{"buggy_code": ["/**\n * @file resolve.c\n * @author Michal Vasko <mvasko@cesnet.cz>\n * @brief libyang resolve functions\n *\n * Copyright (c) 2015 - 2018 CESNET, z.s.p.o.\n *\n * This source code is licensed under BSD 3-Clause License (the \"License\").\n * You may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/BSD-3-Clause\n */\n\n#define _GNU_SOURCE\n\n#include <stdlib.h>\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <limits.h>\n\n#include \"libyang.h\"\n#include \"resolve.h\"\n#include \"common.h\"\n#include \"xpath.h\"\n#include \"parser.h\"\n#include \"parser_yang.h\"\n#include \"xml_internal.h\"\n#include \"hash_table.h\"\n#include \"tree_internal.h\"\n#include \"extensions.h\"\n#include \"validation.h\"\n\n/* internal parsed predicate structure */\nstruct parsed_pred {\n    const struct lys_node *schema;\n    int len;\n    struct {\n        const char *mod_name;\n        int mod_name_len;\n        const char *name;\n        int nam_len;\n        const char *value;\n        int val_len;\n    } *pred;\n};\n\nint\nparse_range_dec64(const char **str_num, uint8_t dig, int64_t *num)\n{\n    const char *ptr;\n    int minus = 0;\n    int64_t ret = 0, prev_ret;\n    int8_t str_exp, str_dig = -1, trailing_zeros = 0;\n\n    ptr = *str_num;\n\n    if (ptr[0] == '-') {\n        minus = 1;\n        ++ptr;\n    } else if (ptr[0] == '+') {\n        ++ptr;\n    }\n\n    if (!isdigit(ptr[0])) {\n        /* there must be at least one */\n        return 1;\n    }\n\n    for (str_exp = 0; isdigit(ptr[0]) || ((ptr[0] == '.') && (str_dig < 0)); ++ptr) {\n        if (str_exp > 18) {\n            return 1;\n        }\n\n        if (ptr[0] == '.') {\n            if (ptr[1] == '.') {\n                /* it's the next interval */\n                break;\n            }\n            ++str_dig;\n        } else {\n            prev_ret = ret;\n            if (minus) {\n                ret = ret * 10 - (ptr[0] - '0');\n                if (ret > prev_ret) {\n                    return 1;\n                }\n            } else {\n                ret = ret * 10 + (ptr[0] - '0');\n                if (ret < prev_ret) {\n                    return 1;\n                }\n            }\n            if (str_dig > -1) {\n                ++str_dig;\n                if (ptr[0] == '0') {\n                    /* possibly trailing zero */\n                    trailing_zeros++;\n                } else {\n                    trailing_zeros = 0;\n                }\n            }\n            ++str_exp;\n        }\n    }\n    if (str_dig == 0) {\n        /* no digits after '.' */\n        return 1;\n    } else if (str_dig == -1) {\n        /* there are 0 numbers after the floating point */\n        str_dig = 0;\n    }\n    /* remove trailing zeros */\n    if (trailing_zeros) {\n        str_dig -= trailing_zeros;\n        str_exp -= trailing_zeros;\n        ret = ret / dec_pow(trailing_zeros);\n    }\n\n    /* it's parsed, now adjust the number based on fraction-digits, if needed */\n    if (str_dig < dig) {\n        if ((str_exp - 1) + (dig - str_dig) > 18) {\n            return 1;\n        }\n        prev_ret = ret;\n        ret *= dec_pow(dig - str_dig);\n        if ((minus && (ret > prev_ret)) || (!minus && (ret < prev_ret))) {\n            return 1;\n        }\n\n    }\n    if (str_dig > dig) {\n        return 1;\n    }\n\n    *str_num = ptr;\n    *num = ret;\n\n    return 0;\n}\n\n/**\n * @brief Parse an identifier.\n *\n * ;; An identifier MUST NOT start with (('X'|'x') ('M'|'m') ('L'|'l'))\n * identifier          = (ALPHA / \"_\")\n *                       *(ALPHA / DIGIT / \"_\" / \"-\" / \".\")\n *\n * @param[in] id Identifier to use.\n *\n * @return Number of characters successfully parsed.\n */\nunsigned int\nparse_identifier(const char *id)\n{\n    unsigned int parsed = 0;\n\n    assert(id);\n\n    if (!isalpha(id[0]) && (id[0] != '_')) {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isalnum(id[0]) || (id[0] == '_') || (id[0] == '-') || (id[0] == '.')) {\n        ++parsed;\n        ++id;\n    }\n\n    return parsed;\n}\n\n/**\n * @brief Parse a node-identifier.\n *\n * node-identifier     = [module-name \":\"] identifier\n *\n * @param[in] id Identifier to use.\n * @param[out] mod_name Points to the module name, NULL if there is not any.\n * @param[out] mod_name_len Length of the module name, 0 if there is not any.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] all_desc Whether the path starts with '/', only supported in extended paths.\n * @param[in] extended Whether to accept an extended path (support for [prefix:]*, /[prefix:]*, /[prefix:]., prefix:#identifier).\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_node_identifier(const char *id, const char **mod_name, int *mod_name_len, const char **name, int *nam_len,\n                      int *all_desc, int extended)\n{\n    int parsed = 0, ret, all_desc_local = 0, first_id_len;\n    const char *first_id;\n\n    assert(id);\n    assert((mod_name && mod_name_len) || (!mod_name && !mod_name_len));\n    assert((name && nam_len) || (!name && !nam_len));\n\n    if (mod_name) {\n        *mod_name = NULL;\n        *mod_name_len = 0;\n    }\n    if (name) {\n        *name = NULL;\n        *nam_len = 0;\n    }\n\n    if (extended) {\n        /* try to parse only the extended expressions */\n        if (id[parsed] == '/') {\n            if (all_desc) {\n                *all_desc = 1;\n            }\n            all_desc_local = 1;\n        } else {\n            if (all_desc) {\n                *all_desc = 0;\n            }\n        }\n\n        /* is there a prefix? */\n        ret = parse_identifier(id + all_desc_local);\n        if (ret > 0) {\n            if (id[all_desc_local + ret] != ':') {\n                /* this is not a prefix, so not an extended id */\n                goto standard_id;\n            }\n\n            if (mod_name) {\n                *mod_name = id + all_desc_local;\n                *mod_name_len = ret;\n            }\n\n            /* \"/\" and \":\" */\n            ret += all_desc_local + 1;\n        } else {\n            ret = all_desc_local;\n        }\n\n        /* parse either \"*\" or \".\" */\n        if (*(id + ret) == '*') {\n            if (name) {\n                *name = id + ret;\n                *nam_len = 1;\n            }\n            ++ret;\n\n            return ret;\n        } else if (*(id + ret) == '.') {\n            if (!all_desc_local) {\n                /* /. is redundant expression, we do not accept it */\n                return -ret;\n            }\n\n            if (name) {\n                *name = id + ret;\n                *nam_len = 1;\n            }\n            ++ret;\n\n            return ret;\n        } else if (*(id + ret) == '#') {\n            if (all_desc_local || !ret) {\n                /* no prefix */\n                return 0;\n            }\n            parsed = ret + 1;\n            if ((ret = parse_identifier(id + parsed)) < 1) {\n                return -parsed + ret;\n            }\n            *name = id + parsed - 1;\n            *nam_len = ret + 1;\n            return parsed + ret;\n        }\n        /* else a standard id, parse it all again */\n    }\n\nstandard_id:\n    if ((ret = parse_identifier(id)) < 1) {\n        return ret;\n    }\n\n    first_id = id;\n    first_id_len = ret;\n\n    parsed += ret;\n    id += ret;\n\n    /* there is prefix */\n    if (id[0] == ':') {\n        ++parsed;\n        ++id;\n\n    /* there isn't */\n    } else {\n        if (name) {\n            *name = first_id;\n            *nam_len = first_id_len;\n        }\n\n        return parsed;\n    }\n\n    /* identifier (node name) */\n    if ((ret = parse_identifier(id)) < 1) {\n        return -parsed + ret;\n    }\n\n    if (mod_name) {\n        *mod_name = first_id;\n        *mod_name_len = first_id_len;\n    }\n    if (name) {\n        *name = id;\n        *nam_len = ret;\n    }\n\n    return parsed + ret;\n}\n\n/**\n * @brief Parse a path-predicate (leafref).\n *\n * path-predicate      = \"[\" *WSP path-equality-expr *WSP \"]\"\n * path-equality-expr  = node-identifier *WSP \"=\" *WSP path-key-expr\n *\n * @param[in] id Identifier to use.\n * @param[out] prefix Points to the prefix, NULL if there is not any.\n * @param[out] pref_len Length of the prefix, 0 if there is not any.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] path_key_expr Points to the path-key-expr.\n * @param[out] pke_len Length of the path-key-expr.\n * @param[out] has_predicate Flag to mark whether there is another predicate following.\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_path_predicate(const char *id, const char **prefix, int *pref_len, const char **name, int *nam_len,\n                     const char **path_key_expr, int *pke_len, int *has_predicate)\n{\n    const char *ptr;\n    int parsed = 0, ret;\n\n    assert(id);\n    if (prefix) {\n        *prefix = NULL;\n    }\n    if (pref_len) {\n        *pref_len = 0;\n    }\n    if (name) {\n        *name = NULL;\n    }\n    if (nam_len) {\n        *nam_len = 0;\n    }\n    if (path_key_expr) {\n        *path_key_expr = NULL;\n    }\n    if (pke_len) {\n        *pke_len = 0;\n    }\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (id[0] != '[') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    if ((ret = parse_node_identifier(id, prefix, pref_len, name, nam_len, NULL, 0)) < 1) {\n        return -parsed+ret;\n    }\n\n    parsed += ret;\n    id += ret;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    if (id[0] != '=') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    if ((ptr = strchr(id, ']')) == NULL) {\n        return -parsed;\n    }\n\n    --ptr;\n    while (isspace(ptr[0])) {\n        --ptr;\n    }\n    ++ptr;\n\n    ret = ptr-id;\n    if (path_key_expr) {\n        *path_key_expr = id;\n    }\n    if (pke_len) {\n        *pke_len = ret;\n    }\n\n    parsed += ret;\n    id += ret;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    assert(id[0] == ']');\n\n    if (id[1] == '[') {\n        *has_predicate = 1;\n    }\n\n    return parsed+1;\n}\n\n/**\n * @brief Parse a path-key-expr (leafref). First call parses \"current()\", all\n *        the \"..\" and the first node-identifier, other calls parse a single\n *        node-identifier each.\n *\n * path-key-expr       = current-function-invocation *WSP \"/\" *WSP\n *                       rel-path-keyexpr\n * rel-path-keyexpr    = 1*(\"..\" *WSP \"/\" *WSP)\n *                       *(node-identifier *WSP \"/\" *WSP)\n *                       node-identifier\n *\n * @param[in] id Identifier to use.\n * @param[out] prefix Points to the prefix, NULL if there is not any.\n * @param[out] pref_len Length of the prefix, 0 if there is not any.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] parent_times Number of \"..\" in the path. Must be 0 on the first call,\n *                          must not be changed between consecutive calls.\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_path_key_expr(const char *id, const char **prefix, int *pref_len, const char **name, int *nam_len,\n                    int *parent_times)\n{\n    int parsed = 0, ret, par_times = 0;\n\n    assert(id);\n    assert(parent_times);\n    if (prefix) {\n        *prefix = NULL;\n    }\n    if (pref_len) {\n        *pref_len = 0;\n    }\n    if (name) {\n        *name = NULL;\n    }\n    if (nam_len) {\n        *nam_len = 0;\n    }\n\n    if (!*parent_times) {\n        /* current-function-invocation *WSP \"/\" *WSP rel-path-keyexpr */\n        if (strncmp(id, \"current()\", 9)) {\n            return -parsed;\n        }\n\n        parsed += 9;\n        id += 9;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        if (id[0] != '/') {\n            return -parsed;\n        }\n\n        ++parsed;\n        ++id;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        /* rel-path-keyexpr */\n        if (strncmp(id, \"..\", 2)) {\n            return -parsed;\n        }\n        ++par_times;\n\n        parsed += 2;\n        id += 2;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n    }\n\n    /* 1*(\"..\" *WSP \"/\" *WSP) *(node-identifier *WSP \"/\" *WSP) node-identifier\n     *\n     * first parent reference with whitespaces already parsed\n     */\n    if (id[0] != '/') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    while (!strncmp(id, \"..\", 2) && !*parent_times) {\n        ++par_times;\n\n        parsed += 2;\n        id += 2;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        if (id[0] != '/') {\n            return -parsed;\n        }\n\n        ++parsed;\n        ++id;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n    }\n\n    if (!*parent_times) {\n        *parent_times = par_times;\n    }\n\n    /* all parent references must be parsed at this point */\n    if ((ret = parse_node_identifier(id, prefix, pref_len, name, nam_len, NULL, 0)) < 1) {\n        return -parsed + ret;\n    }\n\n    parsed += ret;\n    id += ret;\n\n    return parsed;\n}\n\n/**\n * @brief Parse path-arg (leafref).\n *\n * path-arg            = absolute-path / relative-path\n * absolute-path       = 1*(\"/\" (node-identifier *path-predicate))\n * relative-path       = 1*(\"..\" \"/\") descendant-path\n *\n * @param[in] mod Module of the context node to get correct prefix in case it is not explicitly specified\n * @param[in] id Identifier to use.\n * @param[out] prefix Points to the prefix, NULL if there is not any.\n * @param[out] pref_len Length of the prefix, 0 if there is not any.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] parent_times Number of \"..\" in the path. Must be 0 on the first call,\n *                          must not be changed between consecutive calls. -1 if the\n *                          path is relative.\n * @param[out] has_predicate Flag to mark whether there is a predicate specified.\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_path_arg(const struct lys_module *mod, const char *id, const char **prefix, int *pref_len,\n               const char **name, int *nam_len, int *parent_times, int *has_predicate)\n{\n    int parsed = 0, ret, par_times = 0;\n\n    assert(id);\n    assert(parent_times);\n    if (prefix) {\n        *prefix = NULL;\n    }\n    if (pref_len) {\n        *pref_len = 0;\n    }\n    if (name) {\n        *name = NULL;\n    }\n    if (nam_len) {\n        *nam_len = 0;\n    }\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (!*parent_times && !strncmp(id, \"..\", 2)) {\n        ++par_times;\n\n        parsed += 2;\n        id += 2;\n\n        while (!strncmp(id, \"/..\", 3)) {\n            ++par_times;\n\n            parsed += 3;\n            id += 3;\n        }\n    }\n\n    if (!*parent_times) {\n        if (par_times) {\n            *parent_times = par_times;\n        } else {\n            *parent_times = -1;\n        }\n    }\n\n    if (id[0] != '/') {\n        return -parsed;\n    }\n\n    /* skip '/' */\n    ++parsed;\n    ++id;\n\n    /* node-identifier ([prefix:]identifier) */\n    if ((ret = parse_node_identifier(id, prefix, pref_len, name, nam_len, NULL, 0)) < 1) {\n        return -parsed - ret;\n    }\n    if (prefix && !(*prefix)) {\n        /* actually we always need prefix even it is not specified */\n        *prefix = lys_main_module(mod)->name;\n        *pref_len = strlen(*prefix);\n    }\n\n    parsed += ret;\n    id += ret;\n\n    /* there is no predicate */\n    if ((id[0] == '/') || !id[0]) {\n        return parsed;\n    } else if (id[0] != '[') {\n        return -parsed;\n    }\n\n    if (has_predicate) {\n        *has_predicate = 1;\n    }\n\n    return parsed;\n}\n\n/**\n * @brief Parse instance-identifier in JSON data format. That means that prefixes\n *        are actually model names.\n *\n * instance-identifier = 1*(\"/\" (node-identifier *predicate))\n *\n * @param[in] id Identifier to use.\n * @param[out] model Points to the model name.\n * @param[out] mod_len Length of the model name.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] has_predicate Flag to mark whether there is a predicate specified.\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_instance_identifier(const char *id, const char **model, int *mod_len, const char **name, int *nam_len,\n                          int *has_predicate)\n{\n    int parsed = 0, ret;\n\n    assert(id && model && mod_len && name && nam_len);\n\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (id[0] != '/') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    if ((ret = parse_identifier(id)) < 1) {\n        return ret;\n    }\n\n    *name = id;\n    *nam_len = ret;\n\n    parsed += ret;\n    id += ret;\n\n    if (id[0] == ':') {\n        /* we have prefix */\n        *model = *name;\n        *mod_len = *nam_len;\n\n        ++parsed;\n        ++id;\n\n        if ((ret = parse_identifier(id)) < 1) {\n            return ret;\n        }\n\n        *name = id;\n        *nam_len = ret;\n\n        parsed += ret;\n        id += ret;\n    }\n\n    if (id[0] == '[' && has_predicate) {\n        *has_predicate = 1;\n    }\n\n    return parsed;\n}\n\n/**\n * @brief Parse predicate (instance-identifier) in JSON data format. That means that prefixes\n *        (which are mandatory) are actually model names.\n *\n * predicate           = \"[\" *WSP (predicate-expr / pos) *WSP \"]\"\n * predicate-expr      = (node-identifier / \".\") *WSP \"=\" *WSP\n *                       ((DQUOTE string DQUOTE) /\n *                        (SQUOTE string SQUOTE))\n * pos                 = non-negative-integer-value\n *\n * @param[in] id Identifier to use.\n * @param[out] model Points to the model name.\n * @param[out] mod_len Length of the model name.\n * @param[out] name Points to the node name. Can be identifier (from node-identifier), \".\" or pos.\n * @param[out] nam_len Length of the node name.\n * @param[out] value Value the node-identifier must have (string from the grammar),\n *                   NULL if there is not any.\n * @param[out] val_len Length of the value, 0 if there is not any.\n * @param[out] has_predicate Flag to mark whether there is a predicate specified.\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_predicate(const char *id, const char **model, int *mod_len, const char **name, int *nam_len,\n                const char **value, int *val_len, int *has_predicate)\n{\n    const char *ptr;\n    int parsed = 0, ret;\n    char quote;\n\n    assert(id);\n    if (model) {\n        assert(mod_len);\n        *model = NULL;\n        *mod_len = 0;\n    }\n    if (name) {\n        assert(nam_len);\n        *name = NULL;\n        *nam_len = 0;\n    }\n    if (value) {\n        assert(val_len);\n        *value = NULL;\n        *val_len = 0;\n    }\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (id[0] != '[') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    /* pos */\n    if (isdigit(id[0])) {\n        if (name) {\n            *name = id;\n        }\n\n        if (id[0] == '0') {\n            return -parsed;\n        }\n\n        while (isdigit(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        if (nam_len) {\n            *nam_len = id-(*name);\n        }\n\n    /* \".\" or node-identifier */\n    } else {\n        if (id[0] == '.') {\n            if (name) {\n                *name = id;\n            }\n            if (nam_len) {\n                *nam_len = 1;\n            }\n\n            ++parsed;\n            ++id;\n\n        } else {\n            if ((ret = parse_node_identifier(id, model, mod_len, name, nam_len, NULL, 0)) < 1) {\n                return -parsed + ret;\n            }\n\n            parsed += ret;\n            id += ret;\n        }\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        if (id[0] != '=') {\n            return -parsed;\n        }\n\n        ++parsed;\n        ++id;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        /* ((DQUOTE string DQUOTE) / (SQUOTE string SQUOTE)) */\n        if ((id[0] == '\\\"') || (id[0] == '\\'')) {\n            quote = id[0];\n\n            ++parsed;\n            ++id;\n\n            if ((ptr = strchr(id, quote)) == NULL) {\n                return -parsed;\n            }\n            ret = ptr - id;\n\n            if (value) {\n                *value = id;\n            }\n            if (val_len) {\n                *val_len = ret;\n            }\n\n            parsed += ret + 1;\n            id += ret + 1;\n        } else {\n            return -parsed;\n        }\n    }\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    if (id[0] != ']') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    if ((id[0] == '[') && has_predicate) {\n        *has_predicate = 1;\n    }\n\n    return parsed;\n}\n\n/**\n * @brief Parse schema-nodeid.\n *\n * schema-nodeid       = absolute-schema-nodeid /\n *                       descendant-schema-nodeid\n * absolute-schema-nodeid = 1*(\"/\" node-identifier)\n * descendant-schema-nodeid = [\".\" \"/\"]\n *                       node-identifier\n *                       absolute-schema-nodeid\n *\n * @param[in] id Identifier to use.\n * @param[out] mod_name Points to the module name, NULL if there is not any.\n * @param[out] mod_name_len Length of the module name, 0 if there is not any.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] is_relative Flag to mark whether the nodeid is absolute or descendant. Must be -1\n *                         on the first call, must not be changed between consecutive calls.\n * @param[out] has_predicate Flag to mark whether there is a predicate specified. It cannot be\n *                           based on the grammar, in those cases use NULL.\n * @param[in] extended Whether to accept an extended path (support for /[prefix:]*, //[prefix:]*, //[prefix:].).\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nint\nparse_schema_nodeid(const char *id, const char **mod_name, int *mod_name_len, const char **name, int *nam_len,\n                    int *is_relative, int *has_predicate, int *all_desc, int extended)\n{\n    int parsed = 0, ret;\n\n    assert(id);\n    assert(is_relative);\n\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (id[0] != '/') {\n        if (*is_relative != -1) {\n            return -parsed;\n        } else {\n            *is_relative = 1;\n        }\n        if (!strncmp(id, \"./\", 2)) {\n            parsed += 2;\n            id += 2;\n        }\n    } else {\n        if (*is_relative == -1) {\n            *is_relative = 0;\n        }\n        ++parsed;\n        ++id;\n    }\n\n    if ((ret = parse_node_identifier(id, mod_name, mod_name_len, name, nam_len, all_desc, extended)) < 1) {\n        return -parsed + ret;\n    }\n\n    parsed += ret;\n    id += ret;\n\n    if ((id[0] == '[') && has_predicate) {\n        *has_predicate = 1;\n    }\n\n    return parsed;\n}\n\n/**\n * @brief Parse schema predicate (special format internally used).\n *\n * predicate           = \"[\" *WSP predicate-expr *WSP \"]\"\n * predicate-expr      = \".\" / [prefix:]identifier / positive-integer / key-with-value\n * key-with-value      = identifier *WSP \"=\" *WSP\n *                       ((DQUOTE string DQUOTE) /\n *                        (SQUOTE string SQUOTE))\n *\n * @param[in] id Identifier to use.\n * @param[out] mod_name Points to the list key module name.\n * @param[out] mod_name_len Length of \\p mod_name.\n * @param[out] name Points to the list key name.\n * @param[out] nam_len Length of \\p name.\n * @param[out] value Points to the key value. If specified, key-with-value is expected.\n * @param[out] val_len Length of \\p value.\n * @param[out] has_predicate Flag to mark whether there is another predicate specified.\n */\nint\nparse_schema_json_predicate(const char *id, const char **mod_name, int *mod_name_len, const char **name, int *nam_len,\n                            const char **value, int *val_len, int *has_predicate)\n{\n    const char *ptr;\n    int parsed = 0, ret;\n    char quote;\n\n    assert(id);\n    if (mod_name) {\n        *mod_name = NULL;\n    }\n    if (mod_name_len) {\n        *mod_name_len = 0;\n    }\n    if (name) {\n        *name = NULL;\n    }\n    if (nam_len) {\n        *nam_len = 0;\n    }\n    if (value) {\n        *value = NULL;\n    }\n    if (val_len) {\n        *val_len = 0;\n    }\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (id[0] != '[') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    /* identifier */\n    if (id[0] == '.') {\n        ret = 1;\n\n        if (name) {\n            *name = id;\n        }\n        if (nam_len) {\n            *nam_len = ret;\n        }\n    } else if (isdigit(id[0])) {\n        if (id[0] == '0') {\n            return -parsed;\n        }\n        ret = 1;\n        while (isdigit(id[ret])) {\n            ++ret;\n        }\n\n        if (name) {\n            *name = id;\n        }\n        if (nam_len) {\n            *nam_len = ret;\n        }\n    } else if ((ret = parse_node_identifier(id, mod_name, mod_name_len, name, nam_len, NULL, 0)) < 1) {\n        return -parsed + ret;\n    }\n\n    parsed += ret;\n    id += ret;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    /* there is value as well */\n    if (id[0] == '=') {\n        if (name && isdigit(**name)) {\n            return -parsed;\n        }\n\n        ++parsed;\n        ++id;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        /* ((DQUOTE string DQUOTE) / (SQUOTE string SQUOTE)) */\n        if ((id[0] == '\\\"') || (id[0] == '\\'')) {\n            quote = id[0];\n\n            ++parsed;\n            ++id;\n\n            if ((ptr = strchr(id, quote)) == NULL) {\n                return -parsed;\n            }\n            ret = ptr - id;\n\n            if (value) {\n                *value = id;\n            }\n            if (val_len) {\n                *val_len = ret;\n            }\n\n            parsed += ret + 1;\n            id += ret + 1;\n        } else {\n            return -parsed;\n        }\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n    }\n\n    if (id[0] != ']') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    if ((id[0] == '[') && has_predicate) {\n        *has_predicate = 1;\n    }\n\n    return parsed;\n}\n\n#ifdef LY_ENABLED_CACHE\n\nstatic int\nresolve_hash_table_find_equal(void *val1_p, void *val2_p, int mod, void *UNUSED(cb_data))\n{\n    struct lyd_node *val2, *elem2;\n    struct parsed_pred pp;\n    const char *str;\n    int i;\n\n    assert(!mod);\n    (void)mod;\n\n    pp = *((struct parsed_pred *)val1_p);\n    val2 = *((struct lyd_node **)val2_p);\n\n    if (val2->schema != pp.schema) {\n        return 0;\n    }\n\n    switch (val2->schema->nodetype) {\n    case LYS_CONTAINER:\n    case LYS_LEAF:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        return 1;\n    case LYS_LEAFLIST:\n        str = ((struct lyd_node_leaf_list *)val2)->value_str;\n        if (!strncmp(str, pp.pred[0].value, pp.pred[0].val_len) && !str[pp.pred[0].val_len]) {\n            return 1;\n        }\n        return 0;\n    case LYS_LIST:\n        assert(((struct lys_node_list *)val2->schema)->keys_size);\n        assert(((struct lys_node_list *)val2->schema)->keys_size == pp.len);\n\n        /* lists with keys, their equivalence is based on their keys */\n        elem2 = val2->child;\n        /* the exact data order is guaranteed */\n        for (i = 0; elem2 && (i < pp.len); ++i) {\n            /* module check */\n            if (pp.pred[i].mod_name) {\n                if (strncmp(lyd_node_module(elem2)->name, pp.pred[i].mod_name, pp.pred[i].mod_name_len)\n                        || lyd_node_module(elem2)->name[pp.pred[i].mod_name_len]) {\n                    break;\n                }\n            } else {\n                if (lyd_node_module(elem2) != lys_node_module(pp.schema)) {\n                    break;\n                }\n            }\n\n            /* name check */\n            if (strncmp(elem2->schema->name, pp.pred[i].name, pp.pred[i].nam_len) || elem2->schema->name[pp.pred[i].nam_len]) {\n                break;\n            }\n\n            /* value check */\n            str = ((struct lyd_node_leaf_list *)elem2)->value_str;\n            if (strncmp(str, pp.pred[i].value, pp.pred[i].val_len) || str[pp.pred[i].val_len]) {\n                break;\n            }\n\n            /* next key */\n            elem2 = elem2->next;\n        }\n        if (i == pp.len) {\n            return 1;\n        }\n        return 0;\n    default:\n        break;\n    }\n\n    LOGINT(val2->schema->module->ctx);\n    return 0;\n}\n\nstatic struct lyd_node *\nresolve_json_data_node_hash(struct lyd_node *parent, struct parsed_pred pp)\n{\n    values_equal_cb prev_cb;\n    struct lyd_node **ret = NULL;\n    uint32_t hash;\n    int i;\n\n    assert(parent && parent->hash);\n\n    /* set our value equivalence callback that does not require data nodes */\n    prev_cb = lyht_set_cb(parent->ht, resolve_hash_table_find_equal);\n\n    /* get the hash of the searched node */\n    hash = dict_hash_multi(0, lys_node_module(pp.schema)->name, strlen(lys_node_module(pp.schema)->name));\n    hash = dict_hash_multi(hash, pp.schema->name, strlen(pp.schema->name));\n    if (pp.schema->nodetype == LYS_LEAFLIST) {\n        assert((pp.len == 1) && (pp.pred[0].name[0] == '.') && (pp.pred[0].nam_len == 1));\n        /* leaf-list value in predicate */\n        hash = dict_hash_multi(hash, pp.pred[0].value, pp.pred[0].val_len);\n    } else if (pp.schema->nodetype == LYS_LIST) {\n        /* list keys in predicates */\n        for (i = 0; i < pp.len; ++i) {\n            hash = dict_hash_multi(hash, pp.pred[i].value, pp.pred[i].val_len);\n        }\n    }\n    hash = dict_hash_multi(hash, NULL, 0);\n\n    /* try to find the node */\n    i = lyht_find(parent->ht, &pp, hash, (void **)&ret);\n    assert(i || *ret);\n\n    /* restore the original callback */\n    lyht_set_cb(parent->ht, prev_cb);\n\n    return (i ? NULL : *ret);\n}\n\n#endif\n\n/**\n * @brief Resolve (find) a feature definition. Logs directly.\n *\n * @param[in] feat_name Feature name to resolve.\n * @param[in] len Length of \\p feat_name.\n * @param[in] node Node with the if-feature expression.\n * @param[out] feature Pointer to be set to point to the feature definition, if feature not found\n * (return code 1), the pointer is untouched.\n *\n * @return 0 on success, 1 on forward reference, -1 on error.\n */\nstatic int\nresolve_feature(const char *feat_name, uint16_t len, const struct lys_node *node, struct lys_feature **feature)\n{\n    char *str;\n    const char *mod_name, *name;\n    int mod_name_len, nam_len, i, j;\n    const struct lys_module *module;\n\n    assert(feature);\n\n    /* check prefix */\n    if ((i = parse_node_identifier(feat_name, &mod_name, &mod_name_len, &name, &nam_len, NULL, 0)) < 1) {\n        LOGVAL(node->module->ctx, LYE_INCHAR, LY_VLOG_NONE, NULL, feat_name[-i], &feat_name[-i]);\n        return -1;\n    }\n\n    module = lyp_get_module(lys_node_module(node), NULL, 0, mod_name, mod_name_len, 0);\n    if (!module) {\n        /* identity refers unknown data model */\n        LOGVAL(node->module->ctx, LYE_INMOD_LEN, LY_VLOG_NONE, NULL, mod_name_len, mod_name);\n        return -1;\n    }\n\n    if (module != node->module && module == lys_node_module(node)) {\n        /* first, try to search directly in submodule where the feature was mentioned */\n        for (j = 0; j < node->module->features_size; j++) {\n            if (!strncmp(name, node->module->features[j].name, nam_len) && !node->module->features[j].name[nam_len]) {\n                /* check status */\n                if (lyp_check_status(node->flags, lys_node_module(node), node->name, node->module->features[j].flags,\n                                     node->module->features[j].module, node->module->features[j].name, NULL)) {\n                    return -1;\n                }\n                *feature = &node->module->features[j];\n                return 0;\n            }\n        }\n    }\n\n    /* search in the identified module ... */\n    for (j = 0; j < module->features_size; j++) {\n        if (!strncmp(name, module->features[j].name, nam_len) && !module->features[j].name[nam_len]) {\n            /* check status */\n            if (lyp_check_status(node->flags, lys_node_module(node), node->name, module->features[j].flags,\n                                 module->features[j].module, module->features[j].name, NULL)) {\n                return -1;\n            }\n            *feature = &module->features[j];\n            return 0;\n        }\n    }\n    /* ... and all its submodules */\n    for (i = 0; i < module->inc_size && module->inc[i].submodule; i++) {\n        for (j = 0; j < module->inc[i].submodule->features_size; j++) {\n            if (!strncmp(name, module->inc[i].submodule->features[j].name, nam_len)\n                    && !module->inc[i].submodule->features[j].name[nam_len]) {\n                /* check status */\n                if (lyp_check_status(node->flags, lys_node_module(node), node->name,\n                                     module->inc[i].submodule->features[j].flags,\n                                     module->inc[i].submodule->features[j].module,\n                                     module->inc[i].submodule->features[j].name, NULL)) {\n                    return -1;\n                }\n                *feature = &module->inc[i].submodule->features[j];\n                return 0;\n            }\n        }\n    }\n\n    /* not found */\n    str = strndup(feat_name, len);\n    LOGVAL(node->module->ctx, LYE_INRESOLV, LY_VLOG_NONE, NULL, \"feature\", str);\n    free(str);\n    return 1;\n}\n\n/*\n * @return\n *  -  1 if enabled\n *  -  0 if disabled\n */\nstatic int\nresolve_feature_value(const struct lys_feature *feat)\n{\n    int i;\n\n    for (i = 0; i < feat->iffeature_size; i++) {\n        if (!resolve_iffeature(&feat->iffeature[i])) {\n            return 0;\n        }\n    }\n\n    return feat->flags & LYS_FENABLED ? 1 : 0;\n}\n\nstatic int\nresolve_iffeature_recursive(struct lys_iffeature *expr, int *index_e, int *index_f)\n{\n    uint8_t op;\n    int a, b;\n\n    op = iff_getop(expr->expr, *index_e);\n    (*index_e)++;\n\n    switch (op) {\n    case LYS_IFF_F:\n        /* resolve feature */\n        return resolve_feature_value(expr->features[(*index_f)++]);\n    case LYS_IFF_NOT:\n        /* invert result */\n        return resolve_iffeature_recursive(expr, index_e, index_f) ? 0 : 1;\n    case LYS_IFF_AND:\n    case LYS_IFF_OR:\n        a = resolve_iffeature_recursive(expr, index_e, index_f);\n        b = resolve_iffeature_recursive(expr, index_e, index_f);\n        if (op == LYS_IFF_AND) {\n            return a && b;\n        } else { /* LYS_IFF_OR */\n            return a || b;\n        }\n    }\n\n    return 0;\n}\n\nint\nresolve_iffeature(struct lys_iffeature *expr)\n{\n    int index_e = 0, index_f = 0;\n\n    if (expr->expr) {\n        return resolve_iffeature_recursive(expr, &index_e, &index_f);\n    }\n    return 0;\n}\n\nstruct iff_stack {\n    int size;\n    int index;     /* first empty item */\n    uint8_t *stack;\n};\n\nstatic int\niff_stack_push(struct iff_stack *stack, uint8_t value)\n{\n    if (stack->index == stack->size) {\n        stack->size += 4;\n        stack->stack = ly_realloc(stack->stack, stack->size * sizeof *stack->stack);\n        LY_CHECK_ERR_RETURN(!stack->stack, LOGMEM(NULL); stack->size = 0, EXIT_FAILURE);\n    }\n\n    stack->stack[stack->index++] = value;\n    return EXIT_SUCCESS;\n}\n\nstatic uint8_t\niff_stack_pop(struct iff_stack *stack)\n{\n    stack->index--;\n    return stack->stack[stack->index];\n}\n\nstatic void\niff_stack_clean(struct iff_stack *stack)\n{\n    stack->size = 0;\n    free(stack->stack);\n}\n\nstatic void\niff_setop(uint8_t *list, uint8_t op, int pos)\n{\n    uint8_t *item;\n    uint8_t mask = 3;\n\n    assert(pos >= 0);\n    assert(op <= 3); /* max 2 bits */\n\n    item = &list[pos / 4];\n    mask = mask << 2 * (pos % 4);\n    *item = (*item) & ~mask;\n    *item = (*item) | (op << 2 * (pos % 4));\n}\n\nuint8_t\niff_getop(uint8_t *list, int pos)\n{\n    uint8_t *item;\n    uint8_t mask = 3, result;\n\n    assert(pos >= 0);\n\n    item = &list[pos / 4];\n    result = (*item) & (mask << 2 * (pos % 4));\n    return result >> 2 * (pos % 4);\n}\n\n#define LYS_IFF_LP 0x04 /* ( */\n#define LYS_IFF_RP 0x08 /* ) */\n\n/* internal structure for passing data for UNRES_IFFEAT */\nstruct unres_iffeat_data {\n    struct lys_node *node;\n    const char *fname;\n    int infeature;\n};\n\nvoid\nresolve_iffeature_getsizes(struct lys_iffeature *iffeat, unsigned int *expr_size, unsigned int *feat_size)\n{\n    unsigned int e = 0, f = 0, r = 0;\n    uint8_t op;\n\n    assert(iffeat);\n\n    if (!iffeat->expr) {\n        goto result;\n    }\n\n    do {\n        op = iff_getop(iffeat->expr, e++);\n        switch (op) {\n        case LYS_IFF_NOT:\n            if (!r) {\n                r += 1;\n            }\n            break;\n        case LYS_IFF_AND:\n        case LYS_IFF_OR:\n            if (!r) {\n                r += 2;\n            } else {\n                r += 1;\n            }\n            break;\n        case LYS_IFF_F:\n            f++;\n            if (r) {\n                r--;\n            }\n            break;\n        }\n    } while(r);\n\nresult:\n    if (expr_size) {\n        *expr_size = e;\n    }\n    if (feat_size) {\n        *feat_size = f;\n    }\n}\n\nint\nresolve_iffeature_compile(struct lys_iffeature *iffeat_expr, const char *value, struct lys_node *node,\n                          int infeature, struct unres_schema *unres)\n{\n    const char *c = value;\n    int r, rc = EXIT_FAILURE;\n    int i, j, last_not, checkversion = 0;\n    unsigned int f_size = 0, expr_size = 0, f_exp = 1;\n    uint8_t op;\n    struct iff_stack stack = {0, 0, NULL};\n    struct unres_iffeat_data *iff_data;\n    struct ly_ctx *ctx = node->module->ctx;\n\n    assert(c);\n\n    if (isspace(c[0])) {\n        LOGVAL(ctx, LYE_INCHAR, LY_VLOG_NONE, NULL, c[0], c);\n        return EXIT_FAILURE;\n    }\n\n    /* pre-parse the expression to get sizes for arrays, also do some syntax checks of the expression */\n    for (i = j = last_not = 0; c[i]; i++) {\n        if (c[i] == '(') {\n            checkversion = 1;\n            j++;\n            continue;\n        } else if (c[i] == ')') {\n            j--;\n            continue;\n        } else if (isspace(c[i])) {\n            continue;\n        }\n\n        if (!strncmp(&c[i], \"not\", r = 3) || !strncmp(&c[i], \"and\", r = 3) || !strncmp(&c[i], \"or\", r = 2)) {\n            if (c[i + r] == '\\0') {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"if-feature\");\n                return EXIT_FAILURE;\n            } else if (!isspace(c[i + r])) {\n                /* feature name starting with the not/and/or */\n                last_not = 0;\n                f_size++;\n            } else if (c[i] == 'n') { /* not operation */\n                if (last_not) {\n                    /* double not */\n                    expr_size = expr_size - 2;\n                    last_not = 0;\n                } else {\n                    last_not = 1;\n                }\n            } else { /* and, or */\n                f_exp++;\n                /* not a not operation */\n                last_not = 0;\n            }\n            i += r;\n        } else {\n            f_size++;\n            last_not = 0;\n        }\n        expr_size++;\n\n        while (!isspace(c[i])) {\n            if (!c[i] || c[i] == ')') {\n                i--;\n                break;\n            }\n            i++;\n        }\n    }\n    if (j || f_exp != f_size) {\n        /* not matching count of ( and ) */\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"if-feature\");\n        return EXIT_FAILURE;\n    }\n\n    if (checkversion || expr_size > 1) {\n        /* check that we have 1.1 module */\n        if (node->module->version != LYS_VERSION_1_1) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"if-feature\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"YANG 1.1 if-feature expression found in 1.0 module.\");\n            return EXIT_FAILURE;\n        }\n    }\n\n    /* allocate the memory */\n    iffeat_expr->expr = calloc((j = (expr_size / 4) + ((expr_size % 4) ? 1 : 0)), sizeof *iffeat_expr->expr);\n    iffeat_expr->features = calloc(f_size, sizeof *iffeat_expr->features);\n    stack.stack = malloc(expr_size * sizeof *stack.stack);\n    LY_CHECK_ERR_GOTO(!stack.stack || !iffeat_expr->expr || !iffeat_expr->features, LOGMEM(ctx), error);\n    stack.size = expr_size;\n    f_size--; expr_size--; /* used as indexes from now */\n\n    for (i--; i >= 0; i--) {\n        if (c[i] == ')') {\n            /* push it on stack */\n            iff_stack_push(&stack, LYS_IFF_RP);\n            continue;\n        } else if (c[i] == '(') {\n            /* pop from the stack into result all operators until ) */\n            while((op = iff_stack_pop(&stack)) != LYS_IFF_RP) {\n                iff_setop(iffeat_expr->expr, op, expr_size--);\n            }\n            continue;\n        } else if (isspace(c[i])) {\n            continue;\n        }\n\n        /* end operator or operand -> find beginning and get what is it */\n        j = i + 1;\n        while (i >= 0 && !isspace(c[i]) && c[i] != '(') {\n            i--;\n        }\n        i++; /* get back by one step */\n\n        if (!strncmp(&c[i], \"not\", 3) && isspace(c[i + 3])) {\n            if (stack.index && stack.stack[stack.index - 1] == LYS_IFF_NOT) {\n                /* double not */\n                iff_stack_pop(&stack);\n            } else {\n                /* not has the highest priority, so do not pop from the stack\n                 * as in case of AND and OR */\n                iff_stack_push(&stack, LYS_IFF_NOT);\n            }\n        } else if (!strncmp(&c[i], \"and\", 3) && isspace(c[i + 3])) {\n            /* as for OR - pop from the stack all operators with the same or higher\n             * priority and store them to the result, then push the AND to the stack */\n            while (stack.index && stack.stack[stack.index - 1] <= LYS_IFF_AND) {\n                op = iff_stack_pop(&stack);\n                iff_setop(iffeat_expr->expr, op, expr_size--);\n            }\n            iff_stack_push(&stack, LYS_IFF_AND);\n        } else if (!strncmp(&c[i], \"or\", 2) && isspace(c[i + 2])) {\n            while (stack.index && stack.stack[stack.index - 1] <= LYS_IFF_OR) {\n                op = iff_stack_pop(&stack);\n                iff_setop(iffeat_expr->expr, op, expr_size--);\n            }\n            iff_stack_push(&stack, LYS_IFF_OR);\n        } else {\n            /* feature name, length is j - i */\n\n            /* add it to the result */\n            iff_setop(iffeat_expr->expr, LYS_IFF_F, expr_size--);\n\n            /* now get the link to the feature definition. Since it can be\n             * forward referenced, we have to keep the feature name in auxiliary\n             * structure passed into unres */\n            iff_data = malloc(sizeof *iff_data);\n            LY_CHECK_ERR_GOTO(!iff_data, LOGMEM(ctx), error);\n            iff_data->node = node;\n            iff_data->fname = lydict_insert(node->module->ctx, &c[i], j - i);\n            iff_data->infeature = infeature;\n            r = unres_schema_add_node(node->module, unres, &iffeat_expr->features[f_size], UNRES_IFFEAT,\n                                      (struct lys_node *)iff_data);\n            f_size--;\n\n            if (r == -1) {\n                lydict_remove(node->module->ctx, iff_data->fname);\n                free(iff_data);\n                goto error;\n            }\n        }\n    }\n    while (stack.index) {\n        op = iff_stack_pop(&stack);\n        iff_setop(iffeat_expr->expr, op, expr_size--);\n    }\n\n    if (++expr_size || ++f_size) {\n        /* not all expected operators and operands found */\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"if-feature\");\n        rc = EXIT_FAILURE;\n    } else {\n        rc = EXIT_SUCCESS;\n    }\n\nerror:\n    /* cleanup */\n    iff_stack_clean(&stack);\n\n    return rc;\n}\n\n/**\n * @brief Resolve (find) a data node based on a schema-nodeid.\n *\n * Used for resolving unique statements - so id is expected to be relative and local (without reference to a different\n * module).\n *\n */\nstruct lyd_node *\nresolve_data_descendant_schema_nodeid(const char *nodeid, struct lyd_node *start)\n{\n    char *str, *token, *p;\n    struct lyd_node *result = NULL, *iter;\n    const struct lys_node *schema = NULL;\n\n    assert(nodeid && start);\n\n    if (nodeid[0] == '/') {\n        return NULL;\n    }\n\n    str = p = strdup(nodeid);\n    LY_CHECK_ERR_RETURN(!str, LOGMEM(start->schema->module->ctx), NULL);\n\n    while (p) {\n        token = p;\n        p = strchr(p, '/');\n        if (p) {\n            *p = '\\0';\n            p++;\n        }\n\n        if (p) {\n            /* inner node */\n            if (resolve_descendant_schema_nodeid(token, schema ? schema->child : start->schema,\n                                                 LYS_CONTAINER | LYS_CHOICE | LYS_CASE | LYS_LEAF, 0, &schema)\n                    || !schema) {\n                result = NULL;\n                break;\n            }\n\n            if (schema->nodetype & (LYS_CHOICE | LYS_CASE)) {\n                continue;\n            }\n        } else {\n            /* final node */\n            if (resolve_descendant_schema_nodeid(token, schema ? schema->child : start->schema, LYS_LEAF, 0, &schema)\n                    || !schema) {\n                result = NULL;\n                break;\n            }\n        }\n        LY_TREE_FOR(result ? result->child : start, iter) {\n            if (iter->schema == schema) {\n                /* move in data tree according to returned schema */\n                result = iter;\n                break;\n            }\n        }\n        if (!iter) {\n            /* instance not found */\n            result = NULL;\n            break;\n        }\n    }\n    free(str);\n\n    return result;\n}\n\nint\nschema_nodeid_siblingcheck(const struct lys_node *sibling, const struct lys_module *cur_module, const char *mod_name,\n                           int mod_name_len, const char *name, int nam_len)\n{\n    const struct lys_module *prefix_mod;\n\n    /* handle special names */\n    if (name[0] == '*') {\n        return 2;\n    } else if (name[0] == '.') {\n        return 3;\n    }\n\n    /* name check */\n    if (strncmp(name, sibling->name, nam_len) || sibling->name[nam_len]) {\n        return 1;\n    }\n\n    /* module check */\n    if (mod_name) {\n        prefix_mod = lyp_get_module(cur_module, NULL, 0, mod_name, mod_name_len, 0);\n        if (!prefix_mod) {\n            return -1;\n        }\n    } else {\n        prefix_mod = cur_module;\n    }\n    if (prefix_mod != lys_node_module(sibling)) {\n        return 1;\n    }\n\n    /* match */\n    return 0;\n}\n\n/* keys do not have to be ordered and do not have to be all of them */\nstatic int\nresolve_extended_schema_nodeid_predicate(const char *nodeid, const struct lys_node *node,\n                                         const struct lys_module *cur_module, int *nodeid_end)\n{\n    int mod_len, nam_len, has_predicate, r, i;\n    const char *model, *name;\n    struct lys_node_list *list;\n\n    if (!(node->nodetype & (LYS_LIST | LYS_LEAFLIST))) {\n        return 1;\n    }\n\n    list = (struct lys_node_list *)node;\n    do {\n        r = parse_schema_json_predicate(nodeid, &model, &mod_len, &name, &nam_len, NULL, NULL, &has_predicate);\n        if (r < 1) {\n            LOGVAL(cur_module->ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, nodeid[r], &nodeid[r]);\n            return -1;\n        }\n        nodeid += r;\n\n        if (node->nodetype == LYS_LEAFLIST) {\n            /* just check syntax */\n            if (model || !name || (name[0] != '.') || has_predicate) {\n                return 1;\n            }\n            break;\n        } else {\n            /* check the key */\n            for (i = 0; i < list->keys_size; ++i) {\n                if (strncmp(list->keys[i]->name, name, nam_len) || list->keys[i]->name[nam_len]) {\n                    continue;\n                }\n                if (model) {\n                    if (strncmp(lys_node_module((struct lys_node *)list->keys[i])->name, model, mod_len)\n                            || lys_node_module((struct lys_node *)list->keys[i])->name[mod_len]) {\n                        continue;\n                    }\n                } else {\n                    if (lys_node_module((struct lys_node *)list->keys[i]) != cur_module) {\n                        continue;\n                    }\n                }\n\n                /* match */\n                break;\n            }\n\n            if (i == list->keys_size) {\n                return 1;\n            }\n        }\n    } while (has_predicate);\n\n    if (!nodeid[0]) {\n        *nodeid_end = 1;\n    }\n    return 0;\n}\n\n/* start_parent - relative, module - absolute, -1 error (logged), EXIT_SUCCESS ok\n */\nint\nresolve_schema_nodeid(const char *nodeid, const struct lys_node *start_parent, const struct lys_module *cur_module,\n                      struct ly_set **ret, int extended, int no_node_error)\n{\n    const char *name, *mod_name, *id, *backup_mod_name = NULL, *yang_data_name = NULL;\n    const struct lys_node *sibling, *next, *elem;\n    struct lys_node_augment *last_aug;\n    int r, nam_len, mod_name_len = 0, is_relative = -1, all_desc, has_predicate, nodeid_end = 0;\n    int yang_data_name_len, backup_mod_name_len = 0;\n    /* resolved import module from the start module, it must match the next node-name-match sibling */\n    const struct lys_module *start_mod, *aux_mod = NULL;\n    char *str;\n    struct ly_ctx *ctx;\n\n    assert(nodeid && (start_parent || cur_module) && ret);\n    *ret = NULL;\n\n    if (!cur_module) {\n        cur_module = lys_node_module(start_parent);\n    }\n    ctx = cur_module->ctx;\n    id = nodeid;\n\n    r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 1);\n    if (r < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[r], &id[r]);\n        return -1;\n    }\n\n    if (name[0] == '#') {\n        if (is_relative) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, '#', name);\n            return -1;\n        }\n        yang_data_name = name + 1;\n        yang_data_name_len = nam_len - 1;\n        backup_mod_name = mod_name;\n        backup_mod_name_len = mod_name_len;\n        id += r;\n    } else {\n        is_relative = -1;\n    }\n\n    r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate,\n                            (extended ? &all_desc : NULL), extended);\n    if (r < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[r], &id[r]);\n        return -1;\n    }\n    id += r;\n\n    if (backup_mod_name) {\n        mod_name = backup_mod_name;\n        mod_name_len = backup_mod_name_len;\n    }\n\n    if (is_relative && !start_parent) {\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_STR, nodeid, \"Starting node must be provided for relative paths.\");\n        return -1;\n    }\n\n    /* descendant-schema-nodeid */\n    if (is_relative) {\n        cur_module = start_mod = lys_node_module(start_parent);\n\n    /* absolute-schema-nodeid */\n    } else {\n        start_mod = lyp_get_module(cur_module, NULL, 0, mod_name, mod_name_len, 0);\n        if (!start_mod) {\n            str = strndup(mod_name, mod_name_len);\n            LOGVAL(ctx, LYE_PATH_INMOD, LY_VLOG_STR, str);\n            free(str);\n            return -1;\n        }\n        start_parent = NULL;\n        if (yang_data_name) {\n            start_parent = lyp_get_yang_data_template(start_mod, yang_data_name, yang_data_name_len);\n            if (!start_parent) {\n                str = strndup(nodeid, (yang_data_name + yang_data_name_len) - nodeid);\n                LOGVAL(ctx, LYE_PATH_INNODE, LY_VLOG_STR, str);\n                free(str);\n                return -1;\n            }\n        }\n    }\n\n    while (1) {\n        sibling = NULL;\n        last_aug = NULL;\n\n        if (start_parent) {\n            if (mod_name && (strncmp(mod_name, cur_module->name, mod_name_len)\n                    || (mod_name_len != (signed)strlen(cur_module->name)))) {\n                /* we are getting into another module (augment) */\n                aux_mod = lyp_get_module(cur_module, NULL, 0, mod_name, mod_name_len, 0);\n                if (!aux_mod) {\n                    str = strndup(mod_name, mod_name_len);\n                    LOGVAL(ctx, LYE_PATH_INMOD, LY_VLOG_STR, str);\n                    free(str);\n                    return -1;\n                }\n            } else {\n                /* there is no mod_name, so why are we checking augments again?\n                 * because this module may be not implemented and it augments something in another module and\n                 * there is another augment augmenting that previous one */\n                aux_mod = cur_module;\n            }\n\n            /* look into augments */\n            if (!extended) {\nget_next_augment:\n                last_aug = lys_getnext_target_aug(last_aug, aux_mod, start_parent);\n            }\n        }\n\n        while ((sibling = lys_getnext(sibling, (last_aug ? (struct lys_node *)last_aug : start_parent), start_mod,\n                LYS_GETNEXT_WITHCHOICE | LYS_GETNEXT_WITHCASE | LYS_GETNEXT_WITHINOUT | LYS_GETNEXT_PARENTUSES | LYS_GETNEXT_NOSTATECHECK))) {\n            r = schema_nodeid_siblingcheck(sibling, cur_module, mod_name, mod_name_len, name, nam_len);\n\n            /* resolve predicate */\n            if (extended && ((r == 0) || (r == 2) || (r == 3)) && has_predicate) {\n                r = resolve_extended_schema_nodeid_predicate(id, sibling, cur_module, &nodeid_end);\n                if (r == 1) {\n                    continue;\n                } else if (r == -1) {\n                    return -1;\n                }\n            } else if (!id[0]) {\n                nodeid_end = 1;\n            }\n\n            if (r == 0) {\n                /* one matching result */\n                if (nodeid_end) {\n                    *ret = ly_set_new();\n                    LY_CHECK_ERR_RETURN(!*ret, LOGMEM(ctx), -1);\n                    ly_set_add(*ret, (void *)sibling, LY_SET_OPT_USEASLIST);\n                } else {\n                    if (sibling->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                        return -1;\n                    }\n                    start_parent = sibling;\n                }\n                break;\n            } else if (r == 1) {\n                continue;\n            } else if (r == 2) {\n                /* \"*\" */\n                if (!*ret) {\n                    *ret = ly_set_new();\n                    LY_CHECK_ERR_RETURN(!*ret, LOGMEM(ctx), -1);\n                }\n                ly_set_add(*ret, (void *)sibling, LY_SET_OPT_USEASLIST);\n                if (all_desc) {\n                    LY_TREE_DFS_BEGIN(sibling, next, elem) {\n                        if (elem != sibling) {\n                            ly_set_add(*ret, (void *)elem, LY_SET_OPT_USEASLIST);\n                        }\n\n                        LY_TREE_DFS_END(sibling, next, elem);\n                    }\n                }\n            } else if (r == 3) {\n                /* \".\" */\n                if (!*ret) {\n                    *ret = ly_set_new();\n                    LY_CHECK_ERR_RETURN(!*ret, LOGMEM(ctx), -1);\n                    ly_set_add(*ret, (void *)start_parent, LY_SET_OPT_USEASLIST);\n                }\n                ly_set_add(*ret, (void *)sibling, LY_SET_OPT_USEASLIST);\n                if (all_desc) {\n                    LY_TREE_DFS_BEGIN(sibling, next, elem) {\n                        if (elem != sibling) {\n                            ly_set_add(*ret, (void *)elem, LY_SET_OPT_USEASLIST);\n                        }\n\n                        LY_TREE_DFS_END(sibling, next, elem);\n                    }\n                }\n            } else {\n                LOGINT(ctx);\n                return -1;\n            }\n        }\n\n        /* skip predicate */\n        if (extended && has_predicate) {\n            while (id[0] == '[') {\n                id = strchr(id, ']');\n                if (!id) {\n                    LOGINT(ctx);\n                    return -1;\n                }\n                ++id;\n            }\n        }\n\n        if (nodeid_end && ((r == 0) || (r == 2) || (r == 3))) {\n            return EXIT_SUCCESS;\n        }\n\n        /* no match */\n        if (!sibling) {\n            if (last_aug) {\n                /* it still could be in another augment */\n                goto get_next_augment;\n            }\n            if (no_node_error) {\n                str = strndup(nodeid, (name - nodeid) + nam_len);\n                LOGVAL(ctx, LYE_PATH_INNODE, LY_VLOG_STR, str);\n                free(str);\n                return -1;\n            }\n            *ret = NULL;\n            return EXIT_SUCCESS;\n        }\n\n        r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate,\n                                (extended ? &all_desc : NULL), extended);\n        if (r < 1) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[r], &id[r]);\n            return -1;\n        }\n        id += r;\n    }\n\n    /* cannot get here */\n    LOGINT(ctx);\n    return -1;\n}\n\n/* unique, refine,\n * >0  - unexpected char on position (ret - 1),\n *  0  - ok (but ret can still be NULL),\n * -1  - error,\n * -2  - violated no_innerlist  */\nint\nresolve_descendant_schema_nodeid(const char *nodeid, const struct lys_node *start, int ret_nodetype,\n                                 int no_innerlist, const struct lys_node **ret)\n{\n    const char *name, *mod_name, *id;\n    const struct lys_node *sibling, *start_parent;\n    int r, nam_len, mod_name_len, is_relative = -1;\n    /* resolved import module from the start module, it must match the next node-name-match sibling */\n    const struct lys_module *module;\n\n    assert(nodeid && ret);\n    assert(!(ret_nodetype & (LYS_USES | LYS_AUGMENT | LYS_GROUPING)));\n\n    if (!start) {\n        /* leaf not found */\n        return 0;\n    }\n\n    id = nodeid;\n    module = lys_node_module(start);\n\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 0)) < 1) {\n        return ((id - nodeid) - r) + 1;\n    }\n    id += r;\n\n    if (!is_relative) {\n        return -1;\n    }\n\n    start_parent = lys_parent(start);\n    while ((start_parent->nodetype == LYS_USES) && lys_parent(start_parent)) {\n        start_parent = lys_parent(start_parent);\n    }\n\n    while (1) {\n        sibling = NULL;\n        while ((sibling = lys_getnext(sibling, start_parent, module,\n                LYS_GETNEXT_WITHCHOICE | LYS_GETNEXT_WITHCASE | LYS_GETNEXT_PARENTUSES | LYS_GETNEXT_NOSTATECHECK))) {\n            r = schema_nodeid_siblingcheck(sibling, module, mod_name, mod_name_len, name, nam_len);\n            if (r == 0) {\n                if (!id[0]) {\n                    if (!(sibling->nodetype & ret_nodetype)) {\n                        /* wrong node type, too bad */\n                        continue;\n                    }\n                    *ret = sibling;\n                    return EXIT_SUCCESS;\n                }\n                start_parent = sibling;\n                break;\n            } else if (r == 1) {\n                continue;\n            } else {\n                return -1;\n            }\n        }\n\n        /* no match */\n        if (!sibling) {\n            *ret = NULL;\n            return EXIT_SUCCESS;\n        } else if (no_innerlist && sibling->nodetype == LYS_LIST) {\n            *ret = NULL;\n            return -2;\n        }\n\n        if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 0)) < 1) {\n            return ((id - nodeid) - r) + 1;\n        }\n        id += r;\n    }\n\n    /* cannot get here */\n    LOGINT(module->ctx);\n    return -1;\n}\n\n/* choice default */\nint\nresolve_choice_default_schema_nodeid(const char *nodeid, const struct lys_node *start, const struct lys_node **ret)\n{\n    /* cannot actually be a path */\n    if (strchr(nodeid, '/')) {\n        return -1;\n    }\n\n    return resolve_descendant_schema_nodeid(nodeid, start, LYS_NO_RPC_NOTIF_NODE, 0, ret);\n}\n\n/* uses, -1 error, EXIT_SUCCESS ok (but ret can still be NULL), >0 unexpected char on ret - 1 */\nstatic int\nresolve_uses_schema_nodeid(const char *nodeid, const struct lys_node *start, const struct lys_node_grp **ret)\n{\n    const struct lys_module *module;\n    const char *mod_prefix, *name;\n    int i, mod_prefix_len, nam_len;\n\n    /* parse the identifier, it must be parsed on one call */\n    if (((i = parse_node_identifier(nodeid, &mod_prefix, &mod_prefix_len, &name, &nam_len, NULL, 0)) < 1) || nodeid[i]) {\n        return -i + 1;\n    }\n\n    module = lyp_get_module(start->module, mod_prefix, mod_prefix_len, NULL, 0, 0);\n    if (!module) {\n        return -1;\n    }\n    if (module != lys_main_module(start->module)) {\n        start = module->data;\n    }\n\n    *ret = lys_find_grouping_up(name, (struct lys_node *)start);\n\n    return EXIT_SUCCESS;\n}\n\nint\nresolve_absolute_schema_nodeid(const char *nodeid, const struct lys_module *module, int ret_nodetype,\n                               const struct lys_node **ret)\n{\n    const char *name, *mod_name, *id;\n    const struct lys_node *sibling, *start_parent;\n    int r, nam_len, mod_name_len, is_relative = -1;\n    const struct lys_module *abs_start_mod;\n\n    assert(nodeid && module && ret);\n    assert(!(ret_nodetype & (LYS_USES | LYS_AUGMENT)) && ((ret_nodetype == LYS_GROUPING) || !(ret_nodetype & LYS_GROUPING)));\n\n    id = nodeid;\n    start_parent = NULL;\n\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 0)) < 1) {\n        return ((id - nodeid) - r) + 1;\n    }\n    id += r;\n\n    if (is_relative) {\n        return -1;\n    }\n\n    abs_start_mod = lyp_get_module(module, NULL, 0, mod_name, mod_name_len, 0);\n    if (!abs_start_mod) {\n        return -1;\n    }\n\n    while (1) {\n        sibling = NULL;\n        while ((sibling = lys_getnext(sibling, start_parent, abs_start_mod, LYS_GETNEXT_WITHCHOICE\n                | LYS_GETNEXT_WITHCASE | LYS_GETNEXT_WITHINOUT | LYS_GETNEXT_WITHGROUPING | LYS_GETNEXT_NOSTATECHECK))) {\n            r = schema_nodeid_siblingcheck(sibling, module, mod_name, mod_name_len, name, nam_len);\n            if (r == 0) {\n                if (!id[0]) {\n                    if (!(sibling->nodetype & ret_nodetype)) {\n                        /* wrong node type, too bad */\n                        continue;\n                    }\n                    *ret = sibling;\n                    return EXIT_SUCCESS;\n                }\n                start_parent = sibling;\n                break;\n            } else if (r == 1) {\n                continue;\n            } else {\n                return -1;\n            }\n        }\n\n        /* no match */\n        if (!sibling) {\n            *ret = NULL;\n            return EXIT_SUCCESS;\n        }\n\n        if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 0)) < 1) {\n            return ((id - nodeid) - r) + 1;\n        }\n        id += r;\n    }\n\n    /* cannot get here */\n    LOGINT(module->ctx);\n    return -1;\n}\n\nstatic int\nresolve_json_schema_list_predicate(const char *predicate, const struct lys_node_list *list, int *parsed)\n{\n    const char *mod_name, *name;\n    int mod_name_len, nam_len, has_predicate, i;\n    struct lys_node *key;\n\n    if (((i = parse_schema_json_predicate(predicate, &mod_name, &mod_name_len, &name, &nam_len, NULL, NULL, &has_predicate)) < 1)\n            || !strncmp(name, \".\", nam_len)) {\n        LOGVAL(list->module->ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, predicate[-i], &predicate[-i]);\n        return -1;\n    }\n\n    predicate += i;\n    *parsed += i;\n\n    if (!isdigit(name[0])) {\n        for (i = 0; i < list->keys_size; ++i) {\n            key = (struct lys_node *)list->keys[i];\n            if (!strncmp(key->name, name, nam_len) && !key->name[nam_len]) {\n                break;\n            }\n        }\n\n        if (i == list->keys_size) {\n            LOGVAL(list->module->ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, name);\n            return -1;\n        }\n    }\n\n    /* more predicates? */\n    if (has_predicate) {\n        return resolve_json_schema_list_predicate(predicate, list, parsed);\n    }\n\n    return 0;\n}\n\n/* cannot return LYS_GROUPING, LYS_AUGMENT, LYS_USES, logs directly */\nconst struct lys_node *\nresolve_json_nodeid(const char *nodeid, struct ly_ctx *ctx, const struct lys_node *start, int output)\n{\n    char *str;\n    const char *name, *mod_name, *id, *backup_mod_name = NULL, *yang_data_name = NULL;\n    const struct lys_node *sibling, *start_parent, *parent;\n    int r, nam_len, mod_name_len, is_relative = -1, has_predicate;\n    int yang_data_name_len, backup_mod_name_len;\n    /* resolved import module from the start module, it must match the next node-name-match sibling */\n    const struct lys_module *prefix_mod, *module, *prev_mod;\n\n    assert(nodeid && (ctx || start));\n    if (!ctx) {\n        ctx = start->module->ctx;\n    }\n\n    id = nodeid;\n\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 1)) < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n        return NULL;\n    }\n\n    if (name[0] == '#') {\n        if (is_relative) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, '#', name);\n            return NULL;\n        }\n        yang_data_name = name + 1;\n        yang_data_name_len = nam_len - 1;\n        backup_mod_name = mod_name;\n        backup_mod_name_len = mod_name_len;\n        id += r;\n    } else {\n        is_relative = -1;\n    }\n\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate, NULL, 0)) < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n        return NULL;\n    }\n    id += r;\n\n    if (backup_mod_name) {\n        mod_name = backup_mod_name;\n        mod_name_len = backup_mod_name_len;\n    }\n\n    if (is_relative) {\n        assert(start);\n        start_parent = start;\n        while (start_parent && (start_parent->nodetype == LYS_USES)) {\n            start_parent = lys_parent(start_parent);\n        }\n        module = start->module;\n    } else {\n        if (!mod_name) {\n            str = strndup(nodeid, (name + nam_len) - nodeid);\n            LOGVAL(ctx, LYE_PATH_MISSMOD, LY_VLOG_STR, nodeid);\n            free(str);\n            return NULL;\n        }\n\n        str = strndup(mod_name, mod_name_len);\n        module = ly_ctx_get_module(ctx, str, NULL, 1);\n        free(str);\n\n        if (!module) {\n            str = strndup(nodeid, (mod_name + mod_name_len) - nodeid);\n            LOGVAL(ctx, LYE_PATH_INMOD, LY_VLOG_STR, str);\n            free(str);\n            return NULL;\n        }\n        start_parent = NULL;\n        if (yang_data_name) {\n            start_parent = lyp_get_yang_data_template(module, yang_data_name, yang_data_name_len);\n            if (!start_parent) {\n                str = strndup(nodeid, (yang_data_name + yang_data_name_len) - nodeid);\n                LOGVAL(ctx, LYE_PATH_INNODE, LY_VLOG_STR, str);\n                free(str);\n                return NULL;\n            }\n        }\n\n        /* now it's as if there was no module name */\n        mod_name = NULL;\n        mod_name_len = 0;\n    }\n\n    prev_mod = module;\n\n    while (1) {\n        sibling = NULL;\n        while ((sibling = lys_getnext(sibling, start_parent, module, 0))) {\n            /* name match */\n            if (sibling->name && !strncmp(name, sibling->name, nam_len) && !sibling->name[nam_len]) {\n                /* output check */\n                for (parent = lys_parent(sibling); parent && !(parent->nodetype & (LYS_INPUT | LYS_OUTPUT)); parent = lys_parent(parent));\n                if (parent) {\n                    if (output && (parent->nodetype == LYS_INPUT)) {\n                        continue;\n                    } else if (!output && (parent->nodetype == LYS_OUTPUT)) {\n                        continue;\n                    }\n                }\n\n                /* module check */\n                if (mod_name) {\n                    /* will also find an augment module */\n                    prefix_mod = ly_ctx_nget_module(ctx, mod_name, mod_name_len, NULL, 1);\n\n                    if (!prefix_mod) {\n                        str = strndup(nodeid, (mod_name + mod_name_len) - nodeid);\n                        LOGVAL(ctx, LYE_PATH_INMOD, LY_VLOG_STR, str);\n                        free(str);\n                        return NULL;\n                    }\n                } else {\n                    prefix_mod = prev_mod;\n                }\n                if (prefix_mod != lys_node_module(sibling)) {\n                    continue;\n                }\n\n                /* do we have some predicates on it? */\n                if (has_predicate) {\n                    r = 0;\n                    if (sibling->nodetype & (LYS_LEAF | LYS_LEAFLIST)) {\n                        if ((r = parse_schema_json_predicate(id, NULL, NULL, NULL, NULL, NULL, NULL, &has_predicate)) < 1) {\n                            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n                            return NULL;\n                        }\n                    } else if (sibling->nodetype == LYS_LIST) {\n                        if (resolve_json_schema_list_predicate(id, (const struct lys_node_list *)sibling, &r)) {\n                            return NULL;\n                        }\n                    } else {\n                        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n                        return NULL;\n                    }\n                    id += r;\n                }\n\n                /* the result node? */\n                if (!id[0]) {\n                    return sibling;\n                }\n\n                /* move down the tree, if possible */\n                if (sibling->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                    LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n                    return NULL;\n                }\n                start_parent = sibling;\n\n                /* update prev mod */\n                prev_mod = (start_parent->child ? lys_node_module(start_parent->child) : module);\n                break;\n            }\n        }\n\n        /* no match */\n        if (!sibling) {\n            str = strndup(nodeid, (name + nam_len) - nodeid);\n            LOGVAL(ctx, LYE_PATH_INNODE, LY_VLOG_STR, str);\n            free(str);\n            return NULL;\n        }\n\n        if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate, NULL, 0)) < 1) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n            return NULL;\n        }\n        id += r;\n    }\n\n    /* cannot get here */\n    LOGINT(ctx);\n    return NULL;\n}\n\nstatic int\nresolve_partial_json_data_list_predicate(struct parsed_pred pp, struct lyd_node *node, int position)\n{\n    uint16_t i;\n    struct lyd_node_leaf_list *key;\n    struct lys_node_list *slist;\n    struct ly_ctx *ctx;\n\n    assert(node);\n    assert(node->schema->nodetype == LYS_LIST);\n    assert(pp.len);\n\n    ctx = node->schema->module->ctx;\n    slist = (struct lys_node_list *)node->schema;\n\n    /* is the predicate a number? */\n    if (isdigit(pp.pred[0].name[0])) {\n        if (position == atoi(pp.pred[0].name)) {\n            /* match */\n            return 0;\n        } else {\n            /* not a match */\n            return 1;\n        }\n    }\n\n    key = (struct lyd_node_leaf_list *)node->child;\n    if (!key) {\n        /* it is not a position, so we need a key for it to be a match */\n        return 1;\n    }\n\n    /* go through all the keys */\n    for (i = 0; i < slist->keys_size; ++i) {\n        if (strncmp(key->schema->name, pp.pred[i].name, pp.pred[i].nam_len) || key->schema->name[pp.pred[i].nam_len]) {\n            LOGVAL(ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, pp.pred[i].name);\n            return -1;\n        }\n\n        if (pp.pred[i].mod_name) {\n            /* specific module, check that the found key is from that module */\n            if (strncmp(lyd_node_module((struct lyd_node *)key)->name, pp.pred[i].mod_name, pp.pred[i].mod_name_len)\n                    || lyd_node_module((struct lyd_node *)key)->name[pp.pred[i].mod_name_len]) {\n                LOGVAL(ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, pp.pred[i].name);\n                return -1;\n            }\n\n            /* but if the module is the same as the parent, it should have been omitted */\n            if (lyd_node_module((struct lyd_node *)key) == lyd_node_module(node)) {\n                LOGVAL(ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, pp.pred[i].name);\n                return -1;\n            }\n        } else {\n            /* no module, so it must be the same as the list (parent) */\n            if (lyd_node_module((struct lyd_node *)key) != lyd_node_module(node)) {\n                LOGVAL(ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, pp.pred[i].name);\n                return -1;\n            }\n        }\n\n        /* value does not match */\n        if (strncmp(key->value_str, pp.pred[i].value, pp.pred[i].val_len) || key->value_str[pp.pred[i].val_len]) {\n            return 1;\n        }\n\n        key = (struct lyd_node_leaf_list *)key->next;\n    }\n\n    return 0;\n}\n\n/**\n * @brief get the closest parent of the node (or the node itself) identified by the nodeid (path)\n *\n * @param[in] nodeid Node data path to find\n * @param[in] llist_value If the \\p nodeid identifies leaf-list, this is expected value of the leaf-list instance.\n * @param[in] options Bitmask of options flags, see @ref pathoptions.\n * @param[out] parsed Number of characters processed in \\p id\n * @return The closes parent (or the node itself) from the path\n */\nstruct lyd_node *\nresolve_partial_json_data_nodeid(const char *nodeid, const char *llist_value, struct lyd_node *start, int options,\n                                 int *parsed)\n{\n    const char *id, *mod_name, *name, *data_val, *llval;\n    int r, ret, mod_name_len, nam_len, is_relative = -1, list_instance_position;\n    int has_predicate, last_parsed = 0, llval_len;\n    struct lyd_node *sibling, *last_match = NULL;\n    struct lyd_node_leaf_list *llist;\n    const struct lys_module *prev_mod;\n    struct ly_ctx *ctx;\n    const struct lys_node *ssibling, *sparent;\n    struct lys_node_list *slist;\n    struct parsed_pred pp;\n\n    assert(nodeid && start && parsed);\n\n    memset(&pp, 0, sizeof pp);\n    ctx = start->schema->module->ctx;\n    id = nodeid;\n\n    /* parse first nodeid in case it is yang-data extension */\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 1)) < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n        goto error;\n    }\n\n    if (name[0] == '#') {\n        if (is_relative) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, '#', name);\n            goto error;\n        }\n        id += r;\n        last_parsed = r;\n    } else {\n        is_relative = -1;\n    }\n\n    /* parse first nodeid */\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate, NULL, 0)) < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n        goto error;\n    }\n    id += r;\n    /* add it to parsed only after the data node was actually found */\n    last_parsed += r;\n\n    if (is_relative) {\n        prev_mod = lyd_node_module(start);\n        start = (start->schema->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_RPC | LYS_ACTION | LYS_NOTIF)) ? start->child : NULL;\n    } else {\n        for (; start->parent; start = start->parent);\n        prev_mod = lyd_node_module(start);\n    }\n    if (!start) {\n        /* there are no siblings to search */\n        return NULL;\n    }\n\n    /* do not duplicate code, use predicate parsing from the loop */\n    goto parse_predicates;\n\n    while (1) {\n        /* find the correct schema node first */\n        ssibling = NULL;\n        sparent = (start && start->parent) ? start->parent->schema : NULL;\n        while ((ssibling = lys_getnext(ssibling, sparent, prev_mod, 0))) {\n            /* skip invalid input/output nodes */\n            if (sparent && (sparent->nodetype & (LYS_RPC | LYS_ACTION))) {\n                if (options & LYD_PATH_OPT_OUTPUT) {\n                    if (lys_parent(ssibling)->nodetype == LYS_INPUT) {\n                        continue;\n                    }\n                } else {\n                    if (lys_parent(ssibling)->nodetype == LYS_OUTPUT) {\n                        continue;\n                    }\n                }\n            }\n\n            if (!schema_nodeid_siblingcheck(ssibling, prev_mod, mod_name, mod_name_len, name, nam_len)) {\n                break;\n            }\n        }\n        if (!ssibling) {\n            /* there is not even such a schema node */\n            free(pp.pred);\n            return last_match;\n        }\n        pp.schema = ssibling;\n\n        /* unify leaf-list value - it is possible to specify last-node value as both a predicate or parameter if\n         * is a leaf-list, unify both cases and the value will in both cases be in the predicate structure */\n        if (!id[0] && !pp.len && (ssibling->nodetype == LYS_LEAFLIST)) {\n            pp.len = 1;\n            pp.pred = calloc(1, sizeof *pp.pred);\n            LY_CHECK_ERR_GOTO(!pp.pred, LOGMEM(ctx), error);\n\n            pp.pred[0].name = \".\";\n            pp.pred[0].nam_len = 1;\n            pp.pred[0].value = (llist_value ? llist_value : \"\");\n            pp.pred[0].val_len = strlen(pp.pred[0].value);\n        }\n\n        if (ssibling->nodetype & (LYS_LEAFLIST | LYS_LEAF)) {\n            /* check leaf/leaf-list predicate */\n            if (pp.len > 1) {\n                LOGVAL(ctx, LYE_PATH_PREDTOOMANY, LY_VLOG_NONE, NULL);\n                goto error;\n            } else if (pp.len) {\n                if ((pp.pred[0].name[0] != '.') || (pp.pred[0].nam_len != 1)) {\n                    LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, pp.pred[0].name[0], pp.pred[0].name);\n                    goto error;\n                }\n                if ((((struct lys_node_leaf *)ssibling)->type.base == LY_TYPE_IDENT) && !strnchr(pp.pred[0].value, ':', pp.pred[0].val_len)) {\n                    LOGVAL(ctx, LYE_PATH_INIDENTREF, LY_VLOG_LYS, ssibling, pp.pred[0].val_len, pp.pred[0].value);\n                    goto error;\n                }\n            }\n        } else if (ssibling->nodetype == LYS_LIST) {\n            /* list should have predicates for all the keys or position */\n            slist = (struct lys_node_list *)ssibling;\n            if (!pp.len) {\n                /* none match */\n                return last_match;\n            } else if (!isdigit(pp.pred[0].name[0])) {\n                /* list predicate is not a position, so there must be all the keys */\n                if (pp.len > slist->keys_size) {\n                    LOGVAL(ctx, LYE_PATH_PREDTOOMANY, LY_VLOG_NONE, NULL);\n                    goto error;\n                } else if (pp.len < slist->keys_size) {\n                    LOGVAL(ctx, LYE_PATH_MISSKEY, LY_VLOG_NONE, NULL, slist->keys[pp.len]->name);\n                    goto error;\n                }\n                /* check that all identityrefs have module name, otherwise the hash of the list instance will never match!! */\n                for (r = 0; r < pp.len; ++r) {\n                    if ((slist->keys[r]->type.base == LY_TYPE_IDENT) && !strnchr(pp.pred[r].value, ':', pp.pred[r].val_len)) {\n                        LOGVAL(ctx, LYE_PATH_INIDENTREF, LY_VLOG_LYS, slist->keys[r], pp.pred[r].val_len, pp.pred[r].value);\n                        goto error;\n                    }\n                }\n            }\n        } else if (pp.pred) {\n            /* no other nodes allow predicates */\n            LOGVAL(ctx, LYE_PATH_PREDTOOMANY, LY_VLOG_NONE, NULL);\n            goto error;\n        }\n\n#ifdef LY_ENABLED_CACHE\n        /* we will not be matching keyless lists or state leaf-lists this way */\n        if (start->parent && start->parent->ht && ((pp.schema->nodetype != LYS_LIST) || ((struct lys_node_list *)pp.schema)->keys_size)\n                && ((pp.schema->nodetype != LYS_LEAFLIST) || (pp.schema->flags & LYS_CONFIG_W))) {\n            sibling = resolve_json_data_node_hash(start->parent, pp);\n        } else\n#endif\n        {\n            list_instance_position = 0;\n            LY_TREE_FOR(start, sibling) {\n                /* RPC/action data check, return simply invalid argument, because the data tree is invalid */\n                if (lys_parent(sibling->schema)) {\n                    if (options & LYD_PATH_OPT_OUTPUT) {\n                        if (lys_parent(sibling->schema)->nodetype == LYS_INPUT) {\n                            LOGERR(ctx, LY_EINVAL, \"Provided data tree includes some RPC input nodes (%s).\", sibling->schema->name);\n                            goto error;\n                        }\n                    } else {\n                        if (lys_parent(sibling->schema)->nodetype == LYS_OUTPUT) {\n                            LOGERR(ctx, LY_EINVAL, \"Provided data tree includes some RPC output nodes (%s).\", sibling->schema->name);\n                            goto error;\n                        }\n                    }\n                }\n\n                if (sibling->schema != ssibling) {\n                    /* wrong schema node */\n                    continue;\n                }\n\n                /* leaf-list, did we find it with the correct value or not? */\n                if (ssibling->nodetype == LYS_LEAFLIST) {\n                    if (ssibling->flags & LYS_CONFIG_R) {\n                        /* state leaf-lists will never match */\n                        continue;\n                    }\n\n                    llist = (struct lyd_node_leaf_list *)sibling;\n\n                    /* get the expected leaf-list value */\n                    llval = NULL;\n                    llval_len = 0;\n                    if (pp.pred) {\n                        /* it was already checked that it is correct */\n                        llval = pp.pred[0].value;\n                        llval_len = pp.pred[0].val_len;\n\n                    }\n\n                    /* make value canonical (remove module name prefix) unless it was specified with it */\n                    if (llval && !strchr(llval, ':') && (llist->value_type & LY_TYPE_IDENT)\n                            && !strncmp(llist->value_str, lyd_node_module(sibling)->name, strlen(lyd_node_module(sibling)->name))\n                            && (llist->value_str[strlen(lyd_node_module(sibling)->name)] == ':')) {\n                        data_val = llist->value_str + strlen(lyd_node_module(sibling)->name) + 1;\n                    } else {\n                        data_val = llist->value_str;\n                    }\n\n                    if ((!llval && data_val && data_val[0]) || (llval && (strncmp(llval, data_val, llval_len)\n                            || data_val[llval_len]))) {\n                        continue;\n                    }\n\n                } else if (ssibling->nodetype == LYS_LIST) {\n                    /* list, we likely need predicates'n'stuff then, but if without a predicate, we are always creating it */\n                    ++list_instance_position;\n                    ret = resolve_partial_json_data_list_predicate(pp, sibling, list_instance_position);\n                    if (ret == -1) {\n                        goto error;\n                    } else if (ret == 1) {\n                        /* this list instance does not match */\n                        continue;\n                    }\n                }\n\n                break;\n            }\n        }\n\n        /* no match, return last match */\n        if (!sibling) {\n            free(pp.pred);\n            return last_match;\n        }\n\n        /* we found a next matching node */\n        *parsed += last_parsed;\n        last_match = sibling;\n        prev_mod = lyd_node_module(sibling);\n\n        /* the result node? */\n        if (!id[0]) {\n            free(pp.pred);\n            return last_match;\n        }\n\n        /* move down the tree, if possible, and continue */\n        if (ssibling->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n            /* there can be no children even through expected, error */\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n            goto error;\n        } else if (!sibling->child) {\n            /* there could be some children, but are not, return what we found so far */\n            free(pp.pred);\n            return last_match;\n        }\n        start = sibling->child;\n\n        /* parse nodeid */\n        if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate, NULL, 0)) < 1) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n            goto error;\n        }\n        id += r;\n        last_parsed = r;\n\nparse_predicates:\n        /* parse all the predicates */\n        free(pp.pred);\n        pp.schema = NULL;\n        pp.len = 0;\n        pp.pred = NULL;\n        while (has_predicate) {\n            ++pp.len;\n            pp.pred = ly_realloc(pp.pred, pp.len * sizeof *pp.pred);\n            LY_CHECK_ERR_GOTO(!pp.pred, LOGMEM(ctx), error);\n            if ((r = parse_schema_json_predicate(id, &pp.pred[pp.len - 1].mod_name, &pp.pred[pp.len - 1].mod_name_len,\n                                                 &pp.pred[pp.len - 1].name, &pp.pred[pp.len - 1].nam_len, &pp.pred[pp.len - 1].value,\n                                                 &pp.pred[pp.len - 1].val_len, &has_predicate)) < 1) {\n                LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n                goto error;\n            }\n\n            id += r;\n            last_parsed += r;\n        }\n    }\n\nerror:\n    *parsed = -1;\n    free(pp.pred);\n    return NULL;\n}\n\n/**\n * @brief Resolves length or range intervals. Does not log.\n * Syntax is assumed to be correct, *ret MUST be NULL.\n *\n * @param[in] ctx Context for errors.\n * @param[in] str_restr Restriction as a string.\n * @param[in] type Type of the restriction.\n * @param[out] ret Final interval structure that starts with\n * the interval of the initial type, continues with intervals\n * of any superior types derived from the initial one, and\n * finishes with intervals from our \\p type.\n *\n * @return EXIT_SUCCESS on succes, -1 on error.\n */\nint\nresolve_len_ran_interval(struct ly_ctx *ctx, const char *str_restr, struct lys_type *type, struct len_ran_intv **ret)\n{\n    /* 0 - unsigned, 1 - signed, 2 - floating point */\n    int kind;\n    int64_t local_smin = 0, local_smax = 0, local_fmin, local_fmax;\n    uint64_t local_umin, local_umax = 0;\n    uint8_t local_fdig = 0;\n    const char *seg_ptr, *ptr;\n    struct len_ran_intv *local_intv = NULL, *tmp_local_intv = NULL, *tmp_intv, *intv = NULL;\n\n    switch (type->base) {\n    case LY_TYPE_BINARY:\n        kind = 0;\n        local_umin = 0;\n        local_umax = 18446744073709551615UL;\n\n        if (!str_restr && type->info.binary.length) {\n            str_restr = type->info.binary.length->expr;\n        }\n        break;\n    case LY_TYPE_DEC64:\n        kind = 2;\n        local_fmin = __INT64_C(-9223372036854775807) - __INT64_C(1);\n        local_fmax = __INT64_C(9223372036854775807);\n        local_fdig = type->info.dec64.dig;\n\n        if (!str_restr && type->info.dec64.range) {\n            str_restr = type->info.dec64.range->expr;\n        }\n        break;\n    case LY_TYPE_INT8:\n        kind = 1;\n        local_smin = __INT64_C(-128);\n        local_smax = __INT64_C(127);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_INT16:\n        kind = 1;\n        local_smin = __INT64_C(-32768);\n        local_smax = __INT64_C(32767);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_INT32:\n        kind = 1;\n        local_smin = __INT64_C(-2147483648);\n        local_smax = __INT64_C(2147483647);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_INT64:\n        kind = 1;\n        local_smin = __INT64_C(-9223372036854775807) - __INT64_C(1);\n        local_smax = __INT64_C(9223372036854775807);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_UINT8:\n        kind = 0;\n        local_umin = __UINT64_C(0);\n        local_umax = __UINT64_C(255);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_UINT16:\n        kind = 0;\n        local_umin = __UINT64_C(0);\n        local_umax = __UINT64_C(65535);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_UINT32:\n        kind = 0;\n        local_umin = __UINT64_C(0);\n        local_umax = __UINT64_C(4294967295);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_UINT64:\n        kind = 0;\n        local_umin = __UINT64_C(0);\n        local_umax = __UINT64_C(18446744073709551615);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_STRING:\n        kind = 0;\n        local_umin = __UINT64_C(0);\n        local_umax = __UINT64_C(18446744073709551615);\n\n        if (!str_restr && type->info.str.length) {\n            str_restr = type->info.str.length->expr;\n        }\n        break;\n    default:\n        return -1;\n    }\n\n    /* process superior types */\n    if (type->der) {\n        if (resolve_len_ran_interval(ctx, NULL, &type->der->type, &intv)) {\n            return -1;\n        }\n        assert(!intv || (intv->kind == kind));\n    }\n\n    if (!str_restr) {\n        /* we do not have any restriction, return superior ones */\n        *ret = intv;\n        return EXIT_SUCCESS;\n    }\n\n    /* adjust local min and max */\n    if (intv) {\n        tmp_intv = intv;\n\n        if (kind == 0) {\n            local_umin = tmp_intv->value.uval.min;\n        } else if (kind == 1) {\n            local_smin = tmp_intv->value.sval.min;\n        } else if (kind == 2) {\n            local_fmin = tmp_intv->value.fval.min;\n        }\n\n        while (tmp_intv->next) {\n            tmp_intv = tmp_intv->next;\n        }\n\n        if (kind == 0) {\n            local_umax = tmp_intv->value.uval.max;\n        } else if (kind == 1) {\n            local_smax = tmp_intv->value.sval.max;\n        } else if (kind == 2) {\n            local_fmax = tmp_intv->value.fval.max;\n        }\n    }\n\n    /* finally parse our restriction */\n    seg_ptr = str_restr;\n    tmp_intv = NULL;\n    while (1) {\n        if (!tmp_local_intv) {\n            assert(!local_intv);\n            local_intv = malloc(sizeof *local_intv);\n            tmp_local_intv = local_intv;\n        } else {\n            tmp_local_intv->next = malloc(sizeof *tmp_local_intv);\n            tmp_local_intv = tmp_local_intv->next;\n        }\n        LY_CHECK_ERR_GOTO(!tmp_local_intv, LOGMEM(ctx), error);\n\n        tmp_local_intv->kind = kind;\n        tmp_local_intv->type = type;\n        tmp_local_intv->next = NULL;\n\n        /* min */\n        ptr = seg_ptr;\n        while (isspace(ptr[0])) {\n            ++ptr;\n        }\n        if (isdigit(ptr[0]) || (ptr[0] == '+') || (ptr[0] == '-')) {\n            if (kind == 0) {\n                tmp_local_intv->value.uval.min = strtoll(ptr, (char **)&ptr, 10);\n            } else if (kind == 1) {\n                tmp_local_intv->value.sval.min = strtoll(ptr, (char **)&ptr, 10);\n            } else if (kind == 2) {\n                if (parse_range_dec64(&ptr, local_fdig, &tmp_local_intv->value.fval.min)) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, ptr, \"range\");\n                    goto error;\n                }\n            }\n        } else if (!strncmp(ptr, \"min\", 3)) {\n            if (kind == 0) {\n                tmp_local_intv->value.uval.min = local_umin;\n            } else if (kind == 1) {\n                tmp_local_intv->value.sval.min = local_smin;\n            } else if (kind == 2) {\n                tmp_local_intv->value.fval.min = local_fmin;\n            }\n\n            ptr += 3;\n        } else if (!strncmp(ptr, \"max\", 3)) {\n            if (kind == 0) {\n                tmp_local_intv->value.uval.min = local_umax;\n            } else if (kind == 1) {\n                tmp_local_intv->value.sval.min = local_smax;\n            } else if (kind == 2) {\n                tmp_local_intv->value.fval.min = local_fmax;\n            }\n\n            ptr += 3;\n        } else {\n            goto error;\n        }\n\n        while (isspace(ptr[0])) {\n            ptr++;\n        }\n\n        /* no interval or interval */\n        if ((ptr[0] == '|') || !ptr[0]) {\n            if (kind == 0) {\n                tmp_local_intv->value.uval.max = tmp_local_intv->value.uval.min;\n            } else if (kind == 1) {\n                tmp_local_intv->value.sval.max = tmp_local_intv->value.sval.min;\n            } else if (kind == 2) {\n                tmp_local_intv->value.fval.max = tmp_local_intv->value.fval.min;\n            }\n        } else if (!strncmp(ptr, \"..\", 2)) {\n            /* skip \"..\" */\n            ptr += 2;\n            while (isspace(ptr[0])) {\n                ++ptr;\n            }\n\n            /* max */\n            if (isdigit(ptr[0]) || (ptr[0] == '+') || (ptr[0] == '-')) {\n                if (kind == 0) {\n                    tmp_local_intv->value.uval.max = strtoll(ptr, (char **)&ptr, 10);\n                } else if (kind == 1) {\n                    tmp_local_intv->value.sval.max = strtoll(ptr, (char **)&ptr, 10);\n                } else if (kind == 2) {\n                    if (parse_range_dec64(&ptr, local_fdig, &tmp_local_intv->value.fval.max)) {\n                        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, ptr, \"range\");\n                        goto error;\n                    }\n                }\n            } else if (!strncmp(ptr, \"max\", 3)) {\n                if (kind == 0) {\n                    tmp_local_intv->value.uval.max = local_umax;\n                } else if (kind == 1) {\n                    tmp_local_intv->value.sval.max = local_smax;\n                } else if (kind == 2) {\n                    tmp_local_intv->value.fval.max = local_fmax;\n                }\n            } else {\n                goto error;\n            }\n        } else {\n            goto error;\n        }\n\n        /* check min and max in correct order*/\n        if (kind == 0) {\n            /* current segment */\n            if (tmp_local_intv->value.uval.min > tmp_local_intv->value.uval.max) {\n                goto error;\n            }\n            if (tmp_local_intv->value.uval.min < local_umin || tmp_local_intv->value.uval.max > local_umax) {\n                goto error;\n            }\n            /* segments sholud be ascending order */\n            if (tmp_intv && (tmp_intv->value.uval.max >= tmp_local_intv->value.uval.min)) {\n                goto error;\n            }\n        } else if (kind == 1) {\n            if (tmp_local_intv->value.sval.min > tmp_local_intv->value.sval.max) {\n                goto error;\n            }\n            if (tmp_local_intv->value.sval.min < local_smin || tmp_local_intv->value.sval.max > local_smax) {\n                goto error;\n            }\n            if (tmp_intv && (tmp_intv->value.sval.max >= tmp_local_intv->value.sval.min)) {\n                goto error;\n            }\n        } else if (kind == 2) {\n            if (tmp_local_intv->value.fval.min > tmp_local_intv->value.fval.max) {\n                goto error;\n            }\n            if (tmp_local_intv->value.fval.min < local_fmin || tmp_local_intv->value.fval.max > local_fmax) {\n                goto error;\n            }\n            if (tmp_intv && (tmp_intv->value.fval.max >= tmp_local_intv->value.fval.min)) {\n                /* fraction-digits value is always the same (it cannot be changed in derived types) */\n                goto error;\n            }\n        }\n\n        /* next segment (next OR) */\n        seg_ptr = strchr(seg_ptr, '|');\n        if (!seg_ptr) {\n            break;\n        }\n        seg_ptr++;\n        tmp_intv = tmp_local_intv;\n    }\n\n    /* check local restrictions against superior ones */\n    if (intv) {\n        tmp_intv = intv;\n        tmp_local_intv = local_intv;\n\n        while (tmp_local_intv && tmp_intv) {\n            /* reuse local variables */\n            if (kind == 0) {\n                local_umin = tmp_local_intv->value.uval.min;\n                local_umax = tmp_local_intv->value.uval.max;\n\n                /* it must be in this interval */\n                if ((local_umin >= tmp_intv->value.uval.min) && (local_umin <= tmp_intv->value.uval.max)) {\n                    /* this interval is covered, next one */\n                    if (local_umax <= tmp_intv->value.uval.max) {\n                        tmp_local_intv = tmp_local_intv->next;\n                        continue;\n                    /* ascending order of restrictions -> fail */\n                    } else {\n                        goto error;\n                    }\n                }\n            } else if (kind == 1) {\n                local_smin = tmp_local_intv->value.sval.min;\n                local_smax = tmp_local_intv->value.sval.max;\n\n                if ((local_smin >= tmp_intv->value.sval.min) && (local_smin <= tmp_intv->value.sval.max)) {\n                    if (local_smax <= tmp_intv->value.sval.max) {\n                        tmp_local_intv = tmp_local_intv->next;\n                        continue;\n                    } else {\n                        goto error;\n                    }\n                }\n            } else if (kind == 2) {\n                local_fmin = tmp_local_intv->value.fval.min;\n                local_fmax = tmp_local_intv->value.fval.max;\n\n                 if ((dec64cmp(local_fmin, local_fdig, tmp_intv->value.fval.min, local_fdig) > -1)\n                        && (dec64cmp(local_fmin, local_fdig, tmp_intv->value.fval.max, local_fdig) < 1)) {\n                    if (dec64cmp(local_fmax, local_fdig, tmp_intv->value.fval.max, local_fdig) < 1) {\n                        tmp_local_intv = tmp_local_intv->next;\n                        continue;\n                    } else {\n                        goto error;\n                    }\n                }\n            }\n\n            tmp_intv = tmp_intv->next;\n        }\n\n        /* some interval left uncovered -> fail */\n        if (tmp_local_intv) {\n            goto error;\n        }\n    }\n\n    /* append the local intervals to all the intervals of the superior types, return it all */\n    if (intv) {\n        for (tmp_intv = intv; tmp_intv->next; tmp_intv = tmp_intv->next);\n        tmp_intv->next = local_intv;\n    } else {\n        intv = local_intv;\n    }\n    *ret = intv;\n\n    return EXIT_SUCCESS;\n\nerror:\n    while (intv) {\n        tmp_intv = intv->next;\n        free(intv);\n        intv = tmp_intv;\n    }\n    while (local_intv) {\n        tmp_local_intv = local_intv->next;\n        free(local_intv);\n        local_intv = tmp_local_intv;\n    }\n\n    return -1;\n}\n\n/**\n * @brief Resolve a typedef, return only resolved typedefs if derived. If leafref, it must be\n * resolved for this function to return it. Does not log.\n *\n * @param[in] name Typedef name.\n * @param[in] mod_name Typedef name module name.\n * @param[in] module Main module.\n * @param[in] parent Parent of the resolved type definition.\n * @param[out] ret Pointer to the resolved typedef. Can be NULL.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nint\nresolve_superior_type(const char *name, const char *mod_name, const struct lys_module *module,\n                      const struct lys_node *parent, struct lys_tpdf **ret)\n{\n    int i, j;\n    struct lys_tpdf *tpdf, *match;\n    int tpdf_size;\n\n    if (!mod_name) {\n        /* no prefix, try built-in types */\n        for (i = 1; i < LY_DATA_TYPE_COUNT; i++) {\n            if (!strcmp(ly_types[i]->name, name)) {\n                if (ret) {\n                    *ret = ly_types[i];\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    } else {\n        if (!strcmp(mod_name, module->name)) {\n            /* prefix refers to the current module, ignore it */\n            mod_name = NULL;\n        }\n    }\n\n    if (!mod_name && parent) {\n        /* search in local typedefs */\n        while (parent) {\n            switch (parent->nodetype) {\n            case LYS_CONTAINER:\n                tpdf_size = ((struct lys_node_container *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_container *)parent)->tpdf;\n                break;\n\n            case LYS_LIST:\n                tpdf_size = ((struct lys_node_list *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_list *)parent)->tpdf;\n                break;\n\n            case LYS_GROUPING:\n                tpdf_size = ((struct lys_node_grp *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_grp *)parent)->tpdf;\n                break;\n\n            case LYS_RPC:\n            case LYS_ACTION:\n                tpdf_size = ((struct lys_node_rpc_action *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_rpc_action *)parent)->tpdf;\n                break;\n\n            case LYS_NOTIF:\n                tpdf_size = ((struct lys_node_notif *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_notif *)parent)->tpdf;\n                break;\n\n            case LYS_INPUT:\n            case LYS_OUTPUT:\n                tpdf_size = ((struct lys_node_inout *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_inout *)parent)->tpdf;\n                break;\n\n            default:\n                parent = lys_parent(parent);\n                continue;\n            }\n\n            for (i = 0; i < tpdf_size; i++) {\n                if (!strcmp(tpdf[i].name, name) && tpdf[i].type.base > 0) {\n                    match = &tpdf[i];\n                    goto check_leafref;\n                }\n            }\n\n            parent = lys_parent(parent);\n        }\n    } else {\n        /* get module where to search */\n        module = lyp_get_module(module, NULL, 0, mod_name, 0, 0);\n        if (!module) {\n            return -1;\n        }\n    }\n\n    /* search in top level typedefs */\n    for (i = 0; i < module->tpdf_size; i++) {\n        if (!strcmp(module->tpdf[i].name, name) && module->tpdf[i].type.base > 0) {\n            match = &module->tpdf[i];\n            goto check_leafref;\n        }\n    }\n\n    /* search in submodules */\n    for (i = 0; i < module->inc_size && module->inc[i].submodule; i++) {\n        for (j = 0; j < module->inc[i].submodule->tpdf_size; j++) {\n            if (!strcmp(module->inc[i].submodule->tpdf[j].name, name) && module->inc[i].submodule->tpdf[j].type.base > 0) {\n                match = &module->inc[i].submodule->tpdf[j];\n                goto check_leafref;\n            }\n        }\n    }\n\n    return EXIT_FAILURE;\n\ncheck_leafref:\n    if (ret) {\n        *ret = match;\n    }\n    if (match->type.base == LY_TYPE_LEAFREF) {\n        while (!match->type.info.lref.path) {\n            match = match->type.der;\n            assert(match);\n        }\n    }\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Check the default \\p value of the \\p type. Logs directly.\n *\n * @param[in] type Type definition to use.\n * @param[in] value Default value to check.\n * @param[in] module Type module.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\ncheck_default(struct lys_type *type, const char **value, struct lys_module *module, int tpdf)\n{\n    struct lys_tpdf *base_tpdf = NULL;\n    struct lyd_node_leaf_list node;\n    const char *dflt = NULL;\n    char *s;\n    int ret = EXIT_SUCCESS, r;\n    struct ly_ctx *ctx = module->ctx;\n\n    assert(value);\n    memset(&node, 0, sizeof node);\n\n    if (type->base <= LY_TYPE_DER) {\n        /* the type was not resolved yet, nothing to do for now */\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    } else if (!tpdf && !module->implemented) {\n        /* do not check defaults in not implemented module's data */\n        goto cleanup;\n    } else if (tpdf && !module->implemented && type->base == LY_TYPE_IDENT) {\n        /* identityrefs are checked when instantiated in data instead of typedef,\n         * but in typedef the value has to be modified to include the prefix */\n        if (*value) {\n            if (strchr(*value, ':')) {\n                dflt = transform_schema2json(module, *value);\n            } else {\n                /* default prefix of the module where the typedef is defined */\n                if (asprintf(&s, \"%s:%s\", lys_main_module(module)->name, *value) == -1) {\n                    LOGMEM(ctx);\n                    ret = -1;\n                    goto cleanup;\n                }\n                dflt = lydict_insert_zc(ctx, s);\n            }\n            lydict_remove(ctx, *value);\n            *value = dflt;\n            dflt = NULL;\n        }\n        goto cleanup;\n    } else if (type->base == LY_TYPE_LEAFREF && tpdf) {\n        /* leafref in typedef cannot be checked */\n        goto cleanup;\n    }\n\n    dflt = lydict_insert(ctx, *value, 0);\n    if (!dflt) {\n        /* we do not have a new default value, so is there any to check even, in some base type? */\n        for (base_tpdf = type->der; base_tpdf->type.der; base_tpdf = base_tpdf->type.der) {\n            if (base_tpdf->dflt) {\n                dflt = lydict_insert(ctx, base_tpdf->dflt, 0);\n                break;\n            }\n        }\n\n        if (!dflt) {\n            /* no default value, nothing to check, all is well */\n            goto cleanup;\n        }\n\n        /* so there is a default value in a base type, but can the default value be no longer valid (did we define some new restrictions)? */\n        switch (type->base) {\n        case LY_TYPE_IDENT:\n            if (lys_main_module(base_tpdf->type.parent->module)->implemented) {\n                goto cleanup;\n            } else {\n                /* check the default value from typedef, but use also the typedef's module\n                 * due to possible searching in imported modules which is expected in\n                 * typedef's module instead of module where the typedef is used */\n                module = base_tpdf->module;\n            }\n            break;\n        case LY_TYPE_INST:\n        case LY_TYPE_LEAFREF:\n        case LY_TYPE_BOOL:\n        case LY_TYPE_EMPTY:\n            /* these have no restrictions, so we would do the exact same work as the unres in the base typedef */\n            goto cleanup;\n        case LY_TYPE_BITS:\n            /* the default value must match the restricted list of values, if the type was restricted */\n            if (type->info.bits.count) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_ENUM:\n            /* the default value must match the restricted list of values, if the type was restricted */\n            if (type->info.enums.count) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_DEC64:\n            if (type->info.dec64.range) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_BINARY:\n            if (type->info.binary.length) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_INT8:\n        case LY_TYPE_INT16:\n        case LY_TYPE_INT32:\n        case LY_TYPE_INT64:\n        case LY_TYPE_UINT8:\n        case LY_TYPE_UINT16:\n        case LY_TYPE_UINT32:\n        case LY_TYPE_UINT64:\n            if (type->info.num.range) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_STRING:\n            if (type->info.str.length || type->info.str.patterns) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_UNION:\n            /* way too much trouble learning whether we need to check the default again, so just do it */\n            break;\n        default:\n            LOGINT(ctx);\n            ret = -1;\n            goto cleanup;\n        }\n    } else if (type->base == LY_TYPE_EMPTY) {\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, \"default\", type->parent->name);\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"The \\\"empty\\\" data type cannot have a default value.\");\n        ret = -1;\n        goto cleanup;\n    }\n\n    /* dummy leaf */\n    memset(&node, 0, sizeof node);\n    node.value_str = lydict_insert(ctx, dflt, 0);\n    node.value_type = type->base;\n\n    if (tpdf) {\n        node.schema = calloc(1, sizeof (struct lys_node_leaf));\n        if (!node.schema) {\n            LOGMEM(ctx);\n            ret = -1;\n            goto cleanup;\n        }\n        r = asprintf((char **)&node.schema->name, \"typedef-%s-default\", ((struct lys_tpdf *)type->parent)->name);\n        if (r == -1) {\n            LOGMEM(ctx);\n            ret = -1;\n            goto cleanup;\n        }\n        node.schema->module = module;\n        memcpy(&((struct lys_node_leaf *)node.schema)->type, type, sizeof *type);\n    } else {\n        node.schema = (struct lys_node *)type->parent;\n    }\n\n    if (type->base == LY_TYPE_LEAFREF) {\n        if (!type->info.lref.target) {\n            ret = EXIT_FAILURE;\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Default value \\\"%s\\\" cannot be checked in an unresolved leafref.\",\n                   dflt);\n            goto cleanup;\n        }\n        ret = check_default(&type->info.lref.target->type, &dflt, module, 0);\n        if (!ret) {\n            /* adopt possibly changed default value to its canonical form */\n            if (*value) {\n                lydict_remove(ctx, *value);\n                *value = dflt;\n                dflt = NULL;\n            }\n        }\n    } else {\n        if (!lyp_parse_value(type, &node.value_str, NULL, &node, NULL, module, 1, 1, 0)) {\n            /* possible forward reference */\n            ret = EXIT_FAILURE;\n            if (base_tpdf) {\n                /* default value is defined in some base typedef */\n                if ((type->base == LY_TYPE_BITS && type->der->type.der) ||\n                        (type->base == LY_TYPE_ENUM && type->der->type.der)) {\n                    /* we have refined bits/enums */\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL,\n                           \"Invalid value \\\"%s\\\" of the default statement inherited to \\\"%s\\\" from \\\"%s\\\" base type.\",\n                           dflt, type->parent->name, base_tpdf->name);\n                }\n            }\n        } else {\n            /* success - adopt canonical form from the node into the default value */\n            if (!ly_strequal(dflt, node.value_str, 1)) {\n                /* this can happen only if we have non-inherited default value,\n                 * inherited default values are already in canonical form */\n                assert(ly_strequal(dflt, *value, 1));\n\n                lydict_remove(ctx, *value);\n                *value = node.value_str;\n                node.value_str = NULL;\n            }\n        }\n    }\n\ncleanup:\n    lyd_free_value(node.value, node.value_type, node.value_flags, type, NULL, NULL, NULL);\n    lydict_remove(ctx, node.value_str);\n    if (tpdf && node.schema) {\n        free((char *)node.schema->name);\n        free(node.schema);\n    }\n    lydict_remove(ctx, dflt);\n\n    return ret;\n}\n\n/**\n * @brief Check a key for mandatory attributes. Logs directly.\n *\n * @param[in] key The key to check.\n * @param[in] flags What flags to check.\n * @param[in] list The list of all the keys.\n * @param[in] index Index of the key in the key list.\n * @param[in] name The name of the keys.\n * @param[in] len The name length.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nstatic int\ncheck_key(struct lys_node_list *list, int index, const char *name, int len)\n{\n    struct lys_node_leaf *key = list->keys[index];\n    char *dup = NULL;\n    int j;\n    struct ly_ctx *ctx = list->module->ctx;\n\n    /* existence */\n    if (!key) {\n        if (name[len] != '\\0') {\n            dup = strdup(name);\n            LY_CHECK_ERR_RETURN(!dup, LOGMEM(ctx), -1);\n            dup[len] = '\\0';\n            name = dup;\n        }\n        LOGVAL(ctx, LYE_KEY_MISS, LY_VLOG_LYS, list, name);\n        free(dup);\n        return -1;\n    }\n\n    /* uniqueness */\n    for (j = index - 1; j >= 0; j--) {\n        if (key == list->keys[j]) {\n            LOGVAL(ctx, LYE_KEY_DUP, LY_VLOG_LYS, list, key->name);\n            return -1;\n        }\n    }\n\n    /* key is a leaf */\n    if (key->nodetype != LYS_LEAF) {\n        LOGVAL(ctx, LYE_KEY_NLEAF, LY_VLOG_LYS, list, key->name);\n        return -1;\n    }\n\n    /* type of the leaf is not built-in empty */\n    if (key->type.base == LY_TYPE_EMPTY && key->module->version < LYS_VERSION_1_1) {\n        LOGVAL(ctx, LYE_KEY_TYPE, LY_VLOG_LYS, list, key->name);\n        return -1;\n    }\n\n    /* config attribute is the same as of the list */\n    if ((key->flags & LYS_CONFIG_MASK) && (list->flags & LYS_CONFIG_MASK)\n            && ((list->flags & LYS_CONFIG_MASK) != (key->flags & LYS_CONFIG_MASK))) {\n        LOGVAL(ctx, LYE_KEY_CONFIG, LY_VLOG_LYS, list, key->name);\n        return -1;\n    }\n\n    /* key is not placed from augment */\n    if (key->parent->nodetype == LYS_AUGMENT) {\n        LOGVAL(ctx, LYE_KEY_MISS, LY_VLOG_LYS, key, key->name);\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Key inserted from augment.\");\n        return -1;\n    }\n\n    /* key is not when/if-feature -conditional */\n    j = 0;\n    if (key->when || (key->iffeature_size && (j = 1))) {\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, key, j ? \"if-feature\" : \"when\", \"leaf\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Key definition cannot depend on a \\\"%s\\\" condition.\",\n               j ? \"if-feature\" : \"when\");\n        return -1;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Resolve (test the target exists) unique. Logs directly.\n *\n * @param[in] parent The parent node of the unique structure.\n * @param[in] uniq_str_path One path from the unique string.\n *\n * @return EXIT_SUCCESS on succes, EXIT_FAILURE on forward reference, -1 on error.\n */\nint\nresolve_unique(struct lys_node *parent, const char *uniq_str_path, uint8_t *trg_type)\n{\n    int rc;\n    const struct lys_node *leaf = NULL;\n    struct ly_ctx *ctx = parent->module->ctx;\n\n    rc = resolve_descendant_schema_nodeid(uniq_str_path, *lys_child(parent, LYS_LEAF), LYS_LEAF, 1, &leaf);\n    if (rc || !leaf) {\n        if (rc) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, parent, uniq_str_path, \"unique\");\n            if (rc > 0) {\n                LOGVAL(ctx, LYE_INCHAR, LY_VLOG_PREV, NULL, uniq_str_path[rc - 1], &uniq_str_path[rc - 1]);\n            } else if (rc == -2) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Unique argument references list.\");\n            }\n            rc = -1;\n        } else {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, parent, uniq_str_path, \"unique\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Target leaf not found.\");\n            rc = EXIT_FAILURE;\n        }\n        goto error;\n    }\n    if (leaf->nodetype != LYS_LEAF) {\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, parent, uniq_str_path, \"unique\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Target is not a leaf.\");\n        return -1;\n    }\n\n    /* check status */\n    if (parent->nodetype != LYS_EXT && lyp_check_status(parent->flags, parent->module, parent->name,\n                                                        leaf->flags, leaf->module, leaf->name, leaf)) {\n        return -1;\n    }\n\n    /* check that all unique's targets are of the same config type */\n    if (*trg_type) {\n        if (((*trg_type == 1) && (leaf->flags & LYS_CONFIG_R)) || ((*trg_type == 2) && (leaf->flags & LYS_CONFIG_W))) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, parent, uniq_str_path, \"unique\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                   \"Leaf \\\"%s\\\" referenced in unique statement is config %s, but previous referenced leaf is config %s.\",\n                   uniq_str_path, *trg_type == 1 ? \"false\" : \"true\", *trg_type == 1 ? \"true\" : \"false\");\n            return -1;\n        }\n    } else {\n        /* first unique */\n        if (leaf->flags & LYS_CONFIG_W) {\n            *trg_type = 1;\n        } else {\n            *trg_type = 2;\n        }\n    }\n\n    /* set leaf's unique flag */\n    ((struct lys_node_leaf *)leaf)->flags |= LYS_UNIQUE;\n\n    return EXIT_SUCCESS;\n\nerror:\n\n    return rc;\n}\n\nvoid\nunres_data_del(struct unres_data *unres, uint32_t i)\n{\n    /* there are items after the one deleted */\n    if (i+1 < unres->count) {\n        /* we only move the data, memory is left allocated, why bother */\n        memmove(&unres->node[i], &unres->node[i+1], (unres->count-(i+1)) * sizeof *unres->node);\n\n    /* deleting the last item */\n    } else if (i == 0) {\n        free(unres->node);\n        unres->node = NULL;\n    }\n\n    /* if there are no items after and it is not the last one, just move the counter */\n    --unres->count;\n}\n\n/**\n * @brief Resolve (find) a data node from a specific module. Does not log.\n *\n * @param[in] mod Module to search in.\n * @param[in] name Name of the data node.\n * @param[in] nam_len Length of the name.\n * @param[in] start Data node to start the search from.\n * @param[in,out] parents Resolved nodes. If there are some parents,\n *                        they are replaced (!!) with the resolvents.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_data(const struct lys_module *mod, const char *name, int nam_len, struct lyd_node *start, struct unres_data *parents)\n{\n    struct lyd_node *node;\n    int flag;\n    uint32_t i;\n\n    if (!parents->count) {\n        parents->count = 1;\n        parents->node = malloc(sizeof *parents->node);\n        LY_CHECK_ERR_RETURN(!parents->node, LOGMEM(mod->ctx), -1);\n        parents->node[0] = NULL;\n    }\n    for (i = 0; i < parents->count;) {\n        if (parents->node[i] && (parents->node[i]->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA))) {\n            /* skip */\n            ++i;\n            continue;\n        }\n        flag = 0;\n        LY_TREE_FOR(parents->node[i] ? parents->node[i]->child : start, node) {\n            if (lyd_node_module(node) == mod && !strncmp(node->schema->name, name, nam_len)\n                    && node->schema->name[nam_len] == '\\0') {\n                /* matching target */\n                if (!flag) {\n                    /* put node instead of the current parent */\n                    parents->node[i] = node;\n                    flag = 1;\n                } else {\n                    /* multiple matching, so create a new node */\n                    ++parents->count;\n                    parents->node = ly_realloc(parents->node, parents->count * sizeof *parents->node);\n                    LY_CHECK_ERR_RETURN(!parents->node, LOGMEM(mod->ctx), EXIT_FAILURE);\n                    parents->node[parents->count-1] = node;\n                    ++i;\n                }\n            }\n        }\n\n        if (!flag) {\n            /* remove item from the parents list */\n            unres_data_del(parents, i);\n        } else {\n            ++i;\n        }\n    }\n\n    return parents->count ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n\nstatic int\nresolve_schema_leafref_valid_dep_flag(const struct lys_node *op_node, const struct lys_module *local_mod,\n                                      const struct lys_node *first_node, int abs_path)\n{\n    int dep1, dep2;\n    const struct lys_node *node;\n\n    if (!op_node) {\n        /* leafref pointing to a different module */\n        if (local_mod != lys_node_module(first_node)) {\n            return 1;\n        }\n    } else if (lys_parent(op_node)) {\n        /* inner operation (notif/action) */\n        if (abs_path) {\n            return 1;\n        } else {\n            /* compare depth of both nodes */\n            for (dep1 = 0, node = op_node; lys_parent(node); node = lys_parent(node));\n            for (dep2 = 0, node = first_node; lys_parent(node); node = lys_parent(node));\n            if ((dep2 > dep1) || ((dep2 == dep1) && (op_node != first_node))) {\n                return 1;\n            }\n        }\n    } else {\n        /* top-level operation (notif/rpc) */\n        if (op_node != first_node) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n/**\n * @brief Resolve a path (leafref) predicate in JSON schema context. Logs directly.\n *\n * @param[in] path Path to use.\n * @param[in] context_node Predicate context node (where the predicate is placed).\n * @param[in] parent Path context node (where the path begins/is placed).\n * @param[in] op_node Optional node if the leafref is in an operation (action/rpc/notif).\n *\n * @return 0 on forward reference, otherwise the number\n *         of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nresolve_schema_leafref_predicate(const char *path, const struct lys_node *context_node, struct lys_node *parent)\n{\n    const struct lys_module *trg_mod;\n    const struct lys_node *src_node, *dst_node;\n    const char *path_key_expr, *source, *sour_pref, *dest, *dest_pref;\n    int pke_len, sour_len, sour_pref_len, dest_len, dest_pref_len, pke_parsed, parsed = 0;\n    int has_predicate, dest_parent_times, i, rc;\n    struct ly_ctx *ctx = context_node->module->ctx;\n\n    do {\n        if ((i = parse_path_predicate(path, &sour_pref, &sour_pref_len, &source, &sour_len, &path_key_expr,\n                                      &pke_len, &has_predicate)) < 1) {\n            LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, parent, path[-i], path-i);\n            return -parsed+i;\n        }\n        parsed += i;\n        path += i;\n\n        /* source (must be leaf) */\n        if (sour_pref) {\n            trg_mod = lyp_get_module(lys_node_module(parent), NULL, 0, sour_pref, sour_pref_len, 0);\n        } else {\n            trg_mod = lys_node_module(parent);\n        }\n        rc = lys_getnext_data(trg_mod, context_node, source, sour_len, LYS_LEAF | LYS_LEAFLIST, &src_node);\n        if (rc) {\n            LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref predicate\", path-parsed);\n            return 0;\n        }\n\n        /* destination */\n        dest_parent_times = 0;\n        pke_parsed = 0;\n        if ((i = parse_path_key_expr(path_key_expr, &dest_pref, &dest_pref_len, &dest, &dest_len,\n                                     &dest_parent_times)) < 1) {\n            LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, parent, path_key_expr[-i], path_key_expr-i);\n            return -parsed;\n        }\n        pke_parsed += i;\n\n        for (i = 0, dst_node = parent; i < dest_parent_times; ++i) {\n            if (!dst_node) {\n                /* we went too much into parents, there is no parent anymore */\n                LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref predicate\", path_key_expr);\n                return 0;\n            }\n\n            if (dst_node->parent && (dst_node->parent->nodetype == LYS_AUGMENT)\n                    && !((struct lys_node_augment *)dst_node->parent)->target) {\n                /* we are in an unresolved augment, cannot evaluate */\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, dst_node->parent,\n                       \"Cannot resolve leafref predicate \\\"%s\\\" because it is in an unresolved augment.\", path_key_expr);\n                return 0;\n            }\n\n            /* path is supposed to be evaluated in data tree, so we have to skip\n             * all schema nodes that cannot be instantiated in data tree */\n            for (dst_node = lys_parent(dst_node);\n                 dst_node && !(dst_node->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_ACTION | LYS_NOTIF | LYS_RPC));\n                 dst_node = lys_parent(dst_node));\n        }\n        while (1) {\n            if (dest_pref) {\n                trg_mod = lyp_get_module(lys_node_module(parent), NULL, 0, dest_pref, dest_pref_len, 0);\n            } else {\n                trg_mod = lys_node_module(parent);\n            }\n            rc = lys_getnext_data(trg_mod, dst_node, dest, dest_len, LYS_CONTAINER | LYS_LIST | LYS_LEAF, &dst_node);\n            if (rc) {\n                LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref predicate\", path_key_expr);\n                return 0;\n            }\n\n            if (pke_len == pke_parsed) {\n                break;\n            }\n\n            if ((i = parse_path_key_expr(path_key_expr + pke_parsed, &dest_pref, &dest_pref_len, &dest, &dest_len,\n                                         &dest_parent_times)) < 1) {\n                LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, parent,\n                       (path_key_expr + pke_parsed)[-i], (path_key_expr + pke_parsed)-i);\n                return -parsed;\n            }\n            pke_parsed += i;\n        }\n\n        /* check source - dest match */\n        if (dst_node->nodetype != src_node->nodetype) {\n            LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref predicate\", path - parsed);\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Destination node is not a %s, but a %s.\",\n                   strnodetype(src_node->nodetype), strnodetype(dst_node->nodetype));\n            return -parsed;\n        }\n    } while (has_predicate);\n\n    return parsed;\n}\n\nstatic int\ncheck_leafref_features(struct lys_type *type)\n{\n    struct lys_node *iter;\n    struct ly_set *src_parents, *trg_parents, *features;\n    struct lys_node_augment *aug;\n    struct ly_ctx *ctx = ((struct lys_tpdf *)type->parent)->module->ctx;\n    unsigned int i, j, size, x;\n    int ret = EXIT_SUCCESS;\n\n    assert(type->parent);\n\n    src_parents = ly_set_new();\n    trg_parents = ly_set_new();\n    features = ly_set_new();\n\n    /* get parents chain of source (leafref) */\n    for (iter = (struct lys_node *)type->parent; iter; iter = lys_parent(iter)) {\n        if (iter->nodetype & (LYS_INPUT | LYS_OUTPUT)) {\n            continue;\n        }\n        if (iter->parent && (iter->parent->nodetype == LYS_AUGMENT)) {\n            aug = (struct lys_node_augment *)iter->parent;\n            if ((aug->module->implemented && (aug->flags & LYS_NOTAPPLIED)) || !aug->target) {\n                /* unresolved augment, wait until it's resolved */\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, aug,\n                       \"Cannot check leafref \\\"%s\\\" if-feature consistency because of an unresolved augment.\", type->info.lref.path);\n                ret = EXIT_FAILURE;\n                goto cleanup;\n            }\n            /* also add this augment */\n            ly_set_add(src_parents, aug, LY_SET_OPT_USEASLIST);\n        }\n        ly_set_add(src_parents, iter, LY_SET_OPT_USEASLIST);\n    }\n    /* get parents chain of target */\n    for (iter = (struct lys_node *)type->info.lref.target; iter; iter = lys_parent(iter)) {\n        if (iter->nodetype & (LYS_INPUT | LYS_OUTPUT)) {\n            continue;\n        }\n        if (iter->parent && (iter->parent->nodetype == LYS_AUGMENT)) {\n            aug = (struct lys_node_augment *)iter->parent;\n            if ((aug->module->implemented && (aug->flags & LYS_NOTAPPLIED)) || !aug->target) {\n                /* unresolved augment, wait until it's resolved */\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, aug,\n                       \"Cannot check leafref \\\"%s\\\" if-feature consistency because of an unresolved augment.\", type->info.lref.path);\n                ret = EXIT_FAILURE;\n                goto cleanup;\n            }\n        }\n        ly_set_add(trg_parents, iter, LY_SET_OPT_USEASLIST);\n    }\n\n    /* compare the features used in if-feature statements in the rest of both\n     * chains of parents. The set of features used for target must be a subset\n     * of features used for the leafref. This is not a perfect, we should compare\n     * the truth tables but it could require too much resources, so we simplify that */\n    for (i = 0; i < src_parents->number; i++) {\n        iter = src_parents->set.s[i]; /* shortcut */\n        if (!iter->iffeature_size) {\n            continue;\n        }\n        for (j = 0; j < iter->iffeature_size; j++) {\n            resolve_iffeature_getsizes(&iter->iffeature[j], NULL, &size);\n            for (; size; size--) {\n                if (!iter->iffeature[j].features[size - 1]) {\n                    /* not yet resolved feature, postpone this check */\n                    ret = EXIT_FAILURE;\n                    goto cleanup;\n                }\n                ly_set_add(features, iter->iffeature[j].features[size - 1], 0);\n            }\n        }\n    }\n    x = features->number;\n    for (i = 0; i < trg_parents->number; i++) {\n        iter = trg_parents->set.s[i]; /* shortcut */\n        if (!iter->iffeature_size) {\n            continue;\n        }\n        for (j = 0; j < iter->iffeature_size; j++) {\n            resolve_iffeature_getsizes(&iter->iffeature[j], NULL, &size);\n            for (; size; size--) {\n                if (!iter->iffeature[j].features[size - 1]) {\n                    /* not yet resolved feature, postpone this check */\n                    ret = EXIT_FAILURE;\n                    goto cleanup;\n                }\n                if ((unsigned)ly_set_add(features, iter->iffeature[j].features[size - 1], 0) >= x) {\n                    /* the feature is not present in features set of target's parents chain */\n                    LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, type->parent, \"leafref\", type->info.lref.path);\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                           \"Leafref is not conditional based on \\\"%s\\\" feature as its target.\",\n                           iter->iffeature[j].features[size - 1]->name);\n                    ret = -1;\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\ncleanup:\n    ly_set_free(features);\n    ly_set_free(src_parents);\n    ly_set_free(trg_parents);\n\n    return ret;\n}\n\n/**\n * @brief Resolve a path (leafref) in JSON schema context. Logs directly.\n *\n * @param[in] path Path to use.\n * @param[in] parent_node Parent of the leafref.\n * @param[out] ret Pointer to the resolved schema node. Can be NULL.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_schema_leafref(struct lys_type *type, struct lys_node *parent, struct unres_schema *unres)\n{\n    const struct lys_node *node, *op_node = NULL, *tmp_parent;\n    struct lys_node_augment *last_aug;\n    const struct lys_module *tmp_mod, *cur_module;\n    const char *id, *prefix, *name;\n    int pref_len, nam_len, parent_times, has_predicate;\n    int i, first_iter;\n    struct ly_ctx *ctx = parent->module->ctx;\n\n    if (!type->info.lref.target) {\n        first_iter = 1;\n        parent_times = 0;\n        id = type->info.lref.path;\n\n        /* find operation schema we are in */\n        for (op_node = lys_parent(parent);\n            op_node && !(op_node->nodetype & (LYS_ACTION | LYS_NOTIF | LYS_RPC));\n            op_node = lys_parent(op_node));\n\n        cur_module = lys_node_module(parent);\n        do {\n            if ((i = parse_path_arg(cur_module, id, &prefix, &pref_len, &name, &nam_len, &parent_times, &has_predicate)) < 1) {\n                LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, parent, id[-i], &id[-i]);\n                return -1;\n            }\n            id += i;\n\n            /* get the current module */\n            tmp_mod = prefix ? lyp_get_module(cur_module, NULL, 0, prefix, pref_len, 0) : cur_module;\n            if (!tmp_mod) {\n                LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);\n                return EXIT_FAILURE;\n            }\n            last_aug = NULL;\n\n            if (first_iter) {\n                if (parent_times == -1) {\n                    /* use module data */\n                    node = NULL;\n\n                } else if (parent_times > 0) {\n                    /* we are looking for the right parent */\n                    for (i = 0, node = parent; i < parent_times; i++) {\n                        if (node->parent && (node->parent->nodetype == LYS_AUGMENT)\n                                && !((struct lys_node_augment *)node->parent)->target) {\n                            /* we are in an unresolved augment, cannot evaluate */\n                            LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, node->parent,\n                                \"Cannot resolve leafref \\\"%s\\\" because it is in an unresolved augment.\", type->info.lref.path);\n                            return EXIT_FAILURE;\n                        }\n\n                        /* path is supposed to be evaluated in data tree, so we have to skip\n                        * all schema nodes that cannot be instantiated in data tree */\n                        for (node = lys_parent(node);\n                            node && !(node->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_ACTION | LYS_NOTIF | LYS_RPC));\n                            node = lys_parent(node));\n\n                        if (!node) {\n                            if (i == parent_times - 1) {\n                                /* top-level */\n                                break;\n                            }\n\n                            /* higher than top-level */\n                            LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);\n                            return EXIT_FAILURE;\n                        }\n                    }\n                } else {\n                    LOGINT(ctx);\n                    return -1;\n                }\n            }\n\n            /* find the next node (either in unconnected augment or as a schema sibling, node is NULL for top-level node -\n            * - useless to search for that in augments) */\n            if (!tmp_mod->implemented && node) {\n    get_next_augment:\n                last_aug = lys_getnext_target_aug(last_aug, tmp_mod, node);\n            }\n\n            tmp_parent = (last_aug ? (struct lys_node *)last_aug : node);\n            node = NULL;\n            while ((node = lys_getnext(node, tmp_parent, tmp_mod, LYS_GETNEXT_NOSTATECHECK))) {\n                if (lys_node_module(node) != lys_main_module(tmp_mod)) {\n                    continue;\n                }\n                if (strncmp(node->name, name, nam_len) || node->name[nam_len]) {\n                    continue;\n                }\n                /* match */\n                break;\n            }\n            if (!node) {\n                if (last_aug) {\n                    /* restore the correct augment target */\n                    node = last_aug->target;\n                    goto get_next_augment;\n                }\n                LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);\n                return EXIT_FAILURE;\n            }\n\n            if (first_iter) {\n                /* set external dependency flag, we can decide based on the first found node */\n                if (resolve_schema_leafref_valid_dep_flag(op_node, cur_module, node, (parent_times == -1 ? 1 : 0))) {\n                    parent->flags |= LYS_LEAFREF_DEP;\n                }\n                first_iter = 0;\n            }\n\n            if (has_predicate) {\n                /* we have predicate, so the current result must be list */\n                if (node->nodetype != LYS_LIST) {\n                    LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);\n                    return -1;\n                }\n\n                i = resolve_schema_leafref_predicate(id, node, parent);\n                if (!i) {\n                    return EXIT_FAILURE;\n                } else if (i < 0) {\n                    return -1;\n                }\n                id += i;\n                has_predicate = 0;\n            }\n        } while (id[0]);\n\n        /* the target must be leaf or leaf-list (in YANG 1.1 only) */\n        if ((node->nodetype != LYS_LEAF) && (node->nodetype != LYS_LEAFLIST)) {\n            LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Leafref target \\\"%s\\\" is not a leaf nor a leaf-list.\", type->info.lref.path);\n            return -1;\n        }\n\n        /* check status */\n        if (lyp_check_status(parent->flags, parent->module, parent->name,\n                        node->flags, node->module, node->name, node)) {\n            return -1;\n        }\n\n        /* assign */\n        type->info.lref.target = (struct lys_node_leaf *)node;\n    }\n\n    /* as the last thing traverse this leafref and make targets on the path implemented */\n    if (lys_node_module(parent)->implemented) {\n        /* make all the modules in the path implemented */\n        for (node = (struct lys_node *)type->info.lref.target; node; node = lys_parent(node)) {\n            if (!lys_node_module(node)->implemented) {\n                lys_node_module(node)->implemented = 1;\n                if (unres_schema_add_node(lys_node_module(node), unres, NULL, UNRES_MOD_IMPLEMENT, NULL) == -1) {\n                    return -1;\n                }\n            }\n        }\n\n        /* store the backlink from leafref target */\n        if (lys_leaf_add_leafref_target(type->info.lref.target, (struct lys_node *)type->parent)) {\n            return -1;\n        }\n    }\n\n    /* check if leafref and its target are under common if-features */\n    return check_leafref_features(type);\n}\n\n/**\n * @brief Compare 2 data node values.\n *\n * Comparison performed on canonical forms, the first value\n * is first transformed into canonical form.\n *\n * @param[in] node Leaf/leaf-list with these values.\n * @param[in] noncan_val Non-canonical value.\n * @param[in] noncan_val_len Length of \\p noncal_val.\n * @param[in] can_val Canonical value.\n * @return 1 if equal, 0 if not, -1 on error (logged).\n */\nstatic int\nvalequal(struct lys_node *node, const char *noncan_val, int noncan_val_len, const char *can_val)\n{\n    int ret;\n    struct lyd_node_leaf_list leaf;\n    struct lys_node_leaf *sleaf = (struct lys_node_leaf*)node;\n\n    /* dummy leaf */\n    memset(&leaf, 0, sizeof leaf);\n    leaf.value_str = lydict_insert(node->module->ctx, noncan_val, noncan_val_len);\n\nrepeat:\n    leaf.value_type = sleaf->type.base;\n    leaf.schema = node;\n\n    if (leaf.value_type == LY_TYPE_LEAFREF) {\n        if (!sleaf->type.info.lref.target) {\n            /* it should either be unresolved leafref (leaf.value_type are ORed flags) or it will be resolved */\n            LOGINT(node->module->ctx);\n            ret = -1;\n            goto finish;\n        }\n        sleaf = sleaf->type.info.lref.target;\n        goto repeat;\n    } else {\n        if (!lyp_parse_value(&sleaf->type, &leaf.value_str, NULL, &leaf, NULL, NULL, 0, 0, 0)) {\n            ret = -1;\n            goto finish;\n        }\n    }\n\n    if (!strcmp(leaf.value_str, can_val)) {\n        ret = 1;\n    } else {\n        ret = 0;\n    }\n\nfinish:\n    lydict_remove(node->module->ctx, leaf.value_str);\n    return ret;\n}\n\n/**\n * @brief Resolve instance-identifier predicate in JSON data format.\n *        Does not log.\n *\n * @param[in] prev_mod Previous module to use in case there is no prefix.\n * @param[in] pred Predicate to use.\n * @param[in,out] node Node matching the restriction without\n *                     the predicate. If it does not satisfy the predicate,\n *                     it is set to NULL.\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nresolve_instid_predicate(const struct lys_module *prev_mod, const char *pred, struct lyd_node **node, int cur_idx)\n{\n    /* ... /node[key=value] ... */\n    struct lyd_node_leaf_list *key;\n    struct lys_node_leaf **list_keys = NULL;\n    struct lys_node_list *slist = NULL;\n    const char *model, *name, *value;\n    int mod_len, nam_len, val_len, i, has_predicate, parsed;\n    struct ly_ctx *ctx = prev_mod->ctx;\n\n    assert(pred && node && *node);\n\n    parsed = 0;\n    do {\n        if ((i = parse_predicate(pred + parsed, &model, &mod_len, &name, &nam_len, &value, &val_len, &has_predicate)) < 1) {\n            return -parsed + i;\n        }\n        parsed += i;\n\n        if (!(*node)) {\n            /* just parse it all */\n            continue;\n        }\n\n        /* target */\n        if (name[0] == '.') {\n            /* leaf-list value */\n            if ((*node)->schema->nodetype != LYS_LEAFLIST) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects leaf-list, but have %s \\\"%s\\\".\",\n                       strnodetype((*node)->schema->nodetype), (*node)->schema->name);\n                parsed = -1;\n                goto cleanup;\n            }\n\n            /* check the value */\n            if (!valequal((*node)->schema, value, val_len, ((struct lyd_node_leaf_list *)*node)->value_str)) {\n                *node = NULL;\n                goto cleanup;\n            }\n\n        } else if (isdigit(name[0])) {\n            assert(!value);\n\n            /* keyless list position */\n            if ((*node)->schema->nodetype != LYS_LIST) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects list, but have %s \\\"%s\\\".\",\n                       strnodetype((*node)->schema->nodetype), (*node)->schema->name);\n                parsed = -1;\n                goto cleanup;\n            }\n\n            if (((struct lys_node_list *)(*node)->schema)->keys) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects list without keys, but have list \\\"%s\\\".\",\n                       (*node)->schema->name);\n                parsed = -1;\n                goto cleanup;\n            }\n\n            /* check the index */\n            if (atoi(name) != cur_idx) {\n                *node = NULL;\n                goto cleanup;\n            }\n\n        } else {\n            /* list key value */\n            if ((*node)->schema->nodetype != LYS_LIST) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects list, but have %s \\\"%s\\\".\",\n                       strnodetype((*node)->schema->nodetype), (*node)->schema->name);\n                parsed = -1;\n                goto cleanup;\n            }\n            slist = (struct lys_node_list *)(*node)->schema;\n\n            /* prepare key array */\n            if (!list_keys) {\n                list_keys = malloc(slist->keys_size * sizeof *list_keys);\n                LY_CHECK_ERR_RETURN(!list_keys, LOGMEM(ctx), -1);\n                for (i = 0; i < slist->keys_size; ++i) {\n                    list_keys[i] = slist->keys[i];\n                }\n            }\n\n            /* find the schema key leaf */\n            for (i = 0; i < slist->keys_size; ++i) {\n                if (list_keys[i] && !strncmp(list_keys[i]->name, name, nam_len) && !list_keys[i]->name[nam_len]) {\n                    break;\n                }\n            }\n            if (i == slist->keys_size) {\n                /* this list has no such key */\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects list with the key \\\"%.*s\\\",\"\n                       \" but list \\\"%s\\\" does not define it.\", nam_len, name, slist->name);\n                parsed = -1;\n                goto cleanup;\n            }\n\n            /* check module */\n            if (model) {\n                if (strncmp(list_keys[i]->module->name, model, mod_len) || list_keys[i]->module->name[mod_len]) {\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects key \\\"%s\\\" from module \\\"%.*s\\\", not \\\"%s\\\".\",\n                           list_keys[i]->name, model, mod_len, list_keys[i]->module->name);\n                    parsed = -1;\n                    goto cleanup;\n                }\n            } else {\n                if (list_keys[i]->module != prev_mod) {\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects key \\\"%s\\\" from module \\\"%s\\\", not \\\"%s\\\".\",\n                           list_keys[i]->name, prev_mod->name, list_keys[i]->module->name);\n                    parsed = -1;\n                    goto cleanup;\n                }\n            }\n\n            /* find the actual data key */\n            for (key = (struct lyd_node_leaf_list *)(*node)->child; key; key = (struct lyd_node_leaf_list *)key->next) {\n                if (key->schema == (struct lys_node *)list_keys[i]) {\n                    break;\n                }\n            }\n            if (!key) {\n                /* list instance is missing a key? definitely should not happen */\n                LOGINT(ctx);\n                parsed = -1;\n                goto cleanup;\n            }\n\n            /* check the value */\n            if (!valequal(key->schema, value, val_len, key->value_str)) {\n                *node = NULL;\n                /* we still want to parse the whole predicate */\n                continue;\n            }\n\n            /* everything is fine, mark this key as resolved */\n            list_keys[i] = NULL;\n        }\n    } while (has_predicate);\n\n    /* check that all list keys were specified */\n    if (*node && list_keys) {\n        for (i = 0; i < slist->keys_size; ++i) {\n            if (list_keys[i]) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier is missing list key \\\"%s\\\".\", list_keys[i]->name);\n                parsed = -1;\n                goto cleanup;\n            }\n        }\n    }\n\ncleanup:\n    free(list_keys);\n    return parsed;\n}\n\nstatic int\ncheck_xpath(struct lys_node *node, int check_place)\n{\n    struct lys_node *parent;\n    struct lyxp_set set;\n    enum int_log_opts prev_ilo;\n\n    if (check_place) {\n        parent = node;\n        while (parent) {\n            if (parent->nodetype == LYS_GROUPING) {\n                /* unresolved grouping, skip for now (will be checked later) */\n                return EXIT_SUCCESS;\n            }\n            if (parent->nodetype == LYS_AUGMENT) {\n                if (!((struct lys_node_augment *)parent)->target) {\n                    /* unresolved augment, skip for now (will be checked later) */\n                    return EXIT_FAILURE;\n                } else {\n                    parent = ((struct lys_node_augment *)parent)->target;\n                    continue;\n                }\n            }\n            parent = parent->parent;\n        }\n    }\n\n    memset(&set, 0, sizeof set);\n\n    /* produce just warnings */\n    ly_ilo_change(NULL, ILO_ERR2WRN, &prev_ilo, NULL);\n    lyxp_node_atomize(node, &set, 1);\n    ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n\n    if (set.val.snodes) {\n        free(set.val.snodes);\n    }\n    return EXIT_SUCCESS;\n}\n\nstatic int\ncheck_leafref_config(struct lys_node_leaf *leaf, struct lys_type *type)\n{\n    unsigned int i;\n\n    if (type->base == LY_TYPE_LEAFREF) {\n        if ((leaf->flags & LYS_CONFIG_W) && type->info.lref.target && type->info.lref.req != -1 &&\n                (type->info.lref.target->flags & LYS_CONFIG_R)) {\n            LOGVAL(leaf->module->ctx, LYE_SPEC, LY_VLOG_LYS, leaf, \"The leafref %s is config but refers to a non-config %s.\",\n                   strnodetype(leaf->nodetype), strnodetype(type->info.lref.target->nodetype));\n            return -1;\n        }\n        /* we can skip the test in case the leafref is not yet resolved. In that case the test is done in the time\n         * of leafref resolving (lys_leaf_add_leafref_target()) */\n    } else if (type->base == LY_TYPE_UNION) {\n        for (i = 0; i < type->info.uni.count; i++) {\n            if (check_leafref_config(leaf, &type->info.uni.types[i])) {\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n\n/**\n * @brief Passes config flag down to children, skips nodes without config flags.\n * Logs.\n *\n * @param[in] node Siblings and their children to have flags changed.\n * @param[in] clear Flag to clear all config flags if parent is LYS_NOTIF, LYS_INPUT, LYS_OUTPUT, LYS_RPC.\n * @param[in] flags Flags to assign to all the nodes.\n * @param[in,out] unres List of unresolved items.\n *\n * @return 0 on success, -1 on error.\n */\nint\ninherit_config_flag(struct lys_node *node, int flags, int clear)\n{\n    struct lys_node_leaf *leaf;\n    struct ly_ctx *ctx;\n\n    if (!node) {\n        return 0;\n    }\n\n    assert(!(flags ^ (flags & LYS_CONFIG_MASK)));\n    ctx = node->module->ctx;\n\n    LY_TREE_FOR(node, node) {\n        if (clear) {\n            node->flags &= ~LYS_CONFIG_MASK;\n            node->flags &= ~LYS_CONFIG_SET;\n        } else {\n            if (node->flags & LYS_CONFIG_SET) {\n                /* skip nodes with an explicit config value */\n                if ((flags & LYS_CONFIG_R) && (node->flags & LYS_CONFIG_W)) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, node, \"true\", \"config\");\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"State nodes cannot have configuration nodes as children.\");\n                    return -1;\n                }\n                continue;\n            }\n\n            if (!(node->nodetype & (LYS_USES | LYS_GROUPING))) {\n                node->flags = (node->flags & ~LYS_CONFIG_MASK) | flags;\n                /* check that configuration lists have keys */\n                if ((node->nodetype == LYS_LIST) && (node->flags & LYS_CONFIG_W)\n                        && !((struct lys_node_list *)node)->keys_size) {\n                    LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, node, \"key\", \"list\");\n                    return -1;\n                }\n            }\n        }\n        if (!(node->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA))) {\n            if (inherit_config_flag(node->child, flags, clear)) {\n                return -1;\n            }\n        } else if (node->nodetype & (LYS_LEAF | LYS_LEAFLIST)) {\n            leaf = (struct lys_node_leaf *)node;\n            if (check_leafref_config(leaf, &leaf->type)) {\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}\n\n/**\n * @brief Resolve augment target. Logs directly.\n *\n * @param[in] aug Augment to use.\n * @param[in] uses Parent where to start the search in. If set, uses augment, if not, standalone augment.\n * @param[in,out] unres List of unresolved items.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_augment(struct lys_node_augment *aug, struct lys_node *uses, struct unres_schema *unres)\n{\n    int rc;\n    struct lys_node *sub;\n    struct lys_module *mod;\n    struct ly_set *set;\n    struct ly_ctx *ctx;\n\n    assert(aug);\n    mod = lys_main_module(aug->module);\n    ctx = mod->ctx;\n\n    /* set it as not applied for now */\n    aug->flags |= LYS_NOTAPPLIED;\n\n    /* it can already be resolved in case we returned EXIT_FAILURE from if block below */\n    if (!aug->target) {\n        /* resolve target node */\n        rc = resolve_schema_nodeid(aug->target_name, uses, (uses ? NULL : lys_node_module((struct lys_node *)aug)), &set, 0, 0);\n        if (rc == -1) {\n            LOGVAL(ctx, LYE_PATH, LY_VLOG_LYS, aug);\n            return -1;\n        }\n        if (!set) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, aug, \"augment\", aug->target_name);\n            return EXIT_FAILURE;\n        }\n        aug->target = set->set.s[0];\n        ly_set_free(set);\n    }\n\n    /* make this module implemented if the target module is (if the target is in an unimplemented module,\n     * it is fine because when we will be making that module implemented, its augment will be applied\n     * and that augment target module made implemented, recursively) */\n    if (mod->implemented && !lys_node_module(aug->target)->implemented) {\n        lys_node_module(aug->target)->implemented = 1;\n        if (unres_schema_add_node(lys_node_module(aug->target), unres, NULL, UNRES_MOD_IMPLEMENT, NULL) == -1) {\n            return -1;\n        }\n    }\n\n    /* check for mandatory nodes - if the target node is in another module\n     * the added nodes cannot be mandatory\n     */\n    if (!aug->parent && (lys_node_module((struct lys_node *)aug) != lys_node_module(aug->target))\n            && (rc = lyp_check_mandatory_augment(aug, aug->target))) {\n        return rc;\n    }\n\n    /* check augment target type and then augment nodes type */\n    if (aug->target->nodetype & (LYS_CONTAINER | LYS_LIST)) {\n        LY_TREE_FOR(aug->child, sub) {\n            if (!(sub->nodetype & (LYS_ANYDATA | LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_USES\n                                   | LYS_CHOICE | LYS_ACTION | LYS_NOTIF))) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, aug, strnodetype(sub->nodetype), \"augment\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Cannot augment \\\"%s\\\" with a \\\"%s\\\".\",\n                       strnodetype(aug->target->nodetype), strnodetype(sub->nodetype));\n                return -1;\n            }\n        }\n    } else if (aug->target->nodetype & (LYS_CASE | LYS_INPUT | LYS_OUTPUT | LYS_NOTIF)) {\n        LY_TREE_FOR(aug->child, sub) {\n            if (!(sub->nodetype & (LYS_ANYDATA | LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_USES | LYS_CHOICE))) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, aug, strnodetype(sub->nodetype), \"augment\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Cannot augment \\\"%s\\\" with a \\\"%s\\\".\",\n                       strnodetype(aug->target->nodetype), strnodetype(sub->nodetype));\n                return -1;\n            }\n        }\n    } else if (aug->target->nodetype == LYS_CHOICE) {\n        LY_TREE_FOR(aug->child, sub) {\n            if (!(sub->nodetype & (LYS_CASE | LYS_ANYDATA | LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST))) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, aug, strnodetype(sub->nodetype), \"augment\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Cannot augment \\\"%s\\\" with a \\\"%s\\\".\",\n                       strnodetype(aug->target->nodetype), strnodetype(sub->nodetype));\n                return -1;\n            }\n        }\n    } else {\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, aug, aug->target_name, \"target-node\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Invalid augment target node type \\\"%s\\\".\", strnodetype(aug->target->nodetype));\n        return -1;\n    }\n\n    /* check identifier uniqueness as in lys_node_addchild() */\n    LY_TREE_FOR(aug->child, sub) {\n        if (lys_check_id(sub, aug->target, NULL)) {\n            return -1;\n        }\n    }\n\n    if (!aug->child) {\n        /* empty augment, nothing to connect, but it is techincally applied */\n        LOGWRN(ctx, \"Augment \\\"%s\\\" without children.\", aug->target_name);\n        aug->flags &= ~LYS_NOTAPPLIED;\n    } else if ((aug->parent || mod->implemented) && apply_aug(aug, unres)) {\n        /* we try to connect the augment only in case the module is implemented or\n         * the augment applies on the used grouping, anyway we failed here */\n        return -1;\n    }\n\n    return EXIT_SUCCESS;\n}\n\nstatic int\nresolve_extension(struct unres_ext *info, struct lys_ext_instance **ext, struct unres_schema *unres)\n{\n    enum LY_VLOG_ELEM vlog_type;\n    void *vlog_node;\n    unsigned int i, j;\n    struct lys_ext *e;\n    char *ext_name, *ext_prefix, *tmp;\n    struct lyxml_elem *next_yin, *yin;\n    const struct lys_module *mod;\n    struct lys_ext_instance *tmp_ext;\n    struct ly_ctx *ctx = NULL;\n    LYEXT_TYPE etype;\n\n    switch (info->parent_type) {\n    case LYEXT_PAR_NODE:\n        vlog_node = info->parent;\n        vlog_type = LY_VLOG_LYS;\n        break;\n    case LYEXT_PAR_MODULE:\n    case LYEXT_PAR_IMPORT:\n    case LYEXT_PAR_INCLUDE:\n        vlog_node = NULL;\n        vlog_type = LY_VLOG_LYS;\n        break;\n    default:\n        vlog_node = NULL;\n        vlog_type = LY_VLOG_NONE;\n        break;\n    }\n\n    if (info->datatype == LYS_IN_YIN) {\n        /* YIN */\n\n        /* get the module where the extension is supposed to be defined */\n        mod = lyp_get_import_module_ns(info->mod, info->data.yin->ns->value);\n        if (!mod) {\n            LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, info->data.yin->name);\n            return EXIT_FAILURE;\n        }\n        ctx = mod->ctx;\n\n        /* find the extension definition */\n        e = NULL;\n        for (i = 0; i < mod->extensions_size; i++) {\n            if (ly_strequal(mod->extensions[i].name, info->data.yin->name, 1)) {\n                e = &mod->extensions[i];\n                break;\n            }\n        }\n        /* try submodules */\n        for (j = 0; !e && j < mod->inc_size; j++) {\n            for (i = 0; i < mod->inc[j].submodule->extensions_size; i++) {\n                if (ly_strequal(mod->inc[j].submodule->extensions[i].name, info->data.yin->name, 1)) {\n                    e = &mod->inc[j].submodule->extensions[i];\n                    break;\n                }\n            }\n        }\n        if (!e) {\n            LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, info->data.yin->name);\n            return EXIT_FAILURE;\n        }\n\n        /* we have the extension definition, so now it cannot be forward referenced and error is always fatal */\n\n        if (e->plugin && e->plugin->check_position) {\n            /* common part - we have plugin with position checking function, use it first */\n            if ((*e->plugin->check_position)(info->parent, info->parent_type, info->substmt)) {\n                /* extension is not allowed here */\n                LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, e->name);\n                return -1;\n            }\n        }\n\n        /* extension type-specific part - allocation */\n        if (e->plugin) {\n            etype = e->plugin->type;\n        } else {\n            /* default type */\n            etype = LYEXT_FLAG;\n        }\n        switch (etype) {\n        case LYEXT_FLAG:\n            (*ext) = calloc(1, sizeof(struct lys_ext_instance));\n            break;\n        case LYEXT_COMPLEX:\n            (*ext) = calloc(1, ((struct lyext_plugin_complex*)e->plugin)->instance_size);\n            break;\n        case LYEXT_ERR:\n            /* we never should be here */\n            LOGINT(ctx);\n            return -1;\n        }\n        LY_CHECK_ERR_RETURN(!*ext, LOGMEM(ctx), -1);\n\n        /* common part for all extension types */\n        (*ext)->def = e;\n        (*ext)->parent = info->parent;\n        (*ext)->parent_type = info->parent_type;\n        (*ext)->insubstmt = info->substmt;\n        (*ext)->insubstmt_index = info->substmt_index;\n        (*ext)->ext_type = e->plugin ? e->plugin->type : LYEXT_FLAG;\n        (*ext)->flags |= e->plugin ? e->plugin->flags : 0;\n\n        if (e->argument) {\n            if (!(e->flags & LYS_YINELEM)) {\n                (*ext)->arg_value = lyxml_get_attr(info->data.yin, e->argument, NULL);\n                if (!(*ext)->arg_value) {\n                    LOGVAL(ctx, LYE_MISSARG, LY_VLOG_NONE, NULL, e->argument, info->data.yin->name);\n                    return -1;\n                }\n\n                (*ext)->arg_value = lydict_insert(mod->ctx, (*ext)->arg_value, 0);\n            } else {\n                LY_TREE_FOR_SAFE(info->data.yin->child, next_yin, yin) {\n                    if (ly_strequal(yin->name, e->argument, 1)) {\n                        (*ext)->arg_value = lydict_insert(mod->ctx, yin->content, 0);\n                        lyxml_free(mod->ctx, yin);\n                        break;\n                    }\n                }\n            }\n        }\n\n        if ((*ext)->flags & LYEXT_OPT_VALID &&\n            (info->parent_type == LYEXT_PAR_NODE || info->parent_type == LYEXT_PAR_TPDF)) {\n            ((struct lys_node *)info->parent)->flags |= LYS_VALID_EXT;\n        }\n\n        (*ext)->nodetype = LYS_EXT;\n        (*ext)->module = info->mod;\n\n        /* extension type-specific part - parsing content */\n        switch (etype) {\n        case LYEXT_FLAG:\n            LY_TREE_FOR_SAFE(info->data.yin->child, next_yin, yin) {\n                if (!yin->ns) {\n                    /* garbage */\n                    lyxml_free(mod->ctx, yin);\n                    continue;\n                } else if (!strcmp(yin->ns->value, LY_NSYIN)) {\n                    /* standard YANG statements are not expected here */\n                    LOGVAL(ctx, LYE_INCHILDSTMT, vlog_type, vlog_node, yin->name, info->data.yin->name);\n                    return -1;\n                } else if (yin->ns == info->data.yin->ns &&\n                        (e->flags & LYS_YINELEM) && ly_strequal(yin->name, e->argument, 1)) {\n                    /* we have the extension's argument */\n                    if ((*ext)->arg_value) {\n                        LOGVAL(ctx, LYE_TOOMANY, vlog_type, vlog_node, yin->name, info->data.yin->name);\n                        return -1;\n                    }\n                    (*ext)->arg_value = yin->content;\n                    yin->content = NULL;\n                    lyxml_free(mod->ctx, yin);\n                } else {\n                    /* extension instance */\n                    if (lyp_yin_parse_subnode_ext(info->mod, *ext, LYEXT_PAR_EXTINST, yin,\n                                                  LYEXT_SUBSTMT_SELF, 0, unres)) {\n                        return -1;\n                    }\n\n                    continue;\n                }\n            }\n            break;\n        case LYEXT_COMPLEX:\n            ((struct lys_ext_instance_complex*)(*ext))->substmt = ((struct lyext_plugin_complex*)e->plugin)->substmt;\n            if (lyp_yin_parse_complex_ext(info->mod, (struct lys_ext_instance_complex*)(*ext), info->data.yin, unres)) {\n                /* TODO memory cleanup */\n                return -1;\n            }\n            break;\n        default:\n            break;\n        }\n\n        /* TODO - lyext_check_result_clb, other than LYEXT_FLAG plugins */\n\n    } else {\n        /* YANG */\n\n        ext_prefix = (char *)(*ext)->def;\n        tmp = strchr(ext_prefix, ':');\n        if (!tmp) {\n            LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, ext_prefix);\n            goto error;\n        }\n        ext_name = tmp + 1;\n\n        /* get the module where the extension is supposed to be defined */\n        mod = lyp_get_module(info->mod, ext_prefix, tmp - ext_prefix, NULL, 0, 0);\n        if (!mod) {\n            LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, ext_prefix);\n            return EXIT_FAILURE;\n        }\n        ctx = mod->ctx;\n\n        /* find the extension definition */\n        e = NULL;\n        for (i = 0; i < mod->extensions_size; i++) {\n            if (ly_strequal(mod->extensions[i].name, ext_name, 0)) {\n                e = &mod->extensions[i];\n                break;\n            }\n        }\n        /* try submodules */\n        for (j = 0; !e && j < mod->inc_size; j++) {\n            for (i = 0; i < mod->inc[j].submodule->extensions_size; i++) {\n                if (ly_strequal(mod->inc[j].submodule->extensions[i].name, ext_name, 0)) {\n                    e = &mod->inc[j].submodule->extensions[i];\n                    break;\n                }\n            }\n        }\n        if (!e) {\n            LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, ext_prefix);\n            return EXIT_FAILURE;\n        }\n\n        (*ext)->flags &= ~LYEXT_OPT_YANG;\n        (*ext)->def = NULL;\n\n        /* we have the extension definition, so now it cannot be forward referenced and error is always fatal */\n\n        if (e->plugin && e->plugin->check_position) {\n            /* common part - we have plugin with position checking function, use it first */\n            if ((*e->plugin->check_position)(info->parent, info->parent_type, info->substmt)) {\n                /* extension is not allowed here */\n                LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, e->name);\n                goto error;\n            }\n        }\n\n        /* extension common part */\n        (*ext)->def = e;\n        (*ext)->parent = info->parent;\n        (*ext)->ext_type = e->plugin ? e->plugin->type : LYEXT_FLAG;\n        (*ext)->flags |= e->plugin ? e->plugin->flags : 0;\n\n        if (e->argument && !(*ext)->arg_value) {\n            LOGVAL(ctx, LYE_MISSARG, LY_VLOG_NONE, NULL, e->argument, ext_name);\n            goto error;\n        }\n\n        if ((*ext)->flags & LYEXT_OPT_VALID &&\n            (info->parent_type == LYEXT_PAR_NODE || info->parent_type == LYEXT_PAR_TPDF)) {\n            ((struct lys_node *)info->parent)->flags |= LYS_VALID_EXT;\n        }\n\n        (*ext)->module = info->mod;\n        (*ext)->nodetype = LYS_EXT;\n\n        /* extension type-specific part */\n        if (e->plugin) {\n            etype = e->plugin->type;\n        } else {\n            /* default type */\n            etype = LYEXT_FLAG;\n        }\n        switch (etype) {\n        case LYEXT_FLAG:\n            /* nothing change */\n            break;\n        case LYEXT_COMPLEX:\n            tmp_ext = realloc(*ext, ((struct lyext_plugin_complex*)e->plugin)->instance_size);\n            LY_CHECK_ERR_GOTO(!tmp_ext, LOGMEM(ctx), error);\n            memset((char *)tmp_ext + offsetof(struct lys_ext_instance_complex, content), 0,\n                   ((struct lyext_plugin_complex*)e->plugin)->instance_size - offsetof(struct lys_ext_instance_complex, content));\n            (*ext) = tmp_ext;\n            ((struct lys_ext_instance_complex*)(*ext))->substmt = ((struct lyext_plugin_complex*)e->plugin)->substmt;\n            if (info->data.yang) {\n                *tmp = ':';\n                if (yang_parse_ext_substatement(info->mod, unres, info->data.yang->ext_substmt, ext_prefix,\n                                                (struct lys_ext_instance_complex*)(*ext))) {\n                    goto error;\n                }\n                if (yang_fill_extcomplex_module(info->mod->ctx, (struct lys_ext_instance_complex*)(*ext), ext_prefix,\n                                                info->data.yang->ext_modules, info->mod->implemented)) {\n                    goto error;\n                }\n            }\n            if (lyp_mand_check_ext((struct lys_ext_instance_complex*)(*ext), ext_prefix)) {\n                goto error;\n            }\n            break;\n        case LYEXT_ERR:\n            /* we never should be here */\n            LOGINT(ctx);\n            goto error;\n        }\n\n        if (yang_check_ext_instance(info->mod, &(*ext)->ext, (*ext)->ext_size, *ext, unres)) {\n            goto error;\n        }\n        free(ext_prefix);\n    }\n\n    return EXIT_SUCCESS;\nerror:\n    free(ext_prefix);\n    return -1;\n}\n\n/**\n * @brief Resolve (find) choice default case. Does not log.\n *\n * @param[in] choic Choice to use.\n * @param[in] dflt Name of the default case.\n *\n * @return Pointer to the default node or NULL.\n */\nstatic struct lys_node *\nresolve_choice_dflt(struct lys_node_choice *choic, const char *dflt)\n{\n    struct lys_node *child, *ret;\n\n    LY_TREE_FOR(choic->child, child) {\n        if (child->nodetype == LYS_USES) {\n            ret = resolve_choice_dflt((struct lys_node_choice *)child, dflt);\n            if (ret) {\n                return ret;\n            }\n        }\n\n        if (ly_strequal(child->name, dflt, 1) && (child->nodetype & (LYS_ANYDATA | LYS_CASE\n                | LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_CHOICE))) {\n            return child;\n        }\n    }\n\n    return NULL;\n}\n\n/**\n * @brief Resolve uses, apply augments, refines. Logs directly.\n *\n * @param[in] uses Uses to use.\n * @param[in,out] unres List of unresolved items.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nstatic int\nresolve_uses(struct lys_node_uses *uses, struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = uses->module->ctx; /* shortcut */\n    struct lys_node *node = NULL, *next, *iter, **refine_nodes = NULL;\n    struct lys_node *node_aux, *parent, *tmp;\n    struct lys_node_leaflist *llist;\n    struct lys_node_leaf *leaf;\n    struct lys_refine *rfn;\n    struct lys_restr *must, **old_must;\n    struct lys_iffeature *iff, **old_iff;\n    int i, j, k, rc;\n    uint8_t size, *old_size;\n    unsigned int usize, usize1, usize2;\n\n    assert(uses->grp);\n\n    /* check that the grouping is resolved (no unresolved uses inside) */\n    assert(!uses->grp->unres_count);\n\n    /* copy the data nodes from grouping into the uses context */\n    LY_TREE_FOR(uses->grp->child, node_aux) {\n        if (node_aux->nodetype & LYS_GROUPING) {\n            /* do not instantiate groupings from groupings */\n            continue;\n        }\n        node = lys_node_dup(uses->module, (struct lys_node *)uses, node_aux, unres, 0);\n        if (!node) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, uses->grp->name, \"uses\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Copying data from grouping failed.\");\n            goto fail;\n        }\n        /* test the name of siblings */\n        LY_TREE_FOR((uses->parent) ? *lys_child(uses->parent, LYS_USES) : lys_main_module(uses->module)->data, tmp) {\n            if (!(tmp->nodetype & (LYS_USES | LYS_GROUPING | LYS_CASE)) && ly_strequal(tmp->name, node_aux->name, 1)) {\n                goto fail;\n            }\n        }\n    }\n\n    /* we managed to copy the grouping, the rest must be possible to resolve */\n\n    if (uses->refine_size) {\n        refine_nodes = malloc(uses->refine_size * sizeof *refine_nodes);\n        LY_CHECK_ERR_GOTO(!refine_nodes, LOGMEM(ctx), fail);\n    }\n\n    /* apply refines */\n    for (i = 0; i < uses->refine_size; i++) {\n        rfn = &uses->refine[i];\n        rc = resolve_descendant_schema_nodeid(rfn->target_name, uses->child,\n                                              LYS_NO_RPC_NOTIF_NODE | LYS_ACTION | LYS_NOTIF,\n                                              0, (const struct lys_node **)&node);\n        if (rc || !node) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, rfn->target_name, \"refine\");\n            goto fail;\n        }\n\n        if (rfn->target_type && !(node->nodetype & rfn->target_type)) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, rfn->target_name, \"refine\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Refine substatements not applicable to the target-node.\");\n            goto fail;\n        }\n        refine_nodes[i] = node;\n\n        /* description on any nodetype */\n        if (rfn->dsc) {\n            lydict_remove(ctx, node->dsc);\n            node->dsc = lydict_insert(ctx, rfn->dsc, 0);\n        }\n\n        /* reference on any nodetype */\n        if (rfn->ref) {\n            lydict_remove(ctx, node->ref);\n            node->ref = lydict_insert(ctx, rfn->ref, 0);\n        }\n\n        /* config on any nodetype,\n         * in case of notification or rpc/action, the config is not applicable (there is no config status) */\n        if ((rfn->flags & LYS_CONFIG_MASK) && (node->flags & LYS_CONFIG_MASK)) {\n            node->flags &= ~LYS_CONFIG_MASK;\n            node->flags |= (rfn->flags & LYS_CONFIG_MASK);\n        }\n\n        /* default value ... */\n        if (rfn->dflt_size) {\n            if (node->nodetype == LYS_LEAF) {\n                /* leaf */\n                leaf = (struct lys_node_leaf *)node;\n\n                /* replace default value */\n                lydict_remove(ctx, leaf->dflt);\n                leaf->dflt = lydict_insert(ctx, rfn->dflt[0], 0);\n\n                /* check the default value */\n                if (unres_schema_add_node(leaf->module, unres, &leaf->type, UNRES_TYPE_DFLT,\n                                          (struct lys_node *)(&leaf->dflt)) == -1) {\n                    goto fail;\n                }\n            } else if (node->nodetype == LYS_LEAFLIST) {\n                /* leaf-list */\n                llist = (struct lys_node_leaflist *)node;\n\n                /* remove complete set of defaults in target */\n                for (j = 0; j < llist->dflt_size; j++) {\n                    lydict_remove(ctx, llist->dflt[j]);\n                }\n                free(llist->dflt);\n\n                /* copy the default set from refine */\n                llist->dflt = malloc(rfn->dflt_size * sizeof *llist->dflt);\n                LY_CHECK_ERR_GOTO(!llist->dflt, LOGMEM(ctx), fail);\n                llist->dflt_size = rfn->dflt_size;\n                for (j = 0; j < llist->dflt_size; j++) {\n                    llist->dflt[j] = lydict_insert(ctx, rfn->dflt[j], 0);\n                }\n\n                /* check default value */\n                for (j = 0; j < llist->dflt_size; j++) {\n                    if (unres_schema_add_node(llist->module, unres, &llist->type, UNRES_TYPE_DFLT,\n                                              (struct lys_node *)(&llist->dflt[j])) == -1) {\n                        goto fail;\n                    }\n                }\n            }\n        }\n\n        /* mandatory on leaf, anyxml or choice */\n        if (rfn->flags & LYS_MAND_MASK) {\n            /* remove current value */\n            node->flags &= ~LYS_MAND_MASK;\n\n            /* set new value */\n            node->flags |= (rfn->flags & LYS_MAND_MASK);\n\n            if (rfn->flags & LYS_MAND_TRUE) {\n                /* check if node has default value */\n                if ((node->nodetype & LYS_LEAF) && ((struct lys_node_leaf *)node)->dflt) {\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, uses,\n                           \"The \\\"mandatory\\\" statement is forbidden on leaf with \\\"default\\\".\");\n                    goto fail;\n                }\n                if ((node->nodetype & LYS_CHOICE) && ((struct lys_node_choice *)node)->dflt) {\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, uses,\n                           \"The \\\"mandatory\\\" statement is forbidden on choices with \\\"default\\\".\");\n                    goto fail;\n                }\n            }\n        }\n\n        /* presence on container */\n        if ((node->nodetype & LYS_CONTAINER) && rfn->mod.presence) {\n            lydict_remove(ctx, ((struct lys_node_container *)node)->presence);\n            ((struct lys_node_container *)node)->presence = lydict_insert(ctx, rfn->mod.presence, 0);\n        }\n\n        /* min/max-elements on list or leaf-list */\n        if (node->nodetype == LYS_LIST) {\n            if (rfn->flags & LYS_RFN_MINSET) {\n                ((struct lys_node_list *)node)->min = rfn->mod.list.min;\n            }\n            if (rfn->flags & LYS_RFN_MAXSET) {\n                ((struct lys_node_list *)node)->max = rfn->mod.list.max;\n            }\n        } else if (node->nodetype == LYS_LEAFLIST) {\n            if (rfn->flags & LYS_RFN_MINSET) {\n                ((struct lys_node_leaflist *)node)->min = rfn->mod.list.min;\n            }\n            if (rfn->flags & LYS_RFN_MAXSET) {\n                ((struct lys_node_leaflist *)node)->max = rfn->mod.list.max;\n            }\n        }\n\n        /* must in leaf, leaf-list, list, container or anyxml */\n        if (rfn->must_size) {\n            switch (node->nodetype) {\n            case LYS_LEAF:\n                old_size = &((struct lys_node_leaf *)node)->must_size;\n                old_must = &((struct lys_node_leaf *)node)->must;\n                break;\n            case LYS_LEAFLIST:\n                old_size = &((struct lys_node_leaflist *)node)->must_size;\n                old_must = &((struct lys_node_leaflist *)node)->must;\n                break;\n            case LYS_LIST:\n                old_size = &((struct lys_node_list *)node)->must_size;\n                old_must = &((struct lys_node_list *)node)->must;\n                break;\n            case LYS_CONTAINER:\n                old_size = &((struct lys_node_container *)node)->must_size;\n                old_must = &((struct lys_node_container *)node)->must;\n                break;\n            case LYS_ANYXML:\n            case LYS_ANYDATA:\n                old_size = &((struct lys_node_anydata *)node)->must_size;\n                old_must = &((struct lys_node_anydata *)node)->must;\n                break;\n            default:\n                LOGINT(ctx);\n                goto fail;\n            }\n\n            size = *old_size + rfn->must_size;\n            must = realloc(*old_must, size * sizeof *rfn->must);\n            LY_CHECK_ERR_GOTO(!must, LOGMEM(ctx), fail);\n            for (k = 0, j = *old_size; k < rfn->must_size; k++, j++) {\n                must[j].ext_size = rfn->must[k].ext_size;\n                lys_ext_dup(ctx, rfn->module, rfn->must[k].ext, rfn->must[k].ext_size, &rfn->must[k], LYEXT_PAR_RESTR,\n                            &must[j].ext, 0, unres);\n                must[j].expr = lydict_insert(ctx, rfn->must[k].expr, 0);\n                must[j].dsc = lydict_insert(ctx, rfn->must[k].dsc, 0);\n                must[j].ref = lydict_insert(ctx, rfn->must[k].ref, 0);\n                must[j].eapptag = lydict_insert(ctx, rfn->must[k].eapptag, 0);\n                must[j].emsg = lydict_insert(ctx, rfn->must[k].emsg, 0);\n                must[j].flags = rfn->must[k].flags;\n            }\n\n            *old_must = must;\n            *old_size = size;\n\n            /* check XPath dependencies again */\n            if (unres_schema_add_node(node->module, unres, node, UNRES_XPATH, NULL) == -1) {\n                goto fail;\n            }\n        }\n\n        /* if-feature in leaf, leaf-list, list, container or anyxml */\n        if (rfn->iffeature_size) {\n            old_size = &node->iffeature_size;\n            old_iff = &node->iffeature;\n\n            size = *old_size + rfn->iffeature_size;\n            iff = realloc(*old_iff, size * sizeof *rfn->iffeature);\n            LY_CHECK_ERR_GOTO(!iff, LOGMEM(ctx), fail);\n            *old_iff = iff;\n\n            for (k = 0, j = *old_size; k < rfn->iffeature_size; k++, j++) {\n                resolve_iffeature_getsizes(&rfn->iffeature[k], &usize1, &usize2);\n                if (usize1) {\n                    /* there is something to duplicate */\n                    /* duplicate compiled expression */\n                    usize = (usize1 / 4) + (usize1 % 4) ? 1 : 0;\n                    iff[j].expr = malloc(usize * sizeof *iff[j].expr);\n                    LY_CHECK_ERR_GOTO(!iff[j].expr, LOGMEM(ctx), fail);\n                    memcpy(iff[j].expr, rfn->iffeature[k].expr, usize * sizeof *iff[j].expr);\n\n                    /* duplicate list of feature pointers */\n                    iff[j].features = malloc(usize2 * sizeof *iff[k].features);\n                    LY_CHECK_ERR_GOTO(!iff[j].expr, LOGMEM(ctx), fail);\n                    memcpy(iff[j].features, rfn->iffeature[k].features, usize2 * sizeof *iff[j].features);\n\n                    /* duplicate extensions */\n                    iff[j].ext_size = rfn->iffeature[k].ext_size;\n                    lys_ext_dup(ctx, rfn->module, rfn->iffeature[k].ext, rfn->iffeature[k].ext_size,\n                                &rfn->iffeature[k], LYEXT_PAR_IFFEATURE, &iff[j].ext, 0, unres);\n                }\n                (*old_size)++;\n            }\n            assert(*old_size == size);\n        }\n    }\n\n    /* apply augments */\n    for (i = 0; i < uses->augment_size; i++) {\n        rc = resolve_augment(&uses->augment[i], (struct lys_node *)uses, unres);\n        if (rc) {\n            goto fail;\n        }\n    }\n\n    /* check refines */\n    for (i = 0; i < uses->refine_size; i++) {\n        node = refine_nodes[i];\n        rfn = &uses->refine[i];\n\n        /* config on any nodetype */\n        if ((rfn->flags & LYS_CONFIG_MASK) && (node->flags & LYS_CONFIG_MASK)) {\n            for (parent = lys_parent(node); parent && parent->nodetype == LYS_USES; parent = lys_parent(parent));\n            if (parent && parent->nodetype != LYS_GROUPING && (parent->flags & LYS_CONFIG_MASK) &&\n                    ((parent->flags & LYS_CONFIG_MASK) != (rfn->flags & LYS_CONFIG_MASK)) &&\n                    (rfn->flags & LYS_CONFIG_W)) {\n                /* setting config true under config false is prohibited */\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, \"config\", \"refine\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                       \"changing config from 'false' to 'true' is prohibited while \"\n                       \"the target's parent is still config 'false'.\");\n                goto fail;\n            }\n\n            /* inherit config change to the target children */\n            LY_TREE_DFS_BEGIN(node->child, next, iter) {\n                if (rfn->flags & LYS_CONFIG_W) {\n                    if (iter->flags & LYS_CONFIG_SET) {\n                        /* config is set explicitely, go to next sibling */\n                        next = NULL;\n                        goto nextsibling;\n                    }\n                } else { /* LYS_CONFIG_R */\n                    if ((iter->flags & LYS_CONFIG_SET) && (iter->flags & LYS_CONFIG_W)) {\n                        /* error - we would have config data under status data */\n                        LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, \"config\", \"refine\");\n                        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                               \"changing config from 'true' to 'false' is prohibited while the target \"\n                               \"has still a children with explicit config 'true'.\");\n                        goto fail;\n                    }\n                }\n                /* change config */\n                iter->flags &= ~LYS_CONFIG_MASK;\n                iter->flags |= (rfn->flags & LYS_CONFIG_MASK);\n\n                /* select next iter - modified LY_TREE_DFS_END */\n                if (iter->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                    next = NULL;\n                } else {\n                    next = iter->child;\n                }\nnextsibling:\n                if (!next) {\n                    /* try siblings */\n                    next = iter->next;\n                }\n                while (!next) {\n                    /* parent is already processed, go to its sibling */\n                    iter = lys_parent(iter);\n\n                    /* no siblings, go back through parents */\n                    if (iter == node) {\n                        /* we are done, no next element to process */\n                        break;\n                    }\n                    next = iter->next;\n                }\n            }\n        }\n\n        /* default value */\n        if (rfn->dflt_size) {\n            if (node->nodetype == LYS_CHOICE) {\n                /* choice */\n                ((struct lys_node_choice *)node)->dflt = resolve_choice_dflt((struct lys_node_choice *)node,\n                                                                             rfn->dflt[0]);\n                if (!((struct lys_node_choice *)node)->dflt) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, rfn->dflt[0], \"default\");\n                    goto fail;\n                }\n                if (lyp_check_mandatory_choice(node)) {\n                    goto fail;\n                }\n            }\n        }\n\n        /* min/max-elements on list or leaf-list */\n        if (node->nodetype == LYS_LIST && ((struct lys_node_list *)node)->max) {\n            if (((struct lys_node_list *)node)->min > ((struct lys_node_list *)node)->max) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, uses, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", rfn->mod.list.min, \"min-elements\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n                goto fail;\n            }\n        } else if (node->nodetype == LYS_LEAFLIST && ((struct lys_node_leaflist *)node)->max) {\n            if (((struct lys_node_leaflist *)node)->min > ((struct lys_node_leaflist *)node)->max) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, uses, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", rfn->mod.list.min, \"min-elements\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n                goto fail;\n            }\n        }\n\n        /* additional checks */\n        /* default value with mandatory/min-elements */\n        if (node->nodetype == LYS_LEAFLIST) {\n            llist = (struct lys_node_leaflist *)node;\n            if (llist->dflt_size && llist->min) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, uses, rfn->dflt_size ? \"default\" : \"min-elements\", \"refine\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                       \"The \\\"min-elements\\\" statement with non-zero value is forbidden on leaf-lists with the \\\"default\\\" statement.\");\n                goto fail;\n            }\n        } else if (node->nodetype == LYS_LEAF) {\n            leaf = (struct lys_node_leaf *)node;\n            if (leaf->dflt && (leaf->flags & LYS_MAND_TRUE)) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, uses, rfn->dflt_size ? \"default\" : \"mandatory\", \"refine\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                       \"The \\\"mandatory\\\" statement is forbidden on leafs with the \\\"default\\\" statement.\");\n                goto fail;\n            }\n        }\n\n        /* check for mandatory node in default case, first find the closest parent choice to the changed node */\n        if ((rfn->flags & LYS_MAND_TRUE) || rfn->mod.list.min) {\n            for (parent = node->parent;\n                 parent && !(parent->nodetype & (LYS_CHOICE | LYS_GROUPING | LYS_ACTION | LYS_USES));\n                 parent = parent->parent) {\n                if (parent->nodetype == LYS_CONTAINER && ((struct lys_node_container *)parent)->presence) {\n                    /* stop also on presence containers */\n                    break;\n                }\n            }\n            /* and if it is a choice with the default case, check it for presence of a mandatory node in it */\n            if (parent && parent->nodetype == LYS_CHOICE && ((struct lys_node_choice *)parent)->dflt) {\n                if (lyp_check_mandatory_choice(parent)) {\n                    goto fail;\n                }\n            }\n        }\n    }\n    free(refine_nodes);\n\n    return EXIT_SUCCESS;\n\nfail:\n    LY_TREE_FOR_SAFE(uses->child, next, iter) {\n        lys_node_free(iter, NULL, 0);\n    }\n    free(refine_nodes);\n    return -1;\n}\n\nvoid\nresolve_identity_backlink_update(struct lys_ident *der, struct lys_ident *base)\n{\n    int i;\n\n    assert(der && base);\n\n    if (!base->der) {\n        /* create a set for backlinks if it does not exist */\n        base->der = ly_set_new();\n    }\n    /* store backlink */\n    ly_set_add(base->der, der, LY_SET_OPT_USEASLIST);\n\n    /* do it recursively */\n    for (i = 0; i < base->base_size; i++) {\n        resolve_identity_backlink_update(der, base->base[i]);\n    }\n}\n\n/**\n * @brief Resolve base identity recursively. Does not log.\n *\n * @param[in] module Main module.\n * @param[in] ident Identity to use.\n * @param[in] basename Base name of the identity.\n * @param[out] ret Pointer to the resolved identity. Can be NULL.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on crucial error.\n */\nstatic int\nresolve_base_ident_sub(const struct lys_module *module, struct lys_ident *ident, const char *basename,\n                       struct unres_schema *unres, struct lys_ident **ret)\n{\n    uint32_t i, j;\n    struct lys_ident *base = NULL;\n    struct ly_ctx *ctx = module->ctx;\n\n    assert(ret);\n\n    /* search module */\n    for (i = 0; i < module->ident_size; i++) {\n        if (!strcmp(basename, module->ident[i].name)) {\n\n            if (!ident) {\n                /* just search for type, so do not modify anything, just return\n                 * the base identity pointer */\n                *ret = &module->ident[i];\n                return EXIT_SUCCESS;\n            }\n\n            base = &module->ident[i];\n            goto matchfound;\n        }\n    }\n\n    /* search submodules */\n    for (j = 0; j < module->inc_size && module->inc[j].submodule; j++) {\n        for (i = 0; i < module->inc[j].submodule->ident_size; i++) {\n            if (!strcmp(basename, module->inc[j].submodule->ident[i].name)) {\n\n                if (!ident) {\n                    *ret = &module->inc[j].submodule->ident[i];\n                    return EXIT_SUCCESS;\n                }\n\n                base = &module->inc[j].submodule->ident[i];\n                goto matchfound;\n            }\n        }\n    }\n\nmatchfound:\n    /* we found it somewhere */\n    if (base) {\n        /* is it already completely resolved? */\n        for (i = 0; i < unres->count; i++) {\n            if ((unres->item[i] == base) && (unres->type[i] == UNRES_IDENT)) {\n                /* identity found, but not yet resolved, so do not return it in *res and try it again later */\n\n                /* simple check for circular reference,\n                 * the complete check is done as a side effect of using only completely\n                 * resolved identities (previous check of unres content) */\n                if (ly_strequal((const char *)unres->str_snode[i], ident->name, 1)) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, basename, \"base\");\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Circular reference of \\\"%s\\\" identity.\", basename);\n                    return -1;\n                }\n\n                return EXIT_FAILURE;\n            }\n        }\n\n        /* checks done, store the result */\n        *ret = base;\n        return EXIT_SUCCESS;\n    }\n\n    /* base not found (maybe a forward reference) */\n    return EXIT_FAILURE;\n}\n\n/**\n * @brief Resolve base identity. Logs directly.\n *\n * @param[in] module Main module.\n * @param[in] ident Identity to use.\n * @param[in] basename Base name of the identity.\n * @param[in] parent Either \"type\" or \"identity\".\n * @param[in,out] type Type structure where we want to resolve identity. Can be NULL.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_base_ident(const struct lys_module *module, struct lys_ident *ident, const char *basename, const char *parent,\n                   struct lys_type *type, struct unres_schema *unres)\n{\n    const char *name;\n    int mod_name_len = 0, rc;\n    struct lys_ident *target, **ret;\n    uint16_t flags;\n    struct lys_module *mod;\n    struct ly_ctx *ctx = module->ctx;\n\n    assert((ident && !type) || (!ident && type));\n\n    if (!type) {\n        /* have ident to resolve */\n        ret = &target;\n        flags = ident->flags;\n        mod = ident->module;\n    } else {\n        /* have type to fill */\n        ++type->info.ident.count;\n        type->info.ident.ref = ly_realloc(type->info.ident.ref, type->info.ident.count * sizeof *type->info.ident.ref);\n        LY_CHECK_ERR_RETURN(!type->info.ident.ref, LOGMEM(ctx), -1);\n\n        ret = &type->info.ident.ref[type->info.ident.count - 1];\n        flags = type->parent->flags;\n        mod = type->parent->module;\n    }\n    *ret = NULL;\n\n    /* search for the base identity */\n    name = strchr(basename, ':');\n    if (name) {\n        /* set name to correct position after colon */\n        mod_name_len = name - basename;\n        name++;\n\n        if (!strncmp(basename, module->name, mod_name_len) && !module->name[mod_name_len]) {\n            /* prefix refers to the current module, ignore it */\n            mod_name_len = 0;\n        }\n    } else {\n        name = basename;\n    }\n\n    /* get module where to search */\n    module = lyp_get_module(module, NULL, 0, mod_name_len ? basename : NULL, mod_name_len, 0);\n    if (!module) {\n        /* identity refers unknown data model */\n        LOGVAL(ctx, LYE_INMOD, LY_VLOG_NONE, NULL, basename);\n        return -1;\n    }\n\n    /* search in the identified module ... */\n    rc = resolve_base_ident_sub(module, ident, name, unres, ret);\n    if (!rc) {\n        assert(*ret);\n\n        /* check status */\n        if (lyp_check_status(flags, mod, ident ? ident->name : \"of type\",\n                             (*ret)->flags, (*ret)->module, (*ret)->name, NULL)) {\n            rc = -1;\n        } else if (ident) {\n            ident->base[ident->base_size++] = *ret;\n            if (lys_main_module(mod)->implemented) {\n                /* in case of the implemented identity, maintain backlinks to it\n                 * from the base identities to make it available when resolving\n                 * data with the identity values (not implemented identity is not\n                 * allowed as an identityref value). */\n                resolve_identity_backlink_update(ident, *ret);\n            }\n        }\n    } else if (rc == EXIT_FAILURE) {\n        LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_NONE, NULL, parent, basename);\n        if (type) {\n            --type->info.ident.count;\n        }\n    }\n\n    return rc;\n}\n\n/*\n * 1 - true (der is derived from base)\n * 0 - false (der is not derived from base)\n */\nstatic int\nsearch_base_identity(struct lys_ident *der, struct lys_ident *base)\n{\n    int i;\n\n    if (der == base) {\n        return 1;\n    } else {\n        for(i = 0; i < der->base_size; i++) {\n            if (search_base_identity(der->base[i], base) == 1) {\n                return 1;\n            }\n        }\n    }\n\n    return 0;\n}\n\n/**\n * @brief Resolve JSON data format identityref. Logs directly.\n *\n * @param[in] type Identityref type.\n * @param[in] ident_name Identityref name.\n * @param[in] node Node where the identityref is being resolved\n * @param[in] dflt flag if we are resolving default value in the schema\n *\n * @return Pointer to the identity resolvent, NULL on error.\n */\nstruct lys_ident *\nresolve_identref(struct lys_type *type, const char *ident_name, struct lyd_node *node, struct lys_module *mod, int dflt)\n{\n    const char *mod_name, *name;\n    char *str;\n    int mod_name_len, nam_len, rc;\n    int need_implemented = 0;\n    unsigned int i, j;\n    struct lys_ident *der, *cur;\n    struct lys_module *imod = NULL, *m, *tmod;\n    struct ly_ctx *ctx;\n\n    assert(type && ident_name && mod);\n    ctx = mod->ctx;\n\n    if (!type || (!type->info.ident.count && !type->der) || !ident_name) {\n        return NULL;\n    }\n\n    rc = parse_node_identifier(ident_name, &mod_name, &mod_name_len, &name, &nam_len, NULL, 0);\n    if (rc < 1) {\n        LOGVAL(ctx, LYE_INCHAR, node ? LY_VLOG_LYD : LY_VLOG_NONE, node, ident_name[-rc], &ident_name[-rc]);\n        return NULL;\n    } else if (rc < (signed)strlen(ident_name)) {\n        LOGVAL(ctx, LYE_INCHAR, node ? LY_VLOG_LYD : LY_VLOG_NONE, node, ident_name[rc], &ident_name[rc]);\n        return NULL;\n    }\n\n    m = lys_main_module(mod); /* shortcut */\n    if (!mod_name || (!strncmp(mod_name, m->name, mod_name_len) && !m->name[mod_name_len])) {\n        /* identity is defined in the same module as node */\n        imod = m;\n    } else if (dflt) {\n        /* solving identityref in default definition in schema -\n         * find the identity's module in the imported modules list to have a correct revision */\n        for (i = 0; i < mod->imp_size; i++) {\n            if (!strncmp(mod_name, mod->imp[i].module->name, mod_name_len) && !mod->imp[i].module->name[mod_name_len]) {\n                imod = mod->imp[i].module;\n                break;\n            }\n        }\n\n        /* We may need to pull it from the module that the typedef came from */\n        if (!imod && type && type->der) {\n            tmod = type->der->module;\n            for (i = 0; i < tmod->imp_size; i++) {\n                if (!strncmp(mod_name, tmod->imp[i].module->name, mod_name_len) && !tmod->imp[i].module->name[mod_name_len]) {\n                    imod = tmod->imp[i].module;\n                    break;\n                }\n            }\n        }\n    } else {\n        /* solving identityref in data - get the module from the context */\n        for (i = 0; i < (unsigned)mod->ctx->models.used; ++i) {\n            imod = mod->ctx->models.list[i];\n            if (!strncmp(mod_name, imod->name, mod_name_len) && !imod->name[mod_name_len]) {\n                break;\n            }\n            imod = NULL;\n        }\n        if (!imod && mod->ctx->models.parsing_sub_modules_count) {\n            /* we are currently parsing some module and checking XPath or a default value,\n             * so take this module into account */\n            for (i = 0; i < mod->ctx->models.parsing_sub_modules_count; i++) {\n                imod = mod->ctx->models.parsing_sub_modules[i];\n                if (imod->type) {\n                    /* skip submodules */\n                    continue;\n                }\n                if (!strncmp(mod_name, imod->name, mod_name_len) && !imod->name[mod_name_len]) {\n                    break;\n                }\n                imod = NULL;\n            }\n        }\n    }\n\n    if (!dflt && (!imod || !imod->implemented) && ctx->data_clb) {\n        /* the needed module was not found, but it may have been expected so call the data callback */\n        if (imod) {\n            ctx->data_clb(ctx, imod->name, imod->ns, LY_MODCLB_NOT_IMPLEMENTED, ctx->data_clb_data);\n        } else if (mod_name) {\n            str = strndup(mod_name, mod_name_len);\n            imod = (struct lys_module *)ctx->data_clb(ctx, str, NULL, 0, ctx->data_clb_data);\n            free(str);\n        }\n    }\n    if (!imod) {\n        goto fail;\n    }\n\n    if (m != imod || lys_main_module(type->parent->module) != mod) {\n        /* the type is not referencing the same schema,\n         * THEN, we may need to make the module with the identity implemented, but only if it really\n         * contains the identity */\n        if (!imod->implemented) {\n            cur = NULL;\n            /* get the identity in the module */\n            for (i = 0; i < imod->ident_size; i++) {\n                if (!strcmp(name, imod->ident[i].name)) {\n                    cur = &imod->ident[i];\n                    break;\n                }\n            }\n            if (!cur) {\n                /* go through includes */\n                for (j = 0; j < imod->inc_size; j++) {\n                    for (i = 0; i < imod->inc[j].submodule->ident_size; i++) {\n                        if (!strcmp(name, imod->inc[j].submodule->ident[i].name)) {\n                            cur = &imod->inc[j].submodule->ident[i];\n                            break;\n                        }\n                    }\n                }\n                if (!cur) {\n                    goto fail;\n                }\n            }\n\n            /* check that identity is derived from one of the type's base */\n            while (type->der) {\n                for (i = 0; i < type->info.ident.count; i++) {\n                    if (search_base_identity(cur, type->info.ident.ref[i])) {\n                        /* cur's base matches the type's base */\n                        need_implemented = 1;\n                        goto match;\n                    }\n                }\n                type = &type->der->type;\n            }\n            /* matching base not found */\n            LOGVAL(ctx, LYE_SPEC, node ? LY_VLOG_LYD : LY_VLOG_NONE, node, \"Identity used as identityref value is not implemented.\");\n            goto fail;\n        }\n    }\n\n    /* go through all the derived types of all the bases */\n    while (type->der) {\n        for (i = 0; i < type->info.ident.count; ++i) {\n            cur = type->info.ident.ref[i];\n\n            if (cur->der) {\n                /* there are some derived identities */\n                for (j = 0; j < cur->der->number; j++) {\n                    der = (struct lys_ident *)cur->der->set.g[j]; /* shortcut */\n                    if (!strcmp(der->name, name) && lys_main_module(der->module) == imod) {\n                        /* we have match */\n                        cur = der;\n                        goto match;\n                    }\n                }\n            }\n        }\n        type = &type->der->type;\n    }\n\nfail:\n    LOGVAL(ctx, LYE_INRESOLV, node ? LY_VLOG_LYD : LY_VLOG_NONE, node, \"identityref\", ident_name);\n    return NULL;\n\nmatch:\n    for (i = 0; i < cur->iffeature_size; i++) {\n        if (!resolve_iffeature(&cur->iffeature[i])) {\n            if (node) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, node, cur->name, node->schema->name);\n            }\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Identity \\\"%s\\\" is disabled by its if-feature condition.\", cur->name);\n            return NULL;\n        }\n    }\n    if (need_implemented) {\n        if (dflt) {\n            /* later try to make the module implemented */\n            LOGVRB(\"Making \\\"%s\\\" module implemented because of identityref default value \\\"%s\\\" used in the implemented \\\"%s\\\" module\",\n                   imod->name, cur->name, mod->name);\n            /* to be more effective we should use UNRES_MOD_IMPLEMENT but that would require changing prototype of\n             * several functions with little gain */\n            if (lys_set_implemented(imod)) {\n                LOGERR(ctx, ly_errno, \"Setting the module \\\"%s\\\" implemented because of used default identity \\\"%s\\\" failed.\",\n                       imod->name, cur->name);\n                goto fail;\n            }\n        } else {\n            /* just say that it was found, but in a non-implemented module */\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Identity found, but in a non-implemented module \\\"%s\\\".\",\n                   lys_main_module(cur->module)->name);\n            goto fail;\n        }\n    }\n    return cur;\n}\n\n/**\n * @brief Resolve unresolved uses. Logs directly.\n *\n * @param[in] uses Uses to use.\n * @param[in] unres Specific unres item.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_unres_schema_uses(struct lys_node_uses *uses, struct unres_schema *unres)\n{\n    int rc;\n    struct lys_node *par_grp;\n    struct ly_ctx *ctx = uses->module->ctx;\n\n    /* HACK: when a grouping has uses inside, all such uses have to be resolved before the grouping itself is used\n     *       in some uses. When we see such a uses, the grouping's unres counter is used to store number of so far\n     *       unresolved uses. The grouping cannot be used unless this counter is decreased back to 0. To remember\n     *       that the uses already increased grouping's counter, the LYS_USESGRP flag is used. */\n    for (par_grp = lys_parent((struct lys_node *)uses); par_grp && (par_grp->nodetype != LYS_GROUPING); par_grp = lys_parent(par_grp));\n    if (par_grp && ly_strequal(par_grp->name, uses->name, 1)) {\n        LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, uses, \"uses\", uses->name);\n        return -1;\n    }\n\n    if (!uses->grp) {\n        rc = resolve_uses_schema_nodeid(uses->name, (const struct lys_node *)uses, (const struct lys_node_grp **)&uses->grp);\n        if (rc == -1) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, uses, \"uses\", uses->name);\n            return -1;\n        } else if (rc > 0) {\n            LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, uses, uses->name[rc - 1], &uses->name[rc - 1]);\n            return -1;\n        } else if (!uses->grp) {\n            if (par_grp && !(uses->flags & LYS_USESGRP)) {\n                if (++((struct lys_node_grp *)par_grp)->unres_count == 0) {\n                    LOGERR(ctx, LY_EINT, \"Too many unresolved items (uses) inside a grouping.\");\n                    return -1;\n                }\n                uses->flags |= LYS_USESGRP;\n            }\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, uses, \"uses\", uses->name);\n            return EXIT_FAILURE;\n        }\n    }\n\n    if (uses->grp->unres_count) {\n        if (par_grp && !(uses->flags & LYS_USESGRP)) {\n            if (++((struct lys_node_grp *)par_grp)->unres_count == 0) {\n                LOGERR(ctx, LY_EINT, \"Too many unresolved items (uses) inside a grouping.\");\n                return -1;\n            }\n            uses->flags |= LYS_USESGRP;\n        } else {\n            /* instantiate grouping only when it is completely resolved */\n            uses->grp = NULL;\n        }\n        LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, uses, \"uses\", uses->name);\n        return EXIT_FAILURE;\n    }\n\n    rc = resolve_uses(uses, unres);\n    if (!rc) {\n        /* decrease unres count only if not first try */\n        if (par_grp && (uses->flags & LYS_USESGRP)) {\n            assert(((struct lys_node_grp *)par_grp)->unres_count);\n            ((struct lys_node_grp *)par_grp)->unres_count--;\n            uses->flags &= ~LYS_USESGRP;\n        }\n\n        /* check status */\n        if (lyp_check_status(uses->flags, uses->module, \"of uses\",\n                         uses->grp->flags, uses->grp->module, uses->grp->name,\n                         (struct lys_node *)uses)) {\n            return -1;\n        }\n\n        return EXIT_SUCCESS;\n    }\n\n    return rc;\n}\n\n/**\n * @brief Resolve list keys. Logs directly.\n *\n * @param[in] list List to use.\n * @param[in] keys_str Keys node value.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_list_keys(struct lys_node_list *list, const char *keys_str)\n{\n    int i, len, rc;\n    const char *value;\n    char *s = NULL;\n    struct ly_ctx *ctx = list->module->ctx;\n\n    for (i = 0; i < list->keys_size; ++i) {\n        assert(keys_str);\n\n        if (!list->child) {\n            /* no child, possible forward reference */\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list keys\", keys_str);\n            return EXIT_FAILURE;\n        }\n        /* get the key name */\n        if ((value = strpbrk(keys_str, \" \\t\\n\"))) {\n            len = value - keys_str;\n            while (isspace(value[0])) {\n                value++;\n            }\n        } else {\n            len = strlen(keys_str);\n        }\n\n        rc = lys_getnext_data(lys_node_module((struct lys_node *)list), (struct lys_node *)list, keys_str, len, LYS_LEAF,\n                              (const struct lys_node **)&list->keys[i]);\n        if (rc) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list key\", keys_str);\n            return EXIT_FAILURE;\n        }\n\n        if (check_key(list, i, keys_str, len)) {\n            /* check_key logs */\n            return -1;\n        }\n\n        /* check status */\n        if (lyp_check_status(list->flags, list->module, list->name,\n                             list->keys[i]->flags, list->keys[i]->module, list->keys[i]->name,\n                             (struct lys_node *)list->keys[i])) {\n            return -1;\n        }\n\n        /* default value - is ignored, keep it but print a warning */\n        if (list->keys[i]->dflt) {\n            /* log is not hidden only in case this resolving fails and in such a case\n             * we cannot get here\n             */\n            assert(log_opt == ILO_STORE);\n            log_opt = ILO_LOG;\n            LOGWRN(ctx, \"Default value \\\"%s\\\" in the list key \\\"%s\\\" is ignored. (%s)\", list->keys[i]->dflt,\n                   list->keys[i]->name, s = lys_path((struct lys_node*)list, LYS_PATH_FIRST_PREFIX));\n            log_opt = ILO_STORE;\n            free(s);\n        }\n\n        /* prepare for next iteration */\n        while (value && isspace(value[0])) {\n            value++;\n        }\n        keys_str = value;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Resolve (check) all must conditions of \\p node.\n * Logs directly.\n *\n * @param[in] node Data node with optional must statements.\n * @param[in] inout_parent If set, must in input or output parent of node->schema will be resolved.\n *\n * @return EXIT_SUCCESS on pass, EXIT_FAILURE on fail, -1 on error.\n */\nstatic int\nresolve_must(struct lyd_node *node, int inout_parent, int ignore_fail)\n{\n    uint8_t i, must_size;\n    struct lys_node *schema;\n    struct lys_restr *must;\n    struct lyxp_set set;\n    struct ly_ctx *ctx = node->schema->module->ctx;\n\n    assert(node);\n    memset(&set, 0, sizeof set);\n\n    if (inout_parent) {\n        for (schema = lys_parent(node->schema);\n             schema && (schema->nodetype & (LYS_CHOICE | LYS_CASE | LYS_USES));\n             schema = lys_parent(schema));\n        if (!schema || !(schema->nodetype & (LYS_INPUT | LYS_OUTPUT))) {\n            LOGINT(ctx);\n            return -1;\n        }\n        must_size = ((struct lys_node_inout *)schema)->must_size;\n        must = ((struct lys_node_inout *)schema)->must;\n\n        /* context node is the RPC/action */\n        node = node->parent;\n        if (!(node->schema->nodetype & (LYS_RPC | LYS_ACTION))) {\n            LOGINT(ctx);\n            return -1;\n        }\n    } else {\n        switch (node->schema->nodetype) {\n        case LYS_CONTAINER:\n            must_size = ((struct lys_node_container *)node->schema)->must_size;\n            must = ((struct lys_node_container *)node->schema)->must;\n            break;\n        case LYS_LEAF:\n            must_size = ((struct lys_node_leaf *)node->schema)->must_size;\n            must = ((struct lys_node_leaf *)node->schema)->must;\n            break;\n        case LYS_LEAFLIST:\n            must_size = ((struct lys_node_leaflist *)node->schema)->must_size;\n            must = ((struct lys_node_leaflist *)node->schema)->must;\n            break;\n        case LYS_LIST:\n            must_size = ((struct lys_node_list *)node->schema)->must_size;\n            must = ((struct lys_node_list *)node->schema)->must;\n            break;\n        case LYS_ANYXML:\n        case LYS_ANYDATA:\n            must_size = ((struct lys_node_anydata *)node->schema)->must_size;\n            must = ((struct lys_node_anydata *)node->schema)->must;\n            break;\n        case LYS_NOTIF:\n            must_size = ((struct lys_node_notif *)node->schema)->must_size;\n            must = ((struct lys_node_notif *)node->schema)->must;\n            break;\n        default:\n            must_size = 0;\n            break;\n        }\n    }\n\n    for (i = 0; i < must_size; ++i) {\n        if (lyxp_eval(must[i].expr, node, LYXP_NODE_ELEM, lyd_node_module(node), &set, LYXP_MUST)) {\n            return -1;\n        }\n\n        lyxp_set_cast(&set, LYXP_SET_BOOLEAN, node, lyd_node_module(node), LYXP_MUST);\n\n        if (!set.val.bool) {\n            if ((ignore_fail == 1) || ((must[i].flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP)) && (ignore_fail == 2))) {\n                LOGVRB(\"Must condition \\\"%s\\\" not satisfied, but it is not required.\", must[i].expr);\n            } else {\n                LOGVAL(ctx, LYE_NOMUST, LY_VLOG_LYD, node, must[i].expr);\n                if (must[i].emsg) {\n                    ly_vlog_str(ctx, LY_VLOG_PREV, must[i].emsg);\n                }\n                if (must[i].eapptag) {\n                    ly_err_last_set_apptag(ctx, must[i].eapptag);\n                }\n                return 1;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Resolve (find) when condition schema context node. Does not log.\n *\n * @param[in] schema Schema node with the when condition.\n * @param[out] ctx_snode When schema context node.\n * @param[out] ctx_snode_type Schema context node type.\n */\nvoid\nresolve_when_ctx_snode(const struct lys_node *schema, struct lys_node **ctx_snode, enum lyxp_node_type *ctx_snode_type)\n{\n    const struct lys_node *sparent;\n\n    /* find a not schema-only node */\n    *ctx_snode_type = LYXP_NODE_ELEM;\n    while (schema->nodetype & (LYS_USES | LYS_CHOICE | LYS_CASE | LYS_AUGMENT | LYS_INPUT | LYS_OUTPUT)) {\n        if (schema->nodetype == LYS_AUGMENT) {\n            sparent = ((struct lys_node_augment *)schema)->target;\n        } else {\n            sparent = schema->parent;\n        }\n        if (!sparent) {\n            /* context node is the document root (fake root in our case) */\n            if (schema->flags & LYS_CONFIG_W) {\n                *ctx_snode_type = LYXP_NODE_ROOT_CONFIG;\n            } else {\n                *ctx_snode_type = LYXP_NODE_ROOT;\n            }\n            /* we need the first top-level sibling, but no uses or groupings */\n            schema = lys_getnext(NULL, NULL, lys_node_module(schema), LYS_GETNEXT_NOSTATECHECK);\n            break;\n        }\n        schema = sparent;\n    }\n\n    *ctx_snode = (struct lys_node *)schema;\n}\n\n/**\n * @brief Resolve (find) when condition context node. Does not log.\n *\n * @param[in] node Data node, whose conditional definition is being decided.\n * @param[in] schema Schema node with the when condition.\n * @param[out] ctx_node Context node.\n * @param[out] ctx_node_type Context node type.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nstatic int\nresolve_when_ctx_node(struct lyd_node *node, struct lys_node *schema, struct lyd_node **ctx_node,\n                      enum lyxp_node_type *ctx_node_type)\n{\n    struct lyd_node *parent;\n    struct lys_node *sparent;\n    enum lyxp_node_type node_type;\n    uint16_t i, data_depth, schema_depth;\n\n    resolve_when_ctx_snode(schema, &schema, &node_type);\n\n    if (node_type == LYXP_NODE_ELEM) {\n        /* standard element context node */\n        for (parent = node, data_depth = 0; parent; parent = parent->parent, ++data_depth);\n        for (sparent = schema, schema_depth = 0;\n                sparent;\n                sparent = (sparent->nodetype == LYS_AUGMENT ? ((struct lys_node_augment *)sparent)->target : sparent->parent)) {\n            if (sparent->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_ANYDATA | LYS_NOTIF | LYS_RPC)) {\n                ++schema_depth;\n            }\n        }\n        if (data_depth < schema_depth) {\n            return -1;\n        }\n\n        /* find the corresponding data node */\n        for (i = 0; i < data_depth - schema_depth; ++i) {\n            node = node->parent;\n        }\n        if (node->schema != schema) {\n            return -1;\n        }\n    } else {\n        /* root context node */\n        while (node->parent) {\n            node = node->parent;\n        }\n        while (node->prev->next) {\n            node = node->prev;\n        }\n    }\n\n    *ctx_node = node;\n    *ctx_node_type = node_type;\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Temporarily unlink nodes as per YANG 1.1 RFC section 7.21.5 for when XPath evaluation.\n * The context node is adjusted if needed.\n *\n * @param[in] snode Schema node, whose children instances need to be unlinked.\n * @param[in,out] node Data siblings where to look for the children of \\p snode. If it is unlinked,\n * it is moved to point to another sibling still in the original tree.\n * @param[in,out] ctx_node When context node, adjusted if needed.\n * @param[in] ctx_node_type Context node type, just for information to detect invalid situations.\n * @param[out] unlinked_nodes Unlinked siblings. Can be safely appended to \\p node afterwards.\n * Ordering may change, but there will be no semantic change.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nstatic int\nresolve_when_unlink_nodes(struct lys_node *snode, struct lyd_node **node, struct lyd_node **ctx_node,\n                          enum lyxp_node_type ctx_node_type, struct lyd_node **unlinked_nodes)\n{\n    struct lyd_node *next, *elem;\n    const struct lys_node *slast;\n    struct ly_ctx *ctx = snode->module->ctx;\n\n    switch (snode->nodetype) {\n    case LYS_AUGMENT:\n    case LYS_USES:\n    case LYS_CHOICE:\n    case LYS_CASE:\n        slast = NULL;\n        while ((slast = lys_getnext(slast, snode, NULL, LYS_GETNEXT_PARENTUSES))) {\n            if (slast->nodetype & (LYS_ACTION | LYS_NOTIF)) {\n                continue;\n            }\n\n            if (resolve_when_unlink_nodes((struct lys_node *)slast, node, ctx_node, ctx_node_type, unlinked_nodes)) {\n                return -1;\n            }\n        }\n        break;\n    case LYS_CONTAINER:\n    case LYS_LIST:\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        LY_TREE_FOR_SAFE(lyd_first_sibling(*node), next, elem) {\n            if (elem->schema == snode) {\n\n                if (elem == *ctx_node) {\n                    /* We are going to unlink our context node! This normally cannot happen,\n                     * but we use normal top-level data nodes for faking a document root node,\n                     * so if this is the context node, we just use the next top-level node.\n                     * Additionally, it can even happen that there are no top-level data nodes left,\n                     * all were unlinked, so in this case we pass NULL as the context node/data tree,\n                     * lyxp_eval() can handle this special situation.\n                     */\n                    if (ctx_node_type == LYXP_NODE_ELEM) {\n                        LOGINT(ctx);\n                        return -1;\n                    }\n\n                    if (elem->prev == elem) {\n                        /* unlinking last top-level element, use an empty data tree */\n                        *ctx_node = NULL;\n                    } else {\n                        /* in this case just use the previous/last top-level data node */\n                        *ctx_node = elem->prev;\n                    }\n                } else if (elem == *node) {\n                    /* We are going to unlink the currently processed node. This does not matter that\n                     * much, but we would lose access to the original data tree, so just move our\n                     * pointer somewhere still inside it.\n                     */\n                    if ((*node)->prev != *node) {\n                        *node = (*node)->prev;\n                    } else {\n                        /* the processed node with sibings were all unlinked, oh well */\n                        *node = NULL;\n                    }\n                }\n\n                /* temporarily unlink the node */\n                lyd_unlink_internal(elem, 0);\n                if (*unlinked_nodes) {\n                    if (lyd_insert_after((*unlinked_nodes)->prev, elem)) {\n                        LOGINT(ctx);\n                        return -1;\n                    }\n                } else {\n                    *unlinked_nodes = elem;\n                }\n\n                if (snode->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_ANYDATA)) {\n                    /* there can be only one instance */\n                    break;\n                }\n            }\n        }\n        break;\n    default:\n        LOGINT(ctx);\n        return -1;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Relink the unlinked nodes back.\n *\n * @param[in] node Data node to link the nodes back to. It can actually be the adjusted context node,\n * we simply need a sibling from the original data tree.\n * @param[in] unlinked_nodes Unlinked nodes to relink to \\p node.\n * @param[in] ctx_node_type Context node type to distinguish between \\p node being the parent\n * or the sibling of \\p unlinked_nodes.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nstatic int\nresolve_when_relink_nodes(struct lyd_node *node, struct lyd_node *unlinked_nodes, enum lyxp_node_type ctx_node_type)\n{\n    struct lyd_node *elem;\n\n    LY_TREE_FOR_SAFE(unlinked_nodes, unlinked_nodes, elem) {\n        lyd_unlink_internal(elem, 0);\n        if (ctx_node_type == LYXP_NODE_ELEM) {\n            if (lyd_insert_common(node, NULL, elem, 0)) {\n                return -1;\n            }\n        } else {\n            if (lyd_insert_nextto(node, elem, 0, 0)) {\n                return -1;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\nresolve_applies_must(const struct lyd_node *node)\n{\n    int ret = 0;\n    uint8_t must_size;\n    struct lys_node *schema, *iter;\n\n    assert(node);\n\n    schema = node->schema;\n\n    /* their own must */\n    switch (schema->nodetype) {\n    case LYS_CONTAINER:\n        must_size = ((struct lys_node_container *)schema)->must_size;\n        break;\n    case LYS_LEAF:\n        must_size = ((struct lys_node_leaf *)schema)->must_size;\n        break;\n    case LYS_LEAFLIST:\n        must_size = ((struct lys_node_leaflist *)schema)->must_size;\n        break;\n    case LYS_LIST:\n        must_size = ((struct lys_node_list *)schema)->must_size;\n        break;\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        must_size = ((struct lys_node_anydata *)schema)->must_size;\n        break;\n    case LYS_NOTIF:\n        must_size = ((struct lys_node_notif *)schema)->must_size;\n        break;\n    default:\n        must_size = 0;\n        break;\n    }\n\n    if (must_size) {\n        ++ret;\n    }\n\n    /* schema may be a direct data child of input/output with must (but it must be first, it needs to be evaluated only once) */\n    if (!node->prev->next) {\n        for (iter = lys_parent(schema); iter && (iter->nodetype & (LYS_CHOICE | LYS_CASE | LYS_USES)); iter = lys_parent(iter));\n        if (iter && (iter->nodetype & (LYS_INPUT | LYS_OUTPUT))) {\n            ret += 0x2;\n        }\n    }\n\n    return ret;\n}\n\nstatic struct lys_when *\nsnode_get_when(const struct lys_node *schema)\n{\n    switch (schema->nodetype) {\n    case LYS_CONTAINER:\n        return ((struct lys_node_container *)schema)->when;\n    case LYS_CHOICE:\n        return ((struct lys_node_choice *)schema)->when;\n    case LYS_LEAF:\n        return ((struct lys_node_leaf *)schema)->when;\n    case LYS_LEAFLIST:\n        return ((struct lys_node_leaflist *)schema)->when;\n    case LYS_LIST:\n        return ((struct lys_node_list *)schema)->when;\n    case LYS_ANYDATA:\n    case LYS_ANYXML:\n        return ((struct lys_node_anydata *)schema)->when;\n    case LYS_CASE:\n        return ((struct lys_node_case *)schema)->when;\n    case LYS_USES:\n        return ((struct lys_node_uses *)schema)->when;\n    case LYS_AUGMENT:\n        return ((struct lys_node_augment *)schema)->when;\n    default:\n        return NULL;\n    }\n}\n\nint\nresolve_applies_when(const struct lys_node *schema, int mode, const struct lys_node *stop)\n{\n    const struct lys_node *parent;\n\n    assert(schema);\n\n    if (!(schema->nodetype & (LYS_NOTIF | LYS_RPC)) && snode_get_when(schema)) {\n        return 1;\n    }\n\n    parent = schema;\n    goto check_augment;\n\n    while (parent) {\n        /* stop conditions */\n        if (!mode) {\n            /* stop on node that can be instantiated in data tree */\n            if (!(parent->nodetype & (LYS_USES | LYS_CHOICE | LYS_CASE))) {\n                break;\n            }\n        } else {\n            /* stop on the specified node */\n            if (parent == stop) {\n                break;\n            }\n        }\n\n        if (snode_get_when(parent)) {\n            return 1;\n        }\ncheck_augment:\n\n        if (parent->parent && (parent->parent->nodetype == LYS_AUGMENT) && snode_get_when(parent->parent)) {\n            return 1;\n        }\n        parent = lys_parent(parent);\n    }\n\n    return 0;\n}\n\n/**\n * @brief Resolve (check) all when conditions relevant for \\p node.\n * Logs directly.\n *\n * @param[in] node Data node, whose conditional reference, if such, is being decided.\n * @param[in] ignore_fail 1 if when does not have to be satisfied, 2 if it does not have to be satisfied\n * only when requiring external dependencies.\n *\n * @return\n *  -1 - error, ly_errno is set\n *   0 - all \"when\" statements true\n *   0, ly_vecode = LYVE_NOWHEN - some \"when\" statement false, returned in failed_when\n *   1, ly_vecode = LYVE_INWHEN - nodes needed to resolve are conditional and not yet resolved (under another \"when\")\n */\nint\nresolve_when(struct lyd_node *node, int ignore_fail, struct lys_when **failed_when)\n{\n    struct lyd_node *ctx_node = NULL, *unlinked_nodes, *tmp_node;\n    struct lys_node *sparent;\n    struct lyxp_set set;\n    enum lyxp_node_type ctx_node_type;\n    struct ly_ctx *ctx = node->schema->module->ctx;\n    int rc = 0;\n\n    assert(node);\n    memset(&set, 0, sizeof set);\n\n    if (!(node->schema->nodetype & (LYS_NOTIF | LYS_RPC | LYS_ACTION)) && snode_get_when(node->schema)) {\n        /* make the node dummy for the evaluation */\n        node->validity |= LYD_VAL_INUSE;\n        rc = lyxp_eval(snode_get_when(node->schema)->cond, node, LYXP_NODE_ELEM, lyd_node_module(node),\n                       &set, LYXP_WHEN);\n        node->validity &= ~LYD_VAL_INUSE;\n        if (rc) {\n            if (rc == 1) {\n                LOGVAL(ctx, LYE_INWHEN, LY_VLOG_LYD, node, snode_get_when(node->schema)->cond);\n            }\n            goto cleanup;\n        }\n\n        /* set boolean result of the condition */\n        lyxp_set_cast(&set, LYXP_SET_BOOLEAN, node, lyd_node_module(node), LYXP_WHEN);\n        if (!set.val.bool) {\n            node->when_status |= LYD_WHEN_FALSE;\n            if ((ignore_fail == 1) || ((snode_get_when(node->schema)->flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP))\n                    && (ignore_fail == 2))) {\n                LOGVRB(\"When condition \\\"%s\\\" is not satisfied, but it is not required.\", snode_get_when(node->schema)->cond);\n            } else {\n                LOGVAL(ctx, LYE_NOWHEN, LY_VLOG_LYD, node, snode_get_when(node->schema)->cond);\n                if (failed_when) {\n                    *failed_when = snode_get_when(node->schema);\n                }\n                goto cleanup;\n            }\n        }\n\n        /* free xpath set content */\n        lyxp_set_cast(&set, LYXP_SET_EMPTY, node, lyd_node_module(node), 0);\n    }\n\n    sparent = node->schema;\n    goto check_augment;\n\n    /* check when in every schema node that affects node */\n    while (sparent && (sparent->nodetype & (LYS_USES | LYS_CHOICE | LYS_CASE))) {\n        if (snode_get_when(sparent)) {\n            if (!ctx_node) {\n                rc = resolve_when_ctx_node(node, sparent, &ctx_node, &ctx_node_type);\n                if (rc) {\n                    LOGINT(ctx);\n                    goto cleanup;\n                }\n            }\n\n            unlinked_nodes = NULL;\n            /* we do not want our node pointer to change */\n            tmp_node = node;\n            rc = resolve_when_unlink_nodes(sparent, &tmp_node, &ctx_node, ctx_node_type, &unlinked_nodes);\n            if (rc) {\n                goto cleanup;\n            }\n\n            rc = lyxp_eval(snode_get_when(sparent)->cond, ctx_node, ctx_node_type, lys_node_module(sparent),\n                           &set, LYXP_WHEN);\n\n            if (unlinked_nodes && ctx_node) {\n                if (resolve_when_relink_nodes(ctx_node, unlinked_nodes, ctx_node_type)) {\n                    rc = -1;\n                    goto cleanup;\n                }\n            }\n\n            if (rc) {\n                if (rc == 1) {\n                    LOGVAL(ctx, LYE_INWHEN, LY_VLOG_LYD, node, snode_get_when(sparent)->cond);\n                }\n                goto cleanup;\n            }\n\n            lyxp_set_cast(&set, LYXP_SET_BOOLEAN, ctx_node, lys_node_module(sparent), LYXP_WHEN);\n            if (!set.val.bool) {\n                if ((ignore_fail == 1) || ((snode_get_when(sparent)->flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP))\n                        && (ignore_fail == 2))) {\n                    LOGVRB(\"When condition \\\"%s\\\" is not satisfied, but it is not required.\", snode_get_when(sparent)->cond);\n                } else {\n                    node->when_status |= LYD_WHEN_FALSE;\n                    LOGVAL(ctx, LYE_NOWHEN, LY_VLOG_LYD, node, snode_get_when(sparent)->cond);\n                    if (failed_when) {\n                        *failed_when = snode_get_when(sparent);\n                    }\n                    goto cleanup;\n                }\n            }\n\n            /* free xpath set content */\n            lyxp_set_cast(&set, LYXP_SET_EMPTY, ctx_node, lys_node_module(sparent), 0);\n        }\n\ncheck_augment:\n        if ((sparent->parent && (sparent->parent->nodetype == LYS_AUGMENT) && snode_get_when(sparent->parent))) {\n            if (!ctx_node) {\n                rc = resolve_when_ctx_node(node, sparent->parent, &ctx_node, &ctx_node_type);\n                if (rc) {\n                    LOGINT(ctx);\n                    goto cleanup;\n                }\n            }\n\n            unlinked_nodes = NULL;\n            tmp_node = node;\n            rc = resolve_when_unlink_nodes(sparent->parent, &tmp_node, &ctx_node, ctx_node_type, &unlinked_nodes);\n            if (rc) {\n                goto cleanup;\n            }\n\n            rc = lyxp_eval(snode_get_when(sparent->parent)->cond, ctx_node, ctx_node_type,\n                           lys_node_module(sparent->parent), &set, LYXP_WHEN);\n\n            /* reconnect nodes, if ctx_node is NULL then all the nodes were unlinked, but linked together,\n             * so the tree did not actually change and there is nothing for us to do\n             */\n            if (unlinked_nodes && ctx_node) {\n                if (resolve_when_relink_nodes(ctx_node, unlinked_nodes, ctx_node_type)) {\n                    rc = -1;\n                    goto cleanup;\n                }\n            }\n\n            if (rc) {\n                if (rc == 1) {\n                    LOGVAL(ctx, LYE_INWHEN, LY_VLOG_LYD, node, snode_get_when(sparent->parent)->cond);\n                }\n                goto cleanup;\n            }\n\n            lyxp_set_cast(&set, LYXP_SET_BOOLEAN, ctx_node, lys_node_module(sparent->parent), LYXP_WHEN);\n            if (!set.val.bool) {\n                node->when_status |= LYD_WHEN_FALSE;\n                if ((ignore_fail == 1) || ((snode_get_when(sparent->parent)->flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP))\n                        && (ignore_fail == 2))) {\n                    LOGVRB(\"When condition \\\"%s\\\" is not satisfied, but it is not required.\",\n                           snode_get_when(sparent->parent)->cond);\n                } else {\n                    LOGVAL(ctx, LYE_NOWHEN, LY_VLOG_LYD, node, snode_get_when(sparent->parent)->cond);\n                    if (failed_when) {\n                        *failed_when = snode_get_when(sparent->parent);\n                    }\n                    goto cleanup;\n                }\n            }\n\n            /* free xpath set content */\n            lyxp_set_cast(&set, LYXP_SET_EMPTY, ctx_node, lys_node_module(sparent->parent), 0);\n        }\n\n        sparent = lys_parent(sparent);\n    }\n\n    node->when_status |= LYD_WHEN_TRUE;\n\ncleanup:\n    /* free xpath set content */\n    lyxp_set_cast(&set, LYXP_SET_EMPTY, ctx_node ? ctx_node : node, NULL, 0);\n    return rc;\n}\n\nstatic int\ncheck_type_union_leafref(struct lys_type *type)\n{\n    uint8_t i;\n\n    if ((type->base == LY_TYPE_UNION) && type->info.uni.count) {\n        /* go through unions and look for leafref */\n        for (i = 0; i < type->info.uni.count; ++i) {\n            switch (type->info.uni.types[i].base) {\n            case LY_TYPE_LEAFREF:\n                return 1;\n            case LY_TYPE_UNION:\n                if (check_type_union_leafref(&type->info.uni.types[i])) {\n                    return 1;\n                }\n                break;\n            default:\n                break;\n            }\n        }\n\n        return 0;\n    }\n\n    /* just inherit the flag value */\n    return type->der->has_union_leafref;\n}\n\n/**\n * @brief Resolve a single unres schema item. Logs indirectly.\n *\n * @param[in] mod Main module.\n * @param[in] item Item to resolve. Type determined by \\p type.\n * @param[in] type Type of the unresolved item.\n * @param[in] str_snode String, a schema node, or NULL.\n * @param[in] unres Unres schema structure to use.\n * @param[in] final_fail Whether we are just printing errors of the failed unres items.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_unres_schema_item(struct lys_module *mod, void *item, enum UNRES_ITEM type, void *str_snode,\n                          struct unres_schema *unres)\n{\n    /* has_str - whether the str_snode is a string in a dictionary that needs to be freed */\n    int rc = -1, has_str = 0, parent_type = 0, i, k;\n    unsigned int j;\n    struct ly_ctx * ctx = mod->ctx;\n    struct lys_node *root, *next, *node, *par_grp;\n    const char *expr;\n    uint8_t *u;\n\n    struct ly_set *refs, *procs;\n    struct lys_feature *ref, *feat;\n    struct lys_ident *ident;\n    struct lys_type *stype;\n    struct lys_node_choice *choic;\n    struct lyxml_elem *yin;\n    struct yang_type *yang;\n    struct unres_list_uniq *unique_info;\n    struct unres_iffeat_data *iff_data;\n    struct unres_ext *ext_data;\n    struct lys_ext_instance *ext, **extlist;\n    struct lyext_plugin *eplugin;\n\n    switch (type) {\n    case UNRES_IDENT:\n        expr = str_snode;\n        has_str = 1;\n        ident = item;\n\n        rc = resolve_base_ident(mod, ident, expr, \"identity\", NULL, unres);\n        break;\n    case UNRES_TYPE_IDENTREF:\n        expr = str_snode;\n        has_str = 1;\n        stype = item;\n\n        rc = resolve_base_ident(mod, NULL, expr, \"type\", stype, unres);\n        break;\n    case UNRES_TYPE_LEAFREF:\n        node = str_snode;\n        stype = item;\n\n        rc = resolve_schema_leafref(stype, node, unres);\n        break;\n    case UNRES_TYPE_DER_EXT:\n        parent_type++;\n        /* falls through */\n    case UNRES_TYPE_DER_TPDF:\n        parent_type++;\n        /* falls through */\n    case UNRES_TYPE_DER:\n        /* parent */\n        node = str_snode;\n        stype = item;\n\n        /* HACK type->der is temporarily unparsed type statement */\n        yin = (struct lyxml_elem *)stype->der;\n        stype->der = NULL;\n\n        if (yin->flags & LY_YANG_STRUCTURE_FLAG) {\n            yang = (struct yang_type *)yin;\n            rc = yang_check_type(mod, node, yang, stype, parent_type, unres);\n\n            if (rc) {\n                /* may try again later */\n                stype->der = (struct lys_tpdf *)yang;\n            } else {\n                /* we need to always be able to free this, it's safe only in this case */\n                lydict_remove(ctx, yang->name);\n                free(yang);\n            }\n\n        } else {\n            rc = fill_yin_type(mod, node, yin, stype, parent_type, unres);\n            if (!rc || rc == -1) {\n                /* we need to always be able to free this, it's safe only in this case */\n                lyxml_free(ctx, yin);\n            } else {\n                /* may try again later, put all back how it was */\n                stype->der = (struct lys_tpdf *)yin;\n            }\n        }\n        if (rc == EXIT_SUCCESS) {\n            /* it does not make sense to have leaf-list of empty type */\n            if (!parent_type && node->nodetype == LYS_LEAFLIST && stype->base == LY_TYPE_EMPTY) {\n                LOGWRN(ctx, \"The leaf-list \\\"%s\\\" is of \\\"empty\\\" type, which does not make sense.\", node->name);\n            }\n\n            if ((type == UNRES_TYPE_DER_TPDF) && (stype->base == LY_TYPE_UNION)) {\n                /* fill typedef union leafref flag */\n                ((struct lys_tpdf *)stype->parent)->has_union_leafref = check_type_union_leafref(stype);\n            } else if ((type == UNRES_TYPE_DER) && stype->der->has_union_leafref) {\n                /* copy the type in case it has union leafref flag */\n                if (lys_copy_union_leafrefs(mod, node, stype, NULL, unres)) {\n                    LOGERR(ctx, LY_EINT, \"Failed to duplicate type.\");\n                    return -1;\n                }\n            }\n        } else if (rc == EXIT_FAILURE && !(stype->value_flags & LY_VALUE_UNRESGRP)) {\n            /* forward reference - in case the type is in grouping, we have to make the grouping unusable\n             * by uses statement until the type is resolved. We do that the same way as uses statements inside\n             * grouping. The grouping cannot be used unless the unres counter is 0.\n             * To remember that the grouping already increased the counter, the LYTYPE_GRP is used as value\n             * of the type's base member. */\n            for (par_grp = node; par_grp && (par_grp->nodetype != LYS_GROUPING); par_grp = lys_parent(par_grp));\n            if (par_grp) {\n                if (++((struct lys_node_grp *)par_grp)->unres_count == 0) {\n                    LOGERR(ctx, LY_EINT, \"Too many unresolved items (type) inside a grouping.\");\n                    return -1;\n                }\n                stype->value_flags |= LY_VALUE_UNRESGRP;\n            }\n        }\n        break;\n    case UNRES_IFFEAT:\n        iff_data = str_snode;\n        rc = resolve_feature(iff_data->fname, strlen(iff_data->fname), iff_data->node, item);\n        if (!rc) {\n            /* success */\n            if (iff_data->infeature) {\n                /* store backlink into the target feature to allow reverse changes in case of changing feature status */\n                feat = *((struct lys_feature **)item);\n                if (!feat->depfeatures) {\n                    feat->depfeatures = ly_set_new();\n                }\n                ly_set_add(feat->depfeatures, iff_data->node, LY_SET_OPT_USEASLIST);\n            }\n            /* cleanup temporary data */\n            lydict_remove(ctx, iff_data->fname);\n            free(iff_data);\n        }\n        break;\n    case UNRES_FEATURE:\n        feat = (struct lys_feature *)item;\n\n        if (feat->iffeature_size) {\n            refs = ly_set_new();\n            procs = ly_set_new();\n            ly_set_add(procs, feat, 0);\n\n            while (procs->number) {\n                ref = procs->set.g[procs->number - 1];\n                ly_set_rm_index(procs, procs->number - 1);\n\n                for (i = 0; i < ref->iffeature_size; i++) {\n                    resolve_iffeature_getsizes(&ref->iffeature[i], NULL, &j);\n                    for (; j > 0 ; j--) {\n                        if (ref->iffeature[i].features[j - 1]) {\n                            if (ref->iffeature[i].features[j - 1] == feat) {\n                                LOGVAL(ctx, LYE_CIRC_FEATURES, LY_VLOG_NONE, NULL, feat->name);\n                                goto featurecheckdone;\n                            }\n\n                            if (ref->iffeature[i].features[j - 1]->iffeature_size) {\n                                k = refs->number;\n                                if (ly_set_add(refs, ref->iffeature[i].features[j - 1], 0) == k) {\n                                    /* not yet seen feature, add it for processing */\n                                    ly_set_add(procs, ref->iffeature[i].features[j - 1], 0);\n                                }\n                            }\n                        } else {\n                            /* forward reference */\n                            rc = EXIT_FAILURE;\n                            goto featurecheckdone;\n                        }\n                    }\n\n                }\n            }\n            rc = EXIT_SUCCESS;\n\nfeaturecheckdone:\n            ly_set_free(refs);\n            ly_set_free(procs);\n        }\n\n        break;\n    case UNRES_USES:\n        rc = resolve_unres_schema_uses(item, unres);\n        break;\n    case UNRES_TYPEDEF_DFLT:\n        parent_type++;\n        /* falls through */\n    case UNRES_TYPE_DFLT:\n        stype = item;\n        rc = check_default(stype, (const char **)str_snode, mod, parent_type);\n        if ((rc == EXIT_FAILURE) && !parent_type && (stype->base == LY_TYPE_LEAFREF)) {\n            for (par_grp = (struct lys_node *)stype->parent;\n                 par_grp && (par_grp->nodetype != LYS_GROUPING);\n                 par_grp = lys_parent(par_grp));\n            if (par_grp) {\n                /* checking default value in a grouping finished with forward reference means we cannot check the value */\n                rc = EXIT_SUCCESS;\n            }\n        }\n        break;\n    case UNRES_CHOICE_DFLT:\n        expr = str_snode;\n        has_str = 1;\n        choic = item;\n\n        if (!choic->dflt) {\n            choic->dflt = resolve_choice_dflt(choic, expr);\n        }\n        if (choic->dflt) {\n            rc = lyp_check_mandatory_choice((struct lys_node *)choic);\n        } else {\n            rc = EXIT_FAILURE;\n        }\n        break;\n    case UNRES_LIST_KEYS:\n        rc = resolve_list_keys(item, ((struct lys_node_list *)item)->keys_str);\n        break;\n    case UNRES_LIST_UNIQ:\n        unique_info = (struct unres_list_uniq *)item;\n        rc = resolve_unique(unique_info->list, unique_info->expr, unique_info->trg_type);\n        break;\n    case UNRES_AUGMENT:\n        rc = resolve_augment(item, NULL, unres);\n        break;\n    case UNRES_XPATH:\n        node = (struct lys_node *)item;\n        rc = check_xpath(node, 1);\n        break;\n    case UNRES_MOD_IMPLEMENT:\n        rc = lys_make_implemented_r(mod, unres);\n        break;\n    case UNRES_EXT:\n        ext_data = (struct unres_ext *)str_snode;\n        extlist = &(*(struct lys_ext_instance ***)item)[ext_data->ext_index];\n        rc = resolve_extension(ext_data, extlist, unres);\n        if (!rc) {\n            /* success */\n            /* is there a callback to be done to finalize the extension? */\n            eplugin = extlist[0]->def->plugin;\n            if (eplugin) {\n                if (eplugin->check_result || (eplugin->flags & LYEXT_OPT_INHERIT)) {\n                    u = malloc(sizeof *u);\n                    LY_CHECK_ERR_RETURN(!u, LOGMEM(ctx), -1);\n                    (*u) = ext_data->ext_index;\n                    if (unres_schema_add_node(mod, unres, item, UNRES_EXT_FINALIZE, (struct lys_node *)u) == -1) {\n                        /* something really bad happend since the extension finalization is not actually\n                         * being resolved while adding into unres, so something more serious with the unres\n                         * list itself must happened */\n                        return -1;\n                    }\n                }\n            }\n        }\n        if (!rc || rc == -1) {\n            /* cleanup on success or fatal error */\n            if (ext_data->datatype == LYS_IN_YIN) {\n                /* YIN */\n                lyxml_free(ctx, ext_data->data.yin);\n            } else {\n                /* YANG */\n                yang_free_ext_data(ext_data->data.yang);\n            }\n            free(ext_data);\n        }\n        break;\n    case UNRES_EXT_FINALIZE:\n        u = (uint8_t *)str_snode;\n        ext = (*(struct lys_ext_instance ***)item)[*u];\n        free(u);\n\n        eplugin = ext->def->plugin;\n\n        /* inherit */\n        if ((eplugin->flags & LYEXT_OPT_INHERIT) && (ext->parent_type == LYEXT_PAR_NODE)) {\n            root = (struct lys_node *)ext->parent;\n            if (!(root->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA))) {\n                LY_TREE_DFS_BEGIN(root->child, next, node) {\n                    /* first, check if the node already contain instance of the same extension,\n                     * in such a case we won't inherit. In case the node was actually defined as\n                     * augment data, we are supposed to check the same way also the augment node itself */\n                    if (lys_ext_instance_presence(ext->def, node->ext, node->ext_size) != -1) {\n                        goto inherit_dfs_sibling;\n                    } else if (node->parent != root && node->parent->nodetype == LYS_AUGMENT &&\n                            lys_ext_instance_presence(ext->def, node->parent->ext, node->parent->ext_size) != -1) {\n                        goto inherit_dfs_sibling;\n                    }\n\n                    if (eplugin->check_inherit) {\n                        /* we have a callback to check the inheritance, use it */\n                        switch ((rc = (*eplugin->check_inherit)(ext, node))) {\n                        case 0:\n                            /* yes - continue with the inheriting code */\n                            break;\n                        case 1:\n                            /* no - continue with the node's sibling */\n                            goto inherit_dfs_sibling;\n                        case 2:\n                            /* no, but continue with the children, just skip the inheriting code for this node */\n                            goto inherit_dfs_child;\n                        default:\n                            LOGERR(ctx, LY_EINT, \"Plugin's (%s:%s) check_inherit callback returns invalid value (%d),\",\n                                   ext->def->module->name, ext->def->name, rc);\n                        }\n                    }\n\n                    /* inherit the extension */\n                    extlist = realloc(node->ext, (node->ext_size + 1) * sizeof *node->ext);\n                    LY_CHECK_ERR_RETURN(!extlist, LOGMEM(ctx), -1);\n                    extlist[node->ext_size] = malloc(sizeof **extlist);\n                    LY_CHECK_ERR_RETURN(!extlist[node->ext_size], LOGMEM(ctx); node->ext = extlist, -1);\n                    memcpy(extlist[node->ext_size], ext, sizeof *ext);\n                    extlist[node->ext_size]->flags |= LYEXT_OPT_INHERIT;\n\n                    node->ext = extlist;\n                    node->ext_size++;\n\ninherit_dfs_child:\n                    /* modification of - select element for the next run - children first */\n                    if (node->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                        next = NULL;\n                    } else {\n                        next = node->child;\n                    }\n                    if (!next) {\ninherit_dfs_sibling:\n                        /* no children, try siblings */\n                        next = node->next;\n                    }\n                    while (!next) {\n                        /* go to the parent */\n                        node = lys_parent(node);\n\n                        /* we are done if we are back in the root (the starter's parent */\n                        if (node == root) {\n                            break;\n                        }\n\n                        /* parent is already processed, go to its sibling */\n                        next = node->next;\n                    }\n                }\n            }\n        }\n\n        /* final check */\n        if (eplugin->check_result) {\n            if ((*eplugin->check_result)(ext)) {\n                LOGERR(ctx, LY_EPLUGIN, \"Resolving extension failed.\");\n                return -1;\n            }\n        }\n\n        rc = 0;\n        break;\n    default:\n        LOGINT(ctx);\n        break;\n    }\n\n    if (has_str && !rc) {\n        /* the string is no more needed in case of success.\n         * In case of forward reference, we will try to resolve the string later */\n        lydict_remove(ctx, str_snode);\n    }\n\n    return rc;\n}\n\n/* logs directly */\nstatic void\nprint_unres_schema_item_fail(void *item, enum UNRES_ITEM type, void *str_node)\n{\n    struct lyxml_elem *xml;\n    struct lyxml_attr *attr;\n    struct unres_iffeat_data *iff_data;\n    const char *name = NULL;\n    struct unres_ext *extinfo;\n\n    switch (type) {\n    case UNRES_IDENT:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"identity\", (char *)str_node);\n        break;\n    case UNRES_TYPE_IDENTREF:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"identityref\", (char *)str_node);\n        break;\n    case UNRES_TYPE_LEAFREF:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"leafref\",\n               ((struct lys_type *)item)->info.lref.path);\n        break;\n    case UNRES_TYPE_DER_EXT:\n    case UNRES_TYPE_DER_TPDF:\n    case UNRES_TYPE_DER:\n        xml = (struct lyxml_elem *)((struct lys_type *)item)->der;\n        if (xml->flags & LY_YANG_STRUCTURE_FLAG) {\n            name = ((struct yang_type *)xml)->name;\n        } else {\n            LY_TREE_FOR(xml->attr, attr) {\n                if ((attr->type == LYXML_ATTR_STD) && !strcmp(attr->name, \"name\")) {\n                    name = attr->value;\n                    break;\n                }\n            }\n            assert(attr);\n        }\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"derived type\", name);\n        break;\n    case UNRES_IFFEAT:\n        iff_data = str_node;\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"if-feature\", iff_data->fname);\n        break;\n    case UNRES_FEATURE:\n        LOGVRB(\"There are unresolved if-features for \\\"%s\\\" feature circular dependency check, it will be attempted later\",\n               ((struct lys_feature *)item)->name);\n        break;\n    case UNRES_USES:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"uses\", ((struct lys_node_uses *)item)->name);\n        break;\n    case UNRES_TYPEDEF_DFLT:\n    case UNRES_TYPE_DFLT:\n        if (*(char **)str_node) {\n            LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"type default\", *(char **)str_node);\n        }   /* else no default value in the type itself, but we are checking some restrictions against\n             *  possible default value of some base type. The failure is caused by not resolved base type,\n             *  so it was already reported */\n        break;\n    case UNRES_CHOICE_DFLT:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"choice default\", (char *)str_node);\n        break;\n    case UNRES_LIST_KEYS:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"list keys\", (char *)str_node);\n        break;\n    case UNRES_LIST_UNIQ:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"list unique\", (char *)str_node);\n        break;\n    case UNRES_AUGMENT:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"augment target\",\n               ((struct lys_node_augment *)item)->target_name);\n        break;\n    case UNRES_XPATH:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"XPath expressions of\",\n               ((struct lys_node *)item)->name);\n        break;\n    case UNRES_EXT:\n        extinfo = (struct unres_ext *)str_node;\n        name = extinfo->datatype == LYS_IN_YIN ? extinfo->data.yin->name : NULL; /* TODO YANG extension */\n        LOGVRB(\"Resolving extension \\\"%s\\\" failed, it will be attempted later.\", name);\n        break;\n    default:\n        LOGINT(NULL);\n        break;\n    }\n}\n\nstatic int\nresolve_unres_schema_types(struct unres_schema *unres, enum UNRES_ITEM types, struct ly_ctx *ctx, int forward_ref,\n                           int print_all_errors, uint32_t *resolved)\n{\n    uint32_t i, unres_count, res_count;\n    int ret = 0, rc;\n    struct ly_err_item *prev_eitem;\n    enum int_log_opts prev_ilo;\n    LY_ERR prev_ly_errno;\n\n    /* if there can be no forward references, every failure is final, so we can print it directly */\n    if (forward_ref) {\n        prev_ly_errno = ly_errno;\n        ly_ilo_change(ctx, ILO_STORE, &prev_ilo, &prev_eitem);\n    }\n\n    do {\n        unres_count = 0;\n        res_count = 0;\n\n        for (i = 0; i < unres->count; ++i) {\n            /* UNRES_TYPE_LEAFREF must be resolved (for storing leafref target pointers);\n             * if-features are resolved here to make sure that we will have all if-features for\n             * later check of feature circular dependency */\n            if (unres->type[i] & types) {\n                ++unres_count;\n                rc = resolve_unres_schema_item(unres->module[i], unres->item[i], unres->type[i], unres->str_snode[i], unres);\n                if (unres->type[i] == UNRES_EXT_FINALIZE) {\n                    /* to avoid double free */\n                    unres->type[i] = UNRES_RESOLVED;\n                }\n                if (!rc || (unres->type[i] == UNRES_XPATH)) {\n                    /* invalid XPath can never cause an error, only a warning */\n                    if (unres->type[i] == UNRES_LIST_UNIQ) {\n                        /* free the allocated structure */\n                        free(unres->item[i]);\n                    }\n\n                    unres->type[i] = UNRES_RESOLVED;\n                    ++(*resolved);\n                    ++res_count;\n                } else if ((rc == EXIT_FAILURE) && forward_ref) {\n                    /* forward reference, erase errors */\n                    ly_err_free_next(ctx, prev_eitem);\n                } else if (print_all_errors) {\n                    /* just so that we quit the loop */\n                    ++res_count;\n                    ret = -1;\n                } else {\n                    if (forward_ref) {\n                        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 1);\n                    }\n                    return -1;\n                }\n            }\n        }\n    } while (res_count && (res_count < unres_count));\n\n    if (res_count < unres_count) {\n        assert(forward_ref);\n        /* just print the errors (but we must free the ones we have and get them again :-/ ) */\n        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 0);\n\n        for (i = 0; i < unres->count; ++i) {\n            if (unres->type[i] & types) {\n                resolve_unres_schema_item(unres->module[i], unres->item[i], unres->type[i], unres->str_snode[i], unres);\n            }\n        }\n        return -1;\n    }\n\n    if (forward_ref) {\n        /* restore log */\n        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 0);\n        ly_errno = prev_ly_errno;\n    }\n\n    return ret;\n}\n\n/**\n * @brief Resolve every unres schema item in the structure. Logs directly.\n *\n * @param[in] mod Main module.\n * @param[in] unres Unres schema structure to use.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nint\nresolve_unres_schema(struct lys_module *mod, struct unres_schema *unres)\n{\n    uint32_t resolved = 0;\n\n    assert(unres);\n\n    LOGVRB(\"Resolving \\\"%s\\\" unresolved schema nodes and their constraints...\", mod->name);\n\n    /* UNRES_TYPE_LEAFREF must be resolved (for storing leafref target pointers);\n     * if-features are resolved here to make sure that we will have all if-features for\n     * later check of feature circular dependency */\n    if (resolve_unres_schema_types(unres, UNRES_USES | UNRES_IFFEAT | UNRES_TYPE_DER | UNRES_TYPE_DER_TPDF | UNRES_TYPE_DER_TPDF\n                                   | UNRES_TYPE_LEAFREF | UNRES_MOD_IMPLEMENT | UNRES_AUGMENT | UNRES_CHOICE_DFLT | UNRES_IDENT,\n                                   mod->ctx, 1, 0, &resolved)) {\n        return -1;\n    }\n\n    /* another batch of resolved items */\n    if (resolve_unres_schema_types(unres, UNRES_TYPE_IDENTREF | UNRES_FEATURE | UNRES_TYPEDEF_DFLT | UNRES_TYPE_DFLT\n                                   | UNRES_LIST_KEYS | UNRES_LIST_UNIQ | UNRES_EXT, mod->ctx, 1, 0, &resolved)) {\n        return -1;\n    }\n\n    /* print xpath warnings and finalize extensions, keep it last to provide the complete schema tree information to the plugin's checkers */\n    if (resolve_unres_schema_types(unres, UNRES_XPATH | UNRES_EXT_FINALIZE, mod->ctx, 0, 1, &resolved)) {\n        return -1;\n    }\n\n    LOGVRB(\"All \\\"%s\\\" schema nodes and constraints resolved.\", mod->name);\n    unres->count = 0;\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Try to resolve an unres schema item with a string argument. Logs indirectly.\n *\n * @param[in] mod Main module.\n * @param[in] unres Unres schema structure to use.\n * @param[in] item Item to resolve. Type determined by \\p type.\n * @param[in] type Type of the unresolved item.\n * @param[in] str String argument.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on storing the item in unres, -1 on error.\n */\nint\nunres_schema_add_str(struct lys_module *mod, struct unres_schema *unres, void *item, enum UNRES_ITEM type,\n                     const char *str)\n{\n    int rc;\n    const char *dictstr;\n\n    dictstr = lydict_insert(mod->ctx, str, 0);\n    rc = unres_schema_add_node(mod, unres, item, type, (struct lys_node *)dictstr);\n\n    if (rc < 0) {\n        lydict_remove(mod->ctx, dictstr);\n    }\n    return rc;\n}\n\n/**\n * @brief Try to resolve an unres schema item with a schema node argument. Logs indirectly.\n *\n * @param[in] mod Main module.\n * @param[in] unres Unres schema structure to use.\n * @param[in] item Item to resolve. Type determined by \\p type.\n * @param[in] type Type of the unresolved item. UNRES_TYPE_DER is handled specially!\n * @param[in] snode Schema node argument.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on storing the item in unres, -1 on error.\n */\nint\nunres_schema_add_node(struct lys_module *mod, struct unres_schema *unres, void *item, enum UNRES_ITEM type,\n                      struct lys_node *snode)\n{\n    int rc;\n    uint32_t u;\n    enum int_log_opts prev_ilo;\n    struct ly_err_item *prev_eitem;\n    LY_ERR prev_ly_errno;\n    struct lyxml_elem *yin;\n    struct ly_ctx *ctx = mod->ctx;\n\n    assert(unres && (item || (type == UNRES_MOD_IMPLEMENT)) && ((type != UNRES_LEAFREF) && (type != UNRES_INSTID)\n           && (type != UNRES_WHEN) && (type != UNRES_MUST)));\n\n    /* check for duplicities in unres */\n    for (u = 0; u < unres->count; u++) {\n        if (unres->type[u] == type && unres->item[u] == item &&\n                unres->str_snode[u] == snode && unres->module[u] == mod) {\n            /* duplication can happen when the node contains multiple statements of the same type to check,\n             * this can happen for example when refinement is being applied, so we just postpone the processing\n             * and do not duplicate the information */\n            return EXIT_FAILURE;\n        }\n    }\n\n    if ((type == UNRES_EXT_FINALIZE) || (type == UNRES_XPATH) || (type == UNRES_MOD_IMPLEMENT)) {\n        /* extension finalization is not even tried when adding the item into the inres list,\n         * xpath is not tried because it would hide some potential warnings,\n         * implementing module must be deferred because some other nodes can be added that will need to be traversed\n         * and their targets made implemented */\n        rc = EXIT_FAILURE;\n    } else {\n        prev_ly_errno = ly_errno;\n        ly_ilo_change(ctx, ILO_STORE, &prev_ilo, &prev_eitem);\n\n        rc = resolve_unres_schema_item(mod, item, type, snode, unres);\n        if (rc != EXIT_FAILURE) {\n            ly_ilo_restore(ctx, prev_ilo, prev_eitem, rc == -1 ? 1 : 0);\n            if (rc != -1) {\n                ly_errno = prev_ly_errno;\n            }\n\n            if (type == UNRES_LIST_UNIQ) {\n                /* free the allocated structure */\n                free(item);\n            } else if (rc == -1 && type == UNRES_IFFEAT) {\n                /* free the allocated resources */\n                free(*((char **)item));\n            }\n            return rc;\n        } else {\n            /* erase info about validation errors */\n            ly_ilo_restore(ctx, prev_ilo, prev_eitem, 0);\n            ly_errno = prev_ly_errno;\n        }\n\n        print_unres_schema_item_fail(item, type, snode);\n\n        /* HACK unlinking is performed here so that we do not do any (NS) copying in vain */\n        if (type == UNRES_TYPE_DER || type == UNRES_TYPE_DER_TPDF) {\n            yin = (struct lyxml_elem *)((struct lys_type *)item)->der;\n            if (!(yin->flags & LY_YANG_STRUCTURE_FLAG)) {\n                lyxml_unlink_elem(mod->ctx, yin, 1);\n                ((struct lys_type *)item)->der = (struct lys_tpdf *)yin;\n            }\n        }\n    }\n\n    unres->count++;\n    unres->item = ly_realloc(unres->item, unres->count*sizeof *unres->item);\n    LY_CHECK_ERR_RETURN(!unres->item, LOGMEM(ctx), -1);\n    unres->item[unres->count-1] = item;\n    unres->type = ly_realloc(unres->type, unres->count*sizeof *unres->type);\n    LY_CHECK_ERR_RETURN(!unres->type, LOGMEM(ctx), -1);\n    unres->type[unres->count-1] = type;\n    unres->str_snode = ly_realloc(unres->str_snode, unres->count*sizeof *unres->str_snode);\n    LY_CHECK_ERR_RETURN(!unres->str_snode, LOGMEM(ctx), -1);\n    unres->str_snode[unres->count-1] = snode;\n    unres->module = ly_realloc(unres->module, unres->count*sizeof *unres->module);\n    LY_CHECK_ERR_RETURN(!unres->module, LOGMEM(ctx), -1);\n    unres->module[unres->count-1] = mod;\n\n    return rc;\n}\n\n/**\n * @brief Duplicate an unres schema item. Logs indirectly.\n *\n * @param[in] mod Main module.\n * @param[in] unres Unres schema structure to use.\n * @param[in] item Old item to be resolved.\n * @param[in] type Type of the old unresolved item.\n * @param[in] new_item New item to use in the duplicate.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE if item is not in unres, -1 on error.\n */\nint\nunres_schema_dup(struct lys_module *mod, struct unres_schema *unres, void *item, enum UNRES_ITEM type, void *new_item)\n{\n    int i;\n    struct unres_list_uniq aux_uniq;\n    struct unres_iffeat_data *iff_data;\n\n    assert(item && new_item && ((type != UNRES_LEAFREF) && (type != UNRES_INSTID) && (type != UNRES_WHEN)));\n\n    /* hack for UNRES_LIST_UNIQ, which stores multiple items behind its item */\n    if (type == UNRES_LIST_UNIQ) {\n        aux_uniq.list = item;\n        aux_uniq.expr = ((struct unres_list_uniq *)new_item)->expr;\n        item = &aux_uniq;\n    }\n    i = unres_schema_find(unres, -1, item, type);\n\n    if (i == -1) {\n        if (type == UNRES_LIST_UNIQ) {\n            free(new_item);\n        }\n        return EXIT_FAILURE;\n    }\n\n    if ((type == UNRES_TYPE_LEAFREF) || (type == UNRES_USES) || (type == UNRES_TYPE_DFLT) ||\n            (type == UNRES_FEATURE) || (type == UNRES_LIST_UNIQ)) {\n        if (unres_schema_add_node(mod, unres, new_item, type, unres->str_snode[i]) == -1) {\n            LOGINT(mod->ctx);\n            return -1;\n        }\n    } else if (type == UNRES_IFFEAT) {\n        /* duplicate unres_iffeature_data */\n        iff_data = malloc(sizeof *iff_data);\n        LY_CHECK_ERR_RETURN(!iff_data, LOGMEM(mod->ctx), -1);\n        iff_data->fname = lydict_insert(mod->ctx, ((struct unres_iffeat_data *)unres->str_snode[i])->fname, 0);\n        iff_data->node = ((struct unres_iffeat_data *)unres->str_snode[i])->node;\n        if (unres_schema_add_node(mod, unres, new_item, type, (struct lys_node *)iff_data) == -1) {\n            LOGINT(mod->ctx);\n            return -1;\n        }\n    } else {\n        if (unres_schema_add_str(mod, unres, new_item, type, unres->str_snode[i]) == -1) {\n            LOGINT(mod->ctx);\n            return -1;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* does not log */\nint\nunres_schema_find(struct unres_schema *unres, int start_on_backwards, void *item, enum UNRES_ITEM type)\n{\n    int i;\n    struct unres_list_uniq *aux_uniq1, *aux_uniq2;\n\n    if (!unres->count) {\n        return -1;\n    }\n\n    if (start_on_backwards >= 0) {\n        i = start_on_backwards;\n    } else {\n        i = unres->count - 1;\n    }\n    for (; i > -1; i--) {\n        if (unres->type[i] != type) {\n            continue;\n        }\n        if (type != UNRES_LIST_UNIQ) {\n            if (unres->item[i] == item) {\n                break;\n            }\n        } else {\n            aux_uniq1 = (struct unres_list_uniq *)unres->item[i];\n            aux_uniq2 = (struct unres_list_uniq *)item;\n            if ((aux_uniq1->list == aux_uniq2->list) && ly_strequal(aux_uniq1->expr, aux_uniq2->expr, 0)) {\n                break;\n            }\n        }\n    }\n\n    return i;\n}\n\nstatic void\nunres_schema_free_item(struct ly_ctx *ctx, struct unres_schema *unres, uint32_t i)\n{\n    struct lyxml_elem *yin;\n    struct yang_type *yang;\n    struct unres_iffeat_data *iff_data;\n\n    switch (unres->type[i]) {\n    case UNRES_TYPE_DER_TPDF:\n    case UNRES_TYPE_DER:\n        yin = (struct lyxml_elem *)((struct lys_type *)unres->item[i])->der;\n        if (yin->flags & LY_YANG_STRUCTURE_FLAG) {\n            yang =(struct yang_type *)yin;\n            ((struct lys_type *)unres->item[i])->base = yang->base;\n            lydict_remove(ctx, yang->name);\n            free(yang);\n            if (((struct lys_type *)unres->item[i])->base == LY_TYPE_UNION) {\n                yang_free_type_union(ctx, (struct lys_type *)unres->item[i]);\n            }\n        } else {\n            lyxml_free(ctx, yin);\n        }\n        break;\n    case UNRES_IFFEAT:\n        iff_data = (struct unres_iffeat_data *)unres->str_snode[i];\n        lydict_remove(ctx, iff_data->fname);\n        free(unres->str_snode[i]);\n        break;\n    case UNRES_IDENT:\n    case UNRES_TYPE_IDENTREF:\n    case UNRES_CHOICE_DFLT:\n    case UNRES_LIST_KEYS:\n        lydict_remove(ctx, (const char *)unres->str_snode[i]);\n        break;\n    case UNRES_LIST_UNIQ:\n        free(unres->item[i]);\n        break;\n    case UNRES_EXT:\n        free(unres->str_snode[i]);\n        break;\n    case UNRES_EXT_FINALIZE:\n        free(unres->str_snode[i]);\n    default:\n        break;\n    }\n    unres->type[i] = UNRES_RESOLVED;\n}\n\nvoid\nunres_schema_free(struct lys_module *module, struct unres_schema **unres, int all)\n{\n    uint32_t i;\n    unsigned int unresolved = 0;\n\n    if (!unres || !(*unres)) {\n        return;\n    }\n\n    assert(module || ((*unres)->count == 0));\n\n    for (i = 0; i < (*unres)->count; ++i) {\n        if (!all && ((*unres)->module[i] != module)) {\n            if ((*unres)->type[i] != UNRES_RESOLVED) {\n                unresolved++;\n            }\n            continue;\n        }\n\n        /* free heap memory for the specific item */\n        unres_schema_free_item(module->ctx, *unres, i);\n    }\n\n    /* free it all */\n    if (!module || all || (!unresolved && !module->type)) {\n        free((*unres)->item);\n        free((*unres)->type);\n        free((*unres)->str_snode);\n        free((*unres)->module);\n        free((*unres));\n        (*unres) = NULL;\n    }\n}\n\n/* check whether instance-identifier points outside its data subtree (for operation it is any node\n * outside the operation subtree, otherwise it is a node from a foreign model) */\nstatic int\ncheck_instid_ext_dep(const struct lys_node *sleaf, const char *json_instid)\n{\n    const struct lys_node *op_node, *first_node;\n    enum int_log_opts prev_ilo;\n    char *buf, *tmp;\n\n    if (!json_instid || !json_instid[0]) {\n        /* no/empty value */\n        return 0;\n    }\n\n    for (op_node = lys_parent(sleaf);\n         op_node && !(op_node->nodetype & (LYS_NOTIF | LYS_RPC | LYS_ACTION));\n         op_node = lys_parent(op_node));\n\n    if (op_node && lys_parent(op_node)) {\n        /* nested operation - any absolute path is external */\n        return 1;\n    }\n\n    /* get the first node from the instid */\n    tmp = strchr(json_instid + 1, '/');\n    buf = strndup(json_instid, tmp ? (size_t)(tmp - json_instid) : strlen(json_instid));\n    if (!buf) {\n        /* so that we do not have to bother with logging, say it is not external */\n        return 0;\n    }\n\n    /* find the first schema node, do not log */\n    ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n    first_node = ly_ctx_get_node(NULL, sleaf, buf, 0);\n    ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n\n    free(buf);\n    if (!first_node) {\n        /* unknown path, say it is external */\n        return 1;\n    }\n\n    /* based on the first schema node in the path we can decide whether it points to an external tree or not */\n\n    if (op_node) {\n        if (op_node != first_node) {\n            /* it is a top-level operation, so we're good if it points somewhere inside it */\n            return 1;\n        }\n    } else {\n        if (lys_node_module(sleaf) != lys_node_module(first_node)) {\n            /* modules differ */\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n/**\n * @brief Resolve instance-identifier in JSON data format. Logs directly.\n *\n * @param[in] data Data node where the path is used\n * @param[in] path Instance-identifier node value.\n * @param[in,out] ret Resolved instance or NULL.\n *\n * @return 0 on success (even if unresolved and \\p ret is NULL), -1 on error.\n */\nstatic int\nresolve_instid(struct lyd_node *data, const char *path, int req_inst, struct lyd_node **ret)\n{\n    int i = 0, j, parsed, cur_idx;\n    const struct lys_module *mod, *prev_mod = NULL;\n    struct ly_ctx *ctx = data->schema->module->ctx;\n    struct lyd_node *root, *node;\n    const char *model = NULL, *name;\n    char *str;\n    int mod_len, name_len, has_predicate;\n    struct unres_data node_match;\n\n    memset(&node_match, 0, sizeof node_match);\n    *ret = NULL;\n\n    /* we need root to resolve absolute path */\n    for (root = data; root->parent; root = root->parent);\n    /* we're still parsing it and the pointer is not correct yet */\n    if (root->prev) {\n        for (; root->prev->next; root = root->prev);\n    }\n\n    /* search for the instance node */\n    while (path[i]) {\n        j = parse_instance_identifier(&path[i], &model, &mod_len, &name, &name_len, &has_predicate);\n        if (j <= 0) {\n            LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYD, data, path[i-j], &path[i-j]);\n            goto error;\n        }\n        i += j;\n\n        if (model) {\n            str = strndup(model, mod_len);\n            if (!str) {\n                LOGMEM(ctx);\n                goto error;\n            }\n            mod = ly_ctx_get_module(ctx, str, NULL, 1);\n            if (ctx->data_clb) {\n                if (!mod) {\n                    mod = ctx->data_clb(ctx, str, NULL, 0, ctx->data_clb_data);\n                } else if (!mod->implemented) {\n                    mod = ctx->data_clb(ctx, mod->name, mod->ns, LY_MODCLB_NOT_IMPLEMENTED, ctx->data_clb_data);\n                }\n            }\n            free(str);\n\n            if (!mod || !mod->implemented || mod->disabled) {\n                break;\n            }\n        } else if (!prev_mod) {\n            /* first iteration and we are missing module name */\n            LOGVAL(ctx, LYE_INELEM_LEN, LY_VLOG_LYD, data, name_len, name);\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Instance-identifier is missing prefix in the first node.\");\n            goto error;\n        } else {\n            mod = prev_mod;\n        }\n\n        if (resolve_data(mod, name, name_len, root, &node_match)) {\n            /* no instance exists */\n            break;\n        }\n\n        if (has_predicate) {\n            /* we have predicate, so the current results must be list or leaf-list */\n            parsed = j = 0;\n            /* index of the current node (for lists with position predicates) */\n            cur_idx = 1;\n            while (j < (signed)node_match.count) {\n                node = node_match.node[j];\n                parsed = resolve_instid_predicate(mod, &path[i], &node, cur_idx);\n                if (parsed < 1) {\n                    LOGVAL(ctx, LYE_INPRED, LY_VLOG_LYD, data, &path[i - parsed]);\n                    goto error;\n                }\n\n                if (!node) {\n                    /* current node does not satisfy the predicate */\n                    unres_data_del(&node_match, j);\n                } else {\n                    ++j;\n                }\n                ++cur_idx;\n            }\n\n            i += parsed;\n        } else if (node_match.count) {\n            /* check that we are not addressing lists */\n            for (j = 0; (unsigned)j < node_match.count; ++j) {\n                if (node_match.node[j]->schema->nodetype == LYS_LIST) {\n                    unres_data_del(&node_match, j--);\n                }\n            }\n            if (!node_match.count) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYD, data, \"Instance identifier is missing list keys.\");\n            }\n        }\n\n        prev_mod = mod;\n    }\n\n    if (!node_match.count) {\n        /* no instance exists */\n        if (req_inst > -1) {\n            LOGVAL(ctx, LYE_NOREQINS, LY_VLOG_LYD, data, path);\n            return EXIT_FAILURE;\n        }\n        LOGVRB(\"There is no instance of \\\"%s\\\", but it is not required.\", path);\n        return EXIT_SUCCESS;\n    } else if (node_match.count > 1) {\n        /* instance identifier must resolve to a single node */\n        LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYD, data, path, \"data tree\");\n        goto error;\n    } else {\n        /* we have required result, remember it and cleanup */\n        *ret = node_match.node[0];\n        free(node_match.node);\n        return EXIT_SUCCESS;\n    }\n\nerror:\n    /* cleanup */\n    free(node_match.node);\n    return -1;\n}\n\nstatic int\nresolve_leafref(struct lyd_node_leaf_list *leaf, const char *path, int req_inst, struct lyd_node **ret)\n{\n    struct lyxp_set xp_set;\n    uint32_t i;\n\n    memset(&xp_set, 0, sizeof xp_set);\n    *ret = NULL;\n\n    /* syntax was already checked, so just evaluate the path using standard XPath */\n    if (lyxp_eval(path, (struct lyd_node *)leaf, LYXP_NODE_ELEM, lyd_node_module((struct lyd_node *)leaf), &xp_set, 0) != EXIT_SUCCESS) {\n        return -1;\n    }\n\n    if (xp_set.type == LYXP_SET_NODE_SET) {\n        for (i = 0; i < xp_set.used; ++i) {\n            if ((xp_set.val.nodes[i].type != LYXP_NODE_ELEM) || !(xp_set.val.nodes[i].node->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n                continue;\n            }\n\n            /* not that the value is already in canonical form since the parsers does the conversion,\n             * so we can simply compare just the values */\n            if (ly_strequal(leaf->value_str, ((struct lyd_node_leaf_list *)xp_set.val.nodes[i].node)->value_str, 1)) {\n                /* we have the match */\n                *ret = xp_set.val.nodes[i].node;\n                break;\n            }\n        }\n    }\n\n    lyxp_set_cast(&xp_set, LYXP_SET_EMPTY, (struct lyd_node *)leaf, NULL, 0);\n\n    if (!*ret) {\n        /* reference not found */\n        if (req_inst > -1) {\n            LOGVAL(leaf->schema->module->ctx, LYE_NOLEAFREF, LY_VLOG_LYD, leaf, path, leaf->value_str);\n            return EXIT_FAILURE;\n        } else {\n            LOGVRB(\"There is no leafref \\\"%s\\\" with the value \\\"%s\\\", but it is not required.\", path, leaf->value_str);\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* ignore fail because we are parsing edit-config, get, or get-config - but only if the union includes leafref or instid */\nint\nresolve_union(struct lyd_node_leaf_list *leaf, struct lys_type *type, int store, int ignore_fail,\n              struct lys_type **resolved_type)\n{\n    struct ly_ctx *ctx = leaf->schema->module->ctx;\n    struct lys_type *t;\n    struct lyd_node *ret;\n    enum int_log_opts prev_ilo;\n    int found, success = 0, ext_dep, req_inst;\n    const char *json_val = NULL;\n\n    assert(type->base == LY_TYPE_UNION);\n\n    if ((leaf->value_type == LY_TYPE_UNION) || ((leaf->value_type == LY_TYPE_INST) && (leaf->value_flags & LY_VALUE_UNRES))) {\n        /* either NULL or instid previously converted to JSON */\n        json_val = lydict_insert(ctx, leaf->value.string, 0);\n    }\n\n    if (store) {\n        lyd_free_value(leaf->value, leaf->value_type, leaf->value_flags, &((struct lys_node_leaf *)leaf->schema)->type,\n                       NULL, NULL, NULL);\n        memset(&leaf->value, 0, sizeof leaf->value);\n    }\n\n    /* turn logging off, we are going to try to validate the value with all the types in order */\n    ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, 0);\n\n    t = NULL;\n    found = 0;\n    while ((t = lyp_get_next_union_type(type, t, &found))) {\n        found = 0;\n\n        switch (t->base) {\n        case LY_TYPE_LEAFREF:\n            if ((ignore_fail == 1) || ((leaf->schema->flags & LYS_LEAFREF_DEP) && (ignore_fail == 2))) {\n                req_inst = -1;\n            } else {\n                req_inst = t->info.lref.req;\n            }\n\n            if (!resolve_leafref(leaf, t->info.lref.path, req_inst, &ret)) {\n                if (store) {\n                    if (ret && !(leaf->schema->flags & LYS_LEAFREF_DEP)) {\n                        /* valid resolved */\n                        leaf->value.leafref = ret;\n                        leaf->value_type = LY_TYPE_LEAFREF;\n                    } else {\n                        /* valid unresolved */\n                        ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n                        if (!lyp_parse_value(t, &leaf->value_str, NULL, leaf, NULL, NULL, 1, 0, 0)) {\n                            return -1;\n                        }\n                        ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n                    }\n                }\n\n                success = 1;\n            }\n            break;\n        case LY_TYPE_INST:\n            ext_dep = check_instid_ext_dep(leaf->schema, (json_val ? json_val : leaf->value_str));\n            if ((ignore_fail == 1) || (ext_dep && (ignore_fail == 2))) {\n                req_inst = -1;\n            } else {\n                req_inst = t->info.inst.req;\n            }\n\n            if (!resolve_instid((struct lyd_node *)leaf, (json_val ? json_val : leaf->value_str), req_inst, &ret)) {\n                if (store) {\n                    if (ret && !ext_dep) {\n                        /* valid resolved */\n                        leaf->value.instance = ret;\n                        leaf->value_type = LY_TYPE_INST;\n\n                        if (json_val) {\n                            lydict_remove(leaf->schema->module->ctx, leaf->value_str);\n                            leaf->value_str = json_val;\n                            json_val = NULL;\n                        }\n                    } else {\n                        /* valid unresolved */\n                        if (json_val) {\n                            /* put the JSON val back */\n                            leaf->value.string = json_val;\n                            json_val = NULL;\n                        } else {\n                            leaf->value.instance = NULL;\n                        }\n                        leaf->value_type = LY_TYPE_INST;\n                        leaf->value_flags |= LY_VALUE_UNRES;\n                    }\n                }\n\n                success = 1;\n            }\n            break;\n        default:\n            if (lyp_parse_value(t, &leaf->value_str, NULL, leaf, NULL, NULL, store, 0, 0)) {\n                success = 1;\n            }\n            break;\n        }\n\n        if (success) {\n            break;\n        }\n\n        /* erase possible present and invalid value data */\n        if (store) {\n            lyd_free_value(leaf->value, leaf->value_type, leaf->value_flags, t, NULL, NULL, NULL);\n            memset(&leaf->value, 0, sizeof leaf->value);\n        }\n    }\n\n    /* turn logging back on */\n    ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n\n    if (json_val) {\n        if (!success) {\n            /* put the value back for now */\n            assert(leaf->value_type == LY_TYPE_UNION);\n            leaf->value.string = json_val;\n        } else {\n            /* value was ultimately useless, but we could not have known */\n            lydict_remove(leaf->schema->module->ctx, json_val);\n        }\n    }\n\n    if (success) {\n        if (resolved_type) {\n            *resolved_type = t;\n        }\n    } else if (!ignore_fail || !type->info.uni.has_ptr_type) {\n        /* not found and it is required */\n        LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, leaf, leaf->value_str ? leaf->value_str : \"\", leaf->schema->name);\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n\n}\n\n/**\n * @brief Resolve a single unres data item. Logs directly.\n *\n * @param[in] node Data node to resolve.\n * @param[in] type Type of the unresolved item.\n * @param[in] ignore_fail 0 - no, 1 - yes, 2 - yes, but only for external dependencies.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nint\nresolve_unres_data_item(struct lyd_node *node, enum UNRES_ITEM type, int ignore_fail, struct lys_when **failed_when)\n{\n    int rc, req_inst, ext_dep;\n    struct lyd_node_leaf_list *leaf;\n    struct lyd_node *ret;\n    struct lys_node_leaf *sleaf;\n\n    leaf = (struct lyd_node_leaf_list *)node;\n    sleaf = (struct lys_node_leaf *)leaf->schema;\n\n    switch (type) {\n    case UNRES_LEAFREF:\n        assert(sleaf->type.base == LY_TYPE_LEAFREF);\n        assert(leaf->validity & LYD_VAL_LEAFREF);\n        if ((ignore_fail == 1) || ((leaf->schema->flags & LYS_LEAFREF_DEP) && (ignore_fail == 2))) {\n            req_inst = -1;\n        } else {\n            req_inst = sleaf->type.info.lref.req;\n        }\n        rc = resolve_leafref(leaf, sleaf->type.info.lref.path, req_inst, &ret);\n        if (!rc) {\n            if (ret && !(leaf->schema->flags & LYS_LEAFREF_DEP)) {\n                /* valid resolved */\n                if (leaf->value_type == LY_TYPE_BITS) {\n                    free(leaf->value.bit);\n                }\n                leaf->value.leafref = ret;\n                leaf->value_type = LY_TYPE_LEAFREF;\n                leaf->value_flags &= ~LY_VALUE_UNRES;\n            } else {\n                /* valid unresolved */\n                if (!(leaf->value_flags & LY_VALUE_UNRES)) {\n                    if (!lyp_parse_value(&sleaf->type, &leaf->value_str, NULL, leaf, NULL, NULL, 1, 0, 0)) {\n                        return -1;\n                    }\n                }\n            }\n            leaf->validity &= ~LYD_VAL_LEAFREF;\n        } else {\n            return rc;\n        }\n        break;\n\n    case UNRES_INSTID:\n        assert(sleaf->type.base == LY_TYPE_INST);\n        ext_dep = check_instid_ext_dep(leaf->schema, leaf->value_str);\n        if (ext_dep == -1) {\n            return -1;\n        }\n\n        if ((ignore_fail == 1) || (ext_dep && (ignore_fail == 2))) {\n            req_inst = -1;\n        } else {\n            req_inst = sleaf->type.info.inst.req;\n        }\n        rc = resolve_instid(node, leaf->value_str, req_inst, &ret);\n        if (!rc) {\n            if (ret && !ext_dep) {\n                /* valid resolved */\n                leaf->value.instance = ret;\n                leaf->value_type = LY_TYPE_INST;\n                leaf->value_flags &= ~LY_VALUE_UNRES;\n            } else {\n                /* valid unresolved */\n                leaf->value.instance = NULL;\n                leaf->value_type = LY_TYPE_INST;\n                leaf->value_flags |= LY_VALUE_UNRES;\n            }\n        } else {\n            return rc;\n        }\n        break;\n\n    case UNRES_UNION:\n        assert(sleaf->type.base == LY_TYPE_UNION);\n        return resolve_union(leaf, &sleaf->type, 1, ignore_fail, NULL);\n\n    case UNRES_WHEN:\n        if ((rc = resolve_when(node, ignore_fail, failed_when))) {\n            return rc;\n        }\n        break;\n\n    case UNRES_MUST:\n        if ((rc = resolve_must(node, 0, ignore_fail))) {\n            return rc;\n        }\n        break;\n\n    case UNRES_MUST_INOUT:\n        if ((rc = resolve_must(node, 1, ignore_fail))) {\n            return rc;\n        }\n        break;\n\n    case UNRES_UNIQ_LEAVES:\n        if (lyv_data_unique(node)) {\n            return -1;\n        }\n        break;\n\n    default:\n        LOGINT(NULL);\n        return -1;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief add data unres item\n *\n * @param[in] unres Unres data structure to use.\n * @param[in] node Data node to use.\n *\n * @return 0 on success, -1 on error.\n */\nint\nunres_data_add(struct unres_data *unres, struct lyd_node *node, enum UNRES_ITEM type)\n{\n    assert(unres && node);\n    assert((type == UNRES_LEAFREF) || (type == UNRES_INSTID) || (type == UNRES_WHEN) || (type == UNRES_MUST)\n           || (type == UNRES_MUST_INOUT) || (type == UNRES_UNION) || (type == UNRES_UNIQ_LEAVES));\n\n    unres->count++;\n    unres->node = ly_realloc(unres->node, unres->count * sizeof *unres->node);\n    LY_CHECK_ERR_RETURN(!unres->node, LOGMEM(NULL), -1);\n    unres->node[unres->count - 1] = node;\n    unres->type = ly_realloc(unres->type, unres->count * sizeof *unres->type);\n    LY_CHECK_ERR_RETURN(!unres->type, LOGMEM(NULL), -1);\n    unres->type[unres->count - 1] = type;\n\n    return 0;\n}\n\nstatic void\nresolve_unres_data_autodel_diff(struct unres_data *unres, uint32_t unres_i)\n{\n    struct lyd_node *next, *child, *parent;\n    uint32_t i;\n\n    for (i = 0; i < unres->diff_idx; ++i) {\n        if (unres->diff->type[i] == LYD_DIFF_DELETED) {\n            /* only leaf(-list) default could be removed and there is nothing to be checked in that case */\n            continue;\n        }\n\n        if (unres->diff->second[i] == unres->node[unres_i]) {\n            /* 1) default value was supposed to be created, but is disabled by when\n             * -> remove it from diff altogether\n             */\n            unres_data_diff_rem(unres, i);\n            /* if diff type is CREATED, the value was just a pointer, it can be freed normally (unlike in 4) */\n            return;\n        } else {\n            parent = unres->diff->second[i]->parent;\n            while (parent && (parent != unres->node[unres_i])) {\n                parent = parent->parent;\n            }\n            if (parent) {\n                /* 2) default value was supposed to be created but is disabled by when in some parent\n                 * -> remove this default subtree and add the rest into diff as deleted instead in 4)\n                 */\n                unres_data_diff_rem(unres, i);\n                break;\n            }\n\n            LY_TREE_DFS_BEGIN(unres->diff->second[i]->parent, next, child) {\n                if (child == unres->node[unres_i]) {\n                    /* 3) some default child of a default value was supposed to be created but has false when\n                     * -> the subtree will be freed later and automatically disconnected from the diff parent node\n                     */\n                    return;\n                }\n\n                LY_TREE_DFS_END(unres->diff->second[i]->parent, next, child);\n            }\n        }\n    }\n\n    /* 4) it does not overlap with created default values in any way\n     * -> just add it into diff as deleted\n     */\n    unres_data_diff_new(unres, unres->node[unres_i], unres->node[unres_i]->parent, 0);\n    lyd_unlink(unres->node[unres_i]);\n\n    /* should not be freed anymore */\n    unres->node[unres_i] = NULL;\n}\n\n/**\n * @brief Resolve every unres data item in the structure. Logs directly.\n *\n * If options include #LYD_OPT_TRUSTED, the data are considered trusted (must conditions are not expected,\n * unresolved leafrefs/instids are accepted, when conditions are normally resolved because at least some implicit\n * non-presence containers may need to be deleted).\n *\n * If options includes #LYD_OPT_WHENAUTODEL, the non-default nodes with false when conditions are auto-deleted.\n *\n * @param[in] ctx Context used.\n * @param[in] unres Unres data structure to use.\n * @param[in,out] root Root node of the data tree, can be changed due to autodeletion.\n * @param[in] options Data options as described above.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nint\nresolve_unres_data(struct ly_ctx *ctx, struct unres_data *unres, struct lyd_node **root, int options)\n{\n    uint32_t i, j, first, resolved, del_items, stmt_count;\n    uint8_t prev_when_status;\n    int rc, progress, ignore_fail;\n    enum int_log_opts prev_ilo;\n    struct ly_err_item *prev_eitem;\n    LY_ERR prev_ly_errno = ly_errno;\n    struct lyd_node *parent;\n    struct lys_when *when;\n\n    assert(root);\n    assert(unres);\n\n    if (!unres->count) {\n        return EXIT_SUCCESS;\n    }\n\n    if (options & (LYD_OPT_NOTIF_FILTER | LYD_OPT_GET | LYD_OPT_GETCONFIG | LYD_OPT_EDIT)) {\n        ignore_fail = 1;\n    } else if (options & LYD_OPT_NOEXTDEPS) {\n        ignore_fail = 2;\n    } else {\n        ignore_fail = 0;\n    }\n\n    LOGVRB(\"Resolving unresolved data nodes and their constraints...\");\n    if (!ignore_fail) {\n        /* remember logging state only if errors are generated and valid */\n        ly_ilo_change(ctx, ILO_STORE, &prev_ilo, &prev_eitem);\n    }\n\n    /*\n     * when-stmt first\n     */\n    first = 1;\n    stmt_count = 0;\n    resolved = 0;\n    del_items = 0;\n    do {\n        if (!ignore_fail) {\n            ly_err_free_next(ctx, prev_eitem);\n        }\n        progress = 0;\n        for (i = 0; i < unres->count; i++) {\n            if (unres->type[i] != UNRES_WHEN) {\n                continue;\n            }\n            if (first) {\n                /* count when-stmt nodes in unres list */\n                stmt_count++;\n            }\n\n            /* resolve when condition only when all parent when conditions are already resolved */\n            for (parent = unres->node[i]->parent;\n                 parent && LYD_WHEN_DONE(parent->when_status);\n                 parent = parent->parent) {\n                if (!parent->parent && (parent->when_status & LYD_WHEN_FALSE)) {\n                    /* the parent node was already unlinked, do not resolve this node,\n                     * it will be removed anyway, so just mark it as resolved\n                     */\n                    unres->node[i]->when_status |= LYD_WHEN_FALSE;\n                    unres->type[i] = UNRES_RESOLVED;\n                    resolved++;\n                    break;\n                }\n            }\n            if (parent) {\n                continue;\n            }\n\n            prev_when_status = unres->node[i]->when_status;\n            rc = resolve_unres_data_item(unres->node[i], unres->type[i], ignore_fail, &when);\n            if (!rc) {\n                /* finish with error/delete the node only if when was changed from true to false, an external\n                 * dependency was not required, or it was not provided (the flag would not be passed down otherwise,\n                 * checked in upper functions) */\n                if ((unres->node[i]->when_status & LYD_WHEN_FALSE)\n                        && (!(when->flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP)) || !(options & LYD_OPT_NOEXTDEPS))) {\n                    if ((!(prev_when_status & LYD_WHEN_TRUE) || !(options & LYD_OPT_WHENAUTODEL)) && !unres->node[i]->dflt) {\n                        /* false when condition */\n                        goto error;\n                    } /* follows else */\n\n                    /* auto-delete */\n                    LOGVRB(\"Auto-deleting node \\\"%s\\\" due to when condition (%s)\", ly_errpath(ctx), when->cond);\n\n                    /* only unlink now, the subtree can contain another nodes stored in the unres list */\n                    /* if it has parent non-presence containers that would be empty, we should actually\n                     * remove the container\n                     */\n                    for (parent = unres->node[i];\n                            parent->parent && parent->parent->schema->nodetype == LYS_CONTAINER;\n                            parent = parent->parent) {\n                        if (((struct lys_node_container *)parent->parent->schema)->presence) {\n                            /* presence container */\n                            break;\n                        }\n                        if (parent->next || parent->prev != parent) {\n                            /* non empty (the child we are in and we are going to remove is not the only child) */\n                            break;\n                        }\n                    }\n                    unres->node[i] = parent;\n\n                    if (*root && *root == unres->node[i]) {\n                        *root = (*root)->next;\n                    }\n\n                    lyd_unlink(unres->node[i]);\n                    unres->type[i] = UNRES_DELETE;\n                    del_items++;\n\n                    /* update the rest of unres items */\n                    for (j = 0; j < unres->count; j++) {\n                        if (unres->type[j] == UNRES_RESOLVED || unres->type[j] == UNRES_DELETE) {\n                            continue;\n                        }\n\n                        /* test if the node is in subtree to be deleted */\n                        for (parent = unres->node[j]; parent; parent = parent->parent) {\n                            if (parent == unres->node[i]) {\n                                /* yes, it is */\n                                unres->type[j] = UNRES_RESOLVED;\n                                resolved++;\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    unres->type[i] = UNRES_RESOLVED;\n                }\n                if (!ignore_fail) {\n                    ly_err_free_next(ctx, prev_eitem);\n                }\n                resolved++;\n                progress = 1;\n            } else if (rc == -1) {\n                goto error;\n            } /* else forward reference */\n        }\n        first = 0;\n    } while (progress && resolved < stmt_count);\n\n    /* do we have some unresolved when-stmt? */\n    if (stmt_count > resolved) {\n        goto error;\n    }\n\n    for (i = 0; del_items && i < unres->count; i++) {\n        /* we had some when-stmt resulted to false, so now we have to sanitize the unres list */\n        if (unres->type[i] != UNRES_DELETE) {\n            continue;\n        }\n        if (!unres->node[i]) {\n            unres->type[i] = UNRES_RESOLVED;\n            del_items--;\n            continue;\n        }\n\n        if (unres->store_diff) {\n            resolve_unres_data_autodel_diff(unres, i);\n        }\n\n        /* really remove the complete subtree */\n        lyd_free(unres->node[i]);\n        unres->type[i] = UNRES_RESOLVED;\n        del_items--;\n    }\n\n    /*\n     * now leafrefs\n     */\n    if (options & LYD_OPT_TRUSTED) {\n        /* we want to attempt to resolve leafrefs */\n        assert(!ignore_fail);\n        ignore_fail = 1;\n\n        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 0);\n        ly_errno = prev_ly_errno;\n    }\n    first = 1;\n    stmt_count = 0;\n    resolved = 0;\n    do {\n        progress = 0;\n        for (i = 0; i < unres->count; i++) {\n            if (unres->type[i] != UNRES_LEAFREF) {\n                continue;\n            }\n            if (first) {\n                /* count leafref nodes in unres list */\n                stmt_count++;\n            }\n\n            rc = resolve_unres_data_item(unres->node[i], unres->type[i], ignore_fail, NULL);\n            if (!rc) {\n                unres->type[i] = UNRES_RESOLVED;\n                if (!ignore_fail) {\n                    ly_err_free_next(ctx, prev_eitem);\n                }\n                resolved++;\n                progress = 1;\n            } else if (rc == -1) {\n                goto error;\n            } /* else forward reference */\n        }\n        first = 0;\n    } while (progress && resolved < stmt_count);\n\n    /* do we have some unresolved leafrefs? */\n    if (stmt_count > resolved) {\n        goto error;\n    }\n\n    if (!ignore_fail) {\n        /* log normally now, throw away irrelevant errors */\n        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 0);\n        ly_errno = prev_ly_errno;\n    }\n\n    /*\n     * rest\n     */\n    for (i = 0; i < unres->count; ++i) {\n        if (unres->type[i] == UNRES_RESOLVED) {\n            continue;\n        }\n        assert(!(options & LYD_OPT_TRUSTED) || ((unres->type[i] != UNRES_MUST) && (unres->type[i] != UNRES_MUST_INOUT)));\n\n        rc = resolve_unres_data_item(unres->node[i], unres->type[i], ignore_fail, NULL);\n        if (rc) {\n            /* since when was already resolved, a forward reference is an error */\n            return -1;\n        }\n\n        unres->type[i] = UNRES_RESOLVED;\n    }\n\n    LOGVRB(\"All data nodes and constraints resolved.\");\n    unres->count = 0;\n    return EXIT_SUCCESS;\n\nerror:\n    if (!ignore_fail) {\n        /* print all the new errors */\n        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 1);\n        /* do not restore ly_errno, it was udpated properly */\n    }\n    return -1;\n}\n", "/**\n * @file tree_data.c\n * @author Radek Krejci <rkrejci@cesnet.cz>\n * @brief Manipulation with libyang data structures\n *\n * Copyright (c) 2015 - 2018 CESNET, z.s.p.o.\n *\n * This source code is licensed under BSD 3-Clause License (the \"License\").\n * You may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/BSD-3-Clause\n */\n\n#define _GNU_SOURCE\n\n#include <assert.h>\n#include <ctype.h>\n#include <limits.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"libyang.h\"\n#include \"common.h\"\n#include \"context.h\"\n#include \"tree_data.h\"\n#include \"parser.h\"\n#include \"resolve.h\"\n#include \"xml_internal.h\"\n#include \"tree_internal.h\"\n#include \"validation.h\"\n#include \"xpath.h\"\n\nstatic struct lys_node *lyd_get_schema_inctx(const struct lyd_node *node, struct ly_ctx *ctx);\n\nstatic int\nlyd_anydata_equal(struct lyd_node *first, struct lyd_node *second)\n{\n    char *str1 = NULL, *str2 = NULL;\n    struct lyd_node_anydata *anydata;\n\n    assert(first->schema->nodetype & LYS_ANYDATA);\n    assert(first->schema->nodetype == second->schema->nodetype);\n\n    anydata = (struct lyd_node_anydata *)first;\n    if (!anydata->value.str) {\n        lyxml_print_mem(&str1, anydata->value.xml, LYXML_PRINT_SIBLINGS);\n        anydata->value.str = lydict_insert_zc(anydata->schema->module->ctx, str1);\n    }\n    str1 = (char *)anydata->value.str;\n\n    anydata = (struct lyd_node_anydata *)second;\n    if (!anydata->value.str) {\n        lyxml_print_mem(&str2, anydata->value.xml, LYXML_PRINT_SIBLINGS);\n        anydata->value.str = lydict_insert_zc(anydata->schema->module->ctx, str2);\n    }\n    str2 = (char *)anydata->value.str;\n\n    if (first->schema->module->ctx != second->schema->module->ctx) {\n        return ly_strequal(str1, str2, 0);\n    } else {\n        return ly_strequal(str1, str2, 1);\n    }\n}\n\n/* used in tests */\nint\nlyd_list_has_keys(struct lyd_node *list)\n{\n    struct lyd_node *iter;\n    struct lys_node_list *slist;\n    int i;\n\n    assert(list->schema->nodetype == LYS_LIST);\n\n    /* even though hash is 0, it may be a valid hash, that is what we are going to check */\n\n    slist = (struct lys_node_list *)list->schema;\n    if (!slist->keys_size) {\n        /* always has keys */\n        return 1;\n    }\n\n    i = 0;\n    iter = list->child;\n    while (iter && (i < slist->keys_size)) {\n        if (iter->schema != (struct lys_node *)slist->keys[i]) {\n            /* missing key */\n            return 0;\n        }\n\n        ++i;\n        iter = iter->next;\n    }\n    if (i < slist->keys_size) {\n        /* missing key */\n        return 0;\n    }\n\n    /* all keys found */\n    return 1;\n}\n\nstatic int\nlyd_leaf_val_equal(struct lyd_node *node1, struct lyd_node *node2, int diff_ctx)\n{\n    assert(node1->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST));\n    assert(node1->schema->nodetype == node2->schema->nodetype);\n\n    if (diff_ctx) {\n        return ly_strequal(((struct lyd_node_leaf_list *)node1)->value_str, ((struct lyd_node_leaf_list *)node2)->value_str, 0);\n    } else {\n        return ly_strequal(((struct lyd_node_leaf_list *)node1)->value_str, ((struct lyd_node_leaf_list *)node2)->value_str, 1);\n    }\n}\n\n/*\n * withdefaults (only for leaf-list):\n * 0 - treat default nodes are normal nodes\n * 1 - only change is that if 2 nodes have the same value, but one is default, the other not, they are considered non-equal\n */\nint\nlyd_list_equal(struct lyd_node *node1, struct lyd_node *node2, int with_defaults)\n{\n    int i, diff_ctx;\n    struct lyd_node *elem1, *next1, *elem2, *next2;\n    struct lys_node *elem1_sch;\n    struct ly_ctx *ctx = node2->schema->module->ctx;\n\n    diff_ctx = (node1->schema->module->ctx != node2->schema->module->ctx);\n\n    switch (node2->schema->nodetype) {\n    case LYS_LEAFLIST:\n        if (lyd_leaf_val_equal(node1, node2, diff_ctx) && (!with_defaults || (node1->dflt == node2->dflt))) {\n            return 1;\n        }\n        break;\n    case LYS_LIST:\n        if (((struct lys_node_list *)node1->schema)->keys_size) {\n            /* lists with keys, their equivalence isb ased on their keys */\n            elem1 = node1->child;\n            elem2 = node2->child;\n            elem1_sch = NULL;\n            /* the exact data order is guaranteed */\n            for (i = 0; i < ((struct lys_node_list *)node1->schema)->keys_size; ++i) {\n                if (diff_ctx && elem1) {\n                    /* we have different contexts */\n                    if (!elem1_sch) {\n                        elem1_sch = lyd_get_schema_inctx(elem1, ctx);\n                        if (!elem1_sch) {\n                            LOGERR(ctx, LY_EINVAL, \"Target context does not contain a required schema node (%s:%s).\",\n                                   lyd_node_module(elem1)->name, elem1->schema->name);\n                            return -1;\n                        }\n                    } else {\n                        /* just move to the next schema node */\n                        elem1_sch = elem1_sch->next;\n                    }\n                }\n                if (!elem1 || !elem2 || ((elem1_sch ? elem1_sch : elem1->schema) != elem2->schema)\n                        || !lyd_leaf_val_equal(elem1, elem2, diff_ctx)) {\n                    break;\n                }\n                elem1 = elem1->next;\n                elem2 = elem2->next;\n            }\n            if (i == ((struct lys_node_list *)node1->schema)->keys_size) {\n                return 1;\n            }\n        } else {\n            /* lists wihtout keys, their equivalence is based on values of all the children (both dierct and indirect) */\n            if (!node1->child && !node2->child) {\n                /* no children, nothing to compare */\n                return 1;\n            }\n\n            /* status lists without keys, we need to compare all the children :( */\n\n            /* LY_TREE_DFS_BEGIN for 2 data trees */\n            elem1 = next1 = node1->child;\n            elem2 = next2 = node2->child;\n            while (elem1 && elem2) {\n                /* node comparison */\n#ifdef LY_ENABLED_CACHE\n                if (elem1->hash != elem2->hash) {\n                    break;\n                }\n#endif\n                if (diff_ctx) {\n                    elem1_sch = lyd_get_schema_inctx(elem1, ctx);\n                    if (!elem1_sch) {\n                        LOGERR(ctx, LY_EINVAL, \"Target context does not contain a required schema node (%s:%s).\",\n                               lyd_node_module(elem1)->name, elem1->schema->name);\n                        return -1;\n                    }\n                } else {\n                    elem1_sch = elem1->schema;\n                }\n                if (elem1_sch != elem2->schema) {\n                    break;\n                }\n                if (elem2->schema->nodetype == LYS_LIST) {\n                    if (!lyd_list_has_keys(elem1) && !lyd_list_has_keys(elem2)) {\n                        /* we encountered lists without keys (but have some defined in schema), ignore them for comparison */\n                        next1 = NULL;\n                        next2 = NULL;\n                        goto next_sibling;\n                    }\n                    /* we will compare all the children of this list instance, not just keys */\n                } else if (elem2->schema->nodetype & (LYS_LEAFLIST | LYS_LEAF)) {\n                    if (!lyd_leaf_val_equal(elem1, elem2, diff_ctx) && (!with_defaults || (elem1->dflt == elem2->dflt))) {\n                        break;\n                    }\n                } else if (elem2->schema->nodetype & LYS_ANYDATA) {\n                    if (!lyd_anydata_equal(elem1, elem2)) {\n                        break;\n                    }\n                }\n\n                /* LY_TREE_DFS_END for 2 data trees */\n                if (elem2->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                    next1 = NULL;\n                    next2 = NULL;\n                } else {\n                    next1 = elem1->child;\n                    next2 = elem2->child;\n                }\n\nnext_sibling:\n                if (!next1) {\n                    next1 = elem1->next;\n                }\n                if (!next2) {\n                    next2 = elem2->next;\n                }\n\n                while (!next1) {\n                    elem1 = elem1->parent;\n                    if (elem1 == node1) {\n                        break;\n                    }\n                    next1 = elem1->next;\n                }\n                while (!next2) {\n                    elem2 = elem2->parent;\n                    if (elem2 == node2) {\n                        break;\n                    }\n                    next2 = elem2->next;\n                }\n\n                elem1 = next1;\n                elem2 = next2;\n            }\n\n            if (!elem1 && !elem2) {\n                /* all children were successfully compared */\n                return 1;\n            }\n        }\n        break;\n    default:\n        LOGINT(ctx);\n        return -1;\n    }\n\n    return 0;\n}\n\n#ifdef LY_ENABLED_CACHE\n\nstatic int\nlyd_hash_table_val_equal(void *val1_p, void *val2_p, int mod, void *UNUSED(cb_data))\n{\n    struct lyd_node *val1, *val2;\n\n    val1 = *((struct lyd_node **)val1_p);\n    val2 = *((struct lyd_node **)val2_p);\n\n    if (mod) {\n        if (val1 == val2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    if (val1->schema != val2->schema) {\n        return 0;\n    }\n\n    switch (val1->schema->nodetype) {\n    case LYS_CONTAINER:\n    case LYS_LEAF:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        return 1;\n    case LYS_LEAFLIST:\n    case LYS_LIST:\n        return lyd_list_equal(val1, val2, 0);\n    default:\n        break;\n    }\n\n    LOGINT(val1->schema->module->ctx);\n    return 0;\n}\n\nstatic void\nlyd_hash_keyless_list_dfs(struct lyd_node *child, uint32_t *hash)\n{\n    LY_TREE_FOR(child, child) {\n        switch (child->schema->nodetype) {\n        case LYS_CONTAINER:\n            lyd_hash_keyless_list_dfs(child->child, hash);\n            break;\n        case LYS_LIST:\n            /* ignore lists with missing keys */\n            if (lyd_list_has_keys(child)) {\n                lyd_hash_keyless_list_dfs(child->child, hash);\n            }\n            break;\n        case LYS_LEAFLIST:\n        case LYS_ANYXML:\n        case LYS_ANYDATA:\n        case LYS_LEAF:\n            *hash = dict_hash_multi(*hash, (char *)&child->hash, sizeof child->hash);\n            break;\n        default:\n            assert(0);\n        }\n    }\n}\n\nint\nlyd_hash(struct lyd_node *node)\n{\n    struct lyd_node *iter;\n    int i;\n\n    assert(!node->hash || ((node->schema->nodetype == LYS_LIST) && !((struct lys_node_list *)node->schema)->keys_size));\n\n    if ((node->schema->nodetype != LYS_LIST) || lyd_list_has_keys(node)) {\n        node->hash = dict_hash_multi(0, lyd_node_module(node)->name, strlen(lyd_node_module(node)->name));\n        node->hash = dict_hash_multi(node->hash, node->schema->name, strlen(node->schema->name));\n        if (node->schema->nodetype == LYS_LEAFLIST) {\n            node->hash = dict_hash_multi(node->hash, ((struct lyd_node_leaf_list *)node)->value_str,\n                                        strlen(((struct lyd_node_leaf_list *)node)->value_str));\n        } else if (node->schema->nodetype == LYS_LIST) {\n            if (((struct lys_node_list *)node->schema)->keys_size) {\n                for (i = 0, iter = node->child; i < ((struct lys_node_list *)node->schema)->keys_size; ++i, iter = iter->next) {\n                    assert(iter);\n                    node->hash = dict_hash_multi(node->hash, ((struct lyd_node_leaf_list *)iter)->value_str,\n                                                 strlen(((struct lyd_node_leaf_list *)iter)->value_str));\n                }\n            } else {\n                /* no-keys list */\n                lyd_hash_keyless_list_dfs(node->child, &node->hash);\n            }\n        }\n        node->hash = dict_hash_multi(node->hash, NULL, 0);\n        return 0;\n    }\n\n    return 1;\n}\n\nstatic void\nlyd_keyless_list_hash_change(struct lyd_node *parent)\n{\n    int r;\n\n    while (parent && (parent->schema->flags & LYS_CONFIG_R)) {\n        if (parent->schema->nodetype == LYS_LIST) {\n            if (!((struct lys_node_list *)parent->schema)->keys_size) {\n                if (parent->parent && parent->parent->ht) {\n                    /* remove the list from the parent */\n                    r = lyht_remove(parent->parent->ht, &parent, parent->hash);\n                    assert(!r);\n                    (void)r;\n                }\n                /* recalculate the hash */\n                lyd_hash(parent);\n                if (parent->parent && parent->parent->ht) {\n                    /* re-add the list again */\n                    r = lyht_insert(parent->parent->ht, &parent, parent->hash, NULL);\n                    assert(!r);\n                    (void)r;\n                }\n            } else if (!lyd_list_has_keys(parent)) {\n                /* a parent is a list without keys so it cannot be a part of any parent hash */\n                break;\n            }\n        }\n\n        parent = parent->parent;\n    }\n}\n\nstatic void\n_lyd_insert_hash(struct lyd_node *node, int keyless_list_check)\n{\n    struct lyd_node *iter;\n    int i;\n\n    if (node->parent) {\n        if ((node->schema->nodetype != LYS_LIST) || lyd_list_has_keys(node)) {\n            if ((node->schema->nodetype == LYS_LEAF) && lys_is_key((struct lys_node_leaf *)node->schema, NULL)) {\n                /* we are adding a key which means that it may be the last missing key for our parent's hash */\n                if (!lyd_hash(node->parent)) {\n                    /* yep, we successfully hashed node->parent so it is technically now added to its parent (hash-wise) */\n                    _lyd_insert_hash(node->parent, 0);\n                }\n            }\n\n            /* create parent hash table if required, otherwise just add the new child */\n            if (!node->parent->ht) {\n                for (i = 0, iter = node->parent->child; iter; ++i, iter = iter->next) {\n                    if ((iter->schema->nodetype == LYS_LIST) && !lyd_list_has_keys(iter)) {\n                        /* it will either never have keys and will never be hashed or has not all keys created yet */\n                        --i;\n                    }\n                }\n                assert(i <= LY_CACHE_HT_MIN_CHILDREN);\n                if (i == LY_CACHE_HT_MIN_CHILDREN) {\n                    /* create hash table, insert all the children */\n                    node->parent->ht = lyht_new(1, sizeof(struct lyd_node *), lyd_hash_table_val_equal, NULL, 1);\n                    LY_TREE_FOR(node->parent->child, iter) {\n                        if ((iter->schema->nodetype == LYS_LIST) && !lyd_list_has_keys(iter)) {\n                            /* skip lists without keys */\n                            continue;\n                        }\n\n                        if (lyht_insert(node->parent->ht, &iter, iter->hash, NULL)) {\n                            assert(0);\n                        }\n                    }\n                }\n            } else {\n                if (lyht_insert(node->parent->ht, &node, node->hash, NULL)) {\n                    assert(0);\n                }\n            }\n\n            /* if node was in a state data subtree, wasn't it a part of a key-less list hash? */\n            if (keyless_list_check) {\n                lyd_keyless_list_hash_change(node->parent);\n            }\n        }\n    }\n}\n\n/* we have inserted node into a parent */\nvoid\nlyd_insert_hash(struct lyd_node *node)\n{\n    _lyd_insert_hash(node, 1);\n}\n\nstatic void\n_lyd_unlink_hash(struct lyd_node *node, struct lyd_node *orig_parent, int keyless_list_check)\n{\n#ifndef NDEBUG\n    struct lyd_node *iter;\n\n    /* it must already be unlinked otherwise keyless lists would get wrong hash */\n    if (keyless_list_check && orig_parent) {\n        LY_TREE_FOR(orig_parent->child, iter) {\n            assert(iter != node);\n        }\n    }\n#endif\n\n    if (orig_parent) {\n        if ((node->schema->nodetype != LYS_LIST) || lyd_list_has_keys(node)) {\n            if (orig_parent->ht) {\n                if (lyht_remove(orig_parent->ht, &node, node->hash)) {\n                    assert(0);\n                }\n\n                /* if no longer enough children, free the whole hash table */\n                if (orig_parent->ht->used < LY_CACHE_HT_MIN_CHILDREN) {\n                    lyht_free(orig_parent->ht);\n                    orig_parent->ht = NULL;\n                }\n            }\n\n            /* if the parent is missing a key now, remove hash, also from parent */\n            if (lys_is_key((struct lys_node_leaf *)node->schema, NULL) && orig_parent->hash) {\n                assert((orig_parent->schema->nodetype == LYS_LIST) && !lyd_list_has_keys(orig_parent));\n\n                _lyd_unlink_hash(orig_parent, orig_parent->parent, 0);\n                orig_parent->hash = 0;\n            }\n\n            /* if node was in a state data subtree, shouldn't it be a part of a key-less list hash? */\n            if (keyless_list_check) {\n                lyd_keyless_list_hash_change(orig_parent);\n            }\n        }\n    }\n}\n\n/* we are unlinking a child from a parent */\nvoid\nlyd_unlink_hash(struct lyd_node *node, struct lyd_node *orig_parent)\n{\n    _lyd_unlink_hash(node, orig_parent, 1);\n}\n\n#endif\n\n/**\n * @brief get the list of \\p data's siblings of the given schema\n */\nstatic int\nlyd_get_node_siblings(const struct lyd_node *data, const struct lys_node *schema, struct ly_set *set)\n{\n    const struct lyd_node *iter;\n\n    assert(set && !set->number);\n    assert(schema);\n    assert(schema->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_ANYDATA | LYS_NOTIF | LYS_RPC |\n                               LYS_ACTION));\n\n    if (!data) {\n        return 0;\n    }\n\n    LY_TREE_FOR(data, iter) {\n        if (iter->schema == schema) {\n            ly_set_add(set, (void*)iter, LY_SET_OPT_USEASLIST);\n        }\n    }\n\n    return set->number;\n}\n\n/**\n * Check whether there are any \"when\" statements on a \\p schema node and evaluate them.\n *\n * @return -1 on error, 0 on no when or evaluated to true, 1 on when evaluated to false\n */\nstatic int\nlyd_is_when_false(struct lyd_node *root, struct lyd_node *last_parent, struct lys_node *schema, int options)\n{\n    enum int_log_opts prev_ilo;\n    struct lyd_node *current, *dummy;\n\n    if ((!(options & LYD_OPT_TYPEMASK) || (options & (LYD_OPT_CONFIG | LYD_OPT_RPC | LYD_OPT_RPCREPLY | LYD_OPT_NOTIF | LYD_OPT_DATA_TEMPLATE)))\n            && resolve_applies_when(schema, 1, last_parent ? last_parent->schema : NULL)) {\n        /* evaluate when statements on a dummy data node */\n        if (schema->nodetype == LYS_CHOICE) {\n            schema = (struct lys_node *)lys_getnext(NULL, schema, NULL, LYS_GETNEXT_NOSTATECHECK);\n        }\n        dummy = lyd_new_dummy(root, last_parent, schema, NULL, 0);\n        if (!dummy) {\n            return -1;\n        }\n        if (!dummy->parent && root) {\n            /* connect dummy nodes into the data tree, insert it before the root\n             * to optimize later unlinking (lyd_free()) */\n            lyd_insert_before(root, dummy);\n        }\n        for (current = dummy; current; current = current->child) {\n            ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n            resolve_when(current, 0, NULL);\n            ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n\n            if (current->when_status & LYD_WHEN_FALSE) {\n                /* when evaluates to false */\n                lyd_free(dummy);\n                return 1;\n            }\n\n            if (current->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                /* termination node without a child */\n                break;\n            }\n        }\n        lyd_free(dummy);\n    }\n\n    return 0;\n}\n\n/**\n * @param[in] root Root node to be able search the data tree in case of no instance\n * @return\n *  0 - all restrictions met\n *  1 - restrictions not met\n *  2 - schema node not enabled\n */\nstatic int\nlyd_check_mandatory_data(struct lyd_node *root, struct lyd_node *last_parent,\n                         struct ly_set *instances, struct lys_node *schema, int options)\n{\n    struct ly_ctx *ctx = schema->module->ctx;\n    uint32_t limit;\n    uint16_t status;\n\n    if (!instances->number) {\n        /* no instance in the data tree - check if the instantiating is enabled\n         * (check: if-feature, when, status data in non-status data tree)\n         */\n        status = (schema->flags & LYS_STATUS_MASK);\n        if (lys_is_disabled(schema, 2) || (status && status != LYS_STATUS_CURR)) {\n            /* disabled by if-feature */\n            return EXIT_SUCCESS;\n        } else if ((options & LYD_OPT_TRUSTED) || ((options & LYD_OPT_TYPEMASK) && (schema->flags & LYS_CONFIG_R))) {\n            /* status schema node in non-status data tree */\n            return EXIT_SUCCESS;\n        } else if (lyd_is_when_false(root, last_parent, schema, options)) {\n            return EXIT_SUCCESS;\n        }\n        /* the schema instance is not disabled by anything, continue with checking */\n    }\n\n    /* checking various mandatory conditions */\n    switch (schema->nodetype) {\n    case LYS_LEAF:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        /* mandatory */\n        if ((schema->flags & LYS_MAND_TRUE) && !instances->number) {\n            LOGVAL(ctx, LYE_MISSELEM, LY_VLOG_LYD, last_parent, schema->name,\n                   last_parent ? last_parent->schema->name : lys_node_module(schema)->name);\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_LIST:\n        /* min-elements */\n        limit = ((struct lys_node_list *)schema)->min;\n        if (limit && limit > instances->number) {\n            LOGVAL(ctx, LYE_NOMIN, LY_VLOG_LYD, last_parent, schema->name);\n            return EXIT_FAILURE;\n        }\n        /* max elements */\n        limit = ((struct lys_node_list *)schema)->max;\n        if (limit && limit < instances->number) {\n            LOGVAL(ctx, LYE_NOMAX, LY_VLOG_LYD, instances->set.d[limit], schema->name);\n            return EXIT_FAILURE;\n        }\n\n        break;\n\n    case LYS_LEAFLIST:\n        /* min-elements */\n        limit = ((struct lys_node_leaflist *)schema)->min;\n        if (limit && limit > instances->number) {\n            LOGVAL(ctx, LYE_NOMIN, LY_VLOG_LYD, last_parent, schema->name);\n            return EXIT_FAILURE;\n        }\n        /* max elements */\n        limit = ((struct lys_node_leaflist *)schema)->max;\n        if (limit && limit < instances->number) {\n            LOGVAL(ctx, LYE_NOMAX, LY_VLOG_LYD, instances->set.d[limit], schema->name);\n            return EXIT_FAILURE;\n        }\n        break;\n    default:\n        /* we cannot get here */\n        assert(0);\n        break;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Check the specific subtree, specified by \\p schema node, for presence of mandatory nodes. Function goes\n * recursively into the subtree.\n *\n * What is being checked:\n * - mandatory statement in leaf, choice, anyxml and anydata\n * - min-elements and max-elements in list and leaf-list\n *\n * @param[in] tree Data tree, needed for case that subtree is NULL (in case of not existing data nodes to explore)\n * @param[in] subtree Depend ons \\p toplevel flag:\n *                 toplevel = 1, then subtree is ignored, instead the tree is taken to search in top level data elements (if any)\n *                 toplevel = 0, subtree is the parent data node of the possible instances of the schema node being checked\n * @param[in] last_parent The last present parent data node (so it does not need to be a direct parent) of the possible\n *                 instances of the schema node being checked\n * @param[in] schema The schema node being checked for mandatory nodes\n * @param[in] toplevel, see the \\p root parameter description\n * @param[in] options @ref parseroptions to specify the type of the data tree.\n * @return EXIT_SUCCESS or EXIT_FAILURE if there are missing mandatory nodes\n */\nstatic int\nlyd_check_mandatory_subtree(struct lyd_node *tree, struct lyd_node *subtree, struct lyd_node *last_parent,\n                            struct lys_node *schema, int toplevel, int options)\n{\n    struct lys_node *siter, *siter_prev;\n    struct lyd_node *iter;\n    struct ly_set *present = NULL;\n    unsigned int u;\n    int ret = EXIT_FAILURE;\n\n    assert(schema);\n\n    if (schema->nodetype & (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_ANYDATA | LYS_CONTAINER)) {\n        /* data node */\n        present = ly_set_new();\n        if (!present) {\n            goto error;\n        }\n        if ((toplevel && tree) || (!toplevel && subtree)) {\n            if (toplevel) {\n                lyd_get_node_siblings(tree, schema, present);\n            } else {\n                lyd_get_node_siblings(subtree->child, schema, present);\n            }\n        }\n    }\n\n    switch (schema->nodetype) {\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        /* check the schema item */\n        if (lyd_check_mandatory_data(tree, last_parent, present, schema, options)) {\n            goto error;\n        }\n        break;\n    case LYS_LIST:\n        /* check the schema item */\n        if (lyd_check_mandatory_data(tree, last_parent, present, schema, options)) {\n            goto error;\n        }\n\n        /* go recursively */\n        for (u = 0; u < present->number; u++) {\n            LY_TREE_FOR(schema->child, siter) {\n                if (lyd_check_mandatory_subtree(tree, present->set.d[u], present->set.d[u], siter, 0, options)) {\n                    goto error;\n                }\n            }\n        }\n        break;\n\n    case LYS_CONTAINER:\n        if (present->number || !((struct lys_node_container *)schema)->presence) {\n            /* if we have existing or non-presence container, go recursively */\n            LY_TREE_FOR(schema->child, siter) {\n                if (lyd_check_mandatory_subtree(tree, present->number ? present->set.d[0] : NULL,\n                                                present->number ? present->set.d[0] : last_parent,\n                                                siter, 0, options)) {\n                    goto error;\n                }\n            }\n        }\n        break;\n    case LYS_CHOICE:\n        /* get existing node in the data tree from the choice */\n        iter = NULL;\n        if ((toplevel && tree) || (!toplevel && subtree)) {\n            LY_TREE_FOR(toplevel ? tree : subtree->child, iter) {\n                for (siter = lys_parent(iter->schema), siter_prev = iter->schema;\n                        siter && (siter->nodetype & (LYS_CASE | LYS_USES | LYS_CHOICE));\n                        siter_prev = siter, siter = lys_parent(siter)) {\n                    if (siter == schema) {\n                        /* we have the choice instance */\n                        break;\n                    }\n                }\n                if (siter == schema) {\n                    /* we have the choice instance;\n                     * the condition must be the same as in the loop because of\n                     * choice's sibling nodes that break the loop, so siter is not NULL,\n                     * but it is not the same as schema */\n                    break;\n                }\n            }\n        }\n        if (!iter) {\n            if (lyd_is_when_false(tree, last_parent, schema, options)) {\n                /* nothing to check */\n                break;\n            }\n            if (((struct lys_node_choice *)schema)->dflt) {\n                /* there is a default case */\n                if (lyd_check_mandatory_subtree(tree, subtree, last_parent, ((struct lys_node_choice *)schema)->dflt,\n                                                toplevel, options)) {\n                    goto error;\n                }\n            } else if (schema->flags & LYS_MAND_TRUE) {\n                /* choice requires some data to be instantiated */\n                LOGVAL(schema->module->ctx, LYE_NOMANDCHOICE, LY_VLOG_LYD, last_parent, schema->name);\n                goto error;\n            }\n        } else {\n            /* one of the choice's cases is instantiated, continue into this case */\n            /* since iter != NULL, siter must be also != NULL and we also know siter_prev\n             * which points to the child of schema leading towards the instantiated data */\n            assert(siter && siter_prev);\n            if (lyd_check_mandatory_subtree(tree, subtree, last_parent, siter_prev, toplevel, options)) {\n                goto error;\n            }\n        }\n        break;\n    case LYS_NOTIF:\n        /* skip if validating a notification */\n        if (!(options & LYD_OPT_NOTIF)) {\n            break;\n        }\n        /* fallthrough */\n    case LYS_CASE:\n    case LYS_USES:\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        /* go recursively */\n        LY_TREE_FOR(schema->child, siter) {\n            if (lyd_check_mandatory_subtree(tree, subtree, last_parent, siter, toplevel, options)) {\n                goto error;\n            }\n        }\n        break;\n    default:\n        /* stop */\n        break;\n    }\n\n    ret = EXIT_SUCCESS;\n\nerror:\n    ly_set_free(present);\n    return ret;\n}\n\nint\nlyd_check_mandatory_tree(struct lyd_node *root, struct ly_ctx *ctx, const struct lys_module **modules, int mod_count,\n                         int options)\n{\n    struct lys_node *siter;\n    int i;\n\n    assert(root || ctx);\n    assert(!(options & LYD_OPT_ACT_NOTIF));\n\n    if (options & (LYD_OPT_EDIT | LYD_OPT_GET | LYD_OPT_GETCONFIG)) {\n        /* no check is needed */\n        return EXIT_SUCCESS;\n    }\n\n    if (!ctx) {\n        /* get context */\n        ctx = root->schema->module->ctx;\n    }\n\n    if (!(options & LYD_OPT_TYPEMASK) || (options & LYD_OPT_CONFIG)) {\n        if (options & LYD_OPT_NOSIBLINGS) {\n            if (root && lyd_check_mandatory_subtree(root, NULL, NULL, root->schema, 1, options)) {\n                return EXIT_FAILURE;\n            }\n        } else if (modules && mod_count) {\n            for (i = 0; i < mod_count; ++i) {\n                LY_TREE_FOR(modules[i]->data, siter) {\n                    if (!(siter->nodetype & (LYS_RPC | LYS_NOTIF)) &&\n                            lyd_check_mandatory_subtree(root, NULL, NULL, siter, 1, options)) {\n                        return EXIT_FAILURE;\n                    }\n                }\n            }\n        } else {\n            for (i = (options & LYD_OPT_DATA_NO_YANGLIB) ? ctx->internal_module_count : ctx->internal_module_count - 1;\n                 i < ctx->models.used;\n                 i++) {\n                /* skip not implemented and disabled modules */\n                if (!ctx->models.list[i]->implemented || ctx->models.list[i]->disabled) {\n                    continue;\n                }\n                LY_TREE_FOR(ctx->models.list[i]->data, siter) {\n                    if (!(siter->nodetype & (LYS_RPC | LYS_NOTIF)) &&\n                            lyd_check_mandatory_subtree(root, NULL, NULL, siter, 1, options)) {\n                        return EXIT_FAILURE;\n                    }\n                }\n            }\n        }\n    } else if (options & LYD_OPT_NOTIF) {\n        if (!root || (root->schema->nodetype != LYS_NOTIF)) {\n            LOGERR(ctx, LY_EINVAL, \"Subtree is not a single notification.\");\n            return EXIT_FAILURE;\n        }\n        if (root->schema->child && lyd_check_mandatory_subtree(root, root, root, root->schema, 0, options)) {\n            return EXIT_FAILURE;\n        }\n    } else if (options & (LYD_OPT_RPC | LYD_OPT_RPCREPLY)) {\n        if (!root || !(root->schema->nodetype & (LYS_RPC | LYS_ACTION))) {\n            LOGERR(ctx, LY_EINVAL, \"Subtree is not a single RPC/action/reply.\");\n            return EXIT_FAILURE;\n        }\n        if (options & LYD_OPT_RPC) {\n            for (siter = root->schema->child; siter && siter->nodetype != LYS_INPUT; siter = siter->next);\n        } else { /* LYD_OPT_RPCREPLY */\n            for (siter = root->schema->child; siter && siter->nodetype != LYS_OUTPUT; siter = siter->next);\n        }\n        if (siter && lyd_check_mandatory_subtree(root, root, root, siter, 0, options)) {\n            return EXIT_FAILURE;\n        }\n    } else if (options & LYD_OPT_DATA_TEMPLATE) {\n        if (root && lyd_check_mandatory_subtree(root, NULL, NULL, root->schema, 1, options)) {\n            return EXIT_FAILURE;\n        }\n    } else {\n        LOGINT(ctx);\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n\nstatic struct lyd_node *\nlyd_parse_(struct ly_ctx *ctx, const struct lyd_node *rpc_act, const char *data, LYD_FORMAT format, int options,\n           const struct lyd_node *data_tree, const char *yang_data_name)\n{\n    struct lyxml_elem *xml;\n    struct lyd_node *result = NULL;\n    int xmlopt = LYXML_PARSE_MULTIROOT;\n\n    if (!ctx || !data) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (options & LYD_OPT_NOSIBLINGS) {\n        xmlopt = 0;\n    }\n\n    /* we must free all the errors, otherwise we are unable to properly check returned ly_errno :-/ */\n    ly_errno = LY_SUCCESS;\n    switch (format) {\n    case LYD_XML:\n        xml = lyxml_parse_mem(ctx, data, xmlopt);\n        if (ly_errno) {\n            break;\n        }\n        if (options & LYD_OPT_RPCREPLY) {\n            result = lyd_parse_xml(ctx, &xml, options, rpc_act, data_tree);\n        } else if (options & (LYD_OPT_RPC | LYD_OPT_NOTIF)) {\n            result = lyd_parse_xml(ctx, &xml, options, data_tree);\n        } else if (options & LYD_OPT_DATA_TEMPLATE) {\n            result = lyd_parse_xml(ctx, &xml, options, yang_data_name);\n        } else {\n            result = lyd_parse_xml(ctx, &xml, options);\n        }\n        lyxml_free_withsiblings(ctx, xml);\n        break;\n    case LYD_JSON:\n        result = lyd_parse_json(ctx, data, options, rpc_act, data_tree, yang_data_name);\n        break;\n    case LYD_LYB:\n        result = lyd_parse_lyb(ctx, data, options, data_tree, yang_data_name, NULL);\n        break;\n    default:\n        /* error */\n        break;\n    }\n\n    if (ly_errno) {\n        lyd_free_withsiblings(result);\n        return NULL;\n    } else {\n        return result;\n    }\n}\n\nstatic struct lyd_node *\nlyd_parse_data_(struct ly_ctx *ctx, const char *data, LYD_FORMAT format, int options, va_list ap)\n{\n    const struct lyd_node *rpc_act = NULL, *data_tree = NULL, *iter;\n    const char *yang_data_name = NULL;\n\n    if (lyp_data_check_options(ctx, options, __func__)) {\n        return NULL;\n    }\n\n    if (options & LYD_OPT_RPCREPLY) {\n        rpc_act = va_arg(ap, const struct lyd_node *);\n        if (!rpc_act || rpc_act->parent || !(rpc_act->schema->nodetype & (LYS_RPC | LYS_LIST | LYS_CONTAINER))) {\n            LOGERR(ctx, LY_EINVAL, \"%s: invalid variable parameter (const struct lyd_node *rpc_act).\", __func__);\n            return NULL;\n        }\n    }\n    if (options & (LYD_OPT_RPC | LYD_OPT_NOTIF | LYD_OPT_RPCREPLY)) {\n        data_tree = va_arg(ap, const struct lyd_node *);\n        if (data_tree) {\n            if (options & LYD_OPT_NOEXTDEPS) {\n                LOGERR(ctx, LY_EINVAL, \"%s: invalid parameter (variable arg const struct lyd_node *data_tree and LYD_OPT_NOEXTDEPS set).\",\n                       __func__);\n                return NULL;\n            }\n\n            LY_TREE_FOR(data_tree, iter) {\n                if (iter->parent) {\n                    /* a sibling is not top-level */\n                    LOGERR(ctx, LY_EINVAL, \"%s: invalid variable parameter (const struct lyd_node *data_tree).\", __func__);\n                    return NULL;\n                }\n            }\n\n            /* move it to the beginning */\n            for (; data_tree->prev->next; data_tree = data_tree->prev);\n\n            /* LYD_OPT_NOSIBLINGS cannot be set in this case */\n            if (options & LYD_OPT_NOSIBLINGS) {\n                LOGERR(ctx, LY_EINVAL, \"%s: invalid parameter (variable arg const struct lyd_node *data_tree with LYD_OPT_NOSIBLINGS).\", __func__);\n                return NULL;\n            }\n        }\n    }\n    if (options & LYD_OPT_DATA_TEMPLATE) {\n        yang_data_name = va_arg(ap, const char *);\n    }\n\n    return lyd_parse_(ctx, rpc_act, data, format, options, data_tree, yang_data_name);\n}\n\nAPI struct lyd_node *\nlyd_parse_mem(struct ly_ctx *ctx, const char *data, LYD_FORMAT format, int options, ...)\n{\n    va_list ap;\n    struct lyd_node *result;\n\n    va_start(ap, options);\n    result = lyd_parse_data_(ctx, data, format, options, ap);\n    va_end(ap);\n\n    return result;\n}\n\nstatic struct lyd_node *\nlyd_parse_fd_(struct ly_ctx *ctx, int fd, LYD_FORMAT format, int options, va_list ap)\n{\n    struct lyd_node *ret;\n    size_t length;\n    char *data;\n\n    if (!ctx || (fd == -1)) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (lyp_mmap(ctx, fd, 0, &length, (void **)&data)) {\n        LOGERR(ctx, LY_ESYS, \"Mapping file descriptor into memory failed (%s()).\", __func__);\n        return NULL;\n    } else if (!data) {\n        return NULL;\n    }\n\n    ret = lyd_parse_data_(ctx, data, format, options, ap);\n\n    lyp_munmap(data, length);\n\n    return ret;\n}\n\nAPI struct lyd_node *\nlyd_parse_fd(struct ly_ctx *ctx, int fd, LYD_FORMAT format, int options, ...)\n{\n    struct lyd_node *ret;\n    va_list ap;\n\n    va_start(ap, options);\n    ret = lyd_parse_fd_(ctx, fd, format, options, ap);\n    va_end(ap);\n\n    return ret;\n}\n\nAPI struct lyd_node *\nlyd_parse_path(struct ly_ctx *ctx, const char *path, LYD_FORMAT format, int options, ...)\n{\n    int fd;\n    struct lyd_node *ret;\n    va_list ap;\n\n    if (!ctx || !path) {\n        LOGARG;\n        return NULL;\n    }\n\n    fd = open(path, O_RDONLY);\n    if (fd == -1) {\n        LOGERR(ctx, LY_ESYS, \"Failed to open data file \\\"%s\\\" (%s).\", path, strerror(errno));\n        return NULL;\n    }\n\n    va_start(ap, options);\n    ret = lyd_parse_fd_(ctx, fd, format, options, ap);\n\n    va_end(ap);\n    close(fd);\n\n    return ret;\n}\n\nstatic struct lys_node *\nlyd_new_find_schema(struct lyd_node *parent, const struct lys_module *module, int rpc_output)\n{\n    struct lys_node *siblings;\n\n    if (!parent) {\n        siblings = module->data;\n    } else {\n        if (!parent->schema) {\n            return NULL;\n        }\n        siblings = parent->schema->child;\n        if (siblings && (siblings->nodetype == (rpc_output ? LYS_INPUT : LYS_OUTPUT))) {\n            siblings = siblings->next;\n        }\n        if (siblings && (siblings->nodetype == (rpc_output ? LYS_OUTPUT : LYS_INPUT))) {\n            siblings = siblings->child;\n        }\n    }\n\n    return siblings;\n}\n\nstruct lyd_node *\n_lyd_new(struct lyd_node *parent, const struct lys_node *schema, int dflt)\n{\n    struct lyd_node *ret;\n\n    ret = calloc(1, sizeof *ret);\n    LY_CHECK_ERR_RETURN(!ret, LOGMEM(schema->module->ctx), NULL);\n\n    ret->schema = (struct lys_node *)schema;\n    ret->validity = ly_new_node_validity(schema);\n    if (resolve_applies_when(schema, 0, NULL)) {\n        ret->when_status = LYD_WHEN;\n    }\n    ret->prev = ret;\n    ret->dflt = dflt;\n\n#ifdef LY_ENABLED_CACHE\n    lyd_hash(ret);\n#endif\n\n    if (parent) {\n        if (lyd_insert(parent, ret)) {\n            lyd_free(ret);\n            return NULL;\n        }\n    }\n    return ret;\n}\n\nAPI struct lyd_node *\nlyd_new(struct lyd_node *parent, const struct lys_module *module, const char *name)\n{\n    const struct lys_node *snode = NULL, *siblings;\n\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n\n    siblings = lyd_new_find_schema(parent, module, 0);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_CONTAINER | LYS_LIST | LYS_NOTIF\n                         | LYS_RPC | LYS_ACTION, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n\n    return _lyd_new(parent, snode, 0);\n}\n\nstatic struct lyd_node *\nlyd_create_leaf(const struct lys_node *schema, const char *val_str, int dflt)\n{\n    struct lyd_node_leaf_list *ret;\n\n    ret = calloc(1, sizeof *ret);\n    LY_CHECK_ERR_RETURN(!ret, LOGMEM(schema->module->ctx), NULL);\n\n    ret->schema = (struct lys_node *)schema;\n    ret->validity = ly_new_node_validity(schema);\n    if (resolve_applies_when(schema, 0, NULL)) {\n        ret->when_status = LYD_WHEN;\n    }\n    ret->prev = (struct lyd_node *)ret;\n    ret->value_type = ((struct lys_node_leaf *)schema)->type.base;\n    ret->value_str = lydict_insert(schema->module->ctx, val_str ? val_str : \"\", 0);\n    ret->dflt = dflt;\n\n#ifdef LY_ENABLED_CACHE\n    lyd_hash((struct lyd_node *)ret);\n#endif\n\n    return (struct lyd_node *)ret;\n}\n\nstatic struct lyd_node *\n_lyd_new_leaf(struct lyd_node *parent, const struct lys_node *schema, const char *val_str, int dflt, int edit_leaf)\n{\n    struct lyd_node *ret;\n\n    ret = lyd_create_leaf(schema, val_str, dflt);\n    if (!ret) {\n        return NULL;\n    }\n\n    /* connect to parent */\n    if (parent) {\n        if (lyd_insert(parent, ret)) {\n            lyd_free(ret);\n            return NULL;\n        }\n    }\n\n    if (edit_leaf && !((struct lyd_node_leaf_list *)ret)->value_str[0]) {\n        /* empty edit leaf, it is fine */\n        ((struct lyd_node_leaf_list *)ret)->value_type = LY_TYPE_UNKNOWN;\n        return ret;\n    }\n\n    /* resolve the type correctly (after it was connected to parent cause of log) */\n    if (!lyp_parse_value(&((struct lys_node_leaf *)ret->schema)->type, &((struct lyd_node_leaf_list *)ret)->value_str,\n                         NULL, (struct lyd_node_leaf_list *)ret, NULL, NULL, 1, dflt, 0)) {\n        lyd_free(ret);\n        return NULL;\n    }\n\n    if ((ret->schema->nodetype == LYS_LEAF) && (ret->schema->flags & LYS_UNIQUE)) {\n        for (; parent && (parent->schema->nodetype != LYS_LIST); parent = parent->parent);\n        if (parent) {\n            parent->validity |= LYD_VAL_UNIQUE;\n        } else {\n            LOGINT(schema->module->ctx);\n        }\n    }\n\n    return ret;\n}\n\nAPI struct lyd_node *\nlyd_new_leaf(struct lyd_node *parent, const struct lys_module *module, const char *name, const char *val_str)\n{\n    const struct lys_node *snode = NULL, *siblings;\n\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n\n    siblings = lyd_new_find_schema(parent, module, 0);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n\n    return _lyd_new_leaf(parent, snode, val_str, 0, 0);\n}\n\n/**\n * @brief Update (add) default flag of the parents of the added node.\n *\n * @param[in] node Added node\n */\nstatic void\nlyd_wd_update_parents(struct lyd_node *node)\n{\n    struct lyd_node *parent = node->parent, *iter;\n\n    for (parent = node->parent; parent; parent = node->parent) {\n        if (parent->dflt || parent->schema->nodetype != LYS_CONTAINER ||\n                ((struct lys_node_container *)parent->schema)->presence) {\n            /* parent is already default and there is nothing to update or\n             * it is not a non-presence container -> stop the loop */\n            break;\n        }\n        /* check that there is still some non default sibling */\n        for (iter = node->prev; iter != node; iter = iter->prev) {\n            if (!iter->dflt) {\n                break;\n            }\n        }\n        if (iter == node && node->prev != node) {\n            /* all siblings are implicit default nodes, propagate it to the parent */\n            node = node->parent;\n            node->dflt = 1;\n            continue;\n        } else {\n            /* stop the loop */\n            break;\n        }\n    }\n}\n\n/* op - 0 add, 1 del, 2 mod (add + del) */\nstatic void\ncheck_leaf_list_backlinks(struct lyd_node *node, int op)\n{\n    struct lyd_node *next, *iter;\n    struct lyd_node_leaf_list *leaf_list;\n    struct ly_set *set, *data;\n    uint32_t i, j;\n    int validity_changed = 0;\n\n    assert((op == 0) || (op == 1) || (op == 2));\n\n    /* fix leafrefs */\n    LY_TREE_DFS_BEGIN(node, next, iter) {\n        /* the node is target of a leafref */\n        if ((iter->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST)) && iter->schema->child) {\n            set = (struct ly_set *)iter->schema->child;\n            for (i = 0; i < set->number; i++) {\n                data = lyd_find_instance(iter, set->set.s[i]);\n                if (data) {\n                    for (j = 0; j < data->number; j++) {\n                        leaf_list = (struct lyd_node_leaf_list *)data->set.d[j];\n                        if (((op != 0) && (leaf_list->value_type == LY_TYPE_LEAFREF) && (leaf_list->value.leafref == iter))\n                                || ((op != 1) && (leaf_list->value_flags & LY_VALUE_UNRES))) {\n                            /* invalidate the leafref, a change concerning it happened */\n                            leaf_list->validity |= LYD_VAL_LEAFREF;\n                            validity_changed = 1;\n                            if (leaf_list->value_type == LY_TYPE_LEAFREF) {\n                                /* remove invalid link and put unresolved value back */\n                                lyp_parse_value(&((struct lys_node_leaf *)leaf_list->schema)->type, &leaf_list->value_str,\n                                                NULL, leaf_list, NULL, NULL, 1, leaf_list->dflt, 0);\n                            }\n                        }\n                    }\n                    ly_set_free(data);\n                } else {\n                    LOGINT(node->schema->module->ctx);\n                    return;\n                }\n            }\n        }\n        LY_TREE_DFS_END(node, next, iter)\n    }\n\n    /* invalidate parent to make sure it will be checked in future validation */\n    if (validity_changed && node->parent) {\n        node->parent->validity |= LYD_VAL_MAND;\n    }\n}\n\nAPI int\nlyd_change_leaf(struct lyd_node_leaf_list *leaf, const char *val_str)\n{\n    const char *backup;\n    int val_change, dflt_change;\n    struct lyd_node *parent;\n\n    if (!leaf || (leaf->schema->nodetype != LYS_LEAF)) {\n        LOGARG;\n        return -1;\n    }\n\n    backup = leaf->value_str;\n    leaf->value_str = lydict_insert(leaf->schema->module->ctx, val_str ? val_str : \"\", 0);\n    /* leaf->value is erased by lyp_parse_value() */\n\n    /* parse the type correctly, makes the value canonical if needed */\n    if (!lyp_parse_value(&((struct lys_node_leaf *)leaf->schema)->type, &leaf->value_str, NULL, leaf, NULL, NULL, 1, 0, 0)) {\n        lydict_remove(leaf->schema->module->ctx, backup);\n        return -1;\n    }\n\n    if (!strcmp(backup, leaf->value_str)) {\n        /* the value remains the same */\n        val_change = 0;\n    } else {\n        val_change = 1;\n    }\n\n    /* value is correct, remove backup */\n    lydict_remove(leaf->schema->module->ctx, backup);\n\n    /* clear the default flag, the value is different */\n    if (leaf->dflt) {\n        for (parent = (struct lyd_node *)leaf; parent; parent = parent->parent) {\n            parent->dflt = 0;\n        }\n        dflt_change = 1;\n    } else {\n        dflt_change = 0;\n    }\n\n    if (val_change) {\n        /* make the node non-validated */\n        leaf->validity = ly_new_node_validity(leaf->schema);\n\n        /* check possible leafref backlinks */\n        check_leaf_list_backlinks((struct lyd_node *)leaf, 2);\n    }\n\n    if (val_change && (leaf->schema->flags & LYS_UNIQUE)) {\n        for (parent = leaf->parent; parent && (parent->schema->nodetype != LYS_LIST); parent = parent->parent);\n        if (parent) {\n            parent->validity |= LYD_VAL_UNIQUE;\n        } else {\n            LOGINT(leaf->schema->module->ctx);\n            return -1;\n        }\n    }\n\n    return (val_change || dflt_change ? 0 : 1);\n}\n\nstatic struct lyd_node *\nlyd_create_anydata(struct lyd_node *parent, const struct lys_node *schema, void *value,\n                   LYD_ANYDATA_VALUETYPE value_type)\n{\n    struct lyd_node *iter;\n    struct lyd_node_anydata *ret;\n    int len;\n\n    ret = calloc(1, sizeof *ret);\n    LY_CHECK_ERR_RETURN(!ret, LOGMEM(schema->module->ctx), NULL);\n\n    ret->schema = (struct lys_node *)schema;\n    ret->validity = ly_new_node_validity(schema);\n    if (resolve_applies_when(schema, 0, NULL)) {\n        ret->when_status = LYD_WHEN;\n    }\n    ret->prev = (struct lyd_node *)ret;\n\n    /* set the value */\n    switch (value_type) {\n    case LYD_ANYDATA_CONSTSTRING:\n    case LYD_ANYDATA_SXML:\n    case LYD_ANYDATA_JSON:\n        ret->value.str = lydict_insert(schema->module->ctx, (const char *)value, 0);\n        break;\n    case LYD_ANYDATA_STRING:\n    case LYD_ANYDATA_SXMLD:\n    case LYD_ANYDATA_JSOND:\n        ret->value.str = lydict_insert_zc(schema->module->ctx, (char *)value);\n        value_type &= ~LYD_ANYDATA_STRING; /* make const string from string */\n        break;\n    case LYD_ANYDATA_DATATREE:\n        ret->value.tree = (struct lyd_node *)value;\n        break;\n    case LYD_ANYDATA_XML:\n        ret->value.xml = (struct lyxml_elem *)value;\n        break;\n    case LYD_ANYDATA_LYB:\n        len = lyd_lyb_data_length(value);\n        if (len == -1) {\n            LOGERR(schema->module->ctx, LY_EINVAL, \"Invalid LYB data.\");\n            return NULL;\n        }\n        ret->value.mem = malloc(len);\n        LY_CHECK_ERR_RETURN(!ret->value.mem, LOGMEM(schema->module->ctx); free(ret), NULL);\n        memcpy(ret->value.mem, value, len);\n        break;\n    case LYD_ANYDATA_LYBD:\n        ret->value.mem = value;\n        value_type &= ~LYD_ANYDATA_STRING; /* make const string from string */\n        break;\n    }\n    ret->value_type = value_type;\n\n#ifdef LY_ENABLED_CACHE\n    lyd_hash((struct lyd_node *)ret);\n#endif\n\n    /* connect to parent */\n    if (parent) {\n        if (lyd_insert(parent, (struct lyd_node*)ret)) {\n            lyd_free((struct lyd_node*)ret);\n            return NULL;\n        }\n\n        /* remove the flag from parents */\n        for (iter = parent; iter && iter->dflt; iter = iter->parent) {\n            iter->dflt = 0;\n        }\n    }\n\n    return (struct lyd_node*)ret;\n}\n\nAPI struct lyd_node *\nlyd_new_anydata(struct lyd_node *parent, const struct lys_module *module, const char *name,\n                void *value, LYD_ANYDATA_VALUETYPE value_type)\n{\n    const struct lys_node *siblings, *snode;\n\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n\n    siblings = lyd_new_find_schema(parent, module, 0);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n\n    return lyd_create_anydata(parent, snode, value, value_type);\n}\n\nAPI struct lyd_node *\nlyd_new_yangdata(const struct lys_module *module, const char *name_template, const char *name)\n{\n    const struct lys_node *schema = NULL, *snode;\n\n    if (!module || !name_template || !name) {\n        LOGARG;\n        return NULL;\n    }\n\n    schema = lyp_get_yang_data_template(module, name_template, strlen(name_template));\n    if (!schema) {\n        LOGERR(module->ctx, LY_EINVAL, \"Failed to find yang-data template \\\"%s\\\".\", name_template);\n        return NULL;\n    }\n\n    if (lys_getnext_data(module, schema, name, strlen(name), LYS_CONTAINER, &snode) || !snode) {\n        LOGERR(module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a container child of \\\"%s:%s\\\".\",\n               name, module->name, schema->name);\n        return NULL;\n    }\n\n    return _lyd_new(NULL, snode, 0);\n}\n\nAPI struct lyd_node *\nlyd_new_output(struct lyd_node *parent, const struct lys_module *module, const char *name)\n{\n    const struct lys_node *snode = NULL, *siblings;\n\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_CONTAINER | LYS_LIST | LYS_NOTIF\n                         | LYS_RPC | LYS_ACTION, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n\n    return _lyd_new(parent, snode, 0);\n}\n\nAPI struct lyd_node *\nlyd_new_output_leaf(struct lyd_node *parent, const struct lys_module *module, const char *name, const char *val_str)\n{\n    const struct lys_node *snode = NULL, *siblings;\n\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n\n    return _lyd_new_leaf(parent, snode, val_str, 0, 0);\n}\n\nAPI struct lyd_node *\nlyd_new_output_anydata(struct lyd_node *parent, const struct lys_module *module, const char *name,\n                       void *value, LYD_ANYDATA_VALUETYPE value_type)\n{\n    const struct lys_node *siblings, *snode;\n\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n\n    return lyd_create_anydata(parent, snode, value, value_type);\n}\n\nstatic int\nlyd_new_path_list_predicate(struct lyd_node *list, const char *list_name, const char *predicate, int *parsed)\n{\n    const char *mod_name, *name, *value;\n    char *key_val;\n    int r, i, mod_name_len, nam_len, val_len, has_predicate;\n    struct lys_node_list *slist;\n    struct lys_node *key;\n\n    slist = (struct lys_node_list *)list->schema;\n\n    /* is the predicate a number? */\n    if (((r = parse_schema_json_predicate(predicate, &mod_name, &mod_name_len, &name, &nam_len, &value, &val_len, &has_predicate)) < 1)\n            || !strncmp(name, \".\", nam_len)) {\n        LOGVAL(slist->module->ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, predicate[-r], &predicate[-r]);\n        return -1;\n    }\n\n    if (isdigit(name[0])) {\n        /* position index - creating without keys */\n        *parsed += r;\n        return 0;\n    }\n\n    /* it's not a number, so there must be some keys */\n    if (!slist->keys_size) {\n        /* there are none, so pretend we did not parse anything to get invalid char error later */\n        return 0;\n    }\n\n    /* go through all the keys */\n    i = 0;\n    goto check_parsed_values;\n\n    for (; i < slist->keys_size; ++i) {\n        if (!has_predicate) {\n            LOGVAL(slist->module->ctx, LYE_PATH_MISSKEY, LY_VLOG_NONE, NULL, list_name);\n            return -1;\n        }\n\n        if (((r = parse_schema_json_predicate(predicate, &mod_name, &mod_name_len, &name, &nam_len, &value, &val_len, &has_predicate)) < 1)\n                || !strncmp(name, \".\", nam_len)) {\n            LOGVAL(slist->module->ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, predicate[-r], &predicate[-r]);\n            return -1;\n        }\n\ncheck_parsed_values:\n        key = (struct lys_node *)slist->keys[i];\n        *parsed += r;\n        predicate += r;\n\n        if (!value || (!mod_name && (lys_node_module(key) != lys_node_module((struct lys_node *)slist)))\n                || (mod_name && (strncmp(lys_node_module(key)->name, mod_name, mod_name_len) || lys_node_module(key)->name[mod_name_len]))\n                || strncmp(key->name, name, nam_len) || key->name[nam_len]) {\n            LOGVAL(slist->module->ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, name);\n            return -1;\n        }\n\n        key_val = malloc((val_len + 1) * sizeof(char));\n        LY_CHECK_ERR_RETURN(!key_val, LOGMEM(slist->module->ctx), -1);\n        strncpy(key_val, value, val_len);\n        key_val[val_len] = '\\0';\n\n        if (!_lyd_new_leaf(list, key, key_val, 0, 0)) {\n            free(key_val);\n            return -1;\n        }\n        free(key_val);\n    }\n\n    return 0;\n}\n\nstatic struct lyd_node *\nlyd_new_path_update(struct lyd_node *node, void *value, LYD_ANYDATA_VALUETYPE value_type, int dflt)\n{\n    struct ly_ctx *ctx = node->schema->module->ctx;\n    struct lyd_node_anydata *any;\n    int len;\n\n    switch (node->schema->nodetype) {\n    case LYS_LEAF:\n        if (value_type > LYD_ANYDATA_STRING) {\n            LOGARG;\n            return NULL;\n        }\n\n        if (lyd_change_leaf((struct lyd_node_leaf_list *)node, value) == 0) {\n            /* there was an actual change */\n            if (dflt) {\n                node->dflt = 1;\n            }\n            return node;\n        }\n\n        if (dflt) {\n            /* maybe the value is the same, but the node is default now */\n            node->dflt = 1;\n            return node;\n        }\n\n        break;\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        /* the nodes are the same if:\n         * 1) the value types are strings (LYD_ANYDATA_STRING and LYD_ANYDATA_CONSTSTRING equals)\n         *    and the strings equals\n         * 2) the value types are the same, but not strings and the pointers (not the content) are the\n         *    same\n         */\n        any = (struct lyd_node_anydata *)node;\n        if (any->value_type <= LYD_ANYDATA_STRING && value_type <= LYD_ANYDATA_STRING) {\n            if (ly_strequal(any->value.str, (char *)value, 0)) {\n                /* values are the same */\n                return NULL;\n            }\n        } else if (any->value_type == value_type) {\n            /* compare pointers */\n            if ((void *)any->value.tree == value) {\n                /* values are the same */\n                return NULL;\n            }\n        }\n\n        /* values are not the same - 1) remove the old one ... */\n        switch (any->value_type) {\n        case LYD_ANYDATA_CONSTSTRING:\n        case LYD_ANYDATA_SXML:\n        case LYD_ANYDATA_JSON:\n            lydict_remove(ctx, any->value.str);\n            break;\n        case LYD_ANYDATA_DATATREE:\n            lyd_free_withsiblings(any->value.tree);\n            break;\n        case LYD_ANYDATA_XML:\n            lyxml_free_withsiblings(ctx, any->value.xml);\n            break;\n        case LYD_ANYDATA_LYB:\n            free(any->value.mem);\n            break;\n        case LYD_ANYDATA_STRING:\n        case LYD_ANYDATA_SXMLD:\n        case LYD_ANYDATA_JSOND:\n        case LYD_ANYDATA_LYBD:\n            /* dynamic strings are used only as input parameters */\n            assert(0);\n            break;\n        }\n        /* ... and 2) store the new one */\n        switch (value_type) {\n        case LYD_ANYDATA_CONSTSTRING:\n        case LYD_ANYDATA_SXML:\n        case LYD_ANYDATA_JSON:\n            any->value.str = lydict_insert(ctx, (const char *)value, 0);\n            break;\n        case LYD_ANYDATA_STRING:\n        case LYD_ANYDATA_SXMLD:\n        case LYD_ANYDATA_JSOND:\n            any->value.str = lydict_insert_zc(ctx, (char *)value);\n            value_type &= ~LYD_ANYDATA_STRING; /* make const string from string */\n            break;\n        case LYD_ANYDATA_DATATREE:\n            any->value.tree = value;\n            break;\n        case LYD_ANYDATA_XML:\n            any->value.xml = value;\n            break;\n        case LYD_ANYDATA_LYB:\n            len = lyd_lyb_data_length(value);\n            if (len == -1) {\n                LOGERR(ctx, LY_EINVAL, \"Invalid LYB data.\");\n                return NULL;\n            }\n            any->value.mem = malloc(len);\n            LY_CHECK_ERR_RETURN(!any->value.mem, LOGMEM(ctx), NULL);\n            memcpy(any->value.mem, value, len);\n            break;\n        case LYD_ANYDATA_LYBD:\n            any->value.mem = value;\n            value_type &= ~LYD_ANYDATA_STRING; /* make const string from string */\n            break;\n        }\n        return node;\n    default:\n        /* nothing needed - containers, lists and leaf-lists do not have value or it cannot be changed */\n        break;\n    }\n\n    /* not updated */\n    return NULL;\n}\n\nAPI struct lyd_node *\nlyd_new_path(struct lyd_node *data_tree, const struct ly_ctx *ctx, const char *path, void *value,\n             LYD_ANYDATA_VALUETYPE value_type, int options)\n{\n    char *str;\n    const char *mod_name, *name, *val_name, *val, *node_mod_name, *id, *backup_mod_name = NULL, *yang_data_name = NULL;\n    struct lyd_node *ret = NULL, *node, *parent = NULL;\n    const struct lys_node *schild, *sparent, *tmp;\n    const struct lys_node_list *slist;\n    const struct lys_module *module, *prev_mod;\n    int r, i, parsed = 0, mod_name_len, nam_len, val_name_len, val_len;\n    int is_relative = -1, has_predicate, first_iter = 1, edit_leaf;\n    int backup_is_relative, backup_mod_name_len, yang_data_name_len;\n\n    if (!path || (!data_tree && !ctx)\n            || (!data_tree && (path[0] != '/'))) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (!ctx) {\n        ctx = data_tree->schema->module->ctx;\n    }\n\n    id = path;\n\n    if (data_tree) {\n        if (path[0] == '/') {\n            /* absolute path, go through all the siblings and try to find the right parent, if exists,\n             * first go through all the next siblings keeping the original order, for positional predicates */\n            for (node = data_tree; !parsed && node; node = node->next) {\n                parent = resolve_partial_json_data_nodeid(id, value_type > LYD_ANYDATA_STRING ? NULL : value, node,\n                                                          options, &parsed);\n            }\n            if (!parsed) {\n                for (node = data_tree->prev; !parsed && node->next; node = node->prev) {\n                    parent = resolve_partial_json_data_nodeid(id, value_type > LYD_ANYDATA_STRING ? NULL : value, node,\n                                                              options, &parsed);\n                }\n            }\n        } else {\n            /* relative path, use only the provided data tree root */\n            parent = resolve_partial_json_data_nodeid(id, value_type > LYD_ANYDATA_STRING ? NULL : value, data_tree,\n                                                      options, &parsed);\n        }\n        if (parsed == -1) {\n            return NULL;\n        }\n        if (parsed) {\n            assert(parent);\n            /* if we parsed something we have a relative path now for sure, otherwise we don't know */\n            is_relative = 1;\n\n            id += parsed;\n\n            if (!id[0]) {\n                /* the node exists, are we supposed to update it or is it default? */\n                if (!(options & LYD_PATH_OPT_UPDATE) && (!parent->dflt || (options & LYD_PATH_OPT_DFLT))) {\n                    LOGVAL(ctx, LYE_PATH_EXISTS, LY_VLOG_STR, path);\n                    return NULL;\n                }\n\n                /* no change, the default node already exists */\n                if (parent->dflt && (options & LYD_PATH_OPT_DFLT)) {\n                    return NULL;\n                }\n\n                return lyd_new_path_update(parent, value, value_type, options & LYD_PATH_OPT_DFLT);\n            }\n        }\n    }\n\n    backup_is_relative = is_relative;\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 1)) < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n        return NULL;\n    }\n\n    if (name[0] == '#') {\n        if (is_relative) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, '#', name);\n            return NULL;\n        }\n        yang_data_name = name + 1;\n        yang_data_name_len = nam_len - 1;\n        backup_mod_name = mod_name;\n        backup_mod_name_len = mod_name_len;\n        /* move to the next node in the path */\n        id += r;\n    } else {\n        is_relative = backup_is_relative;\n    }\n\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate, NULL, 0)) < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n        return NULL;\n    }\n    /* move to the next node in the path */\n    id += r;\n\n    if (backup_mod_name) {\n        mod_name = backup_mod_name;\n        mod_name_len = backup_mod_name_len;\n    }\n\n    /* prepare everything for the schema search loop */\n    if (is_relative) {\n        /* we are relative to data_tree or parent if some part of the path already exists */\n        if (!data_tree) {\n            LOGERR(ctx, LY_EINVAL, \"%s: provided relative path (%s) without context node.\", path);\n            return NULL;\n        } else if (!parent) {\n            parent = data_tree;\n        }\n        sparent = parent->schema;\n        module = prev_mod = lys_node_module(sparent);\n    } else {\n        /* we are starting from scratch, absolute path */\n        assert(!parent);\n        if (!mod_name) {\n            str = strndup(path, (name + nam_len) - path);\n            LOGVAL(ctx, LYE_PATH_MISSMOD, LY_VLOG_STR, str);\n            free(str);\n            return NULL;\n        }\n\n        module = ly_ctx_nget_module(ctx, mod_name, mod_name_len, NULL, 1);\n\n        if (!module) {\n            str = strndup(path, (mod_name + mod_name_len) - path);\n            LOGVAL(ctx, LYE_PATH_INMOD, LY_VLOG_STR, str);\n            free(str);\n            return NULL;\n        }\n        mod_name = NULL;\n        mod_name_len = 0;\n        prev_mod = module;\n\n        sparent = NULL;\n        if (yang_data_name) {\n            sparent = lyp_get_yang_data_template(module, yang_data_name, yang_data_name_len);\n            if (!sparent) {\n                str = strndup(path, (yang_data_name + yang_data_name_len) - path);\n                LOGVAL(ctx, LYE_PATH_INNODE, LY_VLOG_STR, str);\n                free(str);\n                return NULL;\n            }\n        }\n    }\n\n    /* create nodes in a loop */\n    while (1) {\n        /* find the schema node */\n        schild = NULL;\n        while ((schild = lys_getnext(schild, sparent, module, 0))) {\n            if (schild->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST\n                                    | LYS_ANYDATA | LYS_NOTIF | LYS_RPC | LYS_ACTION)) {\n                /* module comparison */\n                if (mod_name) {\n                    node_mod_name = lys_node_module(schild)->name;\n                    if (strncmp(node_mod_name, mod_name, mod_name_len) || node_mod_name[mod_name_len]) {\n                        continue;\n                    }\n                } else if (lys_node_module(schild) != prev_mod) {\n                    continue;\n                }\n\n                /* name check */\n                if (strncmp(schild->name, name, nam_len) || schild->name[nam_len]) {\n                    continue;\n                }\n\n                /* RPC/action in/out check */\n                for (tmp = lys_parent(schild); tmp && (tmp->nodetype == LYS_USES); tmp = lys_parent(tmp));\n                if (tmp) {\n                    if (options & LYD_PATH_OPT_OUTPUT) {\n                        if (tmp->nodetype == LYS_INPUT) {\n                            continue;\n                        }\n                    } else {\n                        if (tmp->nodetype == LYS_OUTPUT) {\n                            continue;\n                        }\n                    }\n                }\n\n                break;\n            }\n        }\n\n        if (!schild) {\n            str = strndup(path, (name + nam_len) - path);\n            LOGVAL(ctx, LYE_PATH_INNODE, LY_VLOG_STR, str);\n            free(str);\n            lyd_free(ret);\n            return NULL;\n        }\n\n        /* we have the right schema node */\n        switch (schild->nodetype) {\n        case LYS_CONTAINER:\n        case LYS_LIST:\n        case LYS_NOTIF:\n        case LYS_RPC:\n        case LYS_ACTION:\n            if (options & LYD_PATH_OPT_NOPARENT) {\n                /* these were supposed to exist */\n                str = strndup(path, (name + nam_len) - path);\n                LOGVAL(ctx, LYE_PATH_MISSPAR, LY_VLOG_STR, str);\n                free(str);\n                lyd_free(ret);\n                return NULL;\n            }\n            node = _lyd_new(is_relative ? parent : NULL, schild, (options & LYD_PATH_OPT_DFLT) ? 1 : 0);\n            break;\n        case LYS_LEAF:\n        case LYS_LEAFLIST:\n            str = NULL;\n            if (has_predicate) {\n                if ((r = parse_schema_json_predicate(id, NULL, NULL, &val_name, &val_name_len, &val, &val_len, &has_predicate)) < 1) {\n                    LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n                    lyd_free(ret);\n                    return NULL;\n                }\n                id += r;\n\n                if ((val_name[0] != '.') || (val_name_len != 1)) {\n                    LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, val_name[0], val_name);\n                    lyd_free(ret);\n                    return NULL;\n                }\n\n                str = strndup(val, val_len);\n                if (!str) {\n                    LOGMEM(ctx);\n                    lyd_free(ret);\n                    return NULL;\n                }\n            }\n            if (id[0]) {\n                LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n                free(str);\n                lyd_free(ret);\n                return NULL;\n            }\n\n            if ((options & LYD_PATH_OPT_EDIT) && schild->nodetype == LYS_LEAF) {\n                edit_leaf = 1;\n            } else {\n                edit_leaf = 0;\n            }\n            node = _lyd_new_leaf(is_relative ? parent : NULL, schild, (str ? str : value),\n                                 (options & LYD_PATH_OPT_DFLT) ? 1 : 0, edit_leaf);\n            free(str);\n            break;\n        case LYS_ANYXML:\n        case LYS_ANYDATA:\n            if (id[0]) {\n                LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n                lyd_free(ret);\n                return NULL;\n            }\n            if (value_type <= LYD_ANYDATA_STRING && !value) {\n                value_type = LYD_ANYDATA_CONSTSTRING;\n                value = \"\";\n            }\n            node = lyd_create_anydata(is_relative ? parent : NULL, schild, value, value_type);\n            break;\n        default:\n            LOGINT(ctx);\n            node = NULL;\n            break;\n        }\n\n        if (!node) {\n            str = strndup(path, id - path);\n            if (is_relative) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_STR, str, \"Failed to create node \\\"%s\\\" as a child of \\\"%s\\\".\",\n                       schild->name, parent->schema->name);\n            } else {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_STR, str, \"Failed to create node \\\"%s\\\".\", schild->name);\n            }\n            free(str);\n            lyd_free(ret);\n            return NULL;\n        }\n        /* special case when we are creating a sibling of a top-level data node */\n        if (!is_relative) {\n            if (data_tree) {\n                for (; data_tree->next; data_tree = data_tree->next);\n                if (lyd_insert_after(data_tree, node)) {\n                    lyd_free(ret);\n                    return NULL;\n                }\n            }\n            is_relative = 1;\n        }\n\n        if (first_iter) {\n            /* sort if needed, but only when inserted somewhere */\n            sparent = node->schema;\n            do {\n                sparent = lys_parent(sparent);\n            } while (sparent && (sparent->nodetype != ((options & LYD_PATH_OPT_OUTPUT) ? LYS_OUTPUT : LYS_INPUT)));\n            if (sparent && lyd_schema_sort(node, 0)) {\n                lyd_free(ret);\n                return NULL;\n            }\n\n            /* set first created node */\n            ret = node;\n            first_iter = 0;\n        }\n\n        parsed = 0;\n        if ((schild->nodetype == LYS_LIST) && has_predicate && lyd_new_path_list_predicate(node, name, id, &parsed)) {\n            lyd_free(ret);\n            return NULL;\n        }\n        id += parsed;\n\n        if (!id[0]) {\n            /* we are done */\n            if (options & LYD_PATH_OPT_NOPARENTRET) {\n                /* last created node */\n                return node;\n            }\n            return ret;\n        }\n\n        /* prepare for another iteration */\n        parent = node;\n        sparent = schild;\n        prev_mod = lys_node_module(schild);\n\n        /* parse another node */\n        if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate, NULL, 0)) < 1) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n            lyd_free(ret);\n            return NULL;\n        }\n        id += r;\n\n        /* if a key of a list was supposed to be created, it is created as a part of the list instance creation */\n        if ((schild->nodetype == LYS_LIST) && !mod_name) {\n            slist = (const struct lys_node_list *)schild;\n            for (i = 0; i < slist->keys_size; ++i) {\n                if (!strncmp(slist->keys[i]->name, name, nam_len) && !slist->keys[i]->name[nam_len]) {\n                    /* the path continues? there cannot be anything after a key (leaf) */\n                    if (id[0]) {\n                        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n                        lyd_free(ret);\n                        return NULL;\n                    }\n                    return ret;\n                }\n            }\n        }\n    }\n\n    LOGINT(ctx);\n    return NULL;\n}\n\nAPI unsigned int\nlyd_list_pos(const struct lyd_node *node)\n{\n    unsigned int pos;\n    struct lys_node *schema;\n\n    if (!node || ((node->schema->nodetype != LYS_LIST) && (node->schema->nodetype != LYS_LEAFLIST))) {\n        return 0;\n    }\n\n    schema = node->schema;\n    pos = 0;\n    do {\n        if (node->schema == schema) {\n            ++pos;\n        }\n        node = node->prev;\n    } while (node->next);\n\n    return pos;\n}\n\nstruct lyd_node *\nlyd_new_dummy(struct lyd_node *root, struct lyd_node *parent, const struct lys_node *schema, const char *value, int dflt)\n{\n    unsigned int index;\n    struct ly_set *spath;\n    const struct lys_node *siter;\n    struct lyd_node *iter, *dummy = NULL;\n\n    assert(schema);\n    assert(schema->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_ANYDATA | LYS_NOTIF |\n                               LYS_RPC | LYS_ACTION));\n\n    spath = ly_set_new();\n    if (!spath) {\n        LOGMEM(schema->module->ctx);\n        return NULL;\n    }\n\n    if (!parent && root) {\n        /* find data root */\n        for (; root->parent; root = root->parent);   /* vertical move (up) */\n        for (; root->prev->next; root = root->prev); /* horizontal move (left) */\n    }\n\n    /* build schema path */\n    for (siter = schema; siter; siter = lys_parent(siter)) {\n        /* stop if we know some of the parents */\n        if (parent && parent->schema == siter) {\n            break;\n        }\n\n        if (siter->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_ANYDATA | LYS_NOTIF |\n                               LYS_RPC | LYS_ACTION)) {\n            /* we have a node that can appear in data tree */\n            ly_set_add(spath, (void*)siter, LY_SET_OPT_USEASLIST);\n        } /* else skip the rest node types */\n    }\n\n    assert(spath->number > 0);\n    index = spath->number;\n    if (!parent && !(spath->set.s[index - 1]->nodetype & LYS_LEAFLIST)) {\n        /* start by searching for the top-level parent */\n        LY_TREE_FOR(root, iter) {\n            if (iter->schema == spath->set.s[index - 1]) {\n                parent = iter;\n                index--;\n                break;\n            }\n        }\n    }\n\n    iter = parent;\n    while (iter && index && !(spath->set.s[index - 1]->nodetype & LYS_LEAFLIST)) {\n        /* search for closer parent on the path */\n        LY_TREE_FOR(parent->child, iter) {\n            if (iter->schema == spath->set.s[index - 1]) {\n                index--;\n                parent = iter;\n                break;\n            }\n        }\n    }\n    while(index) {\n        /* create the missing part of the path */\n        switch (spath->set.s[index - 1]->nodetype) {\n        case LYS_LEAF:\n        case LYS_LEAFLIST:\n            if (value) {\n                iter = _lyd_new_leaf(parent, spath->set.s[index - 1], value, dflt, 0);\n            } else {\n                iter = lyd_create_leaf(spath->set.s[index - 1], value, dflt);\n                if (iter && parent) {\n                    if (lyd_insert(parent, iter)) {\n                        lyd_free(iter);\n                        goto error;\n                    }\n                }\n            }\n            break;\n        case LYS_CONTAINER:\n        case LYS_LIST:\n            iter = _lyd_new(parent, spath->set.s[index - 1], dflt);\n            break;\n        case LYS_ANYXML:\n        case LYS_ANYDATA:\n            iter = lyd_create_anydata(parent, spath->set.s[index - 1], \"\", LYD_ANYDATA_CONSTSTRING);\n            break;\n        default:\n            goto error;\n        }\n        if (!iter) {\n            LOGINT(schema->module->ctx);\n            goto error;\n        }\n\n        /* we say it is valid and it is dummy */\n        iter->validity = LYD_VAL_INUSE;\n\n        if (!dummy) {\n            dummy = iter;\n        }\n\n        /* continue */\n        parent = iter;\n        index--;\n    }\n\n    ly_set_free(spath);\n\n    return dummy;\n\nerror:\n    ly_set_free(spath);\n    lyd_free(dummy);\n    return NULL;\n}\n\nstatic struct lys_node *\nlys_get_schema_inctx(struct lys_node *schema, struct ly_ctx *ctx)\n{\n    const struct lys_module *mod, *trg_mod = NULL;\n    struct lys_node *parent, *first_sibling = NULL, *iter = NULL;\n    struct ly_set *parents;\n    unsigned int index;\n    uint32_t idx;\n    void **ptr;\n\n    if (!ctx || schema->module->ctx == ctx) {\n        /* we have the same context */\n        return schema;\n    }\n\n    /* store the parents chain */\n    parents = ly_set_new();\n    for (parent = schema; parent; parent = lys_parent(parent)) {\n        /* note - augments are skipped so we will work only with the implemented modules\n         * (where the augments are applied) */\n        if (parent->nodetype != LYS_USES) {\n            ly_set_add(parents, parent, LY_SET_OPT_USEASLIST);\n        }\n    }\n    assert(parents->number);\n    index = parents->number - 1;\n\n    /* process the parents from the top level */\n    /* for the top-level node, we have to locate the module first */\n    parent = parents->set.s[index];\n    if (parent->nodetype == LYS_EXT) {\n        ptr = lys_ext_complex_get_substmt(LY_STMT_NODE, (struct lys_ext_instance_complex *)parent, NULL);\n        if (!ptr) {\n            ly_set_free(parents);\n            return NULL;\n        }\n        first_sibling = *(struct lys_node **)ptr;\n        parent = parents->set.s[--index];\n    }\n    idx = 0;\n    while ((mod = ly_ctx_get_module_iter(ctx, &idx))) {\n        trg_mod = lys_node_module(parent);\n        /* check module name */\n        if (strcmp(mod->name, trg_mod->name)) {\n            continue;\n        }\n\n        /* check revision */\n        if ((!mod->rev_size && !trg_mod->rev_size) ||\n                (mod->rev_size && trg_mod->rev_size && !strcmp(mod->rev[0].date, trg_mod->rev[0].date))) {\n            /* we have match */\n            break;\n        }\n    }\n    /* try data callback */\n    if (!mod && trg_mod && ctx->data_clb) {\n        LOGDBG(LY_LDGYANG, \"Attempting to load '%s' into context using callback ...\", trg_mod->name);\n        mod = ctx->data_clb(ctx, trg_mod->name, NULL, 0, ctx->data_clb_data);\n    }\n    if (!mod) {\n        ly_set_free(parents);\n        return NULL;\n    }\n    if (!first_sibling) {\n        first_sibling = mod->data;\n    }\n\n    /* now search in the schema tree for the matching node */\n    while (1) {\n        lys_get_sibling(first_sibling, trg_mod->name, 0, parent->name, 0, parent->nodetype,\n                        (const struct lys_node **)&iter);\n        if (!iter) {\n            /* not found, iter will be used as NULL result */\n            break;\n        }\n\n        if (index == 0) {\n            /* we are done, iter is the result */\n            break;\n        } else {\n            /* we are going to continue, so update variables for the next loop */\n            first_sibling = iter->child;\n            parent = parents->set.s[--index];\n            iter = NULL;\n        }\n    }\n\n    ly_set_free(parents);\n    return iter;\n}\n\nstatic struct lys_node *\nlyd_get_schema_inctx(const struct lyd_node *node, struct ly_ctx *ctx)\n{\n    assert(node);\n\n    return lys_get_schema_inctx(node->schema, ctx);\n}\n\n/* both target and source were validated */\nstatic void\nlyd_merge_node_update(struct lyd_node *target, struct lyd_node *source)\n{\n    struct ly_ctx *ctx;\n    struct lyd_node_leaf_list *trg_leaf, *src_leaf;\n    struct lyd_node_anydata *trg_any, *src_any;\n    int len;\n\n    assert(target->schema->nodetype & (LYS_LEAF | LYS_ANYDATA));\n    ctx = target->schema->module->ctx;\n\n    if (ctx == source->schema->module->ctx) {\n        /* source and targets are in the same context */\n        if (target->schema->nodetype == LYS_LEAF) {\n            trg_leaf = (struct lyd_node_leaf_list *)target;\n            src_leaf = (struct lyd_node_leaf_list *)source;\n\n            lydict_remove(ctx, trg_leaf->value_str);\n            trg_leaf->value_str = src_leaf->value_str;\n            src_leaf->value_str = NULL;\n            trg_leaf->value_type = src_leaf->value_type;\n            src_leaf->value_type = 0;\n            if (trg_leaf->value_type == LY_TYPE_LEAFREF) {\n                trg_leaf->validity |= LYD_VAL_LEAFREF;\n                lyp_parse_value(&((struct lys_node_leaf *)trg_leaf->schema)->type, &trg_leaf->value_str,\n                                NULL, trg_leaf, NULL, NULL, 1, src_leaf->dflt, 0);\n            } else {\n                lyd_free_value(trg_leaf->value, trg_leaf->value_type, trg_leaf->value_flags,\n                               &((struct lys_node_leaf *)trg_leaf->schema)->type, NULL, NULL, NULL);\n                trg_leaf->value = src_leaf->value;\n            }\n            src_leaf->value = (lyd_val)0;\n            trg_leaf->dflt = src_leaf->dflt;\n\n            check_leaf_list_backlinks(target, 2);\n        } else { /* ANYDATA */\n            trg_any = (struct lyd_node_anydata *)target;\n            src_any = (struct lyd_node_anydata *)source;\n\n            switch(trg_any->value_type) {\n            case LYD_ANYDATA_CONSTSTRING:\n            case LYD_ANYDATA_SXML:\n            case LYD_ANYDATA_JSON:\n                lydict_remove(ctx, trg_any->value.str);\n                break;\n            case LYD_ANYDATA_DATATREE:\n                lyd_free_withsiblings(trg_any->value.tree);\n                break;\n            case LYD_ANYDATA_XML:\n                lyxml_free_withsiblings(ctx, trg_any->value.xml);\n                break;\n            case LYD_ANYDATA_LYB:\n                free(trg_any->value.mem);\n                break;\n            case LYD_ANYDATA_STRING:\n            case LYD_ANYDATA_SXMLD:\n            case LYD_ANYDATA_JSOND:\n            case LYD_ANYDATA_LYBD:\n                /* dynamic strings are used only as input parameters */\n                assert(0);\n                break;\n            }\n\n            trg_any->value_type = src_any->value_type;\n            trg_any->value = src_any->value;\n\n            src_any->value_type = LYD_ANYDATA_DATATREE;\n            src_any->value.tree = NULL;\n        }\n    } else {\n        /* we have different contexts for the target and source */\n        if (target->schema->nodetype == LYS_LEAF) {\n            trg_leaf = (struct lyd_node_leaf_list *)target;\n            src_leaf = (struct lyd_node_leaf_list *)source;\n\n            lydict_remove(ctx, trg_leaf->value_str);\n            trg_leaf->value_str = lydict_insert(ctx, src_leaf->value_str, 0);\n            lyd_free_value(trg_leaf->value, trg_leaf->value_type, trg_leaf->value_flags,\n                           &((struct lys_node_leaf *)trg_leaf->schema)->type, NULL, NULL, NULL);\n            trg_leaf->value_type = src_leaf->value_type;\n            trg_leaf->dflt = src_leaf->dflt;\n\n            switch (trg_leaf->value_type) {\n            case LY_TYPE_BINARY:\n            case LY_TYPE_STRING:\n                /* value_str pointer is shared in these cases */\n                trg_leaf->value.string = trg_leaf->value_str;\n                break;\n            case LY_TYPE_LEAFREF:\n                trg_leaf->validity |= LYD_VAL_LEAFREF;\n                lyp_parse_value(&((struct lys_node_leaf *)trg_leaf->schema)->type, &trg_leaf->value_str,\n                                NULL, trg_leaf, NULL, NULL, 1, trg_leaf->dflt, 0);\n                break;\n            case LY_TYPE_INST:\n                trg_leaf->value.instance = NULL;\n                break;\n            case LY_TYPE_UNION:\n                /* unresolved union (this must be non-validated tree), duplicate the stored string (duplicated\n                 * because of possible change of the value in case of instance-identifier) */\n                trg_leaf->value.string = lydict_insert(ctx, src_leaf->value.string, 0);\n                break;\n            case LY_TYPE_BITS:\n            case LY_TYPE_ENUM:\n            case LY_TYPE_IDENT:\n                /* in case of duplicating bits (no matter if in the same context or not) or enum and identityref into\n                 * a different context, searching for the type and duplicating the data is almost as same as resolving\n                 * the string value, so due to a simplicity, parse the value for the duplicated leaf */\n                lyp_parse_value(&((struct lys_node_leaf *)trg_leaf->schema)->type, &trg_leaf->value_str, NULL,\n                                trg_leaf, NULL, NULL, 1, trg_leaf->dflt, 1);\n                break;\n            default:\n                trg_leaf->value = src_leaf->value;\n                break;\n            }\n\n            check_leaf_list_backlinks(target, 2);\n        } else { /* ANYDATA */\n            trg_any = (struct lyd_node_anydata *)target;\n            src_any = (struct lyd_node_anydata *)source;\n\n            switch(trg_any->value_type) {\n            case LYD_ANYDATA_CONSTSTRING:\n            case LYD_ANYDATA_SXML:\n            case LYD_ANYDATA_JSON:\n                lydict_remove(ctx, trg_any->value.str);\n                break;\n            case LYD_ANYDATA_DATATREE:\n                lyd_free_withsiblings(trg_any->value.tree);\n                break;\n            case LYD_ANYDATA_XML:\n                lyxml_free_withsiblings(ctx, trg_any->value.xml);\n                break;\n            case LYD_ANYDATA_LYB:\n                free(trg_any->value.mem);\n                break;\n            case LYD_ANYDATA_STRING:\n            case LYD_ANYDATA_SXMLD:\n            case LYD_ANYDATA_JSOND:\n            case LYD_ANYDATA_LYBD:\n                /* dynamic strings are used only as input parameters */\n                assert(0);\n                break;\n            }\n\n            trg_any->value_type = src_any->value_type;\n            if ((void*)src_any->value.tree) {\n                /* there is a value to duplicate */\n                switch (trg_any->value_type) {\n                case LYD_ANYDATA_CONSTSTRING:\n                case LYD_ANYDATA_SXML:\n                case LYD_ANYDATA_JSON:\n                    trg_any->value.str = lydict_insert(ctx, src_any->value.str, 0);\n                    break;\n                case LYD_ANYDATA_DATATREE:\n                    trg_any->value.tree = lyd_dup_to_ctx(src_any->value.tree, 1, ctx);\n                    break;\n                case LYD_ANYDATA_XML:\n                    trg_any->value.xml = lyxml_dup_elem(ctx, src_any->value.xml, NULL, 1);\n                    break;\n                case LYD_ANYDATA_LYB:\n                    len = lyd_lyb_data_length(src_any->value.mem);\n                    if (len == -1) {\n                        LOGERR(ctx, LY_EINVAL, \"Invalid LYB data.\");\n                        return;\n                    }\n                    trg_any->value.mem = malloc(len);\n                    LY_CHECK_ERR_RETURN(!trg_any->value.mem, LOGMEM(ctx), );\n                    memcpy(trg_any->value.mem, src_any->value.mem, len);\n                    break;\n                case LYD_ANYDATA_STRING:\n                case LYD_ANYDATA_SXMLD:\n                case LYD_ANYDATA_JSOND:\n                case LYD_ANYDATA_LYBD:\n                    /* dynamic strings are used only as input parameters */\n                    assert(0);\n                    break;\n                }\n            }\n        }\n    }\n}\n\n/* return: 0 (not equal), 1 (equal), -1 (error) */\nstatic int\nlyd_merge_node_schema_equal(struct lyd_node *node1, struct lyd_node *node2)\n{\n    struct lys_node *sch1;\n\n    if (node1->schema->module->ctx == node2->schema->module->ctx) {\n        if (node1->schema != node2->schema) {\n            return 0;\n        }\n    } else {\n        /* the nodes are in different contexts, get the appropriate schema nodes from the\n         * same context */\n        sch1 = lyd_get_schema_inctx(node1, node2->schema->module->ctx);\n        if (!sch1) {\n            LOGERR(node2->schema->module->ctx, LY_EINVAL, \"Target context does not contain a required schema node (%s:%s).\",\n                   lyd_node_module(node1)->name, node1->schema->name);\n            return -1;\n        } else if (sch1 != node2->schema) {\n            /* not matching nodes */\n            return 0;\n        }\n    }\n\n    return 1;\n}\n\n/* return: 0 (not equal), 1 (equal), 2 (equal and state leaf-/list marked), -1 (error) */\nstatic int\nlyd_merge_node_equal(struct lyd_node *node1, struct lyd_node *node2)\n{\n    int ret;\n\n    switch (node1->schema->nodetype) {\n    case LYS_CONTAINER:\n    case LYS_LEAF:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n    case LYS_RPC:\n    case LYS_ACTION:\n    case LYS_NOTIF:\n        return 1;\n    case LYS_LEAFLIST:\n        if (node1->validity & LYD_VAL_INUSE) {\n            /* this instance was already matched, we want to find another so that the number of the istances matches */\n            assert(node1->schema->flags & LYS_CONFIG_R);\n            return 0;\n        }\n\n        ret = lyd_list_equal(node1, node2, 1);\n        if ((ret == 1) && (node1->schema->flags & LYS_CONFIG_R)) {\n            /* mark it as matched */\n            node1->validity |= LYD_VAL_INUSE;\n            ret = 2;\n        }\n        return ret;\n    case LYS_LIST:\n        if (node1->validity & LYD_VAL_INUSE) {\n            /* this instance was already matched, we want to find another so that the number of the istances matches */\n            assert(!((struct lys_node_list *)node1->schema)->keys_size);\n            return 0;\n        }\n\n        ret = lyd_list_equal(node1, node2, 1);\n        if ((ret == 1) && !((struct lys_node_list *)node1->schema)->keys_size) {\n            /* mark it as matched */\n            node1->validity |= LYD_VAL_INUSE;\n            ret = 2;\n        }\n        return ret;\n    default:\n        break;\n    }\n\n    LOGINT(node2->schema->module->ctx);\n    return -1;\n}\n\n/* spends source */\nstatic int\nlyd_merge_parent_children(struct lyd_node *target, struct lyd_node *source, int options)\n{\n    struct lyd_node *trg_parent, *src, *src_backup, *src_elem, *src_elem_backup, *src_next, *trg_child, *trg_parent_backup;\n    int ret, clear_flag = 0;\n    struct ly_ctx *ctx = target->schema->module->ctx; /* shortcut */\n\n    LY_TREE_FOR_SAFE(source, src_backup, src) {\n        for (src_elem = src_next = src, trg_parent = target;\n            src_elem;\n            src_elem = src_next) {\n\n            /* it won't get inserted in this case */\n            if (src_elem->dflt && (options & LYD_OPT_EXPLICIT)) {\n                if (src_elem == src) {\n                    /* we are done with this subtree in this case */\n                    break;\n                }\n                trg_child = (struct lyd_node *)1;\n                goto src_skip;\n            }\n\n            ret = 0;\n\n#ifdef LY_ENABLED_CACHE\n            struct lyd_node **trg_child_p;\n\n            /* trees are supposed to be validated so all nodes must have their hash, but lets not be that strict */\n            if (!src_elem->hash) {\n                lyd_hash(src_elem);\n            }\n\n            if (trg_parent->ht) {\n                trg_child = NULL;\n                if (!lyht_find(trg_parent->ht, &src_elem, src_elem->hash, (void **)&trg_child_p)) {\n                    trg_child = *trg_child_p;\n                    ret = 1;\n\n                    /* it is a bit more difficult with keyless state lists and leaf-lists */\n                    if (((trg_child->schema->nodetype == LYS_LIST) && !((struct lys_node_list *)trg_child->schema)->keys_size)\n                            || ((trg_child->schema->nodetype == LYS_LEAFLIST) && (trg_child->schema->flags & LYS_CONFIG_R))) {\n                        assert(trg_child->schema->flags & LYS_CONFIG_R);\n\n                        while (trg_child && (trg_child->validity & LYD_VAL_INUSE)) {\n                            /* state lists, find one not-already-found */\n                            if (lyht_find_next(trg_parent->ht, &trg_child, trg_child->hash, (void **)&trg_child_p)) {\n                                trg_child = NULL;\n                            } else {\n                                trg_child = *trg_child_p;\n                            }\n                        }\n                        if (trg_child) {\n                            /* mark it as matched */\n                            trg_child->validity |= LYD_VAL_INUSE;\n                            ret = 2;\n                        } else {\n                            /* actually, it was matched already and no other instance found, so now not a match */\n                            ret = 0;\n                        }\n                    }\n                }\n            } else\n#endif\n            {\n                LY_TREE_FOR(trg_parent->child, trg_child) {\n                    /* schema match, data match? */\n                    ret = lyd_merge_node_schema_equal(trg_child, src_elem);\n                    if (ret == 1) {\n                        ret = lyd_merge_node_equal(trg_child, src_elem);\n                    }\n                    if (ret != 0) {\n                        /* even data match */\n                        break;\n                    }\n                }\n            }\n\n            if (ret > 0) {\n                if (trg_child->schema->nodetype & (LYS_LEAF | LYS_ANYDATA)) {\n                    lyd_merge_node_update(trg_child, src_elem);\n                } else if (ret == 2) {\n                    clear_flag = 1;\n                }\n            } else if (ret == -1) {\n                /* error */\n                lyd_free_withsiblings(source);\n                return 1;\n            }\n\n            /* first prepare for the next iteration */\n            src_elem_backup = src_elem;\n            trg_parent_backup = trg_parent;\n            if (((src_elem->schema->nodetype == LYS_CONTAINER) || ((src_elem->schema->nodetype == LYS_LIST)\n                    && ((struct lys_node_list *)src_elem->schema)->keys_size)) && src_elem->child && trg_child) {\n                /* go into children */\n                src_next = src_elem->child;\n                trg_parent = trg_child;\n            } else {\nsrc_skip:\n                /* no children (or the whole subtree will be inserted), try siblings */\n                if (src_elem == src) {\n                    /* we are done with this subtree */\n                    if (trg_child) {\n                        /* it's an empty container, list without keys, or an already-updated leaf/anydata, nothing else to do */\n                        break;\n                    } else {\n                        /* ... but we still need to insert it */\n                        src_next = NULL;\n                        goto src_insert;\n                    }\n                } else {\n                    src_next = src_elem->next;\n                    /* trg_parent does not change */\n                }\n            }\n            while (!src_next) {\n                src_elem = src_elem->parent;\n                if (src_elem->parent == src->parent) {\n                    /* we are done, no next element to process */\n                    break;\n                }\n\n                /* parent is already processed, go to its sibling */\n                src_next = src_elem->next;\n                trg_parent = trg_parent->parent;\n            }\n\n            if (!trg_child) {\nsrc_insert:\n                /* we need to insert the whole subtree */\n                if (ctx == src_elem_backup->schema->module->ctx) {\n                    /* same context - unlink the subtree and insert it into the target */\n                    lyd_unlink(src_elem_backup);\n                } else {\n                    /* different contexts - before inserting subtree, instead of unlinking, duplicate it into the\n                     * target context */\n                    src_elem_backup = lyd_dup_to_ctx(src_elem_backup, 1, ctx);\n                }\n\n                if (src_elem == source) {\n                    /* it will be linked into another data tree and the pointers changed */\n                    source = source->next;\n                }\n\n                /* insert subtree into the target */\n                if (lyd_insert(trg_parent_backup, src_elem_backup)) {\n                    LOGINT(ctx);\n                    lyd_free_withsiblings(source);\n                    return 1;\n                }\n                if (src_elem == src) {\n                    /* we are finished for this src */\n                    break;\n                }\n            }\n        }\n    }\n\n    lyd_free_withsiblings(source);\n    if (clear_flag) {\n        return 2;\n    }\n    return 0;\n}\n\n/* spends source */\nstatic int\nlyd_merge_siblings(struct lyd_node *target, struct lyd_node *source, int options)\n{\n    struct lyd_node *trg, *src, *src_backup, *ins;\n    int ret, clear_flag = 0;\n    struct ly_ctx *ctx = target->schema->module->ctx; /* shortcut */\n\n    while (target->prev->next) {\n        target = target->prev;\n    }\n\n    LY_TREE_FOR_SAFE(source, src_backup, src) {\n        LY_TREE_FOR(target, trg) {\n            /* sibling found, merge it */\n            ret = lyd_merge_node_schema_equal(trg, src);\n            if (ret == 1) {\n                ret = lyd_merge_node_equal(trg, src);\n            }\n            if (ret > 0) {\n                if (ret == 2) {\n                    clear_flag = 1;\n                }\n\n                switch (trg->schema->nodetype) {\n                case LYS_LEAF:\n                case LYS_ANYXML:\n                case LYS_ANYDATA:\n                    lyd_merge_node_update(trg, src);\n                    break;\n                case LYS_LEAFLIST:\n                    /* it's already there, nothing to do */\n                    break;\n                case LYS_LIST:\n                case LYS_CONTAINER:\n                case LYS_NOTIF:\n                case LYS_RPC:\n                case LYS_INPUT:\n                case LYS_OUTPUT:\n                    ret = lyd_merge_parent_children(trg, src->child, options);\n                    if (ret == 2) {\n                        clear_flag = 1;\n                    } else if (ret) {\n                        lyd_free_withsiblings(source);\n                        return 1;\n                    }\n                    break;\n                default:\n                    LOGINT(ctx);\n                    lyd_free_withsiblings(source);\n                    return 1;\n                }\n                break;\n            } else if (ret == -1) {\n                lyd_free_withsiblings(source);\n                return 1;\n            } /* else not equal, nothing to do */\n        }\n\n        /* sibling not found, insert it */\n        if (!trg) {\n            if (ctx != src->schema->module->ctx) {\n                ins = lyd_dup_to_ctx(src, 1, ctx);\n            } else {\n                lyd_unlink(src);\n                if (src == source) {\n                    /* just so source is not freed, we inserted it and need it further */\n                    source = src_backup;\n                }\n                ins = src;\n            }\n            lyd_insert_after(target->prev, ins);\n        }\n    }\n\n    lyd_free_withsiblings(source);\n    if (clear_flag) {\n        return 2;\n    }\n    return 0;\n}\n\nAPI int\nlyd_merge_to_ctx(struct lyd_node **trg, const struct lyd_node *src, int options, struct ly_ctx *ctx)\n{\n    struct lyd_node *node = NULL, *node2, *target, *trg_merge_start, *src_merge_start = NULL;\n    const struct lyd_node *iter;\n    struct lys_node *src_snode, *sch = NULL;\n    int i, src_depth, depth, first_iter, ret, dflt = 1;\n    const struct lys_node *parent = NULL;\n\n    if (!trg || !(*trg) || !src) {\n        LOGARG;\n        return -1;\n    }\n    target = *trg;\n\n    parent = lys_parent(target->schema);\n\n    /* go up all uses */\n    while (parent && (parent->nodetype == LYS_USES)) {\n        parent = lys_parent(parent);\n    }\n\n    if (parent && !lyp_get_yang_data_template_name(target)) {\n        LOGERR(parent->module->ctx, LY_EINVAL, \"Target not a top-level data tree.\");\n        return -1;\n    }\n\n    /* get know if we are converting data into a different context */\n    if (ctx && target->schema->module->ctx != ctx) {\n        /* target's data tree context differs from the target context, move the target\n         * data tree into the target context */\n\n        /* get the first target's top-level and store it as the result */\n        for (; target->prev->next; target = target->prev);\n        *trg = target;\n\n        for (node = NULL, trg_merge_start = target; target; target = target->next) {\n            node2 = lyd_dup_to_ctx(target, 1, ctx);\n            if (!node2) {\n                goto error;\n            }\n            if (node) {\n                if (lyd_insert_after(node->prev, node2)) {\n                    goto error;\n                }\n            } else {\n                node = node2;\n            }\n        }\n        target = node;\n        node = NULL;\n    } else if (src->schema->module->ctx != target->schema->module->ctx) {\n        /* the source data will be converted into the target's context during the merge */\n        ctx = target->schema->module->ctx;\n    } else if (ctx == src->schema->module->ctx) {\n        /* no conversion is needed */\n        ctx = NULL;\n    }\n\n    /* find source top-level schema node */\n    for (src_snode = src->schema, src_depth = 0;\n         (src_snode = lys_parent(src_snode)) && src_snode->nodetype != LYS_EXT;\n         ++src_depth);\n\n    /* find first shared missing schema parent of the subtrees */\n    trg_merge_start = target;\n    depth = 0;\n    first_iter = 1;\n    if (src_depth) {\n        /* we are going to create missing parents in the following loop,\n         * but we will need to know a dflt flag for them. In case the newly\n         * created parent is going to have at least one non-default child,\n         * it will be also non-default, otherwise it will be the default node */\n        if (options & LYD_OPT_NOSIBLINGS) {\n            dflt = src->dflt;\n        } else {\n            LY_TREE_FOR(src, iter) {\n                if (!iter->dflt) {\n                    /* non default sibling -> parent is going to be\n                     * created also as non-default */\n                    dflt = 0;\n                    break;\n                }\n            }\n        }\n    }\n    while (1) {\n        /* going from down (source root) to up (top-level or the common node with target */\n        do {\n            for (src_snode = src->schema, i = 0; i < src_depth - depth; src_snode = lys_parent(src_snode), ++i);\n            ++depth;\n        } while (src_snode != src->schema && (src_snode->nodetype & (LYS_CHOICE | LYS_CASE | LYS_USES)));\n\n        if (src_snode == src->schema) {\n            break;\n        }\n\n        if (src_snode->nodetype != LYS_CONTAINER) {\n            /* we would have to create a list (the only data node with children except container), impossible */\n            LOGERR(ctx, LY_EINVAL, \"Cannot create %s \\\"%s\\\" for the merge.\", strnodetype(src_snode->nodetype), src_snode->name);\n            goto error;\n        }\n\n        /* have we created any missing containers already? if we did,\n         * it is totally useless to search for match, there won't ever be */\n        if (!src_merge_start) {\n            if (first_iter) {\n                node = trg_merge_start;\n                first_iter = 0;\n            } else {\n                node = trg_merge_start->child;\n            }\n\n            /* find it in target data nodes */\n            LY_TREE_FOR(node, node) {\n                if (ctx) {\n                    /* we have the schema nodes in the different context */\n                    sch = lys_get_schema_inctx(src_snode, ctx);\n                    if (!sch) {\n                        LOGERR(ctx, LY_EINVAL, \"Target context does not contain schema node for the data node being \"\n                               \"merged (%s:%s).\", lys_node_module(src_snode)->name, src_snode->name);\n                        goto error;\n                    }\n                } else {\n                    /* the context is same and comparison of the schema nodes will works fine */\n                    sch = src_snode;\n                }\n\n                if (node->schema == sch) {\n                    trg_merge_start = node;\n                    break;\n                }\n            }\n\n            if (!(options & LYD_OPT_DESTRUCT)) {\n                /* the source tree will be duplicated, so to save some work in case\n                 * of different target context, create also the parents nodes in the\n                 * correct context */\n                src_snode = sch;\n            }\n        } else if (ctx && !(options & LYD_OPT_DESTRUCT)) {\n            /* get the schema node in the correct (target) context, same as above,\n             * this is done to save some work and have the source in the same context\n             * when the provided source tree is below duplicated in the target context\n             * and connected into the parents created here */\n            src_snode = lys_get_schema_inctx(src_snode, ctx);\n            if (!src_snode) {\n                LOGERR(ctx, LY_EINVAL, \"Target context does not contain schema node for the data node being \"\n                       \"merged (%s:%s).\", lys_node_module(src_snode)->name, src_snode->name);\n                goto error;\n            }\n        }\n\n        if (!node) {\n            /* it is not there, create it */\n            node2 = _lyd_new(NULL, src_snode, dflt);\n            if (!src_merge_start) {\n                src_merge_start = node2;\n            } else {\n                if (lyd_insert(node2, src_merge_start)) {\n                    goto error;\n                }\n                src_merge_start = node2;\n            }\n        }\n    }\n\n    /* process source according to options */\n    if (options & LYD_OPT_DESTRUCT) {\n        LY_TREE_FOR(src, iter) {\n            check_leaf_list_backlinks((struct lyd_node *)iter, 2);\n            if (options & LYD_OPT_NOSIBLINGS) {\n                break;\n            }\n        }\n\n        node = (struct lyd_node *)src;\n        if ((node->prev != node) && (options & LYD_OPT_NOSIBLINGS)) {\n            node2 = node->prev;\n            lyd_unlink(node);\n            lyd_free_withsiblings(node2);\n        }\n    } else {\n        node = NULL;\n        for (; src; src = src->next) {\n            /* because we already have to duplicate it, do it in the correct context */\n            node2 = lyd_dup_to_ctx(src, 1, ctx);\n            if (!node2) {\n                lyd_free_withsiblings(node);\n                goto error;\n            }\n            if (node) {\n                if (lyd_insert_after(node->prev, node2)) {\n                    lyd_free_withsiblings(node);\n                    goto error;\n                }\n            } else {\n                node = node2;\n            }\n\n            if (options & LYD_OPT_NOSIBLINGS) {\n                break;\n            }\n        }\n    }\n\n    if (src_merge_start) {\n        /* insert data into the created parents */\n        /* first, get the lowest created parent, we don't have to check the nodetype since we are\n         * creating only a simple chain of containers */\n        for (node2 = src_merge_start; node2->child; node2 = node2->child);\n        node2->child = node;\n        LY_TREE_FOR(node, node) {\n            node->parent = node2;\n        }\n    } else {\n        src_merge_start = node;\n    }\n\n    if (!first_iter) {\n        /* !! src_merge start is a child(ren) of trg_merge_start */\n        ret = lyd_merge_parent_children(trg_merge_start, src_merge_start, options);\n    } else {\n        /* !! src_merge start is a (top-level) sibling(s) of trg_merge_start */\n        ret = lyd_merge_siblings(trg_merge_start, src_merge_start, options);\n    }\n    /* it was freed whatever the return value */\n    src_merge_start = NULL;\n    if (ret == 2) {\n        /* clear remporary LYD_VAL_INUSE validation flags */\n        LY_TREE_DFS_BEGIN(target, node2, node) {\n            node->validity &= ~LYD_VAL_INUSE;\n            LY_TREE_DFS_END(target, node2, node);\n        }\n        ret = 0;\n    } else if (ret) {\n        goto error;\n    }\n\n    if (target->schema->nodetype == LYS_RPC) {\n        lyd_schema_sort(target, 1);\n    }\n\n    /* update the pointer to the target tree if needed */\n    if (*trg != target) {\n        lyd_free_withsiblings(*trg);\n        (*trg) = target;\n    }\n    return ret;\n\nerror:\n    if (*trg != target) {\n        /* target is duplication of the original target in different context,\n         * free it due to the error */\n        lyd_free_withsiblings(target);\n    }\n    lyd_free_withsiblings(src_merge_start);\n    return -1;\n}\n\nAPI int\nlyd_merge(struct lyd_node *target, const struct lyd_node *source, int options)\n{\n    if (!target || !source) {\n        LOGARG;\n        return -1;\n    }\n\n    return lyd_merge_to_ctx(&target, source, options, target->schema->module->ctx);\n}\n\nAPI void\nlyd_free_diff(struct lyd_difflist *diff)\n{\n    if (diff) {\n        free(diff->type);\n        free(diff->first);\n        free(diff->second);\n        free(diff);\n    }\n}\n\nstatic int\nlyd_difflist_add(struct lyd_difflist *diff, unsigned int *size, unsigned int index,\n                 LYD_DIFFTYPE type, struct lyd_node *first, struct lyd_node *second)\n{\n    void *new;\n    struct ly_ctx *ctx = (first ? first->schema->module->ctx : second->schema->module->ctx);\n\n    assert(diff);\n    assert(size && *size);\n\n    if (index + 1 == *size) {\n        /* it's time to enlarge */\n        *size = *size + 16;\n        new = realloc(diff->type, *size * sizeof *diff->type);\n        LY_CHECK_ERR_RETURN(!new, LOGMEM(ctx), EXIT_FAILURE);\n        diff->type = new;\n\n        new = realloc(diff->first, *size * sizeof *diff->first);\n        LY_CHECK_ERR_RETURN(!new, LOGMEM(ctx), EXIT_FAILURE);\n        diff->first = new;\n\n        new = realloc(diff->second, *size * sizeof *diff->second);\n        LY_CHECK_ERR_RETURN(!new, LOGMEM(ctx), EXIT_FAILURE);\n        diff->second = new;\n    }\n\n    /* insert the item */\n    diff->type[index] = type;\n    diff->first[index] = first;\n    diff->second[index] = second;\n\n    /* terminate the arrays */\n    index++;\n    diff->type[index] = LYD_DIFF_END;\n    diff->first[index] = NULL;\n    diff->second[index] = NULL;\n\n    return EXIT_SUCCESS;\n}\n\nstruct diff_ordered_dist {\n    struct diff_ordered_dist *next;\n    int dist;\n};\nstruct diff_ordered_item {\n    struct lyd_node *first;\n    struct lyd_node *second;\n    struct diff_ordered_dist *dist;\n};\nstruct diff_ordered {\n    struct lys_node *schema;\n    struct lyd_node *parent;\n    unsigned int count;\n    struct diff_ordered_item *items; /* array */\n    struct diff_ordered_dist *dist;  /* linked list (1-way, ring) */\n    struct diff_ordered_dist *dist_last;  /* aux pointer for faster insertion sort */\n};\n\nstatic int\ndiff_ordset_insert(struct lyd_node *node, struct ly_set *ordset)\n{\n    unsigned int i;\n    struct diff_ordered *new_ordered, *iter;\n\n    for (i = 0; i < ordset->number; i++) {\n        iter = (struct diff_ordered *)ordset->set.g[i];\n        if (iter->schema == node->schema && iter->parent == node->parent) {\n            break;\n        }\n    }\n    if (i == ordset->number) {\n        /* not seen user-ordered list */\n        new_ordered = calloc(1, sizeof *new_ordered);\n        LY_CHECK_ERR_RETURN(!new_ordered, LOGMEM(node->schema->module->ctx), EXIT_FAILURE);\n        new_ordered->schema = node->schema;\n        new_ordered->parent = node->parent;\n\n        ly_set_add(ordset, new_ordered, LY_SET_OPT_USEASLIST);\n    }\n    ((struct diff_ordered *)ordset->set.g[i])->count++;\n\n    return EXIT_SUCCESS;\n}\n\nstatic void\ndiff_ordset_free(struct ly_set *set)\n{\n    unsigned int i, j;\n    struct diff_ordered *ord;\n\n    if (!set) {\n        return;\n    }\n\n    for (i = 0; i < set->number; i++) {\n        ord = (struct diff_ordered *)set->set.g[i];\n        for (j = 0; j < ord->count; j++) {\n            free(ord->items[j].dist);\n        }\n        free(ord->items);\n        free(ord);\n    }\n\n    ly_set_free(set);\n}\n\n/*\n * -1 - error\n *  0 - ok\n *  1 - first and second not the same\n */\nstatic int\nlyd_diff_compare(struct lyd_node *first, struct lyd_node *second, int options)\n{\n    int rc;\n\n    if (first->dflt && !(options & LYD_DIFFOPT_WITHDEFAULTS)) {\n        /* the second one cannot be default (see lyd_diff()),\n         * so the nodes differs (first one is default node) */\n        return 1;\n    }\n\n    if (first->schema->nodetype & (LYS_LEAFLIST | LYS_LIST)) {\n        if (first->validity & LYD_VAL_INUSE) {\n            /* this node was already matched, it cannot be matched twice (except for state leaf-/lists,\n             * which we want to keep the count on this way) */\n            return 1;\n        }\n\n        rc = lyd_list_equal(first, second, (options & LYD_DIFFOPT_WITHDEFAULTS ? 1 : 0));\n        if (rc == -1) {\n            return -1;\n        } else if (!rc) {\n            /* list instances differs */\n            return 1;\n        }\n        /* matches */\n    }\n\n    return 0;\n}\n\n/*\n * -1 - error\n *  0 - ok\n */\nstatic int\nlyd_diff_match(struct lyd_node *first, struct lyd_node *second, struct lyd_difflist *diff, unsigned int *size,\n               unsigned int *i, struct ly_set *matchset, struct ly_set *ordset, int options)\n{\n    switch (first->schema->nodetype) {\n    case LYS_LEAFLIST:\n    case LYS_LIST:\n        /* additional work for future move matching in case of user ordered lists */\n        if (first->schema->flags & LYS_USERORDERED) {\n            diff_ordset_insert(first, ordset);\n        }\n\n        /* falls through */\n    case LYS_CONTAINER:\n        assert(!(second->validity & LYD_VAL_INUSE));\n        second->validity |= LYD_VAL_INUSE;\n        /* remember the matching node in first for keeping correct pointer in first\n         * for comparing when passing through the second tree in lyd_diff().\n         * Duplicities are not allowed actually, but they cannot happen since single\n         * node can match only one node in the other tree */\n        ly_set_add(matchset, first, LY_SET_OPT_USEASLIST);\n        break;\n    case LYS_LEAF:\n        /* check for leaf's modification */\n        if (!lyd_leaf_val_equal(first, second, 0) || ((options & LYD_DIFFOPT_WITHDEFAULTS) && (first->dflt != second->dflt))) {\n            if (lyd_difflist_add(diff, size, (*i)++, LYD_DIFF_CHANGED, first, second)) {\n               return -1;\n            }\n        }\n        break;\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        /* check for anydata/anyxml's modification */\n        if (!lyd_anydata_equal(first, second) && lyd_difflist_add(diff, size, (*i)++, LYD_DIFF_CHANGED, first, second)) {\n            return -1;\n        }\n        break;\n    default:\n        LOGINT(first->schema->module->ctx);\n        return -1;\n    }\n\n    /* mark both that they have matching instance in the other tree */\n    assert(!(first->validity & LYD_VAL_INUSE));\n    first->validity |= LYD_VAL_INUSE;\n\n    return 0;\n}\n\n/* @brief compare if the nodes are equivalent including checking the list's keys\n * Go through the nodes and their parents and in the case of list, compare its keys.\n *\n * @return 0 different, 1 equivalent\n */\nstatic int\nlyd_diff_equivnode(struct lyd_node *first, struct lyd_node *second)\n{\n    struct lyd_node *iter1, *iter2;\n\n    for (iter1 = first, iter2 = second; iter1 && iter2; iter1 = iter1->parent, iter2 = iter2->parent) {\n        if (iter1->schema->module->ctx == iter2->schema->module->ctx) {\n            if (iter1->schema != iter2->schema) {\n                return 0;\n            }\n        } else {\n            if (!ly_strequal(iter1->schema->name, iter2->schema->name, 0)) {\n                /* comparing the names is fine, even if they are, in fact, 2 different nodes\n                 * with equal names, some of their parents will differ */\n                return 0;\n            }\n        }\n        if (iter1->schema->nodetype == LYS_LIST) {\n            /* compare keys */\n            if (lyd_list_equal(iter1, iter2, 0) != 1) {\n                return 0;\n            }\n        }\n    }\n\n    if (iter1 != iter2) {\n        /* we are supposed to be in root (NULL) in both trees */\n        return 0;\n    }\n\n    return 1;\n}\n\nstatic int\nlyd_diff_move_preprocess(struct diff_ordered *ordered, struct lyd_node *first, struct lyd_node *second)\n{\n    struct ly_ctx *ctx = first->schema->module->ctx;\n    struct lyd_node *iter;\n    unsigned int pos = 0;\n    int abs_dist;\n    struct diff_ordered_dist *dist_aux;\n    struct diff_ordered_dist *dist_iter, *dist_last;\n    char *str = NULL;\n\n    /* ordered->count was zeroed and now it is incremented with each added\n     * item's information, so it is actually position of the second node\n     */\n\n    /* get the position of the first node */\n    for (iter = first->prev; iter->next; iter = iter->prev) {\n        if (!(iter->validity & LYD_VAL_INUSE)) {\n            /* skip deleted nodes */\n            continue;\n        }\n        if (iter->schema == first->schema) {\n            pos++;\n        }\n    }\n    if (pos != ordered->count) {\n        LOGDBG(LY_LDGDIFF, \"detected moved element \\\"%s\\\" from %d to %d (distance %d)\",\n               str = lyd_path(first), pos, ordered->count, ordered->count - pos);\n        free(str);\n    }\n\n    /* store information, count distance */\n    ordered->items[pos].dist = dist_aux = calloc(1, sizeof *dist_aux);\n    LY_CHECK_ERR_RETURN(!dist_aux, LOGMEM(ctx), EXIT_FAILURE);\n    ordered->items[pos].dist->dist = ordered->count - pos;\n    abs_dist = abs(ordered->items[pos].dist->dist);\n    ordered->items[pos].first = first;\n    ordered->items[pos].second = second;\n    ordered->count++;\n\n    /* insert sort of distances, higher first */\n    for (dist_iter = ordered->dist, dist_last = NULL;\n            dist_iter;\n            dist_last = dist_iter, dist_iter = dist_iter->next) {\n        if (abs_dist >= abs(dist_iter->dist)) {\n            /* found correct place */\n            dist_aux->next = dist_iter;\n            if (dist_last) {\n                dist_last->next = dist_aux;\n            }\n            break;\n        } else if (dist_iter->next == ordered->dist) {\n            /* last item */\n            dist_aux->next = ordered->dist; /* ring list */\n            ordered->dist_last = dist_aux;\n            break;\n        }\n    }\n    if (dist_aux->next == ordered->dist) {\n        if (ordered->dist_last == dist_aux) {\n            /* last item */\n            if (!ordered->dist) {\n                /* the only item */\n                dist_aux->next = dist_aux;\n                ordered->dist = ordered->dist_last = dist_aux;\n            }\n        } else {\n            /* first item */\n            ordered->dist = dist_aux;\n            if (dist_aux->next) {\n                /* more than one item, update the last one's next */\n                ordered->dist_last->next = dist_aux;\n            } else {\n                /* the only item */\n                ordered->dist_last = dist_aux;\n                dist_aux->next = dist_aux; /* ring list */\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic struct lyd_difflist *\nlyd_diff_init_difflist(struct ly_ctx *ctx, unsigned int *size)\n{\n    struct lyd_difflist *result;\n\n    result = malloc(sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(ctx); *size = 0, NULL);\n\n    *size = 1;\n    result->type = calloc(*size, sizeof *result->type);\n    result->first = calloc(*size, sizeof *result->first);\n    result->second = calloc(*size, sizeof *result->second);\n    if (!result->type || !result->first || !result->second) {\n        LOGMEM(ctx);\n        free(result->second);\n        free(result->first);\n        free(result->type);\n        free(result);\n        *size = 0;\n        return NULL;\n    }\n\n    return result;\n}\n\nAPI struct lyd_difflist *\nlyd_diff(struct lyd_node *first, struct lyd_node *second, int options)\n{\n    struct ly_ctx *ctx;\n    int rc;\n    struct lyd_node *elem1, *elem2, *iter, *aux, *parent = NULL, *next1, *next2;\n    struct lyd_difflist *result, *result2 = NULL;\n    void *new;\n    unsigned int size, size2, index = 0, index2 = 0, i, j, k;\n    struct matchlist_s {\n        struct matchlist_s *prev;\n        struct ly_set *match;\n        unsigned int i;\n    } *matchlist = NULL, *mlaux;\n    struct ly_set *ordset = NULL;\n    struct diff_ordered *ordered;\n    struct diff_ordered_dist *dist_aux, *dist_iter;\n    struct diff_ordered_item item_aux;\n\n    if (!first) {\n        /* all nodes in second were created,\n         * but the second must be top level */\n        if (second && second->parent) {\n            LOGERR(second->schema->module->ctx, LY_EINVAL, \"%s: \\\"first\\\" parameter is NULL and \\\"second\\\" is not top level.\", __func__);\n            return NULL;\n        }\n        result = lyd_diff_init_difflist(NULL, &size);\n        LY_TREE_FOR(second, iter) {\n            if (!iter->dflt || (options & LYD_DIFFOPT_WITHDEFAULTS)) { /* skip the implicit nodes */\n                if (lyd_difflist_add(result, &size, index++, LYD_DIFF_CREATED, NULL, iter)) {\n                    goto error;\n                }\n            }\n            if (options & LYD_DIFFOPT_NOSIBLINGS) {\n                break;\n            }\n        }\n        return result;\n    } else if (!second) {\n        /* all nodes from first were deleted */\n        result = lyd_diff_init_difflist(first->schema->module->ctx, &size);\n        LY_TREE_FOR(first, iter) {\n            if (!iter->dflt || (options & LYD_DIFFOPT_WITHDEFAULTS)) { /* skip the implicit nodes */\n                if (lyd_difflist_add(result, &size, index++, LYD_DIFF_DELETED, iter, NULL)) {\n                    goto error;\n                }\n            }\n            if (options & LYD_DIFFOPT_NOSIBLINGS) {\n                break;\n            }\n        }\n        return result;\n    }\n\n    ctx = first->schema->module->ctx;\n\n    if (options & LYD_DIFFOPT_NOSIBLINGS) {\n        /* both trees must start at the same (schema) node */\n        if (first->schema != second->schema) {\n            LOGERR(ctx, LY_EINVAL, \"%s: incompatible trees to compare with LYD_OPT_NOSIBLINGS option.\", __func__);\n            return NULL;\n        }\n        /* use first's and second's child to make comparison the same as without LYD_OPT_NOSIBLINGS */\n        first = first->child;\n        second = second->child;\n    } else {\n        /* go to the first sibling in both trees */\n        if (first->parent) {\n            first = first->parent->child;\n        } else {\n            while (first->prev->next) {\n                first = first->prev;\n            }\n        }\n\n        if (second->parent) {\n            second = second->parent->child;\n        } else {\n            for (; second->prev->next; second = second->prev);\n        }\n\n        /* check that both has the same (schema) parent or that they are top-level nodes */\n        if ((first->parent && second->parent && first->parent->schema != second->parent->schema) ||\n                (!first->parent && first->parent != second->parent)) {\n            LOGERR(ctx, LY_EINVAL, \"%s: incompatible trees with different parents.\", __func__);\n            return NULL;\n        }\n    }\n    if (first == second) {\n        LOGERR(ctx, LY_EINVAL, \"%s: comparing the same tree does not make sense.\", __func__);\n        return NULL;\n    }\n\n    /* initiate resulting structure */\n    result = lyd_diff_init_difflist(ctx, &size);\n    LY_CHECK_ERR_GOTO(!result, , error);\n\n    /* the records about created and moved items are created in\n     * bad order, so the records about created nodes (and their\n     * possible moving) is stored separately and added to the\n     * main result at the end.\n     */\n    result2 = lyd_diff_init_difflist(ctx, &size2);\n    LY_CHECK_ERR_GOTO(!result2, , error);\n\n    matchlist = malloc(sizeof *matchlist);\n    LY_CHECK_ERR_GOTO(!matchlist, LOGMEM(ctx), error);\n\n    matchlist->i = 0;\n    matchlist->match = ly_set_new();\n    matchlist->prev = NULL;\n\n    ordset = ly_set_new();\n    LY_CHECK_ERR_GOTO(!ordset, , error);\n\n    /*\n     * compare trees\n     */\n    /* 1) newly created nodes + changed leafs/anyxmls */\n    next1 = first;\n    for (elem2 = next2 = second; elem2; elem2 = next2) {\n        /* keep right pointer for searching in the first tree */\n        elem1 = next1;\n\n        if (elem2->dflt && !(options & LYD_DIFFOPT_WITHDEFAULTS)) {\n            /* skip default elements, they could not be created or changed, just deleted */\n            goto cmp_continue;\n        }\n\n#ifdef LY_ENABLED_CACHE\n        struct lyd_node **iter_p;\n\n        if (elem1 && elem1->parent && elem1->parent->ht) {\n            iter = NULL;\n            if (!lyht_find(elem1->parent->ht, &elem2, elem2->hash, (void **)&iter_p)) {\n                iter = *iter_p;\n                /* we found a match */\n                if (iter->dflt && !(options & LYD_DIFFOPT_WITHDEFAULTS)) {\n                    /* the second one cannot be default (see lyd_diff()),\n                     * so the nodes differs (first one is default node) */\n                    iter = NULL;\n                }\n                while (iter && (iter->validity & LYD_VAL_INUSE)) {\n                    /* state lists, find one not-already-found */\n                    assert((iter->schema->nodetype & (LYS_LIST | LYS_LEAFLIST)) && (iter->schema->flags & LYS_CONFIG_R));\n                    if (lyht_find_next(elem1->parent->ht, &iter, iter->hash, (void **)&iter_p)) {\n                        iter = NULL;\n                    } else {\n                        iter = *iter_p;\n                    }\n                }\n            }\n        } else\n#endif\n        {\n            /* search for elem2 instance in the first */\n            LY_TREE_FOR(elem1, iter) {\n                if (iter->schema != elem2->schema) {\n                    continue;\n                }\n\n                /* elem2 instance found */\n                rc = lyd_diff_compare(iter, elem2, options);\n                if (rc == -1) {\n                    goto error;\n                } else if (rc == 0) {\n                    /* match */\n                    break;\n                } /* else, continue */\n            }\n        }\n        /* we have a match */\n        if (iter && lyd_diff_match(iter, elem2, result, &size, &index, matchlist->match, ordset, options)) {\n            goto error;\n        }\n\n        if (!iter) {\n            /* elem2 not found in the first tree */\n            if (lyd_difflist_add(result2, &size2, index2++, LYD_DIFF_CREATED, elem1 ? elem1->parent : parent, elem2)) {\n                goto error;\n            }\n\n            if (elem1 && (elem2->schema->flags & LYS_USERORDERED)) {\n                /* store the correct place where the node is supposed to be moved after creation */\n                /* if elem1 does not exist, all nodes were created and they will be created in\n                 * correct order, so it is not needed to detect moves */\n                for (aux = elem2->prev; aux->next; aux = aux->prev) {\n                    if (aux->schema == elem2->schema) {\n                        /* predecessor found */\n                        break;\n                    }\n                }\n                if (!aux->next) {\n                    /* predecessor not found */\n                    aux = NULL;\n                }\n                if (lyd_difflist_add(result2, &size2, index2++, LYD_DIFF_MOVEDAFTER2, aux, elem2)) {\n                    goto error;\n                }\n            }\n        }\n\ncmp_continue:\n        /* select element for the next run                                    1     2\n         * - first, process all siblings of a single parent                  / \\   / \\\n         * - then, go to children (deep)                                    3   4 7   8\n         * - return to the parent's next sibling children                  / \\\n         *                                                                5   6\n         */\n        /* siblings first */\n        next1 = elem1;\n        next2 = elem2->next;\n\n        if (!next2) {\n            /* children */\n\n            /* first pass of the siblings done, some additional work for future\n             * detection of move may be needed */\n            for (i = ordset->number; i > 0; i--) {\n                ordered = (struct diff_ordered *)ordset->set.g[i - 1];\n                if (ordered->items) {\n                    /* already preprocessed ordered structure */\n                    break;\n                }\n                ordered->items = calloc(ordered->count, sizeof *ordered->items);\n                LY_CHECK_ERR_GOTO(!ordered->items, LOGMEM(ctx), error);\n                ordered->dist = NULL;\n                /* zero the count to be used as a node position in lyd_diff_move_preprocess() */\n                ordered->count = 0;\n            }\n\n            /* first, get the first sibling */\n            if (elem2->parent == second->parent) {\n                elem2 = second;\n            } else {\n                elem2 = elem2->parent->child;\n            }\n\n            /* and then find the first child */\n            LY_TREE_FOR(elem2, iter) {\n                if (!(iter->validity & LYD_VAL_INUSE)) {\n                    /* the iter is not present in both trees */\n                    continue;\n                } else if (matchlist->i == matchlist->match->number) {\n                    if (iter == elem2) {\n                        /* we already went through all the matching nodes and now we are just supposed to stop\n                         * the loop with no iter */\n                        iter = NULL;\n                        break;\n                    } else {\n                        /* we have started with some not processed data in matchlist, but now we have\n                         * the INUSE iter and no nodes in matchlist to find its equivalent,\n                         * so something went wrong somewhere */\n                        LOGINT(ctx);\n                        goto error;\n                    }\n                }\n\n                iter->validity &= ~LYD_VAL_INUSE;\n                if ((iter->schema->nodetype & (LYS_LEAFLIST | LYS_LIST)) && (iter->schema->flags & LYS_USERORDERED)) {\n                    for (j = ordset->number; j > 0; j--) {\n                        ordered = (struct diff_ordered *)ordset->set.g[j - 1];\n                        if (ordered->schema != iter->schema || !lyd_diff_equivnode(ordered->parent, iter->parent)) {\n                            continue;\n                        }\n\n                        /* store necessary information for move detection */\n                        lyd_diff_move_preprocess(ordered, matchlist->match->set.d[matchlist->i], iter);\n                        break;\n                    }\n                }\n\n                if (((iter->schema->nodetype == LYS_CONTAINER) || ((iter->schema->nodetype == LYS_LIST)\n                        && ((struct lys_node_list *)iter->schema)->keys_size)) && iter->child) {\n                    while (matchlist->i < matchlist->match->number && matchlist->match->set.d[matchlist->i]->schema != iter->schema) {\n                        matchlist->i++;\n                    }\n                    if (matchlist->i == matchlist->match->number) {\n                        /* we have the INUSE iter, so we have to find its equivalent in match list */\n                        LOGINT(ctx);\n                        goto error;\n                    }\n                    next1 = matchlist->match->set.d[matchlist->i]->child;\n                    if (!next1) {\n                        parent = matchlist->match->set.d[matchlist->i];\n                    }\n                    matchlist->i++;\n                    next2 = iter->child;\n                    break;\n                }\n                matchlist->i++;\n            }\n\n            if (!iter) {\n                /* no child/data on next level */\n                if (elem2 == second) {\n                    /* done */\n                    break;\n                }\n            } else {\n                /* create new matchlist item */\n                mlaux = malloc(sizeof *mlaux);\n                LY_CHECK_ERR_GOTO(!mlaux, LOGMEM(ctx), error);\n                mlaux->i = 0;\n                mlaux->match = ly_set_new();\n                mlaux->prev = matchlist;\n                matchlist = mlaux;\n            }\n        }\n\n        while (!next2) {\n            /* parent */\n\n            /* clean the last match set */\n            ly_set_clean(matchlist->match);\n            matchlist->i = 0;\n\n            /* try to go to a cousin - child of the next parent's sibling */\n            mlaux = matchlist->prev;\n            LY_TREE_FOR(elem2->parent->next, iter) {\n                if (!(iter->validity & LYD_VAL_INUSE)) {\n                    continue;\n                } else if (mlaux->i == mlaux->match->number) {\n                    if (iter == elem2->parent->next) {\n                        /* we already went through all the matching nodes and now we are just supposed to stop\n                         * the loop with no iter */\n                        iter = NULL;\n                        break;\n                    } else {\n                        /* we have started with some not processed data in matchlist, but now we have\n                         * the INUSE iter and no nodes in matchlist to find its equivalent,\n                         * so something went wrong somewhere */\n                        LOGINT(ctx);\n                        goto error;\n                    }\n                }\n\n                iter->validity &= ~LYD_VAL_INUSE;\n                if ((iter->schema->nodetype & (LYS_LEAFLIST | LYS_LIST)) && (iter->schema->flags & LYS_USERORDERED)) {\n                    for (j = ordset->number ; j > 0; j--) {\n                        ordered = (struct diff_ordered *)ordset->set.g[j - 1];\n                        if (ordered->schema != iter->schema || !lyd_diff_equivnode(ordered->parent, iter->parent)) {\n                            continue;\n                        }\n\n                        /* store necessary information for move detection */\n                        lyd_diff_move_preprocess(ordered, mlaux->match->set.d[mlaux->i], iter);\n                        break;\n                    }\n                }\n\n                if (((iter->schema->nodetype == LYS_CONTAINER) || ((iter->schema->nodetype == LYS_LIST)\n                        && ((struct lys_node_list *)iter->schema)->keys_size)) && iter->child) {\n                    while (mlaux->i < mlaux->match->number && mlaux->match->set.d[mlaux->i]->schema != iter->schema) {\n                        mlaux->i++;\n                    }\n                    if (mlaux->i == mlaux->match->number) {\n                        /* we have the INUSE iter, so we have to find its equivalent in match list */\n                        LOGINT(ctx);\n                        goto error;\n                    }\n                    next1 = mlaux->match->set.d[mlaux->i]->child;\n                    if (!next1) {\n                        parent = mlaux->match->set.d[mlaux->i];\n                    }\n                    mlaux->i++;\n                    next2 = iter->child;\n                    break;\n                }\n                mlaux->i++;\n            }\n\n            /* if no cousin exists, continue next loop on higher level */\n            if (!iter) {\n                elem2 = elem2->parent;\n\n                /* remove matchlist item */\n                ly_set_free(matchlist->match);\n                mlaux = matchlist;\n                matchlist = matchlist->prev;\n                free(mlaux);\n\n                if (!matchlist->prev) { /* elem2->parent == second->parent */\n                    /* done */\n                    break;\n                }\n            }\n        }\n    }\n\n    ly_set_free(matchlist->match);\n    free(matchlist);\n    matchlist = NULL;\n\n    /* 2) deleted nodes */\n    LY_TREE_DFS_BEGIN(first, next1, elem1) {\n        /* search for elem1s deleted in the second */\n        if (elem1->validity & LYD_VAL_INUSE) {\n            /* erase temporary LYD_VAL_INUSE flag and continue into children */\n            elem1->validity &= ~LYD_VAL_INUSE;\n        } else if (!elem1->dflt || (options & LYD_DIFFOPT_WITHDEFAULTS)) {\n            /* elem1 has no matching node in second, add it into result */\n            if (lyd_difflist_add(result, &size, index++, LYD_DIFF_DELETED, elem1, NULL)) {\n                goto error;\n            }\n\n            /* skip subtree processing of data missing in the second tree */\n            goto dfs_nextsibling;\n        }\n\n        /* modified LY_TREE_DFS_END() */\n        /* select element for the next run - children first */\n        if ((elem1->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) || ((elem1->schema->nodetype == LYS_LIST)\n                && !((struct lys_node_list *)elem1->schema)->keys_size)) {\n            next1 = NULL;\n        } else {\n            next1 = elem1->child;\n        }\n        if (!next1) {\ndfs_nextsibling:\n            /* try siblings */\n            next1 = elem1->next;\n        }\n        while (!next1) {\n            /* parent is already processed, go to its sibling */\n\n            elem1 = elem1->parent;\n            if (elem1 == first->parent) {\n                /* we are done, no next element to process */\n                break;\n            }\n\n            next1 = elem1->next;\n        }\n    }\n\n    /* 3) moved nodes (when user-ordered) */\n    for (i = 0; i < ordset->number; i++) {\n        ordered = (struct diff_ordered *)ordset->set.g[i];\n        if (!ordered->dist->dist) {\n            /* the dist list is sorted here, but the biggest dist is 0,\n             * so nothing changed in order of these items between first\n             * and second. We can continue with another user-ordered list.\n             */\n            continue;\n        }\n\n        /* get needed movements\n         * - from the biggest distances try to apply node movements\n         * on first tree node until they will be ordered as in the\n         * second tree - i.e. until there will be no position difference\n         */\n\n        for (dist_iter = ordered->dist; ; dist_iter = dist_iter->next) {\n            /* dist list is sorted at the beginning, since applying a move causes\n             * just a small change in other distances, we assume that the biggest\n             * dist is the next one (note that dist list is implemented as ring\n             * list). This way we avoid sorting distances after each move. The loop\n             * stops when all distances are zero.\n             */\n            dist_aux = dist_iter;\n            while (!dist_iter->dist) {\n                /* no dist, so no move. Try another, but when\n                 * there is no dist at all, stop the loop\n                 */\n                dist_iter = dist_iter->next;\n                if (dist_iter == dist_aux) {\n                    /* all dist we zeroed */\n                    goto movedone;\n                }\n            }\n            /* something to move */\n\n            /* get the item to move */\n            for (k = 0; k < ordered->count; k++) {\n                if (ordered->items[k].dist == dist_iter) {\n                    break;\n                }\n            }\n\n            /* apply the move (distance) */\n            memcpy(&item_aux, &ordered->items[k], sizeof item_aux);\n            if (dist_iter->dist > 0) {\n                /* move to right (other move to left) */\n                while (dist_iter->dist) {\n                    memcpy(&ordered->items[k], &ordered->items[k + 1], sizeof *ordered->items);\n                    ordered->items[k].dist->dist++; /* update moved item distance */\n                    dist_iter->dist--;\n                    k++;\n                }\n            } else {\n                /* move to left (other move to right) */\n                while (dist_iter->dist) {\n                    memcpy(&ordered->items[k], &ordered->items[k - 1], sizeof *ordered->items);\n                    ordered->items[k].dist->dist--; /* update moved item distance */\n                    dist_iter->dist++;\n                    k--;\n                }\n            }\n            memcpy(&ordered->items[k], &item_aux, sizeof *ordered->items);\n\n            /* store the transaction into the difflist */\n            if (lyd_difflist_add(result, &size, index++, LYD_DIFF_MOVEDAFTER1, item_aux.first,\n                                 (k > 0) ? ordered->items[k - 1].first : NULL)) {\n                goto error;\n            }\n            continue;\n\nmovedone:\n            break;\n        }\n    }\n\n    diff_ordset_free(ordset);\n    ordset = NULL;\n\n    if (index2) {\n        /* append result2 with newly created\n         * (and possibly moved) nodes */\n        if (index + index2 + 1 >= size) {\n            /* result must be enlarged */\n            size = index + index2 + 1;\n            new = realloc(result->type, size * sizeof *result->type);\n            LY_CHECK_ERR_GOTO(!new, LOGMEM(ctx), error);\n            result->type = new;\n\n            new = realloc(result->first, size * sizeof *result->first);\n            LY_CHECK_ERR_GOTO(!new, LOGMEM(ctx), error);\n            result->first = new;\n\n            new = realloc(result->second, size * sizeof *result->second);\n            LY_CHECK_ERR_GOTO(!new, LOGMEM(ctx), error);\n            result->second = new;\n        }\n\n        /* append */\n        memcpy(&result->type[index], result2->type, (index2 + 1) * sizeof *result->type);\n        memcpy(&result->first[index], result2->first, (index2 + 1) * sizeof *result->first);\n        memcpy(&result->second[index], result2->second, (index2 + 1) * sizeof *result->second);\n    }\n    lyd_free_diff(result2);\n\n    return result;\n\nerror:\n    while (matchlist) {\n        mlaux = matchlist;\n        matchlist = mlaux->prev;\n        ly_set_free(mlaux->match);\n        free(mlaux);\n\n    }\n    diff_ordset_free(ordset);\n\n    lyd_free_diff(result);\n    lyd_free_diff(result2);\n\n    return NULL;\n}\n\nstatic void\nlyd_insert_setinvalid(struct lyd_node *node)\n{\n    struct lyd_node *next, *elem, *parent_list;\n\n    assert(node);\n\n    /* overall validity of the node itself */\n    node->validity = ly_new_node_validity(node->schema);\n\n    /* explore changed unique leaves */\n    /* first, get know if there is a list in parents chain */\n    for (parent_list = node->parent;\n         parent_list && parent_list->schema->nodetype != LYS_LIST;\n         parent_list = parent_list->parent);\n    if (parent_list && !(parent_list->validity & LYD_VAL_UNIQUE)) {\n        /* there is a list, so check if we inserted a leaf supposed to be unique */\n        for (elem = node; elem; elem = next) {\n            if (elem->schema->nodetype == LYS_LIST) {\n                /* stop searching to the depth, children would be unique to a list in subtree */\n                goto nextsibling;\n            }\n\n            if (elem->schema->nodetype == LYS_LEAF && (elem->schema->flags & LYS_UNIQUE)) {\n                /* set flag to list for future validation */\n                parent_list->validity |= LYD_VAL_UNIQUE;\n                break;\n            }\n\n            if (elem->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                if (elem == node) {\n                    /* stop the loop */\n                    break;\n                }\n                goto nextsibling;\n            }\n\n            /* select next elem to process */\n            /* go into children */\n            next = elem->child;\n            /* go through siblings */\n            if (!next) {\nnextsibling:\n                next = elem->next;\n                if (!next) {\n                    /* no sibling */\n                    if (elem == node) {\n                        /* we are done, back in start node */\n                        break;\n                    }\n                }\n            }\n            /* go back to parents */\n            while (!next) {\n                elem = elem->parent;\n                if (elem->parent == node->parent) {\n                    /* we are done, back in start node */\n                    break;\n                }\n                /* parent was actually already processed, so go to the parent's sibling */\n                next = elem->parent->next;\n            }\n        }\n    }\n\n    if (node->parent) {\n        /* if the inserted node is list/leaflist with constraint on max instances,\n         * invalidate the parent to make it validate this */\n        if (node->schema->nodetype & LYS_LEAFLIST) {\n            if (((struct lys_node_leaflist *)node->schema)->max) {\n                node->parent->validity |= LYD_VAL_MAND;\n            }\n        } else if (node->schema->nodetype & LYS_LIST) {\n            if (((struct lys_node_list *)node->schema)->max) {\n                node->parent->validity |= LYD_VAL_MAND;\n            }\n        }\n    }\n}\n\nstatic void\nlyd_replace(struct lyd_node *orig, struct lyd_node *repl, int destroy)\n{\n    struct lyd_node *iter, *last;\n\n    if (!repl) {\n        /* remove the old one */\n        goto finish;\n    }\n\n    if (repl->parent || repl->prev->next) {\n        /* isolate the new node */\n        repl->next = NULL;\n        repl->prev = repl;\n        last = repl;\n    } else {\n        /* get the last node of a possible list of nodes to be inserted */\n        for(last = repl; last->next; last = last->next) {\n            /* part of the parent changes */\n            last->parent = orig->parent;\n        }\n    }\n\n    /* parent */\n    if (orig->parent) {\n        if (orig->parent->child == orig) {\n            orig->parent->child = repl;\n        }\n        orig->parent = NULL;\n    }\n\n    /* predecessor */\n    if (orig->prev == orig) {\n        /* the old was alone */\n        goto finish;\n    }\n    if (orig->prev->next) {\n        orig->prev->next = repl;\n    }\n    repl->prev = orig->prev;\n    orig->prev = orig;\n\n    /* successor */\n    if (orig->next) {\n        orig->next->prev = last;\n        last->next = orig->next;\n        orig->next = NULL;\n    } else {\n        /* fix the last pointer */\n        if (repl->parent) {\n            repl->parent->child->prev = last;\n        } else {\n            /* get the first sibling */\n            for (iter = repl; iter->prev != orig; iter = iter->prev);\n            iter->prev = last;\n        }\n    }\n\nfinish:\n    /* remove the old one */\n    if (destroy) {\n        lyd_free(orig);\n    }\n}\n\nint\nlyd_insert_common(struct lyd_node *parent, struct lyd_node **sibling, struct lyd_node *node, int invalidate)\n{\n    struct lys_node *par1, *par2;\n    const struct lys_node *siter;\n    struct lyd_node *start, *iter, *ins, *next1, *next2;\n    int invalid = 0, isrpc = 0, clrdflt = 0;\n    struct ly_set *llists = NULL;\n    int i;\n    uint8_t pos;\n    int stype = LYS_INPUT | LYS_OUTPUT;\n\n    assert(parent || sibling);\n\n    /* get first sibling */\n    if (parent) {\n        start = parent->child;\n    } else {\n        for (start = *sibling; start->prev->next; start = start->prev);\n    }\n\n    /* check placing the node to the appropriate place according to the schema */\n    if (!start) {\n        if (!parent) {\n            /* empty tree to insert */\n            if (node->parent || node->prev->next) {\n                /* unlink the node first */\n                lyd_unlink_internal(node, 1);\n            } /* else insert also node's siblings */\n            *sibling = node;\n            return EXIT_SUCCESS;\n        }\n        par1 = parent->schema;\n        if (par1->nodetype & (LYS_RPC | LYS_ACTION)) {\n            /* it is not clear if the tree being created is going to\n             * be rpc (LYS_INPUT) or rpc-reply (LYS_OUTPUT) so we have to\n             * compare against LYS_RPC or LYS_ACTION in par2\n             */\n            stype = LYS_RPC | LYS_ACTION;\n        }\n    } else if (parent && (parent->schema->nodetype & (LYS_RPC | LYS_ACTION))) {\n        par1 = parent->schema;\n        stype = LYS_RPC | LYS_ACTION;\n    } else {\n        for (par1 = lys_parent(start->schema);\n             par1 && !(par1->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_INPUT | LYS_OUTPUT | LYS_NOTIF));\n             par1 = lys_parent(par1));\n    }\n    for (par2 = lys_parent(node->schema);\n         par2 && !(par2->nodetype & (LYS_CONTAINER | LYS_LIST | stype | LYS_NOTIF));\n         par2 = lys_parent(par2));\n    if (par1 != par2) {\n        LOGERR(parent->schema->module->ctx, LY_EINVAL, \"Cannot insert, different parents (\\\"%s\\\" and \\\"%s\\\").\",\n               (par1 ? par1->name : \"<top-lvl>\"), (par2 ? par2->name : \"<top-lvl>\"));\n        return EXIT_FAILURE;\n    }\n\n    if (invalidate) {\n        invalid = isrpc = lyp_is_rpc_action(node->schema);\n        if (!parent || node->parent != parent || isrpc) {\n            /* it is not just moving under a parent node or it is in an RPC where\n             * nodes order matters, so the validation will be necessary */\n            invalid++;\n        }\n    }\n\n    /* unlink only if it is not a list of siblings without a parent and node is not the first sibling */\n    if (node->parent || node->prev->next) {\n        /* do it permanent if the parents are not exact same or if it is top-level */\n        lyd_unlink_internal(node, invalid);\n    }\n\n    llists = ly_set_new();\n\n    /* process the nodes to insert one by one */\n    LY_TREE_FOR_SAFE(node, next1, ins) {\n        if (invalid == 1) {\n            /* auto delete nodes from other cases, if any;\n             * this is done only if node->parent != parent */\n            if (lyv_multicases(ins, NULL, &start, 1, NULL)) {\n                goto error;\n            }\n        }\n\n        /* isolate the node to be handled separately */\n        ins->prev = ins;\n        ins->next = NULL;\n\n        iter = NULL;\n        if (!ins->dflt) {\n            clrdflt = 1;\n        }\n\n        /* are we inserting list key? */\n        if (!ins->dflt && ins->schema->nodetype == LYS_LEAF && lys_is_key((struct lys_node_leaf *)ins->schema, &pos)) {\n            /* yes, we have a key, get know its position */\n            for (i = 0, iter = parent->child;\n                    iter && i < pos && iter->schema->nodetype == LYS_LEAF;\n                    i++, iter = iter->next);\n            if (iter) {\n                /* insert list's key to the correct position - before the iter */\n                if (parent->child == iter) {\n                    parent->child = ins;\n                }\n                if (iter->prev->next) {\n                    iter->prev->next = ins;\n                }\n                ins->prev = iter->prev;\n                iter->prev = ins;\n                ins->next = iter;\n\n                /* update start element */\n                if (parent->child != start) {\n                    start = parent->child;\n                }\n            }\n\n            /* try to find previously present default instance to replace */\n        } else if (ins->schema->nodetype == LYS_LEAFLIST) {\n            i = (int)llists->number;\n            if ((ly_set_add(llists, ins->schema, 0) != i) || ins->dflt) {\n                /* each leaf-list must be cleared only once (except when looking for exact same existing dflt nodes) */\n                LY_TREE_FOR_SAFE(start, next2, iter) {\n                    if (iter->schema == ins->schema) {\n                        if ((ins->dflt && (!iter->dflt || ((iter->schema->flags & LYS_CONFIG_W) &&\n                                                           !strcmp(((struct lyd_node_leaf_list *)iter)->value_str,\n                                                                  ((struct lyd_node_leaf_list *)ins)->value_str))))\n                                || (!ins->dflt && iter->dflt)) {\n                            if (iter == start) {\n                                start = next2;\n                            }\n                            lyd_free(iter);\n                        }\n                    }\n                }\n            }\n        } else if (ins->schema->nodetype == LYS_LEAF || (ins->schema->nodetype == LYS_CONTAINER\n                        && !((struct lys_node_container *)ins->schema)->presence)) {\n            LY_TREE_FOR(start, iter) {\n                if (iter->schema == ins->schema) {\n                    if (ins->dflt || iter->dflt) {\n                        /* replace existing (either explicit or default) node with the new (either explicit or default) node */\n                        lyd_replace(iter, ins, 1);\n                    } else {\n                        /* keep both explicit nodes, let the caller solve it later */\n                        iter = NULL;\n                    }\n                    break;\n                }\n            }\n        }\n\n        if (!iter) {\n            if (!start) {\n                /* add as the only child of the parent */\n                start = ins;\n                if (parent) {\n                    parent->child = ins;\n                }\n            } else if (isrpc) {\n                /* add to the specific position in rpc/rpc-reply/action */\n                for (par1 = ins->schema->parent; !(par1->nodetype & (LYS_INPUT | LYS_OUTPUT)); par1 = lys_parent(par1));\n                siter = NULL;\n                LY_TREE_FOR(start, iter) {\n                    while ((siter = lys_getnext(siter, par1, lys_node_module(par1), 0))) {\n                        if (iter->schema == siter || ins->schema == siter) {\n                            break;\n                        }\n                    }\n                    if (ins->schema == siter) {\n                        if ((siter->nodetype & (LYS_LEAFLIST | LYS_LIST)) && iter->schema == siter) {\n                            /* we are inserting leaflist/list instance, but since there are already\n                             * some instances of the same leaflist/list, we want to insert the new one\n                             * as the last instance, so here we have to move on */\n                            while (iter && iter->schema == siter) {\n                                iter = iter->next;\n                            }\n                            if (!iter) {\n                                break;\n                            }\n                        }\n                        /* we have the correct place for new node (before the iter) */\n                        if (iter == start) {\n                            start = ins;\n                            if (parent) {\n                                parent->child = ins;\n                            }\n                        } else {\n                            iter->prev->next = ins;\n                        }\n                        ins->prev = iter->prev;\n                        iter->prev = ins;\n                        ins->next = iter;\n\n                        /* we are done */\n                        break;\n                    }\n                }\n                if (!iter) {\n                    /* add as the last child of the parent */\n                    start->prev->next = ins;\n                    ins->prev = start->prev;\n                    start->prev = ins;\n                }\n            } else {\n                /* add as the last child of the parent */\n                start->prev->next = ins;\n                ins->prev = start->prev;\n                start->prev = ins;\n            }\n        }\n\n#ifdef LY_ENABLED_CACHE\n        lyd_unlink_hash(ins, ins->parent);\n#endif\n\n        ins->parent = parent;\n\n#ifdef LY_ENABLED_CACHE\n        lyd_insert_hash(ins);\n#endif\n\n        if (invalidate) {\n            check_leaf_list_backlinks(ins, 0);\n        }\n\n        if (invalid) {\n            lyd_insert_setinvalid(ins);\n        }\n    }\n    ly_set_free(llists);\n\n    if (clrdflt) {\n        /* remove the dflt flag from parents */\n        for (iter = parent; iter && iter->dflt; iter = iter->parent) {\n            iter->dflt = 0;\n        }\n    }\n\n    if (sibling) {\n        *sibling = start;\n    }\n    return EXIT_SUCCESS;\n\nerror:\n    ly_set_free(llists);\n    return EXIT_FAILURE;\n}\n\nAPI int\nlyd_insert(struct lyd_node *parent, struct lyd_node *node)\n{\n    if (!node || !parent || (parent->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA))) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    return lyd_insert_common(parent, NULL, node, 1);\n}\n\nAPI int\nlyd_insert_sibling(struct lyd_node **sibling, struct lyd_node *node)\n{\n    if (!sibling || !node) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    return lyd_insert_common((*sibling) ? (*sibling)->parent : NULL, sibling, node, 1);\n\n}\n\nint\nlyd_insert_nextto(struct lyd_node *sibling, struct lyd_node *node, int before, int invalidate)\n{\n    struct ly_ctx *ctx;\n    struct lys_node *par1, *par2;\n    struct lyd_node *iter, *start = NULL, *ins, *next1, *next2, *last;\n    struct lyd_node *orig_parent = NULL, *orig_prev = NULL, *orig_next = NULL;\n    int invalid = 0;\n    char *str;\n\n    assert(sibling);\n    assert(node);\n\n    ctx = sibling->schema->module->ctx;\n\n    if (sibling == node) {\n        return EXIT_SUCCESS;\n    }\n\n    /* check placing the node to the appropriate place according to the schema */\n    for (par1 = lys_parent(sibling->schema);\n         par1 && !(par1->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_INPUT | LYS_OUTPUT | LYS_ACTION | LYS_NOTIF));\n         par1 = lys_parent(par1));\n    for (par2 = lys_parent(node->schema);\n         par2 && !(par2->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_INPUT | LYS_OUTPUT | LYS_ACTION | LYS_NOTIF));\n         par2 = lys_parent(par2));\n    if (par1 != par2) {\n        LOGERR(ctx, LY_EINVAL, \"Cannot insert, different parents (\\\"%s\\\" and \\\"%s\\\").\",\n               (par1 ? par1->name : \"<top-lvl>\"), (par2 ? par2->name : \"<top-lvl>\"));\n        return EXIT_FAILURE;\n    }\n\n    if (invalidate && ((node->parent != sibling->parent) || (invalid = lyp_is_rpc_action(node->schema)) || !node->parent)) {\n        /* a) it is not just moving under a parent node (invalid = 1) or\n         * b) it is in an RPC where nodes order matters (invalid = 2) or\n         * c) it is top-level where we don't know if it is the same tree (invalid = 1),\n         * so the validation will be necessary */\n        if (!node->parent && !invalid) {\n            /* c) search in siblings */\n            for (iter = node->prev; iter != node; iter = iter->prev) {\n                if (iter == sibling) {\n                    break;\n                }\n            }\n            if (iter == node) {\n                /* node and siblings are not currently in the same data tree */\n                invalid++;\n            }\n        } else { /* a) and b) */\n            invalid++;\n        }\n    }\n\n    /* unlink only if it is not a list of siblings without a parent or node is not the first sibling,\n     * always unlink if just moving a node */\n    if ((!invalid) || node->parent || node->prev->next) {\n        /* remember the original position to be able to revert\n         * unlink in case of error */\n        orig_parent = node->parent;\n        if (node->prev != node) {\n            orig_prev = node->prev;\n        }\n        orig_next = node->next;\n        lyd_unlink_internal(node, invalid);\n    }\n\n    /* find first sibling node */\n    if (sibling->parent) {\n        start = sibling->parent->child;\n    } else {\n        for (start = sibling; start->prev->next; start = start->prev);\n    }\n\n    /* process the nodes one by one to clean the current tree */\n    if (!invalid) {\n        /* just moving one sibling */\n        last = node;\n        node->parent = sibling->parent;\n    } else {\n        LY_TREE_FOR_SAFE(node, next1, ins) {\n            lyd_insert_setinvalid(ins);\n\n            if (invalid == 1) {\n                /* auto delete nodes from other cases */\n                if (lyv_multicases(ins, NULL, &start, 1, sibling) == 2) {\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYD, sibling, \"Insert request refers node (%s) that is going to be auto-deleted.\",\n                        ly_errpath(ctx));\n                    goto error;\n                }\n            }\n\n            /* try to find previously present default instance to remove because of\n            * inserting the specified node */\n            if (ins->schema->nodetype == LYS_LEAFLIST) {\n                LY_TREE_FOR_SAFE(start, next2, iter) {\n                    if (iter->schema == ins->schema) {\n                        if ((ins->dflt && (!iter->dflt || ((iter->schema->flags & LYS_CONFIG_W) &&\n                                                        !strcmp(((struct lyd_node_leaf_list *)iter)->value_str,\n                                                                ((struct lyd_node_leaf_list *)ins)->value_str))))\n                                || (!ins->dflt && iter->dflt)) {\n                            /* iter will get deleted */\n                            if (iter == sibling) {\n                                LOGERR(ctx, LY_EINVAL, \"Insert request refers node (%s) that is going to be auto-deleted.\",\n                                    str = lyd_path(sibling));\n                                free(str);\n                                goto error;\n                            }\n                            if (iter == start) {\n                                start = next2;\n                            }\n                            lyd_free(iter);\n                        }\n                    }\n                }\n            } else if (ins->schema->nodetype == LYS_LEAF ||\n                    (ins->schema->nodetype == LYS_CONTAINER && !((struct lys_node_container *)ins->schema)->presence)) {\n                LY_TREE_FOR(start, iter) {\n                    if (iter->schema == ins->schema) {\n                        if (iter->dflt || ins->dflt) {\n                            /* iter gets deleted */\n                            if (iter == sibling) {\n                                LOGERR(ctx, LY_EINVAL, \"Insert request refers node (%s) that is going to be auto-deleted.\",\n                                    str = lyd_path(sibling));\n                                free(str);\n                                goto error;\n                            }\n                            if (iter == start) {\n                                start = iter->next;\n                            }\n                            lyd_free(iter);\n                        }\n                        break;\n                    }\n                }\n            }\n\n#ifdef LY_ENABLED_CACHE\n            lyd_unlink_hash(ins, ins->parent);\n#endif\n\n            ins->parent = sibling->parent;\n\n#ifdef LY_ENABLED_CACHE\n            lyd_insert_hash(ins);\n#endif\n            last = ins;\n        }\n    }\n\n    /* insert the (list of) node(s) to the specified position */\n    if (before) {\n        if (sibling->prev->next) {\n            /* adding into a middle */\n            sibling->prev->next = node;\n        } else if (sibling->parent) {\n            /* at the beginning */\n            sibling->parent->child = node;\n        }\n        node->prev = sibling->prev;\n        sibling->prev = last;\n        last->next = sibling;\n    } else { /* after */\n        if (sibling->next) {\n            /* adding into a middle - fix the prev pointer of the node after inserted nodes */\n            last->next = sibling->next;\n            sibling->next->prev = last;\n        } else {\n            /* at the end - fix the prev pointer of the first node */\n            start->prev = last;\n        }\n        sibling->next = node;\n        node->prev = sibling;\n    }\n\n    if (invalidate) {\n        LY_TREE_FOR(node, next1) {\n            check_leaf_list_backlinks(next1, 0);\n            if (next1 == last) {\n                break;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    /* insert back to the original position */\n    if (orig_prev) {\n        lyd_insert_after(orig_prev, node);\n    } else if (orig_next) {\n        lyd_insert_before(orig_next, node);\n    } else if (orig_parent) {\n        /* there were no siblings */\n        orig_parent->child = node;\n        node->parent = orig_parent;\n    }\n    return EXIT_FAILURE;\n}\n\nAPI int\nlyd_insert_before(struct lyd_node *sibling, struct lyd_node *node)\n{\n    if (!node || !sibling) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    return lyd_insert_nextto(sibling, node, 1, 1);\n}\n\nAPI int\nlyd_insert_after(struct lyd_node *sibling, struct lyd_node *node)\n{\n    if (!node || !sibling) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    return lyd_insert_nextto(sibling, node, 0, 1);\n}\n\nstatic uint32_t\nlys_module_pos(struct lys_module *module)\n{\n    int i;\n    uint32_t pos = 1;\n\n    for (i = 0; i < module->ctx->models.used; ++i) {\n        if (module->ctx->models.list[i] == module) {\n            return pos;\n        }\n        ++pos;\n    }\n\n    LOGINT(module->ctx);\n    return 0;\n}\n\nstatic int\nlys_module_node_pos_r(struct lys_node *first_sibling, struct lys_node *target, uint32_t *pos)\n{\n    const struct lys_node *next = NULL;\n\n    /* the schema nodes are actually from data, lys_getnext skips non-data schema nodes for us (we know the parent will not be uses) */\n    while ((next = lys_getnext(next, lys_parent(first_sibling), lys_node_module(first_sibling), LYS_GETNEXT_NOSTATECHECK))) {\n        ++(*pos);\n        if (target == next) {\n            return 0;\n        }\n    }\n\n    LOGINT(first_sibling->module->ctx);\n    return 1;\n}\n\nstatic int\nlyd_node_pos_cmp(const void *item1, const void *item2)\n{\n    uint32_t mpos1, mpos2;\n    struct lyd_node_pos *np1, *np2;\n\n    np1 = (struct lyd_node_pos *)item1;\n    np2 = (struct lyd_node_pos *)item2;\n\n    /* different modules? */\n    if (lys_node_module(np1->node->schema) != lys_node_module(np2->node->schema)) {\n        mpos1 = lys_module_pos(lys_node_module(np1->node->schema));\n        mpos2 = lys_module_pos(lys_node_module(np2->node->schema));\n        /* if lys_module_pos failed, there is nothing we can do anyway,\n         * at least internal error will be printed */\n\n        if (mpos1 > mpos2) {\n            return 1;\n        } else {\n            return -1;\n        }\n    }\n\n    if (np1->pos > np2->pos) {\n        return 1;\n    } else if (np1->pos < np2->pos) {\n        return -1;\n    }\n    return 0;\n}\n\nAPI int\nlyd_schema_sort(struct lyd_node *sibling, int recursive)\n{\n    uint32_t len, i;\n    struct lyd_node *node;\n    struct lys_node *first_ssibling = NULL;\n    struct lyd_node_pos *array;\n\n    if (!sibling) {\n        LOGARG;\n        return -1;\n    }\n\n    /* something actually to sort */\n    if (sibling->prev != sibling) {\n\n        /* find the beginning */\n        sibling = lyd_first_sibling(sibling);\n\n        /* count siblings */\n        len = 0;\n        for (node = sibling; node; node = node->next) {\n            ++len;\n        }\n\n        array = malloc(len * sizeof *array);\n        LY_CHECK_ERR_RETURN(!array, LOGMEM(sibling->schema->module->ctx), -1);\n\n        /* fill arrays with positions and corresponding nodes */\n        for (i = 0, node = sibling; i < len; ++i, node = node->next) {\n            array[i].pos = 0;\n\n            /* we need to repeat this for every module */\n            if (!first_ssibling || (lyd_node_module(node) != lys_node_module(first_ssibling))) {\n                /* find the data node schema parent */\n                first_ssibling = node->schema;\n                while (lys_parent(first_ssibling)\n                        && (lys_parent(first_ssibling)->nodetype & (LYS_CHOICE | LYS_CASE | LYS_USES))) {\n                    first_ssibling = lys_parent(first_ssibling);\n                }\n\n                /* find the beginning */\n                if (lys_parent(first_ssibling)) {\n                    first_ssibling = lys_parent(first_ssibling)->child;\n                } else {\n                    while (first_ssibling->prev->next) {\n                        first_ssibling = first_ssibling->prev;\n                    }\n                }\n            }\n\n            if (lys_module_node_pos_r(first_ssibling, node->schema, &array[i].pos)) {\n                free(array);\n                return -1;\n            }\n\n            array[i].node = node;\n        }\n\n        /* sort the arrays */\n        qsort(array, len, sizeof *array, lyd_node_pos_cmp);\n\n        /* adjust siblings based on the sorted array */\n        for (i = 0; i < len; ++i) {\n            /* parent child */\n            if (i == 0) {\n                /* adjust sibling so that it still points to the beginning */\n                sibling = array[i].node;\n                if (array[i].node->parent) {\n                    array[i].node->parent->child = array[i].node;\n                }\n            }\n\n            /* prev */\n            if (i > 0) {\n                array[i].node->prev = array[i - 1].node;\n            } else {\n                array[i].node->prev = array[len - 1].node;\n            }\n\n            /* next */\n            if (i < len - 1) {\n                array[i].node->next = array[i + 1].node;\n            } else {\n                array[i].node->next = NULL;\n            }\n        }\n        free(array);\n    }\n\n    /* sort all the children recursively */\n    if (recursive) {\n        LY_TREE_FOR(sibling, node) {\n            if ((node->schema->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_RPC | LYS_ACTION | LYS_NOTIF))\n                    && node->child && lyd_schema_sort(node->child, recursive)) {\n                return -1;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nstatic int\n_lyd_validate(struct lyd_node **node, struct lyd_node *data_tree, struct ly_ctx *ctx, const struct lys_module **modules,\n              int mod_count, struct lyd_difflist **diff, int options)\n{\n    struct lyd_node *root, *next1, *next2, *iter, *act_notif = NULL;\n    int ret = EXIT_FAILURE;\n    unsigned int i;\n    struct unres_data *unres = NULL;\n    const struct lys_module *yanglib_mod;\n\n    unres = calloc(1, sizeof *unres);\n    LY_CHECK_ERR_RETURN(!unres, LOGMEM(NULL), EXIT_FAILURE);\n\n    if (diff) {\n        unres->store_diff = 1;\n        unres->diff = lyd_diff_init_difflist(ctx, &unres->diff_size);\n    }\n\n    if ((options & (LYD_OPT_RPC | LYD_OPT_RPCREPLY)) && *node && ((*node)->schema->nodetype != LYS_RPC)) {\n        options |= LYD_OPT_ACT_NOTIF;\n    }\n    if ((options & (LYD_OPT_NOTIF | LYD_OPT_NOTIF_FILTER)) && *node && ((*node)->schema->nodetype != LYS_NOTIF)) {\n        options |= LYD_OPT_ACT_NOTIF;\n    }\n\n    LY_TREE_FOR_SAFE(*node, next1, root) {\n        if (modules) {\n            for (i = 0; i < (unsigned)mod_count; ++i) {\n                if (lyd_node_module(root) == modules[i]) {\n                    break;\n                }\n            }\n            if (i == (unsigned)mod_count) {\n                /* skip data that should not be validated */\n                continue;\n            }\n        }\n\n        LY_TREE_DFS_BEGIN(root, next2, iter) {\n            if (iter->parent && (iter->schema->nodetype & (LYS_ACTION | LYS_NOTIF))) {\n                if (!(options & LYD_OPT_ACT_NOTIF) || act_notif) {\n                    LOGVAL(ctx, LYE_INELEM, LY_VLOG_LYD, iter, iter->schema->name);\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Unexpected %s node \\\"%s\\\".\",\n                           (options & LYD_OPT_RPC ? \"action\" : \"notification\"), iter->schema->name);\n                    goto cleanup;\n                }\n                act_notif = iter;\n            }\n\n            if (lyv_data_context(iter, options, unres) || lyv_data_content(iter, options, unres)) {\n                goto cleanup;\n            }\n\n            /* basic validation successful */\n            iter->validity &= ~LYD_VAL_MAND;\n\n            /* empty non-default, non-presence container without attributes, make it default */\n            if (!iter->dflt && (iter->schema->nodetype == LYS_CONTAINER) && !iter->child\n                        && !((struct lys_node_container *)iter->schema)->presence && !iter->attr) {\n                iter->dflt = 1;\n            }\n\n            LY_TREE_DFS_END(root, next2, iter);\n        }\n\n        if (options & LYD_OPT_NOSIBLINGS) {\n            break;\n        }\n\n    }\n\n    if (options & LYD_OPT_ACT_NOTIF) {\n        if (!act_notif) {\n            LOGVAL(ctx, LYE_MISSELEM, LY_VLOG_LYD, *node, (options & LYD_OPT_RPC ? \"action\" : \"notification\"), (*node)->schema->name);\n            goto cleanup;\n        }\n        options &= ~LYD_OPT_ACT_NOTIF;\n    }\n\n    if (*node) {\n        /* check for uniqueness of top-level lists/leaflists because\n         * only the inner instances were tested in lyv_data_content() */\n        yanglib_mod = ly_ctx_get_module(ctx ? ctx : (*node)->schema->module->ctx, \"ietf-yang-library\", NULL, 1);\n        LY_TREE_FOR(*node, root) {\n            if ((options & LYD_OPT_DATA_ADD_YANGLIB) && yanglib_mod && (root->schema->module == yanglib_mod)) {\n                /* ietf-yang-library data present, so ignore the option to add them */\n                options &= ~LYD_OPT_DATA_ADD_YANGLIB;\n            }\n\n            if (!(root->schema->nodetype & (LYS_LIST | LYS_LEAFLIST)) || !(root->validity & LYD_VAL_DUP)) {\n                continue;\n            }\n\n            if (options & LYD_OPT_TRUSTED) {\n                /* just clear the flag */\n                root->validity &= ~LYD_VAL_DUP;\n                continue;\n            }\n\n            if (lyv_data_dup(root, *node)) {\n                goto cleanup;\n            }\n        }\n    }\n\n    /* add missing ietf-yang-library if requested */\n    if (options & LYD_OPT_DATA_ADD_YANGLIB) {\n        if (!(*node)) {\n            (*node) = ly_ctx_info(ctx);\n        } else if (lyd_merge((*node), ly_ctx_info(ctx), LYD_OPT_DESTRUCT | LYD_OPT_EXPLICIT)) {\n            LOGERR(ctx, LY_EINT, \"Adding ietf-yang-library data failed.\");\n            goto cleanup;\n        }\n    }\n\n    /* add default values, resolve unres and check for mandatory nodes in final tree */\n    if (lyd_defaults_add_unres(node, options, ctx, modules, mod_count, data_tree, act_notif, unres, 1)) {\n        goto cleanup;\n    }\n    if (act_notif) {\n        if (lyd_check_mandatory_tree(act_notif, ctx, modules, mod_count, options)) {\n            goto cleanup;\n        }\n    } else {\n        if (lyd_check_mandatory_tree(*node, ctx, modules, mod_count, options)) {\n            goto cleanup;\n        }\n    }\n\n    /* consolidate diff if created */\n    if (diff) {\n        assert(unres->store_diff);\n\n        for (i = 0; i < unres->diff_idx; ++i) {\n            if (unres->diff->type[i] == LYD_DIFF_CREATED) {\n                if (unres->diff->second[i]->parent) {\n                    unres->diff->first[i] = (struct lyd_node *)lyd_path(unres->diff->second[i]->parent);\n                }\n                unres->diff->second[i] = lyd_dup(unres->diff->second[i], LYD_DUP_OPT_RECURSIVE);\n            }\n        }\n\n        *diff = unres->diff;\n        unres->diff = 0;\n        unres->diff_idx = 0;\n    }\n\n    ret = EXIT_SUCCESS;\n\ncleanup:\n    if (unres) {\n        free(unres->node);\n        free(unres->type);\n        for (i = 0; i < unres->diff_idx; ++i) {\n            if (unres->diff->type[i] == LYD_DIFF_DELETED) {\n                lyd_free_withsiblings(unres->diff->first[i]);\n                free(unres->diff->second[i]);\n            }\n        }\n        lyd_free_diff(unres->diff);\n        free(unres);\n    }\n\n    return ret;\n}\n\nAPI int\nlyd_validate(struct lyd_node **node, int options, void *var_arg, ...)\n{\n    struct lyd_node *iter, *data_tree = NULL;\n    struct lyd_difflist **diff = NULL;\n    struct ly_ctx *ctx = NULL;\n    va_list ap;\n\n    if (!node) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    if (lyp_data_check_options(NULL, options, __func__)) {\n        return EXIT_FAILURE;\n    }\n\n    data_tree = *node;\n\n    if ((!(options & LYD_OPT_TYPEMASK)\n            || (options & (LYD_OPT_CONFIG | LYD_OPT_GET | LYD_OPT_GETCONFIG | LYD_OPT_EDIT))) && !(*node)) {\n        /* get context with schemas from the var_arg */\n        ctx = (struct ly_ctx *)var_arg;\n        if (!ctx) {\n            LOGERR(NULL, LY_EINVAL, \"%s: invalid variable parameter (struct ly_ctx *ctx).\", __func__);\n            return EXIT_FAILURE;\n        }\n\n        /* LYD_OPT_NOSIBLINGS has no meaning here */\n        options &= ~LYD_OPT_NOSIBLINGS;\n    } else if (options & (LYD_OPT_RPC | LYD_OPT_RPCREPLY | LYD_OPT_NOTIF)) {\n        /* LYD_OPT_NOSIBLINGS cannot be set in this case */\n        if (options & LYD_OPT_NOSIBLINGS) {\n            LOGERR(NULL, LY_EINVAL, \"%s: invalid parameter (variable arg const struct lyd_node *data_tree with LYD_OPT_NOSIBLINGS).\", __func__);\n            return EXIT_FAILURE;\n        } else if (!(*node)) {\n            LOGARG;\n            return EXIT_FAILURE;\n        }\n\n        /* get the additional data tree if given */\n        data_tree = (struct lyd_node *)var_arg;\n        if (data_tree) {\n            if (options & LYD_OPT_NOEXTDEPS) {\n                LOGERR(NULL, LY_EINVAL, \"%s: invalid parameter (variable arg const struct lyd_node *data_tree and LYD_OPT_NOEXTDEPS set).\",\n                       __func__);\n                return EXIT_FAILURE;\n            }\n\n            LY_TREE_FOR(data_tree, iter) {\n                if (iter->parent) {\n                    /* a sibling is not top-level */\n                    LOGERR(NULL, LY_EINVAL, \"%s: invalid variable parameter (const struct lyd_node *data_tree).\", __func__);\n                    return EXIT_FAILURE;\n                }\n            }\n\n            /* move it to the beginning */\n            for (; data_tree->prev->next; data_tree = data_tree->prev);\n        }\n    } else if (options & LYD_OPT_DATA_TEMPLATE) {\n        /* get context with schemas from the var_arg */\n        if (*node && ((*node)->prev->next || (*node)->next)) {\n            /* not allow sibling in top-level */\n            LOGERR(NULL, LY_EINVAL, \"%s: invalid variable parameter (struct lyd_node *node).\", __func__);\n            return EXIT_FAILURE;\n        }\n    }\n\n    if (options & LYD_OPT_VAL_DIFF) {\n        va_start(ap, var_arg);\n        diff = va_arg(ap, struct lyd_difflist **);\n        va_end(ap);\n        if (!diff) {\n            LOGERR(ctx, LY_EINVAL, \"%s: invalid variable parameter (struct lyd_difflist **).\", __func__);\n            return EXIT_FAILURE;\n        }\n    }\n\n    if (*node) {\n        if (!ctx) {\n            ctx = (*node)->schema->module->ctx;\n        }\n        if (!(options & LYD_OPT_NOSIBLINGS)) {\n            /* check that the node is the first sibling */\n            while ((*node)->prev->next) {\n                *node = (*node)->prev;\n            }\n        }\n    }\n\n    return _lyd_validate(node, data_tree, ctx, NULL, 0, diff, options);\n}\n\nAPI int\nlyd_validate_modules(struct lyd_node **node, const struct lys_module **modules, int mod_count, int options, ...)\n{\n    struct ly_ctx *ctx;\n    struct lyd_difflist **diff = NULL;\n    va_list ap;\n\n    if (!node || !modules || !mod_count) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    ctx = modules[0]->ctx;\n\n    if (*node && !(options & LYD_OPT_NOSIBLINGS)) {\n        /* check that the node is the first sibling */\n        while ((*node)->prev->next) {\n            *node = (*node)->prev;\n        }\n    }\n\n    if (lyp_data_check_options(ctx, options, __func__)) {\n        return EXIT_FAILURE;\n    }\n\n    if ((options & LYD_OPT_TYPEMASK) && !(options & (LYD_OPT_CONFIG | LYD_OPT_GET | LYD_OPT_GETCONFIG | LYD_OPT_EDIT))) {\n        LOGERR(NULL, LY_EINVAL, \"%s: options include a forbidden data type.\", __func__);\n        return EXIT_FAILURE;\n    }\n\n    if (options & LYD_OPT_VAL_DIFF) {\n        va_start(ap, options);\n        diff = va_arg(ap, struct lyd_difflist **);\n        va_end(ap);\n        if (!diff) {\n            LOGERR(ctx, LY_EINVAL, \"%s: invalid variable parameter (struct lyd_difflist **).\", __func__);\n            return EXIT_FAILURE;\n        }\n    }\n\n    return _lyd_validate(node, *node, ctx, modules, mod_count, diff, options);\n}\n\nAPI int\nlyd_validate_value(struct lys_node *node, const char *value)\n{\n    struct lyd_node_leaf_list leaf;\n    struct lys_node_leaf *sleaf = (struct lys_node_leaf*)node;\n    int ret = EXIT_SUCCESS;\n\n    if (!node || !(node->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    if (!value) {\n        value = \"\";\n    }\n\n    /* dummy leaf */\n    memset(&leaf, 0, sizeof leaf);\n    leaf.value_str = lydict_insert(node->module->ctx, value, 0);\n\nrepeat:\n    leaf.value_type = sleaf->type.base;\n    leaf.schema = node;\n\n    if (leaf.value_type == LY_TYPE_LEAFREF) {\n        if (!sleaf->type.info.lref.target) {\n            /* it should either be unresolved leafref (leaf.value_type are ORed flags) or it will be resolved */\n            LOGINT(node->module->ctx);\n            ret = EXIT_FAILURE;\n            goto cleanup;\n        }\n        sleaf = sleaf->type.info.lref.target;\n        goto repeat;\n    } else {\n        if (!lyp_parse_value(&sleaf->type, &leaf.value_str, NULL, &leaf, NULL, NULL, 0, 0, 0)) {\n            ret = EXIT_FAILURE;\n            goto cleanup;\n        }\n    }\n\ncleanup:\n    lydict_remove(node->module->ctx, leaf.value_str);\n    return ret;\n}\n\n/* create an attribute copy */\nstatic struct lyd_attr *\nlyd_dup_attr(struct ly_ctx *ctx, struct lyd_node *parent, struct lyd_attr *attr)\n{\n    struct lyd_attr *ret;\n\n    /* allocate new attr */\n    if (!parent->attr) {\n        parent->attr = malloc(sizeof *parent->attr);\n        ret = parent->attr;\n    } else {\n        for (ret = parent->attr; ret->next; ret = ret->next);\n        ret->next = calloc(1, sizeof *ret);\n        ret = ret->next;\n    }\n    LY_CHECK_ERR_RETURN(!ret, LOGMEM(ctx), NULL);\n\n    /* fill new attr except */\n    ret->parent = parent;\n    ret->next = NULL;\n    ret->annotation = attr->annotation;\n    ret->name = lydict_insert(ctx, attr->name, 0);\n    ret->value_str = lydict_insert(ctx, attr->value_str, 0);\n    ret->value_type = attr->value_type;\n    ret->value_flags = attr->value_flags;\n    switch (ret->value_type) {\n    case LY_TYPE_BINARY:\n    case LY_TYPE_STRING:\n        /* value_str pointer is shared in these cases */\n        ret->value.string = ret->value_str;\n        break;\n    case LY_TYPE_LEAFREF:\n        lyp_parse_value(*((struct lys_type **)lys_ext_complex_get_substmt(LY_STMT_TYPE, ret->annotation, NULL)),\n                             &ret->value_str, NULL, NULL, ret, NULL, 1, 0, 0);\n        break;\n    case LY_TYPE_INST:\n        ret->value.instance = NULL;\n        break;\n    case LY_TYPE_UNION:\n        /* unresolved union (this must be non-validated tree), duplicate the stored string (duplicated\n         * because of possible change of the value in case of instance-identifier) */\n        ret->value.string = lydict_insert(ctx, attr->value.string, 0);\n        break;\n    case LY_TYPE_ENUM:\n    case LY_TYPE_IDENT:\n    case LY_TYPE_BITS:\n        /* in case of duplicating bits (no matter if in the same context or not) or enum and identityref into\n         * a different context, searching for the type and duplicating the data is almost as same as resolving\n         * the string value, so due to a simplicity, parse the value for the duplicated leaf */\n        lyp_parse_value(*((struct lys_type **)lys_ext_complex_get_substmt(LY_STMT_TYPE, ret->annotation, NULL)),\n                             &ret->value_str, NULL, NULL, ret, NULL, 1, 0, 0);\n        break;\n    default:\n        ret->value = attr->value;\n        break;\n    }\n    return ret;\n}\n\nint\nlyd_unlink_internal(struct lyd_node *node, int permanent)\n{\n    struct lyd_node *iter;\n\n    if (!node) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    if (permanent) {\n        check_leaf_list_backlinks(node, 1);\n    }\n\n    /* unlink from siblings */\n    if (node->prev->next) {\n        node->prev->next = node->next;\n    }\n    if (node->next) {\n        node->next->prev = node->prev;\n    } else {\n        /* unlinking the last node */\n        if (node->parent) {\n            iter = node->parent->child;\n        } else {\n            iter = node->prev;\n            while (iter->prev != node) {\n                iter = iter->prev;\n            }\n        }\n        /* update the \"last\" pointer from the first node */\n        iter->prev = node->prev;\n    }\n\n    /* unlink from parent */\n    if (node->parent) {\n        if (node->parent->child == node) {\n            /* the node is the first child */\n            node->parent->child = node->next;\n        }\n\n#ifdef LY_ENABLED_CACHE\n        /* do not remove from parent hash table if freeing the whole subtree */\n        if (permanent != 2) {\n            lyd_unlink_hash(node, node->parent);\n        }\n#endif\n\n        node->parent = NULL;\n    }\n\n    node->next = NULL;\n    node->prev = node;\n\n    return EXIT_SUCCESS;\n}\n\nAPI int\nlyd_unlink(struct lyd_node *node)\n{\n    return lyd_unlink_internal(node, 1);\n}\n\n/*\n * - in leaflist it must be added with value_str\n */\nstatic int\n_lyd_dup_node_common(struct lyd_node *new_node, const struct lyd_node *orig, struct ly_ctx *ctx, int options)\n{\n    struct lyd_attr *attr;\n\n    new_node->attr = NULL;\n    if (!(options & LYD_DUP_OPT_NO_ATTR)) {\n        LY_TREE_FOR(orig->attr, attr) {\n            lyd_dup_attr(ctx, new_node, attr);\n        }\n    }\n    new_node->next = NULL;\n    new_node->prev = new_node;\n    new_node->parent = NULL;\n    new_node->validity = ly_new_node_validity(new_node->schema);\n    new_node->dflt = orig->dflt;\n    new_node->when_status = orig->when_status & LYD_WHEN;\n#ifdef LY_ENABLED_CACHE\n    /* just copy the hash, it will not change */\n    if ((new_node->schema->nodetype != LYS_LIST) || lyd_list_has_keys(new_node)) {\n        new_node->hash = orig->hash;\n    }\n#endif\n\n#ifdef LY_ENABLED_LYD_PRIV\n    if (ctx->priv_dup_clb) {\n        new_node->priv = ctx->priv_dup_clb(orig->priv);\n    }\n#endif\n\n    return EXIT_SUCCESS;\n}\n\nstatic struct lyd_node *\n_lyd_dup_node(const struct lyd_node *node, const struct lys_node *schema, struct ly_ctx *ctx, int options)\n{\n    struct lyd_node *new_node = NULL;\n    struct lys_node_leaf *sleaf;\n    struct lyd_node_leaf_list *new_leaf;\n    struct lyd_node_anydata *new_any, *old_any;\n    int r;\n\n    /* fill specific part */\n    switch (node->schema->nodetype) {\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n        new_leaf = calloc(1, sizeof *new_leaf);\n        new_node = (struct lyd_node *)new_leaf;\n        LY_CHECK_ERR_GOTO(!new_node, LOGMEM(ctx), error);\n        new_node->schema = (struct lys_node *)schema;\n\n        new_leaf->value_str = lydict_insert(ctx, ((struct lyd_node_leaf_list *)node)->value_str, 0);\n        new_leaf->value_type = ((struct lyd_node_leaf_list *)node)->value_type;\n        new_leaf->value_flags = ((struct lyd_node_leaf_list *)node)->value_flags;\n        if (_lyd_dup_node_common(new_node, node, ctx, options)) {\n            goto error;\n        }\n\n        /* get schema from the correct context */\n        sleaf = (struct lys_node_leaf *)new_leaf->schema;\n\n        switch (new_leaf->value_type) {\n        case LY_TYPE_BINARY:\n        case LY_TYPE_STRING:\n            /* value_str pointer is shared in these cases */\n            new_leaf->value.string = new_leaf->value_str;\n            break;\n        case LY_TYPE_LEAFREF:\n            new_leaf->validity |= LYD_VAL_LEAFREF;\n            lyp_parse_value(&sleaf->type, &new_leaf->value_str, NULL, new_leaf, NULL, NULL, 1, node->dflt, 0);\n            break;\n        case LY_TYPE_INST:\n            new_leaf->value.instance = NULL;\n            break;\n        case LY_TYPE_UNION:\n            /* unresolved union (this must be non-validated tree), duplicate the stored string (duplicated\n             * because of possible change of the value in case of instance-identifier) */\n            new_leaf->value.string = lydict_insert(ctx, ((struct lyd_node_leaf_list *)node)->value.string, 0);\n            break;\n        case LY_TYPE_ENUM:\n        case LY_TYPE_IDENT:\n        case LY_TYPE_BITS:\n            /* in case of duplicating bits (no matter if in the same context or not) or enum and identityref into\n             * a different context, searching for the type and duplicating the data is almost as same as resolving\n             * the string value, so due to a simplicity, parse the value for the duplicated leaf */\n            if (!lyp_parse_value(&sleaf->type, &new_leaf->value_str, NULL, new_leaf, NULL, NULL, 1, node->dflt, 0)) {\n                goto error;\n            }\n            break;\n        default:\n            new_leaf->value = ((struct lyd_node_leaf_list *)node)->value;\n            break;\n        }\n\n        if (sleaf->type.der && sleaf->type.der->module) {\n            r = lytype_store(sleaf->type.der->module, sleaf->type.der->name, new_leaf->value_str, &new_leaf->value);\n            if (r == -1) {\n                goto error;\n            } else if (!r) {\n                new_leaf->value_flags |= LY_VALUE_USER;\n            }\n        }\n        break;\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        old_any = (struct lyd_node_anydata *)node;\n        new_any = calloc(1, sizeof *new_any);\n        new_node = (struct lyd_node *)new_any;\n        LY_CHECK_ERR_GOTO(!new_node, LOGMEM(ctx), error);\n        new_node->schema = (struct lys_node *)schema;\n\n        if (_lyd_dup_node_common(new_node, node, ctx, options)) {\n            goto error;\n        }\n\n        new_any->value_type = old_any->value_type;\n        if (!(void*)old_any->value.tree) {\n            /* no value to duplicate */\n            break;\n        }\n        /* duplicate the value */\n        switch (old_any->value_type) {\n        case LYD_ANYDATA_CONSTSTRING:\n        case LYD_ANYDATA_SXML:\n        case LYD_ANYDATA_JSON:\n            new_any->value.str = lydict_insert(ctx, old_any->value.str, 0);\n            break;\n        case LYD_ANYDATA_DATATREE:\n            new_any->value.tree = lyd_dup_to_ctx(old_any->value.tree, 1, ctx);\n            break;\n        case LYD_ANYDATA_XML:\n            new_any->value.xml = lyxml_dup_elem(ctx, old_any->value.xml, NULL, 1);\n            break;\n        case LYD_ANYDATA_LYB:\n            r = lyd_lyb_data_length(old_any->value.mem);\n            if (r == -1) {\n                LOGERR(ctx, LY_EINVAL, \"Invalid LYB data.\");\n                goto error;\n            }\n            new_any->value.mem = malloc(r);\n            LY_CHECK_ERR_GOTO(!new_any->value.mem, LOGMEM(ctx), error);\n            memcpy(new_any->value.mem, old_any->value.mem, r);\n            break;\n        case LYD_ANYDATA_STRING:\n        case LYD_ANYDATA_SXMLD:\n        case LYD_ANYDATA_JSOND:\n        case LYD_ANYDATA_LYBD:\n            /* dynamic strings are used only as input parameters */\n            assert(0);\n            break;\n        }\n        break;\n    case LYS_CONTAINER:\n    case LYS_LIST:\n    case LYS_NOTIF:\n    case LYS_RPC:\n    case LYS_ACTION:\n        new_node = calloc(1, sizeof *new_node);\n        LY_CHECK_ERR_GOTO(!new_node, LOGMEM(ctx), error);\n        new_node->schema = (struct lys_node *)schema;\n\n        if (_lyd_dup_node_common(new_node, node, ctx, options)) {\n            goto error;\n        }\n        break;\n    default:\n        LOGINT(ctx);\n        goto error;\n    }\n\n    return new_node;\n\nerror:\n    lyd_free(new_node);\n    return NULL;\n}\n\nAPI struct lyd_node *\nlyd_dup_to_ctx(const struct lyd_node *node, int options, struct ly_ctx *ctx)\n{\n    struct ly_ctx *log_ctx;\n    struct lys_node_list *slist;\n    struct lys_node *schema;\n    const char *yang_data_name;\n    const struct lys_module *trg_mod;\n    const struct lyd_node *next, *elem;\n    struct lyd_node *ret, *parent, *key, *key_dup, *new_node = NULL;\n    uint16_t i;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    log_ctx = (ctx ? ctx : node->schema->module->ctx);\n    if (ctx == node->schema->module->ctx) {\n        /* target context is actually the same as the source context,\n         * ignore the target context */\n        ctx = NULL;\n    }\n\n    ret = NULL;\n    parent = NULL;\n\n    /* LY_TREE_DFS */\n    for (elem = next = node; elem; elem = next) {\n\n        /* find the correct schema */\n        if (ctx) {\n            schema = NULL;\n            if (parent) {\n                trg_mod = lyp_get_module(parent->schema->module, NULL, 0, lyd_node_module(elem)->name,\n                                         strlen(lyd_node_module(elem)->name), 1);\n                if (!trg_mod) {\n                    LOGERR(log_ctx, LY_EINVAL, \"Target context does not contain model for the data node being duplicated (%s).\",\n                                lyd_node_module(elem)->name);\n                    goto error;\n                }\n                /* we know its parent, so we can start with it */\n                lys_getnext_data(trg_mod, parent->schema, elem->schema->name, strlen(elem->schema->name),\n                                 elem->schema->nodetype, (const struct lys_node **)&schema);\n            } else {\n                /* we have to search in complete context */\n                schema = lyd_get_schema_inctx(elem, ctx);\n            }\n\n            if (!schema) {\n                yang_data_name = lyp_get_yang_data_template_name(elem);\n                if (yang_data_name) {\n                    LOGERR(log_ctx, LY_EINVAL, \"Target context does not contain schema node for the data node being duplicated \"\n                                        \"(%s:#%s/%s).\", lyd_node_module(elem)->name, yang_data_name, elem->schema->name);\n                } else {\n                    LOGERR(log_ctx, LY_EINVAL, \"Target context does not contain schema node for the data node being duplicated \"\n                                        \"(%s:%s).\", lyd_node_module(elem)->name, elem->schema->name);\n                }\n                goto error;\n            }\n        } else {\n            schema = elem->schema;\n        }\n\n        /* make node copy */\n        new_node = _lyd_dup_node(elem, schema, log_ctx, options);\n        if (!new_node) {\n            goto error;\n        }\n\n        if (parent && lyd_insert(parent, new_node)) {\n            goto error;\n        }\n\n        if (!ret) {\n            ret = new_node;\n        }\n\n        if (!(options & LYD_DUP_OPT_RECURSIVE)) {\n            break;\n        }\n\n        /* LY_TREE_DFS_END */\n        /* select element for the next run - children first,\n         * child exception for lyd_node_leaf and lyd_node_leaflist */\n        if (elem->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n            next = NULL;\n        } else {\n            next = elem->child;\n        }\n        if (!next) {\n            if (elem->parent == node->parent) {\n                break;\n            }\n            /* no children, so try siblings */\n            next = elem->next;\n        } else {\n            parent = new_node;\n        }\n        new_node = NULL;\n\n        while (!next) {\n            /* no siblings, go back through parents */\n            elem = elem->parent;\n            if (elem->parent == node->parent) {\n                break;\n            }\n            if (!parent) {\n                LOGINT(log_ctx);\n                goto error;\n            }\n            parent = parent->parent;\n            /* parent is already processed, go to its sibling */\n            next = elem->next;\n        }\n    }\n\n    /* dup all the parents */\n    if (options & LYD_DUP_OPT_WITH_PARENTS) {\n        parent = ret;\n        for (elem = node->parent; elem; elem = elem->parent) {\n            new_node = lyd_dup(elem, options & LYD_DUP_OPT_NO_ATTR);\n            LY_CHECK_ERR_GOTO(!new_node, LOGMEM(log_ctx), error);\n\n            /* dup all list keys */\n            if (new_node->schema->nodetype == LYS_LIST) {\n                slist = (struct lys_node_list *)new_node->schema;\n                for (key = elem->child, i = 0; key && (i < slist->keys_size); ++i, key = key->next) {\n                    if (key->schema != (struct lys_node *)slist->keys[i]) {\n                        LOGVAL(log_ctx, LYE_PATH_INKEY, LY_VLOG_LYD, new_node, slist->keys[i]->name);\n                        goto error;\n                    }\n\n                    key_dup = lyd_dup(key, options & LYD_DUP_OPT_NO_ATTR);\n                    LY_CHECK_ERR_GOTO(!key_dup, LOGMEM(log_ctx), error);\n\n                    if (lyd_insert(new_node, key_dup)) {\n                        lyd_free(key_dup);\n                        goto error;\n                    }\n                }\n                if (!key && (i < slist->keys_size)) {\n                    LOGVAL(log_ctx, LYE_PATH_INKEY, LY_VLOG_LYD, new_node, slist->keys[i]->name);\n                    goto error;\n                }\n            }\n\n            /* link together */\n            if (lyd_insert(new_node, parent)) {\n                ret = parent;\n                goto error;\n            }\n            parent = new_node;\n        }\n    }\n\n    return ret;\n\nerror:\n    lyd_free(ret);\n    return NULL;\n}\n\nAPI struct lyd_node *\nlyd_dup(const struct lyd_node *node, int options)\n{\n    return lyd_dup_to_ctx(node, options, NULL);\n}\n\nstatic struct lyd_node *\nlyd_dup_withsiblings_r(const struct lyd_node *first, struct lyd_node *parent_dup, int options)\n{\n    struct lyd_node *first_dup = NULL, *prev_dup = NULL, *last_dup;\n    const struct lyd_node *next;\n\n    assert(first);\n\n    /* duplicate and connect all siblings */\n    LY_TREE_FOR(first, next) {\n        last_dup = _lyd_dup_node(next, next->schema, next->schema->module->ctx, options);\n        if (!last_dup) {\n            goto error;\n        }\n\n        /* the whole data tree is exactly the same so we can safely copy the validation flags */\n        last_dup->validity = next->validity;\n        last_dup->when_status = next->when_status;\n\n        last_dup->parent = parent_dup;\n        if (!first_dup) {\n            first_dup = last_dup;\n        } else {\n            assert(prev_dup);\n            prev_dup->next = last_dup;\n            last_dup->prev = prev_dup;\n        }\n\n        if ((next->schema->nodetype & (LYS_LIST | LYS_CONTAINER | LYS_RPC | LYS_ACTION | LYS_NOTIF)) && next->child) {\n            /* recursively duplicate all children */\n            if (!lyd_dup_withsiblings_r(next->child, last_dup, options)) {\n                goto error;\n            }\n        }\n\n        prev_dup = last_dup;\n    }\n\n    /* correctly set last sibling and parent child pointer */\n    assert(!prev_dup->next);\n    first_dup->prev = prev_dup;\n    if (parent_dup) {\n        parent_dup->child = first_dup;\n    }\n\n    return first_dup;\n\nerror:\n    /* disconnect and free */\n    first_dup->parent = NULL;\n    lyd_free_withsiblings(first_dup);\n    return NULL;\n}\n\nAPI struct lyd_node *\nlyd_dup_withsiblings(const struct lyd_node *node, int options)\n{\n    const struct lyd_node *iter;\n    struct lyd_node *ret, *ret_iter, *tmp;\n\n    if (!node) {\n        return NULL;\n    }\n\n    /* find first sibling */\n    while (node->prev->next) {\n        node = node->prev;\n    }\n\n    if (node->parent) {\n        ret = lyd_dup(node, options);\n        if (!ret) {\n            return NULL;\n        }\n\n        /* copy following siblings */\n        ret_iter = ret;\n        LY_TREE_FOR(node->next, iter) {\n            tmp = lyd_dup(iter, options);\n            if (!tmp) {\n                lyd_free_withsiblings(ret);\n                return NULL;\n            }\n\n            if (lyd_insert_after(ret_iter, tmp)) {\n                lyd_free_withsiblings(ret);\n                return NULL;\n            }\n            ret_iter = ret_iter->next;\n            assert(ret_iter == tmp);\n        }\n    } else {\n        /* duplicating top-level siblings, we can duplicate much more efficiently */\n        ret = lyd_dup_withsiblings_r(node, NULL, options);\n    }\n\n    return ret;\n}\n\nAPI void\nlyd_free_attr(struct ly_ctx *ctx, struct lyd_node *parent, struct lyd_attr *attr, int recursive)\n{\n    struct lyd_attr *iter;\n    struct lys_type **type;\n\n    if (!ctx || !attr) {\n        return;\n    }\n\n    if (parent) {\n        if (parent->attr == attr) {\n            if (recursive) {\n                parent->attr = NULL;\n            } else {\n                parent->attr = attr->next;\n            }\n        } else {\n            for (iter = parent->attr; iter->next != attr; iter = iter->next);\n            if (iter->next) {\n                if (recursive) {\n                    iter->next = NULL;\n                } else {\n                    iter->next = attr->next;\n                }\n            }\n        }\n    }\n\n    if (!recursive) {\n        attr->next = NULL;\n    }\n\n    for(iter = attr; iter; ) {\n        attr = iter;\n        iter = iter->next;\n\n        lydict_remove(ctx, attr->name);\n        type = lys_ext_complex_get_substmt(LY_STMT_TYPE, attr->annotation, NULL);\n        assert(type);\n        lyd_free_value(attr->value, attr->value_type, attr->value_flags, *type, NULL, NULL, NULL);\n        lydict_remove(ctx, attr->value_str);\n        free(attr);\n    }\n}\n\nconst struct lyd_node *\nlyd_attr_parent(const struct lyd_node *root, struct lyd_attr *attr)\n{\n    const struct lyd_node *next, *elem;\n    struct lyd_attr *node_attr;\n\n    LY_TREE_DFS_BEGIN(root, next, elem) {\n        for (node_attr = elem->attr; node_attr; node_attr = node_attr->next) {\n            if (node_attr == attr) {\n                return elem;\n            }\n        }\n        LY_TREE_DFS_END(root, next, elem)\n    }\n\n    return NULL;\n}\n\nAPI struct lyd_attr *\nlyd_insert_attr(struct lyd_node *parent, const struct lys_module *mod, const char *name, const char *value)\n{\n    struct lyd_attr *a, *iter;\n    struct ly_ctx *ctx;\n    const struct lys_module *module;\n    const char *p;\n    char *aux;\n    int pos, i;\n\n    if (!parent || !name || !value) {\n        LOGARG;\n        return NULL;\n    }\n    ctx = parent->schema->module->ctx;\n\n    if ((p = strchr(name, ':'))) {\n        /* search for the namespace */\n        aux = strndup(name, p - name);\n        if (!aux) {\n            LOGMEM(ctx);\n            return NULL;\n        }\n        module = ly_ctx_get_module(ctx, aux, NULL, 1);\n        free(aux);\n        name = p + 1;\n\n        if (!module) {\n            /* module not found */\n            LOGERR(ctx, LY_EINVAL, \"Attribute prefix does not match any implemented schema in the context.\");\n            return NULL;\n        }\n    } else if (mod) {\n        module = mod;\n    } else if (!mod && (!strcmp(name, \"type\") || !strcmp(name, \"select\")) && !strcmp(parent->schema->name, \"filter\")) {\n        /* special case of inserting unqualified filter attributes \"type\" and \"select\" */\n        module = ly_ctx_get_module(ctx, \"ietf-netconf\", NULL, 1);\n        if (!module) {\n            LOGERR(ctx, LY_EINVAL, \"Attribute prefix does not match any implemented schema in the context.\");\n            return NULL;\n        }\n    } else {\n        /* no prefix -> module is the same as for the parent */\n        module = lyd_node_module(parent);\n    }\n\n    pos = -1;\n    do {\n        if ((unsigned int)(pos + 1) < module->ext_size) {\n            i = lys_ext_instance_presence(&ctx->models.list[0]->extensions[0],\n                                          &module->ext[pos + 1], module->ext_size - (pos + 1));\n            pos = (i == -1) ? -1 : pos + 1 + i;\n        } else {\n            pos = -1;\n        }\n        if (pos == -1) {\n            LOGERR(ctx, LY_EINVAL, \"Attribute does not match any annotation instance definition.\");\n            return NULL;\n        }\n    } while (!ly_strequal(module->ext[pos]->arg_value, name, 0));\n\n    a = calloc(1, sizeof *a);\n    LY_CHECK_ERR_RETURN(!a, LOGMEM(ctx), NULL);\n    a->parent = parent;\n    a->next = NULL;\n    a->annotation = (struct lys_ext_instance_complex *)module->ext[pos];\n    a->name = lydict_insert(ctx, name, 0);\n    a->value_str = lydict_insert(ctx, value, 0);\n    if (!lyp_parse_value(*((struct lys_type **)lys_ext_complex_get_substmt(LY_STMT_TYPE, a->annotation, NULL)),\n                         &a->value_str, NULL, NULL, a, NULL, 1, 0, 0)) {\n        lyd_free_attr(ctx, NULL, a, 0);\n        return NULL;\n    }\n\n    if (!parent->attr) {\n        parent->attr = a;\n    } else {\n        for (iter = parent->attr; iter->next; iter = iter->next);\n        iter->next = a;\n    }\n\n    return a;\n}\n\nvoid\nlyd_free_value(lyd_val value, LY_DATA_TYPE value_type, uint8_t value_flags, struct lys_type *type, lyd_val *old_val,\n               LY_DATA_TYPE *old_val_type, uint8_t *old_val_flags)\n{\n    if (old_val) {\n        *old_val = value;\n        *old_val_type = value_type;\n        *old_val_flags = value_flags;\n        /* we only backup the values for now */\n        return;\n    }\n\n    /* otherwise the value is correctly freed */\n    if (value_flags & LY_VALUE_USER) {\n        assert(type->der && type->der->module);\n        lytype_free(type->der->module, type->der->name, value);\n    } else {\n        switch (value_type) {\n        case LY_TYPE_BITS:\n            if (value.bit) {\n                free(value.bit);\n            }\n            break;\n        case LY_TYPE_INST:\n            if (!(value_flags & LY_VALUE_UNRES)) {\n                break;\n            }\n            /* fallthrough */\n        case LY_TYPE_UNION:\n            /* unresolved union leaf */\n            lydict_remove(type->parent->module->ctx, value.string);\n            break;\n        default:\n            break;\n        }\n    }\n}\n\nstatic void\n_lyd_free_node(struct lyd_node *node)\n{\n    struct lyd_node_leaf_list *leaf;\n\n    if (!node) {\n        return;\n    }\n\n    switch (node->schema->nodetype) {\n    case LYS_CONTAINER:\n    case LYS_LIST:\n    case LYS_RPC:\n    case LYS_ACTION:\n    case LYS_NOTIF:\n#ifdef LY_ENABLED_CACHE\n        /* it should be empty because all the children are freed already (only if in debug mode) */\n        lyht_free(node->ht);\n#endif\n        break;\n    case LYS_ANYDATA:\n    case LYS_ANYXML:\n        switch (((struct lyd_node_anydata *)node)->value_type) {\n        case LYD_ANYDATA_CONSTSTRING:\n        case LYD_ANYDATA_SXML:\n        case LYD_ANYDATA_JSON:\n            lydict_remove(node->schema->module->ctx, ((struct lyd_node_anydata *)node)->value.str);\n            break;\n        case LYD_ANYDATA_DATATREE:\n            lyd_free_withsiblings(((struct lyd_node_anydata *)node)->value.tree);\n            break;\n        case LYD_ANYDATA_XML:\n            lyxml_free_withsiblings(node->schema->module->ctx, ((struct lyd_node_anydata *)node)->value.xml);\n            break;\n        case LYD_ANYDATA_LYB:\n            free(((struct lyd_node_anydata *)node)->value.mem);\n            break;\n        case LYD_ANYDATA_STRING:\n        case LYD_ANYDATA_SXMLD:\n        case LYD_ANYDATA_JSOND:\n        case LYD_ANYDATA_LYBD:\n            /* dynamic strings are used only as input parameters */\n            assert(0);\n            break;\n        }\n        break;\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n        leaf = (struct lyd_node_leaf_list *)node;\n        lyd_free_value(leaf->value, leaf->value_type, leaf->value_flags, &((struct lys_node_leaf *)leaf->schema)->type,\n                       NULL, NULL, NULL);\n        lydict_remove(leaf->schema->module->ctx, leaf->value_str);\n        break;\n    default:\n        assert(0);\n    }\n\n    lyd_free_attr(node->schema->module->ctx, node, node->attr, 1);\n    free(node);\n}\n\nstatic void\nlyd_free_internal_r(struct lyd_node *node, int top)\n{\n    struct lyd_node *next, *iter;\n\n    if (!node) {\n        return;\n    }\n\n    /* if freeing top-level, always remove it from the parent hash table */\n    lyd_unlink_internal(node, (top ? 1 : 2));\n\n    if (!(node->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA))) {\n        /* free children */\n        LY_TREE_FOR_SAFE(node->child, next, iter) {\n            lyd_free_internal_r(iter, 0);\n        }\n    }\n\n    _lyd_free_node(node);\n}\n\nAPI void\nlyd_free(struct lyd_node *node)\n{\n    lyd_free_internal_r(node, 1);\n}\n\nstatic void\nlyd_free_withsiblings_r(struct lyd_node *first)\n{\n    struct lyd_node *next, *node;\n\n    LY_TREE_FOR_SAFE(first, next, node) {\n        if (node->schema->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_RPC | LYS_ACTION | LYS_NOTIF)) {\n            lyd_free_withsiblings_r(node->child);\n        }\n        _lyd_free_node(node);\n    }\n}\n\nAPI void\nlyd_free_withsiblings(struct lyd_node *node)\n{\n    struct lyd_node *iter, *aux;\n\n    if (!node) {\n        return;\n    }\n\n    if (node->parent) {\n        /* optimization - avoid freeing (unlinking) the last node of the siblings list */\n        /* so, first, free the node's predecessors to the beginning of the list ... */\n        for(iter = node->prev; iter->next; iter = aux) {\n            aux = iter->prev;\n            lyd_free(iter);\n        }\n        /* ... then, the node is the first in the siblings list, so free them all */\n        LY_TREE_FOR_SAFE(node, aux, iter) {\n            lyd_free(iter);\n        }\n    } else {\n        /* node is top-level so we are freeing the whole data tree, we can just free nodes without any unlinking */\n        while (node->prev->next) {\n            /* find the first sibling */\n            node = node->prev;\n        }\n\n        /* free it all */\n        lyd_free_withsiblings_r(node);\n    }\n}\n\n/**\n * Expectations:\n * - list exists in data tree\n * - the leaf (defined by the unique_expr) is not instantiated under the list\n */\nint\nlyd_get_unique_default(const char* unique_expr, struct lyd_node *list, const char **dflt)\n{\n    struct ly_ctx *ctx = list->schema->module->ctx;\n    const struct lys_node *parent;\n    const struct lys_node_leaf *sleaf = NULL;\n    struct lys_tpdf *tpdf;\n    struct lyd_node *last, *node;\n    struct ly_set *s, *r;\n    unsigned int i;\n    enum int_log_opts prev_ilo;\n\n    assert(unique_expr && list && dflt);\n    *dflt = NULL;\n\n    if (resolve_descendant_schema_nodeid(unique_expr, list->schema->child, LYS_LEAF, 1, &parent) || !parent) {\n        /* error, but unique expression was checked when the schema was parsed so this should not happened */\n        LOGINT(ctx);\n        return -1;\n    }\n\n    sleaf = (struct lys_node_leaf *)parent;\n    if (sleaf->dflt) {\n        /* leaf has a default value */\n        *dflt = sleaf->dflt;\n    } else if (!(sleaf->flags & LYS_MAND_TRUE)) {\n        /* get the default value from the type */\n        for (tpdf = sleaf->type.der; tpdf && !(*dflt); tpdf = tpdf->type.der) {\n            *dflt = tpdf->dflt;\n        }\n    }\n\n    if (!(*dflt)) {\n        return 0;\n    }\n\n    /* it has default value, but check if it can appear in the data tree under the list */\n    s = ly_set_new();\n    for (parent = lys_parent((struct lys_node *)sleaf); parent != list->schema; parent = lys_parent(parent)) {\n        if (!(parent->nodetype & (LYS_CONTAINER | LYS_CASE | LYS_CHOICE | LYS_USES))) {\n            /* This should be already detected when parsing schema */\n            LOGINT(ctx);\n            ly_set_free(s);\n            return -1;\n        }\n        ly_set_add(s, (void *)parent, LY_SET_OPT_USEASLIST);\n    }\n\n    ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n    for (i = 0, last = list; i < s->number; i++) {\n        parent = s->set.s[i]; /* shortcut */\n\n        switch (parent->nodetype) {\n        case LYS_CONTAINER:\n            if (last) {\n                /* find instance in the data */\n                r = lyd_find_path(last, parent->name);\n                if (!r || r->number > 1) {\n                    ly_set_free(r);\n                    *dflt = NULL;\n                    goto end;\n                }\n                if (r->number) {\n                    last = r->set.d[0];\n                } else {\n                    last = NULL;\n                }\n                ly_set_free(r);\n            }\n            if (((struct lys_node_container *)parent)->presence) {\n                /* not-instantiated presence container on path */\n                *dflt = NULL;\n                goto end;\n            }\n            break;\n        case LYS_CHOICE :\n            /* check presence of another case */\n            if (!last) {\n                continue;\n            }\n\n            /* remember the case to be searched in choice by lyv_multicases() */\n            if (i + 1 == s->number) {\n                parent = (struct lys_node *)sleaf;\n            } else if (s->set.s[i + 1]->nodetype == LYS_CASE && (i + 2 < s->number) &&\n                    s->set.s[i + 2]->nodetype == LYS_CHOICE) {\n                /* nested choices are covered by lyv_multicases, we just have to pass\n                 * the lowest choice */\n                i++;\n                continue;\n            } else {\n                parent = s->set.s[i + 1];\n            }\n            node = last->child;\n            if (lyv_multicases(NULL, (struct lys_node *)parent, &node, 0, NULL)) {\n                /* another case is present */\n                *dflt = NULL;\n                goto end;\n            }\n            break;\n        default:\n            /* LYS_CASE, LYS_USES */\n            continue;\n        }\n    }\n\nend:\n    ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n    ly_set_free(s);\n    return 0;\n}\n\nAPI char *\nlyd_path(const struct lyd_node *node)\n{\n    char *buf = NULL;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (ly_vlog_build_path(LY_VLOG_LYD, node, &buf, 0, 0)) {\n        return NULL;\n    }\n\n    return buf;\n}\n\nint\nlyd_build_relative_data_path(const struct lys_module *module, const struct lyd_node *node, const char *schema_id,\n                             char *buf)\n{\n    const struct lys_node *snode, *schema;\n    const char *mod_name, *name;\n    int mod_name_len, name_len, len = 0;\n    int r, is_relative = -1;\n\n    assert(schema_id && buf);\n    schema = node->schema;\n\n    while (*schema_id) {\n        if ((r = parse_schema_nodeid(schema_id, &mod_name, &mod_name_len, &name, &name_len, &is_relative, NULL, NULL, 0)) < 1) {\n            LOGINT(module->ctx);\n            return -1;\n        }\n        schema_id += r;\n\n        snode = NULL;\n        while ((snode = lys_getnext(snode, schema, NULL, LYS_GETNEXT_WITHCHOICE | LYS_GETNEXT_WITHCASE | LYS_GETNEXT_NOSTATECHECK))) {\n            r = schema_nodeid_siblingcheck(snode, module, mod_name, mod_name_len, name, name_len);\n            if (r == 0) {\n                schema = snode;\n                break;\n            } else if (r == 1) {\n                continue;\n            } else {\n                return -1;\n            }\n        }\n        /* no match */\n        if (!snode || (!schema_id[0] && snode->nodetype != LYS_LEAF)) {\n            LOGINT(module->ctx);\n            return -1;\n        }\n\n        if (!(snode->nodetype & (LYS_CHOICE | LYS_CASE))) {\n            len += sprintf(&buf[len], \"%s%s\", (len ? \"/\" : \"\"), snode->name);\n        }\n    }\n\n    return len;\n}\n\nAPI struct ly_set *\nlyd_find_path(const struct lyd_node *ctx_node, const char *path)\n{\n    struct lyxp_set xp_set;\n    struct ly_set *set;\n    char *yang_xpath;\n    const char * node_mod_name, *mod_name, *name;\n    int mod_name_len, name_len, is_relative = -1;\n    uint32_t i;\n\n    if (!ctx_node || !path) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (parse_schema_nodeid(path, &mod_name, &mod_name_len, &name, &name_len, &is_relative, NULL, NULL, 1) > 0) {\n        if (name[0] == '#' && !is_relative) {\n            node_mod_name = lyd_node_module(ctx_node)->name;\n            if (strncmp(mod_name, node_mod_name, mod_name_len) || node_mod_name[mod_name_len]) {\n                return NULL;\n            }\n            path = name + name_len;\n        }\n    }\n\n    /* transform JSON into YANG XPATH */\n    yang_xpath = transform_json2xpath(lyd_node_module(ctx_node), path);\n    if (!yang_xpath) {\n        return NULL;\n    }\n\n    memset(&xp_set, 0, sizeof xp_set);\n\n    if (lyxp_eval(yang_xpath, ctx_node, LYXP_NODE_ELEM, lyd_node_module(ctx_node), &xp_set, 0) != EXIT_SUCCESS) {\n        free(yang_xpath);\n        return NULL;\n    }\n    free(yang_xpath);\n\n    set = ly_set_new();\n    LY_CHECK_ERR_RETURN(!set, LOGMEM(ctx_node->schema->module->ctx), NULL);\n\n    if (xp_set.type == LYXP_SET_NODE_SET) {\n        for (i = 0; i < xp_set.used; ++i) {\n            if (xp_set.val.nodes[i].type == LYXP_NODE_ELEM) {\n                if (ly_set_add(set, xp_set.val.nodes[i].node, LY_SET_OPT_USEASLIST) < 0) {\n                    ly_set_free(set);\n                    set = NULL;\n                    break;\n                }\n            }\n        }\n    }\n    /* free xp_set content */\n    lyxp_set_cast(&xp_set, LYXP_SET_EMPTY, ctx_node, NULL, 0);\n\n    return set;\n}\n\nAPI struct ly_set *\nlyd_find_instance(const struct lyd_node *data, const struct lys_node *schema)\n{\n    struct ly_set *ret, *ret_aux, *spath;\n    const struct lys_node *siter;\n    struct lyd_node *iter;\n    unsigned int i, j;\n\n    if (!data || !schema ||\n            !(schema->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_ANYDATA | LYS_NOTIF | LYS_RPC | LYS_ACTION))) {\n        LOGARG;\n        return NULL;\n    }\n\n    ret = ly_set_new();\n    spath = ly_set_new();\n    if (!ret || !spath) {\n        LOGMEM(schema->module->ctx);\n        goto error;\n    }\n\n    /* find data root */\n    while (data->parent) {\n        /* vertical move (up) */\n        data = data->parent;\n    }\n    while (data->prev->next) {\n        /* horizontal move (left) */\n        data = data->prev;\n    }\n\n    /* build schema path */\n    for (siter = schema; siter; ) {\n        if (siter->nodetype == LYS_AUGMENT) {\n            siter = ((struct lys_node_augment *)siter)->target;\n            continue;\n        } else if (siter->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_ANYDATA | LYS_NOTIF | LYS_RPC | LYS_ACTION)) {\n            /* standard data node */\n            ly_set_add(spath, (void*)siter, LY_SET_OPT_USEASLIST);\n\n        } /* else skip the rest node types */\n        siter = siter->parent;\n    }\n    if (!spath->number) {\n        /* no valid path */\n        goto error;\n    }\n\n    /* start searching */\n    LY_TREE_FOR((struct lyd_node *)data, iter) {\n        if (iter->schema == spath->set.s[spath->number - 1]) {\n            ly_set_add(ret, iter, LY_SET_OPT_USEASLIST);\n        }\n    }\n    for (i = spath->number - 1; i; i--) {\n        if (!ret->number) {\n            /* nothing found */\n            break;\n        }\n\n        ret_aux = ly_set_new();\n        if (!ret_aux) {\n            LOGMEM(schema->module->ctx);\n            goto error;\n        }\n        for (j = 0; j < ret->number; j++) {\n            LY_TREE_FOR(ret->set.d[j]->child, iter) {\n                if (iter->schema == spath->set.s[i - 1]) {\n                    ly_set_add(ret_aux, iter, LY_SET_OPT_USEASLIST);\n                }\n            }\n        }\n        ly_set_free(ret);\n        ret = ret_aux;\n    }\n\n    ly_set_free(spath);\n    return ret;\n\nerror:\n    ly_set_free(ret);\n    ly_set_free(spath);\n\n    return NULL;\n}\n\nAPI struct lyd_node *\nlyd_first_sibling(struct lyd_node *node)\n{\n    struct lyd_node *start;\n\n    if (!node) {\n        return NULL;\n    }\n\n    /* get the first sibling */\n    if (node->parent) {\n        start = node->parent->child;\n    } else {\n        for (start = node; start->prev->next; start = start->prev);\n    }\n\n    return start;\n}\n\nAPI struct ly_set *\nly_set_new(void)\n{\n    struct ly_set *new;\n\n    new = calloc(1, sizeof(struct ly_set));\n    LY_CHECK_ERR_RETURN(!new, LOGMEM(NULL), NULL);\n    return new;\n}\n\nAPI void\nly_set_free(struct ly_set *set)\n{\n    if (!set) {\n        return;\n    }\n\n    free(set->set.g);\n    free(set);\n}\n\nAPI int\nly_set_contains(const struct ly_set *set, void *node)\n{\n    unsigned int i;\n\n    if (!set) {\n        return -1;\n    }\n\n    for (i = 0; i < set->number; i++) {\n        if (set->set.g[i] == node) {\n            /* object found */\n            return i;\n        }\n    }\n\n    /* object not found */\n    return -1;\n}\n\nAPI struct ly_set *\nly_set_dup(const struct ly_set *set)\n{\n    struct ly_set *new;\n\n    if (!set) {\n        return NULL;\n    }\n\n    new = malloc(sizeof *new);\n    LY_CHECK_ERR_RETURN(!new, LOGMEM(NULL), NULL);\n    new->number = set->number;\n    new->size = set->size;\n    new->set.g = malloc(new->size * sizeof *(new->set.g));\n    LY_CHECK_ERR_RETURN(!new->set.g, LOGMEM(NULL); free(new), NULL);\n    memcpy(new->set.g, set->set.g, new->size * sizeof *(new->set.g));\n\n    return new;\n}\n\nAPI int\nly_set_add(struct ly_set *set, void *node, int options)\n{\n    unsigned int i;\n    void **new;\n\n    if (!set || !node) {\n        LOGARG;\n        return -1;\n    }\n\n    if (!(options & LY_SET_OPT_USEASLIST)) {\n        /* search for duplication */\n        for (i = 0; i < set->number; i++) {\n            if (set->set.g[i] == node) {\n                /* already in set */\n                return i;\n            }\n        }\n    }\n\n    if (set->size == set->number) {\n        new = realloc(set->set.g, (set->size + 8) * sizeof *(set->set.g));\n        LY_CHECK_ERR_RETURN(!new, LOGMEM(NULL), -1);\n        set->size += 8;\n        set->set.g = new;\n    }\n\n    set->set.g[set->number++] = node;\n\n    return set->number - 1;\n}\n\nAPI int\nly_set_merge(struct ly_set *trg, struct ly_set *src, int options)\n{\n    unsigned int i, ret;\n    void **new;\n\n    if (!trg) {\n        LOGARG;\n        return -1;\n    }\n\n    if (!src) {\n        return 0;\n    }\n\n    if (!(options & LY_SET_OPT_USEASLIST)) {\n        /* remove duplicates */\n        i = 0;\n        while (i < src->number) {\n            if (ly_set_contains(trg, src->set.g[i]) > -1) {\n                ly_set_rm_index(src, i);\n            } else {\n                ++i;\n            }\n        }\n    }\n\n    /* allocate more memory if needed */\n    if (trg->size < trg->number + src->number) {\n        new = realloc(trg->set.g, (trg->number + src->number) * sizeof *(trg->set.g));\n        LY_CHECK_ERR_RETURN(!new, LOGMEM(NULL), -1);\n        trg->size = trg->number + src->number;\n        trg->set.g = new;\n    }\n\n    /* copy contents from src into trg */\n    memcpy(trg->set.g + trg->number, src->set.g, src->number * sizeof *(src->set.g));\n    ret = src->number;\n    trg->number += ret;\n\n    /* cleanup */\n    ly_set_free(src);\n    return ret;\n}\n\nAPI int\nly_set_rm_index(struct ly_set *set, unsigned int index)\n{\n    if (!set || (index + 1) > set->number) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    if (index == set->number - 1) {\n        /* removing last item in set */\n        set->set.g[index] = NULL;\n    } else {\n        /* removing item somewhere in a middle, so put there the last item */\n        set->set.g[index] = set->set.g[set->number - 1];\n        set->set.g[set->number - 1] = NULL;\n    }\n    set->number--;\n\n    return EXIT_SUCCESS;\n}\n\nAPI int\nly_set_rm(struct ly_set *set, void *node)\n{\n    unsigned int i;\n\n    if (!set || !node) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    /* get index */\n    for (i = 0; i < set->number; i++) {\n        if (set->set.g[i] == node) {\n            break;\n        }\n    }\n    if (i == set->number) {\n        /* node is not in set */\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    return ly_set_rm_index(set, i);\n}\n\nAPI int\nly_set_clean(struct ly_set *set)\n{\n    if (!set) {\n        return EXIT_FAILURE;\n    }\n\n    set->number = 0;\n    return EXIT_SUCCESS;\n}\n\nAPI int\nlyd_wd_default(struct lyd_node_leaf_list *node)\n{\n    struct lys_node_leaf *leaf;\n    struct lys_node_leaflist *llist;\n    struct lyd_node *iter;\n    struct lys_tpdf *tpdf;\n    const char *dflt = NULL, **dflts = NULL;\n    uint8_t dflts_size = 0, c, i;\n\n    if (!node || !(node->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n        return 0;\n    }\n\n    if (node->dflt) {\n        return 1;\n    }\n\n    if (node->schema->nodetype == LYS_LEAF) {\n        leaf = (struct lys_node_leaf *)node->schema;\n\n        /* get know if there is a default value */\n        if (leaf->dflt) {\n            /* leaf has a default value */\n            dflt = leaf->dflt;\n        } else if (!(leaf->flags & LYS_MAND_TRUE)) {\n            /* get the default value from the type */\n            for (tpdf = leaf->type.der; tpdf && !dflt; tpdf = tpdf->type.der) {\n                dflt = tpdf->dflt;\n            }\n        }\n        if (!dflt) {\n            /* no default value */\n            return 0;\n        }\n\n        /* compare the default value with the value of the leaf */\n        if (!ly_strequal(dflt, node->value_str, 1)) {\n            return 0;\n        }\n    } else if (node->schema->module->version >= LYS_VERSION_1_1) { /* LYS_LEAFLIST */\n        llist = (struct lys_node_leaflist *)node->schema;\n\n        /* get know if there is a default value */\n        if (llist->dflt_size) {\n            /* there are default values */\n            dflts_size = llist->dflt_size;\n            dflts = llist->dflt;\n        } else if (!llist->min) {\n            /* get the default value from the type */\n            for (tpdf = llist->type.der; tpdf && !dflts; tpdf = tpdf->type.der) {\n                if (tpdf->dflt) {\n                    dflts = &tpdf->dflt;\n                    dflts_size = 1;\n                    break;\n                }\n            }\n        }\n\n        if (!dflts_size) {\n            /* no default values to use */\n            return 0;\n        }\n\n        /* compare the default value with the value of the leaf */\n        /* first, find the first leaf-list's sibling */\n        iter = (struct lyd_node *)node;\n        if (iter->parent) {\n            iter = iter->parent->child;\n        } else {\n            for (; iter->prev->next; iter = iter->prev);\n        }\n        for (c = 0; iter; iter = iter->next) {\n            if (iter->schema != node->schema) {\n                continue;\n            }\n            if (c == dflts_size) {\n                /* to many leaf-list instances */\n                return 0;\n            }\n\n            if (llist->flags & LYS_USERORDERED) {\n                /* we have strict order */\n                if (!ly_strequal(dflts[c], ((struct lyd_node_leaf_list *)iter)->value_str, 1)) {\n                    return 0;\n                }\n            } else {\n                /* node's value is supposed to match with one of the default values */\n                for (i = 0; i < dflts_size; i++) {\n                    if (ly_strequal(dflts[i], ((struct lyd_node_leaf_list *)iter)->value_str, 1)) {\n                        break;\n                    }\n                }\n                if (i == dflts_size) {\n                    /* values do not match */\n                    return 0;\n                }\n            }\n            c++;\n        }\n        if (c != dflts_size) {\n            /* different sets of leaf-list instances */\n            return 0;\n        }\n    } else {\n        return 0;\n    }\n\n    /* all checks ok */\n    return 1;\n}\n\nint\nunres_data_diff_new(struct unres_data *unres, struct lyd_node *subtree, struct lyd_node *parent, int created)\n{\n    char *parent_xpath = NULL;\n\n    if (created) {\n        return lyd_difflist_add(unres->diff, &unres->diff_size, unres->diff_idx++, LYD_DIFF_CREATED, NULL, subtree);\n    } else {\n        if (parent) {\n            parent_xpath = lyd_path(parent);\n            LY_CHECK_ERR_RETURN(!parent_xpath, LOGMEM(lyd_node_module(subtree)->ctx), -1);\n        }\n        return lyd_difflist_add(unres->diff, &unres->diff_size, unres->diff_idx++, LYD_DIFF_DELETED,\n                                subtree, (struct lyd_node *)parent_xpath);\n    }\n}\n\nvoid\nunres_data_diff_rem(struct unres_data *unres, unsigned int idx)\n{\n    if (unres->diff->type[idx] == LYD_DIFF_DELETED) {\n        lyd_free_withsiblings(unres->diff->first[idx]);\n        free(unres->diff->second[idx]);\n    }\n\n    /* replace by last real value */\n    if (idx < unres->diff_idx - 1) {\n        unres->diff->type[idx] = unres->diff->type[unres->diff_idx - 1];\n        unres->diff->first[idx] = unres->diff->first[unres->diff_idx - 1];\n        unres->diff->second[idx] = unres->diff->second[unres->diff_idx - 1];\n    }\n\n    /* move the end */\n    assert(unres->diff->type[unres->diff_idx] == LYD_DIFF_END);\n    unres->diff->type[unres->diff_idx - 1] = unres->diff->type[unres->diff_idx];\n    --unres->diff_idx;\n}\n\nAPI void\nlyd_free_val_diff(struct lyd_difflist *diff)\n{\n    uint32_t i;\n\n    if (!diff) {\n        return;\n    }\n\n    for (i = 0; diff->type[i] != LYD_DIFF_END; ++i) {\n        switch (diff->type[i]) {\n        case LYD_DIFF_CREATED:\n            free(diff->first[i]);\n            lyd_free_withsiblings(diff->second[i]);\n            break;\n        case LYD_DIFF_DELETED:\n            lyd_free_withsiblings(diff->first[i]);\n            free(diff->second[i]);\n            break;\n        default:\n            /* what to do? */\n            break;\n        }\n    }\n\n    lyd_free_diff(diff);\n}\n\nstatic int\nlyd_wd_add_leaf(struct lyd_node **tree, struct lyd_node *last_parent, struct lys_node_leaf *leaf, struct unres_data *unres,\n                int check_when_must)\n{\n    struct lyd_node *dummy = NULL, *current;\n    struct lys_tpdf *tpdf;\n    const char *dflt = NULL;\n    int ret;\n\n    /* get know if there is a default value */\n    if (leaf->dflt) {\n        /* leaf has a default value */\n        dflt = leaf->dflt;\n    } else if (!(leaf->flags & LYS_MAND_TRUE)) {\n        /* get the default value from the type */\n        for (tpdf = leaf->type.der; tpdf && !dflt; tpdf = tpdf->type.der) {\n            dflt = tpdf->dflt;\n        }\n    }\n    if (!dflt) {\n        /* no default value */\n        return EXIT_SUCCESS;\n    }\n\n    /* create the node */\n    if (!(dummy = lyd_new_dummy(*tree, last_parent, (struct lys_node*)leaf, dflt, 1))) {\n        goto error;\n    }\n\n    if (unres->store_diff) {\n        /* remember this subtree in the diff */\n        if (unres_data_diff_new(unres, dummy, NULL, 1)) {\n            goto error;\n        }\n    }\n\n    if (!dummy->parent && (*tree)) {\n        /* connect dummy nodes into the data tree (at the end of top level nodes) */\n        if (lyd_insert_sibling(tree, dummy)) {\n            goto error;\n        }\n    }\n    for (current = dummy; ; current = current->child) {\n        /* remember the created data in unres */\n        if (check_when_must) {\n            if ((current->when_status & LYD_WHEN) && unres_data_add(unres, current, UNRES_WHEN) == -1) {\n                goto error;\n            }\n            if (check_when_must == 2) {\n                ret = resolve_applies_must(current);\n                if ((ret & 0x1) && (unres_data_add(unres, current, UNRES_MUST) == -1)) {\n                    goto error;\n                }\n                if ((ret & 0x2) && (unres_data_add(unres, current, UNRES_MUST_INOUT) == -1)) {\n                    goto error;\n                }\n            }\n        }\n\n        /* clear dummy-node flag */\n        current->validity &= ~LYD_VAL_INUSE;\n\n        if (current->schema == (struct lys_node *)leaf) {\n            break;\n        }\n    }\n    /* update parent's default flag if needed */\n    lyd_wd_update_parents(dummy);\n\n    /* if necessary, remember the created data value in unres */\n    if (((struct lyd_node_leaf_list *)current)->value_type == LY_TYPE_LEAFREF) {\n        if (unres_data_add(unres, current, UNRES_LEAFREF)) {\n            goto error;\n        }\n    } else if (((struct lyd_node_leaf_list *)current)->value_type == LY_TYPE_INST) {\n        if (unres_data_add(unres, current, UNRES_INSTID)) {\n            goto error;\n        }\n    }\n\n    if (!(*tree)) {\n        *tree = dummy;\n    }\n    return EXIT_SUCCESS;\n\nerror:\n    lyd_free(dummy);\n    return EXIT_FAILURE;\n}\n\nstatic int\nlyd_wd_add_leaflist(struct lyd_node **tree, struct lyd_node *last_parent, struct lys_node_leaflist *llist,\n                    struct unres_data *unres, int check_when_must)\n{\n    struct lyd_node *dummy, *current, *first = NULL;\n    struct lys_tpdf *tpdf;\n    const char **dflt = NULL;\n    uint8_t dflt_size = 0;\n    int i, ret;\n\n    if (llist->module->version < LYS_VERSION_1_1) {\n        /* default values on leaf-lists are allowed from YANG 1.1 */\n        return EXIT_SUCCESS;\n    }\n\n    /* get know if there is a default value */\n    if (llist->dflt_size) {\n        /* there are default values */\n        dflt_size = llist->dflt_size;\n        dflt = llist->dflt;\n    } else if (!llist->min) {\n        /* get the default value from the type */\n        for (tpdf = llist->type.der; tpdf && !dflt; tpdf = tpdf->type.der) {\n            if (tpdf->dflt) {\n                dflt = &tpdf->dflt;\n                dflt_size = 1;\n                break;\n            }\n        }\n    }\n\n    if (!dflt_size) {\n        /* no default values to use */\n        return EXIT_SUCCESS;\n    }\n\n    for (i = 0; i < dflt_size; i++) {\n        /* create the node */\n        if (!(dummy = lyd_new_dummy(*tree, last_parent, (struct lys_node*)llist, dflt[i], 1))) {\n            goto error;\n        }\n\n        if (unres->store_diff) {\n            /* remember this subtree in the diff */\n            if (unres_data_diff_new(unres, dummy, NULL, 1)) {\n                goto error;\n            }\n        }\n\n        if (!first) {\n            first = dummy;\n        } else if (!dummy->parent) {\n            /* interconnect with the rest of leaf-lists */\n            first->prev->next = dummy;\n            dummy->prev = first->prev;\n            first->prev = dummy;\n        }\n\n        for (current = dummy; ; current = current->child) {\n            /* remember the created data in unres */\n            if (check_when_must) {\n                if ((current->when_status & LYD_WHEN) && unres_data_add(unres, current, UNRES_WHEN) == -1) {\n                    goto error;\n                }\n                if (check_when_must == 2) {\n                    ret = resolve_applies_must(current);\n                    if ((ret & 0x1) && (unres_data_add(unres, current, UNRES_MUST) == -1)) {\n                        goto error;\n                    }\n                    if ((ret & 0x2) && (unres_data_add(unres, current, UNRES_MUST_INOUT) == -1)) {\n                        goto error;\n                    }\n                }\n            }\n\n            /* clear dummy-node flag */\n            current->validity &= ~LYD_VAL_INUSE;\n\n            if (current->schema == (struct lys_node *)llist) {\n                break;\n            }\n        }\n\n        /* if necessary, remember the created data value in unres */\n        if (((struct lyd_node_leaf_list *)current)->value_type == LY_TYPE_LEAFREF) {\n            if (unres_data_add(unres, current, UNRES_LEAFREF)) {\n                goto error;\n            }\n        } else if (((struct lyd_node_leaf_list *)current)->value_type == LY_TYPE_INST) {\n            if (unres_data_add(unres, current, UNRES_INSTID)) {\n                goto error;\n            }\n        }\n    }\n\n    /* insert into the tree */\n    if (first && !first->parent && (*tree)) {\n        /* connect dummy nodes into the data tree (at the end of top level nodes) */\n        if (lyd_insert_sibling(tree, first)) {\n            goto error;\n        }\n    } else if (!(*tree)) {\n        *tree = first;\n    }\n\n    /* update parent's default flag if needed */\n    lyd_wd_update_parents(first);\n\n    return EXIT_SUCCESS;\n\nerror:\n    lyd_free_withsiblings(first);\n    return EXIT_FAILURE;\n}\n\nstatic void\nlyd_wd_leaflist_cleanup(struct ly_set *set, struct unres_data *unres)\n{\n    unsigned int i;\n\n    assert(set);\n\n    /* if there is an instance without the dflt flag, we have to\n     * remove all instances with the flag - an instance could be\n     * explicitely added, so the default leaflists were invalidated */\n    for (i = 0; i < set->number; i++) {\n        if (!set->set.d[i]->dflt) {\n            break;\n        }\n    }\n    if (i < set->number) {\n        for (i = 0; i < set->number; i++) {\n            if (set->set.d[i]->dflt) {\n                /* remove this default instance */\n                if (unres->store_diff) {\n                    /* just move it to diff if is being generated */\n                    unres_data_diff_new(unres, set->set.d[i], set->set.d[i]->parent, 0);\n                    lyd_unlink(set->set.d[i]);\n                } else {\n                    lyd_free(set->set.d[i]);\n                }\n            }\n        }\n    }\n}\n\n/**\n * @brief Process (add/clean flags) default nodes in the schema subtree\n *\n * @param[in,out] root Pointer to the root node of the complete data tree, the root node can be NULL if the data tree\n *                     is empty\n * @param[in] last_parent The closest parent in the data tree to the currently processed \\p schema node\n * @param[in] subroot  The root node of a data subtree, the node is instance of the \\p schema node, NULL in case the\n *                     schema node is not instantiated in the data tree\n * @param[in] schema The schema node to be processed\n * @param[in] toplevel Flag for processing top level schema nodes when \\p last_parent and \\p subroot are consider as\n *                     unknown\n * @param[in] options  Parser options to know the data tree type, see @ref parseroptions.\n * @param[in] unres    Unresolved data list, the newly added default nodes may need to add some unresolved items\n * @return EXIT_SUCCESS or EXIT_FAILURE\n */\nstatic int\nlyd_wd_add_subtree(struct lyd_node **root, struct lyd_node *last_parent, struct lyd_node *subroot,\n                   struct lys_node *schema, int toplevel, int options, struct unres_data *unres)\n{\n    struct ly_set *present = NULL;\n    struct lys_node *siter, *siter_prev;\n    struct lyd_node *iter;\n    int i, check_when_must, storing_diff = 0;\n\n    assert(root);\n\n    if ((options & LYD_OPT_TYPEMASK) && (schema->flags & LYS_CONFIG_R)) {\n        /* non LYD_OPT_DATA tree, status data are not expected here */\n        return EXIT_SUCCESS;\n    }\n\n    if (options & (LYD_OPT_NOTIF_FILTER | LYD_OPT_EDIT | LYD_OPT_GET | LYD_OPT_GETCONFIG)) {\n        check_when_must = 0; /* check neither */\n    } else if (options & LYD_OPT_TRUSTED) {\n        check_when_must = 1; /* check only when */\n    } else {\n        check_when_must = 2; /* check both when and must */\n    }\n\n    if (toplevel && (schema->nodetype & (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER))) {\n        /* search for the schema node instance */\n        present = ly_set_new();\n        if (!present) {\n            goto error;\n        }\n        if ((*root) && lyd_get_node_siblings(*root, schema, present)) {\n            /* there are some instances */\n            for (i = 0; i < (signed)present->number; i++) {\n                if (schema->nodetype & LYS_LEAFLIST) {\n                    lyd_wd_leaflist_cleanup(present, unres);\n                } else if (schema->nodetype != LYS_LEAF) {\n                    if (lyd_wd_add_subtree(root, present->set.d[i], present->set.d[i], schema, 0, options, unres)) {\n                        goto error;\n                    }\n                } /* else LYS_LEAF - nothing to do */\n            }\n        } else {\n            /* no instance */\n            if (lyd_wd_add_subtree(root, last_parent, NULL, schema, 0, options, unres)) {\n                goto error;\n            }\n        }\n\n        ly_set_free(present);\n        return EXIT_SUCCESS;\n    }\n\n    /* skip disabled parts of schema */\n    if (!subroot) {\n        /* go through all the uses and check whether they are enabled */\n        for (siter = schema->parent; siter && (siter->nodetype & (LYS_USES | LYS_CHOICE)); siter = siter->parent) {\n            if (lys_is_disabled(siter, 0)) {\n                /* ignore disabled uses nodes */\n                return EXIT_SUCCESS;\n            }\n        }\n\n        /* check augment state */\n        if (siter && siter->nodetype == LYS_AUGMENT) {\n            if (lys_is_disabled(siter, 0)) {\n                /* ignore disabled augment */\n                return EXIT_SUCCESS;\n            }\n        }\n\n        /* check the node itself */\n        if (lys_is_disabled(schema, 0)) {\n            /* ignore disabled data */\n            return EXIT_SUCCESS;\n        }\n    }\n\n    /* go recursively */\n    switch (schema->nodetype) {\n    case LYS_LIST:\n        if (!subroot) {\n            /* stop recursion */\n            break;\n        }\n        /* falls through */\n    case LYS_CONTAINER:\n        if (!subroot) {\n            /* container does not exists, continue only in case of non presence container */\n            if (((struct lys_node_container *)schema)->presence) {\n                /* stop recursion */\n                break;\n            }\n            /* always create empty NP container even if there is no default node,\n             * because accroding to RFC, the empty NP container is always part of\n             * accessible tree (e.g. for evaluating when and must conditions) */\n            subroot = _lyd_new(last_parent, schema, 1);\n            /* useless to set mand flag */\n            subroot->validity &= ~LYD_VAL_MAND;\n\n            if (unres->store_diff) {\n                /* remember this container in the diff */\n                if (unres_data_diff_new(unres, subroot, NULL, 1)) {\n                    goto error;\n                }\n\n                /* do not store diff for recursive calls, created values will be connected to this one */\n                storing_diff = 1;\n                unres->store_diff = 0;\n            }\n\n            if (!last_parent) {\n                if (*root) {\n                    lyd_insert_common((*root)->parent, root, subroot, 0);\n                } else {\n                    *root = subroot;\n                }\n            }\n            last_parent = subroot;\n\n            /* remember the created container in unres */\n            if (check_when_must) {\n                if ((subroot->when_status & LYD_WHEN) && unres_data_add(unres, subroot, UNRES_WHEN) == -1) {\n                    goto error;\n                }\n                if (check_when_must == 2) {\n                    i = resolve_applies_must(subroot);\n                    if ((i & 0x1) && (unres_data_add(unres, subroot, UNRES_MUST) == -1)) {\n                        goto error;\n                    }\n                    if ((i & 0x2) && (unres_data_add(unres, subroot, UNRES_MUST_INOUT) == -1)) {\n                        goto error;\n                    }\n                }\n            }\n        } else if (!((struct lys_node_container *)schema)->presence) {\n            /* fix default flag on existing containers - set it on all non-presence containers and in case we will\n             * have in recursion function some non-default node, it will unset it */\n            subroot->dflt = 1;\n        }\n        /* falls through */\n    case LYS_CASE:\n    case LYS_USES:\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n    case LYS_NOTIF:\n\n        /* recursion */\n        present = ly_set_new();\n        if (!present) {\n            goto error;\n        }\n        LY_TREE_FOR(schema->child, siter) {\n            if (siter->nodetype & (LYS_CHOICE | LYS_USES)) {\n                /* go into without searching for data instance */\n                if (lyd_wd_add_subtree(root, last_parent, subroot, siter, toplevel, options, unres)) {\n                    goto error;\n                }\n            } else if (siter->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_ANYDATA)) {\n                /* search for the schema node instance */\n                if (subroot && lyd_get_node_siblings(subroot->child, siter, present)) {\n                    /* there are some instances in the data root */\n                    if (siter->nodetype & LYS_LEAFLIST) {\n                        /* already have some leaflists, check that they are all\n                         * default, if not, remove the default leaflists */\n                        lyd_wd_leaflist_cleanup(present, unres);\n                    } else if (siter->nodetype != LYS_LEAF) {\n                        /* recursion */\n                        for (i = 0; i < (signed)present->number; i++) {\n                            if (lyd_wd_add_subtree(root, present->set.d[i], present->set.d[i], siter, toplevel, options,\n                                                   unres)) {\n                                goto error;\n                            }\n                        }\n                    } /* else LYS_LEAF - nothing to do */\n\n                    /* fix default flag (2nd part) - for non-default node with default parent, unset the default flag\n                     * from the parents (starting from subroot node) */\n                    if (subroot->dflt) {\n                        for (i = 0; i < (signed)present->number; i++) {\n                            if (!present->set.d[i]->dflt) {\n                                for (iter = subroot; iter && iter->dflt; iter = iter->parent) {\n                                    iter->dflt = 0;\n                                }\n                                break;\n                            }\n                        }\n                    }\n                    ly_set_clean(present);\n                } else {\n                    /* no instance */\n                    if (lyd_wd_add_subtree(root, last_parent, NULL, siter, toplevel, options, unres)) {\n                        goto error;\n                    }\n                }\n            }\n        }\n\n        if (storing_diff) {\n            /* continue generating the diff in functions above this one */\n            unres->store_diff = 1;\n        }\n        break;\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n        if (subroot) {\n            /* default shortcase of a choice */\n            present = ly_set_new();\n            if (!present) {\n                goto error;\n            }\n            lyd_get_node_siblings(subroot->child, schema, present);\n            if (present->number) {\n                /* the shortcase leaf(-list) exists, stop the processing */\n                break;\n            }\n        }\n        if (schema->nodetype == LYS_LEAF) {\n            if (lyd_wd_add_leaf(root, last_parent, (struct lys_node_leaf*)schema, unres, check_when_must)) {\n                return EXIT_FAILURE;\n            }\n        } else { /* LYS_LEAFLIST */\n            if (lyd_wd_add_leaflist(root, last_parent, (struct lys_node_leaflist*)schema, unres, check_when_must)) {\n                goto error;\n            }\n        }\n        break;\n    case LYS_CHOICE:\n        /* get existing node in the data root from the choice */\n        iter = NULL;\n        if ((toplevel && (*root)) || (!toplevel && subroot)) {\n            LY_TREE_FOR(toplevel ? (*root) : subroot->child, iter) {\n                for (siter = lys_parent(iter->schema), siter_prev = iter->schema;\n                        siter && (siter->nodetype & (LYS_CASE | LYS_USES | LYS_CHOICE));\n                        siter_prev = siter, siter = lys_parent(siter)) {\n                    if (siter == schema) {\n                        /* we have the choice instance */\n                        break;\n                    }\n                }\n                if (siter == schema) {\n                    /* we have the choice instance;\n                     * the condition must be the same as in the loop because of\n                     * choice's sibling nodes that break the loop, so siter is not NULL,\n                     * but it is not the same as schema */\n                    break;\n                }\n            }\n        }\n        if (!iter) {\n            if (((struct lys_node_choice *)schema)->dflt) {\n                /* there is a default case */\n                if (lyd_wd_add_subtree(root, last_parent, subroot, ((struct lys_node_choice *)schema)->dflt,\n                                       toplevel, options, unres)) {\n                    goto error;\n                }\n            }\n        } else {\n            /* one of the choice's cases is instantiated, continue into this case */\n            /* since iter != NULL, siter must be also != NULL and we also know siter_prev\n             * which points to the child of schema leading towards the instantiated data */\n            assert(siter && siter_prev);\n            if (lyd_wd_add_subtree(root, last_parent, subroot, siter_prev, toplevel, options, unres)) {\n                goto error;\n            }\n        }\n        break;\n    default:\n        /* LYS_ANYXML, LYS_ANYDATA, LYS_USES, LYS_GROUPING - do nothing */\n        break;\n    }\n\n    ly_set_free(present);\n    return EXIT_SUCCESS;\n\nerror:\n    ly_set_free(present);\n    return EXIT_FAILURE;\n}\n\n/**\n * @brief Covering function to process (add/clean) default nodes in the data tree\n * @param[in,out] root Pointer to the root node of the complete data tree, the root node can be NULL if the data tree\n *                     is empty\n * @param[in] ctx      Context for the case the data tree is empty (in that case \\p ctx must not be NULL)\n * @param[in] options  Parser options to know the data tree type, see @ref parseroptions.\n * @param[in] unres    Unresolved data list, the newly added default nodes may need to add some unresolved items\n * @return EXIT_SUCCESS or EXIT_FAILURE\n */\nstatic int\nlyd_wd_add(struct lyd_node **root, struct ly_ctx *ctx, const struct lys_module **modules, int mod_count,\n           struct unres_data *unres, int options)\n{\n    struct lys_node *siter;\n    int i;\n\n    assert(root && !(options & LYD_OPT_ACT_NOTIF));\n    assert(*root || ctx);\n    assert(!(options & LYD_OPT_NOSIBLINGS) || *root);\n\n    if (options & (LYD_OPT_EDIT | LYD_OPT_GET | LYD_OPT_GETCONFIG)) {\n        /* no change supposed */\n        return EXIT_SUCCESS;\n    }\n\n    if (!ctx) {\n        ctx = (*root)->schema->module->ctx;\n    }\n\n    if (!(options & LYD_OPT_TYPEMASK) || (options & LYD_OPT_CONFIG)) {\n        if (options & LYD_OPT_NOSIBLINGS) {\n            if (lyd_wd_add_subtree(root, NULL, NULL, (*root)->schema, 1, options, unres)) {\n                return EXIT_FAILURE;\n            }\n        } else if (modules && mod_count) {\n            for (i = 0; i < mod_count; ++i) {\n                LY_TREE_FOR(modules[i]->data, siter) {\n                    if (!(siter->nodetype & (LYS_CONTAINER | LYS_CHOICE | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_ANYDATA |\n                                             LYS_USES))) {\n                        continue;\n                    }\n                    if (lyd_wd_add_subtree(root, NULL, NULL, siter, 1, options, unres)) {\n                        return EXIT_FAILURE;\n                    }\n                }\n            }\n        } else {\n            for (i = 0; i < ctx->models.used; i++) {\n                /* skip not implemented and disabled modules */\n                if (!ctx->models.list[i]->implemented || ctx->models.list[i]->disabled) {\n                    continue;\n                }\n                LY_TREE_FOR(ctx->models.list[i]->data, siter) {\n                    if (!(siter->nodetype & (LYS_CONTAINER | LYS_CHOICE | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_ANYDATA |\n                                             LYS_USES))) {\n                        continue;\n                    }\n                    if (lyd_wd_add_subtree(root, NULL, NULL, siter, 1, options, unres)) {\n                        return EXIT_FAILURE;\n                    }\n                }\n            }\n        }\n    } else if (options & LYD_OPT_NOTIF) {\n        if (!(*root) || ((*root)->schema->nodetype != LYS_NOTIF)) {\n            LOGERR(ctx, LY_EINVAL, \"Subtree is not a single notification.\");\n            return EXIT_FAILURE;\n        }\n        if (lyd_wd_add_subtree(root, *root, *root, (*root)->schema, 0, options, unres)) {\n            return EXIT_FAILURE;\n        }\n    } else if (options & (LYD_OPT_RPC | LYD_OPT_RPCREPLY)) {\n        if (!(*root) || !((*root)->schema->nodetype & (LYS_RPC | LYS_ACTION))) {\n            LOGERR(ctx, LY_EINVAL, \"Subtree is not a single RPC/action/reply.\");\n            return EXIT_FAILURE;\n        }\n        if (options & LYD_OPT_RPC) {\n            for (siter = (*root)->schema->child; siter && siter->nodetype != LYS_INPUT; siter = siter->next);\n        } else { /* LYD_OPT_RPCREPLY */\n            for (siter = (*root)->schema->child; siter && siter->nodetype != LYS_OUTPUT; siter = siter->next);\n        }\n        if (siter) {\n            if (lyd_wd_add_subtree(root, *root, *root, siter, 0, options, unres)) {\n                return EXIT_FAILURE;\n            }\n        }\n    } else if (options & LYD_OPT_DATA_TEMPLATE) {\n        if (lyd_wd_add_subtree(root, NULL, NULL, (*root)->schema, 1, options, unres)) {\n            return EXIT_FAILURE;\n        }\n    } else {\n        LOGINT(ctx);\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\nlyd_defaults_add_unres(struct lyd_node **root, int options, struct ly_ctx *ctx, const struct lys_module **modules,\n                       int mod_count, const struct lyd_node *data_tree, struct lyd_node *act_notif,\n                       struct unres_data *unres, int wd)\n{\n    struct lyd_node *msg_sibling = NULL, *msg_parent = NULL, *data_tree_sibling, *data_tree_parent;\n    struct lys_node *msg_op = NULL;\n    struct ly_set *set;\n    int ret = EXIT_FAILURE;\n\n    assert(root && (*root || ctx) && unres && !(options & LYD_OPT_ACT_NOTIF));\n\n    if (!ctx) {\n        ctx = (*root)->schema->module->ctx;\n    }\n\n    if ((options & LYD_OPT_NOSIBLINGS) && !(*root)) {\n        LOGERR(ctx, LY_EINVAL, \"Cannot add default values for one module (LYD_OPT_NOSIBLINGS) without any data.\");\n        return EXIT_FAILURE;\n    }\n\n    if (options & (LYD_OPT_RPC | LYD_OPT_RPCREPLY | LYD_OPT_NOTIF)) {\n        if (!(*root)) {\n            LOGERR(ctx, LY_EINVAL, \"Cannot add default values to RPC, RPC reply, and notification without at least the empty container.\");\n            return EXIT_FAILURE;\n        }\n        if ((options & LYD_OPT_RPC) && !act_notif && ((*root)->schema->nodetype != LYS_RPC)) {\n            LOGERR(ctx, LY_EINVAL, \"Not valid RPC/action data.\");\n            return EXIT_FAILURE;\n        }\n        if ((options & LYD_OPT_RPCREPLY) && !act_notif && ((*root)->schema->nodetype != LYS_RPC)) {\n            LOGERR(ctx, LY_EINVAL, \"Not valid reply data.\");\n            return EXIT_FAILURE;\n        }\n        if ((options & LYD_OPT_NOTIF) && !act_notif && ((*root)->schema->nodetype != LYS_NOTIF)) {\n            LOGERR(ctx, LY_EINVAL, \"Not valid notification data.\");\n            return EXIT_FAILURE;\n        }\n\n        /* remember the operation/notification schema */\n        msg_op = act_notif ? act_notif->schema : (*root)->schema;\n    } else if (*root && (*root)->parent) {\n        /* we have inner node, so it will be considered as\n         * a root of subtree where to add default nodes and\n         * no of its siblings will be affected */\n        options |= LYD_OPT_NOSIBLINGS;\n    }\n\n    /* add missing default nodes */\n    if (wd && lyd_wd_add((act_notif ? &act_notif : root), ctx, modules, mod_count, unres, options)) {\n        return EXIT_FAILURE;\n    }\n\n    /* check leafrefs and/or instids if any */\n    if (unres && unres->count) {\n        if (!(*root)) {\n            LOGINT(ctx);\n            return EXIT_FAILURE;\n        }\n\n        /* temporarily link the additional data tree to the RPC/action/notification */\n        if (data_tree && (options & (LYD_OPT_RPC | LYD_OPT_RPCREPLY | LYD_OPT_NOTIF))) {\n            /* duplicate the message tree - if it gets deleted we would not be able to positively identify it */\n            msg_parent = NULL;\n            msg_sibling = *root;\n\n            if (act_notif) {\n                /* fun case */\n                data_tree_parent = NULL;\n                data_tree_sibling = (struct lyd_node *)data_tree;\n                while (data_tree_sibling) {\n                    while (data_tree_sibling) {\n                        if ((data_tree_sibling->schema == msg_sibling->schema)\n                                && ((msg_sibling->schema->nodetype != LYS_LIST)\n                                    || lyd_list_equal(data_tree_sibling, msg_sibling, 0))) {\n                            /* match */\n                            break;\n                        }\n\n                        data_tree_sibling = data_tree_sibling->next;\n                    }\n\n                    if (data_tree_sibling) {\n                        /* prepare for the new data_tree iteration */\n                        data_tree_parent = data_tree_sibling;\n                        data_tree_sibling = data_tree_sibling->child;\n\n                        /* find new action sibling to search for later (skip list keys) */\n                        msg_parent = msg_sibling;\n                        assert(msg_sibling->child);\n                        for (msg_sibling = msg_sibling->child;\n                                msg_sibling->schema->nodetype == LYS_LEAF;\n                                msg_sibling = msg_sibling->next) {\n                            assert(msg_sibling->next);\n                        }\n                        if (msg_sibling->schema->nodetype & (LYS_ACTION | LYS_NOTIF)) {\n                            /* we are done */\n                            assert(act_notif->parent);\n                            assert(act_notif->parent->schema == data_tree_parent->schema);\n                            assert(msg_sibling == act_notif);\n                            break;\n                        }\n                    }\n                }\n\n                /* loop ended after the first iteration, set the values correctly */\n                if (!data_tree_parent) {\n                    data_tree_sibling = (struct lyd_node *)data_tree;\n                }\n\n            } else {\n                /* easy case */\n                data_tree_parent = NULL;\n                data_tree_sibling = (struct lyd_node *)data_tree;\n            }\n\n            /* unlink msg_sibling if needed (won't do anything otherwise) */\n            lyd_unlink_internal(msg_sibling, 0);\n\n            /* now we can insert msg_sibling into data_tree_parent or next to data_tree_sibling */\n            assert(data_tree_parent || data_tree_sibling);\n            if (data_tree_parent) {\n                if (lyd_insert_common(data_tree_parent, NULL, msg_sibling, 0)) {\n                    goto unlink_datatree;\n                }\n            } else {\n                assert(!data_tree_sibling->parent);\n                if (lyd_insert_nextto(data_tree_sibling->prev, msg_sibling, 0, 0)) {\n                    goto unlink_datatree;\n                }\n            }\n        }\n\n        if (resolve_unres_data(ctx, unres, root, options)) {\n            goto unlink_datatree;\n        }\n\n        /* we are done */\n        ret = EXIT_SUCCESS;\n\n        /* check that the operation/notification tree was not removed */\n        if (options & (LYD_OPT_RPC | LYD_OPT_RPCREPLY | LYD_OPT_NOTIF)) {\n            set = NULL;\n            if (data_tree) {\n                set = lyd_find_instance(data_tree_parent ? data_tree_parent : data_tree_sibling, msg_op);\n                assert(set && ((set->number == 0) || (set->number == 1)));\n            } else if (*root) {\n                set = lyd_find_instance(*root, msg_op);\n                assert(set && ((set->number == 0) || (set->number == 1)));\n            }\n            if (!set || !set->number) {\n                /* it was removed, handle specially */\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, msg_op, \"Operation/notification not supported because of the current configuration.\");\n                ret = EXIT_FAILURE;\n            }\n            ly_set_free(set);\n        }\n\nunlink_datatree:\n        /* put the trees back in order */\n        if (data_tree && (options & (LYD_OPT_RPC | LYD_OPT_RPCREPLY | LYD_OPT_NOTIF))) {\n            /* unlink and insert it back, if there is a parent  */\n            lyd_unlink_internal(msg_sibling, 0);\n            if (msg_parent) {\n                lyd_insert_common(msg_parent, NULL, msg_sibling, 0);\n            }\n        }\n    } else {\n        /* we are done */\n        ret = EXIT_SUCCESS;\n    }\n\n    return ret;\n}\n\nAPI struct lys_module *\nlyd_node_module(const struct lyd_node *node)\n{\n    if (!node) {\n        return NULL;\n    }\n\n    return node->schema->module->type ? ((struct lys_submodule *)node->schema->module)->belongsto : node->schema->module;\n}\n\nAPI double\nlyd_dec64_to_double(const struct lyd_node *node)\n{\n    if (!node || !(node->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST))\n            || (((struct lys_node_leaf *)node->schema)->type.base != LY_TYPE_DEC64)) {\n        LOGARG;\n        return 0;\n    }\n\n    return atof(((struct lyd_node_leaf_list *)node)->value_str);\n}\n\nAPI const struct lys_type *\nlyd_leaf_type(const struct lyd_node_leaf_list *leaf)\n{\n    struct lys_type *type;\n\n    if (!leaf || !(leaf->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n        return NULL;\n    }\n\n    type = &((struct lys_node_leaf *)leaf->schema)->type;\n\n    do {\n        if (type->base == LY_TYPE_LEAFREF) {\n            type = &type->info.lref.target->type;\n        } else if (type->base == LY_TYPE_UNION) {\n            if (type->info.uni.has_ptr_type && leaf->validity) {\n                /* we don't know what it will be after resolution (validation) */\n                LOGVAL(leaf->schema->module->ctx, LYE_SPEC, LY_VLOG_LYD, leaf,\n                       \"Unable to determine the type of value \\\"%s\\\" from union type \\\"%s\\\" prior to validation.\",\n                       leaf->value_str, type->der->name);\n                return NULL;\n            }\n\n            if (resolve_union((struct lyd_node_leaf_list *)leaf, type, 0, 0, &type)) {\n                /* resolve union failed */\n                return NULL;\n            }\n        }\n    } while (type->base == LY_TYPE_LEAFREF);\n\n    return type;\n}\n\nAPI int\nlyd_lyb_data_length(const char *data)\n{\n    const char *ptr;\n    uint16_t i, mod_count, str_len;\n    uint8_t tmp_buf[2];\n    LYB_META meta;\n\n    if (!data) {\n        return -1;\n    }\n\n    ptr = data;\n\n    /* magic number */\n    if ((ptr[0] != 'l') || (ptr[1] != 'y') || (ptr[2] != 'b')) {\n        return -1;\n    }\n    ptr += 3;\n\n    /* header */\n    ++ptr;\n\n    /* models */\n    memcpy(tmp_buf, ptr, 2);\n    ptr += 2;\n    mod_count = tmp_buf[0] | (tmp_buf[1] << 8);\n\n    for (i = 0; i < mod_count; ++i) {\n        /* model name */\n        memcpy(tmp_buf, ptr, 2);\n        ptr += 2;\n        str_len = tmp_buf[0] | (tmp_buf[1] << 8);\n\n        ptr += str_len;\n\n        /* revision */\n        ptr += 2;\n    }\n\n    if (ptr[0]) {\n        /* subtrees */\n        do {\n            memcpy(&meta, ptr, LYB_META_BYTES);\n            ptr += LYB_META_BYTES;\n\n            /* read whole subtree (chunk size) */\n            ptr += *((uint8_t *)&meta);\n            /* skip inner chunks (inner chunk count) */\n            ptr += *(((uint8_t *)&meta) + LYB_SIZE_BYTES) * LYB_META_BYTES;\n        } while ((*((uint8_t *)&meta) == LYB_SIZE_MAX) || ptr[0]);\n    }\n\n    /* ending zero */\n    ++ptr;\n\n    return ptr - data;\n}\n\n#ifdef LY_ENABLED_LYD_PRIV\n\nAPI void *\nlyd_set_private(const struct lyd_node *node, void *priv)\n{\n    void *prev;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    prev = node->priv;\n    ((struct lyd_node *)node)->priv = priv;\n\n    return prev;\n}\n\n#endif\n", "/**\n * @file tree_internal.h\n * @author Radek Krejci <rkrejci@cesnet.cz>\n * @brief libyang internal functions for manipulating with the data model and\n * data trees.\n *\n * Copyright (c) 2015 CESNET, z.s.p.o.\n *\n * This source code is licensed under BSD 3-Clause License (the \"License\").\n * You may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/BSD-3-Clause\n */\n\n#ifndef LY_TREE_INTERNAL_H_\n#define LY_TREE_INTERNAL_H_\n\n#include <stdint.h>\n\n#include \"libyang.h\"\n#include \"tree_schema.h\"\n#include \"tree_data.h\"\n#include \"resolve.h\"\n\n/* this is used to distinguish lyxml_elem * from a YANG temporary parsing structure, the first byte is compared */\n#define LY_YANG_STRUCTURE_FLAG 0x80\n\n/**\n * @brief YANG namespace\n */\n#define LY_NSYANG \"urn:ietf:params:xml:ns:yang:1\"\n\n/**\n * @brief YIN namespace\n */\n#define LY_NSYIN \"urn:ietf:params:xml:ns:yang:yin:1\"\n\n/**\n * @brief NETCONF namespace\n */\n#define LY_NSNC \"urn:ietf:params:xml:ns:netconf:base:1.0\"\n\n/**\n * @brief NACM namespace\n */\n#define LY_NSNACM \"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\"\n\n/**\n * @brief internal parser flag for actions and inline notifications\n */\n#define LYD_OPT_ACT_NOTIF 0x100\n\n/**\n * @brief Internal list of built-in types\n */\nextern struct lys_tpdf *ly_types[LY_DATA_TYPE_COUNT];\n\n/**\n * @brief Internal structure for data node sorting.\n */\nstruct lyd_node_pos {\n    struct lyd_node *node;\n    uint32_t pos;\n};\n\n/**\n * @brief Internal structure for LYB parser/printer.\n */\nstruct lyb_state {\n    size_t *written;\n    size_t *position;\n    uint8_t *inner_chunks;\n    int used;\n    int size;\n    const struct lys_module **models;\n    int mod_count;\n    struct ly_ctx *ctx;\n\n    /* LYB printer only */\n    struct {\n        struct lys_node *first_sibling;\n        struct hash_table *ht;\n    } *sib_ht;\n    int sib_ht_count;\n};\n\n/* struct lyb_state allocation step */\n#define LYB_STATE_STEP 4\n\n/**\n * LYB schema hash constants\n *\n * Hash is divided to collision ID and hash itself.\n *\n * First bits are collision ID until 1 is found. The rest is truncated 32b hash.\n * 1xxx xxxx - collision ID 0 (no collisions)\n * 01xx xxxx - collision ID 1 (collision ID 0 hash collided)\n * 001x xxxx - collision ID 2 ...\n */\n\n/* Number of bits the whole hash will take (including hash collision ID) */\n#define LYB_HASH_BITS 8\n\n/* Masking 32b hash (collision ID 0) */\n#define LYB_HASH_MASK 0x7f\n\n/* Type for storing the whole hash (used only internally, publicly defined directly) */\n#define LYB_HASH uint8_t\n\n/* Need to move this first >> collision number (from 0) to get collision ID hash part */\n#define LYB_HASH_COLLISION_ID 0x80\n\n/* How many bytes are reserved for one data chunk SIZE (8B is maximum) */\n#define LYB_SIZE_BYTES 1\n\n/* Maximum size that will be written into LYB_SIZE_BYTES (must be large enough) */\n#define LYB_SIZE_MAX UINT8_MAX\n\n/* How many bytes are reserved for one data chunk inner chunk count */\n#define LYB_INCHUNK_BYTES 1\n\n/* Maximum size that will be written into LYB_INCHUNK_BYTES (must be large enough) */\n#define LYB_INCHUNK_MAX UINT8_MAX\n\n/* Just a helper macro */\n#define LYB_META_BYTES (LYB_INCHUNK_BYTES + LYB_SIZE_BYTES)\n\n/* Type large enough for all meta data */\n#define LYB_META uint16_t\n\nLYB_HASH lyb_hash(struct lys_node *sibling, uint8_t collision_id);\n\nint lyb_has_schema_model(struct lys_node *sibling, const struct lys_module **models, int mod_count);\n\n/**\n * Macros to work with ::lyd_node#when_status\n * +--- bit 1 - some when-stmt connected with the node (resolve_applies_when() is true)\n * |+-- bit 2 - when-stmt's condition is resolved and it is true\n * ||+- bit 3 - when-stmt's condition is resolved and it is false\n * XXX\n *\n * bit 1 is set when the node is created\n * if none of bits 2 and 3 is set, the when condition is not yet resolved\n */\n#define LYD_WHEN       0x04\n#define LYD_WHEN_TRUE  0x02\n#define LYD_WHEN_FALSE 0x01\n#define LYD_WHEN_DONE(status) (!((status) & LYD_WHEN) || ((status) & (LYD_WHEN_TRUE | LYD_WHEN_FALSE)))\n\n/**\n * @brief Type flag for an unresolved type in a grouping.\n */\n#define LY_VALUE_UNRESGRP 0x80\n\n#ifdef LY_ENABLED_CACHE\n\n/**\n * @brief Minimum number of children for the parent to create a hash table for them.\n */\n#   define LY_CACHE_HT_MIN_CHILDREN 4\n\n    int lyd_hash(struct lyd_node *node);\n\n    void lyd_insert_hash(struct lyd_node *node);\n\n    void lyd_unlink_hash(struct lyd_node *node, struct lyd_node *orig_parent);\n#endif\n\n/**\n * @brief Create submodule structure by reading data from memory.\n *\n * @param[in] module Schema tree where to connect the submodule, belongs-to value must match.\n * @param[in] data String containing the submodule specification in the given \\p format.\n * @param[in] format Format of the data to read.\n * @param[in] unres list of unresolved items\n * @return Created submodule structure or NULL in case of error.\n */\nstruct lys_submodule *lys_sub_parse_mem(struct lys_module *module, const char *data, LYS_INFORMAT format,\n                                        struct unres_schema *unres);\n\n/**\n * @brief Create submodule structure by reading data from file descriptor.\n *\n * \\note Current implementation supports only reading data from standard (disk) file, not from sockets, pipes, etc.\n *\n * @param[in] module Schema tree where to connect the submodule, belongs-to value must match.\n * @param[in] fd File descriptor of a regular file (e.g. sockets are not supported) containing the submodule\n *            specification in the given \\p format.\n * @param[in] format Format of the data to read.\n * @param[in] unres list of unresolved items\n * @return Created submodule structure or NULL in case of error.\n */\nstruct lys_submodule *lys_sub_parse_fd(struct lys_module *module, int fd, LYS_INFORMAT format, struct unres_schema *unres);\n\n/**\n * @brief Free the submodule structure\n *\n * @param[in] submodule The structure to free. Do not use the pointer after calling this function.\n * @param[in] private_destructor Optional destructor function for private objects assigned\n * to the nodes via lys_set_private(). If NULL, the private objects are not freed by libyang.\n */\nvoid lys_submodule_free(struct lys_submodule *submodule, void (*private_destructor)(const struct lys_node *node, void *priv));\n\n/**\n * @brief Add child schema tree node at the end of the parent's child list.\n *\n * If the child is connected somewhere (has a parent), it is completely\n * unlinked and none of the following conditions applies.\n * If the child has prev sibling(s), they are ignored (child is added at the\n * end of the child list).\n * If the child has next sibling(s), all of them are connected with the parent.\n *\n * @param[in] parent Parent node where the \\p child will be added.\n * @param[in] module Module where the \\p child will be added if the \\p parent\n * parameter is NULL (case of top-level elements). The parameter does not change\n * the module of the \\p child element. If the \\p parent parameter is present,\n * the \\p module parameter is ignored.\n * @param[in] child The schema tree node to be added.\n * @param[in] options Parsing options. Only relevant when creating a shorthand case.\n * @return 0 on success, nonzero else\n */\nint lys_node_addchild(struct lys_node *parent, struct lys_module *module, struct lys_node *child, int options);\n\n/**\n * @brief Find a valid grouping definition relative to a node.\n *\n * Valid definition means a sibling of \\p start or a sibling of any of \\p start 's parents.\n *\n * @param[in] name Name of the searched grouping.\n * @param[in] start Definition must be valid (visible) for this node.\n * @return Matching valid grouping or NULL.\n */\nstruct lys_node_grp *lys_find_grouping_up(const char *name, struct lys_node *start);\n\n/**\n * @brief Check that the \\p node being connected into the \\p parent has a unique name (identifier).\n *\n * Function is performed also as part of lys_node_addchild().\n *\n * @param[in] node The schema tree node to be checked.\n * @param[in] parent Parent node where the \\p child is supposed to be added.\n * @param[in] module Module where the \\p child is supposed to be added if the \\p parent\n * parameter is NULL (case of top-level elements). The parameter does not change\n * the module of the \\p child element. If the \\p parent parameter is present,\n * the \\p module parameter is ignored.\n * @return 0 on success, nonzero else\n */\nint lys_check_id(struct lys_node *node, struct lys_node *parent, struct lys_module *module);\n\n/**\n * @brief Get know if the node contains must or when with XPath expression\n *\n * @param[in] node Node to examine.\n * @return 1 if contains, 0 otherwise\n */\nint lys_has_xpath(const struct lys_node *node);\n\n/**\n * @brief Learn if \\p type is defined in the local module or from an import.\n *\n * @param[in] type Type to examine.\n * @return non-zero if local, 0 if from an import.\n */\nint lys_type_is_local(const struct lys_type *type);\n\n/**\n * @brief Create a copy of the specified schema tree \\p node\n *\n * @param[in] module Target module for the duplicated node.\n * @param[in] parent Schema tree node where the node is being connected, NULL in case of top level \\p node.\n * @param[in] node Schema tree node to be duplicated.\n * @param[in] unres list of unresolved items\n * @param[in] shallow Whether to copy children and connect to parent/module too.\n * @return Created copy of the provided schema \\p node.\n */\nstruct lys_node *lys_node_dup(struct lys_module *module, struct lys_node *parent, const struct lys_node *node,\n                              struct unres_schema *unres, int shallow);\n\n/**\n * @brief duplicate the list of extension instances.\n *\n * @param[in] ctx Context to store errors in.\n * @param[in] mod Module where we are\n * @param[in] orig list of the extension instances to duplicate, the size of the array must correspond with \\p size\n * @param[in] size number of items in \\p old array to duplicate\n * @param[in] parent Parent structure of the new extension instances list\n * @param[in] parent_type Type of the provide \\p parent *\n * @param[in,out] new Address where to store the created list of duplicated extension instances\n * @param[in] shallow Whether to copy children and connect to parent/module too.\n * @param[in] unres list of unresolved items\n *\n */\nint lys_ext_dup(struct ly_ctx *ctx, struct lys_module *mod, struct lys_ext_instance **orig, uint8_t size, void *parent,\n                LYEXT_PAR parent_type, struct lys_ext_instance ***new, int shallow, struct unres_schema *unres);\n\n/**\n * @brief Iterate over the specified type of the extension instances\n *\n * @param[in] ext Array of extensions to explore\n * @param[in] ext_size Size of the provided \\p ext array\n * @param[in] start Index in the \\p ext array where to start searching (first call with 0, the consequent calls with\n *            the returned index increased by 1, unless the returned index is -1)\n * @param[in] substmt Type of the extension (its belongins to the specific substatement) to iterate, use\n *            #LYEXT_SUBSTMT_ALL to go through all the extensions in the array\n * @result index in the ext, -1 if not present\n */\nint lys_ext_iter(struct lys_ext_instance **ext, uint8_t ext_size, uint8_t start, LYEXT_SUBSTMT substmt);\n\n/**\n * @brief free the array of the extension instances\n */\nvoid lys_extension_instances_free(struct ly_ctx *ctx, struct lys_ext_instance **e, unsigned int size,\n                                  void (*private_destructor)(const struct lys_node *node, void *priv));\n\n/**\n * @brief Add pointer to \\p leafref to \\p leafref_target children so that it knows there\n * are some leafrefs referring it.\n *\n * @param[in] leafref_target Leaf that is \\p leafref's target.\n * @param[in] leafref Leaf or leaflist of type #LY_TYPE_LEAFREF referring \\p leafref_target.\n * @return 0 on success, -1 on error.\n */\nint lys_leaf_add_leafref_target(struct lys_node_leaf *leafref_target, struct lys_node *leafref);\n\n/**\n * @brief Free a schema when condition\n *\n * @param[in] libyang context where the schema of the ondition is used.\n * @param[in] w When structure to free.\n * @param[in] private_destructor Destructor for priv member in extension instances\n */\nvoid lys_when_free(struct ly_ctx *ctx, struct lys_when *w,\n                   void (*private_destructor)(const struct lys_node *node, void *priv));\n\n/**\n * @brief Free the schema tree restriction (must, ...) structure content\n *\n * @param[in] ctx libyang context where the schema of the restriction is used.\n * @param[in] restr The restriction structure to free. The function actually frees only\n * the content of the structure, so after using this function, caller is supposed to\n * use free(restr). It is done to free the content of structures being allocated as\n * part of array, in that case the free() is used on the whole array.\n * @param[in] private_destructor Destructor for priv member in extension instances\n */\nvoid lys_restr_free(struct ly_ctx *ctx, struct lys_restr *restr,\n                    void (*private_destructor)(const struct lys_node *node, void *priv));\n\n/**\n * @brief Free the schema tree type structure content\n *\n * @param[in] ctx libyang context where the schema of the type is used.\n * @param[in] restr The type structure to free. The function actually frees only\n * the content of the structure, so after using this function, caller is supposed to\n * use free(type). It is done to free the content of structures being allocated as\n * part of array, in that case the free() is used on the whole array.\n * @param[in] private_destructor Destructor for priv member in extension instances\n */\nvoid lys_type_free(struct ly_ctx *ctx, struct lys_type *type,\n                   void (*private_destructor)(const struct lys_node *node, void *priv));\n\n/**\n * @brief Unlink the schema node from the tree.\n *\n * @param[in] node Schema tree node to unlink.\n */\nvoid lys_node_unlink(struct lys_node *node);\n\n/**\n * @brief Free the schema node structure, includes unlinking it from the tree\n *\n * @param[in] node Schema tree node to free. Do not use the pointer after calling this function.\n * @param[in] private_destructor Optional destructor function for private objects assigned\n * to the nodes via lys_set_private(). If NULL, the private objects are not freed by libyang.\n * @param[in] shallow Whether to do a shallow free only (on a shallow copy of a node).\n */\nvoid lys_node_free(struct lys_node *node, void (*private_destructor)(const struct lys_node *node, void *priv), int shallow);\n\n/**\n * @brief Free (and unlink it from the context) the specified schema.\n *\n * It is dangerous to call this function on schemas already placed into the context's\n * list of modules - there can be many references from other modules and data instances.\n *\n * @param[in] module Data model to free.\n * @param[in] private_destructor Optional destructor function for private objects assigned\n * to the nodes via lys_set_private(). If NULL, the private objects are not freed by libyang.\n * @param[in] free_subs Whether to free included submodules.\n * @param[in] remove_from_ctx Whether to remove this model from context. Always use 1 except\n * when removing all the models (in ly_ctx_destroy()).\n */\nvoid lys_free(struct lys_module *module, void (*private_destructor)(const struct lys_node *node, void *priv),\n              int free_subs, int remove_from_ctx);\n\n/**\n * @brief Create a data container knowing it's schema node.\n *\n * @param[in] parent Data parent of the new node.\n * @param[in] schema Schema node of the new node.\n * @param[in] dflt Set dflt flag in the created data nodes\n * @return New node, NULL on error.\n */\nstruct lyd_node *_lyd_new(struct lyd_node *parent, const struct lys_node *schema, int dflt);\n\n/**\n * @brief Create a dummy node for XPath evaluation. After done using, it should be removed.\n *\n * The function must be used very carefully:\n * - there must not be a list node to create\n *\n * @param[in] data Any data node of the tree where the dummy node will be created\n * @param[in] parent To optimize searching in data tree (and to avoid issues with lists), caller can specify a\n *                   parent node that exists in the data tree.\n * @param[in] schema Schema node of the dummy node to create, must be of nodetype that\n * appears also in data tree.\n * @param[in] value Optional value to be set in the dummy node\n * @param[in] dflt Set dflt flag in the created data nodes\n *\n * @return The first created node needed for the dummy node in the given tree.\n */\nstruct lyd_node *lyd_new_dummy(struct lyd_node *data, struct lyd_node *parent, const struct lys_node *schema,\n                               const char *value, int dflt);\n\n/**\n * @brief Find the parent node of an attribute.\n *\n * @param[in] root Root element of the data tree with the attribute.\n * @param[in] attr Attribute to find.\n *\n * @return Parent of \\p attr, NULL if not found.\n */\nconst struct lyd_node *lyd_attr_parent(const struct lyd_node *root, struct lyd_attr *attr);\n\n/**\n * @brief Internal version of lyd_unlink().\n *\n * @param[in] node Node to unlink.\n * @param[in] permanent 0 - the node will be linked back,\n *                      1 - the node is premanently unlinked,\n *                      2 - the node is being freed.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on error.\n */\nint lyd_unlink_internal(struct lyd_node *node, int permanent);\n\n/**\n * @brief Internal version of lyd_insert() and lyd_insert_sibling().\n *\n * @param[in] invalidate Whether to invalidate any nodes. Set 0 only if linking back some temporarily internally unlinked nodes.\n */\nint lyd_insert_common(struct lyd_node *parent, struct lyd_node **sibling, struct lyd_node *node, int invalidate);\n\n/**\n * @brief Internal version of lyd_insert_before() and lyd_insert_after().\n *\n * @param[in] invalidate Whether to invalidate any nodes. Set 0 only if linking back some temporarily internally unlinked nodes.\n */\nint lyd_insert_nextto(struct lyd_node *sibling, struct lyd_node *node, int before, int invalidate);\n\n/**\n * @brief Find a specific sibling. Does not log.\n *\n * Since \\p mod_name is mandatory, augments are handled.\n *\n * @param[in] siblings Siblings to consider. They are first adjusted to\n *                     point to the first sibling.\n * @param[in] mod_name Module name, mandatory.\n * @param[in] mod_name_len Module name length.\n * @param[in] name Node name, mandatory.\n * @param[in] nam_len Node name length.\n * @param[in] type ORed desired type of the node. 0 means any type.\n *                 Does not return groupings, uses, and augments (but can return augment nodes).\n * @param[out] ret Pointer to the node of the desired type. Can be NULL.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference.\n */\nint lys_get_sibling(const struct lys_node *siblings, const char *mod_name, int mod_name_len, const char *name,\n                    int nam_len, LYS_NODE type, const struct lys_node **ret);\n\n/**\n * @brief Find a specific node that can only appear in the data. Does not log.\n *\n * @param[in] mod Main module with the node. Must be set if \\p parent == NULL (top-level node).\n * @param[in] parent Parent of the node. Must be set if \\p mod == NULL (nested node).\n * @param[in] name Node name.\n * @param[in] nam_len Node \\p name length.\n * @param[in] type ORed desired type of the node. 0 means any (data node) type.\n * @param[out] ret Pointer to the node of the desired type. Can be NULL.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on fail.\n */\nint lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,\n                     LYS_NODE type, const struct lys_node **ret);\n\nint lyd_get_unique_default(const char* unique_expr, struct lyd_node *list, const char **dflt);\n\nint lyd_build_relative_data_path(const struct lys_module *module, const struct lyd_node *node, const char *schema_id,\n                                 char *buf);\n\nvoid lyd_free_value(lyd_val value, LY_DATA_TYPE value_type, uint8_t value_flags, struct lys_type *type, lyd_val *old_val,\n                    LY_DATA_TYPE *old_val_type, uint8_t *old_val_flags);\n\nint lyd_list_equal(struct lyd_node *node1, struct lyd_node *node2, int with_defaults);\n\nint lys_make_implemented_r(struct lys_module *module, struct unres_schema *unres);\n\n/**\n * @brief Check for (validate) mandatory nodes of a data tree. Checks recursively whole data tree. Requires all when\n * statement to be solved.\n *\n * @param[in] root Data tree to validate.\n * @param[in] ctx libyang context (for the case when the data tree is empty - i.e. root == NULL).\n * @param[in] modules Only check mandatory nodes from these modules. If not set, check for all modules in the context.\n * @param[in] mod_count Number of modules in \\p modules.\n * @param[in] options Standard @ref parseroptions.\n * @return EXIT_SUCCESS or EXIT_FAILURE.\n */\nint lyd_check_mandatory_tree(struct lyd_node *root, struct ly_ctx *ctx, const struct lys_module **modules, int mod_count,\n                             int options);\n\n/**\n * @brief Check if the provided node is inside a grouping.\n *\n * @param[in] node Schema node to check.\n * @return 0 as false, 1 as true\n */\nint lys_ingrouping(const struct lys_node *node);\n\nint unres_data_diff_new(struct unres_data *unres, struct lyd_node *subtree, struct lyd_node *parent, int created);\n\nvoid unres_data_diff_rem(struct unres_data *unres, unsigned int idx);\n\n/**\n * @brief Process (add/clean) default nodes in the data tree and resolve the unresolved items\n *\n * @param[in,out] root  Pointer to the root node of the complete data tree, the root node can be NULL if the data tree\n *                      is empty\n * @param[in] options   Parser options to know the data tree type, see @ref parseroptions.\n * @param[in] ctx       Context for the case the \\p root is empty (in that case \\p ctx must not be NULL)\n * @param[in] modules   Only modules that will be traversed when adding default values.\n * @param[in] mod_count Number of module names in \\p modules.\n * @param[in] data_tree Additional data tree for validating RPC/action/notification. The tree is used to satisfy\n *                      possible references to the datastore content.\n * @param[in] act_notif In case of nested action/notification, pointer to the subroot of the action/notification. Note\n *                      that in this case the \\p root points to the top level data tree node which provides the context\n *                      for the nested action/notification\n * @param[in] unres     Unresolved data list, the newly added default nodes may need to add some unresolved items\n * @param[in] wd        Whether to add default values.\n * @return EXIT_SUCCESS or EXIT_FAILURE\n */\nint lyd_defaults_add_unres(struct lyd_node **root, int options, struct ly_ctx *ctx, const struct lys_module **modules,\n                           int mod_count, const struct lyd_node *data_tree, struct lyd_node *act_notif,\n                           struct unres_data *unres, int wd);\n\nvoid lys_enable_deviations(struct lys_module *module);\n\nvoid lys_disable_deviations(struct lys_module *module);\n\nvoid lys_sub_module_remove_devs_augs(struct lys_module *module);\n\nvoid lys_sub_module_apply_devs_augs(struct lys_module *module);\n\nint apply_aug(struct lys_node_augment *augment, struct unres_schema *unres);\n\nvoid lys_submodule_module_data_free(struct lys_submodule *submodule);\n\nint lys_copy_union_leafrefs(struct lys_module *mod, struct lys_node *parent, struct lys_type *type,\n                            struct lys_type *prev_new, struct unres_schema *unres);\n\nconst struct lys_module *lys_parse_fd_(struct ly_ctx *ctx, int fd, LYS_INFORMAT format, const char *revision, int implement);\n\nconst struct lys_module *lys_parse_mem_(struct ly_ctx *ctx, const char *data, LYS_INFORMAT format, const char *revision,\n                                        int internal, int implement);\n\n/**\n * @brief Get next augment from \\p mod augmenting \\p aug_target\n */\nstruct lys_node_augment *lys_getnext_target_aug(struct lys_node_augment *last, const struct lys_module *mod,\n                                                const struct lys_node *aug_target);\n\nLY_STMT lys_snode2stmt(LYS_NODE nodetype);\nstruct lys_node ** lys_child(const struct lys_node *node, LYS_NODE nodetype);\n\n#endif /* LY_TREE_INTERNAL_H_ */\n", "/**\n * @file tree_schema.c\n * @author Radek Krejci <rkrejci@cesnet.cz>\n * @brief Manipulation with libyang schema data structures\n *\n * Copyright (c) 2015 - 2018 CESNET, z.s.p.o.\n *\n * This source code is licensed under BSD 3-Clause License (the \"License\").\n * You may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/BSD-3-Clause\n */\n\n#define _GNU_SOURCE\n\n#ifdef __APPLE__\n#   include <sys/param.h>\n#endif\n#include <assert.h>\n#include <ctype.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <dirent.h>\n\n#include \"common.h\"\n#include \"context.h\"\n#include \"parser.h\"\n#include \"resolve.h\"\n#include \"xml.h\"\n#include \"xpath.h\"\n#include \"xml_internal.h\"\n#include \"tree_internal.h\"\n#include \"validation.h\"\n#include \"parser_yang.h\"\n\nstatic int lys_type_dup(struct lys_module *mod, struct lys_node *parent, struct lys_type *new, struct lys_type *old,\n                        int in_grp, int shallow, struct unres_schema *unres);\n\nAPI const struct lys_node_list *\nlys_is_key(const struct lys_node_leaf *node, uint8_t *index)\n{\n    struct lys_node *parent = (struct lys_node *)node;\n    struct lys_node_list *list;\n    uint8_t i;\n\n    if (!node || node->nodetype != LYS_LEAF) {\n        return NULL;\n    }\n\n    do {\n        parent = lys_parent(parent);\n    } while (parent && parent->nodetype == LYS_USES);\n\n    if (!parent || parent->nodetype != LYS_LIST) {\n        return NULL;\n    }\n\n    list = (struct lys_node_list*)parent;\n    for (i = 0; i < list->keys_size; i++) {\n        if (list->keys[i] == node) {\n            if (index) {\n                (*index) = i;\n            }\n            return list;\n        }\n    }\n    return NULL;\n}\n\nAPI const struct lys_node *\nlys_is_disabled(const struct lys_node *node, int recursive)\n{\n    int i;\n\n    if (!node) {\n        return NULL;\n    }\n\ncheck:\n    if (node->nodetype != LYS_INPUT && node->nodetype != LYS_OUTPUT) {\n        /* input/output does not have if-feature, so skip them */\n\n        /* check local if-features */\n        for (i = 0; i < node->iffeature_size; i++) {\n            if (!resolve_iffeature(&node->iffeature[i])) {\n                return node;\n            }\n        }\n    }\n\n    if (!recursive) {\n        return NULL;\n    }\n\n    /* go through parents */\n    if (node->nodetype == LYS_AUGMENT) {\n        /* go to parent actually means go to the target node */\n        node = ((struct lys_node_augment *)node)->target;\n        if (!node) {\n            /* unresolved augment, let's say it's enabled */\n            return NULL;\n        }\n    } else if (node->nodetype == LYS_EXT) {\n        return NULL;\n    } else if (node->parent) {\n        node = node->parent;\n    } else {\n        return NULL;\n    }\n\n    if (recursive == 2) {\n        /* continue only if the node cannot have a data instance */\n        if (node->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST)) {\n            return NULL;\n        }\n    }\n    goto check;\n}\n\nAPI const struct lys_type *\nlys_getnext_union_type(const struct lys_type *last, const struct lys_type *type)\n{\n    int found = 0;\n\n    if (!type || (type->base != LY_TYPE_UNION)) {\n        return NULL;\n    }\n\n    return lyp_get_next_union_type((struct lys_type *)type, (struct lys_type *)last, &found);\n}\n\nint\nlys_get_sibling(const struct lys_node *siblings, const char *mod_name, int mod_name_len, const char *name,\n                int nam_len, LYS_NODE type, const struct lys_node **ret)\n{\n    const struct lys_node *node, *parent = NULL;\n    const struct lys_module *mod = NULL;\n    const char *node_mod_name;\n\n    assert(siblings && mod_name && name);\n    assert(!(type & (LYS_USES | LYS_GROUPING)));\n\n    /* fill the lengths in case the caller is so indifferent */\n    if (!mod_name_len) {\n        mod_name_len = strlen(mod_name);\n    }\n    if (!nam_len) {\n        nam_len = strlen(name);\n    }\n\n    while (siblings && (siblings->nodetype == LYS_USES)) {\n        siblings = siblings->child;\n    }\n    if (!siblings) {\n        /* unresolved uses */\n        return EXIT_FAILURE;\n    }\n\n    if (siblings->nodetype == LYS_GROUPING) {\n        for (node = siblings; (node->nodetype == LYS_GROUPING) && (node->prev != siblings); node = node->prev);\n        if (node->nodetype == LYS_GROUPING) {\n            /* we went through all the siblings, only groupings there - no valid sibling */\n            return EXIT_FAILURE;\n        }\n        /* update siblings to be valid */\n        siblings = node;\n    }\n\n    /* set parent correctly */\n    parent = lys_parent(siblings);\n\n    /* go up all uses */\n    while (parent && (parent->nodetype == LYS_USES)) {\n        parent = lys_parent(parent);\n    }\n\n    if (!parent) {\n        /* handle situation when there is a top-level uses referencing a foreign grouping */\n        for (node = siblings; lys_parent(node) && (node->nodetype == LYS_USES); node = lys_parent(node));\n        mod = lys_node_module(node);\n    }\n\n    /* try to find the node */\n    node = NULL;\n    while ((node = lys_getnext(node, parent, mod, LYS_GETNEXT_WITHCHOICE | LYS_GETNEXT_WITHCASE | LYS_GETNEXT_WITHINOUT))) {\n        if (!type || (node->nodetype & type)) {\n            /* module name comparison */\n            node_mod_name = lys_node_module(node)->name;\n            if (!ly_strequal(node_mod_name, mod_name, 1) && (strncmp(node_mod_name, mod_name, mod_name_len) || node_mod_name[mod_name_len])) {\n                continue;\n            }\n\n            /* direct name check */\n            if (ly_strequal(node->name, name, 1) || (!strncmp(node->name, name, nam_len) && !node->name[nam_len])) {\n                if (ret) {\n                    *ret = node;\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    }\n\n    return EXIT_FAILURE;\n}\n\nint\nlys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,\n                 LYS_NODE type, const struct lys_node **ret)\n{\n    const struct lys_node *node;\n\n    assert((mod || parent) && name);\n    assert(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));\n\n    if (!mod) {\n        mod = lys_node_module(parent);\n    }\n\n    /* try to find the node */\n    node = NULL;\n    while ((node = lys_getnext(node, parent, mod, 0))) {\n        if (!type || (node->nodetype & type)) {\n            /* module check */\n            if (lys_node_module(node) != lys_main_module(mod)) {\n                continue;\n            }\n\n            /* direct name check */\n            if (!strncmp(node->name, name, nam_len) && !node->name[nam_len]) {\n                if (ret) {\n                    *ret = node;\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    }\n\n    return EXIT_FAILURE;\n}\n\nAPI const struct lys_node *\nlys_getnext(const struct lys_node *last, const struct lys_node *parent, const struct lys_module *module, int options)\n{\n    const struct lys_node *next, *aug_parent;\n    struct lys_node **snode;\n\n    if ((!parent && !module) || (module && module->type) || (parent && (parent->nodetype == LYS_USES) && !(options & LYS_GETNEXT_PARENTUSES))) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (!last) {\n        /* first call */\n\n        /* get know where to start */\n        if (parent) {\n            /* schema subtree */\n            snode = lys_child(parent, LYS_UNKNOWN);\n            /* do not return anything if the augment does not have any children */\n            if (!snode || !(*snode) || ((parent->nodetype == LYS_AUGMENT) && ((*snode)->parent != parent))) {\n                return NULL;\n            }\n            next = last = *snode;\n        } else {\n            /* top level data */\n            if (!(options & LYS_GETNEXT_NOSTATECHECK) && (module->disabled || !module->implemented)) {\n                /* nothing to return from a disabled/imported module */\n                return NULL;\n            }\n            next = last = module->data;\n        }\n    } else if ((last->nodetype == LYS_USES) && (options & LYS_GETNEXT_INTOUSES) && last->child) {\n        /* continue with uses content */\n        next = last->child;\n    } else {\n        /* continue after the last returned value */\n        next = last->next;\n    }\n\nrepeat:\n    if (parent && (parent->nodetype == LYS_AUGMENT) && next) {\n        /* do not return anything outside the parent augment */\n        aug_parent = next->parent;\n        do {\n            while (aug_parent && (aug_parent->nodetype != LYS_AUGMENT)) {\n                aug_parent = aug_parent->parent;\n            }\n            if (aug_parent) {\n                if (aug_parent == parent) {\n                    break;\n                }\n                aug_parent = ((struct lys_node_augment *)aug_parent)->target;\n            }\n\n        } while (aug_parent);\n        if (!aug_parent) {\n            return NULL;\n        }\n    }\n    while (next && (next->nodetype == LYS_GROUPING)) {\n        if (options & LYS_GETNEXT_WITHGROUPING) {\n            return next;\n        }\n        next = next->next;\n    }\n\n    if (!next) {     /* cover case when parent is augment */\n        if (!last || last->parent == parent || lys_parent(last) == parent) {\n            /* no next element */\n            return NULL;\n        }\n        last = lys_parent(last);\n        next = last->next;\n        goto repeat;\n    } else {\n        last = next;\n    }\n\n    if (!(options & LYS_GETNEXT_NOSTATECHECK) && lys_is_disabled(next, 0)) {\n        next = next->next;\n        goto repeat;\n    }\n\n    switch (next->nodetype) {\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        if (options & LYS_GETNEXT_WITHINOUT) {\n            return next;\n        } else if (next->child) {\n            next = next->child;\n        } else {\n            next = next->next;\n        }\n        goto repeat;\n\n    case LYS_CASE:\n        if (options & LYS_GETNEXT_WITHCASE) {\n            return next;\n        } else if (next->child) {\n            next = next->child;\n        } else {\n            next = next->next;\n        }\n        goto repeat;\n\n    case LYS_USES:\n        /* go into */\n        if (options & LYS_GETNEXT_WITHUSES) {\n            return next;\n        } else if (next->child) {\n            next = next->child;\n        } else {\n            next = next->next;\n        }\n        goto repeat;\n\n    case LYS_RPC:\n    case LYS_ACTION:\n    case LYS_NOTIF:\n    case LYS_LEAF:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n    case LYS_LIST:\n    case LYS_LEAFLIST:\n        return next;\n\n    case LYS_CONTAINER:\n        if (!((struct lys_node_container *)next)->presence && (options & LYS_GETNEXT_INTONPCONT)) {\n            if (next->child) {\n                /* go into */\n                next = next->child;\n            } else {\n                next = next->next;\n            }\n            goto repeat;\n        } else {\n            return next;\n        }\n\n    case LYS_CHOICE:\n        if (options & LYS_GETNEXT_WITHCHOICE) {\n            return next;\n        } else if (next->child) {\n            /* go into */\n            next = next->child;\n        } else {\n            next = next->next;\n        }\n        goto repeat;\n\n    default:\n        /* we should not be here */\n        return NULL;\n    }\n}\n\nvoid\nlys_node_unlink(struct lys_node *node)\n{\n    struct lys_node *parent, *first, **pp = NULL;\n    struct lys_module *main_module;\n\n    if (!node) {\n        return;\n    }\n\n    /* unlink from data model if necessary */\n    if (node->module) {\n        /* get main module with data tree */\n        main_module = lys_node_module(node);\n        if (main_module->data == node) {\n            main_module->data = node->next;\n        }\n    }\n\n    /* store pointers to important nodes */\n    parent = node->parent;\n    if (parent && (parent->nodetype == LYS_AUGMENT)) {\n        /* handle augments - first, unlink it from the augment parent ... */\n        if (parent->child == node) {\n            parent->child = (node->next && node->next->parent == parent) ? node->next : NULL;\n        }\n\n        if (parent->flags & LYS_NOTAPPLIED) {\n            /* data are not connected in the target, so we cannot continue with the target as a parent */\n            parent = NULL;\n        } else {\n            /* data are connected in target, so we will continue with the target as a parent */\n            parent = ((struct lys_node_augment *)parent)->target;\n        }\n    }\n\n    /* unlink from parent */\n    if (parent) {\n        if (parent->nodetype == LYS_EXT) {\n            pp = (struct lys_node **)lys_ext_complex_get_substmt(lys_snode2stmt(node->nodetype),\n                                                                 (struct lys_ext_instance_complex*)parent, NULL);\n            if (*pp == node) {\n                *pp = node->next;\n            }\n        } else if (parent->child == node) {\n            parent->child = node->next;\n        }\n        node->parent = NULL;\n    }\n\n    /* unlink from siblings */\n    if (node->prev == node) {\n        /* there are no more siblings */\n        return;\n    }\n    if (node->next) {\n        node->next->prev = node->prev;\n    } else {\n        /* unlinking the last element */\n        if (parent) {\n            if (parent->nodetype == LYS_EXT) {\n                first = *(struct lys_node **)pp;\n            } else {\n                first = parent->child;\n            }\n        } else {\n            first = node;\n            while (first->prev->next) {\n                first = first->prev;\n            }\n        }\n        first->prev = node->prev;\n    }\n    if (node->prev->next) {\n        node->prev->next = node->next;\n    }\n\n    /* clean up the unlinked element */\n    node->next = NULL;\n    node->prev = node;\n}\n\nstruct lys_node_grp *\nlys_find_grouping_up(const char *name, struct lys_node *start)\n{\n    struct lys_node *par_iter, *iter, *stop;\n\n    for (par_iter = start; par_iter; par_iter = par_iter->parent) {\n        /* top-level augment, look into module (uses augment is handled correctly below) */\n        if (par_iter->parent && !par_iter->parent->parent && (par_iter->parent->nodetype == LYS_AUGMENT)) {\n            par_iter = lys_main_module(par_iter->parent->module)->data;\n            if (!par_iter) {\n                break;\n            }\n        }\n\n        if (par_iter->nodetype == LYS_EXT) {\n            /* we are in a top-level extension, search grouping in top-level groupings */\n            par_iter = lys_main_module(par_iter->module)->data;\n            if (!par_iter) {\n                /* not connected yet, wait */\n                return NULL;\n            }\n        } else if (par_iter->parent && (par_iter->parent->nodetype & (LYS_CHOICE | LYS_CASE | LYS_AUGMENT | LYS_USES))) {\n            continue;\n        }\n\n        for (iter = par_iter, stop = NULL; iter; iter = iter->prev) {\n            if (!stop) {\n                stop = par_iter;\n            } else if (iter == stop) {\n                break;\n            }\n            if (iter->nodetype != LYS_GROUPING) {\n                continue;\n            }\n\n            if (!strcmp(name, iter->name)) {\n                return (struct lys_node_grp *)iter;\n            }\n        }\n    }\n\n    return NULL;\n}\n\n/*\n * get next grouping in the root's subtree, in the\n * first call, tha last is NULL\n */\nstatic struct lys_node_grp *\nlys_get_next_grouping(struct lys_node_grp *lastgrp, struct lys_node *root)\n{\n    struct lys_node *last = (struct lys_node *)lastgrp;\n    struct lys_node *next;\n\n    assert(root);\n\n    if (!last) {\n        last = root;\n    }\n\n    while (1) {\n        if ((last->nodetype & (LYS_CONTAINER | LYS_CHOICE | LYS_LIST | LYS_GROUPING | LYS_INPUT | LYS_OUTPUT))) {\n            next = last->child;\n        } else {\n            next = NULL;\n        }\n        if (!next) {\n            if (last == root) {\n                /* we are done */\n                return NULL;\n            }\n\n            /* no children, go to siblings */\n            next = last->next;\n        }\n        while (!next) {\n            /* go back through parents */\n            if (lys_parent(last) == root) {\n                /* we are done */\n                return NULL;\n            }\n            next = last->next;\n            last = lys_parent(last);\n        }\n\n        if (next->nodetype == LYS_GROUPING) {\n            return (struct lys_node_grp *)next;\n        }\n\n        last = next;\n    }\n}\n\n/* logs directly */\nint\nlys_check_id(struct lys_node *node, struct lys_node *parent, struct lys_module *module)\n{\n    struct lys_node *start, *stop, *iter;\n    struct lys_node_grp *grp;\n    int down, up;\n\n    assert(node);\n\n    if (!parent) {\n        assert(module);\n    } else {\n        module = parent->module;\n    }\n    module = lys_main_module(module);\n\n    switch (node->nodetype) {\n    case LYS_GROUPING:\n        /* 6.2.1, rule 6 */\n        if (parent) {\n            start = *lys_child(parent, LYS_GROUPING);\n            if (!start) {\n                down = 0;\n                start = parent;\n            } else {\n                down = 1;\n            }\n            if (parent->nodetype == LYS_EXT) {\n                up = 0;\n            } else {\n                up = 1;\n            }\n        } else {\n            down = up = 1;\n            start = module->data;\n        }\n        /* go up */\n        if (up && lys_find_grouping_up(node->name, start)) {\n            LOGVAL(module->ctx, LYE_DUPID, LY_VLOG_LYS, node, \"grouping\", node->name);\n            return EXIT_FAILURE;\n        }\n        /* go down, because grouping can be defined after e.g. container in which is collision */\n        if (down) {\n            for (iter = start, stop = NULL; iter; iter = iter->prev) {\n                if (!stop) {\n                    stop = start;\n                } else if (iter == stop) {\n                    break;\n                }\n                if (!(iter->nodetype & (LYS_CONTAINER | LYS_CHOICE | LYS_LIST | LYS_GROUPING | LYS_INPUT | LYS_OUTPUT))) {\n                    continue;\n                }\n\n                grp = NULL;\n                while ((grp = lys_get_next_grouping(grp, iter))) {\n                    if (ly_strequal(node->name, grp->name, 1)) {\n                        LOGVAL(module->ctx, LYE_DUPID,LY_VLOG_LYS, node, \"grouping\", node->name);\n                        return EXIT_FAILURE;\n                    }\n                }\n            }\n        }\n        break;\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n    case LYS_LIST:\n    case LYS_CONTAINER:\n    case LYS_CHOICE:\n    case LYS_ANYDATA:\n        /* 6.2.1, rule 7 */\n        if (parent) {\n            iter = parent;\n            while (iter && (iter->nodetype & (LYS_USES | LYS_CASE | LYS_CHOICE | LYS_AUGMENT))) {\n                if (iter->nodetype == LYS_AUGMENT) {\n                    if (((struct lys_node_augment *)iter)->target) {\n                        /* augment is resolved, go up */\n                        iter = ((struct lys_node_augment *)iter)->target;\n                        continue;\n                    }\n                    /* augment is not resolved, this is the final parent */\n                    break;\n                }\n                iter = iter->parent;\n            }\n\n            if (!iter) {\n                stop = NULL;\n                iter = module->data;\n            } else if (iter->nodetype == LYS_EXT) {\n                stop = iter;\n                iter = (struct lys_node *)lys_child(iter, node->nodetype);\n                if (iter) {\n                    iter = *(struct lys_node **)iter;\n                }\n            } else {\n                stop = iter;\n                iter = iter->child;\n            }\n        } else {\n            stop = NULL;\n            iter = module->data;\n        }\n        while (iter) {\n            if (iter->nodetype & (LYS_USES | LYS_CASE)) {\n                iter = iter->child;\n                continue;\n            }\n\n            if (iter->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_CONTAINER | LYS_CHOICE | LYS_ANYDATA)) {\n                if (iter->module == node->module && ly_strequal(iter->name, node->name, 1)) {\n                    LOGVAL(module->ctx, LYE_DUPID, LY_VLOG_LYS, node, strnodetype(node->nodetype), node->name);\n                    return EXIT_FAILURE;\n                }\n            }\n\n            /* special case for choice - we must check the choice's name as\n             * well as the names of nodes under the choice\n             */\n            if (iter->nodetype == LYS_CHOICE) {\n                iter = iter->child;\n                continue;\n            }\n\n            /* go to siblings */\n            if (!iter->next) {\n                /* no sibling, go to parent's sibling */\n                do {\n                    /* for parent LYS_AUGMENT */\n                    if (iter->parent == stop) {\n                        iter = stop;\n                        break;\n                    }\n                    iter = lys_parent(iter);\n                    if (iter && iter->next) {\n                        break;\n                    }\n                } while (iter != stop);\n\n                if (iter == stop) {\n                    break;\n                }\n            }\n            iter = iter->next;\n        }\n        break;\n    case LYS_CASE:\n        /* 6.2.1, rule 8 */\n        if (parent) {\n            start = *lys_child(parent, LYS_CASE);\n        } else {\n            start = module->data;\n        }\n\n        LY_TREE_FOR(start, iter) {\n            if (!(iter->nodetype & (LYS_ANYDATA | LYS_CASE | LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST))) {\n                continue;\n            }\n\n            if (iter->module == node->module && ly_strequal(iter->name, node->name, 1)) {\n                LOGVAL(module->ctx, LYE_DUPID, LY_VLOG_LYS, node, \"case\", node->name);\n                return EXIT_FAILURE;\n            }\n        }\n        break;\n    default:\n        /* no check needed */\n        break;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* logs directly */\nint\nlys_node_addchild(struct lys_node *parent, struct lys_module *module, struct lys_node *child, int options)\n{\n    struct ly_ctx *ctx = child->module->ctx;\n    struct lys_node *iter, **pchild, *log_parent;\n    struct lys_node_inout *in, *out;\n    struct lys_node_case *c;\n    int type, shortcase = 0;\n    void *p;\n    struct lyext_substmt *info = NULL;\n\n    assert(child);\n\n    if (parent) {\n        type = parent->nodetype;\n        module = parent->module;\n        log_parent = parent;\n\n        if (type == LYS_USES) {\n            /* we are adding children to uses -> we must be copying grouping contents into it, so properly check the parent */\n            log_parent = lys_parent(log_parent);\n            while (log_parent && (log_parent->nodetype == LYS_USES)) {\n                log_parent = lys_parent(log_parent);\n            }\n            if (log_parent) {\n                type = log_parent->nodetype;\n            } else {\n                type = 0;\n            }\n        }\n    } else {\n        assert(module);\n        assert(!(child->nodetype & (LYS_INPUT | LYS_OUTPUT)));\n        type = 0;\n        log_parent = NULL;\n    }\n\n    /* checks */\n    switch (type) {\n    case LYS_CONTAINER:\n    case LYS_LIST:\n    case LYS_GROUPING:\n    case LYS_USES:\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CHOICE | LYS_CONTAINER | LYS_GROUPING | LYS_LEAF |\n                 LYS_LEAFLIST | LYS_LIST | LYS_USES | LYS_ACTION | LYS_NOTIF))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), strnodetype(log_parent->nodetype));\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n    case LYS_NOTIF:\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CHOICE | LYS_CONTAINER | LYS_GROUPING | LYS_LEAF |\n                 LYS_LEAFLIST | LYS_LIST | LYS_USES))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), strnodetype(log_parent->nodetype));\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_CHOICE:\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CASE | LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_CHOICE))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), \"choice\");\n            return EXIT_FAILURE;\n        }\n        if (child->nodetype != LYS_CASE) {\n            shortcase = 1;\n        }\n        break;\n    case LYS_CASE:\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CHOICE | LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_USES))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), \"case\");\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_RPC:\n    case LYS_ACTION:\n        if (!(child->nodetype & (LYS_INPUT | LYS_OUTPUT | LYS_GROUPING))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), \"rpc\");\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), strnodetype(log_parent->nodetype));\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"The \\\"%s\\\" statement cannot have any data substatement.\",\n               strnodetype(log_parent->nodetype));\n        return EXIT_FAILURE;\n    case LYS_AUGMENT:\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CASE | LYS_CHOICE | LYS_CONTAINER | LYS_LEAF\n                | LYS_LEAFLIST | LYS_LIST | LYS_USES | LYS_ACTION | LYS_NOTIF))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), strnodetype(log_parent->nodetype));\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_UNKNOWN:\n        /* top level */\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CHOICE | LYS_CONTAINER | LYS_LEAF | LYS_GROUPING\n                | LYS_LEAFLIST | LYS_LIST | LYS_USES | LYS_RPC | LYS_NOTIF | LYS_AUGMENT))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), \"(sub)module\");\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_EXT:\n        /* plugin-defined */\n        p = lys_ext_complex_get_substmt(lys_snode2stmt(child->nodetype), (struct lys_ext_instance_complex*)log_parent, &info);\n        if (!p) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype),\n                   ((struct lys_ext_instance_complex*)log_parent)->def->name);\n            return EXIT_FAILURE;\n        }\n        /* TODO check cardinality */\n        break;\n    }\n\n    /* check identifier uniqueness */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && lys_check_id(child, parent, module)) {\n        return EXIT_FAILURE;\n    }\n\n    if (child->parent) {\n        lys_node_unlink(child);\n    }\n\n    if ((child->nodetype & (LYS_INPUT | LYS_OUTPUT)) && parent->nodetype != LYS_EXT) {\n        /* find the implicit input/output node */\n        LY_TREE_FOR(parent->child, iter) {\n            if (iter->nodetype == child->nodetype) {\n                break;\n            }\n        }\n        assert(iter);\n\n        /* switch the old implicit node (iter) with the new one (child) */\n        if (parent->child == iter) {\n            /* first child */\n            parent->child = child;\n        } else {\n            iter->prev->next = child;\n        }\n        child->prev = iter->prev;\n        child->next = iter->next;\n        if (iter->next) {\n            iter->next->prev = child;\n        } else {\n            /* last child */\n            parent->child->prev = child;\n        }\n        child->parent = parent;\n\n        /* isolate the node and free it */\n        iter->next = NULL;\n        iter->prev = iter;\n        iter->parent = NULL;\n        lys_node_free(iter, NULL, 0);\n    } else {\n        if (shortcase) {\n            /* create the implicit case to allow it to serve as a target of the augments,\n             * it won't be printed, but it will be present in the tree */\n            c = calloc(1, sizeof *c);\n            LY_CHECK_ERR_RETURN(!c, LOGMEM(ctx), EXIT_FAILURE);\n            c->name = lydict_insert(module->ctx, child->name, 0);\n            c->flags = LYS_IMPLICIT;\n            if (!(options & (LYS_PARSE_OPT_CFG_IGNORE | LYS_PARSE_OPT_CFG_NOINHERIT))) {\n                /* get config flag from parent */\n                c->flags |= parent->flags & LYS_CONFIG_MASK;\n            }\n            c->module = module;\n            c->nodetype = LYS_CASE;\n            c->prev = (struct lys_node*)c;\n            lys_node_addchild(parent, module, (struct lys_node*)c, options);\n            parent = (struct lys_node*)c;\n        }\n        /* connect the child correctly */\n        if (!parent) {\n            if (module->data) {\n                module->data->prev->next = child;\n                child->prev = module->data->prev;\n                module->data->prev = child;\n            } else {\n                module->data = child;\n            }\n        } else {\n            pchild = lys_child(parent, child->nodetype);\n            assert(pchild);\n\n            child->parent = parent;\n            if (!(*pchild)) {\n                /* the only/first child of the parent */\n                *pchild = child;\n                iter = child;\n            } else {\n                /* add a new child at the end of parent's child list */\n                iter = (*pchild)->prev;\n                iter->next = child;\n                child->prev = iter;\n            }\n            while (iter->next) {\n                iter = iter->next;\n                iter->parent = parent;\n            }\n            (*pchild)->prev = iter;\n        }\n    }\n\n    /* check config value (but ignore them in groupings and augments) */\n    for (iter = parent; iter && !(iter->nodetype & (LYS_GROUPING | LYS_AUGMENT | LYS_EXT)); iter = iter->parent);\n    if (parent && !iter) {\n        for (iter = child; iter && !(iter->nodetype & (LYS_NOTIF | LYS_INPUT | LYS_OUTPUT | LYS_RPC)); iter = iter->parent);\n        if (!iter && (parent->flags & LYS_CONFIG_R) && (child->flags & LYS_CONFIG_W)) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, child, \"true\", \"config\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"State nodes cannot have configuration nodes as children.\");\n            return EXIT_FAILURE;\n        }\n    }\n\n    /* propagate information about status data presence */\n    if ((child->nodetype & (LYS_CONTAINER | LYS_CHOICE | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_ANYDATA)) &&\n            (child->flags & LYS_INCL_STATUS)) {\n        for(iter = parent; iter; iter = lys_parent(iter)) {\n            /* store it only into container or list - the only data inner nodes */\n            if (iter->nodetype & (LYS_CONTAINER | LYS_LIST)) {\n                if (iter->flags & LYS_INCL_STATUS) {\n                    /* done, someone else set it already from here */\n                    break;\n                }\n                /* set flag about including status data */\n                iter->flags |= LYS_INCL_STATUS;\n            }\n        }\n    }\n\n    /* create implicit input/output nodes to have available them as possible target for augment */\n    if ((child->nodetype & (LYS_RPC | LYS_ACTION)) && !child->child) {\n        in = calloc(1, sizeof *in);\n        out = calloc(1, sizeof *out);\n        if (!in || !out) {\n            LOGMEM(ctx);\n            free(in);\n            free(out);\n            return EXIT_FAILURE;\n        }\n        in->nodetype = LYS_INPUT;\n        in->name = lydict_insert(child->module->ctx, \"input\", 5);\n        out->nodetype = LYS_OUTPUT;\n        out->name = lydict_insert(child->module->ctx, \"output\", 6);\n        in->module = out->module = child->module;\n        in->parent = out->parent = child;\n        in->flags = out->flags = LYS_IMPLICIT;\n        in->next = (struct lys_node *)out;\n        in->prev = (struct lys_node *)out;\n        out->prev = (struct lys_node *)in;\n        child->child = (struct lys_node *)in;\n    }\n    return EXIT_SUCCESS;\n}\n\nconst struct lys_module *\nlys_parse_mem_(struct ly_ctx *ctx, const char *data, LYS_INFORMAT format, const char *revision, int internal, int implement)\n{\n    char *enlarged_data = NULL;\n    struct lys_module *mod = NULL;\n    unsigned int len;\n\n    if (!ctx || !data) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (!internal && format == LYS_IN_YANG) {\n        /* enlarge data by 2 bytes for flex */\n        len = strlen(data);\n        enlarged_data = malloc((len + 2) * sizeof *enlarged_data);\n        LY_CHECK_ERR_RETURN(!enlarged_data, LOGMEM(ctx), NULL);\n        memcpy(enlarged_data, data, len);\n        enlarged_data[len] = enlarged_data[len + 1] = '\\0';\n        data = enlarged_data;\n    }\n\n    switch (format) {\n    case LYS_IN_YIN:\n        mod = yin_read_module(ctx, data, revision, implement);\n        break;\n    case LYS_IN_YANG:\n        mod = yang_read_module(ctx, data, 0, revision, implement);\n        break;\n    default:\n        LOGERR(ctx, LY_EINVAL, \"Invalid schema input format.\");\n        break;\n    }\n\n    free(enlarged_data);\n\n    /* hack for NETCONF's edit-config's operation attribute. It is not defined in the schema, but since libyang\n     * implements YANG metadata (annotations), we need its definition. Because the ietf-netconf schema is not the\n     * internal part of libyang, we cannot add the annotation into the schema source, but we do it here to have\n     * the anotation definitions available in the internal schema structure. There is another hack in schema\n     * printers to do not print this internally added annotation. */\n    if (mod && ly_strequal(mod->name, \"ietf-netconf\", 0)) {\n        if (lyp_add_ietf_netconf_annotations_config(mod)) {\n            lys_free(mod, NULL, 1, 1);\n            return NULL;\n        }\n    }\n\n    return mod;\n}\n\nAPI const struct lys_module *\nlys_parse_mem(struct ly_ctx *ctx, const char *data, LYS_INFORMAT format)\n{\n    return lys_parse_mem_(ctx, data, format, NULL, 0, 1);\n}\n\nstruct lys_submodule *\nlys_sub_parse_mem(struct lys_module *module, const char *data, LYS_INFORMAT format, struct unres_schema *unres)\n{\n    char *enlarged_data = NULL;\n    struct lys_submodule *submod = NULL;\n    unsigned int len;\n\n    assert(module);\n    assert(data);\n\n    if (format == LYS_IN_YANG) {\n        /* enlarge data by 2 bytes for flex */\n        len = strlen(data);\n        enlarged_data = malloc((len + 2) * sizeof *enlarged_data);\n        LY_CHECK_ERR_RETURN(!enlarged_data, LOGMEM(module->ctx), NULL);\n        memcpy(enlarged_data, data, len);\n        enlarged_data[len] = enlarged_data[len + 1] = '\\0';\n        data = enlarged_data;\n    }\n\n    /* get the main module */\n    module = lys_main_module(module);\n\n    switch (format) {\n    case LYS_IN_YIN:\n        submod = yin_read_submodule(module, data, unres);\n        break;\n    case LYS_IN_YANG:\n        submod = yang_read_submodule(module, data, 0, unres);\n        break;\n    default:\n        assert(0);\n        break;\n    }\n\n    free(enlarged_data);\n    return submod;\n}\n\nAPI const struct lys_module *\nlys_parse_path(struct ly_ctx *ctx, const char *path, LYS_INFORMAT format)\n{\n    int fd;\n    const struct lys_module *ret;\n    const char *rev, *dot, *filename;\n    size_t len;\n\n    if (!ctx || !path) {\n        LOGARG;\n        return NULL;\n    }\n\n    fd = open(path, O_RDONLY);\n    if (fd == -1) {\n        LOGERR(ctx, LY_ESYS, \"Opening file \\\"%s\\\" failed (%s).\", path, strerror(errno));\n        return NULL;\n    }\n\n    ret = lys_parse_fd(ctx, fd, format);\n    close(fd);\n\n    if (!ret) {\n        /* error */\n        return NULL;\n    }\n\n    /* check that name and revision match filename */\n    filename = strrchr(path, '/');\n    if (!filename) {\n        filename = path;\n    } else {\n        filename++;\n    }\n    rev = strchr(filename, '@');\n    dot = strrchr(filename, '.');\n\n    /* name */\n    len = strlen(ret->name);\n    if (strncmp(filename, ret->name, len) ||\n            ((rev && rev != &filename[len]) || (!rev && dot != &filename[len]))) {\n        LOGWRN(ctx, \"File name \\\"%s\\\" does not match module name \\\"%s\\\".\", filename, ret->name);\n    }\n    if (rev) {\n        len = dot - ++rev;\n        if (!ret->rev_size || len != 10 || strncmp(ret->rev[0].date, rev, len)) {\n            LOGWRN(ctx, \"File name \\\"%s\\\" does not match module revision \\\"%s\\\".\", filename,\n                   ret->rev_size ? ret->rev[0].date : \"none\");\n        }\n    }\n\n    if (!ret->filepath) {\n        /* store URI */\n        char rpath[PATH_MAX];\n        if (realpath(path, rpath) != NULL) {\n            ((struct lys_module *)ret)->filepath = lydict_insert(ctx, rpath, 0);\n        } else {\n            ((struct lys_module *)ret)->filepath = lydict_insert(ctx, path, 0);\n        }\n    }\n\n    return ret;\n}\n\nAPI const struct lys_module *\nlys_parse_fd(struct ly_ctx *ctx, int fd, LYS_INFORMAT format)\n{\n    return lys_parse_fd_(ctx, fd, format, NULL, 1);\n}\n\nstatic void\nlys_parse_set_filename(struct ly_ctx *ctx, const char **filename, int fd)\n{\n#ifdef __APPLE__\n    char path[MAXPATHLEN];\n#else\n    int len;\n    char path[PATH_MAX], proc_path[32];\n#endif\n\n#ifdef __APPLE__\n    if (fcntl(fd, F_GETPATH, path) != -1) {\n        *filename = lydict_insert(ctx, path, 0);\n    }\n#else\n    /* get URI if there is /proc */\n    sprintf(proc_path, \"/proc/self/fd/%d\", fd);\n    if ((len = readlink(proc_path, path, PATH_MAX - 1)) > 0) {\n        *filename = lydict_insert(ctx, path, len);\n    }\n#endif\n}\n\nconst struct lys_module *\nlys_parse_fd_(struct ly_ctx *ctx, int fd, LYS_INFORMAT format, const char *revision, int implement)\n{\n    const struct lys_module *module;\n    size_t length;\n    char *addr;\n\n    if (!ctx || fd < 0) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (lyp_mmap(ctx, fd, format == LYS_IN_YANG ? 1 : 0, &length, (void **)&addr)) {\n        LOGERR(ctx, LY_ESYS, \"Mapping file descriptor into memory failed (%s()).\", __func__);\n        return NULL;\n    } else if (!addr) {\n        LOGERR(ctx, LY_EINVAL, \"Empty schema file.\");\n        return NULL;\n    }\n\n    module = lys_parse_mem_(ctx, addr, format, revision, 1, implement);\n    lyp_munmap(addr, length);\n\n    if (module && !module->filepath) {\n        lys_parse_set_filename(ctx, (const char **)&module->filepath, fd);\n    }\n\n    return module;\n}\n\nstruct lys_submodule *\nlys_sub_parse_fd(struct lys_module *module, int fd, LYS_INFORMAT format, struct unres_schema *unres)\n{\n    struct lys_submodule *submodule;\n    size_t length;\n    char *addr;\n\n    assert(module);\n    assert(fd >= 0);\n\n    if (lyp_mmap(module->ctx, fd, format == LYS_IN_YANG ? 1 : 0, &length, (void **)&addr)) {\n        LOGERR(module->ctx, LY_ESYS, \"Mapping file descriptor into memory failed (%s()).\", __func__);\n        return NULL;\n    } else if (!addr) {\n        LOGERR(module->ctx, LY_EINVAL, \"Empty submodule schema file.\");\n        return NULL;\n    }\n\n    /* get the main module */\n    module = lys_main_module(module);\n\n    switch (format) {\n    case LYS_IN_YIN:\n        submodule = yin_read_submodule(module, addr, unres);\n        break;\n    case LYS_IN_YANG:\n        submodule = yang_read_submodule(module, addr, 0, unres);\n        break;\n    default:\n        LOGINT(module->ctx);\n        return NULL;\n    }\n\n    lyp_munmap(addr, length);\n\n    if (submodule && !submodule->filepath) {\n        lys_parse_set_filename(module->ctx, (const char **)&submodule->filepath, fd);\n    }\n\n    return submodule;\n\n}\n\nAPI int\nlys_search_localfile(const char * const *searchpaths, int cwd, const char *name, const char *revision, char **localfile, LYS_INFORMAT *format)\n{\n    size_t len, flen, match_len = 0, dir_len;\n    int i, implicit_cwd = 0, ret = EXIT_FAILURE;\n    char *wd, *wn = NULL;\n    DIR *dir = NULL;\n    struct dirent *file;\n    char *match_name = NULL;\n    LYS_INFORMAT format_aux, match_format = 0;\n    unsigned int u;\n    struct ly_set *dirs;\n    struct stat st;\n\n    if (!localfile) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    /* start to fill the dir fifo with the context's search path (if set)\n     * and the current working directory */\n    dirs = ly_set_new();\n    if (!dirs) {\n        LOGMEM(NULL);\n        return EXIT_FAILURE;\n    }\n\n    len = strlen(name);\n    if (cwd) {\n        wd = get_current_dir_name();\n        if (!wd) {\n            LOGMEM(NULL);\n            goto cleanup;\n        } else {\n            /* add implicit current working directory (./) to be searched,\n             * this directory is not searched recursively */\n            if (ly_set_add(dirs, wd, 0) == -1) {\n                goto cleanup;\n            }\n            implicit_cwd = 1;\n        }\n    }\n    if (searchpaths) {\n        for (i = 0; searchpaths[i]; i++) {\n            /* check for duplicities with the implicit current working directory */\n            if (implicit_cwd && !strcmp(dirs->set.g[0], searchpaths[i])) {\n                implicit_cwd = 0;\n                continue;\n            }\n            wd = strdup(searchpaths[i]);\n            if (!wd) {\n                LOGMEM(NULL);\n                goto cleanup;\n            } else if (ly_set_add(dirs, wd, 0) == -1) {\n                goto cleanup;\n            }\n        }\n    }\n    wd = NULL;\n\n    /* start searching */\n    while (dirs->number) {\n        free(wd);\n        free(wn); wn = NULL;\n\n        dirs->number--;\n        wd = (char *)dirs->set.g[dirs->number];\n        dirs->set.g[dirs->number] = NULL;\n        LOGVRB(\"Searching for \\\"%s\\\" in %s.\", name, wd);\n\n        if (dir) {\n            closedir(dir);\n        }\n        dir = opendir(wd);\n        dir_len = strlen(wd);\n        if (!dir) {\n            LOGWRN(NULL, \"Unable to open directory \\\"%s\\\" for searching (sub)modules (%s).\", wd, strerror(errno));\n        } else {\n            while ((file = readdir(dir))) {\n                if (!strcmp(\".\", file->d_name) || !strcmp(\"..\", file->d_name)) {\n                    /* skip . and .. */\n                    continue;\n                }\n                free(wn);\n                if (asprintf(&wn, \"%s/%s\", wd, file->d_name) == -1) {\n                    LOGMEM(NULL);\n                    goto cleanup;\n                }\n                if (stat(wn, &st) == -1) {\n                    LOGWRN(NULL, \"Unable to get information about \\\"%s\\\" file in \\\"%s\\\" when searching for (sub)modules (%s)\",\n                           file->d_name, wd, strerror(errno));\n                    continue;\n                }\n                if (S_ISDIR(st.st_mode) && (dirs->number || !implicit_cwd)) {\n                    /* we have another subdirectory in searchpath to explore,\n                     * subdirectories are not taken into account in current working dir (dirs->set.g[0]) */\n                    if (ly_set_add(dirs, wn, 0) == -1) {\n                        goto cleanup;\n                    }\n                    /* continue with the next item in current directory */\n                    wn = NULL;\n                    continue;\n                } else if (!S_ISREG(st.st_mode)) {\n                    /* not a regular file (note that we see the target of symlinks instead of symlinks */\n                    continue;\n                }\n\n                /* here we know that the item is a file which can contain a module */\n                if (strncmp(name, file->d_name, len) ||\n                        (file->d_name[len] != '.' && file->d_name[len] != '@')) {\n                    /* different filename than the module we search for */\n                    continue;\n                }\n\n                /* get type according to filename suffix */\n                flen = strlen(file->d_name);\n                if (!strcmp(&file->d_name[flen - 4], \".yin\")) {\n                    format_aux = LYS_IN_YIN;\n                } else if (!strcmp(&file->d_name[flen - 5], \".yang\")) {\n                    format_aux = LYS_IN_YANG;\n                } else {\n                    /* not supportde suffix/file format */\n                    continue;\n                }\n\n                if (revision) {\n                    /* we look for the specific revision, try to get it from the filename */\n                    if (file->d_name[len] == '@') {\n                        /* check revision from the filename */\n                        if (strncmp(revision, &file->d_name[len + 1], strlen(revision))) {\n                            /* another revision */\n                            continue;\n                        } else {\n                            /* exact revision */\n                            free(match_name);\n                            match_name = wn;\n                            wn = NULL;\n                            match_len = dir_len + 1 + len;\n                            match_format = format_aux;\n                            goto success;\n                        }\n                    } else {\n                        /* continue trying to find exact revision match, use this only if not found */\n                        free(match_name);\n                        match_name = wn;\n                        wn = NULL;\n                        match_len = dir_len + 1 +len;\n                        match_format = format_aux;\n                        continue;\n                    }\n                } else {\n                    /* remember the revision and try to find the newest one */\n                    if (match_name) {\n                        if (file->d_name[len] != '@' || lyp_check_date(NULL, &file->d_name[len + 1])) {\n                            continue;\n                        } else if (match_name[match_len] == '@' &&\n                                (strncmp(&match_name[match_len + 1], &file->d_name[len + 1], LY_REV_SIZE - 1) >= 0)) {\n                            continue;\n                        }\n                        free(match_name);\n                    }\n\n                    match_name = wn;\n                    wn = NULL;\n                    match_len = dir_len + 1 + len;\n                    match_format = format_aux;\n                    continue;\n                }\n            }\n        }\n    }\n\nsuccess:\n    (*localfile) = match_name;\n    match_name = NULL;\n    if (format) {\n        (*format) = match_format;\n    }\n    ret = EXIT_SUCCESS;\n\ncleanup:\n    free(wn);\n    free(wd);\n    if (dir) {\n        closedir(dir);\n    }\n    free(match_name);\n    for (u = 0; u < dirs->number; u++) {\n        free(dirs->set.g[u]);\n    }\n    ly_set_free(dirs);\n\n    return ret;\n}\n\nint\nlys_ext_iter(struct lys_ext_instance **ext, uint8_t ext_size, uint8_t start, LYEXT_SUBSTMT substmt)\n{\n    unsigned int u;\n\n    for (u = start; u < ext_size; u++) {\n        if (ext[u]->insubstmt == substmt) {\n            return u;\n        }\n    }\n\n    return -1;\n}\n\n/*\n * duplicate extension instance\n */\nint\nlys_ext_dup(struct ly_ctx *ctx, struct lys_module *mod, struct lys_ext_instance **orig, uint8_t size, void *parent,\n            LYEXT_PAR parent_type, struct lys_ext_instance ***new, int shallow, struct unres_schema *unres)\n{\n    int i;\n    uint8_t u = 0;\n    struct lys_ext_instance **result;\n    struct unres_ext *info, *info_orig;\n    size_t len;\n\n    assert(new);\n\n    if (!size) {\n        if (orig) {\n            LOGINT(ctx);\n            return EXIT_FAILURE;\n        }\n        (*new) = NULL;\n        return EXIT_SUCCESS;\n    }\n\n    (*new) = result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(ctx), EXIT_FAILURE);\n    for (u = 0; u < size; u++) {\n        if (orig[u]) {\n            /* resolved extension instance, just duplicate it */\n            switch(orig[u]->ext_type) {\n            case LYEXT_FLAG:\n                result[u] = malloc(sizeof(struct lys_ext_instance));\n                LY_CHECK_ERR_GOTO(!result[u], LOGMEM(ctx), error);\n                break;\n            case LYEXT_COMPLEX:\n                len = ((struct lyext_plugin_complex*)orig[u]->def->plugin)->instance_size;\n                result[u] = calloc(1, len);\n                LY_CHECK_ERR_GOTO(!result[u], LOGMEM(ctx), error);\n\n                ((struct lys_ext_instance_complex*)result[u])->substmt = ((struct lyext_plugin_complex*)orig[u]->def->plugin)->substmt;\n                /* TODO duplicate data in extension instance content */\n                memcpy((void*)result[u] + sizeof(**orig), (void*)orig[u] + sizeof(**orig), len - sizeof(**orig));\n                break;\n            }\n            /* generic part */\n            result[u]->def = orig[u]->def;\n            result[u]->flags = LYEXT_OPT_CONTENT;\n            result[u]->arg_value = lydict_insert(ctx, orig[u]->arg_value, 0);\n            result[u]->parent = parent;\n            result[u]->parent_type = parent_type;\n            result[u]->insubstmt = orig[u]->insubstmt;\n            result[u]->insubstmt_index = orig[u]->insubstmt_index;\n            result[u]->ext_type = orig[u]->ext_type;\n            result[u]->priv = NULL;\n            result[u]->nodetype = LYS_EXT;\n            result[u]->module = mod;\n\n            /* extensions */\n            result[u]->ext_size = orig[u]->ext_size;\n            if (lys_ext_dup(ctx, mod, orig[u]->ext, orig[u]->ext_size, result[u],\n                            LYEXT_PAR_EXTINST, &result[u]->ext, shallow, unres)) {\n                goto error;\n            }\n\n            /* in case of shallow copy (duplication for deviation), duplicate only the link to private data\n             * in a new copy, otherwise (grouping instantiation) do not duplicate the private data */\n            if (shallow) {\n                result[u]->priv = orig[u]->priv;\n            }\n        } else {\n            /* original extension is not yet resolved, so duplicate it in unres */\n            i = unres_schema_find(unres, -1, &orig, UNRES_EXT);\n            if (i == -1) {\n                /* extension not found in unres */\n                LOGINT(ctx);\n                goto error;\n            }\n            info_orig = unres->str_snode[i];\n            info = malloc(sizeof *info);\n            LY_CHECK_ERR_GOTO(!info, LOGMEM(ctx), error);\n            info->datatype = info_orig->datatype;\n            if (info->datatype == LYS_IN_YIN) {\n                info->data.yin = lyxml_dup_elem(ctx, info_orig->data.yin, NULL, 1);\n            } /* else TODO YANG */\n            info->parent = parent;\n            info->mod = mod;\n            info->parent_type = parent_type;\n            info->ext_index = u;\n            if (unres_schema_add_node(info->mod, unres, new, UNRES_EXT, (struct lys_node *)info) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    (*new) = NULL;\n    lys_extension_instances_free(ctx, result, u, NULL);\n    return EXIT_FAILURE;\n}\n\nstatic struct lys_restr *\nlys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n\n    if (!size) {\n        return NULL;\n    }\n\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n\n    for (i = 0; i < size; i++) {\n        result[i].ext_size = old[i].ext_size;\n        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n\n    return result;\n}\n\nvoid\nlys_restr_free(struct ly_ctx *ctx, struct lys_restr *restr,\n               void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    assert(ctx);\n    if (!restr) {\n        return;\n    }\n\n    lys_extension_instances_free(ctx, restr->ext, restr->ext_size, private_destructor);\n    lydict_remove(ctx, restr->expr);\n    lydict_remove(ctx, restr->dsc);\n    lydict_remove(ctx, restr->ref);\n    lydict_remove(ctx, restr->eapptag);\n    lydict_remove(ctx, restr->emsg);\n}\n\nAPI void\nlys_iffeature_free(struct ly_ctx *ctx, struct lys_iffeature *iffeature, uint8_t iffeature_size,\n                   int shallow, void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    uint8_t i;\n\n    for (i = 0; i < iffeature_size; ++i) {\n        lys_extension_instances_free(ctx, iffeature[i].ext, iffeature[i].ext_size, private_destructor);\n        if (!shallow) {\n            free(iffeature[i].expr);\n            free(iffeature[i].features);\n        }\n    }\n    free(iffeature);\n}\n\nstatic int\ntype_dup(struct lys_module *mod, struct lys_node *parent, struct lys_type *new, struct lys_type *old,\n         LY_DATA_TYPE base, int in_grp, int shallow, struct unres_schema *unres)\n{\n    int i;\n    unsigned int u;\n\n    switch (base) {\n    case LY_TYPE_BINARY:\n        if (old->info.binary.length) {\n            new->info.binary.length = lys_restr_dup(mod, old->info.binary.length, 1, shallow, unres);\n        }\n        break;\n\n    case LY_TYPE_BITS:\n        new->info.bits.count = old->info.bits.count;\n        if (new->info.bits.count) {\n            new->info.bits.bit = calloc(new->info.bits.count, sizeof *new->info.bits.bit);\n            LY_CHECK_ERR_RETURN(!new->info.bits.bit, LOGMEM(mod->ctx), -1);\n\n            for (u = 0; u < new->info.bits.count; u++) {\n                new->info.bits.bit[u].name = lydict_insert(mod->ctx, old->info.bits.bit[u].name, 0);\n                new->info.bits.bit[u].dsc = lydict_insert(mod->ctx, old->info.bits.bit[u].dsc, 0);\n                new->info.bits.bit[u].ref = lydict_insert(mod->ctx, old->info.bits.bit[u].ref, 0);\n                new->info.bits.bit[u].flags = old->info.bits.bit[u].flags;\n                new->info.bits.bit[u].pos = old->info.bits.bit[u].pos;\n                new->info.bits.bit[u].ext_size = old->info.bits.bit[u].ext_size;\n                if (lys_ext_dup(mod->ctx, mod, old->info.bits.bit[u].ext, old->info.bits.bit[u].ext_size,\n                                &new->info.bits.bit[u], LYEXT_PAR_TYPE_BIT,\n                                &new->info.bits.bit[u].ext, shallow, unres)) {\n                    return -1;\n                }\n            }\n        }\n        break;\n\n    case LY_TYPE_DEC64:\n        new->info.dec64.dig = old->info.dec64.dig;\n        new->info.dec64.div = old->info.dec64.div;\n        if (old->info.dec64.range) {\n            new->info.dec64.range = lys_restr_dup(mod, old->info.dec64.range, 1, shallow, unres);\n        }\n        break;\n\n    case LY_TYPE_ENUM:\n        new->info.enums.count = old->info.enums.count;\n        if (new->info.enums.count) {\n            new->info.enums.enm = calloc(new->info.enums.count, sizeof *new->info.enums.enm);\n            LY_CHECK_ERR_RETURN(!new->info.enums.enm, LOGMEM(mod->ctx), -1);\n\n            for (u = 0; u < new->info.enums.count; u++) {\n                new->info.enums.enm[u].name = lydict_insert(mod->ctx, old->info.enums.enm[u].name, 0);\n                new->info.enums.enm[u].dsc = lydict_insert(mod->ctx, old->info.enums.enm[u].dsc, 0);\n                new->info.enums.enm[u].ref = lydict_insert(mod->ctx, old->info.enums.enm[u].ref, 0);\n                new->info.enums.enm[u].flags = old->info.enums.enm[u].flags;\n                new->info.enums.enm[u].value = old->info.enums.enm[u].value;\n                new->info.enums.enm[u].ext_size = old->info.enums.enm[u].ext_size;\n                if (lys_ext_dup(mod->ctx, mod, old->info.enums.enm[u].ext, old->info.enums.enm[u].ext_size,\n                                &new->info.enums.enm[u], LYEXT_PAR_TYPE_ENUM,\n                                &new->info.enums.enm[u].ext, shallow, unres)) {\n                    return -1;\n                }\n            }\n        }\n        break;\n\n    case LY_TYPE_IDENT:\n        new->info.ident.count = old->info.ident.count;\n        if (old->info.ident.count) {\n            new->info.ident.ref = malloc(old->info.ident.count * sizeof *new->info.ident.ref);\n            LY_CHECK_ERR_RETURN(!new->info.ident.ref, LOGMEM(mod->ctx), -1);\n            memcpy(new->info.ident.ref, old->info.ident.ref, old->info.ident.count * sizeof *new->info.ident.ref);\n        } else {\n            /* there can be several unresolved base identities, duplicate them all */\n            i = -1;\n            do {\n                i = unres_schema_find(unres, i, old, UNRES_TYPE_IDENTREF);\n                if (i != -1) {\n                    if (unres_schema_add_str(mod, unres, new, UNRES_TYPE_IDENTREF, unres->str_snode[i]) == -1) {\n                        return -1;\n                    }\n                }\n                --i;\n            } while (i > -1);\n        }\n        break;\n\n    case LY_TYPE_INST:\n        new->info.inst.req = old->info.inst.req;\n        break;\n\n    case LY_TYPE_INT8:\n    case LY_TYPE_INT16:\n    case LY_TYPE_INT32:\n    case LY_TYPE_INT64:\n    case LY_TYPE_UINT8:\n    case LY_TYPE_UINT16:\n    case LY_TYPE_UINT32:\n    case LY_TYPE_UINT64:\n        if (old->info.num.range) {\n            new->info.num.range = lys_restr_dup(mod, old->info.num.range, 1, shallow, unres);\n        }\n        break;\n\n    case LY_TYPE_LEAFREF:\n        if (old->info.lref.path) {\n            new->info.lref.path = lydict_insert(mod->ctx, old->info.lref.path, 0);\n            new->info.lref.req = old->info.lref.req;\n            if (!in_grp && unres_schema_add_node(mod, unres, new, UNRES_TYPE_LEAFREF, parent) == -1) {\n                return -1;\n            }\n        }\n        break;\n\n    case LY_TYPE_STRING:\n        if (old->info.str.length) {\n            new->info.str.length = lys_restr_dup(mod, old->info.str.length, 1, shallow, unres);\n        }\n        if (old->info.str.pat_count) {\n            new->info.str.patterns = lys_restr_dup(mod, old->info.str.patterns, old->info.str.pat_count, shallow, unres);\n            new->info.str.pat_count = old->info.str.pat_count;\n#ifdef LY_ENABLED_CACHE\n            if (!in_grp) {\n                new->info.str.patterns_pcre = malloc(new->info.str.pat_count * 2 * sizeof *new->info.str.patterns_pcre);\n                LY_CHECK_ERR_RETURN(!new->info.str.patterns_pcre, LOGMEM(mod->ctx), -1);\n                for (u = 0; u < new->info.str.pat_count; u++) {\n                    if (lyp_precompile_pattern(mod->ctx, &new->info.str.patterns[u].expr[1],\n                                              (pcre**)&new->info.str.patterns_pcre[2 * u],\n                                              (pcre_extra**)&new->info.str.patterns_pcre[2 * u + 1])) {\n                        free(new->info.str.patterns_pcre);\n                        new->info.str.patterns_pcre = NULL;\n                        return -1;\n                    }\n                }\n            }\n#endif\n        }\n        break;\n\n    case LY_TYPE_UNION:\n        new->info.uni.has_ptr_type = old->info.uni.has_ptr_type;\n        new->info.uni.count = old->info.uni.count;\n        if (new->info.uni.count) {\n            new->info.uni.types = calloc(new->info.uni.count, sizeof *new->info.uni.types);\n            LY_CHECK_ERR_RETURN(!new->info.uni.types, LOGMEM(mod->ctx), -1);\n\n            for (u = 0; u < new->info.uni.count; u++) {\n                if (lys_type_dup(mod, parent, &(new->info.uni.types[u]), &(old->info.uni.types[u]), in_grp,\n                        shallow, unres)) {\n                    return -1;\n                }\n            }\n        }\n        break;\n\n    default:\n        /* nothing to do for LY_TYPE_BOOL, LY_TYPE_EMPTY */\n        break;\n    }\n\n    return EXIT_SUCCESS;\n}\n\nstruct yang_type *\nlys_yang_type_dup(struct lys_module *module, struct lys_node *parent, struct yang_type *old, struct lys_type *type,\n                  int in_grp, int shallow, struct unres_schema *unres)\n{\n    struct yang_type *new;\n\n    new = calloc(1, sizeof *new);\n    LY_CHECK_ERR_RETURN(!new, LOGMEM(module->ctx), NULL);\n    new->flags = old->flags;\n    new->base = old->base;\n    new->name = lydict_insert(module->ctx, old->name, 0);\n    new->type = type;\n    if (!new->name) {\n        LOGMEM(module->ctx);\n        goto error;\n    }\n    if (type_dup(module, parent, type, old->type, new->base, in_grp, shallow, unres)) {\n        new->type->base = new->base;\n        lys_type_free(module->ctx, new->type, NULL);\n        memset(&new->type->info, 0, sizeof new->type->info);\n        goto error;\n    }\n    return new;\n\nerror:\n    free(new);\n    return NULL;\n}\n\nint\nlys_copy_union_leafrefs(struct lys_module *mod, struct lys_node *parent, struct lys_type *type, struct lys_type *prev_new,\n                        struct unres_schema *unres)\n{\n    struct lys_type new;\n    unsigned int i, top_type;\n    struct lys_ext_instance **ext;\n    uint8_t ext_size;\n    void *reloc;\n\n    if (!prev_new) {\n        /* this is the \"top-level\" type, meaning it is a real type and no typedef directly above */\n        top_type = 1;\n\n        memset(&new, 0, sizeof new);\n\n        new.base = type->base;\n        new.parent = (struct lys_tpdf *)parent;\n\n        prev_new = &new;\n    } else {\n        /* this is not top-level type, just a type of a typedef */\n        top_type = 0;\n    }\n\n    assert(type->der);\n    if (type->der->module) {\n        /* typedef, skip it, but keep the extensions */\n        ext_size = type->ext_size;\n        if (lys_ext_dup(mod->ctx, mod, type->ext, type->ext_size, prev_new, LYEXT_PAR_TYPE, &ext, 0, unres)) {\n            return -1;\n        }\n        if (prev_new->ext) {\n            reloc = realloc(prev_new->ext, (prev_new->ext_size + ext_size) * sizeof *prev_new->ext);\n            LY_CHECK_ERR_RETURN(!reloc, LOGMEM(mod->ctx), -1);\n            prev_new->ext = reloc;\n\n            memcpy(prev_new->ext + prev_new->ext_size, ext, ext_size * sizeof *ext);\n            free(ext);\n\n            prev_new->ext_size += ext_size;\n        } else {\n            prev_new->ext = ext;\n            prev_new->ext_size = ext_size;\n        }\n\n        if (lys_copy_union_leafrefs(mod, parent, &type->der->type, prev_new, unres)) {\n            return -1;\n        }\n    } else {\n        /* type, just make a deep copy */\n        switch (type->base) {\n        case LY_TYPE_UNION:\n            prev_new->info.uni.has_ptr_type = type->info.uni.has_ptr_type;\n            prev_new->info.uni.count = type->info.uni.count;\n            /* this cannot be a typedef anymore */\n            assert(prev_new->info.uni.count);\n\n            prev_new->info.uni.types = calloc(prev_new->info.uni.count, sizeof *prev_new->info.uni.types);\n            LY_CHECK_ERR_RETURN(!prev_new->info.uni.types, LOGMEM(mod->ctx), -1);\n\n            for (i = 0; i < prev_new->info.uni.count; i++) {\n                if (lys_copy_union_leafrefs(mod, parent, &(type->info.uni.types[i]), &(prev_new->info.uni.types[i]), unres)) {\n                    return -1;\n                }\n            }\n\n            prev_new->der = type->der;\n            break;\n        default:\n            if (lys_type_dup(mod, parent, prev_new, type, 0, 0, unres)) {\n                return -1;\n            }\n            break;\n        }\n    }\n\n    if (top_type) {\n        memcpy(type, prev_new, sizeof *type);\n    }\n    return EXIT_SUCCESS;\n}\n\nAPI const void *\nlys_ext_instance_substmt(const struct lys_ext_instance *ext)\n{\n    if (!ext) {\n        return NULL;\n    }\n\n    switch (ext->insubstmt) {\n    case LYEXT_SUBSTMT_SELF:\n    case LYEXT_SUBSTMT_MODIFIER:\n    case LYEXT_SUBSTMT_VERSION:\n        return NULL;\n    case LYEXT_SUBSTMT_ARGUMENT:\n        if (ext->parent_type == LYEXT_PAR_EXT) {\n            return ((struct lys_ext_instance*)ext->parent)->arg_value;\n        }\n        break;\n    case LYEXT_SUBSTMT_BASE:\n        if (ext->parent_type == LYEXT_PAR_TYPE) {\n            return ((struct lys_type*)ext->parent)->info.ident.ref[ext->insubstmt_index];\n        } else if (ext->parent_type == LYEXT_PAR_IDENT) {\n            return ((struct lys_ident*)ext->parent)->base[ext->insubstmt_index];\n        }\n        break;\n    case LYEXT_SUBSTMT_BELONGSTO:\n        if (ext->parent_type == LYEXT_PAR_MODULE && ((struct lys_module*)ext->parent)->type) {\n            return ((struct lys_submodule*)ext->parent)->belongsto;\n        }\n        break;\n    case LYEXT_SUBSTMT_CONFIG:\n    case LYEXT_SUBSTMT_MANDATORY:\n        if (ext->parent_type == LYEXT_PAR_NODE) {\n            return &((struct lys_node*)ext->parent)->flags;\n        } else if (ext->parent_type == LYEXT_PAR_DEVIATE) {\n            return &((struct lys_deviate*)ext->parent)->flags;\n        } else if (ext->parent_type == LYEXT_PAR_REFINE) {\n            return &((struct lys_refine*)ext->parent)->flags;\n        }\n        break;\n    case LYEXT_SUBSTMT_CONTACT:\n        if (ext->parent_type == LYEXT_PAR_MODULE) {\n            return ((struct lys_module*)ext->parent)->contact;\n        }\n        break;\n    case LYEXT_SUBSTMT_DEFAULT:\n        if (ext->parent_type == LYEXT_PAR_NODE) {\n            switch (((struct lys_node*)ext->parent)->nodetype) {\n            case LYS_LEAF:\n            case LYS_LEAFLIST:\n                /* in case of leaf, the index is supposed to be 0, so it will return the\n                 * correct pointer despite the leaf structure does not have dflt as array */\n                return ((struct lys_node_leaflist*)ext->parent)->dflt[ext->insubstmt_index];\n            case LYS_CHOICE:\n                return ((struct lys_node_choice*)ext->parent)->dflt;\n            default:\n                /* internal error */\n                break;\n            }\n        } else if (ext->parent_type == LYEXT_PAR_TPDF) {\n            return ((struct lys_tpdf*)ext->parent)->dflt;\n        } else if (ext->parent_type == LYEXT_PAR_DEVIATE) {\n            return ((struct lys_deviate*)ext->parent)->dflt[ext->insubstmt_index];\n        } else if (ext->parent_type == LYEXT_PAR_REFINE) {\n            return &((struct lys_refine*)ext->parent)->dflt[ext->insubstmt_index];\n        }\n        break;\n    case LYEXT_SUBSTMT_DESCRIPTION:\n        switch (ext->parent_type) {\n        case LYEXT_PAR_NODE:\n            return ((struct lys_node*)ext->parent)->dsc;\n        case LYEXT_PAR_MODULE:\n            return ((struct lys_module*)ext->parent)->dsc;\n        case LYEXT_PAR_IMPORT:\n            return ((struct lys_import*)ext->parent)->dsc;\n        case LYEXT_PAR_INCLUDE:\n            return ((struct lys_include*)ext->parent)->dsc;\n        case LYEXT_PAR_EXT:\n            return ((struct lys_ext*)ext->parent)->dsc;\n        case LYEXT_PAR_FEATURE:\n            return ((struct lys_feature*)ext->parent)->dsc;\n        case LYEXT_PAR_TPDF:\n            return ((struct lys_tpdf*)ext->parent)->dsc;\n        case LYEXT_PAR_TYPE_BIT:\n            return ((struct lys_type_bit*)ext->parent)->dsc;\n        case LYEXT_PAR_TYPE_ENUM:\n            return ((struct lys_type_enum*)ext->parent)->dsc;\n        case LYEXT_PAR_RESTR:\n            return ((struct lys_restr*)ext->parent)->dsc;\n        case LYEXT_PAR_WHEN:\n            return ((struct lys_when*)ext->parent)->dsc;\n        case LYEXT_PAR_IDENT:\n            return ((struct lys_ident*)ext->parent)->dsc;\n        case LYEXT_PAR_DEVIATION:\n            return ((struct lys_deviation*)ext->parent)->dsc;\n        case LYEXT_PAR_REVISION:\n            return ((struct lys_revision*)ext->parent)->dsc;\n        case LYEXT_PAR_REFINE:\n            return ((struct lys_refine*)ext->parent)->dsc;\n        default:\n            break;\n        }\n        break;\n    case LYEXT_SUBSTMT_ERRTAG:\n        if (ext->parent_type == LYEXT_PAR_RESTR) {\n            return ((struct lys_restr*)ext->parent)->eapptag;\n        }\n        break;\n    case LYEXT_SUBSTMT_ERRMSG:\n        if (ext->parent_type == LYEXT_PAR_RESTR) {\n            return ((struct lys_restr*)ext->parent)->emsg;\n        }\n        break;\n    case LYEXT_SUBSTMT_DIGITS:\n        if (ext->parent_type == LYEXT_PAR_TYPE && ((struct lys_type*)ext->parent)->base == LY_TYPE_DEC64) {\n            return &((struct lys_type*)ext->parent)->info.dec64.dig;\n        }\n        break;\n    case LYEXT_SUBSTMT_KEY:\n        if (ext->parent_type == LYEXT_PAR_NODE && ((struct lys_node*)ext->parent)->nodetype == LYS_LIST) {\n            return ((struct lys_node_list*)ext->parent)->keys;\n        }\n        break;\n    case LYEXT_SUBSTMT_MAX:\n        if (ext->parent_type == LYEXT_PAR_NODE) {\n            if (((struct lys_node*)ext->parent)->nodetype == LYS_LIST) {\n                return &((struct lys_node_list*)ext->parent)->max;\n            } else if (((struct lys_node*)ext->parent)->nodetype == LYS_LEAFLIST) {\n                return &((struct lys_node_leaflist*)ext->parent)->max;\n            }\n        } else if (ext->parent_type == LYEXT_PAR_REFINE) {\n            return &((struct lys_refine*)ext->parent)->mod.list.max;\n        }\n        break;\n    case LYEXT_SUBSTMT_MIN:\n        if (ext->parent_type == LYEXT_PAR_NODE) {\n            if (((struct lys_node*)ext->parent)->nodetype == LYS_LIST) {\n                return &((struct lys_node_list*)ext->parent)->min;\n            } else if (((struct lys_node*)ext->parent)->nodetype == LYS_LEAFLIST) {\n                return &((struct lys_node_leaflist*)ext->parent)->min;\n            }\n        } else if (ext->parent_type == LYEXT_PAR_REFINE) {\n            return &((struct lys_refine*)ext->parent)->mod.list.min;\n        }\n        break;\n    case LYEXT_SUBSTMT_NAMESPACE:\n        if (ext->parent_type == LYEXT_PAR_MODULE && !((struct lys_module*)ext->parent)->type) {\n            return ((struct lys_module*)ext->parent)->ns;\n        }\n        break;\n    case LYEXT_SUBSTMT_ORDEREDBY:\n        if (ext->parent_type == LYEXT_PAR_NODE &&\n                (((struct lys_node*)ext->parent)->nodetype & (LYS_LIST | LYS_LEAFLIST))) {\n            return &((struct lys_node_list*)ext->parent)->flags;\n        }\n        break;\n    case LYEXT_SUBSTMT_ORGANIZATION:\n        if (ext->parent_type == LYEXT_PAR_MODULE) {\n            return ((struct lys_module*)ext->parent)->org;\n        }\n        break;\n    case LYEXT_SUBSTMT_PATH:\n        if (ext->parent_type == LYEXT_PAR_TYPE && ((struct lys_type*)ext->parent)->base == LY_TYPE_LEAFREF) {\n            return ((struct lys_type*)ext->parent)->info.lref.path;\n        }\n        break;\n    case LYEXT_SUBSTMT_POSITION:\n        if (ext->parent_type == LYEXT_PAR_TYPE_BIT) {\n            return &((struct lys_type_bit*)ext->parent)->pos;\n        }\n        break;\n    case LYEXT_SUBSTMT_PREFIX:\n        if (ext->parent_type == LYEXT_PAR_MODULE) {\n            /* covers also lys_submodule */\n            return ((struct lys_module*)ext->parent)->prefix;\n        } else if (ext->parent_type == LYEXT_PAR_IMPORT) {\n            return ((struct lys_import*)ext->parent)->prefix;\n        }\n        break;\n    case LYEXT_SUBSTMT_PRESENCE:\n        if (ext->parent_type == LYEXT_PAR_NODE && ((struct lys_node*)ext->parent)->nodetype == LYS_CONTAINER) {\n            return ((struct lys_node_container*)ext->parent)->presence;\n        } else if (ext->parent_type == LYEXT_PAR_REFINE) {\n            return ((struct lys_refine*)ext->parent)->mod.presence;\n        }\n        break;\n    case LYEXT_SUBSTMT_REFERENCE:\n        switch (ext->parent_type) {\n        case LYEXT_PAR_NODE:\n            return ((struct lys_node*)ext->parent)->ref;\n        case LYEXT_PAR_MODULE:\n            return ((struct lys_module*)ext->parent)->ref;\n        case LYEXT_PAR_IMPORT:\n            return ((struct lys_import*)ext->parent)->ref;\n        case LYEXT_PAR_INCLUDE:\n            return ((struct lys_include*)ext->parent)->ref;\n        case LYEXT_PAR_EXT:\n            return ((struct lys_ext*)ext->parent)->ref;\n        case LYEXT_PAR_FEATURE:\n            return ((struct lys_feature*)ext->parent)->ref;\n        case LYEXT_PAR_TPDF:\n            return ((struct lys_tpdf*)ext->parent)->ref;\n        case LYEXT_PAR_TYPE_BIT:\n            return ((struct lys_type_bit*)ext->parent)->ref;\n        case LYEXT_PAR_TYPE_ENUM:\n            return ((struct lys_type_enum*)ext->parent)->ref;\n        case LYEXT_PAR_RESTR:\n            return ((struct lys_restr*)ext->parent)->ref;\n        case LYEXT_PAR_WHEN:\n            return ((struct lys_when*)ext->parent)->ref;\n        case LYEXT_PAR_IDENT:\n            return ((struct lys_ident*)ext->parent)->ref;\n        case LYEXT_PAR_DEVIATION:\n            return ((struct lys_deviation*)ext->parent)->ref;\n        case LYEXT_PAR_REVISION:\n            return ((struct lys_revision*)ext->parent)->ref;\n        case LYEXT_PAR_REFINE:\n            return ((struct lys_refine*)ext->parent)->ref;\n        default:\n            break;\n        }\n        break;\n    case LYEXT_SUBSTMT_REQINSTANCE:\n        if (ext->parent_type == LYEXT_PAR_TYPE) {\n            if (((struct lys_type*)ext->parent)->base == LY_TYPE_LEAFREF) {\n                return &((struct lys_type*)ext->parent)->info.lref.req;\n            } else if (((struct lys_type*)ext->parent)->base == LY_TYPE_INST) {\n                return &((struct lys_type*)ext->parent)->info.inst.req;\n            }\n        }\n        break;\n    case LYEXT_SUBSTMT_REVISIONDATE:\n        if (ext->parent_type == LYEXT_PAR_IMPORT) {\n            return ((struct lys_import*)ext->parent)->rev;\n        } else if (ext->parent_type == LYEXT_PAR_INCLUDE) {\n            return ((struct lys_include*)ext->parent)->rev;\n        }\n        break;\n    case LYEXT_SUBSTMT_STATUS:\n        switch (ext->parent_type) {\n        case LYEXT_PAR_NODE:\n        case LYEXT_PAR_IDENT:\n        case LYEXT_PAR_TPDF:\n        case LYEXT_PAR_EXT:\n        case LYEXT_PAR_FEATURE:\n        case LYEXT_PAR_TYPE_ENUM:\n        case LYEXT_PAR_TYPE_BIT:\n            /* in all structures the flags member is at the same offset */\n            return &((struct lys_node*)ext->parent)->flags;\n        default:\n            break;\n        }\n        break;\n    case LYEXT_SUBSTMT_UNIQUE:\n        if (ext->parent_type == LYEXT_PAR_DEVIATE) {\n            return &((struct lys_deviate*)ext->parent)->unique[ext->insubstmt_index];\n        } else if (ext->parent_type == LYEXT_PAR_NODE && ((struct lys_node*)ext->parent)->nodetype == LYS_LIST) {\n            return &((struct lys_node_list*)ext->parent)->unique[ext->insubstmt_index];\n        }\n        break;\n    case LYEXT_SUBSTMT_UNITS:\n        if (ext->parent_type == LYEXT_PAR_NODE &&\n                (((struct lys_node*)ext->parent)->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n            /* units is at the same offset in both lys_node_leaf and lys_node_leaflist */\n            return ((struct lys_node_leaf*)ext->parent)->units;\n        } else if (ext->parent_type == LYEXT_PAR_TPDF) {\n            return ((struct lys_tpdf*)ext->parent)->units;\n        } else if (ext->parent_type == LYEXT_PAR_DEVIATE) {\n            return ((struct lys_deviate*)ext->parent)->units;\n        }\n        break;\n    case LYEXT_SUBSTMT_VALUE:\n        if (ext->parent_type == LYEXT_PAR_TYPE_ENUM) {\n            return &((struct lys_type_enum*)ext->parent)->value;\n        }\n        break;\n    case LYEXT_SUBSTMT_YINELEM:\n        if (ext->parent_type == LYEXT_PAR_EXT) {\n            return &((struct lys_ext*)ext->parent)->flags;\n        }\n        break;\n    }\n    LOGINT(ext->module->ctx);\n    return NULL;\n}\n\nstatic int\nlys_type_dup(struct lys_module *mod, struct lys_node *parent, struct lys_type *new, struct lys_type *old,\n            int in_grp, int shallow, struct unres_schema *unres)\n{\n    int i;\n\n    new->base = old->base;\n    new->der = old->der;\n    new->parent = (struct lys_tpdf *)parent;\n    new->ext_size = old->ext_size;\n    if (lys_ext_dup(mod->ctx, mod, old->ext, old->ext_size, new, LYEXT_PAR_TYPE, &new->ext, shallow, unres)) {\n        return -1;\n    }\n\n    i = unres_schema_find(unres, -1, old, UNRES_TYPE_DER);\n    if (i != -1) {\n        /* HACK (serious one) for unres */\n        /* nothing else we can do but duplicate it immediately */\n        if (((struct lyxml_elem *)old->der)->flags & LY_YANG_STRUCTURE_FLAG) {\n            new->der = (struct lys_tpdf *)lys_yang_type_dup(mod, parent, (struct yang_type *)old->der, new, in_grp,\n                                                            shallow, unres);\n        } else {\n            new->der = (struct lys_tpdf *)lyxml_dup_elem(mod->ctx, (struct lyxml_elem *)old->der, NULL, 1);\n        }\n        /* all these unres additions can fail even though they did not before */\n        if (!new->der || (unres_schema_add_node(mod, unres, new, UNRES_TYPE_DER, parent) == -1)) {\n            return -1;\n        }\n        return EXIT_SUCCESS;\n    }\n\n    return type_dup(mod, parent, new, old, new->base, in_grp, shallow, unres);\n}\n\nvoid\nlys_type_free(struct ly_ctx *ctx, struct lys_type *type,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    unsigned int i;\n\n    assert(ctx);\n    if (!type) {\n        return;\n    }\n\n    lys_extension_instances_free(ctx, type->ext, type->ext_size, private_destructor);\n\n    switch (type->base) {\n    case LY_TYPE_BINARY:\n        lys_restr_free(ctx, type->info.binary.length, private_destructor);\n        free(type->info.binary.length);\n        break;\n    case LY_TYPE_BITS:\n        for (i = 0; i < type->info.bits.count; i++) {\n            lydict_remove(ctx, type->info.bits.bit[i].name);\n            lydict_remove(ctx, type->info.bits.bit[i].dsc);\n            lydict_remove(ctx, type->info.bits.bit[i].ref);\n            lys_iffeature_free(ctx, type->info.bits.bit[i].iffeature, type->info.bits.bit[i].iffeature_size, 0,\n                               private_destructor);\n            lys_extension_instances_free(ctx, type->info.bits.bit[i].ext, type->info.bits.bit[i].ext_size,\n                                         private_destructor);\n        }\n        free(type->info.bits.bit);\n        break;\n\n    case LY_TYPE_DEC64:\n        lys_restr_free(ctx, type->info.dec64.range, private_destructor);\n        free(type->info.dec64.range);\n        break;\n\n    case LY_TYPE_ENUM:\n        for (i = 0; i < type->info.enums.count; i++) {\n            lydict_remove(ctx, type->info.enums.enm[i].name);\n            lydict_remove(ctx, type->info.enums.enm[i].dsc);\n            lydict_remove(ctx, type->info.enums.enm[i].ref);\n            lys_iffeature_free(ctx, type->info.enums.enm[i].iffeature, type->info.enums.enm[i].iffeature_size, 0,\n                               private_destructor);\n            lys_extension_instances_free(ctx, type->info.enums.enm[i].ext, type->info.enums.enm[i].ext_size,\n                                         private_destructor);\n        }\n        free(type->info.enums.enm);\n        break;\n\n    case LY_TYPE_INT8:\n    case LY_TYPE_INT16:\n    case LY_TYPE_INT32:\n    case LY_TYPE_INT64:\n    case LY_TYPE_UINT8:\n    case LY_TYPE_UINT16:\n    case LY_TYPE_UINT32:\n    case LY_TYPE_UINT64:\n        lys_restr_free(ctx, type->info.num.range, private_destructor);\n        free(type->info.num.range);\n        break;\n\n    case LY_TYPE_LEAFREF:\n        lydict_remove(ctx, type->info.lref.path);\n        break;\n\n    case LY_TYPE_STRING:\n        lys_restr_free(ctx, type->info.str.length, private_destructor);\n        free(type->info.str.length);\n        for (i = 0; i < type->info.str.pat_count; i++) {\n            lys_restr_free(ctx, &type->info.str.patterns[i], private_destructor);\n#ifdef LY_ENABLED_CACHE\n            if (type->info.str.patterns_pcre) {\n                pcre_free((pcre*)type->info.str.patterns_pcre[2 * i]);\n                pcre_free_study((pcre_extra*)type->info.str.patterns_pcre[2 * i + 1]);\n            }\n#endif\n        }\n        free(type->info.str.patterns);\n#ifdef LY_ENABLED_CACHE\n        free(type->info.str.patterns_pcre);\n#endif\n        break;\n\n    case LY_TYPE_UNION:\n        for (i = 0; i < type->info.uni.count; i++) {\n            lys_type_free(ctx, &type->info.uni.types[i], private_destructor);\n        }\n        free(type->info.uni.types);\n        break;\n\n    case LY_TYPE_IDENT:\n        free(type->info.ident.ref);\n        break;\n\n    default:\n        /* nothing to do for LY_TYPE_INST, LY_TYPE_BOOL, LY_TYPE_EMPTY */\n        break;\n    }\n}\n\nstatic void\nlys_tpdf_free(struct ly_ctx *ctx, struct lys_tpdf *tpdf,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    assert(ctx);\n    if (!tpdf) {\n        return;\n    }\n\n    lydict_remove(ctx, tpdf->name);\n    lydict_remove(ctx, tpdf->dsc);\n    lydict_remove(ctx, tpdf->ref);\n\n    lys_type_free(ctx, &tpdf->type, private_destructor);\n\n    lydict_remove(ctx, tpdf->units);\n    lydict_remove(ctx, tpdf->dflt);\n\n    lys_extension_instances_free(ctx, tpdf->ext, tpdf->ext_size, private_destructor);\n}\n\nstatic struct lys_when *\nlys_when_dup(struct lys_module *mod, struct lys_when *old, int shallow, struct unres_schema *unres)\n{\n    struct lys_when *new;\n\n    if (!old) {\n        return NULL;\n    }\n\n    new = calloc(1, sizeof *new);\n    LY_CHECK_ERR_RETURN(!new, LOGMEM(mod->ctx), NULL);\n    new->cond = lydict_insert(mod->ctx, old->cond, 0);\n    new->dsc = lydict_insert(mod->ctx, old->dsc, 0);\n    new->ref = lydict_insert(mod->ctx, old->ref, 0);\n    new->ext_size = old->ext_size;\n    lys_ext_dup(mod->ctx, mod, old->ext, old->ext_size, new, LYEXT_PAR_WHEN, &new->ext, shallow, unres);\n\n    return new;\n}\n\nvoid\nlys_when_free(struct ly_ctx *ctx, struct lys_when *w,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    if (!w) {\n        return;\n    }\n\n    lys_extension_instances_free(ctx, w->ext, w->ext_size, private_destructor);\n    lydict_remove(ctx, w->cond);\n    lydict_remove(ctx, w->dsc);\n    lydict_remove(ctx, w->ref);\n\n    free(w);\n}\n\nstatic void\nlys_augment_free(struct ly_ctx *ctx, struct lys_node_augment *aug,\n                 void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    struct lys_node *next, *sub;\n\n    /* children from a resolved augment are freed under the target node */\n    if (!aug->target || (aug->flags & LYS_NOTAPPLIED)) {\n        LY_TREE_FOR_SAFE(aug->child, next, sub) {\n            lys_node_free(sub, private_destructor, 0);\n        }\n    }\n\n    lydict_remove(ctx, aug->target_name);\n    lydict_remove(ctx, aug->dsc);\n    lydict_remove(ctx, aug->ref);\n\n    lys_iffeature_free(ctx, aug->iffeature, aug->iffeature_size, 0, private_destructor);\n    lys_extension_instances_free(ctx, aug->ext, aug->ext_size, private_destructor);\n\n    lys_when_free(ctx, aug->when, private_destructor);\n}\n\nstatic void\nlys_ident_free(struct ly_ctx *ctx, struct lys_ident *ident,\n               void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    assert(ctx);\n    if (!ident) {\n        return;\n    }\n\n    free(ident->base);\n    ly_set_free(ident->der);\n    lydict_remove(ctx, ident->name);\n    lydict_remove(ctx, ident->dsc);\n    lydict_remove(ctx, ident->ref);\n    lys_iffeature_free(ctx, ident->iffeature, ident->iffeature_size, 0, private_destructor);\n    lys_extension_instances_free(ctx, ident->ext, ident->ext_size, private_destructor);\n\n}\n\nstatic void\nlys_grp_free(struct ly_ctx *ctx, struct lys_node_grp *grp,\n             void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    /* handle only specific parts for LYS_GROUPING */\n    for (i = 0; i < grp->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &grp->tpdf[i], private_destructor);\n    }\n    free(grp->tpdf);\n}\n\nstatic void\nlys_rpc_action_free(struct ly_ctx *ctx, struct lys_node_rpc_action *rpc_act,\n             void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    /* handle only specific parts for LYS_GROUPING */\n    for (i = 0; i < rpc_act->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &rpc_act->tpdf[i], private_destructor);\n    }\n    free(rpc_act->tpdf);\n}\n\nstatic void\nlys_inout_free(struct ly_ctx *ctx, struct lys_node_inout *io,\n               void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    /* handle only specific parts for LYS_INPUT and LYS_OUTPUT */\n    for (i = 0; i < io->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &io->tpdf[i], private_destructor);\n    }\n    free(io->tpdf);\n\n    for (i = 0; i < io->must_size; i++) {\n        lys_restr_free(ctx, &io->must[i], private_destructor);\n    }\n    free(io->must);\n}\n\nstatic void\nlys_notif_free(struct ly_ctx *ctx, struct lys_node_notif *notif,\n               void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    for (i = 0; i < notif->must_size; i++) {\n        lys_restr_free(ctx, &notif->must[i], private_destructor);\n    }\n    free(notif->must);\n\n    for (i = 0; i < notif->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &notif->tpdf[i], private_destructor);\n    }\n    free(notif->tpdf);\n}\nstatic void\nlys_anydata_free(struct ly_ctx *ctx, struct lys_node_anydata *anyxml,\n                 void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    for (i = 0; i < anyxml->must_size; i++) {\n        lys_restr_free(ctx, &anyxml->must[i], private_destructor);\n    }\n    free(anyxml->must);\n\n    lys_when_free(ctx, anyxml->when, private_destructor);\n}\n\nstatic void\nlys_leaf_free(struct ly_ctx *ctx, struct lys_node_leaf *leaf,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    /* leafref backlinks */\n    ly_set_free((struct ly_set *)leaf->backlinks);\n\n    for (i = 0; i < leaf->must_size; i++) {\n        lys_restr_free(ctx, &leaf->must[i], private_destructor);\n    }\n    free(leaf->must);\n\n    lys_when_free(ctx, leaf->when, private_destructor);\n\n    lys_type_free(ctx, &leaf->type, private_destructor);\n    lydict_remove(ctx, leaf->units);\n    lydict_remove(ctx, leaf->dflt);\n}\n\nstatic void\nlys_leaflist_free(struct ly_ctx *ctx, struct lys_node_leaflist *llist,\n                  void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    if (llist->backlinks) {\n        /* leafref backlinks */\n        ly_set_free(llist->backlinks);\n    }\n\n    for (i = 0; i < llist->must_size; i++) {\n        lys_restr_free(ctx, &llist->must[i], private_destructor);\n    }\n    free(llist->must);\n\n    for (i = 0; i < llist->dflt_size; i++) {\n        lydict_remove(ctx, llist->dflt[i]);\n    }\n    free(llist->dflt);\n\n    lys_when_free(ctx, llist->when, private_destructor);\n\n    lys_type_free(ctx, &llist->type, private_destructor);\n    lydict_remove(ctx, llist->units);\n}\n\nstatic void\nlys_list_free(struct ly_ctx *ctx, struct lys_node_list *list,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i, j;\n\n    /* handle only specific parts for LY_NODE_LIST */\n    lys_when_free(ctx, list->when, private_destructor);\n\n    for (i = 0; i < list->must_size; i++) {\n        lys_restr_free(ctx, &list->must[i], private_destructor);\n    }\n    free(list->must);\n\n    for (i = 0; i < list->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &list->tpdf[i], private_destructor);\n    }\n    free(list->tpdf);\n\n    free(list->keys);\n\n    for (i = 0; i < list->unique_size; i++) {\n        for (j = 0; j < list->unique[i].expr_size; j++) {\n            lydict_remove(ctx, list->unique[i].expr[j]);\n        }\n        free(list->unique[i].expr);\n    }\n    free(list->unique);\n\n    lydict_remove(ctx, list->keys_str);\n}\n\nstatic void\nlys_container_free(struct ly_ctx *ctx, struct lys_node_container *cont,\n                   void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    /* handle only specific parts for LY_NODE_CONTAINER */\n    lydict_remove(ctx, cont->presence);\n\n    for (i = 0; i < cont->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &cont->tpdf[i], private_destructor);\n    }\n    free(cont->tpdf);\n\n    for (i = 0; i < cont->must_size; i++) {\n        lys_restr_free(ctx, &cont->must[i], private_destructor);\n    }\n    free(cont->must);\n\n    lys_when_free(ctx, cont->when, private_destructor);\n}\n\nstatic void\nlys_feature_free(struct ly_ctx *ctx, struct lys_feature *f,\n                 void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    lydict_remove(ctx, f->name);\n    lydict_remove(ctx, f->dsc);\n    lydict_remove(ctx, f->ref);\n    lys_iffeature_free(ctx, f->iffeature, f->iffeature_size, 0, private_destructor);\n    ly_set_free(f->depfeatures);\n    lys_extension_instances_free(ctx, f->ext, f->ext_size, private_destructor);\n}\n\nstatic void\nlys_extension_free(struct ly_ctx *ctx, struct lys_ext *e,\n                   void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    lydict_remove(ctx, e->name);\n    lydict_remove(ctx, e->dsc);\n    lydict_remove(ctx, e->ref);\n    lydict_remove(ctx, e->argument);\n    lys_extension_instances_free(ctx, e->ext, e->ext_size, private_destructor);\n}\n\nstatic void\nlys_deviation_free(struct lys_module *module, struct lys_deviation *dev,\n                   void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i, j, k;\n    struct ly_ctx *ctx;\n    struct lys_node *next, *elem;\n\n    ctx = module->ctx;\n\n    lydict_remove(ctx, dev->target_name);\n    lydict_remove(ctx, dev->dsc);\n    lydict_remove(ctx, dev->ref);\n    lys_extension_instances_free(ctx, dev->ext, dev->ext_size, private_destructor);\n\n    if (!dev->deviate) {\n        return;\n    }\n\n    /* it could not be applied because it failed to be applied */\n    if (dev->orig_node) {\n        /* the module was freed, but we only need the context from orig_node, use ours */\n        if (dev->deviate[0].mod == LY_DEVIATE_NO) {\n            /* it's actually a node subtree, we need to update modules on all the nodes :-/ */\n            LY_TREE_DFS_BEGIN(dev->orig_node, next, elem) {\n                elem->module = module;\n\n                LY_TREE_DFS_END(dev->orig_node, next, elem);\n            }\n            lys_node_free(dev->orig_node, NULL, 0);\n        } else {\n            /* it's just a shallow copy, freeing one node */\n            dev->orig_node->module = module;\n            lys_node_free(dev->orig_node, NULL, 1);\n        }\n    }\n\n    for (i = 0; i < dev->deviate_size; i++) {\n        lys_extension_instances_free(ctx, dev->deviate[i].ext, dev->deviate[i].ext_size, private_destructor);\n\n        for (j = 0; j < dev->deviate[i].dflt_size; j++) {\n            lydict_remove(ctx, dev->deviate[i].dflt[j]);\n        }\n        free(dev->deviate[i].dflt);\n\n        lydict_remove(ctx, dev->deviate[i].units);\n\n        if (dev->deviate[i].mod == LY_DEVIATE_DEL) {\n            for (j = 0; j < dev->deviate[i].must_size; j++) {\n                lys_restr_free(ctx, &dev->deviate[i].must[j], private_destructor);\n            }\n            free(dev->deviate[i].must);\n\n            for (j = 0; j < dev->deviate[i].unique_size; j++) {\n                for (k = 0; k < dev->deviate[i].unique[j].expr_size; k++) {\n                    lydict_remove(ctx, dev->deviate[i].unique[j].expr[k]);\n                }\n                free(dev->deviate[i].unique[j].expr);\n            }\n            free(dev->deviate[i].unique);\n        }\n    }\n    free(dev->deviate);\n}\n\nstatic void\nlys_uses_free(struct ly_ctx *ctx, struct lys_node_uses *uses,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i, j;\n\n    for (i = 0; i < uses->refine_size; i++) {\n        lydict_remove(ctx, uses->refine[i].target_name);\n        lydict_remove(ctx, uses->refine[i].dsc);\n        lydict_remove(ctx, uses->refine[i].ref);\n\n        lys_iffeature_free(ctx, uses->refine[i].iffeature, uses->refine[i].iffeature_size, 0, private_destructor);\n\n        for (j = 0; j < uses->refine[i].must_size; j++) {\n            lys_restr_free(ctx, &uses->refine[i].must[j], private_destructor);\n        }\n        free(uses->refine[i].must);\n\n        for (j = 0; j < uses->refine[i].dflt_size; j++) {\n            lydict_remove(ctx, uses->refine[i].dflt[j]);\n        }\n        free(uses->refine[i].dflt);\n\n        lys_extension_instances_free(ctx, uses->refine[i].ext, uses->refine[i].ext_size, private_destructor);\n\n        if (uses->refine[i].target_type & LYS_CONTAINER) {\n            lydict_remove(ctx, uses->refine[i].mod.presence);\n        }\n    }\n    free(uses->refine);\n\n    for (i = 0; i < uses->augment_size; i++) {\n        lys_augment_free(ctx, &uses->augment[i], private_destructor);\n    }\n    free(uses->augment);\n\n    lys_when_free(ctx, uses->when, private_destructor);\n}\n\nvoid\nlys_node_free(struct lys_node *node, void (*private_destructor)(const struct lys_node *node, void *priv), int shallow)\n{\n    struct ly_ctx *ctx;\n    struct lys_node *sub, *next;\n\n    if (!node) {\n        return;\n    }\n\n    assert(node->module);\n    assert(node->module->ctx);\n\n    ctx = node->module->ctx;\n\n    /* remove private object */\n    if (node->priv && private_destructor) {\n        private_destructor(node, node->priv);\n    }\n\n    /* common part */\n    lydict_remove(ctx, node->name);\n    if (!(node->nodetype & (LYS_INPUT | LYS_OUTPUT))) {\n        lys_iffeature_free(ctx, node->iffeature, node->iffeature_size, shallow, private_destructor);\n        lydict_remove(ctx, node->dsc);\n        lydict_remove(ctx, node->ref);\n    }\n\n    if (!shallow && !(node->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n        LY_TREE_FOR_SAFE(node->child, next, sub) {\n            lys_node_free(sub, private_destructor, 0);\n        }\n    }\n\n    lys_extension_instances_free(ctx, node->ext, node->ext_size, private_destructor);\n\n    /* specific part */\n    switch (node->nodetype) {\n    case LYS_CONTAINER:\n        lys_container_free(ctx, (struct lys_node_container *)node, private_destructor);\n        break;\n    case LYS_CHOICE:\n        lys_when_free(ctx, ((struct lys_node_choice *)node)->when, private_destructor);\n        break;\n    case LYS_LEAF:\n        lys_leaf_free(ctx, (struct lys_node_leaf *)node, private_destructor);\n        break;\n    case LYS_LEAFLIST:\n        lys_leaflist_free(ctx, (struct lys_node_leaflist *)node, private_destructor);\n        break;\n    case LYS_LIST:\n        lys_list_free(ctx, (struct lys_node_list *)node, private_destructor);\n        break;\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        lys_anydata_free(ctx, (struct lys_node_anydata *)node, private_destructor);\n        break;\n    case LYS_USES:\n        lys_uses_free(ctx, (struct lys_node_uses *)node, private_destructor);\n        break;\n    case LYS_CASE:\n        lys_when_free(ctx, ((struct lys_node_case *)node)->when, private_destructor);\n        break;\n    case LYS_AUGMENT:\n        /* do nothing */\n        break;\n    case LYS_GROUPING:\n        lys_grp_free(ctx, (struct lys_node_grp *)node, private_destructor);\n        break;\n    case LYS_RPC:\n    case LYS_ACTION:\n        lys_rpc_action_free(ctx, (struct lys_node_rpc_action *)node, private_destructor);\n        break;\n    case LYS_NOTIF:\n        lys_notif_free(ctx, (struct lys_node_notif *)node, private_destructor);\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        lys_inout_free(ctx, (struct lys_node_inout *)node, private_destructor);\n        break;\n    case LYS_EXT:\n    case LYS_UNKNOWN:\n        LOGINT(ctx);\n        break;\n    }\n\n    /* again common part */\n    lys_node_unlink(node);\n    free(node);\n}\n\nAPI struct lys_module *\nlys_implemented_module(const struct lys_module *mod)\n{\n    struct ly_ctx *ctx;\n    int i;\n\n    if (!mod || mod->implemented) {\n        /* invalid argument or the module itself is implemented */\n        return (struct lys_module *)mod;\n    }\n\n    ctx = mod->ctx;\n    for (i = 0; i < ctx->models.used; i++) {\n        if (!ctx->models.list[i]->implemented) {\n            continue;\n        }\n\n        if (ly_strequal(mod->name, ctx->models.list[i]->name, 1)) {\n            /* we have some revision of the module implemented */\n            return ctx->models.list[i];\n        }\n    }\n\n    /* we have no revision of the module implemented, return the module itself,\n     * it is up to the caller to set the module implemented when needed */\n    return (struct lys_module *)mod;\n}\n\n/* free_int_mods - flag whether to free the internal modules as well */\nstatic void\nmodule_free_common(struct lys_module *module, void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    struct ly_ctx *ctx;\n    struct lys_node *next, *iter;\n    unsigned int i;\n\n    assert(module->ctx);\n    ctx = module->ctx;\n\n    /* just free the import array, imported modules will stay in the context */\n    for (i = 0; i < module->imp_size; i++) {\n        lydict_remove(ctx, module->imp[i].prefix);\n        lydict_remove(ctx, module->imp[i].dsc);\n        lydict_remove(ctx, module->imp[i].ref);\n        lys_extension_instances_free(ctx, module->imp[i].ext, module->imp[i].ext_size, private_destructor);\n    }\n    free(module->imp);\n\n    /* submodules don't have data tree, the data nodes\n     * are placed in the main module altogether */\n    if (!module->type) {\n        LY_TREE_FOR_SAFE(module->data, next, iter) {\n            lys_node_free(iter, private_destructor, 0);\n        }\n    }\n\n    lydict_remove(ctx, module->dsc);\n    lydict_remove(ctx, module->ref);\n    lydict_remove(ctx, module->org);\n    lydict_remove(ctx, module->contact);\n    lydict_remove(ctx, module->filepath);\n\n    /* revisions */\n    for (i = 0; i < module->rev_size; i++) {\n        lys_extension_instances_free(ctx, module->rev[i].ext, module->rev[i].ext_size, private_destructor);\n        lydict_remove(ctx, module->rev[i].dsc);\n        lydict_remove(ctx, module->rev[i].ref);\n    }\n    free(module->rev);\n\n    /* identities */\n    for (i = 0; i < module->ident_size; i++) {\n        lys_ident_free(ctx, &module->ident[i], private_destructor);\n    }\n    module->ident_size = 0;\n    free(module->ident);\n\n    /* typedefs */\n    for (i = 0; i < module->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &module->tpdf[i], private_destructor);\n    }\n    free(module->tpdf);\n\n    /* extension instances */\n    lys_extension_instances_free(ctx, module->ext, module->ext_size, private_destructor);\n\n    /* augment */\n    for (i = 0; i < module->augment_size; i++) {\n        lys_augment_free(ctx, &module->augment[i], private_destructor);\n    }\n    free(module->augment);\n\n    /* features */\n    for (i = 0; i < module->features_size; i++) {\n        lys_feature_free(ctx, &module->features[i], private_destructor);\n    }\n    free(module->features);\n\n    /* deviations */\n    for (i = 0; i < module->deviation_size; i++) {\n        lys_deviation_free(module, &module->deviation[i], private_destructor);\n    }\n    free(module->deviation);\n\n    /* extensions */\n    for (i = 0; i < module->extensions_size; i++) {\n        lys_extension_free(ctx, &module->extensions[i], private_destructor);\n    }\n    free(module->extensions);\n\n    lydict_remove(ctx, module->name);\n    lydict_remove(ctx, module->prefix);\n}\n\nvoid\nlys_submodule_free(struct lys_submodule *submodule, void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    if (!submodule) {\n        return;\n    }\n\n    /* common part with struct ly_module */\n    module_free_common((struct lys_module *)submodule, private_destructor);\n\n    /* include */\n    for (i = 0; i < submodule->inc_size; i++) {\n        lydict_remove(submodule->ctx, submodule->inc[i].dsc);\n        lydict_remove(submodule->ctx, submodule->inc[i].ref);\n        lys_extension_instances_free(submodule->ctx, submodule->inc[i].ext, submodule->inc[i].ext_size, private_destructor);\n        /* complete submodule free is done only from main module since\n         * submodules propagate their includes to the main module */\n    }\n    free(submodule->inc);\n\n    free(submodule);\n}\n\nint\nlys_ingrouping(const struct lys_node *node)\n{\n    const struct lys_node *iter = node;\n    assert(node);\n\n    for(iter = node; iter && iter->nodetype != LYS_GROUPING; iter = lys_parent(iter));\n    if (!iter) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n\n/*\n * final: 0 - do not change config flags; 1 - inherit config flags from the parent; 2 - remove config flags\n */\nstatic struct lys_node *\nlys_node_dup_recursion(struct lys_module *module, struct lys_node *parent, const struct lys_node *node,\n                       struct unres_schema *unres, int shallow, int finalize)\n{\n    struct lys_node *retval = NULL, *iter, *p;\n    struct ly_ctx *ctx = module->ctx;\n    int i, j, rc;\n    unsigned int size, size1, size2;\n    struct unres_list_uniq *unique_info;\n    uint16_t flags;\n\n    struct lys_node_container *cont = NULL;\n    struct lys_node_container *cont_orig = (struct lys_node_container *)node;\n    struct lys_node_choice *choice = NULL;\n    struct lys_node_choice *choice_orig = (struct lys_node_choice *)node;\n    struct lys_node_leaf *leaf = NULL;\n    struct lys_node_leaf *leaf_orig = (struct lys_node_leaf *)node;\n    struct lys_node_leaflist *llist = NULL;\n    struct lys_node_leaflist *llist_orig = (struct lys_node_leaflist *)node;\n    struct lys_node_list *list = NULL;\n    struct lys_node_list *list_orig = (struct lys_node_list *)node;\n    struct lys_node_anydata *any = NULL;\n    struct lys_node_anydata *any_orig = (struct lys_node_anydata *)node;\n    struct lys_node_uses *uses = NULL;\n    struct lys_node_uses *uses_orig = (struct lys_node_uses *)node;\n    struct lys_node_rpc_action *rpc = NULL;\n    struct lys_node_inout *io = NULL;\n    struct lys_node_notif *ntf = NULL;\n    struct lys_node_case *cs = NULL;\n    struct lys_node_case *cs_orig = (struct lys_node_case *)node;\n\n    /* we cannot just duplicate memory since the strings are stored in\n     * dictionary and we need to update dictionary counters.\n     */\n\n    switch (node->nodetype) {\n    case LYS_CONTAINER:\n        cont = calloc(1, sizeof *cont);\n        retval = (struct lys_node *)cont;\n        break;\n\n    case LYS_CHOICE:\n        choice = calloc(1, sizeof *choice);\n        retval = (struct lys_node *)choice;\n        break;\n\n    case LYS_LEAF:\n        leaf = calloc(1, sizeof *leaf);\n        retval = (struct lys_node *)leaf;\n        break;\n\n    case LYS_LEAFLIST:\n        llist = calloc(1, sizeof *llist);\n        retval = (struct lys_node *)llist;\n        break;\n\n    case LYS_LIST:\n        list = calloc(1, sizeof *list);\n        retval = (struct lys_node *)list;\n        break;\n\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        any = calloc(1, sizeof *any);\n        retval = (struct lys_node *)any;\n        break;\n\n    case LYS_USES:\n        uses = calloc(1, sizeof *uses);\n        retval = (struct lys_node *)uses;\n        break;\n\n    case LYS_CASE:\n        cs = calloc(1, sizeof *cs);\n        retval = (struct lys_node *)cs;\n        break;\n\n    case LYS_RPC:\n    case LYS_ACTION:\n        rpc = calloc(1, sizeof *rpc);\n        retval = (struct lys_node *)rpc;\n        break;\n\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        io = calloc(1, sizeof *io);\n        retval = (struct lys_node *)io;\n        break;\n\n    case LYS_NOTIF:\n        ntf = calloc(1, sizeof *ntf);\n        retval = (struct lys_node *)ntf;\n        break;\n\n    default:\n        LOGINT(ctx);\n        goto error;\n    }\n    LY_CHECK_ERR_RETURN(!retval, LOGMEM(ctx), NULL);\n\n    /*\n     * duplicate generic part of the structure\n     */\n    retval->name = lydict_insert(ctx, node->name, 0);\n    retval->dsc = lydict_insert(ctx, node->dsc, 0);\n    retval->ref = lydict_insert(ctx, node->ref, 0);\n    retval->flags = node->flags;\n\n    retval->module = module;\n    retval->nodetype = node->nodetype;\n\n    retval->prev = retval;\n\n    retval->ext_size = node->ext_size;\n    if (lys_ext_dup(ctx, module, node->ext, node->ext_size, retval, LYEXT_PAR_NODE, &retval->ext, shallow, unres)) {\n        goto error;\n    }\n\n    if (node->iffeature_size) {\n        retval->iffeature_size = node->iffeature_size;\n        retval->iffeature = calloc(retval->iffeature_size, sizeof *retval->iffeature);\n        LY_CHECK_ERR_GOTO(!retval->iffeature, LOGMEM(ctx), error);\n    }\n\n    if (!shallow) {\n        for (i = 0; i < node->iffeature_size; ++i) {\n            resolve_iffeature_getsizes(&node->iffeature[i], &size1, &size2);\n            if (size1) {\n                /* there is something to duplicate */\n\n                /* duplicate compiled expression */\n                size = (size1 / 4) + (size1 % 4) ? 1 : 0;\n                retval->iffeature[i].expr = malloc(size * sizeof *retval->iffeature[i].expr);\n                LY_CHECK_ERR_GOTO(!retval->iffeature[i].expr, LOGMEM(ctx), error);\n                memcpy(retval->iffeature[i].expr, node->iffeature[i].expr, size * sizeof *retval->iffeature[i].expr);\n\n                /* list of feature pointer must be updated to point to the resulting tree */\n                retval->iffeature[i].features = calloc(size2, sizeof *retval->iffeature[i].features);\n                LY_CHECK_ERR_GOTO(!retval->iffeature[i].features, LOGMEM(ctx); free(retval->iffeature[i].expr), error);\n\n                for (j = 0; (unsigned int)j < size2; j++) {\n                    rc = unres_schema_dup(module, unres, &node->iffeature[i].features[j], UNRES_IFFEAT,\n                                          &retval->iffeature[i].features[j]);\n                    if (rc == EXIT_FAILURE) {\n                        /* feature is resolved in origin, so copy it\n                         * - duplication is used for instantiating groupings\n                         * and if-feature inside grouping is supposed to be\n                         * resolved inside the original grouping, so we want\n                         * to keep pointers to features from the grouping\n                         * context */\n                        retval->iffeature[i].features[j] = node->iffeature[i].features[j];\n                    } else if (rc == -1) {\n                        goto error;\n                    } /* else unres was duplicated */\n                }\n            }\n\n            /* duplicate if-feature's extensions */\n            retval->iffeature[i].ext_size = node->iffeature[i].ext_size;\n            if (lys_ext_dup(ctx, module, node->iffeature[i].ext, node->iffeature[i].ext_size,\n                            &retval->iffeature[i], LYEXT_PAR_IFFEATURE, &retval->iffeature[i].ext, shallow, unres)) {\n                goto error;\n            }\n        }\n\n        /* inherit config flags */\n        p = parent;\n        do {\n            for (iter = p; iter && (iter->nodetype == LYS_USES); iter = iter->parent);\n        } while (iter && iter->nodetype == LYS_AUGMENT && (p = lys_parent(iter)));\n        if (iter) {\n            flags = iter->flags & LYS_CONFIG_MASK;\n        } else {\n            /* default */\n            flags = LYS_CONFIG_W;\n        }\n\n        switch (finalize) {\n        case 1:\n            /* inherit config flags */\n            if (retval->flags & LYS_CONFIG_SET) {\n                /* skip nodes with an explicit config value */\n                if ((flags & LYS_CONFIG_R) && (retval->flags & LYS_CONFIG_W)) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, \"true\", \"config\");\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"State nodes cannot have configuration nodes as children.\");\n                    goto error;\n                }\n                break;\n            }\n\n            if (retval->nodetype != LYS_USES) {\n                retval->flags = (retval->flags & ~LYS_CONFIG_MASK) | flags;\n            }\n\n            /* inherit status */\n            if ((parent->flags & LYS_STATUS_MASK) > (retval->flags & LYS_STATUS_MASK)) {\n                /* but do it only in case the parent has a stonger status */\n                retval->flags &= ~LYS_STATUS_MASK;\n                retval->flags |= (parent->flags & LYS_STATUS_MASK);\n            }\n            break;\n        case 2:\n            /* erase config flags */\n            retval->flags &= ~LYS_CONFIG_MASK;\n            retval->flags &= ~LYS_CONFIG_SET;\n            break;\n        }\n\n        /* connect it to the parent */\n        if (lys_node_addchild(parent, retval->module, retval, 0)) {\n            goto error;\n        }\n\n        /* go recursively */\n        if (!(node->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n            LY_TREE_FOR(node->child, iter) {\n                if (iter->nodetype & LYS_GROUPING) {\n                    /* do not instantiate groupings */\n                    continue;\n                }\n                if (!lys_node_dup_recursion(module, retval, iter, unres, 0, finalize)) {\n                    goto error;\n                }\n            }\n        }\n\n        if (finalize == 1) {\n            /* check that configuration lists have keys\n             * - we really want to check keys_size in original node, because the keys are\n             * not yet resolved here, it is done below in nodetype specific part */\n            if ((retval->nodetype == LYS_LIST) && (retval->flags & LYS_CONFIG_W)\n                    && !((struct lys_node_list *)node)->keys_size) {\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, retval, \"key\", \"list\");\n                goto error;\n            }\n        }\n    } else {\n        memcpy(retval->iffeature, node->iffeature, retval->iffeature_size * sizeof *retval->iffeature);\n    }\n\n    /*\n     * duplicate specific part of the structure\n     */\n    switch (node->nodetype) {\n    case LYS_CONTAINER:\n        if (cont_orig->when) {\n            cont->when = lys_when_dup(module, cont_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!cont->when, error);\n        }\n        cont->presence = lydict_insert(ctx, cont_orig->presence, 0);\n\n        if (cont_orig->must) {\n            cont->must = lys_restr_dup(module, cont_orig->must, cont_orig->must_size, shallow, unres);\n            LY_CHECK_GOTO(!cont->must, error);\n            cont->must_size = cont_orig->must_size;\n        }\n\n        /* typedefs are not needed in instantiated grouping, nor the deviation's shallow copy */\n\n        break;\n    case LYS_CHOICE:\n        if (choice_orig->when) {\n            choice->when = lys_when_dup(module, choice_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!choice->when, error);\n        }\n\n        if (!shallow) {\n            if (choice_orig->dflt) {\n                rc = lys_get_sibling(choice->child, lys_node_module(retval)->name, 0, choice_orig->dflt->name, 0,\n                                            LYS_ANYDATA | LYS_CASE | LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST,\n                                            (const struct lys_node **)&choice->dflt);\n                if (rc) {\n                    if (rc == EXIT_FAILURE) {\n                        LOGINT(ctx);\n                    }\n                    goto error;\n                }\n            } else {\n                /* useless to check return value, we don't know whether\n                * there really wasn't any default defined or it just hasn't\n                * been resolved, we just hope for the best :)\n                */\n                unres_schema_dup(module, unres, choice_orig, UNRES_CHOICE_DFLT, choice);\n            }\n        } else {\n            choice->dflt = choice_orig->dflt;\n        }\n        break;\n\n    case LYS_LEAF:\n        if (lys_type_dup(module, retval, &(leaf->type), &(leaf_orig->type), lys_ingrouping(retval), shallow, unres)) {\n            goto error;\n        }\n        leaf->units = lydict_insert(module->ctx, leaf_orig->units, 0);\n\n        if (leaf_orig->dflt) {\n            leaf->dflt = lydict_insert(ctx, leaf_orig->dflt, 0);\n        }\n\n        if (leaf_orig->must) {\n            leaf->must = lys_restr_dup(module, leaf_orig->must, leaf_orig->must_size, shallow, unres);\n            LY_CHECK_GOTO(!leaf->must, error);\n            leaf->must_size = leaf_orig->must_size;\n        }\n\n        if (leaf_orig->when) {\n            leaf->when = lys_when_dup(module, leaf_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!leaf->when, error);\n        }\n        break;\n\n    case LYS_LEAFLIST:\n        if (lys_type_dup(module, retval, &(llist->type), &(llist_orig->type), lys_ingrouping(retval), shallow, unres)) {\n            goto error;\n        }\n        llist->units = lydict_insert(module->ctx, llist_orig->units, 0);\n\n        llist->min = llist_orig->min;\n        llist->max = llist_orig->max;\n\n        if (llist_orig->must) {\n            llist->must = lys_restr_dup(module, llist_orig->must, llist_orig->must_size, shallow, unres);\n            LY_CHECK_GOTO(!llist->must, error);\n            llist->must_size = llist_orig->must_size;\n        }\n\n        if (llist_orig->dflt) {\n            llist->dflt = malloc(llist_orig->dflt_size * sizeof *llist->dflt);\n            LY_CHECK_ERR_GOTO(!llist->dflt, LOGMEM(ctx), error);\n            llist->dflt_size = llist_orig->dflt_size;\n\n            for (i = 0; i < llist->dflt_size; i++) {\n                llist->dflt[i] = lydict_insert(ctx, llist_orig->dflt[i], 0);\n            }\n        }\n\n        if (llist_orig->when) {\n            llist->when = lys_when_dup(module, llist_orig->when, shallow, unres);\n        }\n        break;\n\n    case LYS_LIST:\n        list->min = list_orig->min;\n        list->max = list_orig->max;\n\n        if (list_orig->must) {\n            list->must = lys_restr_dup(module, list_orig->must, list_orig->must_size, shallow, unres);\n            LY_CHECK_GOTO(!list->must, error);\n            list->must_size = list_orig->must_size;\n        }\n\n        /* typedefs are not needed in instantiated grouping, nor the deviation's shallow copy */\n\n        if (list_orig->keys_size) {\n            list->keys = calloc(list_orig->keys_size, sizeof *list->keys);\n            LY_CHECK_ERR_GOTO(!list->keys, LOGMEM(ctx), error);\n            list->keys_str = lydict_insert(ctx, list_orig->keys_str, 0);\n            list->keys_size = list_orig->keys_size;\n\n            if (!shallow) {\n                if (unres_schema_add_node(module, unres, list, UNRES_LIST_KEYS, NULL) == -1) {\n                    goto error;\n                }\n            } else {\n                memcpy(list->keys, list_orig->keys, list_orig->keys_size * sizeof *list->keys);\n            }\n        }\n\n        if (list_orig->unique) {\n            list->unique = malloc(list_orig->unique_size * sizeof *list->unique);\n            LY_CHECK_ERR_GOTO(!list->unique, LOGMEM(ctx), error);\n            list->unique_size = list_orig->unique_size;\n\n            for (i = 0; i < list->unique_size; ++i) {\n                list->unique[i].expr = malloc(list_orig->unique[i].expr_size * sizeof *list->unique[i].expr);\n                LY_CHECK_ERR_GOTO(!list->unique[i].expr, LOGMEM(ctx), error);\n                list->unique[i].expr_size = list_orig->unique[i].expr_size;\n                for (j = 0; j < list->unique[i].expr_size; j++) {\n                    list->unique[i].expr[j] = lydict_insert(ctx, list_orig->unique[i].expr[j], 0);\n\n                    /* if it stays in unres list, duplicate it also there */\n                    unique_info = malloc(sizeof *unique_info);\n                    LY_CHECK_ERR_GOTO(!unique_info, LOGMEM(ctx), error);\n                    unique_info->list = (struct lys_node *)list;\n                    unique_info->expr = list->unique[i].expr[j];\n                    unique_info->trg_type = &list->unique[i].trg_type;\n                    unres_schema_dup(module, unres, &list_orig, UNRES_LIST_UNIQ, unique_info);\n                }\n            }\n        }\n\n        if (list_orig->when) {\n            list->when = lys_when_dup(module, list_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!list->when, error);\n        }\n        break;\n\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        if (any_orig->must) {\n            any->must = lys_restr_dup(module, any_orig->must, any_orig->must_size, shallow, unres);\n            LY_CHECK_GOTO(!any->must, error);\n            any->must_size = any_orig->must_size;\n        }\n\n        if (any_orig->when) {\n            any->when = lys_when_dup(module, any_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!any->when, error);\n        }\n        break;\n\n    case LYS_USES:\n        uses->grp = uses_orig->grp;\n\n        if (uses_orig->when) {\n            uses->when = lys_when_dup(module, uses_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!uses->when, error);\n        }\n        /* it is not needed to duplicate refine, nor augment. They are already applied to the uses children */\n        break;\n\n    case LYS_CASE:\n        if (cs_orig->when) {\n            cs->when = lys_when_dup(module, cs_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!cs->when, error);\n        }\n        break;\n\n    case LYS_ACTION:\n    case LYS_RPC:\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n    case LYS_NOTIF:\n        /* typedefs are not needed in instantiated grouping, nor the deviation's shallow copy */\n        break;\n\n    default:\n        /* LY_NODE_AUGMENT */\n        LOGINT(ctx);\n        goto error;\n    }\n\n    return retval;\n\nerror:\n    lys_node_free(retval, NULL, 0);\n    return NULL;\n}\n\nint\nlys_has_xpath(const struct lys_node *node)\n{\n    assert(node);\n\n    switch (node->nodetype) {\n    case LYS_AUGMENT:\n        if (((struct lys_node_augment *)node)->when) {\n            return 1;\n        }\n        break;\n    case LYS_CASE:\n        if (((struct lys_node_case *)node)->when) {\n            return 1;\n        }\n        break;\n    case LYS_CHOICE:\n        if (((struct lys_node_choice *)node)->when) {\n            return 1;\n        }\n        break;\n    case LYS_ANYDATA:\n        if (((struct lys_node_anydata *)node)->when || ((struct lys_node_anydata *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_LEAF:\n        if (((struct lys_node_leaf *)node)->when || ((struct lys_node_leaf *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_LEAFLIST:\n        if (((struct lys_node_leaflist *)node)->when || ((struct lys_node_leaflist *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_LIST:\n        if (((struct lys_node_list *)node)->when || ((struct lys_node_list *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_CONTAINER:\n        if (((struct lys_node_container *)node)->when || ((struct lys_node_container *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        if (((struct lys_node_inout *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_NOTIF:\n        if (((struct lys_node_notif *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_USES:\n        if (((struct lys_node_uses *)node)->when) {\n            return 1;\n        }\n        break;\n    default:\n        /* does not have XPath */\n        break;\n    }\n\n    return 0;\n}\n\nint\nlys_type_is_local(const struct lys_type *type)\n{\n    if (!type->der->module) {\n        /* build-in type */\n        return 1;\n    }\n    /* type->parent can be either a typedef or leaf/leaf-list, but module pointers are compatible */\n    return (lys_main_module(type->der->module) == lys_main_module(((struct lys_tpdf *)type->parent)->module));\n}\n\n/*\n * shallow -\n *         - do not inherit status from the parent\n */\nstruct lys_node *\nlys_node_dup(struct lys_module *module, struct lys_node *parent, const struct lys_node *node,\n             struct unres_schema *unres, int shallow)\n{\n    struct lys_node *p = NULL;\n    int finalize = 0;\n    struct lys_node *result, *iter, *next;\n\n    if (!shallow) {\n        /* get know where in schema tree we are to know what should be done during instantiation of the grouping */\n        for (p = parent;\n             p && !(p->nodetype & (LYS_NOTIF | LYS_INPUT | LYS_OUTPUT | LYS_RPC | LYS_ACTION | LYS_GROUPING));\n             p = lys_parent(p));\n        finalize = p ? ((p->nodetype == LYS_GROUPING) ? 0 : 2) : 1;\n    }\n\n    result = lys_node_dup_recursion(module, parent, node, unres, shallow, finalize);\n    if (finalize) {\n        /* check xpath expressions in the instantiated tree */\n        for (iter = next = result; iter; iter = next) {\n            if (lys_has_xpath(iter) && unres_schema_add_node(module, unres, iter, UNRES_XPATH, NULL) == -1) {\n                /* invalid xpath */\n                return NULL;\n            }\n\n            /* select next item */\n            if (iter->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA | LYS_GROUPING)) {\n                /* child exception for leafs, leaflists and anyxml without children, ignore groupings */\n                next = NULL;\n            } else {\n                next = iter->child;\n            }\n            if (!next) {\n                /* no children, try siblings */\n                if (iter == result) {\n                    /* we are done, no next element to process */\n                    break;\n                }\n                next = iter->next;\n            }\n            while (!next) {\n                /* parent is already processed, go to its sibling */\n                iter = lys_parent(iter);\n                if (lys_parent(iter) == lys_parent(result)) {\n                    /* we are done, no next element to process */\n                    break;\n                }\n                next = iter->next;\n            }\n        }\n    }\n\n    return result;\n}\n\n/**\n * @brief Switch contents of two same schema nodes. One of the nodes\n * is expected to be ashallow copy of the other.\n *\n * @param[in] node1 Node whose contents will be switched with \\p node2.\n * @param[in] node2 Node whose contents will be switched with \\p node1.\n */\nstatic void\nlys_node_switch(struct lys_node *node1, struct lys_node *node2)\n{\n    const size_t mem_size = 104;\n    uint8_t mem[mem_size];\n    size_t offset, size;\n\n    assert((node1->module == node2->module) && ly_strequal(node1->name, node2->name, 1) && (node1->nodetype == node2->nodetype));\n\n    /*\n     * Initially, the nodes were really switched in the tree which\n     * caused problems for some other nodes with pointers (augments, leafrefs, ...)\n     * because their pointers were not being updated. Code kept in case there is\n     * a use of it in future (it took some debugging to cover all the cases).\n\n    * sibling next *\n    if (node1->prev->next) {\n        node1->prev->next = node2;\n    }\n\n    * sibling prev *\n    if (node1->next) {\n        node1->next->prev = node2;\n    } else {\n        for (child = node1->prev; child->prev->next; child = child->prev);\n        child->prev = node2;\n    }\n\n    * next *\n    node2->next = node1->next;\n    node1->next = NULL;\n\n    * prev *\n    if (node1->prev != node1) {\n        node2->prev = node1->prev;\n    }\n    node1->prev = node1;\n\n    * parent child *\n    if (node1->parent) {\n        if (node1->parent->child == node1) {\n            node1->parent->child = node2;\n        }\n    } else if (lys_main_module(node1->module)->data == node1) {\n        lys_main_module(node1->module)->data = node2;\n    }\n\n    * parent *\n    node2->parent = node1->parent;\n    node1->parent = NULL;\n\n    * child parent *\n    LY_TREE_FOR(node1->child, child) {\n        if (child->parent == node1) {\n            child->parent = node2;\n        }\n    }\n\n    * child *\n    node2->child = node1->child;\n    node1->child = NULL;\n    */\n\n    /* switch common node part */\n    offset = 3 * sizeof(char *);\n    size = sizeof(uint16_t) + 6 * sizeof(uint8_t) + sizeof(struct lys_ext_instance **) + sizeof(struct lys_iffeature *);\n    memcpy(mem, ((uint8_t *)node1) + offset, size);\n    memcpy(((uint8_t *)node1) + offset, ((uint8_t *)node2) + offset, size);\n    memcpy(((uint8_t *)node2) + offset, mem, size);\n\n    /* switch node-specific data */\n    offset = sizeof(struct lys_node);\n    switch (node1->nodetype) {\n    case LYS_CONTAINER:\n        size = sizeof(struct lys_node_container) - offset;\n        break;\n    case LYS_CHOICE:\n        size = sizeof(struct lys_node_choice) - offset;\n        break;\n    case LYS_LEAF:\n        size = sizeof(struct lys_node_leaf) - offset;\n        break;\n    case LYS_LEAFLIST:\n        size = sizeof(struct lys_node_leaflist) - offset;\n        break;\n    case LYS_LIST:\n        size = sizeof(struct lys_node_list) - offset;\n        break;\n    case LYS_ANYDATA:\n    case LYS_ANYXML:\n        size = sizeof(struct lys_node_anydata) - offset;\n        break;\n    case LYS_CASE:\n        size = sizeof(struct lys_node_case) - offset;\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        size = sizeof(struct lys_node_inout) - offset;\n        break;\n    case LYS_NOTIF:\n        size = sizeof(struct lys_node_notif) - offset;\n        break;\n    case LYS_RPC:\n    case LYS_ACTION:\n        size = sizeof(struct lys_node_rpc_action) - offset;\n        break;\n    default:\n        assert(0);\n        LOGINT(node1->module->ctx);\n        return;\n    }\n    assert(size <= mem_size);\n    memcpy(mem, ((uint8_t *)node1) + offset, size);\n    memcpy(((uint8_t *)node1) + offset, ((uint8_t *)node2) + offset, size);\n    memcpy(((uint8_t *)node2) + offset, mem, size);\n\n    /* typedefs were not copied to the backup node, so always reuse them,\n     * in leaves/leaf-lists we must correct the type parent pointer */\n    switch (node1->nodetype) {\n    case LYS_CONTAINER:\n        ((struct lys_node_container *)node1)->tpdf_size = ((struct lys_node_container *)node2)->tpdf_size;\n        ((struct lys_node_container *)node1)->tpdf = ((struct lys_node_container *)node2)->tpdf;\n        ((struct lys_node_container *)node2)->tpdf_size = 0;\n        ((struct lys_node_container *)node2)->tpdf = NULL;\n        break;\n    case LYS_LIST:\n        ((struct lys_node_list *)node1)->tpdf_size = ((struct lys_node_list *)node2)->tpdf_size;\n        ((struct lys_node_list *)node1)->tpdf = ((struct lys_node_list *)node2)->tpdf;\n        ((struct lys_node_list *)node2)->tpdf_size = 0;\n        ((struct lys_node_list *)node2)->tpdf = NULL;\n        break;\n    case LYS_RPC:\n    case LYS_ACTION:\n        ((struct lys_node_rpc_action *)node1)->tpdf_size = ((struct lys_node_rpc_action *)node2)->tpdf_size;\n        ((struct lys_node_rpc_action *)node1)->tpdf = ((struct lys_node_rpc_action *)node2)->tpdf;\n        ((struct lys_node_rpc_action *)node2)->tpdf_size = 0;\n        ((struct lys_node_rpc_action *)node2)->tpdf = NULL;\n        break;\n    case LYS_NOTIF:\n        ((struct lys_node_notif *)node1)->tpdf_size = ((struct lys_node_notif *)node2)->tpdf_size;\n        ((struct lys_node_notif *)node1)->tpdf = ((struct lys_node_notif *)node2)->tpdf;\n        ((struct lys_node_notif *)node2)->tpdf_size = 0;\n        ((struct lys_node_notif *)node2)->tpdf = NULL;\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        ((struct lys_node_inout *)node1)->tpdf_size = ((struct lys_node_inout *)node2)->tpdf_size;\n        ((struct lys_node_inout *)node1)->tpdf = ((struct lys_node_inout *)node2)->tpdf;\n        ((struct lys_node_inout *)node2)->tpdf_size = 0;\n        ((struct lys_node_inout *)node2)->tpdf = NULL;\n        break;\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n        ((struct lys_node_leaf *)node1)->type.parent = (struct lys_tpdf *)node1;\n        ((struct lys_node_leaf *)node2)->type.parent = (struct lys_tpdf *)node2;\n    default:\n        break;\n    }\n}\n\nvoid\nlys_free(struct lys_module *module, void (*private_destructor)(const struct lys_node *node, void *priv), int free_subs, int remove_from_ctx)\n{\n    struct ly_ctx *ctx;\n    int i;\n\n    if (!module) {\n        return;\n    }\n\n    /* remove schema from the context */\n    ctx = module->ctx;\n    if (remove_from_ctx && ctx->models.used) {\n        for (i = 0; i < ctx->models.used; i++) {\n            if (ctx->models.list[i] == module) {\n                /* move all the models to not change the order in the list */\n                ctx->models.used--;\n                memmove(&ctx->models.list[i], ctx->models.list[i + 1], (ctx->models.used - i) * sizeof *ctx->models.list);\n                ctx->models.list[ctx->models.used] = NULL;\n                /* we are done */\n                break;\n            }\n        }\n    }\n\n    /* common part with struct ly_submodule */\n    module_free_common(module, private_destructor);\n\n    /* include */\n    for (i = 0; i < module->inc_size; i++) {\n        lydict_remove(ctx, module->inc[i].dsc);\n        lydict_remove(ctx, module->inc[i].ref);\n        lys_extension_instances_free(ctx, module->inc[i].ext, module->inc[i].ext_size, private_destructor);\n        /* complete submodule free is done only from main module since\n         * submodules propagate their includes to the main module */\n        if (free_subs) {\n            lys_submodule_free(module->inc[i].submodule, private_destructor);\n        }\n    }\n    free(module->inc);\n\n    /* specific items to free */\n    lydict_remove(ctx, module->ns);\n\n    free(module);\n}\n\nstatic void\nlys_features_disable_recursive(struct lys_feature *f)\n{\n    unsigned int i;\n    struct lys_feature *depf;\n\n    /* disable the feature */\n    f->flags &= ~LYS_FENABLED;\n\n    /* by disabling feature we have to disable also all features that depends on this feature */\n    if (f->depfeatures) {\n        for (i = 0; i < f->depfeatures->number; i++) {\n            depf = (struct lys_feature *)f->depfeatures->set.g[i];\n            if (depf->flags & LYS_FENABLED) {\n                lys_features_disable_recursive(depf);\n            }\n        }\n    }\n}\n\n/*\n * op: 1 - enable, 0 - disable\n */\nstatic int\nlys_features_change(const struct lys_module *module, const char *name, int op)\n{\n    int all = 0;\n    int i, j, k;\n    int progress, faili, failj, failk;\n\n    uint8_t fsize;\n    struct lys_feature *f;\n\n    if (!module || !name || !strlen(name)) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    if (!strcmp(name, \"*\")) {\n        /* enable all */\n        all = 1;\n    }\n\n    progress = failk = 1;\n    while (progress && failk) {\n        for (i = -1, failk = progress = 0; i < module->inc_size; i++) {\n            if (i == -1) {\n                fsize = module->features_size;\n                f = module->features;\n            } else {\n                fsize = module->inc[i].submodule->features_size;\n                f = module->inc[i].submodule->features;\n            }\n\n            for (j = 0; j < fsize; j++) {\n                if (all || !strcmp(f[j].name, name)) {\n                    if ((op && (f[j].flags & LYS_FENABLED)) || (!op && !(f[j].flags & LYS_FENABLED))) {\n                        if (all) {\n                            /* skip already set features */\n                            continue;\n                        } else {\n                            /* feature already set correctly */\n                            return EXIT_SUCCESS;\n                        }\n                    }\n\n                    if (op) {\n                        /* check referenced features if they are enabled */\n                        for (k = 0; k < f[j].iffeature_size; k++) {\n                            if (!resolve_iffeature(&f[j].iffeature[k])) {\n                                if (all) {\n                                    faili = i;\n                                    failj = j;\n                                    failk = k + 1;\n                                    break;\n                                } else {\n                                    LOGERR(module->ctx, LY_EINVAL, \"Feature \\\"%s\\\" is disabled by its %d. if-feature condition.\",\n                                           f[j].name, k + 1);\n                                    return EXIT_FAILURE;\n                                }\n                            }\n                        }\n\n                        if (k == f[j].iffeature_size) {\n                            /* the last check passed, do the change */\n                            f[j].flags |= LYS_FENABLED;\n                            progress++;\n                        }\n                    } else {\n                        lys_features_disable_recursive(&f[j]);\n                        progress++;\n                    }\n                    if (!all) {\n                        /* stop in case changing a single feature */\n                        return EXIT_SUCCESS;\n                    }\n                }\n            }\n        }\n    }\n    if (failk) {\n        /* print info about the last failing feature */\n        LOGERR(module->ctx, LY_EINVAL, \"Feature \\\"%s\\\" is disabled by its %d. if-feature condition.\",\n               faili == -1 ? module->features[failj].name : module->inc[faili].submodule->features[failj].name, failk);\n        return EXIT_FAILURE;\n    }\n\n    if (all) {\n        return EXIT_SUCCESS;\n    } else {\n        /* the specified feature not found */\n        return EXIT_FAILURE;\n    }\n}\n\nAPI int\nlys_features_enable(const struct lys_module *module, const char *feature)\n{\n    return lys_features_change(module, feature, 1);\n}\n\nAPI int\nlys_features_disable(const struct lys_module *module, const char *feature)\n{\n    return lys_features_change(module, feature, 0);\n}\n\nAPI int\nlys_features_state(const struct lys_module *module, const char *feature)\n{\n    int i, j;\n\n    if (!module || !feature) {\n        return -1;\n    }\n\n    /* search for the specified feature */\n    /* module itself */\n    for (i = 0; i < module->features_size; i++) {\n        if (!strcmp(feature, module->features[i].name)) {\n            if (module->features[i].flags & LYS_FENABLED) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    /* submodules */\n    for (j = 0; j < module->inc_size; j++) {\n        for (i = 0; i < module->inc[j].submodule->features_size; i++) {\n            if (!strcmp(feature, module->inc[j].submodule->features[i].name)) {\n                if (module->inc[j].submodule->features[i].flags & LYS_FENABLED) {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            }\n        }\n    }\n\n    /* feature definition not found */\n    return -1;\n}\n\nAPI const char **\nlys_features_list(const struct lys_module *module, uint8_t **states)\n{\n    const char **result = NULL;\n    int i, j;\n    unsigned int count;\n\n    if (!module) {\n        return NULL;\n    }\n\n    count = module->features_size;\n    for (i = 0; i < module->inc_size; i++) {\n        count += module->inc[i].submodule->features_size;\n    }\n    result = malloc((count + 1) * sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(module->ctx), NULL);\n\n    if (states) {\n        *states = malloc((count + 1) * sizeof **states);\n        LY_CHECK_ERR_RETURN(!(*states), LOGMEM(module->ctx); free(result), NULL);\n    }\n    count = 0;\n\n    /* module itself */\n    for (i = 0; i < module->features_size; i++) {\n        result[count] = module->features[i].name;\n        if (states) {\n            if (module->features[i].flags & LYS_FENABLED) {\n                (*states)[count] = 1;\n            } else {\n                (*states)[count] = 0;\n            }\n        }\n        count++;\n    }\n\n    /* submodules */\n    for (j = 0; j < module->inc_size; j++) {\n        for (i = 0; i < module->inc[j].submodule->features_size; i++) {\n            result[count] = module->inc[j].submodule->features[i].name;\n            if (states) {\n                if (module->inc[j].submodule->features[i].flags & LYS_FENABLED) {\n                    (*states)[count] = 1;\n                } else {\n                    (*states)[count] = 0;\n                }\n            }\n            count++;\n        }\n    }\n\n    /* terminating NULL byte */\n    result[count] = NULL;\n\n    return result;\n}\n\nAPI struct lys_module *\nlys_node_module(const struct lys_node *node)\n{\n    if (!node) {\n        return NULL;\n    }\n\n    return node->module->type ? ((struct lys_submodule *)node->module)->belongsto : node->module;\n}\n\nAPI struct lys_module *\nlys_main_module(const struct lys_module *module)\n{\n    if (!module) {\n        return NULL;\n    }\n\n    return (module->type ? ((struct lys_submodule *)module)->belongsto : (struct lys_module *)module);\n}\n\nAPI struct lys_node *\nlys_parent(const struct lys_node *node)\n{\n    struct lys_node *parent;\n\n    if (!node) {\n        return NULL;\n    }\n\n    if (node->nodetype == LYS_EXT) {\n        if (((struct lys_ext_instance_complex*)node)->parent_type != LYEXT_PAR_NODE) {\n            return NULL;\n        }\n        parent = (struct lys_node*)((struct lys_ext_instance_complex*)node)->parent;\n    } else if (!node->parent) {\n        return NULL;\n    } else {\n        parent = node->parent;\n    }\n\n    if (parent->nodetype == LYS_AUGMENT) {\n        return ((struct lys_node_augment *)parent)->target;\n    } else {\n        return parent;\n    }\n}\n\nstruct lys_node **\nlys_child(const struct lys_node *node, LYS_NODE nodetype)\n{\n    void *pp;\n    assert(node);\n\n    if (node->nodetype == LYS_EXT) {\n        pp = lys_ext_complex_get_substmt(lys_snode2stmt(nodetype), (struct lys_ext_instance_complex*)node, NULL);\n        if (!pp) {\n            return NULL;\n        }\n        return (struct lys_node **)pp;\n    } else if (node->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n        return NULL;\n    } else {\n        return (struct lys_node **)&node->child;\n    }\n}\n\nAPI void *\nlys_set_private(const struct lys_node *node, void *priv)\n{\n    void *prev;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    prev = node->priv;\n    ((struct lys_node *)node)->priv = priv;\n\n    return prev;\n}\n\nint\nlys_leaf_add_leafref_target(struct lys_node_leaf *leafref_target, struct lys_node *leafref)\n{\n    struct lys_node_leaf *iter;\n    struct ly_ctx *ctx = leafref_target->module->ctx;\n\n    if (!(leafref_target->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n        LOGINT(ctx);\n        return -1;\n    }\n\n    /* check for config flag */\n    if (((struct lys_node_leaf*)leafref)->type.info.lref.req != -1 &&\n            (leafref->flags & LYS_CONFIG_W) && (leafref_target->flags & LYS_CONFIG_R)) {\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, leafref,\n               \"The leafref %s is config but refers to a non-config %s.\",\n               strnodetype(leafref->nodetype), strnodetype(leafref_target->nodetype));\n        return -1;\n    }\n    /* check for cycles */\n    for (iter = leafref_target; iter && iter->type.base == LY_TYPE_LEAFREF; iter = iter->type.info.lref.target) {\n        if ((void *)iter == (void *)leafref) {\n            /* cycle detected */\n            LOGVAL(ctx, LYE_CIRC_LEAFREFS, LY_VLOG_LYS, leafref);\n            return -1;\n        }\n    }\n\n    /* create fake child - the ly_set structure to hold the list of\n     * leafrefs referencing the leaf(-list) */\n    if (!leafref_target->backlinks) {\n        leafref_target->backlinks = (void *)ly_set_new();\n        if (!leafref_target->backlinks) {\n            LOGMEM(ctx);\n            return -1;\n        }\n    }\n    ly_set_add(leafref_target->backlinks, leafref, 0);\n\n    return 0;\n}\n\n/* not needed currently */\n#if 0\n\nstatic const char *\nlys_data_path_reverse(const struct lys_node *node, char * const buf, uint32_t buf_len)\n{\n    struct lys_module *prev_mod;\n    uint32_t str_len, mod_len, buf_idx;\n\n    if (!(node->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA))) {\n        LOGINT;\n        return NULL;\n    }\n\n    buf_idx = buf_len - 1;\n    buf[buf_idx] = '\\0';\n\n    while (node) {\n        if (lys_parent(node)) {\n            prev_mod = lys_node_module(lys_parent(node));\n        } else {\n            prev_mod = NULL;\n        }\n\n        if (node->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n            str_len = strlen(node->name);\n\n            if (prev_mod != node->module) {\n                mod_len = strlen(node->module->name);\n            } else {\n                mod_len = 0;\n            }\n\n            if (buf_idx < 1 + (mod_len ? mod_len + 1 : 0) + str_len) {\n                LOGINT;\n                return NULL;\n            }\n\n            buf_idx -= 1 + (mod_len ? mod_len + 1 : 0) + str_len;\n\n            buf[buf_idx] = '/';\n            if (mod_len) {\n                memcpy(buf + buf_idx + 1, node->module->name, mod_len);\n                buf[buf_idx + 1 + mod_len] = ':';\n            }\n            memcpy(buf + buf_idx + 1 + (mod_len ? mod_len + 1 : 0), node->name, str_len);\n        }\n\n        node = lys_parent(node);\n    }\n\n    return buf + buf_idx;\n}\n\n#endif\n\nAPI struct ly_set *\nlys_xpath_atomize(const struct lys_node *ctx_node, enum lyxp_node_type ctx_node_type, const char *expr, int options)\n{\n    struct lyxp_set set;\n    struct ly_set *ret_set;\n    uint32_t i;\n\n    if (!ctx_node || !expr) {\n        LOGARG;\n        return NULL;\n    }\n\n    /* adjust the root */\n    if ((ctx_node_type == LYXP_NODE_ROOT) || (ctx_node_type == LYXP_NODE_ROOT_CONFIG)) {\n        do {\n            ctx_node = lys_getnext(NULL, NULL, lys_node_module(ctx_node), LYS_GETNEXT_NOSTATECHECK);\n        } while ((ctx_node_type == LYXP_NODE_ROOT_CONFIG) && (ctx_node->flags & LYS_CONFIG_R));\n    }\n\n    memset(&set, 0, sizeof set);\n\n    if (options & LYXP_MUST) {\n        options &= ~LYXP_MUST;\n        options |= LYXP_SNODE_MUST;\n    } else if (options & LYXP_WHEN) {\n        options &= ~LYXP_WHEN;\n        options |= LYXP_SNODE_WHEN;\n    } else {\n        options |= LYXP_SNODE;\n    }\n\n    if (lyxp_atomize(expr, ctx_node, ctx_node_type, &set, options, NULL)) {\n        free(set.val.snodes);\n        LOGVAL(ctx_node->module->ctx, LYE_SPEC, LY_VLOG_LYS, ctx_node, \"Resolving XPath expression \\\"%s\\\" failed.\", expr);\n        return NULL;\n    }\n\n    ret_set = ly_set_new();\n\n    for (i = 0; i < set.used; ++i) {\n        switch (set.val.snodes[i].type) {\n        case LYXP_NODE_ELEM:\n            if (ly_set_add(ret_set, set.val.snodes[i].snode, LY_SET_OPT_USEASLIST) == -1) {\n                ly_set_free(ret_set);\n                free(set.val.snodes);\n                return NULL;\n            }\n            break;\n        default:\n            /* ignore roots, text and attr should not ever appear */\n            break;\n        }\n    }\n\n    free(set.val.snodes);\n    return ret_set;\n}\n\nAPI struct ly_set *\nlys_node_xpath_atomize(const struct lys_node *node, int options)\n{\n    const struct lys_node *next, *elem, *parent, *tmp;\n    struct lyxp_set set;\n    struct ly_set *ret_set;\n    uint16_t i;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    for (parent = node; parent && !(parent->nodetype & (LYS_NOTIF | LYS_INPUT | LYS_OUTPUT)); parent = lys_parent(parent));\n    if (!parent) {\n        /* not in input, output, or notification */\n        return NULL;\n    }\n\n    ret_set = ly_set_new();\n    if (!ret_set) {\n        return NULL;\n    }\n\n    LY_TREE_DFS_BEGIN(node, next, elem) {\n        if ((options & LYXP_NO_LOCAL) && !(elem->flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP))) {\n            /* elem has no dependencies from other subtrees and local nodes get discarded */\n            goto next_iter;\n        }\n\n        if (lyxp_node_atomize(elem, &set, 0)) {\n            ly_set_free(ret_set);\n            free(set.val.snodes);\n            return NULL;\n        }\n\n        for (i = 0; i < set.used; ++i) {\n            switch (set.val.snodes[i].type) {\n            case LYXP_NODE_ELEM:\n                if (options & LYXP_NO_LOCAL) {\n                    for (tmp = set.val.snodes[i].snode; tmp && (tmp != parent); tmp = lys_parent(tmp));\n                    if (tmp) {\n                        /* in local subtree, discard */\n                        break;\n                    }\n                }\n                if (ly_set_add(ret_set, set.val.snodes[i].snode, 0) == -1) {\n                    ly_set_free(ret_set);\n                    free(set.val.snodes);\n                    return NULL;\n                }\n                break;\n            default:\n                /* ignore roots, text and attr should not ever appear */\n                break;\n            }\n        }\n\n        free(set.val.snodes);\n        if (!(options & LYXP_RECURSIVE)) {\n            break;\n        }\nnext_iter:\n        LY_TREE_DFS_END(node, next, elem);\n    }\n\n    return ret_set;\n}\n\n/* logs */\nint\napply_aug(struct lys_node_augment *augment, struct unres_schema *unres)\n{\n    struct lys_node *child, *parent;\n    int clear_config;\n    unsigned int u;\n    uint8_t *v;\n    struct lys_ext_instance *ext;\n\n    assert(augment->target && (augment->flags & LYS_NOTAPPLIED));\n\n    if (!augment->child) {\n        /* nothing to apply */\n        goto success;\n    }\n\n    /* inherit config information from actual parent */\n    for (parent = augment->target; parent && !(parent->nodetype & (LYS_NOTIF | LYS_INPUT | LYS_OUTPUT | LYS_RPC)); parent = lys_parent(parent));\n    clear_config = (parent) ? 1 : 0;\n    LY_TREE_FOR(augment->child, child) {\n        if (inherit_config_flag(child, augment->target->flags & LYS_CONFIG_MASK, clear_config)) {\n            return -1;\n        }\n    }\n\n    /* inherit extensions if any */\n    for (u = 0; u < augment->target->ext_size; u++) {\n        ext = augment->target->ext[u]; /* shortcut */\n        if (ext && ext->def->plugin && (ext->def->plugin->flags & LYEXT_OPT_INHERIT)) {\n            v = malloc(sizeof *v);\n            LY_CHECK_ERR_RETURN(!v, LOGMEM(augment->module->ctx), -1);\n            *v = u;\n            if (unres_schema_add_node(lys_main_module(augment->module), unres, &augment->target->ext,\n                    UNRES_EXT_FINALIZE, (struct lys_node *)v) == -1) {\n                /* something really bad happend since the extension finalization is not actually\n                 * being resolved while adding into unres, so something more serious with the unres\n                 * list itself must happened */\n                return -1;\n            }\n        }\n    }\n\n    /* reconnect augmenting data into the target - add them to the target child list */\n    if (augment->target->child) {\n        child = augment->target->child->prev;\n        child->next = augment->child;\n        augment->target->child->prev = augment->child->prev;\n        augment->child->prev = child;\n    } else {\n        augment->target->child = augment->child;\n    }\n\nsuccess:\n    /* remove the flag about not applicability */\n    augment->flags &= ~LYS_NOTAPPLIED;\n    return EXIT_SUCCESS;\n}\n\nstatic void\nremove_aug(struct lys_node_augment *augment)\n{\n    struct lys_node *last, *elem;\n\n    if ((augment->flags & LYS_NOTAPPLIED) || !augment->target) {\n        /* skip already not applied augment */\n        return;\n    }\n\n    elem = augment->child;\n    if (elem) {\n        LY_TREE_FOR(elem, last) {\n            if (!last->next || (last->next->parent != (struct lys_node *)augment)) {\n                break;\n            }\n        }\n        /* elem is first augment child, last is the last child */\n\n        /* parent child ptr */\n        if (augment->target->child == elem) {\n            augment->target->child = last->next;\n        }\n\n        /* parent child next ptr */\n        if (elem->prev->next) {\n            elem->prev->next = last->next;\n        }\n\n        /* parent child prev ptr */\n        if (last->next) {\n            last->next->prev = elem->prev;\n        } else if (augment->target->child) {\n            augment->target->child->prev = elem->prev;\n        }\n\n        /* update augment children themselves */\n        elem->prev = last;\n        last->next = NULL;\n    }\n\n    /* augment->target still keeps the resolved target, but for lys_augment_free()\n     * we have to keep information that this augment is not applied to free its data */\n    augment->flags |= LYS_NOTAPPLIED;\n}\n\n/*\n * @param[in] module - the module where the deviation is defined\n */\nstatic void\nlys_switch_deviation(struct lys_deviation *dev, const struct lys_module *module, struct unres_schema *unres)\n{\n    int ret, reapply = 0;\n    char *parent_path;\n    struct lys_node *target = NULL, *parent;\n    struct lys_node_inout *inout;\n    struct ly_set *set;\n\n    if (!dev->deviate) {\n        return;\n    }\n\n    if (dev->deviate[0].mod == LY_DEVIATE_NO) {\n        if (dev->orig_node) {\n            /* removing not-supported deviation ... */\n            if (strrchr(dev->target_name, '/') != dev->target_name) {\n                /* ... from a parent */\n\n                /* reconnect to its previous position */\n                parent = dev->orig_node->parent;\n                if (parent && (parent->nodetype == LYS_AUGMENT)) {\n                    dev->orig_node->parent = NULL;\n                    /* the original node was actually from augment, we have to get know if the augment is\n                     * applied (its module is enabled and implemented). If yes, the node will be connected\n                     * to the augment and the linkage with the target will be fixed if needed, otherwise\n                     * it will be connected only to the augment */\n                    if (!(parent->flags & LYS_NOTAPPLIED)) {\n                        /* start with removing augment if applied before adding nodes, we have to make sure\n                         * that everything will be connect correctly */\n                        remove_aug((struct lys_node_augment *)parent);\n                        reapply = 1;\n                    }\n                    /* connect the deviated node back into the augment */\n                    lys_node_addchild(parent, NULL, dev->orig_node, 0);\n                    if (reapply) {\n                        /* augment is supposed to be applied, so fix pointers in target and the status of the original node */\n                        assert(lys_node_module(parent)->implemented);\n                        parent->flags |= LYS_NOTAPPLIED; /* allow apply_aug() */\n                        apply_aug((struct lys_node_augment *)parent, unres);\n                    }\n                } else if (parent && (parent->nodetype == LYS_USES)) {\n                    /* uses child */\n                    lys_node_addchild(parent, NULL, dev->orig_node, 0);\n                } else {\n                    /* non-augment, non-toplevel */\n                    parent_path = strndup(dev->target_name, strrchr(dev->target_name, '/') - dev->target_name);\n                    ret = resolve_schema_nodeid(parent_path, NULL, module, &set, 0, 1);\n                    free(parent_path);\n                    if (ret == -1) {\n                        LOGINT(module->ctx);\n                        ly_set_free(set);\n                        return;\n                    }\n                    target = set->set.s[0];\n                    ly_set_free(set);\n\n                    lys_node_addchild(target, NULL, dev->orig_node, 0);\n                }\n            } else {\n                /* ... from top-level data */\n                lys_node_addchild(NULL, (struct lys_module *)dev->orig_node->module, dev->orig_node, 0);\n            }\n\n            dev->orig_node = NULL;\n        } else {\n            /* adding not-supported deviation */\n            ret = resolve_schema_nodeid(dev->target_name, NULL, module, &set, 0, 1);\n            if (ret == -1) {\n                LOGINT(module->ctx);\n                ly_set_free(set);\n                return;\n            }\n            target = set->set.s[0];\n            ly_set_free(set);\n\n            /* unlink and store the original node */\n            parent = target->parent;\n            lys_node_unlink(target);\n            if (parent) {\n                if (parent->nodetype & (LYS_AUGMENT | LYS_USES)) {\n                    /* hack for augment, because when the original will be sometime reconnected back, we actually need\n                     * to reconnect it to both - the augment and its target (which is deduced from the deviations target\n                     * path), so we need to remember the augment as an addition */\n                    /* we also need to remember the parent uses so that we connect it back to it when switching deviation state */\n                    target->parent = parent;\n                } else if (parent->nodetype & (LYS_RPC | LYS_ACTION)) {\n                    /* re-create implicit node */\n                    inout = calloc(1, sizeof *inout);\n                    LY_CHECK_ERR_RETURN(!inout, LOGMEM(module->ctx), );\n\n                    inout->nodetype = target->nodetype;\n                    inout->name = lydict_insert(module->ctx, (inout->nodetype == LYS_INPUT) ? \"input\" : \"output\", 0);\n                    inout->module = target->module;\n                    inout->flags = LYS_IMPLICIT;\n\n                    /* insert it manually */\n                    assert(parent->child && !parent->child->next\n                    && (parent->child->nodetype == (inout->nodetype == LYS_INPUT ? LYS_OUTPUT : LYS_INPUT)));\n                    parent->child->next = (struct lys_node *)inout;\n                    inout->prev = parent->child;\n                    parent->child->prev = (struct lys_node *)inout;\n                    inout->parent = parent;\n                }\n            }\n            dev->orig_node = target;\n        }\n    } else {\n        ret = resolve_schema_nodeid(dev->target_name, NULL, module, &set, 0, 1);\n        if (ret == -1) {\n            LOGINT(module->ctx);\n            ly_set_free(set);\n            return;\n        }\n        target = set->set.s[0];\n        ly_set_free(set);\n\n        /* contents are switched */\n        lys_node_switch(target, dev->orig_node);\n    }\n}\n\n/* temporarily removes or applies deviations, updates module deviation flag accordingly */\nvoid\nlys_enable_deviations(struct lys_module *module)\n{\n    uint32_t i = 0, j;\n    const struct lys_module *mod;\n    const char *ptr;\n    struct unres_schema *unres;\n\n    if (module->deviated) {\n        unres = calloc(1, sizeof *unres);\n        LY_CHECK_ERR_RETURN(!unres, LOGMEM(module->ctx), );\n\n        while ((mod = ly_ctx_get_module_iter(module->ctx, &i))) {\n            if (mod == module) {\n                continue;\n            }\n\n            for (j = 0; j < mod->deviation_size; ++j) {\n                ptr = strstr(mod->deviation[j].target_name, module->name);\n                if (ptr && ptr[strlen(module->name)] == ':') {\n                    lys_switch_deviation(&mod->deviation[j], mod, unres);\n                }\n            }\n        }\n\n        assert(module->deviated == 2);\n        module->deviated = 1;\n\n        for (j = 0; j < module->inc_size; j++) {\n            if (module->inc[j].submodule->deviated) {\n                module->inc[j].submodule->deviated = module->deviated;\n            }\n        }\n\n        if (unres->count) {\n            resolve_unres_schema(module, unres);\n        }\n        unres_schema_free(module, &unres, 1);\n    }\n}\n\nvoid\nlys_disable_deviations(struct lys_module *module)\n{\n    uint32_t i, j;\n    const struct lys_module *mod;\n    const char *ptr;\n    struct unres_schema *unres;\n\n    if (module->deviated) {\n        unres = calloc(1, sizeof *unres);\n        LY_CHECK_ERR_RETURN(!unres, LOGMEM(module->ctx), );\n\n        i = module->ctx->models.used;\n        while (i--) {\n            mod = module->ctx->models.list[i];\n\n            if (mod == module) {\n                continue;\n            }\n\n            j = mod->deviation_size;\n            while (j--) {\n                ptr = strstr(mod->deviation[j].target_name, module->name);\n                if (ptr && ptr[strlen(module->name)] == ':') {\n                    lys_switch_deviation(&mod->deviation[j], mod, unres);\n                }\n            }\n        }\n\n        assert(module->deviated == 1);\n        module->deviated = 2;\n\n        for (j = 0; j < module->inc_size; j++) {\n            if (module->inc[j].submodule->deviated) {\n                module->inc[j].submodule->deviated = module->deviated;\n            }\n        }\n\n        if (unres->count) {\n            resolve_unres_schema(module, unres);\n        }\n        unres_schema_free(module, &unres, 1);\n    }\n}\n\nstatic void\napply_dev(struct lys_deviation *dev, const struct lys_module *module, struct unres_schema *unres)\n{\n    lys_switch_deviation(dev, module, unres);\n\n    assert(dev->orig_node);\n    lys_node_module(dev->orig_node)->deviated = 1; /* main module */\n    dev->orig_node->module->deviated = 1;          /* possible submodule */\n}\n\nstatic void\nremove_dev(struct lys_deviation *dev, const struct lys_module *module, struct unres_schema *unres)\n{\n    uint32_t idx = 0, j;\n    const struct lys_module *mod;\n    struct lys_module *target_mod, *target_submod;\n    const char *ptr;\n\n    if (dev->orig_node) {\n        target_mod = lys_node_module(dev->orig_node);\n        target_submod = dev->orig_node->module;\n    } else {\n        LOGINT(module->ctx);\n        return;\n    }\n    lys_switch_deviation(dev, module, unres);\n\n    /* clear the deviation flag if possible */\n    while ((mod = ly_ctx_get_module_iter(module->ctx, &idx))) {\n        if ((mod == module) || (mod == target_mod)) {\n            continue;\n        }\n\n        for (j = 0; j < mod->deviation_size; ++j) {\n            ptr = strstr(mod->deviation[j].target_name, target_mod->name);\n            if (ptr && (ptr[strlen(target_mod->name)] == ':')) {\n                /* some other module deviation targets the inspected module, flag remains */\n                break;\n            }\n        }\n\n        if (j < mod->deviation_size) {\n            break;\n        }\n    }\n\n    if (!mod) {\n        target_mod->deviated = 0;    /* main module */\n        target_submod->deviated = 0; /* possible submodule */\n    }\n}\n\nvoid\nlys_sub_module_apply_devs_augs(struct lys_module *module)\n{\n    uint8_t u, v;\n    struct unres_schema *unres;\n\n    assert(module->implemented);\n\n    unres = calloc(1, sizeof *unres);\n    LY_CHECK_ERR_RETURN(!unres, LOGMEM(module->ctx), );\n\n    /* apply deviations */\n    for (u = 0; u < module->deviation_size; ++u) {\n        apply_dev(&module->deviation[u], module, unres);\n    }\n    /* apply augments */\n    for (u = 0; u < module->augment_size; ++u) {\n        apply_aug(&module->augment[u], unres);\n    }\n\n    /* apply deviations and augments defined in submodules */\n    for (v = 0; v < module->inc_size; ++v) {\n        for (u = 0; u < module->inc[v].submodule->deviation_size; ++u) {\n            apply_dev(&module->inc[v].submodule->deviation[u], module, unres);\n        }\n\n        for (u = 0; u < module->inc[v].submodule->augment_size; ++u) {\n            apply_aug(&module->inc[v].submodule->augment[u], unres);\n        }\n    }\n\n    if (unres->count) {\n        resolve_unres_schema(module, unres);\n    }\n    /* nothing else left to do even if something is not resolved */\n    unres_schema_free(module, &unres, 1);\n}\n\nvoid\nlys_sub_module_remove_devs_augs(struct lys_module *module)\n{\n    uint8_t u, v, w;\n    struct unres_schema *unres;\n\n    unres = calloc(1, sizeof *unres);\n    LY_CHECK_ERR_RETURN(!unres, LOGMEM(module->ctx), );\n\n    /* remove applied deviations */\n    for (u = 0; u < module->deviation_size; ++u) {\n        /* the deviation could not be applied because it failed to be applied in the first place*/\n        if (module->deviation[u].orig_node) {\n            remove_dev(&module->deviation[u], module, unres);\n        }\n\n        /* Free the deviation's must array(s). These are shallow copies of the arrays\n           on the target node(s), so a deep free is not needed. */\n        for (v = 0; v < module->deviation[u].deviate_size; ++v) {\n            if (module->deviation[u].deviate[v].mod == LY_DEVIATE_ADD) {\n                free(module->deviation[u].deviate[v].must);\n            }\n        }\n    }\n    /* remove applied augments */\n    for (u = 0; u < module->augment_size; ++u) {\n        remove_aug(&module->augment[u]);\n    }\n\n    /* remove deviation and augments defined in submodules */\n    for (v = 0; v < module->inc_size && module->inc[v].submodule; ++v) {\n        for (u = 0; u < module->inc[v].submodule->deviation_size; ++u) {\n            if (module->inc[v].submodule->deviation[u].orig_node) {\n                remove_dev(&module->inc[v].submodule->deviation[u], module, unres);\n            }\n\n            /* Free the deviation's must array(s). These are shallow copies of the arrays\n               on the target node(s), so a deep free is not needed. */\n            for (w = 0; w < module->inc[v].submodule->deviation[u].deviate_size; ++w) {\n                if (module->inc[v].submodule->deviation[u].deviate[w].mod == LY_DEVIATE_ADD) {\n                    free(module->inc[v].submodule->deviation[u].deviate[w].must);\n                }\n            }\n        }\n\n        for (u = 0; u < module->inc[v].submodule->augment_size; ++u) {\n            remove_aug(&module->inc[v].submodule->augment[u]);\n        }\n    }\n\n    if (unres->count) {\n        resolve_unres_schema(module, unres);\n    }\n    /* nothing else left to do even if something is not resolved */\n    unres_schema_free(module, &unres, 1);\n}\n\nint\nlys_make_implemented_r(struct lys_module *module, struct unres_schema *unres)\n{\n    struct ly_ctx *ctx;\n    struct lys_node *root, *next, *node;\n    struct lys_module *target_module;\n    uint16_t i, j, k;\n\n    assert(module->implemented);\n    ctx = module->ctx;\n\n    for (i = 0; i < ctx->models.used; ++i) {\n        if (module == ctx->models.list[i]) {\n            continue;\n        }\n\n        if (!strcmp(module->name, ctx->models.list[i]->name) && ctx->models.list[i]->implemented) {\n            LOGERR(ctx, LY_EINVAL, \"Module \\\"%s\\\" in another revision already implemented.\", module->name);\n            return EXIT_FAILURE;\n        }\n    }\n\n    for (i = 0; i < module->augment_size; i++) {\n\n        /* make target module implemented if was not */\n        assert(module->augment[i].target);\n        target_module = lys_node_module(module->augment[i].target);\n        if (!target_module->implemented) {\n            target_module->implemented = 1;\n            if (unres_schema_add_node(target_module, unres, NULL, UNRES_MOD_IMPLEMENT, NULL) == -1) {\n                return -1;\n            }\n        }\n\n        /* apply augment */\n        if ((module->augment[i].flags & LYS_NOTAPPLIED) && apply_aug(&module->augment[i], unres)) {\n            return -1;\n        }\n    }\n\n    /* identities */\n    for (i = 0; i < module->ident_size; i++) {\n        for (j = 0; j < module->ident[i].base_size; j++) {\n            resolve_identity_backlink_update(&module->ident[i], module->ident[i].base[j]);\n        }\n    }\n\n    /* process augments in submodules */\n    for (i = 0; i < module->inc_size && module->inc[i].submodule; ++i) {\n        module->inc[i].submodule->implemented = 1;\n\n        for (j = 0; j < module->inc[i].submodule->augment_size; j++) {\n\n            /* make target module implemented if it was not */\n            assert(module->inc[i].submodule->augment[j].target);\n            target_module = lys_node_module(module->inc[i].submodule->augment[j].target);\n            if (!target_module->implemented) {\n                target_module->implemented = 1;\n                if (unres_schema_add_node(target_module, unres, NULL, UNRES_MOD_IMPLEMENT, NULL) == -1) {\n                    return -1;\n                }\n            }\n\n            /* apply augment */\n            if ((module->inc[i].submodule->augment[j].flags & LYS_NOTAPPLIED) && apply_aug(&module->inc[i].submodule->augment[j], unres)) {\n                return -1;\n            }\n        }\n\n        /* identities */\n        for (j = 0; j < module->inc[i].submodule->ident_size; j++) {\n            for (k = 0; k < module->inc[i].submodule->ident[j].base_size; k++) {\n                resolve_identity_backlink_update(&module->inc[i].submodule->ident[j],\n                                                 module->inc[i].submodule->ident[j].base[k]);\n            }\n        }\n    }\n\n    LY_TREE_FOR(module->data, root) {\n        /* handle leafrefs and recursively change the implemented flags in the leafref targets */\n        LY_TREE_DFS_BEGIN(root, next, node) {\n            if (node->nodetype == LYS_GROUPING) {\n                goto nextsibling;\n            }\n            if (node->nodetype & (LYS_LEAF | LYS_LEAFLIST)) {\n                if (((struct lys_node_leaf *)node)->type.base == LY_TYPE_LEAFREF) {\n                    if (unres_schema_add_node(module, unres, &((struct lys_node_leaf *)node)->type,\n                                              UNRES_TYPE_LEAFREF, node) == -1) {\n                        return -1;\n                    }\n                }\n            }\n\n            /* modified LY_TREE_DFS_END */\n            next = node->child;\n            /* child exception for leafs, leaflists and anyxml without children */\n            if (node->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                next = NULL;\n            }\n            if (!next) {\nnextsibling:\n                /* no children */\n                if (node == root) {\n                    /* we are done, root has no children */\n                    break;\n                }\n                /* try siblings */\n                next = node->next;\n            }\n            while (!next) {\n                /* parent is already processed, go to its sibling */\n                node = lys_parent(node);\n                /* no siblings, go back through parents */\n                if (lys_parent(node) == lys_parent(root)) {\n                    /* we are done, no next element to process */\n                    break;\n                }\n                next = node->next;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nAPI int\nlys_set_implemented(const struct lys_module *module)\n{\n    struct unres_schema *unres;\n    int disabled = 0;\n\n    if (!module) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    module = lys_main_module(module);\n\n    if (module->disabled) {\n        disabled = 1;\n        lys_set_enabled(module);\n    }\n\n    if (module->implemented) {\n        return EXIT_SUCCESS;\n    }\n\n    unres = calloc(1, sizeof *unres);\n    if (!unres) {\n        LOGMEM(module->ctx);\n        if (disabled) {\n            /* set it back disabled */\n            lys_set_disabled(module);\n        }\n        return EXIT_FAILURE;\n    }\n    /* recursively make the module implemented */\n    ((struct lys_module *)module)->implemented = 1;\n    if (lys_make_implemented_r((struct lys_module *)module, unres)) {\n        goto error;\n    }\n\n    /* try again resolve augments in other modules possibly augmenting this one,\n     * since we have just enabled it\n     */\n    /* resolve rest of unres items */\n    if (unres->count && resolve_unres_schema((struct lys_module *)module, unres)) {\n        goto error;\n    }\n    unres_schema_free(NULL, &unres, 0);\n\n    LOGVRB(\"Module \\\"%s%s%s\\\" now implemented.\", module->name, (module->rev_size ? \"@\" : \"\"),\n           (module->rev_size ? module->rev[0].date : \"\"));\n    return EXIT_SUCCESS;\n\nerror:\n    if (disabled) {\n        /* set it back disabled */\n        lys_set_disabled(module);\n    }\n\n    ((struct lys_module *)module)->implemented = 0;\n    unres_schema_free((struct lys_module *)module, &unres, 1);\n    return EXIT_FAILURE;\n}\n\nvoid\nlys_submodule_module_data_free(struct lys_submodule *submodule)\n{\n    struct lys_node *next, *elem;\n\n    /* remove parsed data */\n    LY_TREE_FOR_SAFE(submodule->belongsto->data, next, elem) {\n        if (elem->module == (struct lys_module *)submodule) {\n            lys_node_free(elem, NULL, 0);\n        }\n    }\n}\n\nAPI char *\nlys_path(const struct lys_node *node, int options)\n{\n    char *buf = NULL;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (ly_vlog_build_path(LY_VLOG_LYS, node, &buf, (options & LYS_PATH_FIRST_PREFIX) ? 0 : 1, 0)) {\n        return NULL;\n    }\n\n    return buf;\n}\n\nAPI char *\nlys_data_path(const struct lys_node *node)\n{\n    char *result = NULL, buf[1024];\n    const char *separator, *name;\n    int i, used;\n    struct ly_set *set;\n    const struct lys_module *prev_mod;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    buf[0] = '\\0';\n    set = ly_set_new();\n    LY_CHECK_ERR_GOTO(!set, LOGMEM(node->module->ctx), cleanup);\n\n    while (node) {\n        ly_set_add(set, (void *)node, 0);\n        do {\n            node = lys_parent(node);\n        } while (node && (node->nodetype & (LYS_USES | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));\n    }\n\n    prev_mod = NULL;\n    used = 0;\n    for (i = set->number - 1; i > -1; --i) {\n        node = set->set.s[i];\n        if (node->nodetype == LYS_EXT) {\n            if (strcmp(((struct lys_ext_instance *)node)->def->name, \"yang-data\")) {\n                continue;\n            }\n            name = ((struct lys_ext_instance *)node)->arg_value;\n            separator = \":#\";\n        } else {\n            name = node->name;\n            separator = \":\";\n        }\n        used += sprintf(buf + used, \"/%s%s%s\", (lys_node_module(node) == prev_mod ? \"\" : lys_node_module(node)->name),\n                        (lys_node_module(node) == prev_mod ? \"\" : separator), name);\n        prev_mod = lys_node_module(node);\n    }\n\n    result = strdup(buf);\n    LY_CHECK_ERR_GOTO(!result, LOGMEM(node->module->ctx), cleanup);\n\ncleanup:\n    ly_set_free(set);\n    return result;\n}\n\nstruct lys_node_augment *\nlys_getnext_target_aug(struct lys_node_augment *last, const struct lys_module *mod, const struct lys_node *aug_target)\n{\n    struct lys_node *child;\n    struct lys_node_augment *aug;\n    int i, j, last_found;\n\n    assert(mod && aug_target);\n\n    if (!last) {\n        last_found = 1;\n    } else {\n        last_found = 0;\n    }\n\n    /* search module augments */\n    for (i = 0; i < mod->augment_size; ++i) {\n        if (!mod->augment[i].target) {\n            /* still unresolved, skip */\n            continue;\n        }\n\n        if (mod->augment[i].target == aug_target) {\n            if (last_found) {\n                /* next match after last */\n                return &mod->augment[i];\n            }\n\n            if (&mod->augment[i] == last) {\n                last_found = 1;\n            }\n        }\n    }\n\n    /* search submodule augments */\n    for (i = 0; i < mod->inc_size; ++i) {\n        for (j = 0; j < mod->inc[i].submodule->augment_size; ++j) {\n            if (!mod->inc[i].submodule->augment[j].target) {\n                continue;\n            }\n\n            if (mod->inc[i].submodule->augment[j].target == aug_target) {\n                if (last_found) {\n                    /* next match after last */\n                    return &mod->inc[i].submodule->augment[j];\n                }\n\n                if (&mod->inc[i].submodule->augment[j] == last) {\n                    last_found = 1;\n                }\n            }\n        }\n    }\n\n    /* we also need to check possible augments to choices */\n    LY_TREE_FOR(aug_target->child, child) {\n        if (child->nodetype == LYS_CHOICE) {\n            aug = lys_getnext_target_aug(last, mod, child);\n            if (aug) {\n                return aug;\n            }\n        }\n    }\n\n    return NULL;\n}\n\nAPI struct ly_set *\nlys_find_path(const struct lys_module *cur_module, const struct lys_node *cur_node, const char *path)\n{\n    struct ly_set *ret;\n    int rc;\n\n    if ((!cur_module && !cur_node) || !path) {\n        return NULL;\n    }\n\n    rc = resolve_schema_nodeid(path, cur_node, cur_module, &ret, 1, 1);\n    if (rc == -1) {\n        return NULL;\n    }\n\n    return ret;\n}\n\nstatic void\nlys_extcomplex_free_str(struct ly_ctx *ctx, struct lys_ext_instance_complex *ext, LY_STMT stmt)\n{\n    struct lyext_substmt *info;\n    const char **str, ***a;\n    int c;\n\n    str = lys_ext_complex_get_substmt(stmt, ext, &info);\n    if (!str || !(*str)) {\n        return;\n    }\n    if (info->cardinality >= LY_STMT_CARD_SOME) {\n        /* we have array */\n        a = (const char ***)str;\n        for (str = (*(const char ***)str), c = 0; str[c]; c++) {\n            lydict_remove(ctx, str[c]);\n        }\n        free(a[0]);\n        if (stmt == LY_STMT_BELONGSTO) {\n            for (str = a[1], c = 0; str[c]; c++) {\n                lydict_remove(ctx, str[c]);\n            }\n            free(a[1]);\n        } else if (stmt == LY_STMT_ARGUMENT) {\n            free(a[1]);\n        }\n    } else {\n        lydict_remove(ctx, str[0]);\n        if (stmt == LY_STMT_BELONGSTO) {\n            lydict_remove(ctx, str[1]);\n        }\n    }\n}\n\nvoid\nlys_extension_instances_free(struct ly_ctx *ctx, struct lys_ext_instance **e, unsigned int size,\n                             void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    unsigned int i, j, k;\n    struct lyext_substmt *substmt;\n    void **pp, **start;\n    struct lys_node *siter, *snext;\n\n#define EXTCOMPLEX_FREE_STRUCT(STMT, TYPE, FUNC, FREE, ARGS...)                               \\\n    pp = lys_ext_complex_get_substmt(STMT, (struct lys_ext_instance_complex *)e[i], NULL);    \\\n    if (!pp || !(*pp)) { break; }                                                             \\\n    if (substmt[j].cardinality >= LY_STMT_CARD_SOME) { /* process array */                    \\\n        for (start = pp = *pp; *pp; pp++) {                                                   \\\n            FUNC(ctx, (TYPE *)(*pp), ##ARGS, private_destructor);                             \\\n            if (FREE) { free(*pp); }                                                          \\\n        }                                                                                     \\\n        free(start);                                                                          \\\n    } else { /* single item */                                                                \\\n        FUNC(ctx, (TYPE *)(*pp), ##ARGS, private_destructor);                                 \\\n        if (FREE) { free(*pp); }                                                              \\\n    }\n\n    if (!size || !e) {\n        return;\n    }\n\n    for (i = 0; i < size; i++) {\n        if (!e[i]) {\n            continue;\n        }\n\n        if (e[i]->flags & (LYEXT_OPT_INHERIT)) {\n            /* no free, this is just a shadow copy of the original extension instance */\n        } else {\n            if (e[i]->flags & (LYEXT_OPT_YANG)) {\n                free(e[i]->def);     /* remove name of instance extension */\n                e[i]->def = NULL;\n                yang_free_ext_data((struct yang_ext_substmt *)e[i]->parent); /* remove backup part of yang file */\n            }\n            /* remove private object */\n            if (e[i]->priv && private_destructor) {\n                private_destructor((struct lys_node*)e[i], e[i]->priv);\n            }\n            lys_extension_instances_free(ctx, e[i]->ext, e[i]->ext_size, private_destructor);\n            lydict_remove(ctx, e[i]->arg_value);\n        }\n\n        if (e[i]->def && e[i]->def->plugin && e[i]->def->plugin->type == LYEXT_COMPLEX\n                && ((e[i]->flags & LYEXT_OPT_CONTENT) == 0)) {\n            substmt = ((struct lys_ext_instance_complex *)e[i])->substmt;\n            for (j = 0; substmt[j].stmt; j++) {\n                switch(substmt[j].stmt) {\n                case LY_STMT_DESCRIPTION:\n                case LY_STMT_REFERENCE:\n                case LY_STMT_UNITS:\n                case LY_STMT_ARGUMENT:\n                case LY_STMT_DEFAULT:\n                case LY_STMT_ERRTAG:\n                case LY_STMT_ERRMSG:\n                case LY_STMT_PREFIX:\n                case LY_STMT_NAMESPACE:\n                case LY_STMT_PRESENCE:\n                case LY_STMT_REVISIONDATE:\n                case LY_STMT_KEY:\n                case LY_STMT_BASE:\n                case LY_STMT_BELONGSTO:\n                case LY_STMT_CONTACT:\n                case LY_STMT_ORGANIZATION:\n                case LY_STMT_PATH:\n                    lys_extcomplex_free_str(ctx, (struct lys_ext_instance_complex *)e[i], substmt[j].stmt);\n                    break;\n                case LY_STMT_TYPE:\n                    EXTCOMPLEX_FREE_STRUCT(LY_STMT_TYPE, struct lys_type, lys_type_free, 1);\n                    break;\n                case LY_STMT_TYPEDEF:\n                    EXTCOMPLEX_FREE_STRUCT(LY_STMT_TYPEDEF, struct lys_tpdf, lys_tpdf_free, 1);\n                    break;\n                case LY_STMT_IFFEATURE:\n                    EXTCOMPLEX_FREE_STRUCT(LY_STMT_IFFEATURE, struct lys_iffeature, lys_iffeature_free, 0, 1, 0);\n                    break;\n                case LY_STMT_MAX:\n                case LY_STMT_MIN:\n                case LY_STMT_POSITION:\n                case LY_STMT_VALUE:\n                    pp = (void**)&((struct lys_ext_instance_complex *)e[i])->content[substmt[j].offset];\n                    if (substmt[j].cardinality >= LY_STMT_CARD_SOME && *pp) {\n                        for(k = 0; ((uint32_t**)(*pp))[k]; k++) {\n                            free(((uint32_t**)(*pp))[k]);\n                        }\n                    }\n                    free(*pp);\n                    break;\n                case LY_STMT_DIGITS:\n                    if (substmt[j].cardinality >= LY_STMT_CARD_SOME) {\n                        /* free the array */\n                        pp = (void**)&((struct lys_ext_instance_complex *)e[i])->content[substmt[j].offset];\n                        free(*pp);\n                    }\n                    break;\n                case LY_STMT_MODULE:\n                    /* modules are part of the context, so they will be freed there */\n                    if (substmt[j].cardinality >= LY_STMT_CARD_SOME) {\n                        /* free the array */\n                        pp = (void**)&((struct lys_ext_instance_complex *)e[i])->content[substmt[j].offset];\n                        free(*pp);\n                    }\n                    break;\n                case LY_STMT_ACTION:\n                case LY_STMT_ANYDATA:\n                case LY_STMT_ANYXML:\n                case LY_STMT_CASE:\n                case LY_STMT_CHOICE:\n                case LY_STMT_CONTAINER:\n                case LY_STMT_GROUPING:\n                case LY_STMT_INPUT:\n                case LY_STMT_LEAF:\n                case LY_STMT_LEAFLIST:\n                case LY_STMT_LIST:\n                case LY_STMT_NOTIFICATION:\n                case LY_STMT_OUTPUT:\n                case LY_STMT_RPC:\n                case LY_STMT_USES:\n                    pp = (void**)&((struct lys_ext_instance_complex *)e[i])->content[substmt[j].offset];\n                    LY_TREE_FOR_SAFE((struct lys_node *)(*pp), snext, siter) {\n                        lys_node_free(siter, NULL, 0);\n                    }\n                    *pp = NULL;\n                    break;\n                case LY_STMT_UNIQUE:\n                    pp = lys_ext_complex_get_substmt(LY_STMT_UNIQUE, (struct lys_ext_instance_complex *)e[i], NULL);\n                    if (!pp || !(*pp)) {\n                        break;\n                    }\n                    if (substmt[j].cardinality >= LY_STMT_CARD_SOME) { /* process array */\n                        for (start = pp = *pp; *pp; pp++) {\n                            for (k = 0; k < (*(struct lys_unique**)pp)->expr_size; k++) {\n                                lydict_remove(ctx, (*(struct lys_unique**)pp)->expr[k]);\n                            }\n                            free((*(struct lys_unique**)pp)->expr);\n                            free(*pp);\n                        }\n                        free(start);\n                    } else { /* single item */\n                        for (k = 0; k < (*(struct lys_unique**)pp)->expr_size; k++) {\n                            lydict_remove(ctx, (*(struct lys_unique**)pp)->expr[k]);\n                        }\n                        free((*(struct lys_unique**)pp)->expr);\n                        free(*pp);\n                    }\n                    break;\n                case LY_STMT_LENGTH:\n                case LY_STMT_MUST:\n                case LY_STMT_PATTERN:\n                case LY_STMT_RANGE:\n                    EXTCOMPLEX_FREE_STRUCT(substmt[j].stmt, struct lys_restr, lys_restr_free, 1);\n                    break;\n                case LY_STMT_WHEN:\n                    EXTCOMPLEX_FREE_STRUCT(LY_STMT_WHEN, struct lys_when, lys_when_free, 0);\n                    break;\n                case LY_STMT_REVISION:\n                    pp = lys_ext_complex_get_substmt(LY_STMT_REVISION, (struct lys_ext_instance_complex *)e[i], NULL);\n                    if (!pp || !(*pp)) {\n                        break;\n                    }\n                    if (substmt[j].cardinality >= LY_STMT_CARD_SOME) { /* process array */\n                        for (start = pp = *pp; *pp; pp++) {\n                            lydict_remove(ctx, (*(struct lys_revision**)pp)->dsc);\n                            lydict_remove(ctx, (*(struct lys_revision**)pp)->ref);\n                            lys_extension_instances_free(ctx, (*(struct lys_revision**)pp)->ext,\n                                                         (*(struct lys_revision**)pp)->ext_size, private_destructor);\n                            free(*pp);\n                        }\n                        free(start);\n                    } else { /* single item */\n                        lydict_remove(ctx, (*(struct lys_revision**)pp)->dsc);\n                        lydict_remove(ctx, (*(struct lys_revision**)pp)->ref);\n                        lys_extension_instances_free(ctx, (*(struct lys_revision**)pp)->ext,\n                                                     (*(struct lys_revision**)pp)->ext_size, private_destructor);\n                        free(*pp);\n                    }\n                    break;\n                default:\n                    /* nothing to free */\n                    break;\n                }\n            }\n        }\n\n        free(e[i]);\n    }\n    free(e);\n\n#undef EXTCOMPLEX_FREE_STRUCT\n}\n"], "fixing_code": ["/**\n * @file resolve.c\n * @author Michal Vasko <mvasko@cesnet.cz>\n * @brief libyang resolve functions\n *\n * Copyright (c) 2015 - 2018 CESNET, z.s.p.o.\n *\n * This source code is licensed under BSD 3-Clause License (the \"License\").\n * You may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/BSD-3-Clause\n */\n\n#define _GNU_SOURCE\n\n#include <stdlib.h>\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <limits.h>\n\n#include \"libyang.h\"\n#include \"resolve.h\"\n#include \"common.h\"\n#include \"xpath.h\"\n#include \"parser.h\"\n#include \"parser_yang.h\"\n#include \"xml_internal.h\"\n#include \"hash_table.h\"\n#include \"tree_internal.h\"\n#include \"extensions.h\"\n#include \"validation.h\"\n\n/* internal parsed predicate structure */\nstruct parsed_pred {\n    const struct lys_node *schema;\n    int len;\n    struct {\n        const char *mod_name;\n        int mod_name_len;\n        const char *name;\n        int nam_len;\n        const char *value;\n        int val_len;\n    } *pred;\n};\n\nint\nparse_range_dec64(const char **str_num, uint8_t dig, int64_t *num)\n{\n    const char *ptr;\n    int minus = 0;\n    int64_t ret = 0, prev_ret;\n    int8_t str_exp, str_dig = -1, trailing_zeros = 0;\n\n    ptr = *str_num;\n\n    if (ptr[0] == '-') {\n        minus = 1;\n        ++ptr;\n    } else if (ptr[0] == '+') {\n        ++ptr;\n    }\n\n    if (!isdigit(ptr[0])) {\n        /* there must be at least one */\n        return 1;\n    }\n\n    for (str_exp = 0; isdigit(ptr[0]) || ((ptr[0] == '.') && (str_dig < 0)); ++ptr) {\n        if (str_exp > 18) {\n            return 1;\n        }\n\n        if (ptr[0] == '.') {\n            if (ptr[1] == '.') {\n                /* it's the next interval */\n                break;\n            }\n            ++str_dig;\n        } else {\n            prev_ret = ret;\n            if (minus) {\n                ret = ret * 10 - (ptr[0] - '0');\n                if (ret > prev_ret) {\n                    return 1;\n                }\n            } else {\n                ret = ret * 10 + (ptr[0] - '0');\n                if (ret < prev_ret) {\n                    return 1;\n                }\n            }\n            if (str_dig > -1) {\n                ++str_dig;\n                if (ptr[0] == '0') {\n                    /* possibly trailing zero */\n                    trailing_zeros++;\n                } else {\n                    trailing_zeros = 0;\n                }\n            }\n            ++str_exp;\n        }\n    }\n    if (str_dig == 0) {\n        /* no digits after '.' */\n        return 1;\n    } else if (str_dig == -1) {\n        /* there are 0 numbers after the floating point */\n        str_dig = 0;\n    }\n    /* remove trailing zeros */\n    if (trailing_zeros) {\n        str_dig -= trailing_zeros;\n        str_exp -= trailing_zeros;\n        ret = ret / dec_pow(trailing_zeros);\n    }\n\n    /* it's parsed, now adjust the number based on fraction-digits, if needed */\n    if (str_dig < dig) {\n        if ((str_exp - 1) + (dig - str_dig) > 18) {\n            return 1;\n        }\n        prev_ret = ret;\n        ret *= dec_pow(dig - str_dig);\n        if ((minus && (ret > prev_ret)) || (!minus && (ret < prev_ret))) {\n            return 1;\n        }\n\n    }\n    if (str_dig > dig) {\n        return 1;\n    }\n\n    *str_num = ptr;\n    *num = ret;\n\n    return 0;\n}\n\n/**\n * @brief Parse an identifier.\n *\n * ;; An identifier MUST NOT start with (('X'|'x') ('M'|'m') ('L'|'l'))\n * identifier          = (ALPHA / \"_\")\n *                       *(ALPHA / DIGIT / \"_\" / \"-\" / \".\")\n *\n * @param[in] id Identifier to use.\n *\n * @return Number of characters successfully parsed.\n */\nunsigned int\nparse_identifier(const char *id)\n{\n    unsigned int parsed = 0;\n\n    assert(id);\n\n    if (!isalpha(id[0]) && (id[0] != '_')) {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isalnum(id[0]) || (id[0] == '_') || (id[0] == '-') || (id[0] == '.')) {\n        ++parsed;\n        ++id;\n    }\n\n    return parsed;\n}\n\n/**\n * @brief Parse a node-identifier.\n *\n * node-identifier     = [module-name \":\"] identifier\n *\n * @param[in] id Identifier to use.\n * @param[out] mod_name Points to the module name, NULL if there is not any.\n * @param[out] mod_name_len Length of the module name, 0 if there is not any.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] all_desc Whether the path starts with '/', only supported in extended paths.\n * @param[in] extended Whether to accept an extended path (support for [prefix:]*, /[prefix:]*, /[prefix:]., prefix:#identifier).\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_node_identifier(const char *id, const char **mod_name, int *mod_name_len, const char **name, int *nam_len,\n                      int *all_desc, int extended)\n{\n    int parsed = 0, ret, all_desc_local = 0, first_id_len;\n    const char *first_id;\n\n    assert(id);\n    assert((mod_name && mod_name_len) || (!mod_name && !mod_name_len));\n    assert((name && nam_len) || (!name && !nam_len));\n\n    if (mod_name) {\n        *mod_name = NULL;\n        *mod_name_len = 0;\n    }\n    if (name) {\n        *name = NULL;\n        *nam_len = 0;\n    }\n\n    if (extended) {\n        /* try to parse only the extended expressions */\n        if (id[parsed] == '/') {\n            if (all_desc) {\n                *all_desc = 1;\n            }\n            all_desc_local = 1;\n        } else {\n            if (all_desc) {\n                *all_desc = 0;\n            }\n        }\n\n        /* is there a prefix? */\n        ret = parse_identifier(id + all_desc_local);\n        if (ret > 0) {\n            if (id[all_desc_local + ret] != ':') {\n                /* this is not a prefix, so not an extended id */\n                goto standard_id;\n            }\n\n            if (mod_name) {\n                *mod_name = id + all_desc_local;\n                *mod_name_len = ret;\n            }\n\n            /* \"/\" and \":\" */\n            ret += all_desc_local + 1;\n        } else {\n            ret = all_desc_local;\n        }\n\n        /* parse either \"*\" or \".\" */\n        if (*(id + ret) == '*') {\n            if (name) {\n                *name = id + ret;\n                *nam_len = 1;\n            }\n            ++ret;\n\n            return ret;\n        } else if (*(id + ret) == '.') {\n            if (!all_desc_local) {\n                /* /. is redundant expression, we do not accept it */\n                return -ret;\n            }\n\n            if (name) {\n                *name = id + ret;\n                *nam_len = 1;\n            }\n            ++ret;\n\n            return ret;\n        } else if (*(id + ret) == '#') {\n            if (all_desc_local || !ret) {\n                /* no prefix */\n                return 0;\n            }\n            parsed = ret + 1;\n            if ((ret = parse_identifier(id + parsed)) < 1) {\n                return -parsed + ret;\n            }\n            *name = id + parsed - 1;\n            *nam_len = ret + 1;\n            return parsed + ret;\n        }\n        /* else a standard id, parse it all again */\n    }\n\nstandard_id:\n    if ((ret = parse_identifier(id)) < 1) {\n        return ret;\n    }\n\n    first_id = id;\n    first_id_len = ret;\n\n    parsed += ret;\n    id += ret;\n\n    /* there is prefix */\n    if (id[0] == ':') {\n        ++parsed;\n        ++id;\n\n    /* there isn't */\n    } else {\n        if (name) {\n            *name = first_id;\n            *nam_len = first_id_len;\n        }\n\n        return parsed;\n    }\n\n    /* identifier (node name) */\n    if ((ret = parse_identifier(id)) < 1) {\n        return -parsed + ret;\n    }\n\n    if (mod_name) {\n        *mod_name = first_id;\n        *mod_name_len = first_id_len;\n    }\n    if (name) {\n        *name = id;\n        *nam_len = ret;\n    }\n\n    return parsed + ret;\n}\n\n/**\n * @brief Parse a path-predicate (leafref).\n *\n * path-predicate      = \"[\" *WSP path-equality-expr *WSP \"]\"\n * path-equality-expr  = node-identifier *WSP \"=\" *WSP path-key-expr\n *\n * @param[in] id Identifier to use.\n * @param[out] prefix Points to the prefix, NULL if there is not any.\n * @param[out] pref_len Length of the prefix, 0 if there is not any.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] path_key_expr Points to the path-key-expr.\n * @param[out] pke_len Length of the path-key-expr.\n * @param[out] has_predicate Flag to mark whether there is another predicate following.\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_path_predicate(const char *id, const char **prefix, int *pref_len, const char **name, int *nam_len,\n                     const char **path_key_expr, int *pke_len, int *has_predicate)\n{\n    const char *ptr;\n    int parsed = 0, ret;\n\n    assert(id);\n    if (prefix) {\n        *prefix = NULL;\n    }\n    if (pref_len) {\n        *pref_len = 0;\n    }\n    if (name) {\n        *name = NULL;\n    }\n    if (nam_len) {\n        *nam_len = 0;\n    }\n    if (path_key_expr) {\n        *path_key_expr = NULL;\n    }\n    if (pke_len) {\n        *pke_len = 0;\n    }\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (id[0] != '[') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    if ((ret = parse_node_identifier(id, prefix, pref_len, name, nam_len, NULL, 0)) < 1) {\n        return -parsed+ret;\n    }\n\n    parsed += ret;\n    id += ret;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    if (id[0] != '=') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    if ((ptr = strchr(id, ']')) == NULL) {\n        return -parsed;\n    }\n\n    --ptr;\n    while (isspace(ptr[0])) {\n        --ptr;\n    }\n    ++ptr;\n\n    ret = ptr-id;\n    if (path_key_expr) {\n        *path_key_expr = id;\n    }\n    if (pke_len) {\n        *pke_len = ret;\n    }\n\n    parsed += ret;\n    id += ret;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    assert(id[0] == ']');\n\n    if (id[1] == '[') {\n        *has_predicate = 1;\n    }\n\n    return parsed+1;\n}\n\n/**\n * @brief Parse a path-key-expr (leafref). First call parses \"current()\", all\n *        the \"..\" and the first node-identifier, other calls parse a single\n *        node-identifier each.\n *\n * path-key-expr       = current-function-invocation *WSP \"/\" *WSP\n *                       rel-path-keyexpr\n * rel-path-keyexpr    = 1*(\"..\" *WSP \"/\" *WSP)\n *                       *(node-identifier *WSP \"/\" *WSP)\n *                       node-identifier\n *\n * @param[in] id Identifier to use.\n * @param[out] prefix Points to the prefix, NULL if there is not any.\n * @param[out] pref_len Length of the prefix, 0 if there is not any.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] parent_times Number of \"..\" in the path. Must be 0 on the first call,\n *                          must not be changed between consecutive calls.\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_path_key_expr(const char *id, const char **prefix, int *pref_len, const char **name, int *nam_len,\n                    int *parent_times)\n{\n    int parsed = 0, ret, par_times = 0;\n\n    assert(id);\n    assert(parent_times);\n    if (prefix) {\n        *prefix = NULL;\n    }\n    if (pref_len) {\n        *pref_len = 0;\n    }\n    if (name) {\n        *name = NULL;\n    }\n    if (nam_len) {\n        *nam_len = 0;\n    }\n\n    if (!*parent_times) {\n        /* current-function-invocation *WSP \"/\" *WSP rel-path-keyexpr */\n        if (strncmp(id, \"current()\", 9)) {\n            return -parsed;\n        }\n\n        parsed += 9;\n        id += 9;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        if (id[0] != '/') {\n            return -parsed;\n        }\n\n        ++parsed;\n        ++id;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        /* rel-path-keyexpr */\n        if (strncmp(id, \"..\", 2)) {\n            return -parsed;\n        }\n        ++par_times;\n\n        parsed += 2;\n        id += 2;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n    }\n\n    /* 1*(\"..\" *WSP \"/\" *WSP) *(node-identifier *WSP \"/\" *WSP) node-identifier\n     *\n     * first parent reference with whitespaces already parsed\n     */\n    if (id[0] != '/') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    while (!strncmp(id, \"..\", 2) && !*parent_times) {\n        ++par_times;\n\n        parsed += 2;\n        id += 2;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        if (id[0] != '/') {\n            return -parsed;\n        }\n\n        ++parsed;\n        ++id;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n    }\n\n    if (!*parent_times) {\n        *parent_times = par_times;\n    }\n\n    /* all parent references must be parsed at this point */\n    if ((ret = parse_node_identifier(id, prefix, pref_len, name, nam_len, NULL, 0)) < 1) {\n        return -parsed + ret;\n    }\n\n    parsed += ret;\n    id += ret;\n\n    return parsed;\n}\n\n/**\n * @brief Parse path-arg (leafref).\n *\n * path-arg            = absolute-path / relative-path\n * absolute-path       = 1*(\"/\" (node-identifier *path-predicate))\n * relative-path       = 1*(\"..\" \"/\") descendant-path\n *\n * @param[in] mod Module of the context node to get correct prefix in case it is not explicitly specified\n * @param[in] id Identifier to use.\n * @param[out] prefix Points to the prefix, NULL if there is not any.\n * @param[out] pref_len Length of the prefix, 0 if there is not any.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] parent_times Number of \"..\" in the path. Must be 0 on the first call,\n *                          must not be changed between consecutive calls. -1 if the\n *                          path is relative.\n * @param[out] has_predicate Flag to mark whether there is a predicate specified.\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_path_arg(const struct lys_module *mod, const char *id, const char **prefix, int *pref_len,\n               const char **name, int *nam_len, int *parent_times, int *has_predicate)\n{\n    int parsed = 0, ret, par_times = 0;\n\n    assert(id);\n    assert(parent_times);\n    if (prefix) {\n        *prefix = NULL;\n    }\n    if (pref_len) {\n        *pref_len = 0;\n    }\n    if (name) {\n        *name = NULL;\n    }\n    if (nam_len) {\n        *nam_len = 0;\n    }\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (!*parent_times && !strncmp(id, \"..\", 2)) {\n        ++par_times;\n\n        parsed += 2;\n        id += 2;\n\n        while (!strncmp(id, \"/..\", 3)) {\n            ++par_times;\n\n            parsed += 3;\n            id += 3;\n        }\n    }\n\n    if (!*parent_times) {\n        if (par_times) {\n            *parent_times = par_times;\n        } else {\n            *parent_times = -1;\n        }\n    }\n\n    if (id[0] != '/') {\n        return -parsed;\n    }\n\n    /* skip '/' */\n    ++parsed;\n    ++id;\n\n    /* node-identifier ([prefix:]identifier) */\n    if ((ret = parse_node_identifier(id, prefix, pref_len, name, nam_len, NULL, 0)) < 1) {\n        return -parsed - ret;\n    }\n    if (prefix && !(*prefix)) {\n        /* actually we always need prefix even it is not specified */\n        *prefix = lys_main_module(mod)->name;\n        *pref_len = strlen(*prefix);\n    }\n\n    parsed += ret;\n    id += ret;\n\n    /* there is no predicate */\n    if ((id[0] == '/') || !id[0]) {\n        return parsed;\n    } else if (id[0] != '[') {\n        return -parsed;\n    }\n\n    if (has_predicate) {\n        *has_predicate = 1;\n    }\n\n    return parsed;\n}\n\n/**\n * @brief Parse instance-identifier in JSON data format. That means that prefixes\n *        are actually model names.\n *\n * instance-identifier = 1*(\"/\" (node-identifier *predicate))\n *\n * @param[in] id Identifier to use.\n * @param[out] model Points to the model name.\n * @param[out] mod_len Length of the model name.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] has_predicate Flag to mark whether there is a predicate specified.\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_instance_identifier(const char *id, const char **model, int *mod_len, const char **name, int *nam_len,\n                          int *has_predicate)\n{\n    int parsed = 0, ret;\n\n    assert(id && model && mod_len && name && nam_len);\n\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (id[0] != '/') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    if ((ret = parse_identifier(id)) < 1) {\n        return ret;\n    }\n\n    *name = id;\n    *nam_len = ret;\n\n    parsed += ret;\n    id += ret;\n\n    if (id[0] == ':') {\n        /* we have prefix */\n        *model = *name;\n        *mod_len = *nam_len;\n\n        ++parsed;\n        ++id;\n\n        if ((ret = parse_identifier(id)) < 1) {\n            return ret;\n        }\n\n        *name = id;\n        *nam_len = ret;\n\n        parsed += ret;\n        id += ret;\n    }\n\n    if (id[0] == '[' && has_predicate) {\n        *has_predicate = 1;\n    }\n\n    return parsed;\n}\n\n/**\n * @brief Parse predicate (instance-identifier) in JSON data format. That means that prefixes\n *        (which are mandatory) are actually model names.\n *\n * predicate           = \"[\" *WSP (predicate-expr / pos) *WSP \"]\"\n * predicate-expr      = (node-identifier / \".\") *WSP \"=\" *WSP\n *                       ((DQUOTE string DQUOTE) /\n *                        (SQUOTE string SQUOTE))\n * pos                 = non-negative-integer-value\n *\n * @param[in] id Identifier to use.\n * @param[out] model Points to the model name.\n * @param[out] mod_len Length of the model name.\n * @param[out] name Points to the node name. Can be identifier (from node-identifier), \".\" or pos.\n * @param[out] nam_len Length of the node name.\n * @param[out] value Value the node-identifier must have (string from the grammar),\n *                   NULL if there is not any.\n * @param[out] val_len Length of the value, 0 if there is not any.\n * @param[out] has_predicate Flag to mark whether there is a predicate specified.\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_predicate(const char *id, const char **model, int *mod_len, const char **name, int *nam_len,\n                const char **value, int *val_len, int *has_predicate)\n{\n    const char *ptr;\n    int parsed = 0, ret;\n    char quote;\n\n    assert(id);\n    if (model) {\n        assert(mod_len);\n        *model = NULL;\n        *mod_len = 0;\n    }\n    if (name) {\n        assert(nam_len);\n        *name = NULL;\n        *nam_len = 0;\n    }\n    if (value) {\n        assert(val_len);\n        *value = NULL;\n        *val_len = 0;\n    }\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (id[0] != '[') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    /* pos */\n    if (isdigit(id[0])) {\n        if (name) {\n            *name = id;\n        }\n\n        if (id[0] == '0') {\n            return -parsed;\n        }\n\n        while (isdigit(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        if (nam_len) {\n            *nam_len = id-(*name);\n        }\n\n    /* \".\" or node-identifier */\n    } else {\n        if (id[0] == '.') {\n            if (name) {\n                *name = id;\n            }\n            if (nam_len) {\n                *nam_len = 1;\n            }\n\n            ++parsed;\n            ++id;\n\n        } else {\n            if ((ret = parse_node_identifier(id, model, mod_len, name, nam_len, NULL, 0)) < 1) {\n                return -parsed + ret;\n            }\n\n            parsed += ret;\n            id += ret;\n        }\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        if (id[0] != '=') {\n            return -parsed;\n        }\n\n        ++parsed;\n        ++id;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        /* ((DQUOTE string DQUOTE) / (SQUOTE string SQUOTE)) */\n        if ((id[0] == '\\\"') || (id[0] == '\\'')) {\n            quote = id[0];\n\n            ++parsed;\n            ++id;\n\n            if ((ptr = strchr(id, quote)) == NULL) {\n                return -parsed;\n            }\n            ret = ptr - id;\n\n            if (value) {\n                *value = id;\n            }\n            if (val_len) {\n                *val_len = ret;\n            }\n\n            parsed += ret + 1;\n            id += ret + 1;\n        } else {\n            return -parsed;\n        }\n    }\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    if (id[0] != ']') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    if ((id[0] == '[') && has_predicate) {\n        *has_predicate = 1;\n    }\n\n    return parsed;\n}\n\n/**\n * @brief Parse schema-nodeid.\n *\n * schema-nodeid       = absolute-schema-nodeid /\n *                       descendant-schema-nodeid\n * absolute-schema-nodeid = 1*(\"/\" node-identifier)\n * descendant-schema-nodeid = [\".\" \"/\"]\n *                       node-identifier\n *                       absolute-schema-nodeid\n *\n * @param[in] id Identifier to use.\n * @param[out] mod_name Points to the module name, NULL if there is not any.\n * @param[out] mod_name_len Length of the module name, 0 if there is not any.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] is_relative Flag to mark whether the nodeid is absolute or descendant. Must be -1\n *                         on the first call, must not be changed between consecutive calls.\n * @param[out] has_predicate Flag to mark whether there is a predicate specified. It cannot be\n *                           based on the grammar, in those cases use NULL.\n * @param[in] extended Whether to accept an extended path (support for /[prefix:]*, //[prefix:]*, //[prefix:].).\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nint\nparse_schema_nodeid(const char *id, const char **mod_name, int *mod_name_len, const char **name, int *nam_len,\n                    int *is_relative, int *has_predicate, int *all_desc, int extended)\n{\n    int parsed = 0, ret;\n\n    assert(id);\n    assert(is_relative);\n\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (id[0] != '/') {\n        if (*is_relative != -1) {\n            return -parsed;\n        } else {\n            *is_relative = 1;\n        }\n        if (!strncmp(id, \"./\", 2)) {\n            parsed += 2;\n            id += 2;\n        }\n    } else {\n        if (*is_relative == -1) {\n            *is_relative = 0;\n        }\n        ++parsed;\n        ++id;\n    }\n\n    if ((ret = parse_node_identifier(id, mod_name, mod_name_len, name, nam_len, all_desc, extended)) < 1) {\n        return -parsed + ret;\n    }\n\n    parsed += ret;\n    id += ret;\n\n    if ((id[0] == '[') && has_predicate) {\n        *has_predicate = 1;\n    }\n\n    return parsed;\n}\n\n/**\n * @brief Parse schema predicate (special format internally used).\n *\n * predicate           = \"[\" *WSP predicate-expr *WSP \"]\"\n * predicate-expr      = \".\" / [prefix:]identifier / positive-integer / key-with-value\n * key-with-value      = identifier *WSP \"=\" *WSP\n *                       ((DQUOTE string DQUOTE) /\n *                        (SQUOTE string SQUOTE))\n *\n * @param[in] id Identifier to use.\n * @param[out] mod_name Points to the list key module name.\n * @param[out] mod_name_len Length of \\p mod_name.\n * @param[out] name Points to the list key name.\n * @param[out] nam_len Length of \\p name.\n * @param[out] value Points to the key value. If specified, key-with-value is expected.\n * @param[out] val_len Length of \\p value.\n * @param[out] has_predicate Flag to mark whether there is another predicate specified.\n */\nint\nparse_schema_json_predicate(const char *id, const char **mod_name, int *mod_name_len, const char **name, int *nam_len,\n                            const char **value, int *val_len, int *has_predicate)\n{\n    const char *ptr;\n    int parsed = 0, ret;\n    char quote;\n\n    assert(id);\n    if (mod_name) {\n        *mod_name = NULL;\n    }\n    if (mod_name_len) {\n        *mod_name_len = 0;\n    }\n    if (name) {\n        *name = NULL;\n    }\n    if (nam_len) {\n        *nam_len = 0;\n    }\n    if (value) {\n        *value = NULL;\n    }\n    if (val_len) {\n        *val_len = 0;\n    }\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (id[0] != '[') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    /* identifier */\n    if (id[0] == '.') {\n        ret = 1;\n\n        if (name) {\n            *name = id;\n        }\n        if (nam_len) {\n            *nam_len = ret;\n        }\n    } else if (isdigit(id[0])) {\n        if (id[0] == '0') {\n            return -parsed;\n        }\n        ret = 1;\n        while (isdigit(id[ret])) {\n            ++ret;\n        }\n\n        if (name) {\n            *name = id;\n        }\n        if (nam_len) {\n            *nam_len = ret;\n        }\n    } else if ((ret = parse_node_identifier(id, mod_name, mod_name_len, name, nam_len, NULL, 0)) < 1) {\n        return -parsed + ret;\n    }\n\n    parsed += ret;\n    id += ret;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    /* there is value as well */\n    if (id[0] == '=') {\n        if (name && isdigit(**name)) {\n            return -parsed;\n        }\n\n        ++parsed;\n        ++id;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        /* ((DQUOTE string DQUOTE) / (SQUOTE string SQUOTE)) */\n        if ((id[0] == '\\\"') || (id[0] == '\\'')) {\n            quote = id[0];\n\n            ++parsed;\n            ++id;\n\n            if ((ptr = strchr(id, quote)) == NULL) {\n                return -parsed;\n            }\n            ret = ptr - id;\n\n            if (value) {\n                *value = id;\n            }\n            if (val_len) {\n                *val_len = ret;\n            }\n\n            parsed += ret + 1;\n            id += ret + 1;\n        } else {\n            return -parsed;\n        }\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n    }\n\n    if (id[0] != ']') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    if ((id[0] == '[') && has_predicate) {\n        *has_predicate = 1;\n    }\n\n    return parsed;\n}\n\n#ifdef LY_ENABLED_CACHE\n\nstatic int\nresolve_hash_table_find_equal(void *val1_p, void *val2_p, int mod, void *UNUSED(cb_data))\n{\n    struct lyd_node *val2, *elem2;\n    struct parsed_pred pp;\n    const char *str;\n    int i;\n\n    assert(!mod);\n    (void)mod;\n\n    pp = *((struct parsed_pred *)val1_p);\n    val2 = *((struct lyd_node **)val2_p);\n\n    if (val2->schema != pp.schema) {\n        return 0;\n    }\n\n    switch (val2->schema->nodetype) {\n    case LYS_CONTAINER:\n    case LYS_LEAF:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        return 1;\n    case LYS_LEAFLIST:\n        str = ((struct lyd_node_leaf_list *)val2)->value_str;\n        if (!strncmp(str, pp.pred[0].value, pp.pred[0].val_len) && !str[pp.pred[0].val_len]) {\n            return 1;\n        }\n        return 0;\n    case LYS_LIST:\n        assert(((struct lys_node_list *)val2->schema)->keys_size);\n        assert(((struct lys_node_list *)val2->schema)->keys_size == pp.len);\n\n        /* lists with keys, their equivalence is based on their keys */\n        elem2 = val2->child;\n        /* the exact data order is guaranteed */\n        for (i = 0; elem2 && (i < pp.len); ++i) {\n            /* module check */\n            if (pp.pred[i].mod_name) {\n                if (strncmp(lyd_node_module(elem2)->name, pp.pred[i].mod_name, pp.pred[i].mod_name_len)\n                        || lyd_node_module(elem2)->name[pp.pred[i].mod_name_len]) {\n                    break;\n                }\n            } else {\n                if (lyd_node_module(elem2) != lys_node_module(pp.schema)) {\n                    break;\n                }\n            }\n\n            /* name check */\n            if (strncmp(elem2->schema->name, pp.pred[i].name, pp.pred[i].nam_len) || elem2->schema->name[pp.pred[i].nam_len]) {\n                break;\n            }\n\n            /* value check */\n            str = ((struct lyd_node_leaf_list *)elem2)->value_str;\n            if (strncmp(str, pp.pred[i].value, pp.pred[i].val_len) || str[pp.pred[i].val_len]) {\n                break;\n            }\n\n            /* next key */\n            elem2 = elem2->next;\n        }\n        if (i == pp.len) {\n            return 1;\n        }\n        return 0;\n    default:\n        break;\n    }\n\n    LOGINT(val2->schema->module->ctx);\n    return 0;\n}\n\nstatic struct lyd_node *\nresolve_json_data_node_hash(struct lyd_node *parent, struct parsed_pred pp)\n{\n    values_equal_cb prev_cb;\n    struct lyd_node **ret = NULL;\n    uint32_t hash;\n    int i;\n\n    assert(parent && parent->hash);\n\n    /* set our value equivalence callback that does not require data nodes */\n    prev_cb = lyht_set_cb(parent->ht, resolve_hash_table_find_equal);\n\n    /* get the hash of the searched node */\n    hash = dict_hash_multi(0, lys_node_module(pp.schema)->name, strlen(lys_node_module(pp.schema)->name));\n    hash = dict_hash_multi(hash, pp.schema->name, strlen(pp.schema->name));\n    if (pp.schema->nodetype == LYS_LEAFLIST) {\n        assert((pp.len == 1) && (pp.pred[0].name[0] == '.') && (pp.pred[0].nam_len == 1));\n        /* leaf-list value in predicate */\n        hash = dict_hash_multi(hash, pp.pred[0].value, pp.pred[0].val_len);\n    } else if (pp.schema->nodetype == LYS_LIST) {\n        /* list keys in predicates */\n        for (i = 0; i < pp.len; ++i) {\n            hash = dict_hash_multi(hash, pp.pred[i].value, pp.pred[i].val_len);\n        }\n    }\n    hash = dict_hash_multi(hash, NULL, 0);\n\n    /* try to find the node */\n    i = lyht_find(parent->ht, &pp, hash, (void **)&ret);\n    assert(i || *ret);\n\n    /* restore the original callback */\n    lyht_set_cb(parent->ht, prev_cb);\n\n    return (i ? NULL : *ret);\n}\n\n#endif\n\n/**\n * @brief Resolve (find) a feature definition. Logs directly.\n *\n * @param[in] feat_name Feature name to resolve.\n * @param[in] len Length of \\p feat_name.\n * @param[in] node Node with the if-feature expression.\n * @param[out] feature Pointer to be set to point to the feature definition, if feature not found\n * (return code 1), the pointer is untouched.\n *\n * @return 0 on success, 1 on forward reference, -1 on error.\n */\nstatic int\nresolve_feature(const char *feat_name, uint16_t len, const struct lys_node *node, struct lys_feature **feature)\n{\n    char *str;\n    const char *mod_name, *name;\n    int mod_name_len, nam_len, i, j;\n    const struct lys_module *module;\n\n    assert(feature);\n\n    /* check prefix */\n    if ((i = parse_node_identifier(feat_name, &mod_name, &mod_name_len, &name, &nam_len, NULL, 0)) < 1) {\n        LOGVAL(node->module->ctx, LYE_INCHAR, LY_VLOG_NONE, NULL, feat_name[-i], &feat_name[-i]);\n        return -1;\n    }\n\n    module = lyp_get_module(lys_node_module(node), NULL, 0, mod_name, mod_name_len, 0);\n    if (!module) {\n        /* identity refers unknown data model */\n        LOGVAL(node->module->ctx, LYE_INMOD_LEN, LY_VLOG_NONE, NULL, mod_name_len, mod_name);\n        return -1;\n    }\n\n    if (module != node->module && module == lys_node_module(node)) {\n        /* first, try to search directly in submodule where the feature was mentioned */\n        for (j = 0; j < node->module->features_size; j++) {\n            if (!strncmp(name, node->module->features[j].name, nam_len) && !node->module->features[j].name[nam_len]) {\n                /* check status */\n                if (lyp_check_status(node->flags, lys_node_module(node), node->name, node->module->features[j].flags,\n                                     node->module->features[j].module, node->module->features[j].name, NULL)) {\n                    return -1;\n                }\n                *feature = &node->module->features[j];\n                return 0;\n            }\n        }\n    }\n\n    /* search in the identified module ... */\n    for (j = 0; j < module->features_size; j++) {\n        if (!strncmp(name, module->features[j].name, nam_len) && !module->features[j].name[nam_len]) {\n            /* check status */\n            if (lyp_check_status(node->flags, lys_node_module(node), node->name, module->features[j].flags,\n                                 module->features[j].module, module->features[j].name, NULL)) {\n                return -1;\n            }\n            *feature = &module->features[j];\n            return 0;\n        }\n    }\n    /* ... and all its submodules */\n    for (i = 0; i < module->inc_size && module->inc[i].submodule; i++) {\n        for (j = 0; j < module->inc[i].submodule->features_size; j++) {\n            if (!strncmp(name, module->inc[i].submodule->features[j].name, nam_len)\n                    && !module->inc[i].submodule->features[j].name[nam_len]) {\n                /* check status */\n                if (lyp_check_status(node->flags, lys_node_module(node), node->name,\n                                     module->inc[i].submodule->features[j].flags,\n                                     module->inc[i].submodule->features[j].module,\n                                     module->inc[i].submodule->features[j].name, NULL)) {\n                    return -1;\n                }\n                *feature = &module->inc[i].submodule->features[j];\n                return 0;\n            }\n        }\n    }\n\n    /* not found */\n    str = strndup(feat_name, len);\n    LOGVAL(node->module->ctx, LYE_INRESOLV, LY_VLOG_NONE, NULL, \"feature\", str);\n    free(str);\n    return 1;\n}\n\n/*\n * @return\n *  -  1 if enabled\n *  -  0 if disabled\n */\nstatic int\nresolve_feature_value(const struct lys_feature *feat)\n{\n    int i;\n\n    for (i = 0; i < feat->iffeature_size; i++) {\n        if (!resolve_iffeature(&feat->iffeature[i])) {\n            return 0;\n        }\n    }\n\n    return feat->flags & LYS_FENABLED ? 1 : 0;\n}\n\nstatic int\nresolve_iffeature_recursive(struct lys_iffeature *expr, int *index_e, int *index_f)\n{\n    uint8_t op;\n    int a, b;\n\n    op = iff_getop(expr->expr, *index_e);\n    (*index_e)++;\n\n    switch (op) {\n    case LYS_IFF_F:\n        /* resolve feature */\n        return resolve_feature_value(expr->features[(*index_f)++]);\n    case LYS_IFF_NOT:\n        /* invert result */\n        return resolve_iffeature_recursive(expr, index_e, index_f) ? 0 : 1;\n    case LYS_IFF_AND:\n    case LYS_IFF_OR:\n        a = resolve_iffeature_recursive(expr, index_e, index_f);\n        b = resolve_iffeature_recursive(expr, index_e, index_f);\n        if (op == LYS_IFF_AND) {\n            return a && b;\n        } else { /* LYS_IFF_OR */\n            return a || b;\n        }\n    }\n\n    return 0;\n}\n\nint\nresolve_iffeature(struct lys_iffeature *expr)\n{\n    int index_e = 0, index_f = 0;\n\n    if (expr->expr) {\n        return resolve_iffeature_recursive(expr, &index_e, &index_f);\n    }\n    return 0;\n}\n\nstruct iff_stack {\n    int size;\n    int index;     /* first empty item */\n    uint8_t *stack;\n};\n\nstatic int\niff_stack_push(struct iff_stack *stack, uint8_t value)\n{\n    if (stack->index == stack->size) {\n        stack->size += 4;\n        stack->stack = ly_realloc(stack->stack, stack->size * sizeof *stack->stack);\n        LY_CHECK_ERR_RETURN(!stack->stack, LOGMEM(NULL); stack->size = 0, EXIT_FAILURE);\n    }\n\n    stack->stack[stack->index++] = value;\n    return EXIT_SUCCESS;\n}\n\nstatic uint8_t\niff_stack_pop(struct iff_stack *stack)\n{\n    stack->index--;\n    return stack->stack[stack->index];\n}\n\nstatic void\niff_stack_clean(struct iff_stack *stack)\n{\n    stack->size = 0;\n    free(stack->stack);\n}\n\nstatic void\niff_setop(uint8_t *list, uint8_t op, int pos)\n{\n    uint8_t *item;\n    uint8_t mask = 3;\n\n    assert(pos >= 0);\n    assert(op <= 3); /* max 2 bits */\n\n    item = &list[pos / 4];\n    mask = mask << 2 * (pos % 4);\n    *item = (*item) & ~mask;\n    *item = (*item) | (op << 2 * (pos % 4));\n}\n\nuint8_t\niff_getop(uint8_t *list, int pos)\n{\n    uint8_t *item;\n    uint8_t mask = 3, result;\n\n    assert(pos >= 0);\n\n    item = &list[pos / 4];\n    result = (*item) & (mask << 2 * (pos % 4));\n    return result >> 2 * (pos % 4);\n}\n\n#define LYS_IFF_LP 0x04 /* ( */\n#define LYS_IFF_RP 0x08 /* ) */\n\n/* internal structure for passing data for UNRES_IFFEAT */\nstruct unres_iffeat_data {\n    struct lys_node *node;\n    const char *fname;\n    int infeature;\n};\n\nvoid\nresolve_iffeature_getsizes(struct lys_iffeature *iffeat, unsigned int *expr_size, unsigned int *feat_size)\n{\n    unsigned int e = 0, f = 0, r = 0;\n    uint8_t op;\n\n    assert(iffeat);\n\n    if (!iffeat->expr) {\n        goto result;\n    }\n\n    do {\n        op = iff_getop(iffeat->expr, e++);\n        switch (op) {\n        case LYS_IFF_NOT:\n            if (!r) {\n                r += 1;\n            }\n            break;\n        case LYS_IFF_AND:\n        case LYS_IFF_OR:\n            if (!r) {\n                r += 2;\n            } else {\n                r += 1;\n            }\n            break;\n        case LYS_IFF_F:\n            f++;\n            if (r) {\n                r--;\n            }\n            break;\n        }\n    } while(r);\n\nresult:\n    if (expr_size) {\n        *expr_size = e;\n    }\n    if (feat_size) {\n        *feat_size = f;\n    }\n}\n\nint\nresolve_iffeature_compile(struct lys_iffeature *iffeat_expr, const char *value, struct lys_node *node,\n                          int infeature, struct unres_schema *unres)\n{\n    const char *c = value;\n    int r, rc = EXIT_FAILURE;\n    int i, j, last_not, checkversion = 0;\n    unsigned int f_size = 0, expr_size = 0, f_exp = 1;\n    uint8_t op;\n    struct iff_stack stack = {0, 0, NULL};\n    struct unres_iffeat_data *iff_data;\n    struct ly_ctx *ctx = node->module->ctx;\n\n    assert(c);\n\n    if (isspace(c[0])) {\n        LOGVAL(ctx, LYE_INCHAR, LY_VLOG_NONE, NULL, c[0], c);\n        return EXIT_FAILURE;\n    }\n\n    /* pre-parse the expression to get sizes for arrays, also do some syntax checks of the expression */\n    for (i = j = last_not = 0; c[i]; i++) {\n        if (c[i] == '(') {\n            checkversion = 1;\n            j++;\n            continue;\n        } else if (c[i] == ')') {\n            j--;\n            continue;\n        } else if (isspace(c[i])) {\n            continue;\n        }\n\n        if (!strncmp(&c[i], \"not\", r = 3) || !strncmp(&c[i], \"and\", r = 3) || !strncmp(&c[i], \"or\", r = 2)) {\n            if (c[i + r] == '\\0') {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"if-feature\");\n                return EXIT_FAILURE;\n            } else if (!isspace(c[i + r])) {\n                /* feature name starting with the not/and/or */\n                last_not = 0;\n                f_size++;\n            } else if (c[i] == 'n') { /* not operation */\n                if (last_not) {\n                    /* double not */\n                    expr_size = expr_size - 2;\n                    last_not = 0;\n                } else {\n                    last_not = 1;\n                }\n            } else { /* and, or */\n                f_exp++;\n                /* not a not operation */\n                last_not = 0;\n            }\n            i += r;\n        } else {\n            f_size++;\n            last_not = 0;\n        }\n        expr_size++;\n\n        while (!isspace(c[i])) {\n            if (!c[i] || c[i] == ')') {\n                i--;\n                break;\n            }\n            i++;\n        }\n    }\n    if (j || f_exp != f_size) {\n        /* not matching count of ( and ) */\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"if-feature\");\n        return EXIT_FAILURE;\n    }\n\n    if (checkversion || expr_size > 1) {\n        /* check that we have 1.1 module */\n        if (node->module->version != LYS_VERSION_1_1) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"if-feature\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"YANG 1.1 if-feature expression found in 1.0 module.\");\n            return EXIT_FAILURE;\n        }\n    }\n\n    /* allocate the memory */\n    iffeat_expr->expr = calloc((j = (expr_size / 4) + ((expr_size % 4) ? 1 : 0)), sizeof *iffeat_expr->expr);\n    iffeat_expr->features = calloc(f_size, sizeof *iffeat_expr->features);\n    stack.stack = malloc(expr_size * sizeof *stack.stack);\n    LY_CHECK_ERR_GOTO(!stack.stack || !iffeat_expr->expr || !iffeat_expr->features, LOGMEM(ctx), error);\n    stack.size = expr_size;\n    f_size--; expr_size--; /* used as indexes from now */\n\n    for (i--; i >= 0; i--) {\n        if (c[i] == ')') {\n            /* push it on stack */\n            iff_stack_push(&stack, LYS_IFF_RP);\n            continue;\n        } else if (c[i] == '(') {\n            /* pop from the stack into result all operators until ) */\n            while((op = iff_stack_pop(&stack)) != LYS_IFF_RP) {\n                iff_setop(iffeat_expr->expr, op, expr_size--);\n            }\n            continue;\n        } else if (isspace(c[i])) {\n            continue;\n        }\n\n        /* end operator or operand -> find beginning and get what is it */\n        j = i + 1;\n        while (i >= 0 && !isspace(c[i]) && c[i] != '(') {\n            i--;\n        }\n        i++; /* get back by one step */\n\n        if (!strncmp(&c[i], \"not\", 3) && isspace(c[i + 3])) {\n            if (stack.index && stack.stack[stack.index - 1] == LYS_IFF_NOT) {\n                /* double not */\n                iff_stack_pop(&stack);\n            } else {\n                /* not has the highest priority, so do not pop from the stack\n                 * as in case of AND and OR */\n                iff_stack_push(&stack, LYS_IFF_NOT);\n            }\n        } else if (!strncmp(&c[i], \"and\", 3) && isspace(c[i + 3])) {\n            /* as for OR - pop from the stack all operators with the same or higher\n             * priority and store them to the result, then push the AND to the stack */\n            while (stack.index && stack.stack[stack.index - 1] <= LYS_IFF_AND) {\n                op = iff_stack_pop(&stack);\n                iff_setop(iffeat_expr->expr, op, expr_size--);\n            }\n            iff_stack_push(&stack, LYS_IFF_AND);\n        } else if (!strncmp(&c[i], \"or\", 2) && isspace(c[i + 2])) {\n            while (stack.index && stack.stack[stack.index - 1] <= LYS_IFF_OR) {\n                op = iff_stack_pop(&stack);\n                iff_setop(iffeat_expr->expr, op, expr_size--);\n            }\n            iff_stack_push(&stack, LYS_IFF_OR);\n        } else {\n            /* feature name, length is j - i */\n\n            /* add it to the result */\n            iff_setop(iffeat_expr->expr, LYS_IFF_F, expr_size--);\n\n            /* now get the link to the feature definition. Since it can be\n             * forward referenced, we have to keep the feature name in auxiliary\n             * structure passed into unres */\n            iff_data = malloc(sizeof *iff_data);\n            LY_CHECK_ERR_GOTO(!iff_data, LOGMEM(ctx), error);\n            iff_data->node = node;\n            iff_data->fname = lydict_insert(node->module->ctx, &c[i], j - i);\n            iff_data->infeature = infeature;\n            r = unres_schema_add_node(node->module, unres, &iffeat_expr->features[f_size], UNRES_IFFEAT,\n                                      (struct lys_node *)iff_data);\n            f_size--;\n\n            if (r == -1) {\n                lydict_remove(node->module->ctx, iff_data->fname);\n                free(iff_data);\n                goto error;\n            }\n        }\n    }\n    while (stack.index) {\n        op = iff_stack_pop(&stack);\n        iff_setop(iffeat_expr->expr, op, expr_size--);\n    }\n\n    if (++expr_size || ++f_size) {\n        /* not all expected operators and operands found */\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"if-feature\");\n        rc = EXIT_FAILURE;\n    } else {\n        rc = EXIT_SUCCESS;\n    }\n\nerror:\n    /* cleanup */\n    iff_stack_clean(&stack);\n\n    return rc;\n}\n\n/**\n * @brief Resolve (find) a data node based on a schema-nodeid.\n *\n * Used for resolving unique statements - so id is expected to be relative and local (without reference to a different\n * module).\n *\n */\nstruct lyd_node *\nresolve_data_descendant_schema_nodeid(const char *nodeid, struct lyd_node *start)\n{\n    char *str, *token, *p;\n    struct lyd_node *result = NULL, *iter;\n    const struct lys_node *schema = NULL;\n\n    assert(nodeid && start);\n\n    if (nodeid[0] == '/') {\n        return NULL;\n    }\n\n    str = p = strdup(nodeid);\n    LY_CHECK_ERR_RETURN(!str, LOGMEM(start->schema->module->ctx), NULL);\n\n    while (p) {\n        token = p;\n        p = strchr(p, '/');\n        if (p) {\n            *p = '\\0';\n            p++;\n        }\n\n        if (p) {\n            /* inner node */\n            if (resolve_descendant_schema_nodeid(token, schema ? schema->child : start->schema,\n                                                 LYS_CONTAINER | LYS_CHOICE | LYS_CASE | LYS_LEAF, 0, &schema)\n                    || !schema) {\n                result = NULL;\n                break;\n            }\n\n            if (schema->nodetype & (LYS_CHOICE | LYS_CASE)) {\n                continue;\n            }\n        } else {\n            /* final node */\n            if (resolve_descendant_schema_nodeid(token, schema ? schema->child : start->schema, LYS_LEAF, 0, &schema)\n                    || !schema) {\n                result = NULL;\n                break;\n            }\n        }\n        LY_TREE_FOR(result ? result->child : start, iter) {\n            if (iter->schema == schema) {\n                /* move in data tree according to returned schema */\n                result = iter;\n                break;\n            }\n        }\n        if (!iter) {\n            /* instance not found */\n            result = NULL;\n            break;\n        }\n    }\n    free(str);\n\n    return result;\n}\n\nint\nschema_nodeid_siblingcheck(const struct lys_node *sibling, const struct lys_module *cur_module, const char *mod_name,\n                           int mod_name_len, const char *name, int nam_len)\n{\n    const struct lys_module *prefix_mod;\n\n    /* handle special names */\n    if (name[0] == '*') {\n        return 2;\n    } else if (name[0] == '.') {\n        return 3;\n    }\n\n    /* name check */\n    if (strncmp(name, sibling->name, nam_len) || sibling->name[nam_len]) {\n        return 1;\n    }\n\n    /* module check */\n    if (mod_name) {\n        prefix_mod = lyp_get_module(cur_module, NULL, 0, mod_name, mod_name_len, 0);\n        if (!prefix_mod) {\n            return -1;\n        }\n    } else {\n        prefix_mod = cur_module;\n    }\n    if (prefix_mod != lys_node_module(sibling)) {\n        return 1;\n    }\n\n    /* match */\n    return 0;\n}\n\n/* keys do not have to be ordered and do not have to be all of them */\nstatic int\nresolve_extended_schema_nodeid_predicate(const char *nodeid, const struct lys_node *node,\n                                         const struct lys_module *cur_module, int *nodeid_end)\n{\n    int mod_len, nam_len, has_predicate, r, i;\n    const char *model, *name;\n    struct lys_node_list *list;\n\n    if (!(node->nodetype & (LYS_LIST | LYS_LEAFLIST))) {\n        return 1;\n    }\n\n    list = (struct lys_node_list *)node;\n    do {\n        r = parse_schema_json_predicate(nodeid, &model, &mod_len, &name, &nam_len, NULL, NULL, &has_predicate);\n        if (r < 1) {\n            LOGVAL(cur_module->ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, nodeid[r], &nodeid[r]);\n            return -1;\n        }\n        nodeid += r;\n\n        if (node->nodetype == LYS_LEAFLIST) {\n            /* just check syntax */\n            if (model || !name || (name[0] != '.') || has_predicate) {\n                return 1;\n            }\n            break;\n        } else {\n            /* check the key */\n            for (i = 0; i < list->keys_size; ++i) {\n                if (strncmp(list->keys[i]->name, name, nam_len) || list->keys[i]->name[nam_len]) {\n                    continue;\n                }\n                if (model) {\n                    if (strncmp(lys_node_module((struct lys_node *)list->keys[i])->name, model, mod_len)\n                            || lys_node_module((struct lys_node *)list->keys[i])->name[mod_len]) {\n                        continue;\n                    }\n                } else {\n                    if (lys_node_module((struct lys_node *)list->keys[i]) != cur_module) {\n                        continue;\n                    }\n                }\n\n                /* match */\n                break;\n            }\n\n            if (i == list->keys_size) {\n                return 1;\n            }\n        }\n    } while (has_predicate);\n\n    if (!nodeid[0]) {\n        *nodeid_end = 1;\n    }\n    return 0;\n}\n\n/* start_parent - relative, module - absolute, -1 error (logged), EXIT_SUCCESS ok\n */\nint\nresolve_schema_nodeid(const char *nodeid, const struct lys_node *start_parent, const struct lys_module *cur_module,\n                      struct ly_set **ret, int extended, int no_node_error)\n{\n    const char *name, *mod_name, *id, *backup_mod_name = NULL, *yang_data_name = NULL;\n    const struct lys_node *sibling, *next, *elem;\n    struct lys_node_augment *last_aug;\n    int r, nam_len, mod_name_len = 0, is_relative = -1, all_desc, has_predicate, nodeid_end = 0;\n    int yang_data_name_len, backup_mod_name_len = 0;\n    /* resolved import module from the start module, it must match the next node-name-match sibling */\n    const struct lys_module *start_mod, *aux_mod = NULL;\n    char *str;\n    struct ly_ctx *ctx;\n\n    assert(nodeid && (start_parent || cur_module) && ret);\n    *ret = NULL;\n\n    if (!cur_module) {\n        cur_module = lys_node_module(start_parent);\n    }\n    ctx = cur_module->ctx;\n    id = nodeid;\n\n    r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 1);\n    if (r < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[r], &id[r]);\n        return -1;\n    }\n\n    if (name[0] == '#') {\n        if (is_relative) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, '#', name);\n            return -1;\n        }\n        yang_data_name = name + 1;\n        yang_data_name_len = nam_len - 1;\n        backup_mod_name = mod_name;\n        backup_mod_name_len = mod_name_len;\n        id += r;\n    } else {\n        is_relative = -1;\n    }\n\n    r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate,\n                            (extended ? &all_desc : NULL), extended);\n    if (r < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[r], &id[r]);\n        return -1;\n    }\n    id += r;\n\n    if (backup_mod_name) {\n        mod_name = backup_mod_name;\n        mod_name_len = backup_mod_name_len;\n    }\n\n    if (is_relative && !start_parent) {\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_STR, nodeid, \"Starting node must be provided for relative paths.\");\n        return -1;\n    }\n\n    /* descendant-schema-nodeid */\n    if (is_relative) {\n        cur_module = start_mod = lys_node_module(start_parent);\n\n    /* absolute-schema-nodeid */\n    } else {\n        start_mod = lyp_get_module(cur_module, NULL, 0, mod_name, mod_name_len, 0);\n        if (!start_mod) {\n            str = strndup(mod_name, mod_name_len);\n            LOGVAL(ctx, LYE_PATH_INMOD, LY_VLOG_STR, str);\n            free(str);\n            return -1;\n        }\n        start_parent = NULL;\n        if (yang_data_name) {\n            start_parent = lyp_get_yang_data_template(start_mod, yang_data_name, yang_data_name_len);\n            if (!start_parent) {\n                str = strndup(nodeid, (yang_data_name + yang_data_name_len) - nodeid);\n                LOGVAL(ctx, LYE_PATH_INNODE, LY_VLOG_STR, str);\n                free(str);\n                return -1;\n            }\n        }\n    }\n\n    while (1) {\n        sibling = NULL;\n        last_aug = NULL;\n\n        if (start_parent) {\n            if (mod_name && (strncmp(mod_name, cur_module->name, mod_name_len)\n                    || (mod_name_len != (signed)strlen(cur_module->name)))) {\n                /* we are getting into another module (augment) */\n                aux_mod = lyp_get_module(cur_module, NULL, 0, mod_name, mod_name_len, 0);\n                if (!aux_mod) {\n                    str = strndup(mod_name, mod_name_len);\n                    LOGVAL(ctx, LYE_PATH_INMOD, LY_VLOG_STR, str);\n                    free(str);\n                    return -1;\n                }\n            } else {\n                /* there is no mod_name, so why are we checking augments again?\n                 * because this module may be not implemented and it augments something in another module and\n                 * there is another augment augmenting that previous one */\n                aux_mod = cur_module;\n            }\n\n            /* look into augments */\n            if (!extended) {\nget_next_augment:\n                last_aug = lys_getnext_target_aug(last_aug, aux_mod, start_parent);\n            }\n        }\n\n        while ((sibling = lys_getnext(sibling, (last_aug ? (struct lys_node *)last_aug : start_parent), start_mod,\n                LYS_GETNEXT_WITHCHOICE | LYS_GETNEXT_WITHCASE | LYS_GETNEXT_WITHINOUT | LYS_GETNEXT_PARENTUSES | LYS_GETNEXT_NOSTATECHECK))) {\n            r = schema_nodeid_siblingcheck(sibling, cur_module, mod_name, mod_name_len, name, nam_len);\n\n            /* resolve predicate */\n            if (extended && ((r == 0) || (r == 2) || (r == 3)) && has_predicate) {\n                r = resolve_extended_schema_nodeid_predicate(id, sibling, cur_module, &nodeid_end);\n                if (r == 1) {\n                    continue;\n                } else if (r == -1) {\n                    return -1;\n                }\n            } else if (!id[0]) {\n                nodeid_end = 1;\n            }\n\n            if (r == 0) {\n                /* one matching result */\n                if (nodeid_end) {\n                    *ret = ly_set_new();\n                    LY_CHECK_ERR_RETURN(!*ret, LOGMEM(ctx), -1);\n                    ly_set_add(*ret, (void *)sibling, LY_SET_OPT_USEASLIST);\n                } else {\n                    if (sibling->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                        return -1;\n                    }\n                    start_parent = sibling;\n                }\n                break;\n            } else if (r == 1) {\n                continue;\n            } else if (r == 2) {\n                /* \"*\" */\n                if (!*ret) {\n                    *ret = ly_set_new();\n                    LY_CHECK_ERR_RETURN(!*ret, LOGMEM(ctx), -1);\n                }\n                ly_set_add(*ret, (void *)sibling, LY_SET_OPT_USEASLIST);\n                if (all_desc) {\n                    LY_TREE_DFS_BEGIN(sibling, next, elem) {\n                        if (elem != sibling) {\n                            ly_set_add(*ret, (void *)elem, LY_SET_OPT_USEASLIST);\n                        }\n\n                        LY_TREE_DFS_END(sibling, next, elem);\n                    }\n                }\n            } else if (r == 3) {\n                /* \".\" */\n                if (!*ret) {\n                    *ret = ly_set_new();\n                    LY_CHECK_ERR_RETURN(!*ret, LOGMEM(ctx), -1);\n                    ly_set_add(*ret, (void *)start_parent, LY_SET_OPT_USEASLIST);\n                }\n                ly_set_add(*ret, (void *)sibling, LY_SET_OPT_USEASLIST);\n                if (all_desc) {\n                    LY_TREE_DFS_BEGIN(sibling, next, elem) {\n                        if (elem != sibling) {\n                            ly_set_add(*ret, (void *)elem, LY_SET_OPT_USEASLIST);\n                        }\n\n                        LY_TREE_DFS_END(sibling, next, elem);\n                    }\n                }\n            } else {\n                LOGINT(ctx);\n                return -1;\n            }\n        }\n\n        /* skip predicate */\n        if (extended && has_predicate) {\n            while (id[0] == '[') {\n                id = strchr(id, ']');\n                if (!id) {\n                    LOGINT(ctx);\n                    return -1;\n                }\n                ++id;\n            }\n        }\n\n        if (nodeid_end && ((r == 0) || (r == 2) || (r == 3))) {\n            return EXIT_SUCCESS;\n        }\n\n        /* no match */\n        if (!sibling) {\n            if (last_aug) {\n                /* it still could be in another augment */\n                goto get_next_augment;\n            }\n            if (no_node_error) {\n                str = strndup(nodeid, (name - nodeid) + nam_len);\n                LOGVAL(ctx, LYE_PATH_INNODE, LY_VLOG_STR, str);\n                free(str);\n                return -1;\n            }\n            *ret = NULL;\n            return EXIT_SUCCESS;\n        }\n\n        r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate,\n                                (extended ? &all_desc : NULL), extended);\n        if (r < 1) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[r], &id[r]);\n            return -1;\n        }\n        id += r;\n    }\n\n    /* cannot get here */\n    LOGINT(ctx);\n    return -1;\n}\n\n/* unique, refine,\n * >0  - unexpected char on position (ret - 1),\n *  0  - ok (but ret can still be NULL),\n * -1  - error,\n * -2  - violated no_innerlist  */\nint\nresolve_descendant_schema_nodeid(const char *nodeid, const struct lys_node *start, int ret_nodetype,\n                                 int no_innerlist, const struct lys_node **ret)\n{\n    const char *name, *mod_name, *id;\n    const struct lys_node *sibling, *start_parent;\n    int r, nam_len, mod_name_len, is_relative = -1;\n    /* resolved import module from the start module, it must match the next node-name-match sibling */\n    const struct lys_module *module;\n\n    assert(nodeid && ret);\n    assert(!(ret_nodetype & (LYS_USES | LYS_AUGMENT | LYS_GROUPING)));\n\n    if (!start) {\n        /* leaf not found */\n        return 0;\n    }\n\n    id = nodeid;\n    module = lys_node_module(start);\n\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 0)) < 1) {\n        return ((id - nodeid) - r) + 1;\n    }\n    id += r;\n\n    if (!is_relative) {\n        return -1;\n    }\n\n    start_parent = lys_parent(start);\n    while ((start_parent->nodetype == LYS_USES) && lys_parent(start_parent)) {\n        start_parent = lys_parent(start_parent);\n    }\n\n    while (1) {\n        sibling = NULL;\n        while ((sibling = lys_getnext(sibling, start_parent, module,\n                LYS_GETNEXT_WITHCHOICE | LYS_GETNEXT_WITHCASE | LYS_GETNEXT_PARENTUSES | LYS_GETNEXT_NOSTATECHECK))) {\n            r = schema_nodeid_siblingcheck(sibling, module, mod_name, mod_name_len, name, nam_len);\n            if (r == 0) {\n                if (!id[0]) {\n                    if (!(sibling->nodetype & ret_nodetype)) {\n                        /* wrong node type, too bad */\n                        continue;\n                    }\n                    *ret = sibling;\n                    return EXIT_SUCCESS;\n                }\n                start_parent = sibling;\n                break;\n            } else if (r == 1) {\n                continue;\n            } else {\n                return -1;\n            }\n        }\n\n        /* no match */\n        if (!sibling) {\n            *ret = NULL;\n            return EXIT_SUCCESS;\n        } else if (no_innerlist && sibling->nodetype == LYS_LIST) {\n            *ret = NULL;\n            return -2;\n        }\n\n        if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 0)) < 1) {\n            return ((id - nodeid) - r) + 1;\n        }\n        id += r;\n    }\n\n    /* cannot get here */\n    LOGINT(module->ctx);\n    return -1;\n}\n\n/* choice default */\nint\nresolve_choice_default_schema_nodeid(const char *nodeid, const struct lys_node *start, const struct lys_node **ret)\n{\n    /* cannot actually be a path */\n    if (strchr(nodeid, '/')) {\n        return -1;\n    }\n\n    return resolve_descendant_schema_nodeid(nodeid, start, LYS_NO_RPC_NOTIF_NODE, 0, ret);\n}\n\n/* uses, -1 error, EXIT_SUCCESS ok (but ret can still be NULL), >0 unexpected char on ret - 1 */\nstatic int\nresolve_uses_schema_nodeid(const char *nodeid, const struct lys_node *start, const struct lys_node_grp **ret)\n{\n    const struct lys_module *module;\n    const char *mod_prefix, *name;\n    int i, mod_prefix_len, nam_len;\n\n    /* parse the identifier, it must be parsed on one call */\n    if (((i = parse_node_identifier(nodeid, &mod_prefix, &mod_prefix_len, &name, &nam_len, NULL, 0)) < 1) || nodeid[i]) {\n        return -i + 1;\n    }\n\n    module = lyp_get_module(start->module, mod_prefix, mod_prefix_len, NULL, 0, 0);\n    if (!module) {\n        return -1;\n    }\n    if (module != lys_main_module(start->module)) {\n        start = module->data;\n    }\n\n    *ret = lys_find_grouping_up(name, (struct lys_node *)start);\n\n    return EXIT_SUCCESS;\n}\n\nint\nresolve_absolute_schema_nodeid(const char *nodeid, const struct lys_module *module, int ret_nodetype,\n                               const struct lys_node **ret)\n{\n    const char *name, *mod_name, *id;\n    const struct lys_node *sibling, *start_parent;\n    int r, nam_len, mod_name_len, is_relative = -1;\n    const struct lys_module *abs_start_mod;\n\n    assert(nodeid && module && ret);\n    assert(!(ret_nodetype & (LYS_USES | LYS_AUGMENT)) && ((ret_nodetype == LYS_GROUPING) || !(ret_nodetype & LYS_GROUPING)));\n\n    id = nodeid;\n    start_parent = NULL;\n\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 0)) < 1) {\n        return ((id - nodeid) - r) + 1;\n    }\n    id += r;\n\n    if (is_relative) {\n        return -1;\n    }\n\n    abs_start_mod = lyp_get_module(module, NULL, 0, mod_name, mod_name_len, 0);\n    if (!abs_start_mod) {\n        return -1;\n    }\n\n    while (1) {\n        sibling = NULL;\n        while ((sibling = lys_getnext(sibling, start_parent, abs_start_mod, LYS_GETNEXT_WITHCHOICE\n                | LYS_GETNEXT_WITHCASE | LYS_GETNEXT_WITHINOUT | LYS_GETNEXT_WITHGROUPING | LYS_GETNEXT_NOSTATECHECK))) {\n            r = schema_nodeid_siblingcheck(sibling, module, mod_name, mod_name_len, name, nam_len);\n            if (r == 0) {\n                if (!id[0]) {\n                    if (!(sibling->nodetype & ret_nodetype)) {\n                        /* wrong node type, too bad */\n                        continue;\n                    }\n                    *ret = sibling;\n                    return EXIT_SUCCESS;\n                }\n                start_parent = sibling;\n                break;\n            } else if (r == 1) {\n                continue;\n            } else {\n                return -1;\n            }\n        }\n\n        /* no match */\n        if (!sibling) {\n            *ret = NULL;\n            return EXIT_SUCCESS;\n        }\n\n        if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 0)) < 1) {\n            return ((id - nodeid) - r) + 1;\n        }\n        id += r;\n    }\n\n    /* cannot get here */\n    LOGINT(module->ctx);\n    return -1;\n}\n\nstatic int\nresolve_json_schema_list_predicate(const char *predicate, const struct lys_node_list *list, int *parsed)\n{\n    const char *mod_name, *name;\n    int mod_name_len, nam_len, has_predicate, i;\n    struct lys_node *key;\n\n    if (((i = parse_schema_json_predicate(predicate, &mod_name, &mod_name_len, &name, &nam_len, NULL, NULL, &has_predicate)) < 1)\n            || !strncmp(name, \".\", nam_len)) {\n        LOGVAL(list->module->ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, predicate[-i], &predicate[-i]);\n        return -1;\n    }\n\n    predicate += i;\n    *parsed += i;\n\n    if (!isdigit(name[0])) {\n        for (i = 0; i < list->keys_size; ++i) {\n            key = (struct lys_node *)list->keys[i];\n            if (!strncmp(key->name, name, nam_len) && !key->name[nam_len]) {\n                break;\n            }\n        }\n\n        if (i == list->keys_size) {\n            LOGVAL(list->module->ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, name);\n            return -1;\n        }\n    }\n\n    /* more predicates? */\n    if (has_predicate) {\n        return resolve_json_schema_list_predicate(predicate, list, parsed);\n    }\n\n    return 0;\n}\n\n/* cannot return LYS_GROUPING, LYS_AUGMENT, LYS_USES, logs directly */\nconst struct lys_node *\nresolve_json_nodeid(const char *nodeid, struct ly_ctx *ctx, const struct lys_node *start, int output)\n{\n    char *str;\n    const char *name, *mod_name, *id, *backup_mod_name = NULL, *yang_data_name = NULL;\n    const struct lys_node *sibling, *start_parent, *parent;\n    int r, nam_len, mod_name_len, is_relative = -1, has_predicate;\n    int yang_data_name_len, backup_mod_name_len;\n    /* resolved import module from the start module, it must match the next node-name-match sibling */\n    const struct lys_module *prefix_mod, *module, *prev_mod;\n\n    assert(nodeid && (ctx || start));\n    if (!ctx) {\n        ctx = start->module->ctx;\n    }\n\n    id = nodeid;\n\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 1)) < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n        return NULL;\n    }\n\n    if (name[0] == '#') {\n        if (is_relative) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, '#', name);\n            return NULL;\n        }\n        yang_data_name = name + 1;\n        yang_data_name_len = nam_len - 1;\n        backup_mod_name = mod_name;\n        backup_mod_name_len = mod_name_len;\n        id += r;\n    } else {\n        is_relative = -1;\n    }\n\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate, NULL, 0)) < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n        return NULL;\n    }\n    id += r;\n\n    if (backup_mod_name) {\n        mod_name = backup_mod_name;\n        mod_name_len = backup_mod_name_len;\n    }\n\n    if (is_relative) {\n        assert(start);\n        start_parent = start;\n        while (start_parent && (start_parent->nodetype == LYS_USES)) {\n            start_parent = lys_parent(start_parent);\n        }\n        module = start->module;\n    } else {\n        if (!mod_name) {\n            str = strndup(nodeid, (name + nam_len) - nodeid);\n            LOGVAL(ctx, LYE_PATH_MISSMOD, LY_VLOG_STR, nodeid);\n            free(str);\n            return NULL;\n        }\n\n        str = strndup(mod_name, mod_name_len);\n        module = ly_ctx_get_module(ctx, str, NULL, 1);\n        free(str);\n\n        if (!module) {\n            str = strndup(nodeid, (mod_name + mod_name_len) - nodeid);\n            LOGVAL(ctx, LYE_PATH_INMOD, LY_VLOG_STR, str);\n            free(str);\n            return NULL;\n        }\n        start_parent = NULL;\n        if (yang_data_name) {\n            start_parent = lyp_get_yang_data_template(module, yang_data_name, yang_data_name_len);\n            if (!start_parent) {\n                str = strndup(nodeid, (yang_data_name + yang_data_name_len) - nodeid);\n                LOGVAL(ctx, LYE_PATH_INNODE, LY_VLOG_STR, str);\n                free(str);\n                return NULL;\n            }\n        }\n\n        /* now it's as if there was no module name */\n        mod_name = NULL;\n        mod_name_len = 0;\n    }\n\n    prev_mod = module;\n\n    while (1) {\n        sibling = NULL;\n        while ((sibling = lys_getnext(sibling, start_parent, module, 0))) {\n            /* name match */\n            if (sibling->name && !strncmp(name, sibling->name, nam_len) && !sibling->name[nam_len]) {\n                /* output check */\n                for (parent = lys_parent(sibling); parent && !(parent->nodetype & (LYS_INPUT | LYS_OUTPUT)); parent = lys_parent(parent));\n                if (parent) {\n                    if (output && (parent->nodetype == LYS_INPUT)) {\n                        continue;\n                    } else if (!output && (parent->nodetype == LYS_OUTPUT)) {\n                        continue;\n                    }\n                }\n\n                /* module check */\n                if (mod_name) {\n                    /* will also find an augment module */\n                    prefix_mod = ly_ctx_nget_module(ctx, mod_name, mod_name_len, NULL, 1);\n\n                    if (!prefix_mod) {\n                        str = strndup(nodeid, (mod_name + mod_name_len) - nodeid);\n                        LOGVAL(ctx, LYE_PATH_INMOD, LY_VLOG_STR, str);\n                        free(str);\n                        return NULL;\n                    }\n                } else {\n                    prefix_mod = prev_mod;\n                }\n                if (prefix_mod != lys_node_module(sibling)) {\n                    continue;\n                }\n\n                /* do we have some predicates on it? */\n                if (has_predicate) {\n                    r = 0;\n                    if (sibling->nodetype & (LYS_LEAF | LYS_LEAFLIST)) {\n                        if ((r = parse_schema_json_predicate(id, NULL, NULL, NULL, NULL, NULL, NULL, &has_predicate)) < 1) {\n                            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n                            return NULL;\n                        }\n                    } else if (sibling->nodetype == LYS_LIST) {\n                        if (resolve_json_schema_list_predicate(id, (const struct lys_node_list *)sibling, &r)) {\n                            return NULL;\n                        }\n                    } else {\n                        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n                        return NULL;\n                    }\n                    id += r;\n                }\n\n                /* the result node? */\n                if (!id[0]) {\n                    return sibling;\n                }\n\n                /* move down the tree, if possible */\n                if (sibling->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                    LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n                    return NULL;\n                }\n                start_parent = sibling;\n\n                /* update prev mod */\n                prev_mod = (start_parent->child ? lys_node_module(start_parent->child) : module);\n                break;\n            }\n        }\n\n        /* no match */\n        if (!sibling) {\n            str = strndup(nodeid, (name + nam_len) - nodeid);\n            LOGVAL(ctx, LYE_PATH_INNODE, LY_VLOG_STR, str);\n            free(str);\n            return NULL;\n        }\n\n        if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate, NULL, 0)) < 1) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n            return NULL;\n        }\n        id += r;\n    }\n\n    /* cannot get here */\n    LOGINT(ctx);\n    return NULL;\n}\n\nstatic int\nresolve_partial_json_data_list_predicate(struct parsed_pred pp, struct lyd_node *node, int position)\n{\n    uint16_t i;\n    struct lyd_node_leaf_list *key;\n    struct lys_node_list *slist;\n    struct ly_ctx *ctx;\n\n    assert(node);\n    assert(node->schema->nodetype == LYS_LIST);\n    assert(pp.len);\n\n    ctx = node->schema->module->ctx;\n    slist = (struct lys_node_list *)node->schema;\n\n    /* is the predicate a number? */\n    if (isdigit(pp.pred[0].name[0])) {\n        if (position == atoi(pp.pred[0].name)) {\n            /* match */\n            return 0;\n        } else {\n            /* not a match */\n            return 1;\n        }\n    }\n\n    key = (struct lyd_node_leaf_list *)node->child;\n    if (!key) {\n        /* it is not a position, so we need a key for it to be a match */\n        return 1;\n    }\n\n    /* go through all the keys */\n    for (i = 0; i < slist->keys_size; ++i) {\n        if (strncmp(key->schema->name, pp.pred[i].name, pp.pred[i].nam_len) || key->schema->name[pp.pred[i].nam_len]) {\n            LOGVAL(ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, pp.pred[i].name);\n            return -1;\n        }\n\n        if (pp.pred[i].mod_name) {\n            /* specific module, check that the found key is from that module */\n            if (strncmp(lyd_node_module((struct lyd_node *)key)->name, pp.pred[i].mod_name, pp.pred[i].mod_name_len)\n                    || lyd_node_module((struct lyd_node *)key)->name[pp.pred[i].mod_name_len]) {\n                LOGVAL(ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, pp.pred[i].name);\n                return -1;\n            }\n\n            /* but if the module is the same as the parent, it should have been omitted */\n            if (lyd_node_module((struct lyd_node *)key) == lyd_node_module(node)) {\n                LOGVAL(ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, pp.pred[i].name);\n                return -1;\n            }\n        } else {\n            /* no module, so it must be the same as the list (parent) */\n            if (lyd_node_module((struct lyd_node *)key) != lyd_node_module(node)) {\n                LOGVAL(ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, pp.pred[i].name);\n                return -1;\n            }\n        }\n\n        /* value does not match */\n        if (strncmp(key->value_str, pp.pred[i].value, pp.pred[i].val_len) || key->value_str[pp.pred[i].val_len]) {\n            return 1;\n        }\n\n        key = (struct lyd_node_leaf_list *)key->next;\n    }\n\n    return 0;\n}\n\n/**\n * @brief get the closest parent of the node (or the node itself) identified by the nodeid (path)\n *\n * @param[in] nodeid Node data path to find\n * @param[in] llist_value If the \\p nodeid identifies leaf-list, this is expected value of the leaf-list instance.\n * @param[in] options Bitmask of options flags, see @ref pathoptions.\n * @param[out] parsed Number of characters processed in \\p id\n * @return The closes parent (or the node itself) from the path\n */\nstruct lyd_node *\nresolve_partial_json_data_nodeid(const char *nodeid, const char *llist_value, struct lyd_node *start, int options,\n                                 int *parsed)\n{\n    const char *id, *mod_name, *name, *data_val, *llval;\n    int r, ret, mod_name_len, nam_len, is_relative = -1, list_instance_position;\n    int has_predicate, last_parsed = 0, llval_len;\n    struct lyd_node *sibling, *last_match = NULL;\n    struct lyd_node_leaf_list *llist;\n    const struct lys_module *prev_mod;\n    struct ly_ctx *ctx;\n    const struct lys_node *ssibling, *sparent;\n    struct lys_node_list *slist;\n    struct parsed_pred pp;\n\n    assert(nodeid && start && parsed);\n\n    memset(&pp, 0, sizeof pp);\n    ctx = start->schema->module->ctx;\n    id = nodeid;\n\n    /* parse first nodeid in case it is yang-data extension */\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 1)) < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n        goto error;\n    }\n\n    if (name[0] == '#') {\n        if (is_relative) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, '#', name);\n            goto error;\n        }\n        id += r;\n        last_parsed = r;\n    } else {\n        is_relative = -1;\n    }\n\n    /* parse first nodeid */\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate, NULL, 0)) < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n        goto error;\n    }\n    id += r;\n    /* add it to parsed only after the data node was actually found */\n    last_parsed += r;\n\n    if (is_relative) {\n        prev_mod = lyd_node_module(start);\n        start = (start->schema->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_RPC | LYS_ACTION | LYS_NOTIF)) ? start->child : NULL;\n    } else {\n        for (; start->parent; start = start->parent);\n        prev_mod = lyd_node_module(start);\n    }\n    if (!start) {\n        /* there are no siblings to search */\n        return NULL;\n    }\n\n    /* do not duplicate code, use predicate parsing from the loop */\n    goto parse_predicates;\n\n    while (1) {\n        /* find the correct schema node first */\n        ssibling = NULL;\n        sparent = (start && start->parent) ? start->parent->schema : NULL;\n        while ((ssibling = lys_getnext(ssibling, sparent, prev_mod, 0))) {\n            /* skip invalid input/output nodes */\n            if (sparent && (sparent->nodetype & (LYS_RPC | LYS_ACTION))) {\n                if (options & LYD_PATH_OPT_OUTPUT) {\n                    if (lys_parent(ssibling)->nodetype == LYS_INPUT) {\n                        continue;\n                    }\n                } else {\n                    if (lys_parent(ssibling)->nodetype == LYS_OUTPUT) {\n                        continue;\n                    }\n                }\n            }\n\n            if (!schema_nodeid_siblingcheck(ssibling, prev_mod, mod_name, mod_name_len, name, nam_len)) {\n                break;\n            }\n        }\n        if (!ssibling) {\n            /* there is not even such a schema node */\n            free(pp.pred);\n            return last_match;\n        }\n        pp.schema = ssibling;\n\n        /* unify leaf-list value - it is possible to specify last-node value as both a predicate or parameter if\n         * is a leaf-list, unify both cases and the value will in both cases be in the predicate structure */\n        if (!id[0] && !pp.len && (ssibling->nodetype == LYS_LEAFLIST)) {\n            pp.len = 1;\n            pp.pred = calloc(1, sizeof *pp.pred);\n            LY_CHECK_ERR_GOTO(!pp.pred, LOGMEM(ctx), error);\n\n            pp.pred[0].name = \".\";\n            pp.pred[0].nam_len = 1;\n            pp.pred[0].value = (llist_value ? llist_value : \"\");\n            pp.pred[0].val_len = strlen(pp.pred[0].value);\n        }\n\n        if (ssibling->nodetype & (LYS_LEAFLIST | LYS_LEAF)) {\n            /* check leaf/leaf-list predicate */\n            if (pp.len > 1) {\n                LOGVAL(ctx, LYE_PATH_PREDTOOMANY, LY_VLOG_NONE, NULL);\n                goto error;\n            } else if (pp.len) {\n                if ((pp.pred[0].name[0] != '.') || (pp.pred[0].nam_len != 1)) {\n                    LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, pp.pred[0].name[0], pp.pred[0].name);\n                    goto error;\n                }\n                if ((((struct lys_node_leaf *)ssibling)->type.base == LY_TYPE_IDENT) && !strnchr(pp.pred[0].value, ':', pp.pred[0].val_len)) {\n                    LOGVAL(ctx, LYE_PATH_INIDENTREF, LY_VLOG_LYS, ssibling, pp.pred[0].val_len, pp.pred[0].value);\n                    goto error;\n                }\n            }\n        } else if (ssibling->nodetype == LYS_LIST) {\n            /* list should have predicates for all the keys or position */\n            slist = (struct lys_node_list *)ssibling;\n            if (!pp.len) {\n                /* none match */\n                return last_match;\n            } else if (!isdigit(pp.pred[0].name[0])) {\n                /* list predicate is not a position, so there must be all the keys */\n                if (pp.len > slist->keys_size) {\n                    LOGVAL(ctx, LYE_PATH_PREDTOOMANY, LY_VLOG_NONE, NULL);\n                    goto error;\n                } else if (pp.len < slist->keys_size) {\n                    LOGVAL(ctx, LYE_PATH_MISSKEY, LY_VLOG_NONE, NULL, slist->keys[pp.len]->name);\n                    goto error;\n                }\n                /* check that all identityrefs have module name, otherwise the hash of the list instance will never match!! */\n                for (r = 0; r < pp.len; ++r) {\n                    if ((slist->keys[r]->type.base == LY_TYPE_IDENT) && !strnchr(pp.pred[r].value, ':', pp.pred[r].val_len)) {\n                        LOGVAL(ctx, LYE_PATH_INIDENTREF, LY_VLOG_LYS, slist->keys[r], pp.pred[r].val_len, pp.pred[r].value);\n                        goto error;\n                    }\n                }\n            }\n        } else if (pp.pred) {\n            /* no other nodes allow predicates */\n            LOGVAL(ctx, LYE_PATH_PREDTOOMANY, LY_VLOG_NONE, NULL);\n            goto error;\n        }\n\n#ifdef LY_ENABLED_CACHE\n        /* we will not be matching keyless lists or state leaf-lists this way */\n        if (start->parent && start->parent->ht && ((pp.schema->nodetype != LYS_LIST) || ((struct lys_node_list *)pp.schema)->keys_size)\n                && ((pp.schema->nodetype != LYS_LEAFLIST) || (pp.schema->flags & LYS_CONFIG_W))) {\n            sibling = resolve_json_data_node_hash(start->parent, pp);\n        } else\n#endif\n        {\n            list_instance_position = 0;\n            LY_TREE_FOR(start, sibling) {\n                /* RPC/action data check, return simply invalid argument, because the data tree is invalid */\n                if (lys_parent(sibling->schema)) {\n                    if (options & LYD_PATH_OPT_OUTPUT) {\n                        if (lys_parent(sibling->schema)->nodetype == LYS_INPUT) {\n                            LOGERR(ctx, LY_EINVAL, \"Provided data tree includes some RPC input nodes (%s).\", sibling->schema->name);\n                            goto error;\n                        }\n                    } else {\n                        if (lys_parent(sibling->schema)->nodetype == LYS_OUTPUT) {\n                            LOGERR(ctx, LY_EINVAL, \"Provided data tree includes some RPC output nodes (%s).\", sibling->schema->name);\n                            goto error;\n                        }\n                    }\n                }\n\n                if (sibling->schema != ssibling) {\n                    /* wrong schema node */\n                    continue;\n                }\n\n                /* leaf-list, did we find it with the correct value or not? */\n                if (ssibling->nodetype == LYS_LEAFLIST) {\n                    if (ssibling->flags & LYS_CONFIG_R) {\n                        /* state leaf-lists will never match */\n                        continue;\n                    }\n\n                    llist = (struct lyd_node_leaf_list *)sibling;\n\n                    /* get the expected leaf-list value */\n                    llval = NULL;\n                    llval_len = 0;\n                    if (pp.pred) {\n                        /* it was already checked that it is correct */\n                        llval = pp.pred[0].value;\n                        llval_len = pp.pred[0].val_len;\n\n                    }\n\n                    /* make value canonical (remove module name prefix) unless it was specified with it */\n                    if (llval && !strchr(llval, ':') && (llist->value_type & LY_TYPE_IDENT)\n                            && !strncmp(llist->value_str, lyd_node_module(sibling)->name, strlen(lyd_node_module(sibling)->name))\n                            && (llist->value_str[strlen(lyd_node_module(sibling)->name)] == ':')) {\n                        data_val = llist->value_str + strlen(lyd_node_module(sibling)->name) + 1;\n                    } else {\n                        data_val = llist->value_str;\n                    }\n\n                    if ((!llval && data_val && data_val[0]) || (llval && (strncmp(llval, data_val, llval_len)\n                            || data_val[llval_len]))) {\n                        continue;\n                    }\n\n                } else if (ssibling->nodetype == LYS_LIST) {\n                    /* list, we likely need predicates'n'stuff then, but if without a predicate, we are always creating it */\n                    ++list_instance_position;\n                    ret = resolve_partial_json_data_list_predicate(pp, sibling, list_instance_position);\n                    if (ret == -1) {\n                        goto error;\n                    } else if (ret == 1) {\n                        /* this list instance does not match */\n                        continue;\n                    }\n                }\n\n                break;\n            }\n        }\n\n        /* no match, return last match */\n        if (!sibling) {\n            free(pp.pred);\n            return last_match;\n        }\n\n        /* we found a next matching node */\n        *parsed += last_parsed;\n        last_match = sibling;\n        prev_mod = lyd_node_module(sibling);\n\n        /* the result node? */\n        if (!id[0]) {\n            free(pp.pred);\n            return last_match;\n        }\n\n        /* move down the tree, if possible, and continue */\n        if (ssibling->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n            /* there can be no children even through expected, error */\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n            goto error;\n        } else if (!sibling->child) {\n            /* there could be some children, but are not, return what we found so far */\n            free(pp.pred);\n            return last_match;\n        }\n        start = sibling->child;\n\n        /* parse nodeid */\n        if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate, NULL, 0)) < 1) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n            goto error;\n        }\n        id += r;\n        last_parsed = r;\n\nparse_predicates:\n        /* parse all the predicates */\n        free(pp.pred);\n        pp.schema = NULL;\n        pp.len = 0;\n        pp.pred = NULL;\n        while (has_predicate) {\n            ++pp.len;\n            pp.pred = ly_realloc(pp.pred, pp.len * sizeof *pp.pred);\n            LY_CHECK_ERR_GOTO(!pp.pred, LOGMEM(ctx), error);\n            if ((r = parse_schema_json_predicate(id, &pp.pred[pp.len - 1].mod_name, &pp.pred[pp.len - 1].mod_name_len,\n                                                 &pp.pred[pp.len - 1].name, &pp.pred[pp.len - 1].nam_len, &pp.pred[pp.len - 1].value,\n                                                 &pp.pred[pp.len - 1].val_len, &has_predicate)) < 1) {\n                LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n                goto error;\n            }\n\n            id += r;\n            last_parsed += r;\n        }\n    }\n\nerror:\n    *parsed = -1;\n    free(pp.pred);\n    return NULL;\n}\n\n/**\n * @brief Resolves length or range intervals. Does not log.\n * Syntax is assumed to be correct, *ret MUST be NULL.\n *\n * @param[in] ctx Context for errors.\n * @param[in] str_restr Restriction as a string.\n * @param[in] type Type of the restriction.\n * @param[out] ret Final interval structure that starts with\n * the interval of the initial type, continues with intervals\n * of any superior types derived from the initial one, and\n * finishes with intervals from our \\p type.\n *\n * @return EXIT_SUCCESS on succes, -1 on error.\n */\nint\nresolve_len_ran_interval(struct ly_ctx *ctx, const char *str_restr, struct lys_type *type, struct len_ran_intv **ret)\n{\n    /* 0 - unsigned, 1 - signed, 2 - floating point */\n    int kind;\n    int64_t local_smin = 0, local_smax = 0, local_fmin, local_fmax;\n    uint64_t local_umin, local_umax = 0;\n    uint8_t local_fdig = 0;\n    const char *seg_ptr, *ptr;\n    struct len_ran_intv *local_intv = NULL, *tmp_local_intv = NULL, *tmp_intv, *intv = NULL;\n\n    switch (type->base) {\n    case LY_TYPE_BINARY:\n        kind = 0;\n        local_umin = 0;\n        local_umax = 18446744073709551615UL;\n\n        if (!str_restr && type->info.binary.length) {\n            str_restr = type->info.binary.length->expr;\n        }\n        break;\n    case LY_TYPE_DEC64:\n        kind = 2;\n        local_fmin = __INT64_C(-9223372036854775807) - __INT64_C(1);\n        local_fmax = __INT64_C(9223372036854775807);\n        local_fdig = type->info.dec64.dig;\n\n        if (!str_restr && type->info.dec64.range) {\n            str_restr = type->info.dec64.range->expr;\n        }\n        break;\n    case LY_TYPE_INT8:\n        kind = 1;\n        local_smin = __INT64_C(-128);\n        local_smax = __INT64_C(127);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_INT16:\n        kind = 1;\n        local_smin = __INT64_C(-32768);\n        local_smax = __INT64_C(32767);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_INT32:\n        kind = 1;\n        local_smin = __INT64_C(-2147483648);\n        local_smax = __INT64_C(2147483647);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_INT64:\n        kind = 1;\n        local_smin = __INT64_C(-9223372036854775807) - __INT64_C(1);\n        local_smax = __INT64_C(9223372036854775807);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_UINT8:\n        kind = 0;\n        local_umin = __UINT64_C(0);\n        local_umax = __UINT64_C(255);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_UINT16:\n        kind = 0;\n        local_umin = __UINT64_C(0);\n        local_umax = __UINT64_C(65535);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_UINT32:\n        kind = 0;\n        local_umin = __UINT64_C(0);\n        local_umax = __UINT64_C(4294967295);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_UINT64:\n        kind = 0;\n        local_umin = __UINT64_C(0);\n        local_umax = __UINT64_C(18446744073709551615);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_STRING:\n        kind = 0;\n        local_umin = __UINT64_C(0);\n        local_umax = __UINT64_C(18446744073709551615);\n\n        if (!str_restr && type->info.str.length) {\n            str_restr = type->info.str.length->expr;\n        }\n        break;\n    default:\n        return -1;\n    }\n\n    /* process superior types */\n    if (type->der) {\n        if (resolve_len_ran_interval(ctx, NULL, &type->der->type, &intv)) {\n            return -1;\n        }\n        assert(!intv || (intv->kind == kind));\n    }\n\n    if (!str_restr) {\n        /* we do not have any restriction, return superior ones */\n        *ret = intv;\n        return EXIT_SUCCESS;\n    }\n\n    /* adjust local min and max */\n    if (intv) {\n        tmp_intv = intv;\n\n        if (kind == 0) {\n            local_umin = tmp_intv->value.uval.min;\n        } else if (kind == 1) {\n            local_smin = tmp_intv->value.sval.min;\n        } else if (kind == 2) {\n            local_fmin = tmp_intv->value.fval.min;\n        }\n\n        while (tmp_intv->next) {\n            tmp_intv = tmp_intv->next;\n        }\n\n        if (kind == 0) {\n            local_umax = tmp_intv->value.uval.max;\n        } else if (kind == 1) {\n            local_smax = tmp_intv->value.sval.max;\n        } else if (kind == 2) {\n            local_fmax = tmp_intv->value.fval.max;\n        }\n    }\n\n    /* finally parse our restriction */\n    seg_ptr = str_restr;\n    tmp_intv = NULL;\n    while (1) {\n        if (!tmp_local_intv) {\n            assert(!local_intv);\n            local_intv = malloc(sizeof *local_intv);\n            tmp_local_intv = local_intv;\n        } else {\n            tmp_local_intv->next = malloc(sizeof *tmp_local_intv);\n            tmp_local_intv = tmp_local_intv->next;\n        }\n        LY_CHECK_ERR_GOTO(!tmp_local_intv, LOGMEM(ctx), error);\n\n        tmp_local_intv->kind = kind;\n        tmp_local_intv->type = type;\n        tmp_local_intv->next = NULL;\n\n        /* min */\n        ptr = seg_ptr;\n        while (isspace(ptr[0])) {\n            ++ptr;\n        }\n        if (isdigit(ptr[0]) || (ptr[0] == '+') || (ptr[0] == '-')) {\n            if (kind == 0) {\n                tmp_local_intv->value.uval.min = strtoll(ptr, (char **)&ptr, 10);\n            } else if (kind == 1) {\n                tmp_local_intv->value.sval.min = strtoll(ptr, (char **)&ptr, 10);\n            } else if (kind == 2) {\n                if (parse_range_dec64(&ptr, local_fdig, &tmp_local_intv->value.fval.min)) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, ptr, \"range\");\n                    goto error;\n                }\n            }\n        } else if (!strncmp(ptr, \"min\", 3)) {\n            if (kind == 0) {\n                tmp_local_intv->value.uval.min = local_umin;\n            } else if (kind == 1) {\n                tmp_local_intv->value.sval.min = local_smin;\n            } else if (kind == 2) {\n                tmp_local_intv->value.fval.min = local_fmin;\n            }\n\n            ptr += 3;\n        } else if (!strncmp(ptr, \"max\", 3)) {\n            if (kind == 0) {\n                tmp_local_intv->value.uval.min = local_umax;\n            } else if (kind == 1) {\n                tmp_local_intv->value.sval.min = local_smax;\n            } else if (kind == 2) {\n                tmp_local_intv->value.fval.min = local_fmax;\n            }\n\n            ptr += 3;\n        } else {\n            goto error;\n        }\n\n        while (isspace(ptr[0])) {\n            ptr++;\n        }\n\n        /* no interval or interval */\n        if ((ptr[0] == '|') || !ptr[0]) {\n            if (kind == 0) {\n                tmp_local_intv->value.uval.max = tmp_local_intv->value.uval.min;\n            } else if (kind == 1) {\n                tmp_local_intv->value.sval.max = tmp_local_intv->value.sval.min;\n            } else if (kind == 2) {\n                tmp_local_intv->value.fval.max = tmp_local_intv->value.fval.min;\n            }\n        } else if (!strncmp(ptr, \"..\", 2)) {\n            /* skip \"..\" */\n            ptr += 2;\n            while (isspace(ptr[0])) {\n                ++ptr;\n            }\n\n            /* max */\n            if (isdigit(ptr[0]) || (ptr[0] == '+') || (ptr[0] == '-')) {\n                if (kind == 0) {\n                    tmp_local_intv->value.uval.max = strtoll(ptr, (char **)&ptr, 10);\n                } else if (kind == 1) {\n                    tmp_local_intv->value.sval.max = strtoll(ptr, (char **)&ptr, 10);\n                } else if (kind == 2) {\n                    if (parse_range_dec64(&ptr, local_fdig, &tmp_local_intv->value.fval.max)) {\n                        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, ptr, \"range\");\n                        goto error;\n                    }\n                }\n            } else if (!strncmp(ptr, \"max\", 3)) {\n                if (kind == 0) {\n                    tmp_local_intv->value.uval.max = local_umax;\n                } else if (kind == 1) {\n                    tmp_local_intv->value.sval.max = local_smax;\n                } else if (kind == 2) {\n                    tmp_local_intv->value.fval.max = local_fmax;\n                }\n            } else {\n                goto error;\n            }\n        } else {\n            goto error;\n        }\n\n        /* check min and max in correct order*/\n        if (kind == 0) {\n            /* current segment */\n            if (tmp_local_intv->value.uval.min > tmp_local_intv->value.uval.max) {\n                goto error;\n            }\n            if (tmp_local_intv->value.uval.min < local_umin || tmp_local_intv->value.uval.max > local_umax) {\n                goto error;\n            }\n            /* segments sholud be ascending order */\n            if (tmp_intv && (tmp_intv->value.uval.max >= tmp_local_intv->value.uval.min)) {\n                goto error;\n            }\n        } else if (kind == 1) {\n            if (tmp_local_intv->value.sval.min > tmp_local_intv->value.sval.max) {\n                goto error;\n            }\n            if (tmp_local_intv->value.sval.min < local_smin || tmp_local_intv->value.sval.max > local_smax) {\n                goto error;\n            }\n            if (tmp_intv && (tmp_intv->value.sval.max >= tmp_local_intv->value.sval.min)) {\n                goto error;\n            }\n        } else if (kind == 2) {\n            if (tmp_local_intv->value.fval.min > tmp_local_intv->value.fval.max) {\n                goto error;\n            }\n            if (tmp_local_intv->value.fval.min < local_fmin || tmp_local_intv->value.fval.max > local_fmax) {\n                goto error;\n            }\n            if (tmp_intv && (tmp_intv->value.fval.max >= tmp_local_intv->value.fval.min)) {\n                /* fraction-digits value is always the same (it cannot be changed in derived types) */\n                goto error;\n            }\n        }\n\n        /* next segment (next OR) */\n        seg_ptr = strchr(seg_ptr, '|');\n        if (!seg_ptr) {\n            break;\n        }\n        seg_ptr++;\n        tmp_intv = tmp_local_intv;\n    }\n\n    /* check local restrictions against superior ones */\n    if (intv) {\n        tmp_intv = intv;\n        tmp_local_intv = local_intv;\n\n        while (tmp_local_intv && tmp_intv) {\n            /* reuse local variables */\n            if (kind == 0) {\n                local_umin = tmp_local_intv->value.uval.min;\n                local_umax = tmp_local_intv->value.uval.max;\n\n                /* it must be in this interval */\n                if ((local_umin >= tmp_intv->value.uval.min) && (local_umin <= tmp_intv->value.uval.max)) {\n                    /* this interval is covered, next one */\n                    if (local_umax <= tmp_intv->value.uval.max) {\n                        tmp_local_intv = tmp_local_intv->next;\n                        continue;\n                    /* ascending order of restrictions -> fail */\n                    } else {\n                        goto error;\n                    }\n                }\n            } else if (kind == 1) {\n                local_smin = tmp_local_intv->value.sval.min;\n                local_smax = tmp_local_intv->value.sval.max;\n\n                if ((local_smin >= tmp_intv->value.sval.min) && (local_smin <= tmp_intv->value.sval.max)) {\n                    if (local_smax <= tmp_intv->value.sval.max) {\n                        tmp_local_intv = tmp_local_intv->next;\n                        continue;\n                    } else {\n                        goto error;\n                    }\n                }\n            } else if (kind == 2) {\n                local_fmin = tmp_local_intv->value.fval.min;\n                local_fmax = tmp_local_intv->value.fval.max;\n\n                 if ((dec64cmp(local_fmin, local_fdig, tmp_intv->value.fval.min, local_fdig) > -1)\n                        && (dec64cmp(local_fmin, local_fdig, tmp_intv->value.fval.max, local_fdig) < 1)) {\n                    if (dec64cmp(local_fmax, local_fdig, tmp_intv->value.fval.max, local_fdig) < 1) {\n                        tmp_local_intv = tmp_local_intv->next;\n                        continue;\n                    } else {\n                        goto error;\n                    }\n                }\n            }\n\n            tmp_intv = tmp_intv->next;\n        }\n\n        /* some interval left uncovered -> fail */\n        if (tmp_local_intv) {\n            goto error;\n        }\n    }\n\n    /* append the local intervals to all the intervals of the superior types, return it all */\n    if (intv) {\n        for (tmp_intv = intv; tmp_intv->next; tmp_intv = tmp_intv->next);\n        tmp_intv->next = local_intv;\n    } else {\n        intv = local_intv;\n    }\n    *ret = intv;\n\n    return EXIT_SUCCESS;\n\nerror:\n    while (intv) {\n        tmp_intv = intv->next;\n        free(intv);\n        intv = tmp_intv;\n    }\n    while (local_intv) {\n        tmp_local_intv = local_intv->next;\n        free(local_intv);\n        local_intv = tmp_local_intv;\n    }\n\n    return -1;\n}\n\n/**\n * @brief Resolve a typedef, return only resolved typedefs if derived. If leafref, it must be\n * resolved for this function to return it. Does not log.\n *\n * @param[in] name Typedef name.\n * @param[in] mod_name Typedef name module name.\n * @param[in] module Main module.\n * @param[in] parent Parent of the resolved type definition.\n * @param[out] ret Pointer to the resolved typedef. Can be NULL.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nint\nresolve_superior_type(const char *name, const char *mod_name, const struct lys_module *module,\n                      const struct lys_node *parent, struct lys_tpdf **ret)\n{\n    int i, j;\n    struct lys_tpdf *tpdf, *match;\n    int tpdf_size;\n\n    if (!mod_name) {\n        /* no prefix, try built-in types */\n        for (i = 1; i < LY_DATA_TYPE_COUNT; i++) {\n            if (!strcmp(ly_types[i]->name, name)) {\n                if (ret) {\n                    *ret = ly_types[i];\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    } else {\n        if (!strcmp(mod_name, module->name)) {\n            /* prefix refers to the current module, ignore it */\n            mod_name = NULL;\n        }\n    }\n\n    if (!mod_name && parent) {\n        /* search in local typedefs */\n        while (parent) {\n            switch (parent->nodetype) {\n            case LYS_CONTAINER:\n                tpdf_size = ((struct lys_node_container *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_container *)parent)->tpdf;\n                break;\n\n            case LYS_LIST:\n                tpdf_size = ((struct lys_node_list *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_list *)parent)->tpdf;\n                break;\n\n            case LYS_GROUPING:\n                tpdf_size = ((struct lys_node_grp *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_grp *)parent)->tpdf;\n                break;\n\n            case LYS_RPC:\n            case LYS_ACTION:\n                tpdf_size = ((struct lys_node_rpc_action *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_rpc_action *)parent)->tpdf;\n                break;\n\n            case LYS_NOTIF:\n                tpdf_size = ((struct lys_node_notif *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_notif *)parent)->tpdf;\n                break;\n\n            case LYS_INPUT:\n            case LYS_OUTPUT:\n                tpdf_size = ((struct lys_node_inout *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_inout *)parent)->tpdf;\n                break;\n\n            default:\n                parent = lys_parent(parent);\n                continue;\n            }\n\n            for (i = 0; i < tpdf_size; i++) {\n                if (!strcmp(tpdf[i].name, name) && tpdf[i].type.base > 0) {\n                    match = &tpdf[i];\n                    goto check_leafref;\n                }\n            }\n\n            parent = lys_parent(parent);\n        }\n    } else {\n        /* get module where to search */\n        module = lyp_get_module(module, NULL, 0, mod_name, 0, 0);\n        if (!module) {\n            return -1;\n        }\n    }\n\n    /* search in top level typedefs */\n    for (i = 0; i < module->tpdf_size; i++) {\n        if (!strcmp(module->tpdf[i].name, name) && module->tpdf[i].type.base > 0) {\n            match = &module->tpdf[i];\n            goto check_leafref;\n        }\n    }\n\n    /* search in submodules */\n    for (i = 0; i < module->inc_size && module->inc[i].submodule; i++) {\n        for (j = 0; j < module->inc[i].submodule->tpdf_size; j++) {\n            if (!strcmp(module->inc[i].submodule->tpdf[j].name, name) && module->inc[i].submodule->tpdf[j].type.base > 0) {\n                match = &module->inc[i].submodule->tpdf[j];\n                goto check_leafref;\n            }\n        }\n    }\n\n    return EXIT_FAILURE;\n\ncheck_leafref:\n    if (ret) {\n        *ret = match;\n    }\n    if (match->type.base == LY_TYPE_LEAFREF) {\n        while (!match->type.info.lref.path) {\n            match = match->type.der;\n            assert(match);\n        }\n    }\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Check the default \\p value of the \\p type. Logs directly.\n *\n * @param[in] type Type definition to use.\n * @param[in] value Default value to check.\n * @param[in] module Type module.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\ncheck_default(struct lys_type *type, const char **value, struct lys_module *module, int tpdf)\n{\n    struct lys_tpdf *base_tpdf = NULL;\n    struct lyd_node_leaf_list node;\n    const char *dflt = NULL;\n    char *s;\n    int ret = EXIT_SUCCESS, r;\n    struct ly_ctx *ctx = module->ctx;\n\n    assert(value);\n    memset(&node, 0, sizeof node);\n\n    if (type->base <= LY_TYPE_DER) {\n        /* the type was not resolved yet, nothing to do for now */\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    } else if (!tpdf && !module->implemented) {\n        /* do not check defaults in not implemented module's data */\n        goto cleanup;\n    } else if (tpdf && !module->implemented && type->base == LY_TYPE_IDENT) {\n        /* identityrefs are checked when instantiated in data instead of typedef,\n         * but in typedef the value has to be modified to include the prefix */\n        if (*value) {\n            if (strchr(*value, ':')) {\n                dflt = transform_schema2json(module, *value);\n            } else {\n                /* default prefix of the module where the typedef is defined */\n                if (asprintf(&s, \"%s:%s\", lys_main_module(module)->name, *value) == -1) {\n                    LOGMEM(ctx);\n                    ret = -1;\n                    goto cleanup;\n                }\n                dflt = lydict_insert_zc(ctx, s);\n            }\n            lydict_remove(ctx, *value);\n            *value = dflt;\n            dflt = NULL;\n        }\n        goto cleanup;\n    } else if (type->base == LY_TYPE_LEAFREF && tpdf) {\n        /* leafref in typedef cannot be checked */\n        goto cleanup;\n    }\n\n    dflt = lydict_insert(ctx, *value, 0);\n    if (!dflt) {\n        /* we do not have a new default value, so is there any to check even, in some base type? */\n        for (base_tpdf = type->der; base_tpdf->type.der; base_tpdf = base_tpdf->type.der) {\n            if (base_tpdf->dflt) {\n                dflt = lydict_insert(ctx, base_tpdf->dflt, 0);\n                break;\n            }\n        }\n\n        if (!dflt) {\n            /* no default value, nothing to check, all is well */\n            goto cleanup;\n        }\n\n        /* so there is a default value in a base type, but can the default value be no longer valid (did we define some new restrictions)? */\n        switch (type->base) {\n        case LY_TYPE_IDENT:\n            if (lys_main_module(base_tpdf->type.parent->module)->implemented) {\n                goto cleanup;\n            } else {\n                /* check the default value from typedef, but use also the typedef's module\n                 * due to possible searching in imported modules which is expected in\n                 * typedef's module instead of module where the typedef is used */\n                module = base_tpdf->module;\n            }\n            break;\n        case LY_TYPE_INST:\n        case LY_TYPE_LEAFREF:\n        case LY_TYPE_BOOL:\n        case LY_TYPE_EMPTY:\n            /* these have no restrictions, so we would do the exact same work as the unres in the base typedef */\n            goto cleanup;\n        case LY_TYPE_BITS:\n            /* the default value must match the restricted list of values, if the type was restricted */\n            if (type->info.bits.count) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_ENUM:\n            /* the default value must match the restricted list of values, if the type was restricted */\n            if (type->info.enums.count) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_DEC64:\n            if (type->info.dec64.range) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_BINARY:\n            if (type->info.binary.length) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_INT8:\n        case LY_TYPE_INT16:\n        case LY_TYPE_INT32:\n        case LY_TYPE_INT64:\n        case LY_TYPE_UINT8:\n        case LY_TYPE_UINT16:\n        case LY_TYPE_UINT32:\n        case LY_TYPE_UINT64:\n            if (type->info.num.range) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_STRING:\n            if (type->info.str.length || type->info.str.patterns) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_UNION:\n            /* way too much trouble learning whether we need to check the default again, so just do it */\n            break;\n        default:\n            LOGINT(ctx);\n            ret = -1;\n            goto cleanup;\n        }\n    } else if (type->base == LY_TYPE_EMPTY) {\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, \"default\", type->parent->name);\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"The \\\"empty\\\" data type cannot have a default value.\");\n        ret = -1;\n        goto cleanup;\n    }\n\n    /* dummy leaf */\n    memset(&node, 0, sizeof node);\n    node.value_str = lydict_insert(ctx, dflt, 0);\n    node.value_type = type->base;\n\n    if (tpdf) {\n        node.schema = calloc(1, sizeof (struct lys_node_leaf));\n        if (!node.schema) {\n            LOGMEM(ctx);\n            ret = -1;\n            goto cleanup;\n        }\n        r = asprintf((char **)&node.schema->name, \"typedef-%s-default\", ((struct lys_tpdf *)type->parent)->name);\n        if (r == -1) {\n            LOGMEM(ctx);\n            ret = -1;\n            goto cleanup;\n        }\n        node.schema->module = module;\n        memcpy(&((struct lys_node_leaf *)node.schema)->type, type, sizeof *type);\n    } else {\n        node.schema = (struct lys_node *)type->parent;\n    }\n\n    if (type->base == LY_TYPE_LEAFREF) {\n        if (!type->info.lref.target) {\n            ret = EXIT_FAILURE;\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Default value \\\"%s\\\" cannot be checked in an unresolved leafref.\",\n                   dflt);\n            goto cleanup;\n        }\n        ret = check_default(&type->info.lref.target->type, &dflt, module, 0);\n        if (!ret) {\n            /* adopt possibly changed default value to its canonical form */\n            if (*value) {\n                lydict_remove(ctx, *value);\n                *value = dflt;\n                dflt = NULL;\n            }\n        }\n    } else {\n        if (!lyp_parse_value(type, &node.value_str, NULL, &node, NULL, module, 1, 1, 0)) {\n            /* possible forward reference */\n            ret = EXIT_FAILURE;\n            if (base_tpdf) {\n                /* default value is defined in some base typedef */\n                if ((type->base == LY_TYPE_BITS && type->der->type.der) ||\n                        (type->base == LY_TYPE_ENUM && type->der->type.der)) {\n                    /* we have refined bits/enums */\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL,\n                           \"Invalid value \\\"%s\\\" of the default statement inherited to \\\"%s\\\" from \\\"%s\\\" base type.\",\n                           dflt, type->parent->name, base_tpdf->name);\n                }\n            }\n        } else {\n            /* success - adopt canonical form from the node into the default value */\n            if (!ly_strequal(dflt, node.value_str, 1)) {\n                /* this can happen only if we have non-inherited default value,\n                 * inherited default values are already in canonical form */\n                assert(ly_strequal(dflt, *value, 1));\n\n                lydict_remove(ctx, *value);\n                *value = node.value_str;\n                node.value_str = NULL;\n            }\n        }\n    }\n\ncleanup:\n    lyd_free_value(node.value, node.value_type, node.value_flags, type, NULL, NULL, NULL);\n    lydict_remove(ctx, node.value_str);\n    if (tpdf && node.schema) {\n        free((char *)node.schema->name);\n        free(node.schema);\n    }\n    lydict_remove(ctx, dflt);\n\n    return ret;\n}\n\n/**\n * @brief Check a key for mandatory attributes. Logs directly.\n *\n * @param[in] key The key to check.\n * @param[in] flags What flags to check.\n * @param[in] list The list of all the keys.\n * @param[in] index Index of the key in the key list.\n * @param[in] name The name of the keys.\n * @param[in] len The name length.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nstatic int\ncheck_key(struct lys_node_list *list, int index, const char *name, int len)\n{\n    struct lys_node_leaf *key = list->keys[index];\n    char *dup = NULL;\n    int j;\n    struct ly_ctx *ctx = list->module->ctx;\n\n    /* existence */\n    if (!key) {\n        if (name[len] != '\\0') {\n            dup = strdup(name);\n            LY_CHECK_ERR_RETURN(!dup, LOGMEM(ctx), -1);\n            dup[len] = '\\0';\n            name = dup;\n        }\n        LOGVAL(ctx, LYE_KEY_MISS, LY_VLOG_LYS, list, name);\n        free(dup);\n        return -1;\n    }\n\n    /* uniqueness */\n    for (j = index - 1; j >= 0; j--) {\n        if (key == list->keys[j]) {\n            LOGVAL(ctx, LYE_KEY_DUP, LY_VLOG_LYS, list, key->name);\n            return -1;\n        }\n    }\n\n    /* key is a leaf */\n    if (key->nodetype != LYS_LEAF) {\n        LOGVAL(ctx, LYE_KEY_NLEAF, LY_VLOG_LYS, list, key->name);\n        return -1;\n    }\n\n    /* type of the leaf is not built-in empty */\n    if (key->type.base == LY_TYPE_EMPTY && key->module->version < LYS_VERSION_1_1) {\n        LOGVAL(ctx, LYE_KEY_TYPE, LY_VLOG_LYS, list, key->name);\n        return -1;\n    }\n\n    /* config attribute is the same as of the list */\n    if ((key->flags & LYS_CONFIG_MASK) && (list->flags & LYS_CONFIG_MASK)\n            && ((list->flags & LYS_CONFIG_MASK) != (key->flags & LYS_CONFIG_MASK))) {\n        LOGVAL(ctx, LYE_KEY_CONFIG, LY_VLOG_LYS, list, key->name);\n        return -1;\n    }\n\n    /* key is not placed from augment */\n    if (key->parent->nodetype == LYS_AUGMENT) {\n        LOGVAL(ctx, LYE_KEY_MISS, LY_VLOG_LYS, key, key->name);\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Key inserted from augment.\");\n        return -1;\n    }\n\n    /* key is not when/if-feature -conditional */\n    j = 0;\n    if (key->when || (key->iffeature_size && (j = 1))) {\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, key, j ? \"if-feature\" : \"when\", \"leaf\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Key definition cannot depend on a \\\"%s\\\" condition.\",\n               j ? \"if-feature\" : \"when\");\n        return -1;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Resolve (test the target exists) unique. Logs directly.\n *\n * @param[in] parent The parent node of the unique structure.\n * @param[in] uniq_str_path One path from the unique string.\n *\n * @return EXIT_SUCCESS on succes, EXIT_FAILURE on forward reference, -1 on error.\n */\nint\nresolve_unique(struct lys_node *parent, const char *uniq_str_path, uint8_t *trg_type)\n{\n    int rc;\n    const struct lys_node *leaf = NULL;\n    struct ly_ctx *ctx = parent->module->ctx;\n\n    rc = resolve_descendant_schema_nodeid(uniq_str_path, *lys_child(parent, LYS_LEAF), LYS_LEAF, 1, &leaf);\n    if (rc || !leaf) {\n        if (rc) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, parent, uniq_str_path, \"unique\");\n            if (rc > 0) {\n                LOGVAL(ctx, LYE_INCHAR, LY_VLOG_PREV, NULL, uniq_str_path[rc - 1], &uniq_str_path[rc - 1]);\n            } else if (rc == -2) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Unique argument references list.\");\n            }\n            rc = -1;\n        } else {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, parent, uniq_str_path, \"unique\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Target leaf not found.\");\n            rc = EXIT_FAILURE;\n        }\n        goto error;\n    }\n    if (leaf->nodetype != LYS_LEAF) {\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, parent, uniq_str_path, \"unique\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Target is not a leaf.\");\n        return -1;\n    }\n\n    /* check status */\n    if (parent->nodetype != LYS_EXT && lyp_check_status(parent->flags, parent->module, parent->name,\n                                                        leaf->flags, leaf->module, leaf->name, leaf)) {\n        return -1;\n    }\n\n    /* check that all unique's targets are of the same config type */\n    if (*trg_type) {\n        if (((*trg_type == 1) && (leaf->flags & LYS_CONFIG_R)) || ((*trg_type == 2) && (leaf->flags & LYS_CONFIG_W))) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, parent, uniq_str_path, \"unique\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                   \"Leaf \\\"%s\\\" referenced in unique statement is config %s, but previous referenced leaf is config %s.\",\n                   uniq_str_path, *trg_type == 1 ? \"false\" : \"true\", *trg_type == 1 ? \"true\" : \"false\");\n            return -1;\n        }\n    } else {\n        /* first unique */\n        if (leaf->flags & LYS_CONFIG_W) {\n            *trg_type = 1;\n        } else {\n            *trg_type = 2;\n        }\n    }\n\n    /* set leaf's unique flag */\n    ((struct lys_node_leaf *)leaf)->flags |= LYS_UNIQUE;\n\n    return EXIT_SUCCESS;\n\nerror:\n\n    return rc;\n}\n\nvoid\nunres_data_del(struct unres_data *unres, uint32_t i)\n{\n    /* there are items after the one deleted */\n    if (i+1 < unres->count) {\n        /* we only move the data, memory is left allocated, why bother */\n        memmove(&unres->node[i], &unres->node[i+1], (unres->count-(i+1)) * sizeof *unres->node);\n\n    /* deleting the last item */\n    } else if (i == 0) {\n        free(unres->node);\n        unres->node = NULL;\n    }\n\n    /* if there are no items after and it is not the last one, just move the counter */\n    --unres->count;\n}\n\n/**\n * @brief Resolve (find) a data node from a specific module. Does not log.\n *\n * @param[in] mod Module to search in.\n * @param[in] name Name of the data node.\n * @param[in] nam_len Length of the name.\n * @param[in] start Data node to start the search from.\n * @param[in,out] parents Resolved nodes. If there are some parents,\n *                        they are replaced (!!) with the resolvents.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_data(const struct lys_module *mod, const char *name, int nam_len, struct lyd_node *start, struct unres_data *parents)\n{\n    struct lyd_node *node;\n    int flag;\n    uint32_t i;\n\n    if (!parents->count) {\n        parents->count = 1;\n        parents->node = malloc(sizeof *parents->node);\n        LY_CHECK_ERR_RETURN(!parents->node, LOGMEM(mod->ctx), -1);\n        parents->node[0] = NULL;\n    }\n    for (i = 0; i < parents->count;) {\n        if (parents->node[i] && (parents->node[i]->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA))) {\n            /* skip */\n            ++i;\n            continue;\n        }\n        flag = 0;\n        LY_TREE_FOR(parents->node[i] ? parents->node[i]->child : start, node) {\n            if (lyd_node_module(node) == mod && !strncmp(node->schema->name, name, nam_len)\n                    && node->schema->name[nam_len] == '\\0') {\n                /* matching target */\n                if (!flag) {\n                    /* put node instead of the current parent */\n                    parents->node[i] = node;\n                    flag = 1;\n                } else {\n                    /* multiple matching, so create a new node */\n                    ++parents->count;\n                    parents->node = ly_realloc(parents->node, parents->count * sizeof *parents->node);\n                    LY_CHECK_ERR_RETURN(!parents->node, LOGMEM(mod->ctx), EXIT_FAILURE);\n                    parents->node[parents->count-1] = node;\n                    ++i;\n                }\n            }\n        }\n\n        if (!flag) {\n            /* remove item from the parents list */\n            unres_data_del(parents, i);\n        } else {\n            ++i;\n        }\n    }\n\n    return parents->count ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n\nstatic int\nresolve_schema_leafref_valid_dep_flag(const struct lys_node *op_node, const struct lys_module *local_mod,\n                                      const struct lys_node *first_node, int abs_path)\n{\n    int dep1, dep2;\n    const struct lys_node *node;\n\n    if (!op_node) {\n        /* leafref pointing to a different module */\n        if (local_mod != lys_node_module(first_node)) {\n            return 1;\n        }\n    } else if (lys_parent(op_node)) {\n        /* inner operation (notif/action) */\n        if (abs_path) {\n            return 1;\n        } else {\n            /* compare depth of both nodes */\n            for (dep1 = 0, node = op_node; lys_parent(node); node = lys_parent(node));\n            for (dep2 = 0, node = first_node; lys_parent(node); node = lys_parent(node));\n            if ((dep2 > dep1) || ((dep2 == dep1) && (op_node != first_node))) {\n                return 1;\n            }\n        }\n    } else {\n        /* top-level operation (notif/rpc) */\n        if (op_node != first_node) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n/**\n * @brief Resolve a path (leafref) predicate in JSON schema context. Logs directly.\n *\n * @param[in] path Path to use.\n * @param[in] context_node Predicate context node (where the predicate is placed).\n * @param[in] parent Path context node (where the path begins/is placed).\n * @param[in] op_node Optional node if the leafref is in an operation (action/rpc/notif).\n *\n * @return 0 on forward reference, otherwise the number\n *         of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nresolve_schema_leafref_predicate(const char *path, const struct lys_node *context_node, struct lys_node *parent)\n{\n    const struct lys_module *trg_mod;\n    const struct lys_node *src_node, *dst_node;\n    const char *path_key_expr, *source, *sour_pref, *dest, *dest_pref;\n    int pke_len, sour_len, sour_pref_len, dest_len, dest_pref_len, pke_parsed, parsed = 0;\n    int has_predicate, dest_parent_times, i, rc;\n    struct ly_ctx *ctx = context_node->module->ctx;\n\n    do {\n        if ((i = parse_path_predicate(path, &sour_pref, &sour_pref_len, &source, &sour_len, &path_key_expr,\n                                      &pke_len, &has_predicate)) < 1) {\n            LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, parent, path[-i], path-i);\n            return -parsed+i;\n        }\n        parsed += i;\n        path += i;\n\n        /* source (must be leaf) */\n        if (sour_pref) {\n            trg_mod = lyp_get_module(lys_node_module(parent), NULL, 0, sour_pref, sour_pref_len, 0);\n        } else {\n            trg_mod = lys_node_module(parent);\n        }\n        rc = lys_getnext_data(trg_mod, context_node, source, sour_len, LYS_LEAF | LYS_LEAFLIST, LYS_GETNEXT_NOSTATECHECK,\n                              &src_node);\n        if (rc) {\n            LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref predicate\", path-parsed);\n            return 0;\n        }\n\n        /* destination */\n        dest_parent_times = 0;\n        pke_parsed = 0;\n        if ((i = parse_path_key_expr(path_key_expr, &dest_pref, &dest_pref_len, &dest, &dest_len,\n                                     &dest_parent_times)) < 1) {\n            LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, parent, path_key_expr[-i], path_key_expr-i);\n            return -parsed;\n        }\n        pke_parsed += i;\n\n        for (i = 0, dst_node = parent; i < dest_parent_times; ++i) {\n            if (!dst_node) {\n                /* we went too much into parents, there is no parent anymore */\n                LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref predicate\", path_key_expr);\n                return 0;\n            }\n\n            if (dst_node->parent && (dst_node->parent->nodetype == LYS_AUGMENT)\n                    && !((struct lys_node_augment *)dst_node->parent)->target) {\n                /* we are in an unresolved augment, cannot evaluate */\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, dst_node->parent,\n                       \"Cannot resolve leafref predicate \\\"%s\\\" because it is in an unresolved augment.\", path_key_expr);\n                return 0;\n            }\n\n            /* path is supposed to be evaluated in data tree, so we have to skip\n             * all schema nodes that cannot be instantiated in data tree */\n            for (dst_node = lys_parent(dst_node);\n                 dst_node && !(dst_node->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_ACTION | LYS_NOTIF | LYS_RPC));\n                 dst_node = lys_parent(dst_node));\n        }\n        while (1) {\n            if (dest_pref) {\n                trg_mod = lyp_get_module(lys_node_module(parent), NULL, 0, dest_pref, dest_pref_len, 0);\n            } else {\n                trg_mod = lys_node_module(parent);\n            }\n            rc = lys_getnext_data(trg_mod, dst_node, dest, dest_len, LYS_CONTAINER | LYS_LIST | LYS_LEAF,\n                                  LYS_GETNEXT_NOSTATECHECK, &dst_node);\n            if (rc) {\n                LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref predicate\", path_key_expr);\n                return 0;\n            }\n\n            if (pke_len == pke_parsed) {\n                break;\n            }\n\n            if ((i = parse_path_key_expr(path_key_expr + pke_parsed, &dest_pref, &dest_pref_len, &dest, &dest_len,\n                                         &dest_parent_times)) < 1) {\n                LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, parent,\n                       (path_key_expr + pke_parsed)[-i], (path_key_expr + pke_parsed)-i);\n                return -parsed;\n            }\n            pke_parsed += i;\n        }\n\n        /* check source - dest match */\n        if (dst_node->nodetype != src_node->nodetype) {\n            LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref predicate\", path - parsed);\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Destination node is not a %s, but a %s.\",\n                   strnodetype(src_node->nodetype), strnodetype(dst_node->nodetype));\n            return -parsed;\n        }\n    } while (has_predicate);\n\n    return parsed;\n}\n\nstatic int\ncheck_leafref_features(struct lys_type *type)\n{\n    struct lys_node *iter;\n    struct ly_set *src_parents, *trg_parents, *features;\n    struct lys_node_augment *aug;\n    struct ly_ctx *ctx = ((struct lys_tpdf *)type->parent)->module->ctx;\n    unsigned int i, j, size, x;\n    int ret = EXIT_SUCCESS;\n\n    assert(type->parent);\n\n    src_parents = ly_set_new();\n    trg_parents = ly_set_new();\n    features = ly_set_new();\n\n    /* get parents chain of source (leafref) */\n    for (iter = (struct lys_node *)type->parent; iter; iter = lys_parent(iter)) {\n        if (iter->nodetype & (LYS_INPUT | LYS_OUTPUT)) {\n            continue;\n        }\n        if (iter->parent && (iter->parent->nodetype == LYS_AUGMENT)) {\n            aug = (struct lys_node_augment *)iter->parent;\n            if ((aug->module->implemented && (aug->flags & LYS_NOTAPPLIED)) || !aug->target) {\n                /* unresolved augment, wait until it's resolved */\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, aug,\n                       \"Cannot check leafref \\\"%s\\\" if-feature consistency because of an unresolved augment.\", type->info.lref.path);\n                ret = EXIT_FAILURE;\n                goto cleanup;\n            }\n            /* also add this augment */\n            ly_set_add(src_parents, aug, LY_SET_OPT_USEASLIST);\n        }\n        ly_set_add(src_parents, iter, LY_SET_OPT_USEASLIST);\n    }\n    /* get parents chain of target */\n    for (iter = (struct lys_node *)type->info.lref.target; iter; iter = lys_parent(iter)) {\n        if (iter->nodetype & (LYS_INPUT | LYS_OUTPUT)) {\n            continue;\n        }\n        if (iter->parent && (iter->parent->nodetype == LYS_AUGMENT)) {\n            aug = (struct lys_node_augment *)iter->parent;\n            if ((aug->module->implemented && (aug->flags & LYS_NOTAPPLIED)) || !aug->target) {\n                /* unresolved augment, wait until it's resolved */\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, aug,\n                       \"Cannot check leafref \\\"%s\\\" if-feature consistency because of an unresolved augment.\", type->info.lref.path);\n                ret = EXIT_FAILURE;\n                goto cleanup;\n            }\n        }\n        ly_set_add(trg_parents, iter, LY_SET_OPT_USEASLIST);\n    }\n\n    /* compare the features used in if-feature statements in the rest of both\n     * chains of parents. The set of features used for target must be a subset\n     * of features used for the leafref. This is not a perfect, we should compare\n     * the truth tables but it could require too much resources, so we simplify that */\n    for (i = 0; i < src_parents->number; i++) {\n        iter = src_parents->set.s[i]; /* shortcut */\n        if (!iter->iffeature_size) {\n            continue;\n        }\n        for (j = 0; j < iter->iffeature_size; j++) {\n            resolve_iffeature_getsizes(&iter->iffeature[j], NULL, &size);\n            for (; size; size--) {\n                if (!iter->iffeature[j].features[size - 1]) {\n                    /* not yet resolved feature, postpone this check */\n                    ret = EXIT_FAILURE;\n                    goto cleanup;\n                }\n                ly_set_add(features, iter->iffeature[j].features[size - 1], 0);\n            }\n        }\n    }\n    x = features->number;\n    for (i = 0; i < trg_parents->number; i++) {\n        iter = trg_parents->set.s[i]; /* shortcut */\n        if (!iter->iffeature_size) {\n            continue;\n        }\n        for (j = 0; j < iter->iffeature_size; j++) {\n            resolve_iffeature_getsizes(&iter->iffeature[j], NULL, &size);\n            for (; size; size--) {\n                if (!iter->iffeature[j].features[size - 1]) {\n                    /* not yet resolved feature, postpone this check */\n                    ret = EXIT_FAILURE;\n                    goto cleanup;\n                }\n                if ((unsigned)ly_set_add(features, iter->iffeature[j].features[size - 1], 0) >= x) {\n                    /* the feature is not present in features set of target's parents chain */\n                    LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, type->parent, \"leafref\", type->info.lref.path);\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                           \"Leafref is not conditional based on \\\"%s\\\" feature as its target.\",\n                           iter->iffeature[j].features[size - 1]->name);\n                    ret = -1;\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\ncleanup:\n    ly_set_free(features);\n    ly_set_free(src_parents);\n    ly_set_free(trg_parents);\n\n    return ret;\n}\n\n/**\n * @brief Resolve a path (leafref) in JSON schema context. Logs directly.\n *\n * @param[in] path Path to use.\n * @param[in] parent_node Parent of the leafref.\n * @param[out] ret Pointer to the resolved schema node. Can be NULL.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_schema_leafref(struct lys_type *type, struct lys_node *parent, struct unres_schema *unres)\n{\n    const struct lys_node *node, *op_node = NULL, *tmp_parent;\n    struct lys_node_augment *last_aug;\n    const struct lys_module *tmp_mod, *cur_module;\n    const char *id, *prefix, *name;\n    int pref_len, nam_len, parent_times, has_predicate;\n    int i, first_iter;\n    struct ly_ctx *ctx = parent->module->ctx;\n\n    if (!type->info.lref.target) {\n        first_iter = 1;\n        parent_times = 0;\n        id = type->info.lref.path;\n\n        /* find operation schema we are in */\n        for (op_node = lys_parent(parent);\n            op_node && !(op_node->nodetype & (LYS_ACTION | LYS_NOTIF | LYS_RPC));\n            op_node = lys_parent(op_node));\n\n        cur_module = lys_node_module(parent);\n        do {\n            if ((i = parse_path_arg(cur_module, id, &prefix, &pref_len, &name, &nam_len, &parent_times, &has_predicate)) < 1) {\n                LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, parent, id[-i], &id[-i]);\n                return -1;\n            }\n            id += i;\n\n            /* get the current module */\n            tmp_mod = prefix ? lyp_get_module(cur_module, NULL, 0, prefix, pref_len, 0) : cur_module;\n            if (!tmp_mod) {\n                LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);\n                return EXIT_FAILURE;\n            }\n            last_aug = NULL;\n\n            if (first_iter) {\n                if (parent_times == -1) {\n                    /* use module data */\n                    node = NULL;\n\n                } else if (parent_times > 0) {\n                    /* we are looking for the right parent */\n                    for (i = 0, node = parent; i < parent_times; i++) {\n                        if (node->parent && (node->parent->nodetype == LYS_AUGMENT)\n                                && !((struct lys_node_augment *)node->parent)->target) {\n                            /* we are in an unresolved augment, cannot evaluate */\n                            LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, node->parent,\n                                \"Cannot resolve leafref \\\"%s\\\" because it is in an unresolved augment.\", type->info.lref.path);\n                            return EXIT_FAILURE;\n                        }\n\n                        /* path is supposed to be evaluated in data tree, so we have to skip\n                        * all schema nodes that cannot be instantiated in data tree */\n                        for (node = lys_parent(node);\n                            node && !(node->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_ACTION | LYS_NOTIF | LYS_RPC));\n                            node = lys_parent(node));\n\n                        if (!node) {\n                            if (i == parent_times - 1) {\n                                /* top-level */\n                                break;\n                            }\n\n                            /* higher than top-level */\n                            LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);\n                            return EXIT_FAILURE;\n                        }\n                    }\n                } else {\n                    LOGINT(ctx);\n                    return -1;\n                }\n            }\n\n            /* find the next node (either in unconnected augment or as a schema sibling, node is NULL for top-level node -\n            * - useless to search for that in augments) */\n            if (!tmp_mod->implemented && node) {\n    get_next_augment:\n                last_aug = lys_getnext_target_aug(last_aug, tmp_mod, node);\n            }\n\n            tmp_parent = (last_aug ? (struct lys_node *)last_aug : node);\n            node = NULL;\n            while ((node = lys_getnext(node, tmp_parent, tmp_mod, LYS_GETNEXT_NOSTATECHECK))) {\n                if (lys_node_module(node) != lys_main_module(tmp_mod)) {\n                    continue;\n                }\n                if (strncmp(node->name, name, nam_len) || node->name[nam_len]) {\n                    continue;\n                }\n                /* match */\n                break;\n            }\n            if (!node) {\n                if (last_aug) {\n                    /* restore the correct augment target */\n                    node = last_aug->target;\n                    goto get_next_augment;\n                }\n                LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);\n                return EXIT_FAILURE;\n            }\n\n            if (first_iter) {\n                /* set external dependency flag, we can decide based on the first found node */\n                if (resolve_schema_leafref_valid_dep_flag(op_node, cur_module, node, (parent_times == -1 ? 1 : 0))) {\n                    parent->flags |= LYS_LEAFREF_DEP;\n                }\n                first_iter = 0;\n            }\n\n            if (has_predicate) {\n                /* we have predicate, so the current result must be list */\n                if (node->nodetype != LYS_LIST) {\n                    LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);\n                    return -1;\n                }\n\n                i = resolve_schema_leafref_predicate(id, node, parent);\n                if (!i) {\n                    return EXIT_FAILURE;\n                } else if (i < 0) {\n                    return -1;\n                }\n                id += i;\n                has_predicate = 0;\n            }\n        } while (id[0]);\n\n        /* the target must be leaf or leaf-list (in YANG 1.1 only) */\n        if ((node->nodetype != LYS_LEAF) && (node->nodetype != LYS_LEAFLIST)) {\n            LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Leafref target \\\"%s\\\" is not a leaf nor a leaf-list.\", type->info.lref.path);\n            return -1;\n        }\n\n        /* check status */\n        if (lyp_check_status(parent->flags, parent->module, parent->name,\n                        node->flags, node->module, node->name, node)) {\n            return -1;\n        }\n\n        /* assign */\n        type->info.lref.target = (struct lys_node_leaf *)node;\n    }\n\n    /* as the last thing traverse this leafref and make targets on the path implemented */\n    if (lys_node_module(parent)->implemented) {\n        /* make all the modules in the path implemented */\n        for (node = (struct lys_node *)type->info.lref.target; node; node = lys_parent(node)) {\n            if (!lys_node_module(node)->implemented) {\n                lys_node_module(node)->implemented = 1;\n                if (unres_schema_add_node(lys_node_module(node), unres, NULL, UNRES_MOD_IMPLEMENT, NULL) == -1) {\n                    return -1;\n                }\n            }\n        }\n\n        /* store the backlink from leafref target */\n        if (lys_leaf_add_leafref_target(type->info.lref.target, (struct lys_node *)type->parent)) {\n            return -1;\n        }\n    }\n\n    /* check if leafref and its target are under common if-features */\n    return check_leafref_features(type);\n}\n\n/**\n * @brief Compare 2 data node values.\n *\n * Comparison performed on canonical forms, the first value\n * is first transformed into canonical form.\n *\n * @param[in] node Leaf/leaf-list with these values.\n * @param[in] noncan_val Non-canonical value.\n * @param[in] noncan_val_len Length of \\p noncal_val.\n * @param[in] can_val Canonical value.\n * @return 1 if equal, 0 if not, -1 on error (logged).\n */\nstatic int\nvalequal(struct lys_node *node, const char *noncan_val, int noncan_val_len, const char *can_val)\n{\n    int ret;\n    struct lyd_node_leaf_list leaf;\n    struct lys_node_leaf *sleaf = (struct lys_node_leaf*)node;\n\n    /* dummy leaf */\n    memset(&leaf, 0, sizeof leaf);\n    leaf.value_str = lydict_insert(node->module->ctx, noncan_val, noncan_val_len);\n\nrepeat:\n    leaf.value_type = sleaf->type.base;\n    leaf.schema = node;\n\n    if (leaf.value_type == LY_TYPE_LEAFREF) {\n        if (!sleaf->type.info.lref.target) {\n            /* it should either be unresolved leafref (leaf.value_type are ORed flags) or it will be resolved */\n            LOGINT(node->module->ctx);\n            ret = -1;\n            goto finish;\n        }\n        sleaf = sleaf->type.info.lref.target;\n        goto repeat;\n    } else {\n        if (!lyp_parse_value(&sleaf->type, &leaf.value_str, NULL, &leaf, NULL, NULL, 0, 0, 0)) {\n            ret = -1;\n            goto finish;\n        }\n    }\n\n    if (!strcmp(leaf.value_str, can_val)) {\n        ret = 1;\n    } else {\n        ret = 0;\n    }\n\nfinish:\n    lydict_remove(node->module->ctx, leaf.value_str);\n    return ret;\n}\n\n/**\n * @brief Resolve instance-identifier predicate in JSON data format.\n *        Does not log.\n *\n * @param[in] prev_mod Previous module to use in case there is no prefix.\n * @param[in] pred Predicate to use.\n * @param[in,out] node Node matching the restriction without\n *                     the predicate. If it does not satisfy the predicate,\n *                     it is set to NULL.\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nresolve_instid_predicate(const struct lys_module *prev_mod, const char *pred, struct lyd_node **node, int cur_idx)\n{\n    /* ... /node[key=value] ... */\n    struct lyd_node_leaf_list *key;\n    struct lys_node_leaf **list_keys = NULL;\n    struct lys_node_list *slist = NULL;\n    const char *model, *name, *value;\n    int mod_len, nam_len, val_len, i, has_predicate, parsed;\n    struct ly_ctx *ctx = prev_mod->ctx;\n\n    assert(pred && node && *node);\n\n    parsed = 0;\n    do {\n        if ((i = parse_predicate(pred + parsed, &model, &mod_len, &name, &nam_len, &value, &val_len, &has_predicate)) < 1) {\n            return -parsed + i;\n        }\n        parsed += i;\n\n        if (!(*node)) {\n            /* just parse it all */\n            continue;\n        }\n\n        /* target */\n        if (name[0] == '.') {\n            /* leaf-list value */\n            if ((*node)->schema->nodetype != LYS_LEAFLIST) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects leaf-list, but have %s \\\"%s\\\".\",\n                       strnodetype((*node)->schema->nodetype), (*node)->schema->name);\n                parsed = -1;\n                goto cleanup;\n            }\n\n            /* check the value */\n            if (!valequal((*node)->schema, value, val_len, ((struct lyd_node_leaf_list *)*node)->value_str)) {\n                *node = NULL;\n                goto cleanup;\n            }\n\n        } else if (isdigit(name[0])) {\n            assert(!value);\n\n            /* keyless list position */\n            if ((*node)->schema->nodetype != LYS_LIST) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects list, but have %s \\\"%s\\\".\",\n                       strnodetype((*node)->schema->nodetype), (*node)->schema->name);\n                parsed = -1;\n                goto cleanup;\n            }\n\n            if (((struct lys_node_list *)(*node)->schema)->keys) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects list without keys, but have list \\\"%s\\\".\",\n                       (*node)->schema->name);\n                parsed = -1;\n                goto cleanup;\n            }\n\n            /* check the index */\n            if (atoi(name) != cur_idx) {\n                *node = NULL;\n                goto cleanup;\n            }\n\n        } else {\n            /* list key value */\n            if ((*node)->schema->nodetype != LYS_LIST) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects list, but have %s \\\"%s\\\".\",\n                       strnodetype((*node)->schema->nodetype), (*node)->schema->name);\n                parsed = -1;\n                goto cleanup;\n            }\n            slist = (struct lys_node_list *)(*node)->schema;\n\n            /* prepare key array */\n            if (!list_keys) {\n                list_keys = malloc(slist->keys_size * sizeof *list_keys);\n                LY_CHECK_ERR_RETURN(!list_keys, LOGMEM(ctx), -1);\n                for (i = 0; i < slist->keys_size; ++i) {\n                    list_keys[i] = slist->keys[i];\n                }\n            }\n\n            /* find the schema key leaf */\n            for (i = 0; i < slist->keys_size; ++i) {\n                if (list_keys[i] && !strncmp(list_keys[i]->name, name, nam_len) && !list_keys[i]->name[nam_len]) {\n                    break;\n                }\n            }\n            if (i == slist->keys_size) {\n                /* this list has no such key */\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects list with the key \\\"%.*s\\\",\"\n                       \" but list \\\"%s\\\" does not define it.\", nam_len, name, slist->name);\n                parsed = -1;\n                goto cleanup;\n            }\n\n            /* check module */\n            if (model) {\n                if (strncmp(list_keys[i]->module->name, model, mod_len) || list_keys[i]->module->name[mod_len]) {\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects key \\\"%s\\\" from module \\\"%.*s\\\", not \\\"%s\\\".\",\n                           list_keys[i]->name, model, mod_len, list_keys[i]->module->name);\n                    parsed = -1;\n                    goto cleanup;\n                }\n            } else {\n                if (list_keys[i]->module != prev_mod) {\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects key \\\"%s\\\" from module \\\"%s\\\", not \\\"%s\\\".\",\n                           list_keys[i]->name, prev_mod->name, list_keys[i]->module->name);\n                    parsed = -1;\n                    goto cleanup;\n                }\n            }\n\n            /* find the actual data key */\n            for (key = (struct lyd_node_leaf_list *)(*node)->child; key; key = (struct lyd_node_leaf_list *)key->next) {\n                if (key->schema == (struct lys_node *)list_keys[i]) {\n                    break;\n                }\n            }\n            if (!key) {\n                /* list instance is missing a key? definitely should not happen */\n                LOGINT(ctx);\n                parsed = -1;\n                goto cleanup;\n            }\n\n            /* check the value */\n            if (!valequal(key->schema, value, val_len, key->value_str)) {\n                *node = NULL;\n                /* we still want to parse the whole predicate */\n                continue;\n            }\n\n            /* everything is fine, mark this key as resolved */\n            list_keys[i] = NULL;\n        }\n    } while (has_predicate);\n\n    /* check that all list keys were specified */\n    if (*node && list_keys) {\n        for (i = 0; i < slist->keys_size; ++i) {\n            if (list_keys[i]) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier is missing list key \\\"%s\\\".\", list_keys[i]->name);\n                parsed = -1;\n                goto cleanup;\n            }\n        }\n    }\n\ncleanup:\n    free(list_keys);\n    return parsed;\n}\n\nstatic int\ncheck_xpath(struct lys_node *node, int check_place)\n{\n    struct lys_node *parent;\n    struct lyxp_set set;\n    enum int_log_opts prev_ilo;\n\n    if (check_place) {\n        parent = node;\n        while (parent) {\n            if (parent->nodetype == LYS_GROUPING) {\n                /* unresolved grouping, skip for now (will be checked later) */\n                return EXIT_SUCCESS;\n            }\n            if (parent->nodetype == LYS_AUGMENT) {\n                if (!((struct lys_node_augment *)parent)->target) {\n                    /* unresolved augment, skip for now (will be checked later) */\n                    return EXIT_FAILURE;\n                } else {\n                    parent = ((struct lys_node_augment *)parent)->target;\n                    continue;\n                }\n            }\n            parent = parent->parent;\n        }\n    }\n\n    memset(&set, 0, sizeof set);\n\n    /* produce just warnings */\n    ly_ilo_change(NULL, ILO_ERR2WRN, &prev_ilo, NULL);\n    lyxp_node_atomize(node, &set, 1);\n    ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n\n    if (set.val.snodes) {\n        free(set.val.snodes);\n    }\n    return EXIT_SUCCESS;\n}\n\nstatic int\ncheck_leafref_config(struct lys_node_leaf *leaf, struct lys_type *type)\n{\n    unsigned int i;\n\n    if (type->base == LY_TYPE_LEAFREF) {\n        if ((leaf->flags & LYS_CONFIG_W) && type->info.lref.target && type->info.lref.req != -1 &&\n                (type->info.lref.target->flags & LYS_CONFIG_R)) {\n            LOGVAL(leaf->module->ctx, LYE_SPEC, LY_VLOG_LYS, leaf, \"The leafref %s is config but refers to a non-config %s.\",\n                   strnodetype(leaf->nodetype), strnodetype(type->info.lref.target->nodetype));\n            return -1;\n        }\n        /* we can skip the test in case the leafref is not yet resolved. In that case the test is done in the time\n         * of leafref resolving (lys_leaf_add_leafref_target()) */\n    } else if (type->base == LY_TYPE_UNION) {\n        for (i = 0; i < type->info.uni.count; i++) {\n            if (check_leafref_config(leaf, &type->info.uni.types[i])) {\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n\n/**\n * @brief Passes config flag down to children, skips nodes without config flags.\n * Logs.\n *\n * @param[in] node Siblings and their children to have flags changed.\n * @param[in] clear Flag to clear all config flags if parent is LYS_NOTIF, LYS_INPUT, LYS_OUTPUT, LYS_RPC.\n * @param[in] flags Flags to assign to all the nodes.\n * @param[in,out] unres List of unresolved items.\n *\n * @return 0 on success, -1 on error.\n */\nint\ninherit_config_flag(struct lys_node *node, int flags, int clear)\n{\n    struct lys_node_leaf *leaf;\n    struct ly_ctx *ctx;\n\n    if (!node) {\n        return 0;\n    }\n\n    assert(!(flags ^ (flags & LYS_CONFIG_MASK)));\n    ctx = node->module->ctx;\n\n    LY_TREE_FOR(node, node) {\n        if (clear) {\n            node->flags &= ~LYS_CONFIG_MASK;\n            node->flags &= ~LYS_CONFIG_SET;\n        } else {\n            if (node->flags & LYS_CONFIG_SET) {\n                /* skip nodes with an explicit config value */\n                if ((flags & LYS_CONFIG_R) && (node->flags & LYS_CONFIG_W)) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, node, \"true\", \"config\");\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"State nodes cannot have configuration nodes as children.\");\n                    return -1;\n                }\n                continue;\n            }\n\n            if (!(node->nodetype & (LYS_USES | LYS_GROUPING))) {\n                node->flags = (node->flags & ~LYS_CONFIG_MASK) | flags;\n                /* check that configuration lists have keys */\n                if ((node->nodetype == LYS_LIST) && (node->flags & LYS_CONFIG_W)\n                        && !((struct lys_node_list *)node)->keys_size) {\n                    LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, node, \"key\", \"list\");\n                    return -1;\n                }\n            }\n        }\n        if (!(node->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA))) {\n            if (inherit_config_flag(node->child, flags, clear)) {\n                return -1;\n            }\n        } else if (node->nodetype & (LYS_LEAF | LYS_LEAFLIST)) {\n            leaf = (struct lys_node_leaf *)node;\n            if (check_leafref_config(leaf, &leaf->type)) {\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}\n\n/**\n * @brief Resolve augment target. Logs directly.\n *\n * @param[in] aug Augment to use.\n * @param[in] uses Parent where to start the search in. If set, uses augment, if not, standalone augment.\n * @param[in,out] unres List of unresolved items.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_augment(struct lys_node_augment *aug, struct lys_node *uses, struct unres_schema *unres)\n{\n    int rc;\n    struct lys_node *sub;\n    struct lys_module *mod;\n    struct ly_set *set;\n    struct ly_ctx *ctx;\n\n    assert(aug);\n    mod = lys_main_module(aug->module);\n    ctx = mod->ctx;\n\n    /* set it as not applied for now */\n    aug->flags |= LYS_NOTAPPLIED;\n\n    /* it can already be resolved in case we returned EXIT_FAILURE from if block below */\n    if (!aug->target) {\n        /* resolve target node */\n        rc = resolve_schema_nodeid(aug->target_name, uses, (uses ? NULL : lys_node_module((struct lys_node *)aug)), &set, 0, 0);\n        if (rc == -1) {\n            LOGVAL(ctx, LYE_PATH, LY_VLOG_LYS, aug);\n            return -1;\n        }\n        if (!set) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, aug, \"augment\", aug->target_name);\n            return EXIT_FAILURE;\n        }\n        aug->target = set->set.s[0];\n        ly_set_free(set);\n    }\n\n    /* make this module implemented if the target module is (if the target is in an unimplemented module,\n     * it is fine because when we will be making that module implemented, its augment will be applied\n     * and that augment target module made implemented, recursively) */\n    if (mod->implemented && !lys_node_module(aug->target)->implemented) {\n        lys_node_module(aug->target)->implemented = 1;\n        if (unres_schema_add_node(lys_node_module(aug->target), unres, NULL, UNRES_MOD_IMPLEMENT, NULL) == -1) {\n            return -1;\n        }\n    }\n\n    /* check for mandatory nodes - if the target node is in another module\n     * the added nodes cannot be mandatory\n     */\n    if (!aug->parent && (lys_node_module((struct lys_node *)aug) != lys_node_module(aug->target))\n            && (rc = lyp_check_mandatory_augment(aug, aug->target))) {\n        return rc;\n    }\n\n    /* check augment target type and then augment nodes type */\n    if (aug->target->nodetype & (LYS_CONTAINER | LYS_LIST)) {\n        LY_TREE_FOR(aug->child, sub) {\n            if (!(sub->nodetype & (LYS_ANYDATA | LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_USES\n                                   | LYS_CHOICE | LYS_ACTION | LYS_NOTIF))) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, aug, strnodetype(sub->nodetype), \"augment\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Cannot augment \\\"%s\\\" with a \\\"%s\\\".\",\n                       strnodetype(aug->target->nodetype), strnodetype(sub->nodetype));\n                return -1;\n            }\n        }\n    } else if (aug->target->nodetype & (LYS_CASE | LYS_INPUT | LYS_OUTPUT | LYS_NOTIF)) {\n        LY_TREE_FOR(aug->child, sub) {\n            if (!(sub->nodetype & (LYS_ANYDATA | LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_USES | LYS_CHOICE))) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, aug, strnodetype(sub->nodetype), \"augment\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Cannot augment \\\"%s\\\" with a \\\"%s\\\".\",\n                       strnodetype(aug->target->nodetype), strnodetype(sub->nodetype));\n                return -1;\n            }\n        }\n    } else if (aug->target->nodetype == LYS_CHOICE) {\n        LY_TREE_FOR(aug->child, sub) {\n            if (!(sub->nodetype & (LYS_CASE | LYS_ANYDATA | LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST))) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, aug, strnodetype(sub->nodetype), \"augment\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Cannot augment \\\"%s\\\" with a \\\"%s\\\".\",\n                       strnodetype(aug->target->nodetype), strnodetype(sub->nodetype));\n                return -1;\n            }\n        }\n    } else {\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, aug, aug->target_name, \"target-node\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Invalid augment target node type \\\"%s\\\".\", strnodetype(aug->target->nodetype));\n        return -1;\n    }\n\n    /* check identifier uniqueness as in lys_node_addchild() */\n    LY_TREE_FOR(aug->child, sub) {\n        if (lys_check_id(sub, aug->target, NULL)) {\n            return -1;\n        }\n    }\n\n    if (!aug->child) {\n        /* empty augment, nothing to connect, but it is techincally applied */\n        LOGWRN(ctx, \"Augment \\\"%s\\\" without children.\", aug->target_name);\n        aug->flags &= ~LYS_NOTAPPLIED;\n    } else if ((aug->parent || mod->implemented) && apply_aug(aug, unres)) {\n        /* we try to connect the augment only in case the module is implemented or\n         * the augment applies on the used grouping, anyway we failed here */\n        return -1;\n    }\n\n    return EXIT_SUCCESS;\n}\n\nstatic int\nresolve_extension(struct unres_ext *info, struct lys_ext_instance **ext, struct unres_schema *unres)\n{\n    enum LY_VLOG_ELEM vlog_type;\n    void *vlog_node;\n    unsigned int i, j;\n    struct lys_ext *e;\n    char *ext_name, *ext_prefix, *tmp;\n    struct lyxml_elem *next_yin, *yin;\n    const struct lys_module *mod;\n    struct lys_ext_instance *tmp_ext;\n    struct ly_ctx *ctx = NULL;\n    LYEXT_TYPE etype;\n\n    switch (info->parent_type) {\n    case LYEXT_PAR_NODE:\n        vlog_node = info->parent;\n        vlog_type = LY_VLOG_LYS;\n        break;\n    case LYEXT_PAR_MODULE:\n    case LYEXT_PAR_IMPORT:\n    case LYEXT_PAR_INCLUDE:\n        vlog_node = NULL;\n        vlog_type = LY_VLOG_LYS;\n        break;\n    default:\n        vlog_node = NULL;\n        vlog_type = LY_VLOG_NONE;\n        break;\n    }\n\n    if (info->datatype == LYS_IN_YIN) {\n        /* YIN */\n\n        /* get the module where the extension is supposed to be defined */\n        mod = lyp_get_import_module_ns(info->mod, info->data.yin->ns->value);\n        if (!mod) {\n            LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, info->data.yin->name);\n            return EXIT_FAILURE;\n        }\n        ctx = mod->ctx;\n\n        /* find the extension definition */\n        e = NULL;\n        for (i = 0; i < mod->extensions_size; i++) {\n            if (ly_strequal(mod->extensions[i].name, info->data.yin->name, 1)) {\n                e = &mod->extensions[i];\n                break;\n            }\n        }\n        /* try submodules */\n        for (j = 0; !e && j < mod->inc_size; j++) {\n            for (i = 0; i < mod->inc[j].submodule->extensions_size; i++) {\n                if (ly_strequal(mod->inc[j].submodule->extensions[i].name, info->data.yin->name, 1)) {\n                    e = &mod->inc[j].submodule->extensions[i];\n                    break;\n                }\n            }\n        }\n        if (!e) {\n            LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, info->data.yin->name);\n            return EXIT_FAILURE;\n        }\n\n        /* we have the extension definition, so now it cannot be forward referenced and error is always fatal */\n\n        if (e->plugin && e->plugin->check_position) {\n            /* common part - we have plugin with position checking function, use it first */\n            if ((*e->plugin->check_position)(info->parent, info->parent_type, info->substmt)) {\n                /* extension is not allowed here */\n                LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, e->name);\n                return -1;\n            }\n        }\n\n        /* extension type-specific part - allocation */\n        if (e->plugin) {\n            etype = e->plugin->type;\n        } else {\n            /* default type */\n            etype = LYEXT_FLAG;\n        }\n        switch (etype) {\n        case LYEXT_FLAG:\n            (*ext) = calloc(1, sizeof(struct lys_ext_instance));\n            break;\n        case LYEXT_COMPLEX:\n            (*ext) = calloc(1, ((struct lyext_plugin_complex*)e->plugin)->instance_size);\n            break;\n        case LYEXT_ERR:\n            /* we never should be here */\n            LOGINT(ctx);\n            return -1;\n        }\n        LY_CHECK_ERR_RETURN(!*ext, LOGMEM(ctx), -1);\n\n        /* common part for all extension types */\n        (*ext)->def = e;\n        (*ext)->parent = info->parent;\n        (*ext)->parent_type = info->parent_type;\n        (*ext)->insubstmt = info->substmt;\n        (*ext)->insubstmt_index = info->substmt_index;\n        (*ext)->ext_type = e->plugin ? e->plugin->type : LYEXT_FLAG;\n        (*ext)->flags |= e->plugin ? e->plugin->flags : 0;\n\n        if (e->argument) {\n            if (!(e->flags & LYS_YINELEM)) {\n                (*ext)->arg_value = lyxml_get_attr(info->data.yin, e->argument, NULL);\n                if (!(*ext)->arg_value) {\n                    LOGVAL(ctx, LYE_MISSARG, LY_VLOG_NONE, NULL, e->argument, info->data.yin->name);\n                    return -1;\n                }\n\n                (*ext)->arg_value = lydict_insert(mod->ctx, (*ext)->arg_value, 0);\n            } else {\n                LY_TREE_FOR_SAFE(info->data.yin->child, next_yin, yin) {\n                    if (ly_strequal(yin->name, e->argument, 1)) {\n                        (*ext)->arg_value = lydict_insert(mod->ctx, yin->content, 0);\n                        lyxml_free(mod->ctx, yin);\n                        break;\n                    }\n                }\n            }\n        }\n\n        if ((*ext)->flags & LYEXT_OPT_VALID &&\n            (info->parent_type == LYEXT_PAR_NODE || info->parent_type == LYEXT_PAR_TPDF)) {\n            ((struct lys_node *)info->parent)->flags |= LYS_VALID_EXT;\n        }\n\n        (*ext)->nodetype = LYS_EXT;\n        (*ext)->module = info->mod;\n\n        /* extension type-specific part - parsing content */\n        switch (etype) {\n        case LYEXT_FLAG:\n            LY_TREE_FOR_SAFE(info->data.yin->child, next_yin, yin) {\n                if (!yin->ns) {\n                    /* garbage */\n                    lyxml_free(mod->ctx, yin);\n                    continue;\n                } else if (!strcmp(yin->ns->value, LY_NSYIN)) {\n                    /* standard YANG statements are not expected here */\n                    LOGVAL(ctx, LYE_INCHILDSTMT, vlog_type, vlog_node, yin->name, info->data.yin->name);\n                    return -1;\n                } else if (yin->ns == info->data.yin->ns &&\n                        (e->flags & LYS_YINELEM) && ly_strequal(yin->name, e->argument, 1)) {\n                    /* we have the extension's argument */\n                    if ((*ext)->arg_value) {\n                        LOGVAL(ctx, LYE_TOOMANY, vlog_type, vlog_node, yin->name, info->data.yin->name);\n                        return -1;\n                    }\n                    (*ext)->arg_value = yin->content;\n                    yin->content = NULL;\n                    lyxml_free(mod->ctx, yin);\n                } else {\n                    /* extension instance */\n                    if (lyp_yin_parse_subnode_ext(info->mod, *ext, LYEXT_PAR_EXTINST, yin,\n                                                  LYEXT_SUBSTMT_SELF, 0, unres)) {\n                        return -1;\n                    }\n\n                    continue;\n                }\n            }\n            break;\n        case LYEXT_COMPLEX:\n            ((struct lys_ext_instance_complex*)(*ext))->substmt = ((struct lyext_plugin_complex*)e->plugin)->substmt;\n            if (lyp_yin_parse_complex_ext(info->mod, (struct lys_ext_instance_complex*)(*ext), info->data.yin, unres)) {\n                /* TODO memory cleanup */\n                return -1;\n            }\n            break;\n        default:\n            break;\n        }\n\n        /* TODO - lyext_check_result_clb, other than LYEXT_FLAG plugins */\n\n    } else {\n        /* YANG */\n\n        ext_prefix = (char *)(*ext)->def;\n        tmp = strchr(ext_prefix, ':');\n        if (!tmp) {\n            LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, ext_prefix);\n            goto error;\n        }\n        ext_name = tmp + 1;\n\n        /* get the module where the extension is supposed to be defined */\n        mod = lyp_get_module(info->mod, ext_prefix, tmp - ext_prefix, NULL, 0, 0);\n        if (!mod) {\n            LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, ext_prefix);\n            return EXIT_FAILURE;\n        }\n        ctx = mod->ctx;\n\n        /* find the extension definition */\n        e = NULL;\n        for (i = 0; i < mod->extensions_size; i++) {\n            if (ly_strequal(mod->extensions[i].name, ext_name, 0)) {\n                e = &mod->extensions[i];\n                break;\n            }\n        }\n        /* try submodules */\n        for (j = 0; !e && j < mod->inc_size; j++) {\n            for (i = 0; i < mod->inc[j].submodule->extensions_size; i++) {\n                if (ly_strequal(mod->inc[j].submodule->extensions[i].name, ext_name, 0)) {\n                    e = &mod->inc[j].submodule->extensions[i];\n                    break;\n                }\n            }\n        }\n        if (!e) {\n            LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, ext_prefix);\n            return EXIT_FAILURE;\n        }\n\n        (*ext)->flags &= ~LYEXT_OPT_YANG;\n        (*ext)->def = NULL;\n\n        /* we have the extension definition, so now it cannot be forward referenced and error is always fatal */\n\n        if (e->plugin && e->plugin->check_position) {\n            /* common part - we have plugin with position checking function, use it first */\n            if ((*e->plugin->check_position)(info->parent, info->parent_type, info->substmt)) {\n                /* extension is not allowed here */\n                LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, e->name);\n                goto error;\n            }\n        }\n\n        /* extension common part */\n        (*ext)->def = e;\n        (*ext)->parent = info->parent;\n        (*ext)->ext_type = e->plugin ? e->plugin->type : LYEXT_FLAG;\n        (*ext)->flags |= e->plugin ? e->plugin->flags : 0;\n\n        if (e->argument && !(*ext)->arg_value) {\n            LOGVAL(ctx, LYE_MISSARG, LY_VLOG_NONE, NULL, e->argument, ext_name);\n            goto error;\n        }\n\n        if ((*ext)->flags & LYEXT_OPT_VALID &&\n            (info->parent_type == LYEXT_PAR_NODE || info->parent_type == LYEXT_PAR_TPDF)) {\n            ((struct lys_node *)info->parent)->flags |= LYS_VALID_EXT;\n        }\n\n        (*ext)->module = info->mod;\n        (*ext)->nodetype = LYS_EXT;\n\n        /* extension type-specific part */\n        if (e->plugin) {\n            etype = e->plugin->type;\n        } else {\n            /* default type */\n            etype = LYEXT_FLAG;\n        }\n        switch (etype) {\n        case LYEXT_FLAG:\n            /* nothing change */\n            break;\n        case LYEXT_COMPLEX:\n            tmp_ext = realloc(*ext, ((struct lyext_plugin_complex*)e->plugin)->instance_size);\n            LY_CHECK_ERR_GOTO(!tmp_ext, LOGMEM(ctx), error);\n            memset((char *)tmp_ext + offsetof(struct lys_ext_instance_complex, content), 0,\n                   ((struct lyext_plugin_complex*)e->plugin)->instance_size - offsetof(struct lys_ext_instance_complex, content));\n            (*ext) = tmp_ext;\n            ((struct lys_ext_instance_complex*)(*ext))->substmt = ((struct lyext_plugin_complex*)e->plugin)->substmt;\n            if (info->data.yang) {\n                *tmp = ':';\n                if (yang_parse_ext_substatement(info->mod, unres, info->data.yang->ext_substmt, ext_prefix,\n                                                (struct lys_ext_instance_complex*)(*ext))) {\n                    goto error;\n                }\n                if (yang_fill_extcomplex_module(info->mod->ctx, (struct lys_ext_instance_complex*)(*ext), ext_prefix,\n                                                info->data.yang->ext_modules, info->mod->implemented)) {\n                    goto error;\n                }\n            }\n            if (lyp_mand_check_ext((struct lys_ext_instance_complex*)(*ext), ext_prefix)) {\n                goto error;\n            }\n            break;\n        case LYEXT_ERR:\n            /* we never should be here */\n            LOGINT(ctx);\n            goto error;\n        }\n\n        if (yang_check_ext_instance(info->mod, &(*ext)->ext, (*ext)->ext_size, *ext, unres)) {\n            goto error;\n        }\n        free(ext_prefix);\n    }\n\n    return EXIT_SUCCESS;\nerror:\n    free(ext_prefix);\n    return -1;\n}\n\n/**\n * @brief Resolve (find) choice default case. Does not log.\n *\n * @param[in] choic Choice to use.\n * @param[in] dflt Name of the default case.\n *\n * @return Pointer to the default node or NULL.\n */\nstatic struct lys_node *\nresolve_choice_dflt(struct lys_node_choice *choic, const char *dflt)\n{\n    struct lys_node *child, *ret;\n\n    LY_TREE_FOR(choic->child, child) {\n        if (child->nodetype == LYS_USES) {\n            ret = resolve_choice_dflt((struct lys_node_choice *)child, dflt);\n            if (ret) {\n                return ret;\n            }\n        }\n\n        if (ly_strequal(child->name, dflt, 1) && (child->nodetype & (LYS_ANYDATA | LYS_CASE\n                | LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_CHOICE))) {\n            return child;\n        }\n    }\n\n    return NULL;\n}\n\n/**\n * @brief Resolve uses, apply augments, refines. Logs directly.\n *\n * @param[in] uses Uses to use.\n * @param[in,out] unres List of unresolved items.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nstatic int\nresolve_uses(struct lys_node_uses *uses, struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = uses->module->ctx; /* shortcut */\n    struct lys_node *node = NULL, *next, *iter, **refine_nodes = NULL;\n    struct lys_node *node_aux, *parent, *tmp;\n    struct lys_node_leaflist *llist;\n    struct lys_node_leaf *leaf;\n    struct lys_refine *rfn;\n    struct lys_restr *must, **old_must;\n    struct lys_iffeature *iff, **old_iff;\n    int i, j, k, rc;\n    uint8_t size, *old_size;\n    unsigned int usize, usize1, usize2;\n\n    assert(uses->grp);\n\n    /* check that the grouping is resolved (no unresolved uses inside) */\n    assert(!uses->grp->unres_count);\n\n    /* copy the data nodes from grouping into the uses context */\n    LY_TREE_FOR(uses->grp->child, node_aux) {\n        if (node_aux->nodetype & LYS_GROUPING) {\n            /* do not instantiate groupings from groupings */\n            continue;\n        }\n        node = lys_node_dup(uses->module, (struct lys_node *)uses, node_aux, unres, 0);\n        if (!node) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, uses->grp->name, \"uses\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Copying data from grouping failed.\");\n            goto fail;\n        }\n        /* test the name of siblings */\n        LY_TREE_FOR((uses->parent) ? *lys_child(uses->parent, LYS_USES) : lys_main_module(uses->module)->data, tmp) {\n            if (!(tmp->nodetype & (LYS_USES | LYS_GROUPING | LYS_CASE)) && ly_strequal(tmp->name, node_aux->name, 1)) {\n                goto fail;\n            }\n        }\n    }\n\n    /* we managed to copy the grouping, the rest must be possible to resolve */\n\n    if (uses->refine_size) {\n        refine_nodes = malloc(uses->refine_size * sizeof *refine_nodes);\n        LY_CHECK_ERR_GOTO(!refine_nodes, LOGMEM(ctx), fail);\n    }\n\n    /* apply refines */\n    for (i = 0; i < uses->refine_size; i++) {\n        rfn = &uses->refine[i];\n        rc = resolve_descendant_schema_nodeid(rfn->target_name, uses->child,\n                                              LYS_NO_RPC_NOTIF_NODE | LYS_ACTION | LYS_NOTIF,\n                                              0, (const struct lys_node **)&node);\n        if (rc || !node) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, rfn->target_name, \"refine\");\n            goto fail;\n        }\n\n        if (rfn->target_type && !(node->nodetype & rfn->target_type)) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, rfn->target_name, \"refine\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Refine substatements not applicable to the target-node.\");\n            goto fail;\n        }\n        refine_nodes[i] = node;\n\n        /* description on any nodetype */\n        if (rfn->dsc) {\n            lydict_remove(ctx, node->dsc);\n            node->dsc = lydict_insert(ctx, rfn->dsc, 0);\n        }\n\n        /* reference on any nodetype */\n        if (rfn->ref) {\n            lydict_remove(ctx, node->ref);\n            node->ref = lydict_insert(ctx, rfn->ref, 0);\n        }\n\n        /* config on any nodetype,\n         * in case of notification or rpc/action, the config is not applicable (there is no config status) */\n        if ((rfn->flags & LYS_CONFIG_MASK) && (node->flags & LYS_CONFIG_MASK)) {\n            node->flags &= ~LYS_CONFIG_MASK;\n            node->flags |= (rfn->flags & LYS_CONFIG_MASK);\n        }\n\n        /* default value ... */\n        if (rfn->dflt_size) {\n            if (node->nodetype == LYS_LEAF) {\n                /* leaf */\n                leaf = (struct lys_node_leaf *)node;\n\n                /* replace default value */\n                lydict_remove(ctx, leaf->dflt);\n                leaf->dflt = lydict_insert(ctx, rfn->dflt[0], 0);\n\n                /* check the default value */\n                if (unres_schema_add_node(leaf->module, unres, &leaf->type, UNRES_TYPE_DFLT,\n                                          (struct lys_node *)(&leaf->dflt)) == -1) {\n                    goto fail;\n                }\n            } else if (node->nodetype == LYS_LEAFLIST) {\n                /* leaf-list */\n                llist = (struct lys_node_leaflist *)node;\n\n                /* remove complete set of defaults in target */\n                for (j = 0; j < llist->dflt_size; j++) {\n                    lydict_remove(ctx, llist->dflt[j]);\n                }\n                free(llist->dflt);\n\n                /* copy the default set from refine */\n                llist->dflt = malloc(rfn->dflt_size * sizeof *llist->dflt);\n                LY_CHECK_ERR_GOTO(!llist->dflt, LOGMEM(ctx), fail);\n                llist->dflt_size = rfn->dflt_size;\n                for (j = 0; j < llist->dflt_size; j++) {\n                    llist->dflt[j] = lydict_insert(ctx, rfn->dflt[j], 0);\n                }\n\n                /* check default value */\n                for (j = 0; j < llist->dflt_size; j++) {\n                    if (unres_schema_add_node(llist->module, unres, &llist->type, UNRES_TYPE_DFLT,\n                                              (struct lys_node *)(&llist->dflt[j])) == -1) {\n                        goto fail;\n                    }\n                }\n            }\n        }\n\n        /* mandatory on leaf, anyxml or choice */\n        if (rfn->flags & LYS_MAND_MASK) {\n            /* remove current value */\n            node->flags &= ~LYS_MAND_MASK;\n\n            /* set new value */\n            node->flags |= (rfn->flags & LYS_MAND_MASK);\n\n            if (rfn->flags & LYS_MAND_TRUE) {\n                /* check if node has default value */\n                if ((node->nodetype & LYS_LEAF) && ((struct lys_node_leaf *)node)->dflt) {\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, uses,\n                           \"The \\\"mandatory\\\" statement is forbidden on leaf with \\\"default\\\".\");\n                    goto fail;\n                }\n                if ((node->nodetype & LYS_CHOICE) && ((struct lys_node_choice *)node)->dflt) {\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, uses,\n                           \"The \\\"mandatory\\\" statement is forbidden on choices with \\\"default\\\".\");\n                    goto fail;\n                }\n            }\n        }\n\n        /* presence on container */\n        if ((node->nodetype & LYS_CONTAINER) && rfn->mod.presence) {\n            lydict_remove(ctx, ((struct lys_node_container *)node)->presence);\n            ((struct lys_node_container *)node)->presence = lydict_insert(ctx, rfn->mod.presence, 0);\n        }\n\n        /* min/max-elements on list or leaf-list */\n        if (node->nodetype == LYS_LIST) {\n            if (rfn->flags & LYS_RFN_MINSET) {\n                ((struct lys_node_list *)node)->min = rfn->mod.list.min;\n            }\n            if (rfn->flags & LYS_RFN_MAXSET) {\n                ((struct lys_node_list *)node)->max = rfn->mod.list.max;\n            }\n        } else if (node->nodetype == LYS_LEAFLIST) {\n            if (rfn->flags & LYS_RFN_MINSET) {\n                ((struct lys_node_leaflist *)node)->min = rfn->mod.list.min;\n            }\n            if (rfn->flags & LYS_RFN_MAXSET) {\n                ((struct lys_node_leaflist *)node)->max = rfn->mod.list.max;\n            }\n        }\n\n        /* must in leaf, leaf-list, list, container or anyxml */\n        if (rfn->must_size) {\n            switch (node->nodetype) {\n            case LYS_LEAF:\n                old_size = &((struct lys_node_leaf *)node)->must_size;\n                old_must = &((struct lys_node_leaf *)node)->must;\n                break;\n            case LYS_LEAFLIST:\n                old_size = &((struct lys_node_leaflist *)node)->must_size;\n                old_must = &((struct lys_node_leaflist *)node)->must;\n                break;\n            case LYS_LIST:\n                old_size = &((struct lys_node_list *)node)->must_size;\n                old_must = &((struct lys_node_list *)node)->must;\n                break;\n            case LYS_CONTAINER:\n                old_size = &((struct lys_node_container *)node)->must_size;\n                old_must = &((struct lys_node_container *)node)->must;\n                break;\n            case LYS_ANYXML:\n            case LYS_ANYDATA:\n                old_size = &((struct lys_node_anydata *)node)->must_size;\n                old_must = &((struct lys_node_anydata *)node)->must;\n                break;\n            default:\n                LOGINT(ctx);\n                goto fail;\n            }\n\n            size = *old_size + rfn->must_size;\n            must = realloc(*old_must, size * sizeof *rfn->must);\n            LY_CHECK_ERR_GOTO(!must, LOGMEM(ctx), fail);\n            for (k = 0, j = *old_size; k < rfn->must_size; k++, j++) {\n                must[j].ext_size = rfn->must[k].ext_size;\n                lys_ext_dup(ctx, rfn->module, rfn->must[k].ext, rfn->must[k].ext_size, &rfn->must[k], LYEXT_PAR_RESTR,\n                            &must[j].ext, 0, unres);\n                must[j].expr = lydict_insert(ctx, rfn->must[k].expr, 0);\n                must[j].dsc = lydict_insert(ctx, rfn->must[k].dsc, 0);\n                must[j].ref = lydict_insert(ctx, rfn->must[k].ref, 0);\n                must[j].eapptag = lydict_insert(ctx, rfn->must[k].eapptag, 0);\n                must[j].emsg = lydict_insert(ctx, rfn->must[k].emsg, 0);\n                must[j].flags = rfn->must[k].flags;\n            }\n\n            *old_must = must;\n            *old_size = size;\n\n            /* check XPath dependencies again */\n            if (unres_schema_add_node(node->module, unres, node, UNRES_XPATH, NULL) == -1) {\n                goto fail;\n            }\n        }\n\n        /* if-feature in leaf, leaf-list, list, container or anyxml */\n        if (rfn->iffeature_size) {\n            old_size = &node->iffeature_size;\n            old_iff = &node->iffeature;\n\n            size = *old_size + rfn->iffeature_size;\n            iff = realloc(*old_iff, size * sizeof *rfn->iffeature);\n            LY_CHECK_ERR_GOTO(!iff, LOGMEM(ctx), fail);\n            *old_iff = iff;\n\n            for (k = 0, j = *old_size; k < rfn->iffeature_size; k++, j++) {\n                resolve_iffeature_getsizes(&rfn->iffeature[k], &usize1, &usize2);\n                if (usize1) {\n                    /* there is something to duplicate */\n                    /* duplicate compiled expression */\n                    usize = (usize1 / 4) + (usize1 % 4) ? 1 : 0;\n                    iff[j].expr = malloc(usize * sizeof *iff[j].expr);\n                    LY_CHECK_ERR_GOTO(!iff[j].expr, LOGMEM(ctx), fail);\n                    memcpy(iff[j].expr, rfn->iffeature[k].expr, usize * sizeof *iff[j].expr);\n\n                    /* duplicate list of feature pointers */\n                    iff[j].features = malloc(usize2 * sizeof *iff[k].features);\n                    LY_CHECK_ERR_GOTO(!iff[j].expr, LOGMEM(ctx), fail);\n                    memcpy(iff[j].features, rfn->iffeature[k].features, usize2 * sizeof *iff[j].features);\n\n                    /* duplicate extensions */\n                    iff[j].ext_size = rfn->iffeature[k].ext_size;\n                    lys_ext_dup(ctx, rfn->module, rfn->iffeature[k].ext, rfn->iffeature[k].ext_size,\n                                &rfn->iffeature[k], LYEXT_PAR_IFFEATURE, &iff[j].ext, 0, unres);\n                }\n                (*old_size)++;\n            }\n            assert(*old_size == size);\n        }\n    }\n\n    /* apply augments */\n    for (i = 0; i < uses->augment_size; i++) {\n        rc = resolve_augment(&uses->augment[i], (struct lys_node *)uses, unres);\n        if (rc) {\n            goto fail;\n        }\n    }\n\n    /* check refines */\n    for (i = 0; i < uses->refine_size; i++) {\n        node = refine_nodes[i];\n        rfn = &uses->refine[i];\n\n        /* config on any nodetype */\n        if ((rfn->flags & LYS_CONFIG_MASK) && (node->flags & LYS_CONFIG_MASK)) {\n            for (parent = lys_parent(node); parent && parent->nodetype == LYS_USES; parent = lys_parent(parent));\n            if (parent && parent->nodetype != LYS_GROUPING && (parent->flags & LYS_CONFIG_MASK) &&\n                    ((parent->flags & LYS_CONFIG_MASK) != (rfn->flags & LYS_CONFIG_MASK)) &&\n                    (rfn->flags & LYS_CONFIG_W)) {\n                /* setting config true under config false is prohibited */\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, \"config\", \"refine\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                       \"changing config from 'false' to 'true' is prohibited while \"\n                       \"the target's parent is still config 'false'.\");\n                goto fail;\n            }\n\n            /* inherit config change to the target children */\n            LY_TREE_DFS_BEGIN(node->child, next, iter) {\n                if (rfn->flags & LYS_CONFIG_W) {\n                    if (iter->flags & LYS_CONFIG_SET) {\n                        /* config is set explicitely, go to next sibling */\n                        next = NULL;\n                        goto nextsibling;\n                    }\n                } else { /* LYS_CONFIG_R */\n                    if ((iter->flags & LYS_CONFIG_SET) && (iter->flags & LYS_CONFIG_W)) {\n                        /* error - we would have config data under status data */\n                        LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, \"config\", \"refine\");\n                        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                               \"changing config from 'true' to 'false' is prohibited while the target \"\n                               \"has still a children with explicit config 'true'.\");\n                        goto fail;\n                    }\n                }\n                /* change config */\n                iter->flags &= ~LYS_CONFIG_MASK;\n                iter->flags |= (rfn->flags & LYS_CONFIG_MASK);\n\n                /* select next iter - modified LY_TREE_DFS_END */\n                if (iter->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                    next = NULL;\n                } else {\n                    next = iter->child;\n                }\nnextsibling:\n                if (!next) {\n                    /* try siblings */\n                    next = iter->next;\n                }\n                while (!next) {\n                    /* parent is already processed, go to its sibling */\n                    iter = lys_parent(iter);\n\n                    /* no siblings, go back through parents */\n                    if (iter == node) {\n                        /* we are done, no next element to process */\n                        break;\n                    }\n                    next = iter->next;\n                }\n            }\n        }\n\n        /* default value */\n        if (rfn->dflt_size) {\n            if (node->nodetype == LYS_CHOICE) {\n                /* choice */\n                ((struct lys_node_choice *)node)->dflt = resolve_choice_dflt((struct lys_node_choice *)node,\n                                                                             rfn->dflt[0]);\n                if (!((struct lys_node_choice *)node)->dflt) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, rfn->dflt[0], \"default\");\n                    goto fail;\n                }\n                if (lyp_check_mandatory_choice(node)) {\n                    goto fail;\n                }\n            }\n        }\n\n        /* min/max-elements on list or leaf-list */\n        if (node->nodetype == LYS_LIST && ((struct lys_node_list *)node)->max) {\n            if (((struct lys_node_list *)node)->min > ((struct lys_node_list *)node)->max) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, uses, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", rfn->mod.list.min, \"min-elements\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n                goto fail;\n            }\n        } else if (node->nodetype == LYS_LEAFLIST && ((struct lys_node_leaflist *)node)->max) {\n            if (((struct lys_node_leaflist *)node)->min > ((struct lys_node_leaflist *)node)->max) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, uses, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", rfn->mod.list.min, \"min-elements\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n                goto fail;\n            }\n        }\n\n        /* additional checks */\n        /* default value with mandatory/min-elements */\n        if (node->nodetype == LYS_LEAFLIST) {\n            llist = (struct lys_node_leaflist *)node;\n            if (llist->dflt_size && llist->min) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, uses, rfn->dflt_size ? \"default\" : \"min-elements\", \"refine\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                       \"The \\\"min-elements\\\" statement with non-zero value is forbidden on leaf-lists with the \\\"default\\\" statement.\");\n                goto fail;\n            }\n        } else if (node->nodetype == LYS_LEAF) {\n            leaf = (struct lys_node_leaf *)node;\n            if (leaf->dflt && (leaf->flags & LYS_MAND_TRUE)) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, uses, rfn->dflt_size ? \"default\" : \"mandatory\", \"refine\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                       \"The \\\"mandatory\\\" statement is forbidden on leafs with the \\\"default\\\" statement.\");\n                goto fail;\n            }\n        }\n\n        /* check for mandatory node in default case, first find the closest parent choice to the changed node */\n        if ((rfn->flags & LYS_MAND_TRUE) || rfn->mod.list.min) {\n            for (parent = node->parent;\n                 parent && !(parent->nodetype & (LYS_CHOICE | LYS_GROUPING | LYS_ACTION | LYS_USES));\n                 parent = parent->parent) {\n                if (parent->nodetype == LYS_CONTAINER && ((struct lys_node_container *)parent)->presence) {\n                    /* stop also on presence containers */\n                    break;\n                }\n            }\n            /* and if it is a choice with the default case, check it for presence of a mandatory node in it */\n            if (parent && parent->nodetype == LYS_CHOICE && ((struct lys_node_choice *)parent)->dflt) {\n                if (lyp_check_mandatory_choice(parent)) {\n                    goto fail;\n                }\n            }\n        }\n    }\n    free(refine_nodes);\n\n    return EXIT_SUCCESS;\n\nfail:\n    LY_TREE_FOR_SAFE(uses->child, next, iter) {\n        lys_node_free(iter, NULL, 0);\n    }\n    free(refine_nodes);\n    return -1;\n}\n\nvoid\nresolve_identity_backlink_update(struct lys_ident *der, struct lys_ident *base)\n{\n    int i;\n\n    assert(der && base);\n\n    if (!base->der) {\n        /* create a set for backlinks if it does not exist */\n        base->der = ly_set_new();\n    }\n    /* store backlink */\n    ly_set_add(base->der, der, LY_SET_OPT_USEASLIST);\n\n    /* do it recursively */\n    for (i = 0; i < base->base_size; i++) {\n        resolve_identity_backlink_update(der, base->base[i]);\n    }\n}\n\n/**\n * @brief Resolve base identity recursively. Does not log.\n *\n * @param[in] module Main module.\n * @param[in] ident Identity to use.\n * @param[in] basename Base name of the identity.\n * @param[out] ret Pointer to the resolved identity. Can be NULL.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on crucial error.\n */\nstatic int\nresolve_base_ident_sub(const struct lys_module *module, struct lys_ident *ident, const char *basename,\n                       struct unres_schema *unres, struct lys_ident **ret)\n{\n    uint32_t i, j;\n    struct lys_ident *base = NULL;\n    struct ly_ctx *ctx = module->ctx;\n\n    assert(ret);\n\n    /* search module */\n    for (i = 0; i < module->ident_size; i++) {\n        if (!strcmp(basename, module->ident[i].name)) {\n\n            if (!ident) {\n                /* just search for type, so do not modify anything, just return\n                 * the base identity pointer */\n                *ret = &module->ident[i];\n                return EXIT_SUCCESS;\n            }\n\n            base = &module->ident[i];\n            goto matchfound;\n        }\n    }\n\n    /* search submodules */\n    for (j = 0; j < module->inc_size && module->inc[j].submodule; j++) {\n        for (i = 0; i < module->inc[j].submodule->ident_size; i++) {\n            if (!strcmp(basename, module->inc[j].submodule->ident[i].name)) {\n\n                if (!ident) {\n                    *ret = &module->inc[j].submodule->ident[i];\n                    return EXIT_SUCCESS;\n                }\n\n                base = &module->inc[j].submodule->ident[i];\n                goto matchfound;\n            }\n        }\n    }\n\nmatchfound:\n    /* we found it somewhere */\n    if (base) {\n        /* is it already completely resolved? */\n        for (i = 0; i < unres->count; i++) {\n            if ((unres->item[i] == base) && (unres->type[i] == UNRES_IDENT)) {\n                /* identity found, but not yet resolved, so do not return it in *res and try it again later */\n\n                /* simple check for circular reference,\n                 * the complete check is done as a side effect of using only completely\n                 * resolved identities (previous check of unres content) */\n                if (ly_strequal((const char *)unres->str_snode[i], ident->name, 1)) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, basename, \"base\");\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Circular reference of \\\"%s\\\" identity.\", basename);\n                    return -1;\n                }\n\n                return EXIT_FAILURE;\n            }\n        }\n\n        /* checks done, store the result */\n        *ret = base;\n        return EXIT_SUCCESS;\n    }\n\n    /* base not found (maybe a forward reference) */\n    return EXIT_FAILURE;\n}\n\n/**\n * @brief Resolve base identity. Logs directly.\n *\n * @param[in] module Main module.\n * @param[in] ident Identity to use.\n * @param[in] basename Base name of the identity.\n * @param[in] parent Either \"type\" or \"identity\".\n * @param[in,out] type Type structure where we want to resolve identity. Can be NULL.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_base_ident(const struct lys_module *module, struct lys_ident *ident, const char *basename, const char *parent,\n                   struct lys_type *type, struct unres_schema *unres)\n{\n    const char *name;\n    int mod_name_len = 0, rc;\n    struct lys_ident *target, **ret;\n    uint16_t flags;\n    struct lys_module *mod;\n    struct ly_ctx *ctx = module->ctx;\n\n    assert((ident && !type) || (!ident && type));\n\n    if (!type) {\n        /* have ident to resolve */\n        ret = &target;\n        flags = ident->flags;\n        mod = ident->module;\n    } else {\n        /* have type to fill */\n        ++type->info.ident.count;\n        type->info.ident.ref = ly_realloc(type->info.ident.ref, type->info.ident.count * sizeof *type->info.ident.ref);\n        LY_CHECK_ERR_RETURN(!type->info.ident.ref, LOGMEM(ctx), -1);\n\n        ret = &type->info.ident.ref[type->info.ident.count - 1];\n        flags = type->parent->flags;\n        mod = type->parent->module;\n    }\n    *ret = NULL;\n\n    /* search for the base identity */\n    name = strchr(basename, ':');\n    if (name) {\n        /* set name to correct position after colon */\n        mod_name_len = name - basename;\n        name++;\n\n        if (!strncmp(basename, module->name, mod_name_len) && !module->name[mod_name_len]) {\n            /* prefix refers to the current module, ignore it */\n            mod_name_len = 0;\n        }\n    } else {\n        name = basename;\n    }\n\n    /* get module where to search */\n    module = lyp_get_module(module, NULL, 0, mod_name_len ? basename : NULL, mod_name_len, 0);\n    if (!module) {\n        /* identity refers unknown data model */\n        LOGVAL(ctx, LYE_INMOD, LY_VLOG_NONE, NULL, basename);\n        return -1;\n    }\n\n    /* search in the identified module ... */\n    rc = resolve_base_ident_sub(module, ident, name, unres, ret);\n    if (!rc) {\n        assert(*ret);\n\n        /* check status */\n        if (lyp_check_status(flags, mod, ident ? ident->name : \"of type\",\n                             (*ret)->flags, (*ret)->module, (*ret)->name, NULL)) {\n            rc = -1;\n        } else if (ident) {\n            ident->base[ident->base_size++] = *ret;\n            if (lys_main_module(mod)->implemented) {\n                /* in case of the implemented identity, maintain backlinks to it\n                 * from the base identities to make it available when resolving\n                 * data with the identity values (not implemented identity is not\n                 * allowed as an identityref value). */\n                resolve_identity_backlink_update(ident, *ret);\n            }\n        }\n    } else if (rc == EXIT_FAILURE) {\n        LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_NONE, NULL, parent, basename);\n        if (type) {\n            --type->info.ident.count;\n        }\n    }\n\n    return rc;\n}\n\n/*\n * 1 - true (der is derived from base)\n * 0 - false (der is not derived from base)\n */\nstatic int\nsearch_base_identity(struct lys_ident *der, struct lys_ident *base)\n{\n    int i;\n\n    if (der == base) {\n        return 1;\n    } else {\n        for(i = 0; i < der->base_size; i++) {\n            if (search_base_identity(der->base[i], base) == 1) {\n                return 1;\n            }\n        }\n    }\n\n    return 0;\n}\n\n/**\n * @brief Resolve JSON data format identityref. Logs directly.\n *\n * @param[in] type Identityref type.\n * @param[in] ident_name Identityref name.\n * @param[in] node Node where the identityref is being resolved\n * @param[in] dflt flag if we are resolving default value in the schema\n *\n * @return Pointer to the identity resolvent, NULL on error.\n */\nstruct lys_ident *\nresolve_identref(struct lys_type *type, const char *ident_name, struct lyd_node *node, struct lys_module *mod, int dflt)\n{\n    const char *mod_name, *name;\n    char *str;\n    int mod_name_len, nam_len, rc;\n    int need_implemented = 0;\n    unsigned int i, j;\n    struct lys_ident *der, *cur;\n    struct lys_module *imod = NULL, *m, *tmod;\n    struct ly_ctx *ctx;\n\n    assert(type && ident_name && mod);\n    ctx = mod->ctx;\n\n    if (!type || (!type->info.ident.count && !type->der) || !ident_name) {\n        return NULL;\n    }\n\n    rc = parse_node_identifier(ident_name, &mod_name, &mod_name_len, &name, &nam_len, NULL, 0);\n    if (rc < 1) {\n        LOGVAL(ctx, LYE_INCHAR, node ? LY_VLOG_LYD : LY_VLOG_NONE, node, ident_name[-rc], &ident_name[-rc]);\n        return NULL;\n    } else if (rc < (signed)strlen(ident_name)) {\n        LOGVAL(ctx, LYE_INCHAR, node ? LY_VLOG_LYD : LY_VLOG_NONE, node, ident_name[rc], &ident_name[rc]);\n        return NULL;\n    }\n\n    m = lys_main_module(mod); /* shortcut */\n    if (!mod_name || (!strncmp(mod_name, m->name, mod_name_len) && !m->name[mod_name_len])) {\n        /* identity is defined in the same module as node */\n        imod = m;\n    } else if (dflt) {\n        /* solving identityref in default definition in schema -\n         * find the identity's module in the imported modules list to have a correct revision */\n        for (i = 0; i < mod->imp_size; i++) {\n            if (!strncmp(mod_name, mod->imp[i].module->name, mod_name_len) && !mod->imp[i].module->name[mod_name_len]) {\n                imod = mod->imp[i].module;\n                break;\n            }\n        }\n\n        /* We may need to pull it from the module that the typedef came from */\n        if (!imod && type && type->der) {\n            tmod = type->der->module;\n            for (i = 0; i < tmod->imp_size; i++) {\n                if (!strncmp(mod_name, tmod->imp[i].module->name, mod_name_len) && !tmod->imp[i].module->name[mod_name_len]) {\n                    imod = tmod->imp[i].module;\n                    break;\n                }\n            }\n        }\n    } else {\n        /* solving identityref in data - get the module from the context */\n        for (i = 0; i < (unsigned)mod->ctx->models.used; ++i) {\n            imod = mod->ctx->models.list[i];\n            if (!strncmp(mod_name, imod->name, mod_name_len) && !imod->name[mod_name_len]) {\n                break;\n            }\n            imod = NULL;\n        }\n        if (!imod && mod->ctx->models.parsing_sub_modules_count) {\n            /* we are currently parsing some module and checking XPath or a default value,\n             * so take this module into account */\n            for (i = 0; i < mod->ctx->models.parsing_sub_modules_count; i++) {\n                imod = mod->ctx->models.parsing_sub_modules[i];\n                if (imod->type) {\n                    /* skip submodules */\n                    continue;\n                }\n                if (!strncmp(mod_name, imod->name, mod_name_len) && !imod->name[mod_name_len]) {\n                    break;\n                }\n                imod = NULL;\n            }\n        }\n    }\n\n    if (!dflt && (!imod || !imod->implemented) && ctx->data_clb) {\n        /* the needed module was not found, but it may have been expected so call the data callback */\n        if (imod) {\n            ctx->data_clb(ctx, imod->name, imod->ns, LY_MODCLB_NOT_IMPLEMENTED, ctx->data_clb_data);\n        } else if (mod_name) {\n            str = strndup(mod_name, mod_name_len);\n            imod = (struct lys_module *)ctx->data_clb(ctx, str, NULL, 0, ctx->data_clb_data);\n            free(str);\n        }\n    }\n    if (!imod) {\n        goto fail;\n    }\n\n    if (m != imod || lys_main_module(type->parent->module) != mod) {\n        /* the type is not referencing the same schema,\n         * THEN, we may need to make the module with the identity implemented, but only if it really\n         * contains the identity */\n        if (!imod->implemented) {\n            cur = NULL;\n            /* get the identity in the module */\n            for (i = 0; i < imod->ident_size; i++) {\n                if (!strcmp(name, imod->ident[i].name)) {\n                    cur = &imod->ident[i];\n                    break;\n                }\n            }\n            if (!cur) {\n                /* go through includes */\n                for (j = 0; j < imod->inc_size; j++) {\n                    for (i = 0; i < imod->inc[j].submodule->ident_size; i++) {\n                        if (!strcmp(name, imod->inc[j].submodule->ident[i].name)) {\n                            cur = &imod->inc[j].submodule->ident[i];\n                            break;\n                        }\n                    }\n                }\n                if (!cur) {\n                    goto fail;\n                }\n            }\n\n            /* check that identity is derived from one of the type's base */\n            while (type->der) {\n                for (i = 0; i < type->info.ident.count; i++) {\n                    if (search_base_identity(cur, type->info.ident.ref[i])) {\n                        /* cur's base matches the type's base */\n                        need_implemented = 1;\n                        goto match;\n                    }\n                }\n                type = &type->der->type;\n            }\n            /* matching base not found */\n            LOGVAL(ctx, LYE_SPEC, node ? LY_VLOG_LYD : LY_VLOG_NONE, node, \"Identity used as identityref value is not implemented.\");\n            goto fail;\n        }\n    }\n\n    /* go through all the derived types of all the bases */\n    while (type->der) {\n        for (i = 0; i < type->info.ident.count; ++i) {\n            cur = type->info.ident.ref[i];\n\n            if (cur->der) {\n                /* there are some derived identities */\n                for (j = 0; j < cur->der->number; j++) {\n                    der = (struct lys_ident *)cur->der->set.g[j]; /* shortcut */\n                    if (!strcmp(der->name, name) && lys_main_module(der->module) == imod) {\n                        /* we have match */\n                        cur = der;\n                        goto match;\n                    }\n                }\n            }\n        }\n        type = &type->der->type;\n    }\n\nfail:\n    LOGVAL(ctx, LYE_INRESOLV, node ? LY_VLOG_LYD : LY_VLOG_NONE, node, \"identityref\", ident_name);\n    return NULL;\n\nmatch:\n    for (i = 0; i < cur->iffeature_size; i++) {\n        if (!resolve_iffeature(&cur->iffeature[i])) {\n            if (node) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, node, cur->name, node->schema->name);\n            }\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Identity \\\"%s\\\" is disabled by its if-feature condition.\", cur->name);\n            return NULL;\n        }\n    }\n    if (need_implemented) {\n        if (dflt) {\n            /* later try to make the module implemented */\n            LOGVRB(\"Making \\\"%s\\\" module implemented because of identityref default value \\\"%s\\\" used in the implemented \\\"%s\\\" module\",\n                   imod->name, cur->name, mod->name);\n            /* to be more effective we should use UNRES_MOD_IMPLEMENT but that would require changing prototype of\n             * several functions with little gain */\n            if (lys_set_implemented(imod)) {\n                LOGERR(ctx, ly_errno, \"Setting the module \\\"%s\\\" implemented because of used default identity \\\"%s\\\" failed.\",\n                       imod->name, cur->name);\n                goto fail;\n            }\n        } else {\n            /* just say that it was found, but in a non-implemented module */\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Identity found, but in a non-implemented module \\\"%s\\\".\",\n                   lys_main_module(cur->module)->name);\n            goto fail;\n        }\n    }\n    return cur;\n}\n\n/**\n * @brief Resolve unresolved uses. Logs directly.\n *\n * @param[in] uses Uses to use.\n * @param[in] unres Specific unres item.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_unres_schema_uses(struct lys_node_uses *uses, struct unres_schema *unres)\n{\n    int rc;\n    struct lys_node *par_grp;\n    struct ly_ctx *ctx = uses->module->ctx;\n\n    /* HACK: when a grouping has uses inside, all such uses have to be resolved before the grouping itself is used\n     *       in some uses. When we see such a uses, the grouping's unres counter is used to store number of so far\n     *       unresolved uses. The grouping cannot be used unless this counter is decreased back to 0. To remember\n     *       that the uses already increased grouping's counter, the LYS_USESGRP flag is used. */\n    for (par_grp = lys_parent((struct lys_node *)uses); par_grp && (par_grp->nodetype != LYS_GROUPING); par_grp = lys_parent(par_grp));\n    if (par_grp && ly_strequal(par_grp->name, uses->name, 1)) {\n        LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, uses, \"uses\", uses->name);\n        return -1;\n    }\n\n    if (!uses->grp) {\n        rc = resolve_uses_schema_nodeid(uses->name, (const struct lys_node *)uses, (const struct lys_node_grp **)&uses->grp);\n        if (rc == -1) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, uses, \"uses\", uses->name);\n            return -1;\n        } else if (rc > 0) {\n            LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, uses, uses->name[rc - 1], &uses->name[rc - 1]);\n            return -1;\n        } else if (!uses->grp) {\n            if (par_grp && !(uses->flags & LYS_USESGRP)) {\n                if (++((struct lys_node_grp *)par_grp)->unres_count == 0) {\n                    LOGERR(ctx, LY_EINT, \"Too many unresolved items (uses) inside a grouping.\");\n                    return -1;\n                }\n                uses->flags |= LYS_USESGRP;\n            }\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, uses, \"uses\", uses->name);\n            return EXIT_FAILURE;\n        }\n    }\n\n    if (uses->grp->unres_count) {\n        if (par_grp && !(uses->flags & LYS_USESGRP)) {\n            if (++((struct lys_node_grp *)par_grp)->unres_count == 0) {\n                LOGERR(ctx, LY_EINT, \"Too many unresolved items (uses) inside a grouping.\");\n                return -1;\n            }\n            uses->flags |= LYS_USESGRP;\n        } else {\n            /* instantiate grouping only when it is completely resolved */\n            uses->grp = NULL;\n        }\n        LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, uses, \"uses\", uses->name);\n        return EXIT_FAILURE;\n    }\n\n    rc = resolve_uses(uses, unres);\n    if (!rc) {\n        /* decrease unres count only if not first try */\n        if (par_grp && (uses->flags & LYS_USESGRP)) {\n            assert(((struct lys_node_grp *)par_grp)->unres_count);\n            ((struct lys_node_grp *)par_grp)->unres_count--;\n            uses->flags &= ~LYS_USESGRP;\n        }\n\n        /* check status */\n        if (lyp_check_status(uses->flags, uses->module, \"of uses\",\n                         uses->grp->flags, uses->grp->module, uses->grp->name,\n                         (struct lys_node *)uses)) {\n            return -1;\n        }\n\n        return EXIT_SUCCESS;\n    }\n\n    return rc;\n}\n\n/**\n * @brief Resolve list keys. Logs directly.\n *\n * @param[in] list List to use.\n * @param[in] keys_str Keys node value.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_list_keys(struct lys_node_list *list, const char *keys_str)\n{\n    int i, len, rc;\n    const char *value;\n    char *s = NULL;\n    struct ly_ctx *ctx = list->module->ctx;\n\n    for (i = 0; i < list->keys_size; ++i) {\n        assert(keys_str);\n\n        if (!list->child) {\n            /* no child, possible forward reference */\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list keys\", keys_str);\n            return EXIT_FAILURE;\n        }\n        /* get the key name */\n        if ((value = strpbrk(keys_str, \" \\t\\n\"))) {\n            len = value - keys_str;\n            while (isspace(value[0])) {\n                value++;\n            }\n        } else {\n            len = strlen(keys_str);\n        }\n\n        rc = lys_getnext_data(lys_node_module((struct lys_node *)list), (struct lys_node *)list, keys_str, len, LYS_LEAF,\n                              LYS_GETNEXT_NOSTATECHECK, (const struct lys_node **)&list->keys[i]);\n        if (rc) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list key\", keys_str);\n            return EXIT_FAILURE;\n        }\n\n        if (check_key(list, i, keys_str, len)) {\n            /* check_key logs */\n            return -1;\n        }\n\n        /* check status */\n        if (lyp_check_status(list->flags, list->module, list->name,\n                             list->keys[i]->flags, list->keys[i]->module, list->keys[i]->name,\n                             (struct lys_node *)list->keys[i])) {\n            return -1;\n        }\n\n        /* default value - is ignored, keep it but print a warning */\n        if (list->keys[i]->dflt) {\n            /* log is not hidden only in case this resolving fails and in such a case\n             * we cannot get here\n             */\n            assert(log_opt == ILO_STORE);\n            log_opt = ILO_LOG;\n            LOGWRN(ctx, \"Default value \\\"%s\\\" in the list key \\\"%s\\\" is ignored. (%s)\", list->keys[i]->dflt,\n                   list->keys[i]->name, s = lys_path((struct lys_node*)list, LYS_PATH_FIRST_PREFIX));\n            log_opt = ILO_STORE;\n            free(s);\n        }\n\n        /* prepare for next iteration */\n        while (value && isspace(value[0])) {\n            value++;\n        }\n        keys_str = value;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Resolve (check) all must conditions of \\p node.\n * Logs directly.\n *\n * @param[in] node Data node with optional must statements.\n * @param[in] inout_parent If set, must in input or output parent of node->schema will be resolved.\n *\n * @return EXIT_SUCCESS on pass, EXIT_FAILURE on fail, -1 on error.\n */\nstatic int\nresolve_must(struct lyd_node *node, int inout_parent, int ignore_fail)\n{\n    uint8_t i, must_size;\n    struct lys_node *schema;\n    struct lys_restr *must;\n    struct lyxp_set set;\n    struct ly_ctx *ctx = node->schema->module->ctx;\n\n    assert(node);\n    memset(&set, 0, sizeof set);\n\n    if (inout_parent) {\n        for (schema = lys_parent(node->schema);\n             schema && (schema->nodetype & (LYS_CHOICE | LYS_CASE | LYS_USES));\n             schema = lys_parent(schema));\n        if (!schema || !(schema->nodetype & (LYS_INPUT | LYS_OUTPUT))) {\n            LOGINT(ctx);\n            return -1;\n        }\n        must_size = ((struct lys_node_inout *)schema)->must_size;\n        must = ((struct lys_node_inout *)schema)->must;\n\n        /* context node is the RPC/action */\n        node = node->parent;\n        if (!(node->schema->nodetype & (LYS_RPC | LYS_ACTION))) {\n            LOGINT(ctx);\n            return -1;\n        }\n    } else {\n        switch (node->schema->nodetype) {\n        case LYS_CONTAINER:\n            must_size = ((struct lys_node_container *)node->schema)->must_size;\n            must = ((struct lys_node_container *)node->schema)->must;\n            break;\n        case LYS_LEAF:\n            must_size = ((struct lys_node_leaf *)node->schema)->must_size;\n            must = ((struct lys_node_leaf *)node->schema)->must;\n            break;\n        case LYS_LEAFLIST:\n            must_size = ((struct lys_node_leaflist *)node->schema)->must_size;\n            must = ((struct lys_node_leaflist *)node->schema)->must;\n            break;\n        case LYS_LIST:\n            must_size = ((struct lys_node_list *)node->schema)->must_size;\n            must = ((struct lys_node_list *)node->schema)->must;\n            break;\n        case LYS_ANYXML:\n        case LYS_ANYDATA:\n            must_size = ((struct lys_node_anydata *)node->schema)->must_size;\n            must = ((struct lys_node_anydata *)node->schema)->must;\n            break;\n        case LYS_NOTIF:\n            must_size = ((struct lys_node_notif *)node->schema)->must_size;\n            must = ((struct lys_node_notif *)node->schema)->must;\n            break;\n        default:\n            must_size = 0;\n            break;\n        }\n    }\n\n    for (i = 0; i < must_size; ++i) {\n        if (lyxp_eval(must[i].expr, node, LYXP_NODE_ELEM, lyd_node_module(node), &set, LYXP_MUST)) {\n            return -1;\n        }\n\n        lyxp_set_cast(&set, LYXP_SET_BOOLEAN, node, lyd_node_module(node), LYXP_MUST);\n\n        if (!set.val.bool) {\n            if ((ignore_fail == 1) || ((must[i].flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP)) && (ignore_fail == 2))) {\n                LOGVRB(\"Must condition \\\"%s\\\" not satisfied, but it is not required.\", must[i].expr);\n            } else {\n                LOGVAL(ctx, LYE_NOMUST, LY_VLOG_LYD, node, must[i].expr);\n                if (must[i].emsg) {\n                    ly_vlog_str(ctx, LY_VLOG_PREV, must[i].emsg);\n                }\n                if (must[i].eapptag) {\n                    ly_err_last_set_apptag(ctx, must[i].eapptag);\n                }\n                return 1;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Resolve (find) when condition schema context node. Does not log.\n *\n * @param[in] schema Schema node with the when condition.\n * @param[out] ctx_snode When schema context node.\n * @param[out] ctx_snode_type Schema context node type.\n */\nvoid\nresolve_when_ctx_snode(const struct lys_node *schema, struct lys_node **ctx_snode, enum lyxp_node_type *ctx_snode_type)\n{\n    const struct lys_node *sparent;\n\n    /* find a not schema-only node */\n    *ctx_snode_type = LYXP_NODE_ELEM;\n    while (schema->nodetype & (LYS_USES | LYS_CHOICE | LYS_CASE | LYS_AUGMENT | LYS_INPUT | LYS_OUTPUT)) {\n        if (schema->nodetype == LYS_AUGMENT) {\n            sparent = ((struct lys_node_augment *)schema)->target;\n        } else {\n            sparent = schema->parent;\n        }\n        if (!sparent) {\n            /* context node is the document root (fake root in our case) */\n            if (schema->flags & LYS_CONFIG_W) {\n                *ctx_snode_type = LYXP_NODE_ROOT_CONFIG;\n            } else {\n                *ctx_snode_type = LYXP_NODE_ROOT;\n            }\n            /* we need the first top-level sibling, but no uses or groupings */\n            schema = lys_getnext(NULL, NULL, lys_node_module(schema), LYS_GETNEXT_NOSTATECHECK);\n            break;\n        }\n        schema = sparent;\n    }\n\n    *ctx_snode = (struct lys_node *)schema;\n}\n\n/**\n * @brief Resolve (find) when condition context node. Does not log.\n *\n * @param[in] node Data node, whose conditional definition is being decided.\n * @param[in] schema Schema node with the when condition.\n * @param[out] ctx_node Context node.\n * @param[out] ctx_node_type Context node type.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nstatic int\nresolve_when_ctx_node(struct lyd_node *node, struct lys_node *schema, struct lyd_node **ctx_node,\n                      enum lyxp_node_type *ctx_node_type)\n{\n    struct lyd_node *parent;\n    struct lys_node *sparent;\n    enum lyxp_node_type node_type;\n    uint16_t i, data_depth, schema_depth;\n\n    resolve_when_ctx_snode(schema, &schema, &node_type);\n\n    if (node_type == LYXP_NODE_ELEM) {\n        /* standard element context node */\n        for (parent = node, data_depth = 0; parent; parent = parent->parent, ++data_depth);\n        for (sparent = schema, schema_depth = 0;\n                sparent;\n                sparent = (sparent->nodetype == LYS_AUGMENT ? ((struct lys_node_augment *)sparent)->target : sparent->parent)) {\n            if (sparent->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_ANYDATA | LYS_NOTIF | LYS_RPC)) {\n                ++schema_depth;\n            }\n        }\n        if (data_depth < schema_depth) {\n            return -1;\n        }\n\n        /* find the corresponding data node */\n        for (i = 0; i < data_depth - schema_depth; ++i) {\n            node = node->parent;\n        }\n        if (node->schema != schema) {\n            return -1;\n        }\n    } else {\n        /* root context node */\n        while (node->parent) {\n            node = node->parent;\n        }\n        while (node->prev->next) {\n            node = node->prev;\n        }\n    }\n\n    *ctx_node = node;\n    *ctx_node_type = node_type;\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Temporarily unlink nodes as per YANG 1.1 RFC section 7.21.5 for when XPath evaluation.\n * The context node is adjusted if needed.\n *\n * @param[in] snode Schema node, whose children instances need to be unlinked.\n * @param[in,out] node Data siblings where to look for the children of \\p snode. If it is unlinked,\n * it is moved to point to another sibling still in the original tree.\n * @param[in,out] ctx_node When context node, adjusted if needed.\n * @param[in] ctx_node_type Context node type, just for information to detect invalid situations.\n * @param[out] unlinked_nodes Unlinked siblings. Can be safely appended to \\p node afterwards.\n * Ordering may change, but there will be no semantic change.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nstatic int\nresolve_when_unlink_nodes(struct lys_node *snode, struct lyd_node **node, struct lyd_node **ctx_node,\n                          enum lyxp_node_type ctx_node_type, struct lyd_node **unlinked_nodes)\n{\n    struct lyd_node *next, *elem;\n    const struct lys_node *slast;\n    struct ly_ctx *ctx = snode->module->ctx;\n\n    switch (snode->nodetype) {\n    case LYS_AUGMENT:\n    case LYS_USES:\n    case LYS_CHOICE:\n    case LYS_CASE:\n        slast = NULL;\n        while ((slast = lys_getnext(slast, snode, NULL, LYS_GETNEXT_PARENTUSES))) {\n            if (slast->nodetype & (LYS_ACTION | LYS_NOTIF)) {\n                continue;\n            }\n\n            if (resolve_when_unlink_nodes((struct lys_node *)slast, node, ctx_node, ctx_node_type, unlinked_nodes)) {\n                return -1;\n            }\n        }\n        break;\n    case LYS_CONTAINER:\n    case LYS_LIST:\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        LY_TREE_FOR_SAFE(lyd_first_sibling(*node), next, elem) {\n            if (elem->schema == snode) {\n\n                if (elem == *ctx_node) {\n                    /* We are going to unlink our context node! This normally cannot happen,\n                     * but we use normal top-level data nodes for faking a document root node,\n                     * so if this is the context node, we just use the next top-level node.\n                     * Additionally, it can even happen that there are no top-level data nodes left,\n                     * all were unlinked, so in this case we pass NULL as the context node/data tree,\n                     * lyxp_eval() can handle this special situation.\n                     */\n                    if (ctx_node_type == LYXP_NODE_ELEM) {\n                        LOGINT(ctx);\n                        return -1;\n                    }\n\n                    if (elem->prev == elem) {\n                        /* unlinking last top-level element, use an empty data tree */\n                        *ctx_node = NULL;\n                    } else {\n                        /* in this case just use the previous/last top-level data node */\n                        *ctx_node = elem->prev;\n                    }\n                } else if (elem == *node) {\n                    /* We are going to unlink the currently processed node. This does not matter that\n                     * much, but we would lose access to the original data tree, so just move our\n                     * pointer somewhere still inside it.\n                     */\n                    if ((*node)->prev != *node) {\n                        *node = (*node)->prev;\n                    } else {\n                        /* the processed node with sibings were all unlinked, oh well */\n                        *node = NULL;\n                    }\n                }\n\n                /* temporarily unlink the node */\n                lyd_unlink_internal(elem, 0);\n                if (*unlinked_nodes) {\n                    if (lyd_insert_after((*unlinked_nodes)->prev, elem)) {\n                        LOGINT(ctx);\n                        return -1;\n                    }\n                } else {\n                    *unlinked_nodes = elem;\n                }\n\n                if (snode->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_ANYDATA)) {\n                    /* there can be only one instance */\n                    break;\n                }\n            }\n        }\n        break;\n    default:\n        LOGINT(ctx);\n        return -1;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Relink the unlinked nodes back.\n *\n * @param[in] node Data node to link the nodes back to. It can actually be the adjusted context node,\n * we simply need a sibling from the original data tree.\n * @param[in] unlinked_nodes Unlinked nodes to relink to \\p node.\n * @param[in] ctx_node_type Context node type to distinguish between \\p node being the parent\n * or the sibling of \\p unlinked_nodes.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nstatic int\nresolve_when_relink_nodes(struct lyd_node *node, struct lyd_node *unlinked_nodes, enum lyxp_node_type ctx_node_type)\n{\n    struct lyd_node *elem;\n\n    LY_TREE_FOR_SAFE(unlinked_nodes, unlinked_nodes, elem) {\n        lyd_unlink_internal(elem, 0);\n        if (ctx_node_type == LYXP_NODE_ELEM) {\n            if (lyd_insert_common(node, NULL, elem, 0)) {\n                return -1;\n            }\n        } else {\n            if (lyd_insert_nextto(node, elem, 0, 0)) {\n                return -1;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\nresolve_applies_must(const struct lyd_node *node)\n{\n    int ret = 0;\n    uint8_t must_size;\n    struct lys_node *schema, *iter;\n\n    assert(node);\n\n    schema = node->schema;\n\n    /* their own must */\n    switch (schema->nodetype) {\n    case LYS_CONTAINER:\n        must_size = ((struct lys_node_container *)schema)->must_size;\n        break;\n    case LYS_LEAF:\n        must_size = ((struct lys_node_leaf *)schema)->must_size;\n        break;\n    case LYS_LEAFLIST:\n        must_size = ((struct lys_node_leaflist *)schema)->must_size;\n        break;\n    case LYS_LIST:\n        must_size = ((struct lys_node_list *)schema)->must_size;\n        break;\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        must_size = ((struct lys_node_anydata *)schema)->must_size;\n        break;\n    case LYS_NOTIF:\n        must_size = ((struct lys_node_notif *)schema)->must_size;\n        break;\n    default:\n        must_size = 0;\n        break;\n    }\n\n    if (must_size) {\n        ++ret;\n    }\n\n    /* schema may be a direct data child of input/output with must (but it must be first, it needs to be evaluated only once) */\n    if (!node->prev->next) {\n        for (iter = lys_parent(schema); iter && (iter->nodetype & (LYS_CHOICE | LYS_CASE | LYS_USES)); iter = lys_parent(iter));\n        if (iter && (iter->nodetype & (LYS_INPUT | LYS_OUTPUT))) {\n            ret += 0x2;\n        }\n    }\n\n    return ret;\n}\n\nstatic struct lys_when *\nsnode_get_when(const struct lys_node *schema)\n{\n    switch (schema->nodetype) {\n    case LYS_CONTAINER:\n        return ((struct lys_node_container *)schema)->when;\n    case LYS_CHOICE:\n        return ((struct lys_node_choice *)schema)->when;\n    case LYS_LEAF:\n        return ((struct lys_node_leaf *)schema)->when;\n    case LYS_LEAFLIST:\n        return ((struct lys_node_leaflist *)schema)->when;\n    case LYS_LIST:\n        return ((struct lys_node_list *)schema)->when;\n    case LYS_ANYDATA:\n    case LYS_ANYXML:\n        return ((struct lys_node_anydata *)schema)->when;\n    case LYS_CASE:\n        return ((struct lys_node_case *)schema)->when;\n    case LYS_USES:\n        return ((struct lys_node_uses *)schema)->when;\n    case LYS_AUGMENT:\n        return ((struct lys_node_augment *)schema)->when;\n    default:\n        return NULL;\n    }\n}\n\nint\nresolve_applies_when(const struct lys_node *schema, int mode, const struct lys_node *stop)\n{\n    const struct lys_node *parent;\n\n    assert(schema);\n\n    if (!(schema->nodetype & (LYS_NOTIF | LYS_RPC)) && snode_get_when(schema)) {\n        return 1;\n    }\n\n    parent = schema;\n    goto check_augment;\n\n    while (parent) {\n        /* stop conditions */\n        if (!mode) {\n            /* stop on node that can be instantiated in data tree */\n            if (!(parent->nodetype & (LYS_USES | LYS_CHOICE | LYS_CASE))) {\n                break;\n            }\n        } else {\n            /* stop on the specified node */\n            if (parent == stop) {\n                break;\n            }\n        }\n\n        if (snode_get_when(parent)) {\n            return 1;\n        }\ncheck_augment:\n\n        if (parent->parent && (parent->parent->nodetype == LYS_AUGMENT) && snode_get_when(parent->parent)) {\n            return 1;\n        }\n        parent = lys_parent(parent);\n    }\n\n    return 0;\n}\n\n/**\n * @brief Resolve (check) all when conditions relevant for \\p node.\n * Logs directly.\n *\n * @param[in] node Data node, whose conditional reference, if such, is being decided.\n * @param[in] ignore_fail 1 if when does not have to be satisfied, 2 if it does not have to be satisfied\n * only when requiring external dependencies.\n *\n * @return\n *  -1 - error, ly_errno is set\n *   0 - all \"when\" statements true\n *   0, ly_vecode = LYVE_NOWHEN - some \"when\" statement false, returned in failed_when\n *   1, ly_vecode = LYVE_INWHEN - nodes needed to resolve are conditional and not yet resolved (under another \"when\")\n */\nint\nresolve_when(struct lyd_node *node, int ignore_fail, struct lys_when **failed_when)\n{\n    struct lyd_node *ctx_node = NULL, *unlinked_nodes, *tmp_node;\n    struct lys_node *sparent;\n    struct lyxp_set set;\n    enum lyxp_node_type ctx_node_type;\n    struct ly_ctx *ctx = node->schema->module->ctx;\n    int rc = 0;\n\n    assert(node);\n    memset(&set, 0, sizeof set);\n\n    if (!(node->schema->nodetype & (LYS_NOTIF | LYS_RPC | LYS_ACTION)) && snode_get_when(node->schema)) {\n        /* make the node dummy for the evaluation */\n        node->validity |= LYD_VAL_INUSE;\n        rc = lyxp_eval(snode_get_when(node->schema)->cond, node, LYXP_NODE_ELEM, lyd_node_module(node),\n                       &set, LYXP_WHEN);\n        node->validity &= ~LYD_VAL_INUSE;\n        if (rc) {\n            if (rc == 1) {\n                LOGVAL(ctx, LYE_INWHEN, LY_VLOG_LYD, node, snode_get_when(node->schema)->cond);\n            }\n            goto cleanup;\n        }\n\n        /* set boolean result of the condition */\n        lyxp_set_cast(&set, LYXP_SET_BOOLEAN, node, lyd_node_module(node), LYXP_WHEN);\n        if (!set.val.bool) {\n            node->when_status |= LYD_WHEN_FALSE;\n            if ((ignore_fail == 1) || ((snode_get_when(node->schema)->flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP))\n                    && (ignore_fail == 2))) {\n                LOGVRB(\"When condition \\\"%s\\\" is not satisfied, but it is not required.\", snode_get_when(node->schema)->cond);\n            } else {\n                LOGVAL(ctx, LYE_NOWHEN, LY_VLOG_LYD, node, snode_get_when(node->schema)->cond);\n                if (failed_when) {\n                    *failed_when = snode_get_when(node->schema);\n                }\n                goto cleanup;\n            }\n        }\n\n        /* free xpath set content */\n        lyxp_set_cast(&set, LYXP_SET_EMPTY, node, lyd_node_module(node), 0);\n    }\n\n    sparent = node->schema;\n    goto check_augment;\n\n    /* check when in every schema node that affects node */\n    while (sparent && (sparent->nodetype & (LYS_USES | LYS_CHOICE | LYS_CASE))) {\n        if (snode_get_when(sparent)) {\n            if (!ctx_node) {\n                rc = resolve_when_ctx_node(node, sparent, &ctx_node, &ctx_node_type);\n                if (rc) {\n                    LOGINT(ctx);\n                    goto cleanup;\n                }\n            }\n\n            unlinked_nodes = NULL;\n            /* we do not want our node pointer to change */\n            tmp_node = node;\n            rc = resolve_when_unlink_nodes(sparent, &tmp_node, &ctx_node, ctx_node_type, &unlinked_nodes);\n            if (rc) {\n                goto cleanup;\n            }\n\n            rc = lyxp_eval(snode_get_when(sparent)->cond, ctx_node, ctx_node_type, lys_node_module(sparent),\n                           &set, LYXP_WHEN);\n\n            if (unlinked_nodes && ctx_node) {\n                if (resolve_when_relink_nodes(ctx_node, unlinked_nodes, ctx_node_type)) {\n                    rc = -1;\n                    goto cleanup;\n                }\n            }\n\n            if (rc) {\n                if (rc == 1) {\n                    LOGVAL(ctx, LYE_INWHEN, LY_VLOG_LYD, node, snode_get_when(sparent)->cond);\n                }\n                goto cleanup;\n            }\n\n            lyxp_set_cast(&set, LYXP_SET_BOOLEAN, ctx_node, lys_node_module(sparent), LYXP_WHEN);\n            if (!set.val.bool) {\n                if ((ignore_fail == 1) || ((snode_get_when(sparent)->flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP))\n                        && (ignore_fail == 2))) {\n                    LOGVRB(\"When condition \\\"%s\\\" is not satisfied, but it is not required.\", snode_get_when(sparent)->cond);\n                } else {\n                    node->when_status |= LYD_WHEN_FALSE;\n                    LOGVAL(ctx, LYE_NOWHEN, LY_VLOG_LYD, node, snode_get_when(sparent)->cond);\n                    if (failed_when) {\n                        *failed_when = snode_get_when(sparent);\n                    }\n                    goto cleanup;\n                }\n            }\n\n            /* free xpath set content */\n            lyxp_set_cast(&set, LYXP_SET_EMPTY, ctx_node, lys_node_module(sparent), 0);\n        }\n\ncheck_augment:\n        if ((sparent->parent && (sparent->parent->nodetype == LYS_AUGMENT) && snode_get_when(sparent->parent))) {\n            if (!ctx_node) {\n                rc = resolve_when_ctx_node(node, sparent->parent, &ctx_node, &ctx_node_type);\n                if (rc) {\n                    LOGINT(ctx);\n                    goto cleanup;\n                }\n            }\n\n            unlinked_nodes = NULL;\n            tmp_node = node;\n            rc = resolve_when_unlink_nodes(sparent->parent, &tmp_node, &ctx_node, ctx_node_type, &unlinked_nodes);\n            if (rc) {\n                goto cleanup;\n            }\n\n            rc = lyxp_eval(snode_get_when(sparent->parent)->cond, ctx_node, ctx_node_type,\n                           lys_node_module(sparent->parent), &set, LYXP_WHEN);\n\n            /* reconnect nodes, if ctx_node is NULL then all the nodes were unlinked, but linked together,\n             * so the tree did not actually change and there is nothing for us to do\n             */\n            if (unlinked_nodes && ctx_node) {\n                if (resolve_when_relink_nodes(ctx_node, unlinked_nodes, ctx_node_type)) {\n                    rc = -1;\n                    goto cleanup;\n                }\n            }\n\n            if (rc) {\n                if (rc == 1) {\n                    LOGVAL(ctx, LYE_INWHEN, LY_VLOG_LYD, node, snode_get_when(sparent->parent)->cond);\n                }\n                goto cleanup;\n            }\n\n            lyxp_set_cast(&set, LYXP_SET_BOOLEAN, ctx_node, lys_node_module(sparent->parent), LYXP_WHEN);\n            if (!set.val.bool) {\n                node->when_status |= LYD_WHEN_FALSE;\n                if ((ignore_fail == 1) || ((snode_get_when(sparent->parent)->flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP))\n                        && (ignore_fail == 2))) {\n                    LOGVRB(\"When condition \\\"%s\\\" is not satisfied, but it is not required.\",\n                           snode_get_when(sparent->parent)->cond);\n                } else {\n                    LOGVAL(ctx, LYE_NOWHEN, LY_VLOG_LYD, node, snode_get_when(sparent->parent)->cond);\n                    if (failed_when) {\n                        *failed_when = snode_get_when(sparent->parent);\n                    }\n                    goto cleanup;\n                }\n            }\n\n            /* free xpath set content */\n            lyxp_set_cast(&set, LYXP_SET_EMPTY, ctx_node, lys_node_module(sparent->parent), 0);\n        }\n\n        sparent = lys_parent(sparent);\n    }\n\n    node->when_status |= LYD_WHEN_TRUE;\n\ncleanup:\n    /* free xpath set content */\n    lyxp_set_cast(&set, LYXP_SET_EMPTY, ctx_node ? ctx_node : node, NULL, 0);\n    return rc;\n}\n\nstatic int\ncheck_type_union_leafref(struct lys_type *type)\n{\n    uint8_t i;\n\n    if ((type->base == LY_TYPE_UNION) && type->info.uni.count) {\n        /* go through unions and look for leafref */\n        for (i = 0; i < type->info.uni.count; ++i) {\n            switch (type->info.uni.types[i].base) {\n            case LY_TYPE_LEAFREF:\n                return 1;\n            case LY_TYPE_UNION:\n                if (check_type_union_leafref(&type->info.uni.types[i])) {\n                    return 1;\n                }\n                break;\n            default:\n                break;\n            }\n        }\n\n        return 0;\n    }\n\n    /* just inherit the flag value */\n    return type->der->has_union_leafref;\n}\n\n/**\n * @brief Resolve a single unres schema item. Logs indirectly.\n *\n * @param[in] mod Main module.\n * @param[in] item Item to resolve. Type determined by \\p type.\n * @param[in] type Type of the unresolved item.\n * @param[in] str_snode String, a schema node, or NULL.\n * @param[in] unres Unres schema structure to use.\n * @param[in] final_fail Whether we are just printing errors of the failed unres items.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_unres_schema_item(struct lys_module *mod, void *item, enum UNRES_ITEM type, void *str_snode,\n                          struct unres_schema *unres)\n{\n    /* has_str - whether the str_snode is a string in a dictionary that needs to be freed */\n    int rc = -1, has_str = 0, parent_type = 0, i, k;\n    unsigned int j;\n    struct ly_ctx * ctx = mod->ctx;\n    struct lys_node *root, *next, *node, *par_grp;\n    const char *expr;\n    uint8_t *u;\n\n    struct ly_set *refs, *procs;\n    struct lys_feature *ref, *feat;\n    struct lys_ident *ident;\n    struct lys_type *stype;\n    struct lys_node_choice *choic;\n    struct lyxml_elem *yin;\n    struct yang_type *yang;\n    struct unres_list_uniq *unique_info;\n    struct unres_iffeat_data *iff_data;\n    struct unres_ext *ext_data;\n    struct lys_ext_instance *ext, **extlist;\n    struct lyext_plugin *eplugin;\n\n    switch (type) {\n    case UNRES_IDENT:\n        expr = str_snode;\n        has_str = 1;\n        ident = item;\n\n        rc = resolve_base_ident(mod, ident, expr, \"identity\", NULL, unres);\n        break;\n    case UNRES_TYPE_IDENTREF:\n        expr = str_snode;\n        has_str = 1;\n        stype = item;\n\n        rc = resolve_base_ident(mod, NULL, expr, \"type\", stype, unres);\n        break;\n    case UNRES_TYPE_LEAFREF:\n        node = str_snode;\n        stype = item;\n\n        rc = resolve_schema_leafref(stype, node, unres);\n        break;\n    case UNRES_TYPE_DER_EXT:\n        parent_type++;\n        /* falls through */\n    case UNRES_TYPE_DER_TPDF:\n        parent_type++;\n        /* falls through */\n    case UNRES_TYPE_DER:\n        /* parent */\n        node = str_snode;\n        stype = item;\n\n        /* HACK type->der is temporarily unparsed type statement */\n        yin = (struct lyxml_elem *)stype->der;\n        stype->der = NULL;\n\n        if (yin->flags & LY_YANG_STRUCTURE_FLAG) {\n            yang = (struct yang_type *)yin;\n            rc = yang_check_type(mod, node, yang, stype, parent_type, unres);\n\n            if (rc) {\n                /* may try again later */\n                stype->der = (struct lys_tpdf *)yang;\n            } else {\n                /* we need to always be able to free this, it's safe only in this case */\n                lydict_remove(ctx, yang->name);\n                free(yang);\n            }\n\n        } else {\n            rc = fill_yin_type(mod, node, yin, stype, parent_type, unres);\n            if (!rc || rc == -1) {\n                /* we need to always be able to free this, it's safe only in this case */\n                lyxml_free(ctx, yin);\n            } else {\n                /* may try again later, put all back how it was */\n                stype->der = (struct lys_tpdf *)yin;\n            }\n        }\n        if (rc == EXIT_SUCCESS) {\n            /* it does not make sense to have leaf-list of empty type */\n            if (!parent_type && node->nodetype == LYS_LEAFLIST && stype->base == LY_TYPE_EMPTY) {\n                LOGWRN(ctx, \"The leaf-list \\\"%s\\\" is of \\\"empty\\\" type, which does not make sense.\", node->name);\n            }\n\n            if ((type == UNRES_TYPE_DER_TPDF) && (stype->base == LY_TYPE_UNION)) {\n                /* fill typedef union leafref flag */\n                ((struct lys_tpdf *)stype->parent)->has_union_leafref = check_type_union_leafref(stype);\n            } else if ((type == UNRES_TYPE_DER) && stype->der->has_union_leafref) {\n                /* copy the type in case it has union leafref flag */\n                if (lys_copy_union_leafrefs(mod, node, stype, NULL, unres)) {\n                    LOGERR(ctx, LY_EINT, \"Failed to duplicate type.\");\n                    return -1;\n                }\n            }\n        } else if (rc == EXIT_FAILURE && !(stype->value_flags & LY_VALUE_UNRESGRP)) {\n            /* forward reference - in case the type is in grouping, we have to make the grouping unusable\n             * by uses statement until the type is resolved. We do that the same way as uses statements inside\n             * grouping. The grouping cannot be used unless the unres counter is 0.\n             * To remember that the grouping already increased the counter, the LYTYPE_GRP is used as value\n             * of the type's base member. */\n            for (par_grp = node; par_grp && (par_grp->nodetype != LYS_GROUPING); par_grp = lys_parent(par_grp));\n            if (par_grp) {\n                if (++((struct lys_node_grp *)par_grp)->unres_count == 0) {\n                    LOGERR(ctx, LY_EINT, \"Too many unresolved items (type) inside a grouping.\");\n                    return -1;\n                }\n                stype->value_flags |= LY_VALUE_UNRESGRP;\n            }\n        }\n        break;\n    case UNRES_IFFEAT:\n        iff_data = str_snode;\n        rc = resolve_feature(iff_data->fname, strlen(iff_data->fname), iff_data->node, item);\n        if (!rc) {\n            /* success */\n            if (iff_data->infeature) {\n                /* store backlink into the target feature to allow reverse changes in case of changing feature status */\n                feat = *((struct lys_feature **)item);\n                if (!feat->depfeatures) {\n                    feat->depfeatures = ly_set_new();\n                }\n                ly_set_add(feat->depfeatures, iff_data->node, LY_SET_OPT_USEASLIST);\n            }\n            /* cleanup temporary data */\n            lydict_remove(ctx, iff_data->fname);\n            free(iff_data);\n        }\n        break;\n    case UNRES_FEATURE:\n        feat = (struct lys_feature *)item;\n\n        if (feat->iffeature_size) {\n            refs = ly_set_new();\n            procs = ly_set_new();\n            ly_set_add(procs, feat, 0);\n\n            while (procs->number) {\n                ref = procs->set.g[procs->number - 1];\n                ly_set_rm_index(procs, procs->number - 1);\n\n                for (i = 0; i < ref->iffeature_size; i++) {\n                    resolve_iffeature_getsizes(&ref->iffeature[i], NULL, &j);\n                    for (; j > 0 ; j--) {\n                        if (ref->iffeature[i].features[j - 1]) {\n                            if (ref->iffeature[i].features[j - 1] == feat) {\n                                LOGVAL(ctx, LYE_CIRC_FEATURES, LY_VLOG_NONE, NULL, feat->name);\n                                goto featurecheckdone;\n                            }\n\n                            if (ref->iffeature[i].features[j - 1]->iffeature_size) {\n                                k = refs->number;\n                                if (ly_set_add(refs, ref->iffeature[i].features[j - 1], 0) == k) {\n                                    /* not yet seen feature, add it for processing */\n                                    ly_set_add(procs, ref->iffeature[i].features[j - 1], 0);\n                                }\n                            }\n                        } else {\n                            /* forward reference */\n                            rc = EXIT_FAILURE;\n                            goto featurecheckdone;\n                        }\n                    }\n\n                }\n            }\n            rc = EXIT_SUCCESS;\n\nfeaturecheckdone:\n            ly_set_free(refs);\n            ly_set_free(procs);\n        }\n\n        break;\n    case UNRES_USES:\n        rc = resolve_unres_schema_uses(item, unres);\n        break;\n    case UNRES_TYPEDEF_DFLT:\n        parent_type++;\n        /* falls through */\n    case UNRES_TYPE_DFLT:\n        stype = item;\n        rc = check_default(stype, (const char **)str_snode, mod, parent_type);\n        if ((rc == EXIT_FAILURE) && !parent_type && (stype->base == LY_TYPE_LEAFREF)) {\n            for (par_grp = (struct lys_node *)stype->parent;\n                 par_grp && (par_grp->nodetype != LYS_GROUPING);\n                 par_grp = lys_parent(par_grp));\n            if (par_grp) {\n                /* checking default value in a grouping finished with forward reference means we cannot check the value */\n                rc = EXIT_SUCCESS;\n            }\n        }\n        break;\n    case UNRES_CHOICE_DFLT:\n        expr = str_snode;\n        has_str = 1;\n        choic = item;\n\n        if (!choic->dflt) {\n            choic->dflt = resolve_choice_dflt(choic, expr);\n        }\n        if (choic->dflt) {\n            rc = lyp_check_mandatory_choice((struct lys_node *)choic);\n        } else {\n            rc = EXIT_FAILURE;\n        }\n        break;\n    case UNRES_LIST_KEYS:\n        rc = resolve_list_keys(item, ((struct lys_node_list *)item)->keys_str);\n        break;\n    case UNRES_LIST_UNIQ:\n        unique_info = (struct unres_list_uniq *)item;\n        rc = resolve_unique(unique_info->list, unique_info->expr, unique_info->trg_type);\n        break;\n    case UNRES_AUGMENT:\n        rc = resolve_augment(item, NULL, unres);\n        break;\n    case UNRES_XPATH:\n        node = (struct lys_node *)item;\n        rc = check_xpath(node, 1);\n        break;\n    case UNRES_MOD_IMPLEMENT:\n        rc = lys_make_implemented_r(mod, unres);\n        break;\n    case UNRES_EXT:\n        ext_data = (struct unres_ext *)str_snode;\n        extlist = &(*(struct lys_ext_instance ***)item)[ext_data->ext_index];\n        rc = resolve_extension(ext_data, extlist, unres);\n        if (!rc) {\n            /* success */\n            /* is there a callback to be done to finalize the extension? */\n            eplugin = extlist[0]->def->plugin;\n            if (eplugin) {\n                if (eplugin->check_result || (eplugin->flags & LYEXT_OPT_INHERIT)) {\n                    u = malloc(sizeof *u);\n                    LY_CHECK_ERR_RETURN(!u, LOGMEM(ctx), -1);\n                    (*u) = ext_data->ext_index;\n                    if (unres_schema_add_node(mod, unres, item, UNRES_EXT_FINALIZE, (struct lys_node *)u) == -1) {\n                        /* something really bad happend since the extension finalization is not actually\n                         * being resolved while adding into unres, so something more serious with the unres\n                         * list itself must happened */\n                        return -1;\n                    }\n                }\n            }\n        }\n        if (!rc || rc == -1) {\n            /* cleanup on success or fatal error */\n            if (ext_data->datatype == LYS_IN_YIN) {\n                /* YIN */\n                lyxml_free(ctx, ext_data->data.yin);\n            } else {\n                /* YANG */\n                yang_free_ext_data(ext_data->data.yang);\n            }\n            free(ext_data);\n        }\n        break;\n    case UNRES_EXT_FINALIZE:\n        u = (uint8_t *)str_snode;\n        ext = (*(struct lys_ext_instance ***)item)[*u];\n        free(u);\n\n        eplugin = ext->def->plugin;\n\n        /* inherit */\n        if ((eplugin->flags & LYEXT_OPT_INHERIT) && (ext->parent_type == LYEXT_PAR_NODE)) {\n            root = (struct lys_node *)ext->parent;\n            if (!(root->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA))) {\n                LY_TREE_DFS_BEGIN(root->child, next, node) {\n                    /* first, check if the node already contain instance of the same extension,\n                     * in such a case we won't inherit. In case the node was actually defined as\n                     * augment data, we are supposed to check the same way also the augment node itself */\n                    if (lys_ext_instance_presence(ext->def, node->ext, node->ext_size) != -1) {\n                        goto inherit_dfs_sibling;\n                    } else if (node->parent != root && node->parent->nodetype == LYS_AUGMENT &&\n                            lys_ext_instance_presence(ext->def, node->parent->ext, node->parent->ext_size) != -1) {\n                        goto inherit_dfs_sibling;\n                    }\n\n                    if (eplugin->check_inherit) {\n                        /* we have a callback to check the inheritance, use it */\n                        switch ((rc = (*eplugin->check_inherit)(ext, node))) {\n                        case 0:\n                            /* yes - continue with the inheriting code */\n                            break;\n                        case 1:\n                            /* no - continue with the node's sibling */\n                            goto inherit_dfs_sibling;\n                        case 2:\n                            /* no, but continue with the children, just skip the inheriting code for this node */\n                            goto inherit_dfs_child;\n                        default:\n                            LOGERR(ctx, LY_EINT, \"Plugin's (%s:%s) check_inherit callback returns invalid value (%d),\",\n                                   ext->def->module->name, ext->def->name, rc);\n                        }\n                    }\n\n                    /* inherit the extension */\n                    extlist = realloc(node->ext, (node->ext_size + 1) * sizeof *node->ext);\n                    LY_CHECK_ERR_RETURN(!extlist, LOGMEM(ctx), -1);\n                    extlist[node->ext_size] = malloc(sizeof **extlist);\n                    LY_CHECK_ERR_RETURN(!extlist[node->ext_size], LOGMEM(ctx); node->ext = extlist, -1);\n                    memcpy(extlist[node->ext_size], ext, sizeof *ext);\n                    extlist[node->ext_size]->flags |= LYEXT_OPT_INHERIT;\n\n                    node->ext = extlist;\n                    node->ext_size++;\n\ninherit_dfs_child:\n                    /* modification of - select element for the next run - children first */\n                    if (node->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                        next = NULL;\n                    } else {\n                        next = node->child;\n                    }\n                    if (!next) {\ninherit_dfs_sibling:\n                        /* no children, try siblings */\n                        next = node->next;\n                    }\n                    while (!next) {\n                        /* go to the parent */\n                        node = lys_parent(node);\n\n                        /* we are done if we are back in the root (the starter's parent */\n                        if (node == root) {\n                            break;\n                        }\n\n                        /* parent is already processed, go to its sibling */\n                        next = node->next;\n                    }\n                }\n            }\n        }\n\n        /* final check */\n        if (eplugin->check_result) {\n            if ((*eplugin->check_result)(ext)) {\n                LOGERR(ctx, LY_EPLUGIN, \"Resolving extension failed.\");\n                return -1;\n            }\n        }\n\n        rc = 0;\n        break;\n    default:\n        LOGINT(ctx);\n        break;\n    }\n\n    if (has_str && !rc) {\n        /* the string is no more needed in case of success.\n         * In case of forward reference, we will try to resolve the string later */\n        lydict_remove(ctx, str_snode);\n    }\n\n    return rc;\n}\n\n/* logs directly */\nstatic void\nprint_unres_schema_item_fail(void *item, enum UNRES_ITEM type, void *str_node)\n{\n    struct lyxml_elem *xml;\n    struct lyxml_attr *attr;\n    struct unres_iffeat_data *iff_data;\n    const char *name = NULL;\n    struct unres_ext *extinfo;\n\n    switch (type) {\n    case UNRES_IDENT:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"identity\", (char *)str_node);\n        break;\n    case UNRES_TYPE_IDENTREF:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"identityref\", (char *)str_node);\n        break;\n    case UNRES_TYPE_LEAFREF:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"leafref\",\n               ((struct lys_type *)item)->info.lref.path);\n        break;\n    case UNRES_TYPE_DER_EXT:\n    case UNRES_TYPE_DER_TPDF:\n    case UNRES_TYPE_DER:\n        xml = (struct lyxml_elem *)((struct lys_type *)item)->der;\n        if (xml->flags & LY_YANG_STRUCTURE_FLAG) {\n            name = ((struct yang_type *)xml)->name;\n        } else {\n            LY_TREE_FOR(xml->attr, attr) {\n                if ((attr->type == LYXML_ATTR_STD) && !strcmp(attr->name, \"name\")) {\n                    name = attr->value;\n                    break;\n                }\n            }\n            assert(attr);\n        }\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"derived type\", name);\n        break;\n    case UNRES_IFFEAT:\n        iff_data = str_node;\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"if-feature\", iff_data->fname);\n        break;\n    case UNRES_FEATURE:\n        LOGVRB(\"There are unresolved if-features for \\\"%s\\\" feature circular dependency check, it will be attempted later\",\n               ((struct lys_feature *)item)->name);\n        break;\n    case UNRES_USES:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"uses\", ((struct lys_node_uses *)item)->name);\n        break;\n    case UNRES_TYPEDEF_DFLT:\n    case UNRES_TYPE_DFLT:\n        if (*(char **)str_node) {\n            LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"type default\", *(char **)str_node);\n        }   /* else no default value in the type itself, but we are checking some restrictions against\n             *  possible default value of some base type. The failure is caused by not resolved base type,\n             *  so it was already reported */\n        break;\n    case UNRES_CHOICE_DFLT:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"choice default\", (char *)str_node);\n        break;\n    case UNRES_LIST_KEYS:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"list keys\", (char *)str_node);\n        break;\n    case UNRES_LIST_UNIQ:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"list unique\", (char *)str_node);\n        break;\n    case UNRES_AUGMENT:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"augment target\",\n               ((struct lys_node_augment *)item)->target_name);\n        break;\n    case UNRES_XPATH:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"XPath expressions of\",\n               ((struct lys_node *)item)->name);\n        break;\n    case UNRES_EXT:\n        extinfo = (struct unres_ext *)str_node;\n        name = extinfo->datatype == LYS_IN_YIN ? extinfo->data.yin->name : NULL; /* TODO YANG extension */\n        LOGVRB(\"Resolving extension \\\"%s\\\" failed, it will be attempted later.\", name);\n        break;\n    default:\n        LOGINT(NULL);\n        break;\n    }\n}\n\nstatic int\nresolve_unres_schema_types(struct unres_schema *unres, enum UNRES_ITEM types, struct ly_ctx *ctx, int forward_ref,\n                           int print_all_errors, uint32_t *resolved)\n{\n    uint32_t i, unres_count, res_count;\n    int ret = 0, rc;\n    struct ly_err_item *prev_eitem;\n    enum int_log_opts prev_ilo;\n    LY_ERR prev_ly_errno;\n\n    /* if there can be no forward references, every failure is final, so we can print it directly */\n    if (forward_ref) {\n        prev_ly_errno = ly_errno;\n        ly_ilo_change(ctx, ILO_STORE, &prev_ilo, &prev_eitem);\n    }\n\n    do {\n        unres_count = 0;\n        res_count = 0;\n\n        for (i = 0; i < unres->count; ++i) {\n            /* UNRES_TYPE_LEAFREF must be resolved (for storing leafref target pointers);\n             * if-features are resolved here to make sure that we will have all if-features for\n             * later check of feature circular dependency */\n            if (unres->type[i] & types) {\n                ++unres_count;\n                rc = resolve_unres_schema_item(unres->module[i], unres->item[i], unres->type[i], unres->str_snode[i], unres);\n                if (unres->type[i] == UNRES_EXT_FINALIZE) {\n                    /* to avoid double free */\n                    unres->type[i] = UNRES_RESOLVED;\n                }\n                if (!rc || (unres->type[i] == UNRES_XPATH)) {\n                    /* invalid XPath can never cause an error, only a warning */\n                    if (unres->type[i] == UNRES_LIST_UNIQ) {\n                        /* free the allocated structure */\n                        free(unres->item[i]);\n                    }\n\n                    unres->type[i] = UNRES_RESOLVED;\n                    ++(*resolved);\n                    ++res_count;\n                } else if ((rc == EXIT_FAILURE) && forward_ref) {\n                    /* forward reference, erase errors */\n                    ly_err_free_next(ctx, prev_eitem);\n                } else if (print_all_errors) {\n                    /* just so that we quit the loop */\n                    ++res_count;\n                    ret = -1;\n                } else {\n                    if (forward_ref) {\n                        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 1);\n                    }\n                    return -1;\n                }\n            }\n        }\n    } while (res_count && (res_count < unres_count));\n\n    if (res_count < unres_count) {\n        assert(forward_ref);\n        /* just print the errors (but we must free the ones we have and get them again :-/ ) */\n        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 0);\n\n        for (i = 0; i < unres->count; ++i) {\n            if (unres->type[i] & types) {\n                resolve_unres_schema_item(unres->module[i], unres->item[i], unres->type[i], unres->str_snode[i], unres);\n            }\n        }\n        return -1;\n    }\n\n    if (forward_ref) {\n        /* restore log */\n        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 0);\n        ly_errno = prev_ly_errno;\n    }\n\n    return ret;\n}\n\n/**\n * @brief Resolve every unres schema item in the structure. Logs directly.\n *\n * @param[in] mod Main module.\n * @param[in] unres Unres schema structure to use.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nint\nresolve_unres_schema(struct lys_module *mod, struct unres_schema *unres)\n{\n    uint32_t resolved = 0;\n\n    assert(unres);\n\n    LOGVRB(\"Resolving \\\"%s\\\" unresolved schema nodes and their constraints...\", mod->name);\n\n    /* UNRES_TYPE_LEAFREF must be resolved (for storing leafref target pointers);\n     * if-features are resolved here to make sure that we will have all if-features for\n     * later check of feature circular dependency */\n    if (resolve_unres_schema_types(unres, UNRES_USES | UNRES_IFFEAT | UNRES_TYPE_DER | UNRES_TYPE_DER_TPDF | UNRES_TYPE_DER_TPDF\n                                   | UNRES_TYPE_LEAFREF | UNRES_MOD_IMPLEMENT | UNRES_AUGMENT | UNRES_CHOICE_DFLT | UNRES_IDENT,\n                                   mod->ctx, 1, 0, &resolved)) {\n        return -1;\n    }\n\n    /* another batch of resolved items */\n    if (resolve_unres_schema_types(unres, UNRES_TYPE_IDENTREF | UNRES_FEATURE | UNRES_TYPEDEF_DFLT | UNRES_TYPE_DFLT\n                                   | UNRES_LIST_KEYS | UNRES_LIST_UNIQ | UNRES_EXT, mod->ctx, 1, 0, &resolved)) {\n        return -1;\n    }\n\n    /* print xpath warnings and finalize extensions, keep it last to provide the complete schema tree information to the plugin's checkers */\n    if (resolve_unres_schema_types(unres, UNRES_XPATH | UNRES_EXT_FINALIZE, mod->ctx, 0, 1, &resolved)) {\n        return -1;\n    }\n\n    LOGVRB(\"All \\\"%s\\\" schema nodes and constraints resolved.\", mod->name);\n    unres->count = 0;\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Try to resolve an unres schema item with a string argument. Logs indirectly.\n *\n * @param[in] mod Main module.\n * @param[in] unres Unres schema structure to use.\n * @param[in] item Item to resolve. Type determined by \\p type.\n * @param[in] type Type of the unresolved item.\n * @param[in] str String argument.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on storing the item in unres, -1 on error.\n */\nint\nunres_schema_add_str(struct lys_module *mod, struct unres_schema *unres, void *item, enum UNRES_ITEM type,\n                     const char *str)\n{\n    int rc;\n    const char *dictstr;\n\n    dictstr = lydict_insert(mod->ctx, str, 0);\n    rc = unres_schema_add_node(mod, unres, item, type, (struct lys_node *)dictstr);\n\n    if (rc < 0) {\n        lydict_remove(mod->ctx, dictstr);\n    }\n    return rc;\n}\n\n/**\n * @brief Try to resolve an unres schema item with a schema node argument. Logs indirectly.\n *\n * @param[in] mod Main module.\n * @param[in] unres Unres schema structure to use.\n * @param[in] item Item to resolve. Type determined by \\p type.\n * @param[in] type Type of the unresolved item. UNRES_TYPE_DER is handled specially!\n * @param[in] snode Schema node argument.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on storing the item in unres, -1 on error.\n */\nint\nunres_schema_add_node(struct lys_module *mod, struct unres_schema *unres, void *item, enum UNRES_ITEM type,\n                      struct lys_node *snode)\n{\n    int rc;\n    uint32_t u;\n    enum int_log_opts prev_ilo;\n    struct ly_err_item *prev_eitem;\n    LY_ERR prev_ly_errno;\n    struct lyxml_elem *yin;\n    struct ly_ctx *ctx = mod->ctx;\n\n    assert(unres && (item || (type == UNRES_MOD_IMPLEMENT)) && ((type != UNRES_LEAFREF) && (type != UNRES_INSTID)\n           && (type != UNRES_WHEN) && (type != UNRES_MUST)));\n\n    /* check for duplicities in unres */\n    for (u = 0; u < unres->count; u++) {\n        if (unres->type[u] == type && unres->item[u] == item &&\n                unres->str_snode[u] == snode && unres->module[u] == mod) {\n            /* duplication can happen when the node contains multiple statements of the same type to check,\n             * this can happen for example when refinement is being applied, so we just postpone the processing\n             * and do not duplicate the information */\n            return EXIT_FAILURE;\n        }\n    }\n\n    if ((type == UNRES_EXT_FINALIZE) || (type == UNRES_XPATH) || (type == UNRES_MOD_IMPLEMENT)) {\n        /* extension finalization is not even tried when adding the item into the inres list,\n         * xpath is not tried because it would hide some potential warnings,\n         * implementing module must be deferred because some other nodes can be added that will need to be traversed\n         * and their targets made implemented */\n        rc = EXIT_FAILURE;\n    } else {\n        prev_ly_errno = ly_errno;\n        ly_ilo_change(ctx, ILO_STORE, &prev_ilo, &prev_eitem);\n\n        rc = resolve_unres_schema_item(mod, item, type, snode, unres);\n        if (rc != EXIT_FAILURE) {\n            ly_ilo_restore(ctx, prev_ilo, prev_eitem, rc == -1 ? 1 : 0);\n            if (rc != -1) {\n                ly_errno = prev_ly_errno;\n            }\n\n            if (type == UNRES_LIST_UNIQ) {\n                /* free the allocated structure */\n                free(item);\n            } else if (rc == -1 && type == UNRES_IFFEAT) {\n                /* free the allocated resources */\n                free(*((char **)item));\n            }\n            return rc;\n        } else {\n            /* erase info about validation errors */\n            ly_ilo_restore(ctx, prev_ilo, prev_eitem, 0);\n            ly_errno = prev_ly_errno;\n        }\n\n        print_unres_schema_item_fail(item, type, snode);\n\n        /* HACK unlinking is performed here so that we do not do any (NS) copying in vain */\n        if (type == UNRES_TYPE_DER || type == UNRES_TYPE_DER_TPDF) {\n            yin = (struct lyxml_elem *)((struct lys_type *)item)->der;\n            if (!(yin->flags & LY_YANG_STRUCTURE_FLAG)) {\n                lyxml_unlink_elem(mod->ctx, yin, 1);\n                ((struct lys_type *)item)->der = (struct lys_tpdf *)yin;\n            }\n        }\n    }\n\n    unres->count++;\n    unres->item = ly_realloc(unres->item, unres->count*sizeof *unres->item);\n    LY_CHECK_ERR_RETURN(!unres->item, LOGMEM(ctx), -1);\n    unres->item[unres->count-1] = item;\n    unres->type = ly_realloc(unres->type, unres->count*sizeof *unres->type);\n    LY_CHECK_ERR_RETURN(!unres->type, LOGMEM(ctx), -1);\n    unres->type[unres->count-1] = type;\n    unres->str_snode = ly_realloc(unres->str_snode, unres->count*sizeof *unres->str_snode);\n    LY_CHECK_ERR_RETURN(!unres->str_snode, LOGMEM(ctx), -1);\n    unres->str_snode[unres->count-1] = snode;\n    unres->module = ly_realloc(unres->module, unres->count*sizeof *unres->module);\n    LY_CHECK_ERR_RETURN(!unres->module, LOGMEM(ctx), -1);\n    unres->module[unres->count-1] = mod;\n\n    return rc;\n}\n\n/**\n * @brief Duplicate an unres schema item. Logs indirectly.\n *\n * @param[in] mod Main module.\n * @param[in] unres Unres schema structure to use.\n * @param[in] item Old item to be resolved.\n * @param[in] type Type of the old unresolved item.\n * @param[in] new_item New item to use in the duplicate.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE if item is not in unres, -1 on error.\n */\nint\nunres_schema_dup(struct lys_module *mod, struct unres_schema *unres, void *item, enum UNRES_ITEM type, void *new_item)\n{\n    int i;\n    struct unres_list_uniq aux_uniq;\n    struct unres_iffeat_data *iff_data;\n\n    assert(item && new_item && ((type != UNRES_LEAFREF) && (type != UNRES_INSTID) && (type != UNRES_WHEN)));\n\n    /* hack for UNRES_LIST_UNIQ, which stores multiple items behind its item */\n    if (type == UNRES_LIST_UNIQ) {\n        aux_uniq.list = item;\n        aux_uniq.expr = ((struct unres_list_uniq *)new_item)->expr;\n        item = &aux_uniq;\n    }\n    i = unres_schema_find(unres, -1, item, type);\n\n    if (i == -1) {\n        if (type == UNRES_LIST_UNIQ) {\n            free(new_item);\n        }\n        return EXIT_FAILURE;\n    }\n\n    if ((type == UNRES_TYPE_LEAFREF) || (type == UNRES_USES) || (type == UNRES_TYPE_DFLT) ||\n            (type == UNRES_FEATURE) || (type == UNRES_LIST_UNIQ)) {\n        if (unres_schema_add_node(mod, unres, new_item, type, unres->str_snode[i]) == -1) {\n            LOGINT(mod->ctx);\n            return -1;\n        }\n    } else if (type == UNRES_IFFEAT) {\n        /* duplicate unres_iffeature_data */\n        iff_data = malloc(sizeof *iff_data);\n        LY_CHECK_ERR_RETURN(!iff_data, LOGMEM(mod->ctx), -1);\n        iff_data->fname = lydict_insert(mod->ctx, ((struct unres_iffeat_data *)unres->str_snode[i])->fname, 0);\n        iff_data->node = ((struct unres_iffeat_data *)unres->str_snode[i])->node;\n        if (unres_schema_add_node(mod, unres, new_item, type, (struct lys_node *)iff_data) == -1) {\n            LOGINT(mod->ctx);\n            return -1;\n        }\n    } else {\n        if (unres_schema_add_str(mod, unres, new_item, type, unres->str_snode[i]) == -1) {\n            LOGINT(mod->ctx);\n            return -1;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* does not log */\nint\nunres_schema_find(struct unres_schema *unres, int start_on_backwards, void *item, enum UNRES_ITEM type)\n{\n    int i;\n    struct unres_list_uniq *aux_uniq1, *aux_uniq2;\n\n    if (!unres->count) {\n        return -1;\n    }\n\n    if (start_on_backwards >= 0) {\n        i = start_on_backwards;\n    } else {\n        i = unres->count - 1;\n    }\n    for (; i > -1; i--) {\n        if (unres->type[i] != type) {\n            continue;\n        }\n        if (type != UNRES_LIST_UNIQ) {\n            if (unres->item[i] == item) {\n                break;\n            }\n        } else {\n            aux_uniq1 = (struct unres_list_uniq *)unres->item[i];\n            aux_uniq2 = (struct unres_list_uniq *)item;\n            if ((aux_uniq1->list == aux_uniq2->list) && ly_strequal(aux_uniq1->expr, aux_uniq2->expr, 0)) {\n                break;\n            }\n        }\n    }\n\n    return i;\n}\n\nstatic void\nunres_schema_free_item(struct ly_ctx *ctx, struct unres_schema *unres, uint32_t i)\n{\n    struct lyxml_elem *yin;\n    struct yang_type *yang;\n    struct unres_iffeat_data *iff_data;\n\n    switch (unres->type[i]) {\n    case UNRES_TYPE_DER_TPDF:\n    case UNRES_TYPE_DER:\n        yin = (struct lyxml_elem *)((struct lys_type *)unres->item[i])->der;\n        if (yin->flags & LY_YANG_STRUCTURE_FLAG) {\n            yang =(struct yang_type *)yin;\n            ((struct lys_type *)unres->item[i])->base = yang->base;\n            lydict_remove(ctx, yang->name);\n            free(yang);\n            if (((struct lys_type *)unres->item[i])->base == LY_TYPE_UNION) {\n                yang_free_type_union(ctx, (struct lys_type *)unres->item[i]);\n            }\n        } else {\n            lyxml_free(ctx, yin);\n        }\n        break;\n    case UNRES_IFFEAT:\n        iff_data = (struct unres_iffeat_data *)unres->str_snode[i];\n        lydict_remove(ctx, iff_data->fname);\n        free(unres->str_snode[i]);\n        break;\n    case UNRES_IDENT:\n    case UNRES_TYPE_IDENTREF:\n    case UNRES_CHOICE_DFLT:\n    case UNRES_LIST_KEYS:\n        lydict_remove(ctx, (const char *)unres->str_snode[i]);\n        break;\n    case UNRES_LIST_UNIQ:\n        free(unres->item[i]);\n        break;\n    case UNRES_EXT:\n        free(unres->str_snode[i]);\n        break;\n    case UNRES_EXT_FINALIZE:\n        free(unres->str_snode[i]);\n    default:\n        break;\n    }\n    unres->type[i] = UNRES_RESOLVED;\n}\n\nvoid\nunres_schema_free(struct lys_module *module, struct unres_schema **unres, int all)\n{\n    uint32_t i;\n    unsigned int unresolved = 0;\n\n    if (!unres || !(*unres)) {\n        return;\n    }\n\n    assert(module || ((*unres)->count == 0));\n\n    for (i = 0; i < (*unres)->count; ++i) {\n        if (!all && ((*unres)->module[i] != module)) {\n            if ((*unres)->type[i] != UNRES_RESOLVED) {\n                unresolved++;\n            }\n            continue;\n        }\n\n        /* free heap memory for the specific item */\n        unres_schema_free_item(module->ctx, *unres, i);\n    }\n\n    /* free it all */\n    if (!module || all || (!unresolved && !module->type)) {\n        free((*unres)->item);\n        free((*unres)->type);\n        free((*unres)->str_snode);\n        free((*unres)->module);\n        free((*unres));\n        (*unres) = NULL;\n    }\n}\n\n/* check whether instance-identifier points outside its data subtree (for operation it is any node\n * outside the operation subtree, otherwise it is a node from a foreign model) */\nstatic int\ncheck_instid_ext_dep(const struct lys_node *sleaf, const char *json_instid)\n{\n    const struct lys_node *op_node, *first_node;\n    enum int_log_opts prev_ilo;\n    char *buf, *tmp;\n\n    if (!json_instid || !json_instid[0]) {\n        /* no/empty value */\n        return 0;\n    }\n\n    for (op_node = lys_parent(sleaf);\n         op_node && !(op_node->nodetype & (LYS_NOTIF | LYS_RPC | LYS_ACTION));\n         op_node = lys_parent(op_node));\n\n    if (op_node && lys_parent(op_node)) {\n        /* nested operation - any absolute path is external */\n        return 1;\n    }\n\n    /* get the first node from the instid */\n    tmp = strchr(json_instid + 1, '/');\n    buf = strndup(json_instid, tmp ? (size_t)(tmp - json_instid) : strlen(json_instid));\n    if (!buf) {\n        /* so that we do not have to bother with logging, say it is not external */\n        return 0;\n    }\n\n    /* find the first schema node, do not log */\n    ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n    first_node = ly_ctx_get_node(NULL, sleaf, buf, 0);\n    ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n\n    free(buf);\n    if (!first_node) {\n        /* unknown path, say it is external */\n        return 1;\n    }\n\n    /* based on the first schema node in the path we can decide whether it points to an external tree or not */\n\n    if (op_node) {\n        if (op_node != first_node) {\n            /* it is a top-level operation, so we're good if it points somewhere inside it */\n            return 1;\n        }\n    } else {\n        if (lys_node_module(sleaf) != lys_node_module(first_node)) {\n            /* modules differ */\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n/**\n * @brief Resolve instance-identifier in JSON data format. Logs directly.\n *\n * @param[in] data Data node where the path is used\n * @param[in] path Instance-identifier node value.\n * @param[in,out] ret Resolved instance or NULL.\n *\n * @return 0 on success (even if unresolved and \\p ret is NULL), -1 on error.\n */\nstatic int\nresolve_instid(struct lyd_node *data, const char *path, int req_inst, struct lyd_node **ret)\n{\n    int i = 0, j, parsed, cur_idx;\n    const struct lys_module *mod, *prev_mod = NULL;\n    struct ly_ctx *ctx = data->schema->module->ctx;\n    struct lyd_node *root, *node;\n    const char *model = NULL, *name;\n    char *str;\n    int mod_len, name_len, has_predicate;\n    struct unres_data node_match;\n\n    memset(&node_match, 0, sizeof node_match);\n    *ret = NULL;\n\n    /* we need root to resolve absolute path */\n    for (root = data; root->parent; root = root->parent);\n    /* we're still parsing it and the pointer is not correct yet */\n    if (root->prev) {\n        for (; root->prev->next; root = root->prev);\n    }\n\n    /* search for the instance node */\n    while (path[i]) {\n        j = parse_instance_identifier(&path[i], &model, &mod_len, &name, &name_len, &has_predicate);\n        if (j <= 0) {\n            LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYD, data, path[i-j], &path[i-j]);\n            goto error;\n        }\n        i += j;\n\n        if (model) {\n            str = strndup(model, mod_len);\n            if (!str) {\n                LOGMEM(ctx);\n                goto error;\n            }\n            mod = ly_ctx_get_module(ctx, str, NULL, 1);\n            if (ctx->data_clb) {\n                if (!mod) {\n                    mod = ctx->data_clb(ctx, str, NULL, 0, ctx->data_clb_data);\n                } else if (!mod->implemented) {\n                    mod = ctx->data_clb(ctx, mod->name, mod->ns, LY_MODCLB_NOT_IMPLEMENTED, ctx->data_clb_data);\n                }\n            }\n            free(str);\n\n            if (!mod || !mod->implemented || mod->disabled) {\n                break;\n            }\n        } else if (!prev_mod) {\n            /* first iteration and we are missing module name */\n            LOGVAL(ctx, LYE_INELEM_LEN, LY_VLOG_LYD, data, name_len, name);\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Instance-identifier is missing prefix in the first node.\");\n            goto error;\n        } else {\n            mod = prev_mod;\n        }\n\n        if (resolve_data(mod, name, name_len, root, &node_match)) {\n            /* no instance exists */\n            break;\n        }\n\n        if (has_predicate) {\n            /* we have predicate, so the current results must be list or leaf-list */\n            parsed = j = 0;\n            /* index of the current node (for lists with position predicates) */\n            cur_idx = 1;\n            while (j < (signed)node_match.count) {\n                node = node_match.node[j];\n                parsed = resolve_instid_predicate(mod, &path[i], &node, cur_idx);\n                if (parsed < 1) {\n                    LOGVAL(ctx, LYE_INPRED, LY_VLOG_LYD, data, &path[i - parsed]);\n                    goto error;\n                }\n\n                if (!node) {\n                    /* current node does not satisfy the predicate */\n                    unres_data_del(&node_match, j);\n                } else {\n                    ++j;\n                }\n                ++cur_idx;\n            }\n\n            i += parsed;\n        } else if (node_match.count) {\n            /* check that we are not addressing lists */\n            for (j = 0; (unsigned)j < node_match.count; ++j) {\n                if (node_match.node[j]->schema->nodetype == LYS_LIST) {\n                    unres_data_del(&node_match, j--);\n                }\n            }\n            if (!node_match.count) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYD, data, \"Instance identifier is missing list keys.\");\n            }\n        }\n\n        prev_mod = mod;\n    }\n\n    if (!node_match.count) {\n        /* no instance exists */\n        if (req_inst > -1) {\n            LOGVAL(ctx, LYE_NOREQINS, LY_VLOG_LYD, data, path);\n            return EXIT_FAILURE;\n        }\n        LOGVRB(\"There is no instance of \\\"%s\\\", but it is not required.\", path);\n        return EXIT_SUCCESS;\n    } else if (node_match.count > 1) {\n        /* instance identifier must resolve to a single node */\n        LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYD, data, path, \"data tree\");\n        goto error;\n    } else {\n        /* we have required result, remember it and cleanup */\n        *ret = node_match.node[0];\n        free(node_match.node);\n        return EXIT_SUCCESS;\n    }\n\nerror:\n    /* cleanup */\n    free(node_match.node);\n    return -1;\n}\n\nstatic int\nresolve_leafref(struct lyd_node_leaf_list *leaf, const char *path, int req_inst, struct lyd_node **ret)\n{\n    struct lyxp_set xp_set;\n    uint32_t i;\n\n    memset(&xp_set, 0, sizeof xp_set);\n    *ret = NULL;\n\n    /* syntax was already checked, so just evaluate the path using standard XPath */\n    if (lyxp_eval(path, (struct lyd_node *)leaf, LYXP_NODE_ELEM, lyd_node_module((struct lyd_node *)leaf), &xp_set, 0) != EXIT_SUCCESS) {\n        return -1;\n    }\n\n    if (xp_set.type == LYXP_SET_NODE_SET) {\n        for (i = 0; i < xp_set.used; ++i) {\n            if ((xp_set.val.nodes[i].type != LYXP_NODE_ELEM) || !(xp_set.val.nodes[i].node->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n                continue;\n            }\n\n            /* not that the value is already in canonical form since the parsers does the conversion,\n             * so we can simply compare just the values */\n            if (ly_strequal(leaf->value_str, ((struct lyd_node_leaf_list *)xp_set.val.nodes[i].node)->value_str, 1)) {\n                /* we have the match */\n                *ret = xp_set.val.nodes[i].node;\n                break;\n            }\n        }\n    }\n\n    lyxp_set_cast(&xp_set, LYXP_SET_EMPTY, (struct lyd_node *)leaf, NULL, 0);\n\n    if (!*ret) {\n        /* reference not found */\n        if (req_inst > -1) {\n            LOGVAL(leaf->schema->module->ctx, LYE_NOLEAFREF, LY_VLOG_LYD, leaf, path, leaf->value_str);\n            return EXIT_FAILURE;\n        } else {\n            LOGVRB(\"There is no leafref \\\"%s\\\" with the value \\\"%s\\\", but it is not required.\", path, leaf->value_str);\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* ignore fail because we are parsing edit-config, get, or get-config - but only if the union includes leafref or instid */\nint\nresolve_union(struct lyd_node_leaf_list *leaf, struct lys_type *type, int store, int ignore_fail,\n              struct lys_type **resolved_type)\n{\n    struct ly_ctx *ctx = leaf->schema->module->ctx;\n    struct lys_type *t;\n    struct lyd_node *ret;\n    enum int_log_opts prev_ilo;\n    int found, success = 0, ext_dep, req_inst;\n    const char *json_val = NULL;\n\n    assert(type->base == LY_TYPE_UNION);\n\n    if ((leaf->value_type == LY_TYPE_UNION) || ((leaf->value_type == LY_TYPE_INST) && (leaf->value_flags & LY_VALUE_UNRES))) {\n        /* either NULL or instid previously converted to JSON */\n        json_val = lydict_insert(ctx, leaf->value.string, 0);\n    }\n\n    if (store) {\n        lyd_free_value(leaf->value, leaf->value_type, leaf->value_flags, &((struct lys_node_leaf *)leaf->schema)->type,\n                       NULL, NULL, NULL);\n        memset(&leaf->value, 0, sizeof leaf->value);\n    }\n\n    /* turn logging off, we are going to try to validate the value with all the types in order */\n    ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, 0);\n\n    t = NULL;\n    found = 0;\n    while ((t = lyp_get_next_union_type(type, t, &found))) {\n        found = 0;\n\n        switch (t->base) {\n        case LY_TYPE_LEAFREF:\n            if ((ignore_fail == 1) || ((leaf->schema->flags & LYS_LEAFREF_DEP) && (ignore_fail == 2))) {\n                req_inst = -1;\n            } else {\n                req_inst = t->info.lref.req;\n            }\n\n            if (!resolve_leafref(leaf, t->info.lref.path, req_inst, &ret)) {\n                if (store) {\n                    if (ret && !(leaf->schema->flags & LYS_LEAFREF_DEP)) {\n                        /* valid resolved */\n                        leaf->value.leafref = ret;\n                        leaf->value_type = LY_TYPE_LEAFREF;\n                    } else {\n                        /* valid unresolved */\n                        ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n                        if (!lyp_parse_value(t, &leaf->value_str, NULL, leaf, NULL, NULL, 1, 0, 0)) {\n                            return -1;\n                        }\n                        ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n                    }\n                }\n\n                success = 1;\n            }\n            break;\n        case LY_TYPE_INST:\n            ext_dep = check_instid_ext_dep(leaf->schema, (json_val ? json_val : leaf->value_str));\n            if ((ignore_fail == 1) || (ext_dep && (ignore_fail == 2))) {\n                req_inst = -1;\n            } else {\n                req_inst = t->info.inst.req;\n            }\n\n            if (!resolve_instid((struct lyd_node *)leaf, (json_val ? json_val : leaf->value_str), req_inst, &ret)) {\n                if (store) {\n                    if (ret && !ext_dep) {\n                        /* valid resolved */\n                        leaf->value.instance = ret;\n                        leaf->value_type = LY_TYPE_INST;\n\n                        if (json_val) {\n                            lydict_remove(leaf->schema->module->ctx, leaf->value_str);\n                            leaf->value_str = json_val;\n                            json_val = NULL;\n                        }\n                    } else {\n                        /* valid unresolved */\n                        if (json_val) {\n                            /* put the JSON val back */\n                            leaf->value.string = json_val;\n                            json_val = NULL;\n                        } else {\n                            leaf->value.instance = NULL;\n                        }\n                        leaf->value_type = LY_TYPE_INST;\n                        leaf->value_flags |= LY_VALUE_UNRES;\n                    }\n                }\n\n                success = 1;\n            }\n            break;\n        default:\n            if (lyp_parse_value(t, &leaf->value_str, NULL, leaf, NULL, NULL, store, 0, 0)) {\n                success = 1;\n            }\n            break;\n        }\n\n        if (success) {\n            break;\n        }\n\n        /* erase possible present and invalid value data */\n        if (store) {\n            lyd_free_value(leaf->value, leaf->value_type, leaf->value_flags, t, NULL, NULL, NULL);\n            memset(&leaf->value, 0, sizeof leaf->value);\n        }\n    }\n\n    /* turn logging back on */\n    ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n\n    if (json_val) {\n        if (!success) {\n            /* put the value back for now */\n            assert(leaf->value_type == LY_TYPE_UNION);\n            leaf->value.string = json_val;\n        } else {\n            /* value was ultimately useless, but we could not have known */\n            lydict_remove(leaf->schema->module->ctx, json_val);\n        }\n    }\n\n    if (success) {\n        if (resolved_type) {\n            *resolved_type = t;\n        }\n    } else if (!ignore_fail || !type->info.uni.has_ptr_type) {\n        /* not found and it is required */\n        LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, leaf, leaf->value_str ? leaf->value_str : \"\", leaf->schema->name);\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n\n}\n\n/**\n * @brief Resolve a single unres data item. Logs directly.\n *\n * @param[in] node Data node to resolve.\n * @param[in] type Type of the unresolved item.\n * @param[in] ignore_fail 0 - no, 1 - yes, 2 - yes, but only for external dependencies.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nint\nresolve_unres_data_item(struct lyd_node *node, enum UNRES_ITEM type, int ignore_fail, struct lys_when **failed_when)\n{\n    int rc, req_inst, ext_dep;\n    struct lyd_node_leaf_list *leaf;\n    struct lyd_node *ret;\n    struct lys_node_leaf *sleaf;\n\n    leaf = (struct lyd_node_leaf_list *)node;\n    sleaf = (struct lys_node_leaf *)leaf->schema;\n\n    switch (type) {\n    case UNRES_LEAFREF:\n        assert(sleaf->type.base == LY_TYPE_LEAFREF);\n        assert(leaf->validity & LYD_VAL_LEAFREF);\n        if ((ignore_fail == 1) || ((leaf->schema->flags & LYS_LEAFREF_DEP) && (ignore_fail == 2))) {\n            req_inst = -1;\n        } else {\n            req_inst = sleaf->type.info.lref.req;\n        }\n        rc = resolve_leafref(leaf, sleaf->type.info.lref.path, req_inst, &ret);\n        if (!rc) {\n            if (ret && !(leaf->schema->flags & LYS_LEAFREF_DEP)) {\n                /* valid resolved */\n                if (leaf->value_type == LY_TYPE_BITS) {\n                    free(leaf->value.bit);\n                }\n                leaf->value.leafref = ret;\n                leaf->value_type = LY_TYPE_LEAFREF;\n                leaf->value_flags &= ~LY_VALUE_UNRES;\n            } else {\n                /* valid unresolved */\n                if (!(leaf->value_flags & LY_VALUE_UNRES)) {\n                    if (!lyp_parse_value(&sleaf->type, &leaf->value_str, NULL, leaf, NULL, NULL, 1, 0, 0)) {\n                        return -1;\n                    }\n                }\n            }\n            leaf->validity &= ~LYD_VAL_LEAFREF;\n        } else {\n            return rc;\n        }\n        break;\n\n    case UNRES_INSTID:\n        assert(sleaf->type.base == LY_TYPE_INST);\n        ext_dep = check_instid_ext_dep(leaf->schema, leaf->value_str);\n        if (ext_dep == -1) {\n            return -1;\n        }\n\n        if ((ignore_fail == 1) || (ext_dep && (ignore_fail == 2))) {\n            req_inst = -1;\n        } else {\n            req_inst = sleaf->type.info.inst.req;\n        }\n        rc = resolve_instid(node, leaf->value_str, req_inst, &ret);\n        if (!rc) {\n            if (ret && !ext_dep) {\n                /* valid resolved */\n                leaf->value.instance = ret;\n                leaf->value_type = LY_TYPE_INST;\n                leaf->value_flags &= ~LY_VALUE_UNRES;\n            } else {\n                /* valid unresolved */\n                leaf->value.instance = NULL;\n                leaf->value_type = LY_TYPE_INST;\n                leaf->value_flags |= LY_VALUE_UNRES;\n            }\n        } else {\n            return rc;\n        }\n        break;\n\n    case UNRES_UNION:\n        assert(sleaf->type.base == LY_TYPE_UNION);\n        return resolve_union(leaf, &sleaf->type, 1, ignore_fail, NULL);\n\n    case UNRES_WHEN:\n        if ((rc = resolve_when(node, ignore_fail, failed_when))) {\n            return rc;\n        }\n        break;\n\n    case UNRES_MUST:\n        if ((rc = resolve_must(node, 0, ignore_fail))) {\n            return rc;\n        }\n        break;\n\n    case UNRES_MUST_INOUT:\n        if ((rc = resolve_must(node, 1, ignore_fail))) {\n            return rc;\n        }\n        break;\n\n    case UNRES_UNIQ_LEAVES:\n        if (lyv_data_unique(node)) {\n            return -1;\n        }\n        break;\n\n    default:\n        LOGINT(NULL);\n        return -1;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief add data unres item\n *\n * @param[in] unres Unres data structure to use.\n * @param[in] node Data node to use.\n *\n * @return 0 on success, -1 on error.\n */\nint\nunres_data_add(struct unres_data *unres, struct lyd_node *node, enum UNRES_ITEM type)\n{\n    assert(unres && node);\n    assert((type == UNRES_LEAFREF) || (type == UNRES_INSTID) || (type == UNRES_WHEN) || (type == UNRES_MUST)\n           || (type == UNRES_MUST_INOUT) || (type == UNRES_UNION) || (type == UNRES_UNIQ_LEAVES));\n\n    unres->count++;\n    unres->node = ly_realloc(unres->node, unres->count * sizeof *unres->node);\n    LY_CHECK_ERR_RETURN(!unres->node, LOGMEM(NULL), -1);\n    unres->node[unres->count - 1] = node;\n    unres->type = ly_realloc(unres->type, unres->count * sizeof *unres->type);\n    LY_CHECK_ERR_RETURN(!unres->type, LOGMEM(NULL), -1);\n    unres->type[unres->count - 1] = type;\n\n    return 0;\n}\n\nstatic void\nresolve_unres_data_autodel_diff(struct unres_data *unres, uint32_t unres_i)\n{\n    struct lyd_node *next, *child, *parent;\n    uint32_t i;\n\n    for (i = 0; i < unres->diff_idx; ++i) {\n        if (unres->diff->type[i] == LYD_DIFF_DELETED) {\n            /* only leaf(-list) default could be removed and there is nothing to be checked in that case */\n            continue;\n        }\n\n        if (unres->diff->second[i] == unres->node[unres_i]) {\n            /* 1) default value was supposed to be created, but is disabled by when\n             * -> remove it from diff altogether\n             */\n            unres_data_diff_rem(unres, i);\n            /* if diff type is CREATED, the value was just a pointer, it can be freed normally (unlike in 4) */\n            return;\n        } else {\n            parent = unres->diff->second[i]->parent;\n            while (parent && (parent != unres->node[unres_i])) {\n                parent = parent->parent;\n            }\n            if (parent) {\n                /* 2) default value was supposed to be created but is disabled by when in some parent\n                 * -> remove this default subtree and add the rest into diff as deleted instead in 4)\n                 */\n                unres_data_diff_rem(unres, i);\n                break;\n            }\n\n            LY_TREE_DFS_BEGIN(unres->diff->second[i]->parent, next, child) {\n                if (child == unres->node[unres_i]) {\n                    /* 3) some default child of a default value was supposed to be created but has false when\n                     * -> the subtree will be freed later and automatically disconnected from the diff parent node\n                     */\n                    return;\n                }\n\n                LY_TREE_DFS_END(unres->diff->second[i]->parent, next, child);\n            }\n        }\n    }\n\n    /* 4) it does not overlap with created default values in any way\n     * -> just add it into diff as deleted\n     */\n    unres_data_diff_new(unres, unres->node[unres_i], unres->node[unres_i]->parent, 0);\n    lyd_unlink(unres->node[unres_i]);\n\n    /* should not be freed anymore */\n    unres->node[unres_i] = NULL;\n}\n\n/**\n * @brief Resolve every unres data item in the structure. Logs directly.\n *\n * If options include #LYD_OPT_TRUSTED, the data are considered trusted (must conditions are not expected,\n * unresolved leafrefs/instids are accepted, when conditions are normally resolved because at least some implicit\n * non-presence containers may need to be deleted).\n *\n * If options includes #LYD_OPT_WHENAUTODEL, the non-default nodes with false when conditions are auto-deleted.\n *\n * @param[in] ctx Context used.\n * @param[in] unres Unres data structure to use.\n * @param[in,out] root Root node of the data tree, can be changed due to autodeletion.\n * @param[in] options Data options as described above.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nint\nresolve_unres_data(struct ly_ctx *ctx, struct unres_data *unres, struct lyd_node **root, int options)\n{\n    uint32_t i, j, first, resolved, del_items, stmt_count;\n    uint8_t prev_when_status;\n    int rc, progress, ignore_fail;\n    enum int_log_opts prev_ilo;\n    struct ly_err_item *prev_eitem;\n    LY_ERR prev_ly_errno = ly_errno;\n    struct lyd_node *parent;\n    struct lys_when *when;\n\n    assert(root);\n    assert(unres);\n\n    if (!unres->count) {\n        return EXIT_SUCCESS;\n    }\n\n    if (options & (LYD_OPT_NOTIF_FILTER | LYD_OPT_GET | LYD_OPT_GETCONFIG | LYD_OPT_EDIT)) {\n        ignore_fail = 1;\n    } else if (options & LYD_OPT_NOEXTDEPS) {\n        ignore_fail = 2;\n    } else {\n        ignore_fail = 0;\n    }\n\n    LOGVRB(\"Resolving unresolved data nodes and their constraints...\");\n    if (!ignore_fail) {\n        /* remember logging state only if errors are generated and valid */\n        ly_ilo_change(ctx, ILO_STORE, &prev_ilo, &prev_eitem);\n    }\n\n    /*\n     * when-stmt first\n     */\n    first = 1;\n    stmt_count = 0;\n    resolved = 0;\n    del_items = 0;\n    do {\n        if (!ignore_fail) {\n            ly_err_free_next(ctx, prev_eitem);\n        }\n        progress = 0;\n        for (i = 0; i < unres->count; i++) {\n            if (unres->type[i] != UNRES_WHEN) {\n                continue;\n            }\n            if (first) {\n                /* count when-stmt nodes in unres list */\n                stmt_count++;\n            }\n\n            /* resolve when condition only when all parent when conditions are already resolved */\n            for (parent = unres->node[i]->parent;\n                 parent && LYD_WHEN_DONE(parent->when_status);\n                 parent = parent->parent) {\n                if (!parent->parent && (parent->when_status & LYD_WHEN_FALSE)) {\n                    /* the parent node was already unlinked, do not resolve this node,\n                     * it will be removed anyway, so just mark it as resolved\n                     */\n                    unres->node[i]->when_status |= LYD_WHEN_FALSE;\n                    unres->type[i] = UNRES_RESOLVED;\n                    resolved++;\n                    break;\n                }\n            }\n            if (parent) {\n                continue;\n            }\n\n            prev_when_status = unres->node[i]->when_status;\n            rc = resolve_unres_data_item(unres->node[i], unres->type[i], ignore_fail, &when);\n            if (!rc) {\n                /* finish with error/delete the node only if when was changed from true to false, an external\n                 * dependency was not required, or it was not provided (the flag would not be passed down otherwise,\n                 * checked in upper functions) */\n                if ((unres->node[i]->when_status & LYD_WHEN_FALSE)\n                        && (!(when->flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP)) || !(options & LYD_OPT_NOEXTDEPS))) {\n                    if ((!(prev_when_status & LYD_WHEN_TRUE) || !(options & LYD_OPT_WHENAUTODEL)) && !unres->node[i]->dflt) {\n                        /* false when condition */\n                        goto error;\n                    } /* follows else */\n\n                    /* auto-delete */\n                    LOGVRB(\"Auto-deleting node \\\"%s\\\" due to when condition (%s)\", ly_errpath(ctx), when->cond);\n\n                    /* only unlink now, the subtree can contain another nodes stored in the unres list */\n                    /* if it has parent non-presence containers that would be empty, we should actually\n                     * remove the container\n                     */\n                    for (parent = unres->node[i];\n                            parent->parent && parent->parent->schema->nodetype == LYS_CONTAINER;\n                            parent = parent->parent) {\n                        if (((struct lys_node_container *)parent->parent->schema)->presence) {\n                            /* presence container */\n                            break;\n                        }\n                        if (parent->next || parent->prev != parent) {\n                            /* non empty (the child we are in and we are going to remove is not the only child) */\n                            break;\n                        }\n                    }\n                    unres->node[i] = parent;\n\n                    if (*root && *root == unres->node[i]) {\n                        *root = (*root)->next;\n                    }\n\n                    lyd_unlink(unres->node[i]);\n                    unres->type[i] = UNRES_DELETE;\n                    del_items++;\n\n                    /* update the rest of unres items */\n                    for (j = 0; j < unres->count; j++) {\n                        if (unres->type[j] == UNRES_RESOLVED || unres->type[j] == UNRES_DELETE) {\n                            continue;\n                        }\n\n                        /* test if the node is in subtree to be deleted */\n                        for (parent = unres->node[j]; parent; parent = parent->parent) {\n                            if (parent == unres->node[i]) {\n                                /* yes, it is */\n                                unres->type[j] = UNRES_RESOLVED;\n                                resolved++;\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    unres->type[i] = UNRES_RESOLVED;\n                }\n                if (!ignore_fail) {\n                    ly_err_free_next(ctx, prev_eitem);\n                }\n                resolved++;\n                progress = 1;\n            } else if (rc == -1) {\n                goto error;\n            } /* else forward reference */\n        }\n        first = 0;\n    } while (progress && resolved < stmt_count);\n\n    /* do we have some unresolved when-stmt? */\n    if (stmt_count > resolved) {\n        goto error;\n    }\n\n    for (i = 0; del_items && i < unres->count; i++) {\n        /* we had some when-stmt resulted to false, so now we have to sanitize the unres list */\n        if (unres->type[i] != UNRES_DELETE) {\n            continue;\n        }\n        if (!unres->node[i]) {\n            unres->type[i] = UNRES_RESOLVED;\n            del_items--;\n            continue;\n        }\n\n        if (unres->store_diff) {\n            resolve_unres_data_autodel_diff(unres, i);\n        }\n\n        /* really remove the complete subtree */\n        lyd_free(unres->node[i]);\n        unres->type[i] = UNRES_RESOLVED;\n        del_items--;\n    }\n\n    /*\n     * now leafrefs\n     */\n    if (options & LYD_OPT_TRUSTED) {\n        /* we want to attempt to resolve leafrefs */\n        assert(!ignore_fail);\n        ignore_fail = 1;\n\n        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 0);\n        ly_errno = prev_ly_errno;\n    }\n    first = 1;\n    stmt_count = 0;\n    resolved = 0;\n    do {\n        progress = 0;\n        for (i = 0; i < unres->count; i++) {\n            if (unres->type[i] != UNRES_LEAFREF) {\n                continue;\n            }\n            if (first) {\n                /* count leafref nodes in unres list */\n                stmt_count++;\n            }\n\n            rc = resolve_unres_data_item(unres->node[i], unres->type[i], ignore_fail, NULL);\n            if (!rc) {\n                unres->type[i] = UNRES_RESOLVED;\n                if (!ignore_fail) {\n                    ly_err_free_next(ctx, prev_eitem);\n                }\n                resolved++;\n                progress = 1;\n            } else if (rc == -1) {\n                goto error;\n            } /* else forward reference */\n        }\n        first = 0;\n    } while (progress && resolved < stmt_count);\n\n    /* do we have some unresolved leafrefs? */\n    if (stmt_count > resolved) {\n        goto error;\n    }\n\n    if (!ignore_fail) {\n        /* log normally now, throw away irrelevant errors */\n        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 0);\n        ly_errno = prev_ly_errno;\n    }\n\n    /*\n     * rest\n     */\n    for (i = 0; i < unres->count; ++i) {\n        if (unres->type[i] == UNRES_RESOLVED) {\n            continue;\n        }\n        assert(!(options & LYD_OPT_TRUSTED) || ((unres->type[i] != UNRES_MUST) && (unres->type[i] != UNRES_MUST_INOUT)));\n\n        rc = resolve_unres_data_item(unres->node[i], unres->type[i], ignore_fail, NULL);\n        if (rc) {\n            /* since when was already resolved, a forward reference is an error */\n            return -1;\n        }\n\n        unres->type[i] = UNRES_RESOLVED;\n    }\n\n    LOGVRB(\"All data nodes and constraints resolved.\");\n    unres->count = 0;\n    return EXIT_SUCCESS;\n\nerror:\n    if (!ignore_fail) {\n        /* print all the new errors */\n        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 1);\n        /* do not restore ly_errno, it was udpated properly */\n    }\n    return -1;\n}\n", "/**\n * @file tree_data.c\n * @author Radek Krejci <rkrejci@cesnet.cz>\n * @brief Manipulation with libyang data structures\n *\n * Copyright (c) 2015 - 2018 CESNET, z.s.p.o.\n *\n * This source code is licensed under BSD 3-Clause License (the \"License\").\n * You may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/BSD-3-Clause\n */\n\n#define _GNU_SOURCE\n\n#include <assert.h>\n#include <ctype.h>\n#include <limits.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"libyang.h\"\n#include \"common.h\"\n#include \"context.h\"\n#include \"tree_data.h\"\n#include \"parser.h\"\n#include \"resolve.h\"\n#include \"xml_internal.h\"\n#include \"tree_internal.h\"\n#include \"validation.h\"\n#include \"xpath.h\"\n\nstatic struct lys_node *lyd_get_schema_inctx(const struct lyd_node *node, struct ly_ctx *ctx);\n\nstatic int\nlyd_anydata_equal(struct lyd_node *first, struct lyd_node *second)\n{\n    char *str1 = NULL, *str2 = NULL;\n    struct lyd_node_anydata *anydata;\n\n    assert(first->schema->nodetype & LYS_ANYDATA);\n    assert(first->schema->nodetype == second->schema->nodetype);\n\n    anydata = (struct lyd_node_anydata *)first;\n    if (!anydata->value.str) {\n        lyxml_print_mem(&str1, anydata->value.xml, LYXML_PRINT_SIBLINGS);\n        anydata->value.str = lydict_insert_zc(anydata->schema->module->ctx, str1);\n    }\n    str1 = (char *)anydata->value.str;\n\n    anydata = (struct lyd_node_anydata *)second;\n    if (!anydata->value.str) {\n        lyxml_print_mem(&str2, anydata->value.xml, LYXML_PRINT_SIBLINGS);\n        anydata->value.str = lydict_insert_zc(anydata->schema->module->ctx, str2);\n    }\n    str2 = (char *)anydata->value.str;\n\n    if (first->schema->module->ctx != second->schema->module->ctx) {\n        return ly_strequal(str1, str2, 0);\n    } else {\n        return ly_strequal(str1, str2, 1);\n    }\n}\n\n/* used in tests */\nint\nlyd_list_has_keys(struct lyd_node *list)\n{\n    struct lyd_node *iter;\n    struct lys_node_list *slist;\n    int i;\n\n    assert(list->schema->nodetype == LYS_LIST);\n\n    /* even though hash is 0, it may be a valid hash, that is what we are going to check */\n\n    slist = (struct lys_node_list *)list->schema;\n    if (!slist->keys_size) {\n        /* always has keys */\n        return 1;\n    }\n\n    i = 0;\n    iter = list->child;\n    while (iter && (i < slist->keys_size)) {\n        if (iter->schema != (struct lys_node *)slist->keys[i]) {\n            /* missing key */\n            return 0;\n        }\n\n        ++i;\n        iter = iter->next;\n    }\n    if (i < slist->keys_size) {\n        /* missing key */\n        return 0;\n    }\n\n    /* all keys found */\n    return 1;\n}\n\nstatic int\nlyd_leaf_val_equal(struct lyd_node *node1, struct lyd_node *node2, int diff_ctx)\n{\n    assert(node1->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST));\n    assert(node1->schema->nodetype == node2->schema->nodetype);\n\n    if (diff_ctx) {\n        return ly_strequal(((struct lyd_node_leaf_list *)node1)->value_str, ((struct lyd_node_leaf_list *)node2)->value_str, 0);\n    } else {\n        return ly_strequal(((struct lyd_node_leaf_list *)node1)->value_str, ((struct lyd_node_leaf_list *)node2)->value_str, 1);\n    }\n}\n\n/*\n * withdefaults (only for leaf-list):\n * 0 - treat default nodes are normal nodes\n * 1 - only change is that if 2 nodes have the same value, but one is default, the other not, they are considered non-equal\n */\nint\nlyd_list_equal(struct lyd_node *node1, struct lyd_node *node2, int with_defaults)\n{\n    int i, diff_ctx;\n    struct lyd_node *elem1, *next1, *elem2, *next2;\n    struct lys_node *elem1_sch;\n    struct ly_ctx *ctx = node2->schema->module->ctx;\n\n    diff_ctx = (node1->schema->module->ctx != node2->schema->module->ctx);\n\n    switch (node2->schema->nodetype) {\n    case LYS_LEAFLIST:\n        if (lyd_leaf_val_equal(node1, node2, diff_ctx) && (!with_defaults || (node1->dflt == node2->dflt))) {\n            return 1;\n        }\n        break;\n    case LYS_LIST:\n        if (((struct lys_node_list *)node1->schema)->keys_size) {\n            /* lists with keys, their equivalence isb ased on their keys */\n            elem1 = node1->child;\n            elem2 = node2->child;\n            elem1_sch = NULL;\n            /* the exact data order is guaranteed */\n            for (i = 0; i < ((struct lys_node_list *)node1->schema)->keys_size; ++i) {\n                if (diff_ctx && elem1) {\n                    /* we have different contexts */\n                    if (!elem1_sch) {\n                        elem1_sch = lyd_get_schema_inctx(elem1, ctx);\n                        if (!elem1_sch) {\n                            LOGERR(ctx, LY_EINVAL, \"Target context does not contain a required schema node (%s:%s).\",\n                                   lyd_node_module(elem1)->name, elem1->schema->name);\n                            return -1;\n                        }\n                    } else {\n                        /* just move to the next schema node */\n                        elem1_sch = elem1_sch->next;\n                    }\n                }\n                if (!elem1 || !elem2 || ((elem1_sch ? elem1_sch : elem1->schema) != elem2->schema)\n                        || !lyd_leaf_val_equal(elem1, elem2, diff_ctx)) {\n                    break;\n                }\n                elem1 = elem1->next;\n                elem2 = elem2->next;\n            }\n            if (i == ((struct lys_node_list *)node1->schema)->keys_size) {\n                return 1;\n            }\n        } else {\n            /* lists wihtout keys, their equivalence is based on values of all the children (both dierct and indirect) */\n            if (!node1->child && !node2->child) {\n                /* no children, nothing to compare */\n                return 1;\n            }\n\n            /* status lists without keys, we need to compare all the children :( */\n\n            /* LY_TREE_DFS_BEGIN for 2 data trees */\n            elem1 = next1 = node1->child;\n            elem2 = next2 = node2->child;\n            while (elem1 && elem2) {\n                /* node comparison */\n#ifdef LY_ENABLED_CACHE\n                if (elem1->hash != elem2->hash) {\n                    break;\n                }\n#endif\n                if (diff_ctx) {\n                    elem1_sch = lyd_get_schema_inctx(elem1, ctx);\n                    if (!elem1_sch) {\n                        LOGERR(ctx, LY_EINVAL, \"Target context does not contain a required schema node (%s:%s).\",\n                               lyd_node_module(elem1)->name, elem1->schema->name);\n                        return -1;\n                    }\n                } else {\n                    elem1_sch = elem1->schema;\n                }\n                if (elem1_sch != elem2->schema) {\n                    break;\n                }\n                if (elem2->schema->nodetype == LYS_LIST) {\n                    if (!lyd_list_has_keys(elem1) && !lyd_list_has_keys(elem2)) {\n                        /* we encountered lists without keys (but have some defined in schema), ignore them for comparison */\n                        next1 = NULL;\n                        next2 = NULL;\n                        goto next_sibling;\n                    }\n                    /* we will compare all the children of this list instance, not just keys */\n                } else if (elem2->schema->nodetype & (LYS_LEAFLIST | LYS_LEAF)) {\n                    if (!lyd_leaf_val_equal(elem1, elem2, diff_ctx) && (!with_defaults || (elem1->dflt == elem2->dflt))) {\n                        break;\n                    }\n                } else if (elem2->schema->nodetype & LYS_ANYDATA) {\n                    if (!lyd_anydata_equal(elem1, elem2)) {\n                        break;\n                    }\n                }\n\n                /* LY_TREE_DFS_END for 2 data trees */\n                if (elem2->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                    next1 = NULL;\n                    next2 = NULL;\n                } else {\n                    next1 = elem1->child;\n                    next2 = elem2->child;\n                }\n\nnext_sibling:\n                if (!next1) {\n                    next1 = elem1->next;\n                }\n                if (!next2) {\n                    next2 = elem2->next;\n                }\n\n                while (!next1) {\n                    elem1 = elem1->parent;\n                    if (elem1 == node1) {\n                        break;\n                    }\n                    next1 = elem1->next;\n                }\n                while (!next2) {\n                    elem2 = elem2->parent;\n                    if (elem2 == node2) {\n                        break;\n                    }\n                    next2 = elem2->next;\n                }\n\n                elem1 = next1;\n                elem2 = next2;\n            }\n\n            if (!elem1 && !elem2) {\n                /* all children were successfully compared */\n                return 1;\n            }\n        }\n        break;\n    default:\n        LOGINT(ctx);\n        return -1;\n    }\n\n    return 0;\n}\n\n#ifdef LY_ENABLED_CACHE\n\nstatic int\nlyd_hash_table_val_equal(void *val1_p, void *val2_p, int mod, void *UNUSED(cb_data))\n{\n    struct lyd_node *val1, *val2;\n\n    val1 = *((struct lyd_node **)val1_p);\n    val2 = *((struct lyd_node **)val2_p);\n\n    if (mod) {\n        if (val1 == val2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    if (val1->schema != val2->schema) {\n        return 0;\n    }\n\n    switch (val1->schema->nodetype) {\n    case LYS_CONTAINER:\n    case LYS_LEAF:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        return 1;\n    case LYS_LEAFLIST:\n    case LYS_LIST:\n        return lyd_list_equal(val1, val2, 0);\n    default:\n        break;\n    }\n\n    LOGINT(val1->schema->module->ctx);\n    return 0;\n}\n\nstatic void\nlyd_hash_keyless_list_dfs(struct lyd_node *child, uint32_t *hash)\n{\n    LY_TREE_FOR(child, child) {\n        switch (child->schema->nodetype) {\n        case LYS_CONTAINER:\n            lyd_hash_keyless_list_dfs(child->child, hash);\n            break;\n        case LYS_LIST:\n            /* ignore lists with missing keys */\n            if (lyd_list_has_keys(child)) {\n                lyd_hash_keyless_list_dfs(child->child, hash);\n            }\n            break;\n        case LYS_LEAFLIST:\n        case LYS_ANYXML:\n        case LYS_ANYDATA:\n        case LYS_LEAF:\n            *hash = dict_hash_multi(*hash, (char *)&child->hash, sizeof child->hash);\n            break;\n        default:\n            assert(0);\n        }\n    }\n}\n\nint\nlyd_hash(struct lyd_node *node)\n{\n    struct lyd_node *iter;\n    int i;\n\n    assert(!node->hash || ((node->schema->nodetype == LYS_LIST) && !((struct lys_node_list *)node->schema)->keys_size));\n\n    if ((node->schema->nodetype != LYS_LIST) || lyd_list_has_keys(node)) {\n        node->hash = dict_hash_multi(0, lyd_node_module(node)->name, strlen(lyd_node_module(node)->name));\n        node->hash = dict_hash_multi(node->hash, node->schema->name, strlen(node->schema->name));\n        if (node->schema->nodetype == LYS_LEAFLIST) {\n            node->hash = dict_hash_multi(node->hash, ((struct lyd_node_leaf_list *)node)->value_str,\n                                        strlen(((struct lyd_node_leaf_list *)node)->value_str));\n        } else if (node->schema->nodetype == LYS_LIST) {\n            if (((struct lys_node_list *)node->schema)->keys_size) {\n                for (i = 0, iter = node->child; i < ((struct lys_node_list *)node->schema)->keys_size; ++i, iter = iter->next) {\n                    assert(iter);\n                    node->hash = dict_hash_multi(node->hash, ((struct lyd_node_leaf_list *)iter)->value_str,\n                                                 strlen(((struct lyd_node_leaf_list *)iter)->value_str));\n                }\n            } else {\n                /* no-keys list */\n                lyd_hash_keyless_list_dfs(node->child, &node->hash);\n            }\n        }\n        node->hash = dict_hash_multi(node->hash, NULL, 0);\n        return 0;\n    }\n\n    return 1;\n}\n\nstatic void\nlyd_keyless_list_hash_change(struct lyd_node *parent)\n{\n    int r;\n\n    while (parent && (parent->schema->flags & LYS_CONFIG_R)) {\n        if (parent->schema->nodetype == LYS_LIST) {\n            if (!((struct lys_node_list *)parent->schema)->keys_size) {\n                if (parent->parent && parent->parent->ht) {\n                    /* remove the list from the parent */\n                    r = lyht_remove(parent->parent->ht, &parent, parent->hash);\n                    assert(!r);\n                    (void)r;\n                }\n                /* recalculate the hash */\n                lyd_hash(parent);\n                if (parent->parent && parent->parent->ht) {\n                    /* re-add the list again */\n                    r = lyht_insert(parent->parent->ht, &parent, parent->hash, NULL);\n                    assert(!r);\n                    (void)r;\n                }\n            } else if (!lyd_list_has_keys(parent)) {\n                /* a parent is a list without keys so it cannot be a part of any parent hash */\n                break;\n            }\n        }\n\n        parent = parent->parent;\n    }\n}\n\nstatic void\n_lyd_insert_hash(struct lyd_node *node, int keyless_list_check)\n{\n    struct lyd_node *iter;\n    int i;\n\n    if (node->parent) {\n        if ((node->schema->nodetype != LYS_LIST) || lyd_list_has_keys(node)) {\n            if ((node->schema->nodetype == LYS_LEAF) && lys_is_key((struct lys_node_leaf *)node->schema, NULL)) {\n                /* we are adding a key which means that it may be the last missing key for our parent's hash */\n                if (!lyd_hash(node->parent)) {\n                    /* yep, we successfully hashed node->parent so it is technically now added to its parent (hash-wise) */\n                    _lyd_insert_hash(node->parent, 0);\n                }\n            }\n\n            /* create parent hash table if required, otherwise just add the new child */\n            if (!node->parent->ht) {\n                for (i = 0, iter = node->parent->child; iter; ++i, iter = iter->next) {\n                    if ((iter->schema->nodetype == LYS_LIST) && !lyd_list_has_keys(iter)) {\n                        /* it will either never have keys and will never be hashed or has not all keys created yet */\n                        --i;\n                    }\n                }\n                assert(i <= LY_CACHE_HT_MIN_CHILDREN);\n                if (i == LY_CACHE_HT_MIN_CHILDREN) {\n                    /* create hash table, insert all the children */\n                    node->parent->ht = lyht_new(1, sizeof(struct lyd_node *), lyd_hash_table_val_equal, NULL, 1);\n                    LY_TREE_FOR(node->parent->child, iter) {\n                        if ((iter->schema->nodetype == LYS_LIST) && !lyd_list_has_keys(iter)) {\n                            /* skip lists without keys */\n                            continue;\n                        }\n\n                        if (lyht_insert(node->parent->ht, &iter, iter->hash, NULL)) {\n                            assert(0);\n                        }\n                    }\n                }\n            } else {\n                if (lyht_insert(node->parent->ht, &node, node->hash, NULL)) {\n                    assert(0);\n                }\n            }\n\n            /* if node was in a state data subtree, wasn't it a part of a key-less list hash? */\n            if (keyless_list_check) {\n                lyd_keyless_list_hash_change(node->parent);\n            }\n        }\n    }\n}\n\n/* we have inserted node into a parent */\nvoid\nlyd_insert_hash(struct lyd_node *node)\n{\n    _lyd_insert_hash(node, 1);\n}\n\nstatic void\n_lyd_unlink_hash(struct lyd_node *node, struct lyd_node *orig_parent, int keyless_list_check)\n{\n#ifndef NDEBUG\n    struct lyd_node *iter;\n\n    /* it must already be unlinked otherwise keyless lists would get wrong hash */\n    if (keyless_list_check && orig_parent) {\n        LY_TREE_FOR(orig_parent->child, iter) {\n            assert(iter != node);\n        }\n    }\n#endif\n\n    if (orig_parent) {\n        if ((node->schema->nodetype != LYS_LIST) || lyd_list_has_keys(node)) {\n            if (orig_parent->ht) {\n                if (lyht_remove(orig_parent->ht, &node, node->hash)) {\n                    assert(0);\n                }\n\n                /* if no longer enough children, free the whole hash table */\n                if (orig_parent->ht->used < LY_CACHE_HT_MIN_CHILDREN) {\n                    lyht_free(orig_parent->ht);\n                    orig_parent->ht = NULL;\n                }\n            }\n\n            /* if the parent is missing a key now, remove hash, also from parent */\n            if (lys_is_key((struct lys_node_leaf *)node->schema, NULL) && orig_parent->hash) {\n                assert((orig_parent->schema->nodetype == LYS_LIST) && !lyd_list_has_keys(orig_parent));\n\n                _lyd_unlink_hash(orig_parent, orig_parent->parent, 0);\n                orig_parent->hash = 0;\n            }\n\n            /* if node was in a state data subtree, shouldn't it be a part of a key-less list hash? */\n            if (keyless_list_check) {\n                lyd_keyless_list_hash_change(orig_parent);\n            }\n        }\n    }\n}\n\n/* we are unlinking a child from a parent */\nvoid\nlyd_unlink_hash(struct lyd_node *node, struct lyd_node *orig_parent)\n{\n    _lyd_unlink_hash(node, orig_parent, 1);\n}\n\n#endif\n\n/**\n * @brief get the list of \\p data's siblings of the given schema\n */\nstatic int\nlyd_get_node_siblings(const struct lyd_node *data, const struct lys_node *schema, struct ly_set *set)\n{\n    const struct lyd_node *iter;\n\n    assert(set && !set->number);\n    assert(schema);\n    assert(schema->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_ANYDATA | LYS_NOTIF | LYS_RPC |\n                               LYS_ACTION));\n\n    if (!data) {\n        return 0;\n    }\n\n    LY_TREE_FOR(data, iter) {\n        if (iter->schema == schema) {\n            ly_set_add(set, (void*)iter, LY_SET_OPT_USEASLIST);\n        }\n    }\n\n    return set->number;\n}\n\n/**\n * Check whether there are any \"when\" statements on a \\p schema node and evaluate them.\n *\n * @return -1 on error, 0 on no when or evaluated to true, 1 on when evaluated to false\n */\nstatic int\nlyd_is_when_false(struct lyd_node *root, struct lyd_node *last_parent, struct lys_node *schema, int options)\n{\n    enum int_log_opts prev_ilo;\n    struct lyd_node *current, *dummy;\n\n    if ((!(options & LYD_OPT_TYPEMASK) || (options & (LYD_OPT_CONFIG | LYD_OPT_RPC | LYD_OPT_RPCREPLY | LYD_OPT_NOTIF | LYD_OPT_DATA_TEMPLATE)))\n            && resolve_applies_when(schema, 1, last_parent ? last_parent->schema : NULL)) {\n        /* evaluate when statements on a dummy data node */\n        if (schema->nodetype == LYS_CHOICE) {\n            schema = (struct lys_node *)lys_getnext(NULL, schema, NULL, LYS_GETNEXT_NOSTATECHECK);\n        }\n        dummy = lyd_new_dummy(root, last_parent, schema, NULL, 0);\n        if (!dummy) {\n            return -1;\n        }\n        if (!dummy->parent && root) {\n            /* connect dummy nodes into the data tree, insert it before the root\n             * to optimize later unlinking (lyd_free()) */\n            lyd_insert_before(root, dummy);\n        }\n        for (current = dummy; current; current = current->child) {\n            ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n            resolve_when(current, 0, NULL);\n            ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n\n            if (current->when_status & LYD_WHEN_FALSE) {\n                /* when evaluates to false */\n                lyd_free(dummy);\n                return 1;\n            }\n\n            if (current->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                /* termination node without a child */\n                break;\n            }\n        }\n        lyd_free(dummy);\n    }\n\n    return 0;\n}\n\n/**\n * @param[in] root Root node to be able search the data tree in case of no instance\n * @return\n *  0 - all restrictions met\n *  1 - restrictions not met\n *  2 - schema node not enabled\n */\nstatic int\nlyd_check_mandatory_data(struct lyd_node *root, struct lyd_node *last_parent,\n                         struct ly_set *instances, struct lys_node *schema, int options)\n{\n    struct ly_ctx *ctx = schema->module->ctx;\n    uint32_t limit;\n    uint16_t status;\n\n    if (!instances->number) {\n        /* no instance in the data tree - check if the instantiating is enabled\n         * (check: if-feature, when, status data in non-status data tree)\n         */\n        status = (schema->flags & LYS_STATUS_MASK);\n        if (lys_is_disabled(schema, 2) || (status && status != LYS_STATUS_CURR)) {\n            /* disabled by if-feature */\n            return EXIT_SUCCESS;\n        } else if ((options & LYD_OPT_TRUSTED) || ((options & LYD_OPT_TYPEMASK) && (schema->flags & LYS_CONFIG_R))) {\n            /* status schema node in non-status data tree */\n            return EXIT_SUCCESS;\n        } else if (lyd_is_when_false(root, last_parent, schema, options)) {\n            return EXIT_SUCCESS;\n        }\n        /* the schema instance is not disabled by anything, continue with checking */\n    }\n\n    /* checking various mandatory conditions */\n    switch (schema->nodetype) {\n    case LYS_LEAF:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        /* mandatory */\n        if ((schema->flags & LYS_MAND_TRUE) && !instances->number) {\n            LOGVAL(ctx, LYE_MISSELEM, LY_VLOG_LYD, last_parent, schema->name,\n                   last_parent ? last_parent->schema->name : lys_node_module(schema)->name);\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_LIST:\n        /* min-elements */\n        limit = ((struct lys_node_list *)schema)->min;\n        if (limit && limit > instances->number) {\n            LOGVAL(ctx, LYE_NOMIN, LY_VLOG_LYD, last_parent, schema->name);\n            return EXIT_FAILURE;\n        }\n        /* max elements */\n        limit = ((struct lys_node_list *)schema)->max;\n        if (limit && limit < instances->number) {\n            LOGVAL(ctx, LYE_NOMAX, LY_VLOG_LYD, instances->set.d[limit], schema->name);\n            return EXIT_FAILURE;\n        }\n\n        break;\n\n    case LYS_LEAFLIST:\n        /* min-elements */\n        limit = ((struct lys_node_leaflist *)schema)->min;\n        if (limit && limit > instances->number) {\n            LOGVAL(ctx, LYE_NOMIN, LY_VLOG_LYD, last_parent, schema->name);\n            return EXIT_FAILURE;\n        }\n        /* max elements */\n        limit = ((struct lys_node_leaflist *)schema)->max;\n        if (limit && limit < instances->number) {\n            LOGVAL(ctx, LYE_NOMAX, LY_VLOG_LYD, instances->set.d[limit], schema->name);\n            return EXIT_FAILURE;\n        }\n        break;\n    default:\n        /* we cannot get here */\n        assert(0);\n        break;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Check the specific subtree, specified by \\p schema node, for presence of mandatory nodes. Function goes\n * recursively into the subtree.\n *\n * What is being checked:\n * - mandatory statement in leaf, choice, anyxml and anydata\n * - min-elements and max-elements in list and leaf-list\n *\n * @param[in] tree Data tree, needed for case that subtree is NULL (in case of not existing data nodes to explore)\n * @param[in] subtree Depend ons \\p toplevel flag:\n *                 toplevel = 1, then subtree is ignored, instead the tree is taken to search in top level data elements (if any)\n *                 toplevel = 0, subtree is the parent data node of the possible instances of the schema node being checked\n * @param[in] last_parent The last present parent data node (so it does not need to be a direct parent) of the possible\n *                 instances of the schema node being checked\n * @param[in] schema The schema node being checked for mandatory nodes\n * @param[in] toplevel, see the \\p root parameter description\n * @param[in] options @ref parseroptions to specify the type of the data tree.\n * @return EXIT_SUCCESS or EXIT_FAILURE if there are missing mandatory nodes\n */\nstatic int\nlyd_check_mandatory_subtree(struct lyd_node *tree, struct lyd_node *subtree, struct lyd_node *last_parent,\n                            struct lys_node *schema, int toplevel, int options)\n{\n    struct lys_node *siter, *siter_prev;\n    struct lyd_node *iter;\n    struct ly_set *present = NULL;\n    unsigned int u;\n    int ret = EXIT_FAILURE;\n\n    assert(schema);\n\n    if (schema->nodetype & (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_ANYDATA | LYS_CONTAINER)) {\n        /* data node */\n        present = ly_set_new();\n        if (!present) {\n            goto error;\n        }\n        if ((toplevel && tree) || (!toplevel && subtree)) {\n            if (toplevel) {\n                lyd_get_node_siblings(tree, schema, present);\n            } else {\n                lyd_get_node_siblings(subtree->child, schema, present);\n            }\n        }\n    }\n\n    switch (schema->nodetype) {\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        /* check the schema item */\n        if (lyd_check_mandatory_data(tree, last_parent, present, schema, options)) {\n            goto error;\n        }\n        break;\n    case LYS_LIST:\n        /* check the schema item */\n        if (lyd_check_mandatory_data(tree, last_parent, present, schema, options)) {\n            goto error;\n        }\n\n        /* go recursively */\n        for (u = 0; u < present->number; u++) {\n            LY_TREE_FOR(schema->child, siter) {\n                if (lyd_check_mandatory_subtree(tree, present->set.d[u], present->set.d[u], siter, 0, options)) {\n                    goto error;\n                }\n            }\n        }\n        break;\n\n    case LYS_CONTAINER:\n        if (present->number || !((struct lys_node_container *)schema)->presence) {\n            /* if we have existing or non-presence container, go recursively */\n            LY_TREE_FOR(schema->child, siter) {\n                if (lyd_check_mandatory_subtree(tree, present->number ? present->set.d[0] : NULL,\n                                                present->number ? present->set.d[0] : last_parent,\n                                                siter, 0, options)) {\n                    goto error;\n                }\n            }\n        }\n        break;\n    case LYS_CHOICE:\n        /* get existing node in the data tree from the choice */\n        iter = NULL;\n        if ((toplevel && tree) || (!toplevel && subtree)) {\n            LY_TREE_FOR(toplevel ? tree : subtree->child, iter) {\n                for (siter = lys_parent(iter->schema), siter_prev = iter->schema;\n                        siter && (siter->nodetype & (LYS_CASE | LYS_USES | LYS_CHOICE));\n                        siter_prev = siter, siter = lys_parent(siter)) {\n                    if (siter == schema) {\n                        /* we have the choice instance */\n                        break;\n                    }\n                }\n                if (siter == schema) {\n                    /* we have the choice instance;\n                     * the condition must be the same as in the loop because of\n                     * choice's sibling nodes that break the loop, so siter is not NULL,\n                     * but it is not the same as schema */\n                    break;\n                }\n            }\n        }\n        if (!iter) {\n            if (lyd_is_when_false(tree, last_parent, schema, options)) {\n                /* nothing to check */\n                break;\n            }\n            if (((struct lys_node_choice *)schema)->dflt) {\n                /* there is a default case */\n                if (lyd_check_mandatory_subtree(tree, subtree, last_parent, ((struct lys_node_choice *)schema)->dflt,\n                                                toplevel, options)) {\n                    goto error;\n                }\n            } else if (schema->flags & LYS_MAND_TRUE) {\n                /* choice requires some data to be instantiated */\n                LOGVAL(schema->module->ctx, LYE_NOMANDCHOICE, LY_VLOG_LYD, last_parent, schema->name);\n                goto error;\n            }\n        } else {\n            /* one of the choice's cases is instantiated, continue into this case */\n            /* since iter != NULL, siter must be also != NULL and we also know siter_prev\n             * which points to the child of schema leading towards the instantiated data */\n            assert(siter && siter_prev);\n            if (lyd_check_mandatory_subtree(tree, subtree, last_parent, siter_prev, toplevel, options)) {\n                goto error;\n            }\n        }\n        break;\n    case LYS_NOTIF:\n        /* skip if validating a notification */\n        if (!(options & LYD_OPT_NOTIF)) {\n            break;\n        }\n        /* fallthrough */\n    case LYS_CASE:\n    case LYS_USES:\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        /* go recursively */\n        LY_TREE_FOR(schema->child, siter) {\n            if (lyd_check_mandatory_subtree(tree, subtree, last_parent, siter, toplevel, options)) {\n                goto error;\n            }\n        }\n        break;\n    default:\n        /* stop */\n        break;\n    }\n\n    ret = EXIT_SUCCESS;\n\nerror:\n    ly_set_free(present);\n    return ret;\n}\n\nint\nlyd_check_mandatory_tree(struct lyd_node *root, struct ly_ctx *ctx, const struct lys_module **modules, int mod_count,\n                         int options)\n{\n    struct lys_node *siter;\n    int i;\n\n    assert(root || ctx);\n    assert(!(options & LYD_OPT_ACT_NOTIF));\n\n    if (options & (LYD_OPT_EDIT | LYD_OPT_GET | LYD_OPT_GETCONFIG)) {\n        /* no check is needed */\n        return EXIT_SUCCESS;\n    }\n\n    if (!ctx) {\n        /* get context */\n        ctx = root->schema->module->ctx;\n    }\n\n    if (!(options & LYD_OPT_TYPEMASK) || (options & LYD_OPT_CONFIG)) {\n        if (options & LYD_OPT_NOSIBLINGS) {\n            if (root && lyd_check_mandatory_subtree(root, NULL, NULL, root->schema, 1, options)) {\n                return EXIT_FAILURE;\n            }\n        } else if (modules && mod_count) {\n            for (i = 0; i < mod_count; ++i) {\n                LY_TREE_FOR(modules[i]->data, siter) {\n                    if (!(siter->nodetype & (LYS_RPC | LYS_NOTIF)) &&\n                            lyd_check_mandatory_subtree(root, NULL, NULL, siter, 1, options)) {\n                        return EXIT_FAILURE;\n                    }\n                }\n            }\n        } else {\n            for (i = (options & LYD_OPT_DATA_NO_YANGLIB) ? ctx->internal_module_count : ctx->internal_module_count - 1;\n                 i < ctx->models.used;\n                 i++) {\n                /* skip not implemented and disabled modules */\n                if (!ctx->models.list[i]->implemented || ctx->models.list[i]->disabled) {\n                    continue;\n                }\n                LY_TREE_FOR(ctx->models.list[i]->data, siter) {\n                    if (!(siter->nodetype & (LYS_RPC | LYS_NOTIF)) &&\n                            lyd_check_mandatory_subtree(root, NULL, NULL, siter, 1, options)) {\n                        return EXIT_FAILURE;\n                    }\n                }\n            }\n        }\n    } else if (options & LYD_OPT_NOTIF) {\n        if (!root || (root->schema->nodetype != LYS_NOTIF)) {\n            LOGERR(ctx, LY_EINVAL, \"Subtree is not a single notification.\");\n            return EXIT_FAILURE;\n        }\n        if (root->schema->child && lyd_check_mandatory_subtree(root, root, root, root->schema, 0, options)) {\n            return EXIT_FAILURE;\n        }\n    } else if (options & (LYD_OPT_RPC | LYD_OPT_RPCREPLY)) {\n        if (!root || !(root->schema->nodetype & (LYS_RPC | LYS_ACTION))) {\n            LOGERR(ctx, LY_EINVAL, \"Subtree is not a single RPC/action/reply.\");\n            return EXIT_FAILURE;\n        }\n        if (options & LYD_OPT_RPC) {\n            for (siter = root->schema->child; siter && siter->nodetype != LYS_INPUT; siter = siter->next);\n        } else { /* LYD_OPT_RPCREPLY */\n            for (siter = root->schema->child; siter && siter->nodetype != LYS_OUTPUT; siter = siter->next);\n        }\n        if (siter && lyd_check_mandatory_subtree(root, root, root, siter, 0, options)) {\n            return EXIT_FAILURE;\n        }\n    } else if (options & LYD_OPT_DATA_TEMPLATE) {\n        if (root && lyd_check_mandatory_subtree(root, NULL, NULL, root->schema, 1, options)) {\n            return EXIT_FAILURE;\n        }\n    } else {\n        LOGINT(ctx);\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n\nstatic struct lyd_node *\nlyd_parse_(struct ly_ctx *ctx, const struct lyd_node *rpc_act, const char *data, LYD_FORMAT format, int options,\n           const struct lyd_node *data_tree, const char *yang_data_name)\n{\n    struct lyxml_elem *xml;\n    struct lyd_node *result = NULL;\n    int xmlopt = LYXML_PARSE_MULTIROOT;\n\n    if (!ctx || !data) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (options & LYD_OPT_NOSIBLINGS) {\n        xmlopt = 0;\n    }\n\n    /* we must free all the errors, otherwise we are unable to properly check returned ly_errno :-/ */\n    ly_errno = LY_SUCCESS;\n    switch (format) {\n    case LYD_XML:\n        xml = lyxml_parse_mem(ctx, data, xmlopt);\n        if (ly_errno) {\n            break;\n        }\n        if (options & LYD_OPT_RPCREPLY) {\n            result = lyd_parse_xml(ctx, &xml, options, rpc_act, data_tree);\n        } else if (options & (LYD_OPT_RPC | LYD_OPT_NOTIF)) {\n            result = lyd_parse_xml(ctx, &xml, options, data_tree);\n        } else if (options & LYD_OPT_DATA_TEMPLATE) {\n            result = lyd_parse_xml(ctx, &xml, options, yang_data_name);\n        } else {\n            result = lyd_parse_xml(ctx, &xml, options);\n        }\n        lyxml_free_withsiblings(ctx, xml);\n        break;\n    case LYD_JSON:\n        result = lyd_parse_json(ctx, data, options, rpc_act, data_tree, yang_data_name);\n        break;\n    case LYD_LYB:\n        result = lyd_parse_lyb(ctx, data, options, data_tree, yang_data_name, NULL);\n        break;\n    default:\n        /* error */\n        break;\n    }\n\n    if (ly_errno) {\n        lyd_free_withsiblings(result);\n        return NULL;\n    } else {\n        return result;\n    }\n}\n\nstatic struct lyd_node *\nlyd_parse_data_(struct ly_ctx *ctx, const char *data, LYD_FORMAT format, int options, va_list ap)\n{\n    const struct lyd_node *rpc_act = NULL, *data_tree = NULL, *iter;\n    const char *yang_data_name = NULL;\n\n    if (lyp_data_check_options(ctx, options, __func__)) {\n        return NULL;\n    }\n\n    if (options & LYD_OPT_RPCREPLY) {\n        rpc_act = va_arg(ap, const struct lyd_node *);\n        if (!rpc_act || rpc_act->parent || !(rpc_act->schema->nodetype & (LYS_RPC | LYS_LIST | LYS_CONTAINER))) {\n            LOGERR(ctx, LY_EINVAL, \"%s: invalid variable parameter (const struct lyd_node *rpc_act).\", __func__);\n            return NULL;\n        }\n    }\n    if (options & (LYD_OPT_RPC | LYD_OPT_NOTIF | LYD_OPT_RPCREPLY)) {\n        data_tree = va_arg(ap, const struct lyd_node *);\n        if (data_tree) {\n            if (options & LYD_OPT_NOEXTDEPS) {\n                LOGERR(ctx, LY_EINVAL, \"%s: invalid parameter (variable arg const struct lyd_node *data_tree and LYD_OPT_NOEXTDEPS set).\",\n                       __func__);\n                return NULL;\n            }\n\n            LY_TREE_FOR(data_tree, iter) {\n                if (iter->parent) {\n                    /* a sibling is not top-level */\n                    LOGERR(ctx, LY_EINVAL, \"%s: invalid variable parameter (const struct lyd_node *data_tree).\", __func__);\n                    return NULL;\n                }\n            }\n\n            /* move it to the beginning */\n            for (; data_tree->prev->next; data_tree = data_tree->prev);\n\n            /* LYD_OPT_NOSIBLINGS cannot be set in this case */\n            if (options & LYD_OPT_NOSIBLINGS) {\n                LOGERR(ctx, LY_EINVAL, \"%s: invalid parameter (variable arg const struct lyd_node *data_tree with LYD_OPT_NOSIBLINGS).\", __func__);\n                return NULL;\n            }\n        }\n    }\n    if (options & LYD_OPT_DATA_TEMPLATE) {\n        yang_data_name = va_arg(ap, const char *);\n    }\n\n    return lyd_parse_(ctx, rpc_act, data, format, options, data_tree, yang_data_name);\n}\n\nAPI struct lyd_node *\nlyd_parse_mem(struct ly_ctx *ctx, const char *data, LYD_FORMAT format, int options, ...)\n{\n    va_list ap;\n    struct lyd_node *result;\n\n    va_start(ap, options);\n    result = lyd_parse_data_(ctx, data, format, options, ap);\n    va_end(ap);\n\n    return result;\n}\n\nstatic struct lyd_node *\nlyd_parse_fd_(struct ly_ctx *ctx, int fd, LYD_FORMAT format, int options, va_list ap)\n{\n    struct lyd_node *ret;\n    size_t length;\n    char *data;\n\n    if (!ctx || (fd == -1)) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (lyp_mmap(ctx, fd, 0, &length, (void **)&data)) {\n        LOGERR(ctx, LY_ESYS, \"Mapping file descriptor into memory failed (%s()).\", __func__);\n        return NULL;\n    } else if (!data) {\n        return NULL;\n    }\n\n    ret = lyd_parse_data_(ctx, data, format, options, ap);\n\n    lyp_munmap(data, length);\n\n    return ret;\n}\n\nAPI struct lyd_node *\nlyd_parse_fd(struct ly_ctx *ctx, int fd, LYD_FORMAT format, int options, ...)\n{\n    struct lyd_node *ret;\n    va_list ap;\n\n    va_start(ap, options);\n    ret = lyd_parse_fd_(ctx, fd, format, options, ap);\n    va_end(ap);\n\n    return ret;\n}\n\nAPI struct lyd_node *\nlyd_parse_path(struct ly_ctx *ctx, const char *path, LYD_FORMAT format, int options, ...)\n{\n    int fd;\n    struct lyd_node *ret;\n    va_list ap;\n\n    if (!ctx || !path) {\n        LOGARG;\n        return NULL;\n    }\n\n    fd = open(path, O_RDONLY);\n    if (fd == -1) {\n        LOGERR(ctx, LY_ESYS, \"Failed to open data file \\\"%s\\\" (%s).\", path, strerror(errno));\n        return NULL;\n    }\n\n    va_start(ap, options);\n    ret = lyd_parse_fd_(ctx, fd, format, options, ap);\n\n    va_end(ap);\n    close(fd);\n\n    return ret;\n}\n\nstatic struct lys_node *\nlyd_new_find_schema(struct lyd_node *parent, const struct lys_module *module, int rpc_output)\n{\n    struct lys_node *siblings;\n\n    if (!parent) {\n        siblings = module->data;\n    } else {\n        if (!parent->schema) {\n            return NULL;\n        }\n        siblings = parent->schema->child;\n        if (siblings && (siblings->nodetype == (rpc_output ? LYS_INPUT : LYS_OUTPUT))) {\n            siblings = siblings->next;\n        }\n        if (siblings && (siblings->nodetype == (rpc_output ? LYS_OUTPUT : LYS_INPUT))) {\n            siblings = siblings->child;\n        }\n    }\n\n    return siblings;\n}\n\nstruct lyd_node *\n_lyd_new(struct lyd_node *parent, const struct lys_node *schema, int dflt)\n{\n    struct lyd_node *ret;\n\n    ret = calloc(1, sizeof *ret);\n    LY_CHECK_ERR_RETURN(!ret, LOGMEM(schema->module->ctx), NULL);\n\n    ret->schema = (struct lys_node *)schema;\n    ret->validity = ly_new_node_validity(schema);\n    if (resolve_applies_when(schema, 0, NULL)) {\n        ret->when_status = LYD_WHEN;\n    }\n    ret->prev = ret;\n    ret->dflt = dflt;\n\n#ifdef LY_ENABLED_CACHE\n    lyd_hash(ret);\n#endif\n\n    if (parent) {\n        if (lyd_insert(parent, ret)) {\n            lyd_free(ret);\n            return NULL;\n        }\n    }\n    return ret;\n}\n\nAPI struct lyd_node *\nlyd_new(struct lyd_node *parent, const struct lys_module *module, const char *name)\n{\n    const struct lys_node *snode = NULL, *siblings;\n\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n\n    siblings = lyd_new_find_schema(parent, module, 0);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_CONTAINER | LYS_LIST | LYS_NOTIF\n                         | LYS_RPC | LYS_ACTION, 0, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n\n    return _lyd_new(parent, snode, 0);\n}\n\nstatic struct lyd_node *\nlyd_create_leaf(const struct lys_node *schema, const char *val_str, int dflt)\n{\n    struct lyd_node_leaf_list *ret;\n\n    ret = calloc(1, sizeof *ret);\n    LY_CHECK_ERR_RETURN(!ret, LOGMEM(schema->module->ctx), NULL);\n\n    ret->schema = (struct lys_node *)schema;\n    ret->validity = ly_new_node_validity(schema);\n    if (resolve_applies_when(schema, 0, NULL)) {\n        ret->when_status = LYD_WHEN;\n    }\n    ret->prev = (struct lyd_node *)ret;\n    ret->value_type = ((struct lys_node_leaf *)schema)->type.base;\n    ret->value_str = lydict_insert(schema->module->ctx, val_str ? val_str : \"\", 0);\n    ret->dflt = dflt;\n\n#ifdef LY_ENABLED_CACHE\n    lyd_hash((struct lyd_node *)ret);\n#endif\n\n    return (struct lyd_node *)ret;\n}\n\nstatic struct lyd_node *\n_lyd_new_leaf(struct lyd_node *parent, const struct lys_node *schema, const char *val_str, int dflt, int edit_leaf)\n{\n    struct lyd_node *ret;\n\n    ret = lyd_create_leaf(schema, val_str, dflt);\n    if (!ret) {\n        return NULL;\n    }\n\n    /* connect to parent */\n    if (parent) {\n        if (lyd_insert(parent, ret)) {\n            lyd_free(ret);\n            return NULL;\n        }\n    }\n\n    if (edit_leaf && !((struct lyd_node_leaf_list *)ret)->value_str[0]) {\n        /* empty edit leaf, it is fine */\n        ((struct lyd_node_leaf_list *)ret)->value_type = LY_TYPE_UNKNOWN;\n        return ret;\n    }\n\n    /* resolve the type correctly (after it was connected to parent cause of log) */\n    if (!lyp_parse_value(&((struct lys_node_leaf *)ret->schema)->type, &((struct lyd_node_leaf_list *)ret)->value_str,\n                         NULL, (struct lyd_node_leaf_list *)ret, NULL, NULL, 1, dflt, 0)) {\n        lyd_free(ret);\n        return NULL;\n    }\n\n    if ((ret->schema->nodetype == LYS_LEAF) && (ret->schema->flags & LYS_UNIQUE)) {\n        for (; parent && (parent->schema->nodetype != LYS_LIST); parent = parent->parent);\n        if (parent) {\n            parent->validity |= LYD_VAL_UNIQUE;\n        } else {\n            LOGINT(schema->module->ctx);\n        }\n    }\n\n    return ret;\n}\n\nAPI struct lyd_node *\nlyd_new_leaf(struct lyd_node *parent, const struct lys_module *module, const char *name, const char *val_str)\n{\n    const struct lys_node *snode = NULL, *siblings;\n\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n\n    siblings = lyd_new_find_schema(parent, module, 0);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, 0, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n\n    return _lyd_new_leaf(parent, snode, val_str, 0, 0);\n}\n\n/**\n * @brief Update (add) default flag of the parents of the added node.\n *\n * @param[in] node Added node\n */\nstatic void\nlyd_wd_update_parents(struct lyd_node *node)\n{\n    struct lyd_node *parent = node->parent, *iter;\n\n    for (parent = node->parent; parent; parent = node->parent) {\n        if (parent->dflt || parent->schema->nodetype != LYS_CONTAINER ||\n                ((struct lys_node_container *)parent->schema)->presence) {\n            /* parent is already default and there is nothing to update or\n             * it is not a non-presence container -> stop the loop */\n            break;\n        }\n        /* check that there is still some non default sibling */\n        for (iter = node->prev; iter != node; iter = iter->prev) {\n            if (!iter->dflt) {\n                break;\n            }\n        }\n        if (iter == node && node->prev != node) {\n            /* all siblings are implicit default nodes, propagate it to the parent */\n            node = node->parent;\n            node->dflt = 1;\n            continue;\n        } else {\n            /* stop the loop */\n            break;\n        }\n    }\n}\n\n/* op - 0 add, 1 del, 2 mod (add + del) */\nstatic void\ncheck_leaf_list_backlinks(struct lyd_node *node, int op)\n{\n    struct lyd_node *next, *iter;\n    struct lyd_node_leaf_list *leaf_list;\n    struct ly_set *set, *data;\n    uint32_t i, j;\n    int validity_changed = 0;\n\n    assert((op == 0) || (op == 1) || (op == 2));\n\n    /* fix leafrefs */\n    LY_TREE_DFS_BEGIN(node, next, iter) {\n        /* the node is target of a leafref */\n        if ((iter->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST)) && iter->schema->child) {\n            set = (struct ly_set *)iter->schema->child;\n            for (i = 0; i < set->number; i++) {\n                data = lyd_find_instance(iter, set->set.s[i]);\n                if (data) {\n                    for (j = 0; j < data->number; j++) {\n                        leaf_list = (struct lyd_node_leaf_list *)data->set.d[j];\n                        if (((op != 0) && (leaf_list->value_type == LY_TYPE_LEAFREF) && (leaf_list->value.leafref == iter))\n                                || ((op != 1) && (leaf_list->value_flags & LY_VALUE_UNRES))) {\n                            /* invalidate the leafref, a change concerning it happened */\n                            leaf_list->validity |= LYD_VAL_LEAFREF;\n                            validity_changed = 1;\n                            if (leaf_list->value_type == LY_TYPE_LEAFREF) {\n                                /* remove invalid link and put unresolved value back */\n                                lyp_parse_value(&((struct lys_node_leaf *)leaf_list->schema)->type, &leaf_list->value_str,\n                                                NULL, leaf_list, NULL, NULL, 1, leaf_list->dflt, 0);\n                            }\n                        }\n                    }\n                    ly_set_free(data);\n                } else {\n                    LOGINT(node->schema->module->ctx);\n                    return;\n                }\n            }\n        }\n        LY_TREE_DFS_END(node, next, iter)\n    }\n\n    /* invalidate parent to make sure it will be checked in future validation */\n    if (validity_changed && node->parent) {\n        node->parent->validity |= LYD_VAL_MAND;\n    }\n}\n\nAPI int\nlyd_change_leaf(struct lyd_node_leaf_list *leaf, const char *val_str)\n{\n    const char *backup;\n    int val_change, dflt_change;\n    struct lyd_node *parent;\n\n    if (!leaf || (leaf->schema->nodetype != LYS_LEAF)) {\n        LOGARG;\n        return -1;\n    }\n\n    backup = leaf->value_str;\n    leaf->value_str = lydict_insert(leaf->schema->module->ctx, val_str ? val_str : \"\", 0);\n    /* leaf->value is erased by lyp_parse_value() */\n\n    /* parse the type correctly, makes the value canonical if needed */\n    if (!lyp_parse_value(&((struct lys_node_leaf *)leaf->schema)->type, &leaf->value_str, NULL, leaf, NULL, NULL, 1, 0, 0)) {\n        lydict_remove(leaf->schema->module->ctx, backup);\n        return -1;\n    }\n\n    if (!strcmp(backup, leaf->value_str)) {\n        /* the value remains the same */\n        val_change = 0;\n    } else {\n        val_change = 1;\n    }\n\n    /* value is correct, remove backup */\n    lydict_remove(leaf->schema->module->ctx, backup);\n\n    /* clear the default flag, the value is different */\n    if (leaf->dflt) {\n        for (parent = (struct lyd_node *)leaf; parent; parent = parent->parent) {\n            parent->dflt = 0;\n        }\n        dflt_change = 1;\n    } else {\n        dflt_change = 0;\n    }\n\n    if (val_change) {\n        /* make the node non-validated */\n        leaf->validity = ly_new_node_validity(leaf->schema);\n\n        /* check possible leafref backlinks */\n        check_leaf_list_backlinks((struct lyd_node *)leaf, 2);\n    }\n\n    if (val_change && (leaf->schema->flags & LYS_UNIQUE)) {\n        for (parent = leaf->parent; parent && (parent->schema->nodetype != LYS_LIST); parent = parent->parent);\n        if (parent) {\n            parent->validity |= LYD_VAL_UNIQUE;\n        } else {\n            LOGINT(leaf->schema->module->ctx);\n            return -1;\n        }\n    }\n\n    return (val_change || dflt_change ? 0 : 1);\n}\n\nstatic struct lyd_node *\nlyd_create_anydata(struct lyd_node *parent, const struct lys_node *schema, void *value,\n                   LYD_ANYDATA_VALUETYPE value_type)\n{\n    struct lyd_node *iter;\n    struct lyd_node_anydata *ret;\n    int len;\n\n    ret = calloc(1, sizeof *ret);\n    LY_CHECK_ERR_RETURN(!ret, LOGMEM(schema->module->ctx), NULL);\n\n    ret->schema = (struct lys_node *)schema;\n    ret->validity = ly_new_node_validity(schema);\n    if (resolve_applies_when(schema, 0, NULL)) {\n        ret->when_status = LYD_WHEN;\n    }\n    ret->prev = (struct lyd_node *)ret;\n\n    /* set the value */\n    switch (value_type) {\n    case LYD_ANYDATA_CONSTSTRING:\n    case LYD_ANYDATA_SXML:\n    case LYD_ANYDATA_JSON:\n        ret->value.str = lydict_insert(schema->module->ctx, (const char *)value, 0);\n        break;\n    case LYD_ANYDATA_STRING:\n    case LYD_ANYDATA_SXMLD:\n    case LYD_ANYDATA_JSOND:\n        ret->value.str = lydict_insert_zc(schema->module->ctx, (char *)value);\n        value_type &= ~LYD_ANYDATA_STRING; /* make const string from string */\n        break;\n    case LYD_ANYDATA_DATATREE:\n        ret->value.tree = (struct lyd_node *)value;\n        break;\n    case LYD_ANYDATA_XML:\n        ret->value.xml = (struct lyxml_elem *)value;\n        break;\n    case LYD_ANYDATA_LYB:\n        len = lyd_lyb_data_length(value);\n        if (len == -1) {\n            LOGERR(schema->module->ctx, LY_EINVAL, \"Invalid LYB data.\");\n            return NULL;\n        }\n        ret->value.mem = malloc(len);\n        LY_CHECK_ERR_RETURN(!ret->value.mem, LOGMEM(schema->module->ctx); free(ret), NULL);\n        memcpy(ret->value.mem, value, len);\n        break;\n    case LYD_ANYDATA_LYBD:\n        ret->value.mem = value;\n        value_type &= ~LYD_ANYDATA_STRING; /* make const string from string */\n        break;\n    }\n    ret->value_type = value_type;\n\n#ifdef LY_ENABLED_CACHE\n    lyd_hash((struct lyd_node *)ret);\n#endif\n\n    /* connect to parent */\n    if (parent) {\n        if (lyd_insert(parent, (struct lyd_node*)ret)) {\n            lyd_free((struct lyd_node*)ret);\n            return NULL;\n        }\n\n        /* remove the flag from parents */\n        for (iter = parent; iter && iter->dflt; iter = iter->parent) {\n            iter->dflt = 0;\n        }\n    }\n\n    return (struct lyd_node*)ret;\n}\n\nAPI struct lyd_node *\nlyd_new_anydata(struct lyd_node *parent, const struct lys_module *module, const char *name,\n                void *value, LYD_ANYDATA_VALUETYPE value_type)\n{\n    const struct lys_node *siblings, *snode;\n\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n\n    siblings = lyd_new_find_schema(parent, module, 0);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, 0, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n\n    return lyd_create_anydata(parent, snode, value, value_type);\n}\n\nAPI struct lyd_node *\nlyd_new_yangdata(const struct lys_module *module, const char *name_template, const char *name)\n{\n    const struct lys_node *schema = NULL, *snode;\n\n    if (!module || !name_template || !name) {\n        LOGARG;\n        return NULL;\n    }\n\n    schema = lyp_get_yang_data_template(module, name_template, strlen(name_template));\n    if (!schema) {\n        LOGERR(module->ctx, LY_EINVAL, \"Failed to find yang-data template \\\"%s\\\".\", name_template);\n        return NULL;\n    }\n\n    if (lys_getnext_data(module, schema, name, strlen(name), LYS_CONTAINER, 0, &snode) || !snode) {\n        LOGERR(module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a container child of \\\"%s:%s\\\".\",\n               name, module->name, schema->name);\n        return NULL;\n    }\n\n    return _lyd_new(NULL, snode, 0);\n}\n\nAPI struct lyd_node *\nlyd_new_output(struct lyd_node *parent, const struct lys_module *module, const char *name)\n{\n    const struct lys_node *snode = NULL, *siblings;\n\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_CONTAINER | LYS_LIST | LYS_NOTIF\n                         | LYS_RPC | LYS_ACTION, 0, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n\n    return _lyd_new(parent, snode, 0);\n}\n\nAPI struct lyd_node *\nlyd_new_output_leaf(struct lyd_node *parent, const struct lys_module *module, const char *name, const char *val_str)\n{\n    const struct lys_node *snode = NULL, *siblings;\n\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, 0, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n\n    return _lyd_new_leaf(parent, snode, val_str, 0, 0);\n}\n\nAPI struct lyd_node *\nlyd_new_output_anydata(struct lyd_node *parent, const struct lys_module *module, const char *name,\n                       void *value, LYD_ANYDATA_VALUETYPE value_type)\n{\n    const struct lys_node *siblings, *snode;\n\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, 0, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n\n    return lyd_create_anydata(parent, snode, value, value_type);\n}\n\nstatic int\nlyd_new_path_list_predicate(struct lyd_node *list, const char *list_name, const char *predicate, int *parsed)\n{\n    const char *mod_name, *name, *value;\n    char *key_val;\n    int r, i, mod_name_len, nam_len, val_len, has_predicate;\n    struct lys_node_list *slist;\n    struct lys_node *key;\n\n    slist = (struct lys_node_list *)list->schema;\n\n    /* is the predicate a number? */\n    if (((r = parse_schema_json_predicate(predicate, &mod_name, &mod_name_len, &name, &nam_len, &value, &val_len, &has_predicate)) < 1)\n            || !strncmp(name, \".\", nam_len)) {\n        LOGVAL(slist->module->ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, predicate[-r], &predicate[-r]);\n        return -1;\n    }\n\n    if (isdigit(name[0])) {\n        /* position index - creating without keys */\n        *parsed += r;\n        return 0;\n    }\n\n    /* it's not a number, so there must be some keys */\n    if (!slist->keys_size) {\n        /* there are none, so pretend we did not parse anything to get invalid char error later */\n        return 0;\n    }\n\n    /* go through all the keys */\n    i = 0;\n    goto check_parsed_values;\n\n    for (; i < slist->keys_size; ++i) {\n        if (!has_predicate) {\n            LOGVAL(slist->module->ctx, LYE_PATH_MISSKEY, LY_VLOG_NONE, NULL, list_name);\n            return -1;\n        }\n\n        if (((r = parse_schema_json_predicate(predicate, &mod_name, &mod_name_len, &name, &nam_len, &value, &val_len, &has_predicate)) < 1)\n                || !strncmp(name, \".\", nam_len)) {\n            LOGVAL(slist->module->ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, predicate[-r], &predicate[-r]);\n            return -1;\n        }\n\ncheck_parsed_values:\n        key = (struct lys_node *)slist->keys[i];\n        *parsed += r;\n        predicate += r;\n\n        if (!value || (!mod_name && (lys_node_module(key) != lys_node_module((struct lys_node *)slist)))\n                || (mod_name && (strncmp(lys_node_module(key)->name, mod_name, mod_name_len) || lys_node_module(key)->name[mod_name_len]))\n                || strncmp(key->name, name, nam_len) || key->name[nam_len]) {\n            LOGVAL(slist->module->ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, name);\n            return -1;\n        }\n\n        key_val = malloc((val_len + 1) * sizeof(char));\n        LY_CHECK_ERR_RETURN(!key_val, LOGMEM(slist->module->ctx), -1);\n        strncpy(key_val, value, val_len);\n        key_val[val_len] = '\\0';\n\n        if (!_lyd_new_leaf(list, key, key_val, 0, 0)) {\n            free(key_val);\n            return -1;\n        }\n        free(key_val);\n    }\n\n    return 0;\n}\n\nstatic struct lyd_node *\nlyd_new_path_update(struct lyd_node *node, void *value, LYD_ANYDATA_VALUETYPE value_type, int dflt)\n{\n    struct ly_ctx *ctx = node->schema->module->ctx;\n    struct lyd_node_anydata *any;\n    int len;\n\n    switch (node->schema->nodetype) {\n    case LYS_LEAF:\n        if (value_type > LYD_ANYDATA_STRING) {\n            LOGARG;\n            return NULL;\n        }\n\n        if (lyd_change_leaf((struct lyd_node_leaf_list *)node, value) == 0) {\n            /* there was an actual change */\n            if (dflt) {\n                node->dflt = 1;\n            }\n            return node;\n        }\n\n        if (dflt) {\n            /* maybe the value is the same, but the node is default now */\n            node->dflt = 1;\n            return node;\n        }\n\n        break;\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        /* the nodes are the same if:\n         * 1) the value types are strings (LYD_ANYDATA_STRING and LYD_ANYDATA_CONSTSTRING equals)\n         *    and the strings equals\n         * 2) the value types are the same, but not strings and the pointers (not the content) are the\n         *    same\n         */\n        any = (struct lyd_node_anydata *)node;\n        if (any->value_type <= LYD_ANYDATA_STRING && value_type <= LYD_ANYDATA_STRING) {\n            if (ly_strequal(any->value.str, (char *)value, 0)) {\n                /* values are the same */\n                return NULL;\n            }\n        } else if (any->value_type == value_type) {\n            /* compare pointers */\n            if ((void *)any->value.tree == value) {\n                /* values are the same */\n                return NULL;\n            }\n        }\n\n        /* values are not the same - 1) remove the old one ... */\n        switch (any->value_type) {\n        case LYD_ANYDATA_CONSTSTRING:\n        case LYD_ANYDATA_SXML:\n        case LYD_ANYDATA_JSON:\n            lydict_remove(ctx, any->value.str);\n            break;\n        case LYD_ANYDATA_DATATREE:\n            lyd_free_withsiblings(any->value.tree);\n            break;\n        case LYD_ANYDATA_XML:\n            lyxml_free_withsiblings(ctx, any->value.xml);\n            break;\n        case LYD_ANYDATA_LYB:\n            free(any->value.mem);\n            break;\n        case LYD_ANYDATA_STRING:\n        case LYD_ANYDATA_SXMLD:\n        case LYD_ANYDATA_JSOND:\n        case LYD_ANYDATA_LYBD:\n            /* dynamic strings are used only as input parameters */\n            assert(0);\n            break;\n        }\n        /* ... and 2) store the new one */\n        switch (value_type) {\n        case LYD_ANYDATA_CONSTSTRING:\n        case LYD_ANYDATA_SXML:\n        case LYD_ANYDATA_JSON:\n            any->value.str = lydict_insert(ctx, (const char *)value, 0);\n            break;\n        case LYD_ANYDATA_STRING:\n        case LYD_ANYDATA_SXMLD:\n        case LYD_ANYDATA_JSOND:\n            any->value.str = lydict_insert_zc(ctx, (char *)value);\n            value_type &= ~LYD_ANYDATA_STRING; /* make const string from string */\n            break;\n        case LYD_ANYDATA_DATATREE:\n            any->value.tree = value;\n            break;\n        case LYD_ANYDATA_XML:\n            any->value.xml = value;\n            break;\n        case LYD_ANYDATA_LYB:\n            len = lyd_lyb_data_length(value);\n            if (len == -1) {\n                LOGERR(ctx, LY_EINVAL, \"Invalid LYB data.\");\n                return NULL;\n            }\n            any->value.mem = malloc(len);\n            LY_CHECK_ERR_RETURN(!any->value.mem, LOGMEM(ctx), NULL);\n            memcpy(any->value.mem, value, len);\n            break;\n        case LYD_ANYDATA_LYBD:\n            any->value.mem = value;\n            value_type &= ~LYD_ANYDATA_STRING; /* make const string from string */\n            break;\n        }\n        return node;\n    default:\n        /* nothing needed - containers, lists and leaf-lists do not have value or it cannot be changed */\n        break;\n    }\n\n    /* not updated */\n    return NULL;\n}\n\nAPI struct lyd_node *\nlyd_new_path(struct lyd_node *data_tree, const struct ly_ctx *ctx, const char *path, void *value,\n             LYD_ANYDATA_VALUETYPE value_type, int options)\n{\n    char *str;\n    const char *mod_name, *name, *val_name, *val, *node_mod_name, *id, *backup_mod_name = NULL, *yang_data_name = NULL;\n    struct lyd_node *ret = NULL, *node, *parent = NULL;\n    const struct lys_node *schild, *sparent, *tmp;\n    const struct lys_node_list *slist;\n    const struct lys_module *module, *prev_mod;\n    int r, i, parsed = 0, mod_name_len, nam_len, val_name_len, val_len;\n    int is_relative = -1, has_predicate, first_iter = 1, edit_leaf;\n    int backup_is_relative, backup_mod_name_len, yang_data_name_len;\n\n    if (!path || (!data_tree && !ctx)\n            || (!data_tree && (path[0] != '/'))) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (!ctx) {\n        ctx = data_tree->schema->module->ctx;\n    }\n\n    id = path;\n\n    if (data_tree) {\n        if (path[0] == '/') {\n            /* absolute path, go through all the siblings and try to find the right parent, if exists,\n             * first go through all the next siblings keeping the original order, for positional predicates */\n            for (node = data_tree; !parsed && node; node = node->next) {\n                parent = resolve_partial_json_data_nodeid(id, value_type > LYD_ANYDATA_STRING ? NULL : value, node,\n                                                          options, &parsed);\n            }\n            if (!parsed) {\n                for (node = data_tree->prev; !parsed && node->next; node = node->prev) {\n                    parent = resolve_partial_json_data_nodeid(id, value_type > LYD_ANYDATA_STRING ? NULL : value, node,\n                                                              options, &parsed);\n                }\n            }\n        } else {\n            /* relative path, use only the provided data tree root */\n            parent = resolve_partial_json_data_nodeid(id, value_type > LYD_ANYDATA_STRING ? NULL : value, data_tree,\n                                                      options, &parsed);\n        }\n        if (parsed == -1) {\n            return NULL;\n        }\n        if (parsed) {\n            assert(parent);\n            /* if we parsed something we have a relative path now for sure, otherwise we don't know */\n            is_relative = 1;\n\n            id += parsed;\n\n            if (!id[0]) {\n                /* the node exists, are we supposed to update it or is it default? */\n                if (!(options & LYD_PATH_OPT_UPDATE) && (!parent->dflt || (options & LYD_PATH_OPT_DFLT))) {\n                    LOGVAL(ctx, LYE_PATH_EXISTS, LY_VLOG_STR, path);\n                    return NULL;\n                }\n\n                /* no change, the default node already exists */\n                if (parent->dflt && (options & LYD_PATH_OPT_DFLT)) {\n                    return NULL;\n                }\n\n                return lyd_new_path_update(parent, value, value_type, options & LYD_PATH_OPT_DFLT);\n            }\n        }\n    }\n\n    backup_is_relative = is_relative;\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 1)) < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n        return NULL;\n    }\n\n    if (name[0] == '#') {\n        if (is_relative) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, '#', name);\n            return NULL;\n        }\n        yang_data_name = name + 1;\n        yang_data_name_len = nam_len - 1;\n        backup_mod_name = mod_name;\n        backup_mod_name_len = mod_name_len;\n        /* move to the next node in the path */\n        id += r;\n    } else {\n        is_relative = backup_is_relative;\n    }\n\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate, NULL, 0)) < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n        return NULL;\n    }\n    /* move to the next node in the path */\n    id += r;\n\n    if (backup_mod_name) {\n        mod_name = backup_mod_name;\n        mod_name_len = backup_mod_name_len;\n    }\n\n    /* prepare everything for the schema search loop */\n    if (is_relative) {\n        /* we are relative to data_tree or parent if some part of the path already exists */\n        if (!data_tree) {\n            LOGERR(ctx, LY_EINVAL, \"%s: provided relative path (%s) without context node.\", path);\n            return NULL;\n        } else if (!parent) {\n            parent = data_tree;\n        }\n        sparent = parent->schema;\n        module = prev_mod = lys_node_module(sparent);\n    } else {\n        /* we are starting from scratch, absolute path */\n        assert(!parent);\n        if (!mod_name) {\n            str = strndup(path, (name + nam_len) - path);\n            LOGVAL(ctx, LYE_PATH_MISSMOD, LY_VLOG_STR, str);\n            free(str);\n            return NULL;\n        }\n\n        module = ly_ctx_nget_module(ctx, mod_name, mod_name_len, NULL, 1);\n\n        if (!module) {\n            str = strndup(path, (mod_name + mod_name_len) - path);\n            LOGVAL(ctx, LYE_PATH_INMOD, LY_VLOG_STR, str);\n            free(str);\n            return NULL;\n        }\n        mod_name = NULL;\n        mod_name_len = 0;\n        prev_mod = module;\n\n        sparent = NULL;\n        if (yang_data_name) {\n            sparent = lyp_get_yang_data_template(module, yang_data_name, yang_data_name_len);\n            if (!sparent) {\n                str = strndup(path, (yang_data_name + yang_data_name_len) - path);\n                LOGVAL(ctx, LYE_PATH_INNODE, LY_VLOG_STR, str);\n                free(str);\n                return NULL;\n            }\n        }\n    }\n\n    /* create nodes in a loop */\n    while (1) {\n        /* find the schema node */\n        schild = NULL;\n        while ((schild = lys_getnext(schild, sparent, module, 0))) {\n            if (schild->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST\n                                    | LYS_ANYDATA | LYS_NOTIF | LYS_RPC | LYS_ACTION)) {\n                /* module comparison */\n                if (mod_name) {\n                    node_mod_name = lys_node_module(schild)->name;\n                    if (strncmp(node_mod_name, mod_name, mod_name_len) || node_mod_name[mod_name_len]) {\n                        continue;\n                    }\n                } else if (lys_node_module(schild) != prev_mod) {\n                    continue;\n                }\n\n                /* name check */\n                if (strncmp(schild->name, name, nam_len) || schild->name[nam_len]) {\n                    continue;\n                }\n\n                /* RPC/action in/out check */\n                for (tmp = lys_parent(schild); tmp && (tmp->nodetype == LYS_USES); tmp = lys_parent(tmp));\n                if (tmp) {\n                    if (options & LYD_PATH_OPT_OUTPUT) {\n                        if (tmp->nodetype == LYS_INPUT) {\n                            continue;\n                        }\n                    } else {\n                        if (tmp->nodetype == LYS_OUTPUT) {\n                            continue;\n                        }\n                    }\n                }\n\n                break;\n            }\n        }\n\n        if (!schild) {\n            str = strndup(path, (name + nam_len) - path);\n            LOGVAL(ctx, LYE_PATH_INNODE, LY_VLOG_STR, str);\n            free(str);\n            lyd_free(ret);\n            return NULL;\n        }\n\n        /* we have the right schema node */\n        switch (schild->nodetype) {\n        case LYS_CONTAINER:\n        case LYS_LIST:\n        case LYS_NOTIF:\n        case LYS_RPC:\n        case LYS_ACTION:\n            if (options & LYD_PATH_OPT_NOPARENT) {\n                /* these were supposed to exist */\n                str = strndup(path, (name + nam_len) - path);\n                LOGVAL(ctx, LYE_PATH_MISSPAR, LY_VLOG_STR, str);\n                free(str);\n                lyd_free(ret);\n                return NULL;\n            }\n            node = _lyd_new(is_relative ? parent : NULL, schild, (options & LYD_PATH_OPT_DFLT) ? 1 : 0);\n            break;\n        case LYS_LEAF:\n        case LYS_LEAFLIST:\n            str = NULL;\n            if (has_predicate) {\n                if ((r = parse_schema_json_predicate(id, NULL, NULL, &val_name, &val_name_len, &val, &val_len, &has_predicate)) < 1) {\n                    LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n                    lyd_free(ret);\n                    return NULL;\n                }\n                id += r;\n\n                if ((val_name[0] != '.') || (val_name_len != 1)) {\n                    LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, val_name[0], val_name);\n                    lyd_free(ret);\n                    return NULL;\n                }\n\n                str = strndup(val, val_len);\n                if (!str) {\n                    LOGMEM(ctx);\n                    lyd_free(ret);\n                    return NULL;\n                }\n            }\n            if (id[0]) {\n                LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n                free(str);\n                lyd_free(ret);\n                return NULL;\n            }\n\n            if ((options & LYD_PATH_OPT_EDIT) && schild->nodetype == LYS_LEAF) {\n                edit_leaf = 1;\n            } else {\n                edit_leaf = 0;\n            }\n            node = _lyd_new_leaf(is_relative ? parent : NULL, schild, (str ? str : value),\n                                 (options & LYD_PATH_OPT_DFLT) ? 1 : 0, edit_leaf);\n            free(str);\n            break;\n        case LYS_ANYXML:\n        case LYS_ANYDATA:\n            if (id[0]) {\n                LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n                lyd_free(ret);\n                return NULL;\n            }\n            if (value_type <= LYD_ANYDATA_STRING && !value) {\n                value_type = LYD_ANYDATA_CONSTSTRING;\n                value = \"\";\n            }\n            node = lyd_create_anydata(is_relative ? parent : NULL, schild, value, value_type);\n            break;\n        default:\n            LOGINT(ctx);\n            node = NULL;\n            break;\n        }\n\n        if (!node) {\n            str = strndup(path, id - path);\n            if (is_relative) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_STR, str, \"Failed to create node \\\"%s\\\" as a child of \\\"%s\\\".\",\n                       schild->name, parent->schema->name);\n            } else {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_STR, str, \"Failed to create node \\\"%s\\\".\", schild->name);\n            }\n            free(str);\n            lyd_free(ret);\n            return NULL;\n        }\n        /* special case when we are creating a sibling of a top-level data node */\n        if (!is_relative) {\n            if (data_tree) {\n                for (; data_tree->next; data_tree = data_tree->next);\n                if (lyd_insert_after(data_tree, node)) {\n                    lyd_free(ret);\n                    return NULL;\n                }\n            }\n            is_relative = 1;\n        }\n\n        if (first_iter) {\n            /* sort if needed, but only when inserted somewhere */\n            sparent = node->schema;\n            do {\n                sparent = lys_parent(sparent);\n            } while (sparent && (sparent->nodetype != ((options & LYD_PATH_OPT_OUTPUT) ? LYS_OUTPUT : LYS_INPUT)));\n            if (sparent && lyd_schema_sort(node, 0)) {\n                lyd_free(ret);\n                return NULL;\n            }\n\n            /* set first created node */\n            ret = node;\n            first_iter = 0;\n        }\n\n        parsed = 0;\n        if ((schild->nodetype == LYS_LIST) && has_predicate && lyd_new_path_list_predicate(node, name, id, &parsed)) {\n            lyd_free(ret);\n            return NULL;\n        }\n        id += parsed;\n\n        if (!id[0]) {\n            /* we are done */\n            if (options & LYD_PATH_OPT_NOPARENTRET) {\n                /* last created node */\n                return node;\n            }\n            return ret;\n        }\n\n        /* prepare for another iteration */\n        parent = node;\n        sparent = schild;\n        prev_mod = lys_node_module(schild);\n\n        /* parse another node */\n        if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate, NULL, 0)) < 1) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n            lyd_free(ret);\n            return NULL;\n        }\n        id += r;\n\n        /* if a key of a list was supposed to be created, it is created as a part of the list instance creation */\n        if ((schild->nodetype == LYS_LIST) && !mod_name) {\n            slist = (const struct lys_node_list *)schild;\n            for (i = 0; i < slist->keys_size; ++i) {\n                if (!strncmp(slist->keys[i]->name, name, nam_len) && !slist->keys[i]->name[nam_len]) {\n                    /* the path continues? there cannot be anything after a key (leaf) */\n                    if (id[0]) {\n                        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n                        lyd_free(ret);\n                        return NULL;\n                    }\n                    return ret;\n                }\n            }\n        }\n    }\n\n    LOGINT(ctx);\n    return NULL;\n}\n\nAPI unsigned int\nlyd_list_pos(const struct lyd_node *node)\n{\n    unsigned int pos;\n    struct lys_node *schema;\n\n    if (!node || ((node->schema->nodetype != LYS_LIST) && (node->schema->nodetype != LYS_LEAFLIST))) {\n        return 0;\n    }\n\n    schema = node->schema;\n    pos = 0;\n    do {\n        if (node->schema == schema) {\n            ++pos;\n        }\n        node = node->prev;\n    } while (node->next);\n\n    return pos;\n}\n\nstruct lyd_node *\nlyd_new_dummy(struct lyd_node *root, struct lyd_node *parent, const struct lys_node *schema, const char *value, int dflt)\n{\n    unsigned int index;\n    struct ly_set *spath;\n    const struct lys_node *siter;\n    struct lyd_node *iter, *dummy = NULL;\n\n    assert(schema);\n    assert(schema->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_ANYDATA | LYS_NOTIF |\n                               LYS_RPC | LYS_ACTION));\n\n    spath = ly_set_new();\n    if (!spath) {\n        LOGMEM(schema->module->ctx);\n        return NULL;\n    }\n\n    if (!parent && root) {\n        /* find data root */\n        for (; root->parent; root = root->parent);   /* vertical move (up) */\n        for (; root->prev->next; root = root->prev); /* horizontal move (left) */\n    }\n\n    /* build schema path */\n    for (siter = schema; siter; siter = lys_parent(siter)) {\n        /* stop if we know some of the parents */\n        if (parent && parent->schema == siter) {\n            break;\n        }\n\n        if (siter->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_ANYDATA | LYS_NOTIF |\n                               LYS_RPC | LYS_ACTION)) {\n            /* we have a node that can appear in data tree */\n            ly_set_add(spath, (void*)siter, LY_SET_OPT_USEASLIST);\n        } /* else skip the rest node types */\n    }\n\n    assert(spath->number > 0);\n    index = spath->number;\n    if (!parent && !(spath->set.s[index - 1]->nodetype & LYS_LEAFLIST)) {\n        /* start by searching for the top-level parent */\n        LY_TREE_FOR(root, iter) {\n            if (iter->schema == spath->set.s[index - 1]) {\n                parent = iter;\n                index--;\n                break;\n            }\n        }\n    }\n\n    iter = parent;\n    while (iter && index && !(spath->set.s[index - 1]->nodetype & LYS_LEAFLIST)) {\n        /* search for closer parent on the path */\n        LY_TREE_FOR(parent->child, iter) {\n            if (iter->schema == spath->set.s[index - 1]) {\n                index--;\n                parent = iter;\n                break;\n            }\n        }\n    }\n    while(index) {\n        /* create the missing part of the path */\n        switch (spath->set.s[index - 1]->nodetype) {\n        case LYS_LEAF:\n        case LYS_LEAFLIST:\n            if (value) {\n                iter = _lyd_new_leaf(parent, spath->set.s[index - 1], value, dflt, 0);\n            } else {\n                iter = lyd_create_leaf(spath->set.s[index - 1], value, dflt);\n                if (iter && parent) {\n                    if (lyd_insert(parent, iter)) {\n                        lyd_free(iter);\n                        goto error;\n                    }\n                }\n            }\n            break;\n        case LYS_CONTAINER:\n        case LYS_LIST:\n            iter = _lyd_new(parent, spath->set.s[index - 1], dflt);\n            break;\n        case LYS_ANYXML:\n        case LYS_ANYDATA:\n            iter = lyd_create_anydata(parent, spath->set.s[index - 1], \"\", LYD_ANYDATA_CONSTSTRING);\n            break;\n        default:\n            goto error;\n        }\n        if (!iter) {\n            LOGINT(schema->module->ctx);\n            goto error;\n        }\n\n        /* we say it is valid and it is dummy */\n        iter->validity = LYD_VAL_INUSE;\n\n        if (!dummy) {\n            dummy = iter;\n        }\n\n        /* continue */\n        parent = iter;\n        index--;\n    }\n\n    ly_set_free(spath);\n\n    return dummy;\n\nerror:\n    ly_set_free(spath);\n    lyd_free(dummy);\n    return NULL;\n}\n\nstatic struct lys_node *\nlys_get_schema_inctx(struct lys_node *schema, struct ly_ctx *ctx)\n{\n    const struct lys_module *mod, *trg_mod = NULL;\n    struct lys_node *parent, *first_sibling = NULL, *iter = NULL;\n    struct ly_set *parents;\n    unsigned int index;\n    uint32_t idx;\n    void **ptr;\n\n    if (!ctx || schema->module->ctx == ctx) {\n        /* we have the same context */\n        return schema;\n    }\n\n    /* store the parents chain */\n    parents = ly_set_new();\n    for (parent = schema; parent; parent = lys_parent(parent)) {\n        /* note - augments are skipped so we will work only with the implemented modules\n         * (where the augments are applied) */\n        if (parent->nodetype != LYS_USES) {\n            ly_set_add(parents, parent, LY_SET_OPT_USEASLIST);\n        }\n    }\n    assert(parents->number);\n    index = parents->number - 1;\n\n    /* process the parents from the top level */\n    /* for the top-level node, we have to locate the module first */\n    parent = parents->set.s[index];\n    if (parent->nodetype == LYS_EXT) {\n        ptr = lys_ext_complex_get_substmt(LY_STMT_NODE, (struct lys_ext_instance_complex *)parent, NULL);\n        if (!ptr) {\n            ly_set_free(parents);\n            return NULL;\n        }\n        first_sibling = *(struct lys_node **)ptr;\n        parent = parents->set.s[--index];\n    }\n    idx = 0;\n    while ((mod = ly_ctx_get_module_iter(ctx, &idx))) {\n        trg_mod = lys_node_module(parent);\n        /* check module name */\n        if (strcmp(mod->name, trg_mod->name)) {\n            continue;\n        }\n\n        /* check revision */\n        if ((!mod->rev_size && !trg_mod->rev_size) ||\n                (mod->rev_size && trg_mod->rev_size && !strcmp(mod->rev[0].date, trg_mod->rev[0].date))) {\n            /* we have match */\n            break;\n        }\n    }\n    /* try data callback */\n    if (!mod && trg_mod && ctx->data_clb) {\n        LOGDBG(LY_LDGYANG, \"Attempting to load '%s' into context using callback ...\", trg_mod->name);\n        mod = ctx->data_clb(ctx, trg_mod->name, NULL, 0, ctx->data_clb_data);\n    }\n    if (!mod) {\n        ly_set_free(parents);\n        return NULL;\n    }\n    if (!first_sibling) {\n        first_sibling = mod->data;\n    }\n\n    /* now search in the schema tree for the matching node */\n    while (1) {\n        lys_get_sibling(first_sibling, trg_mod->name, 0, parent->name, 0, parent->nodetype,\n                        (const struct lys_node **)&iter);\n        if (!iter) {\n            /* not found, iter will be used as NULL result */\n            break;\n        }\n\n        if (index == 0) {\n            /* we are done, iter is the result */\n            break;\n        } else {\n            /* we are going to continue, so update variables for the next loop */\n            first_sibling = iter->child;\n            parent = parents->set.s[--index];\n            iter = NULL;\n        }\n    }\n\n    ly_set_free(parents);\n    return iter;\n}\n\nstatic struct lys_node *\nlyd_get_schema_inctx(const struct lyd_node *node, struct ly_ctx *ctx)\n{\n    assert(node);\n\n    return lys_get_schema_inctx(node->schema, ctx);\n}\n\n/* both target and source were validated */\nstatic void\nlyd_merge_node_update(struct lyd_node *target, struct lyd_node *source)\n{\n    struct ly_ctx *ctx;\n    struct lyd_node_leaf_list *trg_leaf, *src_leaf;\n    struct lyd_node_anydata *trg_any, *src_any;\n    int len;\n\n    assert(target->schema->nodetype & (LYS_LEAF | LYS_ANYDATA));\n    ctx = target->schema->module->ctx;\n\n    if (ctx == source->schema->module->ctx) {\n        /* source and targets are in the same context */\n        if (target->schema->nodetype == LYS_LEAF) {\n            trg_leaf = (struct lyd_node_leaf_list *)target;\n            src_leaf = (struct lyd_node_leaf_list *)source;\n\n            lydict_remove(ctx, trg_leaf->value_str);\n            trg_leaf->value_str = src_leaf->value_str;\n            src_leaf->value_str = NULL;\n            trg_leaf->value_type = src_leaf->value_type;\n            src_leaf->value_type = 0;\n            if (trg_leaf->value_type == LY_TYPE_LEAFREF) {\n                trg_leaf->validity |= LYD_VAL_LEAFREF;\n                lyp_parse_value(&((struct lys_node_leaf *)trg_leaf->schema)->type, &trg_leaf->value_str,\n                                NULL, trg_leaf, NULL, NULL, 1, src_leaf->dflt, 0);\n            } else {\n                lyd_free_value(trg_leaf->value, trg_leaf->value_type, trg_leaf->value_flags,\n                               &((struct lys_node_leaf *)trg_leaf->schema)->type, NULL, NULL, NULL);\n                trg_leaf->value = src_leaf->value;\n            }\n            src_leaf->value = (lyd_val)0;\n            trg_leaf->dflt = src_leaf->dflt;\n\n            check_leaf_list_backlinks(target, 2);\n        } else { /* ANYDATA */\n            trg_any = (struct lyd_node_anydata *)target;\n            src_any = (struct lyd_node_anydata *)source;\n\n            switch(trg_any->value_type) {\n            case LYD_ANYDATA_CONSTSTRING:\n            case LYD_ANYDATA_SXML:\n            case LYD_ANYDATA_JSON:\n                lydict_remove(ctx, trg_any->value.str);\n                break;\n            case LYD_ANYDATA_DATATREE:\n                lyd_free_withsiblings(trg_any->value.tree);\n                break;\n            case LYD_ANYDATA_XML:\n                lyxml_free_withsiblings(ctx, trg_any->value.xml);\n                break;\n            case LYD_ANYDATA_LYB:\n                free(trg_any->value.mem);\n                break;\n            case LYD_ANYDATA_STRING:\n            case LYD_ANYDATA_SXMLD:\n            case LYD_ANYDATA_JSOND:\n            case LYD_ANYDATA_LYBD:\n                /* dynamic strings are used only as input parameters */\n                assert(0);\n                break;\n            }\n\n            trg_any->value_type = src_any->value_type;\n            trg_any->value = src_any->value;\n\n            src_any->value_type = LYD_ANYDATA_DATATREE;\n            src_any->value.tree = NULL;\n        }\n    } else {\n        /* we have different contexts for the target and source */\n        if (target->schema->nodetype == LYS_LEAF) {\n            trg_leaf = (struct lyd_node_leaf_list *)target;\n            src_leaf = (struct lyd_node_leaf_list *)source;\n\n            lydict_remove(ctx, trg_leaf->value_str);\n            trg_leaf->value_str = lydict_insert(ctx, src_leaf->value_str, 0);\n            lyd_free_value(trg_leaf->value, trg_leaf->value_type, trg_leaf->value_flags,\n                           &((struct lys_node_leaf *)trg_leaf->schema)->type, NULL, NULL, NULL);\n            trg_leaf->value_type = src_leaf->value_type;\n            trg_leaf->dflt = src_leaf->dflt;\n\n            switch (trg_leaf->value_type) {\n            case LY_TYPE_BINARY:\n            case LY_TYPE_STRING:\n                /* value_str pointer is shared in these cases */\n                trg_leaf->value.string = trg_leaf->value_str;\n                break;\n            case LY_TYPE_LEAFREF:\n                trg_leaf->validity |= LYD_VAL_LEAFREF;\n                lyp_parse_value(&((struct lys_node_leaf *)trg_leaf->schema)->type, &trg_leaf->value_str,\n                                NULL, trg_leaf, NULL, NULL, 1, trg_leaf->dflt, 0);\n                break;\n            case LY_TYPE_INST:\n                trg_leaf->value.instance = NULL;\n                break;\n            case LY_TYPE_UNION:\n                /* unresolved union (this must be non-validated tree), duplicate the stored string (duplicated\n                 * because of possible change of the value in case of instance-identifier) */\n                trg_leaf->value.string = lydict_insert(ctx, src_leaf->value.string, 0);\n                break;\n            case LY_TYPE_BITS:\n            case LY_TYPE_ENUM:\n            case LY_TYPE_IDENT:\n                /* in case of duplicating bits (no matter if in the same context or not) or enum and identityref into\n                 * a different context, searching for the type and duplicating the data is almost as same as resolving\n                 * the string value, so due to a simplicity, parse the value for the duplicated leaf */\n                lyp_parse_value(&((struct lys_node_leaf *)trg_leaf->schema)->type, &trg_leaf->value_str, NULL,\n                                trg_leaf, NULL, NULL, 1, trg_leaf->dflt, 1);\n                break;\n            default:\n                trg_leaf->value = src_leaf->value;\n                break;\n            }\n\n            check_leaf_list_backlinks(target, 2);\n        } else { /* ANYDATA */\n            trg_any = (struct lyd_node_anydata *)target;\n            src_any = (struct lyd_node_anydata *)source;\n\n            switch(trg_any->value_type) {\n            case LYD_ANYDATA_CONSTSTRING:\n            case LYD_ANYDATA_SXML:\n            case LYD_ANYDATA_JSON:\n                lydict_remove(ctx, trg_any->value.str);\n                break;\n            case LYD_ANYDATA_DATATREE:\n                lyd_free_withsiblings(trg_any->value.tree);\n                break;\n            case LYD_ANYDATA_XML:\n                lyxml_free_withsiblings(ctx, trg_any->value.xml);\n                break;\n            case LYD_ANYDATA_LYB:\n                free(trg_any->value.mem);\n                break;\n            case LYD_ANYDATA_STRING:\n            case LYD_ANYDATA_SXMLD:\n            case LYD_ANYDATA_JSOND:\n            case LYD_ANYDATA_LYBD:\n                /* dynamic strings are used only as input parameters */\n                assert(0);\n                break;\n            }\n\n            trg_any->value_type = src_any->value_type;\n            if ((void*)src_any->value.tree) {\n                /* there is a value to duplicate */\n                switch (trg_any->value_type) {\n                case LYD_ANYDATA_CONSTSTRING:\n                case LYD_ANYDATA_SXML:\n                case LYD_ANYDATA_JSON:\n                    trg_any->value.str = lydict_insert(ctx, src_any->value.str, 0);\n                    break;\n                case LYD_ANYDATA_DATATREE:\n                    trg_any->value.tree = lyd_dup_to_ctx(src_any->value.tree, 1, ctx);\n                    break;\n                case LYD_ANYDATA_XML:\n                    trg_any->value.xml = lyxml_dup_elem(ctx, src_any->value.xml, NULL, 1);\n                    break;\n                case LYD_ANYDATA_LYB:\n                    len = lyd_lyb_data_length(src_any->value.mem);\n                    if (len == -1) {\n                        LOGERR(ctx, LY_EINVAL, \"Invalid LYB data.\");\n                        return;\n                    }\n                    trg_any->value.mem = malloc(len);\n                    LY_CHECK_ERR_RETURN(!trg_any->value.mem, LOGMEM(ctx), );\n                    memcpy(trg_any->value.mem, src_any->value.mem, len);\n                    break;\n                case LYD_ANYDATA_STRING:\n                case LYD_ANYDATA_SXMLD:\n                case LYD_ANYDATA_JSOND:\n                case LYD_ANYDATA_LYBD:\n                    /* dynamic strings are used only as input parameters */\n                    assert(0);\n                    break;\n                }\n            }\n        }\n    }\n}\n\n/* return: 0 (not equal), 1 (equal), -1 (error) */\nstatic int\nlyd_merge_node_schema_equal(struct lyd_node *node1, struct lyd_node *node2)\n{\n    struct lys_node *sch1;\n\n    if (node1->schema->module->ctx == node2->schema->module->ctx) {\n        if (node1->schema != node2->schema) {\n            return 0;\n        }\n    } else {\n        /* the nodes are in different contexts, get the appropriate schema nodes from the\n         * same context */\n        sch1 = lyd_get_schema_inctx(node1, node2->schema->module->ctx);\n        if (!sch1) {\n            LOGERR(node2->schema->module->ctx, LY_EINVAL, \"Target context does not contain a required schema node (%s:%s).\",\n                   lyd_node_module(node1)->name, node1->schema->name);\n            return -1;\n        } else if (sch1 != node2->schema) {\n            /* not matching nodes */\n            return 0;\n        }\n    }\n\n    return 1;\n}\n\n/* return: 0 (not equal), 1 (equal), 2 (equal and state leaf-/list marked), -1 (error) */\nstatic int\nlyd_merge_node_equal(struct lyd_node *node1, struct lyd_node *node2)\n{\n    int ret;\n\n    switch (node1->schema->nodetype) {\n    case LYS_CONTAINER:\n    case LYS_LEAF:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n    case LYS_RPC:\n    case LYS_ACTION:\n    case LYS_NOTIF:\n        return 1;\n    case LYS_LEAFLIST:\n        if (node1->validity & LYD_VAL_INUSE) {\n            /* this instance was already matched, we want to find another so that the number of the istances matches */\n            assert(node1->schema->flags & LYS_CONFIG_R);\n            return 0;\n        }\n\n        ret = lyd_list_equal(node1, node2, 1);\n        if ((ret == 1) && (node1->schema->flags & LYS_CONFIG_R)) {\n            /* mark it as matched */\n            node1->validity |= LYD_VAL_INUSE;\n            ret = 2;\n        }\n        return ret;\n    case LYS_LIST:\n        if (node1->validity & LYD_VAL_INUSE) {\n            /* this instance was already matched, we want to find another so that the number of the istances matches */\n            assert(!((struct lys_node_list *)node1->schema)->keys_size);\n            return 0;\n        }\n\n        ret = lyd_list_equal(node1, node2, 1);\n        if ((ret == 1) && !((struct lys_node_list *)node1->schema)->keys_size) {\n            /* mark it as matched */\n            node1->validity |= LYD_VAL_INUSE;\n            ret = 2;\n        }\n        return ret;\n    default:\n        break;\n    }\n\n    LOGINT(node2->schema->module->ctx);\n    return -1;\n}\n\n/* spends source */\nstatic int\nlyd_merge_parent_children(struct lyd_node *target, struct lyd_node *source, int options)\n{\n    struct lyd_node *trg_parent, *src, *src_backup, *src_elem, *src_elem_backup, *src_next, *trg_child, *trg_parent_backup;\n    int ret, clear_flag = 0;\n    struct ly_ctx *ctx = target->schema->module->ctx; /* shortcut */\n\n    LY_TREE_FOR_SAFE(source, src_backup, src) {\n        for (src_elem = src_next = src, trg_parent = target;\n            src_elem;\n            src_elem = src_next) {\n\n            /* it won't get inserted in this case */\n            if (src_elem->dflt && (options & LYD_OPT_EXPLICIT)) {\n                if (src_elem == src) {\n                    /* we are done with this subtree in this case */\n                    break;\n                }\n                trg_child = (struct lyd_node *)1;\n                goto src_skip;\n            }\n\n            ret = 0;\n\n#ifdef LY_ENABLED_CACHE\n            struct lyd_node **trg_child_p;\n\n            /* trees are supposed to be validated so all nodes must have their hash, but lets not be that strict */\n            if (!src_elem->hash) {\n                lyd_hash(src_elem);\n            }\n\n            if (trg_parent->ht) {\n                trg_child = NULL;\n                if (!lyht_find(trg_parent->ht, &src_elem, src_elem->hash, (void **)&trg_child_p)) {\n                    trg_child = *trg_child_p;\n                    ret = 1;\n\n                    /* it is a bit more difficult with keyless state lists and leaf-lists */\n                    if (((trg_child->schema->nodetype == LYS_LIST) && !((struct lys_node_list *)trg_child->schema)->keys_size)\n                            || ((trg_child->schema->nodetype == LYS_LEAFLIST) && (trg_child->schema->flags & LYS_CONFIG_R))) {\n                        assert(trg_child->schema->flags & LYS_CONFIG_R);\n\n                        while (trg_child && (trg_child->validity & LYD_VAL_INUSE)) {\n                            /* state lists, find one not-already-found */\n                            if (lyht_find_next(trg_parent->ht, &trg_child, trg_child->hash, (void **)&trg_child_p)) {\n                                trg_child = NULL;\n                            } else {\n                                trg_child = *trg_child_p;\n                            }\n                        }\n                        if (trg_child) {\n                            /* mark it as matched */\n                            trg_child->validity |= LYD_VAL_INUSE;\n                            ret = 2;\n                        } else {\n                            /* actually, it was matched already and no other instance found, so now not a match */\n                            ret = 0;\n                        }\n                    }\n                }\n            } else\n#endif\n            {\n                LY_TREE_FOR(trg_parent->child, trg_child) {\n                    /* schema match, data match? */\n                    ret = lyd_merge_node_schema_equal(trg_child, src_elem);\n                    if (ret == 1) {\n                        ret = lyd_merge_node_equal(trg_child, src_elem);\n                    }\n                    if (ret != 0) {\n                        /* even data match */\n                        break;\n                    }\n                }\n            }\n\n            if (ret > 0) {\n                if (trg_child->schema->nodetype & (LYS_LEAF | LYS_ANYDATA)) {\n                    lyd_merge_node_update(trg_child, src_elem);\n                } else if (ret == 2) {\n                    clear_flag = 1;\n                }\n            } else if (ret == -1) {\n                /* error */\n                lyd_free_withsiblings(source);\n                return 1;\n            }\n\n            /* first prepare for the next iteration */\n            src_elem_backup = src_elem;\n            trg_parent_backup = trg_parent;\n            if (((src_elem->schema->nodetype == LYS_CONTAINER) || ((src_elem->schema->nodetype == LYS_LIST)\n                    && ((struct lys_node_list *)src_elem->schema)->keys_size)) && src_elem->child && trg_child) {\n                /* go into children */\n                src_next = src_elem->child;\n                trg_parent = trg_child;\n            } else {\nsrc_skip:\n                /* no children (or the whole subtree will be inserted), try siblings */\n                if (src_elem == src) {\n                    /* we are done with this subtree */\n                    if (trg_child) {\n                        /* it's an empty container, list without keys, or an already-updated leaf/anydata, nothing else to do */\n                        break;\n                    } else {\n                        /* ... but we still need to insert it */\n                        src_next = NULL;\n                        goto src_insert;\n                    }\n                } else {\n                    src_next = src_elem->next;\n                    /* trg_parent does not change */\n                }\n            }\n            while (!src_next) {\n                src_elem = src_elem->parent;\n                if (src_elem->parent == src->parent) {\n                    /* we are done, no next element to process */\n                    break;\n                }\n\n                /* parent is already processed, go to its sibling */\n                src_next = src_elem->next;\n                trg_parent = trg_parent->parent;\n            }\n\n            if (!trg_child) {\nsrc_insert:\n                /* we need to insert the whole subtree */\n                if (ctx == src_elem_backup->schema->module->ctx) {\n                    /* same context - unlink the subtree and insert it into the target */\n                    lyd_unlink(src_elem_backup);\n                } else {\n                    /* different contexts - before inserting subtree, instead of unlinking, duplicate it into the\n                     * target context */\n                    src_elem_backup = lyd_dup_to_ctx(src_elem_backup, 1, ctx);\n                }\n\n                if (src_elem == source) {\n                    /* it will be linked into another data tree and the pointers changed */\n                    source = source->next;\n                }\n\n                /* insert subtree into the target */\n                if (lyd_insert(trg_parent_backup, src_elem_backup)) {\n                    LOGINT(ctx);\n                    lyd_free_withsiblings(source);\n                    return 1;\n                }\n                if (src_elem == src) {\n                    /* we are finished for this src */\n                    break;\n                }\n            }\n        }\n    }\n\n    lyd_free_withsiblings(source);\n    if (clear_flag) {\n        return 2;\n    }\n    return 0;\n}\n\n/* spends source */\nstatic int\nlyd_merge_siblings(struct lyd_node *target, struct lyd_node *source, int options)\n{\n    struct lyd_node *trg, *src, *src_backup, *ins;\n    int ret, clear_flag = 0;\n    struct ly_ctx *ctx = target->schema->module->ctx; /* shortcut */\n\n    while (target->prev->next) {\n        target = target->prev;\n    }\n\n    LY_TREE_FOR_SAFE(source, src_backup, src) {\n        LY_TREE_FOR(target, trg) {\n            /* sibling found, merge it */\n            ret = lyd_merge_node_schema_equal(trg, src);\n            if (ret == 1) {\n                ret = lyd_merge_node_equal(trg, src);\n            }\n            if (ret > 0) {\n                if (ret == 2) {\n                    clear_flag = 1;\n                }\n\n                switch (trg->schema->nodetype) {\n                case LYS_LEAF:\n                case LYS_ANYXML:\n                case LYS_ANYDATA:\n                    lyd_merge_node_update(trg, src);\n                    break;\n                case LYS_LEAFLIST:\n                    /* it's already there, nothing to do */\n                    break;\n                case LYS_LIST:\n                case LYS_CONTAINER:\n                case LYS_NOTIF:\n                case LYS_RPC:\n                case LYS_INPUT:\n                case LYS_OUTPUT:\n                    ret = lyd_merge_parent_children(trg, src->child, options);\n                    if (ret == 2) {\n                        clear_flag = 1;\n                    } else if (ret) {\n                        lyd_free_withsiblings(source);\n                        return 1;\n                    }\n                    break;\n                default:\n                    LOGINT(ctx);\n                    lyd_free_withsiblings(source);\n                    return 1;\n                }\n                break;\n            } else if (ret == -1) {\n                lyd_free_withsiblings(source);\n                return 1;\n            } /* else not equal, nothing to do */\n        }\n\n        /* sibling not found, insert it */\n        if (!trg) {\n            if (ctx != src->schema->module->ctx) {\n                ins = lyd_dup_to_ctx(src, 1, ctx);\n            } else {\n                lyd_unlink(src);\n                if (src == source) {\n                    /* just so source is not freed, we inserted it and need it further */\n                    source = src_backup;\n                }\n                ins = src;\n            }\n            lyd_insert_after(target->prev, ins);\n        }\n    }\n\n    lyd_free_withsiblings(source);\n    if (clear_flag) {\n        return 2;\n    }\n    return 0;\n}\n\nAPI int\nlyd_merge_to_ctx(struct lyd_node **trg, const struct lyd_node *src, int options, struct ly_ctx *ctx)\n{\n    struct lyd_node *node = NULL, *node2, *target, *trg_merge_start, *src_merge_start = NULL;\n    const struct lyd_node *iter;\n    struct lys_node *src_snode, *sch = NULL;\n    int i, src_depth, depth, first_iter, ret, dflt = 1;\n    const struct lys_node *parent = NULL;\n\n    if (!trg || !(*trg) || !src) {\n        LOGARG;\n        return -1;\n    }\n    target = *trg;\n\n    parent = lys_parent(target->schema);\n\n    /* go up all uses */\n    while (parent && (parent->nodetype == LYS_USES)) {\n        parent = lys_parent(parent);\n    }\n\n    if (parent && !lyp_get_yang_data_template_name(target)) {\n        LOGERR(parent->module->ctx, LY_EINVAL, \"Target not a top-level data tree.\");\n        return -1;\n    }\n\n    /* get know if we are converting data into a different context */\n    if (ctx && target->schema->module->ctx != ctx) {\n        /* target's data tree context differs from the target context, move the target\n         * data tree into the target context */\n\n        /* get the first target's top-level and store it as the result */\n        for (; target->prev->next; target = target->prev);\n        *trg = target;\n\n        for (node = NULL, trg_merge_start = target; target; target = target->next) {\n            node2 = lyd_dup_to_ctx(target, 1, ctx);\n            if (!node2) {\n                goto error;\n            }\n            if (node) {\n                if (lyd_insert_after(node->prev, node2)) {\n                    goto error;\n                }\n            } else {\n                node = node2;\n            }\n        }\n        target = node;\n        node = NULL;\n    } else if (src->schema->module->ctx != target->schema->module->ctx) {\n        /* the source data will be converted into the target's context during the merge */\n        ctx = target->schema->module->ctx;\n    } else if (ctx == src->schema->module->ctx) {\n        /* no conversion is needed */\n        ctx = NULL;\n    }\n\n    /* find source top-level schema node */\n    for (src_snode = src->schema, src_depth = 0;\n         (src_snode = lys_parent(src_snode)) && src_snode->nodetype != LYS_EXT;\n         ++src_depth);\n\n    /* find first shared missing schema parent of the subtrees */\n    trg_merge_start = target;\n    depth = 0;\n    first_iter = 1;\n    if (src_depth) {\n        /* we are going to create missing parents in the following loop,\n         * but we will need to know a dflt flag for them. In case the newly\n         * created parent is going to have at least one non-default child,\n         * it will be also non-default, otherwise it will be the default node */\n        if (options & LYD_OPT_NOSIBLINGS) {\n            dflt = src->dflt;\n        } else {\n            LY_TREE_FOR(src, iter) {\n                if (!iter->dflt) {\n                    /* non default sibling -> parent is going to be\n                     * created also as non-default */\n                    dflt = 0;\n                    break;\n                }\n            }\n        }\n    }\n    while (1) {\n        /* going from down (source root) to up (top-level or the common node with target */\n        do {\n            for (src_snode = src->schema, i = 0; i < src_depth - depth; src_snode = lys_parent(src_snode), ++i);\n            ++depth;\n        } while (src_snode != src->schema && (src_snode->nodetype & (LYS_CHOICE | LYS_CASE | LYS_USES)));\n\n        if (src_snode == src->schema) {\n            break;\n        }\n\n        if (src_snode->nodetype != LYS_CONTAINER) {\n            /* we would have to create a list (the only data node with children except container), impossible */\n            LOGERR(ctx, LY_EINVAL, \"Cannot create %s \\\"%s\\\" for the merge.\", strnodetype(src_snode->nodetype), src_snode->name);\n            goto error;\n        }\n\n        /* have we created any missing containers already? if we did,\n         * it is totally useless to search for match, there won't ever be */\n        if (!src_merge_start) {\n            if (first_iter) {\n                node = trg_merge_start;\n                first_iter = 0;\n            } else {\n                node = trg_merge_start->child;\n            }\n\n            /* find it in target data nodes */\n            LY_TREE_FOR(node, node) {\n                if (ctx) {\n                    /* we have the schema nodes in the different context */\n                    sch = lys_get_schema_inctx(src_snode, ctx);\n                    if (!sch) {\n                        LOGERR(ctx, LY_EINVAL, \"Target context does not contain schema node for the data node being \"\n                               \"merged (%s:%s).\", lys_node_module(src_snode)->name, src_snode->name);\n                        goto error;\n                    }\n                } else {\n                    /* the context is same and comparison of the schema nodes will works fine */\n                    sch = src_snode;\n                }\n\n                if (node->schema == sch) {\n                    trg_merge_start = node;\n                    break;\n                }\n            }\n\n            if (!(options & LYD_OPT_DESTRUCT)) {\n                /* the source tree will be duplicated, so to save some work in case\n                 * of different target context, create also the parents nodes in the\n                 * correct context */\n                src_snode = sch;\n            }\n        } else if (ctx && !(options & LYD_OPT_DESTRUCT)) {\n            /* get the schema node in the correct (target) context, same as above,\n             * this is done to save some work and have the source in the same context\n             * when the provided source tree is below duplicated in the target context\n             * and connected into the parents created here */\n            src_snode = lys_get_schema_inctx(src_snode, ctx);\n            if (!src_snode) {\n                LOGERR(ctx, LY_EINVAL, \"Target context does not contain schema node for the data node being \"\n                       \"merged (%s:%s).\", lys_node_module(src_snode)->name, src_snode->name);\n                goto error;\n            }\n        }\n\n        if (!node) {\n            /* it is not there, create it */\n            node2 = _lyd_new(NULL, src_snode, dflt);\n            if (!src_merge_start) {\n                src_merge_start = node2;\n            } else {\n                if (lyd_insert(node2, src_merge_start)) {\n                    goto error;\n                }\n                src_merge_start = node2;\n            }\n        }\n    }\n\n    /* process source according to options */\n    if (options & LYD_OPT_DESTRUCT) {\n        LY_TREE_FOR(src, iter) {\n            check_leaf_list_backlinks((struct lyd_node *)iter, 2);\n            if (options & LYD_OPT_NOSIBLINGS) {\n                break;\n            }\n        }\n\n        node = (struct lyd_node *)src;\n        if ((node->prev != node) && (options & LYD_OPT_NOSIBLINGS)) {\n            node2 = node->prev;\n            lyd_unlink(node);\n            lyd_free_withsiblings(node2);\n        }\n    } else {\n        node = NULL;\n        for (; src; src = src->next) {\n            /* because we already have to duplicate it, do it in the correct context */\n            node2 = lyd_dup_to_ctx(src, 1, ctx);\n            if (!node2) {\n                lyd_free_withsiblings(node);\n                goto error;\n            }\n            if (node) {\n                if (lyd_insert_after(node->prev, node2)) {\n                    lyd_free_withsiblings(node);\n                    goto error;\n                }\n            } else {\n                node = node2;\n            }\n\n            if (options & LYD_OPT_NOSIBLINGS) {\n                break;\n            }\n        }\n    }\n\n    if (src_merge_start) {\n        /* insert data into the created parents */\n        /* first, get the lowest created parent, we don't have to check the nodetype since we are\n         * creating only a simple chain of containers */\n        for (node2 = src_merge_start; node2->child; node2 = node2->child);\n        node2->child = node;\n        LY_TREE_FOR(node, node) {\n            node->parent = node2;\n        }\n    } else {\n        src_merge_start = node;\n    }\n\n    if (!first_iter) {\n        /* !! src_merge start is a child(ren) of trg_merge_start */\n        ret = lyd_merge_parent_children(trg_merge_start, src_merge_start, options);\n    } else {\n        /* !! src_merge start is a (top-level) sibling(s) of trg_merge_start */\n        ret = lyd_merge_siblings(trg_merge_start, src_merge_start, options);\n    }\n    /* it was freed whatever the return value */\n    src_merge_start = NULL;\n    if (ret == 2) {\n        /* clear remporary LYD_VAL_INUSE validation flags */\n        LY_TREE_DFS_BEGIN(target, node2, node) {\n            node->validity &= ~LYD_VAL_INUSE;\n            LY_TREE_DFS_END(target, node2, node);\n        }\n        ret = 0;\n    } else if (ret) {\n        goto error;\n    }\n\n    if (target->schema->nodetype == LYS_RPC) {\n        lyd_schema_sort(target, 1);\n    }\n\n    /* update the pointer to the target tree if needed */\n    if (*trg != target) {\n        lyd_free_withsiblings(*trg);\n        (*trg) = target;\n    }\n    return ret;\n\nerror:\n    if (*trg != target) {\n        /* target is duplication of the original target in different context,\n         * free it due to the error */\n        lyd_free_withsiblings(target);\n    }\n    lyd_free_withsiblings(src_merge_start);\n    return -1;\n}\n\nAPI int\nlyd_merge(struct lyd_node *target, const struct lyd_node *source, int options)\n{\n    if (!target || !source) {\n        LOGARG;\n        return -1;\n    }\n\n    return lyd_merge_to_ctx(&target, source, options, target->schema->module->ctx);\n}\n\nAPI void\nlyd_free_diff(struct lyd_difflist *diff)\n{\n    if (diff) {\n        free(diff->type);\n        free(diff->first);\n        free(diff->second);\n        free(diff);\n    }\n}\n\nstatic int\nlyd_difflist_add(struct lyd_difflist *diff, unsigned int *size, unsigned int index,\n                 LYD_DIFFTYPE type, struct lyd_node *first, struct lyd_node *second)\n{\n    void *new;\n    struct ly_ctx *ctx = (first ? first->schema->module->ctx : second->schema->module->ctx);\n\n    assert(diff);\n    assert(size && *size);\n\n    if (index + 1 == *size) {\n        /* it's time to enlarge */\n        *size = *size + 16;\n        new = realloc(diff->type, *size * sizeof *diff->type);\n        LY_CHECK_ERR_RETURN(!new, LOGMEM(ctx), EXIT_FAILURE);\n        diff->type = new;\n\n        new = realloc(diff->first, *size * sizeof *diff->first);\n        LY_CHECK_ERR_RETURN(!new, LOGMEM(ctx), EXIT_FAILURE);\n        diff->first = new;\n\n        new = realloc(diff->second, *size * sizeof *diff->second);\n        LY_CHECK_ERR_RETURN(!new, LOGMEM(ctx), EXIT_FAILURE);\n        diff->second = new;\n    }\n\n    /* insert the item */\n    diff->type[index] = type;\n    diff->first[index] = first;\n    diff->second[index] = second;\n\n    /* terminate the arrays */\n    index++;\n    diff->type[index] = LYD_DIFF_END;\n    diff->first[index] = NULL;\n    diff->second[index] = NULL;\n\n    return EXIT_SUCCESS;\n}\n\nstruct diff_ordered_dist {\n    struct diff_ordered_dist *next;\n    int dist;\n};\nstruct diff_ordered_item {\n    struct lyd_node *first;\n    struct lyd_node *second;\n    struct diff_ordered_dist *dist;\n};\nstruct diff_ordered {\n    struct lys_node *schema;\n    struct lyd_node *parent;\n    unsigned int count;\n    struct diff_ordered_item *items; /* array */\n    struct diff_ordered_dist *dist;  /* linked list (1-way, ring) */\n    struct diff_ordered_dist *dist_last;  /* aux pointer for faster insertion sort */\n};\n\nstatic int\ndiff_ordset_insert(struct lyd_node *node, struct ly_set *ordset)\n{\n    unsigned int i;\n    struct diff_ordered *new_ordered, *iter;\n\n    for (i = 0; i < ordset->number; i++) {\n        iter = (struct diff_ordered *)ordset->set.g[i];\n        if (iter->schema == node->schema && iter->parent == node->parent) {\n            break;\n        }\n    }\n    if (i == ordset->number) {\n        /* not seen user-ordered list */\n        new_ordered = calloc(1, sizeof *new_ordered);\n        LY_CHECK_ERR_RETURN(!new_ordered, LOGMEM(node->schema->module->ctx), EXIT_FAILURE);\n        new_ordered->schema = node->schema;\n        new_ordered->parent = node->parent;\n\n        ly_set_add(ordset, new_ordered, LY_SET_OPT_USEASLIST);\n    }\n    ((struct diff_ordered *)ordset->set.g[i])->count++;\n\n    return EXIT_SUCCESS;\n}\n\nstatic void\ndiff_ordset_free(struct ly_set *set)\n{\n    unsigned int i, j;\n    struct diff_ordered *ord;\n\n    if (!set) {\n        return;\n    }\n\n    for (i = 0; i < set->number; i++) {\n        ord = (struct diff_ordered *)set->set.g[i];\n        for (j = 0; j < ord->count; j++) {\n            free(ord->items[j].dist);\n        }\n        free(ord->items);\n        free(ord);\n    }\n\n    ly_set_free(set);\n}\n\n/*\n * -1 - error\n *  0 - ok\n *  1 - first and second not the same\n */\nstatic int\nlyd_diff_compare(struct lyd_node *first, struct lyd_node *second, int options)\n{\n    int rc;\n\n    if (first->dflt && !(options & LYD_DIFFOPT_WITHDEFAULTS)) {\n        /* the second one cannot be default (see lyd_diff()),\n         * so the nodes differs (first one is default node) */\n        return 1;\n    }\n\n    if (first->schema->nodetype & (LYS_LEAFLIST | LYS_LIST)) {\n        if (first->validity & LYD_VAL_INUSE) {\n            /* this node was already matched, it cannot be matched twice (except for state leaf-/lists,\n             * which we want to keep the count on this way) */\n            return 1;\n        }\n\n        rc = lyd_list_equal(first, second, (options & LYD_DIFFOPT_WITHDEFAULTS ? 1 : 0));\n        if (rc == -1) {\n            return -1;\n        } else if (!rc) {\n            /* list instances differs */\n            return 1;\n        }\n        /* matches */\n    }\n\n    return 0;\n}\n\n/*\n * -1 - error\n *  0 - ok\n */\nstatic int\nlyd_diff_match(struct lyd_node *first, struct lyd_node *second, struct lyd_difflist *diff, unsigned int *size,\n               unsigned int *i, struct ly_set *matchset, struct ly_set *ordset, int options)\n{\n    switch (first->schema->nodetype) {\n    case LYS_LEAFLIST:\n    case LYS_LIST:\n        /* additional work for future move matching in case of user ordered lists */\n        if (first->schema->flags & LYS_USERORDERED) {\n            diff_ordset_insert(first, ordset);\n        }\n\n        /* falls through */\n    case LYS_CONTAINER:\n        assert(!(second->validity & LYD_VAL_INUSE));\n        second->validity |= LYD_VAL_INUSE;\n        /* remember the matching node in first for keeping correct pointer in first\n         * for comparing when passing through the second tree in lyd_diff().\n         * Duplicities are not allowed actually, but they cannot happen since single\n         * node can match only one node in the other tree */\n        ly_set_add(matchset, first, LY_SET_OPT_USEASLIST);\n        break;\n    case LYS_LEAF:\n        /* check for leaf's modification */\n        if (!lyd_leaf_val_equal(first, second, 0) || ((options & LYD_DIFFOPT_WITHDEFAULTS) && (first->dflt != second->dflt))) {\n            if (lyd_difflist_add(diff, size, (*i)++, LYD_DIFF_CHANGED, first, second)) {\n               return -1;\n            }\n        }\n        break;\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        /* check for anydata/anyxml's modification */\n        if (!lyd_anydata_equal(first, second) && lyd_difflist_add(diff, size, (*i)++, LYD_DIFF_CHANGED, first, second)) {\n            return -1;\n        }\n        break;\n    default:\n        LOGINT(first->schema->module->ctx);\n        return -1;\n    }\n\n    /* mark both that they have matching instance in the other tree */\n    assert(!(first->validity & LYD_VAL_INUSE));\n    first->validity |= LYD_VAL_INUSE;\n\n    return 0;\n}\n\n/* @brief compare if the nodes are equivalent including checking the list's keys\n * Go through the nodes and their parents and in the case of list, compare its keys.\n *\n * @return 0 different, 1 equivalent\n */\nstatic int\nlyd_diff_equivnode(struct lyd_node *first, struct lyd_node *second)\n{\n    struct lyd_node *iter1, *iter2;\n\n    for (iter1 = first, iter2 = second; iter1 && iter2; iter1 = iter1->parent, iter2 = iter2->parent) {\n        if (iter1->schema->module->ctx == iter2->schema->module->ctx) {\n            if (iter1->schema != iter2->schema) {\n                return 0;\n            }\n        } else {\n            if (!ly_strequal(iter1->schema->name, iter2->schema->name, 0)) {\n                /* comparing the names is fine, even if they are, in fact, 2 different nodes\n                 * with equal names, some of their parents will differ */\n                return 0;\n            }\n        }\n        if (iter1->schema->nodetype == LYS_LIST) {\n            /* compare keys */\n            if (lyd_list_equal(iter1, iter2, 0) != 1) {\n                return 0;\n            }\n        }\n    }\n\n    if (iter1 != iter2) {\n        /* we are supposed to be in root (NULL) in both trees */\n        return 0;\n    }\n\n    return 1;\n}\n\nstatic int\nlyd_diff_move_preprocess(struct diff_ordered *ordered, struct lyd_node *first, struct lyd_node *second)\n{\n    struct ly_ctx *ctx = first->schema->module->ctx;\n    struct lyd_node *iter;\n    unsigned int pos = 0;\n    int abs_dist;\n    struct diff_ordered_dist *dist_aux;\n    struct diff_ordered_dist *dist_iter, *dist_last;\n    char *str = NULL;\n\n    /* ordered->count was zeroed and now it is incremented with each added\n     * item's information, so it is actually position of the second node\n     */\n\n    /* get the position of the first node */\n    for (iter = first->prev; iter->next; iter = iter->prev) {\n        if (!(iter->validity & LYD_VAL_INUSE)) {\n            /* skip deleted nodes */\n            continue;\n        }\n        if (iter->schema == first->schema) {\n            pos++;\n        }\n    }\n    if (pos != ordered->count) {\n        LOGDBG(LY_LDGDIFF, \"detected moved element \\\"%s\\\" from %d to %d (distance %d)\",\n               str = lyd_path(first), pos, ordered->count, ordered->count - pos);\n        free(str);\n    }\n\n    /* store information, count distance */\n    ordered->items[pos].dist = dist_aux = calloc(1, sizeof *dist_aux);\n    LY_CHECK_ERR_RETURN(!dist_aux, LOGMEM(ctx), EXIT_FAILURE);\n    ordered->items[pos].dist->dist = ordered->count - pos;\n    abs_dist = abs(ordered->items[pos].dist->dist);\n    ordered->items[pos].first = first;\n    ordered->items[pos].second = second;\n    ordered->count++;\n\n    /* insert sort of distances, higher first */\n    for (dist_iter = ordered->dist, dist_last = NULL;\n            dist_iter;\n            dist_last = dist_iter, dist_iter = dist_iter->next) {\n        if (abs_dist >= abs(dist_iter->dist)) {\n            /* found correct place */\n            dist_aux->next = dist_iter;\n            if (dist_last) {\n                dist_last->next = dist_aux;\n            }\n            break;\n        } else if (dist_iter->next == ordered->dist) {\n            /* last item */\n            dist_aux->next = ordered->dist; /* ring list */\n            ordered->dist_last = dist_aux;\n            break;\n        }\n    }\n    if (dist_aux->next == ordered->dist) {\n        if (ordered->dist_last == dist_aux) {\n            /* last item */\n            if (!ordered->dist) {\n                /* the only item */\n                dist_aux->next = dist_aux;\n                ordered->dist = ordered->dist_last = dist_aux;\n            }\n        } else {\n            /* first item */\n            ordered->dist = dist_aux;\n            if (dist_aux->next) {\n                /* more than one item, update the last one's next */\n                ordered->dist_last->next = dist_aux;\n            } else {\n                /* the only item */\n                ordered->dist_last = dist_aux;\n                dist_aux->next = dist_aux; /* ring list */\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic struct lyd_difflist *\nlyd_diff_init_difflist(struct ly_ctx *ctx, unsigned int *size)\n{\n    struct lyd_difflist *result;\n\n    result = malloc(sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(ctx); *size = 0, NULL);\n\n    *size = 1;\n    result->type = calloc(*size, sizeof *result->type);\n    result->first = calloc(*size, sizeof *result->first);\n    result->second = calloc(*size, sizeof *result->second);\n    if (!result->type || !result->first || !result->second) {\n        LOGMEM(ctx);\n        free(result->second);\n        free(result->first);\n        free(result->type);\n        free(result);\n        *size = 0;\n        return NULL;\n    }\n\n    return result;\n}\n\nAPI struct lyd_difflist *\nlyd_diff(struct lyd_node *first, struct lyd_node *second, int options)\n{\n    struct ly_ctx *ctx;\n    int rc;\n    struct lyd_node *elem1, *elem2, *iter, *aux, *parent = NULL, *next1, *next2;\n    struct lyd_difflist *result, *result2 = NULL;\n    void *new;\n    unsigned int size, size2, index = 0, index2 = 0, i, j, k;\n    struct matchlist_s {\n        struct matchlist_s *prev;\n        struct ly_set *match;\n        unsigned int i;\n    } *matchlist = NULL, *mlaux;\n    struct ly_set *ordset = NULL;\n    struct diff_ordered *ordered;\n    struct diff_ordered_dist *dist_aux, *dist_iter;\n    struct diff_ordered_item item_aux;\n\n    if (!first) {\n        /* all nodes in second were created,\n         * but the second must be top level */\n        if (second && second->parent) {\n            LOGERR(second->schema->module->ctx, LY_EINVAL, \"%s: \\\"first\\\" parameter is NULL and \\\"second\\\" is not top level.\", __func__);\n            return NULL;\n        }\n        result = lyd_diff_init_difflist(NULL, &size);\n        LY_TREE_FOR(second, iter) {\n            if (!iter->dflt || (options & LYD_DIFFOPT_WITHDEFAULTS)) { /* skip the implicit nodes */\n                if (lyd_difflist_add(result, &size, index++, LYD_DIFF_CREATED, NULL, iter)) {\n                    goto error;\n                }\n            }\n            if (options & LYD_DIFFOPT_NOSIBLINGS) {\n                break;\n            }\n        }\n        return result;\n    } else if (!second) {\n        /* all nodes from first were deleted */\n        result = lyd_diff_init_difflist(first->schema->module->ctx, &size);\n        LY_TREE_FOR(first, iter) {\n            if (!iter->dflt || (options & LYD_DIFFOPT_WITHDEFAULTS)) { /* skip the implicit nodes */\n                if (lyd_difflist_add(result, &size, index++, LYD_DIFF_DELETED, iter, NULL)) {\n                    goto error;\n                }\n            }\n            if (options & LYD_DIFFOPT_NOSIBLINGS) {\n                break;\n            }\n        }\n        return result;\n    }\n\n    ctx = first->schema->module->ctx;\n\n    if (options & LYD_DIFFOPT_NOSIBLINGS) {\n        /* both trees must start at the same (schema) node */\n        if (first->schema != second->schema) {\n            LOGERR(ctx, LY_EINVAL, \"%s: incompatible trees to compare with LYD_OPT_NOSIBLINGS option.\", __func__);\n            return NULL;\n        }\n        /* use first's and second's child to make comparison the same as without LYD_OPT_NOSIBLINGS */\n        first = first->child;\n        second = second->child;\n    } else {\n        /* go to the first sibling in both trees */\n        if (first->parent) {\n            first = first->parent->child;\n        } else {\n            while (first->prev->next) {\n                first = first->prev;\n            }\n        }\n\n        if (second->parent) {\n            second = second->parent->child;\n        } else {\n            for (; second->prev->next; second = second->prev);\n        }\n\n        /* check that both has the same (schema) parent or that they are top-level nodes */\n        if ((first->parent && second->parent && first->parent->schema != second->parent->schema) ||\n                (!first->parent && first->parent != second->parent)) {\n            LOGERR(ctx, LY_EINVAL, \"%s: incompatible trees with different parents.\", __func__);\n            return NULL;\n        }\n    }\n    if (first == second) {\n        LOGERR(ctx, LY_EINVAL, \"%s: comparing the same tree does not make sense.\", __func__);\n        return NULL;\n    }\n\n    /* initiate resulting structure */\n    result = lyd_diff_init_difflist(ctx, &size);\n    LY_CHECK_ERR_GOTO(!result, , error);\n\n    /* the records about created and moved items are created in\n     * bad order, so the records about created nodes (and their\n     * possible moving) is stored separately and added to the\n     * main result at the end.\n     */\n    result2 = lyd_diff_init_difflist(ctx, &size2);\n    LY_CHECK_ERR_GOTO(!result2, , error);\n\n    matchlist = malloc(sizeof *matchlist);\n    LY_CHECK_ERR_GOTO(!matchlist, LOGMEM(ctx), error);\n\n    matchlist->i = 0;\n    matchlist->match = ly_set_new();\n    matchlist->prev = NULL;\n\n    ordset = ly_set_new();\n    LY_CHECK_ERR_GOTO(!ordset, , error);\n\n    /*\n     * compare trees\n     */\n    /* 1) newly created nodes + changed leafs/anyxmls */\n    next1 = first;\n    for (elem2 = next2 = second; elem2; elem2 = next2) {\n        /* keep right pointer for searching in the first tree */\n        elem1 = next1;\n\n        if (elem2->dflt && !(options & LYD_DIFFOPT_WITHDEFAULTS)) {\n            /* skip default elements, they could not be created or changed, just deleted */\n            goto cmp_continue;\n        }\n\n#ifdef LY_ENABLED_CACHE\n        struct lyd_node **iter_p;\n\n        if (elem1 && elem1->parent && elem1->parent->ht) {\n            iter = NULL;\n            if (!lyht_find(elem1->parent->ht, &elem2, elem2->hash, (void **)&iter_p)) {\n                iter = *iter_p;\n                /* we found a match */\n                if (iter->dflt && !(options & LYD_DIFFOPT_WITHDEFAULTS)) {\n                    /* the second one cannot be default (see lyd_diff()),\n                     * so the nodes differs (first one is default node) */\n                    iter = NULL;\n                }\n                while (iter && (iter->validity & LYD_VAL_INUSE)) {\n                    /* state lists, find one not-already-found */\n                    assert((iter->schema->nodetype & (LYS_LIST | LYS_LEAFLIST)) && (iter->schema->flags & LYS_CONFIG_R));\n                    if (lyht_find_next(elem1->parent->ht, &iter, iter->hash, (void **)&iter_p)) {\n                        iter = NULL;\n                    } else {\n                        iter = *iter_p;\n                    }\n                }\n            }\n        } else\n#endif\n        {\n            /* search for elem2 instance in the first */\n            LY_TREE_FOR(elem1, iter) {\n                if (iter->schema != elem2->schema) {\n                    continue;\n                }\n\n                /* elem2 instance found */\n                rc = lyd_diff_compare(iter, elem2, options);\n                if (rc == -1) {\n                    goto error;\n                } else if (rc == 0) {\n                    /* match */\n                    break;\n                } /* else, continue */\n            }\n        }\n        /* we have a match */\n        if (iter && lyd_diff_match(iter, elem2, result, &size, &index, matchlist->match, ordset, options)) {\n            goto error;\n        }\n\n        if (!iter) {\n            /* elem2 not found in the first tree */\n            if (lyd_difflist_add(result2, &size2, index2++, LYD_DIFF_CREATED, elem1 ? elem1->parent : parent, elem2)) {\n                goto error;\n            }\n\n            if (elem1 && (elem2->schema->flags & LYS_USERORDERED)) {\n                /* store the correct place where the node is supposed to be moved after creation */\n                /* if elem1 does not exist, all nodes were created and they will be created in\n                 * correct order, so it is not needed to detect moves */\n                for (aux = elem2->prev; aux->next; aux = aux->prev) {\n                    if (aux->schema == elem2->schema) {\n                        /* predecessor found */\n                        break;\n                    }\n                }\n                if (!aux->next) {\n                    /* predecessor not found */\n                    aux = NULL;\n                }\n                if (lyd_difflist_add(result2, &size2, index2++, LYD_DIFF_MOVEDAFTER2, aux, elem2)) {\n                    goto error;\n                }\n            }\n        }\n\ncmp_continue:\n        /* select element for the next run                                    1     2\n         * - first, process all siblings of a single parent                  / \\   / \\\n         * - then, go to children (deep)                                    3   4 7   8\n         * - return to the parent's next sibling children                  / \\\n         *                                                                5   6\n         */\n        /* siblings first */\n        next1 = elem1;\n        next2 = elem2->next;\n\n        if (!next2) {\n            /* children */\n\n            /* first pass of the siblings done, some additional work for future\n             * detection of move may be needed */\n            for (i = ordset->number; i > 0; i--) {\n                ordered = (struct diff_ordered *)ordset->set.g[i - 1];\n                if (ordered->items) {\n                    /* already preprocessed ordered structure */\n                    break;\n                }\n                ordered->items = calloc(ordered->count, sizeof *ordered->items);\n                LY_CHECK_ERR_GOTO(!ordered->items, LOGMEM(ctx), error);\n                ordered->dist = NULL;\n                /* zero the count to be used as a node position in lyd_diff_move_preprocess() */\n                ordered->count = 0;\n            }\n\n            /* first, get the first sibling */\n            if (elem2->parent == second->parent) {\n                elem2 = second;\n            } else {\n                elem2 = elem2->parent->child;\n            }\n\n            /* and then find the first child */\n            LY_TREE_FOR(elem2, iter) {\n                if (!(iter->validity & LYD_VAL_INUSE)) {\n                    /* the iter is not present in both trees */\n                    continue;\n                } else if (matchlist->i == matchlist->match->number) {\n                    if (iter == elem2) {\n                        /* we already went through all the matching nodes and now we are just supposed to stop\n                         * the loop with no iter */\n                        iter = NULL;\n                        break;\n                    } else {\n                        /* we have started with some not processed data in matchlist, but now we have\n                         * the INUSE iter and no nodes in matchlist to find its equivalent,\n                         * so something went wrong somewhere */\n                        LOGINT(ctx);\n                        goto error;\n                    }\n                }\n\n                iter->validity &= ~LYD_VAL_INUSE;\n                if ((iter->schema->nodetype & (LYS_LEAFLIST | LYS_LIST)) && (iter->schema->flags & LYS_USERORDERED)) {\n                    for (j = ordset->number; j > 0; j--) {\n                        ordered = (struct diff_ordered *)ordset->set.g[j - 1];\n                        if (ordered->schema != iter->schema || !lyd_diff_equivnode(ordered->parent, iter->parent)) {\n                            continue;\n                        }\n\n                        /* store necessary information for move detection */\n                        lyd_diff_move_preprocess(ordered, matchlist->match->set.d[matchlist->i], iter);\n                        break;\n                    }\n                }\n\n                if (((iter->schema->nodetype == LYS_CONTAINER) || ((iter->schema->nodetype == LYS_LIST)\n                        && ((struct lys_node_list *)iter->schema)->keys_size)) && iter->child) {\n                    while (matchlist->i < matchlist->match->number && matchlist->match->set.d[matchlist->i]->schema != iter->schema) {\n                        matchlist->i++;\n                    }\n                    if (matchlist->i == matchlist->match->number) {\n                        /* we have the INUSE iter, so we have to find its equivalent in match list */\n                        LOGINT(ctx);\n                        goto error;\n                    }\n                    next1 = matchlist->match->set.d[matchlist->i]->child;\n                    if (!next1) {\n                        parent = matchlist->match->set.d[matchlist->i];\n                    }\n                    matchlist->i++;\n                    next2 = iter->child;\n                    break;\n                }\n                matchlist->i++;\n            }\n\n            if (!iter) {\n                /* no child/data on next level */\n                if (elem2 == second) {\n                    /* done */\n                    break;\n                }\n            } else {\n                /* create new matchlist item */\n                mlaux = malloc(sizeof *mlaux);\n                LY_CHECK_ERR_GOTO(!mlaux, LOGMEM(ctx), error);\n                mlaux->i = 0;\n                mlaux->match = ly_set_new();\n                mlaux->prev = matchlist;\n                matchlist = mlaux;\n            }\n        }\n\n        while (!next2) {\n            /* parent */\n\n            /* clean the last match set */\n            ly_set_clean(matchlist->match);\n            matchlist->i = 0;\n\n            /* try to go to a cousin - child of the next parent's sibling */\n            mlaux = matchlist->prev;\n            LY_TREE_FOR(elem2->parent->next, iter) {\n                if (!(iter->validity & LYD_VAL_INUSE)) {\n                    continue;\n                } else if (mlaux->i == mlaux->match->number) {\n                    if (iter == elem2->parent->next) {\n                        /* we already went through all the matching nodes and now we are just supposed to stop\n                         * the loop with no iter */\n                        iter = NULL;\n                        break;\n                    } else {\n                        /* we have started with some not processed data in matchlist, but now we have\n                         * the INUSE iter and no nodes in matchlist to find its equivalent,\n                         * so something went wrong somewhere */\n                        LOGINT(ctx);\n                        goto error;\n                    }\n                }\n\n                iter->validity &= ~LYD_VAL_INUSE;\n                if ((iter->schema->nodetype & (LYS_LEAFLIST | LYS_LIST)) && (iter->schema->flags & LYS_USERORDERED)) {\n                    for (j = ordset->number ; j > 0; j--) {\n                        ordered = (struct diff_ordered *)ordset->set.g[j - 1];\n                        if (ordered->schema != iter->schema || !lyd_diff_equivnode(ordered->parent, iter->parent)) {\n                            continue;\n                        }\n\n                        /* store necessary information for move detection */\n                        lyd_diff_move_preprocess(ordered, mlaux->match->set.d[mlaux->i], iter);\n                        break;\n                    }\n                }\n\n                if (((iter->schema->nodetype == LYS_CONTAINER) || ((iter->schema->nodetype == LYS_LIST)\n                        && ((struct lys_node_list *)iter->schema)->keys_size)) && iter->child) {\n                    while (mlaux->i < mlaux->match->number && mlaux->match->set.d[mlaux->i]->schema != iter->schema) {\n                        mlaux->i++;\n                    }\n                    if (mlaux->i == mlaux->match->number) {\n                        /* we have the INUSE iter, so we have to find its equivalent in match list */\n                        LOGINT(ctx);\n                        goto error;\n                    }\n                    next1 = mlaux->match->set.d[mlaux->i]->child;\n                    if (!next1) {\n                        parent = mlaux->match->set.d[mlaux->i];\n                    }\n                    mlaux->i++;\n                    next2 = iter->child;\n                    break;\n                }\n                mlaux->i++;\n            }\n\n            /* if no cousin exists, continue next loop on higher level */\n            if (!iter) {\n                elem2 = elem2->parent;\n\n                /* remove matchlist item */\n                ly_set_free(matchlist->match);\n                mlaux = matchlist;\n                matchlist = matchlist->prev;\n                free(mlaux);\n\n                if (!matchlist->prev) { /* elem2->parent == second->parent */\n                    /* done */\n                    break;\n                }\n            }\n        }\n    }\n\n    ly_set_free(matchlist->match);\n    free(matchlist);\n    matchlist = NULL;\n\n    /* 2) deleted nodes */\n    LY_TREE_DFS_BEGIN(first, next1, elem1) {\n        /* search for elem1s deleted in the second */\n        if (elem1->validity & LYD_VAL_INUSE) {\n            /* erase temporary LYD_VAL_INUSE flag and continue into children */\n            elem1->validity &= ~LYD_VAL_INUSE;\n        } else if (!elem1->dflt || (options & LYD_DIFFOPT_WITHDEFAULTS)) {\n            /* elem1 has no matching node in second, add it into result */\n            if (lyd_difflist_add(result, &size, index++, LYD_DIFF_DELETED, elem1, NULL)) {\n                goto error;\n            }\n\n            /* skip subtree processing of data missing in the second tree */\n            goto dfs_nextsibling;\n        }\n\n        /* modified LY_TREE_DFS_END() */\n        /* select element for the next run - children first */\n        if ((elem1->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) || ((elem1->schema->nodetype == LYS_LIST)\n                && !((struct lys_node_list *)elem1->schema)->keys_size)) {\n            next1 = NULL;\n        } else {\n            next1 = elem1->child;\n        }\n        if (!next1) {\ndfs_nextsibling:\n            /* try siblings */\n            next1 = elem1->next;\n        }\n        while (!next1) {\n            /* parent is already processed, go to its sibling */\n\n            elem1 = elem1->parent;\n            if (elem1 == first->parent) {\n                /* we are done, no next element to process */\n                break;\n            }\n\n            next1 = elem1->next;\n        }\n    }\n\n    /* 3) moved nodes (when user-ordered) */\n    for (i = 0; i < ordset->number; i++) {\n        ordered = (struct diff_ordered *)ordset->set.g[i];\n        if (!ordered->dist->dist) {\n            /* the dist list is sorted here, but the biggest dist is 0,\n             * so nothing changed in order of these items between first\n             * and second. We can continue with another user-ordered list.\n             */\n            continue;\n        }\n\n        /* get needed movements\n         * - from the biggest distances try to apply node movements\n         * on first tree node until they will be ordered as in the\n         * second tree - i.e. until there will be no position difference\n         */\n\n        for (dist_iter = ordered->dist; ; dist_iter = dist_iter->next) {\n            /* dist list is sorted at the beginning, since applying a move causes\n             * just a small change in other distances, we assume that the biggest\n             * dist is the next one (note that dist list is implemented as ring\n             * list). This way we avoid sorting distances after each move. The loop\n             * stops when all distances are zero.\n             */\n            dist_aux = dist_iter;\n            while (!dist_iter->dist) {\n                /* no dist, so no move. Try another, but when\n                 * there is no dist at all, stop the loop\n                 */\n                dist_iter = dist_iter->next;\n                if (dist_iter == dist_aux) {\n                    /* all dist we zeroed */\n                    goto movedone;\n                }\n            }\n            /* something to move */\n\n            /* get the item to move */\n            for (k = 0; k < ordered->count; k++) {\n                if (ordered->items[k].dist == dist_iter) {\n                    break;\n                }\n            }\n\n            /* apply the move (distance) */\n            memcpy(&item_aux, &ordered->items[k], sizeof item_aux);\n            if (dist_iter->dist > 0) {\n                /* move to right (other move to left) */\n                while (dist_iter->dist) {\n                    memcpy(&ordered->items[k], &ordered->items[k + 1], sizeof *ordered->items);\n                    ordered->items[k].dist->dist++; /* update moved item distance */\n                    dist_iter->dist--;\n                    k++;\n                }\n            } else {\n                /* move to left (other move to right) */\n                while (dist_iter->dist) {\n                    memcpy(&ordered->items[k], &ordered->items[k - 1], sizeof *ordered->items);\n                    ordered->items[k].dist->dist--; /* update moved item distance */\n                    dist_iter->dist++;\n                    k--;\n                }\n            }\n            memcpy(&ordered->items[k], &item_aux, sizeof *ordered->items);\n\n            /* store the transaction into the difflist */\n            if (lyd_difflist_add(result, &size, index++, LYD_DIFF_MOVEDAFTER1, item_aux.first,\n                                 (k > 0) ? ordered->items[k - 1].first : NULL)) {\n                goto error;\n            }\n            continue;\n\nmovedone:\n            break;\n        }\n    }\n\n    diff_ordset_free(ordset);\n    ordset = NULL;\n\n    if (index2) {\n        /* append result2 with newly created\n         * (and possibly moved) nodes */\n        if (index + index2 + 1 >= size) {\n            /* result must be enlarged */\n            size = index + index2 + 1;\n            new = realloc(result->type, size * sizeof *result->type);\n            LY_CHECK_ERR_GOTO(!new, LOGMEM(ctx), error);\n            result->type = new;\n\n            new = realloc(result->first, size * sizeof *result->first);\n            LY_CHECK_ERR_GOTO(!new, LOGMEM(ctx), error);\n            result->first = new;\n\n            new = realloc(result->second, size * sizeof *result->second);\n            LY_CHECK_ERR_GOTO(!new, LOGMEM(ctx), error);\n            result->second = new;\n        }\n\n        /* append */\n        memcpy(&result->type[index], result2->type, (index2 + 1) * sizeof *result->type);\n        memcpy(&result->first[index], result2->first, (index2 + 1) * sizeof *result->first);\n        memcpy(&result->second[index], result2->second, (index2 + 1) * sizeof *result->second);\n    }\n    lyd_free_diff(result2);\n\n    return result;\n\nerror:\n    while (matchlist) {\n        mlaux = matchlist;\n        matchlist = mlaux->prev;\n        ly_set_free(mlaux->match);\n        free(mlaux);\n\n    }\n    diff_ordset_free(ordset);\n\n    lyd_free_diff(result);\n    lyd_free_diff(result2);\n\n    return NULL;\n}\n\nstatic void\nlyd_insert_setinvalid(struct lyd_node *node)\n{\n    struct lyd_node *next, *elem, *parent_list;\n\n    assert(node);\n\n    /* overall validity of the node itself */\n    node->validity = ly_new_node_validity(node->schema);\n\n    /* explore changed unique leaves */\n    /* first, get know if there is a list in parents chain */\n    for (parent_list = node->parent;\n         parent_list && parent_list->schema->nodetype != LYS_LIST;\n         parent_list = parent_list->parent);\n    if (parent_list && !(parent_list->validity & LYD_VAL_UNIQUE)) {\n        /* there is a list, so check if we inserted a leaf supposed to be unique */\n        for (elem = node; elem; elem = next) {\n            if (elem->schema->nodetype == LYS_LIST) {\n                /* stop searching to the depth, children would be unique to a list in subtree */\n                goto nextsibling;\n            }\n\n            if (elem->schema->nodetype == LYS_LEAF && (elem->schema->flags & LYS_UNIQUE)) {\n                /* set flag to list for future validation */\n                parent_list->validity |= LYD_VAL_UNIQUE;\n                break;\n            }\n\n            if (elem->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                if (elem == node) {\n                    /* stop the loop */\n                    break;\n                }\n                goto nextsibling;\n            }\n\n            /* select next elem to process */\n            /* go into children */\n            next = elem->child;\n            /* go through siblings */\n            if (!next) {\nnextsibling:\n                next = elem->next;\n                if (!next) {\n                    /* no sibling */\n                    if (elem == node) {\n                        /* we are done, back in start node */\n                        break;\n                    }\n                }\n            }\n            /* go back to parents */\n            while (!next) {\n                elem = elem->parent;\n                if (elem->parent == node->parent) {\n                    /* we are done, back in start node */\n                    break;\n                }\n                /* parent was actually already processed, so go to the parent's sibling */\n                next = elem->parent->next;\n            }\n        }\n    }\n\n    if (node->parent) {\n        /* if the inserted node is list/leaflist with constraint on max instances,\n         * invalidate the parent to make it validate this */\n        if (node->schema->nodetype & LYS_LEAFLIST) {\n            if (((struct lys_node_leaflist *)node->schema)->max) {\n                node->parent->validity |= LYD_VAL_MAND;\n            }\n        } else if (node->schema->nodetype & LYS_LIST) {\n            if (((struct lys_node_list *)node->schema)->max) {\n                node->parent->validity |= LYD_VAL_MAND;\n            }\n        }\n    }\n}\n\nstatic void\nlyd_replace(struct lyd_node *orig, struct lyd_node *repl, int destroy)\n{\n    struct lyd_node *iter, *last;\n\n    if (!repl) {\n        /* remove the old one */\n        goto finish;\n    }\n\n    if (repl->parent || repl->prev->next) {\n        /* isolate the new node */\n        repl->next = NULL;\n        repl->prev = repl;\n        last = repl;\n    } else {\n        /* get the last node of a possible list of nodes to be inserted */\n        for(last = repl; last->next; last = last->next) {\n            /* part of the parent changes */\n            last->parent = orig->parent;\n        }\n    }\n\n    /* parent */\n    if (orig->parent) {\n        if (orig->parent->child == orig) {\n            orig->parent->child = repl;\n        }\n        orig->parent = NULL;\n    }\n\n    /* predecessor */\n    if (orig->prev == orig) {\n        /* the old was alone */\n        goto finish;\n    }\n    if (orig->prev->next) {\n        orig->prev->next = repl;\n    }\n    repl->prev = orig->prev;\n    orig->prev = orig;\n\n    /* successor */\n    if (orig->next) {\n        orig->next->prev = last;\n        last->next = orig->next;\n        orig->next = NULL;\n    } else {\n        /* fix the last pointer */\n        if (repl->parent) {\n            repl->parent->child->prev = last;\n        } else {\n            /* get the first sibling */\n            for (iter = repl; iter->prev != orig; iter = iter->prev);\n            iter->prev = last;\n        }\n    }\n\nfinish:\n    /* remove the old one */\n    if (destroy) {\n        lyd_free(orig);\n    }\n}\n\nint\nlyd_insert_common(struct lyd_node *parent, struct lyd_node **sibling, struct lyd_node *node, int invalidate)\n{\n    struct lys_node *par1, *par2;\n    const struct lys_node *siter;\n    struct lyd_node *start, *iter, *ins, *next1, *next2;\n    int invalid = 0, isrpc = 0, clrdflt = 0;\n    struct ly_set *llists = NULL;\n    int i;\n    uint8_t pos;\n    int stype = LYS_INPUT | LYS_OUTPUT;\n\n    assert(parent || sibling);\n\n    /* get first sibling */\n    if (parent) {\n        start = parent->child;\n    } else {\n        for (start = *sibling; start->prev->next; start = start->prev);\n    }\n\n    /* check placing the node to the appropriate place according to the schema */\n    if (!start) {\n        if (!parent) {\n            /* empty tree to insert */\n            if (node->parent || node->prev->next) {\n                /* unlink the node first */\n                lyd_unlink_internal(node, 1);\n            } /* else insert also node's siblings */\n            *sibling = node;\n            return EXIT_SUCCESS;\n        }\n        par1 = parent->schema;\n        if (par1->nodetype & (LYS_RPC | LYS_ACTION)) {\n            /* it is not clear if the tree being created is going to\n             * be rpc (LYS_INPUT) or rpc-reply (LYS_OUTPUT) so we have to\n             * compare against LYS_RPC or LYS_ACTION in par2\n             */\n            stype = LYS_RPC | LYS_ACTION;\n        }\n    } else if (parent && (parent->schema->nodetype & (LYS_RPC | LYS_ACTION))) {\n        par1 = parent->schema;\n        stype = LYS_RPC | LYS_ACTION;\n    } else {\n        for (par1 = lys_parent(start->schema);\n             par1 && !(par1->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_INPUT | LYS_OUTPUT | LYS_NOTIF));\n             par1 = lys_parent(par1));\n    }\n    for (par2 = lys_parent(node->schema);\n         par2 && !(par2->nodetype & (LYS_CONTAINER | LYS_LIST | stype | LYS_NOTIF));\n         par2 = lys_parent(par2));\n    if (par1 != par2) {\n        LOGERR(parent->schema->module->ctx, LY_EINVAL, \"Cannot insert, different parents (\\\"%s\\\" and \\\"%s\\\").\",\n               (par1 ? par1->name : \"<top-lvl>\"), (par2 ? par2->name : \"<top-lvl>\"));\n        return EXIT_FAILURE;\n    }\n\n    if (invalidate) {\n        invalid = isrpc = lyp_is_rpc_action(node->schema);\n        if (!parent || node->parent != parent || isrpc) {\n            /* it is not just moving under a parent node or it is in an RPC where\n             * nodes order matters, so the validation will be necessary */\n            invalid++;\n        }\n    }\n\n    /* unlink only if it is not a list of siblings without a parent and node is not the first sibling */\n    if (node->parent || node->prev->next) {\n        /* do it permanent if the parents are not exact same or if it is top-level */\n        lyd_unlink_internal(node, invalid);\n    }\n\n    llists = ly_set_new();\n\n    /* process the nodes to insert one by one */\n    LY_TREE_FOR_SAFE(node, next1, ins) {\n        if (invalid == 1) {\n            /* auto delete nodes from other cases, if any;\n             * this is done only if node->parent != parent */\n            if (lyv_multicases(ins, NULL, &start, 1, NULL)) {\n                goto error;\n            }\n        }\n\n        /* isolate the node to be handled separately */\n        ins->prev = ins;\n        ins->next = NULL;\n\n        iter = NULL;\n        if (!ins->dflt) {\n            clrdflt = 1;\n        }\n\n        /* are we inserting list key? */\n        if (!ins->dflt && ins->schema->nodetype == LYS_LEAF && lys_is_key((struct lys_node_leaf *)ins->schema, &pos)) {\n            /* yes, we have a key, get know its position */\n            for (i = 0, iter = parent->child;\n                    iter && i < pos && iter->schema->nodetype == LYS_LEAF;\n                    i++, iter = iter->next);\n            if (iter) {\n                /* insert list's key to the correct position - before the iter */\n                if (parent->child == iter) {\n                    parent->child = ins;\n                }\n                if (iter->prev->next) {\n                    iter->prev->next = ins;\n                }\n                ins->prev = iter->prev;\n                iter->prev = ins;\n                ins->next = iter;\n\n                /* update start element */\n                if (parent->child != start) {\n                    start = parent->child;\n                }\n            }\n\n            /* try to find previously present default instance to replace */\n        } else if (ins->schema->nodetype == LYS_LEAFLIST) {\n            i = (int)llists->number;\n            if ((ly_set_add(llists, ins->schema, 0) != i) || ins->dflt) {\n                /* each leaf-list must be cleared only once (except when looking for exact same existing dflt nodes) */\n                LY_TREE_FOR_SAFE(start, next2, iter) {\n                    if (iter->schema == ins->schema) {\n                        if ((ins->dflt && (!iter->dflt || ((iter->schema->flags & LYS_CONFIG_W) &&\n                                                           !strcmp(((struct lyd_node_leaf_list *)iter)->value_str,\n                                                                  ((struct lyd_node_leaf_list *)ins)->value_str))))\n                                || (!ins->dflt && iter->dflt)) {\n                            if (iter == start) {\n                                start = next2;\n                            }\n                            lyd_free(iter);\n                        }\n                    }\n                }\n            }\n        } else if (ins->schema->nodetype == LYS_LEAF || (ins->schema->nodetype == LYS_CONTAINER\n                        && !((struct lys_node_container *)ins->schema)->presence)) {\n            LY_TREE_FOR(start, iter) {\n                if (iter->schema == ins->schema) {\n                    if (ins->dflt || iter->dflt) {\n                        /* replace existing (either explicit or default) node with the new (either explicit or default) node */\n                        lyd_replace(iter, ins, 1);\n                    } else {\n                        /* keep both explicit nodes, let the caller solve it later */\n                        iter = NULL;\n                    }\n                    break;\n                }\n            }\n        }\n\n        if (!iter) {\n            if (!start) {\n                /* add as the only child of the parent */\n                start = ins;\n                if (parent) {\n                    parent->child = ins;\n                }\n            } else if (isrpc) {\n                /* add to the specific position in rpc/rpc-reply/action */\n                for (par1 = ins->schema->parent; !(par1->nodetype & (LYS_INPUT | LYS_OUTPUT)); par1 = lys_parent(par1));\n                siter = NULL;\n                LY_TREE_FOR(start, iter) {\n                    while ((siter = lys_getnext(siter, par1, lys_node_module(par1), 0))) {\n                        if (iter->schema == siter || ins->schema == siter) {\n                            break;\n                        }\n                    }\n                    if (ins->schema == siter) {\n                        if ((siter->nodetype & (LYS_LEAFLIST | LYS_LIST)) && iter->schema == siter) {\n                            /* we are inserting leaflist/list instance, but since there are already\n                             * some instances of the same leaflist/list, we want to insert the new one\n                             * as the last instance, so here we have to move on */\n                            while (iter && iter->schema == siter) {\n                                iter = iter->next;\n                            }\n                            if (!iter) {\n                                break;\n                            }\n                        }\n                        /* we have the correct place for new node (before the iter) */\n                        if (iter == start) {\n                            start = ins;\n                            if (parent) {\n                                parent->child = ins;\n                            }\n                        } else {\n                            iter->prev->next = ins;\n                        }\n                        ins->prev = iter->prev;\n                        iter->prev = ins;\n                        ins->next = iter;\n\n                        /* we are done */\n                        break;\n                    }\n                }\n                if (!iter) {\n                    /* add as the last child of the parent */\n                    start->prev->next = ins;\n                    ins->prev = start->prev;\n                    start->prev = ins;\n                }\n            } else {\n                /* add as the last child of the parent */\n                start->prev->next = ins;\n                ins->prev = start->prev;\n                start->prev = ins;\n            }\n        }\n\n#ifdef LY_ENABLED_CACHE\n        lyd_unlink_hash(ins, ins->parent);\n#endif\n\n        ins->parent = parent;\n\n#ifdef LY_ENABLED_CACHE\n        lyd_insert_hash(ins);\n#endif\n\n        if (invalidate) {\n            check_leaf_list_backlinks(ins, 0);\n        }\n\n        if (invalid) {\n            lyd_insert_setinvalid(ins);\n        }\n    }\n    ly_set_free(llists);\n\n    if (clrdflt) {\n        /* remove the dflt flag from parents */\n        for (iter = parent; iter && iter->dflt; iter = iter->parent) {\n            iter->dflt = 0;\n        }\n    }\n\n    if (sibling) {\n        *sibling = start;\n    }\n    return EXIT_SUCCESS;\n\nerror:\n    ly_set_free(llists);\n    return EXIT_FAILURE;\n}\n\nAPI int\nlyd_insert(struct lyd_node *parent, struct lyd_node *node)\n{\n    if (!node || !parent || (parent->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA))) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    return lyd_insert_common(parent, NULL, node, 1);\n}\n\nAPI int\nlyd_insert_sibling(struct lyd_node **sibling, struct lyd_node *node)\n{\n    if (!sibling || !node) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    return lyd_insert_common((*sibling) ? (*sibling)->parent : NULL, sibling, node, 1);\n\n}\n\nint\nlyd_insert_nextto(struct lyd_node *sibling, struct lyd_node *node, int before, int invalidate)\n{\n    struct ly_ctx *ctx;\n    struct lys_node *par1, *par2;\n    struct lyd_node *iter, *start = NULL, *ins, *next1, *next2, *last;\n    struct lyd_node *orig_parent = NULL, *orig_prev = NULL, *orig_next = NULL;\n    int invalid = 0;\n    char *str;\n\n    assert(sibling);\n    assert(node);\n\n    ctx = sibling->schema->module->ctx;\n\n    if (sibling == node) {\n        return EXIT_SUCCESS;\n    }\n\n    /* check placing the node to the appropriate place according to the schema */\n    for (par1 = lys_parent(sibling->schema);\n         par1 && !(par1->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_INPUT | LYS_OUTPUT | LYS_ACTION | LYS_NOTIF));\n         par1 = lys_parent(par1));\n    for (par2 = lys_parent(node->schema);\n         par2 && !(par2->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_INPUT | LYS_OUTPUT | LYS_ACTION | LYS_NOTIF));\n         par2 = lys_parent(par2));\n    if (par1 != par2) {\n        LOGERR(ctx, LY_EINVAL, \"Cannot insert, different parents (\\\"%s\\\" and \\\"%s\\\").\",\n               (par1 ? par1->name : \"<top-lvl>\"), (par2 ? par2->name : \"<top-lvl>\"));\n        return EXIT_FAILURE;\n    }\n\n    if (invalidate && ((node->parent != sibling->parent) || (invalid = lyp_is_rpc_action(node->schema)) || !node->parent)) {\n        /* a) it is not just moving under a parent node (invalid = 1) or\n         * b) it is in an RPC where nodes order matters (invalid = 2) or\n         * c) it is top-level where we don't know if it is the same tree (invalid = 1),\n         * so the validation will be necessary */\n        if (!node->parent && !invalid) {\n            /* c) search in siblings */\n            for (iter = node->prev; iter != node; iter = iter->prev) {\n                if (iter == sibling) {\n                    break;\n                }\n            }\n            if (iter == node) {\n                /* node and siblings are not currently in the same data tree */\n                invalid++;\n            }\n        } else { /* a) and b) */\n            invalid++;\n        }\n    }\n\n    /* unlink only if it is not a list of siblings without a parent or node is not the first sibling,\n     * always unlink if just moving a node */\n    if ((!invalid) || node->parent || node->prev->next) {\n        /* remember the original position to be able to revert\n         * unlink in case of error */\n        orig_parent = node->parent;\n        if (node->prev != node) {\n            orig_prev = node->prev;\n        }\n        orig_next = node->next;\n        lyd_unlink_internal(node, invalid);\n    }\n\n    /* find first sibling node */\n    if (sibling->parent) {\n        start = sibling->parent->child;\n    } else {\n        for (start = sibling; start->prev->next; start = start->prev);\n    }\n\n    /* process the nodes one by one to clean the current tree */\n    if (!invalid) {\n        /* just moving one sibling */\n        last = node;\n        node->parent = sibling->parent;\n    } else {\n        LY_TREE_FOR_SAFE(node, next1, ins) {\n            lyd_insert_setinvalid(ins);\n\n            if (invalid == 1) {\n                /* auto delete nodes from other cases */\n                if (lyv_multicases(ins, NULL, &start, 1, sibling) == 2) {\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYD, sibling, \"Insert request refers node (%s) that is going to be auto-deleted.\",\n                        ly_errpath(ctx));\n                    goto error;\n                }\n            }\n\n            /* try to find previously present default instance to remove because of\n            * inserting the specified node */\n            if (ins->schema->nodetype == LYS_LEAFLIST) {\n                LY_TREE_FOR_SAFE(start, next2, iter) {\n                    if (iter->schema == ins->schema) {\n                        if ((ins->dflt && (!iter->dflt || ((iter->schema->flags & LYS_CONFIG_W) &&\n                                                        !strcmp(((struct lyd_node_leaf_list *)iter)->value_str,\n                                                                ((struct lyd_node_leaf_list *)ins)->value_str))))\n                                || (!ins->dflt && iter->dflt)) {\n                            /* iter will get deleted */\n                            if (iter == sibling) {\n                                LOGERR(ctx, LY_EINVAL, \"Insert request refers node (%s) that is going to be auto-deleted.\",\n                                    str = lyd_path(sibling));\n                                free(str);\n                                goto error;\n                            }\n                            if (iter == start) {\n                                start = next2;\n                            }\n                            lyd_free(iter);\n                        }\n                    }\n                }\n            } else if (ins->schema->nodetype == LYS_LEAF ||\n                    (ins->schema->nodetype == LYS_CONTAINER && !((struct lys_node_container *)ins->schema)->presence)) {\n                LY_TREE_FOR(start, iter) {\n                    if (iter->schema == ins->schema) {\n                        if (iter->dflt || ins->dflt) {\n                            /* iter gets deleted */\n                            if (iter == sibling) {\n                                LOGERR(ctx, LY_EINVAL, \"Insert request refers node (%s) that is going to be auto-deleted.\",\n                                    str = lyd_path(sibling));\n                                free(str);\n                                goto error;\n                            }\n                            if (iter == start) {\n                                start = iter->next;\n                            }\n                            lyd_free(iter);\n                        }\n                        break;\n                    }\n                }\n            }\n\n#ifdef LY_ENABLED_CACHE\n            lyd_unlink_hash(ins, ins->parent);\n#endif\n\n            ins->parent = sibling->parent;\n\n#ifdef LY_ENABLED_CACHE\n            lyd_insert_hash(ins);\n#endif\n            last = ins;\n        }\n    }\n\n    /* insert the (list of) node(s) to the specified position */\n    if (before) {\n        if (sibling->prev->next) {\n            /* adding into a middle */\n            sibling->prev->next = node;\n        } else if (sibling->parent) {\n            /* at the beginning */\n            sibling->parent->child = node;\n        }\n        node->prev = sibling->prev;\n        sibling->prev = last;\n        last->next = sibling;\n    } else { /* after */\n        if (sibling->next) {\n            /* adding into a middle - fix the prev pointer of the node after inserted nodes */\n            last->next = sibling->next;\n            sibling->next->prev = last;\n        } else {\n            /* at the end - fix the prev pointer of the first node */\n            start->prev = last;\n        }\n        sibling->next = node;\n        node->prev = sibling;\n    }\n\n    if (invalidate) {\n        LY_TREE_FOR(node, next1) {\n            check_leaf_list_backlinks(next1, 0);\n            if (next1 == last) {\n                break;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    /* insert back to the original position */\n    if (orig_prev) {\n        lyd_insert_after(orig_prev, node);\n    } else if (orig_next) {\n        lyd_insert_before(orig_next, node);\n    } else if (orig_parent) {\n        /* there were no siblings */\n        orig_parent->child = node;\n        node->parent = orig_parent;\n    }\n    return EXIT_FAILURE;\n}\n\nAPI int\nlyd_insert_before(struct lyd_node *sibling, struct lyd_node *node)\n{\n    if (!node || !sibling) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    return lyd_insert_nextto(sibling, node, 1, 1);\n}\n\nAPI int\nlyd_insert_after(struct lyd_node *sibling, struct lyd_node *node)\n{\n    if (!node || !sibling) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    return lyd_insert_nextto(sibling, node, 0, 1);\n}\n\nstatic uint32_t\nlys_module_pos(struct lys_module *module)\n{\n    int i;\n    uint32_t pos = 1;\n\n    for (i = 0; i < module->ctx->models.used; ++i) {\n        if (module->ctx->models.list[i] == module) {\n            return pos;\n        }\n        ++pos;\n    }\n\n    LOGINT(module->ctx);\n    return 0;\n}\n\nstatic int\nlys_module_node_pos_r(struct lys_node *first_sibling, struct lys_node *target, uint32_t *pos)\n{\n    const struct lys_node *next = NULL;\n\n    /* the schema nodes are actually from data, lys_getnext skips non-data schema nodes for us (we know the parent will not be uses) */\n    while ((next = lys_getnext(next, lys_parent(first_sibling), lys_node_module(first_sibling), LYS_GETNEXT_NOSTATECHECK))) {\n        ++(*pos);\n        if (target == next) {\n            return 0;\n        }\n    }\n\n    LOGINT(first_sibling->module->ctx);\n    return 1;\n}\n\nstatic int\nlyd_node_pos_cmp(const void *item1, const void *item2)\n{\n    uint32_t mpos1, mpos2;\n    struct lyd_node_pos *np1, *np2;\n\n    np1 = (struct lyd_node_pos *)item1;\n    np2 = (struct lyd_node_pos *)item2;\n\n    /* different modules? */\n    if (lys_node_module(np1->node->schema) != lys_node_module(np2->node->schema)) {\n        mpos1 = lys_module_pos(lys_node_module(np1->node->schema));\n        mpos2 = lys_module_pos(lys_node_module(np2->node->schema));\n        /* if lys_module_pos failed, there is nothing we can do anyway,\n         * at least internal error will be printed */\n\n        if (mpos1 > mpos2) {\n            return 1;\n        } else {\n            return -1;\n        }\n    }\n\n    if (np1->pos > np2->pos) {\n        return 1;\n    } else if (np1->pos < np2->pos) {\n        return -1;\n    }\n    return 0;\n}\n\nAPI int\nlyd_schema_sort(struct lyd_node *sibling, int recursive)\n{\n    uint32_t len, i;\n    struct lyd_node *node;\n    struct lys_node *first_ssibling = NULL;\n    struct lyd_node_pos *array;\n\n    if (!sibling) {\n        LOGARG;\n        return -1;\n    }\n\n    /* something actually to sort */\n    if (sibling->prev != sibling) {\n\n        /* find the beginning */\n        sibling = lyd_first_sibling(sibling);\n\n        /* count siblings */\n        len = 0;\n        for (node = sibling; node; node = node->next) {\n            ++len;\n        }\n\n        array = malloc(len * sizeof *array);\n        LY_CHECK_ERR_RETURN(!array, LOGMEM(sibling->schema->module->ctx), -1);\n\n        /* fill arrays with positions and corresponding nodes */\n        for (i = 0, node = sibling; i < len; ++i, node = node->next) {\n            array[i].pos = 0;\n\n            /* we need to repeat this for every module */\n            if (!first_ssibling || (lyd_node_module(node) != lys_node_module(first_ssibling))) {\n                /* find the data node schema parent */\n                first_ssibling = node->schema;\n                while (lys_parent(first_ssibling)\n                        && (lys_parent(first_ssibling)->nodetype & (LYS_CHOICE | LYS_CASE | LYS_USES))) {\n                    first_ssibling = lys_parent(first_ssibling);\n                }\n\n                /* find the beginning */\n                if (lys_parent(first_ssibling)) {\n                    first_ssibling = lys_parent(first_ssibling)->child;\n                } else {\n                    while (first_ssibling->prev->next) {\n                        first_ssibling = first_ssibling->prev;\n                    }\n                }\n            }\n\n            if (lys_module_node_pos_r(first_ssibling, node->schema, &array[i].pos)) {\n                free(array);\n                return -1;\n            }\n\n            array[i].node = node;\n        }\n\n        /* sort the arrays */\n        qsort(array, len, sizeof *array, lyd_node_pos_cmp);\n\n        /* adjust siblings based on the sorted array */\n        for (i = 0; i < len; ++i) {\n            /* parent child */\n            if (i == 0) {\n                /* adjust sibling so that it still points to the beginning */\n                sibling = array[i].node;\n                if (array[i].node->parent) {\n                    array[i].node->parent->child = array[i].node;\n                }\n            }\n\n            /* prev */\n            if (i > 0) {\n                array[i].node->prev = array[i - 1].node;\n            } else {\n                array[i].node->prev = array[len - 1].node;\n            }\n\n            /* next */\n            if (i < len - 1) {\n                array[i].node->next = array[i + 1].node;\n            } else {\n                array[i].node->next = NULL;\n            }\n        }\n        free(array);\n    }\n\n    /* sort all the children recursively */\n    if (recursive) {\n        LY_TREE_FOR(sibling, node) {\n            if ((node->schema->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_RPC | LYS_ACTION | LYS_NOTIF))\n                    && node->child && lyd_schema_sort(node->child, recursive)) {\n                return -1;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nstatic int\n_lyd_validate(struct lyd_node **node, struct lyd_node *data_tree, struct ly_ctx *ctx, const struct lys_module **modules,\n              int mod_count, struct lyd_difflist **diff, int options)\n{\n    struct lyd_node *root, *next1, *next2, *iter, *act_notif = NULL;\n    int ret = EXIT_FAILURE;\n    unsigned int i;\n    struct unres_data *unres = NULL;\n    const struct lys_module *yanglib_mod;\n\n    unres = calloc(1, sizeof *unres);\n    LY_CHECK_ERR_RETURN(!unres, LOGMEM(NULL), EXIT_FAILURE);\n\n    if (diff) {\n        unres->store_diff = 1;\n        unres->diff = lyd_diff_init_difflist(ctx, &unres->diff_size);\n    }\n\n    if ((options & (LYD_OPT_RPC | LYD_OPT_RPCREPLY)) && *node && ((*node)->schema->nodetype != LYS_RPC)) {\n        options |= LYD_OPT_ACT_NOTIF;\n    }\n    if ((options & (LYD_OPT_NOTIF | LYD_OPT_NOTIF_FILTER)) && *node && ((*node)->schema->nodetype != LYS_NOTIF)) {\n        options |= LYD_OPT_ACT_NOTIF;\n    }\n\n    LY_TREE_FOR_SAFE(*node, next1, root) {\n        if (modules) {\n            for (i = 0; i < (unsigned)mod_count; ++i) {\n                if (lyd_node_module(root) == modules[i]) {\n                    break;\n                }\n            }\n            if (i == (unsigned)mod_count) {\n                /* skip data that should not be validated */\n                continue;\n            }\n        }\n\n        LY_TREE_DFS_BEGIN(root, next2, iter) {\n            if (iter->parent && (iter->schema->nodetype & (LYS_ACTION | LYS_NOTIF))) {\n                if (!(options & LYD_OPT_ACT_NOTIF) || act_notif) {\n                    LOGVAL(ctx, LYE_INELEM, LY_VLOG_LYD, iter, iter->schema->name);\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Unexpected %s node \\\"%s\\\".\",\n                           (options & LYD_OPT_RPC ? \"action\" : \"notification\"), iter->schema->name);\n                    goto cleanup;\n                }\n                act_notif = iter;\n            }\n\n            if (lyv_data_context(iter, options, unres) || lyv_data_content(iter, options, unres)) {\n                goto cleanup;\n            }\n\n            /* basic validation successful */\n            iter->validity &= ~LYD_VAL_MAND;\n\n            /* empty non-default, non-presence container without attributes, make it default */\n            if (!iter->dflt && (iter->schema->nodetype == LYS_CONTAINER) && !iter->child\n                        && !((struct lys_node_container *)iter->schema)->presence && !iter->attr) {\n                iter->dflt = 1;\n            }\n\n            LY_TREE_DFS_END(root, next2, iter);\n        }\n\n        if (options & LYD_OPT_NOSIBLINGS) {\n            break;\n        }\n\n    }\n\n    if (options & LYD_OPT_ACT_NOTIF) {\n        if (!act_notif) {\n            LOGVAL(ctx, LYE_MISSELEM, LY_VLOG_LYD, *node, (options & LYD_OPT_RPC ? \"action\" : \"notification\"), (*node)->schema->name);\n            goto cleanup;\n        }\n        options &= ~LYD_OPT_ACT_NOTIF;\n    }\n\n    if (*node) {\n        /* check for uniqueness of top-level lists/leaflists because\n         * only the inner instances were tested in lyv_data_content() */\n        yanglib_mod = ly_ctx_get_module(ctx ? ctx : (*node)->schema->module->ctx, \"ietf-yang-library\", NULL, 1);\n        LY_TREE_FOR(*node, root) {\n            if ((options & LYD_OPT_DATA_ADD_YANGLIB) && yanglib_mod && (root->schema->module == yanglib_mod)) {\n                /* ietf-yang-library data present, so ignore the option to add them */\n                options &= ~LYD_OPT_DATA_ADD_YANGLIB;\n            }\n\n            if (!(root->schema->nodetype & (LYS_LIST | LYS_LEAFLIST)) || !(root->validity & LYD_VAL_DUP)) {\n                continue;\n            }\n\n            if (options & LYD_OPT_TRUSTED) {\n                /* just clear the flag */\n                root->validity &= ~LYD_VAL_DUP;\n                continue;\n            }\n\n            if (lyv_data_dup(root, *node)) {\n                goto cleanup;\n            }\n        }\n    }\n\n    /* add missing ietf-yang-library if requested */\n    if (options & LYD_OPT_DATA_ADD_YANGLIB) {\n        if (!(*node)) {\n            (*node) = ly_ctx_info(ctx);\n        } else if (lyd_merge((*node), ly_ctx_info(ctx), LYD_OPT_DESTRUCT | LYD_OPT_EXPLICIT)) {\n            LOGERR(ctx, LY_EINT, \"Adding ietf-yang-library data failed.\");\n            goto cleanup;\n        }\n    }\n\n    /* add default values, resolve unres and check for mandatory nodes in final tree */\n    if (lyd_defaults_add_unres(node, options, ctx, modules, mod_count, data_tree, act_notif, unres, 1)) {\n        goto cleanup;\n    }\n    if (act_notif) {\n        if (lyd_check_mandatory_tree(act_notif, ctx, modules, mod_count, options)) {\n            goto cleanup;\n        }\n    } else {\n        if (lyd_check_mandatory_tree(*node, ctx, modules, mod_count, options)) {\n            goto cleanup;\n        }\n    }\n\n    /* consolidate diff if created */\n    if (diff) {\n        assert(unres->store_diff);\n\n        for (i = 0; i < unres->diff_idx; ++i) {\n            if (unres->diff->type[i] == LYD_DIFF_CREATED) {\n                if (unres->diff->second[i]->parent) {\n                    unres->diff->first[i] = (struct lyd_node *)lyd_path(unres->diff->second[i]->parent);\n                }\n                unres->diff->second[i] = lyd_dup(unres->diff->second[i], LYD_DUP_OPT_RECURSIVE);\n            }\n        }\n\n        *diff = unres->diff;\n        unres->diff = 0;\n        unres->diff_idx = 0;\n    }\n\n    ret = EXIT_SUCCESS;\n\ncleanup:\n    if (unres) {\n        free(unres->node);\n        free(unres->type);\n        for (i = 0; i < unres->diff_idx; ++i) {\n            if (unres->diff->type[i] == LYD_DIFF_DELETED) {\n                lyd_free_withsiblings(unres->diff->first[i]);\n                free(unres->diff->second[i]);\n            }\n        }\n        lyd_free_diff(unres->diff);\n        free(unres);\n    }\n\n    return ret;\n}\n\nAPI int\nlyd_validate(struct lyd_node **node, int options, void *var_arg, ...)\n{\n    struct lyd_node *iter, *data_tree = NULL;\n    struct lyd_difflist **diff = NULL;\n    struct ly_ctx *ctx = NULL;\n    va_list ap;\n\n    if (!node) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    if (lyp_data_check_options(NULL, options, __func__)) {\n        return EXIT_FAILURE;\n    }\n\n    data_tree = *node;\n\n    if ((!(options & LYD_OPT_TYPEMASK)\n            || (options & (LYD_OPT_CONFIG | LYD_OPT_GET | LYD_OPT_GETCONFIG | LYD_OPT_EDIT))) && !(*node)) {\n        /* get context with schemas from the var_arg */\n        ctx = (struct ly_ctx *)var_arg;\n        if (!ctx) {\n            LOGERR(NULL, LY_EINVAL, \"%s: invalid variable parameter (struct ly_ctx *ctx).\", __func__);\n            return EXIT_FAILURE;\n        }\n\n        /* LYD_OPT_NOSIBLINGS has no meaning here */\n        options &= ~LYD_OPT_NOSIBLINGS;\n    } else if (options & (LYD_OPT_RPC | LYD_OPT_RPCREPLY | LYD_OPT_NOTIF)) {\n        /* LYD_OPT_NOSIBLINGS cannot be set in this case */\n        if (options & LYD_OPT_NOSIBLINGS) {\n            LOGERR(NULL, LY_EINVAL, \"%s: invalid parameter (variable arg const struct lyd_node *data_tree with LYD_OPT_NOSIBLINGS).\", __func__);\n            return EXIT_FAILURE;\n        } else if (!(*node)) {\n            LOGARG;\n            return EXIT_FAILURE;\n        }\n\n        /* get the additional data tree if given */\n        data_tree = (struct lyd_node *)var_arg;\n        if (data_tree) {\n            if (options & LYD_OPT_NOEXTDEPS) {\n                LOGERR(NULL, LY_EINVAL, \"%s: invalid parameter (variable arg const struct lyd_node *data_tree and LYD_OPT_NOEXTDEPS set).\",\n                       __func__);\n                return EXIT_FAILURE;\n            }\n\n            LY_TREE_FOR(data_tree, iter) {\n                if (iter->parent) {\n                    /* a sibling is not top-level */\n                    LOGERR(NULL, LY_EINVAL, \"%s: invalid variable parameter (const struct lyd_node *data_tree).\", __func__);\n                    return EXIT_FAILURE;\n                }\n            }\n\n            /* move it to the beginning */\n            for (; data_tree->prev->next; data_tree = data_tree->prev);\n        }\n    } else if (options & LYD_OPT_DATA_TEMPLATE) {\n        /* get context with schemas from the var_arg */\n        if (*node && ((*node)->prev->next || (*node)->next)) {\n            /* not allow sibling in top-level */\n            LOGERR(NULL, LY_EINVAL, \"%s: invalid variable parameter (struct lyd_node *node).\", __func__);\n            return EXIT_FAILURE;\n        }\n    }\n\n    if (options & LYD_OPT_VAL_DIFF) {\n        va_start(ap, var_arg);\n        diff = va_arg(ap, struct lyd_difflist **);\n        va_end(ap);\n        if (!diff) {\n            LOGERR(ctx, LY_EINVAL, \"%s: invalid variable parameter (struct lyd_difflist **).\", __func__);\n            return EXIT_FAILURE;\n        }\n    }\n\n    if (*node) {\n        if (!ctx) {\n            ctx = (*node)->schema->module->ctx;\n        }\n        if (!(options & LYD_OPT_NOSIBLINGS)) {\n            /* check that the node is the first sibling */\n            while ((*node)->prev->next) {\n                *node = (*node)->prev;\n            }\n        }\n    }\n\n    return _lyd_validate(node, data_tree, ctx, NULL, 0, diff, options);\n}\n\nAPI int\nlyd_validate_modules(struct lyd_node **node, const struct lys_module **modules, int mod_count, int options, ...)\n{\n    struct ly_ctx *ctx;\n    struct lyd_difflist **diff = NULL;\n    va_list ap;\n\n    if (!node || !modules || !mod_count) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    ctx = modules[0]->ctx;\n\n    if (*node && !(options & LYD_OPT_NOSIBLINGS)) {\n        /* check that the node is the first sibling */\n        while ((*node)->prev->next) {\n            *node = (*node)->prev;\n        }\n    }\n\n    if (lyp_data_check_options(ctx, options, __func__)) {\n        return EXIT_FAILURE;\n    }\n\n    if ((options & LYD_OPT_TYPEMASK) && !(options & (LYD_OPT_CONFIG | LYD_OPT_GET | LYD_OPT_GETCONFIG | LYD_OPT_EDIT))) {\n        LOGERR(NULL, LY_EINVAL, \"%s: options include a forbidden data type.\", __func__);\n        return EXIT_FAILURE;\n    }\n\n    if (options & LYD_OPT_VAL_DIFF) {\n        va_start(ap, options);\n        diff = va_arg(ap, struct lyd_difflist **);\n        va_end(ap);\n        if (!diff) {\n            LOGERR(ctx, LY_EINVAL, \"%s: invalid variable parameter (struct lyd_difflist **).\", __func__);\n            return EXIT_FAILURE;\n        }\n    }\n\n    return _lyd_validate(node, *node, ctx, modules, mod_count, diff, options);\n}\n\nAPI int\nlyd_validate_value(struct lys_node *node, const char *value)\n{\n    struct lyd_node_leaf_list leaf;\n    struct lys_node_leaf *sleaf = (struct lys_node_leaf*)node;\n    int ret = EXIT_SUCCESS;\n\n    if (!node || !(node->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    if (!value) {\n        value = \"\";\n    }\n\n    /* dummy leaf */\n    memset(&leaf, 0, sizeof leaf);\n    leaf.value_str = lydict_insert(node->module->ctx, value, 0);\n\nrepeat:\n    leaf.value_type = sleaf->type.base;\n    leaf.schema = node;\n\n    if (leaf.value_type == LY_TYPE_LEAFREF) {\n        if (!sleaf->type.info.lref.target) {\n            /* it should either be unresolved leafref (leaf.value_type are ORed flags) or it will be resolved */\n            LOGINT(node->module->ctx);\n            ret = EXIT_FAILURE;\n            goto cleanup;\n        }\n        sleaf = sleaf->type.info.lref.target;\n        goto repeat;\n    } else {\n        if (!lyp_parse_value(&sleaf->type, &leaf.value_str, NULL, &leaf, NULL, NULL, 0, 0, 0)) {\n            ret = EXIT_FAILURE;\n            goto cleanup;\n        }\n    }\n\ncleanup:\n    lydict_remove(node->module->ctx, leaf.value_str);\n    return ret;\n}\n\n/* create an attribute copy */\nstatic struct lyd_attr *\nlyd_dup_attr(struct ly_ctx *ctx, struct lyd_node *parent, struct lyd_attr *attr)\n{\n    struct lyd_attr *ret;\n\n    /* allocate new attr */\n    if (!parent->attr) {\n        parent->attr = malloc(sizeof *parent->attr);\n        ret = parent->attr;\n    } else {\n        for (ret = parent->attr; ret->next; ret = ret->next);\n        ret->next = calloc(1, sizeof *ret);\n        ret = ret->next;\n    }\n    LY_CHECK_ERR_RETURN(!ret, LOGMEM(ctx), NULL);\n\n    /* fill new attr except */\n    ret->parent = parent;\n    ret->next = NULL;\n    ret->annotation = attr->annotation;\n    ret->name = lydict_insert(ctx, attr->name, 0);\n    ret->value_str = lydict_insert(ctx, attr->value_str, 0);\n    ret->value_type = attr->value_type;\n    ret->value_flags = attr->value_flags;\n    switch (ret->value_type) {\n    case LY_TYPE_BINARY:\n    case LY_TYPE_STRING:\n        /* value_str pointer is shared in these cases */\n        ret->value.string = ret->value_str;\n        break;\n    case LY_TYPE_LEAFREF:\n        lyp_parse_value(*((struct lys_type **)lys_ext_complex_get_substmt(LY_STMT_TYPE, ret->annotation, NULL)),\n                             &ret->value_str, NULL, NULL, ret, NULL, 1, 0, 0);\n        break;\n    case LY_TYPE_INST:\n        ret->value.instance = NULL;\n        break;\n    case LY_TYPE_UNION:\n        /* unresolved union (this must be non-validated tree), duplicate the stored string (duplicated\n         * because of possible change of the value in case of instance-identifier) */\n        ret->value.string = lydict_insert(ctx, attr->value.string, 0);\n        break;\n    case LY_TYPE_ENUM:\n    case LY_TYPE_IDENT:\n    case LY_TYPE_BITS:\n        /* in case of duplicating bits (no matter if in the same context or not) or enum and identityref into\n         * a different context, searching for the type and duplicating the data is almost as same as resolving\n         * the string value, so due to a simplicity, parse the value for the duplicated leaf */\n        lyp_parse_value(*((struct lys_type **)lys_ext_complex_get_substmt(LY_STMT_TYPE, ret->annotation, NULL)),\n                             &ret->value_str, NULL, NULL, ret, NULL, 1, 0, 0);\n        break;\n    default:\n        ret->value = attr->value;\n        break;\n    }\n    return ret;\n}\n\nint\nlyd_unlink_internal(struct lyd_node *node, int permanent)\n{\n    struct lyd_node *iter;\n\n    if (!node) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    if (permanent) {\n        check_leaf_list_backlinks(node, 1);\n    }\n\n    /* unlink from siblings */\n    if (node->prev->next) {\n        node->prev->next = node->next;\n    }\n    if (node->next) {\n        node->next->prev = node->prev;\n    } else {\n        /* unlinking the last node */\n        if (node->parent) {\n            iter = node->parent->child;\n        } else {\n            iter = node->prev;\n            while (iter->prev != node) {\n                iter = iter->prev;\n            }\n        }\n        /* update the \"last\" pointer from the first node */\n        iter->prev = node->prev;\n    }\n\n    /* unlink from parent */\n    if (node->parent) {\n        if (node->parent->child == node) {\n            /* the node is the first child */\n            node->parent->child = node->next;\n        }\n\n#ifdef LY_ENABLED_CACHE\n        /* do not remove from parent hash table if freeing the whole subtree */\n        if (permanent != 2) {\n            lyd_unlink_hash(node, node->parent);\n        }\n#endif\n\n        node->parent = NULL;\n    }\n\n    node->next = NULL;\n    node->prev = node;\n\n    return EXIT_SUCCESS;\n}\n\nAPI int\nlyd_unlink(struct lyd_node *node)\n{\n    return lyd_unlink_internal(node, 1);\n}\n\n/*\n * - in leaflist it must be added with value_str\n */\nstatic int\n_lyd_dup_node_common(struct lyd_node *new_node, const struct lyd_node *orig, struct ly_ctx *ctx, int options)\n{\n    struct lyd_attr *attr;\n\n    new_node->attr = NULL;\n    if (!(options & LYD_DUP_OPT_NO_ATTR)) {\n        LY_TREE_FOR(orig->attr, attr) {\n            lyd_dup_attr(ctx, new_node, attr);\n        }\n    }\n    new_node->next = NULL;\n    new_node->prev = new_node;\n    new_node->parent = NULL;\n    new_node->validity = ly_new_node_validity(new_node->schema);\n    new_node->dflt = orig->dflt;\n    new_node->when_status = orig->when_status & LYD_WHEN;\n#ifdef LY_ENABLED_CACHE\n    /* just copy the hash, it will not change */\n    if ((new_node->schema->nodetype != LYS_LIST) || lyd_list_has_keys(new_node)) {\n        new_node->hash = orig->hash;\n    }\n#endif\n\n#ifdef LY_ENABLED_LYD_PRIV\n    if (ctx->priv_dup_clb) {\n        new_node->priv = ctx->priv_dup_clb(orig->priv);\n    }\n#endif\n\n    return EXIT_SUCCESS;\n}\n\nstatic struct lyd_node *\n_lyd_dup_node(const struct lyd_node *node, const struct lys_node *schema, struct ly_ctx *ctx, int options)\n{\n    struct lyd_node *new_node = NULL;\n    struct lys_node_leaf *sleaf;\n    struct lyd_node_leaf_list *new_leaf;\n    struct lyd_node_anydata *new_any, *old_any;\n    int r;\n\n    /* fill specific part */\n    switch (node->schema->nodetype) {\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n        new_leaf = calloc(1, sizeof *new_leaf);\n        new_node = (struct lyd_node *)new_leaf;\n        LY_CHECK_ERR_GOTO(!new_node, LOGMEM(ctx), error);\n        new_node->schema = (struct lys_node *)schema;\n\n        new_leaf->value_str = lydict_insert(ctx, ((struct lyd_node_leaf_list *)node)->value_str, 0);\n        new_leaf->value_type = ((struct lyd_node_leaf_list *)node)->value_type;\n        new_leaf->value_flags = ((struct lyd_node_leaf_list *)node)->value_flags;\n        if (_lyd_dup_node_common(new_node, node, ctx, options)) {\n            goto error;\n        }\n\n        /* get schema from the correct context */\n        sleaf = (struct lys_node_leaf *)new_leaf->schema;\n\n        switch (new_leaf->value_type) {\n        case LY_TYPE_BINARY:\n        case LY_TYPE_STRING:\n            /* value_str pointer is shared in these cases */\n            new_leaf->value.string = new_leaf->value_str;\n            break;\n        case LY_TYPE_LEAFREF:\n            new_leaf->validity |= LYD_VAL_LEAFREF;\n            lyp_parse_value(&sleaf->type, &new_leaf->value_str, NULL, new_leaf, NULL, NULL, 1, node->dflt, 0);\n            break;\n        case LY_TYPE_INST:\n            new_leaf->value.instance = NULL;\n            break;\n        case LY_TYPE_UNION:\n            /* unresolved union (this must be non-validated tree), duplicate the stored string (duplicated\n             * because of possible change of the value in case of instance-identifier) */\n            new_leaf->value.string = lydict_insert(ctx, ((struct lyd_node_leaf_list *)node)->value.string, 0);\n            break;\n        case LY_TYPE_ENUM:\n        case LY_TYPE_IDENT:\n        case LY_TYPE_BITS:\n            /* in case of duplicating bits (no matter if in the same context or not) or enum and identityref into\n             * a different context, searching for the type and duplicating the data is almost as same as resolving\n             * the string value, so due to a simplicity, parse the value for the duplicated leaf */\n            if (!lyp_parse_value(&sleaf->type, &new_leaf->value_str, NULL, new_leaf, NULL, NULL, 1, node->dflt, 0)) {\n                goto error;\n            }\n            break;\n        default:\n            new_leaf->value = ((struct lyd_node_leaf_list *)node)->value;\n            break;\n        }\n\n        if (sleaf->type.der && sleaf->type.der->module) {\n            r = lytype_store(sleaf->type.der->module, sleaf->type.der->name, new_leaf->value_str, &new_leaf->value);\n            if (r == -1) {\n                goto error;\n            } else if (!r) {\n                new_leaf->value_flags |= LY_VALUE_USER;\n            }\n        }\n        break;\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        old_any = (struct lyd_node_anydata *)node;\n        new_any = calloc(1, sizeof *new_any);\n        new_node = (struct lyd_node *)new_any;\n        LY_CHECK_ERR_GOTO(!new_node, LOGMEM(ctx), error);\n        new_node->schema = (struct lys_node *)schema;\n\n        if (_lyd_dup_node_common(new_node, node, ctx, options)) {\n            goto error;\n        }\n\n        new_any->value_type = old_any->value_type;\n        if (!(void*)old_any->value.tree) {\n            /* no value to duplicate */\n            break;\n        }\n        /* duplicate the value */\n        switch (old_any->value_type) {\n        case LYD_ANYDATA_CONSTSTRING:\n        case LYD_ANYDATA_SXML:\n        case LYD_ANYDATA_JSON:\n            new_any->value.str = lydict_insert(ctx, old_any->value.str, 0);\n            break;\n        case LYD_ANYDATA_DATATREE:\n            new_any->value.tree = lyd_dup_to_ctx(old_any->value.tree, 1, ctx);\n            break;\n        case LYD_ANYDATA_XML:\n            new_any->value.xml = lyxml_dup_elem(ctx, old_any->value.xml, NULL, 1);\n            break;\n        case LYD_ANYDATA_LYB:\n            r = lyd_lyb_data_length(old_any->value.mem);\n            if (r == -1) {\n                LOGERR(ctx, LY_EINVAL, \"Invalid LYB data.\");\n                goto error;\n            }\n            new_any->value.mem = malloc(r);\n            LY_CHECK_ERR_GOTO(!new_any->value.mem, LOGMEM(ctx), error);\n            memcpy(new_any->value.mem, old_any->value.mem, r);\n            break;\n        case LYD_ANYDATA_STRING:\n        case LYD_ANYDATA_SXMLD:\n        case LYD_ANYDATA_JSOND:\n        case LYD_ANYDATA_LYBD:\n            /* dynamic strings are used only as input parameters */\n            assert(0);\n            break;\n        }\n        break;\n    case LYS_CONTAINER:\n    case LYS_LIST:\n    case LYS_NOTIF:\n    case LYS_RPC:\n    case LYS_ACTION:\n        new_node = calloc(1, sizeof *new_node);\n        LY_CHECK_ERR_GOTO(!new_node, LOGMEM(ctx), error);\n        new_node->schema = (struct lys_node *)schema;\n\n        if (_lyd_dup_node_common(new_node, node, ctx, options)) {\n            goto error;\n        }\n        break;\n    default:\n        LOGINT(ctx);\n        goto error;\n    }\n\n    return new_node;\n\nerror:\n    lyd_free(new_node);\n    return NULL;\n}\n\nAPI struct lyd_node *\nlyd_dup_to_ctx(const struct lyd_node *node, int options, struct ly_ctx *ctx)\n{\n    struct ly_ctx *log_ctx;\n    struct lys_node_list *slist;\n    struct lys_node *schema;\n    const char *yang_data_name;\n    const struct lys_module *trg_mod;\n    const struct lyd_node *next, *elem;\n    struct lyd_node *ret, *parent, *key, *key_dup, *new_node = NULL;\n    uint16_t i;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    log_ctx = (ctx ? ctx : node->schema->module->ctx);\n    if (ctx == node->schema->module->ctx) {\n        /* target context is actually the same as the source context,\n         * ignore the target context */\n        ctx = NULL;\n    }\n\n    ret = NULL;\n    parent = NULL;\n\n    /* LY_TREE_DFS */\n    for (elem = next = node; elem; elem = next) {\n\n        /* find the correct schema */\n        if (ctx) {\n            schema = NULL;\n            if (parent) {\n                trg_mod = lyp_get_module(parent->schema->module, NULL, 0, lyd_node_module(elem)->name,\n                                         strlen(lyd_node_module(elem)->name), 1);\n                if (!trg_mod) {\n                    LOGERR(log_ctx, LY_EINVAL, \"Target context does not contain model for the data node being duplicated (%s).\",\n                                lyd_node_module(elem)->name);\n                    goto error;\n                }\n                /* we know its parent, so we can start with it */\n                lys_getnext_data(trg_mod, parent->schema, elem->schema->name, strlen(elem->schema->name),\n                                 elem->schema->nodetype, 0, (const struct lys_node **)&schema);\n            } else {\n                /* we have to search in complete context */\n                schema = lyd_get_schema_inctx(elem, ctx);\n            }\n\n            if (!schema) {\n                yang_data_name = lyp_get_yang_data_template_name(elem);\n                if (yang_data_name) {\n                    LOGERR(log_ctx, LY_EINVAL, \"Target context does not contain schema node for the data node being duplicated \"\n                                        \"(%s:#%s/%s).\", lyd_node_module(elem)->name, yang_data_name, elem->schema->name);\n                } else {\n                    LOGERR(log_ctx, LY_EINVAL, \"Target context does not contain schema node for the data node being duplicated \"\n                                        \"(%s:%s).\", lyd_node_module(elem)->name, elem->schema->name);\n                }\n                goto error;\n            }\n        } else {\n            schema = elem->schema;\n        }\n\n        /* make node copy */\n        new_node = _lyd_dup_node(elem, schema, log_ctx, options);\n        if (!new_node) {\n            goto error;\n        }\n\n        if (parent && lyd_insert(parent, new_node)) {\n            goto error;\n        }\n\n        if (!ret) {\n            ret = new_node;\n        }\n\n        if (!(options & LYD_DUP_OPT_RECURSIVE)) {\n            break;\n        }\n\n        /* LY_TREE_DFS_END */\n        /* select element for the next run - children first,\n         * child exception for lyd_node_leaf and lyd_node_leaflist */\n        if (elem->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n            next = NULL;\n        } else {\n            next = elem->child;\n        }\n        if (!next) {\n            if (elem->parent == node->parent) {\n                break;\n            }\n            /* no children, so try siblings */\n            next = elem->next;\n        } else {\n            parent = new_node;\n        }\n        new_node = NULL;\n\n        while (!next) {\n            /* no siblings, go back through parents */\n            elem = elem->parent;\n            if (elem->parent == node->parent) {\n                break;\n            }\n            if (!parent) {\n                LOGINT(log_ctx);\n                goto error;\n            }\n            parent = parent->parent;\n            /* parent is already processed, go to its sibling */\n            next = elem->next;\n        }\n    }\n\n    /* dup all the parents */\n    if (options & LYD_DUP_OPT_WITH_PARENTS) {\n        parent = ret;\n        for (elem = node->parent; elem; elem = elem->parent) {\n            new_node = lyd_dup(elem, options & LYD_DUP_OPT_NO_ATTR);\n            LY_CHECK_ERR_GOTO(!new_node, LOGMEM(log_ctx), error);\n\n            /* dup all list keys */\n            if (new_node->schema->nodetype == LYS_LIST) {\n                slist = (struct lys_node_list *)new_node->schema;\n                for (key = elem->child, i = 0; key && (i < slist->keys_size); ++i, key = key->next) {\n                    if (key->schema != (struct lys_node *)slist->keys[i]) {\n                        LOGVAL(log_ctx, LYE_PATH_INKEY, LY_VLOG_LYD, new_node, slist->keys[i]->name);\n                        goto error;\n                    }\n\n                    key_dup = lyd_dup(key, options & LYD_DUP_OPT_NO_ATTR);\n                    LY_CHECK_ERR_GOTO(!key_dup, LOGMEM(log_ctx), error);\n\n                    if (lyd_insert(new_node, key_dup)) {\n                        lyd_free(key_dup);\n                        goto error;\n                    }\n                }\n                if (!key && (i < slist->keys_size)) {\n                    LOGVAL(log_ctx, LYE_PATH_INKEY, LY_VLOG_LYD, new_node, slist->keys[i]->name);\n                    goto error;\n                }\n            }\n\n            /* link together */\n            if (lyd_insert(new_node, parent)) {\n                ret = parent;\n                goto error;\n            }\n            parent = new_node;\n        }\n    }\n\n    return ret;\n\nerror:\n    lyd_free(ret);\n    return NULL;\n}\n\nAPI struct lyd_node *\nlyd_dup(const struct lyd_node *node, int options)\n{\n    return lyd_dup_to_ctx(node, options, NULL);\n}\n\nstatic struct lyd_node *\nlyd_dup_withsiblings_r(const struct lyd_node *first, struct lyd_node *parent_dup, int options)\n{\n    struct lyd_node *first_dup = NULL, *prev_dup = NULL, *last_dup;\n    const struct lyd_node *next;\n\n    assert(first);\n\n    /* duplicate and connect all siblings */\n    LY_TREE_FOR(first, next) {\n        last_dup = _lyd_dup_node(next, next->schema, next->schema->module->ctx, options);\n        if (!last_dup) {\n            goto error;\n        }\n\n        /* the whole data tree is exactly the same so we can safely copy the validation flags */\n        last_dup->validity = next->validity;\n        last_dup->when_status = next->when_status;\n\n        last_dup->parent = parent_dup;\n        if (!first_dup) {\n            first_dup = last_dup;\n        } else {\n            assert(prev_dup);\n            prev_dup->next = last_dup;\n            last_dup->prev = prev_dup;\n        }\n\n        if ((next->schema->nodetype & (LYS_LIST | LYS_CONTAINER | LYS_RPC | LYS_ACTION | LYS_NOTIF)) && next->child) {\n            /* recursively duplicate all children */\n            if (!lyd_dup_withsiblings_r(next->child, last_dup, options)) {\n                goto error;\n            }\n        }\n\n        prev_dup = last_dup;\n    }\n\n    /* correctly set last sibling and parent child pointer */\n    assert(!prev_dup->next);\n    first_dup->prev = prev_dup;\n    if (parent_dup) {\n        parent_dup->child = first_dup;\n    }\n\n    return first_dup;\n\nerror:\n    /* disconnect and free */\n    first_dup->parent = NULL;\n    lyd_free_withsiblings(first_dup);\n    return NULL;\n}\n\nAPI struct lyd_node *\nlyd_dup_withsiblings(const struct lyd_node *node, int options)\n{\n    const struct lyd_node *iter;\n    struct lyd_node *ret, *ret_iter, *tmp;\n\n    if (!node) {\n        return NULL;\n    }\n\n    /* find first sibling */\n    while (node->prev->next) {\n        node = node->prev;\n    }\n\n    if (node->parent) {\n        ret = lyd_dup(node, options);\n        if (!ret) {\n            return NULL;\n        }\n\n        /* copy following siblings */\n        ret_iter = ret;\n        LY_TREE_FOR(node->next, iter) {\n            tmp = lyd_dup(iter, options);\n            if (!tmp) {\n                lyd_free_withsiblings(ret);\n                return NULL;\n            }\n\n            if (lyd_insert_after(ret_iter, tmp)) {\n                lyd_free_withsiblings(ret);\n                return NULL;\n            }\n            ret_iter = ret_iter->next;\n            assert(ret_iter == tmp);\n        }\n    } else {\n        /* duplicating top-level siblings, we can duplicate much more efficiently */\n        ret = lyd_dup_withsiblings_r(node, NULL, options);\n    }\n\n    return ret;\n}\n\nAPI void\nlyd_free_attr(struct ly_ctx *ctx, struct lyd_node *parent, struct lyd_attr *attr, int recursive)\n{\n    struct lyd_attr *iter;\n    struct lys_type **type;\n\n    if (!ctx || !attr) {\n        return;\n    }\n\n    if (parent) {\n        if (parent->attr == attr) {\n            if (recursive) {\n                parent->attr = NULL;\n            } else {\n                parent->attr = attr->next;\n            }\n        } else {\n            for (iter = parent->attr; iter->next != attr; iter = iter->next);\n            if (iter->next) {\n                if (recursive) {\n                    iter->next = NULL;\n                } else {\n                    iter->next = attr->next;\n                }\n            }\n        }\n    }\n\n    if (!recursive) {\n        attr->next = NULL;\n    }\n\n    for(iter = attr; iter; ) {\n        attr = iter;\n        iter = iter->next;\n\n        lydict_remove(ctx, attr->name);\n        type = lys_ext_complex_get_substmt(LY_STMT_TYPE, attr->annotation, NULL);\n        assert(type);\n        lyd_free_value(attr->value, attr->value_type, attr->value_flags, *type, NULL, NULL, NULL);\n        lydict_remove(ctx, attr->value_str);\n        free(attr);\n    }\n}\n\nconst struct lyd_node *\nlyd_attr_parent(const struct lyd_node *root, struct lyd_attr *attr)\n{\n    const struct lyd_node *next, *elem;\n    struct lyd_attr *node_attr;\n\n    LY_TREE_DFS_BEGIN(root, next, elem) {\n        for (node_attr = elem->attr; node_attr; node_attr = node_attr->next) {\n            if (node_attr == attr) {\n                return elem;\n            }\n        }\n        LY_TREE_DFS_END(root, next, elem)\n    }\n\n    return NULL;\n}\n\nAPI struct lyd_attr *\nlyd_insert_attr(struct lyd_node *parent, const struct lys_module *mod, const char *name, const char *value)\n{\n    struct lyd_attr *a, *iter;\n    struct ly_ctx *ctx;\n    const struct lys_module *module;\n    const char *p;\n    char *aux;\n    int pos, i;\n\n    if (!parent || !name || !value) {\n        LOGARG;\n        return NULL;\n    }\n    ctx = parent->schema->module->ctx;\n\n    if ((p = strchr(name, ':'))) {\n        /* search for the namespace */\n        aux = strndup(name, p - name);\n        if (!aux) {\n            LOGMEM(ctx);\n            return NULL;\n        }\n        module = ly_ctx_get_module(ctx, aux, NULL, 1);\n        free(aux);\n        name = p + 1;\n\n        if (!module) {\n            /* module not found */\n            LOGERR(ctx, LY_EINVAL, \"Attribute prefix does not match any implemented schema in the context.\");\n            return NULL;\n        }\n    } else if (mod) {\n        module = mod;\n    } else if (!mod && (!strcmp(name, \"type\") || !strcmp(name, \"select\")) && !strcmp(parent->schema->name, \"filter\")) {\n        /* special case of inserting unqualified filter attributes \"type\" and \"select\" */\n        module = ly_ctx_get_module(ctx, \"ietf-netconf\", NULL, 1);\n        if (!module) {\n            LOGERR(ctx, LY_EINVAL, \"Attribute prefix does not match any implemented schema in the context.\");\n            return NULL;\n        }\n    } else {\n        /* no prefix -> module is the same as for the parent */\n        module = lyd_node_module(parent);\n    }\n\n    pos = -1;\n    do {\n        if ((unsigned int)(pos + 1) < module->ext_size) {\n            i = lys_ext_instance_presence(&ctx->models.list[0]->extensions[0],\n                                          &module->ext[pos + 1], module->ext_size - (pos + 1));\n            pos = (i == -1) ? -1 : pos + 1 + i;\n        } else {\n            pos = -1;\n        }\n        if (pos == -1) {\n            LOGERR(ctx, LY_EINVAL, \"Attribute does not match any annotation instance definition.\");\n            return NULL;\n        }\n    } while (!ly_strequal(module->ext[pos]->arg_value, name, 0));\n\n    a = calloc(1, sizeof *a);\n    LY_CHECK_ERR_RETURN(!a, LOGMEM(ctx), NULL);\n    a->parent = parent;\n    a->next = NULL;\n    a->annotation = (struct lys_ext_instance_complex *)module->ext[pos];\n    a->name = lydict_insert(ctx, name, 0);\n    a->value_str = lydict_insert(ctx, value, 0);\n    if (!lyp_parse_value(*((struct lys_type **)lys_ext_complex_get_substmt(LY_STMT_TYPE, a->annotation, NULL)),\n                         &a->value_str, NULL, NULL, a, NULL, 1, 0, 0)) {\n        lyd_free_attr(ctx, NULL, a, 0);\n        return NULL;\n    }\n\n    if (!parent->attr) {\n        parent->attr = a;\n    } else {\n        for (iter = parent->attr; iter->next; iter = iter->next);\n        iter->next = a;\n    }\n\n    return a;\n}\n\nvoid\nlyd_free_value(lyd_val value, LY_DATA_TYPE value_type, uint8_t value_flags, struct lys_type *type, lyd_val *old_val,\n               LY_DATA_TYPE *old_val_type, uint8_t *old_val_flags)\n{\n    if (old_val) {\n        *old_val = value;\n        *old_val_type = value_type;\n        *old_val_flags = value_flags;\n        /* we only backup the values for now */\n        return;\n    }\n\n    /* otherwise the value is correctly freed */\n    if (value_flags & LY_VALUE_USER) {\n        assert(type->der && type->der->module);\n        lytype_free(type->der->module, type->der->name, value);\n    } else {\n        switch (value_type) {\n        case LY_TYPE_BITS:\n            if (value.bit) {\n                free(value.bit);\n            }\n            break;\n        case LY_TYPE_INST:\n            if (!(value_flags & LY_VALUE_UNRES)) {\n                break;\n            }\n            /* fallthrough */\n        case LY_TYPE_UNION:\n            /* unresolved union leaf */\n            lydict_remove(type->parent->module->ctx, value.string);\n            break;\n        default:\n            break;\n        }\n    }\n}\n\nstatic void\n_lyd_free_node(struct lyd_node *node)\n{\n    struct lyd_node_leaf_list *leaf;\n\n    if (!node) {\n        return;\n    }\n\n    switch (node->schema->nodetype) {\n    case LYS_CONTAINER:\n    case LYS_LIST:\n    case LYS_RPC:\n    case LYS_ACTION:\n    case LYS_NOTIF:\n#ifdef LY_ENABLED_CACHE\n        /* it should be empty because all the children are freed already (only if in debug mode) */\n        lyht_free(node->ht);\n#endif\n        break;\n    case LYS_ANYDATA:\n    case LYS_ANYXML:\n        switch (((struct lyd_node_anydata *)node)->value_type) {\n        case LYD_ANYDATA_CONSTSTRING:\n        case LYD_ANYDATA_SXML:\n        case LYD_ANYDATA_JSON:\n            lydict_remove(node->schema->module->ctx, ((struct lyd_node_anydata *)node)->value.str);\n            break;\n        case LYD_ANYDATA_DATATREE:\n            lyd_free_withsiblings(((struct lyd_node_anydata *)node)->value.tree);\n            break;\n        case LYD_ANYDATA_XML:\n            lyxml_free_withsiblings(node->schema->module->ctx, ((struct lyd_node_anydata *)node)->value.xml);\n            break;\n        case LYD_ANYDATA_LYB:\n            free(((struct lyd_node_anydata *)node)->value.mem);\n            break;\n        case LYD_ANYDATA_STRING:\n        case LYD_ANYDATA_SXMLD:\n        case LYD_ANYDATA_JSOND:\n        case LYD_ANYDATA_LYBD:\n            /* dynamic strings are used only as input parameters */\n            assert(0);\n            break;\n        }\n        break;\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n        leaf = (struct lyd_node_leaf_list *)node;\n        lyd_free_value(leaf->value, leaf->value_type, leaf->value_flags, &((struct lys_node_leaf *)leaf->schema)->type,\n                       NULL, NULL, NULL);\n        lydict_remove(leaf->schema->module->ctx, leaf->value_str);\n        break;\n    default:\n        assert(0);\n    }\n\n    lyd_free_attr(node->schema->module->ctx, node, node->attr, 1);\n    free(node);\n}\n\nstatic void\nlyd_free_internal_r(struct lyd_node *node, int top)\n{\n    struct lyd_node *next, *iter;\n\n    if (!node) {\n        return;\n    }\n\n    /* if freeing top-level, always remove it from the parent hash table */\n    lyd_unlink_internal(node, (top ? 1 : 2));\n\n    if (!(node->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA))) {\n        /* free children */\n        LY_TREE_FOR_SAFE(node->child, next, iter) {\n            lyd_free_internal_r(iter, 0);\n        }\n    }\n\n    _lyd_free_node(node);\n}\n\nAPI void\nlyd_free(struct lyd_node *node)\n{\n    lyd_free_internal_r(node, 1);\n}\n\nstatic void\nlyd_free_withsiblings_r(struct lyd_node *first)\n{\n    struct lyd_node *next, *node;\n\n    LY_TREE_FOR_SAFE(first, next, node) {\n        if (node->schema->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_RPC | LYS_ACTION | LYS_NOTIF)) {\n            lyd_free_withsiblings_r(node->child);\n        }\n        _lyd_free_node(node);\n    }\n}\n\nAPI void\nlyd_free_withsiblings(struct lyd_node *node)\n{\n    struct lyd_node *iter, *aux;\n\n    if (!node) {\n        return;\n    }\n\n    if (node->parent) {\n        /* optimization - avoid freeing (unlinking) the last node of the siblings list */\n        /* so, first, free the node's predecessors to the beginning of the list ... */\n        for(iter = node->prev; iter->next; iter = aux) {\n            aux = iter->prev;\n            lyd_free(iter);\n        }\n        /* ... then, the node is the first in the siblings list, so free them all */\n        LY_TREE_FOR_SAFE(node, aux, iter) {\n            lyd_free(iter);\n        }\n    } else {\n        /* node is top-level so we are freeing the whole data tree, we can just free nodes without any unlinking */\n        while (node->prev->next) {\n            /* find the first sibling */\n            node = node->prev;\n        }\n\n        /* free it all */\n        lyd_free_withsiblings_r(node);\n    }\n}\n\n/**\n * Expectations:\n * - list exists in data tree\n * - the leaf (defined by the unique_expr) is not instantiated under the list\n */\nint\nlyd_get_unique_default(const char* unique_expr, struct lyd_node *list, const char **dflt)\n{\n    struct ly_ctx *ctx = list->schema->module->ctx;\n    const struct lys_node *parent;\n    const struct lys_node_leaf *sleaf = NULL;\n    struct lys_tpdf *tpdf;\n    struct lyd_node *last, *node;\n    struct ly_set *s, *r;\n    unsigned int i;\n    enum int_log_opts prev_ilo;\n\n    assert(unique_expr && list && dflt);\n    *dflt = NULL;\n\n    if (resolve_descendant_schema_nodeid(unique_expr, list->schema->child, LYS_LEAF, 1, &parent) || !parent) {\n        /* error, but unique expression was checked when the schema was parsed so this should not happened */\n        LOGINT(ctx);\n        return -1;\n    }\n\n    sleaf = (struct lys_node_leaf *)parent;\n    if (sleaf->dflt) {\n        /* leaf has a default value */\n        *dflt = sleaf->dflt;\n    } else if (!(sleaf->flags & LYS_MAND_TRUE)) {\n        /* get the default value from the type */\n        for (tpdf = sleaf->type.der; tpdf && !(*dflt); tpdf = tpdf->type.der) {\n            *dflt = tpdf->dflt;\n        }\n    }\n\n    if (!(*dflt)) {\n        return 0;\n    }\n\n    /* it has default value, but check if it can appear in the data tree under the list */\n    s = ly_set_new();\n    for (parent = lys_parent((struct lys_node *)sleaf); parent != list->schema; parent = lys_parent(parent)) {\n        if (!(parent->nodetype & (LYS_CONTAINER | LYS_CASE | LYS_CHOICE | LYS_USES))) {\n            /* This should be already detected when parsing schema */\n            LOGINT(ctx);\n            ly_set_free(s);\n            return -1;\n        }\n        ly_set_add(s, (void *)parent, LY_SET_OPT_USEASLIST);\n    }\n\n    ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n    for (i = 0, last = list; i < s->number; i++) {\n        parent = s->set.s[i]; /* shortcut */\n\n        switch (parent->nodetype) {\n        case LYS_CONTAINER:\n            if (last) {\n                /* find instance in the data */\n                r = lyd_find_path(last, parent->name);\n                if (!r || r->number > 1) {\n                    ly_set_free(r);\n                    *dflt = NULL;\n                    goto end;\n                }\n                if (r->number) {\n                    last = r->set.d[0];\n                } else {\n                    last = NULL;\n                }\n                ly_set_free(r);\n            }\n            if (((struct lys_node_container *)parent)->presence) {\n                /* not-instantiated presence container on path */\n                *dflt = NULL;\n                goto end;\n            }\n            break;\n        case LYS_CHOICE :\n            /* check presence of another case */\n            if (!last) {\n                continue;\n            }\n\n            /* remember the case to be searched in choice by lyv_multicases() */\n            if (i + 1 == s->number) {\n                parent = (struct lys_node *)sleaf;\n            } else if (s->set.s[i + 1]->nodetype == LYS_CASE && (i + 2 < s->number) &&\n                    s->set.s[i + 2]->nodetype == LYS_CHOICE) {\n                /* nested choices are covered by lyv_multicases, we just have to pass\n                 * the lowest choice */\n                i++;\n                continue;\n            } else {\n                parent = s->set.s[i + 1];\n            }\n            node = last->child;\n            if (lyv_multicases(NULL, (struct lys_node *)parent, &node, 0, NULL)) {\n                /* another case is present */\n                *dflt = NULL;\n                goto end;\n            }\n            break;\n        default:\n            /* LYS_CASE, LYS_USES */\n            continue;\n        }\n    }\n\nend:\n    ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n    ly_set_free(s);\n    return 0;\n}\n\nAPI char *\nlyd_path(const struct lyd_node *node)\n{\n    char *buf = NULL;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (ly_vlog_build_path(LY_VLOG_LYD, node, &buf, 0, 0)) {\n        return NULL;\n    }\n\n    return buf;\n}\n\nint\nlyd_build_relative_data_path(const struct lys_module *module, const struct lyd_node *node, const char *schema_id,\n                             char *buf)\n{\n    const struct lys_node *snode, *schema;\n    const char *mod_name, *name;\n    int mod_name_len, name_len, len = 0;\n    int r, is_relative = -1;\n\n    assert(schema_id && buf);\n    schema = node->schema;\n\n    while (*schema_id) {\n        if ((r = parse_schema_nodeid(schema_id, &mod_name, &mod_name_len, &name, &name_len, &is_relative, NULL, NULL, 0)) < 1) {\n            LOGINT(module->ctx);\n            return -1;\n        }\n        schema_id += r;\n\n        snode = NULL;\n        while ((snode = lys_getnext(snode, schema, NULL, LYS_GETNEXT_WITHCHOICE | LYS_GETNEXT_WITHCASE | LYS_GETNEXT_NOSTATECHECK))) {\n            r = schema_nodeid_siblingcheck(snode, module, mod_name, mod_name_len, name, name_len);\n            if (r == 0) {\n                schema = snode;\n                break;\n            } else if (r == 1) {\n                continue;\n            } else {\n                return -1;\n            }\n        }\n        /* no match */\n        if (!snode || (!schema_id[0] && snode->nodetype != LYS_LEAF)) {\n            LOGINT(module->ctx);\n            return -1;\n        }\n\n        if (!(snode->nodetype & (LYS_CHOICE | LYS_CASE))) {\n            len += sprintf(&buf[len], \"%s%s\", (len ? \"/\" : \"\"), snode->name);\n        }\n    }\n\n    return len;\n}\n\nAPI struct ly_set *\nlyd_find_path(const struct lyd_node *ctx_node, const char *path)\n{\n    struct lyxp_set xp_set;\n    struct ly_set *set;\n    char *yang_xpath;\n    const char * node_mod_name, *mod_name, *name;\n    int mod_name_len, name_len, is_relative = -1;\n    uint32_t i;\n\n    if (!ctx_node || !path) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (parse_schema_nodeid(path, &mod_name, &mod_name_len, &name, &name_len, &is_relative, NULL, NULL, 1) > 0) {\n        if (name[0] == '#' && !is_relative) {\n            node_mod_name = lyd_node_module(ctx_node)->name;\n            if (strncmp(mod_name, node_mod_name, mod_name_len) || node_mod_name[mod_name_len]) {\n                return NULL;\n            }\n            path = name + name_len;\n        }\n    }\n\n    /* transform JSON into YANG XPATH */\n    yang_xpath = transform_json2xpath(lyd_node_module(ctx_node), path);\n    if (!yang_xpath) {\n        return NULL;\n    }\n\n    memset(&xp_set, 0, sizeof xp_set);\n\n    if (lyxp_eval(yang_xpath, ctx_node, LYXP_NODE_ELEM, lyd_node_module(ctx_node), &xp_set, 0) != EXIT_SUCCESS) {\n        free(yang_xpath);\n        return NULL;\n    }\n    free(yang_xpath);\n\n    set = ly_set_new();\n    LY_CHECK_ERR_RETURN(!set, LOGMEM(ctx_node->schema->module->ctx), NULL);\n\n    if (xp_set.type == LYXP_SET_NODE_SET) {\n        for (i = 0; i < xp_set.used; ++i) {\n            if (xp_set.val.nodes[i].type == LYXP_NODE_ELEM) {\n                if (ly_set_add(set, xp_set.val.nodes[i].node, LY_SET_OPT_USEASLIST) < 0) {\n                    ly_set_free(set);\n                    set = NULL;\n                    break;\n                }\n            }\n        }\n    }\n    /* free xp_set content */\n    lyxp_set_cast(&xp_set, LYXP_SET_EMPTY, ctx_node, NULL, 0);\n\n    return set;\n}\n\nAPI struct ly_set *\nlyd_find_instance(const struct lyd_node *data, const struct lys_node *schema)\n{\n    struct ly_set *ret, *ret_aux, *spath;\n    const struct lys_node *siter;\n    struct lyd_node *iter;\n    unsigned int i, j;\n\n    if (!data || !schema ||\n            !(schema->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_ANYDATA | LYS_NOTIF | LYS_RPC | LYS_ACTION))) {\n        LOGARG;\n        return NULL;\n    }\n\n    ret = ly_set_new();\n    spath = ly_set_new();\n    if (!ret || !spath) {\n        LOGMEM(schema->module->ctx);\n        goto error;\n    }\n\n    /* find data root */\n    while (data->parent) {\n        /* vertical move (up) */\n        data = data->parent;\n    }\n    while (data->prev->next) {\n        /* horizontal move (left) */\n        data = data->prev;\n    }\n\n    /* build schema path */\n    for (siter = schema; siter; ) {\n        if (siter->nodetype == LYS_AUGMENT) {\n            siter = ((struct lys_node_augment *)siter)->target;\n            continue;\n        } else if (siter->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_ANYDATA | LYS_NOTIF | LYS_RPC | LYS_ACTION)) {\n            /* standard data node */\n            ly_set_add(spath, (void*)siter, LY_SET_OPT_USEASLIST);\n\n        } /* else skip the rest node types */\n        siter = siter->parent;\n    }\n    if (!spath->number) {\n        /* no valid path */\n        goto error;\n    }\n\n    /* start searching */\n    LY_TREE_FOR((struct lyd_node *)data, iter) {\n        if (iter->schema == spath->set.s[spath->number - 1]) {\n            ly_set_add(ret, iter, LY_SET_OPT_USEASLIST);\n        }\n    }\n    for (i = spath->number - 1; i; i--) {\n        if (!ret->number) {\n            /* nothing found */\n            break;\n        }\n\n        ret_aux = ly_set_new();\n        if (!ret_aux) {\n            LOGMEM(schema->module->ctx);\n            goto error;\n        }\n        for (j = 0; j < ret->number; j++) {\n            LY_TREE_FOR(ret->set.d[j]->child, iter) {\n                if (iter->schema == spath->set.s[i - 1]) {\n                    ly_set_add(ret_aux, iter, LY_SET_OPT_USEASLIST);\n                }\n            }\n        }\n        ly_set_free(ret);\n        ret = ret_aux;\n    }\n\n    ly_set_free(spath);\n    return ret;\n\nerror:\n    ly_set_free(ret);\n    ly_set_free(spath);\n\n    return NULL;\n}\n\nAPI struct lyd_node *\nlyd_first_sibling(struct lyd_node *node)\n{\n    struct lyd_node *start;\n\n    if (!node) {\n        return NULL;\n    }\n\n    /* get the first sibling */\n    if (node->parent) {\n        start = node->parent->child;\n    } else {\n        for (start = node; start->prev->next; start = start->prev);\n    }\n\n    return start;\n}\n\nAPI struct ly_set *\nly_set_new(void)\n{\n    struct ly_set *new;\n\n    new = calloc(1, sizeof(struct ly_set));\n    LY_CHECK_ERR_RETURN(!new, LOGMEM(NULL), NULL);\n    return new;\n}\n\nAPI void\nly_set_free(struct ly_set *set)\n{\n    if (!set) {\n        return;\n    }\n\n    free(set->set.g);\n    free(set);\n}\n\nAPI int\nly_set_contains(const struct ly_set *set, void *node)\n{\n    unsigned int i;\n\n    if (!set) {\n        return -1;\n    }\n\n    for (i = 0; i < set->number; i++) {\n        if (set->set.g[i] == node) {\n            /* object found */\n            return i;\n        }\n    }\n\n    /* object not found */\n    return -1;\n}\n\nAPI struct ly_set *\nly_set_dup(const struct ly_set *set)\n{\n    struct ly_set *new;\n\n    if (!set) {\n        return NULL;\n    }\n\n    new = malloc(sizeof *new);\n    LY_CHECK_ERR_RETURN(!new, LOGMEM(NULL), NULL);\n    new->number = set->number;\n    new->size = set->size;\n    new->set.g = malloc(new->size * sizeof *(new->set.g));\n    LY_CHECK_ERR_RETURN(!new->set.g, LOGMEM(NULL); free(new), NULL);\n    memcpy(new->set.g, set->set.g, new->size * sizeof *(new->set.g));\n\n    return new;\n}\n\nAPI int\nly_set_add(struct ly_set *set, void *node, int options)\n{\n    unsigned int i;\n    void **new;\n\n    if (!set || !node) {\n        LOGARG;\n        return -1;\n    }\n\n    if (!(options & LY_SET_OPT_USEASLIST)) {\n        /* search for duplication */\n        for (i = 0; i < set->number; i++) {\n            if (set->set.g[i] == node) {\n                /* already in set */\n                return i;\n            }\n        }\n    }\n\n    if (set->size == set->number) {\n        new = realloc(set->set.g, (set->size + 8) * sizeof *(set->set.g));\n        LY_CHECK_ERR_RETURN(!new, LOGMEM(NULL), -1);\n        set->size += 8;\n        set->set.g = new;\n    }\n\n    set->set.g[set->number++] = node;\n\n    return set->number - 1;\n}\n\nAPI int\nly_set_merge(struct ly_set *trg, struct ly_set *src, int options)\n{\n    unsigned int i, ret;\n    void **new;\n\n    if (!trg) {\n        LOGARG;\n        return -1;\n    }\n\n    if (!src) {\n        return 0;\n    }\n\n    if (!(options & LY_SET_OPT_USEASLIST)) {\n        /* remove duplicates */\n        i = 0;\n        while (i < src->number) {\n            if (ly_set_contains(trg, src->set.g[i]) > -1) {\n                ly_set_rm_index(src, i);\n            } else {\n                ++i;\n            }\n        }\n    }\n\n    /* allocate more memory if needed */\n    if (trg->size < trg->number + src->number) {\n        new = realloc(trg->set.g, (trg->number + src->number) * sizeof *(trg->set.g));\n        LY_CHECK_ERR_RETURN(!new, LOGMEM(NULL), -1);\n        trg->size = trg->number + src->number;\n        trg->set.g = new;\n    }\n\n    /* copy contents from src into trg */\n    memcpy(trg->set.g + trg->number, src->set.g, src->number * sizeof *(src->set.g));\n    ret = src->number;\n    trg->number += ret;\n\n    /* cleanup */\n    ly_set_free(src);\n    return ret;\n}\n\nAPI int\nly_set_rm_index(struct ly_set *set, unsigned int index)\n{\n    if (!set || (index + 1) > set->number) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    if (index == set->number - 1) {\n        /* removing last item in set */\n        set->set.g[index] = NULL;\n    } else {\n        /* removing item somewhere in a middle, so put there the last item */\n        set->set.g[index] = set->set.g[set->number - 1];\n        set->set.g[set->number - 1] = NULL;\n    }\n    set->number--;\n\n    return EXIT_SUCCESS;\n}\n\nAPI int\nly_set_rm(struct ly_set *set, void *node)\n{\n    unsigned int i;\n\n    if (!set || !node) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    /* get index */\n    for (i = 0; i < set->number; i++) {\n        if (set->set.g[i] == node) {\n            break;\n        }\n    }\n    if (i == set->number) {\n        /* node is not in set */\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    return ly_set_rm_index(set, i);\n}\n\nAPI int\nly_set_clean(struct ly_set *set)\n{\n    if (!set) {\n        return EXIT_FAILURE;\n    }\n\n    set->number = 0;\n    return EXIT_SUCCESS;\n}\n\nAPI int\nlyd_wd_default(struct lyd_node_leaf_list *node)\n{\n    struct lys_node_leaf *leaf;\n    struct lys_node_leaflist *llist;\n    struct lyd_node *iter;\n    struct lys_tpdf *tpdf;\n    const char *dflt = NULL, **dflts = NULL;\n    uint8_t dflts_size = 0, c, i;\n\n    if (!node || !(node->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n        return 0;\n    }\n\n    if (node->dflt) {\n        return 1;\n    }\n\n    if (node->schema->nodetype == LYS_LEAF) {\n        leaf = (struct lys_node_leaf *)node->schema;\n\n        /* get know if there is a default value */\n        if (leaf->dflt) {\n            /* leaf has a default value */\n            dflt = leaf->dflt;\n        } else if (!(leaf->flags & LYS_MAND_TRUE)) {\n            /* get the default value from the type */\n            for (tpdf = leaf->type.der; tpdf && !dflt; tpdf = tpdf->type.der) {\n                dflt = tpdf->dflt;\n            }\n        }\n        if (!dflt) {\n            /* no default value */\n            return 0;\n        }\n\n        /* compare the default value with the value of the leaf */\n        if (!ly_strequal(dflt, node->value_str, 1)) {\n            return 0;\n        }\n    } else if (node->schema->module->version >= LYS_VERSION_1_1) { /* LYS_LEAFLIST */\n        llist = (struct lys_node_leaflist *)node->schema;\n\n        /* get know if there is a default value */\n        if (llist->dflt_size) {\n            /* there are default values */\n            dflts_size = llist->dflt_size;\n            dflts = llist->dflt;\n        } else if (!llist->min) {\n            /* get the default value from the type */\n            for (tpdf = llist->type.der; tpdf && !dflts; tpdf = tpdf->type.der) {\n                if (tpdf->dflt) {\n                    dflts = &tpdf->dflt;\n                    dflts_size = 1;\n                    break;\n                }\n            }\n        }\n\n        if (!dflts_size) {\n            /* no default values to use */\n            return 0;\n        }\n\n        /* compare the default value with the value of the leaf */\n        /* first, find the first leaf-list's sibling */\n        iter = (struct lyd_node *)node;\n        if (iter->parent) {\n            iter = iter->parent->child;\n        } else {\n            for (; iter->prev->next; iter = iter->prev);\n        }\n        for (c = 0; iter; iter = iter->next) {\n            if (iter->schema != node->schema) {\n                continue;\n            }\n            if (c == dflts_size) {\n                /* to many leaf-list instances */\n                return 0;\n            }\n\n            if (llist->flags & LYS_USERORDERED) {\n                /* we have strict order */\n                if (!ly_strequal(dflts[c], ((struct lyd_node_leaf_list *)iter)->value_str, 1)) {\n                    return 0;\n                }\n            } else {\n                /* node's value is supposed to match with one of the default values */\n                for (i = 0; i < dflts_size; i++) {\n                    if (ly_strequal(dflts[i], ((struct lyd_node_leaf_list *)iter)->value_str, 1)) {\n                        break;\n                    }\n                }\n                if (i == dflts_size) {\n                    /* values do not match */\n                    return 0;\n                }\n            }\n            c++;\n        }\n        if (c != dflts_size) {\n            /* different sets of leaf-list instances */\n            return 0;\n        }\n    } else {\n        return 0;\n    }\n\n    /* all checks ok */\n    return 1;\n}\n\nint\nunres_data_diff_new(struct unres_data *unres, struct lyd_node *subtree, struct lyd_node *parent, int created)\n{\n    char *parent_xpath = NULL;\n\n    if (created) {\n        return lyd_difflist_add(unres->diff, &unres->diff_size, unres->diff_idx++, LYD_DIFF_CREATED, NULL, subtree);\n    } else {\n        if (parent) {\n            parent_xpath = lyd_path(parent);\n            LY_CHECK_ERR_RETURN(!parent_xpath, LOGMEM(lyd_node_module(subtree)->ctx), -1);\n        }\n        return lyd_difflist_add(unres->diff, &unres->diff_size, unres->diff_idx++, LYD_DIFF_DELETED,\n                                subtree, (struct lyd_node *)parent_xpath);\n    }\n}\n\nvoid\nunres_data_diff_rem(struct unres_data *unres, unsigned int idx)\n{\n    if (unres->diff->type[idx] == LYD_DIFF_DELETED) {\n        lyd_free_withsiblings(unres->diff->first[idx]);\n        free(unres->diff->second[idx]);\n    }\n\n    /* replace by last real value */\n    if (idx < unres->diff_idx - 1) {\n        unres->diff->type[idx] = unres->diff->type[unres->diff_idx - 1];\n        unres->diff->first[idx] = unres->diff->first[unres->diff_idx - 1];\n        unres->diff->second[idx] = unres->diff->second[unres->diff_idx - 1];\n    }\n\n    /* move the end */\n    assert(unres->diff->type[unres->diff_idx] == LYD_DIFF_END);\n    unres->diff->type[unres->diff_idx - 1] = unres->diff->type[unres->diff_idx];\n    --unres->diff_idx;\n}\n\nAPI void\nlyd_free_val_diff(struct lyd_difflist *diff)\n{\n    uint32_t i;\n\n    if (!diff) {\n        return;\n    }\n\n    for (i = 0; diff->type[i] != LYD_DIFF_END; ++i) {\n        switch (diff->type[i]) {\n        case LYD_DIFF_CREATED:\n            free(diff->first[i]);\n            lyd_free_withsiblings(diff->second[i]);\n            break;\n        case LYD_DIFF_DELETED:\n            lyd_free_withsiblings(diff->first[i]);\n            free(diff->second[i]);\n            break;\n        default:\n            /* what to do? */\n            break;\n        }\n    }\n\n    lyd_free_diff(diff);\n}\n\nstatic int\nlyd_wd_add_leaf(struct lyd_node **tree, struct lyd_node *last_parent, struct lys_node_leaf *leaf, struct unres_data *unres,\n                int check_when_must)\n{\n    struct lyd_node *dummy = NULL, *current;\n    struct lys_tpdf *tpdf;\n    const char *dflt = NULL;\n    int ret;\n\n    /* get know if there is a default value */\n    if (leaf->dflt) {\n        /* leaf has a default value */\n        dflt = leaf->dflt;\n    } else if (!(leaf->flags & LYS_MAND_TRUE)) {\n        /* get the default value from the type */\n        for (tpdf = leaf->type.der; tpdf && !dflt; tpdf = tpdf->type.der) {\n            dflt = tpdf->dflt;\n        }\n    }\n    if (!dflt) {\n        /* no default value */\n        return EXIT_SUCCESS;\n    }\n\n    /* create the node */\n    if (!(dummy = lyd_new_dummy(*tree, last_parent, (struct lys_node*)leaf, dflt, 1))) {\n        goto error;\n    }\n\n    if (unres->store_diff) {\n        /* remember this subtree in the diff */\n        if (unres_data_diff_new(unres, dummy, NULL, 1)) {\n            goto error;\n        }\n    }\n\n    if (!dummy->parent && (*tree)) {\n        /* connect dummy nodes into the data tree (at the end of top level nodes) */\n        if (lyd_insert_sibling(tree, dummy)) {\n            goto error;\n        }\n    }\n    for (current = dummy; ; current = current->child) {\n        /* remember the created data in unres */\n        if (check_when_must) {\n            if ((current->when_status & LYD_WHEN) && unres_data_add(unres, current, UNRES_WHEN) == -1) {\n                goto error;\n            }\n            if (check_when_must == 2) {\n                ret = resolve_applies_must(current);\n                if ((ret & 0x1) && (unres_data_add(unres, current, UNRES_MUST) == -1)) {\n                    goto error;\n                }\n                if ((ret & 0x2) && (unres_data_add(unres, current, UNRES_MUST_INOUT) == -1)) {\n                    goto error;\n                }\n            }\n        }\n\n        /* clear dummy-node flag */\n        current->validity &= ~LYD_VAL_INUSE;\n\n        if (current->schema == (struct lys_node *)leaf) {\n            break;\n        }\n    }\n    /* update parent's default flag if needed */\n    lyd_wd_update_parents(dummy);\n\n    /* if necessary, remember the created data value in unres */\n    if (((struct lyd_node_leaf_list *)current)->value_type == LY_TYPE_LEAFREF) {\n        if (unres_data_add(unres, current, UNRES_LEAFREF)) {\n            goto error;\n        }\n    } else if (((struct lyd_node_leaf_list *)current)->value_type == LY_TYPE_INST) {\n        if (unres_data_add(unres, current, UNRES_INSTID)) {\n            goto error;\n        }\n    }\n\n    if (!(*tree)) {\n        *tree = dummy;\n    }\n    return EXIT_SUCCESS;\n\nerror:\n    lyd_free(dummy);\n    return EXIT_FAILURE;\n}\n\nstatic int\nlyd_wd_add_leaflist(struct lyd_node **tree, struct lyd_node *last_parent, struct lys_node_leaflist *llist,\n                    struct unres_data *unres, int check_when_must)\n{\n    struct lyd_node *dummy, *current, *first = NULL;\n    struct lys_tpdf *tpdf;\n    const char **dflt = NULL;\n    uint8_t dflt_size = 0;\n    int i, ret;\n\n    if (llist->module->version < LYS_VERSION_1_1) {\n        /* default values on leaf-lists are allowed from YANG 1.1 */\n        return EXIT_SUCCESS;\n    }\n\n    /* get know if there is a default value */\n    if (llist->dflt_size) {\n        /* there are default values */\n        dflt_size = llist->dflt_size;\n        dflt = llist->dflt;\n    } else if (!llist->min) {\n        /* get the default value from the type */\n        for (tpdf = llist->type.der; tpdf && !dflt; tpdf = tpdf->type.der) {\n            if (tpdf->dflt) {\n                dflt = &tpdf->dflt;\n                dflt_size = 1;\n                break;\n            }\n        }\n    }\n\n    if (!dflt_size) {\n        /* no default values to use */\n        return EXIT_SUCCESS;\n    }\n\n    for (i = 0; i < dflt_size; i++) {\n        /* create the node */\n        if (!(dummy = lyd_new_dummy(*tree, last_parent, (struct lys_node*)llist, dflt[i], 1))) {\n            goto error;\n        }\n\n        if (unres->store_diff) {\n            /* remember this subtree in the diff */\n            if (unres_data_diff_new(unres, dummy, NULL, 1)) {\n                goto error;\n            }\n        }\n\n        if (!first) {\n            first = dummy;\n        } else if (!dummy->parent) {\n            /* interconnect with the rest of leaf-lists */\n            first->prev->next = dummy;\n            dummy->prev = first->prev;\n            first->prev = dummy;\n        }\n\n        for (current = dummy; ; current = current->child) {\n            /* remember the created data in unres */\n            if (check_when_must) {\n                if ((current->when_status & LYD_WHEN) && unres_data_add(unres, current, UNRES_WHEN) == -1) {\n                    goto error;\n                }\n                if (check_when_must == 2) {\n                    ret = resolve_applies_must(current);\n                    if ((ret & 0x1) && (unres_data_add(unres, current, UNRES_MUST) == -1)) {\n                        goto error;\n                    }\n                    if ((ret & 0x2) && (unres_data_add(unres, current, UNRES_MUST_INOUT) == -1)) {\n                        goto error;\n                    }\n                }\n            }\n\n            /* clear dummy-node flag */\n            current->validity &= ~LYD_VAL_INUSE;\n\n            if (current->schema == (struct lys_node *)llist) {\n                break;\n            }\n        }\n\n        /* if necessary, remember the created data value in unres */\n        if (((struct lyd_node_leaf_list *)current)->value_type == LY_TYPE_LEAFREF) {\n            if (unres_data_add(unres, current, UNRES_LEAFREF)) {\n                goto error;\n            }\n        } else if (((struct lyd_node_leaf_list *)current)->value_type == LY_TYPE_INST) {\n            if (unres_data_add(unres, current, UNRES_INSTID)) {\n                goto error;\n            }\n        }\n    }\n\n    /* insert into the tree */\n    if (first && !first->parent && (*tree)) {\n        /* connect dummy nodes into the data tree (at the end of top level nodes) */\n        if (lyd_insert_sibling(tree, first)) {\n            goto error;\n        }\n    } else if (!(*tree)) {\n        *tree = first;\n    }\n\n    /* update parent's default flag if needed */\n    lyd_wd_update_parents(first);\n\n    return EXIT_SUCCESS;\n\nerror:\n    lyd_free_withsiblings(first);\n    return EXIT_FAILURE;\n}\n\nstatic void\nlyd_wd_leaflist_cleanup(struct ly_set *set, struct unres_data *unres)\n{\n    unsigned int i;\n\n    assert(set);\n\n    /* if there is an instance without the dflt flag, we have to\n     * remove all instances with the flag - an instance could be\n     * explicitely added, so the default leaflists were invalidated */\n    for (i = 0; i < set->number; i++) {\n        if (!set->set.d[i]->dflt) {\n            break;\n        }\n    }\n    if (i < set->number) {\n        for (i = 0; i < set->number; i++) {\n            if (set->set.d[i]->dflt) {\n                /* remove this default instance */\n                if (unres->store_diff) {\n                    /* just move it to diff if is being generated */\n                    unres_data_diff_new(unres, set->set.d[i], set->set.d[i]->parent, 0);\n                    lyd_unlink(set->set.d[i]);\n                } else {\n                    lyd_free(set->set.d[i]);\n                }\n            }\n        }\n    }\n}\n\n/**\n * @brief Process (add/clean flags) default nodes in the schema subtree\n *\n * @param[in,out] root Pointer to the root node of the complete data tree, the root node can be NULL if the data tree\n *                     is empty\n * @param[in] last_parent The closest parent in the data tree to the currently processed \\p schema node\n * @param[in] subroot  The root node of a data subtree, the node is instance of the \\p schema node, NULL in case the\n *                     schema node is not instantiated in the data tree\n * @param[in] schema The schema node to be processed\n * @param[in] toplevel Flag for processing top level schema nodes when \\p last_parent and \\p subroot are consider as\n *                     unknown\n * @param[in] options  Parser options to know the data tree type, see @ref parseroptions.\n * @param[in] unres    Unresolved data list, the newly added default nodes may need to add some unresolved items\n * @return EXIT_SUCCESS or EXIT_FAILURE\n */\nstatic int\nlyd_wd_add_subtree(struct lyd_node **root, struct lyd_node *last_parent, struct lyd_node *subroot,\n                   struct lys_node *schema, int toplevel, int options, struct unres_data *unres)\n{\n    struct ly_set *present = NULL;\n    struct lys_node *siter, *siter_prev;\n    struct lyd_node *iter;\n    int i, check_when_must, storing_diff = 0;\n\n    assert(root);\n\n    if ((options & LYD_OPT_TYPEMASK) && (schema->flags & LYS_CONFIG_R)) {\n        /* non LYD_OPT_DATA tree, status data are not expected here */\n        return EXIT_SUCCESS;\n    }\n\n    if (options & (LYD_OPT_NOTIF_FILTER | LYD_OPT_EDIT | LYD_OPT_GET | LYD_OPT_GETCONFIG)) {\n        check_when_must = 0; /* check neither */\n    } else if (options & LYD_OPT_TRUSTED) {\n        check_when_must = 1; /* check only when */\n    } else {\n        check_when_must = 2; /* check both when and must */\n    }\n\n    if (toplevel && (schema->nodetype & (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER))) {\n        /* search for the schema node instance */\n        present = ly_set_new();\n        if (!present) {\n            goto error;\n        }\n        if ((*root) && lyd_get_node_siblings(*root, schema, present)) {\n            /* there are some instances */\n            for (i = 0; i < (signed)present->number; i++) {\n                if (schema->nodetype & LYS_LEAFLIST) {\n                    lyd_wd_leaflist_cleanup(present, unres);\n                } else if (schema->nodetype != LYS_LEAF) {\n                    if (lyd_wd_add_subtree(root, present->set.d[i], present->set.d[i], schema, 0, options, unres)) {\n                        goto error;\n                    }\n                } /* else LYS_LEAF - nothing to do */\n            }\n        } else {\n            /* no instance */\n            if (lyd_wd_add_subtree(root, last_parent, NULL, schema, 0, options, unres)) {\n                goto error;\n            }\n        }\n\n        ly_set_free(present);\n        return EXIT_SUCCESS;\n    }\n\n    /* skip disabled parts of schema */\n    if (!subroot) {\n        /* go through all the uses and check whether they are enabled */\n        for (siter = schema->parent; siter && (siter->nodetype & (LYS_USES | LYS_CHOICE)); siter = siter->parent) {\n            if (lys_is_disabled(siter, 0)) {\n                /* ignore disabled uses nodes */\n                return EXIT_SUCCESS;\n            }\n        }\n\n        /* check augment state */\n        if (siter && siter->nodetype == LYS_AUGMENT) {\n            if (lys_is_disabled(siter, 0)) {\n                /* ignore disabled augment */\n                return EXIT_SUCCESS;\n            }\n        }\n\n        /* check the node itself */\n        if (lys_is_disabled(schema, 0)) {\n            /* ignore disabled data */\n            return EXIT_SUCCESS;\n        }\n    }\n\n    /* go recursively */\n    switch (schema->nodetype) {\n    case LYS_LIST:\n        if (!subroot) {\n            /* stop recursion */\n            break;\n        }\n        /* falls through */\n    case LYS_CONTAINER:\n        if (!subroot) {\n            /* container does not exists, continue only in case of non presence container */\n            if (((struct lys_node_container *)schema)->presence) {\n                /* stop recursion */\n                break;\n            }\n            /* always create empty NP container even if there is no default node,\n             * because accroding to RFC, the empty NP container is always part of\n             * accessible tree (e.g. for evaluating when and must conditions) */\n            subroot = _lyd_new(last_parent, schema, 1);\n            /* useless to set mand flag */\n            subroot->validity &= ~LYD_VAL_MAND;\n\n            if (unres->store_diff) {\n                /* remember this container in the diff */\n                if (unres_data_diff_new(unres, subroot, NULL, 1)) {\n                    goto error;\n                }\n\n                /* do not store diff for recursive calls, created values will be connected to this one */\n                storing_diff = 1;\n                unres->store_diff = 0;\n            }\n\n            if (!last_parent) {\n                if (*root) {\n                    lyd_insert_common((*root)->parent, root, subroot, 0);\n                } else {\n                    *root = subroot;\n                }\n            }\n            last_parent = subroot;\n\n            /* remember the created container in unres */\n            if (check_when_must) {\n                if ((subroot->when_status & LYD_WHEN) && unres_data_add(unres, subroot, UNRES_WHEN) == -1) {\n                    goto error;\n                }\n                if (check_when_must == 2) {\n                    i = resolve_applies_must(subroot);\n                    if ((i & 0x1) && (unres_data_add(unres, subroot, UNRES_MUST) == -1)) {\n                        goto error;\n                    }\n                    if ((i & 0x2) && (unres_data_add(unres, subroot, UNRES_MUST_INOUT) == -1)) {\n                        goto error;\n                    }\n                }\n            }\n        } else if (!((struct lys_node_container *)schema)->presence) {\n            /* fix default flag on existing containers - set it on all non-presence containers and in case we will\n             * have in recursion function some non-default node, it will unset it */\n            subroot->dflt = 1;\n        }\n        /* falls through */\n    case LYS_CASE:\n    case LYS_USES:\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n    case LYS_NOTIF:\n\n        /* recursion */\n        present = ly_set_new();\n        if (!present) {\n            goto error;\n        }\n        LY_TREE_FOR(schema->child, siter) {\n            if (siter->nodetype & (LYS_CHOICE | LYS_USES)) {\n                /* go into without searching for data instance */\n                if (lyd_wd_add_subtree(root, last_parent, subroot, siter, toplevel, options, unres)) {\n                    goto error;\n                }\n            } else if (siter->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_ANYDATA)) {\n                /* search for the schema node instance */\n                if (subroot && lyd_get_node_siblings(subroot->child, siter, present)) {\n                    /* there are some instances in the data root */\n                    if (siter->nodetype & LYS_LEAFLIST) {\n                        /* already have some leaflists, check that they are all\n                         * default, if not, remove the default leaflists */\n                        lyd_wd_leaflist_cleanup(present, unres);\n                    } else if (siter->nodetype != LYS_LEAF) {\n                        /* recursion */\n                        for (i = 0; i < (signed)present->number; i++) {\n                            if (lyd_wd_add_subtree(root, present->set.d[i], present->set.d[i], siter, toplevel, options,\n                                                   unres)) {\n                                goto error;\n                            }\n                        }\n                    } /* else LYS_LEAF - nothing to do */\n\n                    /* fix default flag (2nd part) - for non-default node with default parent, unset the default flag\n                     * from the parents (starting from subroot node) */\n                    if (subroot->dflt) {\n                        for (i = 0; i < (signed)present->number; i++) {\n                            if (!present->set.d[i]->dflt) {\n                                for (iter = subroot; iter && iter->dflt; iter = iter->parent) {\n                                    iter->dflt = 0;\n                                }\n                                break;\n                            }\n                        }\n                    }\n                    ly_set_clean(present);\n                } else {\n                    /* no instance */\n                    if (lyd_wd_add_subtree(root, last_parent, NULL, siter, toplevel, options, unres)) {\n                        goto error;\n                    }\n                }\n            }\n        }\n\n        if (storing_diff) {\n            /* continue generating the diff in functions above this one */\n            unres->store_diff = 1;\n        }\n        break;\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n        if (subroot) {\n            /* default shortcase of a choice */\n            present = ly_set_new();\n            if (!present) {\n                goto error;\n            }\n            lyd_get_node_siblings(subroot->child, schema, present);\n            if (present->number) {\n                /* the shortcase leaf(-list) exists, stop the processing */\n                break;\n            }\n        }\n        if (schema->nodetype == LYS_LEAF) {\n            if (lyd_wd_add_leaf(root, last_parent, (struct lys_node_leaf*)schema, unres, check_when_must)) {\n                return EXIT_FAILURE;\n            }\n        } else { /* LYS_LEAFLIST */\n            if (lyd_wd_add_leaflist(root, last_parent, (struct lys_node_leaflist*)schema, unres, check_when_must)) {\n                goto error;\n            }\n        }\n        break;\n    case LYS_CHOICE:\n        /* get existing node in the data root from the choice */\n        iter = NULL;\n        if ((toplevel && (*root)) || (!toplevel && subroot)) {\n            LY_TREE_FOR(toplevel ? (*root) : subroot->child, iter) {\n                for (siter = lys_parent(iter->schema), siter_prev = iter->schema;\n                        siter && (siter->nodetype & (LYS_CASE | LYS_USES | LYS_CHOICE));\n                        siter_prev = siter, siter = lys_parent(siter)) {\n                    if (siter == schema) {\n                        /* we have the choice instance */\n                        break;\n                    }\n                }\n                if (siter == schema) {\n                    /* we have the choice instance;\n                     * the condition must be the same as in the loop because of\n                     * choice's sibling nodes that break the loop, so siter is not NULL,\n                     * but it is not the same as schema */\n                    break;\n                }\n            }\n        }\n        if (!iter) {\n            if (((struct lys_node_choice *)schema)->dflt) {\n                /* there is a default case */\n                if (lyd_wd_add_subtree(root, last_parent, subroot, ((struct lys_node_choice *)schema)->dflt,\n                                       toplevel, options, unres)) {\n                    goto error;\n                }\n            }\n        } else {\n            /* one of the choice's cases is instantiated, continue into this case */\n            /* since iter != NULL, siter must be also != NULL and we also know siter_prev\n             * which points to the child of schema leading towards the instantiated data */\n            assert(siter && siter_prev);\n            if (lyd_wd_add_subtree(root, last_parent, subroot, siter_prev, toplevel, options, unres)) {\n                goto error;\n            }\n        }\n        break;\n    default:\n        /* LYS_ANYXML, LYS_ANYDATA, LYS_USES, LYS_GROUPING - do nothing */\n        break;\n    }\n\n    ly_set_free(present);\n    return EXIT_SUCCESS;\n\nerror:\n    ly_set_free(present);\n    return EXIT_FAILURE;\n}\n\n/**\n * @brief Covering function to process (add/clean) default nodes in the data tree\n * @param[in,out] root Pointer to the root node of the complete data tree, the root node can be NULL if the data tree\n *                     is empty\n * @param[in] ctx      Context for the case the data tree is empty (in that case \\p ctx must not be NULL)\n * @param[in] options  Parser options to know the data tree type, see @ref parseroptions.\n * @param[in] unres    Unresolved data list, the newly added default nodes may need to add some unresolved items\n * @return EXIT_SUCCESS or EXIT_FAILURE\n */\nstatic int\nlyd_wd_add(struct lyd_node **root, struct ly_ctx *ctx, const struct lys_module **modules, int mod_count,\n           struct unres_data *unres, int options)\n{\n    struct lys_node *siter;\n    int i;\n\n    assert(root && !(options & LYD_OPT_ACT_NOTIF));\n    assert(*root || ctx);\n    assert(!(options & LYD_OPT_NOSIBLINGS) || *root);\n\n    if (options & (LYD_OPT_EDIT | LYD_OPT_GET | LYD_OPT_GETCONFIG)) {\n        /* no change supposed */\n        return EXIT_SUCCESS;\n    }\n\n    if (!ctx) {\n        ctx = (*root)->schema->module->ctx;\n    }\n\n    if (!(options & LYD_OPT_TYPEMASK) || (options & LYD_OPT_CONFIG)) {\n        if (options & LYD_OPT_NOSIBLINGS) {\n            if (lyd_wd_add_subtree(root, NULL, NULL, (*root)->schema, 1, options, unres)) {\n                return EXIT_FAILURE;\n            }\n        } else if (modules && mod_count) {\n            for (i = 0; i < mod_count; ++i) {\n                LY_TREE_FOR(modules[i]->data, siter) {\n                    if (!(siter->nodetype & (LYS_CONTAINER | LYS_CHOICE | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_ANYDATA |\n                                             LYS_USES))) {\n                        continue;\n                    }\n                    if (lyd_wd_add_subtree(root, NULL, NULL, siter, 1, options, unres)) {\n                        return EXIT_FAILURE;\n                    }\n                }\n            }\n        } else {\n            for (i = 0; i < ctx->models.used; i++) {\n                /* skip not implemented and disabled modules */\n                if (!ctx->models.list[i]->implemented || ctx->models.list[i]->disabled) {\n                    continue;\n                }\n                LY_TREE_FOR(ctx->models.list[i]->data, siter) {\n                    if (!(siter->nodetype & (LYS_CONTAINER | LYS_CHOICE | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_ANYDATA |\n                                             LYS_USES))) {\n                        continue;\n                    }\n                    if (lyd_wd_add_subtree(root, NULL, NULL, siter, 1, options, unres)) {\n                        return EXIT_FAILURE;\n                    }\n                }\n            }\n        }\n    } else if (options & LYD_OPT_NOTIF) {\n        if (!(*root) || ((*root)->schema->nodetype != LYS_NOTIF)) {\n            LOGERR(ctx, LY_EINVAL, \"Subtree is not a single notification.\");\n            return EXIT_FAILURE;\n        }\n        if (lyd_wd_add_subtree(root, *root, *root, (*root)->schema, 0, options, unres)) {\n            return EXIT_FAILURE;\n        }\n    } else if (options & (LYD_OPT_RPC | LYD_OPT_RPCREPLY)) {\n        if (!(*root) || !((*root)->schema->nodetype & (LYS_RPC | LYS_ACTION))) {\n            LOGERR(ctx, LY_EINVAL, \"Subtree is not a single RPC/action/reply.\");\n            return EXIT_FAILURE;\n        }\n        if (options & LYD_OPT_RPC) {\n            for (siter = (*root)->schema->child; siter && siter->nodetype != LYS_INPUT; siter = siter->next);\n        } else { /* LYD_OPT_RPCREPLY */\n            for (siter = (*root)->schema->child; siter && siter->nodetype != LYS_OUTPUT; siter = siter->next);\n        }\n        if (siter) {\n            if (lyd_wd_add_subtree(root, *root, *root, siter, 0, options, unres)) {\n                return EXIT_FAILURE;\n            }\n        }\n    } else if (options & LYD_OPT_DATA_TEMPLATE) {\n        if (lyd_wd_add_subtree(root, NULL, NULL, (*root)->schema, 1, options, unres)) {\n            return EXIT_FAILURE;\n        }\n    } else {\n        LOGINT(ctx);\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\nlyd_defaults_add_unres(struct lyd_node **root, int options, struct ly_ctx *ctx, const struct lys_module **modules,\n                       int mod_count, const struct lyd_node *data_tree, struct lyd_node *act_notif,\n                       struct unres_data *unres, int wd)\n{\n    struct lyd_node *msg_sibling = NULL, *msg_parent = NULL, *data_tree_sibling, *data_tree_parent;\n    struct lys_node *msg_op = NULL;\n    struct ly_set *set;\n    int ret = EXIT_FAILURE;\n\n    assert(root && (*root || ctx) && unres && !(options & LYD_OPT_ACT_NOTIF));\n\n    if (!ctx) {\n        ctx = (*root)->schema->module->ctx;\n    }\n\n    if ((options & LYD_OPT_NOSIBLINGS) && !(*root)) {\n        LOGERR(ctx, LY_EINVAL, \"Cannot add default values for one module (LYD_OPT_NOSIBLINGS) without any data.\");\n        return EXIT_FAILURE;\n    }\n\n    if (options & (LYD_OPT_RPC | LYD_OPT_RPCREPLY | LYD_OPT_NOTIF)) {\n        if (!(*root)) {\n            LOGERR(ctx, LY_EINVAL, \"Cannot add default values to RPC, RPC reply, and notification without at least the empty container.\");\n            return EXIT_FAILURE;\n        }\n        if ((options & LYD_OPT_RPC) && !act_notif && ((*root)->schema->nodetype != LYS_RPC)) {\n            LOGERR(ctx, LY_EINVAL, \"Not valid RPC/action data.\");\n            return EXIT_FAILURE;\n        }\n        if ((options & LYD_OPT_RPCREPLY) && !act_notif && ((*root)->schema->nodetype != LYS_RPC)) {\n            LOGERR(ctx, LY_EINVAL, \"Not valid reply data.\");\n            return EXIT_FAILURE;\n        }\n        if ((options & LYD_OPT_NOTIF) && !act_notif && ((*root)->schema->nodetype != LYS_NOTIF)) {\n            LOGERR(ctx, LY_EINVAL, \"Not valid notification data.\");\n            return EXIT_FAILURE;\n        }\n\n        /* remember the operation/notification schema */\n        msg_op = act_notif ? act_notif->schema : (*root)->schema;\n    } else if (*root && (*root)->parent) {\n        /* we have inner node, so it will be considered as\n         * a root of subtree where to add default nodes and\n         * no of its siblings will be affected */\n        options |= LYD_OPT_NOSIBLINGS;\n    }\n\n    /* add missing default nodes */\n    if (wd && lyd_wd_add((act_notif ? &act_notif : root), ctx, modules, mod_count, unres, options)) {\n        return EXIT_FAILURE;\n    }\n\n    /* check leafrefs and/or instids if any */\n    if (unres && unres->count) {\n        if (!(*root)) {\n            LOGINT(ctx);\n            return EXIT_FAILURE;\n        }\n\n        /* temporarily link the additional data tree to the RPC/action/notification */\n        if (data_tree && (options & (LYD_OPT_RPC | LYD_OPT_RPCREPLY | LYD_OPT_NOTIF))) {\n            /* duplicate the message tree - if it gets deleted we would not be able to positively identify it */\n            msg_parent = NULL;\n            msg_sibling = *root;\n\n            if (act_notif) {\n                /* fun case */\n                data_tree_parent = NULL;\n                data_tree_sibling = (struct lyd_node *)data_tree;\n                while (data_tree_sibling) {\n                    while (data_tree_sibling) {\n                        if ((data_tree_sibling->schema == msg_sibling->schema)\n                                && ((msg_sibling->schema->nodetype != LYS_LIST)\n                                    || lyd_list_equal(data_tree_sibling, msg_sibling, 0))) {\n                            /* match */\n                            break;\n                        }\n\n                        data_tree_sibling = data_tree_sibling->next;\n                    }\n\n                    if (data_tree_sibling) {\n                        /* prepare for the new data_tree iteration */\n                        data_tree_parent = data_tree_sibling;\n                        data_tree_sibling = data_tree_sibling->child;\n\n                        /* find new action sibling to search for later (skip list keys) */\n                        msg_parent = msg_sibling;\n                        assert(msg_sibling->child);\n                        for (msg_sibling = msg_sibling->child;\n                                msg_sibling->schema->nodetype == LYS_LEAF;\n                                msg_sibling = msg_sibling->next) {\n                            assert(msg_sibling->next);\n                        }\n                        if (msg_sibling->schema->nodetype & (LYS_ACTION | LYS_NOTIF)) {\n                            /* we are done */\n                            assert(act_notif->parent);\n                            assert(act_notif->parent->schema == data_tree_parent->schema);\n                            assert(msg_sibling == act_notif);\n                            break;\n                        }\n                    }\n                }\n\n                /* loop ended after the first iteration, set the values correctly */\n                if (!data_tree_parent) {\n                    data_tree_sibling = (struct lyd_node *)data_tree;\n                }\n\n            } else {\n                /* easy case */\n                data_tree_parent = NULL;\n                data_tree_sibling = (struct lyd_node *)data_tree;\n            }\n\n            /* unlink msg_sibling if needed (won't do anything otherwise) */\n            lyd_unlink_internal(msg_sibling, 0);\n\n            /* now we can insert msg_sibling into data_tree_parent or next to data_tree_sibling */\n            assert(data_tree_parent || data_tree_sibling);\n            if (data_tree_parent) {\n                if (lyd_insert_common(data_tree_parent, NULL, msg_sibling, 0)) {\n                    goto unlink_datatree;\n                }\n            } else {\n                assert(!data_tree_sibling->parent);\n                if (lyd_insert_nextto(data_tree_sibling->prev, msg_sibling, 0, 0)) {\n                    goto unlink_datatree;\n                }\n            }\n        }\n\n        if (resolve_unres_data(ctx, unres, root, options)) {\n            goto unlink_datatree;\n        }\n\n        /* we are done */\n        ret = EXIT_SUCCESS;\n\n        /* check that the operation/notification tree was not removed */\n        if (options & (LYD_OPT_RPC | LYD_OPT_RPCREPLY | LYD_OPT_NOTIF)) {\n            set = NULL;\n            if (data_tree) {\n                set = lyd_find_instance(data_tree_parent ? data_tree_parent : data_tree_sibling, msg_op);\n                assert(set && ((set->number == 0) || (set->number == 1)));\n            } else if (*root) {\n                set = lyd_find_instance(*root, msg_op);\n                assert(set && ((set->number == 0) || (set->number == 1)));\n            }\n            if (!set || !set->number) {\n                /* it was removed, handle specially */\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, msg_op, \"Operation/notification not supported because of the current configuration.\");\n                ret = EXIT_FAILURE;\n            }\n            ly_set_free(set);\n        }\n\nunlink_datatree:\n        /* put the trees back in order */\n        if (data_tree && (options & (LYD_OPT_RPC | LYD_OPT_RPCREPLY | LYD_OPT_NOTIF))) {\n            /* unlink and insert it back, if there is a parent  */\n            lyd_unlink_internal(msg_sibling, 0);\n            if (msg_parent) {\n                lyd_insert_common(msg_parent, NULL, msg_sibling, 0);\n            }\n        }\n    } else {\n        /* we are done */\n        ret = EXIT_SUCCESS;\n    }\n\n    return ret;\n}\n\nAPI struct lys_module *\nlyd_node_module(const struct lyd_node *node)\n{\n    if (!node) {\n        return NULL;\n    }\n\n    return node->schema->module->type ? ((struct lys_submodule *)node->schema->module)->belongsto : node->schema->module;\n}\n\nAPI double\nlyd_dec64_to_double(const struct lyd_node *node)\n{\n    if (!node || !(node->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST))\n            || (((struct lys_node_leaf *)node->schema)->type.base != LY_TYPE_DEC64)) {\n        LOGARG;\n        return 0;\n    }\n\n    return atof(((struct lyd_node_leaf_list *)node)->value_str);\n}\n\nAPI const struct lys_type *\nlyd_leaf_type(const struct lyd_node_leaf_list *leaf)\n{\n    struct lys_type *type;\n\n    if (!leaf || !(leaf->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n        return NULL;\n    }\n\n    type = &((struct lys_node_leaf *)leaf->schema)->type;\n\n    do {\n        if (type->base == LY_TYPE_LEAFREF) {\n            type = &type->info.lref.target->type;\n        } else if (type->base == LY_TYPE_UNION) {\n            if (type->info.uni.has_ptr_type && leaf->validity) {\n                /* we don't know what it will be after resolution (validation) */\n                LOGVAL(leaf->schema->module->ctx, LYE_SPEC, LY_VLOG_LYD, leaf,\n                       \"Unable to determine the type of value \\\"%s\\\" from union type \\\"%s\\\" prior to validation.\",\n                       leaf->value_str, type->der->name);\n                return NULL;\n            }\n\n            if (resolve_union((struct lyd_node_leaf_list *)leaf, type, 0, 0, &type)) {\n                /* resolve union failed */\n                return NULL;\n            }\n        }\n    } while (type->base == LY_TYPE_LEAFREF);\n\n    return type;\n}\n\nAPI int\nlyd_lyb_data_length(const char *data)\n{\n    const char *ptr;\n    uint16_t i, mod_count, str_len;\n    uint8_t tmp_buf[2];\n    LYB_META meta;\n\n    if (!data) {\n        return -1;\n    }\n\n    ptr = data;\n\n    /* magic number */\n    if ((ptr[0] != 'l') || (ptr[1] != 'y') || (ptr[2] != 'b')) {\n        return -1;\n    }\n    ptr += 3;\n\n    /* header */\n    ++ptr;\n\n    /* models */\n    memcpy(tmp_buf, ptr, 2);\n    ptr += 2;\n    mod_count = tmp_buf[0] | (tmp_buf[1] << 8);\n\n    for (i = 0; i < mod_count; ++i) {\n        /* model name */\n        memcpy(tmp_buf, ptr, 2);\n        ptr += 2;\n        str_len = tmp_buf[0] | (tmp_buf[1] << 8);\n\n        ptr += str_len;\n\n        /* revision */\n        ptr += 2;\n    }\n\n    if (ptr[0]) {\n        /* subtrees */\n        do {\n            memcpy(&meta, ptr, LYB_META_BYTES);\n            ptr += LYB_META_BYTES;\n\n            /* read whole subtree (chunk size) */\n            ptr += *((uint8_t *)&meta);\n            /* skip inner chunks (inner chunk count) */\n            ptr += *(((uint8_t *)&meta) + LYB_SIZE_BYTES) * LYB_META_BYTES;\n        } while ((*((uint8_t *)&meta) == LYB_SIZE_MAX) || ptr[0]);\n    }\n\n    /* ending zero */\n    ++ptr;\n\n    return ptr - data;\n}\n\n#ifdef LY_ENABLED_LYD_PRIV\n\nAPI void *\nlyd_set_private(const struct lyd_node *node, void *priv)\n{\n    void *prev;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    prev = node->priv;\n    ((struct lyd_node *)node)->priv = priv;\n\n    return prev;\n}\n\n#endif\n", "/**\n * @file tree_internal.h\n * @author Radek Krejci <rkrejci@cesnet.cz>\n * @brief libyang internal functions for manipulating with the data model and\n * data trees.\n *\n * Copyright (c) 2015 CESNET, z.s.p.o.\n *\n * This source code is licensed under BSD 3-Clause License (the \"License\").\n * You may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/BSD-3-Clause\n */\n\n#ifndef LY_TREE_INTERNAL_H_\n#define LY_TREE_INTERNAL_H_\n\n#include <stdint.h>\n\n#include \"libyang.h\"\n#include \"tree_schema.h\"\n#include \"tree_data.h\"\n#include \"resolve.h\"\n\n/* this is used to distinguish lyxml_elem * from a YANG temporary parsing structure, the first byte is compared */\n#define LY_YANG_STRUCTURE_FLAG 0x80\n\n/**\n * @brief YANG namespace\n */\n#define LY_NSYANG \"urn:ietf:params:xml:ns:yang:1\"\n\n/**\n * @brief YIN namespace\n */\n#define LY_NSYIN \"urn:ietf:params:xml:ns:yang:yin:1\"\n\n/**\n * @brief NETCONF namespace\n */\n#define LY_NSNC \"urn:ietf:params:xml:ns:netconf:base:1.0\"\n\n/**\n * @brief NACM namespace\n */\n#define LY_NSNACM \"urn:ietf:params:xml:ns:yang:ietf-netconf-acm\"\n\n/**\n * @brief internal parser flag for actions and inline notifications\n */\n#define LYD_OPT_ACT_NOTIF 0x100\n\n/**\n * @brief Internal list of built-in types\n */\nextern struct lys_tpdf *ly_types[LY_DATA_TYPE_COUNT];\n\n/**\n * @brief Internal structure for data node sorting.\n */\nstruct lyd_node_pos {\n    struct lyd_node *node;\n    uint32_t pos;\n};\n\n/**\n * @brief Internal structure for LYB parser/printer.\n */\nstruct lyb_state {\n    size_t *written;\n    size_t *position;\n    uint8_t *inner_chunks;\n    int used;\n    int size;\n    const struct lys_module **models;\n    int mod_count;\n    struct ly_ctx *ctx;\n\n    /* LYB printer only */\n    struct {\n        struct lys_node *first_sibling;\n        struct hash_table *ht;\n    } *sib_ht;\n    int sib_ht_count;\n};\n\n/* struct lyb_state allocation step */\n#define LYB_STATE_STEP 4\n\n/**\n * LYB schema hash constants\n *\n * Hash is divided to collision ID and hash itself.\n *\n * First bits are collision ID until 1 is found. The rest is truncated 32b hash.\n * 1xxx xxxx - collision ID 0 (no collisions)\n * 01xx xxxx - collision ID 1 (collision ID 0 hash collided)\n * 001x xxxx - collision ID 2 ...\n */\n\n/* Number of bits the whole hash will take (including hash collision ID) */\n#define LYB_HASH_BITS 8\n\n/* Masking 32b hash (collision ID 0) */\n#define LYB_HASH_MASK 0x7f\n\n/* Type for storing the whole hash (used only internally, publicly defined directly) */\n#define LYB_HASH uint8_t\n\n/* Need to move this first >> collision number (from 0) to get collision ID hash part */\n#define LYB_HASH_COLLISION_ID 0x80\n\n/* How many bytes are reserved for one data chunk SIZE (8B is maximum) */\n#define LYB_SIZE_BYTES 1\n\n/* Maximum size that will be written into LYB_SIZE_BYTES (must be large enough) */\n#define LYB_SIZE_MAX UINT8_MAX\n\n/* How many bytes are reserved for one data chunk inner chunk count */\n#define LYB_INCHUNK_BYTES 1\n\n/* Maximum size that will be written into LYB_INCHUNK_BYTES (must be large enough) */\n#define LYB_INCHUNK_MAX UINT8_MAX\n\n/* Just a helper macro */\n#define LYB_META_BYTES (LYB_INCHUNK_BYTES + LYB_SIZE_BYTES)\n\n/* Type large enough for all meta data */\n#define LYB_META uint16_t\n\nLYB_HASH lyb_hash(struct lys_node *sibling, uint8_t collision_id);\n\nint lyb_has_schema_model(struct lys_node *sibling, const struct lys_module **models, int mod_count);\n\n/**\n * Macros to work with ::lyd_node#when_status\n * +--- bit 1 - some when-stmt connected with the node (resolve_applies_when() is true)\n * |+-- bit 2 - when-stmt's condition is resolved and it is true\n * ||+- bit 3 - when-stmt's condition is resolved and it is false\n * XXX\n *\n * bit 1 is set when the node is created\n * if none of bits 2 and 3 is set, the when condition is not yet resolved\n */\n#define LYD_WHEN       0x04\n#define LYD_WHEN_TRUE  0x02\n#define LYD_WHEN_FALSE 0x01\n#define LYD_WHEN_DONE(status) (!((status) & LYD_WHEN) || ((status) & (LYD_WHEN_TRUE | LYD_WHEN_FALSE)))\n\n/**\n * @brief Type flag for an unresolved type in a grouping.\n */\n#define LY_VALUE_UNRESGRP 0x80\n\n#ifdef LY_ENABLED_CACHE\n\n/**\n * @brief Minimum number of children for the parent to create a hash table for them.\n */\n#   define LY_CACHE_HT_MIN_CHILDREN 4\n\n    int lyd_hash(struct lyd_node *node);\n\n    void lyd_insert_hash(struct lyd_node *node);\n\n    void lyd_unlink_hash(struct lyd_node *node, struct lyd_node *orig_parent);\n#endif\n\n/**\n * @brief Create submodule structure by reading data from memory.\n *\n * @param[in] module Schema tree where to connect the submodule, belongs-to value must match.\n * @param[in] data String containing the submodule specification in the given \\p format.\n * @param[in] format Format of the data to read.\n * @param[in] unres list of unresolved items\n * @return Created submodule structure or NULL in case of error.\n */\nstruct lys_submodule *lys_sub_parse_mem(struct lys_module *module, const char *data, LYS_INFORMAT format,\n                                        struct unres_schema *unres);\n\n/**\n * @brief Create submodule structure by reading data from file descriptor.\n *\n * \\note Current implementation supports only reading data from standard (disk) file, not from sockets, pipes, etc.\n *\n * @param[in] module Schema tree where to connect the submodule, belongs-to value must match.\n * @param[in] fd File descriptor of a regular file (e.g. sockets are not supported) containing the submodule\n *            specification in the given \\p format.\n * @param[in] format Format of the data to read.\n * @param[in] unres list of unresolved items\n * @return Created submodule structure or NULL in case of error.\n */\nstruct lys_submodule *lys_sub_parse_fd(struct lys_module *module, int fd, LYS_INFORMAT format, struct unres_schema *unres);\n\n/**\n * @brief Free the submodule structure\n *\n * @param[in] submodule The structure to free. Do not use the pointer after calling this function.\n * @param[in] private_destructor Optional destructor function for private objects assigned\n * to the nodes via lys_set_private(). If NULL, the private objects are not freed by libyang.\n */\nvoid lys_submodule_free(struct lys_submodule *submodule, void (*private_destructor)(const struct lys_node *node, void *priv));\n\n/**\n * @brief Add child schema tree node at the end of the parent's child list.\n *\n * If the child is connected somewhere (has a parent), it is completely\n * unlinked and none of the following conditions applies.\n * If the child has prev sibling(s), they are ignored (child is added at the\n * end of the child list).\n * If the child has next sibling(s), all of them are connected with the parent.\n *\n * @param[in] parent Parent node where the \\p child will be added.\n * @param[in] module Module where the \\p child will be added if the \\p parent\n * parameter is NULL (case of top-level elements). The parameter does not change\n * the module of the \\p child element. If the \\p parent parameter is present,\n * the \\p module parameter is ignored.\n * @param[in] child The schema tree node to be added.\n * @param[in] options Parsing options. Only relevant when creating a shorthand case.\n * @return 0 on success, nonzero else\n */\nint lys_node_addchild(struct lys_node *parent, struct lys_module *module, struct lys_node *child, int options);\n\n/**\n * @brief Find a valid grouping definition relative to a node.\n *\n * Valid definition means a sibling of \\p start or a sibling of any of \\p start 's parents.\n *\n * @param[in] name Name of the searched grouping.\n * @param[in] start Definition must be valid (visible) for this node.\n * @return Matching valid grouping or NULL.\n */\nstruct lys_node_grp *lys_find_grouping_up(const char *name, struct lys_node *start);\n\n/**\n * @brief Check that the \\p node being connected into the \\p parent has a unique name (identifier).\n *\n * Function is performed also as part of lys_node_addchild().\n *\n * @param[in] node The schema tree node to be checked.\n * @param[in] parent Parent node where the \\p child is supposed to be added.\n * @param[in] module Module where the \\p child is supposed to be added if the \\p parent\n * parameter is NULL (case of top-level elements). The parameter does not change\n * the module of the \\p child element. If the \\p parent parameter is present,\n * the \\p module parameter is ignored.\n * @return 0 on success, nonzero else\n */\nint lys_check_id(struct lys_node *node, struct lys_node *parent, struct lys_module *module);\n\n/**\n * @brief Get know if the node contains must or when with XPath expression\n *\n * @param[in] node Node to examine.\n * @return 1 if contains, 0 otherwise\n */\nint lys_has_xpath(const struct lys_node *node);\n\n/**\n * @brief Learn if \\p type is defined in the local module or from an import.\n *\n * @param[in] type Type to examine.\n * @return non-zero if local, 0 if from an import.\n */\nint lys_type_is_local(const struct lys_type *type);\n\n/**\n * @brief Create a copy of the specified schema tree \\p node\n *\n * @param[in] module Target module for the duplicated node.\n * @param[in] parent Schema tree node where the node is being connected, NULL in case of top level \\p node.\n * @param[in] node Schema tree node to be duplicated.\n * @param[in] unres list of unresolved items\n * @param[in] shallow Whether to copy children and connect to parent/module too.\n * @return Created copy of the provided schema \\p node.\n */\nstruct lys_node *lys_node_dup(struct lys_module *module, struct lys_node *parent, const struct lys_node *node,\n                              struct unres_schema *unres, int shallow);\n\n/**\n * @brief duplicate the list of extension instances.\n *\n * @param[in] ctx Context to store errors in.\n * @param[in] mod Module where we are\n * @param[in] orig list of the extension instances to duplicate, the size of the array must correspond with \\p size\n * @param[in] size number of items in \\p old array to duplicate\n * @param[in] parent Parent structure of the new extension instances list\n * @param[in] parent_type Type of the provide \\p parent *\n * @param[in,out] new Address where to store the created list of duplicated extension instances\n * @param[in] shallow Whether to copy children and connect to parent/module too.\n * @param[in] unres list of unresolved items\n *\n */\nint lys_ext_dup(struct ly_ctx *ctx, struct lys_module *mod, struct lys_ext_instance **orig, uint8_t size, void *parent,\n                LYEXT_PAR parent_type, struct lys_ext_instance ***new, int shallow, struct unres_schema *unres);\n\n/**\n * @brief Iterate over the specified type of the extension instances\n *\n * @param[in] ext Array of extensions to explore\n * @param[in] ext_size Size of the provided \\p ext array\n * @param[in] start Index in the \\p ext array where to start searching (first call with 0, the consequent calls with\n *            the returned index increased by 1, unless the returned index is -1)\n * @param[in] substmt Type of the extension (its belongins to the specific substatement) to iterate, use\n *            #LYEXT_SUBSTMT_ALL to go through all the extensions in the array\n * @result index in the ext, -1 if not present\n */\nint lys_ext_iter(struct lys_ext_instance **ext, uint8_t ext_size, uint8_t start, LYEXT_SUBSTMT substmt);\n\n/**\n * @brief free the array of the extension instances\n */\nvoid lys_extension_instances_free(struct ly_ctx *ctx, struct lys_ext_instance **e, unsigned int size,\n                                  void (*private_destructor)(const struct lys_node *node, void *priv));\n\n/**\n * @brief Add pointer to \\p leafref to \\p leafref_target children so that it knows there\n * are some leafrefs referring it.\n *\n * @param[in] leafref_target Leaf that is \\p leafref's target.\n * @param[in] leafref Leaf or leaflist of type #LY_TYPE_LEAFREF referring \\p leafref_target.\n * @return 0 on success, -1 on error.\n */\nint lys_leaf_add_leafref_target(struct lys_node_leaf *leafref_target, struct lys_node *leafref);\n\n/**\n * @brief Free a schema when condition\n *\n * @param[in] libyang context where the schema of the ondition is used.\n * @param[in] w When structure to free.\n * @param[in] private_destructor Destructor for priv member in extension instances\n */\nvoid lys_when_free(struct ly_ctx *ctx, struct lys_when *w,\n                   void (*private_destructor)(const struct lys_node *node, void *priv));\n\n/**\n * @brief Free the schema tree restriction (must, ...) structure content\n *\n * @param[in] ctx libyang context where the schema of the restriction is used.\n * @param[in] restr The restriction structure to free. The function actually frees only\n * the content of the structure, so after using this function, caller is supposed to\n * use free(restr). It is done to free the content of structures being allocated as\n * part of array, in that case the free() is used on the whole array.\n * @param[in] private_destructor Destructor for priv member in extension instances\n */\nvoid lys_restr_free(struct ly_ctx *ctx, struct lys_restr *restr,\n                    void (*private_destructor)(const struct lys_node *node, void *priv));\n\n/**\n * @brief Free the schema tree type structure content\n *\n * @param[in] ctx libyang context where the schema of the type is used.\n * @param[in] restr The type structure to free. The function actually frees only\n * the content of the structure, so after using this function, caller is supposed to\n * use free(type). It is done to free the content of structures being allocated as\n * part of array, in that case the free() is used on the whole array.\n * @param[in] private_destructor Destructor for priv member in extension instances\n */\nvoid lys_type_free(struct ly_ctx *ctx, struct lys_type *type,\n                   void (*private_destructor)(const struct lys_node *node, void *priv));\n\n/**\n * @brief Unlink the schema node from the tree.\n *\n * @param[in] node Schema tree node to unlink.\n */\nvoid lys_node_unlink(struct lys_node *node);\n\n/**\n * @brief Free the schema node structure, includes unlinking it from the tree\n *\n * @param[in] node Schema tree node to free. Do not use the pointer after calling this function.\n * @param[in] private_destructor Optional destructor function for private objects assigned\n * to the nodes via lys_set_private(). If NULL, the private objects are not freed by libyang.\n * @param[in] shallow Whether to do a shallow free only (on a shallow copy of a node).\n */\nvoid lys_node_free(struct lys_node *node, void (*private_destructor)(const struct lys_node *node, void *priv), int shallow);\n\n/**\n * @brief Free (and unlink it from the context) the specified schema.\n *\n * It is dangerous to call this function on schemas already placed into the context's\n * list of modules - there can be many references from other modules and data instances.\n *\n * @param[in] module Data model to free.\n * @param[in] private_destructor Optional destructor function for private objects assigned\n * to the nodes via lys_set_private(). If NULL, the private objects are not freed by libyang.\n * @param[in] free_subs Whether to free included submodules.\n * @param[in] remove_from_ctx Whether to remove this model from context. Always use 1 except\n * when removing all the models (in ly_ctx_destroy()).\n */\nvoid lys_free(struct lys_module *module, void (*private_destructor)(const struct lys_node *node, void *priv),\n              int free_subs, int remove_from_ctx);\n\n/**\n * @brief Create a data container knowing it's schema node.\n *\n * @param[in] parent Data parent of the new node.\n * @param[in] schema Schema node of the new node.\n * @param[in] dflt Set dflt flag in the created data nodes\n * @return New node, NULL on error.\n */\nstruct lyd_node *_lyd_new(struct lyd_node *parent, const struct lys_node *schema, int dflt);\n\n/**\n * @brief Create a dummy node for XPath evaluation. After done using, it should be removed.\n *\n * The function must be used very carefully:\n * - there must not be a list node to create\n *\n * @param[in] data Any data node of the tree where the dummy node will be created\n * @param[in] parent To optimize searching in data tree (and to avoid issues with lists), caller can specify a\n *                   parent node that exists in the data tree.\n * @param[in] schema Schema node of the dummy node to create, must be of nodetype that\n * appears also in data tree.\n * @param[in] value Optional value to be set in the dummy node\n * @param[in] dflt Set dflt flag in the created data nodes\n *\n * @return The first created node needed for the dummy node in the given tree.\n */\nstruct lyd_node *lyd_new_dummy(struct lyd_node *data, struct lyd_node *parent, const struct lys_node *schema,\n                               const char *value, int dflt);\n\n/**\n * @brief Find the parent node of an attribute.\n *\n * @param[in] root Root element of the data tree with the attribute.\n * @param[in] attr Attribute to find.\n *\n * @return Parent of \\p attr, NULL if not found.\n */\nconst struct lyd_node *lyd_attr_parent(const struct lyd_node *root, struct lyd_attr *attr);\n\n/**\n * @brief Internal version of lyd_unlink().\n *\n * @param[in] node Node to unlink.\n * @param[in] permanent 0 - the node will be linked back,\n *                      1 - the node is premanently unlinked,\n *                      2 - the node is being freed.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on error.\n */\nint lyd_unlink_internal(struct lyd_node *node, int permanent);\n\n/**\n * @brief Internal version of lyd_insert() and lyd_insert_sibling().\n *\n * @param[in] invalidate Whether to invalidate any nodes. Set 0 only if linking back some temporarily internally unlinked nodes.\n */\nint lyd_insert_common(struct lyd_node *parent, struct lyd_node **sibling, struct lyd_node *node, int invalidate);\n\n/**\n * @brief Internal version of lyd_insert_before() and lyd_insert_after().\n *\n * @param[in] invalidate Whether to invalidate any nodes. Set 0 only if linking back some temporarily internally unlinked nodes.\n */\nint lyd_insert_nextto(struct lyd_node *sibling, struct lyd_node *node, int before, int invalidate);\n\n/**\n * @brief Find a specific sibling. Does not log.\n *\n * Since \\p mod_name is mandatory, augments are handled.\n *\n * @param[in] siblings Siblings to consider. They are first adjusted to\n *                     point to the first sibling.\n * @param[in] mod_name Module name, mandatory.\n * @param[in] mod_name_len Module name length.\n * @param[in] name Node name, mandatory.\n * @param[in] nam_len Node name length.\n * @param[in] type ORed desired type of the node. 0 means any type.\n *                 Does not return groupings, uses, and augments (but can return augment nodes).\n * @param[out] ret Pointer to the node of the desired type. Can be NULL.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference.\n */\nint lys_get_sibling(const struct lys_node *siblings, const char *mod_name, int mod_name_len, const char *name,\n                    int nam_len, LYS_NODE type, const struct lys_node **ret);\n\n/**\n * @brief Find a specific node that can only appear in the data. Does not log.\n *\n * @param[in] mod Main module with the node. Must be set if \\p parent == NULL (top-level node).\n * @param[in] parent Parent of the node. Must be set if \\p mod == NULL (nested node).\n * @param[in] name Node name.\n * @param[in] nam_len Node \\p name length.\n * @param[in] type ORed desired type of the node. 0 means any (data node) type.\n * @param[in] getnext_opts lys_getnext() options to use.\n * @param[out] ret Pointer to the node of the desired type. Can be NULL.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on fail.\n */\nint lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,\n                     LYS_NODE type, int getnext_opts, const struct lys_node **ret);\n\nint lyd_get_unique_default(const char* unique_expr, struct lyd_node *list, const char **dflt);\n\nint lyd_build_relative_data_path(const struct lys_module *module, const struct lyd_node *node, const char *schema_id,\n                                 char *buf);\n\nvoid lyd_free_value(lyd_val value, LY_DATA_TYPE value_type, uint8_t value_flags, struct lys_type *type, lyd_val *old_val,\n                    LY_DATA_TYPE *old_val_type, uint8_t *old_val_flags);\n\nint lyd_list_equal(struct lyd_node *node1, struct lyd_node *node2, int with_defaults);\n\nint lys_make_implemented_r(struct lys_module *module, struct unres_schema *unres);\n\n/**\n * @brief Check for (validate) mandatory nodes of a data tree. Checks recursively whole data tree. Requires all when\n * statement to be solved.\n *\n * @param[in] root Data tree to validate.\n * @param[in] ctx libyang context (for the case when the data tree is empty - i.e. root == NULL).\n * @param[in] modules Only check mandatory nodes from these modules. If not set, check for all modules in the context.\n * @param[in] mod_count Number of modules in \\p modules.\n * @param[in] options Standard @ref parseroptions.\n * @return EXIT_SUCCESS or EXIT_FAILURE.\n */\nint lyd_check_mandatory_tree(struct lyd_node *root, struct ly_ctx *ctx, const struct lys_module **modules, int mod_count,\n                             int options);\n\n/**\n * @brief Check if the provided node is inside a grouping.\n *\n * @param[in] node Schema node to check.\n * @return 0 as false, 1 as true\n */\nint lys_ingrouping(const struct lys_node *node);\n\nint unres_data_diff_new(struct unres_data *unres, struct lyd_node *subtree, struct lyd_node *parent, int created);\n\nvoid unres_data_diff_rem(struct unres_data *unres, unsigned int idx);\n\n/**\n * @brief Process (add/clean) default nodes in the data tree and resolve the unresolved items\n *\n * @param[in,out] root  Pointer to the root node of the complete data tree, the root node can be NULL if the data tree\n *                      is empty\n * @param[in] options   Parser options to know the data tree type, see @ref parseroptions.\n * @param[in] ctx       Context for the case the \\p root is empty (in that case \\p ctx must not be NULL)\n * @param[in] modules   Only modules that will be traversed when adding default values.\n * @param[in] mod_count Number of module names in \\p modules.\n * @param[in] data_tree Additional data tree for validating RPC/action/notification. The tree is used to satisfy\n *                      possible references to the datastore content.\n * @param[in] act_notif In case of nested action/notification, pointer to the subroot of the action/notification. Note\n *                      that in this case the \\p root points to the top level data tree node which provides the context\n *                      for the nested action/notification\n * @param[in] unres     Unresolved data list, the newly added default nodes may need to add some unresolved items\n * @param[in] wd        Whether to add default values.\n * @return EXIT_SUCCESS or EXIT_FAILURE\n */\nint lyd_defaults_add_unres(struct lyd_node **root, int options, struct ly_ctx *ctx, const struct lys_module **modules,\n                           int mod_count, const struct lyd_node *data_tree, struct lyd_node *act_notif,\n                           struct unres_data *unres, int wd);\n\nvoid lys_enable_deviations(struct lys_module *module);\n\nvoid lys_disable_deviations(struct lys_module *module);\n\nvoid lys_sub_module_remove_devs_augs(struct lys_module *module);\n\nvoid lys_sub_module_apply_devs_augs(struct lys_module *module);\n\nint apply_aug(struct lys_node_augment *augment, struct unres_schema *unres);\n\nvoid lys_submodule_module_data_free(struct lys_submodule *submodule);\n\nint lys_copy_union_leafrefs(struct lys_module *mod, struct lys_node *parent, struct lys_type *type,\n                            struct lys_type *prev_new, struct unres_schema *unres);\n\nconst struct lys_module *lys_parse_fd_(struct ly_ctx *ctx, int fd, LYS_INFORMAT format, const char *revision, int implement);\n\nconst struct lys_module *lys_parse_mem_(struct ly_ctx *ctx, const char *data, LYS_INFORMAT format, const char *revision,\n                                        int internal, int implement);\n\n/**\n * @brief Get next augment from \\p mod augmenting \\p aug_target\n */\nstruct lys_node_augment *lys_getnext_target_aug(struct lys_node_augment *last, const struct lys_module *mod,\n                                                const struct lys_node *aug_target);\n\nLY_STMT lys_snode2stmt(LYS_NODE nodetype);\nstruct lys_node ** lys_child(const struct lys_node *node, LYS_NODE nodetype);\n\n#endif /* LY_TREE_INTERNAL_H_ */\n", "/**\n * @file tree_schema.c\n * @author Radek Krejci <rkrejci@cesnet.cz>\n * @brief Manipulation with libyang schema data structures\n *\n * Copyright (c) 2015 - 2018 CESNET, z.s.p.o.\n *\n * This source code is licensed under BSD 3-Clause License (the \"License\").\n * You may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/BSD-3-Clause\n */\n\n#define _GNU_SOURCE\n\n#ifdef __APPLE__\n#   include <sys/param.h>\n#endif\n#include <assert.h>\n#include <ctype.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <dirent.h>\n\n#include \"common.h\"\n#include \"context.h\"\n#include \"parser.h\"\n#include \"resolve.h\"\n#include \"xml.h\"\n#include \"xpath.h\"\n#include \"xml_internal.h\"\n#include \"tree_internal.h\"\n#include \"validation.h\"\n#include \"parser_yang.h\"\n\nstatic int lys_type_dup(struct lys_module *mod, struct lys_node *parent, struct lys_type *new, struct lys_type *old,\n                        int in_grp, int shallow, struct unres_schema *unres);\n\nAPI const struct lys_node_list *\nlys_is_key(const struct lys_node_leaf *node, uint8_t *index)\n{\n    struct lys_node *parent = (struct lys_node *)node;\n    struct lys_node_list *list;\n    uint8_t i;\n\n    if (!node || node->nodetype != LYS_LEAF) {\n        return NULL;\n    }\n\n    do {\n        parent = lys_parent(parent);\n    } while (parent && parent->nodetype == LYS_USES);\n\n    if (!parent || parent->nodetype != LYS_LIST) {\n        return NULL;\n    }\n\n    list = (struct lys_node_list*)parent;\n    for (i = 0; i < list->keys_size; i++) {\n        if (list->keys[i] == node) {\n            if (index) {\n                (*index) = i;\n            }\n            return list;\n        }\n    }\n    return NULL;\n}\n\nAPI const struct lys_node *\nlys_is_disabled(const struct lys_node *node, int recursive)\n{\n    int i;\n\n    if (!node) {\n        return NULL;\n    }\n\ncheck:\n    if (node->nodetype != LYS_INPUT && node->nodetype != LYS_OUTPUT) {\n        /* input/output does not have if-feature, so skip them */\n\n        /* check local if-features */\n        for (i = 0; i < node->iffeature_size; i++) {\n            if (!resolve_iffeature(&node->iffeature[i])) {\n                return node;\n            }\n        }\n    }\n\n    if (!recursive) {\n        return NULL;\n    }\n\n    /* go through parents */\n    if (node->nodetype == LYS_AUGMENT) {\n        /* go to parent actually means go to the target node */\n        node = ((struct lys_node_augment *)node)->target;\n        if (!node) {\n            /* unresolved augment, let's say it's enabled */\n            return NULL;\n        }\n    } else if (node->nodetype == LYS_EXT) {\n        return NULL;\n    } else if (node->parent) {\n        node = node->parent;\n    } else {\n        return NULL;\n    }\n\n    if (recursive == 2) {\n        /* continue only if the node cannot have a data instance */\n        if (node->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST)) {\n            return NULL;\n        }\n    }\n    goto check;\n}\n\nAPI const struct lys_type *\nlys_getnext_union_type(const struct lys_type *last, const struct lys_type *type)\n{\n    int found = 0;\n\n    if (!type || (type->base != LY_TYPE_UNION)) {\n        return NULL;\n    }\n\n    return lyp_get_next_union_type((struct lys_type *)type, (struct lys_type *)last, &found);\n}\n\nint\nlys_get_sibling(const struct lys_node *siblings, const char *mod_name, int mod_name_len, const char *name,\n                int nam_len, LYS_NODE type, const struct lys_node **ret)\n{\n    const struct lys_node *node, *parent = NULL;\n    const struct lys_module *mod = NULL;\n    const char *node_mod_name;\n\n    assert(siblings && mod_name && name);\n    assert(!(type & (LYS_USES | LYS_GROUPING)));\n\n    /* fill the lengths in case the caller is so indifferent */\n    if (!mod_name_len) {\n        mod_name_len = strlen(mod_name);\n    }\n    if (!nam_len) {\n        nam_len = strlen(name);\n    }\n\n    while (siblings && (siblings->nodetype == LYS_USES)) {\n        siblings = siblings->child;\n    }\n    if (!siblings) {\n        /* unresolved uses */\n        return EXIT_FAILURE;\n    }\n\n    if (siblings->nodetype == LYS_GROUPING) {\n        for (node = siblings; (node->nodetype == LYS_GROUPING) && (node->prev != siblings); node = node->prev);\n        if (node->nodetype == LYS_GROUPING) {\n            /* we went through all the siblings, only groupings there - no valid sibling */\n            return EXIT_FAILURE;\n        }\n        /* update siblings to be valid */\n        siblings = node;\n    }\n\n    /* set parent correctly */\n    parent = lys_parent(siblings);\n\n    /* go up all uses */\n    while (parent && (parent->nodetype == LYS_USES)) {\n        parent = lys_parent(parent);\n    }\n\n    if (!parent) {\n        /* handle situation when there is a top-level uses referencing a foreign grouping */\n        for (node = siblings; lys_parent(node) && (node->nodetype == LYS_USES); node = lys_parent(node));\n        mod = lys_node_module(node);\n    }\n\n    /* try to find the node */\n    node = NULL;\n    while ((node = lys_getnext(node, parent, mod, LYS_GETNEXT_WITHCHOICE | LYS_GETNEXT_WITHCASE | LYS_GETNEXT_WITHINOUT))) {\n        if (!type || (node->nodetype & type)) {\n            /* module name comparison */\n            node_mod_name = lys_node_module(node)->name;\n            if (!ly_strequal(node_mod_name, mod_name, 1) && (strncmp(node_mod_name, mod_name, mod_name_len) || node_mod_name[mod_name_len])) {\n                continue;\n            }\n\n            /* direct name check */\n            if (ly_strequal(node->name, name, 1) || (!strncmp(node->name, name, nam_len) && !node->name[nam_len])) {\n                if (ret) {\n                    *ret = node;\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    }\n\n    return EXIT_FAILURE;\n}\n\nint\nlys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,\n                 LYS_NODE type, int getnext_opts, const struct lys_node **ret)\n{\n    const struct lys_node *node;\n\n    assert((mod || parent) && name);\n    assert(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));\n\n    if (!mod) {\n        mod = lys_node_module(parent);\n    }\n\n    /* try to find the node */\n    node = NULL;\n    while ((node = lys_getnext(node, parent, mod, getnext_opts))) {\n        if (!type || (node->nodetype & type)) {\n            /* module check */\n            if (lys_node_module(node) != lys_main_module(mod)) {\n                continue;\n            }\n\n            /* direct name check */\n            if (!strncmp(node->name, name, nam_len) && !node->name[nam_len]) {\n                if (ret) {\n                    *ret = node;\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    }\n\n    return EXIT_FAILURE;\n}\n\nAPI const struct lys_node *\nlys_getnext(const struct lys_node *last, const struct lys_node *parent, const struct lys_module *module, int options)\n{\n    const struct lys_node *next, *aug_parent;\n    struct lys_node **snode;\n\n    if ((!parent && !module) || (module && module->type) || (parent && (parent->nodetype == LYS_USES) && !(options & LYS_GETNEXT_PARENTUSES))) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (!last) {\n        /* first call */\n\n        /* get know where to start */\n        if (parent) {\n            /* schema subtree */\n            snode = lys_child(parent, LYS_UNKNOWN);\n            /* do not return anything if the augment does not have any children */\n            if (!snode || !(*snode) || ((parent->nodetype == LYS_AUGMENT) && ((*snode)->parent != parent))) {\n                return NULL;\n            }\n            next = last = *snode;\n        } else {\n            /* top level data */\n            if (!(options & LYS_GETNEXT_NOSTATECHECK) && (module->disabled || !module->implemented)) {\n                /* nothing to return from a disabled/imported module */\n                return NULL;\n            }\n            next = last = module->data;\n        }\n    } else if ((last->nodetype == LYS_USES) && (options & LYS_GETNEXT_INTOUSES) && last->child) {\n        /* continue with uses content */\n        next = last->child;\n    } else {\n        /* continue after the last returned value */\n        next = last->next;\n    }\n\nrepeat:\n    if (parent && (parent->nodetype == LYS_AUGMENT) && next) {\n        /* do not return anything outside the parent augment */\n        aug_parent = next->parent;\n        do {\n            while (aug_parent && (aug_parent->nodetype != LYS_AUGMENT)) {\n                aug_parent = aug_parent->parent;\n            }\n            if (aug_parent) {\n                if (aug_parent == parent) {\n                    break;\n                }\n                aug_parent = ((struct lys_node_augment *)aug_parent)->target;\n            }\n\n        } while (aug_parent);\n        if (!aug_parent) {\n            return NULL;\n        }\n    }\n    while (next && (next->nodetype == LYS_GROUPING)) {\n        if (options & LYS_GETNEXT_WITHGROUPING) {\n            return next;\n        }\n        next = next->next;\n    }\n\n    if (!next) {     /* cover case when parent is augment */\n        if (!last || last->parent == parent || lys_parent(last) == parent) {\n            /* no next element */\n            return NULL;\n        }\n        last = lys_parent(last);\n        next = last->next;\n        goto repeat;\n    } else {\n        last = next;\n    }\n\n    if (!(options & LYS_GETNEXT_NOSTATECHECK) && lys_is_disabled(next, 0)) {\n        next = next->next;\n        goto repeat;\n    }\n\n    switch (next->nodetype) {\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        if (options & LYS_GETNEXT_WITHINOUT) {\n            return next;\n        } else if (next->child) {\n            next = next->child;\n        } else {\n            next = next->next;\n        }\n        goto repeat;\n\n    case LYS_CASE:\n        if (options & LYS_GETNEXT_WITHCASE) {\n            return next;\n        } else if (next->child) {\n            next = next->child;\n        } else {\n            next = next->next;\n        }\n        goto repeat;\n\n    case LYS_USES:\n        /* go into */\n        if (options & LYS_GETNEXT_WITHUSES) {\n            return next;\n        } else if (next->child) {\n            next = next->child;\n        } else {\n            next = next->next;\n        }\n        goto repeat;\n\n    case LYS_RPC:\n    case LYS_ACTION:\n    case LYS_NOTIF:\n    case LYS_LEAF:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n    case LYS_LIST:\n    case LYS_LEAFLIST:\n        return next;\n\n    case LYS_CONTAINER:\n        if (!((struct lys_node_container *)next)->presence && (options & LYS_GETNEXT_INTONPCONT)) {\n            if (next->child) {\n                /* go into */\n                next = next->child;\n            } else {\n                next = next->next;\n            }\n            goto repeat;\n        } else {\n            return next;\n        }\n\n    case LYS_CHOICE:\n        if (options & LYS_GETNEXT_WITHCHOICE) {\n            return next;\n        } else if (next->child) {\n            /* go into */\n            next = next->child;\n        } else {\n            next = next->next;\n        }\n        goto repeat;\n\n    default:\n        /* we should not be here */\n        return NULL;\n    }\n}\n\nvoid\nlys_node_unlink(struct lys_node *node)\n{\n    struct lys_node *parent, *first, **pp = NULL;\n    struct lys_module *main_module;\n\n    if (!node) {\n        return;\n    }\n\n    /* unlink from data model if necessary */\n    if (node->module) {\n        /* get main module with data tree */\n        main_module = lys_node_module(node);\n        if (main_module->data == node) {\n            main_module->data = node->next;\n        }\n    }\n\n    /* store pointers to important nodes */\n    parent = node->parent;\n    if (parent && (parent->nodetype == LYS_AUGMENT)) {\n        /* handle augments - first, unlink it from the augment parent ... */\n        if (parent->child == node) {\n            parent->child = (node->next && node->next->parent == parent) ? node->next : NULL;\n        }\n\n        if (parent->flags & LYS_NOTAPPLIED) {\n            /* data are not connected in the target, so we cannot continue with the target as a parent */\n            parent = NULL;\n        } else {\n            /* data are connected in target, so we will continue with the target as a parent */\n            parent = ((struct lys_node_augment *)parent)->target;\n        }\n    }\n\n    /* unlink from parent */\n    if (parent) {\n        if (parent->nodetype == LYS_EXT) {\n            pp = (struct lys_node **)lys_ext_complex_get_substmt(lys_snode2stmt(node->nodetype),\n                                                                 (struct lys_ext_instance_complex*)parent, NULL);\n            if (*pp == node) {\n                *pp = node->next;\n            }\n        } else if (parent->child == node) {\n            parent->child = node->next;\n        }\n        node->parent = NULL;\n    }\n\n    /* unlink from siblings */\n    if (node->prev == node) {\n        /* there are no more siblings */\n        return;\n    }\n    if (node->next) {\n        node->next->prev = node->prev;\n    } else {\n        /* unlinking the last element */\n        if (parent) {\n            if (parent->nodetype == LYS_EXT) {\n                first = *(struct lys_node **)pp;\n            } else {\n                first = parent->child;\n            }\n        } else {\n            first = node;\n            while (first->prev->next) {\n                first = first->prev;\n            }\n        }\n        first->prev = node->prev;\n    }\n    if (node->prev->next) {\n        node->prev->next = node->next;\n    }\n\n    /* clean up the unlinked element */\n    node->next = NULL;\n    node->prev = node;\n}\n\nstruct lys_node_grp *\nlys_find_grouping_up(const char *name, struct lys_node *start)\n{\n    struct lys_node *par_iter, *iter, *stop;\n\n    for (par_iter = start; par_iter; par_iter = par_iter->parent) {\n        /* top-level augment, look into module (uses augment is handled correctly below) */\n        if (par_iter->parent && !par_iter->parent->parent && (par_iter->parent->nodetype == LYS_AUGMENT)) {\n            par_iter = lys_main_module(par_iter->parent->module)->data;\n            if (!par_iter) {\n                break;\n            }\n        }\n\n        if (par_iter->nodetype == LYS_EXT) {\n            /* we are in a top-level extension, search grouping in top-level groupings */\n            par_iter = lys_main_module(par_iter->module)->data;\n            if (!par_iter) {\n                /* not connected yet, wait */\n                return NULL;\n            }\n        } else if (par_iter->parent && (par_iter->parent->nodetype & (LYS_CHOICE | LYS_CASE | LYS_AUGMENT | LYS_USES))) {\n            continue;\n        }\n\n        for (iter = par_iter, stop = NULL; iter; iter = iter->prev) {\n            if (!stop) {\n                stop = par_iter;\n            } else if (iter == stop) {\n                break;\n            }\n            if (iter->nodetype != LYS_GROUPING) {\n                continue;\n            }\n\n            if (!strcmp(name, iter->name)) {\n                return (struct lys_node_grp *)iter;\n            }\n        }\n    }\n\n    return NULL;\n}\n\n/*\n * get next grouping in the root's subtree, in the\n * first call, tha last is NULL\n */\nstatic struct lys_node_grp *\nlys_get_next_grouping(struct lys_node_grp *lastgrp, struct lys_node *root)\n{\n    struct lys_node *last = (struct lys_node *)lastgrp;\n    struct lys_node *next;\n\n    assert(root);\n\n    if (!last) {\n        last = root;\n    }\n\n    while (1) {\n        if ((last->nodetype & (LYS_CONTAINER | LYS_CHOICE | LYS_LIST | LYS_GROUPING | LYS_INPUT | LYS_OUTPUT))) {\n            next = last->child;\n        } else {\n            next = NULL;\n        }\n        if (!next) {\n            if (last == root) {\n                /* we are done */\n                return NULL;\n            }\n\n            /* no children, go to siblings */\n            next = last->next;\n        }\n        while (!next) {\n            /* go back through parents */\n            if (lys_parent(last) == root) {\n                /* we are done */\n                return NULL;\n            }\n            next = last->next;\n            last = lys_parent(last);\n        }\n\n        if (next->nodetype == LYS_GROUPING) {\n            return (struct lys_node_grp *)next;\n        }\n\n        last = next;\n    }\n}\n\n/* logs directly */\nint\nlys_check_id(struct lys_node *node, struct lys_node *parent, struct lys_module *module)\n{\n    struct lys_node *start, *stop, *iter;\n    struct lys_node_grp *grp;\n    int down, up;\n\n    assert(node);\n\n    if (!parent) {\n        assert(module);\n    } else {\n        module = parent->module;\n    }\n    module = lys_main_module(module);\n\n    switch (node->nodetype) {\n    case LYS_GROUPING:\n        /* 6.2.1, rule 6 */\n        if (parent) {\n            start = *lys_child(parent, LYS_GROUPING);\n            if (!start) {\n                down = 0;\n                start = parent;\n            } else {\n                down = 1;\n            }\n            if (parent->nodetype == LYS_EXT) {\n                up = 0;\n            } else {\n                up = 1;\n            }\n        } else {\n            down = up = 1;\n            start = module->data;\n        }\n        /* go up */\n        if (up && lys_find_grouping_up(node->name, start)) {\n            LOGVAL(module->ctx, LYE_DUPID, LY_VLOG_LYS, node, \"grouping\", node->name);\n            return EXIT_FAILURE;\n        }\n        /* go down, because grouping can be defined after e.g. container in which is collision */\n        if (down) {\n            for (iter = start, stop = NULL; iter; iter = iter->prev) {\n                if (!stop) {\n                    stop = start;\n                } else if (iter == stop) {\n                    break;\n                }\n                if (!(iter->nodetype & (LYS_CONTAINER | LYS_CHOICE | LYS_LIST | LYS_GROUPING | LYS_INPUT | LYS_OUTPUT))) {\n                    continue;\n                }\n\n                grp = NULL;\n                while ((grp = lys_get_next_grouping(grp, iter))) {\n                    if (ly_strequal(node->name, grp->name, 1)) {\n                        LOGVAL(module->ctx, LYE_DUPID,LY_VLOG_LYS, node, \"grouping\", node->name);\n                        return EXIT_FAILURE;\n                    }\n                }\n            }\n        }\n        break;\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n    case LYS_LIST:\n    case LYS_CONTAINER:\n    case LYS_CHOICE:\n    case LYS_ANYDATA:\n        /* 6.2.1, rule 7 */\n        if (parent) {\n            iter = parent;\n            while (iter && (iter->nodetype & (LYS_USES | LYS_CASE | LYS_CHOICE | LYS_AUGMENT))) {\n                if (iter->nodetype == LYS_AUGMENT) {\n                    if (((struct lys_node_augment *)iter)->target) {\n                        /* augment is resolved, go up */\n                        iter = ((struct lys_node_augment *)iter)->target;\n                        continue;\n                    }\n                    /* augment is not resolved, this is the final parent */\n                    break;\n                }\n                iter = iter->parent;\n            }\n\n            if (!iter) {\n                stop = NULL;\n                iter = module->data;\n            } else if (iter->nodetype == LYS_EXT) {\n                stop = iter;\n                iter = (struct lys_node *)lys_child(iter, node->nodetype);\n                if (iter) {\n                    iter = *(struct lys_node **)iter;\n                }\n            } else {\n                stop = iter;\n                iter = iter->child;\n            }\n        } else {\n            stop = NULL;\n            iter = module->data;\n        }\n        while (iter) {\n            if (iter->nodetype & (LYS_USES | LYS_CASE)) {\n                iter = iter->child;\n                continue;\n            }\n\n            if (iter->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_CONTAINER | LYS_CHOICE | LYS_ANYDATA)) {\n                if (iter->module == node->module && ly_strequal(iter->name, node->name, 1)) {\n                    LOGVAL(module->ctx, LYE_DUPID, LY_VLOG_LYS, node, strnodetype(node->nodetype), node->name);\n                    return EXIT_FAILURE;\n                }\n            }\n\n            /* special case for choice - we must check the choice's name as\n             * well as the names of nodes under the choice\n             */\n            if (iter->nodetype == LYS_CHOICE) {\n                iter = iter->child;\n                continue;\n            }\n\n            /* go to siblings */\n            if (!iter->next) {\n                /* no sibling, go to parent's sibling */\n                do {\n                    /* for parent LYS_AUGMENT */\n                    if (iter->parent == stop) {\n                        iter = stop;\n                        break;\n                    }\n                    iter = lys_parent(iter);\n                    if (iter && iter->next) {\n                        break;\n                    }\n                } while (iter != stop);\n\n                if (iter == stop) {\n                    break;\n                }\n            }\n            iter = iter->next;\n        }\n        break;\n    case LYS_CASE:\n        /* 6.2.1, rule 8 */\n        if (parent) {\n            start = *lys_child(parent, LYS_CASE);\n        } else {\n            start = module->data;\n        }\n\n        LY_TREE_FOR(start, iter) {\n            if (!(iter->nodetype & (LYS_ANYDATA | LYS_CASE | LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST))) {\n                continue;\n            }\n\n            if (iter->module == node->module && ly_strequal(iter->name, node->name, 1)) {\n                LOGVAL(module->ctx, LYE_DUPID, LY_VLOG_LYS, node, \"case\", node->name);\n                return EXIT_FAILURE;\n            }\n        }\n        break;\n    default:\n        /* no check needed */\n        break;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* logs directly */\nint\nlys_node_addchild(struct lys_node *parent, struct lys_module *module, struct lys_node *child, int options)\n{\n    struct ly_ctx *ctx = child->module->ctx;\n    struct lys_node *iter, **pchild, *log_parent;\n    struct lys_node_inout *in, *out;\n    struct lys_node_case *c;\n    int type, shortcase = 0;\n    void *p;\n    struct lyext_substmt *info = NULL;\n\n    assert(child);\n\n    if (parent) {\n        type = parent->nodetype;\n        module = parent->module;\n        log_parent = parent;\n\n        if (type == LYS_USES) {\n            /* we are adding children to uses -> we must be copying grouping contents into it, so properly check the parent */\n            log_parent = lys_parent(log_parent);\n            while (log_parent && (log_parent->nodetype == LYS_USES)) {\n                log_parent = lys_parent(log_parent);\n            }\n            if (log_parent) {\n                type = log_parent->nodetype;\n            } else {\n                type = 0;\n            }\n        }\n    } else {\n        assert(module);\n        assert(!(child->nodetype & (LYS_INPUT | LYS_OUTPUT)));\n        type = 0;\n        log_parent = NULL;\n    }\n\n    /* checks */\n    switch (type) {\n    case LYS_CONTAINER:\n    case LYS_LIST:\n    case LYS_GROUPING:\n    case LYS_USES:\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CHOICE | LYS_CONTAINER | LYS_GROUPING | LYS_LEAF |\n                 LYS_LEAFLIST | LYS_LIST | LYS_USES | LYS_ACTION | LYS_NOTIF))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), strnodetype(log_parent->nodetype));\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n    case LYS_NOTIF:\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CHOICE | LYS_CONTAINER | LYS_GROUPING | LYS_LEAF |\n                 LYS_LEAFLIST | LYS_LIST | LYS_USES))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), strnodetype(log_parent->nodetype));\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_CHOICE:\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CASE | LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_CHOICE))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), \"choice\");\n            return EXIT_FAILURE;\n        }\n        if (child->nodetype != LYS_CASE) {\n            shortcase = 1;\n        }\n        break;\n    case LYS_CASE:\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CHOICE | LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_USES))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), \"case\");\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_RPC:\n    case LYS_ACTION:\n        if (!(child->nodetype & (LYS_INPUT | LYS_OUTPUT | LYS_GROUPING))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), \"rpc\");\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), strnodetype(log_parent->nodetype));\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"The \\\"%s\\\" statement cannot have any data substatement.\",\n               strnodetype(log_parent->nodetype));\n        return EXIT_FAILURE;\n    case LYS_AUGMENT:\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CASE | LYS_CHOICE | LYS_CONTAINER | LYS_LEAF\n                | LYS_LEAFLIST | LYS_LIST | LYS_USES | LYS_ACTION | LYS_NOTIF))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), strnodetype(log_parent->nodetype));\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_UNKNOWN:\n        /* top level */\n        if (!(child->nodetype &\n                (LYS_ANYDATA | LYS_CHOICE | LYS_CONTAINER | LYS_LEAF | LYS_GROUPING\n                | LYS_LEAFLIST | LYS_LIST | LYS_USES | LYS_RPC | LYS_NOTIF | LYS_AUGMENT))) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype), \"(sub)module\");\n            return EXIT_FAILURE;\n        }\n        break;\n    case LYS_EXT:\n        /* plugin-defined */\n        p = lys_ext_complex_get_substmt(lys_snode2stmt(child->nodetype), (struct lys_ext_instance_complex*)log_parent, &info);\n        if (!p) {\n            LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, log_parent, strnodetype(child->nodetype),\n                   ((struct lys_ext_instance_complex*)log_parent)->def->name);\n            return EXIT_FAILURE;\n        }\n        /* TODO check cardinality */\n        break;\n    }\n\n    /* check identifier uniqueness */\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && lys_check_id(child, parent, module)) {\n        return EXIT_FAILURE;\n    }\n\n    if (child->parent) {\n        lys_node_unlink(child);\n    }\n\n    if ((child->nodetype & (LYS_INPUT | LYS_OUTPUT)) && parent->nodetype != LYS_EXT) {\n        /* find the implicit input/output node */\n        LY_TREE_FOR(parent->child, iter) {\n            if (iter->nodetype == child->nodetype) {\n                break;\n            }\n        }\n        assert(iter);\n\n        /* switch the old implicit node (iter) with the new one (child) */\n        if (parent->child == iter) {\n            /* first child */\n            parent->child = child;\n        } else {\n            iter->prev->next = child;\n        }\n        child->prev = iter->prev;\n        child->next = iter->next;\n        if (iter->next) {\n            iter->next->prev = child;\n        } else {\n            /* last child */\n            parent->child->prev = child;\n        }\n        child->parent = parent;\n\n        /* isolate the node and free it */\n        iter->next = NULL;\n        iter->prev = iter;\n        iter->parent = NULL;\n        lys_node_free(iter, NULL, 0);\n    } else {\n        if (shortcase) {\n            /* create the implicit case to allow it to serve as a target of the augments,\n             * it won't be printed, but it will be present in the tree */\n            c = calloc(1, sizeof *c);\n            LY_CHECK_ERR_RETURN(!c, LOGMEM(ctx), EXIT_FAILURE);\n            c->name = lydict_insert(module->ctx, child->name, 0);\n            c->flags = LYS_IMPLICIT;\n            if (!(options & (LYS_PARSE_OPT_CFG_IGNORE | LYS_PARSE_OPT_CFG_NOINHERIT))) {\n                /* get config flag from parent */\n                c->flags |= parent->flags & LYS_CONFIG_MASK;\n            }\n            c->module = module;\n            c->nodetype = LYS_CASE;\n            c->prev = (struct lys_node*)c;\n            lys_node_addchild(parent, module, (struct lys_node*)c, options);\n            parent = (struct lys_node*)c;\n        }\n        /* connect the child correctly */\n        if (!parent) {\n            if (module->data) {\n                module->data->prev->next = child;\n                child->prev = module->data->prev;\n                module->data->prev = child;\n            } else {\n                module->data = child;\n            }\n        } else {\n            pchild = lys_child(parent, child->nodetype);\n            assert(pchild);\n\n            child->parent = parent;\n            if (!(*pchild)) {\n                /* the only/first child of the parent */\n                *pchild = child;\n                iter = child;\n            } else {\n                /* add a new child at the end of parent's child list */\n                iter = (*pchild)->prev;\n                iter->next = child;\n                child->prev = iter;\n            }\n            while (iter->next) {\n                iter = iter->next;\n                iter->parent = parent;\n            }\n            (*pchild)->prev = iter;\n        }\n    }\n\n    /* check config value (but ignore them in groupings and augments) */\n    for (iter = parent; iter && !(iter->nodetype & (LYS_GROUPING | LYS_AUGMENT | LYS_EXT)); iter = iter->parent);\n    if (parent && !iter) {\n        for (iter = child; iter && !(iter->nodetype & (LYS_NOTIF | LYS_INPUT | LYS_OUTPUT | LYS_RPC)); iter = iter->parent);\n        if (!iter && (parent->flags & LYS_CONFIG_R) && (child->flags & LYS_CONFIG_W)) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, child, \"true\", \"config\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"State nodes cannot have configuration nodes as children.\");\n            return EXIT_FAILURE;\n        }\n    }\n\n    /* propagate information about status data presence */\n    if ((child->nodetype & (LYS_CONTAINER | LYS_CHOICE | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_ANYDATA)) &&\n            (child->flags & LYS_INCL_STATUS)) {\n        for(iter = parent; iter; iter = lys_parent(iter)) {\n            /* store it only into container or list - the only data inner nodes */\n            if (iter->nodetype & (LYS_CONTAINER | LYS_LIST)) {\n                if (iter->flags & LYS_INCL_STATUS) {\n                    /* done, someone else set it already from here */\n                    break;\n                }\n                /* set flag about including status data */\n                iter->flags |= LYS_INCL_STATUS;\n            }\n        }\n    }\n\n    /* create implicit input/output nodes to have available them as possible target for augment */\n    if ((child->nodetype & (LYS_RPC | LYS_ACTION)) && !child->child) {\n        in = calloc(1, sizeof *in);\n        out = calloc(1, sizeof *out);\n        if (!in || !out) {\n            LOGMEM(ctx);\n            free(in);\n            free(out);\n            return EXIT_FAILURE;\n        }\n        in->nodetype = LYS_INPUT;\n        in->name = lydict_insert(child->module->ctx, \"input\", 5);\n        out->nodetype = LYS_OUTPUT;\n        out->name = lydict_insert(child->module->ctx, \"output\", 6);\n        in->module = out->module = child->module;\n        in->parent = out->parent = child;\n        in->flags = out->flags = LYS_IMPLICIT;\n        in->next = (struct lys_node *)out;\n        in->prev = (struct lys_node *)out;\n        out->prev = (struct lys_node *)in;\n        child->child = (struct lys_node *)in;\n    }\n    return EXIT_SUCCESS;\n}\n\nconst struct lys_module *\nlys_parse_mem_(struct ly_ctx *ctx, const char *data, LYS_INFORMAT format, const char *revision, int internal, int implement)\n{\n    char *enlarged_data = NULL;\n    struct lys_module *mod = NULL;\n    unsigned int len;\n\n    if (!ctx || !data) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (!internal && format == LYS_IN_YANG) {\n        /* enlarge data by 2 bytes for flex */\n        len = strlen(data);\n        enlarged_data = malloc((len + 2) * sizeof *enlarged_data);\n        LY_CHECK_ERR_RETURN(!enlarged_data, LOGMEM(ctx), NULL);\n        memcpy(enlarged_data, data, len);\n        enlarged_data[len] = enlarged_data[len + 1] = '\\0';\n        data = enlarged_data;\n    }\n\n    switch (format) {\n    case LYS_IN_YIN:\n        mod = yin_read_module(ctx, data, revision, implement);\n        break;\n    case LYS_IN_YANG:\n        mod = yang_read_module(ctx, data, 0, revision, implement);\n        break;\n    default:\n        LOGERR(ctx, LY_EINVAL, \"Invalid schema input format.\");\n        break;\n    }\n\n    free(enlarged_data);\n\n    /* hack for NETCONF's edit-config's operation attribute. It is not defined in the schema, but since libyang\n     * implements YANG metadata (annotations), we need its definition. Because the ietf-netconf schema is not the\n     * internal part of libyang, we cannot add the annotation into the schema source, but we do it here to have\n     * the anotation definitions available in the internal schema structure. There is another hack in schema\n     * printers to do not print this internally added annotation. */\n    if (mod && ly_strequal(mod->name, \"ietf-netconf\", 0)) {\n        if (lyp_add_ietf_netconf_annotations_config(mod)) {\n            lys_free(mod, NULL, 1, 1);\n            return NULL;\n        }\n    }\n\n    return mod;\n}\n\nAPI const struct lys_module *\nlys_parse_mem(struct ly_ctx *ctx, const char *data, LYS_INFORMAT format)\n{\n    return lys_parse_mem_(ctx, data, format, NULL, 0, 1);\n}\n\nstruct lys_submodule *\nlys_sub_parse_mem(struct lys_module *module, const char *data, LYS_INFORMAT format, struct unres_schema *unres)\n{\n    char *enlarged_data = NULL;\n    struct lys_submodule *submod = NULL;\n    unsigned int len;\n\n    assert(module);\n    assert(data);\n\n    if (format == LYS_IN_YANG) {\n        /* enlarge data by 2 bytes for flex */\n        len = strlen(data);\n        enlarged_data = malloc((len + 2) * sizeof *enlarged_data);\n        LY_CHECK_ERR_RETURN(!enlarged_data, LOGMEM(module->ctx), NULL);\n        memcpy(enlarged_data, data, len);\n        enlarged_data[len] = enlarged_data[len + 1] = '\\0';\n        data = enlarged_data;\n    }\n\n    /* get the main module */\n    module = lys_main_module(module);\n\n    switch (format) {\n    case LYS_IN_YIN:\n        submod = yin_read_submodule(module, data, unres);\n        break;\n    case LYS_IN_YANG:\n        submod = yang_read_submodule(module, data, 0, unres);\n        break;\n    default:\n        assert(0);\n        break;\n    }\n\n    free(enlarged_data);\n    return submod;\n}\n\nAPI const struct lys_module *\nlys_parse_path(struct ly_ctx *ctx, const char *path, LYS_INFORMAT format)\n{\n    int fd;\n    const struct lys_module *ret;\n    const char *rev, *dot, *filename;\n    size_t len;\n\n    if (!ctx || !path) {\n        LOGARG;\n        return NULL;\n    }\n\n    fd = open(path, O_RDONLY);\n    if (fd == -1) {\n        LOGERR(ctx, LY_ESYS, \"Opening file \\\"%s\\\" failed (%s).\", path, strerror(errno));\n        return NULL;\n    }\n\n    ret = lys_parse_fd(ctx, fd, format);\n    close(fd);\n\n    if (!ret) {\n        /* error */\n        return NULL;\n    }\n\n    /* check that name and revision match filename */\n    filename = strrchr(path, '/');\n    if (!filename) {\n        filename = path;\n    } else {\n        filename++;\n    }\n    rev = strchr(filename, '@');\n    dot = strrchr(filename, '.');\n\n    /* name */\n    len = strlen(ret->name);\n    if (strncmp(filename, ret->name, len) ||\n            ((rev && rev != &filename[len]) || (!rev && dot != &filename[len]))) {\n        LOGWRN(ctx, \"File name \\\"%s\\\" does not match module name \\\"%s\\\".\", filename, ret->name);\n    }\n    if (rev) {\n        len = dot - ++rev;\n        if (!ret->rev_size || len != 10 || strncmp(ret->rev[0].date, rev, len)) {\n            LOGWRN(ctx, \"File name \\\"%s\\\" does not match module revision \\\"%s\\\".\", filename,\n                   ret->rev_size ? ret->rev[0].date : \"none\");\n        }\n    }\n\n    if (!ret->filepath) {\n        /* store URI */\n        char rpath[PATH_MAX];\n        if (realpath(path, rpath) != NULL) {\n            ((struct lys_module *)ret)->filepath = lydict_insert(ctx, rpath, 0);\n        } else {\n            ((struct lys_module *)ret)->filepath = lydict_insert(ctx, path, 0);\n        }\n    }\n\n    return ret;\n}\n\nAPI const struct lys_module *\nlys_parse_fd(struct ly_ctx *ctx, int fd, LYS_INFORMAT format)\n{\n    return lys_parse_fd_(ctx, fd, format, NULL, 1);\n}\n\nstatic void\nlys_parse_set_filename(struct ly_ctx *ctx, const char **filename, int fd)\n{\n#ifdef __APPLE__\n    char path[MAXPATHLEN];\n#else\n    int len;\n    char path[PATH_MAX], proc_path[32];\n#endif\n\n#ifdef __APPLE__\n    if (fcntl(fd, F_GETPATH, path) != -1) {\n        *filename = lydict_insert(ctx, path, 0);\n    }\n#else\n    /* get URI if there is /proc */\n    sprintf(proc_path, \"/proc/self/fd/%d\", fd);\n    if ((len = readlink(proc_path, path, PATH_MAX - 1)) > 0) {\n        *filename = lydict_insert(ctx, path, len);\n    }\n#endif\n}\n\nconst struct lys_module *\nlys_parse_fd_(struct ly_ctx *ctx, int fd, LYS_INFORMAT format, const char *revision, int implement)\n{\n    const struct lys_module *module;\n    size_t length;\n    char *addr;\n\n    if (!ctx || fd < 0) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (lyp_mmap(ctx, fd, format == LYS_IN_YANG ? 1 : 0, &length, (void **)&addr)) {\n        LOGERR(ctx, LY_ESYS, \"Mapping file descriptor into memory failed (%s()).\", __func__);\n        return NULL;\n    } else if (!addr) {\n        LOGERR(ctx, LY_EINVAL, \"Empty schema file.\");\n        return NULL;\n    }\n\n    module = lys_parse_mem_(ctx, addr, format, revision, 1, implement);\n    lyp_munmap(addr, length);\n\n    if (module && !module->filepath) {\n        lys_parse_set_filename(ctx, (const char **)&module->filepath, fd);\n    }\n\n    return module;\n}\n\nstruct lys_submodule *\nlys_sub_parse_fd(struct lys_module *module, int fd, LYS_INFORMAT format, struct unres_schema *unres)\n{\n    struct lys_submodule *submodule;\n    size_t length;\n    char *addr;\n\n    assert(module);\n    assert(fd >= 0);\n\n    if (lyp_mmap(module->ctx, fd, format == LYS_IN_YANG ? 1 : 0, &length, (void **)&addr)) {\n        LOGERR(module->ctx, LY_ESYS, \"Mapping file descriptor into memory failed (%s()).\", __func__);\n        return NULL;\n    } else if (!addr) {\n        LOGERR(module->ctx, LY_EINVAL, \"Empty submodule schema file.\");\n        return NULL;\n    }\n\n    /* get the main module */\n    module = lys_main_module(module);\n\n    switch (format) {\n    case LYS_IN_YIN:\n        submodule = yin_read_submodule(module, addr, unres);\n        break;\n    case LYS_IN_YANG:\n        submodule = yang_read_submodule(module, addr, 0, unres);\n        break;\n    default:\n        LOGINT(module->ctx);\n        return NULL;\n    }\n\n    lyp_munmap(addr, length);\n\n    if (submodule && !submodule->filepath) {\n        lys_parse_set_filename(module->ctx, (const char **)&submodule->filepath, fd);\n    }\n\n    return submodule;\n\n}\n\nAPI int\nlys_search_localfile(const char * const *searchpaths, int cwd, const char *name, const char *revision, char **localfile, LYS_INFORMAT *format)\n{\n    size_t len, flen, match_len = 0, dir_len;\n    int i, implicit_cwd = 0, ret = EXIT_FAILURE;\n    char *wd, *wn = NULL;\n    DIR *dir = NULL;\n    struct dirent *file;\n    char *match_name = NULL;\n    LYS_INFORMAT format_aux, match_format = 0;\n    unsigned int u;\n    struct ly_set *dirs;\n    struct stat st;\n\n    if (!localfile) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    /* start to fill the dir fifo with the context's search path (if set)\n     * and the current working directory */\n    dirs = ly_set_new();\n    if (!dirs) {\n        LOGMEM(NULL);\n        return EXIT_FAILURE;\n    }\n\n    len = strlen(name);\n    if (cwd) {\n        wd = get_current_dir_name();\n        if (!wd) {\n            LOGMEM(NULL);\n            goto cleanup;\n        } else {\n            /* add implicit current working directory (./) to be searched,\n             * this directory is not searched recursively */\n            if (ly_set_add(dirs, wd, 0) == -1) {\n                goto cleanup;\n            }\n            implicit_cwd = 1;\n        }\n    }\n    if (searchpaths) {\n        for (i = 0; searchpaths[i]; i++) {\n            /* check for duplicities with the implicit current working directory */\n            if (implicit_cwd && !strcmp(dirs->set.g[0], searchpaths[i])) {\n                implicit_cwd = 0;\n                continue;\n            }\n            wd = strdup(searchpaths[i]);\n            if (!wd) {\n                LOGMEM(NULL);\n                goto cleanup;\n            } else if (ly_set_add(dirs, wd, 0) == -1) {\n                goto cleanup;\n            }\n        }\n    }\n    wd = NULL;\n\n    /* start searching */\n    while (dirs->number) {\n        free(wd);\n        free(wn); wn = NULL;\n\n        dirs->number--;\n        wd = (char *)dirs->set.g[dirs->number];\n        dirs->set.g[dirs->number] = NULL;\n        LOGVRB(\"Searching for \\\"%s\\\" in %s.\", name, wd);\n\n        if (dir) {\n            closedir(dir);\n        }\n        dir = opendir(wd);\n        dir_len = strlen(wd);\n        if (!dir) {\n            LOGWRN(NULL, \"Unable to open directory \\\"%s\\\" for searching (sub)modules (%s).\", wd, strerror(errno));\n        } else {\n            while ((file = readdir(dir))) {\n                if (!strcmp(\".\", file->d_name) || !strcmp(\"..\", file->d_name)) {\n                    /* skip . and .. */\n                    continue;\n                }\n                free(wn);\n                if (asprintf(&wn, \"%s/%s\", wd, file->d_name) == -1) {\n                    LOGMEM(NULL);\n                    goto cleanup;\n                }\n                if (stat(wn, &st) == -1) {\n                    LOGWRN(NULL, \"Unable to get information about \\\"%s\\\" file in \\\"%s\\\" when searching for (sub)modules (%s)\",\n                           file->d_name, wd, strerror(errno));\n                    continue;\n                }\n                if (S_ISDIR(st.st_mode) && (dirs->number || !implicit_cwd)) {\n                    /* we have another subdirectory in searchpath to explore,\n                     * subdirectories are not taken into account in current working dir (dirs->set.g[0]) */\n                    if (ly_set_add(dirs, wn, 0) == -1) {\n                        goto cleanup;\n                    }\n                    /* continue with the next item in current directory */\n                    wn = NULL;\n                    continue;\n                } else if (!S_ISREG(st.st_mode)) {\n                    /* not a regular file (note that we see the target of symlinks instead of symlinks */\n                    continue;\n                }\n\n                /* here we know that the item is a file which can contain a module */\n                if (strncmp(name, file->d_name, len) ||\n                        (file->d_name[len] != '.' && file->d_name[len] != '@')) {\n                    /* different filename than the module we search for */\n                    continue;\n                }\n\n                /* get type according to filename suffix */\n                flen = strlen(file->d_name);\n                if (!strcmp(&file->d_name[flen - 4], \".yin\")) {\n                    format_aux = LYS_IN_YIN;\n                } else if (!strcmp(&file->d_name[flen - 5], \".yang\")) {\n                    format_aux = LYS_IN_YANG;\n                } else {\n                    /* not supportde suffix/file format */\n                    continue;\n                }\n\n                if (revision) {\n                    /* we look for the specific revision, try to get it from the filename */\n                    if (file->d_name[len] == '@') {\n                        /* check revision from the filename */\n                        if (strncmp(revision, &file->d_name[len + 1], strlen(revision))) {\n                            /* another revision */\n                            continue;\n                        } else {\n                            /* exact revision */\n                            free(match_name);\n                            match_name = wn;\n                            wn = NULL;\n                            match_len = dir_len + 1 + len;\n                            match_format = format_aux;\n                            goto success;\n                        }\n                    } else {\n                        /* continue trying to find exact revision match, use this only if not found */\n                        free(match_name);\n                        match_name = wn;\n                        wn = NULL;\n                        match_len = dir_len + 1 +len;\n                        match_format = format_aux;\n                        continue;\n                    }\n                } else {\n                    /* remember the revision and try to find the newest one */\n                    if (match_name) {\n                        if (file->d_name[len] != '@' || lyp_check_date(NULL, &file->d_name[len + 1])) {\n                            continue;\n                        } else if (match_name[match_len] == '@' &&\n                                (strncmp(&match_name[match_len + 1], &file->d_name[len + 1], LY_REV_SIZE - 1) >= 0)) {\n                            continue;\n                        }\n                        free(match_name);\n                    }\n\n                    match_name = wn;\n                    wn = NULL;\n                    match_len = dir_len + 1 + len;\n                    match_format = format_aux;\n                    continue;\n                }\n            }\n        }\n    }\n\nsuccess:\n    (*localfile) = match_name;\n    match_name = NULL;\n    if (format) {\n        (*format) = match_format;\n    }\n    ret = EXIT_SUCCESS;\n\ncleanup:\n    free(wn);\n    free(wd);\n    if (dir) {\n        closedir(dir);\n    }\n    free(match_name);\n    for (u = 0; u < dirs->number; u++) {\n        free(dirs->set.g[u]);\n    }\n    ly_set_free(dirs);\n\n    return ret;\n}\n\nint\nlys_ext_iter(struct lys_ext_instance **ext, uint8_t ext_size, uint8_t start, LYEXT_SUBSTMT substmt)\n{\n    unsigned int u;\n\n    for (u = start; u < ext_size; u++) {\n        if (ext[u]->insubstmt == substmt) {\n            return u;\n        }\n    }\n\n    return -1;\n}\n\n/*\n * duplicate extension instance\n */\nint\nlys_ext_dup(struct ly_ctx *ctx, struct lys_module *mod, struct lys_ext_instance **orig, uint8_t size, void *parent,\n            LYEXT_PAR parent_type, struct lys_ext_instance ***new, int shallow, struct unres_schema *unres)\n{\n    int i;\n    uint8_t u = 0;\n    struct lys_ext_instance **result;\n    struct unres_ext *info, *info_orig;\n    size_t len;\n\n    assert(new);\n\n    if (!size) {\n        if (orig) {\n            LOGINT(ctx);\n            return EXIT_FAILURE;\n        }\n        (*new) = NULL;\n        return EXIT_SUCCESS;\n    }\n\n    (*new) = result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(ctx), EXIT_FAILURE);\n    for (u = 0; u < size; u++) {\n        if (orig[u]) {\n            /* resolved extension instance, just duplicate it */\n            switch(orig[u]->ext_type) {\n            case LYEXT_FLAG:\n                result[u] = malloc(sizeof(struct lys_ext_instance));\n                LY_CHECK_ERR_GOTO(!result[u], LOGMEM(ctx), error);\n                break;\n            case LYEXT_COMPLEX:\n                len = ((struct lyext_plugin_complex*)orig[u]->def->plugin)->instance_size;\n                result[u] = calloc(1, len);\n                LY_CHECK_ERR_GOTO(!result[u], LOGMEM(ctx), error);\n\n                ((struct lys_ext_instance_complex*)result[u])->substmt = ((struct lyext_plugin_complex*)orig[u]->def->plugin)->substmt;\n                /* TODO duplicate data in extension instance content */\n                memcpy((void*)result[u] + sizeof(**orig), (void*)orig[u] + sizeof(**orig), len - sizeof(**orig));\n                break;\n            }\n            /* generic part */\n            result[u]->def = orig[u]->def;\n            result[u]->flags = LYEXT_OPT_CONTENT;\n            result[u]->arg_value = lydict_insert(ctx, orig[u]->arg_value, 0);\n            result[u]->parent = parent;\n            result[u]->parent_type = parent_type;\n            result[u]->insubstmt = orig[u]->insubstmt;\n            result[u]->insubstmt_index = orig[u]->insubstmt_index;\n            result[u]->ext_type = orig[u]->ext_type;\n            result[u]->priv = NULL;\n            result[u]->nodetype = LYS_EXT;\n            result[u]->module = mod;\n\n            /* extensions */\n            result[u]->ext_size = orig[u]->ext_size;\n            if (lys_ext_dup(ctx, mod, orig[u]->ext, orig[u]->ext_size, result[u],\n                            LYEXT_PAR_EXTINST, &result[u]->ext, shallow, unres)) {\n                goto error;\n            }\n\n            /* in case of shallow copy (duplication for deviation), duplicate only the link to private data\n             * in a new copy, otherwise (grouping instantiation) do not duplicate the private data */\n            if (shallow) {\n                result[u]->priv = orig[u]->priv;\n            }\n        } else {\n            /* original extension is not yet resolved, so duplicate it in unres */\n            i = unres_schema_find(unres, -1, &orig, UNRES_EXT);\n            if (i == -1) {\n                /* extension not found in unres */\n                LOGINT(ctx);\n                goto error;\n            }\n            info_orig = unres->str_snode[i];\n            info = malloc(sizeof *info);\n            LY_CHECK_ERR_GOTO(!info, LOGMEM(ctx), error);\n            info->datatype = info_orig->datatype;\n            if (info->datatype == LYS_IN_YIN) {\n                info->data.yin = lyxml_dup_elem(ctx, info_orig->data.yin, NULL, 1);\n            } /* else TODO YANG */\n            info->parent = parent;\n            info->mod = mod;\n            info->parent_type = parent_type;\n            info->ext_index = u;\n            if (unres_schema_add_node(info->mod, unres, new, UNRES_EXT, (struct lys_node *)info) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    (*new) = NULL;\n    lys_extension_instances_free(ctx, result, u, NULL);\n    return EXIT_FAILURE;\n}\n\nstatic struct lys_restr *\nlys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n\n    if (!size) {\n        return NULL;\n    }\n\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n\n    for (i = 0; i < size; i++) {\n        result[i].ext_size = old[i].ext_size;\n        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n\n    return result;\n}\n\nvoid\nlys_restr_free(struct ly_ctx *ctx, struct lys_restr *restr,\n               void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    assert(ctx);\n    if (!restr) {\n        return;\n    }\n\n    lys_extension_instances_free(ctx, restr->ext, restr->ext_size, private_destructor);\n    lydict_remove(ctx, restr->expr);\n    lydict_remove(ctx, restr->dsc);\n    lydict_remove(ctx, restr->ref);\n    lydict_remove(ctx, restr->eapptag);\n    lydict_remove(ctx, restr->emsg);\n}\n\nAPI void\nlys_iffeature_free(struct ly_ctx *ctx, struct lys_iffeature *iffeature, uint8_t iffeature_size,\n                   int shallow, void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    uint8_t i;\n\n    for (i = 0; i < iffeature_size; ++i) {\n        lys_extension_instances_free(ctx, iffeature[i].ext, iffeature[i].ext_size, private_destructor);\n        if (!shallow) {\n            free(iffeature[i].expr);\n            free(iffeature[i].features);\n        }\n    }\n    free(iffeature);\n}\n\nstatic int\ntype_dup(struct lys_module *mod, struct lys_node *parent, struct lys_type *new, struct lys_type *old,\n         LY_DATA_TYPE base, int in_grp, int shallow, struct unres_schema *unres)\n{\n    int i;\n    unsigned int u;\n\n    switch (base) {\n    case LY_TYPE_BINARY:\n        if (old->info.binary.length) {\n            new->info.binary.length = lys_restr_dup(mod, old->info.binary.length, 1, shallow, unres);\n        }\n        break;\n\n    case LY_TYPE_BITS:\n        new->info.bits.count = old->info.bits.count;\n        if (new->info.bits.count) {\n            new->info.bits.bit = calloc(new->info.bits.count, sizeof *new->info.bits.bit);\n            LY_CHECK_ERR_RETURN(!new->info.bits.bit, LOGMEM(mod->ctx), -1);\n\n            for (u = 0; u < new->info.bits.count; u++) {\n                new->info.bits.bit[u].name = lydict_insert(mod->ctx, old->info.bits.bit[u].name, 0);\n                new->info.bits.bit[u].dsc = lydict_insert(mod->ctx, old->info.bits.bit[u].dsc, 0);\n                new->info.bits.bit[u].ref = lydict_insert(mod->ctx, old->info.bits.bit[u].ref, 0);\n                new->info.bits.bit[u].flags = old->info.bits.bit[u].flags;\n                new->info.bits.bit[u].pos = old->info.bits.bit[u].pos;\n                new->info.bits.bit[u].ext_size = old->info.bits.bit[u].ext_size;\n                if (lys_ext_dup(mod->ctx, mod, old->info.bits.bit[u].ext, old->info.bits.bit[u].ext_size,\n                                &new->info.bits.bit[u], LYEXT_PAR_TYPE_BIT,\n                                &new->info.bits.bit[u].ext, shallow, unres)) {\n                    return -1;\n                }\n            }\n        }\n        break;\n\n    case LY_TYPE_DEC64:\n        new->info.dec64.dig = old->info.dec64.dig;\n        new->info.dec64.div = old->info.dec64.div;\n        if (old->info.dec64.range) {\n            new->info.dec64.range = lys_restr_dup(mod, old->info.dec64.range, 1, shallow, unres);\n        }\n        break;\n\n    case LY_TYPE_ENUM:\n        new->info.enums.count = old->info.enums.count;\n        if (new->info.enums.count) {\n            new->info.enums.enm = calloc(new->info.enums.count, sizeof *new->info.enums.enm);\n            LY_CHECK_ERR_RETURN(!new->info.enums.enm, LOGMEM(mod->ctx), -1);\n\n            for (u = 0; u < new->info.enums.count; u++) {\n                new->info.enums.enm[u].name = lydict_insert(mod->ctx, old->info.enums.enm[u].name, 0);\n                new->info.enums.enm[u].dsc = lydict_insert(mod->ctx, old->info.enums.enm[u].dsc, 0);\n                new->info.enums.enm[u].ref = lydict_insert(mod->ctx, old->info.enums.enm[u].ref, 0);\n                new->info.enums.enm[u].flags = old->info.enums.enm[u].flags;\n                new->info.enums.enm[u].value = old->info.enums.enm[u].value;\n                new->info.enums.enm[u].ext_size = old->info.enums.enm[u].ext_size;\n                if (lys_ext_dup(mod->ctx, mod, old->info.enums.enm[u].ext, old->info.enums.enm[u].ext_size,\n                                &new->info.enums.enm[u], LYEXT_PAR_TYPE_ENUM,\n                                &new->info.enums.enm[u].ext, shallow, unres)) {\n                    return -1;\n                }\n            }\n        }\n        break;\n\n    case LY_TYPE_IDENT:\n        new->info.ident.count = old->info.ident.count;\n        if (old->info.ident.count) {\n            new->info.ident.ref = malloc(old->info.ident.count * sizeof *new->info.ident.ref);\n            LY_CHECK_ERR_RETURN(!new->info.ident.ref, LOGMEM(mod->ctx), -1);\n            memcpy(new->info.ident.ref, old->info.ident.ref, old->info.ident.count * sizeof *new->info.ident.ref);\n        } else {\n            /* there can be several unresolved base identities, duplicate them all */\n            i = -1;\n            do {\n                i = unres_schema_find(unres, i, old, UNRES_TYPE_IDENTREF);\n                if (i != -1) {\n                    if (unres_schema_add_str(mod, unres, new, UNRES_TYPE_IDENTREF, unres->str_snode[i]) == -1) {\n                        return -1;\n                    }\n                }\n                --i;\n            } while (i > -1);\n        }\n        break;\n\n    case LY_TYPE_INST:\n        new->info.inst.req = old->info.inst.req;\n        break;\n\n    case LY_TYPE_INT8:\n    case LY_TYPE_INT16:\n    case LY_TYPE_INT32:\n    case LY_TYPE_INT64:\n    case LY_TYPE_UINT8:\n    case LY_TYPE_UINT16:\n    case LY_TYPE_UINT32:\n    case LY_TYPE_UINT64:\n        if (old->info.num.range) {\n            new->info.num.range = lys_restr_dup(mod, old->info.num.range, 1, shallow, unres);\n        }\n        break;\n\n    case LY_TYPE_LEAFREF:\n        if (old->info.lref.path) {\n            new->info.lref.path = lydict_insert(mod->ctx, old->info.lref.path, 0);\n            new->info.lref.req = old->info.lref.req;\n            if (!in_grp && unres_schema_add_node(mod, unres, new, UNRES_TYPE_LEAFREF, parent) == -1) {\n                return -1;\n            }\n        }\n        break;\n\n    case LY_TYPE_STRING:\n        if (old->info.str.length) {\n            new->info.str.length = lys_restr_dup(mod, old->info.str.length, 1, shallow, unres);\n        }\n        if (old->info.str.pat_count) {\n            new->info.str.patterns = lys_restr_dup(mod, old->info.str.patterns, old->info.str.pat_count, shallow, unres);\n            new->info.str.pat_count = old->info.str.pat_count;\n#ifdef LY_ENABLED_CACHE\n            if (!in_grp) {\n                new->info.str.patterns_pcre = malloc(new->info.str.pat_count * 2 * sizeof *new->info.str.patterns_pcre);\n                LY_CHECK_ERR_RETURN(!new->info.str.patterns_pcre, LOGMEM(mod->ctx), -1);\n                for (u = 0; u < new->info.str.pat_count; u++) {\n                    if (lyp_precompile_pattern(mod->ctx, &new->info.str.patterns[u].expr[1],\n                                              (pcre**)&new->info.str.patterns_pcre[2 * u],\n                                              (pcre_extra**)&new->info.str.patterns_pcre[2 * u + 1])) {\n                        free(new->info.str.patterns_pcre);\n                        new->info.str.patterns_pcre = NULL;\n                        return -1;\n                    }\n                }\n            }\n#endif\n        }\n        break;\n\n    case LY_TYPE_UNION:\n        new->info.uni.has_ptr_type = old->info.uni.has_ptr_type;\n        new->info.uni.count = old->info.uni.count;\n        if (new->info.uni.count) {\n            new->info.uni.types = calloc(new->info.uni.count, sizeof *new->info.uni.types);\n            LY_CHECK_ERR_RETURN(!new->info.uni.types, LOGMEM(mod->ctx), -1);\n\n            for (u = 0; u < new->info.uni.count; u++) {\n                if (lys_type_dup(mod, parent, &(new->info.uni.types[u]), &(old->info.uni.types[u]), in_grp,\n                        shallow, unres)) {\n                    return -1;\n                }\n            }\n        }\n        break;\n\n    default:\n        /* nothing to do for LY_TYPE_BOOL, LY_TYPE_EMPTY */\n        break;\n    }\n\n    return EXIT_SUCCESS;\n}\n\nstruct yang_type *\nlys_yang_type_dup(struct lys_module *module, struct lys_node *parent, struct yang_type *old, struct lys_type *type,\n                  int in_grp, int shallow, struct unres_schema *unres)\n{\n    struct yang_type *new;\n\n    new = calloc(1, sizeof *new);\n    LY_CHECK_ERR_RETURN(!new, LOGMEM(module->ctx), NULL);\n    new->flags = old->flags;\n    new->base = old->base;\n    new->name = lydict_insert(module->ctx, old->name, 0);\n    new->type = type;\n    if (!new->name) {\n        LOGMEM(module->ctx);\n        goto error;\n    }\n    if (type_dup(module, parent, type, old->type, new->base, in_grp, shallow, unres)) {\n        new->type->base = new->base;\n        lys_type_free(module->ctx, new->type, NULL);\n        memset(&new->type->info, 0, sizeof new->type->info);\n        goto error;\n    }\n    return new;\n\nerror:\n    free(new);\n    return NULL;\n}\n\nint\nlys_copy_union_leafrefs(struct lys_module *mod, struct lys_node *parent, struct lys_type *type, struct lys_type *prev_new,\n                        struct unres_schema *unres)\n{\n    struct lys_type new;\n    unsigned int i, top_type;\n    struct lys_ext_instance **ext;\n    uint8_t ext_size;\n    void *reloc;\n\n    if (!prev_new) {\n        /* this is the \"top-level\" type, meaning it is a real type and no typedef directly above */\n        top_type = 1;\n\n        memset(&new, 0, sizeof new);\n\n        new.base = type->base;\n        new.parent = (struct lys_tpdf *)parent;\n\n        prev_new = &new;\n    } else {\n        /* this is not top-level type, just a type of a typedef */\n        top_type = 0;\n    }\n\n    assert(type->der);\n    if (type->der->module) {\n        /* typedef, skip it, but keep the extensions */\n        ext_size = type->ext_size;\n        if (lys_ext_dup(mod->ctx, mod, type->ext, type->ext_size, prev_new, LYEXT_PAR_TYPE, &ext, 0, unres)) {\n            return -1;\n        }\n        if (prev_new->ext) {\n            reloc = realloc(prev_new->ext, (prev_new->ext_size + ext_size) * sizeof *prev_new->ext);\n            LY_CHECK_ERR_RETURN(!reloc, LOGMEM(mod->ctx), -1);\n            prev_new->ext = reloc;\n\n            memcpy(prev_new->ext + prev_new->ext_size, ext, ext_size * sizeof *ext);\n            free(ext);\n\n            prev_new->ext_size += ext_size;\n        } else {\n            prev_new->ext = ext;\n            prev_new->ext_size = ext_size;\n        }\n\n        if (lys_copy_union_leafrefs(mod, parent, &type->der->type, prev_new, unres)) {\n            return -1;\n        }\n    } else {\n        /* type, just make a deep copy */\n        switch (type->base) {\n        case LY_TYPE_UNION:\n            prev_new->info.uni.has_ptr_type = type->info.uni.has_ptr_type;\n            prev_new->info.uni.count = type->info.uni.count;\n            /* this cannot be a typedef anymore */\n            assert(prev_new->info.uni.count);\n\n            prev_new->info.uni.types = calloc(prev_new->info.uni.count, sizeof *prev_new->info.uni.types);\n            LY_CHECK_ERR_RETURN(!prev_new->info.uni.types, LOGMEM(mod->ctx), -1);\n\n            for (i = 0; i < prev_new->info.uni.count; i++) {\n                if (lys_copy_union_leafrefs(mod, parent, &(type->info.uni.types[i]), &(prev_new->info.uni.types[i]), unres)) {\n                    return -1;\n                }\n            }\n\n            prev_new->der = type->der;\n            break;\n        default:\n            if (lys_type_dup(mod, parent, prev_new, type, 0, 0, unres)) {\n                return -1;\n            }\n            break;\n        }\n    }\n\n    if (top_type) {\n        memcpy(type, prev_new, sizeof *type);\n    }\n    return EXIT_SUCCESS;\n}\n\nAPI const void *\nlys_ext_instance_substmt(const struct lys_ext_instance *ext)\n{\n    if (!ext) {\n        return NULL;\n    }\n\n    switch (ext->insubstmt) {\n    case LYEXT_SUBSTMT_SELF:\n    case LYEXT_SUBSTMT_MODIFIER:\n    case LYEXT_SUBSTMT_VERSION:\n        return NULL;\n    case LYEXT_SUBSTMT_ARGUMENT:\n        if (ext->parent_type == LYEXT_PAR_EXT) {\n            return ((struct lys_ext_instance*)ext->parent)->arg_value;\n        }\n        break;\n    case LYEXT_SUBSTMT_BASE:\n        if (ext->parent_type == LYEXT_PAR_TYPE) {\n            return ((struct lys_type*)ext->parent)->info.ident.ref[ext->insubstmt_index];\n        } else if (ext->parent_type == LYEXT_PAR_IDENT) {\n            return ((struct lys_ident*)ext->parent)->base[ext->insubstmt_index];\n        }\n        break;\n    case LYEXT_SUBSTMT_BELONGSTO:\n        if (ext->parent_type == LYEXT_PAR_MODULE && ((struct lys_module*)ext->parent)->type) {\n            return ((struct lys_submodule*)ext->parent)->belongsto;\n        }\n        break;\n    case LYEXT_SUBSTMT_CONFIG:\n    case LYEXT_SUBSTMT_MANDATORY:\n        if (ext->parent_type == LYEXT_PAR_NODE) {\n            return &((struct lys_node*)ext->parent)->flags;\n        } else if (ext->parent_type == LYEXT_PAR_DEVIATE) {\n            return &((struct lys_deviate*)ext->parent)->flags;\n        } else if (ext->parent_type == LYEXT_PAR_REFINE) {\n            return &((struct lys_refine*)ext->parent)->flags;\n        }\n        break;\n    case LYEXT_SUBSTMT_CONTACT:\n        if (ext->parent_type == LYEXT_PAR_MODULE) {\n            return ((struct lys_module*)ext->parent)->contact;\n        }\n        break;\n    case LYEXT_SUBSTMT_DEFAULT:\n        if (ext->parent_type == LYEXT_PAR_NODE) {\n            switch (((struct lys_node*)ext->parent)->nodetype) {\n            case LYS_LEAF:\n            case LYS_LEAFLIST:\n                /* in case of leaf, the index is supposed to be 0, so it will return the\n                 * correct pointer despite the leaf structure does not have dflt as array */\n                return ((struct lys_node_leaflist*)ext->parent)->dflt[ext->insubstmt_index];\n            case LYS_CHOICE:\n                return ((struct lys_node_choice*)ext->parent)->dflt;\n            default:\n                /* internal error */\n                break;\n            }\n        } else if (ext->parent_type == LYEXT_PAR_TPDF) {\n            return ((struct lys_tpdf*)ext->parent)->dflt;\n        } else if (ext->parent_type == LYEXT_PAR_DEVIATE) {\n            return ((struct lys_deviate*)ext->parent)->dflt[ext->insubstmt_index];\n        } else if (ext->parent_type == LYEXT_PAR_REFINE) {\n            return &((struct lys_refine*)ext->parent)->dflt[ext->insubstmt_index];\n        }\n        break;\n    case LYEXT_SUBSTMT_DESCRIPTION:\n        switch (ext->parent_type) {\n        case LYEXT_PAR_NODE:\n            return ((struct lys_node*)ext->parent)->dsc;\n        case LYEXT_PAR_MODULE:\n            return ((struct lys_module*)ext->parent)->dsc;\n        case LYEXT_PAR_IMPORT:\n            return ((struct lys_import*)ext->parent)->dsc;\n        case LYEXT_PAR_INCLUDE:\n            return ((struct lys_include*)ext->parent)->dsc;\n        case LYEXT_PAR_EXT:\n            return ((struct lys_ext*)ext->parent)->dsc;\n        case LYEXT_PAR_FEATURE:\n            return ((struct lys_feature*)ext->parent)->dsc;\n        case LYEXT_PAR_TPDF:\n            return ((struct lys_tpdf*)ext->parent)->dsc;\n        case LYEXT_PAR_TYPE_BIT:\n            return ((struct lys_type_bit*)ext->parent)->dsc;\n        case LYEXT_PAR_TYPE_ENUM:\n            return ((struct lys_type_enum*)ext->parent)->dsc;\n        case LYEXT_PAR_RESTR:\n            return ((struct lys_restr*)ext->parent)->dsc;\n        case LYEXT_PAR_WHEN:\n            return ((struct lys_when*)ext->parent)->dsc;\n        case LYEXT_PAR_IDENT:\n            return ((struct lys_ident*)ext->parent)->dsc;\n        case LYEXT_PAR_DEVIATION:\n            return ((struct lys_deviation*)ext->parent)->dsc;\n        case LYEXT_PAR_REVISION:\n            return ((struct lys_revision*)ext->parent)->dsc;\n        case LYEXT_PAR_REFINE:\n            return ((struct lys_refine*)ext->parent)->dsc;\n        default:\n            break;\n        }\n        break;\n    case LYEXT_SUBSTMT_ERRTAG:\n        if (ext->parent_type == LYEXT_PAR_RESTR) {\n            return ((struct lys_restr*)ext->parent)->eapptag;\n        }\n        break;\n    case LYEXT_SUBSTMT_ERRMSG:\n        if (ext->parent_type == LYEXT_PAR_RESTR) {\n            return ((struct lys_restr*)ext->parent)->emsg;\n        }\n        break;\n    case LYEXT_SUBSTMT_DIGITS:\n        if (ext->parent_type == LYEXT_PAR_TYPE && ((struct lys_type*)ext->parent)->base == LY_TYPE_DEC64) {\n            return &((struct lys_type*)ext->parent)->info.dec64.dig;\n        }\n        break;\n    case LYEXT_SUBSTMT_KEY:\n        if (ext->parent_type == LYEXT_PAR_NODE && ((struct lys_node*)ext->parent)->nodetype == LYS_LIST) {\n            return ((struct lys_node_list*)ext->parent)->keys;\n        }\n        break;\n    case LYEXT_SUBSTMT_MAX:\n        if (ext->parent_type == LYEXT_PAR_NODE) {\n            if (((struct lys_node*)ext->parent)->nodetype == LYS_LIST) {\n                return &((struct lys_node_list*)ext->parent)->max;\n            } else if (((struct lys_node*)ext->parent)->nodetype == LYS_LEAFLIST) {\n                return &((struct lys_node_leaflist*)ext->parent)->max;\n            }\n        } else if (ext->parent_type == LYEXT_PAR_REFINE) {\n            return &((struct lys_refine*)ext->parent)->mod.list.max;\n        }\n        break;\n    case LYEXT_SUBSTMT_MIN:\n        if (ext->parent_type == LYEXT_PAR_NODE) {\n            if (((struct lys_node*)ext->parent)->nodetype == LYS_LIST) {\n                return &((struct lys_node_list*)ext->parent)->min;\n            } else if (((struct lys_node*)ext->parent)->nodetype == LYS_LEAFLIST) {\n                return &((struct lys_node_leaflist*)ext->parent)->min;\n            }\n        } else if (ext->parent_type == LYEXT_PAR_REFINE) {\n            return &((struct lys_refine*)ext->parent)->mod.list.min;\n        }\n        break;\n    case LYEXT_SUBSTMT_NAMESPACE:\n        if (ext->parent_type == LYEXT_PAR_MODULE && !((struct lys_module*)ext->parent)->type) {\n            return ((struct lys_module*)ext->parent)->ns;\n        }\n        break;\n    case LYEXT_SUBSTMT_ORDEREDBY:\n        if (ext->parent_type == LYEXT_PAR_NODE &&\n                (((struct lys_node*)ext->parent)->nodetype & (LYS_LIST | LYS_LEAFLIST))) {\n            return &((struct lys_node_list*)ext->parent)->flags;\n        }\n        break;\n    case LYEXT_SUBSTMT_ORGANIZATION:\n        if (ext->parent_type == LYEXT_PAR_MODULE) {\n            return ((struct lys_module*)ext->parent)->org;\n        }\n        break;\n    case LYEXT_SUBSTMT_PATH:\n        if (ext->parent_type == LYEXT_PAR_TYPE && ((struct lys_type*)ext->parent)->base == LY_TYPE_LEAFREF) {\n            return ((struct lys_type*)ext->parent)->info.lref.path;\n        }\n        break;\n    case LYEXT_SUBSTMT_POSITION:\n        if (ext->parent_type == LYEXT_PAR_TYPE_BIT) {\n            return &((struct lys_type_bit*)ext->parent)->pos;\n        }\n        break;\n    case LYEXT_SUBSTMT_PREFIX:\n        if (ext->parent_type == LYEXT_PAR_MODULE) {\n            /* covers also lys_submodule */\n            return ((struct lys_module*)ext->parent)->prefix;\n        } else if (ext->parent_type == LYEXT_PAR_IMPORT) {\n            return ((struct lys_import*)ext->parent)->prefix;\n        }\n        break;\n    case LYEXT_SUBSTMT_PRESENCE:\n        if (ext->parent_type == LYEXT_PAR_NODE && ((struct lys_node*)ext->parent)->nodetype == LYS_CONTAINER) {\n            return ((struct lys_node_container*)ext->parent)->presence;\n        } else if (ext->parent_type == LYEXT_PAR_REFINE) {\n            return ((struct lys_refine*)ext->parent)->mod.presence;\n        }\n        break;\n    case LYEXT_SUBSTMT_REFERENCE:\n        switch (ext->parent_type) {\n        case LYEXT_PAR_NODE:\n            return ((struct lys_node*)ext->parent)->ref;\n        case LYEXT_PAR_MODULE:\n            return ((struct lys_module*)ext->parent)->ref;\n        case LYEXT_PAR_IMPORT:\n            return ((struct lys_import*)ext->parent)->ref;\n        case LYEXT_PAR_INCLUDE:\n            return ((struct lys_include*)ext->parent)->ref;\n        case LYEXT_PAR_EXT:\n            return ((struct lys_ext*)ext->parent)->ref;\n        case LYEXT_PAR_FEATURE:\n            return ((struct lys_feature*)ext->parent)->ref;\n        case LYEXT_PAR_TPDF:\n            return ((struct lys_tpdf*)ext->parent)->ref;\n        case LYEXT_PAR_TYPE_BIT:\n            return ((struct lys_type_bit*)ext->parent)->ref;\n        case LYEXT_PAR_TYPE_ENUM:\n            return ((struct lys_type_enum*)ext->parent)->ref;\n        case LYEXT_PAR_RESTR:\n            return ((struct lys_restr*)ext->parent)->ref;\n        case LYEXT_PAR_WHEN:\n            return ((struct lys_when*)ext->parent)->ref;\n        case LYEXT_PAR_IDENT:\n            return ((struct lys_ident*)ext->parent)->ref;\n        case LYEXT_PAR_DEVIATION:\n            return ((struct lys_deviation*)ext->parent)->ref;\n        case LYEXT_PAR_REVISION:\n            return ((struct lys_revision*)ext->parent)->ref;\n        case LYEXT_PAR_REFINE:\n            return ((struct lys_refine*)ext->parent)->ref;\n        default:\n            break;\n        }\n        break;\n    case LYEXT_SUBSTMT_REQINSTANCE:\n        if (ext->parent_type == LYEXT_PAR_TYPE) {\n            if (((struct lys_type*)ext->parent)->base == LY_TYPE_LEAFREF) {\n                return &((struct lys_type*)ext->parent)->info.lref.req;\n            } else if (((struct lys_type*)ext->parent)->base == LY_TYPE_INST) {\n                return &((struct lys_type*)ext->parent)->info.inst.req;\n            }\n        }\n        break;\n    case LYEXT_SUBSTMT_REVISIONDATE:\n        if (ext->parent_type == LYEXT_PAR_IMPORT) {\n            return ((struct lys_import*)ext->parent)->rev;\n        } else if (ext->parent_type == LYEXT_PAR_INCLUDE) {\n            return ((struct lys_include*)ext->parent)->rev;\n        }\n        break;\n    case LYEXT_SUBSTMT_STATUS:\n        switch (ext->parent_type) {\n        case LYEXT_PAR_NODE:\n        case LYEXT_PAR_IDENT:\n        case LYEXT_PAR_TPDF:\n        case LYEXT_PAR_EXT:\n        case LYEXT_PAR_FEATURE:\n        case LYEXT_PAR_TYPE_ENUM:\n        case LYEXT_PAR_TYPE_BIT:\n            /* in all structures the flags member is at the same offset */\n            return &((struct lys_node*)ext->parent)->flags;\n        default:\n            break;\n        }\n        break;\n    case LYEXT_SUBSTMT_UNIQUE:\n        if (ext->parent_type == LYEXT_PAR_DEVIATE) {\n            return &((struct lys_deviate*)ext->parent)->unique[ext->insubstmt_index];\n        } else if (ext->parent_type == LYEXT_PAR_NODE && ((struct lys_node*)ext->parent)->nodetype == LYS_LIST) {\n            return &((struct lys_node_list*)ext->parent)->unique[ext->insubstmt_index];\n        }\n        break;\n    case LYEXT_SUBSTMT_UNITS:\n        if (ext->parent_type == LYEXT_PAR_NODE &&\n                (((struct lys_node*)ext->parent)->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n            /* units is at the same offset in both lys_node_leaf and lys_node_leaflist */\n            return ((struct lys_node_leaf*)ext->parent)->units;\n        } else if (ext->parent_type == LYEXT_PAR_TPDF) {\n            return ((struct lys_tpdf*)ext->parent)->units;\n        } else if (ext->parent_type == LYEXT_PAR_DEVIATE) {\n            return ((struct lys_deviate*)ext->parent)->units;\n        }\n        break;\n    case LYEXT_SUBSTMT_VALUE:\n        if (ext->parent_type == LYEXT_PAR_TYPE_ENUM) {\n            return &((struct lys_type_enum*)ext->parent)->value;\n        }\n        break;\n    case LYEXT_SUBSTMT_YINELEM:\n        if (ext->parent_type == LYEXT_PAR_EXT) {\n            return &((struct lys_ext*)ext->parent)->flags;\n        }\n        break;\n    }\n    LOGINT(ext->module->ctx);\n    return NULL;\n}\n\nstatic int\nlys_type_dup(struct lys_module *mod, struct lys_node *parent, struct lys_type *new, struct lys_type *old,\n            int in_grp, int shallow, struct unres_schema *unres)\n{\n    int i;\n\n    new->base = old->base;\n    new->der = old->der;\n    new->parent = (struct lys_tpdf *)parent;\n    new->ext_size = old->ext_size;\n    if (lys_ext_dup(mod->ctx, mod, old->ext, old->ext_size, new, LYEXT_PAR_TYPE, &new->ext, shallow, unres)) {\n        return -1;\n    }\n\n    i = unres_schema_find(unres, -1, old, UNRES_TYPE_DER);\n    if (i != -1) {\n        /* HACK (serious one) for unres */\n        /* nothing else we can do but duplicate it immediately */\n        if (((struct lyxml_elem *)old->der)->flags & LY_YANG_STRUCTURE_FLAG) {\n            new->der = (struct lys_tpdf *)lys_yang_type_dup(mod, parent, (struct yang_type *)old->der, new, in_grp,\n                                                            shallow, unres);\n        } else {\n            new->der = (struct lys_tpdf *)lyxml_dup_elem(mod->ctx, (struct lyxml_elem *)old->der, NULL, 1);\n        }\n        /* all these unres additions can fail even though they did not before */\n        if (!new->der || (unres_schema_add_node(mod, unres, new, UNRES_TYPE_DER, parent) == -1)) {\n            return -1;\n        }\n        return EXIT_SUCCESS;\n    }\n\n    return type_dup(mod, parent, new, old, new->base, in_grp, shallow, unres);\n}\n\nvoid\nlys_type_free(struct ly_ctx *ctx, struct lys_type *type,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    unsigned int i;\n\n    assert(ctx);\n    if (!type) {\n        return;\n    }\n\n    lys_extension_instances_free(ctx, type->ext, type->ext_size, private_destructor);\n\n    switch (type->base) {\n    case LY_TYPE_BINARY:\n        lys_restr_free(ctx, type->info.binary.length, private_destructor);\n        free(type->info.binary.length);\n        break;\n    case LY_TYPE_BITS:\n        for (i = 0; i < type->info.bits.count; i++) {\n            lydict_remove(ctx, type->info.bits.bit[i].name);\n            lydict_remove(ctx, type->info.bits.bit[i].dsc);\n            lydict_remove(ctx, type->info.bits.bit[i].ref);\n            lys_iffeature_free(ctx, type->info.bits.bit[i].iffeature, type->info.bits.bit[i].iffeature_size, 0,\n                               private_destructor);\n            lys_extension_instances_free(ctx, type->info.bits.bit[i].ext, type->info.bits.bit[i].ext_size,\n                                         private_destructor);\n        }\n        free(type->info.bits.bit);\n        break;\n\n    case LY_TYPE_DEC64:\n        lys_restr_free(ctx, type->info.dec64.range, private_destructor);\n        free(type->info.dec64.range);\n        break;\n\n    case LY_TYPE_ENUM:\n        for (i = 0; i < type->info.enums.count; i++) {\n            lydict_remove(ctx, type->info.enums.enm[i].name);\n            lydict_remove(ctx, type->info.enums.enm[i].dsc);\n            lydict_remove(ctx, type->info.enums.enm[i].ref);\n            lys_iffeature_free(ctx, type->info.enums.enm[i].iffeature, type->info.enums.enm[i].iffeature_size, 0,\n                               private_destructor);\n            lys_extension_instances_free(ctx, type->info.enums.enm[i].ext, type->info.enums.enm[i].ext_size,\n                                         private_destructor);\n        }\n        free(type->info.enums.enm);\n        break;\n\n    case LY_TYPE_INT8:\n    case LY_TYPE_INT16:\n    case LY_TYPE_INT32:\n    case LY_TYPE_INT64:\n    case LY_TYPE_UINT8:\n    case LY_TYPE_UINT16:\n    case LY_TYPE_UINT32:\n    case LY_TYPE_UINT64:\n        lys_restr_free(ctx, type->info.num.range, private_destructor);\n        free(type->info.num.range);\n        break;\n\n    case LY_TYPE_LEAFREF:\n        lydict_remove(ctx, type->info.lref.path);\n        break;\n\n    case LY_TYPE_STRING:\n        lys_restr_free(ctx, type->info.str.length, private_destructor);\n        free(type->info.str.length);\n        for (i = 0; i < type->info.str.pat_count; i++) {\n            lys_restr_free(ctx, &type->info.str.patterns[i], private_destructor);\n#ifdef LY_ENABLED_CACHE\n            if (type->info.str.patterns_pcre) {\n                pcre_free((pcre*)type->info.str.patterns_pcre[2 * i]);\n                pcre_free_study((pcre_extra*)type->info.str.patterns_pcre[2 * i + 1]);\n            }\n#endif\n        }\n        free(type->info.str.patterns);\n#ifdef LY_ENABLED_CACHE\n        free(type->info.str.patterns_pcre);\n#endif\n        break;\n\n    case LY_TYPE_UNION:\n        for (i = 0; i < type->info.uni.count; i++) {\n            lys_type_free(ctx, &type->info.uni.types[i], private_destructor);\n        }\n        free(type->info.uni.types);\n        break;\n\n    case LY_TYPE_IDENT:\n        free(type->info.ident.ref);\n        break;\n\n    default:\n        /* nothing to do for LY_TYPE_INST, LY_TYPE_BOOL, LY_TYPE_EMPTY */\n        break;\n    }\n}\n\nstatic void\nlys_tpdf_free(struct ly_ctx *ctx, struct lys_tpdf *tpdf,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    assert(ctx);\n    if (!tpdf) {\n        return;\n    }\n\n    lydict_remove(ctx, tpdf->name);\n    lydict_remove(ctx, tpdf->dsc);\n    lydict_remove(ctx, tpdf->ref);\n\n    lys_type_free(ctx, &tpdf->type, private_destructor);\n\n    lydict_remove(ctx, tpdf->units);\n    lydict_remove(ctx, tpdf->dflt);\n\n    lys_extension_instances_free(ctx, tpdf->ext, tpdf->ext_size, private_destructor);\n}\n\nstatic struct lys_when *\nlys_when_dup(struct lys_module *mod, struct lys_when *old, int shallow, struct unres_schema *unres)\n{\n    struct lys_when *new;\n\n    if (!old) {\n        return NULL;\n    }\n\n    new = calloc(1, sizeof *new);\n    LY_CHECK_ERR_RETURN(!new, LOGMEM(mod->ctx), NULL);\n    new->cond = lydict_insert(mod->ctx, old->cond, 0);\n    new->dsc = lydict_insert(mod->ctx, old->dsc, 0);\n    new->ref = lydict_insert(mod->ctx, old->ref, 0);\n    new->ext_size = old->ext_size;\n    lys_ext_dup(mod->ctx, mod, old->ext, old->ext_size, new, LYEXT_PAR_WHEN, &new->ext, shallow, unres);\n\n    return new;\n}\n\nvoid\nlys_when_free(struct ly_ctx *ctx, struct lys_when *w,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    if (!w) {\n        return;\n    }\n\n    lys_extension_instances_free(ctx, w->ext, w->ext_size, private_destructor);\n    lydict_remove(ctx, w->cond);\n    lydict_remove(ctx, w->dsc);\n    lydict_remove(ctx, w->ref);\n\n    free(w);\n}\n\nstatic void\nlys_augment_free(struct ly_ctx *ctx, struct lys_node_augment *aug,\n                 void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    struct lys_node *next, *sub;\n\n    /* children from a resolved augment are freed under the target node */\n    if (!aug->target || (aug->flags & LYS_NOTAPPLIED)) {\n        LY_TREE_FOR_SAFE(aug->child, next, sub) {\n            lys_node_free(sub, private_destructor, 0);\n        }\n    }\n\n    lydict_remove(ctx, aug->target_name);\n    lydict_remove(ctx, aug->dsc);\n    lydict_remove(ctx, aug->ref);\n\n    lys_iffeature_free(ctx, aug->iffeature, aug->iffeature_size, 0, private_destructor);\n    lys_extension_instances_free(ctx, aug->ext, aug->ext_size, private_destructor);\n\n    lys_when_free(ctx, aug->when, private_destructor);\n}\n\nstatic void\nlys_ident_free(struct ly_ctx *ctx, struct lys_ident *ident,\n               void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    assert(ctx);\n    if (!ident) {\n        return;\n    }\n\n    free(ident->base);\n    ly_set_free(ident->der);\n    lydict_remove(ctx, ident->name);\n    lydict_remove(ctx, ident->dsc);\n    lydict_remove(ctx, ident->ref);\n    lys_iffeature_free(ctx, ident->iffeature, ident->iffeature_size, 0, private_destructor);\n    lys_extension_instances_free(ctx, ident->ext, ident->ext_size, private_destructor);\n\n}\n\nstatic void\nlys_grp_free(struct ly_ctx *ctx, struct lys_node_grp *grp,\n             void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    /* handle only specific parts for LYS_GROUPING */\n    for (i = 0; i < grp->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &grp->tpdf[i], private_destructor);\n    }\n    free(grp->tpdf);\n}\n\nstatic void\nlys_rpc_action_free(struct ly_ctx *ctx, struct lys_node_rpc_action *rpc_act,\n             void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    /* handle only specific parts for LYS_GROUPING */\n    for (i = 0; i < rpc_act->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &rpc_act->tpdf[i], private_destructor);\n    }\n    free(rpc_act->tpdf);\n}\n\nstatic void\nlys_inout_free(struct ly_ctx *ctx, struct lys_node_inout *io,\n               void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    /* handle only specific parts for LYS_INPUT and LYS_OUTPUT */\n    for (i = 0; i < io->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &io->tpdf[i], private_destructor);\n    }\n    free(io->tpdf);\n\n    for (i = 0; i < io->must_size; i++) {\n        lys_restr_free(ctx, &io->must[i], private_destructor);\n    }\n    free(io->must);\n}\n\nstatic void\nlys_notif_free(struct ly_ctx *ctx, struct lys_node_notif *notif,\n               void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    for (i = 0; i < notif->must_size; i++) {\n        lys_restr_free(ctx, &notif->must[i], private_destructor);\n    }\n    free(notif->must);\n\n    for (i = 0; i < notif->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &notif->tpdf[i], private_destructor);\n    }\n    free(notif->tpdf);\n}\nstatic void\nlys_anydata_free(struct ly_ctx *ctx, struct lys_node_anydata *anyxml,\n                 void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    for (i = 0; i < anyxml->must_size; i++) {\n        lys_restr_free(ctx, &anyxml->must[i], private_destructor);\n    }\n    free(anyxml->must);\n\n    lys_when_free(ctx, anyxml->when, private_destructor);\n}\n\nstatic void\nlys_leaf_free(struct ly_ctx *ctx, struct lys_node_leaf *leaf,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    /* leafref backlinks */\n    ly_set_free((struct ly_set *)leaf->backlinks);\n\n    for (i = 0; i < leaf->must_size; i++) {\n        lys_restr_free(ctx, &leaf->must[i], private_destructor);\n    }\n    free(leaf->must);\n\n    lys_when_free(ctx, leaf->when, private_destructor);\n\n    lys_type_free(ctx, &leaf->type, private_destructor);\n    lydict_remove(ctx, leaf->units);\n    lydict_remove(ctx, leaf->dflt);\n}\n\nstatic void\nlys_leaflist_free(struct ly_ctx *ctx, struct lys_node_leaflist *llist,\n                  void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    if (llist->backlinks) {\n        /* leafref backlinks */\n        ly_set_free(llist->backlinks);\n    }\n\n    for (i = 0; i < llist->must_size; i++) {\n        lys_restr_free(ctx, &llist->must[i], private_destructor);\n    }\n    free(llist->must);\n\n    for (i = 0; i < llist->dflt_size; i++) {\n        lydict_remove(ctx, llist->dflt[i]);\n    }\n    free(llist->dflt);\n\n    lys_when_free(ctx, llist->when, private_destructor);\n\n    lys_type_free(ctx, &llist->type, private_destructor);\n    lydict_remove(ctx, llist->units);\n}\n\nstatic void\nlys_list_free(struct ly_ctx *ctx, struct lys_node_list *list,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i, j;\n\n    /* handle only specific parts for LY_NODE_LIST */\n    lys_when_free(ctx, list->when, private_destructor);\n\n    for (i = 0; i < list->must_size; i++) {\n        lys_restr_free(ctx, &list->must[i], private_destructor);\n    }\n    free(list->must);\n\n    for (i = 0; i < list->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &list->tpdf[i], private_destructor);\n    }\n    free(list->tpdf);\n\n    free(list->keys);\n\n    for (i = 0; i < list->unique_size; i++) {\n        for (j = 0; j < list->unique[i].expr_size; j++) {\n            lydict_remove(ctx, list->unique[i].expr[j]);\n        }\n        free(list->unique[i].expr);\n    }\n    free(list->unique);\n\n    lydict_remove(ctx, list->keys_str);\n}\n\nstatic void\nlys_container_free(struct ly_ctx *ctx, struct lys_node_container *cont,\n                   void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    /* handle only specific parts for LY_NODE_CONTAINER */\n    lydict_remove(ctx, cont->presence);\n\n    for (i = 0; i < cont->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &cont->tpdf[i], private_destructor);\n    }\n    free(cont->tpdf);\n\n    for (i = 0; i < cont->must_size; i++) {\n        lys_restr_free(ctx, &cont->must[i], private_destructor);\n    }\n    free(cont->must);\n\n    lys_when_free(ctx, cont->when, private_destructor);\n}\n\nstatic void\nlys_feature_free(struct ly_ctx *ctx, struct lys_feature *f,\n                 void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    lydict_remove(ctx, f->name);\n    lydict_remove(ctx, f->dsc);\n    lydict_remove(ctx, f->ref);\n    lys_iffeature_free(ctx, f->iffeature, f->iffeature_size, 0, private_destructor);\n    ly_set_free(f->depfeatures);\n    lys_extension_instances_free(ctx, f->ext, f->ext_size, private_destructor);\n}\n\nstatic void\nlys_extension_free(struct ly_ctx *ctx, struct lys_ext *e,\n                   void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    lydict_remove(ctx, e->name);\n    lydict_remove(ctx, e->dsc);\n    lydict_remove(ctx, e->ref);\n    lydict_remove(ctx, e->argument);\n    lys_extension_instances_free(ctx, e->ext, e->ext_size, private_destructor);\n}\n\nstatic void\nlys_deviation_free(struct lys_module *module, struct lys_deviation *dev,\n                   void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i, j, k;\n    struct ly_ctx *ctx;\n    struct lys_node *next, *elem;\n\n    ctx = module->ctx;\n\n    lydict_remove(ctx, dev->target_name);\n    lydict_remove(ctx, dev->dsc);\n    lydict_remove(ctx, dev->ref);\n    lys_extension_instances_free(ctx, dev->ext, dev->ext_size, private_destructor);\n\n    if (!dev->deviate) {\n        return;\n    }\n\n    /* it could not be applied because it failed to be applied */\n    if (dev->orig_node) {\n        /* the module was freed, but we only need the context from orig_node, use ours */\n        if (dev->deviate[0].mod == LY_DEVIATE_NO) {\n            /* it's actually a node subtree, we need to update modules on all the nodes :-/ */\n            LY_TREE_DFS_BEGIN(dev->orig_node, next, elem) {\n                elem->module = module;\n\n                LY_TREE_DFS_END(dev->orig_node, next, elem);\n            }\n            lys_node_free(dev->orig_node, NULL, 0);\n        } else {\n            /* it's just a shallow copy, freeing one node */\n            dev->orig_node->module = module;\n            lys_node_free(dev->orig_node, NULL, 1);\n        }\n    }\n\n    for (i = 0; i < dev->deviate_size; i++) {\n        lys_extension_instances_free(ctx, dev->deviate[i].ext, dev->deviate[i].ext_size, private_destructor);\n\n        for (j = 0; j < dev->deviate[i].dflt_size; j++) {\n            lydict_remove(ctx, dev->deviate[i].dflt[j]);\n        }\n        free(dev->deviate[i].dflt);\n\n        lydict_remove(ctx, dev->deviate[i].units);\n\n        if (dev->deviate[i].mod == LY_DEVIATE_DEL) {\n            for (j = 0; j < dev->deviate[i].must_size; j++) {\n                lys_restr_free(ctx, &dev->deviate[i].must[j], private_destructor);\n            }\n            free(dev->deviate[i].must);\n\n            for (j = 0; j < dev->deviate[i].unique_size; j++) {\n                for (k = 0; k < dev->deviate[i].unique[j].expr_size; k++) {\n                    lydict_remove(ctx, dev->deviate[i].unique[j].expr[k]);\n                }\n                free(dev->deviate[i].unique[j].expr);\n            }\n            free(dev->deviate[i].unique);\n        }\n    }\n    free(dev->deviate);\n}\n\nstatic void\nlys_uses_free(struct ly_ctx *ctx, struct lys_node_uses *uses,\n              void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i, j;\n\n    for (i = 0; i < uses->refine_size; i++) {\n        lydict_remove(ctx, uses->refine[i].target_name);\n        lydict_remove(ctx, uses->refine[i].dsc);\n        lydict_remove(ctx, uses->refine[i].ref);\n\n        lys_iffeature_free(ctx, uses->refine[i].iffeature, uses->refine[i].iffeature_size, 0, private_destructor);\n\n        for (j = 0; j < uses->refine[i].must_size; j++) {\n            lys_restr_free(ctx, &uses->refine[i].must[j], private_destructor);\n        }\n        free(uses->refine[i].must);\n\n        for (j = 0; j < uses->refine[i].dflt_size; j++) {\n            lydict_remove(ctx, uses->refine[i].dflt[j]);\n        }\n        free(uses->refine[i].dflt);\n\n        lys_extension_instances_free(ctx, uses->refine[i].ext, uses->refine[i].ext_size, private_destructor);\n\n        if (uses->refine[i].target_type & LYS_CONTAINER) {\n            lydict_remove(ctx, uses->refine[i].mod.presence);\n        }\n    }\n    free(uses->refine);\n\n    for (i = 0; i < uses->augment_size; i++) {\n        lys_augment_free(ctx, &uses->augment[i], private_destructor);\n    }\n    free(uses->augment);\n\n    lys_when_free(ctx, uses->when, private_destructor);\n}\n\nvoid\nlys_node_free(struct lys_node *node, void (*private_destructor)(const struct lys_node *node, void *priv), int shallow)\n{\n    struct ly_ctx *ctx;\n    struct lys_node *sub, *next;\n\n    if (!node) {\n        return;\n    }\n\n    assert(node->module);\n    assert(node->module->ctx);\n\n    ctx = node->module->ctx;\n\n    /* remove private object */\n    if (node->priv && private_destructor) {\n        private_destructor(node, node->priv);\n    }\n\n    /* common part */\n    lydict_remove(ctx, node->name);\n    if (!(node->nodetype & (LYS_INPUT | LYS_OUTPUT))) {\n        lys_iffeature_free(ctx, node->iffeature, node->iffeature_size, shallow, private_destructor);\n        lydict_remove(ctx, node->dsc);\n        lydict_remove(ctx, node->ref);\n    }\n\n    if (!shallow && !(node->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n        LY_TREE_FOR_SAFE(node->child, next, sub) {\n            lys_node_free(sub, private_destructor, 0);\n        }\n    }\n\n    lys_extension_instances_free(ctx, node->ext, node->ext_size, private_destructor);\n\n    /* specific part */\n    switch (node->nodetype) {\n    case LYS_CONTAINER:\n        lys_container_free(ctx, (struct lys_node_container *)node, private_destructor);\n        break;\n    case LYS_CHOICE:\n        lys_when_free(ctx, ((struct lys_node_choice *)node)->when, private_destructor);\n        break;\n    case LYS_LEAF:\n        lys_leaf_free(ctx, (struct lys_node_leaf *)node, private_destructor);\n        break;\n    case LYS_LEAFLIST:\n        lys_leaflist_free(ctx, (struct lys_node_leaflist *)node, private_destructor);\n        break;\n    case LYS_LIST:\n        lys_list_free(ctx, (struct lys_node_list *)node, private_destructor);\n        break;\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        lys_anydata_free(ctx, (struct lys_node_anydata *)node, private_destructor);\n        break;\n    case LYS_USES:\n        lys_uses_free(ctx, (struct lys_node_uses *)node, private_destructor);\n        break;\n    case LYS_CASE:\n        lys_when_free(ctx, ((struct lys_node_case *)node)->when, private_destructor);\n        break;\n    case LYS_AUGMENT:\n        /* do nothing */\n        break;\n    case LYS_GROUPING:\n        lys_grp_free(ctx, (struct lys_node_grp *)node, private_destructor);\n        break;\n    case LYS_RPC:\n    case LYS_ACTION:\n        lys_rpc_action_free(ctx, (struct lys_node_rpc_action *)node, private_destructor);\n        break;\n    case LYS_NOTIF:\n        lys_notif_free(ctx, (struct lys_node_notif *)node, private_destructor);\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        lys_inout_free(ctx, (struct lys_node_inout *)node, private_destructor);\n        break;\n    case LYS_EXT:\n    case LYS_UNKNOWN:\n        LOGINT(ctx);\n        break;\n    }\n\n    /* again common part */\n    lys_node_unlink(node);\n    free(node);\n}\n\nAPI struct lys_module *\nlys_implemented_module(const struct lys_module *mod)\n{\n    struct ly_ctx *ctx;\n    int i;\n\n    if (!mod || mod->implemented) {\n        /* invalid argument or the module itself is implemented */\n        return (struct lys_module *)mod;\n    }\n\n    ctx = mod->ctx;\n    for (i = 0; i < ctx->models.used; i++) {\n        if (!ctx->models.list[i]->implemented) {\n            continue;\n        }\n\n        if (ly_strequal(mod->name, ctx->models.list[i]->name, 1)) {\n            /* we have some revision of the module implemented */\n            return ctx->models.list[i];\n        }\n    }\n\n    /* we have no revision of the module implemented, return the module itself,\n     * it is up to the caller to set the module implemented when needed */\n    return (struct lys_module *)mod;\n}\n\n/* free_int_mods - flag whether to free the internal modules as well */\nstatic void\nmodule_free_common(struct lys_module *module, void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    struct ly_ctx *ctx;\n    struct lys_node *next, *iter;\n    unsigned int i;\n\n    assert(module->ctx);\n    ctx = module->ctx;\n\n    /* just free the import array, imported modules will stay in the context */\n    for (i = 0; i < module->imp_size; i++) {\n        lydict_remove(ctx, module->imp[i].prefix);\n        lydict_remove(ctx, module->imp[i].dsc);\n        lydict_remove(ctx, module->imp[i].ref);\n        lys_extension_instances_free(ctx, module->imp[i].ext, module->imp[i].ext_size, private_destructor);\n    }\n    free(module->imp);\n\n    /* submodules don't have data tree, the data nodes\n     * are placed in the main module altogether */\n    if (!module->type) {\n        LY_TREE_FOR_SAFE(module->data, next, iter) {\n            lys_node_free(iter, private_destructor, 0);\n        }\n    }\n\n    lydict_remove(ctx, module->dsc);\n    lydict_remove(ctx, module->ref);\n    lydict_remove(ctx, module->org);\n    lydict_remove(ctx, module->contact);\n    lydict_remove(ctx, module->filepath);\n\n    /* revisions */\n    for (i = 0; i < module->rev_size; i++) {\n        lys_extension_instances_free(ctx, module->rev[i].ext, module->rev[i].ext_size, private_destructor);\n        lydict_remove(ctx, module->rev[i].dsc);\n        lydict_remove(ctx, module->rev[i].ref);\n    }\n    free(module->rev);\n\n    /* identities */\n    for (i = 0; i < module->ident_size; i++) {\n        lys_ident_free(ctx, &module->ident[i], private_destructor);\n    }\n    module->ident_size = 0;\n    free(module->ident);\n\n    /* typedefs */\n    for (i = 0; i < module->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &module->tpdf[i], private_destructor);\n    }\n    free(module->tpdf);\n\n    /* extension instances */\n    lys_extension_instances_free(ctx, module->ext, module->ext_size, private_destructor);\n\n    /* augment */\n    for (i = 0; i < module->augment_size; i++) {\n        lys_augment_free(ctx, &module->augment[i], private_destructor);\n    }\n    free(module->augment);\n\n    /* features */\n    for (i = 0; i < module->features_size; i++) {\n        lys_feature_free(ctx, &module->features[i], private_destructor);\n    }\n    free(module->features);\n\n    /* deviations */\n    for (i = 0; i < module->deviation_size; i++) {\n        lys_deviation_free(module, &module->deviation[i], private_destructor);\n    }\n    free(module->deviation);\n\n    /* extensions */\n    for (i = 0; i < module->extensions_size; i++) {\n        lys_extension_free(ctx, &module->extensions[i], private_destructor);\n    }\n    free(module->extensions);\n\n    lydict_remove(ctx, module->name);\n    lydict_remove(ctx, module->prefix);\n}\n\nvoid\nlys_submodule_free(struct lys_submodule *submodule, void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i;\n\n    if (!submodule) {\n        return;\n    }\n\n    /* common part with struct ly_module */\n    module_free_common((struct lys_module *)submodule, private_destructor);\n\n    /* include */\n    for (i = 0; i < submodule->inc_size; i++) {\n        lydict_remove(submodule->ctx, submodule->inc[i].dsc);\n        lydict_remove(submodule->ctx, submodule->inc[i].ref);\n        lys_extension_instances_free(submodule->ctx, submodule->inc[i].ext, submodule->inc[i].ext_size, private_destructor);\n        /* complete submodule free is done only from main module since\n         * submodules propagate their includes to the main module */\n    }\n    free(submodule->inc);\n\n    free(submodule);\n}\n\nint\nlys_ingrouping(const struct lys_node *node)\n{\n    const struct lys_node *iter = node;\n    assert(node);\n\n    for(iter = node; iter && iter->nodetype != LYS_GROUPING; iter = lys_parent(iter));\n    if (!iter) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n\n/*\n * final: 0 - do not change config flags; 1 - inherit config flags from the parent; 2 - remove config flags\n */\nstatic struct lys_node *\nlys_node_dup_recursion(struct lys_module *module, struct lys_node *parent, const struct lys_node *node,\n                       struct unres_schema *unres, int shallow, int finalize)\n{\n    struct lys_node *retval = NULL, *iter, *p;\n    struct ly_ctx *ctx = module->ctx;\n    int i, j, rc;\n    unsigned int size, size1, size2;\n    struct unres_list_uniq *unique_info;\n    uint16_t flags;\n\n    struct lys_node_container *cont = NULL;\n    struct lys_node_container *cont_orig = (struct lys_node_container *)node;\n    struct lys_node_choice *choice = NULL;\n    struct lys_node_choice *choice_orig = (struct lys_node_choice *)node;\n    struct lys_node_leaf *leaf = NULL;\n    struct lys_node_leaf *leaf_orig = (struct lys_node_leaf *)node;\n    struct lys_node_leaflist *llist = NULL;\n    struct lys_node_leaflist *llist_orig = (struct lys_node_leaflist *)node;\n    struct lys_node_list *list = NULL;\n    struct lys_node_list *list_orig = (struct lys_node_list *)node;\n    struct lys_node_anydata *any = NULL;\n    struct lys_node_anydata *any_orig = (struct lys_node_anydata *)node;\n    struct lys_node_uses *uses = NULL;\n    struct lys_node_uses *uses_orig = (struct lys_node_uses *)node;\n    struct lys_node_rpc_action *rpc = NULL;\n    struct lys_node_inout *io = NULL;\n    struct lys_node_notif *ntf = NULL;\n    struct lys_node_case *cs = NULL;\n    struct lys_node_case *cs_orig = (struct lys_node_case *)node;\n\n    /* we cannot just duplicate memory since the strings are stored in\n     * dictionary and we need to update dictionary counters.\n     */\n\n    switch (node->nodetype) {\n    case LYS_CONTAINER:\n        cont = calloc(1, sizeof *cont);\n        retval = (struct lys_node *)cont;\n        break;\n\n    case LYS_CHOICE:\n        choice = calloc(1, sizeof *choice);\n        retval = (struct lys_node *)choice;\n        break;\n\n    case LYS_LEAF:\n        leaf = calloc(1, sizeof *leaf);\n        retval = (struct lys_node *)leaf;\n        break;\n\n    case LYS_LEAFLIST:\n        llist = calloc(1, sizeof *llist);\n        retval = (struct lys_node *)llist;\n        break;\n\n    case LYS_LIST:\n        list = calloc(1, sizeof *list);\n        retval = (struct lys_node *)list;\n        break;\n\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        any = calloc(1, sizeof *any);\n        retval = (struct lys_node *)any;\n        break;\n\n    case LYS_USES:\n        uses = calloc(1, sizeof *uses);\n        retval = (struct lys_node *)uses;\n        break;\n\n    case LYS_CASE:\n        cs = calloc(1, sizeof *cs);\n        retval = (struct lys_node *)cs;\n        break;\n\n    case LYS_RPC:\n    case LYS_ACTION:\n        rpc = calloc(1, sizeof *rpc);\n        retval = (struct lys_node *)rpc;\n        break;\n\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        io = calloc(1, sizeof *io);\n        retval = (struct lys_node *)io;\n        break;\n\n    case LYS_NOTIF:\n        ntf = calloc(1, sizeof *ntf);\n        retval = (struct lys_node *)ntf;\n        break;\n\n    default:\n        LOGINT(ctx);\n        goto error;\n    }\n    LY_CHECK_ERR_RETURN(!retval, LOGMEM(ctx), NULL);\n\n    /*\n     * duplicate generic part of the structure\n     */\n    retval->name = lydict_insert(ctx, node->name, 0);\n    retval->dsc = lydict_insert(ctx, node->dsc, 0);\n    retval->ref = lydict_insert(ctx, node->ref, 0);\n    retval->flags = node->flags;\n\n    retval->module = module;\n    retval->nodetype = node->nodetype;\n\n    retval->prev = retval;\n\n    retval->ext_size = node->ext_size;\n    if (lys_ext_dup(ctx, module, node->ext, node->ext_size, retval, LYEXT_PAR_NODE, &retval->ext, shallow, unres)) {\n        goto error;\n    }\n\n    if (node->iffeature_size) {\n        retval->iffeature_size = node->iffeature_size;\n        retval->iffeature = calloc(retval->iffeature_size, sizeof *retval->iffeature);\n        LY_CHECK_ERR_GOTO(!retval->iffeature, LOGMEM(ctx), error);\n    }\n\n    if (!shallow) {\n        for (i = 0; i < node->iffeature_size; ++i) {\n            resolve_iffeature_getsizes(&node->iffeature[i], &size1, &size2);\n            if (size1) {\n                /* there is something to duplicate */\n\n                /* duplicate compiled expression */\n                size = (size1 / 4) + (size1 % 4) ? 1 : 0;\n                retval->iffeature[i].expr = malloc(size * sizeof *retval->iffeature[i].expr);\n                LY_CHECK_ERR_GOTO(!retval->iffeature[i].expr, LOGMEM(ctx), error);\n                memcpy(retval->iffeature[i].expr, node->iffeature[i].expr, size * sizeof *retval->iffeature[i].expr);\n\n                /* list of feature pointer must be updated to point to the resulting tree */\n                retval->iffeature[i].features = calloc(size2, sizeof *retval->iffeature[i].features);\n                LY_CHECK_ERR_GOTO(!retval->iffeature[i].features, LOGMEM(ctx); free(retval->iffeature[i].expr), error);\n\n                for (j = 0; (unsigned int)j < size2; j++) {\n                    rc = unres_schema_dup(module, unres, &node->iffeature[i].features[j], UNRES_IFFEAT,\n                                          &retval->iffeature[i].features[j]);\n                    if (rc == EXIT_FAILURE) {\n                        /* feature is resolved in origin, so copy it\n                         * - duplication is used for instantiating groupings\n                         * and if-feature inside grouping is supposed to be\n                         * resolved inside the original grouping, so we want\n                         * to keep pointers to features from the grouping\n                         * context */\n                        retval->iffeature[i].features[j] = node->iffeature[i].features[j];\n                    } else if (rc == -1) {\n                        goto error;\n                    } /* else unres was duplicated */\n                }\n            }\n\n            /* duplicate if-feature's extensions */\n            retval->iffeature[i].ext_size = node->iffeature[i].ext_size;\n            if (lys_ext_dup(ctx, module, node->iffeature[i].ext, node->iffeature[i].ext_size,\n                            &retval->iffeature[i], LYEXT_PAR_IFFEATURE, &retval->iffeature[i].ext, shallow, unres)) {\n                goto error;\n            }\n        }\n\n        /* inherit config flags */\n        p = parent;\n        do {\n            for (iter = p; iter && (iter->nodetype == LYS_USES); iter = iter->parent);\n        } while (iter && iter->nodetype == LYS_AUGMENT && (p = lys_parent(iter)));\n        if (iter) {\n            flags = iter->flags & LYS_CONFIG_MASK;\n        } else {\n            /* default */\n            flags = LYS_CONFIG_W;\n        }\n\n        switch (finalize) {\n        case 1:\n            /* inherit config flags */\n            if (retval->flags & LYS_CONFIG_SET) {\n                /* skip nodes with an explicit config value */\n                if ((flags & LYS_CONFIG_R) && (retval->flags & LYS_CONFIG_W)) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, \"true\", \"config\");\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"State nodes cannot have configuration nodes as children.\");\n                    goto error;\n                }\n                break;\n            }\n\n            if (retval->nodetype != LYS_USES) {\n                retval->flags = (retval->flags & ~LYS_CONFIG_MASK) | flags;\n            }\n\n            /* inherit status */\n            if ((parent->flags & LYS_STATUS_MASK) > (retval->flags & LYS_STATUS_MASK)) {\n                /* but do it only in case the parent has a stonger status */\n                retval->flags &= ~LYS_STATUS_MASK;\n                retval->flags |= (parent->flags & LYS_STATUS_MASK);\n            }\n            break;\n        case 2:\n            /* erase config flags */\n            retval->flags &= ~LYS_CONFIG_MASK;\n            retval->flags &= ~LYS_CONFIG_SET;\n            break;\n        }\n\n        /* connect it to the parent */\n        if (lys_node_addchild(parent, retval->module, retval, 0)) {\n            goto error;\n        }\n\n        /* go recursively */\n        if (!(node->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n            LY_TREE_FOR(node->child, iter) {\n                if (iter->nodetype & LYS_GROUPING) {\n                    /* do not instantiate groupings */\n                    continue;\n                }\n                if (!lys_node_dup_recursion(module, retval, iter, unres, 0, finalize)) {\n                    goto error;\n                }\n            }\n        }\n\n        if (finalize == 1) {\n            /* check that configuration lists have keys\n             * - we really want to check keys_size in original node, because the keys are\n             * not yet resolved here, it is done below in nodetype specific part */\n            if ((retval->nodetype == LYS_LIST) && (retval->flags & LYS_CONFIG_W)\n                    && !((struct lys_node_list *)node)->keys_size) {\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, retval, \"key\", \"list\");\n                goto error;\n            }\n        }\n    } else {\n        memcpy(retval->iffeature, node->iffeature, retval->iffeature_size * sizeof *retval->iffeature);\n    }\n\n    /*\n     * duplicate specific part of the structure\n     */\n    switch (node->nodetype) {\n    case LYS_CONTAINER:\n        if (cont_orig->when) {\n            cont->when = lys_when_dup(module, cont_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!cont->when, error);\n        }\n        cont->presence = lydict_insert(ctx, cont_orig->presence, 0);\n\n        if (cont_orig->must) {\n            cont->must = lys_restr_dup(module, cont_orig->must, cont_orig->must_size, shallow, unres);\n            LY_CHECK_GOTO(!cont->must, error);\n            cont->must_size = cont_orig->must_size;\n        }\n\n        /* typedefs are not needed in instantiated grouping, nor the deviation's shallow copy */\n\n        break;\n    case LYS_CHOICE:\n        if (choice_orig->when) {\n            choice->when = lys_when_dup(module, choice_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!choice->when, error);\n        }\n\n        if (!shallow) {\n            if (choice_orig->dflt) {\n                rc = lys_get_sibling(choice->child, lys_node_module(retval)->name, 0, choice_orig->dflt->name, 0,\n                                            LYS_ANYDATA | LYS_CASE | LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST,\n                                            (const struct lys_node **)&choice->dflt);\n                if (rc) {\n                    if (rc == EXIT_FAILURE) {\n                        LOGINT(ctx);\n                    }\n                    goto error;\n                }\n            } else {\n                /* useless to check return value, we don't know whether\n                * there really wasn't any default defined or it just hasn't\n                * been resolved, we just hope for the best :)\n                */\n                unres_schema_dup(module, unres, choice_orig, UNRES_CHOICE_DFLT, choice);\n            }\n        } else {\n            choice->dflt = choice_orig->dflt;\n        }\n        break;\n\n    case LYS_LEAF:\n        if (lys_type_dup(module, retval, &(leaf->type), &(leaf_orig->type), lys_ingrouping(retval), shallow, unres)) {\n            goto error;\n        }\n        leaf->units = lydict_insert(module->ctx, leaf_orig->units, 0);\n\n        if (leaf_orig->dflt) {\n            leaf->dflt = lydict_insert(ctx, leaf_orig->dflt, 0);\n        }\n\n        if (leaf_orig->must) {\n            leaf->must = lys_restr_dup(module, leaf_orig->must, leaf_orig->must_size, shallow, unres);\n            LY_CHECK_GOTO(!leaf->must, error);\n            leaf->must_size = leaf_orig->must_size;\n        }\n\n        if (leaf_orig->when) {\n            leaf->when = lys_when_dup(module, leaf_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!leaf->when, error);\n        }\n        break;\n\n    case LYS_LEAFLIST:\n        if (lys_type_dup(module, retval, &(llist->type), &(llist_orig->type), lys_ingrouping(retval), shallow, unres)) {\n            goto error;\n        }\n        llist->units = lydict_insert(module->ctx, llist_orig->units, 0);\n\n        llist->min = llist_orig->min;\n        llist->max = llist_orig->max;\n\n        if (llist_orig->must) {\n            llist->must = lys_restr_dup(module, llist_orig->must, llist_orig->must_size, shallow, unres);\n            LY_CHECK_GOTO(!llist->must, error);\n            llist->must_size = llist_orig->must_size;\n        }\n\n        if (llist_orig->dflt) {\n            llist->dflt = malloc(llist_orig->dflt_size * sizeof *llist->dflt);\n            LY_CHECK_ERR_GOTO(!llist->dflt, LOGMEM(ctx), error);\n            llist->dflt_size = llist_orig->dflt_size;\n\n            for (i = 0; i < llist->dflt_size; i++) {\n                llist->dflt[i] = lydict_insert(ctx, llist_orig->dflt[i], 0);\n            }\n        }\n\n        if (llist_orig->when) {\n            llist->when = lys_when_dup(module, llist_orig->when, shallow, unres);\n        }\n        break;\n\n    case LYS_LIST:\n        list->min = list_orig->min;\n        list->max = list_orig->max;\n\n        if (list_orig->must) {\n            list->must = lys_restr_dup(module, list_orig->must, list_orig->must_size, shallow, unres);\n            LY_CHECK_GOTO(!list->must, error);\n            list->must_size = list_orig->must_size;\n        }\n\n        /* typedefs are not needed in instantiated grouping, nor the deviation's shallow copy */\n\n        if (list_orig->keys_size) {\n            list->keys = calloc(list_orig->keys_size, sizeof *list->keys);\n            LY_CHECK_ERR_GOTO(!list->keys, LOGMEM(ctx), error);\n            list->keys_str = lydict_insert(ctx, list_orig->keys_str, 0);\n            list->keys_size = list_orig->keys_size;\n\n            if (!shallow) {\n                if (unres_schema_add_node(module, unres, list, UNRES_LIST_KEYS, NULL) == -1) {\n                    goto error;\n                }\n            } else {\n                memcpy(list->keys, list_orig->keys, list_orig->keys_size * sizeof *list->keys);\n            }\n        }\n\n        if (list_orig->unique) {\n            list->unique = malloc(list_orig->unique_size * sizeof *list->unique);\n            LY_CHECK_ERR_GOTO(!list->unique, LOGMEM(ctx), error);\n            list->unique_size = list_orig->unique_size;\n\n            for (i = 0; i < list->unique_size; ++i) {\n                list->unique[i].expr = malloc(list_orig->unique[i].expr_size * sizeof *list->unique[i].expr);\n                LY_CHECK_ERR_GOTO(!list->unique[i].expr, LOGMEM(ctx), error);\n                list->unique[i].expr_size = list_orig->unique[i].expr_size;\n                for (j = 0; j < list->unique[i].expr_size; j++) {\n                    list->unique[i].expr[j] = lydict_insert(ctx, list_orig->unique[i].expr[j], 0);\n\n                    /* if it stays in unres list, duplicate it also there */\n                    unique_info = malloc(sizeof *unique_info);\n                    LY_CHECK_ERR_GOTO(!unique_info, LOGMEM(ctx), error);\n                    unique_info->list = (struct lys_node *)list;\n                    unique_info->expr = list->unique[i].expr[j];\n                    unique_info->trg_type = &list->unique[i].trg_type;\n                    unres_schema_dup(module, unres, &list_orig, UNRES_LIST_UNIQ, unique_info);\n                }\n            }\n        }\n\n        if (list_orig->when) {\n            list->when = lys_when_dup(module, list_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!list->when, error);\n        }\n        break;\n\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        if (any_orig->must) {\n            any->must = lys_restr_dup(module, any_orig->must, any_orig->must_size, shallow, unres);\n            LY_CHECK_GOTO(!any->must, error);\n            any->must_size = any_orig->must_size;\n        }\n\n        if (any_orig->when) {\n            any->when = lys_when_dup(module, any_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!any->when, error);\n        }\n        break;\n\n    case LYS_USES:\n        uses->grp = uses_orig->grp;\n\n        if (uses_orig->when) {\n            uses->when = lys_when_dup(module, uses_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!uses->when, error);\n        }\n        /* it is not needed to duplicate refine, nor augment. They are already applied to the uses children */\n        break;\n\n    case LYS_CASE:\n        if (cs_orig->when) {\n            cs->when = lys_when_dup(module, cs_orig->when, shallow, unres);\n            LY_CHECK_GOTO(!cs->when, error);\n        }\n        break;\n\n    case LYS_ACTION:\n    case LYS_RPC:\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n    case LYS_NOTIF:\n        /* typedefs are not needed in instantiated grouping, nor the deviation's shallow copy */\n        break;\n\n    default:\n        /* LY_NODE_AUGMENT */\n        LOGINT(ctx);\n        goto error;\n    }\n\n    return retval;\n\nerror:\n    lys_node_free(retval, NULL, 0);\n    return NULL;\n}\n\nint\nlys_has_xpath(const struct lys_node *node)\n{\n    assert(node);\n\n    switch (node->nodetype) {\n    case LYS_AUGMENT:\n        if (((struct lys_node_augment *)node)->when) {\n            return 1;\n        }\n        break;\n    case LYS_CASE:\n        if (((struct lys_node_case *)node)->when) {\n            return 1;\n        }\n        break;\n    case LYS_CHOICE:\n        if (((struct lys_node_choice *)node)->when) {\n            return 1;\n        }\n        break;\n    case LYS_ANYDATA:\n        if (((struct lys_node_anydata *)node)->when || ((struct lys_node_anydata *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_LEAF:\n        if (((struct lys_node_leaf *)node)->when || ((struct lys_node_leaf *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_LEAFLIST:\n        if (((struct lys_node_leaflist *)node)->when || ((struct lys_node_leaflist *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_LIST:\n        if (((struct lys_node_list *)node)->when || ((struct lys_node_list *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_CONTAINER:\n        if (((struct lys_node_container *)node)->when || ((struct lys_node_container *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        if (((struct lys_node_inout *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_NOTIF:\n        if (((struct lys_node_notif *)node)->must_size) {\n            return 1;\n        }\n        break;\n    case LYS_USES:\n        if (((struct lys_node_uses *)node)->when) {\n            return 1;\n        }\n        break;\n    default:\n        /* does not have XPath */\n        break;\n    }\n\n    return 0;\n}\n\nint\nlys_type_is_local(const struct lys_type *type)\n{\n    if (!type->der->module) {\n        /* build-in type */\n        return 1;\n    }\n    /* type->parent can be either a typedef or leaf/leaf-list, but module pointers are compatible */\n    return (lys_main_module(type->der->module) == lys_main_module(((struct lys_tpdf *)type->parent)->module));\n}\n\n/*\n * shallow -\n *         - do not inherit status from the parent\n */\nstruct lys_node *\nlys_node_dup(struct lys_module *module, struct lys_node *parent, const struct lys_node *node,\n             struct unres_schema *unres, int shallow)\n{\n    struct lys_node *p = NULL;\n    int finalize = 0;\n    struct lys_node *result, *iter, *next;\n\n    if (!shallow) {\n        /* get know where in schema tree we are to know what should be done during instantiation of the grouping */\n        for (p = parent;\n             p && !(p->nodetype & (LYS_NOTIF | LYS_INPUT | LYS_OUTPUT | LYS_RPC | LYS_ACTION | LYS_GROUPING));\n             p = lys_parent(p));\n        finalize = p ? ((p->nodetype == LYS_GROUPING) ? 0 : 2) : 1;\n    }\n\n    result = lys_node_dup_recursion(module, parent, node, unres, shallow, finalize);\n    if (finalize) {\n        /* check xpath expressions in the instantiated tree */\n        for (iter = next = result; iter; iter = next) {\n            if (lys_has_xpath(iter) && unres_schema_add_node(module, unres, iter, UNRES_XPATH, NULL) == -1) {\n                /* invalid xpath */\n                return NULL;\n            }\n\n            /* select next item */\n            if (iter->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA | LYS_GROUPING)) {\n                /* child exception for leafs, leaflists and anyxml without children, ignore groupings */\n                next = NULL;\n            } else {\n                next = iter->child;\n            }\n            if (!next) {\n                /* no children, try siblings */\n                if (iter == result) {\n                    /* we are done, no next element to process */\n                    break;\n                }\n                next = iter->next;\n            }\n            while (!next) {\n                /* parent is already processed, go to its sibling */\n                iter = lys_parent(iter);\n                if (lys_parent(iter) == lys_parent(result)) {\n                    /* we are done, no next element to process */\n                    break;\n                }\n                next = iter->next;\n            }\n        }\n    }\n\n    return result;\n}\n\n/**\n * @brief Switch contents of two same schema nodes. One of the nodes\n * is expected to be ashallow copy of the other.\n *\n * @param[in] node1 Node whose contents will be switched with \\p node2.\n * @param[in] node2 Node whose contents will be switched with \\p node1.\n */\nstatic void\nlys_node_switch(struct lys_node *node1, struct lys_node *node2)\n{\n    const size_t mem_size = 104;\n    uint8_t mem[mem_size];\n    size_t offset, size;\n\n    assert((node1->module == node2->module) && ly_strequal(node1->name, node2->name, 1) && (node1->nodetype == node2->nodetype));\n\n    /*\n     * Initially, the nodes were really switched in the tree which\n     * caused problems for some other nodes with pointers (augments, leafrefs, ...)\n     * because their pointers were not being updated. Code kept in case there is\n     * a use of it in future (it took some debugging to cover all the cases).\n\n    * sibling next *\n    if (node1->prev->next) {\n        node1->prev->next = node2;\n    }\n\n    * sibling prev *\n    if (node1->next) {\n        node1->next->prev = node2;\n    } else {\n        for (child = node1->prev; child->prev->next; child = child->prev);\n        child->prev = node2;\n    }\n\n    * next *\n    node2->next = node1->next;\n    node1->next = NULL;\n\n    * prev *\n    if (node1->prev != node1) {\n        node2->prev = node1->prev;\n    }\n    node1->prev = node1;\n\n    * parent child *\n    if (node1->parent) {\n        if (node1->parent->child == node1) {\n            node1->parent->child = node2;\n        }\n    } else if (lys_main_module(node1->module)->data == node1) {\n        lys_main_module(node1->module)->data = node2;\n    }\n\n    * parent *\n    node2->parent = node1->parent;\n    node1->parent = NULL;\n\n    * child parent *\n    LY_TREE_FOR(node1->child, child) {\n        if (child->parent == node1) {\n            child->parent = node2;\n        }\n    }\n\n    * child *\n    node2->child = node1->child;\n    node1->child = NULL;\n    */\n\n    /* switch common node part */\n    offset = 3 * sizeof(char *);\n    size = sizeof(uint16_t) + 6 * sizeof(uint8_t) + sizeof(struct lys_ext_instance **) + sizeof(struct lys_iffeature *);\n    memcpy(mem, ((uint8_t *)node1) + offset, size);\n    memcpy(((uint8_t *)node1) + offset, ((uint8_t *)node2) + offset, size);\n    memcpy(((uint8_t *)node2) + offset, mem, size);\n\n    /* switch node-specific data */\n    offset = sizeof(struct lys_node);\n    switch (node1->nodetype) {\n    case LYS_CONTAINER:\n        size = sizeof(struct lys_node_container) - offset;\n        break;\n    case LYS_CHOICE:\n        size = sizeof(struct lys_node_choice) - offset;\n        break;\n    case LYS_LEAF:\n        size = sizeof(struct lys_node_leaf) - offset;\n        break;\n    case LYS_LEAFLIST:\n        size = sizeof(struct lys_node_leaflist) - offset;\n        break;\n    case LYS_LIST:\n        size = sizeof(struct lys_node_list) - offset;\n        break;\n    case LYS_ANYDATA:\n    case LYS_ANYXML:\n        size = sizeof(struct lys_node_anydata) - offset;\n        break;\n    case LYS_CASE:\n        size = sizeof(struct lys_node_case) - offset;\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        size = sizeof(struct lys_node_inout) - offset;\n        break;\n    case LYS_NOTIF:\n        size = sizeof(struct lys_node_notif) - offset;\n        break;\n    case LYS_RPC:\n    case LYS_ACTION:\n        size = sizeof(struct lys_node_rpc_action) - offset;\n        break;\n    default:\n        assert(0);\n        LOGINT(node1->module->ctx);\n        return;\n    }\n    assert(size <= mem_size);\n    memcpy(mem, ((uint8_t *)node1) + offset, size);\n    memcpy(((uint8_t *)node1) + offset, ((uint8_t *)node2) + offset, size);\n    memcpy(((uint8_t *)node2) + offset, mem, size);\n\n    /* typedefs were not copied to the backup node, so always reuse them,\n     * in leaves/leaf-lists we must correct the type parent pointer */\n    switch (node1->nodetype) {\n    case LYS_CONTAINER:\n        ((struct lys_node_container *)node1)->tpdf_size = ((struct lys_node_container *)node2)->tpdf_size;\n        ((struct lys_node_container *)node1)->tpdf = ((struct lys_node_container *)node2)->tpdf;\n        ((struct lys_node_container *)node2)->tpdf_size = 0;\n        ((struct lys_node_container *)node2)->tpdf = NULL;\n        break;\n    case LYS_LIST:\n        ((struct lys_node_list *)node1)->tpdf_size = ((struct lys_node_list *)node2)->tpdf_size;\n        ((struct lys_node_list *)node1)->tpdf = ((struct lys_node_list *)node2)->tpdf;\n        ((struct lys_node_list *)node2)->tpdf_size = 0;\n        ((struct lys_node_list *)node2)->tpdf = NULL;\n        break;\n    case LYS_RPC:\n    case LYS_ACTION:\n        ((struct lys_node_rpc_action *)node1)->tpdf_size = ((struct lys_node_rpc_action *)node2)->tpdf_size;\n        ((struct lys_node_rpc_action *)node1)->tpdf = ((struct lys_node_rpc_action *)node2)->tpdf;\n        ((struct lys_node_rpc_action *)node2)->tpdf_size = 0;\n        ((struct lys_node_rpc_action *)node2)->tpdf = NULL;\n        break;\n    case LYS_NOTIF:\n        ((struct lys_node_notif *)node1)->tpdf_size = ((struct lys_node_notif *)node2)->tpdf_size;\n        ((struct lys_node_notif *)node1)->tpdf = ((struct lys_node_notif *)node2)->tpdf;\n        ((struct lys_node_notif *)node2)->tpdf_size = 0;\n        ((struct lys_node_notif *)node2)->tpdf = NULL;\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        ((struct lys_node_inout *)node1)->tpdf_size = ((struct lys_node_inout *)node2)->tpdf_size;\n        ((struct lys_node_inout *)node1)->tpdf = ((struct lys_node_inout *)node2)->tpdf;\n        ((struct lys_node_inout *)node2)->tpdf_size = 0;\n        ((struct lys_node_inout *)node2)->tpdf = NULL;\n        break;\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n        ((struct lys_node_leaf *)node1)->type.parent = (struct lys_tpdf *)node1;\n        ((struct lys_node_leaf *)node2)->type.parent = (struct lys_tpdf *)node2;\n    default:\n        break;\n    }\n}\n\nvoid\nlys_free(struct lys_module *module, void (*private_destructor)(const struct lys_node *node, void *priv), int free_subs, int remove_from_ctx)\n{\n    struct ly_ctx *ctx;\n    int i;\n\n    if (!module) {\n        return;\n    }\n\n    /* remove schema from the context */\n    ctx = module->ctx;\n    if (remove_from_ctx && ctx->models.used) {\n        for (i = 0; i < ctx->models.used; i++) {\n            if (ctx->models.list[i] == module) {\n                /* move all the models to not change the order in the list */\n                ctx->models.used--;\n                memmove(&ctx->models.list[i], ctx->models.list[i + 1], (ctx->models.used - i) * sizeof *ctx->models.list);\n                ctx->models.list[ctx->models.used] = NULL;\n                /* we are done */\n                break;\n            }\n        }\n    }\n\n    /* common part with struct ly_submodule */\n    module_free_common(module, private_destructor);\n\n    /* include */\n    for (i = 0; i < module->inc_size; i++) {\n        lydict_remove(ctx, module->inc[i].dsc);\n        lydict_remove(ctx, module->inc[i].ref);\n        lys_extension_instances_free(ctx, module->inc[i].ext, module->inc[i].ext_size, private_destructor);\n        /* complete submodule free is done only from main module since\n         * submodules propagate their includes to the main module */\n        if (free_subs) {\n            lys_submodule_free(module->inc[i].submodule, private_destructor);\n        }\n    }\n    free(module->inc);\n\n    /* specific items to free */\n    lydict_remove(ctx, module->ns);\n\n    free(module);\n}\n\nstatic void\nlys_features_disable_recursive(struct lys_feature *f)\n{\n    unsigned int i;\n    struct lys_feature *depf;\n\n    /* disable the feature */\n    f->flags &= ~LYS_FENABLED;\n\n    /* by disabling feature we have to disable also all features that depends on this feature */\n    if (f->depfeatures) {\n        for (i = 0; i < f->depfeatures->number; i++) {\n            depf = (struct lys_feature *)f->depfeatures->set.g[i];\n            if (depf->flags & LYS_FENABLED) {\n                lys_features_disable_recursive(depf);\n            }\n        }\n    }\n}\n\n/*\n * op: 1 - enable, 0 - disable\n */\nstatic int\nlys_features_change(const struct lys_module *module, const char *name, int op)\n{\n    int all = 0;\n    int i, j, k;\n    int progress, faili, failj, failk;\n\n    uint8_t fsize;\n    struct lys_feature *f;\n\n    if (!module || !name || !strlen(name)) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    if (!strcmp(name, \"*\")) {\n        /* enable all */\n        all = 1;\n    }\n\n    progress = failk = 1;\n    while (progress && failk) {\n        for (i = -1, failk = progress = 0; i < module->inc_size; i++) {\n            if (i == -1) {\n                fsize = module->features_size;\n                f = module->features;\n            } else {\n                fsize = module->inc[i].submodule->features_size;\n                f = module->inc[i].submodule->features;\n            }\n\n            for (j = 0; j < fsize; j++) {\n                if (all || !strcmp(f[j].name, name)) {\n                    if ((op && (f[j].flags & LYS_FENABLED)) || (!op && !(f[j].flags & LYS_FENABLED))) {\n                        if (all) {\n                            /* skip already set features */\n                            continue;\n                        } else {\n                            /* feature already set correctly */\n                            return EXIT_SUCCESS;\n                        }\n                    }\n\n                    if (op) {\n                        /* check referenced features if they are enabled */\n                        for (k = 0; k < f[j].iffeature_size; k++) {\n                            if (!resolve_iffeature(&f[j].iffeature[k])) {\n                                if (all) {\n                                    faili = i;\n                                    failj = j;\n                                    failk = k + 1;\n                                    break;\n                                } else {\n                                    LOGERR(module->ctx, LY_EINVAL, \"Feature \\\"%s\\\" is disabled by its %d. if-feature condition.\",\n                                           f[j].name, k + 1);\n                                    return EXIT_FAILURE;\n                                }\n                            }\n                        }\n\n                        if (k == f[j].iffeature_size) {\n                            /* the last check passed, do the change */\n                            f[j].flags |= LYS_FENABLED;\n                            progress++;\n                        }\n                    } else {\n                        lys_features_disable_recursive(&f[j]);\n                        progress++;\n                    }\n                    if (!all) {\n                        /* stop in case changing a single feature */\n                        return EXIT_SUCCESS;\n                    }\n                }\n            }\n        }\n    }\n    if (failk) {\n        /* print info about the last failing feature */\n        LOGERR(module->ctx, LY_EINVAL, \"Feature \\\"%s\\\" is disabled by its %d. if-feature condition.\",\n               faili == -1 ? module->features[failj].name : module->inc[faili].submodule->features[failj].name, failk);\n        return EXIT_FAILURE;\n    }\n\n    if (all) {\n        return EXIT_SUCCESS;\n    } else {\n        /* the specified feature not found */\n        return EXIT_FAILURE;\n    }\n}\n\nAPI int\nlys_features_enable(const struct lys_module *module, const char *feature)\n{\n    return lys_features_change(module, feature, 1);\n}\n\nAPI int\nlys_features_disable(const struct lys_module *module, const char *feature)\n{\n    return lys_features_change(module, feature, 0);\n}\n\nAPI int\nlys_features_state(const struct lys_module *module, const char *feature)\n{\n    int i, j;\n\n    if (!module || !feature) {\n        return -1;\n    }\n\n    /* search for the specified feature */\n    /* module itself */\n    for (i = 0; i < module->features_size; i++) {\n        if (!strcmp(feature, module->features[i].name)) {\n            if (module->features[i].flags & LYS_FENABLED) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    /* submodules */\n    for (j = 0; j < module->inc_size; j++) {\n        for (i = 0; i < module->inc[j].submodule->features_size; i++) {\n            if (!strcmp(feature, module->inc[j].submodule->features[i].name)) {\n                if (module->inc[j].submodule->features[i].flags & LYS_FENABLED) {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            }\n        }\n    }\n\n    /* feature definition not found */\n    return -1;\n}\n\nAPI const char **\nlys_features_list(const struct lys_module *module, uint8_t **states)\n{\n    const char **result = NULL;\n    int i, j;\n    unsigned int count;\n\n    if (!module) {\n        return NULL;\n    }\n\n    count = module->features_size;\n    for (i = 0; i < module->inc_size; i++) {\n        count += module->inc[i].submodule->features_size;\n    }\n    result = malloc((count + 1) * sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(module->ctx), NULL);\n\n    if (states) {\n        *states = malloc((count + 1) * sizeof **states);\n        LY_CHECK_ERR_RETURN(!(*states), LOGMEM(module->ctx); free(result), NULL);\n    }\n    count = 0;\n\n    /* module itself */\n    for (i = 0; i < module->features_size; i++) {\n        result[count] = module->features[i].name;\n        if (states) {\n            if (module->features[i].flags & LYS_FENABLED) {\n                (*states)[count] = 1;\n            } else {\n                (*states)[count] = 0;\n            }\n        }\n        count++;\n    }\n\n    /* submodules */\n    for (j = 0; j < module->inc_size; j++) {\n        for (i = 0; i < module->inc[j].submodule->features_size; i++) {\n            result[count] = module->inc[j].submodule->features[i].name;\n            if (states) {\n                if (module->inc[j].submodule->features[i].flags & LYS_FENABLED) {\n                    (*states)[count] = 1;\n                } else {\n                    (*states)[count] = 0;\n                }\n            }\n            count++;\n        }\n    }\n\n    /* terminating NULL byte */\n    result[count] = NULL;\n\n    return result;\n}\n\nAPI struct lys_module *\nlys_node_module(const struct lys_node *node)\n{\n    if (!node) {\n        return NULL;\n    }\n\n    return node->module->type ? ((struct lys_submodule *)node->module)->belongsto : node->module;\n}\n\nAPI struct lys_module *\nlys_main_module(const struct lys_module *module)\n{\n    if (!module) {\n        return NULL;\n    }\n\n    return (module->type ? ((struct lys_submodule *)module)->belongsto : (struct lys_module *)module);\n}\n\nAPI struct lys_node *\nlys_parent(const struct lys_node *node)\n{\n    struct lys_node *parent;\n\n    if (!node) {\n        return NULL;\n    }\n\n    if (node->nodetype == LYS_EXT) {\n        if (((struct lys_ext_instance_complex*)node)->parent_type != LYEXT_PAR_NODE) {\n            return NULL;\n        }\n        parent = (struct lys_node*)((struct lys_ext_instance_complex*)node)->parent;\n    } else if (!node->parent) {\n        return NULL;\n    } else {\n        parent = node->parent;\n    }\n\n    if (parent->nodetype == LYS_AUGMENT) {\n        return ((struct lys_node_augment *)parent)->target;\n    } else {\n        return parent;\n    }\n}\n\nstruct lys_node **\nlys_child(const struct lys_node *node, LYS_NODE nodetype)\n{\n    void *pp;\n    assert(node);\n\n    if (node->nodetype == LYS_EXT) {\n        pp = lys_ext_complex_get_substmt(lys_snode2stmt(nodetype), (struct lys_ext_instance_complex*)node, NULL);\n        if (!pp) {\n            return NULL;\n        }\n        return (struct lys_node **)pp;\n    } else if (node->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n        return NULL;\n    } else {\n        return (struct lys_node **)&node->child;\n    }\n}\n\nAPI void *\nlys_set_private(const struct lys_node *node, void *priv)\n{\n    void *prev;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    prev = node->priv;\n    ((struct lys_node *)node)->priv = priv;\n\n    return prev;\n}\n\nint\nlys_leaf_add_leafref_target(struct lys_node_leaf *leafref_target, struct lys_node *leafref)\n{\n    struct lys_node_leaf *iter;\n    struct ly_ctx *ctx = leafref_target->module->ctx;\n\n    if (!(leafref_target->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n        LOGINT(ctx);\n        return -1;\n    }\n\n    /* check for config flag */\n    if (((struct lys_node_leaf*)leafref)->type.info.lref.req != -1 &&\n            (leafref->flags & LYS_CONFIG_W) && (leafref_target->flags & LYS_CONFIG_R)) {\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, leafref,\n               \"The leafref %s is config but refers to a non-config %s.\",\n               strnodetype(leafref->nodetype), strnodetype(leafref_target->nodetype));\n        return -1;\n    }\n    /* check for cycles */\n    for (iter = leafref_target; iter && iter->type.base == LY_TYPE_LEAFREF; iter = iter->type.info.lref.target) {\n        if ((void *)iter == (void *)leafref) {\n            /* cycle detected */\n            LOGVAL(ctx, LYE_CIRC_LEAFREFS, LY_VLOG_LYS, leafref);\n            return -1;\n        }\n    }\n\n    /* create fake child - the ly_set structure to hold the list of\n     * leafrefs referencing the leaf(-list) */\n    if (!leafref_target->backlinks) {\n        leafref_target->backlinks = (void *)ly_set_new();\n        if (!leafref_target->backlinks) {\n            LOGMEM(ctx);\n            return -1;\n        }\n    }\n    ly_set_add(leafref_target->backlinks, leafref, 0);\n\n    return 0;\n}\n\n/* not needed currently */\n#if 0\n\nstatic const char *\nlys_data_path_reverse(const struct lys_node *node, char * const buf, uint32_t buf_len)\n{\n    struct lys_module *prev_mod;\n    uint32_t str_len, mod_len, buf_idx;\n\n    if (!(node->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA))) {\n        LOGINT;\n        return NULL;\n    }\n\n    buf_idx = buf_len - 1;\n    buf[buf_idx] = '\\0';\n\n    while (node) {\n        if (lys_parent(node)) {\n            prev_mod = lys_node_module(lys_parent(node));\n        } else {\n            prev_mod = NULL;\n        }\n\n        if (node->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n            str_len = strlen(node->name);\n\n            if (prev_mod != node->module) {\n                mod_len = strlen(node->module->name);\n            } else {\n                mod_len = 0;\n            }\n\n            if (buf_idx < 1 + (mod_len ? mod_len + 1 : 0) + str_len) {\n                LOGINT;\n                return NULL;\n            }\n\n            buf_idx -= 1 + (mod_len ? mod_len + 1 : 0) + str_len;\n\n            buf[buf_idx] = '/';\n            if (mod_len) {\n                memcpy(buf + buf_idx + 1, node->module->name, mod_len);\n                buf[buf_idx + 1 + mod_len] = ':';\n            }\n            memcpy(buf + buf_idx + 1 + (mod_len ? mod_len + 1 : 0), node->name, str_len);\n        }\n\n        node = lys_parent(node);\n    }\n\n    return buf + buf_idx;\n}\n\n#endif\n\nAPI struct ly_set *\nlys_xpath_atomize(const struct lys_node *ctx_node, enum lyxp_node_type ctx_node_type, const char *expr, int options)\n{\n    struct lyxp_set set;\n    struct ly_set *ret_set;\n    uint32_t i;\n\n    if (!ctx_node || !expr) {\n        LOGARG;\n        return NULL;\n    }\n\n    /* adjust the root */\n    if ((ctx_node_type == LYXP_NODE_ROOT) || (ctx_node_type == LYXP_NODE_ROOT_CONFIG)) {\n        do {\n            ctx_node = lys_getnext(NULL, NULL, lys_node_module(ctx_node), LYS_GETNEXT_NOSTATECHECK);\n        } while ((ctx_node_type == LYXP_NODE_ROOT_CONFIG) && (ctx_node->flags & LYS_CONFIG_R));\n    }\n\n    memset(&set, 0, sizeof set);\n\n    if (options & LYXP_MUST) {\n        options &= ~LYXP_MUST;\n        options |= LYXP_SNODE_MUST;\n    } else if (options & LYXP_WHEN) {\n        options &= ~LYXP_WHEN;\n        options |= LYXP_SNODE_WHEN;\n    } else {\n        options |= LYXP_SNODE;\n    }\n\n    if (lyxp_atomize(expr, ctx_node, ctx_node_type, &set, options, NULL)) {\n        free(set.val.snodes);\n        LOGVAL(ctx_node->module->ctx, LYE_SPEC, LY_VLOG_LYS, ctx_node, \"Resolving XPath expression \\\"%s\\\" failed.\", expr);\n        return NULL;\n    }\n\n    ret_set = ly_set_new();\n\n    for (i = 0; i < set.used; ++i) {\n        switch (set.val.snodes[i].type) {\n        case LYXP_NODE_ELEM:\n            if (ly_set_add(ret_set, set.val.snodes[i].snode, LY_SET_OPT_USEASLIST) == -1) {\n                ly_set_free(ret_set);\n                free(set.val.snodes);\n                return NULL;\n            }\n            break;\n        default:\n            /* ignore roots, text and attr should not ever appear */\n            break;\n        }\n    }\n\n    free(set.val.snodes);\n    return ret_set;\n}\n\nAPI struct ly_set *\nlys_node_xpath_atomize(const struct lys_node *node, int options)\n{\n    const struct lys_node *next, *elem, *parent, *tmp;\n    struct lyxp_set set;\n    struct ly_set *ret_set;\n    uint16_t i;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    for (parent = node; parent && !(parent->nodetype & (LYS_NOTIF | LYS_INPUT | LYS_OUTPUT)); parent = lys_parent(parent));\n    if (!parent) {\n        /* not in input, output, or notification */\n        return NULL;\n    }\n\n    ret_set = ly_set_new();\n    if (!ret_set) {\n        return NULL;\n    }\n\n    LY_TREE_DFS_BEGIN(node, next, elem) {\n        if ((options & LYXP_NO_LOCAL) && !(elem->flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP))) {\n            /* elem has no dependencies from other subtrees and local nodes get discarded */\n            goto next_iter;\n        }\n\n        if (lyxp_node_atomize(elem, &set, 0)) {\n            ly_set_free(ret_set);\n            free(set.val.snodes);\n            return NULL;\n        }\n\n        for (i = 0; i < set.used; ++i) {\n            switch (set.val.snodes[i].type) {\n            case LYXP_NODE_ELEM:\n                if (options & LYXP_NO_LOCAL) {\n                    for (tmp = set.val.snodes[i].snode; tmp && (tmp != parent); tmp = lys_parent(tmp));\n                    if (tmp) {\n                        /* in local subtree, discard */\n                        break;\n                    }\n                }\n                if (ly_set_add(ret_set, set.val.snodes[i].snode, 0) == -1) {\n                    ly_set_free(ret_set);\n                    free(set.val.snodes);\n                    return NULL;\n                }\n                break;\n            default:\n                /* ignore roots, text and attr should not ever appear */\n                break;\n            }\n        }\n\n        free(set.val.snodes);\n        if (!(options & LYXP_RECURSIVE)) {\n            break;\n        }\nnext_iter:\n        LY_TREE_DFS_END(node, next, elem);\n    }\n\n    return ret_set;\n}\n\n/* logs */\nint\napply_aug(struct lys_node_augment *augment, struct unres_schema *unres)\n{\n    struct lys_node *child, *parent;\n    int clear_config;\n    unsigned int u;\n    uint8_t *v;\n    struct lys_ext_instance *ext;\n\n    assert(augment->target && (augment->flags & LYS_NOTAPPLIED));\n\n    if (!augment->child) {\n        /* nothing to apply */\n        goto success;\n    }\n\n    /* inherit config information from actual parent */\n    for (parent = augment->target; parent && !(parent->nodetype & (LYS_NOTIF | LYS_INPUT | LYS_OUTPUT | LYS_RPC)); parent = lys_parent(parent));\n    clear_config = (parent) ? 1 : 0;\n    LY_TREE_FOR(augment->child, child) {\n        if (inherit_config_flag(child, augment->target->flags & LYS_CONFIG_MASK, clear_config)) {\n            return -1;\n        }\n    }\n\n    /* inherit extensions if any */\n    for (u = 0; u < augment->target->ext_size; u++) {\n        ext = augment->target->ext[u]; /* shortcut */\n        if (ext && ext->def->plugin && (ext->def->plugin->flags & LYEXT_OPT_INHERIT)) {\n            v = malloc(sizeof *v);\n            LY_CHECK_ERR_RETURN(!v, LOGMEM(augment->module->ctx), -1);\n            *v = u;\n            if (unres_schema_add_node(lys_main_module(augment->module), unres, &augment->target->ext,\n                    UNRES_EXT_FINALIZE, (struct lys_node *)v) == -1) {\n                /* something really bad happend since the extension finalization is not actually\n                 * being resolved while adding into unres, so something more serious with the unres\n                 * list itself must happened */\n                return -1;\n            }\n        }\n    }\n\n    /* reconnect augmenting data into the target - add them to the target child list */\n    if (augment->target->child) {\n        child = augment->target->child->prev;\n        child->next = augment->child;\n        augment->target->child->prev = augment->child->prev;\n        augment->child->prev = child;\n    } else {\n        augment->target->child = augment->child;\n    }\n\nsuccess:\n    /* remove the flag about not applicability */\n    augment->flags &= ~LYS_NOTAPPLIED;\n    return EXIT_SUCCESS;\n}\n\nstatic void\nremove_aug(struct lys_node_augment *augment)\n{\n    struct lys_node *last, *elem;\n\n    if ((augment->flags & LYS_NOTAPPLIED) || !augment->target) {\n        /* skip already not applied augment */\n        return;\n    }\n\n    elem = augment->child;\n    if (elem) {\n        LY_TREE_FOR(elem, last) {\n            if (!last->next || (last->next->parent != (struct lys_node *)augment)) {\n                break;\n            }\n        }\n        /* elem is first augment child, last is the last child */\n\n        /* parent child ptr */\n        if (augment->target->child == elem) {\n            augment->target->child = last->next;\n        }\n\n        /* parent child next ptr */\n        if (elem->prev->next) {\n            elem->prev->next = last->next;\n        }\n\n        /* parent child prev ptr */\n        if (last->next) {\n            last->next->prev = elem->prev;\n        } else if (augment->target->child) {\n            augment->target->child->prev = elem->prev;\n        }\n\n        /* update augment children themselves */\n        elem->prev = last;\n        last->next = NULL;\n    }\n\n    /* augment->target still keeps the resolved target, but for lys_augment_free()\n     * we have to keep information that this augment is not applied to free its data */\n    augment->flags |= LYS_NOTAPPLIED;\n}\n\n/*\n * @param[in] module - the module where the deviation is defined\n */\nstatic void\nlys_switch_deviation(struct lys_deviation *dev, const struct lys_module *module, struct unres_schema *unres)\n{\n    int ret, reapply = 0;\n    char *parent_path;\n    struct lys_node *target = NULL, *parent;\n    struct lys_node_inout *inout;\n    struct ly_set *set;\n\n    if (!dev->deviate) {\n        return;\n    }\n\n    if (dev->deviate[0].mod == LY_DEVIATE_NO) {\n        if (dev->orig_node) {\n            /* removing not-supported deviation ... */\n            if (strrchr(dev->target_name, '/') != dev->target_name) {\n                /* ... from a parent */\n\n                /* reconnect to its previous position */\n                parent = dev->orig_node->parent;\n                if (parent && (parent->nodetype == LYS_AUGMENT)) {\n                    dev->orig_node->parent = NULL;\n                    /* the original node was actually from augment, we have to get know if the augment is\n                     * applied (its module is enabled and implemented). If yes, the node will be connected\n                     * to the augment and the linkage with the target will be fixed if needed, otherwise\n                     * it will be connected only to the augment */\n                    if (!(parent->flags & LYS_NOTAPPLIED)) {\n                        /* start with removing augment if applied before adding nodes, we have to make sure\n                         * that everything will be connect correctly */\n                        remove_aug((struct lys_node_augment *)parent);\n                        reapply = 1;\n                    }\n                    /* connect the deviated node back into the augment */\n                    lys_node_addchild(parent, NULL, dev->orig_node, 0);\n                    if (reapply) {\n                        /* augment is supposed to be applied, so fix pointers in target and the status of the original node */\n                        assert(lys_node_module(parent)->implemented);\n                        parent->flags |= LYS_NOTAPPLIED; /* allow apply_aug() */\n                        apply_aug((struct lys_node_augment *)parent, unres);\n                    }\n                } else if (parent && (parent->nodetype == LYS_USES)) {\n                    /* uses child */\n                    lys_node_addchild(parent, NULL, dev->orig_node, 0);\n                } else {\n                    /* non-augment, non-toplevel */\n                    parent_path = strndup(dev->target_name, strrchr(dev->target_name, '/') - dev->target_name);\n                    ret = resolve_schema_nodeid(parent_path, NULL, module, &set, 0, 1);\n                    free(parent_path);\n                    if (ret == -1) {\n                        LOGINT(module->ctx);\n                        ly_set_free(set);\n                        return;\n                    }\n                    target = set->set.s[0];\n                    ly_set_free(set);\n\n                    lys_node_addchild(target, NULL, dev->orig_node, 0);\n                }\n            } else {\n                /* ... from top-level data */\n                lys_node_addchild(NULL, (struct lys_module *)dev->orig_node->module, dev->orig_node, 0);\n            }\n\n            dev->orig_node = NULL;\n        } else {\n            /* adding not-supported deviation */\n            ret = resolve_schema_nodeid(dev->target_name, NULL, module, &set, 0, 1);\n            if (ret == -1) {\n                LOGINT(module->ctx);\n                ly_set_free(set);\n                return;\n            }\n            target = set->set.s[0];\n            ly_set_free(set);\n\n            /* unlink and store the original node */\n            parent = target->parent;\n            lys_node_unlink(target);\n            if (parent) {\n                if (parent->nodetype & (LYS_AUGMENT | LYS_USES)) {\n                    /* hack for augment, because when the original will be sometime reconnected back, we actually need\n                     * to reconnect it to both - the augment and its target (which is deduced from the deviations target\n                     * path), so we need to remember the augment as an addition */\n                    /* we also need to remember the parent uses so that we connect it back to it when switching deviation state */\n                    target->parent = parent;\n                } else if (parent->nodetype & (LYS_RPC | LYS_ACTION)) {\n                    /* re-create implicit node */\n                    inout = calloc(1, sizeof *inout);\n                    LY_CHECK_ERR_RETURN(!inout, LOGMEM(module->ctx), );\n\n                    inout->nodetype = target->nodetype;\n                    inout->name = lydict_insert(module->ctx, (inout->nodetype == LYS_INPUT) ? \"input\" : \"output\", 0);\n                    inout->module = target->module;\n                    inout->flags = LYS_IMPLICIT;\n\n                    /* insert it manually */\n                    assert(parent->child && !parent->child->next\n                    && (parent->child->nodetype == (inout->nodetype == LYS_INPUT ? LYS_OUTPUT : LYS_INPUT)));\n                    parent->child->next = (struct lys_node *)inout;\n                    inout->prev = parent->child;\n                    parent->child->prev = (struct lys_node *)inout;\n                    inout->parent = parent;\n                }\n            }\n            dev->orig_node = target;\n        }\n    } else {\n        ret = resolve_schema_nodeid(dev->target_name, NULL, module, &set, 0, 1);\n        if (ret == -1) {\n            LOGINT(module->ctx);\n            ly_set_free(set);\n            return;\n        }\n        target = set->set.s[0];\n        ly_set_free(set);\n\n        /* contents are switched */\n        lys_node_switch(target, dev->orig_node);\n    }\n}\n\n/* temporarily removes or applies deviations, updates module deviation flag accordingly */\nvoid\nlys_enable_deviations(struct lys_module *module)\n{\n    uint32_t i = 0, j;\n    const struct lys_module *mod;\n    const char *ptr;\n    struct unres_schema *unres;\n\n    if (module->deviated) {\n        unres = calloc(1, sizeof *unres);\n        LY_CHECK_ERR_RETURN(!unres, LOGMEM(module->ctx), );\n\n        while ((mod = ly_ctx_get_module_iter(module->ctx, &i))) {\n            if (mod == module) {\n                continue;\n            }\n\n            for (j = 0; j < mod->deviation_size; ++j) {\n                ptr = strstr(mod->deviation[j].target_name, module->name);\n                if (ptr && ptr[strlen(module->name)] == ':') {\n                    lys_switch_deviation(&mod->deviation[j], mod, unres);\n                }\n            }\n        }\n\n        assert(module->deviated == 2);\n        module->deviated = 1;\n\n        for (j = 0; j < module->inc_size; j++) {\n            if (module->inc[j].submodule->deviated) {\n                module->inc[j].submodule->deviated = module->deviated;\n            }\n        }\n\n        if (unres->count) {\n            resolve_unres_schema(module, unres);\n        }\n        unres_schema_free(module, &unres, 1);\n    }\n}\n\nvoid\nlys_disable_deviations(struct lys_module *module)\n{\n    uint32_t i, j;\n    const struct lys_module *mod;\n    const char *ptr;\n    struct unres_schema *unres;\n\n    if (module->deviated) {\n        unres = calloc(1, sizeof *unres);\n        LY_CHECK_ERR_RETURN(!unres, LOGMEM(module->ctx), );\n\n        i = module->ctx->models.used;\n        while (i--) {\n            mod = module->ctx->models.list[i];\n\n            if (mod == module) {\n                continue;\n            }\n\n            j = mod->deviation_size;\n            while (j--) {\n                ptr = strstr(mod->deviation[j].target_name, module->name);\n                if (ptr && ptr[strlen(module->name)] == ':') {\n                    lys_switch_deviation(&mod->deviation[j], mod, unres);\n                }\n            }\n        }\n\n        assert(module->deviated == 1);\n        module->deviated = 2;\n\n        for (j = 0; j < module->inc_size; j++) {\n            if (module->inc[j].submodule->deviated) {\n                module->inc[j].submodule->deviated = module->deviated;\n            }\n        }\n\n        if (unres->count) {\n            resolve_unres_schema(module, unres);\n        }\n        unres_schema_free(module, &unres, 1);\n    }\n}\n\nstatic void\napply_dev(struct lys_deviation *dev, const struct lys_module *module, struct unres_schema *unres)\n{\n    lys_switch_deviation(dev, module, unres);\n\n    assert(dev->orig_node);\n    lys_node_module(dev->orig_node)->deviated = 1; /* main module */\n    dev->orig_node->module->deviated = 1;          /* possible submodule */\n}\n\nstatic void\nremove_dev(struct lys_deviation *dev, const struct lys_module *module, struct unres_schema *unres)\n{\n    uint32_t idx = 0, j;\n    const struct lys_module *mod;\n    struct lys_module *target_mod, *target_submod;\n    const char *ptr;\n\n    if (dev->orig_node) {\n        target_mod = lys_node_module(dev->orig_node);\n        target_submod = dev->orig_node->module;\n    } else {\n        LOGINT(module->ctx);\n        return;\n    }\n    lys_switch_deviation(dev, module, unres);\n\n    /* clear the deviation flag if possible */\n    while ((mod = ly_ctx_get_module_iter(module->ctx, &idx))) {\n        if ((mod == module) || (mod == target_mod)) {\n            continue;\n        }\n\n        for (j = 0; j < mod->deviation_size; ++j) {\n            ptr = strstr(mod->deviation[j].target_name, target_mod->name);\n            if (ptr && (ptr[strlen(target_mod->name)] == ':')) {\n                /* some other module deviation targets the inspected module, flag remains */\n                break;\n            }\n        }\n\n        if (j < mod->deviation_size) {\n            break;\n        }\n    }\n\n    if (!mod) {\n        target_mod->deviated = 0;    /* main module */\n        target_submod->deviated = 0; /* possible submodule */\n    }\n}\n\nvoid\nlys_sub_module_apply_devs_augs(struct lys_module *module)\n{\n    uint8_t u, v;\n    struct unres_schema *unres;\n\n    assert(module->implemented);\n\n    unres = calloc(1, sizeof *unres);\n    LY_CHECK_ERR_RETURN(!unres, LOGMEM(module->ctx), );\n\n    /* apply deviations */\n    for (u = 0; u < module->deviation_size; ++u) {\n        apply_dev(&module->deviation[u], module, unres);\n    }\n    /* apply augments */\n    for (u = 0; u < module->augment_size; ++u) {\n        apply_aug(&module->augment[u], unres);\n    }\n\n    /* apply deviations and augments defined in submodules */\n    for (v = 0; v < module->inc_size; ++v) {\n        for (u = 0; u < module->inc[v].submodule->deviation_size; ++u) {\n            apply_dev(&module->inc[v].submodule->deviation[u], module, unres);\n        }\n\n        for (u = 0; u < module->inc[v].submodule->augment_size; ++u) {\n            apply_aug(&module->inc[v].submodule->augment[u], unres);\n        }\n    }\n\n    if (unres->count) {\n        resolve_unres_schema(module, unres);\n    }\n    /* nothing else left to do even if something is not resolved */\n    unres_schema_free(module, &unres, 1);\n}\n\nvoid\nlys_sub_module_remove_devs_augs(struct lys_module *module)\n{\n    uint8_t u, v, w;\n    struct unres_schema *unres;\n\n    unres = calloc(1, sizeof *unres);\n    LY_CHECK_ERR_RETURN(!unres, LOGMEM(module->ctx), );\n\n    /* remove applied deviations */\n    for (u = 0; u < module->deviation_size; ++u) {\n        /* the deviation could not be applied because it failed to be applied in the first place*/\n        if (module->deviation[u].orig_node) {\n            remove_dev(&module->deviation[u], module, unres);\n        }\n\n        /* Free the deviation's must array(s). These are shallow copies of the arrays\n           on the target node(s), so a deep free is not needed. */\n        for (v = 0; v < module->deviation[u].deviate_size; ++v) {\n            if (module->deviation[u].deviate[v].mod == LY_DEVIATE_ADD) {\n                free(module->deviation[u].deviate[v].must);\n            }\n        }\n    }\n    /* remove applied augments */\n    for (u = 0; u < module->augment_size; ++u) {\n        remove_aug(&module->augment[u]);\n    }\n\n    /* remove deviation and augments defined in submodules */\n    for (v = 0; v < module->inc_size && module->inc[v].submodule; ++v) {\n        for (u = 0; u < module->inc[v].submodule->deviation_size; ++u) {\n            if (module->inc[v].submodule->deviation[u].orig_node) {\n                remove_dev(&module->inc[v].submodule->deviation[u], module, unres);\n            }\n\n            /* Free the deviation's must array(s). These are shallow copies of the arrays\n               on the target node(s), so a deep free is not needed. */\n            for (w = 0; w < module->inc[v].submodule->deviation[u].deviate_size; ++w) {\n                if (module->inc[v].submodule->deviation[u].deviate[w].mod == LY_DEVIATE_ADD) {\n                    free(module->inc[v].submodule->deviation[u].deviate[w].must);\n                }\n            }\n        }\n\n        for (u = 0; u < module->inc[v].submodule->augment_size; ++u) {\n            remove_aug(&module->inc[v].submodule->augment[u]);\n        }\n    }\n\n    if (unres->count) {\n        resolve_unres_schema(module, unres);\n    }\n    /* nothing else left to do even if something is not resolved */\n    unres_schema_free(module, &unres, 1);\n}\n\nint\nlys_make_implemented_r(struct lys_module *module, struct unres_schema *unres)\n{\n    struct ly_ctx *ctx;\n    struct lys_node *root, *next, *node;\n    struct lys_module *target_module;\n    uint16_t i, j, k;\n\n    assert(module->implemented);\n    ctx = module->ctx;\n\n    for (i = 0; i < ctx->models.used; ++i) {\n        if (module == ctx->models.list[i]) {\n            continue;\n        }\n\n        if (!strcmp(module->name, ctx->models.list[i]->name) && ctx->models.list[i]->implemented) {\n            LOGERR(ctx, LY_EINVAL, \"Module \\\"%s\\\" in another revision already implemented.\", module->name);\n            return EXIT_FAILURE;\n        }\n    }\n\n    for (i = 0; i < module->augment_size; i++) {\n\n        /* make target module implemented if was not */\n        assert(module->augment[i].target);\n        target_module = lys_node_module(module->augment[i].target);\n        if (!target_module->implemented) {\n            target_module->implemented = 1;\n            if (unres_schema_add_node(target_module, unres, NULL, UNRES_MOD_IMPLEMENT, NULL) == -1) {\n                return -1;\n            }\n        }\n\n        /* apply augment */\n        if ((module->augment[i].flags & LYS_NOTAPPLIED) && apply_aug(&module->augment[i], unres)) {\n            return -1;\n        }\n    }\n\n    /* identities */\n    for (i = 0; i < module->ident_size; i++) {\n        for (j = 0; j < module->ident[i].base_size; j++) {\n            resolve_identity_backlink_update(&module->ident[i], module->ident[i].base[j]);\n        }\n    }\n\n    /* process augments in submodules */\n    for (i = 0; i < module->inc_size && module->inc[i].submodule; ++i) {\n        module->inc[i].submodule->implemented = 1;\n\n        for (j = 0; j < module->inc[i].submodule->augment_size; j++) {\n\n            /* make target module implemented if it was not */\n            assert(module->inc[i].submodule->augment[j].target);\n            target_module = lys_node_module(module->inc[i].submodule->augment[j].target);\n            if (!target_module->implemented) {\n                target_module->implemented = 1;\n                if (unres_schema_add_node(target_module, unres, NULL, UNRES_MOD_IMPLEMENT, NULL) == -1) {\n                    return -1;\n                }\n            }\n\n            /* apply augment */\n            if ((module->inc[i].submodule->augment[j].flags & LYS_NOTAPPLIED) && apply_aug(&module->inc[i].submodule->augment[j], unres)) {\n                return -1;\n            }\n        }\n\n        /* identities */\n        for (j = 0; j < module->inc[i].submodule->ident_size; j++) {\n            for (k = 0; k < module->inc[i].submodule->ident[j].base_size; k++) {\n                resolve_identity_backlink_update(&module->inc[i].submodule->ident[j],\n                                                 module->inc[i].submodule->ident[j].base[k]);\n            }\n        }\n    }\n\n    LY_TREE_FOR(module->data, root) {\n        /* handle leafrefs and recursively change the implemented flags in the leafref targets */\n        LY_TREE_DFS_BEGIN(root, next, node) {\n            if (node->nodetype == LYS_GROUPING) {\n                goto nextsibling;\n            }\n            if (node->nodetype & (LYS_LEAF | LYS_LEAFLIST)) {\n                if (((struct lys_node_leaf *)node)->type.base == LY_TYPE_LEAFREF) {\n                    if (unres_schema_add_node(module, unres, &((struct lys_node_leaf *)node)->type,\n                                              UNRES_TYPE_LEAFREF, node) == -1) {\n                        return -1;\n                    }\n                }\n            }\n\n            /* modified LY_TREE_DFS_END */\n            next = node->child;\n            /* child exception for leafs, leaflists and anyxml without children */\n            if (node->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                next = NULL;\n            }\n            if (!next) {\nnextsibling:\n                /* no children */\n                if (node == root) {\n                    /* we are done, root has no children */\n                    break;\n                }\n                /* try siblings */\n                next = node->next;\n            }\n            while (!next) {\n                /* parent is already processed, go to its sibling */\n                node = lys_parent(node);\n                /* no siblings, go back through parents */\n                if (lys_parent(node) == lys_parent(root)) {\n                    /* we are done, no next element to process */\n                    break;\n                }\n                next = node->next;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nAPI int\nlys_set_implemented(const struct lys_module *module)\n{\n    struct unres_schema *unres;\n    int disabled = 0;\n\n    if (!module) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    module = lys_main_module(module);\n\n    if (module->disabled) {\n        disabled = 1;\n        lys_set_enabled(module);\n    }\n\n    if (module->implemented) {\n        return EXIT_SUCCESS;\n    }\n\n    unres = calloc(1, sizeof *unres);\n    if (!unres) {\n        LOGMEM(module->ctx);\n        if (disabled) {\n            /* set it back disabled */\n            lys_set_disabled(module);\n        }\n        return EXIT_FAILURE;\n    }\n    /* recursively make the module implemented */\n    ((struct lys_module *)module)->implemented = 1;\n    if (lys_make_implemented_r((struct lys_module *)module, unres)) {\n        goto error;\n    }\n\n    /* try again resolve augments in other modules possibly augmenting this one,\n     * since we have just enabled it\n     */\n    /* resolve rest of unres items */\n    if (unres->count && resolve_unres_schema((struct lys_module *)module, unres)) {\n        goto error;\n    }\n    unres_schema_free(NULL, &unres, 0);\n\n    LOGVRB(\"Module \\\"%s%s%s\\\" now implemented.\", module->name, (module->rev_size ? \"@\" : \"\"),\n           (module->rev_size ? module->rev[0].date : \"\"));\n    return EXIT_SUCCESS;\n\nerror:\n    if (disabled) {\n        /* set it back disabled */\n        lys_set_disabled(module);\n    }\n\n    ((struct lys_module *)module)->implemented = 0;\n    unres_schema_free((struct lys_module *)module, &unres, 1);\n    return EXIT_FAILURE;\n}\n\nvoid\nlys_submodule_module_data_free(struct lys_submodule *submodule)\n{\n    struct lys_node *next, *elem;\n\n    /* remove parsed data */\n    LY_TREE_FOR_SAFE(submodule->belongsto->data, next, elem) {\n        if (elem->module == (struct lys_module *)submodule) {\n            lys_node_free(elem, NULL, 0);\n        }\n    }\n}\n\nAPI char *\nlys_path(const struct lys_node *node, int options)\n{\n    char *buf = NULL;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    if (ly_vlog_build_path(LY_VLOG_LYS, node, &buf, (options & LYS_PATH_FIRST_PREFIX) ? 0 : 1, 0)) {\n        return NULL;\n    }\n\n    return buf;\n}\n\nAPI char *\nlys_data_path(const struct lys_node *node)\n{\n    char *result = NULL, buf[1024];\n    const char *separator, *name;\n    int i, used;\n    struct ly_set *set;\n    const struct lys_module *prev_mod;\n\n    if (!node) {\n        LOGARG;\n        return NULL;\n    }\n\n    buf[0] = '\\0';\n    set = ly_set_new();\n    LY_CHECK_ERR_GOTO(!set, LOGMEM(node->module->ctx), cleanup);\n\n    while (node) {\n        ly_set_add(set, (void *)node, 0);\n        do {\n            node = lys_parent(node);\n        } while (node && (node->nodetype & (LYS_USES | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));\n    }\n\n    prev_mod = NULL;\n    used = 0;\n    for (i = set->number - 1; i > -1; --i) {\n        node = set->set.s[i];\n        if (node->nodetype == LYS_EXT) {\n            if (strcmp(((struct lys_ext_instance *)node)->def->name, \"yang-data\")) {\n                continue;\n            }\n            name = ((struct lys_ext_instance *)node)->arg_value;\n            separator = \":#\";\n        } else {\n            name = node->name;\n            separator = \":\";\n        }\n        used += sprintf(buf + used, \"/%s%s%s\", (lys_node_module(node) == prev_mod ? \"\" : lys_node_module(node)->name),\n                        (lys_node_module(node) == prev_mod ? \"\" : separator), name);\n        prev_mod = lys_node_module(node);\n    }\n\n    result = strdup(buf);\n    LY_CHECK_ERR_GOTO(!result, LOGMEM(node->module->ctx), cleanup);\n\ncleanup:\n    ly_set_free(set);\n    return result;\n}\n\nstruct lys_node_augment *\nlys_getnext_target_aug(struct lys_node_augment *last, const struct lys_module *mod, const struct lys_node *aug_target)\n{\n    struct lys_node *child;\n    struct lys_node_augment *aug;\n    int i, j, last_found;\n\n    assert(mod && aug_target);\n\n    if (!last) {\n        last_found = 1;\n    } else {\n        last_found = 0;\n    }\n\n    /* search module augments */\n    for (i = 0; i < mod->augment_size; ++i) {\n        if (!mod->augment[i].target) {\n            /* still unresolved, skip */\n            continue;\n        }\n\n        if (mod->augment[i].target == aug_target) {\n            if (last_found) {\n                /* next match after last */\n                return &mod->augment[i];\n            }\n\n            if (&mod->augment[i] == last) {\n                last_found = 1;\n            }\n        }\n    }\n\n    /* search submodule augments */\n    for (i = 0; i < mod->inc_size; ++i) {\n        for (j = 0; j < mod->inc[i].submodule->augment_size; ++j) {\n            if (!mod->inc[i].submodule->augment[j].target) {\n                continue;\n            }\n\n            if (mod->inc[i].submodule->augment[j].target == aug_target) {\n                if (last_found) {\n                    /* next match after last */\n                    return &mod->inc[i].submodule->augment[j];\n                }\n\n                if (&mod->inc[i].submodule->augment[j] == last) {\n                    last_found = 1;\n                }\n            }\n        }\n    }\n\n    /* we also need to check possible augments to choices */\n    LY_TREE_FOR(aug_target->child, child) {\n        if (child->nodetype == LYS_CHOICE) {\n            aug = lys_getnext_target_aug(last, mod, child);\n            if (aug) {\n                return aug;\n            }\n        }\n    }\n\n    return NULL;\n}\n\nAPI struct ly_set *\nlys_find_path(const struct lys_module *cur_module, const struct lys_node *cur_node, const char *path)\n{\n    struct ly_set *ret;\n    int rc;\n\n    if ((!cur_module && !cur_node) || !path) {\n        return NULL;\n    }\n\n    rc = resolve_schema_nodeid(path, cur_node, cur_module, &ret, 1, 1);\n    if (rc == -1) {\n        return NULL;\n    }\n\n    return ret;\n}\n\nstatic void\nlys_extcomplex_free_str(struct ly_ctx *ctx, struct lys_ext_instance_complex *ext, LY_STMT stmt)\n{\n    struct lyext_substmt *info;\n    const char **str, ***a;\n    int c;\n\n    str = lys_ext_complex_get_substmt(stmt, ext, &info);\n    if (!str || !(*str)) {\n        return;\n    }\n    if (info->cardinality >= LY_STMT_CARD_SOME) {\n        /* we have array */\n        a = (const char ***)str;\n        for (str = (*(const char ***)str), c = 0; str[c]; c++) {\n            lydict_remove(ctx, str[c]);\n        }\n        free(a[0]);\n        if (stmt == LY_STMT_BELONGSTO) {\n            for (str = a[1], c = 0; str[c]; c++) {\n                lydict_remove(ctx, str[c]);\n            }\n            free(a[1]);\n        } else if (stmt == LY_STMT_ARGUMENT) {\n            free(a[1]);\n        }\n    } else {\n        lydict_remove(ctx, str[0]);\n        if (stmt == LY_STMT_BELONGSTO) {\n            lydict_remove(ctx, str[1]);\n        }\n    }\n}\n\nvoid\nlys_extension_instances_free(struct ly_ctx *ctx, struct lys_ext_instance **e, unsigned int size,\n                             void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    unsigned int i, j, k;\n    struct lyext_substmt *substmt;\n    void **pp, **start;\n    struct lys_node *siter, *snext;\n\n#define EXTCOMPLEX_FREE_STRUCT(STMT, TYPE, FUNC, FREE, ARGS...)                               \\\n    pp = lys_ext_complex_get_substmt(STMT, (struct lys_ext_instance_complex *)e[i], NULL);    \\\n    if (!pp || !(*pp)) { break; }                                                             \\\n    if (substmt[j].cardinality >= LY_STMT_CARD_SOME) { /* process array */                    \\\n        for (start = pp = *pp; *pp; pp++) {                                                   \\\n            FUNC(ctx, (TYPE *)(*pp), ##ARGS, private_destructor);                             \\\n            if (FREE) { free(*pp); }                                                          \\\n        }                                                                                     \\\n        free(start);                                                                          \\\n    } else { /* single item */                                                                \\\n        FUNC(ctx, (TYPE *)(*pp), ##ARGS, private_destructor);                                 \\\n        if (FREE) { free(*pp); }                                                              \\\n    }\n\n    if (!size || !e) {\n        return;\n    }\n\n    for (i = 0; i < size; i++) {\n        if (!e[i]) {\n            continue;\n        }\n\n        if (e[i]->flags & (LYEXT_OPT_INHERIT)) {\n            /* no free, this is just a shadow copy of the original extension instance */\n        } else {\n            if (e[i]->flags & (LYEXT_OPT_YANG)) {\n                free(e[i]->def);     /* remove name of instance extension */\n                e[i]->def = NULL;\n                yang_free_ext_data((struct yang_ext_substmt *)e[i]->parent); /* remove backup part of yang file */\n            }\n            /* remove private object */\n            if (e[i]->priv && private_destructor) {\n                private_destructor((struct lys_node*)e[i], e[i]->priv);\n            }\n            lys_extension_instances_free(ctx, e[i]->ext, e[i]->ext_size, private_destructor);\n            lydict_remove(ctx, e[i]->arg_value);\n        }\n\n        if (e[i]->def && e[i]->def->plugin && e[i]->def->plugin->type == LYEXT_COMPLEX\n                && ((e[i]->flags & LYEXT_OPT_CONTENT) == 0)) {\n            substmt = ((struct lys_ext_instance_complex *)e[i])->substmt;\n            for (j = 0; substmt[j].stmt; j++) {\n                switch(substmt[j].stmt) {\n                case LY_STMT_DESCRIPTION:\n                case LY_STMT_REFERENCE:\n                case LY_STMT_UNITS:\n                case LY_STMT_ARGUMENT:\n                case LY_STMT_DEFAULT:\n                case LY_STMT_ERRTAG:\n                case LY_STMT_ERRMSG:\n                case LY_STMT_PREFIX:\n                case LY_STMT_NAMESPACE:\n                case LY_STMT_PRESENCE:\n                case LY_STMT_REVISIONDATE:\n                case LY_STMT_KEY:\n                case LY_STMT_BASE:\n                case LY_STMT_BELONGSTO:\n                case LY_STMT_CONTACT:\n                case LY_STMT_ORGANIZATION:\n                case LY_STMT_PATH:\n                    lys_extcomplex_free_str(ctx, (struct lys_ext_instance_complex *)e[i], substmt[j].stmt);\n                    break;\n                case LY_STMT_TYPE:\n                    EXTCOMPLEX_FREE_STRUCT(LY_STMT_TYPE, struct lys_type, lys_type_free, 1);\n                    break;\n                case LY_STMT_TYPEDEF:\n                    EXTCOMPLEX_FREE_STRUCT(LY_STMT_TYPEDEF, struct lys_tpdf, lys_tpdf_free, 1);\n                    break;\n                case LY_STMT_IFFEATURE:\n                    EXTCOMPLEX_FREE_STRUCT(LY_STMT_IFFEATURE, struct lys_iffeature, lys_iffeature_free, 0, 1, 0);\n                    break;\n                case LY_STMT_MAX:\n                case LY_STMT_MIN:\n                case LY_STMT_POSITION:\n                case LY_STMT_VALUE:\n                    pp = (void**)&((struct lys_ext_instance_complex *)e[i])->content[substmt[j].offset];\n                    if (substmt[j].cardinality >= LY_STMT_CARD_SOME && *pp) {\n                        for(k = 0; ((uint32_t**)(*pp))[k]; k++) {\n                            free(((uint32_t**)(*pp))[k]);\n                        }\n                    }\n                    free(*pp);\n                    break;\n                case LY_STMT_DIGITS:\n                    if (substmt[j].cardinality >= LY_STMT_CARD_SOME) {\n                        /* free the array */\n                        pp = (void**)&((struct lys_ext_instance_complex *)e[i])->content[substmt[j].offset];\n                        free(*pp);\n                    }\n                    break;\n                case LY_STMT_MODULE:\n                    /* modules are part of the context, so they will be freed there */\n                    if (substmt[j].cardinality >= LY_STMT_CARD_SOME) {\n                        /* free the array */\n                        pp = (void**)&((struct lys_ext_instance_complex *)e[i])->content[substmt[j].offset];\n                        free(*pp);\n                    }\n                    break;\n                case LY_STMT_ACTION:\n                case LY_STMT_ANYDATA:\n                case LY_STMT_ANYXML:\n                case LY_STMT_CASE:\n                case LY_STMT_CHOICE:\n                case LY_STMT_CONTAINER:\n                case LY_STMT_GROUPING:\n                case LY_STMT_INPUT:\n                case LY_STMT_LEAF:\n                case LY_STMT_LEAFLIST:\n                case LY_STMT_LIST:\n                case LY_STMT_NOTIFICATION:\n                case LY_STMT_OUTPUT:\n                case LY_STMT_RPC:\n                case LY_STMT_USES:\n                    pp = (void**)&((struct lys_ext_instance_complex *)e[i])->content[substmt[j].offset];\n                    LY_TREE_FOR_SAFE((struct lys_node *)(*pp), snext, siter) {\n                        lys_node_free(siter, NULL, 0);\n                    }\n                    *pp = NULL;\n                    break;\n                case LY_STMT_UNIQUE:\n                    pp = lys_ext_complex_get_substmt(LY_STMT_UNIQUE, (struct lys_ext_instance_complex *)e[i], NULL);\n                    if (!pp || !(*pp)) {\n                        break;\n                    }\n                    if (substmt[j].cardinality >= LY_STMT_CARD_SOME) { /* process array */\n                        for (start = pp = *pp; *pp; pp++) {\n                            for (k = 0; k < (*(struct lys_unique**)pp)->expr_size; k++) {\n                                lydict_remove(ctx, (*(struct lys_unique**)pp)->expr[k]);\n                            }\n                            free((*(struct lys_unique**)pp)->expr);\n                            free(*pp);\n                        }\n                        free(start);\n                    } else { /* single item */\n                        for (k = 0; k < (*(struct lys_unique**)pp)->expr_size; k++) {\n                            lydict_remove(ctx, (*(struct lys_unique**)pp)->expr[k]);\n                        }\n                        free((*(struct lys_unique**)pp)->expr);\n                        free(*pp);\n                    }\n                    break;\n                case LY_STMT_LENGTH:\n                case LY_STMT_MUST:\n                case LY_STMT_PATTERN:\n                case LY_STMT_RANGE:\n                    EXTCOMPLEX_FREE_STRUCT(substmt[j].stmt, struct lys_restr, lys_restr_free, 1);\n                    break;\n                case LY_STMT_WHEN:\n                    EXTCOMPLEX_FREE_STRUCT(LY_STMT_WHEN, struct lys_when, lys_when_free, 0);\n                    break;\n                case LY_STMT_REVISION:\n                    pp = lys_ext_complex_get_substmt(LY_STMT_REVISION, (struct lys_ext_instance_complex *)e[i], NULL);\n                    if (!pp || !(*pp)) {\n                        break;\n                    }\n                    if (substmt[j].cardinality >= LY_STMT_CARD_SOME) { /* process array */\n                        for (start = pp = *pp; *pp; pp++) {\n                            lydict_remove(ctx, (*(struct lys_revision**)pp)->dsc);\n                            lydict_remove(ctx, (*(struct lys_revision**)pp)->ref);\n                            lys_extension_instances_free(ctx, (*(struct lys_revision**)pp)->ext,\n                                                         (*(struct lys_revision**)pp)->ext_size, private_destructor);\n                            free(*pp);\n                        }\n                        free(start);\n                    } else { /* single item */\n                        lydict_remove(ctx, (*(struct lys_revision**)pp)->dsc);\n                        lydict_remove(ctx, (*(struct lys_revision**)pp)->ref);\n                        lys_extension_instances_free(ctx, (*(struct lys_revision**)pp)->ext,\n                                                     (*(struct lys_revision**)pp)->ext_size, private_destructor);\n                        free(*pp);\n                    }\n                    break;\n                default:\n                    /* nothing to free */\n                    break;\n                }\n            }\n        }\n\n        free(e[i]);\n    }\n    free(e);\n\n#undef EXTCOMPLEX_FREE_STRUCT\n}\n"], "filenames": ["src/resolve.c", "src/tree_data.c", "src/tree_internal.h", "src/tree_schema.c"], "buggy_code_start_loc": [3944, 1175, 487, 216], "buggy_code_end_loc": [6069, 5613, 494, 230], "fixing_code_start_loc": [3944, 1175, 488, 216], "fixing_code_end_loc": [6071, 5613, 495, 230], "type": "CWE-119", "message": "An invalid memory access flaw is present in libyang before v1.0-r1 in the function resolve_feature_value() when an if-feature statement is used inside a list key node, and the feature used is not defined. Applications that use libyang to parse untrusted input yang files may crash.", "other": {"cve": {"id": "CVE-2019-20392", "sourceIdentifier": "cve@mitre.org", "published": "2020-01-22T22:15:10.143", "lastModified": "2020-01-23T21:18:43.547", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An invalid memory access flaw is present in libyang before v1.0-r1 in the function resolve_feature_value() when an if-feature statement is used inside a list key node, and the feature used is not defined. Applications that use libyang to parse untrusted input yang files may crash."}, {"lang": "es", "value": "Un fallo de acceso a memoria no v\u00e1lida est\u00e1 presente en libyang versiones anteriores a v1.0-r1, en la funci\u00f3n resolve_feature_value() cuando es usada una sentencia if-feature dentro de un nodo de clave de lista, y la caracter\u00edstica usada no est\u00e1 definida. Las aplicaciones que utilizan libyang para analizar archivos de entrada yang no confiables pueden bloquearse."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.11:r1:*:*:*:*:*:*", "matchCriteriaId": "65E91322-5F67-43C2-8112-5ECAEC2A3C12"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.11:r2:*:*:*:*:*:*", "matchCriteriaId": "80A88DE4-93F8-40C3-AA52-A5F353F028AA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.12:r1:*:*:*:*:*:*", "matchCriteriaId": "05C120CA-50EF-4B6D-92C9-ED736219DB07"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.12:r2:*:*:*:*:*:*", "matchCriteriaId": "99D1FA55-3F56-4E09-B41E-B05C199B96B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.13:r1:*:*:*:*:*:*", "matchCriteriaId": "35D48EC4-58D2-49C6-8049-920787733587"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.13:r2:*:*:*:*:*:*", "matchCriteriaId": "B57F3953-49D6-413C-A4AE-03125935FC77"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.14:r1:*:*:*:*:*:*", "matchCriteriaId": "DD62411F-A524-4E80-B540-780EA39CB6A4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.15:r1:*:*:*:*:*:*", "matchCriteriaId": "FEF091B1-978A-4881-B1FC-6848CD1A7BBF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.16:r1:*:*:*:*:*:*", "matchCriteriaId": "0C50D690-9A4D-4B78-BF4E-A4D9B4074216"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.16:r2:*:*:*:*:*:*", "matchCriteriaId": "124A5D30-7451-4516-9AA2-963AE62DD679"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.16:r3:*:*:*:*:*:*", "matchCriteriaId": "C260D13B-82E9-4596-9116-61073B42D661"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1793922", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/CESNET/libyang/commit/32fb4993bc8bb49e93e84016af3c10ea53964be5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/CESNET/libyang/compare/v0.16-r3...v1.0-r1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/CESNET/libyang/issues/723", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/CESNET/libyang/commit/32fb4993bc8bb49e93e84016af3c10ea53964be5"}}