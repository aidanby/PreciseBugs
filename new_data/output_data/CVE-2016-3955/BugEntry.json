{"buggy_code": ["/*\n * Copyright (C) 2003-2008 Takahiro Hirofuchi\n *\n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n * USA.\n */\n\n#include <asm/byteorder.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <net/sock.h>\n\n#include \"usbip_common.h\"\n\n#define DRIVER_AUTHOR \"Takahiro Hirofuchi <hirofuchi@users.sourceforge.net>\"\n#define DRIVER_DESC \"USB/IP Core\"\n\n#ifdef CONFIG_USBIP_DEBUG\nunsigned long usbip_debug_flag = 0xffffffff;\n#else\nunsigned long usbip_debug_flag;\n#endif\nEXPORT_SYMBOL_GPL(usbip_debug_flag);\nmodule_param(usbip_debug_flag, ulong, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(usbip_debug_flag, \"debug flags (defined in usbip_common.h)\");\n\n/* FIXME */\nstruct device_attribute dev_attr_usbip_debug;\nEXPORT_SYMBOL_GPL(dev_attr_usbip_debug);\n\nstatic ssize_t usbip_debug_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lx\\n\", usbip_debug_flag);\n}\n\nstatic ssize_t usbip_debug_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr, const char *buf,\n\t\t\t\t size_t count)\n{\n\tif (sscanf(buf, \"%lx\", &usbip_debug_flag) != 1)\n\t\treturn -EINVAL;\n\treturn count;\n}\nDEVICE_ATTR_RW(usbip_debug);\n\nstatic void usbip_dump_buffer(char *buff, int bufflen)\n{\n\tprint_hex_dump(KERN_DEBUG, \"usbip-core\", DUMP_PREFIX_OFFSET, 16, 4,\n\t\t       buff, bufflen, false);\n}\n\nstatic void usbip_dump_pipe(unsigned int p)\n{\n\tunsigned char type = usb_pipetype(p);\n\tunsigned char ep   = usb_pipeendpoint(p);\n\tunsigned char dev  = usb_pipedevice(p);\n\tunsigned char dir  = usb_pipein(p);\n\n\tpr_debug(\"dev(%d) ep(%d) [%s] \", dev, ep, dir ? \"IN\" : \"OUT\");\n\n\tswitch (type) {\n\tcase PIPE_ISOCHRONOUS:\n\t\tpr_debug(\"ISO\\n\");\n\t\tbreak;\n\tcase PIPE_INTERRUPT:\n\t\tpr_debug(\"INT\\n\");\n\t\tbreak;\n\tcase PIPE_CONTROL:\n\t\tpr_debug(\"CTRL\\n\");\n\t\tbreak;\n\tcase PIPE_BULK:\n\t\tpr_debug(\"BULK\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"ERR\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void usbip_dump_usb_device(struct usb_device *udev)\n{\n\tstruct device *dev = &udev->dev;\n\tint i;\n\n\tdev_dbg(dev, \"       devnum(%d) devpath(%s) usb speed(%s)\",\n\t\tudev->devnum, udev->devpath, usb_speed_string(udev->speed));\n\n\tpr_debug(\"tt %p, ttport %d\\n\", udev->tt, udev->ttport);\n\n\tdev_dbg(dev, \"                    \");\n\tfor (i = 0; i < 16; i++)\n\t\tpr_debug(\" %2u\", i);\n\tpr_debug(\"\\n\");\n\n\tdev_dbg(dev, \"       toggle0(IN) :\");\n\tfor (i = 0; i < 16; i++)\n\t\tpr_debug(\" %2u\", (udev->toggle[0] & (1 << i)) ? 1 : 0);\n\tpr_debug(\"\\n\");\n\n\tdev_dbg(dev, \"       toggle1(OUT):\");\n\tfor (i = 0; i < 16; i++)\n\t\tpr_debug(\" %2u\", (udev->toggle[1] & (1 << i)) ? 1 : 0);\n\tpr_debug(\"\\n\");\n\n\tdev_dbg(dev, \"       epmaxp_in   :\");\n\tfor (i = 0; i < 16; i++) {\n\t\tif (udev->ep_in[i])\n\t\t\tpr_debug(\" %2u\",\n\t\t\t    le16_to_cpu(udev->ep_in[i]->desc.wMaxPacketSize));\n\t}\n\tpr_debug(\"\\n\");\n\n\tdev_dbg(dev, \"       epmaxp_out  :\");\n\tfor (i = 0; i < 16; i++) {\n\t\tif (udev->ep_out[i])\n\t\t\tpr_debug(\" %2u\",\n\t\t\t    le16_to_cpu(udev->ep_out[i]->desc.wMaxPacketSize));\n\t}\n\tpr_debug(\"\\n\");\n\n\tdev_dbg(dev, \"parent %p, bus %p\\n\", udev->parent, udev->bus);\n\n\tdev_dbg(dev,\n\t\t\"descriptor %p, config %p, actconfig %p, rawdescriptors %p\\n\",\n\t\t&udev->descriptor, udev->config,\n\t\tudev->actconfig, udev->rawdescriptors);\n\n\tdev_dbg(dev, \"have_langid %d, string_langid %d\\n\",\n\t\tudev->have_langid, udev->string_langid);\n\n\tdev_dbg(dev, \"maxchild %d\\n\", udev->maxchild);\n}\n\nstatic void usbip_dump_request_type(__u8 rt)\n{\n\tswitch (rt & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tpr_debug(\"DEVICE\");\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tpr_debug(\"INTERF\");\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tpr_debug(\"ENDPOI\");\n\t\tbreak;\n\tcase USB_RECIP_OTHER:\n\t\tpr_debug(\"OTHER \");\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"------\");\n\t\tbreak;\n\t}\n}\n\nstatic void usbip_dump_usb_ctrlrequest(struct usb_ctrlrequest *cmd)\n{\n\tif (!cmd) {\n\t\tpr_debug(\"       : null pointer\\n\");\n\t\treturn;\n\t}\n\n\tpr_debug(\"       \");\n\tpr_debug(\"bRequestType(%02X) bRequest(%02X) wValue(%04X) wIndex(%04X) wLength(%04X) \",\n\t\t cmd->bRequestType, cmd->bRequest,\n\t\t cmd->wValue, cmd->wIndex, cmd->wLength);\n\tpr_debug(\"\\n       \");\n\n\tif ((cmd->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\n\t\tpr_debug(\"STANDARD \");\n\t\tswitch (cmd->bRequest) {\n\t\tcase USB_REQ_GET_STATUS:\n\t\t\tpr_debug(\"GET_STATUS\\n\");\n\t\t\tbreak;\n\t\tcase USB_REQ_CLEAR_FEATURE:\n\t\t\tpr_debug(\"CLEAR_FEAT\\n\");\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_FEATURE:\n\t\t\tpr_debug(\"SET_FEAT\\n\");\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_ADDRESS:\n\t\t\tpr_debug(\"SET_ADDRRS\\n\");\n\t\t\tbreak;\n\t\tcase USB_REQ_GET_DESCRIPTOR:\n\t\t\tpr_debug(\"GET_DESCRI\\n\");\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_DESCRIPTOR:\n\t\t\tpr_debug(\"SET_DESCRI\\n\");\n\t\t\tbreak;\n\t\tcase USB_REQ_GET_CONFIGURATION:\n\t\t\tpr_debug(\"GET_CONFIG\\n\");\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_CONFIGURATION:\n\t\t\tpr_debug(\"SET_CONFIG\\n\");\n\t\t\tbreak;\n\t\tcase USB_REQ_GET_INTERFACE:\n\t\t\tpr_debug(\"GET_INTERF\\n\");\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_INTERFACE:\n\t\t\tpr_debug(\"SET_INTERF\\n\");\n\t\t\tbreak;\n\t\tcase USB_REQ_SYNCH_FRAME:\n\t\t\tpr_debug(\"SYNC_FRAME\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_debug(\"REQ(%02X)\\n\", cmd->bRequest);\n\t\t\tbreak;\n\t\t}\n\t\tusbip_dump_request_type(cmd->bRequestType);\n\t} else if ((cmd->bRequestType & USB_TYPE_MASK) == USB_TYPE_CLASS) {\n\t\tpr_debug(\"CLASS\\n\");\n\t} else if ((cmd->bRequestType & USB_TYPE_MASK) == USB_TYPE_VENDOR) {\n\t\tpr_debug(\"VENDOR\\n\");\n\t} else if ((cmd->bRequestType & USB_TYPE_MASK) == USB_TYPE_RESERVED) {\n\t\tpr_debug(\"RESERVED\\n\");\n\t}\n}\n\nvoid usbip_dump_urb(struct urb *urb)\n{\n\tstruct device *dev;\n\n\tif (!urb) {\n\t\tpr_debug(\"urb: null pointer!!\\n\");\n\t\treturn;\n\t}\n\n\tif (!urb->dev) {\n\t\tpr_debug(\"urb->dev: null pointer!!\\n\");\n\t\treturn;\n\t}\n\n\tdev = &urb->dev->dev;\n\n\tdev_dbg(dev, \"   urb                   :%p\\n\", urb);\n\tdev_dbg(dev, \"   dev                   :%p\\n\", urb->dev);\n\n\tusbip_dump_usb_device(urb->dev);\n\n\tdev_dbg(dev, \"   pipe                  :%08x \", urb->pipe);\n\n\tusbip_dump_pipe(urb->pipe);\n\n\tdev_dbg(dev, \"   status                :%d\\n\", urb->status);\n\tdev_dbg(dev, \"   transfer_flags        :%08X\\n\", urb->transfer_flags);\n\tdev_dbg(dev, \"   transfer_buffer       :%p\\n\", urb->transfer_buffer);\n\tdev_dbg(dev, \"   transfer_buffer_length:%d\\n\",\n\t\t\t\t\t\turb->transfer_buffer_length);\n\tdev_dbg(dev, \"   actual_length         :%d\\n\", urb->actual_length);\n\tdev_dbg(dev, \"   setup_packet          :%p\\n\", urb->setup_packet);\n\n\tif (urb->setup_packet && usb_pipetype(urb->pipe) == PIPE_CONTROL)\n\t\tusbip_dump_usb_ctrlrequest(\n\t\t\t(struct usb_ctrlrequest *)urb->setup_packet);\n\n\tdev_dbg(dev, \"   start_frame           :%d\\n\", urb->start_frame);\n\tdev_dbg(dev, \"   number_of_packets     :%d\\n\", urb->number_of_packets);\n\tdev_dbg(dev, \"   interval              :%d\\n\", urb->interval);\n\tdev_dbg(dev, \"   error_count           :%d\\n\", urb->error_count);\n\tdev_dbg(dev, \"   context               :%p\\n\", urb->context);\n\tdev_dbg(dev, \"   complete              :%p\\n\", urb->complete);\n}\nEXPORT_SYMBOL_GPL(usbip_dump_urb);\n\nvoid usbip_dump_header(struct usbip_header *pdu)\n{\n\tpr_debug(\"BASE: cmd %u seq %u devid %u dir %u ep %u\\n\",\n\t\t pdu->base.command,\n\t\t pdu->base.seqnum,\n\t\t pdu->base.devid,\n\t\t pdu->base.direction,\n\t\t pdu->base.ep);\n\n\tswitch (pdu->base.command) {\n\tcase USBIP_CMD_SUBMIT:\n\t\tpr_debug(\"USBIP_CMD_SUBMIT: x_flags %u x_len %u sf %u #p %d iv %d\\n\",\n\t\t\t pdu->u.cmd_submit.transfer_flags,\n\t\t\t pdu->u.cmd_submit.transfer_buffer_length,\n\t\t\t pdu->u.cmd_submit.start_frame,\n\t\t\t pdu->u.cmd_submit.number_of_packets,\n\t\t\t pdu->u.cmd_submit.interval);\n\t\tbreak;\n\tcase USBIP_CMD_UNLINK:\n\t\tpr_debug(\"USBIP_CMD_UNLINK: seq %u\\n\",\n\t\t\t pdu->u.cmd_unlink.seqnum);\n\t\tbreak;\n\tcase USBIP_RET_SUBMIT:\n\t\tpr_debug(\"USBIP_RET_SUBMIT: st %d al %u sf %d #p %d ec %d\\n\",\n\t\t\t pdu->u.ret_submit.status,\n\t\t\t pdu->u.ret_submit.actual_length,\n\t\t\t pdu->u.ret_submit.start_frame,\n\t\t\t pdu->u.ret_submit.number_of_packets,\n\t\t\t pdu->u.ret_submit.error_count);\n\t\tbreak;\n\tcase USBIP_RET_UNLINK:\n\t\tpr_debug(\"USBIP_RET_UNLINK: status %d\\n\",\n\t\t\t pdu->u.ret_unlink.status);\n\t\tbreak;\n\tdefault:\n\t\t/* NOT REACHED */\n\t\tpr_err(\"unknown command\\n\");\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(usbip_dump_header);\n\n/* Receive data over TCP/IP. */\nint usbip_recv(struct socket *sock, void *buf, int size)\n{\n\tint result;\n\tstruct msghdr msg;\n\tstruct kvec iov;\n\tint total = 0;\n\n\t/* for blocks of if (usbip_dbg_flag_xmit) */\n\tchar *bp = buf;\n\tint osize = size;\n\n\tusbip_dbg_xmit(\"enter\\n\");\n\n\tif (!sock || !buf || !size) {\n\t\tpr_err(\"invalid arg, sock %p buff %p size %d\\n\", sock, buf,\n\t\t       size);\n\t\treturn -EINVAL;\n\t}\n\n\tdo {\n\t\tsock->sk->sk_allocation = GFP_NOIO;\n\t\tiov.iov_base    = buf;\n\t\tiov.iov_len     = size;\n\t\tmsg.msg_name    = NULL;\n\t\tmsg.msg_namelen = 0;\n\t\tmsg.msg_control = NULL;\n\t\tmsg.msg_controllen = 0;\n\t\tmsg.msg_flags      = MSG_NOSIGNAL;\n\n\t\tresult = kernel_recvmsg(sock, &msg, &iov, 1, size, MSG_WAITALL);\n\t\tif (result <= 0) {\n\t\t\tpr_debug(\"receive sock %p buf %p size %u ret %d total %d\\n\",\n\t\t\t\t sock, buf, size, result, total);\n\t\t\tgoto err;\n\t\t}\n\n\t\tsize -= result;\n\t\tbuf += result;\n\t\ttotal += result;\n\t} while (size > 0);\n\n\tif (usbip_dbg_flag_xmit) {\n\t\tif (!in_interrupt())\n\t\t\tpr_debug(\"%-10s:\", current->comm);\n\t\telse\n\t\t\tpr_debug(\"interrupt  :\");\n\n\t\tpr_debug(\"receiving....\\n\");\n\t\tusbip_dump_buffer(bp, osize);\n\t\tpr_debug(\"received, osize %d ret %d size %d total %d\\n\",\n\t\t\t osize, result, size, total);\n\t}\n\n\treturn total;\n\nerr:\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(usbip_recv);\n\n/* there may be more cases to tweak the flags. */\nstatic unsigned int tweak_transfer_flags(unsigned int flags)\n{\n\tflags &= ~URB_NO_TRANSFER_DMA_MAP;\n\treturn flags;\n}\n\nstatic void usbip_pack_cmd_submit(struct usbip_header *pdu, struct urb *urb,\n\t\t\t\t  int pack)\n{\n\tstruct usbip_header_cmd_submit *spdu = &pdu->u.cmd_submit;\n\n\t/*\n\t * Some members are not still implemented in usbip. I hope this issue\n\t * will be discussed when usbip is ported to other operating systems.\n\t */\n\tif (pack) {\n\t\tspdu->transfer_flags =\n\t\t\ttweak_transfer_flags(urb->transfer_flags);\n\t\tspdu->transfer_buffer_length\t= urb->transfer_buffer_length;\n\t\tspdu->start_frame\t\t= urb->start_frame;\n\t\tspdu->number_of_packets\t\t= urb->number_of_packets;\n\t\tspdu->interval\t\t\t= urb->interval;\n\t} else  {\n\t\turb->transfer_flags         = spdu->transfer_flags;\n\t\turb->transfer_buffer_length = spdu->transfer_buffer_length;\n\t\turb->start_frame            = spdu->start_frame;\n\t\turb->number_of_packets      = spdu->number_of_packets;\n\t\turb->interval               = spdu->interval;\n\t}\n}\n\nstatic void usbip_pack_ret_submit(struct usbip_header *pdu, struct urb *urb,\n\t\t\t\t  int pack)\n{\n\tstruct usbip_header_ret_submit *rpdu = &pdu->u.ret_submit;\n\n\tif (pack) {\n\t\trpdu->status\t\t= urb->status;\n\t\trpdu->actual_length\t= urb->actual_length;\n\t\trpdu->start_frame\t= urb->start_frame;\n\t\trpdu->number_of_packets = urb->number_of_packets;\n\t\trpdu->error_count\t= urb->error_count;\n\t} else {\n\t\turb->status\t\t= rpdu->status;\n\t\turb->actual_length\t= rpdu->actual_length;\n\t\turb->start_frame\t= rpdu->start_frame;\n\t\turb->number_of_packets = rpdu->number_of_packets;\n\t\turb->error_count\t= rpdu->error_count;\n\t}\n}\n\nvoid usbip_pack_pdu(struct usbip_header *pdu, struct urb *urb, int cmd,\n\t\t    int pack)\n{\n\tswitch (cmd) {\n\tcase USBIP_CMD_SUBMIT:\n\t\tusbip_pack_cmd_submit(pdu, urb, pack);\n\t\tbreak;\n\tcase USBIP_RET_SUBMIT:\n\t\tusbip_pack_ret_submit(pdu, urb, pack);\n\t\tbreak;\n\tdefault:\n\t\t/* NOT REACHED */\n\t\tpr_err(\"unknown command\\n\");\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(usbip_pack_pdu);\n\nstatic void correct_endian_basic(struct usbip_header_basic *base, int send)\n{\n\tif (send) {\n\t\tbase->command\t= cpu_to_be32(base->command);\n\t\tbase->seqnum\t= cpu_to_be32(base->seqnum);\n\t\tbase->devid\t= cpu_to_be32(base->devid);\n\t\tbase->direction\t= cpu_to_be32(base->direction);\n\t\tbase->ep\t= cpu_to_be32(base->ep);\n\t} else {\n\t\tbase->command\t= be32_to_cpu(base->command);\n\t\tbase->seqnum\t= be32_to_cpu(base->seqnum);\n\t\tbase->devid\t= be32_to_cpu(base->devid);\n\t\tbase->direction\t= be32_to_cpu(base->direction);\n\t\tbase->ep\t= be32_to_cpu(base->ep);\n\t}\n}\n\nstatic void correct_endian_cmd_submit(struct usbip_header_cmd_submit *pdu,\n\t\t\t\t      int send)\n{\n\tif (send) {\n\t\tpdu->transfer_flags = cpu_to_be32(pdu->transfer_flags);\n\n\t\tcpu_to_be32s(&pdu->transfer_buffer_length);\n\t\tcpu_to_be32s(&pdu->start_frame);\n\t\tcpu_to_be32s(&pdu->number_of_packets);\n\t\tcpu_to_be32s(&pdu->interval);\n\t} else {\n\t\tpdu->transfer_flags = be32_to_cpu(pdu->transfer_flags);\n\n\t\tbe32_to_cpus(&pdu->transfer_buffer_length);\n\t\tbe32_to_cpus(&pdu->start_frame);\n\t\tbe32_to_cpus(&pdu->number_of_packets);\n\t\tbe32_to_cpus(&pdu->interval);\n\t}\n}\n\nstatic void correct_endian_ret_submit(struct usbip_header_ret_submit *pdu,\n\t\t\t\t      int send)\n{\n\tif (send) {\n\t\tcpu_to_be32s(&pdu->status);\n\t\tcpu_to_be32s(&pdu->actual_length);\n\t\tcpu_to_be32s(&pdu->start_frame);\n\t\tcpu_to_be32s(&pdu->number_of_packets);\n\t\tcpu_to_be32s(&pdu->error_count);\n\t} else {\n\t\tbe32_to_cpus(&pdu->status);\n\t\tbe32_to_cpus(&pdu->actual_length);\n\t\tbe32_to_cpus(&pdu->start_frame);\n\t\tbe32_to_cpus(&pdu->number_of_packets);\n\t\tbe32_to_cpus(&pdu->error_count);\n\t}\n}\n\nstatic void correct_endian_cmd_unlink(struct usbip_header_cmd_unlink *pdu,\n\t\t\t\t      int send)\n{\n\tif (send)\n\t\tpdu->seqnum = cpu_to_be32(pdu->seqnum);\n\telse\n\t\tpdu->seqnum = be32_to_cpu(pdu->seqnum);\n}\n\nstatic void correct_endian_ret_unlink(struct usbip_header_ret_unlink *pdu,\n\t\t\t\t      int send)\n{\n\tif (send)\n\t\tcpu_to_be32s(&pdu->status);\n\telse\n\t\tbe32_to_cpus(&pdu->status);\n}\n\nvoid usbip_header_correct_endian(struct usbip_header *pdu, int send)\n{\n\t__u32 cmd = 0;\n\n\tif (send)\n\t\tcmd = pdu->base.command;\n\n\tcorrect_endian_basic(&pdu->base, send);\n\n\tif (!send)\n\t\tcmd = pdu->base.command;\n\n\tswitch (cmd) {\n\tcase USBIP_CMD_SUBMIT:\n\t\tcorrect_endian_cmd_submit(&pdu->u.cmd_submit, send);\n\t\tbreak;\n\tcase USBIP_RET_SUBMIT:\n\t\tcorrect_endian_ret_submit(&pdu->u.ret_submit, send);\n\t\tbreak;\n\tcase USBIP_CMD_UNLINK:\n\t\tcorrect_endian_cmd_unlink(&pdu->u.cmd_unlink, send);\n\t\tbreak;\n\tcase USBIP_RET_UNLINK:\n\t\tcorrect_endian_ret_unlink(&pdu->u.ret_unlink, send);\n\t\tbreak;\n\tdefault:\n\t\t/* NOT REACHED */\n\t\tpr_err(\"unknown command\\n\");\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(usbip_header_correct_endian);\n\nstatic void usbip_iso_packet_correct_endian(\n\t\tstruct usbip_iso_packet_descriptor *iso, int send)\n{\n\t/* does not need all members. but copy all simply. */\n\tif (send) {\n\t\tiso->offset\t= cpu_to_be32(iso->offset);\n\t\tiso->length\t= cpu_to_be32(iso->length);\n\t\tiso->status\t= cpu_to_be32(iso->status);\n\t\tiso->actual_length = cpu_to_be32(iso->actual_length);\n\t} else {\n\t\tiso->offset\t= be32_to_cpu(iso->offset);\n\t\tiso->length\t= be32_to_cpu(iso->length);\n\t\tiso->status\t= be32_to_cpu(iso->status);\n\t\tiso->actual_length = be32_to_cpu(iso->actual_length);\n\t}\n}\n\nstatic void usbip_pack_iso(struct usbip_iso_packet_descriptor *iso,\n\t\t\t   struct usb_iso_packet_descriptor *uiso, int pack)\n{\n\tif (pack) {\n\t\tiso->offset\t\t= uiso->offset;\n\t\tiso->length\t\t= uiso->length;\n\t\tiso->status\t\t= uiso->status;\n\t\tiso->actual_length\t= uiso->actual_length;\n\t} else {\n\t\tuiso->offset\t\t= iso->offset;\n\t\tuiso->length\t\t= iso->length;\n\t\tuiso->status\t\t= iso->status;\n\t\tuiso->actual_length\t= iso->actual_length;\n\t}\n}\n\n/* must free buffer */\nstruct usbip_iso_packet_descriptor*\nusbip_alloc_iso_desc_pdu(struct urb *urb, ssize_t *bufflen)\n{\n\tstruct usbip_iso_packet_descriptor *iso;\n\tint np = urb->number_of_packets;\n\tssize_t size = np * sizeof(*iso);\n\tint i;\n\n\tiso = kzalloc(size, GFP_KERNEL);\n\tif (!iso)\n\t\treturn NULL;\n\n\tfor (i = 0; i < np; i++) {\n\t\tusbip_pack_iso(&iso[i], &urb->iso_frame_desc[i], 1);\n\t\tusbip_iso_packet_correct_endian(&iso[i], 1);\n\t}\n\n\t*bufflen = size;\n\n\treturn iso;\n}\nEXPORT_SYMBOL_GPL(usbip_alloc_iso_desc_pdu);\n\n/* some members of urb must be substituted before. */\nint usbip_recv_iso(struct usbip_device *ud, struct urb *urb)\n{\n\tvoid *buff;\n\tstruct usbip_iso_packet_descriptor *iso;\n\tint np = urb->number_of_packets;\n\tint size = np * sizeof(*iso);\n\tint i;\n\tint ret;\n\tint total_length = 0;\n\n\tif (!usb_pipeisoc(urb->pipe))\n\t\treturn 0;\n\n\t/* my Bluetooth dongle gets ISO URBs which are np = 0 */\n\tif (np == 0)\n\t\treturn 0;\n\n\tbuff = kzalloc(size, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\tret = usbip_recv(ud->tcp_socket, buff, size);\n\tif (ret != size) {\n\t\tdev_err(&urb->dev->dev, \"recv iso_frame_descriptor, %d\\n\",\n\t\t\tret);\n\t\tkfree(buff);\n\n\t\tif (ud->side == USBIP_STUB)\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\telse\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\n\t\treturn -EPIPE;\n\t}\n\n\tiso = (struct usbip_iso_packet_descriptor *) buff;\n\tfor (i = 0; i < np; i++) {\n\t\tusbip_iso_packet_correct_endian(&iso[i], 0);\n\t\tusbip_pack_iso(&iso[i], &urb->iso_frame_desc[i], 0);\n\t\ttotal_length += urb->iso_frame_desc[i].actual_length;\n\t}\n\n\tkfree(buff);\n\n\tif (total_length != urb->actual_length) {\n\t\tdev_err(&urb->dev->dev,\n\t\t\t\"total length of iso packets %d not equal to actual length of buffer %d\\n\",\n\t\t\ttotal_length, urb->actual_length);\n\n\t\tif (ud->side == USBIP_STUB)\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\telse\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\n\t\treturn -EPIPE;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usbip_recv_iso);\n\n/*\n * This functions restores the padding which was removed for optimizing\n * the bandwidth during transfer over tcp/ip\n *\n * buffer and iso packets need to be stored and be in propeper endian in urb\n * before calling this function\n */\nvoid usbip_pad_iso(struct usbip_device *ud, struct urb *urb)\n{\n\tint np = urb->number_of_packets;\n\tint i;\n\tint actualoffset = urb->actual_length;\n\n\tif (!usb_pipeisoc(urb->pipe))\n\t\treturn;\n\n\t/* if no packets or length of data is 0, then nothing to unpack */\n\tif (np == 0 || urb->actual_length == 0)\n\t\treturn;\n\n\t/*\n\t * if actual_length is transfer_buffer_length then no padding is\n\t * present.\n\t */\n\tif (urb->actual_length == urb->transfer_buffer_length)\n\t\treturn;\n\n\t/*\n\t * loop over all packets from last to first (to prevent overwritting\n\t * memory when padding) and move them into the proper place\n\t */\n\tfor (i = np-1; i > 0; i--) {\n\t\tactualoffset -= urb->iso_frame_desc[i].actual_length;\n\t\tmemmove(urb->transfer_buffer + urb->iso_frame_desc[i].offset,\n\t\t\turb->transfer_buffer + actualoffset,\n\t\t\turb->iso_frame_desc[i].actual_length);\n\t}\n}\nEXPORT_SYMBOL_GPL(usbip_pad_iso);\n\n/* some members of urb must be substituted before. */\nint usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)\n{\n\tint ret;\n\tint size;\n\n\tif (ud->side == USBIP_STUB) {\n\t\t/* the direction of urb must be OUT. */\n\t\tif (usb_pipein(urb->pipe))\n\t\t\treturn 0;\n\n\t\tsize = urb->transfer_buffer_length;\n\t} else {\n\t\t/* the direction of urb must be IN. */\n\t\tif (usb_pipeout(urb->pipe))\n\t\t\treturn 0;\n\n\t\tsize = urb->actual_length;\n\t}\n\n\t/* no need to recv xbuff */\n\tif (!(size > 0))\n\t\treturn 0;\n\n\tret = usbip_recv(ud->tcp_socket, urb->transfer_buffer, size);\n\tif (ret != size) {\n\t\tdev_err(&urb->dev->dev, \"recv xbuf, %d\\n\", ret);\n\t\tif (ud->side == USBIP_STUB) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\t} else {\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usbip_recv_xbuff);\n\nstatic int __init usbip_core_init(void)\n{\n\tpr_info(DRIVER_DESC \" v\" USBIP_VERSION \"\\n\");\n\treturn 0;\n}\n\nstatic void __exit usbip_core_exit(void)\n{\n\treturn;\n}\n\nmodule_init(usbip_core_init);\nmodule_exit(usbip_core_exit);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(USBIP_VERSION);\n"], "fixing_code": ["/*\n * Copyright (C) 2003-2008 Takahiro Hirofuchi\n *\n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n * USA.\n */\n\n#include <asm/byteorder.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <net/sock.h>\n\n#include \"usbip_common.h\"\n\n#define DRIVER_AUTHOR \"Takahiro Hirofuchi <hirofuchi@users.sourceforge.net>\"\n#define DRIVER_DESC \"USB/IP Core\"\n\n#ifdef CONFIG_USBIP_DEBUG\nunsigned long usbip_debug_flag = 0xffffffff;\n#else\nunsigned long usbip_debug_flag;\n#endif\nEXPORT_SYMBOL_GPL(usbip_debug_flag);\nmodule_param(usbip_debug_flag, ulong, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(usbip_debug_flag, \"debug flags (defined in usbip_common.h)\");\n\n/* FIXME */\nstruct device_attribute dev_attr_usbip_debug;\nEXPORT_SYMBOL_GPL(dev_attr_usbip_debug);\n\nstatic ssize_t usbip_debug_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lx\\n\", usbip_debug_flag);\n}\n\nstatic ssize_t usbip_debug_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr, const char *buf,\n\t\t\t\t size_t count)\n{\n\tif (sscanf(buf, \"%lx\", &usbip_debug_flag) != 1)\n\t\treturn -EINVAL;\n\treturn count;\n}\nDEVICE_ATTR_RW(usbip_debug);\n\nstatic void usbip_dump_buffer(char *buff, int bufflen)\n{\n\tprint_hex_dump(KERN_DEBUG, \"usbip-core\", DUMP_PREFIX_OFFSET, 16, 4,\n\t\t       buff, bufflen, false);\n}\n\nstatic void usbip_dump_pipe(unsigned int p)\n{\n\tunsigned char type = usb_pipetype(p);\n\tunsigned char ep   = usb_pipeendpoint(p);\n\tunsigned char dev  = usb_pipedevice(p);\n\tunsigned char dir  = usb_pipein(p);\n\n\tpr_debug(\"dev(%d) ep(%d) [%s] \", dev, ep, dir ? \"IN\" : \"OUT\");\n\n\tswitch (type) {\n\tcase PIPE_ISOCHRONOUS:\n\t\tpr_debug(\"ISO\\n\");\n\t\tbreak;\n\tcase PIPE_INTERRUPT:\n\t\tpr_debug(\"INT\\n\");\n\t\tbreak;\n\tcase PIPE_CONTROL:\n\t\tpr_debug(\"CTRL\\n\");\n\t\tbreak;\n\tcase PIPE_BULK:\n\t\tpr_debug(\"BULK\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"ERR\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void usbip_dump_usb_device(struct usb_device *udev)\n{\n\tstruct device *dev = &udev->dev;\n\tint i;\n\n\tdev_dbg(dev, \"       devnum(%d) devpath(%s) usb speed(%s)\",\n\t\tudev->devnum, udev->devpath, usb_speed_string(udev->speed));\n\n\tpr_debug(\"tt %p, ttport %d\\n\", udev->tt, udev->ttport);\n\n\tdev_dbg(dev, \"                    \");\n\tfor (i = 0; i < 16; i++)\n\t\tpr_debug(\" %2u\", i);\n\tpr_debug(\"\\n\");\n\n\tdev_dbg(dev, \"       toggle0(IN) :\");\n\tfor (i = 0; i < 16; i++)\n\t\tpr_debug(\" %2u\", (udev->toggle[0] & (1 << i)) ? 1 : 0);\n\tpr_debug(\"\\n\");\n\n\tdev_dbg(dev, \"       toggle1(OUT):\");\n\tfor (i = 0; i < 16; i++)\n\t\tpr_debug(\" %2u\", (udev->toggle[1] & (1 << i)) ? 1 : 0);\n\tpr_debug(\"\\n\");\n\n\tdev_dbg(dev, \"       epmaxp_in   :\");\n\tfor (i = 0; i < 16; i++) {\n\t\tif (udev->ep_in[i])\n\t\t\tpr_debug(\" %2u\",\n\t\t\t    le16_to_cpu(udev->ep_in[i]->desc.wMaxPacketSize));\n\t}\n\tpr_debug(\"\\n\");\n\n\tdev_dbg(dev, \"       epmaxp_out  :\");\n\tfor (i = 0; i < 16; i++) {\n\t\tif (udev->ep_out[i])\n\t\t\tpr_debug(\" %2u\",\n\t\t\t    le16_to_cpu(udev->ep_out[i]->desc.wMaxPacketSize));\n\t}\n\tpr_debug(\"\\n\");\n\n\tdev_dbg(dev, \"parent %p, bus %p\\n\", udev->parent, udev->bus);\n\n\tdev_dbg(dev,\n\t\t\"descriptor %p, config %p, actconfig %p, rawdescriptors %p\\n\",\n\t\t&udev->descriptor, udev->config,\n\t\tudev->actconfig, udev->rawdescriptors);\n\n\tdev_dbg(dev, \"have_langid %d, string_langid %d\\n\",\n\t\tudev->have_langid, udev->string_langid);\n\n\tdev_dbg(dev, \"maxchild %d\\n\", udev->maxchild);\n}\n\nstatic void usbip_dump_request_type(__u8 rt)\n{\n\tswitch (rt & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tpr_debug(\"DEVICE\");\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tpr_debug(\"INTERF\");\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tpr_debug(\"ENDPOI\");\n\t\tbreak;\n\tcase USB_RECIP_OTHER:\n\t\tpr_debug(\"OTHER \");\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"------\");\n\t\tbreak;\n\t}\n}\n\nstatic void usbip_dump_usb_ctrlrequest(struct usb_ctrlrequest *cmd)\n{\n\tif (!cmd) {\n\t\tpr_debug(\"       : null pointer\\n\");\n\t\treturn;\n\t}\n\n\tpr_debug(\"       \");\n\tpr_debug(\"bRequestType(%02X) bRequest(%02X) wValue(%04X) wIndex(%04X) wLength(%04X) \",\n\t\t cmd->bRequestType, cmd->bRequest,\n\t\t cmd->wValue, cmd->wIndex, cmd->wLength);\n\tpr_debug(\"\\n       \");\n\n\tif ((cmd->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\n\t\tpr_debug(\"STANDARD \");\n\t\tswitch (cmd->bRequest) {\n\t\tcase USB_REQ_GET_STATUS:\n\t\t\tpr_debug(\"GET_STATUS\\n\");\n\t\t\tbreak;\n\t\tcase USB_REQ_CLEAR_FEATURE:\n\t\t\tpr_debug(\"CLEAR_FEAT\\n\");\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_FEATURE:\n\t\t\tpr_debug(\"SET_FEAT\\n\");\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_ADDRESS:\n\t\t\tpr_debug(\"SET_ADDRRS\\n\");\n\t\t\tbreak;\n\t\tcase USB_REQ_GET_DESCRIPTOR:\n\t\t\tpr_debug(\"GET_DESCRI\\n\");\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_DESCRIPTOR:\n\t\t\tpr_debug(\"SET_DESCRI\\n\");\n\t\t\tbreak;\n\t\tcase USB_REQ_GET_CONFIGURATION:\n\t\t\tpr_debug(\"GET_CONFIG\\n\");\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_CONFIGURATION:\n\t\t\tpr_debug(\"SET_CONFIG\\n\");\n\t\t\tbreak;\n\t\tcase USB_REQ_GET_INTERFACE:\n\t\t\tpr_debug(\"GET_INTERF\\n\");\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_INTERFACE:\n\t\t\tpr_debug(\"SET_INTERF\\n\");\n\t\t\tbreak;\n\t\tcase USB_REQ_SYNCH_FRAME:\n\t\t\tpr_debug(\"SYNC_FRAME\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_debug(\"REQ(%02X)\\n\", cmd->bRequest);\n\t\t\tbreak;\n\t\t}\n\t\tusbip_dump_request_type(cmd->bRequestType);\n\t} else if ((cmd->bRequestType & USB_TYPE_MASK) == USB_TYPE_CLASS) {\n\t\tpr_debug(\"CLASS\\n\");\n\t} else if ((cmd->bRequestType & USB_TYPE_MASK) == USB_TYPE_VENDOR) {\n\t\tpr_debug(\"VENDOR\\n\");\n\t} else if ((cmd->bRequestType & USB_TYPE_MASK) == USB_TYPE_RESERVED) {\n\t\tpr_debug(\"RESERVED\\n\");\n\t}\n}\n\nvoid usbip_dump_urb(struct urb *urb)\n{\n\tstruct device *dev;\n\n\tif (!urb) {\n\t\tpr_debug(\"urb: null pointer!!\\n\");\n\t\treturn;\n\t}\n\n\tif (!urb->dev) {\n\t\tpr_debug(\"urb->dev: null pointer!!\\n\");\n\t\treturn;\n\t}\n\n\tdev = &urb->dev->dev;\n\n\tdev_dbg(dev, \"   urb                   :%p\\n\", urb);\n\tdev_dbg(dev, \"   dev                   :%p\\n\", urb->dev);\n\n\tusbip_dump_usb_device(urb->dev);\n\n\tdev_dbg(dev, \"   pipe                  :%08x \", urb->pipe);\n\n\tusbip_dump_pipe(urb->pipe);\n\n\tdev_dbg(dev, \"   status                :%d\\n\", urb->status);\n\tdev_dbg(dev, \"   transfer_flags        :%08X\\n\", urb->transfer_flags);\n\tdev_dbg(dev, \"   transfer_buffer       :%p\\n\", urb->transfer_buffer);\n\tdev_dbg(dev, \"   transfer_buffer_length:%d\\n\",\n\t\t\t\t\t\turb->transfer_buffer_length);\n\tdev_dbg(dev, \"   actual_length         :%d\\n\", urb->actual_length);\n\tdev_dbg(dev, \"   setup_packet          :%p\\n\", urb->setup_packet);\n\n\tif (urb->setup_packet && usb_pipetype(urb->pipe) == PIPE_CONTROL)\n\t\tusbip_dump_usb_ctrlrequest(\n\t\t\t(struct usb_ctrlrequest *)urb->setup_packet);\n\n\tdev_dbg(dev, \"   start_frame           :%d\\n\", urb->start_frame);\n\tdev_dbg(dev, \"   number_of_packets     :%d\\n\", urb->number_of_packets);\n\tdev_dbg(dev, \"   interval              :%d\\n\", urb->interval);\n\tdev_dbg(dev, \"   error_count           :%d\\n\", urb->error_count);\n\tdev_dbg(dev, \"   context               :%p\\n\", urb->context);\n\tdev_dbg(dev, \"   complete              :%p\\n\", urb->complete);\n}\nEXPORT_SYMBOL_GPL(usbip_dump_urb);\n\nvoid usbip_dump_header(struct usbip_header *pdu)\n{\n\tpr_debug(\"BASE: cmd %u seq %u devid %u dir %u ep %u\\n\",\n\t\t pdu->base.command,\n\t\t pdu->base.seqnum,\n\t\t pdu->base.devid,\n\t\t pdu->base.direction,\n\t\t pdu->base.ep);\n\n\tswitch (pdu->base.command) {\n\tcase USBIP_CMD_SUBMIT:\n\t\tpr_debug(\"USBIP_CMD_SUBMIT: x_flags %u x_len %u sf %u #p %d iv %d\\n\",\n\t\t\t pdu->u.cmd_submit.transfer_flags,\n\t\t\t pdu->u.cmd_submit.transfer_buffer_length,\n\t\t\t pdu->u.cmd_submit.start_frame,\n\t\t\t pdu->u.cmd_submit.number_of_packets,\n\t\t\t pdu->u.cmd_submit.interval);\n\t\tbreak;\n\tcase USBIP_CMD_UNLINK:\n\t\tpr_debug(\"USBIP_CMD_UNLINK: seq %u\\n\",\n\t\t\t pdu->u.cmd_unlink.seqnum);\n\t\tbreak;\n\tcase USBIP_RET_SUBMIT:\n\t\tpr_debug(\"USBIP_RET_SUBMIT: st %d al %u sf %d #p %d ec %d\\n\",\n\t\t\t pdu->u.ret_submit.status,\n\t\t\t pdu->u.ret_submit.actual_length,\n\t\t\t pdu->u.ret_submit.start_frame,\n\t\t\t pdu->u.ret_submit.number_of_packets,\n\t\t\t pdu->u.ret_submit.error_count);\n\t\tbreak;\n\tcase USBIP_RET_UNLINK:\n\t\tpr_debug(\"USBIP_RET_UNLINK: status %d\\n\",\n\t\t\t pdu->u.ret_unlink.status);\n\t\tbreak;\n\tdefault:\n\t\t/* NOT REACHED */\n\t\tpr_err(\"unknown command\\n\");\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(usbip_dump_header);\n\n/* Receive data over TCP/IP. */\nint usbip_recv(struct socket *sock, void *buf, int size)\n{\n\tint result;\n\tstruct msghdr msg;\n\tstruct kvec iov;\n\tint total = 0;\n\n\t/* for blocks of if (usbip_dbg_flag_xmit) */\n\tchar *bp = buf;\n\tint osize = size;\n\n\tusbip_dbg_xmit(\"enter\\n\");\n\n\tif (!sock || !buf || !size) {\n\t\tpr_err(\"invalid arg, sock %p buff %p size %d\\n\", sock, buf,\n\t\t       size);\n\t\treturn -EINVAL;\n\t}\n\n\tdo {\n\t\tsock->sk->sk_allocation = GFP_NOIO;\n\t\tiov.iov_base    = buf;\n\t\tiov.iov_len     = size;\n\t\tmsg.msg_name    = NULL;\n\t\tmsg.msg_namelen = 0;\n\t\tmsg.msg_control = NULL;\n\t\tmsg.msg_controllen = 0;\n\t\tmsg.msg_flags      = MSG_NOSIGNAL;\n\n\t\tresult = kernel_recvmsg(sock, &msg, &iov, 1, size, MSG_WAITALL);\n\t\tif (result <= 0) {\n\t\t\tpr_debug(\"receive sock %p buf %p size %u ret %d total %d\\n\",\n\t\t\t\t sock, buf, size, result, total);\n\t\t\tgoto err;\n\t\t}\n\n\t\tsize -= result;\n\t\tbuf += result;\n\t\ttotal += result;\n\t} while (size > 0);\n\n\tif (usbip_dbg_flag_xmit) {\n\t\tif (!in_interrupt())\n\t\t\tpr_debug(\"%-10s:\", current->comm);\n\t\telse\n\t\t\tpr_debug(\"interrupt  :\");\n\n\t\tpr_debug(\"receiving....\\n\");\n\t\tusbip_dump_buffer(bp, osize);\n\t\tpr_debug(\"received, osize %d ret %d size %d total %d\\n\",\n\t\t\t osize, result, size, total);\n\t}\n\n\treturn total;\n\nerr:\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(usbip_recv);\n\n/* there may be more cases to tweak the flags. */\nstatic unsigned int tweak_transfer_flags(unsigned int flags)\n{\n\tflags &= ~URB_NO_TRANSFER_DMA_MAP;\n\treturn flags;\n}\n\nstatic void usbip_pack_cmd_submit(struct usbip_header *pdu, struct urb *urb,\n\t\t\t\t  int pack)\n{\n\tstruct usbip_header_cmd_submit *spdu = &pdu->u.cmd_submit;\n\n\t/*\n\t * Some members are not still implemented in usbip. I hope this issue\n\t * will be discussed when usbip is ported to other operating systems.\n\t */\n\tif (pack) {\n\t\tspdu->transfer_flags =\n\t\t\ttweak_transfer_flags(urb->transfer_flags);\n\t\tspdu->transfer_buffer_length\t= urb->transfer_buffer_length;\n\t\tspdu->start_frame\t\t= urb->start_frame;\n\t\tspdu->number_of_packets\t\t= urb->number_of_packets;\n\t\tspdu->interval\t\t\t= urb->interval;\n\t} else  {\n\t\turb->transfer_flags         = spdu->transfer_flags;\n\t\turb->transfer_buffer_length = spdu->transfer_buffer_length;\n\t\turb->start_frame            = spdu->start_frame;\n\t\turb->number_of_packets      = spdu->number_of_packets;\n\t\turb->interval               = spdu->interval;\n\t}\n}\n\nstatic void usbip_pack_ret_submit(struct usbip_header *pdu, struct urb *urb,\n\t\t\t\t  int pack)\n{\n\tstruct usbip_header_ret_submit *rpdu = &pdu->u.ret_submit;\n\n\tif (pack) {\n\t\trpdu->status\t\t= urb->status;\n\t\trpdu->actual_length\t= urb->actual_length;\n\t\trpdu->start_frame\t= urb->start_frame;\n\t\trpdu->number_of_packets = urb->number_of_packets;\n\t\trpdu->error_count\t= urb->error_count;\n\t} else {\n\t\turb->status\t\t= rpdu->status;\n\t\turb->actual_length\t= rpdu->actual_length;\n\t\turb->start_frame\t= rpdu->start_frame;\n\t\turb->number_of_packets = rpdu->number_of_packets;\n\t\turb->error_count\t= rpdu->error_count;\n\t}\n}\n\nvoid usbip_pack_pdu(struct usbip_header *pdu, struct urb *urb, int cmd,\n\t\t    int pack)\n{\n\tswitch (cmd) {\n\tcase USBIP_CMD_SUBMIT:\n\t\tusbip_pack_cmd_submit(pdu, urb, pack);\n\t\tbreak;\n\tcase USBIP_RET_SUBMIT:\n\t\tusbip_pack_ret_submit(pdu, urb, pack);\n\t\tbreak;\n\tdefault:\n\t\t/* NOT REACHED */\n\t\tpr_err(\"unknown command\\n\");\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(usbip_pack_pdu);\n\nstatic void correct_endian_basic(struct usbip_header_basic *base, int send)\n{\n\tif (send) {\n\t\tbase->command\t= cpu_to_be32(base->command);\n\t\tbase->seqnum\t= cpu_to_be32(base->seqnum);\n\t\tbase->devid\t= cpu_to_be32(base->devid);\n\t\tbase->direction\t= cpu_to_be32(base->direction);\n\t\tbase->ep\t= cpu_to_be32(base->ep);\n\t} else {\n\t\tbase->command\t= be32_to_cpu(base->command);\n\t\tbase->seqnum\t= be32_to_cpu(base->seqnum);\n\t\tbase->devid\t= be32_to_cpu(base->devid);\n\t\tbase->direction\t= be32_to_cpu(base->direction);\n\t\tbase->ep\t= be32_to_cpu(base->ep);\n\t}\n}\n\nstatic void correct_endian_cmd_submit(struct usbip_header_cmd_submit *pdu,\n\t\t\t\t      int send)\n{\n\tif (send) {\n\t\tpdu->transfer_flags = cpu_to_be32(pdu->transfer_flags);\n\n\t\tcpu_to_be32s(&pdu->transfer_buffer_length);\n\t\tcpu_to_be32s(&pdu->start_frame);\n\t\tcpu_to_be32s(&pdu->number_of_packets);\n\t\tcpu_to_be32s(&pdu->interval);\n\t} else {\n\t\tpdu->transfer_flags = be32_to_cpu(pdu->transfer_flags);\n\n\t\tbe32_to_cpus(&pdu->transfer_buffer_length);\n\t\tbe32_to_cpus(&pdu->start_frame);\n\t\tbe32_to_cpus(&pdu->number_of_packets);\n\t\tbe32_to_cpus(&pdu->interval);\n\t}\n}\n\nstatic void correct_endian_ret_submit(struct usbip_header_ret_submit *pdu,\n\t\t\t\t      int send)\n{\n\tif (send) {\n\t\tcpu_to_be32s(&pdu->status);\n\t\tcpu_to_be32s(&pdu->actual_length);\n\t\tcpu_to_be32s(&pdu->start_frame);\n\t\tcpu_to_be32s(&pdu->number_of_packets);\n\t\tcpu_to_be32s(&pdu->error_count);\n\t} else {\n\t\tbe32_to_cpus(&pdu->status);\n\t\tbe32_to_cpus(&pdu->actual_length);\n\t\tbe32_to_cpus(&pdu->start_frame);\n\t\tbe32_to_cpus(&pdu->number_of_packets);\n\t\tbe32_to_cpus(&pdu->error_count);\n\t}\n}\n\nstatic void correct_endian_cmd_unlink(struct usbip_header_cmd_unlink *pdu,\n\t\t\t\t      int send)\n{\n\tif (send)\n\t\tpdu->seqnum = cpu_to_be32(pdu->seqnum);\n\telse\n\t\tpdu->seqnum = be32_to_cpu(pdu->seqnum);\n}\n\nstatic void correct_endian_ret_unlink(struct usbip_header_ret_unlink *pdu,\n\t\t\t\t      int send)\n{\n\tif (send)\n\t\tcpu_to_be32s(&pdu->status);\n\telse\n\t\tbe32_to_cpus(&pdu->status);\n}\n\nvoid usbip_header_correct_endian(struct usbip_header *pdu, int send)\n{\n\t__u32 cmd = 0;\n\n\tif (send)\n\t\tcmd = pdu->base.command;\n\n\tcorrect_endian_basic(&pdu->base, send);\n\n\tif (!send)\n\t\tcmd = pdu->base.command;\n\n\tswitch (cmd) {\n\tcase USBIP_CMD_SUBMIT:\n\t\tcorrect_endian_cmd_submit(&pdu->u.cmd_submit, send);\n\t\tbreak;\n\tcase USBIP_RET_SUBMIT:\n\t\tcorrect_endian_ret_submit(&pdu->u.ret_submit, send);\n\t\tbreak;\n\tcase USBIP_CMD_UNLINK:\n\t\tcorrect_endian_cmd_unlink(&pdu->u.cmd_unlink, send);\n\t\tbreak;\n\tcase USBIP_RET_UNLINK:\n\t\tcorrect_endian_ret_unlink(&pdu->u.ret_unlink, send);\n\t\tbreak;\n\tdefault:\n\t\t/* NOT REACHED */\n\t\tpr_err(\"unknown command\\n\");\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(usbip_header_correct_endian);\n\nstatic void usbip_iso_packet_correct_endian(\n\t\tstruct usbip_iso_packet_descriptor *iso, int send)\n{\n\t/* does not need all members. but copy all simply. */\n\tif (send) {\n\t\tiso->offset\t= cpu_to_be32(iso->offset);\n\t\tiso->length\t= cpu_to_be32(iso->length);\n\t\tiso->status\t= cpu_to_be32(iso->status);\n\t\tiso->actual_length = cpu_to_be32(iso->actual_length);\n\t} else {\n\t\tiso->offset\t= be32_to_cpu(iso->offset);\n\t\tiso->length\t= be32_to_cpu(iso->length);\n\t\tiso->status\t= be32_to_cpu(iso->status);\n\t\tiso->actual_length = be32_to_cpu(iso->actual_length);\n\t}\n}\n\nstatic void usbip_pack_iso(struct usbip_iso_packet_descriptor *iso,\n\t\t\t   struct usb_iso_packet_descriptor *uiso, int pack)\n{\n\tif (pack) {\n\t\tiso->offset\t\t= uiso->offset;\n\t\tiso->length\t\t= uiso->length;\n\t\tiso->status\t\t= uiso->status;\n\t\tiso->actual_length\t= uiso->actual_length;\n\t} else {\n\t\tuiso->offset\t\t= iso->offset;\n\t\tuiso->length\t\t= iso->length;\n\t\tuiso->status\t\t= iso->status;\n\t\tuiso->actual_length\t= iso->actual_length;\n\t}\n}\n\n/* must free buffer */\nstruct usbip_iso_packet_descriptor*\nusbip_alloc_iso_desc_pdu(struct urb *urb, ssize_t *bufflen)\n{\n\tstruct usbip_iso_packet_descriptor *iso;\n\tint np = urb->number_of_packets;\n\tssize_t size = np * sizeof(*iso);\n\tint i;\n\n\tiso = kzalloc(size, GFP_KERNEL);\n\tif (!iso)\n\t\treturn NULL;\n\n\tfor (i = 0; i < np; i++) {\n\t\tusbip_pack_iso(&iso[i], &urb->iso_frame_desc[i], 1);\n\t\tusbip_iso_packet_correct_endian(&iso[i], 1);\n\t}\n\n\t*bufflen = size;\n\n\treturn iso;\n}\nEXPORT_SYMBOL_GPL(usbip_alloc_iso_desc_pdu);\n\n/* some members of urb must be substituted before. */\nint usbip_recv_iso(struct usbip_device *ud, struct urb *urb)\n{\n\tvoid *buff;\n\tstruct usbip_iso_packet_descriptor *iso;\n\tint np = urb->number_of_packets;\n\tint size = np * sizeof(*iso);\n\tint i;\n\tint ret;\n\tint total_length = 0;\n\n\tif (!usb_pipeisoc(urb->pipe))\n\t\treturn 0;\n\n\t/* my Bluetooth dongle gets ISO URBs which are np = 0 */\n\tif (np == 0)\n\t\treturn 0;\n\n\tbuff = kzalloc(size, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\tret = usbip_recv(ud->tcp_socket, buff, size);\n\tif (ret != size) {\n\t\tdev_err(&urb->dev->dev, \"recv iso_frame_descriptor, %d\\n\",\n\t\t\tret);\n\t\tkfree(buff);\n\n\t\tif (ud->side == USBIP_STUB)\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\telse\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\n\t\treturn -EPIPE;\n\t}\n\n\tiso = (struct usbip_iso_packet_descriptor *) buff;\n\tfor (i = 0; i < np; i++) {\n\t\tusbip_iso_packet_correct_endian(&iso[i], 0);\n\t\tusbip_pack_iso(&iso[i], &urb->iso_frame_desc[i], 0);\n\t\ttotal_length += urb->iso_frame_desc[i].actual_length;\n\t}\n\n\tkfree(buff);\n\n\tif (total_length != urb->actual_length) {\n\t\tdev_err(&urb->dev->dev,\n\t\t\t\"total length of iso packets %d not equal to actual length of buffer %d\\n\",\n\t\t\ttotal_length, urb->actual_length);\n\n\t\tif (ud->side == USBIP_STUB)\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\telse\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\n\t\treturn -EPIPE;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usbip_recv_iso);\n\n/*\n * This functions restores the padding which was removed for optimizing\n * the bandwidth during transfer over tcp/ip\n *\n * buffer and iso packets need to be stored and be in propeper endian in urb\n * before calling this function\n */\nvoid usbip_pad_iso(struct usbip_device *ud, struct urb *urb)\n{\n\tint np = urb->number_of_packets;\n\tint i;\n\tint actualoffset = urb->actual_length;\n\n\tif (!usb_pipeisoc(urb->pipe))\n\t\treturn;\n\n\t/* if no packets or length of data is 0, then nothing to unpack */\n\tif (np == 0 || urb->actual_length == 0)\n\t\treturn;\n\n\t/*\n\t * if actual_length is transfer_buffer_length then no padding is\n\t * present.\n\t */\n\tif (urb->actual_length == urb->transfer_buffer_length)\n\t\treturn;\n\n\t/*\n\t * loop over all packets from last to first (to prevent overwritting\n\t * memory when padding) and move them into the proper place\n\t */\n\tfor (i = np-1; i > 0; i--) {\n\t\tactualoffset -= urb->iso_frame_desc[i].actual_length;\n\t\tmemmove(urb->transfer_buffer + urb->iso_frame_desc[i].offset,\n\t\t\turb->transfer_buffer + actualoffset,\n\t\t\turb->iso_frame_desc[i].actual_length);\n\t}\n}\nEXPORT_SYMBOL_GPL(usbip_pad_iso);\n\n/* some members of urb must be substituted before. */\nint usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)\n{\n\tint ret;\n\tint size;\n\n\tif (ud->side == USBIP_STUB) {\n\t\t/* the direction of urb must be OUT. */\n\t\tif (usb_pipein(urb->pipe))\n\t\t\treturn 0;\n\n\t\tsize = urb->transfer_buffer_length;\n\t} else {\n\t\t/* the direction of urb must be IN. */\n\t\tif (usb_pipeout(urb->pipe))\n\t\t\treturn 0;\n\n\t\tsize = urb->actual_length;\n\t}\n\n\t/* no need to recv xbuff */\n\tif (!(size > 0))\n\t\treturn 0;\n\n\tif (size > urb->transfer_buffer_length) {\n\t\t/* should not happen, probably malicious packet */\n\t\tif (ud->side == USBIP_STUB) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\n\tret = usbip_recv(ud->tcp_socket, urb->transfer_buffer, size);\n\tif (ret != size) {\n\t\tdev_err(&urb->dev->dev, \"recv xbuf, %d\\n\", ret);\n\t\tif (ud->side == USBIP_STUB) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\t} else {\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usbip_recv_xbuff);\n\nstatic int __init usbip_core_init(void)\n{\n\tpr_info(DRIVER_DESC \" v\" USBIP_VERSION \"\\n\");\n\treturn 0;\n}\n\nstatic void __exit usbip_core_exit(void)\n{\n\treturn;\n}\n\nmodule_init(usbip_core_init);\nmodule_exit(usbip_core_exit);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(USBIP_VERSION);\n"], "filenames": ["drivers/usb/usbip/usbip_common.c"], "buggy_code_start_loc": [743], "buggy_code_end_loc": [743], "fixing_code_start_loc": [744], "fixing_code_end_loc": [755], "type": "CWE-119", "message": "The usbip_recv_xbuff function in drivers/usb/usbip/usbip_common.c in the Linux kernel before 4.5.3 allows remote attackers to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via a crafted length value in a USB/IP packet.", "other": {"cve": {"id": "CVE-2016-3955", "sourceIdentifier": "cve@mitre.org", "published": "2016-07-03T21:59:15.137", "lastModified": "2022-11-03T20:31:33.723", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The usbip_recv_xbuff function in drivers/usb/usbip/usbip_common.c in the Linux kernel before 4.5.3 allows remote attackers to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via a crafted length value in a USB/IP packet."}, {"lang": "es", "value": "La funci\u00f3n usbip_recv_xbuff en drivers/usb/usbip/usbip_common.c en el kernel de Linux en versiones anteriores a 4.5.3 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (escritura fuera de l\u00edmites) o posiblemente tener otro impacto no especificado a trav\u00e9s de un valor de longitud manipulado en un paquete USB/IP."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:-:*:*:*", "matchCriteriaId": "CB66DB75-2B16-4EBF-9B93-CE49D8086E41"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B6B7CAD7-9D4E-4FDB-88E3-1E583210A01F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:15.10:*:*:*:*:*:*:*", "matchCriteriaId": "E88A537F-F4D0-46B9-9E37-965233C2A355"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.80", "matchCriteriaId": "C3F06908-393B-4A56-8D8A-ACC5927425FC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3", "versionEndExcluding": "3.10.102", "matchCriteriaId": "0F147711-AD8B-484D-8393-5BCFC6C59EC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.11", "versionEndExcluding": "3.12.59", "matchCriteriaId": "584CA2EF-2339-4C1A-93C3-464EB59A2D76"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.13", "versionEndExcluding": "3.14.68", "matchCriteriaId": "DBB7351F-4242-42E0-9E68-345C83AEB5FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.18.37", "matchCriteriaId": "B55F09A2-F470-41BA-9585-40E8C1960ABA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.19", "versionEndExcluding": "4.1.28", "matchCriteriaId": "2BACB680-D42D-4EFF-9B8B-121AA348DB7A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "4.4.9", "matchCriteriaId": "0D383D96-EBCF-47EA-A479-DA86045C1C1D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.5.3", "matchCriteriaId": "159A2E6D-BE26-4EC9-9346-1E5F3B6B5D36"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=b348d7dddb6c4fbfc810b7a0626e8ec9e29f7cbb", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-06/msg00044.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2016/dsa-3607", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.5.3", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/04/19/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/86534", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-2989-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2996-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2997-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2998-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-3000-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-3001-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-3002-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-3003-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-3004-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1328478", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/b348d7dddb6c4fbfc810b7a0626e8ec9e29f7cbb", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/b348d7dddb6c4fbfc810b7a0626e8ec9e29f7cbb"}}