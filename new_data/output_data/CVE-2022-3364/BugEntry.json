{"buggy_code": ["# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport logging\n\nimport cherrypy\nimport humanfriendly\nfrom wtforms import validators, widgets\nfrom wtforms.fields import Field, HiddenField, PasswordField, SelectField, StringField\nfrom wtforms.fields.html5 import EmailField\n\nfrom rdiffweb.controller import Controller, flash\nfrom rdiffweb.controller.form import CherryForm\nfrom rdiffweb.core.model import UserObject\nfrom rdiffweb.tools.i18n import gettext_lazy as _\n\n# Define the logger\nlogger = logging.getLogger(__name__)\n\n# Max root directory path length\nMAX_PATH = 260\n\n\nclass SizeField(Field):\n    \"\"\"\n    A text field which stores a file size as GiB or GB format.\n    \"\"\"\n\n    widget = widgets.TextInput()\n\n    def __init__(self, label=None, validators=None, **kwargs):\n        super(SizeField, self).__init__(label, validators, **kwargs)\n\n    def _value(self):\n        if self.raw_data:\n            return ' '.join(self.raw_data)\n        else:\n            return self.data and humanfriendly.format_size(self.data, binary=True) or ''\n\n    def process_formdata(self, valuelist):\n        if valuelist:\n            value_str = ''.join(valuelist)\n            # parse_size doesn't handle locales.this mean we need to\n            # replace ',' by '.' to get parse and prefix number with 0\n            value_str = value_str.replace(',', '.').strip()\n            # a value must start with a number.\n            if value_str.startswith('.'):\n                value_str = '0' + value_str\n            try:\n                self.data = humanfriendly.parse_size(value_str)\n            except humanfriendly.InvalidSize:\n                self.data = None\n                raise ValueError(self.gettext('Not a valid file size value'))\n\n\nclass UserForm(CherryForm):\n    userid = HiddenField(_('UserID'))\n    username = StringField(\n        _('Username'),\n        validators=[\n            validators.data_required(),\n            validators.length(max=256, message=_('Username too long.')),\n        ],\n    )\n    fullname = StringField(_('Fullname'), validators=[validators.optional()])\n    email = EmailField(\n        _('Email'),\n        validators=[\n            validators.optional(),\n            validators.length(max=256, message=_('Email too long.')),\n        ],\n    )\n    password = PasswordField(\n        _('Password'),\n        validators=[validators.optional()],\n        description=_('To create an LDAP user, you must leave the password empty.'),\n    )\n    mfa = SelectField(\n        _('Two-Factor Authentication (2FA)'),\n        coerce=int,\n        choices=[\n            (UserObject.DISABLED_MFA, _(\"Disabled\")),\n            (UserObject.ENABLED_MFA, _(\"Enabled\")),\n        ],\n        default=UserObject.DISABLED_MFA,\n        description=_(\n            \"When Two-Factor Authentication (2FA) is enabled for a user, a verification code get sent by email when user login from a new location.\"\n        ),\n        render_kw={'data-beta': 1},\n    )\n    user_root = StringField(\n        _('Root directory'),\n        description=_(\"Absolute path defining the location of the repositories for this user.\"),\n        validators=[\n            validators.length(max=MAX_PATH, message=_('Root directory too long.')),\n        ],\n    )\n    role = SelectField(\n        _('User Role'),\n        coerce=int,\n        choices=[\n            (UserObject.ADMIN_ROLE, _(\"Admin\")),\n            (UserObject.MAINTAINER_ROLE, _(\"Maintainer\")),\n            (UserObject.USER_ROLE, _(\"User\")),\n        ],\n        default=UserObject.USER_ROLE,\n        description=_(\n            \"Admin: may browse and delete everything. Maintainer: may browse and delete their own repo. User: may only browser their own repo.\"\n        ),\n    )\n    disk_quota = SizeField(\n        _('Disk space'),\n        validators=[validators.optional()],\n        description=_(\"Users disk spaces (in bytes). Set to 0 to remove quota (unlimited).\"),\n    )\n    disk_usage = SizeField(\n        _('Quota Used'),\n        validators=[validators.optional()],\n        description=_(\"Disk spaces (in bytes) used by this user.\"),\n        widget=widgets.HiddenInput(),\n    )\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        cfg = cherrypy.tree.apps[''].cfg\n        self.password.validators += [\n            validators.length(\n                min=cfg.password_min_length,\n                max=cfg.password_max_length,\n                message=_('Password must have between %(min)d and %(max)d characters.'),\n            )\n        ]\n\n    def validate_role(self, field):\n        # Don't allow the user to changes it's \"role\" state.\n        currentuser = cherrypy.request.currentuser\n        if self.username.data == currentuser.username and self.role.data != currentuser.role:\n            raise ValueError(_('Cannot edit your own role.'))\n\n    def validate_mfa(self, field):\n        # Don't allow the user to changes it's \"mfa\" state.\n        currentuser = cherrypy.request.currentuser\n        if self.username.data == currentuser.username and self.mfa.data != currentuser.mfa:\n            raise ValueError(_('Cannot change your own two-factor authentication settings.'))\n\n    def populate_obj(self, userobj):\n        # Save password if defined\n        if self.password.data:\n            userobj.set_password(self.password.data, old_password=None)\n        userobj.role = self.role.data\n        userobj.fullname = self.fullname.data or ''\n        userobj.email = self.email.data or ''\n        userobj.user_root = self.user_root.data\n        if self.mfa.data and not userobj.email:\n            flash(_(\"User email is required to enabled Two-Factor Authentication\"), level='error')\n        else:\n            userobj.mfa = self.mfa.data\n        if not userobj.valid_user_root():\n            flash(_(\"User's root directory %s is not accessible!\") % userobj.user_root, level='error')\n            logger.warning(\"user's root directory %s is not accessible\" % userobj.user_root)\n        else:\n            userobj.refresh_repos(delete=True)\n        # Try to update disk quota if the human readable value changed.\n        # Report error using flash.\n        new_quota = self.disk_quota.data or 0\n        old_quota = humanfriendly.parse_size(humanfriendly.format_size(self.disk_quota.object_data or 0, binary=True))\n        if old_quota != new_quota:\n            userobj.disk_quota = new_quota\n            # Setting quota will silently fail. Check if quota was updated.\n            if userobj.disk_quota != new_quota:\n                flash(_(\"Setting user's quota is not supported\"), level='warning')\n\n\nclass EditUserForm(UserForm):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        # Make username field read-only\n        self.username.render_kw = {'readonly': True}\n        self.username.populate_obj = lambda *args, **kwargs: None\n\n\nclass DeleteUserForm(CherryForm):\n    username = StringField(_('Username'), validators=[validators.data_required()])\n\n\n@cherrypy.tools.is_admin()\nclass AdminUsersPage(Controller):\n    \"\"\"Administration pages. Allow to manage users database.\"\"\"\n\n    def _delete_user(self, action, form):\n        assert action == 'delete'\n        assert form\n        # Validate form.\n        if not form.validate():\n            flash(form.error_message, level='error')\n            return\n        if form.username.data == self.app.currentuser.username:\n            flash(_(\"You cannot remove your own account!\"), level='error')\n        else:\n            try:\n                user = UserObject.get_user(form.username.data)\n                if user:\n                    user.delete()\n                    flash(_(\"User account removed.\"))\n                else:\n                    flash(_(\"User doesn't exists!\"), level='warning')\n            except ValueError as e:\n                flash(e, level='error')\n\n    @cherrypy.expose\n    def default(self, username=None, action=u\"\", **kwargs):\n\n        # If we're just showing the initial page, just do that\n        if action == \"add\":\n            form = UserForm()\n            if form.validate_on_submit():\n                try:\n                    user = UserObject.add_user(username)\n                    form.populate_obj(user)\n                    flash(_(\"User added successfully.\"))\n                except Exception as e:\n                    flash(str(e), level='error')\n            else:\n                flash(form.error_message, level='error')\n        elif action == \"edit\":\n            user = UserObject.get_user(username)\n            if user:\n                form = EditUserForm(obj=user)\n                if form.validate_on_submit():\n                    try:\n                        form.populate_obj(user)\n                        flash(_(\"User information modified successfully.\"))\n                    except Exception as e:\n                        flash(str(e), level='error')\n                else:\n                    flash(form.error_message, level='error')\n            else:\n                flash(_(\"Cannot edit user `%s`: user doesn't exists\") % username, level='error')\n        elif action == 'delete':\n            form = DeleteUserForm()\n            if form.validate_on_submit():\n                self._delete_user(action, form)\n\n        params = {\n            \"add_form\": UserForm(formdata=None),\n            \"edit_form\": EditUserForm(formdata=None),\n            \"users\": UserObject.query.all(),\n        }\n\n        # Build users page\n        return self._compile_template(\"admin_users.html\", **params)\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefault preference page to show general user information. It allows user\nto change password ans refresh it's repository view.\n\"\"\"\n\nimport logging\nimport re\n\nimport cherrypy\nfrom wtforms.fields import HiddenField, PasswordField, StringField, SubmitField\nfrom wtforms.fields.html5 import EmailField\nfrom wtforms.validators import DataRequired, EqualTo, InputRequired, Length, Regexp\n\nfrom rdiffweb.controller import Controller, flash\nfrom rdiffweb.controller.form import CherryForm\nfrom rdiffweb.tools.i18n import gettext_lazy as _\n\n# Define the logger\n_logger = logging.getLogger(__name__)\n\nPATTERN_EMAIL = re.compile(r'[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$')\n\n\nclass UserProfileForm(CherryForm):\n    action = HiddenField(default='set_profile_info')\n    username = StringField(_('Username'), render_kw={'readonly': True})\n    fullname = StringField(_('Fullname'))\n    email = EmailField(\n        _('Email'),\n        validators=[\n            DataRequired(),\n            Length(max=256, message=_(\"Invalid email.\")),\n            Regexp(PATTERN_EMAIL, message=_(\"Invalid email.\")),\n        ],\n    )\n    set_profile_info = SubmitField(_('Save changes'))\n\n    def is_submitted(self):\n        # Validate only if action is set_profile_info\n        return super().is_submitted() and self.action.data == 'set_profile_info'\n\n    def populate_obj(self, user):\n        user.fullname = self.fullname.data\n        user.email = self.email.data\n        user.add()\n\n\nclass UserPasswordForm(CherryForm):\n    action = HiddenField(default='set_password')\n    current = PasswordField(\n        _('Current password'),\n        validators=[InputRequired(_(\"Current password is missing.\"))],\n        description=_(\"You must provide your current password in order to change it.\"),\n    )\n    new = PasswordField(\n        _('New password'),\n        validators=[\n            InputRequired(_(\"New password is missing.\")),\n            EqualTo('confirm', message=_(\"The new password and its confirmation do not match.\")),\n        ],\n    )\n    confirm = PasswordField(\n        _('Confirm new password'), validators=[InputRequired(_(\"Confirmation password is missing.\"))]\n    )\n    set_password = SubmitField(_('Update password'))\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.new.validators += [\n            Length(\n                min=self.app.cfg.password_min_length,\n                max=self.app.cfg.password_max_length,\n                message=_('Password must have between %(min)d and %(max)d characters.'),\n            )\n        ]\n\n    @property\n    def app(self):\n        return cherrypy.request.app\n\n    def is_submitted(self):\n        # Validate only if action is set_profile_info\n        return super().is_submitted() and self.action.data == 'set_password'\n\n    def populate_obj(self, user):\n        try:\n            user.set_password(self.new.data, old_password=self.current.data)\n            flash(_(\"Password updated successfully.\"), level='success')\n        except ValueError as e:\n            flash(str(e), level='warning')\n\n\nclass RefreshForm(CherryForm):\n    action = HiddenField(default='update_repos')\n    update_repos = SubmitField(\n        _('Refresh repositories'),\n        description=_(\n            \"Refresh the list of repositories associated to your account. If you recently add a new repository and it doesn't show, you may try to refresh the list.\"\n        ),\n    )\n\n    def is_submitted(self):\n        # Validate only if action is set_profile_info\n        return super().is_submitted() and self.action.data == 'update_repos'\n\n    def populate_obj(self, user):\n        try:\n            user.refresh_repos(delete=True)\n            flash(_(\"Repositories successfully updated\"), level='success')\n        except ValueError as e:\n            flash(str(e), level='warning')\n\n\nclass PagePrefsGeneral(Controller):\n    \"\"\"\n    Plugin to change user profile and password.\n    \"\"\"\n\n    @cherrypy.expose\n    def default(self, **kwargs):\n        # Process the parameters.\n        profile_form = UserProfileForm(obj=self.app.currentuser)\n        password_form = UserPasswordForm()\n        refresh_form = RefreshForm()\n        if profile_form.is_submitted():\n            if profile_form.validate():\n                profile_form.populate_obj(self.app.currentuser)\n                flash(_(\"Profile updated successfully.\"), level='success')\n            else:\n                flash(profile_form.error_message, level='error')\n        elif password_form.is_submitted():\n            if password_form.validate():\n                password_form.populate_obj(self.app.currentuser)\n            else:\n                flash(password_form.error_message, level='error')\n        elif refresh_form.is_submitted():\n            if refresh_form.validate():\n                refresh_form.populate_obj(self.app.currentuser)\n            else:\n                flash(refresh_form.error_message, level='error')\n        params = {\n            'profile_form': profile_form,\n            'password_form': password_form,\n            'refresh_form': refresh_form,\n        }\n        return self._compile_template(\"prefs_general.html\", **params)\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\nimport logging\n\nimport cherrypy\nfrom wtforms.fields import DateField, HiddenField, StringField, SubmitField\nfrom wtforms.validators import DataRequired, Optional\n\nfrom rdiffweb.controller import Controller, flash\nfrom rdiffweb.controller.filter_authorization import is_maintainer\nfrom rdiffweb.controller.form import CherryForm\nfrom rdiffweb.core.model import Token\nfrom rdiffweb.tools.i18n import gettext_lazy as _\n\nlogger = logging.getLogger(__name__)\n\n\nclass TokenForm(CherryForm):\n    action = HiddenField(default='add_access_token')\n    name = StringField(\n        _('Token name'),\n        description=_(\n            'Used only to identify the purpose of the token. For example, the application that uses the token.'\n        ),\n        validators=[DataRequired()],\n    )\n    expiration = DateField(\n        _('Expiration date'),\n        description=_(\n            'Allows the creation of a temporary token by defining an expiration date. Leave empty to keep the token forever.'\n        ),\n        render_kw={\n            \"placeholder\": _('YYYY-MM-DD'),\n        },\n        validators=[Optional()],\n    )\n    submit = SubmitField(_('Create access token'))\n\n    def is_submitted(self):\n        # Validate only if action is set_profile_info\n        return super().is_submitted() and self.action.data == 'add_access_token'\n\n    def populate_obj(self, userobj):\n        try:\n            token = userobj.add_access_token(self.name.data, self.expiration.data)\n            flash(\n                _(\n                    \"Your new personal access token has been created.\\n\"\n                    \"Make sure to save it - you won't be able to access it again.\\n\"\n                    \"%s\"\n                )\n                % token,\n                level='info',\n            )\n        except ValueError as e:\n            flash(str(e), level='warning')\n        except Exception:\n            logger.exception(\"error adding access token: %s, %s\" % (self.name.data, self.expiration.data))\n            flash(_(\"Unknown error while adding the access token.\"), level='error')\n\n\nclass DeleteTokenForm(CherryForm):\n    action = HiddenField(default='delete_access_token')\n    name = StringField(validators=[DataRequired()])\n\n    def is_submitted(self):\n        # Validate only if action is set_profile_info\n        return super().is_submitted() and self.action.data == 'delete_access_token'\n\n    def populate_obj(self, userobj):\n        is_maintainer()\n        try:\n            userobj.delete_access_token(self.name.data)\n            flash(_('The access token has been successfully deleted.'), level='success')\n        except ValueError as e:\n            flash(str(e), level='warning')\n        except Exception:\n            logger.exception(\"error removing access token: %s\" % self.name.data)\n            flash(_(\"Unknown error while removing the access token.\"), level='error')\n\n\nclass PagePrefTokens(Controller):\n    @cherrypy.expose\n    def default(self, action=None, **kwargs):\n        form = TokenForm()\n        delete_form = DeleteTokenForm()\n        if form.is_submitted():\n            if form.validate():\n                form.populate_obj(self.app.currentuser)\n            else:\n                flash(form.error_message, level='error')\n        elif delete_form.is_submitted():\n            if delete_form.validate():\n                delete_form.populate_obj(self.app.currentuser)\n            else:\n                flash(delete_form.error_message, level='error')\n        params = {\n            'form': form,\n            'tokens': Token.query.filter(Token.userid == self.app.currentuser.userid),\n        }\n        return self._compile_template(\"prefs_tokens.html\", **params)\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom unittest.mock import ANY, MagicMock\n\nimport cherrypy\n\nimport rdiffweb.test\nfrom rdiffweb.core.model import UserObject\n\n\nclass AbstractAdminTest(rdiffweb.test.WebCase):\n\n    login = True\n\n    def setUp(self):\n        super().setUp()\n        self._quota = {}\n        self.listener = MagicMock()\n        cherrypy.engine.subscribe('user_added', self.listener.user_added, priority=50)\n        cherrypy.engine.subscribe('user_attr_changed', self.listener.user_attr_changed, priority=50)\n        cherrypy.engine.subscribe('user_deleted', self.listener.user_deleted, priority=50)\n        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)\n        self.listener.get_disk_quota.side_effect = self._load_quota\n        cherrypy.engine.subscribe('get_disk_quota', self.listener.get_disk_quota, priority=40)\n        self.listener.get_disk_usage.return_value = 0\n        cherrypy.engine.subscribe('get_disk_usage', self.listener.get_disk_usage, priority=40)\n        self.listener.set_disk_quota.side_effect = self._store_quota\n        cherrypy.engine.subscribe('set_disk_quota', self.listener.set_disk_quota, priority=40)\n\n    def tearDown(self):\n        cherrypy.engine.unsubscribe('user_added', self.listener.user_added)\n        cherrypy.engine.unsubscribe('user_attr_changed', self.listener.user_attr_changed)\n        cherrypy.engine.unsubscribe('user_deleted', self.listener.user_deleted)\n        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)\n        cherrypy.engine.unsubscribe('get_disk_quota', self.listener.get_disk_quota)\n        cherrypy.engine.unsubscribe('get_disk_usage', self.listener.get_disk_usage)\n        cherrypy.engine.unsubscribe('set_disk_quota', self.listener.set_disk_quota)\n        return super().tearDown()\n\n    def _store_quota(self, userobj, value):\n        self._quota[userobj.username] = value\n\n    def _load_quota(self, userobj):\n        return self._quota.get(userobj.username, 0)\n\n    def _add_user(self, username=None, email=None, password=None, user_root=None, role=None, mfa=None):\n        b = {}\n        b['action'] = 'add'\n        if username is not None:\n            b['username'] = username\n        if email is not None:\n            b['email'] = email\n        if password is not None:\n            b['password'] = password\n        if user_root is not None:\n            b['user_root'] = user_root\n        if role is not None:\n            b['role'] = str(role)\n        if mfa is not None:\n            b['mfa'] = str(mfa)\n        self.getPage(\"/admin/users/\", method='POST', body=b)\n\n    def _edit_user(\n        self, username=None, email=None, password=None, user_root=None, role=None, disk_quota=None, mfa=None\n    ):\n        b = {}\n        b['action'] = 'edit'\n        if username is not None:\n            b['username'] = username\n        if email is not None:\n            b['email'] = email\n        if password is not None:\n            b['password'] = password\n        if user_root is not None:\n            b['user_root'] = user_root\n        if role is not None:\n            b['role'] = str(role)\n        if disk_quota is not None:\n            b['disk_quota'] = disk_quota\n        if mfa is not None:\n            b['mfa'] = str(mfa)\n        self.getPage(\"/admin/users/\", method='POST', body=b)\n\n    def _delete_user(self, username='test1'):\n        b = {'action': 'delete', 'username': username}\n        self.getPage(\"/admin/users/\", method='POST', body=b)\n\n    def test_add_user_with_role_admin(self):\n        # When trying to create a new user with role admin\n        self._add_user(\"admin_role\", \"admin_role@test.com\", \"password\", \"/home/\", UserObject.ADMIN_ROLE)\n        # Then page return success\n        self.assertStatus(200)\n        # Then database is updated\n        userobj = UserObject.get_user('admin_role')\n        self.assertEqual(UserObject.ADMIN_ROLE, userobj.role)\n        # Then notification was raised\n        self.listener.user_added.assert_called_once_with(userobj)\n\n    def test_add_user_with_role_maintainer(self):\n        self._add_user(\"maintainer_role\", \"maintainer_role@test.com\", \"password\", \"/home/\", UserObject.MAINTAINER_ROLE)\n        self.assertStatus(200)\n        self.assertEqual(UserObject.MAINTAINER_ROLE, UserObject.get_user('maintainer_role').role)\n\n    def test_add_user_with_role_user(self):\n        self._add_user(\"user_role\", \"user_role@test.com\", \"password\", \"/home/\", UserObject.USER_ROLE)\n        self.assertStatus(200)\n        self.assertEqual(UserObject.USER_ROLE, UserObject.get_user('user_role').role)\n\n    def test_add_user_with_invalid_role(self):\n        # When trying to create a new user with an invalid role (admin instead of 0)\n        self._add_user(\"invalid\", \"invalid@test.com\", \"password\", \"/home/\", 'admin')\n        # Then an error message is displayed to the user\n        self.assertStatus(200)\n        self.assertInBody('Role: Invalid Choice: could not coerce')\n        # Then listener are not called\n        self.listener.user_added.assert_not_called()\n\n        # When trying to create a new user with an invalid role (-1)\n        self._add_user(\"invalid\", \"invalid@test.com\", \"password\", \"/home/\", -1)\n        # Then an error message is displayed to the user\n        self.assertStatus(200)\n        self.assertInBody('User Role: Not a valid choice')\n        # Then listener are not called\n        self.listener.user_added.assert_not_called()\n\n    def test_add_edit_delete(self):\n        #  Add user to be listed\n        self.listener.user_password_changed.reset_mock()\n        self._add_user(\n            \"test2\", \"test2@test.com\", \"password\", \"/home/\", UserObject.USER_ROLE, mfa=UserObject.DISABLED_MFA\n        )\n        self.assertInBody(\"User added successfully.\")\n        self.assertInBody(\"test2\")\n        self.assertInBody(\"test2@test.com\")\n        self.listener.user_added.assert_called_once()\n        self.listener.user_password_changed.assert_called_once()\n        self.listener.user_password_changed.reset_mock()\n        #  Update user\n        self._edit_user(\n            \"test2\", \"chaned@test.com\", \"new-password\", \"/tmp/\", UserObject.ADMIN_ROLE, mfa=UserObject.ENABLED_MFA\n        )\n        self.listener.user_attr_changed.assert_called()\n        self.listener.user_password_changed.assert_called_once()\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertInBody(\"test2\")\n        self.assertInBody(\"chaned@test.com\")\n        self.assertNotInBody(\"/home/\")\n        self.assertInBody(\"/tmp/\")\n\n        self._delete_user(\"test2\")\n        self.listener.user_deleted.assert_called()\n        self.assertStatus(200)\n        self.assertInBody(\"User account removed.\")\n        self.assertNotInBody(\"test2\")\n\n    def test_edit_fullname(self):\n        # Given an existing user\n        # When updating the user's fullname\n        self.getPage(\n            \"/admin/users/\",\n            method='POST',\n            body={'action': 'edit', 'username': self.USERNAME, 'fullname': 'My fullname'},\n        )\n        self.assertStatus(200)\n        # Then user is updated successfully\n        self.assertInBody(\"User information modified successfully.\")\n        # Then database is updated\n        obj = UserObject.query.filter(UserObject.username == self.USERNAME).first()\n        self.assertEqual('My fullname', obj.fullname)\n\n    def test_add_edit_delete_user_with_encoding(self):\n        \"\"\"\n        Check creation of user with non-ascii char.\n        \"\"\"\n        self._add_user(\"\u00c9ric\", \"\u00e9ric@test.com\", \"password\", \"/home/\", UserObject.USER_ROLE)\n        self.assertInBody(\"User added successfully.\")\n        self.assertInBody(\"\u00c9ric\")\n        self.assertInBody(\"\u00e9ric@test.com\")\n        # Update user\n        self._edit_user(\"\u00c9ric\", \"eric.l\u00e9tourno@test.com\", \"\u00e9cureuil\", \"/tmp/\", UserObject.ADMIN_ROLE)\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertInBody(\"\u00c9ric\")\n        self.assertInBody(\"eric.l\u00e9tourno@test.com\")\n        self.assertNotInBody(\"/home/\")\n        self.assertInBody(\"/tmp/\")\n\n        self._delete_user(\"\u00c9ric\")\n        self.assertInBody(\"User account removed.\")\n        self.assertNotInBody(\"\u00c9ric\")\n\n    def test_add_user_with_empty_username(self):\n        \"\"\"\n        Verify failure trying to create user without username.\n        \"\"\"\n        self._add_user(\"\", \"test1@test.com\", \"password\", \"/tmp/\", UserObject.USER_ROLE)\n        self.assertStatus(200)\n        self.assertInBody(\"Username: This field is required.\")\n\n    def test_add_user_with_existing_username(self):\n        \"\"\"\n        Verify failure trying to add the same user.\n        \"\"\"\n        # Given a user named `test1`\n        self._add_user(\"test1\", \"test1@test.com\", \"password\", \"/tmp/\", UserObject.USER_ROLE)\n        # When trying to create a new user with the same name\n        self._add_user(\"test1\", \"test1@test.com\", \"password\", \"/tmp/\", UserObject.USER_ROLE)\n        # Then the user list is displayed with an error message.\n        self.assertStatus(200)\n        self.assertInBody(\"User test1 already exists.\")\n\n    def test_add_user_with_invalid_root_directory(self):\n        \"\"\"\n        Verify failure to add a user with invalid root directory.\n        \"\"\"\n        try:\n            self._delete_user(\"test5\")\n        except Exception:\n            pass\n        self._add_user(\"test5\", \"test1@test.com\", \"password\", \"/var/invalid/\", UserObject.USER_ROLE)\n        self.assertInBody(\"User added successfully.\")\n        self.assertInBody(\"User&#39;s root directory /var/invalid/ is not accessible!\")\n\n    def test_add_without_email(self):\n        #  Add user to be listed\n        self._add_user(\"test2\", None, \"password\", \"/tmp/\", UserObject.USER_ROLE)\n        self.assertInBody(\"User added successfully.\")\n\n    def test_add_without_user_root(self):\n        #  Add user to be listed\n        self._add_user(\"test6\", None, \"password\", None, UserObject.USER_ROLE)\n        self.assertInBody(\"User added successfully.\")\n\n        user = UserObject.get_user('test6')\n        self.assertEqual('', user.user_root)\n\n    def test_add_with_username_too_long(self):\n        # Given a too long username\n        username = \"test2\" * 52\n        # When trying to create the user\n        self._add_user(username, None, \"password\", \"/tmp/\", UserObject.USER_ROLE)\n        # Then an error is raised\n        self.assertStatus(200)\n        self.assertInBody(\"Username too long.\")\n\n    def test_add_with_email_too_long(self):\n        # Given a too long username\n        email = (\"test2\" * 50) + \"@test.com\"\n        # When trying to create the user\n        self._add_user(\"test2\", email, \"password\", \"/tmp/\", UserObject.USER_ROLE)\n        # Then an error is raised\n        self.assertStatus(200)\n        self.assertInBody(\"Email too long.\")\n\n    def test_add_with_user_root_too_long(self):\n        # Given a too long user root\n        user_root = \"/temp/\" * 50\n        # When trying to create the user\n        self._add_user(\"test2\", \"test@test,com\", \"password\", user_root, UserObject.USER_ROLE)\n        # Then an error is raised\n        self.assertStatus(200)\n        self.assertInBody(\"Root directory too long.\")\n\n    def test_delete_user_with_not_existing_username(self):\n        \"\"\"\n        Verify failure to delete invalid username.\n        \"\"\"\n        self._delete_user(\"test3\")\n        self.assertInBody(\"User doesn&#39;t exists!\")\n\n    def test_delete_our_self(self):\n        \"\"\"\n        Verify failure to delete our self.\n        \"\"\"\n        self._delete_user(self.USERNAME)\n        self.assertInBody(\"You cannot remove your own account!\")\n\n    def test_delete_user_admin(self):\n        \"\"\"\n        Verify failure to delete our self.\n        \"\"\"\n        # Create another admin user\n        self._add_user('admin2', '', 'password', '', UserObject.ADMIN_ROLE)\n        self.getPage(\"/logout\")\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n        self._login('admin2', 'password')\n\n        # Try deleting admin user\n        self._delete_user(self.USERNAME)\n        self.assertStatus(200)\n        self.assertInBody(\"can&#39;t delete admin user\")\n\n    def test_delete_user_method_get(self):\n        # Given a user\n        UserObject.add_user('newuser')\n        # When trying to delete this user using method GET\n        self.getPage(\"/admin/users/?action=delete&username=newuser\", method='GET')\n        # Then page return without error\n        self.assertStatus(200)\n        # Then user is not deleted\n        self.assertIsNotNone(UserObject.get_user('newuser'))\n\n    def test_change_password_with_too_short(self):\n        self._edit_user(self.USERNAME, password='short')\n        self.assertInBody(\"Password must have between 8 and 128 characters.\")\n\n    def test_change_password_with_too_long(self):\n        new_password = 'a' * 129\n        self._edit_user(self.USERNAME, password=new_password)\n        self.assertInBody(\"Password must have between 8 and 128 characters.\")\n\n    def test_change_admin_password(self):\n        # Given rdiffweb is configured with admin-password option\n        self.app.cfg.admin_password = 'hardcoded'\n        try:\n            # When trying to update admin password\n            self._edit_user('admin', password='new-password')\n            # Then the form is refused with 200 OK with an error message.\n            self.assertStatus(200)\n            self.assertInBody(\"can&#39;t update admin-password defined in configuration file\")\n        finally:\n            self.app.cfg.admin_password = None\n\n    def test_edit_user_with_invalid_path(self):\n        \"\"\"\n        Verify failure trying to update user with invalid path.\n        \"\"\"\n        UserObject.add_user('test1')\n        self._edit_user(\"test1\", \"test1@test.com\", \"password\", \"/var/invalid/\", UserObject.USER_ROLE)\n        self.assertNotInBody(\"User added successfully.\")\n        self.assertInBody(\"User&#39;s root directory /var/invalid/ is not accessible!\")\n\n    def test_list(self):\n        self.getPage(\"/admin/users/\")\n        self.assertInBody(\"Users\")\n        self.assertInBody(\"User management\")\n        self.assertInBody(\"Add user\")\n\n    def test_edit_user_with_not_existing_username(self):\n        \"\"\"\n        Verify failure trying to update invalid user.\n        \"\"\"\n        # Given an invalid username\n        username = 'invalid'\n        # When trying to edit the user\n        self._edit_user(username, \"test1@test.com\", \"test\", \"/var/invalid/\", UserObject.USER_ROLE)\n        # Then the user list is displayed with an error message\n        self.assertStatus(200)\n        self.assertInBody(\"Cannot edit user `invalid`: user doesn&#39;t exists\")\n\n    def test_user_invalid_root(self):\n        # Delete all user's\n        for user in UserObject.query.all():\n            if user.username != self.USERNAME:\n                user.delete()\n        # Change the user's root\n        user = UserObject.get_user('admin')\n        user.user_root = \"/invalid\"\n        user.add()\n        self.getPage(\"/admin/users\")\n        self.assertInBody(\"Root directory not accessible!\")\n\n        # Query the page by default\n        user = UserObject.get_user('admin')\n        user.user_root = \"/tmp/\"\n        user.add()\n        self.getPage(\"/admin/users\")\n        self.assertNotInBody(\"Root directory not accessible!\")\n\n    def test_get_quota(self):\n        # Mock a quota.\n        self.listener.get_disk_quota.side_effect = None\n        self.listener.get_disk_quota.return_value = 654321\n        # When querying the user list\n        self.getPage(\"/admin/users/\")\n        self.assertStatus(200)\n        # Then get_disk_quota listenre is called\n        self.listener.get_disk_quota.assert_called()\n        # Then the quota value is displayed in human readable format\n        self.assertInBody(\"638.99 KiB\")\n        self.assertStatus(200)\n\n    def test_set_quota(self):\n        # When updating user quota.\n        self._edit_user(\"admin\", disk_quota='8765432')\n        # Then listenr get called\n        self.listener.set_disk_quota.assert_called_once_with(ANY, 8765432)\n        # Then a success message is displayed\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertStatus(200)\n\n    def test_set_quota_as_gib(self):\n        # When updating user quota\n        self._edit_user(\"admin\", disk_quota='1GiB')\n        # Then listern get called\n        self.listener.set_disk_quota.assert_called_once_with(ANY, 1073741824)\n        # Then a success message is displayed\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertStatus(200)\n\n    def test_set_quota_as_with_comma(self):\n        # When updating quota with comma value\n        self._edit_user(\"admin\", disk_quota='1,5 GiB')\n        # Then listner get called\n        self.listener.set_disk_quota.assert_called_once_with(ANY, 1610612736)\n        # Then a success message is displayed\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertStatus(200)\n\n    def test_set_quota_as_with_leading_dot(self):\n        # When updating quota with leading dot\n        self._edit_user(\"admin\", disk_quota='.5 GiB')\n        # Then listener get called\n        self.listener.set_disk_quota.assert_called_once_with(ANY, 536870912)\n        # Then a success message is displayed\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertStatus(200)\n\n    def test_set_quota_empty(self):\n        # When quota is not defined\n        self._edit_user(\"admin\", disk_quota='')\n        # Then listener is not called.\n        self.listener.set_disk_quota.assert_not_called()\n        # Then message is not displayed\n        self.assertStatus(200)\n\n    def test_set_quota_same_value(self):\n        # Given an exiting quota\n        self.listener.get_disk_quota.side_effect = None\n        self.listener.get_disk_quota.return_value = 1234567890\n        # When setting the quota value to the same value\n        self._edit_user(\"admin\", disk_quota='1.15 GiB')\n        #  Then listener is not called\n        self.listener.set_disk_quota.assert_not_called()\n        # Then message is not displayed\n        self.assertStatus(200)\n\n    def test_set_quota_unsupported(self):\n        # Given setting quota is not supported\n        self.listener.set_disk_quota.side_effect = None\n        self.listener.set_disk_quota.return_value = None\n        # When updating the quota\n        self._edit_user(\"admin\", disk_quota='8765432')\n        # Then\n        self.listener.set_disk_quota.assert_called_once_with(ANY, 8765432)\n        self.assertInBody(\"Setting user&#39;s quota is not supported\")\n        self.assertStatus(200)\n\n    def test_edit_own_role(self):\n        # Given an administrator\n        # When trygin to update your own role\n        self._edit_user(username=self.USERNAME, role=UserObject.MAINTAINER_ROLE)\n        # Then an error is returned\n        self.assertStatus(200)\n        self.assertInBody(\"Cannot edit your own role.\")\n\n    def test_edit_own_mfa(self):\n        # Given an administrator\n        # When trygin to update your own role\n        self._edit_user(username=self.USERNAME, mfa=UserObject.ENABLED_MFA)\n        # Then an error is returned\n        self.assertStatus(200)\n        self.assertInBody(\"Cannot change your own two-factor authentication settings.\")\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nCreated on Dec 26, 2015\n\n@author: Patrik Dufresne\n\"\"\"\n\nfrom unittest.mock import MagicMock\n\nimport cherrypy\n\nimport rdiffweb.test\nfrom rdiffweb.core.model import RepoObject, UserObject\n\n\nclass PagePrefGeneralTest(rdiffweb.test.WebCase):\n\n    PREFS = \"/prefs/general\"\n\n    login = True\n\n    def setUp(self):\n        self.listener = MagicMock()\n        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)\n        return super().setUp()\n\n    def tearDown(self):\n        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)\n        return super().tearDown()\n\n    def _set_password(\n        self,\n        current,\n        new_password,\n        confirm,\n    ):\n        b = {\n            'action': 'set_password',\n            'current': current,\n            'new': new_password,\n            'confirm': confirm,\n        }\n        return self.getPage(self.PREFS, method='POST', body=b)\n\n    def _set_profile_info(self, email, fullname=None):\n        b = {\n            'action': 'set_profile_info',\n            'email': email,\n        }\n        if fullname:\n            b['fullname'] = fullname\n        return self.getPage(self.PREFS, method='POST', body=b)\n\n    def test_get_page(self):\n        # When querying the page\n        self.getPage(self.PREFS)\n        # Then the page is returned\n        self.assertStatus(200)\n        self.assertInBody('User profile')\n\n    def test_change_username_noop(self):\n        # Given an authenticated user\n        # When updating the username\n        self.getPage(\n            self.PREFS,\n            method='POST',\n            body={'action': 'set_profile_info', 'email': 'test@test.com', 'username': 'test'},\n        )\n        self.assertStatus(200)\n        self.assertInBody(\"Profile updated successfully.\")\n        # Then database is updated with fullname\n        user = UserObject.query.filter(UserObject.username == self.USERNAME).first()\n        self.assertIsNotNone(user)\n        self.assertEqual(\"test@test.com\", user.email)\n\n    def test_change_fullname(self):\n        # Given an authenticated user\n        # When update the fullname\n        self._set_profile_info(\"test@test.com\", \"My Fullname\")\n        self.assertStatus(200)\n        self.assertInBody(\"Profile updated successfully.\")\n        # Then database is updated with fullname\n        self.assertInBody(\"My Fullname\")\n        user = UserObject.query.filter(UserObject.username == self.USERNAME).first()\n        self.assertEqual(\"My Fullname\", user.fullname)\n\n    def test_change_fullname_method_get(self):\n        # Given an authenticated user\n        # When trying to update full name using GET method\n        self.getPage(self.PREFS + '?action=set_profile_info&email=test@test.com')\n        # Then nothing happen\n        self.assertStatus(200)\n        self.assertNotInBody(\"Profile updated successfully.\")\n        user = UserObject.query.filter(UserObject.username == self.USERNAME).first()\n        self.assertEqual(\"\", user.fullname)\n\n    def test_change_email(self):\n        self._set_profile_info(\"test@test.com\")\n        self.assertStatus(200)\n        self.assertInBody(\"Profile updated successfully.\")\n\n    def test_change_email_with_invalid_email(self):\n        self._set_profile_info(\"@test.com\")\n        self.assertStatus(200)\n        self.assertInBody(\"Invalid email\")\n\n        self._set_profile_info(\"test.com\")\n        self.assertStatus(200)\n        self.assertInBody(\"Invalid email\")\n\n        self._set_profile_info(\"test\")\n        self.assertStatus(200)\n        self.assertInBody(\"Invalid email\")\n\n        self._set_profile_info(\"test@te_st.com\")\n        self.assertStatus(200)\n        self.assertInBody(\"Invalid email\")\n\n        self._set_profile_info(\"test@test.com, test2@test.com\")\n        self.assertStatus(200)\n        self.assertInBody(\"Invalid email\")\n\n    def test_change_email_with_too_long(self):\n        self._set_profile_info((\"test1\" * 50) + \"@test.com\")\n        self.assertInBody(\"Invalid email\")\n\n    def test_change_password(self):\n        self.listener.user_password_changed.reset_mock()\n        # When udating user's password\n        self._set_password(self.PASSWORD, \"newpassword\", \"newpassword\")\n        self.assertInBody(\"Password updated successfully.\")\n        # Then a notification is raised\n        self.listener.user_password_changed.assert_called_once()\n        # Change it back\n        self._set_password(\"newpassword\", self.PASSWORD, self.PASSWORD)\n        self.assertInBody(\"Password updated successfully.\")\n\n    def test_change_password_with_wrong_confirmation(self):\n        self._set_password(self.PASSWORD, \"t\", \"a\")\n        self.assertInBody(\"The new password and its confirmation do not match.\")\n\n    def test_change_password_with_wrong_password(self):\n        self._set_password(\"oups\", \"newpassword\", \"newpassword\")\n        self.assertInBody(\"Wrong password\")\n\n    def test_change_password_with_too_short(self):\n        self._set_password(self.PASSWORD, \"short\", \"short\")\n        self.assertInBody(\"Password must have between 8 and 128 characters.\")\n\n    def test_change_password_with_too_long(self):\n        new_password = 'a' * 129\n        self._set_password(self.PASSWORD, new_password, new_password)\n        self.assertInBody(\"Password must have between 8 and 128 characters.\")\n\n    def test_change_password_method_get(self):\n        # Given an authenticated user\n        # Trying to update password with GET method\n        self.getPage(self.PREFS + '?action=set_password&new=newpassword&confirm=newpassword&current=' + self.PASSWORD)\n        # Then nothing happen\n        self.assertStatus(200)\n        self.assertNotInBody(\"Password updated successfully.\")\n\n    def test_invalid_pref(self):\n        \"\"\"\n        Check if invalid prefs url is 404 Not Found.\n        \"\"\"\n        self.getPage(\"/prefs/invalid/\")\n        self.assertStatus(404)\n\n    def test_update_repos(self):\n        # Given a user with invalid repositories\n        userobj = UserObject.get_user(self.USERNAME)\n        RepoObject(userid=userobj.userid, repopath='invalid').add()\n        self.assertEqual(['broker-repo', 'invalid', 'testcases'], sorted([r.name for r in userobj.repo_objs]))\n        # When updating the repository list\n        self.getPage(self.PREFS, method='POST', body={'action': 'update_repos'})\n        self.assertStatus(200)\n        # Then a success message is displayed\n        self.assertInBody('Repositories successfully updated')\n        # Then the list is free of inexisting repos.\n        userobj.expire()\n        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in userobj.repo_objs]))\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\nimport rdiffweb.test\nfrom rdiffweb.core.model import Token, UserObject\n\n\nclass PagePrefTokensTest(rdiffweb.test.WebCase):\n\n    login = True\n\n    def test_get(self):\n        # When getting the page\n        self.getPage(\"/prefs/tokens\")\n        # Then the page is return without error\n        self.assertStatus(200)\n\n    def test_add_access_token(self):\n        # Given an existing user\n        userobj = UserObject.get_user(self.USERNAME)\n        # When adding a new access token\n        self.getPage(\n            \"/prefs/tokens\",\n            method='POST',\n            body={'action': 'add_access_token', 'name': 'test-token-name', 'expiration_time': ''},\n        )\n        # Then page return without error\n        self.assertStatus(200)\n        # Then token name get displayed in the view\n        self.assertInBody('test-token-name')\n        # Then access token get created\n        self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid, Token.name == 'test-token-name').count())\n\n    def test_add_access_token_with_expiration_time(self):\n        # Given an existing user\n        userobj = UserObject.get_user(self.USERNAME)\n        # When adding a new access token\n        self.getPage(\n            \"/prefs/tokens\",\n            method='POST',\n            body={'action': 'add_access_token', 'name': 'test-token-name', 'expiration_time': '1999-01-01'},\n        )\n        # Then page return without error\n        self.assertStatus(200)\n        # Then token name get displayed in the view\n        self.assertInBody('test-token-name')\n        # Then access token get created\n        self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid, Token.name == 'test-token-name').count())\n\n    def test_add_access_token_without_name(self):\n        # Given an existing user\n        userobj = UserObject.get_user(self.USERNAME)\n        # When adding a new access token\n        self.getPage(\n            \"/prefs/tokens\",\n            method='POST',\n            body={'action': 'add_access_token', 'name': '', 'expiration_time': ''},\n        )\n        # Then page return without error\n        self.assertStatus(200)\n        # Then token name get displayed in the view\n        self.assertInBody('Token name: This field is required.')\n        # Then access token is not created\n        self.assertEqual(0, Token.query.filter(Token.userid == userobj.userid, Token.name == 'test-token-name').count())\n\n    def test_delete_access_token(self):\n        # Given an existing user with access_token\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.add_access_token('test-token-name')\n        # When deleting access token\n        self.getPage(\n            \"/prefs/tokens\",\n            method='POST',\n            body={'action': 'delete_access_token', 'name': 'test-token-name'},\n        )\n        # Then page return without error\n        self.assertStatus(200)\n        # Then token name get displayed in the view\n        self.assertInBody('The access token has been successfully deleted.')\n        # Then access token is not created\n        self.assertEqual(0, Token.query.filter(Token.userid == userobj.userid, Token.name == 'test-token-name').count())\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport logging\n\nimport cherrypy\nimport humanfriendly\nfrom wtforms import validators, widgets\nfrom wtforms.fields import Field, HiddenField, PasswordField, SelectField, StringField\nfrom wtforms.fields.html5 import EmailField\n\nfrom rdiffweb.controller import Controller, flash\nfrom rdiffweb.controller.form import CherryForm\nfrom rdiffweb.core.model import UserObject\nfrom rdiffweb.tools.i18n import gettext_lazy as _\n\n# Define the logger\nlogger = logging.getLogger(__name__)\n\n# Max root directory path length\nMAX_PATH = 260\n\n\nclass SizeField(Field):\n    \"\"\"\n    A text field which stores a file size as GiB or GB format.\n    \"\"\"\n\n    widget = widgets.TextInput()\n\n    def __init__(self, label=None, validators=None, **kwargs):\n        super(SizeField, self).__init__(label, validators, **kwargs)\n\n    def _value(self):\n        if self.raw_data:\n            return ' '.join(self.raw_data)\n        else:\n            return self.data and humanfriendly.format_size(self.data, binary=True) or ''\n\n    def process_formdata(self, valuelist):\n        if valuelist:\n            value_str = ''.join(valuelist)\n            # parse_size doesn't handle locales.this mean we need to\n            # replace ',' by '.' to get parse and prefix number with 0\n            value_str = value_str.replace(',', '.').strip()\n            # a value must start with a number.\n            if value_str.startswith('.'):\n                value_str = '0' + value_str\n            try:\n                self.data = humanfriendly.parse_size(value_str)\n            except humanfriendly.InvalidSize:\n                self.data = None\n                raise ValueError(self.gettext('Not a valid file size value'))\n\n\nclass UserForm(CherryForm):\n    userid = HiddenField(_('UserID'))\n    username = StringField(\n        _('Username'),\n        validators=[\n            validators.data_required(),\n            validators.length(max=256, message=_('Username too long.')),\n        ],\n    )\n    fullname = StringField(\n        _('Fullname'),\n        validators=[\n            validators.optional(),\n            validators.length(max=256, message=_('Fullname too long.')),\n        ],\n    )\n    email = EmailField(\n        _('Email'),\n        validators=[\n            validators.optional(),\n            validators.length(max=256, message=_('Email too long.')),\n        ],\n    )\n    password = PasswordField(\n        _('Password'),\n        validators=[validators.optional()],\n        description=_('To create an LDAP user, you must leave the password empty.'),\n    )\n    mfa = SelectField(\n        _('Two-Factor Authentication (2FA)'),\n        coerce=int,\n        choices=[\n            (UserObject.DISABLED_MFA, _(\"Disabled\")),\n            (UserObject.ENABLED_MFA, _(\"Enabled\")),\n        ],\n        default=UserObject.DISABLED_MFA,\n        description=_(\n            \"When Two-Factor Authentication (2FA) is enabled for a user, a verification code get sent by email when user login from a new location.\"\n        ),\n        render_kw={'data-beta': 1},\n    )\n    user_root = StringField(\n        _('Root directory'),\n        description=_(\"Absolute path defining the location of the repositories for this user.\"),\n        validators=[\n            validators.length(max=MAX_PATH, message=_('Root directory too long.')),\n        ],\n    )\n    role = SelectField(\n        _('User Role'),\n        coerce=int,\n        choices=[\n            (UserObject.ADMIN_ROLE, _(\"Admin\")),\n            (UserObject.MAINTAINER_ROLE, _(\"Maintainer\")),\n            (UserObject.USER_ROLE, _(\"User\")),\n        ],\n        default=UserObject.USER_ROLE,\n        description=_(\n            \"Admin: may browse and delete everything. Maintainer: may browse and delete their own repo. User: may only browser their own repo.\"\n        ),\n    )\n    disk_quota = SizeField(\n        _('Disk space'),\n        validators=[validators.optional()],\n        description=_(\"Users disk spaces (in bytes). Set to 0 to remove quota (unlimited).\"),\n    )\n    disk_usage = SizeField(\n        _('Quota Used'),\n        validators=[validators.optional()],\n        description=_(\"Disk spaces (in bytes) used by this user.\"),\n        widget=widgets.HiddenInput(),\n    )\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        cfg = cherrypy.tree.apps[''].cfg\n        self.password.validators += [\n            validators.length(\n                min=cfg.password_min_length,\n                max=cfg.password_max_length,\n                message=_('Password must have between %(min)d and %(max)d characters.'),\n            )\n        ]\n\n    def validate_role(self, field):\n        # Don't allow the user to changes it's \"role\" state.\n        currentuser = cherrypy.request.currentuser\n        if self.username.data == currentuser.username and self.role.data != currentuser.role:\n            raise ValueError(_('Cannot edit your own role.'))\n\n    def validate_mfa(self, field):\n        # Don't allow the user to changes it's \"mfa\" state.\n        currentuser = cherrypy.request.currentuser\n        if self.username.data == currentuser.username and self.mfa.data != currentuser.mfa:\n            raise ValueError(_('Cannot change your own two-factor authentication settings.'))\n\n    def populate_obj(self, userobj):\n        # Save password if defined\n        if self.password.data:\n            userobj.set_password(self.password.data, old_password=None)\n        userobj.role = self.role.data\n        userobj.fullname = self.fullname.data or ''\n        userobj.email = self.email.data or ''\n        userobj.user_root = self.user_root.data\n        if self.mfa.data and not userobj.email:\n            flash(_(\"User email is required to enabled Two-Factor Authentication\"), level='error')\n        else:\n            userobj.mfa = self.mfa.data\n        if not userobj.valid_user_root():\n            flash(_(\"User's root directory %s is not accessible!\") % userobj.user_root, level='error')\n            logger.warning(\"user's root directory %s is not accessible\" % userobj.user_root)\n        else:\n            userobj.refresh_repos(delete=True)\n        # Try to update disk quota if the human readable value changed.\n        # Report error using flash.\n        new_quota = self.disk_quota.data or 0\n        old_quota = humanfriendly.parse_size(humanfriendly.format_size(self.disk_quota.object_data or 0, binary=True))\n        if old_quota != new_quota:\n            userobj.disk_quota = new_quota\n            # Setting quota will silently fail. Check if quota was updated.\n            if userobj.disk_quota != new_quota:\n                flash(_(\"Setting user's quota is not supported\"), level='warning')\n\n\nclass EditUserForm(UserForm):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        # Make username field read-only\n        self.username.render_kw = {'readonly': True}\n        self.username.populate_obj = lambda *args, **kwargs: None\n\n\nclass DeleteUserForm(CherryForm):\n    username = StringField(_('Username'), validators=[validators.data_required()])\n\n\n@cherrypy.tools.is_admin()\nclass AdminUsersPage(Controller):\n    \"\"\"Administration pages. Allow to manage users database.\"\"\"\n\n    def _delete_user(self, action, form):\n        assert action == 'delete'\n        assert form\n        # Validate form.\n        if not form.validate():\n            flash(form.error_message, level='error')\n            return\n        if form.username.data == self.app.currentuser.username:\n            flash(_(\"You cannot remove your own account!\"), level='error')\n        else:\n            try:\n                user = UserObject.get_user(form.username.data)\n                if user:\n                    user.delete()\n                    flash(_(\"User account removed.\"))\n                else:\n                    flash(_(\"User doesn't exists!\"), level='warning')\n            except ValueError as e:\n                flash(e, level='error')\n\n    @cherrypy.expose\n    def default(self, username=None, action=u\"\", **kwargs):\n\n        # If we're just showing the initial page, just do that\n        if action == \"add\":\n            form = UserForm()\n            if form.validate_on_submit():\n                try:\n                    user = UserObject.add_user(username)\n                    form.populate_obj(user)\n                    flash(_(\"User added successfully.\"))\n                except Exception as e:\n                    flash(str(e), level='error')\n            else:\n                flash(form.error_message, level='error')\n        elif action == \"edit\":\n            user = UserObject.get_user(username)\n            if user:\n                form = EditUserForm(obj=user)\n                if form.validate_on_submit():\n                    try:\n                        form.populate_obj(user)\n                        flash(_(\"User information modified successfully.\"))\n                    except Exception as e:\n                        flash(str(e), level='error')\n                else:\n                    flash(form.error_message, level='error')\n            else:\n                flash(_(\"Cannot edit user `%s`: user doesn't exists\") % username, level='error')\n        elif action == 'delete':\n            form = DeleteUserForm()\n            if form.validate_on_submit():\n                self._delete_user(action, form)\n\n        params = {\n            \"add_form\": UserForm(formdata=None),\n            \"edit_form\": EditUserForm(formdata=None),\n            \"users\": UserObject.query.all(),\n        }\n\n        # Build users page\n        return self._compile_template(\"admin_users.html\", **params)\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefault preference page to show general user information. It allows user\nto change password ans refresh it's repository view.\n\"\"\"\n\nimport logging\nimport re\n\nimport cherrypy\nfrom wtforms.fields import HiddenField, PasswordField, StringField, SubmitField\nfrom wtforms.fields.html5 import EmailField\nfrom wtforms.validators import DataRequired, EqualTo, InputRequired, Length, Optional, Regexp\n\nfrom rdiffweb.controller import Controller, flash\nfrom rdiffweb.controller.form import CherryForm\nfrom rdiffweb.tools.i18n import gettext_lazy as _\n\n# Define the logger\n_logger = logging.getLogger(__name__)\n\nPATTERN_EMAIL = re.compile(r'[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$')\n\n\nclass UserProfileForm(CherryForm):\n    action = HiddenField(default='set_profile_info')\n    username = StringField(_('Username'), render_kw={'readonly': True})\n    fullname = StringField(\n        _('Fullname'),\n        validators=[\n            Optional(),\n            Length(max=256, message=_('Fullname too long.')),\n        ],\n    )\n    email = EmailField(\n        _('Email'),\n        validators=[\n            DataRequired(),\n            Length(max=256, message=_(\"Invalid email.\")),\n            Regexp(PATTERN_EMAIL, message=_(\"Invalid email.\")),\n        ],\n    )\n    set_profile_info = SubmitField(_('Save changes'))\n\n    def is_submitted(self):\n        # Validate only if action is set_profile_info\n        return super().is_submitted() and self.action.data == 'set_profile_info'\n\n    def populate_obj(self, user):\n        user.fullname = self.fullname.data\n        user.email = self.email.data\n        user.add()\n\n\nclass UserPasswordForm(CherryForm):\n    action = HiddenField(default='set_password')\n    current = PasswordField(\n        _('Current password'),\n        validators=[InputRequired(_(\"Current password is missing.\"))],\n        description=_(\"You must provide your current password in order to change it.\"),\n    )\n    new = PasswordField(\n        _('New password'),\n        validators=[\n            InputRequired(_(\"New password is missing.\")),\n            EqualTo('confirm', message=_(\"The new password and its confirmation do not match.\")),\n        ],\n    )\n    confirm = PasswordField(\n        _('Confirm new password'), validators=[InputRequired(_(\"Confirmation password is missing.\"))]\n    )\n    set_password = SubmitField(_('Update password'))\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.new.validators += [\n            Length(\n                min=self.app.cfg.password_min_length,\n                max=self.app.cfg.password_max_length,\n                message=_('Password must have between %(min)d and %(max)d characters.'),\n            )\n        ]\n\n    @property\n    def app(self):\n        return cherrypy.request.app\n\n    def is_submitted(self):\n        # Validate only if action is set_profile_info\n        return super().is_submitted() and self.action.data == 'set_password'\n\n    def populate_obj(self, user):\n        try:\n            user.set_password(self.new.data, old_password=self.current.data)\n            flash(_(\"Password updated successfully.\"), level='success')\n        except ValueError as e:\n            flash(str(e), level='warning')\n\n\nclass RefreshForm(CherryForm):\n    action = HiddenField(default='update_repos')\n    update_repos = SubmitField(\n        _('Refresh repositories'),\n        description=_(\n            \"Refresh the list of repositories associated to your account. If you recently add a new repository and it doesn't show, you may try to refresh the list.\"\n        ),\n    )\n\n    def is_submitted(self):\n        # Validate only if action is set_profile_info\n        return super().is_submitted() and self.action.data == 'update_repos'\n\n    def populate_obj(self, user):\n        try:\n            user.refresh_repos(delete=True)\n            flash(_(\"Repositories successfully updated\"), level='success')\n        except ValueError as e:\n            flash(str(e), level='warning')\n\n\nclass PagePrefsGeneral(Controller):\n    \"\"\"\n    Plugin to change user profile and password.\n    \"\"\"\n\n    @cherrypy.expose\n    def default(self, **kwargs):\n        # Process the parameters.\n        profile_form = UserProfileForm(obj=self.app.currentuser)\n        password_form = UserPasswordForm()\n        refresh_form = RefreshForm()\n        if profile_form.is_submitted():\n            if profile_form.validate():\n                profile_form.populate_obj(self.app.currentuser)\n                flash(_(\"Profile updated successfully.\"), level='success')\n            else:\n                flash(profile_form.error_message, level='error')\n        elif password_form.is_submitted():\n            if password_form.validate():\n                password_form.populate_obj(self.app.currentuser)\n            else:\n                flash(password_form.error_message, level='error')\n        elif refresh_form.is_submitted():\n            if refresh_form.validate():\n                refresh_form.populate_obj(self.app.currentuser)\n            else:\n                flash(refresh_form.error_message, level='error')\n        params = {\n            'profile_form': profile_form,\n            'password_form': password_form,\n            'refresh_form': refresh_form,\n        }\n        return self._compile_template(\"prefs_general.html\", **params)\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\nimport logging\n\nimport cherrypy\nfrom wtforms.fields import DateField, HiddenField, StringField, SubmitField\nfrom wtforms.validators import DataRequired, Length, Optional\n\nfrom rdiffweb.controller import Controller, flash\nfrom rdiffweb.controller.filter_authorization import is_maintainer\nfrom rdiffweb.controller.form import CherryForm\nfrom rdiffweb.core.model import Token\nfrom rdiffweb.tools.i18n import gettext_lazy as _\n\nlogger = logging.getLogger(__name__)\n\n\nclass TokenForm(CherryForm):\n    action = HiddenField(default='add_access_token')\n    name = StringField(\n        _('Token name'),\n        description=_(\n            'Used only to identify the purpose of the token. For example, the application that uses the token.'\n        ),\n        validators=[\n            DataRequired(),\n            Length(max=256, message=_('Token name too long')),\n        ],\n    )\n    expiration = DateField(\n        _('Expiration date'),\n        description=_(\n            'Allows the creation of a temporary token by defining an expiration date. Leave empty to keep the token forever.'\n        ),\n        render_kw={\n            \"placeholder\": _('YYYY-MM-DD'),\n        },\n        validators=[Optional()],\n    )\n    submit = SubmitField(_('Create access token'))\n\n    def is_submitted(self):\n        # Validate only if action is set_profile_info\n        return super().is_submitted() and self.action.data == 'add_access_token'\n\n    def populate_obj(self, userobj):\n        try:\n            token = userobj.add_access_token(self.name.data, self.expiration.data)\n            flash(\n                _(\n                    \"Your new personal access token has been created.\\n\"\n                    \"Make sure to save it - you won't be able to access it again.\\n\"\n                    \"%s\"\n                )\n                % token,\n                level='info',\n            )\n        except ValueError as e:\n            flash(str(e), level='warning')\n        except Exception:\n            logger.exception(\"error adding access token: %s, %s\" % (self.name.data, self.expiration.data))\n            flash(_(\"Unknown error while adding the access token.\"), level='error')\n\n\nclass DeleteTokenForm(CherryForm):\n    action = HiddenField(default='delete_access_token')\n    name = StringField(validators=[DataRequired()])\n\n    def is_submitted(self):\n        # Validate only if action is set_profile_info\n        return super().is_submitted() and self.action.data == 'delete_access_token'\n\n    def populate_obj(self, userobj):\n        is_maintainer()\n        try:\n            userobj.delete_access_token(self.name.data)\n            flash(_('The access token has been successfully deleted.'), level='success')\n        except ValueError as e:\n            flash(str(e), level='warning')\n        except Exception:\n            logger.exception(\"error removing access token: %s\" % self.name.data)\n            flash(_(\"Unknown error while removing the access token.\"), level='error')\n\n\nclass PagePrefTokens(Controller):\n    @cherrypy.expose\n    def default(self, action=None, **kwargs):\n        form = TokenForm()\n        delete_form = DeleteTokenForm()\n        if form.is_submitted():\n            if form.validate():\n                form.populate_obj(self.app.currentuser)\n            else:\n                flash(form.error_message, level='error')\n        elif delete_form.is_submitted():\n            if delete_form.validate():\n                delete_form.populate_obj(self.app.currentuser)\n            else:\n                flash(delete_form.error_message, level='error')\n        params = {\n            'form': form,\n            'tokens': Token.query.filter(Token.userid == self.app.currentuser.userid),\n        }\n        return self._compile_template(\"prefs_tokens.html\", **params)\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom unittest.mock import ANY, MagicMock\n\nimport cherrypy\n\nimport rdiffweb.test\nfrom rdiffweb.core.model import UserObject\n\n\nclass AbstractAdminTest(rdiffweb.test.WebCase):\n\n    login = True\n\n    def setUp(self):\n        super().setUp()\n        self._quota = {}\n        self.listener = MagicMock()\n        cherrypy.engine.subscribe('user_added', self.listener.user_added, priority=50)\n        cherrypy.engine.subscribe('user_attr_changed', self.listener.user_attr_changed, priority=50)\n        cherrypy.engine.subscribe('user_deleted', self.listener.user_deleted, priority=50)\n        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)\n        self.listener.get_disk_quota.side_effect = self._load_quota\n        cherrypy.engine.subscribe('get_disk_quota', self.listener.get_disk_quota, priority=40)\n        self.listener.get_disk_usage.return_value = 0\n        cherrypy.engine.subscribe('get_disk_usage', self.listener.get_disk_usage, priority=40)\n        self.listener.set_disk_quota.side_effect = self._store_quota\n        cherrypy.engine.subscribe('set_disk_quota', self.listener.set_disk_quota, priority=40)\n\n    def tearDown(self):\n        cherrypy.engine.unsubscribe('user_added', self.listener.user_added)\n        cherrypy.engine.unsubscribe('user_attr_changed', self.listener.user_attr_changed)\n        cherrypy.engine.unsubscribe('user_deleted', self.listener.user_deleted)\n        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)\n        cherrypy.engine.unsubscribe('get_disk_quota', self.listener.get_disk_quota)\n        cherrypy.engine.unsubscribe('get_disk_usage', self.listener.get_disk_usage)\n        cherrypy.engine.unsubscribe('set_disk_quota', self.listener.set_disk_quota)\n        return super().tearDown()\n\n    def _store_quota(self, userobj, value):\n        self._quota[userobj.username] = value\n\n    def _load_quota(self, userobj):\n        return self._quota.get(userobj.username, 0)\n\n    def _add_user(self, username=None, email=None, password=None, user_root=None, role=None, mfa=None, fullname=None):\n        b = {}\n        b['action'] = 'add'\n        if username is not None:\n            b['username'] = username\n        if email is not None:\n            b['email'] = email\n        if password is not None:\n            b['password'] = password\n        if user_root is not None:\n            b['user_root'] = user_root\n        if role is not None:\n            b['role'] = str(role)\n        if mfa is not None:\n            b['mfa'] = str(mfa)\n        if fullname is not None:\n            b['fullname'] = str(fullname)\n        self.getPage(\"/admin/users/\", method='POST', body=b)\n\n    def _edit_user(\n        self, username=None, email=None, password=None, user_root=None, role=None, disk_quota=None, mfa=None\n    ):\n        b = {}\n        b['action'] = 'edit'\n        if username is not None:\n            b['username'] = username\n        if email is not None:\n            b['email'] = email\n        if password is not None:\n            b['password'] = password\n        if user_root is not None:\n            b['user_root'] = user_root\n        if role is not None:\n            b['role'] = str(role)\n        if disk_quota is not None:\n            b['disk_quota'] = disk_quota\n        if mfa is not None:\n            b['mfa'] = str(mfa)\n        self.getPage(\"/admin/users/\", method='POST', body=b)\n\n    def _delete_user(self, username='test1'):\n        b = {'action': 'delete', 'username': username}\n        self.getPage(\"/admin/users/\", method='POST', body=b)\n\n    def test_add_user_with_role_admin(self):\n        # When trying to create a new user with role admin\n        self._add_user(\"admin_role\", \"admin_role@test.com\", \"password\", \"/home/\", UserObject.ADMIN_ROLE)\n        # Then page return success\n        self.assertStatus(200)\n        # Then database is updated\n        userobj = UserObject.get_user('admin_role')\n        self.assertEqual(UserObject.ADMIN_ROLE, userobj.role)\n        # Then notification was raised\n        self.listener.user_added.assert_called_once_with(userobj)\n\n    def test_add_user_with_role_maintainer(self):\n        self._add_user(\"maintainer_role\", \"maintainer_role@test.com\", \"password\", \"/home/\", UserObject.MAINTAINER_ROLE)\n        self.assertStatus(200)\n        self.assertEqual(UserObject.MAINTAINER_ROLE, UserObject.get_user('maintainer_role').role)\n\n    def test_add_user_with_role_user(self):\n        self._add_user(\"user_role\", \"user_role@test.com\", \"password\", \"/home/\", UserObject.USER_ROLE)\n        self.assertStatus(200)\n        self.assertEqual(UserObject.USER_ROLE, UserObject.get_user('user_role').role)\n\n    def test_add_user_with_invalid_role(self):\n        # When trying to create a new user with an invalid role (admin instead of 0)\n        self._add_user(\"invalid\", \"invalid@test.com\", \"password\", \"/home/\", 'admin')\n        # Then an error message is displayed to the user\n        self.assertStatus(200)\n        self.assertInBody('Role: Invalid Choice: could not coerce')\n        # Then listener are not called\n        self.listener.user_added.assert_not_called()\n\n        # When trying to create a new user with an invalid role (-1)\n        self._add_user(\"invalid\", \"invalid@test.com\", \"password\", \"/home/\", -1)\n        # Then an error message is displayed to the user\n        self.assertStatus(200)\n        self.assertInBody('User Role: Not a valid choice')\n        # Then listener are not called\n        self.listener.user_added.assert_not_called()\n\n    def test_add_edit_delete(self):\n        #  Add user to be listed\n        self.listener.user_password_changed.reset_mock()\n        self._add_user(\n            \"test2\", \"test2@test.com\", \"password\", \"/home/\", UserObject.USER_ROLE, mfa=UserObject.DISABLED_MFA\n        )\n        self.assertInBody(\"User added successfully.\")\n        self.assertInBody(\"test2\")\n        self.assertInBody(\"test2@test.com\")\n        self.listener.user_added.assert_called_once()\n        self.listener.user_password_changed.assert_called_once()\n        self.listener.user_password_changed.reset_mock()\n        #  Update user\n        self._edit_user(\n            \"test2\", \"chaned@test.com\", \"new-password\", \"/tmp/\", UserObject.ADMIN_ROLE, mfa=UserObject.ENABLED_MFA\n        )\n        self.listener.user_attr_changed.assert_called()\n        self.listener.user_password_changed.assert_called_once()\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertInBody(\"test2\")\n        self.assertInBody(\"chaned@test.com\")\n        self.assertNotInBody(\"/home/\")\n        self.assertInBody(\"/tmp/\")\n\n        self._delete_user(\"test2\")\n        self.listener.user_deleted.assert_called()\n        self.assertStatus(200)\n        self.assertInBody(\"User account removed.\")\n        self.assertNotInBody(\"test2\")\n\n    def test_edit_fullname(self):\n        # Given an existing user\n        # When updating the user's fullname\n        self.getPage(\n            \"/admin/users/\",\n            method='POST',\n            body={'action': 'edit', 'username': self.USERNAME, 'fullname': 'My fullname'},\n        )\n        self.assertStatus(200)\n        # Then user is updated successfully\n        self.assertInBody(\"User information modified successfully.\")\n        # Then database is updated\n        obj = UserObject.query.filter(UserObject.username == self.USERNAME).first()\n        self.assertEqual('My fullname', obj.fullname)\n\n    def test_add_edit_delete_user_with_encoding(self):\n        \"\"\"\n        Check creation of user with non-ascii char.\n        \"\"\"\n        self._add_user(\"\u00c9ric\", \"\u00e9ric@test.com\", \"password\", \"/home/\", UserObject.USER_ROLE)\n        self.assertInBody(\"User added successfully.\")\n        self.assertInBody(\"\u00c9ric\")\n        self.assertInBody(\"\u00e9ric@test.com\")\n        # Update user\n        self._edit_user(\"\u00c9ric\", \"eric.l\u00e9tourno@test.com\", \"\u00e9cureuil\", \"/tmp/\", UserObject.ADMIN_ROLE)\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertInBody(\"\u00c9ric\")\n        self.assertInBody(\"eric.l\u00e9tourno@test.com\")\n        self.assertNotInBody(\"/home/\")\n        self.assertInBody(\"/tmp/\")\n\n        self._delete_user(\"\u00c9ric\")\n        self.assertInBody(\"User account removed.\")\n        self.assertNotInBody(\"\u00c9ric\")\n\n    def test_add_user_with_empty_username(self):\n        \"\"\"\n        Verify failure trying to create user without username.\n        \"\"\"\n        self._add_user(\"\", \"test1@test.com\", \"password\", \"/tmp/\", UserObject.USER_ROLE)\n        self.assertStatus(200)\n        self.assertInBody(\"Username: This field is required.\")\n\n    def test_add_user_with_existing_username(self):\n        \"\"\"\n        Verify failure trying to add the same user.\n        \"\"\"\n        # Given a user named `test1`\n        self._add_user(\"test1\", \"test1@test.com\", \"password\", \"/tmp/\", UserObject.USER_ROLE)\n        # When trying to create a new user with the same name\n        self._add_user(\"test1\", \"test1@test.com\", \"password\", \"/tmp/\", UserObject.USER_ROLE)\n        # Then the user list is displayed with an error message.\n        self.assertStatus(200)\n        self.assertInBody(\"User test1 already exists.\")\n\n    def test_add_user_with_invalid_root_directory(self):\n        \"\"\"\n        Verify failure to add a user with invalid root directory.\n        \"\"\"\n        try:\n            self._delete_user(\"test5\")\n        except Exception:\n            pass\n        self._add_user(\"test5\", \"test1@test.com\", \"password\", \"/var/invalid/\", UserObject.USER_ROLE)\n        self.assertInBody(\"User added successfully.\")\n        self.assertInBody(\"User&#39;s root directory /var/invalid/ is not accessible!\")\n\n    def test_add_without_email(self):\n        #  Add user to be listed\n        self._add_user(\"test2\", None, \"password\", \"/tmp/\", UserObject.USER_ROLE)\n        self.assertInBody(\"User added successfully.\")\n\n    def test_add_without_user_root(self):\n        #  Add user to be listed\n        self._add_user(\"test6\", None, \"password\", None, UserObject.USER_ROLE)\n        self.assertInBody(\"User added successfully.\")\n\n        user = UserObject.get_user('test6')\n        self.assertEqual('', user.user_root)\n\n    def test_add_with_username_too_long(self):\n        # Given a too long username\n        username = \"test2\" * 52\n        # When trying to create the user\n        self._add_user(username, None, \"password\", \"/tmp/\", UserObject.USER_ROLE)\n        # Then an error is raised\n        self.assertStatus(200)\n        self.assertInBody(\"Username too long.\")\n\n    def test_add_with_email_too_long(self):\n        # Given a too long username\n        email = (\"test2\" * 50) + \"@test.com\"\n        # When trying to create the user\n        self._add_user(\"test2\", email, \"password\", \"/tmp/\", UserObject.USER_ROLE)\n        # Then an error is raised\n        self.assertStatus(200)\n        self.assertInBody(\"Email too long.\")\n\n    def test_add_with_user_root_too_long(self):\n        # Given a too long user root\n        user_root = \"/temp/\" * 50\n        # When trying to create the user\n        self._add_user(\"test2\", \"test@test,com\", \"password\", user_root, UserObject.USER_ROLE)\n        # Then an error is raised\n        self.assertStatus(200)\n        self.assertInBody(\"Root directory too long.\")\n\n    def test_add_with_fullname_too_long(self):\n        # Given a too long user root\n        fullname = \"fullname\" * 50\n        # When trying to create the user\n        self._add_user(\"test2\", \"test@test,com\", \"password\", \"/tmp/\", UserObject.USER_ROLE, fullname=fullname)\n        # Then an error is raised\n        self.assertStatus(200)\n        self.assertInBody(\"Fullname too long.\")\n\n    def test_delete_user_with_not_existing_username(self):\n        \"\"\"\n        Verify failure to delete invalid username.\n        \"\"\"\n        self._delete_user(\"test3\")\n        self.assertInBody(\"User doesn&#39;t exists!\")\n\n    def test_delete_our_self(self):\n        \"\"\"\n        Verify failure to delete our self.\n        \"\"\"\n        self._delete_user(self.USERNAME)\n        self.assertInBody(\"You cannot remove your own account!\")\n\n    def test_delete_user_admin(self):\n        \"\"\"\n        Verify failure to delete our self.\n        \"\"\"\n        # Create another admin user\n        self._add_user('admin2', '', 'password', '', UserObject.ADMIN_ROLE)\n        self.getPage(\"/logout\")\n        self.assertStatus(303)\n        self.assertHeaderItemValue('Location', self.baseurl + '/')\n        self._login('admin2', 'password')\n\n        # Try deleting admin user\n        self._delete_user(self.USERNAME)\n        self.assertStatus(200)\n        self.assertInBody(\"can&#39;t delete admin user\")\n\n    def test_delete_user_method_get(self):\n        # Given a user\n        UserObject.add_user('newuser')\n        # When trying to delete this user using method GET\n        self.getPage(\"/admin/users/?action=delete&username=newuser\", method='GET')\n        # Then page return without error\n        self.assertStatus(200)\n        # Then user is not deleted\n        self.assertIsNotNone(UserObject.get_user('newuser'))\n\n    def test_change_password_with_too_short(self):\n        self._edit_user(self.USERNAME, password='short')\n        self.assertInBody(\"Password must have between 8 and 128 characters.\")\n\n    def test_change_password_with_too_long(self):\n        new_password = 'a' * 129\n        self._edit_user(self.USERNAME, password=new_password)\n        self.assertInBody(\"Password must have between 8 and 128 characters.\")\n\n    def test_change_admin_password(self):\n        # Given rdiffweb is configured with admin-password option\n        self.app.cfg.admin_password = 'hardcoded'\n        try:\n            # When trying to update admin password\n            self._edit_user('admin', password='new-password')\n            # Then the form is refused with 200 OK with an error message.\n            self.assertStatus(200)\n            self.assertInBody(\"can&#39;t update admin-password defined in configuration file\")\n        finally:\n            self.app.cfg.admin_password = None\n\n    def test_edit_user_with_invalid_path(self):\n        \"\"\"\n        Verify failure trying to update user with invalid path.\n        \"\"\"\n        UserObject.add_user('test1')\n        self._edit_user(\"test1\", \"test1@test.com\", \"password\", \"/var/invalid/\", UserObject.USER_ROLE)\n        self.assertNotInBody(\"User added successfully.\")\n        self.assertInBody(\"User&#39;s root directory /var/invalid/ is not accessible!\")\n\n    def test_list(self):\n        self.getPage(\"/admin/users/\")\n        self.assertInBody(\"Users\")\n        self.assertInBody(\"User management\")\n        self.assertInBody(\"Add user\")\n\n    def test_edit_user_with_not_existing_username(self):\n        \"\"\"\n        Verify failure trying to update invalid user.\n        \"\"\"\n        # Given an invalid username\n        username = 'invalid'\n        # When trying to edit the user\n        self._edit_user(username, \"test1@test.com\", \"test\", \"/var/invalid/\", UserObject.USER_ROLE)\n        # Then the user list is displayed with an error message\n        self.assertStatus(200)\n        self.assertInBody(\"Cannot edit user `invalid`: user doesn&#39;t exists\")\n\n    def test_user_invalid_root(self):\n        # Delete all user's\n        for user in UserObject.query.all():\n            if user.username != self.USERNAME:\n                user.delete()\n        # Change the user's root\n        user = UserObject.get_user('admin')\n        user.user_root = \"/invalid\"\n        user.add()\n        self.getPage(\"/admin/users\")\n        self.assertInBody(\"Root directory not accessible!\")\n\n        # Query the page by default\n        user = UserObject.get_user('admin')\n        user.user_root = \"/tmp/\"\n        user.add()\n        self.getPage(\"/admin/users\")\n        self.assertNotInBody(\"Root directory not accessible!\")\n\n    def test_get_quota(self):\n        # Mock a quota.\n        self.listener.get_disk_quota.side_effect = None\n        self.listener.get_disk_quota.return_value = 654321\n        # When querying the user list\n        self.getPage(\"/admin/users/\")\n        self.assertStatus(200)\n        # Then get_disk_quota listenre is called\n        self.listener.get_disk_quota.assert_called()\n        # Then the quota value is displayed in human readable format\n        self.assertInBody(\"638.99 KiB\")\n        self.assertStatus(200)\n\n    def test_set_quota(self):\n        # When updating user quota.\n        self._edit_user(\"admin\", disk_quota='8765432')\n        # Then listenr get called\n        self.listener.set_disk_quota.assert_called_once_with(ANY, 8765432)\n        # Then a success message is displayed\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertStatus(200)\n\n    def test_set_quota_as_gib(self):\n        # When updating user quota\n        self._edit_user(\"admin\", disk_quota='1GiB')\n        # Then listern get called\n        self.listener.set_disk_quota.assert_called_once_with(ANY, 1073741824)\n        # Then a success message is displayed\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertStatus(200)\n\n    def test_set_quota_as_with_comma(self):\n        # When updating quota with comma value\n        self._edit_user(\"admin\", disk_quota='1,5 GiB')\n        # Then listner get called\n        self.listener.set_disk_quota.assert_called_once_with(ANY, 1610612736)\n        # Then a success message is displayed\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertStatus(200)\n\n    def test_set_quota_as_with_leading_dot(self):\n        # When updating quota with leading dot\n        self._edit_user(\"admin\", disk_quota='.5 GiB')\n        # Then listener get called\n        self.listener.set_disk_quota.assert_called_once_with(ANY, 536870912)\n        # Then a success message is displayed\n        self.assertInBody(\"User information modified successfully.\")\n        self.assertStatus(200)\n\n    def test_set_quota_empty(self):\n        # When quota is not defined\n        self._edit_user(\"admin\", disk_quota='')\n        # Then listener is not called.\n        self.listener.set_disk_quota.assert_not_called()\n        # Then message is not displayed\n        self.assertStatus(200)\n\n    def test_set_quota_same_value(self):\n        # Given an exiting quota\n        self.listener.get_disk_quota.side_effect = None\n        self.listener.get_disk_quota.return_value = 1234567890\n        # When setting the quota value to the same value\n        self._edit_user(\"admin\", disk_quota='1.15 GiB')\n        #  Then listener is not called\n        self.listener.set_disk_quota.assert_not_called()\n        # Then message is not displayed\n        self.assertStatus(200)\n\n    def test_set_quota_unsupported(self):\n        # Given setting quota is not supported\n        self.listener.set_disk_quota.side_effect = None\n        self.listener.set_disk_quota.return_value = None\n        # When updating the quota\n        self._edit_user(\"admin\", disk_quota='8765432')\n        # Then\n        self.listener.set_disk_quota.assert_called_once_with(ANY, 8765432)\n        self.assertInBody(\"Setting user&#39;s quota is not supported\")\n        self.assertStatus(200)\n\n    def test_edit_own_role(self):\n        # Given an administrator\n        # When trygin to update your own role\n        self._edit_user(username=self.USERNAME, role=UserObject.MAINTAINER_ROLE)\n        # Then an error is returned\n        self.assertStatus(200)\n        self.assertInBody(\"Cannot edit your own role.\")\n\n    def test_edit_own_mfa(self):\n        # Given an administrator\n        # When trygin to update your own role\n        self._edit_user(username=self.USERNAME, mfa=UserObject.ENABLED_MFA)\n        # Then an error is returned\n        self.assertStatus(200)\n        self.assertInBody(\"Cannot change your own two-factor authentication settings.\")\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nCreated on Dec 26, 2015\n\n@author: Patrik Dufresne\n\"\"\"\n\nfrom unittest.mock import MagicMock\n\nimport cherrypy\n\nimport rdiffweb.test\nfrom rdiffweb.core.model import RepoObject, UserObject\n\n\nclass PagePrefGeneralTest(rdiffweb.test.WebCase):\n\n    PREFS = \"/prefs/general\"\n\n    login = True\n\n    def setUp(self):\n        self.listener = MagicMock()\n        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)\n        return super().setUp()\n\n    def tearDown(self):\n        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)\n        return super().tearDown()\n\n    def _set_password(\n        self,\n        current,\n        new_password,\n        confirm,\n    ):\n        b = {\n            'action': 'set_password',\n            'current': current,\n            'new': new_password,\n            'confirm': confirm,\n        }\n        return self.getPage(self.PREFS, method='POST', body=b)\n\n    def _set_profile_info(self, email, fullname=None):\n        b = {\n            'action': 'set_profile_info',\n            'email': email,\n        }\n        if fullname:\n            b['fullname'] = fullname\n        return self.getPage(self.PREFS, method='POST', body=b)\n\n    def test_get_page(self):\n        # When querying the page\n        self.getPage(self.PREFS)\n        # Then the page is returned\n        self.assertStatus(200)\n        self.assertInBody('User profile')\n\n    def test_change_username_noop(self):\n        # Given an authenticated user\n        # When updating the username\n        self.getPage(\n            self.PREFS,\n            method='POST',\n            body={'action': 'set_profile_info', 'email': 'test@test.com', 'username': 'test'},\n        )\n        self.assertStatus(200)\n        self.assertInBody(\"Profile updated successfully.\")\n        # Then database is updated with fullname\n        user = UserObject.query.filter(UserObject.username == self.USERNAME).first()\n        self.assertIsNotNone(user)\n        self.assertEqual(\"test@test.com\", user.email)\n\n    def test_change_fullname(self):\n        # Given an authenticated user\n        # When update the fullname\n        self._set_profile_info(\"test@test.com\", \"My Fullname\")\n        self.assertStatus(200)\n        self.assertInBody(\"Profile updated successfully.\")\n        # Then database is updated with fullname\n        self.assertInBody(\"My Fullname\")\n        user = UserObject.query.filter(UserObject.username == self.USERNAME).first()\n        self.assertEqual(\"My Fullname\", user.fullname)\n\n    def test_change_fullname_method_get(self):\n        # Given an authenticated user\n        # When trying to update full name using GET method\n        self.getPage(self.PREFS + '?action=set_profile_info&email=test@test.com')\n        # Then nothing happen\n        self.assertStatus(200)\n        self.assertNotInBody(\"Profile updated successfully.\")\n        user = UserObject.query.filter(UserObject.username == self.USERNAME).first()\n        self.assertEqual(\"\", user.fullname)\n\n    def test_change_fullname_too_long(self):\n        # Given an authenticated user\n        # When update the fullname\n        self._set_profile_info(\"test@test.com\", \"Fullname\" * 50)\n        # Then page return with error message\n        self.assertStatus(200)\n        self.assertNotInBody(\"Profile updated successfully.\")\n        self.assertInBody(\"Fullname too long.\")\n        # Then database is not updated\n        user = UserObject.query.filter(UserObject.username == self.USERNAME).first()\n        self.assertEqual(\"\", user.fullname)\n\n    def test_change_email(self):\n        self._set_profile_info(\"test@test.com\")\n        self.assertStatus(200)\n        self.assertInBody(\"Profile updated successfully.\")\n\n    def test_change_email_with_invalid_email(self):\n        self._set_profile_info(\"@test.com\")\n        self.assertStatus(200)\n        self.assertInBody(\"Invalid email\")\n\n        self._set_profile_info(\"test.com\")\n        self.assertStatus(200)\n        self.assertInBody(\"Invalid email\")\n\n        self._set_profile_info(\"test\")\n        self.assertStatus(200)\n        self.assertInBody(\"Invalid email\")\n\n        self._set_profile_info(\"test@te_st.com\")\n        self.assertStatus(200)\n        self.assertInBody(\"Invalid email\")\n\n        self._set_profile_info(\"test@test.com, test2@test.com\")\n        self.assertStatus(200)\n        self.assertInBody(\"Invalid email\")\n\n    def test_change_email_with_too_long(self):\n        self._set_profile_info((\"test1\" * 50) + \"@test.com\")\n        self.assertInBody(\"Invalid email\")\n\n    def test_change_password(self):\n        self.listener.user_password_changed.reset_mock()\n        # When udating user's password\n        self._set_password(self.PASSWORD, \"newpassword\", \"newpassword\")\n        self.assertInBody(\"Password updated successfully.\")\n        # Then a notification is raised\n        self.listener.user_password_changed.assert_called_once()\n        # Change it back\n        self._set_password(\"newpassword\", self.PASSWORD, self.PASSWORD)\n        self.assertInBody(\"Password updated successfully.\")\n\n    def test_change_password_with_wrong_confirmation(self):\n        self._set_password(self.PASSWORD, \"t\", \"a\")\n        self.assertInBody(\"The new password and its confirmation do not match.\")\n\n    def test_change_password_with_wrong_password(self):\n        self._set_password(\"oups\", \"newpassword\", \"newpassword\")\n        self.assertInBody(\"Wrong password\")\n\n    def test_change_password_with_too_short(self):\n        self._set_password(self.PASSWORD, \"short\", \"short\")\n        self.assertInBody(\"Password must have between 8 and 128 characters.\")\n\n    def test_change_password_with_too_long(self):\n        new_password = 'a' * 129\n        self._set_password(self.PASSWORD, new_password, new_password)\n        self.assertInBody(\"Password must have between 8 and 128 characters.\")\n\n    def test_change_password_method_get(self):\n        # Given an authenticated user\n        # Trying to update password with GET method\n        self.getPage(self.PREFS + '?action=set_password&new=newpassword&confirm=newpassword&current=' + self.PASSWORD)\n        # Then nothing happen\n        self.assertStatus(200)\n        self.assertNotInBody(\"Password updated successfully.\")\n\n    def test_invalid_pref(self):\n        \"\"\"\n        Check if invalid prefs url is 404 Not Found.\n        \"\"\"\n        self.getPage(\"/prefs/invalid/\")\n        self.assertStatus(404)\n\n    def test_update_repos(self):\n        # Given a user with invalid repositories\n        userobj = UserObject.get_user(self.USERNAME)\n        RepoObject(userid=userobj.userid, repopath='invalid').add()\n        self.assertEqual(['broker-repo', 'invalid', 'testcases'], sorted([r.name for r in userobj.repo_objs]))\n        # When updating the repository list\n        self.getPage(self.PREFS, method='POST', body={'action': 'update_repos'})\n        self.assertStatus(200)\n        # Then a success message is displayed\n        self.assertInBody('Repositories successfully updated')\n        # Then the list is free of inexisting repos.\n        userobj.expire()\n        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in userobj.repo_objs]))\n", "# -*- coding: utf-8 -*-\n# rdiffweb, A web interface to rdiff-backup repositories\n# Copyright (C) 2012-2021 rdiffweb contributors\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\nimport rdiffweb.test\nfrom rdiffweb.core.model import Token, UserObject\n\n\nclass PagePrefTokensTest(rdiffweb.test.WebCase):\n\n    login = True\n\n    def test_get(self):\n        # When getting the page\n        self.getPage(\"/prefs/tokens\")\n        # Then the page is return without error\n        self.assertStatus(200)\n\n    def test_add_access_token(self):\n        # Given an existing user\n        userobj = UserObject.get_user(self.USERNAME)\n        # When adding a new access token\n        self.getPage(\n            \"/prefs/tokens\",\n            method='POST',\n            body={'action': 'add_access_token', 'name': 'test-token-name', 'expiration_time': ''},\n        )\n        # Then page return without error\n        self.assertStatus(200)\n        # Then token name get displayed in the view\n        self.assertInBody('test-token-name')\n        # Then access token get created\n        self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid, Token.name == 'test-token-name').count())\n\n    def test_add_access_token_with_expiration_time(self):\n        # Given an existing user\n        userobj = UserObject.get_user(self.USERNAME)\n        # When adding a new access token\n        self.getPage(\n            \"/prefs/tokens\",\n            method='POST',\n            body={'action': 'add_access_token', 'name': 'test-token-name', 'expiration_time': '1999-01-01'},\n        )\n        # Then page return without error\n        self.assertStatus(200)\n        # Then token name get displayed in the view\n        self.assertInBody('test-token-name')\n        # Then access token get created\n        self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid, Token.name == 'test-token-name').count())\n\n    def test_add_access_token_without_name(self):\n        # Given an existing user\n        userobj = UserObject.get_user(self.USERNAME)\n        # When adding a new access token\n        self.getPage(\n            \"/prefs/tokens\",\n            method='POST',\n            body={'action': 'add_access_token', 'name': '', 'expiration_time': ''},\n        )\n        # Then page return without error\n        self.assertStatus(200)\n        # Then token name get displayed in the view\n        self.assertInBody('Token name: This field is required.')\n        # Then access token is not created\n        self.assertEqual(0, Token.query.filter(Token.userid == userobj.userid, Token.name == 'test-token-name').count())\n\n    def test_add_access_token_with_name_too_long(self):\n        # Given an existing user\n        # When adding a new access token with name too long.\n        self.getPage(\n            \"/prefs/tokens\",\n            method='POST',\n            body={'action': 'add_access_token', 'name': 'token' * 52, 'expiration_time': ''},\n        )\n        # Then page return with error message\n        self.assertStatus(200)\n        # Then token name get displayed in the view\n        self.assertInBody('Token name too long')\n\n    def test_delete_access_token(self):\n        # Given an existing user with access_token\n        userobj = UserObject.get_user(self.USERNAME)\n        userobj.add_access_token('test-token-name')\n        # When deleting access token\n        self.getPage(\n            \"/prefs/tokens\",\n            method='POST',\n            body={'action': 'delete_access_token', 'name': 'test-token-name'},\n        )\n        # Then page return without error\n        self.assertStatus(200)\n        # Then token name get displayed in the view\n        self.assertInBody('The access token has been successfully deleted.')\n        # Then access token is not created\n        self.assertEqual(0, Token.query.filter(Token.userid == userobj.userid, Token.name == 'test-token-name').count())\n"], "filenames": ["rdiffweb/controller/page_admin_users.py", "rdiffweb/controller/page_pref_general.py", "rdiffweb/controller/page_pref_tokens.py", "rdiffweb/controller/tests/test_page_admin_users.py", "rdiffweb/controller/tests/test_page_prefs_general.py", "rdiffweb/controller/tests/test_page_prefs_tokens.py"], "buggy_code_start_loc": [79, 28, 23, 61, 111, 80], "buggy_code_end_loc": [80, 44, 42, 277, 111, 80], "fixing_code_start_loc": [79, 28, 23, 61, 112, 81], "fixing_code_end_loc": [86, 50, 45, 289, 124, 94], "type": "CWE-770", "message": "Allocation of Resources Without Limits or Throttling in GitHub repository ikus060/rdiffweb prior to 2.5.0a3.", "other": {"cve": {"id": "CVE-2022-3364", "sourceIdentifier": "security@huntr.dev", "published": "2022-09-29T21:15:11.883", "lastModified": "2022-10-04T13:14:36.490", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Allocation of Resources Without Limits or Throttling in GitHub repository ikus060/rdiffweb prior to 2.5.0a3."}, {"lang": "es", "value": "Una Asignaci\u00f3n de Recursos sin L\u00edmites ni Estrangulamiento en el repositorio de GitHub ikus060/rdiffweb versiones anteriores a 2.5.0a3"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ikus-soft:rdiffweb:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.4.9", "matchCriteriaId": "705F4846-2B52-430E-88CE-AC6514B70A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ikus-soft:rdiffweb:2.5.0:alpha1:*:*:*:*:*:*", "matchCriteriaId": "E967F2E5-0F47-436B-9DC7-4F8D051F5615"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ikus-soft:rdiffweb:2.5.0:alpha2:*:*:*:*:*:*", "matchCriteriaId": "039D2014-4F4C-4B3F-81B1-EFA08EE3D513"}]}]}], "references": [{"url": "https://github.com/ikus060/rdiffweb/commit/b62c479ff6979563c7c23e7182942bc4f460a2c7", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/e70ad507-1424-463b-bdf1-c4a6fbe6e720", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ikus060/rdiffweb/commit/b62c479ff6979563c7c23e7182942bc4f460a2c7"}}