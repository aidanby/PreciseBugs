{"buggy_code": ["/*\n * Copyright (c) 2015-2019 Snowflake Computing Inc. All rights reserved.\n */\n\nvar Util = require('../../util');\nvar Errors = require('../../errors');\nvar BigNumber = require('bignumber.js');\nvar SfTimestamp = require('./sf_timestamp');\nvar SqlTypes = require('./data_types').SqlTypes;\nvar bigInt = require('big-integer');\nvar { XMLParser, XMLValidator } = require(\"fast-xml-parser\");\n\nvar NULL_UPPERCASE = 'NULL';\n\n/**\n * Creates a new Column.\n *\n * @param {Object} options\n * @param {Number} index\n * @param {Object} statementParameters\n * @param {String} resultVersion\n *\n * @constructor\n */\nfunction Column(options, index, statementParameters, resultVersion)\n{\n  var name = options.name;\n  var nullable = options.nullable;\n  var scale = options.scale;\n  var type = options.type;\n  var precision = options.precision;\n\n  /**\n   * Returns the name of this column.\n   *\n   * @return {String}\n   */\n  this.getName = function ()\n  {\n    return name;\n  };\n\n  /**\n   * Returns the index of this column.\n   *\n   * @return {Number}\n   */\n  this.getIndex = function ()\n  {\n    return index;\n  };\n\n  /**\n   * Returns the id of this column.\n   *\n   * @return {Number}\n   */\n  this.getId = function ()\n  {\n    // use the index as the id for now\n    return index;\n  };\n\n  /**\n   * Determines if this column is nullable.\n   *\n   * @returns {Boolean}\n   */\n  this.isNullable = function ()\n  {\n    return nullable;\n  };\n\n  /**\n   * Returns the scale associated with this column.\n   *\n   * @returns {Number}\n   */\n  this.getScale = function ()\n  {\n    return scale;\n  };\n\n  /**\n   * Returns the type associated with this column.\n   *\n   * @returns {String}\n   */\n  this.getType = function ()\n  {\n    return type;\n  };\n\n  /**\n   * Returns the precision associated with this column\n   *\n   * @returns {Number}\n   */\n  this.getPrecision = function ()\n  {\n    return precision;\n  };\n\n  // add methods that make it easy to check if the column is of a specific type\n  this.isString = createFnIsColumnOfType(type, SqlTypes.isString, SqlTypes);\n  this.isBinary = createFnIsColumnOfType(type, SqlTypes.isBinary, SqlTypes);\n  this.isNumber = createFnIsColumnOfType(type, SqlTypes.isNumber, SqlTypes);\n  this.isBoolean = createFnIsColumnOfType(type, SqlTypes.isBoolean, SqlTypes);\n  this.isDate = createFnIsColumnOfType(type, SqlTypes.isDate, SqlTypes);\n  this.isTime = createFnIsColumnOfType(type, SqlTypes.isTime, SqlTypes);\n  this.isTimestamp = createFnIsColumnOfType(type, SqlTypes.isTimestamp, SqlTypes);\n  this.isTimestampLtz = createFnIsColumnOfType(type, SqlTypes.isTimestampLtz, SqlTypes);\n  this.isTimestampNtz = createFnIsColumnOfType(type, SqlTypes.isTimestampNtz, SqlTypes);\n  this.isTimestampTz = createFnIsColumnOfType(type, SqlTypes.isTimestampTz, SqlTypes);\n  this.isVariant = createFnIsColumnOfType(type, SqlTypes.isVariant, SqlTypes);\n  this.isObject = createFnIsColumnOfType(type, SqlTypes.isObject, SqlTypes);\n  this.isArray = createFnIsColumnOfType(type, SqlTypes.isArray, SqlTypes);\n\n  var convert;\n  var toString;\n  var toValue;\n  var format;\n\n  if (this.isNumber())\n  {\n    let integerAs = statementParameters['JS_TREAT_INTEGER_AS_BIGINT'];\n    if (!integerAs)\n    {\n      convert = convertRawNumber;\n    }\n    else\n    {\n      if (this.getScale() > 0 || this.getType() === SqlTypes.values.REAL)\n      {\n        convert = convertRawNumber;\n      }\n      // This is a integer so represent it as a big int\n      else\n      {\n        convert = convertRawBigInt;\n      }\n    }\n    toValue = toValueFromNumber;\n    toString = toStringFromNumber;\n  }\n  else if (this.isTime())\n  {\n    convert = convertRawTime;\n    toValue = toValueFromTime;\n    toString = toStringFromTime;\n    format = statementParameters['TIME_OUTPUT_FORMAT'];\n  }\n  else\n  {\n    toValue = noop;\n\n    if (this.isBoolean())\n    {\n      convert = convertRawBoolean;\n      toString = toStringFromBoolean;\n    }\n    else if (this.isDate())\n    {\n      convert = convertRawDate;\n      toString = toStringFromDate;\n      format = statementParameters['DATE_OUTPUT_FORMAT'];\n    }\n    else if (this.isTimestamp())\n    {\n      if (this.isTimestampLtz())\n      {\n        convert = convertRawTimestampLtz;\n        toString = toStringFromTimestamp;\n        format = statementParameters['TIMESTAMP_LTZ_OUTPUT_FORMAT'];\n      }\n      else if (this.isTimestampNtz())\n      {\n        convert = convertRawTimestampNtz;\n        toString = toStringFromTimestamp;\n        format = statementParameters['TIMESTAMP_NTZ_OUTPUT_FORMAT'];\n      }\n      else if (this.isTimestampTz())\n      {\n        convert = convertRawTimestampTz;\n        toString = toStringFromTimestamp;\n        format = statementParameters['TIMESTAMP_TZ_OUTPUT_FORMAT'];\n      }\n\n      // if we don't have a type-specific timezone, use the default format\n      if (!format)\n      {\n        format = statementParameters['TIMESTAMP_OUTPUT_FORMAT'];\n      }\n    }\n    else if (this.isBinary())\n    {\n      convert = convertRawBinary;\n      toString = toStringFromBinary;\n      format = statementParameters['BINARY_OUTPUT_FORMAT'];\n    }\n    else if (this.isVariant())\n    {\n      convert = convertRawVariant;\n      toString = toStringFromVariant;\n    }\n    else\n    {\n      // column is of type string, so leave value as is\n      convert = noop;\n      toString = toStringFromString;\n    }\n  }\n\n  // create a private context to pass to the extract function\n  var context =\n    {\n      convert: convert,\n      toValue: toValue,\n      toString: toString,\n      format: format,\n      resultVersion: resultVersion,\n      statementParameters: statementParameters\n    };\n\n  /**\n   * Returns the value of this column in a row.\n   *\n   * @param {Object} row\n   *\n   * @returns {*}\n   */\n  this.getRowValue = function (row)\n  {\n    return extractFromRow.call(this, row, context, false);\n  };\n\n  /**\n   * Returns the value of this in a row as a String.\n   *\n   * @param {Object} row\n   *\n   * @returns {String}\n   */\n  this.getRowValueAsString = function (row)\n  {\n    return extractFromRow.call(this, row, context, true);\n  };\n}\n\n/**\n * Returns a function that can be used to determine if a column is of a given\n * type.\n *\n * @param {String} columnType the column type.\n * @param {Function} columnComparisonFn the column comparison function.\n * @param {Object} scope the scope in which to invoke the column comparison\n *   function.\n *\n * @returns {Function}\n */\nfunction createFnIsColumnOfType(columnType, columnComparisonFn, scope)\n{\n  return function ()\n  {\n    return columnComparisonFn.call(scope, columnType);\n  };\n}\n\n/**\n * Converts a raw column value of type Number. The returned value is an object\n * that contains the raw string version of the value as well as the\n * post-processed version of the value obtained after casting to Number.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Object}\n */\nfunction convertRawNumber(rawColumnValue, column, context)\n{\n  return {\n    raw: rawColumnValue,\n    processed: Number(rawColumnValue)\n  };\n}\n\n/**\n * Converts a raw column value that is an integer. The returned value is an object\n * that contains the raw string version of the value as well as the post-processed\n * version of the value obtained after casting to bigInt\n *\n * @param rawColumnValue\n * @param column\n * @param context\n * @returns {{processed: bigInt.BigInteger, raw: *}}\n */\nfunction convertRawBigInt(rawColumnValue, column, context)\n{\n  return {\n    raw: rawColumnValue,\n    processed: bigInt(rawColumnValue)\n  };\n}\n\n/**\n * Converts a raw column value of type Boolean to a boolean (true, false,\n * or null).\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Boolean}\n */\nfunction convertRawBoolean(rawColumnValue, column, context)\n{\n  var ret;\n\n  if ((rawColumnValue === '1') || (rawColumnValue === 'TRUE'))\n  {\n    ret = true;\n  }\n  else if ((rawColumnValue === '0') || (rawColumnValue === 'FALSE'))\n  {\n    ret = false;\n  }\n\n  return ret;\n}\n\n/**\n * Converts a raw column value of type Date to a Snowflake Date.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Date}\n */\nfunction convertRawDate(rawColumnValue, column, context)\n{\n  return new SfTimestamp(\n    Number(rawColumnValue) * 86400, // convert to seconds\n    0,                              // no nano seconds\n    0,                              // no scale required\n    'UTC',                          // use utc as the timezone\n    context.format).toSfDate();\n}\n\n/**\n * Converts a raw column value of type Time to a Snowflake Time.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Object}\n */\nfunction convertRawTime(rawColumnValue, column, context)\n{\n  var columnScale = column.getScale();\n\n  // the values might be big so use BigNumber to do arithmetic\n  var valFracSecsBig =\n    new BigNumber(rawColumnValue).times(Math.pow(10, columnScale));\n\n  return convertRawTimestampHelper(\n    valFracSecsBig,\n    columnScale,\n    'UTC',\n    context.format).toSfTime();\n}\n\n/**\n * Converts a raw column value of type TIMESTAMP_LTZ to a Snowflake Date.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Date}\n */\nfunction convertRawTimestampLtz(rawColumnValue, column, context)\n{\n  var columnScale = column.getScale();\n\n  // the values might be big so use BigNumber to do arithmetic\n  var valFracSecsBig =\n    new BigNumber(rawColumnValue).times(Math.pow(10, columnScale));\n\n  // create a new snowflake date\n  return convertRawTimestampHelper(\n    valFracSecsBig,\n    columnScale,\n    context.statementParameters['TIMEZONE'],\n    context.format).toSfDate();\n}\n\n/**\n * Converts a raw column value of type TIMESTAMP_NTZ to a Snowflake Date.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Date}\n */\nfunction convertRawTimestampNtz(rawColumnValue, column, context)\n{\n  var columnScale = column.getScale();\n\n  // the values might be big so use BigNumber to do arithmetic\n  var valFracSecsBig =\n    new BigNumber(rawColumnValue).times(Math.pow(10, columnScale));\n\n  // create a new snowflake date\n  return convertRawTimestampHelper(\n    valFracSecsBig,\n    columnScale,\n    'UTC',     // it's _ntz, so use UTC for timezone\n    context.format).toSfDate();\n}\n\n/**\n * Converts a raw column value of type TIMESTAMP_TZ to a Snowflake Date.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Date}\n */\nfunction convertRawTimestampTz(rawColumnValue, column, context)\n{\n  var valFracSecsBig;\n  var valFracSecsWithTzBig;\n  var timezoneBig;\n  var timezone;\n  var timestampAndTZIndex;\n\n  // compute the scale factor\n  var columnScale = column.getScale();\n  var scaleFactor = Math.pow(10, columnScale);\n\n  var resultVersion = context.resultVersion;\n  if (resultVersion === '0' || resultVersion === undefined)\n  {\n    // the values might be big so use BigNumber to do arithmetic\n    valFracSecsBig =\n      new BigNumber(rawColumnValue).times(scaleFactor);\n\n    // for _tz, the timezone is baked into the value\n    valFracSecsWithTzBig = valFracSecsBig;\n\n    // extract everything but the lowest 14 bits to get the fractional seconds\n    valFracSecsBig =\n      valFracSecsWithTzBig.dividedBy(16384).floor();\n\n    // extract the lowest 14 bits to get the timezone\n    if (valFracSecsWithTzBig.greaterThanOrEqualTo(0))\n    {\n      timezoneBig = valFracSecsWithTzBig.modulo(16384);\n    }\n    else\n    {\n      timezoneBig =\n        valFracSecsWithTzBig.modulo(16384).plus(16384);\n    }\n  }\n  else\n  {\n    // split the value into number of seconds and timezone index\n    timestampAndTZIndex = rawColumnValue.split(' ');\n\n    // the values might be big so use BigNumber to do arithmetic\n    valFracSecsBig =\n      new BigNumber(timestampAndTZIndex[0]).times(scaleFactor);\n\n    timezoneBig = new BigNumber(timestampAndTZIndex[1]);\n  }\n\n  timezone = timezoneBig.toNumber();\n\n  // assert that timezone is valid\n  Errors.assertInternal(timezone >= 0 && timezone <= 2880);\n\n  // subtract 24 hours from the timezone to map [0, 48] to\n  // [-24, 24], and convert the result to a number\n  timezone = timezone - 1440;\n\n  // create a new snowflake date\n  return convertRawTimestampHelper(\n    valFracSecsBig,\n    columnScale,\n    timezone,\n    context.format).toSfDate();\n}\n\n/**\n * Helper function for the convertRawTimestamp*() functions.\n * Returns an instance of SfTimestamp.\n *\n * @param {Object} epochFracSecsBig\n * @param {Number} scale\n * @param {String | Number} timezone\n * @param {String} format\n *\n * @returns {Object}\n */\nfunction convertRawTimestampHelper(\n  epochFracSecsBig,\n  scale,\n  timezone,\n  format)\n{\n  // compute the scale factor\n  var scaleFactor = Math.pow(10, scale);\n\n  // split the value into epoch seconds + nanoseconds; for example,\n  // 1365148923.123456789 will be split into 1365148923 (epoch seconds)\n  // and 123456789 (nano seconds)\n  var valSecBig = epochFracSecsBig.dividedBy(scaleFactor).floor();\n  var fractionsBig = epochFracSecsBig.minus(valSecBig.times(scaleFactor));\n  var valSecNanoBig = fractionsBig.times(Math.pow(10, 9 - scale));\n\n  // create a new snowflake date from the information\n  return new SfTimestamp(\n    valSecBig.toNumber(),\n    valSecNanoBig.toNumber(),\n    scale,\n    timezone,\n    format);\n}\n\n/**\n * Converts a raw column value of type Variant to a JavaScript value.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Object | Array}\n */\nfunction convertRawVariant(rawColumnValue, column, context)\n{\n  var ret;\n\n  // if the input is a non-empty string, convert it to a json object\n  if (Util.string.isNotNullOrEmpty(rawColumnValue))\n  {\n    try\n    {\n      ret = eval(\"(\" + rawColumnValue + \")\");\n    }\n    catch (parseError)\n    {\n      // check if raw string is in XML format\n      // ensure each tag is enclosed and all attributes and elements are valid\n      if (XMLValidator.validate(rawColumnValue) === true)\n      {\n        // use XML parser\n        ret = new XMLParser().parse(rawColumnValue);\n      }\n      else\n      {\n        // TODO: log the error\n\n        // throw the error\n        throw parseError;\n      }\n    }\n  }\n\n  return ret;\n}\n\n/**\n * Converts a raw column value of type Binary to a Buffer.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Buffer}\n */\nfunction convertRawBinary(rawColumnValue, column, context)\n{\n  // Ensure the format is valid.\n  var format = context.format.toUpperCase();\n  Errors.assertInternal(format === \"HEX\" || format === \"BASE64\");\n\n  // Decode hex string sent by GS.\n  var buffer = Buffer.from(rawColumnValue, \"HEX\");\n\n  if (format === \"HEX\")\n  {\n    buffer.toStringSf = function ()\n    {\n      // The raw value is already an uppercase hex string, so just return it.\n      // Note that buffer.toString(\"HEX\") returns a lowercase hex string, but we\n      // want upper case.\n      return rawColumnValue;\n    }\n  }\n  else\n  {\n    buffer.toStringSf = function ()\n    {\n      return this.toString(\"BASE64\");\n    }\n  }\n\n  buffer.getFormat = function ()\n  {\n    return format;\n  };\n\n  return buffer;\n}\n\n/**\n * Returns the input value as is.\n *\n * @param {*} value\n *\n * @returns {*}\n */\nfunction noop(value)\n{\n  return value;\n}\n\n/**\n * The toValue() function for a column of type Number.\n *\n * @param {*} columnValue\n *\n * @returns {Number}\n */\nfunction toValueFromNumber(columnValue)\n{\n  return columnValue ? columnValue.processed : columnValue;\n}\n\n/**\n * The toValue() function for a column of type Time.\n *\n * @param {*} columnValue\n *\n * @returns {String}\n */\nfunction toValueFromTime(columnValue)\n{\n  // there's no native javascript type that can be used to represent time, so\n  // just convert to string\n  return toStringFromTime(columnValue);\n}\n\n/**\n * The toString() function for a column of type Number.\n *\n * @param {Number} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromNumber(columnValue)\n{\n  return (columnValue !== null) ? columnValue.raw : NULL_UPPERCASE;\n}\n\n/**\n * The toString() function for a column of type Boolean.\n *\n * @param {Boolean} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromBoolean(columnValue)\n{\n  return (columnValue !== null) ? String(columnValue).toUpperCase() :\n    NULL_UPPERCASE;\n}\n\n/**\n * The toString() function for a column of type Date.\n *\n * @param {Date} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromDate(columnValue)\n{\n  return (columnValue !== null) ? columnValue.toJSON() : NULL_UPPERCASE;\n}\n\n/**\n * The toString() function for a column of type Time.\n *\n * @param {Object} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromTime(columnValue)\n{\n  return (columnValue !== null) ? columnValue.toJSON() : NULL_UPPERCASE;\n}\n\n/**\n * The toString() function for a column of type Timestamp.\n *\n * @param {Date} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromTimestamp(columnValue)\n{\n  return (columnValue !== null) ? columnValue.toJSON() : NULL_UPPERCASE;\n}\n\n/**\n * The toString() function for a column of type Variant.\n *\n * @param {Object} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromVariant(columnValue)\n{\n  return (columnValue !== null) ? JSON.stringify(columnValue) : NULL_UPPERCASE;\n}\n\n/**\n * The toString() function for a column of type String.\n *\n * @param {String} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromString(columnValue)\n{\n  return (columnValue !== null) ? columnValue : NULL_UPPERCASE;\n}\n\n/**\n * The toString() function for a column of type Binary.\n *\n * @param {Buffer} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromBinary(columnValue)\n{\n  return (columnValue !== null) ? columnValue.toStringSf() : NULL_UPPERCASE;\n}\n\n/**\n * Extracts the value of a column from a given row.\n *\n * @param {Object} row\n * @param {Object} context\n * @param {Boolean} asString\n *\n * @returns {*}\n */\nfunction extractFromRow(row, context, asString)\n{\n  var map = row._arrayProcessedColumns;\n  var values = row.values;\n\n  // get the value\n  var columnIndex = this.getIndex();\n  var ret = values[columnIndex];\n\n  // if we want the value as a string, and the column is of type variant, and we\n  // haven't already processed the value before, we don't need to process the\n  // value, so only process if none of the aforementioned conditions are true\n  if (!(asString && this.isVariant() && !map[columnIndex]))\n  {\n    // if the column value has not been processed yet, process it, put it back\n    // in the values array, and remember that the value has been processed\n    if (!map[columnIndex])\n    {\n      if (ret !== null)\n      {\n        ret = values[columnIndex] =\n          context.convert(values[columnIndex], this, context);\n      }\n      map[columnIndex] = true;\n    }\n\n    // use the appropriate extraction function depending on whether\n    // we want the value or a string representation of the value\n    var extractFn = !asString ? context.toValue : context.toString;\n    ret = extractFn(ret);\n  }\n\n  return ret;\n}\n\nmodule.exports = Column;\n", "{\n  \"name\": \"snowflake-sdk\",\n  \"version\": \"1.6.20\",\n  \"description\": \"Node.js driver for Snowflake\",\n  \"dependencies\": {\n    \"@azure/storage-blob\": \"^12.11.0\",\n    \"@techteamer/ocsp\": \"1.0.0\",\n    \"agent-base\": \"^6.0.2\",\n    \"asn1.js-rfc2560\": \"^5.0.0\",\n    \"asn1.js-rfc5280\": \"^3.0.0\",\n\t\"async\": \"^3.2.3\",\n    \"aws-sdk\": \"^2.878.0\",\n    \"axios\": \"^0.27.2\",\n    \"big-integer\": \"^1.6.43\",\n    \"bignumber.js\": \"^2.4.0\",\n    \"binascii\": \"0.0.2\",\n    \"browser-request\": \"^0.3.3\",\n    \"debug\": \"^3.2.6\",\n    \"expand-tilde\": \"^2.0.2\",\n    \"extend\": \"^3.0.2\",\n    \"fast-xml-parser\": \"^4.1.3\",\n    \"generic-pool\": \"^3.8.2\",\n    \"@google-cloud/storage\": \"^6.9.3\",\n    \"glob\": \"^7.1.6\",\n    \"jsonwebtoken\": \"^9.0.0\",\n    \"mime-types\": \"^2.1.29\",\n    \"mkdirp\": \"^1.0.3\",\n    \"mock-require\": \"^3.0.3\",\n    \"moment\": \"^2.29.4\",\n    \"moment-timezone\": \"^0.5.15\",\n    \"open\": \"^7.3.1\",\n    \"python-struct\": \"^1.1.3\",\n    \"simple-lru-cache\": \"^0.0.2\",\n    \"string-similarity\": \"^4.0.4\",\n    \"test-console\": \"^2.0.0\",\n    \"tmp\": \"^0.2.1\",\n    \"urllib\": \"^2.38.0\",\n    \"uuid\": \"^3.3.2\",\n    \"winston\": \"^3.1.0\"\n  },\n  \"devDependencies\": {\n    \"qs\": \"^6.10.3\",\n    \"mocha\": \"^10.1.0\"\n  },\n  \"overrides\": {\n    \"@azure/storage-blob\": {\n      \"node-fetch\": \"^3.2.10\"\n    }\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/snowflakedb/snowflake-connector-nodejs\"\n  },\n  \"scripts\": {\n    \"test\": \"mocha test/unit/**/*.js\"\n  },\n  \"author\": {\n    \"name\": \"Snowflake Computing, Inc.\",\n    \"email\": \"support@snowflake.com\",\n    \"url\": \"https://www.snowflake.com/\"\n  },\n  \"license\": \"Apache-2.0\"\n}\n", "/*\n * Copyright (c) 2015-2019 Snowflake Computing Inc. All rights reserved.\n */\nvar async = require('async');\nvar testUtil = require('./testUtil');\nconst sharedStatement = require('./sharedStatements');\nvar bigInt = require(\"big-integer\");\n\ndescribe('Test DataType', function ()\n{\n  var connection;\n  var createTableWithString = 'create or replace table testString(colA string)';\n  var createTableWithVariant = 'create or replace table testVariant(colA variant)';\n  var createTableWithArray = 'create or replace table testArray(colA array)';\n  var createTableWithNumber = 'create or replace table testNumber(colA number)';\n  var createTableWithDouble = 'create or replace table testDouble(colA double)';\n  var createTableWithDate = 'create or replace table testDate(colA date)';\n  var createTableWithTime = 'create or replace table testTime(colA time)';\n  var createTableWithTimestamp = 'create or replace table testTimestamp(colA timestamp_ltz, ' +\n    'colB timestamp_tz, colC timestamp_ntz)';\n  var createTableWithBoolean = 'create or replace table testBoolean(colA boolean, colB boolean, colC boolean)';\n  var dropTableWithString = 'drop table if exists testString';\n  var dropTableWithVariant = 'drop table if exists testVariant';\n  var dropTableWithArray = 'drop table if exists testArray';\n  var dropTableWithNumber = 'drop table if exists testNumber';\n  var dropTableWithDouble = 'drop table if exists testDouble';\n  var dropTableWithDate = 'drop table if exists testDate';\n  var dropTableWithTime = 'drop table if exists testTime';\n  var dropTableWithTimestamp = 'drop table if exists testTimestamp';\n  var dropTableWithBoolean = 'drop table if exists testBoolean';\n  var insertDouble = 'insert into testDouble values(123.456)';\n  var insertLargeNumber = 'insert into testNumber values (12345678901234567890123456789012345678)';\n  var insertRegularSizedNumber = 'insert into testNumber values (100000001)';\n  var insertVariant = 'insert into testVariant select parse_json(\\'{a : 1 , b :[1 , 2 , 3, -Infinity, undefined], c : {a : 1}}\\')';\n  var insertArray = 'insert into testArray select parse_json(\\'[\"a\", 1]\\')';\n  var insertDate = 'insert into testDate values(to_date(\\'2012-11-11\\'))';\n  var insertTime = 'insert into testTime values(to_time(\\'12:34:56.789789789\\'))';\n  var insertTimestamp = 'insert into testTimestamp values(to_timestamp_ltz('\n    + '\\'Thu, 21 Jan 2016 06:32:44 -0800\\'), to_timestamp_tz(\\'Thu, 21 Jan 2016 06:32:44 -0800\\'), '\n    + 'to_timestamp_ntz(\\'Thu, 21 Jan 2016 06:32:44 -0800\\'))';\n  var insertBoolean = 'insert into testBoolean values(true, false, null)';\n  var insertString = 'insert into testString values(\\'string with space\\')';\n  var selectDouble = 'select * from testDouble';\n  var selectNumber = 'select * from testNumber';\n  var selectVariant = 'select * from testVariant';\n  var selectArray = 'select * from testArray';\n  var selectDate = 'select * from testDate';\n  var selectTime = 'select * from testTime';\n  var selectTimestamp = 'select * from testTimestamp';\n  var selectBoolean = 'select * from testBoolean';\n  var selectString = 'select * from testString';\n\n  before(function (done)\n  {\n    connection = testUtil.createConnection();\n    async.series([\n        function (callback)\n        {\n          testUtil.connect(connection, callback);\n        }],\n      done\n    );\n  });\n\n  after(function (done)\n  {\n    async.series([\n        function (callback)\n        {\n          testUtil.executeCmd(connection, dropTableWithString, callback);\n        },\n        function (callback)\n        {\n          testUtil.executeCmd(connection, dropTableWithVariant, callback);\n        },\n        function (callback)\n        {\n          testUtil.executeCmd(connection, dropTableWithArray, callback);\n        },\n        function (callback)\n        {\n          testUtil.executeCmd(connection, dropTableWithNumber, callback);\n        },\n        function (callback)\n        {\n          testUtil.executeCmd(connection, dropTableWithDouble, callback);\n        },\n        function (callback)\n        {\n          testUtil.executeCmd(connection, dropTableWithDate, callback);\n        },\n        function (callback)\n        {\n          testUtil.executeCmd(connection, dropTableWithTime, callback);\n        },\n        function (callback)\n        {\n          testUtil.executeCmd(connection, dropTableWithTimestamp, callback);\n        },\n        function (callback)\n        {\n          testUtil.executeCmd(connection, dropTableWithBoolean, callback);\n        },\n        function (callback)\n        {\n          testUtil.destroyConnection(connection, callback);\n        }],\n      done\n    );\n  });\n\n  describe('testNumber', function ()\n  {\n    it('testDouble', function (done)\n    {\n      async.series([\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithDouble, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertDouble, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectDouble,\n              [{'COLA': 123.456}],\n              callback\n            );\n          }],\n        done\n      );\n    });\n\n    it('testLargeNumber', function (done)\n    {\n      async.series([\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithNumber, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertLargeNumber, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectNumber,\n              [{'COLA': 12345678901234567890123456789012345678}],\n              callback\n            );\n          }],\n        done\n      );\n    });\n\n    it('testLargeNumberBigInt', function (done)\n    {\n      async.series([\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithNumber, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertLargeNumber, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, \"alter session set JS_TREAT_INTEGER_AS_BIGINT=true\", callback)\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectNumber,\n              [{'COLA': bigInt(\"12345678901234567890123456789012345678\")}],\n              callback,\n              null,\n              false\n            );\n          }],\n        done\n      );\n    });\n\n    it('testRegularSizedInteger', function (done)\n    {\n      async.series([\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithNumber, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertRegularSizedNumber, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectNumber,\n              [{'COLA': 100000001}],\n              callback\n            );\n          }],\n        done\n      );\n    });\n  });\n\n  describe('testSemiStructuredDataType', function ()\n  {\n    it('testVariant', function (done)\n    {\n      async.series(\n        [\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithVariant, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertVariant, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectVariant,\n              [{'COLA': {a: 1, b: [1, 2, 3, -Infinity, undefined], c: {a: 1}}}],\n              callback\n            );\n          }],\n        done\n      );\n    });\n\n    it('testArray', function (done)\n    {\n      async.series(\n        [\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithArray, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertArray, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectArray,\n              [{'COLA': ['a', 1]}],\n              callback\n            );\n          }],\n        done\n      );\n    });\n  });\n\n  describe('testDateTime', function ()\n  {\n    it('testDate', function (done)\n    {\n      async.series(\n        [\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithDate, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertDate, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectDate,\n              [{'COLA': '2012-11-11'}],\n              callback\n            );\n          }],\n        done\n      );\n    });\n\n    it('testTime', function (done)\n    {\n      async.series(\n        [\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithTime, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertTime, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectTime,\n              [{'COLA': '12:34:56'}],\n              callback\n            );\n          }],\n        done\n      );\n    });\n\n    it('testTimestamp', function (done)\n    {\n      async.series(\n        [\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithTimestamp, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertTimestamp, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, sharedStatement.setTimezoneAndTimestamps, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectTimestamp,\n              [{\n                'COLA': '2016-01-21 06:32:44.000 -0800',\n                'COLB': '2016-01-21 06:32:44.000 -0800',\n                'COLC': '2016-01-21 06:32:44.000'\n              }],\n              callback\n            );\n          }],\n        done\n      );\n    });\n  });\n\n  describe('testBoolean', function ()\n  {\n    it('testTrue', function (done)\n    {\n      async.series(\n        [\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithBoolean, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertBoolean, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectBoolean,\n              [{\n                'COLA': true,\n                'COLB': false,\n                'COLC': null\n              }],\n              callback\n            );\n          }],\n        done\n      );\n    });\n  });\n\n  describe('testText', function ()\n  {\n    it('testString', function (done)\n    {\n      async.series(\n        [\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithString, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertString, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectString,\n              [{'COLA': 'string with space'}],\n              callback\n            );\n          }],\n        done\n      );\n    });\n  });\n});\n", "/*\n * Copyright (c) 2015-2019 Snowflake Computing Inc. All rights reserved.\n */\nvar snowflake = require('./../../lib/snowflake');\nvar connOptions = require('./connectionOptions');\nvar assert = require('assert');\n\nmodule.exports.createConnection = function ()\n{\n  return snowflake.createConnection(connOptions.valid);\n};\n\nmodule.exports.connect = function (connection, callback)\n{\n  connection.connect(function (err)\n  {\n    assert.ok(!err, JSON.stringify(err));\n    callback();\n  });\n};\n\nmodule.exports.destroyConnection = function (connection, callback)\n{\n  connection.destroy(function (err)\n  {\n    assert.ok(!err, JSON.stringify(err));\n    callback();\n  })\n};\n\nmodule.exports.executeCmd = function (connection, sql, callback, bindArray)\n{\n  var executeOptions = {};\n  executeOptions.sqlText = sql;\n  executeOptions.complete = function (err)\n  {\n    assert.ok(!err, JSON.stringify(err));\n    callback();\n  };\n\n  if (bindArray !== undefined && bindArray != null)\n  {\n    executeOptions.binds = bindArray;\n  }\n\n  connection.execute(executeOptions);\n};\n\nmodule.exports.checkError = function (err)\n{\n  assert.ok(!err, JSON.stringify(err));\n};\n\nmodule.exports.executeQueryAndVerify = function (connection, sql, expected, callback, bindArray, normalize)\n{\n  // Sometimes we may not want to normalize the row first\n  normalize = (typeof normalize !== \"undefined\" && normalize != null) ? normalize : true;\n  var executeOptions = {};\n  executeOptions.sqlText = sql;\n  executeOptions.complete = function (err, stmt)\n  {\n    assert.ok(!err, JSON.stringify(err));\n    var rowCount = 0;\n    var stream = stmt.streamRows();\n    stream.on('readable', function ()\n    {\n      var row;\n      while ((row = stream.read()) !== null)\n      {\n        assert.deepStrictEqual(normalize ? normalizeRowObject(row) : row, expected[rowCount]);\n        rowCount++;\n      }\n    });\n    stream.on('error', function (err)\n    {\n      assert.ok(!err, JSON.stringify(err));\n    });\n    stream.on('end', function ()\n    {\n      assert.strictEqual(rowCount, expected.length);\n      callback();\n    });\n  };\n  if (bindArray != null && bindArray != undefined)\n  {\n    executeOptions.binds = bindArray;\n  }\n\n  connection.execute(executeOptions);\n};\n\nfunction normalizeRowObject(row)\n{\n  var normalizedRow = {};\n  for (var key in row)\n  {\n    if (row.hasOwnProperty(key))\n    {\n      var convertToString = (row[key] !== null) && (row[key] !== undefined)\n        && (typeof row[key].toJSON === 'function');\n      var convertToJSNumber = (row[key] !== null) && (row[key] !== undefined)\n        && (typeof row[key].toJSNumber === 'function');\n      // If this is a bigInt type then convert to JS Number instead of string JSON representation\n      if (convertToJSNumber)\n      {\n        normalizedRow[key] = row[key].toJSNumber();\n      }\n      else if (convertToString)\n      {\n        normalizedRow[key] = row[key].toJSON();\n      }\n      else\n      {\n        normalizedRow[key] = row[key];\n      }\n    }\n  }\n  return normalizedRow;\n}\n\n\n\n", "/*\n * Copyright (c) 2015-2019 Snowflake Computing Inc. All rights reserved.\n */\n\nvar assert = require('assert');\nvar ResultTestCommon = require('./result_test_common');\n\ndescribe('Result: test variant', function ()\n{\n  it(\"select to_variant((parse_json('{ a : 1 }'))) as C1, \" +\n    \"to_object(parse_json('{ a : 1 }')) as C2, \" +\n    \"to_array(parse_json('[1, 2]')) as C3;\",\n    function (done)\n    {\n      var response =\n        {\n          \"data\": {\n            \"parameters\": [{\"name\": \"TIMEZONE\", \"value\": \"America/Los_Angeles\"}, {\n              \"name\": \"TIMESTAMP_OUTPUT_FORMAT\", \"value\": \"DY, DD MON YYYY HH24:MI:SS TZHTZM\"\n            }, {\"name\": \"TIMESTAMP_NTZ_OUTPUT_FORMAT\", \"value\": \"\"}, {\n              \"name\": \"TIMESTAMP_LTZ_OUTPUT_FORMAT\", \"value\": \"\"\n            }, {\"name\": \"TIMESTAMP_TZ_OUTPUT_FORMAT\", \"value\": \"\"}, {\n              \"name\": \"DATE_OUTPUT_FORMAT\", \"value\": \"YYYY-MM-DD\"\n            }, {\"name\": \"CLIENT_RESULT_PREFETCH_SLOTS\", \"value\": 2}, {\n              \"name\": \"CLIENT_RESULT_PREFETCH_THREADS\", \"value\": 1\n            }, {\"name\": \"CLIENT_HONOR_CLIENT_TZ_FOR_TIMESTAMP_NTZ\", \"value\": true}, {\n              \"name\": \"CLIENT_USE_V1_QUERY_API\", \"value\": true\n            }],\n            \"rowtype\": [{\n              \"name\": \"C1\", \"byteLength\": 16777216, \"nullable\": true, \"precision\": null, \"scale\": null,\n              \"length\": 16777216, \"type\": \"variant\"\n            }, {\n              \"name\": \"C2\", \"byteLength\": 16777216, \"nullable\": true, \"precision\": null, \"scale\": null,\n              \"length\": 16777216, \"type\": \"object\"\n            }, {\n              \"name\": \"C3\", \"byteLength\": 16777216, \"nullable\": true, \"precision\": null, \"scale\": null,\n              \"length\": 16777216, \"type\": \"array\"\n            }],\n            \"rowset\": [[\"{\\n  \\\"a\\\": 1\\n}\", \"{\\n  \\\"a\\\": 1\\n}\", \"[\\n  1,\\n  2\\n]\"]],\n            \"total\": 1,\n            \"returned\": 1,\n            \"queryId\": \"34d7c2d2-33ff-416d-a3bc-0b897daec56b\",\n            \"databaseProvider\": null,\n            \"finalDatabaseName\": null,\n            \"finalSchemaName\": null,\n            \"finalWarehouseName\": \"NEW_WH\",\n            \"finalRoleName\": \"ACCOUNTADMIN\",\n            \"numberOfBinds\": 0,\n            \"statementTypeId\": 4096,\n            \"version\": 0\n          },\n          \"message\": null,\n          \"code\": null,\n          \"success\": true\n        };\n\n      ResultTestCommon.testResult(\n        ResultTestCommon.createResultOptions(response),\n        function (row)\n        {\n          // variant\n          assert.deepStrictEqual(row.getColumnValue('C1'), {a: 1});\n          assert.strictEqual(\n            row.getColumnValueAsString('C1'), JSON.stringify({a: 1}));\n\n          // object\n          assert.deepStrictEqual(row.getColumnValue('C2'), {a: 1});\n          assert.strictEqual(\n            row.getColumnValueAsString('C2'), JSON.stringify({a: 1}));\n\n          // array\n          assert.deepStrictEqual(row.getColumnValue('C3'), [1, 2]);\n          assert.strictEqual(\n            row.getColumnValueAsString('C3'), JSON.stringify([1, 2]));\n        },\n        function (result)\n        {\n          done();\n        }\n      );\n    });\n});"], "fixing_code": ["/*\n * Copyright (c) 2015-2019 Snowflake Computing Inc. All rights reserved.\n */\n\nvar Util = require('../../util');\nvar Errors = require('../../errors');\nvar BigNumber = require('bignumber.js');\nvar SfTimestamp = require('./sf_timestamp');\nvar SqlTypes = require('./data_types').SqlTypes;\nvar bigInt = require('big-integer');\nvar { XMLParser, XMLValidator } = require(\"fast-xml-parser\");\nvar betterEval = require(\"better-eval\");\n\nvar NULL_UPPERCASE = 'NULL';\n\n/**\n * Creates a new Column.\n *\n * @param {Object} options\n * @param {Number} index\n * @param {Object} statementParameters\n * @param {String} resultVersion\n *\n * @constructor\n */\nfunction Column(options, index, statementParameters, resultVersion)\n{\n  var name = options.name;\n  var nullable = options.nullable;\n  var scale = options.scale;\n  var type = options.type;\n  var precision = options.precision;\n\n  /**\n   * Returns the name of this column.\n   *\n   * @return {String}\n   */\n  this.getName = function ()\n  {\n    return name;\n  };\n\n  /**\n   * Returns the index of this column.\n   *\n   * @return {Number}\n   */\n  this.getIndex = function ()\n  {\n    return index;\n  };\n\n  /**\n   * Returns the id of this column.\n   *\n   * @return {Number}\n   */\n  this.getId = function ()\n  {\n    // use the index as the id for now\n    return index;\n  };\n\n  /**\n   * Determines if this column is nullable.\n   *\n   * @returns {Boolean}\n   */\n  this.isNullable = function ()\n  {\n    return nullable;\n  };\n\n  /**\n   * Returns the scale associated with this column.\n   *\n   * @returns {Number}\n   */\n  this.getScale = function ()\n  {\n    return scale;\n  };\n\n  /**\n   * Returns the type associated with this column.\n   *\n   * @returns {String}\n   */\n  this.getType = function ()\n  {\n    return type;\n  };\n\n  /**\n   * Returns the precision associated with this column\n   *\n   * @returns {Number}\n   */\n  this.getPrecision = function ()\n  {\n    return precision;\n  };\n\n  // add methods that make it easy to check if the column is of a specific type\n  this.isString = createFnIsColumnOfType(type, SqlTypes.isString, SqlTypes);\n  this.isBinary = createFnIsColumnOfType(type, SqlTypes.isBinary, SqlTypes);\n  this.isNumber = createFnIsColumnOfType(type, SqlTypes.isNumber, SqlTypes);\n  this.isBoolean = createFnIsColumnOfType(type, SqlTypes.isBoolean, SqlTypes);\n  this.isDate = createFnIsColumnOfType(type, SqlTypes.isDate, SqlTypes);\n  this.isTime = createFnIsColumnOfType(type, SqlTypes.isTime, SqlTypes);\n  this.isTimestamp = createFnIsColumnOfType(type, SqlTypes.isTimestamp, SqlTypes);\n  this.isTimestampLtz = createFnIsColumnOfType(type, SqlTypes.isTimestampLtz, SqlTypes);\n  this.isTimestampNtz = createFnIsColumnOfType(type, SqlTypes.isTimestampNtz, SqlTypes);\n  this.isTimestampTz = createFnIsColumnOfType(type, SqlTypes.isTimestampTz, SqlTypes);\n  this.isVariant = createFnIsColumnOfType(type, SqlTypes.isVariant, SqlTypes);\n  this.isObject = createFnIsColumnOfType(type, SqlTypes.isObject, SqlTypes);\n  this.isArray = createFnIsColumnOfType(type, SqlTypes.isArray, SqlTypes);\n\n  var convert;\n  var toString;\n  var toValue;\n  var format;\n\n  if (this.isNumber())\n  {\n    let integerAs = statementParameters['JS_TREAT_INTEGER_AS_BIGINT'];\n    if (!integerAs)\n    {\n      convert = convertRawNumber;\n    }\n    else\n    {\n      if (this.getScale() > 0 || this.getType() === SqlTypes.values.REAL)\n      {\n        convert = convertRawNumber;\n      }\n      // This is a integer so represent it as a big int\n      else\n      {\n        convert = convertRawBigInt;\n      }\n    }\n    toValue = toValueFromNumber;\n    toString = toStringFromNumber;\n  }\n  else if (this.isTime())\n  {\n    convert = convertRawTime;\n    toValue = toValueFromTime;\n    toString = toStringFromTime;\n    format = statementParameters['TIME_OUTPUT_FORMAT'];\n  }\n  else\n  {\n    toValue = noop;\n\n    if (this.isBoolean())\n    {\n      convert = convertRawBoolean;\n      toString = toStringFromBoolean;\n    }\n    else if (this.isDate())\n    {\n      convert = convertRawDate;\n      toString = toStringFromDate;\n      format = statementParameters['DATE_OUTPUT_FORMAT'];\n    }\n    else if (this.isTimestamp())\n    {\n      if (this.isTimestampLtz())\n      {\n        convert = convertRawTimestampLtz;\n        toString = toStringFromTimestamp;\n        format = statementParameters['TIMESTAMP_LTZ_OUTPUT_FORMAT'];\n      }\n      else if (this.isTimestampNtz())\n      {\n        convert = convertRawTimestampNtz;\n        toString = toStringFromTimestamp;\n        format = statementParameters['TIMESTAMP_NTZ_OUTPUT_FORMAT'];\n      }\n      else if (this.isTimestampTz())\n      {\n        convert = convertRawTimestampTz;\n        toString = toStringFromTimestamp;\n        format = statementParameters['TIMESTAMP_TZ_OUTPUT_FORMAT'];\n      }\n\n      // if we don't have a type-specific timezone, use the default format\n      if (!format)\n      {\n        format = statementParameters['TIMESTAMP_OUTPUT_FORMAT'];\n      }\n    }\n    else if (this.isBinary())\n    {\n      convert = convertRawBinary;\n      toString = toStringFromBinary;\n      format = statementParameters['BINARY_OUTPUT_FORMAT'];\n    }\n    else if (this.isVariant())\n    {\n      convert = convertRawVariant;\n      toString = toStringFromVariant;\n    }\n    else\n    {\n      // column is of type string, so leave value as is\n      convert = noop;\n      toString = toStringFromString;\n    }\n  }\n\n  // create a private context to pass to the extract function\n  var context =\n    {\n      convert: convert,\n      toValue: toValue,\n      toString: toString,\n      format: format,\n      resultVersion: resultVersion,\n      statementParameters: statementParameters\n    };\n\n  /**\n   * Returns the value of this column in a row.\n   *\n   * @param {Object} row\n   *\n   * @returns {*}\n   */\n  this.getRowValue = function (row)\n  {\n    return extractFromRow.call(this, row, context, false);\n  };\n\n  /**\n   * Returns the value of this in a row as a String.\n   *\n   * @param {Object} row\n   *\n   * @returns {String}\n   */\n  this.getRowValueAsString = function (row)\n  {\n    return extractFromRow.call(this, row, context, true);\n  };\n}\n\n/**\n * Returns a function that can be used to determine if a column is of a given\n * type.\n *\n * @param {String} columnType the column type.\n * @param {Function} columnComparisonFn the column comparison function.\n * @param {Object} scope the scope in which to invoke the column comparison\n *   function.\n *\n * @returns {Function}\n */\nfunction createFnIsColumnOfType(columnType, columnComparisonFn, scope)\n{\n  return function ()\n  {\n    return columnComparisonFn.call(scope, columnType);\n  };\n}\n\n/**\n * Converts a raw column value of type Number. The returned value is an object\n * that contains the raw string version of the value as well as the\n * post-processed version of the value obtained after casting to Number.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Object}\n */\nfunction convertRawNumber(rawColumnValue, column, context)\n{\n  return {\n    raw: rawColumnValue,\n    processed: Number(rawColumnValue)\n  };\n}\n\n/**\n * Converts a raw column value that is an integer. The returned value is an object\n * that contains the raw string version of the value as well as the post-processed\n * version of the value obtained after casting to bigInt\n *\n * @param rawColumnValue\n * @param column\n * @param context\n * @returns {{processed: bigInt.BigInteger, raw: *}}\n */\nfunction convertRawBigInt(rawColumnValue, column, context)\n{\n  return {\n    raw: rawColumnValue,\n    processed: bigInt(rawColumnValue)\n  };\n}\n\n/**\n * Converts a raw column value of type Boolean to a boolean (true, false,\n * or null).\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Boolean}\n */\nfunction convertRawBoolean(rawColumnValue, column, context)\n{\n  var ret;\n\n  if ((rawColumnValue === '1') || (rawColumnValue === 'TRUE'))\n  {\n    ret = true;\n  }\n  else if ((rawColumnValue === '0') || (rawColumnValue === 'FALSE'))\n  {\n    ret = false;\n  }\n\n  return ret;\n}\n\n/**\n * Converts a raw column value of type Date to a Snowflake Date.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Date}\n */\nfunction convertRawDate(rawColumnValue, column, context)\n{\n  return new SfTimestamp(\n    Number(rawColumnValue) * 86400, // convert to seconds\n    0,                              // no nano seconds\n    0,                              // no scale required\n    'UTC',                          // use utc as the timezone\n    context.format).toSfDate();\n}\n\n/**\n * Converts a raw column value of type Time to a Snowflake Time.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Object}\n */\nfunction convertRawTime(rawColumnValue, column, context)\n{\n  var columnScale = column.getScale();\n\n  // the values might be big so use BigNumber to do arithmetic\n  var valFracSecsBig =\n    new BigNumber(rawColumnValue).times(Math.pow(10, columnScale));\n\n  return convertRawTimestampHelper(\n    valFracSecsBig,\n    columnScale,\n    'UTC',\n    context.format).toSfTime();\n}\n\n/**\n * Converts a raw column value of type TIMESTAMP_LTZ to a Snowflake Date.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Date}\n */\nfunction convertRawTimestampLtz(rawColumnValue, column, context)\n{\n  var columnScale = column.getScale();\n\n  // the values might be big so use BigNumber to do arithmetic\n  var valFracSecsBig =\n    new BigNumber(rawColumnValue).times(Math.pow(10, columnScale));\n\n  // create a new snowflake date\n  return convertRawTimestampHelper(\n    valFracSecsBig,\n    columnScale,\n    context.statementParameters['TIMEZONE'],\n    context.format).toSfDate();\n}\n\n/**\n * Converts a raw column value of type TIMESTAMP_NTZ to a Snowflake Date.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Date}\n */\nfunction convertRawTimestampNtz(rawColumnValue, column, context)\n{\n  var columnScale = column.getScale();\n\n  // the values might be big so use BigNumber to do arithmetic\n  var valFracSecsBig =\n    new BigNumber(rawColumnValue).times(Math.pow(10, columnScale));\n\n  // create a new snowflake date\n  return convertRawTimestampHelper(\n    valFracSecsBig,\n    columnScale,\n    'UTC',     // it's _ntz, so use UTC for timezone\n    context.format).toSfDate();\n}\n\n/**\n * Converts a raw column value of type TIMESTAMP_TZ to a Snowflake Date.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Date}\n */\nfunction convertRawTimestampTz(rawColumnValue, column, context)\n{\n  var valFracSecsBig;\n  var valFracSecsWithTzBig;\n  var timezoneBig;\n  var timezone;\n  var timestampAndTZIndex;\n\n  // compute the scale factor\n  var columnScale = column.getScale();\n  var scaleFactor = Math.pow(10, columnScale);\n\n  var resultVersion = context.resultVersion;\n  if (resultVersion === '0' || resultVersion === undefined)\n  {\n    // the values might be big so use BigNumber to do arithmetic\n    valFracSecsBig =\n      new BigNumber(rawColumnValue).times(scaleFactor);\n\n    // for _tz, the timezone is baked into the value\n    valFracSecsWithTzBig = valFracSecsBig;\n\n    // extract everything but the lowest 14 bits to get the fractional seconds\n    valFracSecsBig =\n      valFracSecsWithTzBig.dividedBy(16384).floor();\n\n    // extract the lowest 14 bits to get the timezone\n    if (valFracSecsWithTzBig.greaterThanOrEqualTo(0))\n    {\n      timezoneBig = valFracSecsWithTzBig.modulo(16384);\n    }\n    else\n    {\n      timezoneBig =\n        valFracSecsWithTzBig.modulo(16384).plus(16384);\n    }\n  }\n  else\n  {\n    // split the value into number of seconds and timezone index\n    timestampAndTZIndex = rawColumnValue.split(' ');\n\n    // the values might be big so use BigNumber to do arithmetic\n    valFracSecsBig =\n      new BigNumber(timestampAndTZIndex[0]).times(scaleFactor);\n\n    timezoneBig = new BigNumber(timestampAndTZIndex[1]);\n  }\n\n  timezone = timezoneBig.toNumber();\n\n  // assert that timezone is valid\n  Errors.assertInternal(timezone >= 0 && timezone <= 2880);\n\n  // subtract 24 hours from the timezone to map [0, 48] to\n  // [-24, 24], and convert the result to a number\n  timezone = timezone - 1440;\n\n  // create a new snowflake date\n  return convertRawTimestampHelper(\n    valFracSecsBig,\n    columnScale,\n    timezone,\n    context.format).toSfDate();\n}\n\n/**\n * Helper function for the convertRawTimestamp*() functions.\n * Returns an instance of SfTimestamp.\n *\n * @param {Object} epochFracSecsBig\n * @param {Number} scale\n * @param {String | Number} timezone\n * @param {String} format\n *\n * @returns {Object}\n */\nfunction convertRawTimestampHelper(\n  epochFracSecsBig,\n  scale,\n  timezone,\n  format)\n{\n  // compute the scale factor\n  var scaleFactor = Math.pow(10, scale);\n\n  // split the value into epoch seconds + nanoseconds; for example,\n  // 1365148923.123456789 will be split into 1365148923 (epoch seconds)\n  // and 123456789 (nano seconds)\n  var valSecBig = epochFracSecsBig.dividedBy(scaleFactor).floor();\n  var fractionsBig = epochFracSecsBig.minus(valSecBig.times(scaleFactor));\n  var valSecNanoBig = fractionsBig.times(Math.pow(10, 9 - scale));\n\n  // create a new snowflake date from the information\n  return new SfTimestamp(\n    valSecBig.toNumber(),\n    valSecNanoBig.toNumber(),\n    scale,\n    timezone,\n    format);\n}\n\n/**\n * Converts a raw column value of type Variant to a JavaScript value.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Object | Array}\n */\nfunction convertRawVariant(rawColumnValue, column, context)\n{\n  var ret;\n\n  // if the input is a non-empty string, convert it to a json object\n  if (Util.string.isNotNullOrEmpty(rawColumnValue))\n  {\n    try\n    {\n      ret = betterEval(\"(\" + rawColumnValue + \")\");\n    }\n    catch (parseError)\n    {\n      // check if raw string is in XML format\n      // ensure each tag is enclosed and all attributes and elements are valid\n      if (XMLValidator.validate(rawColumnValue) === true)\n      {\n        // use XML parser\n        ret = new XMLParser().parse(rawColumnValue);\n      }\n      else\n      {\n        // TODO: log the error\n\n        // throw the error\n        throw parseError;\n      }\n    }\n  }\n\n  return ret;\n}\n\n/**\n * Converts a raw column value of type Binary to a Buffer.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Buffer}\n */\nfunction convertRawBinary(rawColumnValue, column, context)\n{\n  // Ensure the format is valid.\n  var format = context.format.toUpperCase();\n  Errors.assertInternal(format === \"HEX\" || format === \"BASE64\");\n\n  // Decode hex string sent by GS.\n  var buffer = Buffer.from(rawColumnValue, \"HEX\");\n\n  if (format === \"HEX\")\n  {\n    buffer.toStringSf = function ()\n    {\n      // The raw value is already an uppercase hex string, so just return it.\n      // Note that buffer.toString(\"HEX\") returns a lowercase hex string, but we\n      // want upper case.\n      return rawColumnValue;\n    }\n  }\n  else\n  {\n    buffer.toStringSf = function ()\n    {\n      return this.toString(\"BASE64\");\n    }\n  }\n\n  buffer.getFormat = function ()\n  {\n    return format;\n  };\n\n  return buffer;\n}\n\n/**\n * Returns the input value as is.\n *\n * @param {*} value\n *\n * @returns {*}\n */\nfunction noop(value)\n{\n  return value;\n}\n\n/**\n * The toValue() function for a column of type Number.\n *\n * @param {*} columnValue\n *\n * @returns {Number}\n */\nfunction toValueFromNumber(columnValue)\n{\n  return columnValue ? columnValue.processed : columnValue;\n}\n\n/**\n * The toValue() function for a column of type Time.\n *\n * @param {*} columnValue\n *\n * @returns {String}\n */\nfunction toValueFromTime(columnValue)\n{\n  // there's no native javascript type that can be used to represent time, so\n  // just convert to string\n  return toStringFromTime(columnValue);\n}\n\n/**\n * The toString() function for a column of type Number.\n *\n * @param {Number} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromNumber(columnValue)\n{\n  return (columnValue !== null) ? columnValue.raw : NULL_UPPERCASE;\n}\n\n/**\n * The toString() function for a column of type Boolean.\n *\n * @param {Boolean} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromBoolean(columnValue)\n{\n  return (columnValue !== null) ? String(columnValue).toUpperCase() :\n    NULL_UPPERCASE;\n}\n\n/**\n * The toString() function for a column of type Date.\n *\n * @param {Date} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromDate(columnValue)\n{\n  return (columnValue !== null) ? columnValue.toJSON() : NULL_UPPERCASE;\n}\n\n/**\n * The toString() function for a column of type Time.\n *\n * @param {Object} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromTime(columnValue)\n{\n  return (columnValue !== null) ? columnValue.toJSON() : NULL_UPPERCASE;\n}\n\n/**\n * The toString() function for a column of type Timestamp.\n *\n * @param {Date} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromTimestamp(columnValue)\n{\n  return (columnValue !== null) ? columnValue.toJSON() : NULL_UPPERCASE;\n}\n\n/**\n * The toString() function for a column of type Variant.\n *\n * @param {Object} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromVariant(columnValue)\n{\n  return (columnValue !== null) ? JSON.stringify(columnValue) : NULL_UPPERCASE;\n}\n\n/**\n * The toString() function for a column of type String.\n *\n * @param {String} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromString(columnValue)\n{\n  return (columnValue !== null) ? columnValue : NULL_UPPERCASE;\n}\n\n/**\n * The toString() function for a column of type Binary.\n *\n * @param {Buffer} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromBinary(columnValue)\n{\n  return (columnValue !== null) ? columnValue.toStringSf() : NULL_UPPERCASE;\n}\n\n/**\n * Extracts the value of a column from a given row.\n *\n * @param {Object} row\n * @param {Object} context\n * @param {Boolean} asString\n *\n * @returns {*}\n */\nfunction extractFromRow(row, context, asString)\n{\n  var map = row._arrayProcessedColumns;\n  var values = row.values;\n\n  // get the value\n  var columnIndex = this.getIndex();\n  var ret = values[columnIndex];\n\n  // if we want the value as a string, and the column is of type variant, and we\n  // haven't already processed the value before, we don't need to process the\n  // value, so only process if none of the aforementioned conditions are true\n  if (!(asString && this.isVariant() && !map[columnIndex]))\n  {\n    // if the column value has not been processed yet, process it, put it back\n    // in the values array, and remember that the value has been processed\n    if (!map[columnIndex])\n    {\n      if (ret !== null)\n      {\n        ret = values[columnIndex] =\n          context.convert(values[columnIndex], this, context);\n      }\n      map[columnIndex] = true;\n    }\n\n    // use the appropriate extraction function depending on whether\n    // we want the value or a string representation of the value\n    var extractFn = !asString ? context.toValue : context.toString;\n    ret = extractFn(ret);\n  }\n\n  return ret;\n}\n\nmodule.exports = Column;\n", "{\n  \"name\": \"snowflake-sdk\",\n  \"version\": \"1.6.20\",\n  \"description\": \"Node.js driver for Snowflake\",\n  \"dependencies\": {\n    \"@azure/storage-blob\": \"^12.11.0\",\n    \"@techteamer/ocsp\": \"1.0.0\",\n    \"agent-base\": \"^6.0.2\",\n    \"asn1.js-rfc2560\": \"^5.0.0\",\n    \"asn1.js-rfc5280\": \"^3.0.0\",\n\t\"async\": \"^3.2.3\",\n    \"aws-sdk\": \"^2.878.0\",\n    \"axios\": \"^0.27.2\",\n    \"better-eval\": \"^1.3.0\",\n    \"big-integer\": \"^1.6.43\",\n    \"bignumber.js\": \"^2.4.0\",\n    \"binascii\": \"0.0.2\",\n    \"browser-request\": \"^0.3.3\",\n    \"debug\": \"^3.2.6\",\n    \"expand-tilde\": \"^2.0.2\",\n    \"extend\": \"^3.0.2\",\n    \"fast-xml-parser\": \"^4.1.3\",\n    \"generic-pool\": \"^3.8.2\",\n    \"@google-cloud/storage\": \"^6.9.3\",\n    \"glob\": \"^7.1.6\",\n    \"jsonwebtoken\": \"^9.0.0\",\n    \"mime-types\": \"^2.1.29\",\n    \"mkdirp\": \"^1.0.3\",\n    \"mock-require\": \"^3.0.3\",\n    \"moment\": \"^2.29.4\",\n    \"moment-timezone\": \"^0.5.15\",\n    \"open\": \"^7.3.1\",\n    \"python-struct\": \"^1.1.3\",\n    \"simple-lru-cache\": \"^0.0.2\",\n    \"string-similarity\": \"^4.0.4\",\n    \"test-console\": \"^2.0.0\",\n    \"tmp\": \"^0.2.1\",\n    \"urllib\": \"^2.38.0\",\n    \"uuid\": \"^3.3.2\",\n    \"winston\": \"^3.1.0\"\n  },\n  \"devDependencies\": {\n    \"qs\": \"^6.10.3\",\n    \"mocha\": \"^10.1.0\"\n  },\n  \"overrides\": {\n    \"@azure/storage-blob\": {\n      \"node-fetch\": \"^3.2.10\"\n    }\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/snowflakedb/snowflake-connector-nodejs\"\n  },\n  \"scripts\": {\n    \"test\": \"mocha test/unit/**/*.js\"\n  },\n  \"author\": {\n    \"name\": \"Snowflake Computing, Inc.\",\n    \"email\": \"support@snowflake.com\",\n    \"url\": \"https://www.snowflake.com/\"\n  },\n  \"license\": \"Apache-2.0\"\n}\n", "/*\n * Copyright (c) 2015-2019 Snowflake Computing Inc. All rights reserved.\n */\nvar async = require('async');\nvar testUtil = require('./testUtil');\nconst sharedStatement = require('./sharedStatements');\nvar bigInt = require(\"big-integer\");\n\ndescribe('Test DataType', function ()\n{\n  var connection;\n  var createTableWithString = 'create or replace table testString(colA string)';\n  var createTableWithVariant = 'create or replace table testVariant(colA variant)';\n  var createTableWithArray = 'create or replace table testArray(colA array)';\n  var createTableWithNumber = 'create or replace table testNumber(colA number)';\n  var createTableWithDouble = 'create or replace table testDouble(colA double)';\n  var createTableWithDate = 'create or replace table testDate(colA date)';\n  var createTableWithTime = 'create or replace table testTime(colA time)';\n  var createTableWithTimestamp = 'create or replace table testTimestamp(colA timestamp_ltz, ' +\n    'colB timestamp_tz, colC timestamp_ntz)';\n  var createTableWithBoolean = 'create or replace table testBoolean(colA boolean, colB boolean, colC boolean)';\n  var dropTableWithString = 'drop table if exists testString';\n  var dropTableWithVariant = 'drop table if exists testVariant';\n  var dropTableWithArray = 'drop table if exists testArray';\n  var dropTableWithNumber = 'drop table if exists testNumber';\n  var dropTableWithDouble = 'drop table if exists testDouble';\n  var dropTableWithDate = 'drop table if exists testDate';\n  var dropTableWithTime = 'drop table if exists testTime';\n  var dropTableWithTimestamp = 'drop table if exists testTimestamp';\n  var dropTableWithBoolean = 'drop table if exists testBoolean';\n  var insertDouble = 'insert into testDouble values(123.456)';\n  var insertLargeNumber = 'insert into testNumber values (12345678901234567890123456789012345678)';\n  var insertRegularSizedNumber = 'insert into testNumber values (100000001)';\n  var insertVariant = 'insert into testVariant select parse_json(\\'{a : 1 , b :[1 , 2 , 3, -Infinity, undefined], c : {a : 1}}\\')';\n  var insertArray = 'insert into testArray select parse_json(\\'[\"a\", 1]\\')';\n  var insertDate = 'insert into testDate values(to_date(\\'2012-11-11\\'))';\n  var insertTime = 'insert into testTime values(to_time(\\'12:34:56.789789789\\'))';\n  var insertTimestamp = 'insert into testTimestamp values(to_timestamp_ltz('\n    + '\\'Thu, 21 Jan 2016 06:32:44 -0800\\'), to_timestamp_tz(\\'Thu, 21 Jan 2016 06:32:44 -0800\\'), '\n    + 'to_timestamp_ntz(\\'Thu, 21 Jan 2016 06:32:44 -0800\\'))';\n  var insertBoolean = 'insert into testBoolean values(true, false, null)';\n  var insertString = 'insert into testString values(\\'string with space\\')';\n  var selectDouble = 'select * from testDouble';\n  var selectNumber = 'select * from testNumber';\n  var selectVariant = 'select * from testVariant';\n  var selectArray = 'select * from testArray';\n  var selectDate = 'select * from testDate';\n  var selectTime = 'select * from testTime';\n  var selectTimestamp = 'select * from testTimestamp';\n  var selectBoolean = 'select * from testBoolean';\n  var selectString = 'select * from testString';\n\n  before(function (done)\n  {\n    connection = testUtil.createConnection();\n    async.series([\n        function (callback)\n        {\n          testUtil.connect(connection, callback);\n        }],\n      done\n    );\n  });\n\n  after(function (done)\n  {\n    async.series([\n        function (callback)\n        {\n          testUtil.executeCmd(connection, dropTableWithString, callback);\n        },\n        function (callback)\n        {\n          testUtil.executeCmd(connection, dropTableWithVariant, callback);\n        },\n        function (callback)\n        {\n          testUtil.executeCmd(connection, dropTableWithArray, callback);\n        },\n        function (callback)\n        {\n          testUtil.executeCmd(connection, dropTableWithNumber, callback);\n        },\n        function (callback)\n        {\n          testUtil.executeCmd(connection, dropTableWithDouble, callback);\n        },\n        function (callback)\n        {\n          testUtil.executeCmd(connection, dropTableWithDate, callback);\n        },\n        function (callback)\n        {\n          testUtil.executeCmd(connection, dropTableWithTime, callback);\n        },\n        function (callback)\n        {\n          testUtil.executeCmd(connection, dropTableWithTimestamp, callback);\n        },\n        function (callback)\n        {\n          testUtil.executeCmd(connection, dropTableWithBoolean, callback);\n        },\n        function (callback)\n        {\n          testUtil.destroyConnection(connection, callback);\n        }],\n      done\n    );\n  });\n\n  describe('testNumber', function ()\n  {\n    it('testDouble', function (done)\n    {\n      async.series([\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithDouble, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertDouble, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectDouble,\n              [{'COLA': 123.456}],\n              callback\n            );\n          }],\n        done\n      );\n    });\n\n    it('testLargeNumber', function (done)\n    {\n      async.series([\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithNumber, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertLargeNumber, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectNumber,\n              [{'COLA': 12345678901234567890123456789012345678}],\n              callback\n            );\n          }],\n        done\n      );\n    });\n\n    it('testLargeNumberBigInt', function (done)\n    {\n      async.series([\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithNumber, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertLargeNumber, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, \"alter session set JS_TREAT_INTEGER_AS_BIGINT=true\", callback)\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectNumber,\n              [{'COLA': bigInt(\"12345678901234567890123456789012345678\")}],\n              callback,\n              null,\n              false\n            );\n          }],\n        done\n      );\n    });\n\n    it('testRegularSizedInteger', function (done)\n    {\n      async.series([\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithNumber, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertRegularSizedNumber, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectNumber,\n              [{'COLA': 100000001}],\n              callback\n            );\n          }],\n        done\n      );\n    });\n  });\n\n  describe('testSemiStructuredDataType', function ()\n  {\n    it('testVariant', function (done)\n    {\n      async.series(\n        [\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithVariant, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertVariant, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectVariant,\n              [{'COLA': {a: 1, b: [1, 2, 3, -Infinity, undefined], c: {a: 1}}}],\n              callback,\n              null,\n              true,\n              false\n            );\n          }],\n        done\n      );\n    });\n\n    it('testArray', function (done)\n    {\n      async.series(\n        [\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithArray, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertArray, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectArray,\n              [{'COLA': ['a', 1]}],\n              callback,\n              null,\n              true,\n              false\n            );\n          }],\n        done\n      );\n    });\n  });\n\n  describe('testDateTime', function ()\n  {\n    it('testDate', function (done)\n    {\n      async.series(\n        [\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithDate, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertDate, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectDate,\n              [{'COLA': '2012-11-11'}],\n              callback\n            );\n          }],\n        done\n      );\n    });\n\n    it('testTime', function (done)\n    {\n      async.series(\n        [\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithTime, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertTime, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectTime,\n              [{'COLA': '12:34:56'}],\n              callback\n            );\n          }],\n        done\n      );\n    });\n\n    it('testTimestamp', function (done)\n    {\n      async.series(\n        [\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithTimestamp, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertTimestamp, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, sharedStatement.setTimezoneAndTimestamps, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectTimestamp,\n              [{\n                'COLA': '2016-01-21 06:32:44.000 -0800',\n                'COLB': '2016-01-21 06:32:44.000 -0800',\n                'COLC': '2016-01-21 06:32:44.000'\n              }],\n              callback\n            );\n          }],\n        done\n      );\n    });\n  });\n\n  describe('testBoolean', function ()\n  {\n    it('testTrue', function (done)\n    {\n      async.series(\n        [\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithBoolean, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertBoolean, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectBoolean,\n              [{\n                'COLA': true,\n                'COLB': false,\n                'COLC': null\n              }],\n              callback\n            );\n          }],\n        done\n      );\n    });\n  });\n\n  describe('testText', function ()\n  {\n    it('testString', function (done)\n    {\n      async.series(\n        [\n          function (callback)\n          {\n            testUtil.executeCmd(connection, createTableWithString, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeCmd(connection, insertString, callback);\n          },\n          function (callback)\n          {\n            testUtil.executeQueryAndVerify(\n              connection,\n              selectString,\n              [{'COLA': 'string with space'}],\n              callback\n            );\n          }],\n        done\n      );\n    });\n  });\n});\n", "/*\n * Copyright (c) 2015-2019 Snowflake Computing Inc. All rights reserved.\n */\nvar snowflake = require('./../../lib/snowflake');\nvar connOptions = require('./connectionOptions');\nvar assert = require('assert');\n\nmodule.exports.createConnection = function ()\n{\n  return snowflake.createConnection(connOptions.valid);\n};\n\nmodule.exports.connect = function (connection, callback)\n{\n  connection.connect(function (err)\n  {\n    assert.ok(!err, JSON.stringify(err));\n    callback();\n  });\n};\n\nmodule.exports.destroyConnection = function (connection, callback)\n{\n  connection.destroy(function (err)\n  {\n    assert.ok(!err, JSON.stringify(err));\n    callback();\n  })\n};\n\nmodule.exports.executeCmd = function (connection, sql, callback, bindArray)\n{\n  var executeOptions = {};\n  executeOptions.sqlText = sql;\n  executeOptions.complete = function (err)\n  {\n    assert.ok(!err, JSON.stringify(err));\n    callback();\n  };\n\n  if (bindArray !== undefined && bindArray != null)\n  {\n    executeOptions.binds = bindArray;\n  }\n\n  connection.execute(executeOptions);\n};\n\nmodule.exports.checkError = function (err)\n{\n  assert.ok(!err, JSON.stringify(err));\n};\n\nmodule.exports.executeQueryAndVerify = function (connection, sql, expected, callback, bindArray, normalize, strict)\n{\n  // Sometimes we may not want to normalize the row first\n  normalize = (typeof normalize !== \"undefined\" && normalize != null) ? normalize : true;\n  strict = (typeof strict !== \"undefined\" && strict != null) ? strict : true;\n  var executeOptions = {};\n  executeOptions.sqlText = sql;\n  executeOptions.complete = function (err, stmt)\n  {\n    assert.ok(!err, JSON.stringify(err));\n    var rowCount = 0;\n    var stream = stmt.streamRows();\n    stream.on('readable', function ()\n    {\n      var row;\n      while ((row = stream.read()) !== null)\n      {\n        if (strict)\n        {\n          assert.deepStrictEqual(normalize ? normalizeRowObject(row) : row, expected[rowCount]);\n        }\n        else\n        {\n          assert.deepEqual(normalize ? normalizeRowObject(row) : row, expected[rowCount]);\n        }\n        rowCount++;\n      }\n    });\n    stream.on('error', function (err)\n    {\n      assert.ok(!err, JSON.stringify(err));\n    });\n    stream.on('end', function ()\n    {\n      assert.strictEqual(rowCount, expected.length);\n      callback();\n    });\n  };\n  if (bindArray != null && bindArray != undefined)\n  {\n    executeOptions.binds = bindArray;\n  }\n\n  connection.execute(executeOptions);\n};\n\nfunction normalizeRowObject(row)\n{\n  var normalizedRow = {};\n  for (var key in row)\n  {\n    if (row.hasOwnProperty(key))\n    {\n      var convertToString = (row[key] !== null) && (row[key] !== undefined)\n        && (typeof row[key].toJSON === 'function');\n      var convertToJSNumber = (row[key] !== null) && (row[key] !== undefined)\n        && (typeof row[key].toJSNumber === 'function');\n      // If this is a bigInt type then convert to JS Number instead of string JSON representation\n      if (convertToJSNumber)\n      {\n        normalizedRow[key] = row[key].toJSNumber();\n      }\n      else if (convertToString)\n      {\n        normalizedRow[key] = row[key].toJSON();\n      }\n      else\n      {\n        normalizedRow[key] = row[key];\n      }\n    }\n  }\n  return normalizedRow;\n}\n\n\n\n", "/*\n * Copyright (c) 2015-2019 Snowflake Computing Inc. All rights reserved.\n */\n\nvar assert = require('assert');\nvar ResultTestCommon = require('./result_test_common');\n\ndescribe('Result: test variant', function ()\n{\n  it(\"select to_variant((parse_json('{ a : 1 }'))) as C1, \" +\n    \"to_object(parse_json('{ a : 1 }')) as C2, \" +\n    \"to_array(parse_json('[1, 2]')) as C3;\",\n    function (done)\n    {\n      var response =\n        {\n          \"data\": {\n            \"parameters\": [{\"name\": \"TIMEZONE\", \"value\": \"America/Los_Angeles\"}, {\n              \"name\": \"TIMESTAMP_OUTPUT_FORMAT\", \"value\": \"DY, DD MON YYYY HH24:MI:SS TZHTZM\"\n            }, {\"name\": \"TIMESTAMP_NTZ_OUTPUT_FORMAT\", \"value\": \"\"}, {\n              \"name\": \"TIMESTAMP_LTZ_OUTPUT_FORMAT\", \"value\": \"\"\n            }, {\"name\": \"TIMESTAMP_TZ_OUTPUT_FORMAT\", \"value\": \"\"}, {\n              \"name\": \"DATE_OUTPUT_FORMAT\", \"value\": \"YYYY-MM-DD\"\n            }, {\"name\": \"CLIENT_RESULT_PREFETCH_SLOTS\", \"value\": 2}, {\n              \"name\": \"CLIENT_RESULT_PREFETCH_THREADS\", \"value\": 1\n            }, {\"name\": \"CLIENT_HONOR_CLIENT_TZ_FOR_TIMESTAMP_NTZ\", \"value\": true}, {\n              \"name\": \"CLIENT_USE_V1_QUERY_API\", \"value\": true\n            }],\n            \"rowtype\": [{\n              \"name\": \"C1\", \"byteLength\": 16777216, \"nullable\": true, \"precision\": null, \"scale\": null,\n              \"length\": 16777216, \"type\": \"variant\"\n            }, {\n              \"name\": \"C2\", \"byteLength\": 16777216, \"nullable\": true, \"precision\": null, \"scale\": null,\n              \"length\": 16777216, \"type\": \"object\"\n            }, {\n              \"name\": \"C3\", \"byteLength\": 16777216, \"nullable\": true, \"precision\": null, \"scale\": null,\n              \"length\": 16777216, \"type\": \"array\"\n            }],\n            \"rowset\": [[\"{\\n  \\\"a\\\": 1\\n}\", \"{\\n  \\\"a\\\": 1\\n}\", \"[\\n  1,\\n  2\\n]\"]],\n            \"total\": 1,\n            \"returned\": 1,\n            \"queryId\": \"34d7c2d2-33ff-416d-a3bc-0b897daec56b\",\n            \"databaseProvider\": null,\n            \"finalDatabaseName\": null,\n            \"finalSchemaName\": null,\n            \"finalWarehouseName\": \"NEW_WH\",\n            \"finalRoleName\": \"ACCOUNTADMIN\",\n            \"numberOfBinds\": 0,\n            \"statementTypeId\": 4096,\n            \"version\": 0\n          },\n          \"message\": null,\n          \"code\": null,\n          \"success\": true\n        };\n\n      ResultTestCommon.testResult(\n        ResultTestCommon.createResultOptions(response),\n        function (row)\n        {\n          // variant\n          assert.deepEqual(row.getColumnValue('C1'), {a: 1});\n          assert.equal(\n            row.getColumnValueAsString('C1'), JSON.stringify({a: 1}));\n\n          // object\n          assert.deepEqual(row.getColumnValue('C2'), {a: 1});\n          assert.equal(\n            row.getColumnValueAsString('C2'), JSON.stringify({a: 1}));\n\n          // array\n          assert.deepEqual(row.getColumnValue('C3'), [1, 2]);\n          assert.equal(\n            row.getColumnValueAsString('C3'), JSON.stringify([1, 2]));\n        },\n        function (result)\n        {\n          done();\n        }\n      );\n    });\n});"], "filenames": ["lib/connection/result/column.js", "package.json", "test/integration/testDataType.js", "test/integration/testUtil.js", "test/unit/connection/result/result_test_variant.js"], "buggy_code_start_loc": [11, 13, 237, 54, 62], "buggy_code_end_loc": [555, 13, 263, 71, 74], "fixing_code_start_loc": [12, 14, 237, 54, 62], "fixing_code_end_loc": [556, 15, 269, 79, 74], "type": "CWE-77", "message": "snowflake-connector-nodejs, a NodeJS driver for Snowflake, is vulnerable to command injection via single sign on (SSO) browser URL authentication in versions prior to 1.6.21. In order to exploit the potential for command injection, an attacker would need to be successful in (1) establishing a malicious resource and (2) redirecting users to utilize the resource. The attacker could set up a malicious, publicly accessible server which responds to the SSO URL with an attack payload. If the attacker then tricked a user into visiting the maliciously crafted connection URL, the user\u2019s local machine would render the malicious payload, leading to a remote code execution. This attack scenario can be mitigated through URL whitelisting as well as common anti-phishing resources. Version 1.6.21 contains a patch for this issue.", "other": {"cve": {"id": "CVE-2023-34232", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-08T21:15:17.593", "lastModified": "2023-06-20T16:18:18.707", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "snowflake-connector-nodejs, a NodeJS driver for Snowflake, is vulnerable to command injection via single sign on (SSO) browser URL authentication in versions prior to 1.6.21. In order to exploit the potential for command injection, an attacker would need to be successful in (1) establishing a malicious resource and (2) redirecting users to utilize the resource. The attacker could set up a malicious, publicly accessible server which responds to the SSO URL with an attack payload. If the attacker then tricked a user into visiting the maliciously crafted connection URL, the user\u2019s local machine would render the malicious payload, leading to a remote code execution. This attack scenario can be mitigated through URL whitelisting as well as common anti-phishing resources. Version 1.6.21 contains a patch for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.1, "impactScore": 5.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:snowflake:snowflake_connector:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.6.21", "matchCriteriaId": "EFCA6C61-98B5-44AC-94E4-07D00861464A"}]}]}], "references": [{"url": "https://community.snowflake.com/s/article/Node-js-Driver-Release-Notes", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/snowflakedb/snowflake-connector-nodejs/commit/0c9622ae12cd7d627df404b73a783b4a5f60728a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/snowflakedb/snowflake-connector-nodejs/pull/465", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/snowflakedb/snowflake-connector-nodejs/security/advisories/GHSA-h53w-7qw7-vh5c", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/snowflakedb/snowflake-connector-nodejs/commit/0c9622ae12cd7d627df404b73a783b4a5f60728a"}}