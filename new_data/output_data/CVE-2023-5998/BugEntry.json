{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / MPEG-1/2/4(Part2) video reframer filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n#include <gpac/internal/media_dev.h>\n\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_RFMPGVID)\n\n#define MIN_HDR_STORE\t12\ntypedef struct\n{\n\tu64 pos;\n\tDouble start_time;\n} MPGVidIdx;\n\ntypedef struct\n{\n\t//filter args\n\tGF_Fraction fps;\n\tDouble index;\n\tBool vfr, importer, notime;\n\n\t//only one input pid declared\n\tGF_FilterPid *ipid;\n\t//only one output pid declared\n\tGF_FilterPid *opid;\n\n\tGF_BitStream *bs;\n\tu64 cts, dts, prev_dts;\n\tu32 width, height;\n\tGF_Fraction64 duration;\n\tDouble start_range;\n\tBool in_seek;\n\tu32 timescale;\n\n\tu32 resume_from;\n\tGF_Fraction cur_fps;\n\n\tBool is_mpg12, forced_packed;\n\tGF_M4VParser *vparser;\n\tGF_M4VDecSpecInfo dsi;\n\tu32 b_frames;\n\tBool is_packed, is_vfr;\n\tGF_List *pck_queue;\n\tu64 last_ref_cts;\n\tBool frame_started;\n\n\tu32 nb_i, nb_p, nb_b, nb_frames, max_b;\n\n\tu32 bytes_in_header;\n\tchar *hdr_store;\n\tu32 hdr_store_size, hdr_store_alloc;\n\n\tBool is_playing;\n\tBool is_file, file_loaded;\n\tBool initial_play_done;\n\n\tBool input_is_au_start, input_is_au_end;\n\tBool recompute_cts, copy_props;\n\n\tGF_FilterPacket *src_pck;\n\n\tMPGVidIdx *indexes;\n\tu32 index_alloc_size, index_size;\n\tu32 bitrate;\n\tBool trash_trailer;\n} GF_MPGVidDmxCtx;\n\n\nGF_Err mpgviddmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tBool was_mpeg12;\n\tconst GF_PropertyValue *p;\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tctx->ipid = pid;\n\tctx->cur_fps = ctx->fps;\n\tif (!ctx->fps.num || !ctx->fps.den) {\n\t\tctx->cur_fps.num = 25000;\n\t\tctx->cur_fps.den = 1000;\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\tif (p) {\n\t\tctx->timescale = ctx->cur_fps.num = p->value.uint;\n\t\tctx->cur_fps.den = 0;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FPS);\n\t\tif (p) {\n\t\t\tctx->cur_fps = p->value.frac;\n\t\t}\n\t\tp = gf_filter_pid_get_property_str(pid, \"nocts\");\n\t\tif (p && p->value.boolean) ctx->recompute_cts = GF_TRUE;\n\t}\n\n\twas_mpeg12 = ctx->is_mpg12;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\tif (p) {\n\t\tswitch (p->value.uint) {\n\t\tcase GF_CODECID_MPEG1:\n\t\tcase GF_CODECID_MPEG2_422:\n\t\tcase GF_CODECID_MPEG2_SNR:\n\t\tcase GF_CODECID_MPEG2_HIGH:\n\t\tcase GF_CODECID_MPEG2_MAIN:\n\t\tcase GF_CODECID_MPEG2_SIMPLE:\n\t\tcase GF_CODECID_MPEG2_SPATIAL:\n\t\t\tctx->is_mpg12 = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\telse {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_MIME);\n\t\tif (p && p->value.string && (strstr(p->value.string, \"m1v\") || strstr(p->value.string, \"m2v\")) ) ctx->is_mpg12 = GF_TRUE;\n\t\telse {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FILE_EXT);\n\t\t\tif (p && p->value.string && (strstr(p->value.string, \"m1v\") || strstr(p->value.string, \"m2v\")) ) ctx->is_mpg12 = GF_TRUE;\n\t\t}\n\t}\n\n\tif (ctx->vparser && (was_mpeg12 != ctx->is_mpg12)) {\n\t\tgf_m4v_parser_del_no_bs(ctx->vparser);\n\t\tctx->vparser = NULL;\n\t}\n\n\tif (ctx->timescale && !ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\t}\n\t//if source has no timescale, recompute time\n\tif (!ctx->timescale) ctx->notime = GF_TRUE;\n\telse ctx->copy_props = GF_TRUE;\n\n\treturn GF_OK;\n}\n\n\nstatic void mpgviddmx_check_dur(GF_Filter *filter, GF_MPGVidDmxCtx *ctx)\n{\n\n\tFILE *stream;\n\tGF_BitStream *bs;\n\tGF_M4VParser *vparser;\n\tGF_M4VDecSpecInfo dsi;\n\tGF_Err e;\n\tu32 probe_size=0;\n\tu64 duration, cur_dur, rate;\n\tconst GF_PropertyValue *p;\n\tif (!ctx->opid || ctx->timescale || ctx->file_loaded) return;\n\n\tif (ctx->index<0) {\n\t\tif (gf_opts_get_bool(\"temp\", \"force_indexing\")) {\n\t\t\tctx->index = 1.0;\n\t\t} else {\n\t\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_DOWN_SIZE);\n\t\t\tif (!p || (p->value.longuint > 20000000)) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[MPGVids] Source file larger than 20M, skipping indexing\\n\"));\n\t\t\t\tif (!gf_sys_is_test_mode())\n\t\t\t\t\tprobe_size = 20000000;\n\t\t\t} else {\n\t\t\t\tctx->index = -ctx->index;\n\t\t\t}\n\t\t}\n\t}\n\tif ((ctx->index<=0) && !probe_size) {\n\t\tctx->duration.num = 1;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILEPATH);\n\tif (!p || !p->value.string || !strncmp(p->value.string, \"gmem://\", 7)) {\n\t\tctx->is_file = GF_FALSE;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\tctx->is_file = GF_TRUE;\n\n\tstream = gf_fopen_ex(p->value.string, NULL, \"rb\", GF_TRUE);\n\tif (!stream) {\n\t\tif (gf_fileio_is_main_thread(p->value.string))\n\t\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tctx->index_size = 0;\n\n\tbs = gf_bs_from_file(stream, GF_BITSTREAM_READ);\n\n\tvparser = gf_m4v_parser_bs_new(bs, ctx->is_mpg12);\n\te = gf_m4v_parse_config(vparser, &dsi);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Could not parse video header - duration  not estimated\\n\"));\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tduration = 0;\n\tcur_dur = 0;\n\twhile (gf_bs_available(bs)) {\n\t\tu8 ftype;\n\t\tu32 tinc;\n\t\tu64 fsize, start;\n\t\tBool is_coded;\n\t\tu64 pos;\n\t\tpos = gf_m4v_get_object_start(vparser);\n\t\te = gf_m4v_parse_frame(vparser, &dsi, &ftype, &tinc, &fsize, &start, &is_coded);\n\t\tif (e<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Could not parse video frame\\n\"));\n\t\t\tcontinue;\n\t\t}\n\t\tif (probe_size && (pos>probe_size) && (ftype==1)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tduration += ctx->cur_fps.den;\n\t\tcur_dur += ctx->cur_fps.den;\n\t\t//only index at I-frame start\n\t\tif (!probe_size && pos && (ftype==1) && (cur_dur >= ctx->index * ctx->cur_fps.num) ) {\n\t\t\tif (!ctx->index_alloc_size) ctx->index_alloc_size = 10;\n\t\t\telse if (ctx->index_alloc_size == ctx->index_size) ctx->index_alloc_size *= 2;\n\t\t\tctx->indexes = gf_realloc(ctx->indexes, sizeof(MPGVidIdx)*ctx->index_alloc_size);\n\t\t\tctx->indexes[ctx->index_size].pos = pos;\n\t\t\tctx->indexes[ctx->index_size].start_time = (Double) (duration-ctx->cur_fps.den);\n\t\t\tctx->indexes[ctx->index_size].start_time /= ctx->cur_fps.num;\n\t\t\tctx->index_size ++;\n\t\t\tcur_dur = 0;\n\t\t}\n\t}\n\n\trate = gf_bs_get_position(bs);\n\tgf_m4v_parser_del(vparser);\n\tgf_fclose(stream);\n\n\tif (!ctx->duration.num || (ctx->duration.num  * ctx->cur_fps.num != duration * ctx->duration.den)) {\n\t\tctx->duration.num = (s32) duration;\n\t\tctx->duration.den = ctx->cur_fps.num;\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\t\tif (duration && !gf_sys_is_test_mode() ) {\n\t\t\trate *= 8 * ctx->duration.den;\n\t\t\trate /= ctx->duration.num;\n\t\t\tctx->bitrate = (u32) rate;\n\t\t}\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n}\n\n\nstatic void mpgviddmx_enqueue_or_dispatch(GF_MPGVidDmxCtx *ctx, GF_FilterPacket *pck, Bool flush_ref, Bool is_eos)\n{\n\tif (pck && ctx->trash_trailer) {\n\t\tgf_filter_pck_discard(pck);\n\t\treturn;\n\t}\n\n\tif (!is_eos && (!ctx->width || !ctx->height))\n\t\tflush_ref = GF_FALSE;\n\n\t//need to signal this for consumers using DTS (eg MPEG-2 TS)\n\tif (flush_ref && ctx->pck_queue) {\n\t\t//send all reference packet queued\n\t\tu32 i, count = gf_list_count(ctx->pck_queue);\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu64 cts;\n\t\t\tGF_FilterPacket *q_pck = gf_list_get(ctx->pck_queue, i);\n\t\t\tu8 carousel = gf_filter_pck_get_carousel_version(q_pck);\n\t\t\tif (!carousel) {\n\t\t\t\tgf_filter_pck_send(q_pck);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgf_filter_pck_set_carousel_version(q_pck, 0);\n\t\t\tcts = gf_filter_pck_get_cts(q_pck);\n\t\t\tif (cts != GF_FILTER_NO_TS) {\n\t\t\t\t//offset the cts of the ref frame to the number of B frames in-between\n\t\t\t\tif (ctx->last_ref_cts == cts) {\n\t\t\t\t\tcts += ctx->b_frames * ctx->cur_fps.den;\n\t\t\t\t\tgf_filter_pck_set_cts(q_pck, cts);\n\t\t\t\t} else {\n\t\t\t\t\t//shift all other frames (i.e. pending Bs) by 1 frame in the past since we move the ref frame after them\n\t\t\t\t\tassert(cts >= ctx->cur_fps.den);\n\t\t\t\t\tcts -= ctx->cur_fps.den;\n\t\t\t\t\tgf_filter_pck_set_cts(q_pck, cts);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_eos && (i+1==count)) {\n\t\t\t\tBool start, end;\n\t\t\t\tgf_filter_pck_get_framing(q_pck, &start, &end);\n\t\t\t\tgf_filter_pck_set_framing(q_pck, start, GF_TRUE);\n\t\t\t}\n\t\t\tgf_filter_pck_send(q_pck);\n\t\t}\n\t\tgf_list_reset(ctx->pck_queue);\n\t}\n\tif (!pck) return;\n\n\tif (!ctx->pck_queue) ctx->pck_queue = gf_list_new();\n\tgf_list_add(ctx->pck_queue, pck);\n}\n\nstatic void mpgviddmx_check_pid(GF_Filter *filter, GF_MPGVidDmxCtx *ctx, u32 vosh_size, u8 *data)\n{\n\tBool flush_after = GF_FALSE;\n\tif (!ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tmpgviddmx_check_dur(filter, ctx);\n\t}\n\n\tif ((ctx->width == ctx->dsi.width) && (ctx->height == ctx->dsi.height) && !ctx->copy_props) return;\n\n\t//copy properties at init or reconfig\n\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\tctx->copy_props = GF_FALSE;\n\tif (ctx->duration.num)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\tif (!ctx->timescale)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CAN_DATAREF, & PROP_BOOL(GF_TRUE ) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, & PROP_UINT(GF_STREAM_VISUAL));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, & PROP_UINT(ctx->timescale ? ctx->timescale : ctx->cur_fps.num));\n\n\t//if we have a FPS prop, use it\n\tif (!gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FPS))\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_FPS, & PROP_FRAC(ctx->cur_fps));\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\n\tif (ctx->width && ctx->height) {\n\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);\n\t} else {\n\t\tflush_after = GF_TRUE;\n\t}\n\tctx->width = ctx->dsi.width;\n\tctx->height = ctx->dsi.height;\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, & PROP_UINT( ctx->dsi.width));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, & PROP_UINT( ctx->dsi.height));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAR, & PROP_FRAC_INT(ctx->dsi.par_num, ctx->dsi.par_den));\n\n\tif (ctx->is_mpg12) {\n\t\tconst GF_PropertyValue *cid = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_CODECID);\n\t\tu32 PL = 0;\n\t\tif (cid) {\n\t\t\tswitch (cid->value.uint) {\n\t\t\tcase GF_CODECID_MPEG2_MAIN:\n\t\t\tcase GF_CODECID_MPEG2_422:\n\t\t\tcase GF_CODECID_MPEG2_SNR:\n\t\t\tcase GF_CODECID_MPEG2_HIGH:\n\t\t\t\t//keep same signaling\n\t\t\t\tPL = cid->value.uint;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tu32 prof = (ctx->dsi.VideoPL>>4) & 0x7;\n\t\t\tif (prof==1) PL = GF_CODECID_MPEG2_HIGH;\n\t\t\telse if (prof==2) PL = GF_CODECID_MPEG2_SNR;\n\t\t\telse if (prof==3) PL = GF_CODECID_MPEG2_SNR;\n\t\t\telse if (prof==4) PL = GF_CODECID_MPEG2_MAIN;\n\t\t\telse if (prof==5) PL = GF_CODECID_MPEG2_SIMPLE;\n\t\t}\n\n\t\tif (!PL)\n\t\t\tPL = (ctx->dsi.VideoPL == GF_CODECID_MPEG1) ? GF_CODECID_MPEG1 : GF_CODECID_MPEG2_MAIN;\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(PL));\n\t} else {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(GF_CODECID_MPEG4_PART2));\n\t}\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PROFILE_LEVEL, & PROP_UINT (ctx->dsi.VideoPL) );\n\n\tif (ctx->bitrate) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->bitrate));\n\t}\n\n\tctx->b_frames = 0;\n\n\tif (vosh_size) {\n\t\tu32 i;\n\t\tchar * dcfg = gf_malloc(sizeof(char)*vosh_size);\n\t\tmemcpy(dcfg, data, sizeof(char)*vosh_size);\n\n\t\t/*remove packed flag if any (VOSH user data)*/\n\t\tctx->is_packed = ctx->is_vfr = ctx->forced_packed = GF_FALSE;\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tchar *frame = dcfg;\n\t\t\twhile ((i+3<vosh_size)  && ((frame[i]!=0) || (frame[i+1]!=0) || (frame[i+2]!=1))) i++;\n\t\t\tif (i+4>=vosh_size) break;\n\t\t\tif (strncmp(frame+i+4, \"DivX\", 4)) {\n\t\t\t\ti += 4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tframe = memchr(dcfg + i + 4, 'p', vosh_size - i - 4);\n\t\t\tif (frame) {\n\t\t\t\tctx->forced_packed = GF_TRUE;\n\t\t\t\tframe[0] = 'n';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, & PROP_DATA_NO_COPY(dcfg, vosh_size));\n\t}\n\n\tif (ctx->is_file && ctx->index) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, & PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) );\n\t}\n\n\tif (!gf_sys_is_test_mode()) {\n\t\tif (ctx->dsi.chroma_fmt)\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_CHROMAFMT, & PROP_UINT(ctx->dsi.chroma_fmt) );\n\n\t\tif (ctx->is_mpg12)\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_INTERLACED, !ctx->dsi.progresive ? & PROP_BOOL(GF_TRUE) : NULL );\n\t}\n\n\tif (flush_after)\n\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);\n\n}\n\nstatic Bool mpgviddmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 i;\n\tu64 file_pos = 0;\n\tGF_FilterEvent fevt;\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->is_playing = GF_TRUE;\n\t\t\tctx->cts = 0;\n\t\t\tctx->bytes_in_header = 0;\n\t\t}\n\t\tif (! ctx->is_file) {\n\t\t\tif (!ctx->initial_play_done) {\n\t\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t\tif (evt->play.start_range>0.1) ctx->resume_from = 0;\n \t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tctx->start_range = evt->play.start_range;\n\t\tctx->in_seek = GF_TRUE;\n\n\t\tif (ctx->start_range) {\n\t\t\tif (ctx->index<0) {\n\t\t\t\tctx->index = -ctx->index;\n\t\t\t\tctx->file_loaded = GF_FALSE;\n\t\t\t\tctx->duration.den = ctx->duration.num = 0;\n\t\t\t\tmpgviddmx_check_dur(filter, ctx);\n\t\t\t}\n\n\t\t\tfor (i=1; i<ctx->index_size; i++) {\n\t\t\t\tif ((ctx->indexes[i].start_time > ctx->start_range) || (i+1==ctx->index_size)) {\n\t\t\t\t\tctx->cts = (u64) (ctx->indexes[i-1].start_time * ctx->cur_fps.num);\n\t\t\t\t\tfile_pos = ctx->indexes[i-1].pos;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tctx->dts = ctx->cts;\n\t\tif (!ctx->initial_play_done) {\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t//seek will not change the current source state, don't send a seek\n\t\t\tif (!file_pos)\n\t\t\t\treturn GF_TRUE;\n\t\t}\n\t\tctx->resume_from = 0;\n\t\tctx->bytes_in_header = 0;\n\t\t//post a seek\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\tfevt.seek.start_offset = file_pos;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\tctx->is_playing = GF_FALSE;\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = NULL;\n\t\tif (ctx->pck_queue) {\n\t\t\twhile (gf_list_count(ctx->pck_queue)) {\n\t\t\t\tGF_FilterPacket *pck=gf_list_pop_front(ctx->pck_queue);\n\t\t\t\tgf_filter_pck_discard(pck);\n\t\t\t}\n\t\t}\n\t\tctx->cts = 0;\n\t\t//don't cancel event\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nstatic GFINLINE void mpgviddmx_update_time(GF_MPGVidDmxCtx *ctx)\n{\n\tassert(ctx->cur_fps.num);\n\n\tif (!ctx->notime) {\n\t\tu64 inc = 3000;\n\t\tif (ctx->cur_fps.den && ctx->cur_fps.num) {\n\t\t\tinc = ctx->cur_fps.den;\n\t\t\tif (ctx->cur_fps.num != ctx->timescale) {\n\t\t\t\tinc *= ctx->timescale;\n\t\t\t\tinc /= ctx->cur_fps.num;\n\t\t\t}\n\t\t}\n\t\tctx->cts += inc;\n\t\tctx->dts += inc;\n\t} else {\n\t\tassert(ctx->cur_fps.den);\n\t\tctx->cts += ctx->cur_fps.den;\n\t\tctx->dts += ctx->cur_fps.den;\n\t}\n}\n\n\nstatic s32 mpgviddmx_next_start_code(u8 *data, u32 size)\n{\n\tu32 v, bpos, found;\n\ts64 start, end;\n\n\tbpos = 0;\n\tfound = 0;\n\tstart = 0;\n\tend = 0;\n\n\tv = 0xffffffff;\n\twhile (!end) {\n\t\tif (bpos == size)\n\t\t\treturn -1;\n\t\tv = ( (v<<8) & 0xFFFFFF00) | data[bpos];\n\n\t\tbpos++;\n\t\tif ((v & 0xFFFFFF00) == 0x00000100) {\n\t\t\tend = start + bpos - 4;\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn -1;\n\tassert(end >= start);\n\treturn (s32) (end - start);\n}\n\nGF_Err mpgviddmx_process(GF_Filter *filter)\n{\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu64 byte_offset;\n\ts64 vosh_start = -1;\n\ts64 vosh_end = -1;\n\tGF_Err e;\n\tchar *data;\n\tu8 *start;\n\tu32 pck_size;\n\ts32 remain;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tmpgviddmx_check_dur(filter, ctx);\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_TRUE);\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\tctx->src_pck = NULL;\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n\n\tstart = data;\n\tremain = pck_size;\n\n\t//input pid was muxed - we flushed pending data , update cts\n\tif (!ctx->resume_from && ctx->timescale) {\n\t\tif (!ctx->notime) {\n\t\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\t\tif (!ctx->cts || !ctx->recompute_cts)\n\t\t\t\t\tctx->cts = ts;\n\t\t\t}\n\t\t\tts = gf_filter_pck_get_dts(pck);\n\t\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\t\tif (!ctx->dts || !ctx->recompute_cts) {\n\t\t\t\t\tctx->dts = ts;\n\t\t\t\t}\n\n\t\t\t\tif (!ctx->prev_dts) ctx->prev_dts = ts;\n\t\t\t\telse if (ctx->prev_dts != ts) {\n\t\t\t\t\tu64 diff = ts;\n\t\t\t\t\tdiff -= ctx->prev_dts;\n\t\t\t\t\tif (!ctx->cur_fps.den)\n\t\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\t\t\t\t\telse if (ctx->cur_fps.den > diff)\n\t\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\n\t\t\t\t\tctx->prev_dts = ts;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgf_filter_pck_get_framing(pck, &ctx->input_is_au_start, &ctx->input_is_au_end);\n\t\t//we force it to true to deal with broken avi packaging where a video AU is split across several AVI video frames\n\t\tctx->input_is_au_end = GF_FALSE;\n\t\t//this will force CTS recomput of each frame\n\t\tif (ctx->recompute_cts) ctx->input_is_au_start = GF_FALSE;\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = pck;\n\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t}\n\n\t//we stored some data to find the complete vosh, aggregate this packet with current one\n\tif (!ctx->resume_from && ctx->hdr_store_size) {\n\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) {\n\t\t\tctx->hdr_store_alloc = ctx->hdr_store_size + pck_size;\n\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t}\n\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);\n\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\tif (byte_offset >= ctx->hdr_store_size)\n\t\t\t\tbyte_offset -= ctx->hdr_store_size;\n\t\t\telse\n\t\t\t\tbyte_offset = GF_FILTER_NO_BO;\n\t\t}\n\t\tctx->hdr_store_size += pck_size;\n\t\tstart = data = ctx->hdr_store;\n\t\tremain = pck_size = ctx->hdr_store_size;\n\t}\n\n\tif (ctx->resume_from) {\n\t\tif (gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\n\t\t//resume from data copied internally\n\t\tif (ctx->hdr_store_size) {\n\t\t\tassert(ctx->resume_from <= ctx->hdr_store_size);\n\t\t\tstart = data = ctx->hdr_store + ctx->resume_from;\n\t\t\tremain = pck_size = ctx->hdr_store_size - ctx->resume_from;\n\t\t} else {\n\t\t\tassert(remain >= (s32) ctx->resume_from);\n\t\t\tstart += ctx->resume_from;\n\t\t\tremain -= ctx->resume_from;\n\t\t}\n\t\tctx->resume_from = 0;\n\t}\n\n\tif (!ctx->bs) {\n\t\tctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);\n\t} else {\n\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t}\n\tif (!ctx->vparser) {\n\t\tctx->vparser = gf_m4v_parser_bs_new(ctx->bs, ctx->is_mpg12);\n\t}\n\n\n\twhile (remain) {\n\t\tBool full_frame;\n\t\tu8 *pck_data;\n\t\ts32 current;\n\t\tu8 sc_type, forced_sc_type=0;\n\t\tBool sc_type_forced = GF_FALSE;\n\t\tBool skip_pck = GF_FALSE;\n\t\tu8 ftype;\n\t\tu32 tinc;\n\t\tu64 size=0;\n\t\tu64 fstart=0;\n\t\tBool is_coded;\n\t\tu32 bytes_from_store = 0;\n\t\tu32 hdr_offset = 0;\n\t\tBool copy_last_bytes = GF_FALSE;\n\n\t\t//not enough bytes to parse start code\n\t\tif (remain<5) {\n\t\t\tmemcpy(ctx->hdr_store, start, remain);\n\t\t\tctx->bytes_in_header = remain;\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = -1;\n\n\t\t//we have some potential bytes of a start code in the store, copy some more bytes and check if valid start code.\n\t\t//if not, dispatch these bytes as continuation of the data\n\t\tif (ctx->bytes_in_header) {\n\n\t\t\tmemcpy(ctx->hdr_store + ctx->bytes_in_header, start, MIN_HDR_STORE - ctx->bytes_in_header);\n\t\t\tcurrent = mpgviddmx_next_start_code(ctx->hdr_store, MIN_HDR_STORE);\n\n\t\t\t//no start code in stored buffer\n\t\t\tif ((current<0) || (current >= (s32) ctx->bytes_in_header) )  {\n\t\t\t\tif (ctx->opid) {\n\t\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);\n\t\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tgf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_NONE);\n\t\t\t\t\tmemcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);\n\t\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\n\t\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);\n\t\t\t\t\t}\n\n\t\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\t}\n\n\t\t\t\tif (current<0) current = -1;\n\t\t\t\telse current -= ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t} else {\n\t\t\t\t//we have a valid start code, check which byte in our store or in the packet payload is the start code type\n\t\t\t\t//and remember its location to reinit the parser from there\n\t\t\t\thdr_offset = 4 - ctx->bytes_in_header + current;\n\t\t\t\t//bytes still to dispatch\n\t\t\t\tbytes_from_store = ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t\tif (!hdr_offset) {\n\t\t\t\t\tforced_sc_type = ctx->hdr_store[current+3];\n\t\t\t\t} else {\n\t\t\t\t\tforced_sc_type = start[hdr_offset-1];\n\t\t\t\t}\n\t\t\t\tsc_type_forced = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\t//no startcode in store, look for startcode in packet\n\t\tif (current == -1) {\n\t\t\t//locate next start code\n\t\t\tcurrent = mpgviddmx_next_start_code(start, remain);\n\t\t\t//no start code, dispatch the block\n\t\t\tif (current<0) {\n\t\t\t\tu8 b3, b2, b1;\n\t\t\t\tif (! ctx->frame_started) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MPGVid] no start code in block and no frame started, discarding data\\n\" ));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsize = remain;\n\t\t\t\tb3 = start[remain-3];\n\t\t\t\tb2 = start[remain-2];\n\t\t\t\tb1 = start[remain-1];\n\t\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\t\tassert(size >= 3);\n\t\t\t\t\tsize -= 3;\n\t\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t\t}\n\n\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\n\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tif (copy_last_bytes) {\n\t\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tassert(current>=0);\n\n\t\t//if we are in the middle of parsing the vosh, skip over bytes remaining from previous obj not parsed\n\t\tif ((vosh_start>=0) && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//also skip if no output pid\n\t\tif (!ctx->opid && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//dispatch remaining bytes\n\t\tif (current>0) {\n\t\t\t//flush remaining\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data);\n\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t//bytes were partly in store, partly in packet\n\t\t\tif (bytes_from_store) {\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t\t}\n\t\t\t\tassert(bytes_from_store>=(u32) current);\n\t\t\t\tbytes_from_store -= current;\n\t\t\t\tmemcpy(pck_data, ctx->hdr_store, current);\n\t\t\t} else {\n\t\t\t\t//bytes were only in packet\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\t\t\t\tmemcpy(pck_data, start, current);\n\t\t\t\tassert(remain>=current);\n\t\t\t\tstart += current;\n\t\t\t\tremain -= current;\n\t\t\t\tcurrent = 0;\n\t\t\t}\n\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t}\n\n\t\t//we're align to startcode, stop trashing packets\n\t\tctx->trash_trailer = GF_FALSE;\n\n\t\t//not enough bytes to parse start code\n\t\tif (remain<5) {\n\t\t\tmemcpy(ctx->hdr_store, start, remain);\n\t\t\tctx->bytes_in_header = remain;\n\t\t\tbreak;\n\t\t}\n\n\t\t//parse headers\n\t\t//we have a start code loaded, eg the data packet does not have a full start code at the beginning\n\t\tif (sc_type_forced) {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset);\n\t\t\tsc_type = forced_sc_type;\n\t\t} else {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\tgf_bs_read_int(ctx->bs, 24);\n\t\t\tsc_type = gf_bs_read_int(ctx->bs, 8);\n\t\t}\n\n\t\tif (ctx->is_mpg12) {\n\t\t\tswitch (sc_type) {\n\t\t\tcase M2V_SEQ_START_CODE:\n\t\t\tcase M2V_EXT_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (data == ctx->hdr_store) {\n\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n\t\t\t\t\t\tctx->hdr_store_size = remain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);\n\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemmove(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\t}\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else if (ctx->dsi.width && ctx->dsi.height) {\n\t\t\t\t\tu32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tvosh_end = start - (u8 *)data + obj_size;\n\t\t\t\t\tvosh_end -= vosh_start;\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M2V_PIC_START_CODE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\tu8 PL;\n\t\t\tswitch (sc_type) {\n\t\t\tcase M4V_VOS_START_CODE:\n\t\t\t\tctx->dsi.VideoPL = (u8) gf_bs_read_u8(ctx->bs);\n\t\t\t\tvosh_start = start - (u8 *)data;\n\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\tassert(remain>=5);\n\t\t\t\tstart += 5;\n\t\t\t\tremain -= 5;\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOL_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\tPL = ctx->dsi.VideoPL;\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\tctx->dsi.VideoPL = PL;\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (data == ctx->hdr_store) {\n\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n\t\t\t\t\t\tctx->hdr_store_size = remain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);\n\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemmove(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\t}\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else {\n\t\t\t\t\tu32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tvosh_end = start - (u8 *)data + obj_size;\n\t\t\t\t\tvosh_end -= vosh_start;\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=(s32) obj_size);\n\t\t\t\t\tstart += obj_size;\n\t\t\t\t\tremain -= obj_size;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOP_START_CODE:\n\t\t\tcase M4V_GOV_START_CODE:\n\t\t\t\tbreak;\n\n\t\t\tcase M4V_VO_START_CODE:\n\t\t\tcase M4V_VISOBJ_START_CODE:\n\t\t\tdefault:\n\t\t\t\tif (vosh_start>=0) {\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=4);\n\t\t\t\t\tstart += 4;\n\t\t\t\t\tremain -= 4;\n\t\t\t\t} else if (!ctx->width) {\n\t\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\t\tPL = ctx->dsi.VideoPL;\n\t\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\t\tif (ctx->dsi.width) {\n\t\t\t\t\t\tu32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);\n\t\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\t\tvosh_end = start - (u8 *)data + obj_size;\n\t\t\t\t\t\tvosh_end -= vosh_start;\n\t\t\t\t\t\tmpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);\n\t\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\t\tassert(remain>=(s32) obj_size);\n\t\t\t\t\t\tstart += obj_size;\n\t\t\t\t\t\tremain -= obj_size;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (skip_pck) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->opid) {\n\t\t\tassert(remain>=4);\n\t\t\tstart += 4;\n\t\t\tremain -= 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = (u32) ((char *)start -  (char *)data);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//at this point, we no longer reaggregate packets\n\t\tctx->hdr_store_size = 0;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num);\n\t\t\tif (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\t//may happen that after all our checks, only 4 bytes are left, continue to store these 4 bytes\n\t\tif (remain<5)\n\t\t\tcontinue;\n\n\t\t//good to go\n\t\tgf_m4v_parser_reset(ctx->vparser, sc_type_forced ? forced_sc_type + 1 : 0);\n\t\tsize = 0;\n\t\te = gf_m4v_parse_frame(ctx->vparser, &ctx->dsi, &ftype, &tinc, &size, &fstart, &is_coded);\n\n\t\t//only for m1v/m2v, for m4v we may have fstart>0 when we strip VO and VISOBJ\n\t\tif (ctx->is_mpg12 && fstart && (fstart<remain)) {\n\t\t\t//start code (4 bytes) in header, adjst frame start and size\n\t\t\tif (sc_type_forced) {\n\t\t\t\tfstart += 4;\n\t\t\t\tsize-=4;\n\t\t\t}\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) fstart, &pck_data);\n\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\tmemcpy(pck_data, start, (size_t) fstart);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\tbyte_offset+=fstart;\n\t\t\t}\n\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\n\t\t\tstart += fstart;\n\t\t\tremain -= (s32) fstart;\n\t\t}\n\t\t//we may have VO or other packets before (fstart is on first of vop/gov/vol/vos)\n\t\telse if (fstart && (fstart + size <= remain)) {\n\t\t\t//start code (4 bytes) in header, adjst frame start and size\n\t\t\tif (sc_type_forced) {\n\t\t\t\tfstart += 4;\n\t\t\t\tsize-=4;\n\t\t\t}\n\t\t\tsize += fstart;\n\t\t}\n\n\t\t//we skipped bytes already in store + end of start code present in packet, so the size of the first object\n\t\t//needs adjustement\n\t\tif (bytes_from_store) {\n\t\t\tsize += bytes_from_store + hdr_offset;\n\t\t}\n\n\t\tif ((e == GF_EOS) && !ctx->input_is_au_end) {\n\t\t\tu8 b3 = start[remain-3];\n\t\t\tu8 b2 = start[remain-2];\n\t\t\tu8 b1 = start[remain-1];\n\n\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\tassert(size >= 3);\n\t\t\t\tsize -= 3;\n\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t}\n\t\t\tfull_frame = GF_FALSE;\n\t\t} else {\n\t\t\tfull_frame = GF_TRUE;\n\t\t}\n\n\t\tif (ftype) {\n\t\t\tif (!is_coded) {\n\t\t\t\t/*if prev is B and we're parsing a packed bitstream discard n-vop*/\n\t\t\t\tif ((ctx->forced_packed && ctx->b_frames)\n\t\t\t\t\t/*policy is to import at variable frame rate, skip*/\n\t\t\t\t\t|| ctx->vfr\n\t\t\t\t) {\n\t\t\t\t\tif (ctx->vfr) {\n\t\t\t\t\t\tctx->is_vfr = GF_TRUE;\n\t\t\t\t\t\tmpgviddmx_update_time(ctx);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx->is_packed = GF_TRUE;\n\t\t\t\t\t}\n\n\t\t\t\t\t//part of the frame was in store, adjust size\n\t\t\t\t\tif (bytes_from_store)\n\t\t\t\t\t\tsize-= bytes_from_store + hdr_offset;\n\n\t\t\t\t\tassert(remain>=size);\n\t\t\t\t\tstart += size;\n\t\t\t\t\tremain -= (s32) size;\n\t\t\t\t\t//trash all packets until we align to a new startcode\n\t\t\t\t\tctx->trash_trailer = full_frame ? GF_FALSE : GF_TRUE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*policy is to keep non coded frame (constant frame rate), add*/\n\t\t\t}\n\n\t\t\tif (ftype==3) {\n\t\t\t\t//count number of B-frames since last ref\n\t\t\t\tctx->b_frames++;\n\t\t\t\tctx->nb_b++;\n\t\t\t} else {\n\t\t\t\t//flush all pending packets\n\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);\n\t\t\t\t//remember the CTS of the last ref\n\t\t\t\tctx->last_ref_cts = ctx->cts;\n\t\t\t\tif (ctx->max_b < ctx->b_frames) ctx->max_b = ctx->b_frames;\n\n\t\t\t\tctx->b_frames = 0;\n\t\t\t\tif (ftype==2)\n\t\t\t\t\tctx->nb_p++;\n\t\t\t\telse\n\t\t\t\t\tctx->nb_i++;\n\t\t\t}\n\t\t\tctx->nb_frames++;\n\t\t} else {\n\t\t\tfull_frame = GF_FALSE;\n\t\t}\n\n\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t//bytes come from both our store and the data packet\n\t\tif (bytes_from_store) {\n\t\t\tmemcpy(pck_data, ctx->hdr_store+current, bytes_from_store);\n\t\t\tassert(size >= bytes_from_store);\n\t\t\tsize -= bytes_from_store;\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t}\n\t\t\tmemcpy(pck_data + bytes_from_store, start, (size_t) size);\n\t\t} else {\n\t\t\t//bytes only come the data packet\n\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data);\n\t\t\t}\n\t\t}\n\n\t\tif (ftype) {\n\t\t\tassert(pck_data[0] == 0);\n\t\t\tassert(pck_data[1] == 0);\n\t\t\tassert(pck_data[2] == 1);\n\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE);\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_dts(dst_pck, ctx->dts);\n\n\t\t\tif (ctx->input_is_au_start) {\n\t\t\t\tctx->input_is_au_start = GF_FALSE;\n\t\t\t} else {\n\t\t\t\t//we use the carousel flag temporarly to indicate the cts must be recomputed\n\t\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\t\t\t}\n\t\t\tgf_filter_pck_set_sap(dst_pck, (ftype==1) ? GF_FILTER_SAP_1 : GF_FILTER_SAP_NONE);\n\t\t\tif (ctx->cur_fps.den > 0) gf_filter_pck_set_duration(dst_pck, ctx->cur_fps.den);\n\t\t\tif (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);\n\t\t\tctx->frame_started = GF_TRUE;\n\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\n\t\t\tmpgviddmx_update_time(ctx);\n\t\t} else {\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE);\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t}\n\n\t\tif (!full_frame) {\n\t\t\tif (copy_last_bytes) {\n\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tassert(remain>=size);\n\t\tstart += size;\n\t\tremain -= (s32) size;\n\t}\n\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\treturn GF_OK;\n}\n\nstatic GF_Err mpgviddmx_initialize(GF_Filter *filter)\n{\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\tctx->hdr_store_size = 0;\n\tctx->hdr_store_alloc = MIN_HDR_STORE;\n\tctx->hdr_store = gf_malloc(sizeof(char)*ctx->hdr_store_alloc);\n\treturn GF_OK;\n}\n\nstatic void mpgviddmx_finalize(GF_Filter *filter)\n{\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->bs) gf_bs_del(ctx->bs);\n\tif (ctx->vparser) gf_m4v_parser_del_no_bs(ctx->vparser);\n\tif (ctx->indexes) gf_free(ctx->indexes);\n\tif (ctx->hdr_store) gf_free(ctx->hdr_store);\n\tif (ctx->pck_queue) {\n\t\twhile (gf_list_count(ctx->pck_queue)) {\n\t\t\tGF_FilterPacket *pck = gf_list_pop_back(ctx->pck_queue);\n\t\t\tgf_filter_pck_discard(pck);\n\t\t}\n\t\tgf_list_del(ctx->pck_queue);\n\t}\n\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\tif (ctx->importer) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s Import results: %d VOPs (%d Is - %d Ps - %d Bs)\\n\", ctx->is_mpg12 ? \"MPEG-1/2\" : \"MPEG-4 (Part 2)\", ctx->nb_frames, ctx->nb_i, ctx->nb_p, ctx->nb_b));\n\t\tif (ctx->nb_b) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"\\t%d max consecutive B-frames%s\\n\", ctx->max_b, ctx->is_packed ? \" - packed bitstream\" : \"\" ));\n\t\t}\n\t\tif (ctx->is_vfr && ctx->nb_b && ctx->is_packed) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"Warning: Mix of non-coded frames: packed bitstream and encoder skipped - unpredictable timing\\n\"));\n\t\t}\n\t}\n}\n\nu32 gf_m4v_parser_get_obj_type(GF_M4VParser *m4v);\n\nstatic const char * mpgvdmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\tGF_M4VParser *parser;\n\tu8 ftype;\n\tu32 tinc, nb_frames, o_start=0;\n\tu64 fsize, start;\n\tBool is_coded;\n\tGF_Err e;\n\tGF_M4VDecSpecInfo dsi;\n\n\tmemset(&dsi, 0, sizeof(GF_M4VDecSpecInfo));\n\tparser = gf_m4v_parser_new((char*)data, size, GF_FALSE);\n\tnb_frames = 0;\n\twhile (1) {\n\t\tu32 otype;\n\t\tftype = 0;\n\t\tis_coded = GF_FALSE;\n\t\te = gf_m4v_parse_frame(parser, &dsi, &ftype, &tinc, &fsize, &start, &is_coded);\n\t\tif (!nb_frames && start) o_start = (u32) start;\n\n\t\totype = gf_m4v_parser_get_obj_type(parser);\n\t\tswitch (otype) {\n\t\tcase M4V_VOL_START_CODE:\n\t\tcase M4V_VOP_START_CODE:\n\t\tcase M4V_VISOBJ_START_CODE:\n\t\tcase M4V_VOS_START_CODE:\n\t\tcase M4V_GOV_START_CODE:\n\t\tcase M4V_UDTA_START_CODE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\totype = 0;\n\t\t}\n\n\t\t//if start is more than 4 (start-code size), we have garbage at the beginning, do not parse\n\t\t//except if we have a valid object VOS\n\t\tif (!nb_frames && (start>4) && !otype) {\n\t\t\tbreak;\n\t\t}\n\t\tif (is_coded) nb_frames++;\n\t\tif (e==GF_EOS) {\n\t\t\te = GF_OK;\n\t\t\t//special case if the only frame we have is not coded\n\t\t\tif (otype == M4V_VOP_START_CODE) {\n\t\t\t\tif (!nb_frames) nb_frames++;\n\t\t\t\tis_coded = 1;\n\t\t\t}\n\n\t\t\tif (is_coded) nb_frames++;\n\t\t\tbreak;\n\t\t}\n\t\tif (ftype>2) break;\n\t\tif (e) break;\n\t\tnb_frames++;\n\t}\n\tgf_m4v_parser_del(parser);\n\tif ((e==GF_OK) && (nb_frames>1)) {\n\t\t*score = o_start ? GF_FPROBE_MAYBE_NOT_SUPPORTED : GF_FPROBE_MAYBE_SUPPORTED;\n\t\treturn \"video/mp4v-es\";\n\t}\n\n\tmemset(&dsi, 0, sizeof(GF_M4VDecSpecInfo));\n\tparser = gf_m4v_parser_new((char*)data, size, GF_TRUE);\n\tnb_frames = 0;\n\twhile (1) {\n\t\tftype = 0;\n\t\tis_coded = GF_FALSE;\n\t\te = gf_m4v_parse_frame(parser, &dsi, &ftype, &tinc, &fsize, &start, &is_coded);\n\n\t\t//if start is more than 4 (start-code size), we have garbage at the beginning, do not parse\n\t\tif (!nb_frames && (start>4) ) {\n\t\t\tbreak;\n\t\t}\n\t\tif (is_coded) nb_frames++;\n\t\tif (e==GF_EOS) {\n\t\t\tif (is_coded) nb_frames++;\n\t\t\te = GF_OK;\n\t\t\tbreak;\n\t\t}\n\t\tif (ftype>2) break;\n\t\tif (e) break;\n\t\tnb_frames++;\n\t}\n\tgf_m4v_parser_del(parser);\n\tif ((e==GF_OK) && (nb_frames>1)) {\n\t\t*score = o_start ? GF_FPROBE_MAYBE_NOT_SUPPORTED : GF_FPROBE_MAYBE_SUPPORTED;\n\t\treturn \"video/mpgv-es\";\n\t}\n\treturn NULL;\n}\n\nstatic const GF_FilterCapability MPGVidDmxCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"cmp|m1v|m2v|m4v\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"video/mp4v-es|video/mpgv-es\"),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG4_PART2),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG1),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SIMPLE),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SPATIAL),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SNR),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_MAIN),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_HIGH),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_422),\n\tCAP_BOOL(GF_CAPS_OUTPUT_STATIC_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG4_PART2),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG1),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SPATIAL),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SNR),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SIMPLE),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_MAIN),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_HIGH),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_422),\n\tCAP_BOOL(GF_CAPS_INPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n};\n\n\n#define OFFS(_n)\t#_n, offsetof(GF_MPGVidDmxCtx, _n)\nstatic const GF_FilterArgs MPGVidDmxArgs[] =\n{\n\t{ OFFS(fps), \"import frame rate (0 default to FPS from bitstream or 25 Hz)\", GF_PROP_FRACTION, \"0/1000\", NULL, 0},\n\t{ OFFS(index), \"indexing window length. If 0, bitstream is not probed for duration. A negative value skips the indexing if the source file is larger than 20M (slows down importers) unless a play with start range > 0 is issued\", GF_PROP_DOUBLE, \"-1.0\", NULL, 0},\n\t{ OFFS(vfr), \"set variable frame rate import\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(importer), \"compatibility with old importer, displays import results\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(notime), \"ignore input timestamps, rebuild from 0\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{0}\n};\n\n\nGF_FilterRegister MPGVidDmxRegister = {\n\t.name = \"rfmpgvid\",\n\tGF_FS_SET_DESCRIPTION(\"M1V/M2V/M4V reframer\")\n\tGF_FS_SET_HELP(\"This filter parses MPEG-1/2 and MPEG-4 part 2 video files/data and outputs corresponding video PID and frames.\\n\"\n\t\t\"Note: The filter uses negative CTS offsets: CTS is correct, but some frames may have DTS greater than CTS.\")\n\t.private_size = sizeof(GF_MPGVidDmxCtx),\n\t.args = MPGVidDmxArgs,\n\t.initialize = mpgviddmx_initialize,\n\t.finalize = mpgviddmx_finalize,\n\tSETCAPS(MPGVidDmxCaps),\n\t.configure_pid = mpgviddmx_configure_pid,\n\t.process = mpgviddmx_process,\n\t.probe_data = mpgvdmx_probe_data,\n\t.process_event = mpgviddmx_process_event\n};\n\n\nconst GF_FilterRegister *rfmpgvid_register(GF_FilterSession *session)\n{\n\treturn &MPGVidDmxRegister;\n}\n#else\nconst GF_FilterRegister *rfmpgvid_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif // #if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_RFMPGVID)\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / MPEG-1/2/4(Part2) video reframer filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n#include <gpac/internal/media_dev.h>\n\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_RFMPGVID)\n\n#define MIN_HDR_STORE\t12\ntypedef struct\n{\n\tu64 pos;\n\tDouble start_time;\n} MPGVidIdx;\n\ntypedef struct\n{\n\t//filter args\n\tGF_Fraction fps;\n\tDouble index;\n\tBool vfr, importer, notime;\n\n\t//only one input pid declared\n\tGF_FilterPid *ipid;\n\t//only one output pid declared\n\tGF_FilterPid *opid;\n\n\tGF_BitStream *bs;\n\tu64 cts, dts, prev_dts;\n\tu32 width, height;\n\tGF_Fraction64 duration;\n\tDouble start_range;\n\tBool in_seek;\n\tu32 timescale;\n\n\tu32 resume_from;\n\tGF_Fraction cur_fps;\n\n\tBool is_mpg12, forced_packed;\n\tGF_M4VParser *vparser;\n\tGF_M4VDecSpecInfo dsi;\n\tu32 b_frames;\n\tBool is_packed, is_vfr;\n\tGF_List *pck_queue;\n\tu64 last_ref_cts;\n\tBool frame_started;\n\n\tu32 nb_i, nb_p, nb_b, nb_frames, max_b;\n\n\tu32 bytes_in_header;\n\tchar *hdr_store;\n\tu32 hdr_store_size, hdr_store_alloc;\n\n\tBool is_playing;\n\tBool is_file, file_loaded;\n\tBool initial_play_done;\n\n\tBool input_is_au_start, input_is_au_end;\n\tBool recompute_cts, copy_props;\n\n\tGF_FilterPacket *src_pck;\n\n\tMPGVidIdx *indexes;\n\tu32 index_alloc_size, index_size;\n\tu32 bitrate;\n\tBool trash_trailer;\n} GF_MPGVidDmxCtx;\n\n\nGF_Err mpgviddmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tBool was_mpeg12;\n\tconst GF_PropertyValue *p;\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tctx->ipid = pid;\n\tctx->cur_fps = ctx->fps;\n\tif (!ctx->fps.num || !ctx->fps.den) {\n\t\tctx->cur_fps.num = 25000;\n\t\tctx->cur_fps.den = 1000;\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\tif (p) {\n\t\tctx->timescale = ctx->cur_fps.num = p->value.uint;\n\t\tctx->cur_fps.den = 0;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FPS);\n\t\tif (p) {\n\t\t\tctx->cur_fps = p->value.frac;\n\t\t}\n\t\tp = gf_filter_pid_get_property_str(pid, \"nocts\");\n\t\tif (p && p->value.boolean) ctx->recompute_cts = GF_TRUE;\n\t}\n\n\twas_mpeg12 = ctx->is_mpg12;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\tif (p) {\n\t\tswitch (p->value.uint) {\n\t\tcase GF_CODECID_MPEG1:\n\t\tcase GF_CODECID_MPEG2_422:\n\t\tcase GF_CODECID_MPEG2_SNR:\n\t\tcase GF_CODECID_MPEG2_HIGH:\n\t\tcase GF_CODECID_MPEG2_MAIN:\n\t\tcase GF_CODECID_MPEG2_SIMPLE:\n\t\tcase GF_CODECID_MPEG2_SPATIAL:\n\t\t\tctx->is_mpg12 = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\telse {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_MIME);\n\t\tif (p && p->value.string && (strstr(p->value.string, \"m1v\") || strstr(p->value.string, \"m2v\")) ) ctx->is_mpg12 = GF_TRUE;\n\t\telse {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FILE_EXT);\n\t\t\tif (p && p->value.string && (strstr(p->value.string, \"m1v\") || strstr(p->value.string, \"m2v\")) ) ctx->is_mpg12 = GF_TRUE;\n\t\t}\n\t}\n\n\tif (ctx->vparser && (was_mpeg12 != ctx->is_mpg12)) {\n\t\tgf_m4v_parser_del_no_bs(ctx->vparser);\n\t\tctx->vparser = NULL;\n\t}\n\n\tif (ctx->timescale && !ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\t}\n\t//if source has no timescale, recompute time\n\tif (!ctx->timescale) ctx->notime = GF_TRUE;\n\telse ctx->copy_props = GF_TRUE;\n\n\treturn GF_OK;\n}\n\n\nstatic void mpgviddmx_check_dur(GF_Filter *filter, GF_MPGVidDmxCtx *ctx)\n{\n\n\tFILE *stream;\n\tGF_BitStream *bs;\n\tGF_M4VParser *vparser;\n\tGF_M4VDecSpecInfo dsi;\n\tGF_Err e;\n\tu32 probe_size=0;\n\tu64 duration, cur_dur, rate;\n\tconst GF_PropertyValue *p;\n\tif (!ctx->opid || ctx->timescale || ctx->file_loaded) return;\n\n\tif (ctx->index<0) {\n\t\tif (gf_opts_get_bool(\"temp\", \"force_indexing\")) {\n\t\t\tctx->index = 1.0;\n\t\t} else {\n\t\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_DOWN_SIZE);\n\t\t\tif (!p || (p->value.longuint > 20000000)) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[MPGVids] Source file larger than 20M, skipping indexing\\n\"));\n\t\t\t\tif (!gf_sys_is_test_mode())\n\t\t\t\t\tprobe_size = 20000000;\n\t\t\t} else {\n\t\t\t\tctx->index = -ctx->index;\n\t\t\t}\n\t\t}\n\t}\n\tif ((ctx->index<=0) && !probe_size) {\n\t\tctx->duration.num = 1;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILEPATH);\n\tif (!p || !p->value.string || !strncmp(p->value.string, \"gmem://\", 7)) {\n\t\tctx->is_file = GF_FALSE;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\tctx->is_file = GF_TRUE;\n\n\tstream = gf_fopen_ex(p->value.string, NULL, \"rb\", GF_TRUE);\n\tif (!stream) {\n\t\tif (gf_fileio_is_main_thread(p->value.string))\n\t\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tctx->index_size = 0;\n\n\tbs = gf_bs_from_file(stream, GF_BITSTREAM_READ);\n\n\tvparser = gf_m4v_parser_bs_new(bs, ctx->is_mpg12);\n\te = gf_m4v_parse_config(vparser, &dsi);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Could not parse video header - duration  not estimated\\n\"));\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tduration = 0;\n\tcur_dur = 0;\n\twhile (gf_bs_available(bs)) {\n\t\tu8 ftype;\n\t\tu32 tinc;\n\t\tu64 fsize, start;\n\t\tBool is_coded;\n\t\tu64 pos;\n\t\tpos = gf_m4v_get_object_start(vparser);\n\t\te = gf_m4v_parse_frame(vparser, &dsi, &ftype, &tinc, &fsize, &start, &is_coded);\n\t\tif (e<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Could not parse video frame\\n\"));\n\t\t\tcontinue;\n\t\t}\n\t\tif (probe_size && (pos>probe_size) && (ftype==1)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tduration += ctx->cur_fps.den;\n\t\tcur_dur += ctx->cur_fps.den;\n\t\t//only index at I-frame start\n\t\tif (!probe_size && pos && (ftype==1) && (cur_dur >= ctx->index * ctx->cur_fps.num) ) {\n\t\t\tif (!ctx->index_alloc_size) ctx->index_alloc_size = 10;\n\t\t\telse if (ctx->index_alloc_size == ctx->index_size) ctx->index_alloc_size *= 2;\n\t\t\tctx->indexes = gf_realloc(ctx->indexes, sizeof(MPGVidIdx)*ctx->index_alloc_size);\n\t\t\tctx->indexes[ctx->index_size].pos = pos;\n\t\t\tctx->indexes[ctx->index_size].start_time = (Double) (duration-ctx->cur_fps.den);\n\t\t\tctx->indexes[ctx->index_size].start_time /= ctx->cur_fps.num;\n\t\t\tctx->index_size ++;\n\t\t\tcur_dur = 0;\n\t\t}\n\t}\n\n\trate = gf_bs_get_position(bs);\n\tgf_m4v_parser_del(vparser);\n\tgf_fclose(stream);\n\n\tif (!ctx->duration.num || (ctx->duration.num  * ctx->cur_fps.num != duration * ctx->duration.den)) {\n\t\tctx->duration.num = (s32) duration;\n\t\tctx->duration.den = ctx->cur_fps.num;\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\t\tif (duration && !gf_sys_is_test_mode() ) {\n\t\t\trate *= 8 * ctx->duration.den;\n\t\t\trate /= ctx->duration.num;\n\t\t\tctx->bitrate = (u32) rate;\n\t\t}\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n}\n\n\nstatic void mpgviddmx_enqueue_or_dispatch(GF_MPGVidDmxCtx *ctx, GF_FilterPacket *pck, Bool flush_ref, Bool is_eos)\n{\n\tif (pck && ctx->trash_trailer) {\n\t\tgf_filter_pck_discard(pck);\n\t\treturn;\n\t}\n\n\tif (!is_eos && (!ctx->width || !ctx->height))\n\t\tflush_ref = GF_FALSE;\n\n\t//need to signal this for consumers using DTS (eg MPEG-2 TS)\n\tif (flush_ref && ctx->pck_queue) {\n\t\t//send all reference packet queued\n\t\tu32 i, count = gf_list_count(ctx->pck_queue);\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu64 cts;\n\t\t\tGF_FilterPacket *q_pck = gf_list_get(ctx->pck_queue, i);\n\t\t\tu8 carousel = gf_filter_pck_get_carousel_version(q_pck);\n\t\t\tif (!carousel) {\n\t\t\t\tgf_filter_pck_send(q_pck);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgf_filter_pck_set_carousel_version(q_pck, 0);\n\t\t\tcts = gf_filter_pck_get_cts(q_pck);\n\t\t\tif (cts != GF_FILTER_NO_TS) {\n\t\t\t\t//offset the cts of the ref frame to the number of B frames in-between\n\t\t\t\tif (ctx->last_ref_cts == cts) {\n\t\t\t\t\tcts += ctx->b_frames * ctx->cur_fps.den;\n\t\t\t\t\tgf_filter_pck_set_cts(q_pck, cts);\n\t\t\t\t} else {\n\t\t\t\t\t//shift all other frames (i.e. pending Bs) by 1 frame in the past since we move the ref frame after them\n\t\t\t\t\tassert(cts >= ctx->cur_fps.den);\n\t\t\t\t\tcts -= ctx->cur_fps.den;\n\t\t\t\t\tgf_filter_pck_set_cts(q_pck, cts);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_eos && (i+1==count)) {\n\t\t\t\tBool start, end;\n\t\t\t\tgf_filter_pck_get_framing(q_pck, &start, &end);\n\t\t\t\tgf_filter_pck_set_framing(q_pck, start, GF_TRUE);\n\t\t\t}\n\t\t\tgf_filter_pck_send(q_pck);\n\t\t}\n\t\tgf_list_reset(ctx->pck_queue);\n\t}\n\tif (!pck) return;\n\n\tif (!ctx->pck_queue) ctx->pck_queue = gf_list_new();\n\tgf_list_add(ctx->pck_queue, pck);\n}\n\nstatic void mpgviddmx_check_pid(GF_Filter *filter, GF_MPGVidDmxCtx *ctx, u32 vosh_size, u8 *data)\n{\n\tBool flush_after = GF_FALSE;\n\tif (!ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tmpgviddmx_check_dur(filter, ctx);\n\t}\n\n\tif ((ctx->width == ctx->dsi.width) && (ctx->height == ctx->dsi.height) && !ctx->copy_props) return;\n\n\t//copy properties at init or reconfig\n\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\tctx->copy_props = GF_FALSE;\n\tif (ctx->duration.num)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\tif (!ctx->timescale)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CAN_DATAREF, & PROP_BOOL(GF_TRUE ) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, & PROP_UINT(GF_STREAM_VISUAL));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, & PROP_UINT(ctx->timescale ? ctx->timescale : ctx->cur_fps.num));\n\n\t//if we have a FPS prop, use it\n\tif (!gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FPS))\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_FPS, & PROP_FRAC(ctx->cur_fps));\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\n\tif (ctx->width && ctx->height) {\n\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);\n\t} else {\n\t\tflush_after = GF_TRUE;\n\t}\n\tctx->width = ctx->dsi.width;\n\tctx->height = ctx->dsi.height;\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, & PROP_UINT( ctx->dsi.width));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, & PROP_UINT( ctx->dsi.height));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAR, & PROP_FRAC_INT(ctx->dsi.par_num, ctx->dsi.par_den));\n\n\tif (ctx->is_mpg12) {\n\t\tconst GF_PropertyValue *cid = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_CODECID);\n\t\tu32 PL = 0;\n\t\tif (cid) {\n\t\t\tswitch (cid->value.uint) {\n\t\t\tcase GF_CODECID_MPEG2_MAIN:\n\t\t\tcase GF_CODECID_MPEG2_422:\n\t\t\tcase GF_CODECID_MPEG2_SNR:\n\t\t\tcase GF_CODECID_MPEG2_HIGH:\n\t\t\t\t//keep same signaling\n\t\t\t\tPL = cid->value.uint;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tu32 prof = (ctx->dsi.VideoPL>>4) & 0x7;\n\t\t\tif (prof==1) PL = GF_CODECID_MPEG2_HIGH;\n\t\t\telse if (prof==2) PL = GF_CODECID_MPEG2_SNR;\n\t\t\telse if (prof==3) PL = GF_CODECID_MPEG2_SNR;\n\t\t\telse if (prof==4) PL = GF_CODECID_MPEG2_MAIN;\n\t\t\telse if (prof==5) PL = GF_CODECID_MPEG2_SIMPLE;\n\t\t}\n\n\t\tif (!PL)\n\t\t\tPL = (ctx->dsi.VideoPL == GF_CODECID_MPEG1) ? GF_CODECID_MPEG1 : GF_CODECID_MPEG2_MAIN;\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(PL));\n\t} else {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(GF_CODECID_MPEG4_PART2));\n\t}\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PROFILE_LEVEL, & PROP_UINT (ctx->dsi.VideoPL) );\n\n\tif (ctx->bitrate) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->bitrate));\n\t}\n\n\tctx->b_frames = 0;\n\n\tif (vosh_size) {\n\t\tu32 i;\n\t\tchar * dcfg = gf_malloc(sizeof(char)*vosh_size);\n\t\tmemcpy(dcfg, data, sizeof(char)*vosh_size);\n\n\t\t/*remove packed flag if any (VOSH user data)*/\n\t\tctx->is_packed = ctx->is_vfr = ctx->forced_packed = GF_FALSE;\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tchar *frame = dcfg;\n\t\t\twhile ((i+3<vosh_size)  && ((frame[i]!=0) || (frame[i+1]!=0) || (frame[i+2]!=1))) i++;\n\t\t\tif (i+4>=vosh_size) break;\n\t\t\tif (strncmp(frame+i+4, \"DivX\", 4)) {\n\t\t\t\ti += 4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tframe = memchr(dcfg + i + 4, 'p', vosh_size - i - 4);\n\t\t\tif (frame) {\n\t\t\t\tctx->forced_packed = GF_TRUE;\n\t\t\t\tframe[0] = 'n';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, & PROP_DATA_NO_COPY(dcfg, vosh_size));\n\t}\n\n\tif (ctx->is_file && ctx->index) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, & PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) );\n\t}\n\n\tif (!gf_sys_is_test_mode()) {\n\t\tif (ctx->dsi.chroma_fmt)\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_CHROMAFMT, & PROP_UINT(ctx->dsi.chroma_fmt) );\n\n\t\tif (ctx->is_mpg12)\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_INTERLACED, !ctx->dsi.progresive ? & PROP_BOOL(GF_TRUE) : NULL );\n\t}\n\n\tif (flush_after)\n\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);\n\n}\n\nstatic Bool mpgviddmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 i;\n\tu64 file_pos = 0;\n\tGF_FilterEvent fevt;\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->is_playing = GF_TRUE;\n\t\t\tctx->cts = 0;\n\t\t\tctx->bytes_in_header = 0;\n\t\t}\n\t\tif (! ctx->is_file) {\n\t\t\tif (!ctx->initial_play_done) {\n\t\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t\tif (evt->play.start_range>0.1) ctx->resume_from = 0;\n \t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tctx->start_range = evt->play.start_range;\n\t\tctx->in_seek = GF_TRUE;\n\n\t\tif (ctx->start_range) {\n\t\t\tif (ctx->index<0) {\n\t\t\t\tctx->index = -ctx->index;\n\t\t\t\tctx->file_loaded = GF_FALSE;\n\t\t\t\tctx->duration.den = ctx->duration.num = 0;\n\t\t\t\tmpgviddmx_check_dur(filter, ctx);\n\t\t\t}\n\n\t\t\tfor (i=1; i<ctx->index_size; i++) {\n\t\t\t\tif ((ctx->indexes[i].start_time > ctx->start_range) || (i+1==ctx->index_size)) {\n\t\t\t\t\tctx->cts = (u64) (ctx->indexes[i-1].start_time * ctx->cur_fps.num);\n\t\t\t\t\tfile_pos = ctx->indexes[i-1].pos;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tctx->dts = ctx->cts;\n\t\tif (!ctx->initial_play_done) {\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t//seek will not change the current source state, don't send a seek\n\t\t\tif (!file_pos)\n\t\t\t\treturn GF_TRUE;\n\t\t}\n\t\tctx->resume_from = 0;\n\t\tctx->bytes_in_header = 0;\n\t\t//post a seek\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\tfevt.seek.start_offset = file_pos;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\tctx->is_playing = GF_FALSE;\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = NULL;\n\t\tif (ctx->pck_queue) {\n\t\t\twhile (gf_list_count(ctx->pck_queue)) {\n\t\t\t\tGF_FilterPacket *pck=gf_list_pop_front(ctx->pck_queue);\n\t\t\t\tgf_filter_pck_discard(pck);\n\t\t\t}\n\t\t}\n\t\tctx->cts = 0;\n\t\t//don't cancel event\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nstatic GFINLINE void mpgviddmx_update_time(GF_MPGVidDmxCtx *ctx)\n{\n\tassert(ctx->cur_fps.num);\n\n\tif (!ctx->notime) {\n\t\tu64 inc = 3000;\n\t\tif (ctx->cur_fps.den && ctx->cur_fps.num) {\n\t\t\tinc = ctx->cur_fps.den;\n\t\t\tif (ctx->cur_fps.num != ctx->timescale) {\n\t\t\t\tinc *= ctx->timescale;\n\t\t\t\tinc /= ctx->cur_fps.num;\n\t\t\t}\n\t\t}\n\t\tctx->cts += inc;\n\t\tctx->dts += inc;\n\t} else {\n\t\tassert(ctx->cur_fps.den);\n\t\tctx->cts += ctx->cur_fps.den;\n\t\tctx->dts += ctx->cur_fps.den;\n\t}\n}\n\n\nstatic s32 mpgviddmx_next_start_code(u8 *data, u32 size)\n{\n\tu32 v, bpos, found;\n\ts64 start, end;\n\n\tbpos = 0;\n\tfound = 0;\n\tstart = 0;\n\tend = 0;\n\n\tv = 0xffffffff;\n\twhile (!end) {\n\t\tif (bpos == size)\n\t\t\treturn -1;\n\t\tv = ( (v<<8) & 0xFFFFFF00) | data[bpos];\n\n\t\tbpos++;\n\t\tif ((v & 0xFFFFFF00) == 0x00000100) {\n\t\t\tend = start + bpos - 4;\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn -1;\n\tassert(end >= start);\n\treturn (s32) (end - start);\n}\n\nGF_Err mpgviddmx_process(GF_Filter *filter)\n{\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu64 byte_offset;\n\ts64 vosh_start = -1;\n\ts64 vosh_end = -1;\n\tGF_Err e;\n\tchar *data;\n\tu8 *start;\n\tu32 pck_size;\n\ts32 remain;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tmpgviddmx_check_dur(filter, ctx);\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_TRUE);\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\tctx->src_pck = NULL;\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n\n\tstart = data;\n\tremain = pck_size;\n\n\t//input pid was muxed - we flushed pending data , update cts\n\tif (!ctx->resume_from && ctx->timescale) {\n\t\tif (!ctx->notime) {\n\t\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\t\tif (!ctx->cts || !ctx->recompute_cts)\n\t\t\t\t\tctx->cts = ts;\n\t\t\t}\n\t\t\tts = gf_filter_pck_get_dts(pck);\n\t\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\t\tif (!ctx->dts || !ctx->recompute_cts) {\n\t\t\t\t\tctx->dts = ts;\n\t\t\t\t}\n\n\t\t\t\tif (!ctx->prev_dts) ctx->prev_dts = ts;\n\t\t\t\telse if (ctx->prev_dts != ts) {\n\t\t\t\t\tu64 diff = ts;\n\t\t\t\t\tdiff -= ctx->prev_dts;\n\t\t\t\t\tif (!ctx->cur_fps.den)\n\t\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\t\t\t\t\telse if (ctx->cur_fps.den > diff)\n\t\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\n\t\t\t\t\tctx->prev_dts = ts;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgf_filter_pck_get_framing(pck, &ctx->input_is_au_start, &ctx->input_is_au_end);\n\t\t//we force it to true to deal with broken avi packaging where a video AU is split across several AVI video frames\n\t\tctx->input_is_au_end = GF_FALSE;\n\t\t//this will force CTS recomput of each frame\n\t\tif (ctx->recompute_cts) ctx->input_is_au_start = GF_FALSE;\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = pck;\n\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t}\n\n\t//we stored some data to find the complete vosh, aggregate this packet with current one\n\tif (!ctx->resume_from && ctx->hdr_store_size) {\n\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) {\n\t\t\tctx->hdr_store_alloc = ctx->hdr_store_size + pck_size;\n\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t}\n\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);\n\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\tif (byte_offset >= ctx->hdr_store_size)\n\t\t\t\tbyte_offset -= ctx->hdr_store_size;\n\t\t\telse\n\t\t\t\tbyte_offset = GF_FILTER_NO_BO;\n\t\t}\n\t\tctx->hdr_store_size += pck_size;\n\t\tstart = data = ctx->hdr_store;\n\t\tremain = pck_size = ctx->hdr_store_size;\n\t}\n\n\tif (ctx->resume_from) {\n\t\tif (gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\n\t\t//resume from data copied internally\n\t\tif (ctx->hdr_store_size) {\n\t\t\tassert(ctx->resume_from <= ctx->hdr_store_size);\n\t\t\tstart = data = ctx->hdr_store + ctx->resume_from;\n\t\t\tremain = pck_size = ctx->hdr_store_size - ctx->resume_from;\n\t\t} else {\n\t\t\tassert(remain >= (s32) ctx->resume_from);\n\t\t\tstart += ctx->resume_from;\n\t\t\tremain -= ctx->resume_from;\n\t\t}\n\t\tctx->resume_from = 0;\n\t}\n\n\tif (!ctx->bs) {\n\t\tctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);\n\t} else {\n\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t}\n\tif (!ctx->vparser) {\n\t\tctx->vparser = gf_m4v_parser_bs_new(ctx->bs, ctx->is_mpg12);\n\t}\n\n\n\twhile (remain) {\n\t\tBool full_frame;\n\t\tu8 *pck_data;\n\t\ts32 current;\n\t\tu8 sc_type, forced_sc_type=0;\n\t\tBool sc_type_forced = GF_FALSE;\n\t\tBool skip_pck = GF_FALSE;\n\t\tu8 ftype;\n\t\tu32 tinc;\n\t\tu64 size=0;\n\t\tu64 fstart=0;\n\t\tBool is_coded;\n\t\tu32 bytes_from_store = 0;\n\t\tu32 hdr_offset = 0;\n\t\tBool copy_last_bytes = GF_FALSE;\n\n\t\t//not enough bytes to parse start code\n\t\tif (remain<5) {\n\t\t\tmemcpy(ctx->hdr_store, start, remain);\n\t\t\tctx->bytes_in_header = remain;\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = -1;\n\n\t\t//we have some potential bytes of a start code in the store, copy some more bytes and check if valid start code.\n\t\t//if not, dispatch these bytes as continuation of the data\n\t\tif (ctx->bytes_in_header) {\n\n\t\t\tmemcpy(ctx->hdr_store + ctx->bytes_in_header, start, MIN_HDR_STORE - ctx->bytes_in_header);\n\t\t\tcurrent = mpgviddmx_next_start_code(ctx->hdr_store, MIN_HDR_STORE);\n\n\t\t\t//no start code in stored buffer\n\t\t\tif ((current<0) || (current >= (s32) ctx->bytes_in_header) )  {\n\t\t\t\tif (ctx->opid) {\n\t\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);\n\t\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tgf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_NONE);\n\t\t\t\t\tmemcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);\n\t\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\n\t\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);\n\t\t\t\t\t}\n\n\t\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\t}\n\n\t\t\t\tif (current<0) current = -1;\n\t\t\t\telse current -= ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t} else {\n\t\t\t\t//we have a valid start code, check which byte in our store or in the packet payload is the start code type\n\t\t\t\t//and remember its location to reinit the parser from there\n\t\t\t\thdr_offset = 4 - ctx->bytes_in_header + current;\n\t\t\t\t//bytes still to dispatch\n\t\t\t\tbytes_from_store = ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t\tif (!hdr_offset) {\n\t\t\t\t\tforced_sc_type = ctx->hdr_store[current+3];\n\t\t\t\t} else {\n\t\t\t\t\tforced_sc_type = start[hdr_offset-1];\n\t\t\t\t}\n\t\t\t\tsc_type_forced = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\t//no startcode in store, look for startcode in packet\n\t\tif (current == -1) {\n\t\t\t//locate next start code\n\t\t\tcurrent = mpgviddmx_next_start_code(start, remain);\n\t\t\t//no start code, dispatch the block\n\t\t\tif (current<0) {\n\t\t\t\tu8 b3, b2, b1;\n\t\t\t\tif (! ctx->frame_started) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MPGVid] no start code in block and no frame started, discarding data\\n\" ));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsize = remain;\n\t\t\t\tb3 = start[remain-3];\n\t\t\t\tb2 = start[remain-2];\n\t\t\t\tb1 = start[remain-1];\n\t\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\t\tassert(size >= 3);\n\t\t\t\t\tsize -= 3;\n\t\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t\t}\n\n\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\n\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tif (copy_last_bytes) {\n\t\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tassert(current>=0);\n\n\t\t//if we are in the middle of parsing the vosh, skip over bytes remaining from previous obj not parsed\n\t\tif ((vosh_start>=0) && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//also skip if no output pid\n\t\tif (!ctx->opid && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//dispatch remaining bytes\n\t\tif (current>0) {\n\t\t\t//flush remaining\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data);\n\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t//bytes were partly in store, partly in packet\n\t\t\tif (bytes_from_store) {\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t\t}\n\t\t\t\tassert(bytes_from_store>=(u32) current);\n\t\t\t\tbytes_from_store -= current;\n\t\t\t\tmemcpy(pck_data, ctx->hdr_store, current);\n\t\t\t} else {\n\t\t\t\t//bytes were only in packet\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\t\t\t\tmemcpy(pck_data, start, current);\n\t\t\t\tassert(remain>=current);\n\t\t\t\tstart += current;\n\t\t\t\tremain -= current;\n\t\t\t\tcurrent = 0;\n\t\t\t}\n\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t}\n\n\t\t//we're align to startcode, stop trashing packets\n\t\tctx->trash_trailer = GF_FALSE;\n\n\t\t//not enough bytes to parse start code\n\t\tif (remain<5) {\n\t\t\tmemcpy(ctx->hdr_store, start, remain);\n\t\t\tctx->bytes_in_header = remain;\n\t\t\tbreak;\n\t\t}\n\n\t\t//parse headers\n\t\t//we have a start code loaded, eg the data packet does not have a full start code at the beginning\n\t\tif (sc_type_forced) {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset);\n\t\t\tsc_type = forced_sc_type;\n\t\t} else {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\tgf_bs_read_int(ctx->bs, 24);\n\t\t\tsc_type = gf_bs_read_int(ctx->bs, 8);\n\t\t}\n\n\t\tif (ctx->is_mpg12) {\n\t\t\tswitch (sc_type) {\n\t\t\tcase M2V_SEQ_START_CODE:\n\t\t\tcase M2V_EXT_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (data == ctx->hdr_store) {\n\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n\t\t\t\t\t\tctx->hdr_store_size = remain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);\n\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemmove(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\t}\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else if (ctx->dsi.width && ctx->dsi.height) {\n\t\t\t\t\tu32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tvosh_end = start - (u8 *)data + obj_size;\n\t\t\t\t\tvosh_end -= vosh_start;\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M2V_PIC_START_CODE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\tu8 PL;\n\t\t\tswitch (sc_type) {\n\t\t\tcase M4V_VOS_START_CODE:\n\t\t\t\tctx->dsi.VideoPL = (u8) gf_bs_read_u8(ctx->bs);\n\t\t\t\tvosh_start = start - (u8 *)data;\n\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\tassert(remain>=5);\n\t\t\t\tstart += 5;\n\t\t\t\tremain -= 5;\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOL_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\tPL = ctx->dsi.VideoPL;\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\tctx->dsi.VideoPL = PL;\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (data == ctx->hdr_store) {\n\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n\t\t\t\t\t\tctx->hdr_store_size = remain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);\n\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemmove(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\t}\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else {\n\t\t\t\t\tu32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tvosh_end = start - (u8 *)data + obj_size;\n\t\t\t\t\tvosh_end -= vosh_start;\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=(s32) obj_size);\n\t\t\t\t\tstart += obj_size;\n\t\t\t\t\tremain -= obj_size;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOP_START_CODE:\n\t\t\tcase M4V_GOV_START_CODE:\n\t\t\t\tbreak;\n\n\t\t\tcase M4V_VO_START_CODE:\n\t\t\tcase M4V_VISOBJ_START_CODE:\n\t\t\tdefault:\n\t\t\t\tif (vosh_start>=0) {\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=4);\n\t\t\t\t\tstart += 4;\n\t\t\t\t\tremain -= 4;\n\t\t\t\t} else if (!ctx->width) {\n\t\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\t\tPL = ctx->dsi.VideoPL;\n\t\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\t\tif (ctx->dsi.width) {\n\t\t\t\t\t\tu32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);\n\t\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\t\tvosh_end = start - (u8 *)data + obj_size;\n\t\t\t\t\t\tvosh_end -= vosh_start;\n\t\t\t\t\t\tmpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);\n\t\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\t\tassert(remain>=(s32) obj_size);\n\t\t\t\t\t\tstart += obj_size;\n\t\t\t\t\t\tremain -= obj_size;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (skip_pck) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->opid) {\n\t\t\tassert(remain>=4);\n\t\t\tstart += 4;\n\t\t\tremain -= 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = (u32) ((char *)start -  (char *)data);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//at this point, we no longer reaggregate packets\n\t\tctx->hdr_store_size = 0;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num);\n\t\t\tif (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\t//may happen that after all our checks, only 4 bytes are left, continue to store these 4 bytes\n\t\tif (remain<5)\n\t\t\tcontinue;\n\n\t\t//good to go\n\t\tgf_m4v_parser_reset(ctx->vparser, sc_type_forced ? forced_sc_type + 1 : 0);\n\t\tsize = 0;\n\t\te = gf_m4v_parse_frame(ctx->vparser, &ctx->dsi, &ftype, &tinc, &size, &fstart, &is_coded);\n\n\t\t//only for m1v/m2v, for m4v we may have fstart>0 when we strip VO and VISOBJ\n\t\tif (ctx->is_mpg12 && fstart && (fstart<remain)) {\n\t\t\t//start code (4 bytes) in header, adjst frame start and size\n\t\t\tif (sc_type_forced) {\n\t\t\t\tfstart += 4;\n\t\t\t\tsize-=4;\n\t\t\t}\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) fstart, &pck_data);\n\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\tmemcpy(pck_data, start, (size_t) fstart);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\tbyte_offset+=fstart;\n\t\t\t}\n\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\n\t\t\tstart += fstart;\n\t\t\tremain -= (s32) fstart;\n\t\t}\n\t\t//we may have VO or other packets before (fstart is on first of vop/gov/vol/vos)\n\t\telse if (fstart && (fstart + size <= remain)) {\n\t\t\t//start code (4 bytes) in header, adjst frame start and size\n\t\t\tif (sc_type_forced) {\n\t\t\t\tfstart += 4;\n\t\t\t\tsize-=4;\n\t\t\t}\n\t\t\tsize += fstart;\n\t\t}\n\n\t\t//we skipped bytes already in store + end of start code present in packet, so the size of the first object\n\t\t//needs adjustement\n\t\tif (bytes_from_store) {\n\t\t\tsize += bytes_from_store + hdr_offset;\n\t\t\tif (size > remain) {\n\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] packet too large to process (size %llu remain %d)\\n\", size, remain ));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ((e == GF_EOS) && !ctx->input_is_au_end) {\n\t\t\tu8 b3 = start[remain-3];\n\t\t\tu8 b2 = start[remain-2];\n\t\t\tu8 b1 = start[remain-1];\n\n\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\tassert(size >= 3);\n\t\t\t\tsize -= 3;\n\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t}\n\t\t\tfull_frame = GF_FALSE;\n\t\t} else {\n\t\t\tfull_frame = GF_TRUE;\n\t\t}\n\n\t\tif (ftype) {\n\t\t\tif (!is_coded) {\n\t\t\t\t/*if prev is B and we're parsing a packed bitstream discard n-vop*/\n\t\t\t\tif ((ctx->forced_packed && ctx->b_frames)\n\t\t\t\t\t/*policy is to import at variable frame rate, skip*/\n\t\t\t\t\t|| ctx->vfr\n\t\t\t\t) {\n\t\t\t\t\tif (ctx->vfr) {\n\t\t\t\t\t\tctx->is_vfr = GF_TRUE;\n\t\t\t\t\t\tmpgviddmx_update_time(ctx);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx->is_packed = GF_TRUE;\n\t\t\t\t\t}\n\n\t\t\t\t\t//part of the frame was in store, adjust size\n\t\t\t\t\tif (bytes_from_store)\n\t\t\t\t\t\tsize-= bytes_from_store + hdr_offset;\n\n\t\t\t\t\tassert(remain>=size);\n\t\t\t\t\tstart += size;\n\t\t\t\t\tremain -= (s32) size;\n\t\t\t\t\t//trash all packets until we align to a new startcode\n\t\t\t\t\tctx->trash_trailer = full_frame ? GF_FALSE : GF_TRUE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*policy is to keep non coded frame (constant frame rate), add*/\n\t\t\t}\n\n\t\t\tif (ftype==3) {\n\t\t\t\t//count number of B-frames since last ref\n\t\t\t\tctx->b_frames++;\n\t\t\t\tctx->nb_b++;\n\t\t\t} else {\n\t\t\t\t//flush all pending packets\n\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);\n\t\t\t\t//remember the CTS of the last ref\n\t\t\t\tctx->last_ref_cts = ctx->cts;\n\t\t\t\tif (ctx->max_b < ctx->b_frames) ctx->max_b = ctx->b_frames;\n\n\t\t\t\tctx->b_frames = 0;\n\t\t\t\tif (ftype==2)\n\t\t\t\t\tctx->nb_p++;\n\t\t\t\telse\n\t\t\t\t\tctx->nb_i++;\n\t\t\t}\n\t\t\tctx->nb_frames++;\n\t\t} else {\n\t\t\tfull_frame = GF_FALSE;\n\t\t}\n\n\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t//bytes come from both our store and the data packet\n\t\tif (bytes_from_store) {\n\t\t\tmemcpy(pck_data, ctx->hdr_store+current, bytes_from_store);\n\t\t\tassert(size >= bytes_from_store);\n\t\t\tsize -= bytes_from_store;\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t}\n\t\t\tmemcpy(pck_data + bytes_from_store, start, (size_t) size);\n\t\t} else {\n\t\t\t//bytes only come the data packet\n\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data);\n\t\t\t}\n\t\t}\n\n\t\tif (ftype) {\n\t\t\tassert(pck_data[0] == 0);\n\t\t\tassert(pck_data[1] == 0);\n\t\t\tassert(pck_data[2] == 1);\n\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE);\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_dts(dst_pck, ctx->dts);\n\n\t\t\tif (ctx->input_is_au_start) {\n\t\t\t\tctx->input_is_au_start = GF_FALSE;\n\t\t\t} else {\n\t\t\t\t//we use the carousel flag temporarly to indicate the cts must be recomputed\n\t\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\t\t\t}\n\t\t\tgf_filter_pck_set_sap(dst_pck, (ftype==1) ? GF_FILTER_SAP_1 : GF_FILTER_SAP_NONE);\n\t\t\tif (ctx->cur_fps.den > 0) gf_filter_pck_set_duration(dst_pck, ctx->cur_fps.den);\n\t\t\tif (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);\n\t\t\tctx->frame_started = GF_TRUE;\n\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\n\t\t\tmpgviddmx_update_time(ctx);\n\t\t} else {\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE);\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t}\n\n\t\tif (!full_frame) {\n\t\t\tif (copy_last_bytes) {\n\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tassert(remain>=size);\n\t\tstart += size;\n\t\tremain -= (s32) size;\n\t}\n\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\treturn GF_OK;\n}\n\nstatic GF_Err mpgviddmx_initialize(GF_Filter *filter)\n{\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\tctx->hdr_store_size = 0;\n\tctx->hdr_store_alloc = MIN_HDR_STORE;\n\tctx->hdr_store = gf_malloc(sizeof(char)*ctx->hdr_store_alloc);\n\treturn GF_OK;\n}\n\nstatic void mpgviddmx_finalize(GF_Filter *filter)\n{\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->bs) gf_bs_del(ctx->bs);\n\tif (ctx->vparser) gf_m4v_parser_del_no_bs(ctx->vparser);\n\tif (ctx->indexes) gf_free(ctx->indexes);\n\tif (ctx->hdr_store) gf_free(ctx->hdr_store);\n\tif (ctx->pck_queue) {\n\t\twhile (gf_list_count(ctx->pck_queue)) {\n\t\t\tGF_FilterPacket *pck = gf_list_pop_back(ctx->pck_queue);\n\t\t\tgf_filter_pck_discard(pck);\n\t\t}\n\t\tgf_list_del(ctx->pck_queue);\n\t}\n\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\tif (ctx->importer) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s Import results: %d VOPs (%d Is - %d Ps - %d Bs)\\n\", ctx->is_mpg12 ? \"MPEG-1/2\" : \"MPEG-4 (Part 2)\", ctx->nb_frames, ctx->nb_i, ctx->nb_p, ctx->nb_b));\n\t\tif (ctx->nb_b) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"\\t%d max consecutive B-frames%s\\n\", ctx->max_b, ctx->is_packed ? \" - packed bitstream\" : \"\" ));\n\t\t}\n\t\tif (ctx->is_vfr && ctx->nb_b && ctx->is_packed) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"Warning: Mix of non-coded frames: packed bitstream and encoder skipped - unpredictable timing\\n\"));\n\t\t}\n\t}\n}\n\nu32 gf_m4v_parser_get_obj_type(GF_M4VParser *m4v);\n\nstatic const char * mpgvdmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\tGF_M4VParser *parser;\n\tu8 ftype;\n\tu32 tinc, nb_frames, o_start=0;\n\tu64 fsize, start;\n\tBool is_coded;\n\tGF_Err e;\n\tGF_M4VDecSpecInfo dsi;\n\n\tmemset(&dsi, 0, sizeof(GF_M4VDecSpecInfo));\n\tparser = gf_m4v_parser_new((char*)data, size, GF_FALSE);\n\tnb_frames = 0;\n\twhile (1) {\n\t\tu32 otype;\n\t\tftype = 0;\n\t\tis_coded = GF_FALSE;\n\t\te = gf_m4v_parse_frame(parser, &dsi, &ftype, &tinc, &fsize, &start, &is_coded);\n\t\tif (!nb_frames && start) o_start = (u32) start;\n\n\t\totype = gf_m4v_parser_get_obj_type(parser);\n\t\tswitch (otype) {\n\t\tcase M4V_VOL_START_CODE:\n\t\tcase M4V_VOP_START_CODE:\n\t\tcase M4V_VISOBJ_START_CODE:\n\t\tcase M4V_VOS_START_CODE:\n\t\tcase M4V_GOV_START_CODE:\n\t\tcase M4V_UDTA_START_CODE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\totype = 0;\n\t\t}\n\n\t\t//if start is more than 4 (start-code size), we have garbage at the beginning, do not parse\n\t\t//except if we have a valid object VOS\n\t\tif (!nb_frames && (start>4) && !otype) {\n\t\t\tbreak;\n\t\t}\n\t\tif (is_coded) nb_frames++;\n\t\tif (e==GF_EOS) {\n\t\t\te = GF_OK;\n\t\t\t//special case if the only frame we have is not coded\n\t\t\tif (otype == M4V_VOP_START_CODE) {\n\t\t\t\tif (!nb_frames) nb_frames++;\n\t\t\t\tis_coded = 1;\n\t\t\t}\n\n\t\t\tif (is_coded) nb_frames++;\n\t\t\tbreak;\n\t\t}\n\t\tif (ftype>2) break;\n\t\tif (e) break;\n\t\tnb_frames++;\n\t}\n\tgf_m4v_parser_del(parser);\n\tif ((e==GF_OK) && (nb_frames>1)) {\n\t\t*score = o_start ? GF_FPROBE_MAYBE_NOT_SUPPORTED : GF_FPROBE_MAYBE_SUPPORTED;\n\t\treturn \"video/mp4v-es\";\n\t}\n\n\tmemset(&dsi, 0, sizeof(GF_M4VDecSpecInfo));\n\tparser = gf_m4v_parser_new((char*)data, size, GF_TRUE);\n\tnb_frames = 0;\n\twhile (1) {\n\t\tftype = 0;\n\t\tis_coded = GF_FALSE;\n\t\te = gf_m4v_parse_frame(parser, &dsi, &ftype, &tinc, &fsize, &start, &is_coded);\n\n\t\t//if start is more than 4 (start-code size), we have garbage at the beginning, do not parse\n\t\tif (!nb_frames && (start>4) ) {\n\t\t\tbreak;\n\t\t}\n\t\tif (is_coded) nb_frames++;\n\t\tif (e==GF_EOS) {\n\t\t\tif (is_coded) nb_frames++;\n\t\t\te = GF_OK;\n\t\t\tbreak;\n\t\t}\n\t\tif (ftype>2) break;\n\t\tif (e) break;\n\t\tnb_frames++;\n\t}\n\tgf_m4v_parser_del(parser);\n\tif ((e==GF_OK) && (nb_frames>1)) {\n\t\t*score = o_start ? GF_FPROBE_MAYBE_NOT_SUPPORTED : GF_FPROBE_MAYBE_SUPPORTED;\n\t\treturn \"video/mpgv-es\";\n\t}\n\treturn NULL;\n}\n\nstatic const GF_FilterCapability MPGVidDmxCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"cmp|m1v|m2v|m4v\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"video/mp4v-es|video/mpgv-es\"),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG4_PART2),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG1),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SIMPLE),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SPATIAL),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SNR),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_MAIN),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_HIGH),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_422),\n\tCAP_BOOL(GF_CAPS_OUTPUT_STATIC_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG4_PART2),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG1),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SPATIAL),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SNR),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_SIMPLE),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_MAIN),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_HIGH),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_422),\n\tCAP_BOOL(GF_CAPS_INPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n};\n\n\n#define OFFS(_n)\t#_n, offsetof(GF_MPGVidDmxCtx, _n)\nstatic const GF_FilterArgs MPGVidDmxArgs[] =\n{\n\t{ OFFS(fps), \"import frame rate (0 default to FPS from bitstream or 25 Hz)\", GF_PROP_FRACTION, \"0/1000\", NULL, 0},\n\t{ OFFS(index), \"indexing window length. If 0, bitstream is not probed for duration. A negative value skips the indexing if the source file is larger than 20M (slows down importers) unless a play with start range > 0 is issued\", GF_PROP_DOUBLE, \"-1.0\", NULL, 0},\n\t{ OFFS(vfr), \"set variable frame rate import\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(importer), \"compatibility with old importer, displays import results\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(notime), \"ignore input timestamps, rebuild from 0\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{0}\n};\n\n\nGF_FilterRegister MPGVidDmxRegister = {\n\t.name = \"rfmpgvid\",\n\tGF_FS_SET_DESCRIPTION(\"M1V/M2V/M4V reframer\")\n\tGF_FS_SET_HELP(\"This filter parses MPEG-1/2 and MPEG-4 part 2 video files/data and outputs corresponding video PID and frames.\\n\"\n\t\t\"Note: The filter uses negative CTS offsets: CTS is correct, but some frames may have DTS greater than CTS.\")\n\t.private_size = sizeof(GF_MPGVidDmxCtx),\n\t.args = MPGVidDmxArgs,\n\t.initialize = mpgviddmx_initialize,\n\t.finalize = mpgviddmx_finalize,\n\tSETCAPS(MPGVidDmxCaps),\n\t.configure_pid = mpgviddmx_configure_pid,\n\t.process = mpgviddmx_process,\n\t.probe_data = mpgvdmx_probe_data,\n\t.process_event = mpgviddmx_process_event\n};\n\n\nconst GF_FilterRegister *rfmpgvid_register(GF_FilterSession *session)\n{\n\treturn &MPGVidDmxRegister;\n}\n#else\nconst GF_FilterRegister *rfmpgvid_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif // #if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_RFMPGVID)\n"], "filenames": ["src/filters/reframe_mpgvid.c"], "buggy_code_start_loc": [1083], "buggy_code_end_loc": [1083], "fixing_code_start_loc": [1084], "fixing_code_end_loc": [1089], "type": "CWE-125", "message": "Out-of-bounds Read in GitHub repository gpac/gpac prior to 2.3.0-DEV.", "other": {"cve": {"id": "CVE-2023-5998", "sourceIdentifier": "security@huntr.dev", "published": "2023-11-07T19:15:12.737", "lastModified": "2023-11-15T15:41:50.257", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Out-of-bounds Read in GitHub repository gpac/gpac prior to 2.3.0-DEV."}, {"lang": "es", "value": "Lectura fuera de los l\u00edmites en el repositorio de GitHub gpac/gpac anterior a 2.3.0-DEV."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 1.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.3.0", "matchCriteriaId": "8427BDFE-346D-45C9-B0BD-1F06E8825368"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/db74835944548fc3bdf03121b0e012373bdebb3e", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.com/bounties/ea02a231-b688-422b-a881-ef415bcf6113", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/db74835944548fc3bdf03121b0e012373bdebb3e"}}