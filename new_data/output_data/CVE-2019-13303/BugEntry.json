{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%        CCCC   OOO   M   M  PPPP    OOO   SSSSS  IIIII  TTTTT  EEEEE         %\n%       C      O   O  MM MM  P   P  O   O  SS       I      T    E             %\n%       C      O   O  M M M  PPPP   O   O   SSS     I      T    EEE           %\n%       C      O   O  M   M  P      O   O     SS    I      T    E             %\n%        CCCC   OOO   M   M  P       OOO   SSSSS  IIIII    T    EEEEE         %\n%                                                                             %\n%                                                                             %\n%                     MagickCore Image Composite Methods                      %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/fx.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/resample.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/threshold.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#include \"MagickCore/version.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C o m p o s i t e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CompositeImage() returns the second image composited onto the first\n%  at the specified offset, using the specified composite method.\n%\n%  The format of the CompositeImage method is:\n%\n%      MagickBooleanType CompositeImage(Image *image,\n%        const Image *source_image,const CompositeOperator compose,\n%        const MagickBooleanType clip_to_self,const ssize_t x_offset,\n%        const ssize_t y_offset,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the canvas image, modified by he composition\n%\n%    o source_image: the source image.\n%\n%    o compose: This operator affects how the composite is applied to\n%      the image.  The operators and how they are utilized are listed here\n%      http://www.w3.org/TR/SVG12/#compositing.\n%\n%    o clip_to_self: set to MagickTrue to limit composition to area composed.\n%\n%    o x_offset: the column offset of the composited image.\n%\n%    o y_offset: the row offset of the composited image.\n%\n%  Extra Controls from Image meta-data in 'image' (artifacts)\n%\n%    o \"compose:args\"\n%        A string containing extra numerical arguments for specific compose\n%        methods, generally expressed as a 'geometry' or a comma separated list\n%        of numbers.\n%\n%        Compose methods needing such arguments include \"BlendCompositeOp\" and\n%        \"DisplaceCompositeOp\".\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n/*\n   Composition based on the SVG specification:\n\n   A Composition is defined by...\n      Color Function :  f(Sc,Dc)  where Sc and Dc are the normizalized colors\n      Blending areas :  X = 1     for area of overlap, ie: f(Sc,Dc)\n                        Y = 1     for source preserved\n                        Z = 1     for canvas preserved\n\n   Conversion to transparency (then optimized)\n      Dca' = f(Sc, Dc)*Sa*Da + Y*Sca*(1-Da) + Z*Dca*(1-Sa)\n      Da'  = X*Sa*Da + Y*Sa*(1-Da) + Z*Da*(1-Sa)\n\n   Where...\n      Sca = Sc*Sa     normalized Source color divided by Source alpha\n      Dca = Dc*Da     normalized Dest color divided by Dest alpha\n      Dc' = Dca'/Da'  the desired color value for this channel.\n\n   Da' in in the follow formula as 'gamma'  The resulting alpla value.\n\n   Most functions use a blending mode of over (X=1,Y=1,Z=1) this results in\n   the following optimizations...\n      gamma = Sa+Da-Sa*Da;\n      gamma = 1 - QuantumScale*alpha * QuantumScale*beta;\n      opacity = QuantumScale*alpha*beta;  // over blend, optimized 1-Gamma\n\n   The above SVG definitions also define that Mathematical Composition\n   methods should use a 'Over' blending mode for Alpha Channel.\n   It however was not applied for composition modes of 'Plus', 'Minus',\n   the modulus versions of 'Add' and 'Subtract'.\n\n   Mathematical operator changes to be applied from IM v6.7...\n\n    1) Modulus modes 'Add' and 'Subtract' are obsoleted and renamed\n       'ModulusAdd' and 'ModulusSubtract' for clarity.\n\n    2) All mathematical compositions work as per the SVG specification\n       with regard to blending.  This now includes 'ModulusAdd' and\n       'ModulusSubtract'.\n\n    3) When the special channel flag 'sync' (syncronize channel updates)\n       is turned off (enabled by default) then mathematical compositions are\n       only performed on the channels specified, and are applied\n       independantally of each other.  In other words the mathematics is\n       performed as 'pure' mathematical operations, rather than as image\n       operations.\n*/\n\nstatic void HCLComposite(const MagickRealType hue,const MagickRealType chroma,\n  const MagickRealType luma,MagickRealType *red,MagickRealType *green,\n  MagickRealType *blue)\n{\n  MagickRealType\n    b,\n    c,\n    g,\n    h,\n    m,\n    r,\n    x;\n\n  /*\n    Convert HCL to RGB colorspace.\n  */\n  assert(red != (MagickRealType *) NULL);\n  assert(green != (MagickRealType *) NULL);\n  assert(blue != (MagickRealType *) NULL);\n  h=6.0*hue;\n  c=chroma;\n  x=c*(1.0-fabs(fmod(h,2.0)-1.0));\n  r=0.0;\n  g=0.0;\n  b=0.0;\n  if ((0.0 <= h) && (h < 1.0))\n    {\n      r=c;\n      g=x;\n    }\n  else\n    if ((1.0 <= h) && (h < 2.0))\n      {\n        r=x;\n        g=c;\n      }\n    else\n      if ((2.0 <= h) && (h < 3.0))\n        {\n          g=c;\n          b=x;\n        }\n      else\n        if ((3.0 <= h) && (h < 4.0))\n          {\n            g=x;\n            b=c;\n          }\n        else\n          if ((4.0 <= h) && (h < 5.0))\n            {\n              r=x;\n              b=c;\n            }\n          else\n            if ((5.0 <= h) && (h < 6.0))\n              {\n                r=c;\n                b=x;\n              }\n  m=luma-(0.298839*r+0.586811*g+0.114350*b);\n  *red=QuantumRange*(r+m);\n  *green=QuantumRange*(g+m);\n  *blue=QuantumRange*(b+m);\n}\n\nstatic void CompositeHCL(const MagickRealType red,const MagickRealType green,\n  const MagickRealType blue,MagickRealType *hue,MagickRealType *chroma,\n  MagickRealType *luma)\n{\n  MagickRealType\n    b,\n    c,\n    g,\n    h,\n    max,\n    r;\n\n  /*\n    Convert RGB to HCL colorspace.\n  */\n  assert(hue != (MagickRealType *) NULL);\n  assert(chroma != (MagickRealType *) NULL);\n  assert(luma != (MagickRealType *) NULL);\n  r=red;\n  g=green;\n  b=blue;\n  max=MagickMax(r,MagickMax(g,b));\n  c=max-(MagickRealType) MagickMin(r,MagickMin(g,b));\n  h=0.0;\n  if (c == 0)\n    h=0.0;\n  else\n    if (red == max)\n      h=fmod((g-b)/c+6.0,6.0);\n    else\n      if (green == max)\n        h=((b-r)/c)+2.0;\n      else\n        if (blue == max)\n          h=((r-g)/c)+4.0;\n  *hue=(h/6.0);\n  *chroma=QuantumScale*c;\n  *luma=QuantumScale*(0.298839*r+0.586811*g+0.114350*b);\n}\n\nstatic MagickBooleanType CompositeOverImage(Image *image,\n  const Image *source_image,const MagickBooleanType clip_to_self,\n  const ssize_t x_offset,const ssize_t y_offset,ExceptionInfo *exception)\n{\n#define CompositeImageTag  \"Composite/Image\"\n\n  CacheView\n    *image_view,\n    *source_view;\n\n  const char\n    *value;\n\n  MagickBooleanType\n    clamp,\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  /*\n    Composite image.\n  */\n  status=MagickTrue;\n  progress=0;\n  clamp=MagickTrue;\n  value=GetImageArtifact(image,\"compose:clamp\");\n  if (value != (const char *) NULL)\n    clamp=IsStringTrue(value);\n  status=MagickTrue;\n  progress=0;\n  source_view=AcquireVirtualCacheView(source_image,exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(source_image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const Quantum\n      *pixels;\n\n    PixelInfo\n      canvas_pixel,\n      source_pixel;\n\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    if (clip_to_self != MagickFalse)\n      {\n        if (y < y_offset)\n          continue;\n        if ((y-y_offset) >= (ssize_t) source_image->rows)\n          continue;\n      }\n    /*\n      If pixels is NULL, y is outside overlay region.\n    */\n    pixels=(Quantum *) NULL;\n    p=(Quantum *) NULL;\n    if ((y >= y_offset) && ((y-y_offset) < (ssize_t) source_image->rows))\n      {\n        p=GetCacheViewVirtualPixels(source_view,0,y-y_offset,\n          source_image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        pixels=p;\n        if (x_offset < 0)\n          p-=x_offset*GetPixelChannels(source_image);\n      }\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    GetPixelInfo(image,&canvas_pixel);\n    GetPixelInfo(source_image,&source_pixel);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      MagickRealType\n        alpha,\n        Da,\n        Dc,\n        Dca,\n        Sa,\n        Sc,\n        Sca;\n\n      register ssize_t\n        i;\n\n      size_t\n        channels;\n\n      if (clip_to_self != MagickFalse)\n        {\n          if (x < x_offset)\n            {\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          if ((x-x_offset) >= (ssize_t) source_image->columns)\n            break;\n        }\n      if ((pixels == (Quantum *) NULL) || (x < x_offset) ||\n          ((x-x_offset) >= (ssize_t) source_image->columns))\n        {\n          Quantum\n            source[MaxPixelChannels];\n\n          /*\n            Virtual composite:\n              Sc: source color.\n              Dc: canvas color.\n          */\n          (void) GetOneVirtualPixel(source_image,x-x_offset,y-y_offset,source,\n            exception);\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            MagickRealType\n              pixel;\n\n            PixelChannel channel = GetPixelChannelChannel(image,i);\n            PixelTrait traits = GetPixelChannelTraits(image,channel);\n            PixelTrait source_traits=GetPixelChannelTraits(source_image,\n              channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (source_traits == UndefinedPixelTrait))\n              continue;\n            if (channel == AlphaPixelChannel)\n              pixel=(MagickRealType) TransparentAlpha;\n            else\n              pixel=(MagickRealType) q[i];\n            q[i]=clamp != MagickFalse ? ClampPixel(pixel) :\n              ClampToQuantum(pixel);\n          }\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      /*\n        Authentic composite:\n          Sa:  normalized source alpha.\n          Da:  normalized canvas alpha.\n      */\n      Sa=QuantumScale*GetPixelAlpha(source_image,p);\n      Da=QuantumScale*GetPixelAlpha(image,q);\n      alpha=Sa+Da-Sa*Da;\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        MagickRealType\n          pixel;\n\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        PixelTrait source_traits=GetPixelChannelTraits(source_image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if ((source_traits == UndefinedPixelTrait) &&\n            (channel != AlphaPixelChannel))\n            continue;\n        if (channel == AlphaPixelChannel)\n          {\n            /*\n              Set alpha channel.\n            */\n            pixel=QuantumRange*alpha;\n            q[i]=clamp != MagickFalse ? ClampPixel(pixel) :\n              ClampToQuantum(pixel);\n            continue;\n          }\n        /*\n          Sc: source color.\n          Dc: canvas color.\n        */\n        Sc=(MagickRealType) GetPixelChannel(source_image,channel,p);\n        Dc=(MagickRealType) q[i];\n        if ((traits & CopyPixelTrait) != 0)\n          {\n            /*\n              Copy channel.\n            */\n            q[i]=ClampToQuantum(Sc);\n            continue;\n          }\n        /*\n          Porter-Duff compositions:\n            Sca: source normalized color multiplied by alpha.\n            Dca: normalized canvas color multiplied by alpha.\n        */\n        Sca=QuantumScale*Sa*Sc;\n        Dca=QuantumScale*Da*Dc;\n        gamma=PerceptibleReciprocal(alpha);\n        pixel=QuantumRange*gamma*(Sca+Dca*(1.0-Sa));\n        q[i]=clamp != MagickFalse ? ClampPixel(pixel) : ClampToQuantum(pixel);\n      }\n      p+=GetPixelChannels(source_image);\n      channels=GetPixelChannels(source_image);\n      if (p >= (pixels+channels*source_image->columns))\n        p=pixels;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,CompositeImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  source_view=DestroyCacheView(source_view);\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nMagickExport MagickBooleanType CompositeImage(Image *image,\n  const Image *composite,const CompositeOperator compose,\n  const MagickBooleanType clip_to_self,const ssize_t x_offset,\n  const ssize_t y_offset,ExceptionInfo *exception)\n{\n#define CompositeImageTag  \"Composite/Image\"\n\n  CacheView\n    *source_view,\n    *image_view;\n\n  const char\n    *value;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *canvas_image,\n    *source_image;\n\n  MagickBooleanType\n    clamp,\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MagickRealType\n    amount,\n    canvas_dissolve,\n    midpoint,\n    percent_luma,\n    percent_chroma,\n    source_dissolve,\n    threshold;\n\n  MagickStatusType\n    flags;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(composite != (Image *) NULL);\n  assert(composite->signature == MagickCoreSignature);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  source_image=CloneImage(composite,0,0,MagickTrue,exception);\n  if (source_image == (const Image *) NULL)\n    return(MagickFalse);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  (void) SetImageColorspace(source_image,image->colorspace,exception);\n  if ((compose == OverCompositeOp) || (compose == SrcOverCompositeOp))\n    {\n      status=CompositeOverImage(image,source_image,clip_to_self,x_offset,\n        y_offset,exception);\n      source_image=DestroyImage(source_image);\n      return(status);\n    }\n  amount=0.5;\n  canvas_image=(Image *) NULL;\n  canvas_dissolve=1.0;\n  clamp=MagickTrue;\n  value=GetImageArtifact(image,\"compose:clamp\");\n  if (value != (const char *) NULL)\n    clamp=IsStringTrue(value);\n  SetGeometryInfo(&geometry_info);\n  percent_luma=100.0;\n  percent_chroma=100.0;\n  source_dissolve=1.0;\n  threshold=0.05f;\n  switch (compose)\n  {\n    case CopyCompositeOp:\n    {\n      if ((x_offset < 0) || (y_offset < 0))\n        break;\n      if ((x_offset+(ssize_t) source_image->columns) > (ssize_t) image->columns)\n        break;\n      if ((y_offset+(ssize_t) source_image->rows) > (ssize_t) image->rows)\n        break;\n      status=MagickTrue;\n      source_view=AcquireVirtualCacheView(source_image,exception);\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static) shared(status) \\\n        magick_number_threads(source_image,image,source_image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) source_image->rows; y++)\n      {\n        MagickBooleanType\n          sync;\n\n        register const Quantum\n          *p;\n\n        register Quantum\n          *q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        p=GetCacheViewVirtualPixels(source_view,0,y,source_image->columns,1,\n          exception);\n        q=GetCacheViewAuthenticPixels(image_view,x_offset,y+y_offset,\n          source_image->columns,1,exception);\n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) source_image->columns; x++)\n        {\n          register ssize_t\n            i;\n\n          if (GetPixelReadMask(source_image,p) <= (QuantumRange/2))\n            {\n              p+=GetPixelChannels(source_image);\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel = GetPixelChannelChannel(image,i);\n            PixelTrait traits = GetPixelChannelTraits(image,channel);\n            PixelTrait source_traits=GetPixelChannelTraits(source_image,\n              channel);\n            if (traits == UndefinedPixelTrait)\n              continue;\n            if (source_traits != UndefinedPixelTrait)\n              SetPixelChannel(image,channel,p[i],q);\n            else if (channel == AlphaPixelChannel)\n              SetPixelChannel(image,channel,OpaqueAlpha,q);\n          }\n          p+=GetPixelChannels(source_image);\n          q+=GetPixelChannels(image);\n        }\n        sync=SyncCacheViewAuthenticPixels(image_view,exception);\n        if (sync == MagickFalse)\n          status=MagickFalse;\n        if (image->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n            proceed=SetImageProgress(image,CompositeImageTag,(MagickOffsetType)\n              y,image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n      source_view=DestroyCacheView(source_view);\n      image_view=DestroyCacheView(image_view);\n      source_image=DestroyImage(source_image);\n      return(status);\n    }\n    case IntensityCompositeOp:\n    {\n      if ((x_offset < 0) || (y_offset < 0))\n        break;\n      if ((x_offset+(ssize_t) source_image->columns) > (ssize_t) image->columns)\n        break;\n      if ((y_offset+(ssize_t) source_image->rows) > (ssize_t) image->rows)\n        break;\n      status=MagickTrue;\n      source_view=AcquireVirtualCacheView(source_image,exception);\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static) shared(status) \\\n        magick_number_threads(source_image,image,source_image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) source_image->rows; y++)\n      {\n        MagickBooleanType\n          sync;\n\n        register const Quantum\n          *p;\n\n        register Quantum\n          *q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        p=GetCacheViewVirtualPixels(source_view,0,y,source_image->columns,1,\n          exception);\n        q=GetCacheViewAuthenticPixels(image_view,x_offset,y+y_offset,\n          source_image->columns,1,exception);\n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) source_image->columns; x++)\n        {\n          if (GetPixelReadMask(source_image,p) <= (QuantumRange/2))\n            {\n              p+=GetPixelChannels(source_image);\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          SetPixelAlpha(image,clamp != MagickFalse ?\n            ClampPixel(GetPixelIntensity(source_image,p)) :\n            ClampToQuantum(GetPixelIntensity(source_image,p)),q);\n          p+=GetPixelChannels(source_image);\n          q+=GetPixelChannels(image);\n        }\n        sync=SyncCacheViewAuthenticPixels(image_view,exception);\n        if (sync == MagickFalse)\n          status=MagickFalse;\n        if (image->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n            proceed=SetImageProgress(image,CompositeImageTag,(MagickOffsetType)\n              y,image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n      source_view=DestroyCacheView(source_view);\n      image_view=DestroyCacheView(image_view);\n      source_image=DestroyImage(source_image);\n      return(status);\n    }\n    case CopyAlphaCompositeOp:\n    case ChangeMaskCompositeOp:\n    {\n      /*\n        Modify canvas outside the overlaid region and require an alpha\n        channel to exist, to add transparency.\n      */\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      break;\n    }\n    case BlurCompositeOp:\n    {\n      CacheView\n        *canvas_view;\n\n      MagickRealType\n        angle_range,\n        angle_start,\n        height,\n        width;\n\n      PixelInfo\n        pixel;\n\n      ResampleFilter\n        *resample_filter;\n\n      SegmentInfo\n        blur;\n\n      /*\n        Blur Image by resampling.\n\n        Blur Image dictated by an overlay gradient map: X = red_channel;\n          Y = green_channel; compose:args =  x_scale[,y_scale[,angle]].\n      */\n      canvas_image=CloneImage(image,0,0,MagickTrue,\n        exception);\n      if (canvas_image == (Image *) NULL)\n        {\n          source_image=DestroyImage(source_image);\n          return(MagickFalse);\n        }\n      /*\n        Gather the maximum blur sigma values from user.\n      */\n      flags=NoValue;\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (const char *) NULL)\n        flags=ParseGeometry(value,&geometry_info);\n      if ((flags & WidthValue) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n            \"InvalidSetting\",\"'%s' '%s'\",\"compose:args\",value);\n          source_image=DestroyImage(source_image);\n          canvas_image=DestroyImage(canvas_image);\n          return(MagickFalse);\n        }\n      /*\n        Users input sigma now needs to be converted to the EWA ellipse size.\n        The filter defaults to a sigma of 0.5 so to make this match the\n        users input the ellipse size needs to be doubled.\n      */\n      width=height=geometry_info.rho*2.0;\n      if ((flags & HeightValue) != 0 )\n        height=geometry_info.sigma*2.0;\n      /*\n        Default the unrotated ellipse width and height axis vectors.\n      */\n      blur.x1=width;\n      blur.x2=0.0;\n      blur.y1=0.0;\n      blur.y2=height;\n      /* rotate vectors if a rotation angle is given */\n      if ((flags & XValue) != 0 )\n        {\n          MagickRealType\n            angle;\n\n          angle=DegreesToRadians(geometry_info.xi);\n          blur.x1=width*cos(angle);\n          blur.x2=width*sin(angle);\n          blur.y1=(-height*sin(angle));\n          blur.y2=height*cos(angle);\n        }\n      /* Otherwise lets set a angle range and calculate in the loop */\n      angle_start=0.0;\n      angle_range=0.0;\n      if ((flags & YValue) != 0 )\n        {\n          angle_start=DegreesToRadians(geometry_info.xi);\n          angle_range=DegreesToRadians(geometry_info.psi)-angle_start;\n        }\n      /*\n        Set up a gaussian cylindrical filter for EWA Bluring.\n\n        As the minimum ellipse radius of support*1.0 the EWA algorithm\n        can only produce a minimum blur of 0.5 for Gaussian (support=2.0)\n        This means that even 'No Blur' will be still a little blurry!\n\n        The solution (as well as the problem of preventing any user\n        expert filter settings, is to set our own user settings, then\n        restore them afterwards.\n      */\n      resample_filter=AcquireResampleFilter(image,exception);\n      SetResampleFilter(resample_filter,GaussianFilter);\n\n      /* do the variable blurring of each pixel in image */\n      GetPixelInfo(image,&pixel);\n      source_view=AcquireVirtualCacheView(source_image,exception);\n      canvas_view=AcquireAuthenticCacheView(canvas_image,exception);\n      for (y=0; y < (ssize_t) source_image->rows; y++)\n      {\n        MagickBooleanType\n          sync;\n\n        register const Quantum\n          *magick_restrict p;\n\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (((y+y_offset) < 0) || ((y+y_offset) >= (ssize_t) image->rows))\n          continue;\n        p=GetCacheViewVirtualPixels(source_view,0,y,source_image->columns,1,\n          exception);\n        q=QueueCacheViewAuthenticPixels(canvas_view,0,y,canvas_image->columns,1,\n          exception);\n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n          break;\n        for (x=0; x < (ssize_t) source_image->columns; x++)\n        {\n          if (((x_offset+x) < 0) || ((x_offset+x) >= (ssize_t) image->columns))\n            {\n              p+=GetPixelChannels(source_image);\n              continue;\n            }\n          if (fabs((double) angle_range) > MagickEpsilon)\n            {\n              MagickRealType\n                angle;\n\n              angle=angle_start+angle_range*QuantumScale*\n                GetPixelBlue(source_image,p);\n              blur.x1=width*cos(angle);\n              blur.x2=width*sin(angle);\n              blur.y1=(-height*sin(angle));\n              blur.y2=height*cos(angle);\n            }\n#if 0\n          if ( x == 10 && y == 60 ) {\n            (void) fprintf(stderr, \"blur.x=%lf,%lf, blur.y=%lf,%lf\\n\",blur.x1,\n              blur.x2,blur.y1, blur.y2);\n            (void) fprintf(stderr, \"scaled by=%lf,%lf\\n\",QuantumScale*\n              GetPixelRed(p),QuantumScale*GetPixelGreen(p));\n#endif\n          ScaleResampleFilter(resample_filter,\n            blur.x1*QuantumScale*GetPixelRed(source_image,p),\n            blur.y1*QuantumScale*GetPixelGreen(source_image,p),\n            blur.x2*QuantumScale*GetPixelRed(source_image,p),\n            blur.y2*QuantumScale*GetPixelGreen(source_image,p) );\n          (void) ResamplePixelColor(resample_filter,(double) x_offset+x,\n            (double) y_offset+y,&pixel,exception);\n          SetPixelViaPixelInfo(canvas_image,&pixel,q);\n          p+=GetPixelChannels(source_image);\n          q+=GetPixelChannels(canvas_image);\n        }\n        sync=SyncCacheViewAuthenticPixels(canvas_view,exception);\n        if (sync == MagickFalse)\n          break;\n      }\n      resample_filter=DestroyResampleFilter(resample_filter);\n      source_view=DestroyCacheView(source_view);\n      canvas_view=DestroyCacheView(canvas_view);\n      source_image=DestroyImage(source_image);\n      source_image=canvas_image;\n      break;\n    }\n    case DisplaceCompositeOp:\n    case DistortCompositeOp:\n    {\n      CacheView\n        *canvas_view;\n\n      MagickRealType\n        horizontal_scale,\n        vertical_scale;\n\n      PixelInfo\n        pixel;\n\n      PointInfo\n        center,\n        offset;\n\n      /*\n        Displace/Distort based on overlay gradient map:\n          X = red_channel;  Y = green_channel;\n          compose:args = x_scale[,y_scale[,center.x,center.y]]\n      */\n      canvas_image=CloneImage(image,0,0,MagickTrue,\n        exception);\n      if (canvas_image == (Image *) NULL)\n        {\n          source_image=DestroyImage(source_image);\n          return(MagickFalse);\n        }\n      SetGeometryInfo(&geometry_info);\n      flags=NoValue;\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        flags=ParseGeometry(value,&geometry_info);\n      if ((flags & (WidthValue | HeightValue)) == 0 )\n        {\n          if ((flags & AspectValue) == 0)\n            {\n              horizontal_scale=(MagickRealType) (source_image->columns-1)/2.0;\n              vertical_scale=(MagickRealType) (source_image->rows-1)/2.0;\n            }\n          else\n            {\n              horizontal_scale=(MagickRealType) (image->columns-1)/2.0;\n              vertical_scale=(MagickRealType) (image->rows-1)/2.0;\n            }\n        }\n      else\n        {\n          horizontal_scale=geometry_info.rho;\n          vertical_scale=geometry_info.sigma;\n          if ((flags & PercentValue) != 0)\n            {\n              if ((flags & AspectValue) == 0)\n                {\n                  horizontal_scale*=(source_image->columns-1)/200.0;\n                  vertical_scale*=(source_image->rows-1)/200.0;\n                }\n              else\n                {\n                  horizontal_scale*=(image->columns-1)/200.0;\n                  vertical_scale*=(image->rows-1)/200.0;\n                }\n            }\n          if ((flags & HeightValue) == 0)\n            vertical_scale=horizontal_scale;\n        }\n      /*\n        Determine fixed center point for absolute distortion map\n         Absolute distort ==\n           Displace offset relative to a fixed absolute point\n           Select that point according to +X+Y user inputs.\n           default = center of overlay image\n           arg flag '!' = locations/percentage relative to background image\n      */\n      center.x=(MagickRealType) x_offset;\n      center.y=(MagickRealType) y_offset;\n      if (compose == DistortCompositeOp)\n        {\n          if ((flags & XValue) == 0)\n            if ((flags & AspectValue) != 0)\n              center.x=(MagickRealType) ((image->columns-1)/2.0);\n            else\n              center.x=(MagickRealType) (x_offset+(source_image->columns-1)/\n                2.0);\n          else\n            if ((flags & AspectValue) != 0)\n              center.x=geometry_info.xi;\n            else\n              center.x=(MagickRealType) (x_offset+geometry_info.xi);\n          if ((flags & YValue) == 0)\n            if ((flags & AspectValue) != 0)\n              center.y=(MagickRealType) ((image->rows-1)/2.0);\n            else\n              center.y=(MagickRealType) (y_offset+(source_image->rows-1)/2.0);\n          else\n            if ((flags & AspectValue) != 0)\n              center.y=geometry_info.psi;\n            else\n              center.y=(MagickRealType) (y_offset+geometry_info.psi);\n        }\n      /*\n        Shift the pixel offset point as defined by the provided,\n        displacement/distortion map.  -- Like a lens...\n      */\n      GetPixelInfo(image,&pixel);\n      image_view=AcquireVirtualCacheView(image,exception);\n      source_view=AcquireVirtualCacheView(source_image,exception);\n      canvas_view=AcquireAuthenticCacheView(canvas_image,exception);\n      for (y=0; y < (ssize_t) source_image->rows; y++)\n      {\n        MagickBooleanType\n          sync;\n\n        register const Quantum\n          *magick_restrict p;\n\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (((y+y_offset) < 0) || ((y+y_offset) >= (ssize_t) image->rows))\n          continue;\n        p=GetCacheViewVirtualPixels(source_view,0,y,source_image->columns,1,\n          exception);\n        q=QueueCacheViewAuthenticPixels(canvas_view,0,y,canvas_image->columns,1,\n          exception);\n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n          break;\n        for (x=0; x < (ssize_t) source_image->columns; x++)\n        {\n          if (((x_offset+x) < 0) || ((x_offset+x) >= (ssize_t) image->columns))\n            {\n              p+=GetPixelChannels(source_image);\n              continue;\n            }\n          /*\n            Displace the offset.\n          */\n          offset.x=(double) (horizontal_scale*(GetPixelRed(source_image,p)-\n            (((MagickRealType) QuantumRange+1.0)/2.0)))/(((MagickRealType)\n            QuantumRange+1.0)/2.0)+center.x+((compose == DisplaceCompositeOp) ?\n            x : 0);\n          offset.y=(double) (vertical_scale*(GetPixelGreen(source_image,p)-\n            (((MagickRealType) QuantumRange+1.0)/2.0)))/(((MagickRealType)\n            QuantumRange+1.0)/2.0)+center.y+((compose == DisplaceCompositeOp) ?\n            y : 0);\n          status=InterpolatePixelInfo(image,image_view,\n            UndefinedInterpolatePixel,(double) offset.x,(double) offset.y,\n            &pixel,exception);\n          if (status == MagickFalse)\n            break;\n          /*\n            Mask with the 'invalid pixel mask' in alpha channel.\n          */\n          pixel.alpha=(MagickRealType) QuantumRange*(QuantumScale*pixel.alpha)*\n            (QuantumScale*GetPixelAlpha(source_image,p));\n          SetPixelViaPixelInfo(canvas_image,&pixel,q);\n          p+=GetPixelChannels(source_image);\n          q+=GetPixelChannels(canvas_image);\n        }\n        if (x < (ssize_t) source_image->columns)\n          break;\n        sync=SyncCacheViewAuthenticPixels(canvas_view,exception);\n        if (sync == MagickFalse)\n          break;\n      }\n      canvas_view=DestroyCacheView(canvas_view);\n      source_view=DestroyCacheView(source_view);\n      image_view=DestroyCacheView(image_view);\n      source_image=DestroyImage(source_image);\n      source_image=canvas_image;\n      break;\n    }\n    case DissolveCompositeOp:\n    {\n      /*\n        Geometry arguments to dissolve factors.\n      */\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        {\n          flags=ParseGeometry(value,&geometry_info);\n          source_dissolve=geometry_info.rho/100.0;\n          canvas_dissolve=1.0;\n          if ((source_dissolve-MagickEpsilon) < 0.0)\n            source_dissolve=0.0;\n          if ((source_dissolve+MagickEpsilon) > 1.0)\n            {\n              canvas_dissolve=2.0-source_dissolve;\n              source_dissolve=1.0;\n            }\n          if ((flags & SigmaValue) != 0)\n            canvas_dissolve=geometry_info.sigma/100.0;\n          if ((canvas_dissolve-MagickEpsilon) < 0.0)\n            canvas_dissolve=0.0;\n        }\n      break;\n    }\n    case BlendCompositeOp:\n    {\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        {\n          flags=ParseGeometry(value,&geometry_info);\n          source_dissolve=geometry_info.rho/100.0;\n          canvas_dissolve=1.0-source_dissolve;\n          if ((flags & SigmaValue) != 0)\n            canvas_dissolve=geometry_info.sigma/100.0;\n        }\n      break;\n    }\n    case MathematicsCompositeOp:\n    {\n      /*\n        Just collect the values from \"compose:args\", setting.\n        Unused values are set to zero automagically.\n\n        Arguments are normally a comma separated list, so this probably should\n        be changed to some 'general comma list' parser, (with a minimum\n        number of values)\n      */\n      SetGeometryInfo(&geometry_info);\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        (void) ParseGeometry(value,&geometry_info);\n      break;\n    }\n    case ModulateCompositeOp:\n    {\n      /*\n        Determine the luma and chroma scale.\n      */\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        {\n          flags=ParseGeometry(value,&geometry_info);\n          percent_luma=geometry_info.rho;\n          if ((flags & SigmaValue) != 0)\n            percent_chroma=geometry_info.sigma;\n        }\n      break;\n    }\n    case ThresholdCompositeOp:\n    {\n      /*\n        Determine the amount and threshold.\n      */\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        {\n          flags=ParseGeometry(value,&geometry_info);\n          amount=geometry_info.rho;\n          threshold=geometry_info.sigma;\n          if ((flags & SigmaValue) == 0)\n            threshold=0.05f;\n        }\n      threshold*=QuantumRange;\n      break;\n    }\n    default:\n      break;\n  }\n  /*\n    Composite image.\n  */\n  status=MagickTrue;\n  progress=0;\n  midpoint=((MagickRealType) QuantumRange+1.0)/2;\n  source_view=AcquireVirtualCacheView(source_image,exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(source_image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const Quantum\n      *pixels;\n\n    MagickRealType\n      blue,\n      chroma,\n      green,\n      hue,\n      luma,\n      red;\n\n    PixelInfo\n      canvas_pixel,\n      source_pixel;\n\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    if (clip_to_self != MagickFalse)\n      {\n        if (y < y_offset)\n          continue;\n        if ((y-y_offset) >= (ssize_t) source_image->rows)\n          continue;\n      }\n    /*\n      If pixels is NULL, y is outside overlay region.\n    */\n    pixels=(Quantum *) NULL;\n    p=(Quantum *) NULL;\n    if ((y >= y_offset) && ((y-y_offset) < (ssize_t) source_image->rows))\n      {\n        p=GetCacheViewVirtualPixels(source_view,0,y-y_offset,\n          source_image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        pixels=p;\n        if (x_offset < 0)\n          p-=x_offset*GetPixelChannels(source_image);\n      }\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    hue=0.0;\n    chroma=0.0;\n    luma=0.0;\n    GetPixelInfo(image,&canvas_pixel);\n    GetPixelInfo(source_image,&source_pixel);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      MagickRealType\n        alpha,\n        Da,\n        Dc,\n        Dca,\n        DcaDa,\n        Sa,\n        SaSca,\n        Sc,\n        Sca;\n\n      register ssize_t\n        i;\n\n      size_t\n        channels;\n\n      if (clip_to_self != MagickFalse)\n        {\n          if (x < x_offset)\n            {\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          if ((x-x_offset) >= (ssize_t) source_image->columns)\n            break;\n        }\n      if ((pixels == (Quantum *) NULL) || (x < x_offset) ||\n          ((x-x_offset) >= (ssize_t) source_image->columns))\n        {\n          Quantum\n            source[MaxPixelChannels];\n\n          /*\n            Virtual composite:\n              Sc: source color.\n              Dc: canvas color.\n          */\n          (void) GetOneVirtualPixel(source_image,x-x_offset,y-y_offset,source,\n            exception);\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            MagickRealType\n              pixel;\n\n            PixelChannel channel = GetPixelChannelChannel(image,i);\n            PixelTrait traits = GetPixelChannelTraits(image,channel);\n            PixelTrait source_traits=GetPixelChannelTraits(source_image,\n              channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (source_traits == UndefinedPixelTrait))\n              continue;\n            switch (compose)\n            {\n              case AlphaCompositeOp:\n              case ChangeMaskCompositeOp:\n              case CopyAlphaCompositeOp:\n              case DstAtopCompositeOp:\n              case DstInCompositeOp:\n              case InCompositeOp:\n              case OutCompositeOp:\n              case SrcInCompositeOp:\n              case SrcOutCompositeOp:\n              {\n                if (channel == AlphaPixelChannel)\n                  pixel=(MagickRealType) TransparentAlpha;\n                else\n                  pixel=(MagickRealType) q[i];\n                break;\n              }\n              case ClearCompositeOp:\n              case CopyCompositeOp:\n              case ReplaceCompositeOp:\n              case SrcCompositeOp:\n              {\n                if (channel == AlphaPixelChannel)\n                  pixel=(MagickRealType) TransparentAlpha;\n                else\n                  pixel=0.0;\n                break;\n              }\n              case BlendCompositeOp:\n              case DissolveCompositeOp:\n              {\n                if (channel == AlphaPixelChannel)\n                  pixel=canvas_dissolve*GetPixelAlpha(source_image,source);\n                else\n                  pixel=(MagickRealType) source[channel];\n                break;\n              }\n              default:\n              {\n                pixel=(MagickRealType) source[channel];\n                break;\n              }\n            }\n            q[i]=clamp != MagickFalse ? ClampPixel(pixel) :\n              ClampToQuantum(pixel);\n          }\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      /*\n        Authentic composite:\n          Sa:  normalized source alpha.\n          Da:  normalized canvas alpha.\n      */\n      Sa=QuantumScale*GetPixelAlpha(source_image,p);\n      Da=QuantumScale*GetPixelAlpha(image,q);\n      switch (compose)\n      {\n        case BumpmapCompositeOp:\n        {\n          alpha=GetPixelIntensity(source_image,p)*Sa;\n          break;\n        }\n        case ColorBurnCompositeOp:\n        case ColorDodgeCompositeOp:\n        case DarkenCompositeOp:\n        case DifferenceCompositeOp:\n        case DivideDstCompositeOp:\n        case DivideSrcCompositeOp:\n        case ExclusionCompositeOp:\n        case HardLightCompositeOp:\n        case HardMixCompositeOp:\n        case LinearBurnCompositeOp:\n        case LinearDodgeCompositeOp:\n        case LinearLightCompositeOp:\n        case LightenCompositeOp:\n        case MathematicsCompositeOp:\n        case MinusDstCompositeOp:\n        case MinusSrcCompositeOp:\n        case ModulusAddCompositeOp:\n        case ModulusSubtractCompositeOp:\n        case MultiplyCompositeOp:\n        case OverlayCompositeOp:\n        case PegtopLightCompositeOp:\n        case PinLightCompositeOp:\n        case ScreenCompositeOp:\n        case SoftLightCompositeOp:\n        case VividLightCompositeOp:\n        {\n          alpha=RoundToUnity(Sa+Da-Sa*Da);\n          break;\n        }\n        case DstAtopCompositeOp:\n        case DstInCompositeOp:\n        case InCompositeOp:\n        case SrcInCompositeOp:\n        {\n          alpha=Sa*Da;\n          break;\n        }\n        case DissolveCompositeOp:\n        {\n          alpha=source_dissolve*Sa*(-canvas_dissolve*Da)+source_dissolve*Sa+\n            canvas_dissolve*Da;\n          break;\n        }\n        case DstOverCompositeOp:\n        case OverCompositeOp:\n        case SrcOverCompositeOp:\n        {\n          alpha=Sa+Da-Sa*Da;\n          break;\n        }\n        case DstOutCompositeOp:\n        {\n          alpha=Da*(1.0-Sa);\n          break;\n        }\n        case OutCompositeOp:\n        case SrcOutCompositeOp:\n        {\n          alpha=Sa*(1.0-Da);\n          break;\n        }\n        case BlendCompositeOp:\n        case PlusCompositeOp:\n        {\n          alpha=RoundToUnity(source_dissolve*Sa+canvas_dissolve*Da);\n          break;\n        }\n        case XorCompositeOp:\n        {\n          alpha=Sa+Da-2.0*Sa*Da;\n          break;\n        }\n        default:\n        {\n          alpha=1.0;\n          break;\n        }\n      }\n      switch (compose)\n      {\n        case ColorizeCompositeOp:\n        case HueCompositeOp:\n        case LuminizeCompositeOp:\n        case ModulateCompositeOp:\n        case SaturateCompositeOp:\n        {\n          GetPixelInfoPixel(source_image,p,&source_pixel);\n          GetPixelInfoPixel(image,q,&canvas_pixel);\n          break;\n        }\n        default:\n          break;\n      }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        MagickRealType\n          pixel,\n          sans;\n\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        PixelTrait source_traits = GetPixelChannelTraits(source_image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if ((channel == AlphaPixelChannel) &&\n            ((traits & UpdatePixelTrait) != 0))\n          {\n            /*\n              Set alpha channel.\n            */\n            switch (compose)\n            {\n              case AlphaCompositeOp:\n              {\n                pixel=QuantumRange*Sa;\n                break;\n              }\n              case AtopCompositeOp:\n              case CopyBlackCompositeOp:\n              case CopyBlueCompositeOp:\n              case CopyCyanCompositeOp:\n              case CopyGreenCompositeOp:\n              case CopyMagentaCompositeOp:\n              case CopyRedCompositeOp:\n              case CopyYellowCompositeOp:\n              case SrcAtopCompositeOp:\n              case DstCompositeOp:\n              case NoCompositeOp:\n              {\n                pixel=QuantumRange*Da;\n                break;\n              }\n              case ChangeMaskCompositeOp:\n              {\n                MagickBooleanType\n                  equivalent;\n\n                if (Da < 0.5)\n                  {\n                    pixel=(MagickRealType) TransparentAlpha;\n                    break;\n                  }\n                equivalent=IsFuzzyEquivalencePixel(source_image,p,image,q);\n                if (equivalent != MagickFalse)\n                  pixel=(MagickRealType) TransparentAlpha;\n                else\n                  pixel=(MagickRealType) OpaqueAlpha;\n                break;\n              }\n              case ClearCompositeOp:\n              {\n                pixel=(MagickRealType) TransparentAlpha;\n                break;\n              }\n              case ColorizeCompositeOp:\n              case HueCompositeOp:\n              case LuminizeCompositeOp:\n              case SaturateCompositeOp:\n              {\n                if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n                  {\n                    pixel=QuantumRange*Da;\n                    break;\n                  }\n                if (fabs((double) (QuantumRange*Da-TransparentAlpha)) < MagickEpsilon)\n                  {\n                    pixel=QuantumRange*Sa;\n                    break;\n                  }\n                if (Sa < Da)\n                  {\n                    pixel=QuantumRange*Da;\n                    break;\n                  }\n                pixel=QuantumRange*Sa;\n                break;\n              }\n              case CopyAlphaCompositeOp:\n              {\n                if (source_image->alpha_trait == UndefinedPixelTrait)\n                  pixel=GetPixelIntensity(source_image,p);\n                else\n                  pixel=QuantumRange*Sa;\n                break;\n              }\n              case CopyCompositeOp:\n              case DisplaceCompositeOp:\n              case DistortCompositeOp:\n              case DstAtopCompositeOp:\n              case ReplaceCompositeOp:\n              case SrcCompositeOp:\n              {\n                pixel=QuantumRange*Sa;\n                break;\n              }\n              case DarkenIntensityCompositeOp:\n              {\n                pixel=Sa*GetPixelIntensity(source_image,p) <\n                  Da*GetPixelIntensity(image,q) ? Sa : Da;\n                break;\n              }\n              case DifferenceCompositeOp:\n              {\n                pixel=QuantumRange*fabs(Sa-Da);\n                break;\n              }\n              case LightenIntensityCompositeOp:\n              {\n                pixel=Sa*GetPixelIntensity(source_image,p) >\n                  Da*GetPixelIntensity(image,q) ? Sa : Da;\n                break;\n              }\n              case ModulateCompositeOp:\n              {\n                pixel=QuantumRange*Da;\n                break;\n              }\n              case MultiplyCompositeOp:\n              {\n                pixel=QuantumRange*Sa*Da;\n                break;\n              }\n              case StereoCompositeOp:\n              {\n                pixel=QuantumRange*(Sa+Da)/2;\n                break;\n              }\n              default:\n              {\n                pixel=QuantumRange*alpha;\n                break;\n              }\n            }\n            q[i]=clamp != MagickFalse ? ClampPixel(pixel) :\n              ClampToQuantum(pixel);\n            continue;\n          }\n        if (source_traits == UndefinedPixelTrait)\n          continue;\n        /*\n          Sc: source color.\n          Dc: canvas color.\n        */\n        Sc=(MagickRealType) GetPixelChannel(source_image,channel,p);\n        Dc=(MagickRealType) q[i];\n        if ((traits & CopyPixelTrait) != 0)\n          {\n            /*\n              Copy channel.\n            */\n            q[i]=ClampToQuantum(Dc);\n            continue;\n          }\n        /*\n          Porter-Duff compositions:\n            Sca: source normalized color multiplied by alpha.\n            Dca: normalized canvas color multiplied by alpha.\n        */\n        Sca=QuantumScale*Sa*Sc;\n        Dca=QuantumScale*Da*Dc;\n        SaSca=Sa*PerceptibleReciprocal(Sca);\n        DcaDa=Dca*PerceptibleReciprocal(Da);\n        switch (compose)\n        {\n          case DarkenCompositeOp:\n          case LightenCompositeOp:\n          case ModulusSubtractCompositeOp:\n          {\n            gamma=PerceptibleReciprocal(1.0-alpha);\n            break;\n          }\n          default:\n          {\n            gamma=PerceptibleReciprocal(alpha);\n            break;\n          }\n        }\n        pixel=Dc;\n        switch (compose)\n        {\n          case AlphaCompositeOp:\n          {\n            pixel=QuantumRange*Sa;\n            break;\n          }\n          case AtopCompositeOp:\n          case SrcAtopCompositeOp:\n          {\n            pixel=QuantumRange*(Sca*Da+Dca*(1.0-Sa));\n            break;\n          }\n          case BlendCompositeOp:\n          {\n            pixel=gamma*(source_dissolve*Sa*Sc+canvas_dissolve*Da*Dc);\n            break;\n          }\n          case BlurCompositeOp:\n          case CopyCompositeOp:\n          case ReplaceCompositeOp:\n          case SrcCompositeOp:\n          {\n            pixel=QuantumRange*Sca;\n            break;\n          }\n          case DisplaceCompositeOp:\n          case DistortCompositeOp:\n          {\n            pixel=Sc;\n            break;\n          }\n          case BumpmapCompositeOp:\n          {\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            pixel=QuantumScale*GetPixelIntensity(source_image,p)*Dc;\n            break;\n          }\n          case ChangeMaskCompositeOp:\n          {\n            pixel=Dc;\n            break;\n          }\n          case ClearCompositeOp:\n          {\n            pixel=0.0;\n            break;\n          }\n          case ColorBurnCompositeOp:\n          {\n            if ((Sca == 0.0) && (Dca == Da))\n              {\n                pixel=QuantumRange*gamma*(Sa*Da+Dca*(1.0-Sa));\n                break;\n              }\n            if (Sca == 0.0)\n              {\n                pixel=QuantumRange*gamma*(Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*gamma*(Sa*Da-Sa*Da*MagickMin(1.0,(1.0-DcaDa)*\n              SaSca)+Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case ColorDodgeCompositeOp:\n          {\n            if ((Sca*Da+Dca*Sa) >= Sa*Da)\n              pixel=QuantumRange*gamma*(Sa*Da+Sca*(1.0-Da)+Dca*(1.0-Sa));\n            else\n              pixel=QuantumRange*gamma*(Dca*Sa*Sa*PerceptibleReciprocal(Sa-Sca)+\n                Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case ColorizeCompositeOp:\n          {\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            if (fabs((double) (QuantumRange*Da-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Sc;\n                break;\n              }\n            CompositeHCL(canvas_pixel.red,canvas_pixel.green,canvas_pixel.blue,\n              &sans,&sans,&luma);\n            CompositeHCL(source_pixel.red,source_pixel.green,source_pixel.blue,\n              &hue,&chroma,&sans);\n            HCLComposite(hue,chroma,luma,&red,&green,&blue);\n            switch (channel)\n            {\n              case RedPixelChannel: pixel=red; break;\n              case GreenPixelChannel: pixel=green; break;\n              case BluePixelChannel: pixel=blue; break;\n              default: pixel=Dc; break;\n            }\n            break;\n          }\n          case CopyAlphaCompositeOp:\n          {\n            pixel=Dc;\n            break;\n          }\n          case CopyBlackCompositeOp:\n          {\n            if (channel == BlackPixelChannel)\n              pixel=(MagickRealType) (QuantumRange-\n                GetPixelBlack(source_image,p));\n            break;\n          }\n          case CopyBlueCompositeOp:\n          case CopyYellowCompositeOp:\n          {\n            if (channel == BluePixelChannel)\n              pixel=(MagickRealType) GetPixelBlue(source_image,p);\n            break;\n          }\n          case CopyGreenCompositeOp:\n          case CopyMagentaCompositeOp:\n          {\n            if (channel == GreenPixelChannel)\n              pixel=(MagickRealType) GetPixelGreen(source_image,p);\n            break;\n          }\n          case CopyRedCompositeOp:\n          case CopyCyanCompositeOp:\n          {\n            if (channel == RedPixelChannel)\n              pixel=(MagickRealType) GetPixelRed(source_image,p);\n            break;\n          }\n          case DarkenCompositeOp:\n          {\n            /*\n              Darken is equivalent to a 'Minimum' method\n                OR a greyscale version of a binary 'Or'\n                OR the 'Intersection' of pixel sets.\n            */\n            if ((Sca*Da) < (Dca*Sa))\n              {\n                pixel=QuantumRange*(Sca+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Dca+Sca*(1.0-Da));\n            break;\n          }\n          case DarkenIntensityCompositeOp:\n          {\n            pixel=Sa*GetPixelIntensity(source_image,p) <\n              Da*GetPixelIntensity(image,q) ? Sc : Dc;\n            break;\n          }\n          case DifferenceCompositeOp:\n          {\n            pixel=QuantumRange*gamma*(Sca+Dca-2.0*MagickMin(Sca*Da,Dca*Sa));\n            break;\n          }\n          case DissolveCompositeOp:\n          {\n            pixel=gamma*(source_dissolve*Sa*Sc-source_dissolve*Sa*\n              canvas_dissolve*Da*Dc+canvas_dissolve*Da*Dc);\n            break;\n          }\n          case DivideDstCompositeOp:\n          {\n            if ((fabs((double) Sca) < MagickEpsilon) &&\n                (fabs((double) Dca) < MagickEpsilon))\n              {\n                pixel=QuantumRange*gamma*(Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            if (fabs((double) Dca) < MagickEpsilon)\n              {\n                pixel=QuantumRange*gamma*(Sa*Da+Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*gamma*(Sca*Da*Da/Dca+Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case DivideSrcCompositeOp:\n          {\n            if ((fabs((double) Dca) < MagickEpsilon) &&\n                (fabs((double) Sca) < MagickEpsilon))\n              {\n                pixel=QuantumRange*gamma*(Dca*(1.0-Sa)+Sca*(1.0-Da));\n                break;\n              }\n            if (fabs((double) Sca) < MagickEpsilon)\n              {\n                pixel=QuantumRange*gamma*(Da*Sa+Dca*(1.0-Sa)+Sca*(1.0-Da));\n                break;\n              }\n            pixel=QuantumRange*gamma*(Dca*Sa*SaSca+Dca*(1.0-Sa)+Sca*(1.0-Da));\n            break;\n          }\n          case DstAtopCompositeOp:\n          {\n            pixel=QuantumRange*(Dca*Sa+Sca*(1.0-Da));\n            break;\n          }\n          case DstCompositeOp:\n          case NoCompositeOp:\n          {\n            pixel=QuantumRange*Dca;\n            break;\n          }\n          case DstInCompositeOp:\n          {\n            pixel=QuantumRange*(Dca*Sa);\n            break;\n          }\n          case DstOutCompositeOp:\n          {\n            pixel=QuantumRange*(Dca*(1.0-Sa));\n            break;\n          }\n          case DstOverCompositeOp:\n          {\n            pixel=QuantumRange*gamma*(Dca+Sca*(1.0-Da));\n            break;\n          }\n          case ExclusionCompositeOp:\n          {\n            pixel=QuantumRange*gamma*(Sca*Da+Dca*Sa-2.0*Sca*Dca+Sca*(1.0-Da)+\n              Dca*(1.0-Sa));\n            break;\n          }\n          case HardLightCompositeOp:\n          {\n            if ((2.0*Sca) < Sa)\n              {\n                pixel=QuantumRange*gamma*(2.0*Sca*Dca+Sca*(1.0-Da)+Dca*(1.0-\n                  Sa));\n                break;\n              }\n            pixel=QuantumRange*gamma*(Sa*Da-2.0*(Da-Dca)*(Sa-Sca)+Sca*(1.0-Da)+\n              Dca*(1.0-Sa));\n            break;\n          }\n          case HardMixCompositeOp:\n          {\n            pixel=gamma*(((Sca+Dca) < 1.0) ? 0.0 : QuantumRange);\n            break;\n          }\n          case HueCompositeOp:\n          {\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            if (fabs((double) (QuantumRange*Da-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Sc;\n                break;\n              }\n            CompositeHCL(canvas_pixel.red,canvas_pixel.green,canvas_pixel.blue,\n              &hue,&chroma,&luma);\n            CompositeHCL(source_pixel.red,source_pixel.green,source_pixel.blue,\n              &hue,&sans,&sans);\n            HCLComposite(hue,chroma,luma,&red,&green,&blue);\n            switch (channel)\n            {\n              case RedPixelChannel: pixel=red; break;\n              case GreenPixelChannel: pixel=green; break;\n              case BluePixelChannel: pixel=blue; break;\n              default: pixel=Dc; break;\n            }\n            break;\n          }\n          case InCompositeOp:\n          case SrcInCompositeOp:\n          {\n            pixel=QuantumRange*(Sca*Da);\n            break;\n          }\n          case LinearBurnCompositeOp:\n          {\n            /*\n              LinearBurn: as defined by Abode Photoshop, according to\n              http://www.simplefilter.de/en/basics/mixmods.html is:\n\n                f(Sc,Dc) = Sc + Dc - 1\n            */\n            pixel=QuantumRange*gamma*(Sca+Dca-Sa*Da);\n            break;\n          }\n          case LinearDodgeCompositeOp:\n          {\n            pixel=gamma*(Sa*Sc+Da*Dc);\n            break;\n          }\n          case LinearLightCompositeOp:\n          {\n            /*\n              LinearLight: as defined by Abode Photoshop, according to\n              http://www.simplefilter.de/en/basics/mixmods.html is:\n\n                f(Sc,Dc) = Dc + 2*Sc - 1\n            */\n            pixel=QuantumRange*gamma*((Sca-Sa)*Da+Sca+Dca);\n            break;\n          }\n          case LightenCompositeOp:\n          {\n            if ((Sca*Da) > (Dca*Sa))\n              {\n                pixel=QuantumRange*(Sca+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Dca+Sca*(1.0-Da));\n            break;\n          }\n          case LightenIntensityCompositeOp:\n          {\n            /*\n              Lighten is equivalent to a 'Maximum' method\n                OR a greyscale version of a binary 'And'\n                OR the 'Union' of pixel sets.\n            */\n            pixel=Sa*GetPixelIntensity(source_image,p) >\n              Da*GetPixelIntensity(image,q) ? Sc : Dc;\n            break;\n          }\n          case LuminizeCompositeOp:\n          {\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            if (fabs((double) (QuantumRange*Da-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Sc;\n                break;\n              }\n            CompositeHCL(canvas_pixel.red,canvas_pixel.green,canvas_pixel.blue,\n              &hue,&chroma,&luma);\n            CompositeHCL(source_pixel.red,source_pixel.green,source_pixel.blue,\n              &sans,&sans,&luma);\n            HCLComposite(hue,chroma,luma,&red,&green,&blue);\n            switch (channel)\n            {\n              case RedPixelChannel: pixel=red; break;\n              case GreenPixelChannel: pixel=green; break;\n              case BluePixelChannel: pixel=blue; break;\n              default: pixel=Dc; break;\n            }\n            break;\n          }\n          case MathematicsCompositeOp:\n          {\n            /*\n              'Mathematics' a free form user control mathematical composition\n              is defined as...\n\n                f(Sc,Dc) = A*Sc*Dc + B*Sc + C*Dc + D\n\n              Where the arguments A,B,C,D are (currently) passed to composite\n              as a command separated 'geometry' string in \"compose:args\" image\n              artifact.\n\n                 A = a->rho,   B = a->sigma,  C = a->xi,  D = a->psi\n\n              Applying the SVG transparency formula (see above), we get...\n\n               Dca' = Sa*Da*f(Sc,Dc) + Sca*(1.0-Da) + Dca*(1.0-Sa)\n\n               Dca' = A*Sca*Dca + B*Sca*Da + C*Dca*Sa + D*Sa*Da + Sca*(1.0-Da) +\n                 Dca*(1.0-Sa)\n            */\n            pixel=QuantumRange*gamma*(geometry_info.rho*Sca*Dca+\n              geometry_info.sigma*Sca*Da+geometry_info.xi*Dca*Sa+\n              geometry_info.psi*Sa*Da+Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case MinusDstCompositeOp:\n          {\n            pixel=gamma*(Sa*Sc+Da*Dc-2.0*Da*Dc*Sa);\n            break;\n          }\n          case MinusSrcCompositeOp:\n          {\n            /*\n              Minus source from canvas.\n\n                f(Sc,Dc) = Sc - Dc\n            */\n            pixel=gamma*(Da*Dc+Sa*Sc-2.0*Sa*Sc*Da);\n            break;\n          }\n          case ModulateCompositeOp:\n          {\n            ssize_t\n              offset;\n\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            offset=(ssize_t) (GetPixelIntensity(source_image,p)-midpoint);\n            if (offset == 0)\n              {\n                pixel=Dc;\n                break;\n              }\n            CompositeHCL(canvas_pixel.red,canvas_pixel.green,canvas_pixel.blue,\n              &hue,&chroma,&luma);\n            luma+=(0.01*percent_luma*offset)/midpoint;\n            chroma*=0.01*percent_chroma;\n            HCLComposite(hue,chroma,luma,&red,&green,&blue);\n            switch (channel)\n            {\n              case RedPixelChannel: pixel=red; break;\n              case GreenPixelChannel: pixel=green; break;\n              case BluePixelChannel: pixel=blue; break;\n              default: pixel=Dc; break;\n            }\n            break;\n          }\n          case ModulusAddCompositeOp:\n          {\n            pixel=Sc+Dc;\n            while (pixel > QuantumRange)\n              pixel-=QuantumRange;\n            while (pixel < 0.0)\n              pixel+=QuantumRange;\n            pixel=(Sa*Da*pixel+Sa*Sc*(1.0-Da)+Da*Dc*(1.0-Sa));\n            break;\n          }\n          case ModulusSubtractCompositeOp:\n          {\n            pixel=Sc-Dc;\n            while (pixel > QuantumRange)\n              pixel-=QuantumRange;\n            while (pixel < 0.0)\n              pixel+=QuantumRange;\n            pixel=(Sa*Da*pixel+Sa*Sc*(1.0-Da)+Da*Dc*(1.0-Sa));\n            break;\n          }\n          case MultiplyCompositeOp:\n          {\n            pixel=QuantumRange*gamma*(Sca*Dca+Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case OutCompositeOp:\n          case SrcOutCompositeOp:\n          {\n            pixel=QuantumRange*(Sca*(1.0-Da));\n            break;\n          }\n          case OverCompositeOp:\n          case SrcOverCompositeOp:\n          {\n            pixel=QuantumRange*gamma*(Sca+Dca*(1.0-Sa));\n            break;\n          }\n          case OverlayCompositeOp:\n          {\n            if ((2.0*Dca) < Da)\n              {\n                pixel=QuantumRange*gamma*(2.0*Dca*Sca+Dca*(1.0-Sa)+Sca*(1.0-\n                  Da));\n                break;\n              }\n            pixel=QuantumRange*gamma*(Da*Sa-2.0*(Sa-Sca)*(Da-Dca)+Dca*(1.0-Sa)+\n              Sca*(1.0-Da));\n            break;\n          }\n          case PegtopLightCompositeOp:\n          {\n            /*\n              PegTop: A Soft-Light alternative: A continuous version of the\n              Softlight function, producing very similar results.\n\n                f(Sc,Dc) = Dc^2*(1-2*Sc) + 2*Sc*Dc\n\n              http://www.pegtop.net/delphi/articles/blendmodes/softlight.htm.\n            */\n            if (fabs((double) Da) < MagickEpsilon)\n              {\n                pixel=QuantumRange*gamma*(Sca);\n                break;\n              }\n            pixel=QuantumRange*gamma*(Dca*Dca*(Sa-2.0*Sca)/Da+Sca*(2.0*Dca+1.0-\n              Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case PinLightCompositeOp:\n          {\n            /*\n              PinLight: A Photoshop 7 composition method\n              http://www.simplefilter.de/en/basics/mixmods.html\n\n                f(Sc,Dc) = Dc<2*Sc-1 ? 2*Sc-1 : Dc>2*Sc   ? 2*Sc : Dc\n            */\n            if ((Dca*Sa) < (Da*(2.0*Sca-Sa)))\n              {\n                pixel=QuantumRange*gamma*(Sca*(Da+1.0)-Sa*Da+Dca*(1.0-Sa));\n                break;\n              }\n            if ((Dca*Sa) > (2.0*Sca*Da))\n              {\n                pixel=QuantumRange*gamma*(Sca*Da+Sca+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*gamma*(Sca*(1.0-Da)+Dca);\n            break;\n          }\n          case PlusCompositeOp:\n          {\n            pixel=QuantumRange*(Sca+Dca);\n            break;\n          }\n          case SaturateCompositeOp:\n          {\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            if (fabs((double) (QuantumRange*Da-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Sc;\n                break;\n              }\n            CompositeHCL(canvas_pixel.red,canvas_pixel.green,canvas_pixel.blue,\n              &hue,&chroma,&luma);\n            CompositeHCL(source_pixel.red,source_pixel.green,source_pixel.blue,\n              &sans,&chroma,&sans);\n            HCLComposite(hue,chroma,luma,&red,&green,&blue);\n            switch (channel)\n            {\n              case RedPixelChannel: pixel=red; break;\n              case GreenPixelChannel: pixel=green; break;\n              case BluePixelChannel: pixel=blue; break;\n              default: pixel=Dc; break;\n            }\n            break;\n          }\n          case ScreenCompositeOp:\n          {\n            /*\n              Screen:  a negated multiply:\n\n                f(Sc,Dc) = 1.0-(1.0-Sc)*(1.0-Dc)\n            */\n            pixel=QuantumRange*gamma*(Sca+Dca-Sca*Dca);\n            break;\n          }\n          case SoftLightCompositeOp:\n          {\n            if ((2.0*Sca) < Sa)\n              {\n                pixel=QuantumRange*gamma*(Dca*(Sa+(2.0*Sca-Sa)*(1.0-DcaDa))+\n                  Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            if (((2.0*Sca) > Sa) && ((4.0*Dca) <= Da))\n              {\n                pixel=QuantumRange*gamma*(Dca*Sa+Da*(2.0*Sca-Sa)*(4.0*DcaDa*\n                  (4.0*DcaDa+1.0)*(DcaDa-1.0)+7.0*DcaDa)+Sca*(1.0-Da)+\n                  Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*gamma*(Dca*Sa+Da*(2.0*Sca-Sa)*(pow(DcaDa,0.5)-\n              DcaDa)+Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case StereoCompositeOp:\n          {\n            if (channel == RedPixelChannel)\n              pixel=(MagickRealType) GetPixelRed(source_image,p);\n            break;\n          }\n          case ThresholdCompositeOp:\n          {\n            MagickRealType\n              delta;\n\n            delta=Sc-Dc;\n            if ((MagickRealType) fabs((double) (2.0*delta)) < threshold)\n              {\n                pixel=gamma*Dc;\n                break;\n              }\n            pixel=gamma*(Dc+delta*amount);\n            break;\n          }\n          case VividLightCompositeOp:\n          {\n            /*\n              VividLight: A Photoshop 7 composition method.  See\n              http://www.simplefilter.de/en/basics/mixmods.html.\n\n                f(Sc,Dc) = (2*Sc < 1) ? 1-(1-Dc)/(2*Sc) : Dc/(2*(1-Sc))\n            */\n            if ((fabs((double) Sa) < MagickEpsilon) ||\n                (fabs((double) (Sca-Sa)) < MagickEpsilon))\n              {\n                pixel=QuantumRange*gamma*(Sa*Da+Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            if ((2.0*Sca) <= Sa)\n              {\n                pixel=QuantumRange*gamma*(Sa*(Da+Sa*(Dca-Da)*\n                  PerceptibleReciprocal(2.0*Sca))+Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*gamma*(Dca*Sa*Sa*PerceptibleReciprocal(2.0*\n              (Sa-Sca))+Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case XorCompositeOp:\n          {\n            pixel=QuantumRange*(Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          default:\n          {\n            pixel=Sc;\n            break;\n          }\n        }\n        q[i]=clamp != MagickFalse ? ClampPixel(pixel) : ClampToQuantum(pixel);\n      }\n      p+=GetPixelChannels(source_image);\n      channels=GetPixelChannels(source_image);\n      if (p >= (pixels+channels*source_image->columns))\n        p=pixels;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,CompositeImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  source_view=DestroyCacheView(source_view);\n  image_view=DestroyCacheView(image_view);\n  if (canvas_image != (Image * ) NULL)\n    canvas_image=DestroyImage(canvas_image);\n  else\n    source_image=DestroyImage(source_image);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     T e x t u r e I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TextureImage() repeatedly tiles the texture image across and down the image\n%  canvas.\n%\n%  The format of the TextureImage method is:\n%\n%      MagickBooleanType TextureImage(Image *image,const Image *texture,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o texture_image: This image is the texture to layer on the background.\n%\n*/\nMagickExport MagickBooleanType TextureImage(Image *image,const Image *texture,\n  ExceptionInfo *exception)\n{\n#define TextureImageTag  \"Texture/Image\"\n\n  CacheView\n    *image_view,\n    *texture_view;\n\n  Image\n    *texture_image;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  if (texture == (const Image *) NULL)\n    return(MagickFalse);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  texture_image=CloneImage(texture,0,0,MagickTrue,exception);\n  if (texture_image == (const Image *) NULL)\n    return(MagickFalse);\n  (void) TransformImageColorspace(texture_image,image->colorspace,exception);\n  (void) SetImageVirtualPixelMethod(texture_image,TileVirtualPixelMethod,\n    exception);\n  status=MagickTrue;\n  if ((image->compose != CopyCompositeOp) &&\n      ((image->compose != OverCompositeOp) ||\n       (image->alpha_trait != UndefinedPixelTrait) ||\n       (texture_image->alpha_trait != UndefinedPixelTrait)))\n    {\n      /*\n        Tile texture onto the image background.\n      */\n      for (y=0; y < (ssize_t) image->rows; y+=(ssize_t) texture_image->rows)\n      {\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        for (x=0; x < (ssize_t) image->columns; x+=(ssize_t) texture_image->columns)\n        {\n          MagickBooleanType\n            thread_status;\n\n          thread_status=CompositeImage(image,texture_image,image->compose,\n            MagickTrue,x+texture_image->tile_offset.x,y+\n            texture_image->tile_offset.y,exception);\n          if (thread_status == MagickFalse)\n            {\n              status=thread_status;\n              break;\n            }\n        }\n        if (image->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n            proceed=SetImageProgress(image,TextureImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n      (void) SetImageProgress(image,TextureImageTag,(MagickOffsetType)\n        image->rows,image->rows);\n      texture_image=DestroyImage(texture_image);\n      return(status);\n    }\n  /*\n    Tile texture onto the image background (optimized).\n  */\n  status=MagickTrue;\n  texture_view=AcquireVirtualCacheView(texture_image,exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(texture_image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    MagickBooleanType\n      sync;\n\n    register const Quantum\n      *p,\n      *pixels;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *q;\n\n    size_t\n      width;\n\n    if (status == MagickFalse)\n      continue;\n    pixels=GetCacheViewVirtualPixels(texture_view,texture_image->tile_offset.x,\n      (y+texture_image->tile_offset.y) % texture_image->rows,\n      texture_image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if ((pixels == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x+=(ssize_t) texture_image->columns)\n    {\n      register ssize_t\n        j;\n\n      p=pixels;\n      width=texture_image->columns;\n      if ((x+(ssize_t) width) > (ssize_t) image->columns)\n        width=image->columns-x;\n      for (j=0; j < (ssize_t) width; j++)\n      {\n        register ssize_t\n          i;\n\n        for (i=0; i < (ssize_t) GetPixelChannels(texture_image); i++)\n        {\n          PixelChannel channel = GetPixelChannelChannel(texture_image,i);\n          PixelTrait traits = GetPixelChannelTraits(image,channel);\n          PixelTrait texture_traits=GetPixelChannelTraits(texture_image,\n            channel);\n          if ((traits == UndefinedPixelTrait) ||\n              (texture_traits == UndefinedPixelTrait))\n            continue;\n          SetPixelChannel(image,channel,p[i],q);\n        }\n        p+=GetPixelChannels(texture_image);\n        q+=GetPixelChannels(image);\n      }\n    }\n    sync=SyncCacheViewAuthenticPixels(image_view,exception);\n    if (sync == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n        proceed=SetImageProgress(image,TextureImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  texture_view=DestroyCacheView(texture_view);\n  image_view=DestroyCacheView(image_view);\n  texture_image=DestroyImage(texture_image);\n  return(status);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%        CCCC   OOO   M   M  PPPP    OOO   SSSSS  IIIII  TTTTT  EEEEE         %\n%       C      O   O  MM MM  P   P  O   O  SS       I      T    E             %\n%       C      O   O  M M M  PPPP   O   O   SSS     I      T    EEE           %\n%       C      O   O  M   M  P      O   O     SS    I      T    E             %\n%        CCCC   OOO   M   M  P       OOO   SSSSS  IIIII    T    EEEEE         %\n%                                                                             %\n%                                                                             %\n%                     MagickCore Image Composite Methods                      %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/fx.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/resample.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/threshold.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#include \"MagickCore/version.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C o m p o s i t e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CompositeImage() returns the second image composited onto the first\n%  at the specified offset, using the specified composite method.\n%\n%  The format of the CompositeImage method is:\n%\n%      MagickBooleanType CompositeImage(Image *image,\n%        const Image *source_image,const CompositeOperator compose,\n%        const MagickBooleanType clip_to_self,const ssize_t x_offset,\n%        const ssize_t y_offset,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the canvas image, modified by he composition\n%\n%    o source_image: the source image.\n%\n%    o compose: This operator affects how the composite is applied to\n%      the image.  The operators and how they are utilized are listed here\n%      http://www.w3.org/TR/SVG12/#compositing.\n%\n%    o clip_to_self: set to MagickTrue to limit composition to area composed.\n%\n%    o x_offset: the column offset of the composited image.\n%\n%    o y_offset: the row offset of the composited image.\n%\n%  Extra Controls from Image meta-data in 'image' (artifacts)\n%\n%    o \"compose:args\"\n%        A string containing extra numerical arguments for specific compose\n%        methods, generally expressed as a 'geometry' or a comma separated list\n%        of numbers.\n%\n%        Compose methods needing such arguments include \"BlendCompositeOp\" and\n%        \"DisplaceCompositeOp\".\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n/*\n   Composition based on the SVG specification:\n\n   A Composition is defined by...\n      Color Function :  f(Sc,Dc)  where Sc and Dc are the normizalized colors\n      Blending areas :  X = 1     for area of overlap, ie: f(Sc,Dc)\n                        Y = 1     for source preserved\n                        Z = 1     for canvas preserved\n\n   Conversion to transparency (then optimized)\n      Dca' = f(Sc, Dc)*Sa*Da + Y*Sca*(1-Da) + Z*Dca*(1-Sa)\n      Da'  = X*Sa*Da + Y*Sa*(1-Da) + Z*Da*(1-Sa)\n\n   Where...\n      Sca = Sc*Sa     normalized Source color divided by Source alpha\n      Dca = Dc*Da     normalized Dest color divided by Dest alpha\n      Dc' = Dca'/Da'  the desired color value for this channel.\n\n   Da' in in the follow formula as 'gamma'  The resulting alpla value.\n\n   Most functions use a blending mode of over (X=1,Y=1,Z=1) this results in\n   the following optimizations...\n      gamma = Sa+Da-Sa*Da;\n      gamma = 1 - QuantumScale*alpha * QuantumScale*beta;\n      opacity = QuantumScale*alpha*beta;  // over blend, optimized 1-Gamma\n\n   The above SVG definitions also define that Mathematical Composition\n   methods should use a 'Over' blending mode for Alpha Channel.\n   It however was not applied for composition modes of 'Plus', 'Minus',\n   the modulus versions of 'Add' and 'Subtract'.\n\n   Mathematical operator changes to be applied from IM v6.7...\n\n    1) Modulus modes 'Add' and 'Subtract' are obsoleted and renamed\n       'ModulusAdd' and 'ModulusSubtract' for clarity.\n\n    2) All mathematical compositions work as per the SVG specification\n       with regard to blending.  This now includes 'ModulusAdd' and\n       'ModulusSubtract'.\n\n    3) When the special channel flag 'sync' (syncronize channel updates)\n       is turned off (enabled by default) then mathematical compositions are\n       only performed on the channels specified, and are applied\n       independantally of each other.  In other words the mathematics is\n       performed as 'pure' mathematical operations, rather than as image\n       operations.\n*/\n\nstatic void HCLComposite(const MagickRealType hue,const MagickRealType chroma,\n  const MagickRealType luma,MagickRealType *red,MagickRealType *green,\n  MagickRealType *blue)\n{\n  MagickRealType\n    b,\n    c,\n    g,\n    h,\n    m,\n    r,\n    x;\n\n  /*\n    Convert HCL to RGB colorspace.\n  */\n  assert(red != (MagickRealType *) NULL);\n  assert(green != (MagickRealType *) NULL);\n  assert(blue != (MagickRealType *) NULL);\n  h=6.0*hue;\n  c=chroma;\n  x=c*(1.0-fabs(fmod(h,2.0)-1.0));\n  r=0.0;\n  g=0.0;\n  b=0.0;\n  if ((0.0 <= h) && (h < 1.0))\n    {\n      r=c;\n      g=x;\n    }\n  else\n    if ((1.0 <= h) && (h < 2.0))\n      {\n        r=x;\n        g=c;\n      }\n    else\n      if ((2.0 <= h) && (h < 3.0))\n        {\n          g=c;\n          b=x;\n        }\n      else\n        if ((3.0 <= h) && (h < 4.0))\n          {\n            g=x;\n            b=c;\n          }\n        else\n          if ((4.0 <= h) && (h < 5.0))\n            {\n              r=x;\n              b=c;\n            }\n          else\n            if ((5.0 <= h) && (h < 6.0))\n              {\n                r=c;\n                b=x;\n              }\n  m=luma-(0.298839*r+0.586811*g+0.114350*b);\n  *red=QuantumRange*(r+m);\n  *green=QuantumRange*(g+m);\n  *blue=QuantumRange*(b+m);\n}\n\nstatic void CompositeHCL(const MagickRealType red,const MagickRealType green,\n  const MagickRealType blue,MagickRealType *hue,MagickRealType *chroma,\n  MagickRealType *luma)\n{\n  MagickRealType\n    b,\n    c,\n    g,\n    h,\n    max,\n    r;\n\n  /*\n    Convert RGB to HCL colorspace.\n  */\n  assert(hue != (MagickRealType *) NULL);\n  assert(chroma != (MagickRealType *) NULL);\n  assert(luma != (MagickRealType *) NULL);\n  r=red;\n  g=green;\n  b=blue;\n  max=MagickMax(r,MagickMax(g,b));\n  c=max-(MagickRealType) MagickMin(r,MagickMin(g,b));\n  h=0.0;\n  if (c == 0)\n    h=0.0;\n  else\n    if (red == max)\n      h=fmod((g-b)/c+6.0,6.0);\n    else\n      if (green == max)\n        h=((b-r)/c)+2.0;\n      else\n        if (blue == max)\n          h=((r-g)/c)+4.0;\n  *hue=(h/6.0);\n  *chroma=QuantumScale*c;\n  *luma=QuantumScale*(0.298839*r+0.586811*g+0.114350*b);\n}\n\nstatic MagickBooleanType CompositeOverImage(Image *image,\n  const Image *source_image,const MagickBooleanType clip_to_self,\n  const ssize_t x_offset,const ssize_t y_offset,ExceptionInfo *exception)\n{\n#define CompositeImageTag  \"Composite/Image\"\n\n  CacheView\n    *image_view,\n    *source_view;\n\n  const char\n    *value;\n\n  MagickBooleanType\n    clamp,\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  /*\n    Composite image.\n  */\n  status=MagickTrue;\n  progress=0;\n  clamp=MagickTrue;\n  value=GetImageArtifact(image,\"compose:clamp\");\n  if (value != (const char *) NULL)\n    clamp=IsStringTrue(value);\n  status=MagickTrue;\n  progress=0;\n  source_view=AcquireVirtualCacheView(source_image,exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(source_image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const Quantum\n      *pixels;\n\n    PixelInfo\n      canvas_pixel,\n      source_pixel;\n\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    if (clip_to_self != MagickFalse)\n      {\n        if (y < y_offset)\n          continue;\n        if ((y-y_offset) >= (ssize_t) source_image->rows)\n          continue;\n      }\n    /*\n      If pixels is NULL, y is outside overlay region.\n    */\n    pixels=(Quantum *) NULL;\n    p=(Quantum *) NULL;\n    if ((y >= y_offset) && ((y-y_offset) < (ssize_t) source_image->rows))\n      {\n        p=GetCacheViewVirtualPixels(source_view,0,y-y_offset,\n          source_image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        pixels=p;\n        if (x_offset < 0)\n          p-=x_offset*GetPixelChannels(source_image);\n      }\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    GetPixelInfo(image,&canvas_pixel);\n    GetPixelInfo(source_image,&source_pixel);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      MagickRealType\n        alpha,\n        Da,\n        Dc,\n        Dca,\n        Sa,\n        Sc,\n        Sca;\n\n      register ssize_t\n        i;\n\n      size_t\n        channels;\n\n      if (clip_to_self != MagickFalse)\n        {\n          if (x < x_offset)\n            {\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          if ((x-x_offset) >= (ssize_t) source_image->columns)\n            break;\n        }\n      if ((pixels == (Quantum *) NULL) || (x < x_offset) ||\n          ((x-x_offset) >= (ssize_t) source_image->columns))\n        {\n          Quantum\n            source[MaxPixelChannels];\n\n          /*\n            Virtual composite:\n              Sc: source color.\n              Dc: canvas color.\n          */\n          (void) GetOneVirtualPixel(source_image,x-x_offset,y-y_offset,source,\n            exception);\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            MagickRealType\n              pixel;\n\n            PixelChannel channel = GetPixelChannelChannel(image,i);\n            PixelTrait traits = GetPixelChannelTraits(image,channel);\n            PixelTrait source_traits=GetPixelChannelTraits(source_image,\n              channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (source_traits == UndefinedPixelTrait))\n              continue;\n            if (channel == AlphaPixelChannel)\n              pixel=(MagickRealType) TransparentAlpha;\n            else\n              pixel=(MagickRealType) q[i];\n            q[i]=clamp != MagickFalse ? ClampPixel(pixel) :\n              ClampToQuantum(pixel);\n          }\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      /*\n        Authentic composite:\n          Sa:  normalized source alpha.\n          Da:  normalized canvas alpha.\n      */\n      Sa=QuantumScale*GetPixelAlpha(source_image,p);\n      Da=QuantumScale*GetPixelAlpha(image,q);\n      alpha=Sa+Da-Sa*Da;\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        MagickRealType\n          pixel;\n\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        PixelTrait source_traits=GetPixelChannelTraits(source_image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if ((source_traits == UndefinedPixelTrait) &&\n            (channel != AlphaPixelChannel))\n            continue;\n        if (channel == AlphaPixelChannel)\n          {\n            /*\n              Set alpha channel.\n            */\n            pixel=QuantumRange*alpha;\n            q[i]=clamp != MagickFalse ? ClampPixel(pixel) :\n              ClampToQuantum(pixel);\n            continue;\n          }\n        /*\n          Sc: source color.\n          Dc: canvas color.\n        */\n        Sc=(MagickRealType) GetPixelChannel(source_image,channel,p);\n        Dc=(MagickRealType) q[i];\n        if ((traits & CopyPixelTrait) != 0)\n          {\n            /*\n              Copy channel.\n            */\n            q[i]=ClampToQuantum(Sc);\n            continue;\n          }\n        /*\n          Porter-Duff compositions:\n            Sca: source normalized color multiplied by alpha.\n            Dca: normalized canvas color multiplied by alpha.\n        */\n        Sca=QuantumScale*Sa*Sc;\n        Dca=QuantumScale*Da*Dc;\n        gamma=PerceptibleReciprocal(alpha);\n        pixel=QuantumRange*gamma*(Sca+Dca*(1.0-Sa));\n        q[i]=clamp != MagickFalse ? ClampPixel(pixel) : ClampToQuantum(pixel);\n      }\n      p+=GetPixelChannels(source_image);\n      channels=GetPixelChannels(source_image);\n      if (p >= (pixels+channels*source_image->columns))\n        p=pixels;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,CompositeImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  source_view=DestroyCacheView(source_view);\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nMagickExport MagickBooleanType CompositeImage(Image *image,\n  const Image *composite,const CompositeOperator compose,\n  const MagickBooleanType clip_to_self,const ssize_t x_offset,\n  const ssize_t y_offset,ExceptionInfo *exception)\n{\n#define CompositeImageTag  \"Composite/Image\"\n\n  CacheView\n    *source_view,\n    *image_view;\n\n  const char\n    *value;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *canvas_image,\n    *source_image;\n\n  MagickBooleanType\n    clamp,\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MagickRealType\n    amount,\n    canvas_dissolve,\n    midpoint,\n    percent_luma,\n    percent_chroma,\n    source_dissolve,\n    threshold;\n\n  MagickStatusType\n    flags;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(composite != (Image *) NULL);\n  assert(composite->signature == MagickCoreSignature);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  source_image=CloneImage(composite,0,0,MagickTrue,exception);\n  if (source_image == (const Image *) NULL)\n    return(MagickFalse);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  (void) SetImageColorspace(source_image,image->colorspace,exception);\n  if ((compose == OverCompositeOp) || (compose == SrcOverCompositeOp))\n    {\n      status=CompositeOverImage(image,source_image,clip_to_self,x_offset,\n        y_offset,exception);\n      source_image=DestroyImage(source_image);\n      return(status);\n    }\n  amount=0.5;\n  canvas_image=(Image *) NULL;\n  canvas_dissolve=1.0;\n  clamp=MagickTrue;\n  value=GetImageArtifact(image,\"compose:clamp\");\n  if (value != (const char *) NULL)\n    clamp=IsStringTrue(value);\n  SetGeometryInfo(&geometry_info);\n  percent_luma=100.0;\n  percent_chroma=100.0;\n  source_dissolve=1.0;\n  threshold=0.05f;\n  switch (compose)\n  {\n    case CopyCompositeOp:\n    {\n      if ((x_offset < 0) || (y_offset < 0))\n        break;\n      if ((x_offset+(ssize_t) source_image->columns) > (ssize_t) image->columns)\n        break;\n      if ((y_offset+(ssize_t) source_image->rows) > (ssize_t) image->rows)\n        break;\n      status=MagickTrue;\n      source_view=AcquireVirtualCacheView(source_image,exception);\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static) shared(status) \\\n        magick_number_threads(source_image,image,source_image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) source_image->rows; y++)\n      {\n        MagickBooleanType\n          sync;\n\n        register const Quantum\n          *p;\n\n        register Quantum\n          *q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        p=GetCacheViewVirtualPixels(source_view,0,y,source_image->columns,1,\n          exception);\n        q=GetCacheViewAuthenticPixels(image_view,x_offset,y+y_offset,\n          source_image->columns,1,exception);\n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) source_image->columns; x++)\n        {\n          register ssize_t\n            i;\n\n          if (GetPixelReadMask(source_image,p) <= (QuantumRange/2))\n            {\n              p+=GetPixelChannels(source_image);\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          for (i=0; i < (ssize_t) GetPixelChannels(source_image); i++)\n          {\n            PixelChannel channel = GetPixelChannelChannel(source_image,i);\n            PixelTrait source_traits = GetPixelChannelTraits(source_image,\n              channel);\n            PixelTrait traits = GetPixelChannelTraits(image,channel);\n            if (source_traits == UndefinedPixelTrait)\n              continue;\n            if (traits != UndefinedPixelTrait)\n              SetPixelChannel(image,channel,p[i],q);\n            else\n              if (channel == AlphaPixelChannel)\n                SetPixelChannel(image,channel,OpaqueAlpha,q);\n          }\n          p+=GetPixelChannels(source_image);\n          q+=GetPixelChannels(image);\n        }\n        sync=SyncCacheViewAuthenticPixels(image_view,exception);\n        if (sync == MagickFalse)\n          status=MagickFalse;\n        if (image->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n            proceed=SetImageProgress(image,CompositeImageTag,(MagickOffsetType)\n              y,image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n      source_view=DestroyCacheView(source_view);\n      image_view=DestroyCacheView(image_view);\n      source_image=DestroyImage(source_image);\n      return(status);\n    }\n    case IntensityCompositeOp:\n    {\n      if ((x_offset < 0) || (y_offset < 0))\n        break;\n      if ((x_offset+(ssize_t) source_image->columns) > (ssize_t) image->columns)\n        break;\n      if ((y_offset+(ssize_t) source_image->rows) > (ssize_t) image->rows)\n        break;\n      status=MagickTrue;\n      source_view=AcquireVirtualCacheView(source_image,exception);\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static) shared(status) \\\n        magick_number_threads(source_image,image,source_image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) source_image->rows; y++)\n      {\n        MagickBooleanType\n          sync;\n\n        register const Quantum\n          *p;\n\n        register Quantum\n          *q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        p=GetCacheViewVirtualPixels(source_view,0,y,source_image->columns,1,\n          exception);\n        q=GetCacheViewAuthenticPixels(image_view,x_offset,y+y_offset,\n          source_image->columns,1,exception);\n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) source_image->columns; x++)\n        {\n          if (GetPixelReadMask(source_image,p) <= (QuantumRange/2))\n            {\n              p+=GetPixelChannels(source_image);\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          SetPixelAlpha(image,clamp != MagickFalse ?\n            ClampPixel(GetPixelIntensity(source_image,p)) :\n            ClampToQuantum(GetPixelIntensity(source_image,p)),q);\n          p+=GetPixelChannels(source_image);\n          q+=GetPixelChannels(image);\n        }\n        sync=SyncCacheViewAuthenticPixels(image_view,exception);\n        if (sync == MagickFalse)\n          status=MagickFalse;\n        if (image->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n            proceed=SetImageProgress(image,CompositeImageTag,(MagickOffsetType)\n              y,image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n      source_view=DestroyCacheView(source_view);\n      image_view=DestroyCacheView(image_view);\n      source_image=DestroyImage(source_image);\n      return(status);\n    }\n    case CopyAlphaCompositeOp:\n    case ChangeMaskCompositeOp:\n    {\n      /*\n        Modify canvas outside the overlaid region and require an alpha\n        channel to exist, to add transparency.\n      */\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      break;\n    }\n    case BlurCompositeOp:\n    {\n      CacheView\n        *canvas_view;\n\n      MagickRealType\n        angle_range,\n        angle_start,\n        height,\n        width;\n\n      PixelInfo\n        pixel;\n\n      ResampleFilter\n        *resample_filter;\n\n      SegmentInfo\n        blur;\n\n      /*\n        Blur Image by resampling.\n\n        Blur Image dictated by an overlay gradient map: X = red_channel;\n          Y = green_channel; compose:args =  x_scale[,y_scale[,angle]].\n      */\n      canvas_image=CloneImage(image,0,0,MagickTrue,\n        exception);\n      if (canvas_image == (Image *) NULL)\n        {\n          source_image=DestroyImage(source_image);\n          return(MagickFalse);\n        }\n      /*\n        Gather the maximum blur sigma values from user.\n      */\n      flags=NoValue;\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (const char *) NULL)\n        flags=ParseGeometry(value,&geometry_info);\n      if ((flags & WidthValue) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n            \"InvalidSetting\",\"'%s' '%s'\",\"compose:args\",value);\n          source_image=DestroyImage(source_image);\n          canvas_image=DestroyImage(canvas_image);\n          return(MagickFalse);\n        }\n      /*\n        Users input sigma now needs to be converted to the EWA ellipse size.\n        The filter defaults to a sigma of 0.5 so to make this match the\n        users input the ellipse size needs to be doubled.\n      */\n      width=height=geometry_info.rho*2.0;\n      if ((flags & HeightValue) != 0 )\n        height=geometry_info.sigma*2.0;\n      /*\n        Default the unrotated ellipse width and height axis vectors.\n      */\n      blur.x1=width;\n      blur.x2=0.0;\n      blur.y1=0.0;\n      blur.y2=height;\n      /* rotate vectors if a rotation angle is given */\n      if ((flags & XValue) != 0 )\n        {\n          MagickRealType\n            angle;\n\n          angle=DegreesToRadians(geometry_info.xi);\n          blur.x1=width*cos(angle);\n          blur.x2=width*sin(angle);\n          blur.y1=(-height*sin(angle));\n          blur.y2=height*cos(angle);\n        }\n      /* Otherwise lets set a angle range and calculate in the loop */\n      angle_start=0.0;\n      angle_range=0.0;\n      if ((flags & YValue) != 0 )\n        {\n          angle_start=DegreesToRadians(geometry_info.xi);\n          angle_range=DegreesToRadians(geometry_info.psi)-angle_start;\n        }\n      /*\n        Set up a gaussian cylindrical filter for EWA Bluring.\n\n        As the minimum ellipse radius of support*1.0 the EWA algorithm\n        can only produce a minimum blur of 0.5 for Gaussian (support=2.0)\n        This means that even 'No Blur' will be still a little blurry!\n\n        The solution (as well as the problem of preventing any user\n        expert filter settings, is to set our own user settings, then\n        restore them afterwards.\n      */\n      resample_filter=AcquireResampleFilter(image,exception);\n      SetResampleFilter(resample_filter,GaussianFilter);\n\n      /* do the variable blurring of each pixel in image */\n      GetPixelInfo(image,&pixel);\n      source_view=AcquireVirtualCacheView(source_image,exception);\n      canvas_view=AcquireAuthenticCacheView(canvas_image,exception);\n      for (y=0; y < (ssize_t) source_image->rows; y++)\n      {\n        MagickBooleanType\n          sync;\n\n        register const Quantum\n          *magick_restrict p;\n\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (((y+y_offset) < 0) || ((y+y_offset) >= (ssize_t) image->rows))\n          continue;\n        p=GetCacheViewVirtualPixels(source_view,0,y,source_image->columns,1,\n          exception);\n        q=QueueCacheViewAuthenticPixels(canvas_view,0,y,canvas_image->columns,1,\n          exception);\n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n          break;\n        for (x=0; x < (ssize_t) source_image->columns; x++)\n        {\n          if (((x_offset+x) < 0) || ((x_offset+x) >= (ssize_t) image->columns))\n            {\n              p+=GetPixelChannels(source_image);\n              continue;\n            }\n          if (fabs((double) angle_range) > MagickEpsilon)\n            {\n              MagickRealType\n                angle;\n\n              angle=angle_start+angle_range*QuantumScale*\n                GetPixelBlue(source_image,p);\n              blur.x1=width*cos(angle);\n              blur.x2=width*sin(angle);\n              blur.y1=(-height*sin(angle));\n              blur.y2=height*cos(angle);\n            }\n#if 0\n          if ( x == 10 && y == 60 ) {\n            (void) fprintf(stderr, \"blur.x=%lf,%lf, blur.y=%lf,%lf\\n\",blur.x1,\n              blur.x2,blur.y1, blur.y2);\n            (void) fprintf(stderr, \"scaled by=%lf,%lf\\n\",QuantumScale*\n              GetPixelRed(p),QuantumScale*GetPixelGreen(p));\n#endif\n          ScaleResampleFilter(resample_filter,\n            blur.x1*QuantumScale*GetPixelRed(source_image,p),\n            blur.y1*QuantumScale*GetPixelGreen(source_image,p),\n            blur.x2*QuantumScale*GetPixelRed(source_image,p),\n            blur.y2*QuantumScale*GetPixelGreen(source_image,p) );\n          (void) ResamplePixelColor(resample_filter,(double) x_offset+x,\n            (double) y_offset+y,&pixel,exception);\n          SetPixelViaPixelInfo(canvas_image,&pixel,q);\n          p+=GetPixelChannels(source_image);\n          q+=GetPixelChannels(canvas_image);\n        }\n        sync=SyncCacheViewAuthenticPixels(canvas_view,exception);\n        if (sync == MagickFalse)\n          break;\n      }\n      resample_filter=DestroyResampleFilter(resample_filter);\n      source_view=DestroyCacheView(source_view);\n      canvas_view=DestroyCacheView(canvas_view);\n      source_image=DestroyImage(source_image);\n      source_image=canvas_image;\n      break;\n    }\n    case DisplaceCompositeOp:\n    case DistortCompositeOp:\n    {\n      CacheView\n        *canvas_view;\n\n      MagickRealType\n        horizontal_scale,\n        vertical_scale;\n\n      PixelInfo\n        pixel;\n\n      PointInfo\n        center,\n        offset;\n\n      /*\n        Displace/Distort based on overlay gradient map:\n          X = red_channel;  Y = green_channel;\n          compose:args = x_scale[,y_scale[,center.x,center.y]]\n      */\n      canvas_image=CloneImage(image,0,0,MagickTrue,\n        exception);\n      if (canvas_image == (Image *) NULL)\n        {\n          source_image=DestroyImage(source_image);\n          return(MagickFalse);\n        }\n      SetGeometryInfo(&geometry_info);\n      flags=NoValue;\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        flags=ParseGeometry(value,&geometry_info);\n      if ((flags & (WidthValue | HeightValue)) == 0 )\n        {\n          if ((flags & AspectValue) == 0)\n            {\n              horizontal_scale=(MagickRealType) (source_image->columns-1)/2.0;\n              vertical_scale=(MagickRealType) (source_image->rows-1)/2.0;\n            }\n          else\n            {\n              horizontal_scale=(MagickRealType) (image->columns-1)/2.0;\n              vertical_scale=(MagickRealType) (image->rows-1)/2.0;\n            }\n        }\n      else\n        {\n          horizontal_scale=geometry_info.rho;\n          vertical_scale=geometry_info.sigma;\n          if ((flags & PercentValue) != 0)\n            {\n              if ((flags & AspectValue) == 0)\n                {\n                  horizontal_scale*=(source_image->columns-1)/200.0;\n                  vertical_scale*=(source_image->rows-1)/200.0;\n                }\n              else\n                {\n                  horizontal_scale*=(image->columns-1)/200.0;\n                  vertical_scale*=(image->rows-1)/200.0;\n                }\n            }\n          if ((flags & HeightValue) == 0)\n            vertical_scale=horizontal_scale;\n        }\n      /*\n        Determine fixed center point for absolute distortion map\n         Absolute distort ==\n           Displace offset relative to a fixed absolute point\n           Select that point according to +X+Y user inputs.\n           default = center of overlay image\n           arg flag '!' = locations/percentage relative to background image\n      */\n      center.x=(MagickRealType) x_offset;\n      center.y=(MagickRealType) y_offset;\n      if (compose == DistortCompositeOp)\n        {\n          if ((flags & XValue) == 0)\n            if ((flags & AspectValue) != 0)\n              center.x=(MagickRealType) ((image->columns-1)/2.0);\n            else\n              center.x=(MagickRealType) (x_offset+(source_image->columns-1)/\n                2.0);\n          else\n            if ((flags & AspectValue) != 0)\n              center.x=geometry_info.xi;\n            else\n              center.x=(MagickRealType) (x_offset+geometry_info.xi);\n          if ((flags & YValue) == 0)\n            if ((flags & AspectValue) != 0)\n              center.y=(MagickRealType) ((image->rows-1)/2.0);\n            else\n              center.y=(MagickRealType) (y_offset+(source_image->rows-1)/2.0);\n          else\n            if ((flags & AspectValue) != 0)\n              center.y=geometry_info.psi;\n            else\n              center.y=(MagickRealType) (y_offset+geometry_info.psi);\n        }\n      /*\n        Shift the pixel offset point as defined by the provided,\n        displacement/distortion map.  -- Like a lens...\n      */\n      GetPixelInfo(image,&pixel);\n      image_view=AcquireVirtualCacheView(image,exception);\n      source_view=AcquireVirtualCacheView(source_image,exception);\n      canvas_view=AcquireAuthenticCacheView(canvas_image,exception);\n      for (y=0; y < (ssize_t) source_image->rows; y++)\n      {\n        MagickBooleanType\n          sync;\n\n        register const Quantum\n          *magick_restrict p;\n\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (((y+y_offset) < 0) || ((y+y_offset) >= (ssize_t) image->rows))\n          continue;\n        p=GetCacheViewVirtualPixels(source_view,0,y,source_image->columns,1,\n          exception);\n        q=QueueCacheViewAuthenticPixels(canvas_view,0,y,canvas_image->columns,1,\n          exception);\n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n          break;\n        for (x=0; x < (ssize_t) source_image->columns; x++)\n        {\n          if (((x_offset+x) < 0) || ((x_offset+x) >= (ssize_t) image->columns))\n            {\n              p+=GetPixelChannels(source_image);\n              continue;\n            }\n          /*\n            Displace the offset.\n          */\n          offset.x=(double) (horizontal_scale*(GetPixelRed(source_image,p)-\n            (((MagickRealType) QuantumRange+1.0)/2.0)))/(((MagickRealType)\n            QuantumRange+1.0)/2.0)+center.x+((compose == DisplaceCompositeOp) ?\n            x : 0);\n          offset.y=(double) (vertical_scale*(GetPixelGreen(source_image,p)-\n            (((MagickRealType) QuantumRange+1.0)/2.0)))/(((MagickRealType)\n            QuantumRange+1.0)/2.0)+center.y+((compose == DisplaceCompositeOp) ?\n            y : 0);\n          status=InterpolatePixelInfo(image,image_view,\n            UndefinedInterpolatePixel,(double) offset.x,(double) offset.y,\n            &pixel,exception);\n          if (status == MagickFalse)\n            break;\n          /*\n            Mask with the 'invalid pixel mask' in alpha channel.\n          */\n          pixel.alpha=(MagickRealType) QuantumRange*(QuantumScale*pixel.alpha)*\n            (QuantumScale*GetPixelAlpha(source_image,p));\n          SetPixelViaPixelInfo(canvas_image,&pixel,q);\n          p+=GetPixelChannels(source_image);\n          q+=GetPixelChannels(canvas_image);\n        }\n        if (x < (ssize_t) source_image->columns)\n          break;\n        sync=SyncCacheViewAuthenticPixels(canvas_view,exception);\n        if (sync == MagickFalse)\n          break;\n      }\n      canvas_view=DestroyCacheView(canvas_view);\n      source_view=DestroyCacheView(source_view);\n      image_view=DestroyCacheView(image_view);\n      source_image=DestroyImage(source_image);\n      source_image=canvas_image;\n      break;\n    }\n    case DissolveCompositeOp:\n    {\n      /*\n        Geometry arguments to dissolve factors.\n      */\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        {\n          flags=ParseGeometry(value,&geometry_info);\n          source_dissolve=geometry_info.rho/100.0;\n          canvas_dissolve=1.0;\n          if ((source_dissolve-MagickEpsilon) < 0.0)\n            source_dissolve=0.0;\n          if ((source_dissolve+MagickEpsilon) > 1.0)\n            {\n              canvas_dissolve=2.0-source_dissolve;\n              source_dissolve=1.0;\n            }\n          if ((flags & SigmaValue) != 0)\n            canvas_dissolve=geometry_info.sigma/100.0;\n          if ((canvas_dissolve-MagickEpsilon) < 0.0)\n            canvas_dissolve=0.0;\n        }\n      break;\n    }\n    case BlendCompositeOp:\n    {\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        {\n          flags=ParseGeometry(value,&geometry_info);\n          source_dissolve=geometry_info.rho/100.0;\n          canvas_dissolve=1.0-source_dissolve;\n          if ((flags & SigmaValue) != 0)\n            canvas_dissolve=geometry_info.sigma/100.0;\n        }\n      break;\n    }\n    case MathematicsCompositeOp:\n    {\n      /*\n        Just collect the values from \"compose:args\", setting.\n        Unused values are set to zero automagically.\n\n        Arguments are normally a comma separated list, so this probably should\n        be changed to some 'general comma list' parser, (with a minimum\n        number of values)\n      */\n      SetGeometryInfo(&geometry_info);\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        (void) ParseGeometry(value,&geometry_info);\n      break;\n    }\n    case ModulateCompositeOp:\n    {\n      /*\n        Determine the luma and chroma scale.\n      */\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        {\n          flags=ParseGeometry(value,&geometry_info);\n          percent_luma=geometry_info.rho;\n          if ((flags & SigmaValue) != 0)\n            percent_chroma=geometry_info.sigma;\n        }\n      break;\n    }\n    case ThresholdCompositeOp:\n    {\n      /*\n        Determine the amount and threshold.\n      */\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        {\n          flags=ParseGeometry(value,&geometry_info);\n          amount=geometry_info.rho;\n          threshold=geometry_info.sigma;\n          if ((flags & SigmaValue) == 0)\n            threshold=0.05f;\n        }\n      threshold*=QuantumRange;\n      break;\n    }\n    default:\n      break;\n  }\n  /*\n    Composite image.\n  */\n  status=MagickTrue;\n  progress=0;\n  midpoint=((MagickRealType) QuantumRange+1.0)/2;\n  source_view=AcquireVirtualCacheView(source_image,exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(source_image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const Quantum\n      *pixels;\n\n    MagickRealType\n      blue,\n      chroma,\n      green,\n      hue,\n      luma,\n      red;\n\n    PixelInfo\n      canvas_pixel,\n      source_pixel;\n\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    if (clip_to_self != MagickFalse)\n      {\n        if (y < y_offset)\n          continue;\n        if ((y-y_offset) >= (ssize_t) source_image->rows)\n          continue;\n      }\n    /*\n      If pixels is NULL, y is outside overlay region.\n    */\n    pixels=(Quantum *) NULL;\n    p=(Quantum *) NULL;\n    if ((y >= y_offset) && ((y-y_offset) < (ssize_t) source_image->rows))\n      {\n        p=GetCacheViewVirtualPixels(source_view,0,y-y_offset,\n          source_image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        pixels=p;\n        if (x_offset < 0)\n          p-=x_offset*GetPixelChannels(source_image);\n      }\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    hue=0.0;\n    chroma=0.0;\n    luma=0.0;\n    GetPixelInfo(image,&canvas_pixel);\n    GetPixelInfo(source_image,&source_pixel);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      MagickRealType\n        alpha,\n        Da,\n        Dc,\n        Dca,\n        DcaDa,\n        Sa,\n        SaSca,\n        Sc,\n        Sca;\n\n      register ssize_t\n        i;\n\n      size_t\n        channels;\n\n      if (clip_to_self != MagickFalse)\n        {\n          if (x < x_offset)\n            {\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          if ((x-x_offset) >= (ssize_t) source_image->columns)\n            break;\n        }\n      if ((pixels == (Quantum *) NULL) || (x < x_offset) ||\n          ((x-x_offset) >= (ssize_t) source_image->columns))\n        {\n          Quantum\n            source[MaxPixelChannels];\n\n          /*\n            Virtual composite:\n              Sc: source color.\n              Dc: canvas color.\n          */\n          (void) GetOneVirtualPixel(source_image,x-x_offset,y-y_offset,source,\n            exception);\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            MagickRealType\n              pixel;\n\n            PixelChannel channel = GetPixelChannelChannel(image,i);\n            PixelTrait traits = GetPixelChannelTraits(image,channel);\n            PixelTrait source_traits=GetPixelChannelTraits(source_image,\n              channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (source_traits == UndefinedPixelTrait))\n              continue;\n            switch (compose)\n            {\n              case AlphaCompositeOp:\n              case ChangeMaskCompositeOp:\n              case CopyAlphaCompositeOp:\n              case DstAtopCompositeOp:\n              case DstInCompositeOp:\n              case InCompositeOp:\n              case OutCompositeOp:\n              case SrcInCompositeOp:\n              case SrcOutCompositeOp:\n              {\n                if (channel == AlphaPixelChannel)\n                  pixel=(MagickRealType) TransparentAlpha;\n                else\n                  pixel=(MagickRealType) q[i];\n                break;\n              }\n              case ClearCompositeOp:\n              case CopyCompositeOp:\n              case ReplaceCompositeOp:\n              case SrcCompositeOp:\n              {\n                if (channel == AlphaPixelChannel)\n                  pixel=(MagickRealType) TransparentAlpha;\n                else\n                  pixel=0.0;\n                break;\n              }\n              case BlendCompositeOp:\n              case DissolveCompositeOp:\n              {\n                if (channel == AlphaPixelChannel)\n                  pixel=canvas_dissolve*GetPixelAlpha(source_image,source);\n                else\n                  pixel=(MagickRealType) source[channel];\n                break;\n              }\n              default:\n              {\n                pixel=(MagickRealType) source[channel];\n                break;\n              }\n            }\n            q[i]=clamp != MagickFalse ? ClampPixel(pixel) :\n              ClampToQuantum(pixel);\n          }\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      /*\n        Authentic composite:\n          Sa:  normalized source alpha.\n          Da:  normalized canvas alpha.\n      */\n      Sa=QuantumScale*GetPixelAlpha(source_image,p);\n      Da=QuantumScale*GetPixelAlpha(image,q);\n      switch (compose)\n      {\n        case BumpmapCompositeOp:\n        {\n          alpha=GetPixelIntensity(source_image,p)*Sa;\n          break;\n        }\n        case ColorBurnCompositeOp:\n        case ColorDodgeCompositeOp:\n        case DarkenCompositeOp:\n        case DifferenceCompositeOp:\n        case DivideDstCompositeOp:\n        case DivideSrcCompositeOp:\n        case ExclusionCompositeOp:\n        case HardLightCompositeOp:\n        case HardMixCompositeOp:\n        case LinearBurnCompositeOp:\n        case LinearDodgeCompositeOp:\n        case LinearLightCompositeOp:\n        case LightenCompositeOp:\n        case MathematicsCompositeOp:\n        case MinusDstCompositeOp:\n        case MinusSrcCompositeOp:\n        case ModulusAddCompositeOp:\n        case ModulusSubtractCompositeOp:\n        case MultiplyCompositeOp:\n        case OverlayCompositeOp:\n        case PegtopLightCompositeOp:\n        case PinLightCompositeOp:\n        case ScreenCompositeOp:\n        case SoftLightCompositeOp:\n        case VividLightCompositeOp:\n        {\n          alpha=RoundToUnity(Sa+Da-Sa*Da);\n          break;\n        }\n        case DstAtopCompositeOp:\n        case DstInCompositeOp:\n        case InCompositeOp:\n        case SrcInCompositeOp:\n        {\n          alpha=Sa*Da;\n          break;\n        }\n        case DissolveCompositeOp:\n        {\n          alpha=source_dissolve*Sa*(-canvas_dissolve*Da)+source_dissolve*Sa+\n            canvas_dissolve*Da;\n          break;\n        }\n        case DstOverCompositeOp:\n        case OverCompositeOp:\n        case SrcOverCompositeOp:\n        {\n          alpha=Sa+Da-Sa*Da;\n          break;\n        }\n        case DstOutCompositeOp:\n        {\n          alpha=Da*(1.0-Sa);\n          break;\n        }\n        case OutCompositeOp:\n        case SrcOutCompositeOp:\n        {\n          alpha=Sa*(1.0-Da);\n          break;\n        }\n        case BlendCompositeOp:\n        case PlusCompositeOp:\n        {\n          alpha=RoundToUnity(source_dissolve*Sa+canvas_dissolve*Da);\n          break;\n        }\n        case XorCompositeOp:\n        {\n          alpha=Sa+Da-2.0*Sa*Da;\n          break;\n        }\n        default:\n        {\n          alpha=1.0;\n          break;\n        }\n      }\n      switch (compose)\n      {\n        case ColorizeCompositeOp:\n        case HueCompositeOp:\n        case LuminizeCompositeOp:\n        case ModulateCompositeOp:\n        case SaturateCompositeOp:\n        {\n          GetPixelInfoPixel(source_image,p,&source_pixel);\n          GetPixelInfoPixel(image,q,&canvas_pixel);\n          break;\n        }\n        default:\n          break;\n      }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        MagickRealType\n          pixel,\n          sans;\n\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        PixelTrait source_traits = GetPixelChannelTraits(source_image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if ((channel == AlphaPixelChannel) &&\n            ((traits & UpdatePixelTrait) != 0))\n          {\n            /*\n              Set alpha channel.\n            */\n            switch (compose)\n            {\n              case AlphaCompositeOp:\n              {\n                pixel=QuantumRange*Sa;\n                break;\n              }\n              case AtopCompositeOp:\n              case CopyBlackCompositeOp:\n              case CopyBlueCompositeOp:\n              case CopyCyanCompositeOp:\n              case CopyGreenCompositeOp:\n              case CopyMagentaCompositeOp:\n              case CopyRedCompositeOp:\n              case CopyYellowCompositeOp:\n              case SrcAtopCompositeOp:\n              case DstCompositeOp:\n              case NoCompositeOp:\n              {\n                pixel=QuantumRange*Da;\n                break;\n              }\n              case ChangeMaskCompositeOp:\n              {\n                MagickBooleanType\n                  equivalent;\n\n                if (Da < 0.5)\n                  {\n                    pixel=(MagickRealType) TransparentAlpha;\n                    break;\n                  }\n                equivalent=IsFuzzyEquivalencePixel(source_image,p,image,q);\n                if (equivalent != MagickFalse)\n                  pixel=(MagickRealType) TransparentAlpha;\n                else\n                  pixel=(MagickRealType) OpaqueAlpha;\n                break;\n              }\n              case ClearCompositeOp:\n              {\n                pixel=(MagickRealType) TransparentAlpha;\n                break;\n              }\n              case ColorizeCompositeOp:\n              case HueCompositeOp:\n              case LuminizeCompositeOp:\n              case SaturateCompositeOp:\n              {\n                if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n                  {\n                    pixel=QuantumRange*Da;\n                    break;\n                  }\n                if (fabs((double) (QuantumRange*Da-TransparentAlpha)) < MagickEpsilon)\n                  {\n                    pixel=QuantumRange*Sa;\n                    break;\n                  }\n                if (Sa < Da)\n                  {\n                    pixel=QuantumRange*Da;\n                    break;\n                  }\n                pixel=QuantumRange*Sa;\n                break;\n              }\n              case CopyAlphaCompositeOp:\n              {\n                if (source_image->alpha_trait == UndefinedPixelTrait)\n                  pixel=GetPixelIntensity(source_image,p);\n                else\n                  pixel=QuantumRange*Sa;\n                break;\n              }\n              case CopyCompositeOp:\n              case DisplaceCompositeOp:\n              case DistortCompositeOp:\n              case DstAtopCompositeOp:\n              case ReplaceCompositeOp:\n              case SrcCompositeOp:\n              {\n                pixel=QuantumRange*Sa;\n                break;\n              }\n              case DarkenIntensityCompositeOp:\n              {\n                pixel=Sa*GetPixelIntensity(source_image,p) <\n                  Da*GetPixelIntensity(image,q) ? Sa : Da;\n                break;\n              }\n              case DifferenceCompositeOp:\n              {\n                pixel=QuantumRange*fabs(Sa-Da);\n                break;\n              }\n              case LightenIntensityCompositeOp:\n              {\n                pixel=Sa*GetPixelIntensity(source_image,p) >\n                  Da*GetPixelIntensity(image,q) ? Sa : Da;\n                break;\n              }\n              case ModulateCompositeOp:\n              {\n                pixel=QuantumRange*Da;\n                break;\n              }\n              case MultiplyCompositeOp:\n              {\n                pixel=QuantumRange*Sa*Da;\n                break;\n              }\n              case StereoCompositeOp:\n              {\n                pixel=QuantumRange*(Sa+Da)/2;\n                break;\n              }\n              default:\n              {\n                pixel=QuantumRange*alpha;\n                break;\n              }\n            }\n            q[i]=clamp != MagickFalse ? ClampPixel(pixel) :\n              ClampToQuantum(pixel);\n            continue;\n          }\n        if (source_traits == UndefinedPixelTrait)\n          continue;\n        /*\n          Sc: source color.\n          Dc: canvas color.\n        */\n        Sc=(MagickRealType) GetPixelChannel(source_image,channel,p);\n        Dc=(MagickRealType) q[i];\n        if ((traits & CopyPixelTrait) != 0)\n          {\n            /*\n              Copy channel.\n            */\n            q[i]=ClampToQuantum(Dc);\n            continue;\n          }\n        /*\n          Porter-Duff compositions:\n            Sca: source normalized color multiplied by alpha.\n            Dca: normalized canvas color multiplied by alpha.\n        */\n        Sca=QuantumScale*Sa*Sc;\n        Dca=QuantumScale*Da*Dc;\n        SaSca=Sa*PerceptibleReciprocal(Sca);\n        DcaDa=Dca*PerceptibleReciprocal(Da);\n        switch (compose)\n        {\n          case DarkenCompositeOp:\n          case LightenCompositeOp:\n          case ModulusSubtractCompositeOp:\n          {\n            gamma=PerceptibleReciprocal(1.0-alpha);\n            break;\n          }\n          default:\n          {\n            gamma=PerceptibleReciprocal(alpha);\n            break;\n          }\n        }\n        pixel=Dc;\n        switch (compose)\n        {\n          case AlphaCompositeOp:\n          {\n            pixel=QuantumRange*Sa;\n            break;\n          }\n          case AtopCompositeOp:\n          case SrcAtopCompositeOp:\n          {\n            pixel=QuantumRange*(Sca*Da+Dca*(1.0-Sa));\n            break;\n          }\n          case BlendCompositeOp:\n          {\n            pixel=gamma*(source_dissolve*Sa*Sc+canvas_dissolve*Da*Dc);\n            break;\n          }\n          case BlurCompositeOp:\n          case CopyCompositeOp:\n          case ReplaceCompositeOp:\n          case SrcCompositeOp:\n          {\n            pixel=QuantumRange*Sca;\n            break;\n          }\n          case DisplaceCompositeOp:\n          case DistortCompositeOp:\n          {\n            pixel=Sc;\n            break;\n          }\n          case BumpmapCompositeOp:\n          {\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            pixel=QuantumScale*GetPixelIntensity(source_image,p)*Dc;\n            break;\n          }\n          case ChangeMaskCompositeOp:\n          {\n            pixel=Dc;\n            break;\n          }\n          case ClearCompositeOp:\n          {\n            pixel=0.0;\n            break;\n          }\n          case ColorBurnCompositeOp:\n          {\n            if ((Sca == 0.0) && (Dca == Da))\n              {\n                pixel=QuantumRange*gamma*(Sa*Da+Dca*(1.0-Sa));\n                break;\n              }\n            if (Sca == 0.0)\n              {\n                pixel=QuantumRange*gamma*(Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*gamma*(Sa*Da-Sa*Da*MagickMin(1.0,(1.0-DcaDa)*\n              SaSca)+Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case ColorDodgeCompositeOp:\n          {\n            if ((Sca*Da+Dca*Sa) >= Sa*Da)\n              pixel=QuantumRange*gamma*(Sa*Da+Sca*(1.0-Da)+Dca*(1.0-Sa));\n            else\n              pixel=QuantumRange*gamma*(Dca*Sa*Sa*PerceptibleReciprocal(Sa-Sca)+\n                Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case ColorizeCompositeOp:\n          {\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            if (fabs((double) (QuantumRange*Da-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Sc;\n                break;\n              }\n            CompositeHCL(canvas_pixel.red,canvas_pixel.green,canvas_pixel.blue,\n              &sans,&sans,&luma);\n            CompositeHCL(source_pixel.red,source_pixel.green,source_pixel.blue,\n              &hue,&chroma,&sans);\n            HCLComposite(hue,chroma,luma,&red,&green,&blue);\n            switch (channel)\n            {\n              case RedPixelChannel: pixel=red; break;\n              case GreenPixelChannel: pixel=green; break;\n              case BluePixelChannel: pixel=blue; break;\n              default: pixel=Dc; break;\n            }\n            break;\n          }\n          case CopyAlphaCompositeOp:\n          {\n            pixel=Dc;\n            break;\n          }\n          case CopyBlackCompositeOp:\n          {\n            if (channel == BlackPixelChannel)\n              pixel=(MagickRealType) (QuantumRange-\n                GetPixelBlack(source_image,p));\n            break;\n          }\n          case CopyBlueCompositeOp:\n          case CopyYellowCompositeOp:\n          {\n            if (channel == BluePixelChannel)\n              pixel=(MagickRealType) GetPixelBlue(source_image,p);\n            break;\n          }\n          case CopyGreenCompositeOp:\n          case CopyMagentaCompositeOp:\n          {\n            if (channel == GreenPixelChannel)\n              pixel=(MagickRealType) GetPixelGreen(source_image,p);\n            break;\n          }\n          case CopyRedCompositeOp:\n          case CopyCyanCompositeOp:\n          {\n            if (channel == RedPixelChannel)\n              pixel=(MagickRealType) GetPixelRed(source_image,p);\n            break;\n          }\n          case DarkenCompositeOp:\n          {\n            /*\n              Darken is equivalent to a 'Minimum' method\n                OR a greyscale version of a binary 'Or'\n                OR the 'Intersection' of pixel sets.\n            */\n            if ((Sca*Da) < (Dca*Sa))\n              {\n                pixel=QuantumRange*(Sca+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Dca+Sca*(1.0-Da));\n            break;\n          }\n          case DarkenIntensityCompositeOp:\n          {\n            pixel=Sa*GetPixelIntensity(source_image,p) <\n              Da*GetPixelIntensity(image,q) ? Sc : Dc;\n            break;\n          }\n          case DifferenceCompositeOp:\n          {\n            pixel=QuantumRange*gamma*(Sca+Dca-2.0*MagickMin(Sca*Da,Dca*Sa));\n            break;\n          }\n          case DissolveCompositeOp:\n          {\n            pixel=gamma*(source_dissolve*Sa*Sc-source_dissolve*Sa*\n              canvas_dissolve*Da*Dc+canvas_dissolve*Da*Dc);\n            break;\n          }\n          case DivideDstCompositeOp:\n          {\n            if ((fabs((double) Sca) < MagickEpsilon) &&\n                (fabs((double) Dca) < MagickEpsilon))\n              {\n                pixel=QuantumRange*gamma*(Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            if (fabs((double) Dca) < MagickEpsilon)\n              {\n                pixel=QuantumRange*gamma*(Sa*Da+Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*gamma*(Sca*Da*Da/Dca+Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case DivideSrcCompositeOp:\n          {\n            if ((fabs((double) Dca) < MagickEpsilon) &&\n                (fabs((double) Sca) < MagickEpsilon))\n              {\n                pixel=QuantumRange*gamma*(Dca*(1.0-Sa)+Sca*(1.0-Da));\n                break;\n              }\n            if (fabs((double) Sca) < MagickEpsilon)\n              {\n                pixel=QuantumRange*gamma*(Da*Sa+Dca*(1.0-Sa)+Sca*(1.0-Da));\n                break;\n              }\n            pixel=QuantumRange*gamma*(Dca*Sa*SaSca+Dca*(1.0-Sa)+Sca*(1.0-Da));\n            break;\n          }\n          case DstAtopCompositeOp:\n          {\n            pixel=QuantumRange*(Dca*Sa+Sca*(1.0-Da));\n            break;\n          }\n          case DstCompositeOp:\n          case NoCompositeOp:\n          {\n            pixel=QuantumRange*Dca;\n            break;\n          }\n          case DstInCompositeOp:\n          {\n            pixel=QuantumRange*(Dca*Sa);\n            break;\n          }\n          case DstOutCompositeOp:\n          {\n            pixel=QuantumRange*(Dca*(1.0-Sa));\n            break;\n          }\n          case DstOverCompositeOp:\n          {\n            pixel=QuantumRange*gamma*(Dca+Sca*(1.0-Da));\n            break;\n          }\n          case ExclusionCompositeOp:\n          {\n            pixel=QuantumRange*gamma*(Sca*Da+Dca*Sa-2.0*Sca*Dca+Sca*(1.0-Da)+\n              Dca*(1.0-Sa));\n            break;\n          }\n          case HardLightCompositeOp:\n          {\n            if ((2.0*Sca) < Sa)\n              {\n                pixel=QuantumRange*gamma*(2.0*Sca*Dca+Sca*(1.0-Da)+Dca*(1.0-\n                  Sa));\n                break;\n              }\n            pixel=QuantumRange*gamma*(Sa*Da-2.0*(Da-Dca)*(Sa-Sca)+Sca*(1.0-Da)+\n              Dca*(1.0-Sa));\n            break;\n          }\n          case HardMixCompositeOp:\n          {\n            pixel=gamma*(((Sca+Dca) < 1.0) ? 0.0 : QuantumRange);\n            break;\n          }\n          case HueCompositeOp:\n          {\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            if (fabs((double) (QuantumRange*Da-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Sc;\n                break;\n              }\n            CompositeHCL(canvas_pixel.red,canvas_pixel.green,canvas_pixel.blue,\n              &hue,&chroma,&luma);\n            CompositeHCL(source_pixel.red,source_pixel.green,source_pixel.blue,\n              &hue,&sans,&sans);\n            HCLComposite(hue,chroma,luma,&red,&green,&blue);\n            switch (channel)\n            {\n              case RedPixelChannel: pixel=red; break;\n              case GreenPixelChannel: pixel=green; break;\n              case BluePixelChannel: pixel=blue; break;\n              default: pixel=Dc; break;\n            }\n            break;\n          }\n          case InCompositeOp:\n          case SrcInCompositeOp:\n          {\n            pixel=QuantumRange*(Sca*Da);\n            break;\n          }\n          case LinearBurnCompositeOp:\n          {\n            /*\n              LinearBurn: as defined by Abode Photoshop, according to\n              http://www.simplefilter.de/en/basics/mixmods.html is:\n\n                f(Sc,Dc) = Sc + Dc - 1\n            */\n            pixel=QuantumRange*gamma*(Sca+Dca-Sa*Da);\n            break;\n          }\n          case LinearDodgeCompositeOp:\n          {\n            pixel=gamma*(Sa*Sc+Da*Dc);\n            break;\n          }\n          case LinearLightCompositeOp:\n          {\n            /*\n              LinearLight: as defined by Abode Photoshop, according to\n              http://www.simplefilter.de/en/basics/mixmods.html is:\n\n                f(Sc,Dc) = Dc + 2*Sc - 1\n            */\n            pixel=QuantumRange*gamma*((Sca-Sa)*Da+Sca+Dca);\n            break;\n          }\n          case LightenCompositeOp:\n          {\n            if ((Sca*Da) > (Dca*Sa))\n              {\n                pixel=QuantumRange*(Sca+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Dca+Sca*(1.0-Da));\n            break;\n          }\n          case LightenIntensityCompositeOp:\n          {\n            /*\n              Lighten is equivalent to a 'Maximum' method\n                OR a greyscale version of a binary 'And'\n                OR the 'Union' of pixel sets.\n            */\n            pixel=Sa*GetPixelIntensity(source_image,p) >\n              Da*GetPixelIntensity(image,q) ? Sc : Dc;\n            break;\n          }\n          case LuminizeCompositeOp:\n          {\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            if (fabs((double) (QuantumRange*Da-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Sc;\n                break;\n              }\n            CompositeHCL(canvas_pixel.red,canvas_pixel.green,canvas_pixel.blue,\n              &hue,&chroma,&luma);\n            CompositeHCL(source_pixel.red,source_pixel.green,source_pixel.blue,\n              &sans,&sans,&luma);\n            HCLComposite(hue,chroma,luma,&red,&green,&blue);\n            switch (channel)\n            {\n              case RedPixelChannel: pixel=red; break;\n              case GreenPixelChannel: pixel=green; break;\n              case BluePixelChannel: pixel=blue; break;\n              default: pixel=Dc; break;\n            }\n            break;\n          }\n          case MathematicsCompositeOp:\n          {\n            /*\n              'Mathematics' a free form user control mathematical composition\n              is defined as...\n\n                f(Sc,Dc) = A*Sc*Dc + B*Sc + C*Dc + D\n\n              Where the arguments A,B,C,D are (currently) passed to composite\n              as a command separated 'geometry' string in \"compose:args\" image\n              artifact.\n\n                 A = a->rho,   B = a->sigma,  C = a->xi,  D = a->psi\n\n              Applying the SVG transparency formula (see above), we get...\n\n               Dca' = Sa*Da*f(Sc,Dc) + Sca*(1.0-Da) + Dca*(1.0-Sa)\n\n               Dca' = A*Sca*Dca + B*Sca*Da + C*Dca*Sa + D*Sa*Da + Sca*(1.0-Da) +\n                 Dca*(1.0-Sa)\n            */\n            pixel=QuantumRange*gamma*(geometry_info.rho*Sca*Dca+\n              geometry_info.sigma*Sca*Da+geometry_info.xi*Dca*Sa+\n              geometry_info.psi*Sa*Da+Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case MinusDstCompositeOp:\n          {\n            pixel=gamma*(Sa*Sc+Da*Dc-2.0*Da*Dc*Sa);\n            break;\n          }\n          case MinusSrcCompositeOp:\n          {\n            /*\n              Minus source from canvas.\n\n                f(Sc,Dc) = Sc - Dc\n            */\n            pixel=gamma*(Da*Dc+Sa*Sc-2.0*Sa*Sc*Da);\n            break;\n          }\n          case ModulateCompositeOp:\n          {\n            ssize_t\n              offset;\n\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            offset=(ssize_t) (GetPixelIntensity(source_image,p)-midpoint);\n            if (offset == 0)\n              {\n                pixel=Dc;\n                break;\n              }\n            CompositeHCL(canvas_pixel.red,canvas_pixel.green,canvas_pixel.blue,\n              &hue,&chroma,&luma);\n            luma+=(0.01*percent_luma*offset)/midpoint;\n            chroma*=0.01*percent_chroma;\n            HCLComposite(hue,chroma,luma,&red,&green,&blue);\n            switch (channel)\n            {\n              case RedPixelChannel: pixel=red; break;\n              case GreenPixelChannel: pixel=green; break;\n              case BluePixelChannel: pixel=blue; break;\n              default: pixel=Dc; break;\n            }\n            break;\n          }\n          case ModulusAddCompositeOp:\n          {\n            pixel=Sc+Dc;\n            while (pixel > QuantumRange)\n              pixel-=QuantumRange;\n            while (pixel < 0.0)\n              pixel+=QuantumRange;\n            pixel=(Sa*Da*pixel+Sa*Sc*(1.0-Da)+Da*Dc*(1.0-Sa));\n            break;\n          }\n          case ModulusSubtractCompositeOp:\n          {\n            pixel=Sc-Dc;\n            while (pixel > QuantumRange)\n              pixel-=QuantumRange;\n            while (pixel < 0.0)\n              pixel+=QuantumRange;\n            pixel=(Sa*Da*pixel+Sa*Sc*(1.0-Da)+Da*Dc*(1.0-Sa));\n            break;\n          }\n          case MultiplyCompositeOp:\n          {\n            pixel=QuantumRange*gamma*(Sca*Dca+Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case OutCompositeOp:\n          case SrcOutCompositeOp:\n          {\n            pixel=QuantumRange*(Sca*(1.0-Da));\n            break;\n          }\n          case OverCompositeOp:\n          case SrcOverCompositeOp:\n          {\n            pixel=QuantumRange*gamma*(Sca+Dca*(1.0-Sa));\n            break;\n          }\n          case OverlayCompositeOp:\n          {\n            if ((2.0*Dca) < Da)\n              {\n                pixel=QuantumRange*gamma*(2.0*Dca*Sca+Dca*(1.0-Sa)+Sca*(1.0-\n                  Da));\n                break;\n              }\n            pixel=QuantumRange*gamma*(Da*Sa-2.0*(Sa-Sca)*(Da-Dca)+Dca*(1.0-Sa)+\n              Sca*(1.0-Da));\n            break;\n          }\n          case PegtopLightCompositeOp:\n          {\n            /*\n              PegTop: A Soft-Light alternative: A continuous version of the\n              Softlight function, producing very similar results.\n\n                f(Sc,Dc) = Dc^2*(1-2*Sc) + 2*Sc*Dc\n\n              http://www.pegtop.net/delphi/articles/blendmodes/softlight.htm.\n            */\n            if (fabs((double) Da) < MagickEpsilon)\n              {\n                pixel=QuantumRange*gamma*(Sca);\n                break;\n              }\n            pixel=QuantumRange*gamma*(Dca*Dca*(Sa-2.0*Sca)/Da+Sca*(2.0*Dca+1.0-\n              Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case PinLightCompositeOp:\n          {\n            /*\n              PinLight: A Photoshop 7 composition method\n              http://www.simplefilter.de/en/basics/mixmods.html\n\n                f(Sc,Dc) = Dc<2*Sc-1 ? 2*Sc-1 : Dc>2*Sc   ? 2*Sc : Dc\n            */\n            if ((Dca*Sa) < (Da*(2.0*Sca-Sa)))\n              {\n                pixel=QuantumRange*gamma*(Sca*(Da+1.0)-Sa*Da+Dca*(1.0-Sa));\n                break;\n              }\n            if ((Dca*Sa) > (2.0*Sca*Da))\n              {\n                pixel=QuantumRange*gamma*(Sca*Da+Sca+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*gamma*(Sca*(1.0-Da)+Dca);\n            break;\n          }\n          case PlusCompositeOp:\n          {\n            pixel=QuantumRange*(Sca+Dca);\n            break;\n          }\n          case SaturateCompositeOp:\n          {\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            if (fabs((double) (QuantumRange*Da-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Sc;\n                break;\n              }\n            CompositeHCL(canvas_pixel.red,canvas_pixel.green,canvas_pixel.blue,\n              &hue,&chroma,&luma);\n            CompositeHCL(source_pixel.red,source_pixel.green,source_pixel.blue,\n              &sans,&chroma,&sans);\n            HCLComposite(hue,chroma,luma,&red,&green,&blue);\n            switch (channel)\n            {\n              case RedPixelChannel: pixel=red; break;\n              case GreenPixelChannel: pixel=green; break;\n              case BluePixelChannel: pixel=blue; break;\n              default: pixel=Dc; break;\n            }\n            break;\n          }\n          case ScreenCompositeOp:\n          {\n            /*\n              Screen:  a negated multiply:\n\n                f(Sc,Dc) = 1.0-(1.0-Sc)*(1.0-Dc)\n            */\n            pixel=QuantumRange*gamma*(Sca+Dca-Sca*Dca);\n            break;\n          }\n          case SoftLightCompositeOp:\n          {\n            if ((2.0*Sca) < Sa)\n              {\n                pixel=QuantumRange*gamma*(Dca*(Sa+(2.0*Sca-Sa)*(1.0-DcaDa))+\n                  Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            if (((2.0*Sca) > Sa) && ((4.0*Dca) <= Da))\n              {\n                pixel=QuantumRange*gamma*(Dca*Sa+Da*(2.0*Sca-Sa)*(4.0*DcaDa*\n                  (4.0*DcaDa+1.0)*(DcaDa-1.0)+7.0*DcaDa)+Sca*(1.0-Da)+\n                  Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*gamma*(Dca*Sa+Da*(2.0*Sca-Sa)*(pow(DcaDa,0.5)-\n              DcaDa)+Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case StereoCompositeOp:\n          {\n            if (channel == RedPixelChannel)\n              pixel=(MagickRealType) GetPixelRed(source_image,p);\n            break;\n          }\n          case ThresholdCompositeOp:\n          {\n            MagickRealType\n              delta;\n\n            delta=Sc-Dc;\n            if ((MagickRealType) fabs((double) (2.0*delta)) < threshold)\n              {\n                pixel=gamma*Dc;\n                break;\n              }\n            pixel=gamma*(Dc+delta*amount);\n            break;\n          }\n          case VividLightCompositeOp:\n          {\n            /*\n              VividLight: A Photoshop 7 composition method.  See\n              http://www.simplefilter.de/en/basics/mixmods.html.\n\n                f(Sc,Dc) = (2*Sc < 1) ? 1-(1-Dc)/(2*Sc) : Dc/(2*(1-Sc))\n            */\n            if ((fabs((double) Sa) < MagickEpsilon) ||\n                (fabs((double) (Sca-Sa)) < MagickEpsilon))\n              {\n                pixel=QuantumRange*gamma*(Sa*Da+Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            if ((2.0*Sca) <= Sa)\n              {\n                pixel=QuantumRange*gamma*(Sa*(Da+Sa*(Dca-Da)*\n                  PerceptibleReciprocal(2.0*Sca))+Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*gamma*(Dca*Sa*Sa*PerceptibleReciprocal(2.0*\n              (Sa-Sca))+Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case XorCompositeOp:\n          {\n            pixel=QuantumRange*(Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          default:\n          {\n            pixel=Sc;\n            break;\n          }\n        }\n        q[i]=clamp != MagickFalse ? ClampPixel(pixel) : ClampToQuantum(pixel);\n      }\n      p+=GetPixelChannels(source_image);\n      channels=GetPixelChannels(source_image);\n      if (p >= (pixels+channels*source_image->columns))\n        p=pixels;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,CompositeImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  source_view=DestroyCacheView(source_view);\n  image_view=DestroyCacheView(image_view);\n  if (canvas_image != (Image * ) NULL)\n    canvas_image=DestroyImage(canvas_image);\n  else\n    source_image=DestroyImage(source_image);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     T e x t u r e I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TextureImage() repeatedly tiles the texture image across and down the image\n%  canvas.\n%\n%  The format of the TextureImage method is:\n%\n%      MagickBooleanType TextureImage(Image *image,const Image *texture,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o texture_image: This image is the texture to layer on the background.\n%\n*/\nMagickExport MagickBooleanType TextureImage(Image *image,const Image *texture,\n  ExceptionInfo *exception)\n{\n#define TextureImageTag  \"Texture/Image\"\n\n  CacheView\n    *image_view,\n    *texture_view;\n\n  Image\n    *texture_image;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  if (texture == (const Image *) NULL)\n    return(MagickFalse);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  texture_image=CloneImage(texture,0,0,MagickTrue,exception);\n  if (texture_image == (const Image *) NULL)\n    return(MagickFalse);\n  (void) TransformImageColorspace(texture_image,image->colorspace,exception);\n  (void) SetImageVirtualPixelMethod(texture_image,TileVirtualPixelMethod,\n    exception);\n  status=MagickTrue;\n  if ((image->compose != CopyCompositeOp) &&\n      ((image->compose != OverCompositeOp) ||\n       (image->alpha_trait != UndefinedPixelTrait) ||\n       (texture_image->alpha_trait != UndefinedPixelTrait)))\n    {\n      /*\n        Tile texture onto the image background.\n      */\n      for (y=0; y < (ssize_t) image->rows; y+=(ssize_t) texture_image->rows)\n      {\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        for (x=0; x < (ssize_t) image->columns; x+=(ssize_t) texture_image->columns)\n        {\n          MagickBooleanType\n            thread_status;\n\n          thread_status=CompositeImage(image,texture_image,image->compose,\n            MagickTrue,x+texture_image->tile_offset.x,y+\n            texture_image->tile_offset.y,exception);\n          if (thread_status == MagickFalse)\n            {\n              status=thread_status;\n              break;\n            }\n        }\n        if (image->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n            proceed=SetImageProgress(image,TextureImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n      (void) SetImageProgress(image,TextureImageTag,(MagickOffsetType)\n        image->rows,image->rows);\n      texture_image=DestroyImage(texture_image);\n      return(status);\n    }\n  /*\n    Tile texture onto the image background (optimized).\n  */\n  status=MagickTrue;\n  texture_view=AcquireVirtualCacheView(texture_image,exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(texture_image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    MagickBooleanType\n      sync;\n\n    register const Quantum\n      *p,\n      *pixels;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *q;\n\n    size_t\n      width;\n\n    if (status == MagickFalse)\n      continue;\n    pixels=GetCacheViewVirtualPixels(texture_view,texture_image->tile_offset.x,\n      (y+texture_image->tile_offset.y) % texture_image->rows,\n      texture_image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if ((pixels == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x+=(ssize_t) texture_image->columns)\n    {\n      register ssize_t\n        j;\n\n      p=pixels;\n      width=texture_image->columns;\n      if ((x+(ssize_t) width) > (ssize_t) image->columns)\n        width=image->columns-x;\n      for (j=0; j < (ssize_t) width; j++)\n      {\n        register ssize_t\n          i;\n\n        for (i=0; i < (ssize_t) GetPixelChannels(texture_image); i++)\n        {\n          PixelChannel channel = GetPixelChannelChannel(texture_image,i);\n          PixelTrait traits = GetPixelChannelTraits(image,channel);\n          PixelTrait texture_traits=GetPixelChannelTraits(texture_image,\n            channel);\n          if ((traits == UndefinedPixelTrait) ||\n              (texture_traits == UndefinedPixelTrait))\n            continue;\n          SetPixelChannel(image,channel,p[i],q);\n        }\n        p+=GetPixelChannels(texture_image);\n        q+=GetPixelChannels(image);\n      }\n    }\n    sync=SyncCacheViewAuthenticPixels(image_view,exception);\n    if (sync == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n        proceed=SetImageProgress(image,TextureImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  texture_view=DestroyCacheView(texture_view);\n  image_view=DestroyCacheView(image_view);\n  texture_image=DestroyImage(texture_image);\n  return(status);\n}\n"], "filenames": ["MagickCore/composite.c"], "buggy_code_start_loc": [659], "buggy_code_end_loc": [671], "fixing_code_start_loc": [659], "fixing_code_end_loc": [672], "type": "CWE-125", "message": "ImageMagick 7.0.8-50 Q16 has a heap-based buffer over-read in MagickCore/composite.c in CompositeImage.", "other": {"cve": {"id": "CVE-2019-13303", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-05T01:15:10.437", "lastModified": "2023-03-02T15:56:59.943", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick 7.0.8-50 Q16 has a heap-based buffer over-read in MagickCore/composite.c in CompositeImage."}, {"lang": "es", "value": "ImageMagick versi\u00f3n 7.0.8-50 Q16 tiene una sobrelectura de b\u00fafer basada en memoria din\u00e1mica (heap) en MagickCore/composite.c en CompositeImage."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.8-50:q16:*:*:*:*:*:*", "matchCriteriaId": "25CCEA99-8329-46C6-9625-4FE15F24CF69"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00069.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/d29148fae06c01ef215940e084cf41853c117bab", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1603", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/d29148fae06c01ef215940e084cf41853c117bab"}}