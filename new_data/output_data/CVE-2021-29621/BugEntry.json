{"buggy_code": ["import base64\nimport datetime\nimport json\nimport logging\nimport re\nfrom typing import Dict, List, Set, Tuple\n\nfrom flask import g, session, url_for\nfrom flask_babel import lazy_gettext as _\nfrom flask_jwt_extended import current_user as current_user_jwt\nfrom flask_jwt_extended import JWTManager\nfrom flask_login import current_user, LoginManager\nfrom werkzeug.security import check_password_hash, generate_password_hash\n\nfrom .api import SecurityApi\nfrom .registerviews import (\n    RegisterUserDBView,\n    RegisterUserOAuthView,\n    RegisterUserOIDView,\n)\nfrom .views import (\n    AuthDBView,\n    AuthLDAPView,\n    AuthOAuthView,\n    AuthOIDView,\n    AuthRemoteUserView,\n    PermissionModelView,\n    PermissionViewModelView,\n    RegisterUserModelView,\n    ResetMyPasswordView,\n    ResetPasswordView,\n    RoleModelView,\n    UserDBModelView,\n    UserInfoEditView,\n    UserLDAPModelView,\n    UserOAuthModelView,\n    UserOIDModelView,\n    UserRemoteUserModelView,\n    UserStatsChartView,\n    ViewMenuModelView,\n)\nfrom ..basemanager import BaseManager\nfrom ..const import (\n    AUTH_DB,\n    AUTH_LDAP,\n    AUTH_OAUTH,\n    AUTH_OID,\n    AUTH_REMOTE_USER,\n    LOGMSG_ERR_SEC_ADD_REGISTER_USER,\n    LOGMSG_ERR_SEC_AUTH_LDAP,\n    LOGMSG_ERR_SEC_AUTH_LDAP_TLS,\n    LOGMSG_WAR_SEC_LOGIN_FAILED,\n    LOGMSG_WAR_SEC_NO_USER,\n    LOGMSG_WAR_SEC_NOLDAP_OBJ,\n    PERMISSION_PREFIX,\n)\n\nlog = logging.getLogger(__name__)\n\n\nclass AbstractSecurityManager(BaseManager):\n    \"\"\"\n        Abstract SecurityManager class, declares all methods used by the\n        framework. There is no assumptions about security models or auth types.\n    \"\"\"\n\n    def add_permissions_view(self, base_permissions, view_menu):\n        \"\"\"\n            Adds a permission on a view menu to the backend\n\n            :param base_permissions:\n                list of permissions from view (all exposed methods):\n                 'can_add','can_edit' etc...\n            :param view_menu:\n                name of the view or menu to add\n        \"\"\"\n        raise NotImplementedError\n\n    def add_permissions_menu(self, view_menu_name):\n        \"\"\"\n            Adds menu_access to menu on permission_view_menu\n\n            :param view_menu_name:\n                The menu name\n        \"\"\"\n        raise NotImplementedError\n\n    def register_views(self):\n        \"\"\"\n            Generic function to create the security views\n        \"\"\"\n        raise NotImplementedError\n\n    def is_item_public(self, permission_name, view_name):\n        \"\"\"\n            Check if view has public permissions\n\n            :param permission_name:\n                the permission: can_show, can_edit...\n            :param view_name:\n                the name of the class view (child of BaseView)\n        \"\"\"\n        raise NotImplementedError\n\n    def has_access(self, permission_name, view_name):\n        \"\"\"\n            Check if current user or public has access to view or menu\n        \"\"\"\n        raise NotImplementedError\n\n    def security_cleanup(self, baseviews, menus):\n        raise NotImplementedError\n\n\ndef _oauth_tokengetter(token=None):\n    \"\"\"\n        Default function to return the current user oauth token\n        from session cookie.\n    \"\"\"\n    token = session.get(\"oauth\")\n    log.debug(\"Token Get: {0}\".format(token))\n    return token\n\n\nclass BaseSecurityManager(AbstractSecurityManager):\n    auth_view = None\n    \"\"\" The obj instance for authentication view \"\"\"\n    user_view = None\n    \"\"\" The obj instance for user view \"\"\"\n    registeruser_view = None\n    \"\"\" The obj instance for registering user view \"\"\"\n    lm = None\n    \"\"\" Flask-Login LoginManager \"\"\"\n    jwt_manager = None\n    \"\"\" Flask-JWT-Extended \"\"\"\n    oid = None\n    \"\"\" Flask-OpenID OpenID \"\"\"\n    oauth = None\n    \"\"\" Flask-OAuth \"\"\"\n    oauth_remotes = None\n    \"\"\" OAuth email whitelists \"\"\"\n    oauth_whitelists = {}\n    \"\"\" Initialized (remote_app) providers dict {'provider_name', OBJ } \"\"\"\n    oauth_tokengetter = _oauth_tokengetter\n    \"\"\" OAuth tokengetter function override to implement your own tokengetter method \"\"\"\n    oauth_user_info = None\n\n    user_model = None\n    \"\"\" Override to set your own User Model \"\"\"\n    role_model = None\n    \"\"\" Override to set your own Role Model \"\"\"\n    permission_model = None\n    \"\"\" Override to set your own Permission Model \"\"\"\n    viewmenu_model = None\n    \"\"\" Override to set your own ViewMenu Model \"\"\"\n    permissionview_model = None\n    \"\"\" Override to set your own PermissionView Model \"\"\"\n    registeruser_model = None\n    \"\"\" Override to set your own RegisterUser Model \"\"\"\n\n    userdbmodelview = UserDBModelView\n    \"\"\" Override if you want your own user db view \"\"\"\n    userldapmodelview = UserLDAPModelView\n    \"\"\" Override if you want your own user ldap view \"\"\"\n    useroidmodelview = UserOIDModelView\n    \"\"\" Override if you want your own user OID view \"\"\"\n    useroauthmodelview = UserOAuthModelView\n    \"\"\" Override if you want your own user OAuth view \"\"\"\n    userremoteusermodelview = UserRemoteUserModelView\n    \"\"\" Override if you want your own user REMOTE_USER view \"\"\"\n    registerusermodelview = RegisterUserModelView\n\n    authdbview = AuthDBView\n    \"\"\" Override if you want your own Authentication DB view \"\"\"\n    authldapview = AuthLDAPView\n    \"\"\" Override if you want your own Authentication LDAP view \"\"\"\n    authoidview = AuthOIDView\n    \"\"\" Override if you want your own Authentication OID view \"\"\"\n    authoauthview = AuthOAuthView\n    \"\"\" Override if you want your own Authentication OAuth view \"\"\"\n    authremoteuserview = AuthRemoteUserView\n    \"\"\" Override if you want your own Authentication REMOTE_USER view \"\"\"\n\n    registeruserdbview = RegisterUserDBView\n    \"\"\" Override if you want your own register user db view \"\"\"\n    registeruseroidview = RegisterUserOIDView\n    \"\"\" Override if you want your own register user OpenID view \"\"\"\n    registeruseroauthview = RegisterUserOAuthView\n    \"\"\" Override if you want your own register user OAuth view \"\"\"\n\n    resetmypasswordview = ResetMyPasswordView\n    \"\"\" Override if you want your own reset my password view \"\"\"\n    resetpasswordview = ResetPasswordView\n    \"\"\" Override if you want your own reset password view \"\"\"\n    userinfoeditview = UserInfoEditView\n    \"\"\" Override if you want your own User information edit view \"\"\"\n\n    # API\n    security_api = SecurityApi\n    \"\"\" Override if you want your own Security API login endpoint \"\"\"\n\n    rolemodelview = RoleModelView\n    permissionmodelview = PermissionModelView\n    userstatschartview = UserStatsChartView\n    viewmenumodelview = ViewMenuModelView\n    permissionviewmodelview = PermissionViewModelView\n\n    def __init__(self, appbuilder):\n        super(BaseSecurityManager, self).__init__(appbuilder)\n        app = self.appbuilder.get_app\n        # Base Security Config\n        app.config.setdefault(\"AUTH_ROLE_ADMIN\", \"Admin\")\n        app.config.setdefault(\"AUTH_ROLE_PUBLIC\", \"Public\")\n        app.config.setdefault(\"AUTH_TYPE\", AUTH_DB)\n        # Self Registration\n        app.config.setdefault(\"AUTH_USER_REGISTRATION\", False)\n        app.config.setdefault(\"AUTH_USER_REGISTRATION_ROLE\", self.auth_role_public)\n        app.config.setdefault(\"AUTH_USER_REGISTRATION_ROLE_JMESPATH\", None)\n        # Role Mapping\n        app.config.setdefault(\"AUTH_ROLES_MAPPING\", {})\n        app.config.setdefault(\"AUTH_ROLES_SYNC_AT_LOGIN\", False)\n\n        # LDAP Config\n        if self.auth_type == AUTH_LDAP:\n            if \"AUTH_LDAP_SERVER\" not in app.config:\n                raise Exception(\n                    \"No AUTH_LDAP_SERVER defined on config\"\n                    \" with AUTH_LDAP authentication type.\"\n                )\n            app.config.setdefault(\"AUTH_LDAP_SEARCH\", \"\")\n            app.config.setdefault(\"AUTH_LDAP_SEARCH_FILTER\", \"\")\n            app.config.setdefault(\"AUTH_LDAP_APPEND_DOMAIN\", \"\")\n            app.config.setdefault(\"AUTH_LDAP_USERNAME_FORMAT\", \"\")\n            app.config.setdefault(\"AUTH_LDAP_BIND_USER\", \"\")\n            app.config.setdefault(\"AUTH_LDAP_BIND_PASSWORD\", \"\")\n            # TLS options\n            app.config.setdefault(\"AUTH_LDAP_USE_TLS\", False)\n            app.config.setdefault(\"AUTH_LDAP_ALLOW_SELF_SIGNED\", False)\n            app.config.setdefault(\"AUTH_LDAP_TLS_DEMAND\", False)\n            app.config.setdefault(\"AUTH_LDAP_TLS_CACERTDIR\", \"\")\n            app.config.setdefault(\"AUTH_LDAP_TLS_CACERTFILE\", \"\")\n            app.config.setdefault(\"AUTH_LDAP_TLS_CERTFILE\", \"\")\n            app.config.setdefault(\"AUTH_LDAP_TLS_KEYFILE\", \"\")\n            # Mapping options\n            app.config.setdefault(\"AUTH_LDAP_UID_FIELD\", \"uid\")\n            app.config.setdefault(\"AUTH_LDAP_GROUP_FIELD\", \"memberOf\")\n            app.config.setdefault(\"AUTH_LDAP_FIRSTNAME_FIELD\", \"givenName\")\n            app.config.setdefault(\"AUTH_LDAP_LASTNAME_FIELD\", \"sn\")\n            app.config.setdefault(\"AUTH_LDAP_EMAIL_FIELD\", \"mail\")\n\n        if self.auth_type == AUTH_OID:\n            from flask_openid import OpenID\n\n            self.oid = OpenID(app)\n        if self.auth_type == AUTH_OAUTH:\n            from authlib.integrations.flask_client import OAuth\n\n            self.oauth = OAuth(app)\n            self.oauth_remotes = dict()\n            for _provider in self.oauth_providers:\n                provider_name = _provider[\"name\"]\n                log.debug(\"OAuth providers init {0}\".format(provider_name))\n                obj_provider = self.oauth.register(\n                    provider_name, **_provider[\"remote_app\"]\n                )\n                obj_provider._tokengetter = self.oauth_tokengetter\n                if not self.oauth_user_info:\n                    self.oauth_user_info = self.get_oauth_user_info\n                # Whitelist only users with matching emails\n                if \"whitelist\" in _provider:\n                    self.oauth_whitelists[provider_name] = _provider[\"whitelist\"]\n                self.oauth_remotes[provider_name] = obj_provider\n\n        self._builtin_roles = self.create_builtin_roles()\n        # Setup Flask-Login\n        self.lm = self.create_login_manager(app)\n\n        # Setup Flask-Jwt-Extended\n        self.jwt_manager = self.create_jwt_manager(app)\n\n    def create_login_manager(self, app) -> LoginManager:\n        \"\"\"\n            Override to implement your custom login manager instance\n\n            :param app: Flask app\n        \"\"\"\n        lm = LoginManager(app)\n        lm.login_view = \"login\"\n        lm.user_loader(self.load_user)\n        return lm\n\n    def create_jwt_manager(self, app) -> JWTManager:\n        \"\"\"\n            Override to implement your custom JWT manager instance\n\n            :param app: Flask app\n        \"\"\"\n        jwt_manager = JWTManager()\n        jwt_manager.init_app(app)\n        jwt_manager.user_loader_callback_loader(self.load_user_jwt)\n        return jwt_manager\n\n    def create_builtin_roles(self):\n        return self.appbuilder.get_app.config.get(\"FAB_ROLES\", {})\n\n    def get_roles_from_keys(self, role_keys: List[str]) -> List[role_model]:\n        \"\"\"\n        Construct a list of FAB role objects, from a list of keys.\n\n        NOTE:\n        - keys are things like: \"LDAP group DNs\" or \"OAUTH group names\"\n        - we use AUTH_ROLES_MAPPING to map from keys, to FAB role names\n\n        :param role_keys: the list of FAB role keys\n        :return: a list of RoleModelView\n        \"\"\"\n        _roles = []\n        _role_keys = set(role_keys)\n        for role_key, fab_role_names in self.auth_roles_mapping.items():\n            if role_key in _role_keys:\n                for fab_role_name in fab_role_names:\n                    fab_role = self.find_role(fab_role_name)\n                    if fab_role:\n                        _roles.append(fab_role)\n                    else:\n                        log.warning(\n                            \"Can't find role specified in AUTH_ROLES_MAPPING: {0}\".format(\n                                fab_role_name\n                            )\n                        )\n        return _roles\n\n    @property\n    def get_url_for_registeruser(self):\n        return url_for(\n            \"%s.%s\"\n            % (self.registeruser_view.endpoint, self.registeruser_view.default_view)\n        )\n\n    @property\n    def get_user_datamodel(self):\n        return self.user_view.datamodel\n\n    @property\n    def get_register_user_datamodel(self):\n        return self.registerusermodelview.datamodel\n\n    @property\n    def builtin_roles(self):\n        return self._builtin_roles\n\n    @property\n    def auth_type(self):\n        return self.appbuilder.get_app.config[\"AUTH_TYPE\"]\n\n    @property\n    def auth_username_ci(self):\n        return self.appbuilder.get_app.config.get(\"AUTH_USERNAME_CI\", True)\n\n    @property\n    def auth_role_admin(self):\n        return self.appbuilder.get_app.config[\"AUTH_ROLE_ADMIN\"]\n\n    @property\n    def auth_role_public(self):\n        return self.appbuilder.get_app.config[\"AUTH_ROLE_PUBLIC\"]\n\n    @property\n    def auth_ldap_server(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_SERVER\"]\n\n    @property\n    def auth_ldap_use_tls(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_USE_TLS\"]\n\n    @property\n    def auth_user_registration(self):\n        return self.appbuilder.get_app.config[\"AUTH_USER_REGISTRATION\"]\n\n    @property\n    def auth_user_registration_role(self):\n        return self.appbuilder.get_app.config[\"AUTH_USER_REGISTRATION_ROLE\"]\n\n    @property\n    def auth_user_registration_role_jmespath(self) -> str:\n        return self.appbuilder.get_app.config[\"AUTH_USER_REGISTRATION_ROLE_JMESPATH\"]\n\n    @property\n    def auth_roles_mapping(self) -> Dict[str, List[str]]:\n        return self.appbuilder.get_app.config[\"AUTH_ROLES_MAPPING\"]\n\n    @property\n    def auth_roles_sync_at_login(self) -> bool:\n        return self.appbuilder.get_app.config[\"AUTH_ROLES_SYNC_AT_LOGIN\"]\n\n    @property\n    def auth_ldap_search(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_SEARCH\"]\n\n    @property\n    def auth_ldap_search_filter(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_SEARCH_FILTER\"]\n\n    @property\n    def auth_ldap_bind_user(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_BIND_USER\"]\n\n    @property\n    def auth_ldap_bind_password(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_BIND_PASSWORD\"]\n\n    @property\n    def auth_ldap_append_domain(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_APPEND_DOMAIN\"]\n\n    @property\n    def auth_ldap_username_format(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_USERNAME_FORMAT\"]\n\n    @property\n    def auth_ldap_uid_field(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_UID_FIELD\"]\n\n    @property\n    def auth_ldap_group_field(self) -> str:\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_GROUP_FIELD\"]\n\n    @property\n    def auth_ldap_firstname_field(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_FIRSTNAME_FIELD\"]\n\n    @property\n    def auth_ldap_lastname_field(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_LASTNAME_FIELD\"]\n\n    @property\n    def auth_ldap_email_field(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_EMAIL_FIELD\"]\n\n    @property\n    def auth_ldap_bind_first(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_BIND_FIRST\"]\n\n    @property\n    def auth_ldap_allow_self_signed(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_ALLOW_SELF_SIGNED\"]\n\n    @property\n    def auth_ldap_tls_demand(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_DEMAND\"]\n\n    @property\n    def auth_ldap_tls_cacertdir(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_CACERTDIR\"]\n\n    @property\n    def auth_ldap_tls_cacertfile(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_CACERTFILE\"]\n\n    @property\n    def auth_ldap_tls_certfile(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_CERTFILE\"]\n\n    @property\n    def auth_ldap_tls_keyfile(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_KEYFILE\"]\n\n    @property\n    def openid_providers(self):\n        return self.appbuilder.get_app.config[\"OPENID_PROVIDERS\"]\n\n    @property\n    def oauth_providers(self):\n        return self.appbuilder.get_app.config[\"OAUTH_PROVIDERS\"]\n\n    @property\n    def current_user(self):\n        if current_user.is_authenticated:\n            return g.user\n        elif current_user_jwt:\n            return current_user_jwt\n\n    def oauth_user_info_getter(self, f):\n        \"\"\"\n            Decorator function to be the OAuth user info getter\n            for all the providers, receives provider and response\n            return a dict with the information returned from the provider.\n            The returned user info dict should have it's keys with the same\n            name as the User Model.\n\n            Use it like this an example for GitHub ::\n\n                @appbuilder.sm.oauth_user_info_getter\n                def my_oauth_user_info(sm, provider, response=None):\n                    if provider == 'github':\n                        me = sm.oauth_remotes[provider].get('user')\n                        return {'username': me.data.get('login')}\n                    else:\n                        return {}\n        \"\"\"\n\n        def wraps(provider, response=None):\n            ret = f(self, provider, response=response)\n            # Checks if decorator is well behaved and returns a dict as supposed.\n            if not type(ret) == dict:\n                log.error(\n                    \"OAuth user info decorated function \"\n                    \"did not returned a dict, but: {0}\".format(type(ret))\n                )\n                return {}\n            return ret\n\n        self.oauth_user_info = wraps\n        return wraps\n\n    def get_oauth_token_key_name(self, provider):\n        \"\"\"\n            Returns the token_key name for the oauth provider\n            if none is configured defaults to oauth_token\n            this is configured using OAUTH_PROVIDERS and token_key key.\n        \"\"\"\n        for _provider in self.oauth_providers:\n            if _provider[\"name\"] == provider:\n                return _provider.get(\"token_key\", \"oauth_token\")\n\n    def get_oauth_token_secret_name(self, provider):\n        \"\"\"\n            Returns the token_secret name for the oauth provider\n            if none is configured defaults to oauth_secret\n            this is configured using OAUTH_PROVIDERS and token_secret\n        \"\"\"\n        for _provider in self.oauth_providers:\n            if _provider[\"name\"] == provider:\n                return _provider.get(\"token_secret\", \"oauth_token_secret\")\n\n    def set_oauth_session(self, provider, oauth_response):\n        \"\"\"\n            Set the current session with OAuth user secrets\n        \"\"\"\n        # Get this provider key names for token_key and token_secret\n        token_key = self.appbuilder.sm.get_oauth_token_key_name(provider)\n        token_secret = self.appbuilder.sm.get_oauth_token_secret_name(provider)\n        # Save users token on encrypted session cookie\n        session[\"oauth\"] = (\n            oauth_response[token_key],\n            oauth_response.get(token_secret, \"\"),\n        )\n        session[\"oauth_provider\"] = provider\n\n    def get_oauth_user_info(self, provider, resp):\n        \"\"\"\n            Since there are different OAuth API's with different ways to\n            retrieve user info\n        \"\"\"\n        # for GITHUB\n        if provider == \"github\" or provider == \"githublocal\":\n            me = self.appbuilder.sm.oauth_remotes[provider].get(\"user\")\n            data = me.json()\n            log.debug(\"User info from Github: {0}\".format(data))\n            return {\"username\": \"github_\" + data.get(\"login\")}\n        # for twitter\n        if provider == \"twitter\":\n            me = self.appbuilder.sm.oauth_remotes[provider].get(\"account/settings.json\")\n            data = me.json()\n            log.debug(\"User info from Twitter: {0}\".format(data))\n            return {\"username\": \"twitter_\" + data.get(\"screen_name\", \"\")}\n        # for linkedin\n        if provider == \"linkedin\":\n            me = self.appbuilder.sm.oauth_remotes[provider].get(\n                \"people/~:(id,email-address,first-name,last-name)?format=json\"\n            )\n            data = me.json()\n            log.debug(\"User info from Linkedin: {0}\".format(data))\n            return {\n                \"username\": \"linkedin_\" + data.get(\"id\", \"\"),\n                \"email\": data.get(\"email-address\", \"\"),\n                \"first_name\": data.get(\"firstName\", \"\"),\n                \"last_name\": data.get(\"lastName\", \"\"),\n            }\n        # for Google\n        if provider == \"google\":\n            me = self.appbuilder.sm.oauth_remotes[provider].get(\"userinfo\")\n            data = me.json()\n            log.debug(\"User info from Google: {0}\".format(data))\n            return {\n                \"username\": \"google_\" + data.get(\"id\", \"\"),\n                \"first_name\": data.get(\"given_name\", \"\"),\n                \"last_name\": data.get(\"family_name\", \"\"),\n                \"email\": data.get(\"email\", \"\"),\n            }\n        # for Azure AD Tenant. Azure OAuth response contains\n        # JWT token which has user info.\n        # JWT token needs to be base64 decoded.\n        # https://docs.microsoft.com/en-us/azure/active-directory/develop/\n        # active-directory-protocols-oauth-code\n        if provider == \"azure\":\n            log.debug(\"Azure response received : {0}\".format(resp))\n            id_token = resp[\"id_token\"]\n            log.debug(str(id_token))\n            me = self._azure_jwt_token_parse(id_token)\n            log.debug(\"Parse JWT token : {0}\".format(me))\n            return {\n                \"name\": me.get(\"name\", \"\"),\n                \"email\": me[\"upn\"],\n                \"first_name\": me.get(\"given_name\", \"\"),\n                \"last_name\": me.get(\"family_name\", \"\"),\n                \"id\": me[\"oid\"],\n                \"username\": me[\"oid\"],\n            }\n        # for OpenShift\n        if provider == \"openshift\":\n            me = self.appbuilder.sm.oauth_remotes[provider].get(\n                \"apis/user.openshift.io/v1/users/~\"\n            )\n            data = me.json()\n            log.debug(\"User info from OpenShift: {0}\".format(data))\n            return {\"username\": \"openshift_\" + data.get(\"metadata\").get(\"name\")}\n        # for Okta\n        if provider == \"okta\":\n            me = self.appbuilder.sm.oauth_remotes[provider].get(\"userinfo\")\n            data = me.json()\n            log.debug(\"User info from Okta: %s\", data)\n            return {\n                \"username\": \"okta_\" + data.get(\"sub\", \"\"),\n                \"first_name\": data.get(\"given_name\", \"\"),\n                \"last_name\": data.get(\"family_name\", \"\"),\n                \"email\": data.get(\"email\", \"\"),\n                \"role_keys\": data.get(\"groups\", []),\n            }\n        else:\n            return {}\n\n    def _azure_parse_jwt(self, id_token):\n        jwt_token_parts = r\"^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$\"\n        matches = re.search(jwt_token_parts, id_token)\n        if not matches or len(matches.groups()) < 3:\n            log.error(\"Unable to parse token.\")\n            return {}\n        return {\n            \"header\": matches.group(1),\n            \"Payload\": matches.group(2),\n            \"Sig\": matches.group(3),\n        }\n\n    def _azure_jwt_token_parse(self, id_token):\n        jwt_split_token = self._azure_parse_jwt(id_token)\n        if not jwt_split_token:\n            return\n\n        jwt_payload = jwt_split_token[\"Payload\"]\n        # Prepare for base64 decoding\n        payload_b64_string = jwt_payload\n        payload_b64_string += \"=\" * (4 - ((len(jwt_payload) % 4)))\n        decoded_payload = base64.urlsafe_b64decode(payload_b64_string.encode(\"ascii\"))\n\n        if not decoded_payload:\n            log.error(\"Payload of id_token could not be base64 url decoded.\")\n            return\n\n        jwt_decoded_payload = json.loads(decoded_payload.decode(\"utf-8\"))\n\n        return jwt_decoded_payload\n\n    def register_views(self):\n        if not self.appbuilder.app.config.get(\"FAB_ADD_SECURITY_VIEWS\", True):\n            return\n        # Security APIs\n        self.appbuilder.add_api(self.security_api)\n\n        if self.auth_user_registration:\n            if self.auth_type == AUTH_DB:\n                self.registeruser_view = self.registeruserdbview()\n            elif self.auth_type == AUTH_OID:\n                self.registeruser_view = self.registeruseroidview()\n            elif self.auth_type == AUTH_OAUTH:\n                self.registeruser_view = self.registeruseroauthview()\n            if self.registeruser_view:\n                self.appbuilder.add_view_no_menu(self.registeruser_view)\n\n        self.appbuilder.add_view_no_menu(self.resetpasswordview())\n        self.appbuilder.add_view_no_menu(self.resetmypasswordview())\n        self.appbuilder.add_view_no_menu(self.userinfoeditview())\n\n        if self.auth_type == AUTH_DB:\n            self.user_view = self.userdbmodelview\n            self.auth_view = self.authdbview()\n\n        elif self.auth_type == AUTH_LDAP:\n            self.user_view = self.userldapmodelview\n            self.auth_view = self.authldapview()\n        elif self.auth_type == AUTH_OAUTH:\n            self.user_view = self.useroauthmodelview\n            self.auth_view = self.authoauthview()\n        elif self.auth_type == AUTH_REMOTE_USER:\n            self.user_view = self.userremoteusermodelview\n            self.auth_view = self.authremoteuserview()\n        else:\n            self.user_view = self.useroidmodelview\n            self.auth_view = self.authoidview()\n            if self.auth_user_registration:\n                pass\n                # self.registeruser_view = self.registeruseroidview()\n                # self.appbuilder.add_view_no_menu(self.registeruser_view)\n\n        self.appbuilder.add_view_no_menu(self.auth_view)\n\n        self.user_view = self.appbuilder.add_view(\n            self.user_view,\n            \"List Users\",\n            icon=\"fa-user\",\n            label=_(\"List Users\"),\n            category=\"Security\",\n            category_icon=\"fa-cogs\",\n            category_label=_(\"Security\"),\n        )\n\n        role_view = self.appbuilder.add_view(\n            self.rolemodelview,\n            \"List Roles\",\n            icon=\"fa-group\",\n            label=_(\"List Roles\"),\n            category=\"Security\",\n            category_icon=\"fa-cogs\",\n        )\n        role_view.related_views = [self.user_view.__class__]\n\n        if self.userstatschartview:\n            self.appbuilder.add_view(\n                self.userstatschartview,\n                \"User's Statistics\",\n                icon=\"fa-bar-chart-o\",\n                label=_(\"User's Statistics\"),\n                category=\"Security\",\n            )\n        if self.auth_user_registration:\n            self.appbuilder.add_view(\n                self.registerusermodelview,\n                \"User's Statistics\",\n                icon=\"fa-user-plus\",\n                label=_(\"User Registrations\"),\n                category=\"Security\",\n            )\n        self.appbuilder.menu.add_separator(\"Security\")\n        if self.appbuilder.app.config.get(\"FAB_ADD_SECURITY_PERMISSION_VIEW\", True):\n            self.appbuilder.add_view(\n                self.permissionmodelview,\n                \"Base Permissions\",\n                icon=\"fa-lock\",\n                label=_(\"Base Permissions\"),\n                category=\"Security\",\n            )\n        if self.appbuilder.app.config.get(\"FAB_ADD_SECURITY_VIEW_MENU_VIEW\", True):\n            self.appbuilder.add_view(\n                self.viewmenumodelview,\n                \"Views/Menus\",\n                icon=\"fa-list-alt\",\n                label=_(\"Views/Menus\"),\n                category=\"Security\",\n            )\n        if self.appbuilder.app.config.get(\n            \"FAB_ADD_SECURITY_PERMISSION_VIEWS_VIEW\", True\n        ):\n            self.appbuilder.add_view(\n                self.permissionviewmodelview,\n                \"Permission on Views/Menus\",\n                icon=\"fa-link\",\n                label=_(\"Permission on Views/Menus\"),\n                category=\"Security\",\n            )\n\n    def create_db(self):\n        \"\"\"\n            Setups the DB, creates admin and public roles if they don't exist.\n        \"\"\"\n        roles_mapping = self.appbuilder.get_app.config.get(\"FAB_ROLES_MAPPING\", {})\n        for pk, name in roles_mapping.items():\n            self.update_role(pk, name)\n        for role_name in self.builtin_roles:\n            self.add_role(role_name)\n        if self.auth_role_admin not in self.builtin_roles:\n            self.add_role(self.auth_role_admin)\n        self.add_role(self.auth_role_public)\n        if self.count_users() == 0:\n            log.warning(LOGMSG_WAR_SEC_NO_USER)\n\n    def reset_password(self, userid, password):\n        \"\"\"\n            Change/Reset a user's password for authdb.\n            Password will be hashed and saved.\n\n            :param userid:\n                the user.id to reset the password\n            :param password:\n                The clear text password to reset and save hashed on the db\n        \"\"\"\n        user = self.get_user_by_id(userid)\n        user.password = generate_password_hash(password)\n        self.update_user(user)\n\n    def update_user_auth_stat(self, user, success=True):\n        \"\"\"\n            Update authentication successful to user.\n\n            :param user:\n                The authenticated user model\n            :param success:\n                Default to true, if false increments fail_login_count on user model\n        \"\"\"\n        if not user.login_count:\n            user.login_count = 0\n        if not user.fail_login_count:\n            user.fail_login_count = 0\n        if success:\n            user.login_count += 1\n            user.fail_login_count = 0\n        else:\n            user.fail_login_count += 1\n        user.last_login = datetime.datetime.now()\n        self.update_user(user)\n\n    def auth_user_db(self, username, password):\n        \"\"\"\n            Method for authenticating user, auth db style\n\n            :param username:\n                The username or registered email address\n            :param password:\n                The password, will be tested against hashed password on db\n        \"\"\"\n        if username is None or username == \"\":\n            return None\n        user = self.find_user(username=username)\n        if user is None:\n            user = self.find_user(email=username)\n        if user is None or (not user.is_active):\n            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(username))\n            return None\n        elif check_password_hash(user.password, password):\n            self.update_user_auth_stat(user, True)\n            return user\n        else:\n            self.update_user_auth_stat(user, False)\n            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(username))\n            return None\n\n    def _search_ldap(self, ldap, con, username):\n        \"\"\"\n            Searches LDAP for user.\n\n            :param ldap: The ldap module reference\n            :param con: The ldap connection\n            :param username: username to match with AUTH_LDAP_UID_FIELD\n            :return: ldap object array\n        \"\"\"\n        # always check AUTH_LDAP_SEARCH is set before calling this method\n        assert self.auth_ldap_search, \"AUTH_LDAP_SEARCH must be set\"\n\n        # build the filter string for the LDAP search\n        if self.auth_ldap_search_filter:\n            filter_str = \"(&{0}({1}={2}))\".format(\n                self.auth_ldap_search_filter, self.auth_ldap_uid_field, username\n            )\n        else:\n            filter_str = \"({0}={1})\".format(self.auth_ldap_uid_field, username)\n\n        # build what fields to request in the LDAP search\n        request_fields = [\n            self.auth_ldap_firstname_field,\n            self.auth_ldap_lastname_field,\n            self.auth_ldap_email_field,\n        ]\n        if len(self.auth_roles_mapping) > 0:\n            request_fields.append(self.auth_ldap_group_field)\n\n        # preform the LDAP search\n        log.debug(\n            \"LDAP search for '{0}' with fields {1} in scope '{2}'\".format(\n                filter_str, request_fields, self.auth_ldap_search\n            )\n        )\n        raw_search_result = con.search_s(\n            self.auth_ldap_search, ldap.SCOPE_SUBTREE, filter_str, request_fields\n        )\n        log.debug(\"LDAP search returned: {0}\".format(raw_search_result))\n\n        # Remove any search referrals from results\n        search_result = [\n            (dn, attrs)\n            for dn, attrs in raw_search_result\n            if dn is not None and isinstance(attrs, dict)\n        ]\n\n        # only continue if 0 or 1 results were returned\n        if len(search_result) > 1:\n            log.error(\n                \"LDAP search for '{0}' in scope '{1}' returned multiple results\".format(\n                    filter_str, self.auth_ldap_search\n                )\n            )\n            return None, None\n\n        try:\n            # extract the DN\n            user_dn = search_result[0][0]\n            # extract the other attributes\n            user_info = search_result[0][1]\n            # return\n            return user_dn, user_info\n        except (IndexError, NameError):\n            return None, None\n\n    def _ldap_calculate_user_roles(\n        self, user_attributes: Dict[str, bytes]\n    ) -> List[str]:\n        user_role_objects = []\n\n        # apply AUTH_ROLES_MAPPING\n        if len(self.auth_roles_mapping) > 0:\n            user_role_keys = self.ldap_extract_list(\n                user_attributes, self.auth_ldap_group_field\n            )\n            user_role_objects += self.get_roles_from_keys(user_role_keys)\n\n        # apply AUTH_USER_REGISTRATION\n        if self.auth_user_registration:\n            registration_role_name = self.auth_user_registration_role\n\n            # lookup registration role in flask db\n            fab_role = self.find_role(registration_role_name)\n            if fab_role:\n                user_role_objects.append(fab_role)\n            else:\n                log.warning(\n                    \"Can't find AUTH_USER_REGISTRATION role: {0}\".format(\n                        registration_role_name\n                    )\n                )\n\n        return user_role_objects\n\n    def _ldap_bind_indirect(self, ldap, con) -> None:\n        \"\"\"\n            Attempt to bind to LDAP using the AUTH_LDAP_BIND_USER.\n\n            :param ldap: The ldap module reference\n            :param con: The ldap connection\n        \"\"\"\n        # always check AUTH_LDAP_BIND_USER is set before calling this method\n        assert self.auth_ldap_bind_user, \"AUTH_LDAP_BIND_USER must be set\"\n\n        try:\n            log.debug(\n                \"LDAP bind indirect TRY with username: '{0}'\".format(\n                    self.auth_ldap_bind_user\n                )\n            )\n            con.simple_bind_s(self.auth_ldap_bind_user, self.auth_ldap_bind_password)\n            log.debug(\n                \"LDAP bind indirect SUCCESS with username: '{0}'\".format(\n                    self.auth_ldap_bind_user\n                )\n            )\n        except ldap.INVALID_CREDENTIALS as ex:\n            log.error(\n                \"AUTH_LDAP_BIND_USER and AUTH_LDAP_BIND_PASSWORD are\"\n                \" not valid LDAP bind credentials\"\n            )\n            raise ex\n\n    @staticmethod\n    def _ldap_bind(ldap, con, dn: str, password: str) -> bool:\n        \"\"\"\n            Validates/binds the provided dn/password with the LDAP sever.\n        \"\"\"\n        try:\n            log.debug(\"LDAP bind TRY with username: '{0}'\".format(dn))\n            con.simple_bind_s(dn, password)\n            log.debug(\"LDAP bind SUCCESS with username: '{0}'\".format(dn))\n            return True\n        except ldap.INVALID_CREDENTIALS:\n            return False\n\n    @staticmethod\n    def ldap_extract(\n        ldap_dict: Dict[str, bytes], field_name: str, fallback: str\n    ) -> str:\n        raw_value = ldap_dict.get(field_name, [bytes()])\n        # decode - if empty string, default to fallback, otherwise take first element\n        return raw_value[0].decode(\"utf-8\") or fallback\n\n    @staticmethod\n    def ldap_extract_list(ldap_dict: Dict[str, bytes], field_name: str) -> List[str]:\n        raw_list = ldap_dict.get(field_name, [])\n        # decode - removing empty strings\n        return [x.decode(\"utf-8\") for x in raw_list if x.decode(\"utf-8\")]\n\n    def auth_user_ldap(self, username, password):\n        \"\"\"\n            Method for authenticating user with LDAP.\n\n            NOTE: this depends on python-ldap module\n\n            :param username: the username\n            :param password: the password\n        \"\"\"\n        # If no username is provided, go away\n        if (username is None) or username == \"\":\n            return None\n\n        # Search the DB for this user\n        user = self.find_user(username=username)\n\n        # If user is not active, go away\n        if user and (not user.is_active):\n            return None\n\n        # If user is not registered, and not self-registration, go away\n        if (not user) and (not self.auth_user_registration):\n            return None\n\n        # Ensure python-ldap is installed\n        try:\n            import ldap\n        except ImportError:\n            log.error(\"python-ldap library is not installed\")\n            return None\n\n        try:\n            # LDAP certificate settings\n            if self.auth_ldap_allow_self_signed:\n                ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_ALLOW)\n                ldap.set_option(ldap.OPT_X_TLS_NEWCTX, 0)\n            elif self.auth_ldap_tls_demand:\n                ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_DEMAND)\n                ldap.set_option(ldap.OPT_X_TLS_NEWCTX, 0)\n            if self.auth_ldap_tls_cacertdir:\n                ldap.set_option(ldap.OPT_X_TLS_CACERTDIR, self.auth_ldap_tls_cacertdir)\n            if self.auth_ldap_tls_cacertfile:\n                ldap.set_option(\n                    ldap.OPT_X_TLS_CACERTFILE, self.auth_ldap_tls_cacertfile\n                )\n            if self.auth_ldap_tls_certfile:\n                ldap.set_option(ldap.OPT_X_TLS_CERTFILE, self.auth_ldap_tls_certfile)\n            if self.auth_ldap_tls_keyfile:\n                ldap.set_option(ldap.OPT_X_TLS_KEYFILE, self.auth_ldap_tls_keyfile)\n\n            # Initialise LDAP connection\n            con = ldap.initialize(self.auth_ldap_server)\n            con.set_option(ldap.OPT_REFERRALS, 0)\n            if self.auth_ldap_use_tls:\n                try:\n                    con.start_tls_s()\n                except Exception:\n                    log.error(\n                        LOGMSG_ERR_SEC_AUTH_LDAP_TLS.format(self.auth_ldap_server)\n                    )\n                    return None\n\n            # Define variables, so we can check if they are set in later steps\n            user_dn = None\n            user_attributes = {}\n\n            # Flow 1 - (Indirect Search Bind):\n            #  - in this flow, special bind credentials are used to preform the\n            #    LDAP search\n            #  - in this flow, AUTH_LDAP_SEARCH must be set\n            if self.auth_ldap_bind_user:\n                # Bind with AUTH_LDAP_BIND_USER/AUTH_LDAP_BIND_PASSWORD\n                # (authorizes for LDAP search)\n                self._ldap_bind_indirect(ldap, con)\n\n                # Search for `username`\n                #  - returns the `user_dn` needed for binding to validate credentials\n                #  - returns the `user_attributes` needed for\n                #    AUTH_USER_REGISTRATION/AUTH_ROLES_SYNC_AT_LOGIN\n                if self.auth_ldap_search:\n                    user_dn, user_attributes = self._search_ldap(ldap, con, username)\n                else:\n                    log.error(\n                        \"AUTH_LDAP_SEARCH must be set when using AUTH_LDAP_BIND_USER\"\n                    )\n                    return None\n\n                # If search failed, go away\n                if user_dn is None:\n                    log.info(LOGMSG_WAR_SEC_NOLDAP_OBJ.format(username))\n                    return None\n\n                # Bind with user_dn/password (validates credentials)\n                if not self._ldap_bind(ldap, con, user_dn, password):\n                    if user:\n                        self.update_user_auth_stat(user, False)\n\n                    # Invalid credentials, go away\n                    log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(username))\n                    return None\n\n            # Flow 2 - (Direct Search Bind):\n            #  - in this flow, the credentials provided by the end-user are used\n            #    to preform the LDAP search\n            #  - in this flow, we only search LDAP if AUTH_LDAP_SEARCH is set\n            #     - features like AUTH_USER_REGISTRATION & AUTH_ROLES_SYNC_AT_LOGIN\n            #       will only work if AUTH_LDAP_SEARCH is set\n            else:\n                # Copy the provided username (so we can apply formatters)\n                bind_username = username\n\n                # update `bind_username` by applying AUTH_LDAP_APPEND_DOMAIN\n                #  - for Microsoft AD, which allows binding with userPrincipalName\n                if self.auth_ldap_append_domain:\n                    bind_username = bind_username + \"@\" + self.auth_ldap_append_domain\n\n                # Update `bind_username` by applying AUTH_LDAP_USERNAME_FORMAT\n                #  - for transforming the username into a DN,\n                #    for example: \"uid=%s,ou=example,o=test\"\n                if self.auth_ldap_username_format:\n                    bind_username = self.auth_ldap_username_format % bind_username\n\n                # Bind with bind_username/password\n                # (validates credentials & authorizes for LDAP search)\n                if not self._ldap_bind(ldap, con, bind_username, password):\n                    if user:\n                        self.update_user_auth_stat(user, False)\n\n                    # Invalid credentials, go away\n                    log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(bind_username))\n                    return None\n\n                # Search for `username` (if AUTH_LDAP_SEARCH is set)\n                #  - returns the `user_attributes`\n                #    needed for AUTH_USER_REGISTRATION/AUTH_ROLES_SYNC_AT_LOGIN\n                #  - we search on `username` not `bind_username`,\n                #    because AUTH_LDAP_APPEND_DOMAIN and AUTH_LDAP_USERNAME_FORMAT\n                #    would result in an invalid search filter\n                if self.auth_ldap_search:\n                    user_dn, user_attributes = self._search_ldap(ldap, con, username)\n\n                    # If search failed, go away\n                    if user_dn is None:\n                        log.info(LOGMSG_WAR_SEC_NOLDAP_OBJ.format(username))\n                        return None\n\n            # Sync the user's roles\n            if user and user_attributes and self.auth_roles_sync_at_login:\n                user.roles = self._ldap_calculate_user_roles(user_attributes)\n                log.debug(\n                    \"Calculated new roles for user='{0}' as: {1}\".format(\n                        user_dn, user.roles\n                    )\n                )\n\n            # If the user is new, register them\n            if (not user) and user_attributes and self.auth_user_registration:\n                user = self.add_user(\n                    username=username,\n                    first_name=self.ldap_extract(\n                        user_attributes, self.auth_ldap_firstname_field, \"\"\n                    ),\n                    last_name=self.ldap_extract(\n                        user_attributes, self.auth_ldap_lastname_field, \"\"\n                    ),\n                    email=self.ldap_extract(\n                        user_attributes,\n                        self.auth_ldap_email_field,\n                        f\"{username}@email.notfound\",\n                    ),\n                    role=self._ldap_calculate_user_roles(user_attributes),\n                )\n                log.debug(\"New user registered: {0}\".format(user))\n\n                # If user registration failed, go away\n                if not user:\n                    log.info(LOGMSG_ERR_SEC_ADD_REGISTER_USER.format(username))\n                    return None\n\n            # LOGIN SUCCESS (only if user is now registered)\n            if user:\n                self.update_user_auth_stat(user)\n                return user\n            else:\n                return None\n\n        except ldap.LDAPError as e:\n            msg = None\n            if isinstance(e, dict):\n                msg = getattr(e, \"message\", None)\n            if (msg is not None) and (\"desc\" in msg):\n                log.error(LOGMSG_ERR_SEC_AUTH_LDAP.format(e.message[\"desc\"]))\n                return None\n            else:\n                log.error(e)\n                return None\n\n    def auth_user_oid(self, email):\n        \"\"\"\n            OpenID user Authentication\n\n            :param email: user's email to authenticate\n            :type self: User model\n        \"\"\"\n        user = self.find_user(email=email)\n        if user is None or (not user.is_active):\n            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(email))\n            return None\n        else:\n            self.update_user_auth_stat(user)\n            return user\n\n    def auth_user_remote_user(self, username):\n        \"\"\"\n            REMOTE_USER user Authentication\n\n            :param username: user's username for remote auth\n            :type self: User model\n        \"\"\"\n        user = self.find_user(username=username)\n\n        # User does not exist, create one if auto user registration.\n        if user is None and self.auth_user_registration:\n            user = self.add_user(\n                # All we have is REMOTE_USER, so we set\n                # the other fields to blank.\n                username=username,\n                first_name=username,\n                last_name=\"-\",\n                email=username + \"@email.notfound\",\n                role=self.find_role(self.auth_user_registration_role),\n            )\n\n        # If user does not exist on the DB and not auto user registration,\n        # or user is inactive, go away.\n        elif user is None or (not user.is_active):\n            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(username))\n            return None\n\n        self.update_user_auth_stat(user)\n        return user\n\n    def _oauth_calculate_user_roles(self, userinfo) -> List[str]:\n        user_role_objects = []\n\n        # apply AUTH_ROLES_MAPPING\n        if len(self.auth_roles_mapping) > 0:\n            user_role_keys = userinfo.get(\"role_keys\", [])\n            user_role_objects += self.get_roles_from_keys(user_role_keys)\n\n        # apply AUTH_USER_REGISTRATION_ROLE\n        if self.auth_user_registration:\n            registration_role_name = self.auth_user_registration_role\n\n            # if AUTH_USER_REGISTRATION_ROLE_JMESPATH is set,\n            # use it for the registration role\n            if self.auth_user_registration_role_jmespath:\n                import jmespath\n\n                registration_role_name = jmespath.search(\n                    self.auth_user_registration_role_jmespath, userinfo\n                )\n\n            # lookup registration role in flask db\n            fab_role = self.find_role(registration_role_name)\n            if fab_role:\n                user_role_objects.append(fab_role)\n            else:\n                log.warning(\n                    \"Can't find AUTH_USER_REGISTRATION role: {0}\".format(\n                        registration_role_name\n                    )\n                )\n\n        return user_role_objects\n\n    def auth_user_oauth(self, userinfo):\n        \"\"\"\n            Method for authenticating user with OAuth.\n\n            :userinfo: dict with user information\n                       (keys are the same as User model columns)\n        \"\"\"\n        # extract the username from `userinfo`\n        if \"username\" in userinfo:\n            username = userinfo[\"username\"]\n        elif \"email\" in userinfo:\n            username = userinfo[\"email\"]\n        else:\n            log.error(\n                \"OAUTH userinfo does not have username or email {0}\".format(userinfo)\n            )\n            return None\n\n        # If username is empty, go away\n        if (username is None) or username == \"\":\n            return None\n\n        # Search the DB for this user\n        user = self.find_user(username=username)\n\n        # If user is not active, go away\n        if user and (not user.is_active):\n            return None\n\n        # If user is not registered, and not self-registration, go away\n        if (not user) and (not self.auth_user_registration):\n            return None\n\n        # Sync the user's roles\n        if user and self.auth_roles_sync_at_login:\n            user.roles = self._oauth_calculate_user_roles(userinfo)\n            log.debug(\n                \"Calculated new roles for user='{0}' as: {1}\".format(\n                    username, user.roles\n                )\n            )\n\n        # If the user is new, register them\n        if (not user) and self.auth_user_registration:\n            user = self.add_user(\n                username=username,\n                first_name=userinfo.get(\"first_name\", \"\"),\n                last_name=userinfo.get(\"last_name\", \"\"),\n                email=userinfo.get(\"email\", \"\") or f\"{username}@email.notfound\",\n                role=self._oauth_calculate_user_roles(userinfo),\n            )\n            log.debug(\"New user registered: {0}\".format(user))\n\n            # If user registration failed, go away\n            if not user:\n                log.error(\"Error creating a new OAuth user {0}\".format(username))\n                return None\n\n        # LOGIN SUCCESS (only if user is now registered)\n        if user:\n            self.update_user_auth_stat(user)\n            return user\n        else:\n            return None\n\n    \"\"\"\n        ----------------------------------------\n            PERMISSION ACCESS CHECK\n        ----------------------------------------\n    \"\"\"\n\n    def is_item_public(self, permission_name, view_name):\n        \"\"\"\n            Check if view has public permissions\n\n            :param permission_name:\n                the permission: can_show, can_edit...\n            :param view_name:\n                the name of the class view (child of BaseView)\n        \"\"\"\n        permissions = self.get_public_permissions()\n        if permissions:\n            for i in permissions:\n                if (view_name == i.view_menu.name) and (\n                    permission_name == i.permission.name\n                ):\n                    return True\n            return False\n        else:\n            return False\n\n    def _has_access_builtin_roles(\n        self, role, permission_name: str, view_name: str\n    ) -> bool:\n        \"\"\"\n            Checks permission on builtin role\n        \"\"\"\n        builtin_pvms = self.builtin_roles.get(role.name, [])\n        for pvm in builtin_pvms:\n            _view_name = pvm[0]\n            _permission_name = pvm[1]\n            if re.match(_view_name, view_name) and re.match(\n                _permission_name, permission_name\n            ):\n                return True\n        return False\n\n    def _has_view_access(\n        self, user: object, permission_name: str, view_name: str\n    ) -> bool:\n        roles = user.roles\n        db_role_ids = list()\n        # First check against builtin (statically configured) roles\n        # because no database query is needed\n        for role in roles:\n            if role.name in self.builtin_roles:\n                if self._has_access_builtin_roles(role, permission_name, view_name):\n                    return True\n            else:\n                db_role_ids.append(role.id)\n\n        # If it's not a builtin role check against database store roles\n        return self.exist_permission_on_roles(view_name, permission_name, db_role_ids)\n\n    def get_user_roles(self, user) -> List[object]:\n        \"\"\"\n        Get current user roles, if user is not authenticated returns the public role\n        \"\"\"\n        if not user.is_authenticated:\n            return [self.get_public_role()]\n        return user.roles\n\n    def get_role_permissions(self, role) -> Set[Tuple[str, str]]:\n        \"\"\"\n        Get all permissions for a certain role\n        \"\"\"\n        result = set()\n        if role.name in self.builtin_roles:\n            for permission in self.builtin_roles[role.name]:\n                result.add((permission[1], permission[0]))\n        else:\n            for permission in self.get_db_role_permissions(role.id):\n                result.add((permission.permission.name, permission.view_menu.name))\n        return result\n\n    def get_user_permissions(self, user) -> Set[Tuple[str, str]]:\n        \"\"\"\n        Get all permissions from the current user\n        \"\"\"\n        roles = self.get_user_roles(user)\n        result = set()\n        for role in roles:\n            result.update(self.get_role_permissions(role))\n        return result\n\n    def _get_user_permission_view_menus(\n        self, user: object, permission_name: str, view_menus_name: List[str]\n    ) -> Set[str]:\n        \"\"\"\n        Return a set of view menu names with a certain permission name\n        that a user has access to. Mainly used to fetch all menu permissions\n        on a single db call, will also check public permissions and builtin roles\n        \"\"\"\n        db_role_ids = list()\n        if user is None:\n            # include public role\n            roles = [self.get_public_role()]\n        else:\n            roles = user.roles\n        # First check against builtin (statically configured) roles\n        # because no database query is needed\n        result = set()\n        for role in roles:\n            if role.name in self.builtin_roles:\n                for view_menu_name in view_menus_name:\n                    if self._has_access_builtin_roles(\n                        role, permission_name, view_menu_name\n                    ):\n                        result.add(view_menu_name)\n            else:\n                db_role_ids.append(role.id)\n        # Then check against database-stored roles\n        pvms_names = [\n            pvm.view_menu.name\n            for pvm in self.find_roles_permission_view_menus(\n                permission_name, db_role_ids\n            )\n        ]\n        result.update(pvms_names)\n        return result\n\n    def has_access(self, permission_name, view_name):\n        \"\"\"\n        Check if current user or public has access to view or menu\n        \"\"\"\n        if current_user.is_authenticated:\n            return self._has_view_access(g.user, permission_name, view_name)\n        elif current_user_jwt:\n            return self._has_view_access(current_user_jwt, permission_name, view_name)\n        else:\n            return self.is_item_public(permission_name, view_name)\n\n    def get_user_menu_access(self, menu_names: List[str] = None) -> Set[str]:\n        if current_user.is_authenticated:\n            return self._get_user_permission_view_menus(\n                g.user, \"menu_access\", view_menus_name=menu_names\n            )\n        elif current_user_jwt:\n            return self._get_user_permission_view_menus(\n                current_user_jwt, \"menu_access\", view_menus_name=menu_names\n            )\n        else:\n            return self._get_user_permission_view_menus(\n                None, \"menu_access\", view_menus_name=menu_names\n            )\n\n    def add_permissions_view(self, base_permissions, view_menu):\n        \"\"\"\n        Adds a permission on a view menu to the backend\n\n        :param base_permissions:\n            list of permissions from view (all exposed methods):\n             'can_add','can_edit' etc...\n        :param view_menu:\n            name of the view or menu to add\n        \"\"\"\n        view_menu_db = self.add_view_menu(view_menu)\n        perm_views = self.find_permissions_view_menu(view_menu_db)\n\n        if not perm_views:\n            # No permissions yet on this view\n            for permission in base_permissions:\n                pv = self.add_permission_view_menu(permission, view_menu)\n                if self.auth_role_admin not in self.builtin_roles:\n                    role_admin = self.find_role(self.auth_role_admin)\n                    self.add_permission_role(role_admin, pv)\n        else:\n            # Permissions on this view exist but....\n            role_admin = self.find_role(self.auth_role_admin)\n            for permission in base_permissions:\n                # Check if base view permissions exist\n                if not self.exist_permission_on_views(perm_views, permission):\n                    pv = self.add_permission_view_menu(permission, view_menu)\n                    if self.auth_role_admin not in self.builtin_roles:\n                        self.add_permission_role(role_admin, pv)\n            for perm_view in perm_views:\n                if perm_view.permission is None:\n                    # Skip this perm_view, it has a null permission\n                    continue\n                if perm_view.permission.name not in base_permissions:\n                    # perm to delete\n                    roles = self.get_all_roles()\n                    perm = self.find_permission(perm_view.permission.name)\n                    # del permission from all roles\n                    for role in roles:\n                        self.del_permission_role(role, perm)\n                    self.del_permission_view_menu(perm_view.permission.name, view_menu)\n                elif (\n                    self.auth_role_admin not in self.builtin_roles\n                    and perm_view not in role_admin.permissions\n                ):\n                    # Role Admin must have all permissions\n                    self.add_permission_role(role_admin, perm_view)\n\n    def add_permissions_menu(self, view_menu_name):\n        \"\"\"\n        Adds menu_access to menu on permission_view_menu\n\n        :param view_menu_name:\n            The menu name\n        \"\"\"\n        self.add_view_menu(view_menu_name)\n        pv = self.find_permission_view_menu(\"menu_access\", view_menu_name)\n        if not pv:\n            pv = self.add_permission_view_menu(\"menu_access\", view_menu_name)\n        if self.auth_role_admin not in self.builtin_roles:\n            role_admin = self.find_role(self.auth_role_admin)\n            self.add_permission_role(role_admin, pv)\n\n    def security_cleanup(self, baseviews, menus):\n        \"\"\"\n        Will cleanup all unused permissions from the database\n\n        :param baseviews: A list of BaseViews class\n        :param menus: Menu class\n        \"\"\"\n        viewsmenus = self.get_all_view_menu()\n        roles = self.get_all_roles()\n        for viewmenu in viewsmenus:\n            found = False\n            for baseview in baseviews:\n                if viewmenu.name == baseview.class_permission_name:\n                    found = True\n                    break\n            if menus.find(viewmenu.name):\n                found = True\n            if not found:\n                permissions = self.find_permissions_view_menu(viewmenu)\n                for permission in permissions:\n                    for role in roles:\n                        self.del_permission_role(role, permission)\n                    self.del_permission_view_menu(\n                        permission.permission.name, viewmenu.name\n                    )\n                self.del_view_menu(viewmenu.name)\n        self.security_converge(baseviews, menus)\n\n    @staticmethod\n    def _get_new_old_permissions(baseview) -> Dict:\n        ret = dict()\n        for method_name, permission_name in baseview.method_permission_name.items():\n            old_permission_name = baseview.previous_method_permission_name.get(\n                method_name\n            )\n            # Actions do not get prefix when normally defined\n            if hasattr(baseview, \"actions\") and baseview.actions.get(\n                old_permission_name\n            ):\n                permission_prefix = \"\"\n            else:\n                permission_prefix = PERMISSION_PREFIX\n            if old_permission_name:\n                if PERMISSION_PREFIX + permission_name not in ret:\n                    ret[PERMISSION_PREFIX + permission_name] = {\n                        permission_prefix + old_permission_name\n                    }\n                else:\n                    ret[PERMISSION_PREFIX + permission_name].add(\n                        permission_prefix + old_permission_name\n                    )\n        return ret\n\n    @staticmethod\n    def _add_state_transition(\n        state_transition: Dict,\n        old_view_name: str,\n        old_perm_name: str,\n        view_name: str,\n        perm_name: str,\n    ) -> None:\n        old_pvm = state_transition[\"add\"].get((old_view_name, old_perm_name))\n        if old_pvm:\n            state_transition[\"add\"][(old_view_name, old_perm_name)].add(\n                (view_name, perm_name)\n            )\n        else:\n            state_transition[\"add\"][(old_view_name, old_perm_name)] = {\n                (view_name, perm_name)\n            }\n        state_transition[\"del_role_pvm\"].add((old_view_name, old_perm_name))\n        state_transition[\"del_views\"].add(old_view_name)\n        state_transition[\"del_perms\"].add(old_perm_name)\n\n    @staticmethod\n    def _update_del_transitions(state_transitions: Dict, baseviews: List) -> None:\n        \"\"\"\n        Mutates state_transitions, loop baseviews and prunes all\n        views and permissions that are not to delete because references\n        exist.\n\n        :param baseview:\n        :param state_transitions:\n        :return:\n        \"\"\"\n        for baseview in baseviews:\n            state_transitions[\"del_views\"].discard(baseview.class_permission_name)\n            for permission in baseview.base_permissions:\n                state_transitions[\"del_role_pvm\"].discard(\n                    (baseview.class_permission_name, permission)\n                )\n                state_transitions[\"del_perms\"].discard(permission)\n\n    def create_state_transitions(self, baseviews: List, menus: List) -> Dict:\n        \"\"\"\n        Creates a Dict with all the necessary vm/permission transitions\n\n        Dict: {\n                \"add\": {(<VM>, <PERM>): ((<VM>, PERM), ... )}\n                \"del_role_pvm\": ((<VM>, <PERM>), ...)\n                \"del_views\": (<VM>, ... )\n                \"del_perms\": (<PERM>, ... )\n              }\n\n        :param baseviews: List with all the registered BaseView, BaseApi\n        :param menus: List with all the menu entries\n        :return: Dict with state transitions\n        \"\"\"\n        state_transitions = {\n            \"add\": {},\n            \"del_role_pvm\": set(),\n            \"del_views\": set(),\n            \"del_perms\": set(),\n        }\n        for baseview in baseviews:\n            add_all_flag = False\n            new_view_name = baseview.class_permission_name\n            permission_mapping = self._get_new_old_permissions(baseview)\n            if baseview.previous_class_permission_name:\n                old_view_name = baseview.previous_class_permission_name\n                add_all_flag = True\n            else:\n                new_view_name = baseview.class_permission_name\n                old_view_name = new_view_name\n            for new_perm_name in baseview.base_permissions:\n                if add_all_flag:\n                    old_perm_names = permission_mapping.get(new_perm_name)\n                    old_perm_names = old_perm_names or (new_perm_name,)\n                    for old_perm_name in old_perm_names:\n                        self._add_state_transition(\n                            state_transitions,\n                            old_view_name,\n                            old_perm_name,\n                            new_view_name,\n                            new_perm_name,\n                        )\n                else:\n                    old_perm_names = permission_mapping.get(new_perm_name) or set()\n                    for old_perm_name in old_perm_names:\n                        self._add_state_transition(\n                            state_transitions,\n                            old_view_name,\n                            old_perm_name,\n                            new_view_name,\n                            new_perm_name,\n                        )\n        self._update_del_transitions(state_transitions, baseviews)\n        return state_transitions\n\n    def security_converge(self, baseviews: List, menus: List, dry=False) -> Dict:\n        \"\"\"\n        Converges overridden permissions on all registered views/api\n        will compute all necessary operations from `class_permissions_name`,\n        `previous_class_permission_name`, method_permission_name`,\n        `previous_method_permission_name` class attributes.\n\n        :param baseviews: List of registered views/apis\n        :param menus: List of menu items\n        :param dry: If True will not change DB\n        :return: Dict with the necessary operations (state_transitions)\n        \"\"\"\n        state_transitions = self.create_state_transitions(baseviews, menus)\n        if dry:\n            return state_transitions\n        if not state_transitions:\n            log.info(\"No state transitions found\")\n            return dict()\n        log.debug(f\"State transitions: {state_transitions}\")\n        roles = self.get_all_roles()\n        for role in roles:\n            permissions = list(role.permissions)\n            for pvm in permissions:\n                new_pvm_states = state_transitions[\"add\"].get(\n                    (pvm.view_menu.name, pvm.permission.name)\n                )\n                if not new_pvm_states:\n                    continue\n                for new_pvm_state in new_pvm_states:\n                    new_pvm = self.add_permission_view_menu(\n                        new_pvm_state[1], new_pvm_state[0]\n                    )\n                    self.add_permission_role(role, new_pvm)\n                if (pvm.view_menu.name, pvm.permission.name) in state_transitions[\n                    \"del_role_pvm\"\n                ]:\n                    self.del_permission_role(role, pvm)\n        for pvm in state_transitions[\"del_role_pvm\"]:\n            self.del_permission_view_menu(pvm[1], pvm[0], cascade=False)\n        for view_name in state_transitions[\"del_views\"]:\n            self.del_view_menu(view_name)\n        for permission_name in state_transitions[\"del_perms\"]:\n            self.del_permission(permission_name)\n        return state_transitions\n\n    \"\"\"\n     ---------------------------\n     INTERFACE ABSTRACT METHODS\n     ---------------------------\n\n     ---------------------\n     PRIMITIVES FOR USERS\n    ----------------------\n    \"\"\"\n\n    def find_register_user(self, registration_hash):\n        \"\"\"\n            Generic function to return user registration\n        \"\"\"\n        raise NotImplementedError\n\n    def add_register_user(\n        self, username, first_name, last_name, email, password=\"\", hashed_password=\"\"\n    ):\n        \"\"\"\n            Generic function to add user registration\n        \"\"\"\n        raise NotImplementedError\n\n    def del_register_user(self, register_user):\n        \"\"\"\n            Generic function to delete user registration\n        \"\"\"\n        raise NotImplementedError\n\n    def get_user_by_id(self, pk):\n        \"\"\"\n            Generic function to return user by it's id (pk)\n        \"\"\"\n        raise NotImplementedError\n\n    def find_user(self, username=None, email=None):\n        \"\"\"\n            Generic function find a user by it's username or email\n        \"\"\"\n        raise NotImplementedError\n\n    def get_all_users(self):\n        \"\"\"\n            Generic function that returns all existing users\n        \"\"\"\n        raise NotImplementedError\n\n    def get_db_role_permissions(self, role_id: int) -> List[object]:\n        \"\"\"\n        Get all DB permissions from a role id\n        \"\"\"\n        raise NotImplementedError\n\n    def add_user(self, username, first_name, last_name, email, role, password=\"\"):\n        \"\"\"\n            Generic function to create user\n        \"\"\"\n        raise NotImplementedError\n\n    def update_user(self, user):\n        \"\"\"\n            Generic function to update user\n\n            :param user: User model to update to database\n        \"\"\"\n        raise NotImplementedError\n\n    def count_users(self):\n        \"\"\"\n            Generic function to count the existing users\n        \"\"\"\n        raise NotImplementedError\n\n    \"\"\"\n    ----------------------\n     PRIMITIVES FOR ROLES\n    ----------------------\n    \"\"\"\n\n    def find_role(self, name):\n        raise NotImplementedError\n\n    def add_role(self, name):\n        raise NotImplementedError\n\n    def update_role(self, pk, name):\n        raise NotImplementedError\n\n    def get_all_roles(self):\n        raise NotImplementedError\n\n    \"\"\"\n    ----------------------------\n     PRIMITIVES FOR PERMISSIONS\n    ----------------------------\n    \"\"\"\n\n    def get_public_role(self):\n        \"\"\"\n            returns all permissions from public role\n        \"\"\"\n        raise NotImplementedError\n\n    def get_public_permissions(self):\n        \"\"\"\n            returns all permissions from public role\n        \"\"\"\n        raise NotImplementedError\n\n    def find_permission(self, name):\n        \"\"\"\n            Finds and returns a Permission by name\n        \"\"\"\n        raise NotImplementedError\n\n    def find_roles_permission_view_menus(\n        self, permission_name: str, role_ids: List[int]\n    ):\n        raise NotImplementedError\n\n    def exist_permission_on_roles(\n        self, view_name: str, permission_name: str, role_ids: List[int]\n    ) -> bool:\n        \"\"\"\n            Finds and returns permission views for a group of roles\n        \"\"\"\n        raise NotImplementedError\n\n    def add_permission(self, name):\n        \"\"\"\n            Adds a permission to the backend, model permission\n\n            :param name:\n                name of the permission: 'can_add','can_edit' etc...\n        \"\"\"\n        raise NotImplementedError\n\n    def del_permission(self, name):\n        \"\"\"\n            Deletes a permission from the backend, model permission\n\n            :param name:\n                name of the permission: 'can_add','can_edit' etc...\n        \"\"\"\n        raise NotImplementedError\n\n    \"\"\"\n    ----------------------\n     PRIMITIVES VIEW MENU\n    ----------------------\n    \"\"\"\n\n    def find_view_menu(self, name):\n        \"\"\"\n            Finds and returns a ViewMenu by name\n        \"\"\"\n        raise NotImplementedError\n\n    def get_all_view_menu(self):\n        raise NotImplementedError\n\n    def add_view_menu(self, name):\n        \"\"\"\n            Adds a view or menu to the backend, model view_menu\n            param name:\n                name of the view menu to add\n        \"\"\"\n        raise NotImplementedError\n\n    def del_view_menu(self, name):\n        \"\"\"\n            Deletes a ViewMenu from the backend\n\n            :param name:\n                name of the ViewMenu\n        \"\"\"\n        raise NotImplementedError\n\n    \"\"\"\n    ----------------------\n     PERMISSION VIEW MENU\n    ----------------------\n    \"\"\"\n\n    def find_permission_view_menu(self, permission_name, view_menu_name):\n        \"\"\"\n            Finds and returns a PermissionView by names\n        \"\"\"\n        raise NotImplementedError\n\n    def find_permissions_view_menu(self, view_menu):\n        \"\"\"\n            Finds all permissions from ViewMenu, returns list of PermissionView\n\n            :param view_menu: ViewMenu object\n            :return: list of PermissionView objects\n        \"\"\"\n        raise NotImplementedError\n\n    def add_permission_view_menu(self, permission_name, view_menu_name):\n        \"\"\"\n            Adds a permission on a view or menu to the backend\n\n            :param permission_name:\n                name of the permission to add: 'can_add','can_edit' etc...\n            :param view_menu_name:\n                name of the view menu to add\n        \"\"\"\n        raise NotImplementedError\n\n    def del_permission_view_menu(self, permission_name, view_menu_name, cascade=True):\n        raise NotImplementedError\n\n    def exist_permission_on_views(self, lst, item):\n        raise NotImplementedError\n\n    def exist_permission_on_view(self, lst, permission, view_menu):\n        raise NotImplementedError\n\n    def add_permission_role(self, role, perm_view):\n        \"\"\"\n            Add permission-ViewMenu object to Role\n\n            :param role:\n                The role object\n            :param perm_view:\n                The PermissionViewMenu object\n        \"\"\"\n        raise NotImplementedError\n\n    def del_permission_role(self, role, perm_view):\n        \"\"\"\n            Remove permission-ViewMenu object to Role\n\n            :param role:\n                The role object\n            :param perm_view:\n                The PermissionViewMenu object\n        \"\"\"\n        raise NotImplementedError\n\n    def load_user(self, pk):\n        return self.get_user_by_id(int(pk))\n\n    def load_user_jwt(self, pk):\n        user = self.load_user(pk)\n        # Set flask g.user to JWT user, we can't do it on before request\n        g.user = user\n        return user\n\n    @staticmethod\n    def before_request():\n        g.user = current_user\n"], "fixing_code": ["import base64\nimport datetime\nimport json\nimport logging\nimport re\nfrom typing import Dict, List, Set, Tuple\n\nfrom flask import g, session, url_for\nfrom flask_babel import lazy_gettext as _\nfrom flask_jwt_extended import current_user as current_user_jwt\nfrom flask_jwt_extended import JWTManager\nfrom flask_login import current_user, LoginManager\nfrom werkzeug.security import check_password_hash, generate_password_hash\n\nfrom .api import SecurityApi\nfrom .registerviews import (\n    RegisterUserDBView,\n    RegisterUserOAuthView,\n    RegisterUserOIDView,\n)\nfrom .views import (\n    AuthDBView,\n    AuthLDAPView,\n    AuthOAuthView,\n    AuthOIDView,\n    AuthRemoteUserView,\n    PermissionModelView,\n    PermissionViewModelView,\n    RegisterUserModelView,\n    ResetMyPasswordView,\n    ResetPasswordView,\n    RoleModelView,\n    UserDBModelView,\n    UserInfoEditView,\n    UserLDAPModelView,\n    UserOAuthModelView,\n    UserOIDModelView,\n    UserRemoteUserModelView,\n    UserStatsChartView,\n    ViewMenuModelView,\n)\nfrom ..basemanager import BaseManager\nfrom ..const import (\n    AUTH_DB,\n    AUTH_LDAP,\n    AUTH_OAUTH,\n    AUTH_OID,\n    AUTH_REMOTE_USER,\n    LOGMSG_ERR_SEC_ADD_REGISTER_USER,\n    LOGMSG_ERR_SEC_AUTH_LDAP,\n    LOGMSG_ERR_SEC_AUTH_LDAP_TLS,\n    LOGMSG_WAR_SEC_LOGIN_FAILED,\n    LOGMSG_WAR_SEC_NO_USER,\n    LOGMSG_WAR_SEC_NOLDAP_OBJ,\n    PERMISSION_PREFIX,\n)\n\nlog = logging.getLogger(__name__)\n\n\nclass AbstractSecurityManager(BaseManager):\n    \"\"\"\n        Abstract SecurityManager class, declares all methods used by the\n        framework. There is no assumptions about security models or auth types.\n    \"\"\"\n\n    def add_permissions_view(self, base_permissions, view_menu):\n        \"\"\"\n            Adds a permission on a view menu to the backend\n\n            :param base_permissions:\n                list of permissions from view (all exposed methods):\n                 'can_add','can_edit' etc...\n            :param view_menu:\n                name of the view or menu to add\n        \"\"\"\n        raise NotImplementedError\n\n    def add_permissions_menu(self, view_menu_name):\n        \"\"\"\n            Adds menu_access to menu on permission_view_menu\n\n            :param view_menu_name:\n                The menu name\n        \"\"\"\n        raise NotImplementedError\n\n    def register_views(self):\n        \"\"\"\n            Generic function to create the security views\n        \"\"\"\n        raise NotImplementedError\n\n    def is_item_public(self, permission_name, view_name):\n        \"\"\"\n            Check if view has public permissions\n\n            :param permission_name:\n                the permission: can_show, can_edit...\n            :param view_name:\n                the name of the class view (child of BaseView)\n        \"\"\"\n        raise NotImplementedError\n\n    def has_access(self, permission_name, view_name):\n        \"\"\"\n            Check if current user or public has access to view or menu\n        \"\"\"\n        raise NotImplementedError\n\n    def security_cleanup(self, baseviews, menus):\n        raise NotImplementedError\n\n\ndef _oauth_tokengetter(token=None):\n    \"\"\"\n        Default function to return the current user oauth token\n        from session cookie.\n    \"\"\"\n    token = session.get(\"oauth\")\n    log.debug(\"Token Get: {0}\".format(token))\n    return token\n\n\nclass BaseSecurityManager(AbstractSecurityManager):\n    auth_view = None\n    \"\"\" The obj instance for authentication view \"\"\"\n    user_view = None\n    \"\"\" The obj instance for user view \"\"\"\n    registeruser_view = None\n    \"\"\" The obj instance for registering user view \"\"\"\n    lm = None\n    \"\"\" Flask-Login LoginManager \"\"\"\n    jwt_manager = None\n    \"\"\" Flask-JWT-Extended \"\"\"\n    oid = None\n    \"\"\" Flask-OpenID OpenID \"\"\"\n    oauth = None\n    \"\"\" Flask-OAuth \"\"\"\n    oauth_remotes = None\n    \"\"\" OAuth email whitelists \"\"\"\n    oauth_whitelists = {}\n    \"\"\" Initialized (remote_app) providers dict {'provider_name', OBJ } \"\"\"\n    oauth_tokengetter = _oauth_tokengetter\n    \"\"\" OAuth tokengetter function override to implement your own tokengetter method \"\"\"\n    oauth_user_info = None\n\n    user_model = None\n    \"\"\" Override to set your own User Model \"\"\"\n    role_model = None\n    \"\"\" Override to set your own Role Model \"\"\"\n    permission_model = None\n    \"\"\" Override to set your own Permission Model \"\"\"\n    viewmenu_model = None\n    \"\"\" Override to set your own ViewMenu Model \"\"\"\n    permissionview_model = None\n    \"\"\" Override to set your own PermissionView Model \"\"\"\n    registeruser_model = None\n    \"\"\" Override to set your own RegisterUser Model \"\"\"\n\n    userdbmodelview = UserDBModelView\n    \"\"\" Override if you want your own user db view \"\"\"\n    userldapmodelview = UserLDAPModelView\n    \"\"\" Override if you want your own user ldap view \"\"\"\n    useroidmodelview = UserOIDModelView\n    \"\"\" Override if you want your own user OID view \"\"\"\n    useroauthmodelview = UserOAuthModelView\n    \"\"\" Override if you want your own user OAuth view \"\"\"\n    userremoteusermodelview = UserRemoteUserModelView\n    \"\"\" Override if you want your own user REMOTE_USER view \"\"\"\n    registerusermodelview = RegisterUserModelView\n\n    authdbview = AuthDBView\n    \"\"\" Override if you want your own Authentication DB view \"\"\"\n    authldapview = AuthLDAPView\n    \"\"\" Override if you want your own Authentication LDAP view \"\"\"\n    authoidview = AuthOIDView\n    \"\"\" Override if you want your own Authentication OID view \"\"\"\n    authoauthview = AuthOAuthView\n    \"\"\" Override if you want your own Authentication OAuth view \"\"\"\n    authremoteuserview = AuthRemoteUserView\n    \"\"\" Override if you want your own Authentication REMOTE_USER view \"\"\"\n\n    registeruserdbview = RegisterUserDBView\n    \"\"\" Override if you want your own register user db view \"\"\"\n    registeruseroidview = RegisterUserOIDView\n    \"\"\" Override if you want your own register user OpenID view \"\"\"\n    registeruseroauthview = RegisterUserOAuthView\n    \"\"\" Override if you want your own register user OAuth view \"\"\"\n\n    resetmypasswordview = ResetMyPasswordView\n    \"\"\" Override if you want your own reset my password view \"\"\"\n    resetpasswordview = ResetPasswordView\n    \"\"\" Override if you want your own reset password view \"\"\"\n    userinfoeditview = UserInfoEditView\n    \"\"\" Override if you want your own User information edit view \"\"\"\n\n    # API\n    security_api = SecurityApi\n    \"\"\" Override if you want your own Security API login endpoint \"\"\"\n\n    rolemodelview = RoleModelView\n    permissionmodelview = PermissionModelView\n    userstatschartview = UserStatsChartView\n    viewmenumodelview = ViewMenuModelView\n    permissionviewmodelview = PermissionViewModelView\n\n    def __init__(self, appbuilder):\n        super(BaseSecurityManager, self).__init__(appbuilder)\n        app = self.appbuilder.get_app\n        # Base Security Config\n        app.config.setdefault(\"AUTH_ROLE_ADMIN\", \"Admin\")\n        app.config.setdefault(\"AUTH_ROLE_PUBLIC\", \"Public\")\n        app.config.setdefault(\"AUTH_TYPE\", AUTH_DB)\n        # Self Registration\n        app.config.setdefault(\"AUTH_USER_REGISTRATION\", False)\n        app.config.setdefault(\"AUTH_USER_REGISTRATION_ROLE\", self.auth_role_public)\n        app.config.setdefault(\"AUTH_USER_REGISTRATION_ROLE_JMESPATH\", None)\n        # Role Mapping\n        app.config.setdefault(\"AUTH_ROLES_MAPPING\", {})\n        app.config.setdefault(\"AUTH_ROLES_SYNC_AT_LOGIN\", False)\n\n        # LDAP Config\n        if self.auth_type == AUTH_LDAP:\n            if \"AUTH_LDAP_SERVER\" not in app.config:\n                raise Exception(\n                    \"No AUTH_LDAP_SERVER defined on config\"\n                    \" with AUTH_LDAP authentication type.\"\n                )\n            app.config.setdefault(\"AUTH_LDAP_SEARCH\", \"\")\n            app.config.setdefault(\"AUTH_LDAP_SEARCH_FILTER\", \"\")\n            app.config.setdefault(\"AUTH_LDAP_APPEND_DOMAIN\", \"\")\n            app.config.setdefault(\"AUTH_LDAP_USERNAME_FORMAT\", \"\")\n            app.config.setdefault(\"AUTH_LDAP_BIND_USER\", \"\")\n            app.config.setdefault(\"AUTH_LDAP_BIND_PASSWORD\", \"\")\n            # TLS options\n            app.config.setdefault(\"AUTH_LDAP_USE_TLS\", False)\n            app.config.setdefault(\"AUTH_LDAP_ALLOW_SELF_SIGNED\", False)\n            app.config.setdefault(\"AUTH_LDAP_TLS_DEMAND\", False)\n            app.config.setdefault(\"AUTH_LDAP_TLS_CACERTDIR\", \"\")\n            app.config.setdefault(\"AUTH_LDAP_TLS_CACERTFILE\", \"\")\n            app.config.setdefault(\"AUTH_LDAP_TLS_CERTFILE\", \"\")\n            app.config.setdefault(\"AUTH_LDAP_TLS_KEYFILE\", \"\")\n            # Mapping options\n            app.config.setdefault(\"AUTH_LDAP_UID_FIELD\", \"uid\")\n            app.config.setdefault(\"AUTH_LDAP_GROUP_FIELD\", \"memberOf\")\n            app.config.setdefault(\"AUTH_LDAP_FIRSTNAME_FIELD\", \"givenName\")\n            app.config.setdefault(\"AUTH_LDAP_LASTNAME_FIELD\", \"sn\")\n            app.config.setdefault(\"AUTH_LDAP_EMAIL_FIELD\", \"mail\")\n\n        if self.auth_type == AUTH_OID:\n            from flask_openid import OpenID\n\n            self.oid = OpenID(app)\n        if self.auth_type == AUTH_OAUTH:\n            from authlib.integrations.flask_client import OAuth\n\n            self.oauth = OAuth(app)\n            self.oauth_remotes = dict()\n            for _provider in self.oauth_providers:\n                provider_name = _provider[\"name\"]\n                log.debug(\"OAuth providers init {0}\".format(provider_name))\n                obj_provider = self.oauth.register(\n                    provider_name, **_provider[\"remote_app\"]\n                )\n                obj_provider._tokengetter = self.oauth_tokengetter\n                if not self.oauth_user_info:\n                    self.oauth_user_info = self.get_oauth_user_info\n                # Whitelist only users with matching emails\n                if \"whitelist\" in _provider:\n                    self.oauth_whitelists[provider_name] = _provider[\"whitelist\"]\n                self.oauth_remotes[provider_name] = obj_provider\n\n        self._builtin_roles = self.create_builtin_roles()\n        # Setup Flask-Login\n        self.lm = self.create_login_manager(app)\n\n        # Setup Flask-Jwt-Extended\n        self.jwt_manager = self.create_jwt_manager(app)\n\n    def create_login_manager(self, app) -> LoginManager:\n        \"\"\"\n            Override to implement your custom login manager instance\n\n            :param app: Flask app\n        \"\"\"\n        lm = LoginManager(app)\n        lm.login_view = \"login\"\n        lm.user_loader(self.load_user)\n        return lm\n\n    def create_jwt_manager(self, app) -> JWTManager:\n        \"\"\"\n            Override to implement your custom JWT manager instance\n\n            :param app: Flask app\n        \"\"\"\n        jwt_manager = JWTManager()\n        jwt_manager.init_app(app)\n        jwt_manager.user_loader_callback_loader(self.load_user_jwt)\n        return jwt_manager\n\n    def create_builtin_roles(self):\n        return self.appbuilder.get_app.config.get(\"FAB_ROLES\", {})\n\n    def get_roles_from_keys(self, role_keys: List[str]) -> List[role_model]:\n        \"\"\"\n        Construct a list of FAB role objects, from a list of keys.\n\n        NOTE:\n        - keys are things like: \"LDAP group DNs\" or \"OAUTH group names\"\n        - we use AUTH_ROLES_MAPPING to map from keys, to FAB role names\n\n        :param role_keys: the list of FAB role keys\n        :return: a list of RoleModelView\n        \"\"\"\n        _roles = []\n        _role_keys = set(role_keys)\n        for role_key, fab_role_names in self.auth_roles_mapping.items():\n            if role_key in _role_keys:\n                for fab_role_name in fab_role_names:\n                    fab_role = self.find_role(fab_role_name)\n                    if fab_role:\n                        _roles.append(fab_role)\n                    else:\n                        log.warning(\n                            \"Can't find role specified in AUTH_ROLES_MAPPING: {0}\".format(\n                                fab_role_name\n                            )\n                        )\n        return _roles\n\n    @property\n    def get_url_for_registeruser(self):\n        return url_for(\n            \"%s.%s\"\n            % (self.registeruser_view.endpoint, self.registeruser_view.default_view)\n        )\n\n    @property\n    def get_user_datamodel(self):\n        return self.user_view.datamodel\n\n    @property\n    def get_register_user_datamodel(self):\n        return self.registerusermodelview.datamodel\n\n    @property\n    def builtin_roles(self):\n        return self._builtin_roles\n\n    @property\n    def auth_type(self):\n        return self.appbuilder.get_app.config[\"AUTH_TYPE\"]\n\n    @property\n    def auth_username_ci(self):\n        return self.appbuilder.get_app.config.get(\"AUTH_USERNAME_CI\", True)\n\n    @property\n    def auth_role_admin(self):\n        return self.appbuilder.get_app.config[\"AUTH_ROLE_ADMIN\"]\n\n    @property\n    def auth_role_public(self):\n        return self.appbuilder.get_app.config[\"AUTH_ROLE_PUBLIC\"]\n\n    @property\n    def auth_ldap_server(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_SERVER\"]\n\n    @property\n    def auth_ldap_use_tls(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_USE_TLS\"]\n\n    @property\n    def auth_user_registration(self):\n        return self.appbuilder.get_app.config[\"AUTH_USER_REGISTRATION\"]\n\n    @property\n    def auth_user_registration_role(self):\n        return self.appbuilder.get_app.config[\"AUTH_USER_REGISTRATION_ROLE\"]\n\n    @property\n    def auth_user_registration_role_jmespath(self) -> str:\n        return self.appbuilder.get_app.config[\"AUTH_USER_REGISTRATION_ROLE_JMESPATH\"]\n\n    @property\n    def auth_roles_mapping(self) -> Dict[str, List[str]]:\n        return self.appbuilder.get_app.config[\"AUTH_ROLES_MAPPING\"]\n\n    @property\n    def auth_roles_sync_at_login(self) -> bool:\n        return self.appbuilder.get_app.config[\"AUTH_ROLES_SYNC_AT_LOGIN\"]\n\n    @property\n    def auth_ldap_search(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_SEARCH\"]\n\n    @property\n    def auth_ldap_search_filter(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_SEARCH_FILTER\"]\n\n    @property\n    def auth_ldap_bind_user(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_BIND_USER\"]\n\n    @property\n    def auth_ldap_bind_password(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_BIND_PASSWORD\"]\n\n    @property\n    def auth_ldap_append_domain(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_APPEND_DOMAIN\"]\n\n    @property\n    def auth_ldap_username_format(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_USERNAME_FORMAT\"]\n\n    @property\n    def auth_ldap_uid_field(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_UID_FIELD\"]\n\n    @property\n    def auth_ldap_group_field(self) -> str:\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_GROUP_FIELD\"]\n\n    @property\n    def auth_ldap_firstname_field(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_FIRSTNAME_FIELD\"]\n\n    @property\n    def auth_ldap_lastname_field(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_LASTNAME_FIELD\"]\n\n    @property\n    def auth_ldap_email_field(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_EMAIL_FIELD\"]\n\n    @property\n    def auth_ldap_bind_first(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_BIND_FIRST\"]\n\n    @property\n    def auth_ldap_allow_self_signed(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_ALLOW_SELF_SIGNED\"]\n\n    @property\n    def auth_ldap_tls_demand(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_DEMAND\"]\n\n    @property\n    def auth_ldap_tls_cacertdir(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_CACERTDIR\"]\n\n    @property\n    def auth_ldap_tls_cacertfile(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_CACERTFILE\"]\n\n    @property\n    def auth_ldap_tls_certfile(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_CERTFILE\"]\n\n    @property\n    def auth_ldap_tls_keyfile(self):\n        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_KEYFILE\"]\n\n    @property\n    def openid_providers(self):\n        return self.appbuilder.get_app.config[\"OPENID_PROVIDERS\"]\n\n    @property\n    def oauth_providers(self):\n        return self.appbuilder.get_app.config[\"OAUTH_PROVIDERS\"]\n\n    @property\n    def current_user(self):\n        if current_user.is_authenticated:\n            return g.user\n        elif current_user_jwt:\n            return current_user_jwt\n\n    def oauth_user_info_getter(self, f):\n        \"\"\"\n            Decorator function to be the OAuth user info getter\n            for all the providers, receives provider and response\n            return a dict with the information returned from the provider.\n            The returned user info dict should have it's keys with the same\n            name as the User Model.\n\n            Use it like this an example for GitHub ::\n\n                @appbuilder.sm.oauth_user_info_getter\n                def my_oauth_user_info(sm, provider, response=None):\n                    if provider == 'github':\n                        me = sm.oauth_remotes[provider].get('user')\n                        return {'username': me.data.get('login')}\n                    else:\n                        return {}\n        \"\"\"\n\n        def wraps(provider, response=None):\n            ret = f(self, provider, response=response)\n            # Checks if decorator is well behaved and returns a dict as supposed.\n            if not type(ret) == dict:\n                log.error(\n                    \"OAuth user info decorated function \"\n                    \"did not returned a dict, but: {0}\".format(type(ret))\n                )\n                return {}\n            return ret\n\n        self.oauth_user_info = wraps\n        return wraps\n\n    def get_oauth_token_key_name(self, provider):\n        \"\"\"\n            Returns the token_key name for the oauth provider\n            if none is configured defaults to oauth_token\n            this is configured using OAUTH_PROVIDERS and token_key key.\n        \"\"\"\n        for _provider in self.oauth_providers:\n            if _provider[\"name\"] == provider:\n                return _provider.get(\"token_key\", \"oauth_token\")\n\n    def get_oauth_token_secret_name(self, provider):\n        \"\"\"\n            Returns the token_secret name for the oauth provider\n            if none is configured defaults to oauth_secret\n            this is configured using OAUTH_PROVIDERS and token_secret\n        \"\"\"\n        for _provider in self.oauth_providers:\n            if _provider[\"name\"] == provider:\n                return _provider.get(\"token_secret\", \"oauth_token_secret\")\n\n    def set_oauth_session(self, provider, oauth_response):\n        \"\"\"\n            Set the current session with OAuth user secrets\n        \"\"\"\n        # Get this provider key names for token_key and token_secret\n        token_key = self.appbuilder.sm.get_oauth_token_key_name(provider)\n        token_secret = self.appbuilder.sm.get_oauth_token_secret_name(provider)\n        # Save users token on encrypted session cookie\n        session[\"oauth\"] = (\n            oauth_response[token_key],\n            oauth_response.get(token_secret, \"\"),\n        )\n        session[\"oauth_provider\"] = provider\n\n    def get_oauth_user_info(self, provider, resp):\n        \"\"\"\n            Since there are different OAuth API's with different ways to\n            retrieve user info\n        \"\"\"\n        # for GITHUB\n        if provider == \"github\" or provider == \"githublocal\":\n            me = self.appbuilder.sm.oauth_remotes[provider].get(\"user\")\n            data = me.json()\n            log.debug(\"User info from Github: {0}\".format(data))\n            return {\"username\": \"github_\" + data.get(\"login\")}\n        # for twitter\n        if provider == \"twitter\":\n            me = self.appbuilder.sm.oauth_remotes[provider].get(\"account/settings.json\")\n            data = me.json()\n            log.debug(\"User info from Twitter: {0}\".format(data))\n            return {\"username\": \"twitter_\" + data.get(\"screen_name\", \"\")}\n        # for linkedin\n        if provider == \"linkedin\":\n            me = self.appbuilder.sm.oauth_remotes[provider].get(\n                \"people/~:(id,email-address,first-name,last-name)?format=json\"\n            )\n            data = me.json()\n            log.debug(\"User info from Linkedin: {0}\".format(data))\n            return {\n                \"username\": \"linkedin_\" + data.get(\"id\", \"\"),\n                \"email\": data.get(\"email-address\", \"\"),\n                \"first_name\": data.get(\"firstName\", \"\"),\n                \"last_name\": data.get(\"lastName\", \"\"),\n            }\n        # for Google\n        if provider == \"google\":\n            me = self.appbuilder.sm.oauth_remotes[provider].get(\"userinfo\")\n            data = me.json()\n            log.debug(\"User info from Google: {0}\".format(data))\n            return {\n                \"username\": \"google_\" + data.get(\"id\", \"\"),\n                \"first_name\": data.get(\"given_name\", \"\"),\n                \"last_name\": data.get(\"family_name\", \"\"),\n                \"email\": data.get(\"email\", \"\"),\n            }\n        # for Azure AD Tenant. Azure OAuth response contains\n        # JWT token which has user info.\n        # JWT token needs to be base64 decoded.\n        # https://docs.microsoft.com/en-us/azure/active-directory/develop/\n        # active-directory-protocols-oauth-code\n        if provider == \"azure\":\n            log.debug(\"Azure response received : {0}\".format(resp))\n            id_token = resp[\"id_token\"]\n            log.debug(str(id_token))\n            me = self._azure_jwt_token_parse(id_token)\n            log.debug(\"Parse JWT token : {0}\".format(me))\n            return {\n                \"name\": me.get(\"name\", \"\"),\n                \"email\": me[\"upn\"],\n                \"first_name\": me.get(\"given_name\", \"\"),\n                \"last_name\": me.get(\"family_name\", \"\"),\n                \"id\": me[\"oid\"],\n                \"username\": me[\"oid\"],\n            }\n        # for OpenShift\n        if provider == \"openshift\":\n            me = self.appbuilder.sm.oauth_remotes[provider].get(\n                \"apis/user.openshift.io/v1/users/~\"\n            )\n            data = me.json()\n            log.debug(\"User info from OpenShift: {0}\".format(data))\n            return {\"username\": \"openshift_\" + data.get(\"metadata\").get(\"name\")}\n        # for Okta\n        if provider == \"okta\":\n            me = self.appbuilder.sm.oauth_remotes[provider].get(\"userinfo\")\n            data = me.json()\n            log.debug(\"User info from Okta: %s\", data)\n            return {\n                \"username\": \"okta_\" + data.get(\"sub\", \"\"),\n                \"first_name\": data.get(\"given_name\", \"\"),\n                \"last_name\": data.get(\"family_name\", \"\"),\n                \"email\": data.get(\"email\", \"\"),\n                \"role_keys\": data.get(\"groups\", []),\n            }\n        else:\n            return {}\n\n    def _azure_parse_jwt(self, id_token):\n        jwt_token_parts = r\"^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$\"\n        matches = re.search(jwt_token_parts, id_token)\n        if not matches or len(matches.groups()) < 3:\n            log.error(\"Unable to parse token.\")\n            return {}\n        return {\n            \"header\": matches.group(1),\n            \"Payload\": matches.group(2),\n            \"Sig\": matches.group(3),\n        }\n\n    def _azure_jwt_token_parse(self, id_token):\n        jwt_split_token = self._azure_parse_jwt(id_token)\n        if not jwt_split_token:\n            return\n\n        jwt_payload = jwt_split_token[\"Payload\"]\n        # Prepare for base64 decoding\n        payload_b64_string = jwt_payload\n        payload_b64_string += \"=\" * (4 - ((len(jwt_payload) % 4)))\n        decoded_payload = base64.urlsafe_b64decode(payload_b64_string.encode(\"ascii\"))\n\n        if not decoded_payload:\n            log.error(\"Payload of id_token could not be base64 url decoded.\")\n            return\n\n        jwt_decoded_payload = json.loads(decoded_payload.decode(\"utf-8\"))\n\n        return jwt_decoded_payload\n\n    def register_views(self):\n        if not self.appbuilder.app.config.get(\"FAB_ADD_SECURITY_VIEWS\", True):\n            return\n        # Security APIs\n        self.appbuilder.add_api(self.security_api)\n\n        if self.auth_user_registration:\n            if self.auth_type == AUTH_DB:\n                self.registeruser_view = self.registeruserdbview()\n            elif self.auth_type == AUTH_OID:\n                self.registeruser_view = self.registeruseroidview()\n            elif self.auth_type == AUTH_OAUTH:\n                self.registeruser_view = self.registeruseroauthview()\n            if self.registeruser_view:\n                self.appbuilder.add_view_no_menu(self.registeruser_view)\n\n        self.appbuilder.add_view_no_menu(self.resetpasswordview())\n        self.appbuilder.add_view_no_menu(self.resetmypasswordview())\n        self.appbuilder.add_view_no_menu(self.userinfoeditview())\n\n        if self.auth_type == AUTH_DB:\n            self.user_view = self.userdbmodelview\n            self.auth_view = self.authdbview()\n\n        elif self.auth_type == AUTH_LDAP:\n            self.user_view = self.userldapmodelview\n            self.auth_view = self.authldapview()\n        elif self.auth_type == AUTH_OAUTH:\n            self.user_view = self.useroauthmodelview\n            self.auth_view = self.authoauthview()\n        elif self.auth_type == AUTH_REMOTE_USER:\n            self.user_view = self.userremoteusermodelview\n            self.auth_view = self.authremoteuserview()\n        else:\n            self.user_view = self.useroidmodelview\n            self.auth_view = self.authoidview()\n            if self.auth_user_registration:\n                pass\n                # self.registeruser_view = self.registeruseroidview()\n                # self.appbuilder.add_view_no_menu(self.registeruser_view)\n\n        self.appbuilder.add_view_no_menu(self.auth_view)\n\n        self.user_view = self.appbuilder.add_view(\n            self.user_view,\n            \"List Users\",\n            icon=\"fa-user\",\n            label=_(\"List Users\"),\n            category=\"Security\",\n            category_icon=\"fa-cogs\",\n            category_label=_(\"Security\"),\n        )\n\n        role_view = self.appbuilder.add_view(\n            self.rolemodelview,\n            \"List Roles\",\n            icon=\"fa-group\",\n            label=_(\"List Roles\"),\n            category=\"Security\",\n            category_icon=\"fa-cogs\",\n        )\n        role_view.related_views = [self.user_view.__class__]\n\n        if self.userstatschartview:\n            self.appbuilder.add_view(\n                self.userstatschartview,\n                \"User's Statistics\",\n                icon=\"fa-bar-chart-o\",\n                label=_(\"User's Statistics\"),\n                category=\"Security\",\n            )\n        if self.auth_user_registration:\n            self.appbuilder.add_view(\n                self.registerusermodelview,\n                \"User's Statistics\",\n                icon=\"fa-user-plus\",\n                label=_(\"User Registrations\"),\n                category=\"Security\",\n            )\n        self.appbuilder.menu.add_separator(\"Security\")\n        if self.appbuilder.app.config.get(\"FAB_ADD_SECURITY_PERMISSION_VIEW\", True):\n            self.appbuilder.add_view(\n                self.permissionmodelview,\n                \"Base Permissions\",\n                icon=\"fa-lock\",\n                label=_(\"Base Permissions\"),\n                category=\"Security\",\n            )\n        if self.appbuilder.app.config.get(\"FAB_ADD_SECURITY_VIEW_MENU_VIEW\", True):\n            self.appbuilder.add_view(\n                self.viewmenumodelview,\n                \"Views/Menus\",\n                icon=\"fa-list-alt\",\n                label=_(\"Views/Menus\"),\n                category=\"Security\",\n            )\n        if self.appbuilder.app.config.get(\n            \"FAB_ADD_SECURITY_PERMISSION_VIEWS_VIEW\", True\n        ):\n            self.appbuilder.add_view(\n                self.permissionviewmodelview,\n                \"Permission on Views/Menus\",\n                icon=\"fa-link\",\n                label=_(\"Permission on Views/Menus\"),\n                category=\"Security\",\n            )\n\n    def create_db(self):\n        \"\"\"\n            Setups the DB, creates admin and public roles if they don't exist.\n        \"\"\"\n        roles_mapping = self.appbuilder.get_app.config.get(\"FAB_ROLES_MAPPING\", {})\n        for pk, name in roles_mapping.items():\n            self.update_role(pk, name)\n        for role_name in self.builtin_roles:\n            self.add_role(role_name)\n        if self.auth_role_admin not in self.builtin_roles:\n            self.add_role(self.auth_role_admin)\n        self.add_role(self.auth_role_public)\n        if self.count_users() == 0:\n            log.warning(LOGMSG_WAR_SEC_NO_USER)\n\n    def reset_password(self, userid, password):\n        \"\"\"\n            Change/Reset a user's password for authdb.\n            Password will be hashed and saved.\n\n            :param userid:\n                the user.id to reset the password\n            :param password:\n                The clear text password to reset and save hashed on the db\n        \"\"\"\n        user = self.get_user_by_id(userid)\n        user.password = generate_password_hash(password)\n        self.update_user(user)\n\n    def update_user_auth_stat(self, user, success=True):\n        \"\"\"\n            Update authentication successful to user.\n\n            :param user:\n                The authenticated user model\n            :param success:\n                Default to true, if false increments fail_login_count on user model\n        \"\"\"\n        if not user.login_count:\n            user.login_count = 0\n        if not user.fail_login_count:\n            user.fail_login_count = 0\n        if success:\n            user.login_count += 1\n            user.fail_login_count = 0\n        else:\n            user.fail_login_count += 1\n        user.last_login = datetime.datetime.now()\n        self.update_user(user)\n\n    def auth_user_db(self, username, password):\n        \"\"\"\n            Method for authenticating user, auth db style\n\n            :param username:\n                The username or registered email address\n            :param password:\n                The password, will be tested against hashed password on db\n        \"\"\"\n        if username is None or username == \"\":\n            return None\n        user = self.find_user(username=username)\n        if user is None:\n            user = self.find_user(email=username)\n        if user is None or (not user.is_active):\n            # Balance failure and success\n            check_password_hash(\n                \"pbkdf2:sha256:150000$Z3t6fmj2$22da622d94a1f8118\"\n                \"c0976a03d2f18f680bfff877c9a965db9eedc51bc0be87c\",\n                \"password\",\n            )\n            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(username))\n            return None\n        elif check_password_hash(user.password, password):\n            self.update_user_auth_stat(user, True)\n            return user\n        else:\n            self.update_user_auth_stat(user, False)\n            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(username))\n            return None\n\n    def _search_ldap(self, ldap, con, username):\n        \"\"\"\n            Searches LDAP for user.\n\n            :param ldap: The ldap module reference\n            :param con: The ldap connection\n            :param username: username to match with AUTH_LDAP_UID_FIELD\n            :return: ldap object array\n        \"\"\"\n        # always check AUTH_LDAP_SEARCH is set before calling this method\n        assert self.auth_ldap_search, \"AUTH_LDAP_SEARCH must be set\"\n\n        # build the filter string for the LDAP search\n        if self.auth_ldap_search_filter:\n            filter_str = \"(&{0}({1}={2}))\".format(\n                self.auth_ldap_search_filter, self.auth_ldap_uid_field, username\n            )\n        else:\n            filter_str = \"({0}={1})\".format(self.auth_ldap_uid_field, username)\n\n        # build what fields to request in the LDAP search\n        request_fields = [\n            self.auth_ldap_firstname_field,\n            self.auth_ldap_lastname_field,\n            self.auth_ldap_email_field,\n        ]\n        if len(self.auth_roles_mapping) > 0:\n            request_fields.append(self.auth_ldap_group_field)\n\n        # preform the LDAP search\n        log.debug(\n            \"LDAP search for '{0}' with fields {1} in scope '{2}'\".format(\n                filter_str, request_fields, self.auth_ldap_search\n            )\n        )\n        raw_search_result = con.search_s(\n            self.auth_ldap_search, ldap.SCOPE_SUBTREE, filter_str, request_fields\n        )\n        log.debug(\"LDAP search returned: {0}\".format(raw_search_result))\n\n        # Remove any search referrals from results\n        search_result = [\n            (dn, attrs)\n            for dn, attrs in raw_search_result\n            if dn is not None and isinstance(attrs, dict)\n        ]\n\n        # only continue if 0 or 1 results were returned\n        if len(search_result) > 1:\n            log.error(\n                \"LDAP search for '{0}' in scope '{1}' returned multiple results\".format(\n                    filter_str, self.auth_ldap_search\n                )\n            )\n            return None, None\n\n        try:\n            # extract the DN\n            user_dn = search_result[0][0]\n            # extract the other attributes\n            user_info = search_result[0][1]\n            # return\n            return user_dn, user_info\n        except (IndexError, NameError):\n            return None, None\n\n    def _ldap_calculate_user_roles(\n        self, user_attributes: Dict[str, bytes]\n    ) -> List[str]:\n        user_role_objects = []\n\n        # apply AUTH_ROLES_MAPPING\n        if len(self.auth_roles_mapping) > 0:\n            user_role_keys = self.ldap_extract_list(\n                user_attributes, self.auth_ldap_group_field\n            )\n            user_role_objects += self.get_roles_from_keys(user_role_keys)\n\n        # apply AUTH_USER_REGISTRATION\n        if self.auth_user_registration:\n            registration_role_name = self.auth_user_registration_role\n\n            # lookup registration role in flask db\n            fab_role = self.find_role(registration_role_name)\n            if fab_role:\n                user_role_objects.append(fab_role)\n            else:\n                log.warning(\n                    \"Can't find AUTH_USER_REGISTRATION role: {0}\".format(\n                        registration_role_name\n                    )\n                )\n\n        return user_role_objects\n\n    def _ldap_bind_indirect(self, ldap, con) -> None:\n        \"\"\"\n            Attempt to bind to LDAP using the AUTH_LDAP_BIND_USER.\n\n            :param ldap: The ldap module reference\n            :param con: The ldap connection\n        \"\"\"\n        # always check AUTH_LDAP_BIND_USER is set before calling this method\n        assert self.auth_ldap_bind_user, \"AUTH_LDAP_BIND_USER must be set\"\n\n        try:\n            log.debug(\n                \"LDAP bind indirect TRY with username: '{0}'\".format(\n                    self.auth_ldap_bind_user\n                )\n            )\n            con.simple_bind_s(self.auth_ldap_bind_user, self.auth_ldap_bind_password)\n            log.debug(\n                \"LDAP bind indirect SUCCESS with username: '{0}'\".format(\n                    self.auth_ldap_bind_user\n                )\n            )\n        except ldap.INVALID_CREDENTIALS as ex:\n            log.error(\n                \"AUTH_LDAP_BIND_USER and AUTH_LDAP_BIND_PASSWORD are\"\n                \" not valid LDAP bind credentials\"\n            )\n            raise ex\n\n    @staticmethod\n    def _ldap_bind(ldap, con, dn: str, password: str) -> bool:\n        \"\"\"\n            Validates/binds the provided dn/password with the LDAP sever.\n        \"\"\"\n        try:\n            log.debug(\"LDAP bind TRY with username: '{0}'\".format(dn))\n            con.simple_bind_s(dn, password)\n            log.debug(\"LDAP bind SUCCESS with username: '{0}'\".format(dn))\n            return True\n        except ldap.INVALID_CREDENTIALS:\n            return False\n\n    @staticmethod\n    def ldap_extract(\n        ldap_dict: Dict[str, bytes], field_name: str, fallback: str\n    ) -> str:\n        raw_value = ldap_dict.get(field_name, [bytes()])\n        # decode - if empty string, default to fallback, otherwise take first element\n        return raw_value[0].decode(\"utf-8\") or fallback\n\n    @staticmethod\n    def ldap_extract_list(ldap_dict: Dict[str, bytes], field_name: str) -> List[str]:\n        raw_list = ldap_dict.get(field_name, [])\n        # decode - removing empty strings\n        return [x.decode(\"utf-8\") for x in raw_list if x.decode(\"utf-8\")]\n\n    def auth_user_ldap(self, username, password):\n        \"\"\"\n            Method for authenticating user with LDAP.\n\n            NOTE: this depends on python-ldap module\n\n            :param username: the username\n            :param password: the password\n        \"\"\"\n        # If no username is provided, go away\n        if (username is None) or username == \"\":\n            return None\n\n        # Search the DB for this user\n        user = self.find_user(username=username)\n\n        # If user is not active, go away\n        if user and (not user.is_active):\n            return None\n\n        # If user is not registered, and not self-registration, go away\n        if (not user) and (not self.auth_user_registration):\n            return None\n\n        # Ensure python-ldap is installed\n        try:\n            import ldap\n        except ImportError:\n            log.error(\"python-ldap library is not installed\")\n            return None\n\n        try:\n            # LDAP certificate settings\n            if self.auth_ldap_allow_self_signed:\n                ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_ALLOW)\n                ldap.set_option(ldap.OPT_X_TLS_NEWCTX, 0)\n            elif self.auth_ldap_tls_demand:\n                ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_DEMAND)\n                ldap.set_option(ldap.OPT_X_TLS_NEWCTX, 0)\n            if self.auth_ldap_tls_cacertdir:\n                ldap.set_option(ldap.OPT_X_TLS_CACERTDIR, self.auth_ldap_tls_cacertdir)\n            if self.auth_ldap_tls_cacertfile:\n                ldap.set_option(\n                    ldap.OPT_X_TLS_CACERTFILE, self.auth_ldap_tls_cacertfile\n                )\n            if self.auth_ldap_tls_certfile:\n                ldap.set_option(ldap.OPT_X_TLS_CERTFILE, self.auth_ldap_tls_certfile)\n            if self.auth_ldap_tls_keyfile:\n                ldap.set_option(ldap.OPT_X_TLS_KEYFILE, self.auth_ldap_tls_keyfile)\n\n            # Initialise LDAP connection\n            con = ldap.initialize(self.auth_ldap_server)\n            con.set_option(ldap.OPT_REFERRALS, 0)\n            if self.auth_ldap_use_tls:\n                try:\n                    con.start_tls_s()\n                except Exception:\n                    log.error(\n                        LOGMSG_ERR_SEC_AUTH_LDAP_TLS.format(self.auth_ldap_server)\n                    )\n                    return None\n\n            # Define variables, so we can check if they are set in later steps\n            user_dn = None\n            user_attributes = {}\n\n            # Flow 1 - (Indirect Search Bind):\n            #  - in this flow, special bind credentials are used to preform the\n            #    LDAP search\n            #  - in this flow, AUTH_LDAP_SEARCH must be set\n            if self.auth_ldap_bind_user:\n                # Bind with AUTH_LDAP_BIND_USER/AUTH_LDAP_BIND_PASSWORD\n                # (authorizes for LDAP search)\n                self._ldap_bind_indirect(ldap, con)\n\n                # Search for `username`\n                #  - returns the `user_dn` needed for binding to validate credentials\n                #  - returns the `user_attributes` needed for\n                #    AUTH_USER_REGISTRATION/AUTH_ROLES_SYNC_AT_LOGIN\n                if self.auth_ldap_search:\n                    user_dn, user_attributes = self._search_ldap(ldap, con, username)\n                else:\n                    log.error(\n                        \"AUTH_LDAP_SEARCH must be set when using AUTH_LDAP_BIND_USER\"\n                    )\n                    return None\n\n                # If search failed, go away\n                if user_dn is None:\n                    log.info(LOGMSG_WAR_SEC_NOLDAP_OBJ.format(username))\n                    return None\n\n                # Bind with user_dn/password (validates credentials)\n                if not self._ldap_bind(ldap, con, user_dn, password):\n                    if user:\n                        self.update_user_auth_stat(user, False)\n\n                    # Invalid credentials, go away\n                    log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(username))\n                    return None\n\n            # Flow 2 - (Direct Search Bind):\n            #  - in this flow, the credentials provided by the end-user are used\n            #    to preform the LDAP search\n            #  - in this flow, we only search LDAP if AUTH_LDAP_SEARCH is set\n            #     - features like AUTH_USER_REGISTRATION & AUTH_ROLES_SYNC_AT_LOGIN\n            #       will only work if AUTH_LDAP_SEARCH is set\n            else:\n                # Copy the provided username (so we can apply formatters)\n                bind_username = username\n\n                # update `bind_username` by applying AUTH_LDAP_APPEND_DOMAIN\n                #  - for Microsoft AD, which allows binding with userPrincipalName\n                if self.auth_ldap_append_domain:\n                    bind_username = bind_username + \"@\" + self.auth_ldap_append_domain\n\n                # Update `bind_username` by applying AUTH_LDAP_USERNAME_FORMAT\n                #  - for transforming the username into a DN,\n                #    for example: \"uid=%s,ou=example,o=test\"\n                if self.auth_ldap_username_format:\n                    bind_username = self.auth_ldap_username_format % bind_username\n\n                # Bind with bind_username/password\n                # (validates credentials & authorizes for LDAP search)\n                if not self._ldap_bind(ldap, con, bind_username, password):\n                    if user:\n                        self.update_user_auth_stat(user, False)\n\n                    # Invalid credentials, go away\n                    log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(bind_username))\n                    return None\n\n                # Search for `username` (if AUTH_LDAP_SEARCH is set)\n                #  - returns the `user_attributes`\n                #    needed for AUTH_USER_REGISTRATION/AUTH_ROLES_SYNC_AT_LOGIN\n                #  - we search on `username` not `bind_username`,\n                #    because AUTH_LDAP_APPEND_DOMAIN and AUTH_LDAP_USERNAME_FORMAT\n                #    would result in an invalid search filter\n                if self.auth_ldap_search:\n                    user_dn, user_attributes = self._search_ldap(ldap, con, username)\n\n                    # If search failed, go away\n                    if user_dn is None:\n                        log.info(LOGMSG_WAR_SEC_NOLDAP_OBJ.format(username))\n                        return None\n\n            # Sync the user's roles\n            if user and user_attributes and self.auth_roles_sync_at_login:\n                user.roles = self._ldap_calculate_user_roles(user_attributes)\n                log.debug(\n                    \"Calculated new roles for user='{0}' as: {1}\".format(\n                        user_dn, user.roles\n                    )\n                )\n\n            # If the user is new, register them\n            if (not user) and user_attributes and self.auth_user_registration:\n                user = self.add_user(\n                    username=username,\n                    first_name=self.ldap_extract(\n                        user_attributes, self.auth_ldap_firstname_field, \"\"\n                    ),\n                    last_name=self.ldap_extract(\n                        user_attributes, self.auth_ldap_lastname_field, \"\"\n                    ),\n                    email=self.ldap_extract(\n                        user_attributes,\n                        self.auth_ldap_email_field,\n                        f\"{username}@email.notfound\",\n                    ),\n                    role=self._ldap_calculate_user_roles(user_attributes),\n                )\n                log.debug(\"New user registered: {0}\".format(user))\n\n                # If user registration failed, go away\n                if not user:\n                    log.info(LOGMSG_ERR_SEC_ADD_REGISTER_USER.format(username))\n                    return None\n\n            # LOGIN SUCCESS (only if user is now registered)\n            if user:\n                self.update_user_auth_stat(user)\n                return user\n            else:\n                return None\n\n        except ldap.LDAPError as e:\n            msg = None\n            if isinstance(e, dict):\n                msg = getattr(e, \"message\", None)\n            if (msg is not None) and (\"desc\" in msg):\n                log.error(LOGMSG_ERR_SEC_AUTH_LDAP.format(e.message[\"desc\"]))\n                return None\n            else:\n                log.error(e)\n                return None\n\n    def auth_user_oid(self, email):\n        \"\"\"\n            OpenID user Authentication\n\n            :param email: user's email to authenticate\n            :type self: User model\n        \"\"\"\n        user = self.find_user(email=email)\n        if user is None or (not user.is_active):\n            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(email))\n            return None\n        else:\n            self.update_user_auth_stat(user)\n            return user\n\n    def auth_user_remote_user(self, username):\n        \"\"\"\n            REMOTE_USER user Authentication\n\n            :param username: user's username for remote auth\n            :type self: User model\n        \"\"\"\n        user = self.find_user(username=username)\n\n        # User does not exist, create one if auto user registration.\n        if user is None and self.auth_user_registration:\n            user = self.add_user(\n                # All we have is REMOTE_USER, so we set\n                # the other fields to blank.\n                username=username,\n                first_name=username,\n                last_name=\"-\",\n                email=username + \"@email.notfound\",\n                role=self.find_role(self.auth_user_registration_role),\n            )\n\n        # If user does not exist on the DB and not auto user registration,\n        # or user is inactive, go away.\n        elif user is None or (not user.is_active):\n            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED.format(username))\n            return None\n\n        self.update_user_auth_stat(user)\n        return user\n\n    def _oauth_calculate_user_roles(self, userinfo) -> List[str]:\n        user_role_objects = []\n\n        # apply AUTH_ROLES_MAPPING\n        if len(self.auth_roles_mapping) > 0:\n            user_role_keys = userinfo.get(\"role_keys\", [])\n            user_role_objects += self.get_roles_from_keys(user_role_keys)\n\n        # apply AUTH_USER_REGISTRATION_ROLE\n        if self.auth_user_registration:\n            registration_role_name = self.auth_user_registration_role\n\n            # if AUTH_USER_REGISTRATION_ROLE_JMESPATH is set,\n            # use it for the registration role\n            if self.auth_user_registration_role_jmespath:\n                import jmespath\n\n                registration_role_name = jmespath.search(\n                    self.auth_user_registration_role_jmespath, userinfo\n                )\n\n            # lookup registration role in flask db\n            fab_role = self.find_role(registration_role_name)\n            if fab_role:\n                user_role_objects.append(fab_role)\n            else:\n                log.warning(\n                    \"Can't find AUTH_USER_REGISTRATION role: {0}\".format(\n                        registration_role_name\n                    )\n                )\n\n        return user_role_objects\n\n    def auth_user_oauth(self, userinfo):\n        \"\"\"\n            Method for authenticating user with OAuth.\n\n            :userinfo: dict with user information\n                       (keys are the same as User model columns)\n        \"\"\"\n        # extract the username from `userinfo`\n        if \"username\" in userinfo:\n            username = userinfo[\"username\"]\n        elif \"email\" in userinfo:\n            username = userinfo[\"email\"]\n        else:\n            log.error(\n                \"OAUTH userinfo does not have username or email {0}\".format(userinfo)\n            )\n            return None\n\n        # If username is empty, go away\n        if (username is None) or username == \"\":\n            return None\n\n        # Search the DB for this user\n        user = self.find_user(username=username)\n\n        # If user is not active, go away\n        if user and (not user.is_active):\n            return None\n\n        # If user is not registered, and not self-registration, go away\n        if (not user) and (not self.auth_user_registration):\n            return None\n\n        # Sync the user's roles\n        if user and self.auth_roles_sync_at_login:\n            user.roles = self._oauth_calculate_user_roles(userinfo)\n            log.debug(\n                \"Calculated new roles for user='{0}' as: {1}\".format(\n                    username, user.roles\n                )\n            )\n\n        # If the user is new, register them\n        if (not user) and self.auth_user_registration:\n            user = self.add_user(\n                username=username,\n                first_name=userinfo.get(\"first_name\", \"\"),\n                last_name=userinfo.get(\"last_name\", \"\"),\n                email=userinfo.get(\"email\", \"\") or f\"{username}@email.notfound\",\n                role=self._oauth_calculate_user_roles(userinfo),\n            )\n            log.debug(\"New user registered: {0}\".format(user))\n\n            # If user registration failed, go away\n            if not user:\n                log.error(\"Error creating a new OAuth user {0}\".format(username))\n                return None\n\n        # LOGIN SUCCESS (only if user is now registered)\n        if user:\n            self.update_user_auth_stat(user)\n            return user\n        else:\n            return None\n\n    \"\"\"\n        ----------------------------------------\n            PERMISSION ACCESS CHECK\n        ----------------------------------------\n    \"\"\"\n\n    def is_item_public(self, permission_name, view_name):\n        \"\"\"\n            Check if view has public permissions\n\n            :param permission_name:\n                the permission: can_show, can_edit...\n            :param view_name:\n                the name of the class view (child of BaseView)\n        \"\"\"\n        permissions = self.get_public_permissions()\n        if permissions:\n            for i in permissions:\n                if (view_name == i.view_menu.name) and (\n                    permission_name == i.permission.name\n                ):\n                    return True\n            return False\n        else:\n            return False\n\n    def _has_access_builtin_roles(\n        self, role, permission_name: str, view_name: str\n    ) -> bool:\n        \"\"\"\n            Checks permission on builtin role\n        \"\"\"\n        builtin_pvms = self.builtin_roles.get(role.name, [])\n        for pvm in builtin_pvms:\n            _view_name = pvm[0]\n            _permission_name = pvm[1]\n            if re.match(_view_name, view_name) and re.match(\n                _permission_name, permission_name\n            ):\n                return True\n        return False\n\n    def _has_view_access(\n        self, user: object, permission_name: str, view_name: str\n    ) -> bool:\n        roles = user.roles\n        db_role_ids = list()\n        # First check against builtin (statically configured) roles\n        # because no database query is needed\n        for role in roles:\n            if role.name in self.builtin_roles:\n                if self._has_access_builtin_roles(role, permission_name, view_name):\n                    return True\n            else:\n                db_role_ids.append(role.id)\n\n        # If it's not a builtin role check against database store roles\n        return self.exist_permission_on_roles(view_name, permission_name, db_role_ids)\n\n    def get_user_roles(self, user) -> List[object]:\n        \"\"\"\n        Get current user roles, if user is not authenticated returns the public role\n        \"\"\"\n        if not user.is_authenticated:\n            return [self.get_public_role()]\n        return user.roles\n\n    def get_role_permissions(self, role) -> Set[Tuple[str, str]]:\n        \"\"\"\n        Get all permissions for a certain role\n        \"\"\"\n        result = set()\n        if role.name in self.builtin_roles:\n            for permission in self.builtin_roles[role.name]:\n                result.add((permission[1], permission[0]))\n        else:\n            for permission in self.get_db_role_permissions(role.id):\n                result.add((permission.permission.name, permission.view_menu.name))\n        return result\n\n    def get_user_permissions(self, user) -> Set[Tuple[str, str]]:\n        \"\"\"\n        Get all permissions from the current user\n        \"\"\"\n        roles = self.get_user_roles(user)\n        result = set()\n        for role in roles:\n            result.update(self.get_role_permissions(role))\n        return result\n\n    def _get_user_permission_view_menus(\n        self, user: object, permission_name: str, view_menus_name: List[str]\n    ) -> Set[str]:\n        \"\"\"\n        Return a set of view menu names with a certain permission name\n        that a user has access to. Mainly used to fetch all menu permissions\n        on a single db call, will also check public permissions and builtin roles\n        \"\"\"\n        db_role_ids = list()\n        if user is None:\n            # include public role\n            roles = [self.get_public_role()]\n        else:\n            roles = user.roles\n        # First check against builtin (statically configured) roles\n        # because no database query is needed\n        result = set()\n        for role in roles:\n            if role.name in self.builtin_roles:\n                for view_menu_name in view_menus_name:\n                    if self._has_access_builtin_roles(\n                        role, permission_name, view_menu_name\n                    ):\n                        result.add(view_menu_name)\n            else:\n                db_role_ids.append(role.id)\n        # Then check against database-stored roles\n        pvms_names = [\n            pvm.view_menu.name\n            for pvm in self.find_roles_permission_view_menus(\n                permission_name, db_role_ids\n            )\n        ]\n        result.update(pvms_names)\n        return result\n\n    def has_access(self, permission_name, view_name):\n        \"\"\"\n        Check if current user or public has access to view or menu\n        \"\"\"\n        if current_user.is_authenticated:\n            return self._has_view_access(g.user, permission_name, view_name)\n        elif current_user_jwt:\n            return self._has_view_access(current_user_jwt, permission_name, view_name)\n        else:\n            return self.is_item_public(permission_name, view_name)\n\n    def get_user_menu_access(self, menu_names: List[str] = None) -> Set[str]:\n        if current_user.is_authenticated:\n            return self._get_user_permission_view_menus(\n                g.user, \"menu_access\", view_menus_name=menu_names\n            )\n        elif current_user_jwt:\n            return self._get_user_permission_view_menus(\n                current_user_jwt, \"menu_access\", view_menus_name=menu_names\n            )\n        else:\n            return self._get_user_permission_view_menus(\n                None, \"menu_access\", view_menus_name=menu_names\n            )\n\n    def add_permissions_view(self, base_permissions, view_menu):\n        \"\"\"\n        Adds a permission on a view menu to the backend\n\n        :param base_permissions:\n            list of permissions from view (all exposed methods):\n             'can_add','can_edit' etc...\n        :param view_menu:\n            name of the view or menu to add\n        \"\"\"\n        view_menu_db = self.add_view_menu(view_menu)\n        perm_views = self.find_permissions_view_menu(view_menu_db)\n\n        if not perm_views:\n            # No permissions yet on this view\n            for permission in base_permissions:\n                pv = self.add_permission_view_menu(permission, view_menu)\n                if self.auth_role_admin not in self.builtin_roles:\n                    role_admin = self.find_role(self.auth_role_admin)\n                    self.add_permission_role(role_admin, pv)\n        else:\n            # Permissions on this view exist but....\n            role_admin = self.find_role(self.auth_role_admin)\n            for permission in base_permissions:\n                # Check if base view permissions exist\n                if not self.exist_permission_on_views(perm_views, permission):\n                    pv = self.add_permission_view_menu(permission, view_menu)\n                    if self.auth_role_admin not in self.builtin_roles:\n                        self.add_permission_role(role_admin, pv)\n            for perm_view in perm_views:\n                if perm_view.permission is None:\n                    # Skip this perm_view, it has a null permission\n                    continue\n                if perm_view.permission.name not in base_permissions:\n                    # perm to delete\n                    roles = self.get_all_roles()\n                    perm = self.find_permission(perm_view.permission.name)\n                    # del permission from all roles\n                    for role in roles:\n                        self.del_permission_role(role, perm)\n                    self.del_permission_view_menu(perm_view.permission.name, view_menu)\n                elif (\n                    self.auth_role_admin not in self.builtin_roles\n                    and perm_view not in role_admin.permissions\n                ):\n                    # Role Admin must have all permissions\n                    self.add_permission_role(role_admin, perm_view)\n\n    def add_permissions_menu(self, view_menu_name):\n        \"\"\"\n        Adds menu_access to menu on permission_view_menu\n\n        :param view_menu_name:\n            The menu name\n        \"\"\"\n        self.add_view_menu(view_menu_name)\n        pv = self.find_permission_view_menu(\"menu_access\", view_menu_name)\n        if not pv:\n            pv = self.add_permission_view_menu(\"menu_access\", view_menu_name)\n        if self.auth_role_admin not in self.builtin_roles:\n            role_admin = self.find_role(self.auth_role_admin)\n            self.add_permission_role(role_admin, pv)\n\n    def security_cleanup(self, baseviews, menus):\n        \"\"\"\n        Will cleanup all unused permissions from the database\n\n        :param baseviews: A list of BaseViews class\n        :param menus: Menu class\n        \"\"\"\n        viewsmenus = self.get_all_view_menu()\n        roles = self.get_all_roles()\n        for viewmenu in viewsmenus:\n            found = False\n            for baseview in baseviews:\n                if viewmenu.name == baseview.class_permission_name:\n                    found = True\n                    break\n            if menus.find(viewmenu.name):\n                found = True\n            if not found:\n                permissions = self.find_permissions_view_menu(viewmenu)\n                for permission in permissions:\n                    for role in roles:\n                        self.del_permission_role(role, permission)\n                    self.del_permission_view_menu(\n                        permission.permission.name, viewmenu.name\n                    )\n                self.del_view_menu(viewmenu.name)\n        self.security_converge(baseviews, menus)\n\n    @staticmethod\n    def _get_new_old_permissions(baseview) -> Dict:\n        ret = dict()\n        for method_name, permission_name in baseview.method_permission_name.items():\n            old_permission_name = baseview.previous_method_permission_name.get(\n                method_name\n            )\n            # Actions do not get prefix when normally defined\n            if hasattr(baseview, \"actions\") and baseview.actions.get(\n                old_permission_name\n            ):\n                permission_prefix = \"\"\n            else:\n                permission_prefix = PERMISSION_PREFIX\n            if old_permission_name:\n                if PERMISSION_PREFIX + permission_name not in ret:\n                    ret[PERMISSION_PREFIX + permission_name] = {\n                        permission_prefix + old_permission_name\n                    }\n                else:\n                    ret[PERMISSION_PREFIX + permission_name].add(\n                        permission_prefix + old_permission_name\n                    )\n        return ret\n\n    @staticmethod\n    def _add_state_transition(\n        state_transition: Dict,\n        old_view_name: str,\n        old_perm_name: str,\n        view_name: str,\n        perm_name: str,\n    ) -> None:\n        old_pvm = state_transition[\"add\"].get((old_view_name, old_perm_name))\n        if old_pvm:\n            state_transition[\"add\"][(old_view_name, old_perm_name)].add(\n                (view_name, perm_name)\n            )\n        else:\n            state_transition[\"add\"][(old_view_name, old_perm_name)] = {\n                (view_name, perm_name)\n            }\n        state_transition[\"del_role_pvm\"].add((old_view_name, old_perm_name))\n        state_transition[\"del_views\"].add(old_view_name)\n        state_transition[\"del_perms\"].add(old_perm_name)\n\n    @staticmethod\n    def _update_del_transitions(state_transitions: Dict, baseviews: List) -> None:\n        \"\"\"\n        Mutates state_transitions, loop baseviews and prunes all\n        views and permissions that are not to delete because references\n        exist.\n\n        :param baseview:\n        :param state_transitions:\n        :return:\n        \"\"\"\n        for baseview in baseviews:\n            state_transitions[\"del_views\"].discard(baseview.class_permission_name)\n            for permission in baseview.base_permissions:\n                state_transitions[\"del_role_pvm\"].discard(\n                    (baseview.class_permission_name, permission)\n                )\n                state_transitions[\"del_perms\"].discard(permission)\n\n    def create_state_transitions(self, baseviews: List, menus: List) -> Dict:\n        \"\"\"\n        Creates a Dict with all the necessary vm/permission transitions\n\n        Dict: {\n                \"add\": {(<VM>, <PERM>): ((<VM>, PERM), ... )}\n                \"del_role_pvm\": ((<VM>, <PERM>), ...)\n                \"del_views\": (<VM>, ... )\n                \"del_perms\": (<PERM>, ... )\n              }\n\n        :param baseviews: List with all the registered BaseView, BaseApi\n        :param menus: List with all the menu entries\n        :return: Dict with state transitions\n        \"\"\"\n        state_transitions = {\n            \"add\": {},\n            \"del_role_pvm\": set(),\n            \"del_views\": set(),\n            \"del_perms\": set(),\n        }\n        for baseview in baseviews:\n            add_all_flag = False\n            new_view_name = baseview.class_permission_name\n            permission_mapping = self._get_new_old_permissions(baseview)\n            if baseview.previous_class_permission_name:\n                old_view_name = baseview.previous_class_permission_name\n                add_all_flag = True\n            else:\n                new_view_name = baseview.class_permission_name\n                old_view_name = new_view_name\n            for new_perm_name in baseview.base_permissions:\n                if add_all_flag:\n                    old_perm_names = permission_mapping.get(new_perm_name)\n                    old_perm_names = old_perm_names or (new_perm_name,)\n                    for old_perm_name in old_perm_names:\n                        self._add_state_transition(\n                            state_transitions,\n                            old_view_name,\n                            old_perm_name,\n                            new_view_name,\n                            new_perm_name,\n                        )\n                else:\n                    old_perm_names = permission_mapping.get(new_perm_name) or set()\n                    for old_perm_name in old_perm_names:\n                        self._add_state_transition(\n                            state_transitions,\n                            old_view_name,\n                            old_perm_name,\n                            new_view_name,\n                            new_perm_name,\n                        )\n        self._update_del_transitions(state_transitions, baseviews)\n        return state_transitions\n\n    def security_converge(self, baseviews: List, menus: List, dry=False) -> Dict:\n        \"\"\"\n        Converges overridden permissions on all registered views/api\n        will compute all necessary operations from `class_permissions_name`,\n        `previous_class_permission_name`, method_permission_name`,\n        `previous_method_permission_name` class attributes.\n\n        :param baseviews: List of registered views/apis\n        :param menus: List of menu items\n        :param dry: If True will not change DB\n        :return: Dict with the necessary operations (state_transitions)\n        \"\"\"\n        state_transitions = self.create_state_transitions(baseviews, menus)\n        if dry:\n            return state_transitions\n        if not state_transitions:\n            log.info(\"No state transitions found\")\n            return dict()\n        log.debug(f\"State transitions: {state_transitions}\")\n        roles = self.get_all_roles()\n        for role in roles:\n            permissions = list(role.permissions)\n            for pvm in permissions:\n                new_pvm_states = state_transitions[\"add\"].get(\n                    (pvm.view_menu.name, pvm.permission.name)\n                )\n                if not new_pvm_states:\n                    continue\n                for new_pvm_state in new_pvm_states:\n                    new_pvm = self.add_permission_view_menu(\n                        new_pvm_state[1], new_pvm_state[0]\n                    )\n                    self.add_permission_role(role, new_pvm)\n                if (pvm.view_menu.name, pvm.permission.name) in state_transitions[\n                    \"del_role_pvm\"\n                ]:\n                    self.del_permission_role(role, pvm)\n        for pvm in state_transitions[\"del_role_pvm\"]:\n            self.del_permission_view_menu(pvm[1], pvm[0], cascade=False)\n        for view_name in state_transitions[\"del_views\"]:\n            self.del_view_menu(view_name)\n        for permission_name in state_transitions[\"del_perms\"]:\n            self.del_permission(permission_name)\n        return state_transitions\n\n    \"\"\"\n     ---------------------------\n     INTERFACE ABSTRACT METHODS\n     ---------------------------\n\n     ---------------------\n     PRIMITIVES FOR USERS\n    ----------------------\n    \"\"\"\n\n    def find_register_user(self, registration_hash):\n        \"\"\"\n            Generic function to return user registration\n        \"\"\"\n        raise NotImplementedError\n\n    def add_register_user(\n        self, username, first_name, last_name, email, password=\"\", hashed_password=\"\"\n    ):\n        \"\"\"\n            Generic function to add user registration\n        \"\"\"\n        raise NotImplementedError\n\n    def del_register_user(self, register_user):\n        \"\"\"\n            Generic function to delete user registration\n        \"\"\"\n        raise NotImplementedError\n\n    def get_user_by_id(self, pk):\n        \"\"\"\n            Generic function to return user by it's id (pk)\n        \"\"\"\n        raise NotImplementedError\n\n    def find_user(self, username=None, email=None):\n        \"\"\"\n            Generic function find a user by it's username or email\n        \"\"\"\n        raise NotImplementedError\n\n    def get_all_users(self):\n        \"\"\"\n            Generic function that returns all existing users\n        \"\"\"\n        raise NotImplementedError\n\n    def get_db_role_permissions(self, role_id: int) -> List[object]:\n        \"\"\"\n        Get all DB permissions from a role id\n        \"\"\"\n        raise NotImplementedError\n\n    def add_user(self, username, first_name, last_name, email, role, password=\"\"):\n        \"\"\"\n            Generic function to create user\n        \"\"\"\n        raise NotImplementedError\n\n    def update_user(self, user):\n        \"\"\"\n            Generic function to update user\n\n            :param user: User model to update to database\n        \"\"\"\n        raise NotImplementedError\n\n    def count_users(self):\n        \"\"\"\n            Generic function to count the existing users\n        \"\"\"\n        raise NotImplementedError\n\n    \"\"\"\n    ----------------------\n     PRIMITIVES FOR ROLES\n    ----------------------\n    \"\"\"\n\n    def find_role(self, name):\n        raise NotImplementedError\n\n    def add_role(self, name):\n        raise NotImplementedError\n\n    def update_role(self, pk, name):\n        raise NotImplementedError\n\n    def get_all_roles(self):\n        raise NotImplementedError\n\n    \"\"\"\n    ----------------------------\n     PRIMITIVES FOR PERMISSIONS\n    ----------------------------\n    \"\"\"\n\n    def get_public_role(self):\n        \"\"\"\n            returns all permissions from public role\n        \"\"\"\n        raise NotImplementedError\n\n    def get_public_permissions(self):\n        \"\"\"\n            returns all permissions from public role\n        \"\"\"\n        raise NotImplementedError\n\n    def find_permission(self, name):\n        \"\"\"\n            Finds and returns a Permission by name\n        \"\"\"\n        raise NotImplementedError\n\n    def find_roles_permission_view_menus(\n        self, permission_name: str, role_ids: List[int]\n    ):\n        raise NotImplementedError\n\n    def exist_permission_on_roles(\n        self, view_name: str, permission_name: str, role_ids: List[int]\n    ) -> bool:\n        \"\"\"\n            Finds and returns permission views for a group of roles\n        \"\"\"\n        raise NotImplementedError\n\n    def add_permission(self, name):\n        \"\"\"\n            Adds a permission to the backend, model permission\n\n            :param name:\n                name of the permission: 'can_add','can_edit' etc...\n        \"\"\"\n        raise NotImplementedError\n\n    def del_permission(self, name):\n        \"\"\"\n            Deletes a permission from the backend, model permission\n\n            :param name:\n                name of the permission: 'can_add','can_edit' etc...\n        \"\"\"\n        raise NotImplementedError\n\n    \"\"\"\n    ----------------------\n     PRIMITIVES VIEW MENU\n    ----------------------\n    \"\"\"\n\n    def find_view_menu(self, name):\n        \"\"\"\n            Finds and returns a ViewMenu by name\n        \"\"\"\n        raise NotImplementedError\n\n    def get_all_view_menu(self):\n        raise NotImplementedError\n\n    def add_view_menu(self, name):\n        \"\"\"\n            Adds a view or menu to the backend, model view_menu\n            param name:\n                name of the view menu to add\n        \"\"\"\n        raise NotImplementedError\n\n    def del_view_menu(self, name):\n        \"\"\"\n            Deletes a ViewMenu from the backend\n\n            :param name:\n                name of the ViewMenu\n        \"\"\"\n        raise NotImplementedError\n\n    \"\"\"\n    ----------------------\n     PERMISSION VIEW MENU\n    ----------------------\n    \"\"\"\n\n    def find_permission_view_menu(self, permission_name, view_menu_name):\n        \"\"\"\n            Finds and returns a PermissionView by names\n        \"\"\"\n        raise NotImplementedError\n\n    def find_permissions_view_menu(self, view_menu):\n        \"\"\"\n            Finds all permissions from ViewMenu, returns list of PermissionView\n\n            :param view_menu: ViewMenu object\n            :return: list of PermissionView objects\n        \"\"\"\n        raise NotImplementedError\n\n    def add_permission_view_menu(self, permission_name, view_menu_name):\n        \"\"\"\n            Adds a permission on a view or menu to the backend\n\n            :param permission_name:\n                name of the permission to add: 'can_add','can_edit' etc...\n            :param view_menu_name:\n                name of the view menu to add\n        \"\"\"\n        raise NotImplementedError\n\n    def del_permission_view_menu(self, permission_name, view_menu_name, cascade=True):\n        raise NotImplementedError\n\n    def exist_permission_on_views(self, lst, item):\n        raise NotImplementedError\n\n    def exist_permission_on_view(self, lst, permission, view_menu):\n        raise NotImplementedError\n\n    def add_permission_role(self, role, perm_view):\n        \"\"\"\n            Add permission-ViewMenu object to Role\n\n            :param role:\n                The role object\n            :param perm_view:\n                The PermissionViewMenu object\n        \"\"\"\n        raise NotImplementedError\n\n    def del_permission_role(self, role, perm_view):\n        \"\"\"\n            Remove permission-ViewMenu object to Role\n\n            :param role:\n                The role object\n            :param perm_view:\n                The PermissionViewMenu object\n        \"\"\"\n        raise NotImplementedError\n\n    def load_user(self, pk):\n        return self.get_user_by_id(int(pk))\n\n    def load_user_jwt(self, pk):\n        user = self.load_user(pk)\n        # Set flask g.user to JWT user, we can't do it on before request\n        g.user = user\n        return user\n\n    @staticmethod\n    def before_request():\n        g.user = current_user\n"], "filenames": ["flask_appbuilder/security/manager.py"], "buggy_code_start_loc": [835], "buggy_code_end_loc": [835], "fixing_code_start_loc": [836], "fixing_code_end_loc": [842], "type": "CWE-203", "message": "Flask-AppBuilder is a development framework, built on top of Flask. User enumeration in database authentication in Flask-AppBuilder <= 3.2.3. Allows for a non authenticated user to enumerate existing accounts by timing the response time from the server when you are logging in. Upgrade to version 3.3.0 or higher to resolve.", "other": {"cve": {"id": "CVE-2021-29621", "sourceIdentifier": "security-advisories@github.com", "published": "2021-06-07T19:15:07.600", "lastModified": "2021-08-06T18:16:00.000", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Flask-AppBuilder is a development framework, built on top of Flask. User enumeration in database authentication in Flask-AppBuilder <= 3.2.3. Allows for a non authenticated user to enumerate existing accounts by timing the response time from the server when you are logging in. Upgrade to version 3.3.0 or higher to resolve."}, {"lang": "es", "value": "Flask-AppBuilder es un marco de desarrollo, construido sobre Flask. Enumeraci\u00f3n de usuarios en la autenticaci\u00f3n de la base de datos en Flask-AppBuilder versiones anteriores a 3.2.3 incluy\u00e9ndola. Permite a un usuario no autenticado enumerar las cuentas existentes cronometrando el tiempo de respuesta del servidor cuando est\u00e1 iniciando la sesi\u00f3n. Actualice a la versi\u00f3n 3.3.0 o superior para resolverlo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-203"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:flask-appbuilder_project:flask-appbuilder:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.2.3", "matchCriteriaId": "5104FD60-B849-447E-A0D3-1EF3359467E9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apache:airflow:1.10.0:*:*:*:*:*:*:*", "matchCriteriaId": "6BE3E45C-D05B-4ACD-8468-32148E391456"}]}]}], "references": [{"url": "https://github.com/dpgaspar/Flask-AppBuilder/commit/780bd0e8fbf2d36ada52edb769477e0a4edae580", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dpgaspar/Flask-AppBuilder/security/advisories/GHSA-434h-p4gx-jm89", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r466759f377651f0a690475d5a52564d0e786e82c08d5a5730a4f8352@%3Cannounce.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r5b754118ba4e996adf03863705d34168bffec202da5c6bdc9bf3add5@%3Cannounce.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r91067f953906d93aaa1c69fe2b5472754019cc6bd4f1ba81349d62a0@%3Ccommits.airflow.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://pypi.org/project/Flask-AppBuilder/", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dpgaspar/Flask-AppBuilder/commit/780bd0e8fbf2d36ada52edb769477e0a4edae580"}}