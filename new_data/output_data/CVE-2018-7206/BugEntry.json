{"buggy_code": ["\"\"\"\nCustom Authenticator to use GitLab OAuth with JupyterHub\n\nModified for GitLab by Laszlo Dobos (@dobos)\nbased on the GitHub plugin by Kyle Kelley (@rgbkrk)\n\"\"\"\n\n\nimport json\nimport os\nimport sys\n\nfrom tornado.auth import OAuth2Mixin\nfrom tornado import gen, web\n\nfrom tornado.escape import url_escape\nfrom tornado.httputil import url_concat\nfrom tornado.httpclient import HTTPRequest, AsyncHTTPClient\n\nfrom jupyterhub.auth import LocalAuthenticator\n\nfrom traitlets import Set\n\nfrom .common import next_page_from_links\nfrom .oauth2 import OAuthLoginHandler, OAuthenticator\n\n# Support gitlab.com and gitlab community edition installations\nGITLAB_HOST = os.environ.get('GITLAB_HOST') or 'https://gitlab.com'\nGITLAB_API_VERSION = os.environ.get('GITLAB_API_VERSION') or '4'\nGITLAB_API = '%s/api/v%s' % (GITLAB_HOST, GITLAB_API_VERSION)\n\n\ndef _api_headers(access_token):\n    return {\"Accept\": \"application/json\",\n            \"User-Agent\": \"JupyterHub\",\n            \"Authorization\": \"Bearer {}\".format(access_token)\n           }\n\n\nclass GitLabMixin(OAuth2Mixin):\n    _OAUTH_AUTHORIZE_URL = \"%s/oauth/authorize\" % GITLAB_HOST\n    _OAUTH_ACCESS_TOKEN_URL = \"%s/oauth/access_token\" % GITLAB_HOST\n\n\nclass GitLabLoginHandler(OAuthLoginHandler, GitLabMixin):\n    pass\n\n\nclass GitLabOAuthenticator(OAuthenticator):\n\n    login_service = \"GitLab\"\n\n    client_id_env = 'GITLAB_CLIENT_ID'\n    client_secret_env = 'GITLAB_CLIENT_SECRET'\n    login_handler = GitLabLoginHandler\n\n    gitlab_group_whitelist = Set(\n        config=True,\n        help=\"Automatically whitelist members of selected groups\",\n    )\n\n\n    @gen.coroutine\n    def authenticate(self, handler, data=None):\n        code = handler.get_argument(\"code\")\n        # TODO: Configure the curl_httpclient for tornado\n        http_client = AsyncHTTPClient()\n\n        # Exchange the OAuth code for a GitLab Access Token\n        #\n        # See: https://github.com/gitlabhq/gitlabhq/blob/master/doc/api/oauth2.md\n\n        # GitLab specifies a POST request yet requires URL parameters\n        params = dict(\n            client_id=self.client_id,\n            client_secret=self.client_secret,\n            code=code,\n            grant_type=\"authorization_code\",\n            redirect_uri=self.get_callback_url(handler),\n        )\n\n\n        validate_server_cert = self.validate_server_cert\n\n        url = url_concat(\"%s/oauth/token\" % GITLAB_HOST,\n                         params)\n\n        req = HTTPRequest(url,\n                          method=\"POST\",\n                          headers={\"Accept\": \"application/json\"},\n                          validate_cert=validate_server_cert,\n                          body='' # Body is required for a POST...\n                          )\n\n        resp = yield http_client.fetch(req)\n        resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n\n        access_token = resp_json['access_token']\n\n        # Determine who the logged in user is\n        req = HTTPRequest(\"%s/user\" % GITLAB_API,\n                          method=\"GET\",\n                          validate_cert=validate_server_cert,\n                          headers=_api_headers(access_token)\n                          )\n        resp = yield http_client.fetch(req)\n        resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n\n        username = resp_json[\"username\"]\n        user_id = resp_json[\"id\"]\n        is_admin = resp_json.get(\"is_admin\", False)\n\n        # Check if user is a member of any whitelisted organizations.\n        # This check is performed here, as it requires `access_token`.\n        if self.gitlab_group_whitelist:\n            user_in_group = yield self._check_group_whitelist(\n                username, user_id, is_admin, access_token)\n            if not user_in_group:\n                self.log.warning(\"%s not in group whitelist\", username)\n                return None\n        return {\n            'name': username,\n            'auth_state': {\n                'access_token': access_token,\n                'gitlab_user': resp_json,\n            }\n        }\n\n\n    @gen.coroutine\n    def _check_group_whitelist(self, username, user_id, is_admin, access_token):\n        http_client = AsyncHTTPClient()\n        headers = _api_headers(access_token)\n        if is_admin:\n            # For admins, /groups returns *all* groups. As a workaround\n            # we check if we are a member of each group in the whitelist\n            for group in map(url_escape, self.gitlab_group_whitelist):\n                url = \"%s/groups/%s/members/%d\" % (GITLAB_API, group, user_id)\n                req = HTTPRequest(url, method=\"GET\", headers=headers)\n                resp = yield http_client.fetch(req, raise_error=False)\n                if resp.code == 200:\n                    return True  # user _is_ in group\n        else:\n            # For regular users we get all the groups to which they have access\n            # and check if any of these are in the whitelisted groups\n            next_page = url_concat(\"%s/groups\" % GITLAB_API,\n                                   dict(all_available=True))\n            while next_page:\n                req = HTTPRequest(next_page, method=\"GET\", headers=headers)\n                resp = yield http_client.fetch(req)\n                resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n                next_page = next_page_from_links(resp)\n                user_groups = set(entry[\"path\"] for entry in resp_json)\n                # check if any of the organizations seen thus far are in whitelist\n                if len(self.gitlab_group_whitelist & user_groups) > 0:\n                    return True\n            return False\n\n\n\nclass LocalGitLabOAuthenticator(LocalAuthenticator, GitLabOAuthenticator):\n\n    \"\"\"A version that mixes in local system user creation\"\"\"\n    pass\n"], "fixing_code": ["\"\"\"\nCustom Authenticator to use GitLab OAuth with JupyterHub\n\nModified for GitLab by Laszlo Dobos (@dobos)\nbased on the GitHub plugin by Kyle Kelley (@rgbkrk)\n\"\"\"\n\n\nimport json\nimport os\nimport sys\n\nfrom tornado.auth import OAuth2Mixin\nfrom tornado import gen, web\n\nfrom tornado.escape import url_escape\nfrom tornado.httputil import url_concat\nfrom tornado.httpclient import HTTPRequest, AsyncHTTPClient\n\nfrom jupyterhub.auth import LocalAuthenticator\n\nfrom traitlets import Set\n\nfrom .oauth2 import OAuthLoginHandler, OAuthenticator\n\n# Support gitlab.com and gitlab community edition installations\nGITLAB_HOST = os.environ.get('GITLAB_HOST') or 'https://gitlab.com'\nGITLAB_API_VERSION = os.environ.get('GITLAB_API_VERSION') or '4'\nGITLAB_API = '%s/api/v%s' % (GITLAB_HOST, GITLAB_API_VERSION)\n\n\ndef _api_headers(access_token):\n    return {\"Accept\": \"application/json\",\n            \"User-Agent\": \"JupyterHub\",\n            \"Authorization\": \"Bearer {}\".format(access_token)\n           }\n\n\nclass GitLabMixin(OAuth2Mixin):\n    _OAUTH_AUTHORIZE_URL = \"%s/oauth/authorize\" % GITLAB_HOST\n    _OAUTH_ACCESS_TOKEN_URL = \"%s/oauth/access_token\" % GITLAB_HOST\n\n\nclass GitLabLoginHandler(OAuthLoginHandler, GitLabMixin):\n    pass\n\n\nclass GitLabOAuthenticator(OAuthenticator):\n\n    login_service = \"GitLab\"\n\n    client_id_env = 'GITLAB_CLIENT_ID'\n    client_secret_env = 'GITLAB_CLIENT_SECRET'\n    login_handler = GitLabLoginHandler\n\n    gitlab_group_whitelist = Set(\n        config=True,\n        help=\"Automatically whitelist members of selected groups\",\n    )\n\n\n    @gen.coroutine\n    def authenticate(self, handler, data=None):\n        code = handler.get_argument(\"code\")\n        # TODO: Configure the curl_httpclient for tornado\n        http_client = AsyncHTTPClient()\n\n        # Exchange the OAuth code for a GitLab Access Token\n        #\n        # See: https://github.com/gitlabhq/gitlabhq/blob/master/doc/api/oauth2.md\n\n        # GitLab specifies a POST request yet requires URL parameters\n        params = dict(\n            client_id=self.client_id,\n            client_secret=self.client_secret,\n            code=code,\n            grant_type=\"authorization_code\",\n            redirect_uri=self.get_callback_url(handler),\n        )\n\n\n        validate_server_cert = self.validate_server_cert\n\n        url = url_concat(\"%s/oauth/token\" % GITLAB_HOST,\n                         params)\n\n        req = HTTPRequest(url,\n                          method=\"POST\",\n                          headers={\"Accept\": \"application/json\"},\n                          validate_cert=validate_server_cert,\n                          body='' # Body is required for a POST...\n                          )\n\n        resp = yield http_client.fetch(req)\n        resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n\n        access_token = resp_json['access_token']\n\n        # Determine who the logged in user is\n        req = HTTPRequest(\"%s/user\" % GITLAB_API,\n                          method=\"GET\",\n                          validate_cert=validate_server_cert,\n                          headers=_api_headers(access_token)\n                          )\n        resp = yield http_client.fetch(req)\n        resp_json = json.loads(resp.body.decode('utf8', 'replace'))\n\n        username = resp_json[\"username\"]\n        user_id = resp_json[\"id\"]\n        is_admin = resp_json.get(\"is_admin\", False)\n\n        # Check if user is a member of any whitelisted organizations.\n        # This check is performed here, as it requires `access_token`.\n        if self.gitlab_group_whitelist:\n            user_in_group = yield self._check_group_whitelist(\n                username, user_id, is_admin, access_token)\n            if not user_in_group:\n                self.log.warning(\"%s not in group whitelist\", username)\n                return None\n        return {\n            'name': username,\n            'auth_state': {\n                'access_token': access_token,\n                'gitlab_user': resp_json,\n            }\n        }\n\n\n    @gen.coroutine\n    def _check_group_whitelist(self, username, user_id, is_admin, access_token):\n        http_client = AsyncHTTPClient()\n        headers = _api_headers(access_token)\n        # Check if we are a member of each group in the whitelist\n        for group in map(url_escape, self.gitlab_group_whitelist):\n            url = \"%s/groups/%s/members/%d\" % (GITLAB_API, group, user_id)\n            req = HTTPRequest(url, method=\"GET\", headers=headers)\n            resp = yield http_client.fetch(req, raise_error=False)\n            if resp.code == 200:\n                return True  # user _is_ in group\n        return False\n\n\nclass LocalGitLabOAuthenticator(LocalAuthenticator, GitLabOAuthenticator):\n\n    \"\"\"A version that mixes in local system user creation\"\"\"\n    pass\n"], "filenames": ["oauthenticator/gitlab.py"], "buggy_code_start_loc": [24], "buggy_code_end_loc": [159], "fixing_code_start_loc": [23], "fixing_code_end_loc": [141], "type": "NVD-CWE-noinfo", "message": "An issue was discovered in Project Jupyter JupyterHub OAuthenticator 0.6.x before 0.6.2 and 0.7.x before 0.7.3. When using JupyterHub with GitLab group whitelisting for access control, group membership was not checked correctly, allowing members not in the whitelisted groups to create accounts on the Hub. (Users were not allowed to access other users' accounts, but could create their own accounts on the Hub linked to their GitLab account. GitLab authentication not using gitlab_group_whitelist is unaffected. No other Authenticators are affected.)", "other": {"cve": {"id": "CVE-2018-7206", "sourceIdentifier": "cve@mitre.org", "published": "2018-02-18T03:29:00.353", "lastModified": "2021-01-13T14:52:13.970", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Project Jupyter JupyterHub OAuthenticator 0.6.x before 0.6.2 and 0.7.x before 0.7.3. When using JupyterHub with GitLab group whitelisting for access control, group membership was not checked correctly, allowing members not in the whitelisted groups to create accounts on the Hub. (Users were not allowed to access other users' accounts, but could create their own accounts on the Hub linked to their GitLab account. GitLab authentication not using gitlab_group_whitelist is unaffected. No other Authenticators are affected.)"}, {"lang": "es", "value": "Se ha descubierto un problema en Project Jupyter JupyterHub OAuthenticator, en versiones 0.6.x, anteriores a la 0.6.2 y versiones 0.7.x anteriores a la 0.7.3. Al emplear JupyterHub con listas blancas de grupos de GitLab para aplicar control de acceso, la membres\u00eda de grupos no se comprob\u00f3 correctamente, lo que permite que los miembros que no est\u00e9n en la lista blanca creen cuentas en el Hub. (Los usuarios no ten\u00edan permitido acceder a las cuentas de otros usuarios, pero pod\u00edan crear sus propias cuentas en el Hub conectado a su cuenta de GitLab. La autenticaci\u00f3n GitLab que no emplee gitlab_group_whitelist no se ha visto afectada. Otros tipos de autenticaci\u00f3n no se han visto afectados."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:oauthenticator:0.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "1B3586E5-A19C-425D-B335-13D19B74F9A8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:oauthenticator:0.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "B74C711F-7B07-4DE1-892C-537CF427A564"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:oauthenticator:0.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "A9648AFA-2E51-4B7D-9CB6-B639F3DFFFAD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:oauthenticator:0.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "A9825746-C8D4-41CA-8D5E-BC83FDA4D579"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:oauthenticator:0.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "D5582AC6-44C8-48DE-8CCC-E08B2EAE2ED1"}]}]}], "references": [{"url": "https://blog.jupyter.org/security-fix-for-jupyterhub-gitlab-oauthenticator-7b14571d1f76", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/jupyterhub/oauthenticator/blob/8499dc2/CHANGELOG.md#073---2018-02-16", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/jupyterhub/oauthenticator/commit/1845c0e4b1bff3462c91c3108c85205acd3c75a2", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/jupyterhub/oauthenticator/commit/1845c0e4b1bff3462c91c3108c85205acd3c75a2"}}