{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Media Tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n\n#include <gpac/internal/media_dev.h>\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n#include <gpac/config_file.h>\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_EXPORT\nGF_Err gf_media_change_par(GF_ISOFile *file, u32 track, s32 ar_num, s32 ar_den, Bool force_par, Bool rewrite_bs)\n{\n\tu32 tk_w, tk_h;\n\tGF_Err e;\n\tBool get_par_info = GF_FALSE;\n\n\te = gf_isom_get_visual_info(file, track, 1, &tk_w, &tk_h);\n\tif (e) return e;\n\n\tif ((ar_num < 0) || (ar_den < 0)) {\n\t\tget_par_info = GF_TRUE;\n\t\trewrite_bs = GF_FALSE;\n\t}\n\telse if (!ar_num || !ar_den) {\n\t\trewrite_bs = GF_FALSE;\n\t}\n\n\tif (get_par_info || rewrite_bs) {\n\t\tu32 stype = gf_isom_get_media_subtype(file, track, 1);\n\t\tif ((stype==GF_ISOM_SUBTYPE_AVC_H264)\n\t\t\t\t|| (stype==GF_ISOM_SUBTYPE_AVC2_H264)\n\t\t\t\t|| (stype==GF_ISOM_SUBTYPE_AVC3_H264)\n\t\t\t\t|| (stype==GF_ISOM_SUBTYPE_AVC4_H264)\n\t\t   ) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(file, track, 1);\n\t\t\tif (rewrite_bs) {\n\t\t\t\tgf_avc_change_par(avcc, ar_num, ar_den);\n\t\t\t\te = gf_isom_avc_config_update(file, track, 1, avcc);\n\t\t\t} else {\n\t\t\t\tGF_NALUFFParam *sl = gf_list_get(avcc->sequenceParameterSets, 0);\n\t\t\t\tif (sl) {\n\t\t\t\t\tgf_avc_get_sps_info(sl->data, sl->size, NULL, NULL, NULL, &ar_num, &ar_den);\n\t\t\t\t} else {\n\t\t\t\t\tar_num = ar_den = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\tif (e) return e;\n#endif\n\t\t}\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\telse if ((stype==GF_ISOM_SUBTYPE_HVC1) || (stype==GF_ISOM_SUBTYPE_HVC2)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_HEV1) || (stype==GF_ISOM_SUBTYPE_HEV2)\n\t\t) {\n\t\t\tGF_HEVCConfig *hvcc = gf_isom_hevc_config_get(file, track, 1);\n\t\t\tif (rewrite_bs) {\n\t\t\t\tgf_hevc_change_par(hvcc, ar_num, ar_den);\n\t\t\t\te = gf_isom_hevc_config_update(file, track, 1, hvcc);\n\t\t\t} else {\n\t\t\t\tu32 i=0;\n\t\t\t\tGF_NALUFFParamArray *ar;\n\t\t\t\tar_num = ar_den = 0;\n\t\t\t\twhile ( (ar = gf_list_enum(hvcc->param_array, &i))) {\n\t\t\t\t\tif (ar->type==GF_HEVC_NALU_SEQ_PARAM) {\n\t\t\t\t\t\tGF_NALUFFParam *sl = gf_list_get(ar->nalus, 0);\n\t\t\t\t\t\tif (sl)\n\t\t\t\t\t\t\tgf_hevc_get_sps_info(sl->data, sl->size, NULL, NULL, NULL, &ar_num, &ar_den);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_odf_hevc_cfg_del(hvcc);\n\t\t\tif (e) return e;\n\t\t}\n\t\telse if (stype == GF_ISOM_SUBTYPE_AV01) {\n\t\t\t//GF_AV1Config *av1c = gf_isom_av1_config_get(file, track, 1);\n\t\t\t//TODO: e = gf_isom_av1_config_update(file, track, 1, av1c);\n\t\t\t//gf_odf_av1_cfg_del(av1c);\n\t\t\t//if (e) return e;\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\telse if ((stype==GF_ISOM_SUBTYPE_VVC1) || (stype==GF_ISOM_SUBTYPE_VVI1)\n\t\t) {\n\t\t\tGF_VVCConfig *vvcc = gf_isom_vvc_config_get(file, track, 1);\n\t\t\tif (rewrite_bs) {\n\t\t\t\tgf_vvc_change_par(vvcc, ar_num, ar_den);\n\t\t\t\te = gf_isom_vvc_config_update(file, track, 1, vvcc);\n\t\t\t} else {\n\t\t\t\tu32 i=0;\n\t\t\t\tGF_NALUFFParamArray *ar;\n\t\t\t\tar_num = ar_den = 0;\n\t\t\t\twhile ( (ar = gf_list_enum(vvcc->param_array, &i))) {\n\t\t\t\t\tif (ar->type==GF_VVC_NALU_SEQ_PARAM) {\n\t\t\t\t\t\tGF_NALUFFParam *sl = gf_list_get(ar->nalus, 0);\n\t\t\t\t\t\tif (sl)\n\t\t\t\t\t\t\tgf_vvc_get_sps_info(sl->data, sl->size, NULL, NULL, NULL, &ar_num, &ar_den);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_odf_vvc_cfg_del(vvcc);\n\t\t\tif (e) return e;\n\t\t}\n#endif\n\t\telse if (stype==GF_ISOM_SUBTYPE_MPEG4) {\n\t\t\tGF_ESD *esd = gf_isom_get_esd(file, track, 1);\n\t\t\tif (!esd || !esd->decoderConfig || (esd->decoderConfig->streamType!=4) ) {\n\t\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t}\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) {\n\t\t\t\tif (rewrite_bs) {\n\t\t\t\t\te = gf_m4v_rewrite_par(&esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength, ar_num, ar_den);\n\t\t\t\t\tif (!e) e = gf_isom_change_mpeg4_description(file, track, 1, esd);\n\t\t\t\t} else {\n\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\te = gf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\tar_num = dsi.par_num;\n\t\t\t\t\tar_den = dsi.par_den;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\t\tif (e) return e;\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tu32 mtype = gf_isom_get_media_type(file, track);\n\t\t\tif (gf_isom_is_video_handler_type(mtype)) {\n\t\t\t\tif (rewrite_bs) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER,\n\t\t\t\t\t\t(\"[ISOBMF] Warning: changing pixel ratio of media subtype \\\"%s\\\" is not supported, changing only \\\"pasp\\\" signaling\\n\",\n\t\t\t\t\t\t\tgf_4cc_to_str(gf_isom_get_media_subtype(file, track, 1)) ));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMF] Error: changing pixel ratio on non-video track.\\n\"));\n\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t}\n\t\t}\n\t\t//auto mode\n\t\tif (get_par_info && ((ar_num<=0) || (ar_den<=0))) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ISOBMF] No sample AR info present in sample description, ignoring SAR update\\n\"));\n\t\t\tif (force_par)\n\t\t\t\treturn gf_isom_set_pixel_aspect_ratio(file, track, 1, 1, 1, force_par);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\te = gf_isom_set_pixel_aspect_ratio(file, track, 1, ar_num, ar_den, force_par);\n\tif (e) return e;\n\n\tif ((ar_den>0) && (ar_num>0)) {\n\t\ttk_w = tk_w * ar_num / ar_den;\n\t}\n\t/*PASP has been removed or forced to 1:1, revert to full frame for track layout*/\n\telse {\n\t\te = gf_isom_get_visual_info(file, track, 1, &tk_w, &tk_h);\n\t\tif (e) return e;\n\t}\n\treturn gf_isom_set_track_layout_info(file, track, tk_w<<16, tk_h<<16, 0, 0, 0);\n}\n\nGF_EXPORT\nGF_Err gf_media_change_color(GF_ISOFile *file, u32 track, s32 fullrange, s32 vidformat, s32 colorprim, s32 transfer, s32 colmatrix)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tGF_Err e;\n\tu32 stype = gf_isom_get_media_subtype(file, track, 1);\n\tif ((stype==GF_ISOM_SUBTYPE_AVC_H264)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_AVC2_H264)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_AVC3_H264)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_AVC4_H264)\n\t) {\n\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(file, track, 1);\n\t\tgf_avc_change_color(avcc, fullrange, vidformat, colorprim, transfer, colmatrix);\n\t\te = gf_isom_avc_config_update(file, track, 1, avcc);\n\t\tgf_odf_avc_cfg_del(avcc);\n\t\tif (e) return e;\n\t\t//remove any colr box\n\t\treturn gf_isom_set_visual_color_info(file, track, 1, 0, 0, 0, 0, 0, NULL, 0);\n\t}\n\tif ((stype==GF_ISOM_SUBTYPE_HEV1)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_HEV2)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_HVC1)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_HVC2)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_LHV1)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_LHE1)\n\t) {\n\t\tGF_HEVCConfig *hvcc = gf_isom_hevc_config_get(file, track, 1);\n\t\tgf_hevc_change_color(hvcc, fullrange, vidformat, colorprim, transfer, colmatrix);\n\t\te = gf_isom_hevc_config_update(file, track, 1, hvcc);\n\t\tgf_odf_hevc_cfg_del(hvcc);\n\t\tif (e) return e;\n\t\t//remove any colr box\n\t\treturn gf_isom_set_visual_color_info(file, track, 1, 0, 0, 0, 0, 0, NULL, 0);\n\t}\n\tif ((stype==GF_ISOM_SUBTYPE_VVC1) || (stype==GF_ISOM_SUBTYPE_VVI1) ) {\n\t\tGF_VVCConfig *vvcc = gf_isom_vvc_config_get(file, track, 1);\n\t\tgf_vvc_change_color(vvcc, fullrange, vidformat, colorprim, transfer, colmatrix);\n\t\te = gf_isom_vvc_config_update(file, track, 1, vvcc);\n\t\tgf_odf_vvc_cfg_del(vvcc);\n\t\tif (e) return e;\n\t\t//remove any colr box\n\t\treturn gf_isom_set_visual_color_info(file, track, 1, 0, 0, 0, 0, 0, NULL, 0);\n\t}\n#endif\n\treturn GF_NOT_SUPPORTED;\n}\n\nGF_EXPORT\nGF_Err gf_media_remove_non_rap(GF_ISOFile *file, u32 track, Bool non_ref_only)\n{\n\tGF_Err e;\n\tu32 i, count, di;\n\tu64 offset, dur, last_dts;\n\tBool all_raps = (gf_isom_has_sync_points(file, track)==0) ? 1 : 0;\n\tif (all_raps) return GF_OK;\n\n\tlast_dts = 0;\n\tdur = gf_isom_get_media_duration(file, track);\n\n\tgf_isom_set_cts_packing(file, track, GF_TRUE);\n\n\tcount = gf_isom_get_sample_count(file, track);\n\tfor (i=0; i<count; i++) {\n\t\tBool remove = GF_TRUE;\n\t\tGF_ISOSample *samp = gf_isom_get_sample_info(file, track, i+1, &di, &offset);\n\t\tif (!samp) return gf_isom_last_error(file);\n\n\t\tif (samp->IsRAP) remove = GF_FALSE;\n\t\telse if (non_ref_only) {\n\t\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\t\t\tgf_isom_get_sample_flags(file, track, i+1, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\t\tif (dependedOn != 2) {\n\t\t\t\tremove = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tif (!remove) {\n\t\t\tlast_dts = samp->DTS;\n\t\t\tgf_isom_sample_del(&samp);\n\t\t\tcontinue;\n\t\t}\n\t\tgf_isom_sample_del(&samp);\n\t\te = gf_isom_remove_sample(file, track, i+1);\n\t\tif (e) return e;\n\t\ti--;\n\t\tcount--;\n\t}\n\tgf_isom_set_cts_packing(file, track, GF_FALSE);\n\tgf_isom_set_last_sample_duration(file, track, (u32) (dur - last_dts) );\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_EXPORT\nGF_Err gf_media_get_file_hash(const char *file, u8 hash[20])\n{\n\tu8 block[4096];\n\tu32 read;\n\tu64 size, tot;\n\tFILE *in;\n\tGF_SHA1Context *ctx;\n\tGF_Err e = GF_OK;\n#ifndef GPAC_DISABLE_ISOM\n\tGF_BitStream *bs = NULL;\n\tBool is_isom = gf_isom_probe_file(file);\n#endif\n\n\tin = gf_fopen(file, \"rb\");\n    if (!in) return GF_URL_ERROR;\n\tsize = gf_fsize(in);\n\n\tctx = gf_sha1_starts();\n\ttot = 0;\n#ifndef GPAC_DISABLE_ISOM\n\tif (is_isom) bs = gf_bs_from_file(in, GF_BITSTREAM_READ);\n#endif\n\n\twhile (tot<size) {\n#ifndef GPAC_DISABLE_ISOM\n\t\tif (is_isom) {\n\t\t\tu64 box_size = gf_bs_peek_bits(bs, 32, 0);\n\t\t\tu32 box_type = gf_bs_peek_bits(bs, 32, 4);\n\n\t\t\t/*64-bit size*/\n\t\t\tif (box_size==1) box_size = gf_bs_peek_bits(bs, 64, 8);\n\t\t\t/*till end of file*/\n\t\t\tif (!box_size) box_size = size - tot;\n\n\t\t\t/*skip all MutableDRMInformation*/\n\t\t\tif (box_type==GF_ISOM_BOX_TYPE_MDRI) {\n\t\t\t\tgf_bs_skip_bytes(bs, box_size);\n\t\t\t\ttot += box_size;\n\t\t\t} else {\n\t\t\t\tu64 bsize = 0;\n\t\t\t\twhile (bsize<box_size) {\n\t\t\t\t\tu32 to_read = (u32) ((box_size-bsize<4096) ? (box_size-bsize) : 4096);\n\t\t\t\t\tread = gf_bs_read_data(bs, (char *) block, to_read);\n\t\t\t\t\tif (!read || (read != to_read) ) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"corrupted isobmf file, box read \"LLU\" but expected still \"LLU\" bytes\\n\", bsize, box_size));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tgf_sha1_update(ctx, block, to_read);\n\t\t\t\t\tbsize += to_read;\n\t\t\t\t}\n\t\t\t\ttot += box_size;\n\t\t\t}\n\t\t} else\n#endif\n\t\t{\n\t\t\tread = (u32) gf_fread(block, 4096, in);\n\t\t\tif ((s32) read <= 0) {\n\t\t\t\tif (ferror(in))\n\t\t\t\t\te = GF_IO_ERR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_sha1_update(ctx, block, read);\n\t\t\ttot += read;\n\t\t}\n\t}\n\tgf_sha1_finish(ctx, hash);\n#ifndef GPAC_DISABLE_ISOM\n\tif (bs) gf_bs_del(bs);\n#endif\n\tgf_fclose(in);\n\treturn e;\n}\n\n#ifndef GPAC_DISABLE_ISOM\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nstatic const u32 ISMA_VIDEO_OD_ID = 20;\nstatic const u32 ISMA_AUDIO_OD_ID = 10;\n\nstatic const u32 ISMA_VIDEO_ES_ID = 201;\nstatic const u32 ISMA_AUDIO_ES_ID = 101;\n\n/*ISMA audio*/\nstatic const u8 ISMA_BIFS_AUDIO[] =\n{\n\t0xC0, 0x10, 0x12, 0x81, 0x30, 0x2A, 0x05, 0x7C\n};\n/*ISMA video*/\nstatic const u8 ISMA_GF_BIFS_VIDEO[] =\n{\n\t0xC0, 0x10, 0x12, 0x60, 0x42, 0x82, 0x28, 0x29,\n\t0xD0, 0x4F, 0x00\n};\n/*ISMA audio-video*/\nstatic const u8 ISMA_BIFS_AV[] =\n{\n\t0xC0, 0x10, 0x12, 0x81, 0x30, 0x2A, 0x05, 0x72,\n\t0x60, 0x42, 0x82, 0x28, 0x29, 0xD0, 0x4F, 0x00\n};\n\n/*image only - uses same visual OD ID as video*/\nstatic const u8 ISMA_BIFS_IMAGE[] =\n{\n\t0xC0, 0x11, 0xA4, 0xCD, 0x53, 0x6A, 0x0A, 0x44,\n\t0x13, 0x00\n};\n\n/*ISMA audio-image*/\nstatic const u8 ISMA_BIFS_AI[] =\n{\n\t0xC0, 0x11, 0xA5, 0x02, 0x60, 0x54, 0x0A, 0xE4,\n\t0xCD, 0x53, 0x6A, 0x0A, 0x44, 0x13, 0x00\n};\n\n\nGF_EXPORT\nGF_Err gf_media_make_isma(GF_ISOFile *mp4file, Bool keepESIDs, Bool keepImage, Bool no_ocr)\n{\n\tu32 AudioTrack, VideoTrack, Tracks, i, mType, bifsT, odT, descIndex, VID, AID, bifsID, odID;\n\tu32 bifs, w, h;\n\tBool is_image, image_track;\n\tGF_ESD *a_esd, *v_esd, *_esd;\n\tGF_ObjectDescriptor *od;\n\tGF_ODUpdate *odU;\n\tGF_ODCodec *codec;\n\tGF_ISOSample *samp;\n\tGF_BitStream *bs;\n\tu8 audioPL, visualPL;\n\n\tswitch (gf_isom_get_mode(mp4file)) {\n\tcase GF_ISOM_OPEN_EDIT:\n\tcase GF_ISOM_OPEN_WRITE:\n\tcase GF_ISOM_WRITE_EDIT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\n\tTracks = gf_isom_get_track_count(mp4file);\n\tAID = VID = 0;\n\tis_image = 0;\n\n\t//search for tracks\n\tfor (i=0; i<Tracks; i++) {\n\t\tGF_ESD *esd = gf_isom_get_esd(mp4file, i+1, 1);\n\t\t//remove from IOD\n\t\tgf_isom_remove_track_from_root_od(mp4file, i+1);\n\n\t\tmType = gf_isom_get_media_type(mp4file, i+1);\n\t\tswitch (mType) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n        case GF_ISOM_MEDIA_AUXV:\n        case GF_ISOM_MEDIA_PICT:\n\t\t\timage_track = 0;\n\t\t\tif (esd && esd->decoderConfig && ((esd->decoderConfig->objectTypeIndication==GF_CODECID_JPEG) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_PNG)) )\n\t\t\t\timage_track = 1;\n\n\t\t\t/*remove image tracks if wanted*/\n\t\t\tif (keepImage || !image_track) {\n\t\t\t\t/*only ONE video stream possible with ISMA*/\n\t\t\t\tif (VID) {\n\t\t\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor*)esd);\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[ISMA convert] More than one video track found, cannot convert file - remove extra track(s)\\n\"));\n\t\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t\t}\n\t\t\t\tVID = gf_isom_get_track_id(mp4file, i+1);\n\t\t\t\tis_image = image_track;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[ISMA convert] Visual track ID %d: only one sample found, assuming image and removing track\\n\", gf_isom_get_track_id(mp4file, i+1) ) );\n\t\t\t\tgf_isom_remove_track(mp4file, i+1);\n\t\t\t\ti -= 1;\n\t\t\t\tTracks = gf_isom_get_track_count(mp4file);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tif (AID) {\n\t\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor*)esd);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[ISMA convert] More than one audio track found, cannot convert file - remove extra track(s)\\n\") );\n\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t}\n\t\t\tAID = gf_isom_get_track_id(mp4file, i+1);\n\t\t\tbreak;\n\t\t/*clean file*/\n\t\tdefault:\n\t\t\tif (mType==GF_ISOM_MEDIA_HINT) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[ISMA convert] Removing Hint track ID %d\\n\", gf_isom_get_track_id(mp4file, i+1) ));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[ISMA convert] Removing track ID %d\\n\", gf_isom_get_track_id(mp4file, i+1) ));\n\t\t\t}\n\t\t\tgf_isom_remove_track(mp4file, i+1);\n\t\t\ti -= 1;\n\t\t\tTracks = gf_isom_get_track_count(mp4file);\n\t\t\tbreak;\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor*)esd);\n\t}\n\t//no audio no video\n\tif (!AID && !VID) return GF_OK;\n\n\t/*reset all PLs*/\n\tvisualPL = 0xFE;\n\taudioPL = 0xFE;\n\n\tod = (GF_ObjectDescriptor *) gf_isom_get_root_od(mp4file);\n\tif (od && (od->tag==GF_ODF_IOD_TAG)) {\n\t\taudioPL = ((GF_InitialObjectDescriptor*)od)->audio_profileAndLevel;\n\t\tvisualPL = ((GF_InitialObjectDescriptor*)od)->visual_profileAndLevel;\n\t}\n\tif (od) gf_odf_desc_del((GF_Descriptor *)od);\n\n\n\t//create the OD AU\n\tbifs = 0;\n\todU = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\n\ta_esd = v_esd = NULL;\n\n\tgf_isom_set_root_od_id(mp4file, 1);\n\n\tbifsID = 1;\n\todID = 2;\n\tif (keepESIDs) {\n\t\tbifsID = 1;\n\t\twhile ((bifsID==AID) || (bifsID==VID)) bifsID++;\n\t\todID = 2;\n\t\twhile ((odID==AID) || (odID==VID) || (odID==bifsID)) odID++;\n\n\t}\n\n\tVideoTrack = gf_isom_get_track_by_id(mp4file, VID);\n\tAudioTrack = gf_isom_get_track_by_id(mp4file, AID);\n\n\tw = h = 0;\n\tif (VideoTrack) {\n\t\tbifs = 1;\n\t\tod = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_OD_TAG);\n\t\tod->objectDescriptorID = ISMA_VIDEO_OD_ID;\n\n\t\tif (!keepESIDs && (VID != ISMA_VIDEO_ES_ID)) {\n\t\t\tgf_isom_set_track_id(mp4file, VideoTrack, ISMA_VIDEO_ES_ID);\n\t\t}\n\n\t\tv_esd = gf_isom_get_esd(mp4file, VideoTrack, 1);\n\t\tif (v_esd) {\n\t\t\tv_esd->OCRESID = no_ocr ? 0 : bifsID;\n\n\t\t\tgf_odf_desc_add_desc((GF_Descriptor *)od, (GF_Descriptor *)v_esd);\n\t\t\tgf_list_add(odU->objectDescriptors, od);\n\n\t\t\tgf_isom_get_track_layout_info(mp4file, VideoTrack, &w, &h, NULL, NULL, NULL);\n\t\t\tif (!w || !h) {\n\t\t\t\tgf_isom_get_visual_info(mp4file, VideoTrack, 1, &w, &h);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\tif (v_esd->decoderConfig\n\t\t\t\t\t&& (v_esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2)\n\t\t\t\t\t&& (v_esd->decoderConfig->streamType==GF_STREAM_VISUAL)\n\t\t\t\t\t&& v_esd->decoderConfig->decoderSpecificInfo\n\t\t\t\t\t&& v_esd->decoderConfig->decoderSpecificInfo->data\n\t\t\t\t) {\n\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\tgf_m4v_get_config(v_esd->decoderConfig->decoderSpecificInfo->data, v_esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\tif (!is_image && (!w || !h)) {\n\t\t\t\t\t\tw = dsi.width;\n\t\t\t\t\t\th = dsi.height;\n\t\t\t\t\t\tgf_isom_set_visual_info(mp4file, VideoTrack, 1, w, h);\n\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[ISMA convert] Adjusting visual track size to %d x %d\\n\", w, h));\n\t\t\t\t\t}\n\t\t\t\t\tif (dsi.par_num && dsi.par_den && (dsi.par_den!=dsi.par_num)) {\n\t\t\t\t\t\tw *= dsi.par_num;\n\t\t\t\t\t\tw /= dsi.par_den;\n\t\t\t\t\t}\n\t\t\t\t\tif (dsi.VideoPL) visualPL = dsi.VideoPL;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\tif (AudioTrack) {\n\t\tod = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_OD_TAG);\n\t\tod->objectDescriptorID = ISMA_AUDIO_OD_ID;\n\n\t\tif (!keepESIDs && (AID != ISMA_AUDIO_ES_ID)) {\n\t\t\tgf_isom_set_track_id(mp4file, AudioTrack, ISMA_AUDIO_ES_ID);\n\t\t}\n\n\t\ta_esd = gf_isom_get_esd(mp4file, AudioTrack, 1);\n\t\tif (a_esd) {\n\t\t\ta_esd->OCRESID = no_ocr ? 0 : bifsID;\n\n\t\t\tif (!keepESIDs) a_esd->ESID = ISMA_AUDIO_ES_ID;\n\t\t\tgf_odf_desc_add_desc((GF_Descriptor *)od, (GF_Descriptor *)a_esd);\n\t\t\tgf_list_add(odU->objectDescriptors, od);\n\t\t\tif (!bifs) {\n\t\t\t\tbifs = 3;\n\t\t\t} else {\n\t\t\t\tbifs = 2;\n\t\t\t}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\tif (a_esd->decoderConfig && (a_esd->decoderConfig->objectTypeIndication == GF_CODECID_AAC_MPEG4)\n\t\t\t\t&& a_esd->decoderConfig->decoderSpecificInfo\n\t\t\t\t&& a_esd->decoderConfig->decoderSpecificInfo->data\n\t\t\t) {\n\t\t\t\tGF_M4ADecSpecInfo cfg;\n\t\t\t\tgf_m4a_get_config(a_esd->decoderConfig->decoderSpecificInfo->data, a_esd->decoderConfig->decoderSpecificInfo->dataLength, &cfg);\n\t\t\t\taudioPL = cfg.audioPL;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\t/*update video cfg if needed*/\n\tif (v_esd) gf_isom_change_mpeg4_description(mp4file, VideoTrack, 1, v_esd);\n\tif (a_esd) gf_isom_change_mpeg4_description(mp4file, AudioTrack, 1, a_esd);\n\n\t/*likely 3GP or other files...*/\n\tif ((!a_esd && AudioTrack) || (!v_esd && VideoTrack)) return GF_OK;\n\n\t//get the OD sample\n\tcodec = gf_odf_codec_new();\n\tsamp = gf_isom_sample_new();\n\tgf_odf_codec_add_com(codec, (GF_ODCom *)odU);\n\tgf_odf_codec_encode(codec, 1);\n\tgf_odf_codec_get_au(codec, &samp->data, &samp->dataLength);\n\tgf_odf_codec_del(codec);\n\tsamp->CTS_Offset = 0;\n\tsamp->DTS = 0;\n\tsamp->IsRAP = RAP;\n\n\t/*create the OD track*/\n\todT = gf_isom_new_track(mp4file, odID, GF_ISOM_MEDIA_OD, gf_isom_get_timescale(mp4file));\n\tif (!odT) return gf_isom_last_error(mp4file);\n\n\t_esd = gf_odf_desc_esd_new(SLPredef_MP4);\n\tif (!_esd) return GF_OUT_OF_MEM;\n\n\t_esd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t_esd->decoderConfig->objectTypeIndication = GF_CODECID_OD_V1;\n\t_esd->decoderConfig->streamType = GF_STREAM_OD;\n\t_esd->ESID = odID;\n\t_esd->OCRESID = no_ocr ? 0 : bifsID;\n\tgf_isom_new_mpeg4_description(mp4file, odT, _esd, NULL, NULL, &descIndex);\n\tgf_odf_desc_del((GF_Descriptor *)_esd);\n\tgf_isom_add_sample(mp4file, odT, 1, samp);\n\tgf_isom_sample_del(&samp);\n\n\tgf_isom_set_track_interleaving_group(mp4file, odT, 1);\n\n\t/*create the BIFS track*/\n\tbifsT = gf_isom_new_track(mp4file, bifsID, GF_ISOM_MEDIA_SCENE, gf_isom_get_timescale(mp4file));\n\tif (!bifsT) return gf_isom_last_error(mp4file);\n\n\t_esd = gf_odf_desc_esd_new(SLPredef_MP4);\n\tif (!_esd) return GF_OUT_OF_MEM;\n\t\n\t_esd->decoderConfig->bufferSizeDB = 20;\n\t_esd->decoderConfig->objectTypeIndication = GF_CODECID_BIFS_V2;\n\t_esd->decoderConfig->streamType = GF_STREAM_SCENE;\n\t_esd->ESID = bifsID;\n\t_esd->OCRESID = 0;\n\n\t/*rewrite ISMA BIFS cfg*/\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t/*empty bifs stuff*/\n\tgf_bs_write_int(bs, 0, 17);\n\t/*command stream*/\n\tgf_bs_write_int(bs, 1, 1);\n\t/*in pixel metrics*/\n\tgf_bs_write_int(bs, 1, 1);\n\t/*with size*/\n\tgf_bs_write_int(bs, 1, 1);\n\tgf_bs_write_int(bs, w, 16);\n\tgf_bs_write_int(bs, h, 16);\n\tgf_bs_align(bs);\n\tgf_bs_get_content(bs, &_esd->decoderConfig->decoderSpecificInfo->data, &_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\tgf_isom_new_mpeg4_description(mp4file, bifsT, _esd, NULL, NULL, &descIndex);\n\tgf_odf_desc_del((GF_Descriptor *)_esd);\n\tgf_bs_del(bs);\n\tgf_isom_set_visual_info(mp4file, bifsT, descIndex, w, h);\n\n\tsamp = gf_isom_sample_new();\n\tsamp->CTS_Offset = 0;\n\tsamp->DTS = 0;\n\tswitch (bifs) {\n\tcase 1:\n\t\tif (is_image) {\n\t\t\tsamp->data = (char *) ISMA_BIFS_IMAGE;\n\t\t\tsamp->dataLength = 10;\n\t\t} else {\n\t\t\tsamp->data = (char *) ISMA_GF_BIFS_VIDEO;\n\t\t\tsamp->dataLength = 11;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif (is_image) {\n\t\t\tsamp->data = (char *) ISMA_BIFS_AI;\n\t\t\tsamp->dataLength = 15;\n\t\t} else {\n\t\t\tsamp->data = (char *) ISMA_BIFS_AV;\n\t\t\tsamp->dataLength = 16;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tsamp->data = (char *) ISMA_BIFS_AUDIO;\n\t\tsamp->dataLength = 8;\n\t\tbreak;\n\t}\n\n\tsamp->IsRAP = RAP;\n\n\tgf_isom_add_sample(mp4file, bifsT, 1, samp);\n\tsamp->data = NULL;\n\tgf_isom_sample_del(&samp);\n\tgf_isom_set_track_interleaving_group(mp4file, bifsT, 1);\n\n\tgf_isom_set_track_enabled(mp4file, bifsT, GF_TRUE);\n\tgf_isom_set_track_enabled(mp4file, odT, GF_TRUE);\n\tgf_isom_add_track_to_root_od(mp4file, bifsT);\n\tgf_isom_add_track_to_root_od(mp4file, odT);\n\n\tgf_isom_set_pl_indication(mp4file, GF_ISOM_PL_SCENE, 1);\n\tgf_isom_set_pl_indication(mp4file, GF_ISOM_PL_GRAPHICS, 1);\n\tgf_isom_set_pl_indication(mp4file, GF_ISOM_PL_OD, 1);\n\tgf_isom_set_pl_indication(mp4file, GF_ISOM_PL_AUDIO, audioPL);\n\tgf_isom_set_pl_indication(mp4file, GF_ISOM_PL_VISUAL, (u8) (is_image ? 0xFE : visualPL));\n\n\tgf_isom_set_brand_info(mp4file, GF_ISOM_BRAND_MP42, 1);\n\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_ISOM, GF_TRUE);\n\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP5, GF_TRUE);\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_media_make_3gpp(GF_ISOFile *mp4file)\n{\n\tu32 Tracks, i, mType, stype, nb_vid, nb_avc, nb_aud, nb_txt, nb_non_mp4, nb_dims;\n\tBool is_3g2 = 0;\n\n\tswitch (gf_isom_get_mode(mp4file)) {\n\tcase GF_ISOM_OPEN_EDIT:\n\tcase GF_ISOM_OPEN_WRITE:\n\tcase GF_ISOM_WRITE_EDIT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tTracks = gf_isom_get_track_count(mp4file);\n\tnb_vid = nb_aud = nb_txt = nb_avc = nb_non_mp4 = nb_dims = 0;\n\n\tfor (i=0; i<Tracks; i++) {\n\t\tgf_isom_remove_track_from_root_od(mp4file, i+1);\n\n\t\tmType = gf_isom_get_media_type(mp4file, i+1);\n\t\tstype = gf_isom_get_media_subtype(mp4file, i+1, 1);\n\t\tswitch (mType) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n        case GF_ISOM_MEDIA_AUXV:\n        case GF_ISOM_MEDIA_PICT:\n\t\t\t/*remove image tracks if wanted*/\n\t\t\tif (gf_isom_get_sample_count(mp4file, i+1)<=1) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[3GPP convert] Visual track ID %d: only one sample found\\n\", gf_isom_get_track_id(mp4file, i+1) ));\n\t\t\t\t//goto remove_track;\n\t\t\t}\n\n\t\t\tif (stype == GF_ISOM_SUBTYPE_MPEG4_CRYP) gf_isom_get_ismacryp_info(mp4file, i+1, 1, &stype, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\n\n\t\t\tswitch (stype) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tnb_vid++;\n\t\t\t\tnb_non_mp4 ++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t\t\tnb_vid++;\n\t\t\t\tnb_avc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\t{\n\t\t\t\tGF_ESD *esd = gf_isom_get_esd(mp4file, i+1, 1);\n\t\t\t\tu32 oti = (esd && esd->decoderConfig) ? esd->decoderConfig->objectTypeIndication : 0;\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\t\t/*both MPEG4-Video and H264/AVC/SVC are supported*/\n\t\t\t\tswitch (oti) {\n\t\t\t\tcase GF_CODECID_MPEG4_PART2:\n\t\t\t\tcase GF_CODECID_AVC:\n\t\t\t\tcase GF_CODECID_SVC:\n\t\t\t\tcase GF_CODECID_MVC:\n\t\t\t\t\tnb_vid++;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Video format not supported by 3GP - removing track ID %d\\n\", gf_isom_get_track_id(mp4file, i+1) ));\n\t\t\t\t\tgoto remove_track;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Video format not supported by 3GP - removing track ID %d\\n\", gf_isom_get_track_id(mp4file, i+1) ));\n\t\t\t\tgoto remove_track;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tif (stype == GF_ISOM_SUBTYPE_MPEG4_CRYP) gf_isom_get_ismacryp_info(mp4file, i+1, 1, &stype, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\n\t\t\tswitch (stype) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\tis_3g2 = 1;\n\t\t\t\tnb_aud++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\t\tnb_aud++;\n\t\t\t\tnb_non_mp4 ++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\t{\n\t\t\t\tGF_ESD *esd = gf_isom_get_esd(mp4file, i+1, 1);\n\t\t\t\tu32 oti = (esd && esd->decoderConfig) ? esd->decoderConfig->objectTypeIndication : 0;\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\n\t\t\t\tswitch (oti) {\n\t\t\t\tcase GF_CODECID_QCELP:\n\t\t\t\tcase GF_CODECID_EVRC:\n\t\t\t\tcase GF_CODECID_SMV:\n\t\t\t\t\tis_3g2 = 1;\n\t\t\t\tcase GF_CODECID_AAC_MPEG4:\n\t\t\t\t\tnb_aud++;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Audio format not supported by 3GP - removing track ID %d\\n\", gf_isom_get_track_id(mp4file, i+1) ));\n\t\t\t\t\tgoto remove_track;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Audio format not supported by 3GP - removing track ID %d\\n\", gf_isom_get_track_id(mp4file, i+1) ));\n\t\t\t\tgoto remove_track;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\t\tgf_isom_set_media_type(mp4file, i+1, GF_ISOM_MEDIA_TEXT);\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_MPEG_SUBT:\n\t\t\tnb_txt++;\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tif (stype == GF_ISOM_MEDIA_DIMS) {\n\t\t\t\tnb_dims++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t/*clean file*/\n\t\tdefault:\n\t\t\tif (mType==GF_ISOM_MEDIA_HINT) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Removing Hint track ID %d\\n\", gf_isom_get_track_id(mp4file, i+1) ));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Removing system track ID %d\\n\", gf_isom_get_track_id(mp4file, i+1) ));\n\t\t\t}\n\nremove_track:\n\t\t\tgf_isom_remove_track(mp4file, i+1);\n\t\t\ti -= 1;\n\t\t\tTracks = gf_isom_get_track_count(mp4file);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*no more IOD*/\n\tgf_isom_remove_root_od(mp4file);\n\n\tif (is_3g2) {\n\t\tgf_isom_set_brand_info(mp4file, GF_ISOM_BRAND_3G2A, 65536);\n\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP6, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP5, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GG6, GF_FALSE);\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Setting major brand to 3GPP2\\n\"));\n\t} else {\n\t\t/*update FType*/\n\t\tif ((nb_vid>1) || (nb_aud>1) || (nb_txt>1)) {\n\t\t\t/*3GPP general purpose*/\n\t\t\tgf_isom_set_brand_info(mp4file, GF_ISOM_BRAND_3GG6, 1024);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP6, GF_FALSE);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP5, GF_FALSE);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP4, GF_FALSE);\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Setting major brand to 3GPP Generic file\\n\"));\n\t\t} else if (nb_txt) {\n\t\t\tgf_isom_set_brand_info(mp4file, GF_ISOM_BRAND_3GP6, 1024);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP5, GF_TRUE);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP4, GF_TRUE);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GG6, GF_FALSE);\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Setting major brand to 3GPP V6 file\\n\"));\n\t\t} else if (nb_avc) {\n\t\t\tgf_isom_set_brand_info(mp4file, GF_ISOM_BRAND_3GP6, 0/*1024*/);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_AVC1, GF_TRUE);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP5, GF_FALSE);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP4, GF_FALSE);\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Setting major brand to 3GPP V6 file + AVC compatible\\n\"));\n\t\t} else {\n\t\t\tgf_isom_set_brand_info(mp4file, GF_ISOM_BRAND_3GP5, 0/*1024*/);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP6, 0);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP4, GF_TRUE);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GG6, GF_FALSE);\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Setting major brand to 3GPP V5 file\\n\"));\n\t\t}\n\t}\n\t/*add/remove MP4 brands and add isom*/\n\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_MP41, (u8) ((nb_avc||is_3g2||nb_non_mp4) ? GF_FALSE : GF_TRUE));\n\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_MP42, (u8) (nb_non_mp4 ? GF_FALSE : GF_TRUE));\n\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_ISOM, GF_TRUE);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_media_make_psp(GF_ISOFile *mp4)\n{\n\tu32 i, count;\n\tu32 nb_a, nb_v;\n\t/*psp track UUID*/\n\tbin128 psp_track_uuid = {0x55, 0x53, 0x4D, 0x54, 0x21, 0xD2, 0x4F, 0xCE, 0xBB, 0x88, 0x69, 0x5C, 0xFA, 0xC9, 0xC7, 0x40};\n\tu8 psp_track_sig [] = {0x00, 0x00, 0x00, 0x1C, 0x4D, 0x54, 0x44, 0x54, 0x00, 0x01, 0x00, 0x12, 0x00, 0x00, 0x00, 0x0A, 0x55, 0xC4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00};\n\t/*psp mov UUID*/\n\t//bin128 psp_uuid = {0x50, 0x52, 0x4F, 0x46, 0x21, 0xD2, 0x4F, 0xCE, 0xBB, 0x88, 0x69, 0x5C, 0xFA, 0xC9, 0xC7, 0x40};\n\n\tnb_a = nb_v = 0;\n\tcount = gf_isom_get_track_count(mp4);\n\tfor (i=0; i<count; i++) {\n\t\tswitch (gf_isom_get_media_type(mp4, i+1)) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tnb_v++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tnb_a++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ((nb_v != 1) && (nb_a!=1)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PSP convert] Movies need one audio track and one video track\\n\" ));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tfor (i=0; i<count; i++) {\n\t\tswitch (gf_isom_get_media_type(mp4, i+1)) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\t/*if no edit list, add one*/\n\t\t\tif (!gf_isom_get_edits_count(mp4, i+1)) {\n\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample_info(mp4, i+1, 1, NULL, NULL);\n\t\t\t\tif (samp) {\n\t\t\t\t\tgf_isom_append_edit(mp4, i+1, gf_isom_get_track_duration(mp4, i+1), samp->CTS_Offset, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*add PSP UUID*/\n\t\t\tgf_isom_remove_uuid(mp4, i+1, psp_track_uuid);\n\t\t\tgf_isom_add_uuid(mp4, i+1, psp_track_uuid, (char *) psp_track_sig, 28);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[PSP convert] Removing track ID %d\\n\", gf_isom_get_track_id(mp4, i+1) ));\n\t\t\tgf_isom_remove_track(mp4, i+1);\n\t\t\ti -= 1;\n\t\t\tcount -= 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_isom_set_brand_info(mp4, GF_ISOM_BRAND_MSNV, 0);\n\tgf_isom_modify_alternate_brand(mp4, GF_ISOM_BRAND_MSNV, GF_TRUE);\n\treturn GF_OK;\n}\n\nGF_Err gf_media_get_color_info(GF_ISOFile *file, u32 track, u32 sampleDescriptionIndex, u32 *colour_type, u16 *colour_primaries, u16 *transfer_characteristics, u16 *matrix_coefficients, Bool *full_range_flag)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tu32 stype = gf_isom_get_media_subtype(file, track, sampleDescriptionIndex);\n\tif ((stype==GF_ISOM_SUBTYPE_AVC_H264)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_AVC2_H264)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_AVC3_H264)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_AVC4_H264)\n\t) {\n\t\tAVCState avc;\n\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(file, track, sampleDescriptionIndex);\n\t\tu32 i;\n\t\ts32 idx;\n\t\tGF_NALUFFParam *slc;\n\n\t\tmemset(&avc, 0, sizeof(AVCState));\n\t\tavc.sps_active_idx = -1;\n\n\t\ti=0;\n\t\twhile ((slc = (GF_NALUFFParam *)gf_list_enum(avcc->sequenceParameterSets, &i))) {\n\t\t\tidx = gf_avc_read_sps(slc->data, slc->size, &avc, 0, NULL);\n\n\t\t\tif (idx<0) continue;\n\t\t\tif (! avc.sps[idx].vui_parameters_present_flag )\n\t\t\t\tcontinue;\n\n\t\t\t*colour_type = avc.sps[idx].vui.video_format;\n\t\t\t*colour_primaries = avc.sps[idx].vui.colour_primaries;\n\t\t\t*transfer_characteristics = avc.sps[idx].vui.transfer_characteristics;\n\t\t\t*matrix_coefficients = avc.sps[idx].vui.matrix_coefficients;\n\t\t\t*full_range_flag = avc.sps[idx].vui.video_full_range_flag;\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tgf_odf_avc_cfg_del(avcc);\n\t\treturn GF_NOT_FOUND;\n\t}\n\tif ((stype==GF_ISOM_SUBTYPE_HEV1)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_HEV2)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_HVC1)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_HVC2)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_LHV1)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_LHE1)\n\t) {\n\t\tHEVCState hvc;\n\t\tGF_HEVCConfig *hvcc = gf_isom_hevc_config_get(file, track, sampleDescriptionIndex);\n\t\tu32 i;\n\t\tGF_NALUFFParamArray *pa;\n\n\t\tmemset(&hvc, 0, sizeof(HEVCState));\n\t\thvc.sps_active_idx = -1;\n\n\t\ti=0;\n\t\twhile ((pa = (GF_NALUFFParamArray *)gf_list_enum(hvcc->param_array, &i))) {\n\t\t\tGF_NALUFFParam *slc;\n\t\t\tu32 j;\n\t\t\ts32 idx;\n\t\t\tif (pa->type != GF_HEVC_NALU_SEQ_PARAM) continue;\n\n\t\t\tj=0;\n\t\t\twhile ((slc = (GF_NALUFFParam *)gf_list_enum(pa->nalus, &j))) {\n\t\t\t\tidx = gf_hevc_read_sps(slc->data, slc->size, &hvc);\n\n\t\t\t\tif (idx<0) continue;\n\t\t\t\tif (! hvc.sps[idx].vui_parameters_present_flag)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t*colour_type = hvc.sps[idx].video_format;\n\t\t\t\t*colour_primaries = hvc.sps[idx].colour_primaries;\n\t\t\t\t*transfer_characteristics = hvc.sps[idx].transfer_characteristic;\n\t\t\t\t*matrix_coefficients = hvc.sps[idx].matrix_coeffs;\n\t\t\t\t*full_range_flag = hvc.sps[idx].video_full_range_flag;\n\t\t\t\tgf_odf_hevc_cfg_del(hvcc);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t\tgf_odf_hevc_cfg_del(hvcc);\n\t\treturn GF_NOT_FOUND;\n\t}\n\tif (stype==GF_ISOM_SUBTYPE_AV01) {\n\t\tAV1State av1;\n\n\t\tgf_av1_init_state(&av1);\n\t\tav1.config = gf_isom_av1_config_get(file, track, sampleDescriptionIndex);\n\t\tif (av1.config) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<gf_list_count(av1.config->obu_array); i++) {\n\t\t\t\tGF_BitStream *bs;\n\t\t\t\tObuType obu_type = 0;\n\t\t\t\tu32 hdr_size = 0;\n\t\t\t\tu64 obu_size = 0;\n\t\t\t\tGF_AV1_OBUArrayEntry *obu = gf_list_get(av1.config->obu_array, i);\n\t\t\t\tbs = gf_bs_new(obu->obu, (u32) obu->obu_length, GF_BITSTREAM_READ);\n\t\t\t\tgf_av1_parse_obu(bs, &obu_type, &obu_size, &hdr_size, &av1);\n\t\t\t\tgf_bs_del(bs);\n\n\t\t\t\tif (av1.color_description_present_flag) {\n\t\t\t\t\t*colour_type = 0;\n\t\t\t\t\t*colour_primaries = av1.color_primaries;\n\t\t\t\t\t*transfer_characteristics = av1.transfer_characteristics;\n\t\t\t\t\t*matrix_coefficients = av1.matrix_coefficients;\n\t\t\t\t\t*full_range_flag = av1.color_range;\n\t\t\t\t\tif (av1.config) gf_odf_av1_cfg_del(av1.config);\n\t\t\t\t\tgf_av1_reset_state(&av1, GF_TRUE);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (av1.config) gf_odf_av1_cfg_del(av1.config);\n\t\tgf_av1_reset_state(&av1, GF_TRUE);\n\t\treturn GF_NOT_FOUND;\n\t}\n\n#endif\n\treturn GF_NOT_SUPPORTED;\n}\n\nGF_Err gf_isom_set_meta_qt(GF_ISOFile *file);\n\nGF_EXPORT\nGF_Err gf_media_check_qt_prores(GF_ISOFile *mp4)\n{\n\tu32 i, count, timescale, def_dur=0, video_tk=0;\n\tu32 prores_type = 0;\n\tGF_Err e;\n\tu32 colour_type=0;\n\tu16 colour_primaries=0, transfer_characteristics=0, matrix_coefficients=0;\n\tBool full_range_flag=GF_FALSE;\n\tu32 hspacing=0, vspacing=0;\n\tu32 nb_video_tracks;\n\tu32 target_ts = 0, w=0, h=0, chunk_size=0;\n\n\tnb_video_tracks = 0;\n\n\tcount = gf_isom_get_track_count(mp4);\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype = gf_isom_get_media_type(mp4, i+1);\n\t\tif (mtype!=GF_ISOM_MEDIA_VISUAL) continue;\n\t\tnb_video_tracks++;\n\t\tif (!video_tk)\n\t\t\tvideo_tk = i+1;\n\t}\n\n\tif ((nb_video_tracks==1) && video_tk) {\n\t\tu32 video_subtype = gf_isom_get_media_subtype(mp4, video_tk, 1);\n\t\tswitch (video_subtype) {\n\t\tcase GF_QT_SUBTYPE_APCH:\n\t\tcase GF_QT_SUBTYPE_APCO:\n\t\tcase GF_QT_SUBTYPE_APCN:\n\t\tcase GF_QT_SUBTYPE_APCS:\n\t\tcase GF_QT_SUBTYPE_AP4X:\n\t\tcase GF_QT_SUBTYPE_AP4H:\n\t\t\tprores_type=video_subtype;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[QTFF/ProRes] Adjusting %s compliancy\\n\", prores_type ? \"ProRes\" : \"QTFF\"));\n\n\t//adjust audio tracks\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype = gf_isom_get_media_type(mp4, i+1);\n\n\t\t//remove bitrate info (isobmff)\n\t\tgf_isom_update_bitrate(mp4, i+1, 1, 0, 0, 0);\n\n\t\tif (mtype==GF_ISOM_MEDIA_AUDIO) {\n\t\t\tu32 sr, nb_ch, bps;\n\t\t\tgf_isom_get_audio_info(mp4, i+1, 1, &sr, &nb_ch, &bps);\n\t\t\tgf_isom_set_audio_info(mp4, i+1, 1, sr, nb_ch, bps, GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF);\n\n\t\t\tgf_isom_hint_max_chunk_duration(mp4, i+1, gf_isom_get_media_timescale(mp4, i+1) / 2);\n\t\t\tcontinue;\n\t\t}\n\t}\n\t//make QT\n\tgf_isom_remove_root_od(mp4);\n\tif (gf_isom_get_mode(mp4) != GF_ISOM_OPEN_WRITE) {\n\t\tgf_isom_set_brand_info(mp4, GF_ISOM_BRAND_QT, 512);\n\t\tgf_isom_reset_alt_brands(mp4);\n\t} else {\n\t\tu32 brand, version;\n\t\tgf_isom_get_brand_info(mp4, &brand, &version, NULL);\n\t\tif (brand != GF_ISOM_BRAND_QT) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[ProRes] Cannot change brand from \\\"%s\\\" to \\\"qt  \\\", flat storage used. Try using different storage mode\\n\", gf_4cc_to_str(brand)));\n\t\t}\n\t}\n\n\tgf_isom_set_meta_qt(mp4);\n\n\tif (!video_tk) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[QTFF] No visual track\\n\"));\n\t\treturn GF_OK;\n\t}\n\n\tif (nb_video_tracks>1) {\n\t\tif (prores_type) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"QTFF] cannot adjust params to prores, %d video tracks present\\n\", nb_video_tracks));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[ProRes] no prores codec found but %d video tracks, not adjusting file\\n\", nb_video_tracks));\n\t\treturn GF_OK;\n\t}\n\n\tif (prores_type) {\n\t\tchar *comp_name = NULL;\n\t\tswitch (prores_type) {\n\t\tcase GF_QT_SUBTYPE_APCH: comp_name = \"\\x0013\"\"Apple ProRes 422 HQ\"; break;\n\t\tcase GF_QT_SUBTYPE_APCO: comp_name = \"\\x0016\"\"Apple ProRes 422 Proxy\"; break;\n\t\tcase GF_QT_SUBTYPE_APCN: comp_name = \"\\x0010\"\"Apple ProRes 422\"; break;\n\t\tcase GF_QT_SUBTYPE_APCS: comp_name = \"\\x0013\"\"Apple ProRes 422 LT\"; break;\n\t\tcase GF_QT_SUBTYPE_AP4X: comp_name = \"\\x0014\"\"Apple ProRes 4444 XQ\"; break;\n\t\tcase GF_QT_SUBTYPE_AP4H: comp_name = \"\\x0011\"\"Apple ProRes 4444\"; break;\n\t\t}\n\t\tgf_isom_update_video_sample_entry_fields(mp4, video_tk, 1, 0, GF_4CC('a','p','p','l'), 0, 0x3FF, 72<<16, 72<<16, 1, comp_name, -1);\n\t}\n\n\ttimescale = gf_isom_get_media_timescale(mp4, video_tk);\n\tdef_dur = gf_isom_get_constant_sample_duration(mp4, video_tk);\n\tif (!def_dur) {\n\t\tdef_dur = gf_isom_get_sample_duration(mp4, video_tk, 2);\n\t\tif (!def_dur) {\n\t\t\tdef_dur = gf_isom_get_sample_duration(mp4, video_tk, 1);\n\t\t}\n\t}\n\tif (!def_dur) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[ProRes] cannot estimate default sample duration for video track\\n\"));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tgf_isom_get_pixel_aspect_ratio(mp4, video_tk, 1, &hspacing, &vspacing);\n\t//force 1:1\n\tif ((hspacing<=1) || (vspacing<=1)) {\n\t\thspacing = vspacing = 1;\n\t\tgf_isom_set_pixel_aspect_ratio(mp4, video_tk, 1, 1, 1, GF_TRUE);\n\t}\n\n\t//patch enof/prof/clef\n\tif (prores_type) {\n\t\tgf_isom_update_aperture_info(mp4, video_tk, GF_FALSE);\n\t}\n\n\te = gf_isom_get_color_info(mp4, video_tk, 1, &colour_type, &colour_primaries, &transfer_characteristics, &matrix_coefficients, &full_range_flag);\n\tif (e==GF_NOT_FOUND) {\n\t\tcolour_primaries = transfer_characteristics = matrix_coefficients = 0;\n\t\tif (prores_type) {\n\t\t\tu32 di;\n\t\t\tGF_ISOSample *s = gf_isom_get_sample(mp4, video_tk, 1, &di);\n\t\t\tif (s && s->dataLength>24) {\n\t\t\t\tGF_BitStream *bs = gf_bs_new(s->data, s->dataLength, GF_BITSTREAM_READ);\n\t\t\t\tgf_bs_read_u32(bs); //frame size\n\t\t\t\tgf_bs_read_u32(bs); //frame ID\n\t\t\t\tgf_bs_read_u32(bs); //frame header size + reserved + bs version\n\t\t\t\tgf_bs_read_u32(bs); //encoder id\n\t\t\t\tgf_bs_read_u32(bs); //w and h\n\t\t\t\tgf_bs_read_u16(bs); //bunch of flags\n\t\t\t\tcolour_primaries = gf_bs_read_u8(bs);\n\t\t\t\ttransfer_characteristics = gf_bs_read_u8(bs);\n\t\t\t\tmatrix_coefficients = gf_bs_read_u8(bs);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t}\n\t\t\tgf_isom_sample_del(&s);\n\t\t} else {\n\t\t\te = gf_media_get_color_info(mp4, video_tk, 1, &colour_type, &colour_primaries, &transfer_characteristics, &matrix_coefficients, &full_range_flag);\n\t\t\tif (e)\n\t\t\t\tcolour_primaries=0;\n\t\t}\n\t\tif (!colour_primaries) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[ProRes] No color info present in visual track, defaulting to BT709\\n\"));\n\t\t\tcolour_primaries = 1;\n\t\t\ttransfer_characteristics = 1;\n\t\t\tmatrix_coefficients = 1;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[ProRes] No color info present in visual track, extracting from %s\\n\", prores_type ? \"first ProRes frame\" : \"sample description\"));\n\t\t}\n\t\tgf_isom_set_visual_color_info(mp4, video_tk, 1, GF_4CC('n','c','l','c'), colour_primaries, transfer_characteristics, matrix_coefficients, GF_FALSE, NULL, 0);\n\t} else if (e) {\n\t\treturn e;\n\t}\n\tgf_isom_get_visual_info(mp4, video_tk, 1, &w, &h);\n\n\tu32 ifps;\n\tDouble FPS = timescale;\n\tFPS /= def_dur;\n\tFPS *= 100;\n\tifps = (u32) FPS;\n\tif (ifps>= 2996 && ifps<=2998) target_ts = 30000;\t//29.97\n\telse if (ifps>= 2999 && ifps<=3001) target_ts = 3000; //30\n\telse if (ifps>= 2495 && ifps<=2505) target_ts = 2500; //25\n\telse if (ifps >= 2396 && ifps<=2398) target_ts = 24000; //23.97\n\telse if ((ifps>=2399) && (ifps<=2401)) target_ts = 2400; //24\n\telse if (ifps>= 4990 && ifps<=5010) target_ts = 5000; //50\n\telse if (ifps>= 5993 && ifps<=5995) target_ts = 60000; //59.94\n\telse if (ifps>= 5996 && ifps<=6004) target_ts = 6000; //60\n\n\tif (!target_ts) {\n\t\tif (prores_type) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[ProRes] Unrecognized frame rate %g\\n\", ((Double)timescale)/def_dur ));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t} else {\n\t\t\ttarget_ts = timescale;\n\t\t}\n\t}\n\n\tif (target_ts != timescale) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[ProRes] Adjusting timescale to %d\\n\", target_ts));\n\t\tgf_isom_set_media_timescale(mp4, video_tk, target_ts, 0, 0);\n\t}\n\tgf_isom_set_timescale(mp4, target_ts);\n\tif ((w<=720) && (h<=576)) chunk_size = 2000000;\n\telse chunk_size = 4000000;\n\n\tgf_isom_set_interleave_time(mp4, 500);\n\tgf_isom_hint_max_chunk_size(mp4, video_tk, chunk_size);\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_EXPORT\nGF_ESD *gf_media_map_esd(GF_ISOFile *mp4, u32 track, u32 stsd_idx)\n{\n\tGF_ESD *esd;\n\tu32 subtype;\n\n\tif (!stsd_idx) stsd_idx = 1;\n\tsubtype = gf_isom_get_media_subtype(mp4, track, stsd_idx);\n\t/*all types with an official MPEG-4 mapping*/\n\tswitch (subtype) {\n\tcase GF_ISOM_SUBTYPE_MPEG4:\n\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\tcase GF_ISOM_SUBTYPE_HVC1:\n\tcase GF_ISOM_SUBTYPE_HEV1:\n\tcase GF_ISOM_SUBTYPE_HVC2:\n\tcase GF_ISOM_SUBTYPE_HEV2:\n\tcase GF_ISOM_SUBTYPE_LHV1:\n\tcase GF_ISOM_SUBTYPE_LHE1:\n\tcase GF_ISOM_SUBTYPE_AV01:\n\tcase GF_ISOM_SUBTYPE_VP09:\n\tcase GF_ISOM_SUBTYPE_VP08:\n\tcase GF_ISOM_SUBTYPE_VVC1:\n\tcase GF_ISOM_SUBTYPE_VVI1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA2:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM2:\n\t\treturn gf_isom_get_esd(mp4, track, stsd_idx);\n\t}\n\n\tif (subtype == GF_ISOM_SUBTYPE_OPUS) {\n\t\tesd = gf_isom_get_esd(mp4, track, 1);\n\t\tif (!esd) return NULL;\n\t\tif (!esd->decoderConfig) {\n\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\treturn NULL;\n\t\t}\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_OPUS;\n\t\treturn esd;\n\t}\n\n\tif (subtype == GF_ISOM_SUBTYPE_3GP_DIMS) {\n\t\tGF_BitStream *bs;\n\t\tGF_DIMSDescription dims;\n\t\tesd = gf_odf_desc_esd_new(0);\n\t\tif (!esd) return NULL;\n\t\tesd->slConfig->timestampResolution = gf_isom_get_media_timescale(mp4, track);\n\t\tesd->ESID = gf_isom_get_track_id(mp4, track);\n\t\tesd->OCRESID = esd->ESID;\n\t\tesd->decoderConfig->streamType = GF_STREAM_SCENE;\n\t\t/*use private DSI*/\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_DIMS;\n\t\tgf_isom_get_dims_description(mp4, track, 1, &dims);\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t/*format ext*/\n\t\tgf_bs_write_u8(bs, dims.profile);\n\t\tgf_bs_write_u8(bs, dims.level);\n\t\tgf_bs_write_int(bs, dims.pathComponents, 4);\n\t\tgf_bs_write_int(bs, dims.fullRequestHost, 1);\n\t\tgf_bs_write_int(bs, dims.streamType, 1);\n\t\tgf_bs_write_int(bs, dims.containsRedundant, 2);\n\t\tgf_bs_write_data(bs, (char*)dims.textEncoding, (u32) strlen(dims.textEncoding)+1);\n\t\tgf_bs_write_data(bs, (char*)dims.contentEncoding, (u32) strlen(dims.contentEncoding)+1);\n\t\tgf_bs_get_content(bs, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_bs_del(bs);\n\t\treturn esd;\n\t}\n\tif (mp4->convert_streaming_text && ((subtype == GF_ISOM_SUBTYPE_TEXT) || (subtype == GF_ISOM_SUBTYPE_TX3G))\n\t) {\n\t\treturn gf_isom_get_esd(mp4, track, stsd_idx);\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nGF_ESD *gf_media_map_item_esd(GF_ISOFile *mp4, u32 item_id)\n{\n\tu32 item_type;\n\tu32 prot_scheme, prot_scheme_version;\n\tBool is_self_ref;\n\tconst char *name;\n\tconst char *mime;\n\tconst char *encoding;\n\tconst char *url;\n\tconst char *urn;\n\tGF_ESD *esd;\n\tGF_Err e;\n\n\tu32 item_idx = gf_isom_get_meta_item_by_id(mp4, GF_TRUE, 0, item_id);\n\tif (!item_idx) return NULL;\n\n\te = gf_isom_get_meta_item_info(mp4, GF_TRUE, 0, item_idx, &item_id, &item_type, &prot_scheme, &prot_scheme_version, &is_self_ref, &name, &mime, &encoding, &url, &urn);\n\tif (e != GF_OK) return NULL;\n\n\tif (item_type == GF_ISOM_SUBTYPE_HVC1) {\n\t\tGF_ImageItemProperties props;\n\t\tesd = gf_odf_desc_esd_new(0);\n\t\tif (!esd) return NULL;\n\n\t\tif (item_id > (1 << 16)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"Item ID greater than 16 bits, does not fit on ES ID\\n\"));\n\t\t}\n\t\tesd->ESID = (u16)item_id;\n\t\tesd->OCRESID = esd->ESID;\n\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_HEVC;\n\t\te = gf_isom_get_meta_image_props(mp4, GF_TRUE, 0, item_id, &props, NULL);\n\t\tif (e == GF_OK && props.config) {\n\t\t\tgf_odf_hevc_cfg_write(((GF_HEVCConfigurationBox *)props.config)->config, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t}\n\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;\n\t\tesd->slConfig->useTimestampsFlag = 1;\n\t\tesd->slConfig->timestampResolution = 1000;\n\t\treturn esd;\n\t}\n\n\tif (item_type == GF_ISOM_SUBTYPE_AVC_H264) {\n\t\tGF_ImageItemProperties props;\n\t\tesd = gf_odf_desc_esd_new(0);\n\t\tif (!esd) return NULL;\n\n\t\tif (item_id > (1 << 16)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"Item ID greater than 16 bits, does not fit on ES ID\\n\"));\n\t\t}\n\t\tesd->ESID = (u16)item_id;\n\t\tesd->OCRESID = esd->ESID;\n\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_AVC;\n\t\te = gf_isom_get_meta_image_props(mp4, GF_TRUE, 0, item_id, &props, NULL);\n\t\tif (e == GF_OK && props.config) {\n\t\t\tgf_odf_avc_cfg_write(((GF_AVCConfigurationBox *)props.config)->config, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t}\n\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;\n\t\tesd->slConfig->useTimestampsFlag = 1;\n\t\tesd->slConfig->timestampResolution = 1000;\n\t\treturn esd;\n\t}\n\n\tif (item_type == GF_ISOM_SUBTYPE_AV01) {\n\t\tGF_ImageItemProperties props;\n\t\tesd = gf_odf_desc_esd_new(0);\n\t\tif (!esd) return NULL;\n\t\tif (item_id > (1 << 16)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"Item ID greater than 16 bits, does not fit on ES ID\\n\"));\n\t\t}\n\t\tesd->ESID = (u16)item_id;\n\t\tesd->OCRESID = esd->ESID;\n\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_AV1;\n\t\te = gf_isom_get_meta_image_props(mp4, GF_TRUE, 0, item_id, &props, NULL);\n\t\tif (e == GF_OK && props.config) {\n\t\t\tgf_odf_av1_cfg_write( ((GF_AV1ConfigurationBox *)props.config)->config, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t}\n\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;\n\t\tesd->slConfig->useTimestampsFlag = 1;\n\t\tesd->slConfig->timestampResolution = 1000;\n\t\treturn esd;\n\t}\n\n\tif ((item_type == GF_ISOM_SUBTYPE_JPEG) || (mime && !strcmp(mime, \"image/jpeg\")) ){\n\t\tGF_ImageItemProperties props;\n\t\tesd = gf_odf_desc_esd_new(0);\n\t\tif (!esd) return NULL;\n\n\t\tif (item_id > (1 << 16)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"Item ID greater than 16 bits, does not fit on ES ID\\n\"));\n\t\t}\n\t\tesd->ESID = (u16)item_id;\n\t\tesd->OCRESID = esd->ESID;\n\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_JPEG;\n\t\te = gf_isom_get_meta_image_props(mp4, GF_TRUE, 0, item_id, &props, NULL);\n\t\tif (e == GF_OK && props.config) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"JPEG image item decoder config not supported, patch welcome\\n\"));\n\t\t}\n\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;\n\t\tesd->slConfig->useTimestampsFlag = 1;\n\t\tesd->slConfig->timestampResolution = 1000;\n\t\treturn esd;\n\t}\n\n\tif ((item_type == GF_ISOM_SUBTYPE_PNG) || (mime && !strcmp(mime, \"image/png\")) ){\n\t\tGF_ImageItemProperties props;\n\t\tesd = gf_odf_desc_esd_new(0);\n\t\tif (!esd) return NULL;\n\n\t\tif (item_id > (1 << 16)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"Item ID greater than 16 bits, does not fit on ES ID\\n\"));\n\t\t}\n\t\tesd->ESID = (u16)item_id;\n\t\tesd->OCRESID = esd->ESID;\n\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_PNG;\n\t\te = gf_isom_get_meta_image_props(mp4, GF_TRUE, 0, item_id, &props, NULL);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"Error fetching item properties %s\\n\", gf_error_to_string(e) ));\n\t\t}\n\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;\n\t\tesd->slConfig->useTimestampsFlag = 1;\n\t\tesd->slConfig->timestampResolution = 1000;\n\t\treturn esd;\n\t}\n\n\tif (item_type == GF_ISOM_SUBTYPE_VVC1) {\n\t\tGF_ImageItemProperties props;\n\t\tesd = gf_odf_desc_esd_new(0);\n\t\tif (!esd) return NULL;\n\n\t\tif (item_id > (1 << 16)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"Item ID greater than 16 bits, does not fit on ES ID\\n\"));\n\t\t}\n\t\tesd->ESID = (u16)item_id;\n\t\tesd->OCRESID = esd->ESID;\n\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_VVC;\n\t\te = gf_isom_get_meta_image_props(mp4, GF_TRUE, 0, item_id, &props, NULL);\n\t\tif (e == GF_OK && props.config) {\n\t\t\tgf_odf_vvc_cfg_write(((GF_VVCConfigurationBox *)props.config)->config, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t}\n\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;\n\t\tesd->slConfig->useTimestampsFlag = 1;\n\t\tesd->slConfig->timestampResolution = 1000;\n\t\treturn esd;\n\t}\n\tif ((item_type == GF_ISOM_SUBTYPE_UNCV) || (item_type == GF_ISOM_ITEM_TYPE_UNCI)) {\n\t\tGF_ImageItemProperties props;\n\t\tesd = gf_odf_desc_esd_new(0);\n\t\tif (!esd) return NULL;\n\n\t\tif (item_id > (1 << 16)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"Item ID greater than 16 bits, does not fit on ES ID\\n\"));\n\t\t}\n\t\tesd->ESID = (u16)item_id;\n\t\tesd->OCRESID = esd->ESID;\n\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_RAW;\n\t\tGF_List *other_props = gf_list_new();\n\t\te = gf_isom_get_meta_image_props(mp4, GF_TRUE, 0, item_id, &props, other_props);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\tif ((e == GF_OK) && gf_list_count(other_props)) {\n\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tgf_isom_box_array_write(NULL, other_props, bs);\n\t\t\tgf_bs_get_content(bs, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_bs_del(bs);\n\t\t}\n#endif // GPAC_DISABLE_ISOM_WRITE\n\t\tgf_list_del(other_props);\n\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;\n\t\tesd->slConfig->useTimestampsFlag = 1;\n\t\tesd->slConfig->timestampResolution = 1000;\n\t\treturn esd;\n\t}\n\n\n\treturn NULL;\n}\n\n#endif /*GPAC_DISABLE_ISOM*/\n\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\nstatic s32 gf_get_DQId(GF_ISOFile *file, u32 track)\n{\n\tGF_AVCConfig *svccfg;\n\tGF_ISOSample *samp;\n\tu32 di = 0, cur_extract_mode;\n\tchar *buffer;\n\tGF_BitStream *bs;\n\tu32 max_size = 4096;\n\tu32 size, nalu_size_length;\n\tu8 nal_type;\n\ts32 DQId=0;\n\n\tsamp = NULL;\n\tbs = NULL;\n\tcur_extract_mode = gf_isom_get_nalu_extract_mode(file, track);\n\tgf_isom_set_nalu_extract_mode(file, track, GF_ISOM_NALU_EXTRACT_INSPECT);\n\tbuffer = (char*)gf_malloc(sizeof(char) * max_size);\n\tsvccfg = gf_isom_svc_config_get(file, track, 1);\n\tif (!svccfg)\n\t{\n\t\tDQId = 0;\n\t\tgoto exit;\n\t}\n\tsamp = gf_isom_get_sample(file, track, 1, &di);\n\tif (!samp)\n\t{\n\t\tDQId = -1;\n\t\tgoto exit;\n\t}\n\tbs = gf_bs_new(samp->data, samp->dataLength, GF_BITSTREAM_READ);\n\tnalu_size_length = 8 * svccfg->nal_unit_size;\n\twhile (gf_bs_available(bs))\n\t{\n\t\tsize = gf_bs_read_int(bs, nalu_size_length);\n\t\tif (size>max_size) {\n\t\t\tbuffer = (char*)gf_realloc(buffer, sizeof(char)*size);\n\t\t\tmax_size = size;\n\t\t}\n\t\tgf_bs_read_data(bs, buffer, size);\n\t\tnal_type = buffer[0] & 0x1F;\n\t\tif (nal_type == GF_AVC_NALU_SVC_SLICE)\n\t\t{\n\t\t\tDQId = buffer[2] & 0x7F;\n\t\t\tgoto exit;\n\t\t}\n\t}\nexit:\n\tif (svccfg) gf_odf_avc_cfg_del(svccfg);\n\tif (samp) gf_isom_sample_del(&samp);\n\tif (buffer) gf_free(buffer);\n\tif (bs) gf_bs_del(bs);\n\tgf_isom_set_nalu_extract_mode(file, track, cur_extract_mode);\n\treturn DQId;\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\nstatic Bool gf_isom_has_svc_explicit(GF_ISOFile *file, u32 track)\n{\n\tGF_AVCConfig *svccfg;\n\tGF_NALUFFParam *slc;\n\tu32 i;\n\tu8 type;\n\tBool ret = 0;\n\n\tsvccfg = gf_isom_svc_config_get(file, track, 1);\n\tif (!svccfg)\n\t\treturn 0;\n\n\tfor (i = 0; i < gf_list_count(svccfg->sequenceParameterSets); i++)\n\t{\n\t\tslc = (GF_NALUFFParam *)gf_list_get(svccfg->sequenceParameterSets, i);\n\t\ttype = slc->data[0] & 0x1F;\n\t\tif (type == GF_AVC_NALU_SEQ_PARAM)\n\t\t{\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgf_odf_avc_cfg_del(svccfg);\n\treturn ret;\n}\n\n\nstatic u32 gf_isom_get_track_id_max(GF_ISOFile *file)\n{\n\tu32 num_track, i, trackID;\n\tu32 max_id = 0;\n\n\tnum_track = gf_isom_get_track_count(file);\n\tfor (i = 1; i <= num_track; i++)\n\t{\n\t\ttrackID = gf_isom_get_track_id(file, i);\n\t\tif (max_id < trackID)\n\t\t\tmax_id = trackID;\n\t}\n\n\treturn max_id;\n}\n#endif\n\n/* Split SVC layers */\nGF_EXPORT\nGF_Err gf_media_split_svc(GF_ISOFile *file, u32 track, Bool splitAll)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tGF_AVCConfig *svccfg, *cfg;\n\tu32 num_svc_track, num_sample, svc_track, dst_track, ref_trackID, ref_trackNum, max_id, di, width, height, size, nalu_size_length, i, j, t, max_size, num_pps, num_sps, num_subseq, NALUnitHeader, data_offset, data_length, count, timescale, cur_extract_mode;\n\tGF_Err e;\n\tGF_NALUFFParam *slc, *sl;\n\tAVCState avc;\n\ts32 sps_id, pps_id;\n\tGF_ISOSample *samp, *dst_samp;\n\tGF_BitStream *bs, *dst_bs;\n\tGF_BitStream ** sample_bs;\n\tu8 nal_type, track_ref_index;\n\tchar *buffer;\n\ts32 *sps_track, *sps, *pps;\n\tu64 offset;\n\tBool is_splitted;\n\tBool *first_sample_track, *is_subseq_pps;\n\tu64 *first_DTS_track;\n\ts8 sample_offset;\n\n\tmax_size = 4096;\n\te = GF_OK;\n\tsamp = dst_samp = NULL;\n\tbs = NULL;\n\tsample_bs = NULL;\n\tsps_track = sps = pps = NULL;\n\tfirst_DTS_track = NULL;\n\tfirst_sample_track = is_subseq_pps = NULL;\n\tbuffer = NULL;\n\tcfg = NULL;\n\tnum_svc_track=0;\n\tcur_extract_mode = gf_isom_get_nalu_extract_mode(file, track);\n\tgf_isom_set_nalu_extract_mode(file, track, GF_ISOM_NALU_EXTRACT_INSPECT);\n\tsvccfg = gf_isom_svc_config_get(file, track, 1);\n\tif (!svccfg)\n\t{\n\t\te = GF_OK;\n\t\tgoto exit;\n\t}\n\tnum_sps = gf_list_count(svccfg->sequenceParameterSets);\n\tif (!num_sps)\n\t{\n\t\te = GF_OK;\n\t\tgoto exit;\n\t}\n\tnum_pps = gf_list_count(svccfg->pictureParameterSets);\n\tif ((gf_isom_get_avc_svc_type(file, track, 1) == GF_ISOM_AVCTYPE_SVC_ONLY) && !gf_isom_has_svc_explicit(file, track))\n\t\tis_splitted = 1;\n\telse\n\t\tis_splitted = 0;\n\tnum_subseq = gf_isom_has_svc_explicit(file, track) ? num_sps - 1 : num_sps;\n\n\tif (is_splitted)\n\t{\n\t\t/*this track has only one SVC ...*/\n\t\tif (num_sps == 1)\n\t\t{\n\t\t\t/*use 'all' mode -> stop*/\n\t\t\tif (splitAll)\n\t\t\t\tgoto exit;\n\t\t\t/*use 'base' mode -> merge SVC tracks*/\n\t\t\telse\n\t\t\t{\n\t\t\t\te = gf_media_merge_svc(file, track, 0);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\t/*this file has been in 'splitbase' mode*/\n\t\telse if (!splitAll)\n\t\t\tgoto exit;\n\n\t}\n\n\ttimescale = gf_isom_get_media_timescale(file, track);\n\tnum_svc_track = splitAll ? num_subseq : 1;\n\tmax_id = gf_isom_get_track_id_max(file);\n\tdi = 0;\n\n\tmemset(&avc, 0, sizeof(AVCState));\n\tavc.sps_active_idx = -1;\n\tnalu_size_length = 8 * svccfg->nal_unit_size;\n\t/*read all sps, but we need only the subset sequence parameter sets*/\n\tsps =  (s32 *) gf_malloc(num_subseq * sizeof(s32));\n\tsps_track = (s32 *) gf_malloc(num_subseq * sizeof(s32));\n\tcount = 0;\n\tfor (i = 0; i < num_sps; i++)\n\t{\n\t\tslc = (GF_NALUFFParam *)gf_list_get(svccfg->sequenceParameterSets, i);\n\t\tnal_type = slc->data[0] & 0x1F;\n\t\tsps_id = gf_avc_read_sps(slc->data, slc->size, &avc, 0, NULL);\n\t\tif (sps_id < 0) {\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (nal_type == GF_AVC_NALU_SVC_SUBSEQ_PARAM)\n\t\t{\n\t\t\tsps[count] = sps_id;\n\t\t\tsps_track[count] = i;\n\t\t\tcount++;\n\t\t}\n\t}\n\t/*for testing*/\n\tassert(count == num_subseq);\n\t/*read all pps*/\n\tpps =  (s32 *) gf_malloc(num_pps * sizeof(s32));\n\tfor (j = 0; j < num_pps; j++)\n\t{\n\t\tslc = (GF_NALUFFParam *)gf_list_get(svccfg->pictureParameterSets, j);\n\t\tpps_id = gf_avc_read_pps(slc->data, slc->size, &avc);\n\t\tif (pps_id < 0) {\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tgoto exit;\n\t\t}\n\t\tpps[j] = pps_id;\n\t}\n\tif (!is_splitted)\n\t\tref_trackID = gf_isom_get_track_id(file, track);\n\telse\n\t{\n\t\tgf_isom_get_reference(file, track, GF_ISOM_REF_BASE, 1, &ref_trackNum);\n\t\tref_trackID = gf_isom_get_track_id(file, ref_trackNum);\n\t}\n\n\tbuffer = (char*)gf_malloc(sizeof(char) * max_size);\n\t/*read first sample for determinating the order of SVC tracks*/\n\tcount = 0;\n\tsamp = gf_isom_get_sample(file, track, 1, &di);\n\tif (!samp)\n\t{\n\t\te = gf_isom_last_error(file);\n\t\tgoto exit;\n\t}\n\tbs = gf_bs_new(samp->data, samp->dataLength, GF_BITSTREAM_READ);\n\toffset = 0;\n\tis_subseq_pps = (Bool *) gf_malloc(num_pps*sizeof(Bool));\n\tfor (i = 0; i < num_pps; i++)\n\t\tis_subseq_pps[i] = 0;\n\twhile (gf_bs_available(bs))\n\t{\n\t\tgf_bs_enable_emulation_byte_removal(bs, GF_FALSE);\n\t\tsize = gf_bs_read_int(bs, nalu_size_length);\n\t\tif (size>max_size) {\n\t\t\tbuffer = (char*)gf_realloc(buffer, sizeof(char)*size);\n\t\t\tmax_size = size;\n\t\t}\n\n\t\tgf_avc_parse_nalu(bs, &avc);\n\t\tnal_type = avc.last_nal_type_parsed;\n\n\t\te = gf_bs_seek(bs, offset+nalu_size_length/8);\n\t\tif (e)\n\t\t\tgoto exit;\n\t\tgf_bs_read_data(bs, buffer, size);\n\t\toffset += size + nalu_size_length/8;\n\t\tif (nal_type == GF_AVC_NALU_SVC_SLICE)\n\t\t{\n\t\t\tfor (i = 0; i < num_pps; i++)\n\t\t\t{\n\t\t\t\tif (avc.s_info.pps->id == pps[i])\n\t\t\t\t{\n\t\t\t\t\tis_subseq_pps[i] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((count > 0) && (avc.s_info.pps->sps_id == sps[count-1]))\n\t\t\t\tcontinue;\n\t\t\t/*verify the order of SPS, reorder if necessary*/\n\t\t\tif (avc.s_info.pps->sps_id != sps[count])\n\t\t\t{\n\t\t\t\tfor (i = count+1; i < num_subseq; i++)\n\t\t\t\t{\n\t\t\t\t\t/*swap two SPS*/\n\t\t\t\t\tif (avc.s_info.pps->sps_id == sps[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tsps[i] = sps[count];\n\t\t\t\t\t\tsps[count] = avc.s_info.pps->sps_id;\n\t\t\t\t\t\tsps_track[count] = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\tbs = NULL;\n\n\tgf_isom_sample_del(&samp);\n\tsamp = NULL;\n\n\tfor (t = 0; t < num_svc_track; t++)\n\t{\n\t\tsvc_track = gf_isom_new_track(file, t+1+max_id, GF_ISOM_MEDIA_VISUAL, timescale);\n\t\tif (!svc_track)\n\t\t{\n\t\t\te = gf_isom_last_error(file);\n\t\t\tgoto exit;\n\t\t}\n\t\tgf_isom_set_track_enabled(file, svc_track, GF_TRUE);\n\t\tgf_isom_set_track_reference(file, svc_track, GF_ISOM_REF_BASE, ref_trackID);\n\t\t//copy over edit list\n\t\tfor (i=0; i<gf_isom_get_edits_count(file, track); i++) {\n\t\t\tGF_ISOEditType emode;\n\t\t\tu64 etime, edur, mtime;\n\t\t\tgf_isom_get_edit(file, track, i+1, &etime, &edur, &mtime, &emode);\n\t\t\tgf_isom_set_edit(file, svc_track, etime, edur, mtime, emode);\n\t\t}\n\t\tcfg = gf_odf_avc_cfg_new();\n\t\tcfg->complete_representation = 1; //SVC\n\t\t/*this layer depends on the base layer and the lower layers*/\n\t\tgf_isom_set_track_reference(file, svc_track, GF_ISOM_REF_SCAL, ref_trackID);\n\t\tfor (i = 0; i < t; i++)\n\t\t\tgf_isom_set_track_reference(file, svc_track, GF_ISOM_REF_SCAL, i+1+max_id);\n\n\t\te = gf_isom_svc_config_new(file, svc_track, cfg, NULL, NULL, &di);\n\t\tif (e)\n\t\t\tgoto exit;\n\t\tif (splitAll)\n\t\t{\n\t\t\tsps_id = sps[t];\n\t\t\twidth = avc.sps[sps_id].width;\n\t\t\theight = avc.sps[sps_id].height;\n\t\t\tgf_isom_set_visual_info(file, svc_track, di, width, height);\n\t\t\tcfg->configurationVersion = 1;\n\t\t\tcfg->chroma_bit_depth = 8 + avc.sps[sps_id].chroma_bit_depth_m8;\n\t\t\tcfg->chroma_format = avc.sps[sps_id].chroma_format;\n\t\t\tcfg->luma_bit_depth = 8 + avc.sps[sps_id].luma_bit_depth_m8;\n\t\t\tcfg->profile_compatibility = avc.sps[sps_id].prof_compat;\n\t\t\tcfg->AVCLevelIndication = avc.sps[sps_id].level_idc;\n\t\t\tcfg->AVCProfileIndication = avc.sps[sps_id].profile_idc;\n\t\t\tcfg->nal_unit_size = svccfg->nal_unit_size;\n\t\t\tslc = (GF_NALUFFParam *)gf_list_get(svccfg->sequenceParameterSets, sps_track[t]);\n\t\t\tsl = (GF_NALUFFParam*)gf_malloc(sizeof(GF_NALUFFParam));\n\t\t\tsl->id = slc->id;\n\t\t\tsl->size = slc->size;\n\t\t\tsl->data = (char*)gf_malloc(sizeof(char)*sl->size);\n\t\t\tmemcpy(sl->data, slc->data, sizeof(char)*sl->size);\n\t\t\tgf_list_add(cfg->sequenceParameterSets, sl);\n\t\t\tfor (j = 0; j < num_pps; j++)\n\t\t\t{\n\t\t\t\tpps_id = pps[j];\n\t\t\t\tif (is_subseq_pps[j] && (avc.pps[pps_id].sps_id == sps_id))\n\t\t\t\t{\n\t\t\t\t\tslc = (GF_NALUFFParam *)gf_list_get(svccfg->pictureParameterSets, j);\n\t\t\t\t\tsl = (GF_NALUFFParam*)gf_malloc(sizeof(GF_NALUFFParam));\n\t\t\t\t\tsl->id = slc->id;\n\t\t\t\t\tsl->size = slc->size;\n\t\t\t\t\tsl->data = (char*)gf_malloc(sizeof(char)*sl->size);\n\t\t\t\t\tmemcpy(sl->data, slc->data, sizeof(char)*sl->size);\n\t\t\t\t\tgf_list_add(cfg->pictureParameterSets, sl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (i = 0; i < num_subseq; i++)\n\t\t\t{\n\t\t\t\tsps_id = sps[i];\n\t\t\t\twidth = avc.sps[sps_id].width;\n\t\t\t\theight = avc.sps[sps_id].height;\n\t\t\t\tgf_isom_set_visual_info(file, svc_track, di, width, height);\n\t\t\t\tcfg->configurationVersion = 1;\n\t\t\t\tcfg->chroma_bit_depth = 8 + avc.sps[sps_id].chroma_bit_depth_m8;\n\t\t\t\tcfg->chroma_format = avc.sps[sps_id].chroma_format;\n\t\t\t\tcfg->luma_bit_depth = 8 + avc.sps[sps_id].luma_bit_depth_m8;\n\t\t\t\tcfg->profile_compatibility = avc.sps[sps_id].prof_compat;\n\t\t\t\tcfg->AVCLevelIndication = avc.sps[sps_id].level_idc;\n\t\t\t\tcfg->AVCProfileIndication = avc.sps[sps_id].profile_idc;\n\t\t\t\tcfg->nal_unit_size = svccfg->nal_unit_size;\n\t\t\t\tslc = (GF_NALUFFParam *)gf_list_get(svccfg->sequenceParameterSets, sps_track[i]);\n\t\t\t\tsl = (GF_NALUFFParam*)gf_malloc(sizeof(GF_NALUFFParam));\n\t\t\t\tsl->id = slc->id;\n\t\t\t\tsl->size = slc->size;\n\t\t\t\tsl->data = (char*)gf_malloc(sizeof(char)*sl->size);\n\t\t\t\tmemcpy(sl->data, slc->data, sizeof(char)*sl->size);\n\t\t\t\tgf_list_add(cfg->sequenceParameterSets, sl);\n\t\t\t\tfor (j = 0; j < num_pps; j++)\n\t\t\t\t{\n\t\t\t\t\tpps_id = pps[j];\n\t\t\t\t\tif (avc.pps[pps_id].sps_id == sps_id)\n\t\t\t\t\t{\n\t\t\t\t\t\tslc = (GF_NALUFFParam *)gf_list_get(svccfg->pictureParameterSets, j);\n\t\t\t\t\t\tsl = (GF_NALUFFParam*)gf_malloc(sizeof(GF_NALUFFParam));\n\t\t\t\t\t\tsl->id = slc->id;\n\t\t\t\t\t\tsl->size = slc->size;\n\t\t\t\t\t\tsl->data = (char*)gf_malloc(sizeof(char)*sl->size);\n\t\t\t\t\t\tmemcpy(sl->data, slc->data, sizeof(char)*sl->size);\n\t\t\t\t\t\tgf_list_add(cfg->pictureParameterSets, sl);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\te = gf_isom_svc_config_update(file, svc_track, 1, cfg, 0);\n\t\tif (e)\n\t\t\tgoto exit;\n\t\tgf_odf_avc_cfg_del(cfg);\n\t\tcfg = NULL;\n\t}\n\n\tnum_sample = gf_isom_get_sample_count(file, track);\n\tfirst_sample_track = (Bool *) gf_malloc((num_svc_track+1) * sizeof(Bool));\n\tfor (t = 0; t <= num_svc_track; t++)\n\t\tfirst_sample_track[t] = 1;\n\tfirst_DTS_track = (u64 *) gf_malloc((num_svc_track+1) * sizeof(u64));\n\tfor (t = 0; t <= num_svc_track; t++)\n\t\tfirst_DTS_track[t] = 0;\n\tfor (i = 1; i <= num_sample; i++)\n\t{\n\t\t/*reset*/\n\t\tmemset(buffer, 0, max_size);\n\n\t\tsamp = gf_isom_get_sample(file, track, i, &di);\n\t\tif (!samp)\n\t\t{\n\t\t\te = GF_IO_ERR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* Create (num_svc_track) SVC bitstreams + 1 AVC bitstream*/\n\t\tsample_bs = (GF_BitStream **) gf_malloc(sizeof(GF_BitStream *) * (num_svc_track+1));\n\t\tfor (j = 0; j <= num_svc_track; j++)\n\t\t\tsample_bs[j] = (GF_BitStream *) gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t/*write extractor*/\n\t\tfor (t = 0; t < num_svc_track; t++)\n\t\t{\n\t\t\t//reference to base layer\n\t\t\tgf_bs_write_int(sample_bs[t+1], 14, nalu_size_length); // extractor 's size = 14\n\t\t\tNALUnitHeader = 0; //reset\n\t\t\tNALUnitHeader |= 0x1F000000; // NALU type = 31\n\t\t\tgf_bs_write_u32(sample_bs[t+1], NALUnitHeader);\n\t\t\ttrack_ref_index = (u8) gf_isom_has_track_reference(file, t+1+max_id, GF_ISOM_REF_SCAL, ref_trackID);\n\t\t\tif (!track_ref_index)\n\t\t\t{\n\t\t\t\te = GF_CORRUPTED_DATA;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tgf_bs_write_u8(sample_bs[t+1], track_ref_index);\n\t\t\tsample_offset = 0;\n\t\t\tgf_bs_write_u8(sample_bs[t+1], sample_offset);\n\t\t\tdata_offset = 0;\n\t\t\tgf_bs_write_u32(sample_bs[t+1], data_offset);\n\t\t\tdata_length = 0;\n\t\t\tgf_bs_write_u32(sample_bs[t+1], data_length);\n\t\t\t//reference to previous layer(s)\n\t\t\tfor (j = 0; j < t; j++)\n\t\t\t{\n\t\t\t\tgf_bs_write_int(sample_bs[t+1], 14, nalu_size_length);\n\t\t\t\tNALUnitHeader = 0;\n\t\t\t\tNALUnitHeader |= 0x1F000000;\n\t\t\t\tgf_bs_write_u32(sample_bs[t+1], NALUnitHeader);\n\t\t\t\ttrack_ref_index = (u8) gf_isom_has_track_reference(file, t+1+max_id, GF_ISOM_REF_SCAL, j+1+max_id);\n\t\t\t\tif (!track_ref_index)\n\t\t\t\t{\n\t\t\t\t\te = GF_CORRUPTED_DATA;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tgf_bs_write_u8(sample_bs[t+1], track_ref_index);\n\t\t\t\tsample_offset = 0;\n\t\t\t\tgf_bs_write_u8(sample_bs[t+1], sample_offset);\n\t\t\t\tdata_offset = (j+1) * (nalu_size_length/8 + 14); // (nalu_size_length/8) bytes of NALU length field + 14 bytes of extractor per layer\n\t\t\t\tgf_bs_write_u32(sample_bs[t+1], data_offset);\n\t\t\t\tdata_length = 0;\n\t\t\t\tgf_bs_write_u32(sample_bs[t+1], data_length);\n\t\t\t}\n\t\t}\n\n\t\tbs = gf_bs_new(samp->data, samp->dataLength, GF_BITSTREAM_READ);\n\t\toffset = 0;\n\t\twhile (gf_bs_available(bs))\n\t\t{\n\t\t\tgf_bs_enable_emulation_byte_removal(bs, GF_FALSE);\n\t\t\tsize = gf_bs_read_int(bs, nalu_size_length);\n\t\t\tif (size>max_size) {\n\t\t\t\tbuffer = (char*)gf_realloc(buffer, sizeof(char)*size);\n\t\t\t\tmax_size = size;\n\t\t\t}\n\n\t\t\tgf_avc_parse_nalu(bs, &avc);\n\t\t\tnal_type = avc.last_nal_type_parsed;\n\t\t\te = gf_bs_seek(bs, offset+nalu_size_length/8);\n\t\t\tif (e)\n\t\t\t\tgoto exit;\n\t\t\tgf_bs_read_data(bs, buffer, size);\n\t\t\toffset += size + nalu_size_length/8;\n\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\t\t\tpps_id = avc.last_ps_idx;\n\t\t\t\tj = 0;\n\t\t\t\tdst_track = 0;\n\t\t\t\twhile (j < num_pps)\n\t\t\t\t{\n\t\t\t\t\tif (pps_id == pps[j])\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif ((j < num_pps) && (is_subseq_pps[j]))\n\t\t\t\t{\n\t\t\t\t\tif (splitAll)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (t = 0; t < num_svc_track; t++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (sps[t] == avc.pps[pps_id].sps_id)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdst_track = t + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tdst_track = 1;\n\t\t\t\t}\n\t\t\t\tdst_bs = sample_bs[dst_track];\n\t\t\t\tbreak;\n\t\t\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\t\t\tsps_id = avc.last_ps_idx;\n\t\t\t\tdst_track = 0;\n\t\t\t\tif (splitAll)\n\t\t\t\t{\n\t\t\t\t\tfor (t = 0; t < num_svc_track; t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (sps[t] == sps_id)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdst_track = t + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tdst_track = 1;\n\t\t\t\tdst_bs = sample_bs[dst_track];\n\t\t\t\tbreak;\n\t\t\tcase GF_AVC_NALU_SVC_SLICE:\n\t\t\t\tdst_track = 0;\n\t\t\t\tif (splitAll)\n\t\t\t\t{\n\t\t\t\t\tfor (t = 0; t < num_svc_track; t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (sps[t] == (avc.s_info.pps)->sps_id)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdst_track = t + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tdst_track = 1;\n\t\t\t\tdst_bs = sample_bs[dst_track];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdst_bs = sample_bs[0];\n\t\t\t}\n\n\t\t\tgf_bs_write_int(dst_bs, size, nalu_size_length);\n\t\t\tgf_bs_write_data(dst_bs, buffer, size);\n\t\t}\n\n\t\tfor (j = 0; j <= num_svc_track; j++)\n\t\t{\n\t\t\tif (gf_bs_get_position(sample_bs[j]))\n\t\t\t{\n\t\t\t\tif (first_sample_track[j])\n\t\t\t\t{\n\t\t\t\t\tfirst_sample_track[j] = 0;\n\t\t\t\t\tfirst_DTS_track[j] = samp->DTS;\n\t\t\t\t}\n\t\t\t\tdst_samp = gf_isom_sample_new();\n\t\t\t\tdst_samp->CTS_Offset = samp->CTS_Offset;\n\t\t\t\tdst_samp->DTS = samp->DTS - first_DTS_track[j];\n\t\t\t\tdst_samp->IsRAP = samp->IsRAP;\n\t\t\t\tgf_bs_get_content(sample_bs[j], &dst_samp->data, &dst_samp->dataLength);\n\t\t\t\tif (j) //SVC\n\t\t\t\t\te = gf_isom_add_sample(file, track+j, di, dst_samp);\n\t\t\t\telse\n\t\t\t\t\te = gf_isom_update_sample(file, track, i, dst_samp, 1);\n\t\t\t\tif (e)\n\t\t\t\t\tgoto exit;\n\t\t\t\tgf_isom_sample_del(&dst_samp);\n\t\t\t\tdst_samp = NULL;\n\t\t\t}\n\t\t\tgf_bs_del(sample_bs[j]);\n\t\t\tsample_bs[j] = NULL;\n\t\t}\n\t\tgf_free(sample_bs);\n\t\tsample_bs = NULL;\n\t\tgf_bs_del(bs);\n\t\tbs = NULL;\n\t\tgf_isom_sample_del(&samp);\n\t\tsamp = NULL;\n\t}\n\n\t/*add Editlist entry if DTS of the first sample is not zero*/\n\tfor (t = 0; t <= num_svc_track; t++)\n\t{\n\t\tif (first_DTS_track[t])\n\t\t{\n\t\t\tu32 media_ts, moov_ts, ts_offset;\n\t\t\tu64 dur;\n\t\t\tmedia_ts = gf_isom_get_media_timescale(file, t);\n\t\t\tmoov_ts = gf_isom_get_timescale(file);\n\t\t\tts_offset = (u32)(first_DTS_track[t]) * moov_ts / media_ts;\n\t\t\tdur = gf_isom_get_media_duration(file, t) * moov_ts / media_ts;\n\t\t\tgf_isom_set_edit(file, t, 0, ts_offset, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\tgf_isom_set_edit(file, t, ts_offset, dur, 0, GF_ISOM_EDIT_NORMAL);\n\t\t}\n\t}\n\n\t/*if this is a merged file*/\n\tif (!is_splitted)\n\t{\n\t\t/*a normal stream: delete SVC config*/\n\t\tif (!gf_isom_has_svc_explicit(file, track))\n\t\t{\n\t\t\tgf_isom_svc_config_del(file, track, 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts32 shift=0;\n\n\t\t\tfor (i = 0; i < gf_list_count(svccfg->sequenceParameterSets); i++)\n\t\t\t{\n\t\t\t\tslc = (GF_NALUFFParam *)gf_list_get(svccfg->sequenceParameterSets, i);\n\t\t\t\tsps_id = gf_avc_read_sps(slc->data, slc->size, &avc, 0, NULL);\n\t\t\t\tif (sps_id < 0) {\n\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tnal_type = slc->data[0] & 0x1F;\n\t\t\t\tif (nal_type == GF_AVC_NALU_SVC_SUBSEQ_PARAM)\n\t\t\t\t{\n\t\t\t\t\tgf_list_rem(svccfg->sequenceParameterSets, i);\n\t\t\t\t\tgf_free(slc->data);\n\t\t\t\t\tgf_free(slc);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (j = 0; j < gf_list_count(svccfg->pictureParameterSets); j++)\n\t\t\t{\n\t\t\t\tslc = (GF_NALUFFParam *)gf_list_get(svccfg->pictureParameterSets, j);\n\t\t\t\tpps_id = gf_avc_read_pps(slc->data, slc->size, &avc);\n\t\t\t\tif (pps_id < 0) {\n\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tif (is_subseq_pps[j+shift])\n\t\t\t\t{\n\t\t\t\t\tgf_list_rem(svccfg->pictureParameterSets, j);\n\t\t\t\t\tgf_free(slc->data);\n\t\t\t\t\tgf_free(slc);\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t}\n\t\t\te = gf_isom_svc_config_update(file, track, 1, svccfg, 0);\n\t\t\tif (e)\n\t\t\t\tgoto exit;\n\t\t}\n\t}\n\t/*if this is as splitted file: delete this track*/\n\telse\n\t{\n\t\tgf_isom_remove_track(file, track);\n\t}\n\nexit:\n\tif (svccfg) gf_odf_avc_cfg_del(svccfg);\n\tif (cfg) gf_odf_avc_cfg_del(cfg);\n\tif (samp) gf_isom_sample_del(&samp);\n\tif (dst_samp) gf_isom_sample_del(&dst_samp);\n\tif (bs) gf_bs_del(bs);\n\tif (sample_bs)\n\t{\n\t\tfor (i = 0; i <= num_svc_track; i++)\n\t\t\tgf_bs_del(sample_bs[i]);\n\t\tgf_free(sample_bs);\n\t}\n\tif (sps_track) gf_free(sps_track);\n\tif (sps) gf_free(sps);\n\tif (pps) gf_free(pps);\n\tif (first_sample_track) gf_free(first_sample_track);\n\tif (first_DTS_track) gf_free(first_DTS_track);\n\tif (buffer) gf_free(buffer);\n\tif (is_subseq_pps) gf_free(is_subseq_pps);\n\tgf_isom_set_nalu_extract_mode(file, track, cur_extract_mode);\n\treturn e;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n\n}\n\n/* Merge SVC layers*/\nGF_EXPORT\nGF_Err gf_media_merge_svc(GF_ISOFile *file, u32 track, Bool mergeAll)\n{\n\tGF_AVCConfig *svccfg, *cfg;\n\tu32 merge_track,  num_track, num_sample, size, i, t, di, max_size, nalu_size_length, ref_trackNum, ref_trackID, count, width, height, nb_EditList, media_ts, moov_ts;\n\tGF_ISOSample *avc_samp, *samp, *dst_samp;\n\tGF_BitStream *bs, *dst_bs;\n\tGF_Err e;\n\tchar *buffer;\n\ts32 *DQId;\n\tu32 *list_track_sorted, *cur_sample, *max_sample;\n\tu64 *DTS_offset;\n\tu64 EditTime, SegmentDuration, MediaTime;\n\tGF_ISOEditType EditMode;\n\tu8 nal_type;\n\tBool first_sample;\n\tu64 first_DTS, offset, dur;\n\tGF_NALUFFParam *slc, *sl;\n\n\te = GF_OK;\n\tdi = 1;\n\tmax_size = 4096;\n\twidth = height = 0;\n\tavc_samp = samp = dst_samp = NULL;\n\tsvccfg = cfg = NULL;\n\tbuffer = NULL;\n\tbs = dst_bs = NULL;\n\tDQId = NULL;\n\tlist_track_sorted = cur_sample = max_sample = NULL;\n\tDTS_offset = NULL;\n\n\tif (gf_isom_get_avc_svc_type(file, track, 1) == GF_ISOM_AVCTYPE_AVC_SVC)\n\t\tgoto exit;\n\n\tnum_track = gf_isom_get_track_count(file);\n\tif (num_track == 1)\n\t\tgoto exit;\n\tgf_isom_get_reference(file, track, GF_ISOM_REF_BASE, 1, &ref_trackNum);\n\tref_trackID = gf_isom_get_track_id(file, ref_trackNum);\n\tif (!ref_trackID)\n\t{\n\t\te = GF_ISOM_INVALID_MEDIA;\n\t\tgoto exit;\n\t}\n\n\tlist_track_sorted = (u32 *) gf_malloc(num_track * sizeof(u32));\n\tmemset(list_track_sorted, 0, num_track * sizeof(u32));\n\tDQId = (s32 *) gf_malloc(num_track * sizeof(s32));\n\tmemset(DQId, 0, num_track * sizeof(s32));\n\tcount = 0;\n\tfor (t = 1; t <= num_track; t++) {\n\t\tu32 pos = 0;\n\t\ts32 track_DQId = gf_get_DQId(file, t);\n\t\tif (track_DQId < 0) {\n\t\t\te = GF_ISOM_INVALID_MEDIA;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (!gf_isom_has_track_reference(file, t, GF_ISOM_REF_BASE, ref_trackID))\n\t\t{\n\t\t\tif (t != ref_trackNum) continue;\n\t\t\telse if (!mergeAll) continue;\n\t\t}\n\n\t\twhile ((pos < count ) && (DQId[pos] <= track_DQId))\n\t\t\tpos++;\n\t\tfor (i = count; i > pos; i--)\n\t\t{\n\t\t\tlist_track_sorted[i] = list_track_sorted[i-1];\n\t\t\tDQId[i] = DQId[i-1];\n\t\t}\n\t\tlist_track_sorted[pos] = t;\n\t\tDQId[pos] = track_DQId;\n\t\tcount++;\n\t}\n\n\tmerge_track = list_track_sorted[0];\n\tgf_isom_set_track_enabled(file, merge_track, GF_TRUE);\n\t/*rewrite svccfg*/\n\tsvccfg = gf_odf_avc_cfg_new();\n\tsvccfg->complete_representation = 1;\n\t/*rewrite visual info*/\n\tif (!mergeAll)\n\t{\n\t\tfor (t = 0; t < count; t++)\n\t\t\tgf_isom_get_visual_info(file, list_track_sorted[t], 1, &width, &height);\n\t\tgf_isom_set_visual_info(file, merge_track, 1, width, height);\n\t}\n\n\tfor (t = 0; t < count; t++)\n\t{\n\t\tcfg = gf_isom_svc_config_get(file, list_track_sorted[t], 1);\n\t\tif (!cfg)\n\t\t\tcontinue;\n\t\tsvccfg->configurationVersion = 1;\n\t\tsvccfg->chroma_bit_depth = cfg->chroma_bit_depth;\n\t\tsvccfg->chroma_format = cfg->chroma_format;\n\t\tsvccfg->luma_bit_depth = cfg->luma_bit_depth;\n\t\tsvccfg->profile_compatibility = cfg->profile_compatibility;\n\t\tsvccfg->AVCLevelIndication = cfg->AVCLevelIndication;\n\t\tsvccfg->AVCProfileIndication = cfg->AVCProfileIndication;\n\t\tsvccfg->nal_unit_size = cfg->nal_unit_size;\n\t\tfor (i = 0; i < gf_list_count(cfg->sequenceParameterSets); i++)\n\t\t{\n\t\t\tslc = (GF_NALUFFParam *)gf_list_get(cfg->sequenceParameterSets, i);\n\t\t\tsl = (GF_NALUFFParam*)gf_malloc(sizeof(GF_NALUFFParam));\n\t\t\tsl->id = slc->id;\n\t\t\tsl->size = slc->size;\n\t\t\tsl->data = (char*)gf_malloc(sizeof(char)*sl->size);\n\t\t\tmemcpy(sl->data, slc->data, sizeof(char)*sl->size);\n\t\t\tgf_list_add(svccfg->sequenceParameterSets, sl);\n\t\t}\n\t\tfor (i = 0; i < gf_list_count(cfg->pictureParameterSets); i++)\n\t\t{\n\t\t\tslc = (GF_NALUFFParam *)gf_list_get(cfg->pictureParameterSets, i);\n\t\t\tsl = (GF_NALUFFParam*)gf_malloc(sizeof(GF_NALUFFParam));\n\t\t\tsl->id = slc->id;\n\t\t\tsl->size = slc->size;\n\t\t\tsl->data = (char*)gf_malloc(sizeof(char)*sl->size);\n\t\t\tmemcpy(sl->data, slc->data, sizeof(char)*sl->size);\n\t\t\tgf_list_add(svccfg->pictureParameterSets, sl);\n\t\t}\n\t\tif (mergeAll)\n\t\t{\n\t\t\tgf_isom_svc_config_update(file, merge_track, 1, svccfg, 1);\n\t\t}\n\t\telse\n\t\t\tgf_isom_svc_config_update(file, merge_track, 1, svccfg, 0);\n\t\tgf_odf_avc_cfg_del(cfg);\n\t\tcfg = NULL;\n\t}\n\n\tcur_sample = (u32 *) gf_malloc(count * sizeof(u32));\n\tmax_sample = (u32 *) gf_malloc(count * sizeof(u32));\n\tfor (t = 0; t < count; t++)\n\t{\n\t\tcur_sample[t] = 1;\n\t\tmax_sample[t] = gf_isom_get_sample_count(file, list_track_sorted[t]);\n\t}\n\n\tDTS_offset = (u64 *) gf_malloc(count * sizeof(u64));\n\tfor (t = 0; t < count; t++) {\n\t\tDTS_offset[t] = 0;\n\t\tnb_EditList = gf_isom_get_edits_count(file, list_track_sorted[t]);\n\t\tif (nb_EditList) {\n\t\t\tmedia_ts = gf_isom_get_media_timescale(file, list_track_sorted[t]);\n\t\t\tmoov_ts = gf_isom_get_timescale(file);\n\t\t\tfor (i = 1; i <= nb_EditList; i++) {\n\t\t\t\te = gf_isom_get_edit(file, list_track_sorted[t], i, &EditTime, &SegmentDuration, &MediaTime, &EditMode);\n\t\t\t\tif (e) goto exit;\n\n\t\t\t\tif (!EditMode) {\n\t\t\t\t\tDTS_offset[t] = SegmentDuration * media_ts / moov_ts;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tnum_sample = gf_isom_get_sample_count(file, ref_trackNum);\n\tnalu_size_length = 8 * svccfg->nal_unit_size;\n\tfirst_sample = 1;\n\tfirst_DTS = 0;\n\tbuffer = (char*)gf_malloc(sizeof(char) * max_size);\n\tfor (t = 1; t <= num_track; t++)\n\t\tgf_isom_set_nalu_extract_mode(file, t, GF_ISOM_NALU_EXTRACT_INSPECT);\n\tfor (i = 1; i <= num_sample; i++)\n\t{\n\t\tdst_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t/*add extractor if nessassary*/\n\t\tif (!mergeAll)\n\t\t{\n\t\t\tu32 NALUnitHeader = 0;\n\t\t\tu8 track_ref_index;\n\t\t\ts8 sample_offset;\n\t\t\tu32 data_offset;\n\t\t\tu32 data_length;\n\n\t\t\tgf_bs_write_int(dst_bs, 14, nalu_size_length); // extractor 's size = 14\n\t\t\tNALUnitHeader |= 0x1F000000; // NALU type = 31\n\t\t\tgf_bs_write_u32(dst_bs, NALUnitHeader);\n\t\t\ttrack_ref_index = (u8) gf_isom_has_track_reference(file, merge_track, GF_ISOM_REF_SCAL, ref_trackID);\n\t\t\tif (!track_ref_index)\n\t\t\t{\n\t\t\t\te = GF_CORRUPTED_DATA;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tgf_bs_write_u8(dst_bs, track_ref_index);\n\t\t\tsample_offset = 0;\n\t\t\tgf_bs_write_u8(dst_bs, sample_offset);\n\t\t\tdata_offset = 0;\n\t\t\tgf_bs_write_u32(dst_bs, data_offset);\n\t\t\tdata_length = 0;\n\t\t\tgf_bs_write_u32(dst_bs, data_length);\n\t\t}\n\n\t\tavc_samp = gf_isom_get_sample(file, ref_trackNum, i, &di);\n\t\tif (!avc_samp) {\n\t\t\te = gf_isom_last_error(file);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tfor (t = 0; t < count; t++)\n\t\t{\n\t\t\tif (cur_sample[t] > max_sample[t])\n\t\t\t\tcontinue;\n\t\t\tsamp = gf_isom_get_sample(file, list_track_sorted[t], cur_sample[t], &di);\n\t\t\tif (!samp) {\n\t\t\t\te = gf_isom_last_error(file);\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tif ((samp->DTS + DTS_offset[t]) != avc_samp->DTS) {\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\tsamp = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbs = gf_bs_new(samp->data, samp->dataLength, GF_BITSTREAM_READ);\n\t\t\t/*reset*/\n\t\t\tmemset(buffer, 0, sizeof(char) * max_size);\n\t\t\twhile (gf_bs_available(bs))\n\t\t\t{\n\t\t\t\tsize = gf_bs_read_int(bs, nalu_size_length);\n\t\t\t\tif (size>max_size) {\n\t\t\t\t\tbuffer = (char*)gf_realloc(buffer, sizeof(char)*size);\n\t\t\t\t\tmax_size = size;\n\t\t\t\t}\n\t\t\t\tgf_bs_read_data(bs, buffer, size);\n\t\t\t\tnal_type = buffer[0] & 0x1F;\n\t\t\t\t/*skip extractor*/\n\t\t\t\tif (nal_type == GF_AVC_NALU_FF_EXTRACTOR)\n\t\t\t\t\tcontinue;\n\t\t\t\t/*copy to new bitstream*/\n\t\t\t\tgf_bs_write_int(dst_bs, size, nalu_size_length);\n\t\t\t\tgf_bs_write_data(dst_bs, buffer, size);\n\t\t\t}\n\t\t\tgf_bs_del(bs);\n\t\t\tbs = NULL;\n\t\t\tgf_isom_sample_del(&samp);\n\t\t\tsamp = NULL;\n\t\t\tcur_sample[t]++;\n\t\t}\n\n\t\t/*add sapmle to track*/\n\t\tif (gf_bs_get_position(dst_bs))\n\t\t{\n\t\t\tif (first_sample)\n\t\t\t{\n\t\t\t\tfirst_DTS = avc_samp->DTS;\n\t\t\t\tfirst_sample = 0;\n\t\t\t}\n\t\t\tdst_samp = gf_isom_sample_new();\n\t\t\tdst_samp->CTS_Offset = avc_samp->CTS_Offset;\n\t\t\tdst_samp->DTS = avc_samp->DTS - first_DTS;\n\t\t\tdst_samp->IsRAP = avc_samp->IsRAP;\n\t\t\tgf_bs_get_content(dst_bs, &dst_samp->data, &dst_samp->dataLength);\n\t\t\te = gf_isom_update_sample(file, merge_track, i, dst_samp, 1);\n\t\t\tif (e)\n\t\t\t\tgoto exit;\n\t\t}\n\t\tgf_isom_sample_del(&avc_samp);\n\t\tavc_samp = NULL;\n\t\tgf_bs_del(dst_bs);\n\t\tdst_bs = NULL;\n\t\tgf_isom_sample_del(&dst_samp);\n\t\tdst_samp = NULL;\n\t}\n\n\t/*Add EditList if nessessary*/\n\tif (!first_DTS)\n\t{\n\t\tmedia_ts = gf_isom_get_media_timescale(file, merge_track);\n\t\tmoov_ts = gf_isom_get_timescale(file);\n\t\toffset = (u32)(first_DTS) * moov_ts / media_ts;\n\t\tdur = gf_isom_get_media_duration(file, merge_track) * moov_ts / media_ts;\n\t\tgf_isom_set_edit(file, merge_track, 0, offset, 0, GF_ISOM_EDIT_EMPTY);\n\t\tgf_isom_set_edit(file, merge_track, offset, dur, 0, GF_ISOM_EDIT_NORMAL);\n\t}\n\n\t/*Delete SVC track(s) that references to ref_track*/\n\tfor (t = 1; t <= num_track; t++)\n\t{\n\t\tif (gf_isom_has_track_reference(file, t, GF_ISOM_REF_BASE, ref_trackID) && (t != merge_track))\n\t\t{\n\t\t\tgf_isom_remove_track(file, t);\n\t\t\tnum_track--; //we removed one track from file\n\t\t\tt--;\n\t\t}\n\t}\n\nexit:\n\tif (avc_samp) gf_isom_sample_del(&avc_samp);\n\tif (samp) gf_isom_sample_del(&samp);\n\tif (dst_samp) gf_isom_sample_del(&dst_samp);\n\tif (svccfg) gf_odf_avc_cfg_del(svccfg);\n\tif (cfg) gf_odf_avc_cfg_del(cfg);\n\tif (bs) gf_bs_del(bs);\n\tif (dst_bs) gf_bs_del(dst_bs);\n\tif (buffer) gf_free(buffer);\n\tif (DQId) gf_free(DQId);\n\tif (list_track_sorted) gf_free(list_track_sorted);\n\tif (cur_sample) gf_free(cur_sample);\n\tif (max_sample) gf_free(max_sample);\n\tif (DTS_offset) gf_free(DTS_offset);\n\tfor (t = 1; t <= gf_isom_get_track_count(file); t++)\n\t\tgf_isom_set_nalu_extract_mode(file, t, GF_ISOM_NALU_EXTRACT_DEFAULT);\n\treturn e;\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\n/* Split LHVC layers */\nstatic GF_NALUFFParamArray *alloc_hevc_param_array(GF_HEVCConfig *hevc_cfg, u8 type)\n{\n\tGF_NALUFFParamArray *ar;\n\tu32 i, count = hevc_cfg->param_array ? gf_list_count(hevc_cfg->param_array) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tar = gf_list_get(hevc_cfg->param_array, i);\n\t\tif (ar->type==type) return ar;\n\t}\n\tGF_SAFEALLOC(ar, GF_NALUFFParamArray);\n\tif (!ar) return NULL;\n\tar->nalus = gf_list_new();\n\tar->type = type;\n\tif (ar->type == GF_HEVC_NALU_VID_PARAM)\n\t\tgf_list_insert(hevc_cfg->param_array, ar, 0);\n\telse\n\t\tgf_list_add(hevc_cfg->param_array, ar);\n\treturn ar;\n}\n\ntypedef struct{\n\tu8 layer_id_plus_one;\n\tu8 min_temporal_id;\n\tu8 max_temporal_id;\n} LInfo;\n\ntypedef struct\n{\n\tu32 track_num;\n\tu32 layer_id;\n\tGF_HEVCConfig *lhvccfg;\n\tGF_BitStream *bs;\n\tu32 data_offset, data_size;\n\tu32 temporal_id_sample, max_temporal_id_sample;\n\tLInfo layers[64];\n\tu32 width, height;\n\tBool has_samples;\n\tBool non_tsa_vcl;\n} LHVCTrackInfo;\n\n\nGF_EXPORT\nGF_Err gf_media_filter_hevc(GF_ISOFile *file, u32 track, u8 max_temporal_id_plus_one, u8 max_layer_id_plus_one)\n{\n\tGF_HEVCConfig *hevccfg, *lhvccfg;\n\tu32 i, count, cur_extract_mode;\n\tchar *nal_data=NULL;\n\tu32 nal_alloc_size, nalu_size;\n\tGF_Err e = GF_OK;\n\n\tif (!max_temporal_id_plus_one && !max_layer_id_plus_one)\n\t\treturn GF_OK;\n\n\thevccfg = gf_isom_hevc_config_get(file, track, 1);\n\tlhvccfg = gf_isom_lhvc_config_get(file, track, 1);\n\tif (!hevccfg && !lhvccfg)\n\t\tnalu_size = 4;\n\telse\n\t\tnalu_size = hevccfg ? hevccfg->nal_unit_size : lhvccfg->nal_unit_size;\n\n\tcur_extract_mode = gf_isom_get_nalu_extract_mode(file, track);\n\tgf_isom_set_nalu_extract_mode(file, track, GF_ISOM_NALU_EXTRACT_INSPECT);\n\n\tnal_alloc_size = 10000;\n\tnal_data = gf_malloc(sizeof(char) * nal_alloc_size);\n\n\tif (hevccfg) {\n\t\tcount = gf_list_count(hevccfg->param_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 j, count2;\n\t\t\tGF_NALUFFParamArray *ar = (GF_NALUFFParamArray *)gf_list_get(hevccfg->param_array, i);\n\t\t\tcount2 = gf_list_count(ar->nalus);\n\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(ar->nalus, j);\n\t\t\t\t//u8 nal_type = (sl->data[0] & 0x7E) >> 1;\n\t\t\t\tu8 layer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3);\n\t\t\t\tu8 temporal_id_plus_one = sl->data[1] & 0x07;\n\n\t\t\t\tif ((max_temporal_id_plus_one && (temporal_id_plus_one > max_temporal_id_plus_one)) || (max_layer_id_plus_one && (layer_id+1 > max_layer_id_plus_one))) {\n\t\t\t\t\tgf_list_rem(ar->nalus, j);\n\t\t\t\t\tj--;\n\t\t\t\t\tcount2--;\n\t\t\t\t\tgf_free(sl->data);\n\t\t\t\t\tgf_free(sl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (lhvccfg) {\n\t\tcount = gf_list_count(lhvccfg->param_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 j, count2;\n\t\t\tGF_NALUFFParamArray *ar = (GF_NALUFFParamArray *)gf_list_get(lhvccfg->param_array, i);\n\t\t\tcount2 = gf_list_count(ar->nalus);\n\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(ar->nalus, j);\n\t\t\t\t//u8 nal_type = (sl->data[0] & 0x7E) >> 1;\n\t\t\t\tu8 layer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3);\n\t\t\t\tu8 temporal_id_plus_one = sl->data[1] & 0x07;\n\n\t\t\t\tif ((max_temporal_id_plus_one && (temporal_id_plus_one > max_temporal_id_plus_one)) || (max_layer_id_plus_one && (layer_id+1 > max_layer_id_plus_one))) {\n\t\t\t\t\tgf_list_rem(ar->nalus, j);\n\t\t\t\t\tj--;\n\t\t\t\t\tcount2--;\n\t\t\t\t\tgf_free(sl->data);\n\t\t\t\t\tgf_free(sl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//parse all samples\n\tcount = gf_isom_get_sample_count(file, track);\n\tfor (i=0; i<count; i++) {\n\t\tGF_BitStream *bs, *dst_bs;\n\t\tu32 di;\n\t\tGF_ISOSample *sample;\n\n\t\tsample = gf_isom_get_sample(file, track, i+1, &di);\n\n\t\tbs = gf_bs_new(sample->data, sample->dataLength, GF_BITSTREAM_READ);\n\t\tdst_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\twhile (gf_bs_available(bs)) {\n\t\t\tu32 size = gf_bs_read_int(bs, nalu_size*8);\n\t\t\tu8 fzero = gf_bs_read_int(bs, 1);\n\t\t\tu8 nal_type = gf_bs_read_int(bs, 6);\n\t\t\tu8 layer_id = gf_bs_read_int(bs, 6);\n\t\t\tu8 temporal_id_plus_one = gf_bs_read_int(bs, 3);\n\t\t\tsize -= 2;\n\n\t\t\tif ((max_temporal_id_plus_one && (temporal_id_plus_one > max_temporal_id_plus_one))\n\t\t\t\t|| (max_layer_id_plus_one && (layer_id+1 > max_layer_id_plus_one))\n\t\t\t) {\n\t\t\t\tgf_bs_skip_bytes(bs, size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (size>nal_alloc_size) {\n\t\t\t\tnal_alloc_size = size;\n\t\t\t\tnal_data = (char *)gf_realloc(nal_data, nal_alloc_size);\n\t\t\t}\n\t\t\tgf_bs_read_data(bs, nal_data, size);\n\n\t\t\tgf_bs_write_int(dst_bs, size+2, nalu_size*8);\n\t\t\tgf_bs_write_int(dst_bs, fzero, 1);\n\t\t\tgf_bs_write_int(dst_bs, nal_type, 6);\n\t\t\tgf_bs_write_int(dst_bs, layer_id, 6);\n\t\t\tgf_bs_write_int(dst_bs, temporal_id_plus_one, 3);\n\t\t\tgf_bs_write_data(dst_bs, nal_data, size);\n\t\t}\n\n\t\tgf_bs_del(bs);\n\t\tgf_free(sample->data);\n\t\tsample->data = NULL;\n\t\tsample->dataLength = 0;\n\n\t\tgf_bs_get_content(dst_bs, &sample->data, &sample->dataLength);\n\t\te = gf_isom_update_sample(file, track, i+1, sample, GF_TRUE);\n\t\tgf_bs_del(dst_bs);\n\t\tgf_isom_sample_del(&sample);\n\n\t\tif (e)\n\t\t\tgoto exit;\n\t}\n\nexit:\n\tif (lhvccfg) gf_odf_hevc_cfg_del(lhvccfg);\n\tif (hevccfg) gf_odf_hevc_cfg_del(hevccfg);\n\tgf_isom_set_nalu_extract_mode(file, track, cur_extract_mode);\n\tif (nal_data) gf_free(nal_data);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_media_split_lhvc(GF_ISOFile *file, u32 track, Bool for_temporal_sublayers, Bool splitAll, GF_LHVCExtractoreMode extractor_mode)\n{\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\tLHVCTrackInfo sti[64];\n\tGF_HEVCConfig *hevccfg, *lhvccfg;\n\tu32 sample_num, count, cur_extract_mode, j, k, max_layer_id;\n\tchar *nal_data=NULL;\n\tu32 nal_alloc_size;\n\tu32 nal_unit_size=0;\n\tBool single_layer_per_track=GF_TRUE;\n\tGF_Err e = GF_OK;\n\tHEVCState hevc_state;\n\n\tmemset(&hevc_state, 0, sizeof(HEVCState));\n\n\thevccfg = gf_isom_hevc_config_get(file, track, 1);\n\tlhvccfg = gf_isom_lhvc_config_get(file, track, 1);\n\tif (!lhvccfg && !for_temporal_sublayers) {\n\t\tif (hevccfg) gf_odf_hevc_cfg_del(hevccfg);\n\t\treturn GF_OK;\n\t}\n\telse if (for_temporal_sublayers) {\n\t\tif (lhvccfg) {\n\t\t\tif (hevccfg) gf_odf_hevc_cfg_del(hevccfg);\n\t\t\tgf_odf_hevc_cfg_del(lhvccfg);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\tif (!hevccfg) return GF_NOT_SUPPORTED;\n\n\t\tif (hevccfg->numTemporalLayers<=1) {\n\t\t\tgf_odf_hevc_cfg_del(hevccfg);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tcur_extract_mode = gf_isom_get_nalu_extract_mode(file, track);\n\tgf_isom_set_nalu_extract_mode(file, track, GF_ISOM_NALU_EXTRACT_INSPECT);\n\n\tmemset(sti, 0, sizeof(sti));\n\tsti[0].track_num = track;\n\tsti[0].has_samples=GF_TRUE;\n\tmax_layer_id = 0;\n\n\tnal_unit_size = lhvccfg ? lhvccfg->nal_unit_size : hevccfg->nal_unit_size;\n\n\tif (!for_temporal_sublayers) {\n\t\tu32 i, pass, base_layer_pass = GF_TRUE;\n\t\tGF_HEVCConfig *cur_cfg = hevccfg;\n\nreparse:\n\t\t//split all SPS/PPS/VPS from lhvccfg\n\t\tfor (pass=0; pass<3; pass++) {\n\t\tcount = gf_list_count(cur_cfg->param_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 count2;\n\t\t\tGF_NALUFFParamArray *s_ar;\n\t\t\tGF_NALUFFParamArray *ar = gf_list_get(cur_cfg->param_array, i);\n\t\t\tif ((pass==0) && (ar->type!=GF_HEVC_NALU_VID_PARAM)) continue;\n\t\t\telse if ((pass==1) && (ar->type!=GF_HEVC_NALU_SEQ_PARAM)) continue;\n\t\t\telse if ((pass==2) && (ar->type!=GF_HEVC_NALU_PIC_PARAM)) continue;\n\n\t\t\tcount2 = gf_list_count(ar->nalus);\n\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\tGF_NALUFFParam *sl = gf_list_get(ar->nalus, j);\n//\t\t\t\tu8 nal_type = (sl->data[0] & 0x7E) >> 1;\n\t\t\t\tu8 layer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3);\n\n\t\t\t\tif (ar->type==GF_HEVC_NALU_SEQ_PARAM) {\n\t\t\t\t\tu32 lw, lh;\n\t\t\t\t\ts32 idx = gf_hevc_get_sps_info_with_state(&hevc_state, sl->data, sl->size, NULL, &lw, &lh, NULL, NULL);\n\t\t\t\t\tif (idx>=0) {\n\t\t\t\t\t\tif (lw > sti[layer_id].width) sti[layer_id].width = lw;\n\t\t\t\t\t\tif (lh > sti[layer_id].height) sti[layer_id].height = lh;\n\t\t\t\t\t}\n\t\t\t\t} else if (ar->type==GF_HEVC_NALU_PIC_PARAM) {\n\t\t\t\t\tgf_hevc_read_pps(sl->data, sl->size, &hevc_state);\n\t\t\t\t} else if (ar->type==GF_HEVC_NALU_VID_PARAM) {\n\t\t\t\t\tgf_hevc_read_vps(sl->data, sl->size, &hevc_state);\n\t\t\t\t}\n\n\t\t\t\t//don't touch base layer\n\t\t\t\tif (!layer_id) {\n\t\t\t\t\tassert(base_layer_pass);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!splitAll) layer_id = 1;\n\n\t\t\t\tif (max_layer_id < layer_id)\n\t\t\t\t\tmax_layer_id = layer_id;\n\n\t\t\t\tif (!sti[layer_id].lhvccfg) {\n\t\t\t\t\tGF_List *backup_list;\n\t\t\t\t\tsti[layer_id].lhvccfg = gf_odf_hevc_cfg_new();\n\t\t\t\t\tbackup_list = sti[layer_id].lhvccfg->param_array;\n\t\t\t\t\tmemcpy(sti[layer_id].lhvccfg , lhvccfg ? lhvccfg : hevccfg, sizeof(GF_HEVCConfig));\n\t\t\t\t\tsti[layer_id].lhvccfg->param_array = backup_list;\n\n\t\t\t\t\tsti[layer_id].lhvccfg->is_lhvc = 1;\n\t\t\t\t\tsti[layer_id].lhvccfg->complete_representation = 1;\n\t\t\t\t}\n\n\t\t\t\ts_ar = alloc_hevc_param_array(sti[layer_id].lhvccfg, ar->type);\n\t\t\t\tgf_list_add(s_ar->nalus, sl);\n\t\t\t\tgf_list_rem(ar->nalus, j);\n\t\t\t\tj--;\n\t\t\t\tcount2--;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (base_layer_pass) {\n\t\t\tbase_layer_pass = GF_FALSE;\n\t\t\tcur_cfg = lhvccfg;\n\t\t\tgoto reparse;\n\t\t}\n\t} else {\n\t\tgf_isom_set_cts_packing(file, track, GF_TRUE);\n\t}\n\n\t//CLARIFY whether this is correct: we duplicate all VPS in the enhancement layer ...\n\t//we do this because if we split the tracks some info for setting up the enhancement layer\n\t//is in the VPS\n\tif (extractor_mode != GF_LHVC_EXTRACTORS_ON) {\n\t\tu32 i;\n\t\tcount = gf_list_count(hevccfg->param_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 count2;\n\t\t\tGF_NALUFFParamArray *s_ar;\n\t\t\tGF_NALUFFParamArray *ar = gf_list_get(hevccfg->param_array, i);\n\t\t\tif (ar->type != GF_HEVC_NALU_VID_PARAM) continue;\n\t\t\tcount2 = gf_list_count(ar->nalus);\n\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\tGF_NALUFFParam *sl = gf_list_get(ar->nalus, j);\n\t\t\t\tu8 layer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3);\n\t\t\t\tif (layer_id) continue;\n\n\t\t\t\tfor (k=0; k <= max_layer_id; k++) {\n\t\t\t\t\tGF_NALUFFParam *sl2;\n\t\t\t\t\tif (!sti[k].lhvccfg) continue;\n\n\t\t\t\t\ts_ar = alloc_hevc_param_array(sti[k].lhvccfg, ar->type);\n\t\t\t\t\ts_ar->array_completeness = ar->array_completeness;\n\n\t\t\t\t\tGF_SAFEALLOC(sl2, GF_NALUFFParam);\n\t\t\t\t\tif (!sl2) break;\n\t\t\t\t\tsl2->data = gf_malloc(sl->size);\n\t\t\t\t\tif (!sl2->data) {\n\t\t\t\t\t\tgf_free(sl2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(sl2->data, sl->data, sl->size);\n\t\t\t\t\tsl2->id = sl->id;\n\t\t\t\t\tsl2->size = sl->size;\n\t\t\t\t\tgf_list_add(s_ar->nalus, sl2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//update lhvc config\n\tif (for_temporal_sublayers) {\n\t\te = gf_isom_lhvc_config_update(file, track, 1, NULL, GF_ISOM_LEHVC_WITH_BASE_BACKWARD);\n\t} else {\n\t\te = gf_isom_lhvc_config_update(file, track, 1, NULL, GF_ISOM_LEHVC_WITH_BASE_BACKWARD);\n\t}\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[HEVC] Failed to update HEVC/LHVC config\\n\"));\n\t\tgoto exit;\n\t}\n\n\t//purge all linf sample groups\n\tgf_isom_remove_sample_group(file, track, GF_ISOM_SAMPLE_GROUP_LINF);\n\n\tnal_alloc_size = 10000;\n\tnal_data = gf_malloc(sizeof(char) * nal_alloc_size);\n\t//parse all samples\n\tcount = gf_isom_get_sample_count(file, track);\n\tfor (sample_num=0; sample_num<count; sample_num++) {\n\t\tGF_BitStream *bs;\n\t\tu32 di;\n\t\tGF_ISOSample *sample;\n\t\tBool is_irap;\n\t\tGF_ISOSampleRollType roll_type;\n\t\ts32 roll_distance;\n\t\tu8 cur_max_layer_id = 0;\n\n\t\tsample = gf_isom_get_sample(file, track, sample_num+1, &di);\n\t\tgf_isom_get_sample_rap_roll_info(file, track, sample_num+1, &is_irap, &roll_type, &roll_distance);\n\n\t\tbs = gf_bs_new(sample->data, sample->dataLength, GF_BITSTREAM_READ);\n\t\twhile (gf_bs_available(bs)) {\n\t\t\tu8 orig_layer_id, nal_size;\n\t\t\tu32 size = gf_bs_read_int(bs, nal_unit_size*8);\n\t\t\tu32 offset = (u32) gf_bs_get_position(bs);\n\t\t\tu8 fzero = gf_bs_read_int(bs, 1);\n\t\t\tu8 nal_type = gf_bs_read_int(bs, 6);\n\t\t\tu8 layer_id = orig_layer_id = gf_bs_read_int(bs, 6);\n\t\t\tu8 temporal_id = gf_bs_read_int(bs, 3);\n\n\t\t\tif (for_temporal_sublayers) {\n\t\t\t\tu32 tid = temporal_id-1;\n\t\t\t\tif (tid && !sti[tid].layer_id) {\n\t\t\t\t\tsti[tid].layer_id=tid;\n\t\t\t\t}\n\t\t\t\tlayer_id = tid;\n\n\t\t\t\tif ((nal_type <= GF_HEVC_NALU_SLICE_CRA)\n\t\t\t\t\t&& (nal_type != GF_HEVC_NALU_SLICE_TSA_N)\n\t\t\t\t\t&& (nal_type != GF_HEVC_NALU_SLICE_TSA_R))\n\t\t\t\t\t\tsti[layer_id].non_tsa_vcl = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (layer_id && !sti[layer_id].layer_id) {\n\t\t\t\t\tsti[layer_id].layer_id=layer_id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!splitAll && layer_id) layer_id = 1;\n\n\t\t\tif (cur_max_layer_id < layer_id) {\n\t\t\t\tcur_max_layer_id = layer_id;\n\t\t\t}\n\n\t\t\tnal_size = size;\n\n\t\t\tif (!sti[layer_id].bs)\n\t\t\t\tsti[layer_id].bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\tgf_bs_write_int(sti[layer_id].bs, size, nal_unit_size*8);\n\t\t\tgf_bs_write_int(sti[layer_id].bs, fzero, 1);\n\t\t\tgf_bs_write_int(sti[layer_id].bs, nal_type, 6);\n\t\t\tgf_bs_write_int(sti[layer_id].bs, orig_layer_id, 6);\n\t\t\tgf_bs_write_int(sti[layer_id].bs, temporal_id, 3);\n\t\t\tsize -= 2;\n\n\t\t\tsti[layer_id].layers[layer_id].layer_id_plus_one = layer_id+1;\n\t\t\tsti[layer_id].temporal_id_sample = temporal_id;\n\n\t\t\tif (!sti[layer_id].layers[layer_id].min_temporal_id || (sti[layer_id].layers[layer_id].min_temporal_id > temporal_id)) {\n\t\t\t\tsti[layer_id].layers[layer_id].min_temporal_id = temporal_id;\n\t\t\t}\n\t\t\tif (!sti[layer_id].layers[layer_id].max_temporal_id || (sti[layer_id].layers[layer_id].max_temporal_id < temporal_id)) {\n\t\t\t\tsti[layer_id].layers[layer_id].max_temporal_id = temporal_id;\n\t\t\t}\n\n\t\t\tif (!sti[layer_id].max_temporal_id_sample || (sti[layer_id].max_temporal_id_sample < temporal_id)) {\n\t\t\t\tsti[layer_id].max_temporal_id_sample = temporal_id;\n\t\t\t}\n\n\t\t\tif (! for_temporal_sublayers) {\n\n\t\t\t\tif (nal_type==GF_HEVC_NALU_SEQ_PARAM) {\n\t\t\t\t\tu32 lw, lh;\n\t\t\t\t\ts32 idx = gf_hevc_get_sps_info_with_state(&hevc_state, sample->data + offset, nal_size, NULL, &lw, &lh, NULL, NULL);\n\t\t\t\t\tif (idx>=0) {\n\t\t\t\t\t\tif (lw > sti[layer_id].width) sti[layer_id].width = lw;\n\t\t\t\t\t\tif (lh > sti[layer_id].height) sti[layer_id].height = lh;\n\t\t\t\t\t}\n\t\t\t\t} else if (nal_type==GF_HEVC_NALU_PIC_PARAM) {\n\t\t\t\t\tgf_hevc_read_pps(sample->data + offset, nal_size, &hevc_state);\n\t\t\t\t} else if (nal_type==GF_HEVC_NALU_VID_PARAM) {\n\t\t\t\t\tgf_hevc_read_vps(sample->data + offset, nal_size, &hevc_state);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (size>nal_alloc_size) {\n\t\t\t\tnal_alloc_size = size;\n\t\t\t\tnal_data = gf_realloc(nal_data, nal_alloc_size);\n\t\t\t}\n\n\t\t\tgf_bs_read_data(bs, nal_data, size);\n\t\t\tgf_bs_write_data(sti[layer_id].bs, nal_data, size);\n\t\t}\n\t\tgf_bs_del(bs);\n\n\t\tif (cur_max_layer_id>max_layer_id) {\n\t\t\tmax_layer_id = cur_max_layer_id;\n\t\t}\n\t\tif (for_temporal_sublayers && hevccfg->numTemporalLayers>max_layer_id+1) {\n\t\t\tmax_layer_id = hevccfg->numTemporalLayers-1;\n\t\t}\n\n\t\tgf_free(sample->data);\n\t\tsample->data = NULL;\n\t\tsample->dataLength = 0;\n\t\t//reset all samples on all layers found - we may have layers not present in this sample, we still need to process these layers when extractors are used\n\t\tfor (j=0; j<=max_layer_id; j++) {\n\t\t\tif (!for_temporal_sublayers && ! sti[j].bs) {\n\t\t\t\tif (!sti[j].track_num || (extractor_mode != GF_LHVC_EXTRACTORS_ON) ) {\n\t\t\t\t\tsti[j].data_offset =  sti[j].data_size = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//clone track\n\t\t\tif (! sti[j].track_num) {\n\t\t\t\tu32 track_id = gf_isom_get_track_id(file, track);\n\t\t\t\te = gf_isom_clone_track(file, track, file, 0, &sti[j].track_num);\n\t\t\t\tif (e) goto exit;\n\n\t\t\t\tif (! for_temporal_sublayers) {\n\t\t\t\t\t//happens for inband param\n\t\t\t\t\tif (!sti[j].lhvccfg) {\n\t\t\t\t\t\tGF_List *backup_list;\n\t\t\t\t\t\tsti[j].lhvccfg = gf_odf_hevc_cfg_new();\n\t\t\t\t\t\tbackup_list = sti[j].lhvccfg->param_array;\n\t\t\t\t\t\tmemcpy(sti[j].lhvccfg , lhvccfg ? lhvccfg : hevccfg, sizeof(GF_HEVCConfig));\n\t\t\t\t\t\tsti[j].lhvccfg->param_array = backup_list;\n\n\t\t\t\t\t\tsti[j].lhvccfg->is_lhvc = 1;\n\t\t\t\t\t\tsti[j].lhvccfg->complete_representation = 1;\n\t\t\t\t\t}\n\t\t\t\t\te = gf_isom_lhvc_config_update(file, sti[j].track_num, 1, sti[j].lhvccfg, (extractor_mode == GF_LHVC_EXTRACTORS_ON)  ? GF_ISOM_LEHVC_WITH_BASE : GF_ISOM_LEHVC_ONLY);\n\t\t\t\t\tif (e) goto exit;\n\n\t\t\t\t\tif (extractor_mode == GF_LHVC_EXTRACTORS_OFF_FORCE_INBAND)\n\t\t\t\t\t\tgf_isom_lhvc_force_inband_config(file, sti[j].track_num, 1);\n\t\t\t\t} else {\n\t\t\t\t\te = gf_isom_lhvc_config_update(file, sti[j].track_num, 1, NULL, GF_ISOM_LEHVC_WITH_BASE);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t}\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[HEVC] Failed to update HEVC/LHVC config\\n\"));\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\tgf_isom_set_track_reference(file, sti[j].track_num, GF_ISOM_REF_BASE, track_id);\n\n\t\t\t\t//for an L-HEVC bitstream: only base track carries the 'oinf' sample group, other track have a track reference of type 'oref' to base track\n\t\t\t\te = gf_isom_remove_sample_group(file, sti[j].track_num, GF_ISOM_SAMPLE_GROUP_OINF);\n\t\t\t\tif (e) goto exit;\n\t\t\t\t//purge all linf sample groups\n\t\t\t\tgf_isom_remove_sample_group(file, sti[j].track_num, GF_ISOM_SAMPLE_GROUP_LINF);\n\t\t\t\tgf_isom_set_track_reference(file, sti[j].track_num, GF_ISOM_REF_OREF, track_id);\n\n\t\t\t\tgf_isom_set_nalu_extract_mode(file, sti[j].track_num, GF_ISOM_NALU_EXTRACT_INSPECT);\n\n\t\t\t\t//get lower layer\n\t\t\t\tif (extractor_mode == GF_LHVC_EXTRACTORS_ON) {\n\t\t\t\t\tfor (k=j; k>0; k--) {\n\t\t\t\t\t\tif (sti[k-1].track_num) {\n\t\t\t\t\t\t\tu32 track_id_r = gf_isom_get_track_id(file, sti[k-1].track_num);\n\t\t\t\t\t\t\tgf_isom_set_track_reference(file, sti[j].track_num, GF_ISOM_REF_SCAL, track_id_r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!for_temporal_sublayers)\n\t\t\t\t\tgf_isom_set_visual_info(file, sti[j].track_num, 1, sti[j].width, sti[j].height);\n\t\t\t} else {\n\t\t\t\tif (!for_temporal_sublayers)\n\t\t\t\t\tgf_isom_set_visual_info(file, sti[j].track_num, 1, sti[j].width, sti[j].height);\n\t\t\t}\n\n\t\t\tif (j && (extractor_mode == GF_LHVC_EXTRACTORS_ON)) {\n\t\t\t\tGF_BitStream *xbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\t//get all lower layers\n\t\t\t\tfor (k=0; k<j; k++) {\n\t\t\t\t\tu8 trefidx, tid;\n\t\t\t\t\tif (!sti[k].data_size)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t//extractor size 5\n\t\t\t\t\tgf_bs_write_int(xbs, 2*nal_unit_size + 5, 8*nal_unit_size);\n\t\t\t\t\tgf_bs_write_int(xbs, 0, 1);\n\t\t\t\t\tgf_bs_write_int(xbs, GF_HEVC_NALU_FF_EXTRACTOR, 6); //extractor\n\t\t\t\t\tgf_bs_write_int(xbs, k, 6);\n\t\t\t\t\tgf_bs_write_int(xbs, sti[k].max_temporal_id_sample, 3);\n\t\t\t\t\tgf_bs_write_u8(xbs, 0); //constructor type 0\n\t\t\t\t\t//set ref track index\n\t\t\t\t\ttrefidx = (u8) gf_isom_has_track_reference(file, sti[j].track_num, GF_ISOM_REF_SCAL, gf_isom_get_track_id(file, sti[k].track_num) );\n\t\t\t\t\tgf_bs_write_int(xbs, trefidx, 8);\n\t\t\t\t\t// no sample offset\n\t\t\t\t\tgf_bs_write_int(xbs, 0, 8);\n\t\t\t\t\t// data offset: we start from beginning of the sample data, not the extractor\n\t\t\t\t\tgf_bs_write_int(xbs, sti[k].data_offset, 8*nal_unit_size);\n\t\t\t\t\tgf_bs_write_int(xbs, sti[k].data_size, 8*nal_unit_size);\n\n\t\t\t\t\ttid = sti[k].temporal_id_sample;\n\t\t\t\t\tsti[j].layers[k].layer_id_plus_one = sti[k].layer_id+1;\n\t\t\t\t\tif (!sti[j].layers[k].min_temporal_id || (sti[j].layers[k].min_temporal_id > tid)) {\n\t\t\t\t\t\tsti[j].layers[k].min_temporal_id = tid;\n\t\t\t\t\t}\n\t\t\t\t\tif (!sti[j].layers[k].max_temporal_id || (sti[j].layers[k].max_temporal_id < tid)) {\n\t\t\t\t\t\tsti[j].layers[k].max_temporal_id = tid;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgf_bs_get_content(xbs, &sample->data, &sample->dataLength);\n\t\t\t\tgf_bs_del(xbs);\n\n\t\t\t\t//we wrote all our references, store offset for upper layers\n\t\t\t\tsti[j].data_offset = sample->dataLength;\n\t\t\t\te = gf_isom_add_sample(file, sti[j].track_num, 1, sample);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[HEVC] Failed to add HEVC/LHVC sample to track %d\\n\", sti[j].track_num));\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tgf_free(sample->data);\n\t\t\t\tsample->data = NULL;\n\n\t\t\t\t//get real content, remember its size and add it to the new bs\n\t\t\t\tif (sti[j].bs) {\n\t\t\t\t\tgf_bs_get_content(sti[j].bs, &sample->data, &sample->dataLength);\n\t\t\t\t\te = gf_isom_append_sample_data(file, sti[j].track_num, sample->data, sample->dataLength);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[HEVC] Failed to append HEVC/LHVC data to sample (track %d)\\n\", sti[j].track_num));\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t//get sample content\n\t\t\telse if (sti[j].bs) {\n\t\t\t\t//add empty sample at DTS 0\n\t\t\t\tif ( ! sti[j].has_samples) {\n\t\t\t\t\tif (sample->DTS) {\n\t\t\t\t\t\tGF_ISOSample s;\n\t\t\t\t\t\tmemset(&s, 0, sizeof(GF_ISOSample));\n\t\t\t\t\t\tgf_isom_add_sample(file, sti[j].track_num, 1, &s);\n\t\t\t\t\t}\n\t\t\t\t\tsti[j].has_samples=GF_TRUE;\n\t\t\t\t}\n\t\t\t\tgf_bs_get_content(sti[j].bs, &sample->data, &sample->dataLength);\n\t\t\t\tsti[j].data_offset = 0;\n\t\t\t\tsti[j].data_size = sample->dataLength;\n\n\t\t\t\t//add sample\n\t\t\t\tif (j) {\n\t\t\t\t\tGF_ISOSAPType rap = sample->IsRAP;\n\t\t\t\t\tif (for_temporal_sublayers && !sti[j].non_tsa_vcl)\n\t\t\t\t\t\tsample->IsRAP = RAP;\n\n\t\t\t\t\te = gf_isom_add_sample(file, sti[j].track_num, 1, sample);\n\t\t\t\t\tsample->IsRAP = rap;\n\t\t\t\t} else {\n\t\t\t\t\te = gf_isom_update_sample(file, sti[j].track_num, sample_num+1, sample, 1);\n\t\t\t\t}\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[HEVC] Failed to %s HEVC/LHVC sample (track %d, base sample num %d)\\n\", j ? \"add\" : \"update\", sti[j].track_num, sample_num+1));\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//no data left in sample, update\n\t\t\telse if (!j) {\n\t\t\t\te = gf_isom_remove_sample(file, sti[j].track_num, sample_num+1);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[HEVC] Failed to remove HEVC/LHVC sample (track %d)\\n\", sti[j].track_num));\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tsample_num--;\n\t\t\t\tcount--;\n\t\t\t}\n\n\t\t\tgf_bs_del(sti[j].bs);\n\t\t\tsti[j].bs = NULL;\n\n\t\t\tif (sample->IsRAP>SAP_TYPE_1) {\n\t\t\t\tu32 sample_idx = gf_isom_get_sample_count(file, sti[j].track_num);\n\t\t\t\tif (is_irap) {\n\t\t\t\t\tgf_isom_set_sample_rap_group(file, sti[j].track_num, sample_idx, GF_TRUE, 0);\n\t\t\t\t}\n\t\t\t\telse if (roll_type) {\n\t\t\t\t\tgf_isom_set_sample_roll_group(file, sti[j].track_num, sample_idx, GF_ISOM_SAMPLE_ROLL, (s16) roll_distance);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sample->data) {\n\t\t\t\tgf_free(sample->data);\n\t\t\t\tsample->data = NULL;\n\t\t\t}\n\t\t\tsample->dataLength = 0;\n\t\t}\n\t\tgf_isom_sample_del(&sample);\n\n\t\t//reset all scalable info\n\t\tfor (j=0; j<=max_layer_id; j++) {\n\t\t\tsti[j].max_temporal_id_sample = 0;\n\t\t\tsti[j].temporal_id_sample = 0;\n\t\t\tsti[j].data_size = 0;\n\t\t\tsti[j].non_tsa_vcl = GF_FALSE;\n\t\t}\n\t}\n\nexit:\n\t//reset all scalable info\n\tfor (j=0; j<=max_layer_id; j++) {\n\t\tGF_BitStream *bs;\n\t\tu32 data_size;\n\t\tu8 *data=NULL;\n\t\tif (sti[j].lhvccfg) gf_odf_hevc_cfg_del(sti[j].lhvccfg);\n\t\t//set linf group\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_int(bs, 0, 2);\n\t\tcount = 0;\n\t\tfor (k=0; k<=max_layer_id; k++) {\n\t\t\tif (sti[j].layers[k].layer_id_plus_one) count++;\n\t\t}\n\t\tgf_bs_write_int(bs, count, 6);\n\t\tif (count>1)\n\t\t\tsingle_layer_per_track = GF_FALSE;\n\n\t\tfor (k=0; k<=max_layer_id; k++) {\n\t\t\tif (! sti[j].layers[k].layer_id_plus_one) continue;\n\t\t\tgf_bs_write_int(bs, 0, 4);\n\t\t\tgf_bs_write_int(bs, sti[j].layers[k].layer_id_plus_one - 1, 6);\n\t\t\tgf_bs_write_int(bs, sti[j].layers[k].min_temporal_id, 3);\n\t\t\tgf_bs_write_int(bs, sti[j].layers[k].max_temporal_id, 3);\n\t\t\tgf_bs_write_int(bs, 0, 1);\n\t\t\t//track carries the NALUs\n\t\t\tif (k==j) {\n\t\t\t\tgf_bs_write_int(bs, 0xFF, 7);\n\t\t\t}\n\t\t\t//otherwise referenced through extractors, not present natively\n\t\t\telse {\n\t\t\t\tgf_bs_write_int(bs, 0, 7);\n\t\t\t}\n\t\t}\n\t\tgf_bs_get_content(bs, &data, &data_size);\n\t\tgf_bs_del(bs);\n\t\tgf_isom_add_sample_group_info(file, sti[j].track_num, GF_ISOM_SAMPLE_GROUP_LINF, data, data_size, GF_TRUE, &count);\n\t\tgf_free(data);\n\t}\n\tgf_isom_set_nalu_extract_mode(file, track, cur_extract_mode);\n\n\tif (extractor_mode == GF_LHVC_EXTRACTORS_ON) {\n\t\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_HVCE, GF_TRUE);\n\t\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_HVCI, GF_FALSE);\n\t}\n\t//add hvci brand only if single layer per track\n\telse if (single_layer_per_track) {\n\t\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_HVCI, GF_TRUE);\n\t\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_HVCE, GF_FALSE);\n\t}\n\tif (lhvccfg) gf_odf_hevc_cfg_del(lhvccfg);\n\tif (hevccfg) gf_odf_hevc_cfg_del(hevccfg);\n\tif (nal_data) gf_free(nal_data);\n\treturn e;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n\n}\n#endif ///GPAC_DISABLE_AV_PARSERS\n\nGF_EXPORT\nGF_Err gf_media_change_pl(GF_ISOFile *file, u32 track, u32 profile, u32 compat, u32 level)\n{\n\tu32 i, count, stype;\n\tGF_Err e;\n\tGF_AVCConfig *avcc;\n\n\tstype = gf_isom_get_media_subtype(file, track, 1);\n\tswitch (stype) {\n\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\tavcc = gf_isom_avc_config_get(file, track, 1);\n\tif (level) avcc->AVCLevelIndication = level;\n\tif (compat) avcc->profile_compatibility = compat;\n\tif (profile) avcc->AVCProfileIndication = profile;\n\tcount = gf_list_count(avcc->sequenceParameterSets);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *slc = gf_list_get(avcc->sequenceParameterSets, i);\n\t\tif (profile) slc->data[1] = profile;\n\t\tif (level) slc->data[3] = level;\n\t}\n\te = gf_isom_avc_config_update(file, track, 1, avcc);\n\n\tgf_odf_avc_cfg_del(avcc);\n\treturn e;\n}\n\n#endif // GPAC_DISABLE_MEDIA_IMPORT\n\n#if !defined(GPAC_DISABLE_AV_PARSERS)\nu32 hevc_get_tile_id(HEVCState *hevc, u32 *tile_x, u32 *tile_y, u32 *tile_width, u32 *tile_height)\n{\n\tHEVCSliceInfo *si = &hevc->s_info;\n\tu32 i, tbX, tbY, PicWidthInCtbsY, PicHeightInCtbsY, tileX, tileY, oX, oY, val;\n\n\tPicWidthInCtbsY = si->sps->width / si->sps->max_CU_width;\n\tif (PicWidthInCtbsY * si->sps->max_CU_width < si->sps->width) PicWidthInCtbsY++;\n\tPicHeightInCtbsY = si->sps->height / si->sps->max_CU_width;\n\tif (PicHeightInCtbsY * si->sps->max_CU_width < si->sps->height) PicHeightInCtbsY++;\n\n\ttbX = si->slice_segment_address % PicWidthInCtbsY;\n\ttbY = si->slice_segment_address / PicWidthInCtbsY;\n\n\ttileX = tileY = 0;\n\toX = oY = 0;\n\tfor (i=0; i < si->pps->num_tile_columns; i++) {\n\t\tif (si->pps->uniform_spacing_flag) {\n\t\t\tval = (i+1)*PicWidthInCtbsY / si->pps->num_tile_columns - (i)*PicWidthInCtbsY / si->pps->num_tile_columns;\n\t\t} else {\n\t\t\tif (i<si->pps->num_tile_columns-1) {\n\t\t\t\tval = si->pps->column_width[i];\n\t\t\t} else {\n\t\t\t\tval = (PicWidthInCtbsY - si->pps->column_width[i-1]);\n\t\t\t}\n\t\t}\n\t\t*tile_x = oX;\n\t\t*tile_width = val;\n\n\t\tif (oX >= tbX) break;\n\t\toX += val;\n\t\ttileX++;\n\t}\n\tfor (i=0; i<si->pps->num_tile_rows; i++) {\n\t\tif (si->pps->uniform_spacing_flag) {\n\t\t\tval = (i+1)*PicHeightInCtbsY / si->pps->num_tile_rows - (i)*PicHeightInCtbsY / si->pps->num_tile_rows;\n\t\t} else {\n\t\t\tif (i<si->pps->num_tile_rows-1) {\n\t\t\t\tval = si->pps->row_height[i];\n\t\t\t} else if (i) {\n\t\t\t\tval = (PicHeightInCtbsY - si->pps->row_height[i-1]);\n\t\t\t} else {\n\t\t\t\tval = PicHeightInCtbsY;\n\t\t\t}\n\t\t}\n\t\t*tile_y = oY;\n\t\t*tile_height = val;\n\n\t\tif (oY >= tbY) break;\n\t\toY += val;\n\t\ttileY++;\n\t}\n\t*tile_x = *tile_x * si->sps->max_CU_width;\n\t*tile_y = *tile_y * si->sps->max_CU_width;\n\t*tile_width = *tile_width * si->sps->max_CU_width;\n\t*tile_height = *tile_height * si->sps->max_CU_width;\n\n\tif (*tile_x + *tile_width > si->sps->width)\n\t\t*tile_width = si->sps->width - *tile_x;\n\tif (*tile_y + *tile_height > si->sps->height)\n\t\t*tile_height = si->sps->height - *tile_y;\n\n\treturn tileX + tileY * si->pps->num_tile_columns;\n}\n\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\ntypedef struct\n{\n\tu32 track, track_id, sample_count;\n\tu32 tx, ty, tw, th;\n\tu32 data_offset;\n\tGF_BitStream *sample_data;\n\tu32 nb_nalus_in_sample;\n\tBool all_intra;\n} HEVCTileImport;\n\nstatic void hevc_add_trif(GF_ISOFile *file, u32 track, u32 id, Bool full_picture, u32 independent, Bool filtering_disable, u32 tx, u32 ty, u32 tw, u32 th, Bool is_default)\n{\n\tchar data[11];\n\tu32 di, data_size=7;\n\tGF_BitStream *bs;\n\t//avoid gcc warnings\n\tmemset(data, 0, 11);\n\t//write TRIF sample group description\n\tbs = gf_bs_new((const char*)data, 11, GF_BITSTREAM_WRITE);\n\tgf_bs_write_u16(bs, id);\t//groupID\n\tgf_bs_write_int(bs, 1, 1); //tile Region flag always true for us\n\tgf_bs_write_int(bs, independent, 2); //independentIDC: set to 1 (motion-constrained tiles but not all tiles RAP)\n\tgf_bs_write_int(bs, full_picture, 1);//full picture: false since we don't do L-HEVC tiles\n\tgf_bs_write_int(bs, filtering_disable, 1); //filtering disabled: set to 1 (always true on our bitstreams for now) - Check xPS to be sure ...\n\tgf_bs_write_int(bs, 0, 1);//has dependency list: false since we don't do L-HEVC tiles\n\tgf_bs_write_int(bs, 0, 2); //reserved\n\tif (!full_picture) {\n\t\tgf_bs_write_u16(bs, tx);\n\t\tgf_bs_write_u16(bs, ty);\n\t\tdata_size+=4;\n\t}\n\tgf_bs_write_u16(bs, tw);\n\tgf_bs_write_u16(bs, th);\n\tgf_bs_del(bs);\n\n\tgf_isom_add_sample_group_info(file, track, GF_ISOM_SAMPLE_GROUP_TRIF, data, data_size, is_default, &di);\n}\n\nGF_EXPORT\nGF_Err gf_media_split_hevc_tiles(GF_ISOFile *file, u32 signal_mode)\n{\n#if defined(GPAC_DISABLE_AV_PARSERS)\n\treturn GF_NOT_SUPPORTED;\n#else\n\tu32 i, j, cur_tile, count, stype, track, nb_tiles, di, nalu_size_length, tx, ty, tw, th;\n\ts32 pps_idx=-1, sps_idx=-1, ret;\n\tGF_Err e = GF_OK;\n\tHEVCState hevc;\n\tHEVCTileImport *tiles;\n\tGF_HEVCConfig *hvcc;\n\tBool filter_disabled=GF_TRUE;\n\n\ttrack = 0;\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tstype = gf_isom_get_media_subtype(file, i+1, 1);\n\t\tswitch (stype) {\n\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\n\t\t\tif (track) return GF_NOT_SUPPORTED;\n\t\t\ttrack = i+1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!track) return GF_NOT_SUPPORTED;\n\n\thvcc = gf_isom_hevc_config_get(file, track, 1);\n\tnalu_size_length = hvcc->nal_unit_size;\n\n\tmemset(&hevc, 0, sizeof(HEVCState));\n\n\tcount = gf_list_count(hvcc->param_array);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParamArray *ar = gf_list_get(hvcc->param_array, i);\n\t\tfor (j=0; j < gf_list_count(ar->nalus); j++) {\n\t\t\tGF_NALUFFParam *sl = gf_list_get(ar->nalus, j);\n\t\t\tif (!sl) continue;\n\t\t\tswitch (ar->type) {\n\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\tpps_idx = gf_hevc_read_pps(sl->data, sl->size, &hevc);\n\t\t\t\tbreak;\n\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\t\tsps_idx = gf_hevc_read_sps(sl->data, sl->size, &hevc);\n\t\t\t\tbreak;\n\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\t\tgf_hevc_read_vps(sl->data, sl->size, &hevc);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tgf_isom_hevc_set_tile_config(file, track, 1, hvcc, GF_TRUE);\n\tgf_odf_hevc_cfg_del(hvcc);\n\n\t//if params sets are inband, get first sps/pps\n\ti=0;\n\twhile ((pps_idx==-1) || (sps_idx==-1)) {\n\t\tGF_ISOSample *sample = gf_isom_get_sample(file, track, i+1, &di);\n\t\tchar *data = sample->data;\n\t\tu32 size = sample->dataLength;\n\n\t\twhile (size) {\n\t\t\tu8 temporal_id, layer_id;\n\t\t\tu8 nal_type = 0;\n\t\t\tu32 nalu_size = 0;\n\n\t\t\tfor (j=0; j<nalu_size_length; j++) {\n\t\t\t\tnalu_size = (nalu_size<<8) + data[j];\n\t\t\t}\n\t\t\tgf_hevc_parse_nalu(data + nalu_size_length, nalu_size, &hevc, &nal_type, &temporal_id, &layer_id);\n\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\tpps_idx = gf_hevc_read_pps((char *) data+nalu_size_length, nalu_size, &hevc);\n\t\t\t\tbreak;\n\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\t\tsps_idx = gf_hevc_read_sps((char *) data+nalu_size_length, nalu_size, &hevc);\n\t\t\t\tbreak;\n\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\t\tgf_hevc_read_vps((char *) data+nalu_size_length, nalu_size, &hevc);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdata += nalu_size + nalu_size_length;\n\t\t\tsize -= nalu_size + nalu_size_length;\n\t\t}\n\t\tgf_isom_sample_del(&sample);\n\t}\n\n\tif (pps_idx==-1) return GF_BAD_PARAM;\n\tif (sps_idx==-1) return GF_BAD_PARAM;\n\n\tif (hevc.pps[pps_idx].loop_filter_across_tiles_enabled_flag)\n\t\tfilter_disabled=GF_FALSE;\n\n\tif (! hevc.pps[pps_idx].tiles_enabled_flag) {\n\t\thevc_add_trif(file, track, gf_isom_get_track_id(file, track), GF_TRUE, 1, filter_disabled, 0, 0, hevc.sps[pps_idx].width, hevc.sps[pps_idx].height, GF_TRUE);\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[HEVC Tiles] Tiles not enabled, signal only single tile full picture\\n\"));\n\t\treturn GF_OK;\n\t}\n\n\tnb_tiles = hevc.pps[pps_idx].num_tile_columns * hevc.pps[pps_idx].num_tile_rows;\n\ttiles = gf_malloc(sizeof(HEVCTileImport) * nb_tiles);\n\tif (!tiles) return GF_OUT_OF_MEM;\n\tmemset(tiles, 0, sizeof(HEVCTileImport) * nb_tiles);\n\n\tfor (i=0; i<nb_tiles; i++) {\n\t\tif (! signal_mode) {\n\t\t\t//first clone tracks\n\t\t\te = gf_isom_clone_track(file, track, file, 0, &tiles[i].track );\n\t\t\tif (e) goto err_exit;\n\t\t\ttiles[i].track_id = gf_isom_get_track_id(file, tiles[i].track);\n\t\t\tgf_isom_hevc_set_tile_config(file, tiles[i].track, 1, NULL, GF_FALSE);\n\n\t\t\t// setup track references from tile track to base\n\t\t\tgf_isom_set_track_reference(file, tiles[i].track, GF_ISOM_REF_TBAS, gf_isom_get_track_id(file, track) );\n\t\t} else {\n\t\t\ttiles[i].track_id = gf_isom_get_track_id(file, track) + i+1;\n\t\t}\n\t\ttiles[i].all_intra = GF_TRUE;\n\t}\n\n\tcount = gf_isom_get_sample_count(file, track);\n\tfor (i=0; i<count; i++) {\n\t\tu8 *data;\n\t\tu32 size, nb_nalus=0, nb_nal_entries=0, last_tile_group=(u32) -1;\n\t\tGF_BitStream *bs=NULL;\n\t\tGF_ISOSample *sample = gf_isom_get_sample(file, track, i+1, &di);\n\t\tif (!sample) {\n\t\t\te = gf_isom_last_error(file);\n\t\t\tgoto err_exit;\n\t\t}\n\n\t\tdata = (u8 *) sample->data;\n\t\tsize = sample->dataLength;\n\t\tif (!signal_mode) {\n\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tsample->data = NULL;\n\t\t\tsample->dataLength = 0;\n\n\t\t\tfor (j=0; j<nb_tiles; j++) {\n\t\t\t\ttiles[j].data_offset = 0;\n\t\t\t\ttiles[j].sample_data = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j=0; j<nb_tiles; j++) {\n\t\t\t\ttiles[j].nb_nalus_in_sample = 0;\n\t\t\t}\n\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t//write start of nalm group\n\t\t\tgf_bs_write_int(bs, 0, 6);//reserved\n\t\t\tgf_bs_write_int(bs, 0, 1);//large_size\n\t\t\tgf_bs_write_int(bs, (signal_mode==2) ? 1 : 0, 1);//rle\n\t\t\tgf_bs_write_u8(bs, 0);//entry_count - will be set at the end\n\t\t}\n\n\n\t\tsample->data = (char *) data;\n\n\t\twhile (size) {\n\t\t\tu8 temporal_id, layer_id;\n\t\t\tu8 nal_type = 0;\n\t\t\tu32 nalu_size = 0;\n\t\t\tfor (j=0; j<nalu_size_length; j++) {\n\t\t\t\tnalu_size = (nalu_size<<8) + data[j];\n\t\t\t}\n\t\t\tret = gf_hevc_parse_nalu(data + nalu_size_length, nalu_size, &hevc, &nal_type, &temporal_id, &layer_id);\n\n\t\t\t//error parsing NAL, set nal to fallback to regular import\n\t\t\tif (ret<0) nal_type = GF_HEVC_NALU_VID_PARAM;\n\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_HEVC_NALU_SLICE_TRAIL_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_TRAIL_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\t\tcase GF_HEVC_NALU_SLICE_RADL_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_RADL_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_RASL_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_RASL_N:\n\t\t\t\ttx = ty = tw = th = 0;\n\t\t\t\tcur_tile = hevc_get_tile_id(&hevc, &tx, &ty, &tw, &th);\n\t\t\t\tif (cur_tile>=nb_tiles) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[HEVC Tiles] Tile index %d is greater than number of tiles %d in PPS\\n\", cur_tile, nb_tiles));\n\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t}\n\t\t\t\tif (e)\n\t\t\t\t\tgoto err_exit;\n\n\t\t\t\ttiles[cur_tile].tx = tx;\n\t\t\t\ttiles[cur_tile].ty = ty;\n\t\t\t\ttiles[cur_tile].tw = tw;\n\t\t\t\ttiles[cur_tile].th = th;\n\t\t\t\tif (hevc.s_info.slice_type != GF_HEVC_SLICE_TYPE_I) {\n\t\t\t\t\ttiles[cur_tile].all_intra = 0;\n\t\t\t\t}\n\n\t\t\t\tif (signal_mode) {\n\t\t\t\t\tnb_nalus++;\n\t\t\t\t\ttiles[cur_tile].nb_nalus_in_sample++;\n\t\t\t\t\tif (signal_mode==1) {\n\t\t\t\t\t\tgf_bs_write_u16(bs, tiles[cur_tile].track_id);\n\t\t\t\t\t\tnb_nal_entries++;\n\t\t\t\t\t} else if (last_tile_group != tiles[cur_tile].track_id) {\n\t\t\t\t\t\tlast_tile_group = tiles[cur_tile].track_id;\n\t\t\t\t\t\tgf_bs_write_u8(bs, nb_nalus);\n\t\t\t\t\t\tgf_bs_write_u16(bs, tiles[cur_tile].track_id);\n\t\t\t\t\t\tnb_nal_entries++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_data(tiles[cur_tile].sample_data, (char *) data, nalu_size + nalu_size_length);\n\n\t\t\t\t\tif (! gf_isom_has_track_reference(file, track, GF_ISOM_REF_SABT, tiles[cur_tile].track_id)) {\n\t\t\t\t\t\tgf_isom_set_track_reference(file, track, GF_ISOM_REF_SABT, tiles[cur_tile].track_id);\n\t\t\t\t\t}\n\t\t\t\t\ttiles[cur_tile].data_offset += nalu_size + nalu_size_length;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (! signal_mode) {\n\t\t\t\t\tgf_bs_write_data(bs, (char *) data, nalu_size + nalu_size_length);\n\t\t\t\t} else {\n\t\t\t\t\tnb_nalus++;\n\t\t\t\t\tif (signal_mode==1) {\n\t\t\t\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\t\t\t\tnb_nal_entries++;\n\t\t\t\t\t} else if (last_tile_group != 0) {\n\t\t\t\t\t\tlast_tile_group = 0;\n\t\t\t\t\t\tgf_bs_write_u8(bs, nb_nalus);\n\t\t\t\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\t\t\t\tnb_nal_entries++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdata += nalu_size + nalu_size_length;\n\t\t\tsize -= nalu_size + nalu_size_length;\n\t\t}\n\n\t\tif (! signal_mode) {\n\t\t\tgf_free(sample->data);\n\t\t\tgf_bs_get_content(bs, &sample->data, &sample->dataLength);\n\t\t\tgf_bs_del(bs);\n\n\t\t\te = gf_isom_update_sample(file, track, i+1, sample, 1);\n\t\t\tif (e) goto err_exit;\n\n\t\t\tgf_free(sample->data);\n\t\t\tsample->data = NULL;\n\n\t\t\tfor (j=0; j<nb_tiles; j++) {\n\t\t\t\tsample->dataLength = 0;\n\t\t\t\tgf_bs_get_content(tiles[j].sample_data, &sample->data, &sample->dataLength);\n\t\t\t\tif (!sample->data)\n\t\t\t\t\tcontinue;\n\n\t\t\t\te = gf_isom_add_sample(file, tiles[j].track, 1, sample);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\ttiles[j].sample_count ++;\n\n\t\t\t\tgf_bs_del(tiles[j].sample_data);\n\t\t\t\ttiles[j].sample_data = NULL;\n\t\t\t\tgf_free(sample->data);\n\t\t\t\tsample->data = NULL;\n\n\t\t\t\te = gf_isom_copy_sample_info(file, tiles[j].track, file, track, i+1);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t}\n\t\t} else {\n\t\t\tu32 sdesc;\n\t\t\tdata=NULL;\n\t\t\tsize=0;\n\t\t\tgf_bs_get_content(bs, &data, &size);\n\t\t\tgf_bs_del(bs);\n\t\t\tdata[1] = nb_nal_entries;\n\n\t\t\te = gf_isom_add_sample_group_info(file, track, GF_ISOM_SAMPLE_GROUP_NALM, data, size, 1, &sdesc);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMF] Error defining NALM group description entry\\n\" ));\n\t\t\t} else {\n\t\t\t\te = gf_isom_add_sample_info(file, track, i+1, GF_ISOM_SAMPLE_GROUP_NALM, sdesc, GF_ISOM_SAMPLE_GROUP_TRIF);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMF] Error associating NALM group description to sample\\n\" ));\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_free(data);\n\t\t\tif (e) goto err_exit;\n\t\t}\n\n\t\tgf_isom_sample_del(&sample);\n\n\t}\n\n\n\tfor (i=0; i<nb_tiles; i++) {\n\t\tu32 width, height;\n\t\ts32 translation_x, translation_y;\n\t\ts16 layer;\n\n\t\tif (! signal_mode) {\n\t\t\ttiles[i].track = gf_isom_get_track_by_id(file, tiles[i].track_id);\n\t\t\tif (!tiles[i].sample_count) {\n\t\t\t\tgf_isom_remove_track(file, tiles[i].track);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\thevc_add_trif(file, tiles[i].track, tiles[i].track_id, GF_FALSE, (tiles[i].all_intra) ? 2 : 1, filter_disabled, tiles[i].tx, tiles[i].ty, tiles[i].tw, tiles[i].th, GF_TRUE);\n\t\t\tgf_isom_set_visual_info(file, tiles[i].track, 1, tiles[i].tw, tiles[i].th);\n\n\t\t\tgf_isom_get_track_layout_info(file, track, &width, &height, &translation_x, &translation_y, &layer);\n\t\t\tgf_isom_set_track_layout_info(file, tiles[i].track, width<<16, height<<16, translation_x, translation_y, layer);\n\t\t} else {\n\t\t\thevc_add_trif(file, track, tiles[i].track_id, GF_FALSE, (tiles[i].all_intra) ? 2 : 1, filter_disabled, tiles[i].tx, tiles[i].ty, tiles[i].tw, tiles[i].th, GF_FALSE);\n\t\t}\n\n\t}\n\n\nerr_exit:\n\tgf_free(tiles);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMF] Could not split HEVC tiles into tracks: %s\\n\", gf_error_to_string(e) ));\n\t}\n\treturn e;\n#endif\n}\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\n#endif /*GPAC_DISABLE_MEDIA_IMPORT*/\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\n#include <gpac/filters.h>\n\ntypedef struct\n{\n\tu32 filter_idx_plus_one;\n\tu32 last_prog;\n\tGF_FilterSession *fsess;\n} FragCallback;\n\nextern char gf_prog_lf;\n\nstatic Bool on_frag_event(void *_udta, GF_Event *evt)\n{\n\tu32 i, count;\n\tGF_FilterStats stats;\n\tFragCallback *fc = (FragCallback *)_udta;\n\tif (!_udta)\n\t\treturn GF_FALSE;\n\tif (evt && (evt->type != GF_EVENT_PROGRESS))\n\t\treturn GF_FALSE;\n\n\tstats.report_updated = GF_FALSE;\n\tif (!fc->filter_idx_plus_one) {\n\t\tcount = gf_fs_get_filters_count(fc->fsess);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tif (gf_fs_get_filter_stats(fc->fsess, i, &stats) != GF_OK) continue;\n\t\t\tif (strcmp(stats.reg_name, \"mp4mx\")) continue;\n\t\t\tfc->filter_idx_plus_one = i+1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!fc->filter_idx_plus_one) return GF_FALSE;\n\t} else {\n\t\tif (gf_fs_get_filter_stats(fc->fsess, fc->filter_idx_plus_one-1, &stats) != GF_OK)\n\t\t\treturn GF_FALSE;\n\t}\n\tif (! stats.report_updated) return GF_FALSE;\n\tif (stats.percent/100 == fc->last_prog) return GF_FALSE;\n\tfc->last_prog = stats.percent / 100;\n\n#ifndef GPAC_DISABLE_LOG\n\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"Fragmenting: % 2.2f %%%c\", ((Double)stats.percent) / 100, gf_prog_lf));\n#else\n\tfprintf(stderr, \"Fragmenting: % 2.2f %%%c\", ((Double)stats.percent) / 100, gf_prog_lf);\n#endif\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_media_fragment_file(GF_ISOFile *input, const char *output_file, Double max_duration_sec, Bool use_mfra)\n{\n\tchar szArgs[1024];\n\tFragCallback fc;\n\tGF_Err e = GF_OK;\n\tGF_Filter *f;\n\tGF_FilterSession *fsess = gf_fs_new_defaults(0);\n\n\tif (!fsess) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"Failed to create filter session\\n\"));\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\n\n\tsprintf(szArgs, \"mp4dmx:mov=%p\", input);\n\tf = gf_fs_load_filter(fsess, szArgs, &e);\n\tif (!f) return e;\n\n\tstrcpy(szArgs, \"reframer:FID=1\");\n\tf = gf_fs_load_filter(fsess, szArgs, &e);\n\tif (!f) return e;\n\n\tsprintf(szArgs, \"%s:SID=1:frag:cdur=%g:abs_offset:fragdur\", output_file, max_duration_sec);\n\tif (use_mfra)\n\t\tstrcat(szArgs, \":mfra\");\n\n\tf = gf_fs_load_destination(fsess, szArgs, NULL, NULL, &e);\n\tif (!f) return e;\n\n\tif (!gf_sys_is_test_mode()\n#ifndef GPAC_DISABLE_LOG\n\t\t&& (gf_log_get_tool_level(GF_LOG_APP)!=GF_LOG_QUIET)\n#endif\n\t\t&& !gf_sys_is_quiet()\n\t) {\n\t\tfc.last_prog=0;\n\t\tfc.fsess=fsess;\n\t\tfc.filter_idx_plus_one=0;\n\t\tgf_fs_enable_reporting(fsess, GF_TRUE);\n\t\tgf_fs_set_ui_callback(fsess, on_frag_event, &fc);\n\t}\n\n#ifdef GPAC_ENABLE_COVERAGE\n\tif (gf_sys_is_cov_mode())\n\t\ton_frag_event(NULL, NULL);\n#endif\n\n\te = gf_fs_run(fsess);\n\tif (e==GF_EOS) e = GF_OK;\n\tif (!e) e = gf_fs_get_last_connect_error(fsess);\n\tif (!e) e = gf_fs_get_last_process_error(fsess);\n\tgf_fs_del(fsess);\n\treturn e;\n}\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nGF_Err rfc_6381_get_codec_aac(char *szCodec, u32 codec_id,  u8 *dsi, u32 dsi_size, Bool force_sbr)\n{\n\tif (dsi && dsi_size) {\n\t\tu8 audio_object_type;\n\t\tif (dsi_size < 2) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[RFC6381] invalid DSI size %u < 2\\n\", dsi_size));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\t/*5 first bits of AAC config*/\n\t\taudio_object_type = (dsi[0] & 0xF8) >> 3;\n\t\tif (audio_object_type == 31) { /*escape code*/\n\t\t\tconst u8 audio_object_type_ext = ((dsi[0] & 0x07) << 3) + ((dsi[1] & 0xE0) >> 5);\n\t\t\taudio_object_type = 32 + audio_object_type_ext;\n\t\t}\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tif (force_sbr && (audio_object_type==2) ) {\n\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\tGF_Err e = gf_m4a_get_config(dsi, dsi_size, &a_cfg);\n\t\t\tif (e==GF_OK) {\n\t\t\t\tif (a_cfg.sbr_sr)\n\t\t\t\t\taudio_object_type = a_cfg.sbr_object_type;\n\t\t\t\tif (a_cfg.has_ps)\n\t\t\t\t\taudio_object_type = 29;\n\t\t\t}\n\t\t}\n#endif\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"mp4a.%02X.%01d\", gf_codecid_oti(codec_id), audio_object_type);\n\t\treturn GF_OK;\n\t}\n\n\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"mp4a.%02X\", codec_id);\n\n\tswitch (codec_id) {\n\tcase GF_CODECID_AAC_MPEG4:\n\tcase GF_CODECID_AAC_MPEG2_MP:\n\tcase GF_CODECID_AAC_MPEG2_LCP:\n\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\tcase GF_CODECID_USAC:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381] Cannot find AAC config, using default %s\\n\", szCodec));\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err rfc_6381_get_codec_m4v(char *szCodec, u32 codec_id, u8 *dsi, u32 dsi_size)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tif (dsi && dsi_size) {\n\t\tGF_M4VDecSpecInfo m4vc;\n\t\tgf_m4v_get_config(dsi, dsi_size, &m4vc);\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"mp4v.%02X.%01x\", codec_id, m4vc.VideoPL);\n\t\treturn GF_OK;\n\t}\n#endif\n\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"mp4v.%02X\", codec_id);\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381] Cannot find M4V config, using default %s\\n\", szCodec));\n\treturn GF_OK;\n}\n\nGF_Err rfc_6381_get_codec_avc(char *szCodec, u32 subtype, GF_AVCConfig *avcc)\n{\n\tassert(avcc);\n\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s.%02X%02X%02X\", gf_4cc_to_str(subtype), avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);\n\treturn GF_OK;\n}\n\nGF_Err rfc_6381_get_codec_hevc(char *szCodec, u32 subtype, GF_HEVCConfig *hvcc)\n{\n\tu8 c;\n\tchar szTemp[RFC6381_CODEC_NAME_SIZE_MAX];\n\tassert(hvcc);\n\n\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s.\", gf_4cc_to_str(subtype));\n\tif (hvcc->profile_space==1) strcat(szCodec, \"A\");\n\telse if (hvcc->profile_space==2) strcat(szCodec, \"B\");\n\telse if (hvcc->profile_space==3) strcat(szCodec, \"C\");\n\t//profile idc encoded as a decimal number\n\tsprintf(szTemp, \"%d\", hvcc->profile_idc);\n\tstrcat(szCodec, szTemp);\n\t//general profile compatibility flags: hexa, bit-reversed\n\t{\n\t\tu32 val = hvcc->general_profile_compatibility_flags;\n\t\tu32 i, res = 0;\n\t\tfor (i=0; i<32; i++) {\n\t\t\tres |= val & 1;\n\t\t\tif (i==31) break;\n\t\t\tres <<= 1;\n\t\t\tval >>=1;\n\t\t}\n\t\tsprintf(szTemp, \".%X\", res);\n\t\tstrcat(szCodec, szTemp);\n\t}\n\n\tif (hvcc->tier_flag) strcat(szCodec, \".H\");\n\telse strcat(szCodec, \".L\");\n\tsprintf(szTemp, \"%d\", hvcc->level_idc);\n\tstrcat(szCodec, szTemp);\n\n\tc = hvcc->progressive_source_flag << 7;\n\tc |= hvcc->interlaced_source_flag << 6;\n\tc |= hvcc->non_packed_constraint_flag << 5;\n\tc |= hvcc->frame_only_constraint_flag << 4;\n\tc |= (hvcc->constraint_indicator_flags >> 40);\n\tsprintf(szTemp, \".%X\", c);\n\tstrcat(szCodec, szTemp);\n\tif (hvcc->constraint_indicator_flags & 0xFFFFFFFF) {\n\t\tc = (hvcc->constraint_indicator_flags >> 32) & 0xFF;\n\t\tsprintf(szTemp, \".%X\", c);\n\t\tstrcat(szCodec, szTemp);\n\t\tif (hvcc->constraint_indicator_flags & 0x00FFFFFF) {\n\t\t\tc = (hvcc->constraint_indicator_flags >> 24) & 0xFF;\n\t\t\tsprintf(szTemp, \".%X\", c);\n\t\t\tstrcat(szCodec, szTemp);\n\t\t\tif (hvcc->constraint_indicator_flags & 0x0000FFFF) {\n\t\t\t\tc = (hvcc->constraint_indicator_flags >> 16) & 0xFF;\n\t\t\t\tsprintf(szTemp, \".%X\", c);\n\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\tif (hvcc->constraint_indicator_flags & 0x000000FF) {\n\t\t\t\t\tc = (hvcc->constraint_indicator_flags >> 8) & 0xFF;\n\t\t\t\t\tsprintf(szTemp, \".%X\", c);\n\t\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\t\tc = (hvcc->constraint_indicator_flags ) & 0xFF;\n\t\t\t\t\tsprintf(szTemp, \".%X\", c);\n\t\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err rfc_6381_get_codec_av1(char *szCodec, u32 subtype, GF_AV1Config *av1c, COLR colr)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tGF_Err e;\n\tu32 i = 0;\n\tAV1State av1_state;\n\tassert(av1c);\n\n\tgf_av1_init_state(&av1_state);\n\tav1_state.config = av1c;\n\n\tfor (i = 0; i < gf_list_count(av1c->obu_array); ++i) {\n\t\tGF_BitStream *bs;\n\t\tGF_AV1_OBUArrayEntry *a = gf_list_get(av1c->obu_array, i);\n\t\tbs = gf_bs_new(a->obu, a->obu_length, GF_BITSTREAM_READ);\n\t\tif (!av1_is_obu_header(a->obu_type))\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381] AV1: unexpected obu_type %d - Parsing anyway.\\n\", a->obu_type, gf_4cc_to_str(subtype)));\n\n\t\te = aom_av1_parse_temporal_unit_from_section5(bs, &av1_state);\n\t\tgf_bs_del(bs);\n\t\tbs = NULL;\n\t\tif (e) {\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s.%01u.%02u%c.%02u\", gf_4cc_to_str(subtype),\n\t\tav1_state.config->seq_profile, av1_state.config->seq_level_idx_0, av1_state.config->seq_tier_0 ? 'H' : 'M', av1_state.bit_depth);\n\n\tif (av1_state.color_description_present_flag) {\n\t\tchar tmp[RFC6381_CODEC_NAME_SIZE_MAX];\n\t\tsnprintf(tmp, RFC6381_CODEC_NAME_SIZE_MAX, \".%01u.%01u%01u%01u.%02u.%02u.%02u.%01u\",\n\t\t\tav1_state.config->monochrome, av1_state.config->chroma_subsampling_x, av1_state.config->chroma_subsampling_y,\n\t\t\tav1_state.config->chroma_subsampling_x && av1_state.config->chroma_subsampling_y ? av1_state.config->chroma_sample_position : 0,\n\t\t\tcolr.override == GF_TRUE ? colr.colour_primaries : av1_state.color_primaries,\n\t\t\tcolr.override == GF_TRUE ? colr.transfer_characteristics : av1_state.transfer_characteristics,\n\t\t\tcolr.override == GF_TRUE ? colr.matrix_coefficients : av1_state.matrix_coefficients,\n\t\t\tcolr.override == GF_TRUE ? colr.full_range : av1_state.color_range);\n\t\tstrcat(szCodec, tmp);\n\t} else {\n\t\tif ((av1_state.color_primaries == 2) && (av1_state.transfer_characteristics == 2) && (av1_state.matrix_coefficients == 2) && av1_state.color_range == GF_FALSE) {\n\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381] incoherent color characteristics primaries %d transfer %d matrix %d color range %d\\n\",\n\t\t\t\tav1_state.color_primaries, av1_state.transfer_characteristics, av1_state.matrix_coefficients, av1_state.color_range));\n\t\t}\n\t}\n\tgf_av1_reset_state(&av1_state, GF_TRUE);\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\nGF_Err rfc_6381_get_codec_vpx(char *szCodec, u32 subtype, GF_VPConfig *vpcc, COLR colr)\n{\n\tassert(vpcc);\n\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s.%02u.%02u.%02u.%02u.%02u.%02u.%02u.%02u\", gf_4cc_to_str(subtype),\n\t\tvpcc->profile,\n\t\tvpcc->level,\n\t\tvpcc->bit_depth,\n\t\tvpcc->chroma_subsampling,\n\t\tcolr.override == GF_TRUE ? colr.colour_primaries : vpcc->colour_primaries,\n\t\tcolr.override == GF_TRUE ? colr.transfer_characteristics : vpcc->transfer_characteristics,\n\t\tcolr.override == GF_TRUE ? colr.matrix_coefficients : vpcc->matrix_coefficients,\n\t\tcolr.override == GF_TRUE ? colr.full_range : vpcc->video_fullRange_flag);\n\treturn GF_OK;\n}\n\nGF_Err rfc_6381_get_codec_dolby_vision(char *szCodec, u32 subtype, GF_DOVIDecoderConfigurationRecord *dovi)\n{\n\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s.%02u.%02u\", gf_4cc_to_str(subtype), dovi->dv_profile, dovi->dv_level);\n\treturn GF_OK;\n}\n\nstatic char base32_chars[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\n\nGF_Err rfc_6381_get_codec_vvc(char *szCodec, u32 subtype, GF_VVCConfig *vvcc)\n{\n\tassert(vvcc);\n\tu32 i, pos, len;\n\n\tif ( (subtype==GF_4CC('v','v','c','N')) || (subtype==GF_4CC('v','v','s','1')) ) {\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s\", gf_4cc_to_str(subtype));\n\t} else {\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s.%d.%s%d\", gf_4cc_to_str(subtype), vvcc->general_profile_idc, vvcc->general_tier_flag ? \"H\" : \"L\", vvcc->general_level_idc);\n\t}\n\n\tu8 buf[256];\n\tGF_BitStream *bs = gf_bs_new(buf, 256, GF_BITSTREAM_WRITE);\n\tgf_bs_write_int(bs, vvcc->ptl_frame_only_constraint, 1);\n\tgf_bs_write_int(bs, vvcc->ptl_multilayer_enabled, 1);\n\tfor (i=0; i<vvcc->num_constraint_info; i++) {\n\t\tgf_bs_write_int(bs, vvcc->general_constraint_info[i], 8);\n\t}\n\tgf_bs_align(bs);\n\tpos = (u32) gf_bs_get_position(bs);\n\tgf_bs_del(bs);\n\twhile (pos && (buf[pos-1]==0)) {\n\t\tpos--;\n\t}\n\tif (!pos) {\n\t\tstrcat(szCodec, \".CA\");\n\t\treturn GF_OK;\n\t}\n\tstrcat(szCodec, \".C\");\n\tlen = (u32) strlen(szCodec);\n\tbs = gf_bs_new(buf, pos, GF_BITSTREAM_READ);\n\twhile (1) {\n\t\tu32 nb_bits = (u32) ( 8*gf_bs_available(bs) + gf_bs_bits_available(bs) );\n\t\tif (!nb_bits) break;\n\t\tif (nb_bits>5) nb_bits = 5;\n\t\tu32 c = gf_bs_read_int(bs, nb_bits);\n\t\twhile (nb_bits<5) {\n\t\t\tc <<= 1;\n\t\t\tnb_bits++;\n\t\t}\n\t\tchar b32_char = base32_chars[c];\n\t\t//should not happen, we use 100 bytes by default and max general_constraint_info is 63 bytes\n\t\tif (len >= RFC6381_CODEC_NAME_SIZE_MAX) {\n\t\t\tgf_bs_del(bs);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tszCodec[len] = b32_char;\n\t\tlen++;\n\t\tszCodec[len] = 0;\n\t}\n\tgf_bs_del(bs);\n\n\treturn GF_OK;\n}\nGF_Err rfc_6381_get_codec_mpegha(char *szCodec, u32 subtype, u8 *dsi, u32 dsi_size, s32 pl)\n{\n\tif (dsi && (dsi_size>=2) ) {\n\t\tpl = dsi[1];\n\t}\n\tif (pl<0) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381] Cannot find MPEG-H Audio Config or audio PL, defaulting to profile 0x01\\n\"));\n\t}\n\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s.0x%02X\", gf_4cc_to_str(subtype), pl);\n\treturn GF_OK;\n}\n\nGF_Err rfc_6381_get_codec_uncv(char *szCodec, u32 subtype, u8 *dsi, u32 dsi_size);\n\n// Selected (namespace,identifier) pairs from https://www.w3.org/TR/ttml-profile-registry/\n// ordered in decreasing order of preference\nstatic const char *ttml_namespaces[] = {\n\t\"im3t\", \"http://www.w3.org/ns/ttml/profile/imsc1.2/text\",\n\t\"im2t\", \"http://www.w3.org/ns/ttml/profile/imsc1.1/text\",\n\t\"im2i\", \"http://www.w3.org/ns/ttml/profile/imsc1.1/image\",\n\t\"im1t\", \"http://www.w3.org/ns/ttml/profile/imsc1/text\",\n\t\"im1i\", \"http://www.w3.org/ns/ttml/profile/imsc1/image\"\n};\nstatic const int TTML_NAMESPACES_COUNT = GF_ARRAY_LENGTH(ttml_namespaces);\n\n\nGF_Err rfc_6381_get_codec_stpp(char *szCodec, u32 subtype,\n                               const char *xmlnamespace,\n                               const char *xml_schema_loc,\n                               const char *mimes)\n{\n    // we ignore schema location and auxiliary mime types\n    // we focus on the provided list of namespaces\n    if (xmlnamespace != NULL) {\n        int i;\n        for (i = 0; i < TTML_NAMESPACES_COUNT; i+=2) {\n            if(strstr(xmlnamespace, ttml_namespaces[i+1]) != NULL) {\n                snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s.%s.%s\", gf_4cc_to_str(subtype), \"ttml\", ttml_namespaces[i]);\n                return GF_OK;\n            }\n        }\n        // if none of the namespaces above have been found, search the default TTML namespace\n        if(strstr(xmlnamespace, \"http://www.w3.org/ns/ttml\")) {\n            snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s.%s\", gf_4cc_to_str(subtype), \"ttml\");\n            return GF_OK;\n        }\n    }\n    // None of the known namespaces are found, default\n    snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s\", gf_4cc_to_str(subtype));\n    return GF_OK;\n}\n\nGF_Err rfc6381_codec_name_default(char *szCodec, u32 subtype, u32 codec_id)\n{\n\tif (codec_id && (codec_id<GF_CODECID_LAST_MPEG4_MAPPING)) {\n\t\tu32 stype = gf_codecid_type(codec_id);\n\t\tif (stype==GF_STREAM_VISUAL)\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"mp4v.%02X\", codec_id);\n\t\telse if (stype==GF_STREAM_AUDIO)\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"mp4a.%02X\", codec_id);\n\t\telse\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"mp4s.%02X\", codec_id);\n\t} else {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[RFC6381] Codec parameters not known - using default value \\\"%s\\\"\\n\", gf_4cc_to_str(subtype) ));\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s\", gf_4cc_to_str(subtype));\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM\n\nGF_EXPORT\nGF_Err gf_media_get_rfc_6381_codec_name(GF_ISOFile *movie, u32 track, u32 stsd_idx, char *szCodec, Bool force_inband, Bool force_sbr)\n{\n\tGF_ESD *esd;\n\tGF_Err e;\n\tGF_AVCConfig *avcc;\n\tGF_HEVCConfig *hvcc;\n\tu32 subtype = gf_isom_get_media_subtype(movie, track, stsd_idx);\n\n\tif (subtype == GF_ISOM_SUBTYPE_MPEG4_CRYP) {\n\t\tu32 originalFormat=0;\n\t\tif (gf_isom_is_ismacryp_media(movie, track, stsd_idx)) {\n\t\t\te = gf_isom_get_ismacryp_info(movie, track, stsd_idx, &originalFormat, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\n\t\t} else if (gf_isom_is_omadrm_media(movie, track, stsd_idx)) {\n\t\t\te = gf_isom_get_omadrm_info(movie, track, stsd_idx, &originalFormat, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\n\t\t} else if(gf_isom_is_cenc_media(movie, track, stsd_idx)) {\n\t\t\te = gf_isom_get_cenc_info(movie, track, stsd_idx, &originalFormat, NULL, NULL);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[RFC6381] Unknown protection scheme type %s\\n\", gf_4cc_to_str( gf_isom_is_media_encrypted(movie, track, stsd_idx)) ));\n\t\t\te = gf_isom_get_original_format_type(movie, track, stsd_idx, &originalFormat);\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[RFC6381] Error fetching protection information\\n\"));\n\t\t\treturn e;\n\t\t}\n\n\t\tif (originalFormat) subtype = originalFormat;\n\t}\n\telse if (subtype==GF_ISOM_SUBTYPE_MPEG4) {\n\t\tu32 stsd_type = gf_isom_get_mpeg4_subtype(movie, track, stsd_idx);\n\t\tif (stsd_type==GF_ISOM_SUBTYPE_RESV)\n\t\t\tgf_isom_get_original_format_type(movie, track, stsd_idx, &subtype);\n\t}\n\n\tswitch (subtype) {\n\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\tesd = gf_isom_get_esd(movie, track, stsd_idx);\n\t\tif (esd && esd->decoderConfig) {\n\t\t\tswitch (esd->decoderConfig->streamType) {\n\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\t\t\te = rfc_6381_get_codec_aac(szCodec, esd->decoderConfig->objectTypeIndication, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, force_sbr);\n\t\t\t\t} else {\n\t\t\t\t\te = rfc_6381_get_codec_aac(szCodec, esd->decoderConfig->objectTypeIndication, NULL, 0, force_sbr);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_VISUAL:\n\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\t\t\te = rfc_6381_get_codec_m4v(szCodec, esd->decoderConfig->objectTypeIndication, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\t\t} else {\n\t\t\t\t\te = rfc_6381_get_codec_m4v(szCodec, esd->decoderConfig->objectTypeIndication, NULL, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"mp4s.%02X\", esd->decoderConfig->objectTypeIndication);\n\t\t\t\te = GF_OK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\treturn e;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[RFC6381] Cannot find ESD. Aborting.\\n\"));\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tavcc = gf_isom_avc_config_get(movie, track, stsd_idx);\n\t\tif (force_inband) {\n\t\t\tif (subtype==GF_ISOM_SUBTYPE_AVC_H264)\n\t\t\t\tsubtype = GF_ISOM_SUBTYPE_AVC3_H264;\n\t\t\telse if (subtype==GF_ISOM_SUBTYPE_AVC2_H264)\n\t\t\t\tsubtype = GF_ISOM_SUBTYPE_AVC4_H264;\n\t\t}\n\t\tif (avcc) {\n\t\t\te = rfc_6381_get_codec_avc(szCodec, subtype, avcc);\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\treturn e;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[RFC6381] Cannot find AVC configuration box\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\tavcc = gf_isom_mvc_config_get(movie, track, stsd_idx);\n\t\tif (!avcc) avcc = gf_isom_svc_config_get(movie, track, stsd_idx);\n\t\tif (avcc) {\n\t\t\te = rfc_6381_get_codec_avc(szCodec, subtype, avcc);\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\treturn e;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[RFC6381] Cannot find SVC/MVC configuration box\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tcase GF_ISOM_SUBTYPE_HVC1:\n\tcase GF_ISOM_SUBTYPE_HEV1:\n\tcase GF_ISOM_SUBTYPE_HVC2:\n\tcase GF_ISOM_SUBTYPE_HEV2:\n\tcase GF_ISOM_SUBTYPE_HVT1:\n\tcase GF_ISOM_SUBTYPE_LHV1:\n\tcase GF_ISOM_SUBTYPE_LHE1:\n\n\t\tif (force_inband) {\n\t\t\tif (subtype==GF_ISOM_SUBTYPE_HVC1) subtype = GF_ISOM_SUBTYPE_HEV1;\n\t\t\telse if (subtype==GF_ISOM_SUBTYPE_HVC2) subtype = GF_ISOM_SUBTYPE_HEV2;\n\t\t}\n\t\thvcc = gf_isom_hevc_config_get(movie, track, stsd_idx);\n\t\tif (!hvcc) {\n\t\t\thvcc = gf_isom_lhvc_config_get(movie, track, stsd_idx);\n\t\t}\n\t\tif (subtype==GF_ISOM_SUBTYPE_HVT1) {\n\t\t\tu32 refTrack;\n\t\t\tgf_isom_get_reference(movie, track, GF_ISOM_REF_TBAS, stsd_idx, &refTrack);\n\t\t\tif (hvcc) gf_odf_hevc_cfg_del(hvcc);\n\t\t\thvcc = gf_isom_hevc_config_get(movie, refTrack, 1);\n\t\t}\n\t\tif (hvcc) {\n\t\t\te = rfc_6381_get_codec_hevc(szCodec, subtype, hvcc);\n\t\t\tgf_odf_hevc_cfg_del(hvcc);\n\t\t\treturn e;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[RFC6381] HEVCConfig not compliant\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tcase GF_ISOM_SUBTYPE_AV01:\n\t{\n\t\tGF_AV1Config *av1c = gf_isom_av1_config_get(movie, track, stsd_idx);\n\t\tif (av1c) {\n\t\t\tu32 colour_type;\n\t\t\tCOLR colr;\n\t\t\tmemset(&colr, 0, sizeof(colr));\n\t\t\tif (GF_OK == gf_isom_get_color_info(movie, track, stsd_idx, &colour_type, &colr.colour_primaries, &colr.transfer_characteristics, &colr.matrix_coefficients, &colr.full_range)) {\n\t\t\t\tcolr.override = GF_TRUE;\n\t\t\t}\n\t\t\te = rfc_6381_get_codec_av1(szCodec, subtype, av1c, colr);\n\t\t\tgf_odf_av1_cfg_del(av1c);\n\t\t\treturn e;\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[RFC6381] No config found for AV1 file (\\\"%s\\\") when computing RFC6381.\\n\", gf_4cc_to_str(subtype)));\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tcase GF_ISOM_SUBTYPE_VP08:\n\tcase GF_ISOM_SUBTYPE_VP09:\n\t{\n\t\tGF_VPConfig *vpcc = gf_isom_vp_config_get(movie, track, stsd_idx);\n\t\tif (vpcc) {\n\t\t\tu32 colour_type;\n\t\t\tCOLR colr;\n\t\t\tmemset(&colr, 0, sizeof(colr));\n\t\t\tif (GF_OK == gf_isom_get_color_info(movie, track, stsd_idx, &colour_type, &colr.colour_primaries, &colr.transfer_characteristics, &colr.matrix_coefficients, &colr.full_range)) {\n\t\t\t\tcolr.override = GF_TRUE;\n\t\t\t}\n\t\t\te = rfc_6381_get_codec_vpx(szCodec, subtype, vpcc, colr);\n\t\t\tgf_odf_vp_cfg_del(vpcc);\n\t\t\treturn e;\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[RFC6381] No config found for VP file (\\\"%s\\\") when computing RFC6381.\\n\", gf_4cc_to_str(subtype)));\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tcase GF_ISOM_SUBTYPE_DVHE:\n\tcase GF_ISOM_SUBTYPE_DVH1:\n\tcase GF_ISOM_SUBTYPE_DVA1:\n\tcase GF_ISOM_SUBTYPE_DVAV:\n\tcase GF_ISOM_SUBTYPE_DAV1:\n\t{\n\t\tGF_DOVIDecoderConfigurationRecord *dovi = gf_isom_dovi_config_get(movie, track, stsd_idx);\n\t\tif (!dovi) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[RFC6381] No config found for Dolby Vision file (\\\"%s\\\") when computing RFC6381.\\n\", gf_4cc_to_str(subtype)));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\te = rfc_6381_get_codec_dolby_vision(szCodec, subtype, dovi);\n\t\tgf_odf_dovi_cfg_del(dovi);\n\t\treturn e;\n\t}\n\n\tcase GF_ISOM_SUBTYPE_VVC1:\n\tcase GF_ISOM_SUBTYPE_VVI1:\n\t{\n\t\tGF_VVCConfig *vvcc = gf_isom_vvc_config_get(movie, track, stsd_idx);\n\t\tif (vvcc) {\n\t\t\tif (force_inband) subtype = GF_ISOM_SUBTYPE_VVI1;\n\n\t\t\te = rfc_6381_get_codec_vvc(szCodec, subtype, vvcc);\n\t\t\tgf_odf_vvc_cfg_del(vvcc);\n\t\t\treturn e;\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[RFC6381] No config found for VVC file (\\\"%s\\\") when computing RFC6381.\\n\", gf_4cc_to_str(subtype)));\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA2:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM2:\n\t{\n\t\tesd = gf_media_map_esd(movie, track, stsd_idx);\n\t\tif (!esd || !esd->decoderConfig || !esd->decoderConfig->decoderSpecificInfo\n\t\t\t|| !esd->decoderConfig->decoderSpecificInfo->data\n\t\t) {\n\t\t\te = rfc_6381_get_codec_mpegha(szCodec, subtype, NULL, 0, -1);\n\t\t} else {\n\t\t\te = rfc_6381_get_codec_mpegha(szCodec, subtype, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, -1);\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\treturn e;\n\t}\n\n\tcase GF_ISOM_SUBTYPE_UNCV:\n\t{\n\t\tGF_GenericSampleDescription *udesc = gf_isom_get_generic_sample_description(movie, track, stsd_idx);\n\n\t\te = rfc_6381_get_codec_uncv(szCodec, subtype, udesc ? udesc->extension_buf : NULL, udesc ? udesc->extension_buf_size : 0);\n\t\tif (udesc) {\n\t\t\tif (udesc->extension_buf) gf_free(udesc->extension_buf);\n\t\t\tgf_free(udesc);\n\t\t}\n\t\treturn e;\n\t}\n    case GF_ISOM_SUBTYPE_STPP:\n    {\n        const char *xmlnamespace;\n        const char *xml_schema_loc;\n        const char *mimes;\n        e = gf_isom_xml_subtitle_get_description(movie, track, stsd_idx,\n                                             &xmlnamespace, &xml_schema_loc, &mimes);\n        if (e == GF_OK) {\n            rfc_6381_get_codec_stpp(szCodec, subtype, xmlnamespace, xml_schema_loc, mimes);\n        }\n        return e;\n    }\n\tdefault:\n\t\treturn rfc6381_codec_name_default(szCodec, subtype, gf_codec_id_from_isobmf(subtype));\n\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err gf_media_av1_layer_size_get(GF_ISOFile *file, u32 trackNumber, u32 sample_number, u8 op_index, u32 layer_size[3])\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tu32 i;\n\tAV1State av1;\n\tObuType obu_type;\n\tu64 obu_size = 0;\n\tu32 hdr_size;\n\tGF_BitStream *bs;\n\tu32 sdidx;\n\tGF_ISOSample *samp;\n\tGF_Err e = GF_OK;\n\n\tsamp = gf_isom_get_sample(file, trackNumber, sample_number, &sdidx);\n\tif (!samp) return GF_BAD_PARAM;\n\n\tif (!sdidx) {\n\t\tgf_isom_sample_del(&samp);\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (gf_isom_get_media_subtype(file, trackNumber, sdidx) != GF_ISOM_SUBTYPE_AV01) {\n\t\tgf_isom_sample_del(&samp);\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tgf_av1_init_state(&av1);\n\tav1.config = gf_isom_av1_config_get(file, trackNumber, sdidx);\n\tif (!av1.config) {\n\t\tgf_isom_sample_del(&samp);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tfor (i=0; i<gf_list_count(av1.config->obu_array); i++) {\n\t\tGF_AV1_OBUArrayEntry *obu = gf_list_get(av1.config->obu_array, i);\n\t\tbs = gf_bs_new(obu->obu, (u32) obu->obu_length, GF_BITSTREAM_READ);\n\t\te = gf_av1_parse_obu(bs, &obu_type, &obu_size, &hdr_size, &av1);\n\t\tgf_bs_del(bs);\n\t\tif (e) break;\n\t}\n\n\tif (!e) {\n\t\tbs = gf_bs_new(samp->data, samp->dataLength, GF_BITSTREAM_READ);\n\t\twhile (gf_bs_available(bs)) {\n\t\t\te = gf_av1_parse_obu(bs, &obu_type, &obu_size, &hdr_size, &av1);\n\t\t\tif (e) break;\n\t\t}\n\t\tgf_bs_del(bs);\n\t}\n\tgf_isom_sample_del(&samp);\n\n  if (op_index > av1.operating_points_count) {\n    if (av1.config) gf_odf_av1_cfg_del(av1.config);\n    gf_av1_reset_state(&av1, GF_TRUE);\n    return GF_BAD_PARAM;\n  }\n\n\tfor (i=0; i<3; i++) {\n\t\tif (av1.layer_size[i+1]==av1.layer_size[i]) {\n\t\t\tlayer_size[i] = 0;\n\t\t} else {\n\t\t\tlayer_size[i] = av1.layer_size[i];\n\t\t}\n\t}\n\n\tif (av1.config) gf_odf_av1_cfg_del(av1.config);\n\tgf_av1_reset_state(&av1, GF_TRUE);\n\n\treturn e;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_EXPORT\nGF_Err gf_media_isom_apply_qt_key(GF_ISOFile *movie, const char *name, const char *val)\n{\n\tGF_Err e;\n\tu8 *data=NULL;\n\tGF_QT_UDTAKey key;\n\tif (!name) return GF_BAD_PARAM;\n\n\tmemset(&key, 0, sizeof(GF_QT_UDTAKey));\n\tkey.name = (char *) name;\n\tkey.ns = GF_4CC('m','d','t','a');\n\tchar *sep = strchr(name, '@');\n\tif (sep) {\n\t\tsep[0] = 0;\n\t\tkey.name = sep+1;\n\t\tif (strlen(name)!=4) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Unrecognize namespace \\\"%s\\\" for key %s\\n\", name, sep+1));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tkey.ns = GF_4CC(name[0], name[1],name[2],name[3]);\n\t\tsep[0] = '@';\n\t}\n\n\tif (!val || !val[0]) {\n\t\tkey.type = GF_QT_KEY_REMOVE;\n\t} else if (!strcmp(val, \"NULL\")) {\n\t\tkey.type = GF_QT_KEY_REMOVE;\n\t} else {\n\t\tkey.type = GF_QT_KEY_UTF8;\n\t\tkey.value.string = val;\n\n\t\tif (gf_file_exists(val)) {\n\t\t\te = gf_file_load_data(val, &data, &key.value.data.data_len);\n\t\t\tif (e!=GF_OK) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Failed to load file \\\"%s\\\" for key %s: %s\\n\", val, name, gf_error_to_string(e)));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tkey.value.data.data = data;\n\t\t\tkey.type = GF_QT_KEY_OPAQUE;\n\t\t\tif (strstr(val, \".bmp\")|| strstr(val, \".BMP\")) {\n\t\t\t\tkey.type = GF_QT_KEY_BMP;\n\t\t\t} else if (key.value.data.data_len>3) {\n\t\t\t\tif ((data[0]==0xFF) && (data[1]==0xD8) && (data[2]==0xFF)) {\n\t\t\t\t\tkey.type = GF_QT_KEY_JPEG;\n\t\t\t\t} else if ((data[0]==0x89) && (data[1]==0x50) && (data[2]==0x4E)) {\n\t\t\t\t\tkey.type = GF_QT_KEY_PNG;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tchar *force_str=NULL;\n\t\t\tif (val[0] == 'S') {\n\t\t\t\tforce_str = (char*)val+1;\n\t\t\t\tval++;\n\t\t\t}\n\t\t\tchar *rect_sep = strchr(val, '@');\n\t\t\tchar *pos_sep = strchr(val, 'x');\n\t\t\tchar *arr_sep = strchr(val, ',');\n\t\t\tif (rect_sep && pos_sep && (sscanf(val, \"%gx%g@%gx%g\", &key.value.rect.x, &key.value.rect.y, &key.value.rect.w, &key.value.rect.h) == 4)) {\n\t\t\t\tkey.type = GF_QT_KEY_RECTF;\n\t\t\t} else if (rect_sep && (sscanf(val, \"%g@%g\", &key.value.pos_size.x, &key.value.pos_size.y)==2)) {\n\t\t\t\tkey.type = GF_QT_KEY_SIZEF;\n\t\t\t} else if (pos_sep && (sscanf(val, \"%gx%g\", &key.value.pos_size.x, &key.value.pos_size.y)==2)) {\n\t\t\t\tkey.type = GF_QT_KEY_POINTF;\n\t\t\t} else if (arr_sep && strchr(arr_sep, ',')\n\t\t\t\t&& (sscanf(val, \"%lg,%lg,%lg,%lg,%lg,%lg,%lg,%lg,%lg\", &key.value.matrix[0], &key.value.matrix[1], &key.value.matrix[2]\n\t\t\t\t, &key.value.matrix[3], &key.value.matrix[4], &key.value.matrix[5]\n\t\t\t\t, &key.value.matrix[6], &key.value.matrix[7], &key.value.matrix[8]\n\t\t\t\t)==9)\n\t\t\t) {\n\t\t\t\tkey.type = GF_QT_KEY_MATRIXF;\n\t\t\t} else {\n\t\t\t\tBool force_flt=GF_FALSE,force_dbl=GF_FALSE,force_sign=GF_FALSE;\n\t\t\t\tu32 force_size=0;\n\t\t\t\twhile (1) {\n\t\t\t\t\tchar c = val[0];\n\t\t\t\t\tif (c=='f') force_flt = GF_TRUE;\n\t\t\t\t\telse if (c=='d') force_dbl = GF_TRUE;\n\t\t\t\t\telse if (c=='+') force_sign = GF_TRUE;\n\t\t\t\t\telse if (c=='b') force_size = 1;\n\t\t\t\t\telse if (c=='s') force_size = 2;\n\t\t\t\t\telse if (c=='l') force_size = 3;\n\t\t\t\t\telse if (c=='L') force_size = 4;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tval++;\n\t\t\t\t}\n\t\t\t\tif (arr_sep || strchr(val, '.') || force_dbl || force_flt) {\n\t\t\t\t\tDouble res;\n\t\t\t\t\tif (sscanf(val, \"%lg\", &res)==1) {\n\t\t\t\t\t\tkey.value.number = res;\n\t\t\t\t\t\tkey.type = force_flt ? GF_QT_KEY_FLOAT : GF_QT_KEY_DOUBLE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ts64 res;\n\t\t\t\t\tif (sscanf(val, LLD, &res)==1) {\n\t\t\t\t\t\tkey.value.sint = res;\n\t\t\t\t\t\tif (!force_sign && (key.value.sint>0)) {\n\t\t\t\t\t\t\tkey.value.uint = key.value.sint;\n\t\t\t\t\t\t\tif (force_size==1) key.type = GF_QT_KEY_UNSIGNED_8;\n\t\t\t\t\t\t\telse if (force_size==2) key.type = GF_QT_KEY_UNSIGNED_16;\n\t\t\t\t\t\t\telse if (force_size==3) key.type = GF_QT_KEY_UNSIGNED_32;\n\t\t\t\t\t\t\telse if (force_size==4) key.type = GF_QT_KEY_UNSIGNED_64;\n\t\t\t\t\t\t\telse key.type = GF_QT_KEY_UNSIGNED_VSIZE;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (force_size==1) key.type = GF_QT_KEY_SIGNED_8;\n\t\t\t\t\t\t\telse if (force_size==2) key.type = GF_QT_KEY_SIGNED_16;\n\t\t\t\t\t\t\telse if (force_size==3) key.type = GF_QT_KEY_SIGNED_32;\n\t\t\t\t\t\t\telse if (force_size==4) key.type = GF_QT_KEY_SIGNED_64;\n\t\t\t\t\t\t\telse key.type = GF_QT_KEY_SIGNED_VSIZE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (force_str && (key.type != GF_QT_KEY_UTF8)) {\n\t\t\t\tkey.type = GF_QT_KEY_UTF8;\n\t\t\t\tkey.value.string = force_str;\n\t\t\t}\n\t\t}\n\t}\n\n\te = gf_isom_set_qt_key(movie, &key);\n\tif (data) gf_free(data);\n\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Failed to add key %s: %s\\n\", name, gf_error_to_string(e) ));\n\t}\n\treturn e;\n}\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n\n#endif //GPAC_DISABLE_ISOM\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Media Tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n\n#include <gpac/internal/media_dev.h>\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n#include <gpac/config_file.h>\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_EXPORT\nGF_Err gf_media_change_par(GF_ISOFile *file, u32 track, s32 ar_num, s32 ar_den, Bool force_par, Bool rewrite_bs)\n{\n\tu32 tk_w, tk_h;\n\tGF_Err e;\n\tBool get_par_info = GF_FALSE;\n\n\te = gf_isom_get_visual_info(file, track, 1, &tk_w, &tk_h);\n\tif (e) return e;\n\n\tif ((ar_num < 0) || (ar_den < 0)) {\n\t\tget_par_info = GF_TRUE;\n\t\trewrite_bs = GF_FALSE;\n\t}\n\telse if (!ar_num || !ar_den) {\n\t\trewrite_bs = GF_FALSE;\n\t}\n\n\tif (get_par_info || rewrite_bs) {\n\t\tu32 stype = gf_isom_get_media_subtype(file, track, 1);\n\t\tif ((stype==GF_ISOM_SUBTYPE_AVC_H264)\n\t\t\t\t|| (stype==GF_ISOM_SUBTYPE_AVC2_H264)\n\t\t\t\t|| (stype==GF_ISOM_SUBTYPE_AVC3_H264)\n\t\t\t\t|| (stype==GF_ISOM_SUBTYPE_AVC4_H264)\n\t\t   ) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(file, track, 1);\n\t\t\tif (rewrite_bs) {\n\t\t\t\tgf_avc_change_par(avcc, ar_num, ar_den);\n\t\t\t\te = gf_isom_avc_config_update(file, track, 1, avcc);\n\t\t\t} else {\n\t\t\t\tGF_NALUFFParam *sl = gf_list_get(avcc->sequenceParameterSets, 0);\n\t\t\t\tif (sl) {\n\t\t\t\t\tgf_avc_get_sps_info(sl->data, sl->size, NULL, NULL, NULL, &ar_num, &ar_den);\n\t\t\t\t} else {\n\t\t\t\t\tar_num = ar_den = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\tif (e) return e;\n#endif\n\t\t}\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\telse if ((stype==GF_ISOM_SUBTYPE_HVC1) || (stype==GF_ISOM_SUBTYPE_HVC2)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_HEV1) || (stype==GF_ISOM_SUBTYPE_HEV2)\n\t\t) {\n\t\t\tGF_HEVCConfig *hvcc = gf_isom_hevc_config_get(file, track, 1);\n\t\t\tif (rewrite_bs) {\n\t\t\t\tgf_hevc_change_par(hvcc, ar_num, ar_den);\n\t\t\t\te = gf_isom_hevc_config_update(file, track, 1, hvcc);\n\t\t\t} else {\n\t\t\t\tu32 i=0;\n\t\t\t\tGF_NALUFFParamArray *ar;\n\t\t\t\tar_num = ar_den = 0;\n\t\t\t\twhile ( (ar = gf_list_enum(hvcc->param_array, &i))) {\n\t\t\t\t\tif (ar->type==GF_HEVC_NALU_SEQ_PARAM) {\n\t\t\t\t\t\tGF_NALUFFParam *sl = gf_list_get(ar->nalus, 0);\n\t\t\t\t\t\tif (sl)\n\t\t\t\t\t\t\tgf_hevc_get_sps_info(sl->data, sl->size, NULL, NULL, NULL, &ar_num, &ar_den);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_odf_hevc_cfg_del(hvcc);\n\t\t\tif (e) return e;\n\t\t}\n\t\telse if (stype == GF_ISOM_SUBTYPE_AV01) {\n\t\t\t//GF_AV1Config *av1c = gf_isom_av1_config_get(file, track, 1);\n\t\t\t//TODO: e = gf_isom_av1_config_update(file, track, 1, av1c);\n\t\t\t//gf_odf_av1_cfg_del(av1c);\n\t\t\t//if (e) return e;\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\telse if ((stype==GF_ISOM_SUBTYPE_VVC1) || (stype==GF_ISOM_SUBTYPE_VVI1)\n\t\t) {\n\t\t\tGF_VVCConfig *vvcc = gf_isom_vvc_config_get(file, track, 1);\n\t\t\tif (rewrite_bs) {\n\t\t\t\tgf_vvc_change_par(vvcc, ar_num, ar_den);\n\t\t\t\te = gf_isom_vvc_config_update(file, track, 1, vvcc);\n\t\t\t} else {\n\t\t\t\tu32 i=0;\n\t\t\t\tGF_NALUFFParamArray *ar;\n\t\t\t\tar_num = ar_den = 0;\n\t\t\t\twhile ( (ar = gf_list_enum(vvcc->param_array, &i))) {\n\t\t\t\t\tif (ar->type==GF_VVC_NALU_SEQ_PARAM) {\n\t\t\t\t\t\tGF_NALUFFParam *sl = gf_list_get(ar->nalus, 0);\n\t\t\t\t\t\tif (sl)\n\t\t\t\t\t\t\tgf_vvc_get_sps_info(sl->data, sl->size, NULL, NULL, NULL, &ar_num, &ar_den);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_odf_vvc_cfg_del(vvcc);\n\t\t\tif (e) return e;\n\t\t}\n#endif\n\t\telse if (stype==GF_ISOM_SUBTYPE_MPEG4) {\n\t\t\tGF_ESD *esd = gf_isom_get_esd(file, track, 1);\n\t\t\tif (!esd || !esd->decoderConfig || (esd->decoderConfig->streamType!=4) ) {\n\t\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t}\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) {\n\t\t\t\tif (rewrite_bs) {\n\t\t\t\t\te = gf_m4v_rewrite_par(&esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength, ar_num, ar_den);\n\t\t\t\t\tif (!e) e = gf_isom_change_mpeg4_description(file, track, 1, esd);\n\t\t\t\t} else {\n\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\te = gf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\tar_num = dsi.par_num;\n\t\t\t\t\tar_den = dsi.par_den;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\t\tif (e) return e;\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tu32 mtype = gf_isom_get_media_type(file, track);\n\t\t\tif (gf_isom_is_video_handler_type(mtype)) {\n\t\t\t\tif (rewrite_bs) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER,\n\t\t\t\t\t\t(\"[ISOBMF] Warning: changing pixel ratio of media subtype \\\"%s\\\" is not supported, changing only \\\"pasp\\\" signaling\\n\",\n\t\t\t\t\t\t\tgf_4cc_to_str(gf_isom_get_media_subtype(file, track, 1)) ));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMF] Error: changing pixel ratio on non-video track.\\n\"));\n\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t}\n\t\t}\n\t\t//auto mode\n\t\tif (get_par_info && ((ar_num<=0) || (ar_den<=0))) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ISOBMF] No sample AR info present in sample description, ignoring SAR update\\n\"));\n\t\t\tif (force_par)\n\t\t\t\treturn gf_isom_set_pixel_aspect_ratio(file, track, 1, 1, 1, force_par);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\te = gf_isom_set_pixel_aspect_ratio(file, track, 1, ar_num, ar_den, force_par);\n\tif (e) return e;\n\n\tif ((ar_den>0) && (ar_num>0)) {\n\t\ttk_w = tk_w * ar_num / ar_den;\n\t}\n\t/*PASP has been removed or forced to 1:1, revert to full frame for track layout*/\n\telse {\n\t\te = gf_isom_get_visual_info(file, track, 1, &tk_w, &tk_h);\n\t\tif (e) return e;\n\t}\n\treturn gf_isom_set_track_layout_info(file, track, tk_w<<16, tk_h<<16, 0, 0, 0);\n}\n\nGF_EXPORT\nGF_Err gf_media_change_color(GF_ISOFile *file, u32 track, s32 fullrange, s32 vidformat, s32 colorprim, s32 transfer, s32 colmatrix)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tGF_Err e;\n\tu32 stype = gf_isom_get_media_subtype(file, track, 1);\n\tif ((stype==GF_ISOM_SUBTYPE_AVC_H264)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_AVC2_H264)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_AVC3_H264)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_AVC4_H264)\n\t) {\n\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(file, track, 1);\n\t\tgf_avc_change_color(avcc, fullrange, vidformat, colorprim, transfer, colmatrix);\n\t\te = gf_isom_avc_config_update(file, track, 1, avcc);\n\t\tgf_odf_avc_cfg_del(avcc);\n\t\tif (e) return e;\n\t\t//remove any colr box\n\t\treturn gf_isom_set_visual_color_info(file, track, 1, 0, 0, 0, 0, 0, NULL, 0);\n\t}\n\tif ((stype==GF_ISOM_SUBTYPE_HEV1)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_HEV2)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_HVC1)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_HVC2)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_LHV1)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_LHE1)\n\t) {\n\t\tGF_HEVCConfig *hvcc = gf_isom_hevc_config_get(file, track, 1);\n\t\tgf_hevc_change_color(hvcc, fullrange, vidformat, colorprim, transfer, colmatrix);\n\t\te = gf_isom_hevc_config_update(file, track, 1, hvcc);\n\t\tgf_odf_hevc_cfg_del(hvcc);\n\t\tif (e) return e;\n\t\t//remove any colr box\n\t\treturn gf_isom_set_visual_color_info(file, track, 1, 0, 0, 0, 0, 0, NULL, 0);\n\t}\n\tif ((stype==GF_ISOM_SUBTYPE_VVC1) || (stype==GF_ISOM_SUBTYPE_VVI1) ) {\n\t\tGF_VVCConfig *vvcc = gf_isom_vvc_config_get(file, track, 1);\n\t\tgf_vvc_change_color(vvcc, fullrange, vidformat, colorprim, transfer, colmatrix);\n\t\te = gf_isom_vvc_config_update(file, track, 1, vvcc);\n\t\tgf_odf_vvc_cfg_del(vvcc);\n\t\tif (e) return e;\n\t\t//remove any colr box\n\t\treturn gf_isom_set_visual_color_info(file, track, 1, 0, 0, 0, 0, 0, NULL, 0);\n\t}\n#endif\n\treturn GF_NOT_SUPPORTED;\n}\n\nGF_EXPORT\nGF_Err gf_media_remove_non_rap(GF_ISOFile *file, u32 track, Bool non_ref_only)\n{\n\tGF_Err e;\n\tu32 i, count, di;\n\tu64 offset, dur, last_dts;\n\tBool all_raps = (gf_isom_has_sync_points(file, track)==0) ? 1 : 0;\n\tif (all_raps) return GF_OK;\n\n\tlast_dts = 0;\n\tdur = gf_isom_get_media_duration(file, track);\n\n\tgf_isom_set_cts_packing(file, track, GF_TRUE);\n\n\tcount = gf_isom_get_sample_count(file, track);\n\tfor (i=0; i<count; i++) {\n\t\tBool remove = GF_TRUE;\n\t\tGF_ISOSample *samp = gf_isom_get_sample_info(file, track, i+1, &di, &offset);\n\t\tif (!samp) return gf_isom_last_error(file);\n\n\t\tif (samp->IsRAP) remove = GF_FALSE;\n\t\telse if (non_ref_only) {\n\t\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\t\t\tgf_isom_get_sample_flags(file, track, i+1, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\t\tif (dependedOn != 2) {\n\t\t\t\tremove = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tif (!remove) {\n\t\t\tlast_dts = samp->DTS;\n\t\t\tgf_isom_sample_del(&samp);\n\t\t\tcontinue;\n\t\t}\n\t\tgf_isom_sample_del(&samp);\n\t\te = gf_isom_remove_sample(file, track, i+1);\n\t\tif (e) return e;\n\t\ti--;\n\t\tcount--;\n\t}\n\tgf_isom_set_cts_packing(file, track, GF_FALSE);\n\tgf_isom_set_last_sample_duration(file, track, (u32) (dur - last_dts) );\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_EXPORT\nGF_Err gf_media_get_file_hash(const char *file, u8 hash[20])\n{\n\tu8 block[4096];\n\tu32 read;\n\tu64 size, tot;\n\tFILE *in;\n\tGF_SHA1Context *ctx;\n\tGF_Err e = GF_OK;\n#ifndef GPAC_DISABLE_ISOM\n\tGF_BitStream *bs = NULL;\n\tBool is_isom = gf_isom_probe_file(file);\n#endif\n\n\tin = gf_fopen(file, \"rb\");\n    if (!in) return GF_URL_ERROR;\n\tsize = gf_fsize(in);\n\n\tctx = gf_sha1_starts();\n\ttot = 0;\n#ifndef GPAC_DISABLE_ISOM\n\tif (is_isom) bs = gf_bs_from_file(in, GF_BITSTREAM_READ);\n#endif\n\n\twhile (tot<size) {\n#ifndef GPAC_DISABLE_ISOM\n\t\tif (is_isom) {\n\t\t\tu64 box_size = gf_bs_peek_bits(bs, 32, 0);\n\t\t\tu32 box_type = gf_bs_peek_bits(bs, 32, 4);\n\n\t\t\t/*64-bit size*/\n\t\t\tif (box_size==1) box_size = gf_bs_peek_bits(bs, 64, 8);\n\t\t\t/*till end of file*/\n\t\t\tif (!box_size) box_size = size - tot;\n\n\t\t\t/*skip all MutableDRMInformation*/\n\t\t\tif (box_type==GF_ISOM_BOX_TYPE_MDRI) {\n\t\t\t\tgf_bs_skip_bytes(bs, box_size);\n\t\t\t\ttot += box_size;\n\t\t\t} else {\n\t\t\t\tu64 bsize = 0;\n\t\t\t\twhile (bsize<box_size) {\n\t\t\t\t\tu32 to_read = (u32) ((box_size-bsize<4096) ? (box_size-bsize) : 4096);\n\t\t\t\t\tread = gf_bs_read_data(bs, (char *) block, to_read);\n\t\t\t\t\tif (!read || (read != to_read) ) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"corrupted isobmf file, box read \"LLU\" but expected still \"LLU\" bytes\\n\", bsize, box_size));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tgf_sha1_update(ctx, block, to_read);\n\t\t\t\t\tbsize += to_read;\n\t\t\t\t}\n\t\t\t\ttot += box_size;\n\t\t\t}\n\t\t} else\n#endif\n\t\t{\n\t\t\tread = (u32) gf_fread(block, 4096, in);\n\t\t\tif ((s32) read <= 0) {\n\t\t\t\tif (ferror(in))\n\t\t\t\t\te = GF_IO_ERR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_sha1_update(ctx, block, read);\n\t\t\ttot += read;\n\t\t}\n\t}\n\tgf_sha1_finish(ctx, hash);\n#ifndef GPAC_DISABLE_ISOM\n\tif (bs) gf_bs_del(bs);\n#endif\n\tgf_fclose(in);\n\treturn e;\n}\n\n#ifndef GPAC_DISABLE_ISOM\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nstatic const u32 ISMA_VIDEO_OD_ID = 20;\nstatic const u32 ISMA_AUDIO_OD_ID = 10;\n\nstatic const u32 ISMA_VIDEO_ES_ID = 201;\nstatic const u32 ISMA_AUDIO_ES_ID = 101;\n\n/*ISMA audio*/\nstatic const u8 ISMA_BIFS_AUDIO[] =\n{\n\t0xC0, 0x10, 0x12, 0x81, 0x30, 0x2A, 0x05, 0x7C\n};\n/*ISMA video*/\nstatic const u8 ISMA_GF_BIFS_VIDEO[] =\n{\n\t0xC0, 0x10, 0x12, 0x60, 0x42, 0x82, 0x28, 0x29,\n\t0xD0, 0x4F, 0x00\n};\n/*ISMA audio-video*/\nstatic const u8 ISMA_BIFS_AV[] =\n{\n\t0xC0, 0x10, 0x12, 0x81, 0x30, 0x2A, 0x05, 0x72,\n\t0x60, 0x42, 0x82, 0x28, 0x29, 0xD0, 0x4F, 0x00\n};\n\n/*image only - uses same visual OD ID as video*/\nstatic const u8 ISMA_BIFS_IMAGE[] =\n{\n\t0xC0, 0x11, 0xA4, 0xCD, 0x53, 0x6A, 0x0A, 0x44,\n\t0x13, 0x00\n};\n\n/*ISMA audio-image*/\nstatic const u8 ISMA_BIFS_AI[] =\n{\n\t0xC0, 0x11, 0xA5, 0x02, 0x60, 0x54, 0x0A, 0xE4,\n\t0xCD, 0x53, 0x6A, 0x0A, 0x44, 0x13, 0x00\n};\n\n\nGF_EXPORT\nGF_Err gf_media_make_isma(GF_ISOFile *mp4file, Bool keepESIDs, Bool keepImage, Bool no_ocr)\n{\n\tu32 AudioTrack, VideoTrack, Tracks, i, mType, bifsT, odT, descIndex, VID, AID, bifsID, odID;\n\tu32 bifs, w, h;\n\tBool is_image, image_track;\n\tGF_ESD *a_esd, *v_esd, *_esd;\n\tGF_ObjectDescriptor *od;\n\tGF_ODUpdate *odU;\n\tGF_ODCodec *codec;\n\tGF_ISOSample *samp;\n\tGF_BitStream *bs;\n\tu8 audioPL, visualPL;\n\n\tswitch (gf_isom_get_mode(mp4file)) {\n\tcase GF_ISOM_OPEN_EDIT:\n\tcase GF_ISOM_OPEN_WRITE:\n\tcase GF_ISOM_WRITE_EDIT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\n\tTracks = gf_isom_get_track_count(mp4file);\n\tAID = VID = 0;\n\tis_image = 0;\n\n\t//search for tracks\n\tfor (i=0; i<Tracks; i++) {\n\t\tGF_ESD *esd = gf_isom_get_esd(mp4file, i+1, 1);\n\t\t//remove from IOD\n\t\tgf_isom_remove_track_from_root_od(mp4file, i+1);\n\n\t\tmType = gf_isom_get_media_type(mp4file, i+1);\n\t\tswitch (mType) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n        case GF_ISOM_MEDIA_AUXV:\n        case GF_ISOM_MEDIA_PICT:\n\t\t\timage_track = 0;\n\t\t\tif (esd && esd->decoderConfig && ((esd->decoderConfig->objectTypeIndication==GF_CODECID_JPEG) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_PNG)) )\n\t\t\t\timage_track = 1;\n\n\t\t\t/*remove image tracks if wanted*/\n\t\t\tif (keepImage || !image_track) {\n\t\t\t\t/*only ONE video stream possible with ISMA*/\n\t\t\t\tif (VID) {\n\t\t\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor*)esd);\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[ISMA convert] More than one video track found, cannot convert file - remove extra track(s)\\n\"));\n\t\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t\t}\n\t\t\t\tVID = gf_isom_get_track_id(mp4file, i+1);\n\t\t\t\tis_image = image_track;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[ISMA convert] Visual track ID %d: only one sample found, assuming image and removing track\\n\", gf_isom_get_track_id(mp4file, i+1) ) );\n\t\t\t\tgf_isom_remove_track(mp4file, i+1);\n\t\t\t\ti -= 1;\n\t\t\t\tTracks = gf_isom_get_track_count(mp4file);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tif (AID) {\n\t\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor*)esd);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[ISMA convert] More than one audio track found, cannot convert file - remove extra track(s)\\n\") );\n\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t}\n\t\t\tAID = gf_isom_get_track_id(mp4file, i+1);\n\t\t\tbreak;\n\t\t/*clean file*/\n\t\tdefault:\n\t\t\tif (mType==GF_ISOM_MEDIA_HINT) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[ISMA convert] Removing Hint track ID %d\\n\", gf_isom_get_track_id(mp4file, i+1) ));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[ISMA convert] Removing track ID %d\\n\", gf_isom_get_track_id(mp4file, i+1) ));\n\t\t\t}\n\t\t\tgf_isom_remove_track(mp4file, i+1);\n\t\t\ti -= 1;\n\t\t\tTracks = gf_isom_get_track_count(mp4file);\n\t\t\tbreak;\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor*)esd);\n\t}\n\t//no audio no video\n\tif (!AID && !VID) return GF_OK;\n\n\t/*reset all PLs*/\n\tvisualPL = 0xFE;\n\taudioPL = 0xFE;\n\n\tod = (GF_ObjectDescriptor *) gf_isom_get_root_od(mp4file);\n\tif (od && (od->tag==GF_ODF_IOD_TAG)) {\n\t\taudioPL = ((GF_InitialObjectDescriptor*)od)->audio_profileAndLevel;\n\t\tvisualPL = ((GF_InitialObjectDescriptor*)od)->visual_profileAndLevel;\n\t}\n\tif (od) gf_odf_desc_del((GF_Descriptor *)od);\n\n\n\t//create the OD AU\n\tbifs = 0;\n\todU = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\n\ta_esd = v_esd = NULL;\n\n\tgf_isom_set_root_od_id(mp4file, 1);\n\n\tbifsID = 1;\n\todID = 2;\n\tif (keepESIDs) {\n\t\tbifsID = 1;\n\t\twhile ((bifsID==AID) || (bifsID==VID)) bifsID++;\n\t\todID = 2;\n\t\twhile ((odID==AID) || (odID==VID) || (odID==bifsID)) odID++;\n\n\t}\n\n\tVideoTrack = gf_isom_get_track_by_id(mp4file, VID);\n\tAudioTrack = gf_isom_get_track_by_id(mp4file, AID);\n\n\tw = h = 0;\n\tif (VideoTrack) {\n\t\tbifs = 1;\n\t\tod = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_OD_TAG);\n\t\tod->objectDescriptorID = ISMA_VIDEO_OD_ID;\n\n\t\tif (!keepESIDs && (VID != ISMA_VIDEO_ES_ID)) {\n\t\t\tgf_isom_set_track_id(mp4file, VideoTrack, ISMA_VIDEO_ES_ID);\n\t\t}\n\n\t\tv_esd = gf_isom_get_esd(mp4file, VideoTrack, 1);\n\t\tif (v_esd) {\n\t\t\tv_esd->OCRESID = no_ocr ? 0 : bifsID;\n\n\t\t\tgf_odf_desc_add_desc((GF_Descriptor *)od, (GF_Descriptor *)v_esd);\n\t\t\tgf_list_add(odU->objectDescriptors, od);\n\n\t\t\tgf_isom_get_track_layout_info(mp4file, VideoTrack, &w, &h, NULL, NULL, NULL);\n\t\t\tif (!w || !h) {\n\t\t\t\tgf_isom_get_visual_info(mp4file, VideoTrack, 1, &w, &h);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\tif (v_esd->decoderConfig\n\t\t\t\t\t&& (v_esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2)\n\t\t\t\t\t&& (v_esd->decoderConfig->streamType==GF_STREAM_VISUAL)\n\t\t\t\t\t&& v_esd->decoderConfig->decoderSpecificInfo\n\t\t\t\t\t&& v_esd->decoderConfig->decoderSpecificInfo->data\n\t\t\t\t) {\n\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\tgf_m4v_get_config(v_esd->decoderConfig->decoderSpecificInfo->data, v_esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\tif (!is_image && (!w || !h)) {\n\t\t\t\t\t\tw = dsi.width;\n\t\t\t\t\t\th = dsi.height;\n\t\t\t\t\t\tgf_isom_set_visual_info(mp4file, VideoTrack, 1, w, h);\n\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[ISMA convert] Adjusting visual track size to %d x %d\\n\", w, h));\n\t\t\t\t\t}\n\t\t\t\t\tif (dsi.par_num && dsi.par_den && (dsi.par_den!=dsi.par_num)) {\n\t\t\t\t\t\tw *= dsi.par_num;\n\t\t\t\t\t\tw /= dsi.par_den;\n\t\t\t\t\t}\n\t\t\t\t\tif (dsi.VideoPL) visualPL = dsi.VideoPL;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\tif (AudioTrack) {\n\t\tod = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_OD_TAG);\n\t\tod->objectDescriptorID = ISMA_AUDIO_OD_ID;\n\n\t\tif (!keepESIDs && (AID != ISMA_AUDIO_ES_ID)) {\n\t\t\tgf_isom_set_track_id(mp4file, AudioTrack, ISMA_AUDIO_ES_ID);\n\t\t}\n\n\t\ta_esd = gf_isom_get_esd(mp4file, AudioTrack, 1);\n\t\tif (a_esd) {\n\t\t\ta_esd->OCRESID = no_ocr ? 0 : bifsID;\n\n\t\t\tif (!keepESIDs) a_esd->ESID = ISMA_AUDIO_ES_ID;\n\t\t\tgf_odf_desc_add_desc((GF_Descriptor *)od, (GF_Descriptor *)a_esd);\n\t\t\tgf_list_add(odU->objectDescriptors, od);\n\t\t\tif (!bifs) {\n\t\t\t\tbifs = 3;\n\t\t\t} else {\n\t\t\t\tbifs = 2;\n\t\t\t}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\tif (a_esd->decoderConfig && (a_esd->decoderConfig->objectTypeIndication == GF_CODECID_AAC_MPEG4)\n\t\t\t\t&& a_esd->decoderConfig->decoderSpecificInfo\n\t\t\t\t&& a_esd->decoderConfig->decoderSpecificInfo->data\n\t\t\t) {\n\t\t\t\tGF_M4ADecSpecInfo cfg;\n\t\t\t\tgf_m4a_get_config(a_esd->decoderConfig->decoderSpecificInfo->data, a_esd->decoderConfig->decoderSpecificInfo->dataLength, &cfg);\n\t\t\t\taudioPL = cfg.audioPL;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\t/*update video cfg if needed*/\n\tif (v_esd) gf_isom_change_mpeg4_description(mp4file, VideoTrack, 1, v_esd);\n\tif (a_esd) gf_isom_change_mpeg4_description(mp4file, AudioTrack, 1, a_esd);\n\n\t/*likely 3GP or other files...*/\n\tif ((!a_esd && AudioTrack) || (!v_esd && VideoTrack)) return GF_OK;\n\n\t//get the OD sample\n\tcodec = gf_odf_codec_new();\n\tsamp = gf_isom_sample_new();\n\tgf_odf_codec_add_com(codec, (GF_ODCom *)odU);\n\tgf_odf_codec_encode(codec, 1);\n\tgf_odf_codec_get_au(codec, &samp->data, &samp->dataLength);\n\tgf_odf_codec_del(codec);\n\tsamp->CTS_Offset = 0;\n\tsamp->DTS = 0;\n\tsamp->IsRAP = RAP;\n\n\t/*create the OD track*/\n\todT = gf_isom_new_track(mp4file, odID, GF_ISOM_MEDIA_OD, gf_isom_get_timescale(mp4file));\n\tif (!odT) return gf_isom_last_error(mp4file);\n\n\t_esd = gf_odf_desc_esd_new(SLPredef_MP4);\n\tif (!_esd) return GF_OUT_OF_MEM;\n\n\t_esd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t_esd->decoderConfig->objectTypeIndication = GF_CODECID_OD_V1;\n\t_esd->decoderConfig->streamType = GF_STREAM_OD;\n\t_esd->ESID = odID;\n\t_esd->OCRESID = no_ocr ? 0 : bifsID;\n\tgf_isom_new_mpeg4_description(mp4file, odT, _esd, NULL, NULL, &descIndex);\n\tgf_odf_desc_del((GF_Descriptor *)_esd);\n\tgf_isom_add_sample(mp4file, odT, 1, samp);\n\tgf_isom_sample_del(&samp);\n\n\tgf_isom_set_track_interleaving_group(mp4file, odT, 1);\n\n\t/*create the BIFS track*/\n\tbifsT = gf_isom_new_track(mp4file, bifsID, GF_ISOM_MEDIA_SCENE, gf_isom_get_timescale(mp4file));\n\tif (!bifsT) return gf_isom_last_error(mp4file);\n\n\t_esd = gf_odf_desc_esd_new(SLPredef_MP4);\n\tif (!_esd) return GF_OUT_OF_MEM;\n\n\t_esd->decoderConfig->bufferSizeDB = 20;\n\t_esd->decoderConfig->objectTypeIndication = GF_CODECID_BIFS_V2;\n\t_esd->decoderConfig->streamType = GF_STREAM_SCENE;\n\t_esd->ESID = bifsID;\n\t_esd->OCRESID = 0;\n\n\t/*rewrite ISMA BIFS cfg*/\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t/*empty bifs stuff*/\n\tgf_bs_write_int(bs, 0, 17);\n\t/*command stream*/\n\tgf_bs_write_int(bs, 1, 1);\n\t/*in pixel metrics*/\n\tgf_bs_write_int(bs, 1, 1);\n\t/*with size*/\n\tgf_bs_write_int(bs, 1, 1);\n\tgf_bs_write_int(bs, w, 16);\n\tgf_bs_write_int(bs, h, 16);\n\tgf_bs_align(bs);\n\tgf_bs_get_content(bs, &_esd->decoderConfig->decoderSpecificInfo->data, &_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\tgf_isom_new_mpeg4_description(mp4file, bifsT, _esd, NULL, NULL, &descIndex);\n\tgf_odf_desc_del((GF_Descriptor *)_esd);\n\tgf_bs_del(bs);\n\tgf_isom_set_visual_info(mp4file, bifsT, descIndex, w, h);\n\n\tsamp = gf_isom_sample_new();\n\tsamp->CTS_Offset = 0;\n\tsamp->DTS = 0;\n\tswitch (bifs) {\n\tcase 1:\n\t\tif (is_image) {\n\t\t\tsamp->data = (char *) ISMA_BIFS_IMAGE;\n\t\t\tsamp->dataLength = 10;\n\t\t} else {\n\t\t\tsamp->data = (char *) ISMA_GF_BIFS_VIDEO;\n\t\t\tsamp->dataLength = 11;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif (is_image) {\n\t\t\tsamp->data = (char *) ISMA_BIFS_AI;\n\t\t\tsamp->dataLength = 15;\n\t\t} else {\n\t\t\tsamp->data = (char *) ISMA_BIFS_AV;\n\t\t\tsamp->dataLength = 16;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tsamp->data = (char *) ISMA_BIFS_AUDIO;\n\t\tsamp->dataLength = 8;\n\t\tbreak;\n\t}\n\n\tsamp->IsRAP = RAP;\n\n\tgf_isom_add_sample(mp4file, bifsT, 1, samp);\n\tsamp->data = NULL;\n\tgf_isom_sample_del(&samp);\n\tgf_isom_set_track_interleaving_group(mp4file, bifsT, 1);\n\n\tgf_isom_set_track_enabled(mp4file, bifsT, GF_TRUE);\n\tgf_isom_set_track_enabled(mp4file, odT, GF_TRUE);\n\tgf_isom_add_track_to_root_od(mp4file, bifsT);\n\tgf_isom_add_track_to_root_od(mp4file, odT);\n\n\tgf_isom_set_pl_indication(mp4file, GF_ISOM_PL_SCENE, 1);\n\tgf_isom_set_pl_indication(mp4file, GF_ISOM_PL_GRAPHICS, 1);\n\tgf_isom_set_pl_indication(mp4file, GF_ISOM_PL_OD, 1);\n\tgf_isom_set_pl_indication(mp4file, GF_ISOM_PL_AUDIO, audioPL);\n\tgf_isom_set_pl_indication(mp4file, GF_ISOM_PL_VISUAL, (u8) (is_image ? 0xFE : visualPL));\n\n\tgf_isom_set_brand_info(mp4file, GF_ISOM_BRAND_MP42, 1);\n\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_ISOM, GF_TRUE);\n\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP5, GF_TRUE);\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_media_make_3gpp(GF_ISOFile *mp4file)\n{\n\tu32 Tracks, i, mType, stype, nb_vid, nb_avc, nb_aud, nb_txt, nb_non_mp4, nb_dims;\n\tBool is_3g2 = 0;\n\n\tswitch (gf_isom_get_mode(mp4file)) {\n\tcase GF_ISOM_OPEN_EDIT:\n\tcase GF_ISOM_OPEN_WRITE:\n\tcase GF_ISOM_WRITE_EDIT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tTracks = gf_isom_get_track_count(mp4file);\n\tnb_vid = nb_aud = nb_txt = nb_avc = nb_non_mp4 = nb_dims = 0;\n\n\tfor (i=0; i<Tracks; i++) {\n\t\tgf_isom_remove_track_from_root_od(mp4file, i+1);\n\n\t\tmType = gf_isom_get_media_type(mp4file, i+1);\n\t\tstype = gf_isom_get_media_subtype(mp4file, i+1, 1);\n\t\tswitch (mType) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n        case GF_ISOM_MEDIA_AUXV:\n        case GF_ISOM_MEDIA_PICT:\n\t\t\t/*remove image tracks if wanted*/\n\t\t\tif (gf_isom_get_sample_count(mp4file, i+1)<=1) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[3GPP convert] Visual track ID %d: only one sample found\\n\", gf_isom_get_track_id(mp4file, i+1) ));\n\t\t\t\t//goto remove_track;\n\t\t\t}\n\n\t\t\tif (stype == GF_ISOM_SUBTYPE_MPEG4_CRYP) gf_isom_get_ismacryp_info(mp4file, i+1, 1, &stype, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\n\n\t\t\tswitch (stype) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tnb_vid++;\n\t\t\t\tnb_non_mp4 ++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t\t\tnb_vid++;\n\t\t\t\tnb_avc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\t{\n\t\t\t\tGF_ESD *esd = gf_isom_get_esd(mp4file, i+1, 1);\n\t\t\t\tu32 oti = (esd && esd->decoderConfig) ? esd->decoderConfig->objectTypeIndication : 0;\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\t\t/*both MPEG4-Video and H264/AVC/SVC are supported*/\n\t\t\t\tswitch (oti) {\n\t\t\t\tcase GF_CODECID_MPEG4_PART2:\n\t\t\t\tcase GF_CODECID_AVC:\n\t\t\t\tcase GF_CODECID_SVC:\n\t\t\t\tcase GF_CODECID_MVC:\n\t\t\t\t\tnb_vid++;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Video format not supported by 3GP - removing track ID %d\\n\", gf_isom_get_track_id(mp4file, i+1) ));\n\t\t\t\t\tgoto remove_track;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Video format not supported by 3GP - removing track ID %d\\n\", gf_isom_get_track_id(mp4file, i+1) ));\n\t\t\t\tgoto remove_track;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tif (stype == GF_ISOM_SUBTYPE_MPEG4_CRYP) gf_isom_get_ismacryp_info(mp4file, i+1, 1, &stype, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\n\t\t\tswitch (stype) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\tis_3g2 = 1;\n\t\t\t\tnb_aud++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\t\tnb_aud++;\n\t\t\t\tnb_non_mp4 ++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\t{\n\t\t\t\tGF_ESD *esd = gf_isom_get_esd(mp4file, i+1, 1);\n\t\t\t\tu32 oti = (esd && esd->decoderConfig) ? esd->decoderConfig->objectTypeIndication : 0;\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\n\t\t\t\tswitch (oti) {\n\t\t\t\tcase GF_CODECID_QCELP:\n\t\t\t\tcase GF_CODECID_EVRC:\n\t\t\t\tcase GF_CODECID_SMV:\n\t\t\t\t\tis_3g2 = 1;\n\t\t\t\tcase GF_CODECID_AAC_MPEG4:\n\t\t\t\t\tnb_aud++;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Audio format not supported by 3GP - removing track ID %d\\n\", gf_isom_get_track_id(mp4file, i+1) ));\n\t\t\t\t\tgoto remove_track;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Audio format not supported by 3GP - removing track ID %d\\n\", gf_isom_get_track_id(mp4file, i+1) ));\n\t\t\t\tgoto remove_track;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\t\tgf_isom_set_media_type(mp4file, i+1, GF_ISOM_MEDIA_TEXT);\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_MPEG_SUBT:\n\t\t\tnb_txt++;\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tif (stype == GF_ISOM_MEDIA_DIMS) {\n\t\t\t\tnb_dims++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t/*clean file*/\n\t\tdefault:\n\t\t\tif (mType==GF_ISOM_MEDIA_HINT) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Removing Hint track ID %d\\n\", gf_isom_get_track_id(mp4file, i+1) ));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Removing system track ID %d\\n\", gf_isom_get_track_id(mp4file, i+1) ));\n\t\t\t}\n\nremove_track:\n\t\t\tgf_isom_remove_track(mp4file, i+1);\n\t\t\ti -= 1;\n\t\t\tTracks = gf_isom_get_track_count(mp4file);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*no more IOD*/\n\tgf_isom_remove_root_od(mp4file);\n\n\tif (is_3g2) {\n\t\tgf_isom_set_brand_info(mp4file, GF_ISOM_BRAND_3G2A, 65536);\n\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP6, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP5, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GG6, GF_FALSE);\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Setting major brand to 3GPP2\\n\"));\n\t} else {\n\t\t/*update FType*/\n\t\tif ((nb_vid>1) || (nb_aud>1) || (nb_txt>1)) {\n\t\t\t/*3GPP general purpose*/\n\t\t\tgf_isom_set_brand_info(mp4file, GF_ISOM_BRAND_3GG6, 1024);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP6, GF_FALSE);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP5, GF_FALSE);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP4, GF_FALSE);\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Setting major brand to 3GPP Generic file\\n\"));\n\t\t} else if (nb_txt) {\n\t\t\tgf_isom_set_brand_info(mp4file, GF_ISOM_BRAND_3GP6, 1024);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP5, GF_TRUE);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP4, GF_TRUE);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GG6, GF_FALSE);\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Setting major brand to 3GPP V6 file\\n\"));\n\t\t} else if (nb_avc) {\n\t\t\tgf_isom_set_brand_info(mp4file, GF_ISOM_BRAND_3GP6, 0/*1024*/);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_AVC1, GF_TRUE);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP5, GF_FALSE);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP4, GF_FALSE);\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Setting major brand to 3GPP V6 file + AVC compatible\\n\"));\n\t\t} else {\n\t\t\tgf_isom_set_brand_info(mp4file, GF_ISOM_BRAND_3GP5, 0/*1024*/);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP6, 0);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GP4, GF_TRUE);\n\t\t\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_3GG6, GF_FALSE);\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[3GPP convert] Setting major brand to 3GPP V5 file\\n\"));\n\t\t}\n\t}\n\t/*add/remove MP4 brands and add isom*/\n\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_MP41, (u8) ((nb_avc||is_3g2||nb_non_mp4) ? GF_FALSE : GF_TRUE));\n\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_MP42, (u8) (nb_non_mp4 ? GF_FALSE : GF_TRUE));\n\tgf_isom_modify_alternate_brand(mp4file, GF_ISOM_BRAND_ISOM, GF_TRUE);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_media_make_psp(GF_ISOFile *mp4)\n{\n\tu32 i, count;\n\tu32 nb_a, nb_v;\n\t/*psp track UUID*/\n\tbin128 psp_track_uuid = {0x55, 0x53, 0x4D, 0x54, 0x21, 0xD2, 0x4F, 0xCE, 0xBB, 0x88, 0x69, 0x5C, 0xFA, 0xC9, 0xC7, 0x40};\n\tu8 psp_track_sig [] = {0x00, 0x00, 0x00, 0x1C, 0x4D, 0x54, 0x44, 0x54, 0x00, 0x01, 0x00, 0x12, 0x00, 0x00, 0x00, 0x0A, 0x55, 0xC4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00};\n\t/*psp mov UUID*/\n\t//bin128 psp_uuid = {0x50, 0x52, 0x4F, 0x46, 0x21, 0xD2, 0x4F, 0xCE, 0xBB, 0x88, 0x69, 0x5C, 0xFA, 0xC9, 0xC7, 0x40};\n\n\tnb_a = nb_v = 0;\n\tcount = gf_isom_get_track_count(mp4);\n\tfor (i=0; i<count; i++) {\n\t\tswitch (gf_isom_get_media_type(mp4, i+1)) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tnb_v++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tnb_a++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ((nb_v != 1) && (nb_a!=1)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PSP convert] Movies need one audio track and one video track\\n\" ));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tfor (i=0; i<count; i++) {\n\t\tswitch (gf_isom_get_media_type(mp4, i+1)) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\t/*if no edit list, add one*/\n\t\t\tif (!gf_isom_get_edits_count(mp4, i+1)) {\n\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample_info(mp4, i+1, 1, NULL, NULL);\n\t\t\t\tif (samp) {\n\t\t\t\t\tgf_isom_append_edit(mp4, i+1, gf_isom_get_track_duration(mp4, i+1), samp->CTS_Offset, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*add PSP UUID*/\n\t\t\tgf_isom_remove_uuid(mp4, i+1, psp_track_uuid);\n\t\t\tgf_isom_add_uuid(mp4, i+1, psp_track_uuid, (char *) psp_track_sig, 28);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[PSP convert] Removing track ID %d\\n\", gf_isom_get_track_id(mp4, i+1) ));\n\t\t\tgf_isom_remove_track(mp4, i+1);\n\t\t\ti -= 1;\n\t\t\tcount -= 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_isom_set_brand_info(mp4, GF_ISOM_BRAND_MSNV, 0);\n\tgf_isom_modify_alternate_brand(mp4, GF_ISOM_BRAND_MSNV, GF_TRUE);\n\treturn GF_OK;\n}\n\nGF_Err gf_media_get_color_info(GF_ISOFile *file, u32 track, u32 sampleDescriptionIndex, u32 *colour_type, u16 *colour_primaries, u16 *transfer_characteristics, u16 *matrix_coefficients, Bool *full_range_flag)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tu32 stype = gf_isom_get_media_subtype(file, track, sampleDescriptionIndex);\n\tif ((stype==GF_ISOM_SUBTYPE_AVC_H264)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_AVC2_H264)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_AVC3_H264)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_AVC4_H264)\n\t) {\n\t\tAVCState avc;\n\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(file, track, sampleDescriptionIndex);\n\t\tu32 i;\n\t\ts32 idx;\n\t\tGF_NALUFFParam *slc;\n\n\t\tmemset(&avc, 0, sizeof(AVCState));\n\t\tavc.sps_active_idx = -1;\n\n\t\ti=0;\n\t\twhile ((slc = (GF_NALUFFParam *)gf_list_enum(avcc->sequenceParameterSets, &i))) {\n\t\t\tidx = gf_avc_read_sps(slc->data, slc->size, &avc, 0, NULL);\n\n\t\t\tif (idx<0) continue;\n\t\t\tif (! avc.sps[idx].vui_parameters_present_flag )\n\t\t\t\tcontinue;\n\n\t\t\t*colour_type = avc.sps[idx].vui.video_format;\n\t\t\t*colour_primaries = avc.sps[idx].vui.colour_primaries;\n\t\t\t*transfer_characteristics = avc.sps[idx].vui.transfer_characteristics;\n\t\t\t*matrix_coefficients = avc.sps[idx].vui.matrix_coefficients;\n\t\t\t*full_range_flag = avc.sps[idx].vui.video_full_range_flag;\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tgf_odf_avc_cfg_del(avcc);\n\t\treturn GF_NOT_FOUND;\n\t}\n\tif ((stype==GF_ISOM_SUBTYPE_HEV1)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_HEV2)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_HVC1)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_HVC2)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_LHV1)\n\t\t\t|| (stype==GF_ISOM_SUBTYPE_LHE1)\n\t) {\n\t\tHEVCState hvc;\n\t\tGF_HEVCConfig *hvcc = gf_isom_hevc_config_get(file, track, sampleDescriptionIndex);\n\t\tu32 i;\n\t\tGF_NALUFFParamArray *pa;\n\n\t\tmemset(&hvc, 0, sizeof(HEVCState));\n\t\thvc.sps_active_idx = -1;\n\n\t\ti=0;\n\t\twhile ((pa = (GF_NALUFFParamArray *)gf_list_enum(hvcc->param_array, &i))) {\n\t\t\tGF_NALUFFParam *slc;\n\t\t\tu32 j;\n\t\t\ts32 idx;\n\t\t\tif (pa->type != GF_HEVC_NALU_SEQ_PARAM) continue;\n\n\t\t\tj=0;\n\t\t\twhile ((slc = (GF_NALUFFParam *)gf_list_enum(pa->nalus, &j))) {\n\t\t\t\tidx = gf_hevc_read_sps(slc->data, slc->size, &hvc);\n\n\t\t\t\tif (idx<0) continue;\n\t\t\t\tif (! hvc.sps[idx].vui_parameters_present_flag)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t*colour_type = hvc.sps[idx].video_format;\n\t\t\t\t*colour_primaries = hvc.sps[idx].colour_primaries;\n\t\t\t\t*transfer_characteristics = hvc.sps[idx].transfer_characteristic;\n\t\t\t\t*matrix_coefficients = hvc.sps[idx].matrix_coeffs;\n\t\t\t\t*full_range_flag = hvc.sps[idx].video_full_range_flag;\n\t\t\t\tgf_odf_hevc_cfg_del(hvcc);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t\tgf_odf_hevc_cfg_del(hvcc);\n\t\treturn GF_NOT_FOUND;\n\t}\n\tif (stype==GF_ISOM_SUBTYPE_AV01) {\n\t\tAV1State av1;\n\n\t\tgf_av1_init_state(&av1);\n\t\tav1.config = gf_isom_av1_config_get(file, track, sampleDescriptionIndex);\n\t\tif (av1.config) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<gf_list_count(av1.config->obu_array); i++) {\n\t\t\t\tGF_BitStream *bs;\n\t\t\t\tObuType obu_type = 0;\n\t\t\t\tu32 hdr_size = 0;\n\t\t\t\tu64 obu_size = 0;\n\t\t\t\tGF_AV1_OBUArrayEntry *obu = gf_list_get(av1.config->obu_array, i);\n\t\t\t\tbs = gf_bs_new(obu->obu, (u32) obu->obu_length, GF_BITSTREAM_READ);\n\t\t\t\tgf_av1_parse_obu(bs, &obu_type, &obu_size, &hdr_size, &av1);\n\t\t\t\tgf_bs_del(bs);\n\n\t\t\t\tif (av1.color_description_present_flag) {\n\t\t\t\t\t*colour_type = 0;\n\t\t\t\t\t*colour_primaries = av1.color_primaries;\n\t\t\t\t\t*transfer_characteristics = av1.transfer_characteristics;\n\t\t\t\t\t*matrix_coefficients = av1.matrix_coefficients;\n\t\t\t\t\t*full_range_flag = av1.color_range;\n\t\t\t\t\tif (av1.config) gf_odf_av1_cfg_del(av1.config);\n\t\t\t\t\tgf_av1_reset_state(&av1, GF_TRUE);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (av1.config) gf_odf_av1_cfg_del(av1.config);\n\t\tgf_av1_reset_state(&av1, GF_TRUE);\n\t\treturn GF_NOT_FOUND;\n\t}\n\n#endif\n\treturn GF_NOT_SUPPORTED;\n}\n\nGF_Err gf_isom_set_meta_qt(GF_ISOFile *file);\n\nGF_EXPORT\nGF_Err gf_media_check_qt_prores(GF_ISOFile *mp4)\n{\n\tu32 i, count, timescale, def_dur=0, video_tk=0;\n\tu32 prores_type = 0;\n\tGF_Err e;\n\tu32 colour_type=0;\n\tu16 colour_primaries=0, transfer_characteristics=0, matrix_coefficients=0;\n\tBool full_range_flag=GF_FALSE;\n\tu32 hspacing=0, vspacing=0;\n\tu32 nb_video_tracks;\n\tu32 target_ts = 0, w=0, h=0, chunk_size=0;\n\n\tnb_video_tracks = 0;\n\n\tcount = gf_isom_get_track_count(mp4);\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype = gf_isom_get_media_type(mp4, i+1);\n\t\tif (mtype!=GF_ISOM_MEDIA_VISUAL) continue;\n\t\tnb_video_tracks++;\n\t\tif (!video_tk)\n\t\t\tvideo_tk = i+1;\n\t}\n\n\tif ((nb_video_tracks==1) && video_tk) {\n\t\tu32 video_subtype = gf_isom_get_media_subtype(mp4, video_tk, 1);\n\t\tswitch (video_subtype) {\n\t\tcase GF_QT_SUBTYPE_APCH:\n\t\tcase GF_QT_SUBTYPE_APCO:\n\t\tcase GF_QT_SUBTYPE_APCN:\n\t\tcase GF_QT_SUBTYPE_APCS:\n\t\tcase GF_QT_SUBTYPE_AP4X:\n\t\tcase GF_QT_SUBTYPE_AP4H:\n\t\t\tprores_type=video_subtype;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[QTFF/ProRes] Adjusting %s compliancy\\n\", prores_type ? \"ProRes\" : \"QTFF\"));\n\n\t//adjust audio tracks\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype = gf_isom_get_media_type(mp4, i+1);\n\n\t\t//remove bitrate info (isobmff)\n\t\tgf_isom_update_bitrate(mp4, i+1, 1, 0, 0, 0);\n\n\t\tif (mtype==GF_ISOM_MEDIA_AUDIO) {\n\t\t\tu32 sr, nb_ch, bps;\n\t\t\tgf_isom_get_audio_info(mp4, i+1, 1, &sr, &nb_ch, &bps);\n\t\t\tgf_isom_set_audio_info(mp4, i+1, 1, sr, nb_ch, bps, GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF);\n\n\t\t\tgf_isom_hint_max_chunk_duration(mp4, i+1, gf_isom_get_media_timescale(mp4, i+1) / 2);\n\t\t\tcontinue;\n\t\t}\n\t}\n\t//make QT\n\tgf_isom_remove_root_od(mp4);\n\tif (gf_isom_get_mode(mp4) != GF_ISOM_OPEN_WRITE) {\n\t\tgf_isom_set_brand_info(mp4, GF_ISOM_BRAND_QT, 512);\n\t\tgf_isom_reset_alt_brands(mp4);\n\t} else {\n\t\tu32 brand, version;\n\t\tgf_isom_get_brand_info(mp4, &brand, &version, NULL);\n\t\tif (brand != GF_ISOM_BRAND_QT) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[ProRes] Cannot change brand from \\\"%s\\\" to \\\"qt  \\\", flat storage used. Try using different storage mode\\n\", gf_4cc_to_str(brand)));\n\t\t}\n\t}\n\n\tgf_isom_set_meta_qt(mp4);\n\n\tif (!video_tk) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[QTFF] No visual track\\n\"));\n\t\treturn GF_OK;\n\t}\n\n\tif (nb_video_tracks>1) {\n\t\tif (prores_type) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"QTFF] cannot adjust params to prores, %d video tracks present\\n\", nb_video_tracks));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[ProRes] no prores codec found but %d video tracks, not adjusting file\\n\", nb_video_tracks));\n\t\treturn GF_OK;\n\t}\n\n\tif (prores_type) {\n\t\tchar *comp_name = NULL;\n\t\tswitch (prores_type) {\n\t\tcase GF_QT_SUBTYPE_APCH: comp_name = \"\\x0013\"\"Apple ProRes 422 HQ\"; break;\n\t\tcase GF_QT_SUBTYPE_APCO: comp_name = \"\\x0016\"\"Apple ProRes 422 Proxy\"; break;\n\t\tcase GF_QT_SUBTYPE_APCN: comp_name = \"\\x0010\"\"Apple ProRes 422\"; break;\n\t\tcase GF_QT_SUBTYPE_APCS: comp_name = \"\\x0013\"\"Apple ProRes 422 LT\"; break;\n\t\tcase GF_QT_SUBTYPE_AP4X: comp_name = \"\\x0014\"\"Apple ProRes 4444 XQ\"; break;\n\t\tcase GF_QT_SUBTYPE_AP4H: comp_name = \"\\x0011\"\"Apple ProRes 4444\"; break;\n\t\t}\n\t\tgf_isom_update_video_sample_entry_fields(mp4, video_tk, 1, 0, GF_4CC('a','p','p','l'), 0, 0x3FF, 72<<16, 72<<16, 1, comp_name, -1);\n\t}\n\n\ttimescale = gf_isom_get_media_timescale(mp4, video_tk);\n\tdef_dur = gf_isom_get_constant_sample_duration(mp4, video_tk);\n\tif (!def_dur) {\n\t\tdef_dur = gf_isom_get_sample_duration(mp4, video_tk, 2);\n\t\tif (!def_dur) {\n\t\t\tdef_dur = gf_isom_get_sample_duration(mp4, video_tk, 1);\n\t\t}\n\t}\n\tif (!def_dur) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[ProRes] cannot estimate default sample duration for video track\\n\"));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tgf_isom_get_pixel_aspect_ratio(mp4, video_tk, 1, &hspacing, &vspacing);\n\t//force 1:1\n\tif ((hspacing<=1) || (vspacing<=1)) {\n\t\thspacing = vspacing = 1;\n\t\tgf_isom_set_pixel_aspect_ratio(mp4, video_tk, 1, 1, 1, GF_TRUE);\n\t}\n\n\t//patch enof/prof/clef\n\tif (prores_type) {\n\t\tgf_isom_update_aperture_info(mp4, video_tk, GF_FALSE);\n\t}\n\n\te = gf_isom_get_color_info(mp4, video_tk, 1, &colour_type, &colour_primaries, &transfer_characteristics, &matrix_coefficients, &full_range_flag);\n\tif (e==GF_NOT_FOUND) {\n\t\tcolour_primaries = transfer_characteristics = matrix_coefficients = 0;\n\t\tif (prores_type) {\n\t\t\tu32 di;\n\t\t\tGF_ISOSample *s = gf_isom_get_sample(mp4, video_tk, 1, &di);\n\t\t\tif (s && s->dataLength>24) {\n\t\t\t\tGF_BitStream *bs = gf_bs_new(s->data, s->dataLength, GF_BITSTREAM_READ);\n\t\t\t\tgf_bs_read_u32(bs); //frame size\n\t\t\t\tgf_bs_read_u32(bs); //frame ID\n\t\t\t\tgf_bs_read_u32(bs); //frame header size + reserved + bs version\n\t\t\t\tgf_bs_read_u32(bs); //encoder id\n\t\t\t\tgf_bs_read_u32(bs); //w and h\n\t\t\t\tgf_bs_read_u16(bs); //bunch of flags\n\t\t\t\tcolour_primaries = gf_bs_read_u8(bs);\n\t\t\t\ttransfer_characteristics = gf_bs_read_u8(bs);\n\t\t\t\tmatrix_coefficients = gf_bs_read_u8(bs);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t}\n\t\t\tgf_isom_sample_del(&s);\n\t\t} else {\n\t\t\te = gf_media_get_color_info(mp4, video_tk, 1, &colour_type, &colour_primaries, &transfer_characteristics, &matrix_coefficients, &full_range_flag);\n\t\t\tif (e)\n\t\t\t\tcolour_primaries=0;\n\t\t}\n\t\tif (!colour_primaries) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[ProRes] No color info present in visual track, defaulting to BT709\\n\"));\n\t\t\tcolour_primaries = 1;\n\t\t\ttransfer_characteristics = 1;\n\t\t\tmatrix_coefficients = 1;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[ProRes] No color info present in visual track, extracting from %s\\n\", prores_type ? \"first ProRes frame\" : \"sample description\"));\n\t\t}\n\t\tgf_isom_set_visual_color_info(mp4, video_tk, 1, GF_4CC('n','c','l','c'), colour_primaries, transfer_characteristics, matrix_coefficients, GF_FALSE, NULL, 0);\n\t} else if (e) {\n\t\treturn e;\n\t}\n\tgf_isom_get_visual_info(mp4, video_tk, 1, &w, &h);\n\n\tu32 ifps;\n\tDouble FPS = timescale;\n\tFPS /= def_dur;\n\tFPS *= 100;\n\tifps = (u32) FPS;\n\tif (ifps>= 2996 && ifps<=2998) target_ts = 30000;\t//29.97\n\telse if (ifps>= 2999 && ifps<=3001) target_ts = 3000; //30\n\telse if (ifps>= 2495 && ifps<=2505) target_ts = 2500; //25\n\telse if (ifps >= 2396 && ifps<=2398) target_ts = 24000; //23.97\n\telse if ((ifps>=2399) && (ifps<=2401)) target_ts = 2400; //24\n\telse if (ifps>= 4990 && ifps<=5010) target_ts = 5000; //50\n\telse if (ifps>= 5993 && ifps<=5995) target_ts = 60000; //59.94\n\telse if (ifps>= 5996 && ifps<=6004) target_ts = 6000; //60\n\n\tif (!target_ts) {\n\t\tif (prores_type) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[ProRes] Unrecognized frame rate %g\\n\", ((Double)timescale)/def_dur ));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t} else {\n\t\t\ttarget_ts = timescale;\n\t\t}\n\t}\n\n\tif (target_ts != timescale) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[ProRes] Adjusting timescale to %d\\n\", target_ts));\n\t\tgf_isom_set_media_timescale(mp4, video_tk, target_ts, 0, 0);\n\t}\n\tgf_isom_set_timescale(mp4, target_ts);\n\tif ((w<=720) && (h<=576)) chunk_size = 2000000;\n\telse chunk_size = 4000000;\n\n\tgf_isom_set_interleave_time(mp4, 500);\n\tgf_isom_hint_max_chunk_size(mp4, video_tk, chunk_size);\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_EXPORT\nGF_ESD *gf_media_map_esd(GF_ISOFile *mp4, u32 track, u32 stsd_idx)\n{\n\tGF_ESD *esd;\n\tu32 subtype;\n\n\tif (!stsd_idx) stsd_idx = 1;\n\tsubtype = gf_isom_get_media_subtype(mp4, track, stsd_idx);\n\t/*all types with an official MPEG-4 mapping*/\n\tswitch (subtype) {\n\tcase GF_ISOM_SUBTYPE_MPEG4:\n\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\tcase GF_ISOM_SUBTYPE_HVC1:\n\tcase GF_ISOM_SUBTYPE_HEV1:\n\tcase GF_ISOM_SUBTYPE_HVC2:\n\tcase GF_ISOM_SUBTYPE_HEV2:\n\tcase GF_ISOM_SUBTYPE_LHV1:\n\tcase GF_ISOM_SUBTYPE_LHE1:\n\tcase GF_ISOM_SUBTYPE_AV01:\n\tcase GF_ISOM_SUBTYPE_VP09:\n\tcase GF_ISOM_SUBTYPE_VP08:\n\tcase GF_ISOM_SUBTYPE_VVC1:\n\tcase GF_ISOM_SUBTYPE_VVI1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA2:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM2:\n\t\treturn gf_isom_get_esd(mp4, track, stsd_idx);\n\t}\n\n\tif (subtype == GF_ISOM_SUBTYPE_OPUS) {\n\t\tesd = gf_isom_get_esd(mp4, track, 1);\n\t\tif (!esd) return NULL;\n\t\tif (!esd->decoderConfig) {\n\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\treturn NULL;\n\t\t}\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_OPUS;\n\t\treturn esd;\n\t}\n\n\tif (subtype == GF_ISOM_SUBTYPE_3GP_DIMS) {\n\t\tGF_BitStream *bs;\n\t\tGF_DIMSDescription dims;\n\t\tesd = gf_odf_desc_esd_new(0);\n\t\tif (!esd) return NULL;\n\t\tesd->slConfig->timestampResolution = gf_isom_get_media_timescale(mp4, track);\n\t\tesd->ESID = gf_isom_get_track_id(mp4, track);\n\t\tesd->OCRESID = esd->ESID;\n\t\tesd->decoderConfig->streamType = GF_STREAM_SCENE;\n\t\t/*use private DSI*/\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_DIMS;\n\t\tgf_isom_get_dims_description(mp4, track, 1, &dims);\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t/*format ext*/\n\t\tgf_bs_write_u8(bs, dims.profile);\n\t\tgf_bs_write_u8(bs, dims.level);\n\t\tgf_bs_write_int(bs, dims.pathComponents, 4);\n\t\tgf_bs_write_int(bs, dims.fullRequestHost, 1);\n\t\tgf_bs_write_int(bs, dims.streamType, 1);\n\t\tgf_bs_write_int(bs, dims.containsRedundant, 2);\n\t\tgf_bs_write_data(bs, (char*)dims.textEncoding, (u32) strlen(dims.textEncoding)+1);\n\t\tgf_bs_write_data(bs, (char*)dims.contentEncoding, (u32) strlen(dims.contentEncoding)+1);\n\t\tgf_bs_get_content(bs, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_bs_del(bs);\n\t\treturn esd;\n\t}\n\tif (mp4->convert_streaming_text && ((subtype == GF_ISOM_SUBTYPE_TEXT) || (subtype == GF_ISOM_SUBTYPE_TX3G))\n\t) {\n\t\treturn gf_isom_get_esd(mp4, track, stsd_idx);\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nGF_ESD *gf_media_map_item_esd(GF_ISOFile *mp4, u32 item_id)\n{\n\tu32 item_type;\n\tu32 prot_scheme, prot_scheme_version;\n\tBool is_self_ref;\n\tconst char *name;\n\tconst char *mime;\n\tconst char *encoding;\n\tconst char *url;\n\tconst char *urn;\n\tGF_ESD *esd;\n\tGF_Err e;\n\n\tu32 item_idx = gf_isom_get_meta_item_by_id(mp4, GF_TRUE, 0, item_id);\n\tif (!item_idx) return NULL;\n\n\te = gf_isom_get_meta_item_info(mp4, GF_TRUE, 0, item_idx, &item_id, &item_type, &prot_scheme, &prot_scheme_version, &is_self_ref, &name, &mime, &encoding, &url, &urn);\n\tif (e != GF_OK) return NULL;\n\n\tif (item_type == GF_ISOM_SUBTYPE_HVC1) {\n\t\tGF_ImageItemProperties props;\n\t\tesd = gf_odf_desc_esd_new(0);\n\t\tif (!esd) return NULL;\n\n\t\tif (item_id > (1 << 16)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"Item ID greater than 16 bits, does not fit on ES ID\\n\"));\n\t\t}\n\t\tesd->ESID = (u16)item_id;\n\t\tesd->OCRESID = esd->ESID;\n\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_HEVC;\n\t\te = gf_isom_get_meta_image_props(mp4, GF_TRUE, 0, item_id, &props, NULL);\n\t\tif (e == GF_OK && props.config) {\n\t\t\tgf_odf_hevc_cfg_write(((GF_HEVCConfigurationBox *)props.config)->config, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t}\n\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;\n\t\tesd->slConfig->useTimestampsFlag = 1;\n\t\tesd->slConfig->timestampResolution = 1000;\n\t\treturn esd;\n\t}\n\n\tif (item_type == GF_ISOM_SUBTYPE_AVC_H264) {\n\t\tGF_ImageItemProperties props;\n\t\tesd = gf_odf_desc_esd_new(0);\n\t\tif (!esd) return NULL;\n\n\t\tif (item_id > (1 << 16)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"Item ID greater than 16 bits, does not fit on ES ID\\n\"));\n\t\t}\n\t\tesd->ESID = (u16)item_id;\n\t\tesd->OCRESID = esd->ESID;\n\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_AVC;\n\t\te = gf_isom_get_meta_image_props(mp4, GF_TRUE, 0, item_id, &props, NULL);\n\t\tif (e == GF_OK && props.config) {\n\t\t\tgf_odf_avc_cfg_write(((GF_AVCConfigurationBox *)props.config)->config, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t}\n\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;\n\t\tesd->slConfig->useTimestampsFlag = 1;\n\t\tesd->slConfig->timestampResolution = 1000;\n\t\treturn esd;\n\t}\n\n\tif (item_type == GF_ISOM_SUBTYPE_AV01) {\n\t\tGF_ImageItemProperties props;\n\t\tesd = gf_odf_desc_esd_new(0);\n\t\tif (!esd) return NULL;\n\t\tif (item_id > (1 << 16)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"Item ID greater than 16 bits, does not fit on ES ID\\n\"));\n\t\t}\n\t\tesd->ESID = (u16)item_id;\n\t\tesd->OCRESID = esd->ESID;\n\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_AV1;\n\t\te = gf_isom_get_meta_image_props(mp4, GF_TRUE, 0, item_id, &props, NULL);\n\t\tif (e == GF_OK && props.config) {\n\t\t\tgf_odf_av1_cfg_write( ((GF_AV1ConfigurationBox *)props.config)->config, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t}\n\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;\n\t\tesd->slConfig->useTimestampsFlag = 1;\n\t\tesd->slConfig->timestampResolution = 1000;\n\t\treturn esd;\n\t}\n\n\tif ((item_type == GF_ISOM_SUBTYPE_JPEG) || (mime && !strcmp(mime, \"image/jpeg\")) ){\n\t\tGF_ImageItemProperties props;\n\t\tesd = gf_odf_desc_esd_new(0);\n\t\tif (!esd) return NULL;\n\n\t\tif (item_id > (1 << 16)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"Item ID greater than 16 bits, does not fit on ES ID\\n\"));\n\t\t}\n\t\tesd->ESID = (u16)item_id;\n\t\tesd->OCRESID = esd->ESID;\n\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_JPEG;\n\t\te = gf_isom_get_meta_image_props(mp4, GF_TRUE, 0, item_id, &props, NULL);\n\t\tif (e == GF_OK && props.config) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"JPEG image item decoder config not supported, patch welcome\\n\"));\n\t\t}\n\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;\n\t\tesd->slConfig->useTimestampsFlag = 1;\n\t\tesd->slConfig->timestampResolution = 1000;\n\t\treturn esd;\n\t}\n\n\tif ((item_type == GF_ISOM_SUBTYPE_PNG) || (mime && !strcmp(mime, \"image/png\")) ){\n\t\tGF_ImageItemProperties props;\n\t\tesd = gf_odf_desc_esd_new(0);\n\t\tif (!esd) return NULL;\n\n\t\tif (item_id > (1 << 16)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"Item ID greater than 16 bits, does not fit on ES ID\\n\"));\n\t\t}\n\t\tesd->ESID = (u16)item_id;\n\t\tesd->OCRESID = esd->ESID;\n\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_PNG;\n\t\te = gf_isom_get_meta_image_props(mp4, GF_TRUE, 0, item_id, &props, NULL);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"Error fetching item properties %s\\n\", gf_error_to_string(e) ));\n\t\t}\n\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;\n\t\tesd->slConfig->useTimestampsFlag = 1;\n\t\tesd->slConfig->timestampResolution = 1000;\n\t\treturn esd;\n\t}\n\n\tif (item_type == GF_ISOM_SUBTYPE_VVC1) {\n\t\tGF_ImageItemProperties props;\n\t\tesd = gf_odf_desc_esd_new(0);\n\t\tif (!esd) return NULL;\n\n\t\tif (item_id > (1 << 16)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"Item ID greater than 16 bits, does not fit on ES ID\\n\"));\n\t\t}\n\t\tesd->ESID = (u16)item_id;\n\t\tesd->OCRESID = esd->ESID;\n\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_VVC;\n\t\te = gf_isom_get_meta_image_props(mp4, GF_TRUE, 0, item_id, &props, NULL);\n\t\tif (e == GF_OK && props.config) {\n\t\t\tgf_odf_vvc_cfg_write(((GF_VVCConfigurationBox *)props.config)->config, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t}\n\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;\n\t\tesd->slConfig->useTimestampsFlag = 1;\n\t\tesd->slConfig->timestampResolution = 1000;\n\t\treturn esd;\n\t}\n\tif ((item_type == GF_ISOM_SUBTYPE_UNCV) || (item_type == GF_ISOM_ITEM_TYPE_UNCI)) {\n\t\tGF_ImageItemProperties props;\n\t\tesd = gf_odf_desc_esd_new(0);\n\t\tif (!esd) return NULL;\n\n\t\tif (item_id > (1 << 16)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"Item ID greater than 16 bits, does not fit on ES ID\\n\"));\n\t\t}\n\t\tesd->ESID = (u16)item_id;\n\t\tesd->OCRESID = esd->ESID;\n\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_RAW;\n\t\tGF_List *other_props = gf_list_new();\n\t\te = gf_isom_get_meta_image_props(mp4, GF_TRUE, 0, item_id, &props, other_props);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\tif ((e == GF_OK) && gf_list_count(other_props)) {\n\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tgf_isom_box_array_write(NULL, other_props, bs);\n\t\t\tgf_bs_get_content(bs, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_bs_del(bs);\n\t\t}\n#endif // GPAC_DISABLE_ISOM_WRITE\n\t\tgf_list_del(other_props);\n\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;\n\t\tesd->slConfig->useTimestampsFlag = 1;\n\t\tesd->slConfig->timestampResolution = 1000;\n\t\treturn esd;\n\t}\n\n\n\treturn NULL;\n}\n\n#endif /*GPAC_DISABLE_ISOM*/\n\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\nstatic s32 gf_get_DQId(GF_ISOFile *file, u32 track)\n{\n\tGF_AVCConfig *svccfg;\n\tGF_ISOSample *samp;\n\tu32 di = 0, cur_extract_mode;\n\tchar *buffer;\n\tGF_BitStream *bs;\n\tu32 max_size = 4096;\n\tu32 size, nalu_size_length;\n\tu8 nal_type;\n\ts32 DQId=0;\n\n\tsamp = NULL;\n\tbs = NULL;\n\tcur_extract_mode = gf_isom_get_nalu_extract_mode(file, track);\n\tgf_isom_set_nalu_extract_mode(file, track, GF_ISOM_NALU_EXTRACT_INSPECT);\n\tbuffer = (char*)gf_malloc(sizeof(char) * max_size);\n\tsvccfg = gf_isom_svc_config_get(file, track, 1);\n\tif (!svccfg)\n\t{\n\t\tDQId = 0;\n\t\tgoto exit;\n\t}\n\tsamp = gf_isom_get_sample(file, track, 1, &di);\n\tif (!samp)\n\t{\n\t\tDQId = -1;\n\t\tgoto exit;\n\t}\n\tbs = gf_bs_new(samp->data, samp->dataLength, GF_BITSTREAM_READ);\n\tnalu_size_length = 8 * svccfg->nal_unit_size;\n\twhile (gf_bs_available(bs))\n\t{\n\t\tsize = gf_bs_read_int(bs, nalu_size_length);\n\t\tif (size>max_size) {\n\t\t\tbuffer = (char*)gf_realloc(buffer, sizeof(char)*size);\n\t\t\tmax_size = size;\n\t\t}\n\t\tgf_bs_read_data(bs, buffer, size);\n\t\tnal_type = buffer[0] & 0x1F;\n\t\tif (nal_type == GF_AVC_NALU_SVC_SLICE)\n\t\t{\n\t\t\tDQId = buffer[2] & 0x7F;\n\t\t\tgoto exit;\n\t\t}\n\t}\nexit:\n\tif (svccfg) gf_odf_avc_cfg_del(svccfg);\n\tif (samp) gf_isom_sample_del(&samp);\n\tif (buffer) gf_free(buffer);\n\tif (bs) gf_bs_del(bs);\n\tgf_isom_set_nalu_extract_mode(file, track, cur_extract_mode);\n\treturn DQId;\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\nstatic Bool gf_isom_has_svc_explicit(GF_ISOFile *file, u32 track)\n{\n\tGF_AVCConfig *svccfg;\n\tGF_NALUFFParam *slc;\n\tu32 i;\n\tu8 type;\n\tBool ret = 0;\n\n\tsvccfg = gf_isom_svc_config_get(file, track, 1);\n\tif (!svccfg)\n\t\treturn 0;\n\n\tfor (i = 0; i < gf_list_count(svccfg->sequenceParameterSets); i++)\n\t{\n\t\tslc = (GF_NALUFFParam *)gf_list_get(svccfg->sequenceParameterSets, i);\n\t\ttype = slc->data[0] & 0x1F;\n\t\tif (type == GF_AVC_NALU_SEQ_PARAM)\n\t\t{\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgf_odf_avc_cfg_del(svccfg);\n\treturn ret;\n}\n\n\nstatic u32 gf_isom_get_track_id_max(GF_ISOFile *file)\n{\n\tu32 num_track, i, trackID;\n\tu32 max_id = 0;\n\n\tnum_track = gf_isom_get_track_count(file);\n\tfor (i = 1; i <= num_track; i++)\n\t{\n\t\ttrackID = gf_isom_get_track_id(file, i);\n\t\tif (max_id < trackID)\n\t\t\tmax_id = trackID;\n\t}\n\n\treturn max_id;\n}\n#endif\n\n/* Split SVC layers */\nGF_EXPORT\nGF_Err gf_media_split_svc(GF_ISOFile *file, u32 track, Bool splitAll)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tGF_AVCConfig *svccfg, *cfg;\n\tu32 num_svc_track, num_sample, svc_track, dst_track, ref_trackID, ref_trackNum, max_id, di, width, height, size, nalu_size_length, i, j, t, max_size, num_pps, num_sps, num_subseq, NALUnitHeader, data_offset, data_length, count, timescale, cur_extract_mode;\n\tGF_Err e;\n\tGF_NALUFFParam *slc, *sl;\n\tAVCState avc;\n\ts32 sps_id, pps_id;\n\tGF_ISOSample *samp, *dst_samp;\n\tGF_BitStream *bs, *dst_bs;\n\tGF_BitStream ** sample_bs;\n\tu8 nal_type, track_ref_index;\n\tchar *buffer;\n\ts32 *sps_track, *sps, *pps;\n\tu64 offset;\n\tBool is_splitted;\n\tBool *first_sample_track, *is_subseq_pps;\n\tu64 *first_DTS_track;\n\ts8 sample_offset;\n\n\tmax_size = 4096;\n\te = GF_OK;\n\tsamp = dst_samp = NULL;\n\tbs = NULL;\n\tsample_bs = NULL;\n\tsps_track = sps = pps = NULL;\n\tfirst_DTS_track = NULL;\n\tfirst_sample_track = is_subseq_pps = NULL;\n\tbuffer = NULL;\n\tcfg = NULL;\n\tnum_svc_track=0;\n\tcur_extract_mode = gf_isom_get_nalu_extract_mode(file, track);\n\tgf_isom_set_nalu_extract_mode(file, track, GF_ISOM_NALU_EXTRACT_INSPECT);\n\tsvccfg = gf_isom_svc_config_get(file, track, 1);\n\tif (!svccfg)\n\t{\n\t\te = GF_OK;\n\t\tgoto exit;\n\t}\n\tnum_sps = gf_list_count(svccfg->sequenceParameterSets);\n\tif (!num_sps)\n\t{\n\t\te = GF_OK;\n\t\tgoto exit;\n\t}\n\tnum_pps = gf_list_count(svccfg->pictureParameterSets);\n\tif ((gf_isom_get_avc_svc_type(file, track, 1) == GF_ISOM_AVCTYPE_SVC_ONLY) && !gf_isom_has_svc_explicit(file, track))\n\t\tis_splitted = 1;\n\telse\n\t\tis_splitted = 0;\n\tnum_subseq = gf_isom_has_svc_explicit(file, track) ? num_sps - 1 : num_sps;\n\n\tif (is_splitted)\n\t{\n\t\t/*this track has only one SVC ...*/\n\t\tif (num_sps == 1)\n\t\t{\n\t\t\t/*use 'all' mode -> stop*/\n\t\t\tif (splitAll)\n\t\t\t\tgoto exit;\n\t\t\t/*use 'base' mode -> merge SVC tracks*/\n\t\t\telse\n\t\t\t{\n\t\t\t\te = gf_media_merge_svc(file, track, 0);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\t/*this file has been in 'splitbase' mode*/\n\t\telse if (!splitAll)\n\t\t\tgoto exit;\n\n\t}\n\n\ttimescale = gf_isom_get_media_timescale(file, track);\n\tnum_svc_track = splitAll ? num_subseq : 1;\n\tmax_id = gf_isom_get_track_id_max(file);\n\tdi = 0;\n\n\tmemset(&avc, 0, sizeof(AVCState));\n\tavc.sps_active_idx = -1;\n\tnalu_size_length = 8 * svccfg->nal_unit_size;\n\t/*read all sps, but we need only the subset sequence parameter sets*/\n\tsps =  (s32 *) gf_malloc(num_subseq * sizeof(s32));\n\tsps_track = (s32 *) gf_malloc(num_subseq * sizeof(s32));\n\tcount = 0;\n\tfor (i = 0; i < num_sps; i++)\n\t{\n\t\tslc = (GF_NALUFFParam *)gf_list_get(svccfg->sequenceParameterSets, i);\n\t\tnal_type = slc->data[0] & 0x1F;\n\t\tsps_id = gf_avc_read_sps(slc->data, slc->size, &avc, 0, NULL);\n\t\tif (sps_id < 0) {\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (nal_type == GF_AVC_NALU_SVC_SUBSEQ_PARAM)\n\t\t{\n\t\t\tsps[count] = sps_id;\n\t\t\tsps_track[count] = i;\n\t\t\tcount++;\n\t\t}\n\t}\n\t/*for testing*/\n\tassert(count == num_subseq);\n\t/*read all pps*/\n\tpps =  (s32 *) gf_malloc(num_pps * sizeof(s32));\n\tfor (j = 0; j < num_pps; j++)\n\t{\n\t\tslc = (GF_NALUFFParam *)gf_list_get(svccfg->pictureParameterSets, j);\n\t\tpps_id = gf_avc_read_pps(slc->data, slc->size, &avc);\n\t\tif (pps_id < 0) {\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tgoto exit;\n\t\t}\n\t\tpps[j] = pps_id;\n\t}\n\tif (!is_splitted)\n\t\tref_trackID = gf_isom_get_track_id(file, track);\n\telse\n\t{\n\t\tgf_isom_get_reference(file, track, GF_ISOM_REF_BASE, 1, &ref_trackNum);\n\t\tref_trackID = gf_isom_get_track_id(file, ref_trackNum);\n\t}\n\n\tbuffer = (char*)gf_malloc(sizeof(char) * max_size);\n\t/*read first sample for determinating the order of SVC tracks*/\n\tcount = 0;\n\tsamp = gf_isom_get_sample(file, track, 1, &di);\n\tif (!samp)\n\t{\n\t\te = gf_isom_last_error(file);\n\t\tgoto exit;\n\t}\n\tbs = gf_bs_new(samp->data, samp->dataLength, GF_BITSTREAM_READ);\n\toffset = 0;\n\tis_subseq_pps = (Bool *) gf_malloc(num_pps*sizeof(Bool));\n\tfor (i = 0; i < num_pps; i++)\n\t\tis_subseq_pps[i] = 0;\n\twhile (gf_bs_available(bs))\n\t{\n\t\tgf_bs_enable_emulation_byte_removal(bs, GF_FALSE);\n\t\tsize = gf_bs_read_int(bs, nalu_size_length);\n\t\tif (size>max_size) {\n\t\t\tbuffer = (char*)gf_realloc(buffer, sizeof(char)*size);\n\t\t\tmax_size = size;\n\t\t}\n\n\t\tgf_avc_parse_nalu(bs, &avc);\n\t\tnal_type = avc.last_nal_type_parsed;\n\n\t\te = gf_bs_seek(bs, offset+nalu_size_length/8);\n\t\tif (e)\n\t\t\tgoto exit;\n\t\tgf_bs_read_data(bs, buffer, size);\n\t\toffset += size + nalu_size_length/8;\n\t\tif (nal_type == GF_AVC_NALU_SVC_SLICE)\n\t\t{\n\t\t\tfor (i = 0; i < num_pps; i++)\n\t\t\t{\n\t\t\t\tif (avc.s_info.pps->id == pps[i])\n\t\t\t\t{\n\t\t\t\t\tis_subseq_pps[i] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((count > 0) && (avc.s_info.pps->sps_id == sps[count-1]))\n\t\t\t\tcontinue;\n\t\t\t/*verify the order of SPS, reorder if necessary*/\n\t\t\tif (avc.s_info.pps->sps_id != sps[count])\n\t\t\t{\n\t\t\t\tfor (i = count+1; i < num_subseq; i++)\n\t\t\t\t{\n\t\t\t\t\t/*swap two SPS*/\n\t\t\t\t\tif (avc.s_info.pps->sps_id == sps[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tsps[i] = sps[count];\n\t\t\t\t\t\tsps[count] = avc.s_info.pps->sps_id;\n\t\t\t\t\t\tsps_track[count] = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\tbs = NULL;\n\n\tgf_isom_sample_del(&samp);\n\tsamp = NULL;\n\n\tfor (t = 0; t < num_svc_track; t++)\n\t{\n\t\tsvc_track = gf_isom_new_track(file, t+1+max_id, GF_ISOM_MEDIA_VISUAL, timescale);\n\t\tif (!svc_track)\n\t\t{\n\t\t\te = gf_isom_last_error(file);\n\t\t\tgoto exit;\n\t\t}\n\t\tgf_isom_set_track_enabled(file, svc_track, GF_TRUE);\n\t\tgf_isom_set_track_reference(file, svc_track, GF_ISOM_REF_BASE, ref_trackID);\n\t\t//copy over edit list\n\t\tfor (i=0; i<gf_isom_get_edits_count(file, track); i++) {\n\t\t\tGF_ISOEditType emode;\n\t\t\tu64 etime, edur, mtime;\n\t\t\tgf_isom_get_edit(file, track, i+1, &etime, &edur, &mtime, &emode);\n\t\t\tgf_isom_set_edit(file, svc_track, etime, edur, mtime, emode);\n\t\t}\n\t\tcfg = gf_odf_avc_cfg_new();\n\t\tcfg->complete_representation = 1; //SVC\n\t\t/*this layer depends on the base layer and the lower layers*/\n\t\tgf_isom_set_track_reference(file, svc_track, GF_ISOM_REF_SCAL, ref_trackID);\n\t\tfor (i = 0; i < t; i++)\n\t\t\tgf_isom_set_track_reference(file, svc_track, GF_ISOM_REF_SCAL, i+1+max_id);\n\n\t\te = gf_isom_svc_config_new(file, svc_track, cfg, NULL, NULL, &di);\n\t\tif (e)\n\t\t\tgoto exit;\n\t\tif (splitAll)\n\t\t{\n\t\t\tsps_id = sps[t];\n\t\t\twidth = avc.sps[sps_id].width;\n\t\t\theight = avc.sps[sps_id].height;\n\t\t\tgf_isom_set_visual_info(file, svc_track, di, width, height);\n\t\t\tcfg->configurationVersion = 1;\n\t\t\tcfg->chroma_bit_depth = 8 + avc.sps[sps_id].chroma_bit_depth_m8;\n\t\t\tcfg->chroma_format = avc.sps[sps_id].chroma_format;\n\t\t\tcfg->luma_bit_depth = 8 + avc.sps[sps_id].luma_bit_depth_m8;\n\t\t\tcfg->profile_compatibility = avc.sps[sps_id].prof_compat;\n\t\t\tcfg->AVCLevelIndication = avc.sps[sps_id].level_idc;\n\t\t\tcfg->AVCProfileIndication = avc.sps[sps_id].profile_idc;\n\t\t\tcfg->nal_unit_size = svccfg->nal_unit_size;\n\t\t\tslc = (GF_NALUFFParam *)gf_list_get(svccfg->sequenceParameterSets, sps_track[t]);\n\t\t\tsl = (GF_NALUFFParam*)gf_malloc(sizeof(GF_NALUFFParam));\n\t\t\tsl->id = slc->id;\n\t\t\tsl->size = slc->size;\n\t\t\tsl->data = (char*)gf_malloc(sizeof(char)*sl->size);\n\t\t\tmemcpy(sl->data, slc->data, sizeof(char)*sl->size);\n\t\t\tgf_list_add(cfg->sequenceParameterSets, sl);\n\t\t\tfor (j = 0; j < num_pps; j++)\n\t\t\t{\n\t\t\t\tpps_id = pps[j];\n\t\t\t\tif (is_subseq_pps[j] && (avc.pps[pps_id].sps_id == sps_id))\n\t\t\t\t{\n\t\t\t\t\tslc = (GF_NALUFFParam *)gf_list_get(svccfg->pictureParameterSets, j);\n\t\t\t\t\tsl = (GF_NALUFFParam*)gf_malloc(sizeof(GF_NALUFFParam));\n\t\t\t\t\tsl->id = slc->id;\n\t\t\t\t\tsl->size = slc->size;\n\t\t\t\t\tsl->data = (char*)gf_malloc(sizeof(char)*sl->size);\n\t\t\t\t\tmemcpy(sl->data, slc->data, sizeof(char)*sl->size);\n\t\t\t\t\tgf_list_add(cfg->pictureParameterSets, sl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (i = 0; i < num_subseq; i++)\n\t\t\t{\n\t\t\t\tsps_id = sps[i];\n\t\t\t\twidth = avc.sps[sps_id].width;\n\t\t\t\theight = avc.sps[sps_id].height;\n\t\t\t\tgf_isom_set_visual_info(file, svc_track, di, width, height);\n\t\t\t\tcfg->configurationVersion = 1;\n\t\t\t\tcfg->chroma_bit_depth = 8 + avc.sps[sps_id].chroma_bit_depth_m8;\n\t\t\t\tcfg->chroma_format = avc.sps[sps_id].chroma_format;\n\t\t\t\tcfg->luma_bit_depth = 8 + avc.sps[sps_id].luma_bit_depth_m8;\n\t\t\t\tcfg->profile_compatibility = avc.sps[sps_id].prof_compat;\n\t\t\t\tcfg->AVCLevelIndication = avc.sps[sps_id].level_idc;\n\t\t\t\tcfg->AVCProfileIndication = avc.sps[sps_id].profile_idc;\n\t\t\t\tcfg->nal_unit_size = svccfg->nal_unit_size;\n\t\t\t\tslc = (GF_NALUFFParam *)gf_list_get(svccfg->sequenceParameterSets, sps_track[i]);\n\t\t\t\tsl = (GF_NALUFFParam*)gf_malloc(sizeof(GF_NALUFFParam));\n\t\t\t\tsl->id = slc->id;\n\t\t\t\tsl->size = slc->size;\n\t\t\t\tsl->data = (char*)gf_malloc(sizeof(char)*sl->size);\n\t\t\t\tmemcpy(sl->data, slc->data, sizeof(char)*sl->size);\n\t\t\t\tgf_list_add(cfg->sequenceParameterSets, sl);\n\t\t\t\tfor (j = 0; j < num_pps; j++)\n\t\t\t\t{\n\t\t\t\t\tpps_id = pps[j];\n\t\t\t\t\tif (avc.pps[pps_id].sps_id == sps_id)\n\t\t\t\t\t{\n\t\t\t\t\t\tslc = (GF_NALUFFParam *)gf_list_get(svccfg->pictureParameterSets, j);\n\t\t\t\t\t\tsl = (GF_NALUFFParam*)gf_malloc(sizeof(GF_NALUFFParam));\n\t\t\t\t\t\tsl->id = slc->id;\n\t\t\t\t\t\tsl->size = slc->size;\n\t\t\t\t\t\tsl->data = (char*)gf_malloc(sizeof(char)*sl->size);\n\t\t\t\t\t\tmemcpy(sl->data, slc->data, sizeof(char)*sl->size);\n\t\t\t\t\t\tgf_list_add(cfg->pictureParameterSets, sl);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\te = gf_isom_svc_config_update(file, svc_track, 1, cfg, 0);\n\t\tif (e)\n\t\t\tgoto exit;\n\t\tgf_odf_avc_cfg_del(cfg);\n\t\tcfg = NULL;\n\t}\n\n\tnum_sample = gf_isom_get_sample_count(file, track);\n\tfirst_sample_track = (Bool *) gf_malloc((num_svc_track+1) * sizeof(Bool));\n\tfor (t = 0; t <= num_svc_track; t++)\n\t\tfirst_sample_track[t] = 1;\n\tfirst_DTS_track = (u64 *) gf_malloc((num_svc_track+1) * sizeof(u64));\n\tfor (t = 0; t <= num_svc_track; t++)\n\t\tfirst_DTS_track[t] = 0;\n\tfor (i = 1; i <= num_sample; i++)\n\t{\n\t\t/*reset*/\n\t\tmemset(buffer, 0, max_size);\n\n\t\tsamp = gf_isom_get_sample(file, track, i, &di);\n\t\tif (!samp)\n\t\t{\n\t\t\te = GF_IO_ERR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* Create (num_svc_track) SVC bitstreams + 1 AVC bitstream*/\n\t\tsample_bs = (GF_BitStream **) gf_malloc(sizeof(GF_BitStream *) * (num_svc_track+1));\n\t\tfor (j = 0; j <= num_svc_track; j++)\n\t\t\tsample_bs[j] = (GF_BitStream *) gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t/*write extractor*/\n\t\tfor (t = 0; t < num_svc_track; t++)\n\t\t{\n\t\t\t//reference to base layer\n\t\t\tgf_bs_write_int(sample_bs[t+1], 14, nalu_size_length); // extractor 's size = 14\n\t\t\tNALUnitHeader = 0; //reset\n\t\t\tNALUnitHeader |= 0x1F000000; // NALU type = 31\n\t\t\tgf_bs_write_u32(sample_bs[t+1], NALUnitHeader);\n\t\t\ttrack_ref_index = (u8) gf_isom_has_track_reference(file, t+1+max_id, GF_ISOM_REF_SCAL, ref_trackID);\n\t\t\tif (!track_ref_index)\n\t\t\t{\n\t\t\t\te = GF_CORRUPTED_DATA;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tgf_bs_write_u8(sample_bs[t+1], track_ref_index);\n\t\t\tsample_offset = 0;\n\t\t\tgf_bs_write_u8(sample_bs[t+1], sample_offset);\n\t\t\tdata_offset = 0;\n\t\t\tgf_bs_write_u32(sample_bs[t+1], data_offset);\n\t\t\tdata_length = 0;\n\t\t\tgf_bs_write_u32(sample_bs[t+1], data_length);\n\t\t\t//reference to previous layer(s)\n\t\t\tfor (j = 0; j < t; j++)\n\t\t\t{\n\t\t\t\tgf_bs_write_int(sample_bs[t+1], 14, nalu_size_length);\n\t\t\t\tNALUnitHeader = 0;\n\t\t\t\tNALUnitHeader |= 0x1F000000;\n\t\t\t\tgf_bs_write_u32(sample_bs[t+1], NALUnitHeader);\n\t\t\t\ttrack_ref_index = (u8) gf_isom_has_track_reference(file, t+1+max_id, GF_ISOM_REF_SCAL, j+1+max_id);\n\t\t\t\tif (!track_ref_index)\n\t\t\t\t{\n\t\t\t\t\te = GF_CORRUPTED_DATA;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tgf_bs_write_u8(sample_bs[t+1], track_ref_index);\n\t\t\t\tsample_offset = 0;\n\t\t\t\tgf_bs_write_u8(sample_bs[t+1], sample_offset);\n\t\t\t\tdata_offset = (j+1) * (nalu_size_length/8 + 14); // (nalu_size_length/8) bytes of NALU length field + 14 bytes of extractor per layer\n\t\t\t\tgf_bs_write_u32(sample_bs[t+1], data_offset);\n\t\t\t\tdata_length = 0;\n\t\t\t\tgf_bs_write_u32(sample_bs[t+1], data_length);\n\t\t\t}\n\t\t}\n\n\t\tbs = gf_bs_new(samp->data, samp->dataLength, GF_BITSTREAM_READ);\n\t\toffset = 0;\n\t\twhile (gf_bs_available(bs))\n\t\t{\n\t\t\tgf_bs_enable_emulation_byte_removal(bs, GF_FALSE);\n\t\t\tsize = gf_bs_read_int(bs, nalu_size_length);\n\t\t\tif (size>max_size) {\n\t\t\t\tbuffer = (char*)gf_realloc(buffer, sizeof(char)*size);\n\t\t\t\tmax_size = size;\n\t\t\t}\n\n\t\t\tgf_avc_parse_nalu(bs, &avc);\n\t\t\tnal_type = avc.last_nal_type_parsed;\n\t\t\te = gf_bs_seek(bs, offset+nalu_size_length/8);\n\t\t\tif (e)\n\t\t\t\tgoto exit;\n\t\t\tgf_bs_read_data(bs, buffer, size);\n\t\t\toffset += size + nalu_size_length/8;\n\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\t\t\tpps_id = avc.last_ps_idx;\n\t\t\t\tj = 0;\n\t\t\t\tdst_track = 0;\n\t\t\t\twhile (j < num_pps)\n\t\t\t\t{\n\t\t\t\t\tif (pps_id == pps[j])\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif ((j < num_pps) && (is_subseq_pps[j]))\n\t\t\t\t{\n\t\t\t\t\tif (splitAll)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (t = 0; t < num_svc_track; t++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (sps[t] == avc.pps[pps_id].sps_id)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdst_track = t + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tdst_track = 1;\n\t\t\t\t}\n\t\t\t\tdst_bs = sample_bs[dst_track];\n\t\t\t\tbreak;\n\t\t\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\t\t\tsps_id = avc.last_ps_idx;\n\t\t\t\tdst_track = 0;\n\t\t\t\tif (splitAll)\n\t\t\t\t{\n\t\t\t\t\tfor (t = 0; t < num_svc_track; t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (sps[t] == sps_id)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdst_track = t + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tdst_track = 1;\n\t\t\t\tdst_bs = sample_bs[dst_track];\n\t\t\t\tbreak;\n\t\t\tcase GF_AVC_NALU_SVC_SLICE:\n\t\t\t\tdst_track = 0;\n\t\t\t\tif (splitAll)\n\t\t\t\t{\n\t\t\t\t\tfor (t = 0; t < num_svc_track; t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (sps[t] == (avc.s_info.pps)->sps_id)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdst_track = t + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tdst_track = 1;\n\t\t\t\tdst_bs = sample_bs[dst_track];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdst_bs = sample_bs[0];\n\t\t\t}\n\n\t\t\tgf_bs_write_int(dst_bs, size, nalu_size_length);\n\t\t\tgf_bs_write_data(dst_bs, buffer, size);\n\t\t}\n\n\t\tfor (j = 0; j <= num_svc_track; j++)\n\t\t{\n\t\t\tif (gf_bs_get_position(sample_bs[j]))\n\t\t\t{\n\t\t\t\tif (first_sample_track[j])\n\t\t\t\t{\n\t\t\t\t\tfirst_sample_track[j] = 0;\n\t\t\t\t\tfirst_DTS_track[j] = samp->DTS;\n\t\t\t\t}\n\t\t\t\tdst_samp = gf_isom_sample_new();\n\t\t\t\tdst_samp->CTS_Offset = samp->CTS_Offset;\n\t\t\t\tdst_samp->DTS = samp->DTS - first_DTS_track[j];\n\t\t\t\tdst_samp->IsRAP = samp->IsRAP;\n\t\t\t\tgf_bs_get_content(sample_bs[j], &dst_samp->data, &dst_samp->dataLength);\n\t\t\t\tif (j) //SVC\n\t\t\t\t\te = gf_isom_add_sample(file, track+j, di, dst_samp);\n\t\t\t\telse\n\t\t\t\t\te = gf_isom_update_sample(file, track, i, dst_samp, 1);\n\t\t\t\tif (e)\n\t\t\t\t\tgoto exit;\n\t\t\t\tgf_isom_sample_del(&dst_samp);\n\t\t\t\tdst_samp = NULL;\n\t\t\t}\n\t\t\tgf_bs_del(sample_bs[j]);\n\t\t\tsample_bs[j] = NULL;\n\t\t}\n\t\tgf_free(sample_bs);\n\t\tsample_bs = NULL;\n\t\tgf_bs_del(bs);\n\t\tbs = NULL;\n\t\tgf_isom_sample_del(&samp);\n\t\tsamp = NULL;\n\t}\n\n\t/*add Editlist entry if DTS of the first sample is not zero*/\n\tfor (t = 0; t <= num_svc_track; t++)\n\t{\n\t\tif (first_DTS_track[t])\n\t\t{\n\t\t\tu32 media_ts, moov_ts, ts_offset;\n\t\t\tu64 dur;\n\t\t\tmedia_ts = gf_isom_get_media_timescale(file, t);\n\t\t\tmoov_ts = gf_isom_get_timescale(file);\n\t\t\tts_offset = (u32)(first_DTS_track[t]) * moov_ts / media_ts;\n\t\t\tdur = gf_isom_get_media_duration(file, t) * moov_ts / media_ts;\n\t\t\tgf_isom_set_edit(file, t, 0, ts_offset, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\tgf_isom_set_edit(file, t, ts_offset, dur, 0, GF_ISOM_EDIT_NORMAL);\n\t\t}\n\t}\n\n\t/*if this is a merged file*/\n\tif (!is_splitted)\n\t{\n\t\t/*a normal stream: delete SVC config*/\n\t\tif (!gf_isom_has_svc_explicit(file, track))\n\t\t{\n\t\t\tgf_isom_svc_config_del(file, track, 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts32 shift=0;\n\n\t\t\tfor (i = 0; i < gf_list_count(svccfg->sequenceParameterSets); i++)\n\t\t\t{\n\t\t\t\tslc = (GF_NALUFFParam *)gf_list_get(svccfg->sequenceParameterSets, i);\n\t\t\t\tsps_id = gf_avc_read_sps(slc->data, slc->size, &avc, 0, NULL);\n\t\t\t\tif (sps_id < 0) {\n\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tnal_type = slc->data[0] & 0x1F;\n\t\t\t\tif (nal_type == GF_AVC_NALU_SVC_SUBSEQ_PARAM)\n\t\t\t\t{\n\t\t\t\t\tgf_list_rem(svccfg->sequenceParameterSets, i);\n\t\t\t\t\tgf_free(slc->data);\n\t\t\t\t\tgf_free(slc);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (j = 0; j < gf_list_count(svccfg->pictureParameterSets); j++)\n\t\t\t{\n\t\t\t\tslc = (GF_NALUFFParam *)gf_list_get(svccfg->pictureParameterSets, j);\n\t\t\t\tpps_id = gf_avc_read_pps(slc->data, slc->size, &avc);\n\t\t\t\tif (pps_id < 0) {\n\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tif (is_subseq_pps[j+shift])\n\t\t\t\t{\n\t\t\t\t\tgf_list_rem(svccfg->pictureParameterSets, j);\n\t\t\t\t\tgf_free(slc->data);\n\t\t\t\t\tgf_free(slc);\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t}\n\t\t\te = gf_isom_svc_config_update(file, track, 1, svccfg, 0);\n\t\t\tif (e)\n\t\t\t\tgoto exit;\n\t\t}\n\t}\n\t/*if this is as splitted file: delete this track*/\n\telse\n\t{\n\t\tgf_isom_remove_track(file, track);\n\t}\n\nexit:\n\tif (svccfg) gf_odf_avc_cfg_del(svccfg);\n\tif (cfg) gf_odf_avc_cfg_del(cfg);\n\tif (samp) gf_isom_sample_del(&samp);\n\tif (dst_samp) gf_isom_sample_del(&dst_samp);\n\tif (bs) gf_bs_del(bs);\n\tif (sample_bs)\n\t{\n\t\tfor (i = 0; i <= num_svc_track; i++)\n\t\t\tgf_bs_del(sample_bs[i]);\n\t\tgf_free(sample_bs);\n\t}\n\tif (sps_track) gf_free(sps_track);\n\tif (sps) gf_free(sps);\n\tif (pps) gf_free(pps);\n\tif (first_sample_track) gf_free(first_sample_track);\n\tif (first_DTS_track) gf_free(first_DTS_track);\n\tif (buffer) gf_free(buffer);\n\tif (is_subseq_pps) gf_free(is_subseq_pps);\n\tgf_isom_set_nalu_extract_mode(file, track, cur_extract_mode);\n\treturn e;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n\n}\n\n/* Merge SVC layers*/\nGF_EXPORT\nGF_Err gf_media_merge_svc(GF_ISOFile *file, u32 track, Bool mergeAll)\n{\n\tGF_AVCConfig *svccfg, *cfg;\n\tu32 merge_track,  num_track, num_sample, size, i, t, di, max_size, nalu_size_length, ref_trackNum, ref_trackID, count, width, height, nb_EditList, media_ts, moov_ts;\n\tGF_ISOSample *avc_samp, *samp, *dst_samp;\n\tGF_BitStream *bs, *dst_bs;\n\tGF_Err e;\n\tchar *buffer;\n\ts32 *DQId;\n\tu32 *list_track_sorted, *cur_sample, *max_sample;\n\tu64 *DTS_offset;\n\tu64 EditTime, SegmentDuration, MediaTime;\n\tGF_ISOEditType EditMode;\n\tu8 nal_type;\n\tBool first_sample;\n\tu64 first_DTS, offset, dur;\n\tGF_NALUFFParam *slc, *sl;\n\n\te = GF_OK;\n\tdi = 1;\n\tmax_size = 4096;\n\twidth = height = 0;\n\tavc_samp = samp = dst_samp = NULL;\n\tsvccfg = cfg = NULL;\n\tbuffer = NULL;\n\tbs = dst_bs = NULL;\n\tDQId = NULL;\n\tlist_track_sorted = cur_sample = max_sample = NULL;\n\tDTS_offset = NULL;\n\n\tif (gf_isom_get_avc_svc_type(file, track, 1) == GF_ISOM_AVCTYPE_AVC_SVC)\n\t\tgoto exit;\n\n\tnum_track = gf_isom_get_track_count(file);\n\tif (num_track == 1)\n\t\tgoto exit;\n\tgf_isom_get_reference(file, track, GF_ISOM_REF_BASE, 1, &ref_trackNum);\n\tref_trackID = gf_isom_get_track_id(file, ref_trackNum);\n\tif (!ref_trackID)\n\t{\n\t\te = GF_ISOM_INVALID_MEDIA;\n\t\tgoto exit;\n\t}\n\n\tlist_track_sorted = (u32 *) gf_malloc(num_track * sizeof(u32));\n\tmemset(list_track_sorted, 0, num_track * sizeof(u32));\n\tDQId = (s32 *) gf_malloc(num_track * sizeof(s32));\n\tmemset(DQId, 0, num_track * sizeof(s32));\n\tcount = 0;\n\tfor (t = 1; t <= num_track; t++) {\n\t\tu32 pos = 0;\n\t\ts32 track_DQId = gf_get_DQId(file, t);\n\t\tif (track_DQId < 0) {\n\t\t\te = GF_ISOM_INVALID_MEDIA;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (!gf_isom_has_track_reference(file, t, GF_ISOM_REF_BASE, ref_trackID))\n\t\t{\n\t\t\tif (t != ref_trackNum) continue;\n\t\t\telse if (!mergeAll) continue;\n\t\t}\n\n\t\twhile ((pos < count ) && (DQId[pos] <= track_DQId))\n\t\t\tpos++;\n\t\tfor (i = count; i > pos; i--)\n\t\t{\n\t\t\tlist_track_sorted[i] = list_track_sorted[i-1];\n\t\t\tDQId[i] = DQId[i-1];\n\t\t}\n\t\tlist_track_sorted[pos] = t;\n\t\tDQId[pos] = track_DQId;\n\t\tcount++;\n\t}\n\n\tmerge_track = list_track_sorted[0];\n\tgf_isom_set_track_enabled(file, merge_track, GF_TRUE);\n\t/*rewrite svccfg*/\n\tsvccfg = gf_odf_avc_cfg_new();\n\tsvccfg->complete_representation = 1;\n\t/*rewrite visual info*/\n\tif (!mergeAll)\n\t{\n\t\tfor (t = 0; t < count; t++)\n\t\t\tgf_isom_get_visual_info(file, list_track_sorted[t], 1, &width, &height);\n\t\tgf_isom_set_visual_info(file, merge_track, 1, width, height);\n\t}\n\n\tfor (t = 0; t < count; t++)\n\t{\n\t\tcfg = gf_isom_svc_config_get(file, list_track_sorted[t], 1);\n\t\tif (!cfg)\n\t\t\tcontinue;\n\t\tsvccfg->configurationVersion = 1;\n\t\tsvccfg->chroma_bit_depth = cfg->chroma_bit_depth;\n\t\tsvccfg->chroma_format = cfg->chroma_format;\n\t\tsvccfg->luma_bit_depth = cfg->luma_bit_depth;\n\t\tsvccfg->profile_compatibility = cfg->profile_compatibility;\n\t\tsvccfg->AVCLevelIndication = cfg->AVCLevelIndication;\n\t\tsvccfg->AVCProfileIndication = cfg->AVCProfileIndication;\n\t\tsvccfg->nal_unit_size = cfg->nal_unit_size;\n\t\tfor (i = 0; i < gf_list_count(cfg->sequenceParameterSets); i++)\n\t\t{\n\t\t\tslc = (GF_NALUFFParam *)gf_list_get(cfg->sequenceParameterSets, i);\n\t\t\tsl = (GF_NALUFFParam*)gf_malloc(sizeof(GF_NALUFFParam));\n\t\t\tsl->id = slc->id;\n\t\t\tsl->size = slc->size;\n\t\t\tsl->data = (char*)gf_malloc(sizeof(char)*sl->size);\n\t\t\tmemcpy(sl->data, slc->data, sizeof(char)*sl->size);\n\t\t\tgf_list_add(svccfg->sequenceParameterSets, sl);\n\t\t}\n\t\tfor (i = 0; i < gf_list_count(cfg->pictureParameterSets); i++)\n\t\t{\n\t\t\tslc = (GF_NALUFFParam *)gf_list_get(cfg->pictureParameterSets, i);\n\t\t\tsl = (GF_NALUFFParam*)gf_malloc(sizeof(GF_NALUFFParam));\n\t\t\tsl->id = slc->id;\n\t\t\tsl->size = slc->size;\n\t\t\tsl->data = (char*)gf_malloc(sizeof(char)*sl->size);\n\t\t\tmemcpy(sl->data, slc->data, sizeof(char)*sl->size);\n\t\t\tgf_list_add(svccfg->pictureParameterSets, sl);\n\t\t}\n\t\tif (mergeAll)\n\t\t{\n\t\t\tgf_isom_svc_config_update(file, merge_track, 1, svccfg, 1);\n\t\t}\n\t\telse\n\t\t\tgf_isom_svc_config_update(file, merge_track, 1, svccfg, 0);\n\t\tgf_odf_avc_cfg_del(cfg);\n\t\tcfg = NULL;\n\t}\n\n\tcur_sample = (u32 *) gf_malloc(count * sizeof(u32));\n\tmax_sample = (u32 *) gf_malloc(count * sizeof(u32));\n\tfor (t = 0; t < count; t++)\n\t{\n\t\tcur_sample[t] = 1;\n\t\tmax_sample[t] = gf_isom_get_sample_count(file, list_track_sorted[t]);\n\t}\n\n\tDTS_offset = (u64 *) gf_malloc(count * sizeof(u64));\n\tfor (t = 0; t < count; t++) {\n\t\tDTS_offset[t] = 0;\n\t\tnb_EditList = gf_isom_get_edits_count(file, list_track_sorted[t]);\n\t\tif (nb_EditList) {\n\t\t\tmedia_ts = gf_isom_get_media_timescale(file, list_track_sorted[t]);\n\t\t\tmoov_ts = gf_isom_get_timescale(file);\n\t\t\tfor (i = 1; i <= nb_EditList; i++) {\n\t\t\t\te = gf_isom_get_edit(file, list_track_sorted[t], i, &EditTime, &SegmentDuration, &MediaTime, &EditMode);\n\t\t\t\tif (e) goto exit;\n\n\t\t\t\tif (!EditMode) {\n\t\t\t\t\tDTS_offset[t] = SegmentDuration * media_ts / moov_ts;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tnum_sample = gf_isom_get_sample_count(file, ref_trackNum);\n\tnalu_size_length = 8 * svccfg->nal_unit_size;\n\tfirst_sample = 1;\n\tfirst_DTS = 0;\n\tbuffer = (char*)gf_malloc(sizeof(char) * max_size);\n\tfor (t = 1; t <= num_track; t++)\n\t\tgf_isom_set_nalu_extract_mode(file, t, GF_ISOM_NALU_EXTRACT_INSPECT);\n\tfor (i = 1; i <= num_sample; i++)\n\t{\n\t\tdst_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t/*add extractor if nessassary*/\n\t\tif (!mergeAll)\n\t\t{\n\t\t\tu32 NALUnitHeader = 0;\n\t\t\tu8 track_ref_index;\n\t\t\ts8 sample_offset;\n\t\t\tu32 data_offset;\n\t\t\tu32 data_length;\n\n\t\t\tgf_bs_write_int(dst_bs, 14, nalu_size_length); // extractor 's size = 14\n\t\t\tNALUnitHeader |= 0x1F000000; // NALU type = 31\n\t\t\tgf_bs_write_u32(dst_bs, NALUnitHeader);\n\t\t\ttrack_ref_index = (u8) gf_isom_has_track_reference(file, merge_track, GF_ISOM_REF_SCAL, ref_trackID);\n\t\t\tif (!track_ref_index)\n\t\t\t{\n\t\t\t\te = GF_CORRUPTED_DATA;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tgf_bs_write_u8(dst_bs, track_ref_index);\n\t\t\tsample_offset = 0;\n\t\t\tgf_bs_write_u8(dst_bs, sample_offset);\n\t\t\tdata_offset = 0;\n\t\t\tgf_bs_write_u32(dst_bs, data_offset);\n\t\t\tdata_length = 0;\n\t\t\tgf_bs_write_u32(dst_bs, data_length);\n\t\t}\n\n\t\tavc_samp = gf_isom_get_sample(file, ref_trackNum, i, &di);\n\t\tif (!avc_samp) {\n\t\t\te = gf_isom_last_error(file);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tfor (t = 0; t < count; t++)\n\t\t{\n\t\t\tif (cur_sample[t] > max_sample[t])\n\t\t\t\tcontinue;\n\t\t\tsamp = gf_isom_get_sample(file, list_track_sorted[t], cur_sample[t], &di);\n\t\t\tif (!samp) {\n\t\t\t\te = gf_isom_last_error(file);\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tif ((samp->DTS + DTS_offset[t]) != avc_samp->DTS) {\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\tsamp = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbs = gf_bs_new(samp->data, samp->dataLength, GF_BITSTREAM_READ);\n\t\t\t/*reset*/\n\t\t\tmemset(buffer, 0, sizeof(char) * max_size);\n\t\t\twhile (gf_bs_available(bs))\n\t\t\t{\n\t\t\t\tsize = gf_bs_read_int(bs, nalu_size_length);\n\t\t\t\tif (size>max_size) {\n\t\t\t\t\tbuffer = (char*)gf_realloc(buffer, sizeof(char)*size);\n\t\t\t\t\tmax_size = size;\n\t\t\t\t}\n\t\t\t\tgf_bs_read_data(bs, buffer, size);\n\t\t\t\tnal_type = buffer[0] & 0x1F;\n\t\t\t\t/*skip extractor*/\n\t\t\t\tif (nal_type == GF_AVC_NALU_FF_EXTRACTOR)\n\t\t\t\t\tcontinue;\n\t\t\t\t/*copy to new bitstream*/\n\t\t\t\tgf_bs_write_int(dst_bs, size, nalu_size_length);\n\t\t\t\tgf_bs_write_data(dst_bs, buffer, size);\n\t\t\t}\n\t\t\tgf_bs_del(bs);\n\t\t\tbs = NULL;\n\t\t\tgf_isom_sample_del(&samp);\n\t\t\tsamp = NULL;\n\t\t\tcur_sample[t]++;\n\t\t}\n\n\t\t/*add sapmle to track*/\n\t\tif (gf_bs_get_position(dst_bs))\n\t\t{\n\t\t\tif (first_sample)\n\t\t\t{\n\t\t\t\tfirst_DTS = avc_samp->DTS;\n\t\t\t\tfirst_sample = 0;\n\t\t\t}\n\t\t\tdst_samp = gf_isom_sample_new();\n\t\t\tdst_samp->CTS_Offset = avc_samp->CTS_Offset;\n\t\t\tdst_samp->DTS = avc_samp->DTS - first_DTS;\n\t\t\tdst_samp->IsRAP = avc_samp->IsRAP;\n\t\t\tgf_bs_get_content(dst_bs, &dst_samp->data, &dst_samp->dataLength);\n\t\t\te = gf_isom_update_sample(file, merge_track, i, dst_samp, 1);\n\t\t\tif (e)\n\t\t\t\tgoto exit;\n\t\t}\n\t\tgf_isom_sample_del(&avc_samp);\n\t\tavc_samp = NULL;\n\t\tgf_bs_del(dst_bs);\n\t\tdst_bs = NULL;\n\t\tgf_isom_sample_del(&dst_samp);\n\t\tdst_samp = NULL;\n\t}\n\n\t/*Add EditList if nessessary*/\n\tif (!first_DTS)\n\t{\n\t\tmedia_ts = gf_isom_get_media_timescale(file, merge_track);\n\t\tmoov_ts = gf_isom_get_timescale(file);\n\t\toffset = (u32)(first_DTS) * moov_ts / media_ts;\n\t\tdur = gf_isom_get_media_duration(file, merge_track) * moov_ts / media_ts;\n\t\tgf_isom_set_edit(file, merge_track, 0, offset, 0, GF_ISOM_EDIT_EMPTY);\n\t\tgf_isom_set_edit(file, merge_track, offset, dur, 0, GF_ISOM_EDIT_NORMAL);\n\t}\n\n\t/*Delete SVC track(s) that references to ref_track*/\n\tfor (t = 1; t <= num_track; t++)\n\t{\n\t\tif (gf_isom_has_track_reference(file, t, GF_ISOM_REF_BASE, ref_trackID) && (t != merge_track))\n\t\t{\n\t\t\tgf_isom_remove_track(file, t);\n\t\t\tnum_track--; //we removed one track from file\n\t\t\tt--;\n\t\t}\n\t}\n\nexit:\n\tif (avc_samp) gf_isom_sample_del(&avc_samp);\n\tif (samp) gf_isom_sample_del(&samp);\n\tif (dst_samp) gf_isom_sample_del(&dst_samp);\n\tif (svccfg) gf_odf_avc_cfg_del(svccfg);\n\tif (cfg) gf_odf_avc_cfg_del(cfg);\n\tif (bs) gf_bs_del(bs);\n\tif (dst_bs) gf_bs_del(dst_bs);\n\tif (buffer) gf_free(buffer);\n\tif (DQId) gf_free(DQId);\n\tif (list_track_sorted) gf_free(list_track_sorted);\n\tif (cur_sample) gf_free(cur_sample);\n\tif (max_sample) gf_free(max_sample);\n\tif (DTS_offset) gf_free(DTS_offset);\n\tfor (t = 1; t <= gf_isom_get_track_count(file); t++)\n\t\tgf_isom_set_nalu_extract_mode(file, t, GF_ISOM_NALU_EXTRACT_DEFAULT);\n\treturn e;\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\n/* Split LHVC layers */\nstatic GF_NALUFFParamArray *alloc_hevc_param_array(GF_HEVCConfig *hevc_cfg, u8 type)\n{\n\tGF_NALUFFParamArray *ar;\n\tu32 i, count = hevc_cfg->param_array ? gf_list_count(hevc_cfg->param_array) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tar = gf_list_get(hevc_cfg->param_array, i);\n\t\tif (ar->type==type) return ar;\n\t}\n\tGF_SAFEALLOC(ar, GF_NALUFFParamArray);\n\tif (!ar) return NULL;\n\tar->nalus = gf_list_new();\n\tar->type = type;\n\tif (ar->type == GF_HEVC_NALU_VID_PARAM)\n\t\tgf_list_insert(hevc_cfg->param_array, ar, 0);\n\telse\n\t\tgf_list_add(hevc_cfg->param_array, ar);\n\treturn ar;\n}\n\ntypedef struct{\n\tu8 layer_id_plus_one;\n\tu8 min_temporal_id;\n\tu8 max_temporal_id;\n} LInfo;\n\ntypedef struct\n{\n\tu32 track_num;\n\tu32 layer_id;\n\tGF_HEVCConfig *lhvccfg;\n\tGF_BitStream *bs;\n\tu32 data_offset, data_size;\n\tu32 temporal_id_sample, max_temporal_id_sample;\n\tLInfo layers[64];\n\tu32 width, height;\n\tBool has_samples;\n\tBool non_tsa_vcl;\n} LHVCTrackInfo;\n\n\nGF_EXPORT\nGF_Err gf_media_filter_hevc(GF_ISOFile *file, u32 track, u8 max_temporal_id_plus_one, u8 max_layer_id_plus_one)\n{\n\tGF_HEVCConfig *hevccfg, *lhvccfg;\n\tu32 i, count, cur_extract_mode;\n\tchar *nal_data=NULL;\n\tu32 nal_alloc_size, nalu_size;\n\tGF_Err e = GF_OK;\n\n\tif (!max_temporal_id_plus_one && !max_layer_id_plus_one)\n\t\treturn GF_OK;\n\n\thevccfg = gf_isom_hevc_config_get(file, track, 1);\n\tlhvccfg = gf_isom_lhvc_config_get(file, track, 1);\n\tif (!hevccfg && !lhvccfg)\n\t\tnalu_size = 4;\n\telse\n\t\tnalu_size = hevccfg ? hevccfg->nal_unit_size : lhvccfg->nal_unit_size;\n\n\tcur_extract_mode = gf_isom_get_nalu_extract_mode(file, track);\n\tgf_isom_set_nalu_extract_mode(file, track, GF_ISOM_NALU_EXTRACT_INSPECT);\n\n\tnal_alloc_size = 10000;\n\tnal_data = gf_malloc(sizeof(char) * nal_alloc_size);\n\n\tif (hevccfg) {\n\t\tcount = gf_list_count(hevccfg->param_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 j, count2;\n\t\t\tGF_NALUFFParamArray *ar = (GF_NALUFFParamArray *)gf_list_get(hevccfg->param_array, i);\n\t\t\tcount2 = gf_list_count(ar->nalus);\n\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(ar->nalus, j);\n\t\t\t\t//u8 nal_type = (sl->data[0] & 0x7E) >> 1;\n\t\t\t\tu8 layer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3);\n\t\t\t\tu8 temporal_id_plus_one = sl->data[1] & 0x07;\n\n\t\t\t\tif ((max_temporal_id_plus_one && (temporal_id_plus_one > max_temporal_id_plus_one)) || (max_layer_id_plus_one && (layer_id+1 > max_layer_id_plus_one))) {\n\t\t\t\t\tgf_list_rem(ar->nalus, j);\n\t\t\t\t\tj--;\n\t\t\t\t\tcount2--;\n\t\t\t\t\tgf_free(sl->data);\n\t\t\t\t\tgf_free(sl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (lhvccfg) {\n\t\tcount = gf_list_count(lhvccfg->param_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 j, count2;\n\t\t\tGF_NALUFFParamArray *ar = (GF_NALUFFParamArray *)gf_list_get(lhvccfg->param_array, i);\n\t\t\tcount2 = gf_list_count(ar->nalus);\n\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(ar->nalus, j);\n\t\t\t\t//u8 nal_type = (sl->data[0] & 0x7E) >> 1;\n\t\t\t\tu8 layer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3);\n\t\t\t\tu8 temporal_id_plus_one = sl->data[1] & 0x07;\n\n\t\t\t\tif ((max_temporal_id_plus_one && (temporal_id_plus_one > max_temporal_id_plus_one)) || (max_layer_id_plus_one && (layer_id+1 > max_layer_id_plus_one))) {\n\t\t\t\t\tgf_list_rem(ar->nalus, j);\n\t\t\t\t\tj--;\n\t\t\t\t\tcount2--;\n\t\t\t\t\tgf_free(sl->data);\n\t\t\t\t\tgf_free(sl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//parse all samples\n\tcount = gf_isom_get_sample_count(file, track);\n\tfor (i=0; i<count; i++) {\n\t\tGF_BitStream *bs, *dst_bs;\n\t\tu32 di;\n\t\tGF_ISOSample *sample;\n\n\t\tsample = gf_isom_get_sample(file, track, i+1, &di);\n\n\t\tbs = gf_bs_new(sample->data, sample->dataLength, GF_BITSTREAM_READ);\n\t\tdst_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\twhile (gf_bs_available(bs)) {\n\t\t\tu32 size = gf_bs_read_int(bs, nalu_size*8);\n\t\t\tu8 fzero = gf_bs_read_int(bs, 1);\n\t\t\tu8 nal_type = gf_bs_read_int(bs, 6);\n\t\t\tu8 layer_id = gf_bs_read_int(bs, 6);\n\t\t\tu8 temporal_id_plus_one = gf_bs_read_int(bs, 3);\n\t\t\tsize -= 2;\n\n\t\t\tif ((max_temporal_id_plus_one && (temporal_id_plus_one > max_temporal_id_plus_one))\n\t\t\t\t|| (max_layer_id_plus_one && (layer_id+1 > max_layer_id_plus_one))\n\t\t\t) {\n\t\t\t\tgf_bs_skip_bytes(bs, size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (size>nal_alloc_size) {\n\t\t\t\tnal_alloc_size = size;\n\t\t\t\tnal_data = (char *)gf_realloc(nal_data, nal_alloc_size);\n\t\t\t}\n\t\t\tgf_bs_read_data(bs, nal_data, size);\n\n\t\t\tgf_bs_write_int(dst_bs, size+2, nalu_size*8);\n\t\t\tgf_bs_write_int(dst_bs, fzero, 1);\n\t\t\tgf_bs_write_int(dst_bs, nal_type, 6);\n\t\t\tgf_bs_write_int(dst_bs, layer_id, 6);\n\t\t\tgf_bs_write_int(dst_bs, temporal_id_plus_one, 3);\n\t\t\tgf_bs_write_data(dst_bs, nal_data, size);\n\t\t}\n\n\t\tgf_bs_del(bs);\n\t\tgf_free(sample->data);\n\t\tsample->data = NULL;\n\t\tsample->dataLength = 0;\n\n\t\tgf_bs_get_content(dst_bs, &sample->data, &sample->dataLength);\n\t\te = gf_isom_update_sample(file, track, i+1, sample, GF_TRUE);\n\t\tgf_bs_del(dst_bs);\n\t\tgf_isom_sample_del(&sample);\n\n\t\tif (e)\n\t\t\tgoto exit;\n\t}\n\nexit:\n\tif (lhvccfg) gf_odf_hevc_cfg_del(lhvccfg);\n\tif (hevccfg) gf_odf_hevc_cfg_del(hevccfg);\n\tgf_isom_set_nalu_extract_mode(file, track, cur_extract_mode);\n\tif (nal_data) gf_free(nal_data);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_media_split_lhvc(GF_ISOFile *file, u32 track, Bool for_temporal_sublayers, Bool splitAll, GF_LHVCExtractoreMode extractor_mode)\n{\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\tLHVCTrackInfo sti[64];\n\tGF_HEVCConfig *hevccfg, *lhvccfg;\n\tu32 sample_num, count, cur_extract_mode, j, k, max_layer_id;\n\tchar *nal_data=NULL;\n\tu32 nal_alloc_size;\n\tu32 nal_unit_size=0;\n\tBool single_layer_per_track=GF_TRUE;\n\tGF_Err e = GF_OK;\n\tHEVCState hevc_state;\n\n\tmemset(&hevc_state, 0, sizeof(HEVCState));\n\n\thevccfg = gf_isom_hevc_config_get(file, track, 1);\n\tlhvccfg = gf_isom_lhvc_config_get(file, track, 1);\n\tif (!lhvccfg && !for_temporal_sublayers) {\n\t\tif (hevccfg) gf_odf_hevc_cfg_del(hevccfg);\n\t\treturn GF_OK;\n\t}\n\telse if (for_temporal_sublayers) {\n\t\tif (lhvccfg) {\n\t\t\tif (hevccfg) gf_odf_hevc_cfg_del(hevccfg);\n\t\t\tgf_odf_hevc_cfg_del(lhvccfg);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\tif (!hevccfg) return GF_NOT_SUPPORTED;\n\n\t\tif (hevccfg->numTemporalLayers<=1) {\n\t\t\tgf_odf_hevc_cfg_del(hevccfg);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tcur_extract_mode = gf_isom_get_nalu_extract_mode(file, track);\n\tgf_isom_set_nalu_extract_mode(file, track, GF_ISOM_NALU_EXTRACT_INSPECT);\n\n\tmemset(sti, 0, sizeof(sti));\n\tsti[0].track_num = track;\n\tsti[0].has_samples=GF_TRUE;\n\tmax_layer_id = 0;\n\n\tnal_unit_size = lhvccfg ? lhvccfg->nal_unit_size : hevccfg->nal_unit_size;\n\n\tif (!for_temporal_sublayers) {\n\t\tu32 i, pass, base_layer_pass = GF_TRUE;\n\t\tGF_HEVCConfig *cur_cfg = hevccfg;\n\nreparse:\n\t\t//split all SPS/PPS/VPS from lhvccfg\n\t\tfor (pass=0; pass<3; pass++) {\n\t\tcount = gf_list_count(cur_cfg->param_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 count2;\n\t\t\tGF_NALUFFParamArray *s_ar;\n\t\t\tGF_NALUFFParamArray *ar = gf_list_get(cur_cfg->param_array, i);\n\t\t\tif ((pass==0) && (ar->type!=GF_HEVC_NALU_VID_PARAM)) continue;\n\t\t\telse if ((pass==1) && (ar->type!=GF_HEVC_NALU_SEQ_PARAM)) continue;\n\t\t\telse if ((pass==2) && (ar->type!=GF_HEVC_NALU_PIC_PARAM)) continue;\n\n\t\t\tcount2 = gf_list_count(ar->nalus);\n\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\tGF_NALUFFParam *sl = gf_list_get(ar->nalus, j);\n//\t\t\t\tu8 nal_type = (sl->data[0] & 0x7E) >> 1;\n\t\t\t\tu8 layer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3);\n\n\t\t\t\tif (ar->type==GF_HEVC_NALU_SEQ_PARAM) {\n\t\t\t\t\tu32 lw, lh;\n\t\t\t\t\ts32 idx = gf_hevc_get_sps_info_with_state(&hevc_state, sl->data, sl->size, NULL, &lw, &lh, NULL, NULL);\n\t\t\t\t\tif (idx>=0) {\n\t\t\t\t\t\tif (lw > sti[layer_id].width) sti[layer_id].width = lw;\n\t\t\t\t\t\tif (lh > sti[layer_id].height) sti[layer_id].height = lh;\n\t\t\t\t\t}\n\t\t\t\t} else if (ar->type==GF_HEVC_NALU_PIC_PARAM) {\n\t\t\t\t\tgf_hevc_read_pps(sl->data, sl->size, &hevc_state);\n\t\t\t\t} else if (ar->type==GF_HEVC_NALU_VID_PARAM) {\n\t\t\t\t\tgf_hevc_read_vps(sl->data, sl->size, &hevc_state);\n\t\t\t\t}\n\n\t\t\t\t//don't touch base layer\n\t\t\t\tif (!layer_id) {\n\t\t\t\t\tassert(base_layer_pass);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!splitAll) layer_id = 1;\n\n\t\t\t\tif (max_layer_id < layer_id)\n\t\t\t\t\tmax_layer_id = layer_id;\n\n\t\t\t\tif (!sti[layer_id].lhvccfg) {\n\t\t\t\t\tGF_List *backup_list;\n\t\t\t\t\tsti[layer_id].lhvccfg = gf_odf_hevc_cfg_new();\n\t\t\t\t\tbackup_list = sti[layer_id].lhvccfg->param_array;\n\t\t\t\t\tmemcpy(sti[layer_id].lhvccfg , lhvccfg ? lhvccfg : hevccfg, sizeof(GF_HEVCConfig));\n\t\t\t\t\tsti[layer_id].lhvccfg->param_array = backup_list;\n\n\t\t\t\t\tsti[layer_id].lhvccfg->is_lhvc = 1;\n\t\t\t\t\tsti[layer_id].lhvccfg->complete_representation = 1;\n\t\t\t\t}\n\n\t\t\t\ts_ar = alloc_hevc_param_array(sti[layer_id].lhvccfg, ar->type);\n\t\t\t\tgf_list_add(s_ar->nalus, sl);\n\t\t\t\tgf_list_rem(ar->nalus, j);\n\t\t\t\tj--;\n\t\t\t\tcount2--;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (base_layer_pass) {\n\t\t\tbase_layer_pass = GF_FALSE;\n\t\t\tcur_cfg = lhvccfg;\n\t\t\tgoto reparse;\n\t\t}\n\t} else {\n\t\tgf_isom_set_cts_packing(file, track, GF_TRUE);\n\t}\n\n\t//CLARIFY whether this is correct: we duplicate all VPS in the enhancement layer ...\n\t//we do this because if we split the tracks some info for setting up the enhancement layer\n\t//is in the VPS\n\tif (extractor_mode != GF_LHVC_EXTRACTORS_ON) {\n\t\tu32 i;\n\t\tcount = gf_list_count(hevccfg->param_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 count2;\n\t\t\tGF_NALUFFParamArray *s_ar;\n\t\t\tGF_NALUFFParamArray *ar = gf_list_get(hevccfg->param_array, i);\n\t\t\tif (ar->type != GF_HEVC_NALU_VID_PARAM) continue;\n\t\t\tcount2 = gf_list_count(ar->nalus);\n\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\tGF_NALUFFParam *sl = gf_list_get(ar->nalus, j);\n\t\t\t\tu8 layer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3);\n\t\t\t\tif (layer_id) continue;\n\n\t\t\t\tfor (k=0; k <= max_layer_id; k++) {\n\t\t\t\t\tGF_NALUFFParam *sl2;\n\t\t\t\t\tif (!sti[k].lhvccfg) continue;\n\n\t\t\t\t\ts_ar = alloc_hevc_param_array(sti[k].lhvccfg, ar->type);\n\t\t\t\t\ts_ar->array_completeness = ar->array_completeness;\n\n\t\t\t\t\tGF_SAFEALLOC(sl2, GF_NALUFFParam);\n\t\t\t\t\tif (!sl2) break;\n\t\t\t\t\tsl2->data = gf_malloc(sl->size);\n\t\t\t\t\tif (!sl2->data) {\n\t\t\t\t\t\tgf_free(sl2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(sl2->data, sl->data, sl->size);\n\t\t\t\t\tsl2->id = sl->id;\n\t\t\t\t\tsl2->size = sl->size;\n\t\t\t\t\tgf_list_add(s_ar->nalus, sl2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//update lhvc config\n\tif (for_temporal_sublayers) {\n\t\te = gf_isom_lhvc_config_update(file, track, 1, NULL, GF_ISOM_LEHVC_WITH_BASE_BACKWARD);\n\t} else {\n\t\te = gf_isom_lhvc_config_update(file, track, 1, NULL, GF_ISOM_LEHVC_WITH_BASE_BACKWARD);\n\t}\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[HEVC] Failed to update HEVC/LHVC config\\n\"));\n\t\tgoto exit;\n\t}\n\n\t//purge all linf sample groups\n\tgf_isom_remove_sample_group(file, track, GF_ISOM_SAMPLE_GROUP_LINF);\n\n\tnal_alloc_size = 10000;\n\tnal_data = gf_malloc(sizeof(char) * nal_alloc_size);\n\t//parse all samples\n\tcount = gf_isom_get_sample_count(file, track);\n\tfor (sample_num=0; sample_num<count; sample_num++) {\n\t\tGF_BitStream *bs;\n\t\tu32 di;\n\t\tGF_ISOSample *sample;\n\t\tBool is_irap;\n\t\tGF_ISOSampleRollType roll_type;\n\t\ts32 roll_distance;\n\t\tu8 cur_max_layer_id = 0;\n\n\t\tsample = gf_isom_get_sample(file, track, sample_num+1, &di);\n\t\tgf_isom_get_sample_rap_roll_info(file, track, sample_num+1, &is_irap, &roll_type, &roll_distance);\n\n\t\tbs = gf_bs_new(sample->data, sample->dataLength, GF_BITSTREAM_READ);\n\t\twhile (gf_bs_available(bs)) {\n\t\t\tu8 orig_layer_id, nal_size;\n\t\t\tu32 size = gf_bs_read_int(bs, nal_unit_size*8);\n\t\t\tu32 offset = (u32) gf_bs_get_position(bs);\n\t\t\tu8 fzero = gf_bs_read_int(bs, 1);\n\t\t\tu8 nal_type = gf_bs_read_int(bs, 6);\n\t\t\tu8 layer_id = orig_layer_id = gf_bs_read_int(bs, 6);\n\t\t\tu8 temporal_id = gf_bs_read_int(bs, 3);\n\n\t\t\tif (for_temporal_sublayers) {\n\t\t\t\tu32 tid = temporal_id-1;\n\t\t\t\tif (tid && !sti[tid].layer_id) {\n\t\t\t\t\tsti[tid].layer_id=tid;\n\t\t\t\t}\n\t\t\t\tlayer_id = tid;\n\n\t\t\t\tif ((nal_type <= GF_HEVC_NALU_SLICE_CRA)\n\t\t\t\t\t&& (nal_type != GF_HEVC_NALU_SLICE_TSA_N)\n\t\t\t\t\t&& (nal_type != GF_HEVC_NALU_SLICE_TSA_R))\n\t\t\t\t\t\tsti[layer_id].non_tsa_vcl = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (layer_id && !sti[layer_id].layer_id) {\n\t\t\t\t\tsti[layer_id].layer_id=layer_id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!splitAll && layer_id) layer_id = 1;\n\n\t\t\tif (cur_max_layer_id < layer_id) {\n\t\t\t\tcur_max_layer_id = layer_id;\n\t\t\t}\n\n\t\t\tnal_size = size;\n\n\t\t\tif (!sti[layer_id].bs)\n\t\t\t\tsti[layer_id].bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\tgf_bs_write_int(sti[layer_id].bs, size, nal_unit_size*8);\n\t\t\tgf_bs_write_int(sti[layer_id].bs, fzero, 1);\n\t\t\tgf_bs_write_int(sti[layer_id].bs, nal_type, 6);\n\t\t\tgf_bs_write_int(sti[layer_id].bs, orig_layer_id, 6);\n\t\t\tgf_bs_write_int(sti[layer_id].bs, temporal_id, 3);\n\t\t\tsize -= 2;\n\n\t\t\tsti[layer_id].layers[layer_id].layer_id_plus_one = layer_id+1;\n\t\t\tsti[layer_id].temporal_id_sample = temporal_id;\n\n\t\t\tif (!sti[layer_id].layers[layer_id].min_temporal_id || (sti[layer_id].layers[layer_id].min_temporal_id > temporal_id)) {\n\t\t\t\tsti[layer_id].layers[layer_id].min_temporal_id = temporal_id;\n\t\t\t}\n\t\t\tif (!sti[layer_id].layers[layer_id].max_temporal_id || (sti[layer_id].layers[layer_id].max_temporal_id < temporal_id)) {\n\t\t\t\tsti[layer_id].layers[layer_id].max_temporal_id = temporal_id;\n\t\t\t}\n\n\t\t\tif (!sti[layer_id].max_temporal_id_sample || (sti[layer_id].max_temporal_id_sample < temporal_id)) {\n\t\t\t\tsti[layer_id].max_temporal_id_sample = temporal_id;\n\t\t\t}\n\n\t\t\tif (! for_temporal_sublayers) {\n\n\t\t\t\tif (nal_type==GF_HEVC_NALU_SEQ_PARAM) {\n\t\t\t\t\tu32 lw, lh;\n\t\t\t\t\ts32 idx = gf_hevc_get_sps_info_with_state(&hevc_state, sample->data + offset, nal_size, NULL, &lw, &lh, NULL, NULL);\n\t\t\t\t\tif (idx>=0) {\n\t\t\t\t\t\tif (lw > sti[layer_id].width) sti[layer_id].width = lw;\n\t\t\t\t\t\tif (lh > sti[layer_id].height) sti[layer_id].height = lh;\n\t\t\t\t\t}\n\t\t\t\t} else if (nal_type==GF_HEVC_NALU_PIC_PARAM) {\n\t\t\t\t\tgf_hevc_read_pps(sample->data + offset, nal_size, &hevc_state);\n\t\t\t\t} else if (nal_type==GF_HEVC_NALU_VID_PARAM) {\n\t\t\t\t\tgf_hevc_read_vps(sample->data + offset, nal_size, &hevc_state);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (size>nal_alloc_size) {\n\t\t\t\tnal_alloc_size = size;\n\t\t\t\tnal_data = gf_realloc(nal_data, nal_alloc_size);\n\t\t\t}\n\n\t\t\tgf_bs_read_data(bs, nal_data, size);\n\t\t\tgf_bs_write_data(sti[layer_id].bs, nal_data, size);\n\t\t}\n\t\tgf_bs_del(bs);\n\n\t\tif (cur_max_layer_id>max_layer_id) {\n\t\t\tmax_layer_id = cur_max_layer_id;\n\t\t}\n\t\tif (for_temporal_sublayers && hevccfg->numTemporalLayers>max_layer_id+1) {\n\t\t\tmax_layer_id = hevccfg->numTemporalLayers-1;\n\t\t}\n\n\t\tgf_free(sample->data);\n\t\tsample->data = NULL;\n\t\tsample->dataLength = 0;\n\t\t//reset all samples on all layers found - we may have layers not present in this sample, we still need to process these layers when extractors are used\n\t\tfor (j=0; j<=max_layer_id; j++) {\n\t\t\tif (!for_temporal_sublayers && ! sti[j].bs) {\n\t\t\t\tif (!sti[j].track_num || (extractor_mode != GF_LHVC_EXTRACTORS_ON) ) {\n\t\t\t\t\tsti[j].data_offset =  sti[j].data_size = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//clone track\n\t\t\tif (! sti[j].track_num) {\n\t\t\t\tu32 track_id = gf_isom_get_track_id(file, track);\n\t\t\t\te = gf_isom_clone_track(file, track, file, 0, &sti[j].track_num);\n\t\t\t\tif (e) goto exit;\n\n\t\t\t\tif (! for_temporal_sublayers) {\n\t\t\t\t\t//happens for inband param\n\t\t\t\t\tif (!sti[j].lhvccfg) {\n\t\t\t\t\t\tGF_List *backup_list;\n\t\t\t\t\t\tsti[j].lhvccfg = gf_odf_hevc_cfg_new();\n\t\t\t\t\t\tbackup_list = sti[j].lhvccfg->param_array;\n\t\t\t\t\t\tmemcpy(sti[j].lhvccfg , lhvccfg ? lhvccfg : hevccfg, sizeof(GF_HEVCConfig));\n\t\t\t\t\t\tsti[j].lhvccfg->param_array = backup_list;\n\n\t\t\t\t\t\tsti[j].lhvccfg->is_lhvc = 1;\n\t\t\t\t\t\tsti[j].lhvccfg->complete_representation = 1;\n\t\t\t\t\t}\n\t\t\t\t\te = gf_isom_lhvc_config_update(file, sti[j].track_num, 1, sti[j].lhvccfg, (extractor_mode == GF_LHVC_EXTRACTORS_ON)  ? GF_ISOM_LEHVC_WITH_BASE : GF_ISOM_LEHVC_ONLY);\n\t\t\t\t\tif (e) goto exit;\n\n\t\t\t\t\tif (extractor_mode == GF_LHVC_EXTRACTORS_OFF_FORCE_INBAND)\n\t\t\t\t\t\tgf_isom_lhvc_force_inband_config(file, sti[j].track_num, 1);\n\t\t\t\t} else {\n\t\t\t\t\te = gf_isom_lhvc_config_update(file, sti[j].track_num, 1, NULL, GF_ISOM_LEHVC_WITH_BASE);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t}\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[HEVC] Failed to update HEVC/LHVC config\\n\"));\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\tgf_isom_set_track_reference(file, sti[j].track_num, GF_ISOM_REF_BASE, track_id);\n\n\t\t\t\t//for an L-HEVC bitstream: only base track carries the 'oinf' sample group, other track have a track reference of type 'oref' to base track\n\t\t\t\te = gf_isom_remove_sample_group(file, sti[j].track_num, GF_ISOM_SAMPLE_GROUP_OINF);\n\t\t\t\tif (e) goto exit;\n\t\t\t\t//purge all linf sample groups\n\t\t\t\tgf_isom_remove_sample_group(file, sti[j].track_num, GF_ISOM_SAMPLE_GROUP_LINF);\n\t\t\t\tgf_isom_set_track_reference(file, sti[j].track_num, GF_ISOM_REF_OREF, track_id);\n\n\t\t\t\tgf_isom_set_nalu_extract_mode(file, sti[j].track_num, GF_ISOM_NALU_EXTRACT_INSPECT);\n\n\t\t\t\t//get lower layer\n\t\t\t\tif (extractor_mode == GF_LHVC_EXTRACTORS_ON) {\n\t\t\t\t\tfor (k=j; k>0; k--) {\n\t\t\t\t\t\tif (sti[k-1].track_num) {\n\t\t\t\t\t\t\tu32 track_id_r = gf_isom_get_track_id(file, sti[k-1].track_num);\n\t\t\t\t\t\t\tgf_isom_set_track_reference(file, sti[j].track_num, GF_ISOM_REF_SCAL, track_id_r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!for_temporal_sublayers)\n\t\t\t\t\tgf_isom_set_visual_info(file, sti[j].track_num, 1, sti[j].width, sti[j].height);\n\t\t\t} else {\n\t\t\t\tif (!for_temporal_sublayers)\n\t\t\t\t\tgf_isom_set_visual_info(file, sti[j].track_num, 1, sti[j].width, sti[j].height);\n\t\t\t}\n\n\t\t\tif (j && (extractor_mode == GF_LHVC_EXTRACTORS_ON)) {\n\t\t\t\tGF_BitStream *xbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\t//get all lower layers\n\t\t\t\tfor (k=0; k<j; k++) {\n\t\t\t\t\tu8 trefidx, tid;\n\t\t\t\t\tif (!sti[k].data_size)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t//extractor size 5\n\t\t\t\t\tgf_bs_write_int(xbs, 2*nal_unit_size + 5, 8*nal_unit_size);\n\t\t\t\t\tgf_bs_write_int(xbs, 0, 1);\n\t\t\t\t\tgf_bs_write_int(xbs, GF_HEVC_NALU_FF_EXTRACTOR, 6); //extractor\n\t\t\t\t\tgf_bs_write_int(xbs, k, 6);\n\t\t\t\t\tgf_bs_write_int(xbs, sti[k].max_temporal_id_sample, 3);\n\t\t\t\t\tgf_bs_write_u8(xbs, 0); //constructor type 0\n\t\t\t\t\t//set ref track index\n\t\t\t\t\ttrefidx = (u8) gf_isom_has_track_reference(file, sti[j].track_num, GF_ISOM_REF_SCAL, gf_isom_get_track_id(file, sti[k].track_num) );\n\t\t\t\t\tgf_bs_write_int(xbs, trefidx, 8);\n\t\t\t\t\t// no sample offset\n\t\t\t\t\tgf_bs_write_int(xbs, 0, 8);\n\t\t\t\t\t// data offset: we start from beginning of the sample data, not the extractor\n\t\t\t\t\tgf_bs_write_int(xbs, sti[k].data_offset, 8*nal_unit_size);\n\t\t\t\t\tgf_bs_write_int(xbs, sti[k].data_size, 8*nal_unit_size);\n\n\t\t\t\t\ttid = sti[k].temporal_id_sample;\n\t\t\t\t\tsti[j].layers[k].layer_id_plus_one = sti[k].layer_id+1;\n\t\t\t\t\tif (!sti[j].layers[k].min_temporal_id || (sti[j].layers[k].min_temporal_id > tid)) {\n\t\t\t\t\t\tsti[j].layers[k].min_temporal_id = tid;\n\t\t\t\t\t}\n\t\t\t\t\tif (!sti[j].layers[k].max_temporal_id || (sti[j].layers[k].max_temporal_id < tid)) {\n\t\t\t\t\t\tsti[j].layers[k].max_temporal_id = tid;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgf_bs_get_content(xbs, &sample->data, &sample->dataLength);\n\t\t\t\tgf_bs_del(xbs);\n\n\t\t\t\t//we wrote all our references, store offset for upper layers\n\t\t\t\tsti[j].data_offset = sample->dataLength;\n\t\t\t\te = gf_isom_add_sample(file, sti[j].track_num, 1, sample);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[HEVC] Failed to add HEVC/LHVC sample to track %d\\n\", sti[j].track_num));\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tgf_free(sample->data);\n\t\t\t\tsample->data = NULL;\n\n\t\t\t\t//get real content, remember its size and add it to the new bs\n\t\t\t\tif (sti[j].bs) {\n\t\t\t\t\tgf_bs_get_content(sti[j].bs, &sample->data, &sample->dataLength);\n\t\t\t\t\te = gf_isom_append_sample_data(file, sti[j].track_num, sample->data, sample->dataLength);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[HEVC] Failed to append HEVC/LHVC data to sample (track %d)\\n\", sti[j].track_num));\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t//get sample content\n\t\t\telse if (sti[j].bs) {\n\t\t\t\t//add empty sample at DTS 0\n\t\t\t\tif ( ! sti[j].has_samples) {\n\t\t\t\t\tif (sample->DTS) {\n\t\t\t\t\t\tGF_ISOSample s;\n\t\t\t\t\t\tmemset(&s, 0, sizeof(GF_ISOSample));\n\t\t\t\t\t\tgf_isom_add_sample(file, sti[j].track_num, 1, &s);\n\t\t\t\t\t}\n\t\t\t\t\tsti[j].has_samples=GF_TRUE;\n\t\t\t\t}\n\t\t\t\tgf_bs_get_content(sti[j].bs, &sample->data, &sample->dataLength);\n\t\t\t\tsti[j].data_offset = 0;\n\t\t\t\tsti[j].data_size = sample->dataLength;\n\n\t\t\t\t//add sample\n\t\t\t\tif (j) {\n\t\t\t\t\tGF_ISOSAPType rap = sample->IsRAP;\n\t\t\t\t\tif (for_temporal_sublayers && !sti[j].non_tsa_vcl)\n\t\t\t\t\t\tsample->IsRAP = RAP;\n\n\t\t\t\t\te = gf_isom_add_sample(file, sti[j].track_num, 1, sample);\n\t\t\t\t\tsample->IsRAP = rap;\n\t\t\t\t} else {\n\t\t\t\t\te = gf_isom_update_sample(file, sti[j].track_num, sample_num+1, sample, 1);\n\t\t\t\t}\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[HEVC] Failed to %s HEVC/LHVC sample (track %d, base sample num %d)\\n\", j ? \"add\" : \"update\", sti[j].track_num, sample_num+1));\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//no data left in sample, update\n\t\t\telse if (!j) {\n\t\t\t\te = gf_isom_remove_sample(file, sti[j].track_num, sample_num+1);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[HEVC] Failed to remove HEVC/LHVC sample (track %d)\\n\", sti[j].track_num));\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tsample_num--;\n\t\t\t\tcount--;\n\t\t\t}\n\n\t\t\tgf_bs_del(sti[j].bs);\n\t\t\tsti[j].bs = NULL;\n\n\t\t\tif (sample->IsRAP>SAP_TYPE_1) {\n\t\t\t\tu32 sample_idx = gf_isom_get_sample_count(file, sti[j].track_num);\n\t\t\t\tif (is_irap) {\n\t\t\t\t\tgf_isom_set_sample_rap_group(file, sti[j].track_num, sample_idx, GF_TRUE, 0);\n\t\t\t\t}\n\t\t\t\telse if (roll_type) {\n\t\t\t\t\tgf_isom_set_sample_roll_group(file, sti[j].track_num, sample_idx, GF_ISOM_SAMPLE_ROLL, (s16) roll_distance);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sample->data) {\n\t\t\t\tgf_free(sample->data);\n\t\t\t\tsample->data = NULL;\n\t\t\t}\n\t\t\tsample->dataLength = 0;\n\t\t}\n\t\tgf_isom_sample_del(&sample);\n\n\t\t//reset all scalable info\n\t\tfor (j=0; j<=max_layer_id; j++) {\n\t\t\tsti[j].max_temporal_id_sample = 0;\n\t\t\tsti[j].temporal_id_sample = 0;\n\t\t\tsti[j].data_size = 0;\n\t\t\tsti[j].non_tsa_vcl = GF_FALSE;\n\t\t}\n\t}\n\nexit:\n\t//reset all scalable info\n\tfor (j=0; j<=max_layer_id; j++) {\n\t\tGF_BitStream *bs;\n\t\tu32 data_size;\n\t\tu8 *data=NULL;\n\t\tif (sti[j].lhvccfg) gf_odf_hevc_cfg_del(sti[j].lhvccfg);\n\t\t//set linf group\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_int(bs, 0, 2);\n\t\tcount = 0;\n\t\tfor (k=0; k<=max_layer_id; k++) {\n\t\t\tif (sti[j].layers[k].layer_id_plus_one) count++;\n\t\t}\n\t\tgf_bs_write_int(bs, count, 6);\n\t\tif (count>1)\n\t\t\tsingle_layer_per_track = GF_FALSE;\n\n\t\tfor (k=0; k<=max_layer_id; k++) {\n\t\t\tif (! sti[j].layers[k].layer_id_plus_one) continue;\n\t\t\tgf_bs_write_int(bs, 0, 4);\n\t\t\tgf_bs_write_int(bs, sti[j].layers[k].layer_id_plus_one - 1, 6);\n\t\t\tgf_bs_write_int(bs, sti[j].layers[k].min_temporal_id, 3);\n\t\t\tgf_bs_write_int(bs, sti[j].layers[k].max_temporal_id, 3);\n\t\t\tgf_bs_write_int(bs, 0, 1);\n\t\t\t//track carries the NALUs\n\t\t\tif (k==j) {\n\t\t\t\tgf_bs_write_int(bs, 0xFF, 7);\n\t\t\t}\n\t\t\t//otherwise referenced through extractors, not present natively\n\t\t\telse {\n\t\t\t\tgf_bs_write_int(bs, 0, 7);\n\t\t\t}\n\t\t}\n\t\tgf_bs_get_content(bs, &data, &data_size);\n\t\tgf_bs_del(bs);\n\t\tgf_isom_add_sample_group_info(file, sti[j].track_num, GF_ISOM_SAMPLE_GROUP_LINF, data, data_size, GF_TRUE, &count);\n\t\tgf_free(data);\n\t}\n\tgf_isom_set_nalu_extract_mode(file, track, cur_extract_mode);\n\n\tif (extractor_mode == GF_LHVC_EXTRACTORS_ON) {\n\t\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_HVCE, GF_TRUE);\n\t\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_HVCI, GF_FALSE);\n\t}\n\t//add hvci brand only if single layer per track\n\telse if (single_layer_per_track) {\n\t\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_HVCI, GF_TRUE);\n\t\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_HVCE, GF_FALSE);\n\t}\n\tif (lhvccfg) gf_odf_hevc_cfg_del(lhvccfg);\n\tif (hevccfg) gf_odf_hevc_cfg_del(hevccfg);\n\tif (nal_data) gf_free(nal_data);\n\treturn e;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n\n}\n#endif ///GPAC_DISABLE_AV_PARSERS\n\nGF_EXPORT\nGF_Err gf_media_change_pl(GF_ISOFile *file, u32 track, u32 profile, u32 compat, u32 level)\n{\n\tu32 i, count, stype;\n\tGF_Err e;\n\tGF_AVCConfig *avcc;\n\n\tstype = gf_isom_get_media_subtype(file, track, 1);\n\tswitch (stype) {\n\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\tavcc = gf_isom_avc_config_get(file, track, 1);\n\n\tif (!avcc)\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\n\tif (level) avcc->AVCLevelIndication = level;\n\tif (compat) avcc->profile_compatibility = compat;\n\tif (profile) avcc->AVCProfileIndication = profile;\n\tcount = gf_list_count(avcc->sequenceParameterSets);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *slc = gf_list_get(avcc->sequenceParameterSets, i);\n\t\tif (profile) slc->data[1] = profile;\n\t\tif (level) slc->data[3] = level;\n\t}\n\te = gf_isom_avc_config_update(file, track, 1, avcc);\n\n\tgf_odf_avc_cfg_del(avcc);\n\treturn e;\n}\n\n#endif // GPAC_DISABLE_MEDIA_IMPORT\n\n#if !defined(GPAC_DISABLE_AV_PARSERS)\nu32 hevc_get_tile_id(HEVCState *hevc, u32 *tile_x, u32 *tile_y, u32 *tile_width, u32 *tile_height)\n{\n\tHEVCSliceInfo *si = &hevc->s_info;\n\tu32 i, tbX, tbY, PicWidthInCtbsY, PicHeightInCtbsY, tileX, tileY, oX, oY, val;\n\n\tPicWidthInCtbsY = si->sps->width / si->sps->max_CU_width;\n\tif (PicWidthInCtbsY * si->sps->max_CU_width < si->sps->width) PicWidthInCtbsY++;\n\tPicHeightInCtbsY = si->sps->height / si->sps->max_CU_width;\n\tif (PicHeightInCtbsY * si->sps->max_CU_width < si->sps->height) PicHeightInCtbsY++;\n\n\ttbX = si->slice_segment_address % PicWidthInCtbsY;\n\ttbY = si->slice_segment_address / PicWidthInCtbsY;\n\n\ttileX = tileY = 0;\n\toX = oY = 0;\n\tfor (i=0; i < si->pps->num_tile_columns; i++) {\n\t\tif (si->pps->uniform_spacing_flag) {\n\t\t\tval = (i+1)*PicWidthInCtbsY / si->pps->num_tile_columns - (i)*PicWidthInCtbsY / si->pps->num_tile_columns;\n\t\t} else {\n\t\t\tif (i<si->pps->num_tile_columns-1) {\n\t\t\t\tval = si->pps->column_width[i];\n\t\t\t} else {\n\t\t\t\tval = (PicWidthInCtbsY - si->pps->column_width[i-1]);\n\t\t\t}\n\t\t}\n\t\t*tile_x = oX;\n\t\t*tile_width = val;\n\n\t\tif (oX >= tbX) break;\n\t\toX += val;\n\t\ttileX++;\n\t}\n\tfor (i=0; i<si->pps->num_tile_rows; i++) {\n\t\tif (si->pps->uniform_spacing_flag) {\n\t\t\tval = (i+1)*PicHeightInCtbsY / si->pps->num_tile_rows - (i)*PicHeightInCtbsY / si->pps->num_tile_rows;\n\t\t} else {\n\t\t\tif (i<si->pps->num_tile_rows-1) {\n\t\t\t\tval = si->pps->row_height[i];\n\t\t\t} else if (i) {\n\t\t\t\tval = (PicHeightInCtbsY - si->pps->row_height[i-1]);\n\t\t\t} else {\n\t\t\t\tval = PicHeightInCtbsY;\n\t\t\t}\n\t\t}\n\t\t*tile_y = oY;\n\t\t*tile_height = val;\n\n\t\tif (oY >= tbY) break;\n\t\toY += val;\n\t\ttileY++;\n\t}\n\t*tile_x = *tile_x * si->sps->max_CU_width;\n\t*tile_y = *tile_y * si->sps->max_CU_width;\n\t*tile_width = *tile_width * si->sps->max_CU_width;\n\t*tile_height = *tile_height * si->sps->max_CU_width;\n\n\tif (*tile_x + *tile_width > si->sps->width)\n\t\t*tile_width = si->sps->width - *tile_x;\n\tif (*tile_y + *tile_height > si->sps->height)\n\t\t*tile_height = si->sps->height - *tile_y;\n\n\treturn tileX + tileY * si->pps->num_tile_columns;\n}\n\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\ntypedef struct\n{\n\tu32 track, track_id, sample_count;\n\tu32 tx, ty, tw, th;\n\tu32 data_offset;\n\tGF_BitStream *sample_data;\n\tu32 nb_nalus_in_sample;\n\tBool all_intra;\n} HEVCTileImport;\n\nstatic void hevc_add_trif(GF_ISOFile *file, u32 track, u32 id, Bool full_picture, u32 independent, Bool filtering_disable, u32 tx, u32 ty, u32 tw, u32 th, Bool is_default)\n{\n\tchar data[11];\n\tu32 di, data_size=7;\n\tGF_BitStream *bs;\n\t//avoid gcc warnings\n\tmemset(data, 0, 11);\n\t//write TRIF sample group description\n\tbs = gf_bs_new((const char*)data, 11, GF_BITSTREAM_WRITE);\n\tgf_bs_write_u16(bs, id);\t//groupID\n\tgf_bs_write_int(bs, 1, 1); //tile Region flag always true for us\n\tgf_bs_write_int(bs, independent, 2); //independentIDC: set to 1 (motion-constrained tiles but not all tiles RAP)\n\tgf_bs_write_int(bs, full_picture, 1);//full picture: false since we don't do L-HEVC tiles\n\tgf_bs_write_int(bs, filtering_disable, 1); //filtering disabled: set to 1 (always true on our bitstreams for now) - Check xPS to be sure ...\n\tgf_bs_write_int(bs, 0, 1);//has dependency list: false since we don't do L-HEVC tiles\n\tgf_bs_write_int(bs, 0, 2); //reserved\n\tif (!full_picture) {\n\t\tgf_bs_write_u16(bs, tx);\n\t\tgf_bs_write_u16(bs, ty);\n\t\tdata_size+=4;\n\t}\n\tgf_bs_write_u16(bs, tw);\n\tgf_bs_write_u16(bs, th);\n\tgf_bs_del(bs);\n\n\tgf_isom_add_sample_group_info(file, track, GF_ISOM_SAMPLE_GROUP_TRIF, data, data_size, is_default, &di);\n}\n\nGF_EXPORT\nGF_Err gf_media_split_hevc_tiles(GF_ISOFile *file, u32 signal_mode)\n{\n#if defined(GPAC_DISABLE_AV_PARSERS)\n\treturn GF_NOT_SUPPORTED;\n#else\n\tu32 i, j, cur_tile, count, stype, track, nb_tiles, di, nalu_size_length, tx, ty, tw, th;\n\ts32 pps_idx=-1, sps_idx=-1, ret;\n\tGF_Err e = GF_OK;\n\tHEVCState hevc;\n\tHEVCTileImport *tiles;\n\tGF_HEVCConfig *hvcc;\n\tBool filter_disabled=GF_TRUE;\n\n\ttrack = 0;\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tstype = gf_isom_get_media_subtype(file, i+1, 1);\n\t\tswitch (stype) {\n\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\n\t\t\tif (track) return GF_NOT_SUPPORTED;\n\t\t\ttrack = i+1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!track) return GF_NOT_SUPPORTED;\n\n\thvcc = gf_isom_hevc_config_get(file, track, 1);\n\tnalu_size_length = hvcc->nal_unit_size;\n\n\tmemset(&hevc, 0, sizeof(HEVCState));\n\n\tcount = gf_list_count(hvcc->param_array);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParamArray *ar = gf_list_get(hvcc->param_array, i);\n\t\tfor (j=0; j < gf_list_count(ar->nalus); j++) {\n\t\t\tGF_NALUFFParam *sl = gf_list_get(ar->nalus, j);\n\t\t\tif (!sl) continue;\n\t\t\tswitch (ar->type) {\n\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\tpps_idx = gf_hevc_read_pps(sl->data, sl->size, &hevc);\n\t\t\t\tbreak;\n\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\t\tsps_idx = gf_hevc_read_sps(sl->data, sl->size, &hevc);\n\t\t\t\tbreak;\n\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\t\tgf_hevc_read_vps(sl->data, sl->size, &hevc);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tgf_isom_hevc_set_tile_config(file, track, 1, hvcc, GF_TRUE);\n\tgf_odf_hevc_cfg_del(hvcc);\n\n\t//if params sets are inband, get first sps/pps\n\ti=0;\n\twhile ((pps_idx==-1) || (sps_idx==-1)) {\n\t\tGF_ISOSample *sample = gf_isom_get_sample(file, track, i+1, &di);\n\t\tchar *data = sample->data;\n\t\tu32 size = sample->dataLength;\n\n\t\twhile (size) {\n\t\t\tu8 temporal_id, layer_id;\n\t\t\tu8 nal_type = 0;\n\t\t\tu32 nalu_size = 0;\n\n\t\t\tfor (j=0; j<nalu_size_length; j++) {\n\t\t\t\tnalu_size = (nalu_size<<8) + data[j];\n\t\t\t}\n\t\t\tgf_hevc_parse_nalu(data + nalu_size_length, nalu_size, &hevc, &nal_type, &temporal_id, &layer_id);\n\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\tpps_idx = gf_hevc_read_pps((char *) data+nalu_size_length, nalu_size, &hevc);\n\t\t\t\tbreak;\n\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\t\tsps_idx = gf_hevc_read_sps((char *) data+nalu_size_length, nalu_size, &hevc);\n\t\t\t\tbreak;\n\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\t\tgf_hevc_read_vps((char *) data+nalu_size_length, nalu_size, &hevc);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdata += nalu_size + nalu_size_length;\n\t\t\tsize -= nalu_size + nalu_size_length;\n\t\t}\n\t\tgf_isom_sample_del(&sample);\n\t}\n\n\tif (pps_idx==-1) return GF_BAD_PARAM;\n\tif (sps_idx==-1) return GF_BAD_PARAM;\n\n\tif (hevc.pps[pps_idx].loop_filter_across_tiles_enabled_flag)\n\t\tfilter_disabled=GF_FALSE;\n\n\tif (! hevc.pps[pps_idx].tiles_enabled_flag) {\n\t\thevc_add_trif(file, track, gf_isom_get_track_id(file, track), GF_TRUE, 1, filter_disabled, 0, 0, hevc.sps[pps_idx].width, hevc.sps[pps_idx].height, GF_TRUE);\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[HEVC Tiles] Tiles not enabled, signal only single tile full picture\\n\"));\n\t\treturn GF_OK;\n\t}\n\n\tnb_tiles = hevc.pps[pps_idx].num_tile_columns * hevc.pps[pps_idx].num_tile_rows;\n\ttiles = gf_malloc(sizeof(HEVCTileImport) * nb_tiles);\n\tif (!tiles) return GF_OUT_OF_MEM;\n\tmemset(tiles, 0, sizeof(HEVCTileImport) * nb_tiles);\n\n\tfor (i=0; i<nb_tiles; i++) {\n\t\tif (! signal_mode) {\n\t\t\t//first clone tracks\n\t\t\te = gf_isom_clone_track(file, track, file, 0, &tiles[i].track );\n\t\t\tif (e) goto err_exit;\n\t\t\ttiles[i].track_id = gf_isom_get_track_id(file, tiles[i].track);\n\t\t\tgf_isom_hevc_set_tile_config(file, tiles[i].track, 1, NULL, GF_FALSE);\n\n\t\t\t// setup track references from tile track to base\n\t\t\tgf_isom_set_track_reference(file, tiles[i].track, GF_ISOM_REF_TBAS, gf_isom_get_track_id(file, track) );\n\t\t} else {\n\t\t\ttiles[i].track_id = gf_isom_get_track_id(file, track) + i+1;\n\t\t}\n\t\ttiles[i].all_intra = GF_TRUE;\n\t}\n\n\tcount = gf_isom_get_sample_count(file, track);\n\tfor (i=0; i<count; i++) {\n\t\tu8 *data;\n\t\tu32 size, nb_nalus=0, nb_nal_entries=0, last_tile_group=(u32) -1;\n\t\tGF_BitStream *bs=NULL;\n\t\tGF_ISOSample *sample = gf_isom_get_sample(file, track, i+1, &di);\n\t\tif (!sample) {\n\t\t\te = gf_isom_last_error(file);\n\t\t\tgoto err_exit;\n\t\t}\n\n\t\tdata = (u8 *) sample->data;\n\t\tsize = sample->dataLength;\n\t\tif (!signal_mode) {\n\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tsample->data = NULL;\n\t\t\tsample->dataLength = 0;\n\n\t\t\tfor (j=0; j<nb_tiles; j++) {\n\t\t\t\ttiles[j].data_offset = 0;\n\t\t\t\ttiles[j].sample_data = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j=0; j<nb_tiles; j++) {\n\t\t\t\ttiles[j].nb_nalus_in_sample = 0;\n\t\t\t}\n\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t//write start of nalm group\n\t\t\tgf_bs_write_int(bs, 0, 6);//reserved\n\t\t\tgf_bs_write_int(bs, 0, 1);//large_size\n\t\t\tgf_bs_write_int(bs, (signal_mode==2) ? 1 : 0, 1);//rle\n\t\t\tgf_bs_write_u8(bs, 0);//entry_count - will be set at the end\n\t\t}\n\n\n\t\tsample->data = (char *) data;\n\n\t\twhile (size) {\n\t\t\tu8 temporal_id, layer_id;\n\t\t\tu8 nal_type = 0;\n\t\t\tu32 nalu_size = 0;\n\t\t\tfor (j=0; j<nalu_size_length; j++) {\n\t\t\t\tnalu_size = (nalu_size<<8) + data[j];\n\t\t\t}\n\t\t\tret = gf_hevc_parse_nalu(data + nalu_size_length, nalu_size, &hevc, &nal_type, &temporal_id, &layer_id);\n\n\t\t\t//error parsing NAL, set nal to fallback to regular import\n\t\t\tif (ret<0) nal_type = GF_HEVC_NALU_VID_PARAM;\n\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_HEVC_NALU_SLICE_TRAIL_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_TRAIL_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\t\tcase GF_HEVC_NALU_SLICE_RADL_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_RADL_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_RASL_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_RASL_N:\n\t\t\t\ttx = ty = tw = th = 0;\n\t\t\t\tcur_tile = hevc_get_tile_id(&hevc, &tx, &ty, &tw, &th);\n\t\t\t\tif (cur_tile>=nb_tiles) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[HEVC Tiles] Tile index %d is greater than number of tiles %d in PPS\\n\", cur_tile, nb_tiles));\n\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t}\n\t\t\t\tif (e)\n\t\t\t\t\tgoto err_exit;\n\n\t\t\t\ttiles[cur_tile].tx = tx;\n\t\t\t\ttiles[cur_tile].ty = ty;\n\t\t\t\ttiles[cur_tile].tw = tw;\n\t\t\t\ttiles[cur_tile].th = th;\n\t\t\t\tif (hevc.s_info.slice_type != GF_HEVC_SLICE_TYPE_I) {\n\t\t\t\t\ttiles[cur_tile].all_intra = 0;\n\t\t\t\t}\n\n\t\t\t\tif (signal_mode) {\n\t\t\t\t\tnb_nalus++;\n\t\t\t\t\ttiles[cur_tile].nb_nalus_in_sample++;\n\t\t\t\t\tif (signal_mode==1) {\n\t\t\t\t\t\tgf_bs_write_u16(bs, tiles[cur_tile].track_id);\n\t\t\t\t\t\tnb_nal_entries++;\n\t\t\t\t\t} else if (last_tile_group != tiles[cur_tile].track_id) {\n\t\t\t\t\t\tlast_tile_group = tiles[cur_tile].track_id;\n\t\t\t\t\t\tgf_bs_write_u8(bs, nb_nalus);\n\t\t\t\t\t\tgf_bs_write_u16(bs, tiles[cur_tile].track_id);\n\t\t\t\t\t\tnb_nal_entries++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_data(tiles[cur_tile].sample_data, (char *) data, nalu_size + nalu_size_length);\n\n\t\t\t\t\tif (! gf_isom_has_track_reference(file, track, GF_ISOM_REF_SABT, tiles[cur_tile].track_id)) {\n\t\t\t\t\t\tgf_isom_set_track_reference(file, track, GF_ISOM_REF_SABT, tiles[cur_tile].track_id);\n\t\t\t\t\t}\n\t\t\t\t\ttiles[cur_tile].data_offset += nalu_size + nalu_size_length;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (! signal_mode) {\n\t\t\t\t\tgf_bs_write_data(bs, (char *) data, nalu_size + nalu_size_length);\n\t\t\t\t} else {\n\t\t\t\t\tnb_nalus++;\n\t\t\t\t\tif (signal_mode==1) {\n\t\t\t\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\t\t\t\tnb_nal_entries++;\n\t\t\t\t\t} else if (last_tile_group != 0) {\n\t\t\t\t\t\tlast_tile_group = 0;\n\t\t\t\t\t\tgf_bs_write_u8(bs, nb_nalus);\n\t\t\t\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\t\t\t\tnb_nal_entries++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdata += nalu_size + nalu_size_length;\n\t\t\tsize -= nalu_size + nalu_size_length;\n\t\t}\n\n\t\tif (! signal_mode) {\n\t\t\tgf_free(sample->data);\n\t\t\tgf_bs_get_content(bs, &sample->data, &sample->dataLength);\n\t\t\tgf_bs_del(bs);\n\n\t\t\te = gf_isom_update_sample(file, track, i+1, sample, 1);\n\t\t\tif (e) goto err_exit;\n\n\t\t\tgf_free(sample->data);\n\t\t\tsample->data = NULL;\n\n\t\t\tfor (j=0; j<nb_tiles; j++) {\n\t\t\t\tsample->dataLength = 0;\n\t\t\t\tgf_bs_get_content(tiles[j].sample_data, &sample->data, &sample->dataLength);\n\t\t\t\tif (!sample->data)\n\t\t\t\t\tcontinue;\n\n\t\t\t\te = gf_isom_add_sample(file, tiles[j].track, 1, sample);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\ttiles[j].sample_count ++;\n\n\t\t\t\tgf_bs_del(tiles[j].sample_data);\n\t\t\t\ttiles[j].sample_data = NULL;\n\t\t\t\tgf_free(sample->data);\n\t\t\t\tsample->data = NULL;\n\n\t\t\t\te = gf_isom_copy_sample_info(file, tiles[j].track, file, track, i+1);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t}\n\t\t} else {\n\t\t\tu32 sdesc;\n\t\t\tdata=NULL;\n\t\t\tsize=0;\n\t\t\tgf_bs_get_content(bs, &data, &size);\n\t\t\tgf_bs_del(bs);\n\t\t\tdata[1] = nb_nal_entries;\n\n\t\t\te = gf_isom_add_sample_group_info(file, track, GF_ISOM_SAMPLE_GROUP_NALM, data, size, 1, &sdesc);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMF] Error defining NALM group description entry\\n\" ));\n\t\t\t} else {\n\t\t\t\te = gf_isom_add_sample_info(file, track, i+1, GF_ISOM_SAMPLE_GROUP_NALM, sdesc, GF_ISOM_SAMPLE_GROUP_TRIF);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMF] Error associating NALM group description to sample\\n\" ));\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_free(data);\n\t\t\tif (e) goto err_exit;\n\t\t}\n\n\t\tgf_isom_sample_del(&sample);\n\n\t}\n\n\n\tfor (i=0; i<nb_tiles; i++) {\n\t\tu32 width, height;\n\t\ts32 translation_x, translation_y;\n\t\ts16 layer;\n\n\t\tif (! signal_mode) {\n\t\t\ttiles[i].track = gf_isom_get_track_by_id(file, tiles[i].track_id);\n\t\t\tif (!tiles[i].sample_count) {\n\t\t\t\tgf_isom_remove_track(file, tiles[i].track);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\thevc_add_trif(file, tiles[i].track, tiles[i].track_id, GF_FALSE, (tiles[i].all_intra) ? 2 : 1, filter_disabled, tiles[i].tx, tiles[i].ty, tiles[i].tw, tiles[i].th, GF_TRUE);\n\t\t\tgf_isom_set_visual_info(file, tiles[i].track, 1, tiles[i].tw, tiles[i].th);\n\n\t\t\tgf_isom_get_track_layout_info(file, track, &width, &height, &translation_x, &translation_y, &layer);\n\t\t\tgf_isom_set_track_layout_info(file, tiles[i].track, width<<16, height<<16, translation_x, translation_y, layer);\n\t\t} else {\n\t\t\thevc_add_trif(file, track, tiles[i].track_id, GF_FALSE, (tiles[i].all_intra) ? 2 : 1, filter_disabled, tiles[i].tx, tiles[i].ty, tiles[i].tw, tiles[i].th, GF_FALSE);\n\t\t}\n\n\t}\n\n\nerr_exit:\n\tgf_free(tiles);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMF] Could not split HEVC tiles into tracks: %s\\n\", gf_error_to_string(e) ));\n\t}\n\treturn e;\n#endif\n}\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\n#endif /*GPAC_DISABLE_MEDIA_IMPORT*/\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\n#include <gpac/filters.h>\n\ntypedef struct\n{\n\tu32 filter_idx_plus_one;\n\tu32 last_prog;\n\tGF_FilterSession *fsess;\n} FragCallback;\n\nextern char gf_prog_lf;\n\nstatic Bool on_frag_event(void *_udta, GF_Event *evt)\n{\n\tu32 i, count;\n\tGF_FilterStats stats;\n\tFragCallback *fc = (FragCallback *)_udta;\n\tif (!_udta)\n\t\treturn GF_FALSE;\n\tif (evt && (evt->type != GF_EVENT_PROGRESS))\n\t\treturn GF_FALSE;\n\n\tstats.report_updated = GF_FALSE;\n\tif (!fc->filter_idx_plus_one) {\n\t\tcount = gf_fs_get_filters_count(fc->fsess);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tif (gf_fs_get_filter_stats(fc->fsess, i, &stats) != GF_OK) continue;\n\t\t\tif (strcmp(stats.reg_name, \"mp4mx\")) continue;\n\t\t\tfc->filter_idx_plus_one = i+1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!fc->filter_idx_plus_one) return GF_FALSE;\n\t} else {\n\t\tif (gf_fs_get_filter_stats(fc->fsess, fc->filter_idx_plus_one-1, &stats) != GF_OK)\n\t\t\treturn GF_FALSE;\n\t}\n\tif (! stats.report_updated) return GF_FALSE;\n\tif (stats.percent/100 == fc->last_prog) return GF_FALSE;\n\tfc->last_prog = stats.percent / 100;\n\n#ifndef GPAC_DISABLE_LOG\n\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"Fragmenting: % 2.2f %%%c\", ((Double)stats.percent) / 100, gf_prog_lf));\n#else\n\tfprintf(stderr, \"Fragmenting: % 2.2f %%%c\", ((Double)stats.percent) / 100, gf_prog_lf);\n#endif\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_media_fragment_file(GF_ISOFile *input, const char *output_file, Double max_duration_sec, Bool use_mfra)\n{\n\tchar szArgs[1024];\n\tFragCallback fc;\n\tGF_Err e = GF_OK;\n\tGF_Filter *f;\n\tGF_FilterSession *fsess = gf_fs_new_defaults(0);\n\n\tif (!fsess) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"Failed to create filter session\\n\"));\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\n\n\tsprintf(szArgs, \"mp4dmx:mov=%p\", input);\n\tf = gf_fs_load_filter(fsess, szArgs, &e);\n\tif (!f) return e;\n\n\tstrcpy(szArgs, \"reframer:FID=1\");\n\tf = gf_fs_load_filter(fsess, szArgs, &e);\n\tif (!f) return e;\n\n\tsprintf(szArgs, \"%s:SID=1:frag:cdur=%g:abs_offset:fragdur\", output_file, max_duration_sec);\n\tif (use_mfra)\n\t\tstrcat(szArgs, \":mfra\");\n\n\tf = gf_fs_load_destination(fsess, szArgs, NULL, NULL, &e);\n\tif (!f) return e;\n\n\tif (!gf_sys_is_test_mode()\n#ifndef GPAC_DISABLE_LOG\n\t\t&& (gf_log_get_tool_level(GF_LOG_APP)!=GF_LOG_QUIET)\n#endif\n\t\t&& !gf_sys_is_quiet()\n\t) {\n\t\tfc.last_prog=0;\n\t\tfc.fsess=fsess;\n\t\tfc.filter_idx_plus_one=0;\n\t\tgf_fs_enable_reporting(fsess, GF_TRUE);\n\t\tgf_fs_set_ui_callback(fsess, on_frag_event, &fc);\n\t}\n\n#ifdef GPAC_ENABLE_COVERAGE\n\tif (gf_sys_is_cov_mode())\n\t\ton_frag_event(NULL, NULL);\n#endif\n\n\te = gf_fs_run(fsess);\n\tif (e==GF_EOS) e = GF_OK;\n\tif (!e) e = gf_fs_get_last_connect_error(fsess);\n\tif (!e) e = gf_fs_get_last_process_error(fsess);\n\tgf_fs_del(fsess);\n\treturn e;\n}\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nGF_Err rfc_6381_get_codec_aac(char *szCodec, u32 codec_id,  u8 *dsi, u32 dsi_size, Bool force_sbr)\n{\n\tif (dsi && dsi_size) {\n\t\tu8 audio_object_type;\n\t\tif (dsi_size < 2) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[RFC6381] invalid DSI size %u < 2\\n\", dsi_size));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\t/*5 first bits of AAC config*/\n\t\taudio_object_type = (dsi[0] & 0xF8) >> 3;\n\t\tif (audio_object_type == 31) { /*escape code*/\n\t\t\tconst u8 audio_object_type_ext = ((dsi[0] & 0x07) << 3) + ((dsi[1] & 0xE0) >> 5);\n\t\t\taudio_object_type = 32 + audio_object_type_ext;\n\t\t}\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tif (force_sbr && (audio_object_type==2) ) {\n\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\tGF_Err e = gf_m4a_get_config(dsi, dsi_size, &a_cfg);\n\t\t\tif (e==GF_OK) {\n\t\t\t\tif (a_cfg.sbr_sr)\n\t\t\t\t\taudio_object_type = a_cfg.sbr_object_type;\n\t\t\t\tif (a_cfg.has_ps)\n\t\t\t\t\taudio_object_type = 29;\n\t\t\t}\n\t\t}\n#endif\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"mp4a.%02X.%01d\", gf_codecid_oti(codec_id), audio_object_type);\n\t\treturn GF_OK;\n\t}\n\n\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"mp4a.%02X\", codec_id);\n\n\tswitch (codec_id) {\n\tcase GF_CODECID_AAC_MPEG4:\n\tcase GF_CODECID_AAC_MPEG2_MP:\n\tcase GF_CODECID_AAC_MPEG2_LCP:\n\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\tcase GF_CODECID_USAC:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381] Cannot find AAC config, using default %s\\n\", szCodec));\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err rfc_6381_get_codec_m4v(char *szCodec, u32 codec_id, u8 *dsi, u32 dsi_size)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tif (dsi && dsi_size) {\n\t\tGF_M4VDecSpecInfo m4vc;\n\t\tgf_m4v_get_config(dsi, dsi_size, &m4vc);\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"mp4v.%02X.%01x\", codec_id, m4vc.VideoPL);\n\t\treturn GF_OK;\n\t}\n#endif\n\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"mp4v.%02X\", codec_id);\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381] Cannot find M4V config, using default %s\\n\", szCodec));\n\treturn GF_OK;\n}\n\nGF_Err rfc_6381_get_codec_avc(char *szCodec, u32 subtype, GF_AVCConfig *avcc)\n{\n\tassert(avcc);\n\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s.%02X%02X%02X\", gf_4cc_to_str(subtype), avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);\n\treturn GF_OK;\n}\n\nGF_Err rfc_6381_get_codec_hevc(char *szCodec, u32 subtype, GF_HEVCConfig *hvcc)\n{\n\tu8 c;\n\tchar szTemp[RFC6381_CODEC_NAME_SIZE_MAX];\n\tassert(hvcc);\n\n\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s.\", gf_4cc_to_str(subtype));\n\tif (hvcc->profile_space==1) strcat(szCodec, \"A\");\n\telse if (hvcc->profile_space==2) strcat(szCodec, \"B\");\n\telse if (hvcc->profile_space==3) strcat(szCodec, \"C\");\n\t//profile idc encoded as a decimal number\n\tsprintf(szTemp, \"%d\", hvcc->profile_idc);\n\tstrcat(szCodec, szTemp);\n\t//general profile compatibility flags: hexa, bit-reversed\n\t{\n\t\tu32 val = hvcc->general_profile_compatibility_flags;\n\t\tu32 i, res = 0;\n\t\tfor (i=0; i<32; i++) {\n\t\t\tres |= val & 1;\n\t\t\tif (i==31) break;\n\t\t\tres <<= 1;\n\t\t\tval >>=1;\n\t\t}\n\t\tsprintf(szTemp, \".%X\", res);\n\t\tstrcat(szCodec, szTemp);\n\t}\n\n\tif (hvcc->tier_flag) strcat(szCodec, \".H\");\n\telse strcat(szCodec, \".L\");\n\tsprintf(szTemp, \"%d\", hvcc->level_idc);\n\tstrcat(szCodec, szTemp);\n\n\tc = hvcc->progressive_source_flag << 7;\n\tc |= hvcc->interlaced_source_flag << 6;\n\tc |= hvcc->non_packed_constraint_flag << 5;\n\tc |= hvcc->frame_only_constraint_flag << 4;\n\tc |= (hvcc->constraint_indicator_flags >> 40);\n\tsprintf(szTemp, \".%X\", c);\n\tstrcat(szCodec, szTemp);\n\tif (hvcc->constraint_indicator_flags & 0xFFFFFFFF) {\n\t\tc = (hvcc->constraint_indicator_flags >> 32) & 0xFF;\n\t\tsprintf(szTemp, \".%X\", c);\n\t\tstrcat(szCodec, szTemp);\n\t\tif (hvcc->constraint_indicator_flags & 0x00FFFFFF) {\n\t\t\tc = (hvcc->constraint_indicator_flags >> 24) & 0xFF;\n\t\t\tsprintf(szTemp, \".%X\", c);\n\t\t\tstrcat(szCodec, szTemp);\n\t\t\tif (hvcc->constraint_indicator_flags & 0x0000FFFF) {\n\t\t\t\tc = (hvcc->constraint_indicator_flags >> 16) & 0xFF;\n\t\t\t\tsprintf(szTemp, \".%X\", c);\n\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\tif (hvcc->constraint_indicator_flags & 0x000000FF) {\n\t\t\t\t\tc = (hvcc->constraint_indicator_flags >> 8) & 0xFF;\n\t\t\t\t\tsprintf(szTemp, \".%X\", c);\n\t\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\t\tc = (hvcc->constraint_indicator_flags ) & 0xFF;\n\t\t\t\t\tsprintf(szTemp, \".%X\", c);\n\t\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err rfc_6381_get_codec_av1(char *szCodec, u32 subtype, GF_AV1Config *av1c, COLR colr)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tGF_Err e;\n\tu32 i = 0;\n\tAV1State av1_state;\n\tassert(av1c);\n\n\tgf_av1_init_state(&av1_state);\n\tav1_state.config = av1c;\n\n\tfor (i = 0; i < gf_list_count(av1c->obu_array); ++i) {\n\t\tGF_BitStream *bs;\n\t\tGF_AV1_OBUArrayEntry *a = gf_list_get(av1c->obu_array, i);\n\t\tbs = gf_bs_new(a->obu, a->obu_length, GF_BITSTREAM_READ);\n\t\tif (!av1_is_obu_header(a->obu_type))\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381] AV1: unexpected obu_type %d - Parsing anyway.\\n\", a->obu_type, gf_4cc_to_str(subtype)));\n\n\t\te = aom_av1_parse_temporal_unit_from_section5(bs, &av1_state);\n\t\tgf_bs_del(bs);\n\t\tbs = NULL;\n\t\tif (e) {\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s.%01u.%02u%c.%02u\", gf_4cc_to_str(subtype),\n\t\tav1_state.config->seq_profile, av1_state.config->seq_level_idx_0, av1_state.config->seq_tier_0 ? 'H' : 'M', av1_state.bit_depth);\n\n\tif (av1_state.color_description_present_flag) {\n\t\tchar tmp[RFC6381_CODEC_NAME_SIZE_MAX];\n\t\tsnprintf(tmp, RFC6381_CODEC_NAME_SIZE_MAX, \".%01u.%01u%01u%01u.%02u.%02u.%02u.%01u\",\n\t\t\tav1_state.config->monochrome, av1_state.config->chroma_subsampling_x, av1_state.config->chroma_subsampling_y,\n\t\t\tav1_state.config->chroma_subsampling_x && av1_state.config->chroma_subsampling_y ? av1_state.config->chroma_sample_position : 0,\n\t\t\tcolr.override == GF_TRUE ? colr.colour_primaries : av1_state.color_primaries,\n\t\t\tcolr.override == GF_TRUE ? colr.transfer_characteristics : av1_state.transfer_characteristics,\n\t\t\tcolr.override == GF_TRUE ? colr.matrix_coefficients : av1_state.matrix_coefficients,\n\t\t\tcolr.override == GF_TRUE ? colr.full_range : av1_state.color_range);\n\t\tstrcat(szCodec, tmp);\n\t} else {\n\t\tif ((av1_state.color_primaries == 2) && (av1_state.transfer_characteristics == 2) && (av1_state.matrix_coefficients == 2) && av1_state.color_range == GF_FALSE) {\n\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381] incoherent color characteristics primaries %d transfer %d matrix %d color range %d\\n\",\n\t\t\t\tav1_state.color_primaries, av1_state.transfer_characteristics, av1_state.matrix_coefficients, av1_state.color_range));\n\t\t}\n\t}\n\tgf_av1_reset_state(&av1_state, GF_TRUE);\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\nGF_Err rfc_6381_get_codec_vpx(char *szCodec, u32 subtype, GF_VPConfig *vpcc, COLR colr)\n{\n\tassert(vpcc);\n\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s.%02u.%02u.%02u.%02u.%02u.%02u.%02u.%02u\", gf_4cc_to_str(subtype),\n\t\tvpcc->profile,\n\t\tvpcc->level,\n\t\tvpcc->bit_depth,\n\t\tvpcc->chroma_subsampling,\n\t\tcolr.override == GF_TRUE ? colr.colour_primaries : vpcc->colour_primaries,\n\t\tcolr.override == GF_TRUE ? colr.transfer_characteristics : vpcc->transfer_characteristics,\n\t\tcolr.override == GF_TRUE ? colr.matrix_coefficients : vpcc->matrix_coefficients,\n\t\tcolr.override == GF_TRUE ? colr.full_range : vpcc->video_fullRange_flag);\n\treturn GF_OK;\n}\n\nGF_Err rfc_6381_get_codec_dolby_vision(char *szCodec, u32 subtype, GF_DOVIDecoderConfigurationRecord *dovi)\n{\n\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s.%02u.%02u\", gf_4cc_to_str(subtype), dovi->dv_profile, dovi->dv_level);\n\treturn GF_OK;\n}\n\nstatic char base32_chars[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\n\nGF_Err rfc_6381_get_codec_vvc(char *szCodec, u32 subtype, GF_VVCConfig *vvcc)\n{\n\tassert(vvcc);\n\tu32 i, pos, len;\n\n\tif ( (subtype==GF_4CC('v','v','c','N')) || (subtype==GF_4CC('v','v','s','1')) ) {\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s\", gf_4cc_to_str(subtype));\n\t} else {\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s.%d.%s%d\", gf_4cc_to_str(subtype), vvcc->general_profile_idc, vvcc->general_tier_flag ? \"H\" : \"L\", vvcc->general_level_idc);\n\t}\n\n\tu8 buf[256];\n\tGF_BitStream *bs = gf_bs_new(buf, 256, GF_BITSTREAM_WRITE);\n\tgf_bs_write_int(bs, vvcc->ptl_frame_only_constraint, 1);\n\tgf_bs_write_int(bs, vvcc->ptl_multilayer_enabled, 1);\n\tfor (i=0; i<vvcc->num_constraint_info; i++) {\n\t\tgf_bs_write_int(bs, vvcc->general_constraint_info[i], 8);\n\t}\n\tgf_bs_align(bs);\n\tpos = (u32) gf_bs_get_position(bs);\n\tgf_bs_del(bs);\n\twhile (pos && (buf[pos-1]==0)) {\n\t\tpos--;\n\t}\n\tif (!pos) {\n\t\tstrcat(szCodec, \".CA\");\n\t\treturn GF_OK;\n\t}\n\tstrcat(szCodec, \".C\");\n\tlen = (u32) strlen(szCodec);\n\tbs = gf_bs_new(buf, pos, GF_BITSTREAM_READ);\n\twhile (1) {\n\t\tu32 nb_bits = (u32) ( 8*gf_bs_available(bs) + gf_bs_bits_available(bs) );\n\t\tif (!nb_bits) break;\n\t\tif (nb_bits>5) nb_bits = 5;\n\t\tu32 c = gf_bs_read_int(bs, nb_bits);\n\t\twhile (nb_bits<5) {\n\t\t\tc <<= 1;\n\t\t\tnb_bits++;\n\t\t}\n\t\tchar b32_char = base32_chars[c];\n\t\t//should not happen, we use 100 bytes by default and max general_constraint_info is 63 bytes\n\t\tif (len >= RFC6381_CODEC_NAME_SIZE_MAX) {\n\t\t\tgf_bs_del(bs);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tszCodec[len] = b32_char;\n\t\tlen++;\n\t\tszCodec[len] = 0;\n\t}\n\tgf_bs_del(bs);\n\n\treturn GF_OK;\n}\nGF_Err rfc_6381_get_codec_mpegha(char *szCodec, u32 subtype, u8 *dsi, u32 dsi_size, s32 pl)\n{\n\tif (dsi && (dsi_size>=2) ) {\n\t\tpl = dsi[1];\n\t}\n\tif (pl<0) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[RFC6381] Cannot find MPEG-H Audio Config or audio PL, defaulting to profile 0x01\\n\"));\n\t}\n\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s.0x%02X\", gf_4cc_to_str(subtype), pl);\n\treturn GF_OK;\n}\n\nGF_Err rfc_6381_get_codec_uncv(char *szCodec, u32 subtype, u8 *dsi, u32 dsi_size);\n\n// Selected (namespace,identifier) pairs from https://www.w3.org/TR/ttml-profile-registry/\n// ordered in decreasing order of preference\nstatic const char *ttml_namespaces[] = {\n\t\"im3t\", \"http://www.w3.org/ns/ttml/profile/imsc1.2/text\",\n\t\"im2t\", \"http://www.w3.org/ns/ttml/profile/imsc1.1/text\",\n\t\"im2i\", \"http://www.w3.org/ns/ttml/profile/imsc1.1/image\",\n\t\"im1t\", \"http://www.w3.org/ns/ttml/profile/imsc1/text\",\n\t\"im1i\", \"http://www.w3.org/ns/ttml/profile/imsc1/image\"\n};\nstatic const int TTML_NAMESPACES_COUNT = GF_ARRAY_LENGTH(ttml_namespaces);\n\n\nGF_Err rfc_6381_get_codec_stpp(char *szCodec, u32 subtype,\n                               const char *xmlnamespace,\n                               const char *xml_schema_loc,\n                               const char *mimes)\n{\n    // we ignore schema location and auxiliary mime types\n    // we focus on the provided list of namespaces\n    if (xmlnamespace != NULL) {\n        int i;\n        for (i = 0; i < TTML_NAMESPACES_COUNT; i+=2) {\n            if(strstr(xmlnamespace, ttml_namespaces[i+1]) != NULL) {\n                snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s.%s.%s\", gf_4cc_to_str(subtype), \"ttml\", ttml_namespaces[i]);\n                return GF_OK;\n            }\n        }\n        // if none of the namespaces above have been found, search the default TTML namespace\n        if(strstr(xmlnamespace, \"http://www.w3.org/ns/ttml\")) {\n            snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s.%s\", gf_4cc_to_str(subtype), \"ttml\");\n            return GF_OK;\n        }\n    }\n    // None of the known namespaces are found, default\n    snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s\", gf_4cc_to_str(subtype));\n    return GF_OK;\n}\n\nGF_Err rfc6381_codec_name_default(char *szCodec, u32 subtype, u32 codec_id)\n{\n\tif (codec_id && (codec_id<GF_CODECID_LAST_MPEG4_MAPPING)) {\n\t\tu32 stype = gf_codecid_type(codec_id);\n\t\tif (stype==GF_STREAM_VISUAL)\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"mp4v.%02X\", codec_id);\n\t\telse if (stype==GF_STREAM_AUDIO)\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"mp4a.%02X\", codec_id);\n\t\telse\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"mp4s.%02X\", codec_id);\n\t} else {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[RFC6381] Codec parameters not known - using default value \\\"%s\\\"\\n\", gf_4cc_to_str(subtype) ));\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"%s\", gf_4cc_to_str(subtype));\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM\n\nGF_EXPORT\nGF_Err gf_media_get_rfc_6381_codec_name(GF_ISOFile *movie, u32 track, u32 stsd_idx, char *szCodec, Bool force_inband, Bool force_sbr)\n{\n\tGF_ESD *esd;\n\tGF_Err e;\n\tGF_AVCConfig *avcc;\n\tGF_HEVCConfig *hvcc;\n\tu32 subtype = gf_isom_get_media_subtype(movie, track, stsd_idx);\n\n\tif (subtype == GF_ISOM_SUBTYPE_MPEG4_CRYP) {\n\t\tu32 originalFormat=0;\n\t\tif (gf_isom_is_ismacryp_media(movie, track, stsd_idx)) {\n\t\t\te = gf_isom_get_ismacryp_info(movie, track, stsd_idx, &originalFormat, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\n\t\t} else if (gf_isom_is_omadrm_media(movie, track, stsd_idx)) {\n\t\t\te = gf_isom_get_omadrm_info(movie, track, stsd_idx, &originalFormat, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\n\t\t} else if(gf_isom_is_cenc_media(movie, track, stsd_idx)) {\n\t\t\te = gf_isom_get_cenc_info(movie, track, stsd_idx, &originalFormat, NULL, NULL);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[RFC6381] Unknown protection scheme type %s\\n\", gf_4cc_to_str( gf_isom_is_media_encrypted(movie, track, stsd_idx)) ));\n\t\t\te = gf_isom_get_original_format_type(movie, track, stsd_idx, &originalFormat);\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[RFC6381] Error fetching protection information\\n\"));\n\t\t\treturn e;\n\t\t}\n\n\t\tif (originalFormat) subtype = originalFormat;\n\t}\n\telse if (subtype==GF_ISOM_SUBTYPE_MPEG4) {\n\t\tu32 stsd_type = gf_isom_get_mpeg4_subtype(movie, track, stsd_idx);\n\t\tif (stsd_type==GF_ISOM_SUBTYPE_RESV)\n\t\t\tgf_isom_get_original_format_type(movie, track, stsd_idx, &subtype);\n\t}\n\n\tswitch (subtype) {\n\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\tesd = gf_isom_get_esd(movie, track, stsd_idx);\n\t\tif (esd && esd->decoderConfig) {\n\t\t\tswitch (esd->decoderConfig->streamType) {\n\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\t\t\te = rfc_6381_get_codec_aac(szCodec, esd->decoderConfig->objectTypeIndication, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, force_sbr);\n\t\t\t\t} else {\n\t\t\t\t\te = rfc_6381_get_codec_aac(szCodec, esd->decoderConfig->objectTypeIndication, NULL, 0, force_sbr);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_VISUAL:\n\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\t\t\te = rfc_6381_get_codec_m4v(szCodec, esd->decoderConfig->objectTypeIndication, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\t\t} else {\n\t\t\t\t\te = rfc_6381_get_codec_m4v(szCodec, esd->decoderConfig->objectTypeIndication, NULL, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \"mp4s.%02X\", esd->decoderConfig->objectTypeIndication);\n\t\t\t\te = GF_OK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\treturn e;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[RFC6381] Cannot find ESD. Aborting.\\n\"));\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tavcc = gf_isom_avc_config_get(movie, track, stsd_idx);\n\t\tif (force_inband) {\n\t\t\tif (subtype==GF_ISOM_SUBTYPE_AVC_H264)\n\t\t\t\tsubtype = GF_ISOM_SUBTYPE_AVC3_H264;\n\t\t\telse if (subtype==GF_ISOM_SUBTYPE_AVC2_H264)\n\t\t\t\tsubtype = GF_ISOM_SUBTYPE_AVC4_H264;\n\t\t}\n\t\tif (avcc) {\n\t\t\te = rfc_6381_get_codec_avc(szCodec, subtype, avcc);\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\treturn e;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[RFC6381] Cannot find AVC configuration box\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\tavcc = gf_isom_mvc_config_get(movie, track, stsd_idx);\n\t\tif (!avcc) avcc = gf_isom_svc_config_get(movie, track, stsd_idx);\n\t\tif (avcc) {\n\t\t\te = rfc_6381_get_codec_avc(szCodec, subtype, avcc);\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\treturn e;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[RFC6381] Cannot find SVC/MVC configuration box\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tcase GF_ISOM_SUBTYPE_HVC1:\n\tcase GF_ISOM_SUBTYPE_HEV1:\n\tcase GF_ISOM_SUBTYPE_HVC2:\n\tcase GF_ISOM_SUBTYPE_HEV2:\n\tcase GF_ISOM_SUBTYPE_HVT1:\n\tcase GF_ISOM_SUBTYPE_LHV1:\n\tcase GF_ISOM_SUBTYPE_LHE1:\n\n\t\tif (force_inband) {\n\t\t\tif (subtype==GF_ISOM_SUBTYPE_HVC1) subtype = GF_ISOM_SUBTYPE_HEV1;\n\t\t\telse if (subtype==GF_ISOM_SUBTYPE_HVC2) subtype = GF_ISOM_SUBTYPE_HEV2;\n\t\t}\n\t\thvcc = gf_isom_hevc_config_get(movie, track, stsd_idx);\n\t\tif (!hvcc) {\n\t\t\thvcc = gf_isom_lhvc_config_get(movie, track, stsd_idx);\n\t\t}\n\t\tif (subtype==GF_ISOM_SUBTYPE_HVT1) {\n\t\t\tu32 refTrack;\n\t\t\tgf_isom_get_reference(movie, track, GF_ISOM_REF_TBAS, stsd_idx, &refTrack);\n\t\t\tif (hvcc) gf_odf_hevc_cfg_del(hvcc);\n\t\t\thvcc = gf_isom_hevc_config_get(movie, refTrack, 1);\n\t\t}\n\t\tif (hvcc) {\n\t\t\te = rfc_6381_get_codec_hevc(szCodec, subtype, hvcc);\n\t\t\tgf_odf_hevc_cfg_del(hvcc);\n\t\t\treturn e;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[RFC6381] HEVCConfig not compliant\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tcase GF_ISOM_SUBTYPE_AV01:\n\t{\n\t\tGF_AV1Config *av1c = gf_isom_av1_config_get(movie, track, stsd_idx);\n\t\tif (av1c) {\n\t\t\tu32 colour_type;\n\t\t\tCOLR colr;\n\t\t\tmemset(&colr, 0, sizeof(colr));\n\t\t\tif (GF_OK == gf_isom_get_color_info(movie, track, stsd_idx, &colour_type, &colr.colour_primaries, &colr.transfer_characteristics, &colr.matrix_coefficients, &colr.full_range)) {\n\t\t\t\tcolr.override = GF_TRUE;\n\t\t\t}\n\t\t\te = rfc_6381_get_codec_av1(szCodec, subtype, av1c, colr);\n\t\t\tgf_odf_av1_cfg_del(av1c);\n\t\t\treturn e;\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[RFC6381] No config found for AV1 file (\\\"%s\\\") when computing RFC6381.\\n\", gf_4cc_to_str(subtype)));\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tcase GF_ISOM_SUBTYPE_VP08:\n\tcase GF_ISOM_SUBTYPE_VP09:\n\t{\n\t\tGF_VPConfig *vpcc = gf_isom_vp_config_get(movie, track, stsd_idx);\n\t\tif (vpcc) {\n\t\t\tu32 colour_type;\n\t\t\tCOLR colr;\n\t\t\tmemset(&colr, 0, sizeof(colr));\n\t\t\tif (GF_OK == gf_isom_get_color_info(movie, track, stsd_idx, &colour_type, &colr.colour_primaries, &colr.transfer_characteristics, &colr.matrix_coefficients, &colr.full_range)) {\n\t\t\t\tcolr.override = GF_TRUE;\n\t\t\t}\n\t\t\te = rfc_6381_get_codec_vpx(szCodec, subtype, vpcc, colr);\n\t\t\tgf_odf_vp_cfg_del(vpcc);\n\t\t\treturn e;\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[RFC6381] No config found for VP file (\\\"%s\\\") when computing RFC6381.\\n\", gf_4cc_to_str(subtype)));\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tcase GF_ISOM_SUBTYPE_DVHE:\n\tcase GF_ISOM_SUBTYPE_DVH1:\n\tcase GF_ISOM_SUBTYPE_DVA1:\n\tcase GF_ISOM_SUBTYPE_DVAV:\n\tcase GF_ISOM_SUBTYPE_DAV1:\n\t{\n\t\tGF_DOVIDecoderConfigurationRecord *dovi = gf_isom_dovi_config_get(movie, track, stsd_idx);\n\t\tif (!dovi) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[RFC6381] No config found for Dolby Vision file (\\\"%s\\\") when computing RFC6381.\\n\", gf_4cc_to_str(subtype)));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\te = rfc_6381_get_codec_dolby_vision(szCodec, subtype, dovi);\n\t\tgf_odf_dovi_cfg_del(dovi);\n\t\treturn e;\n\t}\n\n\tcase GF_ISOM_SUBTYPE_VVC1:\n\tcase GF_ISOM_SUBTYPE_VVI1:\n\t{\n\t\tGF_VVCConfig *vvcc = gf_isom_vvc_config_get(movie, track, stsd_idx);\n\t\tif (vvcc) {\n\t\t\tif (force_inband) subtype = GF_ISOM_SUBTYPE_VVI1;\n\n\t\t\te = rfc_6381_get_codec_vvc(szCodec, subtype, vvcc);\n\t\t\tgf_odf_vvc_cfg_del(vvcc);\n\t\t\treturn e;\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[RFC6381] No config found for VVC file (\\\"%s\\\") when computing RFC6381.\\n\", gf_4cc_to_str(subtype)));\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA2:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM2:\n\t{\n\t\tesd = gf_media_map_esd(movie, track, stsd_idx);\n\t\tif (!esd || !esd->decoderConfig || !esd->decoderConfig->decoderSpecificInfo\n\t\t\t|| !esd->decoderConfig->decoderSpecificInfo->data\n\t\t) {\n\t\t\te = rfc_6381_get_codec_mpegha(szCodec, subtype, NULL, 0, -1);\n\t\t} else {\n\t\t\te = rfc_6381_get_codec_mpegha(szCodec, subtype, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, -1);\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\treturn e;\n\t}\n\n\tcase GF_ISOM_SUBTYPE_UNCV:\n\t{\n\t\tGF_GenericSampleDescription *udesc = gf_isom_get_generic_sample_description(movie, track, stsd_idx);\n\n\t\te = rfc_6381_get_codec_uncv(szCodec, subtype, udesc ? udesc->extension_buf : NULL, udesc ? udesc->extension_buf_size : 0);\n\t\tif (udesc) {\n\t\t\tif (udesc->extension_buf) gf_free(udesc->extension_buf);\n\t\t\tgf_free(udesc);\n\t\t}\n\t\treturn e;\n\t}\n    case GF_ISOM_SUBTYPE_STPP:\n    {\n        const char *xmlnamespace;\n        const char *xml_schema_loc;\n        const char *mimes;\n        e = gf_isom_xml_subtitle_get_description(movie, track, stsd_idx,\n                                             &xmlnamespace, &xml_schema_loc, &mimes);\n        if (e == GF_OK) {\n            rfc_6381_get_codec_stpp(szCodec, subtype, xmlnamespace, xml_schema_loc, mimes);\n        }\n        return e;\n    }\n\tdefault:\n\t\treturn rfc6381_codec_name_default(szCodec, subtype, gf_codec_id_from_isobmf(subtype));\n\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err gf_media_av1_layer_size_get(GF_ISOFile *file, u32 trackNumber, u32 sample_number, u8 op_index, u32 layer_size[3])\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tu32 i;\n\tAV1State av1;\n\tObuType obu_type;\n\tu64 obu_size = 0;\n\tu32 hdr_size;\n\tGF_BitStream *bs;\n\tu32 sdidx;\n\tGF_ISOSample *samp;\n\tGF_Err e = GF_OK;\n\n\tsamp = gf_isom_get_sample(file, trackNumber, sample_number, &sdidx);\n\tif (!samp) return GF_BAD_PARAM;\n\n\tif (!sdidx) {\n\t\tgf_isom_sample_del(&samp);\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (gf_isom_get_media_subtype(file, trackNumber, sdidx) != GF_ISOM_SUBTYPE_AV01) {\n\t\tgf_isom_sample_del(&samp);\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tgf_av1_init_state(&av1);\n\tav1.config = gf_isom_av1_config_get(file, trackNumber, sdidx);\n\tif (!av1.config) {\n\t\tgf_isom_sample_del(&samp);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tfor (i=0; i<gf_list_count(av1.config->obu_array); i++) {\n\t\tGF_AV1_OBUArrayEntry *obu = gf_list_get(av1.config->obu_array, i);\n\t\tbs = gf_bs_new(obu->obu, (u32) obu->obu_length, GF_BITSTREAM_READ);\n\t\te = gf_av1_parse_obu(bs, &obu_type, &obu_size, &hdr_size, &av1);\n\t\tgf_bs_del(bs);\n\t\tif (e) break;\n\t}\n\n\tif (!e) {\n\t\tbs = gf_bs_new(samp->data, samp->dataLength, GF_BITSTREAM_READ);\n\t\twhile (gf_bs_available(bs)) {\n\t\t\te = gf_av1_parse_obu(bs, &obu_type, &obu_size, &hdr_size, &av1);\n\t\t\tif (e) break;\n\t\t}\n\t\tgf_bs_del(bs);\n\t}\n\tgf_isom_sample_del(&samp);\n\n  if (op_index > av1.operating_points_count) {\n    if (av1.config) gf_odf_av1_cfg_del(av1.config);\n    gf_av1_reset_state(&av1, GF_TRUE);\n    return GF_BAD_PARAM;\n  }\n\n\tfor (i=0; i<3; i++) {\n\t\tif (av1.layer_size[i+1]==av1.layer_size[i]) {\n\t\t\tlayer_size[i] = 0;\n\t\t} else {\n\t\t\tlayer_size[i] = av1.layer_size[i];\n\t\t}\n\t}\n\n\tif (av1.config) gf_odf_av1_cfg_del(av1.config);\n\tgf_av1_reset_state(&av1, GF_TRUE);\n\n\treturn e;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_EXPORT\nGF_Err gf_media_isom_apply_qt_key(GF_ISOFile *movie, const char *name, const char *val)\n{\n\tGF_Err e;\n\tu8 *data=NULL;\n\tGF_QT_UDTAKey key;\n\tif (!name) return GF_BAD_PARAM;\n\n\tmemset(&key, 0, sizeof(GF_QT_UDTAKey));\n\tkey.name = (char *) name;\n\tkey.ns = GF_4CC('m','d','t','a');\n\tchar *sep = strchr(name, '@');\n\tif (sep) {\n\t\tsep[0] = 0;\n\t\tkey.name = sep+1;\n\t\tif (strlen(name)!=4) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Unrecognize namespace \\\"%s\\\" for key %s\\n\", name, sep+1));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tkey.ns = GF_4CC(name[0], name[1],name[2],name[3]);\n\t\tsep[0] = '@';\n\t}\n\n\tif (!val || !val[0]) {\n\t\tkey.type = GF_QT_KEY_REMOVE;\n\t} else if (!strcmp(val, \"NULL\")) {\n\t\tkey.type = GF_QT_KEY_REMOVE;\n\t} else {\n\t\tkey.type = GF_QT_KEY_UTF8;\n\t\tkey.value.string = val;\n\n\t\tif (gf_file_exists(val)) {\n\t\t\te = gf_file_load_data(val, &data, &key.value.data.data_len);\n\t\t\tif (e!=GF_OK) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Failed to load file \\\"%s\\\" for key %s: %s\\n\", val, name, gf_error_to_string(e)));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tkey.value.data.data = data;\n\t\t\tkey.type = GF_QT_KEY_OPAQUE;\n\t\t\tif (strstr(val, \".bmp\")|| strstr(val, \".BMP\")) {\n\t\t\t\tkey.type = GF_QT_KEY_BMP;\n\t\t\t} else if (key.value.data.data_len>3) {\n\t\t\t\tif ((data[0]==0xFF) && (data[1]==0xD8) && (data[2]==0xFF)) {\n\t\t\t\t\tkey.type = GF_QT_KEY_JPEG;\n\t\t\t\t} else if ((data[0]==0x89) && (data[1]==0x50) && (data[2]==0x4E)) {\n\t\t\t\t\tkey.type = GF_QT_KEY_PNG;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tchar *force_str=NULL;\n\t\t\tif (val[0] == 'S') {\n\t\t\t\tforce_str = (char*)val+1;\n\t\t\t\tval++;\n\t\t\t}\n\t\t\tchar *rect_sep = strchr(val, '@');\n\t\t\tchar *pos_sep = strchr(val, 'x');\n\t\t\tchar *arr_sep = strchr(val, ',');\n\t\t\tif (rect_sep && pos_sep && (sscanf(val, \"%gx%g@%gx%g\", &key.value.rect.x, &key.value.rect.y, &key.value.rect.w, &key.value.rect.h) == 4)) {\n\t\t\t\tkey.type = GF_QT_KEY_RECTF;\n\t\t\t} else if (rect_sep && (sscanf(val, \"%g@%g\", &key.value.pos_size.x, &key.value.pos_size.y)==2)) {\n\t\t\t\tkey.type = GF_QT_KEY_SIZEF;\n\t\t\t} else if (pos_sep && (sscanf(val, \"%gx%g\", &key.value.pos_size.x, &key.value.pos_size.y)==2)) {\n\t\t\t\tkey.type = GF_QT_KEY_POINTF;\n\t\t\t} else if (arr_sep && strchr(arr_sep, ',')\n\t\t\t\t&& (sscanf(val, \"%lg,%lg,%lg,%lg,%lg,%lg,%lg,%lg,%lg\", &key.value.matrix[0], &key.value.matrix[1], &key.value.matrix[2]\n\t\t\t\t, &key.value.matrix[3], &key.value.matrix[4], &key.value.matrix[5]\n\t\t\t\t, &key.value.matrix[6], &key.value.matrix[7], &key.value.matrix[8]\n\t\t\t\t)==9)\n\t\t\t) {\n\t\t\t\tkey.type = GF_QT_KEY_MATRIXF;\n\t\t\t} else {\n\t\t\t\tBool force_flt=GF_FALSE,force_dbl=GF_FALSE,force_sign=GF_FALSE;\n\t\t\t\tu32 force_size=0;\n\t\t\t\twhile (1) {\n\t\t\t\t\tchar c = val[0];\n\t\t\t\t\tif (c=='f') force_flt = GF_TRUE;\n\t\t\t\t\telse if (c=='d') force_dbl = GF_TRUE;\n\t\t\t\t\telse if (c=='+') force_sign = GF_TRUE;\n\t\t\t\t\telse if (c=='b') force_size = 1;\n\t\t\t\t\telse if (c=='s') force_size = 2;\n\t\t\t\t\telse if (c=='l') force_size = 3;\n\t\t\t\t\telse if (c=='L') force_size = 4;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tval++;\n\t\t\t\t}\n\t\t\t\tif (arr_sep || strchr(val, '.') || force_dbl || force_flt) {\n\t\t\t\t\tDouble res;\n\t\t\t\t\tif (sscanf(val, \"%lg\", &res)==1) {\n\t\t\t\t\t\tkey.value.number = res;\n\t\t\t\t\t\tkey.type = force_flt ? GF_QT_KEY_FLOAT : GF_QT_KEY_DOUBLE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ts64 res;\n\t\t\t\t\tif (sscanf(val, LLD, &res)==1) {\n\t\t\t\t\t\tkey.value.sint = res;\n\t\t\t\t\t\tif (!force_sign && (key.value.sint>0)) {\n\t\t\t\t\t\t\tkey.value.uint = key.value.sint;\n\t\t\t\t\t\t\tif (force_size==1) key.type = GF_QT_KEY_UNSIGNED_8;\n\t\t\t\t\t\t\telse if (force_size==2) key.type = GF_QT_KEY_UNSIGNED_16;\n\t\t\t\t\t\t\telse if (force_size==3) key.type = GF_QT_KEY_UNSIGNED_32;\n\t\t\t\t\t\t\telse if (force_size==4) key.type = GF_QT_KEY_UNSIGNED_64;\n\t\t\t\t\t\t\telse key.type = GF_QT_KEY_UNSIGNED_VSIZE;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (force_size==1) key.type = GF_QT_KEY_SIGNED_8;\n\t\t\t\t\t\t\telse if (force_size==2) key.type = GF_QT_KEY_SIGNED_16;\n\t\t\t\t\t\t\telse if (force_size==3) key.type = GF_QT_KEY_SIGNED_32;\n\t\t\t\t\t\t\telse if (force_size==4) key.type = GF_QT_KEY_SIGNED_64;\n\t\t\t\t\t\t\telse key.type = GF_QT_KEY_SIGNED_VSIZE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (force_str && (key.type != GF_QT_KEY_UTF8)) {\n\t\t\t\tkey.type = GF_QT_KEY_UTF8;\n\t\t\t\tkey.value.string = force_str;\n\t\t\t}\n\t\t}\n\t}\n\n\te = gf_isom_set_qt_key(movie, &key);\n\tif (data) gf_free(data);\n\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Failed to add key %s: %s\\n\", name, gf_error_to_string(e) ));\n\t}\n\treturn e;\n}\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n\n#endif //GPAC_DISABLE_ISOM\n"], "filenames": ["src/media_tools/isom_tools.c"], "buggy_code_start_loc": [638], "buggy_code_end_loc": [3291], "fixing_code_start_loc": [638], "fixing_code_end_loc": [3296], "type": "NVD-CWE-noinfo", "message": "GPAC 2.3-DEV-rev605-gfc9e29089-master contains a SEGV in gpac/MP4Box in gf_media_change_pl /afltest/gpac/src/media_tools/isom_tools.c:3293:42.", "other": {"cve": {"id": "CVE-2023-46928", "sourceIdentifier": "cve@mitre.org", "published": "2023-11-01T15:15:08.753", "lastModified": "2023-11-08T19:31:58.797", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GPAC 2.3-DEV-rev605-gfc9e29089-master contains a SEGV in gpac/MP4Box in gf_media_change_pl /afltest/gpac/src/media_tools/isom_tools.c:3293:42."}, {"lang": "es", "value": "GPAC 2.3-DEV-rev605-gfc9e29089-master contiene un SEGV en gpac/MP4Box en gf_media_change_pl /afltest/gpac/src/media_tools/isom_tools.c:3293:42."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:2.3-dev-rev605-gfc9e29089-master:*:*:*:*:*:*:*", "matchCriteriaId": "276701A5-2ABB-4EDB-9E2A-96A6A9EA62D9"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/0753bf6d867343a80a044bf47a27d0b7accc8bf1", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/2661", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/0753bf6d867343a80a044bf47a27d0b7accc8bf1"}}