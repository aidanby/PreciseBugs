{"buggy_code": ["/**\n *\n * Static file server with compression Ulfius callback\n *\n * Copyright 2020-2022 Nicolas Mora <mail@babelouest.org>\n *\n * Version 20220425\n *\n * The MIT License (MIT)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * `files_path`: path to the DocumentRoot folder, can be relative or absolute\n * `url_prefix`: prefix used to access the callback function\n * `mime_types`: a `struct _u_map` containing a set of mime-types with file extension as key and mime-type as value\n * `mime_types_compressed`: A `string_array` structure containing the list of mime-types allowed for compression\n * `mime_types_compressed_size`: The number of elements in `mime_types_compressed`\n * `map_header`: a `struct _u_map` containing a set of headers that will be added to all responses within the `static_file_callback`\n * `redirect_on_404`: redirct uri on error 404, if NULL, send 404\n * `allow_gzip`: Set to true if you want to allow gzip compression (default true)\n * `allow_deflate`: Set to true if you want to allow deflate compression (default true)\n * `allow_cache_compressed`: set to true if you want to allow memory cache for compressed files (default true)\n * `lock`: mutex lock (do not touch this variable)\n * `gzip_files`: a `struct _u_map` containing cached gzip files\n * `deflate_files`: a `struct _u_map` containing cached deflate files\n *\n * example of mime-types used in Hutch:\n * {\n *   key = \".html\"\n *   value = \"text/html\"\n * },\n * {\n *   key = \".css\"\n *   value = \"text/css\"\n * },\n * {\n *   key = \".js\"\n *   value = \"application/javascript\"\n * },\n * {\n *   key = \".png\"\n *   value = \"image/png\"\n * },\n * {\n *   key = \".jpg\"\n *   value = \"image/jpeg\"\n * },\n * {\n *   key = \".jpeg\"\n *   value = \"image/jpeg\"\n * },\n * {\n *   key = \".ttf\"\n *   value = \"font/ttf\"\n * },\n * {\n *   key = \".woff\"\n *   value = \"font/woff\"\n * },\n * {\n *   key = \".woff2\"\n *   value = \"font/woff2\"\n * },\n * {\n *   key = \".map\"\n *   value = \"application/octet-stream\"\n * },\n * {\n *   key = \"*\"\n *   value = \"application/octet-stream\"\n * }\n *\n */\n#include <pthread.h>\n#include <zlib.h>\n#include <string.h>\n#include <ulfius.h>\n\n#include \"static_compressed_inmemory_website_callback.h\"\n\n#define U_COMPRESS_NONE 0\n#define U_COMPRESS_GZIP 1\n#define U_COMPRESS_DEFL 2\n\n#define U_ACCEPT_HEADER  \"Accept-Encoding\"\n#define U_CONTENT_HEADER \"Content-Encoding\"\n\n#define U_ACCEPT_GZIP    \"gzip\"\n#define U_ACCEPT_DEFLATE \"deflate\"\n\n#define U_GZIP_WINDOW_BITS 15\n#define U_GZIP_ENCODING    16\n\n#define CHUNK 0x4000\n\nstatic void * u_zalloc(void * q, unsigned n, unsigned m) {\n  (void)q;\n  return o_malloc((size_t) n * m);\n}\n\nstatic void u_zfree(void *q, void *p) {\n  (void)q;\n  o_free(p);\n}\n\n/**\n * Return the filename extension\n */\nstatic const char * get_filename_ext(const char *path) {\n    const char *dot = strrchr(path, '.');\n    if(!dot || dot == path) return \"*\";\n    if (strchr(dot, '?') != NULL) {\n      *strchr(dot, '?') = '\\0';\n    }\n    return dot;\n}\n\n/**\n * Streaming callback function to ease sending large files\n */\nstatic ssize_t callback_static_file_uncompressed_stream(void * cls, uint64_t pos, char * buf, size_t max) {\n  (void)(pos);\n  if (cls != NULL) {\n    return fread (buf, sizeof(char), max, (FILE *)cls);\n  } else {\n    return U_STREAM_END;\n  }\n}\n\n/**\n * Cleanup FILE* structure when streaming is complete\n */\nstatic void callback_static_file_uncompressed_stream_free(void * cls) {\n  if (cls != NULL) {\n    fclose((FILE *)cls);\n  }\n}\n\n/**\n * static file callback endpoint\n */\nstatic int callback_static_file_uncompressed (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  size_t length;\n  FILE * f;\n  char * file_requested, * file_path, * url_dup_save;\n  const char * content_type;\n  int ret = U_CALLBACK_CONTINUE;\n\n  if (user_data != NULL && ((struct _u_compressed_inmemory_website_config *)user_data)->files_path != NULL) {\n    file_requested = o_strdup(request->http_url);\n    url_dup_save = file_requested;\n\n    file_requested += o_strlen(((struct _u_compressed_inmemory_website_config *)user_data)->url_prefix);\n    while (file_requested[0] == '/') {\n      file_requested++;\n    }\n\n    if (strchr(file_requested, '#') != NULL) {\n      *strchr(file_requested, '#') = '\\0';\n    }\n\n    if (strchr(file_requested, '?') != NULL) {\n      *strchr(file_requested, '?') = '\\0';\n    }\n\n    if (file_requested == NULL || o_strnullempty(file_requested) || 0 == o_strcmp(\"/\", file_requested)) {\n      o_free(url_dup_save);\n      url_dup_save = file_requested = o_strdup(\"index.html\");\n    }\n\n    file_path = msprintf(\"%s/%s\", ((struct _u_compressed_inmemory_website_config *)user_data)->files_path, file_requested);\n\n    f = fopen (file_path, \"rb\");\n    if (f) {\n      fseek (f, 0, SEEK_END);\n      length = ftell (f);\n      fseek (f, 0, SEEK_SET);\n\n      content_type = u_map_get_case(&((struct _u_compressed_inmemory_website_config *)user_data)->mime_types, get_filename_ext(file_requested));\n      if (content_type == NULL) {\n        content_type = u_map_get(&((struct _u_compressed_inmemory_website_config *)user_data)->mime_types, \"*\");\n        y_log_message(Y_LOG_LEVEL_WARNING, \"Static File Server - Unknown mime type for extension %s\", get_filename_ext(file_requested));\n      }\n      u_map_put(response->map_header, \"Content-Type\", content_type);\n      u_map_copy_into(response->map_header, &((struct _u_compressed_inmemory_website_config *)user_data)->map_header);\n\n      if (ulfius_set_stream_response(response, 200, callback_static_file_uncompressed_stream, callback_static_file_uncompressed_stream_free, length, CHUNK, f) != U_OK) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Static File Server - Error ulfius_set_stream_response\");\n      }\n    } else {\n      if (((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404 == NULL) {\n        ret = U_CALLBACK_IGNORE;\n      } else {\n        ulfius_add_header_to_response(response, \"Location\", ((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404);\n        response->status = 302;\n      }\n    }\n    o_free(file_path);\n    o_free(url_dup_save);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Static File Server - Error, user_data is NULL or inconsistent\");\n    ret = U_CALLBACK_ERROR;\n  }\n  return ret;\n}\n\nint u_init_compressed_inmemory_website_config(struct _u_compressed_inmemory_website_config * config) {\n  int ret = U_OK;\n  pthread_mutexattr_t mutexattr;\n\n  if (config != NULL) {\n    config->files_path                 = NULL;\n    config->url_prefix                 = NULL;\n    config->redirect_on_404            = NULL;\n    config->allow_gzip                 = 1;\n    config->allow_deflate              = 1;\n    config->mime_types_compressed      = NULL;\n    config->mime_types_compressed_size = 0;\n    config->allow_cache_compressed     = 1;\n    if ((ret = u_map_init(&(config->mime_types))) != U_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"u_init_compressed_inmemory_website_config - Error u_map_init mime_types\");\n    } else if ((ret = u_map_init(&(config->map_header))) != U_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"u_init_compressed_inmemory_website_config - Error u_map_init map_header\");\n    } else if ((ret = u_map_init(&(config->gzip_files))) != U_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"u_init_compressed_inmemory_website_config - Error u_map_init gzip_files\");\n    } else if ((ret = u_map_init(&(config->deflate_files))) != U_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"u_init_compressed_inmemory_website_config - Error u_map_init deflate_files\");\n    } else {\n      pthread_mutexattr_init (&mutexattr);\n      pthread_mutexattr_settype(&mutexattr, PTHREAD_MUTEX_RECURSIVE);\n      if (pthread_mutex_init(&(config->lock), &mutexattr) != 0) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"u_init_compressed_inmemory_website_config - Error pthread_mutex_init\");\n        ret = U_ERROR;\n      }\n    }\n  }\n  return ret;\n}\n\nvoid u_clean_compressed_inmemory_website_config(struct _u_compressed_inmemory_website_config * config) {\n  if (config != NULL) {\n    u_map_clean(&(config->mime_types));\n    u_map_clean(&(config->map_header));\n    u_map_clean(&(config->gzip_files));\n    u_map_clean(&(config->deflate_files));\n    free_string_array(config->mime_types_compressed);\n    pthread_mutex_destroy(&(config->lock));\n  }\n}\n\nint u_add_mime_types_compressed(struct _u_compressed_inmemory_website_config * config, const char * mime_type) {\n  int ret;\n  if (config != NULL && !o_strnullempty(mime_type)) {\n    if ((config->mime_types_compressed = o_realloc(config->mime_types_compressed, (config->mime_types_compressed_size+2)*sizeof(char*))) != NULL) {\n      config->mime_types_compressed[config->mime_types_compressed_size] = o_strdup(mime_type);\n      config->mime_types_compressed[config->mime_types_compressed_size+1] = NULL;\n      config->mime_types_compressed_size++;\n      ret = U_OK;\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"u_add_mime_types_compressed - Error allocating resources for mime_types_compressed\");\n      ret = U_ERROR;\n    }\n  } else {\n    ret = U_ERROR_PARAMS;\n  }\n  return ret;\n}\n\nint callback_static_compressed_inmemory_website (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  struct _u_compressed_inmemory_website_config * config = (struct _u_compressed_inmemory_website_config *)user_data;\n  char ** accept_list = NULL;\n  int ret = U_CALLBACK_CONTINUE, compress_mode = U_COMPRESS_NONE, res;\n  z_stream defstream;\n  unsigned char * file_content, * file_content_orig = NULL;\n  size_t length, read_length, offset, data_zip_len = 0;\n  FILE * f;\n  char * file_requested, * file_path, * url_dup_save, * data_zip = NULL;\n  const char * content_type;\n\n  /*\n   * Comment this if statement if you don't access static files url from root dir, like /app\n   */\n  if (request->callback_position > 0) {\n    return U_CALLBACK_IGNORE;\n  } else {\n    file_requested = o_strdup(request->http_url);\n    url_dup_save = file_requested;\n\n    file_requested += o_strlen((config->url_prefix));\n    while (file_requested[0] == '/') {\n      file_requested++;\n    }\n\n    if (strchr(file_requested, '#') != NULL) {\n      *strchr(file_requested, '#') = '\\0';\n    }\n\n    if (strchr(file_requested, '?') != NULL) {\n      *strchr(file_requested, '?') = '\\0';\n    }\n\n    if (file_requested == NULL || o_strnullempty(file_requested) || 0 == o_strcmp(\"/\", file_requested)) {\n      o_free(url_dup_save);\n      url_dup_save = file_requested = o_strdup(\"index.html\");\n    }\n\n    if (!u_map_has_key_case(response->map_header, U_CONTENT_HEADER)) {\n      if (split_string(u_map_get_case(request->map_header, U_ACCEPT_HEADER), \",\", &accept_list)) {\n        if (config->allow_gzip && string_array_has_trimmed_value((const char **)accept_list, U_ACCEPT_GZIP)) {\n          compress_mode = U_COMPRESS_GZIP;\n        } else if (config->allow_deflate && string_array_has_trimmed_value((const char **)accept_list, U_ACCEPT_DEFLATE)) {\n          compress_mode = U_COMPRESS_DEFL;\n        }\n\n\n        if (compress_mode != U_COMPRESS_NONE) {\n          if (compress_mode == U_COMPRESS_GZIP && config->allow_cache_compressed && u_map_has_key(&config->gzip_files, file_requested)) {\n            ulfius_set_binary_body_response(response, 200, u_map_get(&config->gzip_files, file_requested), u_map_get_length(&config->gzip_files, file_requested));\n            u_map_put(response->map_header, U_CONTENT_HEADER, U_ACCEPT_GZIP);\n            \n            content_type = u_map_get_case(&config->mime_types, get_filename_ext(file_requested));\n            if (content_type == NULL) {\n              content_type = u_map_get(&config->mime_types, \"*\");\n            }\n            u_map_put(response->map_header, \"Content-Type\", content_type);\n            u_map_copy_into(response->map_header, &config->map_header);\n          } else if (compress_mode == U_COMPRESS_DEFL && config->allow_cache_compressed && u_map_has_key(&config->deflate_files, file_requested)) {\n            ulfius_set_binary_body_response(response, 200, u_map_get(&config->deflate_files, file_requested), u_map_get_length(&config->deflate_files, file_requested));\n            u_map_put(response->map_header, U_CONTENT_HEADER, U_ACCEPT_DEFLATE);\n            \n            content_type = u_map_get_case(&config->mime_types, get_filename_ext(file_requested));\n            if (content_type == NULL) {\n              content_type = u_map_get(&config->mime_types, \"*\");\n            }\n            u_map_put(response->map_header, \"Content-Type\", content_type);\n            u_map_copy_into(response->map_header, &config->map_header);\n          } else {\n            file_path = msprintf(\"%s/%s\", ((struct _u_compressed_inmemory_website_config *)user_data)->files_path, file_requested);\n\n            if (!pthread_mutex_lock(&config->lock)) {\n              f = fopen (file_path, \"rb\");\n              if (f) {\n                content_type = u_map_get_case(&config->mime_types, get_filename_ext(file_requested));\n                if (content_type == NULL) {\n                  content_type = u_map_get(&config->mime_types, \"*\");\n                  y_log_message(Y_LOG_LEVEL_WARNING, \"Static File Server - Unknown mime type for extension %s\", get_filename_ext(file_requested));\n                }\n                if (!string_array_has_value((const char **)config->mime_types_compressed, content_type)) {\n                  compress_mode = U_COMPRESS_NONE;\n                }\n\n                u_map_put(response->map_header, \"Content-Type\", content_type);\n                u_map_copy_into(response->map_header, &config->map_header);\n                \n                fseek (f, 0, SEEK_END);\n                offset = length = ftell (f);\n                fseek (f, 0, SEEK_SET);\n\n                if (length) {\n                  if ((file_content_orig = file_content = o_malloc(length)) != NULL && (data_zip = o_malloc((2*length)+20)) != NULL) {\n                    defstream.zalloc = u_zalloc;\n                    defstream.zfree = u_zfree;\n                    defstream.opaque = Z_NULL;\n                    defstream.avail_in = (uInt)length;\n                    defstream.next_in = (Bytef *)file_content;\n                    while ((read_length = fread(file_content, sizeof(char), offset, f))) {\n                      file_content += read_length;\n                      offset -= read_length;\n                    }\n\n                    if (compress_mode == U_COMPRESS_GZIP) {\n                      if (deflateInit2(&defstream,\n                                       Z_DEFAULT_COMPRESSION,\n                                       Z_DEFLATED,\n                                       U_GZIP_WINDOW_BITS | U_GZIP_ENCODING,\n                                       8,\n                                       Z_DEFAULT_STRATEGY) != Z_OK) {\n                        y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error deflateInit (gzip)\");\n                        ret = U_CALLBACK_ERROR;\n                      }\n                    } else {\n                      if (deflateInit(&defstream, Z_BEST_COMPRESSION) != Z_OK) {\n                        y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error deflateInit (deflate)\");\n                        ret = U_CALLBACK_ERROR;\n                      }\n                    }\n                    if (ret == U_CALLBACK_CONTINUE) {\n                      do {\n                        if ((data_zip = o_realloc(data_zip, data_zip_len+_U_W_BLOCK_SIZE)) != NULL) {\n                          defstream.avail_out = _U_W_BLOCK_SIZE;\n                          defstream.next_out = ((Bytef *)data_zip)+data_zip_len;\n                          switch ((res = deflate(&defstream, Z_FINISH))) {\n                            case Z_OK:\n                            case Z_STREAM_END:\n                            case Z_BUF_ERROR:\n                              break;\n                            default:\n                              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error deflate %d\", res);\n                              ret = U_CALLBACK_ERROR;\n                              break;\n                          }\n                          data_zip_len += _U_W_BLOCK_SIZE - defstream.avail_out;\n                        } else {\n                          y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error allocating resources for data_zip\");\n                          ret = U_CALLBACK_ERROR;\n                        }\n                      } while (U_CALLBACK_CONTINUE == ret && defstream.avail_out == 0);\n\n                      if (ret == U_CALLBACK_CONTINUE) {\n                        if (compress_mode == U_COMPRESS_GZIP) {\n                          if (config->allow_cache_compressed) {\n                            u_map_put_binary(&config->gzip_files, file_requested, data_zip, 0, defstream.total_out);\n                          }\n                          ulfius_set_binary_body_response(response, 200, u_map_get(&config->gzip_files, file_requested), u_map_get_length(&config->gzip_files, file_requested));\n                        } else {\n                          if (config->allow_cache_compressed) {\n                            u_map_put_binary(&config->deflate_files, file_requested, data_zip, 0, defstream.total_out);\n                          }\n                          ulfius_set_binary_body_response(response, 200, u_map_get(&config->deflate_files, file_requested), u_map_get_length(&config->deflate_files, file_requested));\n                        }\n                        u_map_put(response->map_header, U_CONTENT_HEADER, compress_mode==U_COMPRESS_GZIP?U_ACCEPT_GZIP:U_ACCEPT_DEFLATE);\n                      }\n                    }\n                    deflateEnd(&defstream);\n                    o_free(data_zip);\n                  } else {\n                    y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error allocating resource for file_content or data_zip\");\n                    ret = U_CALLBACK_ERROR;\n                  }\n                  o_free(file_content_orig);\n                }\n                fclose(f);\n              } else {\n                if (((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404 == NULL) {\n                  ret = U_CALLBACK_IGNORE;\n                } else {\n                  ulfius_add_header_to_response(response, \"Location\", ((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404);\n                  response->status = 302;\n                }\n              }\n              pthread_mutex_unlock(&config->lock);\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error pthread_lock_mutex\");\n              ret = U_CALLBACK_ERROR;\n            }\n            o_free(file_path);\n          }\n        } else {\n          ret = callback_static_file_uncompressed(request, response, user_data);\n        }\n        free_string_array(accept_list);\n      }\n    }\n    o_free(url_dup_save);\n  }\n\n  return ret;\n}\n", "/**\n *\n * Static file server with compression Ulfius callback\n *\n * Copyright 2020-2022 Nicolas Mora <mail@babelouest.org>\n *\n * Version 20220425\n * \n * The MIT License (MIT)\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * `files_path`: path to the DocumentRoot folder, can be relative or absolute\n * `url_prefix`: prefix used to access the callback function\n * `mime_types`: a `struct _u_map` containing a set of mime-types with file extension as key and mime-type as value\n * `mime_types_compressed`: A `string_array` structure containing the list of mime-types allowed for compression\n * `mime_types_compressed_size`: The number of elements in `mime_types_compressed`\n * `map_header`: a `struct _u_map` containing a set of headers that will be added to all responses within the `static_file_callback`\n * `redirect_on_404`: redirct uri on error 404, if NULL, send 404\n * `allow_gzip`: Set to true if you want to allow gzip compression (default true)\n * `allow_deflate`: Set to true if you want to allow deflate compression (default true)\n * `allow_cache_compressed`: set to true if you want to allow memory cache for compressed files (default true)\n * `lock`: mutex lock (do not touch this variable)\n * `gzip_files`: a `struct _u_map` containing cached gzip files\n * `deflate_files`: a `struct _u_map` containing cached deflate files\n * \n * example of mime-types used in Hutch:\n * {\n *   key = \".html\"\n *   value = \"text/html\"\n * },\n * {\n *   key = \".css\"\n *   value = \"text/css\"\n * },\n * {\n *   key = \".js\"\n *   value = \"application/javascript\"\n * },\n * {\n *   key = \".png\"\n *   value = \"image/png\"\n * },\n * {\n *   key = \".jpg\"\n *   value = \"image/jpeg\"\n * },\n * {\n *   key = \".jpeg\"\n *   value = \"image/jpeg\"\n * },\n * {\n *   key = \".ttf\"\n *   value = \"font/ttf\"\n * },\n * {\n *   key = \".woff\"\n *   value = \"font/woff\"\n * },\n * {\n *   key = \".woff2\"\n *   value = \"font/woff2\"\n * },\n * {\n *   key = \".map\"\n *   value = \"application/octet-stream\"\n * },\n * {\n *   key = \"*\"\n *   value = \"application/octet-stream\"\n * }\n * \n */\n\n#ifndef _U_STATIC_COMPRESSED_INMEMORY_WEBSITE\n#define _U_STATIC_COMPRESSED_INMEMORY_WEBSITE\n\n#define _U_W_BLOCK_SIZE 256\n\nstruct _u_compressed_inmemory_website_config {\n  char          * files_path;\n  char          * url_prefix;\n  struct _u_map   mime_types;\n  char **         mime_types_compressed;\n  size_t          mime_types_compressed_size;\n  struct _u_map   map_header;\n  char          * redirect_on_404;\n  int             allow_gzip;\n  int             allow_deflate;\n  int             allow_cache_compressed;\n  pthread_mutex_t lock;\n  struct _u_map   gzip_files;\n  struct _u_map   deflate_files;\n};\n\nint u_init_compressed_inmemory_website_config(struct _u_compressed_inmemory_website_config * config);\n\nvoid u_clean_compressed_inmemory_website_config(struct _u_compressed_inmemory_website_config * config);\n\nint u_add_mime_types_compressed(struct _u_compressed_inmemory_website_config * config, const char * mime_type);\n\nint callback_static_compressed_inmemory_website (const struct _u_request * request, struct _u_response * response, void * user_data);\n\n#endif\n"], "fixing_code": ["/**\n *\n * Static file server with compression Ulfius callback\n *\n * Copyright 2020-2022 Nicolas Mora <mail@babelouest.org>\n *\n * Version 20220428\n *\n * The MIT License (MIT)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * `files_path`: path to the DocumentRoot folder, can be relative or absolute\n * `url_prefix`: prefix used to access the callback function\n * `mime_types`: a `struct _u_map` containing a set of mime-types with file extension as key and mime-type as value\n * `mime_types_compressed`: A `string_array` structure containing the list of mime-types allowed for compression\n * `mime_types_compressed_size`: The number of elements in `mime_types_compressed`\n * `map_header`: a `struct _u_map` containing a set of headers that will be added to all responses within the `static_file_callback`\n * `redirect_on_404`: redirct uri on error 404, if NULL, send 404\n * `allow_gzip`: Set to true if you want to allow gzip compression (default true)\n * `allow_deflate`: Set to true if you want to allow deflate compression (default true)\n * `allow_cache_compressed`: set to true if you want to allow memory cache for compressed files (default true)\n * `lock`: mutex lock (do not touch this variable)\n * `gzip_files`: a `struct _u_map` containing cached gzip files\n * `deflate_files`: a `struct _u_map` containing cached deflate files\n *\n * example of mime-types used in Hutch:\n * {\n *   key = \".html\"\n *   value = \"text/html\"\n * },\n * {\n *   key = \".css\"\n *   value = \"text/css\"\n * },\n * {\n *   key = \".js\"\n *   value = \"application/javascript\"\n * },\n * {\n *   key = \".png\"\n *   value = \"image/png\"\n * },\n * {\n *   key = \".jpg\"\n *   value = \"image/jpeg\"\n * },\n * {\n *   key = \".jpeg\"\n *   value = \"image/jpeg\"\n * },\n * {\n *   key = \".ttf\"\n *   value = \"font/ttf\"\n * },\n * {\n *   key = \".woff\"\n *   value = \"font/woff\"\n * },\n * {\n *   key = \".woff2\"\n *   value = \"font/woff2\"\n * },\n * {\n *   key = \".map\"\n *   value = \"application/octet-stream\"\n * },\n * {\n *   key = \"*\"\n *   value = \"application/octet-stream\"\n * }\n *\n */\n#include <pthread.h>\n#include <zlib.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ulfius.h>\n\n#include \"static_compressed_inmemory_website_callback.h\"\n\n#define U_COMPRESS_NONE 0\n#define U_COMPRESS_GZIP 1\n#define U_COMPRESS_DEFL 2\n\n#define U_ACCEPT_HEADER  \"Accept-Encoding\"\n#define U_CONTENT_HEADER \"Content-Encoding\"\n\n#define U_ACCEPT_GZIP    \"gzip\"\n#define U_ACCEPT_DEFLATE \"deflate\"\n\n#define U_GZIP_WINDOW_BITS 15\n#define U_GZIP_ENCODING    16\n\n#define CHUNK 0x4000\n\nstatic void * u_zalloc(void * q, unsigned n, unsigned m) {\n  (void)q;\n  return o_malloc((size_t) n * m);\n}\n\nstatic void u_zfree(void *q, void *p) {\n  (void)q;\n  o_free(p);\n}\n\n/**\n * Return the filename extension\n */\nstatic const char * get_filename_ext(const char *path) {\n    const char *dot = strrchr(path, '.');\n    if(!dot || dot == path) return \"*\";\n    if (strchr(dot, '?') != NULL) {\n      *strchr(dot, '?') = '\\0';\n    }\n    return dot;\n}\n\n/**\n * Streaming callback function to ease sending large files\n */\nstatic ssize_t callback_static_file_uncompressed_stream(void * cls, uint64_t pos, char * buf, size_t max) {\n  (void)(pos);\n  if (cls != NULL) {\n    return fread (buf, sizeof(char), max, (FILE *)cls);\n  } else {\n    return U_STREAM_END;\n  }\n}\n\n/**\n * Cleanup FILE* structure when streaming is complete\n */\nstatic void callback_static_file_uncompressed_stream_free(void * cls) {\n  if (cls != NULL) {\n    fclose((FILE *)cls);\n  }\n}\n\n/**\n * static file callback endpoint\n */\nstatic int callback_static_file_uncompressed (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  size_t length;\n  FILE * f;\n  char * file_requested, * file_path, * url_dup_save, * real_path = NULL;\n  const char * content_type;\n  int ret = U_CALLBACK_CONTINUE;\n\n  if (user_data != NULL && ((struct _u_compressed_inmemory_website_config *)user_data)->files_path != NULL) {\n    file_requested = o_strdup(request->http_url);\n    url_dup_save = file_requested;\n\n    file_requested += o_strlen(((struct _u_compressed_inmemory_website_config *)user_data)->url_prefix);\n    while (file_requested[0] == '/') {\n      file_requested++;\n    }\n\n    if (strchr(file_requested, '#') != NULL) {\n      *strchr(file_requested, '#') = '\\0';\n    }\n\n    if (strchr(file_requested, '?') != NULL) {\n      *strchr(file_requested, '?') = '\\0';\n    }\n\n    if (file_requested == NULL || o_strnullempty(file_requested) || 0 == o_strcmp(\"/\", file_requested)) {\n      o_free(url_dup_save);\n      url_dup_save = file_requested = o_strdup(\"index.html\");\n    }\n\n    file_path = msprintf(\"%s/%s\", ((struct _u_compressed_inmemory_website_config *)user_data)->files_path, file_requested);\n    real_path = realpath(file_path, NULL);\n    if (0 == o_strncmp(((struct _u_compressed_inmemory_website_config *)user_data)->files_path, real_path, o_strlen(((struct _u_compressed_inmemory_website_config *)user_data)->files_path))) {\n      f = fopen (file_path, \"rb\");\n      if (f) {\n        fseek (f, 0, SEEK_END);\n        length = ftell (f);\n        fseek (f, 0, SEEK_SET);\n\n        content_type = u_map_get_case(&((struct _u_compressed_inmemory_website_config *)user_data)->mime_types, get_filename_ext(file_requested));\n        if (content_type == NULL) {\n          content_type = u_map_get(&((struct _u_compressed_inmemory_website_config *)user_data)->mime_types, \"*\");\n          y_log_message(Y_LOG_LEVEL_WARNING, \"Static File Server - Unknown mime type for extension %s\", get_filename_ext(file_requested));\n        }\n        u_map_put(response->map_header, \"Content-Type\", content_type);\n        u_map_copy_into(response->map_header, &((struct _u_compressed_inmemory_website_config *)user_data)->map_header);\n\n        if (ulfius_set_stream_response(response, 200, callback_static_file_uncompressed_stream, callback_static_file_uncompressed_stream_free, length, CHUNK, f) != U_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"Static File Server - Error ulfius_set_stream_response\");\n        }\n      } else {\n        if (((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404 == NULL) {\n          ret = U_CALLBACK_IGNORE;\n        } else {\n          ulfius_add_header_to_response(response, \"Location\", ((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404);\n          response->status = 302;\n        }\n      }\n      o_free(url_dup_save);\n    } else {\n      response->status = 403;\n    }\n    o_free(file_path);\n    free(real_path); // realpath uses malloc\n\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Static File Server - Error, user_data is NULL or inconsistent\");\n    ret = U_CALLBACK_ERROR;\n  }\n  return ret;\n}\n\nint u_init_compressed_inmemory_website_config(struct _u_compressed_inmemory_website_config * config) {\n  int ret = U_OK;\n  pthread_mutexattr_t mutexattr;\n\n  if (config != NULL) {\n    config->files_path                 = NULL;\n    config->url_prefix                 = NULL;\n    config->redirect_on_404            = NULL;\n    config->allow_gzip                 = 1;\n    config->allow_deflate              = 1;\n    config->mime_types_compressed      = NULL;\n    config->mime_types_compressed_size = 0;\n    config->allow_cache_compressed     = 1;\n    if ((ret = u_map_init(&(config->mime_types))) != U_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"u_init_compressed_inmemory_website_config - Error u_map_init mime_types\");\n    } else if ((ret = u_map_init(&(config->map_header))) != U_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"u_init_compressed_inmemory_website_config - Error u_map_init map_header\");\n    } else if ((ret = u_map_init(&(config->gzip_files))) != U_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"u_init_compressed_inmemory_website_config - Error u_map_init gzip_files\");\n    } else if ((ret = u_map_init(&(config->deflate_files))) != U_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"u_init_compressed_inmemory_website_config - Error u_map_init deflate_files\");\n    } else {\n      pthread_mutexattr_init (&mutexattr);\n      pthread_mutexattr_settype(&mutexattr, PTHREAD_MUTEX_RECURSIVE);\n      if (pthread_mutex_init(&(config->lock), &mutexattr) != 0) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"u_init_compressed_inmemory_website_config - Error pthread_mutex_init\");\n        ret = U_ERROR;\n      }\n    }\n  }\n  return ret;\n}\n\nvoid u_clean_compressed_inmemory_website_config(struct _u_compressed_inmemory_website_config * config) {\n  if (config != NULL) {\n    u_map_clean(&(config->mime_types));\n    u_map_clean(&(config->map_header));\n    u_map_clean(&(config->gzip_files));\n    u_map_clean(&(config->deflate_files));\n    free_string_array(config->mime_types_compressed);\n    pthread_mutex_destroy(&(config->lock));\n  }\n}\n\nint u_add_mime_types_compressed(struct _u_compressed_inmemory_website_config * config, const char * mime_type) {\n  int ret;\n  if (config != NULL && !o_strnullempty(mime_type)) {\n    if ((config->mime_types_compressed = o_realloc(config->mime_types_compressed, (config->mime_types_compressed_size+2)*sizeof(char*))) != NULL) {\n      config->mime_types_compressed[config->mime_types_compressed_size] = o_strdup(mime_type);\n      config->mime_types_compressed[config->mime_types_compressed_size+1] = NULL;\n      config->mime_types_compressed_size++;\n      ret = U_OK;\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"u_add_mime_types_compressed - Error allocating resources for mime_types_compressed\");\n      ret = U_ERROR;\n    }\n  } else {\n    ret = U_ERROR_PARAMS;\n  }\n  return ret;\n}\n\nint callback_static_compressed_inmemory_website (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  struct _u_compressed_inmemory_website_config * config = (struct _u_compressed_inmemory_website_config *)user_data;\n  char ** accept_list = NULL;\n  int ret = U_CALLBACK_CONTINUE, compress_mode = U_COMPRESS_NONE, res;\n  z_stream defstream;\n  unsigned char * file_content, * file_content_orig = NULL;\n  size_t length, read_length, offset, data_zip_len = 0;\n  FILE * f;\n  char * file_requested, * file_path, * url_dup_save, * data_zip = NULL, * real_path = NULL;\n  const char * content_type;\n\n  /*\n   * Comment this if statement if you don't access static files url from root dir, like /app\n   */\n  if (request->callback_position > 0) {\n    return U_CALLBACK_IGNORE;\n  } else {\n    file_requested = o_strdup(request->http_url);\n    url_dup_save = file_requested;\n\n    file_requested += o_strlen((config->url_prefix));\n    while (file_requested[0] == '/') {\n      file_requested++;\n    }\n\n    if (strchr(file_requested, '#') != NULL) {\n      *strchr(file_requested, '#') = '\\0';\n    }\n\n    if (strchr(file_requested, '?') != NULL) {\n      *strchr(file_requested, '?') = '\\0';\n    }\n\n    if (file_requested == NULL || o_strnullempty(file_requested) || 0 == o_strcmp(\"/\", file_requested)) {\n      o_free(url_dup_save);\n      url_dup_save = file_requested = o_strdup(\"index.html\");\n    }\n\n    if (!u_map_has_key_case(response->map_header, U_CONTENT_HEADER)) {\n      if (split_string(u_map_get_case(request->map_header, U_ACCEPT_HEADER), \",\", &accept_list)) {\n        if (config->allow_gzip && string_array_has_trimmed_value((const char **)accept_list, U_ACCEPT_GZIP)) {\n          compress_mode = U_COMPRESS_GZIP;\n        } else if (config->allow_deflate && string_array_has_trimmed_value((const char **)accept_list, U_ACCEPT_DEFLATE)) {\n          compress_mode = U_COMPRESS_DEFL;\n        }\n\n        if (compress_mode != U_COMPRESS_NONE) {\n          if (compress_mode == U_COMPRESS_GZIP && config->allow_cache_compressed && u_map_has_key(&config->gzip_files, file_requested)) {\n            ulfius_set_binary_body_response(response, 200, u_map_get(&config->gzip_files, file_requested), u_map_get_length(&config->gzip_files, file_requested));\n            u_map_put(response->map_header, U_CONTENT_HEADER, U_ACCEPT_GZIP);\n\n            content_type = u_map_get_case(&config->mime_types, get_filename_ext(file_requested));\n            if (content_type == NULL) {\n              content_type = u_map_get(&config->mime_types, \"*\");\n            }\n            u_map_put(response->map_header, \"Content-Type\", content_type);\n            u_map_copy_into(response->map_header, &config->map_header);\n          } else if (compress_mode == U_COMPRESS_DEFL && config->allow_cache_compressed && u_map_has_key(&config->deflate_files, file_requested)) {\n            ulfius_set_binary_body_response(response, 200, u_map_get(&config->deflate_files, file_requested), u_map_get_length(&config->deflate_files, file_requested));\n            u_map_put(response->map_header, U_CONTENT_HEADER, U_ACCEPT_DEFLATE);\n\n            content_type = u_map_get_case(&config->mime_types, get_filename_ext(file_requested));\n            if (content_type == NULL) {\n              content_type = u_map_get(&config->mime_types, \"*\");\n            }\n            u_map_put(response->map_header, \"Content-Type\", content_type);\n            u_map_copy_into(response->map_header, &config->map_header);\n          } else {\n            file_path = msprintf(\"%s/%s\", ((struct _u_compressed_inmemory_website_config *)user_data)->files_path, file_requested);\n            real_path = realpath(file_path, NULL);\n            if (0 == o_strncmp(((struct _u_compressed_inmemory_website_config *)user_data)->files_path, real_path, o_strlen(((struct _u_compressed_inmemory_website_config *)user_data)->files_path))) {\n              if (!pthread_mutex_lock(&config->lock)) {\n                f = fopen (file_path, \"rb\");\n                if (f) {\n                  content_type = u_map_get_case(&config->mime_types, get_filename_ext(file_requested));\n                  if (content_type == NULL) {\n                    content_type = u_map_get(&config->mime_types, \"*\");\n                    y_log_message(Y_LOG_LEVEL_WARNING, \"Static File Server - Unknown mime type for extension %s\", get_filename_ext(file_requested));\n                  }\n                  if (!string_array_has_value((const char **)config->mime_types_compressed, content_type)) {\n                    compress_mode = U_COMPRESS_NONE;\n                  }\n\n                  u_map_put(response->map_header, \"Content-Type\", content_type);\n                  u_map_copy_into(response->map_header, &config->map_header);\n\n                  fseek (f, 0, SEEK_END);\n                  offset = length = ftell (f);\n                  fseek (f, 0, SEEK_SET);\n\n                  if (length) {\n                    if ((file_content_orig = file_content = o_malloc(length)) != NULL && (data_zip = o_malloc((2*length)+20)) != NULL) {\n                      defstream.zalloc = u_zalloc;\n                      defstream.zfree = u_zfree;\n                      defstream.opaque = Z_NULL;\n                      defstream.avail_in = (uInt)length;\n                      defstream.next_in = (Bytef *)file_content;\n                      while ((read_length = fread(file_content, sizeof(char), offset, f))) {\n                        file_content += read_length;\n                        offset -= read_length;\n                      }\n\n                      if (compress_mode == U_COMPRESS_GZIP) {\n                        if (deflateInit2(&defstream,\n                                         Z_DEFAULT_COMPRESSION,\n                                         Z_DEFLATED,\n                                         U_GZIP_WINDOW_BITS | U_GZIP_ENCODING,\n                                         8,\n                                         Z_DEFAULT_STRATEGY) != Z_OK) {\n                          y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error deflateInit (gzip)\");\n                          ret = U_CALLBACK_ERROR;\n                        }\n                      } else {\n                        if (deflateInit(&defstream, Z_BEST_COMPRESSION) != Z_OK) {\n                          y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error deflateInit (deflate)\");\n                          ret = U_CALLBACK_ERROR;\n                        }\n                      }\n                      if (ret == U_CALLBACK_CONTINUE) {\n                        do {\n                          if ((data_zip = o_realloc(data_zip, data_zip_len+_U_W_BLOCK_SIZE)) != NULL) {\n                            defstream.avail_out = _U_W_BLOCK_SIZE;\n                            defstream.next_out = ((Bytef *)data_zip)+data_zip_len;\n                            switch ((res = deflate(&defstream, Z_FINISH))) {\n                              case Z_OK:\n                              case Z_STREAM_END:\n                              case Z_BUF_ERROR:\n                                break;\n                              default:\n                                y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error deflate %d\", res);\n                                ret = U_CALLBACK_ERROR;\n                                break;\n                            }\n                            data_zip_len += _U_W_BLOCK_SIZE - defstream.avail_out;\n                          } else {\n                            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error allocating resources for data_zip\");\n                            ret = U_CALLBACK_ERROR;\n                          }\n                        } while (U_CALLBACK_CONTINUE == ret && defstream.avail_out == 0);\n\n                        if (ret == U_CALLBACK_CONTINUE) {\n                          if (compress_mode == U_COMPRESS_GZIP) {\n                            if (config->allow_cache_compressed) {\n                              u_map_put_binary(&config->gzip_files, file_requested, data_zip, 0, defstream.total_out);\n                            }\n                            ulfius_set_binary_body_response(response, 200, u_map_get(&config->gzip_files, file_requested), u_map_get_length(&config->gzip_files, file_requested));\n                          } else {\n                            if (config->allow_cache_compressed) {\n                              u_map_put_binary(&config->deflate_files, file_requested, data_zip, 0, defstream.total_out);\n                            }\n                            ulfius_set_binary_body_response(response, 200, u_map_get(&config->deflate_files, file_requested), u_map_get_length(&config->deflate_files, file_requested));\n                          }\n                          u_map_put(response->map_header, U_CONTENT_HEADER, compress_mode==U_COMPRESS_GZIP?U_ACCEPT_GZIP:U_ACCEPT_DEFLATE);\n                        }\n                      }\n                      deflateEnd(&defstream);\n                      o_free(data_zip);\n                    } else {\n                      y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error allocating resource for file_content or data_zip\");\n                      ret = U_CALLBACK_ERROR;\n                    }\n                    o_free(file_content_orig);\n                  }\n                  fclose(f);\n                } else {\n                  if (((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404 == NULL) {\n                    ret = U_CALLBACK_IGNORE;\n                  } else {\n                    ulfius_add_header_to_response(response, \"Location\", ((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404);\n                    response->status = 302;\n                  }\n                }\n                pthread_mutex_unlock(&config->lock);\n              } else {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website - Error pthread_lock_mutex\");\n                ret = U_CALLBACK_ERROR;\n              }\n            } else {\n              response->status = 403;\n            }\n            o_free(file_path);\n            free(real_path); // realpath uses malloc\n          }\n        } else {\n          ret = callback_static_file_uncompressed(request, response, user_data);\n        }\n        free_string_array(accept_list);\n      } else {\n        ret = callback_static_file_uncompressed(request, response, user_data);\n      }\n    } else {\n      ret = callback_static_file_uncompressed(request, response, user_data);\n    }\n    o_free(url_dup_save);\n  }\n\n  return ret;\n}\n", "/**\n *\n * Static file server with compression Ulfius callback\n *\n * Copyright 2020-2022 Nicolas Mora <mail@babelouest.org>\n *\n * Version 20220428\n * \n * The MIT License (MIT)\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * `files_path`: path to the DocumentRoot folder, can be relative or absolute\n * `url_prefix`: prefix used to access the callback function\n * `mime_types`: a `struct _u_map` containing a set of mime-types with file extension as key and mime-type as value\n * `mime_types_compressed`: A `string_array` structure containing the list of mime-types allowed for compression\n * `mime_types_compressed_size`: The number of elements in `mime_types_compressed`\n * `map_header`: a `struct _u_map` containing a set of headers that will be added to all responses within the `static_file_callback`\n * `redirect_on_404`: redirct uri on error 404, if NULL, send 404\n * `allow_gzip`: Set to true if you want to allow gzip compression (default true)\n * `allow_deflate`: Set to true if you want to allow deflate compression (default true)\n * `allow_cache_compressed`: set to true if you want to allow memory cache for compressed files (default true)\n * `lock`: mutex lock (do not touch this variable)\n * `gzip_files`: a `struct _u_map` containing cached gzip files\n * `deflate_files`: a `struct _u_map` containing cached deflate files\n * \n * example of mime-types used in Hutch:\n * {\n *   key = \".html\"\n *   value = \"text/html\"\n * },\n * {\n *   key = \".css\"\n *   value = \"text/css\"\n * },\n * {\n *   key = \".js\"\n *   value = \"application/javascript\"\n * },\n * {\n *   key = \".png\"\n *   value = \"image/png\"\n * },\n * {\n *   key = \".jpg\"\n *   value = \"image/jpeg\"\n * },\n * {\n *   key = \".jpeg\"\n *   value = \"image/jpeg\"\n * },\n * {\n *   key = \".ttf\"\n *   value = \"font/ttf\"\n * },\n * {\n *   key = \".woff\"\n *   value = \"font/woff\"\n * },\n * {\n *   key = \".woff2\"\n *   value = \"font/woff2\"\n * },\n * {\n *   key = \".map\"\n *   value = \"application/octet-stream\"\n * },\n * {\n *   key = \"*\"\n *   value = \"application/octet-stream\"\n * }\n * \n */\n\n#ifndef _U_STATIC_COMPRESSED_INMEMORY_WEBSITE\n#define _U_STATIC_COMPRESSED_INMEMORY_WEBSITE\n\n#define _U_W_BLOCK_SIZE 256\n\nstruct _u_compressed_inmemory_website_config {\n  char          * files_path;\n  char          * url_prefix;\n  struct _u_map   mime_types;\n  char **         mime_types_compressed;\n  size_t          mime_types_compressed_size;\n  struct _u_map   map_header;\n  char          * redirect_on_404;\n  int             allow_gzip;\n  int             allow_deflate;\n  int             allow_cache_compressed;\n  pthread_mutex_t lock;\n  struct _u_map   gzip_files;\n  struct _u_map   deflate_files;\n};\n\nint u_init_compressed_inmemory_website_config(struct _u_compressed_inmemory_website_config * config);\n\nvoid u_clean_compressed_inmemory_website_config(struct _u_compressed_inmemory_website_config * config);\n\nint u_add_mime_types_compressed(struct _u_compressed_inmemory_website_config * config, const char * mime_type);\n\nint callback_static_compressed_inmemory_website (const struct _u_request * request, struct _u_response * response, void * user_data);\n\n#endif\n"], "filenames": ["src/static_compressed_inmemory_website_callback.c", "src/static_compressed_inmemory_website_callback.h"], "buggy_code_start_loc": [7, 7], "buggy_code_end_loc": [468, 8], "fixing_code_start_loc": [7, 7], "fixing_code_end_loc": [485, 8], "type": "CWE-22", "message": "static_compressed_inmemory_website_callback.c in Glewlwyd through 2.6.2 allows directory traversal.", "other": {"cve": {"id": "CVE-2022-29967", "sourceIdentifier": "cve@mitre.org", "published": "2022-04-29T23:15:09.937", "lastModified": "2022-05-10T15:56:59.157", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "static_compressed_inmemory_website_callback.c in Glewlwyd through 2.6.2 allows directory traversal."}, {"lang": "es", "value": "el archivo static_compressed_inmemory_website_callback.c en Glewlwyd versiones hasta 2.6.2 permite un salto de directorios"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:glewlwyd_project:glewlwyd:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.2", "matchCriteriaId": "4CB237CB-1245-4D42-AB25-5BAEC20E1F22"}]}]}], "references": [{"url": "https://github.com/babelouest/glewlwyd/commit/e3f7245c33897bf9b3a75acfcdb8b7b93974bf11", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/babelouest/glewlwyd/commit/e3f7245c33897bf9b3a75acfcdb8b7b93974bf11"}}