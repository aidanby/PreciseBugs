{"buggy_code": ["/* Copyright (c) 2020 The Brave Authors. All rights reserved.\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this file,\n * You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n#include \"brave/browser/net/ipfs_redirect_network_delegate_helper.h\"\n\n#include <string>\n\n#include \"brave/browser/profiles/profile_util.h\"\n#include \"brave/components/ipfs/ipfs_utils.h\"\n#include \"chrome/common/channel_info.h\"\n#include \"components/user_prefs/user_prefs.h\"\n#include \"content/public/browser/browser_context.h\"\n#include \"net/base/net_errors.h\"\n\nnamespace ipfs {\n\nint OnBeforeURLRequest_IPFSRedirectWork(\n    const brave::ResponseCallback& next_callback,\n    std::shared_ptr<brave::BraveRequestInfo> ctx) {\n  if (!ctx->browser_context || !brave::IsRegularProfile(ctx->browser_context))\n    return net::OK;\n  auto* prefs = user_prefs::UserPrefs::Get(ctx->browser_context);\n  if (IsIpfsResolveMethodDisabled(prefs)) {\n    return net::OK;\n  }\n\n  GURL new_url;\n  if (ipfs::TranslateIPFSURI(ctx->request_url, &new_url, ctx->ipfs_gateway_url,\n                             false)) {\n    // We only allow translating ipfs:// and ipns:// URIs if the initiator_url\n    // is from the same Brave ipfs/ipns gateway.\n    // For the local case, we don't want a normal site to be able to populate\n    // a user's IPFS local cache with content they didn't know about.\n    // In which case that user would also be able to serve that content.\n    // If the user is not using a local node, we want the experience to be\n    // the same as the local case.\n    if (ctx->resource_type == blink::mojom::ResourceType::kMainFrame ||\n        (IsLocalGatewayURL(new_url) && IsLocalGatewayURL(ctx->initiator_url)) ||\n        (IsDefaultGatewayURL(new_url, prefs) &&\n         IsDefaultGatewayURL(ctx->initiator_url, prefs))) {\n      ctx->new_url_spec = new_url.spec();\n    } else {\n      ctx->blocked_by = brave::kOtherBlocked;\n    }\n  }\n  return net::OK;\n}\n\nint OnHeadersReceived_IPFSRedirectWork(\n    const net::HttpResponseHeaders* response_headers,\n    scoped_refptr<net::HttpResponseHeaders>* override_response_headers,\n    GURL* allowed_unsafe_redirect_url,\n    const brave::ResponseCallback& next_callback,\n    std::shared_ptr<brave::BraveRequestInfo> ctx) {\n  if (!ctx->browser_context)\n    return net::OK;\n  auto* prefs = user_prefs::UserPrefs::Get(ctx->browser_context);\n  if (IsIpfsResolveMethodDisabled(prefs)) {\n    return net::OK;\n  }\n\n  std::string ipfs_path;\n  bool api_gateway = IsAPIGateway(ctx->request_url, chrome::GetChannel());\n  if (ctx->ipfs_auto_fallback && !api_gateway && response_headers &&\n      response_headers->GetNormalizedHeader(\"x-ipfs-path\", &ipfs_path) &&\n      // Make sure we don't infinite redirect\n      !ctx->request_url.DomainIs(ctx->ipfs_gateway_url.host()) &&\n      // Do not redirect if the frame is not ipfs/ipns\n      IsIPFSScheme(ctx->initiator_url)) {\n    GURL::Replacements replacements;\n    replacements.SetPathStr(ipfs_path);\n\n    if (ctx->request_url.has_query()) {\n      replacements.SetQueryStr(ctx->request_url.query_piece());\n    }\n\n    GURL new_url = ctx->ipfs_gateway_url.ReplaceComponents(replacements);\n\n    *override_response_headers =\n        new net::HttpResponseHeaders(response_headers->raw_headers());\n    (*override_response_headers)\n        ->ReplaceStatusLine(\"HTTP/1.1 307 Temporary Redirect\");\n    (*override_response_headers)->RemoveHeader(\"Location\");\n    (*override_response_headers)->AddHeader(\"Location\", new_url.spec());\n    *allowed_unsafe_redirect_url = new_url;\n  }\n\n  return net::OK;\n}\n\n}  // namespace ipfs\n", "/* Copyright (c) 2020 The Brave Authors. All rights reserved.\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this file,\n * You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n#include \"brave/browser/net/ipfs_redirect_network_delegate_helper.h\"\n\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include \"base/test/scoped_feature_list.h\"\n#include \"brave/browser/net/url_context.h\"\n#include \"brave/components/ipfs/features.h\"\n#include \"brave/components/ipfs/ipfs_constants.h\"\n#include \"brave/components/ipfs/ipfs_utils.h\"\n#include \"brave/components/ipfs/pref_names.h\"\n#include \"chrome/common/channel_info.h\"\n#include \"chrome/test/base/chrome_render_view_host_test_harness.h\"\n#include \"chrome/test/base/testing_profile.h\"\n#include \"components/prefs/pref_service.h\"\n#include \"content/public/test/browser_task_environment.h\"\n#include \"net/traffic_annotation/network_traffic_annotation_test_helper.h\"\n#include \"net/url_request/url_request_test_util.h\"\n#include \"url/gurl.h\"\n\nnamespace {\n\nGURL GetLocalGateway() {\n  return GURL(\"http://localhost:48080\");\n}\n\nGURL GetPublicGateway() {\n  return GURL(\"https://dweb.link\");\n}\n\nconst char initiator_cid[] =\n    \"bafybeiemxf5abjwjbikoz4mc3a3dla6ual3jsgpdr4cjr3oz3evfyavhwq\";\n\n}  // namespace\n\nnamespace ipfs {\n\nclass IPFSRedirectNetworkDelegateHelperTest : public testing::Test {\n public:\n  IPFSRedirectNetworkDelegateHelperTest() : profile_(new TestingProfile) {}\n  ~IPFSRedirectNetworkDelegateHelperTest() override = default;\n\n  void SetUp() override {\n    feature_list_.InitAndEnableFeature(ipfs::features::kIpfsFeature);\n  }\n\n  TestingProfile* profile() { return profile_.get(); }\n\n private:\n  content::BrowserTaskEnvironment task_environment_;\n  std::unique_ptr<TestingProfile> profile_;\n  base::test::ScopedFeatureList feature_list_;\n};\n\nTEST_F(IPFSRedirectNetworkDelegateHelperTest, TranslateIPFSURIHTTPScheme) {\n  GURL url(\"http://a.com/ipfs/QmfM2r8seH2GiRaC4esTjeraXEachRt8ZsSeGaWTPLyMoG\");\n  auto brave_request_info = std::make_shared<brave::BraveRequestInfo>(url);\n  brave_request_info->browser_context = profile();\n  int rc = ipfs::OnBeforeURLRequest_IPFSRedirectWork(brave::ResponseCallback(),\n                                                     brave_request_info);\n  EXPECT_EQ(rc, net::OK);\n  EXPECT_TRUE(brave_request_info->new_url_spec.empty());\n}\n\nTEST_F(IPFSRedirectNetworkDelegateHelperTest, TranslateIPFSURIIPFSSchemeLocal) {\n  GURL url(\"ipfs://QmfM2r8seH2GiRaC4esTjeraXEachRt8ZsSeGaWTPLyMoG\");\n  auto brave_request_info = std::make_shared<brave::BraveRequestInfo>(url);\n  brave_request_info->browser_context = profile();\n  brave_request_info->ipfs_gateway_url = GetLocalGateway();\n  brave_request_info->initiator_url = ipfs::GetIPFSGatewayURL(\n      initiator_cid, \"\",\n      ipfs::GetDefaultIPFSLocalGateway(chrome::GetChannel()));\n  int rc = ipfs::OnBeforeURLRequest_IPFSRedirectWork(brave::ResponseCallback(),\n                                                     brave_request_info);\n  EXPECT_EQ(rc, net::OK);\n  EXPECT_EQ(brave_request_info->new_url_spec,\n            \"http://localhost:48080/ipfs/\"\n            \"QmfM2r8seH2GiRaC4esTjeraXEachRt8ZsSeGaWTPLyMoG\");\n}\n\nTEST_F(IPFSRedirectNetworkDelegateHelperTest, TranslateIPFSURIIPFSScheme) {\n  GURL url(\"ipfs://QmfM2r8seH2GiRaC4esTjeraXEachRt8ZsSeGaWTPLyMoG\");\n  auto brave_request_info = std::make_shared<brave::BraveRequestInfo>(url);\n  brave_request_info->browser_context = profile();\n  brave_request_info->ipfs_gateway_url = GetPublicGateway();\n  brave_request_info->initiator_url = ipfs::GetIPFSGatewayURL(\n      initiator_cid, \"\", ipfs::GetDefaultIPFSGateway(profile()->GetPrefs()));\n  int rc = ipfs::OnBeforeURLRequest_IPFSRedirectWork(brave::ResponseCallback(),\n                                                     brave_request_info);\n  EXPECT_EQ(rc, net::OK);\n  EXPECT_EQ(\n      brave_request_info->new_url_spec,\n      \"https://dweb.link/ipfs/QmfM2r8seH2GiRaC4esTjeraXEachRt8ZsSeGaWTPLyMoG\");\n}\n\nTEST_F(IPFSRedirectNetworkDelegateHelperTest, TranslateIPFSURIIPNSSchemeLocal) {\n  GURL url(\"ipns://QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd\");\n  auto brave_request_info = std::make_shared<brave::BraveRequestInfo>(url);\n  brave_request_info->browser_context = profile();\n  brave_request_info->ipfs_gateway_url = GetLocalGateway();\n  brave_request_info->initiator_url = ipfs::GetIPFSGatewayURL(\n      initiator_cid, \"\",\n      ipfs::GetDefaultIPFSLocalGateway(chrome::GetChannel()));\n  int rc = ipfs::OnBeforeURLRequest_IPFSRedirectWork(brave::ResponseCallback(),\n                                                     brave_request_info);\n  EXPECT_EQ(rc, net::OK);\n  EXPECT_EQ(brave_request_info->new_url_spec,\n            \"http://localhost:48080/ipns/\"\n            \"QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd\");\n}\n\nTEST_F(IPFSRedirectNetworkDelegateHelperTest, TranslateIPFSURIIPNSScheme) {\n  GURL url(\"ipns://QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd\");\n  auto brave_request_info = std::make_shared<brave::BraveRequestInfo>(url);\n  brave_request_info->browser_context = profile();\n  brave_request_info->ipfs_gateway_url = GetPublicGateway();\n  brave_request_info->initiator_url = ipfs::GetIPFSGatewayURL(\n      initiator_cid, \"\", ipfs::GetDefaultIPFSGateway(profile()->GetPrefs()));\n  int rc = ipfs::OnBeforeURLRequest_IPFSRedirectWork(brave::ResponseCallback(),\n                                                     brave_request_info);\n  EXPECT_EQ(rc, net::OK);\n  EXPECT_EQ(\n      brave_request_info->new_url_spec,\n      \"https://dweb.link/ipns/QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd\");\n}\n\nTEST_F(IPFSRedirectNetworkDelegateHelperTest, HeadersIPFSWorkWithRedirect) {\n  GURL url(\n      \"https://cloudflare-ipfs.com/ipfs/\"\n      \"QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd\");\n  auto request_info = std::make_shared<brave::BraveRequestInfo>(url);\n  request_info->browser_context = profile();\n  request_info->ipfs_gateway_url = GetPublicGateway();\n  request_info->initiator_url =\n      GURL(\"ipfs://QmfM2r8seH2GiRaC4esTjeraXEachRt8ZsSeGaWTPLyMoG\");\n  request_info->resource_type = blink::mojom::ResourceType::kImage;\n  request_info->ipfs_auto_fallback = true;\n  request_info->tab_origin = GURL(\"https://cloudflare-ipfs.com/\");\n\n  scoped_refptr<net::HttpResponseHeaders> orig_response_headers =\n      new net::HttpResponseHeaders(std::string());\n  orig_response_headers->AddHeader(\"x-ipfs-path\", \"/test\");\n  scoped_refptr<net::HttpResponseHeaders> overwrite_response_headers =\n      new net::HttpResponseHeaders(std::string());\n  GURL allowed_unsafe_redirect_url;\n\n  int rc = ipfs::OnHeadersReceived_IPFSRedirectWork(\n      orig_response_headers.get(), &overwrite_response_headers,\n      &allowed_unsafe_redirect_url, brave::ResponseCallback(), request_info);\n\n  EXPECT_EQ(rc, net::OK);\n\n  std::string location;\n  EXPECT_TRUE(overwrite_response_headers->EnumerateHeader(nullptr, \"Location\",\n                                                          &location));\n  GURL converted_url = GURL(\"https://dweb.link/test\");\n  EXPECT_EQ(location, converted_url);\n  EXPECT_EQ(allowed_unsafe_redirect_url, converted_url);\n}\n\nTEST_F(IPFSRedirectNetworkDelegateHelperTest,\n       HeadersIPFSWorkWithNoRedirectHttps) {\n  GURL url(\n      \"https://cloudflare-ipfs.com/ipfs/\"\n      \"QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd\");\n  auto request_info = std::make_shared<brave::BraveRequestInfo>(url);\n  request_info->browser_context = profile();\n  request_info->ipfs_gateway_url = GetPublicGateway();\n  request_info->initiator_url = ipfs::GetIPFSGatewayURL(\n      initiator_cid, \"\", ipfs::GetDefaultIPFSGateway(profile()->GetPrefs()));\n  request_info->resource_type = blink::mojom::ResourceType::kImage;\n  request_info->ipfs_auto_fallback = true;\n  request_info->tab_origin = GURL(\"https://some.dweb.link/\");\n\n  scoped_refptr<net::HttpResponseHeaders> orig_response_headers =\n      new net::HttpResponseHeaders(std::string());\n  orig_response_headers->AddHeader(\"x-ipfs-path\", \"/test\");\n  scoped_refptr<net::HttpResponseHeaders> overwrite_response_headers =\n      new net::HttpResponseHeaders(std::string());\n  GURL allowed_unsafe_redirect_url;\n\n  int rc = ipfs::OnHeadersReceived_IPFSRedirectWork(\n      orig_response_headers.get(), &overwrite_response_headers,\n      &allowed_unsafe_redirect_url, brave::ResponseCallback(), request_info);\n\n  EXPECT_EQ(rc, net::OK);\n\n  std::string location;\n  EXPECT_FALSE(overwrite_response_headers->EnumerateHeader(nullptr, \"Location\",\n                                                           &location));\n  EXPECT_EQ(rc, net::OK);\n  EXPECT_TRUE(allowed_unsafe_redirect_url.is_empty());\n}\n\nTEST_F(IPFSRedirectNetworkDelegateHelperTest, HeadersIPFSWorkNoRedirect) {\n  GURL url(\n      \"https://cloudflare-ipfs.com/ipfs/\"\n      \"QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd\");\n  auto request_info = std::make_shared<brave::BraveRequestInfo>(url);\n  request_info->browser_context = profile();\n  request_info->ipfs_gateway_url = GetPublicGateway();\n  request_info->initiator_url = ipfs::GetIPFSGatewayURL(\n      initiator_cid, \"\", ipfs::GetDefaultIPFSGateway(profile()->GetPrefs()));\n  request_info->resource_type = blink::mojom::ResourceType::kImage;\n  request_info->ipfs_auto_fallback = false;\n\n  scoped_refptr<net::HttpResponseHeaders> orig_response_headers =\n      new net::HttpResponseHeaders(std::string());\n  orig_response_headers->AddHeader(\"x-ipfs-path\", \"/test\");\n  scoped_refptr<net::HttpResponseHeaders> overwrite_response_headers =\n      new net::HttpResponseHeaders(std::string());\n  GURL allowed_unsafe_redirect_url;\n\n  int rc = ipfs::OnHeadersReceived_IPFSRedirectWork(\n      orig_response_headers.get(), &overwrite_response_headers,\n      &allowed_unsafe_redirect_url, brave::ResponseCallback(), request_info);\n\n  EXPECT_EQ(rc, net::OK);\n\n  std::string location;\n  EXPECT_FALSE(overwrite_response_headers->EnumerateHeader(nullptr, \"Location\",\n                                                           &location));\n  EXPECT_TRUE(allowed_unsafe_redirect_url.is_empty());\n\n  request_info->request_url = GetAPIServer(chrome::GetChannel());\n  request_info->ipfs_auto_fallback = true;\n\n  rc = ipfs::OnHeadersReceived_IPFSRedirectWork(\n      orig_response_headers.get(), &overwrite_response_headers,\n      &allowed_unsafe_redirect_url, brave::ResponseCallback(), request_info);\n  EXPECT_EQ(rc, net::OK);\n  EXPECT_TRUE(allowed_unsafe_redirect_url.is_empty());\n}\n\nTEST_F(IPFSRedirectNetworkDelegateHelperTest, PrivateProfile) {\n  GURL url(\"ipfs://QmfM2r8seH2GiRaC4esTjeraXEachRt8ZsSeGaWTPLyMoG\");\n  auto brave_request_info = std::make_shared<brave::BraveRequestInfo>(url);\n  brave_request_info->browser_context = profile()->GetPrimaryOTRProfile(true);\n  brave_request_info->ipfs_gateway_url = GetPublicGateway();\n  brave_request_info->initiator_url = ipfs::GetIPFSGatewayURL(\n      initiator_cid, \"\", ipfs::GetDefaultIPFSGateway(profile()->GetPrefs()));\n  int rc = ipfs::OnBeforeURLRequest_IPFSRedirectWork(brave::ResponseCallback(),\n                                                     brave_request_info);\n  EXPECT_EQ(rc, net::OK);\n  EXPECT_TRUE(brave_request_info->new_url_spec.empty());\n}\n\n}  // namespace ipfs\n"], "fixing_code": ["/* Copyright (c) 2020 The Brave Authors. All rights reserved.\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this file,\n * You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n#include \"brave/browser/net/ipfs_redirect_network_delegate_helper.h\"\n\n#include <string>\n\n#include \"brave/browser/profiles/profile_util.h\"\n#include \"brave/components/ipfs/ipfs_utils.h\"\n#include \"chrome/common/channel_info.h\"\n#include \"components/user_prefs/user_prefs.h\"\n#include \"content/public/browser/browser_context.h\"\n#include \"net/base/net_errors.h\"\n\nnamespace ipfs {\n\nint OnBeforeURLRequest_IPFSRedirectWork(\n    const brave::ResponseCallback& next_callback,\n    std::shared_ptr<brave::BraveRequestInfo> ctx) {\n  const bool has_ipfs_scheme = IsIPFSScheme(ctx->request_url);\n  if (!ctx->browser_context) {\n    // IPFS url translation depends on selected gateway.\n    // So we block IPFS requests if we don't have access to prefs.\n    if (has_ipfs_scheme) {\n      ctx->blocked_by = brave::kOtherBlocked;\n    }\n    return net::OK;\n  }\n\n  auto* prefs = user_prefs::UserPrefs::Get(ctx->browser_context);\n  const bool ipfs_disabled = IsIpfsResolveMethodDisabled(prefs);\n\n  if (ipfs_disabled || !brave::IsRegularProfile(ctx->browser_context)) {\n    // Don't allow IPFS requests without translation of IPFS urls.\n    if (has_ipfs_scheme &&\n        ctx->resource_type != blink::mojom::ResourceType::kMainFrame) {\n      ctx->blocked_by = brave::kOtherBlocked;\n    }\n    return net::OK;\n  }\n\n  GURL new_url;\n  if (ipfs::TranslateIPFSURI(ctx->request_url, &new_url, ctx->ipfs_gateway_url,\n                             false)) {\n    // We only allow translating ipfs:// and ipns:// URIs if the initiator_url\n    // is from the same Brave ipfs/ipns gateway.\n    // For the local case, we don't want a normal site to be able to populate\n    // a user's IPFS local cache with content they didn't know about.\n    // In which case that user would also be able to serve that content.\n    // If the user is not using a local node, we want the experience to be\n    // the same as the local case.\n    if (ctx->resource_type == blink::mojom::ResourceType::kMainFrame ||\n        (IsLocalGatewayURL(new_url) && IsLocalGatewayURL(ctx->initiator_url)) ||\n        (IsDefaultGatewayURL(new_url, prefs) &&\n         IsDefaultGatewayURL(ctx->initiator_url, prefs))) {\n      ctx->new_url_spec = new_url.spec();\n    } else {\n      ctx->blocked_by = brave::kOtherBlocked;\n    }\n  }\n  return net::OK;\n}\n\nint OnHeadersReceived_IPFSRedirectWork(\n    const net::HttpResponseHeaders* response_headers,\n    scoped_refptr<net::HttpResponseHeaders>* override_response_headers,\n    GURL* allowed_unsafe_redirect_url,\n    const brave::ResponseCallback& next_callback,\n    std::shared_ptr<brave::BraveRequestInfo> ctx) {\n  if (!ctx->browser_context)\n    return net::OK;\n  auto* prefs = user_prefs::UserPrefs::Get(ctx->browser_context);\n  if (IsIpfsResolveMethodDisabled(prefs)) {\n    return net::OK;\n  }\n\n  std::string ipfs_path;\n  bool api_gateway = IsAPIGateway(ctx->request_url, chrome::GetChannel());\n  if (ctx->ipfs_auto_fallback && !api_gateway && response_headers &&\n      response_headers->GetNormalizedHeader(\"x-ipfs-path\", &ipfs_path) &&\n      // Make sure we don't infinite redirect\n      !ctx->request_url.DomainIs(ctx->ipfs_gateway_url.host()) &&\n      // Do not redirect if the frame is not ipfs/ipns\n      IsIPFSScheme(ctx->initiator_url)) {\n    GURL::Replacements replacements;\n    replacements.SetPathStr(ipfs_path);\n\n    if (ctx->request_url.has_query()) {\n      replacements.SetQueryStr(ctx->request_url.query_piece());\n    }\n\n    GURL new_url = ctx->ipfs_gateway_url.ReplaceComponents(replacements);\n\n    *override_response_headers =\n        new net::HttpResponseHeaders(response_headers->raw_headers());\n    (*override_response_headers)\n        ->ReplaceStatusLine(\"HTTP/1.1 307 Temporary Redirect\");\n    (*override_response_headers)->RemoveHeader(\"Location\");\n    (*override_response_headers)->AddHeader(\"Location\", new_url.spec());\n    *allowed_unsafe_redirect_url = new_url;\n  }\n\n  return net::OK;\n}\n\n}  // namespace ipfs\n", "/* Copyright (c) 2020 The Brave Authors. All rights reserved.\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this file,\n * You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n#include \"brave/browser/net/ipfs_redirect_network_delegate_helper.h\"\n\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include \"base/test/scoped_feature_list.h\"\n#include \"brave/browser/net/url_context.h\"\n#include \"brave/components/ipfs/features.h\"\n#include \"brave/components/ipfs/ipfs_constants.h\"\n#include \"brave/components/ipfs/ipfs_utils.h\"\n#include \"brave/components/ipfs/pref_names.h\"\n#include \"chrome/common/channel_info.h\"\n#include \"chrome/test/base/chrome_render_view_host_test_harness.h\"\n#include \"chrome/test/base/testing_profile.h\"\n#include \"components/prefs/pref_service.h\"\n#include \"content/public/test/browser_task_environment.h\"\n#include \"net/traffic_annotation/network_traffic_annotation_test_helper.h\"\n#include \"net/url_request/url_request_test_util.h\"\n#include \"url/gurl.h\"\n\nnamespace {\n\nGURL GetLocalGateway() {\n  return GURL(\"http://localhost:48080\");\n}\n\nGURL GetPublicGateway() {\n  return GURL(\"https://dweb.link\");\n}\n\nconst char initiator_cid[] =\n    \"bafybeiemxf5abjwjbikoz4mc3a3dla6ual3jsgpdr4cjr3oz3evfyavhwq\";\n\n}  // namespace\n\nnamespace ipfs {\n\nclass IPFSRedirectNetworkDelegateHelperTest : public testing::Test {\n public:\n  IPFSRedirectNetworkDelegateHelperTest() : profile_(new TestingProfile) {}\n  ~IPFSRedirectNetworkDelegateHelperTest() override = default;\n\n  void SetUp() override {\n    feature_list_.InitAndEnableFeature(ipfs::features::kIpfsFeature);\n  }\n\n  TestingProfile* profile() { return profile_.get(); }\n\n private:\n  content::BrowserTaskEnvironment task_environment_;\n  std::unique_ptr<TestingProfile> profile_;\n  base::test::ScopedFeatureList feature_list_;\n};\n\nTEST_F(IPFSRedirectNetworkDelegateHelperTest, TranslateIPFSURIHTTPScheme) {\n  GURL url(\"http://a.com/ipfs/QmfM2r8seH2GiRaC4esTjeraXEachRt8ZsSeGaWTPLyMoG\");\n  auto brave_request_info = std::make_shared<brave::BraveRequestInfo>(url);\n  brave_request_info->browser_context = profile();\n  int rc = ipfs::OnBeforeURLRequest_IPFSRedirectWork(brave::ResponseCallback(),\n                                                     brave_request_info);\n  EXPECT_EQ(rc, net::OK);\n  EXPECT_TRUE(brave_request_info->new_url_spec.empty());\n}\n\nTEST_F(IPFSRedirectNetworkDelegateHelperTest, TranslateIPFSURIIPFSSchemeLocal) {\n  GURL url(\"ipfs://QmfM2r8seH2GiRaC4esTjeraXEachRt8ZsSeGaWTPLyMoG\");\n  auto brave_request_info = std::make_shared<brave::BraveRequestInfo>(url);\n  brave_request_info->browser_context = profile();\n  brave_request_info->ipfs_gateway_url = GetLocalGateway();\n  brave_request_info->initiator_url = ipfs::GetIPFSGatewayURL(\n      initiator_cid, \"\",\n      ipfs::GetDefaultIPFSLocalGateway(chrome::GetChannel()));\n  int rc = ipfs::OnBeforeURLRequest_IPFSRedirectWork(brave::ResponseCallback(),\n                                                     brave_request_info);\n  EXPECT_EQ(rc, net::OK);\n  EXPECT_EQ(brave_request_info->new_url_spec,\n            \"http://localhost:48080/ipfs/\"\n            \"QmfM2r8seH2GiRaC4esTjeraXEachRt8ZsSeGaWTPLyMoG\");\n}\n\nTEST_F(IPFSRedirectNetworkDelegateHelperTest,\n       SubFrameRequestDisabledWhenIPFSDisabled) {\n  profile()->GetPrefs()->SetInteger(\n      kIPFSResolveMethod,\n      static_cast<int>(IPFSResolveMethodTypes::IPFS_DISABLED));\n\n  GURL url(\"ipfs://QmfM2r8seH2GiRaC4esTjeraXEachRt8ZsSeGaWTPLyMoG\");\n  auto brave_request_info = std::make_shared<brave::BraveRequestInfo>(url);\n  brave_request_info->resource_type = blink::mojom::ResourceType::kSubFrame;\n  brave_request_info->browser_context = profile();\n  int rc = ipfs::OnBeforeURLRequest_IPFSRedirectWork(brave::ResponseCallback(),\n                                                     brave_request_info);\n  EXPECT_EQ(rc, net::OK);\n  EXPECT_EQ(brave_request_info->blocked_by, brave::kOtherBlocked);\n}\n\nTEST_F(IPFSRedirectNetworkDelegateHelperTest,\n       SubFrameRequestDisabledWhenIPFSDisabled_Incognito) {\n  profile()->GetPrefs()->SetInteger(\n      kIPFSResolveMethod, static_cast<int>(IPFSResolveMethodTypes::IPFS_LOCAL));\n\n  GURL url(\"ipfs://QmfM2r8seH2GiRaC4esTjeraXEachRt8ZsSeGaWTPLyMoG\");\n  auto brave_request_info = std::make_shared<brave::BraveRequestInfo>(url);\n  brave_request_info->resource_type = blink::mojom::ResourceType::kSubFrame;\n  brave_request_info->browser_context = profile()->GetOffTheRecordProfile(\n      Profile::OTRProfileID::CreateUnique(\"incognito\"), true);\n  int rc = ipfs::OnBeforeURLRequest_IPFSRedirectWork(brave::ResponseCallback(),\n                                                     brave_request_info);\n  EXPECT_EQ(rc, net::OK);\n  EXPECT_EQ(brave_request_info->blocked_by, brave::kOtherBlocked);\n}\n\nTEST_F(IPFSRedirectNetworkDelegateHelperTest,\n       SubFrameRequestDisabledWhen_NoContext) {\n  profile()->GetPrefs()->SetInteger(\n      kIPFSResolveMethod, static_cast<int>(IPFSResolveMethodTypes::IPFS_LOCAL));\n\n  GURL url(\"ipfs://QmfM2r8seH2GiRaC4esTjeraXEachRt8ZsSeGaWTPLyMoG\");\n  auto brave_request_info = std::make_shared<brave::BraveRequestInfo>(url);\n  brave_request_info->resource_type = blink::mojom::ResourceType::kSubFrame;\n  brave_request_info->browser_context = nullptr;\n  int rc = ipfs::OnBeforeURLRequest_IPFSRedirectWork(brave::ResponseCallback(),\n                                                     brave_request_info);\n  EXPECT_EQ(rc, net::OK);\n  EXPECT_EQ(brave_request_info->blocked_by, brave::kOtherBlocked);\n}\n\nTEST_F(IPFSRedirectNetworkDelegateHelperTest, TranslateIPFSURIIPFSScheme) {\n  GURL url(\"ipfs://QmfM2r8seH2GiRaC4esTjeraXEachRt8ZsSeGaWTPLyMoG\");\n  auto brave_request_info = std::make_shared<brave::BraveRequestInfo>(url);\n  brave_request_info->browser_context = profile();\n  brave_request_info->ipfs_gateway_url = GetPublicGateway();\n  brave_request_info->initiator_url = ipfs::GetIPFSGatewayURL(\n      initiator_cid, \"\", ipfs::GetDefaultIPFSGateway(profile()->GetPrefs()));\n  int rc = ipfs::OnBeforeURLRequest_IPFSRedirectWork(brave::ResponseCallback(),\n                                                     brave_request_info);\n  EXPECT_EQ(rc, net::OK);\n  EXPECT_EQ(\n      brave_request_info->new_url_spec,\n      \"https://dweb.link/ipfs/QmfM2r8seH2GiRaC4esTjeraXEachRt8ZsSeGaWTPLyMoG\");\n}\n\nTEST_F(IPFSRedirectNetworkDelegateHelperTest, TranslateIPFSURIIPNSSchemeLocal) {\n  GURL url(\"ipns://QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd\");\n  auto brave_request_info = std::make_shared<brave::BraveRequestInfo>(url);\n  brave_request_info->browser_context = profile();\n  brave_request_info->ipfs_gateway_url = GetLocalGateway();\n  brave_request_info->initiator_url = ipfs::GetIPFSGatewayURL(\n      initiator_cid, \"\",\n      ipfs::GetDefaultIPFSLocalGateway(chrome::GetChannel()));\n  int rc = ipfs::OnBeforeURLRequest_IPFSRedirectWork(brave::ResponseCallback(),\n                                                     brave_request_info);\n  EXPECT_EQ(rc, net::OK);\n  EXPECT_EQ(brave_request_info->new_url_spec,\n            \"http://localhost:48080/ipns/\"\n            \"QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd\");\n}\n\nTEST_F(IPFSRedirectNetworkDelegateHelperTest, TranslateIPFSURIIPNSScheme) {\n  GURL url(\"ipns://QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd\");\n  auto brave_request_info = std::make_shared<brave::BraveRequestInfo>(url);\n  brave_request_info->browser_context = profile();\n  brave_request_info->ipfs_gateway_url = GetPublicGateway();\n  brave_request_info->initiator_url = ipfs::GetIPFSGatewayURL(\n      initiator_cid, \"\", ipfs::GetDefaultIPFSGateway(profile()->GetPrefs()));\n  int rc = ipfs::OnBeforeURLRequest_IPFSRedirectWork(brave::ResponseCallback(),\n                                                     brave_request_info);\n  EXPECT_EQ(rc, net::OK);\n  EXPECT_EQ(\n      brave_request_info->new_url_spec,\n      \"https://dweb.link/ipns/QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd\");\n}\n\nTEST_F(IPFSRedirectNetworkDelegateHelperTest, HeadersIPFSWorkWithRedirect) {\n  GURL url(\n      \"https://cloudflare-ipfs.com/ipfs/\"\n      \"QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd\");\n  auto request_info = std::make_shared<brave::BraveRequestInfo>(url);\n  request_info->browser_context = profile();\n  request_info->ipfs_gateway_url = GetPublicGateway();\n  request_info->initiator_url =\n      GURL(\"ipfs://QmfM2r8seH2GiRaC4esTjeraXEachRt8ZsSeGaWTPLyMoG\");\n  request_info->resource_type = blink::mojom::ResourceType::kImage;\n  request_info->ipfs_auto_fallback = true;\n  request_info->tab_origin = GURL(\"https://cloudflare-ipfs.com/\");\n\n  scoped_refptr<net::HttpResponseHeaders> orig_response_headers =\n      new net::HttpResponseHeaders(std::string());\n  orig_response_headers->AddHeader(\"x-ipfs-path\", \"/test\");\n  scoped_refptr<net::HttpResponseHeaders> overwrite_response_headers =\n      new net::HttpResponseHeaders(std::string());\n  GURL allowed_unsafe_redirect_url;\n\n  int rc = ipfs::OnHeadersReceived_IPFSRedirectWork(\n      orig_response_headers.get(), &overwrite_response_headers,\n      &allowed_unsafe_redirect_url, brave::ResponseCallback(), request_info);\n\n  EXPECT_EQ(rc, net::OK);\n\n  std::string location;\n  EXPECT_TRUE(overwrite_response_headers->EnumerateHeader(nullptr, \"Location\",\n                                                          &location));\n  GURL converted_url = GURL(\"https://dweb.link/test\");\n  EXPECT_EQ(location, converted_url);\n  EXPECT_EQ(allowed_unsafe_redirect_url, converted_url);\n}\n\nTEST_F(IPFSRedirectNetworkDelegateHelperTest,\n       HeadersIPFSWorkWithNoRedirectHttps) {\n  GURL url(\n      \"https://cloudflare-ipfs.com/ipfs/\"\n      \"QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd\");\n  auto request_info = std::make_shared<brave::BraveRequestInfo>(url);\n  request_info->browser_context = profile();\n  request_info->ipfs_gateway_url = GetPublicGateway();\n  request_info->initiator_url = ipfs::GetIPFSGatewayURL(\n      initiator_cid, \"\", ipfs::GetDefaultIPFSGateway(profile()->GetPrefs()));\n  request_info->resource_type = blink::mojom::ResourceType::kImage;\n  request_info->ipfs_auto_fallback = true;\n  request_info->tab_origin = GURL(\"https://some.dweb.link/\");\n\n  scoped_refptr<net::HttpResponseHeaders> orig_response_headers =\n      new net::HttpResponseHeaders(std::string());\n  orig_response_headers->AddHeader(\"x-ipfs-path\", \"/test\");\n  scoped_refptr<net::HttpResponseHeaders> overwrite_response_headers =\n      new net::HttpResponseHeaders(std::string());\n  GURL allowed_unsafe_redirect_url;\n\n  int rc = ipfs::OnHeadersReceived_IPFSRedirectWork(\n      orig_response_headers.get(), &overwrite_response_headers,\n      &allowed_unsafe_redirect_url, brave::ResponseCallback(), request_info);\n\n  EXPECT_EQ(rc, net::OK);\n\n  std::string location;\n  EXPECT_FALSE(overwrite_response_headers->EnumerateHeader(nullptr, \"Location\",\n                                                           &location));\n  EXPECT_EQ(rc, net::OK);\n  EXPECT_TRUE(allowed_unsafe_redirect_url.is_empty());\n}\n\nTEST_F(IPFSRedirectNetworkDelegateHelperTest, HeadersIPFSWorkNoRedirect) {\n  GURL url(\n      \"https://cloudflare-ipfs.com/ipfs/\"\n      \"QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd\");\n  auto request_info = std::make_shared<brave::BraveRequestInfo>(url);\n  request_info->browser_context = profile();\n  request_info->ipfs_gateway_url = GetPublicGateway();\n  request_info->initiator_url = ipfs::GetIPFSGatewayURL(\n      initiator_cid, \"\", ipfs::GetDefaultIPFSGateway(profile()->GetPrefs()));\n  request_info->resource_type = blink::mojom::ResourceType::kImage;\n  request_info->ipfs_auto_fallback = false;\n\n  scoped_refptr<net::HttpResponseHeaders> orig_response_headers =\n      new net::HttpResponseHeaders(std::string());\n  orig_response_headers->AddHeader(\"x-ipfs-path\", \"/test\");\n  scoped_refptr<net::HttpResponseHeaders> overwrite_response_headers =\n      new net::HttpResponseHeaders(std::string());\n  GURL allowed_unsafe_redirect_url;\n\n  int rc = ipfs::OnHeadersReceived_IPFSRedirectWork(\n      orig_response_headers.get(), &overwrite_response_headers,\n      &allowed_unsafe_redirect_url, brave::ResponseCallback(), request_info);\n\n  EXPECT_EQ(rc, net::OK);\n\n  std::string location;\n  EXPECT_FALSE(overwrite_response_headers->EnumerateHeader(nullptr, \"Location\",\n                                                           &location));\n  EXPECT_TRUE(allowed_unsafe_redirect_url.is_empty());\n\n  request_info->request_url = GetAPIServer(chrome::GetChannel());\n  request_info->ipfs_auto_fallback = true;\n\n  rc = ipfs::OnHeadersReceived_IPFSRedirectWork(\n      orig_response_headers.get(), &overwrite_response_headers,\n      &allowed_unsafe_redirect_url, brave::ResponseCallback(), request_info);\n  EXPECT_EQ(rc, net::OK);\n  EXPECT_TRUE(allowed_unsafe_redirect_url.is_empty());\n}\n\nTEST_F(IPFSRedirectNetworkDelegateHelperTest, PrivateProfile) {\n  GURL url(\"ipfs://QmfM2r8seH2GiRaC4esTjeraXEachRt8ZsSeGaWTPLyMoG\");\n  auto brave_request_info = std::make_shared<brave::BraveRequestInfo>(url);\n  brave_request_info->browser_context = profile()->GetPrimaryOTRProfile(true);\n  brave_request_info->ipfs_gateway_url = GetPublicGateway();\n  brave_request_info->initiator_url = ipfs::GetIPFSGatewayURL(\n      initiator_cid, \"\", ipfs::GetDefaultIPFSGateway(profile()->GetPrefs()));\n  int rc = ipfs::OnBeforeURLRequest_IPFSRedirectWork(brave::ResponseCallback(),\n                                                     brave_request_info);\n  EXPECT_EQ(rc, net::OK);\n  EXPECT_TRUE(brave_request_info->new_url_spec.empty());\n}\n\n}  // namespace ipfs\n"], "filenames": ["browser/net/ipfs_redirect_network_delegate_helper.cc", "browser/net/ipfs_redirect_network_delegate_helper_unittest.cc"], "buggy_code_start_loc": [22, 87], "buggy_code_end_loc": [26, 87], "fixing_code_start_loc": [22, 88], "fixing_code_end_loc": [41, 135], "type": "NVD-CWE-Other", "message": "Brave Browser before 1.42.51 allowed a remote attacker to cause a denial of service via a crafted HTML file that references the IPFS scheme. This vulnerability is caused by an uncaught exception in the function ipfs::OnBeforeURLRequest_IPFSRedirectWork() in ipfs_redirect_network_delegate_helper.cc.", "other": {"cve": {"id": "CVE-2022-47933", "sourceIdentifier": "cve@mitre.org", "published": "2022-12-24T22:15:09.373", "lastModified": "2022-12-30T22:05:18.947", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Brave Browser before 1.42.51 allowed a remote attacker to cause a denial of service via a crafted HTML file that references the IPFS scheme. This vulnerability is caused by an uncaught exception in the function ipfs::OnBeforeURLRequest_IPFSRedirectWork() in ipfs_redirect_network_delegate_helper.cc."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:brave:brave:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.42.51", "matchCriteriaId": "FE993CC2-7343-4D41-ABF4-84B6DC15763F"}]}]}], "references": [{"url": "https://github.com/brave/brave-browser/issues/23646", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/brave/brave-browser/issues/24378", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/brave/brave-core/commit/7ef8cb2f232abdf59ec9c3c99a086a14b972bc56", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/brave/brave-core/pull/13989", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/1610343", "source": "cve@mitre.org", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/brave/brave-core/commit/7ef8cb2f232abdf59ec9c3c99a086a14b972bc56"}}