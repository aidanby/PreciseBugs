{"buggy_code": ["///////////////////////////////////////////////////////////////////////////\n//\n// Copyright (c) 2011, Industrial Light & Magic, a division of Lucas\n// Digital Ltd. LLC\n//\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// *       Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// *       Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// *       Neither the name of Industrial Light & Magic nor the names of\n// its contributors may be used to endorse or promote products derived\n// from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n///////////////////////////////////////////////////////////////////////////\n\n#include \"ImfMultiPartInputFile.h\"\n\n#include \"ImfTimeCodeAttribute.h\"\n#include \"ImfChromaticitiesAttribute.h\"\n#include \"ImfBoxAttribute.h\"\n#include \"ImfFloatAttribute.h\"\n#include \"ImfStdIO.h\"\n#include \"ImfTileOffsets.h\"\n#include \"ImfMisc.h\"\n#include \"ImfTiledMisc.h\"\n#include \"ImfInputStreamMutex.h\"\n#include \"ImfInputPartData.h\"\n#include \"ImfPartType.h\"\n#include \"ImfInputFile.h\"\n#include \"ImfScanLineInputFile.h\"\n#include \"ImfTiledInputFile.h\"\n#include \"ImfDeepScanLineInputFile.h\"\n#include \"ImfDeepTiledInputFile.h\"\n#include \"ImfVersion.h\"\n\n#include <OpenEXRConfig.h>\n#include <IlmThread.h>\n#include <IlmThreadMutex.h>\n\n#include <Iex.h>\n#include <map>\n#include <set>\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_ENTER\n\nusing ILMTHREAD_NAMESPACE::Mutex;\nusing ILMTHREAD_NAMESPACE::Lock;\nusing IMATH_NAMESPACE::Box2i;\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\n\nnamespace\n{\n    // Controls whether we error out in the event of shared attribute\n    // inconsistency in the input file\n    static const bool strictSharedAttribute = true;\n}\n\nstruct MultiPartInputFile::Data: public InputStreamMutex\n{\n    int                         version;        // Version of this file.\n    bool                        deleteStream;   // If we should delete the stream during destruction.\n    vector<InputPartData*>      parts;          // Data to initialize Output files.\n    int                         numThreads;     // Number of threads\n    bool                        reconstructChunkOffsetTable;    // If we should reconstruct\n                                                                // the offset table if it's broken.\n    std::map<int,GenericInputFile*> _inputFiles;\n    std::vector<Header>             _headers;\n\n    \n    void                    chunkOffsetReconstruction(OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& is, const std::vector<InputPartData*>& parts);\n                                                      \n    void                    readChunkOffsetTables(bool reconstructChunkOffsetTable);\n                                                      \n    bool                    checkSharedAttributesValues(const Header & src,\n                                                        const Header & dst,\n                                                        std::vector<std::string> & conflictingAttributes) const;\n                                                                                                          \n   TileOffsets*            createTileOffsets(const Header& header);\n   \n   InputPartData*          getPart(int partNumber);\n   \n    Data (bool deleteStream, int numThreads, bool reconstructChunkOffsetTable):\n        InputStreamMutex(),\n        deleteStream (deleteStream),\n        numThreads (numThreads),\n        reconstructChunkOffsetTable(reconstructChunkOffsetTable)\n    {\n    }\n\n    ~Data()\n    {\n        if (deleteStream) delete is;\n\n        for (size_t i = 0; i < parts.size(); i++)\n            delete parts[i];\n    }\n    \n    Data (const Data& other) = delete;\n    Data& operator = (const Data& other) = delete;\n    Data (Data&& other) = delete;\n    Data& operator = (Data&& other) = delete;\n    \n    template <class T>\n    T*    createInputPartT(int partNumber)\n    {\n\n    }\n};\n\nMultiPartInputFile::MultiPartInputFile(const char fileName[],\n                           int numThreads,\n                           bool reconstructChunkOffsetTable):\n    _data(new Data(true, numThreads, reconstructChunkOffsetTable))\n{\n    try\n    {\n        _data->is = new StdIFStream (fileName);\n        initialize();\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        delete _data;\n\n        REPLACE_EXC (e, \"Cannot read image file \"\n                     \"\\\"\" << fileName << \"\\\". \" << e.what());\n        throw;\n    }\n    catch (...)\n    {\n        delete _data;\n        throw;\n    }\n}\n\nMultiPartInputFile::MultiPartInputFile (OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& is,\n                                        int numThreads,\n                                        bool reconstructChunkOffsetTable):\n    _data(new Data(false, numThreads, reconstructChunkOffsetTable))\n{\n    try\n    {\n        _data->is = &is;\n        initialize();\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        delete _data;\n\n        REPLACE_EXC (e, \"Cannot read image file \"\n                     \"\\\"\" << is.fileName() << \"\\\". \" << e.what());\n        throw;\n    }\n    catch (...)\n    {\n        delete _data;\n        throw;\n    }\n}\n\ntemplate<class T>\nT*\nMultiPartInputFile::getInputPart(int partNumber)\n{\n    Lock lock(*_data);\n            if (_data->_inputFiles.find(partNumber) == _data->_inputFiles.end())\n        {\n            T* file = new T(_data->getPart(partNumber));\n            _data->_inputFiles.insert(std::make_pair(partNumber, (GenericInputFile*) file));\n            return file;\n        }\n        else return (T*) _data->_inputFiles[partNumber];\n}\n\n\ntemplate InputFile* MultiPartInputFile::getInputPart<InputFile>(int);\ntemplate TiledInputFile* MultiPartInputFile::getInputPart<TiledInputFile>(int);\ntemplate DeepScanLineInputFile* MultiPartInputFile::getInputPart<DeepScanLineInputFile>(int);\ntemplate DeepTiledInputFile* MultiPartInputFile::getInputPart<DeepTiledInputFile>(int);\n\nInputPartData*\nMultiPartInputFile::getPart(int partNumber)\n{\n    return _data->getPart(partNumber);\n}\n\n\n\nconst Header &\n MultiPartInputFile::header(int n) const\n{\n    return _data->_headers[n];\n}\n\n\n\nMultiPartInputFile::~MultiPartInputFile()\n{\n    for (map<int, GenericInputFile*>::iterator it = _data->_inputFiles.begin();\n         it != _data->_inputFiles.end(); it++)\n    {\n        delete it->second;\n    }\n\n    delete _data;\n}\n\n\nbool\nMultiPartInputFile::Data::checkSharedAttributesValues(const Header & src,\n                                                const Header & dst,\n                                                vector<string> & conflictingAttributes) const\n{\n    conflictingAttributes.clear();\n\n    bool conflict = false;\n\n    //\n    // Display Window\n    //\n    if (src.displayWindow() != dst.displayWindow())\n    {\n        conflict = true;\n        conflictingAttributes.push_back (\"displayWindow\");\n    }\n\n\n    //\n    // Pixel Aspect Ratio\n    //\n    if (src.pixelAspectRatio() != dst.pixelAspectRatio())\n    {\n        conflict = true;\n        conflictingAttributes.push_back (\"pixelAspectRatio\");\n    }\n\n\n    //\n    // Timecode\n    //\n    const TimeCodeAttribute * srcTimeCode = src.findTypedAttribute<\n          TimeCodeAttribute> (TimeCodeAttribute::staticTypeName());\n    const TimeCodeAttribute * dstTimeCode = dst.findTypedAttribute<\n          TimeCodeAttribute> (TimeCodeAttribute::staticTypeName());\n\n    if (dstTimeCode)\n    {\n        if  ( (srcTimeCode && (srcTimeCode->value() != dstTimeCode->value())) ||\n              (!srcTimeCode))\n        {\n            conflict = true;\n            conflictingAttributes.push_back (TimeCodeAttribute::staticTypeName());\n        }\n    }\n\n    //\n    // Chromaticities\n    //\n    const ChromaticitiesAttribute * srcChrom =  src.findTypedAttribute<\n          ChromaticitiesAttribute> (ChromaticitiesAttribute::staticTypeName());\n    const ChromaticitiesAttribute * dstChrom =  dst.findTypedAttribute<\n          ChromaticitiesAttribute> (ChromaticitiesAttribute::staticTypeName());\n\n    if (dstChrom)\n    {\n        if ( (srcChrom && (srcChrom->value() != dstChrom->value())) ||\n             (!srcChrom))\n        {\n            conflict = true;\n            conflictingAttributes.push_back (ChromaticitiesAttribute::staticTypeName());\n        }\n    }\n\n\n    return conflict;\n}\n\n\nvoid\nMultiPartInputFile::initialize()\n{\n    readMagicNumberAndVersionField(*_data->is, _data->version);\n    \n    bool multipart = isMultiPart(_data->version);\n    bool tiled = isTiled(_data->version);\n\n    //\n    // Multipart files don't have and shouldn't have the tiled bit set.\n    //\n\n    if (tiled && multipart)\n        throw IEX_NAMESPACE::InputExc (\"Multipart files cannot have the tiled bit set\");\n\n    \n    int pos = 0;\n    while (true)\n    {\n        Header header;\n        header.readFrom(*_data->is, _data->version);\n\n        //\n        // If we read nothing then we stop reading.\n        //\n\n        if (header.readsNothing())\n        {\n            pos++;\n            break;\n        }\n\n        _data->_headers.push_back(header);\n        \n        if(multipart == false)\n          break;\n    }\n\n    //\n    // Perform usual check on headers.\n    //\n\n    for (size_t i = 0; i < _data->_headers.size(); i++)\n    {\n        //\n        // Silently invent a type if the file is a single part regular image.\n        //\n\n        if( _data->_headers[i].hasType() == false )\n        {\n            if(multipart)\n\n                throw IEX_NAMESPACE::ArgExc (\"Every header in a multipart file should have a type\");\n          \n            _data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);\n        }\n        else\n        {\n            \n            //\n            // Silently fix the header type if it's wrong\n            // (happens when a regular Image file written by EXR_2.0 is rewritten by an older library,\n            //  so doesn't effect deep image types)\n            //\n\n            if(!multipart && !isNonImage(_data->version))\n            {\n                _data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);\n            }\n        }\n         \n\n        \n        if( _data->_headers[i].hasName() == false )\n        {\n            if(multipart)\n                throw IEX_NAMESPACE::ArgExc (\"Every header in a multipart file should have a name\");\n        }\n        \n        if (isTiled(_data->_headers[i].type()))\n            _data->_headers[i].sanityCheck(true, multipart);\n        else\n            _data->_headers[i].sanityCheck(false, multipart);\n    }\n\n    //\n    // Check name uniqueness.\n    //\n\n    if (multipart)\n    {\n        set<string> names;\n        for (size_t i = 0; i < _data->_headers.size(); i++)\n        {\n        \n            if (names.find(_data->_headers[i].name()) != names.end())\n            {\n                throw IEX_NAMESPACE::InputExc (\"Header name \" + _data->_headers[i].name() +\n                                   \" is not a unique name.\");\n            }\n            names.insert(_data->_headers[i].name());\n        }\n    }\n    \n    //\n    // Check shared attributes compliance.\n    //\n\n    if (multipart && strictSharedAttribute)\n    {\n        for (size_t i = 1; i < _data->_headers.size(); i++)\n        {\n            vector <string> attrs;\n            if (_data->checkSharedAttributesValues (_data->_headers[0], _data->_headers[i], attrs))\n            {\n                string attrNames;\n                for (size_t j=0; j<attrs.size(); j++)\n                    attrNames += \" \" + attrs[j];\n                throw IEX_NAMESPACE::InputExc (\"Header name \" + _data->_headers[i].name() +\n                                     \" has non-conforming shared attributes: \"+\n                                     attrNames);\n            }\n        }\n    }\n\n    //\n    // Create InputParts and read chunk offset tables.\n    //\n        \n    for (size_t i = 0; i < _data->_headers.size(); i++)\n        _data->parts.push_back(\n                new InputPartData(_data, _data->_headers[i], i, _data->numThreads, _data->version));\n\n    _data->readChunkOffsetTables(_data->reconstructChunkOffsetTable);\n}\n\nTileOffsets*\nMultiPartInputFile::Data::createTileOffsets(const Header& header)\n{\n    //\n    // Get the dataWindow information\n    //\n\n    const Box2i &dataWindow = header.dataWindow();\n    int minX = dataWindow.min.x;\n    int maxX = dataWindow.max.x;\n    int minY = dataWindow.min.y;\n    int maxY = dataWindow.max.y;\n\n    //\n    // Precompute level and tile information\n    //\n\n    int* numXTiles = nullptr;\n    int* numYTiles = nullptr;\n    int numXLevels, numYLevels;\n    TileDescription tileDesc = header.tileDescription();\n    try\n    {\n\n        precalculateTileInfo (tileDesc,\n                            minX, maxX,\n                            minY, maxY,\n                            numXTiles, numYTiles,\n                            numXLevels, numYLevels);\n\n        TileOffsets* tileOffsets = new TileOffsets (tileDesc.mode,\n                                                    numXLevels,\n                                                    numYLevels,\n                                                    numXTiles,\n                                                    numYTiles);\n        delete [] numXTiles;\n        delete [] numYTiles;\n\n        return tileOffsets;\n\n    }\n    catch(...)\n    {\n        delete [] numXTiles;\n        delete [] numYTiles;\n        throw;\n    }\n\n}\n\n\nvoid\nMultiPartInputFile::Data::chunkOffsetReconstruction(OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& is, const vector<InputPartData*>& parts)\n{\n    //\n    // Reconstruct broken chunk offset tables. Stop once we received any exception.\n    //\n\n    Int64 position = is.tellg();\n\n    \n    //\n    // check we understand all the parts available: if not, we cannot continue\n    // exceptions thrown here should trickle back up to the constructor\n    //\n    \n    for (size_t i = 0; i < parts.size(); i++)\n    {\n        Header& header=parts[i]->header;\n        \n        //\n        // do we have a valid type entry?\n        // we only need them for true multipart files or single part non-image (deep) files\n        //\n        if(!header.hasType() && (isMultiPart(version) || isNonImage(version)))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with missing type\");\n        }\n        if(!isSupportedType(header.type()))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with unknown type \"+header.type());\n        }\n    }\n    \n    \n    // how many chunks should we read? We should stop when we reach the end\n    size_t total_chunks = 0;\n        \n    // for tiled-based parts, array of (pointers to) tileOffsets objects\n    // to create mapping between tile coordinates and chunk table indices\n    \n    \n    vector<TileOffsets*> tileOffsets(parts.size());\n    \n    // for scanline-based parts, number of scanlines in each chunk\n    vector<int> rowsizes(parts.size());\n        \n    for(size_t i = 0 ; i < parts.size() ; i++)\n    {\n        total_chunks += parts[i]->chunkOffsets.size();\n        if (isTiled(parts[i]->header.type()))\n        {\n            tileOffsets[i] = createTileOffsets(parts[i]->header);\n        }else{\n            tileOffsets[i] = NULL;\n            // (TODO) fix this so that it doesn't need to be revised for future compression types.\n            switch(parts[i]->header.compression())\n            {\n                case DWAB_COMPRESSION :\n                    rowsizes[i] = 256;\n                    break;\n                case PIZ_COMPRESSION :\n                case B44_COMPRESSION :\n                case B44A_COMPRESSION :\n                case DWAA_COMPRESSION :\n                    rowsizes[i]=32;\n                    break;\n                case ZIP_COMPRESSION :\n                case PXR24_COMPRESSION :\n                    rowsizes[i]=16;\n                    break;\n                case ZIPS_COMPRESSION :\n                case RLE_COMPRESSION :\n                case NO_COMPRESSION :\n                    rowsizes[i]=1;\n                    break;\n                default :\n                    throw(IEX_NAMESPACE::ArgExc(\"Unknown compression method in chunk offset reconstruction\"));\n            }\n        }\n     }\n        \n     try\n     {\n            \n        //\n        // \n        //\n        \n        Int64 chunk_start = position;\n        for (size_t i = 0; i < total_chunks ; i++)\n        {\n            //\n            // do we have a part number?\n            //\n            \n            int partNumber = 0;\n            if(isMultiPart(version))\n            {\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, partNumber);\n            }\n            \n            \n            \n            if(partNumber<0 || partNumber>= static_cast<int>(parts.size()))\n            {\n                throw IEX_NAMESPACE::IoExc(\"part number out of range\");\n            }\n            \n            Header& header = parts[partNumber]->header;\n\n            // size of chunk NOT including multipart field\n            \n            Int64 size_of_chunk=0;\n\n            if (isTiled(header.type()))\n            {\n                //\n                // \n                //\n                int tilex,tiley,levelx,levely;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tilex);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tiley);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levelx);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levely);\n                \n                //std::cout << \"chunk_start for \" << tilex <<',' << tiley << ',' << levelx << ' ' << levely << ':' << chunk_start << std::endl;\n                    \n                \n                if(!tileOffsets[partNumber])\n                {\n                    // this shouldn't actually happen - we should have allocated a valid\n                    // tileOffsets for any part which isTiled\n                    throw IEX_NAMESPACE::IoExc(\"part not tiled\");\n                    \n                }\n                \n                if(!tileOffsets[partNumber]->isValidTile(tilex,tiley,levelx,levely))\n                {\n                    throw IEX_NAMESPACE::IoExc(\"invalid tile coordinates\");\n                }\n                \n                (*tileOffsets[partNumber])(tilex,tiley,levelx,levely)=chunk_start;\n                \n                // compute chunk sizes - different procedure for deep tiles and regular\n                // ones\n                if(header.type()==DEEPTILE)\n                {\n                    Int64 packed_offset;\n                    Int64 packed_sample;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);\n                    \n                    //add 40 byte header to packed sizes (tile coordinates, packed sizes, unpacked size)\n                    size_of_chunk=packed_offset+packed_sample + 40ll;\n                }\n                else\n                {\n                    \n                    // regular image has 20 bytes of header, 4 byte chunksize;\n                    int chunksize;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);\n                    size_of_chunk=static_cast<Int64>(chunksize) + 20ll;\n                }\n            }\n            else\n            {\n                int y_coordinate;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, y_coordinate);\n                \n                \n                if(y_coordinate < header.dataWindow().min.y || y_coordinate > header.dataWindow().max.y)\n                {\n                   throw IEX_NAMESPACE::IoExc(\"y out of range\");\n                }\n                y_coordinate -= header.dataWindow().min.y;\n                y_coordinate /= rowsizes[partNumber];   \n                \n                if(y_coordinate < 0 || y_coordinate >= int(parts[partNumber]->chunkOffsets.size()))\n                {\n                   throw IEX_NAMESPACE::IoExc(\"chunk index out of range\");\n                }\n                \n                parts[partNumber]->chunkOffsets[y_coordinate]=chunk_start;\n                \n                if(header.type()==DEEPSCANLINE)\n                {\n                    Int64 packed_offset;\n                    Int64 packed_sample;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);\n                    \n                    \n                    size_of_chunk=packed_offset+packed_sample + 28ll;\n                }\n                else\n                {\n                    int chunksize;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);   \n                    size_of_chunk=static_cast<Int64>(chunksize) + 8ll;\n                }\n                \n            }\n            \n            if(isMultiPart(version))\n            {\n                chunk_start+=4;\n            }\n            \n            chunk_start+=size_of_chunk;\n            \n            is.seekg(chunk_start);\n            \n        }\n        \n    }\n    catch (...) //NOSONAR - suppress vulnerability reports from SonarCloud.\n    {\n        //\n        // Suppress all exceptions.  This functions is\n        // called only to reconstruct the line offset\n        // table for incomplete files, and exceptions\n        // are likely.\n        //\n    }\n\n    // copy tiled part data back to chunk offsets\n    \n    for(size_t partNumber=0;partNumber<parts.size();partNumber++)\n    {\n        if(tileOffsets[partNumber])\n        {\n            size_t pos=0;\n            vector<vector<vector <Int64> > > offsets = tileOffsets[partNumber]->getOffsets();\n            for (size_t l = 0; l < offsets.size(); l++)\n                for (size_t y = 0; y < offsets[l].size(); y++)\n                    for (size_t x = 0; x < offsets[l][y].size(); x++)\n                    {\n                        parts[ partNumber ]->chunkOffsets[pos] = offsets[l][y][x];\n                        pos++;\n                    }\n           delete tileOffsets[partNumber];\n        }\n    }\n\n    is.clear();\n    is.seekg (position);\n}\n\nInputPartData*\nMultiPartInputFile::Data::getPart(int partNumber)\n{\n    if (partNumber < 0 || partNumber >= (int) parts.size())\n        throw IEX_NAMESPACE::ArgExc (\"Part number is not in valid range.\");\n    return parts[partNumber];\n}\n\nnamespace{\nstatic const int gLargeChunkTableSize = 1024*1024;\n}\n\nvoid\nMultiPartInputFile::Data::readChunkOffsetTables(bool reconstructChunkOffsetTable)\n{\n    bool brokenPartsExist = false;\n\n    for (size_t i = 0; i < parts.size(); i++)\n    {\n        int chunkOffsetTableSize = getChunkOffsetTableSize(parts[i]->header);\n\n        //\n        // avoid allocating excessive memory.\n        // If the chunktablesize claims to be large,\n        // check the file is big enough to contain the table before allocating memory.\n        // Attempt to read the last entry in the table. Either the seekg() or the read()\n        // call will throw an exception if the file is too small to contain the table\n        //\n        if (chunkOffsetTableSize > gLargeChunkTableSize)\n        {\n            Int64 pos = is->tellg();\n            is->seekg(pos + (chunkOffsetTableSize-1)*sizeof(Int64));\n            Int64 temp;\n            OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*is, temp);\n            is->seekg(pos);\n\n        }\n\n        parts[i]->chunkOffsets.resize(chunkOffsetTableSize);\n\n\n\n        for (int j = 0; j < chunkOffsetTableSize; j++)\n            OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*is, parts[i]->chunkOffsets[j]);\n\n        //\n        // Check chunk offsets, reconstruct if broken.\n        // At first we assume the table is complete.\n        //\n        parts[i]->completed = true;\n        for (int j = 0; j < chunkOffsetTableSize; j++)\n        {\n            if (parts[i]->chunkOffsets[j] <= 0)\n            {\n                brokenPartsExist = true;\n                parts[i]->completed = false;\n                break;\n            }\n        }\n    }\n\n    if (brokenPartsExist && reconstructChunkOffsetTable)\n        chunkOffsetReconstruction(*is, parts);\n}\n\nint \nMultiPartInputFile::version() const\n{\n    return _data->version;\n}\n\nbool \nMultiPartInputFile::partComplete(int part) const\n{\n  return _data->parts[part]->completed;\n}\n\nint \nMultiPartInputFile::parts() const\n{\n   return int(_data->_headers.size());\n}\n\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_EXIT\n"], "fixing_code": ["///////////////////////////////////////////////////////////////////////////\n//\n// Copyright (c) 2011, Industrial Light & Magic, a division of Lucas\n// Digital Ltd. LLC\n//\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// *       Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// *       Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// *       Neither the name of Industrial Light & Magic nor the names of\n// its contributors may be used to endorse or promote products derived\n// from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n///////////////////////////////////////////////////////////////////////////\n\n#include \"ImfMultiPartInputFile.h\"\n\n#include \"ImfTimeCodeAttribute.h\"\n#include \"ImfChromaticitiesAttribute.h\"\n#include \"ImfBoxAttribute.h\"\n#include \"ImfFloatAttribute.h\"\n#include \"ImfStdIO.h\"\n#include \"ImfTileOffsets.h\"\n#include \"ImfMisc.h\"\n#include \"ImfTiledMisc.h\"\n#include \"ImfInputStreamMutex.h\"\n#include \"ImfInputPartData.h\"\n#include \"ImfPartType.h\"\n#include \"ImfInputFile.h\"\n#include \"ImfScanLineInputFile.h\"\n#include \"ImfTiledInputFile.h\"\n#include \"ImfDeepScanLineInputFile.h\"\n#include \"ImfDeepTiledInputFile.h\"\n#include \"ImfVersion.h\"\n\n#include <OpenEXRConfig.h>\n#include <IlmThread.h>\n#include <IlmThreadMutex.h>\n\n#include <Iex.h>\n#include <map>\n#include <set>\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_ENTER\n\nusing ILMTHREAD_NAMESPACE::Mutex;\nusing ILMTHREAD_NAMESPACE::Lock;\nusing IMATH_NAMESPACE::Box2i;\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\n\nnamespace\n{\n    // Controls whether we error out in the event of shared attribute\n    // inconsistency in the input file\n    static const bool strictSharedAttribute = true;\n}\n\nstruct MultiPartInputFile::Data: public InputStreamMutex\n{\n    int                         version;        // Version of this file.\n    bool                        deleteStream;   // If we should delete the stream during destruction.\n    vector<InputPartData*>      parts;          // Data to initialize Output files.\n    int                         numThreads;     // Number of threads\n    bool                        reconstructChunkOffsetTable;    // If we should reconstruct\n                                                                // the offset table if it's broken.\n    std::map<int,GenericInputFile*> _inputFiles;\n    std::vector<Header>             _headers;\n\n    \n    void                    chunkOffsetReconstruction(OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& is, const std::vector<InputPartData*>& parts);\n                                                      \n    void                    readChunkOffsetTables(bool reconstructChunkOffsetTable);\n                                                      \n    bool                    checkSharedAttributesValues(const Header & src,\n                                                        const Header & dst,\n                                                        std::vector<std::string> & conflictingAttributes) const;\n                                                                                                          \n   TileOffsets*            createTileOffsets(const Header& header);\n   \n   InputPartData*          getPart(int partNumber);\n   \n    Data (bool deleteStream, int numThreads, bool reconstructChunkOffsetTable):\n        InputStreamMutex(),\n        deleteStream (deleteStream),\n        numThreads (numThreads),\n        reconstructChunkOffsetTable(reconstructChunkOffsetTable)\n    {\n    }\n\n    ~Data()\n    {\n        if (deleteStream) delete is;\n\n        for (size_t i = 0; i < parts.size(); i++)\n            delete parts[i];\n    }\n    \n    Data (const Data& other) = delete;\n    Data& operator = (const Data& other) = delete;\n    Data (Data&& other) = delete;\n    Data& operator = (Data&& other) = delete;\n    \n    template <class T>\n    T*    createInputPartT(int partNumber)\n    {\n\n    }\n};\n\nMultiPartInputFile::MultiPartInputFile(const char fileName[],\n                           int numThreads,\n                           bool reconstructChunkOffsetTable):\n    _data(new Data(true, numThreads, reconstructChunkOffsetTable))\n{\n    try\n    {\n        _data->is = new StdIFStream (fileName);\n        initialize();\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        delete _data;\n\n        REPLACE_EXC (e, \"Cannot read image file \"\n                     \"\\\"\" << fileName << \"\\\". \" << e.what());\n        throw;\n    }\n    catch (...)\n    {\n        delete _data;\n        throw;\n    }\n}\n\nMultiPartInputFile::MultiPartInputFile (OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& is,\n                                        int numThreads,\n                                        bool reconstructChunkOffsetTable):\n    _data(new Data(false, numThreads, reconstructChunkOffsetTable))\n{\n    try\n    {\n        _data->is = &is;\n        initialize();\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        delete _data;\n\n        REPLACE_EXC (e, \"Cannot read image file \"\n                     \"\\\"\" << is.fileName() << \"\\\". \" << e.what());\n        throw;\n    }\n    catch (...)\n    {\n        delete _data;\n        throw;\n    }\n}\n\ntemplate<class T>\nT*\nMultiPartInputFile::getInputPart(int partNumber)\n{\n    Lock lock(*_data);\n            if (_data->_inputFiles.find(partNumber) == _data->_inputFiles.end())\n        {\n            T* file = new T(_data->getPart(partNumber));\n            _data->_inputFiles.insert(std::make_pair(partNumber, (GenericInputFile*) file));\n            return file;\n        }\n        else return (T*) _data->_inputFiles[partNumber];\n}\n\n\ntemplate InputFile* MultiPartInputFile::getInputPart<InputFile>(int);\ntemplate TiledInputFile* MultiPartInputFile::getInputPart<TiledInputFile>(int);\ntemplate DeepScanLineInputFile* MultiPartInputFile::getInputPart<DeepScanLineInputFile>(int);\ntemplate DeepTiledInputFile* MultiPartInputFile::getInputPart<DeepTiledInputFile>(int);\n\nInputPartData*\nMultiPartInputFile::getPart(int partNumber)\n{\n    return _data->getPart(partNumber);\n}\n\n\n\nconst Header &\n MultiPartInputFile::header(int n) const\n{\n    return _data->_headers[n];\n}\n\n\n\nMultiPartInputFile::~MultiPartInputFile()\n{\n    for (map<int, GenericInputFile*>::iterator it = _data->_inputFiles.begin();\n         it != _data->_inputFiles.end(); it++)\n    {\n        delete it->second;\n    }\n\n    delete _data;\n}\n\n\nbool\nMultiPartInputFile::Data::checkSharedAttributesValues(const Header & src,\n                                                const Header & dst,\n                                                vector<string> & conflictingAttributes) const\n{\n    conflictingAttributes.clear();\n\n    bool conflict = false;\n\n    //\n    // Display Window\n    //\n    if (src.displayWindow() != dst.displayWindow())\n    {\n        conflict = true;\n        conflictingAttributes.push_back (\"displayWindow\");\n    }\n\n\n    //\n    // Pixel Aspect Ratio\n    //\n    if (src.pixelAspectRatio() != dst.pixelAspectRatio())\n    {\n        conflict = true;\n        conflictingAttributes.push_back (\"pixelAspectRatio\");\n    }\n\n\n    //\n    // Timecode\n    //\n    const TimeCodeAttribute * srcTimeCode = src.findTypedAttribute<\n          TimeCodeAttribute> (TimeCodeAttribute::staticTypeName());\n    const TimeCodeAttribute * dstTimeCode = dst.findTypedAttribute<\n          TimeCodeAttribute> (TimeCodeAttribute::staticTypeName());\n\n    if (dstTimeCode)\n    {\n        if  ( (srcTimeCode && (srcTimeCode->value() != dstTimeCode->value())) ||\n              (!srcTimeCode))\n        {\n            conflict = true;\n            conflictingAttributes.push_back (TimeCodeAttribute::staticTypeName());\n        }\n    }\n\n    //\n    // Chromaticities\n    //\n    const ChromaticitiesAttribute * srcChrom =  src.findTypedAttribute<\n          ChromaticitiesAttribute> (ChromaticitiesAttribute::staticTypeName());\n    const ChromaticitiesAttribute * dstChrom =  dst.findTypedAttribute<\n          ChromaticitiesAttribute> (ChromaticitiesAttribute::staticTypeName());\n\n    if (dstChrom)\n    {\n        if ( (srcChrom && (srcChrom->value() != dstChrom->value())) ||\n             (!srcChrom))\n        {\n            conflict = true;\n            conflictingAttributes.push_back (ChromaticitiesAttribute::staticTypeName());\n        }\n    }\n\n\n    return conflict;\n}\n\n\nvoid\nMultiPartInputFile::initialize()\n{\n    readMagicNumberAndVersionField(*_data->is, _data->version);\n    \n    bool multipart = isMultiPart(_data->version);\n    bool tiled = isTiled(_data->version);\n\n    //\n    // Multipart files don't have and shouldn't have the tiled bit set.\n    //\n\n    if (tiled && multipart)\n        throw IEX_NAMESPACE::InputExc (\"Multipart files cannot have the tiled bit set\");\n\n    \n    int pos = 0;\n    while (true)\n    {\n        Header header;\n        header.readFrom(*_data->is, _data->version);\n\n        //\n        // If we read nothing then we stop reading.\n        //\n\n        if (header.readsNothing())\n        {\n            pos++;\n            break;\n        }\n\n        _data->_headers.push_back(header);\n        \n        if(multipart == false)\n          break;\n    }\n\n    //\n    // Perform usual check on headers.\n    //\n\n    if ( _data->_headers.size() == 0)\n    {\n        throw IEX_NAMESPACE::ArgExc (\"Files must contain at least one header\");\n    }\n\n    for (size_t i = 0; i < _data->_headers.size(); i++)\n    {\n        //\n        // Silently invent a type if the file is a single part regular image.\n        //\n\n        if( _data->_headers[i].hasType() == false )\n        {\n            if(multipart)\n\n                throw IEX_NAMESPACE::ArgExc (\"Every header in a multipart file should have a type\");\n          \n            _data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);\n        }\n        else\n        {\n            \n            //\n            // Silently fix the header type if it's wrong\n            // (happens when a regular Image file written by EXR_2.0 is rewritten by an older library,\n            //  so doesn't effect deep image types)\n            //\n\n            if(!multipart && !isNonImage(_data->version))\n            {\n                _data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);\n            }\n        }\n         \n\n        \n        if( _data->_headers[i].hasName() == false )\n        {\n            if(multipart)\n                throw IEX_NAMESPACE::ArgExc (\"Every header in a multipart file should have a name\");\n        }\n        \n        if (isTiled(_data->_headers[i].type()))\n            _data->_headers[i].sanityCheck(true, multipart);\n        else\n            _data->_headers[i].sanityCheck(false, multipart);\n    }\n\n    //\n    // Check name uniqueness.\n    //\n\n    if (multipart)\n    {\n        set<string> names;\n        for (size_t i = 0; i < _data->_headers.size(); i++)\n        {\n        \n            if (names.find(_data->_headers[i].name()) != names.end())\n            {\n                throw IEX_NAMESPACE::InputExc (\"Header name \" + _data->_headers[i].name() +\n                                   \" is not a unique name.\");\n            }\n            names.insert(_data->_headers[i].name());\n        }\n    }\n    \n    //\n    // Check shared attributes compliance.\n    //\n\n    if (multipart && strictSharedAttribute)\n    {\n        for (size_t i = 1; i < _data->_headers.size(); i++)\n        {\n            vector <string> attrs;\n            if (_data->checkSharedAttributesValues (_data->_headers[0], _data->_headers[i], attrs))\n            {\n                string attrNames;\n                for (size_t j=0; j<attrs.size(); j++)\n                    attrNames += \" \" + attrs[j];\n                throw IEX_NAMESPACE::InputExc (\"Header name \" + _data->_headers[i].name() +\n                                     \" has non-conforming shared attributes: \"+\n                                     attrNames);\n            }\n        }\n    }\n\n    //\n    // Create InputParts and read chunk offset tables.\n    //\n        \n    for (size_t i = 0; i < _data->_headers.size(); i++)\n        _data->parts.push_back(\n                new InputPartData(_data, _data->_headers[i], i, _data->numThreads, _data->version));\n\n    _data->readChunkOffsetTables(_data->reconstructChunkOffsetTable);\n}\n\nTileOffsets*\nMultiPartInputFile::Data::createTileOffsets(const Header& header)\n{\n    //\n    // Get the dataWindow information\n    //\n\n    const Box2i &dataWindow = header.dataWindow();\n    int minX = dataWindow.min.x;\n    int maxX = dataWindow.max.x;\n    int minY = dataWindow.min.y;\n    int maxY = dataWindow.max.y;\n\n    //\n    // Precompute level and tile information\n    //\n\n    int* numXTiles = nullptr;\n    int* numYTiles = nullptr;\n    int numXLevels, numYLevels;\n    TileDescription tileDesc = header.tileDescription();\n    try\n    {\n\n        precalculateTileInfo (tileDesc,\n                            minX, maxX,\n                            minY, maxY,\n                            numXTiles, numYTiles,\n                            numXLevels, numYLevels);\n\n        TileOffsets* tileOffsets = new TileOffsets (tileDesc.mode,\n                                                    numXLevels,\n                                                    numYLevels,\n                                                    numXTiles,\n                                                    numYTiles);\n        delete [] numXTiles;\n        delete [] numYTiles;\n\n        return tileOffsets;\n\n    }\n    catch(...)\n    {\n        delete [] numXTiles;\n        delete [] numYTiles;\n        throw;\n    }\n\n}\n\n\nvoid\nMultiPartInputFile::Data::chunkOffsetReconstruction(OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& is, const vector<InputPartData*>& parts)\n{\n    //\n    // Reconstruct broken chunk offset tables. Stop once we received any exception.\n    //\n\n    Int64 position = is.tellg();\n\n    \n    //\n    // check we understand all the parts available: if not, we cannot continue\n    // exceptions thrown here should trickle back up to the constructor\n    //\n    \n    for (size_t i = 0; i < parts.size(); i++)\n    {\n        Header& header=parts[i]->header;\n        \n        //\n        // do we have a valid type entry?\n        // we only need them for true multipart files or single part non-image (deep) files\n        //\n        if(!header.hasType() && (isMultiPart(version) || isNonImage(version)))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with missing type\");\n        }\n        if(!isSupportedType(header.type()))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with unknown type \"+header.type());\n        }\n    }\n    \n    \n    // how many chunks should we read? We should stop when we reach the end\n    size_t total_chunks = 0;\n        \n    // for tiled-based parts, array of (pointers to) tileOffsets objects\n    // to create mapping between tile coordinates and chunk table indices\n    \n    \n    vector<TileOffsets*> tileOffsets(parts.size());\n    \n    // for scanline-based parts, number of scanlines in each chunk\n    vector<int> rowsizes(parts.size());\n        \n    for(size_t i = 0 ; i < parts.size() ; i++)\n    {\n        total_chunks += parts[i]->chunkOffsets.size();\n        if (isTiled(parts[i]->header.type()))\n        {\n            tileOffsets[i] = createTileOffsets(parts[i]->header);\n        }else{\n            tileOffsets[i] = NULL;\n            // (TODO) fix this so that it doesn't need to be revised for future compression types.\n            switch(parts[i]->header.compression())\n            {\n                case DWAB_COMPRESSION :\n                    rowsizes[i] = 256;\n                    break;\n                case PIZ_COMPRESSION :\n                case B44_COMPRESSION :\n                case B44A_COMPRESSION :\n                case DWAA_COMPRESSION :\n                    rowsizes[i]=32;\n                    break;\n                case ZIP_COMPRESSION :\n                case PXR24_COMPRESSION :\n                    rowsizes[i]=16;\n                    break;\n                case ZIPS_COMPRESSION :\n                case RLE_COMPRESSION :\n                case NO_COMPRESSION :\n                    rowsizes[i]=1;\n                    break;\n                default :\n                    throw(IEX_NAMESPACE::ArgExc(\"Unknown compression method in chunk offset reconstruction\"));\n            }\n        }\n     }\n        \n     try\n     {\n            \n        //\n        // \n        //\n        \n        Int64 chunk_start = position;\n        for (size_t i = 0; i < total_chunks ; i++)\n        {\n            //\n            // do we have a part number?\n            //\n            \n            int partNumber = 0;\n            if(isMultiPart(version))\n            {\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, partNumber);\n            }\n            \n            \n            \n            if(partNumber<0 || partNumber>= static_cast<int>(parts.size()))\n            {\n                throw IEX_NAMESPACE::IoExc(\"part number out of range\");\n            }\n            \n            Header& header = parts[partNumber]->header;\n\n            // size of chunk NOT including multipart field\n            \n            Int64 size_of_chunk=0;\n\n            if (isTiled(header.type()))\n            {\n                //\n                // \n                //\n                int tilex,tiley,levelx,levely;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tilex);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tiley);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levelx);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levely);\n                \n                //std::cout << \"chunk_start for \" << tilex <<',' << tiley << ',' << levelx << ' ' << levely << ':' << chunk_start << std::endl;\n                    \n                \n                if(!tileOffsets[partNumber])\n                {\n                    // this shouldn't actually happen - we should have allocated a valid\n                    // tileOffsets for any part which isTiled\n                    throw IEX_NAMESPACE::IoExc(\"part not tiled\");\n                    \n                }\n                \n                if(!tileOffsets[partNumber]->isValidTile(tilex,tiley,levelx,levely))\n                {\n                    throw IEX_NAMESPACE::IoExc(\"invalid tile coordinates\");\n                }\n                \n                (*tileOffsets[partNumber])(tilex,tiley,levelx,levely)=chunk_start;\n                \n                // compute chunk sizes - different procedure for deep tiles and regular\n                // ones\n                if(header.type()==DEEPTILE)\n                {\n                    Int64 packed_offset;\n                    Int64 packed_sample;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);\n                    \n                    //add 40 byte header to packed sizes (tile coordinates, packed sizes, unpacked size)\n                    size_of_chunk=packed_offset+packed_sample + 40ll;\n                }\n                else\n                {\n                    \n                    // regular image has 20 bytes of header, 4 byte chunksize;\n                    int chunksize;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);\n                    size_of_chunk=static_cast<Int64>(chunksize) + 20ll;\n                }\n            }\n            else\n            {\n                int y_coordinate;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, y_coordinate);\n                \n                \n                if(y_coordinate < header.dataWindow().min.y || y_coordinate > header.dataWindow().max.y)\n                {\n                   throw IEX_NAMESPACE::IoExc(\"y out of range\");\n                }\n                y_coordinate -= header.dataWindow().min.y;\n                y_coordinate /= rowsizes[partNumber];   \n                \n                if(y_coordinate < 0 || y_coordinate >= int(parts[partNumber]->chunkOffsets.size()))\n                {\n                   throw IEX_NAMESPACE::IoExc(\"chunk index out of range\");\n                }\n                \n                parts[partNumber]->chunkOffsets[y_coordinate]=chunk_start;\n                \n                if(header.type()==DEEPSCANLINE)\n                {\n                    Int64 packed_offset;\n                    Int64 packed_sample;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);\n                    \n                    \n                    size_of_chunk=packed_offset+packed_sample + 28ll;\n                }\n                else\n                {\n                    int chunksize;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);   \n                    size_of_chunk=static_cast<Int64>(chunksize) + 8ll;\n                }\n                \n            }\n            \n            if(isMultiPart(version))\n            {\n                chunk_start+=4;\n            }\n            \n            chunk_start+=size_of_chunk;\n            \n            is.seekg(chunk_start);\n            \n        }\n        \n    }\n    catch (...) //NOSONAR - suppress vulnerability reports from SonarCloud.\n    {\n        //\n        // Suppress all exceptions.  This functions is\n        // called only to reconstruct the line offset\n        // table for incomplete files, and exceptions\n        // are likely.\n        //\n    }\n\n    // copy tiled part data back to chunk offsets\n    \n    for(size_t partNumber=0;partNumber<parts.size();partNumber++)\n    {\n        if(tileOffsets[partNumber])\n        {\n            size_t pos=0;\n            vector<vector<vector <Int64> > > offsets = tileOffsets[partNumber]->getOffsets();\n            for (size_t l = 0; l < offsets.size(); l++)\n                for (size_t y = 0; y < offsets[l].size(); y++)\n                    for (size_t x = 0; x < offsets[l][y].size(); x++)\n                    {\n                        parts[ partNumber ]->chunkOffsets[pos] = offsets[l][y][x];\n                        pos++;\n                    }\n           delete tileOffsets[partNumber];\n        }\n    }\n\n    is.clear();\n    is.seekg (position);\n}\n\nInputPartData*\nMultiPartInputFile::Data::getPart(int partNumber)\n{\n    if (partNumber < 0 || partNumber >= (int) parts.size())\n        throw IEX_NAMESPACE::ArgExc (\"Part number is not in valid range.\");\n    return parts[partNumber];\n}\n\nnamespace{\nstatic const int gLargeChunkTableSize = 1024*1024;\n}\n\nvoid\nMultiPartInputFile::Data::readChunkOffsetTables(bool reconstructChunkOffsetTable)\n{\n    bool brokenPartsExist = false;\n\n    for (size_t i = 0; i < parts.size(); i++)\n    {\n        int chunkOffsetTableSize = getChunkOffsetTableSize(parts[i]->header);\n\n        //\n        // avoid allocating excessive memory.\n        // If the chunktablesize claims to be large,\n        // check the file is big enough to contain the table before allocating memory.\n        // Attempt to read the last entry in the table. Either the seekg() or the read()\n        // call will throw an exception if the file is too small to contain the table\n        //\n        if (chunkOffsetTableSize > gLargeChunkTableSize)\n        {\n            Int64 pos = is->tellg();\n            is->seekg(pos + (chunkOffsetTableSize-1)*sizeof(Int64));\n            Int64 temp;\n            OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*is, temp);\n            is->seekg(pos);\n\n        }\n\n        parts[i]->chunkOffsets.resize(chunkOffsetTableSize);\n\n\n\n        for (int j = 0; j < chunkOffsetTableSize; j++)\n            OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*is, parts[i]->chunkOffsets[j]);\n\n        //\n        // Check chunk offsets, reconstruct if broken.\n        // At first we assume the table is complete.\n        //\n        parts[i]->completed = true;\n        for (int j = 0; j < chunkOffsetTableSize; j++)\n        {\n            if (parts[i]->chunkOffsets[j] <= 0)\n            {\n                brokenPartsExist = true;\n                parts[i]->completed = false;\n                break;\n            }\n        }\n    }\n\n    if (brokenPartsExist && reconstructChunkOffsetTable)\n        chunkOffsetReconstruction(*is, parts);\n}\n\nint \nMultiPartInputFile::version() const\n{\n    return _data->version;\n}\n\nbool \nMultiPartInputFile::partComplete(int part) const\n{\n  return _data->parts[part]->completed;\n}\n\nint \nMultiPartInputFile::parts() const\n{\n   return int(_data->_headers.size());\n}\n\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_EXIT\n"], "filenames": ["OpenEXR/IlmImf/ImfMultiPartInputFile.cpp"], "buggy_code_start_loc": [342], "buggy_code_end_loc": [342], "fixing_code_start_loc": [343], "fixing_code_end_loc": [348], "type": "CWE-476", "message": "A flaw was found in OpenEXR's Multipart input file functionality. A crafted multi-part input file with no actual parts can trigger a NULL pointer dereference. The highest threat from this vulnerability is to system availability.", "other": {"cve": {"id": "CVE-2021-20299", "sourceIdentifier": "secalert@redhat.com", "published": "2022-03-16T15:15:10.043", "lastModified": "2022-12-13T01:59:22.887", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in OpenEXR's Multipart input file functionality. A crafted multi-part input file with no actual parts can trigger a NULL pointer dereference. The highest threat from this vulnerability is to system availability."}, {"lang": "es", "value": "Se ha encontrado un fallo en la funcionalidad Multipart input file de OpenEXR. Un archivo de entrada multiparte dise\u00f1ado sin partes reales puede desencadenar una desreferencia de puntero NULL. La mayor amenaza de esta vulnerabilidad es la disponibilidad del sistema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openexr:openexr:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.5.4", "matchCriteriaId": "9A41E435-16D4-4706-B45A-0AB56664C6EF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=25740", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1939154", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/AcademySoftwareFoundation/openexr/commit/25e9515b06a6bc293d871622b8cafaee7af84e0f", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/12/msg00022.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/AcademySoftwareFoundation/openexr/commit/25e9515b06a6bc293d871622b8cafaee7af84e0f"}}