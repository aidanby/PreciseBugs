{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     CCCC   OOO   N   N  SSSSS  TTTTT  IIIII  TTTTT  U   U  TTTTT  EEEEE     %\n%    C      O   O  NN  N  SS       T      I      T    U   U    T    E         %\n%    C      O   O  N N N  ESSS     T      I      T    U   U    T    EEE       %\n%    C      O   O  N  NN     SS    T      I      T    U   U    T    E         %\n%     CCCC   OOO   N   N  SSSSS    T    IIIII    T     UUU     T    EEEEE     %\n%                                                                             %\n%                                                                             %\n%                  MagickCore Methods to Consitute an Image                   %\n%                                                                             %\n%                             Software Design                                 %\n%                                  Cristy                                     %\n%                               October 1998                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2015 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/constitute-private.h\"\n#include \"MagickCore/delegate.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/identify.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/policy.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/profile-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/stream.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/timer.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C o n s t i t u t e I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ConstituteImage() returns an image from the pixel data you supply.\n%  The pixel data must be in scanline order top-to-bottom.  The data can be\n%  char, short int, int, float, or double.  Float and double require the\n%  pixels to be normalized [0..1], otherwise [0..QuantumRange].  For example, to\n%  create a 640x480 image from unsigned red-green-blue character data, use:\n%\n%      image = ConstituteImage(640,480,\"RGB\",CharPixel,pixels,&exception);\n%\n%  The format of the ConstituteImage method is:\n%\n%      Image *ConstituteImage(const size_t columns,const size_t rows,\n%        const char *map,const StorageType storage,const void *pixels,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o columns: width in pixels of the image.\n%\n%    o rows: height in pixels of the image.\n%\n%    o map:  This string reflects the expected ordering of the pixel array.\n%      It can be any combination or order of R = red, G = green, B = blue,\n%      A = alpha (0 is transparent), O = opacity (0 is opaque), C = cyan,\n%      Y = yellow, M = magenta, K = black, I = intensity (for grayscale),\n%      P = pad.\n%\n%    o storage: Define the data type of the pixels.  Float and double types are\n%      expected to be normalized [0..1] otherwise [0..QuantumRange].  Choose\n%      from these types: CharPixel, DoublePixel, FloatPixel, IntegerPixel,\n%      LongPixel, QuantumPixel, or ShortPixel.\n%\n%    o pixels: This array of values contain the pixel components as defined by\n%      map and type.  You must preallocate this array where the expected\n%      length varies depending on the values of width, height, map, and type.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ConstituteImage(const size_t columns,const size_t rows,\n  const char *map,const StorageType storage,const void *pixels,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Allocate image structure.\n  */\n  assert(map != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",map);\n  assert(pixels != (void *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage((ImageInfo *) NULL,exception);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  if ((columns == 0) || (rows == 0))\n    ThrowImageException(OptionError,\"NonZeroWidthAndHeightRequired\");\n  image->columns=columns;\n  image->rows=rows;\n  (void) SetImageBackgroundColor(image,exception);\n  status=ImportImagePixels(image,0,0,columns,rows,map,storage,pixels,exception);\n  if (status == MagickFalse)\n     image=DestroyImage(image);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   P i n g I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PingImage() returns all the properties of an image or image sequence\n%  except for the pixels.  It is much faster and consumes far less memory\n%  than ReadImage().  On failure, a NULL image is returned and exception\n%  describes the reason for the failure.\n%\n%  The format of the PingImage method is:\n%\n%      Image *PingImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: Ping the image defined by the file or filename members of\n%      this structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic size_t PingStream(const Image *magick_unused(image),\n  const void *magick_unused(pixels),const size_t columns)\n{\n  return(columns);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nMagickExport Image *PingImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  ImageInfo\n    *ping_info;\n\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  ping_info=CloneImageInfo(image_info);\n  ping_info->ping=MagickTrue;\n  image=ReadStream(ping_info,&PingStream,exception);\n  if (image != (Image *) NULL)\n    {\n      ResetTimer(&image->timer);\n      if (ping_info->verbose != MagickFalse)\n        (void) IdentifyImage(image,stdout,MagickFalse,exception);\n    }\n  ping_info=DestroyImageInfo(ping_info);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   P i n g I m a g e s                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PingImages() pings one or more images and returns them as an image list.\n%\n%  The format of the PingImage method is:\n%\n%      Image *PingImages(ImageInfo *image_info,const char *filename,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o filename: the image filename.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *PingImages(ImageInfo *image_info,const char *filename,\n  ExceptionInfo *exception)\n{\n  char\n    ping_filename[MagickPathExtent];\n\n  Image\n    *image,\n    *images;\n\n  ImageInfo\n    *read_info;\n\n  /*\n    Ping image list from a file.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  (void) SetImageOption(image_info,\"filename\",filename);\n  (void) CopyMagickString(image_info->filename,filename,MagickPathExtent);\n  (void) InterpretImageFilename(image_info,(Image *) NULL,image_info->filename,\n    (int) image_info->scene,ping_filename,exception);\n  if (LocaleCompare(ping_filename,image_info->filename) != 0)\n    {\n      ExceptionInfo\n        *sans;\n\n      ssize_t\n        extent,\n        scene;\n\n      /*\n        Images of the form image-%d.png[1-5].\n      */\n      read_info=CloneImageInfo(image_info);\n      sans=AcquireExceptionInfo();\n      (void) SetImageInfo(read_info,0,sans);\n      sans=DestroyExceptionInfo(sans);\n      if (read_info->number_scenes == 0)\n        {\n          read_info=DestroyImageInfo(read_info);\n          return(PingImage(image_info,exception));\n        }\n      (void) CopyMagickString(ping_filename,read_info->filename,MagickPathExtent);\n      images=NewImageList();\n      extent=(ssize_t) (read_info->scene+read_info->number_scenes);\n      for (scene=(ssize_t) read_info->scene; scene < (ssize_t) extent; scene++)\n      {\n        (void) InterpretImageFilename(image_info,(Image *) NULL,ping_filename,\n          (int) scene,read_info->filename,exception);\n        image=PingImage(read_info,exception);\n        if (image == (Image *) NULL)\n          continue;\n        AppendImageToList(&images,image);\n      }\n      read_info=DestroyImageInfo(read_info);\n      return(images);\n    }\n  return(PingImage(image_info,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadImage() reads an image or image sequence from a file or file handle.\n%  The method returns a NULL if there is a memory shortage or if the image\n%  cannot be read.  On failure, a NULL image is returned and exception\n%  describes the reason for the failure.\n%\n%  The format of the ReadImage method is:\n%\n%      Image *ReadImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: Read the image defined by the file or filename members of\n%      this structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ReadImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    magick[MagickPathExtent],\n    magick_filename[MagickPathExtent];\n\n  const char\n    *value;\n\n  const DelegateInfo\n    *delegate_info;\n\n  const MagickInfo\n    *magick_info;\n\n  ExceptionInfo\n    *sans_exception;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image,\n    *next;\n\n  ImageInfo\n    *read_info;\n\n  MagickStatusType\n    flags;\n\n  PolicyDomain\n    domain;\n\n  PolicyRights\n    rights;\n\n  /*\n    Determine image type from filename prefix or suffix (e.g. image.jpg).\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image_info->filename != (char *) NULL);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  read_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(magick_filename,read_info->filename,MagickPathExtent);\n  (void) SetImageInfo(read_info,0,exception);\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) CopyMagickString(magick,read_info->magick,MagickPathExtent);\n  domain=CoderPolicyDomain;\n  rights=ReadPolicyRights;\n  if (IsRightsAuthorized(domain,rights,read_info->magick) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",read_info->filename);\n      read_info=DestroyImageInfo(read_info);\n      return((Image *) NULL);\n    }\n  /*\n    Call appropriate image reader based on image type.\n  */\n  sans_exception=AcquireExceptionInfo();\n  magick_info=GetMagickInfo(read_info->magick,sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if (magick_info != (const MagickInfo *) NULL)\n    {\n      if (GetMagickEndianSupport(magick_info) == MagickFalse)\n        read_info->endian=UndefinedEndian;\n      else\n        if ((image_info->endian == UndefinedEndian) &&\n            (GetMagickRawSupport(magick_info) != MagickFalse))\n          {\n            unsigned long\n              lsb_first;\n\n            lsb_first=1;\n            read_info->endian=(*(char *) &lsb_first) == 1 ? LSBEndian :\n              MSBEndian;\n         }\n    }\n  if ((magick_info != (const MagickInfo *) NULL) &&\n      (GetMagickSeekableStream(magick_info) != MagickFalse))\n    {\n      MagickBooleanType\n        status;\n\n      image=AcquireImage(read_info,exception);\n      (void) CopyMagickString(image->filename,read_info->filename,\n        MagickPathExtent);\n      status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        {\n          read_info=DestroyImageInfo(read_info);\n          image=DestroyImage(image);\n          return((Image *) NULL);\n        }\n      if (IsBlobSeekable(image) == MagickFalse)\n        {\n          /*\n            Coder requires a seekable stream.\n          */\n          *read_info->filename='\\0';\n          status=ImageToFile(image,read_info->filename,exception);\n          if (status == MagickFalse)\n            {\n              (void) CloseBlob(image);\n              read_info=DestroyImageInfo(read_info);\n              image=DestroyImage(image);\n              return((Image *) NULL);\n            }\n          read_info->temporary=MagickTrue;\n        }\n      (void) CloseBlob(image);\n      image=DestroyImage(image);\n    }\n  image=NewImageList();\n  if ((magick_info == (const MagickInfo *) NULL) ||\n      (GetImageDecoder(magick_info) == (DecodeImageHandler *) NULL))\n    {\n      delegate_info=GetDelegateInfo(read_info->magick,(char *) NULL,exception);\n      if (delegate_info == (const DelegateInfo *) NULL)\n        {\n          (void) SetImageInfo(read_info,0,exception);\n          (void) CopyMagickString(read_info->filename,filename,\n            MagickPathExtent);\n          magick_info=GetMagickInfo(read_info->magick,exception);\n        }\n    }\n  if ((magick_info != (const MagickInfo *) NULL) &&\n      (GetImageDecoder(magick_info) != (DecodeImageHandler *) NULL))\n    {\n      if (GetMagickDecoderThreadSupport(magick_info) == MagickFalse)\n        LockSemaphoreInfo(magick_info->semaphore);\n      image=GetImageDecoder(magick_info)(read_info,exception);\n      if (GetMagickDecoderThreadSupport(magick_info) == MagickFalse)\n        UnlockSemaphoreInfo(magick_info->semaphore);\n    }\n  else\n    {\n      delegate_info=GetDelegateInfo(read_info->magick,(char *) NULL,exception);\n      if (delegate_info == (const DelegateInfo *) NULL)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            MissingDelegateError,\"NoDecodeDelegateForThisImageFormat\",\"`%s'\",\n            read_info->magick);\n          if (read_info->temporary != MagickFalse)\n            (void) RelinquishUniqueFileResource(read_info->filename);\n          read_info=DestroyImageInfo(read_info);\n          return((Image *) NULL);\n        }\n      /*\n        Let our decoding delegate process the image.\n      */\n      image=AcquireImage(read_info,exception);\n      if (image == (Image *) NULL)\n        {\n          read_info=DestroyImageInfo(read_info);\n          return((Image *) NULL);\n        }\n      (void) CopyMagickString(image->filename,read_info->filename,\n        MagickPathExtent);\n      *read_info->filename='\\0';\n      if (GetDelegateThreadSupport(delegate_info) == MagickFalse)\n        LockSemaphoreInfo(delegate_info->semaphore);\n      (void) InvokeDelegate(read_info,image,read_info->magick,(char *) NULL,\n        exception);\n      if (GetDelegateThreadSupport(delegate_info) == MagickFalse)\n        UnlockSemaphoreInfo(delegate_info->semaphore);\n      image=DestroyImageList(image);\n      read_info->temporary=MagickTrue;\n      (void) SetImageInfo(read_info,0,exception);\n      magick_info=GetMagickInfo(read_info->magick,exception);\n      if ((magick_info == (const MagickInfo *) NULL) ||\n          (GetImageDecoder(magick_info) == (DecodeImageHandler *) NULL))\n        {\n          if (IsPathAccessible(read_info->filename) != MagickFalse)\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              MissingDelegateError,\"NoDecodeDelegateForThisImageFormat\",\"`%s'\",\n              read_info->magick);\n          else\n            ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n              read_info->filename);\n          read_info=DestroyImageInfo(read_info);\n          return((Image *) NULL);\n        }\n      if (GetMagickDecoderThreadSupport(magick_info) == MagickFalse)\n        LockSemaphoreInfo(magick_info->semaphore);\n      image=(Image *) (GetImageDecoder(magick_info))(read_info,exception);\n      if (GetMagickDecoderThreadSupport(magick_info) == MagickFalse)\n        UnlockSemaphoreInfo(magick_info->semaphore);\n    }\n  if (read_info->temporary != MagickFalse)\n    {\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      read_info->temporary=MagickFalse;\n      if (image != (Image *) NULL)\n        (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n    }\n  if (image == (Image *) NULL)\n    {\n      read_info=DestroyImageInfo(read_info);\n      return(image);\n    }\n  if (exception->severity >= ErrorException)\n    (void) LogMagickEvent(ExceptionEvent,GetMagickModule(),\n      \"Coder (%s) generated an image despite an error (%d), \"\n      \"notify the developers\",image->magick,exception->severity);\n  if (IsBlobTemporary(image) != MagickFalse)\n    (void) RelinquishUniqueFileResource(read_info->filename);\n  if ((GetNextImageInList(image) != (Image *) NULL) &&\n      (IsSceneGeometry(read_info->scenes,MagickFalse) != MagickFalse))\n    {\n      Image\n        *clones;\n\n      clones=CloneImages(image,read_info->scenes,exception);\n      if (clones == (Image *) NULL)\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"SubimageSpecificationReturnsNoImages\",\"`%s'\",read_info->filename);\n      else\n        {\n          image=DestroyImageList(image);\n          image=GetFirstImageInList(clones);\n        }\n    }\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    char\n      magick_path[MagickPathExtent],\n      *property,\n      timestamp[MagickPathExtent];\n\n    const char\n      *option;\n\n    const StringInfo\n      *profile;\n\n    next->taint=MagickFalse;\n    GetPathComponent(magick_filename,MagickPath,magick_path);\n    if (*magick_path == '\\0' && *next->magick == '\\0')\n      (void) CopyMagickString(next->magick,magick,MagickPathExtent);\n    (void) CopyMagickString(next->magick_filename,magick_filename,\n      MagickPathExtent);\n    if (IsBlobTemporary(image) != MagickFalse)\n      (void) CopyMagickString(next->filename,filename,MagickPathExtent);\n    if (next->magick_columns == 0)\n      next->magick_columns=next->columns;\n    if (next->magick_rows == 0)\n      next->magick_rows=next->rows;\n    value=GetImageProperty(next,\"tiff:Orientation\",exception);\n    if (value == (char *) NULL)\n      value=GetImageProperty(next,\"exif:Orientation\",exception);\n    if (value != (char *) NULL)\n      {\n        next->orientation=(OrientationType) StringToLong(value);\n        (void) DeleteImageProperty(next,\"tiff:Orientation\");\n        (void) DeleteImageProperty(next,\"exif:Orientation\");\n      }\n    value=GetImageProperty(next,\"exif:XResolution\",exception);\n    if (value != (char *) NULL)\n      {\n        geometry_info.rho=next->resolution.x;\n        geometry_info.sigma=1.0;\n        flags=ParseGeometry(value,&geometry_info);\n        if (geometry_info.sigma != 0)\n          next->resolution.x=geometry_info.rho/geometry_info.sigma;\n        (void) DeleteImageProperty(next,\"exif:XResolution\");\n      }\n    value=GetImageProperty(next,\"exif:YResolution\",exception);\n    if (value != (char *) NULL)\n      {\n        geometry_info.rho=next->resolution.y;\n        geometry_info.sigma=1.0;\n        flags=ParseGeometry(value,&geometry_info);\n        if (geometry_info.sigma != 0)\n          next->resolution.y=geometry_info.rho/geometry_info.sigma;\n        (void) DeleteImageProperty(next,\"exif:YResolution\");\n      }\n    value=GetImageProperty(next,\"tiff:ResolutionUnit\",exception);\n    if (value == (char *) NULL)\n      value=GetImageProperty(next,\"exif:ResolutionUnit\",exception);\n    if (value != (char *) NULL)\n      {\n        next->units=(ResolutionType) (StringToLong(value)-1);\n        (void) DeleteImageProperty(next,\"exif:ResolutionUnit\");\n        (void) DeleteImageProperty(next,\"tiff:ResolutionUnit\");\n      }\n    if (next->page.width == 0)\n      next->page.width=next->columns;\n    if (next->page.height == 0)\n      next->page.height=next->rows;\n    option=GetImageOption(read_info,\"caption\");\n    if (option != (const char *) NULL)\n      {\n        property=InterpretImageProperties(read_info,next,option,exception);\n        (void) SetImageProperty(next,\"caption\",property,exception);\n        property=DestroyString(property);\n      }\n    option=GetImageOption(read_info,\"comment\");\n    if (option != (const char *) NULL)\n      {\n        property=InterpretImageProperties(read_info,next,option,exception);\n        (void) SetImageProperty(next,\"comment\",property,exception);\n        property=DestroyString(property);\n      }\n    option=GetImageOption(read_info,\"label\");\n    if (option != (const char *) NULL)\n      {\n        property=InterpretImageProperties(read_info,next,option,exception);\n        (void) SetImageProperty(next,\"label\",property,exception);\n        property=DestroyString(property);\n      }\n    if (LocaleCompare(next->magick,\"TEXT\") == 0)\n      (void) ParseAbsoluteGeometry(\"0x0+0+0\",&next->page);\n    if ((read_info->extract != (char *) NULL) &&\n        (read_info->stream == (StreamHandler) NULL))\n      {\n        RectangleInfo\n          geometry;\n\n        flags=ParseAbsoluteGeometry(read_info->extract,&geometry);\n        if ((next->columns != geometry.width) ||\n            (next->rows != geometry.height))\n          {\n            if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n              {\n                Image\n                  *crop_image;\n\n                crop_image=CropImage(next,&geometry,exception);\n                if (crop_image != (Image *) NULL)\n                  ReplaceImageInList(&next,crop_image);\n              }\n            else\n              if (((flags & WidthValue) != 0) || ((flags & HeightValue) != 0))\n                {\n                  Image\n                    *size_image;\n\n                  flags=ParseRegionGeometry(next,read_info->extract,&geometry,\n                    exception);\n                  size_image=ResizeImage(next,geometry.width,geometry.height,\n                    next->filter,exception);\n                  if (size_image != (Image *) NULL)\n                    ReplaceImageInList(&next,size_image);\n                }\n          }\n      }\n    profile=GetImageProfile(next,\"icc\");\n    if (profile == (const StringInfo *) NULL)\n      profile=GetImageProfile(next,\"icm\");\n    profile=GetImageProfile(next,\"iptc\");\n    if (profile == (const StringInfo *) NULL)\n      profile=GetImageProfile(next,\"8bim\");\n    (void) FormatMagickTime(GetBlobProperties(next)->st_mtime,MagickPathExtent,\n      timestamp);\n    (void) SetImageProperty(next,\"date:modify\",timestamp,exception);\n    (void) FormatMagickTime(GetBlobProperties(next)->st_ctime,MagickPathExtent,\n      timestamp);\n    (void) SetImageProperty(next,\"date:create\",timestamp,exception);\n    option=GetImageOption(image_info,\"delay\");\n    if (option != (const char *) NULL)\n      {\n        flags=ParseGeometry(option,&geometry_info);\n        if ((flags & GreaterValue) != 0)\n          {\n            if (next->delay > (size_t) floor(geometry_info.rho+0.5))\n              next->delay=(size_t) floor(geometry_info.rho+0.5);\n          }\n        else\n          if ((flags & LessValue) != 0)\n            {\n              if (next->delay < (size_t) floor(geometry_info.rho+0.5))\n                next->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n            }\n          else\n            next->delay=(size_t) floor(geometry_info.rho+0.5);\n        if ((flags & SigmaValue) != 0)\n          next->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n      }\n    option=GetImageOption(image_info,\"dispose\");\n    if (option != (const char *) NULL)\n      next->dispose=(DisposeType) ParseCommandOption(MagickDisposeOptions,\n        MagickFalse,option);\n    if (read_info->verbose != MagickFalse)\n      (void) IdentifyImage(next,stderr,MagickFalse,exception);\n    image=next;\n  }\n  read_info=DestroyImageInfo(read_info);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d I m a g e s                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadImages() reads one or more images and returns them as an image list.\n%\n%  The format of the ReadImage method is:\n%\n%      Image *ReadImages(ImageInfo *image_info,const char *filename,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o filename: the image filename.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ReadImages(ImageInfo *image_info,const char *filename,\n  ExceptionInfo *exception)\n{\n  char\n    read_filename[MagickPathExtent];\n\n  Image\n    *image,\n    *images;\n\n  ImageInfo\n    *read_info;\n\n  /*\n    Read image list from a file.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  (void) SetImageOption(read_info,\"filename\",filename);\n  (void) CopyMagickString(read_info->filename,filename,MagickPathExtent);\n  (void) InterpretImageFilename(read_info,(Image *) NULL,filename,\n    (int) read_info->scene,read_filename,exception);\n  if (LocaleCompare(read_filename,read_info->filename) != 0)\n    {\n      ExceptionInfo\n        *sans;\n\n      ssize_t\n        extent,\n        scene;\n\n      /*\n        Images of the form image-%d.png[1-5].\n      */\n      sans=AcquireExceptionInfo();\n      (void) SetImageInfo(read_info,0,sans);\n      sans=DestroyExceptionInfo(sans);\n      if (read_info->number_scenes == 0)\n        {\n          read_info=DestroyImageInfo(read_info);\n          return(ReadImage(image_info,exception));\n        }\n      (void) CopyMagickString(read_filename,read_info->filename,MagickPathExtent);\n      images=NewImageList();\n      extent=(ssize_t) (read_info->scene+read_info->number_scenes);\n      for (scene=(ssize_t) read_info->scene; scene < (ssize_t) extent; scene++)\n      {\n        (void) InterpretImageFilename(image_info,(Image *) NULL,read_filename,\n          (int) scene,read_info->filename,exception);\n        image=ReadImage(read_info,exception);\n        if (image == (Image *) NULL)\n          continue;\n        AppendImageToList(&images,image);\n      }\n      read_info=DestroyImageInfo(read_info);\n      return(images);\n    }\n  image=ReadImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e a d I n l i n e I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadInlineImage() reads a Base64-encoded inline image or image sequence.\n%  The method returns a NULL if there is a memory shortage or if the image\n%  cannot be read.  On failure, a NULL image is returned and exception\n%  describes the reason for the failure.\n%\n%  The format of the ReadInlineImage method is:\n%\n%      Image *ReadInlineImage(const ImageInfo *image_info,const char *content,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o content: the image encoded in Base64.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ReadInlineImage(const ImageInfo *image_info,\n  const char *content,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  unsigned char\n    *blob;\n\n  size_t\n    length;\n\n  register const char\n    *p;\n\n  /*\n    Skip over header (e.g. data:image/gif;base64,).\n  */\n  image=NewImageList();\n  for (p=content; (*p != ',') && (*p != '\\0'); p++) ;\n  if (*p == '\\0')\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  p++;\n  length=0;\n  blob=Base64Decode(p,&length);\n  if (length == 0)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  *read_info->filename='\\0';\n  *read_info->magick='\\0';\n  image=BlobToImage(read_info,blob,length,exception);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n  read_info=DestroyImageInfo(read_info);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e I m a g e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteImage() writes an image or an image sequence to a file or file handle.\n%  If writing to a file is on disk, the name is defined by the filename member\n%  of the image structure.  WriteImage() returns MagickFalse is there is a\n%  memory shortage or if the image cannot be written.  Check the exception\n%  member of image to determine the cause for any failure.\n%\n%  The format of the WriteImage method is:\n%\n%      MagickBooleanType WriteImage(const ImageInfo *image_info,Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType WriteImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  const char\n    *option;\n\n  const DelegateInfo\n    *delegate_info;\n\n  const MagickInfo\n    *magick_info;\n\n  ExceptionInfo\n    *sans_exception;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status,\n    temporary;\n\n  PolicyDomain\n    domain;\n\n  PolicyRights\n    rights;\n\n  /*\n    Determine image type from filename prefix or suffix (e.g. image.jpg).\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  sans_exception=AcquireExceptionInfo();\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->filename,image->filename,MagickPathExtent);\n  (void) SetImageInfo(write_info,1,sans_exception);\n  if (*write_info->magick == '\\0')\n    (void) CopyMagickString(write_info->magick,image->magick,MagickPathExtent);\n  (void) CopyMagickString(filename,image->filename,MagickPathExtent);\n  (void) CopyMagickString(image->filename,write_info->filename,MagickPathExtent);\n  domain=CoderPolicyDomain;\n  rights=WritePolicyRights;\n  if (IsRightsAuthorized(domain,rights,write_info->magick) == MagickFalse)\n    {\n      sans_exception=DestroyExceptionInfo(sans_exception);\n      write_info=DestroyImageInfo(write_info);\n      errno=EPERM;\n      ThrowBinaryException(PolicyError,\"NotAuthorized\",filename);\n    }\n  /*\n    Call appropriate image reader based on image type.\n  */\n  magick_info=GetMagickInfo(write_info->magick,sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if (magick_info != (const MagickInfo *) NULL)\n    {\n      if (GetMagickEndianSupport(magick_info) == MagickFalse)\n        image->endian=UndefinedEndian;\n      else\n        if ((image_info->endian == UndefinedEndian) &&\n            (GetMagickRawSupport(magick_info) != MagickFalse))\n          {\n            unsigned long\n              lsb_first;\n\n            lsb_first=1;\n            image->endian=(*(char *) &lsb_first) == 1 ? LSBEndian : MSBEndian;\n         }\n    }\n  (void) SyncImageProfiles(image);\n  DisassociateImageStream(image);\n  option=GetImageOption(image_info,\"delegate:bimodal\");\n  if ((IfMagickTrue(IsStringTrue(option))) &&\n      (write_info->page == (char *) NULL) &&\n      (GetPreviousImageInList(image) == (Image *) NULL) &&\n      (GetNextImageInList(image) == (Image *) NULL) &&\n      (IfMagickFalse(IsTaintImage(image))) )\n    {\n      delegate_info=GetDelegateInfo(image->magick,write_info->magick,exception);\n      if ((delegate_info != (const DelegateInfo *) NULL) &&\n          (GetDelegateMode(delegate_info) == 0) &&\n          (IsPathAccessible(image->magick_filename) != MagickFalse))\n        {\n          /*\n            Process image with bi-modal delegate.\n          */\n          (void) CopyMagickString(image->filename,image->magick_filename,\n            MagickPathExtent);\n          status=InvokeDelegate(write_info,image,image->magick,\n            write_info->magick,exception);\n          write_info=DestroyImageInfo(write_info);\n          (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n          return(status);\n        }\n    }\n  status=MagickFalse;\n  temporary=MagickFalse;\n  if ((magick_info != (const MagickInfo *) NULL) &&\n      (GetMagickSeekableStream(magick_info) != MagickFalse))\n    {\n      char\n        image_filename[MagickPathExtent];\n\n      (void) CopyMagickString(image_filename,image->filename,MagickPathExtent);\n      status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n      (void) CopyMagickString(image->filename, image_filename,MagickPathExtent);\n      if (status != MagickFalse)\n        {\n          if (IsBlobSeekable(image) == MagickFalse)\n            {\n              /*\n                A seekable stream is required by the encoder.\n              */\n              write_info->adjoin=MagickTrue;\n              (void) CopyMagickString(write_info->filename,image->filename,\n                MagickPathExtent);\n              (void) AcquireUniqueFilename(image->filename);\n              temporary=MagickTrue;\n            }\n          (void) CloseBlob(image);\n        }\n    }\n  if ((magick_info != (const MagickInfo *) NULL) &&\n      (GetImageEncoder(magick_info) != (EncodeImageHandler *) NULL))\n    {\n      /*\n        Call appropriate image writer based on image type.\n      */\n      if (GetMagickEncoderThreadSupport(magick_info) == MagickFalse)\n        LockSemaphoreInfo(magick_info->semaphore);\n      status=GetImageEncoder(magick_info)(write_info,image,exception);\n      if (GetMagickEncoderThreadSupport(magick_info) == MagickFalse)\n        UnlockSemaphoreInfo(magick_info->semaphore);\n    }\n  else\n    {\n      delegate_info=GetDelegateInfo((char *) NULL,write_info->magick,exception);\n      if (delegate_info != (DelegateInfo *) NULL)\n        {\n          /*\n            Process the image with delegate.\n          */\n          *write_info->filename='\\0';\n          if (GetDelegateThreadSupport(delegate_info) == MagickFalse)\n            LockSemaphoreInfo(delegate_info->semaphore);\n          status=InvokeDelegate(write_info,image,(char *) NULL,\n            write_info->magick,exception);\n          if (GetDelegateThreadSupport(delegate_info) == MagickFalse)\n            UnlockSemaphoreInfo(delegate_info->semaphore);\n          (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n        }\n      else\n        {\n          sans_exception=AcquireExceptionInfo();\n          magick_info=GetMagickInfo(write_info->magick,sans_exception);\n          sans_exception=DestroyExceptionInfo(sans_exception);\n          if ((write_info->affirm == MagickFalse) &&\n              (magick_info == (const MagickInfo *) NULL))\n            {\n              (void) CopyMagickString(write_info->magick,image->magick,\n                MagickPathExtent);\n              magick_info=GetMagickInfo(write_info->magick,exception);\n            }\n          if ((magick_info == (const MagickInfo *) NULL) ||\n              (GetImageEncoder(magick_info) == (EncodeImageHandler *) NULL))\n            {\n              char\n                extension[MagickPathExtent];\n\n              GetPathComponent(image->filename,ExtensionPath,extension);\n              if (*extension != '\\0')\n                magick_info=GetMagickInfo(extension,exception);\n              else\n                magick_info=GetMagickInfo(image->magick,exception);\n              (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n            }\n          if ((magick_info == (const MagickInfo *) NULL) ||\n              (GetImageEncoder(magick_info) == (EncodeImageHandler *) NULL))\n            {\n              magick_info=GetMagickInfo(image->magick,exception);\n              if ((magick_info == (const MagickInfo *) NULL) ||\n                  (GetImageEncoder(magick_info) == (EncodeImageHandler *) NULL))\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  MissingDelegateError,\"NoEncodeDelegateForThisImageFormat\",\n                  \"`%s'\",write_info->magick);\n              else\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  MissingDelegateWarning,\"NoEncodeDelegateForThisImageFormat\",\n                  \"`%s'\",write_info->magick);\n            }\n          if ((magick_info != (const MagickInfo *) NULL) &&\n              (GetImageEncoder(magick_info) != (EncodeImageHandler *) NULL))\n            {\n              /*\n                Call appropriate image writer based on image type.\n              */\n              if (GetMagickEncoderThreadSupport(magick_info) == MagickFalse)\n                LockSemaphoreInfo(magick_info->semaphore);\n              status=GetImageEncoder(magick_info)(write_info,image,exception);\n              if (GetMagickEncoderThreadSupport(magick_info) == MagickFalse)\n                UnlockSemaphoreInfo(magick_info->semaphore);\n            }\n        }\n    }\n  if (temporary != MagickFalse)\n    {\n      /*\n        Copy temporary image file to permanent.\n      */\n      status=OpenBlob(write_info,image,ReadBinaryBlobMode,exception);\n      if (status != MagickFalse)\n        {\n          (void) RelinquishUniqueFileResource(write_info->filename);\n          status=ImageToFile(image,write_info->filename,exception);\n        }\n      (void) CloseBlob(image);\n      (void) RelinquishUniqueFileResource(image->filename);\n      (void) CopyMagickString(image->filename,write_info->filename,\n        MagickPathExtent);\n    }\n  if ((LocaleCompare(write_info->magick,\"info\") != 0) &&\n      (write_info->verbose != MagickFalse))\n    (void) IdentifyImage(image,stdout,MagickFalse,exception);\n  write_info=DestroyImageInfo(write_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e I m a g e s                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteImages() writes an image sequence into one or more files.  While\n%  WriteImage() can write an image sequence, it is limited to writing\n%  the sequence into a single file using a format which supports multiple\n%  frames.   WriteImages(), however, does not have this limitation, instead it\n%  generates multiple output files if necessary (or when requested).  When\n%  ImageInfo's adjoin flag is set to MagickFalse, the file name is expected\n%  to include a printf-style formatting string for the frame number (e.g.\n%  \"image%02d.png\").\n%\n%  The format of the WriteImages method is:\n%\n%      MagickBooleanType WriteImages(const ImageInfo *image_info,Image *images,\n%        const char *filename,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o images: the image list.\n%\n%    o filename: the image filename.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,\n  Image *images,const char *filename,ExceptionInfo *exception)\n{\n#define WriteImageTag  \"Write/Image\"\n\n  ExceptionInfo\n    *sans_exception;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    proceed;\n\n  MagickOffsetType\n    progress;\n\n  MagickProgressMonitor\n    progress_monitor;\n\n  MagickSizeType\n    number_images;\n\n  MagickStatusType\n    status;\n\n  register Image\n    *p;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  write_info=CloneImageInfo(image_info);\n  *write_info->magick='\\0';\n  images=GetFirstImageInList(images);\n  if (filename != (const char *) NULL)\n    for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n      (void) CopyMagickString(p->filename,filename,MagickPathExtent);\n  (void) CopyMagickString(write_info->filename,images->filename,MagickPathExtent);\n  sans_exception=AcquireExceptionInfo();\n  (void) SetImageInfo(write_info,(unsigned int) GetImageListLength(images),\n    sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if (*write_info->magick == '\\0')\n    (void) CopyMagickString(write_info->magick,images->magick,MagickPathExtent);\n  p=images;\n  for ( ; GetNextImageInList(p) != (Image *) NULL; p=GetNextImageInList(p))\n    if (p->scene >= GetNextImageInList(p)->scene)\n      {\n        register ssize_t\n          i;\n\n        /*\n          Generate consistent scene numbers.\n        */\n        i=(ssize_t) images->scene;\n        for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n          p->scene=(size_t) i++;\n        break;\n      }\n  /*\n    Write images.\n  */\n  status=MagickTrue;\n  progress_monitor=(MagickProgressMonitor) NULL;\n  progress=0;\n  number_images=GetImageListLength(images);\n  for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    if (number_images != 1)\n      progress_monitor=SetImageProgressMonitor(p,(MagickProgressMonitor) NULL,\n        p->client_data);\n    status&=WriteImage(write_info,p,exception);\n    if (number_images != 1)\n      (void) SetImageProgressMonitor(p,progress_monitor,p->client_data);\n    if (write_info->adjoin != MagickFalse)\n      break;\n    if (number_images != 1)\n      {\n        proceed=SetImageProgress(p,WriteImageTag,progress++,number_images);\n        if (proceed == MagickFalse)\n          break;\n      }\n  }\n  write_info=DestroyImageInfo(write_info);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     CCCC   OOO   N   N  SSSSS  TTTTT  IIIII  TTTTT  U   U  TTTTT  EEEEE     %\n%    C      O   O  NN  N  SS       T      I      T    U   U    T    E         %\n%    C      O   O  N N N  ESSS     T      I      T    U   U    T    EEE       %\n%    C      O   O  N  NN     SS    T      I      T    U   U    T    E         %\n%     CCCC   OOO   N   N  SSSSS    T    IIIII    T     UUU     T    EEEEE     %\n%                                                                             %\n%                                                                             %\n%                  MagickCore Methods to Consitute an Image                   %\n%                                                                             %\n%                             Software Design                                 %\n%                                  Cristy                                     %\n%                               October 1998                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2015 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/constitute-private.h\"\n#include \"MagickCore/delegate.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/identify.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/policy.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/profile-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/stream.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/timer.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C o n s t i t u t e I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ConstituteImage() returns an image from the pixel data you supply.\n%  The pixel data must be in scanline order top-to-bottom.  The data can be\n%  char, short int, int, float, or double.  Float and double require the\n%  pixels to be normalized [0..1], otherwise [0..QuantumRange].  For example, to\n%  create a 640x480 image from unsigned red-green-blue character data, use:\n%\n%      image = ConstituteImage(640,480,\"RGB\",CharPixel,pixels,&exception);\n%\n%  The format of the ConstituteImage method is:\n%\n%      Image *ConstituteImage(const size_t columns,const size_t rows,\n%        const char *map,const StorageType storage,const void *pixels,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o columns: width in pixels of the image.\n%\n%    o rows: height in pixels of the image.\n%\n%    o map:  This string reflects the expected ordering of the pixel array.\n%      It can be any combination or order of R = red, G = green, B = blue,\n%      A = alpha (0 is transparent), O = opacity (0 is opaque), C = cyan,\n%      Y = yellow, M = magenta, K = black, I = intensity (for grayscale),\n%      P = pad.\n%\n%    o storage: Define the data type of the pixels.  Float and double types are\n%      expected to be normalized [0..1] otherwise [0..QuantumRange].  Choose\n%      from these types: CharPixel, DoublePixel, FloatPixel, IntegerPixel,\n%      LongPixel, QuantumPixel, or ShortPixel.\n%\n%    o pixels: This array of values contain the pixel components as defined by\n%      map and type.  You must preallocate this array where the expected\n%      length varies depending on the values of width, height, map, and type.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ConstituteImage(const size_t columns,const size_t rows,\n  const char *map,const StorageType storage,const void *pixels,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Allocate image structure.\n  */\n  assert(map != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",map);\n  assert(pixels != (void *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage((ImageInfo *) NULL,exception);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  if ((columns == 0) || (rows == 0))\n    ThrowImageException(OptionError,\"NonZeroWidthAndHeightRequired\");\n  image->columns=columns;\n  image->rows=rows;\n  (void) SetImageBackgroundColor(image,exception);\n  status=ImportImagePixels(image,0,0,columns,rows,map,storage,pixels,exception);\n  if (status == MagickFalse)\n     image=DestroyImage(image);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   P i n g I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PingImage() returns all the properties of an image or image sequence\n%  except for the pixels.  It is much faster and consumes far less memory\n%  than ReadImage().  On failure, a NULL image is returned and exception\n%  describes the reason for the failure.\n%\n%  The format of the PingImage method is:\n%\n%      Image *PingImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: Ping the image defined by the file or filename members of\n%      this structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic size_t PingStream(const Image *magick_unused(image),\n  const void *magick_unused(pixels),const size_t columns)\n{\n  return(columns);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nMagickExport Image *PingImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  ImageInfo\n    *ping_info;\n\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  ping_info=CloneImageInfo(image_info);\n  ping_info->ping=MagickTrue;\n  image=ReadStream(ping_info,&PingStream,exception);\n  if (image != (Image *) NULL)\n    {\n      ResetTimer(&image->timer);\n      if (ping_info->verbose != MagickFalse)\n        (void) IdentifyImage(image,stdout,MagickFalse,exception);\n    }\n  ping_info=DestroyImageInfo(ping_info);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   P i n g I m a g e s                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PingImages() pings one or more images and returns them as an image list.\n%\n%  The format of the PingImage method is:\n%\n%      Image *PingImages(ImageInfo *image_info,const char *filename,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o filename: the image filename.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *PingImages(ImageInfo *image_info,const char *filename,\n  ExceptionInfo *exception)\n{\n  char\n    ping_filename[MagickPathExtent];\n\n  Image\n    *image,\n    *images;\n\n  ImageInfo\n    *read_info;\n\n  /*\n    Ping image list from a file.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  (void) SetImageOption(image_info,\"filename\",filename);\n  (void) CopyMagickString(image_info->filename,filename,MagickPathExtent);\n  (void) InterpretImageFilename(image_info,(Image *) NULL,image_info->filename,\n    (int) image_info->scene,ping_filename,exception);\n  if (LocaleCompare(ping_filename,image_info->filename) != 0)\n    {\n      ExceptionInfo\n        *sans;\n\n      ssize_t\n        extent,\n        scene;\n\n      /*\n        Images of the form image-%d.png[1-5].\n      */\n      read_info=CloneImageInfo(image_info);\n      sans=AcquireExceptionInfo();\n      (void) SetImageInfo(read_info,0,sans);\n      sans=DestroyExceptionInfo(sans);\n      if (read_info->number_scenes == 0)\n        {\n          read_info=DestroyImageInfo(read_info);\n          return(PingImage(image_info,exception));\n        }\n      (void) CopyMagickString(ping_filename,read_info->filename,MagickPathExtent);\n      images=NewImageList();\n      extent=(ssize_t) (read_info->scene+read_info->number_scenes);\n      for (scene=(ssize_t) read_info->scene; scene < (ssize_t) extent; scene++)\n      {\n        (void) InterpretImageFilename(image_info,(Image *) NULL,ping_filename,\n          (int) scene,read_info->filename,exception);\n        image=PingImage(read_info,exception);\n        if (image == (Image *) NULL)\n          continue;\n        AppendImageToList(&images,image);\n      }\n      read_info=DestroyImageInfo(read_info);\n      return(images);\n    }\n  return(PingImage(image_info,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadImage() reads an image or image sequence from a file or file handle.\n%  The method returns a NULL if there is a memory shortage or if the image\n%  cannot be read.  On failure, a NULL image is returned and exception\n%  describes the reason for the failure.\n%\n%  The format of the ReadImage method is:\n%\n%      Image *ReadImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: Read the image defined by the file or filename members of\n%      this structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ReadImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    magick[MagickPathExtent],\n    magick_filename[MagickPathExtent];\n\n  const char\n    *value;\n\n  const DelegateInfo\n    *delegate_info;\n\n  const MagickInfo\n    *magick_info;\n\n  ExceptionInfo\n    *sans_exception;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image,\n    *next;\n\n  ImageInfo\n    *read_info;\n\n  MagickStatusType\n    flags;\n\n  PolicyDomain\n    domain;\n\n  PolicyRights\n    rights;\n\n  /*\n    Determine image type from filename prefix or suffix (e.g. image.jpg).\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image_info->filename != (char *) NULL);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  read_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(magick_filename,read_info->filename,MagickPathExtent);\n  (void) SetImageInfo(read_info,0,exception);\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) CopyMagickString(magick,read_info->magick,MagickPathExtent);\n  domain=CoderPolicyDomain;\n  rights=ReadPolicyRights;\n  if (IsRightsAuthorized(domain,rights,read_info->magick) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",read_info->filename);\n      read_info=DestroyImageInfo(read_info);\n      return((Image *) NULL);\n    }\n  /*\n    Call appropriate image reader based on image type.\n  */\n  sans_exception=AcquireExceptionInfo();\n  magick_info=GetMagickInfo(read_info->magick,sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if (magick_info != (const MagickInfo *) NULL)\n    {\n      if (GetMagickEndianSupport(magick_info) == MagickFalse)\n        read_info->endian=UndefinedEndian;\n      else\n        if ((image_info->endian == UndefinedEndian) &&\n            (GetMagickRawSupport(magick_info) != MagickFalse))\n          {\n            unsigned long\n              lsb_first;\n\n            lsb_first=1;\n            read_info->endian=(*(char *) &lsb_first) == 1 ? LSBEndian :\n              MSBEndian;\n         }\n    }\n  if ((magick_info != (const MagickInfo *) NULL) &&\n      (GetMagickSeekableStream(magick_info) != MagickFalse))\n    {\n      MagickBooleanType\n        status;\n\n      image=AcquireImage(read_info,exception);\n      (void) CopyMagickString(image->filename,read_info->filename,\n        MagickPathExtent);\n      status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        {\n          read_info=DestroyImageInfo(read_info);\n          image=DestroyImage(image);\n          return((Image *) NULL);\n        }\n      if (IsBlobSeekable(image) == MagickFalse)\n        {\n          /*\n            Coder requires a seekable stream.\n          */\n          *read_info->filename='\\0';\n          status=ImageToFile(image,read_info->filename,exception);\n          if (status == MagickFalse)\n            {\n              (void) CloseBlob(image);\n              read_info=DestroyImageInfo(read_info);\n              image=DestroyImage(image);\n              return((Image *) NULL);\n            }\n          read_info->temporary=MagickTrue;\n        }\n      (void) CloseBlob(image);\n      image=DestroyImage(image);\n    }\n  image=NewImageList();\n  if ((magick_info == (const MagickInfo *) NULL) ||\n      (GetImageDecoder(magick_info) == (DecodeImageHandler *) NULL))\n    {\n      delegate_info=GetDelegateInfo(read_info->magick,(char *) NULL,exception);\n      if (delegate_info == (const DelegateInfo *) NULL)\n        {\n          (void) SetImageInfo(read_info,0,exception);\n          (void) CopyMagickString(read_info->filename,filename,\n            MagickPathExtent);\n          magick_info=GetMagickInfo(read_info->magick,exception);\n        }\n    }\n  if ((magick_info != (const MagickInfo *) NULL) &&\n      (GetImageDecoder(magick_info) != (DecodeImageHandler *) NULL))\n    {\n      if (GetMagickDecoderThreadSupport(magick_info) == MagickFalse)\n        LockSemaphoreInfo(magick_info->semaphore);\n      image=GetImageDecoder(magick_info)(read_info,exception);\n      if (GetMagickDecoderThreadSupport(magick_info) == MagickFalse)\n        UnlockSemaphoreInfo(magick_info->semaphore);\n    }\n  else\n    {\n      delegate_info=GetDelegateInfo(read_info->magick,(char *) NULL,exception);\n      if (delegate_info == (const DelegateInfo *) NULL)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            MissingDelegateError,\"NoDecodeDelegateForThisImageFormat\",\"`%s'\",\n            read_info->magick);\n          if (read_info->temporary != MagickFalse)\n            (void) RelinquishUniqueFileResource(read_info->filename);\n          read_info=DestroyImageInfo(read_info);\n          return((Image *) NULL);\n        }\n      /*\n        Let our decoding delegate process the image.\n      */\n      image=AcquireImage(read_info,exception);\n      if (image == (Image *) NULL)\n        {\n          read_info=DestroyImageInfo(read_info);\n          return((Image *) NULL);\n        }\n      (void) CopyMagickString(image->filename,read_info->filename,\n        MagickPathExtent);\n      *read_info->filename='\\0';\n      if (GetDelegateThreadSupport(delegate_info) == MagickFalse)\n        LockSemaphoreInfo(delegate_info->semaphore);\n      (void) InvokeDelegate(read_info,image,read_info->magick,(char *) NULL,\n        exception);\n      if (GetDelegateThreadSupport(delegate_info) == MagickFalse)\n        UnlockSemaphoreInfo(delegate_info->semaphore);\n      image=DestroyImageList(image);\n      read_info->temporary=MagickTrue;\n      (void) SetImageInfo(read_info,0,exception);\n      magick_info=GetMagickInfo(read_info->magick,exception);\n      if ((magick_info == (const MagickInfo *) NULL) ||\n          (GetImageDecoder(magick_info) == (DecodeImageHandler *) NULL))\n        {\n          if (IsPathAccessible(read_info->filename) != MagickFalse)\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              MissingDelegateError,\"NoDecodeDelegateForThisImageFormat\",\"`%s'\",\n              read_info->magick);\n          else\n            ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n              read_info->filename);\n          read_info=DestroyImageInfo(read_info);\n          return((Image *) NULL);\n        }\n      if (GetMagickDecoderThreadSupport(magick_info) == MagickFalse)\n        LockSemaphoreInfo(magick_info->semaphore);\n      image=(Image *) (GetImageDecoder(magick_info))(read_info,exception);\n      if (GetMagickDecoderThreadSupport(magick_info) == MagickFalse)\n        UnlockSemaphoreInfo(magick_info->semaphore);\n    }\n  if (read_info->temporary != MagickFalse)\n    {\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      read_info->temporary=MagickFalse;\n      if (image != (Image *) NULL)\n        (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n    }\n  if (image == (Image *) NULL)\n    {\n      read_info=DestroyImageInfo(read_info);\n      return(image);\n    }\n  if (exception->severity >= ErrorException)\n    (void) LogMagickEvent(ExceptionEvent,GetMagickModule(),\n      \"Coder (%s) generated an image despite an error (%d), \"\n      \"notify the developers\",image->magick,exception->severity);\n  if (IsBlobTemporary(image) != MagickFalse)\n    (void) RelinquishUniqueFileResource(read_info->filename);\n  if ((GetNextImageInList(image) != (Image *) NULL) &&\n      (IsSceneGeometry(read_info->scenes,MagickFalse) != MagickFalse))\n    {\n      Image\n        *clones;\n\n      clones=CloneImages(image,read_info->scenes,exception);\n      if (clones == (Image *) NULL)\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"SubimageSpecificationReturnsNoImages\",\"`%s'\",read_info->filename);\n      else\n        {\n          image=DestroyImageList(image);\n          image=GetFirstImageInList(clones);\n        }\n    }\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    char\n      magick_path[MagickPathExtent],\n      *property,\n      timestamp[MagickPathExtent];\n\n    const char\n      *option;\n\n    const StringInfo\n      *profile;\n\n    next->taint=MagickFalse;\n    GetPathComponent(magick_filename,MagickPath,magick_path);\n    if (*magick_path == '\\0' && *next->magick == '\\0')\n      (void) CopyMagickString(next->magick,magick,MagickPathExtent);\n    (void) CopyMagickString(next->magick_filename,magick_filename,\n      MagickPathExtent);\n    if (IsBlobTemporary(image) != MagickFalse)\n      (void) CopyMagickString(next->filename,filename,MagickPathExtent);\n    if (next->magick_columns == 0)\n      next->magick_columns=next->columns;\n    if (next->magick_rows == 0)\n      next->magick_rows=next->rows;\n    value=GetImageProperty(next,\"tiff:Orientation\",exception);\n    if (value == (char *) NULL)\n      value=GetImageProperty(next,\"exif:Orientation\",exception);\n    if (value != (char *) NULL)\n      {\n        next->orientation=(OrientationType) StringToLong(value);\n        (void) DeleteImageProperty(next,\"tiff:Orientation\");\n        (void) DeleteImageProperty(next,\"exif:Orientation\");\n      }\n    value=GetImageProperty(next,\"exif:XResolution\",exception);\n    if (value != (char *) NULL)\n      {\n        geometry_info.rho=next->resolution.x;\n        geometry_info.sigma=1.0;\n        flags=ParseGeometry(value,&geometry_info);\n        if (geometry_info.sigma != 0)\n          next->resolution.x=geometry_info.rho/geometry_info.sigma;\n        (void) DeleteImageProperty(next,\"exif:XResolution\");\n      }\n    value=GetImageProperty(next,\"exif:YResolution\",exception);\n    if (value != (char *) NULL)\n      {\n        geometry_info.rho=next->resolution.y;\n        geometry_info.sigma=1.0;\n        flags=ParseGeometry(value,&geometry_info);\n        if (geometry_info.sigma != 0)\n          next->resolution.y=geometry_info.rho/geometry_info.sigma;\n        (void) DeleteImageProperty(next,\"exif:YResolution\");\n      }\n    value=GetImageProperty(next,\"tiff:ResolutionUnit\",exception);\n    if (value == (char *) NULL)\n      value=GetImageProperty(next,\"exif:ResolutionUnit\",exception);\n    if (value != (char *) NULL)\n      {\n        next->units=(ResolutionType) (StringToLong(value)-1);\n        (void) DeleteImageProperty(next,\"exif:ResolutionUnit\");\n        (void) DeleteImageProperty(next,\"tiff:ResolutionUnit\");\n      }\n    if (next->page.width == 0)\n      next->page.width=next->columns;\n    if (next->page.height == 0)\n      next->page.height=next->rows;\n    option=GetImageOption(read_info,\"caption\");\n    if (option != (const char *) NULL)\n      {\n        property=InterpretImageProperties(read_info,next,option,exception);\n        (void) SetImageProperty(next,\"caption\",property,exception);\n        property=DestroyString(property);\n      }\n    option=GetImageOption(read_info,\"comment\");\n    if (option != (const char *) NULL)\n      {\n        property=InterpretImageProperties(read_info,next,option,exception);\n        (void) SetImageProperty(next,\"comment\",property,exception);\n        property=DestroyString(property);\n      }\n    option=GetImageOption(read_info,\"label\");\n    if (option != (const char *) NULL)\n      {\n        property=InterpretImageProperties(read_info,next,option,exception);\n        (void) SetImageProperty(next,\"label\",property,exception);\n        property=DestroyString(property);\n      }\n    if (LocaleCompare(next->magick,\"TEXT\") == 0)\n      (void) ParseAbsoluteGeometry(\"0x0+0+0\",&next->page);\n    if ((read_info->extract != (char *) NULL) &&\n        (read_info->stream == (StreamHandler) NULL))\n      {\n        RectangleInfo\n          geometry;\n\n        flags=ParseAbsoluteGeometry(read_info->extract,&geometry);\n        if ((next->columns != geometry.width) ||\n            (next->rows != geometry.height))\n          {\n            if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n              {\n                Image\n                  *crop_image;\n\n                crop_image=CropImage(next,&geometry,exception);\n                if (crop_image != (Image *) NULL)\n                  ReplaceImageInList(&next,crop_image);\n              }\n            else\n              if (((flags & WidthValue) != 0) || ((flags & HeightValue) != 0))\n                {\n                  Image\n                    *size_image;\n\n                  flags=ParseRegionGeometry(next,read_info->extract,&geometry,\n                    exception);\n                  size_image=ResizeImage(next,geometry.width,geometry.height,\n                    next->filter,exception);\n                  if (size_image != (Image *) NULL)\n                    ReplaceImageInList(&next,size_image);\n                }\n          }\n      }\n    profile=GetImageProfile(next,\"icc\");\n    if (profile == (const StringInfo *) NULL)\n      profile=GetImageProfile(next,\"icm\");\n    profile=GetImageProfile(next,\"iptc\");\n    if (profile == (const StringInfo *) NULL)\n      profile=GetImageProfile(next,\"8bim\");\n    (void) FormatMagickTime(GetBlobProperties(next)->st_mtime,MagickPathExtent,\n      timestamp);\n    (void) SetImageProperty(next,\"date:modify\",timestamp,exception);\n    (void) FormatMagickTime(GetBlobProperties(next)->st_ctime,MagickPathExtent,\n      timestamp);\n    (void) SetImageProperty(next,\"date:create\",timestamp,exception);\n    option=GetImageOption(image_info,\"delay\");\n    if (option != (const char *) NULL)\n      {\n        flags=ParseGeometry(option,&geometry_info);\n        if ((flags & GreaterValue) != 0)\n          {\n            if (next->delay > (size_t) floor(geometry_info.rho+0.5))\n              next->delay=(size_t) floor(geometry_info.rho+0.5);\n          }\n        else\n          if ((flags & LessValue) != 0)\n            {\n              if (next->delay < (size_t) floor(geometry_info.rho+0.5))\n                next->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n            }\n          else\n            next->delay=(size_t) floor(geometry_info.rho+0.5);\n        if ((flags & SigmaValue) != 0)\n          next->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n      }\n    option=GetImageOption(image_info,\"dispose\");\n    if (option != (const char *) NULL)\n      next->dispose=(DisposeType) ParseCommandOption(MagickDisposeOptions,\n        MagickFalse,option);\n    if (read_info->verbose != MagickFalse)\n      (void) IdentifyImage(next,stderr,MagickFalse,exception);\n    image=next;\n  }\n  read_info=DestroyImageInfo(read_info);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d I m a g e s                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadImages() reads one or more images and returns them as an image list.\n%\n%  The format of the ReadImage method is:\n%\n%      Image *ReadImages(ImageInfo *image_info,const char *filename,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o filename: the image filename.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ReadImages(ImageInfo *image_info,const char *filename,\n  ExceptionInfo *exception)\n{\n  char\n    read_filename[MagickPathExtent];\n\n  Image\n    *image,\n    *images;\n\n  ImageInfo\n    *read_info;\n\n  /*\n    Read image list from a file.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  (void) SetImageOption(read_info,\"filename\",filename);\n  (void) CopyMagickString(read_info->filename,filename,MagickPathExtent);\n  (void) InterpretImageFilename(read_info,(Image *) NULL,filename,\n    (int) read_info->scene,read_filename,exception);\n  if (LocaleCompare(read_filename,read_info->filename) != 0)\n    {\n      ExceptionInfo\n        *sans;\n\n      ssize_t\n        extent,\n        scene;\n\n      /*\n        Images of the form image-%d.png[1-5].\n      */\n      sans=AcquireExceptionInfo();\n      (void) SetImageInfo(read_info,0,sans);\n      sans=DestroyExceptionInfo(sans);\n      if (read_info->number_scenes == 0)\n        {\n          read_info=DestroyImageInfo(read_info);\n          return(ReadImage(image_info,exception));\n        }\n      (void) CopyMagickString(read_filename,read_info->filename,MagickPathExtent);\n      images=NewImageList();\n      extent=(ssize_t) (read_info->scene+read_info->number_scenes);\n      for (scene=(ssize_t) read_info->scene; scene < (ssize_t) extent; scene++)\n      {\n        (void) InterpretImageFilename(image_info,(Image *) NULL,read_filename,\n          (int) scene,read_info->filename,exception);\n        image=ReadImage(read_info,exception);\n        if (image == (Image *) NULL)\n          continue;\n        AppendImageToList(&images,image);\n      }\n      read_info=DestroyImageInfo(read_info);\n      return(images);\n    }\n  image=ReadImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e a d I n l i n e I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadInlineImage() reads a Base64-encoded inline image or image sequence.\n%  The method returns a NULL if there is a memory shortage or if the image\n%  cannot be read.  On failure, a NULL image is returned and exception\n%  describes the reason for the failure.\n%\n%  The format of the ReadInlineImage method is:\n%\n%      Image *ReadInlineImage(const ImageInfo *image_info,const char *content,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o content: the image encoded in Base64.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ReadInlineImage(const ImageInfo *image_info,\n  const char *content,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  unsigned char\n    *blob;\n\n  size_t\n    length;\n\n  register const char\n    *p;\n\n  /*\n    Skip over header (e.g. data:image/gif;base64,).\n  */\n  image=NewImageList();\n  for (p=content; (*p != ',') && (*p != '\\0'); p++) ;\n  if (*p == '\\0')\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  p++;\n  length=0;\n  blob=Base64Decode(p,&length);\n  if (length == 0)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  *read_info->filename='\\0';\n  *read_info->magick='\\0';\n  image=BlobToImage(read_info,blob,length,exception);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n  read_info=DestroyImageInfo(read_info);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e I m a g e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteImage() writes an image or an image sequence to a file or file handle.\n%  If writing to a file is on disk, the name is defined by the filename member\n%  of the image structure.  WriteImage() returns MagickFalse is there is a\n%  memory shortage or if the image cannot be written.  Check the exception\n%  member of image to determine the cause for any failure.\n%\n%  The format of the WriteImage method is:\n%\n%      MagickBooleanType WriteImage(const ImageInfo *image_info,Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType WriteImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  const char\n    *option;\n\n  const DelegateInfo\n    *delegate_info;\n\n  const MagickInfo\n    *magick_info;\n\n  ExceptionInfo\n    *sans_exception;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status,\n    temporary;\n\n  PolicyDomain\n    domain;\n\n  PolicyRights\n    rights;\n\n  /*\n    Determine image type from filename prefix or suffix (e.g. image.jpg).\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  sans_exception=AcquireExceptionInfo();\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->filename,image->filename,MagickPathExtent);\n  (void) SetImageInfo(write_info,1,sans_exception);\n  if (*write_info->magick == '\\0')\n    (void) CopyMagickString(write_info->magick,image->magick,MagickPathExtent);\n  (void) CopyMagickString(filename,image->filename,MagickPathExtent);\n  (void) CopyMagickString(image->filename,write_info->filename,MagickPathExtent);\n  domain=CoderPolicyDomain;\n  rights=WritePolicyRights;\n  if (IsRightsAuthorized(domain,rights,write_info->magick) == MagickFalse)\n    {\n      sans_exception=DestroyExceptionInfo(sans_exception);\n      write_info=DestroyImageInfo(write_info);\n      errno=EPERM;\n      ThrowBinaryException(PolicyError,\"NotAuthorized\",filename);\n    }\n  /*\n    Call appropriate image reader based on image type.\n  */\n  magick_info=GetMagickInfo(write_info->magick,sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if (magick_info != (const MagickInfo *) NULL)\n    {\n      if (GetMagickEndianSupport(magick_info) == MagickFalse)\n        image->endian=UndefinedEndian;\n      else\n        if ((image_info->endian == UndefinedEndian) &&\n            (GetMagickRawSupport(magick_info) != MagickFalse))\n          {\n            unsigned long\n              lsb_first;\n\n            lsb_first=1;\n            image->endian=(*(char *) &lsb_first) == 1 ? LSBEndian : MSBEndian;\n         }\n    }\n  (void) SyncImageProfiles(image);\n  DisassociateImageStream(image);\n  option=GetImageOption(image_info,\"delegate:bimodal\");\n  if ((IfMagickTrue(IsStringTrue(option))) &&\n      (write_info->page == (char *) NULL) &&\n      (GetPreviousImageInList(image) == (Image *) NULL) &&\n      (GetNextImageInList(image) == (Image *) NULL) &&\n      (IfMagickFalse(IsTaintImage(image))) )\n    {\n      delegate_info=GetDelegateInfo(image->magick,write_info->magick,exception);\n      if ((delegate_info != (const DelegateInfo *) NULL) &&\n          (GetDelegateMode(delegate_info) == 0) &&\n          (IsPathAccessible(image->magick_filename) != MagickFalse))\n        {\n          /*\n            Process image with bi-modal delegate.\n          */\n          (void) CopyMagickString(image->filename,image->magick_filename,\n            MagickPathExtent);\n          status=InvokeDelegate(write_info,image,image->magick,\n            write_info->magick,exception);\n          write_info=DestroyImageInfo(write_info);\n          (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n          return(status);\n        }\n    }\n  status=MagickFalse;\n  temporary=MagickFalse;\n  if ((magick_info != (const MagickInfo *) NULL) &&\n      (GetMagickSeekableStream(magick_info) != MagickFalse))\n    {\n      char\n        image_filename[MagickPathExtent];\n\n      (void) CopyMagickString(image_filename,image->filename,MagickPathExtent);\n      status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n      (void) CopyMagickString(image->filename, image_filename,MagickPathExtent);\n      if (status != MagickFalse)\n        {\n          if (IsBlobSeekable(image) == MagickFalse)\n            {\n              /*\n                A seekable stream is required by the encoder.\n              */\n              write_info->adjoin=MagickTrue;\n              (void) CopyMagickString(write_info->filename,image->filename,\n                MagickPathExtent);\n              (void) AcquireUniqueFilename(image->filename);\n              temporary=MagickTrue;\n            }\n          (void) CloseBlob(image);\n        }\n    }\n  if ((magick_info != (const MagickInfo *) NULL) &&\n      (GetImageEncoder(magick_info) != (EncodeImageHandler *) NULL))\n    {\n      /*\n        Call appropriate image writer based on image type.\n      */\n      if (GetMagickEncoderThreadSupport(magick_info) == MagickFalse)\n        LockSemaphoreInfo(magick_info->semaphore);\n      status=GetImageEncoder(magick_info)(write_info,image,exception);\n      if (GetMagickEncoderThreadSupport(magick_info) == MagickFalse)\n        UnlockSemaphoreInfo(magick_info->semaphore);\n    }\n  else\n    {\n      delegate_info=GetDelegateInfo((char *) NULL,write_info->magick,exception);\n      if (delegate_info != (DelegateInfo *) NULL)\n        {\n          /*\n            Process the image with delegate.\n          */\n          *write_info->filename='\\0';\n          if (GetDelegateThreadSupport(delegate_info) == MagickFalse)\n            LockSemaphoreInfo(delegate_info->semaphore);\n          status=InvokeDelegate(write_info,image,(char *) NULL,\n            write_info->magick,exception);\n          if (GetDelegateThreadSupport(delegate_info) == MagickFalse)\n            UnlockSemaphoreInfo(delegate_info->semaphore);\n          (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n        }\n      else\n        {\n          sans_exception=AcquireExceptionInfo();\n          magick_info=GetMagickInfo(write_info->magick,sans_exception);\n          sans_exception=DestroyExceptionInfo(sans_exception);\n          if ((write_info->affirm == MagickFalse) &&\n              (magick_info == (const MagickInfo *) NULL))\n            {\n              (void) CopyMagickString(write_info->magick,image->magick,\n                MagickPathExtent);\n              magick_info=GetMagickInfo(write_info->magick,exception);\n            }\n          if ((magick_info == (const MagickInfo *) NULL) ||\n              (GetImageEncoder(magick_info) == (EncodeImageHandler *) NULL))\n            {\n              char\n                extension[MagickPathExtent];\n\n              GetPathComponent(image->filename,ExtensionPath,extension);\n              if (*extension != '\\0')\n                magick_info=GetMagickInfo(extension,exception);\n              else\n                magick_info=GetMagickInfo(image->magick,exception);\n              (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n            }\n          if ((magick_info == (const MagickInfo *) NULL) ||\n              (GetImageEncoder(magick_info) == (EncodeImageHandler *) NULL))\n            {\n              magick_info=GetMagickInfo(image->magick,exception);\n              if ((magick_info == (const MagickInfo *) NULL) ||\n                  (GetImageEncoder(magick_info) == (EncodeImageHandler *) NULL))\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  MissingDelegateError,\"NoEncodeDelegateForThisImageFormat\",\n                  \"`%s'\",write_info->magick);\n              else\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  MissingDelegateWarning,\"NoEncodeDelegateForThisImageFormat\",\n                  \"`%s'\",write_info->magick);\n            }\n          if ((magick_info != (const MagickInfo *) NULL) &&\n              (GetImageEncoder(magick_info) != (EncodeImageHandler *) NULL))\n            {\n              /*\n                Call appropriate image writer based on image type.\n              */\n              if (GetMagickEncoderThreadSupport(magick_info) == MagickFalse)\n                LockSemaphoreInfo(magick_info->semaphore);\n              status=GetImageEncoder(magick_info)(write_info,image,exception);\n              if (GetMagickEncoderThreadSupport(magick_info) == MagickFalse)\n                UnlockSemaphoreInfo(magick_info->semaphore);\n            }\n        }\n    }\n  if (temporary != MagickFalse)\n    {\n      /*\n        Copy temporary image file to permanent.\n      */\n      status=OpenBlob(write_info,image,ReadBinaryBlobMode,exception);\n      if (status != MagickFalse)\n        {\n          (void) RelinquishUniqueFileResource(write_info->filename);\n          status=ImageToFile(image,write_info->filename,exception);\n        }\n      (void) CloseBlob(image);\n      (void) RelinquishUniqueFileResource(image->filename);\n      (void) CopyMagickString(image->filename,write_info->filename,\n        MagickPathExtent);\n    }\n  if ((LocaleCompare(write_info->magick,\"info\") != 0) &&\n      (write_info->verbose != MagickFalse))\n    (void) IdentifyImage(image,stdout,MagickFalse,exception);\n  write_info=DestroyImageInfo(write_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e I m a g e s                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteImages() writes an image sequence into one or more files.  While\n%  WriteImage() can write an image sequence, it is limited to writing\n%  the sequence into a single file using a format which supports multiple\n%  frames.   WriteImages(), however, does not have this limitation, instead it\n%  generates multiple output files if necessary (or when requested).  When\n%  ImageInfo's adjoin flag is set to MagickFalse, the file name is expected\n%  to include a printf-style formatting string for the frame number (e.g.\n%  \"image%02d.png\").\n%\n%  The format of the WriteImages method is:\n%\n%      MagickBooleanType WriteImages(const ImageInfo *image_info,Image *images,\n%        const char *filename,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o images: the image list.\n%\n%    o filename: the image filename.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,\n  Image *images,const char *filename,ExceptionInfo *exception)\n{\n#define WriteImageTag  \"Write/Image\"\n\n  ExceptionInfo\n    *sans_exception;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    proceed;\n\n  MagickOffsetType\n    progress;\n\n  MagickProgressMonitor\n    progress_monitor;\n\n  MagickSizeType\n    number_images;\n\n  MagickStatusType\n    status;\n\n  register Image\n    *p;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  write_info=CloneImageInfo(image_info);\n  *write_info->magick='\\0';\n  images=GetFirstImageInList(images);\n  if (filename != (const char *) NULL)\n    for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n      (void) CopyMagickString(p->filename,filename,MagickPathExtent);\n  (void) CopyMagickString(write_info->filename,images->filename,MagickPathExtent);\n  sans_exception=AcquireExceptionInfo();\n  (void) SetImageInfo(write_info,(unsigned int) GetImageListLength(images),\n    sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if (*write_info->magick == '\\0')\n    (void) CopyMagickString(write_info->magick,images->magick,MagickPathExtent);\n  p=images;\n  for ( ; GetNextImageInList(p) != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    register Image\n      *next;\n    \n    next=GetNextImageInList(p);\n    if (next == (Image *) NULL)\n      break;\n    if (p->scene >= next->scene)\n      {\n        register ssize_t\n          i;\n\n        /*\n          Generate consistent scene numbers.\n        */\n        i=(ssize_t) images->scene;\n        for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n          p->scene=(size_t) i++;\n        break;\n      }\n  }\n  /*\n    Write images.\n  */\n  status=MagickTrue;\n  progress_monitor=(MagickProgressMonitor) NULL;\n  progress=0;\n  number_images=GetImageListLength(images);\n  for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    if (number_images != 1)\n      progress_monitor=SetImageProgressMonitor(p,(MagickProgressMonitor) NULL,\n        p->client_data);\n    status&=WriteImage(write_info,p,exception);\n    if (number_images != 1)\n      (void) SetImageProgressMonitor(p,progress_monitor,p->client_data);\n    if (write_info->adjoin != MagickFalse)\n      break;\n    if (number_images != 1)\n      {\n        proceed=SetImageProgress(p,WriteImageTag,progress++,number_images);\n        if (proceed == MagickFalse)\n          break;\n      }\n  }\n  write_info=DestroyImageInfo(write_info);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n"], "filenames": ["MagickCore/constitute.c"], "buggy_code_start_loc": [1284], "buggy_code_end_loc": [1296], "fixing_code_start_loc": [1284], "fixing_code_end_loc": [1305], "type": "CWE-476", "message": "The WriteImages function in magick/constitute.c in ImageMagick before 6.9.2-4 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image file.", "other": {"cve": {"id": "CVE-2015-8898", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-15T19:59:00.330", "lastModified": "2018-05-18T01:29:03.057", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The WriteImages function in magick/constitute.c in ImageMagick before 6.9.2-4 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image file."}, {"lang": "es", "value": "La funci\u00f3n WriteImages en magick/constitu.c en ImageMagick en versiones anteriores a 6.9.2-4 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (referencia a puntero NULL) a trav\u00e9s de un archivo de imagen manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.9.2-3", "matchCriteriaId": "B92D28C2-8E57-46C6-B2AF-6F1EB575E6F3"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/06/02/13", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinapr2016-2952096.html", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/91039", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2016:1237", "source": "cve@mitre.org"}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/5b4bebaa91849c592a8448bc353ab25a54ff8c44", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/pull/34", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/5b4bebaa91849c592a8448bc353ab25a54ff8c44"}}