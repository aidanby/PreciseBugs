{"buggy_code": ["package io.dropwizard.validation.selfvalidating;\n\nimport javax.validation.ConstraintValidatorContext;\n\n/**\n * This class is a simple wrapper around the ConstraintValidatorContext of hibernate validation.\n * It collects all the violations of the SelfValidation methods of an object.\n */\npublic class ViolationCollector {\n\n    private boolean violationOccurred = false;\n    private ConstraintValidatorContext context;\n\n\n    public ViolationCollector(ConstraintValidatorContext context) {\n        this.context = context;\n    }\n\n    /**\n     * Adds a new violation to this collector. This also sets violationOccurred to true.\n     *\n     * @param msg the message of the violation\n     */\n    public void addViolation(String msg) {\n        violationOccurred = true;\n        context.buildConstraintViolationWithTemplate(msg)\n            .addConstraintViolation();\n    }\n\n    /**\n     * This method returns the wrapped context for raw access to the validation framework. If you use\n     * the context to add violations make sure to call <code>setViolationOccurred(true)</code>.\n     *\n     * @return the wrapped Hibernate ConstraintValidatorContext\n     */\n    public ConstraintValidatorContext getContext() {\n        return context;\n    }\n\n    /**\n     * @return if any violation was collected\n     */\n    public boolean hasViolationOccurred() {\n        return violationOccurred;\n    }\n\n    /**\n     * Manually sets if a violation occurred. This is automatically set if <code>addViolation</code> is called.\n     *\n     * @param violationOccurred if any violation was collected\n     */\n    public void setViolationOccurred(boolean violationOccurred) {\n        this.violationOccurred = violationOccurred;\n    }\n\n}\n", "package io.dropwizard.validation;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport javax.annotation.concurrent.NotThreadSafe;\nimport javax.validation.Validator;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport io.dropwizard.validation.selfvalidating.SelfValidating;\nimport io.dropwizard.validation.selfvalidating.SelfValidation;\nimport io.dropwizard.validation.selfvalidating.ViolationCollector;\nimport uk.org.lidalia.slf4jext.Level;\nimport uk.org.lidalia.slf4jtest.LoggingEvent;\nimport uk.org.lidalia.slf4jtest.TestLoggerFactory;\n\n@NotThreadSafe\npublic class SelfValidationTest {\n\n    private static final String FAILED = \"failed\";\n    private static final String FAILED_RESULT = \" \" + FAILED;\n    \n    @BeforeEach @AfterEach\n    public void clearAllLoggers() {\n        //this must be a clear all because the validation runs in other threads\n        TestLoggerFactory.clearAll();\n    }\n\n    @SelfValidating\n    public static class FailingExample {\n        @SelfValidation\n        public void validateFail(ViolationCollector col) {\n            col.addViolation(FAILED);\n        }\n    }\n    \n    public static class SubclassExample extends FailingExample {\n        @SelfValidation\n        public void subValidateFail(ViolationCollector col) {\n            col.addViolation(FAILED+\"subclass\");\n        } \n    }\n\n    @SelfValidating\n    public static class AnnotatedSubclassExample extends FailingExample {\n        @SelfValidation\n        public void subValidateFail(ViolationCollector col) {\n            col.addViolation(FAILED+\"subclass\");\n        } \n    }\n    \n    public static class OverridingExample extends FailingExample {\n        @Override\n        public void validateFail(ViolationCollector col) {\n        } \n    }\n\n    @SelfValidating\n    public static class DirectContextExample {\n        @SelfValidation\n        public void validateFail(ViolationCollector col) {\n            col.getContext().buildConstraintViolationWithTemplate(FAILED).addConstraintViolation();\n            col.setViolationOccurred(true);\n        }\n    }\n\n    @SelfValidating\n    public static class CorrectExample {\n        @SuppressWarnings(\"unused\")\n        @SelfValidation\n        public void validateCorrect(ViolationCollector col) {\n        }\n    }\n\n    @SelfValidating\n    public static class InvalidExample {\n        @SuppressWarnings(\"unused\")\n        @SelfValidation\n        public void validateCorrect(ViolationCollector col) {\n        }\n\n        @SuppressWarnings(\"unused\")\n        @SelfValidation\n        public void validateFailAdditionalParameters(ViolationCollector col, int a) {\n            col.addViolation(FAILED);\n        }\n\n        @SelfValidation\n        public boolean validateFailReturn(ViolationCollector col) {\n            col.addViolation(FAILED);\n            return true;\n        }\n\n        @SelfValidation\n        private void validateFailPrivate(ViolationCollector col) {\n            col.addViolation(FAILED);\n        }\n    }\n\n\n    @SelfValidating\n    public static class ComplexExample {\n        @SelfValidation\n        public void validateFail1(ViolationCollector col) {\n            col.addViolation(FAILED + \"1\");\n        }\n\n        @SelfValidation\n        public void validateFail2(ViolationCollector col) {\n            col.addViolation(FAILED + \"2\");\n        }\n\n        @SelfValidation\n        public void validateFail3(ViolationCollector col) {\n            col.addViolation(FAILED + \"3\");\n        }\n\n        @SuppressWarnings(\"unused\")\n        @SelfValidation\n        public void validateCorrect(ViolationCollector col) {\n        }\n    }\n\n    @SelfValidating\n    public static class NoValidations {\n    }\n\n    private final Validator validator = BaseValidator.newValidator();\n\n    @Test\n    public void failingExample() throws Exception {\n        assertThat(ConstraintViolations.format(validator.validate(new FailingExample())))\n            .containsExactlyInAnyOrder(FAILED_RESULT);\n        assertThat(TestLoggerFactory.getAllLoggingEvents())\n            .isEmpty();\n    }\n    \n    @Test\n    public void subClassExample() throws Exception {\n        assertThat(ConstraintViolations.format(validator.validate(new SubclassExample())))\n            .containsExactlyInAnyOrder(\n                    FAILED_RESULT,\n                    FAILED_RESULT+\"subclass\"\n            );\n        assertThat(TestLoggerFactory.getAllLoggingEvents())\n            .isEmpty();\n    }\n    \n    @Test\n    public void annotatedSubClassExample() throws Exception {\n        assertThat(ConstraintViolations.format(validator.validate(new AnnotatedSubclassExample())))\n            .containsExactlyInAnyOrder(\n                    FAILED_RESULT,\n                    FAILED_RESULT+\"subclass\"\n            );\n        assertThat(TestLoggerFactory.getAllLoggingEvents())\n            .isEmpty();\n    }\n    \n    @Test\n    public void overridingSubClassExample() throws Exception {\n        assertThat(ConstraintViolations.format(validator.validate(new OverridingExample())))\n            .isEmpty();\n        assertThat(TestLoggerFactory.getAllLoggingEvents())\n            .isEmpty();\n    }\n\n    @Test\n    public void correctExample() throws Exception {\n        assertThat(ConstraintViolations.format(validator.validate(new CorrectExample())))\n            .isEmpty();\n        assertThat(TestLoggerFactory.getAllLoggingEvents())\n            .isEmpty();\n    }\n\n    @Test\n    public void multipleTestingOfSameClass() throws Exception {\n        assertThat(ConstraintViolations.format(validator.validate(new CorrectExample())))\n            .isEmpty();\n        assertThat(ConstraintViolations.format(validator.validate(new CorrectExample())))\n            .isEmpty();\n        assertThat(TestLoggerFactory.getAllLoggingEvents())\n            .isEmpty();\n    }\n\n    @Test\n    public void testDirectContextUsage() throws Exception {\n        assertThat(ConstraintViolations.format(validator.validate(new DirectContextExample())))\n            .containsExactlyInAnyOrder(FAILED_RESULT);\n        assertThat(TestLoggerFactory.getAllLoggingEvents())\n            .isEmpty();\n    }\n\n    @Test\n    public void complexExample() throws Exception {\n        assertThat(ConstraintViolations.format(validator.validate(new ComplexExample())))\n            .containsExactlyInAnyOrder(\n                FAILED_RESULT + \"1\",\n                FAILED_RESULT + \"2\",\n                FAILED_RESULT + \"3\"\n            );\n        assertThat(TestLoggerFactory.getAllLoggingEvents())\n            .isEmpty();\n    }\n\n    @Test\n    public void invalidExample() throws Exception {\n        assertThat(ConstraintViolations.format(validator.validate(new InvalidExample())))\n            .isEmpty();\n        assertThat(TestLoggerFactory.getAllLoggingEvents())\n            .containsExactlyInAnyOrder(\n                    new LoggingEvent(\n                            Level.ERROR, \n                            \"The method {} is annotated with @SelfValidation but does not have a single parameter of type {}\",\n                            InvalidExample.class.getMethod(\"validateFailAdditionalParameters\", ViolationCollector.class, int.class),\n                            ViolationCollector.class\n                    ),\n                    new LoggingEvent(\n                            Level.ERROR, \n                            \"The method {} is annotated with @SelfValidation but does not return void. It is ignored\",\n                            InvalidExample.class.getMethod(\"validateFailReturn\", ViolationCollector.class)\n                    ),\n                    new LoggingEvent(\n                            Level.ERROR, \n                            \"The method {} is annotated with @SelfValidation but is not public\",\n                            InvalidExample.class.getDeclaredMethod(\"validateFailPrivate\", ViolationCollector.class)\n                    )\n            );\n    }\n\n    @Test\n    public void giveWarningIfNoValidationMethods() throws Exception {\n        assertThat(ConstraintViolations.format(validator.validate(new NoValidations())))\n            .isEmpty();\n        assertThat(TestLoggerFactory.getAllLoggingEvents())\n        .containsExactlyInAnyOrder(\n                new LoggingEvent(\n                        Level.WARN, \n                        \"The class {} is annotated with @SelfValidating but contains no valid methods that are annotated with @SelfValidation\",\n                        NoValidations.class\n                )\n                \n        );\n    }\n}\n"], "fixing_code": ["package io.dropwizard.validation.selfvalidating;\n\nimport javax.annotation.Nullable;\nimport javax.validation.ConstraintValidatorContext;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * This class is a simple wrapper around the ConstraintValidatorContext of hibernate validation.\n * It collects all the violations of the SelfValidation methods of an object.\n */\npublic class ViolationCollector {\n    private static final Pattern ESCAPE_PATTERN = Pattern.compile(\"\\\\$\\\\{\");\n\n    private boolean violationOccurred = false;\n    private ConstraintValidatorContext context;\n\n\n    public ViolationCollector(ConstraintValidatorContext context) {\n        this.context = context;\n    }\n\n    /**\n     * Adds a new violation to this collector. This also sets {@code violationOccurred} to {@code true}.\n     *\n     * @param message the message of the violation (any EL expression will be escaped and not parsed)\n     */\n    public void addViolation(String message) {\n        violationOccurred = true;\n        String messageTemplate = escapeEl(message);\n        context.buildConstraintViolationWithTemplate(messageTemplate)\n                .addConstraintViolation();\n    }\n\n    /**\n     * Adds a new violation to this collector. This also sets {@code violationOccurred} to {@code true}.\n     *\n     * @param propertyName the name of the property\n     * @param message      the message of the violation (any EL expression will be escaped and not parsed)\n     * @since 2.0.2\n     */\n    public void addViolation(String propertyName, String message) {\n        violationOccurred = true;\n        String messageTemplate = escapeEl(message);\n        context.buildConstraintViolationWithTemplate(messageTemplate)\n                .addPropertyNode(propertyName)\n                .addConstraintViolation();\n    }\n\n    /**\n     * Adds a new violation to this collector. This also sets {@code violationOccurred} to {@code true}.\n     *\n     * @param propertyName the name of the property with the violation\n     * @param index        the index of the element with the violation\n     * @param message      the message of the violation (any EL expression will be escaped and not parsed)\n     * @since 2.0.2\n     */\n    public void addViolation(String propertyName, Integer index, String message) {\n        violationOccurred = true;\n        String messageTemplate = escapeEl(message);\n        context.buildConstraintViolationWithTemplate(messageTemplate)\n                .addPropertyNode(propertyName)\n                .addBeanNode().inIterable().atIndex(index)\n                .addConstraintViolation();\n    }\n\n    /**\n     * Adds a new violation to this collector. This also sets {@code violationOccurred} to {@code true}.\n     *\n     * @param propertyName the name of the property with the violation\n     * @param key          the key of the element with the violation\n     * @param message      the message of the violation (any EL expression will be escaped and not parsed)\n     * @since 2.0.2\n     */\n    public void addViolation(String propertyName, String key, String message) {\n        violationOccurred = true;\n        String messageTemplate = escapeEl(message);\n        context.buildConstraintViolationWithTemplate(messageTemplate)\n                .addPropertyNode(propertyName)\n                .addBeanNode().inIterable().atKey(key)\n                .addConstraintViolation();\n    }\n\n    @Nullable\n    private String escapeEl(@Nullable String s) {\n        if (s == null || s.isEmpty()) {\n            return s;\n        }\n\n        final Matcher m = ESCAPE_PATTERN.matcher(s);\n        final StringBuffer sb = new StringBuffer(s.length() + 16);\n        while (m.find()) {\n            m.appendReplacement(sb, \"\\\\\\\\\\\\${\");\n        }\n        m.appendTail(sb);\n\n        return sb.toString();\n    }\n\n    /**\n     * This method returns the wrapped context for raw access to the validation framework. If you use\n     * the context to add violations make sure to call <code>setViolationOccurred(true)</code>.\n     *\n     * @return the wrapped Hibernate ConstraintValidatorContext\n     */\n    public ConstraintValidatorContext getContext() {\n        return context;\n    }\n\n    /**\n     * @return if any violation was collected\n     */\n    public boolean hasViolationOccurred() {\n        return violationOccurred;\n    }\n\n    /**\n     * Manually sets if a violation occurred. This is automatically set if <code>addViolation</code> is called.\n     *\n     * @param violationOccurred if any violation was collected\n     */\n    public void setViolationOccurred(boolean violationOccurred) {\n        this.violationOccurred = violationOccurred;\n    }\n\n}\n", "package io.dropwizard.validation;\n\nimport io.dropwizard.validation.selfvalidating.SelfValidating;\nimport io.dropwizard.validation.selfvalidating.SelfValidation;\nimport io.dropwizard.validation.selfvalidating.ViolationCollector;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport uk.org.lidalia.slf4jext.Level;\nimport uk.org.lidalia.slf4jtest.LoggingEvent;\nimport uk.org.lidalia.slf4jtest.TestLoggerFactory;\n\nimport javax.annotation.concurrent.NotThreadSafe;\nimport javax.validation.Validator;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@NotThreadSafe\npublic class SelfValidationTest {\n\n    private static final String FAILED = \"failed\";\n    private static final String FAILED_RESULT = \" \" + FAILED;\n\n    @AfterEach\n    @BeforeEach\n    public void clearAllLoggers() {\n        //this must be a clear all because the validation runs in other threads\n        TestLoggerFactory.clearAll();\n    }\n\n    @SelfValidating\n    public static class FailingExample {\n        @SuppressWarnings(\"unused\")\n        @SelfValidation\n        public void validateFail(ViolationCollector col) {\n            col.addViolation(FAILED);\n        }\n    }\n\n    public static class SubclassExample extends FailingExample {\n        @SuppressWarnings(\"unused\")\n        @SelfValidation\n        public void subValidateFail(ViolationCollector col) {\n            col.addViolation(FAILED + \"subclass\");\n        }\n    }\n\n    @SelfValidating\n    public static class AnnotatedSubclassExample extends FailingExample {\n        @SuppressWarnings(\"unused\")\n        @SelfValidation\n        public void subValidateFail(ViolationCollector col) {\n            col.addViolation(FAILED + \"subclass\");\n        }\n    }\n\n    public static class OverridingExample extends FailingExample {\n        @Override\n        public void validateFail(ViolationCollector col) {\n        }\n    }\n\n    @SelfValidating\n    public static class DirectContextExample {\n        @SuppressWarnings(\"unused\")\n        @SelfValidation\n        public void validateFail(ViolationCollector col) {\n            col.getContext().buildConstraintViolationWithTemplate(FAILED).addConstraintViolation();\n            col.setViolationOccurred(true);\n        }\n    }\n\n    @SelfValidating\n    public static class CorrectExample {\n        @SuppressWarnings(\"unused\")\n        @SelfValidation\n        public void validateCorrect(ViolationCollector col) {\n        }\n    }\n\n    @SelfValidating\n    public static class InvalidExample {\n        @SuppressWarnings(\"unused\")\n        @SelfValidation\n        public void validateCorrect(ViolationCollector col) {\n        }\n\n        @SuppressWarnings(\"unused\")\n        @SelfValidation\n        public void validateFailAdditionalParameters(ViolationCollector col, int a) {\n            col.addViolation(FAILED);\n        }\n\n        @SelfValidation\n        public boolean validateFailReturn(ViolationCollector col) {\n            col.addViolation(FAILED);\n            return true;\n        }\n\n        @SelfValidation\n        private void validateFailPrivate(ViolationCollector col) {\n            col.addViolation(FAILED);\n        }\n    }\n\n\n    @SelfValidating\n    public static class ComplexExample {\n        @SuppressWarnings(\"unused\")\n        @SelfValidation\n        public void validateFail1(ViolationCollector col) {\n            col.addViolation(FAILED + \"1\");\n        }\n\n        @SuppressWarnings(\"unused\")\n        @SelfValidation\n        public void validateFail2(ViolationCollector col) {\n            col.addViolation(\"p2\", FAILED);\n        }\n\n        @SuppressWarnings(\"unused\")\n        @SelfValidation\n        public void validateFail3(ViolationCollector col) {\n            col.addViolation(\"p\", 3, FAILED);\n        }\n\n        @SuppressWarnings(\"unused\")\n        @SelfValidation\n        public void validateFail4(ViolationCollector col) {\n            col.addViolation(\"p\", \"four\", FAILED);\n        }\n\n        @SuppressWarnings(\"unused\")\n        @SelfValidation\n        public void validateCorrect(ViolationCollector col) {\n        }\n    }\n\n    @SelfValidating\n    public static class NoValidations {\n    }\n\n    @SelfValidating\n    public static class InjectionExample {\n        @SuppressWarnings(\"unused\")\n        @SelfValidation\n        public void validateFail(ViolationCollector col) {\n            col.addViolation(\"${'value'}\");\n            col.addViolation(\"${'property'}\", \"${'value'}\");\n            col.addViolation(\"${'property'}\", 1, \"${'value'}\");\n            col.addViolation(\"${'property'}\", \"${'key'}\", \"${'value'}\");\n        }\n    }\n\n    private final Validator validator = BaseValidator.newValidator();\n\n    @Test\n    public void failingExample() {\n        assertThat(ConstraintViolations.format(validator.validate(new FailingExample())))\n                .containsExactlyInAnyOrder(FAILED_RESULT);\n        assertThat(TestLoggerFactory.getAllLoggingEvents())\n                .isEmpty();\n    }\n\n    @Test\n    public void subClassExample() {\n        assertThat(ConstraintViolations.format(validator.validate(new SubclassExample())))\n                .containsExactlyInAnyOrder(\n                        FAILED_RESULT,\n                        FAILED_RESULT + \"subclass\"\n                );\n        assertThat(TestLoggerFactory.getAllLoggingEvents())\n                .isEmpty();\n    }\n\n    @Test\n    public void annotatedSubClassExample() {\n        assertThat(ConstraintViolations.format(validator.validate(new AnnotatedSubclassExample())))\n                .containsExactlyInAnyOrder(\n                        FAILED_RESULT,\n                        FAILED_RESULT + \"subclass\"\n                );\n        assertThat(TestLoggerFactory.getAllLoggingEvents())\n                .isEmpty();\n    }\n\n    @Test\n    public void overridingSubClassExample() {\n        assertThat(ConstraintViolations.format(validator.validate(new OverridingExample())))\n                .isEmpty();\n        assertThat(TestLoggerFactory.getAllLoggingEvents())\n                .isEmpty();\n    }\n\n    @Test\n    public void correctExample() {\n        assertThat(ConstraintViolations.format(validator.validate(new CorrectExample())))\n                .isEmpty();\n        assertThat(TestLoggerFactory.getAllLoggingEvents())\n                .isEmpty();\n    }\n\n    @Test\n    public void multipleTestingOfSameClass() {\n        assertThat(ConstraintViolations.format(validator.validate(new CorrectExample())))\n                .isEmpty();\n        assertThat(ConstraintViolations.format(validator.validate(new CorrectExample())))\n                .isEmpty();\n        assertThat(TestLoggerFactory.getAllLoggingEvents())\n                .isEmpty();\n    }\n\n    @Test\n    public void testDirectContextUsage() {\n        assertThat(ConstraintViolations.format(validator.validate(new DirectContextExample())))\n                .containsExactlyInAnyOrder(FAILED_RESULT);\n        assertThat(TestLoggerFactory.getAllLoggingEvents())\n                .isEmpty();\n    }\n\n    @Test\n    public void complexExample() {\n        assertThat(ConstraintViolations.format(validator.validate(new ComplexExample())))\n                .containsExactly(\n                        \" failed1\",\n                        \"p2 failed\",\n                        \"p[3] failed\",\n                        \"p[four] failed\");\n        assertThat(TestLoggerFactory.getAllLoggingEvents())\n                .isEmpty();\n    }\n\n    @Test\n    public void invalidExample() throws Exception {\n        assertThat(ConstraintViolations.format(validator.validate(new InvalidExample())))\n                .isEmpty();\n        assertThat(TestLoggerFactory.getAllLoggingEvents())\n                .containsExactlyInAnyOrder(\n                        new LoggingEvent(\n                                Level.ERROR,\n                                \"The method {} is annotated with @SelfValidation but does not have a single parameter of type {}\",\n                                InvalidExample.class.getMethod(\"validateFailAdditionalParameters\", ViolationCollector.class, int.class),\n                                ViolationCollector.class\n                        ),\n                        new LoggingEvent(\n                                Level.ERROR,\n                                \"The method {} is annotated with @SelfValidation but does not return void. It is ignored\",\n                                InvalidExample.class.getMethod(\"validateFailReturn\", ViolationCollector.class)\n                        ),\n                        new LoggingEvent(\n                                Level.ERROR,\n                                \"The method {} is annotated with @SelfValidation but is not public\",\n                                InvalidExample.class.getDeclaredMethod(\"validateFailPrivate\", ViolationCollector.class)\n                        )\n                );\n    }\n\n    @Test\n    public void giveWarningIfNoValidationMethods() {\n        assertThat(ConstraintViolations.format(validator.validate(new NoValidations())))\n                .isEmpty();\n        assertThat(TestLoggerFactory.getAllLoggingEvents())\n                .containsExactlyInAnyOrder(\n                        new LoggingEvent(\n                                Level.WARN,\n                                \"The class {} is annotated with @SelfValidating but contains no valid methods that are annotated with @SelfValidation\",\n                                NoValidations.class\n                        )\n\n                );\n    }\n\n    @Test\n    public void violationMessagesAreEscaped() {\n        assertThat(ConstraintViolations.format(validator.validate(new InjectionExample()))).containsExactly(\n                \" ${'value'}\",\n                \"${'property'} ${'value'}\",\n                \"${'property'}[${'key'}] ${'value'}\",\n                \"${'property'}[1] ${'value'}\"\n        );\n        assertThat(TestLoggerFactory.getAllLoggingEvents()).isEmpty();\n    }\n}\n"], "filenames": ["dropwizard-validation/src/main/java/io/dropwizard/validation/selfvalidating/ViolationCollector.java", "dropwizard-validation/src/test/java/io/dropwizard/validation/SelfValidationTest.java"], "buggy_code_start_loc": [2, 3], "buggy_code_end_loc": [28, 245], "fixing_code_start_loc": [3, 3], "fixing_code_end_loc": [98, 282], "type": "CWE-74", "message": "Dropwizard-Validation before 1.3.19, and 2.0.2 may allow arbitrary code execution on the host system, with the privileges of the Dropwizard service account, by injecting arbitrary Java Expression Language expressions when using the self-validating feature. The issue has been fixed in dropwizard-validation 1.3.19 and 2.0.2.", "other": {"cve": {"id": "CVE-2020-5245", "sourceIdentifier": "security-advisories@github.com", "published": "2020-02-24T18:15:22.477", "lastModified": "2022-05-12T15:00:07.600", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Dropwizard-Validation before 1.3.19, and 2.0.2 may allow arbitrary code execution on the host system, with the privileges of the Dropwizard service account, by injecting arbitrary Java Expression Language expressions when using the self-validating feature. The issue has been fixed in dropwizard-validation 1.3.19 and 2.0.2."}, {"lang": "es", "value": "Dropwizard-Validation versiones anteriores a 1.3.19 y 2.0.2, puede permitir una ejecuci\u00f3n de c\u00f3digo arbitraria en el host system, con los privilegios de la cuenta de servicio de Dropwizard, mediante la inyecci\u00f3n de expresiones arbitrarias de Java Expression Language cuando se utiliza la funcionalidad self-validating. El problema se ha corregido en dropwizard-validation versiones 1.3.19 y 2.0.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:H/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 7.9, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.0}, "baseSeverity": "HIGH", "exploitabilityScore": 8.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dropwizard:dropwizard_validation:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.19", "matchCriteriaId": "6093F68F-E2FF-4A25-A709-79F315833DEF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:dropwizard:dropwizard_validation:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.0.2", "matchCriteriaId": "4522F31B-974E-4957-8A49-6B396C810720"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:blockchain_platform:*:*:*:*:*:*:*:*", "versionEndExcluding": "21.1.2", "matchCriteriaId": "D0DBC938-A782-433F-8BF1-CA250C332AA7"}]}]}], "references": [{"url": "https://beanvalidation.org/2.0/spec/#validationapi-message-defaultmessageinterpolation", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://docs.jboss.org/hibernate/validator/6.1/reference/en-US/html_single/#section-interpolation-with-message-expressions", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://docs.oracle.com/javaee/7/tutorial/jsf-el.htm", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/dropwizard/dropwizard/commit/d87d1e4f8e20f6494c0232bf8560c961b46db634", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dropwizard/dropwizard/pull/3157", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dropwizard/dropwizard/pull/3160", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dropwizard/dropwizard/security/advisories/GHSA-3mcp-9wr4-cjqf", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dropwizard/dropwizard/commit/d87d1e4f8e20f6494c0232bf8560c961b46db634"}}