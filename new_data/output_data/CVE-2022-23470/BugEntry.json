{"buggy_code": ["import os\nfrom typing import List, Tuple\n\nfrom paste import request\nfrom paste.fileapp import FileApp\nfrom paste.httpheaders import ETAG\nfrom paste.urlparser import StaticURLParser\n\n\nclass CacheableStaticURLParser(StaticURLParser):\n\n    def __init__(self, directory, cache_seconds=None, directory_per_host=None):\n        StaticURLParser.__init__(self, directory)\n        self.cache_seconds = cache_seconds\n        self.directory_per_host = directory_per_host\n\n    def __call__(self, environ, start_response):\n        path_info = environ.get('PATH_INFO', '')\n        if not path_info:\n            # See if this is a static file hackishly mapped.\n            if os.path.exists(self.directory) and os.path.isfile(self.directory):\n                app = FileApp(self.directory)\n                if self.cache_seconds:\n                    app.cache_control(max_age=int(self.cache_seconds))\n                return app(environ, start_response)\n            return self.add_slash(environ, start_response)\n        if path_info == '/':\n            # @@: This should obviously be configurable\n            filename = 'index.html'\n        else:\n            filename = request.path_info_pop(environ)\n\n        directory = self.directory\n        host = environ.get('HTTP_HOST')\n        if self.directory_per_host and host:\n            for host_key, host_val in self.directory_per_host.items():\n                if host_key in host:\n                    directory = host_val\n                    break\n\n        full = os.path.join(directory, filename)\n        if not os.path.exists(full):\n            return self.not_found(environ, start_response)\n        if os.path.isdir(full):\n            # @@: Cache?\n            return self.__class__(full)(environ, start_response)\n        if environ.get('PATH_INFO') and environ.get('PATH_INFO') != '/':\n            return self.error_extra_path(environ, start_response)\n        if_none_match = environ.get('HTTP_IF_NONE_MATCH')\n        if if_none_match:\n            mytime = os.stat(full).st_mtime\n            if str(mytime) == if_none_match:\n                headers: List[Tuple[str, str]] = []\n                ETAG.update(headers, mytime)\n                start_response('304 Not Modified', headers)\n                return ['']  # empty body\n        app = FileApp(full)\n        if self.cache_seconds:\n            app.cache_control(max_age=int(self.cache_seconds))\n        return app(environ, start_response)\n\n\ndef make_static(global_conf, document_root, cache_seconds=None):\n    return CacheableStaticURLParser(document_root, cache_seconds)\n"], "fixing_code": ["import os\nfrom typing import List, Tuple\n\nfrom paste import request\nfrom paste.fileapp import FileApp\nfrom paste.httpheaders import ETAG\nfrom paste.urlparser import StaticURLParser\n\n\nclass CacheableStaticURLParser(StaticURLParser):\n\n    def __init__(self, directory, cache_seconds=None, directory_per_host=None):\n        StaticURLParser.__init__(self, directory)\n        self.cache_seconds = cache_seconds\n        self.directory_per_host = directory_per_host\n\n    def __call__(self, environ, start_response):\n        path_info = environ.get('PATH_INFO', '')\n        if not path_info:\n            # See if this is a static file hackishly mapped.\n            if os.path.exists(self.directory) and os.path.isfile(self.directory):\n                app = FileApp(self.directory)\n                if self.cache_seconds:\n                    app.cache_control(max_age=int(self.cache_seconds))\n                return app(environ, start_response)\n            return self.add_slash(environ, start_response)\n        if path_info == '/':\n            # @@: This should obviously be configurable\n            filename = 'index.html'\n        else:\n            filename = request.path_info_pop(environ)\n\n        directory = self.directory\n        host = environ.get('HTTP_HOST')\n        if self.directory_per_host and host:\n            for host_key, host_val in self.directory_per_host.items():\n                if host_key in host:\n                    directory = host_val\n                    break\n\n        full = self.normpath(os.path.join(directory, filename))\n        if not full.startswith(directory):\n            # Out of bounds\n            return self.not_found(environ, start_response)\n\n        if not os.path.exists(full):\n            return self.not_found(environ, start_response)\n        if os.path.isdir(full):\n            # @@: Cache?\n            return self.__class__(full)(environ, start_response)\n        if environ.get('PATH_INFO') and environ.get('PATH_INFO') != '/':\n            return self.error_extra_path(environ, start_response)\n        if_none_match = environ.get('HTTP_IF_NONE_MATCH')\n        if if_none_match:\n            mytime = os.stat(full).st_mtime\n            if str(mytime) == if_none_match:\n                headers: List[Tuple[str, str]] = []\n                ETAG.update(headers, mytime)\n                start_response('304 Not Modified', headers)\n                return ['']  # empty body\n        app = FileApp(full)\n        if self.cache_seconds:\n            app.cache_control(max_age=int(self.cache_seconds))\n        return app(environ, start_response)\n\n\ndef make_static(global_conf, document_root, cache_seconds=None):\n    return CacheableStaticURLParser(document_root, cache_seconds)\n"], "filenames": ["lib/galaxy/web/framework/middleware/static.py"], "buggy_code_start_loc": [41], "buggy_code_end_loc": [42], "fixing_code_start_loc": [41], "fixing_code_end_loc": [46], "type": "CWE-22", "message": "Galaxy is an open-source platform for data analysis. An arbitrary file read exists in Galaxy 22.01 and Galaxy 22.05 due to the switch to Gunicorn, which can be used to read any file accessible to the operating system user under which Galaxy is running. This vulnerability affects Galaxy 22.01 and higher, after the switch to gunicorn, which serve static contents directly. Additionally, the vulnerability is mitigated when using Nginx or Apache to serve /static/* contents, instead of Galaxy's internal middleware. This issue has been patched in commit `e5e6bda4f` and will be included in future releases. Users are advised to manually patch their installations. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2022-23470", "sourceIdentifier": "security-advisories@github.com", "published": "2022-12-06T18:15:10.090", "lastModified": "2022-12-08T18:00:26.873", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Galaxy is an open-source platform for data analysis. An arbitrary file read exists in Galaxy 22.01 and Galaxy 22.05 due to the switch to Gunicorn, which can be used to read any file accessible to the operating system user under which Galaxy is running. This vulnerability affects Galaxy 22.01 and higher, after the switch to gunicorn, which serve static contents directly. Additionally, the vulnerability is mitigated when using Nginx or Apache to serve /static/* contents, instead of Galaxy's internal middleware. This issue has been patched in commit `e5e6bda4f` and will be included in future releases. Users are advised to manually patch their installations. There are no known workarounds for this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:galaxyproject:galaxy:*:*:*:*:*:*:*:*", "versionStartIncluding": "22.01", "versionEndIncluding": "22.05", "matchCriteriaId": "A0F7B08A-3315-4CDC-8BDE-6FF30A49DCF4"}]}]}], "references": [{"url": "https://github.com/galaxyproject/galaxy/commit/e5e6bda4f014f807ca77ee0cf6af777a55918346", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/galaxyproject/galaxy/security/advisories/GHSA-grjf-2ghx-q77x", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/galaxyproject/galaxy/commit/e5e6bda4f014f807ca77ee0cf6af777a55918346"}}