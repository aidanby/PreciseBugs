{"buggy_code": ["/*\n * A bus for connecting virtio serial and console ports\n *\n * Copyright (C) 2009, 2010 Red Hat, Inc.\n *\n * Author(s):\n *  Amit Shah <amit.shah@redhat.com>\n *\n * Some earlier parts are:\n *  Copyright IBM, Corp. 2008\n * authored by\n *  Christian Ehrhardt <ehrhardt@linux.vnet.ibm.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n * Contributions after 2012-01-13 are licensed under the terms of the\n * GNU GPL, version 2 or (at your option) any later version.\n */\n\n#include \"qemu/iov.h\"\n#include \"monitor/monitor.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/queue.h\"\n#include \"hw/sysbus.h\"\n#include \"trace.h\"\n#include \"hw/virtio/virtio-serial.h\"\n#include \"hw/virtio/virtio-access.h\"\n\nstatic struct VirtIOSerialDevices {\n    QLIST_HEAD(, VirtIOSerial) devices;\n} vserdevices;\n\nstatic VirtIOSerialPort *find_port_by_id(VirtIOSerial *vser, uint32_t id)\n{\n    VirtIOSerialPort *port;\n\n    if (id == VIRTIO_CONSOLE_BAD_ID) {\n        return NULL;\n    }\n\n    QTAILQ_FOREACH(port, &vser->ports, next) {\n        if (port->id == id)\n            return port;\n    }\n    return NULL;\n}\n\nstatic VirtIOSerialPort *find_port_by_vq(VirtIOSerial *vser, VirtQueue *vq)\n{\n    VirtIOSerialPort *port;\n\n    QTAILQ_FOREACH(port, &vser->ports, next) {\n        if (port->ivq == vq || port->ovq == vq)\n            return port;\n    }\n    return NULL;\n}\n\nstatic VirtIOSerialPort *find_port_by_name(char *name)\n{\n    VirtIOSerial *vser;\n\n    QLIST_FOREACH(vser, &vserdevices.devices, next) {\n        VirtIOSerialPort *port;\n\n        QTAILQ_FOREACH(port, &vser->ports, next) {\n            if (port->name && !strcmp(port->name, name)) {\n                return port;\n            }\n        }\n    }\n    return NULL;\n}\n\nstatic bool use_multiport(VirtIOSerial *vser)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(vser);\n    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);\n}\n\nstatic size_t write_to_port(VirtIOSerialPort *port,\n                            const uint8_t *buf, size_t size)\n{\n    VirtQueueElement elem;\n    VirtQueue *vq;\n    size_t offset;\n\n    vq = port->ivq;\n    if (!virtio_queue_ready(vq)) {\n        return 0;\n    }\n\n    offset = 0;\n    while (offset < size) {\n        size_t len;\n\n        if (!virtqueue_pop(vq, &elem)) {\n            break;\n        }\n\n        len = iov_from_buf(elem.in_sg, elem.in_num, 0,\n                           buf + offset, size - offset);\n        offset += len;\n\n        virtqueue_push(vq, &elem, len);\n    }\n\n    virtio_notify(VIRTIO_DEVICE(port->vser), vq);\n    return offset;\n}\n\nstatic void discard_vq_data(VirtQueue *vq, VirtIODevice *vdev)\n{\n    VirtQueueElement elem;\n\n    if (!virtio_queue_ready(vq)) {\n        return;\n    }\n    while (virtqueue_pop(vq, &elem)) {\n        virtqueue_push(vq, &elem, 0);\n    }\n    virtio_notify(vdev, vq);\n}\n\nstatic void do_flush_queued_data(VirtIOSerialPort *port, VirtQueue *vq,\n                                 VirtIODevice *vdev)\n{\n    VirtIOSerialPortClass *vsc;\n\n    assert(port);\n    assert(virtio_queue_ready(vq));\n\n    vsc = VIRTIO_SERIAL_PORT_GET_CLASS(port);\n\n    while (!port->throttled) {\n        unsigned int i;\n\n        /* Pop an elem only if we haven't left off a previous one mid-way */\n        if (!port->elem.out_num) {\n            if (!virtqueue_pop(vq, &port->elem)) {\n                break;\n            }\n            port->iov_idx = 0;\n            port->iov_offset = 0;\n        }\n\n        for (i = port->iov_idx; i < port->elem.out_num; i++) {\n            size_t buf_size;\n            ssize_t ret;\n\n            buf_size = port->elem.out_sg[i].iov_len - port->iov_offset;\n            ret = vsc->have_data(port,\n                                  port->elem.out_sg[i].iov_base\n                                  + port->iov_offset,\n                                  buf_size);\n            if (port->throttled) {\n                port->iov_idx = i;\n                if (ret > 0) {\n                    port->iov_offset += ret;\n                }\n                break;\n            }\n            port->iov_offset = 0;\n        }\n        if (port->throttled) {\n            break;\n        }\n        virtqueue_push(vq, &port->elem, 0);\n        port->elem.out_num = 0;\n    }\n    virtio_notify(vdev, vq);\n}\n\nstatic void flush_queued_data(VirtIOSerialPort *port)\n{\n    assert(port);\n\n    if (!virtio_queue_ready(port->ovq)) {\n        return;\n    }\n    do_flush_queued_data(port, port->ovq, VIRTIO_DEVICE(port->vser));\n}\n\nstatic size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n{\n    VirtQueueElement elem;\n    VirtQueue *vq;\n\n    vq = vser->c_ivq;\n    if (!virtio_queue_ready(vq)) {\n        return 0;\n    }\n    if (!virtqueue_pop(vq, &elem)) {\n        return 0;\n    }\n\n    memcpy(elem.in_sg[0].iov_base, buf, len);\n\n    virtqueue_push(vq, &elem, len);\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n    return len;\n}\n\nstatic size_t send_control_event(VirtIOSerial *vser, uint32_t port_id,\n                                 uint16_t event, uint16_t value)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(vser);\n    struct virtio_console_control cpkt;\n\n    virtio_stl_p(vdev, &cpkt.id, port_id);\n    virtio_stw_p(vdev, &cpkt.event, event);\n    virtio_stw_p(vdev, &cpkt.value, value);\n\n    trace_virtio_serial_send_control_event(port_id, event, value);\n    return send_control_msg(vser, &cpkt, sizeof(cpkt));\n}\n\n/* Functions for use inside qemu to open and read from/write to ports */\nint virtio_serial_open(VirtIOSerialPort *port)\n{\n    /* Don't allow opening an already-open port */\n    if (port->host_connected) {\n        return 0;\n    }\n    /* Send port open notification to the guest */\n    port->host_connected = true;\n    send_control_event(port->vser, port->id, VIRTIO_CONSOLE_PORT_OPEN, 1);\n\n    return 0;\n}\n\nint virtio_serial_close(VirtIOSerialPort *port)\n{\n    port->host_connected = false;\n    /*\n     * If there's any data the guest sent which the app didn't\n     * consume, reset the throttling flag and discard the data.\n     */\n    port->throttled = false;\n    discard_vq_data(port->ovq, VIRTIO_DEVICE(port->vser));\n\n    send_control_event(port->vser, port->id, VIRTIO_CONSOLE_PORT_OPEN, 0);\n\n    return 0;\n}\n\n/* Individual ports/apps call this function to write to the guest. */\nssize_t virtio_serial_write(VirtIOSerialPort *port, const uint8_t *buf,\n                            size_t size)\n{\n    if (!port || !port->host_connected || !port->guest_connected) {\n        return 0;\n    }\n    return write_to_port(port, buf, size);\n}\n\n/*\n * Readiness of the guest to accept data on a port.\n * Returns max. data the guest can receive\n */\nsize_t virtio_serial_guest_ready(VirtIOSerialPort *port)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(port->vser);\n    VirtQueue *vq = port->ivq;\n    unsigned int bytes;\n\n    if (!virtio_queue_ready(vq) ||\n        !(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK) ||\n        virtio_queue_empty(vq)) {\n        return 0;\n    }\n    if (use_multiport(port->vser) && !port->guest_connected) {\n        return 0;\n    }\n    virtqueue_get_avail_bytes(vq, &bytes, NULL, 4096, 0);\n    return bytes;\n}\n\nstatic void flush_queued_data_bh(void *opaque)\n{\n    VirtIOSerialPort *port = opaque;\n\n    flush_queued_data(port);\n}\n\nvoid virtio_serial_throttle_port(VirtIOSerialPort *port, bool throttle)\n{\n    if (!port) {\n        return;\n    }\n\n    trace_virtio_serial_throttle_port(port->id, throttle);\n    port->throttled = throttle;\n    if (throttle) {\n        return;\n    }\n    qemu_bh_schedule(port->bh);\n}\n\n/* Guest wants to notify us of some event */\nstatic void handle_control_message(VirtIOSerial *vser, void *buf, size_t len)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(vser);\n    struct VirtIOSerialPort *port;\n    VirtIOSerialPortClass *vsc;\n    struct virtio_console_control cpkt, *gcpkt;\n    uint8_t *buffer;\n    size_t buffer_len;\n\n    gcpkt = buf;\n\n    if (len < sizeof(cpkt)) {\n        /* The guest sent an invalid control packet */\n        return;\n    }\n\n    cpkt.event = virtio_lduw_p(vdev, &gcpkt->event);\n    cpkt.value = virtio_lduw_p(vdev, &gcpkt->value);\n\n    trace_virtio_serial_handle_control_message(cpkt.event, cpkt.value);\n\n    if (cpkt.event == VIRTIO_CONSOLE_DEVICE_READY) {\n        if (!cpkt.value) {\n            error_report(\"virtio-serial-bus: Guest failure in adding device %s\",\n                         vser->bus.qbus.name);\n            return;\n        }\n        /*\n         * The device is up, we can now tell the device about all the\n         * ports we have here.\n         */\n        QTAILQ_FOREACH(port, &vser->ports, next) {\n            send_control_event(vser, port->id, VIRTIO_CONSOLE_PORT_ADD, 1);\n        }\n        return;\n    }\n\n    port = find_port_by_id(vser, virtio_ldl_p(vdev, &gcpkt->id));\n    if (!port) {\n        error_report(\"virtio-serial-bus: Unexpected port id %u for device %s\",\n                     virtio_ldl_p(vdev, &gcpkt->id), vser->bus.qbus.name);\n        return;\n    }\n\n    trace_virtio_serial_handle_control_message_port(port->id);\n\n    vsc = VIRTIO_SERIAL_PORT_GET_CLASS(port);\n\n    switch(cpkt.event) {\n    case VIRTIO_CONSOLE_PORT_READY:\n        if (!cpkt.value) {\n            error_report(\"virtio-serial-bus: Guest failure in adding port %u for device %s\",\n                         port->id, vser->bus.qbus.name);\n            break;\n        }\n        /*\n         * Now that we know the guest asked for the port name, we're\n         * sure the guest has initialised whatever state is necessary\n         * for this port. Now's a good time to let the guest know if\n         * this port is a console port so that the guest can hook it\n         * up to hvc.\n         */\n        if (vsc->is_console) {\n            send_control_event(vser, port->id, VIRTIO_CONSOLE_CONSOLE_PORT, 1);\n        }\n\n        if (port->name) {\n            virtio_stl_p(vdev, &cpkt.id, port->id);\n            virtio_stw_p(vdev, &cpkt.event, VIRTIO_CONSOLE_PORT_NAME);\n            virtio_stw_p(vdev, &cpkt.value, 1);\n\n            buffer_len = sizeof(cpkt) + strlen(port->name) + 1;\n            buffer = g_malloc(buffer_len);\n\n            memcpy(buffer, &cpkt, sizeof(cpkt));\n            memcpy(buffer + sizeof(cpkt), port->name, strlen(port->name));\n            buffer[buffer_len - 1] = 0;\n\n            send_control_msg(vser, buffer, buffer_len);\n            g_free(buffer);\n        }\n\n        if (port->host_connected) {\n            send_control_event(vser, port->id, VIRTIO_CONSOLE_PORT_OPEN, 1);\n        }\n\n        /*\n         * When the guest has asked us for this information it means\n         * the guest is all setup and has its virtqueues\n         * initialised. If some app is interested in knowing about\n         * this event, let it know.\n         */\n        if (vsc->guest_ready) {\n            vsc->guest_ready(port);\n        }\n        break;\n\n    case VIRTIO_CONSOLE_PORT_OPEN:\n        port->guest_connected = cpkt.value;\n        if (vsc->set_guest_connected) {\n            /* Send the guest opened notification if an app is interested */\n            vsc->set_guest_connected(port, cpkt.value);\n        }\n        break;\n    }\n}\n\nstatic void control_in(VirtIODevice *vdev, VirtQueue *vq)\n{\n}\n\nstatic void control_out(VirtIODevice *vdev, VirtQueue *vq)\n{\n    VirtQueueElement elem;\n    VirtIOSerial *vser;\n    uint8_t *buf;\n    size_t len;\n\n    vser = VIRTIO_SERIAL(vdev);\n\n    len = 0;\n    buf = NULL;\n    while (virtqueue_pop(vq, &elem)) {\n        size_t cur_len;\n\n        cur_len = iov_size(elem.out_sg, elem.out_num);\n        /*\n         * Allocate a new buf only if we didn't have one previously or\n         * if the size of the buf differs\n         */\n        if (cur_len > len) {\n            g_free(buf);\n\n            buf = g_malloc(cur_len);\n            len = cur_len;\n        }\n        iov_to_buf(elem.out_sg, elem.out_num, 0, buf, cur_len);\n\n        handle_control_message(vser, buf, cur_len);\n        virtqueue_push(vq, &elem, 0);\n    }\n    g_free(buf);\n    virtio_notify(vdev, vq);\n}\n\n/* Guest wrote something to some port. */\nstatic void handle_output(VirtIODevice *vdev, VirtQueue *vq)\n{\n    VirtIOSerial *vser;\n    VirtIOSerialPort *port;\n\n    vser = VIRTIO_SERIAL(vdev);\n    port = find_port_by_vq(vser, vq);\n\n    if (!port || !port->host_connected) {\n        discard_vq_data(vq, vdev);\n        return;\n    }\n\n    if (!port->throttled) {\n        do_flush_queued_data(port, vq, vdev);\n        return;\n    }\n}\n\nstatic void handle_input(VirtIODevice *vdev, VirtQueue *vq)\n{\n    /*\n     * Users of virtio-serial would like to know when guest becomes\n     * writable again -- i.e. if a vq had stuff queued up and the\n     * guest wasn't reading at all, the host would not be able to\n     * write to the vq anymore.  Once the guest reads off something,\n     * we can start queueing things up again.  However, this call is\n     * made for each buffer addition by the guest -- even though free\n     * buffers existed prior to the current buffer addition.  This is\n     * done so as not to maintain previous state, which will need\n     * additional live-migration-related changes.\n     */\n    VirtIOSerial *vser;\n    VirtIOSerialPort *port;\n    VirtIOSerialPortClass *vsc;\n\n    vser = VIRTIO_SERIAL(vdev);\n    port = find_port_by_vq(vser, vq);\n\n    if (!port) {\n        return;\n    }\n    vsc = VIRTIO_SERIAL_PORT_GET_CLASS(port);\n\n    /*\n     * If guest_connected is false, this call is being made by the\n     * early-boot queueing up of descriptors, which is just noise for\n     * the host apps -- don't disturb them in that case.\n     */\n    if (port->guest_connected && port->host_connected && vsc->guest_writable) {\n        vsc->guest_writable(port);\n    }\n}\n\nstatic uint64_t get_features(VirtIODevice *vdev, uint64_t features)\n{\n    VirtIOSerial *vser;\n\n    vser = VIRTIO_SERIAL(vdev);\n\n    if (vser->bus.max_nr_ports > 1) {\n        virtio_add_feature(&features, VIRTIO_CONSOLE_F_MULTIPORT);\n    }\n    return features;\n}\n\n/* Guest requested config info */\nstatic void get_config(VirtIODevice *vdev, uint8_t *config_data)\n{\n    VirtIOSerial *vser = VIRTIO_SERIAL(vdev);\n    struct virtio_console_config *config =\n        (struct virtio_console_config *)config_data;\n\n    config->cols = 0;\n    config->rows = 0;\n    config->max_nr_ports = virtio_tswap32(vdev,\n                                          vser->serial.max_virtserial_ports);\n}\n\nstatic void guest_reset(VirtIOSerial *vser)\n{\n    VirtIOSerialPort *port;\n    VirtIOSerialPortClass *vsc;\n\n    QTAILQ_FOREACH(port, &vser->ports, next) {\n        vsc = VIRTIO_SERIAL_PORT_GET_CLASS(port);\n        if (port->guest_connected) {\n            port->guest_connected = false;\n            if (vsc->set_guest_connected) {\n                vsc->set_guest_connected(port, false);\n            }\n        }\n    }\n}\n\nstatic void set_status(VirtIODevice *vdev, uint8_t status)\n{\n    VirtIOSerial *vser;\n    VirtIOSerialPort *port;\n\n    vser = VIRTIO_SERIAL(vdev);\n    port = find_port_by_id(vser, 0);\n\n    if (port && !use_multiport(port->vser)\n        && (status & VIRTIO_CONFIG_S_DRIVER_OK)) {\n        /*\n         * Non-multiport guests won't be able to tell us guest\n         * open/close status.  Such guests can only have a port at id\n         * 0, so set guest_connected for such ports as soon as guest\n         * is up.\n         */\n        port->guest_connected = true;\n    }\n    if (!(status & VIRTIO_CONFIG_S_DRIVER_OK)) {\n        guest_reset(vser);\n    }\n}\n\nstatic void vser_reset(VirtIODevice *vdev)\n{\n    VirtIOSerial *vser;\n\n    vser = VIRTIO_SERIAL(vdev);\n    guest_reset(vser);\n}\n\nstatic void virtio_serial_save(QEMUFile *f, void *opaque)\n{\n    /* The virtio device */\n    virtio_save(VIRTIO_DEVICE(opaque), f);\n}\n\nstatic void virtio_serial_save_device(VirtIODevice *vdev, QEMUFile *f)\n{\n    VirtIOSerial *s = VIRTIO_SERIAL(vdev);\n    VirtIOSerialPort *port;\n    uint32_t nr_active_ports;\n    unsigned int i, max_nr_ports;\n    struct virtio_console_config config;\n\n    /* The config space (ignored on the far end in current versions) */\n    get_config(vdev, (uint8_t *)&config);\n    qemu_put_be16s(f, &config.cols);\n    qemu_put_be16s(f, &config.rows);\n    qemu_put_be32s(f, &config.max_nr_ports);\n\n    /* The ports map */\n    max_nr_ports = s->serial.max_virtserial_ports;\n    for (i = 0; i < (max_nr_ports + 31) / 32; i++) {\n        qemu_put_be32s(f, &s->ports_map[i]);\n    }\n\n    /* Ports */\n\n    nr_active_ports = 0;\n    QTAILQ_FOREACH(port, &s->ports, next) {\n        nr_active_ports++;\n    }\n\n    qemu_put_be32s(f, &nr_active_ports);\n\n    /*\n     * Items in struct VirtIOSerialPort.\n     */\n    QTAILQ_FOREACH(port, &s->ports, next) {\n        uint32_t elem_popped;\n\n        qemu_put_be32s(f, &port->id);\n        qemu_put_byte(f, port->guest_connected);\n        qemu_put_byte(f, port->host_connected);\n\n\telem_popped = 0;\n        if (port->elem.out_num) {\n            elem_popped = 1;\n        }\n        qemu_put_be32s(f, &elem_popped);\n        if (elem_popped) {\n            qemu_put_be32s(f, &port->iov_idx);\n            qemu_put_be64s(f, &port->iov_offset);\n\n            qemu_put_buffer(f, (unsigned char *)&port->elem,\n                            sizeof(port->elem));\n        }\n    }\n}\n\nstatic void virtio_serial_post_load_timer_cb(void *opaque)\n{\n    uint32_t i;\n    VirtIOSerial *s = VIRTIO_SERIAL(opaque);\n    VirtIOSerialPort *port;\n    uint8_t host_connected;\n    VirtIOSerialPortClass *vsc;\n\n    if (!s->post_load) {\n        return;\n    }\n    for (i = 0 ; i < s->post_load->nr_active_ports; ++i) {\n        port = s->post_load->connected[i].port;\n        host_connected = s->post_load->connected[i].host_connected;\n        if (host_connected != port->host_connected) {\n            /*\n             * We have to let the guest know of the host connection\n             * status change\n             */\n            send_control_event(s, port->id, VIRTIO_CONSOLE_PORT_OPEN,\n                               port->host_connected);\n        }\n        vsc = VIRTIO_SERIAL_PORT_GET_CLASS(port);\n        if (vsc->set_guest_connected) {\n            vsc->set_guest_connected(port, port->guest_connected);\n        }\n    }\n    g_free(s->post_load->connected);\n    timer_free(s->post_load->timer);\n    g_free(s->post_load);\n    s->post_load = NULL;\n}\n\nstatic int fetch_active_ports_list(QEMUFile *f, int version_id,\n                                   VirtIOSerial *s, uint32_t nr_active_ports)\n{\n    uint32_t i;\n\n    s->post_load = g_malloc0(sizeof(*s->post_load));\n    s->post_load->nr_active_ports = nr_active_ports;\n    s->post_load->connected =\n        g_malloc0(sizeof(*s->post_load->connected) * nr_active_ports);\n\n    s->post_load->timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n                                            virtio_serial_post_load_timer_cb,\n                                            s);\n\n    /* Items in struct VirtIOSerialPort */\n    for (i = 0; i < nr_active_ports; i++) {\n        VirtIOSerialPort *port;\n        uint32_t id;\n\n        id = qemu_get_be32(f);\n        port = find_port_by_id(s, id);\n        if (!port) {\n            return -EINVAL;\n        }\n\n        port->guest_connected = qemu_get_byte(f);\n        s->post_load->connected[i].port = port;\n        s->post_load->connected[i].host_connected = qemu_get_byte(f);\n\n        if (version_id > 2) {\n            uint32_t elem_popped;\n\n            qemu_get_be32s(f, &elem_popped);\n            if (elem_popped) {\n                qemu_get_be32s(f, &port->iov_idx);\n                qemu_get_be64s(f, &port->iov_offset);\n\n                qemu_get_buffer(f, (unsigned char *)&port->elem,\n                                sizeof(port->elem));\n                virtqueue_map_sg(port->elem.in_sg, port->elem.in_addr,\n                                 port->elem.in_num, 1);\n                virtqueue_map_sg(port->elem.out_sg, port->elem.out_addr,\n                                 port->elem.out_num, 1);\n\n                /*\n                 *  Port was throttled on source machine.  Let's\n                 *  unthrottle it here so data starts flowing again.\n                 */\n                virtio_serial_throttle_port(port, false);\n            }\n        }\n    }\n    timer_mod(s->post_load->timer, 1);\n    return 0;\n}\n\nstatic int virtio_serial_load(QEMUFile *f, void *opaque, int version_id)\n{\n    if (version_id > 3) {\n        return -EINVAL;\n    }\n\n    /* The virtio device */\n    return virtio_load(VIRTIO_DEVICE(opaque), f, version_id);\n}\n\nstatic int virtio_serial_load_device(VirtIODevice *vdev, QEMUFile *f,\n                                     int version_id)\n{\n    VirtIOSerial *s = VIRTIO_SERIAL(vdev);\n    uint32_t max_nr_ports, nr_active_ports, ports_map;\n    unsigned int i;\n    int ret;\n    uint32_t tmp;\n\n    if (version_id < 2) {\n        return 0;\n    }\n\n    /* Unused */\n    qemu_get_be16s(f, (uint16_t *) &tmp);\n    qemu_get_be16s(f, (uint16_t *) &tmp);\n    qemu_get_be32s(f, &tmp);\n\n    max_nr_ports = s->serial.max_virtserial_ports;\n    for (i = 0; i < (max_nr_ports + 31) / 32; i++) {\n        qemu_get_be32s(f, &ports_map);\n\n        if (ports_map != s->ports_map[i]) {\n            /*\n             * Ports active on source and destination don't\n             * match. Fail migration.\n             */\n            return -EINVAL;\n        }\n    }\n\n    qemu_get_be32s(f, &nr_active_ports);\n\n    if (nr_active_ports) {\n        ret = fetch_active_ports_list(f, version_id, s, nr_active_ports);\n        if (ret) {\n            return ret;\n        }\n    }\n    return 0;\n}\n\nstatic void virtser_bus_dev_print(Monitor *mon, DeviceState *qdev, int indent);\n\nstatic Property virtser_props[] = {\n    DEFINE_PROP_UINT32(\"nr\", VirtIOSerialPort, id, VIRTIO_CONSOLE_BAD_ID),\n    DEFINE_PROP_STRING(\"name\", VirtIOSerialPort, name),\n    DEFINE_PROP_END_OF_LIST()\n};\n\n#define TYPE_VIRTIO_SERIAL_BUS \"virtio-serial-bus\"\n#define VIRTIO_SERIAL_BUS(obj) \\\n      OBJECT_CHECK(VirtIOSerialBus, (obj), TYPE_VIRTIO_SERIAL_BUS)\n\nstatic void virtser_bus_class_init(ObjectClass *klass, void *data)\n{\n    BusClass *k = BUS_CLASS(klass);\n    k->print_dev = virtser_bus_dev_print;\n}\n\nstatic const TypeInfo virtser_bus_info = {\n    .name = TYPE_VIRTIO_SERIAL_BUS,\n    .parent = TYPE_BUS,\n    .instance_size = sizeof(VirtIOSerialBus),\n    .class_init = virtser_bus_class_init,\n};\n\nstatic void virtser_bus_dev_print(Monitor *mon, DeviceState *qdev, int indent)\n{\n    VirtIOSerialPort *port = DO_UPCAST(VirtIOSerialPort, dev, qdev);\n\n    monitor_printf(mon, \"%*sport %d, guest %s, host %s, throttle %s\\n\",\n                   indent, \"\", port->id,\n                   port->guest_connected ? \"on\" : \"off\",\n                   port->host_connected ? \"on\" : \"off\",\n                   port->throttled ? \"on\" : \"off\");\n}\n\n/* This function is only used if a port id is not provided by the user */\nstatic uint32_t find_free_port_id(VirtIOSerial *vser)\n{\n    unsigned int i, max_nr_ports;\n\n    max_nr_ports = vser->serial.max_virtserial_ports;\n    for (i = 0; i < (max_nr_ports + 31) / 32; i++) {\n        uint32_t map, zeroes;\n\n        map = vser->ports_map[i];\n        zeroes = ctz32(~map);\n        if (zeroes != 32) {\n            return zeroes + i * 32;\n        }\n    }\n    return VIRTIO_CONSOLE_BAD_ID;\n}\n\nstatic void mark_port_added(VirtIOSerial *vser, uint32_t port_id)\n{\n    unsigned int i;\n\n    i = port_id / 32;\n    vser->ports_map[i] |= 1U << (port_id % 32);\n}\n\nstatic void add_port(VirtIOSerial *vser, uint32_t port_id)\n{\n    mark_port_added(vser, port_id);\n    send_control_event(vser, port_id, VIRTIO_CONSOLE_PORT_ADD, 1);\n}\n\nstatic void remove_port(VirtIOSerial *vser, uint32_t port_id)\n{\n    VirtIOSerialPort *port;\n\n    /*\n     * Don't mark port 0 removed -- we explicitly reserve it for\n     * backward compat with older guests, ensure a virtconsole device\n     * unplug retains the reservation.\n     */\n    if (port_id) {\n        unsigned int i;\n\n        i = port_id / 32;\n        vser->ports_map[i] &= ~(1U << (port_id % 32));\n    }\n\n    port = find_port_by_id(vser, port_id);\n    /*\n     * This function is only called from qdev's unplug callback; if we\n     * get a NULL port here, we're in trouble.\n     */\n    assert(port);\n\n    /* Flush out any unconsumed buffers first */\n    discard_vq_data(port->ovq, VIRTIO_DEVICE(port->vser));\n\n    send_control_event(vser, port->id, VIRTIO_CONSOLE_PORT_REMOVE, 1);\n}\n\nstatic void virtser_port_device_realize(DeviceState *dev, Error **errp)\n{\n    VirtIOSerialPort *port = VIRTIO_SERIAL_PORT(dev);\n    VirtIOSerialPortClass *vsc = VIRTIO_SERIAL_PORT_GET_CLASS(port);\n    VirtIOSerialBus *bus = VIRTIO_SERIAL_BUS(qdev_get_parent_bus(dev));\n    int max_nr_ports;\n    bool plugging_port0;\n    Error *err = NULL;\n\n    port->vser = bus->vser;\n    port->bh = qemu_bh_new(flush_queued_data_bh, port);\n\n    assert(vsc->have_data);\n\n    /*\n     * Is the first console port we're seeing? If so, put it up at\n     * location 0. This is done for backward compatibility (old\n     * kernel, new qemu).\n     */\n    plugging_port0 = vsc->is_console && !find_port_by_id(port->vser, 0);\n\n    if (find_port_by_id(port->vser, port->id)) {\n        error_setg(errp, \"virtio-serial-bus: A port already exists at id %u\",\n                   port->id);\n        return;\n    }\n\n    if (port->name != NULL && find_port_by_name(port->name)) {\n        error_setg(errp, \"virtio-serial-bus: A port already exists by name %s\",\n                   port->name);\n        return;\n    }\n\n    if (port->id == VIRTIO_CONSOLE_BAD_ID) {\n        if (plugging_port0) {\n            port->id = 0;\n        } else {\n            port->id = find_free_port_id(port->vser);\n            if (port->id == VIRTIO_CONSOLE_BAD_ID) {\n                error_setg(errp, \"virtio-serial-bus: Maximum port limit for \"\n                                 \"this device reached\");\n                return;\n            }\n        }\n    }\n\n    max_nr_ports = port->vser->serial.max_virtserial_ports;\n    if (port->id >= max_nr_ports) {\n        error_setg(errp, \"virtio-serial-bus: Out-of-range port id specified, \"\n                         \"max. allowed: %u\", max_nr_ports - 1);\n        return;\n    }\n\n    vsc->realize(dev, &err);\n    if (err != NULL) {\n        error_propagate(errp, err);\n        return;\n    }\n\n    port->elem.out_num = 0;\n}\n\nstatic void virtser_port_device_plug(HotplugHandler *hotplug_dev,\n                                     DeviceState *dev, Error **errp)\n{\n    VirtIOSerialPort *port = VIRTIO_SERIAL_PORT(dev);\n\n    QTAILQ_INSERT_TAIL(&port->vser->ports, port, next);\n    port->ivq = port->vser->ivqs[port->id];\n    port->ovq = port->vser->ovqs[port->id];\n\n    add_port(port->vser, port->id);\n\n    /* Send an update to the guest about this new port added */\n    virtio_notify_config(VIRTIO_DEVICE(hotplug_dev));\n}\n\nstatic void virtser_port_device_unrealize(DeviceState *dev, Error **errp)\n{\n    VirtIOSerialPort *port = VIRTIO_SERIAL_PORT(dev);\n    VirtIOSerialPortClass *vsc = VIRTIO_SERIAL_PORT_GET_CLASS(dev);\n    VirtIOSerial *vser = port->vser;\n\n    qemu_bh_delete(port->bh);\n    remove_port(port->vser, port->id);\n\n    QTAILQ_REMOVE(&vser->ports, port, next);\n\n    if (vsc->unrealize) {\n        vsc->unrealize(dev, errp);\n    }\n}\n\nstatic void virtio_serial_device_realize(DeviceState *dev, Error **errp)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n    VirtIOSerial *vser = VIRTIO_SERIAL(dev);\n    uint32_t i, max_supported_ports;\n\n    if (!vser->serial.max_virtserial_ports) {\n        error_setg(errp, \"Maximum number of serial ports not specified\");\n        return;\n    }\n\n    /* Each port takes 2 queues, and one pair is for the control queue */\n    max_supported_ports = VIRTIO_QUEUE_MAX / 2 - 1;\n\n    if (vser->serial.max_virtserial_ports > max_supported_ports) {\n        error_setg(errp, \"maximum ports supported: %u\", max_supported_ports);\n        return;\n    }\n\n    /* We don't support emergency write, skip it for now. */\n    /* TODO: cleaner fix, depending on host features. */\n    virtio_init(vdev, \"virtio-serial\", VIRTIO_ID_CONSOLE,\n                offsetof(struct virtio_console_config, emerg_wr));\n\n    /* Spawn a new virtio-serial bus on which the ports will ride as devices */\n    qbus_create_inplace(&vser->bus, sizeof(vser->bus), TYPE_VIRTIO_SERIAL_BUS,\n                        dev, vdev->bus_name);\n    qbus_set_hotplug_handler(BUS(&vser->bus), DEVICE(vser), errp);\n    vser->bus.vser = vser;\n    QTAILQ_INIT(&vser->ports);\n\n    vser->bus.max_nr_ports = vser->serial.max_virtserial_ports;\n    vser->ivqs = g_malloc(vser->serial.max_virtserial_ports\n                          * sizeof(VirtQueue *));\n    vser->ovqs = g_malloc(vser->serial.max_virtserial_ports\n                          * sizeof(VirtQueue *));\n\n    /* Add a queue for host to guest transfers for port 0 (backward compat) */\n    vser->ivqs[0] = virtio_add_queue(vdev, 128, handle_input);\n    /* Add a queue for guest to host transfers for port 0 (backward compat) */\n    vser->ovqs[0] = virtio_add_queue(vdev, 128, handle_output);\n\n    /* TODO: host to guest notifications can get dropped\n     * if the queue fills up. Implement queueing in host,\n     * this might also make it possible to reduce the control\n     * queue size: as guest preposts buffers there,\n     * this will save 4Kbyte of guest memory per entry. */\n\n    /* control queue: host to guest */\n    vser->c_ivq = virtio_add_queue(vdev, 32, control_in);\n    /* control queue: guest to host */\n    vser->c_ovq = virtio_add_queue(vdev, 32, control_out);\n\n    for (i = 1; i < vser->bus.max_nr_ports; i++) {\n        /* Add a per-port queue for host to guest transfers */\n        vser->ivqs[i] = virtio_add_queue(vdev, 128, handle_input);\n        /* Add a per-per queue for guest to host transfers */\n        vser->ovqs[i] = virtio_add_queue(vdev, 128, handle_output);\n    }\n\n    vser->ports_map = g_malloc0(((vser->serial.max_virtserial_ports + 31) / 32)\n        * sizeof(vser->ports_map[0]));\n    /*\n     * Reserve location 0 for a console port for backward compat\n     * (old kernel, new qemu)\n     */\n    mark_port_added(vser, 0);\n\n    vser->post_load = NULL;\n\n    /*\n     * Register for the savevm section with the virtio-console name\n     * to preserve backward compat\n     */\n    register_savevm(dev, \"virtio-console\", -1, 3, virtio_serial_save,\n                    virtio_serial_load, vser);\n\n    QLIST_INSERT_HEAD(&vserdevices.devices, vser, next);\n}\n\nstatic void virtio_serial_port_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *k = DEVICE_CLASS(klass);\n\n    set_bit(DEVICE_CATEGORY_INPUT, k->categories);\n    k->bus_type = TYPE_VIRTIO_SERIAL_BUS;\n    k->realize = virtser_port_device_realize;\n    k->unrealize = virtser_port_device_unrealize;\n    k->props = virtser_props;\n}\n\nstatic const TypeInfo virtio_serial_port_type_info = {\n    .name = TYPE_VIRTIO_SERIAL_PORT,\n    .parent = TYPE_DEVICE,\n    .instance_size = sizeof(VirtIOSerialPort),\n    .abstract = true,\n    .class_size = sizeof(VirtIOSerialPortClass),\n    .class_init = virtio_serial_port_class_init,\n};\n\nstatic void virtio_serial_device_unrealize(DeviceState *dev, Error **errp)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n    VirtIOSerial *vser = VIRTIO_SERIAL(dev);\n\n    QLIST_REMOVE(vser, next);\n\n    unregister_savevm(dev, \"virtio-console\", vser);\n\n    g_free(vser->ivqs);\n    g_free(vser->ovqs);\n    g_free(vser->ports_map);\n    if (vser->post_load) {\n        g_free(vser->post_load->connected);\n        timer_del(vser->post_load->timer);\n        timer_free(vser->post_load->timer);\n        g_free(vser->post_load);\n    }\n    virtio_cleanup(vdev);\n}\n\nstatic Property virtio_serial_properties[] = {\n    DEFINE_PROP_UINT32(\"max_ports\", VirtIOSerial, serial.max_virtserial_ports,\n                                                  31),\n    DEFINE_PROP_END_OF_LIST(),\n};\n\nstatic void virtio_serial_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(klass);\n\n    QLIST_INIT(&vserdevices.devices);\n\n    dc->props = virtio_serial_properties;\n    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);\n    vdc->realize = virtio_serial_device_realize;\n    vdc->unrealize = virtio_serial_device_unrealize;\n    vdc->get_features = get_features;\n    vdc->get_config = get_config;\n    vdc->set_status = set_status;\n    vdc->reset = vser_reset;\n    vdc->save = virtio_serial_save_device;\n    vdc->load = virtio_serial_load_device;\n    hc->plug = virtser_port_device_plug;\n    hc->unplug = qdev_simple_device_unplug_cb;\n}\n\nstatic const TypeInfo virtio_device_info = {\n    .name = TYPE_VIRTIO_SERIAL,\n    .parent = TYPE_VIRTIO_DEVICE,\n    .instance_size = sizeof(VirtIOSerial),\n    .class_init = virtio_serial_class_init,\n    .interfaces = (InterfaceInfo[]) {\n        { TYPE_HOTPLUG_HANDLER },\n        { }\n    }\n};\n\nstatic void virtio_serial_register_types(void)\n{\n    type_register_static(&virtser_bus_info);\n    type_register_static(&virtio_serial_port_type_info);\n    type_register_static(&virtio_device_info);\n}\n\ntype_init(virtio_serial_register_types)\n"], "fixing_code": ["/*\n * A bus for connecting virtio serial and console ports\n *\n * Copyright (C) 2009, 2010 Red Hat, Inc.\n *\n * Author(s):\n *  Amit Shah <amit.shah@redhat.com>\n *\n * Some earlier parts are:\n *  Copyright IBM, Corp. 2008\n * authored by\n *  Christian Ehrhardt <ehrhardt@linux.vnet.ibm.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n * Contributions after 2012-01-13 are licensed under the terms of the\n * GNU GPL, version 2 or (at your option) any later version.\n */\n\n#include \"qemu/iov.h\"\n#include \"monitor/monitor.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/queue.h\"\n#include \"hw/sysbus.h\"\n#include \"trace.h\"\n#include \"hw/virtio/virtio-serial.h\"\n#include \"hw/virtio/virtio-access.h\"\n\nstatic struct VirtIOSerialDevices {\n    QLIST_HEAD(, VirtIOSerial) devices;\n} vserdevices;\n\nstatic VirtIOSerialPort *find_port_by_id(VirtIOSerial *vser, uint32_t id)\n{\n    VirtIOSerialPort *port;\n\n    if (id == VIRTIO_CONSOLE_BAD_ID) {\n        return NULL;\n    }\n\n    QTAILQ_FOREACH(port, &vser->ports, next) {\n        if (port->id == id)\n            return port;\n    }\n    return NULL;\n}\n\nstatic VirtIOSerialPort *find_port_by_vq(VirtIOSerial *vser, VirtQueue *vq)\n{\n    VirtIOSerialPort *port;\n\n    QTAILQ_FOREACH(port, &vser->ports, next) {\n        if (port->ivq == vq || port->ovq == vq)\n            return port;\n    }\n    return NULL;\n}\n\nstatic VirtIOSerialPort *find_port_by_name(char *name)\n{\n    VirtIOSerial *vser;\n\n    QLIST_FOREACH(vser, &vserdevices.devices, next) {\n        VirtIOSerialPort *port;\n\n        QTAILQ_FOREACH(port, &vser->ports, next) {\n            if (port->name && !strcmp(port->name, name)) {\n                return port;\n            }\n        }\n    }\n    return NULL;\n}\n\nstatic bool use_multiport(VirtIOSerial *vser)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(vser);\n    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);\n}\n\nstatic size_t write_to_port(VirtIOSerialPort *port,\n                            const uint8_t *buf, size_t size)\n{\n    VirtQueueElement elem;\n    VirtQueue *vq;\n    size_t offset;\n\n    vq = port->ivq;\n    if (!virtio_queue_ready(vq)) {\n        return 0;\n    }\n\n    offset = 0;\n    while (offset < size) {\n        size_t len;\n\n        if (!virtqueue_pop(vq, &elem)) {\n            break;\n        }\n\n        len = iov_from_buf(elem.in_sg, elem.in_num, 0,\n                           buf + offset, size - offset);\n        offset += len;\n\n        virtqueue_push(vq, &elem, len);\n    }\n\n    virtio_notify(VIRTIO_DEVICE(port->vser), vq);\n    return offset;\n}\n\nstatic void discard_vq_data(VirtQueue *vq, VirtIODevice *vdev)\n{\n    VirtQueueElement elem;\n\n    if (!virtio_queue_ready(vq)) {\n        return;\n    }\n    while (virtqueue_pop(vq, &elem)) {\n        virtqueue_push(vq, &elem, 0);\n    }\n    virtio_notify(vdev, vq);\n}\n\nstatic void do_flush_queued_data(VirtIOSerialPort *port, VirtQueue *vq,\n                                 VirtIODevice *vdev)\n{\n    VirtIOSerialPortClass *vsc;\n\n    assert(port);\n    assert(virtio_queue_ready(vq));\n\n    vsc = VIRTIO_SERIAL_PORT_GET_CLASS(port);\n\n    while (!port->throttled) {\n        unsigned int i;\n\n        /* Pop an elem only if we haven't left off a previous one mid-way */\n        if (!port->elem.out_num) {\n            if (!virtqueue_pop(vq, &port->elem)) {\n                break;\n            }\n            port->iov_idx = 0;\n            port->iov_offset = 0;\n        }\n\n        for (i = port->iov_idx; i < port->elem.out_num; i++) {\n            size_t buf_size;\n            ssize_t ret;\n\n            buf_size = port->elem.out_sg[i].iov_len - port->iov_offset;\n            ret = vsc->have_data(port,\n                                  port->elem.out_sg[i].iov_base\n                                  + port->iov_offset,\n                                  buf_size);\n            if (port->throttled) {\n                port->iov_idx = i;\n                if (ret > 0) {\n                    port->iov_offset += ret;\n                }\n                break;\n            }\n            port->iov_offset = 0;\n        }\n        if (port->throttled) {\n            break;\n        }\n        virtqueue_push(vq, &port->elem, 0);\n        port->elem.out_num = 0;\n    }\n    virtio_notify(vdev, vq);\n}\n\nstatic void flush_queued_data(VirtIOSerialPort *port)\n{\n    assert(port);\n\n    if (!virtio_queue_ready(port->ovq)) {\n        return;\n    }\n    do_flush_queued_data(port, port->ovq, VIRTIO_DEVICE(port->vser));\n}\n\nstatic size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n{\n    VirtQueueElement elem;\n    VirtQueue *vq;\n\n    vq = vser->c_ivq;\n    if (!virtio_queue_ready(vq)) {\n        return 0;\n    }\n    if (!virtqueue_pop(vq, &elem)) {\n        return 0;\n    }\n\n    /* TODO: detect a buffer that's too short, set NEEDS_RESET */\n    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len);\n\n    virtqueue_push(vq, &elem, len);\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n    return len;\n}\n\nstatic size_t send_control_event(VirtIOSerial *vser, uint32_t port_id,\n                                 uint16_t event, uint16_t value)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(vser);\n    struct virtio_console_control cpkt;\n\n    virtio_stl_p(vdev, &cpkt.id, port_id);\n    virtio_stw_p(vdev, &cpkt.event, event);\n    virtio_stw_p(vdev, &cpkt.value, value);\n\n    trace_virtio_serial_send_control_event(port_id, event, value);\n    return send_control_msg(vser, &cpkt, sizeof(cpkt));\n}\n\n/* Functions for use inside qemu to open and read from/write to ports */\nint virtio_serial_open(VirtIOSerialPort *port)\n{\n    /* Don't allow opening an already-open port */\n    if (port->host_connected) {\n        return 0;\n    }\n    /* Send port open notification to the guest */\n    port->host_connected = true;\n    send_control_event(port->vser, port->id, VIRTIO_CONSOLE_PORT_OPEN, 1);\n\n    return 0;\n}\n\nint virtio_serial_close(VirtIOSerialPort *port)\n{\n    port->host_connected = false;\n    /*\n     * If there's any data the guest sent which the app didn't\n     * consume, reset the throttling flag and discard the data.\n     */\n    port->throttled = false;\n    discard_vq_data(port->ovq, VIRTIO_DEVICE(port->vser));\n\n    send_control_event(port->vser, port->id, VIRTIO_CONSOLE_PORT_OPEN, 0);\n\n    return 0;\n}\n\n/* Individual ports/apps call this function to write to the guest. */\nssize_t virtio_serial_write(VirtIOSerialPort *port, const uint8_t *buf,\n                            size_t size)\n{\n    if (!port || !port->host_connected || !port->guest_connected) {\n        return 0;\n    }\n    return write_to_port(port, buf, size);\n}\n\n/*\n * Readiness of the guest to accept data on a port.\n * Returns max. data the guest can receive\n */\nsize_t virtio_serial_guest_ready(VirtIOSerialPort *port)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(port->vser);\n    VirtQueue *vq = port->ivq;\n    unsigned int bytes;\n\n    if (!virtio_queue_ready(vq) ||\n        !(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK) ||\n        virtio_queue_empty(vq)) {\n        return 0;\n    }\n    if (use_multiport(port->vser) && !port->guest_connected) {\n        return 0;\n    }\n    virtqueue_get_avail_bytes(vq, &bytes, NULL, 4096, 0);\n    return bytes;\n}\n\nstatic void flush_queued_data_bh(void *opaque)\n{\n    VirtIOSerialPort *port = opaque;\n\n    flush_queued_data(port);\n}\n\nvoid virtio_serial_throttle_port(VirtIOSerialPort *port, bool throttle)\n{\n    if (!port) {\n        return;\n    }\n\n    trace_virtio_serial_throttle_port(port->id, throttle);\n    port->throttled = throttle;\n    if (throttle) {\n        return;\n    }\n    qemu_bh_schedule(port->bh);\n}\n\n/* Guest wants to notify us of some event */\nstatic void handle_control_message(VirtIOSerial *vser, void *buf, size_t len)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(vser);\n    struct VirtIOSerialPort *port;\n    VirtIOSerialPortClass *vsc;\n    struct virtio_console_control cpkt, *gcpkt;\n    uint8_t *buffer;\n    size_t buffer_len;\n\n    gcpkt = buf;\n\n    if (len < sizeof(cpkt)) {\n        /* The guest sent an invalid control packet */\n        return;\n    }\n\n    cpkt.event = virtio_lduw_p(vdev, &gcpkt->event);\n    cpkt.value = virtio_lduw_p(vdev, &gcpkt->value);\n\n    trace_virtio_serial_handle_control_message(cpkt.event, cpkt.value);\n\n    if (cpkt.event == VIRTIO_CONSOLE_DEVICE_READY) {\n        if (!cpkt.value) {\n            error_report(\"virtio-serial-bus: Guest failure in adding device %s\",\n                         vser->bus.qbus.name);\n            return;\n        }\n        /*\n         * The device is up, we can now tell the device about all the\n         * ports we have here.\n         */\n        QTAILQ_FOREACH(port, &vser->ports, next) {\n            send_control_event(vser, port->id, VIRTIO_CONSOLE_PORT_ADD, 1);\n        }\n        return;\n    }\n\n    port = find_port_by_id(vser, virtio_ldl_p(vdev, &gcpkt->id));\n    if (!port) {\n        error_report(\"virtio-serial-bus: Unexpected port id %u for device %s\",\n                     virtio_ldl_p(vdev, &gcpkt->id), vser->bus.qbus.name);\n        return;\n    }\n\n    trace_virtio_serial_handle_control_message_port(port->id);\n\n    vsc = VIRTIO_SERIAL_PORT_GET_CLASS(port);\n\n    switch(cpkt.event) {\n    case VIRTIO_CONSOLE_PORT_READY:\n        if (!cpkt.value) {\n            error_report(\"virtio-serial-bus: Guest failure in adding port %u for device %s\",\n                         port->id, vser->bus.qbus.name);\n            break;\n        }\n        /*\n         * Now that we know the guest asked for the port name, we're\n         * sure the guest has initialised whatever state is necessary\n         * for this port. Now's a good time to let the guest know if\n         * this port is a console port so that the guest can hook it\n         * up to hvc.\n         */\n        if (vsc->is_console) {\n            send_control_event(vser, port->id, VIRTIO_CONSOLE_CONSOLE_PORT, 1);\n        }\n\n        if (port->name) {\n            virtio_stl_p(vdev, &cpkt.id, port->id);\n            virtio_stw_p(vdev, &cpkt.event, VIRTIO_CONSOLE_PORT_NAME);\n            virtio_stw_p(vdev, &cpkt.value, 1);\n\n            buffer_len = sizeof(cpkt) + strlen(port->name) + 1;\n            buffer = g_malloc(buffer_len);\n\n            memcpy(buffer, &cpkt, sizeof(cpkt));\n            memcpy(buffer + sizeof(cpkt), port->name, strlen(port->name));\n            buffer[buffer_len - 1] = 0;\n\n            send_control_msg(vser, buffer, buffer_len);\n            g_free(buffer);\n        }\n\n        if (port->host_connected) {\n            send_control_event(vser, port->id, VIRTIO_CONSOLE_PORT_OPEN, 1);\n        }\n\n        /*\n         * When the guest has asked us for this information it means\n         * the guest is all setup and has its virtqueues\n         * initialised. If some app is interested in knowing about\n         * this event, let it know.\n         */\n        if (vsc->guest_ready) {\n            vsc->guest_ready(port);\n        }\n        break;\n\n    case VIRTIO_CONSOLE_PORT_OPEN:\n        port->guest_connected = cpkt.value;\n        if (vsc->set_guest_connected) {\n            /* Send the guest opened notification if an app is interested */\n            vsc->set_guest_connected(port, cpkt.value);\n        }\n        break;\n    }\n}\n\nstatic void control_in(VirtIODevice *vdev, VirtQueue *vq)\n{\n}\n\nstatic void control_out(VirtIODevice *vdev, VirtQueue *vq)\n{\n    VirtQueueElement elem;\n    VirtIOSerial *vser;\n    uint8_t *buf;\n    size_t len;\n\n    vser = VIRTIO_SERIAL(vdev);\n\n    len = 0;\n    buf = NULL;\n    while (virtqueue_pop(vq, &elem)) {\n        size_t cur_len;\n\n        cur_len = iov_size(elem.out_sg, elem.out_num);\n        /*\n         * Allocate a new buf only if we didn't have one previously or\n         * if the size of the buf differs\n         */\n        if (cur_len > len) {\n            g_free(buf);\n\n            buf = g_malloc(cur_len);\n            len = cur_len;\n        }\n        iov_to_buf(elem.out_sg, elem.out_num, 0, buf, cur_len);\n\n        handle_control_message(vser, buf, cur_len);\n        virtqueue_push(vq, &elem, 0);\n    }\n    g_free(buf);\n    virtio_notify(vdev, vq);\n}\n\n/* Guest wrote something to some port. */\nstatic void handle_output(VirtIODevice *vdev, VirtQueue *vq)\n{\n    VirtIOSerial *vser;\n    VirtIOSerialPort *port;\n\n    vser = VIRTIO_SERIAL(vdev);\n    port = find_port_by_vq(vser, vq);\n\n    if (!port || !port->host_connected) {\n        discard_vq_data(vq, vdev);\n        return;\n    }\n\n    if (!port->throttled) {\n        do_flush_queued_data(port, vq, vdev);\n        return;\n    }\n}\n\nstatic void handle_input(VirtIODevice *vdev, VirtQueue *vq)\n{\n    /*\n     * Users of virtio-serial would like to know when guest becomes\n     * writable again -- i.e. if a vq had stuff queued up and the\n     * guest wasn't reading at all, the host would not be able to\n     * write to the vq anymore.  Once the guest reads off something,\n     * we can start queueing things up again.  However, this call is\n     * made for each buffer addition by the guest -- even though free\n     * buffers existed prior to the current buffer addition.  This is\n     * done so as not to maintain previous state, which will need\n     * additional live-migration-related changes.\n     */\n    VirtIOSerial *vser;\n    VirtIOSerialPort *port;\n    VirtIOSerialPortClass *vsc;\n\n    vser = VIRTIO_SERIAL(vdev);\n    port = find_port_by_vq(vser, vq);\n\n    if (!port) {\n        return;\n    }\n    vsc = VIRTIO_SERIAL_PORT_GET_CLASS(port);\n\n    /*\n     * If guest_connected is false, this call is being made by the\n     * early-boot queueing up of descriptors, which is just noise for\n     * the host apps -- don't disturb them in that case.\n     */\n    if (port->guest_connected && port->host_connected && vsc->guest_writable) {\n        vsc->guest_writable(port);\n    }\n}\n\nstatic uint64_t get_features(VirtIODevice *vdev, uint64_t features)\n{\n    VirtIOSerial *vser;\n\n    vser = VIRTIO_SERIAL(vdev);\n\n    if (vser->bus.max_nr_ports > 1) {\n        virtio_add_feature(&features, VIRTIO_CONSOLE_F_MULTIPORT);\n    }\n    return features;\n}\n\n/* Guest requested config info */\nstatic void get_config(VirtIODevice *vdev, uint8_t *config_data)\n{\n    VirtIOSerial *vser = VIRTIO_SERIAL(vdev);\n    struct virtio_console_config *config =\n        (struct virtio_console_config *)config_data;\n\n    config->cols = 0;\n    config->rows = 0;\n    config->max_nr_ports = virtio_tswap32(vdev,\n                                          vser->serial.max_virtserial_ports);\n}\n\nstatic void guest_reset(VirtIOSerial *vser)\n{\n    VirtIOSerialPort *port;\n    VirtIOSerialPortClass *vsc;\n\n    QTAILQ_FOREACH(port, &vser->ports, next) {\n        vsc = VIRTIO_SERIAL_PORT_GET_CLASS(port);\n        if (port->guest_connected) {\n            port->guest_connected = false;\n            if (vsc->set_guest_connected) {\n                vsc->set_guest_connected(port, false);\n            }\n        }\n    }\n}\n\nstatic void set_status(VirtIODevice *vdev, uint8_t status)\n{\n    VirtIOSerial *vser;\n    VirtIOSerialPort *port;\n\n    vser = VIRTIO_SERIAL(vdev);\n    port = find_port_by_id(vser, 0);\n\n    if (port && !use_multiport(port->vser)\n        && (status & VIRTIO_CONFIG_S_DRIVER_OK)) {\n        /*\n         * Non-multiport guests won't be able to tell us guest\n         * open/close status.  Such guests can only have a port at id\n         * 0, so set guest_connected for such ports as soon as guest\n         * is up.\n         */\n        port->guest_connected = true;\n    }\n    if (!(status & VIRTIO_CONFIG_S_DRIVER_OK)) {\n        guest_reset(vser);\n    }\n}\n\nstatic void vser_reset(VirtIODevice *vdev)\n{\n    VirtIOSerial *vser;\n\n    vser = VIRTIO_SERIAL(vdev);\n    guest_reset(vser);\n}\n\nstatic void virtio_serial_save(QEMUFile *f, void *opaque)\n{\n    /* The virtio device */\n    virtio_save(VIRTIO_DEVICE(opaque), f);\n}\n\nstatic void virtio_serial_save_device(VirtIODevice *vdev, QEMUFile *f)\n{\n    VirtIOSerial *s = VIRTIO_SERIAL(vdev);\n    VirtIOSerialPort *port;\n    uint32_t nr_active_ports;\n    unsigned int i, max_nr_ports;\n    struct virtio_console_config config;\n\n    /* The config space (ignored on the far end in current versions) */\n    get_config(vdev, (uint8_t *)&config);\n    qemu_put_be16s(f, &config.cols);\n    qemu_put_be16s(f, &config.rows);\n    qemu_put_be32s(f, &config.max_nr_ports);\n\n    /* The ports map */\n    max_nr_ports = s->serial.max_virtserial_ports;\n    for (i = 0; i < (max_nr_ports + 31) / 32; i++) {\n        qemu_put_be32s(f, &s->ports_map[i]);\n    }\n\n    /* Ports */\n\n    nr_active_ports = 0;\n    QTAILQ_FOREACH(port, &s->ports, next) {\n        nr_active_ports++;\n    }\n\n    qemu_put_be32s(f, &nr_active_ports);\n\n    /*\n     * Items in struct VirtIOSerialPort.\n     */\n    QTAILQ_FOREACH(port, &s->ports, next) {\n        uint32_t elem_popped;\n\n        qemu_put_be32s(f, &port->id);\n        qemu_put_byte(f, port->guest_connected);\n        qemu_put_byte(f, port->host_connected);\n\n\telem_popped = 0;\n        if (port->elem.out_num) {\n            elem_popped = 1;\n        }\n        qemu_put_be32s(f, &elem_popped);\n        if (elem_popped) {\n            qemu_put_be32s(f, &port->iov_idx);\n            qemu_put_be64s(f, &port->iov_offset);\n\n            qemu_put_buffer(f, (unsigned char *)&port->elem,\n                            sizeof(port->elem));\n        }\n    }\n}\n\nstatic void virtio_serial_post_load_timer_cb(void *opaque)\n{\n    uint32_t i;\n    VirtIOSerial *s = VIRTIO_SERIAL(opaque);\n    VirtIOSerialPort *port;\n    uint8_t host_connected;\n    VirtIOSerialPortClass *vsc;\n\n    if (!s->post_load) {\n        return;\n    }\n    for (i = 0 ; i < s->post_load->nr_active_ports; ++i) {\n        port = s->post_load->connected[i].port;\n        host_connected = s->post_load->connected[i].host_connected;\n        if (host_connected != port->host_connected) {\n            /*\n             * We have to let the guest know of the host connection\n             * status change\n             */\n            send_control_event(s, port->id, VIRTIO_CONSOLE_PORT_OPEN,\n                               port->host_connected);\n        }\n        vsc = VIRTIO_SERIAL_PORT_GET_CLASS(port);\n        if (vsc->set_guest_connected) {\n            vsc->set_guest_connected(port, port->guest_connected);\n        }\n    }\n    g_free(s->post_load->connected);\n    timer_free(s->post_load->timer);\n    g_free(s->post_load);\n    s->post_load = NULL;\n}\n\nstatic int fetch_active_ports_list(QEMUFile *f, int version_id,\n                                   VirtIOSerial *s, uint32_t nr_active_ports)\n{\n    uint32_t i;\n\n    s->post_load = g_malloc0(sizeof(*s->post_load));\n    s->post_load->nr_active_ports = nr_active_ports;\n    s->post_load->connected =\n        g_malloc0(sizeof(*s->post_load->connected) * nr_active_ports);\n\n    s->post_load->timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n                                            virtio_serial_post_load_timer_cb,\n                                            s);\n\n    /* Items in struct VirtIOSerialPort */\n    for (i = 0; i < nr_active_ports; i++) {\n        VirtIOSerialPort *port;\n        uint32_t id;\n\n        id = qemu_get_be32(f);\n        port = find_port_by_id(s, id);\n        if (!port) {\n            return -EINVAL;\n        }\n\n        port->guest_connected = qemu_get_byte(f);\n        s->post_load->connected[i].port = port;\n        s->post_load->connected[i].host_connected = qemu_get_byte(f);\n\n        if (version_id > 2) {\n            uint32_t elem_popped;\n\n            qemu_get_be32s(f, &elem_popped);\n            if (elem_popped) {\n                qemu_get_be32s(f, &port->iov_idx);\n                qemu_get_be64s(f, &port->iov_offset);\n\n                qemu_get_buffer(f, (unsigned char *)&port->elem,\n                                sizeof(port->elem));\n                virtqueue_map_sg(port->elem.in_sg, port->elem.in_addr,\n                                 port->elem.in_num, 1);\n                virtqueue_map_sg(port->elem.out_sg, port->elem.out_addr,\n                                 port->elem.out_num, 1);\n\n                /*\n                 *  Port was throttled on source machine.  Let's\n                 *  unthrottle it here so data starts flowing again.\n                 */\n                virtio_serial_throttle_port(port, false);\n            }\n        }\n    }\n    timer_mod(s->post_load->timer, 1);\n    return 0;\n}\n\nstatic int virtio_serial_load(QEMUFile *f, void *opaque, int version_id)\n{\n    if (version_id > 3) {\n        return -EINVAL;\n    }\n\n    /* The virtio device */\n    return virtio_load(VIRTIO_DEVICE(opaque), f, version_id);\n}\n\nstatic int virtio_serial_load_device(VirtIODevice *vdev, QEMUFile *f,\n                                     int version_id)\n{\n    VirtIOSerial *s = VIRTIO_SERIAL(vdev);\n    uint32_t max_nr_ports, nr_active_ports, ports_map;\n    unsigned int i;\n    int ret;\n    uint32_t tmp;\n\n    if (version_id < 2) {\n        return 0;\n    }\n\n    /* Unused */\n    qemu_get_be16s(f, (uint16_t *) &tmp);\n    qemu_get_be16s(f, (uint16_t *) &tmp);\n    qemu_get_be32s(f, &tmp);\n\n    max_nr_ports = s->serial.max_virtserial_ports;\n    for (i = 0; i < (max_nr_ports + 31) / 32; i++) {\n        qemu_get_be32s(f, &ports_map);\n\n        if (ports_map != s->ports_map[i]) {\n            /*\n             * Ports active on source and destination don't\n             * match. Fail migration.\n             */\n            return -EINVAL;\n        }\n    }\n\n    qemu_get_be32s(f, &nr_active_ports);\n\n    if (nr_active_ports) {\n        ret = fetch_active_ports_list(f, version_id, s, nr_active_ports);\n        if (ret) {\n            return ret;\n        }\n    }\n    return 0;\n}\n\nstatic void virtser_bus_dev_print(Monitor *mon, DeviceState *qdev, int indent);\n\nstatic Property virtser_props[] = {\n    DEFINE_PROP_UINT32(\"nr\", VirtIOSerialPort, id, VIRTIO_CONSOLE_BAD_ID),\n    DEFINE_PROP_STRING(\"name\", VirtIOSerialPort, name),\n    DEFINE_PROP_END_OF_LIST()\n};\n\n#define TYPE_VIRTIO_SERIAL_BUS \"virtio-serial-bus\"\n#define VIRTIO_SERIAL_BUS(obj) \\\n      OBJECT_CHECK(VirtIOSerialBus, (obj), TYPE_VIRTIO_SERIAL_BUS)\n\nstatic void virtser_bus_class_init(ObjectClass *klass, void *data)\n{\n    BusClass *k = BUS_CLASS(klass);\n    k->print_dev = virtser_bus_dev_print;\n}\n\nstatic const TypeInfo virtser_bus_info = {\n    .name = TYPE_VIRTIO_SERIAL_BUS,\n    .parent = TYPE_BUS,\n    .instance_size = sizeof(VirtIOSerialBus),\n    .class_init = virtser_bus_class_init,\n};\n\nstatic void virtser_bus_dev_print(Monitor *mon, DeviceState *qdev, int indent)\n{\n    VirtIOSerialPort *port = DO_UPCAST(VirtIOSerialPort, dev, qdev);\n\n    monitor_printf(mon, \"%*sport %d, guest %s, host %s, throttle %s\\n\",\n                   indent, \"\", port->id,\n                   port->guest_connected ? \"on\" : \"off\",\n                   port->host_connected ? \"on\" : \"off\",\n                   port->throttled ? \"on\" : \"off\");\n}\n\n/* This function is only used if a port id is not provided by the user */\nstatic uint32_t find_free_port_id(VirtIOSerial *vser)\n{\n    unsigned int i, max_nr_ports;\n\n    max_nr_ports = vser->serial.max_virtserial_ports;\n    for (i = 0; i < (max_nr_ports + 31) / 32; i++) {\n        uint32_t map, zeroes;\n\n        map = vser->ports_map[i];\n        zeroes = ctz32(~map);\n        if (zeroes != 32) {\n            return zeroes + i * 32;\n        }\n    }\n    return VIRTIO_CONSOLE_BAD_ID;\n}\n\nstatic void mark_port_added(VirtIOSerial *vser, uint32_t port_id)\n{\n    unsigned int i;\n\n    i = port_id / 32;\n    vser->ports_map[i] |= 1U << (port_id % 32);\n}\n\nstatic void add_port(VirtIOSerial *vser, uint32_t port_id)\n{\n    mark_port_added(vser, port_id);\n    send_control_event(vser, port_id, VIRTIO_CONSOLE_PORT_ADD, 1);\n}\n\nstatic void remove_port(VirtIOSerial *vser, uint32_t port_id)\n{\n    VirtIOSerialPort *port;\n\n    /*\n     * Don't mark port 0 removed -- we explicitly reserve it for\n     * backward compat with older guests, ensure a virtconsole device\n     * unplug retains the reservation.\n     */\n    if (port_id) {\n        unsigned int i;\n\n        i = port_id / 32;\n        vser->ports_map[i] &= ~(1U << (port_id % 32));\n    }\n\n    port = find_port_by_id(vser, port_id);\n    /*\n     * This function is only called from qdev's unplug callback; if we\n     * get a NULL port here, we're in trouble.\n     */\n    assert(port);\n\n    /* Flush out any unconsumed buffers first */\n    discard_vq_data(port->ovq, VIRTIO_DEVICE(port->vser));\n\n    send_control_event(vser, port->id, VIRTIO_CONSOLE_PORT_REMOVE, 1);\n}\n\nstatic void virtser_port_device_realize(DeviceState *dev, Error **errp)\n{\n    VirtIOSerialPort *port = VIRTIO_SERIAL_PORT(dev);\n    VirtIOSerialPortClass *vsc = VIRTIO_SERIAL_PORT_GET_CLASS(port);\n    VirtIOSerialBus *bus = VIRTIO_SERIAL_BUS(qdev_get_parent_bus(dev));\n    int max_nr_ports;\n    bool plugging_port0;\n    Error *err = NULL;\n\n    port->vser = bus->vser;\n    port->bh = qemu_bh_new(flush_queued_data_bh, port);\n\n    assert(vsc->have_data);\n\n    /*\n     * Is the first console port we're seeing? If so, put it up at\n     * location 0. This is done for backward compatibility (old\n     * kernel, new qemu).\n     */\n    plugging_port0 = vsc->is_console && !find_port_by_id(port->vser, 0);\n\n    if (find_port_by_id(port->vser, port->id)) {\n        error_setg(errp, \"virtio-serial-bus: A port already exists at id %u\",\n                   port->id);\n        return;\n    }\n\n    if (port->name != NULL && find_port_by_name(port->name)) {\n        error_setg(errp, \"virtio-serial-bus: A port already exists by name %s\",\n                   port->name);\n        return;\n    }\n\n    if (port->id == VIRTIO_CONSOLE_BAD_ID) {\n        if (plugging_port0) {\n            port->id = 0;\n        } else {\n            port->id = find_free_port_id(port->vser);\n            if (port->id == VIRTIO_CONSOLE_BAD_ID) {\n                error_setg(errp, \"virtio-serial-bus: Maximum port limit for \"\n                                 \"this device reached\");\n                return;\n            }\n        }\n    }\n\n    max_nr_ports = port->vser->serial.max_virtserial_ports;\n    if (port->id >= max_nr_ports) {\n        error_setg(errp, \"virtio-serial-bus: Out-of-range port id specified, \"\n                         \"max. allowed: %u\", max_nr_ports - 1);\n        return;\n    }\n\n    vsc->realize(dev, &err);\n    if (err != NULL) {\n        error_propagate(errp, err);\n        return;\n    }\n\n    port->elem.out_num = 0;\n}\n\nstatic void virtser_port_device_plug(HotplugHandler *hotplug_dev,\n                                     DeviceState *dev, Error **errp)\n{\n    VirtIOSerialPort *port = VIRTIO_SERIAL_PORT(dev);\n\n    QTAILQ_INSERT_TAIL(&port->vser->ports, port, next);\n    port->ivq = port->vser->ivqs[port->id];\n    port->ovq = port->vser->ovqs[port->id];\n\n    add_port(port->vser, port->id);\n\n    /* Send an update to the guest about this new port added */\n    virtio_notify_config(VIRTIO_DEVICE(hotplug_dev));\n}\n\nstatic void virtser_port_device_unrealize(DeviceState *dev, Error **errp)\n{\n    VirtIOSerialPort *port = VIRTIO_SERIAL_PORT(dev);\n    VirtIOSerialPortClass *vsc = VIRTIO_SERIAL_PORT_GET_CLASS(dev);\n    VirtIOSerial *vser = port->vser;\n\n    qemu_bh_delete(port->bh);\n    remove_port(port->vser, port->id);\n\n    QTAILQ_REMOVE(&vser->ports, port, next);\n\n    if (vsc->unrealize) {\n        vsc->unrealize(dev, errp);\n    }\n}\n\nstatic void virtio_serial_device_realize(DeviceState *dev, Error **errp)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n    VirtIOSerial *vser = VIRTIO_SERIAL(dev);\n    uint32_t i, max_supported_ports;\n\n    if (!vser->serial.max_virtserial_ports) {\n        error_setg(errp, \"Maximum number of serial ports not specified\");\n        return;\n    }\n\n    /* Each port takes 2 queues, and one pair is for the control queue */\n    max_supported_ports = VIRTIO_QUEUE_MAX / 2 - 1;\n\n    if (vser->serial.max_virtserial_ports > max_supported_ports) {\n        error_setg(errp, \"maximum ports supported: %u\", max_supported_ports);\n        return;\n    }\n\n    /* We don't support emergency write, skip it for now. */\n    /* TODO: cleaner fix, depending on host features. */\n    virtio_init(vdev, \"virtio-serial\", VIRTIO_ID_CONSOLE,\n                offsetof(struct virtio_console_config, emerg_wr));\n\n    /* Spawn a new virtio-serial bus on which the ports will ride as devices */\n    qbus_create_inplace(&vser->bus, sizeof(vser->bus), TYPE_VIRTIO_SERIAL_BUS,\n                        dev, vdev->bus_name);\n    qbus_set_hotplug_handler(BUS(&vser->bus), DEVICE(vser), errp);\n    vser->bus.vser = vser;\n    QTAILQ_INIT(&vser->ports);\n\n    vser->bus.max_nr_ports = vser->serial.max_virtserial_ports;\n    vser->ivqs = g_malloc(vser->serial.max_virtserial_ports\n                          * sizeof(VirtQueue *));\n    vser->ovqs = g_malloc(vser->serial.max_virtserial_ports\n                          * sizeof(VirtQueue *));\n\n    /* Add a queue for host to guest transfers for port 0 (backward compat) */\n    vser->ivqs[0] = virtio_add_queue(vdev, 128, handle_input);\n    /* Add a queue for guest to host transfers for port 0 (backward compat) */\n    vser->ovqs[0] = virtio_add_queue(vdev, 128, handle_output);\n\n    /* TODO: host to guest notifications can get dropped\n     * if the queue fills up. Implement queueing in host,\n     * this might also make it possible to reduce the control\n     * queue size: as guest preposts buffers there,\n     * this will save 4Kbyte of guest memory per entry. */\n\n    /* control queue: host to guest */\n    vser->c_ivq = virtio_add_queue(vdev, 32, control_in);\n    /* control queue: guest to host */\n    vser->c_ovq = virtio_add_queue(vdev, 32, control_out);\n\n    for (i = 1; i < vser->bus.max_nr_ports; i++) {\n        /* Add a per-port queue for host to guest transfers */\n        vser->ivqs[i] = virtio_add_queue(vdev, 128, handle_input);\n        /* Add a per-per queue for guest to host transfers */\n        vser->ovqs[i] = virtio_add_queue(vdev, 128, handle_output);\n    }\n\n    vser->ports_map = g_malloc0(((vser->serial.max_virtserial_ports + 31) / 32)\n        * sizeof(vser->ports_map[0]));\n    /*\n     * Reserve location 0 for a console port for backward compat\n     * (old kernel, new qemu)\n     */\n    mark_port_added(vser, 0);\n\n    vser->post_load = NULL;\n\n    /*\n     * Register for the savevm section with the virtio-console name\n     * to preserve backward compat\n     */\n    register_savevm(dev, \"virtio-console\", -1, 3, virtio_serial_save,\n                    virtio_serial_load, vser);\n\n    QLIST_INSERT_HEAD(&vserdevices.devices, vser, next);\n}\n\nstatic void virtio_serial_port_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *k = DEVICE_CLASS(klass);\n\n    set_bit(DEVICE_CATEGORY_INPUT, k->categories);\n    k->bus_type = TYPE_VIRTIO_SERIAL_BUS;\n    k->realize = virtser_port_device_realize;\n    k->unrealize = virtser_port_device_unrealize;\n    k->props = virtser_props;\n}\n\nstatic const TypeInfo virtio_serial_port_type_info = {\n    .name = TYPE_VIRTIO_SERIAL_PORT,\n    .parent = TYPE_DEVICE,\n    .instance_size = sizeof(VirtIOSerialPort),\n    .abstract = true,\n    .class_size = sizeof(VirtIOSerialPortClass),\n    .class_init = virtio_serial_port_class_init,\n};\n\nstatic void virtio_serial_device_unrealize(DeviceState *dev, Error **errp)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n    VirtIOSerial *vser = VIRTIO_SERIAL(dev);\n\n    QLIST_REMOVE(vser, next);\n\n    unregister_savevm(dev, \"virtio-console\", vser);\n\n    g_free(vser->ivqs);\n    g_free(vser->ovqs);\n    g_free(vser->ports_map);\n    if (vser->post_load) {\n        g_free(vser->post_load->connected);\n        timer_del(vser->post_load->timer);\n        timer_free(vser->post_load->timer);\n        g_free(vser->post_load);\n    }\n    virtio_cleanup(vdev);\n}\n\nstatic Property virtio_serial_properties[] = {\n    DEFINE_PROP_UINT32(\"max_ports\", VirtIOSerial, serial.max_virtserial_ports,\n                                                  31),\n    DEFINE_PROP_END_OF_LIST(),\n};\n\nstatic void virtio_serial_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(klass);\n\n    QLIST_INIT(&vserdevices.devices);\n\n    dc->props = virtio_serial_properties;\n    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);\n    vdc->realize = virtio_serial_device_realize;\n    vdc->unrealize = virtio_serial_device_unrealize;\n    vdc->get_features = get_features;\n    vdc->get_config = get_config;\n    vdc->set_status = set_status;\n    vdc->reset = vser_reset;\n    vdc->save = virtio_serial_save_device;\n    vdc->load = virtio_serial_load_device;\n    hc->plug = virtser_port_device_plug;\n    hc->unplug = qdev_simple_device_unplug_cb;\n}\n\nstatic const TypeInfo virtio_device_info = {\n    .name = TYPE_VIRTIO_SERIAL,\n    .parent = TYPE_VIRTIO_DEVICE,\n    .instance_size = sizeof(VirtIOSerial),\n    .class_init = virtio_serial_class_init,\n    .interfaces = (InterfaceInfo[]) {\n        { TYPE_HOTPLUG_HANDLER },\n        { }\n    }\n};\n\nstatic void virtio_serial_register_types(void)\n{\n    type_register_static(&virtser_bus_info);\n    type_register_static(&virtio_serial_port_type_info);\n    type_register_static(&virtio_device_info);\n}\n\ntype_init(virtio_serial_register_types)\n"], "filenames": ["hw/char/virtio-serial-bus.c"], "buggy_code_start_loc": [198], "buggy_code_end_loc": [199], "fixing_code_start_loc": [198], "fixing_code_end_loc": [200], "type": "CWE-120", "message": "Buffer overflow in the send_control_msg function in hw/char/virtio-serial-bus.c in QEMU before 2.4.0 allows guest users to cause a denial of service (QEMU process crash) via a crafted virtio control message.", "other": {"cve": {"id": "CVE-2015-5745", "sourceIdentifier": "secalert@redhat.com", "published": "2020-01-23T20:15:12.090", "lastModified": "2022-02-20T06:45:02.027", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Buffer overflow in the send_control_msg function in hw/char/virtio-serial-bus.c in QEMU before 2.4.0 allows guest users to cause a denial of service (QEMU process crash) via a crafted virtio control message."}, {"lang": "es", "value": "Un desbordamiento del b\u00fafer en la funci\u00f3n send_control_msg en el archivo hw/char/virtio-serial-bus.c en QEMU versiones anteriores a 2.4.0, permite a usuarios invitados causar una denegaci\u00f3n de servicio (bloqueo del proceso de QEMU) por medio de un mensaje de control de virtio dise\u00f1ado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:qemu:qemu:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.4.0", "matchCriteriaId": "2047404E-2637-46D0-980C-ABEE8D3453C4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:21:*:*:*:*:*:*:*", "matchCriteriaId": "56BDB5A0-0839-4A20-A003-B8CD56F48171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:22:*:*:*:*:*:*:*", "matchCriteriaId": "253C303A-E577-4488-93E6-68A8DD942C38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:23:*:*:*:*:*:*:*", "matchCriteriaId": "E79AB8DD-C907-4038-A931-1A5A4CFB6A5B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:arista:eos:4.12:*:*:*:*:*:*:*", "matchCriteriaId": "FDDF9823-D999-41A4-BB7B-A63C00ACE11B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:arista:eos:4.13:*:*:*:*:*:*:*", "matchCriteriaId": "51F7426A-46F7-4BE0-806F-F4598C8B0426"}, {"vulnerable": true, "criteria": "cpe:2.3:o:arista:eos:4.14:*:*:*:*:*:*:*", "matchCriteriaId": "E7F71EBA-27AC-464B-8708-4E8971BC75A7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:arista:eos:4.15:*:*:*:*:*:*:*", "matchCriteriaId": "8705CF80-DEFC-4425-8E23-D98FFD678157"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-October/168077.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-October/168646.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-October/168671.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/08/06/3", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/08/06/5", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/qemu/qemu/commit/7882080388be5088e72c425b02223c02e6cb4295", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.gnu.org/archive/html/qemu-devel/2015-07/msg05458.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://www.arista.com/en/support/advisories-notices/security-advisories/1180-security-advisory-13", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/qemu/qemu/commit/7882080388be5088e72c425b02223c02e6cb4295"}}