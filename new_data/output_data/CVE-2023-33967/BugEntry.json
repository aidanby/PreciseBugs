{"buggy_code": ["/*\n * Copyright (c) 2022, MegaEase\n * All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage global\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\tlog \"github.com/sirupsen/logrus\"\n\t\"golang.org/x/exp/constraints\"\n)\n\nconst (\n\t// Org is the organization\n\tOrg = \"MegaEase\"\n\t// DefaultProg is the program name\n\tDefaultProg = \"EaseProbe\"\n\t// DefaultIconURL is the default icon which used in Slack or Discord\n\tDefaultIconURL = \"https://megaease.com/favicon.png\"\n)\n\nvar (\n\t// Ver is the program version\n\t// It will be set by the build script\n\t// go build -ldflags \"-X github.com/megaease/easegress/pkg/global.Ver=1.0.0\"\n\tVer = \"v1.7.0\"\n\t//OrgProg combine organization and program\n\tOrgProg = Org + \" \" + DefaultProg\n\t//OrgProgVer combine organization and program and version\n\tOrgProgVer = Org + \" \" + DefaultProg + \"/\" + Ver\n)\n\nconst (\n\t// DefaultRetryTimes is 3 times\n\tDefaultRetryTimes = 3\n\t// DefaultRetryInterval is 5 seconds\n\tDefaultRetryInterval = time.Second * 5\n\t// DefaultTimeFormat is \"2006-01-02 15:04:05 Z0700\"\n\tDefaultTimeFormat = \"2006-01-02 15:04:05 Z0700\"\n\t// DefaultTimeZone is \"UTC\"\n\tDefaultTimeZone = \"UTC\"\n\t// DefaultProbeInterval is 1 minutes\n\tDefaultProbeInterval = time.Second * 60\n\t// DefaultTimeOut is 30 seconds\n\tDefaultTimeOut = time.Second * 30\n\t// DefaultChannelName  is the default wide channel name\n\tDefaultChannelName = \"__EaseProbe_Channel__\"\n\t// DefaultStatusChangeThresholdSetting is the threshold of status change\n\tDefaultStatusChangeThresholdSetting = 1\n\t// DefaultNotificationStrategy is the default notify strategy\n\tDefaultNotificationStrategy = RegularStrategy\n\t// DefaultMaxNotificationTimes is the default max notification times\n\tDefaultMaxNotificationTimes = 1\n\t// DefaultNotificationFactor is the default notification factor\n\tDefaultNotificationFactor = 1\n)\n\nconst (\n\t// DefaultHTTPServerIP is the default ip of the HTTP server\n\tDefaultHTTPServerIP = \"0.0.0.0\"\n\t// DefaultHTTPServerPort is the default port of the HTTP server\n\tDefaultHTTPServerPort = \"8181\"\n\t// DefaultPageSize is the default page size\n\tDefaultPageSize = 100\n\t// DefaultAccessLogFile is the default access log file name\n\tDefaultAccessLogFile = \"access.log\"\n\t// DefaultDataFile is the default data file name\n\tDefaultDataFile = \"data/data.yaml\"\n\t// DefaultPIDFile is the default pid file name\n\tDefaultPIDFile = \"easeprobe.pid\"\n)\n\nconst (\n\t// DefaultMaxLogSize is the default max log size\n\tDefaultMaxLogSize = 10 // 10M\n\t// DefaultMaxLogAge is the default max log age\n\tDefaultMaxLogAge = 7 // 7 days\n\t// DefaultMaxBackups is the default backup file number\n\tDefaultMaxBackups = 5 // file\n\t// DefaultLogCompress is the default compress log\n\tDefaultLogCompress = true\n)\n\n// Retry is the settings of retry\ntype Retry struct {\n\tTimes    int           `yaml:\"times\" json:\"times,omitempty\" jsonschema:\"title=Retry Times,description=how many times need to retry,minimum=1\"`\n\tInterval time.Duration `yaml:\"interval\" json:\"interval,omitempty\" jsonschema:\"type=string,format=duration,title=Retry Interval,description=the interval between each retry\"`\n}\n\n// TLS is the configuration for TLS files\ntype TLS struct {\n\tCA       string `yaml:\"ca\" json:\"ca,omitempty\" jsonschema:\"title=CA File,description=the CA file path\"`\n\tCert     string `yaml:\"cert\" json:\"cert,omitempty\" jsonschema:\"title=Cert File,description=the Cert file path\"`\n\tKey      string `yaml:\"key\" json:\"key,omitempty\" jsonschema:\"title=Key File,description=the Key file path\"`\n\tInsecure bool   `yaml:\"insecure\" json:\"insecure,omitempty\" jsonschema:\"title=Insecure,description=whether to skip the TLS verification\"`\n}\n\n// The normalize() function logic as below:\n// - if both global and local are not set, then return the _default.\n// - if set the global, but not the local, then return the global\n// - if set the local, but not the global, then return the local\n// - if both global and local are set, then return the local\nfunc normalize[T constraints.Ordered](global, local, valid, _default T) T {\n\t// if the val is invalid, then assign the default value\n\tif local <= valid {\n\t\tlocal = _default\n\t\t//if the global configuration is validated, assign the global\n\t\tif global > valid {\n\t\t\tlocal = global\n\t\t}\n\t}\n\treturn local\n}\n\n// ReverseMap just reverse the map from [key, value] to [value, key]\nfunc ReverseMap[K comparable, V comparable](m map[K]V) map[V]K {\n\tn := make(map[V]K, len(m))\n\tfor k, v := range m {\n\t\tn[v] = k\n\t}\n\treturn n\n}\n\n// EnumMarshalYaml is a help function to marshal the enum to yaml\nfunc EnumMarshalYaml[T comparable](m map[T]string, v T, typename string) (interface{}, error) {\n\tif val, ok := m[v]; ok {\n\t\treturn val, nil\n\t}\n\treturn nil, fmt.Errorf(\"%v is not a valid %s\", v, typename)\n}\n\n// EnumMarshalJSON is a help function to marshal the enum to JSON\nfunc EnumMarshalJSON[T comparable](m map[T]string, v T, typename string) ([]byte, error) {\n\tif val, ok := m[v]; ok {\n\t\treturn []byte(fmt.Sprintf(`\"%s\"`, val)), nil\n\t}\n\treturn nil, fmt.Errorf(\"%v is not a valid %s\", v, typename)\n}\n\n// EnumUnmarshalYaml is a help function to unmarshal the enum from yaml\nfunc EnumUnmarshalYaml[T comparable](unmarshal func(interface{}) error, m map[string]T, v *T, init T, typename string) error {\n\tvar str string\n\t*v = init\n\tif err := unmarshal(&str); err != nil {\n\t\treturn err\n\t}\n\tif val, ok := m[strings.ToLower(str)]; ok {\n\t\t*v = val\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"%v is not a valid %s\", str, typename)\n}\n\n// EnumUnmarshalJSON is a help function to unmarshal the enum from JSON\nfunc EnumUnmarshalJSON[T comparable](b []byte, m map[string]T, v *T, init T, typename string) error {\n\tvar str string\n\t*v = init\n\tif err := json.Unmarshal(b, &str); err != nil {\n\t\treturn err\n\t}\n\tif val, ok := m[strings.ToLower(str)]; ok {\n\t\t*v = val\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"%v is not a valid %s\", str, typename)\n}\n\n// Config return a tls.Config object\nfunc (t *TLS) Config() (*tls.Config, error) {\n\tif len(t.CA) <= 0 {\n\t\t// the insecure is true but no ca/cert/key, then return a tls config\n\t\tif t.Insecure == true {\n\t\t\tlog.Debug(\"[TLS] Insecure is true but the CA is empty, return a tls config\")\n\t\t\treturn &tls.Config{InsecureSkipVerify: true}, nil\n\t\t}\n\t\treturn nil, nil\n\t}\n\n\tcert, err := ioutil.ReadFile(t.CA)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcaCertPool := x509.NewCertPool()\n\tcaCertPool.AppendCertsFromPEM(cert)\n\n\t// only have CA file, go TLS\n\tif len(t.Cert) <= 0 || len(t.Key) <= 0 {\n\t\tlog.Debug(\"[TLS] Only have CA file, go TLS\")\n\t\treturn &tls.Config{\n\t\t\tRootCAs:            caCertPool,\n\t\t\tInsecureSkipVerify: t.Insecure,\n\t\t}, nil\n\t}\n\n\t// have both CA and cert/key, go mTLS way\n\tlog.Debug(\"[TLS] Have both CA and cert/key, go mTLS way\")\n\tcertificate, err := tls.LoadX509KeyPair(t.Cert, t.Key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &tls.Config{\n\t\tRootCAs:            caCertPool,\n\t\tCertificates:       []tls.Certificate{certificate},\n\t\tInsecureSkipVerify: t.Insecure,\n\t}, nil\n}\n\n// ErrNoRetry is the error need not retry\ntype ErrNoRetry struct {\n\tMessage string\n}\n\nfunc (e *ErrNoRetry) Error() string {\n\treturn e.Message\n}\n\n// DoRetry is a help function to retry the function if it returns error\nfunc DoRetry(kind, name, tag string, r Retry, fn func() error) error {\n\tvar err error\n\tfor i := 0; i < r.Times; i++ {\n\t\terr = fn()\n\t\t_, ok := err.(*ErrNoRetry)\n\t\tif err == nil || ok {\n\t\t\treturn err\n\t\t}\n\t\tlog.Warnf(\"[%s / %s / %s] Retried to send %d/%d - %v\", kind, name, tag, i+1, r.Times, err)\n\n\t\t// last time no need to sleep\n\t\tif i < r.Times-1 {\n\t\t\ttime.Sleep(r.Interval)\n\t\t}\n\t}\n\treturn fmt.Errorf(\"[%s / %s / %s] failed after %d retries - %v\", kind, name, tag, r.Times, err)\n}\n\n// GetWorkDir return the current working directory\nfunc GetWorkDir() string {\n\tdir, err := os.Getwd()\n\tif err != nil {\n\t\tlog.Warnf(\"Cannot get the current directory: %v, using $HOME directory!\", err)\n\t\tdir, err = os.UserHomeDir()\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"Cannot get the user home directory: %v, using /tmp directory!\", err)\n\t\t\tdir = os.TempDir()\n\t\t}\n\t}\n\treturn dir\n}\n\n// MakeDirectory return the writeable filename\nfunc MakeDirectory(filename string) string {\n\tdir, file := filepath.Split(filename)\n\tif len(dir) <= 0 {\n\t\tdir = GetWorkDir()\n\t}\n\tif len(file) <= 0 {\n\t\treturn dir\n\t}\n\tif strings.HasPrefix(dir, \"~/\") {\n\t\thome, err := os.UserHomeDir()\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"Cannot get the user home directory: %v, using /tmp directory as home\", err)\n\t\t\thome = os.TempDir()\n\t\t}\n\t\tdir = filepath.Join(home, dir[2:])\n\t}\n\tdir, err := filepath.Abs(dir)\n\tif err != nil {\n\t\tlog.Warnf(\"Cannot get the absolute path: %v\", err)\n\t\tdir = GetWorkDir()\n\t}\n\n\tif _, err := os.Stat(dir); os.IsNotExist(err) {\n\t\terr = os.MkdirAll(dir, os.ModePerm)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"Cannot create the directory: %v\", err)\n\t\t\tdir = GetWorkDir()\n\t\t}\n\t}\n\n\treturn filepath.Join(dir, file)\n}\n\n// CommandLine will return the whole command line which includes command and all arguments\nfunc CommandLine(cmd string, args []string) string {\n\tresult := cmd\n\tfor _, arg := range args {\n\t\tresult += \" \" + arg\n\t}\n\treturn result\n}\n", "/*\n * Copyright (c) 2022, MegaEase\n * All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage global\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"encoding/json\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\t\"bou.ke/monkey\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"gopkg.in/yaml.v3\"\n)\n\nfunc TestReverseMap(t *testing.T) {\n\tm := map[int]string{\n\t\t1: \"a\",\n\t\t2: \"b\",\n\t\t3: \"c\",\n\t}\n\tn := ReverseMap(m)\n\tassert.Equal(t, 1, n[\"a\"])\n\tassert.Equal(t, 2, n[\"b\"])\n\tassert.Equal(t, 3, n[\"c\"])\n}\n\ntype TestEnum int\n\nconst (\n\tUnknown TestEnum = iota\n\tTest1\n\tTest2\n\tTest3\n\tTest4\n)\n\nvar testEnumToString = map[TestEnum]string{\n\tUnknown: \"unknown\",\n\tTest1:   \"test1\",\n\tTest2:   \"test2\",\n\tTest3:   \"test3\",\n\tTest4:   \"test4\",\n}\nvar strToTestEnum = ReverseMap(testEnumToString)\n\n// MarshalYAML is marshal the provider type\nfunc (d TestEnum) MarshalYAML() (interface{}, error) {\n\treturn EnumMarshalYaml(testEnumToString, d, \"Test\")\n}\n\n// UnmarshalYAML is unmarshal the provider type\nfunc (d *TestEnum) UnmarshalYAML(unmarshal func(interface{}) error) error {\n\treturn EnumUnmarshalYaml(unmarshal, strToTestEnum, d, Unknown, \"Test\")\n}\n\n// MarshalJSON is marshal the provider\nfunc (d TestEnum) MarshalJSON() (b []byte, err error) {\n\treturn EnumMarshalJSON(testEnumToString, d, \"Test\")\n}\n\n// UnmarshalJSON is Unmarshal the provider type\nfunc (d *TestEnum) UnmarshalJSON(b []byte) (err error) {\n\treturn EnumUnmarshalJSON(b, strToTestEnum, d, Unknown, \"Test\")\n}\n\nfunc testMarshalUnmarshal(t *testing.T, str string, te TestEnum, good bool,\n\tmarshal func(in interface{}) ([]byte, error),\n\tunmarshal func(in []byte, out interface{}) (err error)) {\n\n\tvar s TestEnum\n\terr := unmarshal([]byte(str), &s)\n\tif good {\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, te, s)\n\t} else {\n\t\tassert.Error(t, err)\n\t\tassert.Equal(t, Unknown, s)\n\t}\n\n\tbuf, err := marshal(te)\n\tif good {\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, str, string(buf))\n\t} else {\n\t\tassert.Error(t, err)\n\t\tassert.Nil(t, buf)\n\t}\n}\nfunc testYamlJSON(t *testing.T, str string, te TestEnum, good bool) {\n\ttestYaml(t, str+\"\\n\", te, good)\n\ttestJSON(t, `\"`+str+`\"`, te, good)\n}\nfunc testYaml(t *testing.T, str string, te TestEnum, good bool) {\n\ttestMarshalUnmarshal(t, str, te, good, yaml.Marshal, yaml.Unmarshal)\n}\nfunc testJSON(t *testing.T, str string, te TestEnum, good bool) {\n\ttestMarshalUnmarshal(t, str, te, good, json.Marshal, json.Unmarshal)\n}\n\nfunc TestEnmuMarshalUnMarshal(t *testing.T) {\n\ttestYamlJSON(t, \"test1\", Test1, true)\n\ttestYamlJSON(t, \"test2\", Test2, true)\n\ttestYamlJSON(t, \"test3\", Test3, true)\n\ttestYamlJSON(t, \"test4\", Test4, true)\n\ttestYamlJSON(t, \"unknown\", Unknown, true)\n\n\ttestYamlJSON(t, \"bad\", 10, false)\n\ttestJSON(t, `{\"x\":\"y\"}`, 10, false)\n\ttestYaml(t, \"-bad::\", 10, false)\n}\n\nfunc makeCA(path string, subject *pkix.Name) (*x509.Certificate, *rsa.PrivateKey, error) {\n\t// creating a CA which will be used to sign all of our certificates using the x509 package from the Go Standard Library\n\tcaCert := &x509.Certificate{\n\t\tSerialNumber:          big.NewInt(2019),\n\t\tSubject:               *subject,\n\t\tNotBefore:             time.Now(),\n\t\tNotAfter:              time.Now().AddDate(10*365, 0, 0),\n\t\tIsCA:                  true, // <- indicating this certificate is a CA certificate.\n\t\tExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},\n\t\tKeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,\n\t\tBasicConstraintsValid: true,\n\t}\n\t// generate a private key for the CA\n\tcaKey, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// create the CA certificate\n\tcaBytes, err := x509.CreateCertificate(rand.Reader, caCert, caCert, &caKey.PublicKey, caKey)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Create the CA PEM files\n\tcaPEM := new(bytes.Buffer)\n\tpem.Encode(caPEM, &pem.Block{\n\t\tType:  \"CERTIFICATE\",\n\t\tBytes: caBytes,\n\t})\n\n\tif err := os.WriteFile(path+\"ca.crt\", caPEM.Bytes(), 0644); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcaPrivKeyPEM := new(bytes.Buffer)\n\tpem.Encode(caPrivKeyPEM, &pem.Block{\n\t\tType:  \"RSA PRIVATE KEY\",\n\t\tBytes: x509.MarshalPKCS1PrivateKey(caKey),\n\t})\n\tif err := os.WriteFile(path+\"ca.key\", caPEM.Bytes(), 0644); err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn caCert, caKey, nil\n}\n\nfunc makeCert(path string, caCert *x509.Certificate, caKey *rsa.PrivateKey, subject *pkix.Name, name string) error {\n\tcert := &x509.Certificate{\n\t\tSerialNumber: big.NewInt(1658),\n\t\tSubject:      *subject,\n\t\t//IPAddresses:  []net.IP{net.IPv4(127, 0, 0, 1), net.IPv6loopback},\n\t\tDNSNames:     []string{\"localhost\"},\n\t\tNotBefore:    time.Now(),\n\t\tNotAfter:     time.Now().AddDate(10, 0, 0),\n\t\tSubjectKeyId: []byte{1, 2, 3, 4, 6},\n\t\tExtKeyUsage:  []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},\n\t\tKeyUsage:     x509.KeyUsageDigitalSignature,\n\t}\n\n\tcertKey, err := rsa.GenerateKey(rand.Reader, 4096)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcertBytes, err := x509.CreateCertificate(rand.Reader, cert, caCert, &certKey.PublicKey, caKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcertPEM := new(bytes.Buffer)\n\tpem.Encode(certPEM, &pem.Block{\n\t\tType:  \"CERTIFICATE\",\n\t\tBytes: certBytes,\n\t})\n\tif err := os.WriteFile(path+name+\".crt\", certPEM.Bytes(), 0644); err != nil {\n\t\treturn err\n\t}\n\n\tcertKeyPEM := new(bytes.Buffer)\n\tpem.Encode(certKeyPEM, &pem.Block{\n\t\tType:  \"RSA PRIVATE KEY\",\n\t\tBytes: x509.MarshalPKCS1PrivateKey(certKey),\n\t})\n\treturn os.WriteFile(path+name+\".key\", certKeyPEM.Bytes(), 0644)\n}\n\nfunc TestTLS(t *testing.T) {\n\t// no TLS\n\t_tls := TLS{}\n\tconn, e := _tls.Config()\n\tassert.Nil(t, conn)\n\tassert.Nil(t, e)\n\n\t// only have insecure option\n\t_tls = TLS{\n\t\tInsecure: true,\n\t}\n\tconn, e = _tls.Config()\n\tassert.NotNil(t, conn)\n\tassert.Nil(t, e)\n\n\tpath := GetWorkDir() + \"/certs/\"\n\tos.MkdirAll(path, 0755)\n\tdefer os.RemoveAll(path)\n\n\t//mTLS\n\t_tls = TLS{\n\t\tCA:   filepath.Join(path, \"./ca.crt\"),\n\t\tCert: filepath.Join(path, \"./test.crt\"),\n\t\tKey:  filepath.Join(path, \"./test.key\"),\n\t}\n\tconn, e = _tls.Config()\n\tassert.Nil(t, conn)\n\tassert.NotNil(t, e)\n\n\tsubject := pkix.Name{\n\t\tCountry:            []string{\"Earth\"},\n\t\tOrganization:       []string{\"MegaEase\"},\n\t\tOrganizationalUnit: []string{\"Engineering\"},\n\t\tLocality:           []string{\"Mountain\"},\n\t\tProvince:           []string{\"Asia\"},\n\t\tStreetAddress:      []string{\"Bridge\"},\n\t\tPostalCode:         []string{\"123456\"},\n\t\tSerialNumber:       \"\",\n\t\tCommonName:         \"CA\",\n\t\tNames:              []pkix.AttributeTypeAndValue{},\n\t\tExtraNames:         []pkix.AttributeTypeAndValue{},\n\t}\n\tcaCert, caKey, err := makeCA(path, &subject)\n\tif err != nil {\n\t\tt.Fatalf(\"make CA Certificate error! - %v\", err)\n\t}\n\tt.Log(\"Create the CA certificate successfully.\")\n\n\tsubject.CommonName = \"Server\"\n\tsubject.Organization = []string{\"Server Company\"}\n\tif err := makeCert(path, caCert, caKey, &subject, \"test\"); err != nil {\n\t\tt.Fatal(\"make Server Certificate error!\")\n\t}\n\tt.Log(\"Create and Sign the Server certificate successfully.\")\n\n\tconn, e = _tls.Config()\n\tassert.Nil(t, e)\n\tassert.NotNil(t, conn)\n\n\tmonkey.Patch(tls.LoadX509KeyPair, func(certFile, keyFile string) (tls.Certificate, error) {\n\t\treturn tls.Certificate{}, fmt.Errorf(\"load x509 key pair error\")\n\t})\n\n\tconn, e = _tls.Config()\n\tassert.NotNil(t, e)\n\tassert.Nil(t, conn)\n\tmonkey.UnpatchAll()\n\n\t//TLS\n\t_tls = TLS{\n\t\tCA:       filepath.Join(path, \"./ca.crt\"),\n\t\tInsecure: false,\n\t}\n\tconn, e = _tls.Config()\n\tassert.Nil(t, e)\n\tassert.NotNil(t, conn)\n\tassert.Nil(t, conn.Certificates)\n}\n\nfunc TestNormalize(t *testing.T) {\n\n\t// local value\n\tr := normalize(10, 20, 0, 30)\n\tassert.Equal(t, 20, r)\n\n\t// global value\n\tr = normalize(10, 0, 0, 10)\n\tassert.Equal(t, 10, r)\n\n\t// default value\n\tr = normalize(0, 0, 0, 30)\n\tassert.Equal(t, 30, r)\n}\n\nfunc TestRetry(t *testing.T) {\n\n\tr := Retry{\n\t\tTimes:    3,\n\t\tInterval: 100 * time.Millisecond,\n\t}\n\n\tcnt := 0\n\tf := func() error {\n\t\tif cnt < r.Times {\n\t\t\tcnt++\n\t\t\treturn fmt.Errorf(\"error, cnt=%d\", cnt)\n\t\t}\n\t\treturn nil\n\t}\n\n\terr := DoRetry(\"test\", \"dummy\", \"tag\", r, f)\n\tassert.NotNil(t, err)\n\tassert.Equal(t, r.Times, cnt)\n\n\tcnt = 1\n\terr = DoRetry(\"test\", \"dummy\", \"tag\", r, f)\n\tassert.Nil(t, err)\n\tassert.Equal(t, r.Times, cnt)\n\n\tf = func() error {\n\t\tcnt++\n\t\treturn &ErrNoRetry{\"No Retry Error\"}\n\t}\n\tcnt = 0\n\terr = DoRetry(\"test\", \"dummy\", \"tag\", r, f)\n\tassert.NotNil(t, err)\n\tassert.Equal(t, 1, cnt)\n\tassert.Equal(t, err.Error(), \"No Retry Error\")\n\n}\n\nfunc TestGetWritableDir(t *testing.T) {\n\tfilename := \"\"\n\tdir := MakeDirectory(filename)\n\tassert.Equal(t, GetWorkDir(), dir)\n\n\tfilename = \"./test.txt\"\n\tdir = MakeDirectory(filename)\n\texp, _ := filepath.Abs(filename)\n\tassert.Equal(t, exp, dir)\n\n\tfilename = \"./none/existed/test.txt\"\n\texp, _ = filepath.Abs(filename)\n\tdir = MakeDirectory(filename)\n\tos.RemoveAll(\"./none\")\n\tassert.Equal(t, exp, dir)\n\n\tfilename = \"~/none/existed/test.txt\"\n\thome, err := os.UserHomeDir()\n\tif err != nil {\n\t\thome = os.TempDir()\n\t}\n\texp = filepath.Join(home, \"none/existed/test.txt\")\n\tdir = MakeDirectory(filename)\n\tos.RemoveAll(home + \"/none\")\n\tassert.Equal(t, exp, dir)\n}\n\nfunc TestGetWorkDirFail(t *testing.T) {\n\tdefer monkey.UnpatchAll()\n\tmonkey.Patch(os.Getwd, func() (string, error) {\n\t\treturn \"\", fmt.Errorf(\"error\")\n\t})\n\n\tpath := GetWorkDir()\n\thome, err := os.UserHomeDir()\n\tassert.Nil(t, err)\n\tassert.Equal(t, path, home)\n\n\tmonkey.Patch(os.UserHomeDir, func() (string, error) {\n\t\treturn \"\", fmt.Errorf(\"error\")\n\t})\n\n\tpath = GetWorkDir()\n\tassert.Equal(t, path, os.TempDir())\n\n}\n\nfunc TestMakeDirectoryFail(t *testing.T) {\n\tdefer monkey.UnpatchAll()\n\tmonkey.Patch(os.UserHomeDir, func() (string, error) {\n\t\treturn \"\", fmt.Errorf(\"error\")\n\t})\n\n\tfilename := \"~/test.txt\"\n\tresult := MakeDirectory(filename)\n\tassert.Equal(t, result, filepath.Join(os.TempDir(), filename[2:]))\n\n\tmonkey.Unpatch(os.UserHomeDir)\n\n\tmonkey.Patch(filepath.Abs, func(path string) (string, error) {\n\t\treturn \"\", fmt.Errorf(\"error\")\n\t})\n\tfilename = \"../test.txt\"\n\tresult = MakeDirectory(filename)\n\tassert.Equal(t, result, filepath.Join(GetWorkDir(), \"test.txt\"))\n\n\tmonkey.Unpatch(filepath.Abs)\n\n\tmonkey.Patch(os.MkdirAll, func(string, os.FileMode) error {\n\t\treturn fmt.Errorf(\"error\")\n\t})\n\n\tfilename = \"/not/existed/test.txt\"\n\tresult = MakeDirectory(filename)\n\tassert.Equal(t, result, filepath.Join(GetWorkDir(), \"test.txt\"))\n\n\tmonkey.Unpatch(os.MkdirAll)\n\n}\n\nfunc TestCommandLine(t *testing.T) {\n\ts := CommandLine(\"echo\", []string{\"hello\", \"world\"})\n\tassert.Equal(t, \"echo hello world\", s)\n\n\ts = CommandLine(\"kubectl\", []string{\"get\", \"pod\", \"--all-namespaces\", \"-o\", \"json\"})\n\tassert.Equal(t, \"kubectl get pod --all-namespaces -o json\", s)\n}\n", "/*\n * Copyright (c) 2022, MegaEase\n * All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Package mysql is the client probe for MySQL.\npackage mysql\n\nimport (\n\t\"crypto/tls\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/go-sql-driver/mysql\"\n\t\"github.com/megaease/easeprobe/global\"\n\t\"github.com/megaease/easeprobe/probe/client/conf\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\n// Kind is the type of driver\nconst Kind string = \"MySQL\"\n\n// MySQL is the MySQL client\ntype MySQL struct {\n\tconf.Options `yaml:\",inline\"`\n\ttls          *tls.Config `yaml:\"-\" json:\"-\"`\n\tConnStr      string      `yaml:\"conn_str,omitempty\" json:\"conn_str,omitempty\"`\n}\n\n// New create a Mysql client\nfunc New(opt conf.Options) (*MySQL, error) {\n\n\tvar conn string\n\tif len(opt.Password) > 0 {\n\t\tconn = fmt.Sprintf(\"%s:%s@tcp(%s)/?timeout=%s\",\n\t\t\topt.Username, opt.Password, opt.Host, opt.Timeout().Round(time.Second))\n\t} else {\n\t\tconn = fmt.Sprintf(\"%s@tcp(%s)/?timeout=%s\",\n\t\t\topt.Username, opt.Host, opt.Timeout().Round(time.Second))\n\t}\n\n\ttls, err := opt.TLS.Config()\n\tif err != nil {\n\t\tlog.Errorf(\"[%s / %s / %s] - TLS Config Error - %v\", opt.ProbeKind, opt.ProbeName, opt.ProbeTag, err)\n\t\treturn nil, fmt.Errorf(\"TLS Config Error - %v\", err)\n\t} else if tls != nil {\n\t\tconn += \"&tls=\" + global.DefaultProg\n\t}\n\n\tm := &MySQL{\n\t\tOptions: opt,\n\t\ttls:     tls,\n\t\tConnStr: conn,\n\t}\n\n\tif err := m.checkData(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n\n// Kind return the name of client\nfunc (r *MySQL) Kind() string {\n\treturn Kind\n}\n\n// checkData do the data checking\nfunc (r *MySQL) checkData() error {\n\n\tfor k := range r.Data {\n\t\tif _, err := r.getSQL(k); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Probe do the health check\nfunc (r *MySQL) Probe() (bool, string) {\n\n\tif r.tls != nil {\n\t\tmysql.RegisterTLSConfig(global.DefaultProg, r.tls)\n\t}\n\n\tdb, err := sql.Open(\"mysql\", r.ConnStr)\n\tif err != nil {\n\t\treturn false, err.Error()\n\t}\n\tdefer db.Close()\n\n\t// Check if we need to query specific data\n\tif len(r.Data) > 0 {\n\t\tfor k, v := range r.Data {\n\t\t\tlog.Debugf(\"[%s / %s / %s] - Verifying Data - [%s] : [%s]\", r.ProbeKind, r.ProbeName, r.ProbeTag, k, v)\n\t\t\tsql, err := r.getSQL(k)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err.Error()\n\t\t\t}\n\t\t\tlog.Debugf(\"[%s / %s / %s] - SQL - [%s]\", r.ProbeKind, r.ProbeName, r.ProbeTag, sql)\n\t\t\trows, err := db.Query(sql)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err.Error()\n\t\t\t}\n\t\t\tif !rows.Next() {\n\t\t\t\trows.Close()\n\t\t\t\treturn false, fmt.Sprintf(\"No data found for [%s]\", k)\n\t\t\t}\n\t\t\t//check the value is equal to the value in data\n\t\t\tvar value string\n\t\t\tif err := rows.Scan(&value); err != nil {\n\t\t\t\trows.Close()\n\t\t\t\treturn false, err.Error()\n\t\t\t}\n\t\t\tif value != v {\n\t\t\t\trows.Close()\n\t\t\t\treturn false, fmt.Sprintf(\"Value not match for [%s] expected [%s] got [%s] \", k, v, value)\n\t\t\t}\n\t\t\trows.Close()\n\t\t\tlog.Debugf(\"[%s / %s / %s] - Data Verified Successfully! - [%s] : [%s]\", r.ProbeKind, r.ProbeName, r.ProbeTag, k, v)\n\t\t}\n\t} else {\n\t\terr = db.Ping()\n\t\tif err != nil {\n\t\t\treturn false, err.Error()\n\t\t}\n\t\trow, err := db.Query(\"show status like \\\"uptime\\\"\") // run a SQL to test\n\t\tif err != nil {\n\t\t\treturn false, err.Error()\n\t\t}\n\t\tdefer row.Close()\n\t}\n\n\treturn true, \"Check MySQL Server Successfully!\"\n\n}\n\n// getSQL get the SQL statement\n// input: database:table:column:key:value\n// output: SELECT column FROM database.table WHERE key = value\nfunc (r *MySQL) getSQL(str string) (string, error) {\n\tif len(strings.TrimSpace(str)) == 0 {\n\t\treturn \"\", fmt.Errorf(\"Empty SQL data\")\n\t}\n\tfields := strings.Split(str, \":\")\n\tif len(fields) != 5 {\n\t\treturn \"\", fmt.Errorf(\"Invalid SQL data - [%s]. (syntax: database:table:field:key:value)\", str)\n\t}\n\tdb := fields[0]\n\ttable := fields[1]\n\tfield := fields[2]\n\tkey := fields[3]\n\tvalue := fields[4]\n\t//check value is int or not\n\tif _, err := strconv.Atoi(value); err != nil {\n\t\treturn \"\", fmt.Errorf(\"Invalid SQL data - [%s], the value must be int\", str)\n\t}\n\n\tsql := fmt.Sprintf(\"SELECT %s FROM %s.%s WHERE %s = %s\", field, db, table, key, value)\n\treturn sql, nil\n}\n", "/*\n * Copyright (c) 2022, MegaEase\n * All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Package postgres is the native client probe for  PostgreSQL\npackage postgres\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/megaease/easeprobe/global\"\n\t\"github.com/megaease/easeprobe/probe/client/conf\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"github.com/uptrace/bun/driver/pgdriver\"\n)\n\n// Kind is the type of driver\nconst Kind string = \"PostgreSQL\"\n\n// revive:disable\n// PostgreSQL is the PostgreSQL client\ntype PostgreSQL struct {\n\tconf.Options  `yaml:\",inline\"`\n\tClientOptions []pgdriver.Option `yaml:\"-\" json:\"-\"`\n}\n\n// revive:enable\n\n// New create a PostgreSQL client\nfunc New(opt conf.Options) (*PostgreSQL, error) {\n\tclientOptions := []pgdriver.Option{\n\t\tpgdriver.WithNetwork(\"tcp\"),\n\t\tpgdriver.WithAddr(opt.Host),\n\t\tpgdriver.WithUser(opt.Username),\n\t\tpgdriver.WithTimeout(opt.Timeout().Round(time.Second)),\n\t\tpgdriver.WithApplicationName(global.OrgProgVer),\n\t}\n\tif len(opt.Password) > 0 {\n\t\tclientOptions = append(clientOptions, pgdriver.WithPassword(opt.Password))\n\t}\n\n\ttls, err := opt.TLS.Config()\n\tif err != nil {\n\t\tlog.Errorf(\"[%s / %s / %s] - TLS Config Error - %v\", opt.ProbeKind, opt.ProbeName, opt.ProbeTag, err)\n\t\treturn nil, fmt.Errorf(\"TLS Config Error - %v\", err)\n\t} else if tls != nil {\n\t\ttls.InsecureSkipVerify = true\n\t}\n\t// if the tls is nil which means `sslmode=disable`\n\tclientOptions = append(clientOptions, pgdriver.WithTLSConfig(tls))\n\n\tpg := &PostgreSQL{\n\t\tOptions:       opt,\n\t\tClientOptions: clientOptions,\n\t}\n\tif err := pg.checkData(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn pg, nil\n}\n\n// Kind return the name of client\nfunc (r *PostgreSQL) Kind() string {\n\treturn Kind\n}\n\n// checkData do the data checking\nfunc (r *PostgreSQL) checkData() error {\n\n\tfor k := range r.Data {\n\t\t_, _, err := r.getSQL(k)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Probe do the health check\nfunc (r *PostgreSQL) Probe() (bool, string) {\n\n\tif len(r.Data) > 0 {\n\t\treturn r.ProbeWithDataChecking()\n\t}\n\treturn r.ProbeWithPing()\n}\n\n// ProbeWithPing do the health check with ping & Select 1;\nfunc (r *PostgreSQL) ProbeWithPing() (bool, string) {\n\tr.ClientOptions = append(r.ClientOptions, pgdriver.WithDatabase(\"template1\"))\n\tdb := sql.OpenDB(pgdriver.NewConnector(r.ClientOptions...))\n\tif db == nil {\n\t\treturn false, \"OpenDB error\"\n\t}\n\tdefer db.Close()\n\n\tif err := db.Ping(); err != nil {\n\t\treturn false, err.Error()\n\t}\n\n\t// run a SQL to test\n\trow, err := db.Query(`SELECT 1`)\n\tif err != nil {\n\t\treturn false, err.Error()\n\t}\n\trow.Close()\n\treturn true, \"Check PostgreSQL Server Successfully!\"\n}\n\n// ProbeWithDataChecking do the health check with data checking\nfunc (r *PostgreSQL) ProbeWithDataChecking() (bool, string) {\n\tif len(r.Data) == 0 {\n\t\tlog.Warnf(\"[%s / %s / %s] - No data found, use ping instead\", r.ProbeKind, r.ProbeName, r.ProbeTag)\n\t\treturn r.ProbeWithPing()\n\t}\n\n\tfor k, v := range r.Data {\n\t\tif ok, msg := r.verifyData(k, v); !ok {\n\t\t\treturn ok, msg\n\t\t}\n\t}\n\n\treturn true, \"Check PostgreSQL Server Successfully!\"\n}\n\nfunc (r *PostgreSQL) verifyData(k, v string) (bool, string) {\n\tlog.Debugf(\"[%s / %s / %s] - Verifying Data - [%s] : [%s]\", r.ProbeKind, r.ProbeName, r.ProbeTag, k, v)\n\t//connect to the database\n\tdbName, sqlstr, err := r.getSQL(k)\n\tif err != nil {\n\t\treturn false, fmt.Sprintf(\"Invalid SQL data - [%s], %v\", v, err)\n\t}\n\tclientOptions := append(r.ClientOptions, pgdriver.WithDatabase(dbName))\n\tdb := sql.OpenDB(pgdriver.NewConnector(clientOptions...))\n\tif db == nil {\n\t\treturn false, \"OpenDB error\"\n\t}\n\tdefer db.Close()\n\n\t// query the data\n\tlog.Debugf(\"[%s / %s / %s] - SQL - [%s]\", r.ProbeKind, r.ProbeName, r.ProbeTag, sqlstr)\n\trows, err := db.Query(sqlstr)\n\tif err != nil {\n\t\treturn false, fmt.Sprintf(\"Query error - [%s], %v\", v, err)\n\t}\n\tdefer rows.Close()\n\n\tif !rows.Next() {\n\t\treturn false, fmt.Sprintf(\"No data found for [%s]\", k)\n\t}\n\t//check the value is equal to the value in data\n\tvar value string\n\tif err := rows.Scan(&value); err != nil {\n\t\treturn false, err.Error()\n\t}\n\tif value != v {\n\t\treturn false, fmt.Sprintf(\"Value not match for [%s] expected [%s] got [%s] \", k, v, value)\n\t}\n\n\tlog.Debugf(\"[%s / %s / %s] - Data Verified Successfully! - [%s] : [%s]\", r.ProbeKind, r.ProbeName, r.ProbeTag, k, v)\n\treturn true, \"Check PostgreSQL Server Successfully!\"\n}\n\n// getSQL get the SQL statement\n// input: database:table:column:key:value\n// output: SELECT column FROM database.table WHERE key = value\nfunc (r *PostgreSQL) getSQL(str string) (string, string, error) {\n\tif len(strings.TrimSpace(str)) == 0 {\n\t\treturn \"\", \"\", fmt.Errorf(\"Empty SQL data\")\n\t}\n\tfields := strings.Split(str, \":\")\n\tif len(fields) != 5 {\n\t\treturn \"\", \"\", fmt.Errorf(\"Invalid SQL data - [%s]. (syntax: database:table:field:key:value)\", str)\n\t}\n\tdb := fields[0]\n\ttable := fields[1]\n\tfield := fields[2]\n\tkey := fields[3]\n\tvalue := fields[4]\n\t//check value is int or not\n\tif _, err := strconv.Atoi(value); err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"Invalid SQL data - [%s], the value must be int\", str)\n\t}\n\n\tsql := fmt.Sprintf(\"SELECT %s FROM %s WHERE %s = %s\", field, table, key, value)\n\treturn db, sql, nil\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2022, MegaEase\n * All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage global\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\tlog \"github.com/sirupsen/logrus\"\n\t\"golang.org/x/exp/constraints\"\n)\n\nconst (\n\t// Org is the organization\n\tOrg = \"MegaEase\"\n\t// DefaultProg is the program name\n\tDefaultProg = \"EaseProbe\"\n\t// DefaultIconURL is the default icon which used in Slack or Discord\n\tDefaultIconURL = \"https://megaease.com/favicon.png\"\n)\n\nvar (\n\t// Ver is the program version\n\t// It will be set by the build script\n\t// go build -ldflags \"-X github.com/megaease/easegress/pkg/global.Ver=1.0.0\"\n\tVer = \"v1.7.0\"\n\t//OrgProg combine organization and program\n\tOrgProg = Org + \" \" + DefaultProg\n\t//OrgProgVer combine organization and program and version\n\tOrgProgVer = Org + \" \" + DefaultProg + \"/\" + Ver\n)\n\nconst (\n\t// DefaultRetryTimes is 3 times\n\tDefaultRetryTimes = 3\n\t// DefaultRetryInterval is 5 seconds\n\tDefaultRetryInterval = time.Second * 5\n\t// DefaultTimeFormat is \"2006-01-02 15:04:05 Z0700\"\n\tDefaultTimeFormat = \"2006-01-02 15:04:05 Z0700\"\n\t// DefaultTimeZone is \"UTC\"\n\tDefaultTimeZone = \"UTC\"\n\t// DefaultProbeInterval is 1 minutes\n\tDefaultProbeInterval = time.Second * 60\n\t// DefaultTimeOut is 30 seconds\n\tDefaultTimeOut = time.Second * 30\n\t// DefaultChannelName  is the default wide channel name\n\tDefaultChannelName = \"__EaseProbe_Channel__\"\n\t// DefaultStatusChangeThresholdSetting is the threshold of status change\n\tDefaultStatusChangeThresholdSetting = 1\n\t// DefaultNotificationStrategy is the default notify strategy\n\tDefaultNotificationStrategy = RegularStrategy\n\t// DefaultMaxNotificationTimes is the default max notification times\n\tDefaultMaxNotificationTimes = 1\n\t// DefaultNotificationFactor is the default notification factor\n\tDefaultNotificationFactor = 1\n)\n\nconst (\n\t// DefaultHTTPServerIP is the default ip of the HTTP server\n\tDefaultHTTPServerIP = \"0.0.0.0\"\n\t// DefaultHTTPServerPort is the default port of the HTTP server\n\tDefaultHTTPServerPort = \"8181\"\n\t// DefaultPageSize is the default page size\n\tDefaultPageSize = 100\n\t// DefaultAccessLogFile is the default access log file name\n\tDefaultAccessLogFile = \"access.log\"\n\t// DefaultDataFile is the default data file name\n\tDefaultDataFile = \"data/data.yaml\"\n\t// DefaultPIDFile is the default pid file name\n\tDefaultPIDFile = \"easeprobe.pid\"\n)\n\nconst (\n\t// DefaultMaxLogSize is the default max log size\n\tDefaultMaxLogSize = 10 // 10M\n\t// DefaultMaxLogAge is the default max log age\n\tDefaultMaxLogAge = 7 // 7 days\n\t// DefaultMaxBackups is the default backup file number\n\tDefaultMaxBackups = 5 // file\n\t// DefaultLogCompress is the default compress log\n\tDefaultLogCompress = true\n)\n\n// Retry is the settings of retry\ntype Retry struct {\n\tTimes    int           `yaml:\"times\" json:\"times,omitempty\" jsonschema:\"title=Retry Times,description=how many times need to retry,minimum=1\"`\n\tInterval time.Duration `yaml:\"interval\" json:\"interval,omitempty\" jsonschema:\"type=string,format=duration,title=Retry Interval,description=the interval between each retry\"`\n}\n\n// TLS is the configuration for TLS files\ntype TLS struct {\n\tCA       string `yaml:\"ca\" json:\"ca,omitempty\" jsonschema:\"title=CA File,description=the CA file path\"`\n\tCert     string `yaml:\"cert\" json:\"cert,omitempty\" jsonschema:\"title=Cert File,description=the Cert file path\"`\n\tKey      string `yaml:\"key\" json:\"key,omitempty\" jsonschema:\"title=Key File,description=the Key file path\"`\n\tInsecure bool   `yaml:\"insecure\" json:\"insecure,omitempty\" jsonschema:\"title=Insecure,description=whether to skip the TLS verification\"`\n}\n\n// The normalize() function logic as below:\n// - if both global and local are not set, then return the _default.\n// - if set the global, but not the local, then return the global\n// - if set the local, but not the global, then return the local\n// - if both global and local are set, then return the local\nfunc normalize[T constraints.Ordered](global, local, valid, _default T) T {\n\t// if the val is invalid, then assign the default value\n\tif local <= valid {\n\t\tlocal = _default\n\t\t//if the global configuration is validated, assign the global\n\t\tif global > valid {\n\t\t\tlocal = global\n\t\t}\n\t}\n\treturn local\n}\n\n// ReverseMap just reverse the map from [key, value] to [value, key]\nfunc ReverseMap[K comparable, V comparable](m map[K]V) map[V]K {\n\tn := make(map[V]K, len(m))\n\tfor k, v := range m {\n\t\tn[v] = k\n\t}\n\treturn n\n}\n\n// EnumMarshalYaml is a help function to marshal the enum to yaml\nfunc EnumMarshalYaml[T comparable](m map[T]string, v T, typename string) (interface{}, error) {\n\tif val, ok := m[v]; ok {\n\t\treturn val, nil\n\t}\n\treturn nil, fmt.Errorf(\"%v is not a valid %s\", v, typename)\n}\n\n// EnumMarshalJSON is a help function to marshal the enum to JSON\nfunc EnumMarshalJSON[T comparable](m map[T]string, v T, typename string) ([]byte, error) {\n\tif val, ok := m[v]; ok {\n\t\treturn []byte(fmt.Sprintf(`\"%s\"`, val)), nil\n\t}\n\treturn nil, fmt.Errorf(\"%v is not a valid %s\", v, typename)\n}\n\n// EnumUnmarshalYaml is a help function to unmarshal the enum from yaml\nfunc EnumUnmarshalYaml[T comparable](unmarshal func(interface{}) error, m map[string]T, v *T, init T, typename string) error {\n\tvar str string\n\t*v = init\n\tif err := unmarshal(&str); err != nil {\n\t\treturn err\n\t}\n\tif val, ok := m[strings.ToLower(str)]; ok {\n\t\t*v = val\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"%v is not a valid %s\", str, typename)\n}\n\n// EnumUnmarshalJSON is a help function to unmarshal the enum from JSON\nfunc EnumUnmarshalJSON[T comparable](b []byte, m map[string]T, v *T, init T, typename string) error {\n\tvar str string\n\t*v = init\n\tif err := json.Unmarshal(b, &str); err != nil {\n\t\treturn err\n\t}\n\tif val, ok := m[strings.ToLower(str)]; ok {\n\t\t*v = val\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"%v is not a valid %s\", str, typename)\n}\n\n// Config return a tls.Config object\nfunc (t *TLS) Config() (*tls.Config, error) {\n\tif len(t.CA) <= 0 {\n\t\t// the insecure is true but no ca/cert/key, then return a tls config\n\t\tif t.Insecure == true {\n\t\t\tlog.Debug(\"[TLS] Insecure is true but the CA is empty, return a tls config\")\n\t\t\treturn &tls.Config{InsecureSkipVerify: true}, nil\n\t\t}\n\t\treturn nil, nil\n\t}\n\n\tcert, err := ioutil.ReadFile(t.CA)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcaCertPool := x509.NewCertPool()\n\tcaCertPool.AppendCertsFromPEM(cert)\n\n\t// only have CA file, go TLS\n\tif len(t.Cert) <= 0 || len(t.Key) <= 0 {\n\t\tlog.Debug(\"[TLS] Only have CA file, go TLS\")\n\t\treturn &tls.Config{\n\t\t\tRootCAs:            caCertPool,\n\t\t\tInsecureSkipVerify: t.Insecure,\n\t\t}, nil\n\t}\n\n\t// have both CA and cert/key, go mTLS way\n\tlog.Debug(\"[TLS] Have both CA and cert/key, go mTLS way\")\n\tcertificate, err := tls.LoadX509KeyPair(t.Cert, t.Key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &tls.Config{\n\t\tRootCAs:            caCertPool,\n\t\tCertificates:       []tls.Certificate{certificate},\n\t\tInsecureSkipVerify: t.Insecure,\n\t}, nil\n}\n\n// ErrNoRetry is the error need not retry\ntype ErrNoRetry struct {\n\tMessage string\n}\n\nfunc (e *ErrNoRetry) Error() string {\n\treturn e.Message\n}\n\n// DoRetry is a help function to retry the function if it returns error\nfunc DoRetry(kind, name, tag string, r Retry, fn func() error) error {\n\tvar err error\n\tfor i := 0; i < r.Times; i++ {\n\t\terr = fn()\n\t\t_, ok := err.(*ErrNoRetry)\n\t\tif err == nil || ok {\n\t\t\treturn err\n\t\t}\n\t\tlog.Warnf(\"[%s / %s / %s] Retried to send %d/%d - %v\", kind, name, tag, i+1, r.Times, err)\n\n\t\t// last time no need to sleep\n\t\tif i < r.Times-1 {\n\t\t\ttime.Sleep(r.Interval)\n\t\t}\n\t}\n\treturn fmt.Errorf(\"[%s / %s / %s] failed after %d retries - %v\", kind, name, tag, r.Times, err)\n}\n\n// GetWorkDir return the current working directory\nfunc GetWorkDir() string {\n\tdir, err := os.Getwd()\n\tif err != nil {\n\t\tlog.Warnf(\"Cannot get the current directory: %v, using $HOME directory!\", err)\n\t\tdir, err = os.UserHomeDir()\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"Cannot get the user home directory: %v, using /tmp directory!\", err)\n\t\t\tdir = os.TempDir()\n\t\t}\n\t}\n\treturn dir\n}\n\n// MakeDirectory return the writeable filename\nfunc MakeDirectory(filename string) string {\n\tdir, file := filepath.Split(filename)\n\tif len(dir) <= 0 {\n\t\tdir = GetWorkDir()\n\t}\n\tif len(file) <= 0 {\n\t\treturn dir\n\t}\n\tif strings.HasPrefix(dir, \"~/\") {\n\t\thome, err := os.UserHomeDir()\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"Cannot get the user home directory: %v, using /tmp directory as home\", err)\n\t\t\thome = os.TempDir()\n\t\t}\n\t\tdir = filepath.Join(home, dir[2:])\n\t}\n\tdir, err := filepath.Abs(dir)\n\tif err != nil {\n\t\tlog.Warnf(\"Cannot get the absolute path: %v\", err)\n\t\tdir = GetWorkDir()\n\t}\n\n\tif _, err := os.Stat(dir); os.IsNotExist(err) {\n\t\terr = os.MkdirAll(dir, os.ModePerm)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"Cannot create the directory: %v\", err)\n\t\t\tdir = GetWorkDir()\n\t\t}\n\t}\n\n\treturn filepath.Join(dir, file)\n}\n\n// CommandLine will return the whole command line which includes command and all arguments\nfunc CommandLine(cmd string, args []string) string {\n\tresult := cmd\n\tfor _, arg := range args {\n\t\tresult += \" \" + arg\n\t}\n\treturn result\n}\n\n// EscapeQuote escape the string the single quote, double quote, and backtick\nfunc EscapeQuote(str string) string {\n\ttype Escape struct {\n\t\tFrom string\n\t\tTo   string\n\t}\n\tescape := []Escape{\n\t\t{From: \"`\", To: \"\"}, // remove the backtick\n\t\t{From: `\\`, To: `\\\\`},\n\t\t{From: `'`, To: `\\'`},\n\t\t{From: `\"`, To: `\\\"`},\n\t}\n\n\tfor _, e := range escape {\n\t\tstr = strings.ReplaceAll(str, e.From, e.To)\n\t}\n\treturn str\n}\n", "/*\n * Copyright (c) 2022, MegaEase\n * All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage global\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"encoding/json\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\t\"bou.ke/monkey\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"gopkg.in/yaml.v3\"\n)\n\nfunc TestReverseMap(t *testing.T) {\n\tm := map[int]string{\n\t\t1: \"a\",\n\t\t2: \"b\",\n\t\t3: \"c\",\n\t}\n\tn := ReverseMap(m)\n\tassert.Equal(t, 1, n[\"a\"])\n\tassert.Equal(t, 2, n[\"b\"])\n\tassert.Equal(t, 3, n[\"c\"])\n}\n\ntype TestEnum int\n\nconst (\n\tUnknown TestEnum = iota\n\tTest1\n\tTest2\n\tTest3\n\tTest4\n)\n\nvar testEnumToString = map[TestEnum]string{\n\tUnknown: \"unknown\",\n\tTest1:   \"test1\",\n\tTest2:   \"test2\",\n\tTest3:   \"test3\",\n\tTest4:   \"test4\",\n}\nvar strToTestEnum = ReverseMap(testEnumToString)\n\n// MarshalYAML is marshal the provider type\nfunc (d TestEnum) MarshalYAML() (interface{}, error) {\n\treturn EnumMarshalYaml(testEnumToString, d, \"Test\")\n}\n\n// UnmarshalYAML is unmarshal the provider type\nfunc (d *TestEnum) UnmarshalYAML(unmarshal func(interface{}) error) error {\n\treturn EnumUnmarshalYaml(unmarshal, strToTestEnum, d, Unknown, \"Test\")\n}\n\n// MarshalJSON is marshal the provider\nfunc (d TestEnum) MarshalJSON() (b []byte, err error) {\n\treturn EnumMarshalJSON(testEnumToString, d, \"Test\")\n}\n\n// UnmarshalJSON is Unmarshal the provider type\nfunc (d *TestEnum) UnmarshalJSON(b []byte) (err error) {\n\treturn EnumUnmarshalJSON(b, strToTestEnum, d, Unknown, \"Test\")\n}\n\nfunc testMarshalUnmarshal(t *testing.T, str string, te TestEnum, good bool,\n\tmarshal func(in interface{}) ([]byte, error),\n\tunmarshal func(in []byte, out interface{}) (err error)) {\n\n\tvar s TestEnum\n\terr := unmarshal([]byte(str), &s)\n\tif good {\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, te, s)\n\t} else {\n\t\tassert.Error(t, err)\n\t\tassert.Equal(t, Unknown, s)\n\t}\n\n\tbuf, err := marshal(te)\n\tif good {\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, str, string(buf))\n\t} else {\n\t\tassert.Error(t, err)\n\t\tassert.Nil(t, buf)\n\t}\n}\nfunc testYamlJSON(t *testing.T, str string, te TestEnum, good bool) {\n\ttestYaml(t, str+\"\\n\", te, good)\n\ttestJSON(t, `\"`+str+`\"`, te, good)\n}\nfunc testYaml(t *testing.T, str string, te TestEnum, good bool) {\n\ttestMarshalUnmarshal(t, str, te, good, yaml.Marshal, yaml.Unmarshal)\n}\nfunc testJSON(t *testing.T, str string, te TestEnum, good bool) {\n\ttestMarshalUnmarshal(t, str, te, good, json.Marshal, json.Unmarshal)\n}\n\nfunc TestEnmuMarshalUnMarshal(t *testing.T) {\n\ttestYamlJSON(t, \"test1\", Test1, true)\n\ttestYamlJSON(t, \"test2\", Test2, true)\n\ttestYamlJSON(t, \"test3\", Test3, true)\n\ttestYamlJSON(t, \"test4\", Test4, true)\n\ttestYamlJSON(t, \"unknown\", Unknown, true)\n\n\ttestYamlJSON(t, \"bad\", 10, false)\n\ttestJSON(t, `{\"x\":\"y\"}`, 10, false)\n\ttestYaml(t, \"-bad::\", 10, false)\n}\n\nfunc makeCA(path string, subject *pkix.Name) (*x509.Certificate, *rsa.PrivateKey, error) {\n\t// creating a CA which will be used to sign all of our certificates using the x509 package from the Go Standard Library\n\tcaCert := &x509.Certificate{\n\t\tSerialNumber:          big.NewInt(2019),\n\t\tSubject:               *subject,\n\t\tNotBefore:             time.Now(),\n\t\tNotAfter:              time.Now().AddDate(10*365, 0, 0),\n\t\tIsCA:                  true, // <- indicating this certificate is a CA certificate.\n\t\tExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},\n\t\tKeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,\n\t\tBasicConstraintsValid: true,\n\t}\n\t// generate a private key for the CA\n\tcaKey, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// create the CA certificate\n\tcaBytes, err := x509.CreateCertificate(rand.Reader, caCert, caCert, &caKey.PublicKey, caKey)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Create the CA PEM files\n\tcaPEM := new(bytes.Buffer)\n\tpem.Encode(caPEM, &pem.Block{\n\t\tType:  \"CERTIFICATE\",\n\t\tBytes: caBytes,\n\t})\n\n\tif err := os.WriteFile(path+\"ca.crt\", caPEM.Bytes(), 0644); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcaPrivKeyPEM := new(bytes.Buffer)\n\tpem.Encode(caPrivKeyPEM, &pem.Block{\n\t\tType:  \"RSA PRIVATE KEY\",\n\t\tBytes: x509.MarshalPKCS1PrivateKey(caKey),\n\t})\n\tif err := os.WriteFile(path+\"ca.key\", caPEM.Bytes(), 0644); err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn caCert, caKey, nil\n}\n\nfunc makeCert(path string, caCert *x509.Certificate, caKey *rsa.PrivateKey, subject *pkix.Name, name string) error {\n\tcert := &x509.Certificate{\n\t\tSerialNumber: big.NewInt(1658),\n\t\tSubject:      *subject,\n\t\t//IPAddresses:  []net.IP{net.IPv4(127, 0, 0, 1), net.IPv6loopback},\n\t\tDNSNames:     []string{\"localhost\"},\n\t\tNotBefore:    time.Now(),\n\t\tNotAfter:     time.Now().AddDate(10, 0, 0),\n\t\tSubjectKeyId: []byte{1, 2, 3, 4, 6},\n\t\tExtKeyUsage:  []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},\n\t\tKeyUsage:     x509.KeyUsageDigitalSignature,\n\t}\n\n\tcertKey, err := rsa.GenerateKey(rand.Reader, 4096)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcertBytes, err := x509.CreateCertificate(rand.Reader, cert, caCert, &certKey.PublicKey, caKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcertPEM := new(bytes.Buffer)\n\tpem.Encode(certPEM, &pem.Block{\n\t\tType:  \"CERTIFICATE\",\n\t\tBytes: certBytes,\n\t})\n\tif err := os.WriteFile(path+name+\".crt\", certPEM.Bytes(), 0644); err != nil {\n\t\treturn err\n\t}\n\n\tcertKeyPEM := new(bytes.Buffer)\n\tpem.Encode(certKeyPEM, &pem.Block{\n\t\tType:  \"RSA PRIVATE KEY\",\n\t\tBytes: x509.MarshalPKCS1PrivateKey(certKey),\n\t})\n\treturn os.WriteFile(path+name+\".key\", certKeyPEM.Bytes(), 0644)\n}\n\nfunc TestTLS(t *testing.T) {\n\t// no TLS\n\t_tls := TLS{}\n\tconn, e := _tls.Config()\n\tassert.Nil(t, conn)\n\tassert.Nil(t, e)\n\n\t// only have insecure option\n\t_tls = TLS{\n\t\tInsecure: true,\n\t}\n\tconn, e = _tls.Config()\n\tassert.NotNil(t, conn)\n\tassert.Nil(t, e)\n\n\tpath := GetWorkDir() + \"/certs/\"\n\tos.MkdirAll(path, 0755)\n\tdefer os.RemoveAll(path)\n\n\t//mTLS\n\t_tls = TLS{\n\t\tCA:   filepath.Join(path, \"./ca.crt\"),\n\t\tCert: filepath.Join(path, \"./test.crt\"),\n\t\tKey:  filepath.Join(path, \"./test.key\"),\n\t}\n\tconn, e = _tls.Config()\n\tassert.Nil(t, conn)\n\tassert.NotNil(t, e)\n\n\tsubject := pkix.Name{\n\t\tCountry:            []string{\"Earth\"},\n\t\tOrganization:       []string{\"MegaEase\"},\n\t\tOrganizationalUnit: []string{\"Engineering\"},\n\t\tLocality:           []string{\"Mountain\"},\n\t\tProvince:           []string{\"Asia\"},\n\t\tStreetAddress:      []string{\"Bridge\"},\n\t\tPostalCode:         []string{\"123456\"},\n\t\tSerialNumber:       \"\",\n\t\tCommonName:         \"CA\",\n\t\tNames:              []pkix.AttributeTypeAndValue{},\n\t\tExtraNames:         []pkix.AttributeTypeAndValue{},\n\t}\n\tcaCert, caKey, err := makeCA(path, &subject)\n\tif err != nil {\n\t\tt.Fatalf(\"make CA Certificate error! - %v\", err)\n\t}\n\tt.Log(\"Create the CA certificate successfully.\")\n\n\tsubject.CommonName = \"Server\"\n\tsubject.Organization = []string{\"Server Company\"}\n\tif err := makeCert(path, caCert, caKey, &subject, \"test\"); err != nil {\n\t\tt.Fatal(\"make Server Certificate error!\")\n\t}\n\tt.Log(\"Create and Sign the Server certificate successfully.\")\n\n\tconn, e = _tls.Config()\n\tassert.Nil(t, e)\n\tassert.NotNil(t, conn)\n\n\tmonkey.Patch(tls.LoadX509KeyPair, func(certFile, keyFile string) (tls.Certificate, error) {\n\t\treturn tls.Certificate{}, fmt.Errorf(\"load x509 key pair error\")\n\t})\n\n\tconn, e = _tls.Config()\n\tassert.NotNil(t, e)\n\tassert.Nil(t, conn)\n\tmonkey.UnpatchAll()\n\n\t//TLS\n\t_tls = TLS{\n\t\tCA:       filepath.Join(path, \"./ca.crt\"),\n\t\tInsecure: false,\n\t}\n\tconn, e = _tls.Config()\n\tassert.Nil(t, e)\n\tassert.NotNil(t, conn)\n\tassert.Nil(t, conn.Certificates)\n}\n\nfunc TestNormalize(t *testing.T) {\n\n\t// local value\n\tr := normalize(10, 20, 0, 30)\n\tassert.Equal(t, 20, r)\n\n\t// global value\n\tr = normalize(10, 0, 0, 10)\n\tassert.Equal(t, 10, r)\n\n\t// default value\n\tr = normalize(0, 0, 0, 30)\n\tassert.Equal(t, 30, r)\n}\n\nfunc TestRetry(t *testing.T) {\n\n\tr := Retry{\n\t\tTimes:    3,\n\t\tInterval: 100 * time.Millisecond,\n\t}\n\n\tcnt := 0\n\tf := func() error {\n\t\tif cnt < r.Times {\n\t\t\tcnt++\n\t\t\treturn fmt.Errorf(\"error, cnt=%d\", cnt)\n\t\t}\n\t\treturn nil\n\t}\n\n\terr := DoRetry(\"test\", \"dummy\", \"tag\", r, f)\n\tassert.NotNil(t, err)\n\tassert.Equal(t, r.Times, cnt)\n\n\tcnt = 1\n\terr = DoRetry(\"test\", \"dummy\", \"tag\", r, f)\n\tassert.Nil(t, err)\n\tassert.Equal(t, r.Times, cnt)\n\n\tf = func() error {\n\t\tcnt++\n\t\treturn &ErrNoRetry{\"No Retry Error\"}\n\t}\n\tcnt = 0\n\terr = DoRetry(\"test\", \"dummy\", \"tag\", r, f)\n\tassert.NotNil(t, err)\n\tassert.Equal(t, 1, cnt)\n\tassert.Equal(t, err.Error(), \"No Retry Error\")\n\n}\n\nfunc TestGetWritableDir(t *testing.T) {\n\tfilename := \"\"\n\tdir := MakeDirectory(filename)\n\tassert.Equal(t, GetWorkDir(), dir)\n\n\tfilename = \"./test.txt\"\n\tdir = MakeDirectory(filename)\n\texp, _ := filepath.Abs(filename)\n\tassert.Equal(t, exp, dir)\n\n\tfilename = \"./none/existed/test.txt\"\n\texp, _ = filepath.Abs(filename)\n\tdir = MakeDirectory(filename)\n\tos.RemoveAll(\"./none\")\n\tassert.Equal(t, exp, dir)\n\n\tfilename = \"~/none/existed/test.txt\"\n\thome, err := os.UserHomeDir()\n\tif err != nil {\n\t\thome = os.TempDir()\n\t}\n\texp = filepath.Join(home, \"none/existed/test.txt\")\n\tdir = MakeDirectory(filename)\n\tos.RemoveAll(home + \"/none\")\n\tassert.Equal(t, exp, dir)\n}\n\nfunc TestGetWorkDirFail(t *testing.T) {\n\tdefer monkey.UnpatchAll()\n\tmonkey.Patch(os.Getwd, func() (string, error) {\n\t\treturn \"\", fmt.Errorf(\"error\")\n\t})\n\n\tpath := GetWorkDir()\n\thome, err := os.UserHomeDir()\n\tassert.Nil(t, err)\n\tassert.Equal(t, path, home)\n\n\tmonkey.Patch(os.UserHomeDir, func() (string, error) {\n\t\treturn \"\", fmt.Errorf(\"error\")\n\t})\n\n\tpath = GetWorkDir()\n\tassert.Equal(t, path, os.TempDir())\n\n}\n\nfunc TestMakeDirectoryFail(t *testing.T) {\n\tdefer monkey.UnpatchAll()\n\tmonkey.Patch(os.UserHomeDir, func() (string, error) {\n\t\treturn \"\", fmt.Errorf(\"error\")\n\t})\n\n\tfilename := \"~/test.txt\"\n\tresult := MakeDirectory(filename)\n\tassert.Equal(t, result, filepath.Join(os.TempDir(), filename[2:]))\n\n\tmonkey.Unpatch(os.UserHomeDir)\n\n\tmonkey.Patch(filepath.Abs, func(path string) (string, error) {\n\t\treturn \"\", fmt.Errorf(\"error\")\n\t})\n\tfilename = \"../test.txt\"\n\tresult = MakeDirectory(filename)\n\tassert.Equal(t, result, filepath.Join(GetWorkDir(), \"test.txt\"))\n\n\tmonkey.Unpatch(filepath.Abs)\n\n\tmonkey.Patch(os.MkdirAll, func(string, os.FileMode) error {\n\t\treturn fmt.Errorf(\"error\")\n\t})\n\n\tfilename = \"/not/existed/test.txt\"\n\tresult = MakeDirectory(filename)\n\tassert.Equal(t, result, filepath.Join(GetWorkDir(), \"test.txt\"))\n\n\tmonkey.Unpatch(os.MkdirAll)\n\n}\n\nfunc TestCommandLine(t *testing.T) {\n\ts := CommandLine(\"echo\", []string{\"hello\", \"world\"})\n\tassert.Equal(t, \"echo hello world\", s)\n\n\ts = CommandLine(\"kubectl\", []string{\"get\", \"pod\", \"--all-namespaces\", \"-o\", \"json\"})\n\tassert.Equal(t, \"kubectl get pod --all-namespaces -o json\", s)\n}\n\nfunc TestEscape(t *testing.T) {\n\tassert.Equal(t, \"test\", EscapeQuote(\"test\"))\n\tassert.Equal(t, \"test\", EscapeQuote(\"`test`\"))\n\tassert.Equal(t, `\\'test\\'`, EscapeQuote(\"'test'\"))\n\tassert.Equal(t, `\\\"test\\\"`, EscapeQuote(`\"test\"`))\n\tassert.Equal(t, `\\\\test\\\\`, EscapeQuote(`\\test\\`))\n\n}\n", "/*\n * Copyright (c) 2022, MegaEase\n * All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Package mysql is the client probe for MySQL.\npackage mysql\n\nimport (\n\t\"crypto/tls\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/go-sql-driver/mysql\"\n\t\"github.com/megaease/easeprobe/global\"\n\t\"github.com/megaease/easeprobe/probe/client/conf\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\n// Kind is the type of driver\nconst Kind string = \"MySQL\"\n\n// MySQL is the MySQL client\ntype MySQL struct {\n\tconf.Options `yaml:\",inline\"`\n\ttls          *tls.Config `yaml:\"-\" json:\"-\"`\n\tConnStr      string      `yaml:\"conn_str,omitempty\" json:\"conn_str,omitempty\"`\n}\n\n// New create a Mysql client\nfunc New(opt conf.Options) (*MySQL, error) {\n\n\tvar conn string\n\tif len(opt.Password) > 0 {\n\t\tconn = fmt.Sprintf(\"%s:%s@tcp(%s)/?timeout=%s\",\n\t\t\topt.Username, opt.Password, opt.Host, opt.Timeout().Round(time.Second))\n\t} else {\n\t\tconn = fmt.Sprintf(\"%s@tcp(%s)/?timeout=%s\",\n\t\t\topt.Username, opt.Host, opt.Timeout().Round(time.Second))\n\t}\n\n\ttls, err := opt.TLS.Config()\n\tif err != nil {\n\t\tlog.Errorf(\"[%s / %s / %s] - TLS Config Error - %v\", opt.ProbeKind, opt.ProbeName, opt.ProbeTag, err)\n\t\treturn nil, fmt.Errorf(\"TLS Config Error - %v\", err)\n\t} else if tls != nil {\n\t\tconn += \"&tls=\" + global.DefaultProg\n\t}\n\n\tm := &MySQL{\n\t\tOptions: opt,\n\t\ttls:     tls,\n\t\tConnStr: conn,\n\t}\n\n\tif err := m.checkData(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, nil\n}\n\n// Kind return the name of client\nfunc (r *MySQL) Kind() string {\n\treturn Kind\n}\n\n// checkData do the data checking\nfunc (r *MySQL) checkData() error {\n\n\tfor k := range r.Data {\n\t\tif _, err := r.getSQL(k); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Probe do the health check\nfunc (r *MySQL) Probe() (bool, string) {\n\n\tif r.tls != nil {\n\t\tmysql.RegisterTLSConfig(global.DefaultProg, r.tls)\n\t}\n\n\tdb, err := sql.Open(\"mysql\", r.ConnStr)\n\tif err != nil {\n\t\treturn false, err.Error()\n\t}\n\tdefer db.Close()\n\n\t// Check if we need to query specific data\n\tif len(r.Data) > 0 {\n\t\tif err := r.ProbeWithDataVerification(db); err != nil {\n\t\t\treturn false, err.Error()\n\t\t}\n\t} else {\n\t\tif err := r.ProbeWithPing(db); err != nil {\n\t\t\treturn false, err.Error()\n\t\t}\n\t}\n\n\treturn true, \"Check MySQL Server Successfully!\"\n\n}\n\n// ProbeWithPing do the health check with ping\nfunc (r *MySQL) ProbeWithPing(db *sql.DB) error {\n\tif err := db.Ping(); err != nil {\n\t\treturn err\n\t}\n\trow, err := db.Query(\"show status like \\\"uptime\\\"\") // run a SQL to test\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer row.Close()\n\treturn nil\n}\n\n// ProbeWithDataVerification do the health check with data verification\nfunc (r *MySQL) ProbeWithDataVerification(db *sql.DB) error {\n\tfor k, v := range r.Data {\n\t\tlog.Debugf(\"[%s / %s / %s] - Verifying Data - [%s] : [%s]\", r.ProbeKind, r.ProbeName, r.ProbeTag, k, v)\n\t\tsql, err := r.getSQL(k)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlog.Debugf(\"[%s / %s / %s] - SQL - [%s]\", r.ProbeKind, r.ProbeName, r.ProbeTag, sql)\n\t\trows, err := db.Query(sql)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !rows.Next() {\n\t\t\trows.Close()\n\t\t\treturn fmt.Errorf(\"No data found for [%s]\", k)\n\t\t}\n\t\t//check the value is equal to the value in data\n\t\tvar value string\n\t\tif err := rows.Scan(&value); err != nil {\n\t\t\trows.Close()\n\t\t\treturn err\n\t\t}\n\t\tif value != v {\n\t\t\trows.Close()\n\t\t\treturn fmt.Errorf(\"Value not match for [%s] expected [%s] got [%s] \", k, v, value)\n\t\t}\n\t\trows.Close()\n\t\tlog.Debugf(\"[%s / %s / %s] - Data Verified Successfully! - [%s] : [%s]\", r.ProbeKind, r.ProbeName, r.ProbeTag, k, v)\n\t}\n\treturn nil\n}\n\n// getSQL get the SQL statement\n// input: database:table:column:key:value\n// output: SELECT column FROM database.table WHERE key = value\nfunc (r *MySQL) getSQL(str string) (string, error) {\n\tif len(strings.TrimSpace(str)) == 0 {\n\t\treturn \"\", fmt.Errorf(\"Empty SQL data\")\n\t}\n\tfields := strings.Split(str, \":\")\n\tif len(fields) != 5 {\n\t\treturn \"\", fmt.Errorf(\"Invalid SQL data - [%s]. (syntax: database:table:field:key:value)\", str)\n\t}\n\tdb := global.EscapeQuote(fields[0])\n\ttable := global.EscapeQuote(fields[1])\n\tfield := global.EscapeQuote(fields[2])\n\tkey := global.EscapeQuote(fields[3])\n\tvalue := global.EscapeQuote(fields[4])\n\t//check value is int or not\n\tif _, err := strconv.Atoi(value); err != nil {\n\t\treturn \"\", fmt.Errorf(\"Invalid SQL data - [%s], the value must be int\", str)\n\t}\n\n\tsql := fmt.Sprintf(\"SELECT `%s` FROM `%s`.`%s` WHERE `%s` = %s\", field, db, table, key, value)\n\treturn sql, nil\n}\n", "/*\n * Copyright (c) 2022, MegaEase\n * All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Package postgres is the native client probe for  PostgreSQL\npackage postgres\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/megaease/easeprobe/global\"\n\t\"github.com/megaease/easeprobe/probe/client/conf\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"github.com/uptrace/bun/driver/pgdriver\"\n)\n\n// Kind is the type of driver\nconst Kind string = \"PostgreSQL\"\n\n// revive:disable\n// PostgreSQL is the PostgreSQL client\ntype PostgreSQL struct {\n\tconf.Options  `yaml:\",inline\"`\n\tClientOptions []pgdriver.Option `yaml:\"-\" json:\"-\"`\n}\n\n// revive:enable\n\n// New create a PostgreSQL client\nfunc New(opt conf.Options) (*PostgreSQL, error) {\n\tclientOptions := []pgdriver.Option{\n\t\tpgdriver.WithNetwork(\"tcp\"),\n\t\tpgdriver.WithAddr(opt.Host),\n\t\tpgdriver.WithUser(opt.Username),\n\t\tpgdriver.WithTimeout(opt.Timeout().Round(time.Second)),\n\t\tpgdriver.WithApplicationName(global.OrgProgVer),\n\t}\n\tif len(opt.Password) > 0 {\n\t\tclientOptions = append(clientOptions, pgdriver.WithPassword(opt.Password))\n\t}\n\n\ttls, err := opt.TLS.Config()\n\tif err != nil {\n\t\tlog.Errorf(\"[%s / %s / %s] - TLS Config Error - %v\", opt.ProbeKind, opt.ProbeName, opt.ProbeTag, err)\n\t\treturn nil, fmt.Errorf(\"TLS Config Error - %v\", err)\n\t} else if tls != nil {\n\t\ttls.InsecureSkipVerify = true\n\t}\n\t// if the tls is nil which means `sslmode=disable`\n\tclientOptions = append(clientOptions, pgdriver.WithTLSConfig(tls))\n\n\tpg := &PostgreSQL{\n\t\tOptions:       opt,\n\t\tClientOptions: clientOptions,\n\t}\n\tif err := pg.checkData(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn pg, nil\n}\n\n// Kind return the name of client\nfunc (r *PostgreSQL) Kind() string {\n\treturn Kind\n}\n\n// checkData do the data checking\nfunc (r *PostgreSQL) checkData() error {\n\n\tfor k := range r.Data {\n\t\t_, _, err := r.getSQL(k)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Probe do the health check\nfunc (r *PostgreSQL) Probe() (bool, string) {\n\n\tif len(r.Data) > 0 {\n\t\treturn r.ProbeWithDataChecking()\n\t}\n\treturn r.ProbeWithPing()\n}\n\n// ProbeWithPing do the health check with ping & Select 1;\nfunc (r *PostgreSQL) ProbeWithPing() (bool, string) {\n\tr.ClientOptions = append(r.ClientOptions, pgdriver.WithDatabase(\"template1\"))\n\tdb := sql.OpenDB(pgdriver.NewConnector(r.ClientOptions...))\n\tif db == nil {\n\t\treturn false, \"OpenDB error\"\n\t}\n\tdefer db.Close()\n\n\tif err := db.Ping(); err != nil {\n\t\treturn false, err.Error()\n\t}\n\n\t// run a SQL to test\n\trow, err := db.Query(`SELECT 1`)\n\tif err != nil {\n\t\treturn false, err.Error()\n\t}\n\trow.Close()\n\treturn true, \"Check PostgreSQL Server Successfully!\"\n}\n\n// ProbeWithDataChecking do the health check with data checking\nfunc (r *PostgreSQL) ProbeWithDataChecking() (bool, string) {\n\tif len(r.Data) == 0 {\n\t\tlog.Warnf(\"[%s / %s / %s] - No data found, use ping instead\", r.ProbeKind, r.ProbeName, r.ProbeTag)\n\t\treturn r.ProbeWithPing()\n\t}\n\n\tfor k, v := range r.Data {\n\t\tif ok, msg := r.verifyData(k, v); !ok {\n\t\t\treturn ok, msg\n\t\t}\n\t}\n\n\treturn true, \"Check PostgreSQL Server Successfully!\"\n}\n\nfunc (r *PostgreSQL) verifyData(k, v string) (bool, string) {\n\tlog.Debugf(\"[%s / %s / %s] - Verifying Data - [%s] : [%s]\", r.ProbeKind, r.ProbeName, r.ProbeTag, k, v)\n\t//connect to the database\n\tdbName, sqlstr, err := r.getSQL(k)\n\tif err != nil {\n\t\treturn false, fmt.Sprintf(\"Invalid SQL data - [%s], %v\", v, err)\n\t}\n\tclientOptions := append(r.ClientOptions, pgdriver.WithDatabase(dbName))\n\tdb := sql.OpenDB(pgdriver.NewConnector(clientOptions...))\n\tif db == nil {\n\t\treturn false, \"OpenDB error\"\n\t}\n\tdefer db.Close()\n\n\t// query the data\n\tlog.Debugf(\"[%s / %s / %s] - SQL - [%s]\", r.ProbeKind, r.ProbeName, r.ProbeTag, sqlstr)\n\trows, err := db.Query(sqlstr)\n\tif err != nil {\n\t\treturn false, fmt.Sprintf(\"Query error - [%s], %v\", v, err)\n\t}\n\tdefer rows.Close()\n\n\tif !rows.Next() {\n\t\treturn false, fmt.Sprintf(\"No data found for [%s]\", k)\n\t}\n\t//check the value is equal to the value in data\n\tvar value string\n\tif err := rows.Scan(&value); err != nil {\n\t\treturn false, err.Error()\n\t}\n\tif value != v {\n\t\treturn false, fmt.Sprintf(\"Value not match for [%s] expected [%s] got [%s] \", k, v, value)\n\t}\n\n\tlog.Debugf(\"[%s / %s / %s] - Data Verified Successfully! - [%s] : [%s]\", r.ProbeKind, r.ProbeName, r.ProbeTag, k, v)\n\treturn true, \"Check PostgreSQL Server Successfully!\"\n}\n\n// getSQL get the SQL statement\n// input: database:table:column:key:value\n// output: SELECT column FROM database.table WHERE key = value\nfunc (r *PostgreSQL) getSQL(str string) (string, string, error) {\n\tif len(strings.TrimSpace(str)) == 0 {\n\t\treturn \"\", \"\", fmt.Errorf(\"Empty SQL data\")\n\t}\n\tfields := strings.Split(str, \":\")\n\tif len(fields) != 5 {\n\t\treturn \"\", \"\", fmt.Errorf(\"Invalid SQL data - [%s]. (syntax: database:table:field:key:value)\", str)\n\t}\n\tdb := global.EscapeQuote(fields[0])\n\ttable := global.EscapeQuote(fields[1])\n\tfield := global.EscapeQuote(fields[2])\n\tkey := global.EscapeQuote(fields[3])\n\tvalue := global.EscapeQuote(fields[4])\n\t//check value is int or not\n\tif _, err := strconv.Atoi(value); err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"Invalid SQL data - [%s], the value must be int\", str)\n\t}\n\n\tsql := fmt.Sprintf(`SELECT \"%s\" FROM \"%s\" WHERE \"%s\" = %s`, field, table, key, value)\n\treturn db, sql, nil\n}\n"], "filenames": ["global/global.go", "global/global_test.go", "probe/client/mysql/mysql.go", "probe/client/postgres/postgres.go"], "buggy_code_start_loc": [313, 440, 109, 193], "buggy_code_end_loc": [313, 440, 175, 204], "fixing_code_start_loc": [314, 441, 109, 193], "fixing_code_end_loc": [333, 450, 190, 204], "type": "CWE-89", "message": "EaseProbe is a tool that can do health/status checking. An SQL injection issue was discovered in EaseProbe before 2.1.0 when using MySQL/PostgreSQL data checking. This problem has been fixed in v2.1.0.", "other": {"cve": {"id": "CVE-2023-33967", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-31T18:15:09.603", "lastModified": "2023-06-07T17:58:21.197", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "EaseProbe is a tool that can do health/status checking. An SQL injection issue was discovered in EaseProbe before 2.1.0 when using MySQL/PostgreSQL data checking. This problem has been fixed in v2.1.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.5, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:megaease:easeprobe:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.0", "matchCriteriaId": "80D94939-ED69-452D-BFAF-BDB67A4110BA"}]}]}], "references": [{"url": "https://github.com/megaease/easeprobe/commit/caaf5860df2aaa76acd29bc40ec9a578d0b1d6e1", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/megaease/easeprobe/pull/330", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/megaease/easeprobe/releases/tag/v2.1.0", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/megaease/easeprobe/security/advisories/GHSA-4c32-w6c7-77x4", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/megaease/easeprobe/commit/caaf5860df2aaa76acd29bc40ec9a578d0b1d6e1"}}