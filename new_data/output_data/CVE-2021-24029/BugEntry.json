{"buggy_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n#include <quic/server/state/ServerStateMachine.h>\n\n#include <quic/api/QuicTransportFunctions.h>\n#include <quic/common/BufUtil.h>\n#include <quic/congestion_control/CongestionControllerFactory.h>\n#include <quic/congestion_control/TokenlessPacer.h>\n#include <quic/fizz/handshake/FizzCryptoFactory.h>\n#include <quic/flowcontrol/QuicFlowController.h>\n#include <quic/handshake/TransportParameters.h>\n#include <quic/logging/QLoggerConstants.h>\n#include <quic/state/QuicPacingFunctions.h>\n#include <quic/state/QuicStreamFunctions.h>\n#include <quic/state/QuicTransportStatsCallback.h>\n#include <quic/state/SimpleFrameFunctions.h>\n#include <quic/state/stream/StreamReceiveHandlers.h>\n#include <quic/state/stream/StreamSendHandlers.h>\n\nnamespace quic {\nusing namespace std::chrono_literals;\n\nnamespace {\nusing PacketDropReason = QuicTransportStatsCallback::PacketDropReason;\nconstexpr size_t kConnIdEncodingRetryLimit = 16;\n\nbool maybeNATRebinding(\n    const folly::SocketAddress& newPeerAddress,\n    const folly::SocketAddress& oldPeerAddress) {\n  auto& newIPAddr = newPeerAddress.getIPAddress();\n  auto& oldIPAddr = oldPeerAddress.getIPAddress();\n\n  // Port changed\n  if (newIPAddr == oldIPAddr) {\n    return true;\n  }\n\n  return newIPAddr.isV4() && oldIPAddr.isV4() &&\n      newIPAddr.inSubnet(oldIPAddr, 24);\n}\n\nCongestionAndRttState moveCurrentCongestionAndRttState(\n    QuicServerConnectionState& conn) {\n  CongestionAndRttState state;\n  state.peerAddress = conn.peerAddress;\n  state.recordTime = Clock::now();\n  state.congestionController = std::move(conn.congestionController);\n  state.srtt = conn.lossState.srtt;\n  state.lrtt = conn.lossState.lrtt;\n  state.rttvar = conn.lossState.rttvar;\n  state.mrtt = conn.lossState.mrtt;\n  return state;\n}\n\nvoid resetCongestionAndRttState(QuicServerConnectionState& conn) {\n  CHECK(conn.congestionControllerFactory)\n      << \"CongestionControllerFactory is not set.\";\n  conn.congestionController =\n      conn.congestionControllerFactory->makeCongestionController(\n          conn, conn.transportSettings.defaultCongestionController);\n  conn.lossState.srtt = 0us;\n  conn.lossState.lrtt = 0us;\n  conn.lossState.rttvar = 0us;\n  conn.lossState.mrtt = kDefaultMinRtt;\n}\n\nvoid recoverOrResetCongestionAndRttState(\n    QuicServerConnectionState& conn,\n    const folly::SocketAddress& peerAddress) {\n  auto& lastState = conn.migrationState.lastCongestionAndRtt;\n  if (lastState && lastState->peerAddress == peerAddress &&\n      (Clock::now() - lastState->recordTime <=\n       kTimeToRetainLastCongestionAndRttState)) {\n    // recover from matched non-stale state\n    conn.congestionController = std::move(lastState->congestionController);\n    conn.lossState.srtt = lastState->srtt;\n    conn.lossState.lrtt = lastState->lrtt;\n    conn.lossState.rttvar = lastState->rttvar;\n    conn.lossState.mrtt = lastState->mrtt;\n    conn.migrationState.lastCongestionAndRtt = folly::none;\n  } else {\n    resetCongestionAndRttState(conn);\n  }\n}\n\nvoid setExperimentalSettings(QuicServerConnectionState& conn) {\n  conn.lossState.reorderingThreshold =\n      std::numeric_limits<decltype(conn.lossState.reorderingThreshold)>::max();\n}\n} // namespace\n\nvoid processClientInitialParams(\n    QuicServerConnectionState& conn,\n    const ClientTransportParameters& clientParams) {\n  // TODO validate that we didn't receive original connection ID, stateless\n  // reset token, or preferred address.\n  auto maxData = getIntegerParameter(\n      TransportParameterId::initial_max_data, clientParams.parameters);\n  auto maxStreamDataBidiLocal = getIntegerParameter(\n      TransportParameterId::initial_max_stream_data_bidi_local,\n      clientParams.parameters);\n  auto maxStreamDataBidiRemote = getIntegerParameter(\n      TransportParameterId::initial_max_stream_data_bidi_remote,\n      clientParams.parameters);\n  auto maxStreamDataUni = getIntegerParameter(\n      TransportParameterId::initial_max_stream_data_uni,\n      clientParams.parameters);\n  auto maxStreamsBidi = getIntegerParameter(\n      TransportParameterId::initial_max_streams_bidi, clientParams.parameters);\n  auto maxStreamsUni = getIntegerParameter(\n      TransportParameterId::initial_max_streams_uni, clientParams.parameters);\n  auto idleTimeout = getIntegerParameter(\n      TransportParameterId::idle_timeout, clientParams.parameters);\n  auto ackDelayExponent = getIntegerParameter(\n      TransportParameterId::ack_delay_exponent, clientParams.parameters);\n  auto packetSize = getIntegerParameter(\n      TransportParameterId::max_packet_size, clientParams.parameters);\n  auto partialReliability = getIntegerParameter(\n      static_cast<TransportParameterId>(kPartialReliabilityParameterId),\n      clientParams.parameters);\n  auto activeConnectionIdLimit = getIntegerParameter(\n      TransportParameterId::active_connection_id_limit,\n      clientParams.parameters);\n  auto d6dBasePMTU = getIntegerParameter(\n      static_cast<TransportParameterId>(kD6DBasePMTUParameterId),\n      clientParams.parameters);\n  auto d6dRaiseTimeout = getIntegerParameter(\n      static_cast<TransportParameterId>(kD6DRaiseTimeoutParameterId),\n      clientParams.parameters);\n  auto d6dProbeTimeout = getIntegerParameter(\n      static_cast<TransportParameterId>(kD6DProbeTimeoutParameterId),\n      clientParams.parameters);\n  auto minAckDelay = getIntegerParameter(\n      TransportParameterId::min_ack_delay, clientParams.parameters);\n  if (conn.version == QuicVersion::QUIC_DRAFT) {\n    auto initialSourceConnId = getConnIdParameter(\n        TransportParameterId::initial_source_connection_id,\n        clientParams.parameters);\n    if (!initialSourceConnId ||\n        initialSourceConnId.value() !=\n            conn.readCodec->getClientConnectionId()) {\n      throw QuicTransportException(\n          \"Initial CID does not match.\",\n          TransportErrorCode::TRANSPORT_PARAMETER_ERROR);\n    }\n  }\n\n  // TODO Validate active_connection_id_limit\n  if (packetSize && *packetSize < kMinMaxUDPPayload) {\n    throw QuicTransportException(\n        folly::to<std::string>(\n            \"Max packet size too small. received max_packetSize = \",\n            *packetSize),\n        TransportErrorCode::TRANSPORT_PARAMETER_ERROR);\n  }\n\n  VLOG(10) << \"Client advertised flow control \";\n  VLOG(10) << \"conn=\" << maxData.value_or(0);\n  VLOG(10) << \" stream bidi local=\" << maxStreamDataBidiLocal.value_or(0)\n           << \" \";\n  VLOG(10) << \" stream bidi remote=\" << maxStreamDataBidiRemote.value_or(0)\n           << \" \";\n  VLOG(10) << \" stream uni=\" << maxStreamDataUni.value_or(0) << \" \";\n  VLOG(10) << conn;\n  conn.flowControlState.peerAdvertisedMaxOffset = maxData.value_or(0);\n  conn.flowControlState.peerAdvertisedInitialMaxStreamOffsetBidiLocal =\n      maxStreamDataBidiLocal.value_or(0);\n  conn.flowControlState.peerAdvertisedInitialMaxStreamOffsetBidiRemote =\n      maxStreamDataBidiRemote.value_or(0);\n  conn.flowControlState.peerAdvertisedInitialMaxStreamOffsetUni =\n      maxStreamDataUni.value_or(0);\n  conn.streamManager->setMaxLocalBidirectionalStreams(\n      maxStreamsBidi.value_or(0));\n  conn.streamManager->setMaxLocalUnidirectionalStreams(\n      maxStreamsUni.value_or(0));\n  conn.peerIdleTimeout = std::chrono::milliseconds(idleTimeout.value_or(0));\n  conn.peerIdleTimeout = timeMin(conn.peerIdleTimeout, kMaxIdleTimeout);\n  if (ackDelayExponent && *ackDelayExponent > kMaxAckDelayExponent) {\n    throw QuicTransportException(\n        \"ack_delay_exponent too large\",\n        TransportErrorCode::TRANSPORT_PARAMETER_ERROR);\n  }\n  conn.peerAckDelayExponent =\n      ackDelayExponent.value_or(kDefaultAckDelayExponent);\n  if (minAckDelay.hasValue()) {\n    conn.peerMinAckDelay = std::chrono::microseconds(minAckDelay.value());\n  }\n\n  // Default to max because we can probe PMTU now, and this will be the upper\n  // limit\n  uint64_t maxUdpPayloadSize = kDefaultMaxUDPPayload;\n  if (packetSize) {\n    maxUdpPayloadSize = std::min(*packetSize, maxUdpPayloadSize);\n    conn.peerMaxUdpPayloadSize = maxUdpPayloadSize;\n    if (conn.transportSettings.canIgnorePathMTU) {\n      if (*packetSize > kDefaultMaxUDPPayload) {\n        // A good peer should never set oversized limit, so to be safe we\n        // fallback to default\n        conn.udpSendPacketLen = kDefaultUDPSendPacketLen;\n      } else {\n        // Otherwise, canIgnorePathMTU forces us to immediately set\n        // udpSendPacketLen\n        // TODO: rename \"canIgnorePathMTU\" to \"forciblySetPathMTU\"\n        conn.udpSendPacketLen = maxUdpPayloadSize;\n      }\n    }\n  }\n\n  conn.peerActiveConnectionIdLimit =\n      activeConnectionIdLimit.value_or(kDefaultActiveConnectionIdLimit);\n\n  if (partialReliability && *partialReliability != 0 &&\n      conn.transportSettings.partialReliabilityEnabled) {\n    conn.partialReliabilityEnabled = true;\n  }\n  VLOG(10) << \"conn.partialReliabilityEnabled=\"\n           << conn.partialReliabilityEnabled;\n\n  if (conn.transportSettings.d6dConfig.enabled) {\n    // Sanity check\n    if (d6dBasePMTU) {\n      if (*d6dBasePMTU >= kMinMaxUDPPayload &&\n          *d6dBasePMTU <= kDefaultMaxUDPPayload) {\n        // The reason to take the max is because we don't want d6d to send\n        // probes with a smaller packet size than udpSendPacketLen, which would\n        // be useless and cause meaningless delay on finding the upper bound.\n        conn.d6d.basePMTU = std::max(*d6dBasePMTU, conn.udpSendPacketLen);\n        conn.d6d.maxPMTU = maxUdpPayloadSize;\n        VLOG(10) << \"conn.d6d.basePMTU=\" << conn.d6d.basePMTU;\n\n        // Start from base\n        conn.d6d.state = D6DMachineState::BASE;\n        conn.d6d.meta.lastNonSearchState = D6DMachineState::DISABLED;\n        conn.d6d.meta.timeLastNonSearchState = Clock::now();\n\n        // Temporary, should be removed after transport knob pipeline works\n        conn.d6d.noBlackholeDetection = true;\n      } else {\n        LOG(ERROR) << \"client d6dBasePMTU fails sanity check: \" << *d6dBasePMTU;\n        // We treat base pmtu transport param as client's swich to activate d6d,\n        // so not receiving that means there's no need to configure the rest d6d\n        // params\n        return;\n      }\n    }\n\n    if (d6dRaiseTimeout) {\n      if (*d6dRaiseTimeout >= kMinD6DRaiseTimeout.count()) {\n        conn.d6d.raiseTimeout = std::chrono::seconds(*d6dRaiseTimeout);\n        VLOG(10) << \"conn.d6d.raiseTimeout=\" << conn.d6d.raiseTimeout.count();\n      } else {\n        LOG(ERROR) << \"client d6dRaiseTimeout fails sanity check: \"\n                   << *d6dRaiseTimeout;\n      }\n    }\n\n    if (d6dProbeTimeout) {\n      if (*d6dProbeTimeout >= kMinD6DProbeTimeout.count()) {\n        conn.d6d.probeTimeout = std::chrono::seconds(*d6dProbeTimeout);\n        VLOG(10) << \"conn.d6d.probeTimeout=\" << conn.d6d.probeTimeout.count();\n      } else {\n        LOG(ERROR) << \"client d6dProbeTimeout fails sanity check: \"\n                   << *d6dProbeTimeout;\n      }\n    }\n  }\n}\n\nvoid updateHandshakeState(QuicServerConnectionState& conn) {\n  // Zero RTT read cipher is available after chlo is processed with the\n  // condition that early data attempt is accepted.\n  auto handshakeLayer = conn.serverHandshakeLayer;\n  auto zeroRttReadCipher = handshakeLayer->getZeroRttReadCipher();\n  auto zeroRttHeaderCipher = handshakeLayer->getZeroRttReadHeaderCipher();\n  // One RTT write cipher is available at Fizz layer after chlo is processed.\n  // However, the cipher is only exported to QUIC if early data attempt is\n  // accepted. Otherwise, the cipher will be available after cfin is\n  // processed.\n  auto oneRttWriteCipher = handshakeLayer->getOneRttWriteCipher();\n  // One RTT read cipher is available after cfin is processed.\n  auto oneRttReadCipher = handshakeLayer->getOneRttReadCipher();\n\n  auto oneRttWriteHeaderCipher = handshakeLayer->getOneRttWriteHeaderCipher();\n  auto oneRttReadHeaderCipher = handshakeLayer->getOneRttReadHeaderCipher();\n\n  if (zeroRttReadCipher) {\n    if (conn.qLogger) {\n      conn.qLogger->addTransportStateUpdate(kDerivedZeroRttReadCipher);\n    }\n    QUIC_TRACE(fst_trace, conn, \"derived 0-rtt read cipher\");\n    conn.readCodec->setZeroRttReadCipher(std::move(zeroRttReadCipher));\n  }\n  if (zeroRttHeaderCipher) {\n    conn.readCodec->setZeroRttHeaderCipher(std::move(zeroRttHeaderCipher));\n  }\n  if (oneRttWriteHeaderCipher) {\n    conn.oneRttWriteHeaderCipher = std::move(oneRttWriteHeaderCipher);\n  }\n  if (oneRttReadHeaderCipher) {\n    conn.readCodec->setOneRttHeaderCipher(std::move(oneRttReadHeaderCipher));\n  }\n\n  if (oneRttWriteCipher) {\n    if (conn.qLogger) {\n      conn.qLogger->addTransportStateUpdate(kDerivedOneRttWriteCipher);\n    }\n    QUIC_TRACE(fst_trace, conn, \"derived 1-rtt write cipher\");\n    CHECK(!conn.oneRttWriteCipher.get());\n    conn.oneRttWriteCipher = std::move(oneRttWriteCipher);\n\n    updatePacingOnKeyEstablished(conn);\n\n    // We negotiate the transport parameters whenever we have the 1-RTT write\n    // keys available.\n    auto clientParams = handshakeLayer->getClientTransportParams();\n    if (!clientParams) {\n      throw QuicTransportException(\n          \"No client transport params\",\n          TransportErrorCode::TRANSPORT_PARAMETER_ERROR);\n    }\n    processClientInitialParams(conn, std::move(*clientParams));\n  }\n  if (oneRttReadCipher) {\n    if (conn.qLogger) {\n      conn.qLogger->addTransportStateUpdate(kDerivedOneRttReadCipher);\n    }\n    QUIC_TRACE(fst_trace, conn, \"derived 1-rtt read cipher\");\n    // Clear limit because CFIN is received at this point\n    conn.writableBytesLimit = folly::none;\n    conn.readCodec->setOneRttReadCipher(std::move(oneRttReadCipher));\n  }\n  auto handshakeReadCipher = handshakeLayer->getHandshakeReadCipher();\n  auto handshakeReadHeaderCipher =\n      handshakeLayer->getHandshakeReadHeaderCipher();\n  if (handshakeReadCipher) {\n    CHECK(handshakeReadHeaderCipher);\n    conn.readCodec->setHandshakeReadCipher(std::move(handshakeReadCipher));\n    conn.readCodec->setHandshakeHeaderCipher(\n        std::move(handshakeReadHeaderCipher));\n  }\n  if (handshakeLayer->isHandshakeDone()) {\n    CHECK(conn.oneRttWriteCipher);\n    if (conn.version != QuicVersion::MVFST_D24 && !conn.sentHandshakeDone) {\n      sendSimpleFrame(conn, HandshakeDoneFrame());\n      conn.sentHandshakeDone = true;\n    }\n  }\n}\n\nbool validateAndUpdateSourceToken(\n    QuicServerConnectionState& conn,\n    std::vector<folly::IPAddress> sourceAddresses) {\n  DCHECK(conn.peerAddress.isInitialized());\n  bool foundMatch = false;\n  for (int ii = sourceAddresses.size() - 1; ii >= 0; --ii) {\n    // TODO T33014230 subnet matching\n    if (conn.peerAddress.getIPAddress() == sourceAddresses[ii]) {\n      foundMatch = true;\n      // If peer address is found in the token, move the element to the end\n      // of vector to increase its favorability.\n      sourceAddresses.erase(sourceAddresses.begin() + ii);\n      sourceAddresses.push_back(conn.peerAddress.getIPAddress());\n    }\n  }\n  conn.sourceTokenMatching = foundMatch;\n  bool acceptZeroRtt = foundMatch;\n  if (!foundMatch) {\n    // Add peer address to token for next resumption\n    if (sourceAddresses.size() >= kMaxNumTokenSourceAddresses) {\n      sourceAddresses.erase(sourceAddresses.begin());\n    }\n    sourceAddresses.push_back(conn.peerAddress.getIPAddress());\n\n    switch (conn.transportSettings.zeroRttSourceTokenMatchingPolicy) {\n      case ZeroRttSourceTokenMatchingPolicy::REJECT_IF_NO_EXACT_MATCH:\n        acceptZeroRtt = false;\n        break;\n      case ZeroRttSourceTokenMatchingPolicy::LIMIT_IF_NO_EXACT_MATCH:\n        acceptZeroRtt = true;\n        conn.writableBytesLimit =\n            conn.transportSettings.limitedCwndInMss * conn.udpSendPacketLen;\n        break;\n    }\n  }\n  // Save the source token so that it can be written to client via NST later\n  conn.tokenSourceAddresses = std::move(sourceAddresses);\n\n  return acceptZeroRtt;\n}\n\nvoid updateWritableByteLimitOnRecvPacket(QuicServerConnectionState& conn) {\n  // When we receive a packet we increase the limit again. The reasoning this is\n  // that a peer can do the same by opening a new connection.\n  if (conn.writableBytesLimit) {\n    conn.writableBytesLimit = *conn.writableBytesLimit +\n        conn.transportSettings.limitedCwndInMss * conn.udpSendPacketLen;\n  }\n}\n\nvoid updateTransportParamsFromTicket(\n    QuicServerConnectionState& conn,\n    uint64_t idleTimeout,\n    uint64_t maxRecvPacketSize,\n    uint64_t initialMaxData,\n    uint64_t initialMaxStreamDataBidiLocal,\n    uint64_t initialMaxStreamDataBidiRemote,\n    uint64_t initialMaxStreamDataUni,\n    uint64_t initialMaxStreamsBidi,\n    uint64_t initialMaxStreamsUni) {\n  conn.transportSettings.idleTimeout = std::chrono::milliseconds(idleTimeout);\n  conn.transportSettings.maxRecvPacketSize = maxRecvPacketSize;\n\n  conn.transportSettings.advertisedInitialConnectionWindowSize = initialMaxData;\n  conn.transportSettings.advertisedInitialBidiLocalStreamWindowSize =\n      initialMaxStreamDataBidiLocal;\n  conn.transportSettings.advertisedInitialBidiRemoteStreamWindowSize =\n      initialMaxStreamDataBidiRemote;\n  conn.transportSettings.advertisedInitialUniStreamWindowSize =\n      initialMaxStreamDataUni;\n  updateFlowControlStateWithSettings(\n      conn.flowControlState, conn.transportSettings);\n\n  conn.transportSettings.advertisedInitialMaxStreamsBidi =\n      initialMaxStreamsBidi;\n  conn.transportSettings.advertisedInitialMaxStreamsUni = initialMaxStreamsUni;\n}\n\nvoid onConnectionMigration(\n    QuicServerConnectionState& conn,\n    const folly::SocketAddress& newPeerAddress,\n    bool isIntentional) {\n  if (conn.migrationState.numMigrations >= kMaxNumMigrationsAllowed) {\n    if (conn.qLogger) {\n      conn.qLogger->addPacketDrop(\n          0,\n          QuicTransportStatsCallback::toString(\n              PacketDropReason::PEER_ADDRESS_CHANGE));\n    }\n    QUIC_STATS(\n        conn.statsCallback,\n        onPacketDropped,\n        PacketDropReason::PEER_ADDRESS_CHANGE);\n    throw QuicTransportException(\n        \"Too many migrations\", TransportErrorCode::INVALID_MIGRATION);\n  }\n  ++conn.migrationState.numMigrations;\n\n  bool hasPendingPathChallenge = conn.pendingEvents.pathChallenge.has_value();\n  // Clear any pending path challenge frame that is not sent\n  conn.pendingEvents.pathChallenge = folly::none;\n\n  auto& previousPeerAddresses = conn.migrationState.previousPeerAddresses;\n  auto it = std::find(\n      previousPeerAddresses.begin(),\n      previousPeerAddresses.end(),\n      newPeerAddress);\n  if (it == previousPeerAddresses.end()) {\n    // Send new path challenge\n    uint64_t pathData;\n    folly::Random::secureRandom(&pathData, sizeof(pathData));\n    conn.pendingEvents.pathChallenge = PathChallengeFrame(pathData);\n\n    // If we are already in the middle of a migration reset\n    // the available bytes in the rate-limited window, but keep the\n    // window.\n    conn.pathValidationLimiter =\n        std::make_unique<PendingPathRateLimiter>(conn.udpSendPacketLen);\n  } else {\n    previousPeerAddresses.erase(it);\n  }\n\n  // At this point, path validation scheduled, writable bytes limit set\n  // However if this is NAT rebinding, keep congestion state unchanged\n  bool isNATRebinding = maybeNATRebinding(newPeerAddress, conn.peerAddress);\n\n  // Cancel current path validation if any\n  if (hasPendingPathChallenge || conn.outstandingPathValidation) {\n    conn.pendingEvents.schedulePathValidationTimeout = false;\n    conn.outstandingPathValidation = folly::none;\n\n    // Only change congestion & rtt state if not NAT rebinding\n    if (!isNATRebinding) {\n      recoverOrResetCongestionAndRttState(conn, newPeerAddress);\n    }\n  } else {\n    // Only add validated addresses to previousPeerAddresses\n    conn.migrationState.previousPeerAddresses.push_back(conn.peerAddress);\n\n    // Only change congestion & rtt state if not NAT rebinding\n    if (!isNATRebinding) {\n      // Current peer address is validated,\n      // remember its congestion state and rtt stats\n      CongestionAndRttState state = moveCurrentCongestionAndRttState(conn);\n      recoverOrResetCongestionAndRttState(conn, newPeerAddress);\n      conn.migrationState.lastCongestionAndRtt = std::move(state);\n    }\n  }\n\n  if (conn.qLogger) {\n    conn.qLogger->addConnectionMigrationUpdate(isIntentional);\n  }\n  conn.peerAddress = newPeerAddress;\n}\n\nvoid onServerReadData(\n    QuicServerConnectionState& conn,\n    ServerEvents::ReadData& readData) {\n  switch (conn.state) {\n    case ServerState::Open:\n      onServerReadDataFromOpen(conn, readData);\n      return;\n    case ServerState::Closed:\n      onServerReadDataFromClosed(conn, readData);\n      return;\n  }\n}\n\nvoid handleCipherUnavailable(\n    CipherUnavailable* originalData,\n    QuicServerConnectionState& conn,\n    size_t packetSize,\n    ServerEvents::ReadData& readData) {\n  if (!originalData->packet || originalData->packet->empty()) {\n    VLOG(10) << \"drop because no data \" << conn;\n    if (conn.qLogger) {\n      conn.qLogger->addPacketDrop(packetSize, kNoData);\n    }\n    QUIC_TRACE(packet_drop, conn, \"no_data\");\n    return;\n  }\n  if (originalData->protectionType != ProtectionType::ZeroRtt &&\n      originalData->protectionType != ProtectionType::KeyPhaseZero) {\n    VLOG(10) << \"drop because unexpected protection level \" << conn;\n    if (conn.qLogger) {\n      conn.qLogger->addPacketDrop(packetSize, kUnexpectedProtectionLevel);\n    }\n    QUIC_TRACE(packet_drop, conn, \"unexpected_protection_level\");\n    return;\n  }\n\n  size_t combinedSize =\n      (conn.pendingZeroRttData ? conn.pendingZeroRttData->size() : 0) +\n      (conn.pendingOneRttData ? conn.pendingOneRttData->size() : 0);\n  if (combinedSize >= conn.transportSettings.maxPacketsToBuffer) {\n    VLOG(10) << \"drop because max buffered \" << conn;\n    if (conn.qLogger) {\n      conn.qLogger->addPacketDrop(packetSize, kMaxBuffered);\n    }\n    QUIC_TRACE(packet_drop, conn, \"max_buffered\");\n    return;\n  }\n\n  auto& pendingData = originalData->protectionType == ProtectionType::ZeroRtt\n      ? conn.pendingZeroRttData\n      : conn.pendingOneRttData;\n  if (pendingData) {\n    QUIC_TRACE(\n        packet_buffered,\n        conn,\n        originalData->packetNum,\n        originalData->protectionType,\n        packetSize);\n    if (conn.qLogger) {\n      conn.qLogger->addPacketBuffered(\n          originalData->packetNum, originalData->protectionType, packetSize);\n    }\n    ServerEvents::ReadData pendingReadData;\n    pendingReadData.peer = readData.peer;\n    pendingReadData.networkData = NetworkDataSingle(\n        std::move(originalData->packet), readData.networkData.receiveTimePoint);\n    pendingData->emplace_back(std::move(pendingReadData));\n    VLOG(10) << \"Adding pending data to \"\n             << toString(originalData->protectionType)\n             << \" buffer size=\" << pendingData->size() << \" \" << conn;\n  } else {\n    VLOG(10) << \"drop because \" << toString(originalData->protectionType)\n             << \" buffer no longer available \" << conn;\n    if (conn.qLogger) {\n      conn.qLogger->addPacketDrop(packetSize, kBufferUnavailable);\n    }\n    QUIC_TRACE(packet_drop, conn, \"buffer_unavailable\");\n  }\n}\n\nvoid onServerReadDataFromOpen(\n    QuicServerConnectionState& conn,\n    ServerEvents::ReadData& readData) {\n  CHECK_EQ(conn.state, ServerState::Open);\n  // Don't bother parsing if the data is empty.\n  if (!readData.networkData.data ||\n      readData.networkData.data->computeChainDataLength() == 0) {\n    return;\n  }\n  if (!conn.readCodec) {\n    // First packet from the peer\n    folly::io::Cursor cursor(readData.networkData.data.get());\n    auto initialByte = cursor.readBE<uint8_t>();\n    auto parsedLongHeader = parseLongHeaderInvariant(initialByte, cursor);\n    if (!parsedLongHeader) {\n      VLOG(4) << \"Could not parse initial packet header\";\n      if (conn.qLogger) {\n        conn.qLogger->addPacketDrop(\n            0,\n            QuicTransportStatsCallback::toString(\n                PacketDropReason::PARSE_ERROR));\n      }\n      QUIC_STATS(\n          conn.statsCallback, onPacketDropped, PacketDropReason::PARSE_ERROR);\n      return;\n    }\n    QuicVersion version = parsedLongHeader->invariant.version;\n    if (version == QuicVersion::VERSION_NEGOTIATION) {\n      VLOG(4) << \"Server droppiong VN packet\";\n      if (conn.qLogger) {\n        conn.qLogger->addPacketDrop(\n            0,\n            QuicTransportStatsCallback::toString(\n                PacketDropReason::INVALID_PACKET));\n      }\n      QUIC_STATS(\n          conn.statsCallback,\n          onPacketDropped,\n          PacketDropReason::INVALID_PACKET);\n      return;\n    }\n\n    const auto& clientConnectionId = parsedLongHeader->invariant.srcConnId;\n    const auto& initialDestinationConnectionId =\n        parsedLongHeader->invariant.dstConnId;\n\n    if (initialDestinationConnectionId.size() < kDefaultConnectionIdSize) {\n      VLOG(4) << \"Initial connectionid too small\";\n      if (conn.qLogger) {\n        conn.qLogger->addPacketDrop(\n            0,\n            QuicTransportStatsCallback::toString(\n                PacketDropReason::INITIAL_CONNID_SMALL));\n      }\n      QUIC_STATS(\n          conn.statsCallback,\n          onPacketDropped,\n          PacketDropReason::INITIAL_CONNID_SMALL);\n      return;\n    }\n\n    CHECK(conn.connIdAlgo) << \"ConnectionIdAlgo is not set.\";\n    CHECK(!conn.serverConnectionId.has_value());\n    // serverConnIdParams must be set by the QuicServerTransport\n    CHECK(conn.serverConnIdParams);\n\n    auto newServerConnIdData = conn.createAndAddNewSelfConnId();\n    CHECK(newServerConnIdData.has_value());\n    conn.serverConnectionId = newServerConnIdData->connId;\n\n    QUIC_STATS(conn.statsCallback, onStatelessReset);\n    conn.serverHandshakeLayer->accept(\n        std::make_shared<ServerTransportParametersExtension>(\n            version,\n            conn.transportSettings.advertisedInitialConnectionWindowSize,\n            conn.transportSettings.advertisedInitialBidiLocalStreamWindowSize,\n            conn.transportSettings.advertisedInitialBidiRemoteStreamWindowSize,\n            conn.transportSettings.advertisedInitialUniStreamWindowSize,\n            conn.transportSettings.advertisedInitialMaxStreamsBidi,\n            conn.transportSettings.advertisedInitialMaxStreamsUni,\n            conn.transportSettings.idleTimeout,\n            conn.transportSettings.ackDelayExponent,\n            conn.transportSettings.maxRecvPacketSize,\n            conn.transportSettings.partialReliabilityEnabled,\n            *newServerConnIdData->token,\n            conn.serverConnectionId.value(),\n            initialDestinationConnectionId));\n    conn.transportParametersEncoded = true;\n    const CryptoFactory& cryptoFactory =\n        conn.serverHandshakeLayer->getCryptoFactory();\n    conn.readCodec = std::make_unique<QuicReadCodec>(QuicNodeType::Server);\n    conn.readCodec->setInitialReadCipher(cryptoFactory.getClientInitialCipher(\n        initialDestinationConnectionId, version));\n    conn.readCodec->setClientConnectionId(clientConnectionId);\n    conn.readCodec->setServerConnectionId(*conn.serverConnectionId);\n    if (conn.qLogger) {\n      conn.qLogger->setScid(conn.serverConnectionId);\n      conn.qLogger->setDcid(initialDestinationConnectionId);\n    }\n    conn.readCodec->setCodecParameters(\n        CodecParameters(conn.peerAckDelayExponent, version));\n    conn.initialWriteCipher = cryptoFactory.getServerInitialCipher(\n        initialDestinationConnectionId, version);\n\n    conn.readCodec->setInitialHeaderCipher(\n        cryptoFactory.makeClientInitialHeaderCipher(\n            initialDestinationConnectionId, version));\n    conn.initialHeaderCipher = cryptoFactory.makeServerInitialHeaderCipher(\n        initialDestinationConnectionId, version);\n    conn.peerAddress = conn.originalPeerAddress;\n  }\n  BufQueue udpData;\n  udpData.append(std::move(readData.networkData.data));\n  for (uint16_t processedPackets = 0;\n       !udpData.empty() && processedPackets < kMaxNumCoalescedPackets;\n       processedPackets++) {\n    size_t dataSize = udpData.chainLength();\n    auto parsedPacket = conn.readCodec->parsePacket(udpData, conn.ackStates);\n    size_t packetSize = dataSize - udpData.chainLength();\n\n    switch (parsedPacket.type()) {\n      case CodecResult::Type::CIPHER_UNAVAILABLE: {\n        handleCipherUnavailable(\n            parsedPacket.cipherUnavailable(), conn, packetSize, readData);\n        break;\n      }\n      case CodecResult::Type::RETRY: {\n        VLOG(10) << \"drop because the server is not supposed to \"\n                 << \"receive a retry \" << conn;\n        if (conn.qLogger) {\n          conn.qLogger->addPacketDrop(packetSize, kRetry);\n        }\n        QUIC_TRACE(packet_drop, conn, \"retry\");\n        break;\n      }\n      case CodecResult::Type::STATELESS_RESET: {\n        VLOG(10) << \"drop because reset \" << conn;\n        if (conn.qLogger) {\n          conn.qLogger->addPacketDrop(packetSize, kReset);\n        }\n        QUIC_TRACE(packet_drop, conn, \"reset\");\n        break;\n      }\n      case CodecResult::Type::NOTHING: {\n        VLOG(10) << \"drop cipher unavailable, no data \" << conn;\n        if (conn.qLogger) {\n          conn.qLogger->addPacketDrop(packetSize, kCipherUnavailable);\n        }\n        QUIC_TRACE(packet_drop, conn, \"cipher_unavailable\");\n        break;\n      }\n      case CodecResult::Type::REGULAR_PACKET:\n        break;\n    }\n\n    RegularQuicPacket* regularOptional = parsedPacket.regularPacket();\n    if (!regularOptional) {\n      // We were unable to parse the packet, drop for now. All the drop reasons\n      // should have already been logged into QLogger and QuicTrace inside the\n      // previous switch-case block. We just need to update QUIC_STATS here.\n      VLOG(10) << \"Not able to parse QUIC packet \" << conn;\n      QUIC_STATS(\n          conn.statsCallback, onPacketDropped, PacketDropReason::PARSE_ERROR);\n      continue;\n    }\n\n    auto protectionLevel = regularOptional->header.getProtectionType();\n    auto encryptionLevel = protectionTypeToEncryptionLevel(protectionLevel);\n\n    auto packetNum = regularOptional->header.getPacketSequenceNum();\n    auto packetNumberSpace = regularOptional->header.getPacketNumberSpace();\n\n    // TODO: enforce constraints on other protection levels.\n    auto& regularPacket = *regularOptional;\n\n    bool isProtectedPacket = protectionLevel == ProtectionType::ZeroRtt ||\n        protectionLevel == ProtectionType::KeyPhaseZero ||\n        protectionLevel == ProtectionType::KeyPhaseOne;\n\n    if (!isProtectedPacket) {\n      for (auto& quicFrame : regularPacket.frames) {\n        auto isPadding = quicFrame.asPaddingFrame();\n        auto isAck = quicFrame.asReadAckFrame();\n        auto isClose = quicFrame.asConnectionCloseFrame();\n        auto isCrypto = quicFrame.asReadCryptoFrame();\n        auto isPing = quicFrame.asPingFrame();\n        // TODO: add path challenge and response\n        if (!isPadding && !isAck && !isClose && !isCrypto && !isPing) {\n          QUIC_STATS(\n              conn.statsCallback,\n              onPacketDropped,\n              PacketDropReason::PROTOCOL_VIOLATION);\n          if (conn.qLogger) {\n            conn.qLogger->addPacketDrop(\n                packetSize,\n                QuicTransportStatsCallback::toString(\n                    PacketDropReason::PROTOCOL_VIOLATION));\n          }\n          throw QuicTransportException(\n              \"Invalid frame\", TransportErrorCode::PROTOCOL_VIOLATION);\n        }\n      }\n    }\n\n    CHECK(conn.clientConnectionId);\n    if (conn.qLogger) {\n      conn.qLogger->addPacket(regularPacket, packetSize);\n    }\n    // We assume that the higher layer takes care of validating that the version\n    // is supported.\n    if (!conn.version) {\n      LongHeader* longHeader = regularPacket.header.asLong();\n      if (!longHeader) {\n        throw QuicTransportException(\n            \"Invalid packet type\", TransportErrorCode::PROTOCOL_VIOLATION);\n      }\n      conn.version = longHeader->getVersion();\n      if (conn.version == QuicVersion::MVFST_EXPERIMENTAL) {\n        setExperimentalSettings(conn);\n      }\n    }\n\n    if (conn.peerAddress != readData.peer) {\n      if (encryptionLevel != EncryptionLevel::AppData) {\n        if (conn.qLogger) {\n          conn.qLogger->addPacketDrop(\n              packetSize,\n              QuicTransportStatsCallback::toString(\n                  PacketDropReason::PEER_ADDRESS_CHANGE));\n        }\n        QUIC_STATS(\n            conn.statsCallback,\n            onPacketDropped,\n            PacketDropReason::PEER_ADDRESS_CHANGE);\n        throw QuicTransportException(\n            \"Migration not allowed during handshake\",\n            TransportErrorCode::INVALID_MIGRATION);\n      }\n\n      if (conn.transportSettings.disableMigration) {\n        if (conn.qLogger) {\n          conn.qLogger->addPacketDrop(\n              packetSize,\n              QuicTransportStatsCallback::toString(\n                  PacketDropReason::PEER_ADDRESS_CHANGE));\n        }\n        QUIC_STATS(\n            conn.statsCallback,\n            onPacketDropped,\n            PacketDropReason::PEER_ADDRESS_CHANGE);\n        throw QuicTransportException(\n            \"Migration disabled\", TransportErrorCode::INVALID_MIGRATION);\n      }\n    }\n\n    auto& ackState = getAckState(conn, packetNumberSpace);\n    bool outOfOrder = updateLargestReceivedPacketNum(\n        ackState, packetNum, readData.networkData.receiveTimePoint);\n    if (outOfOrder) {\n      QUIC_STATS(conn.statsCallback, onOutOfOrderPacketReceived);\n    }\n    DCHECK(hasReceivedPackets(conn));\n\n    bool pktHasRetransmittableData = false;\n    bool pktHasCryptoData = false;\n    bool isNonProbingPacket = false;\n    bool handshakeConfirmedThisLoop = false;\n\n    // TODO: possibly drop the packet here, but rolling back state of\n    // what we've already processed is difficult.\n    for (auto& quicFrame : regularPacket.frames) {\n      switch (quicFrame.type()) {\n        case QuicFrame::Type::ReadAckFrame: {\n          VLOG(10) << \"Server received ack frame packet=\" << packetNum << \" \"\n                   << conn;\n          isNonProbingPacket = true;\n          ReadAckFrame& ackFrame = *quicFrame.asReadAckFrame();\n          processAckFrame(\n              conn,\n              packetNumberSpace,\n              ackFrame,\n              [&](const OutstandingPacket& packet,\n                  const QuicWriteFrame& packetFrame,\n                  const ReadAckFrame&) {\n                switch (packetFrame.type()) {\n                  case QuicWriteFrame::Type::WriteStreamFrame: {\n                    const WriteStreamFrame& frame =\n                        *packetFrame.asWriteStreamFrame();\n                    VLOG(4)\n                        << \"Server received ack for stream=\" << frame.streamId\n                        << \" offset=\" << frame.offset << \" fin=\" << frame.fin\n                        << \" len=\" << frame.len << \" \" << conn;\n                    auto ackedStream =\n                        conn.streamManager->getStream(frame.streamId);\n                    if (ackedStream) {\n                      sendAckSMHandler(*ackedStream, frame);\n                    }\n                    break;\n                  }\n                  case QuicWriteFrame::Type::WriteCryptoFrame: {\n                    const WriteCryptoFrame& frame =\n                        *packetFrame.asWriteCryptoFrame();\n                    auto cryptoStream =\n                        getCryptoStream(*conn.cryptoState, encryptionLevel);\n                    processCryptoStreamAck(\n                        *cryptoStream, frame.offset, frame.len);\n                    break;\n                  }\n                  case QuicWriteFrame::Type::RstStreamFrame: {\n                    const RstStreamFrame& frame =\n                        *packetFrame.asRstStreamFrame();\n                    VLOG(4) << \"Server received ack for reset stream=\"\n                            << frame.streamId << \" \" << conn;\n                    auto stream = conn.streamManager->getStream(frame.streamId);\n                    if (stream) {\n                      sendRstAckSMHandler(*stream);\n                    }\n                    break;\n                  }\n                  case QuicWriteFrame::Type::WriteAckFrame: {\n                    const WriteAckFrame& frame = *packetFrame.asWriteAckFrame();\n                    DCHECK(!frame.ackBlocks.empty());\n                    VLOG(4) << \"Server received ack for largestAcked=\"\n                            << frame.ackBlocks.front().end << \" \" << conn;\n                    commonAckVisitorForAckFrame(ackState, frame);\n                    break;\n                  }\n                  case QuicWriteFrame::Type::PingFrame:\n                    if (!packet.metadata.isD6DProbe) {\n                      conn.pendingEvents.cancelPingTimeout = true;\n                    }\n                    return;\n                  case QuicWriteFrame::Type::QuicSimpleFrame: {\n                    const QuicSimpleFrame& frame =\n                        *packetFrame.asQuicSimpleFrame();\n                    // ACK of HandshakeDone is a server-specific behavior.\n                    if (frame.asHandshakeDoneFrame() &&\n                        conn.version != QuicVersion::MVFST_D24) {\n                      // Call handshakeConfirmed outside of the packet\n                      // processing loop to avoid a re-entrancy.\n                      handshakeConfirmedThisLoop = true;\n                    }\n                    break;\n                  }\n                  default: {\n                    break;\n                  }\n                }\n              },\n              markPacketLoss,\n              readData.networkData.receiveTimePoint);\n          break;\n        }\n        case QuicFrame::Type::RstStreamFrame: {\n          RstStreamFrame& frame = *quicFrame.asRstStreamFrame();\n          VLOG(10) << \"Server received reset stream=\" << frame.streamId << \" \"\n                   << conn;\n          pktHasRetransmittableData = true;\n          isNonProbingPacket = true;\n          auto stream = conn.streamManager->getStream(frame.streamId);\n          if (!stream) {\n            break;\n          }\n          receiveRstStreamSMHandler(*stream, frame);\n          break;\n        }\n        case QuicFrame::Type::ReadCryptoFrame: {\n          pktHasRetransmittableData = true;\n          pktHasCryptoData = true;\n          isNonProbingPacket = true;\n          ReadCryptoFrame& cryptoFrame = *quicFrame.asReadCryptoFrame();\n          VLOG(10) << \"Server received crypto data offset=\"\n                   << cryptoFrame.offset\n                   << \" len=\" << cryptoFrame.data->computeChainDataLength()\n                   << \" currentReadOffset=\"\n                   << getCryptoStream(*conn.cryptoState, encryptionLevel)\n                          ->currentReadOffset\n                   << \" \" << conn;\n          appendDataToReadBuffer(\n              *getCryptoStream(*conn.cryptoState, encryptionLevel),\n              StreamBuffer(\n                  std::move(cryptoFrame.data), cryptoFrame.offset, false));\n          break;\n        }\n        case QuicFrame::Type::ReadStreamFrame: {\n          ReadStreamFrame& frame = *quicFrame.asReadStreamFrame();\n          VLOG(10) << \"Server received stream data for stream=\"\n                   << frame.streamId << \", offset=\" << frame.offset\n                   << \" len=\" << frame.data->computeChainDataLength()\n                   << \" fin=\" << frame.fin << \" \" << conn;\n          pktHasRetransmittableData = true;\n          isNonProbingPacket = true;\n          auto stream = conn.streamManager->getStream(frame.streamId);\n          // Ignore data from closed streams that we don't have the\n          // state for any more.\n          if (stream) {\n            receiveReadStreamFrameSMHandler(*stream, std::move(frame));\n          }\n          break;\n        }\n        case QuicFrame::Type::MaxDataFrame: {\n          MaxDataFrame& connWindowUpdate = *quicFrame.asMaxDataFrame();\n          VLOG(10) << \"Server received max data offset=\"\n                   << connWindowUpdate.maximumData << \" \" << conn;\n          pktHasRetransmittableData = true;\n          isNonProbingPacket = true;\n          handleConnWindowUpdate(conn, connWindowUpdate, packetNum);\n          break;\n        }\n        case QuicFrame::Type::MaxStreamDataFrame: {\n          MaxStreamDataFrame& streamWindowUpdate =\n              *quicFrame.asMaxStreamDataFrame();\n          VLOG(10) << \"Server received max stream data stream=\"\n                   << streamWindowUpdate.streamId\n                   << \" offset=\" << streamWindowUpdate.maximumData << \" \"\n                   << conn;\n          if (isReceivingStream(conn.nodeType, streamWindowUpdate.streamId)) {\n            throw QuicTransportException(\n                \"Received MaxStreamDataFrame for receiving stream.\",\n                TransportErrorCode::STREAM_STATE_ERROR);\n          }\n          pktHasRetransmittableData = true;\n          isNonProbingPacket = true;\n          auto stream =\n              conn.streamManager->getStream(streamWindowUpdate.streamId);\n          if (stream) {\n            handleStreamWindowUpdate(\n                *stream, streamWindowUpdate.maximumData, packetNum);\n          }\n          break;\n        }\n        case QuicFrame::Type::DataBlockedFrame: {\n          VLOG(10) << \"Server received blocked \" << conn;\n          pktHasRetransmittableData = true;\n          isNonProbingPacket = true;\n          handleConnBlocked(conn);\n          break;\n        }\n        case QuicFrame::Type::StreamDataBlockedFrame: {\n          StreamDataBlockedFrame& blocked =\n              *quicFrame.asStreamDataBlockedFrame();\n          VLOG(10) << \"Server received blocked stream=\" << blocked.streamId\n                   << \" \" << conn;\n          pktHasRetransmittableData = true;\n          isNonProbingPacket = true;\n          auto stream = conn.streamManager->getStream(blocked.streamId);\n          if (stream) {\n            handleStreamBlocked(*stream);\n          }\n          break;\n        }\n        case QuicFrame::Type::StreamsBlockedFrame: {\n          StreamsBlockedFrame& blocked = *quicFrame.asStreamsBlockedFrame();\n          // peer wishes to open a stream, but is unable to due to the maximum\n          // stream limit set by us\n          // TODO implement the handler\n          isNonProbingPacket = true;\n          VLOG(10) << \"Server received streams blocked limit=\"\n                   << blocked.streamLimit << \", \" << conn;\n          break;\n        }\n        case QuicFrame::Type::ConnectionCloseFrame: {\n          isNonProbingPacket = true;\n          ConnectionCloseFrame& connFrame = *quicFrame.asConnectionCloseFrame();\n          auto errMsg = folly::to<std::string>(\n              \"Server closed by peer reason=\", connFrame.reasonPhrase);\n          VLOG(4) << errMsg << \" \" << conn;\n          // we want to deliver app callbacks with the peer supplied error,\n          // but send a NO_ERROR to the peer.\n          QUIC_TRACE(recvd_close, conn, errMsg.c_str());\n          if (conn.qLogger) {\n            conn.qLogger->addTransportStateUpdate(getPeerClose(errMsg));\n          }\n          conn.peerConnectionError = std::make_pair(\n              QuicErrorCode(connFrame.errorCode), std::move(errMsg));\n          if (getSendConnFlowControlBytesWire(conn) == 0 &&\n              conn.flowControlState.sumCurStreamBufferLen) {\n            VLOG(2) << \"Client gives up a flow control blocked connection\";\n          }\n          throw QuicTransportException(\n              \"Peer closed\", TransportErrorCode::NO_ERROR);\n          break;\n        }\n        case QuicFrame::Type::PingFrame:\n          isNonProbingPacket = true;\n          // Ping isn't retransmittable data. But we would like to ack them\n          // early.\n          pktHasRetransmittableData = true;\n          break;\n        case QuicFrame::Type::PaddingFrame:\n          break;\n        case QuicFrame::Type::QuicSimpleFrame: {\n          pktHasRetransmittableData = true;\n          QuicSimpleFrame& simpleFrame = *quicFrame.asQuicSimpleFrame();\n          isNonProbingPacket |= updateSimpleFrameOnPacketReceived(\n              conn, simpleFrame, packetNum, readData.peer != conn.peerAddress);\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n    }\n\n    if (handshakeConfirmedThisLoop) {\n      handshakeConfirmed(conn);\n    }\n\n    // Update writable limit before processing the handshake data. This is so\n    // that if we haven't decided whether or not to validate the peer, we won't\n    // increase the limit.\n    updateWritableByteLimitOnRecvPacket(conn);\n\n    if (conn.peerAddress != readData.peer) {\n      // TODO use new conn id, make sure the other endpoint has new conn id\n      if (isNonProbingPacket) {\n        if (packetNum == ackState.largestReceivedPacketNum) {\n          ShortHeader* shortHeader = regularPacket.header.asShort();\n          bool intentionalMigration = false;\n          if (shortHeader &&\n              shortHeader->getConnectionId() != conn.serverConnectionId) {\n            intentionalMigration = true;\n          }\n          onConnectionMigration(conn, readData.peer, intentionalMigration);\n        }\n      } else {\n        // Server will need to response with PathResponse to the new address\n        // while not updating peerAddress to new address\n        if (conn.qLogger) {\n          conn.qLogger->addPacketDrop(\n              packetSize,\n              QuicTransportStatsCallback::toString(\n                  PacketDropReason::PEER_ADDRESS_CHANGE));\n        }\n        QUIC_STATS(\n            conn.statsCallback,\n            onPacketDropped,\n            PacketDropReason::PEER_ADDRESS_CHANGE);\n        throw QuicTransportException(\n            \"Probing not supported yet\", TransportErrorCode::INVALID_MIGRATION);\n      }\n    }\n\n    // Try reading bytes off of crypto, and performing a handshake.\n    auto data = readDataFromCryptoStream(\n        *getCryptoStream(*conn.cryptoState, encryptionLevel));\n    if (data) {\n      conn.serverHandshakeLayer->doHandshake(std::move(data), encryptionLevel);\n\n      try {\n        updateHandshakeState(conn);\n      } catch (...) {\n        if (conn.qLogger) {\n          conn.qLogger->addPacketDrop(\n              packetSize,\n              QuicTransportStatsCallback::toString(\n                  PacketDropReason::TRANSPORT_PARAMETER_ERROR));\n        }\n        QUIC_STATS(\n            conn.statsCallback,\n            onPacketDropped,\n            QuicTransportStatsCallback::PacketDropReason::\n                TRANSPORT_PARAMETER_ERROR);\n        throw;\n      }\n    }\n    updateAckSendStateOnRecvPacket(\n        conn,\n        ackState,\n        outOfOrder,\n        pktHasRetransmittableData,\n        pktHasCryptoData);\n    if (encryptionLevel == EncryptionLevel::Handshake &&\n        conn.version != QuicVersion::MVFST_D24 && conn.initialWriteCipher) {\n      conn.initialWriteCipher.reset();\n      conn.initialHeaderCipher.reset();\n      conn.readCodec->setInitialReadCipher(nullptr);\n      conn.readCodec->setInitialHeaderCipher(nullptr);\n      implicitAckCryptoStream(conn, EncryptionLevel::Initial);\n    }\n    QUIC_STATS(conn.statsCallback, onPacketProcessed);\n  }\n  VLOG_IF(4, !udpData.empty())\n      << \"Leaving \" << udpData.chainLength()\n      << \" bytes unprocessed after attempting to process \"\n      << kMaxNumCoalescedPackets << \" packets.\";\n}\n\nvoid onServerReadDataFromClosed(\n    QuicServerConnectionState& conn,\n    ServerEvents::ReadData& readData) {\n  CHECK_EQ(conn.state, ServerState::Closed);\n  BufQueue udpData;\n  udpData.append(std::move(readData.networkData.data));\n  auto packetSize = udpData.empty() ? 0 : udpData.chainLength();\n  if (!conn.readCodec) {\n    // drop data. We closed before we even got the first packet. This is\n    // normally not possible but might as well.\n    if (conn.qLogger) {\n      conn.qLogger->addPacketDrop(\n          packetSize,\n          QuicTransportStatsCallback::toString(\n              PacketDropReason::SERVER_STATE_CLOSED));\n    }\n    QUIC_STATS(\n        conn.statsCallback,\n        onPacketDropped,\n        PacketDropReason::SERVER_STATE_CLOSED);\n    return;\n  }\n\n  if (conn.peerConnectionError) {\n    // We already got a peer error. We can ignore any futher peer errors.\n    if (conn.qLogger) {\n      conn.qLogger->addPacketDrop(\n          packetSize,\n          QuicTransportStatsCallback::toString(\n              PacketDropReason::SERVER_STATE_CLOSED));\n    }\n    QUIC_TRACE(packet_drop, conn, \"ignoring peer close\");\n    QUIC_STATS(\n        conn.statsCallback,\n        onPacketDropped,\n        PacketDropReason::SERVER_STATE_CLOSED);\n    return;\n  }\n  auto parsedPacket = conn.readCodec->parsePacket(udpData, conn.ackStates);\n  switch (parsedPacket.type()) {\n    case CodecResult::Type::CIPHER_UNAVAILABLE: {\n      VLOG(10) << \"drop cipher unavailable \" << conn;\n      if (conn.qLogger) {\n        conn.qLogger->addPacketDrop(packetSize, kCipherUnavailable);\n      }\n      QUIC_TRACE(packet_drop, conn, \"cipher_unavailable\");\n      break;\n    }\n    case CodecResult::Type::RETRY: {\n      VLOG(10) << \"drop because the server is not supposed to \"\n               << \"receive a retry \" << conn;\n      if (conn.qLogger) {\n        conn.qLogger->addPacketDrop(packetSize, kRetry);\n      }\n      QUIC_TRACE(packet_drop, conn, \"retry\");\n      break;\n    }\n    case CodecResult::Type::STATELESS_RESET: {\n      VLOG(10) << \"drop because reset \" << conn;\n      if (conn.qLogger) {\n        conn.qLogger->addPacketDrop(packetSize, kReset);\n      }\n      QUIC_TRACE(packet_drop, conn, \"reset\");\n      break;\n    }\n    case CodecResult::Type::NOTHING: {\n      VLOG(10) << \"drop cipher unavailable, no data \" << conn;\n      if (conn.qLogger) {\n        conn.qLogger->addPacketDrop(packetSize, kCipherUnavailable);\n      }\n      QUIC_TRACE(packet_drop, conn, \"cipher_unavailable\");\n      break;\n    }\n    case CodecResult::Type::REGULAR_PACKET:\n      break;\n  }\n  auto regularOptional = parsedPacket.regularPacket();\n  if (!regularOptional) {\n    // We were unable to parse the packet, drop for now.\n    VLOG(10) << \"Not able to parse QUIC packet \" << conn;\n    if (conn.qLogger) {\n      conn.qLogger->addPacketDrop(\n          packetSize,\n          QuicTransportStatsCallback::toString(PacketDropReason::PARSE_ERROR));\n    }\n    QUIC_STATS(\n        conn.statsCallback, onPacketDropped, PacketDropReason::PARSE_ERROR);\n    return;\n  }\n\n  auto& regularPacket = *regularOptional;\n  auto packetNum = regularPacket.header.getPacketSequenceNum();\n  auto pnSpace = regularPacket.header.getPacketNumberSpace();\n  if (conn.qLogger) {\n    conn.qLogger->addPacket(regularPacket, packetSize);\n  }\n\n  // Only process the close frames in the packet\n  for (auto& quicFrame : regularPacket.frames) {\n    switch (quicFrame.type()) {\n      case QuicFrame::Type::ConnectionCloseFrame: {\n        ConnectionCloseFrame& connFrame = *quicFrame.asConnectionCloseFrame();\n        auto errMsg = folly::to<std::string>(\n            \"Server closed by peer reason=\", connFrame.reasonPhrase);\n        VLOG(4) << errMsg << \" \" << conn;\n        if (conn.qLogger) {\n          conn.qLogger->addTransportStateUpdate(getPeerClose(errMsg));\n        }\n        // we want to deliver app callbacks with the peer supplied error,\n        // but send a NO_ERROR to the peer.\n        QUIC_TRACE(recvd_close, conn, errMsg.c_str());\n        conn.peerConnectionError = std::make_pair(\n            QuicErrorCode(connFrame.errorCode), std::move(errMsg));\n        break;\n      }\n      default:\n        break;\n    }\n  }\n\n  // We only need to set the largest received packet number in order to\n  // determine whether or not we need to send a new close.\n  auto& largestReceivedPacketNum =\n      getAckState(conn, pnSpace).largestReceivedPacketNum;\n  largestReceivedPacketNum = std::max<PacketNum>(\n      largestReceivedPacketNum.value_or(packetNum), packetNum);\n}\n\nvoid onServerClose(QuicServerConnectionState& conn) {\n  switch (conn.state) {\n    case ServerState::Open:\n      onServerCloseOpenState(conn);\n      return;\n    case ServerState::Closed:\n      return;\n  }\n}\n\nvoid onServerCloseOpenState(QuicServerConnectionState& conn) {\n  conn.state = ServerState::Closed;\n}\n\nfolly::Optional<ConnectionIdData>\nQuicServerConnectionState::createAndAddNewSelfConnId() {\n  // Should be set right after server transport construction.\n  CHECK(connIdAlgo);\n  CHECK(serverConnIdParams);\n\n  CHECK(transportSettings.statelessResetTokenSecret);\n\n  StatelessResetGenerator generator(\n      transportSettings.statelessResetTokenSecret.value(),\n      serverAddr.getFullyQualified());\n\n  // TODO Possibly change this mechanism later\n  // The default connectionId algo has 36 bits of randomness.\n  auto encodedCid = connIdAlgo->encodeConnectionId(*serverConnIdParams);\n  size_t encodedTimes = 0;\n  while (encodedCid && connIdRejector &&\n         connIdRejector->rejectConnectionId(*encodedCid) &&\n         ++encodedTimes < kConnIdEncodingRetryLimit) {\n    encodedCid = connIdAlgo->encodeConnectionId(*serverConnIdParams);\n  }\n  LOG_IF(ERROR, encodedTimes == kConnIdEncodingRetryLimit)\n      << \"Quic CIDRejector rejected all conneectionIDs\";\n  if (encodedCid.hasError()) {\n    return folly::none;\n  }\n  auto newConnIdData =\n      ConnectionIdData{*encodedCid, nextSelfConnectionIdSequence++};\n  newConnIdData.token = generator.generateToken(newConnIdData.connId);\n  selfConnectionIds.push_back(newConnIdData);\n  return newConnIdData;\n}\n\n} // namespace quic\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n#include <quic/server/QuicServerTransport.h>\n\n#include <gmock/gmock.h>\n#include <gtest/gtest.h>\n\n#include <quic/api/QuicTransportFunctions.h>\n#include <quic/api/test/Mocks.h>\n#include <quic/codec/DefaultConnectionIdAlgo.h>\n#include <quic/codec/QuicPacketBuilder.h>\n#include <quic/codec/Types.h>\n#include <quic/common/test/TestUtils.h>\n#include <quic/congestion_control/ServerCongestionControllerFactory.h>\n#include <quic/fizz/handshake/FizzCryptoFactory.h>\n#include <quic/fizz/server/handshake/FizzServerHandshake.h>\n#include <quic/fizz/server/handshake/FizzServerQuicHandshakeContext.h>\n#include <quic/logging/FileQLogger.h>\n#include <quic/server/handshake/ServerHandshake.h>\n#include <quic/server/test/Mocks.h>\n#include <quic/state/QuicStreamFunctions.h>\n#include <quic/state/test/MockQuicStats.h>\n\n#include <folly/io/async/test/MockAsyncUDPSocket.h>\n\nusing namespace testing;\nusing namespace folly;\n\nnamespace quic {\nnamespace test {\n\nnamespace {\nusing ByteEvent = QuicTransportBase::ByteEvent;\nusing PacketDropReason = QuicTransportStatsCallback::PacketDropReason;\n} // namespace\n\nclass FakeServerHandshake : public FizzServerHandshake {\n public:\n  explicit FakeServerHandshake(\n      QuicServerConnectionState& conn,\n      std::shared_ptr<FizzServerQuicHandshakeContext> fizzContext,\n      bool chloSync = false,\n      bool cfinSync = false,\n      folly::Optional<uint64_t> clientActiveConnectionIdLimit = folly::none)\n      : FizzServerHandshake(&conn, std::move(fizzContext)),\n        conn_(conn),\n        chloSync_(chloSync),\n        cfinSync_(cfinSync),\n        clientActiveConnectionIdLimit_(clientActiveConnectionIdLimit) {}\n\n  void accept(std::shared_ptr<ServerTransportParametersExtension>) override {}\n\n  MOCK_METHOD1(writeNewSessionTicket, void(const AppToken&));\n\n  void doHandshake(std::unique_ptr<IOBuf> data, EncryptionLevel) override {\n    IOBufEqualTo eq;\n    auto chlo = folly::IOBuf::copyBuffer(\"CHLO\");\n    auto clientFinished = IOBuf::copyBuffer(\"FINISHED\");\n    if (eq(data, chlo)) {\n      if (chloSync_) {\n        // Do NOT invoke onCryptoEventAvailable callback\n        // Fall through and let the ServerStateMachine to process the event\n        writeDataToQuicStream(\n            *getCryptoStream(*conn_.cryptoState, EncryptionLevel::Initial),\n            IOBuf::copyBuffer(\"SHLO\"));\n        if (allowZeroRttKeys_) {\n          validateAndUpdateSourceToken(conn_, sourceAddrs_);\n          phase_ = Phase::KeysDerived;\n          setEarlyKeys();\n        }\n        setHandshakeKeys();\n      } else {\n        // Asynchronously schedule the callback\n        executor_->add([&] {\n          writeDataToQuicStream(\n              *getCryptoStream(*conn_.cryptoState, EncryptionLevel::Initial),\n              IOBuf::copyBuffer(\"SHLO\"));\n          if (allowZeroRttKeys_) {\n            validateAndUpdateSourceToken(conn_, sourceAddrs_);\n            phase_ = Phase::KeysDerived;\n            setEarlyKeys();\n          }\n          setHandshakeKeys();\n          if (callback_) {\n            callback_->onCryptoEventAvailable();\n          }\n        });\n      }\n    } else if (eq(data, clientFinished)) {\n      if (cfinSync_) {\n        // Do NOT invoke onCryptoEventAvailable callback\n        // Fall through and let the ServerStateMachine to process the event\n        setOneRttKeys();\n        phase_ = Phase::Established;\n        handshakeDone_ = true;\n      } else {\n        // Asynchronously schedule the callback\n        executor_->add([&] {\n          setOneRttKeys();\n          phase_ = Phase::Established;\n          handshakeDone_ = true;\n          if (callback_) {\n            callback_->onCryptoEventAvailable();\n          }\n        });\n      }\n    }\n  }\n\n  folly::Optional<ClientTransportParameters> getClientTransportParams()\n      override {\n    std::vector<TransportParameter> transportParams;\n    transportParams.push_back(encodeIntegerParameter(\n        TransportParameterId::initial_max_stream_data_bidi_local,\n        kDefaultStreamWindowSize));\n    transportParams.push_back(encodeIntegerParameter(\n        TransportParameterId::initial_max_stream_data_bidi_remote,\n        kDefaultStreamWindowSize));\n    transportParams.push_back(encodeIntegerParameter(\n        TransportParameterId::initial_max_stream_data_uni,\n        kDefaultStreamWindowSize));\n    transportParams.push_back(encodeIntegerParameter(\n        TransportParameterId::initial_max_streams_bidi,\n        kDefaultMaxStreamsBidirectional));\n    transportParams.push_back(encodeIntegerParameter(\n        TransportParameterId::initial_max_streams_uni,\n        kDefaultMaxStreamsUnidirectional));\n    transportParams.push_back(encodeIntegerParameter(\n        TransportParameterId::initial_max_data, kDefaultConnectionWindowSize));\n    transportParams.push_back(encodeIntegerParameter(\n        TransportParameterId::idle_timeout, kDefaultIdleTimeout.count()));\n    transportParams.push_back(encodeIntegerParameter(\n        TransportParameterId::max_packet_size, maxRecvPacketSize));\n    if (clientActiveConnectionIdLimit_) {\n      transportParams.push_back(encodeIntegerParameter(\n          TransportParameterId::active_connection_id_limit,\n          *clientActiveConnectionIdLimit_));\n    }\n    transportParams.push_back(encodeConnIdParameter(\n        TransportParameterId::initial_source_connection_id,\n        getTestConnectionId()));\n\n    return ClientTransportParameters{std::move(transportParams)};\n  }\n\n  void setEarlyKeys() {\n    oneRttWriteCipher_ = createNoOpAead();\n    oneRttWriteHeaderCipher_ = createNoOpHeaderCipher();\n    zeroRttReadCipher_ = createNoOpAead();\n    zeroRttReadHeaderCipher_ = createNoOpHeaderCipher();\n  }\n\n  void setOneRttKeys() {\n    // Mimic ServerHandshake behavior.\n    // oneRttWriteCipher would already be set during ReportEarlyHandshakeSuccess\n    if (!allowZeroRttKeys_) {\n      oneRttWriteCipher_ = createNoOpAead();\n      oneRttWriteHeaderCipher_ = createNoOpHeaderCipher();\n    }\n    oneRttReadCipher_ = createNoOpAead();\n    oneRttReadHeaderCipher_ = createNoOpHeaderCipher();\n  }\n\n  void setHandshakeKeys() {\n    conn_.handshakeWriteCipher = createNoOpAead();\n    conn_.handshakeWriteHeaderCipher = createNoOpHeaderCipher();\n    handshakeReadCipher_ = createNoOpAead();\n    handshakeReadHeaderCipher_ = createNoOpHeaderCipher();\n  }\n\n  void setHandshakeDone(bool done) {\n    handshakeDone_ = done;\n  }\n\n  void allowZeroRttKeys() {\n    allowZeroRttKeys_ = true;\n  }\n\n  void setSourceTokens(std::vector<folly::IPAddress> srcAddrs) {\n    sourceAddrs_ = srcAddrs;\n  }\n\n  QuicServerConnectionState& conn_;\n  bool chloSync_{false};\n  bool cfinSync_{false};\n  uint64_t maxRecvPacketSize{kDefaultMaxUDPPayload};\n  bool allowZeroRttKeys_{false};\n  std::vector<folly::IPAddress> sourceAddrs_;\n  folly::Optional<uint64_t> clientActiveConnectionIdLimit_;\n};\n\nbool verifyFramePresent(\n    std::vector<std::unique_ptr<folly::IOBuf>>& socketWrites,\n    QuicReadCodec& readCodec,\n    QuicFrame::Type frameType) {\n  AckStates ackStates;\n  for (auto& write : socketWrites) {\n    auto packetQueue = bufToQueue(write->clone());\n    auto result = readCodec.parsePacket(packetQueue, ackStates);\n    auto regularPacket = result.regularPacket();\n    if (!regularPacket) {\n      continue;\n    }\n    for (FOLLY_MAYBE_UNUSED auto& frame : regularPacket->frames) {\n      if (frame.type() != frameType) {\n        continue;\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\nstruct MigrationParam {\n  folly::Optional<uint64_t> clientSentActiveConnIdTransportParam;\n};\n\nclass TestingQuicServerTransport : public QuicServerTransport {\n public:\n  TestingQuicServerTransport(\n      folly::EventBase* evb,\n      std::unique_ptr<folly::AsyncUDPSocket> sock,\n      ConnectionCallback& cb,\n      std::shared_ptr<const fizz::server::FizzServerContext> ctx)\n      : QuicServerTransport(evb, std::move(sock), cb, ctx) {}\n\n  const QuicServerConnectionState& getConn() const {\n    return *dynamic_cast<QuicServerConnectionState*>(conn_.get());\n  }\n\n  QuicServerConnectionState& getNonConstConn() {\n    return *dynamic_cast<QuicServerConnectionState*>(conn_.get());\n  }\n\n  AsyncUDPSocket& getSocket() {\n    return *socket_;\n  }\n\n  auto& idleTimeout() {\n    return idleTimeout_;\n  }\n\n  auto& drainTimeout() {\n    return drainTimeout_;\n  }\n\n  auto& ackTimeout() {\n    return ackTimeout_;\n  }\n\n  auto& lossTimeout() {\n    return lossTimeout_;\n  }\n\n  auto& pathValidationTimeout() {\n    return pathValidationTimeout_;\n  }\n\n  bool isClosed() {\n    return closeState_ == CloseState::CLOSED;\n  }\n\n  bool isDraining() {\n    return drainTimeout_.isScheduled();\n  }\n\n  void triggerCryptoEvent() {\n    onCryptoEventAvailable();\n  }\n\n  auto& writeLooper() {\n    return writeLooper_;\n  }\n\n  auto& readLooper() {\n    return readLooper_;\n  }\n\n  void registerKnobParamHandler(\n      uint64_t paramId,\n      std::function<void(QuicServerConnectionState*, uint64_t)>&& handler) {\n    registerTransportKnobParamHandler(paramId, std::move(handler));\n  }\n\n  void handleKnobParams(const TransportKnobParams& params) {\n    handleTransportKnobParams(params);\n  }\n};\n\nclass QuicServerTransportTest : public Test {\n public:\n  void SetUp() override {\n    clientAddr = folly::SocketAddress(\"127.0.0.1\", 1000);\n    serverAddr = folly::SocketAddress(\"1.2.3.4\", 8080);\n    clientConnectionId = getTestConnectionId();\n    initialDestinationConnectionId = clientConnectionId;\n    // change the initialDestinationConnectionId to be different\n    // to suss out bugs.\n    initialDestinationConnectionId->data()[0] ^= 0x1;\n    // set server chosen connId with processId = 0 and workerId = 1\n    ServerConnectionIdParams params(0, 0, 1);\n    auto sock =\n        std::make_unique<NiceMock<folly::test::MockAsyncUDPSocket>>(&evb);\n    socket = sock.get();\n    EXPECT_CALL(*sock, write(_, _))\n        .WillRepeatedly(Invoke([&](const SocketAddress&,\n                                   const std::unique_ptr<folly::IOBuf>& buf) {\n          serverWrites.push_back(buf->clone());\n          return buf->computeChainDataLength();\n        }));\n    EXPECT_CALL(*sock, address()).WillRepeatedly(ReturnRef(serverAddr));\n    supportedVersions = {QuicVersion::MVFST, QuicVersion::QUIC_DRAFT};\n    serverCtx = createServerCtx();\n    connIdAlgo_ = std::make_unique<DefaultConnectionIdAlgo>();\n    ccFactory_ = std::make_shared<ServerCongestionControllerFactory>();\n    server = std::make_shared<TestingQuicServerTransport>(\n        &evb, std::move(sock), connCallback, serverCtx);\n    server->setCongestionControllerFactory(ccFactory_);\n    server->setCongestionControl(CongestionControlType::Cubic);\n    server->setRoutingCallback(&routingCallback);\n    server->setSupportedVersions(supportedVersions);\n    server->setOriginalPeerAddress(clientAddr);\n    server->setServerConnectionIdParams(params);\n    server->getNonConstConn().transportSettings.statelessResetTokenSecret =\n        getRandSecret();\n    transportInfoCb_ = std::make_unique<NiceMock<MockQuicStats>>();\n    server->setTransportStatsCallback(transportInfoCb_.get());\n    initializeServerHandshake();\n    server->getNonConstConn().handshakeLayer.reset(fakeHandshake);\n    server->getNonConstConn().serverHandshakeLayer = fakeHandshake;\n    // Allow ignoring path mtu for testing negotiation.\n    server->getNonConstConn().transportSettings.canIgnorePathMTU =\n        getCanIgnorePathMTU();\n    server->getNonConstConn().transportSettings.disableMigration =\n        getDisableMigration();\n    server->setConnectionIdAlgo(connIdAlgo_.get());\n    server->setClientConnectionId(*clientConnectionId);\n    server->setClientChosenDestConnectionId(*initialDestinationConnectionId);\n    VLOG(20) << __func__ << \" client connId=\" << clientConnectionId->hex()\n             << \", server connId=\"\n             << (server->getConn().serverConnectionId\n                     ? server->getConn().serverConnectionId->hex()\n                     : \" (n/a)\");\n    server->accept();\n    setupConnection();\n    EXPECT_TRUE(server->idleTimeout().isScheduled());\n    EXPECT_EQ(server->getConn().peerConnectionIds.size(), 1);\n    EXPECT_EQ(\n        *server->getConn().clientConnectionId,\n        server->getConn().peerConnectionIds[0].connId);\n  }\n\n  std::shared_ptr<FizzServerQuicHandshakeContext> getFizzServerContext() {\n    if (!fizzServerContext) {\n      fizzServerContext = FizzServerQuicHandshakeContext::Builder()\n                              .setFizzServerContext(createServerCtx())\n                              .build();\n    }\n\n    return fizzServerContext;\n  }\n\n  virtual void initializeServerHandshake() {\n    fakeHandshake = new FakeServerHandshake(\n        server->getNonConstConn(), getFizzServerContext());\n  }\n\n  virtual bool getDisableMigration() {\n    return true;\n  }\n\n  virtual bool getCanIgnorePathMTU() {\n    return true;\n  }\n\n  std::unique_ptr<Aead> getInitialCipher(\n      QuicVersion version = QuicVersion::MVFST) {\n    FizzCryptoFactory cryptoFactory;\n    return cryptoFactory.getClientInitialCipher(\n        *initialDestinationConnectionId, version);\n  }\n\n  std::unique_ptr<PacketNumberCipher> getInitialHeaderCipher(\n      QuicVersion version = QuicVersion::MVFST) {\n    FizzCryptoFactory cryptoFactory;\n    return cryptoFactory.makeClientInitialHeaderCipher(\n        *initialDestinationConnectionId, version);\n  }\n\n  Buf recvEncryptedStream(\n      StreamId streamId,\n      folly::IOBuf& data,\n      uint64_t offset = 0,\n      bool eof = false) {\n    PacketNum packetNum = clientNextAppDataPacketNum++;\n    auto packetData = packetToBuf(createStreamPacket(\n        clientConnectionId.value_or(getTestConnectionId()),\n        *server->getConn().serverConnectionId,\n        packetNum,\n        streamId,\n        data,\n        0 /* cipherOverhead */,\n        0 /* largestAcked */,\n        folly::none /* longHeaderOverride */,\n        eof,\n        folly::none,\n        offset));\n    deliverData(packetData->clone());\n    return packetData;\n  }\n\n  void recvClientHello(\n      bool writes = true,\n      QuicVersion version = QuicVersion::MVFST) {\n    auto chlo = IOBuf::copyBuffer(\"CHLO\");\n    auto nextPacketNum = clientNextInitialPacketNum++;\n    auto aead = getInitialCipher(version);\n    auto headerCipher = getInitialHeaderCipher(version);\n    auto initialPacket = packetToBufCleartext(\n        createInitialCryptoPacket(\n            *clientConnectionId,\n            *initialDestinationConnectionId,\n            nextPacketNum,\n            version,\n            *chlo,\n            *aead,\n            0 /* largestAcked */),\n        *aead,\n        *headerCipher,\n        nextPacketNum);\n    deliverData(initialPacket->clone(), writes);\n  }\n\n  void recvClientFinished(\n      bool writes = true,\n      folly::SocketAddress* peerAddress = nullptr,\n      QuicVersion version = QuicVersion::MVFST) {\n    auto finished = IOBuf::copyBuffer(\"FINISHED\");\n    auto nextPacketNum = clientNextHandshakePacketNum++;\n    auto headerCipher = test::createNoOpHeaderCipher();\n    uint64_t offset =\n        getCryptoStream(\n            *server->getConn().cryptoState, EncryptionLevel::Handshake)\n            ->currentReadOffset;\n    auto handshakeCipher = test::createNoOpAead();\n    auto finishedPacket = packetToBufCleartext(\n        createCryptoPacket(\n            *clientConnectionId,\n            *server->getConn().serverConnectionId,\n            nextPacketNum,\n            version,\n            ProtectionType::Handshake,\n            *finished,\n            *handshakeCipher,\n            0 /* largestAcked */,\n            offset),\n        *handshakeCipher,\n        *headerCipher,\n        nextPacketNum);\n    deliverData(finishedPacket->clone(), writes, peerAddress);\n  }\n\n  virtual void setupClientReadCodec() {\n    FizzCryptoFactory cryptoFactory;\n    clientReadCodec = std::make_unique<QuicReadCodec>(QuicNodeType::Client);\n    clientReadCodec->setClientConnectionId(*clientConnectionId);\n    clientReadCodec->setInitialReadCipher(cryptoFactory.getServerInitialCipher(\n        *initialDestinationConnectionId, QuicVersion::MVFST));\n    clientReadCodec->setInitialHeaderCipher(\n        cryptoFactory.makeServerInitialHeaderCipher(\n            *initialDestinationConnectionId, QuicVersion::MVFST));\n    clientReadCodec->setCodecParameters(\n        CodecParameters(kDefaultAckDelayExponent, QuicVersion::MVFST));\n  }\n\n  virtual void expectWriteNewSessionTicket() {\n    server->setEarlyDataAppParamsFunctions(\n        [](const folly::Optional<std::string>&, const Buf&) { return false; },\n        []() -> Buf {\n          // This function shouldn't be called\n          EXPECT_TRUE(false);\n          return nullptr;\n        });\n    EXPECT_CALL(*getFakeHandshakeLayer(), writeNewSessionTicket(_)).Times(0);\n  }\n\n  virtual void setupConnection() {\n    EXPECT_EQ(server->getConn().readCodec, nullptr);\n    EXPECT_EQ(server->getConn().statsCallback, transportInfoCb_.get());\n    setupClientReadCodec();\n    recvClientHello();\n\n    IOBufEqualTo eq;\n    EXPECT_TRUE(eq(getCryptoStreamData(), IOBuf::copyBuffer(\"SHLO\")));\n    serverWrites.clear();\n\n    EXPECT_NE(server->getConn().readCodec, nullptr);\n    EXPECT_NE(server->getConn().initialWriteCipher, nullptr);\n    EXPECT_NE(server->getConn().initialHeaderCipher, nullptr);\n    EXPECT_NE(server->getConn().handshakeWriteCipher, nullptr);\n    EXPECT_NE(server->getConn().handshakeWriteHeaderCipher, nullptr);\n    EXPECT_NE(server->getConn().readCodec->getHandshakeHeaderCipher(), nullptr);\n\n    EXPECT_FALSE(server->getConn().localConnectionError.has_value());\n    EXPECT_EQ(server->getConn().version, QuicVersion::MVFST);\n    EXPECT_EQ(server->getConn().serverConnIdParams->processId, 0);\n    EXPECT_EQ(server->getConn().serverConnIdParams->workerId, 1);\n    EXPECT_TRUE(server->getConn().serverConnectionId.has_value());\n    EXPECT_EQ(server->getConn().selfConnectionIds.size(), 1);\n    serverConnectionId = *server->getConn().serverConnectionId;\n    EXPECT_EQ(\n        server->getConn().selfConnectionIds[0].connId, serverConnectionId);\n    // the crypto data should have been written in the previous loop, verify\n    // that the write loop callback is not scheduled any more since we don't\n    // have keys to write acks. This assumes that we will schedule crypto data\n    // as soon as we can.\n    EXPECT_FALSE(server->writeLooper()->isLoopCallbackScheduled());\n    EXPECT_FALSE(server->readLooper()->isLoopCallbackScheduled());\n\n    expectWriteNewSessionTicket();\n    // Once oneRtt keys are available, ServerTransport must call the\n    // onConnectionIdBound on its 'routingCallback'\n    EXPECT_CALL(routingCallback, onConnectionIdBound(_))\n        .WillOnce(Invoke([&, clientAddr = clientAddr](auto transport) {\n          EXPECT_EQ(clientAddr, transport->getOriginalPeerAddress());\n        }));\n\n    EXPECT_TRUE(server->getConn().pendingEvents.frames.empty());\n    EXPECT_EQ(server->getConn().nextSelfConnectionIdSequence, 1);\n    recvClientFinished();\n\n    // We need an extra pump here for some reason.\n    loopForWrites();\n\n    // Issue (kMinNumAvailableConnIds - 1) more connection ids on handshake\n    // complete\n    auto numNewConnIdFrames = 0;\n    for (const auto& packet : server->getConn().outstandings.packets) {\n      for (const auto& frame : packet.packet.frames) {\n        switch (frame.type()) {\n          case QuicWriteFrame::Type::QuicSimpleFrame: {\n            const auto writeFrame = frame.asQuicSimpleFrame();\n            if (writeFrame->type() ==\n                QuicSimpleFrame::Type::NewConnectionIdFrame) {\n              ++numNewConnIdFrames;\n            }\n            break;\n          }\n          default:\n            break;\n        }\n      }\n    }\n    uint64_t connIdsToIssue = std::min(\n                                  server->getConn().peerActiveConnectionIdLimit,\n                                  kDefaultActiveConnectionIdLimit) -\n        1;\n\n    if (server->getConn().transportSettings.disableMigration ||\n        (connIdsToIssue == 0)) {\n      EXPECT_EQ(numNewConnIdFrames, 0);\n      EXPECT_EQ(server->getConn().nextSelfConnectionIdSequence, 1);\n    } else {\n      EXPECT_EQ(numNewConnIdFrames, connIdsToIssue);\n      EXPECT_EQ(\n          server->getConn().nextSelfConnectionIdSequence, connIdsToIssue + 1);\n    }\n\n    EXPECT_NE(server->getConn().readCodec, nullptr);\n    EXPECT_NE(server->getConn().oneRttWriteCipher, nullptr);\n    EXPECT_NE(server->getConn().oneRttWriteHeaderCipher, nullptr);\n    EXPECT_NE(server->getConn().readCodec->getOneRttHeaderCipher(), nullptr);\n\n    EXPECT_TRUE(getCryptoStream(\n                    *server->getConn().cryptoState, EncryptionLevel::Initial)\n                    ->readBuffer.empty());\n    EXPECT_FALSE(server->getConn().localConnectionError.has_value());\n    verifyTransportParameters(kDefaultIdleTimeout);\n    serverWrites.clear();\n\n    auto& cryptoState = server->getConn().cryptoState;\n    EXPECT_EQ(cryptoState->handshakeStream.retransmissionBuffer.size(), 0);\n    EXPECT_EQ(cryptoState->oneRttStream.retransmissionBuffer.size(), 0);\n  }\n\n  void verifyTransportParameters(std::chrono::milliseconds idleTimeout) {\n    EXPECT_EQ(server->getConn().peerIdleTimeout, idleTimeout);\n    if (getCanIgnorePathMTU()) {\n      EXPECT_EQ(\n          server->getConn().udpSendPacketLen, fakeHandshake->maxRecvPacketSize);\n    }\n  }\n\n  void deliverDataWithoutErrorCheck(\n      Buf data,\n      bool writes = true,\n      folly::SocketAddress* peer = nullptr) {\n    data->coalesce();\n    server->onNetworkData(\n        peer == nullptr ? clientAddr : *peer,\n        NetworkData(std::move(data), Clock::now()));\n    if (writes) {\n      loopForWrites();\n    }\n  }\n\n  void deliverData(\n      Buf data,\n      bool writes = true,\n      folly::SocketAddress* peer = nullptr) {\n    deliverDataWithoutErrorCheck(std::move(data), writes, peer);\n    if (server->getConn().localConnectionError) {\n      bool idleTimeout = false;\n      const LocalErrorCode* localError =\n          server->getConn().localConnectionError->first.asLocalErrorCode();\n      if (localError) {\n        idleTimeout = (*localError == LocalErrorCode::IDLE_TIMEOUT);\n      }\n      if (!idleTimeout) {\n        throw std::runtime_error(\n            toString(server->getConn().localConnectionError->first));\n      }\n    }\n  }\n\n  void loopForWrites() {\n    evb.loopOnce(EVLOOP_NONBLOCK);\n  }\n\n  Buf getCryptoStreamData() {\n    CHECK(!serverWrites.empty());\n    auto cryptoBuf = IOBuf::create(0);\n    AckStates ackStates;\n    for (auto& serverWrite : serverWrites) {\n      auto packetQueue = bufToQueue(serverWrite->clone());\n      auto result = clientReadCodec->parsePacket(packetQueue, ackStates);\n      auto& parsedPacket = *result.regularPacket();\n      for (auto& frame : parsedPacket.frames) {\n        if (frame.type() != QuicFrame::Type::ReadCryptoFrame) {\n          continue;\n        }\n        cryptoBuf->prependChain(frame.asReadCryptoFrame()->data->clone());\n      }\n    }\n    return cryptoBuf;\n  }\n\n  std::unique_ptr<QuicReadCodec> makeClientEncryptedCodec(\n      bool handshakeCipher = false) {\n    FizzCryptoFactory cryptoFactory;\n    auto readCodec = std::make_unique<QuicReadCodec>(QuicNodeType::Client);\n    readCodec->setOneRttReadCipher(test::createNoOpAead());\n    readCodec->setOneRttHeaderCipher(test::createNoOpHeaderCipher());\n    readCodec->setHandshakeReadCipher(test::createNoOpAead());\n    readCodec->setHandshakeHeaderCipher(test::createNoOpHeaderCipher());\n    readCodec->setClientConnectionId(*clientConnectionId);\n    readCodec->setCodecParameters(\n        CodecParameters(kDefaultAckDelayExponent, QuicVersion::MVFST));\n    if (handshakeCipher) {\n      readCodec->setInitialReadCipher(cryptoFactory.getServerInitialCipher(\n          *initialDestinationConnectionId, QuicVersion::MVFST));\n      readCodec->setInitialHeaderCipher(\n          cryptoFactory.makeServerInitialHeaderCipher(\n              *initialDestinationConnectionId, QuicVersion::MVFST));\n    }\n    return readCodec;\n  }\n\n  FakeServerHandshake* getFakeHandshakeLayer() {\n    return CHECK_NOTNULL(dynamic_cast<FakeServerHandshake*>(\n        server->getNonConstConn().handshakeLayer.get()));\n  }\n\n  void checkTransportStateUpdate(\n      const std::shared_ptr<FileQLogger>& qLogger,\n      const std::string& msg) {\n    std::vector<int> indices =\n        getQLogEventIndices(QLogEventType::TransportStateUpdate, qLogger);\n    EXPECT_EQ(indices.size(), 1);\n    auto tmp = std::move(qLogger->logs[indices[0]]);\n    auto event = dynamic_cast<QLogTransportStateUpdateEvent*>(tmp.get());\n    EXPECT_EQ(event->update, getPeerClose(msg));\n  }\n\n  EventBase evb;\n  SocketAddress serverAddr;\n  SocketAddress clientAddr;\n  NiceMock<MockConnectionCallback> connCallback;\n  NiceMock<MockRoutingCallback> routingCallback;\n  folly::Optional<ConnectionId> clientConnectionId;\n  folly::Optional<ConnectionId> initialDestinationConnectionId;\n  folly::Optional<ConnectionId> serverConnectionId;\n  std::unique_ptr<QuicReadCodec> clientReadCodec;\n  std::vector<Buf> serverWrites;\n  std::shared_ptr<fizz::server::FizzServerContext> serverCtx;\n\n  std::vector<QuicVersion> supportedVersions;\n  std::unique_ptr<MockQuicStats> transportInfoCb_;\n  std::unique_ptr<ConnectionIdAlgo> connIdAlgo_;\n  std::shared_ptr<CongestionControllerFactory> ccFactory_;\n  std::shared_ptr<TestingQuicServerTransport> server;\n  folly::test::MockAsyncUDPSocket* socket;\n  FakeServerHandshake* fakeHandshake{nullptr};\n  std::shared_ptr<FizzServerQuicHandshakeContext> fizzServerContext;\n  PacketNum clientNextInitialPacketNum{0}, clientNextHandshakePacketNum{0},\n      clientNextAppDataPacketNum{0};\n};\n\nTEST_F(QuicServerTransportTest, TestReadMultipleStreams) {\n  PacketNum clientPacketNum = clientNextAppDataPacketNum++;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientPacketNum);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n\n  auto buf1 = IOBuf::copyBuffer(\"Aloha\");\n  auto buf2 = IOBuf::copyBuffer(\"Hello\");\n\n  auto dataLen = writeStreamFrameHeader(\n      builder,\n      0x08,\n      0,\n      buf1->computeChainDataLength(),\n      buf1->computeChainDataLength(),\n      true,\n      folly::none /* skipLenHint */);\n  ASSERT_TRUE(dataLen);\n  ASSERT_EQ(*dataLen, buf1->computeChainDataLength());\n  writeStreamFrameData(builder, buf1->clone(), buf1->computeChainDataLength());\n\n  dataLen = writeStreamFrameHeader(\n      builder,\n      0x0C,\n      0,\n      buf1->computeChainDataLength(),\n      buf1->computeChainDataLength(),\n      true,\n      folly::none /* skipLenHint */);\n  ASSERT_TRUE(dataLen);\n  ASSERT_EQ(*dataLen, buf1->computeChainDataLength());\n  writeStreamFrameData(builder, buf2->clone(), buf2->computeChainDataLength());\n\n  auto packet = std::move(builder).buildPacket();\n\n  // Clear out the existing acks to make sure that we are the cause of the acks.\n  server->getNonConstConn().ackStates.initialAckState.acks.clear();\n  server->getNonConstConn().ackStates.initialAckState.largestRecvdPacketTime =\n      folly::none;\n  server->getNonConstConn().ackStates.handshakeAckState.acks.clear();\n  server->getNonConstConn().ackStates.handshakeAckState.largestRecvdPacketTime =\n      folly::none;\n  server->getNonConstConn().ackStates.appDataAckState.acks.clear();\n  server->getNonConstConn().ackStates.appDataAckState.largestRecvdPacketTime =\n      folly::none;\n\n  EXPECT_CALL(*transportInfoCb_, onNewQuicStream()).Times(2); // for x08, x0C\n  deliverData(packetToBuf(packet));\n\n  EXPECT_TRUE(\n      server->getConn()\n          .ackStates.appDataAckState.largestRecvdPacketTime.has_value());\n  EXPECT_EQ(server->getConn().ackStates.appDataAckState.acks.size(), 1);\n  EXPECT_EQ(\n      server->getConn().ackStates.appDataAckState.acks.front().start,\n      clientPacketNum);\n  EXPECT_EQ(\n      server->getConn().ackStates.appDataAckState.acks.front().end,\n      clientPacketNum);\n  ASSERT_EQ(server->getConn().streamManager->streamCount(), 2);\n  IOBufEqualTo eq;\n\n  auto stream = server->getNonConstConn().streamManager->findStream(0x08);\n  ASSERT_TRUE(stream);\n  auto streamData = readDataFromQuicStream(*stream);\n  EXPECT_TRUE(eq(buf1, streamData.first));\n  EXPECT_TRUE(streamData.second);\n\n  auto stream2 = server->getNonConstConn().streamManager->findStream(0x0C);\n  ASSERT_TRUE(stream2);\n  auto streamData2 = readDataFromQuicStream(*stream2);\n  EXPECT_TRUE(eq(buf2, streamData2.first));\n  EXPECT_TRUE(streamData2.second);\n  EXPECT_CALL(*transportInfoCb_, onQuicStreamClosed()).Times(2);\n}\n\nTEST_F(QuicServerTransportTest, TestInvalidServerStream) {\n  EXPECT_CALL(*transportInfoCb_, onNewQuicStream()).Times(0);\n  StreamId streamId = 0x01;\n  auto data = IOBuf::copyBuffer(\"Aloha\");\n  EXPECT_THROW(recvEncryptedStream(streamId, *data), std::runtime_error);\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAckled */));\n  EXPECT_THROW(deliverData(std::move(packetData)), std::runtime_error);\n  ASSERT_EQ(server->getConn().streamManager->streamCount(), 0);\n}\n\nTEST_F(QuicServerTransportTest, IdleTimerResetOnRecvNewData) {\n  EXPECT_CALL(*transportInfoCb_, onNewQuicStream()).Times(1);\n  StreamId streamId = server->createBidirectionalStream().value();\n  auto expected = IOBuf::copyBuffer(\"hello\");\n  auto packet = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId,\n      *expected,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  server->idleTimeout().cancelTimeout();\n  ASSERT_FALSE(server->idleTimeout().isScheduled());\n  recvEncryptedStream(streamId, *expected);\n  ASSERT_TRUE(server->idleTimeout().isScheduled());\n  EXPECT_CALL(*transportInfoCb_, onQuicStreamClosed());\n}\n\nTEST_F(QuicServerTransportTest, IdleTimerNotResetOnDuplicatePacket) {\n  EXPECT_CALL(*transportInfoCb_, onNewQuicStream()).Times(1);\n  StreamId streamId = server->createBidirectionalStream().value();\n\n  auto expected = IOBuf::copyBuffer(\"hello\");\n  auto packet = recvEncryptedStream(streamId, *expected);\n  ASSERT_TRUE(server->idleTimeout().isScheduled());\n\n  server->idleTimeout().cancelTimeout();\n  ASSERT_FALSE(server->idleTimeout().isScheduled());\n  // Try delivering the same packet again\n  deliverData(packet->clone(), false);\n  ASSERT_FALSE(server->idleTimeout().isScheduled());\n  EXPECT_CALL(*transportInfoCb_, onQuicStreamClosed());\n}\n\nTEST_F(QuicServerTransportTest, IdleTimerNotResetWhenDataOutstanding) {\n  // Clear the receivedNewPacketBeforeWrite flag, since we may reveice from\n  // client during the SetUp of the test case.\n  server->getNonConstConn().outstandings.packets.clear();\n  server->getNonConstConn().receivedNewPacketBeforeWrite = false;\n  server->getNonConstConn().outstandings.packets.clear();\n  StreamId streamId = server->createBidirectionalStream().value();\n\n  server->idleTimeout().cancelTimeout();\n  ASSERT_FALSE(server->idleTimeout().isScheduled());\n  server->writeChain(\n      streamId,\n      IOBuf::copyBuffer(\"And if the darkness is to keep us apart\"),\n      false);\n  loopForWrites();\n  // It was the first packet\n  EXPECT_TRUE(server->idleTimeout().isScheduled());\n\n  // cancel it and write something else. This time idle timer shouldn't set.\n  server->idleTimeout().cancelTimeout();\n  EXPECT_FALSE(server->idleTimeout().isScheduled());\n  server->writeChain(\n      streamId,\n      IOBuf::copyBuffer(\"And if the daylight feels like it's a long way off\"),\n      false);\n  loopForWrites();\n  EXPECT_FALSE(server->idleTimeout().isScheduled());\n}\n\nTEST_F(QuicServerTransportTest, TimeoutsNotSetAfterClose) {\n  StreamId streamId = server->createBidirectionalStream().value();\n\n  auto expected = IOBuf::copyBuffer(\"hello\");\n  auto packet = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId,\n      *expected,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n  server->close(std::make_pair(\n      QuicErrorCode(TransportErrorCode::INTERNAL_ERROR),\n      std::string(\"how about no\")));\n  server->idleTimeout().cancelTimeout();\n  ASSERT_FALSE(server->idleTimeout().isScheduled());\n\n  deliverDataWithoutErrorCheck(packet->clone());\n  ASSERT_FALSE(server->idleTimeout().isScheduled());\n  ASSERT_FALSE(server->lossTimeout().isScheduled());\n  ASSERT_FALSE(server->ackTimeout().isScheduled());\n  ASSERT_TRUE(server->drainTimeout().isScheduled());\n}\n\nTEST_F(QuicServerTransportTest, InvalidMigrationNoDrain) {\n  StreamId streamId = server->createBidirectionalStream().value();\n\n  auto expected = IOBuf::copyBuffer(\"hello\");\n  auto packet = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId,\n      *expected,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n  server->close(std::make_pair(\n      QuicErrorCode(TransportErrorCode::INVALID_MIGRATION),\n      std::string(\"migration disabled\")));\n  server->idleTimeout().cancelTimeout();\n  ASSERT_FALSE(server->idleTimeout().isScheduled());\n\n  deliverDataWithoutErrorCheck(packet->clone());\n  ASSERT_FALSE(server->idleTimeout().isScheduled());\n  ASSERT_FALSE(server->lossTimeout().isScheduled());\n  ASSERT_FALSE(server->ackTimeout().isScheduled());\n  ASSERT_FALSE(server->drainTimeout().isScheduled());\n}\n\nTEST_F(QuicServerTransportTest, IdleTimeoutExpired) {\n  server->idleTimeout().timeoutExpired();\n\n  EXPECT_FALSE(server->idleTimeout().isScheduled());\n  EXPECT_TRUE(server->isDraining());\n  EXPECT_TRUE(server->isClosed());\n  auto serverReadCodec = makeClientEncryptedCodec();\n  EXPECT_FALSE(verifyFramePresent(\n      serverWrites, *serverReadCodec, QuicFrame::Type::ConnectionCloseFrame));\n  EXPECT_FALSE(verifyFramePresent(\n      serverWrites, *serverReadCodec, QuicFrame::Type::ConnectionCloseFrame));\n}\n\nTEST_F(QuicServerTransportTest, RecvDataAfterIdleTimeout) {\n  server->idleTimeout().timeoutExpired();\n\n  EXPECT_FALSE(server->idleTimeout().isScheduled());\n  EXPECT_TRUE(server->isDraining());\n  EXPECT_TRUE(server->isClosed());\n\n  serverWrites.clear();\n  StreamId streamId = 11;\n  auto expected = IOBuf::copyBuffer(\"hello\");\n  recvEncryptedStream(streamId, *expected);\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(true),\n      QuicFrame::Type::ConnectionCloseFrame));\n}\n\nTEST_F(QuicServerTransportTest, TestCloseConnectionWithError) {\n  server->close(std::make_pair(\n      QuicErrorCode(GenericApplicationErrorCode::UNKNOWN),\n      std::string(\"stopping\")));\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n}\n\nTEST_F(QuicServerTransportTest, TestCloseConnectionWithNoError) {\n  server->close(std::make_pair(\n      QuicErrorCode(GenericApplicationErrorCode::UNKNOWN),\n      std::string(\"stopping\")));\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n}\n\nTEST_F(QuicServerTransportTest, TestClientAddressChanges) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n  StreamId streamId = 4;\n  clientAddr = folly::SocketAddress(\"127.0.0.1\", 2000);\n  auto data = IOBuf::copyBuffer(\"data\");\n  EXPECT_THROW(\n      recvEncryptedStream(streamId, *data, 0, true), std::runtime_error);\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n\n  std::vector<int> indices =\n      getQLogEventIndices(QLogEventType::PacketDrop, qLogger);\n  EXPECT_EQ(indices.size(), 1);\n  auto tmp = std::move(qLogger->logs[indices[0]]);\n  auto event = dynamic_cast<QLogPacketDropEvent*>(tmp.get());\n  EXPECT_EQ(event->packetSize, 29);\n  EXPECT_EQ(\n      event->dropReason,\n      QuicTransportStatsCallback::toString(\n          PacketDropReason::PEER_ADDRESS_CHANGE));\n}\n\nTEST_F(QuicServerTransportTest, TestCloseConnectionWithNoErrorPendingStreams) {\n  auto streamId = server->createBidirectionalStream().value();\n\n  server->writeChain(streamId, IOBuf::copyBuffer(\"hello\"), true);\n  loopForWrites();\n\n  AckBlocks acks;\n  auto start = getFirstOutstandingPacket(\n                   server->getNonConstConn(), PacketNumberSpace::AppData)\n                   ->packet.header.getPacketSequenceNum();\n  auto end = getLastOutstandingPacket(\n                 server->getNonConstConn(), PacketNumberSpace::AppData)\n                 ->packet.header.getPacketSequenceNum();\n  acks.insert(start, end);\n  deliverData(packetToBuf(createAckPacket(\n      server->getNonConstConn(),\n      ++clientNextAppDataPacketNum,\n      acks,\n      PacketNumberSpace::AppData)));\n  server->close(std::make_pair(\n      QuicErrorCode(GenericApplicationErrorCode::UNKNOWN),\n      std::string(\"stopping\")));\n\n  EXPECT_THROW(\n      recvEncryptedStream(streamId, *IOBuf::copyBuffer(\"hello\")),\n      std::runtime_error);\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n}\n\nTEST_F(QuicServerTransportTest, ReceivePacketAfterLocalError) {\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n\n  // Deliver a reset to non existent stream to trigger a local conn error\n  StreamId streamId = 0x01;\n  RstStreamFrame rstFrame(streamId, GenericApplicationErrorCode::UNKNOWN, 0);\n  writeFrame(std::move(rstFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  deliverDataWithoutErrorCheck(packetToBuf(packet));\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  serverWrites.clear();\n\n  ShortHeader header2(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder2(\n      server->getConn().udpSendPacketLen,\n      std::move(header2),\n      0 /* largestAcked */);\n  builder2.encodePacketHeader();\n  RstStreamFrame rstFrame2(streamId, GenericApplicationErrorCode::UNKNOWN, 0);\n  writeFrame(std::move(rstFrame2), builder2);\n  auto packet2 = std::move(builder2).buildPacket();\n  deliverDataWithoutErrorCheck(packetToBuf(packet2));\n  EXPECT_TRUE(hasNotReceivedNewPacketsSinceLastCloseSent(server->getConn()));\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n}\n\nTEST_F(QuicServerTransportTest, ReceiveCloseAfterLocalError) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n\n  // Deliver a reset to non existent stream to trigger a local conn error\n  StreamId streamId = 0x01;\n  RstStreamFrame rstFrame(streamId, GenericApplicationErrorCode::UNKNOWN, 0);\n  writeFrame(std::move(rstFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  deliverDataWithoutErrorCheck(packetToBuf(packet));\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  serverWrites.clear();\n\n  auto currLargestReceivedPacketNum =\n      server->getConn().ackStates.appDataAckState.largestReceivedPacketNum;\n  EXPECT_TRUE(hasNotReceivedNewPacketsSinceLastCloseSent(server->getConn()));\n\n  ShortHeader header2(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder2(\n      server->getConn().udpSendPacketLen,\n      std::move(header2),\n      0 /* largestAcked */);\n  builder2.encodePacketHeader();\n  std::string errMsg = \"Mind the gap\";\n  ConnectionCloseFrame connClose(\n      QuicErrorCode(TransportErrorCode::NO_ERROR), errMsg);\n  writeFrame(std::move(connClose), builder2);\n\n  auto packet2 = std::move(builder2).buildPacket();\n  deliverDataWithoutErrorCheck(packetToBuf(packet2));\n  EXPECT_FALSE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  EXPECT_GT(\n      server->getConn().ackStates.appDataAckState.largestReceivedPacketNum,\n      currLargestReceivedPacketNum);\n\n  // Deliver the same bad data again\n  EXPECT_CALL(*transportInfoCb_, onPacketDropped(_));\n  deliverDataWithoutErrorCheck(packetToBuf(packet));\n  EXPECT_LT(\n      server->getConn()\n          .ackStates.appDataAckState.largestReceivedAtLastCloseSent,\n      server->getConn().ackStates.appDataAckState.largestReceivedPacketNum);\n  EXPECT_FALSE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  checkTransportStateUpdate(\n      qLogger, \"Server closed by peer reason=Mind the gap\");\n}\n\nTEST_F(QuicServerTransportTest, NoDataExceptCloseProcessedAfterClosing) {\n  auto packetNum = clientNextAppDataPacketNum++;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      packetNum);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n\n  auto buf = folly::IOBuf::copyBuffer(\"hello\");\n  writeStreamFrameHeader(\n      builder,\n      4,\n      0,\n      buf->computeChainDataLength(),\n      buf->computeChainDataLength(),\n      true,\n      folly::none /* skipLenHint */);\n  writeStreamFrameData(builder, buf->clone(), buf->computeChainDataLength());\n  std::string errMsg = \"Mind the gap\";\n  ConnectionCloseFrame connClose(\n      QuicErrorCode(TransportErrorCode::NO_ERROR), errMsg);\n  writeFrame(std::move(connClose), builder);\n\n  auto packet = std::move(builder).buildPacket();\n\n  server->close(std::make_pair(\n      QuicErrorCode(GenericApplicationErrorCode::UNKNOWN),\n      std::string(\"hello\")));\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  EXPECT_TRUE(hasNotReceivedNewPacketsSinceLastCloseSent(server->getConn()));\n  serverWrites.clear();\n\n  // largestReceivedPacketNum won't be accurate because we will throw\n  // before updating the ack state.\n  deliverDataWithoutErrorCheck(packetToBuf(packet));\n  EXPECT_EQ(\n      server->getConn().ackStates.appDataAckState.largestReceivedPacketNum,\n      packetNum);\n  EXPECT_FALSE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  EXPECT_FALSE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n}\n\nTEST_F(QuicServerTransportTest, TestOpenAckStreamFrame) {\n  StreamId streamId = server->createBidirectionalStream().value();\n\n  auto data = IOBuf::copyBuffer(\"Aloha\");\n\n  // Remove any packets that might have been queued.\n  server->getNonConstConn().outstandings.packets.clear();\n  server->getNonConstConn().outstandings.initialPacketsCount = 0;\n  server->getNonConstConn().outstandings.handshakePacketsCount = 0;\n  server->writeChain(streamId, data->clone(), false);\n  loopForWrites();\n  server->writeChain(streamId, data->clone(), false);\n  server->writeChain(streamId, data->clone(), false);\n  loopForWrites();\n\n  auto stream = server->getNonConstConn().streamManager->getStream(streamId);\n  ASSERT_FALSE(server->getConn().outstandings.packets.empty());\n  ASSERT_FALSE(stream->retransmissionBuffer.empty());\n  // We need more than one packet for this test.\n  ASSERT_FALSE(server->getConn().outstandings.packets.empty());\n\n  PacketNum packetNum1 =\n      getFirstOutstandingPacket(\n          server->getNonConstConn(), PacketNumberSpace::AppData)\n          ->packet.header.getPacketSequenceNum();\n\n  PacketNum lastPacketNum =\n      getLastOutstandingPacket(\n          server->getNonConstConn(), PacketNumberSpace::AppData)\n          ->packet.header.getPacketSequenceNum();\n\n  uint32_t buffersInPacket1 = 0;\n  for (size_t i = 0; i < server->getNonConstConn().outstandings.packets.size();\n       ++i) {\n    auto& packet = server->getNonConstConn().outstandings.packets[i];\n    if (packet.packet.header.getPacketNumberSpace() !=\n        PacketNumberSpace::AppData) {\n      continue;\n    }\n    PacketNum currentPacket = packet.packet.header.getPacketSequenceNum();\n    ASSERT_FALSE(packet.packet.frames.empty());\n    for (auto& quicFrame : packet.packet.frames) {\n      auto frame = quicFrame.asWriteStreamFrame();\n      if (!frame) {\n        continue;\n      }\n      auto it = stream->retransmissionBuffer.find(frame->offset);\n      ASSERT_TRUE(it != stream->retransmissionBuffer.end());\n      if (currentPacket == packetNum1 && frame->streamId == streamId) {\n        buffersInPacket1++;\n      }\n    }\n  }\n\n  auto originalRetransSize = stream->retransmissionBuffer.size();\n  AckBlocks acks = {{packetNum1, packetNum1}};\n  auto packet1 = createAckPacket(\n      server->getNonConstConn(),\n      ++clientNextAppDataPacketNum,\n      acks,\n      PacketNumberSpace::AppData);\n  deliverData(packetToBuf(packet1));\n  EXPECT_EQ(\n      stream->retransmissionBuffer.size(),\n      originalRetransSize - buffersInPacket1);\n  EXPECT_EQ(stream->sendState, StreamSendState::Open);\n  EXPECT_EQ(stream->recvState, StreamRecvState::Open);\n\n  // Dup ack\n  auto packet2 = createAckPacket(\n      server->getNonConstConn(),\n      ++clientNextAppDataPacketNum,\n      acks,\n      PacketNumberSpace::AppData);\n  deliverData(packetToBuf(packet2));\n\n  EXPECT_EQ(\n      stream->retransmissionBuffer.size(),\n      originalRetransSize - buffersInPacket1);\n  EXPECT_EQ(stream->sendState, StreamSendState::Open);\n  EXPECT_EQ(stream->recvState, StreamRecvState::Open);\n\n  AckBlocks acks2 = {{packetNum1, lastPacketNum}};\n  auto packet3 = createAckPacket(\n      server->getNonConstConn(),\n      ++clientNextAppDataPacketNum,\n      acks2,\n      PacketNumberSpace::AppData);\n  deliverData(packetToBuf(packet3));\n\n  EXPECT_EQ(stream->retransmissionBuffer.size(), 0);\n  EXPECT_EQ(stream->sendState, StreamSendState::Open);\n  EXPECT_EQ(stream->recvState, StreamRecvState::Open);\n\n  auto empty = IOBuf::create(0);\n  server->writeChain(streamId, std::move(empty), true);\n  loopForWrites();\n  ASSERT_FALSE(server->getConn().outstandings.packets.empty());\n\n  PacketNum finPacketNum =\n      getFirstOutstandingPacket(\n          server->getNonConstConn(), PacketNumberSpace::AppData)\n          ->packet.header.getPacketSequenceNum();\n\n  AckBlocks acks3 = {{lastPacketNum, finPacketNum}};\n  auto packet4 = createAckPacket(\n      server->getNonConstConn(),\n      ++clientNextAppDataPacketNum,\n      acks3,\n      PacketNumberSpace::AppData);\n  deliverData(packetToBuf(packet4));\n  EXPECT_EQ(stream->sendState, StreamSendState::Closed);\n  EXPECT_EQ(stream->recvState, StreamRecvState::Open);\n}\n\nTEST_F(QuicServerTransportTest, RecvRstStreamFrameNonexistClientStream) {\n  StreamId streamId = 0x00;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n\n  RstStreamFrame rstFrame(streamId, GenericApplicationErrorCode::UNKNOWN, 0);\n  writeFrame(std::move(rstFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  deliverData(packetToBuf(packet));\n\n  auto stream = server->getNonConstConn().streamManager->getStream(streamId);\n  ASSERT_TRUE(stream->streamReadError.has_value());\n}\n\nTEST_F(QuicServerTransportTest, ReceiveRstStreamNonExistentAndOtherFrame) {\n  StreamId clientUnidirectional = 0x02;\n\n  // Deliver reset on peer unidirectional stream to close the stream.\n  RstStreamFrame rstFrame(\n      clientUnidirectional, GenericApplicationErrorCode::UNKNOWN, 0);\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  writeFrame(rstFrame, builder);\n  auto packet = packetToBuf(std::move(builder).buildPacket());\n  deliverData(std::move(packet));\n\n  auto streamId =\n      server->createBidirectionalStream(false /* replaySafe */).value();\n\n  ShortHeader header2(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder2(\n      server->getConn().udpSendPacketLen,\n      std::move(header2),\n      0 /* largestAcked */);\n  builder2.encodePacketHeader();\n  writeFrame(rstFrame, builder2);\n\n  auto data = folly::IOBuf::copyBuffer(\"hello\");\n  writeStreamFrameHeader(\n      builder2,\n      streamId,\n      0,\n      data->computeChainDataLength(),\n      data->computeChainDataLength(),\n      false,\n      folly::none /* skipLenHint */);\n  writeStreamFrameData(builder2, data->clone(), data->computeChainDataLength());\n  auto packetObject = std::move(builder2).buildPacket();\n  auto packet2 = packetToBuf(std::move(packetObject));\n  deliverData(std::move(packet2));\n\n  auto readData = server->read(streamId, 0);\n  ASSERT_TRUE(readData.hasValue());\n  ASSERT_NE(readData.value().first, nullptr);\n  EXPECT_TRUE(folly::IOBufEqualTo()(*readData.value().first, *data));\n}\n\nTEST_F(QuicServerTransportTest, RecvRstStreamFrameNonexistServerStream) {\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n\n  StreamId streamId = 0x01;\n  RstStreamFrame rstFrame(streamId, GenericApplicationErrorCode::UNKNOWN, 0);\n  writeFrame(std::move(rstFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  EXPECT_THROW(deliverData(packetToBuf(packet)), std::runtime_error);\n}\n\nTEST_F(QuicServerTransportTest, RecvRstStreamFrame) {\n  clientNextAppDataPacketNum = 3;\n  std::array<std::string, 4> words = {\n      \"Hey Bob, this is Alice, for real.\",\n      \"What message did I send you last time?\",\n      \"You don't sound like Alice\",\n      \"You are a liar!\",\n  };\n\n  StreamId streamId = 0x00;\n  auto stream = server->getNonConstConn().streamManager->getStream(streamId);\n  stream->readBuffer.emplace_back(IOBuf::copyBuffer(words.at(0)), 0, false);\n  stream->readBuffer.emplace_back(\n      IOBuf::copyBuffer(words.at(1)), words.at(0).length(), false);\n  stream->retransmissionBuffer.emplace(\n      std::piecewise_construct,\n      std::forward_as_tuple(0),\n      std::forward_as_tuple(std::make_unique<StreamBuffer>(\n          IOBuf::copyBuffer(words.at(2)), 0, false)));\n  writeDataToQuicStream(*stream, IOBuf::copyBuffer(words.at(3)), false);\n  stream->currentWriteOffset = words.at(2).length() + words.at(3).length();\n  stream->currentReadOffset = words.at(0).length() + words.at(1).length();\n\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 5;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n\n  RstStreamFrame rstFrame(\n      streamId,\n      GenericApplicationErrorCode::UNKNOWN,\n      words.at(0).length() + words.at(1).length());\n  ASSERT_TRUE(builder.canBuildPacket());\n  writeFrame(std::move(rstFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  deliverData(packetToBuf(packet));\n\n  // Verify stream receive state is cleaned up but send state isn't:\n  auto updatedStream =\n      server->getNonConstConn().streamManager->findStream(streamId);\n  ASSERT_TRUE(updatedStream);\n  EXPECT_TRUE(updatedStream->readBuffer.empty());\n  // We can verify retx buffer isn't empty here. The writeBuffer though could be\n  // empty since deliverData can cause a write synchrously.\n  EXPECT_FALSE(updatedStream->retransmissionBuffer.empty());\n  EXPECT_EQ(\n      words.at(0).length() + words.at(1).length(),\n      updatedStream->finalReadOffset.value());\n  // updatedStream still writable since receiving rst has no impact on egress\n  EXPECT_TRUE(updatedStream->writable());\n}\n\nTEST_F(QuicServerTransportTest, RecvStopSendingFrame) {\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 3;\n  std::array<std::string, 4> words = {\n      \"Hey Bob, this is Alice, for real.\",\n      \"What message did I send you last time?\",\n      \"You don't sound like Alice\",\n      \"You are a liar!\",\n  };\n\n  StreamId streamId = 0x00;\n  auto stream = server->getNonConstConn().streamManager->getStream(streamId);\n  stream->readBuffer.emplace_back(IOBuf::copyBuffer(words.at(0)), 0, false);\n  stream->readBuffer.emplace_back(\n      IOBuf::copyBuffer(words.at(1)), words.at(0).length(), false);\n  stream->retransmissionBuffer.emplace(\n      std::piecewise_construct,\n      std::forward_as_tuple(0),\n      std::forward_as_tuple(std::make_unique<StreamBuffer>(\n          IOBuf::copyBuffer(words.at(2)), 0, false)));\n  stream->writeBuffer.append(IOBuf::copyBuffer(words.at(3)));\n  stream->currentWriteOffset = words.at(2).length() + words.at(3).length();\n  stream->currentReadOffset = words.at(0).length() + words.at(1).length();\n\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 5;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  StopSendingFrame stopSendingFrame(\n      streamId, GenericApplicationErrorCode::UNKNOWN);\n  ASSERT_TRUE(builder.canBuildPacket());\n  writeFrame(QuicSimpleFrame(stopSendingFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  EXPECT_CALL(\n      connCallback,\n      onStopSending(streamId, GenericApplicationErrorCode::UNKNOWN));\n  deliverData(packetToBuf(packet));\n}\n\nTEST_F(QuicServerTransportTest, RecvStopSendingFrameAfterCloseStream) {\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 3;\n  std::array<std::string, 4> words = {\n      \"Hey Bob, this is Alice, for real.\",\n      \"What message did I send you last time?\",\n      \"You don't sound like Alice\",\n      \"You are a liar!\",\n  };\n\n  StreamId streamId = 0x00;\n  auto stream = server->getNonConstConn().streamManager->getStream(streamId);\n  stream->readBuffer.emplace_back(IOBuf::copyBuffer(words.at(0)), 0, false);\n  stream->readBuffer.emplace_back(\n      IOBuf::copyBuffer(words.at(1)), words.at(0).length(), false);\n  stream->retransmissionBuffer.emplace(\n      std::piecewise_construct,\n      std::forward_as_tuple(0),\n      std::forward_as_tuple(std::make_unique<StreamBuffer>(\n          IOBuf::copyBuffer(words.at(2)), 0, false)));\n  stream->writeBuffer.append(IOBuf::copyBuffer(words.at(3)));\n  stream->currentWriteOffset = words.at(2).length() + words.at(3).length();\n  stream->currentReadOffset = words.at(0).length() + words.at(1).length();\n  server->getNonConstConn().flowControlState.sumCurStreamBufferLen = 100;\n\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 5;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n\n  StopSendingFrame stopSendingFrame(\n      streamId, GenericApplicationErrorCode::UNKNOWN);\n  ASSERT_TRUE(builder.canBuildPacket());\n  writeFrame(QuicSimpleFrame(stopSendingFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  server->resetStream(streamId, GenericApplicationErrorCode::UNKNOWN);\n  EXPECT_CALL(connCallback, onStopSending(_, _)).Times(0);\n  deliverData(packetToBuf(packet));\n}\n\nTEST_F(QuicServerTransportTest, RecvInvalidMaxStreamData) {\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 3;\n  std::array<std::string, 4> words = {\n      \"Hey Bob, this is Alice, for real.\",\n      \"What message did I send you last time?\",\n      \"You don't sound like Alice\",\n      \"You are a liar!\",\n  };\n\n  StreamId streamId = 0x02;\n  auto stream = server->getNonConstConn().streamManager->getStream(streamId);\n  stream->readBuffer.emplace_back(IOBuf::copyBuffer(words.at(0)), 0, false);\n  stream->readBuffer.emplace_back(\n      IOBuf::copyBuffer(words.at(1)), words.at(0).length(), false);\n  stream->retransmissionBuffer.emplace(\n      std::piecewise_construct,\n      std::forward_as_tuple(0),\n      std::forward_as_tuple(std::make_unique<StreamBuffer>(\n          IOBuf::copyBuffer(words.at(2)), 0, false)));\n  stream->writeBuffer.append(IOBuf::copyBuffer(words.at(3)));\n  stream->currentWriteOffset = words.at(2).length() + words.at(3).length();\n  stream->currentReadOffset = words.at(0).length() + words.at(1).length();\n  server->getNonConstConn().flowControlState.sumCurStreamBufferLen = 100;\n\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 5;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n\n  MaxStreamDataFrame maxStreamDataFrame(streamId, 100);\n  ASSERT_TRUE(builder.canBuildPacket());\n  writeFrame(std::move(maxStreamDataFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  EXPECT_THROW(deliverData(packetToBuf(packet)), std::runtime_error);\n}\n\nTEST_F(QuicServerTransportTest, RecvStopSendingFrameAfterHalfCloseRemote) {\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 3;\n  std::array<std::string, 4> words = {\n      \"Hey Bob, this is Alice, for real.\",\n      \"What message did I send you last time?\",\n      \"You don't sound like Alice\",\n      \"You are a liar!\",\n  };\n\n  StreamId streamId = 0x00;\n  auto stream = server->getNonConstConn().streamManager->getStream(streamId);\n  stream->readBuffer.emplace_back(IOBuf::copyBuffer(words.at(0)), 0, false);\n  stream->readBuffer.emplace_back(\n      IOBuf::copyBuffer(words.at(1)), words.at(0).length(), false);\n  stream->retransmissionBuffer.emplace(\n      std::piecewise_construct,\n      std::forward_as_tuple(0),\n      std::forward_as_tuple(std::make_unique<StreamBuffer>(\n          IOBuf::copyBuffer(words.at(2)), 0, false)));\n  stream->writeBuffer.append(IOBuf::copyBuffer(words.at(3)));\n  stream->currentWriteOffset = words.at(2).length() + words.at(3).length();\n  stream->currentReadOffset = words.at(0).length() + words.at(1).length();\n\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 5;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n\n  StopSendingFrame stopSendingFrame(\n      streamId, GenericApplicationErrorCode::UNKNOWN);\n  ASSERT_TRUE(builder.canBuildPacket());\n  auto dataLen = writeStreamFrameHeader(\n      builder,\n      0x00,\n      stream->currentReadOffset,\n      0,\n      10,\n      true,\n      folly::none /* skipLenHint */);\n  ASSERT_TRUE(dataLen.has_value());\n  ASSERT_EQ(*dataLen, 0);\n  writeFrame(QuicSimpleFrame(stopSendingFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  EXPECT_CALL(\n      connCallback,\n      onStopSending(streamId, GenericApplicationErrorCode::UNKNOWN));\n  deliverData(packetToBuf(packet));\n}\n\nTEST_F(QuicServerTransportTest, RecvStopSendingBeforeStream) {\n  StreamId streamId = 0x00;\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 3;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n\n  StopSendingFrame stopSendingFrame(\n      streamId, GenericApplicationErrorCode::UNKNOWN);\n  ASSERT_TRUE(builder.canBuildPacket());\n  writeFrame(QuicSimpleFrame(stopSendingFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  EXPECT_CALL(connCallback, onNewBidirectionalStream(streamId));\n  EXPECT_CALL(\n      connCallback,\n      onStopSending(streamId, GenericApplicationErrorCode::UNKNOWN));\n  deliverData(packetToBuf(packet));\n}\n\nTEST_F(QuicServerTransportTest, RecvStopSendingFrameAfterReset) {\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 3;\n  std::array<std::string, 4> words = {\n      \"Hey Bob, this is Alice, for real.\",\n      \"What message did I send you last time?\",\n      \"You don't sound like Alice\",\n      \"You are a liar!\",\n  };\n\n  StreamId streamId1 = 0x00;\n  StreamId streamId2 = 0x04;\n  auto stream1 = server->getNonConstConn().streamManager->getStream(streamId1);\n  stream1->readBuffer.emplace_back(IOBuf::copyBuffer(words.at(0)), 0, false);\n  stream1->readBuffer.emplace_back(\n      IOBuf::copyBuffer(words.at(1)), words.at(0).length(), false);\n  stream1->retransmissionBuffer.emplace(\n      std::piecewise_construct,\n      std::forward_as_tuple(0),\n      std::forward_as_tuple(std::make_unique<StreamBuffer>(\n          IOBuf::copyBuffer(words.at(2)), 0, false)));\n  stream1->writeBuffer.append(IOBuf::copyBuffer(words.at(3)));\n  stream1->currentWriteOffset = words.at(2).length() + words.at(3).length();\n  stream1->currentReadOffset = words.at(0).length() + words.at(1).length();\n  auto stream2 = server->getNonConstConn().streamManager->getStream(streamId2);\n  stream2->readBuffer.emplace_back(IOBuf::copyBuffer(words.at(0)), 0, false);\n  stream2->readBuffer.emplace_back(\n      IOBuf::copyBuffer(words.at(1)), words.at(0).length(), false);\n  stream2->retransmissionBuffer.emplace(\n      std::piecewise_construct,\n      std::forward_as_tuple(0),\n      std::forward_as_tuple(std::make_unique<StreamBuffer>(\n          IOBuf::copyBuffer(words.at(2)), 0, false)));\n  stream2->writeBuffer.append(IOBuf::copyBuffer(words.at(3)));\n  stream2->currentWriteOffset = words.at(2).length() + words.at(3).length();\n  stream2->currentReadOffset = words.at(0).length() + words.at(1).length();\n\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 5;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n\n  StopSendingFrame stopSendingFrame1(\n      streamId1, GenericApplicationErrorCode::UNKNOWN);\n  StopSendingFrame stopSendingFrame2(\n      streamId2, GenericApplicationErrorCode::UNKNOWN);\n  ASSERT_TRUE(builder.canBuildPacket());\n  writeFrame(QuicSimpleFrame(stopSendingFrame1), builder);\n  writeFrame(QuicSimpleFrame(stopSendingFrame2), builder);\n  auto packet = std::move(builder).buildPacket();\n  EXPECT_CALL(\n      connCallback, onStopSending(_, GenericApplicationErrorCode::UNKNOWN))\n      .WillOnce(Invoke([&](StreamId /*sid*/, ApplicationErrorCode /*e*/) {\n        server->close(folly::none);\n      }));\n  EXPECT_THROW(deliverData(packetToBuf(packet)), std::runtime_error);\n}\n\nTEST_F(QuicServerTransportTest, StopSendingLoss) {\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 3;\n  auto streamId = server->createBidirectionalStream().value();\n  server->getNonConstConn().streamManager->getStream(streamId);\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      server->getNonConstConn().ackStates.appDataAckState.nextPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      server->getConn().ackStates.appDataAckState.largestAckedByPeer.value_or(\n          0));\n  builder.encodePacketHeader();\n  StopSendingFrame stopSendingFrame(\n      streamId, GenericApplicationErrorCode::UNKNOWN);\n  ASSERT_TRUE(builder.canBuildPacket());\n  writeFrame(QuicSimpleFrame(stopSendingFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  markPacketLoss(server->getNonConstConn(), packet.packet, false);\n  EXPECT_EQ(server->getNonConstConn().pendingEvents.frames.size(), 1);\n  StopSendingFrame* stopFrame = server->getNonConstConn()\n                                    .pendingEvents.frames.front()\n                                    .asStopSendingFrame();\n  ASSERT_NE(stopFrame, nullptr);\n  EXPECT_EQ(*stopFrame, stopSendingFrame);\n}\n\nTEST_F(QuicServerTransportTest, StopSendingLossAfterStreamClosed) {\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 3;\n  auto streamId = server->createBidirectionalStream().value();\n  server->getNonConstConn().streamManager->getStream(streamId);\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      server->getConn().ackStates.appDataAckState.largestAckedByPeer.value_or(\n          0));\n  builder.encodePacketHeader();\n  StopSendingFrame stopSendingFrame(\n      streamId, GenericApplicationErrorCode::UNKNOWN);\n  ASSERT_TRUE(builder.canBuildPacket());\n  writeFrame(QuicSimpleFrame(stopSendingFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n\n  // clear out all the streams, this is not a great way to simulate closed\n  // streams, but good enough for this test.\n  server->getNonConstConn().streamManager->clearOpenStreams();\n  markPacketLoss(server->getNonConstConn(), packet.packet, false);\n  EXPECT_EQ(server->getNonConstConn().pendingEvents.frames.size(), 0);\n}\n\nTEST_F(QuicServerTransportTest, TestCloneStopSending) {\n  auto streamId = server->createBidirectionalStream().value();\n  auto qLogger = std::make_shared<quic::FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n  server->getNonConstConn().streamManager->getStream(streamId);\n  // knock every handshake outstanding packets out\n  server->getNonConstConn().outstandings.initialPacketsCount = 0;\n  server->getNonConstConn().outstandings.handshakePacketsCount = 0;\n  server->getNonConstConn().outstandings.packets.clear();\n  for (auto& t : server->getNonConstConn().lossState.lossTimes) {\n    t.reset();\n  }\n\n  server->stopSending(streamId, GenericApplicationErrorCode::UNKNOWN);\n  loopForWrites();\n  // Find the outstanding StopSending.\n  auto packetItr = std::find_if(\n      server->getNonConstConn().outstandings.packets.begin(),\n      server->getNonConstConn().outstandings.packets.end(),\n      findFrameInPacketFunc<QuicSimpleFrame::Type::StopSendingFrame>());\n\n  ASSERT_TRUE(\n      packetItr != server->getNonConstConn().outstandings.packets.end());\n  // Force a timeout with no data so that it clones the packet\n  server->lossTimeout().timeoutExpired();\n  loopForWrites();\n  auto numStopSendingPackets = std::count_if(\n      server->getNonConstConn().outstandings.packets.begin(),\n      server->getNonConstConn().outstandings.packets.end(),\n      findFrameInPacketFunc<QuicSimpleFrame::Type::StopSendingFrame>());\n\n  EXPECT_GT(numStopSendingPackets, 1);\n\n  std::vector<int> indices =\n      getQLogEventIndices(QLogEventType::TransportStateUpdate, qLogger);\n  EXPECT_EQ(indices.size(), 1);\n  auto tmp = std::move(qLogger->logs[indices[0]]);\n  auto event = dynamic_cast<QLogTransportStateUpdateEvent*>(tmp.get());\n  EXPECT_EQ(event->update, kLossTimeoutExpired);\n}\n\nTEST_F(QuicServerTransportTest, TestAckStopSending) {\n  auto streamId = server->createBidirectionalStream().value();\n  server->getNonConstConn().streamManager->getStream(streamId);\n  server->stopSending(streamId, GenericApplicationErrorCode::UNKNOWN);\n  loopForWrites();\n  auto match = findFrameInPacketFunc<QuicSimpleFrame::Type::StopSendingFrame>();\n\n  auto op = findOutstandingPacket(server->getNonConstConn(), match);\n  ASSERT_TRUE(op != nullptr);\n  PacketNum packetNum = op->packet.header.getPacketSequenceNum();\n  AckBlocks acks = {{packetNum, packetNum}};\n  auto packet1 = createAckPacket(\n      server->getNonConstConn(),\n      ++clientNextAppDataPacketNum,\n      acks,\n      PacketNumberSpace::AppData);\n  deliverData(packetToBuf(packet1));\n  op = findOutstandingPacket(server->getNonConstConn(), match);\n  EXPECT_TRUE(op == nullptr);\n}\n\nTEST_F(QuicServerTransportTest, RecvPathChallenge) {\n  auto& conn = server->getNonConstConn();\n\n  // Add additional peer id so PathResponse completes.\n  conn.peerConnectionIds.emplace_back(ConnectionId({1, 2, 3, 4}), 1);\n\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero, *conn.serverConnectionId, 10);\n  RegularQuicPacketBuilder builder(\n      conn.udpSendPacketLen, std::move(header), 0 /* largestAcked */);\n  builder.encodePacketHeader();\n  PathChallengeFrame pathChallenge(123);\n  ASSERT_TRUE(builder.canBuildPacket());\n  writeSimpleFrame(QuicSimpleFrame(pathChallenge), builder);\n\n  auto packet = std::move(builder).buildPacket();\n\n  EXPECT_TRUE(conn.pendingEvents.frames.empty());\n  deliverData(packetToBuf(packet), false);\n  EXPECT_EQ(conn.pendingEvents.frames.size(), 2);\n  // The RetireConnectionId frame will be enqueued before the PathResponse.\n  auto retireFrame = conn.pendingEvents.frames[0].asRetireConnectionIdFrame();\n  EXPECT_EQ(retireFrame->sequenceNumber, 0);\n\n  PathResponseFrame& pathResponse =\n      *conn.pendingEvents.frames[1].asPathResponseFrame();\n  EXPECT_EQ(pathResponse.pathData, pathChallenge.pathData);\n}\n\nTEST_F(QuicServerTransportTest, TestAckRstStream) {\n  auto streamId = server->createUnidirectionalStream().value();\n  auto stream = server->getNonConstConn().streamManager->getStream(streamId);\n  auto packetNum = rstStreamAndSendPacket(\n      server->getNonConstConn(),\n      server->getSocket(),\n      *stream,\n      GenericApplicationErrorCode::UNKNOWN);\n\n  AckBlocks acks = {{packetNum, packetNum}};\n  auto packet1 = createAckPacket(\n      server->getNonConstConn(),\n      ++clientNextAppDataPacketNum,\n      acks,\n      PacketNumberSpace::AppData);\n  deliverData(packetToBuf(packet1));\n  // Closed streams should be deleted.\n  EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n}\n\nTEST_F(QuicServerTransportTest, ReceiveConnectionClose) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  std::string errMsg = \"Stand clear of the closing doors, please\";\n  ConnectionCloseFrame connClose(\n      QuicErrorCode(TransportErrorCode::NO_ERROR), errMsg);\n  writeFrame(std::move(connClose), builder);\n  auto packet = std::move(builder).buildPacket();\n  EXPECT_CALL(connCallback, onConnectionEnd());\n  deliverDataWithoutErrorCheck(packetToBuf(packet));\n  // Now the transport should be closed\n  EXPECT_EQ(\n      server->getConn().localConnectionError->first,\n      QuicErrorCode(TransportErrorCode::NO_ERROR));\n  EXPECT_EQ(\n      server->getConn().peerConnectionError->first,\n      QuicErrorCode(TransportErrorCode::NO_ERROR));\n  auto closedMsg =\n      folly::to<std::string>(\"Server closed by peer reason=\", errMsg);\n  EXPECT_EQ(server->getConn().peerConnectionError->second, closedMsg);\n  EXPECT_TRUE(server->isClosed());\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  checkTransportStateUpdate(qLogger, std::move(closedMsg));\n}\n\nTEST_F(QuicServerTransportTest, ReceiveApplicationClose) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n\n  std::string errMsg = \"Stand clear of the closing doors, please\";\n  ConnectionCloseFrame appClose(\n      QuicErrorCode(GenericApplicationErrorCode::UNKNOWN), errMsg);\n  writeFrame(std::move(appClose), builder);\n  auto packet = std::move(builder).buildPacket();\n\n  EXPECT_CALL(\n      connCallback,\n      onConnectionError(IsAppError(GenericApplicationErrorCode::UNKNOWN)));\n  deliverDataWithoutErrorCheck(packetToBuf(packet));\n  // Now the transport should be closed\n  EXPECT_EQ(\n      QuicErrorCode(TransportErrorCode::NO_ERROR),\n      server->getConn().localConnectionError->first);\n  EXPECT_EQ(\n      server->getConn().peerConnectionError->first,\n      QuicErrorCode(GenericApplicationErrorCode::UNKNOWN));\n  auto closedMsg =\n      folly::to<std::string>(\"Server closed by peer reason=\", errMsg);\n  EXPECT_EQ(server->getConn().peerConnectionError->second, closedMsg);\n  EXPECT_TRUE(server->isClosed());\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  checkTransportStateUpdate(qLogger, std::move(closedMsg));\n}\n\nTEST_F(QuicServerTransportTest, ReceiveConnectionCloseTwice) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  std::string errMsg = \"Mind the gap\";\n  ConnectionCloseFrame connClose(\n      QuicErrorCode(TransportErrorCode::NO_ERROR), errMsg);\n  writeFrame(std::move(connClose), builder);\n  auto packet = std::move(builder).buildPacket();\n  EXPECT_CALL(connCallback, onConnectionEnd());\n  deliverDataWithoutErrorCheck(packetToBuf(packet));\n  // Now the transport should be closed\n  EXPECT_EQ(\n      QuicErrorCode(TransportErrorCode::NO_ERROR),\n      server->getConn().localConnectionError->first);\n  EXPECT_EQ(\n      server->getConn().peerConnectionError->first,\n      QuicErrorCode(TransportErrorCode::NO_ERROR));\n  auto closedMsg =\n      folly::to<std::string>(\"Server closed by peer reason=\", errMsg);\n  EXPECT_EQ(server->getConn().peerConnectionError->second, closedMsg);\n  EXPECT_TRUE(server->isClosed());\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  serverWrites.clear();\n  deliverDataWithoutErrorCheck(packetToBuf(packet));\n  EXPECT_FALSE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  std::vector<int> indices =\n      getQLogEventIndices(QLogEventType::PacketDrop, qLogger);\n  EXPECT_EQ(indices.size(), 1);\n  auto tmp = std::move(qLogger->logs[indices[0]]);\n  auto event = dynamic_cast<QLogPacketDropEvent*>(tmp.get());\n  EXPECT_EQ(event->packetSize, 29);\n  EXPECT_EQ(\n      event->dropReason,\n      QuicTransportStatsCallback::toString(\n          PacketDropReason::SERVER_STATE_CLOSED));\n}\n\nTEST_F(QuicServerTransportTest, CloseTransportWontUnbound) {\n  EXPECT_CALL(routingCallback, onConnectionUnbound(_, _, _)).Times(0);\n  server->closeTransport();\n  // Need to do this otherwise server transport destructor will still call\n  // onConnectionUnbound\n  server->setRoutingCallback(nullptr);\n}\n\nTEST_F(QuicServerTransportTest, UnboundConnection) {\n  EXPECT_CALL(routingCallback, onConnectionUnbound(_, _, _)).Times(1);\n  server->unbindConnection();\n  // Need to do this otherwise server transport destructor will still call\n  // onConnectionUnbound\n  server->setRoutingCallback(nullptr);\n}\n\nTEST_F(QuicServerTransportTest, DestroyWithoutClosing) {\n  StreamId streamId = server->createBidirectionalStream().value();\n\n  MockReadCallback readCb;\n  server->setReadCallback(streamId, &readCb);\n\n  EXPECT_CALL(connCallback, onConnectionError(_)).Times(0);\n  EXPECT_CALL(connCallback, onConnectionEnd()).Times(0);\n  MockDeliveryCallback deliveryCallback;\n  auto write = IOBuf::copyBuffer(\"no\");\n  server->writeChain(streamId, write->clone(), true, &deliveryCallback);\n\n  EXPECT_CALL(deliveryCallback, onCanceled(_, _));\n  EXPECT_CALL(readCb, readError(_, _));\n\n  server.reset();\n}\n\nTEST_F(QuicServerTransportTest, DestroyWithoutClosingCancelByteEvents) {\n  StreamId streamId = server->createBidirectionalStream().value();\n\n  MockReadCallback readCb;\n  server->setReadCallback(streamId, &readCb);\n\n  EXPECT_CALL(connCallback, onConnectionError(_)).Times(0);\n  EXPECT_CALL(connCallback, onConnectionEnd()).Times(0);\n  auto write = IOBuf::copyBuffer(\"no\");\n  server->writeChain(streamId, write->clone(), true);\n\n  MockByteEventCallback txCallback;\n  MockByteEventCallback deliveryCallback;\n\n  server->registerByteEventCallback(\n      ByteEvent::Type::TX, streamId, 0, &txCallback);\n  server->registerByteEventCallback(\n      ByteEvent::Type::ACK, streamId, 0, &deliveryCallback);\n\n  EXPECT_CALL(txCallback, onByteEventCanceled(_));\n  EXPECT_CALL(deliveryCallback, onByteEventCanceled(_));\n  EXPECT_CALL(readCb, readError(_, _));\n\n  server.reset();\n}\n\nTEST_F(QuicServerTransportTest, SetCongestionControl) {\n  // Default: Cubic\n  auto cc = server->getConn().congestionController.get();\n  EXPECT_EQ(CongestionControlType::Cubic, cc->type());\n\n  // Change to Reno\n  server->setCongestionControl(CongestionControlType::NewReno);\n  cc = server->getConn().congestionController.get();\n  EXPECT_EQ(CongestionControlType::NewReno, cc->type());\n\n  // Change back to Cubic:\n  server->setCongestionControl(CongestionControlType::Cubic);\n  cc = server->getConn().congestionController.get();\n  EXPECT_EQ(CongestionControlType::Cubic, cc->type());\n}\n\nTEST_F(QuicServerTransportTest, TestServerNotDetachable) {\n  EXPECT_FALSE(server->isDetachable());\n}\n\nTEST_F(QuicServerTransportTest, SetOriginalPeerAddressSetsPacketSize) {\n  folly::SocketAddress v4Address(\"0.0.0.0\", 0);\n  ASSERT_TRUE(v4Address.getFamily() == AF_INET);\n  server->setOriginalPeerAddress(v4Address);\n  EXPECT_EQ(kDefaultV4UDPSendPacketLen, server->getConn().udpSendPacketLen);\n\n  folly::SocketAddress v6Address(\"::\", 0);\n  ASSERT_TRUE(v6Address.getFamily() == AF_INET6);\n  server->setOriginalPeerAddress(v6Address);\n  EXPECT_EQ(kDefaultV6UDPSendPacketLen, server->getConn().udpSendPacketLen);\n\n  server->closeNow(folly::none);\n}\n\nTEST_F(\n    QuicServerTransportTest,\n    ReceiveDataFromChangedPeerAddressWhileMigrationIsDisabled) {\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  StreamId streamId = 2;\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  try {\n    deliverData(std::move(packetData), true, &newPeer);\n    FAIL();\n  } catch (const std::runtime_error& ex) {\n    EXPECT_EQ(std::string(ex.what()), \"Invalid migration\");\n  }\n  EXPECT_TRUE(server->getConn().localConnectionError);\n  EXPECT_EQ(\n      server->getConn().localConnectionError->second, \"Migration disabled\");\n  EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n}\n\nTEST_F(QuicServerTransportTest, SwitchServerCidsNoOtherIds) {\n  auto& conn = server->getNonConstConn();\n\n  EXPECT_EQ(conn.retireAndSwitchPeerConnectionIds(), false);\n  EXPECT_EQ(conn.pendingEvents.frames.size(), 0);\n  EXPECT_EQ(conn.peerConnectionIds.size(), 1);\n}\n\nTEST_F(QuicServerTransportTest, SwitchServerCidsOneOtherCid) {\n  auto& conn = server->getNonConstConn();\n  auto originalCid = conn.clientConnectionId;\n  auto secondCid =\n      ConnectionIdData(ConnectionId(std::vector<uint8_t>{5, 6, 7, 8}), 2);\n  conn.peerConnectionIds.push_back(secondCid);\n\n  EXPECT_EQ(conn.retireAndSwitchPeerConnectionIds(), true);\n  EXPECT_EQ(conn.peerConnectionIds.size(), 1);\n\n  EXPECT_EQ(conn.pendingEvents.frames.size(), 1);\n  auto retireFrame = conn.pendingEvents.frames[0].asRetireConnectionIdFrame();\n  EXPECT_EQ(retireFrame->sequenceNumber, 0);\n\n  auto replacedCid = conn.clientConnectionId;\n  EXPECT_NE(originalCid, *replacedCid);\n  EXPECT_EQ(secondCid.connId, *replacedCid);\n}\n\nTEST_F(QuicServerTransportTest, SwitchServerCidsMultipleCids) {\n  auto& conn = server->getNonConstConn();\n  auto originalCid = conn.clientConnectionId;\n  auto secondCid =\n      ConnectionIdData(ConnectionId(std::vector<uint8_t>{5, 6, 7, 8}), 2);\n  auto thirdCid =\n      ConnectionIdData(ConnectionId(std::vector<uint8_t>{3, 3, 3, 3}), 3);\n\n  conn.peerConnectionIds.push_back(secondCid);\n  conn.peerConnectionIds.push_back(thirdCid);\n\n  EXPECT_EQ(conn.retireAndSwitchPeerConnectionIds(), true);\n  EXPECT_EQ(conn.peerConnectionIds.size(), 2);\n\n  EXPECT_EQ(conn.pendingEvents.frames.size(), 1);\n  auto retireFrame = conn.pendingEvents.frames[0].asRetireConnectionIdFrame();\n  EXPECT_EQ(retireFrame->sequenceNumber, 0);\n\n  // Uses the first unused connection id.\n  auto replacedCid = conn.clientConnectionId;\n  EXPECT_NE(originalCid, *replacedCid);\n  EXPECT_EQ(secondCid.connId, *replacedCid);\n}\n\nclass QuicServerTransportAllowMigrationTest\n    : public QuicServerTransportTest,\n      public WithParamInterface<MigrationParam> {\n public:\n  bool getDisableMigration() override {\n    return false;\n  }\n\n  virtual void initializeServerHandshake() override {\n    fakeHandshake = new FakeServerHandshake(\n        server->getNonConstConn(),\n        FizzServerQuicHandshakeContext::Builder().build(),\n        false,\n        false,\n        GetParam().clientSentActiveConnIdTransportParam);\n  }\n};\n\nINSTANTIATE_TEST_CASE_P(\n    QuicServerTransportMigrationTests,\n    QuicServerTransportAllowMigrationTest,\n    Values(\n        MigrationParam{folly::none},\n        MigrationParam{2},\n        MigrationParam{4},\n        MigrationParam{9},\n        MigrationParam{50}));\n\nTEST_P(\n    QuicServerTransportAllowMigrationTest,\n    ReceiveProbingPacketFromChangedPeerAddress) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n  server->getNonConstConn().transportSettings.disableMigration = false;\n\n  // Add additional peer id so PathResponse completes.\n  server->getNonConstConn().peerConnectionIds.emplace_back(\n      ConnectionId({1, 2, 3, 4}), 1);\n\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n\n  writeSimpleFrame(PathChallengeFrame(123), builder);\n  auto packet = std::move(builder).buildPacket();\n  auto packetData = packetToBuf(packet);\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  try {\n    deliverData(std::move(packetData), true, &newPeer);\n    FAIL();\n  } catch (const std::runtime_error& ex) {\n    EXPECT_EQ(std::string(ex.what()), \"Invalid migration\");\n  }\n  EXPECT_TRUE(server->getConn().localConnectionError);\n  EXPECT_EQ(\n      server->getConn().localConnectionError->second,\n      \"Probing not supported yet\");\n\n  std::vector<int> indices =\n      getQLogEventIndices(QLogEventType::PacketDrop, qLogger);\n  EXPECT_EQ(indices.size(), 1);\n  auto tmp = std::move(qLogger->logs[indices[0]]);\n  auto event = dynamic_cast<QLogPacketDropEvent*>(tmp.get());\n  EXPECT_EQ(event->packetSize, 29);\n  EXPECT_EQ(\n      event->dropReason,\n      QuicTransportStatsCallback::toString(\n          PacketDropReason::PEER_ADDRESS_CHANGE));\n}\n\nTEST_P(\n    QuicServerTransportAllowMigrationTest,\n    ReceiveReorderedDataFromChangedPeerAddress) {\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto firstPacket = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n  auto secondPacket = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      6,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  // Receive second packet first\n  deliverData(std::move(secondPacket));\n\n  auto peerAddress = server->getConn().peerAddress;\n\n  // Receive first packet later from a different address\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  deliverData(std::move(firstPacket), true, &newPeer);\n\n  // No migration for reordered packet\n  EXPECT_EQ(server->getConn().peerAddress, peerAddress);\n}\n\nTEST_P(QuicServerTransportAllowMigrationTest, MigrateToUnvalidatedPeer) {\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 0);\n\n  auto peerAddress = server->getConn().peerAddress;\n  auto congestionController = server->getConn().congestionController.get();\n  auto srtt = server->getConn().lossState.srtt;\n  auto lrtt = server->getConn().lossState.lrtt;\n  auto rttvar = server->getConn().lossState.rttvar;\n  auto mrtt = server->getConn().lossState.mrtt;\n\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  deliverData(std::move(packetData), false, &newPeer);\n\n  EXPECT_TRUE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n  EXPECT_EQ(server->getConn().lossState.srtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.lrtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.rttvar, 0us);\n  EXPECT_EQ(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_NE(server->getConn().congestionController.get(), nullptr);\n  EXPECT_NE(server->getConn().congestionController.get(), congestionController);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->peerAddress,\n      clientAddr);\n  EXPECT_EQ(\n      server->getConn()\n          .migrationState.lastCongestionAndRtt->congestionController.get(),\n      congestionController);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->srtt, srtt);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->lrtt, lrtt);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar, rttvar);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->mrtt, mrtt);\n\n  loopForWrites();\n  EXPECT_FALSE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n  EXPECT_TRUE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_TRUE(server->pathValidationTimeout().isScheduled());\n\n  EXPECT_TRUE(server->getConn().pathValidationLimiter != nullptr);\n\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n\n  writeSimpleFrame(\n      PathResponseFrame(server->getConn().outstandingPathValidation->pathData),\n      builder);\n  auto packet = std::move(builder).buildPacket();\n  deliverData(packetToBuf(packet), false, &newPeer);\n  EXPECT_FALSE(server->getConn().outstandingPathValidation);\n  EXPECT_FALSE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_FALSE(server->pathValidationTimeout().isScheduled());\n}\n\nTEST_P(QuicServerTransportAllowMigrationTest, ResetPathRttPathResponse) {\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 0);\n\n  auto peerAddress = server->getConn().peerAddress;\n  auto srtt = server->getConn().lossState.srtt;\n  auto lrtt = server->getConn().lossState.lrtt;\n  auto rttvar = server->getConn().lossState.rttvar;\n\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  deliverData(std::move(packetData), false, &newPeer);\n\n  EXPECT_TRUE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n  EXPECT_EQ(server->getConn().lossState.srtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.lrtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.rttvar, 0us);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->peerAddress,\n      clientAddr);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->srtt, srtt);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->lrtt, lrtt);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar, rttvar);\n\n  loopForWrites();\n  EXPECT_FALSE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n  EXPECT_TRUE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_TRUE(server->pathValidationTimeout().isScheduled());\n\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n\n  writeSimpleFrame(\n      PathResponseFrame(server->getConn().outstandingPathValidation->pathData),\n      builder);\n  auto packet = std::move(builder).buildPacket();\n  deliverData(packetToBuf(packet), false, &newPeer);\n  EXPECT_FALSE(server->getConn().outstandingPathValidation);\n  EXPECT_FALSE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_FALSE(server->pathValidationTimeout().isScheduled());\n  EXPECT_FALSE(server->getConn().writableBytesLimit);\n\n  // After Pathresponse frame is received, srtt,lrtt = sampleRtt;\n  // sampleRtt = time from send of PathChallenge to receiving PathResponse\n  EXPECT_NE(server->getConn().lossState.srtt, 0us);\n  EXPECT_NE(server->getConn().lossState.lrtt, 0us);\n  EXPECT_NE(server->getConn().lossState.rttvar, 0us);\n\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->srtt, srtt);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->lrtt, lrtt);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar, rttvar);\n}\n\nTEST_P(QuicServerTransportAllowMigrationTest, IgnoreInvalidPathResponse) {\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 0);\n\n  auto peerAddress = server->getConn().peerAddress;\n\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n\n  deliverData(std::move(packetData), false, &newPeer);\n\n  EXPECT_TRUE(server->getConn().pendingEvents.pathChallenge);\n\n  EXPECT_TRUE(server->getConn().pathValidationLimiter != nullptr);\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n\n  loopForWrites();\n  EXPECT_FALSE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n  EXPECT_TRUE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_TRUE(server->pathValidationTimeout().isScheduled());\n\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n\n  writeSimpleFrame(\n      PathResponseFrame(\n          server->getConn().outstandingPathValidation->pathData ^ 1),\n      builder);\n  auto packet = std::move(builder).buildPacket();\n  deliverData(packetToBuf(packet), false, &newPeer);\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n  EXPECT_TRUE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_TRUE(server->pathValidationTimeout().isScheduled());\n}\n\nTEST_P(\n    QuicServerTransportAllowMigrationTest,\n    ReceivePathResponseFromDifferentPeerAddress) {\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 0);\n\n  auto peerAddress = server->getConn().peerAddress;\n\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  deliverData(std::move(packetData), false, &newPeer);\n\n  EXPECT_TRUE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n\n  loopForWrites();\n  EXPECT_FALSE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n  EXPECT_TRUE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_TRUE(server->pathValidationTimeout().isScheduled());\n\n  EXPECT_TRUE(server->getConn().pathValidationLimiter != nullptr);\n\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n  writeSimpleFrame(\n      PathResponseFrame(server->getConn().outstandingPathValidation->pathData),\n      builder);\n  auto packet = std::move(builder).buildPacket();\n  folly::SocketAddress newPeer2(\"200.101.102.103\", 23456);\n  try {\n    deliverData(packetToBuf(packet), false, &newPeer2);\n    FAIL();\n  } catch (const std::runtime_error& ex) {\n    EXPECT_EQ(std::string(ex.what()), \"Invalid migration\");\n  }\n  EXPECT_TRUE(server->isClosed());\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n  EXPECT_FALSE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_FALSE(server->pathValidationTimeout().isScheduled());\n\n  EXPECT_TRUE(server->getConn().localConnectionError);\n  EXPECT_EQ(\n      server->getConn().localConnectionError->second,\n      \"Probing not supported yet\");\n}\n\nTEST_F(QuicServerTransportTest, TooManyMigrations) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n  server->getNonConstConn().transportSettings.disableMigration = false;\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  for (size_t i = 0; i < kMaxNumMigrationsAllowed; ++i) {\n    folly::SocketAddress newPeer(\"100.101.102.103\", 23456 + i);\n    deliverData(packetData->clone(), false, &newPeer);\n  }\n\n  folly::SocketAddress newPeer(\"200.101.102.103\", 23456);\n  try {\n    deliverData(packetData->clone(), false, &newPeer);\n  } catch (const std::runtime_error& ex) {\n    EXPECT_EQ(std::string(ex.what()), \"Invalid migration\");\n  }\n  EXPECT_TRUE(server->getConn().localConnectionError);\n  EXPECT_EQ(\n      server->getConn().localConnectionError->second, \"Too many migrations\");\n  EXPECT_TRUE(server->isClosed());\n  std::vector<int> indices =\n      getQLogEventIndices(QLogEventType::PacketDrop, qLogger);\n  EXPECT_EQ(indices.size(), 1);\n  auto tmp = std::move(qLogger->logs[indices[0]]);\n  auto event = dynamic_cast<QLogPacketDropEvent*>(tmp.get());\n  EXPECT_EQ(event->packetSize, 0);\n  EXPECT_EQ(\n      event->dropReason,\n      QuicTransportStatsCallback::toString(\n          PacketDropReason::PEER_ADDRESS_CHANGE));\n}\n\nTEST_P(QuicServerTransportAllowMigrationTest, MigrateToValidatedPeer) {\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  server->getNonConstConn().migrationState.previousPeerAddresses.push_back(\n      newPeer);\n  CongestionAndRttState state;\n  state.peerAddress = newPeer;\n  state.recordTime = Clock::now();\n  state.congestionController = ccFactory_->makeCongestionController(\n      server->getNonConstConn(),\n      server->getNonConstConn().transportSettings.defaultCongestionController);\n  state.srtt = 1000us;\n  state.lrtt = 2000us;\n  state.rttvar = 3000us;\n  state.mrtt = 800us;\n  server->getNonConstConn().migrationState.lastCongestionAndRtt =\n      std::move(state);\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n\n  auto peerAddress = server->getConn().peerAddress;\n  auto lastCongestionController =\n      server->getConn()\n          .migrationState.lastCongestionAndRtt->congestionController.get();\n  auto lastSrtt = server->getConn().migrationState.lastCongestionAndRtt->srtt;\n  auto lastLrtt = server->getConn().migrationState.lastCongestionAndRtt->lrtt;\n  auto lastRttvar =\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar;\n  auto lastMrtt = server->getConn().migrationState.lastCongestionAndRtt->mrtt;\n  auto congestionController = server->getConn().congestionController.get();\n  auto srtt = server->getConn().lossState.srtt;\n  auto lrtt = server->getConn().lossState.lrtt;\n  auto rttvar = server->getConn().lossState.rttvar;\n  auto mrtt = server->getConn().lossState.mrtt;\n\n  deliverData(std::move(packetData), false, &newPeer);\n\n  EXPECT_FALSE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n  EXPECT_EQ(server->getConn().lossState.srtt, lastSrtt);\n  EXPECT_EQ(server->getConn().lossState.lrtt, lastLrtt);\n  EXPECT_EQ(server->getConn().lossState.rttvar, lastRttvar);\n  EXPECT_EQ(server->getConn().lossState.mrtt, lastMrtt);\n  EXPECT_EQ(\n      server->getConn().congestionController.get(), lastCongestionController);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->peerAddress,\n      clientAddr);\n  EXPECT_EQ(\n      server->getConn()\n          .migrationState.lastCongestionAndRtt->congestionController.get(),\n      congestionController);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->srtt, srtt);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->lrtt, lrtt);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar, rttvar);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->mrtt, mrtt);\n}\n\nTEST_P(\n    QuicServerTransportAllowMigrationTest,\n    MigrateToUnvalidatedPeerOverwritesCachedRttState) {\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  server->getNonConstConn().migrationState.previousPeerAddresses.push_back(\n      newPeer);\n  CongestionAndRttState state;\n  state.peerAddress = newPeer;\n  state.recordTime = Clock::now();\n  state.congestionController = ccFactory_->makeCongestionController(\n      server->getNonConstConn(),\n      server->getNonConstConn().transportSettings.defaultCongestionController);\n  state.srtt = 1000us;\n  state.lrtt = 2000us;\n  state.rttvar = 3000us;\n  state.mrtt = 800us;\n  server->getNonConstConn().migrationState.lastCongestionAndRtt =\n      std::move(state);\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n\n  auto peerAddress = server->getConn().peerAddress;\n  auto congestionController = server->getConn().congestionController.get();\n  auto srtt = server->getConn().lossState.srtt;\n  auto lrtt = server->getConn().lossState.lrtt;\n  auto rttvar = server->getConn().lossState.rttvar;\n  auto mrtt = server->getConn().lossState.mrtt;\n\n  folly::SocketAddress newPeer2(\"200.101.102.103\", 2345);\n  deliverData(std::move(packetData), false, &newPeer2);\n\n  EXPECT_TRUE(server->getConn().pendingEvents.pathChallenge);\n\n  EXPECT_EQ(server->getConn().peerAddress, newPeer2);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 2);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.front(), newPeer);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n  EXPECT_EQ(server->getConn().lossState.srtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.lrtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.rttvar, 0us);\n  EXPECT_EQ(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_NE(server->getConn().congestionController.get(), nullptr);\n  EXPECT_NE(server->getConn().congestionController.get(), congestionController);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->peerAddress,\n      clientAddr);\n  EXPECT_EQ(\n      server->getConn()\n          .migrationState.lastCongestionAndRtt->congestionController.get(),\n      congestionController);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->srtt, srtt);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->lrtt, lrtt);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar, rttvar);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->mrtt, mrtt);\n}\n\nTEST_P(QuicServerTransportAllowMigrationTest, MigrateToStaleValidatedPeer) {\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  server->getNonConstConn().migrationState.previousPeerAddresses.push_back(\n      newPeer);\n  CongestionAndRttState state;\n  state.peerAddress = newPeer;\n  state.recordTime = Clock::now() - 2 * kTimeToRetainLastCongestionAndRttState;\n  state.congestionController = ccFactory_->makeCongestionController(\n      server->getNonConstConn(),\n      server->getNonConstConn().transportSettings.defaultCongestionController);\n  state.srtt = 1000us;\n  state.lrtt = 2000us;\n  state.rttvar = 3000us;\n  state.srtt = 800us;\n  server->getNonConstConn().migrationState.lastCongestionAndRtt =\n      std::move(state);\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n\n  auto peerAddress = server->getConn().peerAddress;\n  auto congestionController = server->getConn().congestionController.get();\n  auto srtt = server->getConn().lossState.srtt;\n  auto lrtt = server->getConn().lossState.lrtt;\n  auto rttvar = server->getConn().lossState.rttvar;\n  auto mrtt = server->getConn().lossState.mrtt;\n\n  deliverData(std::move(packetData), false, &newPeer);\n\n  EXPECT_FALSE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n  EXPECT_EQ(server->getConn().lossState.srtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.lrtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.rttvar, 0us);\n  EXPECT_EQ(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_NE(server->getConn().congestionController.get(), nullptr);\n  EXPECT_NE(server->getConn().congestionController.get(), congestionController);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->peerAddress,\n      clientAddr);\n  EXPECT_EQ(\n      server->getConn()\n          .migrationState.lastCongestionAndRtt->congestionController.get(),\n      congestionController);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->srtt, srtt);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->lrtt, lrtt);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar, rttvar);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->mrtt, mrtt);\n}\n\nTEST_F(\n    QuicServerTransportTest,\n    MigrateToValidatePeerCancelsPendingPathChallenge) {\n  server->getNonConstConn().transportSettings.disableMigration = false;\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  auto peerAddress = server->getConn().peerAddress;\n  auto congestionController = server->getConn().congestionController.get();\n  auto srtt = server->getConn().lossState.srtt;\n  auto lrtt = server->getConn().lossState.lrtt;\n  auto rttvar = server->getConn().lossState.rttvar;\n  auto mrtt = server->getConn().lossState.mrtt;\n\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  deliverData(std::move(packetData), false, &newPeer);\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_TRUE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_FALSE(server->getConn().outstandingPathValidation);\n  EXPECT_FALSE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_FALSE(server->pathValidationTimeout().isScheduled());\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n  EXPECT_EQ(server->getConn().lossState.srtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.lrtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.rttvar, 0us);\n  EXPECT_EQ(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_NE(server->getConn().congestionController.get(), nullptr);\n  EXPECT_NE(server->getConn().congestionController.get(), congestionController);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->peerAddress,\n      clientAddr);\n  EXPECT_EQ(\n      server->getConn()\n          .migrationState.lastCongestionAndRtt->congestionController.get(),\n      congestionController);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->srtt, srtt);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->lrtt, lrtt);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar, rttvar);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->mrtt, mrtt);\n\n  auto packetData2 = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      6,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n  deliverData(std::move(packetData2), false);\n  EXPECT_FALSE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_FALSE(server->getConn().outstandingPathValidation);\n  EXPECT_FALSE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_FALSE(server->pathValidationTimeout().isScheduled());\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 0);\n  EXPECT_EQ(server->getConn().lossState.srtt, srtt);\n  EXPECT_EQ(server->getConn().lossState.lrtt, lrtt);\n  EXPECT_EQ(server->getConn().lossState.rttvar, rttvar);\n  EXPECT_EQ(server->getConn().lossState.mrtt, mrtt);\n  EXPECT_EQ(server->getConn().congestionController.get(), congestionController);\n  EXPECT_FALSE(server->getConn().migrationState.lastCongestionAndRtt);\n}\n\nTEST_F(\n    QuicServerTransportTest,\n    MigrateToUnvalidatePeerCancelsOutstandingPathChallenge) {\n  server->getNonConstConn().transportSettings.disableMigration = false;\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  auto peerAddress = server->getConn().peerAddress;\n  auto congestionController = server->getConn().congestionController.get();\n  auto srtt = server->getConn().lossState.srtt;\n  auto lrtt = server->getConn().lossState.lrtt;\n  auto rttvar = server->getConn().lossState.rttvar;\n  auto mrtt = server->getConn().lossState.mrtt;\n\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  deliverData(std::move(packetData), true, &newPeer);\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n  EXPECT_TRUE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_TRUE(server->pathValidationTimeout().isScheduled());\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n  EXPECT_EQ(server->getConn().lossState.srtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.lrtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.rttvar, 0us);\n  EXPECT_EQ(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_NE(server->getConn().congestionController.get(), nullptr);\n  EXPECT_NE(server->getConn().congestionController.get(), congestionController);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->peerAddress,\n      clientAddr);\n  EXPECT_EQ(\n      server->getConn()\n          .migrationState.lastCongestionAndRtt->congestionController.get(),\n      congestionController);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->srtt, srtt);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->lrtt, lrtt);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar, rttvar);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->mrtt, mrtt);\n\n  auto packetData2 = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      6,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n  folly::SocketAddress newPeer2(\"200.101.102.103\", 23456);\n  deliverData(std::move(packetData2), false, &newPeer2);\n  EXPECT_FALSE(server->getConn().outstandingPathValidation);\n  EXPECT_FALSE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_FALSE(server->pathValidationTimeout().isScheduled());\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n  EXPECT_EQ(server->getConn().lossState.srtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.lrtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.rttvar, 0us);\n  EXPECT_EQ(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_NE(server->getConn().congestionController.get(), nullptr);\n  EXPECT_NE(server->getConn().congestionController.get(), congestionController);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->peerAddress,\n      clientAddr);\n  EXPECT_EQ(\n      server->getConn()\n          .migrationState.lastCongestionAndRtt->congestionController.get(),\n      congestionController);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->srtt, srtt);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->lrtt, lrtt);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar, rttvar);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->mrtt, mrtt);\n}\n\nTEST_F(\n    QuicServerTransportTest,\n    MigrateToValidatePeerCancelsOutstandingPathChallenge) {\n  server->getNonConstConn().transportSettings.disableMigration = false;\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  auto peerAddress = server->getConn().peerAddress;\n  auto congestionController = server->getConn().congestionController.get();\n  auto srtt = server->getConn().lossState.srtt;\n  auto lrtt = server->getConn().lossState.lrtt;\n  auto rttvar = server->getConn().lossState.rttvar;\n  auto mrtt = server->getConn().lossState.mrtt;\n\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  deliverData(std::move(packetData), true, &newPeer);\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n  EXPECT_TRUE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_TRUE(server->pathValidationTimeout().isScheduled());\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n  EXPECT_EQ(server->getConn().lossState.srtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.lrtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.rttvar, 0us);\n  EXPECT_EQ(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_NE(server->getConn().congestionController.get(), nullptr);\n  EXPECT_NE(server->getConn().congestionController.get(), congestionController);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->peerAddress,\n      clientAddr);\n  EXPECT_EQ(\n      server->getConn()\n          .migrationState.lastCongestionAndRtt->congestionController.get(),\n      congestionController);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->srtt, srtt);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->lrtt, lrtt);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar, rttvar);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->mrtt, mrtt);\n\n  auto packetData2 = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      6,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n  deliverData(std::move(packetData2));\n  EXPECT_FALSE(server->getConn().outstandingPathValidation);\n  EXPECT_FALSE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_FALSE(server->pathValidationTimeout().isScheduled());\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 0);\n  EXPECT_EQ(server->getConn().lossState.srtt, srtt);\n  EXPECT_EQ(server->getConn().lossState.lrtt, lrtt);\n  EXPECT_EQ(server->getConn().lossState.rttvar, rttvar);\n  EXPECT_EQ(server->getConn().lossState.mrtt, mrtt);\n  EXPECT_EQ(server->getConn().congestionController.get(), congestionController);\n  EXPECT_FALSE(server->getConn().migrationState.lastCongestionAndRtt);\n}\n\nTEST_F(QuicServerTransportTest, ClientPortChangeNATRebinding) {\n  server->getNonConstConn().transportSettings.disableMigration = false;\n\n  StreamId streamId = server->createBidirectionalStream().value();\n  auto data1 = IOBuf::copyBuffer(\"Aloha\");\n  server->writeChain(streamId, data1->clone(), false);\n  loopForWrites();\n  PacketNum packetNum1 =\n      getFirstOutstandingPacket(\n          server->getNonConstConn(), PacketNumberSpace::AppData)\n          ->packet.header.getPacketSequenceNum();\n  AckBlocks acks = {{packetNum1, packetNum1}};\n  auto packet1 = createAckPacket(\n      server->getNonConstConn(),\n      ++clientNextAppDataPacketNum,\n      acks,\n      PacketNumberSpace::AppData);\n  deliverData(packetToBuf(packet1));\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  auto congestionController = server->getConn().congestionController.get();\n\n  folly::SocketAddress newPeer(clientAddr.getIPAddress(), 23456);\n  deliverData(std::move(packetData), true, &newPeer);\n\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_NE(\n      server->getConn().lossState.srtt, std::chrono::microseconds::zero());\n  EXPECT_NE(\n      server->getConn().lossState.lrtt, std::chrono::microseconds::zero());\n  EXPECT_NE(\n      server->getConn().lossState.rttvar, std::chrono::microseconds::zero());\n  EXPECT_NE(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_EQ(server->getConn().congestionController.get(), congestionController);\n  EXPECT_FALSE(server->getConn().migrationState.lastCongestionAndRtt);\n}\n\nTEST_F(QuicServerTransportTest, ClientAddressChangeNATRebinding) {\n  server->getNonConstConn().transportSettings.disableMigration = false;\n  StreamId streamId = server->createBidirectionalStream().value();\n  auto data1 = IOBuf::copyBuffer(\"Aloha\");\n  server->writeChain(streamId, data1->clone(), false);\n  loopForWrites();\n  PacketNum packetNum1 =\n      getFirstOutstandingPacket(\n          server->getNonConstConn(), PacketNumberSpace::AppData)\n          ->packet.header.getPacketSequenceNum();\n  AckBlocks acks = {{packetNum1, packetNum1}};\n  auto packet1 = createAckPacket(\n      server->getNonConstConn(),\n      ++clientNextAppDataPacketNum,\n      acks,\n      PacketNumberSpace::AppData);\n  deliverData(packetToBuf(packet1));\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  auto congestionController = server->getConn().congestionController.get();\n\n  folly::SocketAddress newPeer(\"127.0.0.100\", 23456);\n  deliverData(std::move(packetData), true, &newPeer);\n\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_NE(server->getConn().lossState.srtt, 0us);\n  EXPECT_NE(server->getConn().lossState.lrtt, 0us);\n  EXPECT_NE(server->getConn().lossState.rttvar, 0us);\n  EXPECT_NE(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_EQ(server->getConn().congestionController.get(), congestionController);\n  EXPECT_FALSE(server->getConn().migrationState.lastCongestionAndRtt);\n}\n\nTEST_F(\n    QuicServerTransportTest,\n    ClientNATRebindingWhilePathValidationOutstanding) {\n  server->getNonConstConn().transportSettings.disableMigration = false;\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  auto congestionController = server->getConn().congestionController.get();\n\n  folly::SocketAddress newPeer(\"200.0.0.100\", 23456);\n  deliverData(std::move(packetData), true, &newPeer);\n\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().lossState.srtt, std::chrono::microseconds::zero());\n  EXPECT_EQ(\n      server->getConn().lossState.lrtt, std::chrono::microseconds::zero());\n  EXPECT_EQ(\n      server->getConn().lossState.rttvar, std::chrono::microseconds::zero());\n  EXPECT_EQ(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_NE(server->getConn().congestionController.get(), nullptr);\n  EXPECT_NE(server->getConn().congestionController.get(), congestionController);\n  EXPECT_TRUE(server->getConn().migrationState.lastCongestionAndRtt);\n\n  auto newCC = server->getConn().congestionController.get();\n  folly::SocketAddress newPeer2(\"200.0.0.200\", 12345);\n  auto data2 = IOBuf::copyBuffer(\"bad data\");\n  auto packetData2 = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n  deliverData(std::move(packetData2), true, &newPeer2);\n\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n\n  EXPECT_EQ(server->getConn().peerAddress, newPeer2);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().lossState.srtt, std::chrono::microseconds::zero());\n  EXPECT_EQ(\n      server->getConn().lossState.lrtt, std::chrono::microseconds::zero());\n  EXPECT_EQ(\n      server->getConn().lossState.rttvar, std::chrono::microseconds::zero());\n  EXPECT_EQ(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_EQ(server->getConn().congestionController.get(), newCC);\n  EXPECT_TRUE(server->getConn().migrationState.lastCongestionAndRtt);\n}\n\nTEST_F(QuicServerTransportTest, PingIsTreatedAsRetransmittable) {\n  PingFrame pingFrame;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  writeFrame(pingFrame, builder);\n  auto packet = std::move(builder).buildPacket();\n  deliverData(packetToBuf(packet));\n  EXPECT_TRUE(server->getConn().pendingEvents.scheduleAckTimeout);\n}\n\nTEST_F(QuicServerTransportTest, RecvNewConnectionIdValid) {\n  auto& conn = server->getNonConstConn();\n  conn.transportSettings.selfActiveConnectionIdLimit = 2;\n\n  ShortHeader header(ProtectionType::KeyPhaseZero, *conn.clientConnectionId, 1);\n  RegularQuicPacketBuilder builder(\n      conn.udpSendPacketLen, std::move(header), 0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n  NewConnectionIdFrame newConnId(\n      1, 0, ConnectionId({2, 4, 2, 3}), StatelessResetToken{9, 8, 7, 6});\n  writeSimpleFrame(QuicSimpleFrame(newConnId), builder);\n\n  auto packet = std::move(builder).buildPacket();\n\n  EXPECT_EQ(conn.peerConnectionIds.size(), 1);\n  deliverData(packetToBuf(packet), false);\n  EXPECT_EQ(conn.peerConnectionIds.size(), 2);\n  EXPECT_EQ(conn.peerConnectionIds[1].connId, newConnId.connectionId);\n  EXPECT_EQ(conn.peerConnectionIds[1].sequenceNumber, newConnId.sequenceNumber);\n  EXPECT_EQ(conn.peerConnectionIds[1].token, newConnId.token);\n}\n\nTEST_F(QuicServerTransportTest, RecvNewConnectionIdTooManyReceivedIds) {\n  auto& conn = server->getNonConstConn();\n  conn.transportSettings.selfActiveConnectionIdLimit = 0;\n\n  ShortHeader header(ProtectionType::KeyPhaseZero, *conn.clientConnectionId, 1);\n  RegularQuicPacketBuilder builder(\n      conn.udpSendPacketLen, std::move(header), 0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n  NewConnectionIdFrame newConnId(\n      1, 0, ConnectionId({2, 4, 2, 3}), StatelessResetToken());\n  writeSimpleFrame(QuicSimpleFrame(newConnId), builder);\n\n  auto packet = std::move(builder).buildPacket();\n\n  EXPECT_EQ(conn.peerConnectionIds.size(), 1);\n  deliverData(packetToBuf(packet), false);\n  EXPECT_EQ(conn.peerConnectionIds.size(), 1);\n}\n\nTEST_F(QuicServerTransportTest, RecvNewConnectionIdInvalidRetire) {\n  auto& conn = server->getNonConstConn();\n  conn.transportSettings.selfActiveConnectionIdLimit = 1;\n\n  ShortHeader header(ProtectionType::KeyPhaseZero, *conn.clientConnectionId, 1);\n  RegularQuicPacketBuilder builder(\n      conn.udpSendPacketLen, std::move(header), 0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n  NewConnectionIdFrame newConnId(\n      1, 3, ConnectionId({2, 4, 2, 3}), StatelessResetToken());\n  writeSimpleFrame(QuicSimpleFrame(newConnId), builder);\n\n  auto packet = std::move(builder).buildPacket();\n\n  EXPECT_EQ(conn.peerConnectionIds.size(), 1);\n  EXPECT_THROW(deliverData(packetToBuf(packet), false), std::runtime_error);\n}\n\nTEST_F(QuicServerTransportTest, RecvNewConnectionIdNoopValidDuplicate) {\n  auto& conn = server->getNonConstConn();\n  conn.transportSettings.selfActiveConnectionIdLimit = 1;\n\n  ConnectionId connId2({5, 5, 5, 5});\n  conn.peerConnectionIds.emplace_back(connId2, 1);\n\n  ShortHeader header(ProtectionType::KeyPhaseZero, *conn.clientConnectionId, 1);\n  RegularQuicPacketBuilder builder(\n      conn.udpSendPacketLen, std::move(header), 0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n  NewConnectionIdFrame newConnId(1, 0, connId2, StatelessResetToken());\n  writeSimpleFrame(QuicSimpleFrame(newConnId), builder);\n\n  auto packet = std::move(builder).buildPacket();\n\n  EXPECT_EQ(conn.peerConnectionIds.size(), 2);\n  deliverData(packetToBuf(packet), false);\n  EXPECT_EQ(conn.peerConnectionIds.size(), 2);\n}\n\nTEST_F(QuicServerTransportTest, RecvNewConnectionIdExceptionInvalidDuplicate) {\n  auto& conn = server->getNonConstConn();\n\n  ConnectionId connId2({5, 5, 5, 5});\n  conn.peerConnectionIds.emplace_back(connId2, 1);\n\n  ShortHeader header(ProtectionType::KeyPhaseZero, *conn.clientConnectionId, 1);\n  RegularQuicPacketBuilder builder(\n      conn.udpSendPacketLen, std::move(header), 0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n  NewConnectionIdFrame newConnId(2, 0, connId2, StatelessResetToken());\n  writeSimpleFrame(QuicSimpleFrame(newConnId), builder);\n\n  auto packet = std::move(builder).buildPacket();\n\n  EXPECT_EQ(conn.peerConnectionIds.size(), 2);\n  EXPECT_THROW(deliverData(packetToBuf(packet)), std::runtime_error);\n}\n\nclass QuicUnencryptedServerTransportTest : public QuicServerTransportTest {\n public:\n  void setupConnection() override {}\n};\n\nTEST_F(QuicUnencryptedServerTransportTest, FirstPacketProcessedCallback) {\n  getFakeHandshakeLayer()->allowZeroRttKeys();\n  EXPECT_CALL(connCallback, onFirstPeerPacketProcessed()).Times(1);\n  recvClientHello();\n  loopForWrites();\n  AckBlocks acks;\n  acks.insert(0);\n  auto aead = getInitialCipher();\n  auto headerCipher = getInitialHeaderCipher();\n  EXPECT_CALL(connCallback, onFirstPeerPacketProcessed()).Times(0);\n  deliverData(packetToBufCleartext(\n      createAckPacket(\n          server->getNonConstConn(),\n          clientNextInitialPacketNum,\n          acks,\n          PacketNumberSpace::Initial,\n          aead.get()),\n      *aead,\n      *headerCipher,\n      clientNextInitialPacketNum));\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestUnencryptedStream) {\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  PacketNum nextPacket = clientNextInitialPacketNum++;\n  StreamId streamId = 3;\n  auto initialCipher = getInitialCipher();\n  auto headerCipher = getInitialHeaderCipher();\n  auto packetData = packetToBufCleartext(\n      createStreamPacket(\n          *clientConnectionId,\n          *initialDestinationConnectionId,\n          nextPacket,\n          streamId,\n          *data,\n          initialCipher->getCipherOverhead(),\n          0 /* largestAcked */,\n          std::make_pair(LongHeader::Types::Initial, QuicVersion::MVFST)),\n      *initialCipher,\n      *headerCipher,\n      nextPacket);\n  EXPECT_THROW(deliverData(std::move(packetData)), std::runtime_error);\n  EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestUnencryptedAck) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n  AckBlocks acks = {{1, 2}};\n  auto expected = IOBuf::copyBuffer(\"hello\");\n  PacketNum nextPacketNum = clientNextInitialPacketNum++;\n  LongHeader header(\n      LongHeader::Types::Initial,\n      *clientConnectionId,\n      server->getConn().serverConnectionId.value_or(getTestConnectionId(1)),\n      nextPacketNum,\n      QuicVersion::MVFST);\n  RegularQuicPacketBuilder builder(\n      kDefaultUDPSendPacketLen, std::move(header), 0 /* largestAcked */);\n  builder.encodePacketHeader();\n  DCHECK(builder.canBuildPacket());\n  AckFrameMetaData ackData(acks, 0us, 0);\n  writeAckFrame(ackData, builder);\n  auto packet = packetToBufCleartext(\n      std::move(builder).buildPacket(),\n      *getInitialCipher(),\n      *getInitialHeaderCipher(),\n      nextPacketNum);\n  EXPECT_NO_THROW(deliverData(std::move(packet)));\n  std::vector<int> indices =\n      getQLogEventIndices(QLogEventType::PacketDrop, qLogger);\n  EXPECT_EQ(indices.size(), 1);\n\n  auto tmp = std::move(qLogger->logs[indices[0]]);\n  auto event = dynamic_cast<QLogPacketDropEvent*>(tmp.get());\n  EXPECT_EQ(event->packetSize, 45);\n  EXPECT_EQ(event->dropReason, kCipherUnavailable);\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestBadPacketProtectionLevel) {\n  // Version negotiation has no protection level.\n  auto packet = VersionNegotiationPacketBuilder(\n                    *clientConnectionId /* src */,\n                    getTestConnectionId(1) /* dest */,\n                    {QuicVersion::MVFST})\n                    .buildPacket();\n  EXPECT_CALL(*transportInfoCb_, onPacketDropped(_));\n  deliverData(packet.second->clone());\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestBadCleartextEncryption) {\n  FizzCryptoFactory cryptoFactory;\n  PacketNum nextPacket = clientNextInitialPacketNum++;\n  auto aead = cryptoFactory.getServerInitialCipher(\n      *clientConnectionId, QuicVersion::MVFST);\n  auto packetData = packetToBufCleartext(\n      createInitialCryptoPacket(\n          *clientConnectionId,\n          *initialDestinationConnectionId,\n          nextPacket,\n          QuicVersion::MVFST,\n          *IOBuf::copyBuffer(\"CHLO\"),\n          *aead,\n          0 /* largestAcked */),\n      *aead,\n      *getInitialHeaderCipher(),\n      nextPacket);\n  EXPECT_CALL(*transportInfoCb_, onPacketDropped(_));\n  deliverData(std::move(packetData));\n  // If crypto data was processed, we would have generated some writes.\n  EXPECT_NE(server->getConn().readCodec, nullptr);\n  EXPECT_TRUE(server->getConn().cryptoState->initialStream.writeBuffer.empty());\n  EXPECT_TRUE(server->getConn()\n                  .cryptoState->initialStream.retransmissionBuffer.empty());\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestPendingZeroRttData) {\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  size_t expectedPendingLen =\n      server->getConn().transportSettings.maxPacketsToBuffer;\n  for (size_t i = 0; i < expectedPendingLen + 10; ++i) {\n    StreamId streamId = static_cast<StreamId>(i);\n    auto packetData = packetToBuf(createStreamPacket(\n        *clientConnectionId,\n        server->getConn().serverConnectionId.value_or(getTestConnectionId(1)),\n        clientNextAppDataPacketNum++,\n        streamId,\n        *data,\n        0 /* cipherOverhead */,\n        0 /* largestAcked */,\n        std::make_pair(LongHeader::Types::ZeroRtt, QuicVersion::MVFST)));\n    EXPECT_CALL(*transportInfoCb_, onPacketDropped(_));\n    deliverData(std::move(packetData));\n  }\n  EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n  EXPECT_EQ(server->getConn().pendingZeroRttData->size(), expectedPendingLen);\n\n  server->getNonConstConn().pendingZeroRttData->clear();\n  deliverData(IOBuf::create(0));\n  EXPECT_TRUE(server->getConn().pendingZeroRttData->empty());\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestPendingOneRttData) {\n  recvClientHello();\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  size_t expectedPendingLen =\n      server->getConn().transportSettings.maxPacketsToBuffer;\n  for (size_t i = 0; i < expectedPendingLen + 10; ++i) {\n    StreamId streamId = static_cast<StreamId>(i);\n    auto packetData = packetToBuf(createStreamPacket(\n        *clientConnectionId,\n        *server->getConn().serverConnectionId,\n        clientNextAppDataPacketNum++,\n        streamId,\n        *data,\n        0 /* cipherOverhead */,\n        0 /* largestAcked */));\n    EXPECT_CALL(*transportInfoCb_, onPacketDropped(_));\n    deliverData(std::move(packetData));\n  }\n  EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n  EXPECT_EQ(server->getConn().pendingOneRttData->size(), expectedPendingLen);\n\n  server->getNonConstConn().pendingOneRttData->clear();\n  deliverData(IOBuf::create(0));\n  EXPECT_TRUE(server->getConn().pendingOneRttData->empty());\n}\n\nTEST_F(\n    QuicUnencryptedServerTransportTest,\n    TestReceiveClientFinishedFromChangedPeerAddress) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n  recvClientHello();\n\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n\n  try {\n    recvClientFinished(true, &newPeer);\n  } catch (const std::runtime_error& ex) {\n    EXPECT_EQ(std::string(ex.what()), \"Invalid migration\");\n  }\n  EXPECT_TRUE(server->getConn().localConnectionError);\n  EXPECT_EQ(\n      server->getConn().localConnectionError->second,\n      \"Migration not allowed during handshake\");\n  EXPECT_TRUE(server->isClosed());\n\n  std::vector<int> indices =\n      getQLogEventIndices(QLogEventType::PacketDrop, qLogger);\n  EXPECT_EQ(indices.size(), 1);\n  auto tmp = std::move(qLogger->logs[indices[0]]);\n  auto event = dynamic_cast<QLogPacketDropEvent*>(tmp.get());\n  EXPECT_EQ(event->packetSize, 44);\n  EXPECT_EQ(\n      event->dropReason,\n      QuicTransportStatsCallback::toString(\n          PacketDropReason::PEER_ADDRESS_CHANGE));\n}\n\nTEST_F(\n    QuicUnencryptedServerTransportTest,\n    ReceiveHandshakePacketFromChangedPeerAddress) {\n  server->getNonConstConn().transportSettings.disableMigration = false;\n\n  recvClientHello();\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n\n  try {\n    recvClientFinished(true, &newPeer);\n  } catch (const std::runtime_error& ex) {\n    EXPECT_EQ(std::string(ex.what()), \"Invalid migration\");\n  }\n  EXPECT_TRUE(server->getConn().localConnectionError);\n  EXPECT_EQ(\n      server->getConn().localConnectionError->second,\n      \"Migration not allowed during handshake\");\n}\n\nTEST_F(\n    QuicUnencryptedServerTransportTest,\n    ReceiveZeroRttPacketFromChangedPeerAddress) {\n  server->getNonConstConn().transportSettings.disableMigration = false;\n  fakeHandshake->allowZeroRttKeys();\n\n  recvClientHello();\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  StreamId streamId = 2;\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */,\n      std::make_pair(\n          LongHeader::Types::ZeroRtt, server->getConn().supportedVersions[0]),\n      false));\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  try {\n    deliverData(std::move(packetData), true, &newPeer);\n  } catch (const std::runtime_error& ex) {\n    EXPECT_EQ(std::string(ex.what()), \"Invalid migration\");\n  }\n  EXPECT_TRUE(server->getConn().localConnectionError);\n  EXPECT_EQ(\n      server->getConn().localConnectionError->second,\n      \"Migration not allowed during handshake\");\n}\n\nTEST_F(\n    QuicUnencryptedServerTransportTest,\n    TestNoCipherProcessPendingOneRttDataFromChangedAddress) {\n  recvClientHello();\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  StreamId streamId = 2;\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  deliverData(std::move(packetData), true, &newPeer);\n  EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n  EXPECT_EQ(server->getConn().pendingOneRttData->size(), 1);\n\n  try {\n    recvClientFinished();\n  } catch (const std::runtime_error& ex) {\n    EXPECT_EQ(std::string(ex.what()), \"Invalid migration\");\n  }\n  EXPECT_TRUE(server->getConn().localConnectionError);\n  EXPECT_EQ(\n      server->getConn().localConnectionError->second, \"Migration disabled\");\n  EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n  EXPECT_EQ(server->getConn().pendingZeroRttData, nullptr);\n  EXPECT_EQ(server->getConn().pendingOneRttData, nullptr);\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestWriteHandshakeAndZeroRtt) {\n  getFakeHandshakeLayer()->allowZeroRttKeys();\n  // This should trigger derivation of keys.\n  recvClientHello();\n\n  auto streamId = server->createBidirectionalStream().value();\n  server->writeChain(streamId, IOBuf::copyBuffer(\"hello\"), true);\n  loopForWrites();\n  auto clientCodec = makeClientEncryptedCodec(true);\n\n  size_t numCryptoFrames = 0;\n  size_t numNonCryptoFrames = 0;\n  EXPECT_GT(serverWrites.size(), 1);\n  AckStates ackStates;\n  for (auto& write : serverWrites) {\n    auto packetQueue = bufToQueue(write->clone());\n    auto result = clientCodec->parsePacket(packetQueue, ackStates);\n    auto& regularPacket = *result.regularPacket();\n    ProtectionType protectionType = regularPacket.header.getProtectionType();\n    bool handshakePacket = protectionType == ProtectionType::Initial ||\n        protectionType == ProtectionType::Handshake;\n    EXPECT_GE(regularPacket.frames.size(), 1);\n    bool hasCryptoFrame = false;\n    bool hasNonCryptoStream = false;\n    for (auto& frame : regularPacket.frames) {\n      hasCryptoFrame |= frame.asReadCryptoFrame() != nullptr;\n      hasNonCryptoStream |= frame.asReadStreamFrame() != nullptr;\n    }\n    if (hasCryptoFrame) {\n      EXPECT_TRUE(handshakePacket);\n      numCryptoFrames++;\n    }\n    if (hasNonCryptoStream) {\n      EXPECT_FALSE(handshakePacket);\n      numNonCryptoFrames++;\n    }\n  }\n  EXPECT_GE(numCryptoFrames, 1);\n  EXPECT_GE(numNonCryptoFrames, 1);\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestEncryptedDataBeforeCFIN) {\n  getFakeHandshakeLayer()->allowZeroRttKeys();\n  // This should trigger derivation of keys.\n  recvClientHello();\n\n  StreamId streamId = 4;\n  recvEncryptedStream(streamId, *IOBuf::copyBuffer(\"hello\"));\n\n  auto stream = server->getNonConstConn().streamManager->getStream(streamId);\n  ASSERT_TRUE(stream->readBuffer.empty());\n}\n\nTEST_F(\n    QuicUnencryptedServerTransportTest,\n    TestClearInFlightBytesLimitationAfterCFIN) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n  server->getNonConstConn().transportSettings.zeroRttSourceTokenMatchingPolicy =\n      ZeroRttSourceTokenMatchingPolicy::LIMIT_IF_NO_EXACT_MATCH;\n  getFakeHandshakeLayer()->allowZeroRttKeys();\n  auto originalUdpSize = server->getConn().udpSendPacketLen;\n\n  setupClientReadCodec();\n\n  recvClientHello();\n  ASSERT_TRUE(server->getNonConstConn().writableBytesLimit.has_value());\n  EXPECT_EQ(\n      *server->getNonConstConn().writableBytesLimit,\n      server->getConn().transportSettings.limitedCwndInMss * originalUdpSize);\n\n  recvClientFinished();\n  loopForWrites();\n  EXPECT_EQ(server->getConn().writableBytesLimit, folly::none);\n\n  std::vector<int> indices =\n      getQLogEventIndices(QLogEventType::TransportStateUpdate, qLogger);\n  EXPECT_EQ(indices.size(), 4);\n  std::array<::std::string, 4> updateArray = {\n      kDerivedZeroRttReadCipher,\n      kDerivedOneRttWriteCipher,\n      kTransportReady,\n      kDerivedOneRttReadCipher};\n  for (int i = 0; i < 4; ++i) {\n    auto tmp = std::move(qLogger->logs[indices[i]]);\n    auto event = dynamic_cast<QLogTransportStateUpdateEvent*>(tmp.get());\n    EXPECT_EQ(event->update, updateArray[i]);\n  }\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestSendHandshakeDone) {\n  getFakeHandshakeLayer()->allowZeroRttKeys();\n  setupClientReadCodec();\n  recvClientHello(true, QuicVersion::QUIC_DRAFT);\n  recvClientFinished(true, nullptr, QuicVersion::QUIC_DRAFT);\n  auto& packets = server->getConn().outstandings.packets;\n  ASSERT_FALSE(packets.empty());\n  int numHandshakeDone = 0;\n  for (auto& p : packets) {\n    for (auto& f : p.packet.frames) {\n      auto s = f.asQuicSimpleFrame();\n      if (s) {\n        if (s->asHandshakeDoneFrame()) {\n          numHandshakeDone++;\n        }\n      }\n    }\n  }\n  EXPECT_EQ(numHandshakeDone, 1);\n}\n\nTEST_F(\n    QuicUnencryptedServerTransportTest,\n    IncreaseLimitAfterReceivingNewPacket) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n  getFakeHandshakeLayer()->allowZeroRttKeys();\n  server->getNonConstConn().transportSettings.zeroRttSourceTokenMatchingPolicy =\n      ZeroRttSourceTokenMatchingPolicy::LIMIT_IF_NO_EXACT_MATCH;\n\n  auto originalUdpSize = server->getConn().udpSendPacketLen;\n  setupClientReadCodec();\n\n  recvClientHello();\n  EXPECT_EQ(\n      *server->getNonConstConn().writableBytesLimit,\n      server->getConn().transportSettings.limitedCwndInMss * originalUdpSize);\n\n  recvClientHello();\n\n  // in tests the udp packet length changes\n  auto expectedLen =\n      server->getConn().transportSettings.limitedCwndInMss * originalUdpSize +\n      server->getConn().transportSettings.limitedCwndInMss *\n          server->getConn().udpSendPacketLen;\n  EXPECT_NE(originalUdpSize, server->getConn().udpSendPacketLen);\n  EXPECT_EQ(*server->getNonConstConn().writableBytesLimit, expectedLen);\n  std::vector<int> indices =\n      getQLogEventIndices(QLogEventType::TransportStateUpdate, qLogger);\n  EXPECT_EQ(indices.size(), 3);\n  std::array<::std::string, 3> updateArray = {\n      kDerivedZeroRttReadCipher, kDerivedOneRttWriteCipher, kTransportReady};\n  for (int i = 0; i < 3; ++i) {\n    auto tmp = std::move(qLogger->logs[indices[i]]);\n    auto event = dynamic_cast<QLogTransportStateUpdateEvent*>(tmp.get());\n    EXPECT_EQ(event->update, updateArray[i]);\n  }\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, MaxReceivePacketSizeTooLarge) {\n  getFakeHandshakeLayer()->allowZeroRttKeys();\n  auto originalUdpSize = server->getConn().udpSendPacketLen;\n  fakeHandshake->maxRecvPacketSize = 4096;\n  setupClientReadCodec();\n  recvClientHello();\n  EXPECT_NE(originalUdpSize, server->getConn().udpSendPacketLen);\n  EXPECT_EQ(server->getConn().udpSendPacketLen, kDefaultUDPSendPacketLen);\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestGarbageData) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  PacketNum nextPacket = clientNextInitialPacketNum++;\n  auto aead = getInitialCipher();\n  auto headerCipher = getInitialHeaderCipher();\n  auto packet = createCryptoPacket(\n      *clientConnectionId,\n      *clientConnectionId,\n      nextPacket,\n      QuicVersion::QUIC_DRAFT,\n      ProtectionType::Initial,\n      *IOBuf::copyBuffer(\"CHLO\"),\n      *aead,\n      0 /* largestAcked */);\n  auto packetData =\n      packetToBufCleartext(packet, *aead, *headerCipher, nextPacket);\n  packetData->prependChain(IOBuf::copyBuffer(\"garbage in\"));\n  deliverData(std::move(packetData));\n  EXPECT_NE(server->getConn().readCodec, nullptr);\n  EXPECT_NE(server->getConn().initialWriteCipher, nullptr);\n\n  std::vector<int> indices =\n      getQLogEventIndices(QLogEventType::PacketBuffered, qLogger);\n  EXPECT_EQ(indices.size(), 1);\n  auto tmp = std::move(qLogger->logs[indices[0]]);\n  auto event = dynamic_cast<QLogPacketBufferedEvent*>(tmp.get());\n  EXPECT_EQ(event->packetNum, nextPacket);\n  EXPECT_EQ(event->protectionType, ProtectionType::KeyPhaseZero);\n  EXPECT_EQ(event->packetSize, 10);\n}\n\nBuf getHandshakePacketWithFrame(\n    QuicWriteFrame frame,\n    ConnectionId connId,\n    Aead& clientWriteCipher,\n    PacketNumberCipher& headerCipher) {\n  PacketNum clientPacketNum = folly::Random::rand32();\n  LongHeader header(\n      LongHeader::Types::Handshake,\n      connId,\n      connId,\n      clientPacketNum,\n      QuicVersion::MVFST);\n  RegularQuicPacketBuilder builder(\n      kDefaultUDPSendPacketLen,\n      std::move(header),\n      clientPacketNum / 2 /* largestAcked */);\n  builder.encodePacketHeader();\n  builder.accountForCipherOverhead(clientWriteCipher.getCipherOverhead());\n  writeFrame(std::move(frame), builder);\n  return packetToBufCleartext(\n      std::move(builder).buildPacket(),\n      clientWriteCipher,\n      headerCipher,\n      clientPacketNum);\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestNotAllowedInUnencryptedPacket) {\n  // This should trigger derivation of keys.\n  recvClientHello();\n\n  StreamId streamId = 4;\n  auto data = IOBuf::copyBuffer(\"data\");\n\n  EXPECT_THROW(\n      deliverData(getHandshakePacketWithFrame(\n          MaxStreamDataFrame(streamId, 100),\n          *clientConnectionId,\n          *getInitialCipher(),\n          *getInitialHeaderCipher())),\n      std::runtime_error);\n  EXPECT_TRUE(server->error());\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestCloseWhileAsyncPending) {\n  folly::EventBase testLooper;\n  setupClientReadCodec();\n  getFakeHandshakeLayer()->initialize(&testLooper, server.get());\n\n  recvClientHello();\n  testLooper.loop();\n\n  // Make sure the test looper worked.\n  IOBufEqualTo eq;\n  EXPECT_TRUE(eq(getCryptoStreamData(), IOBuf::copyBuffer(\"SHLO\")));\n\n  recvClientFinished();\n\n  server->close(std::make_pair(\n      QuicErrorCode(GenericApplicationErrorCode::UNKNOWN),\n      std::string(\"hello\")));\n  EXPECT_TRUE(server->isClosed());\n  testLooper.loop();\n\n  EXPECT_EQ(server->getConn().oneRttWriteCipher, nullptr);\n\n  StreamId streamId = 4;\n  auto data = IOBuf::copyBuffer(\"data\");\n\n  EXPECT_THROW(\n      deliverData(getHandshakePacketWithFrame(\n          MaxStreamDataFrame(streamId, 100),\n          *clientConnectionId,\n          *getInitialCipher(),\n          *getInitialHeaderCipher())),\n      std::runtime_error);\n}\n\nstruct FizzHandshakeParam {\n  FizzHandshakeParam(bool argCHLOSync, bool argCFINSync, bool argAcceptZeroRtt)\n      : chloSync(argCHLOSync),\n        cfinSync(argCFINSync),\n        acceptZeroRtt(argAcceptZeroRtt) {}\n  bool chloSync;\n  bool cfinSync;\n  bool acceptZeroRtt;\n};\n\nclass QuicServerTransportPendingDataTest\n    : public QuicUnencryptedServerTransportTest,\n      public WithParamInterface<FizzHandshakeParam> {\n public:\n  ~QuicServerTransportPendingDataTest() override {\n    loopForWrites();\n  }\n\n  void initializeServerHandshake() override {\n    fakeHandshake = new FakeServerHandshake(\n        server->getNonConstConn(),\n        FizzServerQuicHandshakeContext::Builder().build(),\n        GetParam().chloSync,\n        GetParam().cfinSync);\n    if (GetParam().acceptZeroRtt) {\n      fakeHandshake->allowZeroRttKeys();\n    }\n  }\n};\n\nINSTANTIATE_TEST_CASE_P(\n    QuicServerTransportPendingDataTests,\n    QuicServerTransportPendingDataTest,\n    Values(\n        FizzHandshakeParam(false, false, false),\n        FizzHandshakeParam(false, false, true),\n        FizzHandshakeParam(false, true, false),\n        FizzHandshakeParam(false, true, true),\n        FizzHandshakeParam(true, false, false),\n        FizzHandshakeParam(true, false, true),\n        FizzHandshakeParam(true, true, false),\n        FizzHandshakeParam(true, true, true)));\n\nTEST_P(\n    QuicServerTransportPendingDataTest,\n    TestNoCipherProcessPendingZeroRttData) {\n  server->getNonConstConn().qLogger =\n      std::make_shared<quic::FileQLogger>(VantagePoint::Server);\n  recvClientHello(false);\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  StreamId streamId = 2;\n  // Write packet with zero rtt keys\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */,\n      std::make_pair(\n          LongHeader::Types::ZeroRtt, server->getConn().supportedVersions[0]),\n      false));\n  deliverData(std::move(packetData), false);\n  if (GetParam().acceptZeroRtt) {\n    if (!GetParam().chloSync) {\n      EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n      EXPECT_EQ(server->getConn().pendingZeroRttData->size(), 1);\n      loopForWrites();\n    }\n    EXPECT_EQ(server->getConn().streamManager->streamCount(), 1);\n    EXPECT_EQ(server->getConn().pendingZeroRttData, nullptr);\n  } else {\n    EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n    EXPECT_EQ(server->getConn().pendingZeroRttData->size(), 1);\n  }\n  EXPECT_EQ(\n      server->getConn().qLogger->scid, server->getConn().serverConnectionId);\n}\n\nTEST_P(\n    QuicServerTransportPendingDataTest,\n    TestNoCipherProcessPendingOneRttData) {\n  server->getNonConstConn().qLogger =\n      std::make_shared<quic::FileQLogger>(VantagePoint::Server);\n  recvClientHello();\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  StreamId streamId = 2;\n  // Write packet with zero rtt keys\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */,\n      folly::none,\n      false));\n  deliverData(std::move(packetData));\n  EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n  EXPECT_EQ(server->getConn().pendingOneRttData->size(), 1);\n\n  recvClientFinished();\n  EXPECT_EQ(server->getConn().streamManager->streamCount(), 1);\n  EXPECT_EQ(server->getConn().pendingZeroRttData, nullptr);\n  EXPECT_EQ(server->getConn().pendingOneRttData, nullptr);\n  EXPECT_EQ(\n      server->getConn().qLogger->scid, server->getConn().serverConnectionId);\n}\n\nTEST_P(\n    QuicServerTransportPendingDataTest,\n    TestNoCipherProcessingZeroAndOneRttData) {\n  server->getNonConstConn().qLogger =\n      std::make_shared<quic::FileQLogger>(VantagePoint::Server);\n  recvClientHello(false);\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  StreamId streamId = 2;\n  // Write packet with zero rtt keys\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */,\n      std::make_pair(\n          LongHeader::Types::ZeroRtt, server->getConn().supportedVersions[0]),\n      false));\n  deliverData(std::move(packetData), false);\n  if (GetParam().acceptZeroRtt) {\n    if (!GetParam().chloSync) {\n      EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n      EXPECT_EQ(server->getConn().pendingZeroRttData->size(), 1);\n      loopForWrites();\n    }\n    EXPECT_EQ(server->getConn().streamManager->streamCount(), 1);\n    EXPECT_EQ(server->getConn().pendingZeroRttData, nullptr);\n  } else {\n    EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n    EXPECT_EQ(server->getConn().pendingZeroRttData->size(), 1);\n  }\n  loopForWrites();\n\n  StreamId streamId2 = 4;\n  // Write packet with zero rtt keys\n  auto packetData2 = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n  deliverData(std::move(packetData2));\n  EXPECT_EQ(\n      server->getConn().streamManager->streamCount(),\n      GetParam().acceptZeroRtt ? 1 : 0);\n  EXPECT_EQ(server->getConn().pendingOneRttData->size(), 1);\n\n  recvClientFinished();\n  EXPECT_EQ(\n      server->getConn().streamManager->streamCount(),\n      GetParam().acceptZeroRtt ? 2 : 1);\n  EXPECT_EQ(server->getConn().pendingZeroRttData, nullptr);\n  EXPECT_EQ(server->getConn().pendingOneRttData, nullptr);\n  EXPECT_EQ(\n      server->getConn().qLogger->scid, server->getConn().serverConnectionId);\n}\n\n/**\n * Test handshake process with different parameters:\n * sync CHLO processing, sync CFIN processing, accept 0-rtt\n */\nclass QuicServerTransportHandshakeTest\n    : public QuicUnencryptedServerTransportTest,\n      public WithParamInterface<FizzHandshakeParam> {\n public:\n  ~QuicServerTransportHandshakeTest() override {\n    // We need an extra pump here for some reason.\n    loopForWrites();\n  }\n\n  void initializeServerHandshake() override {\n    fakeHandshake = new FakeServerHandshake(\n        server->getNonConstConn(),\n        FizzServerQuicHandshakeContext::Builder().build(),\n        GetParam().chloSync,\n        GetParam().cfinSync);\n    if (GetParam().acceptZeroRtt) {\n      fakeHandshake->allowZeroRttKeys();\n    }\n  }\n\n  void expectWriteNewSessionTicket() override {\n    std::string appParams(\"APP params\");\n    server->setEarlyDataAppParamsFunctions(\n        [](const folly::Optional<std::string>&, const Buf&) { return false; },\n        [=]() -> Buf { return folly::IOBuf::copyBuffer(appParams); });\n    EXPECT_CALL(*getFakeHandshakeLayer(), writeNewSessionTicket(_))\n        .WillOnce(Invoke([=](const AppToken& appToken) {\n          auto& params = appToken.transportParams.parameters;\n\n          auto initialMaxData = *getIntegerParameter(\n              TransportParameterId::initial_max_data, params);\n          EXPECT_EQ(\n              initialMaxData,\n              server->getConn()\n                  .transportSettings.advertisedInitialConnectionWindowSize);\n\n          auto initialMaxStreamDataBidiLocal = *getIntegerParameter(\n              TransportParameterId::initial_max_stream_data_bidi_local, params);\n          auto initialMaxStreamDataBidiRemote = *getIntegerParameter(\n              TransportParameterId::initial_max_stream_data_bidi_remote,\n              params);\n          auto initialMaxStreamDataUni = *getIntegerParameter(\n              TransportParameterId::initial_max_stream_data_bidi_remote,\n              params);\n          EXPECT_EQ(\n              initialMaxStreamDataBidiLocal,\n              server->getConn()\n                  .transportSettings\n                  .advertisedInitialBidiLocalStreamWindowSize);\n          EXPECT_EQ(\n              initialMaxStreamDataBidiRemote,\n              server->getConn()\n                  .transportSettings\n                  .advertisedInitialBidiRemoteStreamWindowSize);\n          EXPECT_EQ(\n              initialMaxStreamDataUni,\n              server->getConn()\n                  .transportSettings.advertisedInitialUniStreamWindowSize);\n\n          auto initialMaxStreamsBidi = *getIntegerParameter(\n              TransportParameterId::initial_max_streams_bidi, params);\n          auto initialMaxStreamsUni = *getIntegerParameter(\n              TransportParameterId::initial_max_streams_uni, params);\n          EXPECT_EQ(\n              initialMaxStreamsBidi,\n              server->getConn()\n                  .transportSettings.advertisedInitialMaxStreamsBidi);\n          EXPECT_EQ(\n              initialMaxStreamsUni,\n              server->getConn()\n                  .transportSettings.advertisedInitialMaxStreamsUni);\n\n          auto maxRecvPacketSize = *getIntegerParameter(\n              TransportParameterId::max_packet_size, params);\n          EXPECT_EQ(\n              maxRecvPacketSize,\n              server->getConn().transportSettings.maxRecvPacketSize);\n\n          EXPECT_THAT(\n              appToken.sourceAddresses, ContainerEq(expectedSourceToken_));\n\n          EXPECT_TRUE(folly::IOBufEqualTo()(\n              appToken.appParams, folly::IOBuf::copyBuffer(appParams)));\n        }));\n  }\n\n  void testSetupConnection() {\n    // If 0-rtt is accepted, one rtt write cipher will be available after CHLO\n    // is processed\n    if (GetParam().acceptZeroRtt) {\n      EXPECT_CALL(connCallback, onTransportReady());\n    }\n    recvClientHello();\n\n    // If 0-rtt is disabled, one rtt write cipher will be available after CFIN\n    // is processed\n    if (!GetParam().acceptZeroRtt) {\n      EXPECT_CALL(connCallback, onTransportReady());\n    }\n    // onConnectionIdBound is always invoked after CFIN is processed\n    EXPECT_CALL(routingCallback, onConnectionIdBound(_));\n    // NST is always written after CFIN is processed\n    expectWriteNewSessionTicket();\n    recvClientFinished();\n  }\n\n protected:\n  std::vector<folly::IPAddress> expectedSourceToken_;\n};\n\nINSTANTIATE_TEST_CASE_P(\n    QuicServerTransportHandshakeTests,\n    QuicServerTransportHandshakeTest,\n    Values(\n        FizzHandshakeParam(false, false, false),\n        FizzHandshakeParam(false, false, true),\n        FizzHandshakeParam(false, true, false),\n        FizzHandshakeParam(false, true, true),\n        FizzHandshakeParam(true, false, false),\n        FizzHandshakeParam(true, false, true),\n        FizzHandshakeParam(true, true, false),\n        FizzHandshakeParam(true, true, true)));\n\nTEST_P(\n    QuicServerTransportHandshakeTest,\n    TestConnectionSetupWithoutSourceTokenInPsk) {\n  serverCtx->setSendNewSessionTicket(false);\n  expectedSourceToken_ = {clientAddr.getIPAddress()};\n  testSetupConnection();\n}\n\nTEST_P(\n    QuicServerTransportHandshakeTest,\n    TestConnectionSetupWithSourceTokenInPsk) {\n  serverCtx->setSendNewSessionTicket(false);\n  auto ipAddr = folly::IPAddress(\"1.2.3.4\");\n  getFakeHandshakeLayer()->setSourceTokens({ipAddr});\n  if (GetParam().acceptZeroRtt) {\n    expectedSourceToken_ = {ipAddr, clientAddr.getIPAddress()};\n  } else {\n    expectedSourceToken_ = {clientAddr.getIPAddress()};\n  }\n  testSetupConnection();\n}\n\nTEST_P(QuicServerTransportHandshakeTest, TestD6DStartCallback) {\n  Observer::Config config = {};\n  config.pmtuEvents = true;\n  auto mockObserver = std::make_unique<MockObserver>(config);\n  server->addObserver(mockObserver.get());\n  // Set oneRttReader so that maybeStartD6DPriobing passes its check\n  auto codec = std::make_unique<QuicReadCodec>(QuicNodeType::Server);\n  codec->setOneRttReadCipher(createNoOpAead());\n  server->getNonConstConn().readCodec = std::move(codec);\n  // And the state too\n  server->getNonConstConn().d6d.state = D6DMachineState::BASE;\n  EXPECT_CALL(*mockObserver, pmtuProbingStarted(_)).Times(1);\n  // CHLO should be enough to trigger probing\n  recvClientHello();\n  server->removeObserver(mockObserver.get());\n}\n\nTEST_F(QuicServerTransportTest, TestRegisterAndHandleTransportKnobParams) {\n  int flag = 0;\n  server->registerKnobParamHandler(\n      199, [&](QuicServerConnectionState* /* server_conn */, uint64_t val) {\n        EXPECT_EQ(val, 10);\n        flag = 1;\n      });\n  server->registerKnobParamHandler(\n      200,\n      [&](QuicServerConnectionState* /* server_conn */, uint64_t /* val */) {\n        flag = 2;\n      });\n  server->handleKnobParams({\n      {199, 10},\n      {201, 20},\n  });\n\n  EXPECT_EQ(flag, 1);\n\n  // ovewrite will fail, the new handler won't be called\n  server->registerKnobParamHandler(\n      199, [&](QuicServerConnectionState* /* server_conn */, uint64_t val) {\n        EXPECT_EQ(val, 30);\n        flag = 3;\n      });\n\n  server->handleKnobParams({\n      {199, 10},\n      {201, 20},\n  });\n  EXPECT_EQ(flag, 1);\n}\n\nTEST_F(QuicServerTransportTest, TestRegisterPMTUZeroBlackholeDetection) {\n  server->handleKnobParams(\n      {{static_cast<uint64_t>(\n            TransportKnobParamId::ZERO_PMTU_BLACKHOLE_DETECTION),\n        1}});\n  EXPECT_TRUE(server->getConn().d6d.noBlackholeDetection);\n}\n\nclass QuicServerTransportForciblySetUDUPayloadSizeTest\n    : public QuicServerTransportTest {\n public:\n  bool getCanIgnorePathMTU() override {\n    return false;\n  }\n};\n\nTEST_F(\n    QuicServerTransportForciblySetUDUPayloadSizeTest,\n    TestHandleTransportKnobParamForciblySetUDPPayloadSize) {\n  EXPECT_LT(server->getConn().udpSendPacketLen, 1452);\n  server->handleKnobParams(\n      {{static_cast<uint64_t>(\n            TransportKnobParamId::FORCIBLY_SET_UDP_PAYLOAD_SIZE),\n        1}});\n  EXPECT_EQ(server->getConn().udpSendPacketLen, 1452);\n}\n\n} // namespace test\n} // namespace quic\n"], "fixing_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n#include <quic/server/state/ServerStateMachine.h>\n\n#include <quic/api/QuicTransportFunctions.h>\n#include <quic/common/BufUtil.h>\n#include <quic/congestion_control/CongestionControllerFactory.h>\n#include <quic/congestion_control/TokenlessPacer.h>\n#include <quic/fizz/handshake/FizzCryptoFactory.h>\n#include <quic/flowcontrol/QuicFlowController.h>\n#include <quic/handshake/TransportParameters.h>\n#include <quic/logging/QLoggerConstants.h>\n#include <quic/state/QuicPacingFunctions.h>\n#include <quic/state/QuicStreamFunctions.h>\n#include <quic/state/QuicTransportStatsCallback.h>\n#include <quic/state/SimpleFrameFunctions.h>\n#include <quic/state/stream/StreamReceiveHandlers.h>\n#include <quic/state/stream/StreamSendHandlers.h>\n\nnamespace quic {\nusing namespace std::chrono_literals;\n\nnamespace {\nusing PacketDropReason = QuicTransportStatsCallback::PacketDropReason;\nconstexpr size_t kConnIdEncodingRetryLimit = 16;\n\nbool maybeNATRebinding(\n    const folly::SocketAddress& newPeerAddress,\n    const folly::SocketAddress& oldPeerAddress) {\n  auto& newIPAddr = newPeerAddress.getIPAddress();\n  auto& oldIPAddr = oldPeerAddress.getIPAddress();\n\n  // Port changed\n  if (newIPAddr == oldIPAddr) {\n    return true;\n  }\n\n  return newIPAddr.isV4() && oldIPAddr.isV4() &&\n      newIPAddr.inSubnet(oldIPAddr, 24);\n}\n\nCongestionAndRttState moveCurrentCongestionAndRttState(\n    QuicServerConnectionState& conn) {\n  CongestionAndRttState state;\n  state.peerAddress = conn.peerAddress;\n  state.recordTime = Clock::now();\n  state.congestionController = std::move(conn.congestionController);\n  state.srtt = conn.lossState.srtt;\n  state.lrtt = conn.lossState.lrtt;\n  state.rttvar = conn.lossState.rttvar;\n  state.mrtt = conn.lossState.mrtt;\n  return state;\n}\n\nvoid resetCongestionAndRttState(QuicServerConnectionState& conn) {\n  CHECK(conn.congestionControllerFactory)\n      << \"CongestionControllerFactory is not set.\";\n  conn.congestionController =\n      conn.congestionControllerFactory->makeCongestionController(\n          conn, conn.transportSettings.defaultCongestionController);\n  conn.lossState.srtt = 0us;\n  conn.lossState.lrtt = 0us;\n  conn.lossState.rttvar = 0us;\n  conn.lossState.mrtt = kDefaultMinRtt;\n}\n\nvoid recoverOrResetCongestionAndRttState(\n    QuicServerConnectionState& conn,\n    const folly::SocketAddress& peerAddress) {\n  auto& lastState = conn.migrationState.lastCongestionAndRtt;\n  if (lastState && lastState->peerAddress == peerAddress &&\n      (Clock::now() - lastState->recordTime <=\n       kTimeToRetainLastCongestionAndRttState)) {\n    // recover from matched non-stale state\n    conn.congestionController = std::move(lastState->congestionController);\n    conn.lossState.srtt = lastState->srtt;\n    conn.lossState.lrtt = lastState->lrtt;\n    conn.lossState.rttvar = lastState->rttvar;\n    conn.lossState.mrtt = lastState->mrtt;\n    conn.migrationState.lastCongestionAndRtt = folly::none;\n  } else {\n    resetCongestionAndRttState(conn);\n  }\n}\n\nvoid setExperimentalSettings(QuicServerConnectionState& conn) {\n  conn.lossState.reorderingThreshold =\n      std::numeric_limits<decltype(conn.lossState.reorderingThreshold)>::max();\n}\n} // namespace\n\nvoid processClientInitialParams(\n    QuicServerConnectionState& conn,\n    const ClientTransportParameters& clientParams) {\n  // TODO validate that we didn't receive original connection ID, stateless\n  // reset token, or preferred address.\n  auto maxData = getIntegerParameter(\n      TransportParameterId::initial_max_data, clientParams.parameters);\n  auto maxStreamDataBidiLocal = getIntegerParameter(\n      TransportParameterId::initial_max_stream_data_bidi_local,\n      clientParams.parameters);\n  auto maxStreamDataBidiRemote = getIntegerParameter(\n      TransportParameterId::initial_max_stream_data_bidi_remote,\n      clientParams.parameters);\n  auto maxStreamDataUni = getIntegerParameter(\n      TransportParameterId::initial_max_stream_data_uni,\n      clientParams.parameters);\n  auto maxStreamsBidi = getIntegerParameter(\n      TransportParameterId::initial_max_streams_bidi, clientParams.parameters);\n  auto maxStreamsUni = getIntegerParameter(\n      TransportParameterId::initial_max_streams_uni, clientParams.parameters);\n  auto idleTimeout = getIntegerParameter(\n      TransportParameterId::idle_timeout, clientParams.parameters);\n  auto ackDelayExponent = getIntegerParameter(\n      TransportParameterId::ack_delay_exponent, clientParams.parameters);\n  auto packetSize = getIntegerParameter(\n      TransportParameterId::max_packet_size, clientParams.parameters);\n  auto partialReliability = getIntegerParameter(\n      static_cast<TransportParameterId>(kPartialReliabilityParameterId),\n      clientParams.parameters);\n  auto activeConnectionIdLimit = getIntegerParameter(\n      TransportParameterId::active_connection_id_limit,\n      clientParams.parameters);\n  auto d6dBasePMTU = getIntegerParameter(\n      static_cast<TransportParameterId>(kD6DBasePMTUParameterId),\n      clientParams.parameters);\n  auto d6dRaiseTimeout = getIntegerParameter(\n      static_cast<TransportParameterId>(kD6DRaiseTimeoutParameterId),\n      clientParams.parameters);\n  auto d6dProbeTimeout = getIntegerParameter(\n      static_cast<TransportParameterId>(kD6DProbeTimeoutParameterId),\n      clientParams.parameters);\n  auto minAckDelay = getIntegerParameter(\n      TransportParameterId::min_ack_delay, clientParams.parameters);\n  if (conn.version == QuicVersion::QUIC_DRAFT) {\n    auto initialSourceConnId = getConnIdParameter(\n        TransportParameterId::initial_source_connection_id,\n        clientParams.parameters);\n    if (!initialSourceConnId ||\n        initialSourceConnId.value() !=\n            conn.readCodec->getClientConnectionId()) {\n      throw QuicTransportException(\n          \"Initial CID does not match.\",\n          TransportErrorCode::TRANSPORT_PARAMETER_ERROR);\n    }\n  }\n\n  // TODO Validate active_connection_id_limit\n  if (packetSize && *packetSize < kMinMaxUDPPayload) {\n    throw QuicTransportException(\n        folly::to<std::string>(\n            \"Max packet size too small. received max_packetSize = \",\n            *packetSize),\n        TransportErrorCode::TRANSPORT_PARAMETER_ERROR);\n  }\n\n  VLOG(10) << \"Client advertised flow control \";\n  VLOG(10) << \"conn=\" << maxData.value_or(0);\n  VLOG(10) << \" stream bidi local=\" << maxStreamDataBidiLocal.value_or(0)\n           << \" \";\n  VLOG(10) << \" stream bidi remote=\" << maxStreamDataBidiRemote.value_or(0)\n           << \" \";\n  VLOG(10) << \" stream uni=\" << maxStreamDataUni.value_or(0) << \" \";\n  VLOG(10) << conn;\n  conn.flowControlState.peerAdvertisedMaxOffset = maxData.value_or(0);\n  conn.flowControlState.peerAdvertisedInitialMaxStreamOffsetBidiLocal =\n      maxStreamDataBidiLocal.value_or(0);\n  conn.flowControlState.peerAdvertisedInitialMaxStreamOffsetBidiRemote =\n      maxStreamDataBidiRemote.value_or(0);\n  conn.flowControlState.peerAdvertisedInitialMaxStreamOffsetUni =\n      maxStreamDataUni.value_or(0);\n  conn.streamManager->setMaxLocalBidirectionalStreams(\n      maxStreamsBidi.value_or(0));\n  conn.streamManager->setMaxLocalUnidirectionalStreams(\n      maxStreamsUni.value_or(0));\n  conn.peerIdleTimeout = std::chrono::milliseconds(idleTimeout.value_or(0));\n  conn.peerIdleTimeout = timeMin(conn.peerIdleTimeout, kMaxIdleTimeout);\n  if (ackDelayExponent && *ackDelayExponent > kMaxAckDelayExponent) {\n    throw QuicTransportException(\n        \"ack_delay_exponent too large\",\n        TransportErrorCode::TRANSPORT_PARAMETER_ERROR);\n  }\n  conn.peerAckDelayExponent =\n      ackDelayExponent.value_or(kDefaultAckDelayExponent);\n  if (minAckDelay.hasValue()) {\n    conn.peerMinAckDelay = std::chrono::microseconds(minAckDelay.value());\n  }\n\n  // Default to max because we can probe PMTU now, and this will be the upper\n  // limit\n  uint64_t maxUdpPayloadSize = kDefaultMaxUDPPayload;\n  if (packetSize) {\n    maxUdpPayloadSize = std::min(*packetSize, maxUdpPayloadSize);\n    conn.peerMaxUdpPayloadSize = maxUdpPayloadSize;\n    if (conn.transportSettings.canIgnorePathMTU) {\n      if (*packetSize > kDefaultMaxUDPPayload) {\n        // A good peer should never set oversized limit, so to be safe we\n        // fallback to default\n        conn.udpSendPacketLen = kDefaultUDPSendPacketLen;\n      } else {\n        // Otherwise, canIgnorePathMTU forces us to immediately set\n        // udpSendPacketLen\n        // TODO: rename \"canIgnorePathMTU\" to \"forciblySetPathMTU\"\n        conn.udpSendPacketLen = maxUdpPayloadSize;\n      }\n    }\n  }\n\n  conn.peerActiveConnectionIdLimit =\n      activeConnectionIdLimit.value_or(kDefaultActiveConnectionIdLimit);\n\n  if (partialReliability && *partialReliability != 0 &&\n      conn.transportSettings.partialReliabilityEnabled) {\n    conn.partialReliabilityEnabled = true;\n  }\n  VLOG(10) << \"conn.partialReliabilityEnabled=\"\n           << conn.partialReliabilityEnabled;\n\n  if (conn.transportSettings.d6dConfig.enabled) {\n    // Sanity check\n    if (d6dBasePMTU) {\n      if (*d6dBasePMTU >= kMinMaxUDPPayload &&\n          *d6dBasePMTU <= kDefaultMaxUDPPayload) {\n        // The reason to take the max is because we don't want d6d to send\n        // probes with a smaller packet size than udpSendPacketLen, which would\n        // be useless and cause meaningless delay on finding the upper bound.\n        conn.d6d.basePMTU = std::max(*d6dBasePMTU, conn.udpSendPacketLen);\n        conn.d6d.maxPMTU = maxUdpPayloadSize;\n        VLOG(10) << \"conn.d6d.basePMTU=\" << conn.d6d.basePMTU;\n\n        // Start from base\n        conn.d6d.state = D6DMachineState::BASE;\n        conn.d6d.meta.lastNonSearchState = D6DMachineState::DISABLED;\n        conn.d6d.meta.timeLastNonSearchState = Clock::now();\n\n        // Temporary, should be removed after transport knob pipeline works\n        conn.d6d.noBlackholeDetection = true;\n      } else {\n        LOG(ERROR) << \"client d6dBasePMTU fails sanity check: \" << *d6dBasePMTU;\n        // We treat base pmtu transport param as client's swich to activate d6d,\n        // so not receiving that means there's no need to configure the rest d6d\n        // params\n        return;\n      }\n    }\n\n    if (d6dRaiseTimeout) {\n      if (*d6dRaiseTimeout >= kMinD6DRaiseTimeout.count()) {\n        conn.d6d.raiseTimeout = std::chrono::seconds(*d6dRaiseTimeout);\n        VLOG(10) << \"conn.d6d.raiseTimeout=\" << conn.d6d.raiseTimeout.count();\n      } else {\n        LOG(ERROR) << \"client d6dRaiseTimeout fails sanity check: \"\n                   << *d6dRaiseTimeout;\n      }\n    }\n\n    if (d6dProbeTimeout) {\n      if (*d6dProbeTimeout >= kMinD6DProbeTimeout.count()) {\n        conn.d6d.probeTimeout = std::chrono::seconds(*d6dProbeTimeout);\n        VLOG(10) << \"conn.d6d.probeTimeout=\" << conn.d6d.probeTimeout.count();\n      } else {\n        LOG(ERROR) << \"client d6dProbeTimeout fails sanity check: \"\n                   << *d6dProbeTimeout;\n      }\n    }\n  }\n}\n\nvoid updateHandshakeState(QuicServerConnectionState& conn) {\n  // Zero RTT read cipher is available after chlo is processed with the\n  // condition that early data attempt is accepted.\n  auto handshakeLayer = conn.serverHandshakeLayer;\n  auto zeroRttReadCipher = handshakeLayer->getZeroRttReadCipher();\n  auto zeroRttHeaderCipher = handshakeLayer->getZeroRttReadHeaderCipher();\n  // One RTT write cipher is available at Fizz layer after chlo is processed.\n  // However, the cipher is only exported to QUIC if early data attempt is\n  // accepted. Otherwise, the cipher will be available after cfin is\n  // processed.\n  auto oneRttWriteCipher = handshakeLayer->getOneRttWriteCipher();\n  // One RTT read cipher is available after cfin is processed.\n  auto oneRttReadCipher = handshakeLayer->getOneRttReadCipher();\n\n  auto oneRttWriteHeaderCipher = handshakeLayer->getOneRttWriteHeaderCipher();\n  auto oneRttReadHeaderCipher = handshakeLayer->getOneRttReadHeaderCipher();\n\n  if (zeroRttReadCipher) {\n    if (conn.qLogger) {\n      conn.qLogger->addTransportStateUpdate(kDerivedZeroRttReadCipher);\n    }\n    QUIC_TRACE(fst_trace, conn, \"derived 0-rtt read cipher\");\n    conn.readCodec->setZeroRttReadCipher(std::move(zeroRttReadCipher));\n  }\n  if (zeroRttHeaderCipher) {\n    conn.readCodec->setZeroRttHeaderCipher(std::move(zeroRttHeaderCipher));\n  }\n  if (oneRttWriteHeaderCipher) {\n    conn.oneRttWriteHeaderCipher = std::move(oneRttWriteHeaderCipher);\n  }\n  if (oneRttReadHeaderCipher) {\n    conn.readCodec->setOneRttHeaderCipher(std::move(oneRttReadHeaderCipher));\n  }\n\n  if (oneRttWriteCipher) {\n    if (conn.qLogger) {\n      conn.qLogger->addTransportStateUpdate(kDerivedOneRttWriteCipher);\n    }\n    QUIC_TRACE(fst_trace, conn, \"derived 1-rtt write cipher\");\n    if (conn.oneRttWriteCipher) {\n      throw QuicTransportException(\n          \"Duplicate 1-rtt write cipher\", TransportErrorCode::CRYPTO_ERROR);\n    }\n    conn.oneRttWriteCipher = std::move(oneRttWriteCipher);\n\n    updatePacingOnKeyEstablished(conn);\n\n    // We negotiate the transport parameters whenever we have the 1-RTT write\n    // keys available.\n    auto clientParams = handshakeLayer->getClientTransportParams();\n    if (!clientParams) {\n      throw QuicTransportException(\n          \"No client transport params\",\n          TransportErrorCode::TRANSPORT_PARAMETER_ERROR);\n    }\n    processClientInitialParams(conn, std::move(*clientParams));\n  }\n  if (oneRttReadCipher) {\n    if (conn.qLogger) {\n      conn.qLogger->addTransportStateUpdate(kDerivedOneRttReadCipher);\n    }\n    QUIC_TRACE(fst_trace, conn, \"derived 1-rtt read cipher\");\n    // Clear limit because CFIN is received at this point\n    conn.writableBytesLimit = folly::none;\n    conn.readCodec->setOneRttReadCipher(std::move(oneRttReadCipher));\n  }\n  auto handshakeReadCipher = handshakeLayer->getHandshakeReadCipher();\n  auto handshakeReadHeaderCipher =\n      handshakeLayer->getHandshakeReadHeaderCipher();\n  if (handshakeReadCipher) {\n    CHECK(handshakeReadHeaderCipher);\n    conn.readCodec->setHandshakeReadCipher(std::move(handshakeReadCipher));\n    conn.readCodec->setHandshakeHeaderCipher(\n        std::move(handshakeReadHeaderCipher));\n  }\n  if (handshakeLayer->isHandshakeDone()) {\n    CHECK(conn.oneRttWriteCipher);\n    if (conn.version != QuicVersion::MVFST_D24 && !conn.sentHandshakeDone) {\n      sendSimpleFrame(conn, HandshakeDoneFrame());\n      conn.sentHandshakeDone = true;\n    }\n  }\n}\n\nbool validateAndUpdateSourceToken(\n    QuicServerConnectionState& conn,\n    std::vector<folly::IPAddress> sourceAddresses) {\n  DCHECK(conn.peerAddress.isInitialized());\n  bool foundMatch = false;\n  for (int ii = sourceAddresses.size() - 1; ii >= 0; --ii) {\n    // TODO T33014230 subnet matching\n    if (conn.peerAddress.getIPAddress() == sourceAddresses[ii]) {\n      foundMatch = true;\n      // If peer address is found in the token, move the element to the end\n      // of vector to increase its favorability.\n      sourceAddresses.erase(sourceAddresses.begin() + ii);\n      sourceAddresses.push_back(conn.peerAddress.getIPAddress());\n    }\n  }\n  conn.sourceTokenMatching = foundMatch;\n  bool acceptZeroRtt = foundMatch;\n  if (!foundMatch) {\n    // Add peer address to token for next resumption\n    if (sourceAddresses.size() >= kMaxNumTokenSourceAddresses) {\n      sourceAddresses.erase(sourceAddresses.begin());\n    }\n    sourceAddresses.push_back(conn.peerAddress.getIPAddress());\n\n    switch (conn.transportSettings.zeroRttSourceTokenMatchingPolicy) {\n      case ZeroRttSourceTokenMatchingPolicy::REJECT_IF_NO_EXACT_MATCH:\n        acceptZeroRtt = false;\n        break;\n      case ZeroRttSourceTokenMatchingPolicy::LIMIT_IF_NO_EXACT_MATCH:\n        acceptZeroRtt = true;\n        conn.writableBytesLimit =\n            conn.transportSettings.limitedCwndInMss * conn.udpSendPacketLen;\n        break;\n    }\n  }\n  // Save the source token so that it can be written to client via NST later\n  conn.tokenSourceAddresses = std::move(sourceAddresses);\n\n  return acceptZeroRtt;\n}\n\nvoid updateWritableByteLimitOnRecvPacket(QuicServerConnectionState& conn) {\n  // When we receive a packet we increase the limit again. The reasoning this is\n  // that a peer can do the same by opening a new connection.\n  if (conn.writableBytesLimit) {\n    conn.writableBytesLimit = *conn.writableBytesLimit +\n        conn.transportSettings.limitedCwndInMss * conn.udpSendPacketLen;\n  }\n}\n\nvoid updateTransportParamsFromTicket(\n    QuicServerConnectionState& conn,\n    uint64_t idleTimeout,\n    uint64_t maxRecvPacketSize,\n    uint64_t initialMaxData,\n    uint64_t initialMaxStreamDataBidiLocal,\n    uint64_t initialMaxStreamDataBidiRemote,\n    uint64_t initialMaxStreamDataUni,\n    uint64_t initialMaxStreamsBidi,\n    uint64_t initialMaxStreamsUni) {\n  conn.transportSettings.idleTimeout = std::chrono::milliseconds(idleTimeout);\n  conn.transportSettings.maxRecvPacketSize = maxRecvPacketSize;\n\n  conn.transportSettings.advertisedInitialConnectionWindowSize = initialMaxData;\n  conn.transportSettings.advertisedInitialBidiLocalStreamWindowSize =\n      initialMaxStreamDataBidiLocal;\n  conn.transportSettings.advertisedInitialBidiRemoteStreamWindowSize =\n      initialMaxStreamDataBidiRemote;\n  conn.transportSettings.advertisedInitialUniStreamWindowSize =\n      initialMaxStreamDataUni;\n  updateFlowControlStateWithSettings(\n      conn.flowControlState, conn.transportSettings);\n\n  conn.transportSettings.advertisedInitialMaxStreamsBidi =\n      initialMaxStreamsBidi;\n  conn.transportSettings.advertisedInitialMaxStreamsUni = initialMaxStreamsUni;\n}\n\nvoid onConnectionMigration(\n    QuicServerConnectionState& conn,\n    const folly::SocketAddress& newPeerAddress,\n    bool isIntentional) {\n  if (conn.migrationState.numMigrations >= kMaxNumMigrationsAllowed) {\n    if (conn.qLogger) {\n      conn.qLogger->addPacketDrop(\n          0,\n          QuicTransportStatsCallback::toString(\n              PacketDropReason::PEER_ADDRESS_CHANGE));\n    }\n    QUIC_STATS(\n        conn.statsCallback,\n        onPacketDropped,\n        PacketDropReason::PEER_ADDRESS_CHANGE);\n    throw QuicTransportException(\n        \"Too many migrations\", TransportErrorCode::INVALID_MIGRATION);\n  }\n  ++conn.migrationState.numMigrations;\n\n  bool hasPendingPathChallenge = conn.pendingEvents.pathChallenge.has_value();\n  // Clear any pending path challenge frame that is not sent\n  conn.pendingEvents.pathChallenge = folly::none;\n\n  auto& previousPeerAddresses = conn.migrationState.previousPeerAddresses;\n  auto it = std::find(\n      previousPeerAddresses.begin(),\n      previousPeerAddresses.end(),\n      newPeerAddress);\n  if (it == previousPeerAddresses.end()) {\n    // Send new path challenge\n    uint64_t pathData;\n    folly::Random::secureRandom(&pathData, sizeof(pathData));\n    conn.pendingEvents.pathChallenge = PathChallengeFrame(pathData);\n\n    // If we are already in the middle of a migration reset\n    // the available bytes in the rate-limited window, but keep the\n    // window.\n    conn.pathValidationLimiter =\n        std::make_unique<PendingPathRateLimiter>(conn.udpSendPacketLen);\n  } else {\n    previousPeerAddresses.erase(it);\n  }\n\n  // At this point, path validation scheduled, writable bytes limit set\n  // However if this is NAT rebinding, keep congestion state unchanged\n  bool isNATRebinding = maybeNATRebinding(newPeerAddress, conn.peerAddress);\n\n  // Cancel current path validation if any\n  if (hasPendingPathChallenge || conn.outstandingPathValidation) {\n    conn.pendingEvents.schedulePathValidationTimeout = false;\n    conn.outstandingPathValidation = folly::none;\n\n    // Only change congestion & rtt state if not NAT rebinding\n    if (!isNATRebinding) {\n      recoverOrResetCongestionAndRttState(conn, newPeerAddress);\n    }\n  } else {\n    // Only add validated addresses to previousPeerAddresses\n    conn.migrationState.previousPeerAddresses.push_back(conn.peerAddress);\n\n    // Only change congestion & rtt state if not NAT rebinding\n    if (!isNATRebinding) {\n      // Current peer address is validated,\n      // remember its congestion state and rtt stats\n      CongestionAndRttState state = moveCurrentCongestionAndRttState(conn);\n      recoverOrResetCongestionAndRttState(conn, newPeerAddress);\n      conn.migrationState.lastCongestionAndRtt = std::move(state);\n    }\n  }\n\n  if (conn.qLogger) {\n    conn.qLogger->addConnectionMigrationUpdate(isIntentional);\n  }\n  conn.peerAddress = newPeerAddress;\n}\n\nvoid onServerReadData(\n    QuicServerConnectionState& conn,\n    ServerEvents::ReadData& readData) {\n  switch (conn.state) {\n    case ServerState::Open:\n      onServerReadDataFromOpen(conn, readData);\n      return;\n    case ServerState::Closed:\n      onServerReadDataFromClosed(conn, readData);\n      return;\n  }\n}\n\nvoid handleCipherUnavailable(\n    CipherUnavailable* originalData,\n    QuicServerConnectionState& conn,\n    size_t packetSize,\n    ServerEvents::ReadData& readData) {\n  if (!originalData->packet || originalData->packet->empty()) {\n    VLOG(10) << \"drop because no data \" << conn;\n    if (conn.qLogger) {\n      conn.qLogger->addPacketDrop(packetSize, kNoData);\n    }\n    QUIC_TRACE(packet_drop, conn, \"no_data\");\n    return;\n  }\n  if (originalData->protectionType != ProtectionType::ZeroRtt &&\n      originalData->protectionType != ProtectionType::KeyPhaseZero) {\n    VLOG(10) << \"drop because unexpected protection level \" << conn;\n    if (conn.qLogger) {\n      conn.qLogger->addPacketDrop(packetSize, kUnexpectedProtectionLevel);\n    }\n    QUIC_TRACE(packet_drop, conn, \"unexpected_protection_level\");\n    return;\n  }\n\n  size_t combinedSize =\n      (conn.pendingZeroRttData ? conn.pendingZeroRttData->size() : 0) +\n      (conn.pendingOneRttData ? conn.pendingOneRttData->size() : 0);\n  if (combinedSize >= conn.transportSettings.maxPacketsToBuffer) {\n    VLOG(10) << \"drop because max buffered \" << conn;\n    if (conn.qLogger) {\n      conn.qLogger->addPacketDrop(packetSize, kMaxBuffered);\n    }\n    QUIC_TRACE(packet_drop, conn, \"max_buffered\");\n    return;\n  }\n\n  auto& pendingData = originalData->protectionType == ProtectionType::ZeroRtt\n      ? conn.pendingZeroRttData\n      : conn.pendingOneRttData;\n  if (pendingData) {\n    QUIC_TRACE(\n        packet_buffered,\n        conn,\n        originalData->packetNum,\n        originalData->protectionType,\n        packetSize);\n    if (conn.qLogger) {\n      conn.qLogger->addPacketBuffered(\n          originalData->packetNum, originalData->protectionType, packetSize);\n    }\n    ServerEvents::ReadData pendingReadData;\n    pendingReadData.peer = readData.peer;\n    pendingReadData.networkData = NetworkDataSingle(\n        std::move(originalData->packet), readData.networkData.receiveTimePoint);\n    pendingData->emplace_back(std::move(pendingReadData));\n    VLOG(10) << \"Adding pending data to \"\n             << toString(originalData->protectionType)\n             << \" buffer size=\" << pendingData->size() << \" \" << conn;\n  } else {\n    VLOG(10) << \"drop because \" << toString(originalData->protectionType)\n             << \" buffer no longer available \" << conn;\n    if (conn.qLogger) {\n      conn.qLogger->addPacketDrop(packetSize, kBufferUnavailable);\n    }\n    QUIC_TRACE(packet_drop, conn, \"buffer_unavailable\");\n  }\n}\n\nvoid onServerReadDataFromOpen(\n    QuicServerConnectionState& conn,\n    ServerEvents::ReadData& readData) {\n  CHECK_EQ(conn.state, ServerState::Open);\n  // Don't bother parsing if the data is empty.\n  if (!readData.networkData.data ||\n      readData.networkData.data->computeChainDataLength() == 0) {\n    return;\n  }\n  if (!conn.readCodec) {\n    // First packet from the peer\n    folly::io::Cursor cursor(readData.networkData.data.get());\n    auto initialByte = cursor.readBE<uint8_t>();\n    auto parsedLongHeader = parseLongHeaderInvariant(initialByte, cursor);\n    if (!parsedLongHeader) {\n      VLOG(4) << \"Could not parse initial packet header\";\n      if (conn.qLogger) {\n        conn.qLogger->addPacketDrop(\n            0,\n            QuicTransportStatsCallback::toString(\n                PacketDropReason::PARSE_ERROR));\n      }\n      QUIC_STATS(\n          conn.statsCallback, onPacketDropped, PacketDropReason::PARSE_ERROR);\n      return;\n    }\n    QuicVersion version = parsedLongHeader->invariant.version;\n    if (version == QuicVersion::VERSION_NEGOTIATION) {\n      VLOG(4) << \"Server droppiong VN packet\";\n      if (conn.qLogger) {\n        conn.qLogger->addPacketDrop(\n            0,\n            QuicTransportStatsCallback::toString(\n                PacketDropReason::INVALID_PACKET));\n      }\n      QUIC_STATS(\n          conn.statsCallback,\n          onPacketDropped,\n          PacketDropReason::INVALID_PACKET);\n      return;\n    }\n\n    const auto& clientConnectionId = parsedLongHeader->invariant.srcConnId;\n    const auto& initialDestinationConnectionId =\n        parsedLongHeader->invariant.dstConnId;\n\n    if (initialDestinationConnectionId.size() < kDefaultConnectionIdSize) {\n      VLOG(4) << \"Initial connectionid too small\";\n      if (conn.qLogger) {\n        conn.qLogger->addPacketDrop(\n            0,\n            QuicTransportStatsCallback::toString(\n                PacketDropReason::INITIAL_CONNID_SMALL));\n      }\n      QUIC_STATS(\n          conn.statsCallback,\n          onPacketDropped,\n          PacketDropReason::INITIAL_CONNID_SMALL);\n      return;\n    }\n\n    CHECK(conn.connIdAlgo) << \"ConnectionIdAlgo is not set.\";\n    CHECK(!conn.serverConnectionId.has_value());\n    // serverConnIdParams must be set by the QuicServerTransport\n    CHECK(conn.serverConnIdParams);\n\n    auto newServerConnIdData = conn.createAndAddNewSelfConnId();\n    CHECK(newServerConnIdData.has_value());\n    conn.serverConnectionId = newServerConnIdData->connId;\n\n    QUIC_STATS(conn.statsCallback, onStatelessReset);\n    conn.serverHandshakeLayer->accept(\n        std::make_shared<ServerTransportParametersExtension>(\n            version,\n            conn.transportSettings.advertisedInitialConnectionWindowSize,\n            conn.transportSettings.advertisedInitialBidiLocalStreamWindowSize,\n            conn.transportSettings.advertisedInitialBidiRemoteStreamWindowSize,\n            conn.transportSettings.advertisedInitialUniStreamWindowSize,\n            conn.transportSettings.advertisedInitialMaxStreamsBidi,\n            conn.transportSettings.advertisedInitialMaxStreamsUni,\n            conn.transportSettings.idleTimeout,\n            conn.transportSettings.ackDelayExponent,\n            conn.transportSettings.maxRecvPacketSize,\n            conn.transportSettings.partialReliabilityEnabled,\n            *newServerConnIdData->token,\n            conn.serverConnectionId.value(),\n            initialDestinationConnectionId));\n    conn.transportParametersEncoded = true;\n    const CryptoFactory& cryptoFactory =\n        conn.serverHandshakeLayer->getCryptoFactory();\n    conn.readCodec = std::make_unique<QuicReadCodec>(QuicNodeType::Server);\n    conn.readCodec->setInitialReadCipher(cryptoFactory.getClientInitialCipher(\n        initialDestinationConnectionId, version));\n    conn.readCodec->setClientConnectionId(clientConnectionId);\n    conn.readCodec->setServerConnectionId(*conn.serverConnectionId);\n    if (conn.qLogger) {\n      conn.qLogger->setScid(conn.serverConnectionId);\n      conn.qLogger->setDcid(initialDestinationConnectionId);\n    }\n    conn.readCodec->setCodecParameters(\n        CodecParameters(conn.peerAckDelayExponent, version));\n    conn.initialWriteCipher = cryptoFactory.getServerInitialCipher(\n        initialDestinationConnectionId, version);\n\n    conn.readCodec->setInitialHeaderCipher(\n        cryptoFactory.makeClientInitialHeaderCipher(\n            initialDestinationConnectionId, version));\n    conn.initialHeaderCipher = cryptoFactory.makeServerInitialHeaderCipher(\n        initialDestinationConnectionId, version);\n    conn.peerAddress = conn.originalPeerAddress;\n  }\n  BufQueue udpData;\n  udpData.append(std::move(readData.networkData.data));\n  for (uint16_t processedPackets = 0;\n       !udpData.empty() && processedPackets < kMaxNumCoalescedPackets;\n       processedPackets++) {\n    size_t dataSize = udpData.chainLength();\n    auto parsedPacket = conn.readCodec->parsePacket(udpData, conn.ackStates);\n    size_t packetSize = dataSize - udpData.chainLength();\n\n    switch (parsedPacket.type()) {\n      case CodecResult::Type::CIPHER_UNAVAILABLE: {\n        handleCipherUnavailable(\n            parsedPacket.cipherUnavailable(), conn, packetSize, readData);\n        break;\n      }\n      case CodecResult::Type::RETRY: {\n        VLOG(10) << \"drop because the server is not supposed to \"\n                 << \"receive a retry \" << conn;\n        if (conn.qLogger) {\n          conn.qLogger->addPacketDrop(packetSize, kRetry);\n        }\n        QUIC_TRACE(packet_drop, conn, \"retry\");\n        break;\n      }\n      case CodecResult::Type::STATELESS_RESET: {\n        VLOG(10) << \"drop because reset \" << conn;\n        if (conn.qLogger) {\n          conn.qLogger->addPacketDrop(packetSize, kReset);\n        }\n        QUIC_TRACE(packet_drop, conn, \"reset\");\n        break;\n      }\n      case CodecResult::Type::NOTHING: {\n        VLOG(10) << \"drop cipher unavailable, no data \" << conn;\n        if (conn.qLogger) {\n          conn.qLogger->addPacketDrop(packetSize, kCipherUnavailable);\n        }\n        QUIC_TRACE(packet_drop, conn, \"cipher_unavailable\");\n        break;\n      }\n      case CodecResult::Type::REGULAR_PACKET:\n        break;\n    }\n\n    RegularQuicPacket* regularOptional = parsedPacket.regularPacket();\n    if (!regularOptional) {\n      // We were unable to parse the packet, drop for now. All the drop reasons\n      // should have already been logged into QLogger and QuicTrace inside the\n      // previous switch-case block. We just need to update QUIC_STATS here.\n      VLOG(10) << \"Not able to parse QUIC packet \" << conn;\n      QUIC_STATS(\n          conn.statsCallback, onPacketDropped, PacketDropReason::PARSE_ERROR);\n      continue;\n    }\n\n    auto protectionLevel = regularOptional->header.getProtectionType();\n    auto encryptionLevel = protectionTypeToEncryptionLevel(protectionLevel);\n\n    auto packetNum = regularOptional->header.getPacketSequenceNum();\n    auto packetNumberSpace = regularOptional->header.getPacketNumberSpace();\n\n    // TODO: enforce constraints on other protection levels.\n    auto& regularPacket = *regularOptional;\n\n    bool isProtectedPacket = protectionLevel == ProtectionType::ZeroRtt ||\n        protectionLevel == ProtectionType::KeyPhaseZero ||\n        protectionLevel == ProtectionType::KeyPhaseOne;\n\n    if (!isProtectedPacket) {\n      for (auto& quicFrame : regularPacket.frames) {\n        auto isPadding = quicFrame.asPaddingFrame();\n        auto isAck = quicFrame.asReadAckFrame();\n        auto isClose = quicFrame.asConnectionCloseFrame();\n        auto isCrypto = quicFrame.asReadCryptoFrame();\n        auto isPing = quicFrame.asPingFrame();\n        // TODO: add path challenge and response\n        if (!isPadding && !isAck && !isClose && !isCrypto && !isPing) {\n          QUIC_STATS(\n              conn.statsCallback,\n              onPacketDropped,\n              PacketDropReason::PROTOCOL_VIOLATION);\n          if (conn.qLogger) {\n            conn.qLogger->addPacketDrop(\n                packetSize,\n                QuicTransportStatsCallback::toString(\n                    PacketDropReason::PROTOCOL_VIOLATION));\n          }\n          throw QuicTransportException(\n              \"Invalid frame\", TransportErrorCode::PROTOCOL_VIOLATION);\n        }\n      }\n    }\n\n    CHECK(conn.clientConnectionId);\n    if (conn.qLogger) {\n      conn.qLogger->addPacket(regularPacket, packetSize);\n    }\n    // We assume that the higher layer takes care of validating that the version\n    // is supported.\n    if (!conn.version) {\n      LongHeader* longHeader = regularPacket.header.asLong();\n      if (!longHeader) {\n        throw QuicTransportException(\n            \"Invalid packet type\", TransportErrorCode::PROTOCOL_VIOLATION);\n      }\n      conn.version = longHeader->getVersion();\n      if (conn.version == QuicVersion::MVFST_EXPERIMENTAL) {\n        setExperimentalSettings(conn);\n      }\n    }\n\n    if (conn.peerAddress != readData.peer) {\n      if (encryptionLevel != EncryptionLevel::AppData) {\n        if (conn.qLogger) {\n          conn.qLogger->addPacketDrop(\n              packetSize,\n              QuicTransportStatsCallback::toString(\n                  PacketDropReason::PEER_ADDRESS_CHANGE));\n        }\n        QUIC_STATS(\n            conn.statsCallback,\n            onPacketDropped,\n            PacketDropReason::PEER_ADDRESS_CHANGE);\n        throw QuicTransportException(\n            \"Migration not allowed during handshake\",\n            TransportErrorCode::INVALID_MIGRATION);\n      }\n\n      if (conn.transportSettings.disableMigration) {\n        if (conn.qLogger) {\n          conn.qLogger->addPacketDrop(\n              packetSize,\n              QuicTransportStatsCallback::toString(\n                  PacketDropReason::PEER_ADDRESS_CHANGE));\n        }\n        QUIC_STATS(\n            conn.statsCallback,\n            onPacketDropped,\n            PacketDropReason::PEER_ADDRESS_CHANGE);\n        throw QuicTransportException(\n            \"Migration disabled\", TransportErrorCode::INVALID_MIGRATION);\n      }\n    }\n\n    auto& ackState = getAckState(conn, packetNumberSpace);\n    bool outOfOrder = updateLargestReceivedPacketNum(\n        ackState, packetNum, readData.networkData.receiveTimePoint);\n    if (outOfOrder) {\n      QUIC_STATS(conn.statsCallback, onOutOfOrderPacketReceived);\n    }\n    DCHECK(hasReceivedPackets(conn));\n\n    bool pktHasRetransmittableData = false;\n    bool pktHasCryptoData = false;\n    bool isNonProbingPacket = false;\n    bool handshakeConfirmedThisLoop = false;\n\n    // TODO: possibly drop the packet here, but rolling back state of\n    // what we've already processed is difficult.\n    for (auto& quicFrame : regularPacket.frames) {\n      switch (quicFrame.type()) {\n        case QuicFrame::Type::ReadAckFrame: {\n          VLOG(10) << \"Server received ack frame packet=\" << packetNum << \" \"\n                   << conn;\n          isNonProbingPacket = true;\n          ReadAckFrame& ackFrame = *quicFrame.asReadAckFrame();\n          processAckFrame(\n              conn,\n              packetNumberSpace,\n              ackFrame,\n              [&](const OutstandingPacket& packet,\n                  const QuicWriteFrame& packetFrame,\n                  const ReadAckFrame&) {\n                switch (packetFrame.type()) {\n                  case QuicWriteFrame::Type::WriteStreamFrame: {\n                    const WriteStreamFrame& frame =\n                        *packetFrame.asWriteStreamFrame();\n                    VLOG(4)\n                        << \"Server received ack for stream=\" << frame.streamId\n                        << \" offset=\" << frame.offset << \" fin=\" << frame.fin\n                        << \" len=\" << frame.len << \" \" << conn;\n                    auto ackedStream =\n                        conn.streamManager->getStream(frame.streamId);\n                    if (ackedStream) {\n                      sendAckSMHandler(*ackedStream, frame);\n                    }\n                    break;\n                  }\n                  case QuicWriteFrame::Type::WriteCryptoFrame: {\n                    const WriteCryptoFrame& frame =\n                        *packetFrame.asWriteCryptoFrame();\n                    auto cryptoStream =\n                        getCryptoStream(*conn.cryptoState, encryptionLevel);\n                    processCryptoStreamAck(\n                        *cryptoStream, frame.offset, frame.len);\n                    break;\n                  }\n                  case QuicWriteFrame::Type::RstStreamFrame: {\n                    const RstStreamFrame& frame =\n                        *packetFrame.asRstStreamFrame();\n                    VLOG(4) << \"Server received ack for reset stream=\"\n                            << frame.streamId << \" \" << conn;\n                    auto stream = conn.streamManager->getStream(frame.streamId);\n                    if (stream) {\n                      sendRstAckSMHandler(*stream);\n                    }\n                    break;\n                  }\n                  case QuicWriteFrame::Type::WriteAckFrame: {\n                    const WriteAckFrame& frame = *packetFrame.asWriteAckFrame();\n                    DCHECK(!frame.ackBlocks.empty());\n                    VLOG(4) << \"Server received ack for largestAcked=\"\n                            << frame.ackBlocks.front().end << \" \" << conn;\n                    commonAckVisitorForAckFrame(ackState, frame);\n                    break;\n                  }\n                  case QuicWriteFrame::Type::PingFrame:\n                    if (!packet.metadata.isD6DProbe) {\n                      conn.pendingEvents.cancelPingTimeout = true;\n                    }\n                    return;\n                  case QuicWriteFrame::Type::QuicSimpleFrame: {\n                    const QuicSimpleFrame& frame =\n                        *packetFrame.asQuicSimpleFrame();\n                    // ACK of HandshakeDone is a server-specific behavior.\n                    if (frame.asHandshakeDoneFrame() &&\n                        conn.version != QuicVersion::MVFST_D24) {\n                      // Call handshakeConfirmed outside of the packet\n                      // processing loop to avoid a re-entrancy.\n                      handshakeConfirmedThisLoop = true;\n                    }\n                    break;\n                  }\n                  default: {\n                    break;\n                  }\n                }\n              },\n              markPacketLoss,\n              readData.networkData.receiveTimePoint);\n          break;\n        }\n        case QuicFrame::Type::RstStreamFrame: {\n          RstStreamFrame& frame = *quicFrame.asRstStreamFrame();\n          VLOG(10) << \"Server received reset stream=\" << frame.streamId << \" \"\n                   << conn;\n          pktHasRetransmittableData = true;\n          isNonProbingPacket = true;\n          auto stream = conn.streamManager->getStream(frame.streamId);\n          if (!stream) {\n            break;\n          }\n          receiveRstStreamSMHandler(*stream, frame);\n          break;\n        }\n        case QuicFrame::Type::ReadCryptoFrame: {\n          pktHasRetransmittableData = true;\n          pktHasCryptoData = true;\n          isNonProbingPacket = true;\n          ReadCryptoFrame& cryptoFrame = *quicFrame.asReadCryptoFrame();\n          VLOG(10) << \"Server received crypto data offset=\"\n                   << cryptoFrame.offset\n                   << \" len=\" << cryptoFrame.data->computeChainDataLength()\n                   << \" currentReadOffset=\"\n                   << getCryptoStream(*conn.cryptoState, encryptionLevel)\n                          ->currentReadOffset\n                   << \" \" << conn;\n          appendDataToReadBuffer(\n              *getCryptoStream(*conn.cryptoState, encryptionLevel),\n              StreamBuffer(\n                  std::move(cryptoFrame.data), cryptoFrame.offset, false));\n          break;\n        }\n        case QuicFrame::Type::ReadStreamFrame: {\n          ReadStreamFrame& frame = *quicFrame.asReadStreamFrame();\n          VLOG(10) << \"Server received stream data for stream=\"\n                   << frame.streamId << \", offset=\" << frame.offset\n                   << \" len=\" << frame.data->computeChainDataLength()\n                   << \" fin=\" << frame.fin << \" \" << conn;\n          pktHasRetransmittableData = true;\n          isNonProbingPacket = true;\n          auto stream = conn.streamManager->getStream(frame.streamId);\n          // Ignore data from closed streams that we don't have the\n          // state for any more.\n          if (stream) {\n            receiveReadStreamFrameSMHandler(*stream, std::move(frame));\n          }\n          break;\n        }\n        case QuicFrame::Type::MaxDataFrame: {\n          MaxDataFrame& connWindowUpdate = *quicFrame.asMaxDataFrame();\n          VLOG(10) << \"Server received max data offset=\"\n                   << connWindowUpdate.maximumData << \" \" << conn;\n          pktHasRetransmittableData = true;\n          isNonProbingPacket = true;\n          handleConnWindowUpdate(conn, connWindowUpdate, packetNum);\n          break;\n        }\n        case QuicFrame::Type::MaxStreamDataFrame: {\n          MaxStreamDataFrame& streamWindowUpdate =\n              *quicFrame.asMaxStreamDataFrame();\n          VLOG(10) << \"Server received max stream data stream=\"\n                   << streamWindowUpdate.streamId\n                   << \" offset=\" << streamWindowUpdate.maximumData << \" \"\n                   << conn;\n          if (isReceivingStream(conn.nodeType, streamWindowUpdate.streamId)) {\n            throw QuicTransportException(\n                \"Received MaxStreamDataFrame for receiving stream.\",\n                TransportErrorCode::STREAM_STATE_ERROR);\n          }\n          pktHasRetransmittableData = true;\n          isNonProbingPacket = true;\n          auto stream =\n              conn.streamManager->getStream(streamWindowUpdate.streamId);\n          if (stream) {\n            handleStreamWindowUpdate(\n                *stream, streamWindowUpdate.maximumData, packetNum);\n          }\n          break;\n        }\n        case QuicFrame::Type::DataBlockedFrame: {\n          VLOG(10) << \"Server received blocked \" << conn;\n          pktHasRetransmittableData = true;\n          isNonProbingPacket = true;\n          handleConnBlocked(conn);\n          break;\n        }\n        case QuicFrame::Type::StreamDataBlockedFrame: {\n          StreamDataBlockedFrame& blocked =\n              *quicFrame.asStreamDataBlockedFrame();\n          VLOG(10) << \"Server received blocked stream=\" << blocked.streamId\n                   << \" \" << conn;\n          pktHasRetransmittableData = true;\n          isNonProbingPacket = true;\n          auto stream = conn.streamManager->getStream(blocked.streamId);\n          if (stream) {\n            handleStreamBlocked(*stream);\n          }\n          break;\n        }\n        case QuicFrame::Type::StreamsBlockedFrame: {\n          StreamsBlockedFrame& blocked = *quicFrame.asStreamsBlockedFrame();\n          // peer wishes to open a stream, but is unable to due to the maximum\n          // stream limit set by us\n          // TODO implement the handler\n          isNonProbingPacket = true;\n          VLOG(10) << \"Server received streams blocked limit=\"\n                   << blocked.streamLimit << \", \" << conn;\n          break;\n        }\n        case QuicFrame::Type::ConnectionCloseFrame: {\n          isNonProbingPacket = true;\n          ConnectionCloseFrame& connFrame = *quicFrame.asConnectionCloseFrame();\n          auto errMsg = folly::to<std::string>(\n              \"Server closed by peer reason=\", connFrame.reasonPhrase);\n          VLOG(4) << errMsg << \" \" << conn;\n          // we want to deliver app callbacks with the peer supplied error,\n          // but send a NO_ERROR to the peer.\n          QUIC_TRACE(recvd_close, conn, errMsg.c_str());\n          if (conn.qLogger) {\n            conn.qLogger->addTransportStateUpdate(getPeerClose(errMsg));\n          }\n          conn.peerConnectionError = std::make_pair(\n              QuicErrorCode(connFrame.errorCode), std::move(errMsg));\n          if (getSendConnFlowControlBytesWire(conn) == 0 &&\n              conn.flowControlState.sumCurStreamBufferLen) {\n            VLOG(2) << \"Client gives up a flow control blocked connection\";\n          }\n          throw QuicTransportException(\n              \"Peer closed\", TransportErrorCode::NO_ERROR);\n          break;\n        }\n        case QuicFrame::Type::PingFrame:\n          isNonProbingPacket = true;\n          // Ping isn't retransmittable data. But we would like to ack them\n          // early.\n          pktHasRetransmittableData = true;\n          break;\n        case QuicFrame::Type::PaddingFrame:\n          break;\n        case QuicFrame::Type::QuicSimpleFrame: {\n          pktHasRetransmittableData = true;\n          QuicSimpleFrame& simpleFrame = *quicFrame.asQuicSimpleFrame();\n          isNonProbingPacket |= updateSimpleFrameOnPacketReceived(\n              conn, simpleFrame, packetNum, readData.peer != conn.peerAddress);\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n    }\n\n    if (handshakeConfirmedThisLoop) {\n      handshakeConfirmed(conn);\n    }\n\n    // Update writable limit before processing the handshake data. This is so\n    // that if we haven't decided whether or not to validate the peer, we won't\n    // increase the limit.\n    updateWritableByteLimitOnRecvPacket(conn);\n\n    if (conn.peerAddress != readData.peer) {\n      // TODO use new conn id, make sure the other endpoint has new conn id\n      if (isNonProbingPacket) {\n        if (packetNum == ackState.largestReceivedPacketNum) {\n          ShortHeader* shortHeader = regularPacket.header.asShort();\n          bool intentionalMigration = false;\n          if (shortHeader &&\n              shortHeader->getConnectionId() != conn.serverConnectionId) {\n            intentionalMigration = true;\n          }\n          onConnectionMigration(conn, readData.peer, intentionalMigration);\n        }\n      } else {\n        // Server will need to response with PathResponse to the new address\n        // while not updating peerAddress to new address\n        if (conn.qLogger) {\n          conn.qLogger->addPacketDrop(\n              packetSize,\n              QuicTransportStatsCallback::toString(\n                  PacketDropReason::PEER_ADDRESS_CHANGE));\n        }\n        QUIC_STATS(\n            conn.statsCallback,\n            onPacketDropped,\n            PacketDropReason::PEER_ADDRESS_CHANGE);\n        throw QuicTransportException(\n            \"Probing not supported yet\", TransportErrorCode::INVALID_MIGRATION);\n      }\n    }\n\n    // Try reading bytes off of crypto, and performing a handshake.\n    auto data = readDataFromCryptoStream(\n        *getCryptoStream(*conn.cryptoState, encryptionLevel));\n    if (data) {\n      conn.serverHandshakeLayer->doHandshake(std::move(data), encryptionLevel);\n\n      try {\n        updateHandshakeState(conn);\n      } catch (...) {\n        if (conn.qLogger) {\n          conn.qLogger->addPacketDrop(\n              packetSize,\n              QuicTransportStatsCallback::toString(\n                  PacketDropReason::TRANSPORT_PARAMETER_ERROR));\n        }\n        QUIC_STATS(\n            conn.statsCallback,\n            onPacketDropped,\n            QuicTransportStatsCallback::PacketDropReason::\n                TRANSPORT_PARAMETER_ERROR);\n        throw;\n      }\n    }\n    updateAckSendStateOnRecvPacket(\n        conn,\n        ackState,\n        outOfOrder,\n        pktHasRetransmittableData,\n        pktHasCryptoData);\n    if (encryptionLevel == EncryptionLevel::Handshake &&\n        conn.version != QuicVersion::MVFST_D24 && conn.initialWriteCipher) {\n      conn.initialWriteCipher.reset();\n      conn.initialHeaderCipher.reset();\n      conn.readCodec->setInitialReadCipher(nullptr);\n      conn.readCodec->setInitialHeaderCipher(nullptr);\n      implicitAckCryptoStream(conn, EncryptionLevel::Initial);\n    }\n    QUIC_STATS(conn.statsCallback, onPacketProcessed);\n  }\n  VLOG_IF(4, !udpData.empty())\n      << \"Leaving \" << udpData.chainLength()\n      << \" bytes unprocessed after attempting to process \"\n      << kMaxNumCoalescedPackets << \" packets.\";\n}\n\nvoid onServerReadDataFromClosed(\n    QuicServerConnectionState& conn,\n    ServerEvents::ReadData& readData) {\n  CHECK_EQ(conn.state, ServerState::Closed);\n  BufQueue udpData;\n  udpData.append(std::move(readData.networkData.data));\n  auto packetSize = udpData.empty() ? 0 : udpData.chainLength();\n  if (!conn.readCodec) {\n    // drop data. We closed before we even got the first packet. This is\n    // normally not possible but might as well.\n    if (conn.qLogger) {\n      conn.qLogger->addPacketDrop(\n          packetSize,\n          QuicTransportStatsCallback::toString(\n              PacketDropReason::SERVER_STATE_CLOSED));\n    }\n    QUIC_STATS(\n        conn.statsCallback,\n        onPacketDropped,\n        PacketDropReason::SERVER_STATE_CLOSED);\n    return;\n  }\n\n  if (conn.peerConnectionError) {\n    // We already got a peer error. We can ignore any futher peer errors.\n    if (conn.qLogger) {\n      conn.qLogger->addPacketDrop(\n          packetSize,\n          QuicTransportStatsCallback::toString(\n              PacketDropReason::SERVER_STATE_CLOSED));\n    }\n    QUIC_TRACE(packet_drop, conn, \"ignoring peer close\");\n    QUIC_STATS(\n        conn.statsCallback,\n        onPacketDropped,\n        PacketDropReason::SERVER_STATE_CLOSED);\n    return;\n  }\n  auto parsedPacket = conn.readCodec->parsePacket(udpData, conn.ackStates);\n  switch (parsedPacket.type()) {\n    case CodecResult::Type::CIPHER_UNAVAILABLE: {\n      VLOG(10) << \"drop cipher unavailable \" << conn;\n      if (conn.qLogger) {\n        conn.qLogger->addPacketDrop(packetSize, kCipherUnavailable);\n      }\n      QUIC_TRACE(packet_drop, conn, \"cipher_unavailable\");\n      break;\n    }\n    case CodecResult::Type::RETRY: {\n      VLOG(10) << \"drop because the server is not supposed to \"\n               << \"receive a retry \" << conn;\n      if (conn.qLogger) {\n        conn.qLogger->addPacketDrop(packetSize, kRetry);\n      }\n      QUIC_TRACE(packet_drop, conn, \"retry\");\n      break;\n    }\n    case CodecResult::Type::STATELESS_RESET: {\n      VLOG(10) << \"drop because reset \" << conn;\n      if (conn.qLogger) {\n        conn.qLogger->addPacketDrop(packetSize, kReset);\n      }\n      QUIC_TRACE(packet_drop, conn, \"reset\");\n      break;\n    }\n    case CodecResult::Type::NOTHING: {\n      VLOG(10) << \"drop cipher unavailable, no data \" << conn;\n      if (conn.qLogger) {\n        conn.qLogger->addPacketDrop(packetSize, kCipherUnavailable);\n      }\n      QUIC_TRACE(packet_drop, conn, \"cipher_unavailable\");\n      break;\n    }\n    case CodecResult::Type::REGULAR_PACKET:\n      break;\n  }\n  auto regularOptional = parsedPacket.regularPacket();\n  if (!regularOptional) {\n    // We were unable to parse the packet, drop for now.\n    VLOG(10) << \"Not able to parse QUIC packet \" << conn;\n    if (conn.qLogger) {\n      conn.qLogger->addPacketDrop(\n          packetSize,\n          QuicTransportStatsCallback::toString(PacketDropReason::PARSE_ERROR));\n    }\n    QUIC_STATS(\n        conn.statsCallback, onPacketDropped, PacketDropReason::PARSE_ERROR);\n    return;\n  }\n\n  auto& regularPacket = *regularOptional;\n  auto packetNum = regularPacket.header.getPacketSequenceNum();\n  auto pnSpace = regularPacket.header.getPacketNumberSpace();\n  if (conn.qLogger) {\n    conn.qLogger->addPacket(regularPacket, packetSize);\n  }\n\n  // Only process the close frames in the packet\n  for (auto& quicFrame : regularPacket.frames) {\n    switch (quicFrame.type()) {\n      case QuicFrame::Type::ConnectionCloseFrame: {\n        ConnectionCloseFrame& connFrame = *quicFrame.asConnectionCloseFrame();\n        auto errMsg = folly::to<std::string>(\n            \"Server closed by peer reason=\", connFrame.reasonPhrase);\n        VLOG(4) << errMsg << \" \" << conn;\n        if (conn.qLogger) {\n          conn.qLogger->addTransportStateUpdate(getPeerClose(errMsg));\n        }\n        // we want to deliver app callbacks with the peer supplied error,\n        // but send a NO_ERROR to the peer.\n        QUIC_TRACE(recvd_close, conn, errMsg.c_str());\n        conn.peerConnectionError = std::make_pair(\n            QuicErrorCode(connFrame.errorCode), std::move(errMsg));\n        break;\n      }\n      default:\n        break;\n    }\n  }\n\n  // We only need to set the largest received packet number in order to\n  // determine whether or not we need to send a new close.\n  auto& largestReceivedPacketNum =\n      getAckState(conn, pnSpace).largestReceivedPacketNum;\n  largestReceivedPacketNum = std::max<PacketNum>(\n      largestReceivedPacketNum.value_or(packetNum), packetNum);\n}\n\nvoid onServerClose(QuicServerConnectionState& conn) {\n  switch (conn.state) {\n    case ServerState::Open:\n      onServerCloseOpenState(conn);\n      return;\n    case ServerState::Closed:\n      return;\n  }\n}\n\nvoid onServerCloseOpenState(QuicServerConnectionState& conn) {\n  conn.state = ServerState::Closed;\n}\n\nfolly::Optional<ConnectionIdData>\nQuicServerConnectionState::createAndAddNewSelfConnId() {\n  // Should be set right after server transport construction.\n  CHECK(connIdAlgo);\n  CHECK(serverConnIdParams);\n\n  CHECK(transportSettings.statelessResetTokenSecret);\n\n  StatelessResetGenerator generator(\n      transportSettings.statelessResetTokenSecret.value(),\n      serverAddr.getFullyQualified());\n\n  // TODO Possibly change this mechanism later\n  // The default connectionId algo has 36 bits of randomness.\n  auto encodedCid = connIdAlgo->encodeConnectionId(*serverConnIdParams);\n  size_t encodedTimes = 0;\n  while (encodedCid && connIdRejector &&\n         connIdRejector->rejectConnectionId(*encodedCid) &&\n         ++encodedTimes < kConnIdEncodingRetryLimit) {\n    encodedCid = connIdAlgo->encodeConnectionId(*serverConnIdParams);\n  }\n  LOG_IF(ERROR, encodedTimes == kConnIdEncodingRetryLimit)\n      << \"Quic CIDRejector rejected all conneectionIDs\";\n  if (encodedCid.hasError()) {\n    return folly::none;\n  }\n  auto newConnIdData =\n      ConnectionIdData{*encodedCid, nextSelfConnectionIdSequence++};\n  newConnIdData.token = generator.generateToken(newConnIdData.connId);\n  selfConnectionIds.push_back(newConnIdData);\n  return newConnIdData;\n}\n\n} // namespace quic\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n#include <quic/server/QuicServerTransport.h>\n\n#include <gmock/gmock.h>\n#include <gtest/gtest.h>\n\n#include <quic/api/QuicTransportFunctions.h>\n#include <quic/api/test/Mocks.h>\n#include <quic/codec/DefaultConnectionIdAlgo.h>\n#include <quic/codec/QuicPacketBuilder.h>\n#include <quic/codec/Types.h>\n#include <quic/common/test/TestUtils.h>\n#include <quic/congestion_control/ServerCongestionControllerFactory.h>\n#include <quic/fizz/handshake/FizzCryptoFactory.h>\n#include <quic/fizz/server/handshake/FizzServerHandshake.h>\n#include <quic/fizz/server/handshake/FizzServerQuicHandshakeContext.h>\n#include <quic/logging/FileQLogger.h>\n#include <quic/server/handshake/ServerHandshake.h>\n#include <quic/server/test/Mocks.h>\n#include <quic/state/QuicStreamFunctions.h>\n#include <quic/state/test/MockQuicStats.h>\n\n#include <folly/io/async/test/MockAsyncUDPSocket.h>\n\nusing namespace testing;\nusing namespace folly;\n\nnamespace quic {\nnamespace test {\n\nnamespace {\nusing ByteEvent = QuicTransportBase::ByteEvent;\nusing PacketDropReason = QuicTransportStatsCallback::PacketDropReason;\n} // namespace\n\nclass FakeServerHandshake : public FizzServerHandshake {\n public:\n  explicit FakeServerHandshake(\n      QuicServerConnectionState& conn,\n      std::shared_ptr<FizzServerQuicHandshakeContext> fizzContext,\n      bool chloSync = false,\n      bool cfinSync = false,\n      folly::Optional<uint64_t> clientActiveConnectionIdLimit = folly::none)\n      : FizzServerHandshake(&conn, std::move(fizzContext)),\n        conn_(conn),\n        chloSync_(chloSync),\n        cfinSync_(cfinSync),\n        clientActiveConnectionIdLimit_(clientActiveConnectionIdLimit) {}\n\n  void accept(std::shared_ptr<ServerTransportParametersExtension>) override {}\n\n  MOCK_METHOD1(writeNewSessionTicket, void(const AppToken&));\n\n  void doHandshake(std::unique_ptr<IOBuf> data, EncryptionLevel) override {\n    IOBufEqualTo eq;\n    auto chlo = folly::IOBuf::copyBuffer(\"CHLO\");\n    auto clientFinished = IOBuf::copyBuffer(\"FINISHED\");\n    if (eq(data, chlo)) {\n      if (chloSync_) {\n        // Do NOT invoke onCryptoEventAvailable callback\n        // Fall through and let the ServerStateMachine to process the event\n        writeDataToQuicStream(\n            *getCryptoStream(*conn_.cryptoState, EncryptionLevel::Initial),\n            IOBuf::copyBuffer(\"SHLO\"));\n        if (allowZeroRttKeys_) {\n          validateAndUpdateSourceToken(conn_, sourceAddrs_);\n          phase_ = Phase::KeysDerived;\n          setEarlyKeys();\n        }\n        setHandshakeKeys();\n      } else {\n        // Asynchronously schedule the callback\n        executor_->add([&] {\n          writeDataToQuicStream(\n              *getCryptoStream(*conn_.cryptoState, EncryptionLevel::Initial),\n              IOBuf::copyBuffer(\"SHLO\"));\n          if (allowZeroRttKeys_) {\n            validateAndUpdateSourceToken(conn_, sourceAddrs_);\n            phase_ = Phase::KeysDerived;\n            setEarlyKeys();\n          }\n          setHandshakeKeys();\n          if (callback_) {\n            callback_->onCryptoEventAvailable();\n          }\n        });\n      }\n    } else if (eq(data, clientFinished)) {\n      if (cfinSync_) {\n        // Do NOT invoke onCryptoEventAvailable callback\n        // Fall through and let the ServerStateMachine to process the event\n        setOneRttKeys();\n        phase_ = Phase::Established;\n        handshakeDone_ = true;\n      } else {\n        // Asynchronously schedule the callback\n        executor_->add([&] {\n          setOneRttKeys();\n          phase_ = Phase::Established;\n          handshakeDone_ = true;\n          if (callback_) {\n            callback_->onCryptoEventAvailable();\n          }\n        });\n      }\n    }\n  }\n\n  folly::Optional<ClientTransportParameters> getClientTransportParams()\n      override {\n    std::vector<TransportParameter> transportParams;\n    transportParams.push_back(encodeIntegerParameter(\n        TransportParameterId::initial_max_stream_data_bidi_local,\n        kDefaultStreamWindowSize));\n    transportParams.push_back(encodeIntegerParameter(\n        TransportParameterId::initial_max_stream_data_bidi_remote,\n        kDefaultStreamWindowSize));\n    transportParams.push_back(encodeIntegerParameter(\n        TransportParameterId::initial_max_stream_data_uni,\n        kDefaultStreamWindowSize));\n    transportParams.push_back(encodeIntegerParameter(\n        TransportParameterId::initial_max_streams_bidi,\n        kDefaultMaxStreamsBidirectional));\n    transportParams.push_back(encodeIntegerParameter(\n        TransportParameterId::initial_max_streams_uni,\n        kDefaultMaxStreamsUnidirectional));\n    transportParams.push_back(encodeIntegerParameter(\n        TransportParameterId::initial_max_data, kDefaultConnectionWindowSize));\n    transportParams.push_back(encodeIntegerParameter(\n        TransportParameterId::idle_timeout, kDefaultIdleTimeout.count()));\n    transportParams.push_back(encodeIntegerParameter(\n        TransportParameterId::max_packet_size, maxRecvPacketSize));\n    if (clientActiveConnectionIdLimit_) {\n      transportParams.push_back(encodeIntegerParameter(\n          TransportParameterId::active_connection_id_limit,\n          *clientActiveConnectionIdLimit_));\n    }\n    transportParams.push_back(encodeConnIdParameter(\n        TransportParameterId::initial_source_connection_id,\n        getTestConnectionId()));\n\n    return ClientTransportParameters{std::move(transportParams)};\n  }\n\n  void setEarlyKeys() {\n    oneRttWriteCipher_ = createNoOpAead();\n    oneRttWriteHeaderCipher_ = createNoOpHeaderCipher();\n    zeroRttReadCipher_ = createNoOpAead();\n    zeroRttReadHeaderCipher_ = createNoOpHeaderCipher();\n  }\n\n  void setOneRttKeys() {\n    // Mimic ServerHandshake behavior.\n    // oneRttWriteCipher would already be set during ReportEarlyHandshakeSuccess\n    if (!allowZeroRttKeys_) {\n      oneRttWriteCipher_ = createNoOpAead();\n      oneRttWriteHeaderCipher_ = createNoOpHeaderCipher();\n    }\n    oneRttReadCipher_ = createNoOpAead();\n    oneRttReadHeaderCipher_ = createNoOpHeaderCipher();\n  }\n\n  void setHandshakeKeys() {\n    conn_.handshakeWriteCipher = createNoOpAead();\n    conn_.handshakeWriteHeaderCipher = createNoOpHeaderCipher();\n    handshakeReadCipher_ = createNoOpAead();\n    handshakeReadHeaderCipher_ = createNoOpHeaderCipher();\n  }\n\n  void setHandshakeDone(bool done) {\n    handshakeDone_ = done;\n  }\n\n  void allowZeroRttKeys() {\n    allowZeroRttKeys_ = true;\n  }\n\n  void setSourceTokens(std::vector<folly::IPAddress> srcAddrs) {\n    sourceAddrs_ = srcAddrs;\n  }\n\n  QuicServerConnectionState& conn_;\n  bool chloSync_{false};\n  bool cfinSync_{false};\n  uint64_t maxRecvPacketSize{kDefaultMaxUDPPayload};\n  bool allowZeroRttKeys_{false};\n  std::vector<folly::IPAddress> sourceAddrs_;\n  folly::Optional<uint64_t> clientActiveConnectionIdLimit_;\n};\n\nbool verifyFramePresent(\n    std::vector<std::unique_ptr<folly::IOBuf>>& socketWrites,\n    QuicReadCodec& readCodec,\n    QuicFrame::Type frameType) {\n  AckStates ackStates;\n  for (auto& write : socketWrites) {\n    auto packetQueue = bufToQueue(write->clone());\n    auto result = readCodec.parsePacket(packetQueue, ackStates);\n    auto regularPacket = result.regularPacket();\n    if (!regularPacket) {\n      continue;\n    }\n    for (FOLLY_MAYBE_UNUSED auto& frame : regularPacket->frames) {\n      if (frame.type() != frameType) {\n        continue;\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\nstruct MigrationParam {\n  folly::Optional<uint64_t> clientSentActiveConnIdTransportParam;\n};\n\nclass TestingQuicServerTransport : public QuicServerTransport {\n public:\n  TestingQuicServerTransport(\n      folly::EventBase* evb,\n      std::unique_ptr<folly::AsyncUDPSocket> sock,\n      ConnectionCallback& cb,\n      std::shared_ptr<const fizz::server::FizzServerContext> ctx)\n      : QuicServerTransport(evb, std::move(sock), cb, ctx) {}\n\n  const QuicServerConnectionState& getConn() const {\n    return *dynamic_cast<QuicServerConnectionState*>(conn_.get());\n  }\n\n  QuicServerConnectionState& getNonConstConn() {\n    return *dynamic_cast<QuicServerConnectionState*>(conn_.get());\n  }\n\n  AsyncUDPSocket& getSocket() {\n    return *socket_;\n  }\n\n  auto& idleTimeout() {\n    return idleTimeout_;\n  }\n\n  auto& drainTimeout() {\n    return drainTimeout_;\n  }\n\n  auto& ackTimeout() {\n    return ackTimeout_;\n  }\n\n  auto& lossTimeout() {\n    return lossTimeout_;\n  }\n\n  auto& pathValidationTimeout() {\n    return pathValidationTimeout_;\n  }\n\n  bool isClosed() {\n    return closeState_ == CloseState::CLOSED;\n  }\n\n  bool isDraining() {\n    return drainTimeout_.isScheduled();\n  }\n\n  void triggerCryptoEvent() {\n    onCryptoEventAvailable();\n  }\n\n  auto& writeLooper() {\n    return writeLooper_;\n  }\n\n  auto& readLooper() {\n    return readLooper_;\n  }\n\n  void registerKnobParamHandler(\n      uint64_t paramId,\n      std::function<void(QuicServerConnectionState*, uint64_t)>&& handler) {\n    registerTransportKnobParamHandler(paramId, std::move(handler));\n  }\n\n  void handleKnobParams(const TransportKnobParams& params) {\n    handleTransportKnobParams(params);\n  }\n};\n\nclass QuicServerTransportTest : public Test {\n public:\n  void SetUp() override {\n    clientAddr = folly::SocketAddress(\"127.0.0.1\", 1000);\n    serverAddr = folly::SocketAddress(\"1.2.3.4\", 8080);\n    clientConnectionId = getTestConnectionId();\n    initialDestinationConnectionId = clientConnectionId;\n    // change the initialDestinationConnectionId to be different\n    // to suss out bugs.\n    initialDestinationConnectionId->data()[0] ^= 0x1;\n    // set server chosen connId with processId = 0 and workerId = 1\n    ServerConnectionIdParams params(0, 0, 1);\n    auto sock =\n        std::make_unique<NiceMock<folly::test::MockAsyncUDPSocket>>(&evb);\n    socket = sock.get();\n    EXPECT_CALL(*sock, write(_, _))\n        .WillRepeatedly(Invoke([&](const SocketAddress&,\n                                   const std::unique_ptr<folly::IOBuf>& buf) {\n          serverWrites.push_back(buf->clone());\n          return buf->computeChainDataLength();\n        }));\n    EXPECT_CALL(*sock, address()).WillRepeatedly(ReturnRef(serverAddr));\n    supportedVersions = {QuicVersion::MVFST, QuicVersion::QUIC_DRAFT};\n    serverCtx = createServerCtx();\n    connIdAlgo_ = std::make_unique<DefaultConnectionIdAlgo>();\n    ccFactory_ = std::make_shared<ServerCongestionControllerFactory>();\n    server = std::make_shared<TestingQuicServerTransport>(\n        &evb, std::move(sock), connCallback, serverCtx);\n    server->setCongestionControllerFactory(ccFactory_);\n    server->setCongestionControl(CongestionControlType::Cubic);\n    server->setRoutingCallback(&routingCallback);\n    server->setSupportedVersions(supportedVersions);\n    server->setOriginalPeerAddress(clientAddr);\n    server->setServerConnectionIdParams(params);\n    server->getNonConstConn().transportSettings.statelessResetTokenSecret =\n        getRandSecret();\n    transportInfoCb_ = std::make_unique<NiceMock<MockQuicStats>>();\n    server->setTransportStatsCallback(transportInfoCb_.get());\n    initializeServerHandshake();\n    server->getNonConstConn().handshakeLayer.reset(fakeHandshake);\n    server->getNonConstConn().serverHandshakeLayer = fakeHandshake;\n    // Allow ignoring path mtu for testing negotiation.\n    server->getNonConstConn().transportSettings.canIgnorePathMTU =\n        getCanIgnorePathMTU();\n    server->getNonConstConn().transportSettings.disableMigration =\n        getDisableMigration();\n    server->setConnectionIdAlgo(connIdAlgo_.get());\n    server->setClientConnectionId(*clientConnectionId);\n    server->setClientChosenDestConnectionId(*initialDestinationConnectionId);\n    VLOG(20) << __func__ << \" client connId=\" << clientConnectionId->hex()\n             << \", server connId=\"\n             << (server->getConn().serverConnectionId\n                     ? server->getConn().serverConnectionId->hex()\n                     : \" (n/a)\");\n    server->accept();\n    setupConnection();\n    EXPECT_TRUE(server->idleTimeout().isScheduled());\n    EXPECT_EQ(server->getConn().peerConnectionIds.size(), 1);\n    EXPECT_EQ(\n        *server->getConn().clientConnectionId,\n        server->getConn().peerConnectionIds[0].connId);\n  }\n\n  std::shared_ptr<FizzServerQuicHandshakeContext> getFizzServerContext() {\n    if (!fizzServerContext) {\n      fizzServerContext = FizzServerQuicHandshakeContext::Builder()\n                              .setFizzServerContext(createServerCtx())\n                              .build();\n    }\n\n    return fizzServerContext;\n  }\n\n  virtual void initializeServerHandshake() {\n    fakeHandshake = new FakeServerHandshake(\n        server->getNonConstConn(), getFizzServerContext());\n  }\n\n  virtual bool getDisableMigration() {\n    return true;\n  }\n\n  virtual bool getCanIgnorePathMTU() {\n    return true;\n  }\n\n  std::unique_ptr<Aead> getInitialCipher(\n      QuicVersion version = QuicVersion::MVFST) {\n    FizzCryptoFactory cryptoFactory;\n    return cryptoFactory.getClientInitialCipher(\n        *initialDestinationConnectionId, version);\n  }\n\n  std::unique_ptr<PacketNumberCipher> getInitialHeaderCipher(\n      QuicVersion version = QuicVersion::MVFST) {\n    FizzCryptoFactory cryptoFactory;\n    return cryptoFactory.makeClientInitialHeaderCipher(\n        *initialDestinationConnectionId, version);\n  }\n\n  Buf recvEncryptedStream(\n      StreamId streamId,\n      folly::IOBuf& data,\n      uint64_t offset = 0,\n      bool eof = false) {\n    PacketNum packetNum = clientNextAppDataPacketNum++;\n    auto packetData = packetToBuf(createStreamPacket(\n        clientConnectionId.value_or(getTestConnectionId()),\n        *server->getConn().serverConnectionId,\n        packetNum,\n        streamId,\n        data,\n        0 /* cipherOverhead */,\n        0 /* largestAcked */,\n        folly::none /* longHeaderOverride */,\n        eof,\n        folly::none,\n        offset));\n    deliverData(packetData->clone());\n    return packetData;\n  }\n\n  void recvClientHello(\n      bool writes = true,\n      QuicVersion version = QuicVersion::MVFST) {\n    auto chlo = IOBuf::copyBuffer(\"CHLO\");\n    auto nextPacketNum = clientNextInitialPacketNum++;\n    auto aead = getInitialCipher(version);\n    auto headerCipher = getInitialHeaderCipher(version);\n    auto initialPacket = packetToBufCleartext(\n        createInitialCryptoPacket(\n            *clientConnectionId,\n            *initialDestinationConnectionId,\n            nextPacketNum,\n            version,\n            *chlo,\n            *aead,\n            0 /* largestAcked */),\n        *aead,\n        *headerCipher,\n        nextPacketNum);\n    deliverData(initialPacket->clone(), writes);\n  }\n\n  void recvClientFinished(\n      bool writes = true,\n      folly::SocketAddress* peerAddress = nullptr,\n      QuicVersion version = QuicVersion::MVFST) {\n    auto finished = IOBuf::copyBuffer(\"FINISHED\");\n    auto nextPacketNum = clientNextHandshakePacketNum++;\n    auto headerCipher = test::createNoOpHeaderCipher();\n    uint64_t offset =\n        getCryptoStream(\n            *server->getConn().cryptoState, EncryptionLevel::Handshake)\n            ->currentReadOffset;\n    auto handshakeCipher = test::createNoOpAead();\n    auto finishedPacket = packetToBufCleartext(\n        createCryptoPacket(\n            *clientConnectionId,\n            *server->getConn().serverConnectionId,\n            nextPacketNum,\n            version,\n            ProtectionType::Handshake,\n            *finished,\n            *handshakeCipher,\n            0 /* largestAcked */,\n            offset),\n        *handshakeCipher,\n        *headerCipher,\n        nextPacketNum);\n    deliverData(finishedPacket->clone(), writes, peerAddress);\n  }\n\n  virtual void setupClientReadCodec() {\n    FizzCryptoFactory cryptoFactory;\n    clientReadCodec = std::make_unique<QuicReadCodec>(QuicNodeType::Client);\n    clientReadCodec->setClientConnectionId(*clientConnectionId);\n    clientReadCodec->setInitialReadCipher(cryptoFactory.getServerInitialCipher(\n        *initialDestinationConnectionId, QuicVersion::MVFST));\n    clientReadCodec->setInitialHeaderCipher(\n        cryptoFactory.makeServerInitialHeaderCipher(\n            *initialDestinationConnectionId, QuicVersion::MVFST));\n    clientReadCodec->setCodecParameters(\n        CodecParameters(kDefaultAckDelayExponent, QuicVersion::MVFST));\n  }\n\n  virtual void expectWriteNewSessionTicket() {\n    server->setEarlyDataAppParamsFunctions(\n        [](const folly::Optional<std::string>&, const Buf&) { return false; },\n        []() -> Buf {\n          // This function shouldn't be called\n          EXPECT_TRUE(false);\n          return nullptr;\n        });\n    EXPECT_CALL(*getFakeHandshakeLayer(), writeNewSessionTicket(_)).Times(0);\n  }\n\n  virtual void setupConnection() {\n    EXPECT_EQ(server->getConn().readCodec, nullptr);\n    EXPECT_EQ(server->getConn().statsCallback, transportInfoCb_.get());\n    setupClientReadCodec();\n    recvClientHello();\n\n    IOBufEqualTo eq;\n    EXPECT_TRUE(eq(getCryptoStreamData(), IOBuf::copyBuffer(\"SHLO\")));\n    serverWrites.clear();\n\n    EXPECT_NE(server->getConn().readCodec, nullptr);\n    EXPECT_NE(server->getConn().initialWriteCipher, nullptr);\n    EXPECT_NE(server->getConn().initialHeaderCipher, nullptr);\n    EXPECT_NE(server->getConn().handshakeWriteCipher, nullptr);\n    EXPECT_NE(server->getConn().handshakeWriteHeaderCipher, nullptr);\n    EXPECT_NE(server->getConn().readCodec->getHandshakeHeaderCipher(), nullptr);\n\n    EXPECT_FALSE(server->getConn().localConnectionError.has_value());\n    EXPECT_EQ(server->getConn().version, QuicVersion::MVFST);\n    EXPECT_EQ(server->getConn().serverConnIdParams->processId, 0);\n    EXPECT_EQ(server->getConn().serverConnIdParams->workerId, 1);\n    EXPECT_TRUE(server->getConn().serverConnectionId.has_value());\n    EXPECT_EQ(server->getConn().selfConnectionIds.size(), 1);\n    serverConnectionId = *server->getConn().serverConnectionId;\n    EXPECT_EQ(\n        server->getConn().selfConnectionIds[0].connId, serverConnectionId);\n    // the crypto data should have been written in the previous loop, verify\n    // that the write loop callback is not scheduled any more since we don't\n    // have keys to write acks. This assumes that we will schedule crypto data\n    // as soon as we can.\n    EXPECT_FALSE(server->writeLooper()->isLoopCallbackScheduled());\n    EXPECT_FALSE(server->readLooper()->isLoopCallbackScheduled());\n\n    expectWriteNewSessionTicket();\n    // Once oneRtt keys are available, ServerTransport must call the\n    // onConnectionIdBound on its 'routingCallback'\n    EXPECT_CALL(routingCallback, onConnectionIdBound(_))\n        .WillOnce(Invoke([&, clientAddr = clientAddr](auto transport) {\n          EXPECT_EQ(clientAddr, transport->getOriginalPeerAddress());\n        }));\n\n    EXPECT_TRUE(server->getConn().pendingEvents.frames.empty());\n    EXPECT_EQ(server->getConn().nextSelfConnectionIdSequence, 1);\n    recvClientFinished();\n\n    // We need an extra pump here for some reason.\n    loopForWrites();\n\n    // Issue (kMinNumAvailableConnIds - 1) more connection ids on handshake\n    // complete\n    auto numNewConnIdFrames = 0;\n    for (const auto& packet : server->getConn().outstandings.packets) {\n      for (const auto& frame : packet.packet.frames) {\n        switch (frame.type()) {\n          case QuicWriteFrame::Type::QuicSimpleFrame: {\n            const auto writeFrame = frame.asQuicSimpleFrame();\n            if (writeFrame->type() ==\n                QuicSimpleFrame::Type::NewConnectionIdFrame) {\n              ++numNewConnIdFrames;\n            }\n            break;\n          }\n          default:\n            break;\n        }\n      }\n    }\n    uint64_t connIdsToIssue = std::min(\n                                  server->getConn().peerActiveConnectionIdLimit,\n                                  kDefaultActiveConnectionIdLimit) -\n        1;\n\n    if (server->getConn().transportSettings.disableMigration ||\n        (connIdsToIssue == 0)) {\n      EXPECT_EQ(numNewConnIdFrames, 0);\n      EXPECT_EQ(server->getConn().nextSelfConnectionIdSequence, 1);\n    } else {\n      EXPECT_EQ(numNewConnIdFrames, connIdsToIssue);\n      EXPECT_EQ(\n          server->getConn().nextSelfConnectionIdSequence, connIdsToIssue + 1);\n    }\n\n    EXPECT_NE(server->getConn().readCodec, nullptr);\n    EXPECT_NE(server->getConn().oneRttWriteCipher, nullptr);\n    EXPECT_NE(server->getConn().oneRttWriteHeaderCipher, nullptr);\n    EXPECT_NE(server->getConn().readCodec->getOneRttHeaderCipher(), nullptr);\n\n    EXPECT_TRUE(getCryptoStream(\n                    *server->getConn().cryptoState, EncryptionLevel::Initial)\n                    ->readBuffer.empty());\n    EXPECT_FALSE(server->getConn().localConnectionError.has_value());\n    verifyTransportParameters(kDefaultIdleTimeout);\n    serverWrites.clear();\n\n    auto& cryptoState = server->getConn().cryptoState;\n    EXPECT_EQ(cryptoState->handshakeStream.retransmissionBuffer.size(), 0);\n    EXPECT_EQ(cryptoState->oneRttStream.retransmissionBuffer.size(), 0);\n  }\n\n  void verifyTransportParameters(std::chrono::milliseconds idleTimeout) {\n    EXPECT_EQ(server->getConn().peerIdleTimeout, idleTimeout);\n    if (getCanIgnorePathMTU()) {\n      EXPECT_EQ(\n          server->getConn().udpSendPacketLen, fakeHandshake->maxRecvPacketSize);\n    }\n  }\n\n  void deliverDataWithoutErrorCheck(\n      Buf data,\n      bool writes = true,\n      folly::SocketAddress* peer = nullptr) {\n    data->coalesce();\n    server->onNetworkData(\n        peer == nullptr ? clientAddr : *peer,\n        NetworkData(std::move(data), Clock::now()));\n    if (writes) {\n      loopForWrites();\n    }\n  }\n\n  void deliverData(\n      Buf data,\n      bool writes = true,\n      folly::SocketAddress* peer = nullptr) {\n    deliverDataWithoutErrorCheck(std::move(data), writes, peer);\n    if (server->getConn().localConnectionError) {\n      bool idleTimeout = false;\n      const LocalErrorCode* localError =\n          server->getConn().localConnectionError->first.asLocalErrorCode();\n      if (localError) {\n        idleTimeout = (*localError == LocalErrorCode::IDLE_TIMEOUT);\n      }\n      if (!idleTimeout) {\n        throw std::runtime_error(\n            toString(server->getConn().localConnectionError->first));\n      }\n    }\n  }\n\n  void loopForWrites() {\n    evb.loopOnce(EVLOOP_NONBLOCK);\n  }\n\n  Buf getCryptoStreamData() {\n    CHECK(!serverWrites.empty());\n    auto cryptoBuf = IOBuf::create(0);\n    AckStates ackStates;\n    for (auto& serverWrite : serverWrites) {\n      auto packetQueue = bufToQueue(serverWrite->clone());\n      auto result = clientReadCodec->parsePacket(packetQueue, ackStates);\n      auto& parsedPacket = *result.regularPacket();\n      for (auto& frame : parsedPacket.frames) {\n        if (frame.type() != QuicFrame::Type::ReadCryptoFrame) {\n          continue;\n        }\n        cryptoBuf->prependChain(frame.asReadCryptoFrame()->data->clone());\n      }\n    }\n    return cryptoBuf;\n  }\n\n  std::unique_ptr<QuicReadCodec> makeClientEncryptedCodec(\n      bool handshakeCipher = false) {\n    FizzCryptoFactory cryptoFactory;\n    auto readCodec = std::make_unique<QuicReadCodec>(QuicNodeType::Client);\n    readCodec->setOneRttReadCipher(test::createNoOpAead());\n    readCodec->setOneRttHeaderCipher(test::createNoOpHeaderCipher());\n    readCodec->setHandshakeReadCipher(test::createNoOpAead());\n    readCodec->setHandshakeHeaderCipher(test::createNoOpHeaderCipher());\n    readCodec->setClientConnectionId(*clientConnectionId);\n    readCodec->setCodecParameters(\n        CodecParameters(kDefaultAckDelayExponent, QuicVersion::MVFST));\n    if (handshakeCipher) {\n      readCodec->setInitialReadCipher(cryptoFactory.getServerInitialCipher(\n          *initialDestinationConnectionId, QuicVersion::MVFST));\n      readCodec->setInitialHeaderCipher(\n          cryptoFactory.makeServerInitialHeaderCipher(\n              *initialDestinationConnectionId, QuicVersion::MVFST));\n    }\n    return readCodec;\n  }\n\n  FakeServerHandshake* getFakeHandshakeLayer() {\n    return CHECK_NOTNULL(dynamic_cast<FakeServerHandshake*>(\n        server->getNonConstConn().handshakeLayer.get()));\n  }\n\n  void checkTransportStateUpdate(\n      const std::shared_ptr<FileQLogger>& qLogger,\n      const std::string& msg) {\n    std::vector<int> indices =\n        getQLogEventIndices(QLogEventType::TransportStateUpdate, qLogger);\n    EXPECT_EQ(indices.size(), 1);\n    auto tmp = std::move(qLogger->logs[indices[0]]);\n    auto event = dynamic_cast<QLogTransportStateUpdateEvent*>(tmp.get());\n    EXPECT_EQ(event->update, getPeerClose(msg));\n  }\n\n  EventBase evb;\n  SocketAddress serverAddr;\n  SocketAddress clientAddr;\n  NiceMock<MockConnectionCallback> connCallback;\n  NiceMock<MockRoutingCallback> routingCallback;\n  folly::Optional<ConnectionId> clientConnectionId;\n  folly::Optional<ConnectionId> initialDestinationConnectionId;\n  folly::Optional<ConnectionId> serverConnectionId;\n  std::unique_ptr<QuicReadCodec> clientReadCodec;\n  std::vector<Buf> serverWrites;\n  std::shared_ptr<fizz::server::FizzServerContext> serverCtx;\n\n  std::vector<QuicVersion> supportedVersions;\n  std::unique_ptr<MockQuicStats> transportInfoCb_;\n  std::unique_ptr<ConnectionIdAlgo> connIdAlgo_;\n  std::shared_ptr<CongestionControllerFactory> ccFactory_;\n  std::shared_ptr<TestingQuicServerTransport> server;\n  folly::test::MockAsyncUDPSocket* socket;\n  FakeServerHandshake* fakeHandshake{nullptr};\n  std::shared_ptr<FizzServerQuicHandshakeContext> fizzServerContext;\n  PacketNum clientNextInitialPacketNum{0}, clientNextHandshakePacketNum{0},\n      clientNextAppDataPacketNum{0};\n};\n\nTEST_F(QuicServerTransportTest, TestReadMultipleStreams) {\n  PacketNum clientPacketNum = clientNextAppDataPacketNum++;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientPacketNum);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n\n  auto buf1 = IOBuf::copyBuffer(\"Aloha\");\n  auto buf2 = IOBuf::copyBuffer(\"Hello\");\n\n  auto dataLen = writeStreamFrameHeader(\n      builder,\n      0x08,\n      0,\n      buf1->computeChainDataLength(),\n      buf1->computeChainDataLength(),\n      true,\n      folly::none /* skipLenHint */);\n  ASSERT_TRUE(dataLen);\n  ASSERT_EQ(*dataLen, buf1->computeChainDataLength());\n  writeStreamFrameData(builder, buf1->clone(), buf1->computeChainDataLength());\n\n  dataLen = writeStreamFrameHeader(\n      builder,\n      0x0C,\n      0,\n      buf1->computeChainDataLength(),\n      buf1->computeChainDataLength(),\n      true,\n      folly::none /* skipLenHint */);\n  ASSERT_TRUE(dataLen);\n  ASSERT_EQ(*dataLen, buf1->computeChainDataLength());\n  writeStreamFrameData(builder, buf2->clone(), buf2->computeChainDataLength());\n\n  auto packet = std::move(builder).buildPacket();\n\n  // Clear out the existing acks to make sure that we are the cause of the acks.\n  server->getNonConstConn().ackStates.initialAckState.acks.clear();\n  server->getNonConstConn().ackStates.initialAckState.largestRecvdPacketTime =\n      folly::none;\n  server->getNonConstConn().ackStates.handshakeAckState.acks.clear();\n  server->getNonConstConn().ackStates.handshakeAckState.largestRecvdPacketTime =\n      folly::none;\n  server->getNonConstConn().ackStates.appDataAckState.acks.clear();\n  server->getNonConstConn().ackStates.appDataAckState.largestRecvdPacketTime =\n      folly::none;\n\n  EXPECT_CALL(*transportInfoCb_, onNewQuicStream()).Times(2); // for x08, x0C\n  deliverData(packetToBuf(packet));\n\n  EXPECT_TRUE(\n      server->getConn()\n          .ackStates.appDataAckState.largestRecvdPacketTime.has_value());\n  EXPECT_EQ(server->getConn().ackStates.appDataAckState.acks.size(), 1);\n  EXPECT_EQ(\n      server->getConn().ackStates.appDataAckState.acks.front().start,\n      clientPacketNum);\n  EXPECT_EQ(\n      server->getConn().ackStates.appDataAckState.acks.front().end,\n      clientPacketNum);\n  ASSERT_EQ(server->getConn().streamManager->streamCount(), 2);\n  IOBufEqualTo eq;\n\n  auto stream = server->getNonConstConn().streamManager->findStream(0x08);\n  ASSERT_TRUE(stream);\n  auto streamData = readDataFromQuicStream(*stream);\n  EXPECT_TRUE(eq(buf1, streamData.first));\n  EXPECT_TRUE(streamData.second);\n\n  auto stream2 = server->getNonConstConn().streamManager->findStream(0x0C);\n  ASSERT_TRUE(stream2);\n  auto streamData2 = readDataFromQuicStream(*stream2);\n  EXPECT_TRUE(eq(buf2, streamData2.first));\n  EXPECT_TRUE(streamData2.second);\n  EXPECT_CALL(*transportInfoCb_, onQuicStreamClosed()).Times(2);\n}\n\nTEST_F(QuicServerTransportTest, TestInvalidServerStream) {\n  EXPECT_CALL(*transportInfoCb_, onNewQuicStream()).Times(0);\n  StreamId streamId = 0x01;\n  auto data = IOBuf::copyBuffer(\"Aloha\");\n  EXPECT_THROW(recvEncryptedStream(streamId, *data), std::runtime_error);\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAckled */));\n  EXPECT_THROW(deliverData(std::move(packetData)), std::runtime_error);\n  ASSERT_EQ(server->getConn().streamManager->streamCount(), 0);\n}\n\nTEST_F(QuicServerTransportTest, IdleTimerResetOnRecvNewData) {\n  EXPECT_CALL(*transportInfoCb_, onNewQuicStream()).Times(1);\n  StreamId streamId = server->createBidirectionalStream().value();\n  auto expected = IOBuf::copyBuffer(\"hello\");\n  auto packet = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId,\n      *expected,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  server->idleTimeout().cancelTimeout();\n  ASSERT_FALSE(server->idleTimeout().isScheduled());\n  recvEncryptedStream(streamId, *expected);\n  ASSERT_TRUE(server->idleTimeout().isScheduled());\n  EXPECT_CALL(*transportInfoCb_, onQuicStreamClosed());\n}\n\nTEST_F(QuicServerTransportTest, IdleTimerNotResetOnDuplicatePacket) {\n  EXPECT_CALL(*transportInfoCb_, onNewQuicStream()).Times(1);\n  StreamId streamId = server->createBidirectionalStream().value();\n\n  auto expected = IOBuf::copyBuffer(\"hello\");\n  auto packet = recvEncryptedStream(streamId, *expected);\n  ASSERT_TRUE(server->idleTimeout().isScheduled());\n\n  server->idleTimeout().cancelTimeout();\n  ASSERT_FALSE(server->idleTimeout().isScheduled());\n  // Try delivering the same packet again\n  deliverData(packet->clone(), false);\n  ASSERT_FALSE(server->idleTimeout().isScheduled());\n  EXPECT_CALL(*transportInfoCb_, onQuicStreamClosed());\n}\n\nTEST_F(QuicServerTransportTest, IdleTimerNotResetWhenDataOutstanding) {\n  // Clear the receivedNewPacketBeforeWrite flag, since we may reveice from\n  // client during the SetUp of the test case.\n  server->getNonConstConn().outstandings.packets.clear();\n  server->getNonConstConn().receivedNewPacketBeforeWrite = false;\n  server->getNonConstConn().outstandings.packets.clear();\n  StreamId streamId = server->createBidirectionalStream().value();\n\n  server->idleTimeout().cancelTimeout();\n  ASSERT_FALSE(server->idleTimeout().isScheduled());\n  server->writeChain(\n      streamId,\n      IOBuf::copyBuffer(\"And if the darkness is to keep us apart\"),\n      false);\n  loopForWrites();\n  // It was the first packet\n  EXPECT_TRUE(server->idleTimeout().isScheduled());\n\n  // cancel it and write something else. This time idle timer shouldn't set.\n  server->idleTimeout().cancelTimeout();\n  EXPECT_FALSE(server->idleTimeout().isScheduled());\n  server->writeChain(\n      streamId,\n      IOBuf::copyBuffer(\"And if the daylight feels like it's a long way off\"),\n      false);\n  loopForWrites();\n  EXPECT_FALSE(server->idleTimeout().isScheduled());\n}\n\nTEST_F(QuicServerTransportTest, TimeoutsNotSetAfterClose) {\n  StreamId streamId = server->createBidirectionalStream().value();\n\n  auto expected = IOBuf::copyBuffer(\"hello\");\n  auto packet = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId,\n      *expected,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n  server->close(std::make_pair(\n      QuicErrorCode(TransportErrorCode::INTERNAL_ERROR),\n      std::string(\"how about no\")));\n  server->idleTimeout().cancelTimeout();\n  ASSERT_FALSE(server->idleTimeout().isScheduled());\n\n  deliverDataWithoutErrorCheck(packet->clone());\n  ASSERT_FALSE(server->idleTimeout().isScheduled());\n  ASSERT_FALSE(server->lossTimeout().isScheduled());\n  ASSERT_FALSE(server->ackTimeout().isScheduled());\n  ASSERT_TRUE(server->drainTimeout().isScheduled());\n}\n\nTEST_F(QuicServerTransportTest, InvalidMigrationNoDrain) {\n  StreamId streamId = server->createBidirectionalStream().value();\n\n  auto expected = IOBuf::copyBuffer(\"hello\");\n  auto packet = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId,\n      *expected,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n  server->close(std::make_pair(\n      QuicErrorCode(TransportErrorCode::INVALID_MIGRATION),\n      std::string(\"migration disabled\")));\n  server->idleTimeout().cancelTimeout();\n  ASSERT_FALSE(server->idleTimeout().isScheduled());\n\n  deliverDataWithoutErrorCheck(packet->clone());\n  ASSERT_FALSE(server->idleTimeout().isScheduled());\n  ASSERT_FALSE(server->lossTimeout().isScheduled());\n  ASSERT_FALSE(server->ackTimeout().isScheduled());\n  ASSERT_FALSE(server->drainTimeout().isScheduled());\n}\n\nTEST_F(QuicServerTransportTest, IdleTimeoutExpired) {\n  server->idleTimeout().timeoutExpired();\n\n  EXPECT_FALSE(server->idleTimeout().isScheduled());\n  EXPECT_TRUE(server->isDraining());\n  EXPECT_TRUE(server->isClosed());\n  auto serverReadCodec = makeClientEncryptedCodec();\n  EXPECT_FALSE(verifyFramePresent(\n      serverWrites, *serverReadCodec, QuicFrame::Type::ConnectionCloseFrame));\n  EXPECT_FALSE(verifyFramePresent(\n      serverWrites, *serverReadCodec, QuicFrame::Type::ConnectionCloseFrame));\n}\n\nTEST_F(QuicServerTransportTest, RecvDataAfterIdleTimeout) {\n  server->idleTimeout().timeoutExpired();\n\n  EXPECT_FALSE(server->idleTimeout().isScheduled());\n  EXPECT_TRUE(server->isDraining());\n  EXPECT_TRUE(server->isClosed());\n\n  serverWrites.clear();\n  StreamId streamId = 11;\n  auto expected = IOBuf::copyBuffer(\"hello\");\n  recvEncryptedStream(streamId, *expected);\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(true),\n      QuicFrame::Type::ConnectionCloseFrame));\n}\n\nTEST_F(QuicServerTransportTest, TestCloseConnectionWithError) {\n  server->close(std::make_pair(\n      QuicErrorCode(GenericApplicationErrorCode::UNKNOWN),\n      std::string(\"stopping\")));\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n}\n\nTEST_F(QuicServerTransportTest, TestCloseConnectionWithNoError) {\n  server->close(std::make_pair(\n      QuicErrorCode(GenericApplicationErrorCode::UNKNOWN),\n      std::string(\"stopping\")));\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n}\n\nTEST_F(QuicServerTransportTest, TestClientAddressChanges) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n  StreamId streamId = 4;\n  clientAddr = folly::SocketAddress(\"127.0.0.1\", 2000);\n  auto data = IOBuf::copyBuffer(\"data\");\n  EXPECT_THROW(\n      recvEncryptedStream(streamId, *data, 0, true), std::runtime_error);\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n\n  std::vector<int> indices =\n      getQLogEventIndices(QLogEventType::PacketDrop, qLogger);\n  EXPECT_EQ(indices.size(), 1);\n  auto tmp = std::move(qLogger->logs[indices[0]]);\n  auto event = dynamic_cast<QLogPacketDropEvent*>(tmp.get());\n  EXPECT_EQ(event->packetSize, 29);\n  EXPECT_EQ(\n      event->dropReason,\n      QuicTransportStatsCallback::toString(\n          PacketDropReason::PEER_ADDRESS_CHANGE));\n}\n\nTEST_F(QuicServerTransportTest, TestCloseConnectionWithNoErrorPendingStreams) {\n  auto streamId = server->createBidirectionalStream().value();\n\n  server->writeChain(streamId, IOBuf::copyBuffer(\"hello\"), true);\n  loopForWrites();\n\n  AckBlocks acks;\n  auto start = getFirstOutstandingPacket(\n                   server->getNonConstConn(), PacketNumberSpace::AppData)\n                   ->packet.header.getPacketSequenceNum();\n  auto end = getLastOutstandingPacket(\n                 server->getNonConstConn(), PacketNumberSpace::AppData)\n                 ->packet.header.getPacketSequenceNum();\n  acks.insert(start, end);\n  deliverData(packetToBuf(createAckPacket(\n      server->getNonConstConn(),\n      ++clientNextAppDataPacketNum,\n      acks,\n      PacketNumberSpace::AppData)));\n  server->close(std::make_pair(\n      QuicErrorCode(GenericApplicationErrorCode::UNKNOWN),\n      std::string(\"stopping\")));\n\n  EXPECT_THROW(\n      recvEncryptedStream(streamId, *IOBuf::copyBuffer(\"hello\")),\n      std::runtime_error);\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n}\n\nTEST_F(QuicServerTransportTest, ReceivePacketAfterLocalError) {\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n\n  // Deliver a reset to non existent stream to trigger a local conn error\n  StreamId streamId = 0x01;\n  RstStreamFrame rstFrame(streamId, GenericApplicationErrorCode::UNKNOWN, 0);\n  writeFrame(std::move(rstFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  deliverDataWithoutErrorCheck(packetToBuf(packet));\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  serverWrites.clear();\n\n  ShortHeader header2(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder2(\n      server->getConn().udpSendPacketLen,\n      std::move(header2),\n      0 /* largestAcked */);\n  builder2.encodePacketHeader();\n  RstStreamFrame rstFrame2(streamId, GenericApplicationErrorCode::UNKNOWN, 0);\n  writeFrame(std::move(rstFrame2), builder2);\n  auto packet2 = std::move(builder2).buildPacket();\n  deliverDataWithoutErrorCheck(packetToBuf(packet2));\n  EXPECT_TRUE(hasNotReceivedNewPacketsSinceLastCloseSent(server->getConn()));\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n}\n\nTEST_F(QuicServerTransportTest, ReceiveCloseAfterLocalError) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n\n  // Deliver a reset to non existent stream to trigger a local conn error\n  StreamId streamId = 0x01;\n  RstStreamFrame rstFrame(streamId, GenericApplicationErrorCode::UNKNOWN, 0);\n  writeFrame(std::move(rstFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  deliverDataWithoutErrorCheck(packetToBuf(packet));\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  serverWrites.clear();\n\n  auto currLargestReceivedPacketNum =\n      server->getConn().ackStates.appDataAckState.largestReceivedPacketNum;\n  EXPECT_TRUE(hasNotReceivedNewPacketsSinceLastCloseSent(server->getConn()));\n\n  ShortHeader header2(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder2(\n      server->getConn().udpSendPacketLen,\n      std::move(header2),\n      0 /* largestAcked */);\n  builder2.encodePacketHeader();\n  std::string errMsg = \"Mind the gap\";\n  ConnectionCloseFrame connClose(\n      QuicErrorCode(TransportErrorCode::NO_ERROR), errMsg);\n  writeFrame(std::move(connClose), builder2);\n\n  auto packet2 = std::move(builder2).buildPacket();\n  deliverDataWithoutErrorCheck(packetToBuf(packet2));\n  EXPECT_FALSE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  EXPECT_GT(\n      server->getConn().ackStates.appDataAckState.largestReceivedPacketNum,\n      currLargestReceivedPacketNum);\n\n  // Deliver the same bad data again\n  EXPECT_CALL(*transportInfoCb_, onPacketDropped(_));\n  deliverDataWithoutErrorCheck(packetToBuf(packet));\n  EXPECT_LT(\n      server->getConn()\n          .ackStates.appDataAckState.largestReceivedAtLastCloseSent,\n      server->getConn().ackStates.appDataAckState.largestReceivedPacketNum);\n  EXPECT_FALSE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  checkTransportStateUpdate(\n      qLogger, \"Server closed by peer reason=Mind the gap\");\n}\n\nTEST_F(QuicServerTransportTest, NoDataExceptCloseProcessedAfterClosing) {\n  auto packetNum = clientNextAppDataPacketNum++;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      packetNum);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n\n  auto buf = folly::IOBuf::copyBuffer(\"hello\");\n  writeStreamFrameHeader(\n      builder,\n      4,\n      0,\n      buf->computeChainDataLength(),\n      buf->computeChainDataLength(),\n      true,\n      folly::none /* skipLenHint */);\n  writeStreamFrameData(builder, buf->clone(), buf->computeChainDataLength());\n  std::string errMsg = \"Mind the gap\";\n  ConnectionCloseFrame connClose(\n      QuicErrorCode(TransportErrorCode::NO_ERROR), errMsg);\n  writeFrame(std::move(connClose), builder);\n\n  auto packet = std::move(builder).buildPacket();\n\n  server->close(std::make_pair(\n      QuicErrorCode(GenericApplicationErrorCode::UNKNOWN),\n      std::string(\"hello\")));\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  EXPECT_TRUE(hasNotReceivedNewPacketsSinceLastCloseSent(server->getConn()));\n  serverWrites.clear();\n\n  // largestReceivedPacketNum won't be accurate because we will throw\n  // before updating the ack state.\n  deliverDataWithoutErrorCheck(packetToBuf(packet));\n  EXPECT_EQ(\n      server->getConn().ackStates.appDataAckState.largestReceivedPacketNum,\n      packetNum);\n  EXPECT_FALSE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  EXPECT_FALSE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n}\n\nTEST_F(QuicServerTransportTest, TestOpenAckStreamFrame) {\n  StreamId streamId = server->createBidirectionalStream().value();\n\n  auto data = IOBuf::copyBuffer(\"Aloha\");\n\n  // Remove any packets that might have been queued.\n  server->getNonConstConn().outstandings.packets.clear();\n  server->getNonConstConn().outstandings.initialPacketsCount = 0;\n  server->getNonConstConn().outstandings.handshakePacketsCount = 0;\n  server->writeChain(streamId, data->clone(), false);\n  loopForWrites();\n  server->writeChain(streamId, data->clone(), false);\n  server->writeChain(streamId, data->clone(), false);\n  loopForWrites();\n\n  auto stream = server->getNonConstConn().streamManager->getStream(streamId);\n  ASSERT_FALSE(server->getConn().outstandings.packets.empty());\n  ASSERT_FALSE(stream->retransmissionBuffer.empty());\n  // We need more than one packet for this test.\n  ASSERT_FALSE(server->getConn().outstandings.packets.empty());\n\n  PacketNum packetNum1 =\n      getFirstOutstandingPacket(\n          server->getNonConstConn(), PacketNumberSpace::AppData)\n          ->packet.header.getPacketSequenceNum();\n\n  PacketNum lastPacketNum =\n      getLastOutstandingPacket(\n          server->getNonConstConn(), PacketNumberSpace::AppData)\n          ->packet.header.getPacketSequenceNum();\n\n  uint32_t buffersInPacket1 = 0;\n  for (size_t i = 0; i < server->getNonConstConn().outstandings.packets.size();\n       ++i) {\n    auto& packet = server->getNonConstConn().outstandings.packets[i];\n    if (packet.packet.header.getPacketNumberSpace() !=\n        PacketNumberSpace::AppData) {\n      continue;\n    }\n    PacketNum currentPacket = packet.packet.header.getPacketSequenceNum();\n    ASSERT_FALSE(packet.packet.frames.empty());\n    for (auto& quicFrame : packet.packet.frames) {\n      auto frame = quicFrame.asWriteStreamFrame();\n      if (!frame) {\n        continue;\n      }\n      auto it = stream->retransmissionBuffer.find(frame->offset);\n      ASSERT_TRUE(it != stream->retransmissionBuffer.end());\n      if (currentPacket == packetNum1 && frame->streamId == streamId) {\n        buffersInPacket1++;\n      }\n    }\n  }\n\n  auto originalRetransSize = stream->retransmissionBuffer.size();\n  AckBlocks acks = {{packetNum1, packetNum1}};\n  auto packet1 = createAckPacket(\n      server->getNonConstConn(),\n      ++clientNextAppDataPacketNum,\n      acks,\n      PacketNumberSpace::AppData);\n  deliverData(packetToBuf(packet1));\n  EXPECT_EQ(\n      stream->retransmissionBuffer.size(),\n      originalRetransSize - buffersInPacket1);\n  EXPECT_EQ(stream->sendState, StreamSendState::Open);\n  EXPECT_EQ(stream->recvState, StreamRecvState::Open);\n\n  // Dup ack\n  auto packet2 = createAckPacket(\n      server->getNonConstConn(),\n      ++clientNextAppDataPacketNum,\n      acks,\n      PacketNumberSpace::AppData);\n  deliverData(packetToBuf(packet2));\n\n  EXPECT_EQ(\n      stream->retransmissionBuffer.size(),\n      originalRetransSize - buffersInPacket1);\n  EXPECT_EQ(stream->sendState, StreamSendState::Open);\n  EXPECT_EQ(stream->recvState, StreamRecvState::Open);\n\n  AckBlocks acks2 = {{packetNum1, lastPacketNum}};\n  auto packet3 = createAckPacket(\n      server->getNonConstConn(),\n      ++clientNextAppDataPacketNum,\n      acks2,\n      PacketNumberSpace::AppData);\n  deliverData(packetToBuf(packet3));\n\n  EXPECT_EQ(stream->retransmissionBuffer.size(), 0);\n  EXPECT_EQ(stream->sendState, StreamSendState::Open);\n  EXPECT_EQ(stream->recvState, StreamRecvState::Open);\n\n  auto empty = IOBuf::create(0);\n  server->writeChain(streamId, std::move(empty), true);\n  loopForWrites();\n  ASSERT_FALSE(server->getConn().outstandings.packets.empty());\n\n  PacketNum finPacketNum =\n      getFirstOutstandingPacket(\n          server->getNonConstConn(), PacketNumberSpace::AppData)\n          ->packet.header.getPacketSequenceNum();\n\n  AckBlocks acks3 = {{lastPacketNum, finPacketNum}};\n  auto packet4 = createAckPacket(\n      server->getNonConstConn(),\n      ++clientNextAppDataPacketNum,\n      acks3,\n      PacketNumberSpace::AppData);\n  deliverData(packetToBuf(packet4));\n  EXPECT_EQ(stream->sendState, StreamSendState::Closed);\n  EXPECT_EQ(stream->recvState, StreamRecvState::Open);\n}\n\nTEST_F(QuicServerTransportTest, RecvRstStreamFrameNonexistClientStream) {\n  StreamId streamId = 0x00;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n\n  RstStreamFrame rstFrame(streamId, GenericApplicationErrorCode::UNKNOWN, 0);\n  writeFrame(std::move(rstFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  deliverData(packetToBuf(packet));\n\n  auto stream = server->getNonConstConn().streamManager->getStream(streamId);\n  ASSERT_TRUE(stream->streamReadError.has_value());\n}\n\nTEST_F(QuicServerTransportTest, ReceiveRstStreamNonExistentAndOtherFrame) {\n  StreamId clientUnidirectional = 0x02;\n\n  // Deliver reset on peer unidirectional stream to close the stream.\n  RstStreamFrame rstFrame(\n      clientUnidirectional, GenericApplicationErrorCode::UNKNOWN, 0);\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  writeFrame(rstFrame, builder);\n  auto packet = packetToBuf(std::move(builder).buildPacket());\n  deliverData(std::move(packet));\n\n  auto streamId =\n      server->createBidirectionalStream(false /* replaySafe */).value();\n\n  ShortHeader header2(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder2(\n      server->getConn().udpSendPacketLen,\n      std::move(header2),\n      0 /* largestAcked */);\n  builder2.encodePacketHeader();\n  writeFrame(rstFrame, builder2);\n\n  auto data = folly::IOBuf::copyBuffer(\"hello\");\n  writeStreamFrameHeader(\n      builder2,\n      streamId,\n      0,\n      data->computeChainDataLength(),\n      data->computeChainDataLength(),\n      false,\n      folly::none /* skipLenHint */);\n  writeStreamFrameData(builder2, data->clone(), data->computeChainDataLength());\n  auto packetObject = std::move(builder2).buildPacket();\n  auto packet2 = packetToBuf(std::move(packetObject));\n  deliverData(std::move(packet2));\n\n  auto readData = server->read(streamId, 0);\n  ASSERT_TRUE(readData.hasValue());\n  ASSERT_NE(readData.value().first, nullptr);\n  EXPECT_TRUE(folly::IOBufEqualTo()(*readData.value().first, *data));\n}\n\nTEST_F(QuicServerTransportTest, RecvRstStreamFrameNonexistServerStream) {\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n\n  StreamId streamId = 0x01;\n  RstStreamFrame rstFrame(streamId, GenericApplicationErrorCode::UNKNOWN, 0);\n  writeFrame(std::move(rstFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  EXPECT_THROW(deliverData(packetToBuf(packet)), std::runtime_error);\n}\n\nTEST_F(QuicServerTransportTest, RecvRstStreamFrame) {\n  clientNextAppDataPacketNum = 3;\n  std::array<std::string, 4> words = {\n      \"Hey Bob, this is Alice, for real.\",\n      \"What message did I send you last time?\",\n      \"You don't sound like Alice\",\n      \"You are a liar!\",\n  };\n\n  StreamId streamId = 0x00;\n  auto stream = server->getNonConstConn().streamManager->getStream(streamId);\n  stream->readBuffer.emplace_back(IOBuf::copyBuffer(words.at(0)), 0, false);\n  stream->readBuffer.emplace_back(\n      IOBuf::copyBuffer(words.at(1)), words.at(0).length(), false);\n  stream->retransmissionBuffer.emplace(\n      std::piecewise_construct,\n      std::forward_as_tuple(0),\n      std::forward_as_tuple(std::make_unique<StreamBuffer>(\n          IOBuf::copyBuffer(words.at(2)), 0, false)));\n  writeDataToQuicStream(*stream, IOBuf::copyBuffer(words.at(3)), false);\n  stream->currentWriteOffset = words.at(2).length() + words.at(3).length();\n  stream->currentReadOffset = words.at(0).length() + words.at(1).length();\n\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 5;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n\n  RstStreamFrame rstFrame(\n      streamId,\n      GenericApplicationErrorCode::UNKNOWN,\n      words.at(0).length() + words.at(1).length());\n  ASSERT_TRUE(builder.canBuildPacket());\n  writeFrame(std::move(rstFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  deliverData(packetToBuf(packet));\n\n  // Verify stream receive state is cleaned up but send state isn't:\n  auto updatedStream =\n      server->getNonConstConn().streamManager->findStream(streamId);\n  ASSERT_TRUE(updatedStream);\n  EXPECT_TRUE(updatedStream->readBuffer.empty());\n  // We can verify retx buffer isn't empty here. The writeBuffer though could be\n  // empty since deliverData can cause a write synchrously.\n  EXPECT_FALSE(updatedStream->retransmissionBuffer.empty());\n  EXPECT_EQ(\n      words.at(0).length() + words.at(1).length(),\n      updatedStream->finalReadOffset.value());\n  // updatedStream still writable since receiving rst has no impact on egress\n  EXPECT_TRUE(updatedStream->writable());\n}\n\nTEST_F(QuicServerTransportTest, RecvStopSendingFrame) {\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 3;\n  std::array<std::string, 4> words = {\n      \"Hey Bob, this is Alice, for real.\",\n      \"What message did I send you last time?\",\n      \"You don't sound like Alice\",\n      \"You are a liar!\",\n  };\n\n  StreamId streamId = 0x00;\n  auto stream = server->getNonConstConn().streamManager->getStream(streamId);\n  stream->readBuffer.emplace_back(IOBuf::copyBuffer(words.at(0)), 0, false);\n  stream->readBuffer.emplace_back(\n      IOBuf::copyBuffer(words.at(1)), words.at(0).length(), false);\n  stream->retransmissionBuffer.emplace(\n      std::piecewise_construct,\n      std::forward_as_tuple(0),\n      std::forward_as_tuple(std::make_unique<StreamBuffer>(\n          IOBuf::copyBuffer(words.at(2)), 0, false)));\n  stream->writeBuffer.append(IOBuf::copyBuffer(words.at(3)));\n  stream->currentWriteOffset = words.at(2).length() + words.at(3).length();\n  stream->currentReadOffset = words.at(0).length() + words.at(1).length();\n\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 5;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  StopSendingFrame stopSendingFrame(\n      streamId, GenericApplicationErrorCode::UNKNOWN);\n  ASSERT_TRUE(builder.canBuildPacket());\n  writeFrame(QuicSimpleFrame(stopSendingFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  EXPECT_CALL(\n      connCallback,\n      onStopSending(streamId, GenericApplicationErrorCode::UNKNOWN));\n  deliverData(packetToBuf(packet));\n}\n\nTEST_F(QuicServerTransportTest, RecvStopSendingFrameAfterCloseStream) {\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 3;\n  std::array<std::string, 4> words = {\n      \"Hey Bob, this is Alice, for real.\",\n      \"What message did I send you last time?\",\n      \"You don't sound like Alice\",\n      \"You are a liar!\",\n  };\n\n  StreamId streamId = 0x00;\n  auto stream = server->getNonConstConn().streamManager->getStream(streamId);\n  stream->readBuffer.emplace_back(IOBuf::copyBuffer(words.at(0)), 0, false);\n  stream->readBuffer.emplace_back(\n      IOBuf::copyBuffer(words.at(1)), words.at(0).length(), false);\n  stream->retransmissionBuffer.emplace(\n      std::piecewise_construct,\n      std::forward_as_tuple(0),\n      std::forward_as_tuple(std::make_unique<StreamBuffer>(\n          IOBuf::copyBuffer(words.at(2)), 0, false)));\n  stream->writeBuffer.append(IOBuf::copyBuffer(words.at(3)));\n  stream->currentWriteOffset = words.at(2).length() + words.at(3).length();\n  stream->currentReadOffset = words.at(0).length() + words.at(1).length();\n  server->getNonConstConn().flowControlState.sumCurStreamBufferLen = 100;\n\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 5;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n\n  StopSendingFrame stopSendingFrame(\n      streamId, GenericApplicationErrorCode::UNKNOWN);\n  ASSERT_TRUE(builder.canBuildPacket());\n  writeFrame(QuicSimpleFrame(stopSendingFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  server->resetStream(streamId, GenericApplicationErrorCode::UNKNOWN);\n  EXPECT_CALL(connCallback, onStopSending(_, _)).Times(0);\n  deliverData(packetToBuf(packet));\n}\n\nTEST_F(QuicServerTransportTest, RecvInvalidMaxStreamData) {\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 3;\n  std::array<std::string, 4> words = {\n      \"Hey Bob, this is Alice, for real.\",\n      \"What message did I send you last time?\",\n      \"You don't sound like Alice\",\n      \"You are a liar!\",\n  };\n\n  StreamId streamId = 0x02;\n  auto stream = server->getNonConstConn().streamManager->getStream(streamId);\n  stream->readBuffer.emplace_back(IOBuf::copyBuffer(words.at(0)), 0, false);\n  stream->readBuffer.emplace_back(\n      IOBuf::copyBuffer(words.at(1)), words.at(0).length(), false);\n  stream->retransmissionBuffer.emplace(\n      std::piecewise_construct,\n      std::forward_as_tuple(0),\n      std::forward_as_tuple(std::make_unique<StreamBuffer>(\n          IOBuf::copyBuffer(words.at(2)), 0, false)));\n  stream->writeBuffer.append(IOBuf::copyBuffer(words.at(3)));\n  stream->currentWriteOffset = words.at(2).length() + words.at(3).length();\n  stream->currentReadOffset = words.at(0).length() + words.at(1).length();\n  server->getNonConstConn().flowControlState.sumCurStreamBufferLen = 100;\n\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 5;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n\n  MaxStreamDataFrame maxStreamDataFrame(streamId, 100);\n  ASSERT_TRUE(builder.canBuildPacket());\n  writeFrame(std::move(maxStreamDataFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  EXPECT_THROW(deliverData(packetToBuf(packet)), std::runtime_error);\n}\n\nTEST_F(QuicServerTransportTest, RecvStopSendingFrameAfterHalfCloseRemote) {\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 3;\n  std::array<std::string, 4> words = {\n      \"Hey Bob, this is Alice, for real.\",\n      \"What message did I send you last time?\",\n      \"You don't sound like Alice\",\n      \"You are a liar!\",\n  };\n\n  StreamId streamId = 0x00;\n  auto stream = server->getNonConstConn().streamManager->getStream(streamId);\n  stream->readBuffer.emplace_back(IOBuf::copyBuffer(words.at(0)), 0, false);\n  stream->readBuffer.emplace_back(\n      IOBuf::copyBuffer(words.at(1)), words.at(0).length(), false);\n  stream->retransmissionBuffer.emplace(\n      std::piecewise_construct,\n      std::forward_as_tuple(0),\n      std::forward_as_tuple(std::make_unique<StreamBuffer>(\n          IOBuf::copyBuffer(words.at(2)), 0, false)));\n  stream->writeBuffer.append(IOBuf::copyBuffer(words.at(3)));\n  stream->currentWriteOffset = words.at(2).length() + words.at(3).length();\n  stream->currentReadOffset = words.at(0).length() + words.at(1).length();\n\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 5;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n\n  StopSendingFrame stopSendingFrame(\n      streamId, GenericApplicationErrorCode::UNKNOWN);\n  ASSERT_TRUE(builder.canBuildPacket());\n  auto dataLen = writeStreamFrameHeader(\n      builder,\n      0x00,\n      stream->currentReadOffset,\n      0,\n      10,\n      true,\n      folly::none /* skipLenHint */);\n  ASSERT_TRUE(dataLen.has_value());\n  ASSERT_EQ(*dataLen, 0);\n  writeFrame(QuicSimpleFrame(stopSendingFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  EXPECT_CALL(\n      connCallback,\n      onStopSending(streamId, GenericApplicationErrorCode::UNKNOWN));\n  deliverData(packetToBuf(packet));\n}\n\nTEST_F(QuicServerTransportTest, RecvStopSendingBeforeStream) {\n  StreamId streamId = 0x00;\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 3;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n\n  StopSendingFrame stopSendingFrame(\n      streamId, GenericApplicationErrorCode::UNKNOWN);\n  ASSERT_TRUE(builder.canBuildPacket());\n  writeFrame(QuicSimpleFrame(stopSendingFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  EXPECT_CALL(connCallback, onNewBidirectionalStream(streamId));\n  EXPECT_CALL(\n      connCallback,\n      onStopSending(streamId, GenericApplicationErrorCode::UNKNOWN));\n  deliverData(packetToBuf(packet));\n}\n\nTEST_F(QuicServerTransportTest, RecvStopSendingFrameAfterReset) {\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 3;\n  std::array<std::string, 4> words = {\n      \"Hey Bob, this is Alice, for real.\",\n      \"What message did I send you last time?\",\n      \"You don't sound like Alice\",\n      \"You are a liar!\",\n  };\n\n  StreamId streamId1 = 0x00;\n  StreamId streamId2 = 0x04;\n  auto stream1 = server->getNonConstConn().streamManager->getStream(streamId1);\n  stream1->readBuffer.emplace_back(IOBuf::copyBuffer(words.at(0)), 0, false);\n  stream1->readBuffer.emplace_back(\n      IOBuf::copyBuffer(words.at(1)), words.at(0).length(), false);\n  stream1->retransmissionBuffer.emplace(\n      std::piecewise_construct,\n      std::forward_as_tuple(0),\n      std::forward_as_tuple(std::make_unique<StreamBuffer>(\n          IOBuf::copyBuffer(words.at(2)), 0, false)));\n  stream1->writeBuffer.append(IOBuf::copyBuffer(words.at(3)));\n  stream1->currentWriteOffset = words.at(2).length() + words.at(3).length();\n  stream1->currentReadOffset = words.at(0).length() + words.at(1).length();\n  auto stream2 = server->getNonConstConn().streamManager->getStream(streamId2);\n  stream2->readBuffer.emplace_back(IOBuf::copyBuffer(words.at(0)), 0, false);\n  stream2->readBuffer.emplace_back(\n      IOBuf::copyBuffer(words.at(1)), words.at(0).length(), false);\n  stream2->retransmissionBuffer.emplace(\n      std::piecewise_construct,\n      std::forward_as_tuple(0),\n      std::forward_as_tuple(std::make_unique<StreamBuffer>(\n          IOBuf::copyBuffer(words.at(2)), 0, false)));\n  stream2->writeBuffer.append(IOBuf::copyBuffer(words.at(3)));\n  stream2->currentWriteOffset = words.at(2).length() + words.at(3).length();\n  stream2->currentReadOffset = words.at(0).length() + words.at(1).length();\n\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 5;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n\n  StopSendingFrame stopSendingFrame1(\n      streamId1, GenericApplicationErrorCode::UNKNOWN);\n  StopSendingFrame stopSendingFrame2(\n      streamId2, GenericApplicationErrorCode::UNKNOWN);\n  ASSERT_TRUE(builder.canBuildPacket());\n  writeFrame(QuicSimpleFrame(stopSendingFrame1), builder);\n  writeFrame(QuicSimpleFrame(stopSendingFrame2), builder);\n  auto packet = std::move(builder).buildPacket();\n  EXPECT_CALL(\n      connCallback, onStopSending(_, GenericApplicationErrorCode::UNKNOWN))\n      .WillOnce(Invoke([&](StreamId /*sid*/, ApplicationErrorCode /*e*/) {\n        server->close(folly::none);\n      }));\n  EXPECT_THROW(deliverData(packetToBuf(packet)), std::runtime_error);\n}\n\nTEST_F(QuicServerTransportTest, StopSendingLoss) {\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 3;\n  auto streamId = server->createBidirectionalStream().value();\n  server->getNonConstConn().streamManager->getStream(streamId);\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      server->getNonConstConn().ackStates.appDataAckState.nextPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      server->getConn().ackStates.appDataAckState.largestAckedByPeer.value_or(\n          0));\n  builder.encodePacketHeader();\n  StopSendingFrame stopSendingFrame(\n      streamId, GenericApplicationErrorCode::UNKNOWN);\n  ASSERT_TRUE(builder.canBuildPacket());\n  writeFrame(QuicSimpleFrame(stopSendingFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n  markPacketLoss(server->getNonConstConn(), packet.packet, false);\n  EXPECT_EQ(server->getNonConstConn().pendingEvents.frames.size(), 1);\n  StopSendingFrame* stopFrame = server->getNonConstConn()\n                                    .pendingEvents.frames.front()\n                                    .asStopSendingFrame();\n  ASSERT_NE(stopFrame, nullptr);\n  EXPECT_EQ(*stopFrame, stopSendingFrame);\n}\n\nTEST_F(QuicServerTransportTest, StopSendingLossAfterStreamClosed) {\n  server->getNonConstConn().ackStates.appDataAckState.nextPacketNum = 3;\n  auto streamId = server->createBidirectionalStream().value();\n  server->getNonConstConn().streamManager->getStream(streamId);\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      server->getConn().ackStates.appDataAckState.largestAckedByPeer.value_or(\n          0));\n  builder.encodePacketHeader();\n  StopSendingFrame stopSendingFrame(\n      streamId, GenericApplicationErrorCode::UNKNOWN);\n  ASSERT_TRUE(builder.canBuildPacket());\n  writeFrame(QuicSimpleFrame(stopSendingFrame), builder);\n  auto packet = std::move(builder).buildPacket();\n\n  // clear out all the streams, this is not a great way to simulate closed\n  // streams, but good enough for this test.\n  server->getNonConstConn().streamManager->clearOpenStreams();\n  markPacketLoss(server->getNonConstConn(), packet.packet, false);\n  EXPECT_EQ(server->getNonConstConn().pendingEvents.frames.size(), 0);\n}\n\nTEST_F(QuicServerTransportTest, TestCloneStopSending) {\n  auto streamId = server->createBidirectionalStream().value();\n  auto qLogger = std::make_shared<quic::FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n  server->getNonConstConn().streamManager->getStream(streamId);\n  // knock every handshake outstanding packets out\n  server->getNonConstConn().outstandings.initialPacketsCount = 0;\n  server->getNonConstConn().outstandings.handshakePacketsCount = 0;\n  server->getNonConstConn().outstandings.packets.clear();\n  for (auto& t : server->getNonConstConn().lossState.lossTimes) {\n    t.reset();\n  }\n\n  server->stopSending(streamId, GenericApplicationErrorCode::UNKNOWN);\n  loopForWrites();\n  // Find the outstanding StopSending.\n  auto packetItr = std::find_if(\n      server->getNonConstConn().outstandings.packets.begin(),\n      server->getNonConstConn().outstandings.packets.end(),\n      findFrameInPacketFunc<QuicSimpleFrame::Type::StopSendingFrame>());\n\n  ASSERT_TRUE(\n      packetItr != server->getNonConstConn().outstandings.packets.end());\n  // Force a timeout with no data so that it clones the packet\n  server->lossTimeout().timeoutExpired();\n  loopForWrites();\n  auto numStopSendingPackets = std::count_if(\n      server->getNonConstConn().outstandings.packets.begin(),\n      server->getNonConstConn().outstandings.packets.end(),\n      findFrameInPacketFunc<QuicSimpleFrame::Type::StopSendingFrame>());\n\n  EXPECT_GT(numStopSendingPackets, 1);\n\n  std::vector<int> indices =\n      getQLogEventIndices(QLogEventType::TransportStateUpdate, qLogger);\n  EXPECT_EQ(indices.size(), 1);\n  auto tmp = std::move(qLogger->logs[indices[0]]);\n  auto event = dynamic_cast<QLogTransportStateUpdateEvent*>(tmp.get());\n  EXPECT_EQ(event->update, kLossTimeoutExpired);\n}\n\nTEST_F(QuicServerTransportTest, TestAckStopSending) {\n  auto streamId = server->createBidirectionalStream().value();\n  server->getNonConstConn().streamManager->getStream(streamId);\n  server->stopSending(streamId, GenericApplicationErrorCode::UNKNOWN);\n  loopForWrites();\n  auto match = findFrameInPacketFunc<QuicSimpleFrame::Type::StopSendingFrame>();\n\n  auto op = findOutstandingPacket(server->getNonConstConn(), match);\n  ASSERT_TRUE(op != nullptr);\n  PacketNum packetNum = op->packet.header.getPacketSequenceNum();\n  AckBlocks acks = {{packetNum, packetNum}};\n  auto packet1 = createAckPacket(\n      server->getNonConstConn(),\n      ++clientNextAppDataPacketNum,\n      acks,\n      PacketNumberSpace::AppData);\n  deliverData(packetToBuf(packet1));\n  op = findOutstandingPacket(server->getNonConstConn(), match);\n  EXPECT_TRUE(op == nullptr);\n}\n\nTEST_F(QuicServerTransportTest, RecvPathChallenge) {\n  auto& conn = server->getNonConstConn();\n\n  // Add additional peer id so PathResponse completes.\n  conn.peerConnectionIds.emplace_back(ConnectionId({1, 2, 3, 4}), 1);\n\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero, *conn.serverConnectionId, 10);\n  RegularQuicPacketBuilder builder(\n      conn.udpSendPacketLen, std::move(header), 0 /* largestAcked */);\n  builder.encodePacketHeader();\n  PathChallengeFrame pathChallenge(123);\n  ASSERT_TRUE(builder.canBuildPacket());\n  writeSimpleFrame(QuicSimpleFrame(pathChallenge), builder);\n\n  auto packet = std::move(builder).buildPacket();\n\n  EXPECT_TRUE(conn.pendingEvents.frames.empty());\n  deliverData(packetToBuf(packet), false);\n  EXPECT_EQ(conn.pendingEvents.frames.size(), 2);\n  // The RetireConnectionId frame will be enqueued before the PathResponse.\n  auto retireFrame = conn.pendingEvents.frames[0].asRetireConnectionIdFrame();\n  EXPECT_EQ(retireFrame->sequenceNumber, 0);\n\n  PathResponseFrame& pathResponse =\n      *conn.pendingEvents.frames[1].asPathResponseFrame();\n  EXPECT_EQ(pathResponse.pathData, pathChallenge.pathData);\n}\n\nTEST_F(QuicServerTransportTest, TestAckRstStream) {\n  auto streamId = server->createUnidirectionalStream().value();\n  auto stream = server->getNonConstConn().streamManager->getStream(streamId);\n  auto packetNum = rstStreamAndSendPacket(\n      server->getNonConstConn(),\n      server->getSocket(),\n      *stream,\n      GenericApplicationErrorCode::UNKNOWN);\n\n  AckBlocks acks = {{packetNum, packetNum}};\n  auto packet1 = createAckPacket(\n      server->getNonConstConn(),\n      ++clientNextAppDataPacketNum,\n      acks,\n      PacketNumberSpace::AppData);\n  deliverData(packetToBuf(packet1));\n  // Closed streams should be deleted.\n  EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n}\n\nTEST_F(QuicServerTransportTest, ReceiveConnectionClose) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  std::string errMsg = \"Stand clear of the closing doors, please\";\n  ConnectionCloseFrame connClose(\n      QuicErrorCode(TransportErrorCode::NO_ERROR), errMsg);\n  writeFrame(std::move(connClose), builder);\n  auto packet = std::move(builder).buildPacket();\n  EXPECT_CALL(connCallback, onConnectionEnd());\n  deliverDataWithoutErrorCheck(packetToBuf(packet));\n  // Now the transport should be closed\n  EXPECT_EQ(\n      server->getConn().localConnectionError->first,\n      QuicErrorCode(TransportErrorCode::NO_ERROR));\n  EXPECT_EQ(\n      server->getConn().peerConnectionError->first,\n      QuicErrorCode(TransportErrorCode::NO_ERROR));\n  auto closedMsg =\n      folly::to<std::string>(\"Server closed by peer reason=\", errMsg);\n  EXPECT_EQ(server->getConn().peerConnectionError->second, closedMsg);\n  EXPECT_TRUE(server->isClosed());\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  checkTransportStateUpdate(qLogger, std::move(closedMsg));\n}\n\nTEST_F(QuicServerTransportTest, ReceiveApplicationClose) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n\n  std::string errMsg = \"Stand clear of the closing doors, please\";\n  ConnectionCloseFrame appClose(\n      QuicErrorCode(GenericApplicationErrorCode::UNKNOWN), errMsg);\n  writeFrame(std::move(appClose), builder);\n  auto packet = std::move(builder).buildPacket();\n\n  EXPECT_CALL(\n      connCallback,\n      onConnectionError(IsAppError(GenericApplicationErrorCode::UNKNOWN)));\n  deliverDataWithoutErrorCheck(packetToBuf(packet));\n  // Now the transport should be closed\n  EXPECT_EQ(\n      QuicErrorCode(TransportErrorCode::NO_ERROR),\n      server->getConn().localConnectionError->first);\n  EXPECT_EQ(\n      server->getConn().peerConnectionError->first,\n      QuicErrorCode(GenericApplicationErrorCode::UNKNOWN));\n  auto closedMsg =\n      folly::to<std::string>(\"Server closed by peer reason=\", errMsg);\n  EXPECT_EQ(server->getConn().peerConnectionError->second, closedMsg);\n  EXPECT_TRUE(server->isClosed());\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  checkTransportStateUpdate(qLogger, std::move(closedMsg));\n}\n\nTEST_F(QuicServerTransportTest, ReceiveConnectionCloseTwice) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  std::string errMsg = \"Mind the gap\";\n  ConnectionCloseFrame connClose(\n      QuicErrorCode(TransportErrorCode::NO_ERROR), errMsg);\n  writeFrame(std::move(connClose), builder);\n  auto packet = std::move(builder).buildPacket();\n  EXPECT_CALL(connCallback, onConnectionEnd());\n  deliverDataWithoutErrorCheck(packetToBuf(packet));\n  // Now the transport should be closed\n  EXPECT_EQ(\n      QuicErrorCode(TransportErrorCode::NO_ERROR),\n      server->getConn().localConnectionError->first);\n  EXPECT_EQ(\n      server->getConn().peerConnectionError->first,\n      QuicErrorCode(TransportErrorCode::NO_ERROR));\n  auto closedMsg =\n      folly::to<std::string>(\"Server closed by peer reason=\", errMsg);\n  EXPECT_EQ(server->getConn().peerConnectionError->second, closedMsg);\n  EXPECT_TRUE(server->isClosed());\n  EXPECT_TRUE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  serverWrites.clear();\n  deliverDataWithoutErrorCheck(packetToBuf(packet));\n  EXPECT_FALSE(verifyFramePresent(\n      serverWrites,\n      *makeClientEncryptedCodec(),\n      QuicFrame::Type::ConnectionCloseFrame));\n  std::vector<int> indices =\n      getQLogEventIndices(QLogEventType::PacketDrop, qLogger);\n  EXPECT_EQ(indices.size(), 1);\n  auto tmp = std::move(qLogger->logs[indices[0]]);\n  auto event = dynamic_cast<QLogPacketDropEvent*>(tmp.get());\n  EXPECT_EQ(event->packetSize, 29);\n  EXPECT_EQ(\n      event->dropReason,\n      QuicTransportStatsCallback::toString(\n          PacketDropReason::SERVER_STATE_CLOSED));\n}\n\nTEST_F(QuicServerTransportTest, CloseTransportWontUnbound) {\n  EXPECT_CALL(routingCallback, onConnectionUnbound(_, _, _)).Times(0);\n  server->closeTransport();\n  // Need to do this otherwise server transport destructor will still call\n  // onConnectionUnbound\n  server->setRoutingCallback(nullptr);\n}\n\nTEST_F(QuicServerTransportTest, UnboundConnection) {\n  EXPECT_CALL(routingCallback, onConnectionUnbound(_, _, _)).Times(1);\n  server->unbindConnection();\n  // Need to do this otherwise server transport destructor will still call\n  // onConnectionUnbound\n  server->setRoutingCallback(nullptr);\n}\n\nTEST_F(QuicServerTransportTest, DestroyWithoutClosing) {\n  StreamId streamId = server->createBidirectionalStream().value();\n\n  MockReadCallback readCb;\n  server->setReadCallback(streamId, &readCb);\n\n  EXPECT_CALL(connCallback, onConnectionError(_)).Times(0);\n  EXPECT_CALL(connCallback, onConnectionEnd()).Times(0);\n  MockDeliveryCallback deliveryCallback;\n  auto write = IOBuf::copyBuffer(\"no\");\n  server->writeChain(streamId, write->clone(), true, &deliveryCallback);\n\n  EXPECT_CALL(deliveryCallback, onCanceled(_, _));\n  EXPECT_CALL(readCb, readError(_, _));\n\n  server.reset();\n}\n\nTEST_F(QuicServerTransportTest, DestroyWithoutClosingCancelByteEvents) {\n  StreamId streamId = server->createBidirectionalStream().value();\n\n  MockReadCallback readCb;\n  server->setReadCallback(streamId, &readCb);\n\n  EXPECT_CALL(connCallback, onConnectionError(_)).Times(0);\n  EXPECT_CALL(connCallback, onConnectionEnd()).Times(0);\n  auto write = IOBuf::copyBuffer(\"no\");\n  server->writeChain(streamId, write->clone(), true);\n\n  MockByteEventCallback txCallback;\n  MockByteEventCallback deliveryCallback;\n\n  server->registerByteEventCallback(\n      ByteEvent::Type::TX, streamId, 0, &txCallback);\n  server->registerByteEventCallback(\n      ByteEvent::Type::ACK, streamId, 0, &deliveryCallback);\n\n  EXPECT_CALL(txCallback, onByteEventCanceled(_));\n  EXPECT_CALL(deliveryCallback, onByteEventCanceled(_));\n  EXPECT_CALL(readCb, readError(_, _));\n\n  server.reset();\n}\n\nTEST_F(QuicServerTransportTest, SetCongestionControl) {\n  // Default: Cubic\n  auto cc = server->getConn().congestionController.get();\n  EXPECT_EQ(CongestionControlType::Cubic, cc->type());\n\n  // Change to Reno\n  server->setCongestionControl(CongestionControlType::NewReno);\n  cc = server->getConn().congestionController.get();\n  EXPECT_EQ(CongestionControlType::NewReno, cc->type());\n\n  // Change back to Cubic:\n  server->setCongestionControl(CongestionControlType::Cubic);\n  cc = server->getConn().congestionController.get();\n  EXPECT_EQ(CongestionControlType::Cubic, cc->type());\n}\n\nTEST_F(QuicServerTransportTest, TestServerNotDetachable) {\n  EXPECT_FALSE(server->isDetachable());\n}\n\nTEST_F(QuicServerTransportTest, SetOriginalPeerAddressSetsPacketSize) {\n  folly::SocketAddress v4Address(\"0.0.0.0\", 0);\n  ASSERT_TRUE(v4Address.getFamily() == AF_INET);\n  server->setOriginalPeerAddress(v4Address);\n  EXPECT_EQ(kDefaultV4UDPSendPacketLen, server->getConn().udpSendPacketLen);\n\n  folly::SocketAddress v6Address(\"::\", 0);\n  ASSERT_TRUE(v6Address.getFamily() == AF_INET6);\n  server->setOriginalPeerAddress(v6Address);\n  EXPECT_EQ(kDefaultV6UDPSendPacketLen, server->getConn().udpSendPacketLen);\n\n  server->closeNow(folly::none);\n}\n\nTEST_F(\n    QuicServerTransportTest,\n    ReceiveDataFromChangedPeerAddressWhileMigrationIsDisabled) {\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  StreamId streamId = 2;\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  try {\n    deliverData(std::move(packetData), true, &newPeer);\n    FAIL();\n  } catch (const std::runtime_error& ex) {\n    EXPECT_EQ(std::string(ex.what()), \"Invalid migration\");\n  }\n  EXPECT_TRUE(server->getConn().localConnectionError);\n  EXPECT_EQ(\n      server->getConn().localConnectionError->second, \"Migration disabled\");\n  EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n}\n\nTEST_F(QuicServerTransportTest, SwitchServerCidsNoOtherIds) {\n  auto& conn = server->getNonConstConn();\n\n  EXPECT_EQ(conn.retireAndSwitchPeerConnectionIds(), false);\n  EXPECT_EQ(conn.pendingEvents.frames.size(), 0);\n  EXPECT_EQ(conn.peerConnectionIds.size(), 1);\n}\n\nTEST_F(QuicServerTransportTest, SwitchServerCidsOneOtherCid) {\n  auto& conn = server->getNonConstConn();\n  auto originalCid = conn.clientConnectionId;\n  auto secondCid =\n      ConnectionIdData(ConnectionId(std::vector<uint8_t>{5, 6, 7, 8}), 2);\n  conn.peerConnectionIds.push_back(secondCid);\n\n  EXPECT_EQ(conn.retireAndSwitchPeerConnectionIds(), true);\n  EXPECT_EQ(conn.peerConnectionIds.size(), 1);\n\n  EXPECT_EQ(conn.pendingEvents.frames.size(), 1);\n  auto retireFrame = conn.pendingEvents.frames[0].asRetireConnectionIdFrame();\n  EXPECT_EQ(retireFrame->sequenceNumber, 0);\n\n  auto replacedCid = conn.clientConnectionId;\n  EXPECT_NE(originalCid, *replacedCid);\n  EXPECT_EQ(secondCid.connId, *replacedCid);\n}\n\nTEST_F(QuicServerTransportTest, SwitchServerCidsMultipleCids) {\n  auto& conn = server->getNonConstConn();\n  auto originalCid = conn.clientConnectionId;\n  auto secondCid =\n      ConnectionIdData(ConnectionId(std::vector<uint8_t>{5, 6, 7, 8}), 2);\n  auto thirdCid =\n      ConnectionIdData(ConnectionId(std::vector<uint8_t>{3, 3, 3, 3}), 3);\n\n  conn.peerConnectionIds.push_back(secondCid);\n  conn.peerConnectionIds.push_back(thirdCid);\n\n  EXPECT_EQ(conn.retireAndSwitchPeerConnectionIds(), true);\n  EXPECT_EQ(conn.peerConnectionIds.size(), 2);\n\n  EXPECT_EQ(conn.pendingEvents.frames.size(), 1);\n  auto retireFrame = conn.pendingEvents.frames[0].asRetireConnectionIdFrame();\n  EXPECT_EQ(retireFrame->sequenceNumber, 0);\n\n  // Uses the first unused connection id.\n  auto replacedCid = conn.clientConnectionId;\n  EXPECT_NE(originalCid, *replacedCid);\n  EXPECT_EQ(secondCid.connId, *replacedCid);\n}\n\nclass QuicServerTransportAllowMigrationTest\n    : public QuicServerTransportTest,\n      public WithParamInterface<MigrationParam> {\n public:\n  bool getDisableMigration() override {\n    return false;\n  }\n\n  virtual void initializeServerHandshake() override {\n    fakeHandshake = new FakeServerHandshake(\n        server->getNonConstConn(),\n        FizzServerQuicHandshakeContext::Builder().build(),\n        false,\n        false,\n        GetParam().clientSentActiveConnIdTransportParam);\n  }\n};\n\nINSTANTIATE_TEST_CASE_P(\n    QuicServerTransportMigrationTests,\n    QuicServerTransportAllowMigrationTest,\n    Values(\n        MigrationParam{folly::none},\n        MigrationParam{2},\n        MigrationParam{4},\n        MigrationParam{9},\n        MigrationParam{50}));\n\nTEST_P(\n    QuicServerTransportAllowMigrationTest,\n    ReceiveProbingPacketFromChangedPeerAddress) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n  server->getNonConstConn().transportSettings.disableMigration = false;\n\n  // Add additional peer id so PathResponse completes.\n  server->getNonConstConn().peerConnectionIds.emplace_back(\n      ConnectionId({1, 2, 3, 4}), 1);\n\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n\n  writeSimpleFrame(PathChallengeFrame(123), builder);\n  auto packet = std::move(builder).buildPacket();\n  auto packetData = packetToBuf(packet);\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  try {\n    deliverData(std::move(packetData), true, &newPeer);\n    FAIL();\n  } catch (const std::runtime_error& ex) {\n    EXPECT_EQ(std::string(ex.what()), \"Invalid migration\");\n  }\n  EXPECT_TRUE(server->getConn().localConnectionError);\n  EXPECT_EQ(\n      server->getConn().localConnectionError->second,\n      \"Probing not supported yet\");\n\n  std::vector<int> indices =\n      getQLogEventIndices(QLogEventType::PacketDrop, qLogger);\n  EXPECT_EQ(indices.size(), 1);\n  auto tmp = std::move(qLogger->logs[indices[0]]);\n  auto event = dynamic_cast<QLogPacketDropEvent*>(tmp.get());\n  EXPECT_EQ(event->packetSize, 29);\n  EXPECT_EQ(\n      event->dropReason,\n      QuicTransportStatsCallback::toString(\n          PacketDropReason::PEER_ADDRESS_CHANGE));\n}\n\nTEST_P(\n    QuicServerTransportAllowMigrationTest,\n    ReceiveReorderedDataFromChangedPeerAddress) {\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto firstPacket = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n  auto secondPacket = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      6,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  // Receive second packet first\n  deliverData(std::move(secondPacket));\n\n  auto peerAddress = server->getConn().peerAddress;\n\n  // Receive first packet later from a different address\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  deliverData(std::move(firstPacket), true, &newPeer);\n\n  // No migration for reordered packet\n  EXPECT_EQ(server->getConn().peerAddress, peerAddress);\n}\n\nTEST_P(QuicServerTransportAllowMigrationTest, MigrateToUnvalidatedPeer) {\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 0);\n\n  auto peerAddress = server->getConn().peerAddress;\n  auto congestionController = server->getConn().congestionController.get();\n  auto srtt = server->getConn().lossState.srtt;\n  auto lrtt = server->getConn().lossState.lrtt;\n  auto rttvar = server->getConn().lossState.rttvar;\n  auto mrtt = server->getConn().lossState.mrtt;\n\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  deliverData(std::move(packetData), false, &newPeer);\n\n  EXPECT_TRUE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n  EXPECT_EQ(server->getConn().lossState.srtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.lrtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.rttvar, 0us);\n  EXPECT_EQ(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_NE(server->getConn().congestionController.get(), nullptr);\n  EXPECT_NE(server->getConn().congestionController.get(), congestionController);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->peerAddress,\n      clientAddr);\n  EXPECT_EQ(\n      server->getConn()\n          .migrationState.lastCongestionAndRtt->congestionController.get(),\n      congestionController);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->srtt, srtt);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->lrtt, lrtt);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar, rttvar);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->mrtt, mrtt);\n\n  loopForWrites();\n  EXPECT_FALSE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n  EXPECT_TRUE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_TRUE(server->pathValidationTimeout().isScheduled());\n\n  EXPECT_TRUE(server->getConn().pathValidationLimiter != nullptr);\n\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n\n  writeSimpleFrame(\n      PathResponseFrame(server->getConn().outstandingPathValidation->pathData),\n      builder);\n  auto packet = std::move(builder).buildPacket();\n  deliverData(packetToBuf(packet), false, &newPeer);\n  EXPECT_FALSE(server->getConn().outstandingPathValidation);\n  EXPECT_FALSE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_FALSE(server->pathValidationTimeout().isScheduled());\n}\n\nTEST_P(QuicServerTransportAllowMigrationTest, ResetPathRttPathResponse) {\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 0);\n\n  auto peerAddress = server->getConn().peerAddress;\n  auto srtt = server->getConn().lossState.srtt;\n  auto lrtt = server->getConn().lossState.lrtt;\n  auto rttvar = server->getConn().lossState.rttvar;\n\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  deliverData(std::move(packetData), false, &newPeer);\n\n  EXPECT_TRUE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n  EXPECT_EQ(server->getConn().lossState.srtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.lrtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.rttvar, 0us);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->peerAddress,\n      clientAddr);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->srtt, srtt);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->lrtt, lrtt);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar, rttvar);\n\n  loopForWrites();\n  EXPECT_FALSE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n  EXPECT_TRUE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_TRUE(server->pathValidationTimeout().isScheduled());\n\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n\n  writeSimpleFrame(\n      PathResponseFrame(server->getConn().outstandingPathValidation->pathData),\n      builder);\n  auto packet = std::move(builder).buildPacket();\n  deliverData(packetToBuf(packet), false, &newPeer);\n  EXPECT_FALSE(server->getConn().outstandingPathValidation);\n  EXPECT_FALSE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_FALSE(server->pathValidationTimeout().isScheduled());\n  EXPECT_FALSE(server->getConn().writableBytesLimit);\n\n  // After Pathresponse frame is received, srtt,lrtt = sampleRtt;\n  // sampleRtt = time from send of PathChallenge to receiving PathResponse\n  EXPECT_NE(server->getConn().lossState.srtt, 0us);\n  EXPECT_NE(server->getConn().lossState.lrtt, 0us);\n  EXPECT_NE(server->getConn().lossState.rttvar, 0us);\n\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->srtt, srtt);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->lrtt, lrtt);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar, rttvar);\n}\n\nTEST_P(QuicServerTransportAllowMigrationTest, IgnoreInvalidPathResponse) {\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 0);\n\n  auto peerAddress = server->getConn().peerAddress;\n\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n\n  deliverData(std::move(packetData), false, &newPeer);\n\n  EXPECT_TRUE(server->getConn().pendingEvents.pathChallenge);\n\n  EXPECT_TRUE(server->getConn().pathValidationLimiter != nullptr);\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n\n  loopForWrites();\n  EXPECT_FALSE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n  EXPECT_TRUE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_TRUE(server->pathValidationTimeout().isScheduled());\n\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n\n  writeSimpleFrame(\n      PathResponseFrame(\n          server->getConn().outstandingPathValidation->pathData ^ 1),\n      builder);\n  auto packet = std::move(builder).buildPacket();\n  deliverData(packetToBuf(packet), false, &newPeer);\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n  EXPECT_TRUE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_TRUE(server->pathValidationTimeout().isScheduled());\n}\n\nTEST_P(\n    QuicServerTransportAllowMigrationTest,\n    ReceivePathResponseFromDifferentPeerAddress) {\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 0);\n\n  auto peerAddress = server->getConn().peerAddress;\n\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  deliverData(std::move(packetData), false, &newPeer);\n\n  EXPECT_TRUE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n\n  loopForWrites();\n  EXPECT_FALSE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n  EXPECT_TRUE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_TRUE(server->pathValidationTimeout().isScheduled());\n\n  EXPECT_TRUE(server->getConn().pathValidationLimiter != nullptr);\n\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n  writeSimpleFrame(\n      PathResponseFrame(server->getConn().outstandingPathValidation->pathData),\n      builder);\n  auto packet = std::move(builder).buildPacket();\n  folly::SocketAddress newPeer2(\"200.101.102.103\", 23456);\n  try {\n    deliverData(packetToBuf(packet), false, &newPeer2);\n    FAIL();\n  } catch (const std::runtime_error& ex) {\n    EXPECT_EQ(std::string(ex.what()), \"Invalid migration\");\n  }\n  EXPECT_TRUE(server->isClosed());\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n  EXPECT_FALSE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_FALSE(server->pathValidationTimeout().isScheduled());\n\n  EXPECT_TRUE(server->getConn().localConnectionError);\n  EXPECT_EQ(\n      server->getConn().localConnectionError->second,\n      \"Probing not supported yet\");\n}\n\nTEST_F(QuicServerTransportTest, TooManyMigrations) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n  server->getNonConstConn().transportSettings.disableMigration = false;\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  for (size_t i = 0; i < kMaxNumMigrationsAllowed; ++i) {\n    folly::SocketAddress newPeer(\"100.101.102.103\", 23456 + i);\n    deliverData(packetData->clone(), false, &newPeer);\n  }\n\n  folly::SocketAddress newPeer(\"200.101.102.103\", 23456);\n  try {\n    deliverData(packetData->clone(), false, &newPeer);\n  } catch (const std::runtime_error& ex) {\n    EXPECT_EQ(std::string(ex.what()), \"Invalid migration\");\n  }\n  EXPECT_TRUE(server->getConn().localConnectionError);\n  EXPECT_EQ(\n      server->getConn().localConnectionError->second, \"Too many migrations\");\n  EXPECT_TRUE(server->isClosed());\n  std::vector<int> indices =\n      getQLogEventIndices(QLogEventType::PacketDrop, qLogger);\n  EXPECT_EQ(indices.size(), 1);\n  auto tmp = std::move(qLogger->logs[indices[0]]);\n  auto event = dynamic_cast<QLogPacketDropEvent*>(tmp.get());\n  EXPECT_EQ(event->packetSize, 0);\n  EXPECT_EQ(\n      event->dropReason,\n      QuicTransportStatsCallback::toString(\n          PacketDropReason::PEER_ADDRESS_CHANGE));\n}\n\nTEST_P(QuicServerTransportAllowMigrationTest, MigrateToValidatedPeer) {\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  server->getNonConstConn().migrationState.previousPeerAddresses.push_back(\n      newPeer);\n  CongestionAndRttState state;\n  state.peerAddress = newPeer;\n  state.recordTime = Clock::now();\n  state.congestionController = ccFactory_->makeCongestionController(\n      server->getNonConstConn(),\n      server->getNonConstConn().transportSettings.defaultCongestionController);\n  state.srtt = 1000us;\n  state.lrtt = 2000us;\n  state.rttvar = 3000us;\n  state.mrtt = 800us;\n  server->getNonConstConn().migrationState.lastCongestionAndRtt =\n      std::move(state);\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n\n  auto peerAddress = server->getConn().peerAddress;\n  auto lastCongestionController =\n      server->getConn()\n          .migrationState.lastCongestionAndRtt->congestionController.get();\n  auto lastSrtt = server->getConn().migrationState.lastCongestionAndRtt->srtt;\n  auto lastLrtt = server->getConn().migrationState.lastCongestionAndRtt->lrtt;\n  auto lastRttvar =\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar;\n  auto lastMrtt = server->getConn().migrationState.lastCongestionAndRtt->mrtt;\n  auto congestionController = server->getConn().congestionController.get();\n  auto srtt = server->getConn().lossState.srtt;\n  auto lrtt = server->getConn().lossState.lrtt;\n  auto rttvar = server->getConn().lossState.rttvar;\n  auto mrtt = server->getConn().lossState.mrtt;\n\n  deliverData(std::move(packetData), false, &newPeer);\n\n  EXPECT_FALSE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n  EXPECT_EQ(server->getConn().lossState.srtt, lastSrtt);\n  EXPECT_EQ(server->getConn().lossState.lrtt, lastLrtt);\n  EXPECT_EQ(server->getConn().lossState.rttvar, lastRttvar);\n  EXPECT_EQ(server->getConn().lossState.mrtt, lastMrtt);\n  EXPECT_EQ(\n      server->getConn().congestionController.get(), lastCongestionController);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->peerAddress,\n      clientAddr);\n  EXPECT_EQ(\n      server->getConn()\n          .migrationState.lastCongestionAndRtt->congestionController.get(),\n      congestionController);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->srtt, srtt);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->lrtt, lrtt);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar, rttvar);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->mrtt, mrtt);\n}\n\nTEST_P(\n    QuicServerTransportAllowMigrationTest,\n    MigrateToUnvalidatedPeerOverwritesCachedRttState) {\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  server->getNonConstConn().migrationState.previousPeerAddresses.push_back(\n      newPeer);\n  CongestionAndRttState state;\n  state.peerAddress = newPeer;\n  state.recordTime = Clock::now();\n  state.congestionController = ccFactory_->makeCongestionController(\n      server->getNonConstConn(),\n      server->getNonConstConn().transportSettings.defaultCongestionController);\n  state.srtt = 1000us;\n  state.lrtt = 2000us;\n  state.rttvar = 3000us;\n  state.mrtt = 800us;\n  server->getNonConstConn().migrationState.lastCongestionAndRtt =\n      std::move(state);\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n\n  auto peerAddress = server->getConn().peerAddress;\n  auto congestionController = server->getConn().congestionController.get();\n  auto srtt = server->getConn().lossState.srtt;\n  auto lrtt = server->getConn().lossState.lrtt;\n  auto rttvar = server->getConn().lossState.rttvar;\n  auto mrtt = server->getConn().lossState.mrtt;\n\n  folly::SocketAddress newPeer2(\"200.101.102.103\", 2345);\n  deliverData(std::move(packetData), false, &newPeer2);\n\n  EXPECT_TRUE(server->getConn().pendingEvents.pathChallenge);\n\n  EXPECT_EQ(server->getConn().peerAddress, newPeer2);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 2);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.front(), newPeer);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n  EXPECT_EQ(server->getConn().lossState.srtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.lrtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.rttvar, 0us);\n  EXPECT_EQ(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_NE(server->getConn().congestionController.get(), nullptr);\n  EXPECT_NE(server->getConn().congestionController.get(), congestionController);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->peerAddress,\n      clientAddr);\n  EXPECT_EQ(\n      server->getConn()\n          .migrationState.lastCongestionAndRtt->congestionController.get(),\n      congestionController);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->srtt, srtt);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->lrtt, lrtt);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar, rttvar);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->mrtt, mrtt);\n}\n\nTEST_P(QuicServerTransportAllowMigrationTest, MigrateToStaleValidatedPeer) {\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  server->getNonConstConn().migrationState.previousPeerAddresses.push_back(\n      newPeer);\n  CongestionAndRttState state;\n  state.peerAddress = newPeer;\n  state.recordTime = Clock::now() - 2 * kTimeToRetainLastCongestionAndRttState;\n  state.congestionController = ccFactory_->makeCongestionController(\n      server->getNonConstConn(),\n      server->getNonConstConn().transportSettings.defaultCongestionController);\n  state.srtt = 1000us;\n  state.lrtt = 2000us;\n  state.rttvar = 3000us;\n  state.srtt = 800us;\n  server->getNonConstConn().migrationState.lastCongestionAndRtt =\n      std::move(state);\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n\n  auto peerAddress = server->getConn().peerAddress;\n  auto congestionController = server->getConn().congestionController.get();\n  auto srtt = server->getConn().lossState.srtt;\n  auto lrtt = server->getConn().lossState.lrtt;\n  auto rttvar = server->getConn().lossState.rttvar;\n  auto mrtt = server->getConn().lossState.mrtt;\n\n  deliverData(std::move(packetData), false, &newPeer);\n\n  EXPECT_FALSE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n  EXPECT_EQ(server->getConn().lossState.srtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.lrtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.rttvar, 0us);\n  EXPECT_EQ(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_NE(server->getConn().congestionController.get(), nullptr);\n  EXPECT_NE(server->getConn().congestionController.get(), congestionController);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->peerAddress,\n      clientAddr);\n  EXPECT_EQ(\n      server->getConn()\n          .migrationState.lastCongestionAndRtt->congestionController.get(),\n      congestionController);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->srtt, srtt);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->lrtt, lrtt);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar, rttvar);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->mrtt, mrtt);\n}\n\nTEST_F(\n    QuicServerTransportTest,\n    MigrateToValidatePeerCancelsPendingPathChallenge) {\n  server->getNonConstConn().transportSettings.disableMigration = false;\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  auto peerAddress = server->getConn().peerAddress;\n  auto congestionController = server->getConn().congestionController.get();\n  auto srtt = server->getConn().lossState.srtt;\n  auto lrtt = server->getConn().lossState.lrtt;\n  auto rttvar = server->getConn().lossState.rttvar;\n  auto mrtt = server->getConn().lossState.mrtt;\n\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  deliverData(std::move(packetData), false, &newPeer);\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_TRUE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_FALSE(server->getConn().outstandingPathValidation);\n  EXPECT_FALSE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_FALSE(server->pathValidationTimeout().isScheduled());\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n  EXPECT_EQ(server->getConn().lossState.srtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.lrtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.rttvar, 0us);\n  EXPECT_EQ(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_NE(server->getConn().congestionController.get(), nullptr);\n  EXPECT_NE(server->getConn().congestionController.get(), congestionController);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->peerAddress,\n      clientAddr);\n  EXPECT_EQ(\n      server->getConn()\n          .migrationState.lastCongestionAndRtt->congestionController.get(),\n      congestionController);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->srtt, srtt);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->lrtt, lrtt);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar, rttvar);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->mrtt, mrtt);\n\n  auto packetData2 = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      6,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n  deliverData(std::move(packetData2), false);\n  EXPECT_FALSE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_FALSE(server->getConn().outstandingPathValidation);\n  EXPECT_FALSE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_FALSE(server->pathValidationTimeout().isScheduled());\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 0);\n  EXPECT_EQ(server->getConn().lossState.srtt, srtt);\n  EXPECT_EQ(server->getConn().lossState.lrtt, lrtt);\n  EXPECT_EQ(server->getConn().lossState.rttvar, rttvar);\n  EXPECT_EQ(server->getConn().lossState.mrtt, mrtt);\n  EXPECT_EQ(server->getConn().congestionController.get(), congestionController);\n  EXPECT_FALSE(server->getConn().migrationState.lastCongestionAndRtt);\n}\n\nTEST_F(\n    QuicServerTransportTest,\n    MigrateToUnvalidatePeerCancelsOutstandingPathChallenge) {\n  server->getNonConstConn().transportSettings.disableMigration = false;\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  auto peerAddress = server->getConn().peerAddress;\n  auto congestionController = server->getConn().congestionController.get();\n  auto srtt = server->getConn().lossState.srtt;\n  auto lrtt = server->getConn().lossState.lrtt;\n  auto rttvar = server->getConn().lossState.rttvar;\n  auto mrtt = server->getConn().lossState.mrtt;\n\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  deliverData(std::move(packetData), true, &newPeer);\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n  EXPECT_TRUE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_TRUE(server->pathValidationTimeout().isScheduled());\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n  EXPECT_EQ(server->getConn().lossState.srtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.lrtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.rttvar, 0us);\n  EXPECT_EQ(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_NE(server->getConn().congestionController.get(), nullptr);\n  EXPECT_NE(server->getConn().congestionController.get(), congestionController);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->peerAddress,\n      clientAddr);\n  EXPECT_EQ(\n      server->getConn()\n          .migrationState.lastCongestionAndRtt->congestionController.get(),\n      congestionController);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->srtt, srtt);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->lrtt, lrtt);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar, rttvar);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->mrtt, mrtt);\n\n  auto packetData2 = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      6,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n  folly::SocketAddress newPeer2(\"200.101.102.103\", 23456);\n  deliverData(std::move(packetData2), false, &newPeer2);\n  EXPECT_FALSE(server->getConn().outstandingPathValidation);\n  EXPECT_FALSE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_FALSE(server->pathValidationTimeout().isScheduled());\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n  EXPECT_EQ(server->getConn().lossState.srtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.lrtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.rttvar, 0us);\n  EXPECT_EQ(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_NE(server->getConn().congestionController.get(), nullptr);\n  EXPECT_NE(server->getConn().congestionController.get(), congestionController);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->peerAddress,\n      clientAddr);\n  EXPECT_EQ(\n      server->getConn()\n          .migrationState.lastCongestionAndRtt->congestionController.get(),\n      congestionController);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->srtt, srtt);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->lrtt, lrtt);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar, rttvar);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->mrtt, mrtt);\n}\n\nTEST_F(\n    QuicServerTransportTest,\n    MigrateToValidatePeerCancelsOutstandingPathChallenge) {\n  server->getNonConstConn().transportSettings.disableMigration = false;\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  auto peerAddress = server->getConn().peerAddress;\n  auto congestionController = server->getConn().congestionController.get();\n  auto srtt = server->getConn().lossState.srtt;\n  auto lrtt = server->getConn().lossState.lrtt;\n  auto rttvar = server->getConn().lossState.rttvar;\n  auto mrtt = server->getConn().lossState.mrtt;\n\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  deliverData(std::move(packetData), true, &newPeer);\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n  EXPECT_TRUE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_TRUE(server->pathValidationTimeout().isScheduled());\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n  EXPECT_EQ(server->getConn().lossState.srtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.lrtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.rttvar, 0us);\n  EXPECT_EQ(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_NE(server->getConn().congestionController.get(), nullptr);\n  EXPECT_NE(server->getConn().congestionController.get(), congestionController);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->peerAddress,\n      clientAddr);\n  EXPECT_EQ(\n      server->getConn()\n          .migrationState.lastCongestionAndRtt->congestionController.get(),\n      congestionController);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->srtt, srtt);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->lrtt, lrtt);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar, rttvar);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->mrtt, mrtt);\n\n  auto packetData2 = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      6,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n  deliverData(std::move(packetData2));\n  EXPECT_FALSE(server->getConn().outstandingPathValidation);\n  EXPECT_FALSE(server->getConn().pendingEvents.schedulePathValidationTimeout);\n  EXPECT_FALSE(server->pathValidationTimeout().isScheduled());\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 0);\n  EXPECT_EQ(server->getConn().lossState.srtt, srtt);\n  EXPECT_EQ(server->getConn().lossState.lrtt, lrtt);\n  EXPECT_EQ(server->getConn().lossState.rttvar, rttvar);\n  EXPECT_EQ(server->getConn().lossState.mrtt, mrtt);\n  EXPECT_EQ(server->getConn().congestionController.get(), congestionController);\n  EXPECT_FALSE(server->getConn().migrationState.lastCongestionAndRtt);\n}\n\nTEST_F(QuicServerTransportTest, ClientPortChangeNATRebinding) {\n  server->getNonConstConn().transportSettings.disableMigration = false;\n\n  StreamId streamId = server->createBidirectionalStream().value();\n  auto data1 = IOBuf::copyBuffer(\"Aloha\");\n  server->writeChain(streamId, data1->clone(), false);\n  loopForWrites();\n  PacketNum packetNum1 =\n      getFirstOutstandingPacket(\n          server->getNonConstConn(), PacketNumberSpace::AppData)\n          ->packet.header.getPacketSequenceNum();\n  AckBlocks acks = {{packetNum1, packetNum1}};\n  auto packet1 = createAckPacket(\n      server->getNonConstConn(),\n      ++clientNextAppDataPacketNum,\n      acks,\n      PacketNumberSpace::AppData);\n  deliverData(packetToBuf(packet1));\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  auto congestionController = server->getConn().congestionController.get();\n\n  folly::SocketAddress newPeer(clientAddr.getIPAddress(), 23456);\n  deliverData(std::move(packetData), true, &newPeer);\n\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_NE(\n      server->getConn().lossState.srtt, std::chrono::microseconds::zero());\n  EXPECT_NE(\n      server->getConn().lossState.lrtt, std::chrono::microseconds::zero());\n  EXPECT_NE(\n      server->getConn().lossState.rttvar, std::chrono::microseconds::zero());\n  EXPECT_NE(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_EQ(server->getConn().congestionController.get(), congestionController);\n  EXPECT_FALSE(server->getConn().migrationState.lastCongestionAndRtt);\n}\n\nTEST_F(QuicServerTransportTest, ClientAddressChangeNATRebinding) {\n  server->getNonConstConn().transportSettings.disableMigration = false;\n  StreamId streamId = server->createBidirectionalStream().value();\n  auto data1 = IOBuf::copyBuffer(\"Aloha\");\n  server->writeChain(streamId, data1->clone(), false);\n  loopForWrites();\n  PacketNum packetNum1 =\n      getFirstOutstandingPacket(\n          server->getNonConstConn(), PacketNumberSpace::AppData)\n          ->packet.header.getPacketSequenceNum();\n  AckBlocks acks = {{packetNum1, packetNum1}};\n  auto packet1 = createAckPacket(\n      server->getNonConstConn(),\n      ++clientNextAppDataPacketNum,\n      acks,\n      PacketNumberSpace::AppData);\n  deliverData(packetToBuf(packet1));\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  auto congestionController = server->getConn().congestionController.get();\n\n  folly::SocketAddress newPeer(\"127.0.0.100\", 23456);\n  deliverData(std::move(packetData), true, &newPeer);\n\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_NE(server->getConn().lossState.srtt, 0us);\n  EXPECT_NE(server->getConn().lossState.lrtt, 0us);\n  EXPECT_NE(server->getConn().lossState.rttvar, 0us);\n  EXPECT_NE(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_EQ(server->getConn().congestionController.get(), congestionController);\n  EXPECT_FALSE(server->getConn().migrationState.lastCongestionAndRtt);\n}\n\nTEST_F(\n    QuicServerTransportTest,\n    ClientNATRebindingWhilePathValidationOutstanding) {\n  server->getNonConstConn().transportSettings.disableMigration = false;\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n\n  auto congestionController = server->getConn().congestionController.get();\n\n  folly::SocketAddress newPeer(\"200.0.0.100\", 23456);\n  deliverData(std::move(packetData), true, &newPeer);\n\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().lossState.srtt, std::chrono::microseconds::zero());\n  EXPECT_EQ(\n      server->getConn().lossState.lrtt, std::chrono::microseconds::zero());\n  EXPECT_EQ(\n      server->getConn().lossState.rttvar, std::chrono::microseconds::zero());\n  EXPECT_EQ(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_NE(server->getConn().congestionController.get(), nullptr);\n  EXPECT_NE(server->getConn().congestionController.get(), congestionController);\n  EXPECT_TRUE(server->getConn().migrationState.lastCongestionAndRtt);\n\n  auto newCC = server->getConn().congestionController.get();\n  folly::SocketAddress newPeer2(\"200.0.0.200\", 12345);\n  auto data2 = IOBuf::copyBuffer(\"bad data\");\n  auto packetData2 = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n  deliverData(std::move(packetData2), true, &newPeer2);\n\n  EXPECT_TRUE(server->getConn().outstandingPathValidation);\n\n  EXPECT_EQ(server->getConn().peerAddress, newPeer2);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().lossState.srtt, std::chrono::microseconds::zero());\n  EXPECT_EQ(\n      server->getConn().lossState.lrtt, std::chrono::microseconds::zero());\n  EXPECT_EQ(\n      server->getConn().lossState.rttvar, std::chrono::microseconds::zero());\n  EXPECT_EQ(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_EQ(server->getConn().congestionController.get(), newCC);\n  EXPECT_TRUE(server->getConn().migrationState.lastCongestionAndRtt);\n}\n\nTEST_F(QuicServerTransportTest, PingIsTreatedAsRetransmittable) {\n  PingFrame pingFrame;\n  ShortHeader header(\n      ProtectionType::KeyPhaseZero,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++);\n  RegularQuicPacketBuilder builder(\n      server->getConn().udpSendPacketLen,\n      std::move(header),\n      0 /* largestAcked */);\n  builder.encodePacketHeader();\n  writeFrame(pingFrame, builder);\n  auto packet = std::move(builder).buildPacket();\n  deliverData(packetToBuf(packet));\n  EXPECT_TRUE(server->getConn().pendingEvents.scheduleAckTimeout);\n}\n\nTEST_F(QuicServerTransportTest, RecvNewConnectionIdValid) {\n  auto& conn = server->getNonConstConn();\n  conn.transportSettings.selfActiveConnectionIdLimit = 2;\n\n  ShortHeader header(ProtectionType::KeyPhaseZero, *conn.clientConnectionId, 1);\n  RegularQuicPacketBuilder builder(\n      conn.udpSendPacketLen, std::move(header), 0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n  NewConnectionIdFrame newConnId(\n      1, 0, ConnectionId({2, 4, 2, 3}), StatelessResetToken{9, 8, 7, 6});\n  writeSimpleFrame(QuicSimpleFrame(newConnId), builder);\n\n  auto packet = std::move(builder).buildPacket();\n\n  EXPECT_EQ(conn.peerConnectionIds.size(), 1);\n  deliverData(packetToBuf(packet), false);\n  EXPECT_EQ(conn.peerConnectionIds.size(), 2);\n  EXPECT_EQ(conn.peerConnectionIds[1].connId, newConnId.connectionId);\n  EXPECT_EQ(conn.peerConnectionIds[1].sequenceNumber, newConnId.sequenceNumber);\n  EXPECT_EQ(conn.peerConnectionIds[1].token, newConnId.token);\n}\n\nTEST_F(QuicServerTransportTest, RecvNewConnectionIdTooManyReceivedIds) {\n  auto& conn = server->getNonConstConn();\n  conn.transportSettings.selfActiveConnectionIdLimit = 0;\n\n  ShortHeader header(ProtectionType::KeyPhaseZero, *conn.clientConnectionId, 1);\n  RegularQuicPacketBuilder builder(\n      conn.udpSendPacketLen, std::move(header), 0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n  NewConnectionIdFrame newConnId(\n      1, 0, ConnectionId({2, 4, 2, 3}), StatelessResetToken());\n  writeSimpleFrame(QuicSimpleFrame(newConnId), builder);\n\n  auto packet = std::move(builder).buildPacket();\n\n  EXPECT_EQ(conn.peerConnectionIds.size(), 1);\n  deliverData(packetToBuf(packet), false);\n  EXPECT_EQ(conn.peerConnectionIds.size(), 1);\n}\n\nTEST_F(QuicServerTransportTest, RecvNewConnectionIdInvalidRetire) {\n  auto& conn = server->getNonConstConn();\n  conn.transportSettings.selfActiveConnectionIdLimit = 1;\n\n  ShortHeader header(ProtectionType::KeyPhaseZero, *conn.clientConnectionId, 1);\n  RegularQuicPacketBuilder builder(\n      conn.udpSendPacketLen, std::move(header), 0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n  NewConnectionIdFrame newConnId(\n      1, 3, ConnectionId({2, 4, 2, 3}), StatelessResetToken());\n  writeSimpleFrame(QuicSimpleFrame(newConnId), builder);\n\n  auto packet = std::move(builder).buildPacket();\n\n  EXPECT_EQ(conn.peerConnectionIds.size(), 1);\n  EXPECT_THROW(deliverData(packetToBuf(packet), false), std::runtime_error);\n}\n\nTEST_F(QuicServerTransportTest, RecvNewConnectionIdNoopValidDuplicate) {\n  auto& conn = server->getNonConstConn();\n  conn.transportSettings.selfActiveConnectionIdLimit = 1;\n\n  ConnectionId connId2({5, 5, 5, 5});\n  conn.peerConnectionIds.emplace_back(connId2, 1);\n\n  ShortHeader header(ProtectionType::KeyPhaseZero, *conn.clientConnectionId, 1);\n  RegularQuicPacketBuilder builder(\n      conn.udpSendPacketLen, std::move(header), 0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n  NewConnectionIdFrame newConnId(1, 0, connId2, StatelessResetToken());\n  writeSimpleFrame(QuicSimpleFrame(newConnId), builder);\n\n  auto packet = std::move(builder).buildPacket();\n\n  EXPECT_EQ(conn.peerConnectionIds.size(), 2);\n  deliverData(packetToBuf(packet), false);\n  EXPECT_EQ(conn.peerConnectionIds.size(), 2);\n}\n\nTEST_F(QuicServerTransportTest, RecvNewConnectionIdExceptionInvalidDuplicate) {\n  auto& conn = server->getNonConstConn();\n\n  ConnectionId connId2({5, 5, 5, 5});\n  conn.peerConnectionIds.emplace_back(connId2, 1);\n\n  ShortHeader header(ProtectionType::KeyPhaseZero, *conn.clientConnectionId, 1);\n  RegularQuicPacketBuilder builder(\n      conn.udpSendPacketLen, std::move(header), 0 /* largestAcked */);\n  builder.encodePacketHeader();\n  ASSERT_TRUE(builder.canBuildPacket());\n  NewConnectionIdFrame newConnId(2, 0, connId2, StatelessResetToken());\n  writeSimpleFrame(QuicSimpleFrame(newConnId), builder);\n\n  auto packet = std::move(builder).buildPacket();\n\n  EXPECT_EQ(conn.peerConnectionIds.size(), 2);\n  EXPECT_THROW(deliverData(packetToBuf(packet)), std::runtime_error);\n}\n\nclass QuicUnencryptedServerTransportTest : public QuicServerTransportTest {\n public:\n  void setupConnection() override {}\n};\n\nTEST_F(QuicUnencryptedServerTransportTest, FirstPacketProcessedCallback) {\n  getFakeHandshakeLayer()->allowZeroRttKeys();\n  EXPECT_CALL(connCallback, onFirstPeerPacketProcessed()).Times(1);\n  recvClientHello();\n  loopForWrites();\n  AckBlocks acks;\n  acks.insert(0);\n  auto aead = getInitialCipher();\n  auto headerCipher = getInitialHeaderCipher();\n  EXPECT_CALL(connCallback, onFirstPeerPacketProcessed()).Times(0);\n  deliverData(packetToBufCleartext(\n      createAckPacket(\n          server->getNonConstConn(),\n          clientNextInitialPacketNum,\n          acks,\n          PacketNumberSpace::Initial,\n          aead.get()),\n      *aead,\n      *headerCipher,\n      clientNextInitialPacketNum));\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestUnencryptedStream) {\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  PacketNum nextPacket = clientNextInitialPacketNum++;\n  StreamId streamId = 3;\n  auto initialCipher = getInitialCipher();\n  auto headerCipher = getInitialHeaderCipher();\n  auto packetData = packetToBufCleartext(\n      createStreamPacket(\n          *clientConnectionId,\n          *initialDestinationConnectionId,\n          nextPacket,\n          streamId,\n          *data,\n          initialCipher->getCipherOverhead(),\n          0 /* largestAcked */,\n          std::make_pair(LongHeader::Types::Initial, QuicVersion::MVFST)),\n      *initialCipher,\n      *headerCipher,\n      nextPacket);\n  EXPECT_THROW(deliverData(std::move(packetData)), std::runtime_error);\n  EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestUnencryptedAck) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n  AckBlocks acks = {{1, 2}};\n  auto expected = IOBuf::copyBuffer(\"hello\");\n  PacketNum nextPacketNum = clientNextInitialPacketNum++;\n  LongHeader header(\n      LongHeader::Types::Initial,\n      *clientConnectionId,\n      server->getConn().serverConnectionId.value_or(getTestConnectionId(1)),\n      nextPacketNum,\n      QuicVersion::MVFST);\n  RegularQuicPacketBuilder builder(\n      kDefaultUDPSendPacketLen, std::move(header), 0 /* largestAcked */);\n  builder.encodePacketHeader();\n  DCHECK(builder.canBuildPacket());\n  AckFrameMetaData ackData(acks, 0us, 0);\n  writeAckFrame(ackData, builder);\n  auto packet = packetToBufCleartext(\n      std::move(builder).buildPacket(),\n      *getInitialCipher(),\n      *getInitialHeaderCipher(),\n      nextPacketNum);\n  EXPECT_NO_THROW(deliverData(std::move(packet)));\n  std::vector<int> indices =\n      getQLogEventIndices(QLogEventType::PacketDrop, qLogger);\n  EXPECT_EQ(indices.size(), 1);\n\n  auto tmp = std::move(qLogger->logs[indices[0]]);\n  auto event = dynamic_cast<QLogPacketDropEvent*>(tmp.get());\n  EXPECT_EQ(event->packetSize, 45);\n  EXPECT_EQ(event->dropReason, kCipherUnavailable);\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestBadPacketProtectionLevel) {\n  // Version negotiation has no protection level.\n  auto packet = VersionNegotiationPacketBuilder(\n                    *clientConnectionId /* src */,\n                    getTestConnectionId(1) /* dest */,\n                    {QuicVersion::MVFST})\n                    .buildPacket();\n  EXPECT_CALL(*transportInfoCb_, onPacketDropped(_));\n  deliverData(packet.second->clone());\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestBadCleartextEncryption) {\n  FizzCryptoFactory cryptoFactory;\n  PacketNum nextPacket = clientNextInitialPacketNum++;\n  auto aead = cryptoFactory.getServerInitialCipher(\n      *clientConnectionId, QuicVersion::MVFST);\n  auto packetData = packetToBufCleartext(\n      createInitialCryptoPacket(\n          *clientConnectionId,\n          *initialDestinationConnectionId,\n          nextPacket,\n          QuicVersion::MVFST,\n          *IOBuf::copyBuffer(\"CHLO\"),\n          *aead,\n          0 /* largestAcked */),\n      *aead,\n      *getInitialHeaderCipher(),\n      nextPacket);\n  EXPECT_CALL(*transportInfoCb_, onPacketDropped(_));\n  deliverData(std::move(packetData));\n  // If crypto data was processed, we would have generated some writes.\n  EXPECT_NE(server->getConn().readCodec, nullptr);\n  EXPECT_TRUE(server->getConn().cryptoState->initialStream.writeBuffer.empty());\n  EXPECT_TRUE(server->getConn()\n                  .cryptoState->initialStream.retransmissionBuffer.empty());\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestPendingZeroRttData) {\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  size_t expectedPendingLen =\n      server->getConn().transportSettings.maxPacketsToBuffer;\n  for (size_t i = 0; i < expectedPendingLen + 10; ++i) {\n    StreamId streamId = static_cast<StreamId>(i);\n    auto packetData = packetToBuf(createStreamPacket(\n        *clientConnectionId,\n        server->getConn().serverConnectionId.value_or(getTestConnectionId(1)),\n        clientNextAppDataPacketNum++,\n        streamId,\n        *data,\n        0 /* cipherOverhead */,\n        0 /* largestAcked */,\n        std::make_pair(LongHeader::Types::ZeroRtt, QuicVersion::MVFST)));\n    EXPECT_CALL(*transportInfoCb_, onPacketDropped(_));\n    deliverData(std::move(packetData));\n  }\n  EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n  EXPECT_EQ(server->getConn().pendingZeroRttData->size(), expectedPendingLen);\n\n  server->getNonConstConn().pendingZeroRttData->clear();\n  deliverData(IOBuf::create(0));\n  EXPECT_TRUE(server->getConn().pendingZeroRttData->empty());\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestPendingOneRttData) {\n  recvClientHello();\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  size_t expectedPendingLen =\n      server->getConn().transportSettings.maxPacketsToBuffer;\n  for (size_t i = 0; i < expectedPendingLen + 10; ++i) {\n    StreamId streamId = static_cast<StreamId>(i);\n    auto packetData = packetToBuf(createStreamPacket(\n        *clientConnectionId,\n        *server->getConn().serverConnectionId,\n        clientNextAppDataPacketNum++,\n        streamId,\n        *data,\n        0 /* cipherOverhead */,\n        0 /* largestAcked */));\n    EXPECT_CALL(*transportInfoCb_, onPacketDropped(_));\n    deliverData(std::move(packetData));\n  }\n  EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n  EXPECT_EQ(server->getConn().pendingOneRttData->size(), expectedPendingLen);\n\n  server->getNonConstConn().pendingOneRttData->clear();\n  deliverData(IOBuf::create(0));\n  EXPECT_TRUE(server->getConn().pendingOneRttData->empty());\n}\n\nTEST_F(\n    QuicUnencryptedServerTransportTest,\n    TestReceiveClientFinishedFromChangedPeerAddress) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n  recvClientHello();\n\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n\n  try {\n    recvClientFinished(true, &newPeer);\n  } catch (const std::runtime_error& ex) {\n    EXPECT_EQ(std::string(ex.what()), \"Invalid migration\");\n  }\n  EXPECT_TRUE(server->getConn().localConnectionError);\n  EXPECT_EQ(\n      server->getConn().localConnectionError->second,\n      \"Migration not allowed during handshake\");\n  EXPECT_TRUE(server->isClosed());\n\n  std::vector<int> indices =\n      getQLogEventIndices(QLogEventType::PacketDrop, qLogger);\n  EXPECT_EQ(indices.size(), 1);\n  auto tmp = std::move(qLogger->logs[indices[0]]);\n  auto event = dynamic_cast<QLogPacketDropEvent*>(tmp.get());\n  EXPECT_EQ(event->packetSize, 44);\n  EXPECT_EQ(\n      event->dropReason,\n      QuicTransportStatsCallback::toString(\n          PacketDropReason::PEER_ADDRESS_CHANGE));\n}\n\nTEST_F(\n    QuicUnencryptedServerTransportTest,\n    ReceiveHandshakePacketFromChangedPeerAddress) {\n  server->getNonConstConn().transportSettings.disableMigration = false;\n\n  recvClientHello();\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n\n  try {\n    recvClientFinished(true, &newPeer);\n  } catch (const std::runtime_error& ex) {\n    EXPECT_EQ(std::string(ex.what()), \"Invalid migration\");\n  }\n  EXPECT_TRUE(server->getConn().localConnectionError);\n  EXPECT_EQ(\n      server->getConn().localConnectionError->second,\n      \"Migration not allowed during handshake\");\n}\n\nTEST_F(\n    QuicUnencryptedServerTransportTest,\n    ReceiveZeroRttPacketFromChangedPeerAddress) {\n  server->getNonConstConn().transportSettings.disableMigration = false;\n  fakeHandshake->allowZeroRttKeys();\n\n  recvClientHello();\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  StreamId streamId = 2;\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */,\n      std::make_pair(\n          LongHeader::Types::ZeroRtt, server->getConn().supportedVersions[0]),\n      false));\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  try {\n    deliverData(std::move(packetData), true, &newPeer);\n  } catch (const std::runtime_error& ex) {\n    EXPECT_EQ(std::string(ex.what()), \"Invalid migration\");\n  }\n  EXPECT_TRUE(server->getConn().localConnectionError);\n  EXPECT_EQ(\n      server->getConn().localConnectionError->second,\n      \"Migration not allowed during handshake\");\n}\n\nTEST_F(\n    QuicUnencryptedServerTransportTest,\n    TestNoCipherProcessPendingOneRttDataFromChangedAddress) {\n  recvClientHello();\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  StreamId streamId = 2;\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n  folly::SocketAddress newPeer(\"100.101.102.103\", 23456);\n  deliverData(std::move(packetData), true, &newPeer);\n  EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n  EXPECT_EQ(server->getConn().pendingOneRttData->size(), 1);\n\n  try {\n    recvClientFinished();\n  } catch (const std::runtime_error& ex) {\n    EXPECT_EQ(std::string(ex.what()), \"Invalid migration\");\n  }\n  EXPECT_TRUE(server->getConn().localConnectionError);\n  EXPECT_EQ(\n      server->getConn().localConnectionError->second, \"Migration disabled\");\n  EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n  EXPECT_EQ(server->getConn().pendingZeroRttData, nullptr);\n  EXPECT_EQ(server->getConn().pendingOneRttData, nullptr);\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestWriteHandshakeAndZeroRtt) {\n  getFakeHandshakeLayer()->allowZeroRttKeys();\n  // This should trigger derivation of keys.\n  recvClientHello();\n\n  auto streamId = server->createBidirectionalStream().value();\n  server->writeChain(streamId, IOBuf::copyBuffer(\"hello\"), true);\n  loopForWrites();\n  auto clientCodec = makeClientEncryptedCodec(true);\n\n  size_t numCryptoFrames = 0;\n  size_t numNonCryptoFrames = 0;\n  EXPECT_GT(serverWrites.size(), 1);\n  AckStates ackStates;\n  for (auto& write : serverWrites) {\n    auto packetQueue = bufToQueue(write->clone());\n    auto result = clientCodec->parsePacket(packetQueue, ackStates);\n    auto& regularPacket = *result.regularPacket();\n    ProtectionType protectionType = regularPacket.header.getProtectionType();\n    bool handshakePacket = protectionType == ProtectionType::Initial ||\n        protectionType == ProtectionType::Handshake;\n    EXPECT_GE(regularPacket.frames.size(), 1);\n    bool hasCryptoFrame = false;\n    bool hasNonCryptoStream = false;\n    for (auto& frame : regularPacket.frames) {\n      hasCryptoFrame |= frame.asReadCryptoFrame() != nullptr;\n      hasNonCryptoStream |= frame.asReadStreamFrame() != nullptr;\n    }\n    if (hasCryptoFrame) {\n      EXPECT_TRUE(handshakePacket);\n      numCryptoFrames++;\n    }\n    if (hasNonCryptoStream) {\n      EXPECT_FALSE(handshakePacket);\n      numNonCryptoFrames++;\n    }\n  }\n  EXPECT_GE(numCryptoFrames, 1);\n  EXPECT_GE(numNonCryptoFrames, 1);\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestEncryptedDataBeforeCFIN) {\n  getFakeHandshakeLayer()->allowZeroRttKeys();\n  // This should trigger derivation of keys.\n  recvClientHello();\n\n  StreamId streamId = 4;\n  recvEncryptedStream(streamId, *IOBuf::copyBuffer(\"hello\"));\n\n  auto stream = server->getNonConstConn().streamManager->getStream(streamId);\n  ASSERT_TRUE(stream->readBuffer.empty());\n}\n\nTEST_F(\n    QuicUnencryptedServerTransportTest,\n    TestClearInFlightBytesLimitationAfterCFIN) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n  server->getNonConstConn().transportSettings.zeroRttSourceTokenMatchingPolicy =\n      ZeroRttSourceTokenMatchingPolicy::LIMIT_IF_NO_EXACT_MATCH;\n  getFakeHandshakeLayer()->allowZeroRttKeys();\n  auto originalUdpSize = server->getConn().udpSendPacketLen;\n\n  setupClientReadCodec();\n\n  recvClientHello();\n  ASSERT_TRUE(server->getNonConstConn().writableBytesLimit.has_value());\n  EXPECT_EQ(\n      *server->getNonConstConn().writableBytesLimit,\n      server->getConn().transportSettings.limitedCwndInMss * originalUdpSize);\n\n  recvClientFinished();\n  loopForWrites();\n  EXPECT_EQ(server->getConn().writableBytesLimit, folly::none);\n\n  std::vector<int> indices =\n      getQLogEventIndices(QLogEventType::TransportStateUpdate, qLogger);\n  EXPECT_EQ(indices.size(), 4);\n  std::array<::std::string, 4> updateArray = {\n      kDerivedZeroRttReadCipher,\n      kDerivedOneRttWriteCipher,\n      kTransportReady,\n      kDerivedOneRttReadCipher};\n  for (int i = 0; i < 4; ++i) {\n    auto tmp = std::move(qLogger->logs[indices[i]]);\n    auto event = dynamic_cast<QLogTransportStateUpdateEvent*>(tmp.get());\n    EXPECT_EQ(event->update, updateArray[i]);\n  }\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestSendHandshakeDone) {\n  getFakeHandshakeLayer()->allowZeroRttKeys();\n  setupClientReadCodec();\n  recvClientHello(true, QuicVersion::QUIC_DRAFT);\n  recvClientFinished(true, nullptr, QuicVersion::QUIC_DRAFT);\n  auto& packets = server->getConn().outstandings.packets;\n  ASSERT_FALSE(packets.empty());\n  int numHandshakeDone = 0;\n  for (auto& p : packets) {\n    for (auto& f : p.packet.frames) {\n      auto s = f.asQuicSimpleFrame();\n      if (s) {\n        if (s->asHandshakeDoneFrame()) {\n          numHandshakeDone++;\n        }\n      }\n    }\n  }\n  EXPECT_EQ(numHandshakeDone, 1);\n}\n\nTEST_F(\n    QuicUnencryptedServerTransportTest,\n    IncreaseLimitAfterReceivingNewPacket) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n  getFakeHandshakeLayer()->allowZeroRttKeys();\n  server->getNonConstConn().transportSettings.zeroRttSourceTokenMatchingPolicy =\n      ZeroRttSourceTokenMatchingPolicy::LIMIT_IF_NO_EXACT_MATCH;\n\n  auto originalUdpSize = server->getConn().udpSendPacketLen;\n  setupClientReadCodec();\n\n  recvClientHello();\n  EXPECT_EQ(\n      *server->getNonConstConn().writableBytesLimit,\n      server->getConn().transportSettings.limitedCwndInMss * originalUdpSize);\n\n  recvClientHello();\n\n  // in tests the udp packet length changes\n  auto expectedLen =\n      server->getConn().transportSettings.limitedCwndInMss * originalUdpSize +\n      server->getConn().transportSettings.limitedCwndInMss *\n          server->getConn().udpSendPacketLen;\n  EXPECT_NE(originalUdpSize, server->getConn().udpSendPacketLen);\n  EXPECT_EQ(*server->getNonConstConn().writableBytesLimit, expectedLen);\n  std::vector<int> indices =\n      getQLogEventIndices(QLogEventType::TransportStateUpdate, qLogger);\n  EXPECT_EQ(indices.size(), 3);\n  std::array<::std::string, 3> updateArray = {\n      kDerivedZeroRttReadCipher, kDerivedOneRttWriteCipher, kTransportReady};\n  for (int i = 0; i < 3; ++i) {\n    auto tmp = std::move(qLogger->logs[indices[i]]);\n    auto event = dynamic_cast<QLogTransportStateUpdateEvent*>(tmp.get());\n    EXPECT_EQ(event->update, updateArray[i]);\n  }\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, MaxReceivePacketSizeTooLarge) {\n  getFakeHandshakeLayer()->allowZeroRttKeys();\n  auto originalUdpSize = server->getConn().udpSendPacketLen;\n  fakeHandshake->maxRecvPacketSize = 4096;\n  setupClientReadCodec();\n  recvClientHello();\n  EXPECT_NE(originalUdpSize, server->getConn().udpSendPacketLen);\n  EXPECT_EQ(server->getConn().udpSendPacketLen, kDefaultUDPSendPacketLen);\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestGarbageData) {\n  auto qLogger = std::make_shared<FileQLogger>(VantagePoint::Server);\n  server->getNonConstConn().qLogger = qLogger;\n\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  PacketNum nextPacket = clientNextInitialPacketNum++;\n  auto aead = getInitialCipher();\n  auto headerCipher = getInitialHeaderCipher();\n  auto packet = createCryptoPacket(\n      *clientConnectionId,\n      *clientConnectionId,\n      nextPacket,\n      QuicVersion::QUIC_DRAFT,\n      ProtectionType::Initial,\n      *IOBuf::copyBuffer(\"CHLO\"),\n      *aead,\n      0 /* largestAcked */);\n  auto packetData =\n      packetToBufCleartext(packet, *aead, *headerCipher, nextPacket);\n  packetData->prependChain(IOBuf::copyBuffer(\"garbage in\"));\n  deliverData(std::move(packetData));\n  EXPECT_NE(server->getConn().readCodec, nullptr);\n  EXPECT_NE(server->getConn().initialWriteCipher, nullptr);\n\n  std::vector<int> indices =\n      getQLogEventIndices(QLogEventType::PacketBuffered, qLogger);\n  EXPECT_EQ(indices.size(), 1);\n  auto tmp = std::move(qLogger->logs[indices[0]]);\n  auto event = dynamic_cast<QLogPacketBufferedEvent*>(tmp.get());\n  EXPECT_EQ(event->packetNum, nextPacket);\n  EXPECT_EQ(event->protectionType, ProtectionType::KeyPhaseZero);\n  EXPECT_EQ(event->packetSize, 10);\n}\n\nBuf getHandshakePacketWithFrame(\n    QuicWriteFrame frame,\n    ConnectionId connId,\n    Aead& clientWriteCipher,\n    PacketNumberCipher& headerCipher) {\n  PacketNum clientPacketNum = folly::Random::rand32();\n  LongHeader header(\n      LongHeader::Types::Handshake,\n      connId,\n      connId,\n      clientPacketNum,\n      QuicVersion::MVFST);\n  RegularQuicPacketBuilder builder(\n      kDefaultUDPSendPacketLen,\n      std::move(header),\n      clientPacketNum / 2 /* largestAcked */);\n  builder.encodePacketHeader();\n  builder.accountForCipherOverhead(clientWriteCipher.getCipherOverhead());\n  writeFrame(std::move(frame), builder);\n  return packetToBufCleartext(\n      std::move(builder).buildPacket(),\n      clientWriteCipher,\n      headerCipher,\n      clientPacketNum);\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestNotAllowedInUnencryptedPacket) {\n  // This should trigger derivation of keys.\n  recvClientHello();\n\n  StreamId streamId = 4;\n  auto data = IOBuf::copyBuffer(\"data\");\n\n  EXPECT_THROW(\n      deliverData(getHandshakePacketWithFrame(\n          MaxStreamDataFrame(streamId, 100),\n          *clientConnectionId,\n          *getInitialCipher(),\n          *getInitialHeaderCipher())),\n      std::runtime_error);\n  EXPECT_TRUE(server->error());\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, TestCloseWhileAsyncPending) {\n  folly::EventBase testLooper;\n  setupClientReadCodec();\n  getFakeHandshakeLayer()->initialize(&testLooper, server.get());\n\n  recvClientHello();\n  testLooper.loop();\n\n  // Make sure the test looper worked.\n  IOBufEqualTo eq;\n  EXPECT_TRUE(eq(getCryptoStreamData(), IOBuf::copyBuffer(\"SHLO\")));\n\n  recvClientFinished();\n\n  server->close(std::make_pair(\n      QuicErrorCode(GenericApplicationErrorCode::UNKNOWN),\n      std::string(\"hello\")));\n  EXPECT_TRUE(server->isClosed());\n  testLooper.loop();\n\n  EXPECT_EQ(server->getConn().oneRttWriteCipher, nullptr);\n\n  StreamId streamId = 4;\n  auto data = IOBuf::copyBuffer(\"data\");\n\n  EXPECT_THROW(\n      deliverData(getHandshakePacketWithFrame(\n          MaxStreamDataFrame(streamId, 100),\n          *clientConnectionId,\n          *getInitialCipher(),\n          *getInitialHeaderCipher())),\n      std::runtime_error);\n}\n\nstruct FizzHandshakeParam {\n  FizzHandshakeParam(bool argCHLOSync, bool argCFINSync, bool argAcceptZeroRtt)\n      : chloSync(argCHLOSync),\n        cfinSync(argCFINSync),\n        acceptZeroRtt(argAcceptZeroRtt) {}\n  bool chloSync;\n  bool cfinSync;\n  bool acceptZeroRtt;\n};\n\nclass QuicServerTransportPendingDataTest\n    : public QuicUnencryptedServerTransportTest,\n      public WithParamInterface<FizzHandshakeParam> {\n public:\n  ~QuicServerTransportPendingDataTest() override {\n    loopForWrites();\n  }\n\n  void initializeServerHandshake() override {\n    fakeHandshake = new FakeServerHandshake(\n        server->getNonConstConn(),\n        FizzServerQuicHandshakeContext::Builder().build(),\n        GetParam().chloSync,\n        GetParam().cfinSync);\n    if (GetParam().acceptZeroRtt) {\n      fakeHandshake->allowZeroRttKeys();\n    }\n  }\n};\n\nINSTANTIATE_TEST_CASE_P(\n    QuicServerTransportPendingDataTests,\n    QuicServerTransportPendingDataTest,\n    Values(\n        FizzHandshakeParam(false, false, false),\n        FizzHandshakeParam(false, false, true),\n        FizzHandshakeParam(false, true, false),\n        FizzHandshakeParam(false, true, true),\n        FizzHandshakeParam(true, false, false),\n        FizzHandshakeParam(true, false, true),\n        FizzHandshakeParam(true, true, false),\n        FizzHandshakeParam(true, true, true)));\n\nTEST_P(\n    QuicServerTransportPendingDataTest,\n    TestNoCipherProcessPendingZeroRttData) {\n  server->getNonConstConn().qLogger =\n      std::make_shared<quic::FileQLogger>(VantagePoint::Server);\n  recvClientHello(false);\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  StreamId streamId = 2;\n  // Write packet with zero rtt keys\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */,\n      std::make_pair(\n          LongHeader::Types::ZeroRtt, server->getConn().supportedVersions[0]),\n      false));\n  deliverData(std::move(packetData), false);\n  if (GetParam().acceptZeroRtt) {\n    if (!GetParam().chloSync) {\n      EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n      EXPECT_EQ(server->getConn().pendingZeroRttData->size(), 1);\n      loopForWrites();\n    }\n    EXPECT_EQ(server->getConn().streamManager->streamCount(), 1);\n    EXPECT_EQ(server->getConn().pendingZeroRttData, nullptr);\n  } else {\n    EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n    EXPECT_EQ(server->getConn().pendingZeroRttData->size(), 1);\n  }\n  EXPECT_EQ(\n      server->getConn().qLogger->scid, server->getConn().serverConnectionId);\n}\n\nTEST_P(\n    QuicServerTransportPendingDataTest,\n    TestNoCipherProcessPendingOneRttData) {\n  server->getNonConstConn().qLogger =\n      std::make_shared<quic::FileQLogger>(VantagePoint::Server);\n  recvClientHello();\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  StreamId streamId = 2;\n  // Write packet with zero rtt keys\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */,\n      folly::none,\n      false));\n  deliverData(std::move(packetData));\n  EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n  EXPECT_EQ(server->getConn().pendingOneRttData->size(), 1);\n\n  recvClientFinished();\n  EXPECT_EQ(server->getConn().streamManager->streamCount(), 1);\n  EXPECT_EQ(server->getConn().pendingZeroRttData, nullptr);\n  EXPECT_EQ(server->getConn().pendingOneRttData, nullptr);\n  EXPECT_EQ(\n      server->getConn().qLogger->scid, server->getConn().serverConnectionId);\n}\n\nTEST_P(\n    QuicServerTransportPendingDataTest,\n    TestNoCipherProcessingZeroAndOneRttData) {\n  server->getNonConstConn().qLogger =\n      std::make_shared<quic::FileQLogger>(VantagePoint::Server);\n  recvClientHello(false);\n  auto data = IOBuf::copyBuffer(\"bad data\");\n  StreamId streamId = 2;\n  // Write packet with zero rtt keys\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */,\n      std::make_pair(\n          LongHeader::Types::ZeroRtt, server->getConn().supportedVersions[0]),\n      false));\n  deliverData(std::move(packetData), false);\n  if (GetParam().acceptZeroRtt) {\n    if (!GetParam().chloSync) {\n      EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n      EXPECT_EQ(server->getConn().pendingZeroRttData->size(), 1);\n      loopForWrites();\n    }\n    EXPECT_EQ(server->getConn().streamManager->streamCount(), 1);\n    EXPECT_EQ(server->getConn().pendingZeroRttData, nullptr);\n  } else {\n    EXPECT_EQ(server->getConn().streamManager->streamCount(), 0);\n    EXPECT_EQ(server->getConn().pendingZeroRttData->size(), 1);\n  }\n  loopForWrites();\n\n  StreamId streamId2 = 4;\n  // Write packet with zero rtt keys\n  auto packetData2 = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      streamId2,\n      *data,\n      0 /* cipherOverhead */,\n      0 /* largestAcked */));\n  deliverData(std::move(packetData2));\n  EXPECT_EQ(\n      server->getConn().streamManager->streamCount(),\n      GetParam().acceptZeroRtt ? 1 : 0);\n  EXPECT_EQ(server->getConn().pendingOneRttData->size(), 1);\n\n  recvClientFinished();\n  EXPECT_EQ(\n      server->getConn().streamManager->streamCount(),\n      GetParam().acceptZeroRtt ? 2 : 1);\n  EXPECT_EQ(server->getConn().pendingZeroRttData, nullptr);\n  EXPECT_EQ(server->getConn().pendingOneRttData, nullptr);\n  EXPECT_EQ(\n      server->getConn().qLogger->scid, server->getConn().serverConnectionId);\n}\n\n/**\n * Test handshake process with different parameters:\n * sync CHLO processing, sync CFIN processing, accept 0-rtt\n */\nclass QuicServerTransportHandshakeTest\n    : public QuicUnencryptedServerTransportTest,\n      public WithParamInterface<FizzHandshakeParam> {\n public:\n  ~QuicServerTransportHandshakeTest() override {\n    // We need an extra pump here for some reason.\n    loopForWrites();\n  }\n\n  void initializeServerHandshake() override {\n    fakeHandshake = new FakeServerHandshake(\n        server->getNonConstConn(),\n        FizzServerQuicHandshakeContext::Builder().build(),\n        GetParam().chloSync,\n        GetParam().cfinSync);\n    if (GetParam().acceptZeroRtt) {\n      fakeHandshake->allowZeroRttKeys();\n    }\n  }\n\n  void expectWriteNewSessionTicket() override {\n    std::string appParams(\"APP params\");\n    server->setEarlyDataAppParamsFunctions(\n        [](const folly::Optional<std::string>&, const Buf&) { return false; },\n        [=]() -> Buf { return folly::IOBuf::copyBuffer(appParams); });\n    EXPECT_CALL(*getFakeHandshakeLayer(), writeNewSessionTicket(_))\n        .WillOnce(Invoke([=](const AppToken& appToken) {\n          auto& params = appToken.transportParams.parameters;\n\n          auto initialMaxData = *getIntegerParameter(\n              TransportParameterId::initial_max_data, params);\n          EXPECT_EQ(\n              initialMaxData,\n              server->getConn()\n                  .transportSettings.advertisedInitialConnectionWindowSize);\n\n          auto initialMaxStreamDataBidiLocal = *getIntegerParameter(\n              TransportParameterId::initial_max_stream_data_bidi_local, params);\n          auto initialMaxStreamDataBidiRemote = *getIntegerParameter(\n              TransportParameterId::initial_max_stream_data_bidi_remote,\n              params);\n          auto initialMaxStreamDataUni = *getIntegerParameter(\n              TransportParameterId::initial_max_stream_data_bidi_remote,\n              params);\n          EXPECT_EQ(\n              initialMaxStreamDataBidiLocal,\n              server->getConn()\n                  .transportSettings\n                  .advertisedInitialBidiLocalStreamWindowSize);\n          EXPECT_EQ(\n              initialMaxStreamDataBidiRemote,\n              server->getConn()\n                  .transportSettings\n                  .advertisedInitialBidiRemoteStreamWindowSize);\n          EXPECT_EQ(\n              initialMaxStreamDataUni,\n              server->getConn()\n                  .transportSettings.advertisedInitialUniStreamWindowSize);\n\n          auto initialMaxStreamsBidi = *getIntegerParameter(\n              TransportParameterId::initial_max_streams_bidi, params);\n          auto initialMaxStreamsUni = *getIntegerParameter(\n              TransportParameterId::initial_max_streams_uni, params);\n          EXPECT_EQ(\n              initialMaxStreamsBidi,\n              server->getConn()\n                  .transportSettings.advertisedInitialMaxStreamsBidi);\n          EXPECT_EQ(\n              initialMaxStreamsUni,\n              server->getConn()\n                  .transportSettings.advertisedInitialMaxStreamsUni);\n\n          auto maxRecvPacketSize = *getIntegerParameter(\n              TransportParameterId::max_packet_size, params);\n          EXPECT_EQ(\n              maxRecvPacketSize,\n              server->getConn().transportSettings.maxRecvPacketSize);\n\n          EXPECT_THAT(\n              appToken.sourceAddresses, ContainerEq(expectedSourceToken_));\n\n          EXPECT_TRUE(folly::IOBufEqualTo()(\n              appToken.appParams, folly::IOBuf::copyBuffer(appParams)));\n        }));\n  }\n\n  void testSetupConnection() {\n    // If 0-rtt is accepted, one rtt write cipher will be available after CHLO\n    // is processed\n    if (GetParam().acceptZeroRtt) {\n      EXPECT_CALL(connCallback, onTransportReady());\n    }\n    recvClientHello();\n\n    // If 0-rtt is disabled, one rtt write cipher will be available after CFIN\n    // is processed\n    if (!GetParam().acceptZeroRtt) {\n      EXPECT_CALL(connCallback, onTransportReady());\n    }\n    // onConnectionIdBound is always invoked after CFIN is processed\n    EXPECT_CALL(routingCallback, onConnectionIdBound(_));\n    // NST is always written after CFIN is processed\n    expectWriteNewSessionTicket();\n    recvClientFinished();\n  }\n\n protected:\n  std::vector<folly::IPAddress> expectedSourceToken_;\n};\n\nINSTANTIATE_TEST_CASE_P(\n    QuicServerTransportHandshakeTests,\n    QuicServerTransportHandshakeTest,\n    Values(\n        FizzHandshakeParam(false, false, false),\n        FizzHandshakeParam(false, false, true),\n        FizzHandshakeParam(false, true, false),\n        FizzHandshakeParam(false, true, true),\n        FizzHandshakeParam(true, false, false),\n        FizzHandshakeParam(true, false, true),\n        FizzHandshakeParam(true, true, false),\n        FizzHandshakeParam(true, true, true)));\n\nTEST_P(\n    QuicServerTransportHandshakeTest,\n    TestConnectionSetupWithoutSourceTokenInPsk) {\n  serverCtx->setSendNewSessionTicket(false);\n  expectedSourceToken_ = {clientAddr.getIPAddress()};\n  testSetupConnection();\n}\n\nTEST_P(\n    QuicServerTransportHandshakeTest,\n    TestConnectionSetupWithSourceTokenInPsk) {\n  serverCtx->setSendNewSessionTicket(false);\n  auto ipAddr = folly::IPAddress(\"1.2.3.4\");\n  getFakeHandshakeLayer()->setSourceTokens({ipAddr});\n  if (GetParam().acceptZeroRtt) {\n    expectedSourceToken_ = {ipAddr, clientAddr.getIPAddress()};\n  } else {\n    expectedSourceToken_ = {clientAddr.getIPAddress()};\n  }\n  testSetupConnection();\n}\n\nTEST_P(QuicServerTransportHandshakeTest, TestD6DStartCallback) {\n  Observer::Config config = {};\n  config.pmtuEvents = true;\n  auto mockObserver = std::make_unique<MockObserver>(config);\n  server->addObserver(mockObserver.get());\n  // Set oneRttReader so that maybeStartD6DPriobing passes its check\n  auto codec = std::make_unique<QuicReadCodec>(QuicNodeType::Server);\n  codec->setOneRttReadCipher(createNoOpAead());\n  server->getNonConstConn().readCodec = std::move(codec);\n  // And the state too\n  server->getNonConstConn().d6d.state = D6DMachineState::BASE;\n  EXPECT_CALL(*mockObserver, pmtuProbingStarted(_)).Times(1);\n  // CHLO should be enough to trigger probing\n  recvClientHello();\n  server->removeObserver(mockObserver.get());\n}\n\nTEST_F(QuicUnencryptedServerTransportTest, DuplicateOneRttWriteCipher) {\n  setupClientReadCodec();\n  recvClientHello();\n  recvClientFinished();\n  loopForWrites();\n  try {\n    recvClientHello();\n    recvClientFinished();\n    FAIL();\n  } catch (const std::runtime_error& ex) {\n    EXPECT_THAT(ex.what(), HasSubstr(\"Crypto error\"));\n  }\n  EXPECT_TRUE(server->isClosed());\n}\n\nTEST_F(QuicServerTransportTest, TestRegisterAndHandleTransportKnobParams) {\n  int flag = 0;\n  server->registerKnobParamHandler(\n      199, [&](QuicServerConnectionState* /* server_conn */, uint64_t val) {\n        EXPECT_EQ(val, 10);\n        flag = 1;\n      });\n  server->registerKnobParamHandler(\n      200,\n      [&](QuicServerConnectionState* /* server_conn */, uint64_t /* val */) {\n        flag = 2;\n      });\n  server->handleKnobParams({\n      {199, 10},\n      {201, 20},\n  });\n\n  EXPECT_EQ(flag, 1);\n\n  // ovewrite will fail, the new handler won't be called\n  server->registerKnobParamHandler(\n      199, [&](QuicServerConnectionState* /* server_conn */, uint64_t val) {\n        EXPECT_EQ(val, 30);\n        flag = 3;\n      });\n\n  server->handleKnobParams({\n      {199, 10},\n      {201, 20},\n  });\n  EXPECT_EQ(flag, 1);\n}\n\nTEST_F(QuicServerTransportTest, TestRegisterPMTUZeroBlackholeDetection) {\n  server->handleKnobParams(\n      {{static_cast<uint64_t>(\n            TransportKnobParamId::ZERO_PMTU_BLACKHOLE_DETECTION),\n        1}});\n  EXPECT_TRUE(server->getConn().d6d.noBlackholeDetection);\n}\n\nclass QuicServerTransportForciblySetUDUPayloadSizeTest\n    : public QuicServerTransportTest {\n public:\n  bool getCanIgnorePathMTU() override {\n    return false;\n  }\n};\n\nTEST_F(\n    QuicServerTransportForciblySetUDUPayloadSizeTest,\n    TestHandleTransportKnobParamForciblySetUDPPayloadSize) {\n  EXPECT_LT(server->getConn().udpSendPacketLen, 1452);\n  server->handleKnobParams(\n      {{static_cast<uint64_t>(\n            TransportKnobParamId::FORCIBLY_SET_UDP_PAYLOAD_SIZE),\n        1}});\n  EXPECT_EQ(server->getConn().udpSendPacketLen, 1452);\n}\n\n} // namespace test\n} // namespace quic\n"], "filenames": ["quic/server/state/ServerStateMachine.cpp", "quic/server/test/QuicServerTransportTest.cpp"], "buggy_code_start_loc": [314, 4267], "buggy_code_end_loc": [315, 4267], "fixing_code_start_loc": [314, 4268], "fixing_code_end_loc": [318, 4283], "type": "CWE-617", "message": "A packet of death scenario is possible in mvfst via a specially crafted message during a QUIC session, which causes a crash via a failed assertion. Per QUIC specification, this particular message should be treated as a connection error. This issue affects mvfst versions prior to commit a67083ff4b8dcbb7ee2839da6338032030d712b0 and proxygen versions prior to v2021.03.15.00.", "other": {"cve": {"id": "CVE-2021-24029", "sourceIdentifier": "cve-assign@fb.com", "published": "2021-03-15T22:15:13.530", "lastModified": "2021-03-23T16:34:55.963", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A packet of death scenario is possible in mvfst via a specially crafted message during a QUIC session, which causes a crash via a failed assertion. Per QUIC specification, this particular message should be treated as a connection error. This issue affects mvfst versions prior to commit a67083ff4b8dcbb7ee2839da6338032030d712b0 and proxygen versions prior to v2021.03.15.00."}, {"lang": "es", "value": "Un paquete de escenario death es posible en mvfst por medio de un mensaje especialmente dise\u00f1ado durante una sesi\u00f3n QUIC, lo que causa un bloqueo por medio de un fallo de aserci\u00f3n.&#xa0;Seg\u00fan la especificaci\u00f3n QUIC, este mensaje en particular debe tratarse como un error de conexi\u00f3n.&#xa0;Este problema afecta a las versiones de mvfst anteriores al commit a67083ff4b8dcbb7ee2839da6338032030d712b0 y versiones de proxygen anteriores a v2021.03.15.00"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:mvfst:*:*:*:*:*:*:*:*", "versionEndExcluding": "2021-03-13", "matchCriteriaId": "D48024F5-694D-40A0-AAC5-8F3E127E1CCF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:proxygen:*:*:*:*:*:*:*:*", "versionEndExcluding": "2021.03.15.00", "matchCriteriaId": "4855309D-53DF-44FE-B80D-D0D3E2425D32"}]}]}], "references": [{"url": "https://github.com/facebookincubator/mvfst/commit/a67083ff4b8dcbb7ee2839da6338032030d712b0", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.facebook.com/security/advisories/cve-2021-24029", "source": "cve-assign@fb.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebookincubator/mvfst/commit/a67083ff4b8dcbb7ee2839da6338032030d712b0"}}