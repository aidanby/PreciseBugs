{"buggy_code": ["/**\n * collectd - src/snmp.c\n * Copyright (C) 2007-2012  Florian octo Forster\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * Authors:\n *   Florian octo Forster <octo at collectd.org>\n **/\n\n#include \"collectd.h\"\n\n#include \"common.h\"\n#include \"plugin.h\"\n#include \"utils_complain.h\"\n\n#include <net-snmp/net-snmp-config.h>\n#include <net-snmp/net-snmp-includes.h>\n\n#include <fnmatch.h>\n\n/*\n * Private data structes\n */\nstruct oid_s {\n  oid oid[MAX_OID_LEN];\n  size_t oid_len;\n};\ntypedef struct oid_s oid_t;\n\nunion instance_u {\n  char string[DATA_MAX_NAME_LEN];\n  oid_t oid;\n};\ntypedef union instance_u instance_t;\n\nstruct data_definition_s {\n  char *name; /* used to reference this from the `Collect' option */\n  char *type; /* used to find the data_set */\n  _Bool is_table;\n  instance_t instance;\n  char *instance_prefix;\n  oid_t *values;\n  size_t values_len;\n  double scale;\n  double shift;\n  struct data_definition_s *next;\n  char **ignores;\n  size_t ignores_len;\n  int invert_match;\n};\ntypedef struct data_definition_s data_definition_t;\n\nstruct host_definition_s {\n  char *name;\n  char *address;\n  int version;\n\n  /* snmpv1/2 options */\n  char *community;\n\n  /* snmpv3 security options */\n  char *username;\n  oid *auth_protocol;\n  size_t auth_protocol_len;\n  char *auth_passphrase;\n  oid *priv_protocol;\n  size_t priv_protocol_len;\n  char *priv_passphrase;\n  int security_level;\n  char *context;\n\n  void *sess_handle;\n  c_complain_t complaint;\n  cdtime_t interval;\n  data_definition_t **data_list;\n  int data_list_len;\n};\ntypedef struct host_definition_s host_definition_t;\n\n/* These two types are used to cache values in `csnmp_read_table' to handle\n * gaps in tables. */\nstruct csnmp_list_instances_s {\n  oid_t suffix;\n  char instance[DATA_MAX_NAME_LEN];\n  struct csnmp_list_instances_s *next;\n};\ntypedef struct csnmp_list_instances_s csnmp_list_instances_t;\n\nstruct csnmp_table_values_s {\n  oid_t suffix;\n  value_t value;\n  struct csnmp_table_values_s *next;\n};\ntypedef struct csnmp_table_values_s csnmp_table_values_t;\n\n/*\n * Private variables\n */\nstatic data_definition_t *data_head = NULL;\n\n/*\n * Prototypes\n */\nstatic int csnmp_read_host(user_data_t *ud);\n\n/*\n * Private functions\n */\nstatic void csnmp_oid_init(oid_t *dst, oid const *src, size_t n) {\n  assert(n <= STATIC_ARRAY_SIZE(dst->oid));\n  memcpy(dst->oid, src, sizeof(*src) * n);\n  dst->oid_len = n;\n}\n\nstatic int csnmp_oid_compare(oid_t const *left, oid_t const *right) {\n  return (\n      snmp_oid_compare(left->oid, left->oid_len, right->oid, right->oid_len));\n}\n\nstatic int csnmp_oid_suffix(oid_t *dst, oid_t const *src, oid_t const *root) {\n  /* Make sure \"src\" is in \"root\"s subtree. */\n  if (src->oid_len <= root->oid_len)\n    return (EINVAL);\n  if (snmp_oid_ncompare(root->oid, root->oid_len, src->oid, src->oid_len,\n                        /* n = */ root->oid_len) != 0)\n    return (EINVAL);\n\n  memset(dst, 0, sizeof(*dst));\n  dst->oid_len = src->oid_len - root->oid_len;\n  memcpy(dst->oid, &src->oid[root->oid_len],\n         dst->oid_len * sizeof(dst->oid[0]));\n  return (0);\n}\n\nstatic int csnmp_oid_to_string(char *buffer, size_t buffer_size,\n                               oid_t const *o) {\n  char oid_str[MAX_OID_LEN][16];\n  char *oid_str_ptr[MAX_OID_LEN];\n\n  for (size_t i = 0; i < o->oid_len; i++) {\n    ssnprintf(oid_str[i], sizeof(oid_str[i]), \"%lu\", (unsigned long)o->oid[i]);\n    oid_str_ptr[i] = oid_str[i];\n  }\n\n  return (strjoin(buffer, buffer_size, oid_str_ptr, o->oid_len,\n                  /* separator = */ \".\"));\n}\n\nstatic void csnmp_host_close_session(host_definition_t *host) /* {{{ */\n{\n  if (host->sess_handle == NULL)\n    return;\n\n  snmp_sess_close(host->sess_handle);\n  host->sess_handle = NULL;\n} /* }}} void csnmp_host_close_session */\n\nstatic void csnmp_host_definition_destroy(void *arg) /* {{{ */\n{\n  host_definition_t *hd;\n\n  hd = arg;\n\n  if (hd == NULL)\n    return;\n\n  if (hd->name != NULL) {\n    DEBUG(\"snmp plugin: Destroying host definition for host `%s'.\", hd->name);\n  }\n\n  csnmp_host_close_session(hd);\n\n  sfree(hd->name);\n  sfree(hd->address);\n  sfree(hd->community);\n  sfree(hd->username);\n  sfree(hd->auth_passphrase);\n  sfree(hd->priv_passphrase);\n  sfree(hd->context);\n  sfree(hd->data_list);\n\n  sfree(hd);\n} /* }}} void csnmp_host_definition_destroy */\n\n/* Many functions to handle the configuration. {{{ */\n/* First there are many functions which do configuration stuff. It's a big\n * bloated and messy, I'm afraid. */\n\n/*\n * Callgraph for the config stuff:\n *  csnmp_config\n *  +-> call_snmp_init_once\n *  +-> csnmp_config_add_data\n *  !   +-> csnmp_config_add_data_instance\n *  !   +-> csnmp_config_add_data_instance_prefix\n *  !   +-> csnmp_config_add_data_values\n *  +-> csnmp_config_add_host\n *      +-> csnmp_config_add_host_version\n *      +-> csnmp_config_add_host_collect\n *      +-> csnmp_config_add_host_auth_protocol\n *      +-> csnmp_config_add_host_priv_protocol\n *      +-> csnmp_config_add_host_security_level\n */\nstatic void call_snmp_init_once(void) {\n  static int have_init = 0;\n\n  if (have_init == 0)\n    init_snmp(PACKAGE_NAME);\n  have_init = 1;\n} /* void call_snmp_init_once */\n\nstatic int csnmp_config_add_data_instance(data_definition_t *dd,\n                                          oconfig_item_t *ci) {\n  char buffer[DATA_MAX_NAME_LEN];\n  int status;\n\n  status = cf_util_get_string_buffer(ci, buffer, sizeof(buffer));\n  if (status != 0)\n    return status;\n\n  if (dd->is_table) {\n    /* Instance is an OID */\n    dd->instance.oid.oid_len = MAX_OID_LEN;\n\n    if (!read_objid(buffer, dd->instance.oid.oid, &dd->instance.oid.oid_len)) {\n      ERROR(\"snmp plugin: read_objid (%s) failed.\", buffer);\n      return (-1);\n    }\n  } else {\n    /* Instance is a simple string */\n    sstrncpy(dd->instance.string, buffer, sizeof(dd->instance.string));\n  }\n\n  return (0);\n} /* int csnmp_config_add_data_instance */\n\nstatic int csnmp_config_add_data_instance_prefix(data_definition_t *dd,\n                                                 oconfig_item_t *ci) {\n  int status;\n\n  if (!dd->is_table) {\n    WARNING(\"snmp plugin: data %s: InstancePrefix is ignored when `Table' \"\n            \"is set to `false'.\",\n            dd->name);\n    return (-1);\n  }\n\n  status = cf_util_get_string(ci, &dd->instance_prefix);\n  return status;\n} /* int csnmp_config_add_data_instance_prefix */\n\nstatic int csnmp_config_add_data_values(data_definition_t *dd,\n                                        oconfig_item_t *ci) {\n  if (ci->values_num < 1) {\n    WARNING(\"snmp plugin: `Values' needs at least one argument.\");\n    return (-1);\n  }\n\n  for (int i = 0; i < ci->values_num; i++)\n    if (ci->values[i].type != OCONFIG_TYPE_STRING) {\n      WARNING(\"snmp plugin: `Values' needs only string argument.\");\n      return (-1);\n    }\n\n  sfree(dd->values);\n  dd->values_len = 0;\n  dd->values = malloc(sizeof(*dd->values) * ci->values_num);\n  if (dd->values == NULL)\n    return (-1);\n  dd->values_len = (size_t)ci->values_num;\n\n  for (int i = 0; i < ci->values_num; i++) {\n    dd->values[i].oid_len = MAX_OID_LEN;\n\n    if (NULL == snmp_parse_oid(ci->values[i].value.string, dd->values[i].oid,\n                               &dd->values[i].oid_len)) {\n      ERROR(\"snmp plugin: snmp_parse_oid (%s) failed.\",\n            ci->values[i].value.string);\n      free(dd->values);\n      dd->values = NULL;\n      dd->values_len = 0;\n      return (-1);\n    }\n  }\n\n  return (0);\n} /* int csnmp_config_add_data_instance */\n\nstatic int csnmp_config_add_data_blacklist(data_definition_t *dd,\n                                           oconfig_item_t *ci) {\n  if (ci->values_num < 1)\n    return (0);\n\n  for (int i = 0; i < ci->values_num; i++) {\n    if (ci->values[i].type != OCONFIG_TYPE_STRING) {\n      WARNING(\"snmp plugin: `Ignore' needs only string argument.\");\n      return (-1);\n    }\n  }\n\n  dd->ignores_len = 0;\n  dd->ignores = NULL;\n\n  for (int i = 0; i < ci->values_num; ++i) {\n    if (strarray_add(&(dd->ignores), &(dd->ignores_len),\n                     ci->values[i].value.string) != 0) {\n      ERROR(\"snmp plugin: Can't allocate memory\");\n      strarray_free(dd->ignores, dd->ignores_len);\n      return (ENOMEM);\n    }\n  }\n  return 0;\n} /* int csnmp_config_add_data_blacklist */\n\nstatic int csnmp_config_add_data_blacklist_match_inverted(data_definition_t *dd,\n                                                          oconfig_item_t *ci) {\n  if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_BOOLEAN)) {\n    WARNING(\"snmp plugin: `InvertMatch' needs exactly one boolean argument.\");\n    return (-1);\n  }\n\n  dd->invert_match = ci->values[0].value.boolean ? 1 : 0;\n\n  return (0);\n} /* int csnmp_config_add_data_blacklist_match_inverted */\n\nstatic int csnmp_config_add_data(oconfig_item_t *ci) {\n  data_definition_t *dd;\n  int status = 0;\n\n  dd = calloc(1, sizeof(*dd));\n  if (dd == NULL)\n    return (-1);\n\n  status = cf_util_get_string(ci, &dd->name);\n  if (status != 0) {\n    free(dd);\n    return (-1);\n  }\n\n  dd->scale = 1.0;\n  dd->shift = 0.0;\n\n  for (int i = 0; i < ci->children_num; i++) {\n    oconfig_item_t *option = ci->children + i;\n\n    if (strcasecmp(\"Type\", option->key) == 0)\n      status = cf_util_get_string(option, &dd->type);\n    else if (strcasecmp(\"Table\", option->key) == 0)\n      status = cf_util_get_boolean(option, &dd->is_table);\n    else if (strcasecmp(\"Instance\", option->key) == 0)\n      status = csnmp_config_add_data_instance(dd, option);\n    else if (strcasecmp(\"InstancePrefix\", option->key) == 0)\n      status = csnmp_config_add_data_instance_prefix(dd, option);\n    else if (strcasecmp(\"Values\", option->key) == 0)\n      status = csnmp_config_add_data_values(dd, option);\n    else if (strcasecmp(\"Shift\", option->key) == 0)\n      status = cf_util_get_double(option, &dd->shift);\n    else if (strcasecmp(\"Scale\", option->key) == 0)\n      status = cf_util_get_double(option, &dd->scale);\n    else if (strcasecmp(\"Ignore\", option->key) == 0)\n      status = csnmp_config_add_data_blacklist(dd, option);\n    else if (strcasecmp(\"InvertMatch\", option->key) == 0)\n      status = csnmp_config_add_data_blacklist_match_inverted(dd, option);\n    else {\n      WARNING(\"snmp plugin: Option `%s' not allowed here.\", option->key);\n      status = -1;\n    }\n\n    if (status != 0)\n      break;\n  } /* for (ci->children) */\n\n  while (status == 0) {\n    if (dd->type == NULL) {\n      WARNING(\"snmp plugin: `Type' not given for data `%s'\", dd->name);\n      status = -1;\n      break;\n    }\n    if (dd->values == NULL) {\n      WARNING(\"snmp plugin: No `Value' given for data `%s'\", dd->name);\n      status = -1;\n      break;\n    }\n\n    break;\n  } /* while (status == 0) */\n\n  if (status != 0) {\n    sfree(dd->name);\n    sfree(dd->instance_prefix);\n    sfree(dd->values);\n    sfree(dd->ignores);\n    sfree(dd);\n    return (-1);\n  }\n\n  DEBUG(\"snmp plugin: dd = { name = %s, type = %s, is_table = %s, values_len = \"\n        \"%zu }\",\n        dd->name, dd->type, (dd->is_table != 0) ? \"true\" : \"false\",\n        dd->values_len);\n\n  if (data_head == NULL)\n    data_head = dd;\n  else {\n    data_definition_t *last;\n    last = data_head;\n    while (last->next != NULL)\n      last = last->next;\n    last->next = dd;\n  }\n\n  return (0);\n} /* int csnmp_config_add_data */\n\nstatic int csnmp_config_add_host_version(host_definition_t *hd,\n                                         oconfig_item_t *ci) {\n  int version;\n\n  if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_NUMBER)) {\n    WARNING(\"snmp plugin: The `Version' config option needs exactly one number \"\n            \"argument.\");\n    return (-1);\n  }\n\n  version = (int)ci->values[0].value.number;\n  if ((version < 1) || (version > 3)) {\n    WARNING(\"snmp plugin: `Version' must either be `1', `2', or `3'.\");\n    return (-1);\n  }\n\n  hd->version = version;\n\n  return (0);\n} /* int csnmp_config_add_host_address */\n\nstatic int csnmp_config_add_host_collect(host_definition_t *host,\n                                         oconfig_item_t *ci) {\n  data_definition_t *data;\n  data_definition_t **data_list;\n  int data_list_len;\n\n  if (ci->values_num < 1) {\n    WARNING(\"snmp plugin: `Collect' needs at least one argument.\");\n    return (-1);\n  }\n\n  for (int i = 0; i < ci->values_num; i++)\n    if (ci->values[i].type != OCONFIG_TYPE_STRING) {\n      WARNING(\"snmp plugin: All arguments to `Collect' must be strings.\");\n      return (-1);\n    }\n\n  data_list_len = host->data_list_len + ci->values_num;\n  data_list =\n      realloc(host->data_list, sizeof(data_definition_t *) * data_list_len);\n  if (data_list == NULL)\n    return (-1);\n  host->data_list = data_list;\n\n  for (int i = 0; i < ci->values_num; i++) {\n    for (data = data_head; data != NULL; data = data->next)\n      if (strcasecmp(ci->values[i].value.string, data->name) == 0)\n        break;\n\n    if (data == NULL) {\n      WARNING(\"snmp plugin: No such data configured: `%s'\",\n              ci->values[i].value.string);\n      continue;\n    }\n\n    DEBUG(\"snmp plugin: Collect: host = %s, data[%i] = %s;\", host->name,\n          host->data_list_len, data->name);\n\n    host->data_list[host->data_list_len] = data;\n    host->data_list_len++;\n  } /* for (values_num) */\n\n  return (0);\n} /* int csnmp_config_add_host_collect */\n\nstatic int csnmp_config_add_host_auth_protocol(host_definition_t *hd,\n                                               oconfig_item_t *ci) {\n  char buffer[4];\n  int status;\n\n  status = cf_util_get_string_buffer(ci, buffer, sizeof(buffer));\n  if (status != 0)\n    return status;\n\n  if (strcasecmp(\"MD5\", buffer) == 0) {\n    hd->auth_protocol = usmHMACMD5AuthProtocol;\n    hd->auth_protocol_len = sizeof(usmHMACMD5AuthProtocol) / sizeof(oid);\n  } else if (strcasecmp(\"SHA\", buffer) == 0) {\n    hd->auth_protocol = usmHMACSHA1AuthProtocol;\n    hd->auth_protocol_len = sizeof(usmHMACSHA1AuthProtocol) / sizeof(oid);\n  } else {\n    WARNING(\"snmp plugin: The `AuthProtocol' config option must be `MD5' or \"\n            \"`SHA'.\");\n    return (-1);\n  }\n\n  DEBUG(\"snmp plugin: host = %s; host->auth_protocol = %s;\", hd->name,\n        hd->auth_protocol == usmHMACMD5AuthProtocol ? \"MD5\" : \"SHA\");\n\n  return (0);\n} /* int csnmp_config_add_host_auth_protocol */\n\nstatic int csnmp_config_add_host_priv_protocol(host_definition_t *hd,\n                                               oconfig_item_t *ci) {\n  char buffer[4];\n  int status;\n\n  status = cf_util_get_string_buffer(ci, buffer, sizeof(buffer));\n  if (status != 0)\n    return status;\n\n  if (strcasecmp(\"AES\", buffer) == 0) {\n    hd->priv_protocol = usmAESPrivProtocol;\n    hd->priv_protocol_len = sizeof(usmAESPrivProtocol) / sizeof(oid);\n  } else if (strcasecmp(\"DES\", buffer) == 0) {\n    hd->priv_protocol = usmDESPrivProtocol;\n    hd->priv_protocol_len = sizeof(usmDESPrivProtocol) / sizeof(oid);\n  } else {\n    WARNING(\"snmp plugin: The `PrivProtocol' config option must be `AES' or \"\n            \"`DES'.\");\n    return (-1);\n  }\n\n  DEBUG(\"snmp plugin: host = %s; host->priv_protocol = %s;\", hd->name,\n        hd->priv_protocol == usmAESPrivProtocol ? \"AES\" : \"DES\");\n\n  return (0);\n} /* int csnmp_config_add_host_priv_protocol */\n\nstatic int csnmp_config_add_host_security_level(host_definition_t *hd,\n                                                oconfig_item_t *ci) {\n  char buffer[16];\n  int status;\n\n  status = cf_util_get_string_buffer(ci, buffer, sizeof(buffer));\n  if (status != 0)\n    return status;\n\n  if (strcasecmp(\"noAuthNoPriv\", buffer) == 0)\n    hd->security_level = SNMP_SEC_LEVEL_NOAUTH;\n  else if (strcasecmp(\"authNoPriv\", buffer) == 0)\n    hd->security_level = SNMP_SEC_LEVEL_AUTHNOPRIV;\n  else if (strcasecmp(\"authPriv\", buffer) == 0)\n    hd->security_level = SNMP_SEC_LEVEL_AUTHPRIV;\n  else {\n    WARNING(\"snmp plugin: The `SecurityLevel' config option must be \"\n            \"`noAuthNoPriv', `authNoPriv', or `authPriv'.\");\n    return (-1);\n  }\n\n  DEBUG(\"snmp plugin: host = %s; host->security_level = %d;\", hd->name,\n        hd->security_level);\n\n  return (0);\n} /* int csnmp_config_add_host_security_level */\n\nstatic int csnmp_config_add_host(oconfig_item_t *ci) {\n  host_definition_t *hd;\n  int status = 0;\n\n  /* Registration stuff. */\n  char cb_name[DATA_MAX_NAME_LEN];\n\n  hd = calloc(1, sizeof(*hd));\n  if (hd == NULL)\n    return (-1);\n  hd->version = 2;\n  C_COMPLAIN_INIT(&hd->complaint);\n\n  status = cf_util_get_string(ci, &hd->name);\n  if (status != 0) {\n    sfree(hd);\n    return status;\n  }\n\n  hd->sess_handle = NULL;\n  hd->interval = 0;\n\n  for (int i = 0; i < ci->children_num; i++) {\n    oconfig_item_t *option = ci->children + i;\n    status = 0;\n\n    if (strcasecmp(\"Address\", option->key) == 0)\n      status = cf_util_get_string(option, &hd->address);\n    else if (strcasecmp(\"Community\", option->key) == 0)\n      status = cf_util_get_string(option, &hd->community);\n    else if (strcasecmp(\"Version\", option->key) == 0)\n      status = csnmp_config_add_host_version(hd, option);\n    else if (strcasecmp(\"Collect\", option->key) == 0)\n      csnmp_config_add_host_collect(hd, option);\n    else if (strcasecmp(\"Interval\", option->key) == 0)\n      cf_util_get_cdtime(option, &hd->interval);\n    else if (strcasecmp(\"Username\", option->key) == 0)\n      status = cf_util_get_string(option, &hd->username);\n    else if (strcasecmp(\"AuthProtocol\", option->key) == 0)\n      status = csnmp_config_add_host_auth_protocol(hd, option);\n    else if (strcasecmp(\"PrivacyProtocol\", option->key) == 0)\n      status = csnmp_config_add_host_priv_protocol(hd, option);\n    else if (strcasecmp(\"AuthPassphrase\", option->key) == 0)\n      status = cf_util_get_string(option, &hd->auth_passphrase);\n    else if (strcasecmp(\"PrivacyPassphrase\", option->key) == 0)\n      status = cf_util_get_string(option, &hd->priv_passphrase);\n    else if (strcasecmp(\"SecurityLevel\", option->key) == 0)\n      status = csnmp_config_add_host_security_level(hd, option);\n    else if (strcasecmp(\"Context\", option->key) == 0)\n      status = cf_util_get_string(option, &hd->context);\n    else {\n      WARNING(\n          \"snmp plugin: csnmp_config_add_host: Option `%s' not allowed here.\",\n          option->key);\n      status = -1;\n    }\n\n    if (status != 0)\n      break;\n  } /* for (ci->children) */\n\n  while (status == 0) {\n    if (hd->address == NULL) {\n      WARNING(\"snmp plugin: `Address' not given for host `%s'\", hd->name);\n      status = -1;\n      break;\n    }\n    if (hd->community == NULL && hd->version < 3) {\n      WARNING(\"snmp plugin: `Community' not given for host `%s'\", hd->name);\n      status = -1;\n      break;\n    }\n    if (hd->version == 3) {\n      if (hd->username == NULL) {\n        WARNING(\"snmp plugin: `Username' not given for host `%s'\", hd->name);\n        status = -1;\n        break;\n      }\n      if (hd->security_level == 0) {\n        WARNING(\"snmp plugin: `SecurityLevel' not given for host `%s'\",\n                hd->name);\n        status = -1;\n        break;\n      }\n      if (hd->security_level == SNMP_SEC_LEVEL_AUTHNOPRIV ||\n          hd->security_level == SNMP_SEC_LEVEL_AUTHPRIV) {\n        if (hd->auth_protocol == NULL) {\n          WARNING(\"snmp plugin: `AuthProtocol' not given for host `%s'\",\n                  hd->name);\n          status = -1;\n          break;\n        }\n        if (hd->auth_passphrase == NULL) {\n          WARNING(\"snmp plugin: `AuthPassphrase' not given for host `%s'\",\n                  hd->name);\n          status = -1;\n          break;\n        }\n      }\n      if (hd->security_level == SNMP_SEC_LEVEL_AUTHPRIV) {\n        if (hd->priv_protocol == NULL) {\n          WARNING(\"snmp plugin: `PrivacyProtocol' not given for host `%s'\",\n                  hd->name);\n          status = -1;\n          break;\n        }\n        if (hd->priv_passphrase == NULL) {\n          WARNING(\"snmp plugin: `PrivacyPassphrase' not given for host `%s'\",\n                  hd->name);\n          status = -1;\n          break;\n        }\n      }\n    }\n\n    break;\n  } /* while (status == 0) */\n\n  if (status != 0) {\n    csnmp_host_definition_destroy(hd);\n    return (-1);\n  }\n\n  DEBUG(\"snmp plugin: hd = { name = %s, address = %s, community = %s, version \"\n        \"= %i }\",\n        hd->name, hd->address, hd->community, hd->version);\n\n  ssnprintf(cb_name, sizeof(cb_name), \"snmp-%s\", hd->name);\n\n  user_data_t ud = {.data = hd, .free_func = csnmp_host_definition_destroy};\n\n  status =\n      plugin_register_complex_read(/* group = */ NULL, cb_name, csnmp_read_host,\n                                   hd->interval, /* user_data = */ &ud);\n  if (status != 0) {\n    ERROR(\"snmp plugin: Registering complex read function failed.\");\n    csnmp_host_definition_destroy(hd);\n    return (-1);\n  }\n\n  return (0);\n} /* int csnmp_config_add_host */\n\nstatic int csnmp_config(oconfig_item_t *ci) {\n  call_snmp_init_once();\n\n  for (int i = 0; i < ci->children_num; i++) {\n    oconfig_item_t *child = ci->children + i;\n    if (strcasecmp(\"Data\", child->key) == 0)\n      csnmp_config_add_data(child);\n    else if (strcasecmp(\"Host\", child->key) == 0)\n      csnmp_config_add_host(child);\n    else {\n      WARNING(\"snmp plugin: Ignoring unknown config option `%s'.\", child->key);\n    }\n  } /* for (ci->children) */\n\n  return (0);\n} /* int csnmp_config */\n\n/* }}} End of the config stuff. Now the interesting part begins */\n\nstatic void csnmp_host_open_session(host_definition_t *host) {\n  struct snmp_session sess;\n  int error;\n\n  if (host->sess_handle != NULL)\n    csnmp_host_close_session(host);\n\n  snmp_sess_init(&sess);\n  sess.peername = host->address;\n  switch (host->version) {\n  case 1:\n    sess.version = SNMP_VERSION_1;\n    break;\n  case 3:\n    sess.version = SNMP_VERSION_3;\n    break;\n  default:\n    sess.version = SNMP_VERSION_2c;\n    break;\n  }\n\n  if (host->version == 3) {\n    sess.securityName = host->username;\n    sess.securityNameLen = strlen(host->username);\n    sess.securityLevel = host->security_level;\n\n    if (sess.securityLevel == SNMP_SEC_LEVEL_AUTHNOPRIV ||\n        sess.securityLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n      sess.securityAuthProto = host->auth_protocol;\n      sess.securityAuthProtoLen = host->auth_protocol_len;\n      sess.securityAuthKeyLen = USM_AUTH_KU_LEN;\n      error = generate_Ku(sess.securityAuthProto, sess.securityAuthProtoLen,\n                          (u_char *)host->auth_passphrase,\n                          strlen(host->auth_passphrase), sess.securityAuthKey,\n                          &sess.securityAuthKeyLen);\n      if (error != SNMPERR_SUCCESS) {\n        ERROR(\"snmp plugin: host %s: Error generating Ku from auth_passphrase. \"\n              \"(Error %d)\",\n              host->name, error);\n      }\n    }\n\n    if (sess.securityLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n      sess.securityPrivProto = host->priv_protocol;\n      sess.securityPrivProtoLen = host->priv_protocol_len;\n      sess.securityPrivKeyLen = USM_PRIV_KU_LEN;\n      error = generate_Ku(sess.securityAuthProto, sess.securityAuthProtoLen,\n                          (u_char *)host->priv_passphrase,\n                          strlen(host->priv_passphrase), sess.securityPrivKey,\n                          &sess.securityPrivKeyLen);\n      if (error != SNMPERR_SUCCESS) {\n        ERROR(\"snmp plugin: host %s: Error generating Ku from priv_passphrase. \"\n              \"(Error %d)\",\n              host->name, error);\n      }\n    }\n\n    if (host->context != NULL) {\n      sess.contextName = host->context;\n      sess.contextNameLen = strlen(host->context);\n    }\n  } else /* SNMPv1/2 \"authenticates\" with community string */\n  {\n    sess.community = (u_char *)host->community;\n    sess.community_len = strlen(host->community);\n  }\n\n  /* snmp_sess_open will copy the `struct snmp_session *'. */\n  host->sess_handle = snmp_sess_open(&sess);\n\n  if (host->sess_handle == NULL) {\n    char *errstr = NULL;\n\n    snmp_error(&sess, NULL, NULL, &errstr);\n\n    ERROR(\"snmp plugin: host %s: snmp_sess_open failed: %s\", host->name,\n          (errstr == NULL) ? \"Unknown problem\" : errstr);\n    sfree(errstr);\n  }\n} /* void csnmp_host_open_session */\n\n/* TODO: Check if negative values wrap around. Problem: negative temperatures.\n */\nstatic value_t csnmp_value_list_to_value(struct variable_list *vl, int type,\n                                         double scale, double shift,\n                                         const char *host_name,\n                                         const char *data_name) {\n  value_t ret;\n  uint64_t tmp_unsigned = 0;\n  int64_t tmp_signed = 0;\n  _Bool defined = 1;\n  /* Set to true when the original SNMP type appears to have been signed. */\n  _Bool prefer_signed = 0;\n\n  if ((vl->type == ASN_INTEGER) || (vl->type == ASN_UINTEGER) ||\n      (vl->type == ASN_COUNTER)\n#ifdef ASN_TIMETICKS\n      || (vl->type == ASN_TIMETICKS)\n#endif\n      || (vl->type == ASN_GAUGE)) {\n    tmp_unsigned = (uint32_t)*vl->val.integer;\n    tmp_signed = (int32_t)*vl->val.integer;\n\n    if (vl->type == ASN_INTEGER)\n      prefer_signed = 1;\n\n    DEBUG(\"snmp plugin: Parsed int32 value is %\" PRIu64 \".\", tmp_unsigned);\n  } else if (vl->type == ASN_COUNTER64) {\n    tmp_unsigned = (uint32_t)vl->val.counter64->high;\n    tmp_unsigned = tmp_unsigned << 32;\n    tmp_unsigned += (uint32_t)vl->val.counter64->low;\n    tmp_signed = (int64_t)tmp_unsigned;\n    DEBUG(\"snmp plugin: Parsed int64 value is %\" PRIu64 \".\", tmp_unsigned);\n  } else if (vl->type == ASN_OCTET_STR) {\n    /* We'll handle this later.. */\n  } else {\n    char oid_buffer[1024] = {0};\n\n    snprint_objid(oid_buffer, sizeof(oid_buffer) - 1, vl->name,\n                  vl->name_length);\n\n#ifdef ASN_NULL\n    if (vl->type == ASN_NULL)\n      INFO(\"snmp plugin: OID \\\"%s\\\" is undefined (type ASN_NULL)\", oid_buffer);\n    else\n#endif\n      WARNING(\"snmp plugin: I don't know the ASN type #%i \"\n              \"(OID: \\\"%s\\\", data block \\\"%s\\\", host block \\\"%s\\\")\",\n              (int)vl->type, oid_buffer,\n              (data_name != NULL) ? data_name : \"UNKNOWN\",\n              (host_name != NULL) ? host_name : \"UNKNOWN\");\n\n    defined = 0;\n  }\n\n  if (vl->type == ASN_OCTET_STR) {\n    int status = -1;\n\n    if (vl->val.string != NULL) {\n      char string[64];\n      size_t string_length;\n\n      string_length = sizeof(string) - 1;\n      if (vl->val_len < string_length)\n        string_length = vl->val_len;\n\n      /* The strings we get from the Net-SNMP library may not be null\n       * terminated. That is why we're using `memcpy' here and not `strcpy'.\n       * `string_length' is set to `vl->val_len' which holds the length of the\n       * string.  -octo */\n      memcpy(string, vl->val.string, string_length);\n      string[string_length] = 0;\n\n      status = parse_value(string, &ret, type);\n      if (status != 0) {\n        ERROR(\"snmp plugin: host %s: csnmp_value_list_to_value: Parsing string \"\n              \"as %s failed: %s\",\n              (host_name != NULL) ? host_name : \"UNKNOWN\",\n              DS_TYPE_TO_STRING(type), string);\n      }\n    }\n\n    if (status != 0) {\n      switch (type) {\n      case DS_TYPE_COUNTER:\n      case DS_TYPE_DERIVE:\n      case DS_TYPE_ABSOLUTE:\n        memset(&ret, 0, sizeof(ret));\n        break;\n\n      case DS_TYPE_GAUGE:\n        ret.gauge = NAN;\n        break;\n\n      default:\n        ERROR(\"snmp plugin: csnmp_value_list_to_value: Unknown \"\n              \"data source type: %i.\",\n              type);\n        ret.gauge = NAN;\n      }\n    }\n  } /* if (vl->type == ASN_OCTET_STR) */\n  else if (type == DS_TYPE_COUNTER) {\n    ret.counter = tmp_unsigned;\n  } else if (type == DS_TYPE_GAUGE) {\n    if (!defined)\n      ret.gauge = NAN;\n    else if (prefer_signed)\n      ret.gauge = (scale * tmp_signed) + shift;\n    else\n      ret.gauge = (scale * tmp_unsigned) + shift;\n  } else if (type == DS_TYPE_DERIVE) {\n    if (prefer_signed)\n      ret.derive = (derive_t)tmp_signed;\n    else\n      ret.derive = (derive_t)tmp_unsigned;\n  } else if (type == DS_TYPE_ABSOLUTE) {\n    ret.absolute = (absolute_t)tmp_unsigned;\n  } else {\n    ERROR(\"snmp plugin: csnmp_value_list_to_value: Unknown data source \"\n          \"type: %i.\",\n          type);\n    ret.gauge = NAN;\n  }\n\n  return (ret);\n} /* value_t csnmp_value_list_to_value */\n\n/* csnmp_strvbcopy_hexstring converts the bit string contained in \"vb\" to a hex\n * representation and writes it to dst. Returns zero on success and ENOMEM if\n * dst is not large enough to hold the string. dst is guaranteed to be\n * nul-terminated. */\nstatic int csnmp_strvbcopy_hexstring(char *dst, /* {{{ */\n                                     const struct variable_list *vb,\n                                     size_t dst_size) {\n  char *buffer_ptr;\n  size_t buffer_free;\n\n  dst[0] = 0;\n\n  buffer_ptr = dst;\n  buffer_free = dst_size;\n\n  for (size_t i = 0; i < vb->val_len; i++) {\n    int status;\n\n    status = snprintf(buffer_ptr, buffer_free, (i == 0) ? \"%02x\" : \":%02x\",\n                      (unsigned int)vb->val.bitstring[i]);\n    assert(status >= 0);\n\n    if (((size_t)status) >= buffer_free) /* truncated */\n    {\n      dst[dst_size - 1] = 0;\n      return ENOMEM;\n    } else /* if (status < buffer_free) */\n    {\n      buffer_ptr += (size_t)status;\n      buffer_free -= (size_t)status;\n    }\n  }\n\n  return 0;\n} /* }}} int csnmp_strvbcopy_hexstring */\n\n/* csnmp_strvbcopy copies the octet string or bit string contained in vb to\n * dst. If non-printable characters are detected, it will switch to a hex\n * representation of the string. Returns zero on success, EINVAL if vb does not\n * contain a string and ENOMEM if dst is not large enough to contain the\n * string. */\nstatic int csnmp_strvbcopy(char *dst, /* {{{ */\n                           const struct variable_list *vb, size_t dst_size) {\n  char *src;\n  size_t num_chars;\n\n  if (vb->type == ASN_OCTET_STR)\n    src = (char *)vb->val.string;\n  else if (vb->type == ASN_BIT_STR)\n    src = (char *)vb->val.bitstring;\n  else if (vb->type == ASN_IPADDRESS) {\n    return ssnprintf(dst, dst_size,\n                     \"%\" PRIu8 \".%\" PRIu8 \".%\" PRIu8 \".%\" PRIu8 \"\",\n                     (uint8_t)vb->val.string[0], (uint8_t)vb->val.string[1],\n                     (uint8_t)vb->val.string[2], (uint8_t)vb->val.string[3]);\n  } else {\n    dst[0] = 0;\n    return (EINVAL);\n  }\n\n  num_chars = dst_size - 1;\n  if (num_chars > vb->val_len)\n    num_chars = vb->val_len;\n\n  for (size_t i = 0; i < num_chars; i++) {\n    /* Check for control characters. */\n    if ((unsigned char)src[i] < 32)\n      return (csnmp_strvbcopy_hexstring(dst, vb, dst_size));\n    dst[i] = src[i];\n  }\n  dst[num_chars] = 0;\n  dst[dst_size - 1] = 0;\n\n  if (dst_size <= vb->val_len)\n    return ENOMEM;\n\n  return 0;\n} /* }}} int csnmp_strvbcopy */\n\nstatic int csnmp_instance_list_add(csnmp_list_instances_t **head,\n                                   csnmp_list_instances_t **tail,\n                                   const struct snmp_pdu *res,\n                                   const host_definition_t *hd,\n                                   const data_definition_t *dd) {\n  csnmp_list_instances_t *il;\n  struct variable_list *vb;\n  oid_t vb_name;\n  int status;\n  uint32_t is_matched;\n\n  /* Set vb on the last variable */\n  for (vb = res->variables; (vb != NULL) && (vb->next_variable != NULL);\n       vb = vb->next_variable)\n    /* do nothing */;\n  if (vb == NULL)\n    return (-1);\n\n  csnmp_oid_init(&vb_name, vb->name, vb->name_length);\n\n  il = calloc(1, sizeof(*il));\n  if (il == NULL) {\n    ERROR(\"snmp plugin: calloc failed.\");\n    return (-1);\n  }\n  il->next = NULL;\n\n  status = csnmp_oid_suffix(&il->suffix, &vb_name, &dd->instance.oid);\n  if (status != 0) {\n    sfree(il);\n    return (status);\n  }\n\n  /* Get instance name */\n  if ((vb->type == ASN_OCTET_STR) || (vb->type == ASN_BIT_STR) ||\n      (vb->type == ASN_IPADDRESS)) {\n    char *ptr;\n\n    csnmp_strvbcopy(il->instance, vb, sizeof(il->instance));\n    is_matched = 0;\n    for (uint32_t i = 0; i < dd->ignores_len; i++) {\n      status = fnmatch(dd->ignores[i], il->instance, 0);\n      if (status == 0) {\n        if (dd->invert_match == 0) {\n          sfree(il);\n          return 0;\n        } else {\n          is_matched = 1;\n          break;\n        }\n      }\n    }\n    if (dd->invert_match != 0 && is_matched == 0) {\n      sfree(il);\n      return 0;\n    }\n    for (ptr = il->instance; *ptr != '\\0'; ptr++) {\n      if ((*ptr > 0) && (*ptr < 32))\n        *ptr = ' ';\n      else if (*ptr == '/')\n        *ptr = '_';\n    }\n    DEBUG(\"snmp plugin: il->instance = `%s';\", il->instance);\n  } else {\n    value_t val = csnmp_value_list_to_value(\n        vb, DS_TYPE_COUNTER,\n        /* scale = */ 1.0, /* shift = */ 0.0, hd->name, dd->name);\n    ssnprintf(il->instance, sizeof(il->instance), \"%llu\", val.counter);\n  }\n\n  /* TODO: Debugging output */\n\n  if (*head == NULL)\n    *head = il;\n  else\n    (*tail)->next = il;\n  *tail = il;\n\n  return (0);\n} /* int csnmp_instance_list_add */\n\nstatic int csnmp_dispatch_table(host_definition_t *host,\n                                data_definition_t *data,\n                                csnmp_list_instances_t *instance_list,\n                                csnmp_table_values_t **value_table) {\n  const data_set_t *ds;\n  value_list_t vl = VALUE_LIST_INIT;\n\n  csnmp_list_instances_t *instance_list_ptr;\n  csnmp_table_values_t **value_table_ptr;\n\n  size_t i;\n  _Bool have_more;\n  oid_t current_suffix;\n\n  ds = plugin_get_ds(data->type);\n  if (!ds) {\n    ERROR(\"snmp plugin: DataSet `%s' not defined.\", data->type);\n    return (-1);\n  }\n  assert(ds->ds_num == data->values_len);\n  assert(data->values_len > 0);\n\n  instance_list_ptr = instance_list;\n\n  value_table_ptr = calloc(data->values_len, sizeof(*value_table_ptr));\n  if (value_table_ptr == NULL)\n    return (-1);\n  for (i = 0; i < data->values_len; i++)\n    value_table_ptr[i] = value_table[i];\n\n  vl.values_len = data->values_len;\n  vl.values = malloc(sizeof(*vl.values) * vl.values_len);\n  if (vl.values == NULL) {\n    ERROR(\"snmp plugin: malloc failed.\");\n    sfree(value_table_ptr);\n    return (-1);\n  }\n\n  sstrncpy(vl.host, host->name, sizeof(vl.host));\n  sstrncpy(vl.plugin, \"snmp\", sizeof(vl.plugin));\n\n  vl.interval = host->interval;\n\n  have_more = 1;\n  while (have_more) {\n    _Bool suffix_skipped = 0;\n\n    /* Determine next suffix to handle. */\n    if (instance_list != NULL) {\n      if (instance_list_ptr == NULL) {\n        have_more = 0;\n        continue;\n      }\n\n      memcpy(&current_suffix, &instance_list_ptr->suffix,\n             sizeof(current_suffix));\n    } else /* no instance configured */\n    {\n      csnmp_table_values_t *ptr = value_table_ptr[0];\n      if (ptr == NULL) {\n        have_more = 0;\n        continue;\n      }\n\n      memcpy(&current_suffix, &ptr->suffix, sizeof(current_suffix));\n    }\n\n    /* Update all the value_table_ptr to point at the entry with the same\n     * trailing partial OID */\n    for (i = 0; i < data->values_len; i++) {\n      while (\n          (value_table_ptr[i] != NULL) &&\n          (csnmp_oid_compare(&value_table_ptr[i]->suffix, &current_suffix) < 0))\n        value_table_ptr[i] = value_table_ptr[i]->next;\n\n      if (value_table_ptr[i] == NULL) {\n        have_more = 0;\n        break;\n      } else if (csnmp_oid_compare(&value_table_ptr[i]->suffix,\n                                   &current_suffix) > 0) {\n        /* This suffix is missing in the subtree. Indicate this with the\n         * \"suffix_skipped\" flag and try the next instance / suffix. */\n        suffix_skipped = 1;\n        break;\n      }\n    } /* for (i = 0; i < columns; i++) */\n\n    if (!have_more)\n      break;\n\n    /* Matching the values failed. Start from the beginning again. */\n    if (suffix_skipped) {\n      if (instance_list != NULL)\n        instance_list_ptr = instance_list_ptr->next;\n      else\n        value_table_ptr[0] = value_table_ptr[0]->next;\n\n      continue;\n    }\n\n/* if we reach this line, all value_table_ptr[i] are non-NULL and are set\n * to the same subid. instance_list_ptr is either NULL or points to the\n * same subid, too. */\n#if COLLECT_DEBUG\n    for (i = 1; i < data->values_len; i++) {\n      assert(value_table_ptr[i] != NULL);\n      assert(csnmp_oid_compare(&value_table_ptr[i - 1]->suffix,\n                               &value_table_ptr[i]->suffix) == 0);\n    }\n    assert((instance_list_ptr == NULL) ||\n           (csnmp_oid_compare(&instance_list_ptr->suffix,\n                              &value_table_ptr[0]->suffix) == 0));\n#endif\n\n    sstrncpy(vl.type, data->type, sizeof(vl.type));\n\n    {\n      char temp[DATA_MAX_NAME_LEN];\n\n      if (instance_list_ptr == NULL)\n        csnmp_oid_to_string(temp, sizeof(temp), &current_suffix);\n      else\n        sstrncpy(temp, instance_list_ptr->instance, sizeof(temp));\n\n      if (data->instance_prefix == NULL)\n        sstrncpy(vl.type_instance, temp, sizeof(vl.type_instance));\n      else\n        ssnprintf(vl.type_instance, sizeof(vl.type_instance), \"%s%s\",\n                  data->instance_prefix, temp);\n    }\n\n    for (i = 0; i < data->values_len; i++)\n      vl.values[i] = value_table_ptr[i]->value;\n\n    /* If we get here `vl.type_instance' and all `vl.values' have been set\n     * vl.type_instance can be empty, i.e. a blank port description on a\n     * switch if you're using IF-MIB::ifDescr as Instance.\n     */\n    if (vl.type_instance[0] != '\\0')\n      plugin_dispatch_values(&vl);\n\n    if (instance_list != NULL)\n      instance_list_ptr = instance_list_ptr->next;\n    else\n      value_table_ptr[0] = value_table_ptr[0]->next;\n  } /* while (have_more) */\n\n  sfree(vl.values);\n  sfree(value_table_ptr);\n\n  return (0);\n} /* int csnmp_dispatch_table */\n\nstatic int csnmp_read_table(host_definition_t *host, data_definition_t *data) {\n  struct snmp_pdu *req;\n  struct snmp_pdu *res = NULL;\n  struct variable_list *vb;\n\n  const data_set_t *ds;\n\n  size_t oid_list_len = data->values_len + 1;\n  /* Holds the last OID returned by the device. We use this in the GETNEXT\n   * request to proceed. */\n  oid_t oid_list[oid_list_len];\n  /* Set to false when an OID has left its subtree so we don't re-request it\n   * again. */\n  _Bool oid_list_todo[oid_list_len];\n\n  int status;\n  size_t i;\n\n  /* `value_list_head' and `value_list_tail' implement a linked list for each\n   * value. `instance_list_head' and `instance_list_tail' implement a linked\n   * list of\n   * instance names. This is used to jump gaps in the table. */\n  csnmp_list_instances_t *instance_list_head;\n  csnmp_list_instances_t *instance_list_tail;\n  csnmp_table_values_t **value_list_head;\n  csnmp_table_values_t **value_list_tail;\n\n  DEBUG(\"snmp plugin: csnmp_read_table (host = %s, data = %s)\", host->name,\n        data->name);\n\n  if (host->sess_handle == NULL) {\n    DEBUG(\"snmp plugin: csnmp_read_table: host->sess_handle == NULL\");\n    return (-1);\n  }\n\n  ds = plugin_get_ds(data->type);\n  if (!ds) {\n    ERROR(\"snmp plugin: DataSet `%s' not defined.\", data->type);\n    return (-1);\n  }\n\n  if (ds->ds_num != data->values_len) {\n    ERROR(\"snmp plugin: DataSet `%s' requires %zu values, but config talks \"\n          \"about %zu\",\n          data->type, ds->ds_num, data->values_len);\n    return (-1);\n  }\n  assert(data->values_len > 0);\n\n  /* We need a copy of all the OIDs, because GETNEXT will destroy them. */\n  memcpy(oid_list, data->values, data->values_len * sizeof(oid_t));\n  if (data->instance.oid.oid_len > 0)\n    memcpy(oid_list + data->values_len, &data->instance.oid, sizeof(oid_t));\n  else /* no InstanceFrom option specified. */\n    oid_list_len--;\n\n  for (i = 0; i < oid_list_len; i++)\n    oid_list_todo[i] = 1;\n\n  /* We're going to construct n linked lists, one for each \"value\".\n   * value_list_head will contain pointers to the heads of these linked lists,\n   * value_list_tail will contain pointers to the tail of the lists. */\n  value_list_head = calloc(data->values_len, sizeof(*value_list_head));\n  value_list_tail = calloc(data->values_len, sizeof(*value_list_tail));\n  if ((value_list_head == NULL) || (value_list_tail == NULL)) {\n    ERROR(\"snmp plugin: csnmp_read_table: calloc failed.\");\n    sfree(value_list_head);\n    sfree(value_list_tail);\n    return (-1);\n  }\n\n  instance_list_head = NULL;\n  instance_list_tail = NULL;\n\n  status = 0;\n  while (status == 0) {\n    int oid_list_todo_num;\n\n    req = snmp_pdu_create(SNMP_MSG_GETNEXT);\n    if (req == NULL) {\n      ERROR(\"snmp plugin: snmp_pdu_create failed.\");\n      status = -1;\n      break;\n    }\n\n    oid_list_todo_num = 0;\n    for (i = 0; i < oid_list_len; i++) {\n      /* Do not rerequest already finished OIDs */\n      if (!oid_list_todo[i])\n        continue;\n      oid_list_todo_num++;\n      snmp_add_null_var(req, oid_list[i].oid, oid_list[i].oid_len);\n    }\n\n    if (oid_list_todo_num == 0) {\n      /* The request is still empty - so we are finished */\n      DEBUG(\"snmp plugin: all variables have left their subtree\");\n      status = 0;\n      break;\n    }\n\n    res = NULL;\n    status = snmp_sess_synch_response(host->sess_handle, req, &res);\n    if ((status != STAT_SUCCESS) || (res == NULL)) {\n      char *errstr = NULL;\n\n      snmp_sess_error(host->sess_handle, NULL, NULL, &errstr);\n\n      c_complain(LOG_ERR, &host->complaint,\n                 \"snmp plugin: host %s: snmp_sess_synch_response failed: %s\",\n                 host->name, (errstr == NULL) ? \"Unknown problem\" : errstr);\n\n      if (res != NULL)\n        snmp_free_pdu(res);\n      res = NULL;\n\n      /* snmp_synch_response already freed our PDU */\n      req = NULL;\n      sfree(errstr);\n      csnmp_host_close_session(host);\n\n      status = -1;\n      break;\n    }\n\n    status = 0;\n    assert(res != NULL);\n    c_release(LOG_INFO, &host->complaint,\n              \"snmp plugin: host %s: snmp_sess_synch_response successful.\",\n              host->name);\n\n    vb = res->variables;\n    if (vb == NULL) {\n      status = -1;\n      break;\n    }\n\n    for (vb = res->variables, i = 0; (vb != NULL);\n         vb = vb->next_variable, i++) {\n      /* Calculate value index from todo list */\n      while ((i < oid_list_len) && !oid_list_todo[i])\n        i++;\n\n      /* An instance is configured and the res variable we process is the\n       * instance value (last index) */\n      if ((data->instance.oid.oid_len > 0) && (i == data->values_len)) {\n        if ((vb->type == SNMP_ENDOFMIBVIEW) ||\n            (snmp_oid_ncompare(\n                 data->instance.oid.oid, data->instance.oid.oid_len, vb->name,\n                 vb->name_length, data->instance.oid.oid_len) != 0)) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; Instance left its subtree.\",\n                host->name, data->name);\n          oid_list_todo[i] = 0;\n          continue;\n        }\n\n        /* Allocate a new `csnmp_list_instances_t', insert the instance name and\n         * add it to the list */\n        if (csnmp_instance_list_add(&instance_list_head, &instance_list_tail,\n                                    res, host, data) != 0) {\n          ERROR(\"snmp plugin: host %s: csnmp_instance_list_add failed.\",\n                host->name);\n          status = -1;\n          break;\n        }\n      } else /* The variable we are processing is a normal value */\n      {\n        csnmp_table_values_t *vt;\n        oid_t vb_name;\n        oid_t suffix;\n        int ret;\n\n        csnmp_oid_init(&vb_name, vb->name, vb->name_length);\n\n        /* Calculate the current suffix. This is later used to check that the\n         * suffix is increasing. This also checks if we left the subtree */\n        ret = csnmp_oid_suffix(&suffix, &vb_name, data->values + i);\n        if (ret != 0) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; i = %zu; \"\n                \"Value probably left its subtree.\",\n                host->name, data->name, i);\n          oid_list_todo[i] = 0;\n          continue;\n        }\n\n        /* Make sure the OIDs returned by the agent are increasing. Otherwise\n         * our\n         * table matching algorithm will get confused. */\n        if ((value_list_tail[i] != NULL) &&\n            (csnmp_oid_compare(&suffix, &value_list_tail[i]->suffix) <= 0)) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; i = %zu; \"\n                \"Suffix is not increasing.\",\n                host->name, data->name, i);\n          oid_list_todo[i] = 0;\n          continue;\n        }\n\n        vt = calloc(1, sizeof(*vt));\n        if (vt == NULL) {\n          ERROR(\"snmp plugin: calloc failed.\");\n          status = -1;\n          break;\n        }\n\n        vt->value =\n            csnmp_value_list_to_value(vb, ds->ds[i].type, data->scale,\n                                      data->shift, host->name, data->name);\n        memcpy(&vt->suffix, &suffix, sizeof(vt->suffix));\n        vt->next = NULL;\n\n        if (value_list_tail[i] == NULL)\n          value_list_head[i] = vt;\n        else\n          value_list_tail[i]->next = vt;\n        value_list_tail[i] = vt;\n      }\n\n      /* Copy OID to oid_list[i] */\n      memcpy(oid_list[i].oid, vb->name, sizeof(oid) * vb->name_length);\n      oid_list[i].oid_len = vb->name_length;\n\n    } /* for (vb = res->variables ...) */\n\n    if (res != NULL)\n      snmp_free_pdu(res);\n    res = NULL;\n  } /* while (status == 0) */\n\n  if (res != NULL)\n    snmp_free_pdu(res);\n  res = NULL;\n\n  if (req != NULL)\n    snmp_free_pdu(req);\n  req = NULL;\n\n  if (status == 0)\n    csnmp_dispatch_table(host, data, instance_list_head, value_list_head);\n\n  /* Free all allocated variables here */\n  while (instance_list_head != NULL) {\n    csnmp_list_instances_t *next = instance_list_head->next;\n    sfree(instance_list_head);\n    instance_list_head = next;\n  }\n\n  for (i = 0; i < data->values_len; i++) {\n    while (value_list_head[i] != NULL) {\n      csnmp_table_values_t *next = value_list_head[i]->next;\n      sfree(value_list_head[i]);\n      value_list_head[i] = next;\n    }\n  }\n\n  sfree(value_list_head);\n  sfree(value_list_tail);\n\n  return (0);\n} /* int csnmp_read_table */\n\nstatic int csnmp_read_value(host_definition_t *host, data_definition_t *data) {\n  struct snmp_pdu *req;\n  struct snmp_pdu *res = NULL;\n  struct variable_list *vb;\n\n  const data_set_t *ds;\n  value_list_t vl = VALUE_LIST_INIT;\n\n  int status;\n  size_t i;\n\n  DEBUG(\"snmp plugin: csnmp_read_value (host = %s, data = %s)\", host->name,\n        data->name);\n\n  if (host->sess_handle == NULL) {\n    DEBUG(\"snmp plugin: csnmp_read_value: host->sess_handle == NULL\");\n    return (-1);\n  }\n\n  ds = plugin_get_ds(data->type);\n  if (!ds) {\n    ERROR(\"snmp plugin: DataSet `%s' not defined.\", data->type);\n    return (-1);\n  }\n\n  if (ds->ds_num != data->values_len) {\n    ERROR(\"snmp plugin: DataSet `%s' requires %zu values, but config talks \"\n          \"about %zu\",\n          data->type, ds->ds_num, data->values_len);\n    return (-1);\n  }\n\n  vl.values_len = ds->ds_num;\n  vl.values = malloc(sizeof(*vl.values) * vl.values_len);\n  if (vl.values == NULL)\n    return (-1);\n  for (i = 0; i < vl.values_len; i++) {\n    if (ds->ds[i].type == DS_TYPE_COUNTER)\n      vl.values[i].counter = 0;\n    else\n      vl.values[i].gauge = NAN;\n  }\n\n  sstrncpy(vl.host, host->name, sizeof(vl.host));\n  sstrncpy(vl.plugin, \"snmp\", sizeof(vl.plugin));\n  sstrncpy(vl.type, data->type, sizeof(vl.type));\n  sstrncpy(vl.type_instance, data->instance.string, sizeof(vl.type_instance));\n\n  vl.interval = host->interval;\n\n  req = snmp_pdu_create(SNMP_MSG_GET);\n  if (req == NULL) {\n    ERROR(\"snmp plugin: snmp_pdu_create failed.\");\n    sfree(vl.values);\n    return (-1);\n  }\n\n  for (i = 0; i < data->values_len; i++)\n    snmp_add_null_var(req, data->values[i].oid, data->values[i].oid_len);\n\n  status = snmp_sess_synch_response(host->sess_handle, req, &res);\n\n  if ((status != STAT_SUCCESS) || (res == NULL)) {\n    char *errstr = NULL;\n\n    snmp_sess_error(host->sess_handle, NULL, NULL, &errstr);\n    ERROR(\"snmp plugin: host %s: snmp_sess_synch_response failed: %s\",\n          host->name, (errstr == NULL) ? \"Unknown problem\" : errstr);\n\n    if (res != NULL)\n      snmp_free_pdu(res);\n\n    sfree(errstr);\n    sfree(vl.values);\n    csnmp_host_close_session(host);\n\n    return (-1);\n  }\n\n  for (vb = res->variables; vb != NULL; vb = vb->next_variable) {\n#if COLLECT_DEBUG\n    char buffer[1024];\n    snprint_variable(buffer, sizeof(buffer), vb->name, vb->name_length, vb);\n    DEBUG(\"snmp plugin: Got this variable: %s\", buffer);\n#endif /* COLLECT_DEBUG */\n\n    for (i = 0; i < data->values_len; i++)\n      if (snmp_oid_compare(data->values[i].oid, data->values[i].oid_len,\n                           vb->name, vb->name_length) == 0)\n        vl.values[i] =\n            csnmp_value_list_to_value(vb, ds->ds[i].type, data->scale,\n                                      data->shift, host->name, data->name);\n  } /* for (res->variables) */\n\n  snmp_free_pdu(res);\n\n  DEBUG(\"snmp plugin: -> plugin_dispatch_values (&vl);\");\n  plugin_dispatch_values(&vl);\n  sfree(vl.values);\n\n  return (0);\n} /* int csnmp_read_value */\n\nstatic int csnmp_read_host(user_data_t *ud) {\n  host_definition_t *host;\n  int status;\n  int success;\n  int i;\n\n  host = ud->data;\n\n  if (host->interval == 0)\n    host->interval = plugin_get_interval();\n\n  if (host->sess_handle == NULL)\n    csnmp_host_open_session(host);\n\n  if (host->sess_handle == NULL)\n    return (-1);\n\n  success = 0;\n  for (i = 0; i < host->data_list_len; i++) {\n    data_definition_t *data = host->data_list[i];\n\n    if (data->is_table)\n      status = csnmp_read_table(host, data);\n    else\n      status = csnmp_read_value(host, data);\n\n    if (status == 0)\n      success++;\n  }\n\n  if (success == 0)\n    return (-1);\n\n  return (0);\n} /* int csnmp_read_host */\n\nstatic int csnmp_init(void) {\n  call_snmp_init_once();\n\n  return (0);\n} /* int csnmp_init */\n\nstatic int csnmp_shutdown(void) {\n  data_definition_t *data_this;\n  data_definition_t *data_next;\n\n  /* When we get here, the read threads have been stopped and all the\n   * `host_definition_t' will be freed. */\n  DEBUG(\"snmp plugin: Destroying all data definitions.\");\n\n  data_this = data_head;\n  data_head = NULL;\n  while (data_this != NULL) {\n    data_next = data_this->next;\n\n    sfree(data_this->name);\n    sfree(data_this->type);\n    sfree(data_this->values);\n    sfree(data_this->ignores);\n    sfree(data_this);\n\n    data_this = data_next;\n  }\n\n  return (0);\n} /* int csnmp_shutdown */\n\nvoid module_register(void) {\n  plugin_register_complex_config(\"snmp\", csnmp_config);\n  plugin_register_init(\"snmp\", csnmp_init);\n  plugin_register_shutdown(\"snmp\", csnmp_shutdown);\n} /* void module_register */\n\n/*\n * vim: shiftwidth=2 softtabstop=2 tabstop=8 fdm=marker\n */\n"], "fixing_code": ["/**\n * collectd - src/snmp.c\n * Copyright (C) 2007-2012  Florian octo Forster\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * Authors:\n *   Florian octo Forster <octo at collectd.org>\n **/\n\n#include \"collectd.h\"\n\n#include \"common.h\"\n#include \"plugin.h\"\n#include \"utils_complain.h\"\n\n#include <net-snmp/net-snmp-config.h>\n#include <net-snmp/net-snmp-includes.h>\n\n#include <fnmatch.h>\n\n/*\n * Private data structes\n */\nstruct oid_s {\n  oid oid[MAX_OID_LEN];\n  size_t oid_len;\n};\ntypedef struct oid_s oid_t;\n\nunion instance_u {\n  char string[DATA_MAX_NAME_LEN];\n  oid_t oid;\n};\ntypedef union instance_u instance_t;\n\nstruct data_definition_s {\n  char *name; /* used to reference this from the `Collect' option */\n  char *type; /* used to find the data_set */\n  _Bool is_table;\n  instance_t instance;\n  char *instance_prefix;\n  oid_t *values;\n  size_t values_len;\n  double scale;\n  double shift;\n  struct data_definition_s *next;\n  char **ignores;\n  size_t ignores_len;\n  int invert_match;\n};\ntypedef struct data_definition_s data_definition_t;\n\nstruct host_definition_s {\n  char *name;\n  char *address;\n  int version;\n\n  /* snmpv1/2 options */\n  char *community;\n\n  /* snmpv3 security options */\n  char *username;\n  oid *auth_protocol;\n  size_t auth_protocol_len;\n  char *auth_passphrase;\n  oid *priv_protocol;\n  size_t priv_protocol_len;\n  char *priv_passphrase;\n  int security_level;\n  char *context;\n\n  void *sess_handle;\n  c_complain_t complaint;\n  cdtime_t interval;\n  data_definition_t **data_list;\n  int data_list_len;\n};\ntypedef struct host_definition_s host_definition_t;\n\n/* These two types are used to cache values in `csnmp_read_table' to handle\n * gaps in tables. */\nstruct csnmp_list_instances_s {\n  oid_t suffix;\n  char instance[DATA_MAX_NAME_LEN];\n  struct csnmp_list_instances_s *next;\n};\ntypedef struct csnmp_list_instances_s csnmp_list_instances_t;\n\nstruct csnmp_table_values_s {\n  oid_t suffix;\n  value_t value;\n  struct csnmp_table_values_s *next;\n};\ntypedef struct csnmp_table_values_s csnmp_table_values_t;\n\n/*\n * Private variables\n */\nstatic data_definition_t *data_head = NULL;\n\n/*\n * Prototypes\n */\nstatic int csnmp_read_host(user_data_t *ud);\n\n/*\n * Private functions\n */\nstatic void csnmp_oid_init(oid_t *dst, oid const *src, size_t n) {\n  assert(n <= STATIC_ARRAY_SIZE(dst->oid));\n  memcpy(dst->oid, src, sizeof(*src) * n);\n  dst->oid_len = n;\n}\n\nstatic int csnmp_oid_compare(oid_t const *left, oid_t const *right) {\n  return (\n      snmp_oid_compare(left->oid, left->oid_len, right->oid, right->oid_len));\n}\n\nstatic int csnmp_oid_suffix(oid_t *dst, oid_t const *src, oid_t const *root) {\n  /* Make sure \"src\" is in \"root\"s subtree. */\n  if (src->oid_len <= root->oid_len)\n    return (EINVAL);\n  if (snmp_oid_ncompare(root->oid, root->oid_len, src->oid, src->oid_len,\n                        /* n = */ root->oid_len) != 0)\n    return (EINVAL);\n\n  memset(dst, 0, sizeof(*dst));\n  dst->oid_len = src->oid_len - root->oid_len;\n  memcpy(dst->oid, &src->oid[root->oid_len],\n         dst->oid_len * sizeof(dst->oid[0]));\n  return (0);\n}\n\nstatic int csnmp_oid_to_string(char *buffer, size_t buffer_size,\n                               oid_t const *o) {\n  char oid_str[MAX_OID_LEN][16];\n  char *oid_str_ptr[MAX_OID_LEN];\n\n  for (size_t i = 0; i < o->oid_len; i++) {\n    ssnprintf(oid_str[i], sizeof(oid_str[i]), \"%lu\", (unsigned long)o->oid[i]);\n    oid_str_ptr[i] = oid_str[i];\n  }\n\n  return (strjoin(buffer, buffer_size, oid_str_ptr, o->oid_len,\n                  /* separator = */ \".\"));\n}\n\nstatic void csnmp_host_close_session(host_definition_t *host) /* {{{ */\n{\n  if (host->sess_handle == NULL)\n    return;\n\n  snmp_sess_close(host->sess_handle);\n  host->sess_handle = NULL;\n} /* }}} void csnmp_host_close_session */\n\nstatic void csnmp_host_definition_destroy(void *arg) /* {{{ */\n{\n  host_definition_t *hd;\n\n  hd = arg;\n\n  if (hd == NULL)\n    return;\n\n  if (hd->name != NULL) {\n    DEBUG(\"snmp plugin: Destroying host definition for host `%s'.\", hd->name);\n  }\n\n  csnmp_host_close_session(hd);\n\n  sfree(hd->name);\n  sfree(hd->address);\n  sfree(hd->community);\n  sfree(hd->username);\n  sfree(hd->auth_passphrase);\n  sfree(hd->priv_passphrase);\n  sfree(hd->context);\n  sfree(hd->data_list);\n\n  sfree(hd);\n} /* }}} void csnmp_host_definition_destroy */\n\n/* Many functions to handle the configuration. {{{ */\n/* First there are many functions which do configuration stuff. It's a big\n * bloated and messy, I'm afraid. */\n\n/*\n * Callgraph for the config stuff:\n *  csnmp_config\n *  +-> call_snmp_init_once\n *  +-> csnmp_config_add_data\n *  !   +-> csnmp_config_add_data_instance\n *  !   +-> csnmp_config_add_data_instance_prefix\n *  !   +-> csnmp_config_add_data_values\n *  +-> csnmp_config_add_host\n *      +-> csnmp_config_add_host_version\n *      +-> csnmp_config_add_host_collect\n *      +-> csnmp_config_add_host_auth_protocol\n *      +-> csnmp_config_add_host_priv_protocol\n *      +-> csnmp_config_add_host_security_level\n */\nstatic void call_snmp_init_once(void) {\n  static int have_init = 0;\n\n  if (have_init == 0)\n    init_snmp(PACKAGE_NAME);\n  have_init = 1;\n} /* void call_snmp_init_once */\n\nstatic int csnmp_config_add_data_instance(data_definition_t *dd,\n                                          oconfig_item_t *ci) {\n  char buffer[DATA_MAX_NAME_LEN];\n  int status;\n\n  status = cf_util_get_string_buffer(ci, buffer, sizeof(buffer));\n  if (status != 0)\n    return status;\n\n  if (dd->is_table) {\n    /* Instance is an OID */\n    dd->instance.oid.oid_len = MAX_OID_LEN;\n\n    if (!read_objid(buffer, dd->instance.oid.oid, &dd->instance.oid.oid_len)) {\n      ERROR(\"snmp plugin: read_objid (%s) failed.\", buffer);\n      return (-1);\n    }\n  } else {\n    /* Instance is a simple string */\n    sstrncpy(dd->instance.string, buffer, sizeof(dd->instance.string));\n  }\n\n  return (0);\n} /* int csnmp_config_add_data_instance */\n\nstatic int csnmp_config_add_data_instance_prefix(data_definition_t *dd,\n                                                 oconfig_item_t *ci) {\n  int status;\n\n  if (!dd->is_table) {\n    WARNING(\"snmp plugin: data %s: InstancePrefix is ignored when `Table' \"\n            \"is set to `false'.\",\n            dd->name);\n    return (-1);\n  }\n\n  status = cf_util_get_string(ci, &dd->instance_prefix);\n  return status;\n} /* int csnmp_config_add_data_instance_prefix */\n\nstatic int csnmp_config_add_data_values(data_definition_t *dd,\n                                        oconfig_item_t *ci) {\n  if (ci->values_num < 1) {\n    WARNING(\"snmp plugin: `Values' needs at least one argument.\");\n    return (-1);\n  }\n\n  for (int i = 0; i < ci->values_num; i++)\n    if (ci->values[i].type != OCONFIG_TYPE_STRING) {\n      WARNING(\"snmp plugin: `Values' needs only string argument.\");\n      return (-1);\n    }\n\n  sfree(dd->values);\n  dd->values_len = 0;\n  dd->values = malloc(sizeof(*dd->values) * ci->values_num);\n  if (dd->values == NULL)\n    return (-1);\n  dd->values_len = (size_t)ci->values_num;\n\n  for (int i = 0; i < ci->values_num; i++) {\n    dd->values[i].oid_len = MAX_OID_LEN;\n\n    if (NULL == snmp_parse_oid(ci->values[i].value.string, dd->values[i].oid,\n                               &dd->values[i].oid_len)) {\n      ERROR(\"snmp plugin: snmp_parse_oid (%s) failed.\",\n            ci->values[i].value.string);\n      free(dd->values);\n      dd->values = NULL;\n      dd->values_len = 0;\n      return (-1);\n    }\n  }\n\n  return (0);\n} /* int csnmp_config_add_data_instance */\n\nstatic int csnmp_config_add_data_blacklist(data_definition_t *dd,\n                                           oconfig_item_t *ci) {\n  if (ci->values_num < 1)\n    return (0);\n\n  for (int i = 0; i < ci->values_num; i++) {\n    if (ci->values[i].type != OCONFIG_TYPE_STRING) {\n      WARNING(\"snmp plugin: `Ignore' needs only string argument.\");\n      return (-1);\n    }\n  }\n\n  dd->ignores_len = 0;\n  dd->ignores = NULL;\n\n  for (int i = 0; i < ci->values_num; ++i) {\n    if (strarray_add(&(dd->ignores), &(dd->ignores_len),\n                     ci->values[i].value.string) != 0) {\n      ERROR(\"snmp plugin: Can't allocate memory\");\n      strarray_free(dd->ignores, dd->ignores_len);\n      return (ENOMEM);\n    }\n  }\n  return 0;\n} /* int csnmp_config_add_data_blacklist */\n\nstatic int csnmp_config_add_data_blacklist_match_inverted(data_definition_t *dd,\n                                                          oconfig_item_t *ci) {\n  if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_BOOLEAN)) {\n    WARNING(\"snmp plugin: `InvertMatch' needs exactly one boolean argument.\");\n    return (-1);\n  }\n\n  dd->invert_match = ci->values[0].value.boolean ? 1 : 0;\n\n  return (0);\n} /* int csnmp_config_add_data_blacklist_match_inverted */\n\nstatic int csnmp_config_add_data(oconfig_item_t *ci) {\n  data_definition_t *dd;\n  int status = 0;\n\n  dd = calloc(1, sizeof(*dd));\n  if (dd == NULL)\n    return (-1);\n\n  status = cf_util_get_string(ci, &dd->name);\n  if (status != 0) {\n    free(dd);\n    return (-1);\n  }\n\n  dd->scale = 1.0;\n  dd->shift = 0.0;\n\n  for (int i = 0; i < ci->children_num; i++) {\n    oconfig_item_t *option = ci->children + i;\n\n    if (strcasecmp(\"Type\", option->key) == 0)\n      status = cf_util_get_string(option, &dd->type);\n    else if (strcasecmp(\"Table\", option->key) == 0)\n      status = cf_util_get_boolean(option, &dd->is_table);\n    else if (strcasecmp(\"Instance\", option->key) == 0)\n      status = csnmp_config_add_data_instance(dd, option);\n    else if (strcasecmp(\"InstancePrefix\", option->key) == 0)\n      status = csnmp_config_add_data_instance_prefix(dd, option);\n    else if (strcasecmp(\"Values\", option->key) == 0)\n      status = csnmp_config_add_data_values(dd, option);\n    else if (strcasecmp(\"Shift\", option->key) == 0)\n      status = cf_util_get_double(option, &dd->shift);\n    else if (strcasecmp(\"Scale\", option->key) == 0)\n      status = cf_util_get_double(option, &dd->scale);\n    else if (strcasecmp(\"Ignore\", option->key) == 0)\n      status = csnmp_config_add_data_blacklist(dd, option);\n    else if (strcasecmp(\"InvertMatch\", option->key) == 0)\n      status = csnmp_config_add_data_blacklist_match_inverted(dd, option);\n    else {\n      WARNING(\"snmp plugin: Option `%s' not allowed here.\", option->key);\n      status = -1;\n    }\n\n    if (status != 0)\n      break;\n  } /* for (ci->children) */\n\n  while (status == 0) {\n    if (dd->type == NULL) {\n      WARNING(\"snmp plugin: `Type' not given for data `%s'\", dd->name);\n      status = -1;\n      break;\n    }\n    if (dd->values == NULL) {\n      WARNING(\"snmp plugin: No `Value' given for data `%s'\", dd->name);\n      status = -1;\n      break;\n    }\n\n    break;\n  } /* while (status == 0) */\n\n  if (status != 0) {\n    sfree(dd->name);\n    sfree(dd->instance_prefix);\n    sfree(dd->values);\n    sfree(dd->ignores);\n    sfree(dd);\n    return (-1);\n  }\n\n  DEBUG(\"snmp plugin: dd = { name = %s, type = %s, is_table = %s, values_len = \"\n        \"%zu }\",\n        dd->name, dd->type, (dd->is_table != 0) ? \"true\" : \"false\",\n        dd->values_len);\n\n  if (data_head == NULL)\n    data_head = dd;\n  else {\n    data_definition_t *last;\n    last = data_head;\n    while (last->next != NULL)\n      last = last->next;\n    last->next = dd;\n  }\n\n  return (0);\n} /* int csnmp_config_add_data */\n\nstatic int csnmp_config_add_host_version(host_definition_t *hd,\n                                         oconfig_item_t *ci) {\n  int version;\n\n  if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_NUMBER)) {\n    WARNING(\"snmp plugin: The `Version' config option needs exactly one number \"\n            \"argument.\");\n    return (-1);\n  }\n\n  version = (int)ci->values[0].value.number;\n  if ((version < 1) || (version > 3)) {\n    WARNING(\"snmp plugin: `Version' must either be `1', `2', or `3'.\");\n    return (-1);\n  }\n\n  hd->version = version;\n\n  return (0);\n} /* int csnmp_config_add_host_address */\n\nstatic int csnmp_config_add_host_collect(host_definition_t *host,\n                                         oconfig_item_t *ci) {\n  data_definition_t *data;\n  data_definition_t **data_list;\n  int data_list_len;\n\n  if (ci->values_num < 1) {\n    WARNING(\"snmp plugin: `Collect' needs at least one argument.\");\n    return (-1);\n  }\n\n  for (int i = 0; i < ci->values_num; i++)\n    if (ci->values[i].type != OCONFIG_TYPE_STRING) {\n      WARNING(\"snmp plugin: All arguments to `Collect' must be strings.\");\n      return (-1);\n    }\n\n  data_list_len = host->data_list_len + ci->values_num;\n  data_list =\n      realloc(host->data_list, sizeof(data_definition_t *) * data_list_len);\n  if (data_list == NULL)\n    return (-1);\n  host->data_list = data_list;\n\n  for (int i = 0; i < ci->values_num; i++) {\n    for (data = data_head; data != NULL; data = data->next)\n      if (strcasecmp(ci->values[i].value.string, data->name) == 0)\n        break;\n\n    if (data == NULL) {\n      WARNING(\"snmp plugin: No such data configured: `%s'\",\n              ci->values[i].value.string);\n      continue;\n    }\n\n    DEBUG(\"snmp plugin: Collect: host = %s, data[%i] = %s;\", host->name,\n          host->data_list_len, data->name);\n\n    host->data_list[host->data_list_len] = data;\n    host->data_list_len++;\n  } /* for (values_num) */\n\n  return (0);\n} /* int csnmp_config_add_host_collect */\n\nstatic int csnmp_config_add_host_auth_protocol(host_definition_t *hd,\n                                               oconfig_item_t *ci) {\n  char buffer[4];\n  int status;\n\n  status = cf_util_get_string_buffer(ci, buffer, sizeof(buffer));\n  if (status != 0)\n    return status;\n\n  if (strcasecmp(\"MD5\", buffer) == 0) {\n    hd->auth_protocol = usmHMACMD5AuthProtocol;\n    hd->auth_protocol_len = sizeof(usmHMACMD5AuthProtocol) / sizeof(oid);\n  } else if (strcasecmp(\"SHA\", buffer) == 0) {\n    hd->auth_protocol = usmHMACSHA1AuthProtocol;\n    hd->auth_protocol_len = sizeof(usmHMACSHA1AuthProtocol) / sizeof(oid);\n  } else {\n    WARNING(\"snmp plugin: The `AuthProtocol' config option must be `MD5' or \"\n            \"`SHA'.\");\n    return (-1);\n  }\n\n  DEBUG(\"snmp plugin: host = %s; host->auth_protocol = %s;\", hd->name,\n        hd->auth_protocol == usmHMACMD5AuthProtocol ? \"MD5\" : \"SHA\");\n\n  return (0);\n} /* int csnmp_config_add_host_auth_protocol */\n\nstatic int csnmp_config_add_host_priv_protocol(host_definition_t *hd,\n                                               oconfig_item_t *ci) {\n  char buffer[4];\n  int status;\n\n  status = cf_util_get_string_buffer(ci, buffer, sizeof(buffer));\n  if (status != 0)\n    return status;\n\n  if (strcasecmp(\"AES\", buffer) == 0) {\n    hd->priv_protocol = usmAESPrivProtocol;\n    hd->priv_protocol_len = sizeof(usmAESPrivProtocol) / sizeof(oid);\n  } else if (strcasecmp(\"DES\", buffer) == 0) {\n    hd->priv_protocol = usmDESPrivProtocol;\n    hd->priv_protocol_len = sizeof(usmDESPrivProtocol) / sizeof(oid);\n  } else {\n    WARNING(\"snmp plugin: The `PrivProtocol' config option must be `AES' or \"\n            \"`DES'.\");\n    return (-1);\n  }\n\n  DEBUG(\"snmp plugin: host = %s; host->priv_protocol = %s;\", hd->name,\n        hd->priv_protocol == usmAESPrivProtocol ? \"AES\" : \"DES\");\n\n  return (0);\n} /* int csnmp_config_add_host_priv_protocol */\n\nstatic int csnmp_config_add_host_security_level(host_definition_t *hd,\n                                                oconfig_item_t *ci) {\n  char buffer[16];\n  int status;\n\n  status = cf_util_get_string_buffer(ci, buffer, sizeof(buffer));\n  if (status != 0)\n    return status;\n\n  if (strcasecmp(\"noAuthNoPriv\", buffer) == 0)\n    hd->security_level = SNMP_SEC_LEVEL_NOAUTH;\n  else if (strcasecmp(\"authNoPriv\", buffer) == 0)\n    hd->security_level = SNMP_SEC_LEVEL_AUTHNOPRIV;\n  else if (strcasecmp(\"authPriv\", buffer) == 0)\n    hd->security_level = SNMP_SEC_LEVEL_AUTHPRIV;\n  else {\n    WARNING(\"snmp plugin: The `SecurityLevel' config option must be \"\n            \"`noAuthNoPriv', `authNoPriv', or `authPriv'.\");\n    return (-1);\n  }\n\n  DEBUG(\"snmp plugin: host = %s; host->security_level = %d;\", hd->name,\n        hd->security_level);\n\n  return (0);\n} /* int csnmp_config_add_host_security_level */\n\nstatic int csnmp_config_add_host(oconfig_item_t *ci) {\n  host_definition_t *hd;\n  int status = 0;\n\n  /* Registration stuff. */\n  char cb_name[DATA_MAX_NAME_LEN];\n\n  hd = calloc(1, sizeof(*hd));\n  if (hd == NULL)\n    return (-1);\n  hd->version = 2;\n  C_COMPLAIN_INIT(&hd->complaint);\n\n  status = cf_util_get_string(ci, &hd->name);\n  if (status != 0) {\n    sfree(hd);\n    return status;\n  }\n\n  hd->sess_handle = NULL;\n  hd->interval = 0;\n\n  for (int i = 0; i < ci->children_num; i++) {\n    oconfig_item_t *option = ci->children + i;\n    status = 0;\n\n    if (strcasecmp(\"Address\", option->key) == 0)\n      status = cf_util_get_string(option, &hd->address);\n    else if (strcasecmp(\"Community\", option->key) == 0)\n      status = cf_util_get_string(option, &hd->community);\n    else if (strcasecmp(\"Version\", option->key) == 0)\n      status = csnmp_config_add_host_version(hd, option);\n    else if (strcasecmp(\"Collect\", option->key) == 0)\n      csnmp_config_add_host_collect(hd, option);\n    else if (strcasecmp(\"Interval\", option->key) == 0)\n      cf_util_get_cdtime(option, &hd->interval);\n    else if (strcasecmp(\"Username\", option->key) == 0)\n      status = cf_util_get_string(option, &hd->username);\n    else if (strcasecmp(\"AuthProtocol\", option->key) == 0)\n      status = csnmp_config_add_host_auth_protocol(hd, option);\n    else if (strcasecmp(\"PrivacyProtocol\", option->key) == 0)\n      status = csnmp_config_add_host_priv_protocol(hd, option);\n    else if (strcasecmp(\"AuthPassphrase\", option->key) == 0)\n      status = cf_util_get_string(option, &hd->auth_passphrase);\n    else if (strcasecmp(\"PrivacyPassphrase\", option->key) == 0)\n      status = cf_util_get_string(option, &hd->priv_passphrase);\n    else if (strcasecmp(\"SecurityLevel\", option->key) == 0)\n      status = csnmp_config_add_host_security_level(hd, option);\n    else if (strcasecmp(\"Context\", option->key) == 0)\n      status = cf_util_get_string(option, &hd->context);\n    else {\n      WARNING(\n          \"snmp plugin: csnmp_config_add_host: Option `%s' not allowed here.\",\n          option->key);\n      status = -1;\n    }\n\n    if (status != 0)\n      break;\n  } /* for (ci->children) */\n\n  while (status == 0) {\n    if (hd->address == NULL) {\n      WARNING(\"snmp plugin: `Address' not given for host `%s'\", hd->name);\n      status = -1;\n      break;\n    }\n    if (hd->community == NULL && hd->version < 3) {\n      WARNING(\"snmp plugin: `Community' not given for host `%s'\", hd->name);\n      status = -1;\n      break;\n    }\n    if (hd->version == 3) {\n      if (hd->username == NULL) {\n        WARNING(\"snmp plugin: `Username' not given for host `%s'\", hd->name);\n        status = -1;\n        break;\n      }\n      if (hd->security_level == 0) {\n        WARNING(\"snmp plugin: `SecurityLevel' not given for host `%s'\",\n                hd->name);\n        status = -1;\n        break;\n      }\n      if (hd->security_level == SNMP_SEC_LEVEL_AUTHNOPRIV ||\n          hd->security_level == SNMP_SEC_LEVEL_AUTHPRIV) {\n        if (hd->auth_protocol == NULL) {\n          WARNING(\"snmp plugin: `AuthProtocol' not given for host `%s'\",\n                  hd->name);\n          status = -1;\n          break;\n        }\n        if (hd->auth_passphrase == NULL) {\n          WARNING(\"snmp plugin: `AuthPassphrase' not given for host `%s'\",\n                  hd->name);\n          status = -1;\n          break;\n        }\n      }\n      if (hd->security_level == SNMP_SEC_LEVEL_AUTHPRIV) {\n        if (hd->priv_protocol == NULL) {\n          WARNING(\"snmp plugin: `PrivacyProtocol' not given for host `%s'\",\n                  hd->name);\n          status = -1;\n          break;\n        }\n        if (hd->priv_passphrase == NULL) {\n          WARNING(\"snmp plugin: `PrivacyPassphrase' not given for host `%s'\",\n                  hd->name);\n          status = -1;\n          break;\n        }\n      }\n    }\n\n    break;\n  } /* while (status == 0) */\n\n  if (status != 0) {\n    csnmp_host_definition_destroy(hd);\n    return (-1);\n  }\n\n  DEBUG(\"snmp plugin: hd = { name = %s, address = %s, community = %s, version \"\n        \"= %i }\",\n        hd->name, hd->address, hd->community, hd->version);\n\n  ssnprintf(cb_name, sizeof(cb_name), \"snmp-%s\", hd->name);\n\n  user_data_t ud = {.data = hd, .free_func = csnmp_host_definition_destroy};\n\n  status =\n      plugin_register_complex_read(/* group = */ NULL, cb_name, csnmp_read_host,\n                                   hd->interval, /* user_data = */ &ud);\n  if (status != 0) {\n    ERROR(\"snmp plugin: Registering complex read function failed.\");\n    csnmp_host_definition_destroy(hd);\n    return (-1);\n  }\n\n  return (0);\n} /* int csnmp_config_add_host */\n\nstatic int csnmp_config(oconfig_item_t *ci) {\n  call_snmp_init_once();\n\n  for (int i = 0; i < ci->children_num; i++) {\n    oconfig_item_t *child = ci->children + i;\n    if (strcasecmp(\"Data\", child->key) == 0)\n      csnmp_config_add_data(child);\n    else if (strcasecmp(\"Host\", child->key) == 0)\n      csnmp_config_add_host(child);\n    else {\n      WARNING(\"snmp plugin: Ignoring unknown config option `%s'.\", child->key);\n    }\n  } /* for (ci->children) */\n\n  return (0);\n} /* int csnmp_config */\n\n/* }}} End of the config stuff. Now the interesting part begins */\n\nstatic void csnmp_host_open_session(host_definition_t *host) {\n  struct snmp_session sess;\n  int error;\n\n  if (host->sess_handle != NULL)\n    csnmp_host_close_session(host);\n\n  snmp_sess_init(&sess);\n  sess.peername = host->address;\n  switch (host->version) {\n  case 1:\n    sess.version = SNMP_VERSION_1;\n    break;\n  case 3:\n    sess.version = SNMP_VERSION_3;\n    break;\n  default:\n    sess.version = SNMP_VERSION_2c;\n    break;\n  }\n\n  if (host->version == 3) {\n    sess.securityName = host->username;\n    sess.securityNameLen = strlen(host->username);\n    sess.securityLevel = host->security_level;\n\n    if (sess.securityLevel == SNMP_SEC_LEVEL_AUTHNOPRIV ||\n        sess.securityLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n      sess.securityAuthProto = host->auth_protocol;\n      sess.securityAuthProtoLen = host->auth_protocol_len;\n      sess.securityAuthKeyLen = USM_AUTH_KU_LEN;\n      error = generate_Ku(sess.securityAuthProto, sess.securityAuthProtoLen,\n                          (u_char *)host->auth_passphrase,\n                          strlen(host->auth_passphrase), sess.securityAuthKey,\n                          &sess.securityAuthKeyLen);\n      if (error != SNMPERR_SUCCESS) {\n        ERROR(\"snmp plugin: host %s: Error generating Ku from auth_passphrase. \"\n              \"(Error %d)\",\n              host->name, error);\n      }\n    }\n\n    if (sess.securityLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n      sess.securityPrivProto = host->priv_protocol;\n      sess.securityPrivProtoLen = host->priv_protocol_len;\n      sess.securityPrivKeyLen = USM_PRIV_KU_LEN;\n      error = generate_Ku(sess.securityAuthProto, sess.securityAuthProtoLen,\n                          (u_char *)host->priv_passphrase,\n                          strlen(host->priv_passphrase), sess.securityPrivKey,\n                          &sess.securityPrivKeyLen);\n      if (error != SNMPERR_SUCCESS) {\n        ERROR(\"snmp plugin: host %s: Error generating Ku from priv_passphrase. \"\n              \"(Error %d)\",\n              host->name, error);\n      }\n    }\n\n    if (host->context != NULL) {\n      sess.contextName = host->context;\n      sess.contextNameLen = strlen(host->context);\n    }\n  } else /* SNMPv1/2 \"authenticates\" with community string */\n  {\n    sess.community = (u_char *)host->community;\n    sess.community_len = strlen(host->community);\n  }\n\n  /* snmp_sess_open will copy the `struct snmp_session *'. */\n  host->sess_handle = snmp_sess_open(&sess);\n\n  if (host->sess_handle == NULL) {\n    char *errstr = NULL;\n\n    snmp_error(&sess, NULL, NULL, &errstr);\n\n    ERROR(\"snmp plugin: host %s: snmp_sess_open failed: %s\", host->name,\n          (errstr == NULL) ? \"Unknown problem\" : errstr);\n    sfree(errstr);\n  }\n} /* void csnmp_host_open_session */\n\n/* TODO: Check if negative values wrap around. Problem: negative temperatures.\n */\nstatic value_t csnmp_value_list_to_value(struct variable_list *vl, int type,\n                                         double scale, double shift,\n                                         const char *host_name,\n                                         const char *data_name) {\n  value_t ret;\n  uint64_t tmp_unsigned = 0;\n  int64_t tmp_signed = 0;\n  _Bool defined = 1;\n  /* Set to true when the original SNMP type appears to have been signed. */\n  _Bool prefer_signed = 0;\n\n  if ((vl->type == ASN_INTEGER) || (vl->type == ASN_UINTEGER) ||\n      (vl->type == ASN_COUNTER)\n#ifdef ASN_TIMETICKS\n      || (vl->type == ASN_TIMETICKS)\n#endif\n      || (vl->type == ASN_GAUGE)) {\n    tmp_unsigned = (uint32_t)*vl->val.integer;\n    tmp_signed = (int32_t)*vl->val.integer;\n\n    if (vl->type == ASN_INTEGER)\n      prefer_signed = 1;\n\n    DEBUG(\"snmp plugin: Parsed int32 value is %\" PRIu64 \".\", tmp_unsigned);\n  } else if (vl->type == ASN_COUNTER64) {\n    tmp_unsigned = (uint32_t)vl->val.counter64->high;\n    tmp_unsigned = tmp_unsigned << 32;\n    tmp_unsigned += (uint32_t)vl->val.counter64->low;\n    tmp_signed = (int64_t)tmp_unsigned;\n    DEBUG(\"snmp plugin: Parsed int64 value is %\" PRIu64 \".\", tmp_unsigned);\n  } else if (vl->type == ASN_OCTET_STR) {\n    /* We'll handle this later.. */\n  } else {\n    char oid_buffer[1024] = {0};\n\n    snprint_objid(oid_buffer, sizeof(oid_buffer) - 1, vl->name,\n                  vl->name_length);\n\n#ifdef ASN_NULL\n    if (vl->type == ASN_NULL)\n      INFO(\"snmp plugin: OID \\\"%s\\\" is undefined (type ASN_NULL)\", oid_buffer);\n    else\n#endif\n      WARNING(\"snmp plugin: I don't know the ASN type #%i \"\n              \"(OID: \\\"%s\\\", data block \\\"%s\\\", host block \\\"%s\\\")\",\n              (int)vl->type, oid_buffer,\n              (data_name != NULL) ? data_name : \"UNKNOWN\",\n              (host_name != NULL) ? host_name : \"UNKNOWN\");\n\n    defined = 0;\n  }\n\n  if (vl->type == ASN_OCTET_STR) {\n    int status = -1;\n\n    if (vl->val.string != NULL) {\n      char string[64];\n      size_t string_length;\n\n      string_length = sizeof(string) - 1;\n      if (vl->val_len < string_length)\n        string_length = vl->val_len;\n\n      /* The strings we get from the Net-SNMP library may not be null\n       * terminated. That is why we're using `memcpy' here and not `strcpy'.\n       * `string_length' is set to `vl->val_len' which holds the length of the\n       * string.  -octo */\n      memcpy(string, vl->val.string, string_length);\n      string[string_length] = 0;\n\n      status = parse_value(string, &ret, type);\n      if (status != 0) {\n        ERROR(\"snmp plugin: host %s: csnmp_value_list_to_value: Parsing string \"\n              \"as %s failed: %s\",\n              (host_name != NULL) ? host_name : \"UNKNOWN\",\n              DS_TYPE_TO_STRING(type), string);\n      }\n    }\n\n    if (status != 0) {\n      switch (type) {\n      case DS_TYPE_COUNTER:\n      case DS_TYPE_DERIVE:\n      case DS_TYPE_ABSOLUTE:\n        memset(&ret, 0, sizeof(ret));\n        break;\n\n      case DS_TYPE_GAUGE:\n        ret.gauge = NAN;\n        break;\n\n      default:\n        ERROR(\"snmp plugin: csnmp_value_list_to_value: Unknown \"\n              \"data source type: %i.\",\n              type);\n        ret.gauge = NAN;\n      }\n    }\n  } /* if (vl->type == ASN_OCTET_STR) */\n  else if (type == DS_TYPE_COUNTER) {\n    ret.counter = tmp_unsigned;\n  } else if (type == DS_TYPE_GAUGE) {\n    if (!defined)\n      ret.gauge = NAN;\n    else if (prefer_signed)\n      ret.gauge = (scale * tmp_signed) + shift;\n    else\n      ret.gauge = (scale * tmp_unsigned) + shift;\n  } else if (type == DS_TYPE_DERIVE) {\n    if (prefer_signed)\n      ret.derive = (derive_t)tmp_signed;\n    else\n      ret.derive = (derive_t)tmp_unsigned;\n  } else if (type == DS_TYPE_ABSOLUTE) {\n    ret.absolute = (absolute_t)tmp_unsigned;\n  } else {\n    ERROR(\"snmp plugin: csnmp_value_list_to_value: Unknown data source \"\n          \"type: %i.\",\n          type);\n    ret.gauge = NAN;\n  }\n\n  return (ret);\n} /* value_t csnmp_value_list_to_value */\n\n/* csnmp_strvbcopy_hexstring converts the bit string contained in \"vb\" to a hex\n * representation and writes it to dst. Returns zero on success and ENOMEM if\n * dst is not large enough to hold the string. dst is guaranteed to be\n * nul-terminated. */\nstatic int csnmp_strvbcopy_hexstring(char *dst, /* {{{ */\n                                     const struct variable_list *vb,\n                                     size_t dst_size) {\n  char *buffer_ptr;\n  size_t buffer_free;\n\n  dst[0] = 0;\n\n  buffer_ptr = dst;\n  buffer_free = dst_size;\n\n  for (size_t i = 0; i < vb->val_len; i++) {\n    int status;\n\n    status = snprintf(buffer_ptr, buffer_free, (i == 0) ? \"%02x\" : \":%02x\",\n                      (unsigned int)vb->val.bitstring[i]);\n    assert(status >= 0);\n\n    if (((size_t)status) >= buffer_free) /* truncated */\n    {\n      dst[dst_size - 1] = 0;\n      return ENOMEM;\n    } else /* if (status < buffer_free) */\n    {\n      buffer_ptr += (size_t)status;\n      buffer_free -= (size_t)status;\n    }\n  }\n\n  return 0;\n} /* }}} int csnmp_strvbcopy_hexstring */\n\n/* csnmp_strvbcopy copies the octet string or bit string contained in vb to\n * dst. If non-printable characters are detected, it will switch to a hex\n * representation of the string. Returns zero on success, EINVAL if vb does not\n * contain a string and ENOMEM if dst is not large enough to contain the\n * string. */\nstatic int csnmp_strvbcopy(char *dst, /* {{{ */\n                           const struct variable_list *vb, size_t dst_size) {\n  char *src;\n  size_t num_chars;\n\n  if (vb->type == ASN_OCTET_STR)\n    src = (char *)vb->val.string;\n  else if (vb->type == ASN_BIT_STR)\n    src = (char *)vb->val.bitstring;\n  else if (vb->type == ASN_IPADDRESS) {\n    return ssnprintf(dst, dst_size,\n                     \"%\" PRIu8 \".%\" PRIu8 \".%\" PRIu8 \".%\" PRIu8 \"\",\n                     (uint8_t)vb->val.string[0], (uint8_t)vb->val.string[1],\n                     (uint8_t)vb->val.string[2], (uint8_t)vb->val.string[3]);\n  } else {\n    dst[0] = 0;\n    return (EINVAL);\n  }\n\n  num_chars = dst_size - 1;\n  if (num_chars > vb->val_len)\n    num_chars = vb->val_len;\n\n  for (size_t i = 0; i < num_chars; i++) {\n    /* Check for control characters. */\n    if ((unsigned char)src[i] < 32)\n      return (csnmp_strvbcopy_hexstring(dst, vb, dst_size));\n    dst[i] = src[i];\n  }\n  dst[num_chars] = 0;\n  dst[dst_size - 1] = 0;\n\n  if (dst_size <= vb->val_len)\n    return ENOMEM;\n\n  return 0;\n} /* }}} int csnmp_strvbcopy */\n\nstatic int csnmp_instance_list_add(csnmp_list_instances_t **head,\n                                   csnmp_list_instances_t **tail,\n                                   const struct snmp_pdu *res,\n                                   const host_definition_t *hd,\n                                   const data_definition_t *dd) {\n  csnmp_list_instances_t *il;\n  struct variable_list *vb;\n  oid_t vb_name;\n  int status;\n  uint32_t is_matched;\n\n  /* Set vb on the last variable */\n  for (vb = res->variables; (vb != NULL) && (vb->next_variable != NULL);\n       vb = vb->next_variable)\n    /* do nothing */;\n  if (vb == NULL)\n    return (-1);\n\n  csnmp_oid_init(&vb_name, vb->name, vb->name_length);\n\n  il = calloc(1, sizeof(*il));\n  if (il == NULL) {\n    ERROR(\"snmp plugin: calloc failed.\");\n    return (-1);\n  }\n  il->next = NULL;\n\n  status = csnmp_oid_suffix(&il->suffix, &vb_name, &dd->instance.oid);\n  if (status != 0) {\n    sfree(il);\n    return (status);\n  }\n\n  /* Get instance name */\n  if ((vb->type == ASN_OCTET_STR) || (vb->type == ASN_BIT_STR) ||\n      (vb->type == ASN_IPADDRESS)) {\n    char *ptr;\n\n    csnmp_strvbcopy(il->instance, vb, sizeof(il->instance));\n    is_matched = 0;\n    for (uint32_t i = 0; i < dd->ignores_len; i++) {\n      status = fnmatch(dd->ignores[i], il->instance, 0);\n      if (status == 0) {\n        if (dd->invert_match == 0) {\n          sfree(il);\n          return 0;\n        } else {\n          is_matched = 1;\n          break;\n        }\n      }\n    }\n    if (dd->invert_match != 0 && is_matched == 0) {\n      sfree(il);\n      return 0;\n    }\n    for (ptr = il->instance; *ptr != '\\0'; ptr++) {\n      if ((*ptr > 0) && (*ptr < 32))\n        *ptr = ' ';\n      else if (*ptr == '/')\n        *ptr = '_';\n    }\n    DEBUG(\"snmp plugin: il->instance = `%s';\", il->instance);\n  } else {\n    value_t val = csnmp_value_list_to_value(\n        vb, DS_TYPE_COUNTER,\n        /* scale = */ 1.0, /* shift = */ 0.0, hd->name, dd->name);\n    ssnprintf(il->instance, sizeof(il->instance), \"%llu\", val.counter);\n  }\n\n  /* TODO: Debugging output */\n\n  if (*head == NULL)\n    *head = il;\n  else\n    (*tail)->next = il;\n  *tail = il;\n\n  return (0);\n} /* int csnmp_instance_list_add */\n\nstatic int csnmp_dispatch_table(host_definition_t *host,\n                                data_definition_t *data,\n                                csnmp_list_instances_t *instance_list,\n                                csnmp_table_values_t **value_table) {\n  const data_set_t *ds;\n  value_list_t vl = VALUE_LIST_INIT;\n\n  csnmp_list_instances_t *instance_list_ptr;\n  csnmp_table_values_t **value_table_ptr;\n\n  size_t i;\n  _Bool have_more;\n  oid_t current_suffix;\n\n  ds = plugin_get_ds(data->type);\n  if (!ds) {\n    ERROR(\"snmp plugin: DataSet `%s' not defined.\", data->type);\n    return (-1);\n  }\n  assert(ds->ds_num == data->values_len);\n  assert(data->values_len > 0);\n\n  instance_list_ptr = instance_list;\n\n  value_table_ptr = calloc(data->values_len, sizeof(*value_table_ptr));\n  if (value_table_ptr == NULL)\n    return (-1);\n  for (i = 0; i < data->values_len; i++)\n    value_table_ptr[i] = value_table[i];\n\n  vl.values_len = data->values_len;\n  vl.values = malloc(sizeof(*vl.values) * vl.values_len);\n  if (vl.values == NULL) {\n    ERROR(\"snmp plugin: malloc failed.\");\n    sfree(value_table_ptr);\n    return (-1);\n  }\n\n  sstrncpy(vl.host, host->name, sizeof(vl.host));\n  sstrncpy(vl.plugin, \"snmp\", sizeof(vl.plugin));\n\n  vl.interval = host->interval;\n\n  have_more = 1;\n  while (have_more) {\n    _Bool suffix_skipped = 0;\n\n    /* Determine next suffix to handle. */\n    if (instance_list != NULL) {\n      if (instance_list_ptr == NULL) {\n        have_more = 0;\n        continue;\n      }\n\n      memcpy(&current_suffix, &instance_list_ptr->suffix,\n             sizeof(current_suffix));\n    } else /* no instance configured */\n    {\n      csnmp_table_values_t *ptr = value_table_ptr[0];\n      if (ptr == NULL) {\n        have_more = 0;\n        continue;\n      }\n\n      memcpy(&current_suffix, &ptr->suffix, sizeof(current_suffix));\n    }\n\n    /* Update all the value_table_ptr to point at the entry with the same\n     * trailing partial OID */\n    for (i = 0; i < data->values_len; i++) {\n      while (\n          (value_table_ptr[i] != NULL) &&\n          (csnmp_oid_compare(&value_table_ptr[i]->suffix, &current_suffix) < 0))\n        value_table_ptr[i] = value_table_ptr[i]->next;\n\n      if (value_table_ptr[i] == NULL) {\n        have_more = 0;\n        break;\n      } else if (csnmp_oid_compare(&value_table_ptr[i]->suffix,\n                                   &current_suffix) > 0) {\n        /* This suffix is missing in the subtree. Indicate this with the\n         * \"suffix_skipped\" flag and try the next instance / suffix. */\n        suffix_skipped = 1;\n        break;\n      }\n    } /* for (i = 0; i < columns; i++) */\n\n    if (!have_more)\n      break;\n\n    /* Matching the values failed. Start from the beginning again. */\n    if (suffix_skipped) {\n      if (instance_list != NULL)\n        instance_list_ptr = instance_list_ptr->next;\n      else\n        value_table_ptr[0] = value_table_ptr[0]->next;\n\n      continue;\n    }\n\n/* if we reach this line, all value_table_ptr[i] are non-NULL and are set\n * to the same subid. instance_list_ptr is either NULL or points to the\n * same subid, too. */\n#if COLLECT_DEBUG\n    for (i = 1; i < data->values_len; i++) {\n      assert(value_table_ptr[i] != NULL);\n      assert(csnmp_oid_compare(&value_table_ptr[i - 1]->suffix,\n                               &value_table_ptr[i]->suffix) == 0);\n    }\n    assert((instance_list_ptr == NULL) ||\n           (csnmp_oid_compare(&instance_list_ptr->suffix,\n                              &value_table_ptr[0]->suffix) == 0));\n#endif\n\n    sstrncpy(vl.type, data->type, sizeof(vl.type));\n\n    {\n      char temp[DATA_MAX_NAME_LEN];\n\n      if (instance_list_ptr == NULL)\n        csnmp_oid_to_string(temp, sizeof(temp), &current_suffix);\n      else\n        sstrncpy(temp, instance_list_ptr->instance, sizeof(temp));\n\n      if (data->instance_prefix == NULL)\n        sstrncpy(vl.type_instance, temp, sizeof(vl.type_instance));\n      else\n        ssnprintf(vl.type_instance, sizeof(vl.type_instance), \"%s%s\",\n                  data->instance_prefix, temp);\n    }\n\n    for (i = 0; i < data->values_len; i++)\n      vl.values[i] = value_table_ptr[i]->value;\n\n    /* If we get here `vl.type_instance' and all `vl.values' have been set\n     * vl.type_instance can be empty, i.e. a blank port description on a\n     * switch if you're using IF-MIB::ifDescr as Instance.\n     */\n    if (vl.type_instance[0] != '\\0')\n      plugin_dispatch_values(&vl);\n\n    if (instance_list != NULL)\n      instance_list_ptr = instance_list_ptr->next;\n    else\n      value_table_ptr[0] = value_table_ptr[0]->next;\n  } /* while (have_more) */\n\n  sfree(vl.values);\n  sfree(value_table_ptr);\n\n  return (0);\n} /* int csnmp_dispatch_table */\n\nstatic int csnmp_read_table(host_definition_t *host, data_definition_t *data) {\n  struct snmp_pdu *req;\n  struct snmp_pdu *res = NULL;\n  struct variable_list *vb;\n\n  const data_set_t *ds;\n\n  size_t oid_list_len = data->values_len + 1;\n  /* Holds the last OID returned by the device. We use this in the GETNEXT\n   * request to proceed. */\n  oid_t oid_list[oid_list_len];\n  /* Set to false when an OID has left its subtree so we don't re-request it\n   * again. */\n  _Bool oid_list_todo[oid_list_len];\n\n  int status;\n  size_t i;\n\n  /* `value_list_head' and `value_list_tail' implement a linked list for each\n   * value. `instance_list_head' and `instance_list_tail' implement a linked\n   * list of\n   * instance names. This is used to jump gaps in the table. */\n  csnmp_list_instances_t *instance_list_head;\n  csnmp_list_instances_t *instance_list_tail;\n  csnmp_table_values_t **value_list_head;\n  csnmp_table_values_t **value_list_tail;\n\n  DEBUG(\"snmp plugin: csnmp_read_table (host = %s, data = %s)\", host->name,\n        data->name);\n\n  if (host->sess_handle == NULL) {\n    DEBUG(\"snmp plugin: csnmp_read_table: host->sess_handle == NULL\");\n    return (-1);\n  }\n\n  ds = plugin_get_ds(data->type);\n  if (!ds) {\n    ERROR(\"snmp plugin: DataSet `%s' not defined.\", data->type);\n    return (-1);\n  }\n\n  if (ds->ds_num != data->values_len) {\n    ERROR(\"snmp plugin: DataSet `%s' requires %zu values, but config talks \"\n          \"about %zu\",\n          data->type, ds->ds_num, data->values_len);\n    return (-1);\n  }\n  assert(data->values_len > 0);\n\n  /* We need a copy of all the OIDs, because GETNEXT will destroy them. */\n  memcpy(oid_list, data->values, data->values_len * sizeof(oid_t));\n  if (data->instance.oid.oid_len > 0)\n    memcpy(oid_list + data->values_len, &data->instance.oid, sizeof(oid_t));\n  else /* no InstanceFrom option specified. */\n    oid_list_len--;\n\n  for (i = 0; i < oid_list_len; i++)\n    oid_list_todo[i] = 1;\n\n  /* We're going to construct n linked lists, one for each \"value\".\n   * value_list_head will contain pointers to the heads of these linked lists,\n   * value_list_tail will contain pointers to the tail of the lists. */\n  value_list_head = calloc(data->values_len, sizeof(*value_list_head));\n  value_list_tail = calloc(data->values_len, sizeof(*value_list_tail));\n  if ((value_list_head == NULL) || (value_list_tail == NULL)) {\n    ERROR(\"snmp plugin: csnmp_read_table: calloc failed.\");\n    sfree(value_list_head);\n    sfree(value_list_tail);\n    return (-1);\n  }\n\n  instance_list_head = NULL;\n  instance_list_tail = NULL;\n\n  status = 0;\n  while (status == 0) {\n    int oid_list_todo_num;\n\n    req = snmp_pdu_create(SNMP_MSG_GETNEXT);\n    if (req == NULL) {\n      ERROR(\"snmp plugin: snmp_pdu_create failed.\");\n      status = -1;\n      break;\n    }\n\n    oid_list_todo_num = 0;\n    for (i = 0; i < oid_list_len; i++) {\n      /* Do not rerequest already finished OIDs */\n      if (!oid_list_todo[i])\n        continue;\n      oid_list_todo_num++;\n      snmp_add_null_var(req, oid_list[i].oid, oid_list[i].oid_len);\n    }\n\n    if (oid_list_todo_num == 0) {\n      /* The request is still empty - so we are finished */\n      DEBUG(\"snmp plugin: all variables have left their subtree\");\n      snmp_free_pdu(req);\n      status = 0;\n      break;\n    }\n\n    res = NULL;\n    /* snmp_sess_synch_response always frees our req PDU */\n    status = snmp_sess_synch_response(host->sess_handle, req, &res);\n    if ((status != STAT_SUCCESS) || (res == NULL)) {\n      char *errstr = NULL;\n\n      snmp_sess_error(host->sess_handle, NULL, NULL, &errstr);\n\n      c_complain(LOG_ERR, &host->complaint,\n                 \"snmp plugin: host %s: snmp_sess_synch_response failed: %s\",\n                 host->name, (errstr == NULL) ? \"Unknown problem\" : errstr);\n\n      if (res != NULL)\n        snmp_free_pdu(res);\n      res = NULL;\n\n      sfree(errstr);\n      csnmp_host_close_session(host);\n\n      status = -1;\n      break;\n    }\n\n    status = 0;\n    assert(res != NULL);\n    c_release(LOG_INFO, &host->complaint,\n              \"snmp plugin: host %s: snmp_sess_synch_response successful.\",\n              host->name);\n\n    vb = res->variables;\n    if (vb == NULL) {\n      status = -1;\n      break;\n    }\n\n    for (vb = res->variables, i = 0; (vb != NULL);\n         vb = vb->next_variable, i++) {\n      /* Calculate value index from todo list */\n      while ((i < oid_list_len) && !oid_list_todo[i])\n        i++;\n\n      /* An instance is configured and the res variable we process is the\n       * instance value (last index) */\n      if ((data->instance.oid.oid_len > 0) && (i == data->values_len)) {\n        if ((vb->type == SNMP_ENDOFMIBVIEW) ||\n            (snmp_oid_ncompare(\n                 data->instance.oid.oid, data->instance.oid.oid_len, vb->name,\n                 vb->name_length, data->instance.oid.oid_len) != 0)) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; Instance left its subtree.\",\n                host->name, data->name);\n          oid_list_todo[i] = 0;\n          continue;\n        }\n\n        /* Allocate a new `csnmp_list_instances_t', insert the instance name and\n         * add it to the list */\n        if (csnmp_instance_list_add(&instance_list_head, &instance_list_tail,\n                                    res, host, data) != 0) {\n          ERROR(\"snmp plugin: host %s: csnmp_instance_list_add failed.\",\n                host->name);\n          status = -1;\n          break;\n        }\n      } else /* The variable we are processing is a normal value */\n      {\n        csnmp_table_values_t *vt;\n        oid_t vb_name;\n        oid_t suffix;\n        int ret;\n\n        csnmp_oid_init(&vb_name, vb->name, vb->name_length);\n\n        /* Calculate the current suffix. This is later used to check that the\n         * suffix is increasing. This also checks if we left the subtree */\n        ret = csnmp_oid_suffix(&suffix, &vb_name, data->values + i);\n        if (ret != 0) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; i = %zu; \"\n                \"Value probably left its subtree.\",\n                host->name, data->name, i);\n          oid_list_todo[i] = 0;\n          continue;\n        }\n\n        /* Make sure the OIDs returned by the agent are increasing. Otherwise\n         * our\n         * table matching algorithm will get confused. */\n        if ((value_list_tail[i] != NULL) &&\n            (csnmp_oid_compare(&suffix, &value_list_tail[i]->suffix) <= 0)) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; i = %zu; \"\n                \"Suffix is not increasing.\",\n                host->name, data->name, i);\n          oid_list_todo[i] = 0;\n          continue;\n        }\n\n        vt = calloc(1, sizeof(*vt));\n        if (vt == NULL) {\n          ERROR(\"snmp plugin: calloc failed.\");\n          status = -1;\n          break;\n        }\n\n        vt->value =\n            csnmp_value_list_to_value(vb, ds->ds[i].type, data->scale,\n                                      data->shift, host->name, data->name);\n        memcpy(&vt->suffix, &suffix, sizeof(vt->suffix));\n        vt->next = NULL;\n\n        if (value_list_tail[i] == NULL)\n          value_list_head[i] = vt;\n        else\n          value_list_tail[i]->next = vt;\n        value_list_tail[i] = vt;\n      }\n\n      /* Copy OID to oid_list[i] */\n      memcpy(oid_list[i].oid, vb->name, sizeof(oid) * vb->name_length);\n      oid_list[i].oid_len = vb->name_length;\n\n    } /* for (vb = res->variables ...) */\n\n    if (res != NULL)\n      snmp_free_pdu(res);\n    res = NULL;\n  } /* while (status == 0) */\n\n  if (res != NULL)\n    snmp_free_pdu(res);\n  res = NULL;\n\n\n  if (status == 0)\n    csnmp_dispatch_table(host, data, instance_list_head, value_list_head);\n\n  /* Free all allocated variables here */\n  while (instance_list_head != NULL) {\n    csnmp_list_instances_t *next = instance_list_head->next;\n    sfree(instance_list_head);\n    instance_list_head = next;\n  }\n\n  for (i = 0; i < data->values_len; i++) {\n    while (value_list_head[i] != NULL) {\n      csnmp_table_values_t *next = value_list_head[i]->next;\n      sfree(value_list_head[i]);\n      value_list_head[i] = next;\n    }\n  }\n\n  sfree(value_list_head);\n  sfree(value_list_tail);\n\n  return (0);\n} /* int csnmp_read_table */\n\nstatic int csnmp_read_value(host_definition_t *host, data_definition_t *data) {\n  struct snmp_pdu *req;\n  struct snmp_pdu *res = NULL;\n  struct variable_list *vb;\n\n  const data_set_t *ds;\n  value_list_t vl = VALUE_LIST_INIT;\n\n  int status;\n  size_t i;\n\n  DEBUG(\"snmp plugin: csnmp_read_value (host = %s, data = %s)\", host->name,\n        data->name);\n\n  if (host->sess_handle == NULL) {\n    DEBUG(\"snmp plugin: csnmp_read_value: host->sess_handle == NULL\");\n    return (-1);\n  }\n\n  ds = plugin_get_ds(data->type);\n  if (!ds) {\n    ERROR(\"snmp plugin: DataSet `%s' not defined.\", data->type);\n    return (-1);\n  }\n\n  if (ds->ds_num != data->values_len) {\n    ERROR(\"snmp plugin: DataSet `%s' requires %zu values, but config talks \"\n          \"about %zu\",\n          data->type, ds->ds_num, data->values_len);\n    return (-1);\n  }\n\n  vl.values_len = ds->ds_num;\n  vl.values = malloc(sizeof(*vl.values) * vl.values_len);\n  if (vl.values == NULL)\n    return (-1);\n  for (i = 0; i < vl.values_len; i++) {\n    if (ds->ds[i].type == DS_TYPE_COUNTER)\n      vl.values[i].counter = 0;\n    else\n      vl.values[i].gauge = NAN;\n  }\n\n  sstrncpy(vl.host, host->name, sizeof(vl.host));\n  sstrncpy(vl.plugin, \"snmp\", sizeof(vl.plugin));\n  sstrncpy(vl.type, data->type, sizeof(vl.type));\n  sstrncpy(vl.type_instance, data->instance.string, sizeof(vl.type_instance));\n\n  vl.interval = host->interval;\n\n  req = snmp_pdu_create(SNMP_MSG_GET);\n  if (req == NULL) {\n    ERROR(\"snmp plugin: snmp_pdu_create failed.\");\n    sfree(vl.values);\n    return (-1);\n  }\n\n  for (i = 0; i < data->values_len; i++)\n    snmp_add_null_var(req, data->values[i].oid, data->values[i].oid_len);\n\n  status = snmp_sess_synch_response(host->sess_handle, req, &res);\n\n  if ((status != STAT_SUCCESS) || (res == NULL)) {\n    char *errstr = NULL;\n\n    snmp_sess_error(host->sess_handle, NULL, NULL, &errstr);\n    ERROR(\"snmp plugin: host %s: snmp_sess_synch_response failed: %s\",\n          host->name, (errstr == NULL) ? \"Unknown problem\" : errstr);\n\n    if (res != NULL)\n      snmp_free_pdu(res);\n\n    sfree(errstr);\n    sfree(vl.values);\n    csnmp_host_close_session(host);\n\n    return (-1);\n  }\n\n  for (vb = res->variables; vb != NULL; vb = vb->next_variable) {\n#if COLLECT_DEBUG\n    char buffer[1024];\n    snprint_variable(buffer, sizeof(buffer), vb->name, vb->name_length, vb);\n    DEBUG(\"snmp plugin: Got this variable: %s\", buffer);\n#endif /* COLLECT_DEBUG */\n\n    for (i = 0; i < data->values_len; i++)\n      if (snmp_oid_compare(data->values[i].oid, data->values[i].oid_len,\n                           vb->name, vb->name_length) == 0)\n        vl.values[i] =\n            csnmp_value_list_to_value(vb, ds->ds[i].type, data->scale,\n                                      data->shift, host->name, data->name);\n  } /* for (res->variables) */\n\n  snmp_free_pdu(res);\n\n  DEBUG(\"snmp plugin: -> plugin_dispatch_values (&vl);\");\n  plugin_dispatch_values(&vl);\n  sfree(vl.values);\n\n  return (0);\n} /* int csnmp_read_value */\n\nstatic int csnmp_read_host(user_data_t *ud) {\n  host_definition_t *host;\n  int status;\n  int success;\n  int i;\n\n  host = ud->data;\n\n  if (host->interval == 0)\n    host->interval = plugin_get_interval();\n\n  if (host->sess_handle == NULL)\n    csnmp_host_open_session(host);\n\n  if (host->sess_handle == NULL)\n    return (-1);\n\n  success = 0;\n  for (i = 0; i < host->data_list_len; i++) {\n    data_definition_t *data = host->data_list[i];\n\n    if (data->is_table)\n      status = csnmp_read_table(host, data);\n    else\n      status = csnmp_read_value(host, data);\n\n    if (status == 0)\n      success++;\n  }\n\n  if (success == 0)\n    return (-1);\n\n  return (0);\n} /* int csnmp_read_host */\n\nstatic int csnmp_init(void) {\n  call_snmp_init_once();\n\n  return (0);\n} /* int csnmp_init */\n\nstatic int csnmp_shutdown(void) {\n  data_definition_t *data_this;\n  data_definition_t *data_next;\n\n  /* When we get here, the read threads have been stopped and all the\n   * `host_definition_t' will be freed. */\n  DEBUG(\"snmp plugin: Destroying all data definitions.\");\n\n  data_this = data_head;\n  data_head = NULL;\n  while (data_this != NULL) {\n    data_next = data_this->next;\n\n    sfree(data_this->name);\n    sfree(data_this->type);\n    sfree(data_this->values);\n    sfree(data_this->ignores);\n    sfree(data_this);\n\n    data_this = data_next;\n  }\n\n  return (0);\n} /* int csnmp_shutdown */\n\nvoid module_register(void) {\n  plugin_register_complex_config(\"snmp\", csnmp_config);\n  plugin_register_init(\"snmp\", csnmp_init);\n  plugin_register_shutdown(\"snmp\", csnmp_shutdown);\n} /* void module_register */\n\n/*\n * vim: shiftwidth=2 softtabstop=2 tabstop=8 fdm=marker\n */\n"], "filenames": ["src/snmp.c"], "buggy_code_start_loc": [1359], "buggy_code_end_loc": [1498], "fixing_code_start_loc": [1360], "fixing_code_end_loc": [1494], "type": "CWE-415", "message": "The csnmp_read_table function in snmp.c in the SNMP plugin in collectd before 5.6.3 is susceptible to a double free in a certain error case, which could lead to a crash (or potentially have other impact).", "other": {"cve": {"id": "CVE-2017-16820", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-14T21:29:00.433", "lastModified": "2018-09-04T10:29:00.277", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The csnmp_read_table function in snmp.c in the SNMP plugin in collectd before 5.6.3 is susceptible to a double free in a certain error case, which could lead to a crash (or potentially have other impact)."}, {"lang": "es", "value": "La funci\u00f3n csnmp_read_table en snmp.c en el plugin SNMP en collectd, en versiones anteriores a la 5.6.3, es susceptible a una doble liberaci\u00f3n (double free) en un cierto caso de error, lo que podr\u00eda conducir a un cierre inesperado (o, potencialmente, provocar otro impacto)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:collectd:collectd:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.3", "matchCriteriaId": "D0C6B755-5FC2-403F-8EB8-CFC784BBA56C"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2018:0252", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:0299", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:0560", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:1605", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:2615", "source": "cve@mitre.org"}, {"url": "https://bugs.debian.org/881757", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/collectd/collectd/commit/d16c24542b2f96a194d43a73c2e5778822b9cb47", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/collectd/collectd/issues/2291", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/collectd/collectd/releases/tag/collectd-5.6.3", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201803-10", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/collectd/collectd/commit/d16c24542b2f96a194d43a73c2e5778822b9cb47"}}