{"buggy_code": ["# Natural Language Toolkit: Corpus & Model Downloader\n#\n# Copyright (C) 2001-2019 NLTK Project\n# Author: Edward Loper <edloper@gmail.com>\n# URL: <http://nltk.org/>\n# For license information, see LICENSE.TXT\n\n\"\"\"\nThe NLTK corpus and module downloader.  This module defines several\ninterfaces which can be used to download corpora, models, and other\ndata packages that can be used with NLTK.\n\nDownloading Packages\n====================\nIf called with no arguments, ``download()`` will display an interactive\ninterface which can be used to download and install new packages.\nIf Tkinter is available, then a graphical interface will be shown,\notherwise a simple text interface will be provided.\n\nIndividual packages can be downloaded by calling the ``download()``\nfunction with a single argument, giving the package identifier for the\npackage that should be downloaded:\n\n    >>> download('treebank') # doctest: +SKIP\n    [nltk_data] Downloading package 'treebank'...\n    [nltk_data]   Unzipping corpora/treebank.zip.\n\nNLTK also provides a number of \\\"package collections\\\", consisting of\na group of related packages.  To download all packages in a\ncolleciton, simply call ``download()`` with the collection's\nidentifier:\n\n    >>> download('all-corpora') # doctest: +SKIP\n    [nltk_data] Downloading package 'abc'...\n    [nltk_data]   Unzipping corpora/abc.zip.\n    [nltk_data] Downloading package 'alpino'...\n    [nltk_data]   Unzipping corpora/alpino.zip.\n      ...\n    [nltk_data] Downloading package 'words'...\n    [nltk_data]   Unzipping corpora/words.zip.\n\nDownload Directory\n==================\nBy default, packages are installed in either a system-wide directory\n(if Python has sufficient access to write to it); or in the current\nuser's home directory.  However, the ``download_dir`` argument may be\nused to specify a different installation target, if desired.\n\nSee ``Downloader.default_download_dir()`` for more a detailed\ndescription of how the default download directory is chosen.\n\nNLTK Download Server\n====================\nBefore downloading any packages, the corpus and module downloader\ncontacts the NLTK download server, to retrieve an index file\ndescribing the available packages.  By default, this index file is\nloaded from ``https://raw.githubusercontent.com/nltk/nltk_data/gh-pages/index.xml``.\nIf necessary, it is possible to create a new ``Downloader`` object,\nspecifying a different URL for the package index file.\n\nUsage::\n\n    python nltk/downloader.py [-d DATADIR] [-q] [-f] [-k] PACKAGE_IDS\n\nor::\n\n    python -m nltk.downloader [-d DATADIR] [-q] [-f] [-k] PACKAGE_IDS\n\"\"\"\n# ----------------------------------------------------------------------\nfrom __future__ import print_function, division, unicode_literals\n\n\"\"\"\n\n  0     1  2    3\n[label][----][label][----]\n[column  ][column     ]\n\nNotes\n=====\nHandling data files..  Some questions:\n\n* Should the data files be kept zipped or unzipped?  I say zipped.\n\n* Should the data files be kept in svn at all?  Advantages: history;\n  automatic version numbers; 'svn up' could be used rather than the\n  downloader to update the corpora.  Disadvantages: they're big,\n  which makes working from svn a bit of a pain.  And we're planning\n  to potentially make them much bigger.  I don't think we want\n  people to have to download 400MB corpora just to use nltk from svn.\n\n* Compromise: keep the data files in trunk/data rather than in\n  trunk/nltk.  That way you can check them out in svn if you want\n  to; but you don't need to, and you can use the downloader instead.\n\n* Also: keep models in mind.  When we change the code, we'd\n  potentially like the models to get updated.  This could require a\n  little thought.\n\n* So.. let's assume we have a trunk/data directory, containing a bunch\n  of packages.  The packages should be kept as zip files, because we\n  really shouldn't be editing them much (well -- we may edit models\n  more, but they tend to be binary-ish files anyway, where diffs\n  aren't that helpful).  So we'll have trunk/data, with a bunch of\n  files like abc.zip and treebank.zip and propbank.zip.  For each\n  package we could also have eg treebank.xml and propbank.xml,\n  describing the contents of the package (name, copyright, license,\n  etc).  Collections would also have .xml files.  Finally, we would\n  pull all these together to form a single index.xml file.  Some\n  directory structure wouldn't hurt.  So how about::\n\n    /trunk/data/ ....................... root of data svn\n      index.xml ........................ main index file\n      src/ ............................. python scripts\n      packages/ ........................ dir for packages\n        corpora/ ....................... zip & xml files for corpora\n        grammars/ ...................... zip & xml files for grammars\n        taggers/ ....................... zip & xml files for taggers\n        tokenizers/ .................... zip & xml files for tokenizers\n        etc.\n      collections/ ..................... xml files for collections\n\n  Where the root (/trunk/data) would contain a makefile; and src/\n  would contain a script to update the info.xml file.  It could also\n  contain scripts to rebuild some of the various model files.  The\n  script that builds index.xml should probably check that each zip\n  file expands entirely into a single subdir, whose name matches the\n  package's uid.\n\nChanges I need to make:\n  - in index: change \"size\" to \"filesize\" or \"compressed-size\"\n  - in index: add \"unzipped-size\"\n  - when checking status: check both compressed & uncompressed size.\n    uncompressed size is important to make sure we detect a problem\n    if something got partially unzipped.  define new status values\n    to differentiate stale vs corrupt vs corruptly-uncompressed??\n    (we shouldn't need to re-download the file if the zip file is ok\n    but it didn't get uncompressed fully.)\n  - add other fields to the index: author, license, copyright, contact,\n    etc.\n\nthe current grammars/ package would become a single new package (eg\ntoy-grammars or book-grammars).\n\nxml file should have:\n  - authorship info\n  - license info\n  - copyright info\n  - contact info\n  - info about what type of data/annotation it contains?\n  - recommended corpus reader?\n\ncollections can contain other collections.  they can also contain\nmultiple package types (corpora & models).  Have a single 'basics'\npackage that includes everything we talk about in the book?\n\nn.b.: there will have to be a fallback to the punkt tokenizer, in case\nthey didn't download that model.\n\ndefault: unzip or not?\n\n\"\"\"\nimport time, os, zipfile, sys, textwrap, threading, itertools, shutil, functools\nimport subprocess\nfrom hashlib import md5\nfrom xml.etree import ElementTree\n\ntry:\n    TKINTER = True\n    from six.moves.tkinter import (\n        Tk,\n        Frame,\n        Label,\n        Entry,\n        Button,\n        Canvas,\n        Menu,\n        IntVar,\n        TclError,\n    )\n    from six.moves.tkinter_messagebox import showerror\n    from nltk.draw.table import Table\n    from nltk.draw.util import ShowText\nexcept ImportError:\n    TKINTER = False\n    TclError = ValueError\n\nfrom six import string_types, text_type\nfrom six.moves import input\nfrom six.moves.urllib.request import urlopen\nfrom six.moves.urllib.error import HTTPError, URLError\n\nimport nltk\nfrom nltk.compat import python_2_unicode_compatible\n\n# urllib2 = nltk.internals.import_from_stdlib('urllib2')\n\n\n######################################################################\n# Directory entry objects (from the data server's index file)\n######################################################################\n\n\n@python_2_unicode_compatible\nclass Package(object):\n    \"\"\"\n    A directory entry for a downloadable package.  These entries are\n    extracted from the XML index file that is downloaded by\n    ``Downloader``.  Each package consists of a single file; but if\n    that file is a zip file, then it can be automatically decompressed\n    when the package is installed.\n    \"\"\"\n\n    def __init__(\n        self,\n        id,\n        url,\n        name=None,\n        subdir='',\n        size=None,\n        unzipped_size=None,\n        checksum=None,\n        svn_revision=None,\n        copyright='Unknown',\n        contact='Unknown',\n        license='Unknown',\n        author='Unknown',\n        unzip=True,\n        **kw\n    ):\n        self.id = id\n        \"\"\"A unique identifier for this package.\"\"\"\n\n        self.name = name or id\n        \"\"\"A string name for this package.\"\"\"\n\n        self.subdir = subdir\n        \"\"\"The subdirectory where this package should be installed.\n           E.g., ``'corpora'`` or ``'taggers'``.\"\"\"\n\n        self.url = url\n        \"\"\"A URL that can be used to download this package's file.\"\"\"\n\n        self.size = int(size)\n        \"\"\"The filesize (in bytes) of the package file.\"\"\"\n\n        self.unzipped_size = int(unzipped_size)\n        \"\"\"The total filesize of the files contained in the package's\n           zipfile.\"\"\"\n\n        self.checksum = checksum\n        \"\"\"The MD-5 checksum of the package file.\"\"\"\n\n        self.svn_revision = svn_revision\n        \"\"\"A subversion revision number for this package.\"\"\"\n\n        self.copyright = copyright\n        \"\"\"Copyright holder for this package.\"\"\"\n\n        self.contact = contact\n        \"\"\"Name & email of the person who should be contacted with\n           questions about this package.\"\"\"\n\n        self.license = license\n        \"\"\"License information for this package.\"\"\"\n\n        self.author = author\n        \"\"\"Author of this package.\"\"\"\n\n        ext = os.path.splitext(url.split('/')[-1])[1]\n        self.filename = os.path.join(subdir, id + ext)\n        \"\"\"The filename that should be used for this package's file.  It\n           is formed by joining ``self.subdir`` with ``self.id``, and\n           using the same extension as ``url``.\"\"\"\n\n        self.unzip = bool(int(unzip))  # '0' or '1'\n        \"\"\"A flag indicating whether this corpus should be unzipped by\n           default.\"\"\"\n\n        # Include any other attributes provided by the XML file.\n        self.__dict__.update(kw)\n\n    @staticmethod\n    def fromxml(xml):\n        if isinstance(xml, string_types):\n            xml = ElementTree.parse(xml)\n        for key in xml.attrib:\n            xml.attrib[key] = text_type(xml.attrib[key])\n        return Package(**xml.attrib)\n\n    def __lt__(self, other):\n        return self.id < other.id\n\n    def __repr__(self):\n        return '<Package %s>' % self.id\n\n\n@python_2_unicode_compatible\nclass Collection(object):\n    \"\"\"\n    A directory entry for a collection of downloadable packages.\n    These entries are extracted from the XML index file that is\n    downloaded by ``Downloader``.\n    \"\"\"\n\n    def __init__(self, id, children, name=None, **kw):\n        self.id = id\n        \"\"\"A unique identifier for this collection.\"\"\"\n\n        self.name = name or id\n        \"\"\"A string name for this collection.\"\"\"\n\n        self.children = children\n        \"\"\"A list of the ``Collections`` or ``Packages`` directly\n           contained by this collection.\"\"\"\n\n        self.packages = None\n        \"\"\"A list of ``Packages`` contained by this collection or any\n           collections it recursively contains.\"\"\"\n\n        # Include any other attributes provided by the XML file.\n        self.__dict__.update(kw)\n\n    @staticmethod\n    def fromxml(xml):\n        if isinstance(xml, string_types):\n            xml = ElementTree.parse(xml)\n        for key in xml.attrib:\n            xml.attrib[key] = text_type(xml.attrib[key])\n        children = [child.get('ref') for child in xml.findall('item')]\n        return Collection(children=children, **xml.attrib)\n\n    def __lt__(self, other):\n        return self.id < other.id\n\n    def __repr__(self):\n        return '<Collection %s>' % self.id\n\n\n######################################################################\n# Message Passing Objects\n######################################################################\n\n\nclass DownloaderMessage(object):\n    \"\"\"A status message object, used by ``incr_download`` to\n       communicate its progress.\"\"\"\n\n\nclass StartCollectionMessage(DownloaderMessage):\n    \"\"\"Data server has started working on a collection of packages.\"\"\"\n\n    def __init__(self, collection):\n        self.collection = collection\n\n\nclass FinishCollectionMessage(DownloaderMessage):\n    \"\"\"Data server has finished working on a collection of packages.\"\"\"\n\n    def __init__(self, collection):\n        self.collection = collection\n\n\nclass StartPackageMessage(DownloaderMessage):\n    \"\"\"Data server has started working on a package.\"\"\"\n\n    def __init__(self, package):\n        self.package = package\n\n\nclass FinishPackageMessage(DownloaderMessage):\n    \"\"\"Data server has finished working on a package.\"\"\"\n\n    def __init__(self, package):\n        self.package = package\n\n\nclass StartDownloadMessage(DownloaderMessage):\n    \"\"\"Data server has started downloading a package.\"\"\"\n\n    def __init__(self, package):\n        self.package = package\n\n\nclass FinishDownloadMessage(DownloaderMessage):\n    \"\"\"Data server has finished downloading a package.\"\"\"\n\n    def __init__(self, package):\n        self.package = package\n\n\nclass StartUnzipMessage(DownloaderMessage):\n    \"\"\"Data server has started unzipping a package.\"\"\"\n\n    def __init__(self, package):\n        self.package = package\n\n\nclass FinishUnzipMessage(DownloaderMessage):\n    \"\"\"Data server has finished unzipping a package.\"\"\"\n\n    def __init__(self, package):\n        self.package = package\n\n\nclass UpToDateMessage(DownloaderMessage):\n    \"\"\"The package download file is already up-to-date\"\"\"\n\n    def __init__(self, package):\n        self.package = package\n\n\nclass StaleMessage(DownloaderMessage):\n    \"\"\"The package download file is out-of-date or corrupt\"\"\"\n\n    def __init__(self, package):\n        self.package = package\n\n\nclass ErrorMessage(DownloaderMessage):\n    \"\"\"Data server encountered an error\"\"\"\n\n    def __init__(self, package, message):\n        self.package = package\n        if isinstance(message, Exception):\n            self.message = str(message)\n        else:\n            self.message = message\n\n\nclass ProgressMessage(DownloaderMessage):\n    \"\"\"Indicates how much progress the data server has made\"\"\"\n\n    def __init__(self, progress):\n        self.progress = progress\n\n\nclass SelectDownloadDirMessage(DownloaderMessage):\n    \"\"\"Indicates what download directory the data server is using\"\"\"\n\n    def __init__(self, download_dir):\n        self.download_dir = download_dir\n\n\n######################################################################\n# NLTK Data Server\n######################################################################\n\n\nclass Downloader(object):\n    \"\"\"\n    A class used to access the NLTK data server, which can be used to\n    download corpora and other data packages.\n    \"\"\"\n\n    # /////////////////////////////////////////////////////////////////\n    # Configuration\n    # /////////////////////////////////////////////////////////////////\n\n    INDEX_TIMEOUT = 60 * 60  # 1 hour\n    \"\"\"The amount of time after which the cached copy of the data\n       server index will be considered 'stale,' and will be\n       re-downloaded.\"\"\"\n\n    DEFAULT_URL = 'https://raw.githubusercontent.com/nltk/nltk_data/gh-pages/index.xml'\n    \"\"\"The default URL for the NLTK data server's index.  An\n       alternative URL can be specified when creating a new\n       ``Downloader`` object.\"\"\"\n\n    # /////////////////////////////////////////////////////////////////\n    # Status Constants\n    # /////////////////////////////////////////////////////////////////\n\n    INSTALLED = 'installed'\n    \"\"\"A status string indicating that a package or collection is\n       installed and up-to-date.\"\"\"\n    NOT_INSTALLED = 'not installed'\n    \"\"\"A status string indicating that a package or collection is\n       not installed.\"\"\"\n    STALE = 'out of date'\n    \"\"\"A status string indicating that a package or collection is\n       corrupt or out-of-date.\"\"\"\n    PARTIAL = 'partial'\n    \"\"\"A status string indicating that a collection is partially\n       installed (i.e., only some of its packages are installed.)\"\"\"\n\n    # /////////////////////////////////////////////////////////////////\n    # Cosntructor\n    # /////////////////////////////////////////////////////////////////\n\n    def __init__(self, server_index_url=None, download_dir=None):\n        self._url = server_index_url or self.DEFAULT_URL\n        \"\"\"The URL for the data server's index file.\"\"\"\n\n        self._collections = {}\n        \"\"\"Dictionary from collection identifier to ``Collection``\"\"\"\n\n        self._packages = {}\n        \"\"\"Dictionary from package identifier to ``Package``\"\"\"\n\n        self._download_dir = download_dir\n        \"\"\"The default directory to which packages will be downloaded.\"\"\"\n\n        self._index = None\n        \"\"\"The XML index file downloaded from the data server\"\"\"\n\n        self._index_timestamp = None\n        \"\"\"Time at which ``self._index`` was downloaded.  If it is more\n           than ``INDEX_TIMEOUT`` seconds old, it will be re-downloaded.\"\"\"\n\n        self._status_cache = {}\n        \"\"\"Dictionary from package/collection identifier to status\n           string (``INSTALLED``, ``NOT_INSTALLED``, ``STALE``, or\n           ``PARTIAL``).  Cache is used for packages only, not\n           collections.\"\"\"\n\n        self._errors = None\n        \"\"\"Flag for telling if all packages got successfully downloaded or not.\"\"\"\n\n        # decide where we're going to save things to.\n        if self._download_dir is None:\n            self._download_dir = self.default_download_dir()\n\n    # /////////////////////////////////////////////////////////////////\n    # Information\n    # /////////////////////////////////////////////////////////////////\n\n    def list(\n        self,\n        download_dir=None,\n        show_packages=True,\n        show_collections=True,\n        header=True,\n        more_prompt=False,\n        skip_installed=False,\n    ):\n        lines = 0  # for more_prompt\n        if download_dir is None:\n            download_dir = self._download_dir\n            print('Using default data directory (%s)' % download_dir)\n        if header:\n            print('=' * (26 + len(self._url)))\n            print(' Data server index for <%s>' % self._url)\n            print('=' * (26 + len(self._url)))\n            lines += 3  # for more_prompt\n        stale = partial = False\n\n        categories = []\n        if show_packages:\n            categories.append('packages')\n        if show_collections:\n            categories.append('collections')\n        for category in categories:\n            print('%s:' % category.capitalize())\n            lines += 1  # for more_prompt\n            for info in sorted(getattr(self, category)(), key=str):\n                status = self.status(info, download_dir)\n                if status == self.INSTALLED and skip_installed:\n                    continue\n                if status == self.STALE:\n                    stale = True\n                if status == self.PARTIAL:\n                    partial = True\n                prefix = {\n                    self.INSTALLED: '*',\n                    self.STALE: '-',\n                    self.PARTIAL: 'P',\n                    self.NOT_INSTALLED: ' ',\n                }[status]\n                name = textwrap.fill(\n                    '-' * 27 + (info.name or info.id), 75, subsequent_indent=27 * ' '\n                )[27:]\n                print('  [%s] %s %s' % (prefix, info.id.ljust(20, '.'), name))\n                lines += len(name.split('\\n'))  # for more_prompt\n                if more_prompt and lines > 20:\n                    user_input = input(\"Hit Enter to continue: \")\n                    if user_input.lower() in ('x', 'q'):\n                        return\n                    lines = 0\n            print()\n        msg = '([*] marks installed packages'\n        if stale:\n            msg += '; [-] marks out-of-date or corrupt packages'\n        if partial:\n            msg += '; [P] marks partially installed collections'\n        print(textwrap.fill(msg + ')', subsequent_indent=' ', width=76))\n\n    def packages(self):\n        self._update_index()\n        return self._packages.values()\n\n    def corpora(self):\n        self._update_index()\n        return [pkg for (id, pkg) in self._packages.items() if pkg.subdir == 'corpora']\n\n    def models(self):\n        self._update_index()\n        return [pkg for (id, pkg) in self._packages.items() if pkg.subdir != 'corpora']\n\n    def collections(self):\n        self._update_index()\n        return self._collections.values()\n\n    # /////////////////////////////////////////////////////////////////\n    # Downloading\n    # /////////////////////////////////////////////////////////////////\n\n    def _info_or_id(self, info_or_id):\n        if isinstance(info_or_id, string_types):\n            return self.info(info_or_id)\n        else:\n            return info_or_id\n\n    # [xx] When during downloading is it 'safe' to abort?  Only unsafe\n    # time is *during* an unzip -- we don't want to leave a\n    # partially-unzipped corpus in place because we wouldn't notice\n    # it.  But if we had the exact total size of the unzipped corpus,\n    # then that would be fine.  Then we could abort anytime we want!\n    # So this is really what we should do.  That way the threaded\n    # downloader in the gui can just kill the download thread anytime\n    # it wants.\n\n    def incr_download(self, info_or_id, download_dir=None, force=False):\n        # If they didn't specify a download_dir, then use the default one.\n        if download_dir is None:\n            download_dir = self._download_dir\n            yield SelectDownloadDirMessage(download_dir)\n\n        # If they gave us a list of ids, then download each one.\n        if isinstance(info_or_id, (list, tuple)):\n            for msg in self._download_list(info_or_id, download_dir, force):\n                yield msg\n            return\n\n        # Look up the requested collection or package.\n        try:\n            info = self._info_or_id(info_or_id)\n        except (IOError, ValueError) as e:\n            yield ErrorMessage(None, 'Error loading %s: %s' % (info_or_id, e))\n            return\n\n        # Handle collections.\n        if isinstance(info, Collection):\n            yield StartCollectionMessage(info)\n            for msg in self.incr_download(info.children, download_dir, force):\n                yield msg\n            yield FinishCollectionMessage(info)\n\n        # Handle Packages (delegate to a helper function).\n        else:\n            for msg in self._download_package(info, download_dir, force):\n                yield msg\n\n    def _num_packages(self, item):\n        if isinstance(item, Package):\n            return 1\n        else:\n            return len(item.packages)\n\n    def _download_list(self, items, download_dir, force):\n        # Look up the requested items.\n        for i in range(len(items)):\n            try:\n                items[i] = self._info_or_id(items[i])\n            except (IOError, ValueError) as e:\n                yield ErrorMessage(items[i], e)\n                return\n\n        # Download each item, re-scaling their progress.\n        num_packages = sum(self._num_packages(item) for item in items)\n        progress = 0\n        for i, item in enumerate(items):\n            if isinstance(item, Package):\n                delta = 1.0 / num_packages\n            else:\n                delta = len(item.packages) / num_packages\n            for msg in self.incr_download(item, download_dir, force):\n                if isinstance(msg, ProgressMessage):\n                    yield ProgressMessage(progress + msg.progress * delta)\n                else:\n                    yield msg\n\n            progress += 100 * delta\n\n    def _download_package(self, info, download_dir, force):\n        yield StartPackageMessage(info)\n        yield ProgressMessage(0)\n\n        # Do we already have the current version?\n        status = self.status(info, download_dir)\n        if not force and status == self.INSTALLED:\n            yield UpToDateMessage(info)\n            yield ProgressMessage(100)\n            yield FinishPackageMessage(info)\n            return\n\n        # Remove the package from our status cache\n        self._status_cache.pop(info.id, None)\n\n        # Check for (and remove) any old/stale version.\n        filepath = os.path.join(download_dir, info.filename)\n        if os.path.exists(filepath):\n            if status == self.STALE:\n                yield StaleMessage(info)\n            os.remove(filepath)\n\n        # Ensure the download_dir exists\n        if not os.path.exists(download_dir):\n            os.mkdir(download_dir)\n        if not os.path.exists(os.path.join(download_dir, info.subdir)):\n            os.mkdir(os.path.join(download_dir, info.subdir))\n\n        # Download the file.  This will raise an IOError if the url\n        # is not found.\n        yield StartDownloadMessage(info)\n        yield ProgressMessage(5)\n        try:\n            infile = urlopen(info.url)\n            with open(filepath, 'wb') as outfile:\n                # print info.size\n                num_blocks = max(1, info.size / (1024 * 16))\n                for block in itertools.count():\n                    s = infile.read(1024 * 16)  # 16k blocks.\n                    outfile.write(s)\n                    if not s:\n                        break\n                    if block % 2 == 0:  # how often?\n                        yield ProgressMessage(min(80, 5 + 75 * (block / num_blocks)))\n            infile.close()\n        except IOError as e:\n            yield ErrorMessage(\n                info,\n                'Error downloading %r from <%s>:' '\\n  %s' % (info.id, info.url, e),\n            )\n            return\n        yield FinishDownloadMessage(info)\n        yield ProgressMessage(80)\n\n        # If it's a zipfile, uncompress it.\n        if info.filename.endswith('.zip'):\n            zipdir = os.path.join(download_dir, info.subdir)\n            # Unzip if we're unzipping by default; *or* if it's already\n            # been unzipped (presumably a previous version).\n            if info.unzip or os.path.exists(os.path.join(zipdir, info.id)):\n                yield StartUnzipMessage(info)\n                for msg in _unzip_iter(filepath, zipdir, verbose=False):\n                    # Somewhat of a hack, but we need a proper package reference\n                    msg.package = info\n                    yield msg\n                yield FinishUnzipMessage(info)\n\n        yield FinishPackageMessage(info)\n\n    def download(\n        self,\n        info_or_id=None,\n        download_dir=None,\n        quiet=False,\n        force=False,\n        prefix='[nltk_data] ',\n        halt_on_error=True,\n        raise_on_error=False,\n        print_error_to=sys.stderr,\n    ):\n\n        print_to = functools.partial(print, file=print_error_to)\n        # If no info or id is given, then use the interactive shell.\n        if info_or_id is None:\n            # [xx] hmm -- changing self._download_dir here seems like\n            # the wrong thing to do.  Maybe the _interactive_download\n            # function should make a new copy of self to use?\n            if download_dir is not None:\n                self._download_dir = download_dir\n            self._interactive_download()\n            return True\n\n        else:\n            # Define a helper function for displaying output:\n            def show(s, prefix2=''):\n                print_to(\n                    textwrap.fill(\n                        s,\n                        initial_indent=prefix + prefix2,\n                        subsequent_indent=prefix + prefix2 + ' ' * 4,\n                    )\n                )\n\n            for msg in self.incr_download(info_or_id, download_dir, force):\n                # Error messages\n                if isinstance(msg, ErrorMessage):\n                    show(msg.message)\n                    if raise_on_error:\n                        raise ValueError(msg.message)\n                    if halt_on_error:\n                        return False\n                    self._errors = True\n                    if not quiet:\n                        print_to(\"Error installing package. Retry? [n/y/e]\")\n                        choice = input().strip()\n                        if choice in ['y', 'Y']:\n                            if not self.download(\n                                msg.package.id,\n                                download_dir,\n                                quiet,\n                                force,\n                                prefix,\n                                halt_on_error,\n                                raise_on_error,\n                            ):\n                                return False\n                        elif choice in ['e', 'E']:\n                            return False\n\n                # All other messages\n                if not quiet:\n                    # Collection downloading messages:\n                    if isinstance(msg, StartCollectionMessage):\n                        show('Downloading collection %r' % msg.collection.id)\n                        prefix += '   | '\n                        print_to(prefix)\n                    elif isinstance(msg, FinishCollectionMessage):\n                        print_to(prefix)\n                        prefix = prefix[:-4]\n                        if self._errors:\n                            show(\n                                'Downloaded collection %r with errors'\n                                % msg.collection.id\n                            )\n                        else:\n                            show('Done downloading collection %s' % msg.collection.id)\n\n                    # Package downloading messages:\n                    elif isinstance(msg, StartPackageMessage):\n                        show(\n                            'Downloading package %s to %s...'\n                            % (msg.package.id, download_dir)\n                        )\n                    elif isinstance(msg, UpToDateMessage):\n                        show('Package %s is already up-to-date!' % msg.package.id, '  ')\n                    # elif isinstance(msg, StaleMessage):\n                    #    show('Package %s is out-of-date or corrupt' %\n                    #         msg.package.id, '  ')\n                    elif isinstance(msg, StartUnzipMessage):\n                        show('Unzipping %s.' % msg.package.filename, '  ')\n\n                    # Data directory message:\n                    elif isinstance(msg, SelectDownloadDirMessage):\n                        download_dir = msg.download_dir\n        return True\n\n    def is_stale(self, info_or_id, download_dir=None):\n        return self.status(info_or_id, download_dir) == self.STALE\n\n    def is_installed(self, info_or_id, download_dir=None):\n        return self.status(info_or_id, download_dir) == self.INSTALLED\n\n    def clear_status_cache(self, id=None):\n        if id is None:\n            self._status_cache.clear()\n        else:\n            self._status_cache.pop(id, None)\n\n    def status(self, info_or_id, download_dir=None):\n        \"\"\"\n        Return a constant describing the status of the given package\n        or collection.  Status can be one of ``INSTALLED``,\n        ``NOT_INSTALLED``, ``STALE``, or ``PARTIAL``.\n        \"\"\"\n        if download_dir is None:\n            download_dir = self._download_dir\n        info = self._info_or_id(info_or_id)\n\n        # Handle collections:\n        if isinstance(info, Collection):\n            pkg_status = [self.status(pkg.id) for pkg in info.packages]\n            if self.STALE in pkg_status:\n                return self.STALE\n            elif self.PARTIAL in pkg_status:\n                return self.PARTIAL\n            elif self.INSTALLED in pkg_status and self.NOT_INSTALLED in pkg_status:\n                return self.PARTIAL\n            elif self.NOT_INSTALLED in pkg_status:\n                return self.NOT_INSTALLED\n            else:\n                return self.INSTALLED\n\n        # Handle packages:\n        else:\n            filepath = os.path.join(download_dir, info.filename)\n            if download_dir != self._download_dir:\n                return self._pkg_status(info, filepath)\n            else:\n                if info.id not in self._status_cache:\n                    self._status_cache[info.id] = self._pkg_status(info, filepath)\n                return self._status_cache[info.id]\n\n    def _pkg_status(self, info, filepath):\n        if not os.path.exists(filepath):\n            return self.NOT_INSTALLED\n\n        # Check if the file has the correct size.\n        try:\n            filestat = os.stat(filepath)\n        except OSError:\n            return self.NOT_INSTALLED\n        if filestat.st_size != int(info.size):\n            return self.STALE\n\n        # Check if the file's checksum matches\n        if md5_hexdigest(filepath) != info.checksum:\n            return self.STALE\n\n        # If it's a zipfile, and it's been at least partially\n        # unzipped, then check if it's been fully unzipped.\n        if filepath.endswith('.zip'):\n            unzipdir = filepath[:-4]\n            if not os.path.exists(unzipdir):\n                return self.INSTALLED  # but not unzipped -- ok!\n            if not os.path.isdir(unzipdir):\n                return self.STALE\n\n            unzipped_size = sum(\n                os.stat(os.path.join(d, f)).st_size\n                for d, _, files in os.walk(unzipdir)\n                for f in files\n            )\n            if unzipped_size != info.unzipped_size:\n                return self.STALE\n\n        # Otherwise, everything looks good.\n        return self.INSTALLED\n\n    def update(self, quiet=False, prefix='[nltk_data] '):\n        \"\"\"\n        Re-download any packages whose status is STALE.\n        \"\"\"\n        self.clear_status_cache()\n        for pkg in self.packages():\n            if self.status(pkg) == self.STALE:\n                self.download(pkg, quiet=quiet, prefix=prefix)\n\n    # /////////////////////////////////////////////////////////////////\n    # Index\n    # /////////////////////////////////////////////////////////////////\n\n    def _update_index(self, url=None):\n        \"\"\"A helper function that ensures that self._index is\n        up-to-date.  If the index is older than self.INDEX_TIMEOUT,\n        then download it again.\"\"\"\n        # Check if the index is aleady up-to-date.  If so, do nothing.\n        if not (\n            self._index is None\n            or url is not None\n            or time.time() - self._index_timestamp > self.INDEX_TIMEOUT\n        ):\n            return\n\n        # If a URL was specified, then update our URL.\n        self._url = url or self._url\n\n        # Download the index file.\n        self._index = nltk.internals.ElementWrapper(\n            ElementTree.parse(urlopen(self._url)).getroot()\n        )\n        self._index_timestamp = time.time()\n\n        # Build a dictionary of packages.\n        packages = [Package.fromxml(p) for p in self._index.findall('packages/package')]\n        self._packages = dict((p.id, p) for p in packages)\n\n        # Build a dictionary of collections.\n        collections = [\n            Collection.fromxml(c) for c in self._index.findall('collections/collection')\n        ]\n        self._collections = dict((c.id, c) for c in collections)\n\n        # Replace identifiers with actual children in collection.children.\n        for collection in self._collections.values():\n            for i, child_id in enumerate(collection.children):\n                if child_id in self._packages:\n                    collection.children[i] = self._packages[child_id]\n                elif child_id in self._collections:\n                    collection.children[i] = self._collections[child_id]\n                else:\n                    print(\n                        'removing collection member with no package: {}'.format(\n                            child_id\n                        )\n                    )\n                    del collection.children[i]\n\n        # Fill in collection.packages for each collection.\n        for collection in self._collections.values():\n            packages = {}\n            queue = [collection]\n            for child in queue:\n                if isinstance(child, Collection):\n                    queue.extend(child.children)\n                elif isinstance(child, Package):\n                    packages[child.id] = child\n                else:\n                    pass\n            collection.packages = packages.values()\n\n        # Flush the status cache\n        self._status_cache.clear()\n\n    def index(self):\n        \"\"\"\n        Return the XML index describing the packages available from\n        the data server.  If necessary, this index will be downloaded\n        from the data server.\n        \"\"\"\n        self._update_index()\n        return self._index\n\n    def info(self, id):\n        \"\"\"Return the ``Package`` or ``Collection`` record for the\n           given item.\"\"\"\n        self._update_index()\n        if id in self._packages:\n            return self._packages[id]\n        if id in self._collections:\n            return self._collections[id]\n        raise ValueError('Package %r not found in index' % id)\n\n    def xmlinfo(self, id):\n        \"\"\"Return the XML info record for the given item\"\"\"\n        self._update_index()\n        for package in self._index.findall('packages/package'):\n            if package.get('id') == id:\n                return package\n        for collection in self._index.findall('collections/collection'):\n            if collection.get('id') == id:\n                return collection\n        raise ValueError('Package %r not found in index' % id)\n\n    # /////////////////////////////////////////////////////////////////\n    # URL & Data Directory\n    # /////////////////////////////////////////////////////////////////\n\n    def _get_url(self):\n        \"\"\"The URL for the data server's index file.\"\"\"\n        return self._url\n\n    def _set_url(self, url):\n        \"\"\"\n        Set a new URL for the data server. If we're unable to contact\n        the given url, then the original url is kept.\n        \"\"\"\n        original_url = self._url\n        try:\n            self._update_index(url)\n        except:\n            self._url = original_url\n            raise\n\n    url = property(_get_url, _set_url)\n\n    def default_download_dir(self):\n        \"\"\"\n        Return the directory to which packages will be downloaded by\n        default.  This value can be overridden using the constructor,\n        or on a case-by-case basis using the ``download_dir`` argument when\n        calling ``download()``.\n\n        On Windows, the default download directory is\n        ``PYTHONHOME/lib/nltk``, where *PYTHONHOME* is the\n        directory containing Python, e.g. ``C:\\\\Python25``.\n\n        On all other platforms, the default directory is the first of\n        the following which exists or which can be created with write\n        permission: ``/usr/share/nltk_data``, ``/usr/local/share/nltk_data``,\n        ``/usr/lib/nltk_data``, ``/usr/local/lib/nltk_data``, ``~/nltk_data``.\n        \"\"\"\n        # Check if we are on GAE where we cannot write into filesystem.\n        if 'APPENGINE_RUNTIME' in os.environ:\n            return\n\n        # Check if we have sufficient permissions to install in a\n        # variety of system-wide locations.\n        for nltkdir in nltk.data.path:\n            if os.path.exists(nltkdir) and nltk.internals.is_writable(nltkdir):\n                return nltkdir\n\n        # On Windows, use %APPDATA%\n        if sys.platform == 'win32' and 'APPDATA' in os.environ:\n            homedir = os.environ['APPDATA']\n\n        # Otherwise, install in the user's home directory.\n        else:\n            homedir = os.path.expanduser('~/')\n            if homedir == '~/':\n                raise ValueError(\"Could not find a default download directory\")\n\n        # append \"nltk_data\" to the home directory\n        return os.path.join(homedir, 'nltk_data')\n\n    def _get_download_dir(self):\n        \"\"\"\n        The default directory to which packages will be downloaded.\n        This defaults to the value returned by ``default_download_dir()``.\n        To override this default on a case-by-case basis, use the\n        ``download_dir`` argument when calling ``download()``.\n        \"\"\"\n        return self._download_dir\n\n    def _set_download_dir(self, download_dir):\n        self._download_dir = download_dir\n        # Clear the status cache.\n        self._status_cache.clear()\n\n    download_dir = property(_get_download_dir, _set_download_dir)\n\n    # /////////////////////////////////////////////////////////////////\n    # Interactive Shell\n    # /////////////////////////////////////////////////////////////////\n\n    def _interactive_download(self):\n        # Try the GUI first; if that doesn't work, try the simple\n        # interactive shell.\n        if TKINTER:\n            try:\n                DownloaderGUI(self).mainloop()\n            except TclError:\n                DownloaderShell(self).run()\n        else:\n            DownloaderShell(self).run()\n\n\nclass DownloaderShell(object):\n    def __init__(self, dataserver):\n        self._ds = dataserver\n\n    def _simple_interactive_menu(self, *options):\n        print('-' * 75)\n        spc = (68 - sum(len(o) for o in options)) // (len(options) - 1) * ' '\n        print('    ' + spc.join(options))\n        # w = 76/len(options)\n        # fmt = '  ' + ('%-'+str(w)+'s')*(len(options)-1) + '%s'\n        # print fmt % options\n        print('-' * 75)\n\n    def run(self):\n        print('NLTK Downloader')\n        while True:\n            self._simple_interactive_menu(\n                'd) Download',\n                'l) List',\n                ' u) Update',\n                'c) Config',\n                'h) Help',\n                'q) Quit',\n            )\n            user_input = input('Downloader> ').strip()\n            if not user_input:\n                print()\n                continue\n            command = user_input.lower().split()[0]\n            args = user_input.split()[1:]\n            try:\n                if command == 'l':\n                    print()\n                    self._ds.list(self._ds.download_dir, header=False, more_prompt=True)\n                elif command == 'h':\n                    self._simple_interactive_help()\n                elif command == 'c':\n                    self._simple_interactive_config()\n                elif command in ('q', 'x'):\n                    return\n                elif command == 'd':\n                    self._simple_interactive_download(args)\n                elif command == 'u':\n                    self._simple_interactive_update()\n                else:\n                    print('Command %r unrecognized' % user_input)\n            except HTTPError as e:\n                print('Error reading from server: %s' % e)\n            except URLError as e:\n                print('Error connecting to server: %s' % e.reason)\n            # try checking if user_input is a package name, &\n            # downloading it?\n            print()\n\n    def _simple_interactive_download(self, args):\n        if args:\n            for arg in args:\n                try:\n                    self._ds.download(arg, prefix='    ')\n                except (IOError, ValueError) as e:\n                    print(e)\n        else:\n            while True:\n                print()\n                print('Download which package (l=list; x=cancel)?')\n                user_input = input('  Identifier> ')\n                if user_input.lower() == 'l':\n                    self._ds.list(\n                        self._ds.download_dir,\n                        header=False,\n                        more_prompt=True,\n                        skip_installed=True,\n                    )\n                    continue\n                elif user_input.lower() in ('x', 'q', ''):\n                    return\n                elif user_input:\n                    for id in user_input.split():\n                        try:\n                            self._ds.download(id, prefix='    ')\n                        except (IOError, ValueError) as e:\n                            print(e)\n                    break\n\n    def _simple_interactive_update(self):\n        while True:\n            stale_packages = []\n            stale = partial = False\n            for info in sorted(getattr(self._ds, 'packages')(), key=str):\n                if self._ds.status(info) == self._ds.STALE:\n                    stale_packages.append((info.id, info.name))\n\n            print()\n            if stale_packages:\n                print('Will update following packages (o=ok; x=cancel)')\n                for pid, pname in stale_packages:\n                    name = textwrap.fill(\n                        '-' * 27 + (pname), 75, subsequent_indent=27 * ' '\n                    )[27:]\n                    print('  [ ] %s %s' % (pid.ljust(20, '.'), name))\n                print()\n\n                user_input = input('  Identifier> ')\n                if user_input.lower() == 'o':\n                    for pid, pname in stale_packages:\n                        try:\n                            self._ds.download(pid, prefix='    ')\n                        except (IOError, ValueError) as e:\n                            print(e)\n                    break\n                elif user_input.lower() in ('x', 'q', ''):\n                    return\n            else:\n                print('Nothing to update.')\n                return\n\n    def _simple_interactive_help(self):\n        print()\n        print('Commands:')\n        print(\n            '  d) Download a package or collection     u) Update out of date packages'\n        )\n        print('  l) List packages & collections          h) Help')\n        print('  c) View & Modify Configuration          q) Quit')\n\n    def _show_config(self):\n        print()\n        print('Data Server:')\n        print('  - URL: <%s>' % self._ds.url)\n        print(('  - %d Package Collections Available' % len(self._ds.collections())))\n        print(('  - %d Individual Packages Available' % len(self._ds.packages())))\n        print()\n        print('Local Machine:')\n        print('  - Data directory: %s' % self._ds.download_dir)\n\n    def _simple_interactive_config(self):\n        self._show_config()\n        while True:\n            print()\n            self._simple_interactive_menu(\n                's) Show Config', 'u) Set Server URL', 'd) Set Data Dir', 'm) Main Menu'\n            )\n            user_input = input('Config> ').strip().lower()\n            if user_input == 's':\n                self._show_config()\n            elif user_input == 'd':\n                new_dl_dir = input('  New Directory> ').strip()\n                if new_dl_dir in ('', 'x', 'q', 'X', 'Q'):\n                    print('  Cancelled!')\n                elif os.path.isdir(new_dl_dir):\n                    self._ds.download_dir = new_dl_dir\n                else:\n                    print(('Directory %r not found!  Create it first.' % new_dl_dir))\n            elif user_input == 'u':\n                new_url = input('  New URL> ').strip()\n                if new_url in ('', 'x', 'q', 'X', 'Q'):\n                    print('  Cancelled!')\n                else:\n                    if not new_url.startswith(('http://', 'https://')):\n                        new_url = 'http://' + new_url\n                    try:\n                        self._ds.url = new_url\n                    except Exception as e:\n                        print('Error reading <%r>:\\n  %s' % (new_url, e))\n            elif user_input == 'm':\n                break\n\n\nclass DownloaderGUI(object):\n    \"\"\"\n    Graphical interface for downloading packages from the NLTK data\n    server.\n    \"\"\"\n\n    # /////////////////////////////////////////////////////////////////\n    # Column Configuration\n    # /////////////////////////////////////////////////////////////////\n\n    COLUMNS = [\n        '',\n        'Identifier',\n        'Name',\n        'Size',\n        'Status',\n        'Unzipped Size',\n        'Copyright',\n        'Contact',\n        'License',\n        'Author',\n        'Subdir',\n        'Checksum',\n    ]\n    \"\"\"A list of the names of columns.  This controls the order in\n       which the columns will appear.  If this is edited, then\n       ``_package_to_columns()`` may need to be edited to match.\"\"\"\n\n    COLUMN_WEIGHTS = {'': 0, 'Name': 5, 'Size': 0, 'Status': 0}\n    \"\"\"A dictionary specifying how columns should be resized when the\n       table is resized.  Columns with weight 0 will not be resized at\n       all; and columns with high weight will be resized more.\n       Default weight (for columns not explicitly listed) is 1.\"\"\"\n\n    COLUMN_WIDTHS = {\n        '': 1,\n        'Identifier': 20,\n        'Name': 45,\n        'Size': 10,\n        'Unzipped Size': 10,\n        'Status': 12,\n    }\n    \"\"\"A dictionary specifying how wide each column should be, in\n       characters.  The default width (for columns not explicitly\n       listed) is specified by ``DEFAULT_COLUMN_WIDTH``.\"\"\"\n\n    DEFAULT_COLUMN_WIDTH = 30\n    \"\"\"The default width for columns that are not explicitly listed\n       in ``COLUMN_WIDTHS``.\"\"\"\n\n    INITIAL_COLUMNS = ['', 'Identifier', 'Name', 'Size', 'Status']\n    \"\"\"The set of columns that should be displayed by default.\"\"\"\n\n    # Perform a few import-time sanity checks to make sure that the\n    # column configuration variables are defined consistently:\n    for c in COLUMN_WEIGHTS:\n        assert c in COLUMNS\n    for c in COLUMN_WIDTHS:\n        assert c in COLUMNS\n    for c in INITIAL_COLUMNS:\n        assert c in COLUMNS\n\n    # /////////////////////////////////////////////////////////////////\n    # Color Configuration\n    # /////////////////////////////////////////////////////////////////\n\n    _BACKDROP_COLOR = ('#000', '#ccc')\n\n    _ROW_COLOR = {\n        Downloader.INSTALLED: ('#afa', '#080'),\n        Downloader.PARTIAL: ('#ffa', '#880'),\n        Downloader.STALE: ('#faa', '#800'),\n        Downloader.NOT_INSTALLED: ('#fff', '#888'),\n    }\n\n    _MARK_COLOR = ('#000', '#ccc')\n\n    # _FRONT_TAB_COLOR = ('#ccf', '#008')\n    # _BACK_TAB_COLOR = ('#88a', '#448')\n    _FRONT_TAB_COLOR = ('#fff', '#45c')\n    _BACK_TAB_COLOR = ('#aaa', '#67a')\n\n    _PROGRESS_COLOR = ('#f00', '#aaa')\n\n    _TAB_FONT = 'helvetica -16 bold'\n\n    # /////////////////////////////////////////////////////////////////\n    # Constructor\n    # /////////////////////////////////////////////////////////////////\n\n    def __init__(self, dataserver, use_threads=True):\n        self._ds = dataserver\n        self._use_threads = use_threads\n\n        # For the threaded downloader:\n        self._download_lock = threading.Lock()\n        self._download_msg_queue = []\n        self._download_abort_queue = []\n        self._downloading = False\n\n        # For tkinter after callbacks:\n        self._afterid = {}\n\n        # A message log.\n        self._log_messages = []\n        self._log_indent = 0\n        self._log('NLTK Downloader Started!')\n\n        # Create the main window.\n        top = self.top = Tk()\n        top.geometry('+50+50')\n        top.title('NLTK Downloader')\n        top.configure(background=self._BACKDROP_COLOR[1])\n\n        # Set up some bindings now, in case anything goes wrong.\n        top.bind('<Control-q>', self.destroy)\n        top.bind('<Control-x>', self.destroy)\n        self._destroyed = False\n\n        self._column_vars = {}\n\n        # Initialize the GUI.\n        self._init_widgets()\n        self._init_menu()\n        try:\n            self._fill_table()\n        except HTTPError as e:\n            showerror('Error reading from server', e)\n        except URLError as e:\n            showerror('Error connecting to server', e.reason)\n\n        self._show_info()\n        self._select_columns()\n        self._table.select(0)\n\n        # Make sure we get notified when we're destroyed, so we can\n        # cancel any download in progress.\n        self._table.bind('<Destroy>', self._destroy)\n\n    def _log(self, msg):\n        self._log_messages.append(\n            '%s %s%s' % (time.ctime(), ' | ' * self._log_indent, msg)\n        )\n\n    # /////////////////////////////////////////////////////////////////\n    # Internals\n    # /////////////////////////////////////////////////////////////////\n\n    def _init_widgets(self):\n        # Create the top-level frame structures\n        f1 = Frame(self.top, relief='raised', border=2, padx=8, pady=0)\n        f1.pack(sid='top', expand=True, fill='both')\n        f1.grid_rowconfigure(2, weight=1)\n        f1.grid_columnconfigure(0, weight=1)\n        Frame(f1, height=8).grid(column=0, row=0)  # spacer\n        tabframe = Frame(f1)\n        tabframe.grid(column=0, row=1, sticky='news')\n        tableframe = Frame(f1)\n        tableframe.grid(column=0, row=2, sticky='news')\n        buttonframe = Frame(f1)\n        buttonframe.grid(column=0, row=3, sticky='news')\n        Frame(f1, height=8).grid(column=0, row=4)  # spacer\n        infoframe = Frame(f1)\n        infoframe.grid(column=0, row=5, sticky='news')\n        Frame(f1, height=8).grid(column=0, row=6)  # spacer\n        progressframe = Frame(\n            self.top, padx=3, pady=3, background=self._BACKDROP_COLOR[1]\n        )\n        progressframe.pack(side='bottom', fill='x')\n        self.top['border'] = 0\n        self.top['highlightthickness'] = 0\n\n        # Create the tabs\n        self._tab_names = ['Collections', 'Corpora', 'Models', 'All Packages']\n        self._tabs = {}\n        for i, tab in enumerate(self._tab_names):\n            label = Label(tabframe, text=tab, font=self._TAB_FONT)\n            label.pack(side='left', padx=((i + 1) % 2) * 10)\n            label.bind('<Button-1>', self._select_tab)\n            self._tabs[tab.lower()] = label\n\n        # Create the table.\n        column_weights = [self.COLUMN_WEIGHTS.get(column, 1) for column in self.COLUMNS]\n        self._table = Table(\n            tableframe,\n            self.COLUMNS,\n            column_weights=column_weights,\n            highlightthickness=0,\n            listbox_height=16,\n            reprfunc=self._table_reprfunc,\n        )\n        self._table.columnconfig(0, foreground=self._MARK_COLOR[0])  # marked\n        for i, column in enumerate(self.COLUMNS):\n            width = self.COLUMN_WIDTHS.get(column, self.DEFAULT_COLUMN_WIDTH)\n            self._table.columnconfig(i, width=width)\n        self._table.pack(expand=True, fill='both')\n        self._table.focus()\n        self._table.bind_to_listboxes('<Double-Button-1>', self._download)\n        self._table.bind('<space>', self._table_mark)\n        self._table.bind('<Return>', self._download)\n        self._table.bind('<Left>', self._prev_tab)\n        self._table.bind('<Right>', self._next_tab)\n        self._table.bind('<Control-a>', self._mark_all)\n\n        # Create entry boxes for URL & download_dir\n        infoframe.grid_columnconfigure(1, weight=1)\n\n        info = [\n            ('url', 'Server Index:', self._set_url),\n            ('download_dir', 'Download Directory:', self._set_download_dir),\n        ]\n        self._info = {}\n        for (i, (key, label, callback)) in enumerate(info):\n            Label(infoframe, text=label).grid(column=0, row=i, sticky='e')\n            entry = Entry(\n                infoframe, font='courier', relief='groove', disabledforeground='black'\n            )\n            self._info[key] = (entry, callback)\n            entry.bind('<Return>', self._info_save)\n            entry.bind('<Button-1>', lambda e, key=key: self._info_edit(key))\n            entry.grid(column=1, row=i, sticky='ew')\n\n        # If the user edits url or download_dir, and then clicks outside\n        # the entry box, then save their results.\n        self.top.bind('<Button-1>', self._info_save)\n\n        # Create Download & Refresh buttons.\n        self._download_button = Button(\n            buttonframe, text='Download', command=self._download, width=8\n        )\n        self._download_button.pack(side='left')\n        self._refresh_button = Button(\n            buttonframe, text='Refresh', command=self._refresh, width=8\n        )\n        self._refresh_button.pack(side='right')\n\n        # Create Progress bar\n        self._progresslabel = Label(\n            progressframe,\n            text='',\n            foreground=self._BACKDROP_COLOR[0],\n            background=self._BACKDROP_COLOR[1],\n        )\n        self._progressbar = Canvas(\n            progressframe,\n            width=200,\n            height=16,\n            background=self._PROGRESS_COLOR[1],\n            relief='sunken',\n            border=1,\n        )\n        self._init_progressbar()\n        self._progressbar.pack(side='right')\n        self._progresslabel.pack(side='left')\n\n    def _init_menu(self):\n        menubar = Menu(self.top)\n\n        filemenu = Menu(menubar, tearoff=0)\n        filemenu.add_command(\n            label='Download', underline=0, command=self._download, accelerator='Return'\n        )\n        filemenu.add_separator()\n        filemenu.add_command(\n            label='Change Server Index',\n            underline=7,\n            command=lambda: self._info_edit('url'),\n        )\n        filemenu.add_command(\n            label='Change Download Directory',\n            underline=0,\n            command=lambda: self._info_edit('download_dir'),\n        )\n        filemenu.add_separator()\n        filemenu.add_command(label='Show Log', underline=5, command=self._show_log)\n        filemenu.add_separator()\n        filemenu.add_command(\n            label='Exit', underline=1, command=self.destroy, accelerator='Ctrl-x'\n        )\n        menubar.add_cascade(label='File', underline=0, menu=filemenu)\n\n        # Create a menu to control which columns of the table are\n        # shown.  n.b.: we never hide the first two columns (mark and\n        # identifier).\n        viewmenu = Menu(menubar, tearoff=0)\n        for column in self._table.column_names[2:]:\n            var = IntVar(self.top)\n            assert column not in self._column_vars\n            self._column_vars[column] = var\n            if column in self.INITIAL_COLUMNS:\n                var.set(1)\n            viewmenu.add_checkbutton(\n                label=column, underline=0, variable=var, command=self._select_columns\n            )\n        menubar.add_cascade(label='View', underline=0, menu=viewmenu)\n\n        # Create a sort menu\n        # [xx] this should be selectbuttons; and it should include\n        # reversed sorts as options.\n        sortmenu = Menu(menubar, tearoff=0)\n        for column in self._table.column_names[1:]:\n            sortmenu.add_command(\n                label='Sort by %s' % column,\n                command=(lambda c=column: self._table.sort_by(c, 'ascending')),\n            )\n        sortmenu.add_separator()\n        # sortmenu.add_command(label='Descending Sort:')\n        for column in self._table.column_names[1:]:\n            sortmenu.add_command(\n                label='Reverse sort by %s' % column,\n                command=(lambda c=column: self._table.sort_by(c, 'descending')),\n            )\n        menubar.add_cascade(label='Sort', underline=0, menu=sortmenu)\n\n        helpmenu = Menu(menubar, tearoff=0)\n        helpmenu.add_command(label='About', underline=0, command=self.about)\n        helpmenu.add_command(\n            label='Instructions', underline=0, command=self.help, accelerator='F1'\n        )\n        menubar.add_cascade(label='Help', underline=0, menu=helpmenu)\n        self.top.bind('<F1>', self.help)\n\n        self.top.config(menu=menubar)\n\n    def _select_columns(self):\n        for (column, var) in self._column_vars.items():\n            if var.get():\n                self._table.show_column(column)\n            else:\n                self._table.hide_column(column)\n\n    def _refresh(self):\n        self._ds.clear_status_cache()\n        try:\n            self._fill_table()\n        except HTTPError as e:\n            showerror('Error reading from server', e)\n        except URLError as e:\n            showerror('Error connecting to server', e.reason)\n        self._table.select(0)\n\n    def _info_edit(self, info_key):\n        self._info_save()  # just in case.\n        (entry, callback) = self._info[info_key]\n        entry['state'] = 'normal'\n        entry['relief'] = 'sunken'\n        entry.focus()\n\n    def _info_save(self, e=None):\n        focus = self._table\n        for entry, callback in self._info.values():\n            if entry['state'] == 'disabled':\n                continue\n            if e is not None and e.widget is entry and e.keysym != 'Return':\n                focus = entry\n            else:\n                entry['state'] = 'disabled'\n                entry['relief'] = 'groove'\n                callback(entry.get())\n        focus.focus()\n\n    def _table_reprfunc(self, row, col, val):\n        if self._table.column_names[col].endswith('Size'):\n            if isinstance(val, string_types):\n                return '  %s' % val\n            elif val < 1024 ** 2:\n                return '  %.1f KB' % (val / 1024.0 ** 1)\n            elif val < 1024 ** 3:\n                return '  %.1f MB' % (val / 1024.0 ** 2)\n            else:\n                return '  %.1f GB' % (val / 1024.0 ** 3)\n\n        if col in (0, ''):\n            return str(val)\n        else:\n            return '  %s' % val\n\n    def _set_url(self, url):\n        if url == self._ds.url:\n            return\n        try:\n            self._ds.url = url\n            self._fill_table()\n        except IOError as e:\n            showerror('Error Setting Server Index', str(e))\n        self._show_info()\n\n    def _set_download_dir(self, download_dir):\n        if self._ds.download_dir == download_dir:\n            return\n        # check if the dir exists, and if not, ask if we should create it?\n\n        # Clear our status cache, & re-check what's installed\n        self._ds.download_dir = download_dir\n        try:\n            self._fill_table()\n        except HTTPError as e:\n            showerror('Error reading from server', e)\n        except URLError as e:\n            showerror('Error connecting to server', e.reason)\n        self._show_info()\n\n    def _show_info(self):\n        print('showing info', self._ds.url)\n        for entry, cb in self._info.values():\n            entry['state'] = 'normal'\n            entry.delete(0, 'end')\n        self._info['url'][0].insert(0, self._ds.url)\n        self._info['download_dir'][0].insert(0, self._ds.download_dir)\n        for entry, cb in self._info.values():\n            entry['state'] = 'disabled'\n\n    def _prev_tab(self, *e):\n        for i, tab in enumerate(self._tab_names):\n            if tab.lower() == self._tab and i > 0:\n                self._tab = self._tab_names[i - 1].lower()\n                try:\n                    return self._fill_table()\n                except HTTPError as e:\n                    showerror('Error reading from server', e)\n                except URLError as e:\n                    showerror('Error connecting to server', e.reason)\n\n    def _next_tab(self, *e):\n        for i, tab in enumerate(self._tab_names):\n            if tab.lower() == self._tab and i < (len(self._tabs) - 1):\n                self._tab = self._tab_names[i + 1].lower()\n                try:\n                    return self._fill_table()\n                except HTTPError as e:\n                    showerror('Error reading from server', e)\n                except URLError as e:\n                    showerror('Error connecting to server', e.reason)\n\n    def _select_tab(self, event):\n        self._tab = event.widget['text'].lower()\n        try:\n            self._fill_table()\n        except HTTPError as e:\n            showerror('Error reading from server', e)\n        except URLError as e:\n            showerror('Error connecting to server', e.reason)\n\n    _tab = 'collections'\n    # _tab = 'corpora'\n    _rows = None\n\n    def _fill_table(self):\n        selected_row = self._table.selected_row()\n        self._table.clear()\n        if self._tab == 'all packages':\n            items = self._ds.packages()\n        elif self._tab == 'corpora':\n            items = self._ds.corpora()\n        elif self._tab == 'models':\n            items = self._ds.models()\n        elif self._tab == 'collections':\n            items = self._ds.collections()\n        else:\n            assert 0, 'bad tab value %r' % self._tab\n        rows = [self._package_to_columns(item) for item in items]\n        self._table.extend(rows)\n\n        # Highlight the active tab.\n        for tab, label in self._tabs.items():\n            if tab == self._tab:\n                label.configure(\n                    foreground=self._FRONT_TAB_COLOR[0],\n                    background=self._FRONT_TAB_COLOR[1],\n                )\n            else:\n                label.configure(\n                    foreground=self._BACK_TAB_COLOR[0],\n                    background=self._BACK_TAB_COLOR[1],\n                )\n\n        self._table.sort_by('Identifier', order='ascending')\n        self._color_table()\n        self._table.select(selected_row)\n\n        # This is a hack, because the scrollbar isn't updating its\n        # position right -- I'm not sure what the underlying cause is\n        # though.  (This is on OS X w/ python 2.5)  The length of\n        # delay that's necessary seems to depend on how fast the\n        # comptuer is. :-/\n        self.top.after(150, self._table._scrollbar.set, *self._table._mlb.yview())\n        self.top.after(300, self._table._scrollbar.set, *self._table._mlb.yview())\n\n    def _update_table_status(self):\n        for row_num in range(len(self._table)):\n            status = self._ds.status(self._table[row_num, 'Identifier'])\n            self._table[row_num, 'Status'] = status\n        self._color_table()\n\n    def _download(self, *e):\n        # If we're using threads, then delegate to the threaded\n        # downloader instead.\n        if self._use_threads:\n            return self._download_threaded(*e)\n\n        marked = [\n            self._table[row, 'Identifier']\n            for row in range(len(self._table))\n            if self._table[row, 0] != ''\n        ]\n        selection = self._table.selected_row()\n        if not marked and selection is not None:\n            marked = [self._table[selection, 'Identifier']]\n\n        download_iter = self._ds.incr_download(marked, self._ds.download_dir)\n        self._log_indent = 0\n        self._download_cb(download_iter, marked)\n\n    _DL_DELAY = 10\n\n    def _download_cb(self, download_iter, ids):\n        try:\n            msg = next(download_iter)\n        except StopIteration:\n            # self._fill_table(sort=False)\n            self._update_table_status()\n            afterid = self.top.after(10, self._show_progress, 0)\n            self._afterid['_download_cb'] = afterid\n            return\n\n        def show(s):\n            self._progresslabel['text'] = s\n            self._log(s)\n\n        if isinstance(msg, ProgressMessage):\n            self._show_progress(msg.progress)\n        elif isinstance(msg, ErrorMessage):\n            show(msg.message)\n            if msg.package is not None:\n                self._select(msg.package.id)\n            self._show_progress(None)\n            return  # halt progress.\n        elif isinstance(msg, StartCollectionMessage):\n            show('Downloading collection %s' % msg.collection.id)\n            self._log_indent += 1\n        elif isinstance(msg, StartPackageMessage):\n            show('Downloading package %s' % msg.package.id)\n        elif isinstance(msg, UpToDateMessage):\n            show('Package %s is up-to-date!' % msg.package.id)\n        # elif isinstance(msg, StaleMessage):\n        #    show('Package %s is out-of-date or corrupt' % msg.package.id)\n        elif isinstance(msg, FinishDownloadMessage):\n            show('Finished downloading %r.' % msg.package.id)\n        elif isinstance(msg, StartUnzipMessage):\n            show('Unzipping %s' % msg.package.filename)\n        elif isinstance(msg, FinishCollectionMessage):\n            self._log_indent -= 1\n            show('Finished downloading collection %r.' % msg.collection.id)\n            self._clear_mark(msg.collection.id)\n        elif isinstance(msg, FinishPackageMessage):\n            self._clear_mark(msg.package.id)\n        afterid = self.top.after(self._DL_DELAY, self._download_cb, download_iter, ids)\n        self._afterid['_download_cb'] = afterid\n\n    def _select(self, id):\n        for row in range(len(self._table)):\n            if self._table[row, 'Identifier'] == id:\n                self._table.select(row)\n                return\n\n    def _color_table(self):\n        # Color rows according to status.\n        for row in range(len(self._table)):\n            bg, sbg = self._ROW_COLOR[self._table[row, 'Status']]\n            fg, sfg = ('black', 'white')\n            self._table.rowconfig(\n                row,\n                foreground=fg,\n                selectforeground=sfg,\n                background=bg,\n                selectbackground=sbg,\n            )\n            # Color the marked column\n            self._table.itemconfigure(\n                row, 0, foreground=self._MARK_COLOR[0], background=self._MARK_COLOR[1]\n            )\n\n    def _clear_mark(self, id):\n        for row in range(len(self._table)):\n            if self._table[row, 'Identifier'] == id:\n                self._table[row, 0] = ''\n\n    def _mark_all(self, *e):\n        for row in range(len(self._table)):\n            self._table[row, 0] = 'X'\n\n    def _table_mark(self, *e):\n        selection = self._table.selected_row()\n        if selection >= 0:\n            if self._table[selection][0] != '':\n                self._table[selection, 0] = ''\n            else:\n                self._table[selection, 0] = 'X'\n        self._table.select(delta=1)\n\n    def _show_log(self):\n        text = '\\n'.join(self._log_messages)\n        ShowText(self.top, 'NLTK Downloader Log', text)\n\n    def _package_to_columns(self, pkg):\n        \"\"\"\n        Given a package, return a list of values describing that\n        package, one for each column in ``self.COLUMNS``.\n        \"\"\"\n        row = []\n        for column_index, column_name in enumerate(self.COLUMNS):\n            if column_index == 0:  # Mark:\n                row.append('')\n            elif column_name == 'Identifier':\n                row.append(pkg.id)\n            elif column_name == 'Status':\n                row.append(self._ds.status(pkg))\n            else:\n                attr = column_name.lower().replace(' ', '_')\n                row.append(getattr(pkg, attr, 'n/a'))\n        return row\n\n    # /////////////////////////////////////////////////////////////////\n    # External Interface\n    # /////////////////////////////////////////////////////////////////\n\n    def destroy(self, *e):\n        if self._destroyed:\n            return\n        self.top.destroy()\n        self._destroyed = True\n\n    def _destroy(self, *e):\n        if self.top is not None:\n            for afterid in self._afterid.values():\n                self.top.after_cancel(afterid)\n\n        # Abort any download in progress.\n        if self._downloading and self._use_threads:\n            self._abort_download()\n\n        # Make sure the garbage collector destroys these now;\n        # otherwise, they may get destroyed when we're not in the main\n        # thread, which would make Tkinter unhappy.\n        self._column_vars.clear()\n\n    def mainloop(self, *args, **kwargs):\n        self.top.mainloop(*args, **kwargs)\n\n    # /////////////////////////////////////////////////////////////////\n    # HELP\n    # /////////////////////////////////////////////////////////////////\n\n    HELP = textwrap.dedent(\n        \"\"\"\\\n    This tool can be used to download a variety of corpora and models\n    that can be used with NLTK.  Each corpus or model is distributed\n    in a single zip file, known as a \\\"package file.\\\"  You can\n    download packages individually, or you can download pre-defined\n    collections of packages.\n\n    When you download a package, it will be saved to the \\\"download\n    directory.\\\"  A default download directory is chosen when you run\n\n    the downloader; but you may also select a different download\n    directory.  On Windows, the default download directory is\n\n\n    \\\"package.\\\"\n\n    The NLTK downloader can be used to download a variety of corpora,\n    models, and other data packages.\n\n    Keyboard shortcuts::\n      [return]\\t Download\n      [up]\\t Select previous package\n      [down]\\t Select next package\n      [left]\\t Select previous tab\n      [right]\\t Select next tab\n    \"\"\"\n    )\n\n    def help(self, *e):\n        # The default font's not very legible; try using 'fixed' instead.\n        try:\n            ShowText(\n                self.top,\n                'Help: NLTK Dowloader',\n                self.HELP.strip(),\n                width=75,\n                font='fixed',\n            )\n        except:\n            ShowText(self.top, 'Help: NLTK Downloader', self.HELP.strip(), width=75)\n\n    def about(self, *e):\n        ABOUT = \"NLTK Downloader\\n\" + \"Written by Edward Loper\"\n        TITLE = 'About: NLTK Downloader'\n        try:\n            from six.moves.tkinter_messagebox import Message\n\n            Message(message=ABOUT, title=TITLE).show()\n        except ImportError:\n            ShowText(self.top, TITLE, ABOUT)\n\n    # /////////////////////////////////////////////////////////////////\n    # Progress Bar\n    # /////////////////////////////////////////////////////////////////\n\n    _gradient_width = 5\n\n    def _init_progressbar(self):\n        c = self._progressbar\n        width, height = int(c['width']), int(c['height'])\n        for i in range(0, (int(c['width']) * 2) // self._gradient_width):\n            c.create_line(\n                i * self._gradient_width + 20,\n                -20,\n                i * self._gradient_width - height - 20,\n                height + 20,\n                width=self._gradient_width,\n                fill='#%02x0000' % (80 + abs(i % 6 - 3) * 12),\n            )\n        c.addtag_all('gradient')\n        c.itemconfig('gradient', state='hidden')\n\n        # This is used to display progress\n        c.addtag_withtag(\n            'redbox', c.create_rectangle(0, 0, 0, 0, fill=self._PROGRESS_COLOR[0])\n        )\n\n    def _show_progress(self, percent):\n        c = self._progressbar\n        if percent is None:\n            c.coords('redbox', 0, 0, 0, 0)\n            c.itemconfig('gradient', state='hidden')\n        else:\n            width, height = int(c['width']), int(c['height'])\n            x = percent * int(width) // 100 + 1\n            c.coords('redbox', 0, 0, x, height + 1)\n\n    def _progress_alive(self):\n        c = self._progressbar\n        if not self._downloading:\n            c.itemconfig('gradient', state='hidden')\n        else:\n            c.itemconfig('gradient', state='normal')\n            x1, y1, x2, y2 = c.bbox('gradient')\n            if x1 <= -100:\n                c.move('gradient', (self._gradient_width * 6) - 4, 0)\n            else:\n                c.move('gradient', -4, 0)\n            afterid = self.top.after(200, self._progress_alive)\n            self._afterid['_progress_alive'] = afterid\n\n    # /////////////////////////////////////////////////////////////////\n    # Threaded downloader\n    # /////////////////////////////////////////////////////////////////\n\n    def _download_threaded(self, *e):\n        # If the user tries to start a new download while we're already\n        # downloading something, then abort the current download instead.\n        if self._downloading:\n            self._abort_download()\n            return\n\n        # Change the 'download' button to an 'abort' button.\n        self._download_button['text'] = 'Cancel'\n\n        marked = [\n            self._table[row, 'Identifier']\n            for row in range(len(self._table))\n            if self._table[row, 0] != ''\n        ]\n        selection = self._table.selected_row()\n        if not marked and selection is not None:\n            marked = [self._table[selection, 'Identifier']]\n\n        # Create a new data server object for the download operation,\n        # just in case the user modifies our data server during the\n        # download (e.g., clicking 'refresh' or editing the index url).\n        ds = Downloader(self._ds.url, self._ds.download_dir)\n\n        # Start downloading in a separate thread.\n        assert self._download_msg_queue == []\n        assert self._download_abort_queue == []\n        self._DownloadThread(\n            ds,\n            marked,\n            self._download_lock,\n            self._download_msg_queue,\n            self._download_abort_queue,\n        ).start()\n\n        # Monitor the download message queue & display its progress.\n        self._log_indent = 0\n        self._downloading = True\n        self._monitor_message_queue()\n\n        # Display an indication that we're still alive and well by\n        # cycling the progress bar.\n        self._progress_alive()\n\n    def _abort_download(self):\n        if self._downloading:\n            self._download_lock.acquire()\n            self._download_abort_queue.append('abort')\n            self._download_lock.release()\n\n    class _DownloadThread(threading.Thread):\n        def __init__(self, data_server, items, lock, message_queue, abort):\n            self.data_server = data_server\n            self.items = items\n            self.lock = lock\n            self.message_queue = message_queue\n            self.abort = abort\n            threading.Thread.__init__(self)\n\n        def run(self):\n            for msg in self.data_server.incr_download(self.items):\n                self.lock.acquire()\n                self.message_queue.append(msg)\n                # Check if we've been told to kill ourselves:\n                if self.abort:\n                    self.message_queue.append('aborted')\n                    self.lock.release()\n                    return\n                self.lock.release()\n            self.lock.acquire()\n            self.message_queue.append('finished')\n            self.lock.release()\n\n    _MONITOR_QUEUE_DELAY = 100\n\n    def _monitor_message_queue(self):\n        def show(s):\n            self._progresslabel['text'] = s\n            self._log(s)\n\n        # Try to acquire the lock; if it's busy, then just try again later.\n        if not self._download_lock.acquire():\n            return\n        for msg in self._download_msg_queue:\n\n            # Done downloading?\n            if msg == 'finished' or msg == 'aborted':\n                # self._fill_table(sort=False)\n                self._update_table_status()\n                self._downloading = False\n                self._download_button['text'] = 'Download'\n                del self._download_msg_queue[:]\n                del self._download_abort_queue[:]\n                self._download_lock.release()\n                if msg == 'aborted':\n                    show('Download aborted!')\n                    self._show_progress(None)\n                else:\n                    afterid = self.top.after(100, self._show_progress, None)\n                    self._afterid['_monitor_message_queue'] = afterid\n                return\n\n            # All other messages\n            elif isinstance(msg, ProgressMessage):\n                self._show_progress(msg.progress)\n            elif isinstance(msg, ErrorMessage):\n                show(msg.message)\n                if msg.package is not None:\n                    self._select(msg.package.id)\n                self._show_progress(None)\n                self._downloading = False\n                return  # halt progress.\n            elif isinstance(msg, StartCollectionMessage):\n                show('Downloading collection %r' % msg.collection.id)\n                self._log_indent += 1\n            elif isinstance(msg, StartPackageMessage):\n                self._ds.clear_status_cache(msg.package.id)\n                show('Downloading package %r' % msg.package.id)\n            elif isinstance(msg, UpToDateMessage):\n                show('Package %s is up-to-date!' % msg.package.id)\n            # elif isinstance(msg, StaleMessage):\n            #    show('Package %s is out-of-date or corrupt; updating it' %\n            #         msg.package.id)\n            elif isinstance(msg, FinishDownloadMessage):\n                show('Finished downloading %r.' % msg.package.id)\n            elif isinstance(msg, StartUnzipMessage):\n                show('Unzipping %s' % msg.package.filename)\n            elif isinstance(msg, FinishUnzipMessage):\n                show('Finished installing %s' % msg.package.id)\n            elif isinstance(msg, FinishCollectionMessage):\n                self._log_indent -= 1\n                show('Finished downloading collection %r.' % msg.collection.id)\n                self._clear_mark(msg.collection.id)\n            elif isinstance(msg, FinishPackageMessage):\n                self._update_table_status()\n                self._clear_mark(msg.package.id)\n\n        # Let the user know when we're aborting a download (but\n        # waiting for a good point to abort it, so we don't end up\n        # with a partially unzipped package or anything like that).\n        if self._download_abort_queue:\n            self._progresslabel['text'] = 'Aborting download...'\n\n        # Clear the message queue and then release the lock\n        del self._download_msg_queue[:]\n        self._download_lock.release()\n\n        # Check the queue again after MONITOR_QUEUE_DELAY msec.\n        afterid = self.top.after(self._MONITOR_QUEUE_DELAY, self._monitor_message_queue)\n        self._afterid['_monitor_message_queue'] = afterid\n\n\n######################################################################\n# Helper Functions\n######################################################################\n# [xx] It may make sense to move these to nltk.internals.\n\n\ndef md5_hexdigest(file):\n    \"\"\"\n    Calculate and return the MD5 checksum for a given file.\n    ``file`` may either be a filename or an open stream.\n    \"\"\"\n    if isinstance(file, string_types):\n        with open(file, 'rb') as infile:\n            return _md5_hexdigest(infile)\n    return _md5_hexdigest(file)\n\n\ndef _md5_hexdigest(fp):\n    md5_digest = md5()\n    while True:\n        block = fp.read(1024 * 16)  # 16k blocks\n        if not block:\n            break\n        md5_digest.update(block)\n    return md5_digest.hexdigest()\n\n\n# change this to periodically yield progress messages?\n# [xx] get rid of topdir parameter -- we should be checking\n# this when we build the index, anyway.\ndef unzip(filename, root, verbose=True):\n    \"\"\"\n    Extract the contents of the zip file ``filename`` into the\n    directory ``root``.\n    \"\"\"\n    for message in _unzip_iter(filename, root, verbose):\n        if isinstance(message, ErrorMessage):\n            raise Exception(message)\n\n\ndef _unzip_iter(filename, root, verbose=True):\n    if verbose:\n        sys.stdout.write('Unzipping %s' % os.path.split(filename)[1])\n        sys.stdout.flush()\n\n    try:\n        zf = zipfile.ZipFile(filename)\n    except zipfile.error as e:\n        yield ErrorMessage(filename, 'Error with downloaded zip file')\n        return\n    except Exception as e:\n        yield ErrorMessage(filename, e)\n        return\n\n    # Get lists of directories & files\n    namelist = zf.namelist()\n    dirlist = set()\n    for x in namelist:\n        if x.endswith('/'):\n            dirlist.add(x)\n        else:\n            dirlist.add(x.rsplit('/', 1)[0] + '/')\n    filelist = [x for x in namelist if not x.endswith('/')]\n\n    # Create the target directory if it doesn't exist\n    if not os.path.exists(root):\n        os.mkdir(root)\n\n    # Create the directory structure\n    for dirname in sorted(dirlist):\n        pieces = dirname[:-1].split('/')\n        for i in range(len(pieces)):\n            dirpath = os.path.join(root, *pieces[: i + 1])\n            if not os.path.exists(dirpath):\n                os.mkdir(dirpath)\n\n    # Extract files.\n    for i, filename in enumerate(filelist):\n        filepath = os.path.join(root, *filename.split('/'))\n\n        try:\n            with open(filepath, 'wb') as dstfile, zf.open(filename) as srcfile:\n                shutil.copyfileobj(srcfile, dstfile)\n        except Exception as e:\n            yield ErrorMessage(filename, e)\n            return\n\n        if verbose and (i * 10 / len(filelist) > (i - 1) * 10 / len(filelist)):\n            sys.stdout.write('.')\n            sys.stdout.flush()\n    if verbose:\n        print()\n\n\n######################################################################\n# Index Builder\n######################################################################\n# This may move to a different file sometime.\n\n\ndef build_index(root, base_url):\n    \"\"\"\n    Create a new data.xml index file, by combining the xml description\n    files for various packages and collections.  ``root`` should be the\n    path to a directory containing the package xml and zip files; and\n    the collection xml files.  The ``root`` directory is expected to\n    have the following subdirectories::\n\n      root/\n        packages/ .................. subdirectory for packages\n          corpora/ ................. zip & xml files for corpora\n          grammars/ ................ zip & xml files for grammars\n          taggers/ ................. zip & xml files for taggers\n          tokenizers/ .............. zip & xml files for tokenizers\n          etc.\n        collections/ ............... xml files for collections\n\n    For each package, there should be two files: ``package.zip``\n    (where *package* is the package name)\n    which contains the package itself as a compressed zip file; and\n    ``package.xml``, which is an xml description of the package.  The\n    zipfile ``package.zip`` should expand to a single subdirectory\n    named ``package/``.  The base filename ``package`` must match\n    the identifier given in the package's xml file.\n\n    For each collection, there should be a single file ``collection.zip``\n    describing the collection, where *collection* is the name of the collection.\n\n    All identifiers (for both packages and collections) must be unique.\n    \"\"\"\n    # Find all packages.\n    packages = []\n    for pkg_xml, zf, subdir in _find_packages(os.path.join(root, 'packages')):\n        zipstat = os.stat(zf.filename)\n        url = '%s/%s/%s' % (base_url, subdir, os.path.split(zf.filename)[1])\n        unzipped_size = sum(zf_info.file_size for zf_info in zf.infolist())\n\n        # Fill in several fields of the package xml with calculated values.\n        pkg_xml.set('unzipped_size', '%s' % unzipped_size)\n        pkg_xml.set('size', '%s' % zipstat.st_size)\n        pkg_xml.set('checksum', '%s' % md5_hexdigest(zf.filename))\n        pkg_xml.set('subdir', subdir)\n        # pkg_xml.set('svn_revision', _svn_revision(zf.filename))\n        if not pkg_xml.get('url'):\n            pkg_xml.set('url', url)\n\n        # Record the package.\n        packages.append(pkg_xml)\n\n    # Find all collections\n    collections = list(_find_collections(os.path.join(root, 'collections')))\n\n    # Check that all UIDs are unique\n    uids = set()\n    for item in packages + collections:\n        if item.get('id') in uids:\n            raise ValueError('Duplicate UID: %s' % item.get('id'))\n        uids.add(item.get('id'))\n\n    # Put it all together\n    top_elt = ElementTree.Element('nltk_data')\n    top_elt.append(ElementTree.Element('packages'))\n    for package in packages:\n        top_elt[0].append(package)\n    top_elt.append(ElementTree.Element('collections'))\n    for collection in collections:\n        top_elt[1].append(collection)\n\n    _indent_xml(top_elt)\n    return top_elt\n\n\ndef _indent_xml(xml, prefix=''):\n    \"\"\"\n    Helper for ``build_index()``: Given an XML ``ElementTree``, modify it\n    (and its descendents) ``text`` and ``tail`` attributes to generate\n    an indented tree, where each nested element is indented by 2\n    spaces with respect to its parent.\n    \"\"\"\n    if len(xml) > 0:\n        xml.text = (xml.text or '').strip() + '\\n' + prefix + '  '\n        for child in xml:\n            _indent_xml(child, prefix + '  ')\n        for child in xml[:-1]:\n            child.tail = (child.tail or '').strip() + '\\n' + prefix + '  '\n        xml[-1].tail = (xml[-1].tail or '').strip() + '\\n' + prefix\n\n\ndef _check_package(pkg_xml, zipfilename, zf):\n    \"\"\"\n    Helper for ``build_index()``: Perform some checks to make sure that\n    the given package is consistent.\n    \"\"\"\n    # The filename must patch the id given in the XML file.\n    uid = os.path.splitext(os.path.split(zipfilename)[1])[0]\n    if pkg_xml.get('id') != uid:\n        raise ValueError(\n            'package identifier mismatch (%s vs %s)' % (pkg_xml.get('id'), uid)\n        )\n\n    # Zip file must expand to a subdir whose name matches uid.\n    if sum((name != uid and not name.startswith(uid + '/')) for name in zf.namelist()):\n        raise ValueError(\n            'Zipfile %s.zip does not expand to a single '\n            'subdirectory %s/' % (uid, uid)\n        )\n\n\n# update for git?\ndef _svn_revision(filename):\n    \"\"\"\n    Helper for ``build_index()``: Calculate the subversion revision\n    number for a given file (by using ``subprocess`` to run ``svn``).\n    \"\"\"\n    p = subprocess.Popen(\n        ['svn', 'status', '-v', filename],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n    )\n    (stdout, stderr) = p.communicate()\n    if p.returncode != 0 or stderr or not stdout:\n        raise ValueError(\n            'Error determining svn_revision for %s: %s'\n            % (os.path.split(filename)[1], textwrap.fill(stderr))\n        )\n    return stdout.split()[2]\n\n\ndef _find_collections(root):\n    \"\"\"\n    Helper for ``build_index()``: Yield a list of ElementTree.Element\n    objects, each holding the xml for a single package collection.\n    \"\"\"\n    packages = []\n    for dirname, subdirs, files in os.walk(root):\n        for filename in files:\n            if filename.endswith('.xml'):\n                xmlfile = os.path.join(dirname, filename)\n                yield ElementTree.parse(xmlfile).getroot()\n\n\ndef _find_packages(root):\n    \"\"\"\n    Helper for ``build_index()``: Yield a list of tuples\n    ``(pkg_xml, zf, subdir)``, where:\n      - ``pkg_xml`` is an ``ElementTree.Element`` holding the xml for a\n        package\n      - ``zf`` is a ``zipfile.ZipFile`` for the package's contents.\n      - ``subdir`` is the subdirectory (relative to ``root``) where\n        the package was found (e.g. 'corpora' or 'grammars').\n    \"\"\"\n    from nltk.corpus.reader.util import _path_from\n\n    # Find all packages.\n    packages = []\n    for dirname, subdirs, files in os.walk(root):\n        relpath = '/'.join(_path_from(root, dirname))\n        for filename in files:\n            if filename.endswith('.xml'):\n                xmlfilename = os.path.join(dirname, filename)\n                zipfilename = xmlfilename[:-4] + '.zip'\n                try:\n                    zf = zipfile.ZipFile(zipfilename)\n                except Exception as e:\n                    raise ValueError('Error reading file %r!\\n%s' % (zipfilename, e))\n                try:\n                    pkg_xml = ElementTree.parse(xmlfilename).getroot()\n                except Exception as e:\n                    raise ValueError('Error reading file %r!\\n%s' % (xmlfilename, e))\n\n                # Check that the UID matches the filename\n                uid = os.path.split(xmlfilename[:-4])[1]\n                if pkg_xml.get('id') != uid:\n                    raise ValueError(\n                        'package identifier mismatch (%s '\n                        'vs %s)' % (pkg_xml.get('id'), uid)\n                    )\n\n                # Check that the zipfile expands to a subdir whose\n                # name matches the uid.\n                if sum(\n                    (name != uid and not name.startswith(uid + '/'))\n                    for name in zf.namelist()\n                ):\n                    raise ValueError(\n                        'Zipfile %s.zip does not expand to a '\n                        'single subdirectory %s/' % (uid, uid)\n                    )\n\n                yield pkg_xml, zf, relpath\n        # Don't recurse into svn subdirectories:\n        try:\n            subdirs.remove('.svn')\n        except ValueError:\n            pass\n\n\n######################################################################\n# Main:\n######################################################################\n\n# There should be a command-line interface\n\n# Aliases\n_downloader = Downloader()\ndownload = _downloader.download\n\n\ndef download_shell():\n    DownloaderShell(_downloader).run()\n\n\ndef download_gui():\n    DownloaderGUI(_downloader).mainloop()\n\n\ndef update():\n    _downloader.update()\n\n\nif __name__ == '__main__':\n    from optparse import OptionParser\n\n    parser = OptionParser()\n    parser.add_option(\n        \"-d\",\n        \"--dir\",\n        dest=\"dir\",\n        help=\"download package to directory DIR\",\n        metavar=\"DIR\",\n    )\n    parser.add_option(\n        \"-q\",\n        \"--quiet\",\n        dest=\"quiet\",\n        action=\"store_true\",\n        default=False,\n        help=\"work quietly\",\n    )\n    parser.add_option(\n        \"-f\",\n        \"--force\",\n        dest=\"force\",\n        action=\"store_true\",\n        default=False,\n        help=\"download even if already installed\",\n    )\n    parser.add_option(\n        \"-e\",\n        \"--exit-on-error\",\n        dest=\"halt_on_error\",\n        action=\"store_true\",\n        default=False,\n        help=\"exit if an error occurs\",\n    )\n    parser.add_option(\n        \"-u\",\n        \"--url\",\n        dest=\"server_index_url\",\n        default=os.environ.get('NLTK_DOWNLOAD_URL'),\n        help=\"download server index url\",\n    )\n\n    (options, args) = parser.parse_args()\n\n    downloader = Downloader(server_index_url=options.server_index_url)\n\n    if args:\n        for pkg_id in args:\n            rv = downloader.download(\n                info_or_id=pkg_id,\n                download_dir=options.dir,\n                quiet=options.quiet,\n                force=options.force,\n                halt_on_error=options.halt_on_error,\n            )\n            if rv == False and options.halt_on_error:\n                break\n    else:\n        downloader.download(\n            download_dir=options.dir,\n            quiet=options.quiet,\n            force=options.force,\n            halt_on_error=options.halt_on_error,\n        )\n"], "fixing_code": ["# Natural Language Toolkit: Corpus & Model Downloader\n#\n# Copyright (C) 2001-2019 NLTK Project\n# Author: Edward Loper <edloper@gmail.com>\n# URL: <http://nltk.org/>\n# For license information, see LICENSE.TXT\n\n\"\"\"\nThe NLTK corpus and module downloader.  This module defines several\ninterfaces which can be used to download corpora, models, and other\ndata packages that can be used with NLTK.\n\nDownloading Packages\n====================\nIf called with no arguments, ``download()`` will display an interactive\ninterface which can be used to download and install new packages.\nIf Tkinter is available, then a graphical interface will be shown,\notherwise a simple text interface will be provided.\n\nIndividual packages can be downloaded by calling the ``download()``\nfunction with a single argument, giving the package identifier for the\npackage that should be downloaded:\n\n    >>> download('treebank') # doctest: +SKIP\n    [nltk_data] Downloading package 'treebank'...\n    [nltk_data]   Unzipping corpora/treebank.zip.\n\nNLTK also provides a number of \\\"package collections\\\", consisting of\na group of related packages.  To download all packages in a\ncolleciton, simply call ``download()`` with the collection's\nidentifier:\n\n    >>> download('all-corpora') # doctest: +SKIP\n    [nltk_data] Downloading package 'abc'...\n    [nltk_data]   Unzipping corpora/abc.zip.\n    [nltk_data] Downloading package 'alpino'...\n    [nltk_data]   Unzipping corpora/alpino.zip.\n      ...\n    [nltk_data] Downloading package 'words'...\n    [nltk_data]   Unzipping corpora/words.zip.\n\nDownload Directory\n==================\nBy default, packages are installed in either a system-wide directory\n(if Python has sufficient access to write to it); or in the current\nuser's home directory.  However, the ``download_dir`` argument may be\nused to specify a different installation target, if desired.\n\nSee ``Downloader.default_download_dir()`` for more a detailed\ndescription of how the default download directory is chosen.\n\nNLTK Download Server\n====================\nBefore downloading any packages, the corpus and module downloader\ncontacts the NLTK download server, to retrieve an index file\ndescribing the available packages.  By default, this index file is\nloaded from ``https://raw.githubusercontent.com/nltk/nltk_data/gh-pages/index.xml``.\nIf necessary, it is possible to create a new ``Downloader`` object,\nspecifying a different URL for the package index file.\n\nUsage::\n\n    python nltk/downloader.py [-d DATADIR] [-q] [-f] [-k] PACKAGE_IDS\n\nor::\n\n    python -m nltk.downloader [-d DATADIR] [-q] [-f] [-k] PACKAGE_IDS\n\"\"\"\n# ----------------------------------------------------------------------\nfrom __future__ import print_function, division, unicode_literals\n\n\"\"\"\n\n  0     1  2    3\n[label][----][label][----]\n[column  ][column     ]\n\nNotes\n=====\nHandling data files..  Some questions:\n\n* Should the data files be kept zipped or unzipped?  I say zipped.\n\n* Should the data files be kept in svn at all?  Advantages: history;\n  automatic version numbers; 'svn up' could be used rather than the\n  downloader to update the corpora.  Disadvantages: they're big,\n  which makes working from svn a bit of a pain.  And we're planning\n  to potentially make them much bigger.  I don't think we want\n  people to have to download 400MB corpora just to use nltk from svn.\n\n* Compromise: keep the data files in trunk/data rather than in\n  trunk/nltk.  That way you can check them out in svn if you want\n  to; but you don't need to, and you can use the downloader instead.\n\n* Also: keep models in mind.  When we change the code, we'd\n  potentially like the models to get updated.  This could require a\n  little thought.\n\n* So.. let's assume we have a trunk/data directory, containing a bunch\n  of packages.  The packages should be kept as zip files, because we\n  really shouldn't be editing them much (well -- we may edit models\n  more, but they tend to be binary-ish files anyway, where diffs\n  aren't that helpful).  So we'll have trunk/data, with a bunch of\n  files like abc.zip and treebank.zip and propbank.zip.  For each\n  package we could also have eg treebank.xml and propbank.xml,\n  describing the contents of the package (name, copyright, license,\n  etc).  Collections would also have .xml files.  Finally, we would\n  pull all these together to form a single index.xml file.  Some\n  directory structure wouldn't hurt.  So how about::\n\n    /trunk/data/ ....................... root of data svn\n      index.xml ........................ main index file\n      src/ ............................. python scripts\n      packages/ ........................ dir for packages\n        corpora/ ....................... zip & xml files for corpora\n        grammars/ ...................... zip & xml files for grammars\n        taggers/ ....................... zip & xml files for taggers\n        tokenizers/ .................... zip & xml files for tokenizers\n        etc.\n      collections/ ..................... xml files for collections\n\n  Where the root (/trunk/data) would contain a makefile; and src/\n  would contain a script to update the info.xml file.  It could also\n  contain scripts to rebuild some of the various model files.  The\n  script that builds index.xml should probably check that each zip\n  file expands entirely into a single subdir, whose name matches the\n  package's uid.\n\nChanges I need to make:\n  - in index: change \"size\" to \"filesize\" or \"compressed-size\"\n  - in index: add \"unzipped-size\"\n  - when checking status: check both compressed & uncompressed size.\n    uncompressed size is important to make sure we detect a problem\n    if something got partially unzipped.  define new status values\n    to differentiate stale vs corrupt vs corruptly-uncompressed??\n    (we shouldn't need to re-download the file if the zip file is ok\n    but it didn't get uncompressed fully.)\n  - add other fields to the index: author, license, copyright, contact,\n    etc.\n\nthe current grammars/ package would become a single new package (eg\ntoy-grammars or book-grammars).\n\nxml file should have:\n  - authorship info\n  - license info\n  - copyright info\n  - contact info\n  - info about what type of data/annotation it contains?\n  - recommended corpus reader?\n\ncollections can contain other collections.  they can also contain\nmultiple package types (corpora & models).  Have a single 'basics'\npackage that includes everything we talk about in the book?\n\nn.b.: there will have to be a fallback to the punkt tokenizer, in case\nthey didn't download that model.\n\ndefault: unzip or not?\n\n\"\"\"\nimport time, os, zipfile, sys, textwrap, threading, itertools, shutil, functools\nimport subprocess\nfrom hashlib import md5\nfrom xml.etree import ElementTree\n\ntry:\n    TKINTER = True\n    from six.moves.tkinter import (\n        Tk,\n        Frame,\n        Label,\n        Entry,\n        Button,\n        Canvas,\n        Menu,\n        IntVar,\n        TclError,\n    )\n    from six.moves.tkinter_messagebox import showerror\n    from nltk.draw.table import Table\n    from nltk.draw.util import ShowText\nexcept ImportError:\n    TKINTER = False\n    TclError = ValueError\n\nfrom six import string_types, text_type\nfrom six.moves import input\nfrom six.moves.urllib.request import urlopen\nfrom six.moves.urllib.error import HTTPError, URLError\n\nimport nltk\nfrom nltk.compat import python_2_unicode_compatible\n\n# urllib2 = nltk.internals.import_from_stdlib('urllib2')\n\n\n######################################################################\n# Directory entry objects (from the data server's index file)\n######################################################################\n\n\n@python_2_unicode_compatible\nclass Package(object):\n    \"\"\"\n    A directory entry for a downloadable package.  These entries are\n    extracted from the XML index file that is downloaded by\n    ``Downloader``.  Each package consists of a single file; but if\n    that file is a zip file, then it can be automatically decompressed\n    when the package is installed.\n    \"\"\"\n\n    def __init__(\n        self,\n        id,\n        url,\n        name=None,\n        subdir='',\n        size=None,\n        unzipped_size=None,\n        checksum=None,\n        svn_revision=None,\n        copyright='Unknown',\n        contact='Unknown',\n        license='Unknown',\n        author='Unknown',\n        unzip=True,\n        **kw\n    ):\n        self.id = id\n        \"\"\"A unique identifier for this package.\"\"\"\n\n        self.name = name or id\n        \"\"\"A string name for this package.\"\"\"\n\n        self.subdir = subdir\n        \"\"\"The subdirectory where this package should be installed.\n           E.g., ``'corpora'`` or ``'taggers'``.\"\"\"\n\n        self.url = url\n        \"\"\"A URL that can be used to download this package's file.\"\"\"\n\n        self.size = int(size)\n        \"\"\"The filesize (in bytes) of the package file.\"\"\"\n\n        self.unzipped_size = int(unzipped_size)\n        \"\"\"The total filesize of the files contained in the package's\n           zipfile.\"\"\"\n\n        self.checksum = checksum\n        \"\"\"The MD-5 checksum of the package file.\"\"\"\n\n        self.svn_revision = svn_revision\n        \"\"\"A subversion revision number for this package.\"\"\"\n\n        self.copyright = copyright\n        \"\"\"Copyright holder for this package.\"\"\"\n\n        self.contact = contact\n        \"\"\"Name & email of the person who should be contacted with\n           questions about this package.\"\"\"\n\n        self.license = license\n        \"\"\"License information for this package.\"\"\"\n\n        self.author = author\n        \"\"\"Author of this package.\"\"\"\n\n        ext = os.path.splitext(url.split('/')[-1])[1]\n        self.filename = os.path.join(subdir, id + ext)\n        \"\"\"The filename that should be used for this package's file.  It\n           is formed by joining ``self.subdir`` with ``self.id``, and\n           using the same extension as ``url``.\"\"\"\n\n        self.unzip = bool(int(unzip))  # '0' or '1'\n        \"\"\"A flag indicating whether this corpus should be unzipped by\n           default.\"\"\"\n\n        # Include any other attributes provided by the XML file.\n        self.__dict__.update(kw)\n\n    @staticmethod\n    def fromxml(xml):\n        if isinstance(xml, string_types):\n            xml = ElementTree.parse(xml)\n        for key in xml.attrib:\n            xml.attrib[key] = text_type(xml.attrib[key])\n        return Package(**xml.attrib)\n\n    def __lt__(self, other):\n        return self.id < other.id\n\n    def __repr__(self):\n        return '<Package %s>' % self.id\n\n\n@python_2_unicode_compatible\nclass Collection(object):\n    \"\"\"\n    A directory entry for a collection of downloadable packages.\n    These entries are extracted from the XML index file that is\n    downloaded by ``Downloader``.\n    \"\"\"\n\n    def __init__(self, id, children, name=None, **kw):\n        self.id = id\n        \"\"\"A unique identifier for this collection.\"\"\"\n\n        self.name = name or id\n        \"\"\"A string name for this collection.\"\"\"\n\n        self.children = children\n        \"\"\"A list of the ``Collections`` or ``Packages`` directly\n           contained by this collection.\"\"\"\n\n        self.packages = None\n        \"\"\"A list of ``Packages`` contained by this collection or any\n           collections it recursively contains.\"\"\"\n\n        # Include any other attributes provided by the XML file.\n        self.__dict__.update(kw)\n\n    @staticmethod\n    def fromxml(xml):\n        if isinstance(xml, string_types):\n            xml = ElementTree.parse(xml)\n        for key in xml.attrib:\n            xml.attrib[key] = text_type(xml.attrib[key])\n        children = [child.get('ref') for child in xml.findall('item')]\n        return Collection(children=children, **xml.attrib)\n\n    def __lt__(self, other):\n        return self.id < other.id\n\n    def __repr__(self):\n        return '<Collection %s>' % self.id\n\n\n######################################################################\n# Message Passing Objects\n######################################################################\n\n\nclass DownloaderMessage(object):\n    \"\"\"A status message object, used by ``incr_download`` to\n       communicate its progress.\"\"\"\n\n\nclass StartCollectionMessage(DownloaderMessage):\n    \"\"\"Data server has started working on a collection of packages.\"\"\"\n\n    def __init__(self, collection):\n        self.collection = collection\n\n\nclass FinishCollectionMessage(DownloaderMessage):\n    \"\"\"Data server has finished working on a collection of packages.\"\"\"\n\n    def __init__(self, collection):\n        self.collection = collection\n\n\nclass StartPackageMessage(DownloaderMessage):\n    \"\"\"Data server has started working on a package.\"\"\"\n\n    def __init__(self, package):\n        self.package = package\n\n\nclass FinishPackageMessage(DownloaderMessage):\n    \"\"\"Data server has finished working on a package.\"\"\"\n\n    def __init__(self, package):\n        self.package = package\n\n\nclass StartDownloadMessage(DownloaderMessage):\n    \"\"\"Data server has started downloading a package.\"\"\"\n\n    def __init__(self, package):\n        self.package = package\n\n\nclass FinishDownloadMessage(DownloaderMessage):\n    \"\"\"Data server has finished downloading a package.\"\"\"\n\n    def __init__(self, package):\n        self.package = package\n\n\nclass StartUnzipMessage(DownloaderMessage):\n    \"\"\"Data server has started unzipping a package.\"\"\"\n\n    def __init__(self, package):\n        self.package = package\n\n\nclass FinishUnzipMessage(DownloaderMessage):\n    \"\"\"Data server has finished unzipping a package.\"\"\"\n\n    def __init__(self, package):\n        self.package = package\n\n\nclass UpToDateMessage(DownloaderMessage):\n    \"\"\"The package download file is already up-to-date\"\"\"\n\n    def __init__(self, package):\n        self.package = package\n\n\nclass StaleMessage(DownloaderMessage):\n    \"\"\"The package download file is out-of-date or corrupt\"\"\"\n\n    def __init__(self, package):\n        self.package = package\n\n\nclass ErrorMessage(DownloaderMessage):\n    \"\"\"Data server encountered an error\"\"\"\n\n    def __init__(self, package, message):\n        self.package = package\n        if isinstance(message, Exception):\n            self.message = str(message)\n        else:\n            self.message = message\n\n\nclass ProgressMessage(DownloaderMessage):\n    \"\"\"Indicates how much progress the data server has made\"\"\"\n\n    def __init__(self, progress):\n        self.progress = progress\n\n\nclass SelectDownloadDirMessage(DownloaderMessage):\n    \"\"\"Indicates what download directory the data server is using\"\"\"\n\n    def __init__(self, download_dir):\n        self.download_dir = download_dir\n\n\n######################################################################\n# NLTK Data Server\n######################################################################\n\n\nclass Downloader(object):\n    \"\"\"\n    A class used to access the NLTK data server, which can be used to\n    download corpora and other data packages.\n    \"\"\"\n\n    # /////////////////////////////////////////////////////////////////\n    # Configuration\n    # /////////////////////////////////////////////////////////////////\n\n    INDEX_TIMEOUT = 60 * 60  # 1 hour\n    \"\"\"The amount of time after which the cached copy of the data\n       server index will be considered 'stale,' and will be\n       re-downloaded.\"\"\"\n\n    DEFAULT_URL = 'https://raw.githubusercontent.com/nltk/nltk_data/gh-pages/index.xml'\n    \"\"\"The default URL for the NLTK data server's index.  An\n       alternative URL can be specified when creating a new\n       ``Downloader`` object.\"\"\"\n\n    # /////////////////////////////////////////////////////////////////\n    # Status Constants\n    # /////////////////////////////////////////////////////////////////\n\n    INSTALLED = 'installed'\n    \"\"\"A status string indicating that a package or collection is\n       installed and up-to-date.\"\"\"\n    NOT_INSTALLED = 'not installed'\n    \"\"\"A status string indicating that a package or collection is\n       not installed.\"\"\"\n    STALE = 'out of date'\n    \"\"\"A status string indicating that a package or collection is\n       corrupt or out-of-date.\"\"\"\n    PARTIAL = 'partial'\n    \"\"\"A status string indicating that a collection is partially\n       installed (i.e., only some of its packages are installed.)\"\"\"\n\n    # /////////////////////////////////////////////////////////////////\n    # Cosntructor\n    # /////////////////////////////////////////////////////////////////\n\n    def __init__(self, server_index_url=None, download_dir=None):\n        self._url = server_index_url or self.DEFAULT_URL\n        \"\"\"The URL for the data server's index file.\"\"\"\n\n        self._collections = {}\n        \"\"\"Dictionary from collection identifier to ``Collection``\"\"\"\n\n        self._packages = {}\n        \"\"\"Dictionary from package identifier to ``Package``\"\"\"\n\n        self._download_dir = download_dir\n        \"\"\"The default directory to which packages will be downloaded.\"\"\"\n\n        self._index = None\n        \"\"\"The XML index file downloaded from the data server\"\"\"\n\n        self._index_timestamp = None\n        \"\"\"Time at which ``self._index`` was downloaded.  If it is more\n           than ``INDEX_TIMEOUT`` seconds old, it will be re-downloaded.\"\"\"\n\n        self._status_cache = {}\n        \"\"\"Dictionary from package/collection identifier to status\n           string (``INSTALLED``, ``NOT_INSTALLED``, ``STALE``, or\n           ``PARTIAL``).  Cache is used for packages only, not\n           collections.\"\"\"\n\n        self._errors = None\n        \"\"\"Flag for telling if all packages got successfully downloaded or not.\"\"\"\n\n        # decide where we're going to save things to.\n        if self._download_dir is None:\n            self._download_dir = self.default_download_dir()\n\n    # /////////////////////////////////////////////////////////////////\n    # Information\n    # /////////////////////////////////////////////////////////////////\n\n    def list(\n        self,\n        download_dir=None,\n        show_packages=True,\n        show_collections=True,\n        header=True,\n        more_prompt=False,\n        skip_installed=False,\n    ):\n        lines = 0  # for more_prompt\n        if download_dir is None:\n            download_dir = self._download_dir\n            print('Using default data directory (%s)' % download_dir)\n        if header:\n            print('=' * (26 + len(self._url)))\n            print(' Data server index for <%s>' % self._url)\n            print('=' * (26 + len(self._url)))\n            lines += 3  # for more_prompt\n        stale = partial = False\n\n        categories = []\n        if show_packages:\n            categories.append('packages')\n        if show_collections:\n            categories.append('collections')\n        for category in categories:\n            print('%s:' % category.capitalize())\n            lines += 1  # for more_prompt\n            for info in sorted(getattr(self, category)(), key=str):\n                status = self.status(info, download_dir)\n                if status == self.INSTALLED and skip_installed:\n                    continue\n                if status == self.STALE:\n                    stale = True\n                if status == self.PARTIAL:\n                    partial = True\n                prefix = {\n                    self.INSTALLED: '*',\n                    self.STALE: '-',\n                    self.PARTIAL: 'P',\n                    self.NOT_INSTALLED: ' ',\n                }[status]\n                name = textwrap.fill(\n                    '-' * 27 + (info.name or info.id), 75, subsequent_indent=27 * ' '\n                )[27:]\n                print('  [%s] %s %s' % (prefix, info.id.ljust(20, '.'), name))\n                lines += len(name.split('\\n'))  # for more_prompt\n                if more_prompt and lines > 20:\n                    user_input = input(\"Hit Enter to continue: \")\n                    if user_input.lower() in ('x', 'q'):\n                        return\n                    lines = 0\n            print()\n        msg = '([*] marks installed packages'\n        if stale:\n            msg += '; [-] marks out-of-date or corrupt packages'\n        if partial:\n            msg += '; [P] marks partially installed collections'\n        print(textwrap.fill(msg + ')', subsequent_indent=' ', width=76))\n\n    def packages(self):\n        self._update_index()\n        return self._packages.values()\n\n    def corpora(self):\n        self._update_index()\n        return [pkg for (id, pkg) in self._packages.items() if pkg.subdir == 'corpora']\n\n    def models(self):\n        self._update_index()\n        return [pkg for (id, pkg) in self._packages.items() if pkg.subdir != 'corpora']\n\n    def collections(self):\n        self._update_index()\n        return self._collections.values()\n\n    # /////////////////////////////////////////////////////////////////\n    # Downloading\n    # /////////////////////////////////////////////////////////////////\n\n    def _info_or_id(self, info_or_id):\n        if isinstance(info_or_id, string_types):\n            return self.info(info_or_id)\n        else:\n            return info_or_id\n\n    # [xx] When during downloading is it 'safe' to abort?  Only unsafe\n    # time is *during* an unzip -- we don't want to leave a\n    # partially-unzipped corpus in place because we wouldn't notice\n    # it.  But if we had the exact total size of the unzipped corpus,\n    # then that would be fine.  Then we could abort anytime we want!\n    # So this is really what we should do.  That way the threaded\n    # downloader in the gui can just kill the download thread anytime\n    # it wants.\n\n    def incr_download(self, info_or_id, download_dir=None, force=False):\n        # If they didn't specify a download_dir, then use the default one.\n        if download_dir is None:\n            download_dir = self._download_dir\n            yield SelectDownloadDirMessage(download_dir)\n\n        # If they gave us a list of ids, then download each one.\n        if isinstance(info_or_id, (list, tuple)):\n            for msg in self._download_list(info_or_id, download_dir, force):\n                yield msg\n            return\n\n        # Look up the requested collection or package.\n        try:\n            info = self._info_or_id(info_or_id)\n        except (IOError, ValueError) as e:\n            yield ErrorMessage(None, 'Error loading %s: %s' % (info_or_id, e))\n            return\n\n        # Handle collections.\n        if isinstance(info, Collection):\n            yield StartCollectionMessage(info)\n            for msg in self.incr_download(info.children, download_dir, force):\n                yield msg\n            yield FinishCollectionMessage(info)\n\n        # Handle Packages (delegate to a helper function).\n        else:\n            for msg in self._download_package(info, download_dir, force):\n                yield msg\n\n    def _num_packages(self, item):\n        if isinstance(item, Package):\n            return 1\n        else:\n            return len(item.packages)\n\n    def _download_list(self, items, download_dir, force):\n        # Look up the requested items.\n        for i in range(len(items)):\n            try:\n                items[i] = self._info_or_id(items[i])\n            except (IOError, ValueError) as e:\n                yield ErrorMessage(items[i], e)\n                return\n\n        # Download each item, re-scaling their progress.\n        num_packages = sum(self._num_packages(item) for item in items)\n        progress = 0\n        for i, item in enumerate(items):\n            if isinstance(item, Package):\n                delta = 1.0 / num_packages\n            else:\n                delta = len(item.packages) / num_packages\n            for msg in self.incr_download(item, download_dir, force):\n                if isinstance(msg, ProgressMessage):\n                    yield ProgressMessage(progress + msg.progress * delta)\n                else:\n                    yield msg\n\n            progress += 100 * delta\n\n    def _download_package(self, info, download_dir, force):\n        yield StartPackageMessage(info)\n        yield ProgressMessage(0)\n\n        # Do we already have the current version?\n        status = self.status(info, download_dir)\n        if not force and status == self.INSTALLED:\n            yield UpToDateMessage(info)\n            yield ProgressMessage(100)\n            yield FinishPackageMessage(info)\n            return\n\n        # Remove the package from our status cache\n        self._status_cache.pop(info.id, None)\n\n        # Check for (and remove) any old/stale version.\n        filepath = os.path.join(download_dir, info.filename)\n        if os.path.exists(filepath):\n            if status == self.STALE:\n                yield StaleMessage(info)\n            os.remove(filepath)\n\n        # Ensure the download_dir exists\n        if not os.path.exists(download_dir):\n            os.mkdir(download_dir)\n        if not os.path.exists(os.path.join(download_dir, info.subdir)):\n            os.mkdir(os.path.join(download_dir, info.subdir))\n\n        # Download the file.  This will raise an IOError if the url\n        # is not found.\n        yield StartDownloadMessage(info)\n        yield ProgressMessage(5)\n        try:\n            infile = urlopen(info.url)\n            with open(filepath, 'wb') as outfile:\n                # print info.size\n                num_blocks = max(1, info.size / (1024 * 16))\n                for block in itertools.count():\n                    s = infile.read(1024 * 16)  # 16k blocks.\n                    outfile.write(s)\n                    if not s:\n                        break\n                    if block % 2 == 0:  # how often?\n                        yield ProgressMessage(min(80, 5 + 75 * (block / num_blocks)))\n            infile.close()\n        except IOError as e:\n            yield ErrorMessage(\n                info,\n                'Error downloading %r from <%s>:' '\\n  %s' % (info.id, info.url, e),\n            )\n            return\n        yield FinishDownloadMessage(info)\n        yield ProgressMessage(80)\n\n        # If it's a zipfile, uncompress it.\n        if info.filename.endswith('.zip'):\n            zipdir = os.path.join(download_dir, info.subdir)\n            # Unzip if we're unzipping by default; *or* if it's already\n            # been unzipped (presumably a previous version).\n            if info.unzip or os.path.exists(os.path.join(zipdir, info.id)):\n                yield StartUnzipMessage(info)\n                for msg in _unzip_iter(filepath, zipdir, verbose=False):\n                    # Somewhat of a hack, but we need a proper package reference\n                    msg.package = info\n                    yield msg\n                yield FinishUnzipMessage(info)\n\n        yield FinishPackageMessage(info)\n\n    def download(\n        self,\n        info_or_id=None,\n        download_dir=None,\n        quiet=False,\n        force=False,\n        prefix='[nltk_data] ',\n        halt_on_error=True,\n        raise_on_error=False,\n        print_error_to=sys.stderr,\n    ):\n\n        print_to = functools.partial(print, file=print_error_to)\n        # If no info or id is given, then use the interactive shell.\n        if info_or_id is None:\n            # [xx] hmm -- changing self._download_dir here seems like\n            # the wrong thing to do.  Maybe the _interactive_download\n            # function should make a new copy of self to use?\n            if download_dir is not None:\n                self._download_dir = download_dir\n            self._interactive_download()\n            return True\n\n        else:\n            # Define a helper function for displaying output:\n            def show(s, prefix2=''):\n                print_to(\n                    textwrap.fill(\n                        s,\n                        initial_indent=prefix + prefix2,\n                        subsequent_indent=prefix + prefix2 + ' ' * 4,\n                    )\n                )\n\n            for msg in self.incr_download(info_or_id, download_dir, force):\n                # Error messages\n                if isinstance(msg, ErrorMessage):\n                    show(msg.message)\n                    if raise_on_error:\n                        raise ValueError(msg.message)\n                    if halt_on_error:\n                        return False\n                    self._errors = True\n                    if not quiet:\n                        print_to(\"Error installing package. Retry? [n/y/e]\")\n                        choice = input().strip()\n                        if choice in ['y', 'Y']:\n                            if not self.download(\n                                msg.package.id,\n                                download_dir,\n                                quiet,\n                                force,\n                                prefix,\n                                halt_on_error,\n                                raise_on_error,\n                            ):\n                                return False\n                        elif choice in ['e', 'E']:\n                            return False\n\n                # All other messages\n                if not quiet:\n                    # Collection downloading messages:\n                    if isinstance(msg, StartCollectionMessage):\n                        show('Downloading collection %r' % msg.collection.id)\n                        prefix += '   | '\n                        print_to(prefix)\n                    elif isinstance(msg, FinishCollectionMessage):\n                        print_to(prefix)\n                        prefix = prefix[:-4]\n                        if self._errors:\n                            show(\n                                'Downloaded collection %r with errors'\n                                % msg.collection.id\n                            )\n                        else:\n                            show('Done downloading collection %s' % msg.collection.id)\n\n                    # Package downloading messages:\n                    elif isinstance(msg, StartPackageMessage):\n                        show(\n                            'Downloading package %s to %s...'\n                            % (msg.package.id, download_dir)\n                        )\n                    elif isinstance(msg, UpToDateMessage):\n                        show('Package %s is already up-to-date!' % msg.package.id, '  ')\n                    # elif isinstance(msg, StaleMessage):\n                    #    show('Package %s is out-of-date or corrupt' %\n                    #         msg.package.id, '  ')\n                    elif isinstance(msg, StartUnzipMessage):\n                        show('Unzipping %s.' % msg.package.filename, '  ')\n\n                    # Data directory message:\n                    elif isinstance(msg, SelectDownloadDirMessage):\n                        download_dir = msg.download_dir\n        return True\n\n    def is_stale(self, info_or_id, download_dir=None):\n        return self.status(info_or_id, download_dir) == self.STALE\n\n    def is_installed(self, info_or_id, download_dir=None):\n        return self.status(info_or_id, download_dir) == self.INSTALLED\n\n    def clear_status_cache(self, id=None):\n        if id is None:\n            self._status_cache.clear()\n        else:\n            self._status_cache.pop(id, None)\n\n    def status(self, info_or_id, download_dir=None):\n        \"\"\"\n        Return a constant describing the status of the given package\n        or collection.  Status can be one of ``INSTALLED``,\n        ``NOT_INSTALLED``, ``STALE``, or ``PARTIAL``.\n        \"\"\"\n        if download_dir is None:\n            download_dir = self._download_dir\n        info = self._info_or_id(info_or_id)\n\n        # Handle collections:\n        if isinstance(info, Collection):\n            pkg_status = [self.status(pkg.id) for pkg in info.packages]\n            if self.STALE in pkg_status:\n                return self.STALE\n            elif self.PARTIAL in pkg_status:\n                return self.PARTIAL\n            elif self.INSTALLED in pkg_status and self.NOT_INSTALLED in pkg_status:\n                return self.PARTIAL\n            elif self.NOT_INSTALLED in pkg_status:\n                return self.NOT_INSTALLED\n            else:\n                return self.INSTALLED\n\n        # Handle packages:\n        else:\n            filepath = os.path.join(download_dir, info.filename)\n            if download_dir != self._download_dir:\n                return self._pkg_status(info, filepath)\n            else:\n                if info.id not in self._status_cache:\n                    self._status_cache[info.id] = self._pkg_status(info, filepath)\n                return self._status_cache[info.id]\n\n    def _pkg_status(self, info, filepath):\n        if not os.path.exists(filepath):\n            return self.NOT_INSTALLED\n\n        # Check if the file has the correct size.\n        try:\n            filestat = os.stat(filepath)\n        except OSError:\n            return self.NOT_INSTALLED\n        if filestat.st_size != int(info.size):\n            return self.STALE\n\n        # Check if the file's checksum matches\n        if md5_hexdigest(filepath) != info.checksum:\n            return self.STALE\n\n        # If it's a zipfile, and it's been at least partially\n        # unzipped, then check if it's been fully unzipped.\n        if filepath.endswith('.zip'):\n            unzipdir = filepath[:-4]\n            if not os.path.exists(unzipdir):\n                return self.INSTALLED  # but not unzipped -- ok!\n            if not os.path.isdir(unzipdir):\n                return self.STALE\n\n            unzipped_size = sum(\n                os.stat(os.path.join(d, f)).st_size\n                for d, _, files in os.walk(unzipdir)\n                for f in files\n            )\n            if unzipped_size != info.unzipped_size:\n                return self.STALE\n\n        # Otherwise, everything looks good.\n        return self.INSTALLED\n\n    def update(self, quiet=False, prefix='[nltk_data] '):\n        \"\"\"\n        Re-download any packages whose status is STALE.\n        \"\"\"\n        self.clear_status_cache()\n        for pkg in self.packages():\n            if self.status(pkg) == self.STALE:\n                self.download(pkg, quiet=quiet, prefix=prefix)\n\n    # /////////////////////////////////////////////////////////////////\n    # Index\n    # /////////////////////////////////////////////////////////////////\n\n    def _update_index(self, url=None):\n        \"\"\"A helper function that ensures that self._index is\n        up-to-date.  If the index is older than self.INDEX_TIMEOUT,\n        then download it again.\"\"\"\n        # Check if the index is aleady up-to-date.  If so, do nothing.\n        if not (\n            self._index is None\n            or url is not None\n            or time.time() - self._index_timestamp > self.INDEX_TIMEOUT\n        ):\n            return\n\n        # If a URL was specified, then update our URL.\n        self._url = url or self._url\n\n        # Download the index file.\n        self._index = nltk.internals.ElementWrapper(\n            ElementTree.parse(urlopen(self._url)).getroot()\n        )\n        self._index_timestamp = time.time()\n\n        # Build a dictionary of packages.\n        packages = [Package.fromxml(p) for p in self._index.findall('packages/package')]\n        self._packages = dict((p.id, p) for p in packages)\n\n        # Build a dictionary of collections.\n        collections = [\n            Collection.fromxml(c) for c in self._index.findall('collections/collection')\n        ]\n        self._collections = dict((c.id, c) for c in collections)\n\n        # Replace identifiers with actual children in collection.children.\n        for collection in self._collections.values():\n            for i, child_id in enumerate(collection.children):\n                if child_id in self._packages:\n                    collection.children[i] = self._packages[child_id]\n                elif child_id in self._collections:\n                    collection.children[i] = self._collections[child_id]\n                else:\n                    print(\n                        'removing collection member with no package: {}'.format(\n                            child_id\n                        )\n                    )\n                    del collection.children[i]\n\n        # Fill in collection.packages for each collection.\n        for collection in self._collections.values():\n            packages = {}\n            queue = [collection]\n            for child in queue:\n                if isinstance(child, Collection):\n                    queue.extend(child.children)\n                elif isinstance(child, Package):\n                    packages[child.id] = child\n                else:\n                    pass\n            collection.packages = packages.values()\n\n        # Flush the status cache\n        self._status_cache.clear()\n\n    def index(self):\n        \"\"\"\n        Return the XML index describing the packages available from\n        the data server.  If necessary, this index will be downloaded\n        from the data server.\n        \"\"\"\n        self._update_index()\n        return self._index\n\n    def info(self, id):\n        \"\"\"Return the ``Package`` or ``Collection`` record for the\n           given item.\"\"\"\n        self._update_index()\n        if id in self._packages:\n            return self._packages[id]\n        if id in self._collections:\n            return self._collections[id]\n        raise ValueError('Package %r not found in index' % id)\n\n    def xmlinfo(self, id):\n        \"\"\"Return the XML info record for the given item\"\"\"\n        self._update_index()\n        for package in self._index.findall('packages/package'):\n            if package.get('id') == id:\n                return package\n        for collection in self._index.findall('collections/collection'):\n            if collection.get('id') == id:\n                return collection\n        raise ValueError('Package %r not found in index' % id)\n\n    # /////////////////////////////////////////////////////////////////\n    # URL & Data Directory\n    # /////////////////////////////////////////////////////////////////\n\n    def _get_url(self):\n        \"\"\"The URL for the data server's index file.\"\"\"\n        return self._url\n\n    def _set_url(self, url):\n        \"\"\"\n        Set a new URL for the data server. If we're unable to contact\n        the given url, then the original url is kept.\n        \"\"\"\n        original_url = self._url\n        try:\n            self._update_index(url)\n        except:\n            self._url = original_url\n            raise\n\n    url = property(_get_url, _set_url)\n\n    def default_download_dir(self):\n        \"\"\"\n        Return the directory to which packages will be downloaded by\n        default.  This value can be overridden using the constructor,\n        or on a case-by-case basis using the ``download_dir`` argument when\n        calling ``download()``.\n\n        On Windows, the default download directory is\n        ``PYTHONHOME/lib/nltk``, where *PYTHONHOME* is the\n        directory containing Python, e.g. ``C:\\\\Python25``.\n\n        On all other platforms, the default directory is the first of\n        the following which exists or which can be created with write\n        permission: ``/usr/share/nltk_data``, ``/usr/local/share/nltk_data``,\n        ``/usr/lib/nltk_data``, ``/usr/local/lib/nltk_data``, ``~/nltk_data``.\n        \"\"\"\n        # Check if we are on GAE where we cannot write into filesystem.\n        if 'APPENGINE_RUNTIME' in os.environ:\n            return\n\n        # Check if we have sufficient permissions to install in a\n        # variety of system-wide locations.\n        for nltkdir in nltk.data.path:\n            if os.path.exists(nltkdir) and nltk.internals.is_writable(nltkdir):\n                return nltkdir\n\n        # On Windows, use %APPDATA%\n        if sys.platform == 'win32' and 'APPDATA' in os.environ:\n            homedir = os.environ['APPDATA']\n\n        # Otherwise, install in the user's home directory.\n        else:\n            homedir = os.path.expanduser('~/')\n            if homedir == '~/':\n                raise ValueError(\"Could not find a default download directory\")\n\n        # append \"nltk_data\" to the home directory\n        return os.path.join(homedir, 'nltk_data')\n\n    def _get_download_dir(self):\n        \"\"\"\n        The default directory to which packages will be downloaded.\n        This defaults to the value returned by ``default_download_dir()``.\n        To override this default on a case-by-case basis, use the\n        ``download_dir`` argument when calling ``download()``.\n        \"\"\"\n        return self._download_dir\n\n    def _set_download_dir(self, download_dir):\n        self._download_dir = download_dir\n        # Clear the status cache.\n        self._status_cache.clear()\n\n    download_dir = property(_get_download_dir, _set_download_dir)\n\n    # /////////////////////////////////////////////////////////////////\n    # Interactive Shell\n    # /////////////////////////////////////////////////////////////////\n\n    def _interactive_download(self):\n        # Try the GUI first; if that doesn't work, try the simple\n        # interactive shell.\n        if TKINTER:\n            try:\n                DownloaderGUI(self).mainloop()\n            except TclError:\n                DownloaderShell(self).run()\n        else:\n            DownloaderShell(self).run()\n\n\nclass DownloaderShell(object):\n    def __init__(self, dataserver):\n        self._ds = dataserver\n\n    def _simple_interactive_menu(self, *options):\n        print('-' * 75)\n        spc = (68 - sum(len(o) for o in options)) // (len(options) - 1) * ' '\n        print('    ' + spc.join(options))\n        # w = 76/len(options)\n        # fmt = '  ' + ('%-'+str(w)+'s')*(len(options)-1) + '%s'\n        # print fmt % options\n        print('-' * 75)\n\n    def run(self):\n        print('NLTK Downloader')\n        while True:\n            self._simple_interactive_menu(\n                'd) Download',\n                'l) List',\n                ' u) Update',\n                'c) Config',\n                'h) Help',\n                'q) Quit',\n            )\n            user_input = input('Downloader> ').strip()\n            if not user_input:\n                print()\n                continue\n            command = user_input.lower().split()[0]\n            args = user_input.split()[1:]\n            try:\n                if command == 'l':\n                    print()\n                    self._ds.list(self._ds.download_dir, header=False, more_prompt=True)\n                elif command == 'h':\n                    self._simple_interactive_help()\n                elif command == 'c':\n                    self._simple_interactive_config()\n                elif command in ('q', 'x'):\n                    return\n                elif command == 'd':\n                    self._simple_interactive_download(args)\n                elif command == 'u':\n                    self._simple_interactive_update()\n                else:\n                    print('Command %r unrecognized' % user_input)\n            except HTTPError as e:\n                print('Error reading from server: %s' % e)\n            except URLError as e:\n                print('Error connecting to server: %s' % e.reason)\n            # try checking if user_input is a package name, &\n            # downloading it?\n            print()\n\n    def _simple_interactive_download(self, args):\n        if args:\n            for arg in args:\n                try:\n                    self._ds.download(arg, prefix='    ')\n                except (IOError, ValueError) as e:\n                    print(e)\n        else:\n            while True:\n                print()\n                print('Download which package (l=list; x=cancel)?')\n                user_input = input('  Identifier> ')\n                if user_input.lower() == 'l':\n                    self._ds.list(\n                        self._ds.download_dir,\n                        header=False,\n                        more_prompt=True,\n                        skip_installed=True,\n                    )\n                    continue\n                elif user_input.lower() in ('x', 'q', ''):\n                    return\n                elif user_input:\n                    for id in user_input.split():\n                        try:\n                            self._ds.download(id, prefix='    ')\n                        except (IOError, ValueError) as e:\n                            print(e)\n                    break\n\n    def _simple_interactive_update(self):\n        while True:\n            stale_packages = []\n            stale = partial = False\n            for info in sorted(getattr(self._ds, 'packages')(), key=str):\n                if self._ds.status(info) == self._ds.STALE:\n                    stale_packages.append((info.id, info.name))\n\n            print()\n            if stale_packages:\n                print('Will update following packages (o=ok; x=cancel)')\n                for pid, pname in stale_packages:\n                    name = textwrap.fill(\n                        '-' * 27 + (pname), 75, subsequent_indent=27 * ' '\n                    )[27:]\n                    print('  [ ] %s %s' % (pid.ljust(20, '.'), name))\n                print()\n\n                user_input = input('  Identifier> ')\n                if user_input.lower() == 'o':\n                    for pid, pname in stale_packages:\n                        try:\n                            self._ds.download(pid, prefix='    ')\n                        except (IOError, ValueError) as e:\n                            print(e)\n                    break\n                elif user_input.lower() in ('x', 'q', ''):\n                    return\n            else:\n                print('Nothing to update.')\n                return\n\n    def _simple_interactive_help(self):\n        print()\n        print('Commands:')\n        print(\n            '  d) Download a package or collection     u) Update out of date packages'\n        )\n        print('  l) List packages & collections          h) Help')\n        print('  c) View & Modify Configuration          q) Quit')\n\n    def _show_config(self):\n        print()\n        print('Data Server:')\n        print('  - URL: <%s>' % self._ds.url)\n        print(('  - %d Package Collections Available' % len(self._ds.collections())))\n        print(('  - %d Individual Packages Available' % len(self._ds.packages())))\n        print()\n        print('Local Machine:')\n        print('  - Data directory: %s' % self._ds.download_dir)\n\n    def _simple_interactive_config(self):\n        self._show_config()\n        while True:\n            print()\n            self._simple_interactive_menu(\n                's) Show Config', 'u) Set Server URL', 'd) Set Data Dir', 'm) Main Menu'\n            )\n            user_input = input('Config> ').strip().lower()\n            if user_input == 's':\n                self._show_config()\n            elif user_input == 'd':\n                new_dl_dir = input('  New Directory> ').strip()\n                if new_dl_dir in ('', 'x', 'q', 'X', 'Q'):\n                    print('  Cancelled!')\n                elif os.path.isdir(new_dl_dir):\n                    self._ds.download_dir = new_dl_dir\n                else:\n                    print(('Directory %r not found!  Create it first.' % new_dl_dir))\n            elif user_input == 'u':\n                new_url = input('  New URL> ').strip()\n                if new_url in ('', 'x', 'q', 'X', 'Q'):\n                    print('  Cancelled!')\n                else:\n                    if not new_url.startswith(('http://', 'https://')):\n                        new_url = 'http://' + new_url\n                    try:\n                        self._ds.url = new_url\n                    except Exception as e:\n                        print('Error reading <%r>:\\n  %s' % (new_url, e))\n            elif user_input == 'm':\n                break\n\n\nclass DownloaderGUI(object):\n    \"\"\"\n    Graphical interface for downloading packages from the NLTK data\n    server.\n    \"\"\"\n\n    # /////////////////////////////////////////////////////////////////\n    # Column Configuration\n    # /////////////////////////////////////////////////////////////////\n\n    COLUMNS = [\n        '',\n        'Identifier',\n        'Name',\n        'Size',\n        'Status',\n        'Unzipped Size',\n        'Copyright',\n        'Contact',\n        'License',\n        'Author',\n        'Subdir',\n        'Checksum',\n    ]\n    \"\"\"A list of the names of columns.  This controls the order in\n       which the columns will appear.  If this is edited, then\n       ``_package_to_columns()`` may need to be edited to match.\"\"\"\n\n    COLUMN_WEIGHTS = {'': 0, 'Name': 5, 'Size': 0, 'Status': 0}\n    \"\"\"A dictionary specifying how columns should be resized when the\n       table is resized.  Columns with weight 0 will not be resized at\n       all; and columns with high weight will be resized more.\n       Default weight (for columns not explicitly listed) is 1.\"\"\"\n\n    COLUMN_WIDTHS = {\n        '': 1,\n        'Identifier': 20,\n        'Name': 45,\n        'Size': 10,\n        'Unzipped Size': 10,\n        'Status': 12,\n    }\n    \"\"\"A dictionary specifying how wide each column should be, in\n       characters.  The default width (for columns not explicitly\n       listed) is specified by ``DEFAULT_COLUMN_WIDTH``.\"\"\"\n\n    DEFAULT_COLUMN_WIDTH = 30\n    \"\"\"The default width for columns that are not explicitly listed\n       in ``COLUMN_WIDTHS``.\"\"\"\n\n    INITIAL_COLUMNS = ['', 'Identifier', 'Name', 'Size', 'Status']\n    \"\"\"The set of columns that should be displayed by default.\"\"\"\n\n    # Perform a few import-time sanity checks to make sure that the\n    # column configuration variables are defined consistently:\n    for c in COLUMN_WEIGHTS:\n        assert c in COLUMNS\n    for c in COLUMN_WIDTHS:\n        assert c in COLUMNS\n    for c in INITIAL_COLUMNS:\n        assert c in COLUMNS\n\n    # /////////////////////////////////////////////////////////////////\n    # Color Configuration\n    # /////////////////////////////////////////////////////////////////\n\n    _BACKDROP_COLOR = ('#000', '#ccc')\n\n    _ROW_COLOR = {\n        Downloader.INSTALLED: ('#afa', '#080'),\n        Downloader.PARTIAL: ('#ffa', '#880'),\n        Downloader.STALE: ('#faa', '#800'),\n        Downloader.NOT_INSTALLED: ('#fff', '#888'),\n    }\n\n    _MARK_COLOR = ('#000', '#ccc')\n\n    # _FRONT_TAB_COLOR = ('#ccf', '#008')\n    # _BACK_TAB_COLOR = ('#88a', '#448')\n    _FRONT_TAB_COLOR = ('#fff', '#45c')\n    _BACK_TAB_COLOR = ('#aaa', '#67a')\n\n    _PROGRESS_COLOR = ('#f00', '#aaa')\n\n    _TAB_FONT = 'helvetica -16 bold'\n\n    # /////////////////////////////////////////////////////////////////\n    # Constructor\n    # /////////////////////////////////////////////////////////////////\n\n    def __init__(self, dataserver, use_threads=True):\n        self._ds = dataserver\n        self._use_threads = use_threads\n\n        # For the threaded downloader:\n        self._download_lock = threading.Lock()\n        self._download_msg_queue = []\n        self._download_abort_queue = []\n        self._downloading = False\n\n        # For tkinter after callbacks:\n        self._afterid = {}\n\n        # A message log.\n        self._log_messages = []\n        self._log_indent = 0\n        self._log('NLTK Downloader Started!')\n\n        # Create the main window.\n        top = self.top = Tk()\n        top.geometry('+50+50')\n        top.title('NLTK Downloader')\n        top.configure(background=self._BACKDROP_COLOR[1])\n\n        # Set up some bindings now, in case anything goes wrong.\n        top.bind('<Control-q>', self.destroy)\n        top.bind('<Control-x>', self.destroy)\n        self._destroyed = False\n\n        self._column_vars = {}\n\n        # Initialize the GUI.\n        self._init_widgets()\n        self._init_menu()\n        try:\n            self._fill_table()\n        except HTTPError as e:\n            showerror('Error reading from server', e)\n        except URLError as e:\n            showerror('Error connecting to server', e.reason)\n\n        self._show_info()\n        self._select_columns()\n        self._table.select(0)\n\n        # Make sure we get notified when we're destroyed, so we can\n        # cancel any download in progress.\n        self._table.bind('<Destroy>', self._destroy)\n\n    def _log(self, msg):\n        self._log_messages.append(\n            '%s %s%s' % (time.ctime(), ' | ' * self._log_indent, msg)\n        )\n\n    # /////////////////////////////////////////////////////////////////\n    # Internals\n    # /////////////////////////////////////////////////////////////////\n\n    def _init_widgets(self):\n        # Create the top-level frame structures\n        f1 = Frame(self.top, relief='raised', border=2, padx=8, pady=0)\n        f1.pack(sid='top', expand=True, fill='both')\n        f1.grid_rowconfigure(2, weight=1)\n        f1.grid_columnconfigure(0, weight=1)\n        Frame(f1, height=8).grid(column=0, row=0)  # spacer\n        tabframe = Frame(f1)\n        tabframe.grid(column=0, row=1, sticky='news')\n        tableframe = Frame(f1)\n        tableframe.grid(column=0, row=2, sticky='news')\n        buttonframe = Frame(f1)\n        buttonframe.grid(column=0, row=3, sticky='news')\n        Frame(f1, height=8).grid(column=0, row=4)  # spacer\n        infoframe = Frame(f1)\n        infoframe.grid(column=0, row=5, sticky='news')\n        Frame(f1, height=8).grid(column=0, row=6)  # spacer\n        progressframe = Frame(\n            self.top, padx=3, pady=3, background=self._BACKDROP_COLOR[1]\n        )\n        progressframe.pack(side='bottom', fill='x')\n        self.top['border'] = 0\n        self.top['highlightthickness'] = 0\n\n        # Create the tabs\n        self._tab_names = ['Collections', 'Corpora', 'Models', 'All Packages']\n        self._tabs = {}\n        for i, tab in enumerate(self._tab_names):\n            label = Label(tabframe, text=tab, font=self._TAB_FONT)\n            label.pack(side='left', padx=((i + 1) % 2) * 10)\n            label.bind('<Button-1>', self._select_tab)\n            self._tabs[tab.lower()] = label\n\n        # Create the table.\n        column_weights = [self.COLUMN_WEIGHTS.get(column, 1) for column in self.COLUMNS]\n        self._table = Table(\n            tableframe,\n            self.COLUMNS,\n            column_weights=column_weights,\n            highlightthickness=0,\n            listbox_height=16,\n            reprfunc=self._table_reprfunc,\n        )\n        self._table.columnconfig(0, foreground=self._MARK_COLOR[0])  # marked\n        for i, column in enumerate(self.COLUMNS):\n            width = self.COLUMN_WIDTHS.get(column, self.DEFAULT_COLUMN_WIDTH)\n            self._table.columnconfig(i, width=width)\n        self._table.pack(expand=True, fill='both')\n        self._table.focus()\n        self._table.bind_to_listboxes('<Double-Button-1>', self._download)\n        self._table.bind('<space>', self._table_mark)\n        self._table.bind('<Return>', self._download)\n        self._table.bind('<Left>', self._prev_tab)\n        self._table.bind('<Right>', self._next_tab)\n        self._table.bind('<Control-a>', self._mark_all)\n\n        # Create entry boxes for URL & download_dir\n        infoframe.grid_columnconfigure(1, weight=1)\n\n        info = [\n            ('url', 'Server Index:', self._set_url),\n            ('download_dir', 'Download Directory:', self._set_download_dir),\n        ]\n        self._info = {}\n        for (i, (key, label, callback)) in enumerate(info):\n            Label(infoframe, text=label).grid(column=0, row=i, sticky='e')\n            entry = Entry(\n                infoframe, font='courier', relief='groove', disabledforeground='black'\n            )\n            self._info[key] = (entry, callback)\n            entry.bind('<Return>', self._info_save)\n            entry.bind('<Button-1>', lambda e, key=key: self._info_edit(key))\n            entry.grid(column=1, row=i, sticky='ew')\n\n        # If the user edits url or download_dir, and then clicks outside\n        # the entry box, then save their results.\n        self.top.bind('<Button-1>', self._info_save)\n\n        # Create Download & Refresh buttons.\n        self._download_button = Button(\n            buttonframe, text='Download', command=self._download, width=8\n        )\n        self._download_button.pack(side='left')\n        self._refresh_button = Button(\n            buttonframe, text='Refresh', command=self._refresh, width=8\n        )\n        self._refresh_button.pack(side='right')\n\n        # Create Progress bar\n        self._progresslabel = Label(\n            progressframe,\n            text='',\n            foreground=self._BACKDROP_COLOR[0],\n            background=self._BACKDROP_COLOR[1],\n        )\n        self._progressbar = Canvas(\n            progressframe,\n            width=200,\n            height=16,\n            background=self._PROGRESS_COLOR[1],\n            relief='sunken',\n            border=1,\n        )\n        self._init_progressbar()\n        self._progressbar.pack(side='right')\n        self._progresslabel.pack(side='left')\n\n    def _init_menu(self):\n        menubar = Menu(self.top)\n\n        filemenu = Menu(menubar, tearoff=0)\n        filemenu.add_command(\n            label='Download', underline=0, command=self._download, accelerator='Return'\n        )\n        filemenu.add_separator()\n        filemenu.add_command(\n            label='Change Server Index',\n            underline=7,\n            command=lambda: self._info_edit('url'),\n        )\n        filemenu.add_command(\n            label='Change Download Directory',\n            underline=0,\n            command=lambda: self._info_edit('download_dir'),\n        )\n        filemenu.add_separator()\n        filemenu.add_command(label='Show Log', underline=5, command=self._show_log)\n        filemenu.add_separator()\n        filemenu.add_command(\n            label='Exit', underline=1, command=self.destroy, accelerator='Ctrl-x'\n        )\n        menubar.add_cascade(label='File', underline=0, menu=filemenu)\n\n        # Create a menu to control which columns of the table are\n        # shown.  n.b.: we never hide the first two columns (mark and\n        # identifier).\n        viewmenu = Menu(menubar, tearoff=0)\n        for column in self._table.column_names[2:]:\n            var = IntVar(self.top)\n            assert column not in self._column_vars\n            self._column_vars[column] = var\n            if column in self.INITIAL_COLUMNS:\n                var.set(1)\n            viewmenu.add_checkbutton(\n                label=column, underline=0, variable=var, command=self._select_columns\n            )\n        menubar.add_cascade(label='View', underline=0, menu=viewmenu)\n\n        # Create a sort menu\n        # [xx] this should be selectbuttons; and it should include\n        # reversed sorts as options.\n        sortmenu = Menu(menubar, tearoff=0)\n        for column in self._table.column_names[1:]:\n            sortmenu.add_command(\n                label='Sort by %s' % column,\n                command=(lambda c=column: self._table.sort_by(c, 'ascending')),\n            )\n        sortmenu.add_separator()\n        # sortmenu.add_command(label='Descending Sort:')\n        for column in self._table.column_names[1:]:\n            sortmenu.add_command(\n                label='Reverse sort by %s' % column,\n                command=(lambda c=column: self._table.sort_by(c, 'descending')),\n            )\n        menubar.add_cascade(label='Sort', underline=0, menu=sortmenu)\n\n        helpmenu = Menu(menubar, tearoff=0)\n        helpmenu.add_command(label='About', underline=0, command=self.about)\n        helpmenu.add_command(\n            label='Instructions', underline=0, command=self.help, accelerator='F1'\n        )\n        menubar.add_cascade(label='Help', underline=0, menu=helpmenu)\n        self.top.bind('<F1>', self.help)\n\n        self.top.config(menu=menubar)\n\n    def _select_columns(self):\n        for (column, var) in self._column_vars.items():\n            if var.get():\n                self._table.show_column(column)\n            else:\n                self._table.hide_column(column)\n\n    def _refresh(self):\n        self._ds.clear_status_cache()\n        try:\n            self._fill_table()\n        except HTTPError as e:\n            showerror('Error reading from server', e)\n        except URLError as e:\n            showerror('Error connecting to server', e.reason)\n        self._table.select(0)\n\n    def _info_edit(self, info_key):\n        self._info_save()  # just in case.\n        (entry, callback) = self._info[info_key]\n        entry['state'] = 'normal'\n        entry['relief'] = 'sunken'\n        entry.focus()\n\n    def _info_save(self, e=None):\n        focus = self._table\n        for entry, callback in self._info.values():\n            if entry['state'] == 'disabled':\n                continue\n            if e is not None and e.widget is entry and e.keysym != 'Return':\n                focus = entry\n            else:\n                entry['state'] = 'disabled'\n                entry['relief'] = 'groove'\n                callback(entry.get())\n        focus.focus()\n\n    def _table_reprfunc(self, row, col, val):\n        if self._table.column_names[col].endswith('Size'):\n            if isinstance(val, string_types):\n                return '  %s' % val\n            elif val < 1024 ** 2:\n                return '  %.1f KB' % (val / 1024.0 ** 1)\n            elif val < 1024 ** 3:\n                return '  %.1f MB' % (val / 1024.0 ** 2)\n            else:\n                return '  %.1f GB' % (val / 1024.0 ** 3)\n\n        if col in (0, ''):\n            return str(val)\n        else:\n            return '  %s' % val\n\n    def _set_url(self, url):\n        if url == self._ds.url:\n            return\n        try:\n            self._ds.url = url\n            self._fill_table()\n        except IOError as e:\n            showerror('Error Setting Server Index', str(e))\n        self._show_info()\n\n    def _set_download_dir(self, download_dir):\n        if self._ds.download_dir == download_dir:\n            return\n        # check if the dir exists, and if not, ask if we should create it?\n\n        # Clear our status cache, & re-check what's installed\n        self._ds.download_dir = download_dir\n        try:\n            self._fill_table()\n        except HTTPError as e:\n            showerror('Error reading from server', e)\n        except URLError as e:\n            showerror('Error connecting to server', e.reason)\n        self._show_info()\n\n    def _show_info(self):\n        print('showing info', self._ds.url)\n        for entry, cb in self._info.values():\n            entry['state'] = 'normal'\n            entry.delete(0, 'end')\n        self._info['url'][0].insert(0, self._ds.url)\n        self._info['download_dir'][0].insert(0, self._ds.download_dir)\n        for entry, cb in self._info.values():\n            entry['state'] = 'disabled'\n\n    def _prev_tab(self, *e):\n        for i, tab in enumerate(self._tab_names):\n            if tab.lower() == self._tab and i > 0:\n                self._tab = self._tab_names[i - 1].lower()\n                try:\n                    return self._fill_table()\n                except HTTPError as e:\n                    showerror('Error reading from server', e)\n                except URLError as e:\n                    showerror('Error connecting to server', e.reason)\n\n    def _next_tab(self, *e):\n        for i, tab in enumerate(self._tab_names):\n            if tab.lower() == self._tab and i < (len(self._tabs) - 1):\n                self._tab = self._tab_names[i + 1].lower()\n                try:\n                    return self._fill_table()\n                except HTTPError as e:\n                    showerror('Error reading from server', e)\n                except URLError as e:\n                    showerror('Error connecting to server', e.reason)\n\n    def _select_tab(self, event):\n        self._tab = event.widget['text'].lower()\n        try:\n            self._fill_table()\n        except HTTPError as e:\n            showerror('Error reading from server', e)\n        except URLError as e:\n            showerror('Error connecting to server', e.reason)\n\n    _tab = 'collections'\n    # _tab = 'corpora'\n    _rows = None\n\n    def _fill_table(self):\n        selected_row = self._table.selected_row()\n        self._table.clear()\n        if self._tab == 'all packages':\n            items = self._ds.packages()\n        elif self._tab == 'corpora':\n            items = self._ds.corpora()\n        elif self._tab == 'models':\n            items = self._ds.models()\n        elif self._tab == 'collections':\n            items = self._ds.collections()\n        else:\n            assert 0, 'bad tab value %r' % self._tab\n        rows = [self._package_to_columns(item) for item in items]\n        self._table.extend(rows)\n\n        # Highlight the active tab.\n        for tab, label in self._tabs.items():\n            if tab == self._tab:\n                label.configure(\n                    foreground=self._FRONT_TAB_COLOR[0],\n                    background=self._FRONT_TAB_COLOR[1],\n                )\n            else:\n                label.configure(\n                    foreground=self._BACK_TAB_COLOR[0],\n                    background=self._BACK_TAB_COLOR[1],\n                )\n\n        self._table.sort_by('Identifier', order='ascending')\n        self._color_table()\n        self._table.select(selected_row)\n\n        # This is a hack, because the scrollbar isn't updating its\n        # position right -- I'm not sure what the underlying cause is\n        # though.  (This is on OS X w/ python 2.5)  The length of\n        # delay that's necessary seems to depend on how fast the\n        # comptuer is. :-/\n        self.top.after(150, self._table._scrollbar.set, *self._table._mlb.yview())\n        self.top.after(300, self._table._scrollbar.set, *self._table._mlb.yview())\n\n    def _update_table_status(self):\n        for row_num in range(len(self._table)):\n            status = self._ds.status(self._table[row_num, 'Identifier'])\n            self._table[row_num, 'Status'] = status\n        self._color_table()\n\n    def _download(self, *e):\n        # If we're using threads, then delegate to the threaded\n        # downloader instead.\n        if self._use_threads:\n            return self._download_threaded(*e)\n\n        marked = [\n            self._table[row, 'Identifier']\n            for row in range(len(self._table))\n            if self._table[row, 0] != ''\n        ]\n        selection = self._table.selected_row()\n        if not marked and selection is not None:\n            marked = [self._table[selection, 'Identifier']]\n\n        download_iter = self._ds.incr_download(marked, self._ds.download_dir)\n        self._log_indent = 0\n        self._download_cb(download_iter, marked)\n\n    _DL_DELAY = 10\n\n    def _download_cb(self, download_iter, ids):\n        try:\n            msg = next(download_iter)\n        except StopIteration:\n            # self._fill_table(sort=False)\n            self._update_table_status()\n            afterid = self.top.after(10, self._show_progress, 0)\n            self._afterid['_download_cb'] = afterid\n            return\n\n        def show(s):\n            self._progresslabel['text'] = s\n            self._log(s)\n\n        if isinstance(msg, ProgressMessage):\n            self._show_progress(msg.progress)\n        elif isinstance(msg, ErrorMessage):\n            show(msg.message)\n            if msg.package is not None:\n                self._select(msg.package.id)\n            self._show_progress(None)\n            return  # halt progress.\n        elif isinstance(msg, StartCollectionMessage):\n            show('Downloading collection %s' % msg.collection.id)\n            self._log_indent += 1\n        elif isinstance(msg, StartPackageMessage):\n            show('Downloading package %s' % msg.package.id)\n        elif isinstance(msg, UpToDateMessage):\n            show('Package %s is up-to-date!' % msg.package.id)\n        # elif isinstance(msg, StaleMessage):\n        #    show('Package %s is out-of-date or corrupt' % msg.package.id)\n        elif isinstance(msg, FinishDownloadMessage):\n            show('Finished downloading %r.' % msg.package.id)\n        elif isinstance(msg, StartUnzipMessage):\n            show('Unzipping %s' % msg.package.filename)\n        elif isinstance(msg, FinishCollectionMessage):\n            self._log_indent -= 1\n            show('Finished downloading collection %r.' % msg.collection.id)\n            self._clear_mark(msg.collection.id)\n        elif isinstance(msg, FinishPackageMessage):\n            self._clear_mark(msg.package.id)\n        afterid = self.top.after(self._DL_DELAY, self._download_cb, download_iter, ids)\n        self._afterid['_download_cb'] = afterid\n\n    def _select(self, id):\n        for row in range(len(self._table)):\n            if self._table[row, 'Identifier'] == id:\n                self._table.select(row)\n                return\n\n    def _color_table(self):\n        # Color rows according to status.\n        for row in range(len(self._table)):\n            bg, sbg = self._ROW_COLOR[self._table[row, 'Status']]\n            fg, sfg = ('black', 'white')\n            self._table.rowconfig(\n                row,\n                foreground=fg,\n                selectforeground=sfg,\n                background=bg,\n                selectbackground=sbg,\n            )\n            # Color the marked column\n            self._table.itemconfigure(\n                row, 0, foreground=self._MARK_COLOR[0], background=self._MARK_COLOR[1]\n            )\n\n    def _clear_mark(self, id):\n        for row in range(len(self._table)):\n            if self._table[row, 'Identifier'] == id:\n                self._table[row, 0] = ''\n\n    def _mark_all(self, *e):\n        for row in range(len(self._table)):\n            self._table[row, 0] = 'X'\n\n    def _table_mark(self, *e):\n        selection = self._table.selected_row()\n        if selection >= 0:\n            if self._table[selection][0] != '':\n                self._table[selection, 0] = ''\n            else:\n                self._table[selection, 0] = 'X'\n        self._table.select(delta=1)\n\n    def _show_log(self):\n        text = '\\n'.join(self._log_messages)\n        ShowText(self.top, 'NLTK Downloader Log', text)\n\n    def _package_to_columns(self, pkg):\n        \"\"\"\n        Given a package, return a list of values describing that\n        package, one for each column in ``self.COLUMNS``.\n        \"\"\"\n        row = []\n        for column_index, column_name in enumerate(self.COLUMNS):\n            if column_index == 0:  # Mark:\n                row.append('')\n            elif column_name == 'Identifier':\n                row.append(pkg.id)\n            elif column_name == 'Status':\n                row.append(self._ds.status(pkg))\n            else:\n                attr = column_name.lower().replace(' ', '_')\n                row.append(getattr(pkg, attr, 'n/a'))\n        return row\n\n    # /////////////////////////////////////////////////////////////////\n    # External Interface\n    # /////////////////////////////////////////////////////////////////\n\n    def destroy(self, *e):\n        if self._destroyed:\n            return\n        self.top.destroy()\n        self._destroyed = True\n\n    def _destroy(self, *e):\n        if self.top is not None:\n            for afterid in self._afterid.values():\n                self.top.after_cancel(afterid)\n\n        # Abort any download in progress.\n        if self._downloading and self._use_threads:\n            self._abort_download()\n\n        # Make sure the garbage collector destroys these now;\n        # otherwise, they may get destroyed when we're not in the main\n        # thread, which would make Tkinter unhappy.\n        self._column_vars.clear()\n\n    def mainloop(self, *args, **kwargs):\n        self.top.mainloop(*args, **kwargs)\n\n    # /////////////////////////////////////////////////////////////////\n    # HELP\n    # /////////////////////////////////////////////////////////////////\n\n    HELP = textwrap.dedent(\n        \"\"\"\\\n    This tool can be used to download a variety of corpora and models\n    that can be used with NLTK.  Each corpus or model is distributed\n    in a single zip file, known as a \\\"package file.\\\"  You can\n    download packages individually, or you can download pre-defined\n    collections of packages.\n\n    When you download a package, it will be saved to the \\\"download\n    directory.\\\"  A default download directory is chosen when you run\n\n    the downloader; but you may also select a different download\n    directory.  On Windows, the default download directory is\n\n\n    \\\"package.\\\"\n\n    The NLTK downloader can be used to download a variety of corpora,\n    models, and other data packages.\n\n    Keyboard shortcuts::\n      [return]\\t Download\n      [up]\\t Select previous package\n      [down]\\t Select next package\n      [left]\\t Select previous tab\n      [right]\\t Select next tab\n    \"\"\"\n    )\n\n    def help(self, *e):\n        # The default font's not very legible; try using 'fixed' instead.\n        try:\n            ShowText(\n                self.top,\n                'Help: NLTK Dowloader',\n                self.HELP.strip(),\n                width=75,\n                font='fixed',\n            )\n        except:\n            ShowText(self.top, 'Help: NLTK Downloader', self.HELP.strip(), width=75)\n\n    def about(self, *e):\n        ABOUT = \"NLTK Downloader\\n\" + \"Written by Edward Loper\"\n        TITLE = 'About: NLTK Downloader'\n        try:\n            from six.moves.tkinter_messagebox import Message\n\n            Message(message=ABOUT, title=TITLE).show()\n        except ImportError:\n            ShowText(self.top, TITLE, ABOUT)\n\n    # /////////////////////////////////////////////////////////////////\n    # Progress Bar\n    # /////////////////////////////////////////////////////////////////\n\n    _gradient_width = 5\n\n    def _init_progressbar(self):\n        c = self._progressbar\n        width, height = int(c['width']), int(c['height'])\n        for i in range(0, (int(c['width']) * 2) // self._gradient_width):\n            c.create_line(\n                i * self._gradient_width + 20,\n                -20,\n                i * self._gradient_width - height - 20,\n                height + 20,\n                width=self._gradient_width,\n                fill='#%02x0000' % (80 + abs(i % 6 - 3) * 12),\n            )\n        c.addtag_all('gradient')\n        c.itemconfig('gradient', state='hidden')\n\n        # This is used to display progress\n        c.addtag_withtag(\n            'redbox', c.create_rectangle(0, 0, 0, 0, fill=self._PROGRESS_COLOR[0])\n        )\n\n    def _show_progress(self, percent):\n        c = self._progressbar\n        if percent is None:\n            c.coords('redbox', 0, 0, 0, 0)\n            c.itemconfig('gradient', state='hidden')\n        else:\n            width, height = int(c['width']), int(c['height'])\n            x = percent * int(width) // 100 + 1\n            c.coords('redbox', 0, 0, x, height + 1)\n\n    def _progress_alive(self):\n        c = self._progressbar\n        if not self._downloading:\n            c.itemconfig('gradient', state='hidden')\n        else:\n            c.itemconfig('gradient', state='normal')\n            x1, y1, x2, y2 = c.bbox('gradient')\n            if x1 <= -100:\n                c.move('gradient', (self._gradient_width * 6) - 4, 0)\n            else:\n                c.move('gradient', -4, 0)\n            afterid = self.top.after(200, self._progress_alive)\n            self._afterid['_progress_alive'] = afterid\n\n    # /////////////////////////////////////////////////////////////////\n    # Threaded downloader\n    # /////////////////////////////////////////////////////////////////\n\n    def _download_threaded(self, *e):\n        # If the user tries to start a new download while we're already\n        # downloading something, then abort the current download instead.\n        if self._downloading:\n            self._abort_download()\n            return\n\n        # Change the 'download' button to an 'abort' button.\n        self._download_button['text'] = 'Cancel'\n\n        marked = [\n            self._table[row, 'Identifier']\n            for row in range(len(self._table))\n            if self._table[row, 0] != ''\n        ]\n        selection = self._table.selected_row()\n        if not marked and selection is not None:\n            marked = [self._table[selection, 'Identifier']]\n\n        # Create a new data server object for the download operation,\n        # just in case the user modifies our data server during the\n        # download (e.g., clicking 'refresh' or editing the index url).\n        ds = Downloader(self._ds.url, self._ds.download_dir)\n\n        # Start downloading in a separate thread.\n        assert self._download_msg_queue == []\n        assert self._download_abort_queue == []\n        self._DownloadThread(\n            ds,\n            marked,\n            self._download_lock,\n            self._download_msg_queue,\n            self._download_abort_queue,\n        ).start()\n\n        # Monitor the download message queue & display its progress.\n        self._log_indent = 0\n        self._downloading = True\n        self._monitor_message_queue()\n\n        # Display an indication that we're still alive and well by\n        # cycling the progress bar.\n        self._progress_alive()\n\n    def _abort_download(self):\n        if self._downloading:\n            self._download_lock.acquire()\n            self._download_abort_queue.append('abort')\n            self._download_lock.release()\n\n    class _DownloadThread(threading.Thread):\n        def __init__(self, data_server, items, lock, message_queue, abort):\n            self.data_server = data_server\n            self.items = items\n            self.lock = lock\n            self.message_queue = message_queue\n            self.abort = abort\n            threading.Thread.__init__(self)\n\n        def run(self):\n            for msg in self.data_server.incr_download(self.items):\n                self.lock.acquire()\n                self.message_queue.append(msg)\n                # Check if we've been told to kill ourselves:\n                if self.abort:\n                    self.message_queue.append('aborted')\n                    self.lock.release()\n                    return\n                self.lock.release()\n            self.lock.acquire()\n            self.message_queue.append('finished')\n            self.lock.release()\n\n    _MONITOR_QUEUE_DELAY = 100\n\n    def _monitor_message_queue(self):\n        def show(s):\n            self._progresslabel['text'] = s\n            self._log(s)\n\n        # Try to acquire the lock; if it's busy, then just try again later.\n        if not self._download_lock.acquire():\n            return\n        for msg in self._download_msg_queue:\n\n            # Done downloading?\n            if msg == 'finished' or msg == 'aborted':\n                # self._fill_table(sort=False)\n                self._update_table_status()\n                self._downloading = False\n                self._download_button['text'] = 'Download'\n                del self._download_msg_queue[:]\n                del self._download_abort_queue[:]\n                self._download_lock.release()\n                if msg == 'aborted':\n                    show('Download aborted!')\n                    self._show_progress(None)\n                else:\n                    afterid = self.top.after(100, self._show_progress, None)\n                    self._afterid['_monitor_message_queue'] = afterid\n                return\n\n            # All other messages\n            elif isinstance(msg, ProgressMessage):\n                self._show_progress(msg.progress)\n            elif isinstance(msg, ErrorMessage):\n                show(msg.message)\n                if msg.package is not None:\n                    self._select(msg.package.id)\n                self._show_progress(None)\n                self._downloading = False\n                return  # halt progress.\n            elif isinstance(msg, StartCollectionMessage):\n                show('Downloading collection %r' % msg.collection.id)\n                self._log_indent += 1\n            elif isinstance(msg, StartPackageMessage):\n                self._ds.clear_status_cache(msg.package.id)\n                show('Downloading package %r' % msg.package.id)\n            elif isinstance(msg, UpToDateMessage):\n                show('Package %s is up-to-date!' % msg.package.id)\n            # elif isinstance(msg, StaleMessage):\n            #    show('Package %s is out-of-date or corrupt; updating it' %\n            #         msg.package.id)\n            elif isinstance(msg, FinishDownloadMessage):\n                show('Finished downloading %r.' % msg.package.id)\n            elif isinstance(msg, StartUnzipMessage):\n                show('Unzipping %s' % msg.package.filename)\n            elif isinstance(msg, FinishUnzipMessage):\n                show('Finished installing %s' % msg.package.id)\n            elif isinstance(msg, FinishCollectionMessage):\n                self._log_indent -= 1\n                show('Finished downloading collection %r.' % msg.collection.id)\n                self._clear_mark(msg.collection.id)\n            elif isinstance(msg, FinishPackageMessage):\n                self._update_table_status()\n                self._clear_mark(msg.package.id)\n\n        # Let the user know when we're aborting a download (but\n        # waiting for a good point to abort it, so we don't end up\n        # with a partially unzipped package or anything like that).\n        if self._download_abort_queue:\n            self._progresslabel['text'] = 'Aborting download...'\n\n        # Clear the message queue and then release the lock\n        del self._download_msg_queue[:]\n        self._download_lock.release()\n\n        # Check the queue again after MONITOR_QUEUE_DELAY msec.\n        afterid = self.top.after(self._MONITOR_QUEUE_DELAY, self._monitor_message_queue)\n        self._afterid['_monitor_message_queue'] = afterid\n\n\n######################################################################\n# Helper Functions\n######################################################################\n# [xx] It may make sense to move these to nltk.internals.\n\n\ndef md5_hexdigest(file):\n    \"\"\"\n    Calculate and return the MD5 checksum for a given file.\n    ``file`` may either be a filename or an open stream.\n    \"\"\"\n    if isinstance(file, string_types):\n        with open(file, 'rb') as infile:\n            return _md5_hexdigest(infile)\n    return _md5_hexdigest(file)\n\n\ndef _md5_hexdigest(fp):\n    md5_digest = md5()\n    while True:\n        block = fp.read(1024 * 16)  # 16k blocks\n        if not block:\n            break\n        md5_digest.update(block)\n    return md5_digest.hexdigest()\n\n\n# change this to periodically yield progress messages?\n# [xx] get rid of topdir parameter -- we should be checking\n# this when we build the index, anyway.\ndef unzip(filename, root, verbose=True):\n    \"\"\"\n    Extract the contents of the zip file ``filename`` into the\n    directory ``root``.\n    \"\"\"\n    for message in _unzip_iter(filename, root, verbose):\n        if isinstance(message, ErrorMessage):\n            raise Exception(message)\n\n\ndef _unzip_iter(filename, root, verbose=True):\n    if verbose:\n        sys.stdout.write('Unzipping %s' % os.path.split(filename)[1])\n        sys.stdout.flush()\n\n    try:\n        zf = zipfile.ZipFile(filename)\n    except zipfile.error as e:\n        yield ErrorMessage(filename, 'Error with downloaded zip file')\n        return\n    except Exception as e:\n        yield ErrorMessage(filename, e)\n        return\n\n    zf.extractall(root)\n\n    if verbose:\n        print()\n\n\n######################################################################\n# Index Builder\n######################################################################\n# This may move to a different file sometime.\n\n\ndef build_index(root, base_url):\n    \"\"\"\n    Create a new data.xml index file, by combining the xml description\n    files for various packages and collections.  ``root`` should be the\n    path to a directory containing the package xml and zip files; and\n    the collection xml files.  The ``root`` directory is expected to\n    have the following subdirectories::\n\n      root/\n        packages/ .................. subdirectory for packages\n          corpora/ ................. zip & xml files for corpora\n          grammars/ ................ zip & xml files for grammars\n          taggers/ ................. zip & xml files for taggers\n          tokenizers/ .............. zip & xml files for tokenizers\n          etc.\n        collections/ ............... xml files for collections\n\n    For each package, there should be two files: ``package.zip``\n    (where *package* is the package name)\n    which contains the package itself as a compressed zip file; and\n    ``package.xml``, which is an xml description of the package.  The\n    zipfile ``package.zip`` should expand to a single subdirectory\n    named ``package/``.  The base filename ``package`` must match\n    the identifier given in the package's xml file.\n\n    For each collection, there should be a single file ``collection.zip``\n    describing the collection, where *collection* is the name of the collection.\n\n    All identifiers (for both packages and collections) must be unique.\n    \"\"\"\n    # Find all packages.\n    packages = []\n    for pkg_xml, zf, subdir in _find_packages(os.path.join(root, 'packages')):\n        zipstat = os.stat(zf.filename)\n        url = '%s/%s/%s' % (base_url, subdir, os.path.split(zf.filename)[1])\n        unzipped_size = sum(zf_info.file_size for zf_info in zf.infolist())\n\n        # Fill in several fields of the package xml with calculated values.\n        pkg_xml.set('unzipped_size', '%s' % unzipped_size)\n        pkg_xml.set('size', '%s' % zipstat.st_size)\n        pkg_xml.set('checksum', '%s' % md5_hexdigest(zf.filename))\n        pkg_xml.set('subdir', subdir)\n        # pkg_xml.set('svn_revision', _svn_revision(zf.filename))\n        if not pkg_xml.get('url'):\n            pkg_xml.set('url', url)\n\n        # Record the package.\n        packages.append(pkg_xml)\n\n    # Find all collections\n    collections = list(_find_collections(os.path.join(root, 'collections')))\n\n    # Check that all UIDs are unique\n    uids = set()\n    for item in packages + collections:\n        if item.get('id') in uids:\n            raise ValueError('Duplicate UID: %s' % item.get('id'))\n        uids.add(item.get('id'))\n\n    # Put it all together\n    top_elt = ElementTree.Element('nltk_data')\n    top_elt.append(ElementTree.Element('packages'))\n    for package in packages:\n        top_elt[0].append(package)\n    top_elt.append(ElementTree.Element('collections'))\n    for collection in collections:\n        top_elt[1].append(collection)\n\n    _indent_xml(top_elt)\n    return top_elt\n\n\ndef _indent_xml(xml, prefix=''):\n    \"\"\"\n    Helper for ``build_index()``: Given an XML ``ElementTree``, modify it\n    (and its descendents) ``text`` and ``tail`` attributes to generate\n    an indented tree, where each nested element is indented by 2\n    spaces with respect to its parent.\n    \"\"\"\n    if len(xml) > 0:\n        xml.text = (xml.text or '').strip() + '\\n' + prefix + '  '\n        for child in xml:\n            _indent_xml(child, prefix + '  ')\n        for child in xml[:-1]:\n            child.tail = (child.tail or '').strip() + '\\n' + prefix + '  '\n        xml[-1].tail = (xml[-1].tail or '').strip() + '\\n' + prefix\n\n\ndef _check_package(pkg_xml, zipfilename, zf):\n    \"\"\"\n    Helper for ``build_index()``: Perform some checks to make sure that\n    the given package is consistent.\n    \"\"\"\n    # The filename must patch the id given in the XML file.\n    uid = os.path.splitext(os.path.split(zipfilename)[1])[0]\n    if pkg_xml.get('id') != uid:\n        raise ValueError(\n            'package identifier mismatch (%s vs %s)' % (pkg_xml.get('id'), uid)\n        )\n\n    # Zip file must expand to a subdir whose name matches uid.\n    if sum((name != uid and not name.startswith(uid + '/')) for name in zf.namelist()):\n        raise ValueError(\n            'Zipfile %s.zip does not expand to a single '\n            'subdirectory %s/' % (uid, uid)\n        )\n\n\n# update for git?\ndef _svn_revision(filename):\n    \"\"\"\n    Helper for ``build_index()``: Calculate the subversion revision\n    number for a given file (by using ``subprocess`` to run ``svn``).\n    \"\"\"\n    p = subprocess.Popen(\n        ['svn', 'status', '-v', filename],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n    )\n    (stdout, stderr) = p.communicate()\n    if p.returncode != 0 or stderr or not stdout:\n        raise ValueError(\n            'Error determining svn_revision for %s: %s'\n            % (os.path.split(filename)[1], textwrap.fill(stderr))\n        )\n    return stdout.split()[2]\n\n\ndef _find_collections(root):\n    \"\"\"\n    Helper for ``build_index()``: Yield a list of ElementTree.Element\n    objects, each holding the xml for a single package collection.\n    \"\"\"\n    packages = []\n    for dirname, subdirs, files in os.walk(root):\n        for filename in files:\n            if filename.endswith('.xml'):\n                xmlfile = os.path.join(dirname, filename)\n                yield ElementTree.parse(xmlfile).getroot()\n\n\ndef _find_packages(root):\n    \"\"\"\n    Helper for ``build_index()``: Yield a list of tuples\n    ``(pkg_xml, zf, subdir)``, where:\n      - ``pkg_xml`` is an ``ElementTree.Element`` holding the xml for a\n        package\n      - ``zf`` is a ``zipfile.ZipFile`` for the package's contents.\n      - ``subdir`` is the subdirectory (relative to ``root``) where\n        the package was found (e.g. 'corpora' or 'grammars').\n    \"\"\"\n    from nltk.corpus.reader.util import _path_from\n\n    # Find all packages.\n    packages = []\n    for dirname, subdirs, files in os.walk(root):\n        relpath = '/'.join(_path_from(root, dirname))\n        for filename in files:\n            if filename.endswith('.xml'):\n                xmlfilename = os.path.join(dirname, filename)\n                zipfilename = xmlfilename[:-4] + '.zip'\n                try:\n                    zf = zipfile.ZipFile(zipfilename)\n                except Exception as e:\n                    raise ValueError('Error reading file %r!\\n%s' % (zipfilename, e))\n                try:\n                    pkg_xml = ElementTree.parse(xmlfilename).getroot()\n                except Exception as e:\n                    raise ValueError('Error reading file %r!\\n%s' % (xmlfilename, e))\n\n                # Check that the UID matches the filename\n                uid = os.path.split(xmlfilename[:-4])[1]\n                if pkg_xml.get('id') != uid:\n                    raise ValueError(\n                        'package identifier mismatch (%s '\n                        'vs %s)' % (pkg_xml.get('id'), uid)\n                    )\n\n                # Check that the zipfile expands to a subdir whose\n                # name matches the uid.\n                if sum(\n                    (name != uid and not name.startswith(uid + '/'))\n                    for name in zf.namelist()\n                ):\n                    raise ValueError(\n                        'Zipfile %s.zip does not expand to a '\n                        'single subdirectory %s/' % (uid, uid)\n                    )\n\n                yield pkg_xml, zf, relpath\n        # Don't recurse into svn subdirectories:\n        try:\n            subdirs.remove('.svn')\n        except ValueError:\n            pass\n\n\n######################################################################\n# Main:\n######################################################################\n\n# There should be a command-line interface\n\n# Aliases\n_downloader = Downloader()\ndownload = _downloader.download\n\n\ndef download_shell():\n    DownloaderShell(_downloader).run()\n\n\ndef download_gui():\n    DownloaderGUI(_downloader).mainloop()\n\n\ndef update():\n    _downloader.update()\n\n\nif __name__ == '__main__':\n    from optparse import OptionParser\n\n    parser = OptionParser()\n    parser.add_option(\n        \"-d\",\n        \"--dir\",\n        dest=\"dir\",\n        help=\"download package to directory DIR\",\n        metavar=\"DIR\",\n    )\n    parser.add_option(\n        \"-q\",\n        \"--quiet\",\n        dest=\"quiet\",\n        action=\"store_true\",\n        default=False,\n        help=\"work quietly\",\n    )\n    parser.add_option(\n        \"-f\",\n        \"--force\",\n        dest=\"force\",\n        action=\"store_true\",\n        default=False,\n        help=\"download even if already installed\",\n    )\n    parser.add_option(\n        \"-e\",\n        \"--exit-on-error\",\n        dest=\"halt_on_error\",\n        action=\"store_true\",\n        default=False,\n        help=\"exit if an error occurs\",\n    )\n    parser.add_option(\n        \"-u\",\n        \"--url\",\n        dest=\"server_index_url\",\n        default=os.environ.get('NLTK_DOWNLOAD_URL'),\n        help=\"download server index url\",\n    )\n\n    (options, args) = parser.parse_args()\n\n    downloader = Downloader(server_index_url=options.server_index_url)\n\n    if args:\n        for pkg_id in args:\n            rv = downloader.download(\n                info_or_id=pkg_id,\n                download_dir=options.dir,\n                quiet=options.quiet,\n                force=options.force,\n                halt_on_error=options.halt_on_error,\n            )\n            if rv == False and options.halt_on_error:\n                break\n    else:\n        downloader.download(\n            download_dir=options.dir,\n            quiet=options.quiet,\n            force=options.force,\n            halt_on_error=options.halt_on_error,\n        )\n"], "filenames": ["nltk/downloader.py"], "buggy_code_start_loc": [2263], "buggy_code_end_loc": [2299], "fixing_code_start_loc": [2263], "fixing_code_end_loc": [2265], "type": "CWE-22", "message": "NLTK Downloader before 3.4.5 is vulnerable to a directory traversal, allowing attackers to write arbitrary files via a ../ (dot dot slash) in an NLTK package (ZIP archive) that is mishandled during extraction.", "other": {"cve": {"id": "CVE-2019-14751", "sourceIdentifier": "cve@mitre.org", "published": "2019-08-22T16:15:10.213", "lastModified": "2020-03-27T10:15:11.553", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "NLTK Downloader before 3.4.5 is vulnerable to a directory traversal, allowing attackers to write arbitrary files via a ../ (dot dot slash) in an NLTK package (ZIP archive) that is mishandled during extraction."}, {"lang": "es", "value": "NLTK Downloader versiones anteriores a 3.4.5, es vulnerable a un salto de directorio, lo que permite a atacantes escribir archivos arbitrarios por medio de un ../ (punto punto barra diagonal) en un paquete NLTK (archivo ZIP) que es manejado inapropiadamente durante la extracci\u00f3n."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nltk:nltk:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.4.5", "matchCriteriaId": "86190853-8334-4EF1-B8A2-7978636E7E2E"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-03/msg00054.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-04/msg00001.html", "source": "cve@mitre.org"}, {"url": "https://github.com/mssalvatore/CVE-2019-14751_PoC", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/nltk/nltk/blob/3.4.5/ChangeLog", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/nltk/nltk/commit/f59d7ed8df2e0e957f7f247fe218032abdbe9a10", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/QI4IJGLZQ5S7C5LNRNROHAO2P526XE3D/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZGZSSEJH7RHH3RBUEVWWYT75QU67J7SE/", "source": "cve@mitre.org"}, {"url": "https://salvatoresecurity.com/zip-slip-in-nltk-cve-2019-14751/", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nltk/nltk/commit/f59d7ed8df2e0e957f7f247fe218032abdbe9a10"}}