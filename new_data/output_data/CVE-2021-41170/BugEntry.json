{"buggy_code": ["<?php\n\n\nnamespace Neoan3\\Apps;\n\n\nclass Template\n{\n\n    /**\n     * @param $content\n     * @param $array\n     *\n     * @return mixed\n     */\n    static function embrace($content, $array)\n    {\n        $flatArray = self::flattenArray($array);\n        $templateFunctions = ['nFor', 'nIf'];\n        foreach ($templateFunctions as $function) {\n            $content = self::enforceEmbraceInAttributes(TemplateFunctions::$function($content, $array));\n        }\n        $saveOpening = preg_quote(TemplateFunctions::getDelimiters()[0]);\n        $saveClosing = preg_quote(TemplateFunctions::getDelimiters()[1]);\n        foreach ($flatArray as $flatKey => $value){\n            $flatKey = preg_replace('/[\\/\\.\\\\\\+\\*\\?\\[\\^\\]\\$\\(\\)\\{\\}\\=\\!\\<\\>\\|\\:\\-]/', \"\\\\\\\\$0\",$flatKey);\n            if(is_callable($value)){\n                TemplateFunctions::registerClosure($flatKey,$value);\n            } else {\n                $content = preg_replace(\"/$saveOpening\\s*$flatKey\\s*$saveClosing/\", $value, $content);\n                $content = TemplateFunctions::tryClosures($flatArray, $content, false);\n            }\n        }\n\n        return $content;\n    }\n\n    /**\n     * @param $content\n     * @param $array\n     *\n     * @return mixed\n     */\n    static function hardEmbrace($content, $array)\n    {\n        TemplateFunctions::setDelimiter('[[',']]');\n        return self::embrace($content, $array);\n    }\n\n    /**\n     * @param $content\n     * @param $array\n     *\n     * @return mixed\n     */\n    static function tEmbrace($content, $array)\n    {\n        return str_replace(array_map('self::tBraces', array_keys($array)), array_values($array), $content);\n    }\n\n    /**\n     * @param $location\n     * @param $array\n     *\n     * @return mixed\n     */\n    static function embraceFromFile($location, $array)\n    {\n        $appRoot = defined('path') ? path : dirname(dirname(dirname(__DIR__)));\n        $file = file_get_contents($appRoot . '/' . $location);\n        return self::embrace($file, $array);\n    }\n\n\n    /**\n     * @param $input\n     *\n     * @return string\n     */\n    private static function tBraces($input): string\n    {\n        return '<t>' . $input . '</t>';\n    }\n\n    /**\n     * @param $parentDoc\n     * @param $hitNode\n     * @param $stringContent\n     */\n    static function clone(\\DOMDocument $parentDoc, \\DOMElement $hitNode, string $stringContent)\n    {\n        $newDD = new \\DOMDocument();\n        @$newDD->loadHTML(\n            '<root>' . $stringContent . '</root>',\n            LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD | LIBXML_NOBLANKS\n        );\n        foreach ($newDD->firstChild->childNodes as $subNode) {\n            if ($subNode->hasChildNodes() > 0 && $subNode->childNodes->length > 0) {\n                $isNode = $parentDoc->importNode($subNode, true);\n                $hitNode->parentNode->appendChild($isNode);\n            }\n        }\n        $hitNode->parentNode->removeChild($hitNode);\n    }\n\n    /**\n     * @param $content\n     *\n     * @return string|string[]|null\n     */\n    private static function enforceEmbraceInAttributes($content)\n    {\n        return preg_replace('/=\"(.*)(%7B%7B)(.*)(%7D%7D)(.*)\"/', '=\"$1{{$3}}$5\"', $content);\n    }\n\n    /**\n     * @param \\DOMElement $domNode\n     *\n     * @return string\n     */\n    static function nodeStringify(\\DOMElement $domNode): string\n    {\n        $string = '<' . $domNode->tagName;\n        foreach ($domNode->attributes as $attribute) {\n            $string .= ' ' . $attribute->name . '=\"' . $attribute->value . '\"';\n        }\n        $string .= '>';\n        if ($domNode->hasChildNodes()) {\n            foreach ($domNode->childNodes as $node) {\n                $string .= $domNode->ownerDocument->saveHTML($node);\n            }\n        }\n        $string .= '</' . $domNode->tagName . '>';\n        return $string;\n    }\n\n    /**\n     * @param      $array\n     * @param bool $parentKey\n     *\n     * @return array\n     */\n    static function flattenArray($array, $parentKey = false): array\n    {\n        $answer = [];\n        foreach ($array as $key => $value) {\n            if ($parentKey) {\n                $key = $parentKey . '.' . $key;\n            }\n            if (!is_array($value)) {\n                $answer[$key] = $value;\n            } else {\n                $answer[$key] = 'Array';\n                $answer[$key.'.length'] = sizeof($value);\n                $answer = array_merge($answer, self::flattenArray($value, $key));\n            }\n        }\n        return $answer;\n    }\n}", "<?php\n\n\nnamespace Neoan3\\Apps;\n\n\n/**\n * Class TemplateFunctions\n * @package Neoan3\\Apps\n */\nclass TemplateFunctions\n{\n    /**\n     * @var array\n     */\n    private static array $registeredClosures = [];\n    /**\n     * @var string[]\n     */\n    private static array $registeredDelimiters = ['{{', '}}'];\n\n    /**\n     * @param $name\n     * @param $function\n     */\n    static function registerClosure($name, $function)\n    {\n        self::$registeredClosures[$name] = $function;\n    }\n\n    /**\n     * @param $opening\n     * @param $closing\n     */\n    static function setDelimiter($opening, $closing)\n    {\n        self::$registeredDelimiters = [$opening, $closing];\n    }\n\n    /**\n     * @return string[]\n     */\n    static function getDelimiters()\n    {\n        return self::$registeredDelimiters;\n    }\n\n    /**\n     * @param $substitutions\n     * @param $content\n     * @param bool $executePure\n     * @return string|string[]|null\n     */\n    static function tryClosures($substitutions, $content, $executePure = true)\n    {\n        foreach (self::$registeredClosures as $name => $closure) {\n            $content = self::executeClosure($content, $name, $closure, $substitutions, $executePure);\n        }\n        return $content;\n    }\n\n    /**\n     * @param $content\n     * @param $callBackName\n     * @param $closure\n     * @param $valueArray\n     * @param bool $pure\n     * @return string|string[]|null\n     */\n    static function executeClosure($content, $callBackName, $closure, $valueArray, $pure = true)\n    {\n        $pattern = self::retrieveClosurePattern($pure, $callBackName);\n        return  preg_replace_callback(\n            $pattern,\n            function ($hit) use ($closure, $valueArray) {\n                $params = explode(',', $hit[1]);\n                $finalsInputs = [];\n                $found = true;\n                foreach ($params as $param){\n                    if(!isset($valueArray[trim($param)])){\n                        $found = false;\n                    } else {\n                        $finalsInputs[] = $valueArray[trim($param)];\n                    }\n                }\n                if ($found) {\n                    return $closure(...$finalsInputs);\n                }\n                return $hit[0];\n            },\n            $content\n        );\n    }\n\n    /**\n     * @param $pure\n     * @param $closureName\n     * @return string\n     */\n    private static function retrieveClosurePattern($pure, $closureName)\n    {\n        $pattern = '/';\n        if (!$pure) {\n            $pattern .= preg_quote(self::$registeredDelimiters[0]) . \"\\s*\";\n        }\n        $pattern .= \"$closureName\\(([a-z0-9,\\.\\s]+)\\)\";\n        if (!$pure) {\n            $pattern .= \"\\s*\" . preg_quote(self::$registeredDelimiters[1]);\n        }\n        return $pattern . \"/i\";\n    }\n\n    /**\n     * @param \\DOMElement $hit\n     * @param $attribute\n     * @return array\n     */\n    private static function extractAttribute(\\DOMElement $hit, $attribute)\n    {\n        // extract attribute\n        $parts = explode(' ', $hit->getAttribute($attribute));\n        // clean up\n        foreach ($parts as $i => $part) {\n            if (empty(trim($part))) {\n                unset($parts[$i]);\n            }\n        }\n        $parts = array_values($parts);\n        // remove attribute\n        $hit->removeAttribute($attribute);\n        // while string\n        return ['template' => Template::nodeStringify($hit), 'parts' => $parts];\n    }\n\n    /**\n     * @param \\DOMDocument $domDocument\n     * @param \\DOMElement $hit\n     * @param array $paramArray\n     * @param array $parts\n     * @param string $template\n     * @return string\n     */\n    static private function subContentGeneration(\n        \\DOMDocument $domDocument,\n        \\DOMElement $hit,\n        array $paramArray,\n        array $parts,\n        string $template\n    ) {\n        $newContent = '';\n        if (isset($paramArray[$parts[0]]) && !empty($paramArray[$parts[0]])) {\n            $subArray = [];\n            foreach ($paramArray[$parts[0]] as $key => $value) {\n                if (isset($parts[4])) {\n                    $subArray[$parts[2]] = $key;\n                    $subArray[$parts[4]] = $value;\n                } else {\n                    $subArray[$parts[2]] = $value;\n                }\n\n                $momentary = self::tryClosures($subArray, $template, false);\n\n                $newContent .= Template::embrace($momentary, $subArray);\n            }\n\n            Template::clone($domDocument, $hit, $newContent);\n        }\n        return $newContent;\n    }\n\n    /**\n     * @param $content\n     * @param $array\n     *\n     * @return string|string[]|null\n     */\n    static function nFor($content, $array)\n    {\n        $doc = new \\DOMDocument();\n        @$doc->loadHTML($content, LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD);\n        $xPath = new \\DOMXPath($doc);\n        $hits = $xPath->query(\"//*[@n-for]\");\n        if ($hits->length < 1) {\n            return $content;\n        }\n        foreach ($hits as $hit) {\n            $extracted = self::extractAttribute($hit, 'n-for');\n            self::subContentGeneration($doc, $hit, $array, $extracted['parts'], $extracted['template']);\n        }\n        return $doc->saveHTML();\n    }\n\n    /**\n     * @param array $flatArray\n     * @param $expression\n     * @return bool|mixed\n     */\n    private static function evaluateTypedCondition(array $flatArray, $expression): bool\n    {\n        $bool = false;\n        foreach ($flatArray as $key => $value) {\n            $pattern = '/' . $key . '([^.]|$)/';\n            if (preg_match($pattern, $expression, $matches)) {\n\n                switch (gettype($flatArray[$key])) {\n                    case 'boolean':\n                        $expression = str_replace($key, $flatArray[$key] ? 'true' : 'false', $expression);\n                        break;\n                    case 'NULL':\n                        $expression = str_replace($key, 'false', $expression);\n                        break;\n                    case 'string':\n                        $expression = str_replace($key, '\"' . $flatArray[$key] . '\"', $expression);\n                        break;\n                    case 'object':\n                        $expression = self::executeClosure($expression, $key, $flatArray[$key], $flatArray);\n                        break;\n                    default:\n                        $expression = str_replace($key, $flatArray[$key], $expression);\n                        break;\n                }\n                $bool = eval(\"return $expression;\");\n            }\n        }\n        return $bool;\n    }\n\n    /**\n     * @param $content\n     * @param $array\n     *\n     * @return string\n     */\n    static function nIf($content, $array)\n    {\n        $doc = new \\DOMDocument();\n        @$doc->loadHTML($content, LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD);\n        $xPath = new \\DOMXPath($doc);\n        $hits = $xPath->query(\"//*[@n-if]\");\n        if ($hits->length < 1) {\n            return $content;\n        }\n\n        foreach ($hits as $hit) {\n            $expression = $hit->getAttribute('n-if');\n            $array = Template::flattenArray($array);\n            $bool = self::evaluateTypedCondition($array, $expression);\n\n            if (!$bool) {\n                $hit->parentNode->removeChild($hit);\n            } else {\n                $hit->removeAttribute('n-if');\n            }\n        }\n        return $doc->saveHTML();\n    }\n}", "{\n    \"name\": \"neoan3-apps/template\",\n    \"description\": \"neoan3 minimal template engine\",\n    \"version\": \"1.1.0\",\n    \"license\": \"MIT\",\n    \"autoload\": {\n        \"psr-4\": {\n            \"Neoan3\\\\Apps\\\\\": \"./\"\n        }\n\n    },\n    \"require\": {\n        \"ext-openssl\": \"*\",\n        \"ext-mbstring\": \"*\",\n        \"ext-json\": \"*\",\n        \"ext-dom\": \"*\",\n        \"ext-libxml\": \"*\"\n    },\n    \"require-dev\": {\n        \"phpunit/phpunit\": \"^9.5\"\n    }\n}\n\n", "<?php\n\n\nnamespace Neoan3\\Apps;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass TemplateTest extends TestCase\n{\n\n    static function setUpBeforeClass(): void\n    {\n        define('path', dirname(__FILE__));\n    }\n    public function setUp(): void\n    {\n        TemplateFunctions::setDelimiter('{{','}}');\n    }\n\n    public function testEmbrace()\n    {\n        $str = '<div>{{easy}}-{{deep.value}}</div>';\n        $sub = ['easy' => 'a', 'deep' => ['value' => 'b']];\n        $this->assertSame('<div>a-b</div>', Template::embrace($str, $sub));\n    }\n\n    public function testEmbraceSanitation()\n    {\n        $array = [\n            's/t' => 1, 's\\t' => 1, 's+t' => 1, 's-t' => 1, 's{t' => 1\n        ];\n        $template = '<p n-for=\"array as key => item\">{{item}}</p>';\n        $res = '';\n        foreach ($array as $item){\n            $res .= '<p>'. $item .'</p>';\n        }\n        $this->assertSame($res, trim(Template::embrace($template, ['array' =>$array])));\n    }\n\n    public function testFlattenArray()\n    {\n        $testArray = ['one' => ['some' => 'value'], 'two' => ['item1', 'item2']];\n        $shouldBe = [\n            'one' => 'Array',\n            'one.length' => 1,\n            'one.some' => 'value',\n            'two' => 'Array',\n            'two.length' => 2,\n            'two.0' => 'item1',\n            'two.1' => 'item2'\n        ];\n        $this->assertSame($shouldBe, Template::flattenArray($testArray));\n    }\n\n    public function testTEmbrace()\n    {\n        $str = 'any <t>how</t>';\n        $sub = ['how' => 'test'];\n        $this->assertSame('any test', Template::tEmbrace($str, $sub));\n    }\n\n    public function testHardEmbrace()\n    {\n        $str = 'any [[how]]';\n        $sub = ['how' => 'test'];\n        $this->assertSame('any test', Template::hardEmbrace($str, $sub));\n    }\n\n    public function testEmbraceFromFile()\n    {\n        $sub = ['easy' => 'a', 'deep' => ['value' => 'b']];\n        $t = Template::embraceFromFile('embrace.html', $sub);\n        $this->assertSame('<div>a-b</div>', trim($t));\n    }\n\n    public function testConditional()\n    {\n        $str = '<custom-ele n-if=\"testKey\">out</custom-ele>';\n        $sub = ['testKey' => false];\n        $this->assertEmpty(trim(Template::embrace($str, $sub)));\n        $sub['testKey'] = true;\n        $this->assertStringContainsString('custom-ele', Template::embrace($str, $sub));\n    }\n\n    public function testComplexEmbrace()\n    {\n        $array = ['items' => ['one', 'two'], 'sub' => [1, 2, 3], 'deeps' => ['one' => 1, 'two' => 2]];\n        $t = Template::embraceFromFile('embraceComplex.html', $array);\n        $this->assertStringContainsString('<li>1</li><li>2</li>', $t);\n        $this->assertIsString($t);\n    }\n\n    public function testNestedCondition()\n    {\n        $array = ['deeps' => [['number' => 1], ['number' => 2]]];\n        $t = Template::embraceFromFile('nestedCondition.html', $array);\n        $this->assertStringContainsString('exists', $t);\n        $this->assertStringNotContainsString('not', $t);\n    }\n\n    public function testEmbraceTypes()\n    {\n        $array = ['string' => 'String', 'number' => 2, 'boolean' => true, 'falseExpression' => false];\n        $t = Template::embraceFromFile('typeTest.html', $array);\n        $expectedResult = ['String', 'Boolean', 'yes'];\n        foreach ($expectedResult as $true) {\n            $this->assertStringContainsString($true, $t);\n        }\n        // cross-check\n        $this->assertStringNotContainsString('no', $t);\n    }\n\n    public function testCallback()\n    {\n        $array = [\n            'myFunc' => function ($x) {\n                return strtoupper($x);\n            },\n            'some' => 'value'\n        ];\n        $t = Template::embraceFromFile('callback.html', $array);\n\n        $this->assertStringContainsString('<p>VALUE</p>', $t);\n        $this->assertStringContainsString('<li>show me</li>', $t);\n    }\n    public function testNoCallback()\n    {\n        $array = [\n            'items' => ['one', 'two'],\n            'som' => 'value'\n        ];\n        TemplateFunctions::registerClosure('myFunc',function($x) {\n            return $x . '-shouldnt';\n        });\n        $t = Template::embraceFromFile('callback.html', $array);\n        $this->assertStringContainsString('myFunc(some)',$t);\n\n    }\n\n    public function testCallbackDeep()\n    {\n        $array = [\n            'items' => ['one', 'two'],\n            'some' => 'value'\n        ];\n        TemplateFunctions::registerClosure('deepFunc',function($input){\n            return $input . '!';\n        });\n        TemplateFunctions::registerClosure('myFunc',function ($x) {\n            return strtoupper($x);\n        });\n\n        $t = Template::embraceFromFile('callback.html', $array);\n        $this->assertStringContainsString('one!', $t);\n        $this->assertStringContainsString('VALUE', $t);\n\n    }\n\n    public function testCustomDelimiter()\n    {\n        $array = ['test' => '[value]'];\n        TemplateFunctions::setDelimiter('<!--','-->');\n        $t = Template::embraceFromFile('callback.html', $array);\n        $this->assertStringContainsString('[value]', $t);\n    }\n    public function testEvaluateTypedConditionNull()\n    {\n        $array = ['test' => null];\n        $t = Template::embrace('<p n-if=\"test === false\">some</p>', $array);\n        $this->assertStringContainsString('p>some', $t);\n    }\n}\n"], "fixing_code": ["<?php\n\n\nnamespace Neoan3\\Apps;\n\n\nclass Template\n{\n\n    /**\n     * @param $content\n     * @param $array\n     *\n     * @return mixed\n     */\n    static function embrace($content, $array)\n    {\n        $flatArray = self::flattenArray($array);\n        $templateFunctions = ['nFor', 'nIf'];\n        foreach ($templateFunctions as $function) {\n            $content = self::enforceEmbraceInAttributes(TemplateFunctions::$function($content, $array));\n        }\n        $saveOpening = preg_quote(TemplateFunctions::getDelimiters()[0]);\n        $saveClosing = preg_quote(TemplateFunctions::getDelimiters()[1]);\n        foreach ($flatArray as $flatKey => $value){\n            $flatKey = preg_replace('/[\\/\\.\\\\\\+\\*\\?\\[\\^\\]\\$\\(\\)\\{\\}\\=\\!\\<\\>\\|\\:\\-]/', \"\\\\\\\\$0\",$flatKey);\n            // PATCHED: direct function injection is not allowed anymore\n            $content = preg_replace(\"/$saveOpening\\s*$flatKey\\s*$saveClosing/\", $value, $content);\n            $content = TemplateFunctions::tryClosures($flatArray, $content, false);\n\n        }\n\n        return $content;\n    }\n\n    /**\n     * @param $content\n     * @param $array\n     *\n     * @return mixed\n     */\n    static function hardEmbrace($content, $array)\n    {\n        TemplateFunctions::setDelimiter('[[',']]');\n        return self::embrace($content, $array);\n    }\n\n    /**\n     * @param $content\n     * @param $array\n     *\n     * @return mixed\n     */\n    static function tEmbrace($content, $array)\n    {\n        return str_replace(array_map('self::tBraces', array_keys($array)), array_values($array), $content);\n    }\n\n    /**\n     * @param $location\n     * @param $array\n     *\n     * @return mixed\n     */\n    static function embraceFromFile($location, $array)\n    {\n        $appRoot = defined('path') ? path : dirname(dirname(dirname(__DIR__)));\n        $file = file_get_contents($appRoot . '/' . $location);\n        return self::embrace($file, $array);\n    }\n\n\n    /**\n     * @param $input\n     *\n     * @return string\n     */\n    private static function tBraces($input): string\n    {\n        return '<t>' . $input . '</t>';\n    }\n\n    /**\n     * @param $parentDoc\n     * @param $hitNode\n     * @param $stringContent\n     */\n    static function clone(\\DOMDocument $parentDoc, \\DOMElement $hitNode, string $stringContent)\n    {\n        $newDD = new \\DOMDocument();\n        @$newDD->loadHTML(\n            '<root>' . $stringContent . '</root>',\n            LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD | LIBXML_NOBLANKS\n        );\n        foreach ($newDD->firstChild->childNodes as $subNode) {\n            if ($subNode->hasChildNodes() > 0 && $subNode->childNodes->length > 0) {\n                $isNode = $parentDoc->importNode($subNode, true);\n                $hitNode->parentNode->appendChild($isNode);\n            }\n        }\n        $hitNode->parentNode->removeChild($hitNode);\n    }\n\n    /**\n     * @param $content\n     *\n     * @return string|string[]|null\n     */\n    private static function enforceEmbraceInAttributes($content)\n    {\n        return preg_replace('/=\"(.*)(%7B%7B)(.*)(%7D%7D)(.*)\"/', '=\"$1{{$3}}$5\"', $content);\n    }\n\n    /**\n     * @param \\DOMElement $domNode\n     *\n     * @return string\n     */\n    static function nodeStringify(\\DOMElement $domNode): string\n    {\n        $string = '<' . $domNode->tagName;\n        foreach ($domNode->attributes as $attribute) {\n            $string .= ' ' . $attribute->name . '=\"' . $attribute->value . '\"';\n        }\n        $string .= '>';\n        if ($domNode->hasChildNodes()) {\n            foreach ($domNode->childNodes as $node) {\n                $string .= $domNode->ownerDocument->saveHTML($node);\n            }\n        }\n        $string .= '</' . $domNode->tagName . '>';\n        return $string;\n    }\n\n    /**\n     * @param      $array\n     * @param bool $parentKey\n     *\n     * @return array\n     */\n    static function flattenArray($array, $parentKey = false): array\n    {\n        $answer = [];\n        foreach ($array as $key => $value) {\n            if ($parentKey) {\n                $key = $parentKey . '.' . $key;\n            }\n            if (!is_array($value)) {\n                $answer[$key] = $value;\n            } else {\n                $answer[$key] = 'Array';\n                $answer[$key.'.length'] = sizeof($value);\n                $answer = array_merge($answer, self::flattenArray($value, $key));\n            }\n        }\n        return $answer;\n    }\n}", "<?php\n\n\nnamespace Neoan3\\Apps;\n\n\n/**\n * Class TemplateFunctions\n * @package Neoan3\\Apps\n */\nclass TemplateFunctions\n{\n    /**\n     * @var array\n     */\n    private static array $registeredClosures = [];\n    /**\n     * @var string[]\n     */\n    private static array $registeredDelimiters = ['{{', '}}'];\n\n    /**\n     * @param $name\n     * @param $function\n     */\n    static function registerClosure($name, $function)\n    {\n        self::$registeredClosures[$name] = $function;\n    }\n\n    /**\n     * @param $opening\n     * @param $closing\n     */\n    static function setDelimiter($opening, $closing)\n    {\n        self::$registeredDelimiters = [$opening, $closing];\n    }\n\n    /**\n     * @return string[]\n     */\n    static function getDelimiters()\n    {\n        return self::$registeredDelimiters;\n    }\n\n    /**\n     * @param $substitutions\n     * @param $content\n     * @param bool $executePure\n     * @return string|string[]|null\n     */\n    static function tryClosures($substitutions, $content, $executePure = true)\n    {\n        foreach (self::$registeredClosures as $name => $closure) {\n            $content = self::executeClosure($content, $name, $closure, $substitutions, $executePure);\n        }\n        return $content;\n    }\n\n    /**\n     * @param $content\n     * @param $callBackName\n     * @param $closure\n     * @param $valueArray\n     * @param bool $pure\n     * @return string|string[]|null\n     */\n    static function executeClosure($content, $callBackName, $closure, $valueArray, $pure = true)\n    {\n        $pattern = self::retrieveClosurePattern($pure, $callBackName);\n        return  preg_replace_callback(\n            $pattern,\n            function ($hit) use ($closure, $valueArray) {\n                $params = explode(',', $hit[1]);\n                $finalsInputs = [];\n                $found = true;\n                foreach ($params as $param){\n                    if(!isset($valueArray[trim($param)])){\n                        $found = false;\n                    } else {\n                        $finalsInputs[] = $valueArray[trim($param)];\n                    }\n                }\n                if ($found) {\n                    return $closure(...$finalsInputs);\n                }\n                return $hit[0];\n            },\n            $content\n        );\n    }\n\n    /**\n     * @param $pure\n     * @param $closureName\n     * @return string\n     */\n    private static function retrieveClosurePattern($pure, $closureName)\n    {\n        $pattern = '/';\n        if (!$pure) {\n            $pattern .= preg_quote(self::$registeredDelimiters[0]) . \"\\s*\";\n        }\n        $pattern .= \"$closureName\\(([a-z0-9,\\.\\s_]+)\\)\";\n        if (!$pure) {\n            $pattern .= \"\\s*\" . preg_quote(self::$registeredDelimiters[1]);\n        }\n        return $pattern . \"/i\";\n    }\n\n    /**\n     * @param \\DOMElement $hit\n     * @param $attribute\n     * @return array\n     */\n    private static function extractAttribute(\\DOMElement $hit, $attribute)\n    {\n        // extract attribute\n        $parts = explode(' ', $hit->getAttribute($attribute));\n        // clean up\n        foreach ($parts as $i => $part) {\n            if (empty(trim($part))) {\n                unset($parts[$i]);\n            }\n        }\n        $parts = array_values($parts);\n        // remove attribute\n        $hit->removeAttribute($attribute);\n        // while string\n        return ['template' => Template::nodeStringify($hit), 'parts' => $parts];\n    }\n\n    /**\n     * @param \\DOMDocument $domDocument\n     * @param \\DOMElement $hit\n     * @param array $paramArray\n     * @param array $parts\n     * @param string $template\n     * @return string\n     */\n    static private function subContentGeneration(\n        \\DOMDocument $domDocument,\n        \\DOMElement $hit,\n        array $paramArray,\n        array $parts,\n        string $template\n    ) {\n        $newContent = '';\n        if (isset($paramArray[$parts[0]]) && !empty($paramArray[$parts[0]])) {\n            $subArray = [];\n            foreach ($paramArray[$parts[0]] as $key => $value) {\n                if (isset($parts[4])) {\n                    $subArray[$parts[2]] = $key;\n                    $subArray[$parts[4]] = $value;\n                } else {\n                    $subArray[$parts[2]] = $value;\n                }\n\n                $momentary = self::tryClosures($subArray, $template, false);\n\n                $newContent .= Template::embrace($momentary, $subArray);\n            }\n\n            Template::clone($domDocument, $hit, $newContent);\n        }\n        return $newContent;\n    }\n\n    /**\n     * @param $content\n     * @param $array\n     *\n     * @return string|string[]|null\n     */\n    static function nFor($content, $array)\n    {\n        $doc = new \\DOMDocument();\n        @$doc->loadHTML($content, LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD);\n        $xPath = new \\DOMXPath($doc);\n        $hits = $xPath->query(\"//*[@n-for]\");\n        if ($hits->length < 1) {\n            return $content;\n        }\n        foreach ($hits as $hit) {\n            $extracted = self::extractAttribute($hit, 'n-for');\n            self::subContentGeneration($doc, $hit, $array, $extracted['parts'], $extracted['template']);\n        }\n        return $doc->saveHTML();\n    }\n\n    /**\n     * @param array $flatArray\n     * @param $expression\n     * @return bool|mixed\n     */\n    private static function evaluateTypedCondition(array $flatArray, $expression): bool\n    {\n        $bool = false;\n        foreach ($flatArray as $key => $value) {\n            $pattern = '/' . $key . '([^.]|$)/';\n            if (preg_match($pattern, $expression, $matches)) {\n                switch (gettype($flatArray[$key])) {\n                    case 'boolean':\n                        $expression = str_replace($key, $flatArray[$key] ? 'true' : 'false', $expression);\n                        break;\n                    case 'NULL':\n                        $expression = str_replace($key, 'false', $expression);\n                        break;\n                    case 'string':\n                        $expression = str_replace($key, '\"' . $flatArray[$key] . '\"', $expression);\n                        break;\n                    case 'object':\n                        $expression = self::executeClosure($expression, $key, $flatArray[$key], $flatArray);\n                        break;\n                    default:\n                        $expression = str_replace($key, $flatArray[$key], $expression);\n                        break;\n                }\n                $bool = eval(\"return $expression;\");\n            }\n        }\n        return $bool;\n    }\n\n    /**\n     * @param $content\n     * @param $array\n     *\n     * @return string\n     */\n    static function nIf($content, $array)\n    {\n        $doc = new \\DOMDocument();\n        @$doc->loadHTML($content, LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD);\n        $xPath = new \\DOMXPath($doc);\n        $hits = $xPath->query(\"//*[@n-if]\");\n        if ($hits->length < 1) {\n            return $content;\n        }\n\n        $array = Template::flattenArray($array);\n        // important: first try closures\n        $array = array_merge(self::$registeredClosures, $array);\n        foreach ($hits as $hit) {\n            $expression = $hit->getAttribute('n-if');\n            $bool = self::evaluateTypedCondition($array, $expression);\n            if (!$bool) {\n                $hit->parentNode->removeChild($hit);\n            } else {\n                $hit->removeAttribute('n-if');\n            }\n        }\n        return $doc->saveHTML();\n    }\n}", "{\n    \"name\": \"neoan3-apps/template\",\n    \"description\": \"neoan3 minimal template engine\",\n    \"version\": \"1.1.1\",\n    \"license\": \"MIT\",\n    \"autoload\": {\n        \"psr-4\": {\n            \"Neoan3\\\\Apps\\\\\": \"./\"\n        }\n    },\n    \"require\": {\n        \"ext-openssl\": \"*\",\n        \"ext-mbstring\": \"*\",\n        \"ext-json\": \"*\",\n        \"ext-dom\": \"*\",\n        \"ext-libxml\": \"*\"\n    },\n    \"require-dev\": {\n        \"phpunit/phpunit\": \"^9.5\"\n    }\n}\n\n", "<?php\n\n\nnamespace Neoan3\\Apps;\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass TemplateTest extends TestCase\n{\n\n    static function setUpBeforeClass(): void\n    {\n        define('path', dirname(__FILE__));\n    }\n    public function setUp(): void\n    {\n        TemplateFunctions::setDelimiter('{{','}}');\n    }\n\n    public function testEmbrace()\n    {\n        $str = '<div>{{easy}}-{{deep.value}}</div>';\n        $sub = ['easy' => 'a', 'deep' => ['value' => 'b']];\n        $this->assertSame('<div>a-b</div>', Template::embrace($str, $sub));\n    }\n\n    public function testEmbraceSanitation()\n    {\n        $array = [\n            's/t' => 1, 's\\t' => 1, 's+t' => 1, 's-t' => 1, 's{t' => 1\n        ];\n        $template = '<p n-for=\"array as key => item\">{{item}}</p>';\n        $res = '';\n        foreach ($array as $item){\n            $res .= '<p>'. $item .'</p>';\n        }\n        $this->assertSame($res, trim(Template::embrace($template, ['array' =>$array])));\n    }\n\n    public function testFlattenArray()\n    {\n        $testArray = ['one' => ['some' => 'value'], 'two' => ['item1', 'item2']];\n        $shouldBe = [\n            'one' => 'Array',\n            'one.length' => 1,\n            'one.some' => 'value',\n            'two' => 'Array',\n            'two.length' => 2,\n            'two.0' => 'item1',\n            'two.1' => 'item2'\n        ];\n        $this->assertSame($shouldBe, Template::flattenArray($testArray));\n    }\n\n    public function testTEmbrace()\n    {\n        $str = 'any <t>how</t>';\n        $sub = ['how' => 'test'];\n        $this->assertSame('any test', Template::tEmbrace($str, $sub));\n    }\n\n    public function testHardEmbrace()\n    {\n        $str = 'any [[how]]';\n        $sub = ['how' => 'test'];\n        $this->assertSame('any test', Template::hardEmbrace($str, $sub));\n    }\n\n    public function testEmbraceFromFile()\n    {\n        $sub = ['easy' => 'a', 'deep' => ['value' => 'b']];\n        $t = Template::embraceFromFile('embrace.html', $sub);\n        $this->assertSame('<div>a-b</div>', trim($t));\n    }\n\n    public function testConditional()\n    {\n        $str = '<custom-ele n-if=\"testKey\">out</custom-ele>';\n        $sub = ['testKey' => false];\n        $this->assertEmpty(trim(Template::embrace($str, $sub)));\n        $sub['testKey'] = true;\n        $this->assertStringContainsString('custom-ele', Template::embrace($str, $sub));\n    }\n\n    public function testComplexEmbrace()\n    {\n        $array = ['items' => ['one', 'two'], 'sub' => [1, 2, 3], 'deeps' => ['one' => 1, 'two' => 2]];\n        $t = Template::embraceFromFile('embraceComplex.html', $array);\n        $this->assertStringContainsString('<li>1</li><li>2</li>', $t);\n        $this->assertIsString($t);\n    }\n\n    public function testNestedCondition()\n    {\n        $array = ['deeps' => [['number' => 1], ['number' => 2]]];\n        $t = Template::embraceFromFile('nestedCondition.html', $array);\n        $this->assertStringContainsString('exists', $t);\n        $this->assertStringNotContainsString('not', $t);\n    }\n\n    public function testEmbraceTypes()\n    {\n        $array = ['string' => 'String', 'number' => 2, 'boolean' => true, 'falseExpression' => false];\n        $t = Template::embraceFromFile('typeTest.html', $array);\n        $expectedResult = ['String', 'Boolean', 'yes'];\n        foreach ($expectedResult as $true) {\n            $this->assertStringContainsString($true, $t);\n        }\n        // cross-check\n        $this->assertStringNotContainsString('no', $t);\n    }\n\n    public function testCallback()\n    {\n        $array = [\n            'some' => 'value'\n        ];\n        TemplateFunctions::registerClosure('myFunc',function($x){\n            return strtoupper($x);\n        });\n        $t = Template::embraceFromFile('callback.html', $array);\n\n        $this->assertStringContainsString('<p>VALUE</p>', $t);\n        $this->assertStringContainsString('<li>show me</li>', $t);\n    }\n    public function testNoCallback()\n    {\n        $array = [\n            'items' => ['one', 'two'],\n            'som' => 'value'\n        ];\n        TemplateFunctions::registerClosure('myFunc',function($x) {\n            return $x . '-shouldnt';\n        });\n        $t = Template::embraceFromFile('callback.html', $array);\n        $this->assertStringContainsString('myFunc(some)',$t);\n\n    }\n\n    public function testCallbackDeep()\n    {\n        $array = [\n            'items' => ['one', 'two'],\n            'some' => 'value'\n        ];\n        TemplateFunctions::registerClosure('deepFunc',function($input){\n            return $input . '!';\n        });\n        TemplateFunctions::registerClosure('myFunc',function ($x) {\n            return strtoupper($x);\n        });\n\n        $t = Template::embraceFromFile('callback.html', $array);\n        $this->assertStringContainsString('one!', $t);\n        $this->assertStringContainsString('VALUE', $t);\n\n    }\n\n    public function testCustomDelimiter()\n    {\n        $array = ['test' => '[value]'];\n        TemplateFunctions::setDelimiter('<!--','-->');\n        $t = Template::embraceFromFile('callback.html', $array);\n        $this->assertStringContainsString('[value]', $t);\n    }\n    public function testEvaluateTypedConditionNull()\n    {\n        $array = ['test' => null];\n        $t = Template::embrace('<p n-if=\"test === false\">some</p>', $array);\n        $this->assertStringContainsString('p>some', $t);\n    }\n}\n"], "filenames": ["Template.php", "TemplateFunctions.php", "composer.json", "tests/TemplateTest.php"], "buggy_code_start_loc": [27, 106, 4, 116], "buggy_code_end_loc": [33, 249, 11, 120], "fixing_code_start_loc": [27, 106, 4, 115], "fixing_code_end_loc": [31, 248, 9, 121], "type": "CWE-277", "message": "neoan3-apps/template is a neoan3 minimal template engine. Versions prior to 1.1.1 have allowed for passing in closures directly into the template engine. As a result values that are callable are executed by the template engine. The issue arises if a value has the same name as a method or function in scope and can therefore be executed either by mistake or maliciously. In theory all users of the package are affected as long as they either deal with direct user input or database values. A multi-step attack on is therefore plausible. Version 1.1.1 has addressed this vulnerability. Unfortunately only working with hardcoded values is safe in prior versions. As this likely defeats the purpose of a template engine, please upgrade.", "other": {"cve": {"id": "CVE-2021-41170", "sourceIdentifier": "security-advisories@github.com", "published": "2021-11-08T19:15:07.640", "lastModified": "2021-11-17T13:16:25.040", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "neoan3-apps/template is a neoan3 minimal template engine. Versions prior to 1.1.1 have allowed for passing in closures directly into the template engine. As a result values that are callable are executed by the template engine. The issue arises if a value has the same name as a method or function in scope and can therefore be executed either by mistake or maliciously. In theory all users of the package are affected as long as they either deal with direct user input or database values. A multi-step attack on is therefore plausible. Version 1.1.1 has addressed this vulnerability. Unfortunately only working with hardcoded values is safe in prior versions. As this likely defeats the purpose of a template engine, please upgrade."}, {"lang": "es", "value": "neoan3-apps/template es un motor de plantillas m\u00ednimo de neoan3. Las versiones anteriores a la 1.1.1 han permitido pasar cierres directamente al motor de plantillas. Como resultado, los valores que son invocables son ejecutados por el motor de plantillas. El problema surge si un valor tiene el mismo nombre que un m\u00e9todo o funci\u00f3n en el \u00e1mbito y, por lo tanto, puede ser ejecutado por error o maliciosamente. En teor\u00eda, todos los usuarios del paquete se ven afectados siempre y cuando traten con entradas directas del usuario o con valores de la base de datos. Por lo tanto, es plausible un ataque en varios pasos. La versi\u00f3n 1.1.1 ha solucionado esta vulnerabilidad. Lamentablemente, en las versiones anteriores s\u00f3lo es seguro trabajar con valores codificados. Dado que esto probablemente anula el prop\u00f3sito de un motor de plantillas, por favor, actualice"}], "metrics": {"cvssMetricV31": [{"source": "security-advisories@github.com", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "nvd@nist.gov", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-277"}, {"lang": "en", "value": "CWE-74"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-732"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:neoan:neoan3-template:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.1", "matchCriteriaId": "70999503-021D-444B-95AD-548CE2C0E680"}]}]}], "references": [{"url": "https://github.com/sroehrl/neoan3-template/commit/4a2c9570f071d3c8f4ac790007599cba20e16934", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sroehrl/neoan3-template/issues/8", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/sroehrl/neoan3-template/security/advisories/GHSA-3v56-q6r6-4gcw", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sroehrl/neoan3-template/commit/4a2c9570f071d3c8f4ac790007599cba20e16934"}}