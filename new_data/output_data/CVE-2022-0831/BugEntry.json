{"buggy_code": ["\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n * @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\npimcore.registerNS(\"pimcore.element.properties\");\npimcore.element.properties = Class.create({\n\n    disallowedKeys: [],\n\n    initialize: function(element, type) {\n        this.element = element;\n        this.type = type;\n\n        this.definedFieldTypes = {};\n    },\n\n    getLayout: function () {\n\n        if (this.layout == null) {\n\n            var predefinedPropertiesStore = new Ext.data.Store({\n                fields: [\n                    \"id\",\"name\",\"description\",\"key\",\"type\",\"data\",\"config\",\"inheritable\",\n                    {\n                        name:\"translatedName\",\n                        convert: function(v, rec){\n                            return t(rec.data.name);\n                        },\n                        depends : ['name']\n                    }\n                ],\n                proxy: {\n                    type: 'ajax',\n                    url: Routing.generate('pimcore_admin_element_getpredefinedproperties', {elementType: this.type}),\n                    reader: {\n                        type: 'json',\n                        rootProperty: \"properties\"\n                    }\n                },\n                sorters: [{\n                    property: 'translatedName',\n                    direction: 'ASC'\n                }],\n            });\n\n            var predefinedcombo = new Ext.form.ComboBox({\n                name: \"type\",\n                displayField:'translatedName',\n                valueField: \"id\",\n                store: predefinedPropertiesStore,\n                triggerAction: 'all',\n                listWidth: 300,\n                width: 250,\n                emptyText: t(\"predefined_properties\"),\n                listClass: \"pimcore_predefined_property_select\",\n                listeners: [{\n                    select: this.addSetFromPredefined.bind(this, predefinedPropertiesStore)\n                }]\n            });\n\n            var propertyTypes = new Ext.data.ArrayStore({\n                fields: ['id', 'name'],\n                data: [\n                    [\"text\", \"Text\"],\n                    [\"document\", \"Document\"],\n                    [\"asset\", \"Asset\"],\n                    [\"object\", \"Object\"],\n                    [\"bool\", \"Checkbox\"]\n                ]\n            });\n\n            var customKey = new Ext.form.TextField({\n                name: 'key',\n                emptyText: t('key')\n            });\n\n            var customType = new Ext.form.ComboBox({\n                name: \"type\",\n                valueField: \"id\",\n                displayField:'name',\n                store: propertyTypes,\n                editable: false,\n                triggerAction: 'all',\n                mode: \"local\",\n                listWidth: 200,\n                emptyText: t('type')\n            });\n\n            // prepare store data\n            var property = null;\n            var keys = Object.keys(this.element.data.properties);\n            var key = null;\n            var storeData = [];\n\n            if (keys.length > 0) {\n                for (var i = 0; i < keys.length; i++) {\n                    key = keys[i];\n                    property = this.element.data.properties[key];\n\n                    if (property && typeof property == \"object\") {\n                        storeData.push({\n                            name: property.name,\n                            type: property.type,\n                            data: property.data,\n                            inherited: property.inherited,\n                            inheritable: property.inheritable,\n                            all: property,\n                            config: property.config,\n                            description: property.description\n                        });\n                    }\n                }\n            }\n\n            var store = new Ext.data.Store({\n                autoDestroy: true,\n                data: {properties: storeData},\n                sortInfo:{field: 'inherited', direction: \"ASC\"},\n                proxy: {\n                    type: 'memory',\n                    reader: {\n                        type: 'json',\n                        rootProperty: 'properties'\n                    }\n                },\n                fields: ['name','description','type',{name: \"data\", type: \"string\", convert: function (v, rec) {\n                    if (rec.data.type == \"document\" || rec.data.type == \"asset\" || rec.data.type == \"object\") {\n                        var type = rec.data.type;\n                        if (type == \"document\") {\n                            if (v && typeof v == \"object\") {\n                                return v.path + v.key;\n                            }\n                        }\n                        else if (type == \"asset\") {\n                            if (v && typeof v == \"object\") {\n                                return v.path + v.filename;\n                            }\n                        }\n                        else if (type == \"object\") {\n                            if (v && typeof v == \"object\") {\n                                return v.o_path + v.o_key;\n                            }\n                        }\n\n                    }\n\n                    return v;\n                }},\"inherited\",\"all\",{name: 'inheritable', type: 'bool', mapping: \"inheritable\"}, \"config\"],\n                groupField: 'inherited',\n                filters: [\n                    function(item) {\n                        if(in_array(item.get(\"name\"), this.disallowedKeys)) {\n                            return false;\n                        }\n                        return true;\n                    }.bind(this)\n                ]\n            });\n\n            var checkColumn = Ext.create('Ext.grid.column.Check', {\n                text: t(\"inheritable\"),\n                dataIndex: 'inheritable',\n                listeners: {\n                    beforecheckchange: function (el, rowIndex, checked, eOpts) {\n                        if(store.getAt(rowIndex).get(\"inherited\")) {\n                            return false;\n                        }\n\n                        return true;\n                    }\n                }\n            });\n\n            this.cellEditing = Ext.create('Ext.grid.plugin.CellEditing', {\n                clicksToEdit: 1,\n                listeners: {\n                    beforeedit: function(editor, context, eOpts) {\n                        //need to clear cached editors of cell-editing editor in order to\n                        //enable different editors per row\n                        editor.editors.each(function (e) {\n                            try {\n                                // complete edit, so the value is stored when hopping around with TAB\n                                e.completeEdit();\n                                Ext.destroy(e);\n                            } catch (exception) {\n                                // garbage collector was faster\n                                // already destroyed\n                            }\n                        });\n\n                        editor.editors.clear();\n\n                        if(context.record.get(\"inherited\")) {\n                            return false;\n                        }\n                    }\n                }\n            });\n\n            this.propertyGrid = Ext.create('Ext.grid.Panel', {\n                autoScroll: true,\n                region: \"center\",\n                //reference: this,\n                sm:  Ext.create('Ext.selection.RowModel', {}),\n                bufferedRenderer: false,\n                trackMouseOver: true,\n                store: store,\n                bodyCls: \"pimcore_editable_grid\",\n                plugins: [\n                    this.cellEditing\n                ],\n                tbar: [predefinedcombo,\"-\",{\n                    xtype: \"tbtext\",\n                    text: t('add_a_custom_property') + \" \"\n                },\n                customKey,\n                customType, {\n                    xtype: \"button\",\n                    handler: this.addSetFromUserDefined.bind(this, customKey, customType),\n                    iconCls: \"pimcore_icon_add\"\n                }],\n                //plugins: checkColumn,\n                clicksToEdit: 1,\n                features: [\n                    Ext.create('Ext.grid.feature.Grouping', {\n                        listeners: {\n                            rowupdated: this.updateRows.bind(this, \"rowupdated\"),\n                            refresh: this.updateRows.bind(this, \"refresh\")\n                        }\n                    })\n                ],\n                autoExpandColumn: \"property_value_col\",\n                columnLines: true,\n                stripeRows: true,\n                columns: [\n                    {\n                        text: t(\"type\"),\n                        dataIndex: 'type',\n                        editable: false,\n                        width: 40,\n                        renderer: this.getTypeRenderer.bind(this),\n                        sortable: true\n                    },\n                    {\n                        text: t('inherited'),\n                        dataIndex: 'inherited',\n                        editable: false,\n                        hidden: true,\n                        sortable: true\n                    },\n                    {\n                        text: t(\"key\"),\n                        dataIndex: 'name',\n                        getEditor: function() {\n                            return new Ext.form.TextField({\n                                allowBlank: false\n                            });\n                        },\n                        sortable: true,\n                        renderer: Ext.util.Format.htmlEncode,\n                        width: 230\n                    },\n                    {\n                        text: t(\"description\"),\n                        dataIndex: 'description',\n                        editable: false,\n                        sortable: true,\n                        renderer: Ext.util.Format.htmlEncode,\n                        width: 230\n                    },\n                    {\n                        text: t(\"value\"),\n                        dataIndex: 'data',\n                        flex: 1,\n                        getEditor: this.getCellEditor.bind(this),\n                        editable: true,\n                        renderer: this.getCellRenderer.bind(this),\n                        listeners: {\n                            \"mousedown\": this.cellMousedown.bind(this)\n                        }\n                    },\n                    checkColumn,\n                    {\n                        xtype: 'actioncolumn',\n                        menuText: t('open'),\n                        width: 40,\n                        items: [{\n                            tooltip: t('open'),\n                            icon: \"/bundles/pimcoreadmin/img/flat-color-icons/open_file.svg\",\n                            handler: function (grid, rowIndex) {\n                                var pData = grid.getStore().getAt(rowIndex).data;\n                                if(pData.all && pData.all.data) {\n                                    if(pData.all.data.id) {\n                                        pimcore.helpers.openElement(pData.all.data.id, pData.type, pData.all.data.type);\n                                    }\n                                    else if (pData.all.data.o_id) {\n                                        pimcore.helpers.openElement(pData.all.data.o_id, pData.type,\n                                                                                        pData.all.data.o_type);\n                                    }\n                                }\n                            }.bind(this),\n                            getClass: function(v, meta, rec) {  // Or return a class from a function\n                                if(rec.get('type') != \"object\" && rec.get('type') != \"document\"\n                                                                            && rec.get('type') != \"asset\") {\n                                    return \"pimcore_hidden\";\n                                }\n                            }\n                        }]\n                    },\n                    {\n                        xtype: 'actioncolumn',\n                        menuText: t('delete'),\n                        width: 40,\n                        items: [{\n                            tooltip: t('delete'),\n                            icon: \"/bundles/pimcoreadmin/img/flat-color-icons/delete.svg\",\n                            handler: function (grid, rowIndex) {\n                                grid.getStore().removeAt(rowIndex);\n                            }.bind(this),\n                            getClass: function(v, meta, rec) {  // Or return a class from a function\n                                if (rec.get('inherited')) {\n                                    return \"pimcore_hidden\";\n                                }\n                            }\n                        }]\n                    }\n                ]\n            });\n\n            this.propertyGrid.getView().on(\"refresh\", this.updateRows.bind(this, \"view-refresh\"));\n            this.propertyGrid.getView().on(\"afterrender\", this.updateRows.bind(this, \"view-afterrender\"));\n            this.propertyGrid.getView().on(\"viewready\", this.updateRows.bind(this, \"view-viewready\"));\n\n            this.propertyGrid.on(\"viewready\", this.updateRows.bind(this));\n            this.propertyGrid.on(\"afterrender\", function() {\n                this.setAutoScroll(true);\n            });\n\n            this.propertyGrid.on(\"rowcontextmenu\", function ( grid, record, tr, rowIndex, e, eOpts ) {\n\n                var propertyData = grid.getStore().getAt(rowIndex).data;\n\n                if (propertyData.inherited) {\n                    e.stopEvent();\n                    return;\n                }\n\n                var menu = new Ext.menu.Menu();\n\n                menu.add(new Ext.menu.Item({\n                    text: t('delete'),\n                    iconCls: \"pimcore_icon_delete\",\n                    handler: function (grid, index) {\n                        grid.getStore().removeAt(index);\n                    }.bind(this, grid, rowIndex)\n                }));\n\n                if(propertyData.type == \"object\" || propertyData.type == \"document\" || propertyData.type == \"asset\") {\n                    if(propertyData.data) {\n                        menu.add(new Ext.menu.Item({\n                            text: t('open'),\n                            iconCls: \"pimcore_icon_open\",\n                            handler: function (grid, index) {\n                                var pData = grid.getStore().getAt(index).data;\n                                if(pData.all && pData.all.data) {\n                                    if(pData.all.data.id) {\n                                        pimcore.helpers.openElement(pData.all.data.id, pData.type, pData.all.data.type);\n                                    }\n                                    else if (pData.all.data.o_id) {\n                                        pimcore.helpers.openElement(pData.all.data.o_id, pData.type,\n                                                                                                pData.all.data.o_type);\n                                    }\n                                }\n                            }.bind(this, grid, rowIndex)\n                        }));\n                    }\n                }\n\n                e.stopEvent();\n                menu.showAt(e.pageX, e.pageY);\n            }.bind(this));\n\n            this.layout = new Ext.Panel({\n                title: t('properties'),\n                border: false,\n                layout: \"border\",\n                iconCls: \"pimcore_material_icon_properties pimcore_material_icon\",\n                items: [this.propertyGrid]\n            });\n        }\n\n        return this.layout;\n    },\n\n    getTypeRenderer: function (value, metaData, record, rowIndex, colIndex, store) {\n\n        return '<div class=\"pimcore_icon_' + value + '\" name=\"' + record.data.name + '\">&nbsp;</div>';\n    },\n\n    getCellRenderer: function (value, metaData, record, rowIndex, colIndex, store) {\n\n        var data = store.getAt(rowIndex).data;\n        var type = data.type;\n\n        if (!value) {\n            value = \"\";\n        }\n\n        if (type == \"document\" || type == \"asset\" || type == \"object\") {\n            if (value && data.inherited == false) {\n                return '<div class=\"pimcore_property_droptarget\">' + value + '</div>';\n            }\n            else if (data.inherited == false) {\n                return '<div class=\"pimcore_property_droptarget\">&nbsp;</div>';\n            }\n        } else if (type == \"bool\" && data.inherited == false) {\n            if (value) {\n                return '<div style=\"text-align: left\"><div role=\"button\" class=\"x-grid-checkcolumn x-grid-checkcolumn-checked\" style=\"\"></div></div>';\n            } else {\n                return '<div style=\"text-align: left\"><div role=\"button\" class=\"x-grid-checkcolumn\" style=\"\"></div></div>';\n            }\n        } else if (type == 'text') {\n            return Ext.util.Format.htmlEncode(value);\n        }\n\n        return value;\n    },\n\n    cellMousedown: function (view, cell, rowIndex, cellIndex, e) {\n\n        // this is used for the boolean field type\n\n        var store = this.propertyGrid.getStore();\n        var record = store.getAt(rowIndex);\n        var data = record.data;\n        var type = data.type;\n\n        if (type == \"bool\") {\n            record.set(\"data\", !record.data.data);\n        }\n    },\n\n    getCellEditor: function (record, defaultField ) {\n        var data = record.data;\n        var type = data.type;\n        var property;\n\n        if (type == \"text\") {\n            property = new Ext.form.TextField();\n        }\n        else if (type == \"document\" || type == \"asset\" || type == \"object\") {\n            //no editor needed here\n        }\n        else if (type == \"bool\") {\n            //no editor needed here\n        }\n        else if (type == \"select\") {\n            var config = data.config;\n            property = new Ext.form.ComboBox({\n                triggerAction: 'all',\n                editable: false,\n                store: config.split(\",\")\n            });\n        }\n\n        return property;\n    },\n\n    updateRows: function (event) {\n        var rows = Ext.get(this.propertyGrid.getEl().dom).query(\".x-grid-row\");\n\n        for (var i = 0; i < rows.length; i++) {\n\n            try {\n                var propertyName = Ext.get(rows[i]).query(\".x-grid-cell-first div div\")[0].getAttribute(\"name\");\n                var storeIndex = this.propertyGrid.getStore().findExact(\"name\", propertyName);\n\n                var data = this.propertyGrid.getStore().getAt(storeIndex).data;\n\n                // hide checkcolumn at inherited properties\n                if (data.inherited == true) {\n                    Ext.get(rows[i]).addCls(\"pimcore_properties_hidden_checkcol\");\n                }\n\n                if (data.type == \"document\" || data.type == \"asset\" || data.type == \"object\") {\n                    if (data.inherited == false) {\n                        // add dnd support\n                        var dd = new Ext.dd.DropZone(rows[i], {\n                            ddGroup: \"element\",\n\n                            getTargetFromEvent: function(e) {\n                                return this.getEl();\n                            },\n\n                            onNodeOver : function(dataRow, target, dd, e, data) {\n                                if(data.records.length === 1 && dataRow.type == data.records[0].data.elementType) {\n                                    return Ext.dd.DropZone.prototype.dropAllowed;\n                                }\n                                return Ext.dd.DropZone.prototype.dropNotAllowed;\n\n                            }.bind(this, data),\n\n                            onNodeDrop : function(myRowIndex, target, dd, e, data) {\n\n                                if(!pimcore.helpers.dragAndDropValidateSingleItem(data)) {\n                                    return false;\n                                }\n\n                                try {\n                                    data = data.records[0].data;\n                                    var rec = this.propertyGrid.getStore().getAt(myRowIndex);\n\n                                    if(data.elementType !== rec.get(\"type\")) {\n                                        return false;\n                                    }\n\n\n                                    rec.set(\"data\", data.path);\n                                    rec.set(\"all\",{\n                                        data: {\n                                            id: data.id,\n                                            type: data.type\n                                        }\n                                    });\n\n                                    this.updateRows();\n\n                                    return true;\n                                } catch (e) {\n                                    console.log(e);\n                                }\n                            }.bind(this, storeIndex)\n                        });\n                    }\n                }\n            }\n            catch (e) {\n                console.log(e);\n            }\n        }\n    },\n\n    addSetFromPredefined: function (data, combo) {\n        try {\n            var id = combo.getValue();\n            var selectedData = data.getAt(data.findExact(\"id\", id)).data;\n\n            if (in_array(selectedData.key, this.disallowedKeys)) {\n                Ext.MessageBox.alert(t(\"error\"), t(\"name_is_not_allowed\"));\n            }\n\n            this.add(selectedData.key, selectedData.type, selectedData.data, selectedData.config, false,\n                selectedData.inheritable, selectedData.description);\n        } catch (e) {\n            console.log(e);\n        }\n    },\n\n    addSetFromUserDefined: function (customKey, customType) {\n        try {\n            if (in_array(customKey.getValue(), this.disallowedKeys)) {\n                Ext.MessageBox.alert(t(\"error\"), t(\"name_is_not_allowed\"));\n            }\n            this.add(customKey.getValue(), customType.getValue(), false, false, false, true);\n        } catch (e) {\n            console.log(e);\n        }\n    },\n\n    add: function (key, type, value, config, inherited, inheritable, description) {\n\n        if(in_array(key, this.disallowedKeys)) {\n            return;\n        }\n\n        if(typeof description != \"string\") {\n            description = \"\";\n        }\n\n        var store = this.propertyGrid.getStore();\n\n        // check for duplicate name\n        var dublicateIndex = store.findBy(function (key, record, id) {\n            if (record.data.name.toLowerCase() == key.toLowerCase()) {\n                return true;\n            }\n            return false;\n        }.bind(this, key));\n\n\n        if (dublicateIndex >= 0) {\n            if (store.getAt(dublicateIndex).data.inherited == false) {\n                Ext.MessageBox.alert(t(\"error\"), t(\"name_already_in_use\"));\n                return;\n            }\n        }\n\n        // check for empty key & type\n        if (key.length < 2 || type.length < 1) {\n            Ext.MessageBox.alert(t(\"error\"), t(\"name_and_key_must_be_defined\"));\n            return;\n        }\n\n\n        if (!value) {\n            if (type == \"bool\") {\n                value = true;\n            }\n            if (type == \"document\" || type == \"asset\" || type == \"object\") {\n                value = \"\";\n            }\n            if (type == \"text\") {\n                value = \"\";\n            }\n            value = \"\";\n        }\n\n        if (typeof inheritable != \"boolean\") {\n            inheritable = true;\n        }\n\n        var model = store.getModel();\n        var newRecord = new model({\n            name: key,\n            data: value,\n            type: type,\n            inherited: false,\n            inheritable: inheritable,\n            config: config,\n            description: description\n        });\n\n\n        store.add(newRecord);\n\n        this.propertyGrid.getStore().group(\"inherited\");\n        this.propertyGrid.getView().refresh();\n    },\n\n    getValues : function () {\n\n        if (!this.propertyGrid.rendered) {\n            throw \"properties not available\";\n        }\n\n        var values = {};\n        var store = this.propertyGrid.getStore();\n        store.commitChanges();\n\n        var records = store.getRange();\n\n        for (var i = 0; i < records.length; i++) {\n            var currentData = records[i];\n            if (currentData) {\n                if (!currentData.data.inherited) {\n                    values[currentData.data.name] = {\n                        data: currentData.data.data,\n                        type: currentData.data.type,\n                        inheritable: currentData.data.inheritable\n                    };\n                }\n            }\n        }\n\n\n        return values;\n    }\n\n});\n"], "fixing_code": ["\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n * @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\npimcore.registerNS(\"pimcore.element.properties\");\npimcore.element.properties = Class.create({\n\n    disallowedKeys: [],\n\n    initialize: function(element, type) {\n        this.element = element;\n        this.type = type;\n\n        this.definedFieldTypes = {};\n    },\n\n    getLayout: function () {\n\n        if (this.layout == null) {\n\n            var predefinedPropertiesStore = new Ext.data.Store({\n                fields: [\n                    \"id\",\"name\",\"description\",\"key\",\"type\",\"data\",\"config\",\"inheritable\",\n                    {\n                        name:\"translatedName\",\n                        convert: function(v, rec){\n                            return t(rec.data.name);\n                        },\n                        depends : ['name']\n                    }\n                ],\n                proxy: {\n                    type: 'ajax',\n                    url: Routing.generate('pimcore_admin_element_getpredefinedproperties', {elementType: this.type}),\n                    reader: {\n                        type: 'json',\n                        rootProperty: \"properties\"\n                    }\n                },\n                sorters: [{\n                    property: 'translatedName',\n                    direction: 'ASC'\n                }],\n            });\n\n            var predefinedcombo = new Ext.form.ComboBox({\n                name: \"type\",\n                displayField:'translatedName',\n                valueField: \"id\",\n                store: predefinedPropertiesStore,\n                triggerAction: 'all',\n                listWidth: 300,\n                width: 250,\n                emptyText: t(\"predefined_properties\"),\n                listClass: \"pimcore_predefined_property_select\",\n                listeners: [{\n                    select: this.addSetFromPredefined.bind(this, predefinedPropertiesStore)\n                }]\n            });\n\n            var propertyTypes = new Ext.data.ArrayStore({\n                fields: ['id', 'name'],\n                data: [\n                    [\"text\", \"Text\"],\n                    [\"document\", \"Document\"],\n                    [\"asset\", \"Asset\"],\n                    [\"object\", \"Object\"],\n                    [\"bool\", \"Checkbox\"]\n                ]\n            });\n\n            var customKey = new Ext.form.TextField({\n                name: 'key',\n                emptyText: t('key')\n            });\n\n            var customType = new Ext.form.ComboBox({\n                name: \"type\",\n                valueField: \"id\",\n                displayField:'name',\n                store: propertyTypes,\n                editable: false,\n                triggerAction: 'all',\n                mode: \"local\",\n                listWidth: 200,\n                emptyText: t('type')\n            });\n\n            // prepare store data\n            var property = null;\n            var keys = Object.keys(this.element.data.properties);\n            var key = null;\n            var storeData = [];\n\n            if (keys.length > 0) {\n                for (var i = 0; i < keys.length; i++) {\n                    key = keys[i];\n                    property = this.element.data.properties[key];\n\n                    if (property && typeof property == \"object\") {\n                        storeData.push({\n                            name: property.name,\n                            type: property.type,\n                            data: property.data,\n                            inherited: property.inherited,\n                            inheritable: property.inheritable,\n                            all: property,\n                            config: property.config,\n                            description: property.description\n                        });\n                    }\n                }\n            }\n\n            var store = new Ext.data.Store({\n                autoDestroy: true,\n                data: {properties: storeData},\n                sortInfo:{field: 'inherited', direction: \"ASC\"},\n                proxy: {\n                    type: 'memory',\n                    reader: {\n                        type: 'json',\n                        rootProperty: 'properties'\n                    }\n                },\n                fields: ['name','description','type',{name: \"data\", type: \"string\", convert: function (v, rec) {\n                    if (rec.data.type == \"document\" || rec.data.type == \"asset\" || rec.data.type == \"object\") {\n                        var type = rec.data.type;\n                        if (type == \"document\") {\n                            if (v && typeof v == \"object\") {\n                                return v.path + v.key;\n                            }\n                        }\n                        else if (type == \"asset\") {\n                            if (v && typeof v == \"object\") {\n                                return v.path + v.filename;\n                            }\n                        }\n                        else if (type == \"object\") {\n                            if (v && typeof v == \"object\") {\n                                return v.o_path + v.o_key;\n                            }\n                        }\n\n                    }\n\n                    return v;\n                }},\"inherited\",\"all\",{name: 'inheritable', type: 'bool', mapping: \"inheritable\"}, \"config\"],\n                groupField: 'inherited',\n                filters: [\n                    function(item) {\n                        if(in_array(item.get(\"name\"), this.disallowedKeys)) {\n                            return false;\n                        }\n                        return true;\n                    }.bind(this)\n                ]\n            });\n\n            var checkColumn = Ext.create('Ext.grid.column.Check', {\n                text: t(\"inheritable\"),\n                dataIndex: 'inheritable',\n                listeners: {\n                    beforecheckchange: function (el, rowIndex, checked, eOpts) {\n                        if(store.getAt(rowIndex).get(\"inherited\")) {\n                            return false;\n                        }\n\n                        return true;\n                    }\n                }\n            });\n\n            this.cellEditing = Ext.create('Ext.grid.plugin.CellEditing', {\n                clicksToEdit: 1,\n                listeners: {\n                    beforeedit: function(editor, context, eOpts) {\n                        //need to clear cached editors of cell-editing editor in order to\n                        //enable different editors per row\n                        editor.editors.each(function (e) {\n                            try {\n                                // complete edit, so the value is stored when hopping around with TAB\n                                e.completeEdit();\n                                Ext.destroy(e);\n                            } catch (exception) {\n                                // garbage collector was faster\n                                // already destroyed\n                            }\n                        });\n\n                        editor.editors.clear();\n\n                        if(context.record.get(\"inherited\")) {\n                            return false;\n                        }\n                    }\n                }\n            });\n\n            this.propertyGrid = Ext.create('Ext.grid.Panel', {\n                autoScroll: true,\n                region: \"center\",\n                //reference: this,\n                sm:  Ext.create('Ext.selection.RowModel', {}),\n                bufferedRenderer: false,\n                trackMouseOver: true,\n                store: store,\n                bodyCls: \"pimcore_editable_grid\",\n                plugins: [\n                    this.cellEditing\n                ],\n                tbar: [predefinedcombo,\"-\",{\n                    xtype: \"tbtext\",\n                    text: t('add_a_custom_property') + \" \"\n                },\n                customKey,\n                customType, {\n                    xtype: \"button\",\n                    handler: this.addSetFromUserDefined.bind(this, customKey, customType),\n                    iconCls: \"pimcore_icon_add\"\n                }],\n                //plugins: checkColumn,\n                clicksToEdit: 1,\n                features: [\n                    Ext.create('Ext.grid.feature.Grouping', {\n                        listeners: {\n                            rowupdated: this.updateRows.bind(this, \"rowupdated\"),\n                            refresh: this.updateRows.bind(this, \"refresh\")\n                        }\n                    })\n                ],\n                autoExpandColumn: \"property_value_col\",\n                columnLines: true,\n                stripeRows: true,\n                columns: [\n                    {\n                        text: t(\"type\"),\n                        dataIndex: 'type',\n                        editable: false,\n                        width: 40,\n                        renderer: this.getTypeRenderer.bind(this),\n                        sortable: true\n                    },\n                    {\n                        text: t('inherited'),\n                        dataIndex: 'inherited',\n                        editable: false,\n                        hidden: true,\n                        sortable: true\n                    },\n                    {\n                        text: t(\"key\"),\n                        dataIndex: 'name',\n                        getEditor: function() {\n                            return new Ext.form.TextField({\n                                allowBlank: false\n                            });\n                        },\n                        sortable: true,\n                        renderer: Ext.util.Format.htmlEncode,\n                        width: 230\n                    },\n                    {\n                        text: t(\"description\"),\n                        dataIndex: 'description',\n                        editable: false,\n                        sortable: true,\n                        renderer: Ext.util.Format.htmlEncode,\n                        width: 230\n                    },\n                    {\n                        text: t(\"value\"),\n                        dataIndex: 'data',\n                        flex: 1,\n                        getEditor: this.getCellEditor.bind(this),\n                        editable: true,\n                        renderer: this.getCellRenderer.bind(this),\n                        listeners: {\n                            \"mousedown\": this.cellMousedown.bind(this)\n                        }\n                    },\n                    checkColumn,\n                    {\n                        xtype: 'actioncolumn',\n                        menuText: t('open'),\n                        width: 40,\n                        items: [{\n                            tooltip: t('open'),\n                            icon: \"/bundles/pimcoreadmin/img/flat-color-icons/open_file.svg\",\n                            handler: function (grid, rowIndex) {\n                                var pData = grid.getStore().getAt(rowIndex).data;\n                                if(pData.all && pData.all.data) {\n                                    if(pData.all.data.id) {\n                                        pimcore.helpers.openElement(pData.all.data.id, pData.type, pData.all.data.type);\n                                    }\n                                    else if (pData.all.data.o_id) {\n                                        pimcore.helpers.openElement(pData.all.data.o_id, pData.type,\n                                                                                        pData.all.data.o_type);\n                                    }\n                                }\n                            }.bind(this),\n                            getClass: function(v, meta, rec) {  // Or return a class from a function\n                                if(rec.get('type') != \"object\" && rec.get('type') != \"document\"\n                                                                            && rec.get('type') != \"asset\") {\n                                    return \"pimcore_hidden\";\n                                }\n                            }\n                        }]\n                    },\n                    {\n                        xtype: 'actioncolumn',\n                        menuText: t('delete'),\n                        width: 40,\n                        items: [{\n                            tooltip: t('delete'),\n                            icon: \"/bundles/pimcoreadmin/img/flat-color-icons/delete.svg\",\n                            handler: function (grid, rowIndex) {\n                                grid.getStore().removeAt(rowIndex);\n                            }.bind(this),\n                            getClass: function(v, meta, rec) {  // Or return a class from a function\n                                if (rec.get('inherited')) {\n                                    return \"pimcore_hidden\";\n                                }\n                            }\n                        }]\n                    }\n                ]\n            });\n\n            this.propertyGrid.getView().on(\"refresh\", this.updateRows.bind(this, \"view-refresh\"));\n            this.propertyGrid.getView().on(\"afterrender\", this.updateRows.bind(this, \"view-afterrender\"));\n            this.propertyGrid.getView().on(\"viewready\", this.updateRows.bind(this, \"view-viewready\"));\n\n            this.propertyGrid.on(\"viewready\", this.updateRows.bind(this));\n            this.propertyGrid.on(\"afterrender\", function() {\n                this.setAutoScroll(true);\n            });\n\n            this.propertyGrid.on(\"rowcontextmenu\", function ( grid, record, tr, rowIndex, e, eOpts ) {\n\n                var propertyData = grid.getStore().getAt(rowIndex).data;\n\n                if (propertyData.inherited) {\n                    e.stopEvent();\n                    return;\n                }\n\n                var menu = new Ext.menu.Menu();\n\n                menu.add(new Ext.menu.Item({\n                    text: t('delete'),\n                    iconCls: \"pimcore_icon_delete\",\n                    handler: function (grid, index) {\n                        grid.getStore().removeAt(index);\n                    }.bind(this, grid, rowIndex)\n                }));\n\n                if(propertyData.type == \"object\" || propertyData.type == \"document\" || propertyData.type == \"asset\") {\n                    if(propertyData.data) {\n                        menu.add(new Ext.menu.Item({\n                            text: t('open'),\n                            iconCls: \"pimcore_icon_open\",\n                            handler: function (grid, index) {\n                                var pData = grid.getStore().getAt(index).data;\n                                if(pData.all && pData.all.data) {\n                                    if(pData.all.data.id) {\n                                        pimcore.helpers.openElement(pData.all.data.id, pData.type, pData.all.data.type);\n                                    }\n                                    else if (pData.all.data.o_id) {\n                                        pimcore.helpers.openElement(pData.all.data.o_id, pData.type,\n                                                                                                pData.all.data.o_type);\n                                    }\n                                }\n                            }.bind(this, grid, rowIndex)\n                        }));\n                    }\n                }\n\n                e.stopEvent();\n                menu.showAt(e.pageX, e.pageY);\n            }.bind(this));\n\n            this.layout = new Ext.Panel({\n                title: t('properties'),\n                border: false,\n                layout: \"border\",\n                iconCls: \"pimcore_material_icon_properties pimcore_material_icon\",\n                items: [this.propertyGrid]\n            });\n        }\n\n        return this.layout;\n    },\n\n    getTypeRenderer: function (value, metaData, record, rowIndex, colIndex, store) {\n\n        return '<div class=\"pimcore_icon_' + value + '\" name=\"' + record.data.name + '\">&nbsp;</div>';\n    },\n\n    getCellRenderer: function (value, metaData, record, rowIndex, colIndex, store) {\n\n        var data = store.getAt(rowIndex).data;\n        var type = data.type;\n\n        if (!value) {\n            value = \"\";\n        }\n\n        if (type == \"document\" || type == \"asset\" || type == \"object\") {\n            if (value && data.inherited == false) {\n                return '<div class=\"pimcore_property_droptarget\">' + value + '</div>';\n            }\n            else if (data.inherited == false) {\n                return '<div class=\"pimcore_property_droptarget\">&nbsp;</div>';\n            }\n        } else if (type == \"bool\" && data.inherited == false) {\n            if (value) {\n                return '<div style=\"text-align: left\"><div role=\"button\" class=\"x-grid-checkcolumn x-grid-checkcolumn-checked\" style=\"\"></div></div>';\n            } else {\n                return '<div style=\"text-align: left\"><div role=\"button\" class=\"x-grid-checkcolumn\" style=\"\"></div></div>';\n            }\n        } else if (type == 'text') {\n            return Ext.util.Format.htmlEncode(value);\n        }\n\n        return value;\n    },\n\n    cellMousedown: function (view, cell, rowIndex, cellIndex, e) {\n\n        // this is used for the boolean field type\n\n        var store = this.propertyGrid.getStore();\n        var record = store.getAt(rowIndex);\n        var data = record.data;\n        var type = data.type;\n\n        if (type == \"bool\") {\n            record.set(\"data\", !record.data.data);\n        }\n    },\n\n    getCellEditor: function (record, defaultField ) {\n        var data = record.data;\n        var type = data.type;\n        var property;\n\n        if (type == \"text\") {\n            property = new Ext.form.TextField();\n        }\n        else if (type == \"document\" || type == \"asset\" || type == \"object\") {\n            //no editor needed here\n        }\n        else if (type == \"bool\") {\n            //no editor needed here\n        }\n        else if (type == \"select\") {\n            var config = data.config;\n            property = new Ext.form.ComboBox({\n                triggerAction: 'all',\n                editable: false,\n                store: config.split(\",\")\n            });\n        }\n\n        return property;\n    },\n\n    updateRows: function (event) {\n        var rows = Ext.get(this.propertyGrid.getEl().dom).query(\".x-grid-row\");\n\n        for (var i = 0; i < rows.length; i++) {\n\n            try {\n                var propertyName = Ext.get(rows[i]).query(\".x-grid-cell-first div div\")[0].getAttribute(\"name\");\n                var storeIndex = this.propertyGrid.getStore().findExact(\"name\", propertyName);\n\n                var data = this.propertyGrid.getStore().getAt(storeIndex).data;\n\n                // hide checkcolumn at inherited properties\n                if (data.inherited == true) {\n                    Ext.get(rows[i]).addCls(\"pimcore_properties_hidden_checkcol\");\n                }\n\n                if (data.type == \"document\" || data.type == \"asset\" || data.type == \"object\") {\n                    if (data.inherited == false) {\n                        // add dnd support\n                        var dd = new Ext.dd.DropZone(rows[i], {\n                            ddGroup: \"element\",\n\n                            getTargetFromEvent: function(e) {\n                                return this.getEl();\n                            },\n\n                            onNodeOver : function(dataRow, target, dd, e, data) {\n                                if(data.records.length === 1 && dataRow.type == data.records[0].data.elementType) {\n                                    return Ext.dd.DropZone.prototype.dropAllowed;\n                                }\n                                return Ext.dd.DropZone.prototype.dropNotAllowed;\n\n                            }.bind(this, data),\n\n                            onNodeDrop : function(myRowIndex, target, dd, e, data) {\n\n                                if(!pimcore.helpers.dragAndDropValidateSingleItem(data)) {\n                                    return false;\n                                }\n\n                                try {\n                                    data = data.records[0].data;\n                                    var rec = this.propertyGrid.getStore().getAt(myRowIndex);\n\n                                    if(data.elementType !== rec.get(\"type\")) {\n                                        return false;\n                                    }\n\n\n                                    rec.set(\"data\", data.path);\n                                    rec.set(\"all\",{\n                                        data: {\n                                            id: data.id,\n                                            type: data.type\n                                        }\n                                    });\n\n                                    this.updateRows();\n\n                                    return true;\n                                } catch (e) {\n                                    console.log(e);\n                                }\n                            }.bind(this, storeIndex)\n                        });\n                    }\n                }\n            }\n            catch (e) {\n                console.log(e);\n            }\n        }\n    },\n\n    addSetFromPredefined: function (data, combo) {\n        try {\n            var id = combo.getValue();\n            var selectedData = data.getAt(data.findExact(\"id\", id)).data;\n\n            if (in_array(selectedData.key, this.disallowedKeys)) {\n                Ext.MessageBox.alert(t(\"error\"), t(\"name_is_not_allowed\"));\n            }\n\n            this.add(selectedData.key, selectedData.type, selectedData.data, selectedData.config, false,\n                selectedData.inheritable, selectedData.description);\n        } catch (e) {\n            console.log(e);\n        }\n    },\n\n    addSetFromUserDefined: function (customKey, customType) {\n        try {\n            let key = htmlspecialchars(customKey.getValue());\n            if (in_array(key, this.disallowedKeys)) {\n                Ext.MessageBox.alert(t(\"error\"), t(\"name_is_not_allowed\"));\n            }\n            this.add(key, customType.getValue(), false, false, false, true);\n        } catch (e) {\n            console.log(e);\n        }\n    },\n\n    add: function (key, type, value, config, inherited, inheritable, description) {\n\n        if(in_array(key, this.disallowedKeys)) {\n            return;\n        }\n\n        if(typeof description != \"string\") {\n            description = \"\";\n        }\n\n        var store = this.propertyGrid.getStore();\n\n        // check for duplicate name\n        var dublicateIndex = store.findBy(function (key, record, id) {\n            if (record.data.name.toLowerCase() == key.toLowerCase()) {\n                return true;\n            }\n            return false;\n        }.bind(this, key));\n\n\n        if (dublicateIndex >= 0) {\n            if (store.getAt(dublicateIndex).data.inherited == false) {\n                Ext.MessageBox.alert(t(\"error\"), t(\"name_already_in_use\"));\n                return;\n            }\n        }\n\n        // check for empty key & type\n        if (key.length < 2 || type.length < 1) {\n            Ext.MessageBox.alert(t(\"error\"), t(\"name_and_key_must_be_defined\"));\n            return;\n        }\n\n\n        if (!value) {\n            if (type == \"bool\") {\n                value = true;\n            }\n            if (type == \"document\" || type == \"asset\" || type == \"object\") {\n                value = \"\";\n            }\n            if (type == \"text\") {\n                value = \"\";\n            }\n            value = \"\";\n        }\n\n        if (typeof inheritable != \"boolean\") {\n            inheritable = true;\n        }\n\n        var model = store.getModel();\n        var newRecord = new model({\n            name: key,\n            data: value,\n            type: type,\n            inherited: false,\n            inheritable: inheritable,\n            config: config,\n            description: description\n        });\n\n\n        store.add(newRecord);\n\n        this.propertyGrid.getStore().group(\"inherited\");\n        this.propertyGrid.getView().refresh();\n    },\n\n    getValues : function () {\n\n        if (!this.propertyGrid.rendered) {\n            throw \"properties not available\";\n        }\n\n        var values = {};\n        var store = this.propertyGrid.getStore();\n        store.commitChanges();\n\n        var records = store.getRange();\n\n        for (var i = 0; i < records.length; i++) {\n            var currentData = records[i];\n            if (currentData) {\n                if (!currentData.data.inherited) {\n                    values[currentData.data.name] = {\n                        data: currentData.data.data,\n                        type: currentData.data.type,\n                        inheritable: currentData.data.inheritable\n                    };\n                }\n            }\n        }\n\n\n        return values;\n    }\n\n});\n"], "filenames": ["bundles/AdminBundle/Resources/public/js/pimcore/element/properties.js"], "buggy_code_start_loc": [571], "buggy_code_end_loc": [575], "fixing_code_start_loc": [571], "fixing_code_end_loc": [576], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Stored in GitHub repository pimcore/pimcore prior to 10.3.3.", "other": {"cve": {"id": "CVE-2022-0831", "sourceIdentifier": "security@huntr.dev", "published": "2022-03-04T14:15:07.903", "lastModified": "2022-03-10T14:39:21.750", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Stored in GitHub repository pimcore/pimcore prior to 10.3.3."}, {"lang": "es", "value": "Una vulnerabilidad de tipo Cross-site Scripting (XSS) - Almacenado en el repositorio de GitHub pimcore/pimcore versiones anteriores a 10.3.3"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:C/C:L/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.5, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pimcore:pimcore:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.3.3", "matchCriteriaId": "BDE34DAE-3EE0-4271-9AC3-87B634A194FB"}]}]}], "references": [{"url": "https://github.com/pimcore/pimcore/commit/e786fd44aac46febdbf916ed6c328fbe645d80bf", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/4152e3a7-27a1-49eb-a6eb-a57506af104f", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pimcore/pimcore/commit/e786fd44aac46febdbf916ed6c328fbe645d80bf"}}