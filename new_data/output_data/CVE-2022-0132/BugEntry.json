{"buggy_code": ["import express from 'express'\nimport { body } from 'express-validator'\nimport { isPreImportVideoAccepted } from '@server/lib/moderation'\nimport { Hooks } from '@server/lib/plugins/hooks'\nimport { HttpStatusCode } from '@shared/models'\nimport { VideoImportCreate } from '@shared/models/videos/import/video-import-create.model'\nimport { isIdValid, toIntOrNull } from '../../../helpers/custom-validators/misc'\nimport { isVideoImportTargetUrlValid, isVideoImportTorrentFile } from '../../../helpers/custom-validators/video-imports'\nimport { isVideoMagnetUriValid, isVideoNameValid } from '../../../helpers/custom-validators/videos'\nimport { cleanUpReqFiles } from '../../../helpers/express-utils'\nimport { logger } from '../../../helpers/logger'\nimport { CONFIG } from '../../../initializers/config'\nimport { CONSTRAINTS_FIELDS } from '../../../initializers/constants'\nimport { areValidationErrors, doesVideoChannelOfAccountExist } from '../shared'\nimport { getCommonVideoEditAttributes } from './videos'\n\nconst videoImportAddValidator = getCommonVideoEditAttributes().concat([\n  body('channelId')\n    .customSanitizer(toIntOrNull)\n    .custom(isIdValid).withMessage('Should have correct video channel id'),\n  body('targetUrl')\n    .optional()\n    .custom(isVideoImportTargetUrlValid).withMessage('Should have a valid video import target URL'),\n  body('magnetUri')\n    .optional()\n    .custom(isVideoMagnetUriValid).withMessage('Should have a valid video magnet URI'),\n  body('torrentfile')\n    .custom((value, { req }) => isVideoImportTorrentFile(req.files))\n    .withMessage(\n      'This torrent file is not supported or too large. Please, make sure it is of the following type: ' +\n      CONSTRAINTS_FIELDS.VIDEO_IMPORTS.TORRENT_FILE.EXTNAME.join(', ')\n    ),\n  body('name')\n    .optional()\n    .custom(isVideoNameValid).withMessage(\n      `Should have a video name between ${CONSTRAINTS_FIELDS.VIDEOS.NAME.min} and ${CONSTRAINTS_FIELDS.VIDEOS.NAME.max} characters long`\n    ),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking videoImportAddValidator parameters', { parameters: req.body })\n\n    const user = res.locals.oauth.token.User\n    const torrentFile = req.files?.['torrentfile'] ? req.files['torrentfile'][0] : undefined\n\n    if (areValidationErrors(req, res)) return cleanUpReqFiles(req)\n\n    if (CONFIG.IMPORT.VIDEOS.HTTP.ENABLED !== true && req.body.targetUrl) {\n      cleanUpReqFiles(req)\n\n      return res.fail({\n        status: HttpStatusCode.CONFLICT_409,\n        message: 'HTTP import is not enabled on this instance.'\n      })\n    }\n\n    if (CONFIG.IMPORT.VIDEOS.TORRENT.ENABLED !== true && (req.body.magnetUri || torrentFile)) {\n      cleanUpReqFiles(req)\n\n      return res.fail({\n        status: HttpStatusCode.CONFLICT_409,\n        message: 'Torrent/magnet URI import is not enabled on this instance.'\n      })\n    }\n\n    if (!await doesVideoChannelOfAccountExist(req.body.channelId, user, res)) return cleanUpReqFiles(req)\n\n    // Check we have at least 1 required param\n    if (!req.body.targetUrl && !req.body.magnetUri && !torrentFile) {\n      cleanUpReqFiles(req)\n\n      return res.fail({ message: 'Should have a magnetUri or a targetUrl or a torrent file.' })\n    }\n\n    if (!await isImportAccepted(req, res)) return cleanUpReqFiles(req)\n\n    return next()\n  }\n])\n\n// ---------------------------------------------------------------------------\n\nexport {\n  videoImportAddValidator\n}\n\n// ---------------------------------------------------------------------------\n\nasync function isImportAccepted (req: express.Request, res: express.Response) {\n  const body: VideoImportCreate = req.body\n  const hookName = body.targetUrl\n    ? 'filter:api.video.pre-import-url.accept.result'\n    : 'filter:api.video.pre-import-torrent.accept.result'\n\n  // Check we accept this video\n  const acceptParameters = {\n    videoImportBody: body,\n    user: res.locals.oauth.token.User\n  }\n  const acceptedResult = await Hooks.wrapFun(\n    isPreImportVideoAccepted,\n    acceptParameters,\n    hookName\n  )\n\n  if (!acceptedResult || acceptedResult.accepted !== true) {\n    logger.info('Refused to import video.', { acceptedResult, acceptParameters })\n\n    res.fail({\n      status: HttpStatusCode.FORBIDDEN_403,\n      message: acceptedResult.errorMessage || 'Refused to import video'\n    })\n    return false\n  }\n\n  return true\n}\n", "/* eslint-disable @typescript-eslint/no-unused-expressions,@typescript-eslint/require-await */\n\nimport 'mocha'\nimport { omit } from 'lodash'\nimport {\n  buildAbsoluteFixturePath,\n  checkBadCountPagination,\n  checkBadSortPagination,\n  checkBadStartPagination,\n  cleanupTests,\n  createSingleServer,\n  FIXTURE_URLS,\n  makeGetRequest,\n  makePostBodyRequest,\n  makeUploadRequest,\n  PeerTubeServer,\n  setAccessTokensToServers\n} from '@shared/extra-utils'\nimport { HttpStatusCode, VideoPrivacy } from '@shared/models'\n\ndescribe('Test video imports API validator', function () {\n  const path = '/api/v1/videos/imports'\n  let server: PeerTubeServer\n  let userAccessToken = ''\n  let channelId: number\n\n  // ---------------------------------------------------------------\n\n  before(async function () {\n    this.timeout(30000)\n\n    server = await createSingleServer(1)\n\n    await setAccessTokensToServers([ server ])\n\n    const username = 'user1'\n    const password = 'my super password'\n    await server.users.create({ username: username, password: password })\n    userAccessToken = await server.login.getAccessToken({ username, password })\n\n    {\n      const { videoChannels } = await server.users.getMyInfo()\n      channelId = videoChannels[0].id\n    }\n  })\n\n  describe('When listing my video imports', function () {\n    const myPath = '/api/v1/users/me/videos/imports'\n\n    it('Should fail with a bad start pagination', async function () {\n      await checkBadStartPagination(server.url, myPath, server.accessToken)\n    })\n\n    it('Should fail with a bad count pagination', async function () {\n      await checkBadCountPagination(server.url, myPath, server.accessToken)\n    })\n\n    it('Should fail with an incorrect sort', async function () {\n      await checkBadSortPagination(server.url, myPath, server.accessToken)\n    })\n\n    it('Should success with the correct parameters', async function () {\n      await makeGetRequest({ url: server.url, path: myPath, expectedStatus: HttpStatusCode.OK_200, token: server.accessToken })\n    })\n  })\n\n  describe('When adding a video import', function () {\n    let baseCorrectParams\n\n    before(function () {\n      baseCorrectParams = {\n        targetUrl: FIXTURE_URLS.goodVideo,\n        name: 'my super name',\n        category: 5,\n        licence: 1,\n        language: 'pt',\n        nsfw: false,\n        commentsEnabled: true,\n        downloadEnabled: true,\n        waitTranscoding: true,\n        description: 'my super description',\n        support: 'my super support text',\n        tags: [ 'tag1', 'tag2' ],\n        privacy: VideoPrivacy.PUBLIC,\n        channelId\n      }\n    })\n\n    it('Should fail with nothing', async function () {\n      const fields = {}\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail without a target url', async function () {\n      const fields = omit(baseCorrectParams, 'targetUrl')\n      await makePostBodyRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.BAD_REQUEST_400\n      })\n    })\n\n    it('Should fail with a bad target url', async function () {\n      const fields = { ...baseCorrectParams, targetUrl: 'htt://hello' }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a long name', async function () {\n      const fields = { ...baseCorrectParams, name: 'super'.repeat(65) }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad category', async function () {\n      const fields = { ...baseCorrectParams, category: 125 }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad licence', async function () {\n      const fields = { ...baseCorrectParams, licence: 125 }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad language', async function () {\n      const fields = { ...baseCorrectParams, language: 'a'.repeat(15) }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a long description', async function () {\n      const fields = { ...baseCorrectParams, description: 'super'.repeat(2500) }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a long support text', async function () {\n      const fields = { ...baseCorrectParams, support: 'super'.repeat(201) }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail without a channel', async function () {\n      const fields = omit(baseCorrectParams, 'channelId')\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad channel', async function () {\n      const fields = { ...baseCorrectParams, channelId: 545454 }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with another user channel', async function () {\n      const user = {\n        username: 'fake',\n        password: 'fake_password'\n      }\n      await server.users.create({ username: user.username, password: user.password })\n\n      const accessTokenUser = await server.login.getAccessToken(user)\n      const { videoChannels } = await server.users.getMyInfo({ token: accessTokenUser })\n      const customChannelId = videoChannels[0].id\n\n      const fields = { ...baseCorrectParams, channelId: customChannelId }\n\n      await makePostBodyRequest({ url: server.url, path, token: userAccessToken, fields })\n    })\n\n    it('Should fail with too many tags', async function () {\n      const fields = { ...baseCorrectParams, tags: [ 'tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6' ] }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a tag length too low', async function () {\n      const fields = { ...baseCorrectParams, tags: [ 'tag1', 't' ] }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a tag length too big', async function () {\n      const fields = { ...baseCorrectParams, tags: [ 'tag1', 'my_super_tag_too_long_long_long_long_long_long' ] }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with an incorrect thumbnail file', async function () {\n      const fields = baseCorrectParams\n      const attaches = {\n        thumbnailfile: buildAbsoluteFixturePath('video_short.mp4')\n      }\n\n      await makeUploadRequest({ url: server.url, path, token: server.accessToken, fields, attaches })\n    })\n\n    it('Should fail with a big thumbnail file', async function () {\n      const fields = baseCorrectParams\n      const attaches = {\n        thumbnailfile: buildAbsoluteFixturePath('preview-big.png')\n      }\n\n      await makeUploadRequest({ url: server.url, path, token: server.accessToken, fields, attaches })\n    })\n\n    it('Should fail with an incorrect preview file', async function () {\n      const fields = baseCorrectParams\n      const attaches = {\n        previewfile: buildAbsoluteFixturePath('video_short.mp4')\n      }\n\n      await makeUploadRequest({ url: server.url, path, token: server.accessToken, fields, attaches })\n    })\n\n    it('Should fail with a big preview file', async function () {\n      const fields = baseCorrectParams\n      const attaches = {\n        previewfile: buildAbsoluteFixturePath('preview-big.png')\n      }\n\n      await makeUploadRequest({ url: server.url, path, token: server.accessToken, fields, attaches })\n    })\n\n    it('Should fail with an invalid torrent file', async function () {\n      const fields = omit(baseCorrectParams, 'targetUrl')\n      const attaches = {\n        torrentfile: buildAbsoluteFixturePath('avatar-big.png')\n      }\n\n      await makeUploadRequest({ url: server.url, path, token: server.accessToken, fields, attaches })\n    })\n\n    it('Should fail with an invalid magnet URI', async function () {\n      let fields = omit(baseCorrectParams, 'targetUrl')\n      fields = { ...fields, magnetUri: 'blabla' }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      this.timeout(30000)\n\n      await makePostBodyRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields: baseCorrectParams,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n\n    it('Should forbid to import http videos', async function () {\n      await server.config.updateCustomSubConfig({\n        newConfig: {\n          import: {\n            videos: {\n              http: {\n                enabled: false\n              },\n              torrent: {\n                enabled: true\n              }\n            }\n          }\n        }\n      })\n\n      await makePostBodyRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields: baseCorrectParams,\n        expectedStatus: HttpStatusCode.CONFLICT_409\n      })\n    })\n\n    it('Should forbid to import torrent videos', async function () {\n      await server.config.updateCustomSubConfig({\n        newConfig: {\n          import: {\n            videos: {\n              http: {\n                enabled: true\n              },\n              torrent: {\n                enabled: false\n              }\n            }\n          }\n        }\n      })\n\n      let fields = omit(baseCorrectParams, 'targetUrl')\n      fields = { ...fields, magnetUri: FIXTURE_URLS.magnet }\n\n      await makePostBodyRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.CONFLICT_409\n      })\n\n      fields = omit(fields, 'magnetUri')\n      const attaches = {\n        torrentfile: buildAbsoluteFixturePath('video-720p.torrent')\n      }\n\n      await makeUploadRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields,\n        attaches,\n        expectedStatus: HttpStatusCode.CONFLICT_409\n      })\n    })\n  })\n\n  after(async function () {\n    await cleanupTests([ server ])\n  })\n})\n"], "fixing_code": ["import express from 'express'\nimport { body } from 'express-validator'\nimport { isPreImportVideoAccepted } from '@server/lib/moderation'\nimport { Hooks } from '@server/lib/plugins/hooks'\nimport { HttpStatusCode } from '@shared/models'\nimport { VideoImportCreate } from '@shared/models/videos/import/video-import-create.model'\nimport { isIdValid, toIntOrNull } from '../../../helpers/custom-validators/misc'\nimport { isVideoImportTargetUrlValid, isVideoImportTorrentFile } from '../../../helpers/custom-validators/video-imports'\nimport { isVideoMagnetUriValid, isVideoNameValid } from '../../../helpers/custom-validators/videos'\nimport { cleanUpReqFiles } from '../../../helpers/express-utils'\nimport { logger } from '../../../helpers/logger'\nimport { CONFIG } from '../../../initializers/config'\nimport { CONSTRAINTS_FIELDS } from '../../../initializers/constants'\nimport { areValidationErrors, doesVideoChannelOfAccountExist } from '../shared'\nimport { getCommonVideoEditAttributes } from './videos'\nimport { isValid as isIPValid, parse as parseIP } from 'ipaddr.js'\n\nconst videoImportAddValidator = getCommonVideoEditAttributes().concat([\n  body('channelId')\n    .customSanitizer(toIntOrNull)\n    .custom(isIdValid).withMessage('Should have correct video channel id'),\n  body('targetUrl')\n    .optional()\n    .custom(isVideoImportTargetUrlValid).withMessage('Should have a valid video import target URL'),\n  body('magnetUri')\n    .optional()\n    .custom(isVideoMagnetUriValid).withMessage('Should have a valid video magnet URI'),\n  body('torrentfile')\n    .custom((value, { req }) => isVideoImportTorrentFile(req.files))\n    .withMessage(\n      'This torrent file is not supported or too large. Please, make sure it is of the following type: ' +\n      CONSTRAINTS_FIELDS.VIDEO_IMPORTS.TORRENT_FILE.EXTNAME.join(', ')\n    ),\n  body('name')\n    .optional()\n    .custom(isVideoNameValid).withMessage(\n      `Should have a video name between ${CONSTRAINTS_FIELDS.VIDEOS.NAME.min} and ${CONSTRAINTS_FIELDS.VIDEOS.NAME.max} characters long`\n    ),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking videoImportAddValidator parameters', { parameters: req.body })\n\n    const user = res.locals.oauth.token.User\n    const torrentFile = req.files?.['torrentfile'] ? req.files['torrentfile'][0] : undefined\n\n    if (areValidationErrors(req, res)) return cleanUpReqFiles(req)\n\n    if (CONFIG.IMPORT.VIDEOS.HTTP.ENABLED !== true && req.body.targetUrl) {\n      cleanUpReqFiles(req)\n\n      return res.fail({\n        status: HttpStatusCode.CONFLICT_409,\n        message: 'HTTP import is not enabled on this instance.'\n      })\n    }\n\n    if (CONFIG.IMPORT.VIDEOS.TORRENT.ENABLED !== true && (req.body.magnetUri || torrentFile)) {\n      cleanUpReqFiles(req)\n\n      return res.fail({\n        status: HttpStatusCode.CONFLICT_409,\n        message: 'Torrent/magnet URI import is not enabled on this instance.'\n      })\n    }\n\n    if (!await doesVideoChannelOfAccountExist(req.body.channelId, user, res)) return cleanUpReqFiles(req)\n\n    // Check we have at least 1 required param\n    if (!req.body.targetUrl && !req.body.magnetUri && !torrentFile) {\n      cleanUpReqFiles(req)\n\n      return res.fail({ message: 'Should have a magnetUri or a targetUrl or a torrent file.' })\n    }\n\n    if (req.body.targetUrl) {\n      const hostname = new URL(req.body.targetUrl).hostname\n\n      if (isIPValid(hostname)) {\n        const parsed = parseIP(hostname)\n\n        if (parsed.range() !== 'unicast') {\n          cleanUpReqFiles(req)\n\n          return res.fail({\n            status: HttpStatusCode.FORBIDDEN_403,\n            message: 'Cannot use non unicast IP as targetUrl.'\n          })\n        }\n      }\n    }\n\n    if (!await isImportAccepted(req, res)) return cleanUpReqFiles(req)\n\n    return next()\n  }\n])\n\n// ---------------------------------------------------------------------------\n\nexport {\n  videoImportAddValidator\n}\n\n// ---------------------------------------------------------------------------\n\nasync function isImportAccepted (req: express.Request, res: express.Response) {\n  const body: VideoImportCreate = req.body\n  const hookName = body.targetUrl\n    ? 'filter:api.video.pre-import-url.accept.result'\n    : 'filter:api.video.pre-import-torrent.accept.result'\n\n  // Check we accept this video\n  const acceptParameters = {\n    videoImportBody: body,\n    user: res.locals.oauth.token.User\n  }\n  const acceptedResult = await Hooks.wrapFun(\n    isPreImportVideoAccepted,\n    acceptParameters,\n    hookName\n  )\n\n  if (!acceptedResult || acceptedResult.accepted !== true) {\n    logger.info('Refused to import video.', { acceptedResult, acceptParameters })\n\n    res.fail({\n      status: HttpStatusCode.FORBIDDEN_403,\n      message: acceptedResult.errorMessage || 'Refused to import video'\n    })\n    return false\n  }\n\n  return true\n}\n", "/* eslint-disable @typescript-eslint/no-unused-expressions,@typescript-eslint/require-await */\n\nimport 'mocha'\nimport { omit } from 'lodash'\nimport {\n  buildAbsoluteFixturePath,\n  checkBadCountPagination,\n  checkBadSortPagination,\n  checkBadStartPagination,\n  cleanupTests,\n  createSingleServer,\n  FIXTURE_URLS,\n  makeGetRequest,\n  makePostBodyRequest,\n  makeUploadRequest,\n  PeerTubeServer,\n  setAccessTokensToServers\n} from '@shared/extra-utils'\nimport { HttpStatusCode, VideoPrivacy } from '@shared/models'\n\ndescribe('Test video imports API validator', function () {\n  const path = '/api/v1/videos/imports'\n  let server: PeerTubeServer\n  let userAccessToken = ''\n  let channelId: number\n\n  // ---------------------------------------------------------------\n\n  before(async function () {\n    this.timeout(30000)\n\n    server = await createSingleServer(1)\n\n    await setAccessTokensToServers([ server ])\n\n    const username = 'user1'\n    const password = 'my super password'\n    await server.users.create({ username: username, password: password })\n    userAccessToken = await server.login.getAccessToken({ username, password })\n\n    {\n      const { videoChannels } = await server.users.getMyInfo()\n      channelId = videoChannels[0].id\n    }\n  })\n\n  describe('When listing my video imports', function () {\n    const myPath = '/api/v1/users/me/videos/imports'\n\n    it('Should fail with a bad start pagination', async function () {\n      await checkBadStartPagination(server.url, myPath, server.accessToken)\n    })\n\n    it('Should fail with a bad count pagination', async function () {\n      await checkBadCountPagination(server.url, myPath, server.accessToken)\n    })\n\n    it('Should fail with an incorrect sort', async function () {\n      await checkBadSortPagination(server.url, myPath, server.accessToken)\n    })\n\n    it('Should success with the correct parameters', async function () {\n      await makeGetRequest({ url: server.url, path: myPath, expectedStatus: HttpStatusCode.OK_200, token: server.accessToken })\n    })\n  })\n\n  describe('When adding a video import', function () {\n    let baseCorrectParams\n\n    before(function () {\n      baseCorrectParams = {\n        targetUrl: FIXTURE_URLS.goodVideo,\n        name: 'my super name',\n        category: 5,\n        licence: 1,\n        language: 'pt',\n        nsfw: false,\n        commentsEnabled: true,\n        downloadEnabled: true,\n        waitTranscoding: true,\n        description: 'my super description',\n        support: 'my super support text',\n        tags: [ 'tag1', 'tag2' ],\n        privacy: VideoPrivacy.PUBLIC,\n        channelId\n      }\n    })\n\n    it('Should fail with nothing', async function () {\n      const fields = {}\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail without a target url', async function () {\n      const fields = omit(baseCorrectParams, 'targetUrl')\n      await makePostBodyRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.BAD_REQUEST_400\n      })\n    })\n\n    it('Should fail with a bad target url', async function () {\n      const fields = { ...baseCorrectParams, targetUrl: 'htt://hello' }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with localhost', async function () {\n      const fields = { ...baseCorrectParams, targetUrl: 'http://localhost:8000' }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a private IP target urls', async function () {\n      const targetUrls = [\n        'http://127.0.0.1:8000',\n        'http://127.0.0.1',\n        'http://127.0.0.1/hello',\n        'https://192.168.1.42',\n        'http://192.168.1.42'\n      ]\n\n      for (const targetUrl of targetUrls) {\n        const fields = { ...baseCorrectParams, targetUrl }\n\n        await makePostBodyRequest({\n          url: server.url,\n          path,\n          token: server.accessToken,\n          fields,\n          expectedStatus: HttpStatusCode.FORBIDDEN_403\n        })\n      }\n    })\n\n    it('Should fail with a long name', async function () {\n      const fields = { ...baseCorrectParams, name: 'super'.repeat(65) }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad category', async function () {\n      const fields = { ...baseCorrectParams, category: 125 }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad licence', async function () {\n      const fields = { ...baseCorrectParams, licence: 125 }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad language', async function () {\n      const fields = { ...baseCorrectParams, language: 'a'.repeat(15) }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a long description', async function () {\n      const fields = { ...baseCorrectParams, description: 'super'.repeat(2500) }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a long support text', async function () {\n      const fields = { ...baseCorrectParams, support: 'super'.repeat(201) }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail without a channel', async function () {\n      const fields = omit(baseCorrectParams, 'channelId')\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad channel', async function () {\n      const fields = { ...baseCorrectParams, channelId: 545454 }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with another user channel', async function () {\n      const user = {\n        username: 'fake',\n        password: 'fake_password'\n      }\n      await server.users.create({ username: user.username, password: user.password })\n\n      const accessTokenUser = await server.login.getAccessToken(user)\n      const { videoChannels } = await server.users.getMyInfo({ token: accessTokenUser })\n      const customChannelId = videoChannels[0].id\n\n      const fields = { ...baseCorrectParams, channelId: customChannelId }\n\n      await makePostBodyRequest({ url: server.url, path, token: userAccessToken, fields })\n    })\n\n    it('Should fail with too many tags', async function () {\n      const fields = { ...baseCorrectParams, tags: [ 'tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6' ] }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a tag length too low', async function () {\n      const fields = { ...baseCorrectParams, tags: [ 'tag1', 't' ] }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a tag length too big', async function () {\n      const fields = { ...baseCorrectParams, tags: [ 'tag1', 'my_super_tag_too_long_long_long_long_long_long' ] }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail with an incorrect thumbnail file', async function () {\n      const fields = baseCorrectParams\n      const attaches = {\n        thumbnailfile: buildAbsoluteFixturePath('video_short.mp4')\n      }\n\n      await makeUploadRequest({ url: server.url, path, token: server.accessToken, fields, attaches })\n    })\n\n    it('Should fail with a big thumbnail file', async function () {\n      const fields = baseCorrectParams\n      const attaches = {\n        thumbnailfile: buildAbsoluteFixturePath('preview-big.png')\n      }\n\n      await makeUploadRequest({ url: server.url, path, token: server.accessToken, fields, attaches })\n    })\n\n    it('Should fail with an incorrect preview file', async function () {\n      const fields = baseCorrectParams\n      const attaches = {\n        previewfile: buildAbsoluteFixturePath('video_short.mp4')\n      }\n\n      await makeUploadRequest({ url: server.url, path, token: server.accessToken, fields, attaches })\n    })\n\n    it('Should fail with a big preview file', async function () {\n      const fields = baseCorrectParams\n      const attaches = {\n        previewfile: buildAbsoluteFixturePath('preview-big.png')\n      }\n\n      await makeUploadRequest({ url: server.url, path, token: server.accessToken, fields, attaches })\n    })\n\n    it('Should fail with an invalid torrent file', async function () {\n      const fields = omit(baseCorrectParams, 'targetUrl')\n      const attaches = {\n        torrentfile: buildAbsoluteFixturePath('avatar-big.png')\n      }\n\n      await makeUploadRequest({ url: server.url, path, token: server.accessToken, fields, attaches })\n    })\n\n    it('Should fail with an invalid magnet URI', async function () {\n      let fields = omit(baseCorrectParams, 'targetUrl')\n      fields = { ...fields, magnetUri: 'blabla' }\n\n      await makePostBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      this.timeout(30000)\n\n      await makePostBodyRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields: baseCorrectParams,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n\n    it('Should forbid to import http videos', async function () {\n      await server.config.updateCustomSubConfig({\n        newConfig: {\n          import: {\n            videos: {\n              http: {\n                enabled: false\n              },\n              torrent: {\n                enabled: true\n              }\n            }\n          }\n        }\n      })\n\n      await makePostBodyRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields: baseCorrectParams,\n        expectedStatus: HttpStatusCode.CONFLICT_409\n      })\n    })\n\n    it('Should forbid to import torrent videos', async function () {\n      await server.config.updateCustomSubConfig({\n        newConfig: {\n          import: {\n            videos: {\n              http: {\n                enabled: true\n              },\n              torrent: {\n                enabled: false\n              }\n            }\n          }\n        }\n      })\n\n      let fields = omit(baseCorrectParams, 'targetUrl')\n      fields = { ...fields, magnetUri: FIXTURE_URLS.magnet }\n\n      await makePostBodyRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.CONFLICT_409\n      })\n\n      fields = omit(fields, 'magnetUri')\n      const attaches = {\n        torrentfile: buildAbsoluteFixturePath('video-720p.torrent')\n      }\n\n      await makeUploadRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields,\n        attaches,\n        expectedStatus: HttpStatusCode.CONFLICT_409\n      })\n    })\n  })\n\n  after(async function () {\n    await cleanupTests([ server ])\n  })\n})\n"], "filenames": ["server/middlewares/validators/videos/video-imports.ts", "server/tests/api/check-params/video-imports.ts"], "buggy_code_start_loc": [15, 110], "buggy_code_end_loc": [73, 110], "fixing_code_start_loc": [16, 111], "fixing_code_end_loc": [92, 139], "type": "CWE-918", "message": "peertube is vulnerable to Server-Side Request Forgery (SSRF)", "other": {"cve": {"id": "CVE-2022-0132", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-10T14:12:26.720", "lastModified": "2022-01-14T16:06:40.243", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "peertube is vulnerable to Server-Side Request Forgery (SSRF)"}, {"lang": "es", "value": "peertube es vulnerable a un ataque de tipo Server-Side Request Forgery (SSRF)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:framasoft:peertube:-:*:*:*:*:*:*:*", "matchCriteriaId": "D93B2533-6077-4A83-9D8D-94A0391F428E"}]}]}], "references": [{"url": "https://github.com/chocobozzz/peertube/commit/7b54a81cccf6b4c12269e9d6897d608b1a99537a", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/77ec5308-5561-4664-af21-d780df2d1e4b", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/chocobozzz/peertube/commit/7b54a81cccf6b4c12269e9d6897d608b1a99537a"}}