{"buggy_code": ["#include \"AppHdr.h\"\n\n#include \"clua.h\"\n\n#include <algorithm>\n\n#include \"cluautil.h\"\n#include \"dlua.h\"\n#include \"end.h\"\n#include \"files.h\"\n#include \"libutil.h\"\n#include \"l-libs.h\"\n#include \"maybe-bool.h\"\n#include \"misc.h\" // erase_val\n#include \"options.h\"\n#include \"state.h\"\n#include \"stringutil.h\"\n#include \"syscalls.h\"\n#include \"unicode.h\"\n#include \"version.h\"\n\n#define BUGGY_PCALL_ERROR  \"667: Malformed response to guarded pcall.\"\n#define BUGGY_SCRIPT_ERROR \"666: Killing badly-behaved Lua script.\"\n\n// 64-bit luajit does not support custom allocators. Only checking\n// TARGET_CPU_X64 because luajit doesn't support other 64-bit archs.\n#if defined(USE_LUAJIT) && defined(TARGET_CPU_X64)\n#define NO_CUSTOM_ALLOCATOR\n#endif\n\nstatic int  _clua_panic(lua_State *);\nstatic void _clua_throttle_hook(lua_State *, lua_Debug *);\n#ifndef NO_CUSTOM_ALLOCATOR\nstatic void *_clua_allocator(void *ud, void *ptr, size_t osize, size_t nsize);\n#endif\nstatic int  _clua_guarded_pcall(lua_State *);\nstatic int  _clua_require(lua_State *);\nstatic int  _clua_dofile(lua_State *);\nstatic int  _clua_loadfile(lua_State *);\nstatic string _get_persist_file();\n\nCLua::CLua(bool managed)\n    : error(), managed_vm(managed), shutting_down(false),\n      throttle_unit_lines(50000),\n      throttle_sleep_ms(0), throttle_sleep_start(2),\n      throttle_sleep_end(800), n_throttle_sleeps(0), mixed_call_depth(0),\n      lua_call_depth(0), max_mixed_call_depth(8),\n      max_lua_call_depth(100), memory_used(0),\n      _state(nullptr), sourced_files(), uniqindex(0)\n{\n}\n\nCLua::~CLua()\n{\n    // Copy the listener vector, because listeners may remove\n    // themselves from the listener list when we notify them of a\n    // shutdown.\n    const vector<lua_shutdown_listener*> slisteners = shutdown_listeners;\n    for (lua_shutdown_listener *listener : slisteners)\n        listener->shutdown(*this);\n    shutting_down = true;\n    if (_state)\n        lua_close(_state);\n}\n\nlua_State *CLua::state()\n{\n    if (!_state)\n        init_lua();\n    return _state;\n}\n\nvoid CLua::setglobal(const char *name)\n{\n    lua_setglobal(state(), name);\n}\n\nvoid CLua::getglobal(const char *name)\n{\n    lua_getglobal(state(), name);\n}\n\nstring CLua::setuniqregistry()\n{\n    char name[100];\n    snprintf(name, sizeof name, \"__cru%u\", uniqindex++);\n    lua_pushstring(state(), name);\n    lua_insert(state(), -2);\n    lua_settable(state(), LUA_REGISTRYINDEX);\n\n    return name;\n}\n\nvoid CLua::setregistry(const char *name)\n{\n    lua_pushstring(state(), name);\n    // Slide name round before the value\n    lua_insert(state(), -2);\n    lua_settable(state(), LUA_REGISTRYINDEX);\n}\n\nvoid CLua::_getregistry(lua_State *ls, const char *name)\n{\n    lua_pushstring(ls, name);\n    lua_gettable(ls, LUA_REGISTRYINDEX);\n}\n\nvoid CLua::getregistry(const char *name)\n{\n    _getregistry(state(), name);\n}\n\nvoid CLua::gc()\n{\n    lua_gc(state(), LUA_GCCOLLECT, 0);\n}\n\nvoid CLua::save(writer &outf)\n{\n    if (!_state)\n        return;\n\n    string res;\n    callfn(\"c_save\", \">s\", &res);\n    outf.write(res.c_str(), res.size());\n}\n\nvoid CLua::save_persist()\n{\n    string persist;\n    // We load persist.lua immediately before calling c_save_persist so\n    // that we know that it hasn't been overwritten by a player version.\n    execfile(\"dlua/persist.lua\", true, true);\n    callfn(\"c_save_persist\", \">s\", &persist);\n    if (Options.no_save)\n        return;\n\n    FILE *f;\n    const string persistfile = _get_persist_file();\n\n    // Don't create the file if there's no need to do so.\n    if (persist.empty() && !file_exists(persistfile))\n        return;\n\n    f = fopen_u(persistfile.c_str(), \"w\");\n    if (!f)\n    {\n        mprf(MSGCH_ERROR, \"Couldn't open %s for writing!\", persistfile.c_str());\n        return;\n    }\n\n    fprintf(f, \"-- %s %s persistent clua file\\n\"\n               \"-- WARNING: This file is entirely auto-generated.\\n\"\n            \"\\n\",\n            OUTS(CRAWL), // ok, localizing the game name is not likely\n            OUTS(Version::Long)); // nor the version string\n    fprintf(f, \"%s\", persist.c_str());\n    fclose(f);\n}\n\nvoid CLua::load_persist()\n{\n    if (Options.no_save)\n        return;\n    string persistfile = _get_persist_file();\n    if (!file_exists(persistfile))\n        return;\n    FileLineInput f(persistfile.c_str());\n    string script;\n    while (!f.eof())\n        script += f.get_line() + \"\\n\";\n    execstring(script.c_str());\n}\n\nint CLua::file_write(lua_State *ls)\n{\n    if (!lua_islightuserdata(ls, 1))\n    {\n        luaL_argerror(ls, 1, \"Expected filehandle at arg 1\");\n        return 0;\n    }\n    CLuaSave *sf = static_cast<CLuaSave *>(lua_touserdata(ls, 1));\n    if (!sf)\n        return 0;\n\n    FILE *f = sf->get_file();\n    if (!f)\n        return 0;\n\n    const char *text = luaL_checkstring(ls, 2);\n    if (text)\n        fprintf(f, \"%s\", text);\n    return 0;\n}\n\nFILE *CLua::CLuaSave::get_file()\n{\n    if (!handle)\n        handle = fopen_u(filename, \"w\");\n\n    return handle;\n}\n\nvoid CLua::set_error(int err, lua_State *ls)\n{\n    if (!err)\n    {\n        error.clear();\n        return;\n    }\n    if (!ls && !(ls = _state))\n    {\n        error = \"<LUA not initialised>\";\n        return;\n    }\n    const char *serr = lua_tostring(ls, -1);\n    lua_pop(ls, 1);\n    error = serr? serr : \"<Unknown error>\";\n}\n\nvoid CLua::init_throttle()\n{\n    if (!managed_vm)\n        return;\n\n    if (!crawl_state.throttle)\n        return;\n\n    if (throttle_unit_lines <= 0)\n        throttle_unit_lines = 500;\n\n    if (throttle_sleep_start < 1)\n        throttle_sleep_start = 1;\n\n    if (throttle_sleep_end < throttle_sleep_start)\n        throttle_sleep_end = throttle_sleep_start;\n\n    if (!mixed_call_depth)\n    {\n        lua_sethook(_state, _clua_throttle_hook,\n                    LUA_MASKCOUNT, throttle_unit_lines);\n        throttle_sleep_ms = 0;\n        n_throttle_sleeps = 0;\n    }\n}\n\nint CLua::loadbuffer(const char *buf, size_t size, const char *context)\n{\n    const int err = luaL_loadbuffer(state(), buf, size, context);\n    set_error(err, state());\n    return err;\n}\n\nint CLua::loadstring(const char *s, const char *context)\n{\n    return loadbuffer(s, strlen(s), context);\n}\n\nint CLua::execstring(const char *s, const char *context, int nresults)\n{\n    int err = 0;\n    if ((err = loadstring(s, context)))\n        return err;\n\n    lua_State *ls = state();\n    lua_call_throttle strangler(this);\n    err = lua_pcall(ls, 0, nresults, 0);\n    set_error(err, ls);\n    return err;\n}\n\nbool CLua::is_path_safe(string s, bool trusted)\n{\n    lowercase(s);\n    return s.find(\"..\") == string::npos && shell_safe(s.c_str())\n           // loading dlua stuff would spew tons of error messages\n           && (trusted || s.find(\"dlua\") != 0);\n}\n\nint CLua::loadfile(lua_State *ls, const char *filename, bool trusted,\n                   bool die_on_fail)\n{\n    if (!ls)\n        return -1;\n\n    if (!is_path_safe(filename, trusted))\n    {\n        lua_pushstring(\n            ls,\n            make_stringf(\"invalid filename: %s\", filename).c_str());\n        return -1;\n    }\n\n    string file = datafile_path(filename, die_on_fail);\n    if (file.empty())\n    {\n        lua_pushstring(ls,\n                       make_stringf(\"Can't find \\\"%s\\\"\", filename).c_str());\n        return -1;\n    }\n\n    FileLineInput f(file.c_str());\n    string script;\n    while (!f.eof())\n        script += f.get_line() + \"\\n\";\n\n    // prefixing with @ stops lua from adding [string \"%s\"]\n    return luaL_loadbuffer(ls, &script[0], script.length(),\n                           (\"@\" + file).c_str());\n}\n\nint CLua::execfile(const char *filename, bool trusted, bool die_on_fail,\n                   bool force)\n{\n    if (!force && sourced_files.count(filename))\n        return 0;\n\n    lua_State *ls = state();\n    int err = loadfile(ls, filename, trusted || !managed_vm, die_on_fail);\n    lua_call_throttle strangler(this);\n    if (!err)\n        err = lua_pcall(ls, 0, 0, 0);\n    if (!err)\n        sourced_files.insert(filename);\n    set_error(err);\n    if (die_on_fail && !error.empty())\n    {\n        end(1, false, \"Lua execfile error (%s): %s\",\n            filename, error.c_str());\n    }\n    return err;\n}\n\nbool CLua::runhook(const char *hook, const char *params, ...)\n{\n    error.clear();\n\n    lua_State *ls = state();\n    if (!ls)\n        return false;\n\n    lua_stack_cleaner clean(ls);\n\n    pushglobal(hook);\n    if (!lua_istable(ls, -1))\n        return false;\n    for (int i = 1; ; ++i)\n    {\n        lua_stack_cleaner clean2(ls);\n\n        lua_rawgeti(ls, -1, i);\n        if (!lua_isfunction(ls, -1))\n        {\n            lua_pop(ls, 1);\n            break;\n        }\n\n        // So what's on top *is* a function. Call it with the args we have.\n        va_list args;\n        va_start(args, params);\n        calltopfn(ls, params, args);\n        va_end(args);\n    }\n    return true;\n}\n\nvoid CLua::fnreturns(const char *format, ...)\n{\n    lua_State *ls = _state;\n\n    if (!format || !ls)\n        return;\n\n    va_list args;\n    va_start(args, format);\n    vfnreturns(format, args);\n    va_end(args);\n}\n\nvoid CLua::vfnreturns(const char *format, va_list args)\n{\n    lua_State *ls = _state;\n    int nrets = return_count(ls, format);\n    int sp = -nrets - 1;\n\n    const char *gs = strchr(format, '>');\n    if (gs)\n        format = gs + 1;\n    else if ((gs = strchr(format, ':')))\n        format = gs + 1;\n\n    for (const char *run = format; *run; ++run)\n    {\n        char argtype = *run;\n        ++sp;\n        switch (argtype)\n        {\n        case 'u':\n            if (lua_islightuserdata(ls, sp))\n                *(va_arg(args, void**)) = lua_touserdata(ls, sp);\n            break;\n        case 'd':\n            if (lua_isnumber(ls, sp))\n                *(va_arg(args, int*)) = luaL_safe_checkint(ls, sp);\n            break;\n        case 'b':\n            *(va_arg(args, bool *)) = lua_toboolean(ls, sp);\n            break;\n        case 's':\n            {\n                const char *s = lua_tostring(ls, sp);\n                if (s)\n                    *(va_arg(args, string *)) = s;\n                break;\n            }\n        default:\n            break;\n        }\n\n    }\n    // Pop args off the stack\n    lua_pop(ls, nrets);\n}\n\nint CLua::push_args(lua_State *ls, const char *format, va_list args,\n                    va_list *targ)\n{\n    if (!format)\n    {\n        if (targ)\n            va_copy(*targ, args);\n        return 0;\n    }\n\n    const char *cs = strchr(format, ':');\n    if (cs)\n        format = cs + 1;\n\n    int argc = 0;\n    for (const char *run = format; *run; run++)\n    {\n        if (*run == '>')\n            break;\n\n        char argtype = *run;\n        ++argc;\n        switch (argtype)\n        {\n        case 'u':       // Light userdata\n            lua_pushlightuserdata(ls, va_arg(args, void*));\n            break;\n        case 'i':\n            clua_push_item(ls, va_arg(args, item_def*));\n            break;\n        case 's':       // String\n        {\n            const char *s = va_arg(args, const char *);\n            if (s)\n                lua_pushstring(ls, s);\n            else\n                lua_pushnil(ls);\n            break;\n        }\n        case 'd':       // Integer\n            lua_pushnumber(ls, va_arg(args, int));\n            break;\n        case 'L':\n            die(\"ambiguous long in Lua push_args\");\n            lua_pushnumber(ls, va_arg(args, long));\n            break;\n        case 'b':\n            lua_pushboolean(ls, va_arg(args, int));\n            break;\n        case 'D':\n            clua_push_dgn_event(ls, va_arg(args, const dgn_event *));\n            break;\n        case 'm':\n            clua_push_map(ls, va_arg(args, map_def *));\n            break;\n        case 'M':\n            push_monster(ls, va_arg(args, monster*));\n            break;\n        case 'I':\n            lua_push_moninf(ls, va_arg(args, monster_info *));\n            break;\n        case 'A':\n            argc += push_activity_interrupt(\n                        ls, va_arg(args, activity_interrupt_data *));\n            break;\n        default:\n            --argc;\n            break;\n        }\n    }\n    if (targ)\n        va_copy(*targ, args);\n    return argc;\n}\n\nint CLua::return_count(lua_State *ls, const char *format)\n{\n    UNUSED(ls);\n\n    if (!format)\n        return 0;\n\n    const char *gs = strchr(format, '>');\n    if (gs)\n        return strlen(gs + 1);\n\n    const char *cs = strchr(format, ':');\n    if (cs && isdigit(*format))\n    {\n        char *es = nullptr;\n        int ci = strtol(format, &es, 10);\n        // We're capping return at 10 here, which is arbitrary, but avoids\n        // blowing the stack.\n        if (ci < 0)\n            ci = 0;\n        else if (ci > 10)\n            ci = 10;\n        return ci;\n    }\n    return 0;\n}\n\nbool CLua::calltopfn(lua_State *ls, const char *params, va_list args,\n                     int retc, va_list *copyto)\n{\n    // We guarantee to remove the function from the stack\n    int argc = push_args(ls, params, args, copyto);\n    if (retc == -1)\n        retc = return_count(ls, params);\n    lua_call_throttle strangler(this);\n    int err = lua_pcall(ls, argc, retc, 0);\n    set_error(err, ls);\n    return !err;\n}\n\nmaybe_bool CLua::callmbooleanfn(const char *fn, const char *params,\n                                va_list args)\n{\n    error.clear();\n    lua_State *ls = state();\n    if (!ls)\n        return MB_MAYBE;\n\n    lua_stack_cleaner clean(ls);\n\n    pushglobal(fn);\n    if (!lua_isfunction(ls, -1))\n        return MB_MAYBE;\n\n    bool ret = calltopfn(ls, params, args, 1);\n    if (!ret)\n        return MB_MAYBE;\n\n    return frombool(lua_toboolean(ls, -1));\n}\n\nmaybe_bool CLua::callmbooleanfn(const char *fn, const char *params, ...)\n{\n    va_list args;\n    va_start(args, params);\n    maybe_bool r = callmbooleanfn(fn, params, args);\n    va_end(args);\n    return r;\n}\n\nmaybe_bool CLua::callmaybefn(const char *fn, const char *params, va_list args)\n{\n    error.clear();\n    lua_State *ls = state();\n    if (!ls)\n        return MB_MAYBE;\n\n    lua_stack_cleaner clean(ls);\n\n    pushglobal(fn);\n    if (!lua_isfunction(ls, -1))\n        return MB_MAYBE;\n\n    bool ret = calltopfn(ls, params, args, 1);\n    if (!ret)\n        return MB_MAYBE;\n\n    return lua_isboolean(ls, -1) ? frombool(lua_toboolean(ls, -1)) : MB_MAYBE;\n}\n\nmaybe_bool CLua::callmaybefn(const char *fn, const char *params, ...)\n{\n    va_list args;\n    va_start(args, params);\n    maybe_bool r = callmaybefn(fn, params, args);\n    va_end(args);\n    return r;\n}\n\nbool CLua::callbooleanfn(bool def, const char *fn, const char *params, ...)\n{\n    va_list args;\n    va_start(args, params);\n    maybe_bool r = callmbooleanfn(fn, params, args);\n    va_end(args);\n    return tobool(r, def);\n}\n\nbool CLua::proc_returns(const char *par) const\n{\n    return strchr(par, '>') != nullptr;\n}\n\n// Identical to lua_getglobal for simple names, but will look up\n// \"a.b.c\" names in tables, so you can pushglobal(\"dgn.point\") and get\n// _G['dgn']['point'], as expected.\n//\n// Guarantees to push exactly one value onto the stack.\n//\nvoid CLua::pushglobal(const string &name)\n{\n    vector<string> pieces = split_string(\".\", name);\n    lua_State *ls(state());\n\n    if (pieces.empty())\n        lua_pushnil(ls);\n\n    for (unsigned i = 0, size = pieces.size(); i < size; ++i)\n    {\n        if (!i)\n            lua_getglobal(ls, pieces[i].c_str());\n        else\n        {\n            if (lua_istable(ls, -1))\n            {\n                lua_pushstring(ls, pieces[i].c_str());\n                lua_gettable(ls, -2);\n                // Swap the value we just found with the table itself.\n                lua_insert(ls, -2);\n                // And remove the table.\n                lua_pop(ls, 1);\n            }\n            else\n            {\n                // We expected a table here, but got something else. Fail.\n                lua_pop(ls, 1);\n                lua_pushnil(ls);\n                break;\n            }\n        }\n    }\n}\n\nbool CLua::callfn(const char *fn, const char *params, ...)\n{\n    error.clear();\n    lua_State *ls = state();\n    if (!ls)\n        return false;\n\n    pushglobal(fn);\n    if (!lua_isfunction(ls, -1))\n    {\n        lua_pop(ls, 1);\n        return false;\n    }\n\n    va_list args;\n    va_list fnret;\n    va_start(args, params);\n    bool ret = calltopfn(ls, params, args, -1, &fnret);\n    if (ret)\n    {\n        // If we have a > in format, gather return params now.\n        if (proc_returns(params))\n            vfnreturns(params, fnret);\n    }\n    va_end(args);\n    va_end(fnret);\n    return ret;\n}\n\nbool CLua::callfn(const char *fn, int nargs, int nret)\n{\n    error.clear();\n    lua_State *ls = state();\n    if (!ls)\n        return false;\n\n    // If a function is not provided on the stack, get the named function.\n    if (fn)\n    {\n        pushglobal(fn);\n        if (!lua_isfunction(ls, -1))\n        {\n            lua_settop(ls, -nargs - 2);\n            return false;\n        }\n\n        // Slide the function in front of its args and call it.\n        if (nargs)\n            lua_insert(ls, -nargs - 1);\n    }\n\n    lua_call_throttle strangler(this);\n    int err = lua_pcall(ls, nargs, nret, 0);\n    set_error(err, ls);\n    return !err;\n}\n\nvoid CLua::init_lua()\n{\n    if (_state)\n        return;\n\n#ifdef NO_CUSTOM_ALLOCATOR\n    // If this is likely to be used as a server, warn the builder.\n    // NOTE: #warning doesn't work on MSVC, so this will be fatal there\n    // (not that webtiles or dgamelaunch are supported on Windows anyway).\n# if defined(USE_TILE_WEB) || defined(DGAMELAUNCH)\n#   warning Detected 64-bit Luajit, disabling CLua memory throttling.\n# endif\n    _state = luaL_newstate();\n#else\n    // Throttle memory usage in managed (clua) VMs\n    _state = managed_vm? lua_newstate(_clua_allocator, this) : luaL_newstate();\n#endif\n    if (!_state)\n        end(1, false, \"Unable to create Lua state.\");\n\n    lua_stack_cleaner clean(_state);\n\n    lua_atpanic(_state, _clua_panic);\n\n#ifdef CLUA_UNRESTRICTED_LIBS\n    // open all libs -- this is not safe for public servers or releases!\n    // Intended for people writing bots and the like.\n    luaL_openlibs(_state);\n#else\n    // Selectively load some, but not all Lua core libraries.\n    //\n    // In Lua 5.1, these library setup calls are not supposed to be called\n    // directly from C. If the lua version changes, this may need to be changed:\n    // recommended practice is (apparently) checking the lua version's linit.cc\n    // and seeing how that does the full library setup.\n    //\n    // This doesn't seem to *obviously* impact the libraries we use by default,\n    // but some of the libraries we don't use will panic if not called\n    // correctly; since someone writing a bot (for example) might want to\n    // expand this, do things \"correctly\". The core lua libraries in 5.1 we are\n    // not loading are:\n    //\n    // {LUA_LOADLIBNAME, luaopen_package},    // (require etc)\n    // {LUA_IOLIBNAME, luaopen_io},           //\n    // {LUA_OSLIBNAME, luaopen_os},\n    // {LUA_DBLIBNAME, luaopen_debug},\n    const vector<pair<string, lua_CFunction>> lua_core_libs =\n    {\n        {\"\", luaopen_base}, // XX: why no name? but this is how linit.cc does it\n        {LUA_TABLIBNAME, luaopen_table},\n        {LUA_STRLIBNAME, luaopen_string},\n        {LUA_MATHLIBNAME, luaopen_math},\n    };\n\n    for (auto l : lua_core_libs)\n    {\n        lua_pushcfunction(_state, l.second);\n        lua_pushstring(_state, l.first.c_str());\n        lua_call(_state, 1, 0);\n    }\n#endif\n\n    lua_pushboolean(_state, managed_vm);\n    setregistry(\"lua_vm_is_managed\");\n\n    lua_pushlightuserdata(_state, this);\n    setregistry(\"__clua\");\n}\n\nvoid CLua::init_libraries()\n{\n    lua_stack_cleaner clean(state());\n\n    // Open Crawl bindings\n    cluaopen_kills(_state);\n    cluaopen_you(_state);\n    cluaopen_item(_state);\n    cluaopen_food(_state);\n    cluaopen_crawl(_state);\n    cluaopen_file(_state);\n    cluaopen_moninf(_state);\n    cluaopen_options(_state);\n    cluaopen_travel(_state);\n    cluaopen_view(_state);\n    cluaopen_spells(_state);\n\n    cluaopen_globals(_state);\n\n    execfile(\"dlua/macro.lua\", true, true);\n\n    // All hook names must be chk_????\n    execstring(\"chk_startgame = { }\", \"base\");\n\n    lua_register(_state, \"loadfile\", _clua_loadfile);\n    lua_register(_state, \"dofile\", _clua_dofile);\n\n    lua_register(_state, \"crawl_require\", _clua_require);\n\n    execfile(\"dlua/util.lua\", true, true);\n    execfile(\"dlua/iter.lua\", true, true);\n    execfile(\"dlua/tags.lua\", true, true);\n    execfile(\"dlua/init.lua\", true, true);\n\n    if (managed_vm)\n    {\n        lua_register(_state, \"pcall\", _clua_guarded_pcall);\n        execfile(\"dlua/userbase.lua\", true, true);\n        execfile(\"dlua/persist.lua\", true, true);\n    }\n}\n\nCLua &CLua::get_vm(lua_State *ls)\n{\n    lua_stack_cleaner clean(ls);\n    _getregistry(ls, \"__clua\");\n    CLua *vm = clua_get_lightuserdata<CLua>(ls, -1);\n    if (!vm)\n        luaL_error(ls, \"Could not find matching clua for lua state\");\n    return *vm;\n}\n\nbool CLua::is_managed_vm(lua_State *ls)\n{\n    lua_stack_cleaner clean(ls);\n    lua_pushstring(ls, \"lua_vm_is_managed\");\n    lua_gettable(ls, LUA_REGISTRYINDEX);\n    return lua_toboolean(ls, -1);\n}\n\nvoid CLua::add_shutdown_listener(lua_shutdown_listener *listener)\n{\n    if (find(shutdown_listeners.begin(), shutdown_listeners.end(), listener)\n        == shutdown_listeners.end())\n    {\n        shutdown_listeners.push_back(listener);\n    }\n}\n\nvoid CLua::remove_shutdown_listener(lua_shutdown_listener *listener)\n{\n    erase_val(shutdown_listeners, listener);\n}\n\n// Can be called from within a debugger to look at the current Lua\n// call stack. (Borrowed from ToME 3)\nvoid CLua::print_stack()\n{\n    struct lua_Debug dbg;\n    int              i = 0;\n    lua_State       *L = state();\n\n    fprintf(stderr, \"\\n\");\n    while (lua_getstack(L, i++, &dbg) == 1)\n    {\n        lua_getinfo(L, \"lnuS\", &dbg);\n\n        char* file = strrchr(dbg.short_src, '/');\n        if (file == nullptr)\n            file = dbg.short_src;\n        else\n            file++;\n\n        fprintf(stderr, \"%s, function %s, line %d\\n\", file,\n                dbg.name, dbg.currentline);\n    }\n\n    fprintf(stderr, \"\\n\");\n}\n\n// //////////////////////////////////////////////////////////////////////\n// lua_text_pattern\n\n// We could simplify this a great deal by just using lex and yacc, but I\n// don't know if we want to introduce them.\n\nstruct lua_pat_op\n{\n    const char *token;\n    const char *luatok;\n\n    bool pretext;       // Does this follow a pattern?\n    bool posttext;      // Is this followed by a pattern?\n};\n\nstatic lua_pat_op pat_ops[] =\n{\n    { \"<<\", \" ( \",   false, true },\n    { \">>\", \" ) \",   true,  false },\n    { \"!!\", \" not \", false, true },\n    { \"==\", \" == \",  true,  true },\n    { \"^^\", \" ~= \",  true,  true },\n    { \"&&\", \" and \", true,  true },\n    { \"||\", \" or \",  true,  true },\n};\n\nunsigned int lua_text_pattern::lfndx = 0;\n\nbool lua_text_pattern::is_lua_pattern(const string &s)\n{\n    return any_of(begin(pat_ops), end(pat_ops),\n            [&s] (const lua_pat_op &op)\n            { return s.find(op.token) != string::npos; });\n}\n\nlua_text_pattern::lua_text_pattern(const string &_pattern)\n    : translated(false), isvalid(true), pattern(_pattern),\n      lua_fn_name(new_fn_name())\n{\n}\n\nlua_text_pattern::~lua_text_pattern()\n{\n    if (translated && !lua_fn_name.empty())\n    {\n        lua_State *ls = clua;\n        if (ls)\n        {\n            lua_pushnil(ls);\n            clua.setglobal(lua_fn_name.c_str());\n        }\n    }\n}\n\nbool lua_text_pattern::valid() const\n{\n    return translated? isvalid : translate();\n}\n\nbool lua_text_pattern::matches(const string &s) const\n{\n    if (isvalid && !translated)\n        translate();\n\n    if (!isvalid)\n        return false;\n\n    return clua.callbooleanfn(false, lua_fn_name.c_str(), \"s\", s.c_str());\n}\n\npattern_match lua_text_pattern::match_location(const string &s) const\n{\n    // lua_text_pattern is only used if a special non-regex op is detected (^F\n    // for \"armour && ego\", for instance), and in those situations, it's\n    // unclear what exactly to use for the matched text here (especially in\n    // more complicated expressions that include things like <<>>, !!, etc).\n    return matches(s)\n        ? pattern_match::succeeded(s)\n        : pattern_match::failed(s);\n}\n\nvoid lua_text_pattern::pre_pattern(string &pat, string &fn) const\n{\n    // Trim trailing spaces\n    pat.erase(pat.find_last_not_of(\" \\t\\n\\r\") + 1);\n\n    fn += \" pmatch([[\";\n    fn += pat;\n    fn += \"]], text, false) \";\n\n    pat.clear();\n}\n\nvoid lua_text_pattern::post_pattern(string &pat, string &fn) const\n{\n    pat.erase(0, pat.find_first_not_of(\" \\t\\n\\r\"));\n\n    fn += \" pmatch([[\";\n    fn += pat;\n    fn += \"]], text, false) \";\n\n    pat.clear();\n}\n\nstring lua_text_pattern::new_fn_name()\n{\n    return make_stringf(\"__ch_stash_search_%u\", lfndx++);\n}\n\nbool lua_text_pattern::translate() const\n{\n    if (translated || !isvalid)\n        return false;\n\n    if (pattern.find(\"]]\") != string::npos || pattern.find(\"[[\") != string::npos)\n        return false;\n\n    string textp;\n    string luafn;\n    const lua_pat_op *currop = nullptr;\n    for (string::size_type i = 0; i < pattern.length(); ++i)\n    {\n        bool match = false;\n        for (unsigned p = 0; p < ARRAYSZ(pat_ops); ++p)\n        {\n            const lua_pat_op &lop = pat_ops[p];\n            if (pattern.find(lop.token, i) == i)\n            {\n                match = true;\n                if (lop.pretext && (!currop || currop->posttext))\n                {\n                    if (currop)\n                        textp.erase(0, textp.find_first_not_of(\" \\r\\n\\t\"));\n                    pre_pattern(textp, luafn);\n                }\n\n                currop = &lop;\n                luafn += lop.luatok;\n\n                i += strlen(lop.token) - 1;\n\n                break;\n            }\n        }\n\n        if (match)\n            continue;\n\n        textp += pattern[i];\n    }\n\n    if (currop && currop->posttext)\n        post_pattern(textp, luafn);\n\n    luafn = \"function \" + lua_fn_name + \"(text) return \" + luafn + \" end\";\n\n    const_cast<lua_text_pattern *>(this)->translated = true;\n\n    int err = clua.execstring(luafn.c_str(), \"stash-search\");\n    if (err)\n    {\n        lua_text_pattern *self = const_cast<lua_text_pattern *>(this);\n        self->isvalid = self->translated = false;\n    }\n\n    return translated;\n}\n\n// ////////////////////////////////////////////////////////////////////////\n\nlua_call_throttle::lua_clua_map lua_call_throttle::lua_map;\n\n// A panic function for the Lua interpreter, usually called when it\n// runs out of memory when trying to load a file or a chunk of Lua from\n// an unprotected Lua op. The only cases of unprotected Lua loads are\n// loads of Lua code from .crawlrc, which is read at start of game.\n//\n// If there's an inordinately large .crawlrc (we're talking seriously\n// massive here) that wants more memory than we're willing to give\n// Lua, then the game will save and exit until the .crawlrc is fixed.\n//\n// Lua can also run out of memory during protected script execution,\n// such as when running a macro or some other game hook, but in such\n// cases the Lua interpreter will throw an exception instead of\n// panicking.\n//\nstatic int _clua_panic(lua_State *ls)\n{\n    UNUSED(ls);\n    if (crawl_state.need_save && !crawl_state.saving_game\n        && !crawl_state.updating_scores)\n    {\n        save_game(true);\n    }\n    return 0;\n}\n\n#ifndef NO_CUSTOM_ALLOCATOR\nstatic void *_clua_allocator(void *ud, void *ptr, size_t osize, size_t nsize)\n{\n    CLua *cl = static_cast<CLua *>(ud);\n    cl->memory_used += nsize - osize;\n\n    if (nsize > osize && cl->memory_used >= CLUA_MAX_MEMORY_USE * 1024\n        && cl->mixed_call_depth)\n    {\n        return nullptr;\n    }\n\n    if (!nsize)\n    {\n        free(ptr);\n        return nullptr;\n    }\n    else\n        return realloc(ptr, nsize);\n}\n#endif\n\nstatic void _clua_throttle_hook(lua_State *ls, lua_Debug *dbg)\n{\n    UNUSED(dbg);\n\n    CLua *lua = lua_call_throttle::find_clua(ls);\n\n    // Co-routines can create a new Lua state; in such cases, we must\n    // fudge it.\n    if (!lua)\n        lua = &clua;\n\n    if (lua)\n    {\n        if (!lua->throttle_sleep_ms)\n            lua->throttle_sleep_ms = lua->throttle_sleep_start;\n        else if (lua->throttle_sleep_ms < lua->throttle_sleep_end)\n            lua->throttle_sleep_ms *= 2;\n\n        ++lua->n_throttle_sleeps;\n\n        delay(lua->throttle_sleep_ms);\n\n        // Try to kill the annoying script.\n        if (lua->n_throttle_sleeps > CLua::MAX_THROTTLE_SLEEPS)\n        {\n            lua->n_throttle_sleeps = CLua::MAX_THROTTLE_SLEEPS;\n            luaL_error(ls, BUGGY_SCRIPT_ERROR);\n        }\n    }\n}\n\nlua_call_throttle::lua_call_throttle(CLua *_lua)\n    : lua(_lua)\n{\n    lua->init_throttle();\n    if (!lua->mixed_call_depth++)\n        lua_map[lua->state()] = lua;\n}\n\nlua_call_throttle::~lua_call_throttle()\n{\n    if (!--lua->mixed_call_depth)\n        lua_map.erase(lua->state());\n}\n\nCLua *lua_call_throttle::find_clua(lua_State *ls)\n{\n    return lookup(lua_map, ls, nullptr);\n}\n\n// This function is a replacement for Lua's in-built pcall function. It behaves\n// like pcall in all respects (as documented in the Lua 5.1 reference manual),\n// but does not allow the Lua chunk/script to catch errors thrown by the\n// Lua-throttling code. This is necessary so that we can interrupt scripts that\n// are hogging CPU.\n//\n// If we did not intercept pcall, the script could do the equivalent\n// of this:\n//\n//    while true do\n//      pcall(function () while true do end end)\n//    end\n//\n// And there's a good chance we wouldn't be able to interrupt the\n// deadloop because our errors would get caught by the pcall (more\n// levels of nesting would just increase the chance of the script\n// beating our throttling).\n//\nstatic int _clua_guarded_pcall(lua_State *ls)\n{\n    const int nargs = lua_gettop(ls);\n    const int err = lua_pcall(ls, nargs - 1, LUA_MULTRET, 0);\n\n    if (err)\n    {\n        const char *errs = lua_tostring(ls, 1);\n        if (!errs || strstr(errs, BUGGY_SCRIPT_ERROR))\n            luaL_error(ls, errs? errs : BUGGY_PCALL_ERROR);\n    }\n\n    lua_pushboolean(ls, !err);\n    lua_insert(ls, 1);\n\n    return lua_gettop(ls);\n}\n\n// Document clua globals here, as they're bound by the interpreter object\n\n/*** Pre-defined globals.\n *\n * *Note:* this is not a real module. All names described here are defined in\n * the global clua namespace.\n * @module Globals\n */\n\n/*** Load the named lua file as a chunk.\n * @tparam string filename\n * @return function chunk or nil,error\n * @function loadfile\n */\nstatic int _clua_loadfile(lua_State *ls)\n{\n    const char *file = luaL_checkstring(ls, 1);\n    if (!file)\n        return 0;\n\n    const int err = CLua::loadfile(ls, file, !CLua::is_managed_vm(ls));\n    if (err)\n    {\n        const int place = lua_gettop(ls);\n        lua_pushnil(ls);\n        lua_insert(ls, place);\n        return 2;\n    }\n    return 1;\n}\n\n/*** Load and execute the named lua file.\n * Differs from @{dofile} in that the file is run for its side effects.\n * If the execution has an error we raise that error and exit.\n * @tparam string filename\n * @treturn boolean|nil\n * @function require\n */\nstatic int _clua_require(lua_State *ls)\n{\n    const char *file = luaL_checkstring(ls, 1);\n    if (!file)\n        return 0;\n\n    CLua &vm(CLua::get_vm(ls));\n    if (vm.execfile(file, false, false) != 0)\n        luaL_error(ls, vm.error.c_str());\n\n    lua_pushboolean(ls, true);\n    return 1;\n}\n\n/*** Load and execute the named luafile, returning the result.\n * Differs from @{require} in that the file is run for a result. Errors\n * come back on the lua stack and can be handled by the caller.\n * @tparam string filename\n * @return whatever is left on the lua stack by filename\n * @function dofile\n */\nstatic int _clua_dofile(lua_State *ls)\n{\n    const char *file = luaL_checkstring(ls, 1);\n    if (!file)\n        return 0;\n\n    const int err = CLua::loadfile(ls, file, !CLua::is_managed_vm(ls));\n    if (err)\n        return lua_error(ls);\n\n    lua_call(ls, 0, LUA_MULTRET);\n    return lua_gettop(ls);\n}\n\nstring quote_lua_string(const string &s)\n{\n    return replace_all_of(replace_all_of(s, \"\\\\\", \"\\\\\\\\\"), \"\\\"\", \"\\\\\\\"\");\n}\n\nstatic string _get_persist_file()\n{\n    return Options.filename + \".persist\";\n}\n\n// ///////////////////////////////////////////////////////////////////\n\nlua_shutdown_listener::~lua_shutdown_listener()\n{\n}\n\nlua_datum::lua_datum(CLua &_lua, int stackpos, bool pop)\n    : lua(_lua), need_cleanup(true)\n{\n    // Store the datum in the registry indexed by \"this\".\n    lua_pushvalue(lua, stackpos);\n    lua_pushlightuserdata(lua, this);\n    // Move the key (this) before the value.\n    lua_insert(lua, -2);\n    lua_settable(lua, LUA_REGISTRYINDEX);\n\n    if (pop && stackpos < 0)\n        lua_pop(lua, -stackpos);\n\n    lua.add_shutdown_listener(this);\n}\n\nlua_datum::lua_datum(const lua_datum &o)\n    : lua(o.lua), need_cleanup(true)\n{\n    set_from(o);\n}\n\nvoid lua_datum::set_from(const lua_datum &o)\n{\n    lua_pushlightuserdata(lua, this);\n    o.push();\n    lua_settable(lua, LUA_REGISTRYINDEX);\n    lua.add_shutdown_listener(this);\n    need_cleanup = true;\n}\n\nconst lua_datum &lua_datum::operator = (const lua_datum &o)\n{\n    if (this != &o)\n    {\n        cleanup();\n        set_from(o);\n    }\n    return *this;\n}\n\nvoid lua_datum::push() const\n{\n    lua_pushlightuserdata(lua, const_cast<lua_datum*>(this));\n    lua_gettable(lua, LUA_REGISTRYINDEX);\n\n    // The value we saved is now on top of the Lua stack.\n}\n\nlua_datum::~lua_datum()\n{\n    cleanup();\n}\n\nvoid lua_datum::shutdown(CLua &)\n{\n    cleanup();\n}\n\nvoid lua_datum::cleanup()\n{\n    if (need_cleanup)\n    {\n        need_cleanup = false;\n        lua.remove_shutdown_listener(this);\n\n        lua_pushlightuserdata(lua, this);\n        lua_pushnil(lua);\n        lua_settable(lua, LUA_REGISTRYINDEX);\n    }\n}\n\n#define LUA_CHECK_TYPE(check) \\\n    lua_stack_cleaner clean(lua);                               \\\n    push();                                                     \\\n    return check(lua, -1)\n\nbool lua_datum::is_table() const\n{\n    LUA_CHECK_TYPE(lua_istable);\n}\n\nbool lua_datum::is_function() const\n{\n    LUA_CHECK_TYPE(lua_isfunction);\n}\n\nbool lua_datum::is_number() const\n{\n    LUA_CHECK_TYPE(lua_isnumber);\n}\n\nbool lua_datum::is_string() const\n{\n    LUA_CHECK_TYPE(lua_isstring);\n}\n\nbool lua_datum::is_udata() const\n{\n    LUA_CHECK_TYPE(lua_isuserdata);\n}\n"], "fixing_code": ["#include \"AppHdr.h\"\n\n#include \"clua.h\"\n\n#include <algorithm>\n\n#include \"cluautil.h\"\n#include \"dlua.h\"\n#include \"end.h\"\n#include \"files.h\"\n#include \"libutil.h\"\n#include \"l-libs.h\"\n#include \"maybe-bool.h\"\n#include \"misc.h\" // erase_val\n#include \"options.h\"\n#include \"state.h\"\n#include \"stringutil.h\"\n#include \"syscalls.h\"\n#include \"unicode.h\"\n#include \"version.h\"\n\n#define BUGGY_PCALL_ERROR  \"667: Malformed response to guarded pcall.\"\n#define BUGGY_SCRIPT_ERROR \"666: Killing badly-behaved Lua script.\"\n\n// 64-bit luajit does not support custom allocators. Only checking\n// TARGET_CPU_X64 because luajit doesn't support other 64-bit archs.\n#if defined(USE_LUAJIT) && defined(TARGET_CPU_X64)\n#define NO_CUSTOM_ALLOCATOR\n#endif\n\nstatic int  _clua_panic(lua_State *);\nstatic void _clua_throttle_hook(lua_State *, lua_Debug *);\n#ifndef NO_CUSTOM_ALLOCATOR\nstatic void *_clua_allocator(void *ud, void *ptr, size_t osize, size_t nsize);\n#endif\nstatic int  _clua_guarded_pcall(lua_State *);\nstatic int  _clua_require(lua_State *);\nstatic int  _clua_dofile(lua_State *);\nstatic int  _clua_loadfile(lua_State *);\nstatic string _get_persist_file();\n\nCLua::CLua(bool managed)\n    : error(), managed_vm(managed), shutting_down(false),\n      throttle_unit_lines(50000),\n      throttle_sleep_ms(0), throttle_sleep_start(2),\n      throttle_sleep_end(800), n_throttle_sleeps(0), mixed_call_depth(0),\n      lua_call_depth(0), max_mixed_call_depth(8),\n      max_lua_call_depth(100), memory_used(0),\n      _state(nullptr), sourced_files(), uniqindex(0)\n{\n}\n\nCLua::~CLua()\n{\n    // Copy the listener vector, because listeners may remove\n    // themselves from the listener list when we notify them of a\n    // shutdown.\n    const vector<lua_shutdown_listener*> slisteners = shutdown_listeners;\n    for (lua_shutdown_listener *listener : slisteners)\n        listener->shutdown(*this);\n    shutting_down = true;\n    if (_state)\n        lua_close(_state);\n}\n\nlua_State *CLua::state()\n{\n    if (!_state)\n        init_lua();\n    return _state;\n}\n\nvoid CLua::setglobal(const char *name)\n{\n    lua_setglobal(state(), name);\n}\n\nvoid CLua::getglobal(const char *name)\n{\n    lua_getglobal(state(), name);\n}\n\nstring CLua::setuniqregistry()\n{\n    char name[100];\n    snprintf(name, sizeof name, \"__cru%u\", uniqindex++);\n    lua_pushstring(state(), name);\n    lua_insert(state(), -2);\n    lua_settable(state(), LUA_REGISTRYINDEX);\n\n    return name;\n}\n\nvoid CLua::setregistry(const char *name)\n{\n    lua_pushstring(state(), name);\n    // Slide name round before the value\n    lua_insert(state(), -2);\n    lua_settable(state(), LUA_REGISTRYINDEX);\n}\n\nvoid CLua::_getregistry(lua_State *ls, const char *name)\n{\n    lua_pushstring(ls, name);\n    lua_gettable(ls, LUA_REGISTRYINDEX);\n}\n\nvoid CLua::getregistry(const char *name)\n{\n    _getregistry(state(), name);\n}\n\nvoid CLua::gc()\n{\n    lua_gc(state(), LUA_GCCOLLECT, 0);\n}\n\nvoid CLua::save(writer &outf)\n{\n    if (!_state)\n        return;\n\n    string res;\n    callfn(\"c_save\", \">s\", &res);\n    outf.write(res.c_str(), res.size());\n}\n\nvoid CLua::save_persist()\n{\n    string persist;\n    // We load persist.lua immediately before calling c_save_persist so\n    // that we know that it hasn't been overwritten by a player version.\n    execfile(\"dlua/persist.lua\", true, true);\n    callfn(\"c_save_persist\", \">s\", &persist);\n    if (Options.no_save)\n        return;\n\n    FILE *f;\n    const string persistfile = _get_persist_file();\n\n    // Don't create the file if there's no need to do so.\n    if (persist.empty() && !file_exists(persistfile))\n        return;\n\n    f = fopen_u(persistfile.c_str(), \"w\");\n    if (!f)\n    {\n        mprf(MSGCH_ERROR, \"Couldn't open %s for writing!\", persistfile.c_str());\n        return;\n    }\n\n    fprintf(f, \"-- %s %s persistent clua file\\n\"\n               \"-- WARNING: This file is entirely auto-generated.\\n\"\n            \"\\n\",\n            OUTS(CRAWL), // ok, localizing the game name is not likely\n            OUTS(Version::Long)); // nor the version string\n    fprintf(f, \"%s\", persist.c_str());\n    fclose(f);\n}\n\nvoid CLua::load_persist()\n{\n    if (Options.no_save)\n        return;\n    string persistfile = _get_persist_file();\n    if (!file_exists(persistfile))\n        return;\n    FileLineInput f(persistfile.c_str());\n    string script;\n    while (!f.eof())\n        script += f.get_line() + \"\\n\";\n    execstring(script.c_str());\n}\n\nint CLua::file_write(lua_State *ls)\n{\n    if (!lua_islightuserdata(ls, 1))\n    {\n        luaL_argerror(ls, 1, \"Expected filehandle at arg 1\");\n        return 0;\n    }\n    CLuaSave *sf = static_cast<CLuaSave *>(lua_touserdata(ls, 1));\n    if (!sf)\n        return 0;\n\n    FILE *f = sf->get_file();\n    if (!f)\n        return 0;\n\n    const char *text = luaL_checkstring(ls, 2);\n    if (text)\n        fprintf(f, \"%s\", text);\n    return 0;\n}\n\nFILE *CLua::CLuaSave::get_file()\n{\n    if (!handle)\n        handle = fopen_u(filename, \"w\");\n\n    return handle;\n}\n\nvoid CLua::set_error(int err, lua_State *ls)\n{\n    if (!err)\n    {\n        error.clear();\n        return;\n    }\n    if (!ls && !(ls = _state))\n    {\n        error = \"<LUA not initialised>\";\n        return;\n    }\n    const char *serr = lua_tostring(ls, -1);\n    lua_pop(ls, 1);\n    error = serr? serr : \"<Unknown error>\";\n}\n\nvoid CLua::init_throttle()\n{\n    if (!managed_vm)\n        return;\n\n    if (!crawl_state.throttle)\n        return;\n\n    if (throttle_unit_lines <= 0)\n        throttle_unit_lines = 500;\n\n    if (throttle_sleep_start < 1)\n        throttle_sleep_start = 1;\n\n    if (throttle_sleep_end < throttle_sleep_start)\n        throttle_sleep_end = throttle_sleep_start;\n\n    if (!mixed_call_depth)\n    {\n        lua_sethook(_state, _clua_throttle_hook,\n                    LUA_MASKCOUNT, throttle_unit_lines);\n        throttle_sleep_ms = 0;\n        n_throttle_sleeps = 0;\n    }\n}\n\nint CLua::loadbuffer(const char *buf, size_t size, const char *context)\n{\n    const int err = luaL_loadbuffer(state(), buf, size, context);\n    set_error(err, state());\n    return err;\n}\n\nint CLua::loadstring(const char *s, const char *context)\n{\n    return loadbuffer(s, strlen(s), context);\n}\n\nint CLua::execstring(const char *s, const char *context, int nresults)\n{\n    int err = 0;\n    if ((err = loadstring(s, context)))\n        return err;\n\n    lua_State *ls = state();\n    lua_call_throttle strangler(this);\n    err = lua_pcall(ls, 0, nresults, 0);\n    set_error(err, ls);\n    return err;\n}\n\nbool CLua::is_path_safe(string s, bool trusted)\n{\n    lowercase(s);\n    return s.find(\"..\") == string::npos && shell_safe(s.c_str())\n           // loading dlua stuff would spew tons of error messages\n           && (trusted || s.find(\"dlua\") != 0);\n}\n\nint CLua::loadfile(lua_State *ls, const char *filename, bool trusted,\n                   bool die_on_fail)\n{\n    if (!ls)\n        return -1;\n\n    if (!is_path_safe(filename, trusted))\n    {\n        lua_pushstring(\n            ls,\n            make_stringf(\"invalid filename: %s\", filename).c_str());\n        return -1;\n    }\n\n    string file = datafile_path(filename, die_on_fail);\n    if (file.empty())\n    {\n        lua_pushstring(ls,\n                       make_stringf(\"Can't find \\\"%s\\\"\", filename).c_str());\n        return -1;\n    }\n\n    FileLineInput f(file.c_str());\n    string script;\n    while (!f.eof())\n        script += f.get_line() + \"\\n\";\n\n    // prefixing with @ stops lua from adding [string \"%s\"]\n    return luaL_loadbuffer(ls, &script[0], script.length(),\n                           (\"@\" + file).c_str());\n}\n\nint CLua::execfile(const char *filename, bool trusted, bool die_on_fail,\n                   bool force)\n{\n    if (!force && sourced_files.count(filename))\n        return 0;\n\n    lua_State *ls = state();\n    int err = loadfile(ls, filename, trusted || !managed_vm, die_on_fail);\n    lua_call_throttle strangler(this);\n    if (!err)\n        err = lua_pcall(ls, 0, 0, 0);\n    if (!err)\n        sourced_files.insert(filename);\n    set_error(err);\n    if (die_on_fail && !error.empty())\n    {\n        end(1, false, \"Lua execfile error (%s): %s\",\n            filename, error.c_str());\n    }\n    return err;\n}\n\nbool CLua::runhook(const char *hook, const char *params, ...)\n{\n    error.clear();\n\n    lua_State *ls = state();\n    if (!ls)\n        return false;\n\n    lua_stack_cleaner clean(ls);\n\n    pushglobal(hook);\n    if (!lua_istable(ls, -1))\n        return false;\n    for (int i = 1; ; ++i)\n    {\n        lua_stack_cleaner clean2(ls);\n\n        lua_rawgeti(ls, -1, i);\n        if (!lua_isfunction(ls, -1))\n        {\n            lua_pop(ls, 1);\n            break;\n        }\n\n        // So what's on top *is* a function. Call it with the args we have.\n        va_list args;\n        va_start(args, params);\n        calltopfn(ls, params, args);\n        va_end(args);\n    }\n    return true;\n}\n\nvoid CLua::fnreturns(const char *format, ...)\n{\n    lua_State *ls = _state;\n\n    if (!format || !ls)\n        return;\n\n    va_list args;\n    va_start(args, format);\n    vfnreturns(format, args);\n    va_end(args);\n}\n\nvoid CLua::vfnreturns(const char *format, va_list args)\n{\n    lua_State *ls = _state;\n    int nrets = return_count(ls, format);\n    int sp = -nrets - 1;\n\n    const char *gs = strchr(format, '>');\n    if (gs)\n        format = gs + 1;\n    else if ((gs = strchr(format, ':')))\n        format = gs + 1;\n\n    for (const char *run = format; *run; ++run)\n    {\n        char argtype = *run;\n        ++sp;\n        switch (argtype)\n        {\n        case 'u':\n            if (lua_islightuserdata(ls, sp))\n                *(va_arg(args, void**)) = lua_touserdata(ls, sp);\n            break;\n        case 'd':\n            if (lua_isnumber(ls, sp))\n                *(va_arg(args, int*)) = luaL_safe_checkint(ls, sp);\n            break;\n        case 'b':\n            *(va_arg(args, bool *)) = lua_toboolean(ls, sp);\n            break;\n        case 's':\n            {\n                const char *s = lua_tostring(ls, sp);\n                if (s)\n                    *(va_arg(args, string *)) = s;\n                break;\n            }\n        default:\n            break;\n        }\n\n    }\n    // Pop args off the stack\n    lua_pop(ls, nrets);\n}\n\nint CLua::push_args(lua_State *ls, const char *format, va_list args,\n                    va_list *targ)\n{\n    if (!format)\n    {\n        if (targ)\n            va_copy(*targ, args);\n        return 0;\n    }\n\n    const char *cs = strchr(format, ':');\n    if (cs)\n        format = cs + 1;\n\n    int argc = 0;\n    for (const char *run = format; *run; run++)\n    {\n        if (*run == '>')\n            break;\n\n        char argtype = *run;\n        ++argc;\n        switch (argtype)\n        {\n        case 'u':       // Light userdata\n            lua_pushlightuserdata(ls, va_arg(args, void*));\n            break;\n        case 'i':\n            clua_push_item(ls, va_arg(args, item_def*));\n            break;\n        case 's':       // String\n        {\n            const char *s = va_arg(args, const char *);\n            if (s)\n                lua_pushstring(ls, s);\n            else\n                lua_pushnil(ls);\n            break;\n        }\n        case 'd':       // Integer\n            lua_pushnumber(ls, va_arg(args, int));\n            break;\n        case 'L':\n            die(\"ambiguous long in Lua push_args\");\n            lua_pushnumber(ls, va_arg(args, long));\n            break;\n        case 'b':\n            lua_pushboolean(ls, va_arg(args, int));\n            break;\n        case 'D':\n            clua_push_dgn_event(ls, va_arg(args, const dgn_event *));\n            break;\n        case 'm':\n            clua_push_map(ls, va_arg(args, map_def *));\n            break;\n        case 'M':\n            push_monster(ls, va_arg(args, monster*));\n            break;\n        case 'I':\n            lua_push_moninf(ls, va_arg(args, monster_info *));\n            break;\n        case 'A':\n            argc += push_activity_interrupt(\n                        ls, va_arg(args, activity_interrupt_data *));\n            break;\n        default:\n            --argc;\n            break;\n        }\n    }\n    if (targ)\n        va_copy(*targ, args);\n    return argc;\n}\n\nint CLua::return_count(lua_State *ls, const char *format)\n{\n    UNUSED(ls);\n\n    if (!format)\n        return 0;\n\n    const char *gs = strchr(format, '>');\n    if (gs)\n        return strlen(gs + 1);\n\n    const char *cs = strchr(format, ':');\n    if (cs && isdigit(*format))\n    {\n        char *es = nullptr;\n        int ci = strtol(format, &es, 10);\n        // We're capping return at 10 here, which is arbitrary, but avoids\n        // blowing the stack.\n        if (ci < 0)\n            ci = 0;\n        else if (ci > 10)\n            ci = 10;\n        return ci;\n    }\n    return 0;\n}\n\nbool CLua::calltopfn(lua_State *ls, const char *params, va_list args,\n                     int retc, va_list *copyto)\n{\n    // We guarantee to remove the function from the stack\n    int argc = push_args(ls, params, args, copyto);\n    if (retc == -1)\n        retc = return_count(ls, params);\n    lua_call_throttle strangler(this);\n    int err = lua_pcall(ls, argc, retc, 0);\n    set_error(err, ls);\n    return !err;\n}\n\nmaybe_bool CLua::callmbooleanfn(const char *fn, const char *params,\n                                va_list args)\n{\n    error.clear();\n    lua_State *ls = state();\n    if (!ls)\n        return MB_MAYBE;\n\n    lua_stack_cleaner clean(ls);\n\n    pushglobal(fn);\n    if (!lua_isfunction(ls, -1))\n        return MB_MAYBE;\n\n    bool ret = calltopfn(ls, params, args, 1);\n    if (!ret)\n        return MB_MAYBE;\n\n    return frombool(lua_toboolean(ls, -1));\n}\n\nmaybe_bool CLua::callmbooleanfn(const char *fn, const char *params, ...)\n{\n    va_list args;\n    va_start(args, params);\n    maybe_bool r = callmbooleanfn(fn, params, args);\n    va_end(args);\n    return r;\n}\n\nmaybe_bool CLua::callmaybefn(const char *fn, const char *params, va_list args)\n{\n    error.clear();\n    lua_State *ls = state();\n    if (!ls)\n        return MB_MAYBE;\n\n    lua_stack_cleaner clean(ls);\n\n    pushglobal(fn);\n    if (!lua_isfunction(ls, -1))\n        return MB_MAYBE;\n\n    bool ret = calltopfn(ls, params, args, 1);\n    if (!ret)\n        return MB_MAYBE;\n\n    return lua_isboolean(ls, -1) ? frombool(lua_toboolean(ls, -1)) : MB_MAYBE;\n}\n\nmaybe_bool CLua::callmaybefn(const char *fn, const char *params, ...)\n{\n    va_list args;\n    va_start(args, params);\n    maybe_bool r = callmaybefn(fn, params, args);\n    va_end(args);\n    return r;\n}\n\nbool CLua::callbooleanfn(bool def, const char *fn, const char *params, ...)\n{\n    va_list args;\n    va_start(args, params);\n    maybe_bool r = callmbooleanfn(fn, params, args);\n    va_end(args);\n    return tobool(r, def);\n}\n\nbool CLua::proc_returns(const char *par) const\n{\n    return strchr(par, '>') != nullptr;\n}\n\n// Identical to lua_getglobal for simple names, but will look up\n// \"a.b.c\" names in tables, so you can pushglobal(\"dgn.point\") and get\n// _G['dgn']['point'], as expected.\n//\n// Guarantees to push exactly one value onto the stack.\n//\nvoid CLua::pushglobal(const string &name)\n{\n    vector<string> pieces = split_string(\".\", name);\n    lua_State *ls(state());\n\n    if (pieces.empty())\n        lua_pushnil(ls);\n\n    for (unsigned i = 0, size = pieces.size(); i < size; ++i)\n    {\n        if (!i)\n            lua_getglobal(ls, pieces[i].c_str());\n        else\n        {\n            if (lua_istable(ls, -1))\n            {\n                lua_pushstring(ls, pieces[i].c_str());\n                lua_gettable(ls, -2);\n                // Swap the value we just found with the table itself.\n                lua_insert(ls, -2);\n                // And remove the table.\n                lua_pop(ls, 1);\n            }\n            else\n            {\n                // We expected a table here, but got something else. Fail.\n                lua_pop(ls, 1);\n                lua_pushnil(ls);\n                break;\n            }\n        }\n    }\n}\n\nbool CLua::callfn(const char *fn, const char *params, ...)\n{\n    error.clear();\n    lua_State *ls = state();\n    if (!ls)\n        return false;\n\n    pushglobal(fn);\n    if (!lua_isfunction(ls, -1))\n    {\n        lua_pop(ls, 1);\n        return false;\n    }\n\n    va_list args;\n    va_list fnret;\n    va_start(args, params);\n    bool ret = calltopfn(ls, params, args, -1, &fnret);\n    if (ret)\n    {\n        // If we have a > in format, gather return params now.\n        if (proc_returns(params))\n            vfnreturns(params, fnret);\n    }\n    va_end(args);\n    va_end(fnret);\n    return ret;\n}\n\nbool CLua::callfn(const char *fn, int nargs, int nret)\n{\n    error.clear();\n    lua_State *ls = state();\n    if (!ls)\n        return false;\n\n    // If a function is not provided on the stack, get the named function.\n    if (fn)\n    {\n        pushglobal(fn);\n        if (!lua_isfunction(ls, -1))\n        {\n            lua_settop(ls, -nargs - 2);\n            return false;\n        }\n\n        // Slide the function in front of its args and call it.\n        if (nargs)\n            lua_insert(ls, -nargs - 1);\n    }\n\n    lua_call_throttle strangler(this);\n    int err = lua_pcall(ls, nargs, nret, 0);\n    set_error(err, ls);\n    return !err;\n}\n\nvoid CLua::init_lua()\n{\n    if (_state)\n        return;\n\n#ifdef NO_CUSTOM_ALLOCATOR\n    // If this is likely to be used as a server, warn the builder.\n    // NOTE: #warning doesn't work on MSVC, so this will be fatal there\n    // (not that webtiles or dgamelaunch are supported on Windows anyway).\n# if defined(USE_TILE_WEB) || defined(DGAMELAUNCH)\n#   warning Detected 64-bit Luajit, disabling CLua memory throttling.\n# endif\n    _state = luaL_newstate();\n#else\n    // Throttle memory usage in managed (clua) VMs\n    _state = managed_vm? lua_newstate(_clua_allocator, this) : luaL_newstate();\n#endif\n    if (!_state)\n        end(1, false, \"Unable to create Lua state.\");\n\n    lua_stack_cleaner clean(_state);\n\n    lua_atpanic(_state, _clua_panic);\n\n#ifdef CLUA_UNRESTRICTED_LIBS\n    // open all libs -- this is not safe for public servers or releases!\n    // Intended for people writing bots and the like.\n    luaL_openlibs(_state);\n#else\n    // Selectively load some, but not all Lua core libraries.\n    //\n    // In Lua 5.1, these library setup calls are not supposed to be called\n    // directly from C. If the lua version changes, this may need to be changed:\n    // recommended practice is (apparently) checking the lua version's linit.cc\n    // and seeing how that does the full library setup.\n    //\n    // This doesn't seem to *obviously* impact the libraries we use by default,\n    // but some of the libraries we don't use will panic if not called\n    // correctly; since someone writing a bot (for example) might want to\n    // expand this, do things \"correctly\". The core lua libraries in 5.1 we are\n    // not loading are:\n    //\n    // {LUA_LOADLIBNAME, luaopen_package},    // (require etc)\n    // {LUA_IOLIBNAME, luaopen_io},           //\n    // {LUA_OSLIBNAME, luaopen_os},\n    // {LUA_DBLIBNAME, luaopen_debug},\n    const vector<pair<string, lua_CFunction>> lua_core_libs =\n    {\n        {\"\", luaopen_base}, // XX: why no name? but this is how linit.cc does it\n        {LUA_TABLIBNAME, luaopen_table},\n        {LUA_STRLIBNAME, luaopen_string},\n        {LUA_MATHLIBNAME, luaopen_math},\n    };\n\n    for (auto l : lua_core_libs)\n    {\n        lua_pushcfunction(_state, l.second);\n        lua_pushstring(_state, l.first.c_str());\n        lua_call(_state, 1, 0);\n    }\n#endif\n\n    lua_pushboolean(_state, managed_vm);\n    setregistry(\"lua_vm_is_managed\");\n\n    lua_pushlightuserdata(_state, this);\n    setregistry(\"__clua\");\n}\n\nstatic int lua_loadstring(lua_State *ls)\n{\n    const auto lua = luaL_checkstring(ls, 1);\n    if (lua[0] == 0x1b)\n        abort();\n    lua_settop(ls, 0);\n    if (luaL_loadstring(ls, lua))\n    {\n        lua_pushnil(ls);\n        lua_insert(ls, 1);\n    }\n    return lua_gettop(ls);\n}\n\nvoid CLua::init_libraries()\n{\n    lua_stack_cleaner clean(state());\n\n    lua_pushcfunction(_state, lua_loadstring);\n    lua_setglobal(_state, \"loadstring\");\n\n    // Open Crawl bindings\n    cluaopen_kills(_state);\n    cluaopen_you(_state);\n    cluaopen_item(_state);\n    cluaopen_food(_state);\n    cluaopen_crawl(_state);\n    cluaopen_file(_state);\n    cluaopen_moninf(_state);\n    cluaopen_options(_state);\n    cluaopen_travel(_state);\n    cluaopen_view(_state);\n    cluaopen_spells(_state);\n\n    cluaopen_globals(_state);\n\n    execfile(\"dlua/macro.lua\", true, true);\n\n    // All hook names must be chk_????\n    execstring(\"chk_startgame = { }\", \"base\");\n\n    lua_register(_state, \"loadfile\", _clua_loadfile);\n    lua_register(_state, \"dofile\", _clua_dofile);\n\n    lua_register(_state, \"crawl_require\", _clua_require);\n\n    execfile(\"dlua/util.lua\", true, true);\n    execfile(\"dlua/iter.lua\", true, true);\n    execfile(\"dlua/tags.lua\", true, true);\n    execfile(\"dlua/init.lua\", true, true);\n\n    if (managed_vm)\n    {\n        lua_register(_state, \"pcall\", _clua_guarded_pcall);\n        execfile(\"dlua/userbase.lua\", true, true);\n        execfile(\"dlua/persist.lua\", true, true);\n    }\n}\n\nCLua &CLua::get_vm(lua_State *ls)\n{\n    lua_stack_cleaner clean(ls);\n    _getregistry(ls, \"__clua\");\n    CLua *vm = clua_get_lightuserdata<CLua>(ls, -1);\n    if (!vm)\n        luaL_error(ls, \"Could not find matching clua for lua state\");\n    return *vm;\n}\n\nbool CLua::is_managed_vm(lua_State *ls)\n{\n    lua_stack_cleaner clean(ls);\n    lua_pushstring(ls, \"lua_vm_is_managed\");\n    lua_gettable(ls, LUA_REGISTRYINDEX);\n    return lua_toboolean(ls, -1);\n}\n\nvoid CLua::add_shutdown_listener(lua_shutdown_listener *listener)\n{\n    if (find(shutdown_listeners.begin(), shutdown_listeners.end(), listener)\n        == shutdown_listeners.end())\n    {\n        shutdown_listeners.push_back(listener);\n    }\n}\n\nvoid CLua::remove_shutdown_listener(lua_shutdown_listener *listener)\n{\n    erase_val(shutdown_listeners, listener);\n}\n\n// Can be called from within a debugger to look at the current Lua\n// call stack. (Borrowed from ToME 3)\nvoid CLua::print_stack()\n{\n    struct lua_Debug dbg;\n    int              i = 0;\n    lua_State       *L = state();\n\n    fprintf(stderr, \"\\n\");\n    while (lua_getstack(L, i++, &dbg) == 1)\n    {\n        lua_getinfo(L, \"lnuS\", &dbg);\n\n        char* file = strrchr(dbg.short_src, '/');\n        if (file == nullptr)\n            file = dbg.short_src;\n        else\n            file++;\n\n        fprintf(stderr, \"%s, function %s, line %d\\n\", file,\n                dbg.name, dbg.currentline);\n    }\n\n    fprintf(stderr, \"\\n\");\n}\n\n// //////////////////////////////////////////////////////////////////////\n// lua_text_pattern\n\n// We could simplify this a great deal by just using lex and yacc, but I\n// don't know if we want to introduce them.\n\nstruct lua_pat_op\n{\n    const char *token;\n    const char *luatok;\n\n    bool pretext;       // Does this follow a pattern?\n    bool posttext;      // Is this followed by a pattern?\n};\n\nstatic lua_pat_op pat_ops[] =\n{\n    { \"<<\", \" ( \",   false, true },\n    { \">>\", \" ) \",   true,  false },\n    { \"!!\", \" not \", false, true },\n    { \"==\", \" == \",  true,  true },\n    { \"^^\", \" ~= \",  true,  true },\n    { \"&&\", \" and \", true,  true },\n    { \"||\", \" or \",  true,  true },\n};\n\nunsigned int lua_text_pattern::lfndx = 0;\n\nbool lua_text_pattern::is_lua_pattern(const string &s)\n{\n    return any_of(begin(pat_ops), end(pat_ops),\n            [&s] (const lua_pat_op &op)\n            { return s.find(op.token) != string::npos; });\n}\n\nlua_text_pattern::lua_text_pattern(const string &_pattern)\n    : translated(false), isvalid(true), pattern(_pattern),\n      lua_fn_name(new_fn_name())\n{\n}\n\nlua_text_pattern::~lua_text_pattern()\n{\n    if (translated && !lua_fn_name.empty())\n    {\n        lua_State *ls = clua;\n        if (ls)\n        {\n            lua_pushnil(ls);\n            clua.setglobal(lua_fn_name.c_str());\n        }\n    }\n}\n\nbool lua_text_pattern::valid() const\n{\n    return translated? isvalid : translate();\n}\n\nbool lua_text_pattern::matches(const string &s) const\n{\n    if (isvalid && !translated)\n        translate();\n\n    if (!isvalid)\n        return false;\n\n    return clua.callbooleanfn(false, lua_fn_name.c_str(), \"s\", s.c_str());\n}\n\npattern_match lua_text_pattern::match_location(const string &s) const\n{\n    // lua_text_pattern is only used if a special non-regex op is detected (^F\n    // for \"armour && ego\", for instance), and in those situations, it's\n    // unclear what exactly to use for the matched text here (especially in\n    // more complicated expressions that include things like <<>>, !!, etc).\n    return matches(s)\n        ? pattern_match::succeeded(s)\n        : pattern_match::failed(s);\n}\n\nvoid lua_text_pattern::pre_pattern(string &pat, string &fn) const\n{\n    // Trim trailing spaces\n    pat.erase(pat.find_last_not_of(\" \\t\\n\\r\") + 1);\n\n    fn += \" pmatch([[\";\n    fn += pat;\n    fn += \"]], text, false) \";\n\n    pat.clear();\n}\n\nvoid lua_text_pattern::post_pattern(string &pat, string &fn) const\n{\n    pat.erase(0, pat.find_first_not_of(\" \\t\\n\\r\"));\n\n    fn += \" pmatch([[\";\n    fn += pat;\n    fn += \"]], text, false) \";\n\n    pat.clear();\n}\n\nstring lua_text_pattern::new_fn_name()\n{\n    return make_stringf(\"__ch_stash_search_%u\", lfndx++);\n}\n\nbool lua_text_pattern::translate() const\n{\n    if (translated || !isvalid)\n        return false;\n\n    if (pattern.find(\"]]\") != string::npos || pattern.find(\"[[\") != string::npos)\n        return false;\n\n    string textp;\n    string luafn;\n    const lua_pat_op *currop = nullptr;\n    for (string::size_type i = 0; i < pattern.length(); ++i)\n    {\n        bool match = false;\n        for (unsigned p = 0; p < ARRAYSZ(pat_ops); ++p)\n        {\n            const lua_pat_op &lop = pat_ops[p];\n            if (pattern.find(lop.token, i) == i)\n            {\n                match = true;\n                if (lop.pretext && (!currop || currop->posttext))\n                {\n                    if (currop)\n                        textp.erase(0, textp.find_first_not_of(\" \\r\\n\\t\"));\n                    pre_pattern(textp, luafn);\n                }\n\n                currop = &lop;\n                luafn += lop.luatok;\n\n                i += strlen(lop.token) - 1;\n\n                break;\n            }\n        }\n\n        if (match)\n            continue;\n\n        textp += pattern[i];\n    }\n\n    if (currop && currop->posttext)\n        post_pattern(textp, luafn);\n\n    luafn = \"function \" + lua_fn_name + \"(text) return \" + luafn + \" end\";\n\n    const_cast<lua_text_pattern *>(this)->translated = true;\n\n    int err = clua.execstring(luafn.c_str(), \"stash-search\");\n    if (err)\n    {\n        lua_text_pattern *self = const_cast<lua_text_pattern *>(this);\n        self->isvalid = self->translated = false;\n    }\n\n    return translated;\n}\n\n// ////////////////////////////////////////////////////////////////////////\n\nlua_call_throttle::lua_clua_map lua_call_throttle::lua_map;\n\n// A panic function for the Lua interpreter, usually called when it\n// runs out of memory when trying to load a file or a chunk of Lua from\n// an unprotected Lua op. The only cases of unprotected Lua loads are\n// loads of Lua code from .crawlrc, which is read at start of game.\n//\n// If there's an inordinately large .crawlrc (we're talking seriously\n// massive here) that wants more memory than we're willing to give\n// Lua, then the game will save and exit until the .crawlrc is fixed.\n//\n// Lua can also run out of memory during protected script execution,\n// such as when running a macro or some other game hook, but in such\n// cases the Lua interpreter will throw an exception instead of\n// panicking.\n//\nstatic int _clua_panic(lua_State *ls)\n{\n    UNUSED(ls);\n    if (crawl_state.need_save && !crawl_state.saving_game\n        && !crawl_state.updating_scores)\n    {\n        save_game(true);\n    }\n    return 0;\n}\n\n#ifndef NO_CUSTOM_ALLOCATOR\nstatic void *_clua_allocator(void *ud, void *ptr, size_t osize, size_t nsize)\n{\n    CLua *cl = static_cast<CLua *>(ud);\n    cl->memory_used += nsize - osize;\n\n    if (nsize > osize && cl->memory_used >= CLUA_MAX_MEMORY_USE * 1024\n        && cl->mixed_call_depth)\n    {\n        return nullptr;\n    }\n\n    if (!nsize)\n    {\n        free(ptr);\n        return nullptr;\n    }\n    else\n        return realloc(ptr, nsize);\n}\n#endif\n\nstatic void _clua_throttle_hook(lua_State *ls, lua_Debug *dbg)\n{\n    UNUSED(dbg);\n\n    CLua *lua = lua_call_throttle::find_clua(ls);\n\n    // Co-routines can create a new Lua state; in such cases, we must\n    // fudge it.\n    if (!lua)\n        lua = &clua;\n\n    if (lua)\n    {\n        if (!lua->throttle_sleep_ms)\n            lua->throttle_sleep_ms = lua->throttle_sleep_start;\n        else if (lua->throttle_sleep_ms < lua->throttle_sleep_end)\n            lua->throttle_sleep_ms *= 2;\n\n        ++lua->n_throttle_sleeps;\n\n        delay(lua->throttle_sleep_ms);\n\n        // Try to kill the annoying script.\n        if (lua->n_throttle_sleeps > CLua::MAX_THROTTLE_SLEEPS)\n        {\n            lua->n_throttle_sleeps = CLua::MAX_THROTTLE_SLEEPS;\n            luaL_error(ls, BUGGY_SCRIPT_ERROR);\n        }\n    }\n}\n\nlua_call_throttle::lua_call_throttle(CLua *_lua)\n    : lua(_lua)\n{\n    lua->init_throttle();\n    if (!lua->mixed_call_depth++)\n        lua_map[lua->state()] = lua;\n}\n\nlua_call_throttle::~lua_call_throttle()\n{\n    if (!--lua->mixed_call_depth)\n        lua_map.erase(lua->state());\n}\n\nCLua *lua_call_throttle::find_clua(lua_State *ls)\n{\n    return lookup(lua_map, ls, nullptr);\n}\n\n// This function is a replacement for Lua's in-built pcall function. It behaves\n// like pcall in all respects (as documented in the Lua 5.1 reference manual),\n// but does not allow the Lua chunk/script to catch errors thrown by the\n// Lua-throttling code. This is necessary so that we can interrupt scripts that\n// are hogging CPU.\n//\n// If we did not intercept pcall, the script could do the equivalent\n// of this:\n//\n//    while true do\n//      pcall(function () while true do end end)\n//    end\n//\n// And there's a good chance we wouldn't be able to interrupt the\n// deadloop because our errors would get caught by the pcall (more\n// levels of nesting would just increase the chance of the script\n// beating our throttling).\n//\nstatic int _clua_guarded_pcall(lua_State *ls)\n{\n    const int nargs = lua_gettop(ls);\n    const int err = lua_pcall(ls, nargs - 1, LUA_MULTRET, 0);\n\n    if (err)\n    {\n        const char *errs = lua_tostring(ls, 1);\n        if (!errs || strstr(errs, BUGGY_SCRIPT_ERROR))\n            luaL_error(ls, errs? errs : BUGGY_PCALL_ERROR);\n    }\n\n    lua_pushboolean(ls, !err);\n    lua_insert(ls, 1);\n\n    return lua_gettop(ls);\n}\n\n// Document clua globals here, as they're bound by the interpreter object\n\n/*** Pre-defined globals.\n *\n * *Note:* this is not a real module. All names described here are defined in\n * the global clua namespace.\n * @module Globals\n */\n\n/*** Load the named lua file as a chunk.\n * @tparam string filename\n * @return function chunk or nil,error\n * @function loadfile\n */\nstatic int _clua_loadfile(lua_State *ls)\n{\n    const char *file = luaL_checkstring(ls, 1);\n    if (!file)\n        return 0;\n\n    const int err = CLua::loadfile(ls, file, !CLua::is_managed_vm(ls));\n    if (err)\n    {\n        const int place = lua_gettop(ls);\n        lua_pushnil(ls);\n        lua_insert(ls, place);\n        return 2;\n    }\n    return 1;\n}\n\n/*** Load and execute the named lua file.\n * Differs from @{dofile} in that the file is run for its side effects.\n * If the execution has an error we raise that error and exit.\n * @tparam string filename\n * @treturn boolean|nil\n * @function require\n */\nstatic int _clua_require(lua_State *ls)\n{\n    const char *file = luaL_checkstring(ls, 1);\n    if (!file)\n        return 0;\n\n    CLua &vm(CLua::get_vm(ls));\n    if (vm.execfile(file, false, false) != 0)\n        luaL_error(ls, vm.error.c_str());\n\n    lua_pushboolean(ls, true);\n    return 1;\n}\n\n/*** Load and execute the named luafile, returning the result.\n * Differs from @{require} in that the file is run for a result. Errors\n * come back on the lua stack and can be handled by the caller.\n * @tparam string filename\n * @return whatever is left on the lua stack by filename\n * @function dofile\n */\nstatic int _clua_dofile(lua_State *ls)\n{\n    const char *file = luaL_checkstring(ls, 1);\n    if (!file)\n        return 0;\n\n    const int err = CLua::loadfile(ls, file, !CLua::is_managed_vm(ls));\n    if (err)\n        return lua_error(ls);\n\n    lua_call(ls, 0, LUA_MULTRET);\n    return lua_gettop(ls);\n}\n\nstring quote_lua_string(const string &s)\n{\n    return replace_all_of(replace_all_of(s, \"\\\\\", \"\\\\\\\\\"), \"\\\"\", \"\\\\\\\"\");\n}\n\nstatic string _get_persist_file()\n{\n    return Options.filename + \".persist\";\n}\n\n// ///////////////////////////////////////////////////////////////////\n\nlua_shutdown_listener::~lua_shutdown_listener()\n{\n}\n\nlua_datum::lua_datum(CLua &_lua, int stackpos, bool pop)\n    : lua(_lua), need_cleanup(true)\n{\n    // Store the datum in the registry indexed by \"this\".\n    lua_pushvalue(lua, stackpos);\n    lua_pushlightuserdata(lua, this);\n    // Move the key (this) before the value.\n    lua_insert(lua, -2);\n    lua_settable(lua, LUA_REGISTRYINDEX);\n\n    if (pop && stackpos < 0)\n        lua_pop(lua, -stackpos);\n\n    lua.add_shutdown_listener(this);\n}\n\nlua_datum::lua_datum(const lua_datum &o)\n    : lua(o.lua), need_cleanup(true)\n{\n    set_from(o);\n}\n\nvoid lua_datum::set_from(const lua_datum &o)\n{\n    lua_pushlightuserdata(lua, this);\n    o.push();\n    lua_settable(lua, LUA_REGISTRYINDEX);\n    lua.add_shutdown_listener(this);\n    need_cleanup = true;\n}\n\nconst lua_datum &lua_datum::operator = (const lua_datum &o)\n{\n    if (this != &o)\n    {\n        cleanup();\n        set_from(o);\n    }\n    return *this;\n}\n\nvoid lua_datum::push() const\n{\n    lua_pushlightuserdata(lua, const_cast<lua_datum*>(this));\n    lua_gettable(lua, LUA_REGISTRYINDEX);\n\n    // The value we saved is now on top of the Lua stack.\n}\n\nlua_datum::~lua_datum()\n{\n    cleanup();\n}\n\nvoid lua_datum::shutdown(CLua &)\n{\n    cleanup();\n}\n\nvoid lua_datum::cleanup()\n{\n    if (need_cleanup)\n    {\n        need_cleanup = false;\n        lua.remove_shutdown_listener(this);\n\n        lua_pushlightuserdata(lua, this);\n        lua_pushnil(lua);\n        lua_settable(lua, LUA_REGISTRYINDEX);\n    }\n}\n\n#define LUA_CHECK_TYPE(check) \\\n    lua_stack_cleaner clean(lua);                               \\\n    push();                                                     \\\n    return check(lua, -1)\n\nbool lua_datum::is_table() const\n{\n    LUA_CHECK_TYPE(lua_istable);\n}\n\nbool lua_datum::is_function() const\n{\n    LUA_CHECK_TYPE(lua_isfunction);\n}\n\nbool lua_datum::is_number() const\n{\n    LUA_CHECK_TYPE(lua_isnumber);\n}\n\nbool lua_datum::is_string() const\n{\n    LUA_CHECK_TYPE(lua_isstring);\n}\n\nbool lua_datum::is_udata() const\n{\n    LUA_CHECK_TYPE(lua_isuserdata);\n}\n"], "filenames": ["crawl-ref/source/clua.cc"], "buggy_code_start_loc": [778], "buggy_code_end_loc": [781], "fixing_code_start_loc": [779], "fixing_code_end_loc": [799], "type": "CWE-434", "message": "Dungeon Crawl Stone Soup (aka DCSS or crawl) before 0.25 allows remote attackers to execute arbitrary code via Lua bytecode embedded in an uploaded .crawlrc file.", "other": {"cve": {"id": "CVE-2020-11722", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-12T19:15:10.427", "lastModified": "2020-04-25T00:15:11.383", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Dungeon Crawl Stone Soup (aka DCSS or crawl) before 0.25 allows remote attackers to execute arbitrary code via Lua bytecode embedded in an uploaded .crawlrc file."}, {"lang": "es", "value": "Dungeon Crawl Stone Soup (tambi\u00e9n se conoce como DCSS o crawl) versiones anteriores a 0.25, permite a atacantes remotos ejecutar c\u00f3digo arbitrario por medio del c\u00f3digo de bytes de Lua insertado en un archivo .crawlrc cargado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dungeon_crawl_stone_soup_project:dungeon_crawl_stone_soup:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.25", "matchCriteriaId": "AF74FC80-D936-4ED3-875F-B6F92A1E1FCB"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-04/msg00037.html", "source": "cve@mitre.org"}, {"url": "https://dpmendenhall.blogspot.com/2020/03/dungeon-crawl-stone-soup.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/crawl/crawl/commit/768f60da87a3fa0b5561da5ade9309577c176d04", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/crawl/crawl/commit/fc522ff6eb1bbb85e3de60c60a45762571e48c28", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6QLPN635S7J3MUXLIHYK6MDAHEIASFYP/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XNXK7QE7EA7XSDDNOWX2A6MJNWOIYCTC/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/crawl/crawl/commit/768f60da87a3fa0b5561da5ade9309577c176d04"}}