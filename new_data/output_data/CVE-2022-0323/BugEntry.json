{"buggy_code": ["<?php\n\n/*\n * This file is part of Mustache.php.\n *\n * (c) 2010-2017 Justin Hileman\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**\n * Mustache Compiler class.\n *\n * This class is responsible for turning a Mustache token parse tree into normal PHP source code.\n */\nclass Mustache_Compiler\n{\n    private $pragmas;\n    private $defaultPragmas = array();\n    private $sections;\n    private $blocks;\n    private $source;\n    private $indentNextLine;\n    private $customEscape;\n    private $entityFlags;\n    private $charset;\n    private $strictCallables;\n\n    /**\n     * Compile a Mustache token parse tree into PHP source code.\n     *\n     * @param string $source          Mustache Template source code\n     * @param string $tree            Parse tree of Mustache tokens\n     * @param string $name            Mustache Template class name\n     * @param bool   $customEscape    (default: false)\n     * @param string $charset         (default: 'UTF-8')\n     * @param bool   $strictCallables (default: false)\n     * @param int    $entityFlags     (default: ENT_COMPAT)\n     *\n     * @return string Generated PHP source code\n     */\n    public function compile($source, array $tree, $name, $customEscape = false, $charset = 'UTF-8', $strictCallables = false, $entityFlags = ENT_COMPAT)\n    {\n        $this->pragmas         = $this->defaultPragmas;\n        $this->sections        = array();\n        $this->blocks          = array();\n        $this->source          = $source;\n        $this->indentNextLine  = true;\n        $this->customEscape    = $customEscape;\n        $this->entityFlags     = $entityFlags;\n        $this->charset         = $charset;\n        $this->strictCallables = $strictCallables;\n\n        return $this->writeCode($tree, $name);\n    }\n\n    /**\n     * Enable pragmas across all templates, regardless of the presence of pragma\n     * tags in the individual templates.\n     *\n     * @internal Users should set global pragmas in Mustache_Engine, not here :)\n     *\n     * @param string[] $pragmas\n     */\n    public function setPragmas(array $pragmas)\n    {\n        $this->pragmas = array();\n        foreach ($pragmas as $pragma) {\n            $this->pragmas[$pragma] = true;\n        }\n        $this->defaultPragmas = $this->pragmas;\n    }\n\n    /**\n     * Helper function for walking the Mustache token parse tree.\n     *\n     * @throws Mustache_Exception_SyntaxException upon encountering unknown token types\n     *\n     * @param array $tree  Parse tree of Mustache tokens\n     * @param int   $level (default: 0)\n     *\n     * @return string Generated PHP source code\n     */\n    private function walk(array $tree, $level = 0)\n    {\n        $code = '';\n        $level++;\n        foreach ($tree as $node) {\n            switch ($node[Mustache_Tokenizer::TYPE]) {\n                case Mustache_Tokenizer::T_PRAGMA:\n                    $this->pragmas[$node[Mustache_Tokenizer::NAME]] = true;\n                    break;\n\n                case Mustache_Tokenizer::T_SECTION:\n                    $code .= $this->section(\n                        $node[Mustache_Tokenizer::NODES],\n                        $node[Mustache_Tokenizer::NAME],\n                        isset($node[Mustache_Tokenizer::FILTERS]) ? $node[Mustache_Tokenizer::FILTERS] : array(),\n                        $node[Mustache_Tokenizer::INDEX],\n                        $node[Mustache_Tokenizer::END],\n                        $node[Mustache_Tokenizer::OTAG],\n                        $node[Mustache_Tokenizer::CTAG],\n                        $level\n                    );\n                    break;\n\n                case Mustache_Tokenizer::T_INVERTED:\n                    $code .= $this->invertedSection(\n                        $node[Mustache_Tokenizer::NODES],\n                        $node[Mustache_Tokenizer::NAME],\n                        isset($node[Mustache_Tokenizer::FILTERS]) ? $node[Mustache_Tokenizer::FILTERS] : array(),\n                        $level\n                    );\n                    break;\n\n                case Mustache_Tokenizer::T_PARTIAL:\n                    $code .= $this->partial(\n                        $node[Mustache_Tokenizer::NAME],\n                        isset($node[Mustache_Tokenizer::INDENT]) ? $node[Mustache_Tokenizer::INDENT] : '',\n                        $level\n                    );\n                    break;\n\n                case Mustache_Tokenizer::T_PARENT:\n                    $code .= $this->parent(\n                        $node[Mustache_Tokenizer::NAME],\n                        isset($node[Mustache_Tokenizer::INDENT]) ? $node[Mustache_Tokenizer::INDENT] : '',\n                        $node[Mustache_Tokenizer::NODES],\n                        $level\n                    );\n                    break;\n\n                case Mustache_Tokenizer::T_BLOCK_ARG:\n                    $code .= $this->blockArg(\n                        $node[Mustache_Tokenizer::NODES],\n                        $node[Mustache_Tokenizer::NAME],\n                        $node[Mustache_Tokenizer::INDEX],\n                        $node[Mustache_Tokenizer::END],\n                        $node[Mustache_Tokenizer::OTAG],\n                        $node[Mustache_Tokenizer::CTAG],\n                        $level\n                    );\n                    break;\n\n                case Mustache_Tokenizer::T_BLOCK_VAR:\n                    $code .= $this->blockVar(\n                        $node[Mustache_Tokenizer::NODES],\n                        $node[Mustache_Tokenizer::NAME],\n                        $node[Mustache_Tokenizer::INDEX],\n                        $node[Mustache_Tokenizer::END],\n                        $node[Mustache_Tokenizer::OTAG],\n                        $node[Mustache_Tokenizer::CTAG],\n                        $level\n                    );\n                    break;\n\n                case Mustache_Tokenizer::T_COMMENT:\n                    break;\n\n                case Mustache_Tokenizer::T_ESCAPED:\n                case Mustache_Tokenizer::T_UNESCAPED:\n                case Mustache_Tokenizer::T_UNESCAPED_2:\n                    $code .= $this->variable(\n                        $node[Mustache_Tokenizer::NAME],\n                        isset($node[Mustache_Tokenizer::FILTERS]) ? $node[Mustache_Tokenizer::FILTERS] : array(),\n                        $node[Mustache_Tokenizer::TYPE] === Mustache_Tokenizer::T_ESCAPED,\n                        $level\n                    );\n                    break;\n\n                case Mustache_Tokenizer::T_TEXT:\n                    $code .= $this->text($node[Mustache_Tokenizer::VALUE], $level);\n                    break;\n\n                default:\n                    throw new Mustache_Exception_SyntaxException(sprintf('Unknown token type: %s', $node[Mustache_Tokenizer::TYPE]), $node);\n            }\n        }\n\n        return $code;\n    }\n\n    const KLASS = '<?php\n\n        class %s extends Mustache_Template\n        {\n            private $lambdaHelper;%s\n\n            public function renderInternal(Mustache_Context $context, $indent = \\'\\')\n            {\n                $this->lambdaHelper = new Mustache_LambdaHelper($this->mustache, $context);\n                $buffer = \\'\\';\n        %s\n\n                return $buffer;\n            }\n        %s\n        %s\n        }';\n\n    const KLASS_NO_LAMBDAS = '<?php\n\n        class %s extends Mustache_Template\n        {%s\n            public function renderInternal(Mustache_Context $context, $indent = \\'\\')\n            {\n                $buffer = \\'\\';\n        %s\n\n                return $buffer;\n            }\n        }';\n\n    const STRICT_CALLABLE = 'protected $strictCallables = true;';\n\n    /**\n     * Generate Mustache Template class PHP source.\n     *\n     * @param array  $tree Parse tree of Mustache tokens\n     * @param string $name Mustache Template class name\n     *\n     * @return string Generated PHP source code\n     */\n    private function writeCode($tree, $name)\n    {\n        $code     = $this->walk($tree);\n        $sections = implode(\"\\n\", $this->sections);\n        $blocks   = implode(\"\\n\", $this->blocks);\n        $klass    = empty($this->sections) && empty($this->blocks) ? self::KLASS_NO_LAMBDAS : self::KLASS;\n\n        $callable = $this->strictCallables ? $this->prepare(self::STRICT_CALLABLE) : '';\n\n        return sprintf($this->prepare($klass, 0, false, true), $name, $callable, $code, $sections, $blocks);\n    }\n\n    const BLOCK_VAR = '\n        $blockFunction = $context->findInBlock(%s);\n        if (is_callable($blockFunction)) {\n            $buffer .= call_user_func($blockFunction, $context);\n        %s}\n    ';\n\n    const BLOCK_VAR_ELSE = '} else {%s';\n\n    /**\n     * Generate Mustache Template inheritance block variable PHP source.\n     *\n     * @param array  $nodes Array of child tokens\n     * @param string $id    Section name\n     * @param int    $start Section start offset\n     * @param int    $end   Section end offset\n     * @param string $otag  Current Mustache opening tag\n     * @param string $ctag  Current Mustache closing tag\n     * @param int    $level\n     *\n     * @return string Generated PHP source code\n     */\n    private function blockVar($nodes, $id, $start, $end, $otag, $ctag, $level)\n    {\n        $id = var_export($id, true);\n\n        $else = $this->walk($nodes, $level);\n        if ($else !== '') {\n            $else = sprintf($this->prepare(self::BLOCK_VAR_ELSE, $level + 1, false, true), $else);\n        }\n\n        return sprintf($this->prepare(self::BLOCK_VAR, $level), $id, $else);\n    }\n\n    const BLOCK_ARG = '%s => array($this, \\'block%s\\'),';\n\n    /**\n     * Generate Mustache Template inheritance block argument PHP source.\n     *\n     * @param array  $nodes Array of child tokens\n     * @param string $id    Section name\n     * @param int    $start Section start offset\n     * @param int    $end   Section end offset\n     * @param string $otag  Current Mustache opening tag\n     * @param string $ctag  Current Mustache closing tag\n     * @param int    $level\n     *\n     * @return string Generated PHP source code\n     */\n    private function blockArg($nodes, $id, $start, $end, $otag, $ctag, $level)\n    {\n        $key = $this->block($nodes);\n        $id = var_export($id, true);\n\n        return sprintf($this->prepare(self::BLOCK_ARG, $level), $id, $key);\n    }\n\n    const BLOCK_FUNCTION = '\n        public function block%s($context)\n        {\n            $indent = $buffer = \\'\\';%s\n\n            return $buffer;\n        }\n    ';\n\n    /**\n     * Generate Mustache Template inheritance block function PHP source.\n     *\n     * @param array $nodes Array of child tokens\n     *\n     * @return string key of new block function\n     */\n    private function block($nodes)\n    {\n        $code = $this->walk($nodes, 0);\n        $key = ucfirst(md5($code));\n\n        if (!isset($this->blocks[$key])) {\n            $this->blocks[$key] = sprintf($this->prepare(self::BLOCK_FUNCTION, 0), $key, $code);\n        }\n\n        return $key;\n    }\n\n    const SECTION_CALL = '\n        // %s section\n        $value = $context->%s(%s);%s\n        $buffer .= $this->section%s($context, $indent, $value);\n    ';\n\n    const SECTION = '\n        private function section%s(Mustache_Context $context, $indent, $value)\n        {\n            $buffer = \\'\\';\n\n            if (%s) {\n                $source = %s;\n                $result = (string) call_user_func($value, $source, %s);\n                if (strpos($result, \\'{{\\') === false) {\n                    $buffer .= $result;\n                } else {\n                    $buffer .= $this->mustache\n                        ->loadLambda($result%s)\n                        ->renderInternal($context);\n                }\n            } elseif (!empty($value)) {\n                $values = $this->isIterable($value) ? $value : array($value);\n                foreach ($values as $value) {\n                    $context->push($value);\n                    %s\n                    $context->pop();\n                }\n            }\n\n            return $buffer;\n        }\n    ';\n\n    /**\n     * Generate Mustache Template section PHP source.\n     *\n     * @param array    $nodes   Array of child tokens\n     * @param string   $id      Section name\n     * @param string[] $filters Array of filters\n     * @param int      $start   Section start offset\n     * @param int      $end     Section end offset\n     * @param string   $otag    Current Mustache opening tag\n     * @param string   $ctag    Current Mustache closing tag\n     * @param int      $level\n     *\n     * @return string Generated section PHP source code\n     */\n    private function section($nodes, $id, $filters, $start, $end, $otag, $ctag, $level)\n    {\n        $source   = var_export(substr($this->source, $start, $end - $start), true);\n        $callable = $this->getCallable();\n\n        if ($otag !== '{{' || $ctag !== '}}') {\n            $delimTag = var_export(sprintf('{{= %s %s =}}', $otag, $ctag), true);\n            $helper = sprintf('$this->lambdaHelper->withDelimiters(%s)', $delimTag);\n            $delims = ', ' . $delimTag;\n        } else {\n            $helper = '$this->lambdaHelper';\n            $delims = '';\n        }\n\n        $key = ucfirst(md5($delims . \"\\n\" . $source));\n\n        if (!isset($this->sections[$key])) {\n            $this->sections[$key] = sprintf($this->prepare(self::SECTION), $key, $callable, $source, $helper, $delims, $this->walk($nodes, 2));\n        }\n\n        $method  = $this->getFindMethod($id);\n        $id      = var_export($id, true);\n        $filters = $this->getFilters($filters, $level);\n\n        return sprintf($this->prepare(self::SECTION_CALL, $level), $id, $method, $id, $filters, $key);\n    }\n\n    const INVERTED_SECTION = '\n        // %s inverted section\n        $value = $context->%s(%s);%s\n        if (empty($value)) {\n            %s\n        }\n    ';\n\n    /**\n     * Generate Mustache Template inverted section PHP source.\n     *\n     * @param array    $nodes   Array of child tokens\n     * @param string   $id      Section name\n     * @param string[] $filters Array of filters\n     * @param int      $level\n     *\n     * @return string Generated inverted section PHP source code\n     */\n    private function invertedSection($nodes, $id, $filters, $level)\n    {\n        $method  = $this->getFindMethod($id);\n        $id      = var_export($id, true);\n        $filters = $this->getFilters($filters, $level);\n\n        return sprintf($this->prepare(self::INVERTED_SECTION, $level), $id, $method, $id, $filters, $this->walk($nodes, $level));\n    }\n\n    const PARTIAL_INDENT = ', $indent . %s';\n    const PARTIAL = '\n        if ($partial = $this->mustache->loadPartial(%s)) {\n            $buffer .= $partial->renderInternal($context%s);\n        }\n    ';\n\n    /**\n     * Generate Mustache Template partial call PHP source.\n     *\n     * @param string $id     Partial name\n     * @param string $indent Whitespace indent to apply to partial\n     * @param int    $level\n     *\n     * @return string Generated partial call PHP source code\n     */\n    private function partial($id, $indent, $level)\n    {\n        if ($indent !== '') {\n            $indentParam = sprintf(self::PARTIAL_INDENT, var_export($indent, true));\n        } else {\n            $indentParam = '';\n        }\n\n        return sprintf(\n            $this->prepare(self::PARTIAL, $level),\n            var_export($id, true),\n            $indentParam\n        );\n    }\n\n    const PARENT = '\n        if ($parent = $this->mustache->loadPartial(%s)) {\n            $context->pushBlockContext(array(%s\n            ));\n            $buffer .= $parent->renderInternal($context, $indent);\n            $context->popBlockContext();\n        }\n    ';\n\n    const PARENT_NO_CONTEXT = '\n        if ($parent = $this->mustache->loadPartial(%s)) {\n            $buffer .= $parent->renderInternal($context, $indent);\n        }\n    ';\n\n    /**\n     * Generate Mustache Template inheritance parent call PHP source.\n     *\n     * @param string $id       Parent tag name\n     * @param string $indent   Whitespace indent to apply to parent\n     * @param array  $children Child nodes\n     * @param int    $level\n     *\n     * @return string Generated PHP source code\n     */\n    private function parent($id, $indent, array $children, $level)\n    {\n        $realChildren = array_filter($children, array(__CLASS__, 'onlyBlockArgs'));\n\n        if (empty($realChildren)) {\n            return sprintf($this->prepare(self::PARENT_NO_CONTEXT, $level), var_export($id, true));\n        }\n\n        return sprintf(\n            $this->prepare(self::PARENT, $level),\n            var_export($id, true),\n            $this->walk($realChildren, $level + 1)\n        );\n    }\n\n    /**\n     * Helper method for filtering out non-block-arg tokens.\n     *\n     * @param array $node\n     *\n     * @return bool True if $node is a block arg token\n     */\n    private static function onlyBlockArgs(array $node)\n    {\n        return $node[Mustache_Tokenizer::TYPE] === Mustache_Tokenizer::T_BLOCK_ARG;\n    }\n\n    const VARIABLE = '\n        $value = $this->resolveValue($context->%s(%s), $context);%s\n        $buffer .= %s($value === null ? \\'\\' : %s);\n    ';\n\n    /**\n     * Generate Mustache Template variable interpolation PHP source.\n     *\n     * @param string   $id      Variable name\n     * @param string[] $filters Array of filters\n     * @param bool     $escape  Escape the variable value for output?\n     * @param int      $level\n     *\n     * @return string Generated variable interpolation PHP source\n     */\n    private function variable($id, $filters, $escape, $level)\n    {\n        $method  = $this->getFindMethod($id);\n        $id      = ($method !== 'last') ? var_export($id, true) : '';\n        $filters = $this->getFilters($filters, $level);\n        $value   = $escape ? $this->getEscape() : '$value';\n\n        return sprintf($this->prepare(self::VARIABLE, $level), $method, $id, $filters, $this->flushIndent(), $value);\n    }\n\n    const FILTER = '\n        $filter = $context->%s(%s);\n        if (!(%s)) {\n            throw new Mustache_Exception_UnknownFilterException(%s);\n        }\n        $value = call_user_func($filter, $value);%s\n    ';\n\n    /**\n     * Generate Mustache Template variable filtering PHP source.\n     *\n     * @param string[] $filters Array of filters\n     * @param int      $level\n     *\n     * @return string Generated filter PHP source\n     */\n    private function getFilters(array $filters, $level)\n    {\n        if (empty($filters)) {\n            return '';\n        }\n\n        $name     = array_shift($filters);\n        $method   = $this->getFindMethod($name);\n        $filter   = ($method !== 'last') ? var_export($name, true) : '';\n        $callable = $this->getCallable('$filter');\n        $msg      = var_export($name, true);\n\n        return sprintf($this->prepare(self::FILTER, $level), $method, $filter, $callable, $msg, $this->getFilters($filters, $level));\n    }\n\n    const LINE = '$buffer .= \"\\n\";';\n    const TEXT = '$buffer .= %s%s;';\n\n    /**\n     * Generate Mustache Template output Buffer call PHP source.\n     *\n     * @param string $text\n     * @param int    $level\n     *\n     * @return string Generated output Buffer call PHP source\n     */\n    private function text($text, $level)\n    {\n        $indentNextLine = (substr($text, -1) === \"\\n\");\n        $code = sprintf($this->prepare(self::TEXT, $level), $this->flushIndent(), var_export($text, true));\n        $this->indentNextLine = $indentNextLine;\n\n        return $code;\n    }\n\n    /**\n     * Prepare PHP source code snippet for output.\n     *\n     * @param string $text\n     * @param int    $bonus          Additional indent level (default: 0)\n     * @param bool   $prependNewline Prepend a newline to the snippet? (default: true)\n     * @param bool   $appendNewline  Append a newline to the snippet? (default: false)\n     *\n     * @return string PHP source code snippet\n     */\n    private function prepare($text, $bonus = 0, $prependNewline = true, $appendNewline = false)\n    {\n        $text = ($prependNewline ? \"\\n\" : '') . trim($text);\n        if ($prependNewline) {\n            $bonus++;\n        }\n        if ($appendNewline) {\n            $text .= \"\\n\";\n        }\n\n        return preg_replace(\"/\\n( {8})?/\", \"\\n\" . str_repeat(' ', $bonus * 4), $text);\n    }\n\n    const DEFAULT_ESCAPE = 'htmlspecialchars(%s, %s, %s)';\n    const CUSTOM_ESCAPE  = 'call_user_func($this->mustache->getEscape(), %s)';\n\n    /**\n     * Get the current escaper.\n     *\n     * @param string $value (default: '$value')\n     *\n     * @return string Either a custom callback, or an inline call to `htmlspecialchars`\n     */\n    private function getEscape($value = '$value')\n    {\n        if ($this->customEscape) {\n            return sprintf(self::CUSTOM_ESCAPE, $value);\n        }\n\n        return sprintf(self::DEFAULT_ESCAPE, $value, var_export($this->entityFlags, true), var_export($this->charset, true));\n    }\n\n    /**\n     * Select the appropriate Context `find` method for a given $id.\n     *\n     * The return value will be one of `find`, `findDot`, `findAnchoredDot` or `last`.\n     *\n     * @see Mustache_Context::find\n     * @see Mustache_Context::findDot\n     * @see Mustache_Context::last\n     *\n     * @param string $id Variable name\n     *\n     * @return string `find` method name\n     */\n    private function getFindMethod($id)\n    {\n        if ($id === '.') {\n            return 'last';\n        }\n\n        if (isset($this->pragmas[Mustache_Engine::PRAGMA_ANCHORED_DOT]) && $this->pragmas[Mustache_Engine::PRAGMA_ANCHORED_DOT]) {\n            if (substr($id, 0, 1) === '.') {\n                return 'findAnchoredDot';\n            }\n        }\n\n        if (strpos($id, '.') === false) {\n            return 'find';\n        }\n\n        return 'findDot';\n    }\n\n    const IS_CALLABLE        = '!is_string(%s) && is_callable(%s)';\n    const STRICT_IS_CALLABLE = 'is_object(%s) && is_callable(%s)';\n\n    /**\n     * Helper function to compile strict vs lax \"is callable\" logic.\n     *\n     * @param string $variable (default: '$value')\n     *\n     * @return string \"is callable\" logic\n     */\n    private function getCallable($variable = '$value')\n    {\n        $tpl = $this->strictCallables ? self::STRICT_IS_CALLABLE : self::IS_CALLABLE;\n\n        return sprintf($tpl, $variable, $variable);\n    }\n\n    const LINE_INDENT = '$indent . ';\n\n    /**\n     * Get the current $indent prefix to write to the buffer.\n     *\n     * @return string \"$indent . \" or \"\"\n     */\n    private function flushIndent()\n    {\n        if (!$this->indentNextLine) {\n            return '';\n        }\n\n        $this->indentNextLine = false;\n\n        return self::LINE_INDENT;\n    }\n}\n"], "fixing_code": ["<?php\n\n/*\n * This file is part of Mustache.php.\n *\n * (c) 2010-2017 Justin Hileman\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**\n * Mustache Compiler class.\n *\n * This class is responsible for turning a Mustache token parse tree into normal PHP source code.\n */\nclass Mustache_Compiler\n{\n    private $pragmas;\n    private $defaultPragmas = array();\n    private $sections;\n    private $blocks;\n    private $source;\n    private $indentNextLine;\n    private $customEscape;\n    private $entityFlags;\n    private $charset;\n    private $strictCallables;\n\n    /**\n     * Compile a Mustache token parse tree into PHP source code.\n     *\n     * @param string $source          Mustache Template source code\n     * @param string $tree            Parse tree of Mustache tokens\n     * @param string $name            Mustache Template class name\n     * @param bool   $customEscape    (default: false)\n     * @param string $charset         (default: 'UTF-8')\n     * @param bool   $strictCallables (default: false)\n     * @param int    $entityFlags     (default: ENT_COMPAT)\n     *\n     * @return string Generated PHP source code\n     */\n    public function compile($source, array $tree, $name, $customEscape = false, $charset = 'UTF-8', $strictCallables = false, $entityFlags = ENT_COMPAT)\n    {\n        $this->pragmas         = $this->defaultPragmas;\n        $this->sections        = array();\n        $this->blocks          = array();\n        $this->source          = $source;\n        $this->indentNextLine  = true;\n        $this->customEscape    = $customEscape;\n        $this->entityFlags     = $entityFlags;\n        $this->charset         = $charset;\n        $this->strictCallables = $strictCallables;\n\n        return $this->writeCode($tree, $name);\n    }\n\n    /**\n     * Enable pragmas across all templates, regardless of the presence of pragma\n     * tags in the individual templates.\n     *\n     * @internal Users should set global pragmas in Mustache_Engine, not here :)\n     *\n     * @param string[] $pragmas\n     */\n    public function setPragmas(array $pragmas)\n    {\n        $this->pragmas = array();\n        foreach ($pragmas as $pragma) {\n            $this->pragmas[$pragma] = true;\n        }\n        $this->defaultPragmas = $this->pragmas;\n    }\n\n    /**\n     * Helper function for walking the Mustache token parse tree.\n     *\n     * @throws Mustache_Exception_SyntaxException upon encountering unknown token types\n     *\n     * @param array $tree  Parse tree of Mustache tokens\n     * @param int   $level (default: 0)\n     *\n     * @return string Generated PHP source code\n     */\n    private function walk(array $tree, $level = 0)\n    {\n        $code = '';\n        $level++;\n        foreach ($tree as $node) {\n            switch ($node[Mustache_Tokenizer::TYPE]) {\n                case Mustache_Tokenizer::T_PRAGMA:\n                    $this->pragmas[$node[Mustache_Tokenizer::NAME]] = true;\n                    break;\n\n                case Mustache_Tokenizer::T_SECTION:\n                    $code .= $this->section(\n                        $node[Mustache_Tokenizer::NODES],\n                        $node[Mustache_Tokenizer::NAME],\n                        isset($node[Mustache_Tokenizer::FILTERS]) ? $node[Mustache_Tokenizer::FILTERS] : array(),\n                        $node[Mustache_Tokenizer::INDEX],\n                        $node[Mustache_Tokenizer::END],\n                        $node[Mustache_Tokenizer::OTAG],\n                        $node[Mustache_Tokenizer::CTAG],\n                        $level\n                    );\n                    break;\n\n                case Mustache_Tokenizer::T_INVERTED:\n                    $code .= $this->invertedSection(\n                        $node[Mustache_Tokenizer::NODES],\n                        $node[Mustache_Tokenizer::NAME],\n                        isset($node[Mustache_Tokenizer::FILTERS]) ? $node[Mustache_Tokenizer::FILTERS] : array(),\n                        $level\n                    );\n                    break;\n\n                case Mustache_Tokenizer::T_PARTIAL:\n                    $code .= $this->partial(\n                        $node[Mustache_Tokenizer::NAME],\n                        isset($node[Mustache_Tokenizer::INDENT]) ? $node[Mustache_Tokenizer::INDENT] : '',\n                        $level\n                    );\n                    break;\n\n                case Mustache_Tokenizer::T_PARENT:\n                    $code .= $this->parent(\n                        $node[Mustache_Tokenizer::NAME],\n                        isset($node[Mustache_Tokenizer::INDENT]) ? $node[Mustache_Tokenizer::INDENT] : '',\n                        $node[Mustache_Tokenizer::NODES],\n                        $level\n                    );\n                    break;\n\n                case Mustache_Tokenizer::T_BLOCK_ARG:\n                    $code .= $this->blockArg(\n                        $node[Mustache_Tokenizer::NODES],\n                        $node[Mustache_Tokenizer::NAME],\n                        $node[Mustache_Tokenizer::INDEX],\n                        $node[Mustache_Tokenizer::END],\n                        $node[Mustache_Tokenizer::OTAG],\n                        $node[Mustache_Tokenizer::CTAG],\n                        $level\n                    );\n                    break;\n\n                case Mustache_Tokenizer::T_BLOCK_VAR:\n                    $code .= $this->blockVar(\n                        $node[Mustache_Tokenizer::NODES],\n                        $node[Mustache_Tokenizer::NAME],\n                        $node[Mustache_Tokenizer::INDEX],\n                        $node[Mustache_Tokenizer::END],\n                        $node[Mustache_Tokenizer::OTAG],\n                        $node[Mustache_Tokenizer::CTAG],\n                        $level\n                    );\n                    break;\n\n                case Mustache_Tokenizer::T_COMMENT:\n                    break;\n\n                case Mustache_Tokenizer::T_ESCAPED:\n                case Mustache_Tokenizer::T_UNESCAPED:\n                case Mustache_Tokenizer::T_UNESCAPED_2:\n                    $code .= $this->variable(\n                        $node[Mustache_Tokenizer::NAME],\n                        isset($node[Mustache_Tokenizer::FILTERS]) ? $node[Mustache_Tokenizer::FILTERS] : array(),\n                        $node[Mustache_Tokenizer::TYPE] === Mustache_Tokenizer::T_ESCAPED,\n                        $level\n                    );\n                    break;\n\n                case Mustache_Tokenizer::T_TEXT:\n                    $code .= $this->text($node[Mustache_Tokenizer::VALUE], $level);\n                    break;\n\n                default:\n                    throw new Mustache_Exception_SyntaxException(sprintf('Unknown token type: %s', $node[Mustache_Tokenizer::TYPE]), $node);\n            }\n        }\n\n        return $code;\n    }\n\n    const KLASS = '<?php\n\n        class %s extends Mustache_Template\n        {\n            private $lambdaHelper;%s\n\n            public function renderInternal(Mustache_Context $context, $indent = \\'\\')\n            {\n                $this->lambdaHelper = new Mustache_LambdaHelper($this->mustache, $context);\n                $buffer = \\'\\';\n        %s\n\n                return $buffer;\n            }\n        %s\n        %s\n        }';\n\n    const KLASS_NO_LAMBDAS = '<?php\n\n        class %s extends Mustache_Template\n        {%s\n            public function renderInternal(Mustache_Context $context, $indent = \\'\\')\n            {\n                $buffer = \\'\\';\n        %s\n\n                return $buffer;\n            }\n        }';\n\n    const STRICT_CALLABLE = 'protected $strictCallables = true;';\n\n    /**\n     * Generate Mustache Template class PHP source.\n     *\n     * @param array  $tree Parse tree of Mustache tokens\n     * @param string $name Mustache Template class name\n     *\n     * @return string Generated PHP source code\n     */\n    private function writeCode($tree, $name)\n    {\n        $code     = $this->walk($tree);\n        $sections = implode(\"\\n\", $this->sections);\n        $blocks   = implode(\"\\n\", $this->blocks);\n        $klass    = empty($this->sections) && empty($this->blocks) ? self::KLASS_NO_LAMBDAS : self::KLASS;\n\n        $callable = $this->strictCallables ? $this->prepare(self::STRICT_CALLABLE) : '';\n\n        return sprintf($this->prepare($klass, 0, false, true), $name, $callable, $code, $sections, $blocks);\n    }\n\n    const BLOCK_VAR = '\n        $blockFunction = $context->findInBlock(%s);\n        if (is_callable($blockFunction)) {\n            $buffer .= call_user_func($blockFunction, $context);\n        %s}\n    ';\n\n    const BLOCK_VAR_ELSE = '} else {%s';\n\n    /**\n     * Generate Mustache Template inheritance block variable PHP source.\n     *\n     * @param array  $nodes Array of child tokens\n     * @param string $id    Section name\n     * @param int    $start Section start offset\n     * @param int    $end   Section end offset\n     * @param string $otag  Current Mustache opening tag\n     * @param string $ctag  Current Mustache closing tag\n     * @param int    $level\n     *\n     * @return string Generated PHP source code\n     */\n    private function blockVar($nodes, $id, $start, $end, $otag, $ctag, $level)\n    {\n        $id = var_export($id, true);\n\n        $else = $this->walk($nodes, $level);\n        if ($else !== '') {\n            $else = sprintf($this->prepare(self::BLOCK_VAR_ELSE, $level + 1, false, true), $else);\n        }\n\n        return sprintf($this->prepare(self::BLOCK_VAR, $level), $id, $else);\n    }\n\n    const BLOCK_ARG = '%s => array($this, \\'block%s\\'),';\n\n    /**\n     * Generate Mustache Template inheritance block argument PHP source.\n     *\n     * @param array  $nodes Array of child tokens\n     * @param string $id    Section name\n     * @param int    $start Section start offset\n     * @param int    $end   Section end offset\n     * @param string $otag  Current Mustache opening tag\n     * @param string $ctag  Current Mustache closing tag\n     * @param int    $level\n     *\n     * @return string Generated PHP source code\n     */\n    private function blockArg($nodes, $id, $start, $end, $otag, $ctag, $level)\n    {\n        $key = $this->block($nodes);\n        $id = var_export($id, true);\n\n        return sprintf($this->prepare(self::BLOCK_ARG, $level), $id, $key);\n    }\n\n    const BLOCK_FUNCTION = '\n        public function block%s($context)\n        {\n            $indent = $buffer = \\'\\';%s\n\n            return $buffer;\n        }\n    ';\n\n    /**\n     * Generate Mustache Template inheritance block function PHP source.\n     *\n     * @param array $nodes Array of child tokens\n     *\n     * @return string key of new block function\n     */\n    private function block($nodes)\n    {\n        $code = $this->walk($nodes, 0);\n        $key = ucfirst(md5($code));\n\n        if (!isset($this->blocks[$key])) {\n            $this->blocks[$key] = sprintf($this->prepare(self::BLOCK_FUNCTION, 0), $key, $code);\n        }\n\n        return $key;\n    }\n\n    const SECTION_CALL = '\n        $value = $context->%s(%s);%s\n        $buffer .= $this->section%s($context, $indent, $value);\n    ';\n\n    const SECTION = '\n        private function section%s(Mustache_Context $context, $indent, $value)\n        {\n            $buffer = \\'\\';\n\n            if (%s) {\n                $source = %s;\n                $result = (string) call_user_func($value, $source, %s);\n                if (strpos($result, \\'{{\\') === false) {\n                    $buffer .= $result;\n                } else {\n                    $buffer .= $this->mustache\n                        ->loadLambda($result%s)\n                        ->renderInternal($context);\n                }\n            } elseif (!empty($value)) {\n                $values = $this->isIterable($value) ? $value : array($value);\n                foreach ($values as $value) {\n                    $context->push($value);\n                    %s\n                    $context->pop();\n                }\n            }\n\n            return $buffer;\n        }\n    ';\n\n    /**\n     * Generate Mustache Template section PHP source.\n     *\n     * @param array    $nodes   Array of child tokens\n     * @param string   $id      Section name\n     * @param string[] $filters Array of filters\n     * @param int      $start   Section start offset\n     * @param int      $end     Section end offset\n     * @param string   $otag    Current Mustache opening tag\n     * @param string   $ctag    Current Mustache closing tag\n     * @param int      $level\n     *\n     * @return string Generated section PHP source code\n     */\n    private function section($nodes, $id, $filters, $start, $end, $otag, $ctag, $level)\n    {\n        $source   = var_export(substr($this->source, $start, $end - $start), true);\n        $callable = $this->getCallable();\n\n        if ($otag !== '{{' || $ctag !== '}}') {\n            $delimTag = var_export(sprintf('{{= %s %s =}}', $otag, $ctag), true);\n            $helper = sprintf('$this->lambdaHelper->withDelimiters(%s)', $delimTag);\n            $delims = ', ' . $delimTag;\n        } else {\n            $helper = '$this->lambdaHelper';\n            $delims = '';\n        }\n\n        $key = ucfirst(md5($delims . \"\\n\" . $source));\n\n        if (!isset($this->sections[$key])) {\n            $this->sections[$key] = sprintf($this->prepare(self::SECTION), $key, $callable, $source, $helper, $delims, $this->walk($nodes, 2));\n        }\n\n        $method  = $this->getFindMethod($id);\n        $id      = var_export($id, true);\n        $filters = $this->getFilters($filters, $level);\n\n        return sprintf($this->prepare(self::SECTION_CALL, $level), $method, $id, $filters, $key);\n    }\n\n    const INVERTED_SECTION = '\n        $value = $context->%s(%s);%s\n        if (empty($value)) {\n            %s\n        }\n    ';\n\n    /**\n     * Generate Mustache Template inverted section PHP source.\n     *\n     * @param array    $nodes   Array of child tokens\n     * @param string   $id      Section name\n     * @param string[] $filters Array of filters\n     * @param int      $level\n     *\n     * @return string Generated inverted section PHP source code\n     */\n    private function invertedSection($nodes, $id, $filters, $level)\n    {\n        $method  = $this->getFindMethod($id);\n        $id      = var_export($id, true);\n        $filters = $this->getFilters($filters, $level);\n\n        return sprintf($this->prepare(self::INVERTED_SECTION, $level), $method, $id, $filters, $this->walk($nodes, $level));\n    }\n\n    const PARTIAL_INDENT = ', $indent . %s';\n    const PARTIAL = '\n        if ($partial = $this->mustache->loadPartial(%s)) {\n            $buffer .= $partial->renderInternal($context%s);\n        }\n    ';\n\n    /**\n     * Generate Mustache Template partial call PHP source.\n     *\n     * @param string $id     Partial name\n     * @param string $indent Whitespace indent to apply to partial\n     * @param int    $level\n     *\n     * @return string Generated partial call PHP source code\n     */\n    private function partial($id, $indent, $level)\n    {\n        if ($indent !== '') {\n            $indentParam = sprintf(self::PARTIAL_INDENT, var_export($indent, true));\n        } else {\n            $indentParam = '';\n        }\n\n        return sprintf(\n            $this->prepare(self::PARTIAL, $level),\n            var_export($id, true),\n            $indentParam\n        );\n    }\n\n    const PARENT = '\n        if ($parent = $this->mustache->loadPartial(%s)) {\n            $context->pushBlockContext(array(%s\n            ));\n            $buffer .= $parent->renderInternal($context, $indent);\n            $context->popBlockContext();\n        }\n    ';\n\n    const PARENT_NO_CONTEXT = '\n        if ($parent = $this->mustache->loadPartial(%s)) {\n            $buffer .= $parent->renderInternal($context, $indent);\n        }\n    ';\n\n    /**\n     * Generate Mustache Template inheritance parent call PHP source.\n     *\n     * @param string $id       Parent tag name\n     * @param string $indent   Whitespace indent to apply to parent\n     * @param array  $children Child nodes\n     * @param int    $level\n     *\n     * @return string Generated PHP source code\n     */\n    private function parent($id, $indent, array $children, $level)\n    {\n        $realChildren = array_filter($children, array(__CLASS__, 'onlyBlockArgs'));\n\n        if (empty($realChildren)) {\n            return sprintf($this->prepare(self::PARENT_NO_CONTEXT, $level), var_export($id, true));\n        }\n\n        return sprintf(\n            $this->prepare(self::PARENT, $level),\n            var_export($id, true),\n            $this->walk($realChildren, $level + 1)\n        );\n    }\n\n    /**\n     * Helper method for filtering out non-block-arg tokens.\n     *\n     * @param array $node\n     *\n     * @return bool True if $node is a block arg token\n     */\n    private static function onlyBlockArgs(array $node)\n    {\n        return $node[Mustache_Tokenizer::TYPE] === Mustache_Tokenizer::T_BLOCK_ARG;\n    }\n\n    const VARIABLE = '\n        $value = $this->resolveValue($context->%s(%s), $context);%s\n        $buffer .= %s($value === null ? \\'\\' : %s);\n    ';\n\n    /**\n     * Generate Mustache Template variable interpolation PHP source.\n     *\n     * @param string   $id      Variable name\n     * @param string[] $filters Array of filters\n     * @param bool     $escape  Escape the variable value for output?\n     * @param int      $level\n     *\n     * @return string Generated variable interpolation PHP source\n     */\n    private function variable($id, $filters, $escape, $level)\n    {\n        $method  = $this->getFindMethod($id);\n        $id      = ($method !== 'last') ? var_export($id, true) : '';\n        $filters = $this->getFilters($filters, $level);\n        $value   = $escape ? $this->getEscape() : '$value';\n\n        return sprintf($this->prepare(self::VARIABLE, $level), $method, $id, $filters, $this->flushIndent(), $value);\n    }\n\n    const FILTER = '\n        $filter = $context->%s(%s);\n        if (!(%s)) {\n            throw new Mustache_Exception_UnknownFilterException(%s);\n        }\n        $value = call_user_func($filter, $value);%s\n    ';\n\n    /**\n     * Generate Mustache Template variable filtering PHP source.\n     *\n     * @param string[] $filters Array of filters\n     * @param int      $level\n     *\n     * @return string Generated filter PHP source\n     */\n    private function getFilters(array $filters, $level)\n    {\n        if (empty($filters)) {\n            return '';\n        }\n\n        $name     = array_shift($filters);\n        $method   = $this->getFindMethod($name);\n        $filter   = ($method !== 'last') ? var_export($name, true) : '';\n        $callable = $this->getCallable('$filter');\n        $msg      = var_export($name, true);\n\n        return sprintf($this->prepare(self::FILTER, $level), $method, $filter, $callable, $msg, $this->getFilters($filters, $level));\n    }\n\n    const LINE = '$buffer .= \"\\n\";';\n    const TEXT = '$buffer .= %s%s;';\n\n    /**\n     * Generate Mustache Template output Buffer call PHP source.\n     *\n     * @param string $text\n     * @param int    $level\n     *\n     * @return string Generated output Buffer call PHP source\n     */\n    private function text($text, $level)\n    {\n        $indentNextLine = (substr($text, -1) === \"\\n\");\n        $code = sprintf($this->prepare(self::TEXT, $level), $this->flushIndent(), var_export($text, true));\n        $this->indentNextLine = $indentNextLine;\n\n        return $code;\n    }\n\n    /**\n     * Prepare PHP source code snippet for output.\n     *\n     * @param string $text\n     * @param int    $bonus          Additional indent level (default: 0)\n     * @param bool   $prependNewline Prepend a newline to the snippet? (default: true)\n     * @param bool   $appendNewline  Append a newline to the snippet? (default: false)\n     *\n     * @return string PHP source code snippet\n     */\n    private function prepare($text, $bonus = 0, $prependNewline = true, $appendNewline = false)\n    {\n        $text = ($prependNewline ? \"\\n\" : '') . trim($text);\n        if ($prependNewline) {\n            $bonus++;\n        }\n        if ($appendNewline) {\n            $text .= \"\\n\";\n        }\n\n        return preg_replace(\"/\\n( {8})?/\", \"\\n\" . str_repeat(' ', $bonus * 4), $text);\n    }\n\n    const DEFAULT_ESCAPE = 'htmlspecialchars(%s, %s, %s)';\n    const CUSTOM_ESCAPE  = 'call_user_func($this->mustache->getEscape(), %s)';\n\n    /**\n     * Get the current escaper.\n     *\n     * @param string $value (default: '$value')\n     *\n     * @return string Either a custom callback, or an inline call to `htmlspecialchars`\n     */\n    private function getEscape($value = '$value')\n    {\n        if ($this->customEscape) {\n            return sprintf(self::CUSTOM_ESCAPE, $value);\n        }\n\n        return sprintf(self::DEFAULT_ESCAPE, $value, var_export($this->entityFlags, true), var_export($this->charset, true));\n    }\n\n    /**\n     * Select the appropriate Context `find` method for a given $id.\n     *\n     * The return value will be one of `find`, `findDot`, `findAnchoredDot` or `last`.\n     *\n     * @see Mustache_Context::find\n     * @see Mustache_Context::findDot\n     * @see Mustache_Context::last\n     *\n     * @param string $id Variable name\n     *\n     * @return string `find` method name\n     */\n    private function getFindMethod($id)\n    {\n        if ($id === '.') {\n            return 'last';\n        }\n\n        if (isset($this->pragmas[Mustache_Engine::PRAGMA_ANCHORED_DOT]) && $this->pragmas[Mustache_Engine::PRAGMA_ANCHORED_DOT]) {\n            if (substr($id, 0, 1) === '.') {\n                return 'findAnchoredDot';\n            }\n        }\n\n        if (strpos($id, '.') === false) {\n            return 'find';\n        }\n\n        return 'findDot';\n    }\n\n    const IS_CALLABLE        = '!is_string(%s) && is_callable(%s)';\n    const STRICT_IS_CALLABLE = 'is_object(%s) && is_callable(%s)';\n\n    /**\n     * Helper function to compile strict vs lax \"is callable\" logic.\n     *\n     * @param string $variable (default: '$value')\n     *\n     * @return string \"is callable\" logic\n     */\n    private function getCallable($variable = '$value')\n    {\n        $tpl = $this->strictCallables ? self::STRICT_IS_CALLABLE : self::IS_CALLABLE;\n\n        return sprintf($tpl, $variable, $variable);\n    }\n\n    const LINE_INDENT = '$indent . ';\n\n    /**\n     * Get the current $indent prefix to write to the buffer.\n     *\n     * @return string \"$indent . \" or \"\"\n     */\n    private function flushIndent()\n    {\n        if (!$this->indentNextLine) {\n            return '';\n        }\n\n        $this->indentNextLine = false;\n\n        return self::LINE_INDENT;\n    }\n}\n"], "filenames": ["src/Mustache/Compiler.php"], "buggy_code_start_loc": [323], "buggy_code_end_loc": [422], "fixing_code_start_loc": [322], "fixing_code_end_loc": [420], "type": "CWE-1336", "message": "Improper Neutralization of Special Elements Used in a Template Engine in Packagist mustache/mustache prior to 2.14.1.", "other": {"cve": {"id": "CVE-2022-0323", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-21T18:15:08.363", "lastModified": "2022-08-08T15:04:55.080", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Neutralization of Special Elements Used in a Template Engine in Packagist mustache/mustache prior to 2.14.1."}, {"lang": "es", "value": "Una Neutralizaci\u00f3n Inapropiada de Elementos Especiales Usados en un Motor de Plantillas en Packagist mustache/mustache versiones anteriores a 2.14.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1336"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mustache_project:mustache:*:*:*:*:*:php:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.14.1", "matchCriteriaId": "5A1446B2-B341-4EB2-A2EB-35882AF35791"}]}]}], "references": [{"url": "https://github.com/bobthecow/mustache.php/commit/579ffa5c96e1d292c060b3dd62811ff01ad8c24e", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/a5f5a988-aa52-4443-839d-299a63f44fb7", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bobthecow/mustache.php/commit/579ffa5c96e1d292c060b3dd62811ff01ad8c24e"}}