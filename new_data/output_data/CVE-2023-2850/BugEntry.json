{"buggy_code": ["'use strict';\n\n// eslint-disable-next-line no-redeclare\nconst io = require('socket.io-client');\n// eslint-disable-next-line no-redeclare\nconst $ = require('jquery');\n\napp = window.app || {};\n\n(function () {\n\tlet reconnecting = false;\n\n\tconst ioParams = {\n\t\treconnectionAttempts: config.maxReconnectionAttempts,\n\t\treconnectionDelay: config.reconnectionDelay,\n\t\ttransports: config.socketioTransports,\n\t\tpath: config.relative_path + '/socket.io',\n\t};\n\n\twindow.socket = io(config.websocketAddress, ioParams);\n\n\tconst oEmit = socket.emit;\n\tsocket.emit = function (event, data, callback) {\n\t\tif (typeof data === 'function') {\n\t\t\tcallback = data;\n\t\t\tdata = null;\n\t\t}\n\t\tif (typeof callback === 'function') {\n\t\t\toEmit.apply(socket, [event, data, callback]);\n\t\t\treturn;\n\t\t}\n\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\toEmit.apply(socket, [event, data, function (err, result) {\n\t\t\t\tif (err) reject(err);\n\t\t\t\telse resolve(result);\n\t\t\t}]);\n\t\t});\n\t};\n\n\tlet hooks;\n\trequire(['hooks'], function (_hooks) {\n\t\thooks = _hooks;\n\t\tif (parseInt(app.user.uid, 10) >= 0) {\n\t\t\taddHandlers();\n\t\t}\n\t});\n\n\twindow.app.reconnect = () => {\n\t\tif (socket.connected) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst reconnectEl = $('#reconnect');\n\t\t$('#reconnect-alert')\n\t\t\t.removeClass('alert-danger pointer')\n\t\t\t.addClass('alert-warning')\n\t\t\t.find('p')\n\t\t\t.translateText(`[[global:reconnecting-message, ${config.siteTitle}]]`);\n\n\t\treconnectEl.html('<i class=\"fa fa-spinner fa-spin\"></i>');\n\t\tsocket.connect();\n\t};\n\n\tfunction addHandlers() {\n\t\tsocket.on('connect', onConnect);\n\n\t\tsocket.on('disconnect', onDisconnect);\n\n\t\tsocket.io.on('reconnect_failed', function () {\n\t\t\tconst reconnectEl = $('#reconnect');\n\t\t\treconnectEl.html('<i class=\"fa fa-plug text-danger\"></i>');\n\n\t\t\t$('#reconnect-alert')\n\t\t\t\t.removeClass('alert-warning')\n\t\t\t\t.addClass('alert-danger pointer')\n\t\t\t\t.find('p')\n\t\t\t\t.translateText('[[error:socket-reconnect-failed]]')\n\t\t\t\t.one('click', app.reconnect);\n\n\t\t\t$(window).one('focus', app.reconnect);\n\t\t});\n\n\t\tsocket.on('checkSession', function (uid) {\n\t\t\tif (parseInt(uid, 10) !== parseInt(app.user.uid, 10)) {\n\t\t\t\thandleSessionMismatch();\n\t\t\t}\n\t\t});\n\t\tsocket.on('event:invalid_session', () => {\n\t\t\thandleInvalidSession();\n\t\t});\n\n\t\tsocket.on('setHostname', function (hostname) {\n\t\t\tapp.upstreamHost = hostname;\n\t\t});\n\n\t\tsocket.on('event:banned', onEventBanned);\n\t\tsocket.on('event:unbanned', onEventUnbanned);\n\t\tsocket.on('event:logout', function () {\n\t\t\trequire(['logout'], function (logout) {\n\t\t\t\tlogout();\n\t\t\t});\n\t\t});\n\t\tsocket.on('event:alert', function (params) {\n\t\t\trequire(['alerts'], function (alerts) {\n\t\t\t\talerts.alert(params);\n\t\t\t});\n\t\t});\n\t\tsocket.on('event:deprecated_call', function (data) {\n\t\t\tconsole.warn('[socket.io] ', data.eventName, 'is now deprecated in favour of', data.replacement);\n\t\t});\n\n\t\tsocket.removeAllListeners('event:nodebb.ready');\n\t\tsocket.on('event:nodebb.ready', function (data) {\n\t\t\tif ((data.hostname === app.upstreamHost) && (!app.cacheBuster || app.cacheBuster !== data['cache-buster'])) {\n\t\t\t\tapp.cacheBuster = data['cache-buster'];\n\t\t\t\trequire(['alerts'], function (alerts) {\n\t\t\t\t\talerts.alert({\n\t\t\t\t\t\talert_id: 'forum_updated',\n\t\t\t\t\t\ttitle: '[[global:updated.title]]',\n\t\t\t\t\t\tmessage: '[[global:updated.message]]',\n\t\t\t\t\t\tclickfn: function () {\n\t\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttype: 'warning',\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\tsocket.on('event:livereload', function () {\n\t\t\tif (app.user.isAdmin && !ajaxify.currentPage.match(/admin/)) {\n\t\t\t\twindow.location.reload();\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction handleInvalidSession() {\n\t\tsocket.disconnect();\n\t\trequire(['messages', 'logout'], function (messages, logout) {\n\t\t\tlogout(false);\n\t\t\tmessages.showInvalidSession();\n\t\t});\n\t}\n\n\tfunction handleSessionMismatch() {\n\t\tif (app.flags._login || app.flags._logout) {\n\t\t\treturn;\n\t\t}\n\n\t\tsocket.disconnect();\n\t\trequire(['messages'], function (messages) {\n\t\t\tmessages.showSessionMismatch();\n\t\t});\n\t}\n\n\tfunction onConnect() {\n\t\tif (!reconnecting) {\n\t\t\thooks.fire('action:connected');\n\t\t}\n\n\t\tif (reconnecting) {\n\t\t\tconst reconnectEl = $('#reconnect');\n\t\t\tconst reconnectAlert = $('#reconnect-alert');\n\n\t\t\treconnectEl.tooltip('dispose');\n\t\t\treconnectEl.html('<i class=\"fa fa-check text-success\"></i>');\n\t\t\treconnectAlert.addClass('hide');\n\t\t\treconnecting = false;\n\n\t\t\treJoinCurrentRoom();\n\n\t\t\tsocket.emit('meta.reconnected');\n\n\t\t\thooks.fire('action:reconnected');\n\n\t\t\tsetTimeout(function () {\n\t\t\t\treconnectEl.removeClass('active').addClass('hide');\n\t\t\t}, 3000);\n\t\t}\n\t}\n\n\tfunction reJoinCurrentRoom() {\n\t\tif (app.currentRoom) {\n\t\t\tconst current = app.currentRoom;\n\t\t\tapp.currentRoom = '';\n\t\t\tapp.enterRoom(current);\n\t\t}\n\t}\n\n\tfunction onReconnecting() {\n\t\treconnecting = true;\n\t\tconst reconnectEl = $('#reconnect');\n\t\tconst reconnectAlert = $('#reconnect-alert');\n\n\t\tif (!reconnectEl.hasClass('active')) {\n\t\t\treconnectEl.html('<i class=\"fa fa-spinner fa-spin\"></i>');\n\t\t\treconnectAlert.removeClass('hide');\n\t\t}\n\n\t\treconnectEl.addClass('active').removeClass('hide').tooltip({\n\t\t\tplacement: 'bottom',\n\t\t\tanimation: false,\n\t\t});\n\t}\n\n\tfunction onDisconnect() {\n\t\tsetTimeout(function () {\n\t\t\tif (socket.disconnected) {\n\t\t\t\tonReconnecting();\n\t\t\t}\n\t\t}, 2000);\n\n\t\thooks.fire('action:disconnected');\n\t}\n\n\tfunction onEventBanned(data) {\n\t\trequire(['bootbox', 'translator'], function (bootbox, translator) {\n\t\t\tconst message = data.until ?\n\t\t\t\ttranslator.compile('error:user-banned-reason-until', (new Date(data.until).toLocaleString()), data.reason) :\n\t\t\t\t'[[error:user-banned-reason, ' + data.reason + ']]';\n\t\t\ttranslator.translate(message, function (message) {\n\t\t\t\tbootbox.alert({\n\t\t\t\t\ttitle: '[[error:user-banned]]',\n\t\t\t\t\tmessage: message,\n\t\t\t\t\tcloseButton: false,\n\t\t\t\t\tcallback: function () {\n\t\t\t\t\t\twindow.location.href = config.relative_path + '/';\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tfunction onEventUnbanned() {\n\t\trequire(['bootbox'], function (bootbox) {\n\t\t\tbootbox.alert({\n\t\t\t\ttitle: '[[global:alert.unbanned]]',\n\t\t\t\tmessage: '[[global:alert.unbanned.message]]',\n\t\t\t\tcloseButton: false,\n\t\t\t\tcallback: function () {\n\t\t\t\t\twindow.location.href = config.relative_path + '/';\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t}\n\n\tif (\n\t\tconfig.socketioOrigins &&\n\t\tconfig.socketioOrigins !== '*:*' &&\n\t\tconfig.socketioOrigins.indexOf(location.hostname) === -1\n\t) {\n\t\tconsole.error(\n\t\t\t'You are accessing the forum from an unknown origin. This will likely result in websockets failing to connect. \\n' +\n\t\t\t'To fix this, set the `\"url\"` value in `config.json` to the URL at which you access the site. \\n' +\n\t\t\t'For more information, see this FAQ topic: https://community.nodebb.org/topic/13388'\n\t\t);\n\t}\n}());\n", "'use strict';\n\nconst { csrfSync } = require('csrf-sync');\n\nconst {\n\tgenerateToken,\n\tcsrfSynchronisedProtection,\n} = csrfSync({\n\tgetTokenFromRequest: (req) => {\n\t\tif (req.headers['x-csrf-token']) {\n\t\t\treturn req.headers['x-csrf-token'];\n\t\t} else if (req.body.csrf_token) {\n\t\t\treturn req.body.csrf_token;\n\t\t}\n\t},\n\tsize: 64,\n});\n\nmodule.exports = {\n\tgenerateToken,\n\tcsrfSynchronisedProtection,\n};\n", "'use strict';\n\nconst os = require('os');\nconst nconf = require('nconf');\nconst winston = require('winston');\nconst util = require('util');\nconst validator = require('validator');\nconst cookieParser = require('cookie-parser')(nconf.get('secret'));\n\nconst db = require('../database');\nconst user = require('../user');\nconst logger = require('../logger');\nconst plugins = require('../plugins');\nconst ratelimit = require('../middleware/ratelimit');\n\nconst Namespaces = Object.create(null);\n\nconst Sockets = module.exports;\n\nSockets.init = async function (server) {\n\trequireModules();\n\n\tconst SocketIO = require('socket.io').Server;\n\tconst io = new SocketIO({\n\t\tpath: `${nconf.get('relative_path')}/socket.io`,\n\t});\n\n\tif (nconf.get('isCluster')) {\n\t\tif (nconf.get('redis')) {\n\t\t\tconst adapter = await require('../database/redis').socketAdapter();\n\t\t\tio.adapter(adapter);\n\t\t} else {\n\t\t\twinston.warn('clustering detected, you should setup redis!');\n\t\t}\n\t}\n\n\tio.use(authorize);\n\n\tio.on('connection', onConnection);\n\n\tconst opts = {\n\t\ttransports: nconf.get('socket.io:transports') || ['polling', 'websocket'],\n\t\tcookie: false,\n\t};\n\t/*\n\t * Restrict socket.io listener to cookie domain. If none is set, infer based on url.\n\t * Production only so you don't get accidentally locked out.\n\t * Can be overridden via config (socket.io:origins)\n\t */\n\tif (process.env.NODE_ENV !== 'development' || nconf.get('socket.io:cors')) {\n\t\tconst origins = nconf.get('socket.io:origins');\n\t\topts.cors = nconf.get('socket.io:cors') || {\n\t\t\torigin: origins,\n\t\t\tmethods: ['GET', 'POST'],\n\t\t\tallowedHeaders: ['content-type'],\n\t\t};\n\t\twinston.info(`[socket.io] Restricting access to origin: ${origins}`);\n\t}\n\n\tio.listen(server, opts);\n\tSockets.server = io;\n};\n\nfunction onConnection(socket) {\n\tsocket.ip = (socket.request.headers['x-forwarded-for'] || socket.request.connection.remoteAddress || '').split(',')[0];\n\tsocket.request.ip = socket.ip;\n\tlogger.io_one(socket, socket.uid);\n\n\tonConnect(socket);\n\tsocket.onAny((event, ...args) => {\n\t\tconst payload = { data: [event].concat(args) };\n\t\tconst als = require('../als');\n\t\tals.run({ uid: socket.uid }, onMessage, socket, payload);\n\t});\n\n\tsocket.on('disconnect', () => {\n\t\tonDisconnect(socket);\n\t});\n}\n\nfunction onDisconnect(socket) {\n\trequire('./uploads').clear(socket.id);\n\tplugins.hooks.fire('action:sockets.disconnect', { socket: socket });\n}\n\nasync function onConnect(socket) {\n\ttry {\n\t\tawait validateSession(socket, '[[error:invalid-session]]');\n\t} catch (e) {\n\t\tif (e.message === '[[error:invalid-session]]') {\n\t\t\tsocket.emit('event:invalid_session');\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (socket.uid) {\n\t\tsocket.join(`uid_${socket.uid}`);\n\t\tsocket.join('online_users');\n\t} else {\n\t\tsocket.join('online_guests');\n\t}\n\n\tsocket.join(`sess_${socket.request.signedCookies[nconf.get('sessionKey')]}`);\n\tsocket.emit('checkSession', socket.uid);\n\tsocket.emit('setHostname', os.hostname());\n\tplugins.hooks.fire('action:sockets.connect', { socket: socket });\n}\n\nasync function onMessage(socket, payload) {\n\tif (!payload.data.length) {\n\t\treturn winston.warn('[socket.io] Empty payload');\n\t}\n\n\tlet eventName = payload.data[0];\n\tconst params = typeof payload.data[1] === 'function' ? {} : payload.data[1];\n\tconst callback = typeof payload.data[payload.data.length - 1] === 'function' ? payload.data[payload.data.length - 1] : function () {};\n\n\ttry {\n\t\tif (!eventName) {\n\t\t\treturn winston.warn('[socket.io] Empty method name');\n\t\t}\n\n\t\tif (typeof eventName !== 'string') {\n\t\t\teventName = typeof eventName;\n\t\t\tconst escapedName = validator.escape(eventName);\n\t\t\treturn callback({ message: `[[error:invalid-event, ${escapedName}]]` });\n\t\t}\n\n\t\tconst parts = eventName.split('.');\n\t\tconst namespace = parts[0];\n\t\tconst methodToCall = parts.reduce((prev, cur) => {\n\t\t\tif (prev !== null && prev[cur] && (!prev.hasOwnProperty || prev.hasOwnProperty(cur))) {\n\t\t\t\treturn prev[cur];\n\t\t\t}\n\t\t\treturn null;\n\t\t}, Namespaces);\n\n\t\tif (!methodToCall || typeof methodToCall !== 'function') {\n\t\t\tif (process.env.NODE_ENV === 'development') {\n\t\t\t\twinston.warn(`[socket.io] Unrecognized message: ${eventName}`);\n\t\t\t}\n\t\t\tconst escapedName = validator.escape(String(eventName));\n\t\t\treturn callback({ message: `[[error:invalid-event, ${escapedName}]]` });\n\t\t}\n\n\t\tsocket.previousEvents = socket.previousEvents || [];\n\t\tsocket.previousEvents.push(eventName);\n\t\tif (socket.previousEvents.length > 20) {\n\t\t\tsocket.previousEvents.shift();\n\t\t}\n\n\t\tif (!eventName.startsWith('admin.') && ratelimit.isFlooding(socket)) {\n\t\t\twinston.warn(`[socket.io] Too many emits! Disconnecting uid : ${socket.uid}. Events : ${socket.previousEvents}`);\n\t\t\treturn socket.disconnect();\n\t\t}\n\n\t\tawait checkMaintenance(socket);\n\t\tawait validateSession(socket, '[[error:revalidate-failure]]');\n\n\t\tif (Namespaces[namespace].before) {\n\t\t\tawait Namespaces[namespace].before(socket, eventName, params);\n\t\t}\n\n\t\tif (methodToCall.constructor && methodToCall.constructor.name === 'AsyncFunction') {\n\t\t\tconst result = await methodToCall(socket, params);\n\t\t\tcallback(null, result);\n\t\t} else {\n\t\t\tmethodToCall(socket, params, (err, result) => {\n\t\t\t\tcallback(err ? { message: err.message } : null, result);\n\t\t\t});\n\t\t}\n\t} catch (err) {\n\t\twinston.error(`${eventName}\\n${err.stack ? err.stack : err.message}`);\n\t\tcallback({ message: err.message });\n\t}\n}\n\nfunction requireModules() {\n\tconst modules = [\n\t\t'admin', 'categories', 'groups', 'meta', 'modules',\n\t\t'notifications', 'plugins', 'posts', 'topics', 'user',\n\t\t'blacklist', 'uploads',\n\t];\n\n\tmodules.forEach((module) => {\n\t\tNamespaces[module] = require(`./${module}`);\n\t});\n}\n\nasync function checkMaintenance(socket) {\n\tconst meta = require('../meta');\n\tif (!meta.config.maintenanceMode) {\n\t\treturn;\n\t}\n\tconst isAdmin = await user.isAdministrator(socket.uid);\n\tif (isAdmin) {\n\t\treturn;\n\t}\n\tconst validator = require('validator');\n\tthrow new Error(`[[pages:maintenance.text, ${validator.escape(String(meta.config.title || 'NodeBB'))}]]`);\n}\n\nconst getSessionAsync = util.promisify(\n\t(sid, callback) => db.sessionStore.get(sid, (err, sessionObj) => callback(err, sessionObj || null))\n);\n\nasync function validateSession(socket, errorMsg) {\n\tconst req = socket.request;\n\tconst { sessionId } = await plugins.hooks.fire('filter:sockets.sessionId', {\n\t\tsessionId: req.signedCookies ? req.signedCookies[nconf.get('sessionKey')] : null,\n\t\trequest: req,\n\t});\n\n\tif (!sessionId) {\n\t\treturn;\n\t}\n\n\tconst sessionData = await getSessionAsync(sessionId);\n\n\tif (!sessionData) {\n\t\tthrow new Error(errorMsg);\n\t}\n\n\tawait plugins.hooks.fire('static:sockets.validateSession', {\n\t\treq: req,\n\t\tsocket: socket,\n\t\tsession: sessionData,\n\t});\n}\n\nconst cookieParserAsync = util.promisify((req, callback) => cookieParser(req, {}, err => callback(err)));\n\nasync function authorize(socket, callback) {\n\tconst { request } = socket;\n\n\tif (!request) {\n\t\treturn callback(new Error('[[error:not-authorized]]'));\n\t}\n\n\tawait cookieParserAsync(request);\n\n\tconst { sessionId } = await plugins.hooks.fire('filter:sockets.sessionId', {\n\t\tsessionId: request.signedCookies ? request.signedCookies[nconf.get('sessionKey')] : null,\n\t\trequest: request,\n\t});\n\n\tconst sessionData = await getSessionAsync(sessionId);\n\n\tif (sessionData && sessionData.passport && sessionData.passport.user) {\n\t\trequest.session = sessionData;\n\t\tsocket.uid = parseInt(sessionData.passport.user, 10);\n\t} else {\n\t\tsocket.uid = 0;\n\t}\n\trequest.uid = socket.uid;\n\tcallback();\n}\n\nSockets.in = function (room) {\n\treturn Sockets.server && Sockets.server.in(room);\n};\n\nSockets.getUserSocketCount = function (uid) {\n\treturn Sockets.getCountInRoom(`uid_${uid}`);\n};\n\nSockets.getCountInRoom = function (room) {\n\tif (!Sockets.server) {\n\t\treturn 0;\n\t}\n\tconst roomMap = Sockets.server.sockets.adapter.rooms.get(room);\n\treturn roomMap ? roomMap.size : 0;\n};\n\nSockets.warnDeprecated = (socket, replacement) => {\n\tif (socket.previousEvents && socket.emit) {\n\t\tsocket.emit('event:deprecated_call', {\n\t\t\teventName: socket.previousEvents[socket.previousEvents.length - 1],\n\t\t\treplacement: replacement,\n\t\t});\n\t}\n\twinston.warn(`[deprecated]\\n ${new Error('-').stack.split('\\n').slice(2, 5).join('\\n')}\\n     use ${replacement}`);\n};\n", "'use strict';\n\nconst request = require('request');\nconst requestAsync = require('request-promise-native');\nconst nconf = require('nconf');\nconst fs = require('fs');\nconst winston = require('winston');\n\nconst utils = require('../../src/utils');\n\nconst helpers = module.exports;\n\nhelpers.getCsrfToken = async (jar) => {\n\tconst { csrf_token: token } = await requestAsync({\n\t\turl: `${nconf.get('url')}/api/config`,\n\t\tjson: true,\n\t\tjar,\n\t});\n\n\treturn token;\n};\n\nhelpers.request = async function (method, uri, options) {\n\tconst ignoreMethods = ['GET', 'HEAD', 'OPTIONS'];\n\tconst lowercaseMethod = String(method).toLowerCase();\n\tlet csrf_token;\n\tif (!ignoreMethods.some(method => method.toLowerCase() === lowercaseMethod)) {\n\t\tcsrf_token = await helpers.getCsrfToken(options.jar);\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\toptions.headers = options.headers || {};\n\t\tif (csrf_token) {\n\t\t\toptions.headers['x-csrf-token'] = csrf_token;\n\t\t}\n\t\trequest[lowercaseMethod](`${nconf.get('url')}${uri}`, options, (err, res, body) => {\n\t\t\tif (err) reject(err);\n\t\t\telse resolve({ res, body });\n\t\t});\n\t});\n};\n\nhelpers.loginUser = async (username, password, payload = {}) => {\n\tconst jar = request.jar();\n\tconst form = { username, password, ...payload };\n\n\tconst { statusCode, body: configBody } = await requestAsync({\n\t\turl: `${nconf.get('url')}/api/config`,\n\t\tjson: true,\n\t\tjar: jar,\n\t\tfollowRedirect: false,\n\t\tsimple: false,\n\t\tresolveWithFullResponse: true,\n\t});\n\n\tif (statusCode !== 200) {\n\t\tthrow new Error('[[error:invalid-response]]');\n\t}\n\n\tconst { csrf_token } = configBody;\n\tconst res = await requestAsync.post(`${nconf.get('url')}/login`, {\n\t\tform,\n\t\tjson: true,\n\t\tjar: jar,\n\t\tfollowRedirect: false,\n\t\tsimple: false,\n\t\tresolveWithFullResponse: true,\n\t\theaders: {\n\t\t\t'x-csrf-token': csrf_token,\n\t\t},\n\t});\n\n\treturn { jar, res, body: res.body, csrf_token: csrf_token };\n};\n\nhelpers.logoutUser = function (jar, callback) {\n\trequest({\n\t\turl: `${nconf.get('url')}/api/config`,\n\t\tjson: true,\n\t\tjar: jar,\n\t}, (err, response, body) => {\n\t\tif (err) {\n\t\t\treturn callback(err, response, body);\n\t\t}\n\n\t\trequest.post(`${nconf.get('url')}/logout`, {\n\t\t\tform: {},\n\t\t\tjson: true,\n\t\t\tjar: jar,\n\t\t\theaders: {\n\t\t\t\t'x-csrf-token': body.csrf_token,\n\t\t\t},\n\t\t}, (err, response, body) => {\n\t\t\tcallback(err, response, body);\n\t\t});\n\t});\n};\n\nhelpers.connectSocketIO = function (res, callback) {\n\tconst io = require('socket.io-client');\n\tlet cookies = res.headers['set-cookie'];\n\tcookies = cookies.filter(c => /express.sid=[^;]+;/.test(c));\n\tconst cookie = cookies[0];\n\tconst socket = io(nconf.get('base_url'), {\n\t\tpath: `${nconf.get('relative_path')}/socket.io`,\n\t\textraHeaders: {\n\t\t\tOrigin: nconf.get('url'),\n\t\t\tCookie: cookie,\n\t\t},\n\t});\n\n\tsocket.on('connect', () => {\n\t\tcallback(null, socket);\n\t});\n\n\tsocket.on('error', (err) => {\n\t\tcallback(err);\n\t});\n};\n\nhelpers.uploadFile = function (uploadEndPoint, filePath, body, jar, csrf_token, callback) {\n\tlet formData = {\n\t\tfiles: [\n\t\t\tfs.createReadStream(filePath),\n\t\t],\n\t};\n\tformData = utils.merge(formData, body);\n\trequest.post({\n\t\turl: uploadEndPoint,\n\t\tformData: formData,\n\t\tjson: true,\n\t\tjar: jar,\n\t\theaders: {\n\t\t\t'x-csrf-token': csrf_token,\n\t\t},\n\t}, (err, res, body) => {\n\t\tif (err) {\n\t\t\treturn callback(err);\n\t\t}\n\t\tif (res.statusCode !== 200) {\n\t\t\twinston.error(JSON.stringify(body));\n\t\t}\n\t\tcallback(null, res, body);\n\t});\n};\n\nhelpers.registerUser = function (data, callback) {\n\tconst jar = request.jar();\n\trequest({\n\t\turl: `${nconf.get('url')}/api/config`,\n\t\tjson: true,\n\t\tjar: jar,\n\t}, (err, response, body) => {\n\t\tif (err) {\n\t\t\treturn callback(err);\n\t\t}\n\n\t\tif (!data.hasOwnProperty('password-confirm')) {\n\t\t\tdata['password-confirm'] = data.password;\n\t\t}\n\n\t\trequest.post(`${nconf.get('url')}/register`, {\n\t\t\tform: data,\n\t\t\tjson: true,\n\t\t\tjar: jar,\n\t\t\theaders: {\n\t\t\t\t'x-csrf-token': body.csrf_token,\n\t\t\t},\n\t\t}, (err, response, body) => {\n\t\t\tcallback(err, jar, response, body);\n\t\t});\n\t});\n};\n\n// http://stackoverflow.com/a/14387791/583363\nhelpers.copyFile = function (source, target, callback) {\n\tlet cbCalled = false;\n\n\tconst rd = fs.createReadStream(source);\n\trd.on('error', (err) => {\n\t\tdone(err);\n\t});\n\tconst wr = fs.createWriteStream(target);\n\twr.on('error', (err) => {\n\t\tdone(err);\n\t});\n\twr.on('close', () => {\n\t\tdone();\n\t});\n\trd.pipe(wr);\n\n\tfunction done(err) {\n\t\tif (!cbCalled) {\n\t\t\tcallback(err);\n\t\t\tcbCalled = true;\n\t\t}\n\t}\n};\n\nhelpers.invite = async function (body, uid, jar, csrf_token) {\n\tconsole.log('making call');\n\tconst res = await requestAsync.post(`${nconf.get('url')}/api/v3/users/${uid}/invites`, {\n\t\tjar: jar,\n\t\t// using \"form\" since client \"api\" module make requests with \"application/x-www-form-urlencoded\" content-type\n\t\tform: body,\n\t\theaders: {\n\t\t\t'x-csrf-token': csrf_token,\n\t\t},\n\t\tsimple: false,\n\t\tresolveWithFullResponse: true,\n\t});\n\tconsole.log(res.statusCode, res.body);\n\n\tres.body = JSON.parse(res.body);\n\treturn { res, body };\n};\n\nhelpers.createFolder = function (path, folderName, jar, csrf_token) {\n\treturn requestAsync.put(`${nconf.get('url')}/api/v3/files/folder`, {\n\t\tjar,\n\t\tbody: {\n\t\t\tpath,\n\t\t\tfolderName,\n\t\t},\n\t\tjson: true,\n\t\theaders: {\n\t\t\t'x-csrf-token': csrf_token,\n\t\t},\n\t\tsimple: false,\n\t\tresolveWithFullResponse: true,\n\t});\n};\n\nrequire('../../src/promisify')(helpers);\n", "'use strict';\n\n// see https://gist.github.com/jfromaniello/4087861#gistcomment-1447029\n\n\nprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';\n\nconst util = require('util');\n\nconst sleep = util.promisify(setTimeout);\nconst assert = require('assert');\nconst async = require('async');\nconst nconf = require('nconf');\nconst request = require('request');\n\nconst cookies = request.jar();\n\nconst db = require('./mocks/databasemock');\nconst user = require('../src/user');\nconst groups = require('../src/groups');\nconst categories = require('../src/categories');\nconst helpers = require('./helpers');\nconst meta = require('../src/meta');\nconst events = require('../src/events');\n\nconst socketAdmin = require('../src/socket.io/admin');\n\ndescribe('socket.io', () => {\n\tlet io;\n\tlet cid;\n\tlet tid;\n\tlet adminUid;\n\tlet regularUid;\n\n\tbefore(async () => {\n\t\tconst data = await Promise.all([\n\t\t\tuser.create({ username: 'admin', password: 'adminpwd' }),\n\t\t\tuser.create({ username: 'regular', password: 'regularpwd' }),\n\t\t\tcategories.create({\n\t\t\t\tname: 'Test Category',\n\t\t\t\tdescription: 'Test category created by testing script',\n\t\t\t}),\n\t\t]);\n\t\tadminUid = data[0];\n\t\tawait groups.join('administrators', data[0]);\n\n\t\tregularUid = data[1];\n\t\tawait user.setUserField(regularUid, 'email', 'regular@test.com');\n\t\tawait user.email.confirmByUid(regularUid);\n\n\t\tcid = data[2].cid;\n\t});\n\n\n\tit('should connect and auth properly', (done) => {\n\t\trequest.get({\n\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\tjar: cookies,\n\t\t\tjson: true,\n\t\t}, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\n\t\t\trequest.post(`${nconf.get('url')}/login`, {\n\t\t\t\tjar: cookies,\n\t\t\t\tform: {\n\t\t\t\t\tusername: 'admin',\n\t\t\t\t\tpassword: 'adminpwd',\n\t\t\t\t},\n\t\t\t\theaders: {\n\t\t\t\t\t'x-csrf-token': body.csrf_token,\n\t\t\t\t},\n\t\t\t\tjson: true,\n\t\t\t}, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\thelpers.connectSocketIO(res, (err, _io) => {\n\t\t\t\t\tio = _io;\n\t\t\t\t\tassert.ifError(err);\n\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should return error for unknown event', (done) => {\n\t\tio.emit('unknown.event', (err) => {\n\t\t\tassert(err);\n\t\t\tassert.equal(err.message, '[[error:invalid-event, unknown.event]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should return error for unknown event', (done) => {\n\t\tio.emit('user.gdpr.__proto__.constructor.toString', (err) => {\n\t\t\tassert(err);\n\t\t\tassert.equal(err.message, '[[error:invalid-event, user.gdpr.__proto__.constructor.toString]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should return error for unknown event', (done) => {\n\t\tio.emit('constructor.toString', (err) => {\n\t\t\tassert(err);\n\t\t\tassert.equal(err.message, '[[error:invalid-event, constructor.toString]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should return error for invalid eventName type', (done) => {\n\t\tconst eventName = ['topics.loadMoreTags'];\n\t\tio.emit(eventName, (err) => {\n\t\t\tassert.strictEqual(err.message, `[[error:invalid-event, object]]`);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get installed themes', (done) => {\n\t\tconst themes = ['nodebb-theme-persona'];\n\t\tio.emit('admin.themes.getInstalled', (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(data);\n\t\t\tconst installed = data.map(theme => theme.id);\n\t\t\tthemes.forEach((theme) => {\n\t\t\t\tassert(installed.includes(theme));\n\t\t\t});\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should ban a user', async () => {\n\t\tconst apiUser = require('../src/api/users');\n\t\tawait apiUser.ban({ uid: adminUid }, { uid: regularUid, reason: 'spammer' });\n\t\tconst data = await user.getLatestBanInfo(regularUid);\n\t\tassert(data.uid);\n\t\tassert(data.timestamp);\n\t\tassert(data.hasOwnProperty('banned_until'));\n\t\tassert(data.hasOwnProperty('banned_until_readable'));\n\t\tassert.equal(data.reason, 'spammer');\n\t});\n\n\tit('should return ban reason', (done) => {\n\t\tuser.bans.getReason(regularUid, (err, reason) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(reason, 'spammer');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should unban a user', async () => {\n\t\tconst apiUser = require('../src/api/users');\n\t\tawait apiUser.unban({ uid: adminUid }, { uid: regularUid });\n\t\tconst isBanned = await user.bans.isBanned(regularUid);\n\t\tassert(!isBanned);\n\t});\n\n\tit('should make user admin', (done) => {\n\t\tsocketAdmin.user.makeAdmins({ uid: adminUid }, [regularUid], (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tgroups.isMember(regularUid, 'administrators', (err, isMember) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(isMember);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should make user non-admin', (done) => {\n\t\tsocketAdmin.user.removeAdmins({ uid: adminUid }, [regularUid], (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tgroups.isMember(regularUid, 'administrators', (err, isMember) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(!isMember);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('user create/delete', () => {\n\t\tlet uid;\n\t\tconst apiUsers = require('../src/api/users');\n\t\tit('should create a user', async () => {\n\t\t\tconst userData = await apiUsers.create({ uid: adminUid }, { username: 'foo1' });\n\t\t\tuid = userData.uid;\n\t\t\tconst isMember = await groups.isMember(userData.uid, 'registered-users');\n\t\t\tassert(isMember);\n\t\t});\n\n\t\tit('should delete users', async () => {\n\t\t\tawait apiUsers.delete({ uid: adminUid }, { uid });\n\t\t\tawait sleep(500);\n\t\t\tconst isMember = await groups.isMember(uid, 'registered-users');\n\t\t\tassert(!isMember);\n\t\t});\n\n\t\tit('should error if user does not exist', async () => {\n\t\t\tlet err;\n\t\t\ttry {\n\t\t\t\tawait apiUsers.deleteMany({ uid: adminUid }, { uids: [uid] });\n\t\t\t} catch (_err) {\n\t\t\t\terr = _err;\n\t\t\t}\n\t\t\tassert.strictEqual(err.message, '[[error:no-user]]');\n\t\t});\n\n\t\tit('should delete users and their content', async () => {\n\t\t\tconst userData = await apiUsers.create({ uid: adminUid }, { username: 'foo2' });\n\t\t\tawait apiUsers.deleteMany({ uid: adminUid }, { uids: [userData.uid] });\n\t\t\tawait sleep(500);\n\t\t\tconst isMember = await groups.isMember(userData.uid, 'registered-users');\n\t\t\tassert(!isMember);\n\t\t});\n\n\t\tit('should error with invalid data', async () => {\n\t\t\tlet err;\n\t\t\ttry {\n\t\t\t\tawait apiUsers.create({ uid: adminUid }, null);\n\t\t\t} catch (_err) {\n\t\t\t\terr = _err;\n\t\t\t}\n\t\t\tassert.strictEqual(err.message, '[[error:invalid-data]]');\n\t\t});\n\t});\n\n\tit('should load user groups', async () => {\n\t\tconst { users } = await socketAdmin.user.loadGroups({ uid: adminUid }, [adminUid]);\n\t\tassert.strictEqual(users[0].username, 'admin');\n\t\tassert(Array.isArray(users[0].groups));\n\t});\n\n\tit('should reset lockouts', (done) => {\n\t\tsocketAdmin.user.resetLockouts({ uid: adminUid }, [regularUid], (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('validation emails', () => {\n\t\tconst plugins = require('../src/plugins');\n\n\t\tasync function dummyEmailerHook(data) {\n\t\t\t// pretend to handle sending emails\n\t\t}\n\t\tbefore(() => {\n\t\t\t// Attach an emailer hook so related requests do not error\n\t\t\tplugins.hooks.register('emailer-test', {\n\t\t\t\thook: 'filter:email.send',\n\t\t\t\tmethod: dummyEmailerHook,\n\t\t\t});\n\t\t});\n\t\tafter(() => {\n\t\t\tplugins.hooks.unregister('emailer-test', 'filter:email.send');\n\t\t});\n\n\t\tit('should validate emails', (done) => {\n\t\t\tsocketAdmin.user.validateEmail({ uid: adminUid }, [regularUid], (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tuser.getUserField(regularUid, 'email:confirmed', (err, emailConfirmed) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(parseInt(emailConfirmed, 10), 1);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should error with invalid uids', (done) => {\n\t\t\tsocketAdmin.user.sendValidationEmail({ uid: adminUid }, null, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should send validation email', (done) => {\n\t\t\tsocketAdmin.user.sendValidationEmail({ uid: adminUid }, [regularUid], (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should push unread notifications on reconnect', (done) => {\n\t\tconst socketMeta = require('../src/socket.io/meta');\n\t\tsocketMeta.reconnected({ uid: 1 }, {}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdone();\n\t\t});\n\t});\n\n\n\tit('should error if the room is missing', (done) => {\n\t\tio.emit('meta.rooms.enter', null, (err) => {\n\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should return if uid is 0', (done) => {\n\t\tconst socketMeta = require('../src/socket.io/meta');\n\t\tsocketMeta.rooms.enter({ uid: 0 }, null, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should join a room', (done) => {\n\t\tio.emit('meta.rooms.enter', { enter: 'recent_topics' }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should leave current room', (done) => {\n\t\tio.emit('meta.rooms.leaveCurrent', {}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get server time', (done) => {\n\t\tio.emit('admin.getServerTime', null, (err, time) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(time);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should error to get daily analytics with invalid data', (done) => {\n\t\tio.emit('admin.analytics.get', null, (err) => {\n\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get daily analytics', (done) => {\n\t\tio.emit('admin.analytics.get', { graph: 'traffic', units: 'days' }, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(data);\n\t\t\tassert(data.summary);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get hourly analytics', (done) => {\n\t\tio.emit('admin.analytics.get', { graph: 'traffic', units: 'hours' }, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(data);\n\t\t\tassert(data.summary);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should allow a custom date range for traffic graph analytics', (done) => {\n\t\tio.emit('admin.analytics.get', { graph: 'traffic', units: 'days', amount: '7' }, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(data);\n\t\t\tassert(data.pageviews);\n\t\t\tassert(data.uniqueVisitors);\n\t\t\tassert.strictEqual(7, data.pageviews.length);\n\t\t\tassert.strictEqual(7, data.uniqueVisitors.length);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should return error', (done) => {\n\t\tsocketAdmin.before({ uid: 10 }, 'someMethod', {}, (err) => {\n\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get room stats', (done) => {\n\t\tio.emit('meta.rooms.enter', { enter: 'topic_1' }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tsocketAdmin.rooms.getAll({ uid: 10 }, {}, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tsocketAdmin.rooms.getAll({ uid: 10 }, {}, (err, data) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(data.hasOwnProperty('onlineGuestCount'));\n\t\t\t\t\t\tassert(data.hasOwnProperty('onlineRegisteredCount'));\n\t\t\t\t\t\tassert(data.hasOwnProperty('socketCount'));\n\t\t\t\t\t\tassert(data.hasOwnProperty('topics'));\n\t\t\t\t\t\tassert(data.hasOwnProperty('users'));\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t}, 1000);\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should get room stats', (done) => {\n\t\tio.emit('meta.rooms.enter', { enter: 'category_1' }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tsocketAdmin.rooms.getAll({ uid: 10 }, {}, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tsocketAdmin.rooms.getAll({ uid: 10 }, {}, (err, data) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(data.users.category, 1, JSON.stringify(data, null, 4));\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t}, 1000);\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should get admin search dictionary', (done) => {\n\t\tsocketAdmin.getSearchDict({ uid: adminUid }, {}, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(Array.isArray(data));\n\t\t\tassert(data[0].namespace);\n\t\t\tassert(data[0].translations);\n\t\t\tassert(data[0].title);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should fire event', (done) => {\n\t\tio.on('testEvent', (data) => {\n\t\t\tassert.equal(data.foo, 1);\n\t\t\tdone();\n\t\t});\n\t\tsocketAdmin.fireEvent({ uid: adminUid }, { name: 'testEvent', payload: { foo: 1 } }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t});\n\t});\n\n\tit('should error with invalid data', (done) => {\n\t\tsocketAdmin.themes.set({ uid: adminUid }, null, (err) => {\n\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should set theme to bootswatch', (done) => {\n\t\tsocketAdmin.themes.set({ uid: adminUid }, {\n\t\t\ttype: 'bootswatch',\n\t\t\tsrc: '//maxcdn.bootstrapcdn.com/bootswatch/latest/darkly/bootstrap.min.css',\n\t\t\tid: 'darkly',\n\t\t}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tmeta.configs.getFields(['theme:src', 'bootswatchSkin'], (err, fields) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(fields['theme:src'], '//maxcdn.bootstrapcdn.com/bootswatch/latest/darkly/bootstrap.min.css');\n\t\t\t\tassert.equal(fields.bootswatchSkin, 'darkly');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should set theme to local persona', (done) => {\n\t\tsocketAdmin.themes.set({ uid: adminUid }, { type: 'local', id: 'nodebb-theme-persona' }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tmeta.configs.get('theme:id', (err, id) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(id, 'nodebb-theme-persona');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should toggle plugin active', (done) => {\n\t\tsocketAdmin.plugins.toggleActive({ uid: adminUid }, 'nodebb-plugin-location-to-map', (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.deepEqual(data, { id: 'nodebb-plugin-location-to-map', active: true });\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should toggle plugin install', function (done) {\n\t\tthis.timeout(0);\n\t\tconst oldValue = process.env.NODE_ENV;\n\t\tprocess.env.NODE_ENV = 'development';\n\t\tsocketAdmin.plugins.toggleInstall({\n\t\t\tuid: adminUid,\n\t\t}, {\n\t\t\tid: 'nodebb-plugin-location-to-map',\n\t\t\tversion: 'latest',\n\t\t}, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(data.name, 'nodebb-plugin-location-to-map');\n\t\t\tprocess.env.NODE_ENV = oldValue;\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get list of active plugins', (done) => {\n\t\tsocketAdmin.plugins.getActive({ uid: adminUid }, {}, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(Array.isArray(data));\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should order active plugins', (done) => {\n\t\tconst data = [\n\t\t\t{ name: 'nodebb-theme-persona', order: 0 },\n\t\t\t{ name: 'nodebb-plugin-dbsearch', order: 1 },\n\t\t\t{ name: 'nodebb-plugin-markdown', order: 2 },\n\t\t\t{ ignoreme: 'wrong data' },\n\t\t];\n\t\tsocketAdmin.plugins.orderActivePlugins({ uid: adminUid }, data, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdb.sortedSetRank('plugins:active', 'nodebb-plugin-dbsearch', (err, rank) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(rank, 1);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should upgrade plugin', function (done) {\n\t\tthis.timeout(0);\n\t\tconst oldValue = process.env.NODE_ENV;\n\t\tprocess.env.NODE_ENV = 'development';\n\t\tsocketAdmin.plugins.upgrade({\n\t\t\tuid: adminUid,\n\t\t}, {\n\t\t\tid: 'nodebb-plugin-location-to-map',\n\t\t\tversion: 'latest',\n\t\t}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tprocess.env.NODE_ENV = oldValue;\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should error with invalid data', (done) => {\n\t\tsocketAdmin.widgets.set({ uid: adminUid }, null, (err) => {\n\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should error with invalid data', (done) => {\n\t\tconst data = [\n\t\t\t{\n\t\t\t\ttemplate: 'global',\n\t\t\t\tlocation: 'sidebar',\n\t\t\t\twidgets: [{ widget: 'html', data: { html: 'test', title: 'test', container: '' } }],\n\t\t\t},\n\t\t];\n\t\tsocketAdmin.widgets.set({ uid: adminUid }, data, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdb.getObjectField('widgets:global', 'sidebar', (err, widgetData) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tassert.equal(JSON.parse(widgetData)[0].data.html, 'test');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should clear sitemap cache', async () => {\n\t\tawait socketAdmin.settings.clearSitemapCache({ uid: adminUid }, {});\n\t});\n\n\tit('should send test email', async () => {\n\t\tconst tpls = ['digest', 'banned', 'verify', 'welcome', 'notification', 'invitation'];\n\t\ttry {\n\t\t\tfor (const tpl of tpls) {\n\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\tawait socketAdmin.email.test({ uid: adminUid }, { template: tpl });\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tif (err.message !== '[[error:sendmail-not-found]]') {\n\t\t\t\tassert.ifError(err);\n\t\t\t}\n\t\t}\n\t});\n\n\tit('should not error when resending digests', async () => {\n\t\tawait socketAdmin.digest.resend({ uid: adminUid }, { action: 'resend-day', uid: adminUid });\n\t\tawait socketAdmin.digest.resend({ uid: adminUid }, { action: 'resend-day' });\n\t});\n\n\tit('should error with invalid interval', async () => {\n\t\tconst oldValue = meta.config.dailyDigestFreq;\n\t\tmeta.config.dailyDigestFreq = 'off';\n\t\ttry {\n\t\t\tawait socketAdmin.digest.resend({ uid: adminUid }, { action: 'resend-' });\n\t\t} catch (err) {\n\t\t\tassert.strictEqual(err.message, '[[error:digest-not-enabled]]');\n\t\t}\n\t\tmeta.config.dailyDigestFreq = oldValue;\n\t});\n\n\tit('should get logs', (done) => {\n\t\tconst fs = require('fs');\n\t\tconst path = require('path');\n\t\tmeta.logs.path = path.join(nconf.get('base_dir'), 'test/files', 'output.log');\n\t\tfs.appendFile(meta.logs.path, 'some logs', (err) => {\n\t\t\tassert.ifError(err);\n\n\t\t\tsocketAdmin.logs.get({ uid: adminUid }, {}, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(data);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should clear logs', (done) => {\n\t\tsocketAdmin.logs.clear({ uid: adminUid }, {}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tsocketAdmin.logs.get({ uid: adminUid }, {}, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.length, 0);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should clear errors', (done) => {\n\t\tsocketAdmin.errors.clear({ uid: adminUid }, {}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdb.exists('error:404', (err, exists) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(!exists);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should delete a single event', (done) => {\n\t\tdb.getSortedSetRevRange('events:time', 0, 0, (err, eids) => {\n\t\t\tassert.ifError(err);\n\t\t\tevents.deleteEvents(eids, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tdb.isSortedSetMembers('events:time', eids, (err, isMembers) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert(!isMembers.includes(true));\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should delete all events', (done) => {\n\t\tevents.deleteAll((err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdb.sortedSetCard('events:time', (err, count) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(count, 0);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('logger', () => {\n\t\tconst logger = require('../src/logger');\n\t\tconst index = require('../src/socket.io');\n\t\tconst fs = require('fs');\n\t\tconst path = require('path');\n\n\t\tit('should enable logging', (done) => {\n\t\t\tmeta.config.loggerStatus = 1;\n\t\t\tmeta.config.loggerIOStatus = 1;\n\t\t\tconst loggerPath = path.join(__dirname, '..', 'logs', 'logger.log');\n\t\t\tlogger.monitorConfig({ io: index.server }, { key: 'loggerPath', value: loggerPath });\n\t\t\tsetTimeout(() => {\n\t\t\t\tio.emit('meta.rooms.enter', { enter: 'recent_topics' }, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tfs.readFile(loggerPath, 'utf-8', (err, content) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(content);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}, 500);\n\t\t});\n\n\t\tafter((done) => {\n\t\t\tmeta.config.loggerStatus = 0;\n\t\t\tmeta.config.loggerIOStatus = 0;\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('password reset', () => {\n\t\tconst socketUser = require('../src/socket.io/user');\n\n\t\tit('should error if uids is not array', (done) => {\n\t\t\tsocketAdmin.user.sendPasswordResetEmail({ uid: adminUid }, null, (err) => {\n\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error if uid doesnt have email', (done) => {\n\t\t\tsocketAdmin.user.sendPasswordResetEmail({ uid: adminUid }, [adminUid], (err) => {\n\t\t\t\tassert.strictEqual(err.message, '[[error:user-doesnt-have-email, admin]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should send password reset email', async () => {\n\t\t\tawait user.setUserField(adminUid, 'email', 'admin_test@nodebb.org');\n\t\t\tawait user.email.confirmByUid(adminUid);\n\t\t\tawait socketAdmin.user.sendPasswordResetEmail({ uid: adminUid }, [adminUid]);\n\t\t});\n\n\t\tit('should error if uids is not array', (done) => {\n\t\t\tsocketAdmin.user.forcePasswordReset({ uid: adminUid }, null, (err) => {\n\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should for password reset', async () => {\n\t\t\tconst then = Date.now();\n\t\t\tconst uid = await user.create({ username: 'forceme', password: '123345' });\n\t\t\tawait socketAdmin.user.forcePasswordReset({ uid: adminUid }, [uid]);\n\t\t\tconst pwExpiry = await user.getUserField(uid, 'passwordExpiry');\n\t\t\tconst sleep = util.promisify(setTimeout);\n\t\t\tawait sleep(500);\n\t\t\tassert(pwExpiry > then && pwExpiry < Date.now());\n\t\t});\n\n\t\tit('should not error on valid email', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, 'regular@test.com', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tasync.parallel({\n\t\t\t\t\tcount: async.apply(db.sortedSetCount.bind(db), 'reset:issueDate', 0, Date.now()),\n\t\t\t\t\tevent: async.apply(events.getEvents, '', 0, 0),\n\t\t\t\t}, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(data.count, 2);\n\n\t\t\t\t\t// Event validity\n\t\t\t\t\tassert.strictEqual(data.event.length, 1);\n\t\t\t\t\tconst event = data.event[0];\n\t\t\t\t\tassert.strictEqual(event.type, 'password-reset');\n\t\t\t\t\tassert.strictEqual(event.text, '[[success:success]]');\n\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should not generate code if rate limited', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, 'regular@test.com', (err) => {\n\t\t\t\tassert(err);\n\n\t\t\t\tasync.parallel({\n\t\t\t\t\tcount: async.apply(db.sortedSetCount.bind(db), 'reset:issueDate', 0, Date.now()),\n\t\t\t\t\tevent: async.apply(events.getEvents, '', 0, 0),\n\t\t\t\t}, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(data.count, 2);\n\n\t\t\t\t\t// Event validity\n\t\t\t\t\tassert.strictEqual(data.event.length, 1);\n\t\t\t\t\tconst event = data.event[0];\n\t\t\t\t\tassert.strictEqual(event.type, 'password-reset');\n\t\t\t\t\tassert.strictEqual(event.text, '[[error:reset-rate-limited]]');\n\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should not error on invalid email (but not generate reset code)', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, 'irregular@test.com', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tdb.sortedSetCount('reset:issueDate', 0, Date.now(), (err, count) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(count, 2);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should error on no email', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, '', (err) => {\n\t\t\t\tassert(err instanceof Error);\n\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should clear caches', async () => {\n\t\tawait socketAdmin.cache.clear({ uid: adminUid }, { name: 'post' });\n\t\tawait socketAdmin.cache.clear({ uid: adminUid }, { name: 'object' });\n\t\tawait socketAdmin.cache.clear({ uid: adminUid }, { name: 'group' });\n\t\tawait socketAdmin.cache.clear({ uid: adminUid }, { name: 'local' });\n\t});\n\n\tit('should toggle caches', async () => {\n\t\tconst caches = {\n\t\t\tpost: require('../src/posts/cache'),\n\t\t\tobject: require('../src/database').objectCache,\n\t\t\tgroup: require('../src/groups').cache,\n\t\t\tlocal: require('../src/cache'),\n\t\t};\n\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'post', enabled: !caches.post.enabled });\n\t\tif (caches.object) {\n\t\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'object', enabled: !caches.object.enabled });\n\t\t}\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'group', enabled: !caches.group.enabled });\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'local', enabled: !caches.local.enabled });\n\n\t\t// call again to return back to original state\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'post', enabled: !caches.post.enabled });\n\t\tif (caches.object) {\n\t\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'object', enabled: !caches.object.enabled });\n\t\t}\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'group', enabled: !caches.group.enabled });\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'local', enabled: !caches.local.enabled });\n\t});\n});\n"], "fixing_code": ["'use strict';\n\n// eslint-disable-next-line no-redeclare\nconst io = require('socket.io-client');\n// eslint-disable-next-line no-redeclare\nconst $ = require('jquery');\n\napp = window.app || {};\n\n(function () {\n\tlet reconnecting = false;\n\n\tconst ioParams = {\n\t\treconnectionAttempts: config.maxReconnectionAttempts,\n\t\treconnectionDelay: config.reconnectionDelay,\n\t\ttransports: config.socketioTransports,\n\t\tpath: config.relative_path + '/socket.io',\n\t\tquery: {\n\t\t\t_csrf: config.csrf_token,\n\t\t},\n\t};\n\n\twindow.socket = io(config.websocketAddress, ioParams);\n\n\tconst oEmit = socket.emit;\n\tsocket.emit = function (event, data, callback) {\n\t\tif (typeof data === 'function') {\n\t\t\tcallback = data;\n\t\t\tdata = null;\n\t\t}\n\t\tif (typeof callback === 'function') {\n\t\t\toEmit.apply(socket, [event, data, callback]);\n\t\t\treturn;\n\t\t}\n\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\toEmit.apply(socket, [event, data, function (err, result) {\n\t\t\t\tif (err) reject(err);\n\t\t\t\telse resolve(result);\n\t\t\t}]);\n\t\t});\n\t};\n\n\tlet hooks;\n\trequire(['hooks'], function (_hooks) {\n\t\thooks = _hooks;\n\t\tif (parseInt(app.user.uid, 10) >= 0) {\n\t\t\taddHandlers();\n\t\t}\n\t});\n\n\twindow.app.reconnect = () => {\n\t\tif (socket.connected) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst reconnectEl = $('#reconnect');\n\t\t$('#reconnect-alert')\n\t\t\t.removeClass('alert-danger pointer')\n\t\t\t.addClass('alert-warning')\n\t\t\t.find('p')\n\t\t\t.translateText(`[[global:reconnecting-message, ${config.siteTitle}]]`);\n\n\t\treconnectEl.html('<i class=\"fa fa-spinner fa-spin\"></i>');\n\t\tsocket.connect();\n\t};\n\n\tfunction addHandlers() {\n\t\tsocket.on('connect', onConnect);\n\n\t\tsocket.on('disconnect', onDisconnect);\n\n\t\tsocket.io.on('reconnect_failed', function () {\n\t\t\tconst reconnectEl = $('#reconnect');\n\t\t\treconnectEl.html('<i class=\"fa fa-plug text-danger\"></i>');\n\n\t\t\t$('#reconnect-alert')\n\t\t\t\t.removeClass('alert-warning')\n\t\t\t\t.addClass('alert-danger pointer')\n\t\t\t\t.find('p')\n\t\t\t\t.translateText('[[error:socket-reconnect-failed]]')\n\t\t\t\t.one('click', app.reconnect);\n\n\t\t\t$(window).one('focus', app.reconnect);\n\t\t});\n\n\t\tsocket.on('checkSession', function (uid) {\n\t\t\tif (parseInt(uid, 10) !== parseInt(app.user.uid, 10)) {\n\t\t\t\thandleSessionMismatch();\n\t\t\t}\n\t\t});\n\t\tsocket.on('event:invalid_session', () => {\n\t\t\thandleInvalidSession();\n\t\t});\n\n\t\tsocket.on('setHostname', function (hostname) {\n\t\t\tapp.upstreamHost = hostname;\n\t\t});\n\n\t\tsocket.on('event:banned', onEventBanned);\n\t\tsocket.on('event:unbanned', onEventUnbanned);\n\t\tsocket.on('event:logout', function () {\n\t\t\trequire(['logout'], function (logout) {\n\t\t\t\tlogout();\n\t\t\t});\n\t\t});\n\t\tsocket.on('event:alert', function (params) {\n\t\t\trequire(['alerts'], function (alerts) {\n\t\t\t\talerts.alert(params);\n\t\t\t});\n\t\t});\n\t\tsocket.on('event:deprecated_call', function (data) {\n\t\t\tconsole.warn('[socket.io] ', data.eventName, 'is now deprecated in favour of', data.replacement);\n\t\t});\n\n\t\tsocket.removeAllListeners('event:nodebb.ready');\n\t\tsocket.on('event:nodebb.ready', function (data) {\n\t\t\tif ((data.hostname === app.upstreamHost) && (!app.cacheBuster || app.cacheBuster !== data['cache-buster'])) {\n\t\t\t\tapp.cacheBuster = data['cache-buster'];\n\t\t\t\trequire(['alerts'], function (alerts) {\n\t\t\t\t\talerts.alert({\n\t\t\t\t\t\talert_id: 'forum_updated',\n\t\t\t\t\t\ttitle: '[[global:updated.title]]',\n\t\t\t\t\t\tmessage: '[[global:updated.message]]',\n\t\t\t\t\t\tclickfn: function () {\n\t\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttype: 'warning',\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\tsocket.on('event:livereload', function () {\n\t\t\tif (app.user.isAdmin && !ajaxify.currentPage.match(/admin/)) {\n\t\t\t\twindow.location.reload();\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction handleInvalidSession() {\n\t\tsocket.disconnect();\n\t\trequire(['messages', 'logout'], function (messages, logout) {\n\t\t\tlogout(false);\n\t\t\tmessages.showInvalidSession();\n\t\t});\n\t}\n\n\tfunction handleSessionMismatch() {\n\t\tif (app.flags._login || app.flags._logout) {\n\t\t\treturn;\n\t\t}\n\n\t\tsocket.disconnect();\n\t\trequire(['messages'], function (messages) {\n\t\t\tmessages.showSessionMismatch();\n\t\t});\n\t}\n\n\tfunction onConnect() {\n\t\tif (!reconnecting) {\n\t\t\thooks.fire('action:connected');\n\t\t}\n\n\t\tif (reconnecting) {\n\t\t\tconst reconnectEl = $('#reconnect');\n\t\t\tconst reconnectAlert = $('#reconnect-alert');\n\n\t\t\treconnectEl.tooltip('dispose');\n\t\t\treconnectEl.html('<i class=\"fa fa-check text-success\"></i>');\n\t\t\treconnectAlert.addClass('hide');\n\t\t\treconnecting = false;\n\n\t\t\treJoinCurrentRoom();\n\n\t\t\tsocket.emit('meta.reconnected');\n\n\t\t\thooks.fire('action:reconnected');\n\n\t\t\tsetTimeout(function () {\n\t\t\t\treconnectEl.removeClass('active').addClass('hide');\n\t\t\t}, 3000);\n\t\t}\n\t}\n\n\tfunction reJoinCurrentRoom() {\n\t\tif (app.currentRoom) {\n\t\t\tconst current = app.currentRoom;\n\t\t\tapp.currentRoom = '';\n\t\t\tapp.enterRoom(current);\n\t\t}\n\t}\n\n\tfunction onReconnecting() {\n\t\treconnecting = true;\n\t\tconst reconnectEl = $('#reconnect');\n\t\tconst reconnectAlert = $('#reconnect-alert');\n\n\t\tif (!reconnectEl.hasClass('active')) {\n\t\t\treconnectEl.html('<i class=\"fa fa-spinner fa-spin\"></i>');\n\t\t\treconnectAlert.removeClass('hide');\n\t\t}\n\n\t\treconnectEl.addClass('active').removeClass('hide').tooltip({\n\t\t\tplacement: 'bottom',\n\t\t\tanimation: false,\n\t\t});\n\t}\n\n\tfunction onDisconnect() {\n\t\tsetTimeout(function () {\n\t\t\tif (socket.disconnected) {\n\t\t\t\tonReconnecting();\n\t\t\t}\n\t\t}, 2000);\n\n\t\thooks.fire('action:disconnected');\n\t}\n\n\tfunction onEventBanned(data) {\n\t\trequire(['bootbox', 'translator'], function (bootbox, translator) {\n\t\t\tconst message = data.until ?\n\t\t\t\ttranslator.compile('error:user-banned-reason-until', (new Date(data.until).toLocaleString()), data.reason) :\n\t\t\t\t'[[error:user-banned-reason, ' + data.reason + ']]';\n\t\t\ttranslator.translate(message, function (message) {\n\t\t\t\tbootbox.alert({\n\t\t\t\t\ttitle: '[[error:user-banned]]',\n\t\t\t\t\tmessage: message,\n\t\t\t\t\tcloseButton: false,\n\t\t\t\t\tcallback: function () {\n\t\t\t\t\t\twindow.location.href = config.relative_path + '/';\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tfunction onEventUnbanned() {\n\t\trequire(['bootbox'], function (bootbox) {\n\t\t\tbootbox.alert({\n\t\t\t\ttitle: '[[global:alert.unbanned]]',\n\t\t\t\tmessage: '[[global:alert.unbanned.message]]',\n\t\t\t\tcloseButton: false,\n\t\t\t\tcallback: function () {\n\t\t\t\t\twindow.location.href = config.relative_path + '/';\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t}\n\n\tif (\n\t\tconfig.socketioOrigins &&\n\t\tconfig.socketioOrigins !== '*:*' &&\n\t\tconfig.socketioOrigins.indexOf(location.hostname) === -1\n\t) {\n\t\tconsole.error(\n\t\t\t'You are accessing the forum from an unknown origin. This will likely result in websockets failing to connect. \\n' +\n\t\t\t'To fix this, set the `\"url\"` value in `config.json` to the URL at which you access the site. \\n' +\n\t\t\t'For more information, see this FAQ topic: https://community.nodebb.org/topic/13388'\n\t\t);\n\t}\n}());\n", "'use strict';\n\nconst { csrfSync } = require('csrf-sync');\n\nconst {\n\tgenerateToken,\n\tcsrfSynchronisedProtection,\n\tisRequestValid,\n} = csrfSync({\n\tgetTokenFromRequest: (req) => {\n\t\tif (req.headers['x-csrf-token']) {\n\t\t\treturn req.headers['x-csrf-token'];\n\t\t} else if (req.body && req.body.csrf_token) {\n\t\t\treturn req.body.csrf_token;\n\t\t} else if (req.query) {\n\t\t\treturn req.query._csrf;\n\t\t}\n\t},\n\tsize: 64,\n});\n\nmodule.exports = {\n\tgenerateToken,\n\tcsrfSynchronisedProtection,\n\tisRequestValid,\n};\n", "'use strict';\n\nconst os = require('os');\nconst nconf = require('nconf');\nconst winston = require('winston');\nconst util = require('util');\nconst validator = require('validator');\nconst cookieParser = require('cookie-parser')(nconf.get('secret'));\n\nconst db = require('../database');\nconst user = require('../user');\nconst logger = require('../logger');\nconst plugins = require('../plugins');\nconst ratelimit = require('../middleware/ratelimit');\n\nconst Namespaces = Object.create(null);\n\nconst Sockets = module.exports;\n\nSockets.init = async function (server) {\n\trequireModules();\n\n\tconst SocketIO = require('socket.io').Server;\n\tconst io = new SocketIO({\n\t\tpath: `${nconf.get('relative_path')}/socket.io`,\n\t});\n\n\tif (nconf.get('isCluster')) {\n\t\tif (nconf.get('redis')) {\n\t\t\tconst adapter = await require('../database/redis').socketAdapter();\n\t\t\tio.adapter(adapter);\n\t\t} else {\n\t\t\twinston.warn('clustering detected, you should setup redis!');\n\t\t}\n\t}\n\n\tio.on('connection', onConnection);\n\n\tconst opts = {\n\t\ttransports: nconf.get('socket.io:transports') || ['polling', 'websocket'],\n\t\tcookie: false,\n\t\tallowRequest: (req, callback) => {\n\t\t\tauthorize(req, (err) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\t\t\t\tconst csrf = require('../middleware/csrf');\n\t\t\t\tconst isValid = csrf.isRequestValid({\n\t\t\t\t\tsession: req.session || {},\n\t\t\t\t\tquery: req._query,\n\t\t\t\t\theaders: req.headers,\n\t\t\t\t});\n\t\t\t\tcallback(null, isValid);\n\t\t\t});\n\t\t},\n\t};\n\t/*\n\t * Restrict socket.io listener to cookie domain. If none is set, infer based on url.\n\t * Production only so you don't get accidentally locked out.\n\t * Can be overridden via config (socket.io:origins)\n\t */\n\tif (process.env.NODE_ENV !== 'development' || nconf.get('socket.io:cors')) {\n\t\tconst origins = nconf.get('socket.io:origins');\n\t\topts.cors = nconf.get('socket.io:cors') || {\n\t\t\torigin: origins,\n\t\t\tmethods: ['GET', 'POST'],\n\t\t\tallowedHeaders: ['content-type'],\n\t\t};\n\t\twinston.info(`[socket.io] Restricting access to origin: ${origins}`);\n\t}\n\n\tio.listen(server, opts);\n\tSockets.server = io;\n};\n\nfunction onConnection(socket) {\n\tsocket.uid = socket.request.uid;\n\tsocket.ip = (\n\t\tsocket.request.headers['x-forwarded-for'] ||\n\t\tsocket.request.connection.remoteAddress || ''\n\t).split(',')[0];\n\tsocket.request.ip = socket.ip;\n\tlogger.io_one(socket, socket.uid);\n\n\tonConnect(socket);\n\tsocket.onAny((event, ...args) => {\n\t\tconst payload = { data: [event].concat(args) };\n\t\tconst als = require('../als');\n\t\tals.run({ uid: socket.uid }, onMessage, socket, payload);\n\t});\n\n\tsocket.on('disconnect', () => {\n\t\tonDisconnect(socket);\n\t});\n}\n\nfunction onDisconnect(socket) {\n\trequire('./uploads').clear(socket.id);\n\tplugins.hooks.fire('action:sockets.disconnect', { socket: socket });\n}\n\nasync function onConnect(socket) {\n\ttry {\n\t\tawait validateSession(socket, '[[error:invalid-session]]');\n\t} catch (e) {\n\t\tif (e.message === '[[error:invalid-session]]') {\n\t\t\tsocket.emit('event:invalid_session');\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (socket.uid) {\n\t\tsocket.join(`uid_${socket.uid}`);\n\t\tsocket.join('online_users');\n\t} else {\n\t\tsocket.join('online_guests');\n\t}\n\n\tsocket.join(`sess_${socket.request.signedCookies[nconf.get('sessionKey')]}`);\n\tsocket.emit('checkSession', socket.uid);\n\tsocket.emit('setHostname', os.hostname());\n\tplugins.hooks.fire('action:sockets.connect', { socket: socket });\n}\n\nasync function onMessage(socket, payload) {\n\tif (!payload.data.length) {\n\t\treturn winston.warn('[socket.io] Empty payload');\n\t}\n\n\tlet eventName = payload.data[0];\n\tconst params = typeof payload.data[1] === 'function' ? {} : payload.data[1];\n\tconst callback = typeof payload.data[payload.data.length - 1] === 'function' ? payload.data[payload.data.length - 1] : function () {};\n\n\ttry {\n\t\tif (!eventName) {\n\t\t\treturn winston.warn('[socket.io] Empty method name');\n\t\t}\n\n\t\tif (typeof eventName !== 'string') {\n\t\t\teventName = typeof eventName;\n\t\t\tconst escapedName = validator.escape(eventName);\n\t\t\treturn callback({ message: `[[error:invalid-event, ${escapedName}]]` });\n\t\t}\n\n\t\tconst parts = eventName.split('.');\n\t\tconst namespace = parts[0];\n\t\tconst methodToCall = parts.reduce((prev, cur) => {\n\t\t\tif (prev !== null && prev[cur] && (!prev.hasOwnProperty || prev.hasOwnProperty(cur))) {\n\t\t\t\treturn prev[cur];\n\t\t\t}\n\t\t\treturn null;\n\t\t}, Namespaces);\n\n\t\tif (!methodToCall || typeof methodToCall !== 'function') {\n\t\t\tif (process.env.NODE_ENV === 'development') {\n\t\t\t\twinston.warn(`[socket.io] Unrecognized message: ${eventName}`);\n\t\t\t}\n\t\t\tconst escapedName = validator.escape(String(eventName));\n\t\t\treturn callback({ message: `[[error:invalid-event, ${escapedName}]]` });\n\t\t}\n\n\t\tsocket.previousEvents = socket.previousEvents || [];\n\t\tsocket.previousEvents.push(eventName);\n\t\tif (socket.previousEvents.length > 20) {\n\t\t\tsocket.previousEvents.shift();\n\t\t}\n\n\t\tif (!eventName.startsWith('admin.') && ratelimit.isFlooding(socket)) {\n\t\t\twinston.warn(`[socket.io] Too many emits! Disconnecting uid : ${socket.uid}. Events : ${socket.previousEvents}`);\n\t\t\treturn socket.disconnect();\n\t\t}\n\n\t\tawait checkMaintenance(socket);\n\t\tawait validateSession(socket, '[[error:revalidate-failure]]');\n\n\t\tif (Namespaces[namespace].before) {\n\t\t\tawait Namespaces[namespace].before(socket, eventName, params);\n\t\t}\n\n\t\tif (methodToCall.constructor && methodToCall.constructor.name === 'AsyncFunction') {\n\t\t\tconst result = await methodToCall(socket, params);\n\t\t\tcallback(null, result);\n\t\t} else {\n\t\t\tmethodToCall(socket, params, (err, result) => {\n\t\t\t\tcallback(err ? { message: err.message } : null, result);\n\t\t\t});\n\t\t}\n\t} catch (err) {\n\t\twinston.error(`${eventName}\\n${err.stack ? err.stack : err.message}`);\n\t\tcallback({ message: err.message });\n\t}\n}\n\nfunction requireModules() {\n\tconst modules = [\n\t\t'admin', 'categories', 'groups', 'meta', 'modules',\n\t\t'notifications', 'plugins', 'posts', 'topics', 'user',\n\t\t'blacklist', 'uploads',\n\t];\n\n\tmodules.forEach((module) => {\n\t\tNamespaces[module] = require(`./${module}`);\n\t});\n}\n\nasync function checkMaintenance(socket) {\n\tconst meta = require('../meta');\n\tif (!meta.config.maintenanceMode) {\n\t\treturn;\n\t}\n\tconst isAdmin = await user.isAdministrator(socket.uid);\n\tif (isAdmin) {\n\t\treturn;\n\t}\n\tconst validator = require('validator');\n\tthrow new Error(`[[pages:maintenance.text, ${validator.escape(String(meta.config.title || 'NodeBB'))}]]`);\n}\n\nconst getSessionAsync = util.promisify(\n\t(sid, callback) => db.sessionStore.get(sid, (err, sessionObj) => callback(err, sessionObj || null))\n);\n\nasync function validateSession(socket, errorMsg) {\n\tconst req = socket.request;\n\tconst { sessionId } = await plugins.hooks.fire('filter:sockets.sessionId', {\n\t\tsessionId: req.signedCookies ? req.signedCookies[nconf.get('sessionKey')] : null,\n\t\trequest: req,\n\t});\n\n\tif (!sessionId) {\n\t\treturn;\n\t}\n\n\tconst sessionData = await getSessionAsync(sessionId);\n\n\tif (!sessionData) {\n\t\tthrow new Error(errorMsg);\n\t}\n\n\tawait plugins.hooks.fire('static:sockets.validateSession', {\n\t\treq: req,\n\t\tsocket: socket,\n\t\tsession: sessionData,\n\t});\n}\n\nconst cookieParserAsync = util.promisify((req, callback) => cookieParser(req, {}, err => callback(err)));\n\nasync function authorize(request, callback) {\n\tif (!request) {\n\t\treturn callback(new Error('[[error:not-authorized]]'));\n\t}\n\n\tawait cookieParserAsync(request);\n\n\tconst { sessionId } = await plugins.hooks.fire('filter:sockets.sessionId', {\n\t\tsessionId: request.signedCookies ? request.signedCookies[nconf.get('sessionKey')] : null,\n\t\trequest: request,\n\t});\n\n\tconst sessionData = await getSessionAsync(sessionId);\n\trequest.session = sessionData;\n\tlet uid = 0;\n\tif (sessionData && sessionData.passport && sessionData.passport.user) {\n\t\tuid = parseInt(sessionData.passport.user, 10);\n\t}\n\trequest.uid = uid;\n\tcallback(null, uid);\n}\n\nSockets.in = function (room) {\n\treturn Sockets.server && Sockets.server.in(room);\n};\n\nSockets.getUserSocketCount = function (uid) {\n\treturn Sockets.getCountInRoom(`uid_${uid}`);\n};\n\nSockets.getCountInRoom = function (room) {\n\tif (!Sockets.server) {\n\t\treturn 0;\n\t}\n\tconst roomMap = Sockets.server.sockets.adapter.rooms.get(room);\n\treturn roomMap ? roomMap.size : 0;\n};\n\nSockets.warnDeprecated = (socket, replacement) => {\n\tif (socket.previousEvents && socket.emit) {\n\t\tsocket.emit('event:deprecated_call', {\n\t\t\teventName: socket.previousEvents[socket.previousEvents.length - 1],\n\t\t\treplacement: replacement,\n\t\t});\n\t}\n\twinston.warn(`[deprecated]\\n ${new Error('-').stack.split('\\n').slice(2, 5).join('\\n')}\\n     use ${replacement}`);\n};\n", "'use strict';\n\nconst request = require('request');\nconst requestAsync = require('request-promise-native');\nconst nconf = require('nconf');\nconst fs = require('fs');\nconst winston = require('winston');\n\nconst utils = require('../../src/utils');\n\nconst helpers = module.exports;\n\nhelpers.getCsrfToken = async (jar) => {\n\tconst { csrf_token: token } = await requestAsync({\n\t\turl: `${nconf.get('url')}/api/config`,\n\t\tjson: true,\n\t\tjar,\n\t});\n\n\treturn token;\n};\n\nhelpers.request = async function (method, uri, options) {\n\tconst ignoreMethods = ['GET', 'HEAD', 'OPTIONS'];\n\tconst lowercaseMethod = String(method).toLowerCase();\n\tlet csrf_token;\n\tif (!ignoreMethods.some(method => method.toLowerCase() === lowercaseMethod)) {\n\t\tcsrf_token = await helpers.getCsrfToken(options.jar);\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\toptions.headers = options.headers || {};\n\t\tif (csrf_token) {\n\t\t\toptions.headers['x-csrf-token'] = csrf_token;\n\t\t}\n\t\trequest[lowercaseMethod](`${nconf.get('url')}${uri}`, options, (err, res, body) => {\n\t\t\tif (err) reject(err);\n\t\t\telse resolve({ res, body });\n\t\t});\n\t});\n};\n\nhelpers.loginUser = async (username, password, payload = {}) => {\n\tconst jar = request.jar();\n\tconst form = { username, password, ...payload };\n\n\tconst { statusCode, body: configBody } = await requestAsync({\n\t\turl: `${nconf.get('url')}/api/config`,\n\t\tjson: true,\n\t\tjar: jar,\n\t\tfollowRedirect: false,\n\t\tsimple: false,\n\t\tresolveWithFullResponse: true,\n\t});\n\n\tif (statusCode !== 200) {\n\t\tthrow new Error('[[error:invalid-response]]');\n\t}\n\n\tconst { csrf_token } = configBody;\n\tconst res = await requestAsync.post(`${nconf.get('url')}/login`, {\n\t\tform,\n\t\tjson: true,\n\t\tjar: jar,\n\t\tfollowRedirect: false,\n\t\tsimple: false,\n\t\tresolveWithFullResponse: true,\n\t\theaders: {\n\t\t\t'x-csrf-token': csrf_token,\n\t\t},\n\t});\n\n\treturn { jar, res, body: res.body, csrf_token: csrf_token };\n};\n\nhelpers.logoutUser = function (jar, callback) {\n\trequest({\n\t\turl: `${nconf.get('url')}/api/config`,\n\t\tjson: true,\n\t\tjar: jar,\n\t}, (err, response, body) => {\n\t\tif (err) {\n\t\t\treturn callback(err, response, body);\n\t\t}\n\n\t\trequest.post(`${nconf.get('url')}/logout`, {\n\t\t\tform: {},\n\t\t\tjson: true,\n\t\t\tjar: jar,\n\t\t\theaders: {\n\t\t\t\t'x-csrf-token': body.csrf_token,\n\t\t\t},\n\t\t}, (err, response, body) => {\n\t\t\tcallback(err, response, body);\n\t\t});\n\t});\n};\n\nhelpers.connectSocketIO = function (res, csrf_token, callback) {\n\tconst io = require('socket.io-client');\n\tlet cookies = res.headers['set-cookie'];\n\tcookies = cookies.filter(c => /express.sid=[^;]+;/.test(c));\n\tconst cookie = cookies[0];\n\tconst socket = io(nconf.get('base_url'), {\n\t\tpath: `${nconf.get('relative_path')}/socket.io`,\n\t\textraHeaders: {\n\t\t\tOrigin: nconf.get('url'),\n\t\t\tCookie: cookie,\n\t\t},\n\t\tquery: {\n\t\t\t_csrf: csrf_token,\n\t\t},\n\t});\n\n\tsocket.on('connect', () => {\n\t\tcallback(null, socket);\n\t});\n\n\tsocket.on('error', (err) => {\n\t\tcallback(err);\n\t});\n};\n\nhelpers.uploadFile = function (uploadEndPoint, filePath, body, jar, csrf_token, callback) {\n\tlet formData = {\n\t\tfiles: [\n\t\t\tfs.createReadStream(filePath),\n\t\t],\n\t};\n\tformData = utils.merge(formData, body);\n\trequest.post({\n\t\turl: uploadEndPoint,\n\t\tformData: formData,\n\t\tjson: true,\n\t\tjar: jar,\n\t\theaders: {\n\t\t\t'x-csrf-token': csrf_token,\n\t\t},\n\t}, (err, res, body) => {\n\t\tif (err) {\n\t\t\treturn callback(err);\n\t\t}\n\t\tif (res.statusCode !== 200) {\n\t\t\twinston.error(JSON.stringify(body));\n\t\t}\n\t\tcallback(null, res, body);\n\t});\n};\n\nhelpers.registerUser = function (data, callback) {\n\tconst jar = request.jar();\n\trequest({\n\t\turl: `${nconf.get('url')}/api/config`,\n\t\tjson: true,\n\t\tjar: jar,\n\t}, (err, response, body) => {\n\t\tif (err) {\n\t\t\treturn callback(err);\n\t\t}\n\n\t\tif (!data.hasOwnProperty('password-confirm')) {\n\t\t\tdata['password-confirm'] = data.password;\n\t\t}\n\n\t\trequest.post(`${nconf.get('url')}/register`, {\n\t\t\tform: data,\n\t\t\tjson: true,\n\t\t\tjar: jar,\n\t\t\theaders: {\n\t\t\t\t'x-csrf-token': body.csrf_token,\n\t\t\t},\n\t\t}, (err, response, body) => {\n\t\t\tcallback(err, jar, response, body);\n\t\t});\n\t});\n};\n\n// http://stackoverflow.com/a/14387791/583363\nhelpers.copyFile = function (source, target, callback) {\n\tlet cbCalled = false;\n\n\tconst rd = fs.createReadStream(source);\n\trd.on('error', (err) => {\n\t\tdone(err);\n\t});\n\tconst wr = fs.createWriteStream(target);\n\twr.on('error', (err) => {\n\t\tdone(err);\n\t});\n\twr.on('close', () => {\n\t\tdone();\n\t});\n\trd.pipe(wr);\n\n\tfunction done(err) {\n\t\tif (!cbCalled) {\n\t\t\tcallback(err);\n\t\t\tcbCalled = true;\n\t\t}\n\t}\n};\n\nhelpers.invite = async function (body, uid, jar, csrf_token) {\n\tconsole.log('making call');\n\tconst res = await requestAsync.post(`${nconf.get('url')}/api/v3/users/${uid}/invites`, {\n\t\tjar: jar,\n\t\t// using \"form\" since client \"api\" module make requests with \"application/x-www-form-urlencoded\" content-type\n\t\tform: body,\n\t\theaders: {\n\t\t\t'x-csrf-token': csrf_token,\n\t\t},\n\t\tsimple: false,\n\t\tresolveWithFullResponse: true,\n\t});\n\tconsole.log(res.statusCode, res.body);\n\n\tres.body = JSON.parse(res.body);\n\treturn { res, body };\n};\n\nhelpers.createFolder = function (path, folderName, jar, csrf_token) {\n\treturn requestAsync.put(`${nconf.get('url')}/api/v3/files/folder`, {\n\t\tjar,\n\t\tbody: {\n\t\t\tpath,\n\t\t\tfolderName,\n\t\t},\n\t\tjson: true,\n\t\theaders: {\n\t\t\t'x-csrf-token': csrf_token,\n\t\t},\n\t\tsimple: false,\n\t\tresolveWithFullResponse: true,\n\t});\n};\n\nrequire('../../src/promisify')(helpers);\n", "'use strict';\n\n// see https://gist.github.com/jfromaniello/4087861#gistcomment-1447029\n\n\nprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';\n\nconst util = require('util');\n\nconst sleep = util.promisify(setTimeout);\nconst assert = require('assert');\nconst async = require('async');\nconst nconf = require('nconf');\nconst request = require('request');\n\nconst cookies = request.jar();\n\nconst db = require('./mocks/databasemock');\nconst user = require('../src/user');\nconst groups = require('../src/groups');\nconst categories = require('../src/categories');\nconst helpers = require('./helpers');\nconst meta = require('../src/meta');\nconst events = require('../src/events');\n\nconst socketAdmin = require('../src/socket.io/admin');\n\ndescribe('socket.io', () => {\n\tlet io;\n\tlet cid;\n\tlet tid;\n\tlet adminUid;\n\tlet regularUid;\n\n\tbefore(async () => {\n\t\tconst data = await Promise.all([\n\t\t\tuser.create({ username: 'admin', password: 'adminpwd' }),\n\t\t\tuser.create({ username: 'regular', password: 'regularpwd' }),\n\t\t\tcategories.create({\n\t\t\t\tname: 'Test Category',\n\t\t\t\tdescription: 'Test category created by testing script',\n\t\t\t}),\n\t\t]);\n\t\tadminUid = data[0];\n\t\tawait groups.join('administrators', data[0]);\n\n\t\tregularUid = data[1];\n\t\tawait user.setUserField(regularUid, 'email', 'regular@test.com');\n\t\tawait user.email.confirmByUid(regularUid);\n\n\t\tcid = data[2].cid;\n\t});\n\n\n\tit('should connect and auth properly', (done) => {\n\t\trequest.get({\n\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\tjar: cookies,\n\t\t\tjson: true,\n\t\t}, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\n\t\t\trequest.post(`${nconf.get('url')}/login`, {\n\t\t\t\tjar: cookies,\n\t\t\t\tform: {\n\t\t\t\t\tusername: 'admin',\n\t\t\t\t\tpassword: 'adminpwd',\n\t\t\t\t},\n\t\t\t\theaders: {\n\t\t\t\t\t'x-csrf-token': body.csrf_token,\n\t\t\t\t},\n\t\t\t\tjson: true,\n\t\t\t}, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\thelpers.connectSocketIO(res, body.csrf_token, (err, _io) => {\n\t\t\t\t\tio = _io;\n\t\t\t\t\tassert.ifError(err);\n\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should return error for unknown event', (done) => {\n\t\tio.emit('unknown.event', (err) => {\n\t\t\tassert(err);\n\t\t\tassert.equal(err.message, '[[error:invalid-event, unknown.event]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should return error for unknown event', (done) => {\n\t\tio.emit('user.gdpr.__proto__.constructor.toString', (err) => {\n\t\t\tassert(err);\n\t\t\tassert.equal(err.message, '[[error:invalid-event, user.gdpr.__proto__.constructor.toString]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should return error for unknown event', (done) => {\n\t\tio.emit('constructor.toString', (err) => {\n\t\t\tassert(err);\n\t\t\tassert.equal(err.message, '[[error:invalid-event, constructor.toString]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should return error for invalid eventName type', (done) => {\n\t\tconst eventName = ['topics.loadMoreTags'];\n\t\tio.emit(eventName, (err) => {\n\t\t\tassert.strictEqual(err.message, `[[error:invalid-event, object]]`);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get installed themes', (done) => {\n\t\tconst themes = ['nodebb-theme-persona'];\n\t\tio.emit('admin.themes.getInstalled', (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(data);\n\t\t\tconst installed = data.map(theme => theme.id);\n\t\t\tthemes.forEach((theme) => {\n\t\t\t\tassert(installed.includes(theme));\n\t\t\t});\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should ban a user', async () => {\n\t\tconst apiUser = require('../src/api/users');\n\t\tawait apiUser.ban({ uid: adminUid }, { uid: regularUid, reason: 'spammer' });\n\t\tconst data = await user.getLatestBanInfo(regularUid);\n\t\tassert(data.uid);\n\t\tassert(data.timestamp);\n\t\tassert(data.hasOwnProperty('banned_until'));\n\t\tassert(data.hasOwnProperty('banned_until_readable'));\n\t\tassert.equal(data.reason, 'spammer');\n\t});\n\n\tit('should return ban reason', (done) => {\n\t\tuser.bans.getReason(regularUid, (err, reason) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(reason, 'spammer');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should unban a user', async () => {\n\t\tconst apiUser = require('../src/api/users');\n\t\tawait apiUser.unban({ uid: adminUid }, { uid: regularUid });\n\t\tconst isBanned = await user.bans.isBanned(regularUid);\n\t\tassert(!isBanned);\n\t});\n\n\tit('should make user admin', (done) => {\n\t\tsocketAdmin.user.makeAdmins({ uid: adminUid }, [regularUid], (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tgroups.isMember(regularUid, 'administrators', (err, isMember) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(isMember);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should make user non-admin', (done) => {\n\t\tsocketAdmin.user.removeAdmins({ uid: adminUid }, [regularUid], (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tgroups.isMember(regularUid, 'administrators', (err, isMember) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(!isMember);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('user create/delete', () => {\n\t\tlet uid;\n\t\tconst apiUsers = require('../src/api/users');\n\t\tit('should create a user', async () => {\n\t\t\tconst userData = await apiUsers.create({ uid: adminUid }, { username: 'foo1' });\n\t\t\tuid = userData.uid;\n\t\t\tconst isMember = await groups.isMember(userData.uid, 'registered-users');\n\t\t\tassert(isMember);\n\t\t});\n\n\t\tit('should delete users', async () => {\n\t\t\tawait apiUsers.delete({ uid: adminUid }, { uid });\n\t\t\tawait sleep(500);\n\t\t\tconst isMember = await groups.isMember(uid, 'registered-users');\n\t\t\tassert(!isMember);\n\t\t});\n\n\t\tit('should error if user does not exist', async () => {\n\t\t\tlet err;\n\t\t\ttry {\n\t\t\t\tawait apiUsers.deleteMany({ uid: adminUid }, { uids: [uid] });\n\t\t\t} catch (_err) {\n\t\t\t\terr = _err;\n\t\t\t}\n\t\t\tassert.strictEqual(err.message, '[[error:no-user]]');\n\t\t});\n\n\t\tit('should delete users and their content', async () => {\n\t\t\tconst userData = await apiUsers.create({ uid: adminUid }, { username: 'foo2' });\n\t\t\tawait apiUsers.deleteMany({ uid: adminUid }, { uids: [userData.uid] });\n\t\t\tawait sleep(500);\n\t\t\tconst isMember = await groups.isMember(userData.uid, 'registered-users');\n\t\t\tassert(!isMember);\n\t\t});\n\n\t\tit('should error with invalid data', async () => {\n\t\t\tlet err;\n\t\t\ttry {\n\t\t\t\tawait apiUsers.create({ uid: adminUid }, null);\n\t\t\t} catch (_err) {\n\t\t\t\terr = _err;\n\t\t\t}\n\t\t\tassert.strictEqual(err.message, '[[error:invalid-data]]');\n\t\t});\n\t});\n\n\tit('should load user groups', async () => {\n\t\tconst { users } = await socketAdmin.user.loadGroups({ uid: adminUid }, [adminUid]);\n\t\tassert.strictEqual(users[0].username, 'admin');\n\t\tassert(Array.isArray(users[0].groups));\n\t});\n\n\tit('should reset lockouts', (done) => {\n\t\tsocketAdmin.user.resetLockouts({ uid: adminUid }, [regularUid], (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('validation emails', () => {\n\t\tconst plugins = require('../src/plugins');\n\n\t\tasync function dummyEmailerHook(data) {\n\t\t\t// pretend to handle sending emails\n\t\t}\n\t\tbefore(() => {\n\t\t\t// Attach an emailer hook so related requests do not error\n\t\t\tplugins.hooks.register('emailer-test', {\n\t\t\t\thook: 'filter:email.send',\n\t\t\t\tmethod: dummyEmailerHook,\n\t\t\t});\n\t\t});\n\t\tafter(() => {\n\t\t\tplugins.hooks.unregister('emailer-test', 'filter:email.send');\n\t\t});\n\n\t\tit('should validate emails', (done) => {\n\t\t\tsocketAdmin.user.validateEmail({ uid: adminUid }, [regularUid], (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tuser.getUserField(regularUid, 'email:confirmed', (err, emailConfirmed) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(parseInt(emailConfirmed, 10), 1);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should error with invalid uids', (done) => {\n\t\t\tsocketAdmin.user.sendValidationEmail({ uid: adminUid }, null, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should send validation email', (done) => {\n\t\t\tsocketAdmin.user.sendValidationEmail({ uid: adminUid }, [regularUid], (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should push unread notifications on reconnect', (done) => {\n\t\tconst socketMeta = require('../src/socket.io/meta');\n\t\tsocketMeta.reconnected({ uid: 1 }, {}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdone();\n\t\t});\n\t});\n\n\n\tit('should error if the room is missing', (done) => {\n\t\tio.emit('meta.rooms.enter', null, (err) => {\n\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should return if uid is 0', (done) => {\n\t\tconst socketMeta = require('../src/socket.io/meta');\n\t\tsocketMeta.rooms.enter({ uid: 0 }, null, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should join a room', (done) => {\n\t\tio.emit('meta.rooms.enter', { enter: 'recent_topics' }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should leave current room', (done) => {\n\t\tio.emit('meta.rooms.leaveCurrent', {}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get server time', (done) => {\n\t\tio.emit('admin.getServerTime', null, (err, time) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(time);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should error to get daily analytics with invalid data', (done) => {\n\t\tio.emit('admin.analytics.get', null, (err) => {\n\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get daily analytics', (done) => {\n\t\tio.emit('admin.analytics.get', { graph: 'traffic', units: 'days' }, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(data);\n\t\t\tassert(data.summary);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get hourly analytics', (done) => {\n\t\tio.emit('admin.analytics.get', { graph: 'traffic', units: 'hours' }, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(data);\n\t\t\tassert(data.summary);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should allow a custom date range for traffic graph analytics', (done) => {\n\t\tio.emit('admin.analytics.get', { graph: 'traffic', units: 'days', amount: '7' }, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(data);\n\t\t\tassert(data.pageviews);\n\t\t\tassert(data.uniqueVisitors);\n\t\t\tassert.strictEqual(7, data.pageviews.length);\n\t\t\tassert.strictEqual(7, data.uniqueVisitors.length);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should return error', (done) => {\n\t\tsocketAdmin.before({ uid: 10 }, 'someMethod', {}, (err) => {\n\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get room stats', (done) => {\n\t\tio.emit('meta.rooms.enter', { enter: 'topic_1' }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tsocketAdmin.rooms.getAll({ uid: 10 }, {}, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tsocketAdmin.rooms.getAll({ uid: 10 }, {}, (err, data) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(data.hasOwnProperty('onlineGuestCount'));\n\t\t\t\t\t\tassert(data.hasOwnProperty('onlineRegisteredCount'));\n\t\t\t\t\t\tassert(data.hasOwnProperty('socketCount'));\n\t\t\t\t\t\tassert(data.hasOwnProperty('topics'));\n\t\t\t\t\t\tassert(data.hasOwnProperty('users'));\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t}, 1000);\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should get room stats', (done) => {\n\t\tio.emit('meta.rooms.enter', { enter: 'category_1' }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tsocketAdmin.rooms.getAll({ uid: 10 }, {}, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tsocketAdmin.rooms.getAll({ uid: 10 }, {}, (err, data) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(data.users.category, 1, JSON.stringify(data, null, 4));\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t}, 1000);\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should get admin search dictionary', (done) => {\n\t\tsocketAdmin.getSearchDict({ uid: adminUid }, {}, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(Array.isArray(data));\n\t\t\tassert(data[0].namespace);\n\t\t\tassert(data[0].translations);\n\t\t\tassert(data[0].title);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should fire event', (done) => {\n\t\tio.on('testEvent', (data) => {\n\t\t\tassert.equal(data.foo, 1);\n\t\t\tdone();\n\t\t});\n\t\tsocketAdmin.fireEvent({ uid: adminUid }, { name: 'testEvent', payload: { foo: 1 } }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t});\n\t});\n\n\tit('should error with invalid data', (done) => {\n\t\tsocketAdmin.themes.set({ uid: adminUid }, null, (err) => {\n\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should set theme to bootswatch', (done) => {\n\t\tsocketAdmin.themes.set({ uid: adminUid }, {\n\t\t\ttype: 'bootswatch',\n\t\t\tsrc: '//maxcdn.bootstrapcdn.com/bootswatch/latest/darkly/bootstrap.min.css',\n\t\t\tid: 'darkly',\n\t\t}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tmeta.configs.getFields(['theme:src', 'bootswatchSkin'], (err, fields) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(fields['theme:src'], '//maxcdn.bootstrapcdn.com/bootswatch/latest/darkly/bootstrap.min.css');\n\t\t\t\tassert.equal(fields.bootswatchSkin, 'darkly');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should set theme to local persona', (done) => {\n\t\tsocketAdmin.themes.set({ uid: adminUid }, { type: 'local', id: 'nodebb-theme-persona' }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tmeta.configs.get('theme:id', (err, id) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(id, 'nodebb-theme-persona');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should toggle plugin active', (done) => {\n\t\tsocketAdmin.plugins.toggleActive({ uid: adminUid }, 'nodebb-plugin-location-to-map', (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.deepEqual(data, { id: 'nodebb-plugin-location-to-map', active: true });\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should toggle plugin install', function (done) {\n\t\tthis.timeout(0);\n\t\tconst oldValue = process.env.NODE_ENV;\n\t\tprocess.env.NODE_ENV = 'development';\n\t\tsocketAdmin.plugins.toggleInstall({\n\t\t\tuid: adminUid,\n\t\t}, {\n\t\t\tid: 'nodebb-plugin-location-to-map',\n\t\t\tversion: 'latest',\n\t\t}, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(data.name, 'nodebb-plugin-location-to-map');\n\t\t\tprocess.env.NODE_ENV = oldValue;\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get list of active plugins', (done) => {\n\t\tsocketAdmin.plugins.getActive({ uid: adminUid }, {}, (err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(Array.isArray(data));\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should order active plugins', (done) => {\n\t\tconst data = [\n\t\t\t{ name: 'nodebb-theme-persona', order: 0 },\n\t\t\t{ name: 'nodebb-plugin-dbsearch', order: 1 },\n\t\t\t{ name: 'nodebb-plugin-markdown', order: 2 },\n\t\t\t{ ignoreme: 'wrong data' },\n\t\t];\n\t\tsocketAdmin.plugins.orderActivePlugins({ uid: adminUid }, data, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdb.sortedSetRank('plugins:active', 'nodebb-plugin-dbsearch', (err, rank) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(rank, 1);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should upgrade plugin', function (done) {\n\t\tthis.timeout(0);\n\t\tconst oldValue = process.env.NODE_ENV;\n\t\tprocess.env.NODE_ENV = 'development';\n\t\tsocketAdmin.plugins.upgrade({\n\t\t\tuid: adminUid,\n\t\t}, {\n\t\t\tid: 'nodebb-plugin-location-to-map',\n\t\t\tversion: 'latest',\n\t\t}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tprocess.env.NODE_ENV = oldValue;\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should error with invalid data', (done) => {\n\t\tsocketAdmin.widgets.set({ uid: adminUid }, null, (err) => {\n\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should error with invalid data', (done) => {\n\t\tconst data = [\n\t\t\t{\n\t\t\t\ttemplate: 'global',\n\t\t\t\tlocation: 'sidebar',\n\t\t\t\twidgets: [{ widget: 'html', data: { html: 'test', title: 'test', container: '' } }],\n\t\t\t},\n\t\t];\n\t\tsocketAdmin.widgets.set({ uid: adminUid }, data, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdb.getObjectField('widgets:global', 'sidebar', (err, widgetData) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tassert.equal(JSON.parse(widgetData)[0].data.html, 'test');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should clear sitemap cache', async () => {\n\t\tawait socketAdmin.settings.clearSitemapCache({ uid: adminUid }, {});\n\t});\n\n\tit('should send test email', async () => {\n\t\tconst tpls = ['digest', 'banned', 'verify', 'welcome', 'notification', 'invitation'];\n\t\ttry {\n\t\t\tfor (const tpl of tpls) {\n\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\tawait socketAdmin.email.test({ uid: adminUid }, { template: tpl });\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tif (err.message !== '[[error:sendmail-not-found]]') {\n\t\t\t\tassert.ifError(err);\n\t\t\t}\n\t\t}\n\t});\n\n\tit('should not error when resending digests', async () => {\n\t\tawait socketAdmin.digest.resend({ uid: adminUid }, { action: 'resend-day', uid: adminUid });\n\t\tawait socketAdmin.digest.resend({ uid: adminUid }, { action: 'resend-day' });\n\t});\n\n\tit('should error with invalid interval', async () => {\n\t\tconst oldValue = meta.config.dailyDigestFreq;\n\t\tmeta.config.dailyDigestFreq = 'off';\n\t\ttry {\n\t\t\tawait socketAdmin.digest.resend({ uid: adminUid }, { action: 'resend-' });\n\t\t} catch (err) {\n\t\t\tassert.strictEqual(err.message, '[[error:digest-not-enabled]]');\n\t\t}\n\t\tmeta.config.dailyDigestFreq = oldValue;\n\t});\n\n\tit('should get logs', (done) => {\n\t\tconst fs = require('fs');\n\t\tconst path = require('path');\n\t\tmeta.logs.path = path.join(nconf.get('base_dir'), 'test/files', 'output.log');\n\t\tfs.appendFile(meta.logs.path, 'some logs', (err) => {\n\t\t\tassert.ifError(err);\n\n\t\t\tsocketAdmin.logs.get({ uid: adminUid }, {}, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(data);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should clear logs', (done) => {\n\t\tsocketAdmin.logs.clear({ uid: adminUid }, {}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tsocketAdmin.logs.get({ uid: adminUid }, {}, (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.length, 0);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should clear errors', (done) => {\n\t\tsocketAdmin.errors.clear({ uid: adminUid }, {}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdb.exists('error:404', (err, exists) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(!exists);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should delete a single event', (done) => {\n\t\tdb.getSortedSetRevRange('events:time', 0, 0, (err, eids) => {\n\t\t\tassert.ifError(err);\n\t\t\tevents.deleteEvents(eids, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tdb.isSortedSetMembers('events:time', eids, (err, isMembers) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert(!isMembers.includes(true));\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should delete all events', (done) => {\n\t\tevents.deleteAll((err) => {\n\t\t\tassert.ifError(err);\n\t\t\tdb.sortedSetCard('events:time', (err, count) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(count, 0);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('logger', () => {\n\t\tconst logger = require('../src/logger');\n\t\tconst index = require('../src/socket.io');\n\t\tconst fs = require('fs');\n\t\tconst path = require('path');\n\n\t\tit('should enable logging', (done) => {\n\t\t\tmeta.config.loggerStatus = 1;\n\t\t\tmeta.config.loggerIOStatus = 1;\n\t\t\tconst loggerPath = path.join(__dirname, '..', 'logs', 'logger.log');\n\t\t\tlogger.monitorConfig({ io: index.server }, { key: 'loggerPath', value: loggerPath });\n\t\t\tsetTimeout(() => {\n\t\t\t\tio.emit('meta.rooms.enter', { enter: 'recent_topics' }, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tfs.readFile(loggerPath, 'utf-8', (err, content) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(content);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}, 500);\n\t\t});\n\n\t\tafter((done) => {\n\t\t\tmeta.config.loggerStatus = 0;\n\t\t\tmeta.config.loggerIOStatus = 0;\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('password reset', () => {\n\t\tconst socketUser = require('../src/socket.io/user');\n\n\t\tit('should error if uids is not array', (done) => {\n\t\t\tsocketAdmin.user.sendPasswordResetEmail({ uid: adminUid }, null, (err) => {\n\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error if uid doesnt have email', (done) => {\n\t\t\tsocketAdmin.user.sendPasswordResetEmail({ uid: adminUid }, [adminUid], (err) => {\n\t\t\t\tassert.strictEqual(err.message, '[[error:user-doesnt-have-email, admin]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should send password reset email', async () => {\n\t\t\tawait user.setUserField(adminUid, 'email', 'admin_test@nodebb.org');\n\t\t\tawait user.email.confirmByUid(adminUid);\n\t\t\tawait socketAdmin.user.sendPasswordResetEmail({ uid: adminUid }, [adminUid]);\n\t\t});\n\n\t\tit('should error if uids is not array', (done) => {\n\t\t\tsocketAdmin.user.forcePasswordReset({ uid: adminUid }, null, (err) => {\n\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should for password reset', async () => {\n\t\t\tconst then = Date.now();\n\t\t\tconst uid = await user.create({ username: 'forceme', password: '123345' });\n\t\t\tawait socketAdmin.user.forcePasswordReset({ uid: adminUid }, [uid]);\n\t\t\tconst pwExpiry = await user.getUserField(uid, 'passwordExpiry');\n\t\t\tconst sleep = util.promisify(setTimeout);\n\t\t\tawait sleep(500);\n\t\t\tassert(pwExpiry > then && pwExpiry < Date.now());\n\t\t});\n\n\t\tit('should not error on valid email', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, 'regular@test.com', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tasync.parallel({\n\t\t\t\t\tcount: async.apply(db.sortedSetCount.bind(db), 'reset:issueDate', 0, Date.now()),\n\t\t\t\t\tevent: async.apply(events.getEvents, '', 0, 0),\n\t\t\t\t}, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(data.count, 2);\n\n\t\t\t\t\t// Event validity\n\t\t\t\t\tassert.strictEqual(data.event.length, 1);\n\t\t\t\t\tconst event = data.event[0];\n\t\t\t\t\tassert.strictEqual(event.type, 'password-reset');\n\t\t\t\t\tassert.strictEqual(event.text, '[[success:success]]');\n\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should not generate code if rate limited', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, 'regular@test.com', (err) => {\n\t\t\t\tassert(err);\n\n\t\t\t\tasync.parallel({\n\t\t\t\t\tcount: async.apply(db.sortedSetCount.bind(db), 'reset:issueDate', 0, Date.now()),\n\t\t\t\t\tevent: async.apply(events.getEvents, '', 0, 0),\n\t\t\t\t}, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(data.count, 2);\n\n\t\t\t\t\t// Event validity\n\t\t\t\t\tassert.strictEqual(data.event.length, 1);\n\t\t\t\t\tconst event = data.event[0];\n\t\t\t\t\tassert.strictEqual(event.type, 'password-reset');\n\t\t\t\t\tassert.strictEqual(event.text, '[[error:reset-rate-limited]]');\n\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should not error on invalid email (but not generate reset code)', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, 'irregular@test.com', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tdb.sortedSetCount('reset:issueDate', 0, Date.now(), (err, count) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(count, 2);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should error on no email', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, '', (err) => {\n\t\t\t\tassert(err instanceof Error);\n\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should clear caches', async () => {\n\t\tawait socketAdmin.cache.clear({ uid: adminUid }, { name: 'post' });\n\t\tawait socketAdmin.cache.clear({ uid: adminUid }, { name: 'object' });\n\t\tawait socketAdmin.cache.clear({ uid: adminUid }, { name: 'group' });\n\t\tawait socketAdmin.cache.clear({ uid: adminUid }, { name: 'local' });\n\t});\n\n\tit('should toggle caches', async () => {\n\t\tconst caches = {\n\t\t\tpost: require('../src/posts/cache'),\n\t\t\tobject: require('../src/database').objectCache,\n\t\t\tgroup: require('../src/groups').cache,\n\t\t\tlocal: require('../src/cache'),\n\t\t};\n\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'post', enabled: !caches.post.enabled });\n\t\tif (caches.object) {\n\t\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'object', enabled: !caches.object.enabled });\n\t\t}\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'group', enabled: !caches.group.enabled });\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'local', enabled: !caches.local.enabled });\n\n\t\t// call again to return back to original state\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'post', enabled: !caches.post.enabled });\n\t\tif (caches.object) {\n\t\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'object', enabled: !caches.object.enabled });\n\t\t}\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'group', enabled: !caches.group.enabled });\n\t\tawait socketAdmin.cache.toggle({ uid: adminUid }, { name: 'local', enabled: !caches.local.enabled });\n\t});\n});\n"], "filenames": ["public/src/sockets.js", "src/middleware/csrf.js", "src/socket.io/index.js", "test/helpers/index.js", "test/socket.io.js"], "buggy_code_start_loc": [17, 7, 37, 99, 76], "buggy_code_end_loc": [17, 21, 258, 108, 77], "fixing_code_start_loc": [18, 8, 36, 99, 76], "fixing_code_end_loc": [21, 26, 270, 112, 77], "type": "CWE-346", "message": "NodeBB is affected by a Cross-Site WebSocket Hijacking vulnerability due to missing validation of the request origin. Exploitation of this vulnerability allows certain user information to be extracted by attacker.", "other": {"cve": {"id": "CVE-2023-2850", "sourceIdentifier": "report@snyk.io", "published": "2023-07-25T12:15:10.837", "lastModified": "2023-08-07T16:58:57.517", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NodeBB is affected by a Cross-Site WebSocket Hijacking vulnerability due to missing validation of the request origin. Exploitation of this vulnerability allows certain user information to be extracted by attacker."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-346"}]}, {"source": "report@snyk.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1385"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nodebb:nodebb:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.8.13", "matchCriteriaId": "8F25C5F7-B985-40D3-AD78-46E8264A4D7A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodebb:nodebb:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.1.3", "matchCriteriaId": "2E60CBF3-000A-4CFE-AB1F-F1CC25A650DB"}]}]}], "references": [{"url": "https://github.com/NodeBB/NodeBB/commit/51096ad2345fb1d1380bec0a447113489ef6c359", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://github.com/NodeBB/NodeBB/releases/tag/v3.1.3", "source": "report@snyk.io", "tags": ["Release Notes"]}, {"url": "https://github.com/NodeBB/NodeBB/security/advisories/GHSA-4qcv-qf38-5j3j", "source": "report@snyk.io", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/NodeBB/NodeBB/commit/51096ad2345fb1d1380bec0a447113489ef6c359"}}