{"buggy_code": ["import fs from 'fs-extra';\nimport { homedir } from 'os';\nimport path from 'path';\nimport tempDir from 'temp-dir';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport gitCommitInfo from '../index';\n\nconst fixtures = path.join(tempDir, 'sgc', uuidv4());\nconst localFixtures = path.join(process.cwd(), '__tests__', 'fixtures');\n\nconst folders = [\n  'upToDate',\n  'multiline',\n  'merge',\n];\n\nbeforeAll(() => {\n  fs.copySync(localFixtures, fixtures);\n  folders.map((folder) => fs.renameSync(path.join(fixtures, folder, 'git'), path.join(fixtures, folder, '.git')));\n});\n\nafterAll(() => {\n  folders.map((folder) => fs.renameSync(path.join(fixtures, folder, '.git'), path.join(fixtures, folder, 'git')));\n});\n\ntest('up to date', () => {\n  const latestInfo = gitCommitInfo({ cwd: path.join(fixtures, 'multiline') });\n\n  expect(latestInfo.message).toBe('do not merge');\n  expect(latestInfo.author).toBe('JPeer264');\n  expect(latestInfo.email).toBe('jan.oster94@gmail.com');\n  expect(latestInfo.commit).toBe('19131a4a9465f38a5cab030beb173edd6e23c6de');\n  expect(latestInfo.shortCommit).toBe('19131a4');\n});\n\ntest('specific commit', () => {\n  const latestInfo = gitCommitInfo({\n    cwd: path.join(fixtures, 'multiline'),\n    commit: '66d6043fb740278dac391ad8b41df74ef9e68afc',\n  });\n\n  expect(latestInfo.message).toBe('Add: index.js\\n    \\n    Here is more information in the body\\n    \\n    BREAKING CHANGE: yes, here is a footer');\n  expect(latestInfo.author).toBe('JPeer264');\n  expect(latestInfo.email).toBe('jan.oster94@gmail.com');\n  expect(latestInfo.commit).toBe('66d6043fb740278dac391ad8b41df74ef9e68afc');\n  expect(latestInfo.shortCommit).toBe('66d6043');\n});\n\ntest('unknown commit hash', () => {\n  const latestInfo = gitCommitInfo({\n    cwd: path.join(fixtures, 'multiline'),\n    commit: 'does not work',\n  });\n\n  expect(!!latestInfo.error).toBe(true);\n});\n\ntest('check up to date', () => {\n  const mergeInfo = gitCommitInfo({\n    cwd: path.join(fixtures, 'upToDate'),\n    commit: '31107b9051efe17e57c583937e027993860b11a9',\n  });\n\n  expect(mergeInfo.commit).toBe('31107b9051efe17e57c583937e027993860b11a9');\n  expect(mergeInfo.message).toBe('Initial commit');\n});\n\ntest('merge conflict - named automatically', () => {\n  const mergeInfo = gitCommitInfo({\n    cwd: path.join(fixtures, 'merge'),\n    commit: '76d090566587fa5e97035b8c133866eb0116d7c0',\n  });\n\n  expect(mergeInfo.commit).toBe('76d090566587fa5e97035b8c133866eb0116d7c0');\n  expect(mergeInfo.message).toBe('Merge branch \\'test/merge\\'');\n});\n\ntest('merge conflict - named randomly', () => {\n  const mergeInfo = gitCommitInfo({\n    cwd: path.join(fixtures, 'merge'),\n    commit: 'e49bfdc2285f13aa5cc206a02a4f41b335026ea5',\n  });\n\n  expect(mergeInfo.commit).toBe('e49bfdc2285f13aa5cc206a02a4f41b335026ea5');\n  expect(mergeInfo.message).toBe('My message');\n});\n\ntest('no git repo', () => {\n  const latestInfo = gitCommitInfo({\n    cwd: homedir(),\n  });\n\n  expect(latestInfo).toEqual({});\n});\n", "import execa from 'execa';\nimport isGit from 'is-git-repository';\nimport path from 'path';\n\nexport interface GitCommitInfoOptions {\n  cwd?: string;\n  commit?: string;\n}\n\nexport interface GitCommitInfoResult {\n  hash?: string;\n  shortHash?: string;\n  commit?: string;\n  shortCommit?: string;\n  author?: string;\n  email?: string;\n  date?: string;\n  message?: string;\n  error?: Error,\n}\n\nconst regex = /\\s+([\\s\\S]*)/g; // matches everything after the first whitespace\n\nconst gitCommitInfo = (options: GitCommitInfoOptions = {}): GitCommitInfoResult => {\n  const {\n    cwd = process.cwd(),\n    commit,\n  } = options;\n  const thisCommit = commit || '';\n  const thisPath = path.resolve(cwd);\n\n  if (!isGit(thisPath)) {\n    return {};\n  }\n\n  try {\n    const { stdout } = execa.commandSync(`git --no-pager show ${thisCommit} --summary`, { cwd });\n\n    const info = stdout\n      .split('\\n')\n      .filter((entry) => entry.length !== 0);\n    const mergeIndex = info[1]?.indexOf('Merge') === -1 ? 0 : 1;\n\n    const hash = (new RegExp(regex).exec(info[0]) || [])[1];\n    const shortHash = hash.slice(0, 7);\n\n    const getInfo = (index: number): string | undefined => {\n      const [, extractedInfo] = (new RegExp(regex).exec(info[index]) || []);\n\n      return extractedInfo;\n    };\n\n    const author = (getInfo(1 + mergeIndex)?.match(/([^<]+)/) || [])[1]?.trim();\n    const [, email] = getInfo(1 + mergeIndex)?.match(/<([^>]+)>/) || [];\n    const date = getInfo(2 + mergeIndex);\n    const message = stdout.split('\\n\\n')[1].trim();\n\n    return {\n      hash,\n      shortHash,\n      commit: hash,\n      shortCommit: shortHash,\n      author,\n      email,\n      date,\n      message,\n    };\n  } catch (error) {\n    return { error };\n  }\n};\n\nexport default gitCommitInfo;\n"], "fixing_code": ["import fs from 'fs-extra';\nimport { homedir } from 'os';\nimport path from 'path';\nimport tempDir from 'temp-dir';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport gitCommitInfo from '../index';\n\nconst fixtures = path.join(tempDir, 'sgc', uuidv4());\nconst localFixtures = path.join(process.cwd(), '__tests__', 'fixtures');\n\nconst folders = [\n  'upToDate',\n  'multiline',\n  'merge',\n];\n\nbeforeAll(() => {\n  fs.copySync(localFixtures, fixtures);\n  folders.map((folder) => fs.renameSync(path.join(fixtures, folder, 'git'), path.join(fixtures, folder, '.git')));\n});\n\nafterAll(() => {\n  folders.map((folder) => fs.renameSync(path.join(fixtures, folder, '.git'), path.join(fixtures, folder, 'git')));\n});\n\ntest('up to date', () => {\n  const latestInfo = gitCommitInfo({ cwd: path.join(fixtures, 'multiline') });\n\n  expect(latestInfo.message).toBe('do not merge');\n  expect(latestInfo.author).toBe('JPeer264');\n  expect(latestInfo.email).toBe('jan.oster94@gmail.com');\n  expect(latestInfo.commit).toBe('19131a4a9465f38a5cab030beb173edd6e23c6de');\n  expect(latestInfo.shortCommit).toBe('19131a4');\n});\n\ntest('specific commit', () => {\n  const latestInfo = gitCommitInfo({\n    cwd: path.join(fixtures, 'multiline'),\n    commit: '66d6043fb740278dac391ad8b41df74ef9e68afc',\n  });\n\n  expect(latestInfo.message).toBe('Add: index.js\\n    \\n    Here is more information in the body\\n    \\n    BREAKING CHANGE: yes, here is a footer');\n  expect(latestInfo.author).toBe('JPeer264');\n  expect(latestInfo.email).toBe('jan.oster94@gmail.com');\n  expect(latestInfo.commit).toBe('66d6043fb740278dac391ad8b41df74ef9e68afc');\n  expect(latestInfo.shortCommit).toBe('66d6043');\n});\n\ntest('unknown commit hash', () => {\n  const latestInfo = gitCommitInfo({\n    cwd: path.join(fixtures, 'multiline'),\n    commit: 'does not work',\n  });\n\n  expect(!!latestInfo.error).toBe(true);\n});\n\ntest('check up to date', () => {\n  const mergeInfo = gitCommitInfo({\n    cwd: path.join(fixtures, 'upToDate'),\n    commit: '31107b9051efe17e57c583937e027993860b11a9',\n  });\n\n  expect(mergeInfo.commit).toBe('31107b9051efe17e57c583937e027993860b11a9');\n  expect(mergeInfo.message).toBe('Initial commit');\n});\n\ntest('merge conflict - named automatically', () => {\n  const mergeInfo = gitCommitInfo({\n    cwd: path.join(fixtures, 'merge'),\n    commit: '76d090566587fa5e97035b8c133866eb0116d7c0',\n  });\n\n  expect(mergeInfo.commit).toBe('76d090566587fa5e97035b8c133866eb0116d7c0');\n  expect(mergeInfo.message).toBe('Merge branch \\'test/merge\\'');\n});\n\ntest('merge conflict - named randomly', () => {\n  const mergeInfo = gitCommitInfo({\n    cwd: path.join(fixtures, 'merge'),\n    commit: 'e49bfdc2285f13aa5cc206a02a4f41b335026ea5',\n  });\n\n  expect(mergeInfo.commit).toBe('e49bfdc2285f13aa5cc206a02a4f41b335026ea5');\n  expect(mergeInfo.message).toBe('My message');\n});\n\ntest('no git repo', () => {\n  const latestInfo = gitCommitInfo({\n    cwd: homedir(),\n  });\n\n  expect(latestInfo).toEqual({});\n});\n\ntest('ignore invalid commits | #24', () => {\n  const latestInfo = gitCommitInfo({\n    cwd: path.join(fixtures, 'merge'),\n    commit: '82442c2405804d7aa44e7bedbc0b93bb17707626 || touch ci ||',\n  });\n\n  expect(latestInfo.error).toBeInstanceOf(Error);\n});\n", "import execa from 'execa';\nimport isGit from 'is-git-repository';\nimport path from 'path';\n\nexport interface GitCommitInfoOptions {\n  cwd?: string;\n  commit?: string;\n}\n\nexport interface GitCommitInfoResult {\n  hash?: string;\n  shortHash?: string;\n  commit?: string;\n  shortCommit?: string;\n  author?: string;\n  email?: string;\n  date?: string;\n  message?: string;\n  error?: Error,\n}\n\nconst regex = /\\s+([\\s\\S]*)/g; // matches everything after the first whitespace\nconst hashRegex = /^[0-9a-f]{7,40}$/;\n\nconst gitCommitInfo = (options: GitCommitInfoOptions = {}): GitCommitInfoResult => {\n  const {\n    cwd = process.cwd(),\n    commit,\n  } = options;\n  const thisCommit = commit || '';\n  const thisPath = path.resolve(cwd);\n\n  if ((thisCommit && !(new RegExp(hashRegex).test(thisCommit)))) {\n    return { error: new Error('Not a valid commit hash') };\n  }\n\n  if (!isGit(thisPath)) {\n    return {};\n  }\n\n  try {\n    const { stdout } = execa.commandSync(`git --no-pager show ${thisCommit} --summary`, { cwd });\n\n    const info = stdout\n      .split('\\n')\n      .filter((entry) => entry.length !== 0);\n    const mergeIndex = info[1]?.indexOf('Merge') === -1 ? 0 : 1;\n\n    const hash = (new RegExp(regex).exec(info[0]) || [])[1];\n    const shortHash = hash.slice(0, 7);\n\n    const getInfo = (index: number): string | undefined => {\n      const [, extractedInfo] = (new RegExp(regex).exec(info[index]) || []);\n\n      return extractedInfo;\n    };\n\n    const author = (getInfo(1 + mergeIndex)?.match(/([^<]+)/) || [])[1]?.trim();\n    const [, email] = getInfo(1 + mergeIndex)?.match(/<([^>]+)>/) || [];\n    const date = getInfo(2 + mergeIndex);\n    const message = stdout.split('\\n\\n')[1].trim();\n\n    return {\n      hash,\n      shortHash,\n      commit: hash,\n      shortCommit: shortHash,\n      author,\n      email,\n      date,\n      message,\n    };\n  } catch (error) {\n    return { error };\n  }\n};\n\nexport default gitCommitInfo;\n"], "filenames": ["__tests__/test.spec.ts", "index.ts"], "buggy_code_start_loc": [95, 22], "buggy_code_end_loc": [95, 30], "fixing_code_start_loc": [96, 23], "fixing_code_end_loc": [105, 36], "type": "CWE-77", "message": "Versions of the package git-commit-info before 2.0.2 are vulnerable to Command Injection such that the package-exported method gitCommitInfo () fails to sanitize its parameter commit, which later flows into a sensitive command execution API. As a result, attackers may inject malicious commands once they control the hash content.", "other": {"cve": {"id": "CVE-2023-26134", "sourceIdentifier": "report@snyk.io", "published": "2023-06-28T05:15:10.467", "lastModified": "2023-11-07T04:09:25.990", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Versions of the package git-commit-info before 2.0.2 are vulnerable to Command Injection such that the package-exported method gitCommitInfo () fails to sanitize its parameter commit, which later flows into a sensitive command execution API. As a result, attackers may inject malicious commands once they control the hash content."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}, {"source": "report@snyk.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:git-commit-info_project:git-commit-info:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.0.2", "matchCriteriaId": "2489C1D5-1EA8-4C4A-A3DB-AA4E8132FF0A"}]}]}], "references": [{"url": "https://github.com/JPeer264/node-git-commit-info/commit/f7c491ede51f886a988af9b266797cb24591d18c", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://github.com/JPeer264/node-git-commit-info/issues/24", "source": "report@snyk.io", "tags": ["Exploit", "Issue Tracking"]}, {"url": "https://security.snyk.io/vuln/SNYK-JS-GITCOMMITINFO-5740174", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/JPeer264/node-git-commit-info/commit/f7c491ede51f886a988af9b266797cb24591d18c"}}