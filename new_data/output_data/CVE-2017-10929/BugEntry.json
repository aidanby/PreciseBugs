{"buggy_code": ["/*\n *  GRUB  --  GRand Unified Bootloader\n *  Copyright (C) 2002,2003,2004,2006,2007,2008,2009,2010  Free Software Foundation, Inc.\n *\n *  GRUB is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  GRUB is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <grub/disk.h>\n#include <grub/err.h>\n#include <grub/mm.h>\n#include <grub/types.h>\n#include <grub/partition.h>\n#include <grub/misc.h>\n#include <grub/time.h>\n#include <grub/file.h>\n\nGRUB_EXPORT(grub_disk_dev_register);\nGRUB_EXPORT(grub_disk_dev_unregister);\nGRUB_EXPORT(grub_disk_dev_iterate);\n\nGRUB_EXPORT(grub_disk_open);\nGRUB_EXPORT(grub_disk_close);\nGRUB_EXPORT(grub_disk_read);\nGRUB_EXPORT(grub_disk_read_ex);\nGRUB_EXPORT(grub_disk_write);\n\nGRUB_EXPORT(grub_disk_get_size);\nGRUB_EXPORT(grub_disk_firmware_fini);\nGRUB_EXPORT(grub_disk_firmware_is_tainted);\n\nGRUB_EXPORT(grub_disk_ata_pass_through);\n\n#define\tGRUB_CACHE_TIMEOUT\t2\n\n/* The last time the disk was used.  */\nstatic grub_uint64_t grub_last_time = 0;\n\n\n/* Disk cache.  */\nstruct grub_disk_cache\n{\n  enum grub_disk_dev_id dev_id;\n  unsigned long disk_id;\n  grub_disk_addr_t sector;\n  char *data;\n  int lock;\n};\n\nstatic struct grub_disk_cache grub_disk_cache_table[GRUB_DISK_CACHE_NUM];\n\nvoid (*grub_disk_firmware_fini) (void);\nint grub_disk_firmware_is_tainted;\n\ngrub_err_t (* grub_disk_ata_pass_through) (grub_disk_t,\n\t    struct grub_disk_ata_pass_through_parms *);\n\n\n#if 0\nstatic unsigned long grub_disk_cache_hits;\nstatic unsigned long grub_disk_cache_misses;\n\nvoid\ngrub_disk_cache_get_performance (unsigned long *hits, unsigned long *misses)\n{\n  *hits = grub_disk_cache_hits;\n  *misses = grub_disk_cache_misses;\n}\n#endif\n\nstatic unsigned\ngrub_disk_cache_get_index (unsigned long dev_id, unsigned long disk_id,\n\t\t\t   grub_disk_addr_t sector)\n{\n  return ((dev_id * 524287UL + disk_id * 2606459UL\n\t   + ((unsigned) (sector >> GRUB_DISK_CACHE_BITS)))\n\t  % GRUB_DISK_CACHE_NUM);\n}\n\nstatic void\ngrub_disk_cache_invalidate (unsigned long dev_id, unsigned long disk_id,\n\t\t\t    grub_disk_addr_t sector)\n{\n  unsigned index;\n  struct grub_disk_cache *cache;\n\n  sector &= ~(GRUB_DISK_CACHE_SIZE - 1);\n  index = grub_disk_cache_get_index (dev_id, disk_id, sector);\n  cache = grub_disk_cache_table + index;\n\n  if (cache->dev_id == dev_id && cache->disk_id == disk_id\n      && cache->sector == sector && cache->data)\n    {\n      cache->lock = 1;\n      grub_free (cache->data);\n      cache->data = 0;\n      cache->lock = 0;\n    }\n}\n\nvoid\ngrub_disk_cache_invalidate_all (void)\n{\n  unsigned i;\n\n  for (i = 0; i < GRUB_DISK_CACHE_NUM; i++)\n    {\n      struct grub_disk_cache *cache = grub_disk_cache_table + i;\n\n      if (cache->data && ! cache->lock)\n\t{\n\t  grub_free (cache->data);\n\t  cache->data = 0;\n\t}\n    }\n}\n\nstatic char *\ngrub_disk_cache_fetch (unsigned long dev_id, unsigned long disk_id,\n\t\t       grub_disk_addr_t sector)\n{\n  struct grub_disk_cache *cache;\n  unsigned index;\n\n  index = grub_disk_cache_get_index (dev_id, disk_id, sector);\n  cache = grub_disk_cache_table + index;\n\n  if (cache->dev_id == dev_id && cache->disk_id == disk_id\n      && cache->sector == sector)\n    {\n      cache->lock = 1;\n#if 0\n      grub_disk_cache_hits++;\n#endif\n      return cache->data;\n    }\n\n#if 0\n  grub_disk_cache_misses++;\n#endif\n\n  return 0;\n}\n\nstatic void\ngrub_disk_cache_unlock (unsigned long dev_id, unsigned long disk_id,\n\t\t\tgrub_disk_addr_t sector)\n{\n  struct grub_disk_cache *cache;\n  unsigned index;\n\n  index = grub_disk_cache_get_index (dev_id, disk_id, sector);\n  cache = grub_disk_cache_table + index;\n\n  if (cache->dev_id == dev_id && cache->disk_id == disk_id\n      && cache->sector == sector)\n    cache->lock = 0;\n}\n\nstatic grub_err_t\ngrub_disk_cache_store (unsigned long dev_id, unsigned long disk_id,\n\t\t       grub_disk_addr_t sector, const char *data)\n{\n  unsigned index;\n  struct grub_disk_cache *cache;\n\n  index = grub_disk_cache_get_index (dev_id, disk_id, sector);\n  cache = grub_disk_cache_table + index;\n\n  cache->lock = 1;\n  grub_free (cache->data);\n  cache->data = 0;\n  cache->lock = 0;\n\n  cache->data = grub_malloc (GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS);\n  if (! cache->data)\n    return grub_errno;\n\n  grub_memcpy (cache->data, data,\n\t       GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS);\n  cache->dev_id = dev_id;\n  cache->disk_id = disk_id;\n  cache->sector = sector;\n\n  return GRUB_ERR_NONE;\n}\n\n\f\n\nstatic grub_disk_dev_t grub_disk_dev_list;\n\nvoid\ngrub_disk_dev_register (grub_disk_dev_t dev)\n{\n  dev->next = grub_disk_dev_list;\n  grub_disk_dev_list = dev;\n}\n\nvoid\ngrub_disk_dev_unregister (grub_disk_dev_t dev)\n{\n  grub_disk_dev_t *p, q;\n\n  for (p = &grub_disk_dev_list, q = *p; q; p = &(q->next), q = q->next)\n    if (q == dev)\n      {\n        *p = q->next;\n\tbreak;\n      }\n}\n\nint\ngrub_disk_dev_iterate (int (*hook) (const char *name, void *closure),\n\t\t       void *closure)\n{\n  grub_disk_dev_t p;\n\n  for (p = grub_disk_dev_list; p; p = p->next)\n    if (p->iterate && (p->iterate) (hook, closure))\n      return 1;\n\n  return 0;\n}\n\n/* Return the location of the first ',', if any, which is not\n   escaped by a '\\'.  */\nstatic const char *\nfind_part_sep (const char *name)\n{\n  const char *p = name;\n  char c;\n\n  while ((c = *p++) != '\\0')\n    {\n      if (c == '\\\\' && *p == ',')\n\tp++;\n      else if (c == ',')\n\treturn p - 1;\n    }\n  return NULL;\n}\n\ngrub_disk_t\ngrub_disk_open (const char *name)\n{\n  const char *p;\n  grub_disk_t disk;\n  grub_disk_dev_t dev;\n  char *raw = (char *) name;\n  grub_uint64_t current_time;\n\n  grub_dprintf (\"disk\", \"Opening `%s'...\\n\", name);\n\n  disk = (grub_disk_t) grub_zalloc (sizeof (*disk));\n  if (! disk)\n    return 0;\n\n  disk->name = grub_strdup (name);\n  if (! disk->name)\n    goto fail;\n\n  p = find_part_sep (name);\n  if (p)\n    {\n      grub_size_t len = p - name;\n\n      raw = grub_malloc (len + 1);\n      if (! raw)\n\tgoto fail;\n\n      grub_memcpy (raw, name, len);\n      raw[len] = '\\0';\n    }\n\n  for (dev = grub_disk_dev_list; dev; dev = dev->next)\n    {\n      if ((dev->open) (raw, disk) == GRUB_ERR_NONE)\n\tbreak;\n      else if (grub_errno == GRUB_ERR_UNKNOWN_DEVICE)\n\tgrub_errno = GRUB_ERR_NONE;\n      else\n\tgoto fail;\n    }\n\n  if (! dev)\n    {\n      grub_error (GRUB_ERR_UNKNOWN_DEVICE, \"no such disk\");\n      goto fail;\n    }\n\n  if (p && ! disk->has_partitions)\n    {\n      grub_error (GRUB_ERR_BAD_DEVICE, \"no partition on this disk\");\n      goto fail;\n    }\n\n  disk->dev = dev;\n\n  if (p)\n    {\n      disk->partition = grub_partition_probe (disk, p + 1);\n      if (! disk->partition)\n\t{\n\t  grub_error (GRUB_ERR_UNKNOWN_DEVICE, \"no such partition\");\n\t  goto fail;\n\t}\n    }\n\n  /* The cache will be invalidated about 2 seconds after a device was\n     closed.  */\n  current_time = grub_get_time_ms ();\n\n  if (current_time > (grub_last_time\n\t\t      + GRUB_CACHE_TIMEOUT * 1000))\n    grub_disk_cache_invalidate_all ();\n\n  grub_last_time = current_time;\n\n fail:\n\n  if (raw && raw != name)\n    grub_free (raw);\n\n  if (grub_errno != GRUB_ERR_NONE)\n    {\n      grub_error_push ();\n      grub_dprintf (\"disk\", \"Opening `%s' failed.\\n\", name);\n      grub_error_pop ();\n\n      grub_disk_close (disk);\n      return 0;\n    }\n\n  return disk;\n}\n\nvoid\ngrub_disk_close (grub_disk_t disk)\n{\n  grub_partition_t part;\n  grub_dprintf (\"disk\", \"Closing `%s'.\\n\", disk->name);\n\n  if (disk->dev && disk->dev->close)\n    (disk->dev->close) (disk);\n\n  /* Reset the timer.  */\n  grub_last_time = grub_get_time_ms ();\n\n  while (disk->partition)\n    {\n      part = disk->partition->parent;\n      grub_free (disk->partition);\n      disk->partition = part;\n    }\n  grub_free ((void *) disk->name);\n  grub_free (disk);\n}\n\n/* This function performs three tasks:\n   - Make sectors disk relative from partition relative.\n   - Normalize offset to be less than the sector size.\n   - Verify that the range is inside the partition.  */\nstatic grub_err_t\ngrub_disk_adjust_range (grub_disk_t disk, grub_disk_addr_t *sector,\n\t\t\tgrub_off_t *offset, grub_size_t size)\n{\n  *sector += *offset >> GRUB_DISK_SECTOR_BITS;\n  *offset &= GRUB_DISK_SECTOR_SIZE - 1;\n/*\n  grub_partition_t part;\n  for (part = disk->partition; part; part = part->parent)\n    {\n      grub_disk_addr_t start;\n      grub_uint64_t len;\n\n      start = part->start;\n      len = part->len;\n\n      if (*sector >= len\n\t  || len - *sector < ((*offset + size + GRUB_DISK_SECTOR_SIZE - 1)\n\t\t\t      >> GRUB_DISK_SECTOR_BITS))\n\treturn grub_error (GRUB_ERR_OUT_OF_RANGE, \"out of partition\");\n\n      *sector += start;\n    }\n\n  if (disk->total_sectors <= *sector\n      || ((*offset + size + GRUB_DISK_SECTOR_SIZE - 1)\n\t  >> GRUB_DISK_SECTOR_BITS) > disk->total_sectors - *sector)\n    return grub_error (GRUB_ERR_OUT_OF_RANGE, \"out of disk\");\n*/\n  return GRUB_ERR_NONE;\n\n}\n\n/* Read data from the disk.  */\ngrub_err_t\ngrub_disk_read (grub_disk_t disk, grub_disk_addr_t sector,\n\t\tgrub_off_t offset, grub_size_t size, void *buf)\n{\n  char *tmp_buf;\n  unsigned real_offset;\n\n  /* First of all, check if the region is within the disk.  */\n  if (grub_disk_adjust_range (disk, &sector, &offset, size) != GRUB_ERR_NONE)\n    {\n      grub_error_push ();\n      grub_dprintf (\"disk\", \"Read out of range: sector 0x%llx (%s).\\n\",\n\t\t    (unsigned long long) sector, grub_errmsg);\n      grub_error_pop ();\n      return grub_errno;\n    }\n\n  real_offset = offset;\n\n  /* Allocate a temporary buffer.  */\n  tmp_buf = grub_malloc (GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS);\n  if (! tmp_buf)\n    return grub_errno;\n\n  /* Until SIZE is zero...  */\n  while (size)\n    {\n      char *data;\n      grub_disk_addr_t start_sector;\n      grub_size_t len;\n      grub_size_t pos;\n\n      /* For reading bulk data.  */\n      start_sector = sector & ~(GRUB_DISK_CACHE_SIZE - 1);\n      pos = (sector - start_sector) << GRUB_DISK_SECTOR_BITS;\n      len = ((GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS)\n\t     - pos - real_offset);\n      if (len > size)\n\tlen = size;\n\n      /* Fetch the cache.  */\n      data = grub_disk_cache_fetch (disk->dev->id, disk->id, start_sector);\n      if (data)\n\t{\n\t  /* Just copy it!  */\n\t  if (buf)\n\t    grub_memcpy (buf, data + pos + real_offset, len);\n\t  grub_disk_cache_unlock (disk->dev->id, disk->id, start_sector);\n\t}\n      else\n\t{\n\t  /* Otherwise read data from the disk actually.  */\n\t  if (start_sector + GRUB_DISK_CACHE_SIZE > disk->total_sectors\n\t      || (disk->dev->read) (disk, start_sector,\n\t\t\t\t    GRUB_DISK_CACHE_SIZE, tmp_buf)\n\t      != GRUB_ERR_NONE)\n\t    {\n\t      /* Uggh... Failed. Instead, just read necessary data.  */\n\t      unsigned num;\n\t      char *p;\n\n\t      grub_errno = GRUB_ERR_NONE;\n\n\t      num = ((size + real_offset + GRUB_DISK_SECTOR_SIZE - 1)\n\t\t     >> GRUB_DISK_SECTOR_BITS);\n\n\t      p = grub_realloc (tmp_buf, num << GRUB_DISK_SECTOR_BITS);\n\t      if (!p)\n\t\tgoto finish;\n\n\t      tmp_buf = p;\n\n\t      if ((disk->dev->read) (disk, sector, num, tmp_buf))\n\t\t{\n\t\t  grub_error_push ();\n\t\t  grub_dprintf (\"disk\", \"%s read failed\\n\", disk->name);\n\t\t  grub_error_pop ();\n\t\t  goto finish;\n\t\t}\n\n\t      if (buf)\n\t\tgrub_memcpy (buf, tmp_buf + real_offset, size);\n\n\t      /* Call the read hook, if any.  */\n\t      if (disk->read_hook)\n\t\twhile (size)\n\t\t  {\n\t\t    grub_size_t to_read;\n\n\t\t    to_read = size;\n\t\t    if (real_offset + to_read > GRUB_DISK_SECTOR_SIZE)\n\t\t      to_read = GRUB_DISK_SECTOR_SIZE - real_offset;\n\t\t    (disk->read_hook) (sector, real_offset,\n\t\t\t\t       to_read, disk->closure);\n\t\t    if (grub_errno != GRUB_ERR_NONE)\n\t\t      goto finish;\n\n\t\t    sector++;\n\t\t    size -= to_read;\n\t\t    real_offset = 0;\n\t\t  }\n\n\t      /* This must be the end.  */\n\t      goto finish;\n\t    }\n\n\t  /* Copy it and store it in the disk cache.  */\n\t  if (buf)\n\t    grub_memcpy (buf, tmp_buf + pos + real_offset, len);\n\t  grub_disk_cache_store (disk->dev->id, disk->id,\n\t\t\t\t start_sector, tmp_buf);\n\t}\n\n      /* Call the read hook, if any.  */\n      if (disk->read_hook)\n\t{\n\t  grub_disk_addr_t s = sector;\n\t  grub_size_t l = len;\n\n\t  while (l)\n\t    {\n\t      (disk->read_hook) (s, real_offset,\n\t\t\t\t ((l > GRUB_DISK_SECTOR_SIZE)\n\t\t\t\t  ? GRUB_DISK_SECTOR_SIZE\n\t\t\t\t  : l), disk->closure);\n\n\t      if (l < GRUB_DISK_SECTOR_SIZE - real_offset)\n\t\tbreak;\n\n\t      s++;\n\t      l -= GRUB_DISK_SECTOR_SIZE - real_offset;\n\t      real_offset = 0;\n\t    }\n\t}\n\n      sector = start_sector + GRUB_DISK_CACHE_SIZE;\n      if (buf)\n\tbuf = (char *) buf + len;\n      size -= len;\n      real_offset = 0;\n    }\n\n finish:\n\n  grub_free (tmp_buf);\n\n  return grub_errno;\n}\n\ngrub_err_t\ngrub_disk_read_ex (grub_disk_t disk, grub_disk_addr_t sector,\n\t\t   grub_off_t offset, grub_size_t size, void *buf, int flags)\n{\n  unsigned real_offset;\n\n  if (! flags)\n    return grub_disk_read (disk, sector, offset, size, buf);\n\n  if (grub_disk_adjust_range (disk, &sector, &offset, size) != GRUB_ERR_NONE)\n    return grub_errno;\n\n  real_offset = offset;\n  while (size)\n    {\n      char tmp_buf[GRUB_DISK_SECTOR_SIZE];\n      grub_size_t len;\n\n      if ((real_offset != 0) || (size < GRUB_DISK_SECTOR_SIZE))\n\t{\n\t  len = GRUB_DISK_SECTOR_SIZE - real_offset;\n\t  if (len > size)\n\t    len = size;\n\n\t  if (buf)\n\t    {\n\t      if ((disk->dev->read) (disk, sector, 1, tmp_buf) != GRUB_ERR_NONE)\n\t\tbreak;\n\t      grub_memcpy (buf, tmp_buf + real_offset, len);\n\t    }\n\n\t  if (disk->read_hook)\n\t    (disk->read_hook) (sector, real_offset, len, disk->closure);\n\n\t  sector++;\n\t  real_offset = 0;\n\t}\n      else\n\t{\n\t  grub_size_t n;\n\n\t  len = size & ~(GRUB_DISK_SECTOR_SIZE - 1);\n\t  n = size >> GRUB_DISK_SECTOR_BITS;\n\n\t  if ((buf) &&\n\t      ((disk->dev->read) (disk, sector, n, buf) != GRUB_ERR_NONE))\n\t    break;\n\n\t  if (disk->read_hook)\n\t    {\n\t      while (n)\n\t\t{\n\t\t  (disk->read_hook) (sector++, 0, GRUB_DISK_SECTOR_SIZE,\n\t\t\t\t     disk->closure);\n\t\t  n--;\n\t\t}\n\t    }\n\t  else\n\t    sector += n;\n\t}\n\n      if (buf)\n\tbuf = (char *) buf + len;\n      size -= len;\n    }\n\n  return grub_errno;\n}\n\ngrub_err_t\ngrub_disk_write (grub_disk_t disk, grub_disk_addr_t sector,\n\t\t grub_off_t offset, grub_size_t size, const void *buf)\n{\n  unsigned real_offset;\n\n  grub_dprintf (\"disk\", \"Writing `%s'...\\n\", disk->name);\n\n  if (grub_disk_adjust_range (disk, &sector, &offset, size) != GRUB_ERR_NONE)\n    return grub_errno;\n\n  real_offset = offset;\n\n  while (size)\n    {\n      if (real_offset != 0 || (size < GRUB_DISK_SECTOR_SIZE && size != 0))\n\t{\n\t  char tmp_buf[GRUB_DISK_SECTOR_SIZE];\n\t  grub_size_t len;\n\t  grub_partition_t part;\n\n\t  part = disk->partition;\n\t  disk->partition = 0;\n\t  if (grub_disk_read (disk, sector, 0, GRUB_DISK_SECTOR_SIZE, tmp_buf)\n\t      != GRUB_ERR_NONE)\n\t    {\n\t      disk->partition = part;\n\t      goto finish;\n\t    }\n\t  disk->partition = part;\n\n\t  len = GRUB_DISK_SECTOR_SIZE - real_offset;\n\t  if (len > size)\n\t    len = size;\n\n\t  grub_memcpy (tmp_buf + real_offset, buf, len);\n\n\t  grub_disk_cache_invalidate (disk->dev->id, disk->id, sector);\n\n\t  if ((disk->dev->write) (disk, sector, 1, tmp_buf) != GRUB_ERR_NONE)\n\t    goto finish;\n\n\t  sector++;\n\t  buf = (char *) buf + len;\n\t  size -= len;\n\t  real_offset = 0;\n\t}\n      else\n\t{\n\t  grub_size_t len;\n\t  grub_size_t n;\n\n\t  len = size & ~(GRUB_DISK_SECTOR_SIZE - 1);\n\t  n = size >> GRUB_DISK_SECTOR_BITS;\n\n\t  if ((disk->dev->write) (disk, sector, n, buf) != GRUB_ERR_NONE)\n\t    goto finish;\n\n\t  while (n--)\n\t    grub_disk_cache_invalidate (disk->dev->id, disk->id, sector++);\n\n\t  buf = (char *) buf + len;\n\t  size -= len;\n\t}\n    }\n\n finish:\n\n  return grub_errno;\n}\n\ngrub_uint64_t\ngrub_disk_get_size (grub_disk_t disk)\n{\n  if (disk->partition)\n    return grub_partition_get_len (disk->partition);\n  else\n    return disk->total_sectors;\n}\n"], "fixing_code": ["/*\n *  GRUB  --  GRand Unified Bootloader\n *  Copyright (C) 2002,2003,2004,2006,2007,2008,2009,2010  Free Software Foundation, Inc.\n *\n *  GRUB is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  GRUB is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <grub/disk.h>\n#include <grub/err.h>\n#include <grub/mm.h>\n#include <grub/types.h>\n#include <grub/partition.h>\n#include <grub/misc.h>\n#include <grub/time.h>\n#include <grub/file.h>\n\nGRUB_EXPORT(grub_disk_dev_register);\nGRUB_EXPORT(grub_disk_dev_unregister);\nGRUB_EXPORT(grub_disk_dev_iterate);\n\nGRUB_EXPORT(grub_disk_open);\nGRUB_EXPORT(grub_disk_close);\nGRUB_EXPORT(grub_disk_read);\nGRUB_EXPORT(grub_disk_read_ex);\nGRUB_EXPORT(grub_disk_write);\n\nGRUB_EXPORT(grub_disk_get_size);\nGRUB_EXPORT(grub_disk_firmware_fini);\nGRUB_EXPORT(grub_disk_firmware_is_tainted);\n\nGRUB_EXPORT(grub_disk_ata_pass_through);\n\n#define\tGRUB_CACHE_TIMEOUT\t2\n\n/* The last time the disk was used.  */\nstatic grub_uint64_t grub_last_time = 0;\n\n\n/* Disk cache.  */\nstruct grub_disk_cache\n{\n  enum grub_disk_dev_id dev_id;\n  unsigned long disk_id;\n  grub_disk_addr_t sector;\n  char *data;\n  int lock;\n};\n\nstatic struct grub_disk_cache grub_disk_cache_table[GRUB_DISK_CACHE_NUM];\n\nvoid (*grub_disk_firmware_fini) (void);\nint grub_disk_firmware_is_tainted;\n\ngrub_err_t (* grub_disk_ata_pass_through) (grub_disk_t,\n\t    struct grub_disk_ata_pass_through_parms *);\n\n\n#if 0\nstatic unsigned long grub_disk_cache_hits;\nstatic unsigned long grub_disk_cache_misses;\n\nvoid\ngrub_disk_cache_get_performance (unsigned long *hits, unsigned long *misses)\n{\n  *hits = grub_disk_cache_hits;\n  *misses = grub_disk_cache_misses;\n}\n#endif\n\nstatic unsigned\ngrub_disk_cache_get_index (unsigned long dev_id, unsigned long disk_id,\n\t\t\t   grub_disk_addr_t sector)\n{\n  return ((dev_id * 524287UL + disk_id * 2606459UL\n\t   + ((unsigned) (sector >> GRUB_DISK_CACHE_BITS)))\n\t  % GRUB_DISK_CACHE_NUM);\n}\n\nstatic void\ngrub_disk_cache_invalidate (unsigned long dev_id, unsigned long disk_id,\n\t\t\t    grub_disk_addr_t sector)\n{\n  unsigned index;\n  struct grub_disk_cache *cache;\n\n  sector &= ~(GRUB_DISK_CACHE_SIZE - 1);\n  index = grub_disk_cache_get_index (dev_id, disk_id, sector);\n  cache = grub_disk_cache_table + index;\n\n  if (cache->dev_id == dev_id && cache->disk_id == disk_id\n      && cache->sector == sector && cache->data)\n    {\n      cache->lock = 1;\n      grub_free (cache->data);\n      cache->data = 0;\n      cache->lock = 0;\n    }\n}\n\nvoid\ngrub_disk_cache_invalidate_all (void)\n{\n  unsigned i;\n\n  for (i = 0; i < GRUB_DISK_CACHE_NUM; i++)\n    {\n      struct grub_disk_cache *cache = grub_disk_cache_table + i;\n\n      if (cache->data && ! cache->lock)\n\t{\n\t  grub_free (cache->data);\n\t  cache->data = 0;\n\t}\n    }\n}\n\nstatic char *\ngrub_disk_cache_fetch (unsigned long dev_id, unsigned long disk_id,\n\t\t       grub_disk_addr_t sector)\n{\n  struct grub_disk_cache *cache;\n  unsigned index;\n\n  index = grub_disk_cache_get_index (dev_id, disk_id, sector);\n  cache = grub_disk_cache_table + index;\n\n  if (cache->dev_id == dev_id && cache->disk_id == disk_id\n      && cache->sector == sector)\n    {\n      cache->lock = 1;\n#if 0\n      grub_disk_cache_hits++;\n#endif\n      return cache->data;\n    }\n\n#if 0\n  grub_disk_cache_misses++;\n#endif\n\n  return 0;\n}\n\nstatic void\ngrub_disk_cache_unlock (unsigned long dev_id, unsigned long disk_id,\n\t\t\tgrub_disk_addr_t sector)\n{\n  struct grub_disk_cache *cache;\n  unsigned index;\n\n  index = grub_disk_cache_get_index (dev_id, disk_id, sector);\n  cache = grub_disk_cache_table + index;\n\n  if (cache->dev_id == dev_id && cache->disk_id == disk_id\n      && cache->sector == sector)\n    cache->lock = 0;\n}\n\nstatic grub_err_t\ngrub_disk_cache_store (unsigned long dev_id, unsigned long disk_id,\n\t\t       grub_disk_addr_t sector, const char *data)\n{\n  unsigned index;\n  struct grub_disk_cache *cache;\n\n  index = grub_disk_cache_get_index (dev_id, disk_id, sector);\n  cache = grub_disk_cache_table + index;\n\n  cache->lock = 1;\n  grub_free (cache->data);\n  cache->data = 0;\n  cache->lock = 0;\n\n  cache->data = grub_malloc (GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS);\n  if (! cache->data)\n    return grub_errno;\n\n  grub_memcpy (cache->data, data,\n\t       GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS);\n  cache->dev_id = dev_id;\n  cache->disk_id = disk_id;\n  cache->sector = sector;\n\n  return GRUB_ERR_NONE;\n}\n\n\f\n\nstatic grub_disk_dev_t grub_disk_dev_list;\n\nvoid\ngrub_disk_dev_register (grub_disk_dev_t dev)\n{\n  dev->next = grub_disk_dev_list;\n  grub_disk_dev_list = dev;\n}\n\nvoid\ngrub_disk_dev_unregister (grub_disk_dev_t dev)\n{\n  grub_disk_dev_t *p, q;\n\n  for (p = &grub_disk_dev_list, q = *p; q; p = &(q->next), q = q->next)\n    if (q == dev)\n      {\n        *p = q->next;\n\tbreak;\n      }\n}\n\nint\ngrub_disk_dev_iterate (int (*hook) (const char *name, void *closure),\n\t\t       void *closure)\n{\n  grub_disk_dev_t p;\n\n  for (p = grub_disk_dev_list; p; p = p->next)\n    if (p->iterate && (p->iterate) (hook, closure))\n      return 1;\n\n  return 0;\n}\n\n/* Return the location of the first ',', if any, which is not\n   escaped by a '\\'.  */\nstatic const char *\nfind_part_sep (const char *name)\n{\n  const char *p = name;\n  char c;\n\n  while ((c = *p++) != '\\0')\n    {\n      if (c == '\\\\' && *p == ',')\n\tp++;\n      else if (c == ',')\n\treturn p - 1;\n    }\n  return NULL;\n}\n\ngrub_disk_t\ngrub_disk_open (const char *name)\n{\n  const char *p;\n  grub_disk_t disk;\n  grub_disk_dev_t dev;\n  char *raw = (char *) name;\n  grub_uint64_t current_time;\n\n  grub_dprintf (\"disk\", \"Opening `%s'...\\n\", name);\n\n  disk = (grub_disk_t) grub_zalloc (sizeof (*disk));\n  if (! disk)\n    return 0;\n\n  disk->name = grub_strdup (name);\n  if (! disk->name)\n    goto fail;\n\n  p = find_part_sep (name);\n  if (p)\n    {\n      grub_size_t len = p - name;\n\n      raw = grub_malloc (len + 1);\n      if (! raw)\n\tgoto fail;\n\n      grub_memcpy (raw, name, len);\n      raw[len] = '\\0';\n    }\n\n  for (dev = grub_disk_dev_list; dev; dev = dev->next)\n    {\n      if ((dev->open) (raw, disk) == GRUB_ERR_NONE)\n\tbreak;\n      else if (grub_errno == GRUB_ERR_UNKNOWN_DEVICE)\n\tgrub_errno = GRUB_ERR_NONE;\n      else\n\tgoto fail;\n    }\n\n  if (! dev)\n    {\n      grub_error (GRUB_ERR_UNKNOWN_DEVICE, \"no such disk\");\n      goto fail;\n    }\n\n  if (p && ! disk->has_partitions)\n    {\n      grub_error (GRUB_ERR_BAD_DEVICE, \"no partition on this disk\");\n      goto fail;\n    }\n\n  disk->dev = dev;\n\n  if (p)\n    {\n      disk->partition = grub_partition_probe (disk, p + 1);\n      if (! disk->partition)\n\t{\n\t  grub_error (GRUB_ERR_UNKNOWN_DEVICE, \"no such partition\");\n\t  goto fail;\n\t}\n    }\n\n  /* The cache will be invalidated about 2 seconds after a device was\n     closed.  */\n  current_time = grub_get_time_ms ();\n\n  if (current_time > (grub_last_time\n\t\t      + GRUB_CACHE_TIMEOUT * 1000))\n    grub_disk_cache_invalidate_all ();\n\n  grub_last_time = current_time;\n\n fail:\n\n  if (raw && raw != name)\n    grub_free (raw);\n\n  if (grub_errno != GRUB_ERR_NONE)\n    {\n      grub_error_push ();\n      grub_dprintf (\"disk\", \"Opening `%s' failed.\\n\", name);\n      grub_error_pop ();\n\n      grub_disk_close (disk);\n      return 0;\n    }\n\n  return disk;\n}\n\nvoid\ngrub_disk_close (grub_disk_t disk)\n{\n  grub_partition_t part;\n  grub_dprintf (\"disk\", \"Closing `%s'.\\n\", disk->name);\n\n  if (disk->dev && disk->dev->close)\n    (disk->dev->close) (disk);\n\n  /* Reset the timer.  */\n  grub_last_time = grub_get_time_ms ();\n\n  while (disk->partition)\n    {\n      part = disk->partition->parent;\n      grub_free (disk->partition);\n      disk->partition = part;\n    }\n  grub_free ((void *) disk->name);\n  grub_free (disk);\n}\n\n/* This function performs three tasks:\n   - Make sectors disk relative from partition relative.\n   - Normalize offset to be less than the sector size.\n   - Verify that the range is inside the partition.  */\nstatic grub_err_t\ngrub_disk_adjust_range (grub_disk_t disk, grub_disk_addr_t *sector,\n\t\t\tgrub_off_t *offset, grub_size_t size)\n{\n  *sector += *offset >> GRUB_DISK_SECTOR_BITS;\n  *offset &= GRUB_DISK_SECTOR_SIZE - 1;\n/*\n  grub_partition_t part;\n  for (part = disk->partition; part; part = part->parent)\n    {\n      grub_disk_addr_t start;\n      grub_uint64_t len;\n\n      start = part->start;\n      len = part->len;\n\n      if (*sector >= len\n\t  || len - *sector < ((*offset + size + GRUB_DISK_SECTOR_SIZE - 1)\n\t\t\t      >> GRUB_DISK_SECTOR_BITS))\n\treturn grub_error (GRUB_ERR_OUT_OF_RANGE, \"out of partition\");\n\n      *sector += start;\n    }\n\n  if (disk->total_sectors <= *sector\n      || ((*offset + size + GRUB_DISK_SECTOR_SIZE - 1)\n\t  >> GRUB_DISK_SECTOR_BITS) > disk->total_sectors - *sector)\n    return grub_error (GRUB_ERR_OUT_OF_RANGE, \"out of disk\");\n*/\n  return GRUB_ERR_NONE;\n\n}\n\n/* Read data from the disk.  */\ngrub_err_t\ngrub_disk_read (grub_disk_t disk, grub_disk_addr_t sector,\n\t\tgrub_off_t offset, grub_size_t size, void *buf)\n{\n  char *tmp_buf;\n  unsigned real_offset;\n\n  /* First of all, check if the region is within the disk.  */\n  if (grub_disk_adjust_range (disk, &sector, &offset, size) != GRUB_ERR_NONE)\n    {\n      grub_error_push ();\n      grub_dprintf (\"disk\", \"Read out of range: sector 0x%llx (%s).\\n\",\n\t\t    (unsigned long long) sector, grub_errmsg);\n      grub_error_pop ();\n      return grub_errno;\n    }\n\n  real_offset = offset;\n\n  /* Allocate a temporary buffer.  */\n  tmp_buf = grub_malloc (GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS);\n  if (! tmp_buf)\n    return grub_errno;\n\n  /* Until SIZE is zero...  */\n  while (size)\n    {\n      char *data;\n      grub_disk_addr_t start_sector;\n      grub_size_t len;\n      grub_size_t pos;\n\n      /* For reading bulk data.  */\n      start_sector = sector & ~(GRUB_DISK_CACHE_SIZE - 1);\n      pos = (sector - start_sector) << GRUB_DISK_SECTOR_BITS;\n      len = ((GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS)\n\t     - pos - real_offset);\n      if (len > size)\n\tlen = size;\n\n      /* Fetch the cache.  */\n      data = grub_disk_cache_fetch (disk->dev->id, disk->id, start_sector);\n      if (data)\n\t{\n\t  /* Just copy it!  */\n\t  if (buf) {\n\t    if (pos + real_offset + len >= size) {\n              // prevent read overflow\n              grub_errno = GRUB_ERR_BAD_FS;\n              return grub_errno;\n\t    }\n\t    grub_memcpy (buf, data + pos + real_offset, len);\n          }\n\t  grub_disk_cache_unlock (disk->dev->id, disk->id, start_sector);\n\t}\n      else\n\t{\n\t  /* Otherwise read data from the disk actually.  */\n\t  if (start_sector + GRUB_DISK_CACHE_SIZE > disk->total_sectors\n\t      || (disk->dev->read) (disk, start_sector,\n\t\t\t\t    GRUB_DISK_CACHE_SIZE, tmp_buf)\n\t      != GRUB_ERR_NONE)\n\t    {\n\t      /* Uggh... Failed. Instead, just read necessary data.  */\n\t      unsigned num;\n\t      char *p;\n\n\t      grub_errno = GRUB_ERR_NONE;\n\n\t      num = ((size + real_offset + GRUB_DISK_SECTOR_SIZE - 1)\n\t\t     >> GRUB_DISK_SECTOR_BITS);\n\n\t      p = grub_realloc (tmp_buf, num << GRUB_DISK_SECTOR_BITS);\n\t      if (!p)\n\t\tgoto finish;\n\n\t      tmp_buf = p;\n\n\t      if ((disk->dev->read) (disk, sector, num, tmp_buf))\n\t\t{\n\t\t  grub_error_push ();\n\t\t  grub_dprintf (\"disk\", \"%s read failed\\n\", disk->name);\n\t\t  grub_error_pop ();\n\t\t  goto finish;\n\t\t}\n\n\t      if (buf)\n\t\tgrub_memcpy (buf, tmp_buf + real_offset, size);\n\n\t      /* Call the read hook, if any.  */\n\t      if (disk->read_hook)\n\t\twhile (size)\n\t\t  {\n\t\t    grub_size_t to_read;\n\n\t\t    to_read = size;\n\t\t    if (real_offset + to_read > GRUB_DISK_SECTOR_SIZE)\n\t\t      to_read = GRUB_DISK_SECTOR_SIZE - real_offset;\n\t\t    (disk->read_hook) (sector, real_offset,\n\t\t\t\t       to_read, disk->closure);\n\t\t    if (grub_errno != GRUB_ERR_NONE)\n\t\t      goto finish;\n\n\t\t    sector++;\n\t\t    size -= to_read;\n\t\t    real_offset = 0;\n\t\t  }\n\n\t      /* This must be the end.  */\n\t      goto finish;\n\t    }\n\n\t  /* Copy it and store it in the disk cache.  */\n\t  if (buf)\n\t    grub_memcpy (buf, tmp_buf + pos + real_offset, len);\n\t  grub_disk_cache_store (disk->dev->id, disk->id,\n\t\t\t\t start_sector, tmp_buf);\n\t}\n\n      /* Call the read hook, if any.  */\n      if (disk->read_hook)\n\t{\n\t  grub_disk_addr_t s = sector;\n\t  grub_size_t l = len;\n\n\t  while (l)\n\t    {\n\t      (disk->read_hook) (s, real_offset,\n\t\t\t\t ((l > GRUB_DISK_SECTOR_SIZE)\n\t\t\t\t  ? GRUB_DISK_SECTOR_SIZE\n\t\t\t\t  : l), disk->closure);\n\n\t      if (l < GRUB_DISK_SECTOR_SIZE - real_offset)\n\t\tbreak;\n\n\t      s++;\n\t      l -= GRUB_DISK_SECTOR_SIZE - real_offset;\n\t      real_offset = 0;\n\t    }\n\t}\n\n      sector = start_sector + GRUB_DISK_CACHE_SIZE;\n      if (buf)\n\tbuf = (char *) buf + len;\n      size -= len;\n      real_offset = 0;\n    }\n\n finish:\n\n  grub_free (tmp_buf);\n\n  return grub_errno;\n}\n\ngrub_err_t\ngrub_disk_read_ex (grub_disk_t disk, grub_disk_addr_t sector,\n\t\t   grub_off_t offset, grub_size_t size, void *buf, int flags)\n{\n  unsigned real_offset;\n\n  if (! flags)\n    return grub_disk_read (disk, sector, offset, size, buf);\n\n  if (grub_disk_adjust_range (disk, &sector, &offset, size) != GRUB_ERR_NONE)\n    return grub_errno;\n\n  real_offset = offset;\n  while (size)\n    {\n      char tmp_buf[GRUB_DISK_SECTOR_SIZE];\n      grub_size_t len;\n\n      if ((real_offset != 0) || (size < GRUB_DISK_SECTOR_SIZE))\n\t{\n\t  len = GRUB_DISK_SECTOR_SIZE - real_offset;\n\t  if (len > size)\n\t    len = size;\n\n\t  if (buf)\n\t    {\n\t      if ((disk->dev->read) (disk, sector, 1, tmp_buf) != GRUB_ERR_NONE)\n\t\tbreak;\n\t      grub_memcpy (buf, tmp_buf + real_offset, len);\n\t    }\n\n\t  if (disk->read_hook)\n\t    (disk->read_hook) (sector, real_offset, len, disk->closure);\n\n\t  sector++;\n\t  real_offset = 0;\n\t}\n      else\n\t{\n\t  grub_size_t n;\n\n\t  len = size & ~(GRUB_DISK_SECTOR_SIZE - 1);\n\t  n = size >> GRUB_DISK_SECTOR_BITS;\n\n\t  if ((buf) &&\n\t      ((disk->dev->read) (disk, sector, n, buf) != GRUB_ERR_NONE))\n\t    break;\n\n\t  if (disk->read_hook)\n\t    {\n\t      while (n)\n\t\t{\n\t\t  (disk->read_hook) (sector++, 0, GRUB_DISK_SECTOR_SIZE,\n\t\t\t\t     disk->closure);\n\t\t  n--;\n\t\t}\n\t    }\n\t  else\n\t    sector += n;\n\t}\n\n      if (buf)\n\tbuf = (char *) buf + len;\n      size -= len;\n    }\n\n  return grub_errno;\n}\n\ngrub_err_t\ngrub_disk_write (grub_disk_t disk, grub_disk_addr_t sector,\n\t\t grub_off_t offset, grub_size_t size, const void *buf)\n{\n  unsigned real_offset;\n\n  grub_dprintf (\"disk\", \"Writing `%s'...\\n\", disk->name);\n\n  if (grub_disk_adjust_range (disk, &sector, &offset, size) != GRUB_ERR_NONE)\n    return grub_errno;\n\n  real_offset = offset;\n\n  while (size)\n    {\n      if (real_offset != 0 || (size < GRUB_DISK_SECTOR_SIZE && size != 0))\n\t{\n\t  char tmp_buf[GRUB_DISK_SECTOR_SIZE];\n\t  grub_size_t len;\n\t  grub_partition_t part;\n\n\t  part = disk->partition;\n\t  disk->partition = 0;\n\t  if (grub_disk_read (disk, sector, 0, GRUB_DISK_SECTOR_SIZE, tmp_buf)\n\t      != GRUB_ERR_NONE)\n\t    {\n\t      disk->partition = part;\n\t      goto finish;\n\t    }\n\t  disk->partition = part;\n\n\t  len = GRUB_DISK_SECTOR_SIZE - real_offset;\n\t  if (len > size)\n\t    len = size;\n\n\t  grub_memcpy (tmp_buf + real_offset, buf, len);\n\n\t  grub_disk_cache_invalidate (disk->dev->id, disk->id, sector);\n\n\t  if ((disk->dev->write) (disk, sector, 1, tmp_buf) != GRUB_ERR_NONE)\n\t    goto finish;\n\n\t  sector++;\n\t  buf = (char *) buf + len;\n\t  size -= len;\n\t  real_offset = 0;\n\t}\n      else\n\t{\n\t  grub_size_t len;\n\t  grub_size_t n;\n\n\t  len = size & ~(GRUB_DISK_SECTOR_SIZE - 1);\n\t  n = size >> GRUB_DISK_SECTOR_BITS;\n\n\t  if ((disk->dev->write) (disk, sector, n, buf) != GRUB_ERR_NONE)\n\t    goto finish;\n\n\t  while (n--)\n\t    grub_disk_cache_invalidate (disk->dev->id, disk->id, sector++);\n\n\t  buf = (char *) buf + len;\n\t  size -= len;\n\t}\n    }\n\n finish:\n\n  return grub_errno;\n}\n\ngrub_uint64_t\ngrub_disk_get_size (grub_disk_t disk)\n{\n  if (disk->partition)\n    return grub_partition_get_len (disk->partition);\n  else\n    return disk->total_sectors;\n}\n"], "filenames": ["shlr/grub/kern/disk.c"], "buggy_code_start_loc": [453], "buggy_code_end_loc": [454], "fixing_code_start_loc": [453], "fixing_code_end_loc": [461], "type": "CWE-119", "message": "The grub_memmove function in shlr/grub/kern/misc.c in radare2 1.5.0 allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, possibly related to a read overflow in the grub_disk_read_small_real function in kern/disk.c in GNU GRUB 2.02.", "other": {"cve": {"id": "CVE-2017-10929", "sourceIdentifier": "cve@mitre.org", "published": "2017-07-05T12:29:00.180", "lastModified": "2017-07-19T16:32:53.530", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The grub_memmove function in shlr/grub/kern/misc.c in radare2 1.5.0 allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, possibly related to a read overflow in the grub_disk_read_small_real function in kern/disk.c in GNU GRUB 2.02."}, {"lang": "es", "value": "La funci\u00f3n grub_memmove en el archivo shlr/grub/kern/misc.c en radare2 versi\u00f3n 1.5.0, permite a atacantes remotos causar una denegaci\u00f3n de servicio (desbordamiento de b\u00fafer en la regi\u00f3n heap de la memoria y bloqueo de aplicaci\u00f3n) o posiblemente tener otro impacto no especificado por medio de un archivo binario creado, posiblemente relacionado con un desbordamiento de lectura en la funci\u00f3n grub_disk_read_small_real en el archivo kern/disk.c en GNU GRUB versi\u00f3n 2.02."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:1.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "1F6336FC-AB50-4F45-B01E-2BC3BA758117"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/99608", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/radare/radare2/commit/c57997e76ec70862174a1b3b3aeb62a6f8570e85", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/radare/radare2/issues/7855", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/c57997e76ec70862174a1b3b3aeb62a6f8570e85"}}