{"buggy_code": ["/***\n  SPDX-License-Identifier: LGPL-2.1+\n\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n***/\n\nLIBSYSTEMD_209 {\nglobal:\n        /* sd-journal */\n        sd_journal_print;\n        sd_journal_printv;\n        sd_journal_send;\n        sd_journal_sendv;\n        sd_journal_stream_fd;\n        sd_journal_open;\n        sd_journal_close;\n        sd_journal_previous;\n        sd_journal_next;\n        sd_journal_previous_skip;\n        sd_journal_next_skip;\n        sd_journal_get_realtime_usec;\n        sd_journal_get_monotonic_usec;\n        sd_journal_get_data;\n        sd_journal_enumerate_data;\n        sd_journal_restart_data;\n        sd_journal_add_match;\n        sd_journal_flush_matches;\n        sd_journal_seek_head;\n        sd_journal_seek_tail;\n        sd_journal_seek_monotonic_usec;\n        sd_journal_seek_realtime_usec;\n        sd_journal_seek_cursor;\n        sd_journal_get_cursor;\n        sd_journal_get_fd;\n        sd_journal_process;\n        sd_journal_print_with_location;\n        sd_journal_printv_with_location;\n        sd_journal_send_with_location;\n        sd_journal_sendv_with_location;\n        sd_journal_get_cutoff_realtime_usec;\n        sd_journal_get_cutoff_monotonic_usec;\n        sd_journal_wait;\n        sd_journal_open_directory;\n        sd_journal_add_disjunction;\n        sd_journal_perror;\n        sd_journal_perror_with_location;\n        sd_journal_get_usage;\n        sd_journal_test_cursor;\n        sd_journal_query_unique;\n        sd_journal_enumerate_unique;\n        sd_journal_restart_unique;\n        sd_journal_get_catalog;\n        sd_journal_get_catalog_for_message_id;\n        sd_journal_set_data_threshold;\n        sd_journal_get_data_threshold;\n        sd_journal_reliable_fd;\n        sd_journal_get_events;\n        sd_journal_get_timeout;\n        sd_journal_add_conjunction;\n        sd_journal_open_files;\n        sd_journal_open_container;\n\n        /* sd-daemon */\n        sd_booted;\n        sd_is_fifo;\n        sd_is_mq;\n        sd_is_socket;\n        sd_is_socket_inet;\n        sd_is_socket_unix;\n        sd_is_special;\n        sd_listen_fds;\n        sd_notify;\n        sd_notifyf;\n        sd_watchdog_enabled;\n\n        /* sd-id128 */\n        sd_id128_to_string;\n        sd_id128_from_string;\n        sd_id128_randomize;\n        sd_id128_get_machine;\n        sd_id128_get_boot;\n\n        /* sd-login */\n        sd_get_seats;\n        sd_get_sessions;\n        sd_get_uids;\n        sd_login_monitor_flush;\n        sd_login_monitor_get_fd;\n        sd_login_monitor_new;\n        sd_login_monitor_unref;\n        sd_pid_get_owner_uid;\n        sd_pid_get_session;\n        sd_seat_can_multi_session;\n        sd_seat_get_active;\n        sd_seat_get_sessions;\n        sd_session_get_seat;\n        sd_session_get_uid;\n        sd_session_is_active;\n        sd_uid_get_seats;\n        sd_uid_get_sessions;\n        sd_uid_get_state;\n        sd_uid_is_on_seat;\n        sd_pid_get_unit;\n        sd_session_get_service;\n        sd_session_get_type;\n        sd_session_get_class;\n        sd_session_get_display;\n        sd_session_get_state;\n        sd_seat_can_tty;\n        sd_seat_can_graphical;\n        sd_session_get_tty;\n        sd_login_monitor_get_events;\n        sd_login_monitor_get_timeout;\n        sd_pid_get_user_unit;\n        sd_pid_get_machine_name;\n        sd_get_machine_names;\n        sd_pid_get_slice;\n        sd_session_get_vt;\n        sd_session_is_remote;\n        sd_session_get_remote_user;\n        sd_session_get_remote_host;\nlocal:\n       *;\n};\n\nLIBSYSTEMD_211 {\nglobal:\n        sd_machine_get_class;\n        sd_peer_get_session;\n        sd_peer_get_owner_uid;\n        sd_peer_get_unit;\n        sd_peer_get_user_unit;\n        sd_peer_get_machine_name;\n        sd_peer_get_slice;\n} LIBSYSTEMD_209;\n\nLIBSYSTEMD_213 {\nglobal:\n        sd_uid_get_display;\n} LIBSYSTEMD_211;\n\nLIBSYSTEMD_214 {\nglobal:\n        sd_pid_notify;\n        sd_pid_notifyf;\n} LIBSYSTEMD_213;\n\nLIBSYSTEMD_216 {\nglobal:\n        sd_machine_get_ifindices;\n} LIBSYSTEMD_214;\n\nLIBSYSTEMD_217 {\nglobal:\n        sd_session_get_desktop;\n} LIBSYSTEMD_216;\n\nLIBSYSTEMD_219 {\nglobal:\n        sd_pid_notify_with_fds;\n} LIBSYSTEMD_217;\n\nLIBSYSTEMD_220 {\nglobal:\n        sd_pid_get_user_slice;\n        sd_peer_get_user_slice;\n} LIBSYSTEMD_219;\n\nLIBSYSTEMD_221 {\nglobal:\n        /* sd-bus */\n        sd_bus_default;\n        sd_bus_default_user;\n        sd_bus_default_system;\n        sd_bus_open;\n        sd_bus_open_user;\n        sd_bus_open_system;\n        sd_bus_open_system_remote;\n        sd_bus_open_system_machine;\n        sd_bus_new;\n        sd_bus_set_address;\n        sd_bus_set_fd;\n        sd_bus_set_exec;\n        sd_bus_get_address;\n        sd_bus_set_bus_client;\n        sd_bus_is_bus_client;\n        sd_bus_set_server;\n        sd_bus_is_server;\n        sd_bus_set_anonymous;\n        sd_bus_is_anonymous;\n        sd_bus_set_trusted;\n        sd_bus_is_trusted;\n        sd_bus_set_monitor;\n        sd_bus_is_monitor;\n        sd_bus_set_description;\n        sd_bus_get_description;\n        sd_bus_negotiate_creds;\n        sd_bus_negotiate_timestamp;\n        sd_bus_negotiate_fds;\n        sd_bus_can_send;\n        sd_bus_get_creds_mask;\n        sd_bus_set_allow_interactive_authorization;\n        sd_bus_get_allow_interactive_authorization;\n        sd_bus_start;\n        sd_bus_close;\n        sd_bus_try_close;\n        sd_bus_ref;\n        sd_bus_unref;\n        sd_bus_is_open;\n        sd_bus_get_bus_id;\n        sd_bus_get_scope;\n        sd_bus_get_tid;\n        sd_bus_get_owner_creds;\n        sd_bus_send;\n        sd_bus_send_to;\n        sd_bus_call;\n        sd_bus_call_async;\n        sd_bus_get_fd;\n        sd_bus_get_events;\n        sd_bus_get_timeout;\n        sd_bus_process;\n        sd_bus_process_priority;\n        sd_bus_wait;\n        sd_bus_flush;\n        sd_bus_get_current_slot;\n        sd_bus_get_current_message;\n        sd_bus_get_current_handler;\n        sd_bus_get_current_userdata;\n        sd_bus_attach_event;\n        sd_bus_detach_event;\n        sd_bus_get_event;\n        sd_bus_add_filter;\n        sd_bus_add_match;\n        sd_bus_add_object;\n        sd_bus_add_fallback;\n        sd_bus_add_object_vtable;\n        sd_bus_add_fallback_vtable;\n        sd_bus_add_node_enumerator;\n        sd_bus_add_object_manager;\n        sd_bus_slot_ref;\n        sd_bus_slot_unref;\n        sd_bus_slot_get_bus;\n        sd_bus_slot_get_userdata;\n        sd_bus_slot_set_userdata;\n        sd_bus_slot_get_description;\n        sd_bus_slot_set_description;\n        sd_bus_slot_get_current_message;\n        sd_bus_slot_get_current_handler;\n        sd_bus_slot_get_current_userdata;\n        sd_bus_message_new_signal;\n        sd_bus_message_new_method_call;\n        sd_bus_message_new_method_return;\n        sd_bus_message_new_method_error;\n        sd_bus_message_new_method_errorf;\n        sd_bus_message_new_method_errno;\n        sd_bus_message_new_method_errnof;\n        sd_bus_message_ref;\n        sd_bus_message_unref;\n        sd_bus_message_get_type;\n        sd_bus_message_get_cookie;\n        sd_bus_message_get_reply_cookie;\n        sd_bus_message_get_priority;\n        sd_bus_message_get_expect_reply;\n        sd_bus_message_get_auto_start;\n        sd_bus_message_get_allow_interactive_authorization;\n        sd_bus_message_get_signature;\n        sd_bus_message_get_path;\n        sd_bus_message_get_interface;\n        sd_bus_message_get_member;\n        sd_bus_message_get_destination;\n        sd_bus_message_get_sender;\n        sd_bus_message_get_error;\n        sd_bus_message_get_errno;\n        sd_bus_message_get_monotonic_usec;\n        sd_bus_message_get_realtime_usec;\n        sd_bus_message_get_seqnum;\n        sd_bus_message_get_bus;\n        sd_bus_message_get_creds;\n        sd_bus_message_is_signal;\n        sd_bus_message_is_method_call;\n        sd_bus_message_is_method_error;\n        sd_bus_message_is_empty;\n        sd_bus_message_has_signature;\n        sd_bus_message_set_expect_reply;\n        sd_bus_message_set_auto_start;\n        sd_bus_message_set_allow_interactive_authorization;\n        sd_bus_message_set_destination;\n        sd_bus_message_set_priority;\n        sd_bus_message_append;\n        sd_bus_message_append_basic;\n        sd_bus_message_append_array;\n        sd_bus_message_append_array_space;\n        sd_bus_message_append_array_iovec;\n        sd_bus_message_append_array_memfd;\n        sd_bus_message_append_string_space;\n        sd_bus_message_append_string_iovec;\n        sd_bus_message_append_string_memfd;\n        sd_bus_message_append_strv;\n        sd_bus_message_open_container;\n        sd_bus_message_close_container;\n        sd_bus_message_copy;\n        sd_bus_message_read;\n        sd_bus_message_read_basic;\n        sd_bus_message_read_array;\n        sd_bus_message_read_strv;\n        sd_bus_message_skip;\n        sd_bus_message_enter_container;\n        sd_bus_message_exit_container;\n        sd_bus_message_peek_type;\n        sd_bus_message_verify_type;\n        sd_bus_message_at_end;\n        sd_bus_message_rewind;\n        sd_bus_get_unique_name;\n        sd_bus_request_name;\n        sd_bus_release_name;\n        sd_bus_list_names;\n        sd_bus_get_name_creds;\n        sd_bus_get_name_machine_id;\n        sd_bus_call_method;\n        sd_bus_call_method_async;\n        sd_bus_get_property;\n        sd_bus_get_property_trivial;\n        sd_bus_get_property_string;\n        sd_bus_get_property_strv;\n        sd_bus_set_property;\n        sd_bus_reply_method_return;\n        sd_bus_reply_method_error;\n        sd_bus_reply_method_errorf;\n        sd_bus_reply_method_errno;\n        sd_bus_reply_method_errnof;\n        sd_bus_emit_signal;\n        sd_bus_emit_properties_changed_strv;\n        sd_bus_emit_properties_changed;\n        sd_bus_emit_interfaces_added_strv;\n        sd_bus_emit_interfaces_added;\n        sd_bus_emit_interfaces_removed_strv;\n        sd_bus_emit_interfaces_removed;\n        sd_bus_query_sender_creds;\n        sd_bus_query_sender_privilege;\n        sd_bus_creds_new_from_pid;\n        sd_bus_creds_ref;\n        sd_bus_creds_unref;\n        sd_bus_creds_get_mask;\n        sd_bus_creds_get_augmented_mask;\n        sd_bus_creds_get_pid;\n        sd_bus_creds_get_ppid;\n        sd_bus_creds_get_tid;\n        sd_bus_creds_get_uid;\n        sd_bus_creds_get_euid;\n        sd_bus_creds_get_suid;\n        sd_bus_creds_get_fsuid;\n        sd_bus_creds_get_gid;\n        sd_bus_creds_get_egid;\n        sd_bus_creds_get_sgid;\n        sd_bus_creds_get_fsgid;\n        sd_bus_creds_get_supplementary_gids;\n        sd_bus_creds_get_comm;\n        sd_bus_creds_get_tid_comm;\n        sd_bus_creds_get_exe;\n        sd_bus_creds_get_cmdline;\n        sd_bus_creds_get_cgroup;\n        sd_bus_creds_get_unit;\n        sd_bus_creds_get_slice;\n        sd_bus_creds_get_user_unit;\n        sd_bus_creds_get_user_slice;\n        sd_bus_creds_get_session;\n        sd_bus_creds_get_owner_uid;\n        sd_bus_creds_has_effective_cap;\n        sd_bus_creds_has_permitted_cap;\n        sd_bus_creds_has_inheritable_cap;\n        sd_bus_creds_has_bounding_cap;\n        sd_bus_creds_get_selinux_context;\n        sd_bus_creds_get_audit_session_id;\n        sd_bus_creds_get_audit_login_uid;\n        sd_bus_creds_get_tty;\n        sd_bus_creds_get_unique_name;\n        sd_bus_creds_get_well_known_names;\n        sd_bus_creds_get_description;\n        sd_bus_error_free;\n        sd_bus_error_set;\n        sd_bus_error_setf;\n        sd_bus_error_set_const;\n        sd_bus_error_set_errno;\n        sd_bus_error_set_errnof;\n        sd_bus_error_set_errnofv;\n        sd_bus_error_get_errno;\n        sd_bus_error_copy;\n        sd_bus_error_is_set;\n        sd_bus_error_has_name;\n        sd_bus_error_add_map;\n        sd_bus_path_encode;\n        sd_bus_path_decode;\n        sd_bus_track_new;\n        sd_bus_track_ref;\n        sd_bus_track_unref;\n        sd_bus_track_get_bus;\n        sd_bus_track_get_userdata;\n        sd_bus_track_set_userdata;\n        sd_bus_track_add_sender;\n        sd_bus_track_remove_sender;\n        sd_bus_track_add_name;\n        sd_bus_track_remove_name;\n        sd_bus_track_count;\n        sd_bus_track_contains;\n        sd_bus_track_first;\n        sd_bus_track_next;\n\n        /* sd-event */\n        sd_event_default;\n        sd_event_new;\n        sd_event_ref;\n        sd_event_unref;\n        sd_event_add_io;\n        sd_event_add_time;\n        sd_event_add_signal;\n        sd_event_add_child;\n        sd_event_add_defer;\n        sd_event_add_post;\n        sd_event_add_exit;\n        sd_event_prepare;\n        sd_event_wait;\n        sd_event_dispatch;\n        sd_event_run;\n        sd_event_loop;\n        sd_event_exit;\n        sd_event_now;\n        sd_event_get_fd;\n        sd_event_get_state;\n        sd_event_get_tid;\n        sd_event_get_exit_code;\n        sd_event_set_watchdog;\n        sd_event_get_watchdog;\n        sd_event_source_ref;\n        sd_event_source_unref;\n        sd_event_source_get_event;\n        sd_event_source_get_userdata;\n        sd_event_source_set_userdata;\n        sd_event_source_set_description;\n        sd_event_source_get_description;\n        sd_event_source_set_prepare;\n        sd_event_source_get_pending;\n        sd_event_source_get_priority;\n        sd_event_source_set_priority;\n        sd_event_source_get_enabled;\n        sd_event_source_set_enabled;\n        sd_event_source_get_io_fd;\n        sd_event_source_set_io_fd;\n        sd_event_source_get_io_events;\n        sd_event_source_set_io_events;\n        sd_event_source_get_io_revents;\n        sd_event_source_get_time;\n        sd_event_source_set_time;\n        sd_event_source_set_time_accuracy;\n        sd_event_source_get_time_accuracy;\n        sd_event_source_get_time_clock;\n        sd_event_source_get_signal;\n        sd_event_source_get_child_pid;\n} LIBSYSTEMD_220;\n\nLIBSYSTEMD_222 {\nglobal:\n        /* sd-bus */\n        sd_bus_emit_object_added;\n        sd_bus_emit_object_removed;\n        sd_bus_flush_close_unref;\n} LIBSYSTEMD_221;\n\nLIBSYSTEMD_226 {\nglobal:\n        sd_pid_get_cgroup;\n        sd_peer_get_cgroup;\n} LIBSYSTEMD_222;\n\nLIBSYSTEMD_227 {\nglobal:\n        sd_bus_default_flush_close;\n        sd_bus_path_decode_many;\n        sd_bus_path_encode_many;\n        sd_listen_fds_with_names;\n} LIBSYSTEMD_226;\n\nLIBSYSTEMD_229 {\nglobal:\n        sd_journal_has_runtime_files;\n        sd_journal_has_persistent_files;\n        sd_journal_enumerate_fields;\n        sd_journal_restart_fields;\n} LIBSYSTEMD_227;\n\nLIBSYSTEMD_230 {\nglobal:\n        sd_journal_open_directory_fd;\n        sd_journal_open_files_fd;\n} LIBSYSTEMD_229;\n\nLIBSYSTEMD_231 {\nglobal:\n        sd_event_get_iteration;\n} LIBSYSTEMD_230;\n\nLIBSYSTEMD_232 {\nglobal:\n        sd_bus_track_set_recursive;\n        sd_bus_track_get_recursive;\n        sd_bus_track_count_name;\n        sd_bus_track_count_sender;\n        sd_bus_set_exit_on_disconnect;\n        sd_bus_get_exit_on_disconnect;\n        sd_id128_get_invocation;\n} LIBSYSTEMD_231;\n\nLIBSYSTEMD_233 {\nglobal:\n        sd_id128_get_machine_app_specific;\n        sd_is_socket_sockaddr;\n} LIBSYSTEMD_232;\n\nLIBSYSTEMD_234 {\nglobal:\n        sd_bus_message_appendv;\n} LIBSYSTEMD_233;\n\nLIBSYSTEMD_236 {\nglobal:\n        sd_bus_message_new;\n        sd_bus_message_seal;\n} LIBSYSTEMD_234;\n\nLIBSYSTEMD_237 {\nglobal:\n        sd_bus_set_watch_bind;\n        sd_bus_get_watch_bind;\n        sd_bus_request_name_async;\n        sd_bus_release_name_async;\n        sd_bus_add_match_async;\n        sd_bus_match_signal;\n        sd_bus_match_signal_async;\n        sd_bus_is_ready;\n        sd_bus_set_connected_signal;\n        sd_bus_get_connected_signal;\n        sd_bus_set_sender;\n        sd_bus_get_sender;\n        sd_bus_message_set_sender;\n        sd_event_source_get_io_fd_own;\n        sd_event_source_set_io_fd_own;\n} LIBSYSTEMD_236;\n\nLIBSYSTEMD_238 {\nglobal:\n        sd_bus_get_n_queued_read;\n        sd_bus_get_n_queued_write;\n} LIBSYSTEMD_237;\n\nLIBSYSTEMD_239 {\nglobal:\n        sd_bus_open_with_description;\n        sd_bus_open_user_with_description;\n        sd_bus_open_system_with_description;\n        sd_bus_slot_get_floating;\n        sd_bus_slot_set_floating;\n        sd_bus_slot_get_destroy_callback;\n        sd_bus_slot_set_destroy_callback;\n        sd_bus_track_get_destroy_callback;\n        sd_bus_track_set_destroy_callback;\n        sd_event_add_inotify;\n        sd_event_source_get_inotify_mask;\n        sd_event_source_set_destroy_callback;\n        sd_event_source_get_destroy_callback;\n} LIBSYSTEMD_238;\n\nLIBSYSTEMD_240 {\nglobal:\n        sd_bus_message_readv;\n        sd_bus_set_method_call_timeout;\n        sd_bus_get_method_call_timeout;\n\n        sd_bus_error_move;\n\n        sd_bus_set_close_on_exit;\n        sd_bus_get_close_on_exit;\n\n        sd_device_ref;\n        sd_device_unref;\n\n        sd_device_new_from_syspath;\n        sd_device_new_from_devnum;\n        sd_device_new_from_subsystem_sysname;\n        sd_device_new_from_device_id;\n\n        sd_device_get_parent;\n        sd_device_get_parent_with_subsystem_devtype;\n\n        sd_device_get_syspath;\n        sd_device_get_subsystem;\n        sd_device_get_devtype;\n        sd_device_get_devnum;\n        sd_device_get_ifindex;\n        sd_device_get_driver;\n        sd_device_get_devpath;\n        sd_device_get_devname;\n        sd_device_get_sysname;\n        sd_device_get_sysnum;\n\n        sd_device_get_is_initialized;\n        sd_device_get_usec_since_initialized;\n\n        sd_device_get_tag_first;\n        sd_device_get_tag_next;\n        sd_device_get_devlink_first;\n        sd_device_get_devlink_next;\n        sd_device_get_property_first;\n        sd_device_get_property_next;\n        sd_device_get_sysattr_first;\n        sd_device_get_sysattr_next;\n\n        sd_device_has_tag;\n        sd_device_get_property_value;\n        sd_device_get_sysattr_value;\n\n        sd_device_set_sysattr_value;\n\n        sd_device_enumerator_new;\n        sd_device_enumerator_ref;\n        sd_device_enumerator_unref;\n\n        sd_device_enumerator_get_device_first;\n        sd_device_enumerator_get_device_next;\n        sd_device_enumerator_get_subsystem_first;\n        sd_device_enumerator_get_subsystem_next;\n\n        sd_device_enumerator_add_match_subsystem;\n        sd_device_enumerator_add_match_sysattr;\n        sd_device_enumerator_add_match_property;\n        sd_device_enumerator_add_match_sysname;\n        sd_device_enumerator_add_match_tag;\n        sd_device_enumerator_add_match_parent;\n        sd_device_enumerator_allow_uninitialized;\n\n        sd_hwdb_ref;\n        sd_hwdb_unref;\n\n        sd_hwdb_new;\n\n        sd_hwdb_get;\n\n        sd_hwdb_seek;\n        sd_hwdb_enumerate;\n\n        sd_id128_get_boot_app_specific;\n\n        sd_device_monitor_new;\n        sd_device_monitor_ref;\n        sd_device_monitor_unref;\n\n        sd_device_monitor_set_receive_buffer_size;\n        sd_device_monitor_attach_event;\n        sd_device_monitor_detach_event;\n        sd_device_monitor_get_event;\n        sd_device_monitor_get_event_source;\n        sd_device_monitor_start;\n        sd_device_monitor_stop;\n\n        sd_device_monitor_filter_add_match_subsystem_devtype;\n        sd_device_monitor_filter_add_match_tag;\n        sd_device_monitor_filter_update;\n        sd_device_monitor_filter_remove;\n\n        sd_event_source_get_floating;\n        sd_event_source_set_floating;\n} LIBSYSTEMD_239;\n\nLIBSYSTEMD_241 {\nglobal:\n        sd_bus_close_unref;\n} LIBSYSTEMD_240;\n\nLIBSYSTEMD_243 {\nglobal:\n        sd_bus_object_vtable_format;\n        sd_event_source_disable_unref;\n} LIBSYSTEMD_241;\n\nLIBSYSTEMD_245 {\nglobal:\n        sd_bus_message_dump;\n        sd_bus_message_sensitive;\n        sd_event_add_child_pidfd;\n        sd_event_source_get_child_pidfd;\n        sd_event_source_get_child_pidfd_own;\n        sd_event_source_set_child_pidfd_own;\n        sd_event_source_get_child_process_own;\n        sd_event_source_set_child_process_own;\n        sd_event_source_send_child_signal;\n        sd_journal_open_namespace;\n} LIBSYSTEMD_243;\n", "/* SPDX-License-Identifier: LGPL-2.1+ */\n\n#include <endian.h>\n#include <netdb.h>\n#include <poll.h>\n#include <pthread.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include \"sd-bus.h\"\n\n#include \"alloc-util.h\"\n#include \"bus-container.h\"\n#include \"bus-control.h\"\n#include \"bus-internal.h\"\n#include \"bus-kernel.h\"\n#include \"bus-label.h\"\n#include \"bus-message.h\"\n#include \"bus-objects.h\"\n#include \"bus-protocol.h\"\n#include \"bus-slot.h\"\n#include \"bus-socket.h\"\n#include \"bus-track.h\"\n#include \"bus-type.h\"\n#include \"bus-util.h\"\n#include \"cgroup-util.h\"\n#include \"def.h\"\n#include \"errno-util.h\"\n#include \"fd-util.h\"\n#include \"hexdecoct.h\"\n#include \"hostname-util.h\"\n#include \"macro.h\"\n#include \"memory-util.h\"\n#include \"missing_syscall.h\"\n#include \"parse-util.h\"\n#include \"path-util.h\"\n#include \"process-util.h\"\n#include \"string-util.h\"\n#include \"strv.h\"\n\n#define log_debug_bus_message(m)                                         \\\n        do {                                                             \\\n                sd_bus_message *_mm = (m);                               \\\n                log_debug(\"Got message type=%s sender=%s destination=%s path=%s interface=%s member=%s cookie=%\" PRIu64 \" reply_cookie=%\" PRIu64 \" signature=%s error-name=%s error-message=%s\", \\\n                          bus_message_type_to_string(_mm->header->type), \\\n                          strna(sd_bus_message_get_sender(_mm)),         \\\n                          strna(sd_bus_message_get_destination(_mm)),    \\\n                          strna(sd_bus_message_get_path(_mm)),           \\\n                          strna(sd_bus_message_get_interface(_mm)),      \\\n                          strna(sd_bus_message_get_member(_mm)),         \\\n                          BUS_MESSAGE_COOKIE(_mm),                       \\\n                          _mm->reply_cookie,                             \\\n                          strna(_mm->root_container.signature),          \\\n                          strna(_mm->error.name),                        \\\n                          strna(_mm->error.message));                    \\\n        } while (false)\n\nstatic int bus_poll(sd_bus *bus, bool need_more, uint64_t timeout_usec);\nstatic void bus_detach_io_events(sd_bus *b);\nstatic void bus_detach_inotify_event(sd_bus *b);\n\nstatic thread_local sd_bus *default_system_bus = NULL;\nstatic thread_local sd_bus *default_user_bus = NULL;\nstatic thread_local sd_bus *default_starter_bus = NULL;\n\nstatic sd_bus **bus_choose_default(int (**bus_open)(sd_bus **)) {\n        const char *e;\n\n        /* Let's try our best to reuse another cached connection. If\n         * the starter bus type is set, connect via our normal\n         * connection logic, ignoring $DBUS_STARTER_ADDRESS, so that\n         * we can share the connection with the user/system default\n         * bus. */\n\n        e = secure_getenv(\"DBUS_STARTER_BUS_TYPE\");\n        if (e) {\n                if (streq(e, \"system\")) {\n                        if (bus_open)\n                                *bus_open = sd_bus_open_system;\n                        return &default_system_bus;\n                } else if (STR_IN_SET(e, \"user\", \"session\")) {\n                        if (bus_open)\n                                *bus_open = sd_bus_open_user;\n                        return &default_user_bus;\n                }\n        }\n\n        /* No type is specified, so we have not other option than to\n         * use the starter address if it is set. */\n        e = secure_getenv(\"DBUS_STARTER_ADDRESS\");\n        if (e) {\n                if (bus_open)\n                        *bus_open = sd_bus_open;\n                return &default_starter_bus;\n        }\n\n        /* Finally, if nothing is set use the cached connection for\n         * the right scope */\n\n        if (cg_pid_get_owner_uid(0, NULL) >= 0) {\n                if (bus_open)\n                        *bus_open = sd_bus_open_user;\n                return &default_user_bus;\n        } else {\n                if (bus_open)\n                        *bus_open = sd_bus_open_system;\n                return &default_system_bus;\n        }\n}\n\nsd_bus *bus_resolve(sd_bus *bus) {\n        switch ((uintptr_t) bus) {\n        case (uintptr_t) SD_BUS_DEFAULT:\n                return *(bus_choose_default(NULL));\n        case (uintptr_t) SD_BUS_DEFAULT_USER:\n                return default_user_bus;\n        case (uintptr_t) SD_BUS_DEFAULT_SYSTEM:\n                return default_system_bus;\n        default:\n                return bus;\n        }\n}\n\nvoid bus_close_io_fds(sd_bus *b) {\n        assert(b);\n\n        bus_detach_io_events(b);\n\n        if (b->input_fd != b->output_fd)\n                safe_close(b->output_fd);\n        b->output_fd = b->input_fd = safe_close(b->input_fd);\n}\n\nvoid bus_close_inotify_fd(sd_bus *b) {\n        assert(b);\n\n        bus_detach_inotify_event(b);\n\n        b->inotify_fd = safe_close(b->inotify_fd);\n        b->inotify_watches = mfree(b->inotify_watches);\n        b->n_inotify_watches = 0;\n}\n\nstatic void bus_reset_queues(sd_bus *b) {\n        assert(b);\n\n        while (b->rqueue_size > 0)\n                bus_message_unref_queued(b->rqueue[--b->rqueue_size], b);\n\n        b->rqueue = mfree(b->rqueue);\n        b->rqueue_allocated = 0;\n\n        while (b->wqueue_size > 0)\n                bus_message_unref_queued(b->wqueue[--b->wqueue_size], b);\n\n        b->wqueue = mfree(b->wqueue);\n        b->wqueue_allocated = 0;\n}\n\nstatic sd_bus* bus_free(sd_bus *b) {\n        sd_bus_slot *s;\n\n        assert(b);\n        assert(!b->track_queue);\n        assert(!b->tracks);\n\n        b->state = BUS_CLOSED;\n\n        sd_bus_detach_event(b);\n\n        while ((s = b->slots)) {\n                /* At this point only floating slots can still be\n                 * around, because the non-floating ones keep a\n                 * reference to the bus, and we thus couldn't be\n                 * destructing right now... We forcibly disconnect the\n                 * slots here, so that they still can be referenced by\n                 * apps, but are dead. */\n\n                assert(s->floating);\n                bus_slot_disconnect(s, true);\n        }\n\n        if (b->default_bus_ptr)\n                *b->default_bus_ptr = NULL;\n\n        bus_close_io_fds(b);\n        bus_close_inotify_fd(b);\n\n        free(b->label);\n        free(b->groups);\n        free(b->rbuffer);\n        free(b->unique_name);\n        free(b->auth_buffer);\n        free(b->address);\n        free(b->machine);\n        free(b->description);\n        free(b->patch_sender);\n\n        free(b->exec_path);\n        strv_free(b->exec_argv);\n\n        close_many(b->fds, b->n_fds);\n        free(b->fds);\n\n        bus_reset_queues(b);\n\n        ordered_hashmap_free_free(b->reply_callbacks);\n        prioq_free(b->reply_callbacks_prioq);\n\n        assert(b->match_callbacks.type == BUS_MATCH_ROOT);\n        bus_match_free(&b->match_callbacks);\n\n        hashmap_free_free(b->vtable_methods);\n        hashmap_free_free(b->vtable_properties);\n\n        assert(hashmap_isempty(b->nodes));\n        hashmap_free(b->nodes);\n\n        bus_flush_memfd(b);\n\n        assert_se(pthread_mutex_destroy(&b->memfd_cache_mutex) == 0);\n\n        return mfree(b);\n}\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(sd_bus*, bus_free);\n\n_public_ int sd_bus_new(sd_bus **ret) {\n        _cleanup_free_ sd_bus *b = NULL;\n\n        assert_return(ret, -EINVAL);\n\n        b = new(sd_bus, 1);\n        if (!b)\n                return -ENOMEM;\n\n        *b = (sd_bus) {\n                .n_ref = 1,\n                .input_fd = -1,\n                .output_fd = -1,\n                .inotify_fd = -1,\n                .message_version = 1,\n                .creds_mask = SD_BUS_CREDS_WELL_KNOWN_NAMES|SD_BUS_CREDS_UNIQUE_NAME,\n                .accept_fd = true,\n                .original_pid = getpid_cached(),\n                .n_groups = (size_t) -1,\n                .close_on_exit = true,\n        };\n\n        /* We guarantee that wqueue always has space for at least one entry */\n        if (!GREEDY_REALLOC(b->wqueue, b->wqueue_allocated, 1))\n                return -ENOMEM;\n\n        assert_se(pthread_mutex_init(&b->memfd_cache_mutex, NULL) == 0);\n\n        *ret = TAKE_PTR(b);\n        return 0;\n}\n\n_public_ int sd_bus_set_address(sd_bus *bus, const char *address) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(address, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return free_and_strdup(&bus->address, address);\n}\n\n_public_ int sd_bus_set_fd(sd_bus *bus, int input_fd, int output_fd) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(input_fd >= 0, -EBADF);\n        assert_return(output_fd >= 0, -EBADF);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus->input_fd = input_fd;\n        bus->output_fd = output_fd;\n        return 0;\n}\n\n_public_ int sd_bus_set_exec(sd_bus *bus, const char *path, char *const argv[]) {\n        _cleanup_strv_free_ char **a = NULL;\n        int r;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(path, -EINVAL);\n        assert_return(!strv_isempty(argv), -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        a = strv_copy(argv);\n        if (!a)\n                return -ENOMEM;\n\n        r = free_and_strdup(&bus->exec_path, path);\n        if (r < 0)\n                return r;\n\n        return strv_free_and_replace(bus->exec_argv, a);\n}\n\n_public_ int sd_bus_set_bus_client(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(!bus->patch_sender, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus->bus_client = !!b;\n        return 0;\n}\n\n_public_ int sd_bus_set_monitor(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus->is_monitor = !!b;\n        return 0;\n}\n\n_public_ int sd_bus_negotiate_fds(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus->accept_fd = !!b;\n        return 0;\n}\n\n_public_ int sd_bus_negotiate_timestamp(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!IN_SET(bus->state, BUS_CLOSING, BUS_CLOSED), -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        /* This is not actually supported by any of our transports these days, but we do honour it for synthetic\n         * replies, and maybe one day classic D-Bus learns this too */\n        bus->attach_timestamp = !!b;\n\n        return 0;\n}\n\n_public_ int sd_bus_negotiate_creds(sd_bus *bus, int b, uint64_t mask) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(mask <= _SD_BUS_CREDS_ALL, -EINVAL);\n        assert_return(!IN_SET(bus->state, BUS_CLOSING, BUS_CLOSED), -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        SET_FLAG(bus->creds_mask, mask, b);\n\n        /* The well knowns we need unconditionally, so that matches can work */\n        bus->creds_mask |= SD_BUS_CREDS_WELL_KNOWN_NAMES|SD_BUS_CREDS_UNIQUE_NAME;\n\n        return 0;\n}\n\n_public_ int sd_bus_set_server(sd_bus *bus, int b, sd_id128_t server_id) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(b || sd_id128_equal(server_id, SD_ID128_NULL), -EINVAL);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus->is_server = !!b;\n        bus->server_id = server_id;\n        return 0;\n}\n\n_public_ int sd_bus_set_anonymous(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus->anonymous_auth = !!b;\n        return 0;\n}\n\n_public_ int sd_bus_set_trusted(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus->trusted = !!b;\n        return 0;\n}\n\n_public_ int sd_bus_set_description(sd_bus *bus, const char *description) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return free_and_strdup(&bus->description, description);\n}\n\n_public_ int sd_bus_set_allow_interactive_authorization(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus->allow_interactive_authorization = !!b;\n        return 0;\n}\n\n_public_ int sd_bus_get_allow_interactive_authorization(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return bus->allow_interactive_authorization;\n}\n\n_public_ int sd_bus_set_watch_bind(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus->watch_bind = !!b;\n        return 0;\n}\n\n_public_ int sd_bus_get_watch_bind(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return bus->watch_bind;\n}\n\n_public_ int sd_bus_set_connected_signal(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus->connected_signal = !!b;\n        return 0;\n}\n\n_public_ int sd_bus_get_connected_signal(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return bus->connected_signal;\n}\n\nstatic int synthesize_connected_signal(sd_bus *bus) {\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = NULL;\n        int r;\n\n        assert(bus);\n\n        /* If enabled, synthesizes a local \"Connected\" signal mirroring the local \"Disconnected\" signal. This is called\n         * whenever we fully established a connection, i.e. after the authorization phase, and after receiving the\n         * Hello() reply. Or in other words, whenever we enter BUS_RUNNING state.\n         *\n         * This is useful so that clients can start doing stuff whenever the connection is fully established in a way\n         * that works independently from whether we connected to a full bus or just a direct connection. */\n\n        if (!bus->connected_signal)\n                return 0;\n\n        r = sd_bus_message_new_signal(\n                        bus,\n                        &m,\n                        \"/org/freedesktop/DBus/Local\",\n                        \"org.freedesktop.DBus.Local\",\n                        \"Connected\");\n        if (r < 0)\n                return r;\n\n        bus_message_set_sender_local(bus, m);\n        m->read_counter = ++bus->read_counter;\n\n        r = bus_seal_synthetic_message(bus, m);\n        if (r < 0)\n                return r;\n\n        r = bus_rqueue_make_room(bus);\n        if (r < 0)\n                return r;\n\n        /* Insert at the very front */\n        memmove(bus->rqueue + 1, bus->rqueue, sizeof(sd_bus_message*) * bus->rqueue_size);\n        bus->rqueue[0] = bus_message_ref_queued(m, bus);\n        bus->rqueue_size++;\n\n        return 0;\n}\n\nvoid bus_set_state(sd_bus *bus, enum bus_state state) {\n\n        static const char * const table[_BUS_STATE_MAX] = {\n                [BUS_UNSET] = \"UNSET\",\n                [BUS_WATCH_BIND] = \"WATCH_BIND\",\n                [BUS_OPENING] = \"OPENING\",\n                [BUS_AUTHENTICATING] = \"AUTHENTICATING\",\n                [BUS_HELLO] = \"HELLO\",\n                [BUS_RUNNING] = \"RUNNING\",\n                [BUS_CLOSING] = \"CLOSING\",\n                [BUS_CLOSED] = \"CLOSED\",\n        };\n\n        assert(bus);\n        assert(state < _BUS_STATE_MAX);\n\n        if (state == bus->state)\n                return;\n\n        log_debug(\"Bus %s: changing state %s \u2192 %s\", strna(bus->description), table[bus->state], table[state]);\n        bus->state = state;\n}\n\nstatic int hello_callback(sd_bus_message *reply, void *userdata, sd_bus_error *error) {\n        const char *s;\n        sd_bus *bus;\n        int r;\n\n        assert(reply);\n        bus = reply->bus;\n        assert(bus);\n        assert(IN_SET(bus->state, BUS_HELLO, BUS_CLOSING));\n\n        r = sd_bus_message_get_errno(reply);\n        if (r > 0) {\n                r = -r;\n                goto fail;\n        }\n\n        r = sd_bus_message_read(reply, \"s\", &s);\n        if (r < 0)\n                goto fail;\n\n        if (!service_name_is_valid(s) || s[0] != ':') {\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        r = free_and_strdup(&bus->unique_name, s);\n        if (r < 0)\n                goto fail;\n\n        if (bus->state == BUS_HELLO) {\n                bus_set_state(bus, BUS_RUNNING);\n\n                r = synthesize_connected_signal(bus);\n                if (r < 0)\n                        goto fail;\n        }\n\n        return 1;\n\nfail:\n        /* When Hello() failed, let's propagate this in two ways: first we return the error immediately here,\n         * which is the propagated up towards the event loop. Let's also invalidate the connection, so that\n         * if the user then calls back into us again we won't wait any longer. */\n\n        bus_set_state(bus, BUS_CLOSING);\n        return r;\n}\n\nstatic int bus_send_hello(sd_bus *bus) {\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = NULL;\n        int r;\n\n        assert(bus);\n\n        if (!bus->bus_client)\n                return 0;\n\n        r = sd_bus_message_new_method_call(\n                        bus,\n                        &m,\n                        \"org.freedesktop.DBus\",\n                        \"/org/freedesktop/DBus\",\n                        \"org.freedesktop.DBus\",\n                        \"Hello\");\n        if (r < 0)\n                return r;\n\n        return sd_bus_call_async(bus, NULL, m, hello_callback, NULL, 0);\n}\n\nint bus_start_running(sd_bus *bus) {\n        struct reply_callback *c;\n        Iterator i;\n        usec_t n;\n        int r;\n\n        assert(bus);\n        assert(bus->state < BUS_HELLO);\n\n        /* We start all method call timeouts when we enter BUS_HELLO or BUS_RUNNING mode. At this point let's convert\n         * all relative to absolute timestamps. Note that we do not reshuffle the reply callback priority queue since\n         * adding a fixed value to all entries should not alter the internal order. */\n\n        n = now(CLOCK_MONOTONIC);\n        ORDERED_HASHMAP_FOREACH(c, bus->reply_callbacks, i) {\n                if (c->timeout_usec == 0)\n                        continue;\n\n                c->timeout_usec = usec_add(n, c->timeout_usec);\n        }\n\n        if (bus->bus_client) {\n                bus_set_state(bus, BUS_HELLO);\n                return 1;\n        }\n\n        bus_set_state(bus, BUS_RUNNING);\n\n        r = synthesize_connected_signal(bus);\n        if (r < 0)\n                return r;\n\n        return 1;\n}\n\nstatic int parse_address_key(const char **p, const char *key, char **value) {\n        size_t l, n = 0, allocated = 0;\n        _cleanup_free_ char *r = NULL;\n        const char *a;\n\n        assert(p);\n        assert(*p);\n        assert(value);\n\n        if (key) {\n                l = strlen(key);\n                if (strncmp(*p, key, l) != 0)\n                        return 0;\n\n                if ((*p)[l] != '=')\n                        return 0;\n\n                if (*value)\n                        return -EINVAL;\n\n                a = *p + l + 1;\n        } else\n                a = *p;\n\n        while (!IN_SET(*a, ';', ',', 0)) {\n                char c;\n\n                if (*a == '%') {\n                        int x, y;\n\n                        x = unhexchar(a[1]);\n                        if (x < 0)\n                                return x;\n\n                        y = unhexchar(a[2]);\n                        if (y < 0)\n                                return y;\n\n                        c = (char) ((x << 4) | y);\n                        a += 3;\n                } else {\n                        c = *a;\n                        a++;\n                }\n\n                if (!GREEDY_REALLOC(r, allocated, n + 2))\n                        return -ENOMEM;\n\n                r[n++] = c;\n        }\n\n        if (!r) {\n                r = strdup(\"\");\n                if (!r)\n                        return -ENOMEM;\n        } else\n                r[n] = 0;\n\n        if (*a == ',')\n                a++;\n\n        *p = a;\n\n        free_and_replace(*value, r);\n\n        return 1;\n}\n\nstatic void skip_address_key(const char **p) {\n        assert(p);\n        assert(*p);\n\n        *p += strcspn(*p, \",\");\n\n        if (**p == ',')\n                (*p)++;\n}\n\nstatic int parse_unix_address(sd_bus *b, const char **p, char **guid) {\n        _cleanup_free_ char *path = NULL, *abstract = NULL;\n        size_t l;\n        int r;\n\n        assert(b);\n        assert(p);\n        assert(*p);\n        assert(guid);\n\n        while (!IN_SET(**p, 0, ';')) {\n                r = parse_address_key(p, \"guid\", guid);\n                if (r < 0)\n                        return r;\n                else if (r > 0)\n                        continue;\n\n                r = parse_address_key(p, \"path\", &path);\n                if (r < 0)\n                        return r;\n                else if (r > 0)\n                        continue;\n\n                r = parse_address_key(p, \"abstract\", &abstract);\n                if (r < 0)\n                        return r;\n                else if (r > 0)\n                        continue;\n\n                skip_address_key(p);\n        }\n\n        if (!path && !abstract)\n                return -EINVAL;\n\n        if (path && abstract)\n                return -EINVAL;\n\n        if (path) {\n                l = strlen(path);\n                if (l >= sizeof(b->sockaddr.un.sun_path)) /* We insist on NUL termination */\n                        return -E2BIG;\n\n                b->sockaddr.un = (struct sockaddr_un) {\n                        .sun_family = AF_UNIX,\n                };\n\n                memcpy(b->sockaddr.un.sun_path, path, l);\n                b->sockaddr_size = offsetof(struct sockaddr_un, sun_path) + l + 1;\n\n        } else {\n                assert(abstract);\n\n                l = strlen(abstract);\n                if (l >= sizeof(b->sockaddr.un.sun_path) - 1) /* We insist on NUL termination */\n                        return -E2BIG;\n\n                b->sockaddr.un = (struct sockaddr_un) {\n                        .sun_family = AF_UNIX,\n                };\n\n                memcpy(b->sockaddr.un.sun_path+1, abstract, l);\n                b->sockaddr_size = offsetof(struct sockaddr_un, sun_path) + 1 + l;\n        }\n\n        b->is_local = true;\n\n        return 0;\n}\n\nstatic int parse_tcp_address(sd_bus *b, const char **p, char **guid) {\n        _cleanup_free_ char *host = NULL, *port = NULL, *family = NULL;\n        int r;\n        struct addrinfo *result, hints = {\n                .ai_socktype = SOCK_STREAM,\n                .ai_flags = AI_ADDRCONFIG,\n        };\n\n        assert(b);\n        assert(p);\n        assert(*p);\n        assert(guid);\n\n        while (!IN_SET(**p, 0, ';')) {\n                r = parse_address_key(p, \"guid\", guid);\n                if (r < 0)\n                        return r;\n                else if (r > 0)\n                        continue;\n\n                r = parse_address_key(p, \"host\", &host);\n                if (r < 0)\n                        return r;\n                else if (r > 0)\n                        continue;\n\n                r = parse_address_key(p, \"port\", &port);\n                if (r < 0)\n                        return r;\n                else if (r > 0)\n                        continue;\n\n                r = parse_address_key(p, \"family\", &family);\n                if (r < 0)\n                        return r;\n                else if (r > 0)\n                        continue;\n\n                skip_address_key(p);\n        }\n\n        if (!host || !port)\n                return -EINVAL;\n\n        if (family) {\n                if (streq(family, \"ipv4\"))\n                        hints.ai_family = AF_INET;\n                else if (streq(family, \"ipv6\"))\n                        hints.ai_family = AF_INET6;\n                else\n                        return -EINVAL;\n        }\n\n        r = getaddrinfo(host, port, &hints, &result);\n        if (r == EAI_SYSTEM)\n                return -errno;\n        else if (r != 0)\n                return -EADDRNOTAVAIL;\n\n        memcpy(&b->sockaddr, result->ai_addr, result->ai_addrlen);\n        b->sockaddr_size = result->ai_addrlen;\n\n        freeaddrinfo(result);\n\n        b->is_local = false;\n\n        return 0;\n}\n\nstatic int parse_exec_address(sd_bus *b, const char **p, char **guid) {\n        char *path = NULL;\n        unsigned n_argv = 0, j;\n        char **argv = NULL;\n        size_t allocated = 0;\n        int r;\n\n        assert(b);\n        assert(p);\n        assert(*p);\n        assert(guid);\n\n        while (!IN_SET(**p, 0, ';')) {\n                r = parse_address_key(p, \"guid\", guid);\n                if (r < 0)\n                        goto fail;\n                else if (r > 0)\n                        continue;\n\n                r = parse_address_key(p, \"path\", &path);\n                if (r < 0)\n                        goto fail;\n                else if (r > 0)\n                        continue;\n\n                if (startswith(*p, \"argv\")) {\n                        unsigned ul;\n\n                        errno = 0;\n                        ul = strtoul(*p + 4, (char**) p, 10);\n                        if (errno > 0 || **p != '=' || ul > 256) {\n                                r = -EINVAL;\n                                goto fail;\n                        }\n\n                        (*p)++;\n\n                        if (ul >= n_argv) {\n                                if (!GREEDY_REALLOC0(argv, allocated, ul + 2)) {\n                                        r = -ENOMEM;\n                                        goto fail;\n                                }\n\n                                n_argv = ul + 1;\n                        }\n\n                        r = parse_address_key(p, NULL, argv + ul);\n                        if (r < 0)\n                                goto fail;\n\n                        continue;\n                }\n\n                skip_address_key(p);\n        }\n\n        if (!path) {\n                r = -EINVAL;\n                goto fail;\n        }\n\n        /* Make sure there are no holes in the array, with the\n         * exception of argv[0] */\n        for (j = 1; j < n_argv; j++)\n                if (!argv[j]) {\n                        r = -EINVAL;\n                        goto fail;\n                }\n\n        if (argv && argv[0] == NULL) {\n                argv[0] = strdup(path);\n                if (!argv[0]) {\n                        r = -ENOMEM;\n                        goto fail;\n                }\n        }\n\n        b->exec_path = path;\n        b->exec_argv = argv;\n\n        b->is_local = false;\n\n        return 0;\n\nfail:\n        for (j = 0; j < n_argv; j++)\n                free(argv[j]);\n\n        free(argv);\n        free(path);\n        return r;\n}\n\nstatic int parse_container_unix_address(sd_bus *b, const char **p, char **guid) {\n        _cleanup_free_ char *machine = NULL, *pid = NULL;\n        int r;\n\n        assert(b);\n        assert(p);\n        assert(*p);\n        assert(guid);\n\n        while (!IN_SET(**p, 0, ';')) {\n                r = parse_address_key(p, \"guid\", guid);\n                if (r < 0)\n                        return r;\n                else if (r > 0)\n                        continue;\n\n                r = parse_address_key(p, \"machine\", &machine);\n                if (r < 0)\n                        return r;\n                else if (r > 0)\n                        continue;\n\n                r = parse_address_key(p, \"pid\", &pid);\n                if (r < 0)\n                        return r;\n                else if (r > 0)\n                        continue;\n\n                skip_address_key(p);\n        }\n\n        if (!machine == !pid)\n                return -EINVAL;\n\n        if (machine) {\n                if (!streq(machine, \".host\") && !machine_name_is_valid(machine))\n                        return -EINVAL;\n\n                free_and_replace(b->machine, machine);\n        } else {\n                b->machine = mfree(b->machine);\n        }\n\n        if (pid) {\n                r = parse_pid(pid, &b->nspid);\n                if (r < 0)\n                        return r;\n        } else\n                b->nspid = 0;\n\n        b->sockaddr.un = (struct sockaddr_un) {\n                .sun_family = AF_UNIX,\n                /* Note that we use the old /var/run prefix here, to increase compatibility with really old containers */\n                .sun_path = \"/var/run/dbus/system_bus_socket\",\n        };\n        b->sockaddr_size = SOCKADDR_UN_LEN(b->sockaddr.un);\n        b->is_local = false;\n\n        return 0;\n}\n\nstatic void bus_reset_parsed_address(sd_bus *b) {\n        assert(b);\n\n        zero(b->sockaddr);\n        b->sockaddr_size = 0;\n        b->exec_argv = strv_free(b->exec_argv);\n        b->exec_path = mfree(b->exec_path);\n        b->server_id = SD_ID128_NULL;\n        b->machine = mfree(b->machine);\n        b->nspid = 0;\n}\n\nstatic int bus_parse_next_address(sd_bus *b) {\n        _cleanup_free_ char *guid = NULL;\n        const char *a;\n        int r;\n\n        assert(b);\n\n        if (!b->address)\n                return 0;\n        if (b->address[b->address_index] == 0)\n                return 0;\n\n        bus_reset_parsed_address(b);\n\n        a = b->address + b->address_index;\n\n        while (*a != 0) {\n\n                if (*a == ';') {\n                        a++;\n                        continue;\n                }\n\n                if (startswith(a, \"unix:\")) {\n                        a += 5;\n\n                        r = parse_unix_address(b, &a, &guid);\n                        if (r < 0)\n                                return r;\n                        break;\n\n                } else if (startswith(a, \"tcp:\")) {\n\n                        a += 4;\n                        r = parse_tcp_address(b, &a, &guid);\n                        if (r < 0)\n                                return r;\n\n                        break;\n\n                } else if (startswith(a, \"unixexec:\")) {\n\n                        a += 9;\n                        r = parse_exec_address(b, &a, &guid);\n                        if (r < 0)\n                                return r;\n\n                        break;\n\n                } else if (startswith(a, \"x-machine-unix:\")) {\n\n                        a += 15;\n                        r = parse_container_unix_address(b, &a, &guid);\n                        if (r < 0)\n                                return r;\n\n                        break;\n                }\n\n                a = strchr(a, ';');\n                if (!a)\n                        return 0;\n        }\n\n        if (guid) {\n                r = sd_id128_from_string(guid, &b->server_id);\n                if (r < 0)\n                        return r;\n        }\n\n        b->address_index = a - b->address;\n        return 1;\n}\n\nstatic void bus_kill_exec(sd_bus *bus) {\n        if (pid_is_valid(bus->busexec_pid) > 0) {\n                sigterm_wait(bus->busexec_pid);\n                bus->busexec_pid = 0;\n        }\n}\n\nstatic int bus_start_address(sd_bus *b) {\n        int r;\n\n        assert(b);\n\n        for (;;) {\n                bus_close_io_fds(b);\n                bus_close_inotify_fd(b);\n\n                bus_kill_exec(b);\n\n                /* If you provide multiple different bus-addresses, we\n                 * try all of them in order and use the first one that\n                 * succeeds. */\n\n                if (b->exec_path)\n                        r = bus_socket_exec(b);\n                else if ((b->nspid > 0 || b->machine) && b->sockaddr.sa.sa_family != AF_UNSPEC)\n                        r = bus_container_connect_socket(b);\n                else if (b->sockaddr.sa.sa_family != AF_UNSPEC)\n                        r = bus_socket_connect(b);\n                else\n                        goto next;\n\n                if (r >= 0) {\n                        int q;\n\n                        q = bus_attach_io_events(b);\n                        if (q < 0)\n                                return q;\n\n                        q = bus_attach_inotify_event(b);\n                        if (q < 0)\n                                return q;\n\n                        return r;\n                }\n\n                b->last_connect_error = -r;\n\n        next:\n                r = bus_parse_next_address(b);\n                if (r < 0)\n                        return r;\n                if (r == 0)\n                        return b->last_connect_error > 0 ? -b->last_connect_error : -ECONNREFUSED;\n        }\n}\n\nint bus_next_address(sd_bus *b) {\n        assert(b);\n\n        bus_reset_parsed_address(b);\n        return bus_start_address(b);\n}\n\nstatic int bus_start_fd(sd_bus *b) {\n        struct stat st;\n        int r;\n\n        assert(b);\n        assert(b->input_fd >= 0);\n        assert(b->output_fd >= 0);\n\n        r = fd_nonblock(b->input_fd, true);\n        if (r < 0)\n                return r;\n\n        r = fd_cloexec(b->input_fd, true);\n        if (r < 0)\n                return r;\n\n        if (b->input_fd != b->output_fd) {\n                r = fd_nonblock(b->output_fd, true);\n                if (r < 0)\n                        return r;\n\n                r = fd_cloexec(b->output_fd, true);\n                if (r < 0)\n                        return r;\n        }\n\n        if (fstat(b->input_fd, &st) < 0)\n                return -errno;\n\n        return bus_socket_take_fd(b);\n}\n\n_public_ int sd_bus_start(sd_bus *bus) {\n        int r;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus_set_state(bus, BUS_OPENING);\n\n        if (bus->is_server && bus->bus_client)\n                return -EINVAL;\n\n        if (bus->input_fd >= 0)\n                r = bus_start_fd(bus);\n        else if (bus->address || bus->sockaddr.sa.sa_family != AF_UNSPEC || bus->exec_path || bus->machine)\n                r = bus_start_address(bus);\n        else\n                return -EINVAL;\n\n        if (r < 0) {\n                sd_bus_close(bus);\n                return r;\n        }\n\n        return bus_send_hello(bus);\n}\n\n_public_ int sd_bus_open_with_description(sd_bus **ret, const char *description) {\n        const char *e;\n        _cleanup_(bus_freep) sd_bus *b = NULL;\n        int r;\n\n        assert_return(ret, -EINVAL);\n\n        /* Let's connect to the starter bus if it is set, and\n         * otherwise to the bus that is appropriate for the scope\n         * we are running in */\n\n        e = secure_getenv(\"DBUS_STARTER_BUS_TYPE\");\n        if (e) {\n                if (streq(e, \"system\"))\n                        return sd_bus_open_system_with_description(ret, description);\n                else if (STR_IN_SET(e, \"session\", \"user\"))\n                        return sd_bus_open_user_with_description(ret, description);\n        }\n\n        e = secure_getenv(\"DBUS_STARTER_ADDRESS\");\n        if (!e) {\n                if (cg_pid_get_owner_uid(0, NULL) >= 0)\n                        return sd_bus_open_user_with_description(ret, description);\n                else\n                        return sd_bus_open_system_with_description(ret, description);\n        }\n\n        r = sd_bus_new(&b);\n        if (r < 0)\n                return r;\n\n        r = sd_bus_set_address(b, e);\n        if (r < 0)\n                return r;\n\n        b->bus_client = true;\n\n        /* We don't know whether the bus is trusted or not, so better\n         * be safe, and authenticate everything */\n        b->trusted = false;\n        b->is_local = false;\n        b->creds_mask |= SD_BUS_CREDS_UID | SD_BUS_CREDS_EUID | SD_BUS_CREDS_EFFECTIVE_CAPS;\n\n        r = sd_bus_start(b);\n        if (r < 0)\n                return r;\n\n        *ret = TAKE_PTR(b);\n        return 0;\n}\n\n_public_ int sd_bus_open(sd_bus **ret) {\n        return sd_bus_open_with_description(ret, NULL);\n}\n\nint bus_set_address_system(sd_bus *b) {\n        const char *e;\n        assert(b);\n\n        e = secure_getenv(\"DBUS_SYSTEM_BUS_ADDRESS\");\n        if (e)\n                return sd_bus_set_address(b, e);\n\n        return sd_bus_set_address(b, DEFAULT_SYSTEM_BUS_ADDRESS);\n}\n\n_public_ int sd_bus_open_system_with_description(sd_bus **ret, const char *description) {\n        _cleanup_(bus_freep) sd_bus *b = NULL;\n        int r;\n\n        assert_return(ret, -EINVAL);\n\n        r = sd_bus_new(&b);\n        if (r < 0)\n                return r;\n\n        if (description) {\n                r = sd_bus_set_description(b, description);\n                if (r < 0)\n                        return r;\n        }\n\n        r = bus_set_address_system(b);\n        if (r < 0)\n                return r;\n\n        b->bus_client = true;\n        b->is_system = true;\n\n        /* Let's do per-method access control on the system bus. We\n         * need the caller's UID and capability set for that. */\n        b->trusted = false;\n        b->creds_mask |= SD_BUS_CREDS_UID | SD_BUS_CREDS_EUID | SD_BUS_CREDS_EFFECTIVE_CAPS;\n        b->is_local = true;\n\n        r = sd_bus_start(b);\n        if (r < 0)\n                return r;\n\n        *ret = TAKE_PTR(b);\n        return 0;\n}\n\n_public_ int sd_bus_open_system(sd_bus **ret) {\n        return sd_bus_open_system_with_description(ret, NULL);\n}\n\nint bus_set_address_user(sd_bus *b) {\n        const char *e;\n        _cleanup_free_ char *ee = NULL, *s = NULL;\n\n        assert(b);\n\n        e = secure_getenv(\"DBUS_SESSION_BUS_ADDRESS\");\n        if (e)\n                return sd_bus_set_address(b, e);\n\n        e = secure_getenv(\"XDG_RUNTIME_DIR\");\n        if (!e)\n                return -ENOENT;\n\n        ee = bus_address_escape(e);\n        if (!ee)\n                return -ENOMEM;\n\n        if (asprintf(&s, DEFAULT_USER_BUS_ADDRESS_FMT, ee) < 0)\n                return -ENOMEM;\n\n        b->address = TAKE_PTR(s);\n\n        return 0;\n}\n\n_public_ int sd_bus_open_user_with_description(sd_bus **ret, const char *description) {\n        _cleanup_(bus_freep) sd_bus *b = NULL;\n        int r;\n\n        assert_return(ret, -EINVAL);\n\n        r = sd_bus_new(&b);\n        if (r < 0)\n                return r;\n\n        if (description) {\n                r = sd_bus_set_description(b, description);\n                if (r < 0)\n                        return r;\n        }\n\n        r = bus_set_address_user(b);\n        if (r < 0)\n                return r;\n\n        b->bus_client = true;\n        b->is_user = true;\n\n        /* We don't do any per-method access control on the user bus. */\n        b->trusted = true;\n        b->is_local = true;\n\n        r = sd_bus_start(b);\n        if (r < 0)\n                return r;\n\n        *ret = TAKE_PTR(b);\n        return 0;\n}\n\n_public_ int sd_bus_open_user(sd_bus **ret) {\n        return sd_bus_open_user_with_description(ret, NULL);\n}\n\nint bus_set_address_system_remote(sd_bus *b, const char *host) {\n        _cleanup_free_ char *e = NULL;\n        char *m = NULL, *c = NULL, *a, *rbracket = NULL, *p = NULL;\n\n        assert(b);\n        assert(host);\n\n        /* Skip \":\"s in ipv6 addresses */\n        if (*host == '[') {\n                char *t;\n\n                rbracket = strchr(host, ']');\n                if (!rbracket)\n                        return -EINVAL;\n                t = strndupa(host + 1, rbracket - host - 1);\n                e = bus_address_escape(t);\n                if (!e)\n                        return -ENOMEM;\n        } else if ((a = strchr(host, '@'))) {\n                if (*(a + 1) == '[') {\n                        _cleanup_free_ char *t = NULL;\n\n                        rbracket = strchr(a + 1, ']');\n                        if (!rbracket)\n                                return -EINVAL;\n                        t = new0(char, strlen(host));\n                        if (!t)\n                                return -ENOMEM;\n                        strncat(t, host, a - host + 1);\n                        strncat(t, a + 2, rbracket - a - 2);\n                        e = bus_address_escape(t);\n                        if (!e)\n                                return -ENOMEM;\n                } else if (*(a + 1) == '\\0' || strchr(a + 1, '@'))\n                        return -EINVAL;\n        }\n\n        /* Let's see if a port was given */\n        m = strchr(rbracket ? rbracket + 1 : host, ':');\n        if (m) {\n                char *t;\n                bool got_forward_slash = false;\n\n                p = m + 1;\n\n                t = strchr(p, '/');\n                if (t) {\n                        p = strndupa(p, t - p);\n                        got_forward_slash = true;\n                }\n\n                if (!in_charset(p, \"0123456789\") || *p == '\\0') {\n                        if (!machine_name_is_valid(p) || got_forward_slash)\n                                return -EINVAL;\n\n                        m = TAKE_PTR(p);\n                        goto interpret_port_as_machine_old_syntax;\n                }\n        }\n\n        /* Let's see if a machine was given */\n        m = strchr(rbracket ? rbracket + 1 : host, '/');\n        if (m) {\n                m++;\ninterpret_port_as_machine_old_syntax:\n                /* Let's make sure this is not a port of some kind,\n                 * and is a valid machine name. */\n                if (!in_charset(m, \"0123456789\") && machine_name_is_valid(m))\n                        c = strjoina(\",argv\", p ? \"7\" : \"5\", \"=--machine=\", m);\n        }\n\n        if (!e) {\n                char *t;\n\n                t = strndupa(host, strcspn(host, \":/\"));\n\n                e = bus_address_escape(t);\n                if (!e)\n                        return -ENOMEM;\n        }\n\n        a = strjoin(\"unixexec:path=ssh,argv1=-xT\", p ? \",argv2=-p,argv3=\" : \"\", strempty(p),\n                                \",argv\", p ? \"4\" : \"2\", \"=--,argv\", p ? \"5\" : \"3\", \"=\", e,\n                                \",argv\", p ? \"6\" : \"4\", \"=systemd-stdio-bridge\", c);\n        if (!a)\n                return -ENOMEM;\n\n        return free_and_replace(b->address, a);\n}\n\n_public_ int sd_bus_open_system_remote(sd_bus **ret, const char *host) {\n        _cleanup_(bus_freep) sd_bus *b = NULL;\n        int r;\n\n        assert_return(host, -EINVAL);\n        assert_return(ret, -EINVAL);\n\n        r = sd_bus_new(&b);\n        if (r < 0)\n                return r;\n\n        r = bus_set_address_system_remote(b, host);\n        if (r < 0)\n                return r;\n\n        b->bus_client = true;\n        b->trusted = false;\n        b->is_system = true;\n        b->is_local = false;\n\n        r = sd_bus_start(b);\n        if (r < 0)\n                return r;\n\n        *ret = TAKE_PTR(b);\n        return 0;\n}\n\nint bus_set_address_system_machine(sd_bus *b, const char *machine) {\n        _cleanup_free_ char *e = NULL;\n        char *a;\n\n        assert(b);\n        assert(machine);\n\n        e = bus_address_escape(machine);\n        if (!e)\n                return -ENOMEM;\n\n        a = strjoin(\"x-machine-unix:machine=\", e);\n        if (!a)\n                return -ENOMEM;\n\n        return free_and_replace(b->address, a);\n}\n\n_public_ int sd_bus_open_system_machine(sd_bus **ret, const char *machine) {\n        _cleanup_(bus_freep) sd_bus *b = NULL;\n        int r;\n\n        assert_return(machine, -EINVAL);\n        assert_return(ret, -EINVAL);\n        assert_return(streq(machine, \".host\") || machine_name_is_valid(machine), -EINVAL);\n\n        r = sd_bus_new(&b);\n        if (r < 0)\n                return r;\n\n        r = bus_set_address_system_machine(b, machine);\n        if (r < 0)\n                return r;\n\n        b->bus_client = true;\n        b->trusted = false;\n        b->is_system = true;\n        b->is_local = false;\n\n        r = sd_bus_start(b);\n        if (r < 0)\n                return r;\n\n        *ret = TAKE_PTR(b);\n        return 0;\n}\n\n_public_ void sd_bus_close(sd_bus *bus) {\n        if (!bus)\n                return;\n        if (bus->state == BUS_CLOSED)\n                return;\n        if (bus_pid_changed(bus))\n                return;\n\n        /* Don't leave ssh hanging around */\n        bus_kill_exec(bus);\n\n        bus_set_state(bus, BUS_CLOSED);\n\n        sd_bus_detach_event(bus);\n\n        /* Drop all queued messages so that they drop references to\n         * the bus object and the bus may be freed */\n        bus_reset_queues(bus);\n\n        bus_close_io_fds(bus);\n        bus_close_inotify_fd(bus);\n}\n\n_public_ sd_bus *sd_bus_close_unref(sd_bus *bus) {\n        if (!bus)\n                return NULL;\n\n        sd_bus_close(bus);\n\n        return sd_bus_unref(bus);\n}\n\n_public_ sd_bus* sd_bus_flush_close_unref(sd_bus *bus) {\n        if (!bus)\n                return NULL;\n\n        /* Have to do this before flush() to prevent hang */\n        bus_kill_exec(bus);\n        sd_bus_flush(bus);\n\n        return sd_bus_close_unref(bus);\n}\n\nvoid bus_enter_closing(sd_bus *bus) {\n        assert(bus);\n\n        if (!IN_SET(bus->state, BUS_WATCH_BIND, BUS_OPENING, BUS_AUTHENTICATING, BUS_HELLO, BUS_RUNNING))\n                return;\n\n        bus_set_state(bus, BUS_CLOSING);\n}\n\nDEFINE_PUBLIC_TRIVIAL_REF_UNREF_FUNC(sd_bus, sd_bus, bus_free);\n\n_public_ int sd_bus_is_open(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return BUS_IS_OPEN(bus->state);\n}\n\n_public_ int sd_bus_is_ready(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return bus->state == BUS_RUNNING;\n}\n\n_public_ int sd_bus_can_send(sd_bus *bus, char type) {\n        int r;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state != BUS_UNSET, -ENOTCONN);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (bus->is_monitor)\n                return 0;\n\n        if (type == SD_BUS_TYPE_UNIX_FD) {\n                if (!bus->accept_fd)\n                        return 0;\n\n                r = bus_ensure_running(bus);\n                if (r < 0)\n                        return r;\n\n                return bus->can_fds;\n        }\n\n        return bus_type_is_valid(type);\n}\n\n_public_ int sd_bus_get_bus_id(sd_bus *bus, sd_id128_t *id) {\n        int r;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(id, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        r = bus_ensure_running(bus);\n        if (r < 0)\n                return r;\n\n        *id = bus->server_id;\n        return 0;\n}\n\n#define COOKIE_CYCLED (UINT32_C(1) << 31)\n\nstatic uint64_t cookie_inc(uint64_t cookie) {\n\n        /* Stay within the 32bit range, since classic D-Bus can't deal with more */\n        if (cookie >= UINT32_MAX)\n                return COOKIE_CYCLED; /* Don't go back to zero, but use the highest bit for checking\n                                       * whether we are looping. */\n\n        return cookie + 1;\n}\n\nstatic int next_cookie(sd_bus *b) {\n        uint64_t new_cookie;\n\n        assert(b);\n\n        new_cookie = cookie_inc(b->cookie);\n\n        /* Small optimization: don't bother with checking for cookie reuse until we overran cookiespace at\n         * least once, but then do it thorougly. */\n        if (FLAGS_SET(new_cookie, COOKIE_CYCLED)) {\n                uint32_t i;\n\n                /* Check if the cookie is currently in use. If so, pick the next one */\n                for (i = 0; i < COOKIE_CYCLED; i++) {\n                        if (!ordered_hashmap_contains(b->reply_callbacks, &new_cookie))\n                                goto good;\n\n                        new_cookie = cookie_inc(new_cookie);\n                }\n\n                /* Can't fulfill request */\n                return -EBUSY;\n        }\n\ngood:\n        b->cookie = new_cookie;\n        return 0;\n}\n\nstatic int bus_seal_message(sd_bus *b, sd_bus_message *m, usec_t timeout) {\n        int r;\n\n        assert(b);\n        assert(m);\n\n        if (m->sealed) {\n                /* If we copy the same message to multiple\n                 * destinations, avoid using the same cookie\n                 * numbers. */\n                b->cookie = MAX(b->cookie, BUS_MESSAGE_COOKIE(m));\n                return 0;\n        }\n\n        if (timeout == 0) {\n                r = sd_bus_get_method_call_timeout(b, &timeout);\n                if (r < 0)\n                        return r;\n        }\n\n        if (!m->sender && b->patch_sender) {\n                r = sd_bus_message_set_sender(m, b->patch_sender);\n                if (r < 0)\n                        return r;\n        }\n\n        r = next_cookie(b);\n        if (r < 0)\n                return r;\n\n        return sd_bus_message_seal(m, b->cookie, timeout);\n}\n\nstatic int bus_remarshal_message(sd_bus *b, sd_bus_message **m) {\n        bool remarshal = false;\n\n        assert(b);\n\n        /* wrong packet version */\n        if (b->message_version != 0 && b->message_version != (*m)->header->version)\n                remarshal = true;\n\n        /* wrong packet endianness */\n        if (b->message_endian != 0 && b->message_endian != (*m)->header->endian)\n                remarshal = true;\n\n        return remarshal ? bus_message_remarshal(b, m) : 0;\n}\n\nint bus_seal_synthetic_message(sd_bus *b, sd_bus_message *m) {\n        assert(b);\n        assert(m);\n\n        /* Fake some timestamps, if they were requested, and not\n         * already initialized */\n        if (b->attach_timestamp) {\n                if (m->realtime <= 0)\n                        m->realtime = now(CLOCK_REALTIME);\n\n                if (m->monotonic <= 0)\n                        m->monotonic = now(CLOCK_MONOTONIC);\n        }\n\n        /* The bus specification says the serial number cannot be 0,\n         * hence let's fill something in for synthetic messages. Since\n         * synthetic messages might have a fake sender and we don't\n         * want to interfere with the real sender's serial numbers we\n         * pick a fixed, artificial one. We use (uint32_t) -1 rather\n         * than (uint64_t) -1 since dbus1 only had 32bit identifiers,\n         * even though kdbus can do 64bit. */\n        return sd_bus_message_seal(m, 0xFFFFFFFFULL, 0);\n}\n\nstatic int bus_write_message(sd_bus *bus, sd_bus_message *m, size_t *idx) {\n        int r;\n\n        assert(bus);\n        assert(m);\n\n        r = bus_socket_write_message(bus, m, idx);\n        if (r <= 0)\n                return r;\n\n        if (*idx >= BUS_MESSAGE_SIZE(m))\n                log_debug(\"Sent message type=%s sender=%s destination=%s path=%s interface=%s member=%s cookie=%\" PRIu64 \" reply_cookie=%\" PRIu64 \" signature=%s error-name=%s error-message=%s\",\n                          bus_message_type_to_string(m->header->type),\n                          strna(sd_bus_message_get_sender(m)),\n                          strna(sd_bus_message_get_destination(m)),\n                          strna(sd_bus_message_get_path(m)),\n                          strna(sd_bus_message_get_interface(m)),\n                          strna(sd_bus_message_get_member(m)),\n                          BUS_MESSAGE_COOKIE(m),\n                          m->reply_cookie,\n                          strna(m->root_container.signature),\n                          strna(m->error.name),\n                          strna(m->error.message));\n\n        return r;\n}\n\nstatic int dispatch_wqueue(sd_bus *bus) {\n        int r, ret = 0;\n\n        assert(bus);\n        assert(IN_SET(bus->state, BUS_RUNNING, BUS_HELLO));\n\n        while (bus->wqueue_size > 0) {\n\n                r = bus_write_message(bus, bus->wqueue[0], &bus->windex);\n                if (r < 0)\n                        return r;\n                else if (r == 0)\n                        /* Didn't do anything this time */\n                        return ret;\n                else if (bus->windex >= BUS_MESSAGE_SIZE(bus->wqueue[0])) {\n                        /* Fully written. Let's drop the entry from\n                         * the queue.\n                         *\n                         * This isn't particularly optimized, but\n                         * well, this is supposed to be our worst-case\n                         * buffer only, and the socket buffer is\n                         * supposed to be our primary buffer, and if\n                         * it got full, then all bets are off\n                         * anyway. */\n\n                        bus->wqueue_size--;\n                        bus_message_unref_queued(bus->wqueue[0], bus);\n                        memmove(bus->wqueue, bus->wqueue + 1, sizeof(sd_bus_message*) * bus->wqueue_size);\n                        bus->windex = 0;\n\n                        ret = 1;\n                }\n        }\n\n        return ret;\n}\n\nstatic int bus_read_message(sd_bus *bus, bool hint_priority, int64_t priority) {\n        assert(bus);\n\n        return bus_socket_read_message(bus);\n}\n\nint bus_rqueue_make_room(sd_bus *bus) {\n        assert(bus);\n\n        if (bus->rqueue_size >= BUS_RQUEUE_MAX)\n                return -ENOBUFS;\n\n        if (!GREEDY_REALLOC(bus->rqueue, bus->rqueue_allocated, bus->rqueue_size + 1))\n                return -ENOMEM;\n\n        return 0;\n}\n\nstatic void rqueue_drop_one(sd_bus *bus, size_t i) {\n        assert(bus);\n        assert(i < bus->rqueue_size);\n\n        bus_message_unref_queued(bus->rqueue[i], bus);\n        memmove(bus->rqueue + i, bus->rqueue + i + 1, sizeof(sd_bus_message*) * (bus->rqueue_size - i - 1));\n        bus->rqueue_size--;\n}\n\nstatic int dispatch_rqueue(sd_bus *bus, bool hint_priority, int64_t priority, sd_bus_message **m) {\n        int r, ret = 0;\n\n        assert(bus);\n        assert(m);\n        assert(IN_SET(bus->state, BUS_RUNNING, BUS_HELLO));\n\n        /* Note that the priority logic is only available on kdbus,\n         * where the rqueue is unused. We check the rqueue here\n         * anyway, because it's simple... */\n\n        for (;;) {\n                if (bus->rqueue_size > 0) {\n                        /* Dispatch a queued message */\n                        *m = sd_bus_message_ref(bus->rqueue[0]);\n                        rqueue_drop_one(bus, 0);\n                        return 1;\n                }\n\n                /* Try to read a new message */\n                r = bus_read_message(bus, hint_priority, priority);\n                if (r < 0)\n                        return r;\n                if (r == 0) {\n                        *m = NULL;\n                        return ret;\n                }\n\n                ret = 1;\n        }\n}\n\n_public_ int sd_bus_send(sd_bus *bus, sd_bus_message *_m, uint64_t *cookie) {\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = sd_bus_message_ref(_m);\n        int r;\n\n        assert_return(m, -EINVAL);\n\n        if (!bus)\n                bus = m->bus;\n\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (!BUS_IS_OPEN(bus->state))\n                return -ENOTCONN;\n\n        if (m->n_fds > 0) {\n                r = sd_bus_can_send(bus, SD_BUS_TYPE_UNIX_FD);\n                if (r < 0)\n                        return r;\n                if (r == 0)\n                        return -EOPNOTSUPP;\n        }\n\n        /* If the cookie number isn't kept, then we know that no reply\n         * is expected */\n        if (!cookie && !m->sealed)\n                m->header->flags |= BUS_MESSAGE_NO_REPLY_EXPECTED;\n\n        r = bus_seal_message(bus, m, 0);\n        if (r < 0)\n                return r;\n\n        /* Remarshall if we have to. This will possibly unref the\n         * message and place a replacement in m */\n        r = bus_remarshal_message(bus, &m);\n        if (r < 0)\n                return r;\n\n        /* If this is a reply and no reply was requested, then let's\n         * suppress this, if we can */\n        if (m->dont_send)\n                goto finish;\n\n        if (IN_SET(bus->state, BUS_RUNNING, BUS_HELLO) && bus->wqueue_size <= 0) {\n                size_t idx = 0;\n\n                r = bus_write_message(bus, m, &idx);\n                if (r < 0) {\n                        if (ERRNO_IS_DISCONNECT(r)) {\n                                bus_enter_closing(bus);\n                                return -ECONNRESET;\n                        }\n\n                        return r;\n                }\n\n                if (idx < BUS_MESSAGE_SIZE(m))  {\n                        /* Wasn't fully written. So let's remember how\n                         * much was written. Note that the first entry\n                         * of the wqueue array is always allocated so\n                         * that we always can remember how much was\n                         * written. */\n                        bus->wqueue[0] = bus_message_ref_queued(m, bus);\n                        bus->wqueue_size = 1;\n                        bus->windex = idx;\n                }\n\n        } else {\n                /* Just append it to the queue. */\n\n                if (bus->wqueue_size >= BUS_WQUEUE_MAX)\n                        return -ENOBUFS;\n\n                if (!GREEDY_REALLOC(bus->wqueue, bus->wqueue_allocated, bus->wqueue_size + 1))\n                        return -ENOMEM;\n\n                bus->wqueue[bus->wqueue_size++] = bus_message_ref_queued(m, bus);\n        }\n\nfinish:\n        if (cookie)\n                *cookie = BUS_MESSAGE_COOKIE(m);\n\n        return 1;\n}\n\n_public_ int sd_bus_send_to(sd_bus *bus, sd_bus_message *m, const char *destination, uint64_t *cookie) {\n        int r;\n\n        assert_return(m, -EINVAL);\n\n        if (!bus)\n                bus = m->bus;\n\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (!BUS_IS_OPEN(bus->state))\n                return -ENOTCONN;\n\n        if (!streq_ptr(m->destination, destination)) {\n\n                if (!destination)\n                        return -EEXIST;\n\n                r = sd_bus_message_set_destination(m, destination);\n                if (r < 0)\n                        return r;\n        }\n\n        return sd_bus_send(bus, m, cookie);\n}\n\nstatic usec_t calc_elapse(sd_bus *bus, uint64_t usec) {\n        assert(bus);\n\n        if (usec == (uint64_t) -1)\n                return 0;\n\n        /* We start all timeouts the instant we enter BUS_HELLO/BUS_RUNNING state, so that the don't run in parallel\n         * with any connection setup states. Hence, if a method callback is started earlier than that we just store the\n         * relative timestamp, and afterwards the absolute one. */\n\n        if (IN_SET(bus->state, BUS_WATCH_BIND, BUS_OPENING, BUS_AUTHENTICATING))\n                return usec;\n        else\n                return now(CLOCK_MONOTONIC) + usec;\n}\n\nstatic int timeout_compare(const void *a, const void *b) {\n        const struct reply_callback *x = a, *y = b;\n\n        if (x->timeout_usec != 0 && y->timeout_usec == 0)\n                return -1;\n\n        if (x->timeout_usec == 0 && y->timeout_usec != 0)\n                return 1;\n\n        return CMP(x->timeout_usec, y->timeout_usec);\n}\n\n_public_ int sd_bus_call_async(\n                sd_bus *bus,\n                sd_bus_slot **slot,\n                sd_bus_message *_m,\n                sd_bus_message_handler_t callback,\n                void *userdata,\n                uint64_t usec) {\n\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = sd_bus_message_ref(_m);\n        _cleanup_(sd_bus_slot_unrefp) sd_bus_slot *s = NULL;\n        int r;\n\n        assert_return(m, -EINVAL);\n        assert_return(m->header->type == SD_BUS_MESSAGE_METHOD_CALL, -EINVAL);\n        assert_return(!m->sealed || (!!callback == !(m->header->flags & BUS_MESSAGE_NO_REPLY_EXPECTED)), -EINVAL);\n\n        if (!bus)\n                bus = m->bus;\n\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (!BUS_IS_OPEN(bus->state))\n                return -ENOTCONN;\n\n        /* If no callback is specified and there's no interest in a slot, then there's no reason to ask for a reply */\n        if (!callback && !slot && !m->sealed)\n                m->header->flags |= BUS_MESSAGE_NO_REPLY_EXPECTED;\n\n        r = ordered_hashmap_ensure_allocated(&bus->reply_callbacks, &uint64_hash_ops);\n        if (r < 0)\n                return r;\n\n        r = prioq_ensure_allocated(&bus->reply_callbacks_prioq, timeout_compare);\n        if (r < 0)\n                return r;\n\n        r = bus_seal_message(bus, m, usec);\n        if (r < 0)\n                return r;\n\n        r = bus_remarshal_message(bus, &m);\n        if (r < 0)\n                return r;\n\n        if (slot || callback) {\n                s = bus_slot_allocate(bus, !slot, BUS_REPLY_CALLBACK, sizeof(struct reply_callback), userdata);\n                if (!s)\n                        return -ENOMEM;\n\n                s->reply_callback.callback = callback;\n\n                s->reply_callback.cookie = BUS_MESSAGE_COOKIE(m);\n                r = ordered_hashmap_put(bus->reply_callbacks, &s->reply_callback.cookie, &s->reply_callback);\n                if (r < 0) {\n                        s->reply_callback.cookie = 0;\n                        return r;\n                }\n\n                s->reply_callback.timeout_usec = calc_elapse(bus, m->timeout);\n                if (s->reply_callback.timeout_usec != 0) {\n                        r = prioq_put(bus->reply_callbacks_prioq, &s->reply_callback, &s->reply_callback.prioq_idx);\n                        if (r < 0) {\n                                s->reply_callback.timeout_usec = 0;\n                                return r;\n                        }\n                }\n        }\n\n        r = sd_bus_send(bus, m, s ? &s->reply_callback.cookie : NULL);\n        if (r < 0)\n                return r;\n\n        if (slot)\n                *slot = s;\n        s = NULL;\n\n        return r;\n}\n\nint bus_ensure_running(sd_bus *bus) {\n        int r;\n\n        assert(bus);\n\n        if (IN_SET(bus->state, BUS_UNSET, BUS_CLOSED, BUS_CLOSING))\n                return -ENOTCONN;\n        if (bus->state == BUS_RUNNING)\n                return 1;\n\n        for (;;) {\n                r = sd_bus_process(bus, NULL);\n                if (r < 0)\n                        return r;\n                if (bus->state == BUS_RUNNING)\n                        return 1;\n                if (r > 0)\n                        continue;\n\n                r = sd_bus_wait(bus, (uint64_t) -1);\n                if (r < 0)\n                        return r;\n        }\n}\n\n_public_ int sd_bus_call(\n                sd_bus *bus,\n                sd_bus_message *_m,\n                uint64_t usec,\n                sd_bus_error *error,\n                sd_bus_message **reply) {\n\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = sd_bus_message_ref(_m);\n        usec_t timeout;\n        uint64_t cookie;\n        size_t i;\n        int r;\n\n        bus_assert_return(m, -EINVAL, error);\n        bus_assert_return(m->header->type == SD_BUS_MESSAGE_METHOD_CALL, -EINVAL, error);\n        bus_assert_return(!(m->header->flags & BUS_MESSAGE_NO_REPLY_EXPECTED), -EINVAL, error);\n        bus_assert_return(!bus_error_is_dirty(error), -EINVAL, error);\n\n        if (!bus)\n                bus = m->bus;\n\n        bus_assert_return(!bus_pid_changed(bus), -ECHILD, error);\n\n        if (!BUS_IS_OPEN(bus->state)) {\n                r = -ENOTCONN;\n                goto fail;\n        }\n\n        r = bus_ensure_running(bus);\n        if (r < 0)\n                goto fail;\n\n        i = bus->rqueue_size;\n\n        r = bus_seal_message(bus, m, usec);\n        if (r < 0)\n                goto fail;\n\n        r = bus_remarshal_message(bus, &m);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_send(bus, m, &cookie);\n        if (r < 0)\n                goto fail;\n\n        timeout = calc_elapse(bus, m->timeout);\n\n        for (;;) {\n                usec_t left;\n\n                while (i < bus->rqueue_size) {\n                        _cleanup_(sd_bus_message_unrefp) sd_bus_message *incoming = NULL;\n\n                        incoming = sd_bus_message_ref(bus->rqueue[i]);\n\n                        if (incoming->reply_cookie == cookie) {\n                                /* Found a match! */\n\n                                rqueue_drop_one(bus, i);\n                                log_debug_bus_message(incoming);\n\n                                if (incoming->header->type == SD_BUS_MESSAGE_METHOD_RETURN) {\n\n                                        if (incoming->n_fds <= 0 || bus->accept_fd) {\n                                                if (reply)\n                                                        *reply = TAKE_PTR(incoming);\n\n                                                return 1;\n                                        }\n\n                                        return sd_bus_error_setf(error, SD_BUS_ERROR_INCONSISTENT_MESSAGE, \"Reply message contained file descriptors which I couldn't accept. Sorry.\");\n\n                                } else if (incoming->header->type == SD_BUS_MESSAGE_METHOD_ERROR)\n                                        return sd_bus_error_copy(error, &incoming->error);\n                                else {\n                                        r = -EIO;\n                                        goto fail;\n                                }\n\n                        } else if (BUS_MESSAGE_COOKIE(incoming) == cookie &&\n                                   bus->unique_name &&\n                                   incoming->sender &&\n                                   streq(bus->unique_name, incoming->sender)) {\n\n                                rqueue_drop_one(bus, i);\n\n                                /* Our own message? Somebody is trying to send its own client a message,\n                                 * let's not dead-lock, let's fail immediately. */\n\n                                r = -ELOOP;\n                                goto fail;\n                        }\n\n                        /* Try to read more, right-away */\n                        i++;\n                }\n\n                r = bus_read_message(bus, false, 0);\n                if (r < 0) {\n                        if (ERRNO_IS_DISCONNECT(r)) {\n                                bus_enter_closing(bus);\n                                r = -ECONNRESET;\n                        }\n\n                        goto fail;\n                }\n                if (r > 0)\n                        continue;\n\n                if (timeout > 0) {\n                        usec_t n;\n\n                        n = now(CLOCK_MONOTONIC);\n                        if (n >= timeout) {\n                                r = -ETIMEDOUT;\n                                goto fail;\n                        }\n\n                        left = timeout - n;\n                } else\n                        left = (uint64_t) -1;\n\n                r = bus_poll(bus, true, left);\n                if (r < 0)\n                        goto fail;\n                if (r == 0) {\n                        r = -ETIMEDOUT;\n                        goto fail;\n                }\n\n                r = dispatch_wqueue(bus);\n                if (r < 0) {\n                        if (ERRNO_IS_DISCONNECT(r)) {\n                                bus_enter_closing(bus);\n                                r = -ECONNRESET;\n                        }\n\n                        goto fail;\n                }\n        }\n\nfail:\n        return sd_bus_error_set_errno(error, r);\n}\n\n_public_ int sd_bus_get_fd(sd_bus *bus) {\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->input_fd == bus->output_fd, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (bus->state == BUS_CLOSED)\n                return -ENOTCONN;\n\n        if (bus->inotify_fd >= 0)\n                return bus->inotify_fd;\n\n        if (bus->input_fd >= 0)\n                return bus->input_fd;\n\n        return -ENOTCONN;\n}\n\n_public_ int sd_bus_get_events(sd_bus *bus) {\n        int flags = 0;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        switch (bus->state) {\n\n        case BUS_UNSET:\n        case BUS_CLOSED:\n                return -ENOTCONN;\n\n        case BUS_WATCH_BIND:\n                flags |= POLLIN;\n                break;\n\n        case BUS_OPENING:\n                flags |= POLLOUT;\n                break;\n\n        case BUS_AUTHENTICATING:\n                if (bus_socket_auth_needs_write(bus))\n                        flags |= POLLOUT;\n\n                flags |= POLLIN;\n                break;\n\n        case BUS_RUNNING:\n        case BUS_HELLO:\n                if (bus->rqueue_size <= 0)\n                        flags |= POLLIN;\n                if (bus->wqueue_size > 0)\n                        flags |= POLLOUT;\n                break;\n\n        case BUS_CLOSING:\n                break;\n\n        default:\n                assert_not_reached(\"Unknown state\");\n        }\n\n        return flags;\n}\n\n_public_ int sd_bus_get_timeout(sd_bus *bus, uint64_t *timeout_usec) {\n        struct reply_callback *c;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(timeout_usec, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (!BUS_IS_OPEN(bus->state) && bus->state != BUS_CLOSING)\n                return -ENOTCONN;\n\n        if (bus->track_queue) {\n                *timeout_usec = 0;\n                return 1;\n        }\n\n        switch (bus->state) {\n\n        case BUS_AUTHENTICATING:\n                *timeout_usec = bus->auth_timeout;\n                return 1;\n\n        case BUS_RUNNING:\n        case BUS_HELLO:\n                if (bus->rqueue_size > 0) {\n                        *timeout_usec = 0;\n                        return 1;\n                }\n\n                c = prioq_peek(bus->reply_callbacks_prioq);\n                if (!c) {\n                        *timeout_usec = (uint64_t) -1;\n                        return 0;\n                }\n\n                if (c->timeout_usec == 0) {\n                        *timeout_usec = (uint64_t) -1;\n                        return 0;\n                }\n\n                *timeout_usec = c->timeout_usec;\n                return 1;\n\n        case BUS_CLOSING:\n                *timeout_usec = 0;\n                return 1;\n\n        case BUS_WATCH_BIND:\n        case BUS_OPENING:\n                *timeout_usec = (uint64_t) -1;\n                return 0;\n\n        default:\n                assert_not_reached(\"Unknown or unexpected stat\");\n        }\n}\n\nstatic int process_timeout(sd_bus *bus) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error_buffer = SD_BUS_ERROR_NULL;\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message* m = NULL;\n        struct reply_callback *c;\n        sd_bus_slot *slot;\n        bool is_hello;\n        usec_t n;\n        int r;\n\n        assert(bus);\n        assert(IN_SET(bus->state, BUS_RUNNING, BUS_HELLO));\n\n        c = prioq_peek(bus->reply_callbacks_prioq);\n        if (!c)\n                return 0;\n\n        n = now(CLOCK_MONOTONIC);\n        if (c->timeout_usec > n)\n                return 0;\n\n        r = bus_message_new_synthetic_error(\n                        bus,\n                        c->cookie,\n                        &SD_BUS_ERROR_MAKE_CONST(SD_BUS_ERROR_NO_REPLY, \"Method call timed out\"),\n                        &m);\n        if (r < 0)\n                return r;\n\n        m->read_counter = ++bus->read_counter;\n\n        r = bus_seal_synthetic_message(bus, m);\n        if (r < 0)\n                return r;\n\n        assert_se(prioq_pop(bus->reply_callbacks_prioq) == c);\n        c->timeout_usec = 0;\n\n        ordered_hashmap_remove(bus->reply_callbacks, &c->cookie);\n        c->cookie = 0;\n\n        slot = container_of(c, sd_bus_slot, reply_callback);\n\n        bus->iteration_counter++;\n\n        is_hello = bus->state == BUS_HELLO && c->callback == hello_callback;\n\n        bus->current_message = m;\n        bus->current_slot = sd_bus_slot_ref(slot);\n        bus->current_handler = c->callback;\n        bus->current_userdata = slot->userdata;\n        r = c->callback(m, slot->userdata, &error_buffer);\n        bus->current_userdata = NULL;\n        bus->current_handler = NULL;\n        bus->current_slot = NULL;\n        bus->current_message = NULL;\n\n        if (slot->floating)\n                bus_slot_disconnect(slot, true);\n\n        sd_bus_slot_unref(slot);\n\n        /* When this is the hello message and it timed out, then make sure to propagate the error up, don't just log\n         * and ignore the callback handler's return value. */\n        if (is_hello)\n                return r;\n\n        return bus_maybe_reply_error(m, r, &error_buffer);\n}\n\nstatic int process_hello(sd_bus *bus, sd_bus_message *m) {\n        assert(bus);\n        assert(m);\n\n        if (bus->state != BUS_HELLO)\n                return 0;\n\n        /* Let's make sure the first message on the bus is the HELLO\n         * reply. But note that we don't actually parse the message\n         * here (we leave that to the usual handling), we just verify\n         * we don't let any earlier msg through. */\n\n        if (!IN_SET(m->header->type, SD_BUS_MESSAGE_METHOD_RETURN, SD_BUS_MESSAGE_METHOD_ERROR))\n                return -EIO;\n\n        if (m->reply_cookie != 1)\n                return -EIO;\n\n        return 0;\n}\n\nstatic int process_reply(sd_bus *bus, sd_bus_message *m) {\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *synthetic_reply = NULL;\n        _cleanup_(sd_bus_error_free) sd_bus_error error_buffer = SD_BUS_ERROR_NULL;\n        struct reply_callback *c;\n        sd_bus_slot *slot;\n        bool is_hello;\n        int r;\n\n        assert(bus);\n        assert(m);\n\n        if (!IN_SET(m->header->type, SD_BUS_MESSAGE_METHOD_RETURN, SD_BUS_MESSAGE_METHOD_ERROR))\n                return 0;\n\n        if (m->destination && bus->unique_name && !streq_ptr(m->destination, bus->unique_name))\n                return 0;\n\n        c = ordered_hashmap_remove(bus->reply_callbacks, &m->reply_cookie);\n        if (!c)\n                return 0;\n\n        c->cookie = 0;\n\n        slot = container_of(c, sd_bus_slot, reply_callback);\n\n        if (m->n_fds > 0 && !bus->accept_fd) {\n\n                /* If the reply contained a file descriptor which we\n                 * didn't want we pass an error instead. */\n\n                r = bus_message_new_synthetic_error(\n                                bus,\n                                m->reply_cookie,\n                                &SD_BUS_ERROR_MAKE_CONST(SD_BUS_ERROR_INCONSISTENT_MESSAGE, \"Reply message contained file descriptor\"),\n                                &synthetic_reply);\n                if (r < 0)\n                        return r;\n\n                /* Copy over original timestamp */\n                synthetic_reply->realtime = m->realtime;\n                synthetic_reply->monotonic = m->monotonic;\n                synthetic_reply->seqnum = m->seqnum;\n                synthetic_reply->read_counter = m->read_counter;\n\n                r = bus_seal_synthetic_message(bus, synthetic_reply);\n                if (r < 0)\n                        return r;\n\n                m = synthetic_reply;\n        } else {\n                r = sd_bus_message_rewind(m, true);\n                if (r < 0)\n                        return r;\n        }\n\n        if (c->timeout_usec != 0) {\n                prioq_remove(bus->reply_callbacks_prioq, c, &c->prioq_idx);\n                c->timeout_usec = 0;\n        }\n\n        is_hello = bus->state == BUS_HELLO && c->callback == hello_callback;\n\n        bus->current_slot = sd_bus_slot_ref(slot);\n        bus->current_handler = c->callback;\n        bus->current_userdata = slot->userdata;\n        r = c->callback(m, slot->userdata, &error_buffer);\n        bus->current_userdata = NULL;\n        bus->current_handler = NULL;\n        bus->current_slot = NULL;\n\n        if (slot->floating)\n                bus_slot_disconnect(slot, true);\n\n        sd_bus_slot_unref(slot);\n\n        /* When this is the hello message and it failed, then make sure to propagate the error up, don't just log and\n         * ignore the callback handler's return value. */\n        if (is_hello)\n                return r;\n\n        return bus_maybe_reply_error(m, r, &error_buffer);\n}\n\nstatic int process_filter(sd_bus *bus, sd_bus_message *m) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error_buffer = SD_BUS_ERROR_NULL;\n        struct filter_callback *l;\n        int r;\n\n        assert(bus);\n        assert(m);\n\n        do {\n                bus->filter_callbacks_modified = false;\n\n                LIST_FOREACH(callbacks, l, bus->filter_callbacks) {\n                        sd_bus_slot *slot;\n\n                        if (bus->filter_callbacks_modified)\n                                break;\n\n                        /* Don't run this more than once per iteration */\n                        if (l->last_iteration == bus->iteration_counter)\n                                continue;\n\n                        l->last_iteration = bus->iteration_counter;\n\n                        r = sd_bus_message_rewind(m, true);\n                        if (r < 0)\n                                return r;\n\n                        slot = container_of(l, sd_bus_slot, filter_callback);\n\n                        bus->current_slot = sd_bus_slot_ref(slot);\n                        bus->current_handler = l->callback;\n                        bus->current_userdata = slot->userdata;\n                        r = l->callback(m, slot->userdata, &error_buffer);\n                        bus->current_userdata = NULL;\n                        bus->current_handler = NULL;\n                        bus->current_slot = sd_bus_slot_unref(slot);\n\n                        r = bus_maybe_reply_error(m, r, &error_buffer);\n                        if (r != 0)\n                                return r;\n\n                }\n\n        } while (bus->filter_callbacks_modified);\n\n        return 0;\n}\n\nstatic int process_match(sd_bus *bus, sd_bus_message *m) {\n        int r;\n\n        assert(bus);\n        assert(m);\n\n        do {\n                bus->match_callbacks_modified = false;\n\n                r = bus_match_run(bus, &bus->match_callbacks, m);\n                if (r != 0)\n                        return r;\n\n        } while (bus->match_callbacks_modified);\n\n        return 0;\n}\n\nstatic int process_builtin(sd_bus *bus, sd_bus_message *m) {\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;\n        int r;\n\n        assert(bus);\n        assert(m);\n\n        if (bus->is_monitor)\n                return 0;\n\n        if (bus->manual_peer_interface)\n                return 0;\n\n        if (m->header->type != SD_BUS_MESSAGE_METHOD_CALL)\n                return 0;\n\n        if (!streq_ptr(m->interface, \"org.freedesktop.DBus.Peer\"))\n                return 0;\n\n        if (m->header->flags & BUS_MESSAGE_NO_REPLY_EXPECTED)\n                return 1;\n\n        if (streq_ptr(m->member, \"Ping\"))\n                r = sd_bus_message_new_method_return(m, &reply);\n        else if (streq_ptr(m->member, \"GetMachineId\")) {\n                sd_id128_t id;\n                char sid[SD_ID128_STRING_MAX];\n\n                r = sd_id128_get_machine(&id);\n                if (r < 0)\n                        return r;\n\n                r = sd_bus_message_new_method_return(m, &reply);\n                if (r < 0)\n                        return r;\n\n                r = sd_bus_message_append(reply, \"s\", sd_id128_to_string(id, sid));\n        } else {\n                r = sd_bus_message_new_method_errorf(\n                                m, &reply,\n                                SD_BUS_ERROR_UNKNOWN_METHOD,\n                                 \"Unknown method '%s' on interface '%s'.\", m->member, m->interface);\n        }\n        if (r < 0)\n                return r;\n\n        r = sd_bus_send(bus, reply, NULL);\n        if (r < 0)\n                return r;\n\n        return 1;\n}\n\nstatic int process_fd_check(sd_bus *bus, sd_bus_message *m) {\n        assert(bus);\n        assert(m);\n\n        /* If we got a message with a file descriptor which we didn't\n         * want to accept, then let's drop it. How can this even\n         * happen? For example, when the kernel queues a message into\n         * an activatable names's queue which allows fds, and then is\n         * delivered to us later even though we ourselves did not\n         * negotiate it. */\n\n        if (bus->is_monitor)\n                return 0;\n\n        if (m->n_fds <= 0)\n                return 0;\n\n        if (bus->accept_fd)\n                return 0;\n\n        if (m->header->type != SD_BUS_MESSAGE_METHOD_CALL)\n                return 1; /* just eat it up */\n\n        return sd_bus_reply_method_errorf(m, SD_BUS_ERROR_INCONSISTENT_MESSAGE, \"Message contains file descriptors, which I cannot accept. Sorry.\");\n}\n\nstatic int process_message(sd_bus *bus, sd_bus_message *m) {\n        int r;\n\n        assert(bus);\n        assert(m);\n\n        bus->current_message = m;\n        bus->iteration_counter++;\n\n        log_debug_bus_message(m);\n\n        r = process_hello(bus, m);\n        if (r != 0)\n                goto finish;\n\n        r = process_reply(bus, m);\n        if (r != 0)\n                goto finish;\n\n        r = process_fd_check(bus, m);\n        if (r != 0)\n                goto finish;\n\n        r = process_filter(bus, m);\n        if (r != 0)\n                goto finish;\n\n        r = process_match(bus, m);\n        if (r != 0)\n                goto finish;\n\n        r = process_builtin(bus, m);\n        if (r != 0)\n                goto finish;\n\n        r = bus_process_object(bus, m);\n\nfinish:\n        bus->current_message = NULL;\n        return r;\n}\n\nstatic int dispatch_track(sd_bus *bus) {\n        assert(bus);\n\n        if (!bus->track_queue)\n                return 0;\n\n        bus_track_dispatch(bus->track_queue);\n        return 1;\n}\n\nstatic int process_running(sd_bus *bus, bool hint_priority, int64_t priority, sd_bus_message **ret) {\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = NULL;\n        int r;\n\n        assert(bus);\n        assert(IN_SET(bus->state, BUS_RUNNING, BUS_HELLO));\n\n        r = process_timeout(bus);\n        if (r != 0)\n                goto null_message;\n\n        r = dispatch_wqueue(bus);\n        if (r != 0)\n                goto null_message;\n\n        r = dispatch_track(bus);\n        if (r != 0)\n                goto null_message;\n\n        r = dispatch_rqueue(bus, hint_priority, priority, &m);\n        if (r < 0)\n                return r;\n        if (!m)\n                goto null_message;\n\n        r = process_message(bus, m);\n        if (r != 0)\n                goto null_message;\n\n        if (ret) {\n                r = sd_bus_message_rewind(m, true);\n                if (r < 0)\n                        return r;\n\n                *ret = TAKE_PTR(m);\n                return 1;\n        }\n\n        if (m->header->type == SD_BUS_MESSAGE_METHOD_CALL) {\n\n                log_debug(\"Unprocessed message call sender=%s object=%s interface=%s member=%s\",\n                          strna(sd_bus_message_get_sender(m)),\n                          strna(sd_bus_message_get_path(m)),\n                          strna(sd_bus_message_get_interface(m)),\n                          strna(sd_bus_message_get_member(m)));\n\n                r = sd_bus_reply_method_errorf(\n                                m,\n                                SD_BUS_ERROR_UNKNOWN_OBJECT,\n                                \"Unknown object '%s'.\", m->path);\n                if (r < 0)\n                        return r;\n        }\n\n        return 1;\n\nnull_message:\n        if (r >= 0 && ret)\n                *ret = NULL;\n\n        return r;\n}\n\nstatic int bus_exit_now(sd_bus *bus) {\n        assert(bus);\n\n        /* Exit due to close, if this is requested. If this is bus object is attached to an event source, invokes\n         * sd_event_exit(), otherwise invokes libc exit(). */\n\n        if (bus->exited) /* did we already exit? */\n                return 0;\n        if (!bus->exit_triggered) /* was the exit condition triggered? */\n                return 0;\n        if (!bus->exit_on_disconnect) /* Shall we actually exit on disconnection? */\n                return 0;\n\n        bus->exited = true; /* never exit more than once */\n\n        log_debug(\"Bus connection disconnected, exiting.\");\n\n        if (bus->event)\n                return sd_event_exit(bus->event, EXIT_FAILURE);\n        else\n                exit(EXIT_FAILURE);\n\n        assert_not_reached(\"exit() didn't exit?\");\n}\n\nstatic int process_closing_reply_callback(sd_bus *bus, struct reply_callback *c) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error_buffer = SD_BUS_ERROR_NULL;\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = NULL;\n        sd_bus_slot *slot;\n        int r;\n\n        assert(bus);\n        assert(c);\n\n        r = bus_message_new_synthetic_error(\n                        bus,\n                        c->cookie,\n                        &SD_BUS_ERROR_MAKE_CONST(SD_BUS_ERROR_NO_REPLY, \"Connection terminated\"),\n                        &m);\n        if (r < 0)\n                return r;\n\n        m->read_counter = ++bus->read_counter;\n\n        r = bus_seal_synthetic_message(bus, m);\n        if (r < 0)\n                return r;\n\n        if (c->timeout_usec != 0) {\n                prioq_remove(bus->reply_callbacks_prioq, c, &c->prioq_idx);\n                c->timeout_usec = 0;\n        }\n\n        ordered_hashmap_remove(bus->reply_callbacks, &c->cookie);\n        c->cookie = 0;\n\n        slot = container_of(c, sd_bus_slot, reply_callback);\n\n        bus->iteration_counter++;\n\n        bus->current_message = m;\n        bus->current_slot = sd_bus_slot_ref(slot);\n        bus->current_handler = c->callback;\n        bus->current_userdata = slot->userdata;\n        r = c->callback(m, slot->userdata, &error_buffer);\n        bus->current_userdata = NULL;\n        bus->current_handler = NULL;\n        bus->current_slot = NULL;\n        bus->current_message = NULL;\n\n        if (slot->floating)\n                bus_slot_disconnect(slot, true);\n\n        sd_bus_slot_unref(slot);\n\n        return bus_maybe_reply_error(m, r, &error_buffer);\n}\n\nstatic int process_closing(sd_bus *bus, sd_bus_message **ret) {\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = NULL;\n        struct reply_callback *c;\n        int r;\n\n        assert(bus);\n        assert(bus->state == BUS_CLOSING);\n\n        /* First, fail all outstanding method calls */\n        c = ordered_hashmap_first(bus->reply_callbacks);\n        if (c)\n                return process_closing_reply_callback(bus, c);\n\n        /* Then, fake-drop all remaining bus tracking references */\n        if (bus->tracks) {\n                bus_track_close(bus->tracks);\n                return 1;\n        }\n\n        /* Then, synthesize a Disconnected message */\n        r = sd_bus_message_new_signal(\n                        bus,\n                        &m,\n                        \"/org/freedesktop/DBus/Local\",\n                        \"org.freedesktop.DBus.Local\",\n                        \"Disconnected\");\n        if (r < 0)\n                return r;\n\n        bus_message_set_sender_local(bus, m);\n        m->read_counter = ++bus->read_counter;\n\n        r = bus_seal_synthetic_message(bus, m);\n        if (r < 0)\n                return r;\n\n        sd_bus_close(bus);\n\n        bus->current_message = m;\n        bus->iteration_counter++;\n\n        r = process_filter(bus, m);\n        if (r != 0)\n                goto finish;\n\n        r = process_match(bus, m);\n        if (r != 0)\n                goto finish;\n\n        /* Nothing else to do, exit now, if the condition holds */\n        bus->exit_triggered = true;\n        (void) bus_exit_now(bus);\n\n        if (ret)\n                *ret = TAKE_PTR(m);\n\n        r = 1;\n\nfinish:\n        bus->current_message = NULL;\n\n        return r;\n}\n\nstatic int bus_process_internal(sd_bus *bus, bool hint_priority, int64_t priority, sd_bus_message **ret) {\n        int r;\n\n        /* Returns 0 when we didn't do anything. This should cause the\n         * caller to invoke sd_bus_wait() before returning the next\n         * time. Returns > 0 when we did something, which possibly\n         * means *ret is filled in with an unprocessed message. */\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        /* We don't allow recursively invoking sd_bus_process(). */\n        assert_return(!bus->current_message, -EBUSY);\n        assert(!bus->current_slot); /* This should be NULL whenever bus->current_message is */\n\n        BUS_DONT_DESTROY(bus);\n\n        switch (bus->state) {\n\n        case BUS_UNSET:\n                return -ENOTCONN;\n\n        case BUS_CLOSED:\n                return -ECONNRESET;\n\n        case BUS_WATCH_BIND:\n                r = bus_socket_process_watch_bind(bus);\n                break;\n\n        case BUS_OPENING:\n                r = bus_socket_process_opening(bus);\n                break;\n\n        case BUS_AUTHENTICATING:\n                r = bus_socket_process_authenticating(bus);\n                break;\n\n        case BUS_RUNNING:\n        case BUS_HELLO:\n                r = process_running(bus, hint_priority, priority, ret);\n                if (r >= 0)\n                        return r;\n\n                /* This branch initializes *ret, hence we don't use the generic error checking below */\n                break;\n\n        case BUS_CLOSING:\n                return process_closing(bus, ret);\n\n        default:\n                assert_not_reached(\"Unknown state\");\n        }\n\n        if (ERRNO_IS_DISCONNECT(r)) {\n                bus_enter_closing(bus);\n                r = 1;\n        } else if (r < 0)\n                return r;\n\n        if (ret)\n                *ret = NULL;\n\n        return r;\n}\n\n_public_ int sd_bus_process(sd_bus *bus, sd_bus_message **ret) {\n        return bus_process_internal(bus, false, 0, ret);\n}\n\n_public_ int sd_bus_process_priority(sd_bus *bus, int64_t priority, sd_bus_message **ret) {\n        return bus_process_internal(bus, true, priority, ret);\n}\n\nstatic int bus_poll(sd_bus *bus, bool need_more, uint64_t timeout_usec) {\n        struct pollfd p[2] = {};\n        int r, n;\n        struct timespec ts;\n        usec_t m = USEC_INFINITY;\n\n        assert(bus);\n\n        if (bus->state == BUS_CLOSING)\n                return 1;\n\n        if (!BUS_IS_OPEN(bus->state))\n                return -ENOTCONN;\n\n        if (bus->state == BUS_WATCH_BIND) {\n                assert(bus->inotify_fd >= 0);\n\n                p[0].events = POLLIN;\n                p[0].fd = bus->inotify_fd;\n                n = 1;\n        } else {\n                int e;\n\n                e = sd_bus_get_events(bus);\n                if (e < 0)\n                        return e;\n\n                if (need_more)\n                        /* The caller really needs some more data, he doesn't\n                         * care about what's already read, or any timeouts\n                         * except its own. */\n                        e |= POLLIN;\n                else {\n                        usec_t until;\n                        /* The caller wants to process if there's something to\n                         * process, but doesn't care otherwise */\n\n                        r = sd_bus_get_timeout(bus, &until);\n                        if (r < 0)\n                                return r;\n                        if (r > 0)\n                                m = usec_sub_unsigned(until, now(CLOCK_MONOTONIC));\n                }\n\n                p[0].fd = bus->input_fd;\n                if (bus->output_fd == bus->input_fd) {\n                        p[0].events = e;\n                        n = 1;\n                } else {\n                        p[0].events = e & POLLIN;\n                        p[1].fd = bus->output_fd;\n                        p[1].events = e & POLLOUT;\n                        n = 2;\n                }\n        }\n\n        if (timeout_usec != (uint64_t) -1 && (m == USEC_INFINITY || timeout_usec < m))\n                m = timeout_usec;\n\n        r = ppoll(p, n, m == USEC_INFINITY ? NULL : timespec_store(&ts, m), NULL);\n        if (r < 0)\n                return -errno;\n\n        return r > 0 ? 1 : 0;\n}\n\n_public_ int sd_bus_wait(sd_bus *bus, uint64_t timeout_usec) {\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (bus->state == BUS_CLOSING)\n                return 0;\n\n        if (!BUS_IS_OPEN(bus->state))\n                return -ENOTCONN;\n\n        if (bus->rqueue_size > 0)\n                return 0;\n\n        return bus_poll(bus, false, timeout_usec);\n}\n\n_public_ int sd_bus_flush(sd_bus *bus) {\n        int r;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (bus->state == BUS_CLOSING)\n                return 0;\n\n        if (!BUS_IS_OPEN(bus->state))\n                return -ENOTCONN;\n\n        /* We never were connected? Don't hang in inotify for good, as there's no timeout set for it */\n        if (bus->state == BUS_WATCH_BIND)\n                return -EUNATCH;\n\n        r = bus_ensure_running(bus);\n        if (r < 0)\n                return r;\n\n        if (bus->wqueue_size <= 0)\n                return 0;\n\n        for (;;) {\n                r = dispatch_wqueue(bus);\n                if (r < 0) {\n                        if (ERRNO_IS_DISCONNECT(r)) {\n                                bus_enter_closing(bus);\n                                return -ECONNRESET;\n                        }\n\n                        return r;\n                }\n\n                if (bus->wqueue_size <= 0)\n                        return 0;\n\n                r = bus_poll(bus, false, (uint64_t) -1);\n                if (r < 0)\n                        return r;\n        }\n}\n\n_public_ int sd_bus_add_filter(\n                sd_bus *bus,\n                sd_bus_slot **slot,\n                sd_bus_message_handler_t callback,\n                void *userdata) {\n\n        sd_bus_slot *s;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(callback, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        s = bus_slot_allocate(bus, !slot, BUS_FILTER_CALLBACK, sizeof(struct filter_callback), userdata);\n        if (!s)\n                return -ENOMEM;\n\n        s->filter_callback.callback = callback;\n\n        bus->filter_callbacks_modified = true;\n        LIST_PREPEND(callbacks, bus->filter_callbacks, &s->filter_callback);\n\n        if (slot)\n                *slot = s;\n\n        return 0;\n}\n\nstatic int add_match_callback(\n                sd_bus_message *m,\n                void *userdata,\n                sd_bus_error *ret_error) {\n\n        sd_bus_slot *match_slot = userdata;\n        bool failed = false;\n        int r;\n\n        assert(m);\n        assert(match_slot);\n\n        sd_bus_slot_ref(match_slot);\n\n        if (sd_bus_message_is_method_error(m, NULL)) {\n                log_debug_errno(sd_bus_message_get_errno(m),\n                                \"Unable to add match %s, failing connection: %s\",\n                                match_slot->match_callback.match_string,\n                                sd_bus_message_get_error(m)->message);\n\n                failed = true;\n        } else\n                log_debug(\"Match %s successfully installed.\", match_slot->match_callback.match_string);\n\n        if (match_slot->match_callback.install_callback) {\n                sd_bus *bus;\n\n                bus = sd_bus_message_get_bus(m);\n\n                /* This function has been called as slot handler, and we want to call another slot handler. Let's\n                 * update the slot callback metadata temporarily with our own data, and then revert back to the old\n                 * values. */\n\n                assert(bus->current_slot == match_slot->match_callback.install_slot);\n                assert(bus->current_handler == add_match_callback);\n                assert(bus->current_userdata == userdata);\n\n                bus->current_slot = match_slot;\n                bus->current_handler = match_slot->match_callback.install_callback;\n                bus->current_userdata = match_slot->userdata;\n\n                r = match_slot->match_callback.install_callback(m, match_slot->userdata, ret_error);\n\n                bus->current_slot = match_slot->match_callback.install_slot;\n                bus->current_handler = add_match_callback;\n                bus->current_userdata = userdata;\n        } else {\n                if (failed) /* Generic failure handling: destroy the connection */\n                        bus_enter_closing(sd_bus_message_get_bus(m));\n\n                r = 1;\n        }\n\n        /* We don't need the install method reply slot anymore, let's free it */\n        match_slot->match_callback.install_slot = sd_bus_slot_unref(match_slot->match_callback.install_slot);\n\n        if (failed && match_slot->floating)\n                bus_slot_disconnect(match_slot, true);\n\n        sd_bus_slot_unref(match_slot);\n\n        return r;\n}\n\nstatic int bus_add_match_full(\n                sd_bus *bus,\n                sd_bus_slot **slot,\n                bool asynchronous,\n                const char *match,\n                sd_bus_message_handler_t callback,\n                sd_bus_message_handler_t install_callback,\n                void *userdata) {\n\n        struct bus_match_component *components = NULL;\n        unsigned n_components = 0;\n        sd_bus_slot *s = NULL;\n        int r = 0;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(match, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        r = bus_match_parse(match, &components, &n_components);\n        if (r < 0)\n                goto finish;\n\n        s = bus_slot_allocate(bus, !slot, BUS_MATCH_CALLBACK, sizeof(struct match_callback), userdata);\n        if (!s) {\n                r = -ENOMEM;\n                goto finish;\n        }\n\n        s->match_callback.callback = callback;\n        s->match_callback.install_callback = install_callback;\n\n        if (bus->bus_client) {\n                enum bus_match_scope scope;\n\n                scope = bus_match_get_scope(components, n_components);\n\n                /* Do not install server-side matches for matches against the local service, interface or bus path. */\n                if (scope != BUS_MATCH_LOCAL) {\n\n                        /* We store the original match string, so that we can use it to remove the match again. */\n\n                        s->match_callback.match_string = strdup(match);\n                        if (!s->match_callback.match_string) {\n                                r = -ENOMEM;\n                                goto finish;\n                        }\n\n                        if (asynchronous) {\n                                r = bus_add_match_internal_async(bus,\n                                                                 &s->match_callback.install_slot,\n                                                                 s->match_callback.match_string,\n                                                                 add_match_callback,\n                                                                 s);\n\n                                if (r < 0)\n                                        return r;\n\n                                /* Make the slot of the match call floating now. We need the reference, but we don't\n                                 * want that this match pins the bus object, hence we first create it non-floating, but\n                                 * then make it floating. */\n                                r = sd_bus_slot_set_floating(s->match_callback.install_slot, true);\n                        } else\n                                r = bus_add_match_internal(bus, s->match_callback.match_string, &s->match_callback.after);\n                        if (r < 0)\n                                goto finish;\n\n                        s->match_added = true;\n                }\n        }\n\n        bus->match_callbacks_modified = true;\n        r = bus_match_add(&bus->match_callbacks, components, n_components, &s->match_callback);\n        if (r < 0)\n                goto finish;\n\n        if (slot)\n                *slot = s;\n        s = NULL;\n\nfinish:\n        bus_match_parse_free(components, n_components);\n        sd_bus_slot_unref(s);\n\n        return r;\n}\n\n_public_ int sd_bus_add_match(\n                sd_bus *bus,\n                sd_bus_slot **slot,\n                const char *match,\n                sd_bus_message_handler_t callback,\n                void *userdata) {\n\n        return bus_add_match_full(bus, slot, false, match, callback, NULL, userdata);\n}\n\n_public_ int sd_bus_add_match_async(\n                sd_bus *bus,\n                sd_bus_slot **slot,\n                const char *match,\n                sd_bus_message_handler_t callback,\n                sd_bus_message_handler_t install_callback,\n                void *userdata) {\n\n        return bus_add_match_full(bus, slot, true, match, callback, install_callback, userdata);\n}\n\nbool bus_pid_changed(sd_bus *bus) {\n        assert(bus);\n\n        /* We don't support people creating a bus connection and\n         * keeping it around over a fork(). Let's complain. */\n\n        return bus->original_pid != getpid_cached();\n}\n\nstatic int io_callback(sd_event_source *s, int fd, uint32_t revents, void *userdata) {\n        sd_bus *bus = userdata;\n        int r;\n\n        assert(bus);\n\n        /* Note that this is called both on input_fd, output_fd as well as inotify_fd events */\n\n        r = sd_bus_process(bus, NULL);\n        if (r < 0) {\n                log_debug_errno(r, \"Processing of bus failed, closing down: %m\");\n                bus_enter_closing(bus);\n        }\n\n        return 1;\n}\n\nstatic int time_callback(sd_event_source *s, uint64_t usec, void *userdata) {\n        sd_bus *bus = userdata;\n        int r;\n\n        assert(bus);\n\n        r = sd_bus_process(bus, NULL);\n        if (r < 0) {\n                log_debug_errno(r, \"Processing of bus failed, closing down: %m\");\n                bus_enter_closing(bus);\n        }\n\n        return 1;\n}\n\nstatic int prepare_callback(sd_event_source *s, void *userdata) {\n        sd_bus *bus = userdata;\n        int r, e;\n        usec_t until;\n\n        assert(s);\n        assert(bus);\n\n        e = sd_bus_get_events(bus);\n        if (e < 0) {\n                r = e;\n                goto fail;\n        }\n\n        if (bus->output_fd != bus->input_fd) {\n\n                r = sd_event_source_set_io_events(bus->input_io_event_source, e & POLLIN);\n                if (r < 0)\n                        goto fail;\n\n                r = sd_event_source_set_io_events(bus->output_io_event_source, e & POLLOUT);\n        } else\n                r = sd_event_source_set_io_events(bus->input_io_event_source, e);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_get_timeout(bus, &until);\n        if (r < 0)\n                goto fail;\n        if (r > 0) {\n                int j;\n\n                j = sd_event_source_set_time(bus->time_event_source, until);\n                if (j < 0) {\n                        r = j;\n                        goto fail;\n                }\n        }\n\n        r = sd_event_source_set_enabled(bus->time_event_source, r > 0);\n        if (r < 0)\n                goto fail;\n\n        return 1;\n\nfail:\n        log_debug_errno(r, \"Preparing of bus events failed, closing down: %m\");\n        bus_enter_closing(bus);\n\n        return 1;\n}\n\nstatic int quit_callback(sd_event_source *event, void *userdata) {\n        sd_bus *bus = userdata;\n\n        assert(event);\n\n        if (bus->close_on_exit) {\n                sd_bus_flush(bus);\n                sd_bus_close(bus);\n        }\n\n        return 1;\n}\n\nint bus_attach_io_events(sd_bus *bus) {\n        int r;\n\n        assert(bus);\n\n        if (bus->input_fd < 0)\n                return 0;\n\n        if (!bus->event)\n                return 0;\n\n        if (!bus->input_io_event_source) {\n                r = sd_event_add_io(bus->event, &bus->input_io_event_source, bus->input_fd, 0, io_callback, bus);\n                if (r < 0)\n                        return r;\n\n                r = sd_event_source_set_prepare(bus->input_io_event_source, prepare_callback);\n                if (r < 0)\n                        return r;\n\n                r = sd_event_source_set_priority(bus->input_io_event_source, bus->event_priority);\n                if (r < 0)\n                        return r;\n\n                r = sd_event_source_set_description(bus->input_io_event_source, \"bus-input\");\n        } else\n                r = sd_event_source_set_io_fd(bus->input_io_event_source, bus->input_fd);\n\n        if (r < 0)\n                return r;\n\n        if (bus->output_fd != bus->input_fd) {\n                assert(bus->output_fd >= 0);\n\n                if (!bus->output_io_event_source) {\n                        r = sd_event_add_io(bus->event, &bus->output_io_event_source, bus->output_fd, 0, io_callback, bus);\n                        if (r < 0)\n                                return r;\n\n                        r = sd_event_source_set_priority(bus->output_io_event_source, bus->event_priority);\n                        if (r < 0)\n                                return r;\n\n                        r = sd_event_source_set_description(bus->input_io_event_source, \"bus-output\");\n                } else\n                        r = sd_event_source_set_io_fd(bus->output_io_event_source, bus->output_fd);\n\n                if (r < 0)\n                        return r;\n        }\n\n        return 0;\n}\n\nstatic void bus_detach_io_events(sd_bus *bus) {\n        assert(bus);\n\n        if (bus->input_io_event_source) {\n                sd_event_source_set_enabled(bus->input_io_event_source, SD_EVENT_OFF);\n                bus->input_io_event_source = sd_event_source_unref(bus->input_io_event_source);\n        }\n\n        if (bus->output_io_event_source) {\n                sd_event_source_set_enabled(bus->output_io_event_source, SD_EVENT_OFF);\n                bus->output_io_event_source = sd_event_source_unref(bus->output_io_event_source);\n        }\n}\n\nint bus_attach_inotify_event(sd_bus *bus) {\n        int r;\n\n        assert(bus);\n\n        if (bus->inotify_fd < 0)\n                return 0;\n\n        if (!bus->event)\n                return 0;\n\n        if (!bus->inotify_event_source) {\n                r = sd_event_add_io(bus->event, &bus->inotify_event_source, bus->inotify_fd, EPOLLIN, io_callback, bus);\n                if (r < 0)\n                        return r;\n\n                r = sd_event_source_set_priority(bus->inotify_event_source, bus->event_priority);\n                if (r < 0)\n                        return r;\n\n                r = sd_event_source_set_description(bus->inotify_event_source, \"bus-inotify\");\n        } else\n                r = sd_event_source_set_io_fd(bus->inotify_event_source, bus->inotify_fd);\n        if (r < 0)\n                return r;\n\n        return 0;\n}\n\nstatic void bus_detach_inotify_event(sd_bus *bus) {\n        assert(bus);\n\n        if (bus->inotify_event_source) {\n                sd_event_source_set_enabled(bus->inotify_event_source, SD_EVENT_OFF);\n                bus->inotify_event_source = sd_event_source_unref(bus->inotify_event_source);\n        }\n}\n\n_public_ int sd_bus_attach_event(sd_bus *bus, sd_event *event, int priority) {\n        int r;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus->event, -EBUSY);\n\n        assert(!bus->input_io_event_source);\n        assert(!bus->output_io_event_source);\n        assert(!bus->time_event_source);\n\n        if (event)\n                bus->event = sd_event_ref(event);\n        else  {\n                r = sd_event_default(&bus->event);\n                if (r < 0)\n                        return r;\n        }\n\n        bus->event_priority = priority;\n\n        r = sd_event_add_time(bus->event, &bus->time_event_source, CLOCK_MONOTONIC, 0, 0, time_callback, bus);\n        if (r < 0)\n                goto fail;\n\n        r = sd_event_source_set_priority(bus->time_event_source, priority);\n        if (r < 0)\n                goto fail;\n\n        r = sd_event_source_set_description(bus->time_event_source, \"bus-time\");\n        if (r < 0)\n                goto fail;\n\n        r = sd_event_add_exit(bus->event, &bus->quit_event_source, quit_callback, bus);\n        if (r < 0)\n                goto fail;\n\n        r = sd_event_source_set_description(bus->quit_event_source, \"bus-exit\");\n        if (r < 0)\n                goto fail;\n\n        r = bus_attach_io_events(bus);\n        if (r < 0)\n                goto fail;\n\n        r = bus_attach_inotify_event(bus);\n        if (r < 0)\n                goto fail;\n\n        return 0;\n\nfail:\n        sd_bus_detach_event(bus);\n        return r;\n}\n\n_public_ int sd_bus_detach_event(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n\n        if (!bus->event)\n                return 0;\n\n        bus_detach_io_events(bus);\n        bus_detach_inotify_event(bus);\n\n        if (bus->time_event_source) {\n                sd_event_source_set_enabled(bus->time_event_source, SD_EVENT_OFF);\n                bus->time_event_source = sd_event_source_unref(bus->time_event_source);\n        }\n\n        if (bus->quit_event_source) {\n                sd_event_source_set_enabled(bus->quit_event_source, SD_EVENT_OFF);\n                bus->quit_event_source = sd_event_source_unref(bus->quit_event_source);\n        }\n\n        bus->event = sd_event_unref(bus->event);\n        return 1;\n}\n\n_public_ sd_event* sd_bus_get_event(sd_bus *bus) {\n        assert_return(bus, NULL);\n\n        return bus->event;\n}\n\n_public_ sd_bus_message* sd_bus_get_current_message(sd_bus *bus) {\n        assert_return(bus, NULL);\n\n        return bus->current_message;\n}\n\n_public_ sd_bus_slot* sd_bus_get_current_slot(sd_bus *bus) {\n        assert_return(bus, NULL);\n\n        return bus->current_slot;\n}\n\n_public_ sd_bus_message_handler_t sd_bus_get_current_handler(sd_bus *bus) {\n        assert_return(bus, NULL);\n\n        return bus->current_handler;\n}\n\n_public_ void* sd_bus_get_current_userdata(sd_bus *bus) {\n        assert_return(bus, NULL);\n\n        return bus->current_userdata;\n}\n\nstatic int bus_default(int (*bus_open)(sd_bus **), sd_bus **default_bus, sd_bus **ret) {\n        sd_bus *b = NULL;\n        int r;\n\n        assert(bus_open);\n        assert(default_bus);\n\n        if (!ret)\n                return !!*default_bus;\n\n        if (*default_bus) {\n                *ret = sd_bus_ref(*default_bus);\n                return 0;\n        }\n\n        r = bus_open(&b);\n        if (r < 0)\n                return r;\n\n        b->default_bus_ptr = default_bus;\n        b->tid = gettid();\n        *default_bus = b;\n\n        *ret = b;\n        return 1;\n}\n\n_public_ int sd_bus_default_system(sd_bus **ret) {\n        return bus_default(sd_bus_open_system, &default_system_bus, ret);\n}\n\n_public_ int sd_bus_default_user(sd_bus **ret) {\n        return bus_default(sd_bus_open_user, &default_user_bus, ret);\n}\n\n_public_ int sd_bus_default(sd_bus **ret) {\n        int (*bus_open)(sd_bus **) = NULL;\n        sd_bus **busp;\n\n        busp = bus_choose_default(&bus_open);\n        return bus_default(bus_open, busp, ret);\n}\n\n_public_ int sd_bus_get_tid(sd_bus *b, pid_t *tid) {\n        assert_return(b, -EINVAL);\n        assert_return(tid, -EINVAL);\n        assert_return(!bus_pid_changed(b), -ECHILD);\n\n        if (b->tid != 0) {\n                *tid = b->tid;\n                return 0;\n        }\n\n        if (b->event)\n                return sd_event_get_tid(b->event, tid);\n\n        return -ENXIO;\n}\n\n_public_ int sd_bus_path_encode(const char *prefix, const char *external_id, char **ret_path) {\n        _cleanup_free_ char *e = NULL;\n        char *ret;\n\n        assert_return(object_path_is_valid(prefix), -EINVAL);\n        assert_return(external_id, -EINVAL);\n        assert_return(ret_path, -EINVAL);\n\n        e = bus_label_escape(external_id);\n        if (!e)\n                return -ENOMEM;\n\n        ret = path_join(prefix, e);\n        if (!ret)\n                return -ENOMEM;\n\n        *ret_path = ret;\n        return 0;\n}\n\n_public_ int sd_bus_path_decode(const char *path, const char *prefix, char **external_id) {\n        const char *e;\n        char *ret;\n\n        assert_return(object_path_is_valid(path), -EINVAL);\n        assert_return(object_path_is_valid(prefix), -EINVAL);\n        assert_return(external_id, -EINVAL);\n\n        e = object_path_startswith(path, prefix);\n        if (!e) {\n                *external_id = NULL;\n                return 0;\n        }\n\n        ret = bus_label_unescape(e);\n        if (!ret)\n                return -ENOMEM;\n\n        *external_id = ret;\n        return 1;\n}\n\n_public_ int sd_bus_path_encode_many(char **out, const char *path_template, ...) {\n        _cleanup_strv_free_ char **labels = NULL;\n        char *path, *path_pos, **label_pos;\n        const char *sep, *template_pos;\n        size_t path_length;\n        va_list list;\n        int r;\n\n        assert_return(out, -EINVAL);\n        assert_return(path_template, -EINVAL);\n\n        path_length = strlen(path_template);\n\n        va_start(list, path_template);\n        for (sep = strchr(path_template, '%'); sep; sep = strchr(sep + 1, '%')) {\n                const char *arg;\n                char *label;\n\n                arg = va_arg(list, const char *);\n                if (!arg) {\n                        va_end(list);\n                        return -EINVAL;\n                }\n\n                label = bus_label_escape(arg);\n                if (!label) {\n                        va_end(list);\n                        return -ENOMEM;\n                }\n\n                r = strv_consume(&labels, label);\n                if (r < 0) {\n                        va_end(list);\n                        return r;\n                }\n\n                /* add label length, but account for the format character */\n                path_length += strlen(label) - 1;\n        }\n        va_end(list);\n\n        path = malloc(path_length + 1);\n        if (!path)\n                return -ENOMEM;\n\n        path_pos = path;\n        label_pos = labels;\n\n        for (template_pos = path_template; *template_pos; ) {\n                sep = strchrnul(template_pos, '%');\n                path_pos = mempcpy(path_pos, template_pos, sep - template_pos);\n                if (!*sep)\n                        break;\n\n                path_pos = stpcpy(path_pos, *label_pos++);\n                template_pos = sep + 1;\n        }\n\n        *path_pos = 0;\n        *out = path;\n        return 0;\n}\n\n_public_ int sd_bus_path_decode_many(const char *path, const char *path_template, ...) {\n        _cleanup_strv_free_ char **labels = NULL;\n        const char *template_pos, *path_pos;\n        char **label_pos;\n        va_list list;\n        int r;\n\n        /*\n         * This decodes an object-path based on a template argument. The\n         * template consists of a verbatim path, optionally including special\n         * directives:\n         *\n         *   - Each occurrence of '%' in the template matches an arbitrary\n         *     substring of a label in the given path. At most one such\n         *     directive is allowed per label. For each such directive, the\n         *     caller must provide an output parameter (char **) via va_arg. If\n         *     NULL is passed, the given label is verified, but not returned.\n         *     For each matched label, the *decoded* label is stored in the\n         *     passed output argument, and the caller is responsible to free\n         *     it. Note that the output arguments are only modified if the\n         *     actually path matched the template. Otherwise, they're left\n         *     untouched.\n         *\n         * This function returns <0 on error, 0 if the path does not match the\n         * template, 1 if it matched.\n         */\n\n        assert_return(path, -EINVAL);\n        assert_return(path_template, -EINVAL);\n\n        path_pos = path;\n\n        for (template_pos = path_template; *template_pos; ) {\n                const char *sep;\n                size_t length;\n                char *label;\n\n                /* verify everything until the next '%' matches verbatim */\n                sep = strchrnul(template_pos, '%');\n                length = sep - template_pos;\n                if (strncmp(path_pos, template_pos, length))\n                        return 0;\n\n                path_pos += length;\n                template_pos += length;\n\n                if (!*template_pos)\n                        break;\n\n                /* We found the next '%' character. Everything up until here\n                 * matched. We now skip ahead to the end of this label and make\n                 * sure it matches the tail of the label in the path. Then we\n                 * decode the string in-between and save it for later use. */\n\n                ++template_pos; /* skip over '%' */\n\n                sep = strchrnul(template_pos, '/');\n                length = sep - template_pos; /* length of suffix to match verbatim */\n\n                /* verify the suffixes match */\n                sep = strchrnul(path_pos, '/');\n                if (sep - path_pos < (ssize_t)length ||\n                    strncmp(sep - length, template_pos, length))\n                        return 0;\n\n                template_pos += length; /* skip over matched label */\n                length = sep - path_pos - length; /* length of sub-label to decode */\n\n                /* store unescaped label for later use */\n                label = bus_label_unescape_n(path_pos, length);\n                if (!label)\n                        return -ENOMEM;\n\n                r = strv_consume(&labels, label);\n                if (r < 0)\n                        return r;\n\n                path_pos = sep; /* skip decoded label and suffix */\n        }\n\n        /* end of template must match end of path */\n        if (*path_pos)\n                return 0;\n\n        /* copy the labels over to the caller */\n        va_start(list, path_template);\n        for (label_pos = labels; label_pos && *label_pos; ++label_pos) {\n                char **arg;\n\n                arg = va_arg(list, char **);\n                if (arg)\n                        *arg = *label_pos;\n                else\n                        free(*label_pos);\n        }\n        va_end(list);\n\n        labels = mfree(labels);\n        return 1;\n}\n\n_public_ int sd_bus_try_close(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return -EOPNOTSUPP;\n}\n\n_public_ int sd_bus_get_description(sd_bus *bus, const char **description) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(description, -EINVAL);\n        assert_return(bus->description, -ENXIO);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (bus->description)\n                *description = bus->description;\n        else if (bus->is_system)\n                *description = \"system\";\n        else if (bus->is_user)\n                *description = \"user\";\n        else\n                *description = NULL;\n\n        return 0;\n}\n\n_public_ int sd_bus_get_scope(sd_bus *bus, const char **scope) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(scope, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (bus->is_user) {\n                *scope = \"user\";\n                return 0;\n        }\n\n        if (bus->is_system) {\n                *scope = \"system\";\n                return 0;\n        }\n\n        return -ENODATA;\n}\n\n_public_ int sd_bus_get_address(sd_bus *bus, const char **address) {\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(address, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (bus->address) {\n                *address = bus->address;\n                return 0;\n        }\n\n        return -ENODATA;\n}\n\n_public_ int sd_bus_get_creds_mask(sd_bus *bus, uint64_t *mask) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(mask, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        *mask = bus->creds_mask;\n        return 0;\n}\n\n_public_ int sd_bus_is_bus_client(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return bus->bus_client;\n}\n\n_public_ int sd_bus_is_server(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return bus->is_server;\n}\n\n_public_ int sd_bus_is_anonymous(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return bus->anonymous_auth;\n}\n\n_public_ int sd_bus_is_trusted(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return bus->trusted;\n}\n\n_public_ int sd_bus_is_monitor(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return bus->is_monitor;\n}\n\nstatic void flush_close(sd_bus *bus) {\n        if (!bus)\n                return;\n\n        /* Flushes and closes the specified bus. We take a ref before,\n         * to ensure the flushing does not cause the bus to be\n         * unreferenced. */\n\n        sd_bus_flush_close_unref(sd_bus_ref(bus));\n}\n\n_public_ void sd_bus_default_flush_close(void) {\n        flush_close(default_starter_bus);\n        flush_close(default_user_bus);\n        flush_close(default_system_bus);\n}\n\n_public_ int sd_bus_set_exit_on_disconnect(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n\n        /* Turns on exit-on-disconnect, and triggers it immediately if the bus connection was already\n         * disconnected. Note that this is triggered exclusively on disconnections triggered by the server side, never\n         * from the client side. */\n        bus->exit_on_disconnect = b;\n\n        /* If the exit condition was triggered already, exit immediately. */\n        return bus_exit_now(bus);\n}\n\n_public_ int sd_bus_get_exit_on_disconnect(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n\n        return bus->exit_on_disconnect;\n}\n\n_public_ int sd_bus_set_sender(sd_bus *bus, const char *sender) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus->bus_client, -EPERM);\n        assert_return(!sender || service_name_is_valid(sender), -EINVAL);\n\n        return free_and_strdup(&bus->patch_sender, sender);\n}\n\n_public_ int sd_bus_get_sender(sd_bus *bus, const char **ret) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(ret, -EINVAL);\n\n        if (!bus->patch_sender)\n                return -ENODATA;\n\n        *ret = bus->patch_sender;\n        return 0;\n}\n\n_public_ int sd_bus_get_n_queued_read(sd_bus *bus, uint64_t *ret) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n        assert_return(ret, -EINVAL);\n\n        *ret = bus->rqueue_size;\n        return 0;\n}\n\n_public_ int sd_bus_get_n_queued_write(sd_bus *bus, uint64_t *ret) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n        assert_return(ret, -EINVAL);\n\n        *ret = bus->wqueue_size;\n        return 0;\n}\n\n_public_ int sd_bus_set_method_call_timeout(sd_bus *bus, uint64_t usec) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n\n        bus->method_call_timeout = usec;\n        return 0;\n}\n\n_public_ int sd_bus_get_method_call_timeout(sd_bus *bus, uint64_t *ret) {\n        const char *e;\n        usec_t usec;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(ret, -EINVAL);\n\n        if (bus->method_call_timeout != 0) {\n                *ret = bus->method_call_timeout;\n                return 0;\n        }\n\n        e = secure_getenv(\"SYSTEMD_BUS_TIMEOUT\");\n        if (e && parse_sec(e, &usec) >= 0 && usec != 0) {\n                /* Save the parsed value to avoid multiple parsing. To change the timeout value,\n                 * use sd_bus_set_method_call_timeout() instead of setenv(). */\n                *ret = bus->method_call_timeout = usec;\n                return 0;\n        }\n\n        *ret = bus->method_call_timeout = BUS_DEFAULT_TIMEOUT;\n        return 0;\n}\n\n_public_ int sd_bus_set_close_on_exit(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n\n        bus->close_on_exit = b;\n        return 0;\n}\n\n_public_ int sd_bus_get_close_on_exit(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n\n        return bus->close_on_exit;\n}\n", "/* SPDX-License-Identifier: LGPL-2.1+ */\n#ifndef foosdbushfoo\n#define foosdbushfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <http://www.gnu.org/licenses/>.\n***/\n\n#include <inttypes.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n\n#include \"sd-event.h\"\n#include \"sd-id128.h\"\n\n#include \"_sd-common.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\n#define SD_BUS_DEFAULT ((sd_bus *) 1)\n#define SD_BUS_DEFAULT_USER ((sd_bus *) 2)\n#define SD_BUS_DEFAULT_SYSTEM ((sd_bus *) 3)\n\n/* https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-marshaling-signature */\n#define SD_BUS_MAXIMUM_SIGNATURE_LENGTH 255\n\n/* https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names */\n#define SD_BUS_MAXIMUM_NAME_LENGTH 255\n\n/* Types */\n\ntypedef struct sd_bus sd_bus;\ntypedef struct sd_bus_message sd_bus_message;\ntypedef struct sd_bus_slot sd_bus_slot;\ntypedef struct sd_bus_creds sd_bus_creds;\ntypedef struct sd_bus_track sd_bus_track;\n\ntypedef struct {\n        const char *name;\n        const char *message;\n        int _need_free;\n} sd_bus_error;\n\ntypedef struct {\n        const char* name;\n        int code;\n} sd_bus_error_map;\n\n/* Flags */\n\nenum {\n        SD_BUS_CREDS_PID                = 1ULL << 0,\n        SD_BUS_CREDS_TID                = 1ULL << 1,\n        SD_BUS_CREDS_PPID               = 1ULL << 2,\n        SD_BUS_CREDS_UID                = 1ULL << 3,\n        SD_BUS_CREDS_EUID               = 1ULL << 4,\n        SD_BUS_CREDS_SUID               = 1ULL << 5,\n        SD_BUS_CREDS_FSUID              = 1ULL << 6,\n        SD_BUS_CREDS_GID                = 1ULL << 7,\n        SD_BUS_CREDS_EGID               = 1ULL << 8,\n        SD_BUS_CREDS_SGID               = 1ULL << 9,\n        SD_BUS_CREDS_FSGID              = 1ULL << 10,\n        SD_BUS_CREDS_SUPPLEMENTARY_GIDS = 1ULL << 11,\n        SD_BUS_CREDS_COMM               = 1ULL << 12,\n        SD_BUS_CREDS_TID_COMM           = 1ULL << 13,\n        SD_BUS_CREDS_EXE                = 1ULL << 14,\n        SD_BUS_CREDS_CMDLINE            = 1ULL << 15,\n        SD_BUS_CREDS_CGROUP             = 1ULL << 16,\n        SD_BUS_CREDS_UNIT               = 1ULL << 17,\n        SD_BUS_CREDS_SLICE              = 1ULL << 18,\n        SD_BUS_CREDS_USER_UNIT          = 1ULL << 19,\n        SD_BUS_CREDS_USER_SLICE         = 1ULL << 20,\n        SD_BUS_CREDS_SESSION            = 1ULL << 21,\n        SD_BUS_CREDS_OWNER_UID          = 1ULL << 22,\n        SD_BUS_CREDS_EFFECTIVE_CAPS     = 1ULL << 23,\n        SD_BUS_CREDS_PERMITTED_CAPS     = 1ULL << 24,\n        SD_BUS_CREDS_INHERITABLE_CAPS   = 1ULL << 25,\n        SD_BUS_CREDS_BOUNDING_CAPS      = 1ULL << 26,\n        SD_BUS_CREDS_SELINUX_CONTEXT    = 1ULL << 27,\n        SD_BUS_CREDS_AUDIT_SESSION_ID   = 1ULL << 28,\n        SD_BUS_CREDS_AUDIT_LOGIN_UID    = 1ULL << 29,\n        SD_BUS_CREDS_TTY                = 1ULL << 30,\n        SD_BUS_CREDS_UNIQUE_NAME        = 1ULL << 31,\n        SD_BUS_CREDS_WELL_KNOWN_NAMES   = 1ULL << 32,\n        SD_BUS_CREDS_DESCRIPTION        = 1ULL << 33,\n        SD_BUS_CREDS_AUGMENT            = 1ULL << 63, /* special flag, if on sd-bus will augment creds struct, in a potentially race-full way. */\n        _SD_BUS_CREDS_ALL               = (1ULL << 34) -1\n};\n\nenum {\n        SD_BUS_NAME_REPLACE_EXISTING  = 1ULL << 0,\n        SD_BUS_NAME_ALLOW_REPLACEMENT = 1ULL << 1,\n        SD_BUS_NAME_QUEUE             = 1ULL << 2\n};\n\nenum {\n        SD_BUS_MESSAGE_DUMP_WITH_HEADER  = 1ULL << 0,\n        SD_BUS_MESSAGE_DUMP_SUBTREE_ONLY = 1ULL << 1,\n};\n\n/* Callbacks */\n\ntypedef int (*sd_bus_message_handler_t)(sd_bus_message *m, void *userdata, sd_bus_error *ret_error);\ntypedef int (*sd_bus_property_get_t) (sd_bus *bus, const char *path, const char *interface, const char *property, sd_bus_message *reply, void *userdata, sd_bus_error *ret_error);\ntypedef int (*sd_bus_property_set_t) (sd_bus *bus, const char *path, const char *interface, const char *property, sd_bus_message *value, void *userdata, sd_bus_error *ret_error);\ntypedef int (*sd_bus_object_find_t) (sd_bus *bus, const char *path, const char *interface, void *userdata, void **ret_found, sd_bus_error *ret_error);\ntypedef int (*sd_bus_node_enumerator_t) (sd_bus *bus, const char *prefix, void *userdata, char ***ret_nodes, sd_bus_error *ret_error);\ntypedef int (*sd_bus_track_handler_t) (sd_bus_track *track, void *userdata);\ntypedef _sd_destroy_t sd_bus_destroy_t;\n\n#include \"sd-bus-protocol.h\"\n#include \"sd-bus-vtable.h\"\n\n/* Connections */\n\nint sd_bus_default(sd_bus **ret);\nint sd_bus_default_user(sd_bus **ret);\nint sd_bus_default_system(sd_bus **ret);\n\nint sd_bus_open(sd_bus **ret);\nint sd_bus_open_with_description(sd_bus **ret, const char *description);\nint sd_bus_open_user(sd_bus **ret);\nint sd_bus_open_user_with_description(sd_bus **ret, const char *description);\nint sd_bus_open_system(sd_bus **ret);\nint sd_bus_open_system_with_description(sd_bus **ret, const char *description);\nint sd_bus_open_system_remote(sd_bus **ret, const char *host);\nint sd_bus_open_system_machine(sd_bus **ret, const char *machine);\n\nint sd_bus_new(sd_bus **ret);\n\nint sd_bus_set_address(sd_bus *bus, const char *address);\nint sd_bus_set_fd(sd_bus *bus, int input_fd, int output_fd);\nint sd_bus_set_exec(sd_bus *bus, const char *path, char *const argv[]);\nint sd_bus_get_address(sd_bus *bus, const char **address);\nint sd_bus_set_bus_client(sd_bus *bus, int b);\nint sd_bus_is_bus_client(sd_bus *bus);\nint sd_bus_set_server(sd_bus *bus, int b, sd_id128_t bus_id);\nint sd_bus_is_server(sd_bus *bus);\nint sd_bus_set_anonymous(sd_bus *bus, int b);\nint sd_bus_is_anonymous(sd_bus *bus);\nint sd_bus_set_trusted(sd_bus *bus, int b);\nint sd_bus_is_trusted(sd_bus *bus);\nint sd_bus_set_monitor(sd_bus *bus, int b);\nint sd_bus_is_monitor(sd_bus *bus);\nint sd_bus_set_description(sd_bus *bus, const char *description);\nint sd_bus_get_description(sd_bus *bus, const char **description);\nint sd_bus_negotiate_creds(sd_bus *bus, int b, uint64_t creds_mask);\nint sd_bus_negotiate_timestamp(sd_bus *bus, int b);\nint sd_bus_negotiate_fds(sd_bus *bus, int b);\nint sd_bus_can_send(sd_bus *bus, char type);\nint sd_bus_get_creds_mask(sd_bus *bus, uint64_t *creds_mask);\nint sd_bus_set_allow_interactive_authorization(sd_bus *bus, int b);\nint sd_bus_get_allow_interactive_authorization(sd_bus *bus);\nint sd_bus_set_exit_on_disconnect(sd_bus *bus, int b);\nint sd_bus_get_exit_on_disconnect(sd_bus *bus);\nint sd_bus_set_close_on_exit(sd_bus *bus, int b);\nint sd_bus_get_close_on_exit(sd_bus *bus);\nint sd_bus_set_watch_bind(sd_bus *bus, int b);\nint sd_bus_get_watch_bind(sd_bus *bus);\nint sd_bus_set_connected_signal(sd_bus *bus, int b);\nint sd_bus_get_connected_signal(sd_bus *bus);\nint sd_bus_set_sender(sd_bus *bus, const char *sender);\nint sd_bus_get_sender(sd_bus *bus, const char **ret);\n\nint sd_bus_start(sd_bus *bus);\n\nint sd_bus_try_close(sd_bus *bus);\nvoid sd_bus_close(sd_bus *bus);\n\nsd_bus *sd_bus_ref(sd_bus *bus);\nsd_bus *sd_bus_unref(sd_bus *bus);\nsd_bus *sd_bus_close_unref(sd_bus *bus);\nsd_bus *sd_bus_flush_close_unref(sd_bus *bus);\n\nvoid sd_bus_default_flush_close(void);\n\nint sd_bus_is_open(sd_bus *bus);\nint sd_bus_is_ready(sd_bus *bus);\n\nint sd_bus_get_bus_id(sd_bus *bus, sd_id128_t *id);\nint sd_bus_get_scope(sd_bus *bus, const char **scope);\nint sd_bus_get_tid(sd_bus *bus, pid_t *tid);\nint sd_bus_get_owner_creds(sd_bus *bus, uint64_t creds_mask, sd_bus_creds **ret);\n\nint sd_bus_send(sd_bus *bus, sd_bus_message *m, uint64_t *cookie);\nint sd_bus_send_to(sd_bus *bus, sd_bus_message *m, const char *destination, uint64_t *cookie);\nint sd_bus_call(sd_bus *bus, sd_bus_message *m, uint64_t usec, sd_bus_error *ret_error, sd_bus_message **reply);\nint sd_bus_call_async(sd_bus *bus, sd_bus_slot **slot, sd_bus_message *m, sd_bus_message_handler_t callback, void *userdata, uint64_t usec);\n\nint sd_bus_get_fd(sd_bus *bus);\nint sd_bus_get_events(sd_bus *bus);\nint sd_bus_get_timeout(sd_bus *bus, uint64_t *timeout_usec);\nint sd_bus_process(sd_bus *bus, sd_bus_message **r);\nint sd_bus_process_priority(sd_bus *bus, int64_t max_priority, sd_bus_message **r);\nint sd_bus_wait(sd_bus *bus, uint64_t timeout_usec);\nint sd_bus_flush(sd_bus *bus);\n\nsd_bus_slot* sd_bus_get_current_slot(sd_bus *bus);\nsd_bus_message* sd_bus_get_current_message(sd_bus *bus);\nsd_bus_message_handler_t sd_bus_get_current_handler(sd_bus *bus);\nvoid* sd_bus_get_current_userdata(sd_bus *bus);\n\nint sd_bus_attach_event(sd_bus *bus, sd_event *e, int priority);\nint sd_bus_detach_event(sd_bus *bus);\nsd_event *sd_bus_get_event(sd_bus *bus);\n\nint sd_bus_get_n_queued_read(sd_bus *bus, uint64_t *ret);\nint sd_bus_get_n_queued_write(sd_bus *bus, uint64_t *ret);\n\nint sd_bus_set_method_call_timeout(sd_bus *bus, uint64_t usec);\nint sd_bus_get_method_call_timeout(sd_bus *bus, uint64_t *ret);\n\nint sd_bus_add_filter(sd_bus *bus, sd_bus_slot **slot, sd_bus_message_handler_t callback, void *userdata);\nint sd_bus_add_match(sd_bus *bus, sd_bus_slot **slot, const char *match, sd_bus_message_handler_t callback, void *userdata);\nint sd_bus_add_match_async(sd_bus *bus, sd_bus_slot **slot, const char *match, sd_bus_message_handler_t callback, sd_bus_message_handler_t install_callback, void *userdata);\nint sd_bus_add_object(sd_bus *bus, sd_bus_slot **slot, const char *path, sd_bus_message_handler_t callback, void *userdata);\nint sd_bus_add_fallback(sd_bus *bus, sd_bus_slot **slot, const char *prefix, sd_bus_message_handler_t callback, void *userdata);\nint sd_bus_add_object_vtable(sd_bus *bus, sd_bus_slot **slot, const char *path, const char *interface, const sd_bus_vtable *vtable, void *userdata);\nint sd_bus_add_fallback_vtable(sd_bus *bus, sd_bus_slot **slot, const char *prefix, const char *interface, const sd_bus_vtable *vtable, sd_bus_object_find_t find, void *userdata);\nint sd_bus_add_node_enumerator(sd_bus *bus, sd_bus_slot **slot, const char *path, sd_bus_node_enumerator_t callback, void *userdata);\nint sd_bus_add_object_manager(sd_bus *bus, sd_bus_slot **slot, const char *path);\n\n/* Slot object */\n\nsd_bus_slot* sd_bus_slot_ref(sd_bus_slot *slot);\nsd_bus_slot* sd_bus_slot_unref(sd_bus_slot *slot);\n\nsd_bus* sd_bus_slot_get_bus(sd_bus_slot *slot);\nvoid *sd_bus_slot_get_userdata(sd_bus_slot *slot);\nvoid *sd_bus_slot_set_userdata(sd_bus_slot *slot, void *userdata);\nint sd_bus_slot_set_description(sd_bus_slot *slot, const char *description);\nint sd_bus_slot_get_description(sd_bus_slot *slot, const char **description);\nint sd_bus_slot_get_floating(sd_bus_slot *slot);\nint sd_bus_slot_set_floating(sd_bus_slot *slot, int b);\nint sd_bus_slot_set_destroy_callback(sd_bus_slot *s, sd_bus_destroy_t callback);\nint sd_bus_slot_get_destroy_callback(sd_bus_slot *s, sd_bus_destroy_t *callback);\n\nsd_bus_message* sd_bus_slot_get_current_message(sd_bus_slot *slot);\nsd_bus_message_handler_t sd_bus_slot_get_current_handler(sd_bus_slot *slot);\nvoid *sd_bus_slot_get_current_userdata(sd_bus_slot *slot);\n\n/* Message object */\n\nint sd_bus_message_new(sd_bus *bus, sd_bus_message **m, uint8_t type);\nint sd_bus_message_new_signal(sd_bus *bus, sd_bus_message **m, const char *path, const char *interface, const char *member);\nint sd_bus_message_new_method_call(sd_bus *bus, sd_bus_message **m, const char *destination, const char *path, const char *interface, const char *member);\nint sd_bus_message_new_method_return(sd_bus_message *call, sd_bus_message **m);\nint sd_bus_message_new_method_error(sd_bus_message *call, sd_bus_message **m, const sd_bus_error *e);\nint sd_bus_message_new_method_errorf(sd_bus_message *call, sd_bus_message **m, const char *name, const char *format, ...) _sd_printf_(4, 5);\nint sd_bus_message_new_method_errno(sd_bus_message *call, sd_bus_message **m, int error, const sd_bus_error *e);\nint sd_bus_message_new_method_errnof(sd_bus_message *call, sd_bus_message **m, int error, const char *format, ...) _sd_printf_(4, 5);\n\nsd_bus_message* sd_bus_message_ref(sd_bus_message *m);\nsd_bus_message* sd_bus_message_unref(sd_bus_message *m);\n\nint sd_bus_message_seal(sd_bus_message *m, uint64_t cookie, uint64_t timeout_usec);\n\nint sd_bus_message_get_type(sd_bus_message *m, uint8_t *type);\nint sd_bus_message_get_cookie(sd_bus_message *m, uint64_t *cookie);\nint sd_bus_message_get_reply_cookie(sd_bus_message *m, uint64_t *cookie);\nint sd_bus_message_get_priority(sd_bus_message *m, int64_t *priority);\n\nint sd_bus_message_get_expect_reply(sd_bus_message *m);\nint sd_bus_message_get_auto_start(sd_bus_message *m);\nint sd_bus_message_get_allow_interactive_authorization(sd_bus_message *m);\n\nconst char *sd_bus_message_get_signature(sd_bus_message *m, int complete);\nconst char *sd_bus_message_get_path(sd_bus_message *m);\nconst char *sd_bus_message_get_interface(sd_bus_message *m);\nconst char *sd_bus_message_get_member(sd_bus_message *m);\nconst char *sd_bus_message_get_destination(sd_bus_message *m);\nconst char *sd_bus_message_get_sender(sd_bus_message *m);\nconst sd_bus_error *sd_bus_message_get_error(sd_bus_message *m);\nint sd_bus_message_get_errno(sd_bus_message *m);\n\nint sd_bus_message_get_monotonic_usec(sd_bus_message *m, uint64_t *usec);\nint sd_bus_message_get_realtime_usec(sd_bus_message *m, uint64_t *usec);\nint sd_bus_message_get_seqnum(sd_bus_message *m, uint64_t* seqnum);\n\nsd_bus* sd_bus_message_get_bus(sd_bus_message *m);\nsd_bus_creds *sd_bus_message_get_creds(sd_bus_message *m); /* do not unref the result */\n\nint sd_bus_message_is_signal(sd_bus_message *m, const char *interface, const char *member);\nint sd_bus_message_is_method_call(sd_bus_message *m, const char *interface, const char *member);\nint sd_bus_message_is_method_error(sd_bus_message *m, const char *name);\nint sd_bus_message_is_empty(sd_bus_message *m);\nint sd_bus_message_has_signature(sd_bus_message *m, const char *signature);\n\nint sd_bus_message_set_expect_reply(sd_bus_message *m, int b);\nint sd_bus_message_set_auto_start(sd_bus_message *m, int b);\nint sd_bus_message_set_allow_interactive_authorization(sd_bus_message *m, int b);\n\nint sd_bus_message_set_destination(sd_bus_message *m, const char *destination);\nint sd_bus_message_set_sender(sd_bus_message *m, const char *sender);\nint sd_bus_message_set_priority(sd_bus_message *m, int64_t priority);\n\nint sd_bus_message_append(sd_bus_message *m, const char *types, ...);\nint sd_bus_message_appendv(sd_bus_message *m, const char *types, va_list ap);\nint sd_bus_message_append_basic(sd_bus_message *m, char type, const void *p);\nint sd_bus_message_append_array(sd_bus_message *m, char type, const void *ptr, size_t size);\nint sd_bus_message_append_array_space(sd_bus_message *m, char type, size_t size, void **ptr);\nint sd_bus_message_append_array_iovec(sd_bus_message *m, char type, const struct iovec *iov, unsigned n);\nint sd_bus_message_append_array_memfd(sd_bus_message *m, char type, int memfd, uint64_t offset, uint64_t size);\nint sd_bus_message_append_string_space(sd_bus_message *m, size_t size, char **s);\nint sd_bus_message_append_string_iovec(sd_bus_message *m, const struct iovec *iov, unsigned n);\nint sd_bus_message_append_string_memfd(sd_bus_message *m, int memfd, uint64_t offset, uint64_t size);\nint sd_bus_message_append_strv(sd_bus_message *m, char **l);\nint sd_bus_message_open_container(sd_bus_message *m, char type, const char *contents);\nint sd_bus_message_close_container(sd_bus_message *m);\nint sd_bus_message_copy(sd_bus_message *m, sd_bus_message *source, int all);\n\nint sd_bus_message_read(sd_bus_message *m, const char *types, ...);\nint sd_bus_message_readv(sd_bus_message *m, const char *types, va_list ap);\nint sd_bus_message_read_basic(sd_bus_message *m, char type, void *p);\nint sd_bus_message_read_array(sd_bus_message *m, char type, const void **ptr, size_t *size);\nint sd_bus_message_read_strv(sd_bus_message *m, char ***l); /* free the result! */\nint sd_bus_message_skip(sd_bus_message *m, const char *types);\nint sd_bus_message_enter_container(sd_bus_message *m, char type, const char *contents);\nint sd_bus_message_exit_container(sd_bus_message *m);\nint sd_bus_message_peek_type(sd_bus_message *m, char *type, const char **contents);\nint sd_bus_message_verify_type(sd_bus_message *m, char type, const char *contents);\nint sd_bus_message_at_end(sd_bus_message *m, int complete);\nint sd_bus_message_rewind(sd_bus_message *m, int complete);\nint sd_bus_message_sensitive(sd_bus_message *m);\n\nint sd_bus_message_dump(sd_bus_message *m, FILE *f, uint64_t flags);\n\n/* Bus management */\n\nint sd_bus_get_unique_name(sd_bus *bus, const char **unique);\nint sd_bus_request_name(sd_bus *bus, const char *name, uint64_t flags);\nint sd_bus_request_name_async(sd_bus *bus, sd_bus_slot **ret_slot, const char *name, uint64_t flags, sd_bus_message_handler_t callback, void *userdata);\nint sd_bus_release_name(sd_bus *bus, const char *name);\nint sd_bus_release_name_async(sd_bus *bus, sd_bus_slot **ret_slot, const char *name, sd_bus_message_handler_t callback, void *userdata);\nint sd_bus_list_names(sd_bus *bus, char ***acquired, char ***activatable); /* free the results */\nint sd_bus_get_name_creds(sd_bus *bus, const char *name, uint64_t mask, sd_bus_creds **creds); /* unref the result! */\nint sd_bus_get_name_machine_id(sd_bus *bus, const char *name, sd_id128_t *machine);\n\n/* Convenience calls */\n\nint sd_bus_call_method(sd_bus *bus, const char *destination, const char *path, const char *interface, const char *member, sd_bus_error *ret_error, sd_bus_message **reply, const char *types, ...);\nint sd_bus_call_method_async(sd_bus *bus, sd_bus_slot **slot, const char *destination, const char *path, const char *interface, const char *member, sd_bus_message_handler_t callback, void *userdata, const char *types, ...);\nint sd_bus_get_property(sd_bus *bus, const char *destination, const char *path, const char *interface, const char *member, sd_bus_error *ret_error, sd_bus_message **reply, const char *type);\nint sd_bus_get_property_trivial(sd_bus *bus, const char *destination, const char *path, const char *interface, const char *member, sd_bus_error *ret_error, char type, void *ret_ptr);\nint sd_bus_get_property_string(sd_bus *bus, const char *destination, const char *path, const char *interface, const char *member, sd_bus_error *ret_error, char **ret); /* free the result! */\nint sd_bus_get_property_strv(sd_bus *bus, const char *destination, const char *path, const char *interface, const char *member, sd_bus_error *ret_error, char ***ret); /* free the result! */\nint sd_bus_set_property(sd_bus *bus, const char *destination, const char *path, const char *interface, const char *member, sd_bus_error *ret_error, const char *type, ...);\n\nint sd_bus_reply_method_return(sd_bus_message *call, const char *types, ...);\nint sd_bus_reply_method_error(sd_bus_message *call, const sd_bus_error *e);\nint sd_bus_reply_method_errorf(sd_bus_message *call, const char *name, const char *format, ...) _sd_printf_(3, 4);\nint sd_bus_reply_method_errno(sd_bus_message *call, int error, const sd_bus_error *e);\nint sd_bus_reply_method_errnof(sd_bus_message *call, int error, const char *format, ...) _sd_printf_(3, 4);\n\nint sd_bus_emit_signal(sd_bus *bus, const char *path, const char *interface, const char *member, const char *types, ...);\n\nint sd_bus_emit_properties_changed_strv(sd_bus *bus, const char *path, const char *interface, char **names);\nint sd_bus_emit_properties_changed(sd_bus *bus, const char *path, const char *interface, const char *name, ...) _sd_sentinel_;\n\nint sd_bus_emit_object_added(sd_bus *bus, const char *path);\nint sd_bus_emit_object_removed(sd_bus *bus, const char *path);\nint sd_bus_emit_interfaces_added_strv(sd_bus *bus, const char *path, char **interfaces);\nint sd_bus_emit_interfaces_added(sd_bus *bus, const char *path, const char *interface, ...) _sd_sentinel_;\nint sd_bus_emit_interfaces_removed_strv(sd_bus *bus, const char *path, char **interfaces);\nint sd_bus_emit_interfaces_removed(sd_bus *bus, const char *path, const char *interface, ...) _sd_sentinel_;\n\nint sd_bus_query_sender_creds(sd_bus_message *call, uint64_t mask, sd_bus_creds **creds);\nint sd_bus_query_sender_privilege(sd_bus_message *call, int capability);\n\nint sd_bus_match_signal(sd_bus *bus, sd_bus_slot **ret, const char *sender, const char *path, const char *interface, const char *member, sd_bus_message_handler_t callback, void *userdata);\nint sd_bus_match_signal_async(sd_bus *bus, sd_bus_slot **ret, const char *sender, const char *path, const char *interface, const char *member, sd_bus_message_handler_t match_callback, sd_bus_message_handler_t add_callback, void *userdata);\n\n/* Credential handling */\n\nint sd_bus_creds_new_from_pid(sd_bus_creds **ret, pid_t pid, uint64_t creds_mask);\nsd_bus_creds *sd_bus_creds_ref(sd_bus_creds *c);\nsd_bus_creds *sd_bus_creds_unref(sd_bus_creds *c);\nuint64_t sd_bus_creds_get_mask(const sd_bus_creds *c);\nuint64_t sd_bus_creds_get_augmented_mask(const sd_bus_creds *c);\n\nint sd_bus_creds_get_pid(sd_bus_creds *c, pid_t *pid);\nint sd_bus_creds_get_ppid(sd_bus_creds *c, pid_t *ppid);\nint sd_bus_creds_get_tid(sd_bus_creds *c, pid_t *tid);\nint sd_bus_creds_get_uid(sd_bus_creds *c, uid_t *uid);\nint sd_bus_creds_get_euid(sd_bus_creds *c, uid_t *euid);\nint sd_bus_creds_get_suid(sd_bus_creds *c, uid_t *suid);\nint sd_bus_creds_get_fsuid(sd_bus_creds *c, uid_t *fsuid);\nint sd_bus_creds_get_gid(sd_bus_creds *c, gid_t *gid);\nint sd_bus_creds_get_egid(sd_bus_creds *c, gid_t *egid);\nint sd_bus_creds_get_sgid(sd_bus_creds *c, gid_t *sgid);\nint sd_bus_creds_get_fsgid(sd_bus_creds *c, gid_t *fsgid);\nint sd_bus_creds_get_supplementary_gids(sd_bus_creds *c, const gid_t **gids);\nint sd_bus_creds_get_comm(sd_bus_creds *c, const char **comm);\nint sd_bus_creds_get_tid_comm(sd_bus_creds *c, const char **comm);\nint sd_bus_creds_get_exe(sd_bus_creds *c, const char **exe);\nint sd_bus_creds_get_cmdline(sd_bus_creds *c, char ***cmdline);\nint sd_bus_creds_get_cgroup(sd_bus_creds *c, const char **cgroup);\nint sd_bus_creds_get_unit(sd_bus_creds *c, const char **unit);\nint sd_bus_creds_get_slice(sd_bus_creds *c, const char **slice);\nint sd_bus_creds_get_user_unit(sd_bus_creds *c, const char **unit);\nint sd_bus_creds_get_user_slice(sd_bus_creds *c, const char **slice);\nint sd_bus_creds_get_session(sd_bus_creds *c, const char **session);\nint sd_bus_creds_get_owner_uid(sd_bus_creds *c, uid_t *uid);\nint sd_bus_creds_has_effective_cap(sd_bus_creds *c, int capability);\nint sd_bus_creds_has_permitted_cap(sd_bus_creds *c, int capability);\nint sd_bus_creds_has_inheritable_cap(sd_bus_creds *c, int capability);\nint sd_bus_creds_has_bounding_cap(sd_bus_creds *c, int capability);\nint sd_bus_creds_get_selinux_context(sd_bus_creds *c, const char **context);\nint sd_bus_creds_get_audit_session_id(sd_bus_creds *c, uint32_t *sessionid);\nint sd_bus_creds_get_audit_login_uid(sd_bus_creds *c, uid_t *loginuid);\nint sd_bus_creds_get_tty(sd_bus_creds *c, const char **tty);\nint sd_bus_creds_get_unique_name(sd_bus_creds *c, const char **name);\nint sd_bus_creds_get_well_known_names(sd_bus_creds *c, char ***names);\nint sd_bus_creds_get_description(sd_bus_creds *c, const char **name);\n\n/* Error structures */\n\n#define SD_BUS_ERROR_MAKE_CONST(name, message) ((const sd_bus_error) {(name), (message), 0})\n#define SD_BUS_ERROR_NULL SD_BUS_ERROR_MAKE_CONST(NULL, NULL)\n\nvoid sd_bus_error_free(sd_bus_error *e);\nint sd_bus_error_set(sd_bus_error *e, const char *name, const char *message);\nint sd_bus_error_setf(sd_bus_error *e, const char *name, const char *format, ...)  _sd_printf_(3, 4);\nint sd_bus_error_set_const(sd_bus_error *e, const char *name, const char *message);\nint sd_bus_error_set_errno(sd_bus_error *e, int error);\nint sd_bus_error_set_errnof(sd_bus_error *e, int error, const char *format, ...) _sd_printf_(3, 4);\nint sd_bus_error_set_errnofv(sd_bus_error *e, int error, const char *format, va_list ap) _sd_printf_(3,0);\nint sd_bus_error_get_errno(const sd_bus_error *e);\nint sd_bus_error_copy(sd_bus_error *dest, const sd_bus_error *e);\nint sd_bus_error_move(sd_bus_error *dest, sd_bus_error *e);\nint sd_bus_error_is_set(const sd_bus_error *e);\nint sd_bus_error_has_name(const sd_bus_error *e, const char *name);\n\n#define SD_BUS_ERROR_MAP(_name, _code)          \\\n        {                                       \\\n                .name = _name,                  \\\n                .code = _code,                  \\\n        }\n#define SD_BUS_ERROR_MAP_END                    \\\n        {                                       \\\n                .name = NULL,                   \\\n                .code = - 'x',                  \\\n        }\n\nint sd_bus_error_add_map(const sd_bus_error_map *map);\n\n/* Auxiliary macros */\n\n#define SD_BUS_MESSAGE_APPEND_ID128(x) 16,                              \\\n                (x).bytes[0],  (x).bytes[1],  (x).bytes[2],  (x).bytes[3], \\\n                (x).bytes[4],  (x).bytes[5],  (x).bytes[6],  (x).bytes[7], \\\n                (x).bytes[8],  (x).bytes[9],  (x).bytes[10], (x).bytes[11], \\\n                (x).bytes[12], (x).bytes[13], (x).bytes[14], (x).bytes[15]\n\n#define SD_BUS_MESSAGE_READ_ID128(x) 16,                                \\\n                &(x).bytes[0],  &(x).bytes[1],  &(x).bytes[2],  &(x).bytes[3], \\\n                &(x).bytes[4],  &(x).bytes[5],  &(x).bytes[6],  &(x).bytes[7], \\\n                &(x).bytes[8],  &(x).bytes[9],  &(x).bytes[10], &(x).bytes[11], \\\n                &(x).bytes[12], &(x).bytes[13], &(x).bytes[14], &(x).bytes[15]\n\n/* Label escaping */\n\nint sd_bus_path_encode(const char *prefix, const char *external_id, char **ret_path);\nint sd_bus_path_encode_many(char **out, const char *path_template, ...);\nint sd_bus_path_decode(const char *path, const char *prefix, char **ret_external_id);\nint sd_bus_path_decode_many(const char *path, const char *path_template, ...);\n\n/* Tracking peers */\n\nint sd_bus_track_new(sd_bus *bus, sd_bus_track **track, sd_bus_track_handler_t handler, void *userdata);\nsd_bus_track* sd_bus_track_ref(sd_bus_track *track);\nsd_bus_track* sd_bus_track_unref(sd_bus_track *track);\n\nsd_bus* sd_bus_track_get_bus(sd_bus_track *track);\nvoid *sd_bus_track_get_userdata(sd_bus_track *track);\nvoid *sd_bus_track_set_userdata(sd_bus_track *track, void *userdata);\n\nint sd_bus_track_add_sender(sd_bus_track *track, sd_bus_message *m);\nint sd_bus_track_remove_sender(sd_bus_track *track, sd_bus_message *m);\nint sd_bus_track_add_name(sd_bus_track *track, const char *name);\nint sd_bus_track_remove_name(sd_bus_track *track, const char *name);\n\nint sd_bus_track_set_recursive(sd_bus_track *track, int b);\nint sd_bus_track_get_recursive(sd_bus_track *track);\n\nunsigned sd_bus_track_count(sd_bus_track *track);\nint sd_bus_track_count_sender(sd_bus_track *track, sd_bus_message *m);\nint sd_bus_track_count_name(sd_bus_track *track, const char *name);\n\nconst char* sd_bus_track_contains(sd_bus_track *track, const char *name);\nconst char* sd_bus_track_first(sd_bus_track *track);\nconst char* sd_bus_track_next(sd_bus_track *track);\n\nint sd_bus_track_set_destroy_callback(sd_bus_track *s, sd_bus_destroy_t callback);\nint sd_bus_track_get_destroy_callback(sd_bus_track *s, sd_bus_destroy_t *ret);\n\n/* Define helpers so that __attribute__((cleanup(sd_bus_unrefp))) and similar may be used. */\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_bus, sd_bus_unref);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_bus, sd_bus_close_unref);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_bus, sd_bus_flush_close_unref);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_bus_slot, sd_bus_slot_unref);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_bus_message, sd_bus_message_unref);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_bus_creds, sd_bus_creds_unref);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_bus_track, sd_bus_track_unref);\n\n_SD_END_DECLARATIONS;\n\n#endif\n"], "fixing_code": ["/***\n  SPDX-License-Identifier: LGPL-2.1+\n\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n***/\n\nLIBSYSTEMD_209 {\nglobal:\n        /* sd-journal */\n        sd_journal_print;\n        sd_journal_printv;\n        sd_journal_send;\n        sd_journal_sendv;\n        sd_journal_stream_fd;\n        sd_journal_open;\n        sd_journal_close;\n        sd_journal_previous;\n        sd_journal_next;\n        sd_journal_previous_skip;\n        sd_journal_next_skip;\n        sd_journal_get_realtime_usec;\n        sd_journal_get_monotonic_usec;\n        sd_journal_get_data;\n        sd_journal_enumerate_data;\n        sd_journal_restart_data;\n        sd_journal_add_match;\n        sd_journal_flush_matches;\n        sd_journal_seek_head;\n        sd_journal_seek_tail;\n        sd_journal_seek_monotonic_usec;\n        sd_journal_seek_realtime_usec;\n        sd_journal_seek_cursor;\n        sd_journal_get_cursor;\n        sd_journal_get_fd;\n        sd_journal_process;\n        sd_journal_print_with_location;\n        sd_journal_printv_with_location;\n        sd_journal_send_with_location;\n        sd_journal_sendv_with_location;\n        sd_journal_get_cutoff_realtime_usec;\n        sd_journal_get_cutoff_monotonic_usec;\n        sd_journal_wait;\n        sd_journal_open_directory;\n        sd_journal_add_disjunction;\n        sd_journal_perror;\n        sd_journal_perror_with_location;\n        sd_journal_get_usage;\n        sd_journal_test_cursor;\n        sd_journal_query_unique;\n        sd_journal_enumerate_unique;\n        sd_journal_restart_unique;\n        sd_journal_get_catalog;\n        sd_journal_get_catalog_for_message_id;\n        sd_journal_set_data_threshold;\n        sd_journal_get_data_threshold;\n        sd_journal_reliable_fd;\n        sd_journal_get_events;\n        sd_journal_get_timeout;\n        sd_journal_add_conjunction;\n        sd_journal_open_files;\n        sd_journal_open_container;\n\n        /* sd-daemon */\n        sd_booted;\n        sd_is_fifo;\n        sd_is_mq;\n        sd_is_socket;\n        sd_is_socket_inet;\n        sd_is_socket_unix;\n        sd_is_special;\n        sd_listen_fds;\n        sd_notify;\n        sd_notifyf;\n        sd_watchdog_enabled;\n\n        /* sd-id128 */\n        sd_id128_to_string;\n        sd_id128_from_string;\n        sd_id128_randomize;\n        sd_id128_get_machine;\n        sd_id128_get_boot;\n\n        /* sd-login */\n        sd_get_seats;\n        sd_get_sessions;\n        sd_get_uids;\n        sd_login_monitor_flush;\n        sd_login_monitor_get_fd;\n        sd_login_monitor_new;\n        sd_login_monitor_unref;\n        sd_pid_get_owner_uid;\n        sd_pid_get_session;\n        sd_seat_can_multi_session;\n        sd_seat_get_active;\n        sd_seat_get_sessions;\n        sd_session_get_seat;\n        sd_session_get_uid;\n        sd_session_is_active;\n        sd_uid_get_seats;\n        sd_uid_get_sessions;\n        sd_uid_get_state;\n        sd_uid_is_on_seat;\n        sd_pid_get_unit;\n        sd_session_get_service;\n        sd_session_get_type;\n        sd_session_get_class;\n        sd_session_get_display;\n        sd_session_get_state;\n        sd_seat_can_tty;\n        sd_seat_can_graphical;\n        sd_session_get_tty;\n        sd_login_monitor_get_events;\n        sd_login_monitor_get_timeout;\n        sd_pid_get_user_unit;\n        sd_pid_get_machine_name;\n        sd_get_machine_names;\n        sd_pid_get_slice;\n        sd_session_get_vt;\n        sd_session_is_remote;\n        sd_session_get_remote_user;\n        sd_session_get_remote_host;\nlocal:\n       *;\n};\n\nLIBSYSTEMD_211 {\nglobal:\n        sd_machine_get_class;\n        sd_peer_get_session;\n        sd_peer_get_owner_uid;\n        sd_peer_get_unit;\n        sd_peer_get_user_unit;\n        sd_peer_get_machine_name;\n        sd_peer_get_slice;\n} LIBSYSTEMD_209;\n\nLIBSYSTEMD_213 {\nglobal:\n        sd_uid_get_display;\n} LIBSYSTEMD_211;\n\nLIBSYSTEMD_214 {\nglobal:\n        sd_pid_notify;\n        sd_pid_notifyf;\n} LIBSYSTEMD_213;\n\nLIBSYSTEMD_216 {\nglobal:\n        sd_machine_get_ifindices;\n} LIBSYSTEMD_214;\n\nLIBSYSTEMD_217 {\nglobal:\n        sd_session_get_desktop;\n} LIBSYSTEMD_216;\n\nLIBSYSTEMD_219 {\nglobal:\n        sd_pid_notify_with_fds;\n} LIBSYSTEMD_217;\n\nLIBSYSTEMD_220 {\nglobal:\n        sd_pid_get_user_slice;\n        sd_peer_get_user_slice;\n} LIBSYSTEMD_219;\n\nLIBSYSTEMD_221 {\nglobal:\n        /* sd-bus */\n        sd_bus_default;\n        sd_bus_default_user;\n        sd_bus_default_system;\n        sd_bus_open;\n        sd_bus_open_user;\n        sd_bus_open_system;\n        sd_bus_open_system_remote;\n        sd_bus_open_system_machine;\n        sd_bus_new;\n        sd_bus_set_address;\n        sd_bus_set_fd;\n        sd_bus_set_exec;\n        sd_bus_get_address;\n        sd_bus_set_bus_client;\n        sd_bus_is_bus_client;\n        sd_bus_set_server;\n        sd_bus_is_server;\n        sd_bus_set_anonymous;\n        sd_bus_is_anonymous;\n        sd_bus_set_trusted;\n        sd_bus_is_trusted;\n        sd_bus_set_monitor;\n        sd_bus_is_monitor;\n        sd_bus_set_description;\n        sd_bus_get_description;\n        sd_bus_negotiate_creds;\n        sd_bus_negotiate_timestamp;\n        sd_bus_negotiate_fds;\n        sd_bus_can_send;\n        sd_bus_get_creds_mask;\n        sd_bus_set_allow_interactive_authorization;\n        sd_bus_get_allow_interactive_authorization;\n        sd_bus_start;\n        sd_bus_close;\n        sd_bus_try_close;\n        sd_bus_ref;\n        sd_bus_unref;\n        sd_bus_is_open;\n        sd_bus_get_bus_id;\n        sd_bus_get_scope;\n        sd_bus_get_tid;\n        sd_bus_get_owner_creds;\n        sd_bus_send;\n        sd_bus_send_to;\n        sd_bus_call;\n        sd_bus_call_async;\n        sd_bus_get_fd;\n        sd_bus_get_events;\n        sd_bus_get_timeout;\n        sd_bus_process;\n        sd_bus_process_priority;\n        sd_bus_wait;\n        sd_bus_flush;\n        sd_bus_get_current_slot;\n        sd_bus_get_current_message;\n        sd_bus_get_current_handler;\n        sd_bus_get_current_userdata;\n        sd_bus_attach_event;\n        sd_bus_detach_event;\n        sd_bus_get_event;\n        sd_bus_add_filter;\n        sd_bus_add_match;\n        sd_bus_add_object;\n        sd_bus_add_fallback;\n        sd_bus_add_object_vtable;\n        sd_bus_add_fallback_vtable;\n        sd_bus_add_node_enumerator;\n        sd_bus_add_object_manager;\n        sd_bus_slot_ref;\n        sd_bus_slot_unref;\n        sd_bus_slot_get_bus;\n        sd_bus_slot_get_userdata;\n        sd_bus_slot_set_userdata;\n        sd_bus_slot_get_description;\n        sd_bus_slot_set_description;\n        sd_bus_slot_get_current_message;\n        sd_bus_slot_get_current_handler;\n        sd_bus_slot_get_current_userdata;\n        sd_bus_message_new_signal;\n        sd_bus_message_new_method_call;\n        sd_bus_message_new_method_return;\n        sd_bus_message_new_method_error;\n        sd_bus_message_new_method_errorf;\n        sd_bus_message_new_method_errno;\n        sd_bus_message_new_method_errnof;\n        sd_bus_message_ref;\n        sd_bus_message_unref;\n        sd_bus_message_get_type;\n        sd_bus_message_get_cookie;\n        sd_bus_message_get_reply_cookie;\n        sd_bus_message_get_priority;\n        sd_bus_message_get_expect_reply;\n        sd_bus_message_get_auto_start;\n        sd_bus_message_get_allow_interactive_authorization;\n        sd_bus_message_get_signature;\n        sd_bus_message_get_path;\n        sd_bus_message_get_interface;\n        sd_bus_message_get_member;\n        sd_bus_message_get_destination;\n        sd_bus_message_get_sender;\n        sd_bus_message_get_error;\n        sd_bus_message_get_errno;\n        sd_bus_message_get_monotonic_usec;\n        sd_bus_message_get_realtime_usec;\n        sd_bus_message_get_seqnum;\n        sd_bus_message_get_bus;\n        sd_bus_message_get_creds;\n        sd_bus_message_is_signal;\n        sd_bus_message_is_method_call;\n        sd_bus_message_is_method_error;\n        sd_bus_message_is_empty;\n        sd_bus_message_has_signature;\n        sd_bus_message_set_expect_reply;\n        sd_bus_message_set_auto_start;\n        sd_bus_message_set_allow_interactive_authorization;\n        sd_bus_message_set_destination;\n        sd_bus_message_set_priority;\n        sd_bus_message_append;\n        sd_bus_message_append_basic;\n        sd_bus_message_append_array;\n        sd_bus_message_append_array_space;\n        sd_bus_message_append_array_iovec;\n        sd_bus_message_append_array_memfd;\n        sd_bus_message_append_string_space;\n        sd_bus_message_append_string_iovec;\n        sd_bus_message_append_string_memfd;\n        sd_bus_message_append_strv;\n        sd_bus_message_open_container;\n        sd_bus_message_close_container;\n        sd_bus_message_copy;\n        sd_bus_message_read;\n        sd_bus_message_read_basic;\n        sd_bus_message_read_array;\n        sd_bus_message_read_strv;\n        sd_bus_message_skip;\n        sd_bus_message_enter_container;\n        sd_bus_message_exit_container;\n        sd_bus_message_peek_type;\n        sd_bus_message_verify_type;\n        sd_bus_message_at_end;\n        sd_bus_message_rewind;\n        sd_bus_get_unique_name;\n        sd_bus_request_name;\n        sd_bus_release_name;\n        sd_bus_list_names;\n        sd_bus_get_name_creds;\n        sd_bus_get_name_machine_id;\n        sd_bus_call_method;\n        sd_bus_call_method_async;\n        sd_bus_get_property;\n        sd_bus_get_property_trivial;\n        sd_bus_get_property_string;\n        sd_bus_get_property_strv;\n        sd_bus_set_property;\n        sd_bus_reply_method_return;\n        sd_bus_reply_method_error;\n        sd_bus_reply_method_errorf;\n        sd_bus_reply_method_errno;\n        sd_bus_reply_method_errnof;\n        sd_bus_emit_signal;\n        sd_bus_emit_properties_changed_strv;\n        sd_bus_emit_properties_changed;\n        sd_bus_emit_interfaces_added_strv;\n        sd_bus_emit_interfaces_added;\n        sd_bus_emit_interfaces_removed_strv;\n        sd_bus_emit_interfaces_removed;\n        sd_bus_query_sender_creds;\n        sd_bus_query_sender_privilege;\n        sd_bus_creds_new_from_pid;\n        sd_bus_creds_ref;\n        sd_bus_creds_unref;\n        sd_bus_creds_get_mask;\n        sd_bus_creds_get_augmented_mask;\n        sd_bus_creds_get_pid;\n        sd_bus_creds_get_ppid;\n        sd_bus_creds_get_tid;\n        sd_bus_creds_get_uid;\n        sd_bus_creds_get_euid;\n        sd_bus_creds_get_suid;\n        sd_bus_creds_get_fsuid;\n        sd_bus_creds_get_gid;\n        sd_bus_creds_get_egid;\n        sd_bus_creds_get_sgid;\n        sd_bus_creds_get_fsgid;\n        sd_bus_creds_get_supplementary_gids;\n        sd_bus_creds_get_comm;\n        sd_bus_creds_get_tid_comm;\n        sd_bus_creds_get_exe;\n        sd_bus_creds_get_cmdline;\n        sd_bus_creds_get_cgroup;\n        sd_bus_creds_get_unit;\n        sd_bus_creds_get_slice;\n        sd_bus_creds_get_user_unit;\n        sd_bus_creds_get_user_slice;\n        sd_bus_creds_get_session;\n        sd_bus_creds_get_owner_uid;\n        sd_bus_creds_has_effective_cap;\n        sd_bus_creds_has_permitted_cap;\n        sd_bus_creds_has_inheritable_cap;\n        sd_bus_creds_has_bounding_cap;\n        sd_bus_creds_get_selinux_context;\n        sd_bus_creds_get_audit_session_id;\n        sd_bus_creds_get_audit_login_uid;\n        sd_bus_creds_get_tty;\n        sd_bus_creds_get_unique_name;\n        sd_bus_creds_get_well_known_names;\n        sd_bus_creds_get_description;\n        sd_bus_error_free;\n        sd_bus_error_set;\n        sd_bus_error_setf;\n        sd_bus_error_set_const;\n        sd_bus_error_set_errno;\n        sd_bus_error_set_errnof;\n        sd_bus_error_set_errnofv;\n        sd_bus_error_get_errno;\n        sd_bus_error_copy;\n        sd_bus_error_is_set;\n        sd_bus_error_has_name;\n        sd_bus_error_add_map;\n        sd_bus_path_encode;\n        sd_bus_path_decode;\n        sd_bus_track_new;\n        sd_bus_track_ref;\n        sd_bus_track_unref;\n        sd_bus_track_get_bus;\n        sd_bus_track_get_userdata;\n        sd_bus_track_set_userdata;\n        sd_bus_track_add_sender;\n        sd_bus_track_remove_sender;\n        sd_bus_track_add_name;\n        sd_bus_track_remove_name;\n        sd_bus_track_count;\n        sd_bus_track_contains;\n        sd_bus_track_first;\n        sd_bus_track_next;\n\n        /* sd-event */\n        sd_event_default;\n        sd_event_new;\n        sd_event_ref;\n        sd_event_unref;\n        sd_event_add_io;\n        sd_event_add_time;\n        sd_event_add_signal;\n        sd_event_add_child;\n        sd_event_add_defer;\n        sd_event_add_post;\n        sd_event_add_exit;\n        sd_event_prepare;\n        sd_event_wait;\n        sd_event_dispatch;\n        sd_event_run;\n        sd_event_loop;\n        sd_event_exit;\n        sd_event_now;\n        sd_event_get_fd;\n        sd_event_get_state;\n        sd_event_get_tid;\n        sd_event_get_exit_code;\n        sd_event_set_watchdog;\n        sd_event_get_watchdog;\n        sd_event_source_ref;\n        sd_event_source_unref;\n        sd_event_source_get_event;\n        sd_event_source_get_userdata;\n        sd_event_source_set_userdata;\n        sd_event_source_set_description;\n        sd_event_source_get_description;\n        sd_event_source_set_prepare;\n        sd_event_source_get_pending;\n        sd_event_source_get_priority;\n        sd_event_source_set_priority;\n        sd_event_source_get_enabled;\n        sd_event_source_set_enabled;\n        sd_event_source_get_io_fd;\n        sd_event_source_set_io_fd;\n        sd_event_source_get_io_events;\n        sd_event_source_set_io_events;\n        sd_event_source_get_io_revents;\n        sd_event_source_get_time;\n        sd_event_source_set_time;\n        sd_event_source_set_time_accuracy;\n        sd_event_source_get_time_accuracy;\n        sd_event_source_get_time_clock;\n        sd_event_source_get_signal;\n        sd_event_source_get_child_pid;\n} LIBSYSTEMD_220;\n\nLIBSYSTEMD_222 {\nglobal:\n        /* sd-bus */\n        sd_bus_emit_object_added;\n        sd_bus_emit_object_removed;\n        sd_bus_flush_close_unref;\n} LIBSYSTEMD_221;\n\nLIBSYSTEMD_226 {\nglobal:\n        sd_pid_get_cgroup;\n        sd_peer_get_cgroup;\n} LIBSYSTEMD_222;\n\nLIBSYSTEMD_227 {\nglobal:\n        sd_bus_default_flush_close;\n        sd_bus_path_decode_many;\n        sd_bus_path_encode_many;\n        sd_listen_fds_with_names;\n} LIBSYSTEMD_226;\n\nLIBSYSTEMD_229 {\nglobal:\n        sd_journal_has_runtime_files;\n        sd_journal_has_persistent_files;\n        sd_journal_enumerate_fields;\n        sd_journal_restart_fields;\n} LIBSYSTEMD_227;\n\nLIBSYSTEMD_230 {\nglobal:\n        sd_journal_open_directory_fd;\n        sd_journal_open_files_fd;\n} LIBSYSTEMD_229;\n\nLIBSYSTEMD_231 {\nglobal:\n        sd_event_get_iteration;\n} LIBSYSTEMD_230;\n\nLIBSYSTEMD_232 {\nglobal:\n        sd_bus_track_set_recursive;\n        sd_bus_track_get_recursive;\n        sd_bus_track_count_name;\n        sd_bus_track_count_sender;\n        sd_bus_set_exit_on_disconnect;\n        sd_bus_get_exit_on_disconnect;\n        sd_id128_get_invocation;\n} LIBSYSTEMD_231;\n\nLIBSYSTEMD_233 {\nglobal:\n        sd_id128_get_machine_app_specific;\n        sd_is_socket_sockaddr;\n} LIBSYSTEMD_232;\n\nLIBSYSTEMD_234 {\nglobal:\n        sd_bus_message_appendv;\n} LIBSYSTEMD_233;\n\nLIBSYSTEMD_236 {\nglobal:\n        sd_bus_message_new;\n        sd_bus_message_seal;\n} LIBSYSTEMD_234;\n\nLIBSYSTEMD_237 {\nglobal:\n        sd_bus_set_watch_bind;\n        sd_bus_get_watch_bind;\n        sd_bus_request_name_async;\n        sd_bus_release_name_async;\n        sd_bus_add_match_async;\n        sd_bus_match_signal;\n        sd_bus_match_signal_async;\n        sd_bus_is_ready;\n        sd_bus_set_connected_signal;\n        sd_bus_get_connected_signal;\n        sd_bus_set_sender;\n        sd_bus_get_sender;\n        sd_bus_message_set_sender;\n        sd_event_source_get_io_fd_own;\n        sd_event_source_set_io_fd_own;\n} LIBSYSTEMD_236;\n\nLIBSYSTEMD_238 {\nglobal:\n        sd_bus_get_n_queued_read;\n        sd_bus_get_n_queued_write;\n} LIBSYSTEMD_237;\n\nLIBSYSTEMD_239 {\nglobal:\n        sd_bus_open_with_description;\n        sd_bus_open_user_with_description;\n        sd_bus_open_system_with_description;\n        sd_bus_slot_get_floating;\n        sd_bus_slot_set_floating;\n        sd_bus_slot_get_destroy_callback;\n        sd_bus_slot_set_destroy_callback;\n        sd_bus_track_get_destroy_callback;\n        sd_bus_track_set_destroy_callback;\n        sd_event_add_inotify;\n        sd_event_source_get_inotify_mask;\n        sd_event_source_set_destroy_callback;\n        sd_event_source_get_destroy_callback;\n} LIBSYSTEMD_238;\n\nLIBSYSTEMD_240 {\nglobal:\n        sd_bus_message_readv;\n        sd_bus_set_method_call_timeout;\n        sd_bus_get_method_call_timeout;\n\n        sd_bus_error_move;\n\n        sd_bus_set_close_on_exit;\n        sd_bus_get_close_on_exit;\n\n        sd_device_ref;\n        sd_device_unref;\n\n        sd_device_new_from_syspath;\n        sd_device_new_from_devnum;\n        sd_device_new_from_subsystem_sysname;\n        sd_device_new_from_device_id;\n\n        sd_device_get_parent;\n        sd_device_get_parent_with_subsystem_devtype;\n\n        sd_device_get_syspath;\n        sd_device_get_subsystem;\n        sd_device_get_devtype;\n        sd_device_get_devnum;\n        sd_device_get_ifindex;\n        sd_device_get_driver;\n        sd_device_get_devpath;\n        sd_device_get_devname;\n        sd_device_get_sysname;\n        sd_device_get_sysnum;\n\n        sd_device_get_is_initialized;\n        sd_device_get_usec_since_initialized;\n\n        sd_device_get_tag_first;\n        sd_device_get_tag_next;\n        sd_device_get_devlink_first;\n        sd_device_get_devlink_next;\n        sd_device_get_property_first;\n        sd_device_get_property_next;\n        sd_device_get_sysattr_first;\n        sd_device_get_sysattr_next;\n\n        sd_device_has_tag;\n        sd_device_get_property_value;\n        sd_device_get_sysattr_value;\n\n        sd_device_set_sysattr_value;\n\n        sd_device_enumerator_new;\n        sd_device_enumerator_ref;\n        sd_device_enumerator_unref;\n\n        sd_device_enumerator_get_device_first;\n        sd_device_enumerator_get_device_next;\n        sd_device_enumerator_get_subsystem_first;\n        sd_device_enumerator_get_subsystem_next;\n\n        sd_device_enumerator_add_match_subsystem;\n        sd_device_enumerator_add_match_sysattr;\n        sd_device_enumerator_add_match_property;\n        sd_device_enumerator_add_match_sysname;\n        sd_device_enumerator_add_match_tag;\n        sd_device_enumerator_add_match_parent;\n        sd_device_enumerator_allow_uninitialized;\n\n        sd_hwdb_ref;\n        sd_hwdb_unref;\n\n        sd_hwdb_new;\n\n        sd_hwdb_get;\n\n        sd_hwdb_seek;\n        sd_hwdb_enumerate;\n\n        sd_id128_get_boot_app_specific;\n\n        sd_device_monitor_new;\n        sd_device_monitor_ref;\n        sd_device_monitor_unref;\n\n        sd_device_monitor_set_receive_buffer_size;\n        sd_device_monitor_attach_event;\n        sd_device_monitor_detach_event;\n        sd_device_monitor_get_event;\n        sd_device_monitor_get_event_source;\n        sd_device_monitor_start;\n        sd_device_monitor_stop;\n\n        sd_device_monitor_filter_add_match_subsystem_devtype;\n        sd_device_monitor_filter_add_match_tag;\n        sd_device_monitor_filter_update;\n        sd_device_monitor_filter_remove;\n\n        sd_event_source_get_floating;\n        sd_event_source_set_floating;\n} LIBSYSTEMD_239;\n\nLIBSYSTEMD_241 {\nglobal:\n        sd_bus_close_unref;\n} LIBSYSTEMD_240;\n\nLIBSYSTEMD_243 {\nglobal:\n        sd_bus_object_vtable_format;\n        sd_event_source_disable_unref;\n} LIBSYSTEMD_241;\n\nLIBSYSTEMD_245 {\nglobal:\n        sd_bus_enqeue_for_read;\n        sd_bus_message_dump;\n        sd_bus_message_sensitive;\n        sd_event_add_child_pidfd;\n        sd_event_source_get_child_pidfd;\n        sd_event_source_get_child_pidfd_own;\n        sd_event_source_set_child_pidfd_own;\n        sd_event_source_get_child_process_own;\n        sd_event_source_set_child_process_own;\n        sd_event_source_send_child_signal;\n        sd_journal_open_namespace;\n} LIBSYSTEMD_243;\n", "/* SPDX-License-Identifier: LGPL-2.1+ */\n\n#include <endian.h>\n#include <netdb.h>\n#include <poll.h>\n#include <pthread.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include \"sd-bus.h\"\n\n#include \"alloc-util.h\"\n#include \"bus-container.h\"\n#include \"bus-control.h\"\n#include \"bus-internal.h\"\n#include \"bus-kernel.h\"\n#include \"bus-label.h\"\n#include \"bus-message.h\"\n#include \"bus-objects.h\"\n#include \"bus-protocol.h\"\n#include \"bus-slot.h\"\n#include \"bus-socket.h\"\n#include \"bus-track.h\"\n#include \"bus-type.h\"\n#include \"bus-util.h\"\n#include \"cgroup-util.h\"\n#include \"def.h\"\n#include \"errno-util.h\"\n#include \"fd-util.h\"\n#include \"hexdecoct.h\"\n#include \"hostname-util.h\"\n#include \"macro.h\"\n#include \"memory-util.h\"\n#include \"missing_syscall.h\"\n#include \"parse-util.h\"\n#include \"path-util.h\"\n#include \"process-util.h\"\n#include \"string-util.h\"\n#include \"strv.h\"\n\n#define log_debug_bus_message(m)                                         \\\n        do {                                                             \\\n                sd_bus_message *_mm = (m);                               \\\n                log_debug(\"Got message type=%s sender=%s destination=%s path=%s interface=%s member=%s cookie=%\" PRIu64 \" reply_cookie=%\" PRIu64 \" signature=%s error-name=%s error-message=%s\", \\\n                          bus_message_type_to_string(_mm->header->type), \\\n                          strna(sd_bus_message_get_sender(_mm)),         \\\n                          strna(sd_bus_message_get_destination(_mm)),    \\\n                          strna(sd_bus_message_get_path(_mm)),           \\\n                          strna(sd_bus_message_get_interface(_mm)),      \\\n                          strna(sd_bus_message_get_member(_mm)),         \\\n                          BUS_MESSAGE_COOKIE(_mm),                       \\\n                          _mm->reply_cookie,                             \\\n                          strna(_mm->root_container.signature),          \\\n                          strna(_mm->error.name),                        \\\n                          strna(_mm->error.message));                    \\\n        } while (false)\n\nstatic int bus_poll(sd_bus *bus, bool need_more, uint64_t timeout_usec);\nstatic void bus_detach_io_events(sd_bus *b);\nstatic void bus_detach_inotify_event(sd_bus *b);\n\nstatic thread_local sd_bus *default_system_bus = NULL;\nstatic thread_local sd_bus *default_user_bus = NULL;\nstatic thread_local sd_bus *default_starter_bus = NULL;\n\nstatic sd_bus **bus_choose_default(int (**bus_open)(sd_bus **)) {\n        const char *e;\n\n        /* Let's try our best to reuse another cached connection. If\n         * the starter bus type is set, connect via our normal\n         * connection logic, ignoring $DBUS_STARTER_ADDRESS, so that\n         * we can share the connection with the user/system default\n         * bus. */\n\n        e = secure_getenv(\"DBUS_STARTER_BUS_TYPE\");\n        if (e) {\n                if (streq(e, \"system\")) {\n                        if (bus_open)\n                                *bus_open = sd_bus_open_system;\n                        return &default_system_bus;\n                } else if (STR_IN_SET(e, \"user\", \"session\")) {\n                        if (bus_open)\n                                *bus_open = sd_bus_open_user;\n                        return &default_user_bus;\n                }\n        }\n\n        /* No type is specified, so we have not other option than to\n         * use the starter address if it is set. */\n        e = secure_getenv(\"DBUS_STARTER_ADDRESS\");\n        if (e) {\n                if (bus_open)\n                        *bus_open = sd_bus_open;\n                return &default_starter_bus;\n        }\n\n        /* Finally, if nothing is set use the cached connection for\n         * the right scope */\n\n        if (cg_pid_get_owner_uid(0, NULL) >= 0) {\n                if (bus_open)\n                        *bus_open = sd_bus_open_user;\n                return &default_user_bus;\n        } else {\n                if (bus_open)\n                        *bus_open = sd_bus_open_system;\n                return &default_system_bus;\n        }\n}\n\nsd_bus *bus_resolve(sd_bus *bus) {\n        switch ((uintptr_t) bus) {\n        case (uintptr_t) SD_BUS_DEFAULT:\n                return *(bus_choose_default(NULL));\n        case (uintptr_t) SD_BUS_DEFAULT_USER:\n                return default_user_bus;\n        case (uintptr_t) SD_BUS_DEFAULT_SYSTEM:\n                return default_system_bus;\n        default:\n                return bus;\n        }\n}\n\nvoid bus_close_io_fds(sd_bus *b) {\n        assert(b);\n\n        bus_detach_io_events(b);\n\n        if (b->input_fd != b->output_fd)\n                safe_close(b->output_fd);\n        b->output_fd = b->input_fd = safe_close(b->input_fd);\n}\n\nvoid bus_close_inotify_fd(sd_bus *b) {\n        assert(b);\n\n        bus_detach_inotify_event(b);\n\n        b->inotify_fd = safe_close(b->inotify_fd);\n        b->inotify_watches = mfree(b->inotify_watches);\n        b->n_inotify_watches = 0;\n}\n\nstatic void bus_reset_queues(sd_bus *b) {\n        assert(b);\n\n        while (b->rqueue_size > 0)\n                bus_message_unref_queued(b->rqueue[--b->rqueue_size], b);\n\n        b->rqueue = mfree(b->rqueue);\n        b->rqueue_allocated = 0;\n\n        while (b->wqueue_size > 0)\n                bus_message_unref_queued(b->wqueue[--b->wqueue_size], b);\n\n        b->wqueue = mfree(b->wqueue);\n        b->wqueue_allocated = 0;\n}\n\nstatic sd_bus* bus_free(sd_bus *b) {\n        sd_bus_slot *s;\n\n        assert(b);\n        assert(!b->track_queue);\n        assert(!b->tracks);\n\n        b->state = BUS_CLOSED;\n\n        sd_bus_detach_event(b);\n\n        while ((s = b->slots)) {\n                /* At this point only floating slots can still be\n                 * around, because the non-floating ones keep a\n                 * reference to the bus, and we thus couldn't be\n                 * destructing right now... We forcibly disconnect the\n                 * slots here, so that they still can be referenced by\n                 * apps, but are dead. */\n\n                assert(s->floating);\n                bus_slot_disconnect(s, true);\n        }\n\n        if (b->default_bus_ptr)\n                *b->default_bus_ptr = NULL;\n\n        bus_close_io_fds(b);\n        bus_close_inotify_fd(b);\n\n        free(b->label);\n        free(b->groups);\n        free(b->rbuffer);\n        free(b->unique_name);\n        free(b->auth_buffer);\n        free(b->address);\n        free(b->machine);\n        free(b->description);\n        free(b->patch_sender);\n\n        free(b->exec_path);\n        strv_free(b->exec_argv);\n\n        close_many(b->fds, b->n_fds);\n        free(b->fds);\n\n        bus_reset_queues(b);\n\n        ordered_hashmap_free_free(b->reply_callbacks);\n        prioq_free(b->reply_callbacks_prioq);\n\n        assert(b->match_callbacks.type == BUS_MATCH_ROOT);\n        bus_match_free(&b->match_callbacks);\n\n        hashmap_free_free(b->vtable_methods);\n        hashmap_free_free(b->vtable_properties);\n\n        assert(hashmap_isempty(b->nodes));\n        hashmap_free(b->nodes);\n\n        bus_flush_memfd(b);\n\n        assert_se(pthread_mutex_destroy(&b->memfd_cache_mutex) == 0);\n\n        return mfree(b);\n}\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(sd_bus*, bus_free);\n\n_public_ int sd_bus_new(sd_bus **ret) {\n        _cleanup_free_ sd_bus *b = NULL;\n\n        assert_return(ret, -EINVAL);\n\n        b = new(sd_bus, 1);\n        if (!b)\n                return -ENOMEM;\n\n        *b = (sd_bus) {\n                .n_ref = 1,\n                .input_fd = -1,\n                .output_fd = -1,\n                .inotify_fd = -1,\n                .message_version = 1,\n                .creds_mask = SD_BUS_CREDS_WELL_KNOWN_NAMES|SD_BUS_CREDS_UNIQUE_NAME,\n                .accept_fd = true,\n                .original_pid = getpid_cached(),\n                .n_groups = (size_t) -1,\n                .close_on_exit = true,\n        };\n\n        /* We guarantee that wqueue always has space for at least one entry */\n        if (!GREEDY_REALLOC(b->wqueue, b->wqueue_allocated, 1))\n                return -ENOMEM;\n\n        assert_se(pthread_mutex_init(&b->memfd_cache_mutex, NULL) == 0);\n\n        *ret = TAKE_PTR(b);\n        return 0;\n}\n\n_public_ int sd_bus_set_address(sd_bus *bus, const char *address) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(address, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return free_and_strdup(&bus->address, address);\n}\n\n_public_ int sd_bus_set_fd(sd_bus *bus, int input_fd, int output_fd) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(input_fd >= 0, -EBADF);\n        assert_return(output_fd >= 0, -EBADF);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus->input_fd = input_fd;\n        bus->output_fd = output_fd;\n        return 0;\n}\n\n_public_ int sd_bus_set_exec(sd_bus *bus, const char *path, char *const argv[]) {\n        _cleanup_strv_free_ char **a = NULL;\n        int r;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(path, -EINVAL);\n        assert_return(!strv_isempty(argv), -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        a = strv_copy(argv);\n        if (!a)\n                return -ENOMEM;\n\n        r = free_and_strdup(&bus->exec_path, path);\n        if (r < 0)\n                return r;\n\n        return strv_free_and_replace(bus->exec_argv, a);\n}\n\n_public_ int sd_bus_set_bus_client(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(!bus->patch_sender, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus->bus_client = !!b;\n        return 0;\n}\n\n_public_ int sd_bus_set_monitor(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus->is_monitor = !!b;\n        return 0;\n}\n\n_public_ int sd_bus_negotiate_fds(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus->accept_fd = !!b;\n        return 0;\n}\n\n_public_ int sd_bus_negotiate_timestamp(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!IN_SET(bus->state, BUS_CLOSING, BUS_CLOSED), -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        /* This is not actually supported by any of our transports these days, but we do honour it for synthetic\n         * replies, and maybe one day classic D-Bus learns this too */\n        bus->attach_timestamp = !!b;\n\n        return 0;\n}\n\n_public_ int sd_bus_negotiate_creds(sd_bus *bus, int b, uint64_t mask) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(mask <= _SD_BUS_CREDS_ALL, -EINVAL);\n        assert_return(!IN_SET(bus->state, BUS_CLOSING, BUS_CLOSED), -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        SET_FLAG(bus->creds_mask, mask, b);\n\n        /* The well knowns we need unconditionally, so that matches can work */\n        bus->creds_mask |= SD_BUS_CREDS_WELL_KNOWN_NAMES|SD_BUS_CREDS_UNIQUE_NAME;\n\n        return 0;\n}\n\n_public_ int sd_bus_set_server(sd_bus *bus, int b, sd_id128_t server_id) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(b || sd_id128_equal(server_id, SD_ID128_NULL), -EINVAL);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus->is_server = !!b;\n        bus->server_id = server_id;\n        return 0;\n}\n\n_public_ int sd_bus_set_anonymous(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus->anonymous_auth = !!b;\n        return 0;\n}\n\n_public_ int sd_bus_set_trusted(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus->trusted = !!b;\n        return 0;\n}\n\n_public_ int sd_bus_set_description(sd_bus *bus, const char *description) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return free_and_strdup(&bus->description, description);\n}\n\n_public_ int sd_bus_set_allow_interactive_authorization(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus->allow_interactive_authorization = !!b;\n        return 0;\n}\n\n_public_ int sd_bus_get_allow_interactive_authorization(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return bus->allow_interactive_authorization;\n}\n\n_public_ int sd_bus_set_watch_bind(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus->watch_bind = !!b;\n        return 0;\n}\n\n_public_ int sd_bus_get_watch_bind(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return bus->watch_bind;\n}\n\n_public_ int sd_bus_set_connected_signal(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus->connected_signal = !!b;\n        return 0;\n}\n\n_public_ int sd_bus_get_connected_signal(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return bus->connected_signal;\n}\n\nstatic int synthesize_connected_signal(sd_bus *bus) {\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = NULL;\n        int r;\n\n        assert(bus);\n\n        /* If enabled, synthesizes a local \"Connected\" signal mirroring the local \"Disconnected\" signal. This is called\n         * whenever we fully established a connection, i.e. after the authorization phase, and after receiving the\n         * Hello() reply. Or in other words, whenever we enter BUS_RUNNING state.\n         *\n         * This is useful so that clients can start doing stuff whenever the connection is fully established in a way\n         * that works independently from whether we connected to a full bus or just a direct connection. */\n\n        if (!bus->connected_signal)\n                return 0;\n\n        r = sd_bus_message_new_signal(\n                        bus,\n                        &m,\n                        \"/org/freedesktop/DBus/Local\",\n                        \"org.freedesktop.DBus.Local\",\n                        \"Connected\");\n        if (r < 0)\n                return r;\n\n        bus_message_set_sender_local(bus, m);\n        m->read_counter = ++bus->read_counter;\n\n        r = bus_seal_synthetic_message(bus, m);\n        if (r < 0)\n                return r;\n\n        r = bus_rqueue_make_room(bus);\n        if (r < 0)\n                return r;\n\n        /* Insert at the very front */\n        memmove(bus->rqueue + 1, bus->rqueue, sizeof(sd_bus_message*) * bus->rqueue_size);\n        bus->rqueue[0] = bus_message_ref_queued(m, bus);\n        bus->rqueue_size++;\n\n        return 0;\n}\n\nvoid bus_set_state(sd_bus *bus, enum bus_state state) {\n\n        static const char * const table[_BUS_STATE_MAX] = {\n                [BUS_UNSET] = \"UNSET\",\n                [BUS_WATCH_BIND] = \"WATCH_BIND\",\n                [BUS_OPENING] = \"OPENING\",\n                [BUS_AUTHENTICATING] = \"AUTHENTICATING\",\n                [BUS_HELLO] = \"HELLO\",\n                [BUS_RUNNING] = \"RUNNING\",\n                [BUS_CLOSING] = \"CLOSING\",\n                [BUS_CLOSED] = \"CLOSED\",\n        };\n\n        assert(bus);\n        assert(state < _BUS_STATE_MAX);\n\n        if (state == bus->state)\n                return;\n\n        log_debug(\"Bus %s: changing state %s \u2192 %s\", strna(bus->description), table[bus->state], table[state]);\n        bus->state = state;\n}\n\nstatic int hello_callback(sd_bus_message *reply, void *userdata, sd_bus_error *error) {\n        const char *s;\n        sd_bus *bus;\n        int r;\n\n        assert(reply);\n        bus = reply->bus;\n        assert(bus);\n        assert(IN_SET(bus->state, BUS_HELLO, BUS_CLOSING));\n\n        r = sd_bus_message_get_errno(reply);\n        if (r > 0) {\n                r = -r;\n                goto fail;\n        }\n\n        r = sd_bus_message_read(reply, \"s\", &s);\n        if (r < 0)\n                goto fail;\n\n        if (!service_name_is_valid(s) || s[0] != ':') {\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        r = free_and_strdup(&bus->unique_name, s);\n        if (r < 0)\n                goto fail;\n\n        if (bus->state == BUS_HELLO) {\n                bus_set_state(bus, BUS_RUNNING);\n\n                r = synthesize_connected_signal(bus);\n                if (r < 0)\n                        goto fail;\n        }\n\n        return 1;\n\nfail:\n        /* When Hello() failed, let's propagate this in two ways: first we return the error immediately here,\n         * which is the propagated up towards the event loop. Let's also invalidate the connection, so that\n         * if the user then calls back into us again we won't wait any longer. */\n\n        bus_set_state(bus, BUS_CLOSING);\n        return r;\n}\n\nstatic int bus_send_hello(sd_bus *bus) {\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = NULL;\n        int r;\n\n        assert(bus);\n\n        if (!bus->bus_client)\n                return 0;\n\n        r = sd_bus_message_new_method_call(\n                        bus,\n                        &m,\n                        \"org.freedesktop.DBus\",\n                        \"/org/freedesktop/DBus\",\n                        \"org.freedesktop.DBus\",\n                        \"Hello\");\n        if (r < 0)\n                return r;\n\n        return sd_bus_call_async(bus, NULL, m, hello_callback, NULL, 0);\n}\n\nint bus_start_running(sd_bus *bus) {\n        struct reply_callback *c;\n        Iterator i;\n        usec_t n;\n        int r;\n\n        assert(bus);\n        assert(bus->state < BUS_HELLO);\n\n        /* We start all method call timeouts when we enter BUS_HELLO or BUS_RUNNING mode. At this point let's convert\n         * all relative to absolute timestamps. Note that we do not reshuffle the reply callback priority queue since\n         * adding a fixed value to all entries should not alter the internal order. */\n\n        n = now(CLOCK_MONOTONIC);\n        ORDERED_HASHMAP_FOREACH(c, bus->reply_callbacks, i) {\n                if (c->timeout_usec == 0)\n                        continue;\n\n                c->timeout_usec = usec_add(n, c->timeout_usec);\n        }\n\n        if (bus->bus_client) {\n                bus_set_state(bus, BUS_HELLO);\n                return 1;\n        }\n\n        bus_set_state(bus, BUS_RUNNING);\n\n        r = synthesize_connected_signal(bus);\n        if (r < 0)\n                return r;\n\n        return 1;\n}\n\nstatic int parse_address_key(const char **p, const char *key, char **value) {\n        size_t l, n = 0, allocated = 0;\n        _cleanup_free_ char *r = NULL;\n        const char *a;\n\n        assert(p);\n        assert(*p);\n        assert(value);\n\n        if (key) {\n                l = strlen(key);\n                if (strncmp(*p, key, l) != 0)\n                        return 0;\n\n                if ((*p)[l] != '=')\n                        return 0;\n\n                if (*value)\n                        return -EINVAL;\n\n                a = *p + l + 1;\n        } else\n                a = *p;\n\n        while (!IN_SET(*a, ';', ',', 0)) {\n                char c;\n\n                if (*a == '%') {\n                        int x, y;\n\n                        x = unhexchar(a[1]);\n                        if (x < 0)\n                                return x;\n\n                        y = unhexchar(a[2]);\n                        if (y < 0)\n                                return y;\n\n                        c = (char) ((x << 4) | y);\n                        a += 3;\n                } else {\n                        c = *a;\n                        a++;\n                }\n\n                if (!GREEDY_REALLOC(r, allocated, n + 2))\n                        return -ENOMEM;\n\n                r[n++] = c;\n        }\n\n        if (!r) {\n                r = strdup(\"\");\n                if (!r)\n                        return -ENOMEM;\n        } else\n                r[n] = 0;\n\n        if (*a == ',')\n                a++;\n\n        *p = a;\n\n        free_and_replace(*value, r);\n\n        return 1;\n}\n\nstatic void skip_address_key(const char **p) {\n        assert(p);\n        assert(*p);\n\n        *p += strcspn(*p, \",\");\n\n        if (**p == ',')\n                (*p)++;\n}\n\nstatic int parse_unix_address(sd_bus *b, const char **p, char **guid) {\n        _cleanup_free_ char *path = NULL, *abstract = NULL;\n        size_t l;\n        int r;\n\n        assert(b);\n        assert(p);\n        assert(*p);\n        assert(guid);\n\n        while (!IN_SET(**p, 0, ';')) {\n                r = parse_address_key(p, \"guid\", guid);\n                if (r < 0)\n                        return r;\n                else if (r > 0)\n                        continue;\n\n                r = parse_address_key(p, \"path\", &path);\n                if (r < 0)\n                        return r;\n                else if (r > 0)\n                        continue;\n\n                r = parse_address_key(p, \"abstract\", &abstract);\n                if (r < 0)\n                        return r;\n                else if (r > 0)\n                        continue;\n\n                skip_address_key(p);\n        }\n\n        if (!path && !abstract)\n                return -EINVAL;\n\n        if (path && abstract)\n                return -EINVAL;\n\n        if (path) {\n                l = strlen(path);\n                if (l >= sizeof(b->sockaddr.un.sun_path)) /* We insist on NUL termination */\n                        return -E2BIG;\n\n                b->sockaddr.un = (struct sockaddr_un) {\n                        .sun_family = AF_UNIX,\n                };\n\n                memcpy(b->sockaddr.un.sun_path, path, l);\n                b->sockaddr_size = offsetof(struct sockaddr_un, sun_path) + l + 1;\n\n        } else {\n                assert(abstract);\n\n                l = strlen(abstract);\n                if (l >= sizeof(b->sockaddr.un.sun_path) - 1) /* We insist on NUL termination */\n                        return -E2BIG;\n\n                b->sockaddr.un = (struct sockaddr_un) {\n                        .sun_family = AF_UNIX,\n                };\n\n                memcpy(b->sockaddr.un.sun_path+1, abstract, l);\n                b->sockaddr_size = offsetof(struct sockaddr_un, sun_path) + 1 + l;\n        }\n\n        b->is_local = true;\n\n        return 0;\n}\n\nstatic int parse_tcp_address(sd_bus *b, const char **p, char **guid) {\n        _cleanup_free_ char *host = NULL, *port = NULL, *family = NULL;\n        int r;\n        struct addrinfo *result, hints = {\n                .ai_socktype = SOCK_STREAM,\n                .ai_flags = AI_ADDRCONFIG,\n        };\n\n        assert(b);\n        assert(p);\n        assert(*p);\n        assert(guid);\n\n        while (!IN_SET(**p, 0, ';')) {\n                r = parse_address_key(p, \"guid\", guid);\n                if (r < 0)\n                        return r;\n                else if (r > 0)\n                        continue;\n\n                r = parse_address_key(p, \"host\", &host);\n                if (r < 0)\n                        return r;\n                else if (r > 0)\n                        continue;\n\n                r = parse_address_key(p, \"port\", &port);\n                if (r < 0)\n                        return r;\n                else if (r > 0)\n                        continue;\n\n                r = parse_address_key(p, \"family\", &family);\n                if (r < 0)\n                        return r;\n                else if (r > 0)\n                        continue;\n\n                skip_address_key(p);\n        }\n\n        if (!host || !port)\n                return -EINVAL;\n\n        if (family) {\n                if (streq(family, \"ipv4\"))\n                        hints.ai_family = AF_INET;\n                else if (streq(family, \"ipv6\"))\n                        hints.ai_family = AF_INET6;\n                else\n                        return -EINVAL;\n        }\n\n        r = getaddrinfo(host, port, &hints, &result);\n        if (r == EAI_SYSTEM)\n                return -errno;\n        else if (r != 0)\n                return -EADDRNOTAVAIL;\n\n        memcpy(&b->sockaddr, result->ai_addr, result->ai_addrlen);\n        b->sockaddr_size = result->ai_addrlen;\n\n        freeaddrinfo(result);\n\n        b->is_local = false;\n\n        return 0;\n}\n\nstatic int parse_exec_address(sd_bus *b, const char **p, char **guid) {\n        char *path = NULL;\n        unsigned n_argv = 0, j;\n        char **argv = NULL;\n        size_t allocated = 0;\n        int r;\n\n        assert(b);\n        assert(p);\n        assert(*p);\n        assert(guid);\n\n        while (!IN_SET(**p, 0, ';')) {\n                r = parse_address_key(p, \"guid\", guid);\n                if (r < 0)\n                        goto fail;\n                else if (r > 0)\n                        continue;\n\n                r = parse_address_key(p, \"path\", &path);\n                if (r < 0)\n                        goto fail;\n                else if (r > 0)\n                        continue;\n\n                if (startswith(*p, \"argv\")) {\n                        unsigned ul;\n\n                        errno = 0;\n                        ul = strtoul(*p + 4, (char**) p, 10);\n                        if (errno > 0 || **p != '=' || ul > 256) {\n                                r = -EINVAL;\n                                goto fail;\n                        }\n\n                        (*p)++;\n\n                        if (ul >= n_argv) {\n                                if (!GREEDY_REALLOC0(argv, allocated, ul + 2)) {\n                                        r = -ENOMEM;\n                                        goto fail;\n                                }\n\n                                n_argv = ul + 1;\n                        }\n\n                        r = parse_address_key(p, NULL, argv + ul);\n                        if (r < 0)\n                                goto fail;\n\n                        continue;\n                }\n\n                skip_address_key(p);\n        }\n\n        if (!path) {\n                r = -EINVAL;\n                goto fail;\n        }\n\n        /* Make sure there are no holes in the array, with the\n         * exception of argv[0] */\n        for (j = 1; j < n_argv; j++)\n                if (!argv[j]) {\n                        r = -EINVAL;\n                        goto fail;\n                }\n\n        if (argv && argv[0] == NULL) {\n                argv[0] = strdup(path);\n                if (!argv[0]) {\n                        r = -ENOMEM;\n                        goto fail;\n                }\n        }\n\n        b->exec_path = path;\n        b->exec_argv = argv;\n\n        b->is_local = false;\n\n        return 0;\n\nfail:\n        for (j = 0; j < n_argv; j++)\n                free(argv[j]);\n\n        free(argv);\n        free(path);\n        return r;\n}\n\nstatic int parse_container_unix_address(sd_bus *b, const char **p, char **guid) {\n        _cleanup_free_ char *machine = NULL, *pid = NULL;\n        int r;\n\n        assert(b);\n        assert(p);\n        assert(*p);\n        assert(guid);\n\n        while (!IN_SET(**p, 0, ';')) {\n                r = parse_address_key(p, \"guid\", guid);\n                if (r < 0)\n                        return r;\n                else if (r > 0)\n                        continue;\n\n                r = parse_address_key(p, \"machine\", &machine);\n                if (r < 0)\n                        return r;\n                else if (r > 0)\n                        continue;\n\n                r = parse_address_key(p, \"pid\", &pid);\n                if (r < 0)\n                        return r;\n                else if (r > 0)\n                        continue;\n\n                skip_address_key(p);\n        }\n\n        if (!machine == !pid)\n                return -EINVAL;\n\n        if (machine) {\n                if (!streq(machine, \".host\") && !machine_name_is_valid(machine))\n                        return -EINVAL;\n\n                free_and_replace(b->machine, machine);\n        } else {\n                b->machine = mfree(b->machine);\n        }\n\n        if (pid) {\n                r = parse_pid(pid, &b->nspid);\n                if (r < 0)\n                        return r;\n        } else\n                b->nspid = 0;\n\n        b->sockaddr.un = (struct sockaddr_un) {\n                .sun_family = AF_UNIX,\n                /* Note that we use the old /var/run prefix here, to increase compatibility with really old containers */\n                .sun_path = \"/var/run/dbus/system_bus_socket\",\n        };\n        b->sockaddr_size = SOCKADDR_UN_LEN(b->sockaddr.un);\n        b->is_local = false;\n\n        return 0;\n}\n\nstatic void bus_reset_parsed_address(sd_bus *b) {\n        assert(b);\n\n        zero(b->sockaddr);\n        b->sockaddr_size = 0;\n        b->exec_argv = strv_free(b->exec_argv);\n        b->exec_path = mfree(b->exec_path);\n        b->server_id = SD_ID128_NULL;\n        b->machine = mfree(b->machine);\n        b->nspid = 0;\n}\n\nstatic int bus_parse_next_address(sd_bus *b) {\n        _cleanup_free_ char *guid = NULL;\n        const char *a;\n        int r;\n\n        assert(b);\n\n        if (!b->address)\n                return 0;\n        if (b->address[b->address_index] == 0)\n                return 0;\n\n        bus_reset_parsed_address(b);\n\n        a = b->address + b->address_index;\n\n        while (*a != 0) {\n\n                if (*a == ';') {\n                        a++;\n                        continue;\n                }\n\n                if (startswith(a, \"unix:\")) {\n                        a += 5;\n\n                        r = parse_unix_address(b, &a, &guid);\n                        if (r < 0)\n                                return r;\n                        break;\n\n                } else if (startswith(a, \"tcp:\")) {\n\n                        a += 4;\n                        r = parse_tcp_address(b, &a, &guid);\n                        if (r < 0)\n                                return r;\n\n                        break;\n\n                } else if (startswith(a, \"unixexec:\")) {\n\n                        a += 9;\n                        r = parse_exec_address(b, &a, &guid);\n                        if (r < 0)\n                                return r;\n\n                        break;\n\n                } else if (startswith(a, \"x-machine-unix:\")) {\n\n                        a += 15;\n                        r = parse_container_unix_address(b, &a, &guid);\n                        if (r < 0)\n                                return r;\n\n                        break;\n                }\n\n                a = strchr(a, ';');\n                if (!a)\n                        return 0;\n        }\n\n        if (guid) {\n                r = sd_id128_from_string(guid, &b->server_id);\n                if (r < 0)\n                        return r;\n        }\n\n        b->address_index = a - b->address;\n        return 1;\n}\n\nstatic void bus_kill_exec(sd_bus *bus) {\n        if (pid_is_valid(bus->busexec_pid) > 0) {\n                sigterm_wait(bus->busexec_pid);\n                bus->busexec_pid = 0;\n        }\n}\n\nstatic int bus_start_address(sd_bus *b) {\n        int r;\n\n        assert(b);\n\n        for (;;) {\n                bus_close_io_fds(b);\n                bus_close_inotify_fd(b);\n\n                bus_kill_exec(b);\n\n                /* If you provide multiple different bus-addresses, we\n                 * try all of them in order and use the first one that\n                 * succeeds. */\n\n                if (b->exec_path)\n                        r = bus_socket_exec(b);\n                else if ((b->nspid > 0 || b->machine) && b->sockaddr.sa.sa_family != AF_UNSPEC)\n                        r = bus_container_connect_socket(b);\n                else if (b->sockaddr.sa.sa_family != AF_UNSPEC)\n                        r = bus_socket_connect(b);\n                else\n                        goto next;\n\n                if (r >= 0) {\n                        int q;\n\n                        q = bus_attach_io_events(b);\n                        if (q < 0)\n                                return q;\n\n                        q = bus_attach_inotify_event(b);\n                        if (q < 0)\n                                return q;\n\n                        return r;\n                }\n\n                b->last_connect_error = -r;\n\n        next:\n                r = bus_parse_next_address(b);\n                if (r < 0)\n                        return r;\n                if (r == 0)\n                        return b->last_connect_error > 0 ? -b->last_connect_error : -ECONNREFUSED;\n        }\n}\n\nint bus_next_address(sd_bus *b) {\n        assert(b);\n\n        bus_reset_parsed_address(b);\n        return bus_start_address(b);\n}\n\nstatic int bus_start_fd(sd_bus *b) {\n        struct stat st;\n        int r;\n\n        assert(b);\n        assert(b->input_fd >= 0);\n        assert(b->output_fd >= 0);\n\n        r = fd_nonblock(b->input_fd, true);\n        if (r < 0)\n                return r;\n\n        r = fd_cloexec(b->input_fd, true);\n        if (r < 0)\n                return r;\n\n        if (b->input_fd != b->output_fd) {\n                r = fd_nonblock(b->output_fd, true);\n                if (r < 0)\n                        return r;\n\n                r = fd_cloexec(b->output_fd, true);\n                if (r < 0)\n                        return r;\n        }\n\n        if (fstat(b->input_fd, &st) < 0)\n                return -errno;\n\n        return bus_socket_take_fd(b);\n}\n\n_public_ int sd_bus_start(sd_bus *bus) {\n        int r;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state == BUS_UNSET, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        bus_set_state(bus, BUS_OPENING);\n\n        if (bus->is_server && bus->bus_client)\n                return -EINVAL;\n\n        if (bus->input_fd >= 0)\n                r = bus_start_fd(bus);\n        else if (bus->address || bus->sockaddr.sa.sa_family != AF_UNSPEC || bus->exec_path || bus->machine)\n                r = bus_start_address(bus);\n        else\n                return -EINVAL;\n\n        if (r < 0) {\n                sd_bus_close(bus);\n                return r;\n        }\n\n        return bus_send_hello(bus);\n}\n\n_public_ int sd_bus_open_with_description(sd_bus **ret, const char *description) {\n        const char *e;\n        _cleanup_(bus_freep) sd_bus *b = NULL;\n        int r;\n\n        assert_return(ret, -EINVAL);\n\n        /* Let's connect to the starter bus if it is set, and\n         * otherwise to the bus that is appropriate for the scope\n         * we are running in */\n\n        e = secure_getenv(\"DBUS_STARTER_BUS_TYPE\");\n        if (e) {\n                if (streq(e, \"system\"))\n                        return sd_bus_open_system_with_description(ret, description);\n                else if (STR_IN_SET(e, \"session\", \"user\"))\n                        return sd_bus_open_user_with_description(ret, description);\n        }\n\n        e = secure_getenv(\"DBUS_STARTER_ADDRESS\");\n        if (!e) {\n                if (cg_pid_get_owner_uid(0, NULL) >= 0)\n                        return sd_bus_open_user_with_description(ret, description);\n                else\n                        return sd_bus_open_system_with_description(ret, description);\n        }\n\n        r = sd_bus_new(&b);\n        if (r < 0)\n                return r;\n\n        r = sd_bus_set_address(b, e);\n        if (r < 0)\n                return r;\n\n        b->bus_client = true;\n\n        /* We don't know whether the bus is trusted or not, so better\n         * be safe, and authenticate everything */\n        b->trusted = false;\n        b->is_local = false;\n        b->creds_mask |= SD_BUS_CREDS_UID | SD_BUS_CREDS_EUID | SD_BUS_CREDS_EFFECTIVE_CAPS;\n\n        r = sd_bus_start(b);\n        if (r < 0)\n                return r;\n\n        *ret = TAKE_PTR(b);\n        return 0;\n}\n\n_public_ int sd_bus_open(sd_bus **ret) {\n        return sd_bus_open_with_description(ret, NULL);\n}\n\nint bus_set_address_system(sd_bus *b) {\n        const char *e;\n        assert(b);\n\n        e = secure_getenv(\"DBUS_SYSTEM_BUS_ADDRESS\");\n        if (e)\n                return sd_bus_set_address(b, e);\n\n        return sd_bus_set_address(b, DEFAULT_SYSTEM_BUS_ADDRESS);\n}\n\n_public_ int sd_bus_open_system_with_description(sd_bus **ret, const char *description) {\n        _cleanup_(bus_freep) sd_bus *b = NULL;\n        int r;\n\n        assert_return(ret, -EINVAL);\n\n        r = sd_bus_new(&b);\n        if (r < 0)\n                return r;\n\n        if (description) {\n                r = sd_bus_set_description(b, description);\n                if (r < 0)\n                        return r;\n        }\n\n        r = bus_set_address_system(b);\n        if (r < 0)\n                return r;\n\n        b->bus_client = true;\n        b->is_system = true;\n\n        /* Let's do per-method access control on the system bus. We\n         * need the caller's UID and capability set for that. */\n        b->trusted = false;\n        b->creds_mask |= SD_BUS_CREDS_UID | SD_BUS_CREDS_EUID | SD_BUS_CREDS_EFFECTIVE_CAPS;\n        b->is_local = true;\n\n        r = sd_bus_start(b);\n        if (r < 0)\n                return r;\n\n        *ret = TAKE_PTR(b);\n        return 0;\n}\n\n_public_ int sd_bus_open_system(sd_bus **ret) {\n        return sd_bus_open_system_with_description(ret, NULL);\n}\n\nint bus_set_address_user(sd_bus *b) {\n        const char *e;\n        _cleanup_free_ char *ee = NULL, *s = NULL;\n\n        assert(b);\n\n        e = secure_getenv(\"DBUS_SESSION_BUS_ADDRESS\");\n        if (e)\n                return sd_bus_set_address(b, e);\n\n        e = secure_getenv(\"XDG_RUNTIME_DIR\");\n        if (!e)\n                return -ENOENT;\n\n        ee = bus_address_escape(e);\n        if (!ee)\n                return -ENOMEM;\n\n        if (asprintf(&s, DEFAULT_USER_BUS_ADDRESS_FMT, ee) < 0)\n                return -ENOMEM;\n\n        b->address = TAKE_PTR(s);\n\n        return 0;\n}\n\n_public_ int sd_bus_open_user_with_description(sd_bus **ret, const char *description) {\n        _cleanup_(bus_freep) sd_bus *b = NULL;\n        int r;\n\n        assert_return(ret, -EINVAL);\n\n        r = sd_bus_new(&b);\n        if (r < 0)\n                return r;\n\n        if (description) {\n                r = sd_bus_set_description(b, description);\n                if (r < 0)\n                        return r;\n        }\n\n        r = bus_set_address_user(b);\n        if (r < 0)\n                return r;\n\n        b->bus_client = true;\n        b->is_user = true;\n\n        /* We don't do any per-method access control on the user bus. */\n        b->trusted = true;\n        b->is_local = true;\n\n        r = sd_bus_start(b);\n        if (r < 0)\n                return r;\n\n        *ret = TAKE_PTR(b);\n        return 0;\n}\n\n_public_ int sd_bus_open_user(sd_bus **ret) {\n        return sd_bus_open_user_with_description(ret, NULL);\n}\n\nint bus_set_address_system_remote(sd_bus *b, const char *host) {\n        _cleanup_free_ char *e = NULL;\n        char *m = NULL, *c = NULL, *a, *rbracket = NULL, *p = NULL;\n\n        assert(b);\n        assert(host);\n\n        /* Skip \":\"s in ipv6 addresses */\n        if (*host == '[') {\n                char *t;\n\n                rbracket = strchr(host, ']');\n                if (!rbracket)\n                        return -EINVAL;\n                t = strndupa(host + 1, rbracket - host - 1);\n                e = bus_address_escape(t);\n                if (!e)\n                        return -ENOMEM;\n        } else if ((a = strchr(host, '@'))) {\n                if (*(a + 1) == '[') {\n                        _cleanup_free_ char *t = NULL;\n\n                        rbracket = strchr(a + 1, ']');\n                        if (!rbracket)\n                                return -EINVAL;\n                        t = new0(char, strlen(host));\n                        if (!t)\n                                return -ENOMEM;\n                        strncat(t, host, a - host + 1);\n                        strncat(t, a + 2, rbracket - a - 2);\n                        e = bus_address_escape(t);\n                        if (!e)\n                                return -ENOMEM;\n                } else if (*(a + 1) == '\\0' || strchr(a + 1, '@'))\n                        return -EINVAL;\n        }\n\n        /* Let's see if a port was given */\n        m = strchr(rbracket ? rbracket + 1 : host, ':');\n        if (m) {\n                char *t;\n                bool got_forward_slash = false;\n\n                p = m + 1;\n\n                t = strchr(p, '/');\n                if (t) {\n                        p = strndupa(p, t - p);\n                        got_forward_slash = true;\n                }\n\n                if (!in_charset(p, \"0123456789\") || *p == '\\0') {\n                        if (!machine_name_is_valid(p) || got_forward_slash)\n                                return -EINVAL;\n\n                        m = TAKE_PTR(p);\n                        goto interpret_port_as_machine_old_syntax;\n                }\n        }\n\n        /* Let's see if a machine was given */\n        m = strchr(rbracket ? rbracket + 1 : host, '/');\n        if (m) {\n                m++;\ninterpret_port_as_machine_old_syntax:\n                /* Let's make sure this is not a port of some kind,\n                 * and is a valid machine name. */\n                if (!in_charset(m, \"0123456789\") && machine_name_is_valid(m))\n                        c = strjoina(\",argv\", p ? \"7\" : \"5\", \"=--machine=\", m);\n        }\n\n        if (!e) {\n                char *t;\n\n                t = strndupa(host, strcspn(host, \":/\"));\n\n                e = bus_address_escape(t);\n                if (!e)\n                        return -ENOMEM;\n        }\n\n        a = strjoin(\"unixexec:path=ssh,argv1=-xT\", p ? \",argv2=-p,argv3=\" : \"\", strempty(p),\n                                \",argv\", p ? \"4\" : \"2\", \"=--,argv\", p ? \"5\" : \"3\", \"=\", e,\n                                \",argv\", p ? \"6\" : \"4\", \"=systemd-stdio-bridge\", c);\n        if (!a)\n                return -ENOMEM;\n\n        return free_and_replace(b->address, a);\n}\n\n_public_ int sd_bus_open_system_remote(sd_bus **ret, const char *host) {\n        _cleanup_(bus_freep) sd_bus *b = NULL;\n        int r;\n\n        assert_return(host, -EINVAL);\n        assert_return(ret, -EINVAL);\n\n        r = sd_bus_new(&b);\n        if (r < 0)\n                return r;\n\n        r = bus_set_address_system_remote(b, host);\n        if (r < 0)\n                return r;\n\n        b->bus_client = true;\n        b->trusted = false;\n        b->is_system = true;\n        b->is_local = false;\n\n        r = sd_bus_start(b);\n        if (r < 0)\n                return r;\n\n        *ret = TAKE_PTR(b);\n        return 0;\n}\n\nint bus_set_address_system_machine(sd_bus *b, const char *machine) {\n        _cleanup_free_ char *e = NULL;\n        char *a;\n\n        assert(b);\n        assert(machine);\n\n        e = bus_address_escape(machine);\n        if (!e)\n                return -ENOMEM;\n\n        a = strjoin(\"x-machine-unix:machine=\", e);\n        if (!a)\n                return -ENOMEM;\n\n        return free_and_replace(b->address, a);\n}\n\n_public_ int sd_bus_open_system_machine(sd_bus **ret, const char *machine) {\n        _cleanup_(bus_freep) sd_bus *b = NULL;\n        int r;\n\n        assert_return(machine, -EINVAL);\n        assert_return(ret, -EINVAL);\n        assert_return(streq(machine, \".host\") || machine_name_is_valid(machine), -EINVAL);\n\n        r = sd_bus_new(&b);\n        if (r < 0)\n                return r;\n\n        r = bus_set_address_system_machine(b, machine);\n        if (r < 0)\n                return r;\n\n        b->bus_client = true;\n        b->trusted = false;\n        b->is_system = true;\n        b->is_local = false;\n\n        r = sd_bus_start(b);\n        if (r < 0)\n                return r;\n\n        *ret = TAKE_PTR(b);\n        return 0;\n}\n\n_public_ void sd_bus_close(sd_bus *bus) {\n        if (!bus)\n                return;\n        if (bus->state == BUS_CLOSED)\n                return;\n        if (bus_pid_changed(bus))\n                return;\n\n        /* Don't leave ssh hanging around */\n        bus_kill_exec(bus);\n\n        bus_set_state(bus, BUS_CLOSED);\n\n        sd_bus_detach_event(bus);\n\n        /* Drop all queued messages so that they drop references to\n         * the bus object and the bus may be freed */\n        bus_reset_queues(bus);\n\n        bus_close_io_fds(bus);\n        bus_close_inotify_fd(bus);\n}\n\n_public_ sd_bus *sd_bus_close_unref(sd_bus *bus) {\n        if (!bus)\n                return NULL;\n\n        sd_bus_close(bus);\n\n        return sd_bus_unref(bus);\n}\n\n_public_ sd_bus* sd_bus_flush_close_unref(sd_bus *bus) {\n        if (!bus)\n                return NULL;\n\n        /* Have to do this before flush() to prevent hang */\n        bus_kill_exec(bus);\n        sd_bus_flush(bus);\n\n        return sd_bus_close_unref(bus);\n}\n\nvoid bus_enter_closing(sd_bus *bus) {\n        assert(bus);\n\n        if (!IN_SET(bus->state, BUS_WATCH_BIND, BUS_OPENING, BUS_AUTHENTICATING, BUS_HELLO, BUS_RUNNING))\n                return;\n\n        bus_set_state(bus, BUS_CLOSING);\n}\n\nDEFINE_PUBLIC_TRIVIAL_REF_UNREF_FUNC(sd_bus, sd_bus, bus_free);\n\n_public_ int sd_bus_is_open(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return BUS_IS_OPEN(bus->state);\n}\n\n_public_ int sd_bus_is_ready(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return bus->state == BUS_RUNNING;\n}\n\n_public_ int sd_bus_can_send(sd_bus *bus, char type) {\n        int r;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->state != BUS_UNSET, -ENOTCONN);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (bus->is_monitor)\n                return 0;\n\n        if (type == SD_BUS_TYPE_UNIX_FD) {\n                if (!bus->accept_fd)\n                        return 0;\n\n                r = bus_ensure_running(bus);\n                if (r < 0)\n                        return r;\n\n                return bus->can_fds;\n        }\n\n        return bus_type_is_valid(type);\n}\n\n_public_ int sd_bus_get_bus_id(sd_bus *bus, sd_id128_t *id) {\n        int r;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(id, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        r = bus_ensure_running(bus);\n        if (r < 0)\n                return r;\n\n        *id = bus->server_id;\n        return 0;\n}\n\n#define COOKIE_CYCLED (UINT32_C(1) << 31)\n\nstatic uint64_t cookie_inc(uint64_t cookie) {\n\n        /* Stay within the 32bit range, since classic D-Bus can't deal with more */\n        if (cookie >= UINT32_MAX)\n                return COOKIE_CYCLED; /* Don't go back to zero, but use the highest bit for checking\n                                       * whether we are looping. */\n\n        return cookie + 1;\n}\n\nstatic int next_cookie(sd_bus *b) {\n        uint64_t new_cookie;\n\n        assert(b);\n\n        new_cookie = cookie_inc(b->cookie);\n\n        /* Small optimization: don't bother with checking for cookie reuse until we overran cookiespace at\n         * least once, but then do it thorougly. */\n        if (FLAGS_SET(new_cookie, COOKIE_CYCLED)) {\n                uint32_t i;\n\n                /* Check if the cookie is currently in use. If so, pick the next one */\n                for (i = 0; i < COOKIE_CYCLED; i++) {\n                        if (!ordered_hashmap_contains(b->reply_callbacks, &new_cookie))\n                                goto good;\n\n                        new_cookie = cookie_inc(new_cookie);\n                }\n\n                /* Can't fulfill request */\n                return -EBUSY;\n        }\n\ngood:\n        b->cookie = new_cookie;\n        return 0;\n}\n\nstatic int bus_seal_message(sd_bus *b, sd_bus_message *m, usec_t timeout) {\n        int r;\n\n        assert(b);\n        assert(m);\n\n        if (m->sealed) {\n                /* If we copy the same message to multiple\n                 * destinations, avoid using the same cookie\n                 * numbers. */\n                b->cookie = MAX(b->cookie, BUS_MESSAGE_COOKIE(m));\n                return 0;\n        }\n\n        if (timeout == 0) {\n                r = sd_bus_get_method_call_timeout(b, &timeout);\n                if (r < 0)\n                        return r;\n        }\n\n        if (!m->sender && b->patch_sender) {\n                r = sd_bus_message_set_sender(m, b->patch_sender);\n                if (r < 0)\n                        return r;\n        }\n\n        r = next_cookie(b);\n        if (r < 0)\n                return r;\n\n        return sd_bus_message_seal(m, b->cookie, timeout);\n}\n\nstatic int bus_remarshal_message(sd_bus *b, sd_bus_message **m) {\n        bool remarshal = false;\n\n        assert(b);\n\n        /* wrong packet version */\n        if (b->message_version != 0 && b->message_version != (*m)->header->version)\n                remarshal = true;\n\n        /* wrong packet endianness */\n        if (b->message_endian != 0 && b->message_endian != (*m)->header->endian)\n                remarshal = true;\n\n        return remarshal ? bus_message_remarshal(b, m) : 0;\n}\n\nint bus_seal_synthetic_message(sd_bus *b, sd_bus_message *m) {\n        assert(b);\n        assert(m);\n\n        /* Fake some timestamps, if they were requested, and not\n         * already initialized */\n        if (b->attach_timestamp) {\n                if (m->realtime <= 0)\n                        m->realtime = now(CLOCK_REALTIME);\n\n                if (m->monotonic <= 0)\n                        m->monotonic = now(CLOCK_MONOTONIC);\n        }\n\n        /* The bus specification says the serial number cannot be 0,\n         * hence let's fill something in for synthetic messages. Since\n         * synthetic messages might have a fake sender and we don't\n         * want to interfere with the real sender's serial numbers we\n         * pick a fixed, artificial one. We use (uint32_t) -1 rather\n         * than (uint64_t) -1 since dbus1 only had 32bit identifiers,\n         * even though kdbus can do 64bit. */\n        return sd_bus_message_seal(m, 0xFFFFFFFFULL, 0);\n}\n\nstatic int bus_write_message(sd_bus *bus, sd_bus_message *m, size_t *idx) {\n        int r;\n\n        assert(bus);\n        assert(m);\n\n        r = bus_socket_write_message(bus, m, idx);\n        if (r <= 0)\n                return r;\n\n        if (*idx >= BUS_MESSAGE_SIZE(m))\n                log_debug(\"Sent message type=%s sender=%s destination=%s path=%s interface=%s member=%s cookie=%\" PRIu64 \" reply_cookie=%\" PRIu64 \" signature=%s error-name=%s error-message=%s\",\n                          bus_message_type_to_string(m->header->type),\n                          strna(sd_bus_message_get_sender(m)),\n                          strna(sd_bus_message_get_destination(m)),\n                          strna(sd_bus_message_get_path(m)),\n                          strna(sd_bus_message_get_interface(m)),\n                          strna(sd_bus_message_get_member(m)),\n                          BUS_MESSAGE_COOKIE(m),\n                          m->reply_cookie,\n                          strna(m->root_container.signature),\n                          strna(m->error.name),\n                          strna(m->error.message));\n\n        return r;\n}\n\nstatic int dispatch_wqueue(sd_bus *bus) {\n        int r, ret = 0;\n\n        assert(bus);\n        assert(IN_SET(bus->state, BUS_RUNNING, BUS_HELLO));\n\n        while (bus->wqueue_size > 0) {\n\n                r = bus_write_message(bus, bus->wqueue[0], &bus->windex);\n                if (r < 0)\n                        return r;\n                else if (r == 0)\n                        /* Didn't do anything this time */\n                        return ret;\n                else if (bus->windex >= BUS_MESSAGE_SIZE(bus->wqueue[0])) {\n                        /* Fully written. Let's drop the entry from\n                         * the queue.\n                         *\n                         * This isn't particularly optimized, but\n                         * well, this is supposed to be our worst-case\n                         * buffer only, and the socket buffer is\n                         * supposed to be our primary buffer, and if\n                         * it got full, then all bets are off\n                         * anyway. */\n\n                        bus->wqueue_size--;\n                        bus_message_unref_queued(bus->wqueue[0], bus);\n                        memmove(bus->wqueue, bus->wqueue + 1, sizeof(sd_bus_message*) * bus->wqueue_size);\n                        bus->windex = 0;\n\n                        ret = 1;\n                }\n        }\n\n        return ret;\n}\n\nstatic int bus_read_message(sd_bus *bus, bool hint_priority, int64_t priority) {\n        assert(bus);\n\n        return bus_socket_read_message(bus);\n}\n\nint bus_rqueue_make_room(sd_bus *bus) {\n        assert(bus);\n\n        if (bus->rqueue_size >= BUS_RQUEUE_MAX)\n                return -ENOBUFS;\n\n        if (!GREEDY_REALLOC(bus->rqueue, bus->rqueue_allocated, bus->rqueue_size + 1))\n                return -ENOMEM;\n\n        return 0;\n}\n\nstatic void rqueue_drop_one(sd_bus *bus, size_t i) {\n        assert(bus);\n        assert(i < bus->rqueue_size);\n\n        bus_message_unref_queued(bus->rqueue[i], bus);\n        memmove(bus->rqueue + i, bus->rqueue + i + 1, sizeof(sd_bus_message*) * (bus->rqueue_size - i - 1));\n        bus->rqueue_size--;\n}\n\nstatic int dispatch_rqueue(sd_bus *bus, bool hint_priority, int64_t priority, sd_bus_message **m) {\n        int r, ret = 0;\n\n        assert(bus);\n        assert(m);\n        assert(IN_SET(bus->state, BUS_RUNNING, BUS_HELLO));\n\n        /* Note that the priority logic is only available on kdbus,\n         * where the rqueue is unused. We check the rqueue here\n         * anyway, because it's simple... */\n\n        for (;;) {\n                if (bus->rqueue_size > 0) {\n                        /* Dispatch a queued message */\n                        *m = sd_bus_message_ref(bus->rqueue[0]);\n                        rqueue_drop_one(bus, 0);\n                        return 1;\n                }\n\n                /* Try to read a new message */\n                r = bus_read_message(bus, hint_priority, priority);\n                if (r < 0)\n                        return r;\n                if (r == 0) {\n                        *m = NULL;\n                        return ret;\n                }\n\n                ret = 1;\n        }\n}\n\n_public_ int sd_bus_send(sd_bus *bus, sd_bus_message *_m, uint64_t *cookie) {\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = sd_bus_message_ref(_m);\n        int r;\n\n        assert_return(m, -EINVAL);\n\n        if (!bus)\n                bus = m->bus;\n\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (!BUS_IS_OPEN(bus->state))\n                return -ENOTCONN;\n\n        if (m->n_fds > 0) {\n                r = sd_bus_can_send(bus, SD_BUS_TYPE_UNIX_FD);\n                if (r < 0)\n                        return r;\n                if (r == 0)\n                        return -EOPNOTSUPP;\n        }\n\n        /* If the cookie number isn't kept, then we know that no reply\n         * is expected */\n        if (!cookie && !m->sealed)\n                m->header->flags |= BUS_MESSAGE_NO_REPLY_EXPECTED;\n\n        r = bus_seal_message(bus, m, 0);\n        if (r < 0)\n                return r;\n\n        /* Remarshall if we have to. This will possibly unref the\n         * message and place a replacement in m */\n        r = bus_remarshal_message(bus, &m);\n        if (r < 0)\n                return r;\n\n        /* If this is a reply and no reply was requested, then let's\n         * suppress this, if we can */\n        if (m->dont_send)\n                goto finish;\n\n        if (IN_SET(bus->state, BUS_RUNNING, BUS_HELLO) && bus->wqueue_size <= 0) {\n                size_t idx = 0;\n\n                r = bus_write_message(bus, m, &idx);\n                if (r < 0) {\n                        if (ERRNO_IS_DISCONNECT(r)) {\n                                bus_enter_closing(bus);\n                                return -ECONNRESET;\n                        }\n\n                        return r;\n                }\n\n                if (idx < BUS_MESSAGE_SIZE(m))  {\n                        /* Wasn't fully written. So let's remember how\n                         * much was written. Note that the first entry\n                         * of the wqueue array is always allocated so\n                         * that we always can remember how much was\n                         * written. */\n                        bus->wqueue[0] = bus_message_ref_queued(m, bus);\n                        bus->wqueue_size = 1;\n                        bus->windex = idx;\n                }\n\n        } else {\n                /* Just append it to the queue. */\n\n                if (bus->wqueue_size >= BUS_WQUEUE_MAX)\n                        return -ENOBUFS;\n\n                if (!GREEDY_REALLOC(bus->wqueue, bus->wqueue_allocated, bus->wqueue_size + 1))\n                        return -ENOMEM;\n\n                bus->wqueue[bus->wqueue_size++] = bus_message_ref_queued(m, bus);\n        }\n\nfinish:\n        if (cookie)\n                *cookie = BUS_MESSAGE_COOKIE(m);\n\n        return 1;\n}\n\n_public_ int sd_bus_send_to(sd_bus *bus, sd_bus_message *m, const char *destination, uint64_t *cookie) {\n        int r;\n\n        assert_return(m, -EINVAL);\n\n        if (!bus)\n                bus = m->bus;\n\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (!BUS_IS_OPEN(bus->state))\n                return -ENOTCONN;\n\n        if (!streq_ptr(m->destination, destination)) {\n\n                if (!destination)\n                        return -EEXIST;\n\n                r = sd_bus_message_set_destination(m, destination);\n                if (r < 0)\n                        return r;\n        }\n\n        return sd_bus_send(bus, m, cookie);\n}\n\nstatic usec_t calc_elapse(sd_bus *bus, uint64_t usec) {\n        assert(bus);\n\n        if (usec == (uint64_t) -1)\n                return 0;\n\n        /* We start all timeouts the instant we enter BUS_HELLO/BUS_RUNNING state, so that the don't run in parallel\n         * with any connection setup states. Hence, if a method callback is started earlier than that we just store the\n         * relative timestamp, and afterwards the absolute one. */\n\n        if (IN_SET(bus->state, BUS_WATCH_BIND, BUS_OPENING, BUS_AUTHENTICATING))\n                return usec;\n        else\n                return now(CLOCK_MONOTONIC) + usec;\n}\n\nstatic int timeout_compare(const void *a, const void *b) {\n        const struct reply_callback *x = a, *y = b;\n\n        if (x->timeout_usec != 0 && y->timeout_usec == 0)\n                return -1;\n\n        if (x->timeout_usec == 0 && y->timeout_usec != 0)\n                return 1;\n\n        return CMP(x->timeout_usec, y->timeout_usec);\n}\n\n_public_ int sd_bus_call_async(\n                sd_bus *bus,\n                sd_bus_slot **slot,\n                sd_bus_message *_m,\n                sd_bus_message_handler_t callback,\n                void *userdata,\n                uint64_t usec) {\n\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = sd_bus_message_ref(_m);\n        _cleanup_(sd_bus_slot_unrefp) sd_bus_slot *s = NULL;\n        int r;\n\n        assert_return(m, -EINVAL);\n        assert_return(m->header->type == SD_BUS_MESSAGE_METHOD_CALL, -EINVAL);\n        assert_return(!m->sealed || (!!callback == !(m->header->flags & BUS_MESSAGE_NO_REPLY_EXPECTED)), -EINVAL);\n\n        if (!bus)\n                bus = m->bus;\n\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (!BUS_IS_OPEN(bus->state))\n                return -ENOTCONN;\n\n        /* If no callback is specified and there's no interest in a slot, then there's no reason to ask for a reply */\n        if (!callback && !slot && !m->sealed)\n                m->header->flags |= BUS_MESSAGE_NO_REPLY_EXPECTED;\n\n        r = ordered_hashmap_ensure_allocated(&bus->reply_callbacks, &uint64_hash_ops);\n        if (r < 0)\n                return r;\n\n        r = prioq_ensure_allocated(&bus->reply_callbacks_prioq, timeout_compare);\n        if (r < 0)\n                return r;\n\n        r = bus_seal_message(bus, m, usec);\n        if (r < 0)\n                return r;\n\n        r = bus_remarshal_message(bus, &m);\n        if (r < 0)\n                return r;\n\n        if (slot || callback) {\n                s = bus_slot_allocate(bus, !slot, BUS_REPLY_CALLBACK, sizeof(struct reply_callback), userdata);\n                if (!s)\n                        return -ENOMEM;\n\n                s->reply_callback.callback = callback;\n\n                s->reply_callback.cookie = BUS_MESSAGE_COOKIE(m);\n                r = ordered_hashmap_put(bus->reply_callbacks, &s->reply_callback.cookie, &s->reply_callback);\n                if (r < 0) {\n                        s->reply_callback.cookie = 0;\n                        return r;\n                }\n\n                s->reply_callback.timeout_usec = calc_elapse(bus, m->timeout);\n                if (s->reply_callback.timeout_usec != 0) {\n                        r = prioq_put(bus->reply_callbacks_prioq, &s->reply_callback, &s->reply_callback.prioq_idx);\n                        if (r < 0) {\n                                s->reply_callback.timeout_usec = 0;\n                                return r;\n                        }\n                }\n        }\n\n        r = sd_bus_send(bus, m, s ? &s->reply_callback.cookie : NULL);\n        if (r < 0)\n                return r;\n\n        if (slot)\n                *slot = s;\n        s = NULL;\n\n        return r;\n}\n\nint bus_ensure_running(sd_bus *bus) {\n        int r;\n\n        assert(bus);\n\n        if (IN_SET(bus->state, BUS_UNSET, BUS_CLOSED, BUS_CLOSING))\n                return -ENOTCONN;\n        if (bus->state == BUS_RUNNING)\n                return 1;\n\n        for (;;) {\n                r = sd_bus_process(bus, NULL);\n                if (r < 0)\n                        return r;\n                if (bus->state == BUS_RUNNING)\n                        return 1;\n                if (r > 0)\n                        continue;\n\n                r = sd_bus_wait(bus, (uint64_t) -1);\n                if (r < 0)\n                        return r;\n        }\n}\n\n_public_ int sd_bus_call(\n                sd_bus *bus,\n                sd_bus_message *_m,\n                uint64_t usec,\n                sd_bus_error *error,\n                sd_bus_message **reply) {\n\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = sd_bus_message_ref(_m);\n        usec_t timeout;\n        uint64_t cookie;\n        size_t i;\n        int r;\n\n        bus_assert_return(m, -EINVAL, error);\n        bus_assert_return(m->header->type == SD_BUS_MESSAGE_METHOD_CALL, -EINVAL, error);\n        bus_assert_return(!(m->header->flags & BUS_MESSAGE_NO_REPLY_EXPECTED), -EINVAL, error);\n        bus_assert_return(!bus_error_is_dirty(error), -EINVAL, error);\n\n        if (!bus)\n                bus = m->bus;\n\n        bus_assert_return(!bus_pid_changed(bus), -ECHILD, error);\n\n        if (!BUS_IS_OPEN(bus->state)) {\n                r = -ENOTCONN;\n                goto fail;\n        }\n\n        r = bus_ensure_running(bus);\n        if (r < 0)\n                goto fail;\n\n        i = bus->rqueue_size;\n\n        r = bus_seal_message(bus, m, usec);\n        if (r < 0)\n                goto fail;\n\n        r = bus_remarshal_message(bus, &m);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_send(bus, m, &cookie);\n        if (r < 0)\n                goto fail;\n\n        timeout = calc_elapse(bus, m->timeout);\n\n        for (;;) {\n                usec_t left;\n\n                while (i < bus->rqueue_size) {\n                        _cleanup_(sd_bus_message_unrefp) sd_bus_message *incoming = NULL;\n\n                        incoming = sd_bus_message_ref(bus->rqueue[i]);\n\n                        if (incoming->reply_cookie == cookie) {\n                                /* Found a match! */\n\n                                rqueue_drop_one(bus, i);\n                                log_debug_bus_message(incoming);\n\n                                if (incoming->header->type == SD_BUS_MESSAGE_METHOD_RETURN) {\n\n                                        if (incoming->n_fds <= 0 || bus->accept_fd) {\n                                                if (reply)\n                                                        *reply = TAKE_PTR(incoming);\n\n                                                return 1;\n                                        }\n\n                                        return sd_bus_error_setf(error, SD_BUS_ERROR_INCONSISTENT_MESSAGE, \"Reply message contained file descriptors which I couldn't accept. Sorry.\");\n\n                                } else if (incoming->header->type == SD_BUS_MESSAGE_METHOD_ERROR)\n                                        return sd_bus_error_copy(error, &incoming->error);\n                                else {\n                                        r = -EIO;\n                                        goto fail;\n                                }\n\n                        } else if (BUS_MESSAGE_COOKIE(incoming) == cookie &&\n                                   bus->unique_name &&\n                                   incoming->sender &&\n                                   streq(bus->unique_name, incoming->sender)) {\n\n                                rqueue_drop_one(bus, i);\n\n                                /* Our own message? Somebody is trying to send its own client a message,\n                                 * let's not dead-lock, let's fail immediately. */\n\n                                r = -ELOOP;\n                                goto fail;\n                        }\n\n                        /* Try to read more, right-away */\n                        i++;\n                }\n\n                r = bus_read_message(bus, false, 0);\n                if (r < 0) {\n                        if (ERRNO_IS_DISCONNECT(r)) {\n                                bus_enter_closing(bus);\n                                r = -ECONNRESET;\n                        }\n\n                        goto fail;\n                }\n                if (r > 0)\n                        continue;\n\n                if (timeout > 0) {\n                        usec_t n;\n\n                        n = now(CLOCK_MONOTONIC);\n                        if (n >= timeout) {\n                                r = -ETIMEDOUT;\n                                goto fail;\n                        }\n\n                        left = timeout - n;\n                } else\n                        left = (uint64_t) -1;\n\n                r = bus_poll(bus, true, left);\n                if (r < 0)\n                        goto fail;\n                if (r == 0) {\n                        r = -ETIMEDOUT;\n                        goto fail;\n                }\n\n                r = dispatch_wqueue(bus);\n                if (r < 0) {\n                        if (ERRNO_IS_DISCONNECT(r)) {\n                                bus_enter_closing(bus);\n                                r = -ECONNRESET;\n                        }\n\n                        goto fail;\n                }\n        }\n\nfail:\n        return sd_bus_error_set_errno(error, r);\n}\n\n_public_ int sd_bus_get_fd(sd_bus *bus) {\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(bus->input_fd == bus->output_fd, -EPERM);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (bus->state == BUS_CLOSED)\n                return -ENOTCONN;\n\n        if (bus->inotify_fd >= 0)\n                return bus->inotify_fd;\n\n        if (bus->input_fd >= 0)\n                return bus->input_fd;\n\n        return -ENOTCONN;\n}\n\n_public_ int sd_bus_get_events(sd_bus *bus) {\n        int flags = 0;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        switch (bus->state) {\n\n        case BUS_UNSET:\n        case BUS_CLOSED:\n                return -ENOTCONN;\n\n        case BUS_WATCH_BIND:\n                flags |= POLLIN;\n                break;\n\n        case BUS_OPENING:\n                flags |= POLLOUT;\n                break;\n\n        case BUS_AUTHENTICATING:\n                if (bus_socket_auth_needs_write(bus))\n                        flags |= POLLOUT;\n\n                flags |= POLLIN;\n                break;\n\n        case BUS_RUNNING:\n        case BUS_HELLO:\n                if (bus->rqueue_size <= 0)\n                        flags |= POLLIN;\n                if (bus->wqueue_size > 0)\n                        flags |= POLLOUT;\n                break;\n\n        case BUS_CLOSING:\n                break;\n\n        default:\n                assert_not_reached(\"Unknown state\");\n        }\n\n        return flags;\n}\n\n_public_ int sd_bus_get_timeout(sd_bus *bus, uint64_t *timeout_usec) {\n        struct reply_callback *c;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(timeout_usec, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (!BUS_IS_OPEN(bus->state) && bus->state != BUS_CLOSING)\n                return -ENOTCONN;\n\n        if (bus->track_queue) {\n                *timeout_usec = 0;\n                return 1;\n        }\n\n        switch (bus->state) {\n\n        case BUS_AUTHENTICATING:\n                *timeout_usec = bus->auth_timeout;\n                return 1;\n\n        case BUS_RUNNING:\n        case BUS_HELLO:\n                if (bus->rqueue_size > 0) {\n                        *timeout_usec = 0;\n                        return 1;\n                }\n\n                c = prioq_peek(bus->reply_callbacks_prioq);\n                if (!c) {\n                        *timeout_usec = (uint64_t) -1;\n                        return 0;\n                }\n\n                if (c->timeout_usec == 0) {\n                        *timeout_usec = (uint64_t) -1;\n                        return 0;\n                }\n\n                *timeout_usec = c->timeout_usec;\n                return 1;\n\n        case BUS_CLOSING:\n                *timeout_usec = 0;\n                return 1;\n\n        case BUS_WATCH_BIND:\n        case BUS_OPENING:\n                *timeout_usec = (uint64_t) -1;\n                return 0;\n\n        default:\n                assert_not_reached(\"Unknown or unexpected stat\");\n        }\n}\n\nstatic int process_timeout(sd_bus *bus) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error_buffer = SD_BUS_ERROR_NULL;\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message* m = NULL;\n        struct reply_callback *c;\n        sd_bus_slot *slot;\n        bool is_hello;\n        usec_t n;\n        int r;\n\n        assert(bus);\n        assert(IN_SET(bus->state, BUS_RUNNING, BUS_HELLO));\n\n        c = prioq_peek(bus->reply_callbacks_prioq);\n        if (!c)\n                return 0;\n\n        n = now(CLOCK_MONOTONIC);\n        if (c->timeout_usec > n)\n                return 0;\n\n        r = bus_message_new_synthetic_error(\n                        bus,\n                        c->cookie,\n                        &SD_BUS_ERROR_MAKE_CONST(SD_BUS_ERROR_NO_REPLY, \"Method call timed out\"),\n                        &m);\n        if (r < 0)\n                return r;\n\n        m->read_counter = ++bus->read_counter;\n\n        r = bus_seal_synthetic_message(bus, m);\n        if (r < 0)\n                return r;\n\n        assert_se(prioq_pop(bus->reply_callbacks_prioq) == c);\n        c->timeout_usec = 0;\n\n        ordered_hashmap_remove(bus->reply_callbacks, &c->cookie);\n        c->cookie = 0;\n\n        slot = container_of(c, sd_bus_slot, reply_callback);\n\n        bus->iteration_counter++;\n\n        is_hello = bus->state == BUS_HELLO && c->callback == hello_callback;\n\n        bus->current_message = m;\n        bus->current_slot = sd_bus_slot_ref(slot);\n        bus->current_handler = c->callback;\n        bus->current_userdata = slot->userdata;\n        r = c->callback(m, slot->userdata, &error_buffer);\n        bus->current_userdata = NULL;\n        bus->current_handler = NULL;\n        bus->current_slot = NULL;\n        bus->current_message = NULL;\n\n        if (slot->floating)\n                bus_slot_disconnect(slot, true);\n\n        sd_bus_slot_unref(slot);\n\n        /* When this is the hello message and it timed out, then make sure to propagate the error up, don't just log\n         * and ignore the callback handler's return value. */\n        if (is_hello)\n                return r;\n\n        return bus_maybe_reply_error(m, r, &error_buffer);\n}\n\nstatic int process_hello(sd_bus *bus, sd_bus_message *m) {\n        assert(bus);\n        assert(m);\n\n        if (bus->state != BUS_HELLO)\n                return 0;\n\n        /* Let's make sure the first message on the bus is the HELLO\n         * reply. But note that we don't actually parse the message\n         * here (we leave that to the usual handling), we just verify\n         * we don't let any earlier msg through. */\n\n        if (!IN_SET(m->header->type, SD_BUS_MESSAGE_METHOD_RETURN, SD_BUS_MESSAGE_METHOD_ERROR))\n                return -EIO;\n\n        if (m->reply_cookie != 1)\n                return -EIO;\n\n        return 0;\n}\n\nstatic int process_reply(sd_bus *bus, sd_bus_message *m) {\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *synthetic_reply = NULL;\n        _cleanup_(sd_bus_error_free) sd_bus_error error_buffer = SD_BUS_ERROR_NULL;\n        struct reply_callback *c;\n        sd_bus_slot *slot;\n        bool is_hello;\n        int r;\n\n        assert(bus);\n        assert(m);\n\n        if (!IN_SET(m->header->type, SD_BUS_MESSAGE_METHOD_RETURN, SD_BUS_MESSAGE_METHOD_ERROR))\n                return 0;\n\n        if (m->destination && bus->unique_name && !streq_ptr(m->destination, bus->unique_name))\n                return 0;\n\n        c = ordered_hashmap_remove(bus->reply_callbacks, &m->reply_cookie);\n        if (!c)\n                return 0;\n\n        c->cookie = 0;\n\n        slot = container_of(c, sd_bus_slot, reply_callback);\n\n        if (m->n_fds > 0 && !bus->accept_fd) {\n\n                /* If the reply contained a file descriptor which we\n                 * didn't want we pass an error instead. */\n\n                r = bus_message_new_synthetic_error(\n                                bus,\n                                m->reply_cookie,\n                                &SD_BUS_ERROR_MAKE_CONST(SD_BUS_ERROR_INCONSISTENT_MESSAGE, \"Reply message contained file descriptor\"),\n                                &synthetic_reply);\n                if (r < 0)\n                        return r;\n\n                /* Copy over original timestamp */\n                synthetic_reply->realtime = m->realtime;\n                synthetic_reply->monotonic = m->monotonic;\n                synthetic_reply->seqnum = m->seqnum;\n                synthetic_reply->read_counter = m->read_counter;\n\n                r = bus_seal_synthetic_message(bus, synthetic_reply);\n                if (r < 0)\n                        return r;\n\n                m = synthetic_reply;\n        } else {\n                r = sd_bus_message_rewind(m, true);\n                if (r < 0)\n                        return r;\n        }\n\n        if (c->timeout_usec != 0) {\n                prioq_remove(bus->reply_callbacks_prioq, c, &c->prioq_idx);\n                c->timeout_usec = 0;\n        }\n\n        is_hello = bus->state == BUS_HELLO && c->callback == hello_callback;\n\n        bus->current_slot = sd_bus_slot_ref(slot);\n        bus->current_handler = c->callback;\n        bus->current_userdata = slot->userdata;\n        r = c->callback(m, slot->userdata, &error_buffer);\n        bus->current_userdata = NULL;\n        bus->current_handler = NULL;\n        bus->current_slot = NULL;\n\n        if (slot->floating)\n                bus_slot_disconnect(slot, true);\n\n        sd_bus_slot_unref(slot);\n\n        /* When this is the hello message and it failed, then make sure to propagate the error up, don't just log and\n         * ignore the callback handler's return value. */\n        if (is_hello)\n                return r;\n\n        return bus_maybe_reply_error(m, r, &error_buffer);\n}\n\nstatic int process_filter(sd_bus *bus, sd_bus_message *m) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error_buffer = SD_BUS_ERROR_NULL;\n        struct filter_callback *l;\n        int r;\n\n        assert(bus);\n        assert(m);\n\n        do {\n                bus->filter_callbacks_modified = false;\n\n                LIST_FOREACH(callbacks, l, bus->filter_callbacks) {\n                        sd_bus_slot *slot;\n\n                        if (bus->filter_callbacks_modified)\n                                break;\n\n                        /* Don't run this more than once per iteration */\n                        if (l->last_iteration == bus->iteration_counter)\n                                continue;\n\n                        l->last_iteration = bus->iteration_counter;\n\n                        r = sd_bus_message_rewind(m, true);\n                        if (r < 0)\n                                return r;\n\n                        slot = container_of(l, sd_bus_slot, filter_callback);\n\n                        bus->current_slot = sd_bus_slot_ref(slot);\n                        bus->current_handler = l->callback;\n                        bus->current_userdata = slot->userdata;\n                        r = l->callback(m, slot->userdata, &error_buffer);\n                        bus->current_userdata = NULL;\n                        bus->current_handler = NULL;\n                        bus->current_slot = sd_bus_slot_unref(slot);\n\n                        r = bus_maybe_reply_error(m, r, &error_buffer);\n                        if (r != 0)\n                                return r;\n\n                }\n\n        } while (bus->filter_callbacks_modified);\n\n        return 0;\n}\n\nstatic int process_match(sd_bus *bus, sd_bus_message *m) {\n        int r;\n\n        assert(bus);\n        assert(m);\n\n        do {\n                bus->match_callbacks_modified = false;\n\n                r = bus_match_run(bus, &bus->match_callbacks, m);\n                if (r != 0)\n                        return r;\n\n        } while (bus->match_callbacks_modified);\n\n        return 0;\n}\n\nstatic int process_builtin(sd_bus *bus, sd_bus_message *m) {\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;\n        int r;\n\n        assert(bus);\n        assert(m);\n\n        if (bus->is_monitor)\n                return 0;\n\n        if (bus->manual_peer_interface)\n                return 0;\n\n        if (m->header->type != SD_BUS_MESSAGE_METHOD_CALL)\n                return 0;\n\n        if (!streq_ptr(m->interface, \"org.freedesktop.DBus.Peer\"))\n                return 0;\n\n        if (m->header->flags & BUS_MESSAGE_NO_REPLY_EXPECTED)\n                return 1;\n\n        if (streq_ptr(m->member, \"Ping\"))\n                r = sd_bus_message_new_method_return(m, &reply);\n        else if (streq_ptr(m->member, \"GetMachineId\")) {\n                sd_id128_t id;\n                char sid[SD_ID128_STRING_MAX];\n\n                r = sd_id128_get_machine(&id);\n                if (r < 0)\n                        return r;\n\n                r = sd_bus_message_new_method_return(m, &reply);\n                if (r < 0)\n                        return r;\n\n                r = sd_bus_message_append(reply, \"s\", sd_id128_to_string(id, sid));\n        } else {\n                r = sd_bus_message_new_method_errorf(\n                                m, &reply,\n                                SD_BUS_ERROR_UNKNOWN_METHOD,\n                                 \"Unknown method '%s' on interface '%s'.\", m->member, m->interface);\n        }\n        if (r < 0)\n                return r;\n\n        r = sd_bus_send(bus, reply, NULL);\n        if (r < 0)\n                return r;\n\n        return 1;\n}\n\nstatic int process_fd_check(sd_bus *bus, sd_bus_message *m) {\n        assert(bus);\n        assert(m);\n\n        /* If we got a message with a file descriptor which we didn't\n         * want to accept, then let's drop it. How can this even\n         * happen? For example, when the kernel queues a message into\n         * an activatable names's queue which allows fds, and then is\n         * delivered to us later even though we ourselves did not\n         * negotiate it. */\n\n        if (bus->is_monitor)\n                return 0;\n\n        if (m->n_fds <= 0)\n                return 0;\n\n        if (bus->accept_fd)\n                return 0;\n\n        if (m->header->type != SD_BUS_MESSAGE_METHOD_CALL)\n                return 1; /* just eat it up */\n\n        return sd_bus_reply_method_errorf(m, SD_BUS_ERROR_INCONSISTENT_MESSAGE, \"Message contains file descriptors, which I cannot accept. Sorry.\");\n}\n\nstatic int process_message(sd_bus *bus, sd_bus_message *m) {\n        int r;\n\n        assert(bus);\n        assert(m);\n\n        bus->current_message = m;\n        bus->iteration_counter++;\n\n        log_debug_bus_message(m);\n\n        r = process_hello(bus, m);\n        if (r != 0)\n                goto finish;\n\n        r = process_reply(bus, m);\n        if (r != 0)\n                goto finish;\n\n        r = process_fd_check(bus, m);\n        if (r != 0)\n                goto finish;\n\n        r = process_filter(bus, m);\n        if (r != 0)\n                goto finish;\n\n        r = process_match(bus, m);\n        if (r != 0)\n                goto finish;\n\n        r = process_builtin(bus, m);\n        if (r != 0)\n                goto finish;\n\n        r = bus_process_object(bus, m);\n\nfinish:\n        bus->current_message = NULL;\n        return r;\n}\n\nstatic int dispatch_track(sd_bus *bus) {\n        assert(bus);\n\n        if (!bus->track_queue)\n                return 0;\n\n        bus_track_dispatch(bus->track_queue);\n        return 1;\n}\n\nstatic int process_running(sd_bus *bus, bool hint_priority, int64_t priority, sd_bus_message **ret) {\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = NULL;\n        int r;\n\n        assert(bus);\n        assert(IN_SET(bus->state, BUS_RUNNING, BUS_HELLO));\n\n        r = process_timeout(bus);\n        if (r != 0)\n                goto null_message;\n\n        r = dispatch_wqueue(bus);\n        if (r != 0)\n                goto null_message;\n\n        r = dispatch_track(bus);\n        if (r != 0)\n                goto null_message;\n\n        r = dispatch_rqueue(bus, hint_priority, priority, &m);\n        if (r < 0)\n                return r;\n        if (!m)\n                goto null_message;\n\n        r = process_message(bus, m);\n        if (r != 0)\n                goto null_message;\n\n        if (ret) {\n                r = sd_bus_message_rewind(m, true);\n                if (r < 0)\n                        return r;\n\n                *ret = TAKE_PTR(m);\n                return 1;\n        }\n\n        if (m->header->type == SD_BUS_MESSAGE_METHOD_CALL) {\n\n                log_debug(\"Unprocessed message call sender=%s object=%s interface=%s member=%s\",\n                          strna(sd_bus_message_get_sender(m)),\n                          strna(sd_bus_message_get_path(m)),\n                          strna(sd_bus_message_get_interface(m)),\n                          strna(sd_bus_message_get_member(m)));\n\n                r = sd_bus_reply_method_errorf(\n                                m,\n                                SD_BUS_ERROR_UNKNOWN_OBJECT,\n                                \"Unknown object '%s'.\", m->path);\n                if (r < 0)\n                        return r;\n        }\n\n        return 1;\n\nnull_message:\n        if (r >= 0 && ret)\n                *ret = NULL;\n\n        return r;\n}\n\nstatic int bus_exit_now(sd_bus *bus) {\n        assert(bus);\n\n        /* Exit due to close, if this is requested. If this is bus object is attached to an event source, invokes\n         * sd_event_exit(), otherwise invokes libc exit(). */\n\n        if (bus->exited) /* did we already exit? */\n                return 0;\n        if (!bus->exit_triggered) /* was the exit condition triggered? */\n                return 0;\n        if (!bus->exit_on_disconnect) /* Shall we actually exit on disconnection? */\n                return 0;\n\n        bus->exited = true; /* never exit more than once */\n\n        log_debug(\"Bus connection disconnected, exiting.\");\n\n        if (bus->event)\n                return sd_event_exit(bus->event, EXIT_FAILURE);\n        else\n                exit(EXIT_FAILURE);\n\n        assert_not_reached(\"exit() didn't exit?\");\n}\n\nstatic int process_closing_reply_callback(sd_bus *bus, struct reply_callback *c) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error_buffer = SD_BUS_ERROR_NULL;\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = NULL;\n        sd_bus_slot *slot;\n        int r;\n\n        assert(bus);\n        assert(c);\n\n        r = bus_message_new_synthetic_error(\n                        bus,\n                        c->cookie,\n                        &SD_BUS_ERROR_MAKE_CONST(SD_BUS_ERROR_NO_REPLY, \"Connection terminated\"),\n                        &m);\n        if (r < 0)\n                return r;\n\n        m->read_counter = ++bus->read_counter;\n\n        r = bus_seal_synthetic_message(bus, m);\n        if (r < 0)\n                return r;\n\n        if (c->timeout_usec != 0) {\n                prioq_remove(bus->reply_callbacks_prioq, c, &c->prioq_idx);\n                c->timeout_usec = 0;\n        }\n\n        ordered_hashmap_remove(bus->reply_callbacks, &c->cookie);\n        c->cookie = 0;\n\n        slot = container_of(c, sd_bus_slot, reply_callback);\n\n        bus->iteration_counter++;\n\n        bus->current_message = m;\n        bus->current_slot = sd_bus_slot_ref(slot);\n        bus->current_handler = c->callback;\n        bus->current_userdata = slot->userdata;\n        r = c->callback(m, slot->userdata, &error_buffer);\n        bus->current_userdata = NULL;\n        bus->current_handler = NULL;\n        bus->current_slot = NULL;\n        bus->current_message = NULL;\n\n        if (slot->floating)\n                bus_slot_disconnect(slot, true);\n\n        sd_bus_slot_unref(slot);\n\n        return bus_maybe_reply_error(m, r, &error_buffer);\n}\n\nstatic int process_closing(sd_bus *bus, sd_bus_message **ret) {\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = NULL;\n        struct reply_callback *c;\n        int r;\n\n        assert(bus);\n        assert(bus->state == BUS_CLOSING);\n\n        /* First, fail all outstanding method calls */\n        c = ordered_hashmap_first(bus->reply_callbacks);\n        if (c)\n                return process_closing_reply_callback(bus, c);\n\n        /* Then, fake-drop all remaining bus tracking references */\n        if (bus->tracks) {\n                bus_track_close(bus->tracks);\n                return 1;\n        }\n\n        /* Then, synthesize a Disconnected message */\n        r = sd_bus_message_new_signal(\n                        bus,\n                        &m,\n                        \"/org/freedesktop/DBus/Local\",\n                        \"org.freedesktop.DBus.Local\",\n                        \"Disconnected\");\n        if (r < 0)\n                return r;\n\n        bus_message_set_sender_local(bus, m);\n        m->read_counter = ++bus->read_counter;\n\n        r = bus_seal_synthetic_message(bus, m);\n        if (r < 0)\n                return r;\n\n        sd_bus_close(bus);\n\n        bus->current_message = m;\n        bus->iteration_counter++;\n\n        r = process_filter(bus, m);\n        if (r != 0)\n                goto finish;\n\n        r = process_match(bus, m);\n        if (r != 0)\n                goto finish;\n\n        /* Nothing else to do, exit now, if the condition holds */\n        bus->exit_triggered = true;\n        (void) bus_exit_now(bus);\n\n        if (ret)\n                *ret = TAKE_PTR(m);\n\n        r = 1;\n\nfinish:\n        bus->current_message = NULL;\n\n        return r;\n}\n\nstatic int bus_process_internal(sd_bus *bus, bool hint_priority, int64_t priority, sd_bus_message **ret) {\n        int r;\n\n        /* Returns 0 when we didn't do anything. This should cause the\n         * caller to invoke sd_bus_wait() before returning the next\n         * time. Returns > 0 when we did something, which possibly\n         * means *ret is filled in with an unprocessed message. */\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        /* We don't allow recursively invoking sd_bus_process(). */\n        assert_return(!bus->current_message, -EBUSY);\n        assert(!bus->current_slot); /* This should be NULL whenever bus->current_message is */\n\n        BUS_DONT_DESTROY(bus);\n\n        switch (bus->state) {\n\n        case BUS_UNSET:\n                return -ENOTCONN;\n\n        case BUS_CLOSED:\n                return -ECONNRESET;\n\n        case BUS_WATCH_BIND:\n                r = bus_socket_process_watch_bind(bus);\n                break;\n\n        case BUS_OPENING:\n                r = bus_socket_process_opening(bus);\n                break;\n\n        case BUS_AUTHENTICATING:\n                r = bus_socket_process_authenticating(bus);\n                break;\n\n        case BUS_RUNNING:\n        case BUS_HELLO:\n                r = process_running(bus, hint_priority, priority, ret);\n                if (r >= 0)\n                        return r;\n\n                /* This branch initializes *ret, hence we don't use the generic error checking below */\n                break;\n\n        case BUS_CLOSING:\n                return process_closing(bus, ret);\n\n        default:\n                assert_not_reached(\"Unknown state\");\n        }\n\n        if (ERRNO_IS_DISCONNECT(r)) {\n                bus_enter_closing(bus);\n                r = 1;\n        } else if (r < 0)\n                return r;\n\n        if (ret)\n                *ret = NULL;\n\n        return r;\n}\n\n_public_ int sd_bus_process(sd_bus *bus, sd_bus_message **ret) {\n        return bus_process_internal(bus, false, 0, ret);\n}\n\n_public_ int sd_bus_process_priority(sd_bus *bus, int64_t priority, sd_bus_message **ret) {\n        return bus_process_internal(bus, true, priority, ret);\n}\n\nstatic int bus_poll(sd_bus *bus, bool need_more, uint64_t timeout_usec) {\n        struct pollfd p[2] = {};\n        int r, n;\n        struct timespec ts;\n        usec_t m = USEC_INFINITY;\n\n        assert(bus);\n\n        if (bus->state == BUS_CLOSING)\n                return 1;\n\n        if (!BUS_IS_OPEN(bus->state))\n                return -ENOTCONN;\n\n        if (bus->state == BUS_WATCH_BIND) {\n                assert(bus->inotify_fd >= 0);\n\n                p[0].events = POLLIN;\n                p[0].fd = bus->inotify_fd;\n                n = 1;\n        } else {\n                int e;\n\n                e = sd_bus_get_events(bus);\n                if (e < 0)\n                        return e;\n\n                if (need_more)\n                        /* The caller really needs some more data, he doesn't\n                         * care about what's already read, or any timeouts\n                         * except its own. */\n                        e |= POLLIN;\n                else {\n                        usec_t until;\n                        /* The caller wants to process if there's something to\n                         * process, but doesn't care otherwise */\n\n                        r = sd_bus_get_timeout(bus, &until);\n                        if (r < 0)\n                                return r;\n                        if (r > 0)\n                                m = usec_sub_unsigned(until, now(CLOCK_MONOTONIC));\n                }\n\n                p[0].fd = bus->input_fd;\n                if (bus->output_fd == bus->input_fd) {\n                        p[0].events = e;\n                        n = 1;\n                } else {\n                        p[0].events = e & POLLIN;\n                        p[1].fd = bus->output_fd;\n                        p[1].events = e & POLLOUT;\n                        n = 2;\n                }\n        }\n\n        if (timeout_usec != (uint64_t) -1 && (m == USEC_INFINITY || timeout_usec < m))\n                m = timeout_usec;\n\n        r = ppoll(p, n, m == USEC_INFINITY ? NULL : timespec_store(&ts, m), NULL);\n        if (r < 0)\n                return -errno;\n\n        return r > 0 ? 1 : 0;\n}\n\n_public_ int sd_bus_wait(sd_bus *bus, uint64_t timeout_usec) {\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (bus->state == BUS_CLOSING)\n                return 0;\n\n        if (!BUS_IS_OPEN(bus->state))\n                return -ENOTCONN;\n\n        if (bus->rqueue_size > 0)\n                return 0;\n\n        return bus_poll(bus, false, timeout_usec);\n}\n\n_public_ int sd_bus_flush(sd_bus *bus) {\n        int r;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (bus->state == BUS_CLOSING)\n                return 0;\n\n        if (!BUS_IS_OPEN(bus->state))\n                return -ENOTCONN;\n\n        /* We never were connected? Don't hang in inotify for good, as there's no timeout set for it */\n        if (bus->state == BUS_WATCH_BIND)\n                return -EUNATCH;\n\n        r = bus_ensure_running(bus);\n        if (r < 0)\n                return r;\n\n        if (bus->wqueue_size <= 0)\n                return 0;\n\n        for (;;) {\n                r = dispatch_wqueue(bus);\n                if (r < 0) {\n                        if (ERRNO_IS_DISCONNECT(r)) {\n                                bus_enter_closing(bus);\n                                return -ECONNRESET;\n                        }\n\n                        return r;\n                }\n\n                if (bus->wqueue_size <= 0)\n                        return 0;\n\n                r = bus_poll(bus, false, (uint64_t) -1);\n                if (r < 0)\n                        return r;\n        }\n}\n\n_public_ int sd_bus_add_filter(\n                sd_bus *bus,\n                sd_bus_slot **slot,\n                sd_bus_message_handler_t callback,\n                void *userdata) {\n\n        sd_bus_slot *s;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(callback, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        s = bus_slot_allocate(bus, !slot, BUS_FILTER_CALLBACK, sizeof(struct filter_callback), userdata);\n        if (!s)\n                return -ENOMEM;\n\n        s->filter_callback.callback = callback;\n\n        bus->filter_callbacks_modified = true;\n        LIST_PREPEND(callbacks, bus->filter_callbacks, &s->filter_callback);\n\n        if (slot)\n                *slot = s;\n\n        return 0;\n}\n\nstatic int add_match_callback(\n                sd_bus_message *m,\n                void *userdata,\n                sd_bus_error *ret_error) {\n\n        sd_bus_slot *match_slot = userdata;\n        bool failed = false;\n        int r;\n\n        assert(m);\n        assert(match_slot);\n\n        sd_bus_slot_ref(match_slot);\n\n        if (sd_bus_message_is_method_error(m, NULL)) {\n                log_debug_errno(sd_bus_message_get_errno(m),\n                                \"Unable to add match %s, failing connection: %s\",\n                                match_slot->match_callback.match_string,\n                                sd_bus_message_get_error(m)->message);\n\n                failed = true;\n        } else\n                log_debug(\"Match %s successfully installed.\", match_slot->match_callback.match_string);\n\n        if (match_slot->match_callback.install_callback) {\n                sd_bus *bus;\n\n                bus = sd_bus_message_get_bus(m);\n\n                /* This function has been called as slot handler, and we want to call another slot handler. Let's\n                 * update the slot callback metadata temporarily with our own data, and then revert back to the old\n                 * values. */\n\n                assert(bus->current_slot == match_slot->match_callback.install_slot);\n                assert(bus->current_handler == add_match_callback);\n                assert(bus->current_userdata == userdata);\n\n                bus->current_slot = match_slot;\n                bus->current_handler = match_slot->match_callback.install_callback;\n                bus->current_userdata = match_slot->userdata;\n\n                r = match_slot->match_callback.install_callback(m, match_slot->userdata, ret_error);\n\n                bus->current_slot = match_slot->match_callback.install_slot;\n                bus->current_handler = add_match_callback;\n                bus->current_userdata = userdata;\n        } else {\n                if (failed) /* Generic failure handling: destroy the connection */\n                        bus_enter_closing(sd_bus_message_get_bus(m));\n\n                r = 1;\n        }\n\n        /* We don't need the install method reply slot anymore, let's free it */\n        match_slot->match_callback.install_slot = sd_bus_slot_unref(match_slot->match_callback.install_slot);\n\n        if (failed && match_slot->floating)\n                bus_slot_disconnect(match_slot, true);\n\n        sd_bus_slot_unref(match_slot);\n\n        return r;\n}\n\nstatic int bus_add_match_full(\n                sd_bus *bus,\n                sd_bus_slot **slot,\n                bool asynchronous,\n                const char *match,\n                sd_bus_message_handler_t callback,\n                sd_bus_message_handler_t install_callback,\n                void *userdata) {\n\n        struct bus_match_component *components = NULL;\n        unsigned n_components = 0;\n        sd_bus_slot *s = NULL;\n        int r = 0;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(match, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        r = bus_match_parse(match, &components, &n_components);\n        if (r < 0)\n                goto finish;\n\n        s = bus_slot_allocate(bus, !slot, BUS_MATCH_CALLBACK, sizeof(struct match_callback), userdata);\n        if (!s) {\n                r = -ENOMEM;\n                goto finish;\n        }\n\n        s->match_callback.callback = callback;\n        s->match_callback.install_callback = install_callback;\n\n        if (bus->bus_client) {\n                enum bus_match_scope scope;\n\n                scope = bus_match_get_scope(components, n_components);\n\n                /* Do not install server-side matches for matches against the local service, interface or bus path. */\n                if (scope != BUS_MATCH_LOCAL) {\n\n                        /* We store the original match string, so that we can use it to remove the match again. */\n\n                        s->match_callback.match_string = strdup(match);\n                        if (!s->match_callback.match_string) {\n                                r = -ENOMEM;\n                                goto finish;\n                        }\n\n                        if (asynchronous) {\n                                r = bus_add_match_internal_async(bus,\n                                                                 &s->match_callback.install_slot,\n                                                                 s->match_callback.match_string,\n                                                                 add_match_callback,\n                                                                 s);\n\n                                if (r < 0)\n                                        return r;\n\n                                /* Make the slot of the match call floating now. We need the reference, but we don't\n                                 * want that this match pins the bus object, hence we first create it non-floating, but\n                                 * then make it floating. */\n                                r = sd_bus_slot_set_floating(s->match_callback.install_slot, true);\n                        } else\n                                r = bus_add_match_internal(bus, s->match_callback.match_string, &s->match_callback.after);\n                        if (r < 0)\n                                goto finish;\n\n                        s->match_added = true;\n                }\n        }\n\n        bus->match_callbacks_modified = true;\n        r = bus_match_add(&bus->match_callbacks, components, n_components, &s->match_callback);\n        if (r < 0)\n                goto finish;\n\n        if (slot)\n                *slot = s;\n        s = NULL;\n\nfinish:\n        bus_match_parse_free(components, n_components);\n        sd_bus_slot_unref(s);\n\n        return r;\n}\n\n_public_ int sd_bus_add_match(\n                sd_bus *bus,\n                sd_bus_slot **slot,\n                const char *match,\n                sd_bus_message_handler_t callback,\n                void *userdata) {\n\n        return bus_add_match_full(bus, slot, false, match, callback, NULL, userdata);\n}\n\n_public_ int sd_bus_add_match_async(\n                sd_bus *bus,\n                sd_bus_slot **slot,\n                const char *match,\n                sd_bus_message_handler_t callback,\n                sd_bus_message_handler_t install_callback,\n                void *userdata) {\n\n        return bus_add_match_full(bus, slot, true, match, callback, install_callback, userdata);\n}\n\nbool bus_pid_changed(sd_bus *bus) {\n        assert(bus);\n\n        /* We don't support people creating a bus connection and\n         * keeping it around over a fork(). Let's complain. */\n\n        return bus->original_pid != getpid_cached();\n}\n\nstatic int io_callback(sd_event_source *s, int fd, uint32_t revents, void *userdata) {\n        sd_bus *bus = userdata;\n        int r;\n\n        assert(bus);\n\n        /* Note that this is called both on input_fd, output_fd as well as inotify_fd events */\n\n        r = sd_bus_process(bus, NULL);\n        if (r < 0) {\n                log_debug_errno(r, \"Processing of bus failed, closing down: %m\");\n                bus_enter_closing(bus);\n        }\n\n        return 1;\n}\n\nstatic int time_callback(sd_event_source *s, uint64_t usec, void *userdata) {\n        sd_bus *bus = userdata;\n        int r;\n\n        assert(bus);\n\n        r = sd_bus_process(bus, NULL);\n        if (r < 0) {\n                log_debug_errno(r, \"Processing of bus failed, closing down: %m\");\n                bus_enter_closing(bus);\n        }\n\n        return 1;\n}\n\nstatic int prepare_callback(sd_event_source *s, void *userdata) {\n        sd_bus *bus = userdata;\n        int r, e;\n        usec_t until;\n\n        assert(s);\n        assert(bus);\n\n        e = sd_bus_get_events(bus);\n        if (e < 0) {\n                r = e;\n                goto fail;\n        }\n\n        if (bus->output_fd != bus->input_fd) {\n\n                r = sd_event_source_set_io_events(bus->input_io_event_source, e & POLLIN);\n                if (r < 0)\n                        goto fail;\n\n                r = sd_event_source_set_io_events(bus->output_io_event_source, e & POLLOUT);\n        } else\n                r = sd_event_source_set_io_events(bus->input_io_event_source, e);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_get_timeout(bus, &until);\n        if (r < 0)\n                goto fail;\n        if (r > 0) {\n                int j;\n\n                j = sd_event_source_set_time(bus->time_event_source, until);\n                if (j < 0) {\n                        r = j;\n                        goto fail;\n                }\n        }\n\n        r = sd_event_source_set_enabled(bus->time_event_source, r > 0);\n        if (r < 0)\n                goto fail;\n\n        return 1;\n\nfail:\n        log_debug_errno(r, \"Preparing of bus events failed, closing down: %m\");\n        bus_enter_closing(bus);\n\n        return 1;\n}\n\nstatic int quit_callback(sd_event_source *event, void *userdata) {\n        sd_bus *bus = userdata;\n\n        assert(event);\n\n        if (bus->close_on_exit) {\n                sd_bus_flush(bus);\n                sd_bus_close(bus);\n        }\n\n        return 1;\n}\n\nint bus_attach_io_events(sd_bus *bus) {\n        int r;\n\n        assert(bus);\n\n        if (bus->input_fd < 0)\n                return 0;\n\n        if (!bus->event)\n                return 0;\n\n        if (!bus->input_io_event_source) {\n                r = sd_event_add_io(bus->event, &bus->input_io_event_source, bus->input_fd, 0, io_callback, bus);\n                if (r < 0)\n                        return r;\n\n                r = sd_event_source_set_prepare(bus->input_io_event_source, prepare_callback);\n                if (r < 0)\n                        return r;\n\n                r = sd_event_source_set_priority(bus->input_io_event_source, bus->event_priority);\n                if (r < 0)\n                        return r;\n\n                r = sd_event_source_set_description(bus->input_io_event_source, \"bus-input\");\n        } else\n                r = sd_event_source_set_io_fd(bus->input_io_event_source, bus->input_fd);\n\n        if (r < 0)\n                return r;\n\n        if (bus->output_fd != bus->input_fd) {\n                assert(bus->output_fd >= 0);\n\n                if (!bus->output_io_event_source) {\n                        r = sd_event_add_io(bus->event, &bus->output_io_event_source, bus->output_fd, 0, io_callback, bus);\n                        if (r < 0)\n                                return r;\n\n                        r = sd_event_source_set_priority(bus->output_io_event_source, bus->event_priority);\n                        if (r < 0)\n                                return r;\n\n                        r = sd_event_source_set_description(bus->input_io_event_source, \"bus-output\");\n                } else\n                        r = sd_event_source_set_io_fd(bus->output_io_event_source, bus->output_fd);\n\n                if (r < 0)\n                        return r;\n        }\n\n        return 0;\n}\n\nstatic void bus_detach_io_events(sd_bus *bus) {\n        assert(bus);\n\n        if (bus->input_io_event_source) {\n                sd_event_source_set_enabled(bus->input_io_event_source, SD_EVENT_OFF);\n                bus->input_io_event_source = sd_event_source_unref(bus->input_io_event_source);\n        }\n\n        if (bus->output_io_event_source) {\n                sd_event_source_set_enabled(bus->output_io_event_source, SD_EVENT_OFF);\n                bus->output_io_event_source = sd_event_source_unref(bus->output_io_event_source);\n        }\n}\n\nint bus_attach_inotify_event(sd_bus *bus) {\n        int r;\n\n        assert(bus);\n\n        if (bus->inotify_fd < 0)\n                return 0;\n\n        if (!bus->event)\n                return 0;\n\n        if (!bus->inotify_event_source) {\n                r = sd_event_add_io(bus->event, &bus->inotify_event_source, bus->inotify_fd, EPOLLIN, io_callback, bus);\n                if (r < 0)\n                        return r;\n\n                r = sd_event_source_set_priority(bus->inotify_event_source, bus->event_priority);\n                if (r < 0)\n                        return r;\n\n                r = sd_event_source_set_description(bus->inotify_event_source, \"bus-inotify\");\n        } else\n                r = sd_event_source_set_io_fd(bus->inotify_event_source, bus->inotify_fd);\n        if (r < 0)\n                return r;\n\n        return 0;\n}\n\nstatic void bus_detach_inotify_event(sd_bus *bus) {\n        assert(bus);\n\n        if (bus->inotify_event_source) {\n                sd_event_source_set_enabled(bus->inotify_event_source, SD_EVENT_OFF);\n                bus->inotify_event_source = sd_event_source_unref(bus->inotify_event_source);\n        }\n}\n\n_public_ int sd_bus_attach_event(sd_bus *bus, sd_event *event, int priority) {\n        int r;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus->event, -EBUSY);\n\n        assert(!bus->input_io_event_source);\n        assert(!bus->output_io_event_source);\n        assert(!bus->time_event_source);\n\n        if (event)\n                bus->event = sd_event_ref(event);\n        else  {\n                r = sd_event_default(&bus->event);\n                if (r < 0)\n                        return r;\n        }\n\n        bus->event_priority = priority;\n\n        r = sd_event_add_time(bus->event, &bus->time_event_source, CLOCK_MONOTONIC, 0, 0, time_callback, bus);\n        if (r < 0)\n                goto fail;\n\n        r = sd_event_source_set_priority(bus->time_event_source, priority);\n        if (r < 0)\n                goto fail;\n\n        r = sd_event_source_set_description(bus->time_event_source, \"bus-time\");\n        if (r < 0)\n                goto fail;\n\n        r = sd_event_add_exit(bus->event, &bus->quit_event_source, quit_callback, bus);\n        if (r < 0)\n                goto fail;\n\n        r = sd_event_source_set_description(bus->quit_event_source, \"bus-exit\");\n        if (r < 0)\n                goto fail;\n\n        r = bus_attach_io_events(bus);\n        if (r < 0)\n                goto fail;\n\n        r = bus_attach_inotify_event(bus);\n        if (r < 0)\n                goto fail;\n\n        return 0;\n\nfail:\n        sd_bus_detach_event(bus);\n        return r;\n}\n\n_public_ int sd_bus_detach_event(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n\n        if (!bus->event)\n                return 0;\n\n        bus_detach_io_events(bus);\n        bus_detach_inotify_event(bus);\n\n        if (bus->time_event_source) {\n                sd_event_source_set_enabled(bus->time_event_source, SD_EVENT_OFF);\n                bus->time_event_source = sd_event_source_unref(bus->time_event_source);\n        }\n\n        if (bus->quit_event_source) {\n                sd_event_source_set_enabled(bus->quit_event_source, SD_EVENT_OFF);\n                bus->quit_event_source = sd_event_source_unref(bus->quit_event_source);\n        }\n\n        bus->event = sd_event_unref(bus->event);\n        return 1;\n}\n\n_public_ sd_event* sd_bus_get_event(sd_bus *bus) {\n        assert_return(bus, NULL);\n\n        return bus->event;\n}\n\n_public_ sd_bus_message* sd_bus_get_current_message(sd_bus *bus) {\n        assert_return(bus, NULL);\n\n        return bus->current_message;\n}\n\n_public_ sd_bus_slot* sd_bus_get_current_slot(sd_bus *bus) {\n        assert_return(bus, NULL);\n\n        return bus->current_slot;\n}\n\n_public_ sd_bus_message_handler_t sd_bus_get_current_handler(sd_bus *bus) {\n        assert_return(bus, NULL);\n\n        return bus->current_handler;\n}\n\n_public_ void* sd_bus_get_current_userdata(sd_bus *bus) {\n        assert_return(bus, NULL);\n\n        return bus->current_userdata;\n}\n\nstatic int bus_default(int (*bus_open)(sd_bus **), sd_bus **default_bus, sd_bus **ret) {\n        sd_bus *b = NULL;\n        int r;\n\n        assert(bus_open);\n        assert(default_bus);\n\n        if (!ret)\n                return !!*default_bus;\n\n        if (*default_bus) {\n                *ret = sd_bus_ref(*default_bus);\n                return 0;\n        }\n\n        r = bus_open(&b);\n        if (r < 0)\n                return r;\n\n        b->default_bus_ptr = default_bus;\n        b->tid = gettid();\n        *default_bus = b;\n\n        *ret = b;\n        return 1;\n}\n\n_public_ int sd_bus_default_system(sd_bus **ret) {\n        return bus_default(sd_bus_open_system, &default_system_bus, ret);\n}\n\n_public_ int sd_bus_default_user(sd_bus **ret) {\n        return bus_default(sd_bus_open_user, &default_user_bus, ret);\n}\n\n_public_ int sd_bus_default(sd_bus **ret) {\n        int (*bus_open)(sd_bus **) = NULL;\n        sd_bus **busp;\n\n        busp = bus_choose_default(&bus_open);\n        return bus_default(bus_open, busp, ret);\n}\n\n_public_ int sd_bus_get_tid(sd_bus *b, pid_t *tid) {\n        assert_return(b, -EINVAL);\n        assert_return(tid, -EINVAL);\n        assert_return(!bus_pid_changed(b), -ECHILD);\n\n        if (b->tid != 0) {\n                *tid = b->tid;\n                return 0;\n        }\n\n        if (b->event)\n                return sd_event_get_tid(b->event, tid);\n\n        return -ENXIO;\n}\n\n_public_ int sd_bus_path_encode(const char *prefix, const char *external_id, char **ret_path) {\n        _cleanup_free_ char *e = NULL;\n        char *ret;\n\n        assert_return(object_path_is_valid(prefix), -EINVAL);\n        assert_return(external_id, -EINVAL);\n        assert_return(ret_path, -EINVAL);\n\n        e = bus_label_escape(external_id);\n        if (!e)\n                return -ENOMEM;\n\n        ret = path_join(prefix, e);\n        if (!ret)\n                return -ENOMEM;\n\n        *ret_path = ret;\n        return 0;\n}\n\n_public_ int sd_bus_path_decode(const char *path, const char *prefix, char **external_id) {\n        const char *e;\n        char *ret;\n\n        assert_return(object_path_is_valid(path), -EINVAL);\n        assert_return(object_path_is_valid(prefix), -EINVAL);\n        assert_return(external_id, -EINVAL);\n\n        e = object_path_startswith(path, prefix);\n        if (!e) {\n                *external_id = NULL;\n                return 0;\n        }\n\n        ret = bus_label_unescape(e);\n        if (!ret)\n                return -ENOMEM;\n\n        *external_id = ret;\n        return 1;\n}\n\n_public_ int sd_bus_path_encode_many(char **out, const char *path_template, ...) {\n        _cleanup_strv_free_ char **labels = NULL;\n        char *path, *path_pos, **label_pos;\n        const char *sep, *template_pos;\n        size_t path_length;\n        va_list list;\n        int r;\n\n        assert_return(out, -EINVAL);\n        assert_return(path_template, -EINVAL);\n\n        path_length = strlen(path_template);\n\n        va_start(list, path_template);\n        for (sep = strchr(path_template, '%'); sep; sep = strchr(sep + 1, '%')) {\n                const char *arg;\n                char *label;\n\n                arg = va_arg(list, const char *);\n                if (!arg) {\n                        va_end(list);\n                        return -EINVAL;\n                }\n\n                label = bus_label_escape(arg);\n                if (!label) {\n                        va_end(list);\n                        return -ENOMEM;\n                }\n\n                r = strv_consume(&labels, label);\n                if (r < 0) {\n                        va_end(list);\n                        return r;\n                }\n\n                /* add label length, but account for the format character */\n                path_length += strlen(label) - 1;\n        }\n        va_end(list);\n\n        path = malloc(path_length + 1);\n        if (!path)\n                return -ENOMEM;\n\n        path_pos = path;\n        label_pos = labels;\n\n        for (template_pos = path_template; *template_pos; ) {\n                sep = strchrnul(template_pos, '%');\n                path_pos = mempcpy(path_pos, template_pos, sep - template_pos);\n                if (!*sep)\n                        break;\n\n                path_pos = stpcpy(path_pos, *label_pos++);\n                template_pos = sep + 1;\n        }\n\n        *path_pos = 0;\n        *out = path;\n        return 0;\n}\n\n_public_ int sd_bus_path_decode_many(const char *path, const char *path_template, ...) {\n        _cleanup_strv_free_ char **labels = NULL;\n        const char *template_pos, *path_pos;\n        char **label_pos;\n        va_list list;\n        int r;\n\n        /*\n         * This decodes an object-path based on a template argument. The\n         * template consists of a verbatim path, optionally including special\n         * directives:\n         *\n         *   - Each occurrence of '%' in the template matches an arbitrary\n         *     substring of a label in the given path. At most one such\n         *     directive is allowed per label. For each such directive, the\n         *     caller must provide an output parameter (char **) via va_arg. If\n         *     NULL is passed, the given label is verified, but not returned.\n         *     For each matched label, the *decoded* label is stored in the\n         *     passed output argument, and the caller is responsible to free\n         *     it. Note that the output arguments are only modified if the\n         *     actually path matched the template. Otherwise, they're left\n         *     untouched.\n         *\n         * This function returns <0 on error, 0 if the path does not match the\n         * template, 1 if it matched.\n         */\n\n        assert_return(path, -EINVAL);\n        assert_return(path_template, -EINVAL);\n\n        path_pos = path;\n\n        for (template_pos = path_template; *template_pos; ) {\n                const char *sep;\n                size_t length;\n                char *label;\n\n                /* verify everything until the next '%' matches verbatim */\n                sep = strchrnul(template_pos, '%');\n                length = sep - template_pos;\n                if (strncmp(path_pos, template_pos, length))\n                        return 0;\n\n                path_pos += length;\n                template_pos += length;\n\n                if (!*template_pos)\n                        break;\n\n                /* We found the next '%' character. Everything up until here\n                 * matched. We now skip ahead to the end of this label and make\n                 * sure it matches the tail of the label in the path. Then we\n                 * decode the string in-between and save it for later use. */\n\n                ++template_pos; /* skip over '%' */\n\n                sep = strchrnul(template_pos, '/');\n                length = sep - template_pos; /* length of suffix to match verbatim */\n\n                /* verify the suffixes match */\n                sep = strchrnul(path_pos, '/');\n                if (sep - path_pos < (ssize_t)length ||\n                    strncmp(sep - length, template_pos, length))\n                        return 0;\n\n                template_pos += length; /* skip over matched label */\n                length = sep - path_pos - length; /* length of sub-label to decode */\n\n                /* store unescaped label for later use */\n                label = bus_label_unescape_n(path_pos, length);\n                if (!label)\n                        return -ENOMEM;\n\n                r = strv_consume(&labels, label);\n                if (r < 0)\n                        return r;\n\n                path_pos = sep; /* skip decoded label and suffix */\n        }\n\n        /* end of template must match end of path */\n        if (*path_pos)\n                return 0;\n\n        /* copy the labels over to the caller */\n        va_start(list, path_template);\n        for (label_pos = labels; label_pos && *label_pos; ++label_pos) {\n                char **arg;\n\n                arg = va_arg(list, char **);\n                if (arg)\n                        *arg = *label_pos;\n                else\n                        free(*label_pos);\n        }\n        va_end(list);\n\n        labels = mfree(labels);\n        return 1;\n}\n\n_public_ int sd_bus_try_close(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return -EOPNOTSUPP;\n}\n\n_public_ int sd_bus_get_description(sd_bus *bus, const char **description) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(description, -EINVAL);\n        assert_return(bus->description, -ENXIO);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (bus->description)\n                *description = bus->description;\n        else if (bus->is_system)\n                *description = \"system\";\n        else if (bus->is_user)\n                *description = \"user\";\n        else\n                *description = NULL;\n\n        return 0;\n}\n\n_public_ int sd_bus_get_scope(sd_bus *bus, const char **scope) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(scope, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (bus->is_user) {\n                *scope = \"user\";\n                return 0;\n        }\n\n        if (bus->is_system) {\n                *scope = \"system\";\n                return 0;\n        }\n\n        return -ENODATA;\n}\n\n_public_ int sd_bus_get_address(sd_bus *bus, const char **address) {\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(address, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (bus->address) {\n                *address = bus->address;\n                return 0;\n        }\n\n        return -ENODATA;\n}\n\n_public_ int sd_bus_get_creds_mask(sd_bus *bus, uint64_t *mask) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(mask, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        *mask = bus->creds_mask;\n        return 0;\n}\n\n_public_ int sd_bus_is_bus_client(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return bus->bus_client;\n}\n\n_public_ int sd_bus_is_server(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return bus->is_server;\n}\n\n_public_ int sd_bus_is_anonymous(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return bus->anonymous_auth;\n}\n\n_public_ int sd_bus_is_trusted(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return bus->trusted;\n}\n\n_public_ int sd_bus_is_monitor(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        return bus->is_monitor;\n}\n\nstatic void flush_close(sd_bus *bus) {\n        if (!bus)\n                return;\n\n        /* Flushes and closes the specified bus. We take a ref before,\n         * to ensure the flushing does not cause the bus to be\n         * unreferenced. */\n\n        sd_bus_flush_close_unref(sd_bus_ref(bus));\n}\n\n_public_ void sd_bus_default_flush_close(void) {\n        flush_close(default_starter_bus);\n        flush_close(default_user_bus);\n        flush_close(default_system_bus);\n}\n\n_public_ int sd_bus_set_exit_on_disconnect(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n\n        /* Turns on exit-on-disconnect, and triggers it immediately if the bus connection was already\n         * disconnected. Note that this is triggered exclusively on disconnections triggered by the server side, never\n         * from the client side. */\n        bus->exit_on_disconnect = b;\n\n        /* If the exit condition was triggered already, exit immediately. */\n        return bus_exit_now(bus);\n}\n\n_public_ int sd_bus_get_exit_on_disconnect(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n\n        return bus->exit_on_disconnect;\n}\n\n_public_ int sd_bus_set_sender(sd_bus *bus, const char *sender) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus->bus_client, -EPERM);\n        assert_return(!sender || service_name_is_valid(sender), -EINVAL);\n\n        return free_and_strdup(&bus->patch_sender, sender);\n}\n\n_public_ int sd_bus_get_sender(sd_bus *bus, const char **ret) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(ret, -EINVAL);\n\n        if (!bus->patch_sender)\n                return -ENODATA;\n\n        *ret = bus->patch_sender;\n        return 0;\n}\n\n_public_ int sd_bus_get_n_queued_read(sd_bus *bus, uint64_t *ret) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n        assert_return(ret, -EINVAL);\n\n        *ret = bus->rqueue_size;\n        return 0;\n}\n\n_public_ int sd_bus_get_n_queued_write(sd_bus *bus, uint64_t *ret) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n        assert_return(ret, -EINVAL);\n\n        *ret = bus->wqueue_size;\n        return 0;\n}\n\n_public_ int sd_bus_set_method_call_timeout(sd_bus *bus, uint64_t usec) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n\n        bus->method_call_timeout = usec;\n        return 0;\n}\n\n_public_ int sd_bus_get_method_call_timeout(sd_bus *bus, uint64_t *ret) {\n        const char *e;\n        usec_t usec;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(ret, -EINVAL);\n\n        if (bus->method_call_timeout != 0) {\n                *ret = bus->method_call_timeout;\n                return 0;\n        }\n\n        e = secure_getenv(\"SYSTEMD_BUS_TIMEOUT\");\n        if (e && parse_sec(e, &usec) >= 0 && usec != 0) {\n                /* Save the parsed value to avoid multiple parsing. To change the timeout value,\n                 * use sd_bus_set_method_call_timeout() instead of setenv(). */\n                *ret = bus->method_call_timeout = usec;\n                return 0;\n        }\n\n        *ret = bus->method_call_timeout = BUS_DEFAULT_TIMEOUT;\n        return 0;\n}\n\n_public_ int sd_bus_set_close_on_exit(sd_bus *bus, int b) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n\n        bus->close_on_exit = b;\n        return 0;\n}\n\n_public_ int sd_bus_get_close_on_exit(sd_bus *bus) {\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n\n        return bus->close_on_exit;\n}\n\n_public_ int sd_bus_enqeue_for_read(sd_bus *bus, sd_bus_message *m) {\n        int r;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(m, -EINVAL);\n        assert_return(m->sealed, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (!BUS_IS_OPEN(bus->state))\n                return -ENOTCONN;\n\n        /* Re-enqeue a message for reading. This is primarily useful for PolicyKit-style authentication,\n         * where we want accept a message, then determine we need to interactively authenticate the user, and\n         * when we have that process the message again. */\n\n        r = bus_rqueue_make_room(bus);\n        if (r < 0)\n                return r;\n\n        bus->rqueue[bus->rqueue_size++] = bus_message_ref_queued(m, bus);\n        return 0;\n}\n", "/* SPDX-License-Identifier: LGPL-2.1+ */\n#ifndef foosdbushfoo\n#define foosdbushfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <http://www.gnu.org/licenses/>.\n***/\n\n#include <inttypes.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n\n#include \"sd-event.h\"\n#include \"sd-id128.h\"\n\n#include \"_sd-common.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\n#define SD_BUS_DEFAULT ((sd_bus *) 1)\n#define SD_BUS_DEFAULT_USER ((sd_bus *) 2)\n#define SD_BUS_DEFAULT_SYSTEM ((sd_bus *) 3)\n\n/* https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-marshaling-signature */\n#define SD_BUS_MAXIMUM_SIGNATURE_LENGTH 255\n\n/* https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names */\n#define SD_BUS_MAXIMUM_NAME_LENGTH 255\n\n/* Types */\n\ntypedef struct sd_bus sd_bus;\ntypedef struct sd_bus_message sd_bus_message;\ntypedef struct sd_bus_slot sd_bus_slot;\ntypedef struct sd_bus_creds sd_bus_creds;\ntypedef struct sd_bus_track sd_bus_track;\n\ntypedef struct {\n        const char *name;\n        const char *message;\n        int _need_free;\n} sd_bus_error;\n\ntypedef struct {\n        const char* name;\n        int code;\n} sd_bus_error_map;\n\n/* Flags */\n\nenum {\n        SD_BUS_CREDS_PID                = 1ULL << 0,\n        SD_BUS_CREDS_TID                = 1ULL << 1,\n        SD_BUS_CREDS_PPID               = 1ULL << 2,\n        SD_BUS_CREDS_UID                = 1ULL << 3,\n        SD_BUS_CREDS_EUID               = 1ULL << 4,\n        SD_BUS_CREDS_SUID               = 1ULL << 5,\n        SD_BUS_CREDS_FSUID              = 1ULL << 6,\n        SD_BUS_CREDS_GID                = 1ULL << 7,\n        SD_BUS_CREDS_EGID               = 1ULL << 8,\n        SD_BUS_CREDS_SGID               = 1ULL << 9,\n        SD_BUS_CREDS_FSGID              = 1ULL << 10,\n        SD_BUS_CREDS_SUPPLEMENTARY_GIDS = 1ULL << 11,\n        SD_BUS_CREDS_COMM               = 1ULL << 12,\n        SD_BUS_CREDS_TID_COMM           = 1ULL << 13,\n        SD_BUS_CREDS_EXE                = 1ULL << 14,\n        SD_BUS_CREDS_CMDLINE            = 1ULL << 15,\n        SD_BUS_CREDS_CGROUP             = 1ULL << 16,\n        SD_BUS_CREDS_UNIT               = 1ULL << 17,\n        SD_BUS_CREDS_SLICE              = 1ULL << 18,\n        SD_BUS_CREDS_USER_UNIT          = 1ULL << 19,\n        SD_BUS_CREDS_USER_SLICE         = 1ULL << 20,\n        SD_BUS_CREDS_SESSION            = 1ULL << 21,\n        SD_BUS_CREDS_OWNER_UID          = 1ULL << 22,\n        SD_BUS_CREDS_EFFECTIVE_CAPS     = 1ULL << 23,\n        SD_BUS_CREDS_PERMITTED_CAPS     = 1ULL << 24,\n        SD_BUS_CREDS_INHERITABLE_CAPS   = 1ULL << 25,\n        SD_BUS_CREDS_BOUNDING_CAPS      = 1ULL << 26,\n        SD_BUS_CREDS_SELINUX_CONTEXT    = 1ULL << 27,\n        SD_BUS_CREDS_AUDIT_SESSION_ID   = 1ULL << 28,\n        SD_BUS_CREDS_AUDIT_LOGIN_UID    = 1ULL << 29,\n        SD_BUS_CREDS_TTY                = 1ULL << 30,\n        SD_BUS_CREDS_UNIQUE_NAME        = 1ULL << 31,\n        SD_BUS_CREDS_WELL_KNOWN_NAMES   = 1ULL << 32,\n        SD_BUS_CREDS_DESCRIPTION        = 1ULL << 33,\n        SD_BUS_CREDS_AUGMENT            = 1ULL << 63, /* special flag, if on sd-bus will augment creds struct, in a potentially race-full way. */\n        _SD_BUS_CREDS_ALL               = (1ULL << 34) -1\n};\n\nenum {\n        SD_BUS_NAME_REPLACE_EXISTING  = 1ULL << 0,\n        SD_BUS_NAME_ALLOW_REPLACEMENT = 1ULL << 1,\n        SD_BUS_NAME_QUEUE             = 1ULL << 2\n};\n\nenum {\n        SD_BUS_MESSAGE_DUMP_WITH_HEADER  = 1ULL << 0,\n        SD_BUS_MESSAGE_DUMP_SUBTREE_ONLY = 1ULL << 1,\n};\n\n/* Callbacks */\n\ntypedef int (*sd_bus_message_handler_t)(sd_bus_message *m, void *userdata, sd_bus_error *ret_error);\ntypedef int (*sd_bus_property_get_t) (sd_bus *bus, const char *path, const char *interface, const char *property, sd_bus_message *reply, void *userdata, sd_bus_error *ret_error);\ntypedef int (*sd_bus_property_set_t) (sd_bus *bus, const char *path, const char *interface, const char *property, sd_bus_message *value, void *userdata, sd_bus_error *ret_error);\ntypedef int (*sd_bus_object_find_t) (sd_bus *bus, const char *path, const char *interface, void *userdata, void **ret_found, sd_bus_error *ret_error);\ntypedef int (*sd_bus_node_enumerator_t) (sd_bus *bus, const char *prefix, void *userdata, char ***ret_nodes, sd_bus_error *ret_error);\ntypedef int (*sd_bus_track_handler_t) (sd_bus_track *track, void *userdata);\ntypedef _sd_destroy_t sd_bus_destroy_t;\n\n#include \"sd-bus-protocol.h\"\n#include \"sd-bus-vtable.h\"\n\n/* Connections */\n\nint sd_bus_default(sd_bus **ret);\nint sd_bus_default_user(sd_bus **ret);\nint sd_bus_default_system(sd_bus **ret);\n\nint sd_bus_open(sd_bus **ret);\nint sd_bus_open_with_description(sd_bus **ret, const char *description);\nint sd_bus_open_user(sd_bus **ret);\nint sd_bus_open_user_with_description(sd_bus **ret, const char *description);\nint sd_bus_open_system(sd_bus **ret);\nint sd_bus_open_system_with_description(sd_bus **ret, const char *description);\nint sd_bus_open_system_remote(sd_bus **ret, const char *host);\nint sd_bus_open_system_machine(sd_bus **ret, const char *machine);\n\nint sd_bus_new(sd_bus **ret);\n\nint sd_bus_set_address(sd_bus *bus, const char *address);\nint sd_bus_set_fd(sd_bus *bus, int input_fd, int output_fd);\nint sd_bus_set_exec(sd_bus *bus, const char *path, char *const argv[]);\nint sd_bus_get_address(sd_bus *bus, const char **address);\nint sd_bus_set_bus_client(sd_bus *bus, int b);\nint sd_bus_is_bus_client(sd_bus *bus);\nint sd_bus_set_server(sd_bus *bus, int b, sd_id128_t bus_id);\nint sd_bus_is_server(sd_bus *bus);\nint sd_bus_set_anonymous(sd_bus *bus, int b);\nint sd_bus_is_anonymous(sd_bus *bus);\nint sd_bus_set_trusted(sd_bus *bus, int b);\nint sd_bus_is_trusted(sd_bus *bus);\nint sd_bus_set_monitor(sd_bus *bus, int b);\nint sd_bus_is_monitor(sd_bus *bus);\nint sd_bus_set_description(sd_bus *bus, const char *description);\nint sd_bus_get_description(sd_bus *bus, const char **description);\nint sd_bus_negotiate_creds(sd_bus *bus, int b, uint64_t creds_mask);\nint sd_bus_negotiate_timestamp(sd_bus *bus, int b);\nint sd_bus_negotiate_fds(sd_bus *bus, int b);\nint sd_bus_can_send(sd_bus *bus, char type);\nint sd_bus_get_creds_mask(sd_bus *bus, uint64_t *creds_mask);\nint sd_bus_set_allow_interactive_authorization(sd_bus *bus, int b);\nint sd_bus_get_allow_interactive_authorization(sd_bus *bus);\nint sd_bus_set_exit_on_disconnect(sd_bus *bus, int b);\nint sd_bus_get_exit_on_disconnect(sd_bus *bus);\nint sd_bus_set_close_on_exit(sd_bus *bus, int b);\nint sd_bus_get_close_on_exit(sd_bus *bus);\nint sd_bus_set_watch_bind(sd_bus *bus, int b);\nint sd_bus_get_watch_bind(sd_bus *bus);\nint sd_bus_set_connected_signal(sd_bus *bus, int b);\nint sd_bus_get_connected_signal(sd_bus *bus);\nint sd_bus_set_sender(sd_bus *bus, const char *sender);\nint sd_bus_get_sender(sd_bus *bus, const char **ret);\n\nint sd_bus_start(sd_bus *bus);\n\nint sd_bus_try_close(sd_bus *bus);\nvoid sd_bus_close(sd_bus *bus);\n\nsd_bus *sd_bus_ref(sd_bus *bus);\nsd_bus *sd_bus_unref(sd_bus *bus);\nsd_bus *sd_bus_close_unref(sd_bus *bus);\nsd_bus *sd_bus_flush_close_unref(sd_bus *bus);\n\nvoid sd_bus_default_flush_close(void);\n\nint sd_bus_is_open(sd_bus *bus);\nint sd_bus_is_ready(sd_bus *bus);\n\nint sd_bus_get_bus_id(sd_bus *bus, sd_id128_t *id);\nint sd_bus_get_scope(sd_bus *bus, const char **scope);\nint sd_bus_get_tid(sd_bus *bus, pid_t *tid);\nint sd_bus_get_owner_creds(sd_bus *bus, uint64_t creds_mask, sd_bus_creds **ret);\n\nint sd_bus_send(sd_bus *bus, sd_bus_message *m, uint64_t *cookie);\nint sd_bus_send_to(sd_bus *bus, sd_bus_message *m, const char *destination, uint64_t *cookie);\nint sd_bus_call(sd_bus *bus, sd_bus_message *m, uint64_t usec, sd_bus_error *ret_error, sd_bus_message **reply);\nint sd_bus_call_async(sd_bus *bus, sd_bus_slot **slot, sd_bus_message *m, sd_bus_message_handler_t callback, void *userdata, uint64_t usec);\n\nint sd_bus_get_fd(sd_bus *bus);\nint sd_bus_get_events(sd_bus *bus);\nint sd_bus_get_timeout(sd_bus *bus, uint64_t *timeout_usec);\nint sd_bus_process(sd_bus *bus, sd_bus_message **r);\nint sd_bus_process_priority(sd_bus *bus, int64_t max_priority, sd_bus_message **r);\nint sd_bus_wait(sd_bus *bus, uint64_t timeout_usec);\nint sd_bus_flush(sd_bus *bus);\nint sd_bus_enqeue_for_read(sd_bus *bus, sd_bus_message *m);\n\nsd_bus_slot* sd_bus_get_current_slot(sd_bus *bus);\nsd_bus_message* sd_bus_get_current_message(sd_bus *bus);\nsd_bus_message_handler_t sd_bus_get_current_handler(sd_bus *bus);\nvoid* sd_bus_get_current_userdata(sd_bus *bus);\n\nint sd_bus_attach_event(sd_bus *bus, sd_event *e, int priority);\nint sd_bus_detach_event(sd_bus *bus);\nsd_event *sd_bus_get_event(sd_bus *bus);\n\nint sd_bus_get_n_queued_read(sd_bus *bus, uint64_t *ret);\nint sd_bus_get_n_queued_write(sd_bus *bus, uint64_t *ret);\n\nint sd_bus_set_method_call_timeout(sd_bus *bus, uint64_t usec);\nint sd_bus_get_method_call_timeout(sd_bus *bus, uint64_t *ret);\n\nint sd_bus_add_filter(sd_bus *bus, sd_bus_slot **slot, sd_bus_message_handler_t callback, void *userdata);\nint sd_bus_add_match(sd_bus *bus, sd_bus_slot **slot, const char *match, sd_bus_message_handler_t callback, void *userdata);\nint sd_bus_add_match_async(sd_bus *bus, sd_bus_slot **slot, const char *match, sd_bus_message_handler_t callback, sd_bus_message_handler_t install_callback, void *userdata);\nint sd_bus_add_object(sd_bus *bus, sd_bus_slot **slot, const char *path, sd_bus_message_handler_t callback, void *userdata);\nint sd_bus_add_fallback(sd_bus *bus, sd_bus_slot **slot, const char *prefix, sd_bus_message_handler_t callback, void *userdata);\nint sd_bus_add_object_vtable(sd_bus *bus, sd_bus_slot **slot, const char *path, const char *interface, const sd_bus_vtable *vtable, void *userdata);\nint sd_bus_add_fallback_vtable(sd_bus *bus, sd_bus_slot **slot, const char *prefix, const char *interface, const sd_bus_vtable *vtable, sd_bus_object_find_t find, void *userdata);\nint sd_bus_add_node_enumerator(sd_bus *bus, sd_bus_slot **slot, const char *path, sd_bus_node_enumerator_t callback, void *userdata);\nint sd_bus_add_object_manager(sd_bus *bus, sd_bus_slot **slot, const char *path);\n\n/* Slot object */\n\nsd_bus_slot* sd_bus_slot_ref(sd_bus_slot *slot);\nsd_bus_slot* sd_bus_slot_unref(sd_bus_slot *slot);\n\nsd_bus* sd_bus_slot_get_bus(sd_bus_slot *slot);\nvoid *sd_bus_slot_get_userdata(sd_bus_slot *slot);\nvoid *sd_bus_slot_set_userdata(sd_bus_slot *slot, void *userdata);\nint sd_bus_slot_set_description(sd_bus_slot *slot, const char *description);\nint sd_bus_slot_get_description(sd_bus_slot *slot, const char **description);\nint sd_bus_slot_get_floating(sd_bus_slot *slot);\nint sd_bus_slot_set_floating(sd_bus_slot *slot, int b);\nint sd_bus_slot_set_destroy_callback(sd_bus_slot *s, sd_bus_destroy_t callback);\nint sd_bus_slot_get_destroy_callback(sd_bus_slot *s, sd_bus_destroy_t *callback);\n\nsd_bus_message* sd_bus_slot_get_current_message(sd_bus_slot *slot);\nsd_bus_message_handler_t sd_bus_slot_get_current_handler(sd_bus_slot *slot);\nvoid *sd_bus_slot_get_current_userdata(sd_bus_slot *slot);\n\n/* Message object */\n\nint sd_bus_message_new(sd_bus *bus, sd_bus_message **m, uint8_t type);\nint sd_bus_message_new_signal(sd_bus *bus, sd_bus_message **m, const char *path, const char *interface, const char *member);\nint sd_bus_message_new_method_call(sd_bus *bus, sd_bus_message **m, const char *destination, const char *path, const char *interface, const char *member);\nint sd_bus_message_new_method_return(sd_bus_message *call, sd_bus_message **m);\nint sd_bus_message_new_method_error(sd_bus_message *call, sd_bus_message **m, const sd_bus_error *e);\nint sd_bus_message_new_method_errorf(sd_bus_message *call, sd_bus_message **m, const char *name, const char *format, ...) _sd_printf_(4, 5);\nint sd_bus_message_new_method_errno(sd_bus_message *call, sd_bus_message **m, int error, const sd_bus_error *e);\nint sd_bus_message_new_method_errnof(sd_bus_message *call, sd_bus_message **m, int error, const char *format, ...) _sd_printf_(4, 5);\n\nsd_bus_message* sd_bus_message_ref(sd_bus_message *m);\nsd_bus_message* sd_bus_message_unref(sd_bus_message *m);\n\nint sd_bus_message_seal(sd_bus_message *m, uint64_t cookie, uint64_t timeout_usec);\n\nint sd_bus_message_get_type(sd_bus_message *m, uint8_t *type);\nint sd_bus_message_get_cookie(sd_bus_message *m, uint64_t *cookie);\nint sd_bus_message_get_reply_cookie(sd_bus_message *m, uint64_t *cookie);\nint sd_bus_message_get_priority(sd_bus_message *m, int64_t *priority);\n\nint sd_bus_message_get_expect_reply(sd_bus_message *m);\nint sd_bus_message_get_auto_start(sd_bus_message *m);\nint sd_bus_message_get_allow_interactive_authorization(sd_bus_message *m);\n\nconst char *sd_bus_message_get_signature(sd_bus_message *m, int complete);\nconst char *sd_bus_message_get_path(sd_bus_message *m);\nconst char *sd_bus_message_get_interface(sd_bus_message *m);\nconst char *sd_bus_message_get_member(sd_bus_message *m);\nconst char *sd_bus_message_get_destination(sd_bus_message *m);\nconst char *sd_bus_message_get_sender(sd_bus_message *m);\nconst sd_bus_error *sd_bus_message_get_error(sd_bus_message *m);\nint sd_bus_message_get_errno(sd_bus_message *m);\n\nint sd_bus_message_get_monotonic_usec(sd_bus_message *m, uint64_t *usec);\nint sd_bus_message_get_realtime_usec(sd_bus_message *m, uint64_t *usec);\nint sd_bus_message_get_seqnum(sd_bus_message *m, uint64_t* seqnum);\n\nsd_bus* sd_bus_message_get_bus(sd_bus_message *m);\nsd_bus_creds *sd_bus_message_get_creds(sd_bus_message *m); /* do not unref the result */\n\nint sd_bus_message_is_signal(sd_bus_message *m, const char *interface, const char *member);\nint sd_bus_message_is_method_call(sd_bus_message *m, const char *interface, const char *member);\nint sd_bus_message_is_method_error(sd_bus_message *m, const char *name);\nint sd_bus_message_is_empty(sd_bus_message *m);\nint sd_bus_message_has_signature(sd_bus_message *m, const char *signature);\n\nint sd_bus_message_set_expect_reply(sd_bus_message *m, int b);\nint sd_bus_message_set_auto_start(sd_bus_message *m, int b);\nint sd_bus_message_set_allow_interactive_authorization(sd_bus_message *m, int b);\n\nint sd_bus_message_set_destination(sd_bus_message *m, const char *destination);\nint sd_bus_message_set_sender(sd_bus_message *m, const char *sender);\nint sd_bus_message_set_priority(sd_bus_message *m, int64_t priority);\n\nint sd_bus_message_append(sd_bus_message *m, const char *types, ...);\nint sd_bus_message_appendv(sd_bus_message *m, const char *types, va_list ap);\nint sd_bus_message_append_basic(sd_bus_message *m, char type, const void *p);\nint sd_bus_message_append_array(sd_bus_message *m, char type, const void *ptr, size_t size);\nint sd_bus_message_append_array_space(sd_bus_message *m, char type, size_t size, void **ptr);\nint sd_bus_message_append_array_iovec(sd_bus_message *m, char type, const struct iovec *iov, unsigned n);\nint sd_bus_message_append_array_memfd(sd_bus_message *m, char type, int memfd, uint64_t offset, uint64_t size);\nint sd_bus_message_append_string_space(sd_bus_message *m, size_t size, char **s);\nint sd_bus_message_append_string_iovec(sd_bus_message *m, const struct iovec *iov, unsigned n);\nint sd_bus_message_append_string_memfd(sd_bus_message *m, int memfd, uint64_t offset, uint64_t size);\nint sd_bus_message_append_strv(sd_bus_message *m, char **l);\nint sd_bus_message_open_container(sd_bus_message *m, char type, const char *contents);\nint sd_bus_message_close_container(sd_bus_message *m);\nint sd_bus_message_copy(sd_bus_message *m, sd_bus_message *source, int all);\n\nint sd_bus_message_read(sd_bus_message *m, const char *types, ...);\nint sd_bus_message_readv(sd_bus_message *m, const char *types, va_list ap);\nint sd_bus_message_read_basic(sd_bus_message *m, char type, void *p);\nint sd_bus_message_read_array(sd_bus_message *m, char type, const void **ptr, size_t *size);\nint sd_bus_message_read_strv(sd_bus_message *m, char ***l); /* free the result! */\nint sd_bus_message_skip(sd_bus_message *m, const char *types);\nint sd_bus_message_enter_container(sd_bus_message *m, char type, const char *contents);\nint sd_bus_message_exit_container(sd_bus_message *m);\nint sd_bus_message_peek_type(sd_bus_message *m, char *type, const char **contents);\nint sd_bus_message_verify_type(sd_bus_message *m, char type, const char *contents);\nint sd_bus_message_at_end(sd_bus_message *m, int complete);\nint sd_bus_message_rewind(sd_bus_message *m, int complete);\nint sd_bus_message_sensitive(sd_bus_message *m);\n\nint sd_bus_message_dump(sd_bus_message *m, FILE *f, uint64_t flags);\n\n/* Bus management */\n\nint sd_bus_get_unique_name(sd_bus *bus, const char **unique);\nint sd_bus_request_name(sd_bus *bus, const char *name, uint64_t flags);\nint sd_bus_request_name_async(sd_bus *bus, sd_bus_slot **ret_slot, const char *name, uint64_t flags, sd_bus_message_handler_t callback, void *userdata);\nint sd_bus_release_name(sd_bus *bus, const char *name);\nint sd_bus_release_name_async(sd_bus *bus, sd_bus_slot **ret_slot, const char *name, sd_bus_message_handler_t callback, void *userdata);\nint sd_bus_list_names(sd_bus *bus, char ***acquired, char ***activatable); /* free the results */\nint sd_bus_get_name_creds(sd_bus *bus, const char *name, uint64_t mask, sd_bus_creds **creds); /* unref the result! */\nint sd_bus_get_name_machine_id(sd_bus *bus, const char *name, sd_id128_t *machine);\n\n/* Convenience calls */\n\nint sd_bus_call_method(sd_bus *bus, const char *destination, const char *path, const char *interface, const char *member, sd_bus_error *ret_error, sd_bus_message **reply, const char *types, ...);\nint sd_bus_call_method_async(sd_bus *bus, sd_bus_slot **slot, const char *destination, const char *path, const char *interface, const char *member, sd_bus_message_handler_t callback, void *userdata, const char *types, ...);\nint sd_bus_get_property(sd_bus *bus, const char *destination, const char *path, const char *interface, const char *member, sd_bus_error *ret_error, sd_bus_message **reply, const char *type);\nint sd_bus_get_property_trivial(sd_bus *bus, const char *destination, const char *path, const char *interface, const char *member, sd_bus_error *ret_error, char type, void *ret_ptr);\nint sd_bus_get_property_string(sd_bus *bus, const char *destination, const char *path, const char *interface, const char *member, sd_bus_error *ret_error, char **ret); /* free the result! */\nint sd_bus_get_property_strv(sd_bus *bus, const char *destination, const char *path, const char *interface, const char *member, sd_bus_error *ret_error, char ***ret); /* free the result! */\nint sd_bus_set_property(sd_bus *bus, const char *destination, const char *path, const char *interface, const char *member, sd_bus_error *ret_error, const char *type, ...);\n\nint sd_bus_reply_method_return(sd_bus_message *call, const char *types, ...);\nint sd_bus_reply_method_error(sd_bus_message *call, const sd_bus_error *e);\nint sd_bus_reply_method_errorf(sd_bus_message *call, const char *name, const char *format, ...) _sd_printf_(3, 4);\nint sd_bus_reply_method_errno(sd_bus_message *call, int error, const sd_bus_error *e);\nint sd_bus_reply_method_errnof(sd_bus_message *call, int error, const char *format, ...) _sd_printf_(3, 4);\n\nint sd_bus_emit_signal(sd_bus *bus, const char *path, const char *interface, const char *member, const char *types, ...);\n\nint sd_bus_emit_properties_changed_strv(sd_bus *bus, const char *path, const char *interface, char **names);\nint sd_bus_emit_properties_changed(sd_bus *bus, const char *path, const char *interface, const char *name, ...) _sd_sentinel_;\n\nint sd_bus_emit_object_added(sd_bus *bus, const char *path);\nint sd_bus_emit_object_removed(sd_bus *bus, const char *path);\nint sd_bus_emit_interfaces_added_strv(sd_bus *bus, const char *path, char **interfaces);\nint sd_bus_emit_interfaces_added(sd_bus *bus, const char *path, const char *interface, ...) _sd_sentinel_;\nint sd_bus_emit_interfaces_removed_strv(sd_bus *bus, const char *path, char **interfaces);\nint sd_bus_emit_interfaces_removed(sd_bus *bus, const char *path, const char *interface, ...) _sd_sentinel_;\n\nint sd_bus_query_sender_creds(sd_bus_message *call, uint64_t mask, sd_bus_creds **creds);\nint sd_bus_query_sender_privilege(sd_bus_message *call, int capability);\n\nint sd_bus_match_signal(sd_bus *bus, sd_bus_slot **ret, const char *sender, const char *path, const char *interface, const char *member, sd_bus_message_handler_t callback, void *userdata);\nint sd_bus_match_signal_async(sd_bus *bus, sd_bus_slot **ret, const char *sender, const char *path, const char *interface, const char *member, sd_bus_message_handler_t match_callback, sd_bus_message_handler_t add_callback, void *userdata);\n\n/* Credential handling */\n\nint sd_bus_creds_new_from_pid(sd_bus_creds **ret, pid_t pid, uint64_t creds_mask);\nsd_bus_creds *sd_bus_creds_ref(sd_bus_creds *c);\nsd_bus_creds *sd_bus_creds_unref(sd_bus_creds *c);\nuint64_t sd_bus_creds_get_mask(const sd_bus_creds *c);\nuint64_t sd_bus_creds_get_augmented_mask(const sd_bus_creds *c);\n\nint sd_bus_creds_get_pid(sd_bus_creds *c, pid_t *pid);\nint sd_bus_creds_get_ppid(sd_bus_creds *c, pid_t *ppid);\nint sd_bus_creds_get_tid(sd_bus_creds *c, pid_t *tid);\nint sd_bus_creds_get_uid(sd_bus_creds *c, uid_t *uid);\nint sd_bus_creds_get_euid(sd_bus_creds *c, uid_t *euid);\nint sd_bus_creds_get_suid(sd_bus_creds *c, uid_t *suid);\nint sd_bus_creds_get_fsuid(sd_bus_creds *c, uid_t *fsuid);\nint sd_bus_creds_get_gid(sd_bus_creds *c, gid_t *gid);\nint sd_bus_creds_get_egid(sd_bus_creds *c, gid_t *egid);\nint sd_bus_creds_get_sgid(sd_bus_creds *c, gid_t *sgid);\nint sd_bus_creds_get_fsgid(sd_bus_creds *c, gid_t *fsgid);\nint sd_bus_creds_get_supplementary_gids(sd_bus_creds *c, const gid_t **gids);\nint sd_bus_creds_get_comm(sd_bus_creds *c, const char **comm);\nint sd_bus_creds_get_tid_comm(sd_bus_creds *c, const char **comm);\nint sd_bus_creds_get_exe(sd_bus_creds *c, const char **exe);\nint sd_bus_creds_get_cmdline(sd_bus_creds *c, char ***cmdline);\nint sd_bus_creds_get_cgroup(sd_bus_creds *c, const char **cgroup);\nint sd_bus_creds_get_unit(sd_bus_creds *c, const char **unit);\nint sd_bus_creds_get_slice(sd_bus_creds *c, const char **slice);\nint sd_bus_creds_get_user_unit(sd_bus_creds *c, const char **unit);\nint sd_bus_creds_get_user_slice(sd_bus_creds *c, const char **slice);\nint sd_bus_creds_get_session(sd_bus_creds *c, const char **session);\nint sd_bus_creds_get_owner_uid(sd_bus_creds *c, uid_t *uid);\nint sd_bus_creds_has_effective_cap(sd_bus_creds *c, int capability);\nint sd_bus_creds_has_permitted_cap(sd_bus_creds *c, int capability);\nint sd_bus_creds_has_inheritable_cap(sd_bus_creds *c, int capability);\nint sd_bus_creds_has_bounding_cap(sd_bus_creds *c, int capability);\nint sd_bus_creds_get_selinux_context(sd_bus_creds *c, const char **context);\nint sd_bus_creds_get_audit_session_id(sd_bus_creds *c, uint32_t *sessionid);\nint sd_bus_creds_get_audit_login_uid(sd_bus_creds *c, uid_t *loginuid);\nint sd_bus_creds_get_tty(sd_bus_creds *c, const char **tty);\nint sd_bus_creds_get_unique_name(sd_bus_creds *c, const char **name);\nint sd_bus_creds_get_well_known_names(sd_bus_creds *c, char ***names);\nint sd_bus_creds_get_description(sd_bus_creds *c, const char **name);\n\n/* Error structures */\n\n#define SD_BUS_ERROR_MAKE_CONST(name, message) ((const sd_bus_error) {(name), (message), 0})\n#define SD_BUS_ERROR_NULL SD_BUS_ERROR_MAKE_CONST(NULL, NULL)\n\nvoid sd_bus_error_free(sd_bus_error *e);\nint sd_bus_error_set(sd_bus_error *e, const char *name, const char *message);\nint sd_bus_error_setf(sd_bus_error *e, const char *name, const char *format, ...)  _sd_printf_(3, 4);\nint sd_bus_error_set_const(sd_bus_error *e, const char *name, const char *message);\nint sd_bus_error_set_errno(sd_bus_error *e, int error);\nint sd_bus_error_set_errnof(sd_bus_error *e, int error, const char *format, ...) _sd_printf_(3, 4);\nint sd_bus_error_set_errnofv(sd_bus_error *e, int error, const char *format, va_list ap) _sd_printf_(3,0);\nint sd_bus_error_get_errno(const sd_bus_error *e);\nint sd_bus_error_copy(sd_bus_error *dest, const sd_bus_error *e);\nint sd_bus_error_move(sd_bus_error *dest, sd_bus_error *e);\nint sd_bus_error_is_set(const sd_bus_error *e);\nint sd_bus_error_has_name(const sd_bus_error *e, const char *name);\n\n#define SD_BUS_ERROR_MAP(_name, _code)          \\\n        {                                       \\\n                .name = _name,                  \\\n                .code = _code,                  \\\n        }\n#define SD_BUS_ERROR_MAP_END                    \\\n        {                                       \\\n                .name = NULL,                   \\\n                .code = - 'x',                  \\\n        }\n\nint sd_bus_error_add_map(const sd_bus_error_map *map);\n\n/* Auxiliary macros */\n\n#define SD_BUS_MESSAGE_APPEND_ID128(x) 16,                              \\\n                (x).bytes[0],  (x).bytes[1],  (x).bytes[2],  (x).bytes[3], \\\n                (x).bytes[4],  (x).bytes[5],  (x).bytes[6],  (x).bytes[7], \\\n                (x).bytes[8],  (x).bytes[9],  (x).bytes[10], (x).bytes[11], \\\n                (x).bytes[12], (x).bytes[13], (x).bytes[14], (x).bytes[15]\n\n#define SD_BUS_MESSAGE_READ_ID128(x) 16,                                \\\n                &(x).bytes[0],  &(x).bytes[1],  &(x).bytes[2],  &(x).bytes[3], \\\n                &(x).bytes[4],  &(x).bytes[5],  &(x).bytes[6],  &(x).bytes[7], \\\n                &(x).bytes[8],  &(x).bytes[9],  &(x).bytes[10], &(x).bytes[11], \\\n                &(x).bytes[12], &(x).bytes[13], &(x).bytes[14], &(x).bytes[15]\n\n/* Label escaping */\n\nint sd_bus_path_encode(const char *prefix, const char *external_id, char **ret_path);\nint sd_bus_path_encode_many(char **out, const char *path_template, ...);\nint sd_bus_path_decode(const char *path, const char *prefix, char **ret_external_id);\nint sd_bus_path_decode_many(const char *path, const char *path_template, ...);\n\n/* Tracking peers */\n\nint sd_bus_track_new(sd_bus *bus, sd_bus_track **track, sd_bus_track_handler_t handler, void *userdata);\nsd_bus_track* sd_bus_track_ref(sd_bus_track *track);\nsd_bus_track* sd_bus_track_unref(sd_bus_track *track);\n\nsd_bus* sd_bus_track_get_bus(sd_bus_track *track);\nvoid *sd_bus_track_get_userdata(sd_bus_track *track);\nvoid *sd_bus_track_set_userdata(sd_bus_track *track, void *userdata);\n\nint sd_bus_track_add_sender(sd_bus_track *track, sd_bus_message *m);\nint sd_bus_track_remove_sender(sd_bus_track *track, sd_bus_message *m);\nint sd_bus_track_add_name(sd_bus_track *track, const char *name);\nint sd_bus_track_remove_name(sd_bus_track *track, const char *name);\n\nint sd_bus_track_set_recursive(sd_bus_track *track, int b);\nint sd_bus_track_get_recursive(sd_bus_track *track);\n\nunsigned sd_bus_track_count(sd_bus_track *track);\nint sd_bus_track_count_sender(sd_bus_track *track, sd_bus_message *m);\nint sd_bus_track_count_name(sd_bus_track *track, const char *name);\n\nconst char* sd_bus_track_contains(sd_bus_track *track, const char *name);\nconst char* sd_bus_track_first(sd_bus_track *track);\nconst char* sd_bus_track_next(sd_bus_track *track);\n\nint sd_bus_track_set_destroy_callback(sd_bus_track *s, sd_bus_destroy_t callback);\nint sd_bus_track_get_destroy_callback(sd_bus_track *s, sd_bus_destroy_t *ret);\n\n/* Define helpers so that __attribute__((cleanup(sd_bus_unrefp))) and similar may be used. */\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_bus, sd_bus_unref);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_bus, sd_bus_close_unref);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_bus, sd_bus_flush_close_unref);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_bus_slot, sd_bus_slot_unref);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_bus_message, sd_bus_message_unref);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_bus_creds, sd_bus_creds_unref);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_bus_track, sd_bus_track_unref);\n\n_SD_END_DECLARATIONS;\n\n#endif\n"], "filenames": ["src/libsystemd/libsystemd.sym", "src/libsystemd/sd-bus/sd-bus.c", "src/systemd/sd-bus.h"], "buggy_code_start_loc": [687, 4209, 209], "buggy_code_end_loc": [687, 4209, 209], "fixing_code_start_loc": [688, 4210, 210], "fixing_code_end_loc": [689, 4234, 211], "type": "CWE-416", "message": "A heap use-after-free vulnerability was found in systemd before version v245-rc1, where asynchronous Polkit queries are performed while handling dbus messages. A local unprivileged attacker can abuse this flaw to crash systemd services or potentially execute code and elevate their privileges, by sending specially crafted dbus messages.", "other": {"cve": {"id": "CVE-2020-1712", "sourceIdentifier": "secalert@redhat.com", "published": "2020-03-31T17:15:26.577", "lastModified": "2022-11-29T16:25:04.397", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A heap use-after-free vulnerability was found in systemd before version v245-rc1, where asynchronous Polkit queries are performed while handling dbus messages. A local unprivileged attacker can abuse this flaw to crash systemd services or potentially execute code and elevate their privileges, by sending specially crafted dbus messages."}, {"lang": "es", "value": "Se detect\u00f3 una vulnerabilidad uso de la memoria previamente liberada de la pila en systemd versiones anteriores a v245-rc1, donde se llevaron a cabo consultas de Polkit asincr\u00f3nicas mientras se manejan mensajes dbus. Un atacante no privilegiado local puede abusar de este fallo para bloquear los servicios de systemd o potencialmente ejecutar c\u00f3digo y elevar sus privilegios, mediante el env\u00edo de mensajes dbus especialmente dise\u00f1ados."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:systemd_project:systemd:*:*:*:*:*:*:*:*", "versionEndIncluding": "244", "matchCriteriaId": "20030C2B-7090-4057-BBE7-CFFEB5F6B6E8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "D6E54096-5D45-4CB2-AC9A-DDB55BF2B94C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:discovery:-:*:*:*:*:*:*:*", "matchCriteriaId": "B5B1D946-5978-4818-BF21-A43D9C1365E1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:migration_toolkit:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "7064499F-9063-4181-A26F-A3476C46CFE9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_container_platform:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "932D137F-528B-4526-9A89-CD59FA1AB0FE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2020-1712", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/systemd/systemd/commit/1068447e6954dc6ce52f099ed174c442cb89ed54", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/systemd/systemd/commit/637486261528e8aa3da9f26a4487dc254f4b7abb", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/systemd/systemd/commit/bc130b6858327b382b07b3985cf48e2aa9016b2d", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/systemd/systemd/commit/ea0d0ede03c6f18dbc5036c5e9cccf97e415ccc2", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/06/msg00025.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2020/02/05/1", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/systemd/systemd/commit/1068447e6954dc6ce52f099ed174c442cb89ed54"}}