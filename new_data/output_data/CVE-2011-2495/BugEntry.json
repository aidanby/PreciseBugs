{"buggy_code": ["/*\n *  linux/fs/proc/base.c\n *\n *  Copyright (C) 1991, 1992 Linus Torvalds\n *\n *  proc base directory handling functions\n *\n *  1999, Al Viro. Rewritten. Now it covers the whole per-process part.\n *  Instead of using magical inumbers to determine the kind of object\n *  we allocate and fill in-core inodes upon lookup. They don't even\n *  go into icache. We cache the reference to task_struct upon lookup too.\n *  Eventually it should become a filesystem in its own. We don't use the\n *  rest of procfs anymore.\n *\n *\n *  Changelog:\n *  17-Jan-2005\n *  Allan Bezerra\n *  Bruna Moreira <bruna.moreira@indt.org.br>\n *  Edjard Mota <edjard.mota@indt.org.br>\n *  Ilias Biris <ilias.biris@indt.org.br>\n *  Mauricio Lin <mauricio.lin@indt.org.br>\n *\n *  Embedded Linux Lab - 10LE Instituto Nokia de Tecnologia - INdT\n *\n *  A new process specific entry (smaps) included in /proc. It shows the\n *  size of rss for each memory area. The maps entry lacks information\n *  about physical memory size (rss) for each mapped file, i.e.,\n *  rss information for executables and library files.\n *  This additional information is useful for any tools that need to know\n *  about physical memory consumption for a process specific library.\n *\n *  Changelog:\n *  21-Feb-2005\n *  Embedded Linux Lab - 10LE Instituto Nokia de Tecnologia - INdT\n *  Pud inclusion in the page table walking.\n *\n *  ChangeLog:\n *  10-Mar-2005\n *  10LE Instituto Nokia de Tecnologia - INdT:\n *  A better way to walks through the page table as suggested by Hugh Dickins.\n *\n *  Simo Piiroinen <simo.piiroinen@nokia.com>:\n *  Smaps information related to shared, private, clean and dirty pages.\n *\n *  Paul Mundt <paul.mundt@nokia.com>:\n *  Overall revision about smaps.\n */\n\n#include <asm/uaccess.h>\n\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/namei.h>\n#include <linux/mnt_namespace.h>\n#include <linux/mm.h>\n#include <linux/swap.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/resource.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/tracehook.h>\n#include <linux/cgroup.h>\n#include <linux/cpuset.h>\n#include <linux/audit.h>\n#include <linux/poll.h>\n#include <linux/nsproxy.h>\n#include <linux/oom.h>\n#include <linux/elf.h>\n#include <linux/pid_namespace.h>\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#ifdef CONFIG_HARDWALL\n#include <asm/hardwall.h>\n#endif\n#include \"internal.h\"\n\n/* NOTE:\n *\tImplementing inode permission operations in /proc is almost\n *\tcertainly an error.  Permission checks need to happen during\n *\teach system call not at open time.  The reason is that most of\n *\twhat we wish to check for permissions in /proc varies at runtime.\n *\n *\tThe classic example of a problem is opening file descriptors\n *\tin /proc for a task before it execs a suid executable.\n */\n\nstruct pid_entry {\n\tchar *name;\n\tint len;\n\tmode_t mode;\n\tconst struct inode_operations *iop;\n\tconst struct file_operations *fop;\n\tunion proc_op op;\n};\n\n#define NOD(NAME, MODE, IOP, FOP, OP) {\t\t\t\\\n\t.name = (NAME),\t\t\t\t\t\\\n\t.len  = sizeof(NAME) - 1,\t\t\t\\\n\t.mode = MODE,\t\t\t\t\t\\\n\t.iop  = IOP,\t\t\t\t\t\\\n\t.fop  = FOP,\t\t\t\t\t\\\n\t.op   = OP,\t\t\t\t\t\\\n}\n\n#define DIR(NAME, MODE, iops, fops)\t\\\n\tNOD(NAME, (S_IFDIR|(MODE)), &iops, &fops, {} )\n#define LNK(NAME, get_link)\t\t\t\t\t\\\n\tNOD(NAME, (S_IFLNK|S_IRWXUGO),\t\t\t\t\\\n\t\t&proc_pid_link_inode_operations, NULL,\t\t\\\n\t\t{ .proc_get_link = get_link } )\n#define REG(NAME, MODE, fops)\t\t\t\t\\\n\tNOD(NAME, (S_IFREG|(MODE)), NULL, &fops, {})\n#define INF(NAME, MODE, read)\t\t\t\t\\\n\tNOD(NAME, (S_IFREG|(MODE)), \t\t\t\\\n\t\tNULL, &proc_info_file_operations,\t\\\n\t\t{ .proc_read = read } )\n#define ONE(NAME, MODE, show)\t\t\t\t\\\n\tNOD(NAME, (S_IFREG|(MODE)), \t\t\t\\\n\t\tNULL, &proc_single_file_operations,\t\\\n\t\t{ .proc_show = show } )\n\n/*\n * Count the number of hardlinks for the pid_entry table, excluding the .\n * and .. links.\n */\nstatic unsigned int pid_entry_count_dirs(const struct pid_entry *entries,\n\tunsigned int n)\n{\n\tunsigned int i;\n\tunsigned int count;\n\n\tcount = 0;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (S_ISDIR(entries[i].mode))\n\t\t\t++count;\n\t}\n\n\treturn count;\n}\n\nstatic int get_task_root(struct task_struct *task, struct path *root)\n{\n\tint result = -ENOENT;\n\n\ttask_lock(task);\n\tif (task->fs) {\n\t\tget_fs_root(task->fs, root);\n\t\tresult = 0;\n\t}\n\ttask_unlock(task);\n\treturn result;\n}\n\nstatic int proc_cwd_link(struct inode *inode, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tint result = -ENOENT;\n\n\tif (task) {\n\t\ttask_lock(task);\n\t\tif (task->fs) {\n\t\t\tget_fs_pwd(task->fs, path);\n\t\t\tresult = 0;\n\t\t}\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}\n\nstatic int proc_root_link(struct inode *inode, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tint result = -ENOENT;\n\n\tif (task) {\n\t\tresult = get_task_root(task, path);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}\n\nstatic struct mm_struct *__check_mem_permission(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * A task can always look at itself, in case it chooses\n\t * to use system calls instead of load instructions.\n\t */\n\tif (task == current)\n\t\treturn mm;\n\n\t/*\n\t * If current is actively ptrace'ing, and would also be\n\t * permitted to freshly attach with ptrace now, permit it.\n\t */\n\tif (task_is_stopped_or_traced(task)) {\n\t\tint match;\n\t\trcu_read_lock();\n\t\tmatch = (tracehook_tracer_task(task) == current);\n\t\trcu_read_unlock();\n\t\tif (match && ptrace_may_access(task, PTRACE_MODE_ATTACH))\n\t\t\treturn mm;\n\t}\n\n\t/*\n\t * No one else is allowed.\n\t */\n\tmmput(mm);\n\treturn ERR_PTR(-EPERM);\n}\n\n/*\n * If current may access user memory in @task return a reference to the\n * corresponding mm, otherwise ERR_PTR.\n */\nstatic struct mm_struct *check_mem_permission(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\tint err;\n\n\t/*\n\t * Avoid racing if task exec's as we might get a new mm but validate\n\t * against old credentials.\n\t */\n\terr = mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tmm = __check_mem_permission(task);\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n\n\treturn mm;\n}\n\nstruct mm_struct *mm_for_maps(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\tint err;\n\n\terr =  mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tmm = get_task_mm(task);\n\tif (mm && mm != current->mm &&\n\t\t\t!ptrace_may_access(task, PTRACE_MODE_READ)) {\n\t\tmmput(mm);\n\t\tmm = ERR_PTR(-EACCES);\n\t}\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n\n\treturn mm;\n}\n\nstatic int proc_pid_cmdline(struct task_struct *task, char * buffer)\n{\n\tint res = 0;\n\tunsigned int len;\n\tstruct mm_struct *mm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out;\n\tif (!mm->arg_end)\n\t\tgoto out_mm;\t/* Shh! No looking before we're done */\n\n \tlen = mm->arg_end - mm->arg_start;\n \n\tif (len > PAGE_SIZE)\n\t\tlen = PAGE_SIZE;\n \n\tres = access_process_vm(task, mm->arg_start, buffer, len, 0);\n\n\t// If the nul at the end of args has been overwritten, then\n\t// assume application is using setproctitle(3).\n\tif (res > 0 && buffer[res-1] != '\\0' && len < PAGE_SIZE) {\n\t\tlen = strnlen(buffer, res);\n\t\tif (len < res) {\n\t\t    res = len;\n\t\t} else {\n\t\t\tlen = mm->env_end - mm->env_start;\n\t\t\tif (len > PAGE_SIZE - res)\n\t\t\t\tlen = PAGE_SIZE - res;\n\t\t\tres += access_process_vm(task, mm->env_start, buffer+res, len, 0);\n\t\t\tres = strnlen(buffer, res);\n\t\t}\n\t}\nout_mm:\n\tmmput(mm);\nout:\n\treturn res;\n}\n\nstatic int proc_pid_auxv(struct task_struct *task, char *buffer)\n{\n\tstruct mm_struct *mm = mm_for_maps(task);\n\tint res = PTR_ERR(mm);\n\tif (mm && !IS_ERR(mm)) {\n\t\tunsigned int nwords = 0;\n\t\tdo {\n\t\t\tnwords += 2;\n\t\t} while (mm->saved_auxv[nwords - 2] != 0); /* AT_NULL */\n\t\tres = nwords * sizeof(mm->saved_auxv[0]);\n\t\tif (res > PAGE_SIZE)\n\t\t\tres = PAGE_SIZE;\n\t\tmemcpy(buffer, mm->saved_auxv, res);\n\t\tmmput(mm);\n\t}\n\treturn res;\n}\n\n\n#ifdef CONFIG_KALLSYMS\n/*\n * Provides a wchan file via kallsyms in a proper one-value-per-file format.\n * Returns the resolved symbol.  If that fails, simply return the address.\n */\nstatic int proc_pid_wchan(struct task_struct *task, char *buffer)\n{\n\tunsigned long wchan;\n\tchar symname[KSYM_NAME_LEN];\n\n\twchan = get_wchan(task);\n\n\tif (lookup_symbol_name(wchan, symname) < 0)\n\t\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn sprintf(buffer, \"%lu\", wchan);\n\telse\n\t\treturn sprintf(buffer, \"%s\", symname);\n}\n#endif /* CONFIG_KALLSYMS */\n\nstatic int lock_trace(struct task_struct *task)\n{\n\tint err = mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (err)\n\t\treturn err;\n\tif (!ptrace_may_access(task, PTRACE_MODE_ATTACH)) {\n\t\tmutex_unlock(&task->signal->cred_guard_mutex);\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}\n\nstatic void unlock_trace(struct task_struct *task)\n{\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n}\n\n#ifdef CONFIG_STACKTRACE\n\n#define MAX_STACK_TRACE_DEPTH\t64\n\nstatic int proc_pid_stack(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\tstruct stack_trace trace;\n\tunsigned long *entries;\n\tint err;\n\tint i;\n\n\tentries = kmalloc(MAX_STACK_TRACE_DEPTH * sizeof(*entries), GFP_KERNEL);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\ttrace.nr_entries\t= 0;\n\ttrace.max_entries\t= MAX_STACK_TRACE_DEPTH;\n\ttrace.entries\t\t= entries;\n\ttrace.skip\t\t= 0;\n\n\terr = lock_trace(task);\n\tif (!err) {\n\t\tsave_stack_trace_tsk(task, &trace);\n\n\t\tfor (i = 0; i < trace.nr_entries; i++) {\n\t\t\tseq_printf(m, \"[<%pK>] %pS\\n\",\n\t\t\t\t   (void *)entries[i], (void *)entries[i]);\n\t\t}\n\t\tunlock_trace(task);\n\t}\n\tkfree(entries);\n\n\treturn err;\n}\n#endif\n\n#ifdef CONFIG_SCHEDSTATS\n/*\n * Provides /proc/PID/schedstat\n */\nstatic int proc_pid_schedstat(struct task_struct *task, char *buffer)\n{\n\treturn sprintf(buffer, \"%llu %llu %lu\\n\",\n\t\t\t(unsigned long long)task->se.sum_exec_runtime,\n\t\t\t(unsigned long long)task->sched_info.run_delay,\n\t\t\ttask->sched_info.pcount);\n}\n#endif\n\n#ifdef CONFIG_LATENCYTOP\nstatic int lstats_show_proc(struct seq_file *m, void *v)\n{\n\tint i;\n\tstruct inode *inode = m->private;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tseq_puts(m, \"Latency Top version : v0.1\\n\");\n\tfor (i = 0; i < 32; i++) {\n\t\tstruct latency_record *lr = &task->latency_record[i];\n\t\tif (lr->backtrace[0]) {\n\t\t\tint q;\n\t\t\tseq_printf(m, \"%i %li %li\",\n\t\t\t\t   lr->count, lr->time, lr->max);\n\t\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\t\tunsigned long bt = lr->backtrace[q];\n\t\t\t\tif (!bt)\n\t\t\t\t\tbreak;\n\t\t\t\tif (bt == ULONG_MAX)\n\t\t\t\t\tbreak;\n\t\t\t\tseq_printf(m, \" %ps\", (void *)bt);\n\t\t\t}\n\t\t\tseq_putc(m, '\\n');\n\t\t}\n\n\t}\n\tput_task_struct(task);\n\treturn 0;\n}\n\nstatic int lstats_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, lstats_show_proc, inode);\n}\n\nstatic ssize_t lstats_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *offs)\n{\n\tstruct task_struct *task = get_proc_task(file->f_dentry->d_inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tclear_all_latency_tracing(task);\n\tput_task_struct(task);\n\n\treturn count;\n}\n\nstatic const struct file_operations proc_lstats_operations = {\n\t.open\t\t= lstats_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= lstats_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n#endif\n\nstatic int proc_oom_score(struct task_struct *task, char *buffer)\n{\n\tunsigned long points = 0;\n\n\tread_lock(&tasklist_lock);\n\tif (pid_alive(task))\n\t\tpoints = oom_badness(task, NULL, NULL,\n\t\t\t\t\ttotalram_pages + total_swap_pages);\n\tread_unlock(&tasklist_lock);\n\treturn sprintf(buffer, \"%lu\\n\", points);\n}\n\nstruct limit_names {\n\tchar *name;\n\tchar *unit;\n};\n\nstatic const struct limit_names lnames[RLIM_NLIMITS] = {\n\t[RLIMIT_CPU] = {\"Max cpu time\", \"seconds\"},\n\t[RLIMIT_FSIZE] = {\"Max file size\", \"bytes\"},\n\t[RLIMIT_DATA] = {\"Max data size\", \"bytes\"},\n\t[RLIMIT_STACK] = {\"Max stack size\", \"bytes\"},\n\t[RLIMIT_CORE] = {\"Max core file size\", \"bytes\"},\n\t[RLIMIT_RSS] = {\"Max resident set\", \"bytes\"},\n\t[RLIMIT_NPROC] = {\"Max processes\", \"processes\"},\n\t[RLIMIT_NOFILE] = {\"Max open files\", \"files\"},\n\t[RLIMIT_MEMLOCK] = {\"Max locked memory\", \"bytes\"},\n\t[RLIMIT_AS] = {\"Max address space\", \"bytes\"},\n\t[RLIMIT_LOCKS] = {\"Max file locks\", \"locks\"},\n\t[RLIMIT_SIGPENDING] = {\"Max pending signals\", \"signals\"},\n\t[RLIMIT_MSGQUEUE] = {\"Max msgqueue size\", \"bytes\"},\n\t[RLIMIT_NICE] = {\"Max nice priority\", NULL},\n\t[RLIMIT_RTPRIO] = {\"Max realtime priority\", NULL},\n\t[RLIMIT_RTTIME] = {\"Max realtime timeout\", \"us\"},\n};\n\n/* Display limits for a process */\nstatic int proc_pid_limits(struct task_struct *task, char *buffer)\n{\n\tunsigned int i;\n\tint count = 0;\n\tunsigned long flags;\n\tchar *bufptr = buffer;\n\n\tstruct rlimit rlim[RLIM_NLIMITS];\n\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn 0;\n\tmemcpy(rlim, task->signal->rlim, sizeof(struct rlimit) * RLIM_NLIMITS);\n\tunlock_task_sighand(task, &flags);\n\n\t/*\n\t * print the file header\n\t */\n\tcount += sprintf(&bufptr[count], \"%-25s %-20s %-20s %-10s\\n\",\n\t\t\t\"Limit\", \"Soft Limit\", \"Hard Limit\", \"Units\");\n\n\tfor (i = 0; i < RLIM_NLIMITS; i++) {\n\t\tif (rlim[i].rlim_cur == RLIM_INFINITY)\n\t\t\tcount += sprintf(&bufptr[count], \"%-25s %-20s \",\n\t\t\t\t\t lnames[i].name, \"unlimited\");\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"%-25s %-20lu \",\n\t\t\t\t\t lnames[i].name, rlim[i].rlim_cur);\n\n\t\tif (rlim[i].rlim_max == RLIM_INFINITY)\n\t\t\tcount += sprintf(&bufptr[count], \"%-20s \", \"unlimited\");\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"%-20lu \",\n\t\t\t\t\t rlim[i].rlim_max);\n\n\t\tif (lnames[i].unit)\n\t\t\tcount += sprintf(&bufptr[count], \"%-10s\\n\",\n\t\t\t\t\t lnames[i].unit);\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"\\n\");\n\t}\n\n\treturn count;\n}\n\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\nstatic int proc_pid_syscall(struct task_struct *task, char *buffer)\n{\n\tlong nr;\n\tunsigned long args[6], sp, pc;\n\tint res = lock_trace(task);\n\tif (res)\n\t\treturn res;\n\n\tif (task_current_syscall(task, &nr, args, 6, &sp, &pc))\n\t\tres = sprintf(buffer, \"running\\n\");\n\telse if (nr < 0)\n\t\tres = sprintf(buffer, \"%ld 0x%lx 0x%lx\\n\", nr, sp, pc);\n\telse\n\t\tres = sprintf(buffer,\n\t\t       \"%ld 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx\\n\",\n\t\t       nr,\n\t\t       args[0], args[1], args[2], args[3], args[4], args[5],\n\t\t       sp, pc);\n\tunlock_trace(task);\n\treturn res;\n}\n#endif /* CONFIG_HAVE_ARCH_TRACEHOOK */\n\n/************************************************************************/\n/*                       Here the fs part begins                        */\n/************************************************************************/\n\n/* permission checks */\nstatic int proc_fd_access_allowed(struct inode *inode)\n{\n\tstruct task_struct *task;\n\tint allowed = 0;\n\t/* Allow access to a task's file descriptors if it is us or we\n\t * may use ptrace attach to the process and find out that\n\t * information.\n\t */\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\tallowed = ptrace_may_access(task, PTRACE_MODE_READ);\n\t\tput_task_struct(task);\n\t}\n\treturn allowed;\n}\n\nint proc_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint error;\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (attr->ia_valid & ATTR_MODE)\n\t\treturn -EPERM;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = vmtruncate(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}\n\nstatic const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};\n\nstatic int mounts_open_common(struct inode *inode, struct file *file,\n\t\t\t      const struct seq_operations *op)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct nsproxy *nsp;\n\tstruct mnt_namespace *ns = NULL;\n\tstruct path root;\n\tstruct proc_mounts *p;\n\tint ret = -EINVAL;\n\n\tif (task) {\n\t\trcu_read_lock();\n\t\tnsp = task_nsproxy(task);\n\t\tif (nsp) {\n\t\t\tns = nsp->mnt_ns;\n\t\t\tif (ns)\n\t\t\t\tget_mnt_ns(ns);\n\t\t}\n\t\trcu_read_unlock();\n\t\tif (ns && get_task_root(task, &root) == 0)\n\t\t\tret = 0;\n\t\tput_task_struct(task);\n\t}\n\n\tif (!ns)\n\t\tgoto err;\n\tif (ret)\n\t\tgoto err_put_ns;\n\n\tret = -ENOMEM;\n\tp = kmalloc(sizeof(struct proc_mounts), GFP_KERNEL);\n\tif (!p)\n\t\tgoto err_put_path;\n\n\tfile->private_data = &p->m;\n\tret = seq_open(file, op);\n\tif (ret)\n\t\tgoto err_free;\n\n\tp->m.private = p;\n\tp->ns = ns;\n\tp->root = root;\n\tp->event = ns->event;\n\n\treturn 0;\n\n err_free:\n\tkfree(p);\n err_put_path:\n\tpath_put(&root);\n err_put_ns:\n\tput_mnt_ns(ns);\n err:\n\treturn ret;\n}\n\nstatic int mounts_release(struct inode *inode, struct file *file)\n{\n\tstruct proc_mounts *p = file->private_data;\n\tpath_put(&p->root);\n\tput_mnt_ns(p->ns);\n\treturn seq_release(inode, file);\n}\n\nstatic unsigned mounts_poll(struct file *file, poll_table *wait)\n{\n\tstruct proc_mounts *p = file->private_data;\n\tunsigned res = POLLIN | POLLRDNORM;\n\n\tpoll_wait(file, &p->ns->poll, wait);\n\tif (mnt_had_events(p))\n\t\tres |= POLLERR | POLLPRI;\n\n\treturn res;\n}\n\nstatic int mounts_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, &mounts_op);\n}\n\nstatic const struct file_operations proc_mounts_operations = {\n\t.open\t\t= mounts_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= mounts_release,\n\t.poll\t\t= mounts_poll,\n};\n\nstatic int mountinfo_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, &mountinfo_op);\n}\n\nstatic const struct file_operations proc_mountinfo_operations = {\n\t.open\t\t= mountinfo_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= mounts_release,\n\t.poll\t\t= mounts_poll,\n};\n\nstatic int mountstats_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, &mountstats_op);\n}\n\nstatic const struct file_operations proc_mountstats_operations = {\n\t.open\t\t= mountstats_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= mounts_release,\n};\n\n#define PROC_BLOCK_SIZE\t(3*1024)\t\t/* 4K page size but our output routines use some slack for overruns */\n\nstatic ssize_t proc_info_read(struct file * file, char __user * buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tunsigned long page;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tlength = -ESRCH;\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tif (count > PROC_BLOCK_SIZE)\n\t\tcount = PROC_BLOCK_SIZE;\n\n\tlength = -ENOMEM;\n\tif (!(page = __get_free_page(GFP_TEMPORARY)))\n\t\tgoto out;\n\n\tlength = PROC_I(inode)->op.proc_read(task, (char*)page);\n\n\tif (length >= 0)\n\t\tlength = simple_read_from_buffer(buf, count, ppos, (char *)page, length);\n\tfree_page(page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn length;\n}\n\nstatic const struct file_operations proc_info_file_operations = {\n\t.read\t\t= proc_info_read,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int proc_single_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct pid_namespace *ns;\n\tstruct pid *pid;\n\tstruct task_struct *task;\n\tint ret;\n\n\tns = inode->i_sb->s_fs_info;\n\tpid = proc_pid(inode);\n\ttask = get_pid_task(pid, PIDTYPE_PID);\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tret = PROC_I(inode)->op.proc_show(m, ns, pid, task);\n\n\tput_task_struct(task);\n\treturn ret;\n}\n\nstatic int proc_single_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, proc_single_show, inode);\n}\n\nstatic const struct file_operations proc_single_file_operations = {\n\t.open\t\t= proc_single_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int mem_open(struct inode* inode, struct file* file)\n{\n\tfile->private_data = (void*)((long)current->self_exec_id);\n\t/* OK to pass negative loff_t, we can catch out-of-range */\n\tfile->f_mode |= FMODE_UNSIGNED_OFFSET;\n\treturn 0;\n}\n\nstatic ssize_t mem_read(struct file * file, char __user * buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = -ESRCH;\n\tstruct mm_struct *mm;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tret = -ENOMEM;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\n\tmm = check_mem_permission(task);\n\tret = PTR_ERR(mm);\n\tif (IS_ERR(mm))\n\t\tgoto out_free;\n\n\tret = -EIO;\n \n\tif (file->private_data != (void*)((long)current->self_exec_id))\n\t\tgoto out_put;\n\n\tret = 0;\n \n\twhile (count > 0) {\n\t\tint this_len, retval;\n\n\t\tthis_len = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n\t\tretval = access_remote_vm(mm, src, page, this_len, 0);\n\t\tif (!retval) {\n\t\t\tif (!ret)\n\t\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n \n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\nout_put:\n\tmmput(mm);\nout_free:\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ret;\n}\n\nstatic ssize_t mem_write(struct file * file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tint copied;\n\tchar *page;\n\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n\tunsigned long dst = *ppos;\n\tstruct mm_struct *mm;\n\n\tcopied = -ESRCH;\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tcopied = -ENOMEM;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out_task;\n\n\tmm = check_mem_permission(task);\n\tcopied = PTR_ERR(mm);\n\tif (IS_ERR(mm))\n\t\tgoto out_free;\n\n\tcopied = -EIO;\n\tif (file->private_data != (void *)((long)current->self_exec_id))\n\t\tgoto out_mm;\n\n\tcopied = 0;\n\twhile (count > 0) {\n\t\tint this_len, retval;\n\n\t\tthis_len = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n\t\tif (copy_from_user(page, buf, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tretval = access_remote_vm(mm, dst, page, this_len, 1);\n\t\tif (!retval) {\n\t\t\tif (!copied)\n\t\t\t\tcopied = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcopied += retval;\n\t\tbuf += retval;\n\t\tdst += retval;\n\t\tcount -= retval;\t\t\t\n\t}\n\t*ppos = dst;\n\nout_mm:\n\tmmput(mm);\nout_free:\n\tfree_page((unsigned long) page);\nout_task:\n\tput_task_struct(task);\nout_no_task:\n\treturn copied;\n}\n\nloff_t mem_lseek(struct file *file, loff_t offset, int orig)\n{\n\tswitch (orig) {\n\tcase 0:\n\t\tfile->f_pos = offset;\n\t\tbreak;\n\tcase 1:\n\t\tfile->f_pos += offset;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tforce_successful_syscall_return();\n\treturn file->f_pos;\n}\n\nstatic const struct file_operations proc_mem_operations = {\n\t.llseek\t\t= mem_lseek,\n\t.read\t\t= mem_read,\n\t.write\t\t= mem_write,\n\t.open\t\t= mem_open,\n};\n\nstatic ssize_t environ_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_dentry->d_inode);\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = -ESRCH;\n\tstruct mm_struct *mm;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tret = -ENOMEM;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\n\n\tmm = mm_for_maps(task);\n\tret = PTR_ERR(mm);\n\tif (!mm || IS_ERR(mm))\n\t\tgoto out_free;\n\n\tret = 0;\n\twhile (count > 0) {\n\t\tint this_len, retval, max_len;\n\n\t\tthis_len = mm->env_end - (mm->env_start + src);\n\n\t\tif (this_len <= 0)\n\t\t\tbreak;\n\n\t\tmax_len = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n\t\tthis_len = (this_len > max_len) ? max_len : this_len;\n\n\t\tretval = access_process_vm(task, (mm->env_start + src),\n\t\t\tpage, this_len, 0);\n\n\t\tif (retval <= 0) {\n\t\t\tret = retval;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\n\tmmput(mm);\nout_free:\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ret;\n}\n\nstatic const struct file_operations proc_environ_operations = {\n\t.read\t\t= environ_read,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic ssize_t oom_adjust_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint oom_adjust = OOM_DISABLE;\n\tunsigned long flags;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tif (lock_task_sighand(task, &flags)) {\n\t\toom_adjust = task->signal->oom_adj;\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\n\tput_task_struct(task);\n\n\tlen = snprintf(buffer, sizeof(buffer), \"%i\\n\", oom_adjust);\n\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}\n\nstatic ssize_t oom_adjust_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tint oom_adjust;\n\tunsigned long flags;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terr = kstrtoint(strstrip(buffer), 0, &oom_adjust);\n\tif (err)\n\t\tgoto out;\n\tif ((oom_adjust < OOM_ADJUST_MIN || oom_adjust > OOM_ADJUST_MAX) &&\n\t     oom_adjust != OOM_DISABLE) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttask = get_proc_task(file->f_path.dentry->d_inode);\n\tif (!task) {\n\t\terr = -ESRCH;\n\t\tgoto out;\n\t}\n\n\ttask_lock(task);\n\tif (!task->mm) {\n\t\terr = -EINVAL;\n\t\tgoto err_task_lock;\n\t}\n\n\tif (!lock_task_sighand(task, &flags)) {\n\t\terr = -ESRCH;\n\t\tgoto err_task_lock;\n\t}\n\n\tif (oom_adjust < task->signal->oom_adj && !capable(CAP_SYS_RESOURCE)) {\n\t\terr = -EACCES;\n\t\tgoto err_sighand;\n\t}\n\n\tif (oom_adjust != task->signal->oom_adj) {\n\t\tif (oom_adjust == OOM_DISABLE)\n\t\t\tatomic_inc(&task->mm->oom_disable_count);\n\t\tif (task->signal->oom_adj == OOM_DISABLE)\n\t\t\tatomic_dec(&task->mm->oom_disable_count);\n\t}\n\n\t/*\n\t * Warn that /proc/pid/oom_adj is deprecated, see\n\t * Documentation/feature-removal-schedule.txt.\n\t */\n\tprintk_once(KERN_WARNING \"%s (%d): /proc/%d/oom_adj is deprecated, \"\n\t\t\t\"please use /proc/%d/oom_score_adj instead.\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\ttask_pid_nr(task), task_pid_nr(task));\n\ttask->signal->oom_adj = oom_adjust;\n\t/*\n\t * Scale /proc/pid/oom_score_adj appropriately ensuring that a maximum\n\t * value is always attainable.\n\t */\n\tif (task->signal->oom_adj == OOM_ADJUST_MAX)\n\t\ttask->signal->oom_score_adj = OOM_SCORE_ADJ_MAX;\n\telse\n\t\ttask->signal->oom_score_adj = (oom_adjust * OOM_SCORE_ADJ_MAX) /\n\t\t\t\t\t\t\t\t-OOM_DISABLE;\nerr_sighand:\n\tunlock_task_sighand(task, &flags);\nerr_task_lock:\n\ttask_unlock(task);\n\tput_task_struct(task);\nout:\n\treturn err < 0 ? err : count;\n}\n\nstatic const struct file_operations proc_oom_adjust_operations = {\n\t.read\t\t= oom_adjust_read,\n\t.write\t\t= oom_adjust_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic ssize_t oom_score_adj_read(struct file *file, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n\tchar buffer[PROC_NUMBUF];\n\tint oom_score_adj = OOM_SCORE_ADJ_MIN;\n\tunsigned long flags;\n\tsize_t len;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tif (lock_task_sighand(task, &flags)) {\n\t\toom_score_adj = task->signal->oom_score_adj;\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\tput_task_struct(task);\n\tlen = snprintf(buffer, sizeof(buffer), \"%d\\n\", oom_score_adj);\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}\n\nstatic ssize_t oom_score_adj_write(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tunsigned long flags;\n\tint oom_score_adj;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terr = kstrtoint(strstrip(buffer), 0, &oom_score_adj);\n\tif (err)\n\t\tgoto out;\n\tif (oom_score_adj < OOM_SCORE_ADJ_MIN ||\n\t\t\toom_score_adj > OOM_SCORE_ADJ_MAX) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttask = get_proc_task(file->f_path.dentry->d_inode);\n\tif (!task) {\n\t\terr = -ESRCH;\n\t\tgoto out;\n\t}\n\n\ttask_lock(task);\n\tif (!task->mm) {\n\t\terr = -EINVAL;\n\t\tgoto err_task_lock;\n\t}\n\n\tif (!lock_task_sighand(task, &flags)) {\n\t\terr = -ESRCH;\n\t\tgoto err_task_lock;\n\t}\n\n\tif (oom_score_adj < task->signal->oom_score_adj_min &&\n\t\t\t!capable(CAP_SYS_RESOURCE)) {\n\t\terr = -EACCES;\n\t\tgoto err_sighand;\n\t}\n\n\tif (oom_score_adj != task->signal->oom_score_adj) {\n\t\tif (oom_score_adj == OOM_SCORE_ADJ_MIN)\n\t\t\tatomic_inc(&task->mm->oom_disable_count);\n\t\tif (task->signal->oom_score_adj == OOM_SCORE_ADJ_MIN)\n\t\t\tatomic_dec(&task->mm->oom_disable_count);\n\t}\n\ttask->signal->oom_score_adj = oom_score_adj;\n\tif (has_capability_noaudit(current, CAP_SYS_RESOURCE))\n\t\ttask->signal->oom_score_adj_min = oom_score_adj;\n\t/*\n\t * Scale /proc/pid/oom_adj appropriately ensuring that OOM_DISABLE is\n\t * always attainable.\n\t */\n\tif (task->signal->oom_score_adj == OOM_SCORE_ADJ_MIN)\n\t\ttask->signal->oom_adj = OOM_DISABLE;\n\telse\n\t\ttask->signal->oom_adj = (oom_score_adj * OOM_ADJUST_MAX) /\n\t\t\t\t\t\t\tOOM_SCORE_ADJ_MAX;\nerr_sighand:\n\tunlock_task_sighand(task, &flags);\nerr_task_lock:\n\ttask_unlock(task);\n\tput_task_struct(task);\nout:\n\treturn err < 0 ? err : count;\n}\n\nstatic const struct file_operations proc_oom_score_adj_operations = {\n\t.read\t\t= oom_score_adj_read,\n\t.write\t\t= oom_score_adj_write,\n\t.llseek\t\t= default_llseek,\n};\n\n#ifdef CONFIG_AUDITSYSCALL\n#define TMPBUFLEN 21\nstatic ssize_t proc_loginuid_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tstruct task_struct *task = get_proc_task(inode);\n\tssize_t length;\n\tchar tmpbuf[TMPBUFLEN];\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\",\n\t\t\t\taudit_get_loginuid(task));\n\tput_task_struct(task);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n\nstatic ssize_t proc_loginuid_write(struct file * file, const char __user * buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tchar *page, *tmp;\n\tssize_t length;\n\tuid_t loginuid;\n\n\tif (!capable(CAP_AUDIT_CONTROL))\n\t\treturn -EPERM;\n\n\trcu_read_lock();\n\tif (current != pid_task(proc_pid(inode), PIDTYPE_PID)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\n\tif (count >= PAGE_SIZE)\n\t\tcount = PAGE_SIZE - 1;\n\n\tif (*ppos != 0) {\n\t\t/* No partial writes. */\n\t\treturn -EINVAL;\n\t}\n\tpage = (char*)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tlength = -EFAULT;\n\tif (copy_from_user(page, buf, count))\n\t\tgoto out_free_page;\n\n\tpage[count] = '\\0';\n\tloginuid = simple_strtoul(page, &tmp, 10);\n\tif (tmp == page) {\n\t\tlength = -EINVAL;\n\t\tgoto out_free_page;\n\n\t}\n\tlength = audit_set_loginuid(current, loginuid);\n\tif (likely(length == 0))\n\t\tlength = count;\n\nout_free_page:\n\tfree_page((unsigned long) page);\n\treturn length;\n}\n\nstatic const struct file_operations proc_loginuid_operations = {\n\t.read\t\t= proc_loginuid_read,\n\t.write\t\t= proc_loginuid_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic ssize_t proc_sessionid_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tstruct task_struct *task = get_proc_task(inode);\n\tssize_t length;\n\tchar tmpbuf[TMPBUFLEN];\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\",\n\t\t\t\taudit_get_sessionid(task));\n\tput_task_struct(task);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n\nstatic const struct file_operations proc_sessionid_operations = {\n\t.read\t\t= proc_sessionid_read,\n\t.llseek\t\t= generic_file_llseek,\n};\n#endif\n\n#ifdef CONFIG_FAULT_INJECTION\nstatic ssize_t proc_fault_inject_read(struct file * file, char __user * buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_dentry->d_inode);\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint make_it_fail;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tmake_it_fail = task->make_it_fail;\n\tput_task_struct(task);\n\n\tlen = snprintf(buffer, sizeof(buffer), \"%i\\n\", make_it_fail);\n\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}\n\nstatic ssize_t proc_fault_inject_write(struct file * file,\n\t\t\tconst char __user * buf, size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF], *end;\n\tint make_it_fail;\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\tmake_it_fail = simple_strtol(strstrip(buffer), &end, 0);\n\tif (*end)\n\t\treturn -EINVAL;\n\ttask = get_proc_task(file->f_dentry->d_inode);\n\tif (!task)\n\t\treturn -ESRCH;\n\ttask->make_it_fail = make_it_fail;\n\tput_task_struct(task);\n\n\treturn count;\n}\n\nstatic const struct file_operations proc_fault_inject_operations = {\n\t.read\t\t= proc_fault_inject_read,\n\t.write\t\t= proc_fault_inject_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n#endif\n\n\n#ifdef CONFIG_SCHED_DEBUG\n/*\n * Print out various scheduling related per-task fields:\n */\nstatic int sched_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_show_task(p, m);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic ssize_t\nsched_write(struct file *file, const char __user *buf,\n\t    size_t count, loff_t *offset)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_set_task(p);\n\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int sched_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, sched_show, inode);\n}\n\nstatic const struct file_operations proc_pid_sched_operations = {\n\t.open\t\t= sched_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= sched_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n#endif\n\n#ifdef CONFIG_SCHED_AUTOGROUP\n/*\n * Print out autogroup related information:\n */\nstatic int sched_autogroup_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_autogroup_show_task(p, m);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic ssize_t\nsched_autogroup_write(struct file *file, const char __user *buf,\n\t    size_t count, loff_t *offset)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct task_struct *p;\n\tchar buffer[PROC_NUMBUF];\n\tint nice;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\n\terr = kstrtoint(strstrip(buffer), 0, &nice);\n\tif (err < 0)\n\t\treturn err;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\terr = nice;\n\terr = proc_sched_autogroup_set_nice(p, &err);\n\tif (err)\n\t\tcount = err;\n\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int sched_autogroup_open(struct inode *inode, struct file *filp)\n{\n\tint ret;\n\n\tret = single_open(filp, sched_autogroup_show, NULL);\n\tif (!ret) {\n\t\tstruct seq_file *m = filp->private_data;\n\n\t\tm->private = inode;\n\t}\n\treturn ret;\n}\n\nstatic const struct file_operations proc_pid_sched_autogroup_operations = {\n\t.open\t\t= sched_autogroup_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= sched_autogroup_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n#endif /* CONFIG_SCHED_AUTOGROUP */\n\nstatic ssize_t comm_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *offset)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct task_struct *p;\n\tchar buffer[TASK_COMM_LEN];\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (same_thread_group(current, p))\n\t\tset_task_comm(p, buffer);\n\telse\n\t\tcount = -EINVAL;\n\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int comm_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\ttask_lock(p);\n\tseq_printf(m, \"%s\\n\", p->comm);\n\ttask_unlock(p);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic int comm_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, comm_show, inode);\n}\n\nstatic const struct file_operations proc_pid_set_comm_operations = {\n\t.open\t\t= comm_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= comm_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int proc_exe_link(struct inode *inode, struct path *exe_path)\n{\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tstruct file *exe_file;\n\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\treturn -ENOENT;\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\tif (!mm)\n\t\treturn -ENOENT;\n\texe_file = get_mm_exe_file(mm);\n\tmmput(mm);\n\tif (exe_file) {\n\t\t*exe_path = exe_file->f_path;\n\t\tpath_get(&exe_file->f_path);\n\t\tfput(exe_file);\n\t\treturn 0;\n\t} else\n\t\treturn -ENOENT;\n}\n\nstatic void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\n\t/* We don't need a base pointer in the /proc filesystem */\n\tpath_put(&nd->path);\n\n\t/* Are we allowed to snoop on the tasks file descriptors? */\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(inode, &nd->path);\nout:\n\treturn ERR_PTR(error);\n}\n\nstatic int do_proc_readlink(struct path *path, char __user *buffer, int buflen)\n{\n\tchar *tmp = (char*)__get_free_page(GFP_TEMPORARY);\n\tchar *pathname;\n\tint len;\n\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tpathname = d_path(path, tmp, PAGE_SIZE);\n\tlen = PTR_ERR(pathname);\n\tif (IS_ERR(pathname))\n\t\tgoto out;\n\tlen = tmp + PAGE_SIZE - 1 - pathname;\n\n\tif (len > buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, pathname, len))\n\t\tlen = -EFAULT;\n out:\n\tfree_page((unsigned long)tmp);\n\treturn len;\n}\n\nstatic int proc_pid_readlink(struct dentry * dentry, char __user * buffer, int buflen)\n{\n\tint error = -EACCES;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct path path;\n\n\t/* Are we allowed to snoop on the tasks file descriptors? */\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(inode, &path);\n\tif (error)\n\t\tgoto out;\n\n\terror = do_proc_readlink(&path, buffer, buflen);\n\tpath_put(&path);\nout:\n\treturn error;\n}\n\nstatic const struct inode_operations proc_pid_link_inode_operations = {\n\t.readlink\t= proc_pid_readlink,\n\t.follow_link\t= proc_pid_follow_link,\n\t.setattr\t= proc_setattr,\n};\n\n\n/* building an inode */\n\nstatic int task_dumpable(struct task_struct *task)\n{\n\tint dumpable = 0;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm)\n\t\tdumpable = get_dumpable(mm);\n\ttask_unlock(task);\n\tif(dumpable == 1)\n\t\treturn 1;\n\treturn 0;\n}\n\nstruct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}\n\nint pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\n\tgeneric_fillattr(inode, stat);\n\n\trcu_read_lock();\n\tstat->uid = 0;\n\tstat->gid = 0;\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\tcred = __task_cred(task);\n\t\t\tstat->uid = cred->euid;\n\t\t\tstat->gid = cred->egid;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}\n\n/* dentry stuff */\n\n/*\n *\tExceptional case: normally we are not allowed to unhash a busy\n * directory. In this case, however, we can do it - no aliasing problems\n * due to the way we treat inodes.\n *\n * Rewrite the inode's ownerships here because the owning task may have\n * performed a setuid(), etc.\n *\n * Before the /proc/pid/status file was created the only way to read\n * the effective uid of a /process was to stat /proc/pid.  Reading\n * /proc/pid/status is slow enough that procps and other packages\n * kept stating /proc/pid.  To keep the rules in /proc simple I have\n * made this apply to all per process world readable and executable\n * directories.\n */\nint pid_revalidate(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\n\tif (nd && nd->flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\trcu_read_lock();\n\t\t\tcred = __task_cred(task);\n\t\t\tinode->i_uid = cred->euid;\n\t\t\tinode->i_gid = cred->egid;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tinode->i_uid = 0;\n\t\t\tinode->i_gid = 0;\n\t\t}\n\t\tinode->i_mode &= ~(S_ISUID | S_ISGID);\n\t\tsecurity_task_to_inode(task, inode);\n\t\tput_task_struct(task);\n\t\treturn 1;\n\t}\n\td_drop(dentry);\n\treturn 0;\n}\n\nstatic int pid_delete_dentry(const struct dentry * dentry)\n{\n\t/* Is the task we represent dead?\n\t * If so, then don't put the dentry on the lru list,\n\t * kill it immediately.\n\t */\n\treturn !proc_pid(dentry->d_inode)->tasks[PIDTYPE_PID].first;\n}\n\nconst struct dentry_operations pid_dentry_operations =\n{\n\t.d_revalidate\t= pid_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\n/* Lookups */\n\n/*\n * Fill a directory entry.\n *\n * If possible create the dcache entry and derive our inode number and\n * file type from dcache entry.\n *\n * Since all of the proc inode numbers are dynamically generated, the inode\n * numbers do not exist until the inode is cache.  This means creating the\n * the dcache entry in readdir is necessary to keep the inode numbers\n * reported by readdir in sync with the inode numbers reported\n * by stat.\n */\nint proc_fill_cache(struct file *filp, void *dirent, filldir_t filldir,\n\tconst char *name, int len,\n\tinstantiate_t instantiate, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *child, *dir = filp->f_path.dentry;\n\tstruct inode *inode;\n\tstruct qstr qname;\n\tino_t ino = 0;\n\tunsigned type = DT_UNKNOWN;\n\n\tqname.name = name;\n\tqname.len  = len;\n\tqname.hash = full_name_hash(name, len);\n\n\tchild = d_lookup(dir, &qname);\n\tif (!child) {\n\t\tstruct dentry *new;\n\t\tnew = d_alloc(dir, &qname);\n\t\tif (new) {\n\t\t\tchild = instantiate(dir->d_inode, new, task, ptr);\n\t\t\tif (child)\n\t\t\t\tdput(new);\n\t\t\telse\n\t\t\t\tchild = new;\n\t\t}\n\t}\n\tif (!child || IS_ERR(child) || !child->d_inode)\n\t\tgoto end_instantiate;\n\tinode = child->d_inode;\n\tif (inode) {\n\t\tino = inode->i_ino;\n\t\ttype = inode->i_mode >> 12;\n\t}\n\tdput(child);\nend_instantiate:\n\tif (!ino)\n\t\tino = find_inode_number(dir, &qname);\n\tif (!ino)\n\t\tino = 1;\n\treturn filldir(dirent, name, len, filp->f_pos, ino, type);\n}\n\nstatic unsigned name_to_int(struct dentry *dentry)\n{\n\tconst char *name = dentry->d_name.name;\n\tint len = dentry->d_name.len;\n\tunsigned n = 0;\n\n\tif (len > 1 && *name == '0')\n\t\tgoto out;\n\twhile (len-- > 0) {\n\t\tunsigned c = *name++ - '0';\n\t\tif (c > 9)\n\t\t\tgoto out;\n\t\tif (n >= (~0U-9)/10)\n\t\t\tgoto out;\n\t\tn *= 10;\n\t\tn += c;\n\t}\n\treturn n;\nout:\n\treturn ~0U;\n}\n\n#define PROC_FDINFO_MAX 64\n\nstatic int proc_fd_info(struct inode *inode, struct path *path, char *info)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct files_struct *files = NULL;\n\tstruct file *file;\n\tint fd = proc_fd(inode);\n\n\tif (task) {\n\t\tfiles = get_files_struct(task);\n\t\tput_task_struct(task);\n\t}\n\tif (files) {\n\t\t/*\n\t\t * We are not taking a ref to the file structure, so we must\n\t\t * hold ->file_lock.\n\t\t */\n\t\tspin_lock(&files->file_lock);\n\t\tfile = fcheck_files(files, fd);\n\t\tif (file) {\n\t\t\tif (path) {\n\t\t\t\t*path = file->f_path;\n\t\t\t\tpath_get(&file->f_path);\n\t\t\t}\n\t\t\tif (info)\n\t\t\t\tsnprintf(info, PROC_FDINFO_MAX,\n\t\t\t\t\t \"pos:\\t%lli\\n\"\n\t\t\t\t\t \"flags:\\t0%o\\n\",\n\t\t\t\t\t (long long) file->f_pos,\n\t\t\t\t\t file->f_flags);\n\t\t\tspin_unlock(&files->file_lock);\n\t\t\tput_files_struct(files);\n\t\t\treturn 0;\n\t\t}\n\t\tspin_unlock(&files->file_lock);\n\t\tput_files_struct(files);\n\t}\n\treturn -ENOENT;\n}\n\nstatic int proc_fd_link(struct inode *inode, struct path *path)\n{\n\treturn proc_fd_info(inode, path, NULL);\n}\n\nstatic int tid_fd_revalidate(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode;\n\tstruct task_struct *task;\n\tint fd;\n\tstruct files_struct *files;\n\tconst struct cred *cred;\n\n\tif (nd && nd->flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\tfd = proc_fd(inode);\n\n\tif (task) {\n\t\tfiles = get_files_struct(task);\n\t\tif (files) {\n\t\t\trcu_read_lock();\n\t\t\tif (fcheck_files(files, fd)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tput_files_struct(files);\n\t\t\t\tif (task_dumpable(task)) {\n\t\t\t\t\trcu_read_lock();\n\t\t\t\t\tcred = __task_cred(task);\n\t\t\t\t\tinode->i_uid = cred->euid;\n\t\t\t\t\tinode->i_gid = cred->egid;\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_uid = 0;\n\t\t\t\t\tinode->i_gid = 0;\n\t\t\t\t}\n\t\t\t\tinode->i_mode &= ~(S_ISUID | S_ISGID);\n\t\t\t\tsecurity_task_to_inode(task, inode);\n\t\t\t\tput_task_struct(task);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\tput_files_struct(files);\n\t\t}\n\t\tput_task_struct(task);\n\t}\n\td_drop(dentry);\n\treturn 0;\n}\n\nstatic const struct dentry_operations tid_fd_dentry_operations =\n{\n\t.d_revalidate\t= tid_fd_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\nstatic struct dentry *proc_fd_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tunsigned fd = *(const unsigned *)ptr;\n\tstruct file *file;\n\tstruct files_struct *files;\n \tstruct inode *inode;\n \tstruct proc_inode *ei;\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\tei = PROC_I(inode);\n\tei->fd = fd;\n\tfiles = get_files_struct(task);\n\tif (!files)\n\t\tgoto out_iput;\n\tinode->i_mode = S_IFLNK;\n\n\t/*\n\t * We are not taking a ref to the file structure, so we must\n\t * hold ->file_lock.\n\t */\n\tspin_lock(&files->file_lock);\n\tfile = fcheck_files(files, fd);\n\tif (!file)\n\t\tgoto out_unlock;\n\tif (file->f_mode & FMODE_READ)\n\t\tinode->i_mode |= S_IRUSR | S_IXUSR;\n\tif (file->f_mode & FMODE_WRITE)\n\t\tinode->i_mode |= S_IWUSR | S_IXUSR;\n\tspin_unlock(&files->file_lock);\n\tput_files_struct(files);\n\n\tinode->i_op = &proc_pid_link_inode_operations;\n\tinode->i_size = 64;\n\tei->op.proc_get_link = proc_fd_link;\n\td_set_d_op(dentry, &tid_fd_dentry_operations);\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (tid_fd_revalidate(dentry, NULL))\n\t\terror = NULL;\n\n out:\n\treturn error;\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\tput_files_struct(files);\nout_iput:\n\tiput(inode);\n\tgoto out;\n}\n\nstatic struct dentry *proc_lookupfd_common(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   instantiate_t instantiate)\n{\n\tstruct task_struct *task = get_proc_task(dir);\n\tunsigned fd = name_to_int(dentry);\n\tstruct dentry *result = ERR_PTR(-ENOENT);\n\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (fd == ~0U)\n\t\tgoto out;\n\n\tresult = instantiate(dir, dentry, task, &fd);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn result;\n}\n\nstatic int proc_readfd_common(struct file * filp, void * dirent,\n\t\t\t      filldir_t filldir, instantiate_t instantiate)\n{\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *p = get_proc_task(inode);\n\tunsigned int fd, ino;\n\tint retval;\n\tstruct files_struct * files;\n\n\tretval = -ENOENT;\n\tif (!p)\n\t\tgoto out_no_task;\n\tretval = 0;\n\n\tfd = filp->f_pos;\n\tswitch (fd) {\n\t\tcase 0:\n\t\t\tif (filldir(dirent, \".\", 1, 0, inode->i_ino, DT_DIR) < 0)\n\t\t\t\tgoto out;\n\t\t\tfilp->f_pos++;\n\t\tcase 1:\n\t\t\tino = parent_ino(dentry);\n\t\t\tif (filldir(dirent, \"..\", 2, 1, ino, DT_DIR) < 0)\n\t\t\t\tgoto out;\n\t\t\tfilp->f_pos++;\n\t\tdefault:\n\t\t\tfiles = get_files_struct(p);\n\t\t\tif (!files)\n\t\t\t\tgoto out;\n\t\t\trcu_read_lock();\n\t\t\tfor (fd = filp->f_pos-2;\n\t\t\t     fd < files_fdtable(files)->max_fds;\n\t\t\t     fd++, filp->f_pos++) {\n\t\t\t\tchar name[PROC_NUMBUF];\n\t\t\t\tint len;\n\n\t\t\t\tif (!fcheck_files(files, fd))\n\t\t\t\t\tcontinue;\n\t\t\t\trcu_read_unlock();\n\n\t\t\t\tlen = snprintf(name, sizeof(name), \"%d\", fd);\n\t\t\t\tif (proc_fill_cache(filp, dirent, filldir,\n\t\t\t\t\t\t    name, len, instantiate,\n\t\t\t\t\t\t    p, &fd) < 0) {\n\t\t\t\t\trcu_read_lock();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trcu_read_lock();\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\tput_files_struct(files);\n\t}\nout:\n\tput_task_struct(p);\nout_no_task:\n\treturn retval;\n}\n\nstatic struct dentry *proc_lookupfd(struct inode *dir, struct dentry *dentry,\n\t\t\t\t    struct nameidata *nd)\n{\n\treturn proc_lookupfd_common(dir, dentry, proc_fd_instantiate);\n}\n\nstatic int proc_readfd(struct file *filp, void *dirent, filldir_t filldir)\n{\n\treturn proc_readfd_common(filp, dirent, filldir, proc_fd_instantiate);\n}\n\nstatic ssize_t proc_fdinfo_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t len, loff_t *ppos)\n{\n\tchar tmp[PROC_FDINFO_MAX];\n\tint err = proc_fd_info(file->f_path.dentry->d_inode, NULL, tmp);\n\tif (!err)\n\t\terr = simple_read_from_buffer(buf, len, ppos, tmp, strlen(tmp));\n\treturn err;\n}\n\nstatic const struct file_operations proc_fdinfo_file_operations = {\n\t.open           = nonseekable_open,\n\t.read\t\t= proc_fdinfo_read,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic const struct file_operations proc_fd_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_readfd,\n\t.llseek\t\t= default_llseek,\n};\n\n/*\n * /proc/pid/fd needs a special permission handler so that a process can still\n * access /proc/self/fd after it has executed a setuid().\n */\nstatic int proc_fd_permission(struct inode *inode, int mask, unsigned int flags)\n{\n\tint rv = generic_permission(inode, mask, flags, NULL);\n\tif (rv == 0)\n\t\treturn 0;\n\tif (task_pid(current) == proc_pid(inode))\n\t\trv = 0;\n\treturn rv;\n}\n\n/*\n * proc directories can do almost nothing..\n */\nstatic const struct inode_operations proc_fd_inode_operations = {\n\t.lookup\t\t= proc_lookupfd,\n\t.permission\t= proc_fd_permission,\n\t.setattr\t= proc_setattr,\n};\n\nstatic struct dentry *proc_fdinfo_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tunsigned fd = *(unsigned *)ptr;\n \tstruct inode *inode;\n \tstruct proc_inode *ei;\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\tei = PROC_I(inode);\n\tei->fd = fd;\n\tinode->i_mode = S_IFREG | S_IRUSR;\n\tinode->i_fop = &proc_fdinfo_file_operations;\n\td_set_d_op(dentry, &tid_fd_dentry_operations);\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (tid_fd_revalidate(dentry, NULL))\n\t\terror = NULL;\n\n out:\n\treturn error;\n}\n\nstatic struct dentry *proc_lookupfdinfo(struct inode *dir,\n\t\t\t\t\tstruct dentry *dentry,\n\t\t\t\t\tstruct nameidata *nd)\n{\n\treturn proc_lookupfd_common(dir, dentry, proc_fdinfo_instantiate);\n}\n\nstatic int proc_readfdinfo(struct file *filp, void *dirent, filldir_t filldir)\n{\n\treturn proc_readfd_common(filp, dirent, filldir,\n\t\t\t\t  proc_fdinfo_instantiate);\n}\n\nstatic const struct file_operations proc_fdinfo_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_readfdinfo,\n\t.llseek\t\t= default_llseek,\n};\n\n/*\n * proc directories can do almost nothing..\n */\nstatic const struct inode_operations proc_fdinfo_inode_operations = {\n\t.lookup\t\t= proc_lookupfdinfo,\n\t.setattr\t= proc_setattr,\n};\n\n\nstatic struct dentry *proc_pident_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tconst struct pid_entry *p = ptr;\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tei = PROC_I(inode);\n\tinode->i_mode = p->mode;\n\tif (S_ISDIR(inode->i_mode))\n\t\tinode->i_nlink = 2;\t/* Use getattr to fix if necessary */\n\tif (p->iop)\n\t\tinode->i_op = p->iop;\n\tif (p->fop)\n\t\tinode->i_fop = p->fop;\n\tei->op = p->op;\n\td_set_d_op(dentry, &pid_dentry_operations);\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, NULL))\n\t\terror = NULL;\nout:\n\treturn error;\n}\n\nstatic struct dentry *proc_pident_lookup(struct inode *dir, \n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const struct pid_entry *ents,\n\t\t\t\t\t unsigned int nents)\n{\n\tstruct dentry *error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\n\terror = ERR_PTR(-ENOENT);\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\t/*\n\t * Yes, it does not scale. And it should not. Don't add\n\t * new entries into /proc/<tgid>/ without very good reasons.\n\t */\n\tlast = &ents[nents - 1];\n\tfor (p = ents; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\n\terror = proc_pident_instantiate(dir, dentry, task, p);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn error;\n}\n\nstatic int proc_pident_fill_cache(struct file *filp, void *dirent,\n\tfilldir_t filldir, struct task_struct *task, const struct pid_entry *p)\n{\n\treturn proc_fill_cache(filp, dirent, filldir, p->name, p->len,\n\t\t\t\tproc_pident_instantiate, task, p);\n}\n\nstatic int proc_pident_readdir(struct file *filp,\n\t\tvoid *dirent, filldir_t filldir,\n\t\tconst struct pid_entry *ents, unsigned int nents)\n{\n\tint i;\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task = get_proc_task(inode);\n\tconst struct pid_entry *p, *last;\n\tino_t ino;\n\tint ret;\n\n\tret = -ENOENT;\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tret = 0;\n\ti = filp->f_pos;\n\tswitch (i) {\n\tcase 0:\n\t\tino = inode->i_ino;\n\t\tif (filldir(dirent, \".\", 1, i, ino, DT_DIR) < 0)\n\t\t\tgoto out;\n\t\ti++;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\tcase 1:\n\t\tino = parent_ino(dentry);\n\t\tif (filldir(dirent, \"..\", 2, i, ino, DT_DIR) < 0)\n\t\t\tgoto out;\n\t\ti++;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\tdefault:\n\t\ti -= 2;\n\t\tif (i >= nents) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tp = ents + i;\n\t\tlast = &ents[nents - 1];\n\t\twhile (p <= last) {\n\t\t\tif (proc_pident_fill_cache(filp, dirent, filldir, task, p) < 0)\n\t\t\t\tgoto out;\n\t\t\tfilp->f_pos++;\n\t\t\tp++;\n\t\t}\n\t}\n\n\tret = 1;\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ret;\n}\n\n#ifdef CONFIG_SECURITY\nstatic ssize_t proc_pid_attr_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tchar *p = NULL;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tlength = security_getprocattr(task,\n\t\t\t\t      (char*)file->f_path.dentry->d_name.name,\n\t\t\t\t      &p);\n\tput_task_struct(task);\n\tif (length > 0)\n\t\tlength = simple_read_from_buffer(buf, count, ppos, p, length);\n\tkfree(p);\n\treturn length;\n}\n\nstatic ssize_t proc_pid_attr_write(struct file * file, const char __user * buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tchar *page;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tlength = -ESRCH;\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (count > PAGE_SIZE)\n\t\tcount = PAGE_SIZE;\n\n\t/* No partial writes. */\n\tlength = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tpage = (char*)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\n\tlength = -EFAULT;\n\tif (copy_from_user(page, buf, count))\n\t\tgoto out_free;\n\n\t/* Guard against adverse ptrace interaction */\n\tlength = mutex_lock_interruptible(&task->signal->cred_guard_mutex);\n\tif (length < 0)\n\t\tgoto out_free;\n\n\tlength = security_setprocattr(task,\n\t\t\t\t      (char*)file->f_path.dentry->d_name.name,\n\t\t\t\t      (void*)page, count);\n\tmutex_unlock(&task->signal->cred_guard_mutex);\nout_free:\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn length;\n}\n\nstatic const struct file_operations proc_pid_attr_operations = {\n\t.read\t\t= proc_pid_attr_read,\n\t.write\t\t= proc_pid_attr_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic const struct pid_entry attr_dir_stuff[] = {\n\tREG(\"current\",    S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"prev\",       S_IRUGO,\t   proc_pid_attr_operations),\n\tREG(\"exec\",       S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"fscreate\",   S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"keycreate\",  S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"sockcreate\", S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n};\n\nstatic int proc_attr_dir_readdir(struct file * filp,\n\t\t\t     void * dirent, filldir_t filldir)\n{\n\treturn proc_pident_readdir(filp,dirent,filldir,\n\t\t\t\t   attr_dir_stuff,ARRAY_SIZE(attr_dir_stuff));\n}\n\nstatic const struct file_operations proc_attr_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_attr_dir_readdir,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic struct dentry *proc_attr_dir_lookup(struct inode *dir,\n\t\t\t\tstruct dentry *dentry, struct nameidata *nd)\n{\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  attr_dir_stuff, ARRAY_SIZE(attr_dir_stuff));\n}\n\nstatic const struct inode_operations proc_attr_dir_inode_operations = {\n\t.lookup\t\t= proc_attr_dir_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n\n#endif\n\n#ifdef CONFIG_ELF_CORE\nstatic ssize_t proc_coredump_filter_read(struct file *file, char __user *buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_dentry->d_inode);\n\tstruct mm_struct *mm;\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint ret;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tret = 0;\n\tmm = get_task_mm(task);\n\tif (mm) {\n\t\tlen = snprintf(buffer, sizeof(buffer), \"%08lx\\n\",\n\t\t\t       ((mm->flags & MMF_DUMP_FILTER_MASK) >>\n\t\t\t\tMMF_DUMP_FILTER_SHIFT));\n\t\tmmput(mm);\n\t\tret = simple_read_from_buffer(buf, count, ppos, buffer, len);\n\t}\n\n\tput_task_struct(task);\n\n\treturn ret;\n}\n\nstatic ssize_t proc_coredump_filter_write(struct file *file,\n\t\t\t\t\t  const char __user *buf,\n\t\t\t\t\t  size_t count,\n\t\t\t\t\t  loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tchar buffer[PROC_NUMBUF], *end;\n\tunsigned int val;\n\tint ret;\n\tint i;\n\tunsigned long mask;\n\n\tret = -EFAULT;\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\tgoto out_no_task;\n\n\tret = -EINVAL;\n\tval = (unsigned int)simple_strtoul(buffer, &end, 0);\n\tif (*end == '\\n')\n\t\tend++;\n\tif (end - buffer == 0)\n\t\tgoto out_no_task;\n\n\tret = -ESRCH;\n\ttask = get_proc_task(file->f_dentry->d_inode);\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tret = end - buffer;\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_no_mm;\n\n\tfor (i = 0, mask = 1; i < MMF_DUMP_FILTER_BITS; i++, mask <<= 1) {\n\t\tif (val & mask)\n\t\t\tset_bit(i + MMF_DUMP_FILTER_SHIFT, &mm->flags);\n\t\telse\n\t\t\tclear_bit(i + MMF_DUMP_FILTER_SHIFT, &mm->flags);\n\t}\n\n\tmmput(mm);\n out_no_mm:\n\tput_task_struct(task);\n out_no_task:\n\treturn ret;\n}\n\nstatic const struct file_operations proc_coredump_filter_operations = {\n\t.read\t\t= proc_coredump_filter_read,\n\t.write\t\t= proc_coredump_filter_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n#endif\n\n/*\n * /proc/self:\n */\nstatic int proc_self_readlink(struct dentry *dentry, char __user *buffer,\n\t\t\t      int buflen)\n{\n\tstruct pid_namespace *ns = dentry->d_sb->s_fs_info;\n\tpid_t tgid = task_tgid_nr_ns(current, ns);\n\tchar tmp[PROC_NUMBUF];\n\tif (!tgid)\n\t\treturn -ENOENT;\n\tsprintf(tmp, \"%d\", tgid);\n\treturn vfs_readlink(dentry,buffer,buflen,tmp);\n}\n\nstatic void *proc_self_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct pid_namespace *ns = dentry->d_sb->s_fs_info;\n\tpid_t tgid = task_tgid_nr_ns(current, ns);\n\tchar *name = ERR_PTR(-ENOENT);\n\tif (tgid) {\n\t\tname = __getname();\n\t\tif (!name)\n\t\t\tname = ERR_PTR(-ENOMEM);\n\t\telse\n\t\t\tsprintf(name, \"%d\", tgid);\n\t}\n\tnd_set_link(nd, name);\n\treturn NULL;\n}\n\nstatic void proc_self_put_link(struct dentry *dentry, struct nameidata *nd,\n\t\t\t\tvoid *cookie)\n{\n\tchar *s = nd_get_link(nd);\n\tif (!IS_ERR(s))\n\t\t__putname(s);\n}\n\nstatic const struct inode_operations proc_self_inode_operations = {\n\t.readlink\t= proc_self_readlink,\n\t.follow_link\t= proc_self_follow_link,\n\t.put_link\t= proc_self_put_link,\n};\n\n/*\n * proc base\n *\n * These are the directory entries in the root directory of /proc\n * that properly belong to the /proc filesystem, as they describe\n * describe something that is process related.\n */\nstatic const struct pid_entry proc_base_stuff[] = {\n\tNOD(\"self\", S_IFLNK|S_IRWXUGO,\n\t\t&proc_self_inode_operations, NULL, {}),\n};\n\nstatic struct dentry *proc_base_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tconst struct pid_entry *p = ptr;\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\tstruct dentry *error;\n\n\t/* Allocate the inode */\n\terror = ERR_PTR(-ENOMEM);\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Initialize the inode */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\n\t/*\n\t * grab the reference to the task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_iput;\n\n\tinode->i_mode = p->mode;\n\tif (S_ISDIR(inode->i_mode))\n\t\tinode->i_nlink = 2;\n\tif (S_ISLNK(inode->i_mode))\n\t\tinode->i_size = 64;\n\tif (p->iop)\n\t\tinode->i_op = p->iop;\n\tif (p->fop)\n\t\tinode->i_fop = p->fop;\n\tei->op = p->op;\n\td_add(dentry, inode);\n\terror = NULL;\nout:\n\treturn error;\nout_iput:\n\tiput(inode);\n\tgoto out;\n}\n\nstatic struct dentry *proc_base_lookup(struct inode *dir, struct dentry *dentry)\n{\n\tstruct dentry *error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\n\terror = ERR_PTR(-ENOENT);\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\t/* Lookup the directory entry */\n\tlast = &proc_base_stuff[ARRAY_SIZE(proc_base_stuff) - 1];\n\tfor (p = proc_base_stuff; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\n\terror = proc_base_instantiate(dir, dentry, task, p);\n\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn error;\n}\n\nstatic int proc_base_fill_cache(struct file *filp, void *dirent,\n\tfilldir_t filldir, struct task_struct *task, const struct pid_entry *p)\n{\n\treturn proc_fill_cache(filp, dirent, filldir, p->name, p->len,\n\t\t\t\tproc_base_instantiate, task, p);\n}\n\n#ifdef CONFIG_TASK_IO_ACCOUNTING\nstatic int do_io_accounting(struct task_struct *task, char *buffer, int whole)\n{\n\tstruct task_io_accounting acct = task->ioac;\n\tunsigned long flags;\n\n\tif (whole && lock_task_sighand(task, &flags)) {\n\t\tstruct task_struct *t = task;\n\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\treturn sprintf(buffer,\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n\t\t\t(unsigned long long)acct.rchar,\n\t\t\t(unsigned long long)acct.wchar,\n\t\t\t(unsigned long long)acct.syscr,\n\t\t\t(unsigned long long)acct.syscw,\n\t\t\t(unsigned long long)acct.read_bytes,\n\t\t\t(unsigned long long)acct.write_bytes,\n\t\t\t(unsigned long long)acct.cancelled_write_bytes);\n}\n\nstatic int proc_tid_io_accounting(struct task_struct *task, char *buffer)\n{\n\treturn do_io_accounting(task, buffer, 0);\n}\n\nstatic int proc_tgid_io_accounting(struct task_struct *task, char *buffer)\n{\n\treturn do_io_accounting(task, buffer, 1);\n}\n#endif /* CONFIG_TASK_IO_ACCOUNTING */\n\nstatic int proc_pid_personality(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\tstruct pid *pid, struct task_struct *task)\n{\n\tint err = lock_trace(task);\n\tif (!err) {\n\t\tseq_printf(m, \"%08x\\n\", task->personality);\n\t\tunlock_trace(task);\n\t}\n\treturn err;\n}\n\n/*\n * Thread groups\n */\nstatic const struct file_operations proc_task_operations;\nstatic const struct inode_operations proc_task_inode_operations;\n\nstatic const struct pid_entry tgid_base_stuff[] = {\n\tDIR(\"task\",       S_IRUGO|S_IXUGO, proc_task_inode_operations, proc_task_operations),\n\tDIR(\"fd\",         S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"fdinfo\",     S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t  S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",    S_IRUSR, proc_environ_operations),\n\tINF(\"auxv\",       S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",     S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUGO, proc_pid_personality),\n\tINF(\"limits\",\t  S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",      S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n#ifdef CONFIG_SCHED_AUTOGROUP\n\tREG(\"autogroup\",  S_IRUGO|S_IWUSR, proc_pid_sched_autogroup_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tINF(\"syscall\",    S_IRUGO, proc_pid_syscall),\n#endif\n\tINF(\"cmdline\",    S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",       S_IRUGO, proc_tgid_stat),\n\tONE(\"statm\",      S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",       S_IRUGO, proc_maps_operations),\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\",  S_IRUGO, proc_numa_maps_operations),\n#endif\n\tREG(\"mem\",        S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",        proc_cwd_link),\n\tLNK(\"root\",       proc_root_link),\n\tLNK(\"exe\",        proc_exe_link),\n\tREG(\"mounts\",     S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n\tREG(\"mountstats\", S_IRUSR, proc_mountstats_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",      S_IRUGO, proc_smaps_operations),\n\tREG(\"pagemap\",    S_IRUGO, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",       S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tINF(\"wchan\",      S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUGO, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tINF(\"schedstat\",  S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tREG(\"cpuset\",     S_IRUGO, proc_cpuset_operations),\n#endif\n#ifdef CONFIG_CGROUPS\n\tREG(\"cgroup\",  S_IRUGO, proc_cgroup_operations),\n#endif\n\tINF(\"oom_score\",  S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",    S_IRUGO|S_IWUSR, proc_oom_adjust_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",   S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_ELF_CORE\n\tREG(\"coredump_filter\", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tINF(\"io\",\tS_IRUGO, proc_tgid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tINF(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n};\n\nstatic int proc_tgid_base_readdir(struct file * filp,\n\t\t\t     void * dirent, filldir_t filldir)\n{\n\treturn proc_pident_readdir(filp,dirent,filldir,\n\t\t\t\t   tgid_base_stuff,ARRAY_SIZE(tgid_base_stuff));\n}\n\nstatic const struct file_operations proc_tgid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_tgid_base_readdir,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic struct dentry *proc_tgid_base_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd){\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  tgid_base_stuff, ARRAY_SIZE(tgid_base_stuff));\n}\n\nstatic const struct inode_operations proc_tgid_base_inode_operations = {\n\t.lookup\t\t= proc_tgid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n\nstatic void proc_flush_task_mnt(struct vfsmount *mnt, pid_t pid, pid_t tgid)\n{\n\tstruct dentry *dentry, *leader, *dir;\n\tchar buf[PROC_NUMBUF];\n\tstruct qstr name;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", pid);\n\tdentry = d_hash_and_lookup(mnt->mnt_root, &name);\n\tif (dentry) {\n\t\tshrink_dcache_parent(dentry);\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t}\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", tgid);\n\tleader = d_hash_and_lookup(mnt->mnt_root, &name);\n\tif (!leader)\n\t\tgoto out;\n\n\tname.name = \"task\";\n\tname.len = strlen(name.name);\n\tdir = d_hash_and_lookup(leader, &name);\n\tif (!dir)\n\t\tgoto out_put_leader;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", pid);\n\tdentry = d_hash_and_lookup(dir, &name);\n\tif (dentry) {\n\t\tshrink_dcache_parent(dentry);\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t}\n\n\tdput(dir);\nout_put_leader:\n\tdput(leader);\nout:\n\treturn;\n}\n\n/**\n * proc_flush_task -  Remove dcache entries for @task from the /proc dcache.\n * @task: task that should be flushed.\n *\n * When flushing dentries from proc, one needs to flush them from global\n * proc (proc_mnt) and from all the namespaces' procs this task was seen\n * in. This call is supposed to do all of this job.\n *\n * Looks in the dcache for\n * /proc/@pid\n * /proc/@tgid/task/@pid\n * if either directory is present flushes it and all of it'ts children\n * from the dcache.\n *\n * It is safe and reasonable to cache /proc entries for a task until\n * that task exits.  After that they just clog up the dcache with\n * useless entries, possibly causing useful dcache entries to be\n * flushed instead.  This routine is proved to flush those useless\n * dcache entries at process exit time.\n *\n * NOTE: This routine is just an optimization so it does not guarantee\n *       that no dcache entries will exist at process exit time it\n *       just makes it very unlikely that any will persist.\n */\n\nvoid proc_flush_task(struct task_struct *task)\n{\n\tint i;\n\tstruct pid *pid, *tgid;\n\tstruct upid *upid;\n\n\tpid = task_pid(task);\n\ttgid = task_tgid(task);\n\n\tfor (i = 0; i <= pid->level; i++) {\n\t\tupid = &pid->numbers[i];\n\t\tproc_flush_task_mnt(upid->ns->proc_mnt, upid->nr,\n\t\t\t\t\ttgid->numbers[i].nr);\n\t}\n\n\tupid = &pid->numbers[pid->level];\n\tif (upid->nr == 1)\n\t\tpid_ns_release_proc(upid->ns);\n}\n\nstatic struct dentry *proc_pid_instantiate(struct inode *dir,\n\t\t\t\t\t   struct dentry * dentry,\n\t\t\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tgid_base_inode_operations;\n\tinode->i_fop = &proc_tgid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tinode->i_nlink = 2 + pid_entry_count_dirs(tgid_base_stuff,\n\t\tARRAY_SIZE(tgid_base_stuff));\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, NULL))\n\t\terror = NULL;\nout:\n\treturn error;\n}\n\nstruct dentry *proc_pid_lookup(struct inode *dir, struct dentry * dentry, struct nameidata *nd)\n{\n\tstruct dentry *result;\n\tstruct task_struct *task;\n\tunsigned tgid;\n\tstruct pid_namespace *ns;\n\n\tresult = proc_base_lookup(dir, dentry);\n\tif (!IS_ERR(result) || PTR_ERR(result) != -ENOENT)\n\t\tgoto out;\n\n\ttgid = name_to_int(dentry);\n\tif (tgid == ~0U)\n\t\tgoto out;\n\n\tns = dentry->d_sb->s_fs_info;\n\trcu_read_lock();\n\ttask = find_task_by_pid_ns(tgid, ns);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\tif (!task)\n\t\tgoto out;\n\n\tresult = proc_pid_instantiate(dir, dentry, task, NULL);\n\tput_task_struct(task);\nout:\n\treturn result;\n}\n\n/*\n * Find the first task with tgid >= tgid\n *\n */\nstruct tgid_iter {\n\tunsigned int tgid;\n\tstruct task_struct *task;\n};\nstatic struct tgid_iter next_tgid(struct pid_namespace *ns, struct tgid_iter iter)\n{\n\tstruct pid *pid;\n\n\tif (iter.task)\n\t\tput_task_struct(iter.task);\n\trcu_read_lock();\nretry:\n\titer.task = NULL;\n\tpid = find_ge_pid(iter.tgid, ns);\n\tif (pid) {\n\t\titer.tgid = pid_nr_ns(pid, ns);\n\t\titer.task = pid_task(pid, PIDTYPE_PID);\n\t\t/* What we to know is if the pid we have find is the\n\t\t * pid of a thread_group_leader.  Testing for task\n\t\t * being a thread_group_leader is the obvious thing\n\t\t * todo but there is a window when it fails, due to\n\t\t * the pid transfer logic in de_thread.\n\t\t *\n\t\t * So we perform the straight forward test of seeing\n\t\t * if the pid we have found is the pid of a thread\n\t\t * group leader, and don't worry if the task we have\n\t\t * found doesn't happen to be a thread group leader.\n\t\t * As we don't care in the case of readdir.\n\t\t */\n\t\tif (!iter.task || !has_group_leader_pid(iter.task)) {\n\t\t\titer.tgid += 1;\n\t\t\tgoto retry;\n\t\t}\n\t\tget_task_struct(iter.task);\n\t}\n\trcu_read_unlock();\n\treturn iter;\n}\n\n#define TGID_OFFSET (FIRST_PROCESS_ENTRY + ARRAY_SIZE(proc_base_stuff))\n\nstatic int proc_pid_fill_cache(struct file *filp, void *dirent, filldir_t filldir,\n\tstruct tgid_iter iter)\n{\n\tchar name[PROC_NUMBUF];\n\tint len = snprintf(name, sizeof(name), \"%d\", iter.tgid);\n\treturn proc_fill_cache(filp, dirent, filldir, name, len,\n\t\t\t\tproc_pid_instantiate, iter.task, NULL);\n}\n\n/* for the /proc/ directory itself, after non-process stuff has been done */\nint proc_pid_readdir(struct file * filp, void * dirent, filldir_t filldir)\n{\n\tunsigned int nr;\n\tstruct task_struct *reaper;\n\tstruct tgid_iter iter;\n\tstruct pid_namespace *ns;\n\n\tif (filp->f_pos >= PID_MAX_LIMIT + TGID_OFFSET)\n\t\tgoto out_no_task;\n\tnr = filp->f_pos - FIRST_PROCESS_ENTRY;\n\n\treaper = get_proc_task(filp->f_path.dentry->d_inode);\n\tif (!reaper)\n\t\tgoto out_no_task;\n\n\tfor (; nr < ARRAY_SIZE(proc_base_stuff); filp->f_pos++, nr++) {\n\t\tconst struct pid_entry *p = &proc_base_stuff[nr];\n\t\tif (proc_base_fill_cache(filp, dirent, filldir, reaper, p) < 0)\n\t\t\tgoto out;\n\t}\n\n\tns = filp->f_dentry->d_sb->s_fs_info;\n\titer.task = NULL;\n\titer.tgid = filp->f_pos - TGID_OFFSET;\n\tfor (iter = next_tgid(ns, iter);\n\t     iter.task;\n\t     iter.tgid += 1, iter = next_tgid(ns, iter)) {\n\t\tfilp->f_pos = iter.tgid + TGID_OFFSET;\n\t\tif (proc_pid_fill_cache(filp, dirent, filldir, iter) < 0) {\n\t\t\tput_task_struct(iter.task);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfilp->f_pos = PID_MAX_LIMIT + TGID_OFFSET;\nout:\n\tput_task_struct(reaper);\nout_no_task:\n\treturn 0;\n}\n\n/*\n * Tasks\n */\nstatic const struct pid_entry tid_base_stuff[] = {\n\tDIR(\"fd\",        S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"fdinfo\",    S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n\tREG(\"environ\",   S_IRUSR, proc_environ_operations),\n\tINF(\"auxv\",      S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",    S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUGO, proc_pid_personality),\n\tINF(\"limits\",\t S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",     S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tINF(\"syscall\",   S_IRUGO, proc_pid_syscall),\n#endif\n\tINF(\"cmdline\",   S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",      S_IRUGO, proc_tid_stat),\n\tONE(\"statm\",     S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",      S_IRUGO, proc_maps_operations),\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\", S_IRUGO, proc_numa_maps_operations),\n#endif\n\tREG(\"mem\",       S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",       proc_cwd_link),\n\tLNK(\"root\",      proc_root_link),\n\tLNK(\"exe\",       proc_exe_link),\n\tREG(\"mounts\",    S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",     S_IRUGO, proc_smaps_operations),\n\tREG(\"pagemap\",    S_IRUGO, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",      S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tINF(\"wchan\",     S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUGO, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tINF(\"schedstat\", S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tREG(\"cpuset\",    S_IRUGO, proc_cpuset_operations),\n#endif\n#ifdef CONFIG_CGROUPS\n\tREG(\"cgroup\",  S_IRUGO, proc_cgroup_operations),\n#endif\n\tINF(\"oom_score\", S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",   S_IRUGO|S_IWUSR, proc_oom_adjust_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",  S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tINF(\"io\",\tS_IRUGO, proc_tid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tINF(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n};\n\nstatic int proc_tid_base_readdir(struct file * filp,\n\t\t\t     void * dirent, filldir_t filldir)\n{\n\treturn proc_pident_readdir(filp,dirent,filldir,\n\t\t\t\t   tid_base_stuff,ARRAY_SIZE(tid_base_stuff));\n}\n\nstatic struct dentry *proc_tid_base_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd){\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  tid_base_stuff, ARRAY_SIZE(tid_base_stuff));\n}\n\nstatic const struct file_operations proc_tid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_tid_base_readdir,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct inode_operations proc_tid_base_inode_operations = {\n\t.lookup\t\t= proc_tid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n\nstatic struct dentry *proc_task_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\tstruct inode *inode;\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\n\tif (!inode)\n\t\tgoto out;\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tid_base_inode_operations;\n\tinode->i_fop = &proc_tid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tinode->i_nlink = 2 + pid_entry_count_dirs(tid_base_stuff,\n\t\tARRAY_SIZE(tid_base_stuff));\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, NULL))\n\t\terror = NULL;\nout:\n\treturn error;\n}\n\nstatic struct dentry *proc_task_lookup(struct inode *dir, struct dentry * dentry, struct nameidata *nd)\n{\n\tstruct dentry *result = ERR_PTR(-ENOENT);\n\tstruct task_struct *task;\n\tstruct task_struct *leader = get_proc_task(dir);\n\tunsigned tid;\n\tstruct pid_namespace *ns;\n\n\tif (!leader)\n\t\tgoto out_no_task;\n\n\ttid = name_to_int(dentry);\n\tif (tid == ~0U)\n\t\tgoto out;\n\n\tns = dentry->d_sb->s_fs_info;\n\trcu_read_lock();\n\ttask = find_task_by_pid_ns(tid, ns);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\tif (!task)\n\t\tgoto out;\n\tif (!same_thread_group(leader, task))\n\t\tgoto out_drop_task;\n\n\tresult = proc_task_instantiate(dir, dentry, task, NULL);\nout_drop_task:\n\tput_task_struct(task);\nout:\n\tput_task_struct(leader);\nout_no_task:\n\treturn result;\n}\n\n/*\n * Find the first tid of a thread group to return to user space.\n *\n * Usually this is just the thread group leader, but if the users\n * buffer was too small or there was a seek into the middle of the\n * directory we have more work todo.\n *\n * In the case of a short read we start with find_task_by_pid.\n *\n * In the case of a seek we start with the leader and walk nr\n * threads past it.\n */\nstatic struct task_struct *first_tid(struct task_struct *leader,\n\t\tint tid, int nr, struct pid_namespace *ns)\n{\n\tstruct task_struct *pos;\n\n\trcu_read_lock();\n\t/* Attempt to start with the pid of a thread */\n\tif (tid && (nr > 0)) {\n\t\tpos = find_task_by_pid_ns(tid, ns);\n\t\tif (pos && (pos->group_leader == leader))\n\t\t\tgoto found;\n\t}\n\n\t/* If nr exceeds the number of threads there is nothing todo */\n\tpos = NULL;\n\tif (nr && nr >= get_nr_threads(leader))\n\t\tgoto out;\n\n\t/* If we haven't found our starting place yet start\n\t * with the leader and walk nr threads forward.\n\t */\n\tfor (pos = leader; nr > 0; --nr) {\n\t\tpos = next_thread(pos);\n\t\tif (pos == leader) {\n\t\t\tpos = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\nfound:\n\tget_task_struct(pos);\nout:\n\trcu_read_unlock();\n\treturn pos;\n}\n\n/*\n * Find the next thread in the thread list.\n * Return NULL if there is an error or no next thread.\n *\n * The reference to the input task_struct is released.\n */\nstatic struct task_struct *next_tid(struct task_struct *start)\n{\n\tstruct task_struct *pos = NULL;\n\trcu_read_lock();\n\tif (pid_alive(start)) {\n\t\tpos = next_thread(start);\n\t\tif (thread_group_leader(pos))\n\t\t\tpos = NULL;\n\t\telse\n\t\t\tget_task_struct(pos);\n\t}\n\trcu_read_unlock();\n\tput_task_struct(start);\n\treturn pos;\n}\n\nstatic int proc_task_fill_cache(struct file *filp, void *dirent, filldir_t filldir,\n\tstruct task_struct *task, int tid)\n{\n\tchar name[PROC_NUMBUF];\n\tint len = snprintf(name, sizeof(name), \"%d\", tid);\n\treturn proc_fill_cache(filp, dirent, filldir, name, len,\n\t\t\t\tproc_task_instantiate, task, NULL);\n}\n\n/* for the /proc/TGID/task/ directories */\nstatic int proc_task_readdir(struct file * filp, void * dirent, filldir_t filldir)\n{\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *leader = NULL;\n\tstruct task_struct *task;\n\tint retval = -ENOENT;\n\tino_t ino;\n\tint tid;\n\tstruct pid_namespace *ns;\n\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\tgoto out_no_task;\n\trcu_read_lock();\n\tif (pid_alive(task)) {\n\t\tleader = task->group_leader;\n\t\tget_task_struct(leader);\n\t}\n\trcu_read_unlock();\n\tput_task_struct(task);\n\tif (!leader)\n\t\tgoto out_no_task;\n\tretval = 0;\n\n\tswitch ((unsigned long)filp->f_pos) {\n\tcase 0:\n\t\tino = inode->i_ino;\n\t\tif (filldir(dirent, \".\", 1, filp->f_pos, ino, DT_DIR) < 0)\n\t\t\tgoto out;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\tcase 1:\n\t\tino = parent_ino(dentry);\n\t\tif (filldir(dirent, \"..\", 2, filp->f_pos, ino, DT_DIR) < 0)\n\t\t\tgoto out;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\t}\n\n\t/* f_version caches the tgid value that the last readdir call couldn't\n\t * return. lseek aka telldir automagically resets f_version to 0.\n\t */\n\tns = filp->f_dentry->d_sb->s_fs_info;\n\ttid = (int)filp->f_version;\n\tfilp->f_version = 0;\n\tfor (task = first_tid(leader, tid, filp->f_pos - 2, ns);\n\t     task;\n\t     task = next_tid(task), filp->f_pos++) {\n\t\ttid = task_pid_nr_ns(task, ns);\n\t\tif (proc_task_fill_cache(filp, dirent, filldir, task, tid) < 0) {\n\t\t\t/* returning this tgid failed, save it as the first\n\t\t\t * pid for the next readir call */\n\t\t\tfilp->f_version = (u64)tid;\n\t\t\tput_task_struct(task);\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tput_task_struct(leader);\nout_no_task:\n\treturn retval;\n}\n\nstatic int proc_task_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *p = get_proc_task(inode);\n\tgeneric_fillattr(inode, stat);\n\n\tif (p) {\n\t\tstat->nlink += get_nr_threads(p);\n\t\tput_task_struct(p);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct inode_operations proc_task_inode_operations = {\n\t.lookup\t\t= proc_task_lookup,\n\t.getattr\t= proc_task_getattr,\n\t.setattr\t= proc_setattr,\n};\n\nstatic const struct file_operations proc_task_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_task_readdir,\n\t.llseek\t\t= default_llseek,\n};\n"], "fixing_code": ["/*\n *  linux/fs/proc/base.c\n *\n *  Copyright (C) 1991, 1992 Linus Torvalds\n *\n *  proc base directory handling functions\n *\n *  1999, Al Viro. Rewritten. Now it covers the whole per-process part.\n *  Instead of using magical inumbers to determine the kind of object\n *  we allocate and fill in-core inodes upon lookup. They don't even\n *  go into icache. We cache the reference to task_struct upon lookup too.\n *  Eventually it should become a filesystem in its own. We don't use the\n *  rest of procfs anymore.\n *\n *\n *  Changelog:\n *  17-Jan-2005\n *  Allan Bezerra\n *  Bruna Moreira <bruna.moreira@indt.org.br>\n *  Edjard Mota <edjard.mota@indt.org.br>\n *  Ilias Biris <ilias.biris@indt.org.br>\n *  Mauricio Lin <mauricio.lin@indt.org.br>\n *\n *  Embedded Linux Lab - 10LE Instituto Nokia de Tecnologia - INdT\n *\n *  A new process specific entry (smaps) included in /proc. It shows the\n *  size of rss for each memory area. The maps entry lacks information\n *  about physical memory size (rss) for each mapped file, i.e.,\n *  rss information for executables and library files.\n *  This additional information is useful for any tools that need to know\n *  about physical memory consumption for a process specific library.\n *\n *  Changelog:\n *  21-Feb-2005\n *  Embedded Linux Lab - 10LE Instituto Nokia de Tecnologia - INdT\n *  Pud inclusion in the page table walking.\n *\n *  ChangeLog:\n *  10-Mar-2005\n *  10LE Instituto Nokia de Tecnologia - INdT:\n *  A better way to walks through the page table as suggested by Hugh Dickins.\n *\n *  Simo Piiroinen <simo.piiroinen@nokia.com>:\n *  Smaps information related to shared, private, clean and dirty pages.\n *\n *  Paul Mundt <paul.mundt@nokia.com>:\n *  Overall revision about smaps.\n */\n\n#include <asm/uaccess.h>\n\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/namei.h>\n#include <linux/mnt_namespace.h>\n#include <linux/mm.h>\n#include <linux/swap.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/resource.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/tracehook.h>\n#include <linux/cgroup.h>\n#include <linux/cpuset.h>\n#include <linux/audit.h>\n#include <linux/poll.h>\n#include <linux/nsproxy.h>\n#include <linux/oom.h>\n#include <linux/elf.h>\n#include <linux/pid_namespace.h>\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#ifdef CONFIG_HARDWALL\n#include <asm/hardwall.h>\n#endif\n#include \"internal.h\"\n\n/* NOTE:\n *\tImplementing inode permission operations in /proc is almost\n *\tcertainly an error.  Permission checks need to happen during\n *\teach system call not at open time.  The reason is that most of\n *\twhat we wish to check for permissions in /proc varies at runtime.\n *\n *\tThe classic example of a problem is opening file descriptors\n *\tin /proc for a task before it execs a suid executable.\n */\n\nstruct pid_entry {\n\tchar *name;\n\tint len;\n\tmode_t mode;\n\tconst struct inode_operations *iop;\n\tconst struct file_operations *fop;\n\tunion proc_op op;\n};\n\n#define NOD(NAME, MODE, IOP, FOP, OP) {\t\t\t\\\n\t.name = (NAME),\t\t\t\t\t\\\n\t.len  = sizeof(NAME) - 1,\t\t\t\\\n\t.mode = MODE,\t\t\t\t\t\\\n\t.iop  = IOP,\t\t\t\t\t\\\n\t.fop  = FOP,\t\t\t\t\t\\\n\t.op   = OP,\t\t\t\t\t\\\n}\n\n#define DIR(NAME, MODE, iops, fops)\t\\\n\tNOD(NAME, (S_IFDIR|(MODE)), &iops, &fops, {} )\n#define LNK(NAME, get_link)\t\t\t\t\t\\\n\tNOD(NAME, (S_IFLNK|S_IRWXUGO),\t\t\t\t\\\n\t\t&proc_pid_link_inode_operations, NULL,\t\t\\\n\t\t{ .proc_get_link = get_link } )\n#define REG(NAME, MODE, fops)\t\t\t\t\\\n\tNOD(NAME, (S_IFREG|(MODE)), NULL, &fops, {})\n#define INF(NAME, MODE, read)\t\t\t\t\\\n\tNOD(NAME, (S_IFREG|(MODE)), \t\t\t\\\n\t\tNULL, &proc_info_file_operations,\t\\\n\t\t{ .proc_read = read } )\n#define ONE(NAME, MODE, show)\t\t\t\t\\\n\tNOD(NAME, (S_IFREG|(MODE)), \t\t\t\\\n\t\tNULL, &proc_single_file_operations,\t\\\n\t\t{ .proc_show = show } )\n\n/*\n * Count the number of hardlinks for the pid_entry table, excluding the .\n * and .. links.\n */\nstatic unsigned int pid_entry_count_dirs(const struct pid_entry *entries,\n\tunsigned int n)\n{\n\tunsigned int i;\n\tunsigned int count;\n\n\tcount = 0;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (S_ISDIR(entries[i].mode))\n\t\t\t++count;\n\t}\n\n\treturn count;\n}\n\nstatic int get_task_root(struct task_struct *task, struct path *root)\n{\n\tint result = -ENOENT;\n\n\ttask_lock(task);\n\tif (task->fs) {\n\t\tget_fs_root(task->fs, root);\n\t\tresult = 0;\n\t}\n\ttask_unlock(task);\n\treturn result;\n}\n\nstatic int proc_cwd_link(struct inode *inode, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tint result = -ENOENT;\n\n\tif (task) {\n\t\ttask_lock(task);\n\t\tif (task->fs) {\n\t\t\tget_fs_pwd(task->fs, path);\n\t\t\tresult = 0;\n\t\t}\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}\n\nstatic int proc_root_link(struct inode *inode, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tint result = -ENOENT;\n\n\tif (task) {\n\t\tresult = get_task_root(task, path);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}\n\nstatic struct mm_struct *__check_mem_permission(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * A task can always look at itself, in case it chooses\n\t * to use system calls instead of load instructions.\n\t */\n\tif (task == current)\n\t\treturn mm;\n\n\t/*\n\t * If current is actively ptrace'ing, and would also be\n\t * permitted to freshly attach with ptrace now, permit it.\n\t */\n\tif (task_is_stopped_or_traced(task)) {\n\t\tint match;\n\t\trcu_read_lock();\n\t\tmatch = (tracehook_tracer_task(task) == current);\n\t\trcu_read_unlock();\n\t\tif (match && ptrace_may_access(task, PTRACE_MODE_ATTACH))\n\t\t\treturn mm;\n\t}\n\n\t/*\n\t * No one else is allowed.\n\t */\n\tmmput(mm);\n\treturn ERR_PTR(-EPERM);\n}\n\n/*\n * If current may access user memory in @task return a reference to the\n * corresponding mm, otherwise ERR_PTR.\n */\nstatic struct mm_struct *check_mem_permission(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\tint err;\n\n\t/*\n\t * Avoid racing if task exec's as we might get a new mm but validate\n\t * against old credentials.\n\t */\n\terr = mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tmm = __check_mem_permission(task);\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n\n\treturn mm;\n}\n\nstruct mm_struct *mm_for_maps(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\tint err;\n\n\terr =  mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tmm = get_task_mm(task);\n\tif (mm && mm != current->mm &&\n\t\t\t!ptrace_may_access(task, PTRACE_MODE_READ)) {\n\t\tmmput(mm);\n\t\tmm = ERR_PTR(-EACCES);\n\t}\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n\n\treturn mm;\n}\n\nstatic int proc_pid_cmdline(struct task_struct *task, char * buffer)\n{\n\tint res = 0;\n\tunsigned int len;\n\tstruct mm_struct *mm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out;\n\tif (!mm->arg_end)\n\t\tgoto out_mm;\t/* Shh! No looking before we're done */\n\n \tlen = mm->arg_end - mm->arg_start;\n \n\tif (len > PAGE_SIZE)\n\t\tlen = PAGE_SIZE;\n \n\tres = access_process_vm(task, mm->arg_start, buffer, len, 0);\n\n\t// If the nul at the end of args has been overwritten, then\n\t// assume application is using setproctitle(3).\n\tif (res > 0 && buffer[res-1] != '\\0' && len < PAGE_SIZE) {\n\t\tlen = strnlen(buffer, res);\n\t\tif (len < res) {\n\t\t    res = len;\n\t\t} else {\n\t\t\tlen = mm->env_end - mm->env_start;\n\t\t\tif (len > PAGE_SIZE - res)\n\t\t\t\tlen = PAGE_SIZE - res;\n\t\t\tres += access_process_vm(task, mm->env_start, buffer+res, len, 0);\n\t\t\tres = strnlen(buffer, res);\n\t\t}\n\t}\nout_mm:\n\tmmput(mm);\nout:\n\treturn res;\n}\n\nstatic int proc_pid_auxv(struct task_struct *task, char *buffer)\n{\n\tstruct mm_struct *mm = mm_for_maps(task);\n\tint res = PTR_ERR(mm);\n\tif (mm && !IS_ERR(mm)) {\n\t\tunsigned int nwords = 0;\n\t\tdo {\n\t\t\tnwords += 2;\n\t\t} while (mm->saved_auxv[nwords - 2] != 0); /* AT_NULL */\n\t\tres = nwords * sizeof(mm->saved_auxv[0]);\n\t\tif (res > PAGE_SIZE)\n\t\t\tres = PAGE_SIZE;\n\t\tmemcpy(buffer, mm->saved_auxv, res);\n\t\tmmput(mm);\n\t}\n\treturn res;\n}\n\n\n#ifdef CONFIG_KALLSYMS\n/*\n * Provides a wchan file via kallsyms in a proper one-value-per-file format.\n * Returns the resolved symbol.  If that fails, simply return the address.\n */\nstatic int proc_pid_wchan(struct task_struct *task, char *buffer)\n{\n\tunsigned long wchan;\n\tchar symname[KSYM_NAME_LEN];\n\n\twchan = get_wchan(task);\n\n\tif (lookup_symbol_name(wchan, symname) < 0)\n\t\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn sprintf(buffer, \"%lu\", wchan);\n\telse\n\t\treturn sprintf(buffer, \"%s\", symname);\n}\n#endif /* CONFIG_KALLSYMS */\n\nstatic int lock_trace(struct task_struct *task)\n{\n\tint err = mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (err)\n\t\treturn err;\n\tif (!ptrace_may_access(task, PTRACE_MODE_ATTACH)) {\n\t\tmutex_unlock(&task->signal->cred_guard_mutex);\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}\n\nstatic void unlock_trace(struct task_struct *task)\n{\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n}\n\n#ifdef CONFIG_STACKTRACE\n\n#define MAX_STACK_TRACE_DEPTH\t64\n\nstatic int proc_pid_stack(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\tstruct stack_trace trace;\n\tunsigned long *entries;\n\tint err;\n\tint i;\n\n\tentries = kmalloc(MAX_STACK_TRACE_DEPTH * sizeof(*entries), GFP_KERNEL);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\ttrace.nr_entries\t= 0;\n\ttrace.max_entries\t= MAX_STACK_TRACE_DEPTH;\n\ttrace.entries\t\t= entries;\n\ttrace.skip\t\t= 0;\n\n\terr = lock_trace(task);\n\tif (!err) {\n\t\tsave_stack_trace_tsk(task, &trace);\n\n\t\tfor (i = 0; i < trace.nr_entries; i++) {\n\t\t\tseq_printf(m, \"[<%pK>] %pS\\n\",\n\t\t\t\t   (void *)entries[i], (void *)entries[i]);\n\t\t}\n\t\tunlock_trace(task);\n\t}\n\tkfree(entries);\n\n\treturn err;\n}\n#endif\n\n#ifdef CONFIG_SCHEDSTATS\n/*\n * Provides /proc/PID/schedstat\n */\nstatic int proc_pid_schedstat(struct task_struct *task, char *buffer)\n{\n\treturn sprintf(buffer, \"%llu %llu %lu\\n\",\n\t\t\t(unsigned long long)task->se.sum_exec_runtime,\n\t\t\t(unsigned long long)task->sched_info.run_delay,\n\t\t\ttask->sched_info.pcount);\n}\n#endif\n\n#ifdef CONFIG_LATENCYTOP\nstatic int lstats_show_proc(struct seq_file *m, void *v)\n{\n\tint i;\n\tstruct inode *inode = m->private;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tseq_puts(m, \"Latency Top version : v0.1\\n\");\n\tfor (i = 0; i < 32; i++) {\n\t\tstruct latency_record *lr = &task->latency_record[i];\n\t\tif (lr->backtrace[0]) {\n\t\t\tint q;\n\t\t\tseq_printf(m, \"%i %li %li\",\n\t\t\t\t   lr->count, lr->time, lr->max);\n\t\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\t\tunsigned long bt = lr->backtrace[q];\n\t\t\t\tif (!bt)\n\t\t\t\t\tbreak;\n\t\t\t\tif (bt == ULONG_MAX)\n\t\t\t\t\tbreak;\n\t\t\t\tseq_printf(m, \" %ps\", (void *)bt);\n\t\t\t}\n\t\t\tseq_putc(m, '\\n');\n\t\t}\n\n\t}\n\tput_task_struct(task);\n\treturn 0;\n}\n\nstatic int lstats_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, lstats_show_proc, inode);\n}\n\nstatic ssize_t lstats_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *offs)\n{\n\tstruct task_struct *task = get_proc_task(file->f_dentry->d_inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tclear_all_latency_tracing(task);\n\tput_task_struct(task);\n\n\treturn count;\n}\n\nstatic const struct file_operations proc_lstats_operations = {\n\t.open\t\t= lstats_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= lstats_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n#endif\n\nstatic int proc_oom_score(struct task_struct *task, char *buffer)\n{\n\tunsigned long points = 0;\n\n\tread_lock(&tasklist_lock);\n\tif (pid_alive(task))\n\t\tpoints = oom_badness(task, NULL, NULL,\n\t\t\t\t\ttotalram_pages + total_swap_pages);\n\tread_unlock(&tasklist_lock);\n\treturn sprintf(buffer, \"%lu\\n\", points);\n}\n\nstruct limit_names {\n\tchar *name;\n\tchar *unit;\n};\n\nstatic const struct limit_names lnames[RLIM_NLIMITS] = {\n\t[RLIMIT_CPU] = {\"Max cpu time\", \"seconds\"},\n\t[RLIMIT_FSIZE] = {\"Max file size\", \"bytes\"},\n\t[RLIMIT_DATA] = {\"Max data size\", \"bytes\"},\n\t[RLIMIT_STACK] = {\"Max stack size\", \"bytes\"},\n\t[RLIMIT_CORE] = {\"Max core file size\", \"bytes\"},\n\t[RLIMIT_RSS] = {\"Max resident set\", \"bytes\"},\n\t[RLIMIT_NPROC] = {\"Max processes\", \"processes\"},\n\t[RLIMIT_NOFILE] = {\"Max open files\", \"files\"},\n\t[RLIMIT_MEMLOCK] = {\"Max locked memory\", \"bytes\"},\n\t[RLIMIT_AS] = {\"Max address space\", \"bytes\"},\n\t[RLIMIT_LOCKS] = {\"Max file locks\", \"locks\"},\n\t[RLIMIT_SIGPENDING] = {\"Max pending signals\", \"signals\"},\n\t[RLIMIT_MSGQUEUE] = {\"Max msgqueue size\", \"bytes\"},\n\t[RLIMIT_NICE] = {\"Max nice priority\", NULL},\n\t[RLIMIT_RTPRIO] = {\"Max realtime priority\", NULL},\n\t[RLIMIT_RTTIME] = {\"Max realtime timeout\", \"us\"},\n};\n\n/* Display limits for a process */\nstatic int proc_pid_limits(struct task_struct *task, char *buffer)\n{\n\tunsigned int i;\n\tint count = 0;\n\tunsigned long flags;\n\tchar *bufptr = buffer;\n\n\tstruct rlimit rlim[RLIM_NLIMITS];\n\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn 0;\n\tmemcpy(rlim, task->signal->rlim, sizeof(struct rlimit) * RLIM_NLIMITS);\n\tunlock_task_sighand(task, &flags);\n\n\t/*\n\t * print the file header\n\t */\n\tcount += sprintf(&bufptr[count], \"%-25s %-20s %-20s %-10s\\n\",\n\t\t\t\"Limit\", \"Soft Limit\", \"Hard Limit\", \"Units\");\n\n\tfor (i = 0; i < RLIM_NLIMITS; i++) {\n\t\tif (rlim[i].rlim_cur == RLIM_INFINITY)\n\t\t\tcount += sprintf(&bufptr[count], \"%-25s %-20s \",\n\t\t\t\t\t lnames[i].name, \"unlimited\");\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"%-25s %-20lu \",\n\t\t\t\t\t lnames[i].name, rlim[i].rlim_cur);\n\n\t\tif (rlim[i].rlim_max == RLIM_INFINITY)\n\t\t\tcount += sprintf(&bufptr[count], \"%-20s \", \"unlimited\");\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"%-20lu \",\n\t\t\t\t\t rlim[i].rlim_max);\n\n\t\tif (lnames[i].unit)\n\t\t\tcount += sprintf(&bufptr[count], \"%-10s\\n\",\n\t\t\t\t\t lnames[i].unit);\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"\\n\");\n\t}\n\n\treturn count;\n}\n\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\nstatic int proc_pid_syscall(struct task_struct *task, char *buffer)\n{\n\tlong nr;\n\tunsigned long args[6], sp, pc;\n\tint res = lock_trace(task);\n\tif (res)\n\t\treturn res;\n\n\tif (task_current_syscall(task, &nr, args, 6, &sp, &pc))\n\t\tres = sprintf(buffer, \"running\\n\");\n\telse if (nr < 0)\n\t\tres = sprintf(buffer, \"%ld 0x%lx 0x%lx\\n\", nr, sp, pc);\n\telse\n\t\tres = sprintf(buffer,\n\t\t       \"%ld 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx\\n\",\n\t\t       nr,\n\t\t       args[0], args[1], args[2], args[3], args[4], args[5],\n\t\t       sp, pc);\n\tunlock_trace(task);\n\treturn res;\n}\n#endif /* CONFIG_HAVE_ARCH_TRACEHOOK */\n\n/************************************************************************/\n/*                       Here the fs part begins                        */\n/************************************************************************/\n\n/* permission checks */\nstatic int proc_fd_access_allowed(struct inode *inode)\n{\n\tstruct task_struct *task;\n\tint allowed = 0;\n\t/* Allow access to a task's file descriptors if it is us or we\n\t * may use ptrace attach to the process and find out that\n\t * information.\n\t */\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\tallowed = ptrace_may_access(task, PTRACE_MODE_READ);\n\t\tput_task_struct(task);\n\t}\n\treturn allowed;\n}\n\nint proc_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint error;\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (attr->ia_valid & ATTR_MODE)\n\t\treturn -EPERM;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = vmtruncate(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}\n\nstatic const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};\n\nstatic int mounts_open_common(struct inode *inode, struct file *file,\n\t\t\t      const struct seq_operations *op)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct nsproxy *nsp;\n\tstruct mnt_namespace *ns = NULL;\n\tstruct path root;\n\tstruct proc_mounts *p;\n\tint ret = -EINVAL;\n\n\tif (task) {\n\t\trcu_read_lock();\n\t\tnsp = task_nsproxy(task);\n\t\tif (nsp) {\n\t\t\tns = nsp->mnt_ns;\n\t\t\tif (ns)\n\t\t\t\tget_mnt_ns(ns);\n\t\t}\n\t\trcu_read_unlock();\n\t\tif (ns && get_task_root(task, &root) == 0)\n\t\t\tret = 0;\n\t\tput_task_struct(task);\n\t}\n\n\tif (!ns)\n\t\tgoto err;\n\tif (ret)\n\t\tgoto err_put_ns;\n\n\tret = -ENOMEM;\n\tp = kmalloc(sizeof(struct proc_mounts), GFP_KERNEL);\n\tif (!p)\n\t\tgoto err_put_path;\n\n\tfile->private_data = &p->m;\n\tret = seq_open(file, op);\n\tif (ret)\n\t\tgoto err_free;\n\n\tp->m.private = p;\n\tp->ns = ns;\n\tp->root = root;\n\tp->event = ns->event;\n\n\treturn 0;\n\n err_free:\n\tkfree(p);\n err_put_path:\n\tpath_put(&root);\n err_put_ns:\n\tput_mnt_ns(ns);\n err:\n\treturn ret;\n}\n\nstatic int mounts_release(struct inode *inode, struct file *file)\n{\n\tstruct proc_mounts *p = file->private_data;\n\tpath_put(&p->root);\n\tput_mnt_ns(p->ns);\n\treturn seq_release(inode, file);\n}\n\nstatic unsigned mounts_poll(struct file *file, poll_table *wait)\n{\n\tstruct proc_mounts *p = file->private_data;\n\tunsigned res = POLLIN | POLLRDNORM;\n\n\tpoll_wait(file, &p->ns->poll, wait);\n\tif (mnt_had_events(p))\n\t\tres |= POLLERR | POLLPRI;\n\n\treturn res;\n}\n\nstatic int mounts_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, &mounts_op);\n}\n\nstatic const struct file_operations proc_mounts_operations = {\n\t.open\t\t= mounts_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= mounts_release,\n\t.poll\t\t= mounts_poll,\n};\n\nstatic int mountinfo_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, &mountinfo_op);\n}\n\nstatic const struct file_operations proc_mountinfo_operations = {\n\t.open\t\t= mountinfo_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= mounts_release,\n\t.poll\t\t= mounts_poll,\n};\n\nstatic int mountstats_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, &mountstats_op);\n}\n\nstatic const struct file_operations proc_mountstats_operations = {\n\t.open\t\t= mountstats_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= mounts_release,\n};\n\n#define PROC_BLOCK_SIZE\t(3*1024)\t\t/* 4K page size but our output routines use some slack for overruns */\n\nstatic ssize_t proc_info_read(struct file * file, char __user * buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tunsigned long page;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tlength = -ESRCH;\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tif (count > PROC_BLOCK_SIZE)\n\t\tcount = PROC_BLOCK_SIZE;\n\n\tlength = -ENOMEM;\n\tif (!(page = __get_free_page(GFP_TEMPORARY)))\n\t\tgoto out;\n\n\tlength = PROC_I(inode)->op.proc_read(task, (char*)page);\n\n\tif (length >= 0)\n\t\tlength = simple_read_from_buffer(buf, count, ppos, (char *)page, length);\n\tfree_page(page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn length;\n}\n\nstatic const struct file_operations proc_info_file_operations = {\n\t.read\t\t= proc_info_read,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int proc_single_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct pid_namespace *ns;\n\tstruct pid *pid;\n\tstruct task_struct *task;\n\tint ret;\n\n\tns = inode->i_sb->s_fs_info;\n\tpid = proc_pid(inode);\n\ttask = get_pid_task(pid, PIDTYPE_PID);\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tret = PROC_I(inode)->op.proc_show(m, ns, pid, task);\n\n\tput_task_struct(task);\n\treturn ret;\n}\n\nstatic int proc_single_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, proc_single_show, inode);\n}\n\nstatic const struct file_operations proc_single_file_operations = {\n\t.open\t\t= proc_single_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int mem_open(struct inode* inode, struct file* file)\n{\n\tfile->private_data = (void*)((long)current->self_exec_id);\n\t/* OK to pass negative loff_t, we can catch out-of-range */\n\tfile->f_mode |= FMODE_UNSIGNED_OFFSET;\n\treturn 0;\n}\n\nstatic ssize_t mem_read(struct file * file, char __user * buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = -ESRCH;\n\tstruct mm_struct *mm;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tret = -ENOMEM;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\n\tmm = check_mem_permission(task);\n\tret = PTR_ERR(mm);\n\tif (IS_ERR(mm))\n\t\tgoto out_free;\n\n\tret = -EIO;\n \n\tif (file->private_data != (void*)((long)current->self_exec_id))\n\t\tgoto out_put;\n\n\tret = 0;\n \n\twhile (count > 0) {\n\t\tint this_len, retval;\n\n\t\tthis_len = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n\t\tretval = access_remote_vm(mm, src, page, this_len, 0);\n\t\tif (!retval) {\n\t\t\tif (!ret)\n\t\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n \n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\nout_put:\n\tmmput(mm);\nout_free:\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ret;\n}\n\nstatic ssize_t mem_write(struct file * file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tint copied;\n\tchar *page;\n\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n\tunsigned long dst = *ppos;\n\tstruct mm_struct *mm;\n\n\tcopied = -ESRCH;\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tcopied = -ENOMEM;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out_task;\n\n\tmm = check_mem_permission(task);\n\tcopied = PTR_ERR(mm);\n\tif (IS_ERR(mm))\n\t\tgoto out_free;\n\n\tcopied = -EIO;\n\tif (file->private_data != (void *)((long)current->self_exec_id))\n\t\tgoto out_mm;\n\n\tcopied = 0;\n\twhile (count > 0) {\n\t\tint this_len, retval;\n\n\t\tthis_len = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n\t\tif (copy_from_user(page, buf, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tretval = access_remote_vm(mm, dst, page, this_len, 1);\n\t\tif (!retval) {\n\t\t\tif (!copied)\n\t\t\t\tcopied = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcopied += retval;\n\t\tbuf += retval;\n\t\tdst += retval;\n\t\tcount -= retval;\t\t\t\n\t}\n\t*ppos = dst;\n\nout_mm:\n\tmmput(mm);\nout_free:\n\tfree_page((unsigned long) page);\nout_task:\n\tput_task_struct(task);\nout_no_task:\n\treturn copied;\n}\n\nloff_t mem_lseek(struct file *file, loff_t offset, int orig)\n{\n\tswitch (orig) {\n\tcase 0:\n\t\tfile->f_pos = offset;\n\t\tbreak;\n\tcase 1:\n\t\tfile->f_pos += offset;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tforce_successful_syscall_return();\n\treturn file->f_pos;\n}\n\nstatic const struct file_operations proc_mem_operations = {\n\t.llseek\t\t= mem_lseek,\n\t.read\t\t= mem_read,\n\t.write\t\t= mem_write,\n\t.open\t\t= mem_open,\n};\n\nstatic ssize_t environ_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_dentry->d_inode);\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = -ESRCH;\n\tstruct mm_struct *mm;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tret = -ENOMEM;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\n\n\tmm = mm_for_maps(task);\n\tret = PTR_ERR(mm);\n\tif (!mm || IS_ERR(mm))\n\t\tgoto out_free;\n\n\tret = 0;\n\twhile (count > 0) {\n\t\tint this_len, retval, max_len;\n\n\t\tthis_len = mm->env_end - (mm->env_start + src);\n\n\t\tif (this_len <= 0)\n\t\t\tbreak;\n\n\t\tmax_len = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n\t\tthis_len = (this_len > max_len) ? max_len : this_len;\n\n\t\tretval = access_process_vm(task, (mm->env_start + src),\n\t\t\tpage, this_len, 0);\n\n\t\tif (retval <= 0) {\n\t\t\tret = retval;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\n\tmmput(mm);\nout_free:\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ret;\n}\n\nstatic const struct file_operations proc_environ_operations = {\n\t.read\t\t= environ_read,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic ssize_t oom_adjust_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint oom_adjust = OOM_DISABLE;\n\tunsigned long flags;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tif (lock_task_sighand(task, &flags)) {\n\t\toom_adjust = task->signal->oom_adj;\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\n\tput_task_struct(task);\n\n\tlen = snprintf(buffer, sizeof(buffer), \"%i\\n\", oom_adjust);\n\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}\n\nstatic ssize_t oom_adjust_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tint oom_adjust;\n\tunsigned long flags;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terr = kstrtoint(strstrip(buffer), 0, &oom_adjust);\n\tif (err)\n\t\tgoto out;\n\tif ((oom_adjust < OOM_ADJUST_MIN || oom_adjust > OOM_ADJUST_MAX) &&\n\t     oom_adjust != OOM_DISABLE) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttask = get_proc_task(file->f_path.dentry->d_inode);\n\tif (!task) {\n\t\terr = -ESRCH;\n\t\tgoto out;\n\t}\n\n\ttask_lock(task);\n\tif (!task->mm) {\n\t\terr = -EINVAL;\n\t\tgoto err_task_lock;\n\t}\n\n\tif (!lock_task_sighand(task, &flags)) {\n\t\terr = -ESRCH;\n\t\tgoto err_task_lock;\n\t}\n\n\tif (oom_adjust < task->signal->oom_adj && !capable(CAP_SYS_RESOURCE)) {\n\t\terr = -EACCES;\n\t\tgoto err_sighand;\n\t}\n\n\tif (oom_adjust != task->signal->oom_adj) {\n\t\tif (oom_adjust == OOM_DISABLE)\n\t\t\tatomic_inc(&task->mm->oom_disable_count);\n\t\tif (task->signal->oom_adj == OOM_DISABLE)\n\t\t\tatomic_dec(&task->mm->oom_disable_count);\n\t}\n\n\t/*\n\t * Warn that /proc/pid/oom_adj is deprecated, see\n\t * Documentation/feature-removal-schedule.txt.\n\t */\n\tprintk_once(KERN_WARNING \"%s (%d): /proc/%d/oom_adj is deprecated, \"\n\t\t\t\"please use /proc/%d/oom_score_adj instead.\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\ttask_pid_nr(task), task_pid_nr(task));\n\ttask->signal->oom_adj = oom_adjust;\n\t/*\n\t * Scale /proc/pid/oom_score_adj appropriately ensuring that a maximum\n\t * value is always attainable.\n\t */\n\tif (task->signal->oom_adj == OOM_ADJUST_MAX)\n\t\ttask->signal->oom_score_adj = OOM_SCORE_ADJ_MAX;\n\telse\n\t\ttask->signal->oom_score_adj = (oom_adjust * OOM_SCORE_ADJ_MAX) /\n\t\t\t\t\t\t\t\t-OOM_DISABLE;\nerr_sighand:\n\tunlock_task_sighand(task, &flags);\nerr_task_lock:\n\ttask_unlock(task);\n\tput_task_struct(task);\nout:\n\treturn err < 0 ? err : count;\n}\n\nstatic const struct file_operations proc_oom_adjust_operations = {\n\t.read\t\t= oom_adjust_read,\n\t.write\t\t= oom_adjust_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic ssize_t oom_score_adj_read(struct file *file, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n\tchar buffer[PROC_NUMBUF];\n\tint oom_score_adj = OOM_SCORE_ADJ_MIN;\n\tunsigned long flags;\n\tsize_t len;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tif (lock_task_sighand(task, &flags)) {\n\t\toom_score_adj = task->signal->oom_score_adj;\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\tput_task_struct(task);\n\tlen = snprintf(buffer, sizeof(buffer), \"%d\\n\", oom_score_adj);\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}\n\nstatic ssize_t oom_score_adj_write(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tunsigned long flags;\n\tint oom_score_adj;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terr = kstrtoint(strstrip(buffer), 0, &oom_score_adj);\n\tif (err)\n\t\tgoto out;\n\tif (oom_score_adj < OOM_SCORE_ADJ_MIN ||\n\t\t\toom_score_adj > OOM_SCORE_ADJ_MAX) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttask = get_proc_task(file->f_path.dentry->d_inode);\n\tif (!task) {\n\t\terr = -ESRCH;\n\t\tgoto out;\n\t}\n\n\ttask_lock(task);\n\tif (!task->mm) {\n\t\terr = -EINVAL;\n\t\tgoto err_task_lock;\n\t}\n\n\tif (!lock_task_sighand(task, &flags)) {\n\t\terr = -ESRCH;\n\t\tgoto err_task_lock;\n\t}\n\n\tif (oom_score_adj < task->signal->oom_score_adj_min &&\n\t\t\t!capable(CAP_SYS_RESOURCE)) {\n\t\terr = -EACCES;\n\t\tgoto err_sighand;\n\t}\n\n\tif (oom_score_adj != task->signal->oom_score_adj) {\n\t\tif (oom_score_adj == OOM_SCORE_ADJ_MIN)\n\t\t\tatomic_inc(&task->mm->oom_disable_count);\n\t\tif (task->signal->oom_score_adj == OOM_SCORE_ADJ_MIN)\n\t\t\tatomic_dec(&task->mm->oom_disable_count);\n\t}\n\ttask->signal->oom_score_adj = oom_score_adj;\n\tif (has_capability_noaudit(current, CAP_SYS_RESOURCE))\n\t\ttask->signal->oom_score_adj_min = oom_score_adj;\n\t/*\n\t * Scale /proc/pid/oom_adj appropriately ensuring that OOM_DISABLE is\n\t * always attainable.\n\t */\n\tif (task->signal->oom_score_adj == OOM_SCORE_ADJ_MIN)\n\t\ttask->signal->oom_adj = OOM_DISABLE;\n\telse\n\t\ttask->signal->oom_adj = (oom_score_adj * OOM_ADJUST_MAX) /\n\t\t\t\t\t\t\tOOM_SCORE_ADJ_MAX;\nerr_sighand:\n\tunlock_task_sighand(task, &flags);\nerr_task_lock:\n\ttask_unlock(task);\n\tput_task_struct(task);\nout:\n\treturn err < 0 ? err : count;\n}\n\nstatic const struct file_operations proc_oom_score_adj_operations = {\n\t.read\t\t= oom_score_adj_read,\n\t.write\t\t= oom_score_adj_write,\n\t.llseek\t\t= default_llseek,\n};\n\n#ifdef CONFIG_AUDITSYSCALL\n#define TMPBUFLEN 21\nstatic ssize_t proc_loginuid_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tstruct task_struct *task = get_proc_task(inode);\n\tssize_t length;\n\tchar tmpbuf[TMPBUFLEN];\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\",\n\t\t\t\taudit_get_loginuid(task));\n\tput_task_struct(task);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n\nstatic ssize_t proc_loginuid_write(struct file * file, const char __user * buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tchar *page, *tmp;\n\tssize_t length;\n\tuid_t loginuid;\n\n\tif (!capable(CAP_AUDIT_CONTROL))\n\t\treturn -EPERM;\n\n\trcu_read_lock();\n\tif (current != pid_task(proc_pid(inode), PIDTYPE_PID)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\n\tif (count >= PAGE_SIZE)\n\t\tcount = PAGE_SIZE - 1;\n\n\tif (*ppos != 0) {\n\t\t/* No partial writes. */\n\t\treturn -EINVAL;\n\t}\n\tpage = (char*)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tlength = -EFAULT;\n\tif (copy_from_user(page, buf, count))\n\t\tgoto out_free_page;\n\n\tpage[count] = '\\0';\n\tloginuid = simple_strtoul(page, &tmp, 10);\n\tif (tmp == page) {\n\t\tlength = -EINVAL;\n\t\tgoto out_free_page;\n\n\t}\n\tlength = audit_set_loginuid(current, loginuid);\n\tif (likely(length == 0))\n\t\tlength = count;\n\nout_free_page:\n\tfree_page((unsigned long) page);\n\treturn length;\n}\n\nstatic const struct file_operations proc_loginuid_operations = {\n\t.read\t\t= proc_loginuid_read,\n\t.write\t\t= proc_loginuid_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic ssize_t proc_sessionid_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tstruct task_struct *task = get_proc_task(inode);\n\tssize_t length;\n\tchar tmpbuf[TMPBUFLEN];\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\",\n\t\t\t\taudit_get_sessionid(task));\n\tput_task_struct(task);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n\nstatic const struct file_operations proc_sessionid_operations = {\n\t.read\t\t= proc_sessionid_read,\n\t.llseek\t\t= generic_file_llseek,\n};\n#endif\n\n#ifdef CONFIG_FAULT_INJECTION\nstatic ssize_t proc_fault_inject_read(struct file * file, char __user * buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_dentry->d_inode);\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint make_it_fail;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tmake_it_fail = task->make_it_fail;\n\tput_task_struct(task);\n\n\tlen = snprintf(buffer, sizeof(buffer), \"%i\\n\", make_it_fail);\n\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}\n\nstatic ssize_t proc_fault_inject_write(struct file * file,\n\t\t\tconst char __user * buf, size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF], *end;\n\tint make_it_fail;\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\tmake_it_fail = simple_strtol(strstrip(buffer), &end, 0);\n\tif (*end)\n\t\treturn -EINVAL;\n\ttask = get_proc_task(file->f_dentry->d_inode);\n\tif (!task)\n\t\treturn -ESRCH;\n\ttask->make_it_fail = make_it_fail;\n\tput_task_struct(task);\n\n\treturn count;\n}\n\nstatic const struct file_operations proc_fault_inject_operations = {\n\t.read\t\t= proc_fault_inject_read,\n\t.write\t\t= proc_fault_inject_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n#endif\n\n\n#ifdef CONFIG_SCHED_DEBUG\n/*\n * Print out various scheduling related per-task fields:\n */\nstatic int sched_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_show_task(p, m);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic ssize_t\nsched_write(struct file *file, const char __user *buf,\n\t    size_t count, loff_t *offset)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_set_task(p);\n\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int sched_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, sched_show, inode);\n}\n\nstatic const struct file_operations proc_pid_sched_operations = {\n\t.open\t\t= sched_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= sched_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n#endif\n\n#ifdef CONFIG_SCHED_AUTOGROUP\n/*\n * Print out autogroup related information:\n */\nstatic int sched_autogroup_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_autogroup_show_task(p, m);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic ssize_t\nsched_autogroup_write(struct file *file, const char __user *buf,\n\t    size_t count, loff_t *offset)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct task_struct *p;\n\tchar buffer[PROC_NUMBUF];\n\tint nice;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\n\terr = kstrtoint(strstrip(buffer), 0, &nice);\n\tif (err < 0)\n\t\treturn err;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\terr = nice;\n\terr = proc_sched_autogroup_set_nice(p, &err);\n\tif (err)\n\t\tcount = err;\n\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int sched_autogroup_open(struct inode *inode, struct file *filp)\n{\n\tint ret;\n\n\tret = single_open(filp, sched_autogroup_show, NULL);\n\tif (!ret) {\n\t\tstruct seq_file *m = filp->private_data;\n\n\t\tm->private = inode;\n\t}\n\treturn ret;\n}\n\nstatic const struct file_operations proc_pid_sched_autogroup_operations = {\n\t.open\t\t= sched_autogroup_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= sched_autogroup_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n#endif /* CONFIG_SCHED_AUTOGROUP */\n\nstatic ssize_t comm_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *offset)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct task_struct *p;\n\tchar buffer[TASK_COMM_LEN];\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (same_thread_group(current, p))\n\t\tset_task_comm(p, buffer);\n\telse\n\t\tcount = -EINVAL;\n\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int comm_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\ttask_lock(p);\n\tseq_printf(m, \"%s\\n\", p->comm);\n\ttask_unlock(p);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic int comm_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, comm_show, inode);\n}\n\nstatic const struct file_operations proc_pid_set_comm_operations = {\n\t.open\t\t= comm_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= comm_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int proc_exe_link(struct inode *inode, struct path *exe_path)\n{\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tstruct file *exe_file;\n\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\treturn -ENOENT;\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\tif (!mm)\n\t\treturn -ENOENT;\n\texe_file = get_mm_exe_file(mm);\n\tmmput(mm);\n\tif (exe_file) {\n\t\t*exe_path = exe_file->f_path;\n\t\tpath_get(&exe_file->f_path);\n\t\tfput(exe_file);\n\t\treturn 0;\n\t} else\n\t\treturn -ENOENT;\n}\n\nstatic void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\n\t/* We don't need a base pointer in the /proc filesystem */\n\tpath_put(&nd->path);\n\n\t/* Are we allowed to snoop on the tasks file descriptors? */\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(inode, &nd->path);\nout:\n\treturn ERR_PTR(error);\n}\n\nstatic int do_proc_readlink(struct path *path, char __user *buffer, int buflen)\n{\n\tchar *tmp = (char*)__get_free_page(GFP_TEMPORARY);\n\tchar *pathname;\n\tint len;\n\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tpathname = d_path(path, tmp, PAGE_SIZE);\n\tlen = PTR_ERR(pathname);\n\tif (IS_ERR(pathname))\n\t\tgoto out;\n\tlen = tmp + PAGE_SIZE - 1 - pathname;\n\n\tif (len > buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, pathname, len))\n\t\tlen = -EFAULT;\n out:\n\tfree_page((unsigned long)tmp);\n\treturn len;\n}\n\nstatic int proc_pid_readlink(struct dentry * dentry, char __user * buffer, int buflen)\n{\n\tint error = -EACCES;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct path path;\n\n\t/* Are we allowed to snoop on the tasks file descriptors? */\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(inode, &path);\n\tif (error)\n\t\tgoto out;\n\n\terror = do_proc_readlink(&path, buffer, buflen);\n\tpath_put(&path);\nout:\n\treturn error;\n}\n\nstatic const struct inode_operations proc_pid_link_inode_operations = {\n\t.readlink\t= proc_pid_readlink,\n\t.follow_link\t= proc_pid_follow_link,\n\t.setattr\t= proc_setattr,\n};\n\n\n/* building an inode */\n\nstatic int task_dumpable(struct task_struct *task)\n{\n\tint dumpable = 0;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm)\n\t\tdumpable = get_dumpable(mm);\n\ttask_unlock(task);\n\tif(dumpable == 1)\n\t\treturn 1;\n\treturn 0;\n}\n\nstruct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}\n\nint pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\n\tgeneric_fillattr(inode, stat);\n\n\trcu_read_lock();\n\tstat->uid = 0;\n\tstat->gid = 0;\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\tcred = __task_cred(task);\n\t\t\tstat->uid = cred->euid;\n\t\t\tstat->gid = cred->egid;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}\n\n/* dentry stuff */\n\n/*\n *\tExceptional case: normally we are not allowed to unhash a busy\n * directory. In this case, however, we can do it - no aliasing problems\n * due to the way we treat inodes.\n *\n * Rewrite the inode's ownerships here because the owning task may have\n * performed a setuid(), etc.\n *\n * Before the /proc/pid/status file was created the only way to read\n * the effective uid of a /process was to stat /proc/pid.  Reading\n * /proc/pid/status is slow enough that procps and other packages\n * kept stating /proc/pid.  To keep the rules in /proc simple I have\n * made this apply to all per process world readable and executable\n * directories.\n */\nint pid_revalidate(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\n\tif (nd && nd->flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\trcu_read_lock();\n\t\t\tcred = __task_cred(task);\n\t\t\tinode->i_uid = cred->euid;\n\t\t\tinode->i_gid = cred->egid;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tinode->i_uid = 0;\n\t\t\tinode->i_gid = 0;\n\t\t}\n\t\tinode->i_mode &= ~(S_ISUID | S_ISGID);\n\t\tsecurity_task_to_inode(task, inode);\n\t\tput_task_struct(task);\n\t\treturn 1;\n\t}\n\td_drop(dentry);\n\treturn 0;\n}\n\nstatic int pid_delete_dentry(const struct dentry * dentry)\n{\n\t/* Is the task we represent dead?\n\t * If so, then don't put the dentry on the lru list,\n\t * kill it immediately.\n\t */\n\treturn !proc_pid(dentry->d_inode)->tasks[PIDTYPE_PID].first;\n}\n\nconst struct dentry_operations pid_dentry_operations =\n{\n\t.d_revalidate\t= pid_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\n/* Lookups */\n\n/*\n * Fill a directory entry.\n *\n * If possible create the dcache entry and derive our inode number and\n * file type from dcache entry.\n *\n * Since all of the proc inode numbers are dynamically generated, the inode\n * numbers do not exist until the inode is cache.  This means creating the\n * the dcache entry in readdir is necessary to keep the inode numbers\n * reported by readdir in sync with the inode numbers reported\n * by stat.\n */\nint proc_fill_cache(struct file *filp, void *dirent, filldir_t filldir,\n\tconst char *name, int len,\n\tinstantiate_t instantiate, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *child, *dir = filp->f_path.dentry;\n\tstruct inode *inode;\n\tstruct qstr qname;\n\tino_t ino = 0;\n\tunsigned type = DT_UNKNOWN;\n\n\tqname.name = name;\n\tqname.len  = len;\n\tqname.hash = full_name_hash(name, len);\n\n\tchild = d_lookup(dir, &qname);\n\tif (!child) {\n\t\tstruct dentry *new;\n\t\tnew = d_alloc(dir, &qname);\n\t\tif (new) {\n\t\t\tchild = instantiate(dir->d_inode, new, task, ptr);\n\t\t\tif (child)\n\t\t\t\tdput(new);\n\t\t\telse\n\t\t\t\tchild = new;\n\t\t}\n\t}\n\tif (!child || IS_ERR(child) || !child->d_inode)\n\t\tgoto end_instantiate;\n\tinode = child->d_inode;\n\tif (inode) {\n\t\tino = inode->i_ino;\n\t\ttype = inode->i_mode >> 12;\n\t}\n\tdput(child);\nend_instantiate:\n\tif (!ino)\n\t\tino = find_inode_number(dir, &qname);\n\tif (!ino)\n\t\tino = 1;\n\treturn filldir(dirent, name, len, filp->f_pos, ino, type);\n}\n\nstatic unsigned name_to_int(struct dentry *dentry)\n{\n\tconst char *name = dentry->d_name.name;\n\tint len = dentry->d_name.len;\n\tunsigned n = 0;\n\n\tif (len > 1 && *name == '0')\n\t\tgoto out;\n\twhile (len-- > 0) {\n\t\tunsigned c = *name++ - '0';\n\t\tif (c > 9)\n\t\t\tgoto out;\n\t\tif (n >= (~0U-9)/10)\n\t\t\tgoto out;\n\t\tn *= 10;\n\t\tn += c;\n\t}\n\treturn n;\nout:\n\treturn ~0U;\n}\n\n#define PROC_FDINFO_MAX 64\n\nstatic int proc_fd_info(struct inode *inode, struct path *path, char *info)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct files_struct *files = NULL;\n\tstruct file *file;\n\tint fd = proc_fd(inode);\n\n\tif (task) {\n\t\tfiles = get_files_struct(task);\n\t\tput_task_struct(task);\n\t}\n\tif (files) {\n\t\t/*\n\t\t * We are not taking a ref to the file structure, so we must\n\t\t * hold ->file_lock.\n\t\t */\n\t\tspin_lock(&files->file_lock);\n\t\tfile = fcheck_files(files, fd);\n\t\tif (file) {\n\t\t\tif (path) {\n\t\t\t\t*path = file->f_path;\n\t\t\t\tpath_get(&file->f_path);\n\t\t\t}\n\t\t\tif (info)\n\t\t\t\tsnprintf(info, PROC_FDINFO_MAX,\n\t\t\t\t\t \"pos:\\t%lli\\n\"\n\t\t\t\t\t \"flags:\\t0%o\\n\",\n\t\t\t\t\t (long long) file->f_pos,\n\t\t\t\t\t file->f_flags);\n\t\t\tspin_unlock(&files->file_lock);\n\t\t\tput_files_struct(files);\n\t\t\treturn 0;\n\t\t}\n\t\tspin_unlock(&files->file_lock);\n\t\tput_files_struct(files);\n\t}\n\treturn -ENOENT;\n}\n\nstatic int proc_fd_link(struct inode *inode, struct path *path)\n{\n\treturn proc_fd_info(inode, path, NULL);\n}\n\nstatic int tid_fd_revalidate(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode;\n\tstruct task_struct *task;\n\tint fd;\n\tstruct files_struct *files;\n\tconst struct cred *cred;\n\n\tif (nd && nd->flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\tfd = proc_fd(inode);\n\n\tif (task) {\n\t\tfiles = get_files_struct(task);\n\t\tif (files) {\n\t\t\trcu_read_lock();\n\t\t\tif (fcheck_files(files, fd)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tput_files_struct(files);\n\t\t\t\tif (task_dumpable(task)) {\n\t\t\t\t\trcu_read_lock();\n\t\t\t\t\tcred = __task_cred(task);\n\t\t\t\t\tinode->i_uid = cred->euid;\n\t\t\t\t\tinode->i_gid = cred->egid;\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_uid = 0;\n\t\t\t\t\tinode->i_gid = 0;\n\t\t\t\t}\n\t\t\t\tinode->i_mode &= ~(S_ISUID | S_ISGID);\n\t\t\t\tsecurity_task_to_inode(task, inode);\n\t\t\t\tput_task_struct(task);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\tput_files_struct(files);\n\t\t}\n\t\tput_task_struct(task);\n\t}\n\td_drop(dentry);\n\treturn 0;\n}\n\nstatic const struct dentry_operations tid_fd_dentry_operations =\n{\n\t.d_revalidate\t= tid_fd_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\nstatic struct dentry *proc_fd_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tunsigned fd = *(const unsigned *)ptr;\n\tstruct file *file;\n\tstruct files_struct *files;\n \tstruct inode *inode;\n \tstruct proc_inode *ei;\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\tei = PROC_I(inode);\n\tei->fd = fd;\n\tfiles = get_files_struct(task);\n\tif (!files)\n\t\tgoto out_iput;\n\tinode->i_mode = S_IFLNK;\n\n\t/*\n\t * We are not taking a ref to the file structure, so we must\n\t * hold ->file_lock.\n\t */\n\tspin_lock(&files->file_lock);\n\tfile = fcheck_files(files, fd);\n\tif (!file)\n\t\tgoto out_unlock;\n\tif (file->f_mode & FMODE_READ)\n\t\tinode->i_mode |= S_IRUSR | S_IXUSR;\n\tif (file->f_mode & FMODE_WRITE)\n\t\tinode->i_mode |= S_IWUSR | S_IXUSR;\n\tspin_unlock(&files->file_lock);\n\tput_files_struct(files);\n\n\tinode->i_op = &proc_pid_link_inode_operations;\n\tinode->i_size = 64;\n\tei->op.proc_get_link = proc_fd_link;\n\td_set_d_op(dentry, &tid_fd_dentry_operations);\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (tid_fd_revalidate(dentry, NULL))\n\t\terror = NULL;\n\n out:\n\treturn error;\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\tput_files_struct(files);\nout_iput:\n\tiput(inode);\n\tgoto out;\n}\n\nstatic struct dentry *proc_lookupfd_common(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   instantiate_t instantiate)\n{\n\tstruct task_struct *task = get_proc_task(dir);\n\tunsigned fd = name_to_int(dentry);\n\tstruct dentry *result = ERR_PTR(-ENOENT);\n\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (fd == ~0U)\n\t\tgoto out;\n\n\tresult = instantiate(dir, dentry, task, &fd);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn result;\n}\n\nstatic int proc_readfd_common(struct file * filp, void * dirent,\n\t\t\t      filldir_t filldir, instantiate_t instantiate)\n{\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *p = get_proc_task(inode);\n\tunsigned int fd, ino;\n\tint retval;\n\tstruct files_struct * files;\n\n\tretval = -ENOENT;\n\tif (!p)\n\t\tgoto out_no_task;\n\tretval = 0;\n\n\tfd = filp->f_pos;\n\tswitch (fd) {\n\t\tcase 0:\n\t\t\tif (filldir(dirent, \".\", 1, 0, inode->i_ino, DT_DIR) < 0)\n\t\t\t\tgoto out;\n\t\t\tfilp->f_pos++;\n\t\tcase 1:\n\t\t\tino = parent_ino(dentry);\n\t\t\tif (filldir(dirent, \"..\", 2, 1, ino, DT_DIR) < 0)\n\t\t\t\tgoto out;\n\t\t\tfilp->f_pos++;\n\t\tdefault:\n\t\t\tfiles = get_files_struct(p);\n\t\t\tif (!files)\n\t\t\t\tgoto out;\n\t\t\trcu_read_lock();\n\t\t\tfor (fd = filp->f_pos-2;\n\t\t\t     fd < files_fdtable(files)->max_fds;\n\t\t\t     fd++, filp->f_pos++) {\n\t\t\t\tchar name[PROC_NUMBUF];\n\t\t\t\tint len;\n\n\t\t\t\tif (!fcheck_files(files, fd))\n\t\t\t\t\tcontinue;\n\t\t\t\trcu_read_unlock();\n\n\t\t\t\tlen = snprintf(name, sizeof(name), \"%d\", fd);\n\t\t\t\tif (proc_fill_cache(filp, dirent, filldir,\n\t\t\t\t\t\t    name, len, instantiate,\n\t\t\t\t\t\t    p, &fd) < 0) {\n\t\t\t\t\trcu_read_lock();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trcu_read_lock();\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\tput_files_struct(files);\n\t}\nout:\n\tput_task_struct(p);\nout_no_task:\n\treturn retval;\n}\n\nstatic struct dentry *proc_lookupfd(struct inode *dir, struct dentry *dentry,\n\t\t\t\t    struct nameidata *nd)\n{\n\treturn proc_lookupfd_common(dir, dentry, proc_fd_instantiate);\n}\n\nstatic int proc_readfd(struct file *filp, void *dirent, filldir_t filldir)\n{\n\treturn proc_readfd_common(filp, dirent, filldir, proc_fd_instantiate);\n}\n\nstatic ssize_t proc_fdinfo_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t len, loff_t *ppos)\n{\n\tchar tmp[PROC_FDINFO_MAX];\n\tint err = proc_fd_info(file->f_path.dentry->d_inode, NULL, tmp);\n\tif (!err)\n\t\terr = simple_read_from_buffer(buf, len, ppos, tmp, strlen(tmp));\n\treturn err;\n}\n\nstatic const struct file_operations proc_fdinfo_file_operations = {\n\t.open           = nonseekable_open,\n\t.read\t\t= proc_fdinfo_read,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic const struct file_operations proc_fd_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_readfd,\n\t.llseek\t\t= default_llseek,\n};\n\n/*\n * /proc/pid/fd needs a special permission handler so that a process can still\n * access /proc/self/fd after it has executed a setuid().\n */\nstatic int proc_fd_permission(struct inode *inode, int mask, unsigned int flags)\n{\n\tint rv = generic_permission(inode, mask, flags, NULL);\n\tif (rv == 0)\n\t\treturn 0;\n\tif (task_pid(current) == proc_pid(inode))\n\t\trv = 0;\n\treturn rv;\n}\n\n/*\n * proc directories can do almost nothing..\n */\nstatic const struct inode_operations proc_fd_inode_operations = {\n\t.lookup\t\t= proc_lookupfd,\n\t.permission\t= proc_fd_permission,\n\t.setattr\t= proc_setattr,\n};\n\nstatic struct dentry *proc_fdinfo_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tunsigned fd = *(unsigned *)ptr;\n \tstruct inode *inode;\n \tstruct proc_inode *ei;\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\tei = PROC_I(inode);\n\tei->fd = fd;\n\tinode->i_mode = S_IFREG | S_IRUSR;\n\tinode->i_fop = &proc_fdinfo_file_operations;\n\td_set_d_op(dentry, &tid_fd_dentry_operations);\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (tid_fd_revalidate(dentry, NULL))\n\t\terror = NULL;\n\n out:\n\treturn error;\n}\n\nstatic struct dentry *proc_lookupfdinfo(struct inode *dir,\n\t\t\t\t\tstruct dentry *dentry,\n\t\t\t\t\tstruct nameidata *nd)\n{\n\treturn proc_lookupfd_common(dir, dentry, proc_fdinfo_instantiate);\n}\n\nstatic int proc_readfdinfo(struct file *filp, void *dirent, filldir_t filldir)\n{\n\treturn proc_readfd_common(filp, dirent, filldir,\n\t\t\t\t  proc_fdinfo_instantiate);\n}\n\nstatic const struct file_operations proc_fdinfo_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_readfdinfo,\n\t.llseek\t\t= default_llseek,\n};\n\n/*\n * proc directories can do almost nothing..\n */\nstatic const struct inode_operations proc_fdinfo_inode_operations = {\n\t.lookup\t\t= proc_lookupfdinfo,\n\t.setattr\t= proc_setattr,\n};\n\n\nstatic struct dentry *proc_pident_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tconst struct pid_entry *p = ptr;\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tei = PROC_I(inode);\n\tinode->i_mode = p->mode;\n\tif (S_ISDIR(inode->i_mode))\n\t\tinode->i_nlink = 2;\t/* Use getattr to fix if necessary */\n\tif (p->iop)\n\t\tinode->i_op = p->iop;\n\tif (p->fop)\n\t\tinode->i_fop = p->fop;\n\tei->op = p->op;\n\td_set_d_op(dentry, &pid_dentry_operations);\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, NULL))\n\t\terror = NULL;\nout:\n\treturn error;\n}\n\nstatic struct dentry *proc_pident_lookup(struct inode *dir, \n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const struct pid_entry *ents,\n\t\t\t\t\t unsigned int nents)\n{\n\tstruct dentry *error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\n\terror = ERR_PTR(-ENOENT);\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\t/*\n\t * Yes, it does not scale. And it should not. Don't add\n\t * new entries into /proc/<tgid>/ without very good reasons.\n\t */\n\tlast = &ents[nents - 1];\n\tfor (p = ents; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\n\terror = proc_pident_instantiate(dir, dentry, task, p);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn error;\n}\n\nstatic int proc_pident_fill_cache(struct file *filp, void *dirent,\n\tfilldir_t filldir, struct task_struct *task, const struct pid_entry *p)\n{\n\treturn proc_fill_cache(filp, dirent, filldir, p->name, p->len,\n\t\t\t\tproc_pident_instantiate, task, p);\n}\n\nstatic int proc_pident_readdir(struct file *filp,\n\t\tvoid *dirent, filldir_t filldir,\n\t\tconst struct pid_entry *ents, unsigned int nents)\n{\n\tint i;\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task = get_proc_task(inode);\n\tconst struct pid_entry *p, *last;\n\tino_t ino;\n\tint ret;\n\n\tret = -ENOENT;\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tret = 0;\n\ti = filp->f_pos;\n\tswitch (i) {\n\tcase 0:\n\t\tino = inode->i_ino;\n\t\tif (filldir(dirent, \".\", 1, i, ino, DT_DIR) < 0)\n\t\t\tgoto out;\n\t\ti++;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\tcase 1:\n\t\tino = parent_ino(dentry);\n\t\tif (filldir(dirent, \"..\", 2, i, ino, DT_DIR) < 0)\n\t\t\tgoto out;\n\t\ti++;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\tdefault:\n\t\ti -= 2;\n\t\tif (i >= nents) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tp = ents + i;\n\t\tlast = &ents[nents - 1];\n\t\twhile (p <= last) {\n\t\t\tif (proc_pident_fill_cache(filp, dirent, filldir, task, p) < 0)\n\t\t\t\tgoto out;\n\t\t\tfilp->f_pos++;\n\t\t\tp++;\n\t\t}\n\t}\n\n\tret = 1;\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ret;\n}\n\n#ifdef CONFIG_SECURITY\nstatic ssize_t proc_pid_attr_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tchar *p = NULL;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tlength = security_getprocattr(task,\n\t\t\t\t      (char*)file->f_path.dentry->d_name.name,\n\t\t\t\t      &p);\n\tput_task_struct(task);\n\tif (length > 0)\n\t\tlength = simple_read_from_buffer(buf, count, ppos, p, length);\n\tkfree(p);\n\treturn length;\n}\n\nstatic ssize_t proc_pid_attr_write(struct file * file, const char __user * buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tchar *page;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tlength = -ESRCH;\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (count > PAGE_SIZE)\n\t\tcount = PAGE_SIZE;\n\n\t/* No partial writes. */\n\tlength = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tpage = (char*)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\n\tlength = -EFAULT;\n\tif (copy_from_user(page, buf, count))\n\t\tgoto out_free;\n\n\t/* Guard against adverse ptrace interaction */\n\tlength = mutex_lock_interruptible(&task->signal->cred_guard_mutex);\n\tif (length < 0)\n\t\tgoto out_free;\n\n\tlength = security_setprocattr(task,\n\t\t\t\t      (char*)file->f_path.dentry->d_name.name,\n\t\t\t\t      (void*)page, count);\n\tmutex_unlock(&task->signal->cred_guard_mutex);\nout_free:\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn length;\n}\n\nstatic const struct file_operations proc_pid_attr_operations = {\n\t.read\t\t= proc_pid_attr_read,\n\t.write\t\t= proc_pid_attr_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic const struct pid_entry attr_dir_stuff[] = {\n\tREG(\"current\",    S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"prev\",       S_IRUGO,\t   proc_pid_attr_operations),\n\tREG(\"exec\",       S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"fscreate\",   S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"keycreate\",  S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"sockcreate\", S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n};\n\nstatic int proc_attr_dir_readdir(struct file * filp,\n\t\t\t     void * dirent, filldir_t filldir)\n{\n\treturn proc_pident_readdir(filp,dirent,filldir,\n\t\t\t\t   attr_dir_stuff,ARRAY_SIZE(attr_dir_stuff));\n}\n\nstatic const struct file_operations proc_attr_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_attr_dir_readdir,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic struct dentry *proc_attr_dir_lookup(struct inode *dir,\n\t\t\t\tstruct dentry *dentry, struct nameidata *nd)\n{\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  attr_dir_stuff, ARRAY_SIZE(attr_dir_stuff));\n}\n\nstatic const struct inode_operations proc_attr_dir_inode_operations = {\n\t.lookup\t\t= proc_attr_dir_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n\n#endif\n\n#ifdef CONFIG_ELF_CORE\nstatic ssize_t proc_coredump_filter_read(struct file *file, char __user *buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_dentry->d_inode);\n\tstruct mm_struct *mm;\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint ret;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tret = 0;\n\tmm = get_task_mm(task);\n\tif (mm) {\n\t\tlen = snprintf(buffer, sizeof(buffer), \"%08lx\\n\",\n\t\t\t       ((mm->flags & MMF_DUMP_FILTER_MASK) >>\n\t\t\t\tMMF_DUMP_FILTER_SHIFT));\n\t\tmmput(mm);\n\t\tret = simple_read_from_buffer(buf, count, ppos, buffer, len);\n\t}\n\n\tput_task_struct(task);\n\n\treturn ret;\n}\n\nstatic ssize_t proc_coredump_filter_write(struct file *file,\n\t\t\t\t\t  const char __user *buf,\n\t\t\t\t\t  size_t count,\n\t\t\t\t\t  loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tchar buffer[PROC_NUMBUF], *end;\n\tunsigned int val;\n\tint ret;\n\tint i;\n\tunsigned long mask;\n\n\tret = -EFAULT;\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\tgoto out_no_task;\n\n\tret = -EINVAL;\n\tval = (unsigned int)simple_strtoul(buffer, &end, 0);\n\tif (*end == '\\n')\n\t\tend++;\n\tif (end - buffer == 0)\n\t\tgoto out_no_task;\n\n\tret = -ESRCH;\n\ttask = get_proc_task(file->f_dentry->d_inode);\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tret = end - buffer;\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_no_mm;\n\n\tfor (i = 0, mask = 1; i < MMF_DUMP_FILTER_BITS; i++, mask <<= 1) {\n\t\tif (val & mask)\n\t\t\tset_bit(i + MMF_DUMP_FILTER_SHIFT, &mm->flags);\n\t\telse\n\t\t\tclear_bit(i + MMF_DUMP_FILTER_SHIFT, &mm->flags);\n\t}\n\n\tmmput(mm);\n out_no_mm:\n\tput_task_struct(task);\n out_no_task:\n\treturn ret;\n}\n\nstatic const struct file_operations proc_coredump_filter_operations = {\n\t.read\t\t= proc_coredump_filter_read,\n\t.write\t\t= proc_coredump_filter_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n#endif\n\n/*\n * /proc/self:\n */\nstatic int proc_self_readlink(struct dentry *dentry, char __user *buffer,\n\t\t\t      int buflen)\n{\n\tstruct pid_namespace *ns = dentry->d_sb->s_fs_info;\n\tpid_t tgid = task_tgid_nr_ns(current, ns);\n\tchar tmp[PROC_NUMBUF];\n\tif (!tgid)\n\t\treturn -ENOENT;\n\tsprintf(tmp, \"%d\", tgid);\n\treturn vfs_readlink(dentry,buffer,buflen,tmp);\n}\n\nstatic void *proc_self_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct pid_namespace *ns = dentry->d_sb->s_fs_info;\n\tpid_t tgid = task_tgid_nr_ns(current, ns);\n\tchar *name = ERR_PTR(-ENOENT);\n\tif (tgid) {\n\t\tname = __getname();\n\t\tif (!name)\n\t\t\tname = ERR_PTR(-ENOMEM);\n\t\telse\n\t\t\tsprintf(name, \"%d\", tgid);\n\t}\n\tnd_set_link(nd, name);\n\treturn NULL;\n}\n\nstatic void proc_self_put_link(struct dentry *dentry, struct nameidata *nd,\n\t\t\t\tvoid *cookie)\n{\n\tchar *s = nd_get_link(nd);\n\tif (!IS_ERR(s))\n\t\t__putname(s);\n}\n\nstatic const struct inode_operations proc_self_inode_operations = {\n\t.readlink\t= proc_self_readlink,\n\t.follow_link\t= proc_self_follow_link,\n\t.put_link\t= proc_self_put_link,\n};\n\n/*\n * proc base\n *\n * These are the directory entries in the root directory of /proc\n * that properly belong to the /proc filesystem, as they describe\n * describe something that is process related.\n */\nstatic const struct pid_entry proc_base_stuff[] = {\n\tNOD(\"self\", S_IFLNK|S_IRWXUGO,\n\t\t&proc_self_inode_operations, NULL, {}),\n};\n\nstatic struct dentry *proc_base_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tconst struct pid_entry *p = ptr;\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\tstruct dentry *error;\n\n\t/* Allocate the inode */\n\terror = ERR_PTR(-ENOMEM);\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Initialize the inode */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\n\t/*\n\t * grab the reference to the task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_iput;\n\n\tinode->i_mode = p->mode;\n\tif (S_ISDIR(inode->i_mode))\n\t\tinode->i_nlink = 2;\n\tif (S_ISLNK(inode->i_mode))\n\t\tinode->i_size = 64;\n\tif (p->iop)\n\t\tinode->i_op = p->iop;\n\tif (p->fop)\n\t\tinode->i_fop = p->fop;\n\tei->op = p->op;\n\td_add(dentry, inode);\n\terror = NULL;\nout:\n\treturn error;\nout_iput:\n\tiput(inode);\n\tgoto out;\n}\n\nstatic struct dentry *proc_base_lookup(struct inode *dir, struct dentry *dentry)\n{\n\tstruct dentry *error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\n\terror = ERR_PTR(-ENOENT);\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\t/* Lookup the directory entry */\n\tlast = &proc_base_stuff[ARRAY_SIZE(proc_base_stuff) - 1];\n\tfor (p = proc_base_stuff; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\n\terror = proc_base_instantiate(dir, dentry, task, p);\n\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn error;\n}\n\nstatic int proc_base_fill_cache(struct file *filp, void *dirent,\n\tfilldir_t filldir, struct task_struct *task, const struct pid_entry *p)\n{\n\treturn proc_fill_cache(filp, dirent, filldir, p->name, p->len,\n\t\t\t\tproc_base_instantiate, task, p);\n}\n\n#ifdef CONFIG_TASK_IO_ACCOUNTING\nstatic int do_io_accounting(struct task_struct *task, char *buffer, int whole)\n{\n\tstruct task_io_accounting acct = task->ioac;\n\tunsigned long flags;\n\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n\t\treturn -EACCES;\n\n\tif (whole && lock_task_sighand(task, &flags)) {\n\t\tstruct task_struct *t = task;\n\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\treturn sprintf(buffer,\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n\t\t\t(unsigned long long)acct.rchar,\n\t\t\t(unsigned long long)acct.wchar,\n\t\t\t(unsigned long long)acct.syscr,\n\t\t\t(unsigned long long)acct.syscw,\n\t\t\t(unsigned long long)acct.read_bytes,\n\t\t\t(unsigned long long)acct.write_bytes,\n\t\t\t(unsigned long long)acct.cancelled_write_bytes);\n}\n\nstatic int proc_tid_io_accounting(struct task_struct *task, char *buffer)\n{\n\treturn do_io_accounting(task, buffer, 0);\n}\n\nstatic int proc_tgid_io_accounting(struct task_struct *task, char *buffer)\n{\n\treturn do_io_accounting(task, buffer, 1);\n}\n#endif /* CONFIG_TASK_IO_ACCOUNTING */\n\nstatic int proc_pid_personality(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\tstruct pid *pid, struct task_struct *task)\n{\n\tint err = lock_trace(task);\n\tif (!err) {\n\t\tseq_printf(m, \"%08x\\n\", task->personality);\n\t\tunlock_trace(task);\n\t}\n\treturn err;\n}\n\n/*\n * Thread groups\n */\nstatic const struct file_operations proc_task_operations;\nstatic const struct inode_operations proc_task_inode_operations;\n\nstatic const struct pid_entry tgid_base_stuff[] = {\n\tDIR(\"task\",       S_IRUGO|S_IXUGO, proc_task_inode_operations, proc_task_operations),\n\tDIR(\"fd\",         S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"fdinfo\",     S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t  S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",    S_IRUSR, proc_environ_operations),\n\tINF(\"auxv\",       S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",     S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUGO, proc_pid_personality),\n\tINF(\"limits\",\t  S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",      S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n#ifdef CONFIG_SCHED_AUTOGROUP\n\tREG(\"autogroup\",  S_IRUGO|S_IWUSR, proc_pid_sched_autogroup_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tINF(\"syscall\",    S_IRUGO, proc_pid_syscall),\n#endif\n\tINF(\"cmdline\",    S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",       S_IRUGO, proc_tgid_stat),\n\tONE(\"statm\",      S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",       S_IRUGO, proc_maps_operations),\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\",  S_IRUGO, proc_numa_maps_operations),\n#endif\n\tREG(\"mem\",        S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",        proc_cwd_link),\n\tLNK(\"root\",       proc_root_link),\n\tLNK(\"exe\",        proc_exe_link),\n\tREG(\"mounts\",     S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n\tREG(\"mountstats\", S_IRUSR, proc_mountstats_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",      S_IRUGO, proc_smaps_operations),\n\tREG(\"pagemap\",    S_IRUGO, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",       S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tINF(\"wchan\",      S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUGO, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tINF(\"schedstat\",  S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tREG(\"cpuset\",     S_IRUGO, proc_cpuset_operations),\n#endif\n#ifdef CONFIG_CGROUPS\n\tREG(\"cgroup\",  S_IRUGO, proc_cgroup_operations),\n#endif\n\tINF(\"oom_score\",  S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",    S_IRUGO|S_IWUSR, proc_oom_adjust_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",   S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_ELF_CORE\n\tREG(\"coredump_filter\", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tINF(\"io\",\tS_IRUSR, proc_tgid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tINF(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n};\n\nstatic int proc_tgid_base_readdir(struct file * filp,\n\t\t\t     void * dirent, filldir_t filldir)\n{\n\treturn proc_pident_readdir(filp,dirent,filldir,\n\t\t\t\t   tgid_base_stuff,ARRAY_SIZE(tgid_base_stuff));\n}\n\nstatic const struct file_operations proc_tgid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_tgid_base_readdir,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic struct dentry *proc_tgid_base_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd){\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  tgid_base_stuff, ARRAY_SIZE(tgid_base_stuff));\n}\n\nstatic const struct inode_operations proc_tgid_base_inode_operations = {\n\t.lookup\t\t= proc_tgid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n\nstatic void proc_flush_task_mnt(struct vfsmount *mnt, pid_t pid, pid_t tgid)\n{\n\tstruct dentry *dentry, *leader, *dir;\n\tchar buf[PROC_NUMBUF];\n\tstruct qstr name;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", pid);\n\tdentry = d_hash_and_lookup(mnt->mnt_root, &name);\n\tif (dentry) {\n\t\tshrink_dcache_parent(dentry);\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t}\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", tgid);\n\tleader = d_hash_and_lookup(mnt->mnt_root, &name);\n\tif (!leader)\n\t\tgoto out;\n\n\tname.name = \"task\";\n\tname.len = strlen(name.name);\n\tdir = d_hash_and_lookup(leader, &name);\n\tif (!dir)\n\t\tgoto out_put_leader;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", pid);\n\tdentry = d_hash_and_lookup(dir, &name);\n\tif (dentry) {\n\t\tshrink_dcache_parent(dentry);\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t}\n\n\tdput(dir);\nout_put_leader:\n\tdput(leader);\nout:\n\treturn;\n}\n\n/**\n * proc_flush_task -  Remove dcache entries for @task from the /proc dcache.\n * @task: task that should be flushed.\n *\n * When flushing dentries from proc, one needs to flush them from global\n * proc (proc_mnt) and from all the namespaces' procs this task was seen\n * in. This call is supposed to do all of this job.\n *\n * Looks in the dcache for\n * /proc/@pid\n * /proc/@tgid/task/@pid\n * if either directory is present flushes it and all of it'ts children\n * from the dcache.\n *\n * It is safe and reasonable to cache /proc entries for a task until\n * that task exits.  After that they just clog up the dcache with\n * useless entries, possibly causing useful dcache entries to be\n * flushed instead.  This routine is proved to flush those useless\n * dcache entries at process exit time.\n *\n * NOTE: This routine is just an optimization so it does not guarantee\n *       that no dcache entries will exist at process exit time it\n *       just makes it very unlikely that any will persist.\n */\n\nvoid proc_flush_task(struct task_struct *task)\n{\n\tint i;\n\tstruct pid *pid, *tgid;\n\tstruct upid *upid;\n\n\tpid = task_pid(task);\n\ttgid = task_tgid(task);\n\n\tfor (i = 0; i <= pid->level; i++) {\n\t\tupid = &pid->numbers[i];\n\t\tproc_flush_task_mnt(upid->ns->proc_mnt, upid->nr,\n\t\t\t\t\ttgid->numbers[i].nr);\n\t}\n\n\tupid = &pid->numbers[pid->level];\n\tif (upid->nr == 1)\n\t\tpid_ns_release_proc(upid->ns);\n}\n\nstatic struct dentry *proc_pid_instantiate(struct inode *dir,\n\t\t\t\t\t   struct dentry * dentry,\n\t\t\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tgid_base_inode_operations;\n\tinode->i_fop = &proc_tgid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tinode->i_nlink = 2 + pid_entry_count_dirs(tgid_base_stuff,\n\t\tARRAY_SIZE(tgid_base_stuff));\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, NULL))\n\t\terror = NULL;\nout:\n\treturn error;\n}\n\nstruct dentry *proc_pid_lookup(struct inode *dir, struct dentry * dentry, struct nameidata *nd)\n{\n\tstruct dentry *result;\n\tstruct task_struct *task;\n\tunsigned tgid;\n\tstruct pid_namespace *ns;\n\n\tresult = proc_base_lookup(dir, dentry);\n\tif (!IS_ERR(result) || PTR_ERR(result) != -ENOENT)\n\t\tgoto out;\n\n\ttgid = name_to_int(dentry);\n\tif (tgid == ~0U)\n\t\tgoto out;\n\n\tns = dentry->d_sb->s_fs_info;\n\trcu_read_lock();\n\ttask = find_task_by_pid_ns(tgid, ns);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\tif (!task)\n\t\tgoto out;\n\n\tresult = proc_pid_instantiate(dir, dentry, task, NULL);\n\tput_task_struct(task);\nout:\n\treturn result;\n}\n\n/*\n * Find the first task with tgid >= tgid\n *\n */\nstruct tgid_iter {\n\tunsigned int tgid;\n\tstruct task_struct *task;\n};\nstatic struct tgid_iter next_tgid(struct pid_namespace *ns, struct tgid_iter iter)\n{\n\tstruct pid *pid;\n\n\tif (iter.task)\n\t\tput_task_struct(iter.task);\n\trcu_read_lock();\nretry:\n\titer.task = NULL;\n\tpid = find_ge_pid(iter.tgid, ns);\n\tif (pid) {\n\t\titer.tgid = pid_nr_ns(pid, ns);\n\t\titer.task = pid_task(pid, PIDTYPE_PID);\n\t\t/* What we to know is if the pid we have find is the\n\t\t * pid of a thread_group_leader.  Testing for task\n\t\t * being a thread_group_leader is the obvious thing\n\t\t * todo but there is a window when it fails, due to\n\t\t * the pid transfer logic in de_thread.\n\t\t *\n\t\t * So we perform the straight forward test of seeing\n\t\t * if the pid we have found is the pid of a thread\n\t\t * group leader, and don't worry if the task we have\n\t\t * found doesn't happen to be a thread group leader.\n\t\t * As we don't care in the case of readdir.\n\t\t */\n\t\tif (!iter.task || !has_group_leader_pid(iter.task)) {\n\t\t\titer.tgid += 1;\n\t\t\tgoto retry;\n\t\t}\n\t\tget_task_struct(iter.task);\n\t}\n\trcu_read_unlock();\n\treturn iter;\n}\n\n#define TGID_OFFSET (FIRST_PROCESS_ENTRY + ARRAY_SIZE(proc_base_stuff))\n\nstatic int proc_pid_fill_cache(struct file *filp, void *dirent, filldir_t filldir,\n\tstruct tgid_iter iter)\n{\n\tchar name[PROC_NUMBUF];\n\tint len = snprintf(name, sizeof(name), \"%d\", iter.tgid);\n\treturn proc_fill_cache(filp, dirent, filldir, name, len,\n\t\t\t\tproc_pid_instantiate, iter.task, NULL);\n}\n\n/* for the /proc/ directory itself, after non-process stuff has been done */\nint proc_pid_readdir(struct file * filp, void * dirent, filldir_t filldir)\n{\n\tunsigned int nr;\n\tstruct task_struct *reaper;\n\tstruct tgid_iter iter;\n\tstruct pid_namespace *ns;\n\n\tif (filp->f_pos >= PID_MAX_LIMIT + TGID_OFFSET)\n\t\tgoto out_no_task;\n\tnr = filp->f_pos - FIRST_PROCESS_ENTRY;\n\n\treaper = get_proc_task(filp->f_path.dentry->d_inode);\n\tif (!reaper)\n\t\tgoto out_no_task;\n\n\tfor (; nr < ARRAY_SIZE(proc_base_stuff); filp->f_pos++, nr++) {\n\t\tconst struct pid_entry *p = &proc_base_stuff[nr];\n\t\tif (proc_base_fill_cache(filp, dirent, filldir, reaper, p) < 0)\n\t\t\tgoto out;\n\t}\n\n\tns = filp->f_dentry->d_sb->s_fs_info;\n\titer.task = NULL;\n\titer.tgid = filp->f_pos - TGID_OFFSET;\n\tfor (iter = next_tgid(ns, iter);\n\t     iter.task;\n\t     iter.tgid += 1, iter = next_tgid(ns, iter)) {\n\t\tfilp->f_pos = iter.tgid + TGID_OFFSET;\n\t\tif (proc_pid_fill_cache(filp, dirent, filldir, iter) < 0) {\n\t\t\tput_task_struct(iter.task);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfilp->f_pos = PID_MAX_LIMIT + TGID_OFFSET;\nout:\n\tput_task_struct(reaper);\nout_no_task:\n\treturn 0;\n}\n\n/*\n * Tasks\n */\nstatic const struct pid_entry tid_base_stuff[] = {\n\tDIR(\"fd\",        S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"fdinfo\",    S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n\tREG(\"environ\",   S_IRUSR, proc_environ_operations),\n\tINF(\"auxv\",      S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",    S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUGO, proc_pid_personality),\n\tINF(\"limits\",\t S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",     S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tINF(\"syscall\",   S_IRUGO, proc_pid_syscall),\n#endif\n\tINF(\"cmdline\",   S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",      S_IRUGO, proc_tid_stat),\n\tONE(\"statm\",     S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",      S_IRUGO, proc_maps_operations),\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\", S_IRUGO, proc_numa_maps_operations),\n#endif\n\tREG(\"mem\",       S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",       proc_cwd_link),\n\tLNK(\"root\",      proc_root_link),\n\tLNK(\"exe\",       proc_exe_link),\n\tREG(\"mounts\",    S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",     S_IRUGO, proc_smaps_operations),\n\tREG(\"pagemap\",    S_IRUGO, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",      S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tINF(\"wchan\",     S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUGO, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tINF(\"schedstat\", S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tREG(\"cpuset\",    S_IRUGO, proc_cpuset_operations),\n#endif\n#ifdef CONFIG_CGROUPS\n\tREG(\"cgroup\",  S_IRUGO, proc_cgroup_operations),\n#endif\n\tINF(\"oom_score\", S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",   S_IRUGO|S_IWUSR, proc_oom_adjust_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",  S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tINF(\"io\",\tS_IRUSR, proc_tid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tINF(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n};\n\nstatic int proc_tid_base_readdir(struct file * filp,\n\t\t\t     void * dirent, filldir_t filldir)\n{\n\treturn proc_pident_readdir(filp,dirent,filldir,\n\t\t\t\t   tid_base_stuff,ARRAY_SIZE(tid_base_stuff));\n}\n\nstatic struct dentry *proc_tid_base_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd){\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  tid_base_stuff, ARRAY_SIZE(tid_base_stuff));\n}\n\nstatic const struct file_operations proc_tid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_tid_base_readdir,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct inode_operations proc_tid_base_inode_operations = {\n\t.lookup\t\t= proc_tid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n\nstatic struct dentry *proc_task_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\tstruct inode *inode;\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\n\tif (!inode)\n\t\tgoto out;\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tid_base_inode_operations;\n\tinode->i_fop = &proc_tid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tinode->i_nlink = 2 + pid_entry_count_dirs(tid_base_stuff,\n\t\tARRAY_SIZE(tid_base_stuff));\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, NULL))\n\t\terror = NULL;\nout:\n\treturn error;\n}\n\nstatic struct dentry *proc_task_lookup(struct inode *dir, struct dentry * dentry, struct nameidata *nd)\n{\n\tstruct dentry *result = ERR_PTR(-ENOENT);\n\tstruct task_struct *task;\n\tstruct task_struct *leader = get_proc_task(dir);\n\tunsigned tid;\n\tstruct pid_namespace *ns;\n\n\tif (!leader)\n\t\tgoto out_no_task;\n\n\ttid = name_to_int(dentry);\n\tif (tid == ~0U)\n\t\tgoto out;\n\n\tns = dentry->d_sb->s_fs_info;\n\trcu_read_lock();\n\ttask = find_task_by_pid_ns(tid, ns);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\tif (!task)\n\t\tgoto out;\n\tif (!same_thread_group(leader, task))\n\t\tgoto out_drop_task;\n\n\tresult = proc_task_instantiate(dir, dentry, task, NULL);\nout_drop_task:\n\tput_task_struct(task);\nout:\n\tput_task_struct(leader);\nout_no_task:\n\treturn result;\n}\n\n/*\n * Find the first tid of a thread group to return to user space.\n *\n * Usually this is just the thread group leader, but if the users\n * buffer was too small or there was a seek into the middle of the\n * directory we have more work todo.\n *\n * In the case of a short read we start with find_task_by_pid.\n *\n * In the case of a seek we start with the leader and walk nr\n * threads past it.\n */\nstatic struct task_struct *first_tid(struct task_struct *leader,\n\t\tint tid, int nr, struct pid_namespace *ns)\n{\n\tstruct task_struct *pos;\n\n\trcu_read_lock();\n\t/* Attempt to start with the pid of a thread */\n\tif (tid && (nr > 0)) {\n\t\tpos = find_task_by_pid_ns(tid, ns);\n\t\tif (pos && (pos->group_leader == leader))\n\t\t\tgoto found;\n\t}\n\n\t/* If nr exceeds the number of threads there is nothing todo */\n\tpos = NULL;\n\tif (nr && nr >= get_nr_threads(leader))\n\t\tgoto out;\n\n\t/* If we haven't found our starting place yet start\n\t * with the leader and walk nr threads forward.\n\t */\n\tfor (pos = leader; nr > 0; --nr) {\n\t\tpos = next_thread(pos);\n\t\tif (pos == leader) {\n\t\t\tpos = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\nfound:\n\tget_task_struct(pos);\nout:\n\trcu_read_unlock();\n\treturn pos;\n}\n\n/*\n * Find the next thread in the thread list.\n * Return NULL if there is an error or no next thread.\n *\n * The reference to the input task_struct is released.\n */\nstatic struct task_struct *next_tid(struct task_struct *start)\n{\n\tstruct task_struct *pos = NULL;\n\trcu_read_lock();\n\tif (pid_alive(start)) {\n\t\tpos = next_thread(start);\n\t\tif (thread_group_leader(pos))\n\t\t\tpos = NULL;\n\t\telse\n\t\t\tget_task_struct(pos);\n\t}\n\trcu_read_unlock();\n\tput_task_struct(start);\n\treturn pos;\n}\n\nstatic int proc_task_fill_cache(struct file *filp, void *dirent, filldir_t filldir,\n\tstruct task_struct *task, int tid)\n{\n\tchar name[PROC_NUMBUF];\n\tint len = snprintf(name, sizeof(name), \"%d\", tid);\n\treturn proc_fill_cache(filp, dirent, filldir, name, len,\n\t\t\t\tproc_task_instantiate, task, NULL);\n}\n\n/* for the /proc/TGID/task/ directories */\nstatic int proc_task_readdir(struct file * filp, void * dirent, filldir_t filldir)\n{\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *leader = NULL;\n\tstruct task_struct *task;\n\tint retval = -ENOENT;\n\tino_t ino;\n\tint tid;\n\tstruct pid_namespace *ns;\n\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\tgoto out_no_task;\n\trcu_read_lock();\n\tif (pid_alive(task)) {\n\t\tleader = task->group_leader;\n\t\tget_task_struct(leader);\n\t}\n\trcu_read_unlock();\n\tput_task_struct(task);\n\tif (!leader)\n\t\tgoto out_no_task;\n\tretval = 0;\n\n\tswitch ((unsigned long)filp->f_pos) {\n\tcase 0:\n\t\tino = inode->i_ino;\n\t\tif (filldir(dirent, \".\", 1, filp->f_pos, ino, DT_DIR) < 0)\n\t\t\tgoto out;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\tcase 1:\n\t\tino = parent_ino(dentry);\n\t\tif (filldir(dirent, \"..\", 2, filp->f_pos, ino, DT_DIR) < 0)\n\t\t\tgoto out;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\t}\n\n\t/* f_version caches the tgid value that the last readdir call couldn't\n\t * return. lseek aka telldir automagically resets f_version to 0.\n\t */\n\tns = filp->f_dentry->d_sb->s_fs_info;\n\ttid = (int)filp->f_version;\n\tfilp->f_version = 0;\n\tfor (task = first_tid(leader, tid, filp->f_pos - 2, ns);\n\t     task;\n\t     task = next_tid(task), filp->f_pos++) {\n\t\ttid = task_pid_nr_ns(task, ns);\n\t\tif (proc_task_fill_cache(filp, dirent, filldir, task, tid) < 0) {\n\t\t\t/* returning this tgid failed, save it as the first\n\t\t\t * pid for the next readir call */\n\t\t\tfilp->f_version = (u64)tid;\n\t\t\tput_task_struct(task);\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tput_task_struct(leader);\nout_no_task:\n\treturn retval;\n}\n\nstatic int proc_task_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *p = get_proc_task(inode);\n\tgeneric_fillattr(inode, stat);\n\n\tif (p) {\n\t\tstat->nlink += get_nr_threads(p);\n\t\tput_task_struct(p);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct inode_operations proc_task_inode_operations = {\n\t.lookup\t\t= proc_task_lookup,\n\t.getattr\t= proc_task_getattr,\n\t.setattr\t= proc_setattr,\n};\n\nstatic const struct file_operations proc_task_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_task_readdir,\n\t.llseek\t\t= default_llseek,\n};\n"], "filenames": ["fs/proc/base.c"], "buggy_code_start_loc": [2710], "buggy_code_end_loc": [3185], "fixing_code_start_loc": [2711], "fixing_code_end_loc": [3188], "type": "CWE-264", "message": "fs/proc/base.c in the Linux kernel before 2.6.39.4 does not properly restrict access to /proc/#####/io files, which allows local users to obtain sensitive I/O statistics by polling a file, as demonstrated by discovering the length of another user's password.", "other": {"cve": {"id": "CVE-2011-2495", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-13T10:24:55.827", "lastModified": "2023-02-13T00:18:23.983", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "fs/proc/base.c in the Linux kernel before 2.6.39.4 does not properly restrict access to /proc/#####/io files, which allows local users to obtain sensitive I/O statistics by polling a file, as demonstrated by discovering the length of another user's password."}, {"lang": "es", "value": "fs/proc/base.c del kernel de Linux en versiones anteriores a la 2.6.39.4 no restringe el acceso apropiadamente a los archivos /proc/#####/io, lo que facilita a usuarios locales obtener estad\u00edsticas sobre I/O confidenciales consultando un archivo, como se ha demostrado descubriendo la lengitud de la contrase\u00f1a de otro usuario."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.39.3", "matchCriteriaId": "94597E40-EA22-414E-BF5A-A4664E943F09"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:*:*:*:*:*:*:*", "matchCriteriaId": "EAAF54BC-6282-492F-BA52-8792223320ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:rc1:*:*:*:*:*:*", "matchCriteriaId": "2493C2FB-2BA1-4DB3-BC04-E282C9CD399D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:rc2:*:*:*:*:*:*", "matchCriteriaId": "18DBC8AF-18ED-4879-8888-23022E494D14"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:rc3:*:*:*:*:*:*", "matchCriteriaId": "75EB375B-8ADF-4EAB-A3FB-ED5D35E5E719"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:rc4:*:*:*:*:*:*", "matchCriteriaId": "D49BB231-622E-4F20-97C8-E6289933912C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:rc5:*:*:*:*:*:*", "matchCriteriaId": "2D6859AA-DA7F-4AF9-8443-05962171D6E3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:rc6:*:*:*:*:*:*", "matchCriteriaId": "9B79A89D-F048-48C5-B148-4B38A6C3953B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:rc7:*:*:*:*:*:*", "matchCriteriaId": "BEBA9217-9105-4BA3-BE1E-FE387FECEF87"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39.1:*:*:*:*:*:*:*", "matchCriteriaId": "1713DDF4-33F1-4716-84D7-FCFECCF9BCCA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39.2:*:*:*:*:*:*:*", "matchCriteriaId": "ABCE5879-317D-4A33-B6DA-A9ACF553F8E9"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.39.4", "source": "secalert@redhat.com"}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=1d1221f375c94ef961ba8574ac4f85c8870ddd51", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2011-1212.html", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/06/27/1", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=716825", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/1d1221f375c94ef961ba8574ac4f85c8870ddd51", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/1d1221f375c94ef961ba8574ac4f85c8870ddd51"}}