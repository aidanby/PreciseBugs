{"buggy_code": ["# Authors: \n#   Trevor Perrin\n#   Google (adapted by Sam Rushing) - NPN support\n#   Google - minimal padding\n#   Martin von Loewis - python 3 port\n#   Yngve Pettersen (ported by Paul Sokolovsky) - TLS 1.2\n#\n# See the LICENSE file for legal information regarding use of this file.\n\n\"\"\"Helper class for TLSConnection.\"\"\"\nfrom __future__ import generators\n\nfrom .utils.compat import *\nfrom .utils.cryptomath import *\nfrom .utils.cipherfactory import createAES, createRC4, createTripleDES\nfrom .utils.codec import *\nfrom .errors import *\nfrom .messages import *\nfrom .mathtls import *\nfrom .constants import *\nfrom .utils.cryptomath import getRandomBytes\n\nimport socket\nimport errno\nimport traceback\n\nclass _ConnectionState(object):\n    def __init__(self):\n        self.macContext = None\n        self.encContext = None\n        self.seqnum = 0\n\n    def getSeqNumBytes(self):\n        w = Writer()\n        w.add(self.seqnum, 8)\n        self.seqnum += 1\n        return w.bytes\n\n\nclass TLSRecordLayer(object):\n    \"\"\"\n    This class handles data transmission for a TLS connection.\n\n    Its only subclass is L{tlslite.TLSConnection.TLSConnection}.  We've\n    separated the code in this class from TLSConnection to make things\n    more readable.\n\n\n    @type sock: socket.socket\n    @ivar sock: The underlying socket object.\n\n    @type session: L{tlslite.Session.Session}\n    @ivar session: The session corresponding to this connection.\n\n    Due to TLS session resumption, multiple connections can correspond\n    to the same underlying session.\n\n    @type version: tuple\n    @ivar version: The TLS version being used for this connection.\n\n    (3,0) means SSL 3.0, and (3,1) means TLS 1.0.\n\n    @type closed: bool\n    @ivar closed: If this connection is closed.\n\n    @type resumed: bool\n    @ivar resumed: If this connection is based on a resumed session.\n\n    @type allegedSrpUsername: str or None\n    @ivar allegedSrpUsername:  This is set to the SRP username\n    asserted by the client, whether the handshake succeeded or not.\n    If the handshake fails, this can be inspected to determine\n    if a guessing attack is in progress against a particular user\n    account.\n\n    @type closeSocket: bool\n    @ivar closeSocket: If the socket should be closed when the\n    connection is closed, defaults to True (writable).\n\n    If you set this to True, TLS Lite will assume the responsibility of\n    closing the socket when the TLS Connection is shutdown (either\n    through an error or through the user calling close()).  The default\n    is False.\n\n    @type ignoreAbruptClose: bool\n    @ivar ignoreAbruptClose: If an abrupt close of the socket should\n    raise an error (writable).\n\n    If you set this to True, TLS Lite will not raise a\n    L{tlslite.errors.TLSAbruptCloseError} exception if the underlying\n    socket is unexpectedly closed.  Such an unexpected closure could be\n    caused by an attacker.  However, it also occurs with some incorrect\n    TLS implementations.\n\n    You should set this to True only if you're not worried about an\n    attacker truncating the connection, and only if necessary to avoid\n    spurious errors.  The default is False.\n\n    @sort: __init__, read, readAsync, write, writeAsync, close, closeAsync,\n    getCipherImplementation, getCipherName\n    \"\"\"\n\n    def __init__(self, sock):\n        self.sock = sock\n\n        #My session object (Session instance; read-only)\n        self.session = None\n\n        #Am I a client or server?\n        self._client = None\n\n        #Buffers for processing messages\n        self._handshakeBuffer = []\n        self.clearReadBuffer()\n        self.clearWriteBuffer()\n\n        #Handshake digests\n        self._handshake_md5 = hashlib.md5()\n        self._handshake_sha = hashlib.sha1()\n        self._handshake_sha256 = hashlib.sha256()\n\n        #TLS Protocol Version\n        self.version = (0,0) #read-only\n        self._versionCheck = False #Once we choose a version, this is True\n\n        #Current and Pending connection states\n        self._writeState = _ConnectionState()\n        self._readState = _ConnectionState()\n        self._pendingWriteState = _ConnectionState()\n        self._pendingReadState = _ConnectionState()\n\n        #Is the connection open?\n        self.closed = True #read-only\n        self._refCount = 0 #Used to trigger closure\n\n        #Is this a resumed session?\n        self.resumed = False #read-only\n\n        #What username did the client claim in his handshake?\n        self.allegedSrpUsername = None\n\n        #On a call to close(), do we close the socket? (writeable)\n        self.closeSocket = True\n\n        #If the socket is abruptly closed, do we ignore it\n        #and pretend the connection was shut down properly? (writeable)\n        self.ignoreAbruptClose = False\n\n        #Fault we will induce, for testing purposes\n        self.fault = None\n\n    def clearReadBuffer(self):\n        self._readBuffer = b''\n\n    def clearWriteBuffer(self):\n        self._send_writer = None\n\n\n    #*********************************************************\n    # Public Functions START\n    #*********************************************************\n\n    def read(self, max=None, min=1):\n        \"\"\"Read some data from the TLS connection.\n\n        This function will block until at least 'min' bytes are\n        available (or the connection is closed).\n\n        If an exception is raised, the connection will have been\n        automatically closed.\n\n        @type max: int\n        @param max: The maximum number of bytes to return.\n\n        @type min: int\n        @param min: The minimum number of bytes to return\n\n        @rtype: str\n        @return: A string of no more than 'max' bytes, and no fewer\n        than 'min' (unless the connection has been closed, in which\n        case fewer than 'min' bytes may be returned).\n\n        @raise socket.error: If a socket error occurs.\n        @raise tlslite.errors.TLSAbruptCloseError: If the socket is closed\n        without a preceding alert.\n        @raise tlslite.errors.TLSAlert: If a TLS alert is signalled.\n        \"\"\"\n        for result in self.readAsync(max, min):\n            pass\n        return result\n\n    def readAsync(self, max=None, min=1):\n        \"\"\"Start a read operation on the TLS connection.\n\n        This function returns a generator which behaves similarly to\n        read().  Successive invocations of the generator will return 0\n        if it is waiting to read from the socket, 1 if it is waiting\n        to write to the socket, or a string if the read operation has\n        completed.\n\n        @rtype: iterable\n        @return: A generator; see above for details.\n        \"\"\"\n        try:\n            while len(self._readBuffer)<min and not self.closed:\n                try:\n                    for result in self._getMsg(ContentType.application_data):\n                        if result in (0,1):\n                            yield result\n                    applicationData = result\n                    self._readBuffer += applicationData.write()\n                except TLSRemoteAlert as alert:\n                    if alert.description != AlertDescription.close_notify:\n                        raise\n                except TLSAbruptCloseError:\n                    if not self.ignoreAbruptClose:\n                        raise\n                    else:\n                        self._shutdown(True)\n\n            if max == None:\n                max = len(self._readBuffer)\n\n            returnBytes = self._readBuffer[:max]\n            self._readBuffer = self._readBuffer[max:]\n            yield bytes(returnBytes)\n        except GeneratorExit:\n            raise\n        except:\n            self._shutdown(False)\n            raise\n\n    def unread(self, b):\n        \"\"\"Add bytes to the front of the socket read buffer for future\n        reading. Be careful using this in the context of select(...): if you\n        unread the last data from a socket, that won't wake up selected waiters,\n        and those waiters may hang forever.\n        \"\"\"\n        self._readBuffer = b + self._readBuffer\n\n    def write(self, s):\n        \"\"\"Write some data to the TLS connection.\n\n        This function will block until all the data has been sent.\n\n        If an exception is raised, the connection will have been\n        automatically closed.\n\n        @type s: str\n        @param s: The data to transmit to the other party.\n\n        @raise socket.error: If a socket error occurs.\n        \"\"\"\n        for result in self.writeAsync(s):\n            pass\n\n    def writeAsync(self, s):\n        \"\"\"Start a write operation on the TLS connection.\n\n        This function returns a generator which behaves similarly to\n        write().  Successive invocations of the generator will return\n        1 if it is waiting to write to the socket, or will raise\n        StopIteration if the write operation has completed.\n\n        @rtype: iterable\n        @return: A generator; see above for details.\n        \"\"\"\n        try:\n            if self.closed:\n                raise TLSClosedConnectionError(\"attempt to write to closed connection\")\n\n            index = 0\n            blockSize = 16384\n            randomizeFirstBlock = True\n            while 1:\n                startIndex = index * blockSize\n                endIndex = startIndex + blockSize\n                if startIndex >= len(s):\n                    break\n                if endIndex > len(s):\n                    endIndex = len(s)\n                block = bytearray(s[startIndex : endIndex])\n                applicationData = ApplicationData().create(block)\n                for result in self._sendMsg(applicationData, \\\n                                            randomizeFirstBlock):\n                    yield result\n                randomizeFirstBlock = False #only on 1st message\n                index += 1\n        except GeneratorExit:\n            raise\n        except Exception:\n            # Don't invalidate the session on write failure if abrupt closes are\n            # okay.\n            self._shutdown(self.ignoreAbruptClose)\n            raise\n\n    def close(self):\n        \"\"\"Close the TLS connection.\n\n        This function will block until it has exchanged close_notify\n        alerts with the other party.  After doing so, it will shut down the\n        TLS connection.  Further attempts to read through this connection\n        will return \"\".  Further attempts to write through this connection\n        will raise ValueError.\n\n        If makefile() has been called on this connection, the connection\n        will be not be closed until the connection object and all file\n        objects have been closed.\n\n        Even if an exception is raised, the connection will have been\n        closed.\n\n        @raise socket.error: If a socket error occurs.\n        @raise tlslite.errors.TLSAbruptCloseError: If the socket is closed\n        without a preceding alert.\n        @raise tlslite.errors.TLSAlert: If a TLS alert is signalled.\n        \"\"\"\n        if not self.closed:\n            for result in self._decrefAsync():\n                pass\n\n    # Python 3 callback\n    _decref_socketios = close\n\n    def closeAsync(self):\n        \"\"\"Start a close operation on the TLS connection.\n\n        This function returns a generator which behaves similarly to\n        close().  Successive invocations of the generator will return 0\n        if it is waiting to read from the socket, 1 if it is waiting\n        to write to the socket, or will raise StopIteration if the\n        close operation has completed.\n\n        @rtype: iterable\n        @return: A generator; see above for details.\n        \"\"\"\n        if not self.closed:\n            for result in self._decrefAsync():\n                yield result\n\n    def _decrefAsync(self):\n        self._refCount -= 1\n        if self._refCount == 0 and not self.closed:\n            try:\n                for result in self._sendMsg(Alert().create(\\\n                        AlertDescription.close_notify, AlertLevel.warning)):\n                    yield result\n                alert = None\n                # By default close the socket, since it's been observed\n                # that some other libraries will not respond to the \n                # close_notify alert, thus leaving us hanging if we're\n                # expecting it\n                if self.closeSocket:\n                    self._shutdown(True)\n                else:\n                    while not alert:\n                        for result in self._getMsg((ContentType.alert, \\\n                                                  ContentType.application_data)):\n                            if result in (0,1):\n                                yield result\n                        if result.contentType == ContentType.alert:\n                            alert = result\n                    if alert.description == AlertDescription.close_notify:\n                        self._shutdown(True)\n                    else:\n                        raise TLSRemoteAlert(alert)\n            except (socket.error, TLSAbruptCloseError):\n                #If the other side closes the socket, that's okay\n                self._shutdown(True)\n            except GeneratorExit:\n                raise\n            except:\n                self._shutdown(False)\n                raise\n\n    def getVersionName(self):\n        \"\"\"Get the name of this TLS version.\n\n        @rtype: str\n        @return: The name of the TLS version used with this connection.\n        Either None, 'SSL 3.0', 'TLS 1.0', 'TLS 1.1', or 'TLS 1.2'.\n        \"\"\"\n        if self.version == (3,0):\n            return \"SSL 3.0\"\n        elif self.version == (3,1):\n            return \"TLS 1.0\"\n        elif self.version == (3,2):\n            return \"TLS 1.1\"\n        elif self.version == (3,3):\n            return \"TLS 1.2\"\n        else:\n            return None\n        \n    def getCipherName(self):\n        \"\"\"Get the name of the cipher used with this connection.\n\n        @rtype: str\n        @return: The name of the cipher used with this connection.\n        Either 'aes128', 'aes256', 'rc4', or '3des'.\n        \"\"\"\n        if not self._writeState.encContext:\n            return None\n        return self._writeState.encContext.name\n\n    def getCipherImplementation(self):\n        \"\"\"Get the name of the cipher implementation used with\n        this connection.\n\n        @rtype: str\n        @return: The name of the cipher implementation used with\n        this connection.  Either 'python', 'openssl', or 'pycrypto'.\n        \"\"\"\n        if not self._writeState.encContext:\n            return None\n        return self._writeState.encContext.implementation\n\n\n\n    #Emulate a socket, somewhat -\n    def send(self, s):\n        \"\"\"Send data to the TLS connection (socket emulation).\n\n        @raise socket.error: If a socket error occurs.\n        \"\"\"\n        self.write(s)\n        return len(s)\n\n    def sendall(self, s):\n        \"\"\"Send data to the TLS connection (socket emulation).\n\n        @raise socket.error: If a socket error occurs.\n        \"\"\"\n        self.write(s)\n\n    def recv(self, bufsize):\n        \"\"\"Get some data from the TLS connection (socket emulation).\n\n        @raise socket.error: If a socket error occurs.\n        @raise tlslite.errors.TLSAbruptCloseError: If the socket is closed\n        without a preceding alert.\n        @raise tlslite.errors.TLSAlert: If a TLS alert is signalled.\n        \"\"\"\n        return self.read(bufsize)\n\n    def recv_into(self, b):\n        # XXX doc string\n        data = self.read(len(b))\n        if not data:\n            return None\n        b[:len(data)] = data\n        return len(data)\n\n    def makefile(self, mode='r', bufsize=-1):\n        \"\"\"Create a file object for the TLS connection (socket emulation).\n\n        @rtype: L{socket._fileobject}\n        \"\"\"\n        self._refCount += 1\n        # So, it is pretty fragile to be using Python internal objects\n        # like this, but it is probably the best/easiest way to provide\n        # matching behavior for socket emulation purposes.  The 'close'\n        # argument is nice, its apparently a recent addition to this\n        # class, so that when fileobject.close() gets called, it will\n        # close() us, causing the refcount to be decremented (decrefAsync).\n        #\n        # If this is the last close() on the outstanding fileobjects / \n        # TLSConnection, then the \"actual\" close alerts will be sent,\n        # socket closed, etc.\n        if sys.version_info < (3,):\n            return socket._fileobject(self, mode, bufsize, close=True)\n        else:\n            # XXX need to wrap this further if buffering is requested\n            return socket.SocketIO(self, mode)\n\n    def getsockname(self):\n        \"\"\"Return the socket's own address (socket emulation).\"\"\"\n        return self.sock.getsockname()\n\n    def getpeername(self):\n        \"\"\"Return the remote address to which the socket is connected\n        (socket emulation).\"\"\"\n        return self.sock.getpeername()\n\n    def settimeout(self, value):\n        \"\"\"Set a timeout on blocking socket operations (socket emulation).\"\"\"\n        return self.sock.settimeout(value)\n\n    def gettimeout(self):\n        \"\"\"Return the timeout associated with socket operations (socket\n        emulation).\"\"\"\n        return self.sock.gettimeout()\n\n    def setsockopt(self, level, optname, value):\n        \"\"\"Set the value of the given socket option (socket emulation).\"\"\"\n        return self.sock.setsockopt(level, optname, value)\n\n    def shutdown(self, how):\n        \"\"\"Shutdown the underlying socket.\"\"\"\n        return self.sock.shutdown(how)\n    \t\n    def fileno(self):\n        \"\"\"Not implement in TLS Lite.\"\"\"\n        raise NotImplementedError()\n    \t\n\n     #*********************************************************\n     # Public Functions END\n     #*********************************************************\n\n    def _shutdown(self, resumable):\n        self._writeState = _ConnectionState()\n        self._readState = _ConnectionState()\n        self.version = (0,0)\n        self._versionCheck = False\n        self.closed = True\n        if self.closeSocket:\n            self.sock.close()\n\n        #Even if resumable is False, we'll never toggle this on\n        if not resumable and self.session:\n            self.session.resumable = False\n\n\n    def _sendError(self, alertDescription, errorStr=None):\n        alert = Alert().create(alertDescription, AlertLevel.fatal)\n        for result in self._sendMsg(alert):\n            yield result\n        self._shutdown(False)\n        raise TLSLocalAlert(alert, errorStr)\n\n    def _sendMsgs(self, msgs):\n        randomizeFirstBlock = True\n        for msg in msgs:\n            for result in self._sendMsg(msg, randomizeFirstBlock):\n                yield result\n            randomizeFirstBlock = True\n\n    def _sendMsg(self, msg, randomizeFirstBlock = True):\n        #Whenever we're connected and asked to send an app data message,\n        #we first send the first byte of the message.  This prevents\n        #an attacker from launching a chosen-plaintext attack based on\n        #knowing the next IV (a la BEAST).\n        if not self.closed and randomizeFirstBlock and self.version <= (3,1) \\\n                and self._writeState.encContext \\\n                and self._writeState.encContext.isBlockCipher \\\n                and isinstance(msg, ApplicationData):\n            msgFirstByte = msg.splitFirstByte()\n            for result in self._sendMsg(msgFirstByte,\n                                       randomizeFirstBlock = False):\n                yield result                                            \n\n        b = msg.write()\n        \n        # If a 1-byte message was passed in, and we \"split\" the \n        # first(only) byte off above, we may have a 0-length msg:\n        if len(b) == 0:\n            return\n            \n        contentType = msg.contentType\n\n        #Update handshake hashes\n        if contentType == ContentType.handshake:\n            self._handshake_md5.update(compat26Str(b))\n            self._handshake_sha.update(compat26Str(b))\n            self._handshake_sha256.update(compat26Str(b))\n\n        #Calculate MAC\n        if self._writeState.macContext:\n            seqnumBytes = self._writeState.getSeqNumBytes()\n            mac = self._writeState.macContext.copy()\n            mac.update(compatHMAC(seqnumBytes))\n            mac.update(compatHMAC(bytearray([contentType])))\n            if self.version == (3,0):\n                mac.update( compatHMAC( bytearray([len(b)//256] )))\n                mac.update( compatHMAC( bytearray([len(b)%256] )))\n            elif self.version in ((3,1), (3,2), (3,3)):\n                mac.update(compatHMAC( bytearray([self.version[0]] )))\n                mac.update(compatHMAC( bytearray([self.version[1]] )))\n                mac.update( compatHMAC( bytearray([len(b)//256] )))\n                mac.update( compatHMAC( bytearray([len(b)%256] )))\n            else:\n                raise AssertionError()\n            mac.update(compatHMAC(b))\n            macBytes = bytearray(mac.digest())\n            if self.fault == Fault.badMAC:\n                macBytes[0] = (macBytes[0]+1) % 256\n\n        #Encrypt for Block or Stream Cipher\n        if self._writeState.encContext:\n            #Add padding and encrypt (for Block Cipher):\n            if self._writeState.encContext.isBlockCipher:\n\n                #Add TLS 1.1 fixed block\n                if self.version >= (3,2):\n                    b = self.fixedIVBlock + b\n\n                #Add padding: b = b+ (macBytes + paddingBytes)\n                currentLength = len(b) + len(macBytes)\n                blockLength = self._writeState.encContext.block_size\n                paddingLength = blockLength - 1 - (currentLength % blockLength)\n\n                paddingBytes = bytearray([paddingLength] * (paddingLength+1))\n                if self.fault == Fault.badPadding:\n                    paddingBytes[0] = (paddingBytes[0]+1) % 256\n                endBytes = macBytes + paddingBytes\n                b += endBytes\n                #Encrypt\n                b = self._writeState.encContext.encrypt(b)\n\n            #Encrypt (for Stream Cipher)\n            else:\n                b += macBytes\n                b = self._writeState.encContext.encrypt(b)\n\n        #Add record header and send\n        r = RecordHeader3().create(self.version, contentType, len(b))\n        s = r.write() + b\n        while 1:\n            try:\n                bytesSent = self.sock.send(s) #Might raise socket.error\n            except socket.error as why:\n                if why.args[0] in (errno.EWOULDBLOCK, errno.EAGAIN):\n                    yield 1\n                    continue\n                else:\n                    # The socket was unexpectedly closed.  The tricky part\n                    # is that there may be an alert sent by the other party\n                    # sitting in the read buffer.  So, if we get here after\n                    # handshaking, we will just raise the error and let the\n                    # caller read more data if it would like, thus stumbling\n                    # upon the error.\n                    #\n                    # However, if we get here DURING handshaking, we take\n                    # it upon ourselves to see if the next message is an \n                    # Alert.\n                    if contentType == ContentType.handshake:\n                        \n                        # See if there's an alert record\n                        # Could raise socket.error or TLSAbruptCloseError\n                        for result in self._getNextRecord():\n                            if result in (0,1):\n                                yield result\n                                \n                        # Closes the socket\n                        self._shutdown(False)\n                        \n                        # If we got an alert, raise it        \n                        recordHeader, p = result                        \n                        if recordHeader.type == ContentType.alert:\n                            alert = Alert().parse(p)\n                            raise TLSRemoteAlert(alert)\n                    else:\n                        # If we got some other message who know what\n                        # the remote side is doing, just go ahead and\n                        # raise the socket.error\n                        raise\n            if bytesSent == len(s):\n                return\n            s = s[bytesSent:]\n            yield 1\n\n\n    def _getMsg(self, expectedType, secondaryType=None, constructorType=None):\n        try:\n            if not isinstance(expectedType, tuple):\n                expectedType = (expectedType,)\n\n            #Spin in a loop, until we've got a non-empty record of a type we\n            #expect.  The loop will be repeated if:\n            #  - we receive a renegotiation attempt; we send no_renegotiation,\n            #    then try again\n            #  - we receive an empty application-data fragment; we try again\n            while 1:\n                for result in self._getNextRecord():\n                    if result in (0,1):\n                        yield result\n                recordHeader, p = result\n\n                #If this is an empty application-data fragment, try again\n                if recordHeader.type == ContentType.application_data:\n                    if p.index == len(p.bytes):\n                        continue\n\n                #If we received an unexpected record type...\n                if recordHeader.type not in expectedType:\n\n                    #If we received an alert...\n                    if recordHeader.type == ContentType.alert:\n                        alert = Alert().parse(p)\n\n                        #We either received a fatal error, a warning, or a\n                        #close_notify.  In any case, we're going to close the\n                        #connection.  In the latter two cases we respond with\n                        #a close_notify, but ignore any socket errors, since\n                        #the other side might have already closed the socket.\n                        if alert.level == AlertLevel.warning or \\\n                           alert.description == AlertDescription.close_notify:\n\n                            #If the sendMsg() call fails because the socket has\n                            #already been closed, we will be forgiving and not\n                            #report the error nor invalidate the \"resumability\"\n                            #of the session.\n                            try:\n                                alertMsg = Alert()\n                                alertMsg.create(AlertDescription.close_notify,\n                                                AlertLevel.warning)\n                                for result in self._sendMsg(alertMsg):\n                                    yield result\n                            except socket.error:\n                                pass\n\n                            if alert.description == \\\n                                   AlertDescription.close_notify:\n                                self._shutdown(True)\n                            elif alert.level == AlertLevel.warning:\n                                self._shutdown(False)\n\n                        else: #Fatal alert:\n                            self._shutdown(False)\n\n                        #Raise the alert as an exception\n                        raise TLSRemoteAlert(alert)\n\n                    #If we received a renegotiation attempt...\n                    if recordHeader.type == ContentType.handshake:\n                        subType = p.get(1)\n                        reneg = False\n                        if self._client:\n                            if subType == HandshakeType.hello_request:\n                                reneg = True\n                        else:\n                            if subType == HandshakeType.client_hello:\n                                reneg = True\n                        #Send no_renegotiation, then try again\n                        if reneg:\n                            alertMsg = Alert()\n                            alertMsg.create(AlertDescription.no_renegotiation,\n                                            AlertLevel.warning)\n                            for result in self._sendMsg(alertMsg):\n                                yield result\n                            continue\n\n                    #Otherwise: this is an unexpected record, but neither an\n                    #alert nor renegotiation\n                    for result in self._sendError(\\\n                            AlertDescription.unexpected_message,\n                            \"received type=%d\" % recordHeader.type):\n                        yield result\n\n                break\n\n            #Parse based on content_type\n            if recordHeader.type == ContentType.change_cipher_spec:\n                yield ChangeCipherSpec().parse(p)\n            elif recordHeader.type == ContentType.alert:\n                yield Alert().parse(p)\n            elif recordHeader.type == ContentType.application_data:\n                yield ApplicationData().parse(p)\n            elif recordHeader.type == ContentType.handshake:\n                #Convert secondaryType to tuple, if it isn't already\n                if not isinstance(secondaryType, tuple):\n                    secondaryType = (secondaryType,)\n\n                #If it's a handshake message, check handshake header\n                if recordHeader.ssl2:\n                    subType = p.get(1)\n                    if subType != HandshakeType.client_hello:\n                        for result in self._sendError(\\\n                                AlertDescription.unexpected_message,\n                                \"Can only handle SSLv2 ClientHello messages\"):\n                            yield result\n                    if HandshakeType.client_hello not in secondaryType:\n                        for result in self._sendError(\\\n                                AlertDescription.unexpected_message):\n                            yield result\n                    subType = HandshakeType.client_hello\n                else:\n                    subType = p.get(1)\n                    if subType not in secondaryType:\n                        for result in self._sendError(\\\n                                AlertDescription.unexpected_message,\n                                \"Expecting %s, got %s\" % (str(secondaryType), subType)):\n                            yield result\n\n                #Update handshake hashes\n                self._handshake_md5.update(compat26Str(p.bytes))\n                self._handshake_sha.update(compat26Str(p.bytes))\n                self._handshake_sha256.update(compat26Str(p.bytes))\n\n                #Parse based on handshake type\n                if subType == HandshakeType.client_hello:\n                    yield ClientHello(recordHeader.ssl2).parse(p)\n                elif subType == HandshakeType.server_hello:\n                    yield ServerHello().parse(p)\n                elif subType == HandshakeType.certificate:\n                    yield Certificate(constructorType).parse(p)\n                elif subType == HandshakeType.certificate_request:\n                    yield CertificateRequest(self.version).parse(p)\n                elif subType == HandshakeType.certificate_verify:\n                    yield CertificateVerify(self.version).parse(p)\n                elif subType == HandshakeType.server_key_exchange:\n                    yield ServerKeyExchange(constructorType).parse(p)\n                elif subType == HandshakeType.server_hello_done:\n                    yield ServerHelloDone().parse(p)\n                elif subType == HandshakeType.client_key_exchange:\n                    yield ClientKeyExchange(constructorType, \\\n                                            self.version).parse(p)\n                elif subType == HandshakeType.finished:\n                    yield Finished(self.version).parse(p)\n                elif subType == HandshakeType.next_protocol:\n                    yield NextProtocol().parse(p)\n                else:\n                    raise AssertionError()\n\n        #If an exception was raised by a Parser or Message instance:\n        except SyntaxError as e:\n            for result in self._sendError(AlertDescription.decode_error,\n                                         formatExceptionTrace(e)):\n                yield result\n\n\n    #Returns next record or next handshake message\n    def _getNextRecord(self):\n\n        #If there's a handshake message waiting, return it\n        if self._handshakeBuffer:\n            recordHeader, b = self._handshakeBuffer[0]\n            self._handshakeBuffer = self._handshakeBuffer[1:]\n            yield (recordHeader, Parser(b))\n            return\n\n        #Otherwise...\n        #Read the next record header\n        b = bytearray(0)\n        recordHeaderLength = 1\n        ssl2 = False\n        while 1:\n            try:\n                s = self.sock.recv(recordHeaderLength-len(b))\n            except socket.error as why:\n                if why.args[0] in (errno.EWOULDBLOCK, errno.EAGAIN):\n                    yield 0\n                    continue\n                else:\n                    raise\n\n            #If the connection was abruptly closed, raise an error\n            if len(s)==0:\n                raise TLSAbruptCloseError()\n\n            b += bytearray(s)\n            if len(b)==1:\n                if b[0] in ContentType.all:\n                    ssl2 = False\n                    recordHeaderLength = 5\n                elif b[0] == 128:\n                    ssl2 = True\n                    recordHeaderLength = 2\n                else:\n                    raise SyntaxError()\n            if len(b) == recordHeaderLength:\n                break\n\n        #Parse the record header\n        if ssl2:\n            r = RecordHeader2().parse(Parser(b))\n        else:\n            r = RecordHeader3().parse(Parser(b))\n\n        #Check the record header fields\n        if r.length > 18432:\n            for result in self._sendError(AlertDescription.record_overflow):\n                yield result\n\n        #Read the record contents\n        b = bytearray(0)\n        while 1:\n            try:\n                s = self.sock.recv(r.length - len(b))\n            except socket.error as why:\n                if why.args[0] in (errno.EWOULDBLOCK, errno.EAGAIN):\n                    yield 0\n                    continue\n                else:\n                    raise\n\n            #If the connection is closed, raise a socket error\n            if len(s)==0:\n                    raise TLSAbruptCloseError()\n\n            b += bytearray(s)\n            if len(b) == r.length:\n                break\n\n        #Check the record header fields (2)\n        #We do this after reading the contents from the socket, so that\n        #if there's an error, we at least don't leave extra bytes in the\n        #socket..\n        #\n        # THIS CHECK HAS NO SECURITY RELEVANCE (?), BUT COULD HURT INTEROP.\n        # SO WE LEAVE IT OUT FOR NOW.\n        #\n        #if self._versionCheck and r.version != self.version:\n        #    for result in self._sendError(AlertDescription.protocol_version,\n        #            \"Version in header field: %s, should be %s\" % (str(r.version),\n        #                                                       str(self.version))):\n        #        yield result\n\n        #Decrypt the record\n        for result in self._decryptRecord(r.type, b):\n            if result in (0,1): yield result\n            else: break\n        b = result\n        p = Parser(b)\n\n        #If it doesn't contain handshake messages, we can just return it\n        if r.type != ContentType.handshake:\n            yield (r, p)\n        #If it's an SSLv2 ClientHello, we can return it as well\n        elif r.ssl2:\n            yield (r, p)\n        else:\n            #Otherwise, we loop through and add the handshake messages to the\n            #handshake buffer\n            while 1:\n                if p.index == len(b): #If we're at the end\n                    if not self._handshakeBuffer:\n                        for result in self._sendError(\\\n                                AlertDescription.decode_error, \\\n                                \"Received empty handshake record\"):\n                            yield result\n                    break\n                #There needs to be at least 4 bytes to get a header\n                if p.index+4 > len(b):\n                    for result in self._sendError(\\\n                            AlertDescription.decode_error,\n                            \"A record has a partial handshake message (1)\"):\n                        yield result\n                p.get(1) # skip handshake type\n                msgLength = p.get(3)\n                if p.index+msgLength > len(b):\n                    for result in self._sendError(\\\n                            AlertDescription.decode_error,\n                            \"A record has a partial handshake message (2)\"):\n                        yield result\n\n                handshakePair = (r, b[p.index-4 : p.index+msgLength])\n                self._handshakeBuffer.append(handshakePair)\n                p.index += msgLength\n\n            #We've moved at least one handshake message into the\n            #handshakeBuffer, return the first one\n            recordHeader, b = self._handshakeBuffer[0]\n            self._handshakeBuffer = self._handshakeBuffer[1:]\n            yield (recordHeader, Parser(b))\n\n\n    def _decryptRecord(self, recordType, b):\n        if self._readState.encContext:\n\n            #Decrypt if it's a block cipher\n            if self._readState.encContext.isBlockCipher:\n                blockLength = self._readState.encContext.block_size\n                if len(b) % blockLength != 0:\n                    for result in self._sendError(\\\n                            AlertDescription.decryption_failed,\n                            \"Encrypted data not a multiple of blocksize\"):\n                        yield result\n                b = self._readState.encContext.decrypt(b)\n                if self.version >= (3,2): #For TLS 1.1, remove explicit IV\n                    b = b[self._readState.encContext.block_size : ]\n\n                #Check padding\n                paddingGood = True\n                paddingLength = b[-1]\n                if (paddingLength+1) > len(b):\n                    paddingGood=False\n                    totalPaddingLength = 0\n                else:\n                    if self.version == (3,0):\n                        totalPaddingLength = paddingLength+1\n                    elif self.version in ((3,1), (3,2), (3,3)):\n                        totalPaddingLength = paddingLength+1\n                        paddingBytes = b[-totalPaddingLength:-1]\n                        for byte in paddingBytes:\n                            if byte != paddingLength:\n                                paddingGood = False\n                                totalPaddingLength = 0\n                    else:\n                        raise AssertionError()\n\n            #Decrypt if it's a stream cipher\n            else:\n                paddingGood = True\n                b = self._readState.encContext.decrypt(b)\n                totalPaddingLength = 0\n\n            #Check MAC\n            macGood = True\n            macLength = self._readState.macContext.digest_size\n            endLength = macLength + totalPaddingLength\n            if endLength > len(b):\n                macGood = False\n            else:\n                #Read MAC\n                startIndex = len(b) - endLength\n                endIndex = startIndex + macLength\n                checkBytes = b[startIndex : endIndex]\n\n                #Calculate MAC\n                seqnumBytes = self._readState.getSeqNumBytes()\n                b = b[:-endLength]\n                mac = self._readState.macContext.copy()\n                mac.update(compatHMAC(seqnumBytes))\n                mac.update(compatHMAC(bytearray([recordType])))\n                if self.version == (3,0):\n                    mac.update( compatHMAC(bytearray( [len(b)//256] ) ))\n                    mac.update( compatHMAC(bytearray( [len(b)%256] ) ))\n                elif self.version in ((3,1), (3,2), (3,3)):\n                    mac.update(compatHMAC(bytearray( [self.version[0]] ) ))\n                    mac.update(compatHMAC(bytearray( [self.version[1]] ) ))\n                    mac.update(compatHMAC(bytearray( [len(b)//256] ) ))\n                    mac.update(compatHMAC(bytearray( [len(b)%256] ) ))\n                else:\n                    raise AssertionError()\n                mac.update(compatHMAC(b))\n                macBytes = bytearray(mac.digest())\n\n                #Compare MACs\n                if macBytes != checkBytes:\n                    macGood = False\n\n            if not (paddingGood and macGood):\n                for result in self._sendError(AlertDescription.bad_record_mac,\n                                          \"MAC failure (or padding failure)\"):\n                    yield result\n\n        yield b\n\n    def _handshakeStart(self, client):\n        if not self.closed:\n            raise ValueError(\"Renegotiation disallowed for security reasons\")\n        self._client = client\n        self._handshake_md5 = hashlib.md5()\n        self._handshake_sha = hashlib.sha1()\n        self._handshake_sha256 = hashlib.sha256()\n        self._handshakeBuffer = []\n        self.allegedSrpUsername = None\n        self._refCount = 1\n\n    def _handshakeDone(self, resumed):\n        self.resumed = resumed\n        self.closed = False\n\n    def _calcPendingStates(self, cipherSuite, masterSecret,\n            clientRandom, serverRandom, implementations):\n        if cipherSuite in CipherSuite.aes128Suites:\n            keyLength = 16\n            ivLength = 16\n            createCipherFunc = createAES\n        elif cipherSuite in CipherSuite.aes256Suites:\n            keyLength = 32\n            ivLength = 16\n            createCipherFunc = createAES\n        elif cipherSuite in CipherSuite.rc4Suites:\n            keyLength = 16\n            ivLength = 0\n            createCipherFunc = createRC4\n        elif cipherSuite in CipherSuite.tripleDESSuites:\n            keyLength = 24\n            ivLength = 8\n            createCipherFunc = createTripleDES\n        else:\n            raise AssertionError()\n            \n        if cipherSuite in CipherSuite.shaSuites:\n            macLength = 20\n            digestmod = hashlib.sha1        \n        elif cipherSuite in CipherSuite.sha256Suites:\n            macLength = 32\n            digestmod = hashlib.sha256\n        elif cipherSuite in CipherSuite.md5Suites:\n            macLength = 16\n            digestmod = hashlib.md5\n\n        if self.version == (3,0):\n            createMACFunc = createMAC_SSL\n        elif self.version in ((3,1), (3,2), (3,3)):\n            createMACFunc = createHMAC\n\n        outputLength = (macLength*2) + (keyLength*2) + (ivLength*2)\n\n        #Calculate Keying Material from Master Secret\n        if self.version == (3,0):\n            keyBlock = PRF_SSL(masterSecret,\n                               serverRandom + clientRandom,\n                               outputLength)\n        elif self.version in ((3,1), (3,2)):\n            keyBlock = PRF(masterSecret,\n                           b\"key expansion\",\n                           serverRandom + clientRandom,\n                           outputLength)\n        elif self.version == (3,3):\n            keyBlock = PRF_1_2(masterSecret,\n                           b\"key expansion\",\n                           serverRandom + clientRandom,\n                           outputLength)\n        else:\n            raise AssertionError()\n\n        #Slice up Keying Material\n        clientPendingState = _ConnectionState()\n        serverPendingState = _ConnectionState()\n        p = Parser(keyBlock)\n        clientMACBlock = p.getFixBytes(macLength)\n        serverMACBlock = p.getFixBytes(macLength)\n        clientKeyBlock = p.getFixBytes(keyLength)\n        serverKeyBlock = p.getFixBytes(keyLength)\n        clientIVBlock  = p.getFixBytes(ivLength)\n        serverIVBlock  = p.getFixBytes(ivLength)\n        clientPendingState.macContext = createMACFunc(\n            compatHMAC(clientMACBlock), digestmod=digestmod)\n        serverPendingState.macContext = createMACFunc(\n            compatHMAC(serverMACBlock), digestmod=digestmod)\n        clientPendingState.encContext = createCipherFunc(clientKeyBlock,\n                                                         clientIVBlock,\n                                                         implementations)\n        serverPendingState.encContext = createCipherFunc(serverKeyBlock,\n                                                         serverIVBlock,\n                                                         implementations)\n\n        #Assign new connection states to pending states\n        if self._client:\n            self._pendingWriteState = clientPendingState\n            self._pendingReadState = serverPendingState\n        else:\n            self._pendingWriteState = serverPendingState\n            self._pendingReadState = clientPendingState\n\n        if self.version >= (3,2) and ivLength:\n            #Choose fixedIVBlock for TLS 1.1 (this is encrypted with the CBC\n            #residue to create the IV for each sent block)\n            self.fixedIVBlock = getRandomBytes(ivLength)\n\n    def _changeWriteState(self):\n        self._writeState = self._pendingWriteState\n        self._pendingWriteState = _ConnectionState()\n\n    def _changeReadState(self):\n        self._readState = self._pendingReadState\n        self._pendingReadState = _ConnectionState()\n\n    #Used for Finished messages and CertificateVerify messages in SSL v3\n    def _calcSSLHandshakeHash(self, masterSecret, label):\n        imac_md5 = self._handshake_md5.copy()\n        imac_sha = self._handshake_sha.copy()\n\n        imac_md5.update(compatHMAC(label + masterSecret + bytearray([0x36]*48)))\n        imac_sha.update(compatHMAC(label + masterSecret + bytearray([0x36]*40)))\n\n        md5Bytes = MD5(masterSecret + bytearray([0x5c]*48) + \\\n                         bytearray(imac_md5.digest()))\n        shaBytes = SHA1(masterSecret + bytearray([0x5c]*40) + \\\n                         bytearray(imac_sha.digest()))\n\n        return md5Bytes + shaBytes\n\n"], "fixing_code": ["# Authors: \n#   Trevor Perrin\n#   Google (adapted by Sam Rushing) - NPN support\n#   Google - minimal padding\n#   Martin von Loewis - python 3 port\n#   Yngve Pettersen (ported by Paul Sokolovsky) - TLS 1.2\n#\n# See the LICENSE file for legal information regarding use of this file.\n\n\"\"\"Helper class for TLSConnection.\"\"\"\nfrom __future__ import generators\n\nfrom .utils.compat import *\nfrom .utils.cryptomath import *\nfrom .utils.cipherfactory import createAES, createRC4, createTripleDES\nfrom .utils.codec import *\nfrom .errors import *\nfrom .messages import *\nfrom .mathtls import *\nfrom .constants import *\nfrom .utils.cryptomath import getRandomBytes\n\nimport socket\nimport errno\nimport traceback\n\nclass _ConnectionState(object):\n    def __init__(self):\n        self.macContext = None\n        self.encContext = None\n        self.seqnum = 0\n\n    def getSeqNumBytes(self):\n        w = Writer()\n        w.add(self.seqnum, 8)\n        self.seqnum += 1\n        return w.bytes\n\n\nclass TLSRecordLayer(object):\n    \"\"\"\n    This class handles data transmission for a TLS connection.\n\n    Its only subclass is L{tlslite.TLSConnection.TLSConnection}.  We've\n    separated the code in this class from TLSConnection to make things\n    more readable.\n\n\n    @type sock: socket.socket\n    @ivar sock: The underlying socket object.\n\n    @type session: L{tlslite.Session.Session}\n    @ivar session: The session corresponding to this connection.\n\n    Due to TLS session resumption, multiple connections can correspond\n    to the same underlying session.\n\n    @type version: tuple\n    @ivar version: The TLS version being used for this connection.\n\n    (3,0) means SSL 3.0, and (3,1) means TLS 1.0.\n\n    @type closed: bool\n    @ivar closed: If this connection is closed.\n\n    @type resumed: bool\n    @ivar resumed: If this connection is based on a resumed session.\n\n    @type allegedSrpUsername: str or None\n    @ivar allegedSrpUsername:  This is set to the SRP username\n    asserted by the client, whether the handshake succeeded or not.\n    If the handshake fails, this can be inspected to determine\n    if a guessing attack is in progress against a particular user\n    account.\n\n    @type closeSocket: bool\n    @ivar closeSocket: If the socket should be closed when the\n    connection is closed, defaults to True (writable).\n\n    If you set this to True, TLS Lite will assume the responsibility of\n    closing the socket when the TLS Connection is shutdown (either\n    through an error or through the user calling close()).  The default\n    is False.\n\n    @type ignoreAbruptClose: bool\n    @ivar ignoreAbruptClose: If an abrupt close of the socket should\n    raise an error (writable).\n\n    If you set this to True, TLS Lite will not raise a\n    L{tlslite.errors.TLSAbruptCloseError} exception if the underlying\n    socket is unexpectedly closed.  Such an unexpected closure could be\n    caused by an attacker.  However, it also occurs with some incorrect\n    TLS implementations.\n\n    You should set this to True only if you're not worried about an\n    attacker truncating the connection, and only if necessary to avoid\n    spurious errors.  The default is False.\n\n    @sort: __init__, read, readAsync, write, writeAsync, close, closeAsync,\n    getCipherImplementation, getCipherName\n    \"\"\"\n\n    def __init__(self, sock):\n        self.sock = sock\n\n        #My session object (Session instance; read-only)\n        self.session = None\n\n        #Am I a client or server?\n        self._client = None\n\n        #Buffers for processing messages\n        self._handshakeBuffer = []\n        self.clearReadBuffer()\n        self.clearWriteBuffer()\n\n        #Handshake digests\n        self._handshake_md5 = hashlib.md5()\n        self._handshake_sha = hashlib.sha1()\n        self._handshake_sha256 = hashlib.sha256()\n\n        #TLS Protocol Version\n        self.version = (0,0) #read-only\n        self._versionCheck = False #Once we choose a version, this is True\n\n        #Current and Pending connection states\n        self._writeState = _ConnectionState()\n        self._readState = _ConnectionState()\n        self._pendingWriteState = _ConnectionState()\n        self._pendingReadState = _ConnectionState()\n\n        #Is the connection open?\n        self.closed = True #read-only\n        self._refCount = 0 #Used to trigger closure\n\n        #Is this a resumed session?\n        self.resumed = False #read-only\n\n        #What username did the client claim in his handshake?\n        self.allegedSrpUsername = None\n\n        #On a call to close(), do we close the socket? (writeable)\n        self.closeSocket = True\n\n        #If the socket is abruptly closed, do we ignore it\n        #and pretend the connection was shut down properly? (writeable)\n        self.ignoreAbruptClose = False\n\n        #Fault we will induce, for testing purposes\n        self.fault = None\n\n    def clearReadBuffer(self):\n        self._readBuffer = b''\n\n    def clearWriteBuffer(self):\n        self._send_writer = None\n\n\n    #*********************************************************\n    # Public Functions START\n    #*********************************************************\n\n    def read(self, max=None, min=1):\n        \"\"\"Read some data from the TLS connection.\n\n        This function will block until at least 'min' bytes are\n        available (or the connection is closed).\n\n        If an exception is raised, the connection will have been\n        automatically closed.\n\n        @type max: int\n        @param max: The maximum number of bytes to return.\n\n        @type min: int\n        @param min: The minimum number of bytes to return\n\n        @rtype: str\n        @return: A string of no more than 'max' bytes, and no fewer\n        than 'min' (unless the connection has been closed, in which\n        case fewer than 'min' bytes may be returned).\n\n        @raise socket.error: If a socket error occurs.\n        @raise tlslite.errors.TLSAbruptCloseError: If the socket is closed\n        without a preceding alert.\n        @raise tlslite.errors.TLSAlert: If a TLS alert is signalled.\n        \"\"\"\n        for result in self.readAsync(max, min):\n            pass\n        return result\n\n    def readAsync(self, max=None, min=1):\n        \"\"\"Start a read operation on the TLS connection.\n\n        This function returns a generator which behaves similarly to\n        read().  Successive invocations of the generator will return 0\n        if it is waiting to read from the socket, 1 if it is waiting\n        to write to the socket, or a string if the read operation has\n        completed.\n\n        @rtype: iterable\n        @return: A generator; see above for details.\n        \"\"\"\n        try:\n            while len(self._readBuffer)<min and not self.closed:\n                try:\n                    for result in self._getMsg(ContentType.application_data):\n                        if result in (0,1):\n                            yield result\n                    applicationData = result\n                    self._readBuffer += applicationData.write()\n                except TLSRemoteAlert as alert:\n                    if alert.description != AlertDescription.close_notify:\n                        raise\n                except TLSAbruptCloseError:\n                    if not self.ignoreAbruptClose:\n                        raise\n                    else:\n                        self._shutdown(True)\n\n            if max == None:\n                max = len(self._readBuffer)\n\n            returnBytes = self._readBuffer[:max]\n            self._readBuffer = self._readBuffer[max:]\n            yield bytes(returnBytes)\n        except GeneratorExit:\n            raise\n        except:\n            self._shutdown(False)\n            raise\n\n    def unread(self, b):\n        \"\"\"Add bytes to the front of the socket read buffer for future\n        reading. Be careful using this in the context of select(...): if you\n        unread the last data from a socket, that won't wake up selected waiters,\n        and those waiters may hang forever.\n        \"\"\"\n        self._readBuffer = b + self._readBuffer\n\n    def write(self, s):\n        \"\"\"Write some data to the TLS connection.\n\n        This function will block until all the data has been sent.\n\n        If an exception is raised, the connection will have been\n        automatically closed.\n\n        @type s: str\n        @param s: The data to transmit to the other party.\n\n        @raise socket.error: If a socket error occurs.\n        \"\"\"\n        for result in self.writeAsync(s):\n            pass\n\n    def writeAsync(self, s):\n        \"\"\"Start a write operation on the TLS connection.\n\n        This function returns a generator which behaves similarly to\n        write().  Successive invocations of the generator will return\n        1 if it is waiting to write to the socket, or will raise\n        StopIteration if the write operation has completed.\n\n        @rtype: iterable\n        @return: A generator; see above for details.\n        \"\"\"\n        try:\n            if self.closed:\n                raise TLSClosedConnectionError(\"attempt to write to closed connection\")\n\n            index = 0\n            blockSize = 16384\n            randomizeFirstBlock = True\n            while 1:\n                startIndex = index * blockSize\n                endIndex = startIndex + blockSize\n                if startIndex >= len(s):\n                    break\n                if endIndex > len(s):\n                    endIndex = len(s)\n                block = bytearray(s[startIndex : endIndex])\n                applicationData = ApplicationData().create(block)\n                for result in self._sendMsg(applicationData, \\\n                                            randomizeFirstBlock):\n                    yield result\n                randomizeFirstBlock = False #only on 1st message\n                index += 1\n        except GeneratorExit:\n            raise\n        except Exception:\n            # Don't invalidate the session on write failure if abrupt closes are\n            # okay.\n            self._shutdown(self.ignoreAbruptClose)\n            raise\n\n    def close(self):\n        \"\"\"Close the TLS connection.\n\n        This function will block until it has exchanged close_notify\n        alerts with the other party.  After doing so, it will shut down the\n        TLS connection.  Further attempts to read through this connection\n        will return \"\".  Further attempts to write through this connection\n        will raise ValueError.\n\n        If makefile() has been called on this connection, the connection\n        will be not be closed until the connection object and all file\n        objects have been closed.\n\n        Even if an exception is raised, the connection will have been\n        closed.\n\n        @raise socket.error: If a socket error occurs.\n        @raise tlslite.errors.TLSAbruptCloseError: If the socket is closed\n        without a preceding alert.\n        @raise tlslite.errors.TLSAlert: If a TLS alert is signalled.\n        \"\"\"\n        if not self.closed:\n            for result in self._decrefAsync():\n                pass\n\n    # Python 3 callback\n    _decref_socketios = close\n\n    def closeAsync(self):\n        \"\"\"Start a close operation on the TLS connection.\n\n        This function returns a generator which behaves similarly to\n        close().  Successive invocations of the generator will return 0\n        if it is waiting to read from the socket, 1 if it is waiting\n        to write to the socket, or will raise StopIteration if the\n        close operation has completed.\n\n        @rtype: iterable\n        @return: A generator; see above for details.\n        \"\"\"\n        if not self.closed:\n            for result in self._decrefAsync():\n                yield result\n\n    def _decrefAsync(self):\n        self._refCount -= 1\n        if self._refCount == 0 and not self.closed:\n            try:\n                for result in self._sendMsg(Alert().create(\\\n                        AlertDescription.close_notify, AlertLevel.warning)):\n                    yield result\n                alert = None\n                # By default close the socket, since it's been observed\n                # that some other libraries will not respond to the \n                # close_notify alert, thus leaving us hanging if we're\n                # expecting it\n                if self.closeSocket:\n                    self._shutdown(True)\n                else:\n                    while not alert:\n                        for result in self._getMsg((ContentType.alert, \\\n                                                  ContentType.application_data)):\n                            if result in (0,1):\n                                yield result\n                        if result.contentType == ContentType.alert:\n                            alert = result\n                    if alert.description == AlertDescription.close_notify:\n                        self._shutdown(True)\n                    else:\n                        raise TLSRemoteAlert(alert)\n            except (socket.error, TLSAbruptCloseError):\n                #If the other side closes the socket, that's okay\n                self._shutdown(True)\n            except GeneratorExit:\n                raise\n            except:\n                self._shutdown(False)\n                raise\n\n    def getVersionName(self):\n        \"\"\"Get the name of this TLS version.\n\n        @rtype: str\n        @return: The name of the TLS version used with this connection.\n        Either None, 'SSL 3.0', 'TLS 1.0', 'TLS 1.1', or 'TLS 1.2'.\n        \"\"\"\n        if self.version == (3,0):\n            return \"SSL 3.0\"\n        elif self.version == (3,1):\n            return \"TLS 1.0\"\n        elif self.version == (3,2):\n            return \"TLS 1.1\"\n        elif self.version == (3,3):\n            return \"TLS 1.2\"\n        else:\n            return None\n        \n    def getCipherName(self):\n        \"\"\"Get the name of the cipher used with this connection.\n\n        @rtype: str\n        @return: The name of the cipher used with this connection.\n        Either 'aes128', 'aes256', 'rc4', or '3des'.\n        \"\"\"\n        if not self._writeState.encContext:\n            return None\n        return self._writeState.encContext.name\n\n    def getCipherImplementation(self):\n        \"\"\"Get the name of the cipher implementation used with\n        this connection.\n\n        @rtype: str\n        @return: The name of the cipher implementation used with\n        this connection.  Either 'python', 'openssl', or 'pycrypto'.\n        \"\"\"\n        if not self._writeState.encContext:\n            return None\n        return self._writeState.encContext.implementation\n\n\n\n    #Emulate a socket, somewhat -\n    def send(self, s):\n        \"\"\"Send data to the TLS connection (socket emulation).\n\n        @raise socket.error: If a socket error occurs.\n        \"\"\"\n        self.write(s)\n        return len(s)\n\n    def sendall(self, s):\n        \"\"\"Send data to the TLS connection (socket emulation).\n\n        @raise socket.error: If a socket error occurs.\n        \"\"\"\n        self.write(s)\n\n    def recv(self, bufsize):\n        \"\"\"Get some data from the TLS connection (socket emulation).\n\n        @raise socket.error: If a socket error occurs.\n        @raise tlslite.errors.TLSAbruptCloseError: If the socket is closed\n        without a preceding alert.\n        @raise tlslite.errors.TLSAlert: If a TLS alert is signalled.\n        \"\"\"\n        return self.read(bufsize)\n\n    def recv_into(self, b):\n        # XXX doc string\n        data = self.read(len(b))\n        if not data:\n            return None\n        b[:len(data)] = data\n        return len(data)\n\n    def makefile(self, mode='r', bufsize=-1):\n        \"\"\"Create a file object for the TLS connection (socket emulation).\n\n        @rtype: L{socket._fileobject}\n        \"\"\"\n        self._refCount += 1\n        # So, it is pretty fragile to be using Python internal objects\n        # like this, but it is probably the best/easiest way to provide\n        # matching behavior for socket emulation purposes.  The 'close'\n        # argument is nice, its apparently a recent addition to this\n        # class, so that when fileobject.close() gets called, it will\n        # close() us, causing the refcount to be decremented (decrefAsync).\n        #\n        # If this is the last close() on the outstanding fileobjects / \n        # TLSConnection, then the \"actual\" close alerts will be sent,\n        # socket closed, etc.\n        if sys.version_info < (3,):\n            return socket._fileobject(self, mode, bufsize, close=True)\n        else:\n            # XXX need to wrap this further if buffering is requested\n            return socket.SocketIO(self, mode)\n\n    def getsockname(self):\n        \"\"\"Return the socket's own address (socket emulation).\"\"\"\n        return self.sock.getsockname()\n\n    def getpeername(self):\n        \"\"\"Return the remote address to which the socket is connected\n        (socket emulation).\"\"\"\n        return self.sock.getpeername()\n\n    def settimeout(self, value):\n        \"\"\"Set a timeout on blocking socket operations (socket emulation).\"\"\"\n        return self.sock.settimeout(value)\n\n    def gettimeout(self):\n        \"\"\"Return the timeout associated with socket operations (socket\n        emulation).\"\"\"\n        return self.sock.gettimeout()\n\n    def setsockopt(self, level, optname, value):\n        \"\"\"Set the value of the given socket option (socket emulation).\"\"\"\n        return self.sock.setsockopt(level, optname, value)\n\n    def shutdown(self, how):\n        \"\"\"Shutdown the underlying socket.\"\"\"\n        return self.sock.shutdown(how)\n    \t\n    def fileno(self):\n        \"\"\"Not implement in TLS Lite.\"\"\"\n        raise NotImplementedError()\n    \t\n\n     #*********************************************************\n     # Public Functions END\n     #*********************************************************\n\n    def _shutdown(self, resumable):\n        self._writeState = _ConnectionState()\n        self._readState = _ConnectionState()\n        self.version = (0,0)\n        self._versionCheck = False\n        self.closed = True\n        if self.closeSocket:\n            self.sock.close()\n\n        #Even if resumable is False, we'll never toggle this on\n        if not resumable and self.session:\n            self.session.resumable = False\n\n\n    def _sendError(self, alertDescription, errorStr=None):\n        alert = Alert().create(alertDescription, AlertLevel.fatal)\n        for result in self._sendMsg(alert):\n            yield result\n        self._shutdown(False)\n        raise TLSLocalAlert(alert, errorStr)\n\n    def _sendMsgs(self, msgs):\n        randomizeFirstBlock = True\n        for msg in msgs:\n            for result in self._sendMsg(msg, randomizeFirstBlock):\n                yield result\n            randomizeFirstBlock = True\n\n    def _sendMsg(self, msg, randomizeFirstBlock = True):\n        #Whenever we're connected and asked to send an app data message,\n        #we first send the first byte of the message.  This prevents\n        #an attacker from launching a chosen-plaintext attack based on\n        #knowing the next IV (a la BEAST).\n        if not self.closed and randomizeFirstBlock and self.version <= (3,1) \\\n                and self._writeState.encContext \\\n                and self._writeState.encContext.isBlockCipher \\\n                and isinstance(msg, ApplicationData):\n            msgFirstByte = msg.splitFirstByte()\n            for result in self._sendMsg(msgFirstByte,\n                                       randomizeFirstBlock = False):\n                yield result                                            \n\n        b = msg.write()\n        \n        # If a 1-byte message was passed in, and we \"split\" the \n        # first(only) byte off above, we may have a 0-length msg:\n        if len(b) == 0:\n            return\n            \n        contentType = msg.contentType\n\n        #Update handshake hashes\n        if contentType == ContentType.handshake:\n            self._handshake_md5.update(compat26Str(b))\n            self._handshake_sha.update(compat26Str(b))\n            self._handshake_sha256.update(compat26Str(b))\n\n        #Calculate MAC\n        if self._writeState.macContext:\n            seqnumBytes = self._writeState.getSeqNumBytes()\n            mac = self._writeState.macContext.copy()\n            mac.update(compatHMAC(seqnumBytes))\n            mac.update(compatHMAC(bytearray([contentType])))\n            if self.version == (3,0):\n                mac.update( compatHMAC( bytearray([len(b)//256] )))\n                mac.update( compatHMAC( bytearray([len(b)%256] )))\n            elif self.version in ((3,1), (3,2), (3,3)):\n                mac.update(compatHMAC( bytearray([self.version[0]] )))\n                mac.update(compatHMAC( bytearray([self.version[1]] )))\n                mac.update( compatHMAC( bytearray([len(b)//256] )))\n                mac.update( compatHMAC( bytearray([len(b)%256] )))\n            else:\n                raise AssertionError()\n            mac.update(compatHMAC(b))\n            macBytes = bytearray(mac.digest())\n            if self.fault == Fault.badMAC:\n                macBytes[0] = (macBytes[0]+1) % 256\n\n        #Encrypt for Block or Stream Cipher\n        if self._writeState.encContext:\n            #Add padding and encrypt (for Block Cipher):\n            if self._writeState.encContext.isBlockCipher:\n\n                #Add TLS 1.1 fixed block\n                if self.version >= (3,2):\n                    b = self.fixedIVBlock + b\n\n                #Add padding: b = b+ (macBytes + paddingBytes)\n                currentLength = len(b) + len(macBytes)\n                blockLength = self._writeState.encContext.block_size\n                paddingLength = blockLength - 1 - (currentLength % blockLength)\n\n                paddingBytes = bytearray([paddingLength] * (paddingLength+1))\n                if self.fault == Fault.badPadding:\n                    paddingBytes[0] = (paddingBytes[0]+1) % 256\n                endBytes = macBytes + paddingBytes\n                b += endBytes\n                #Encrypt\n                b = self._writeState.encContext.encrypt(b)\n\n            #Encrypt (for Stream Cipher)\n            else:\n                b += macBytes\n                b = self._writeState.encContext.encrypt(b)\n\n        #Add record header and send\n        r = RecordHeader3().create(self.version, contentType, len(b))\n        s = r.write() + b\n        while 1:\n            try:\n                bytesSent = self.sock.send(s) #Might raise socket.error\n            except socket.error as why:\n                if why.args[0] in (errno.EWOULDBLOCK, errno.EAGAIN):\n                    yield 1\n                    continue\n                else:\n                    # The socket was unexpectedly closed.  The tricky part\n                    # is that there may be an alert sent by the other party\n                    # sitting in the read buffer.  So, if we get here after\n                    # handshaking, we will just raise the error and let the\n                    # caller read more data if it would like, thus stumbling\n                    # upon the error.\n                    #\n                    # However, if we get here DURING handshaking, we take\n                    # it upon ourselves to see if the next message is an \n                    # Alert.\n                    if contentType == ContentType.handshake:\n                        \n                        # See if there's an alert record\n                        # Could raise socket.error or TLSAbruptCloseError\n                        for result in self._getNextRecord():\n                            if result in (0,1):\n                                yield result\n                                \n                        # Closes the socket\n                        self._shutdown(False)\n                        \n                        # If we got an alert, raise it        \n                        recordHeader, p = result                        \n                        if recordHeader.type == ContentType.alert:\n                            alert = Alert().parse(p)\n                            raise TLSRemoteAlert(alert)\n                    else:\n                        # If we got some other message who know what\n                        # the remote side is doing, just go ahead and\n                        # raise the socket.error\n                        raise\n            if bytesSent == len(s):\n                return\n            s = s[bytesSent:]\n            yield 1\n\n\n    def _getMsg(self, expectedType, secondaryType=None, constructorType=None):\n        try:\n            if not isinstance(expectedType, tuple):\n                expectedType = (expectedType,)\n\n            #Spin in a loop, until we've got a non-empty record of a type we\n            #expect.  The loop will be repeated if:\n            #  - we receive a renegotiation attempt; we send no_renegotiation,\n            #    then try again\n            #  - we receive an empty application-data fragment; we try again\n            while 1:\n                for result in self._getNextRecord():\n                    if result in (0,1):\n                        yield result\n                recordHeader, p = result\n\n                #If this is an empty application-data fragment, try again\n                if recordHeader.type == ContentType.application_data:\n                    if p.index == len(p.bytes):\n                        continue\n\n                #If we received an unexpected record type...\n                if recordHeader.type not in expectedType:\n\n                    #If we received an alert...\n                    if recordHeader.type == ContentType.alert:\n                        alert = Alert().parse(p)\n\n                        #We either received a fatal error, a warning, or a\n                        #close_notify.  In any case, we're going to close the\n                        #connection.  In the latter two cases we respond with\n                        #a close_notify, but ignore any socket errors, since\n                        #the other side might have already closed the socket.\n                        if alert.level == AlertLevel.warning or \\\n                           alert.description == AlertDescription.close_notify:\n\n                            #If the sendMsg() call fails because the socket has\n                            #already been closed, we will be forgiving and not\n                            #report the error nor invalidate the \"resumability\"\n                            #of the session.\n                            try:\n                                alertMsg = Alert()\n                                alertMsg.create(AlertDescription.close_notify,\n                                                AlertLevel.warning)\n                                for result in self._sendMsg(alertMsg):\n                                    yield result\n                            except socket.error:\n                                pass\n\n                            if alert.description == \\\n                                   AlertDescription.close_notify:\n                                self._shutdown(True)\n                            elif alert.level == AlertLevel.warning:\n                                self._shutdown(False)\n\n                        else: #Fatal alert:\n                            self._shutdown(False)\n\n                        #Raise the alert as an exception\n                        raise TLSRemoteAlert(alert)\n\n                    #If we received a renegotiation attempt...\n                    if recordHeader.type == ContentType.handshake:\n                        subType = p.get(1)\n                        reneg = False\n                        if self._client:\n                            if subType == HandshakeType.hello_request:\n                                reneg = True\n                        else:\n                            if subType == HandshakeType.client_hello:\n                                reneg = True\n                        #Send no_renegotiation, then try again\n                        if reneg:\n                            alertMsg = Alert()\n                            alertMsg.create(AlertDescription.no_renegotiation,\n                                            AlertLevel.warning)\n                            for result in self._sendMsg(alertMsg):\n                                yield result\n                            continue\n\n                    #Otherwise: this is an unexpected record, but neither an\n                    #alert nor renegotiation\n                    for result in self._sendError(\\\n                            AlertDescription.unexpected_message,\n                            \"received type=%d\" % recordHeader.type):\n                        yield result\n\n                break\n\n            #Parse based on content_type\n            if recordHeader.type == ContentType.change_cipher_spec:\n                yield ChangeCipherSpec().parse(p)\n            elif recordHeader.type == ContentType.alert:\n                yield Alert().parse(p)\n            elif recordHeader.type == ContentType.application_data:\n                yield ApplicationData().parse(p)\n            elif recordHeader.type == ContentType.handshake:\n                #Convert secondaryType to tuple, if it isn't already\n                if not isinstance(secondaryType, tuple):\n                    secondaryType = (secondaryType,)\n\n                #If it's a handshake message, check handshake header\n                if recordHeader.ssl2:\n                    subType = p.get(1)\n                    if subType != HandshakeType.client_hello:\n                        for result in self._sendError(\\\n                                AlertDescription.unexpected_message,\n                                \"Can only handle SSLv2 ClientHello messages\"):\n                            yield result\n                    if HandshakeType.client_hello not in secondaryType:\n                        for result in self._sendError(\\\n                                AlertDescription.unexpected_message):\n                            yield result\n                    subType = HandshakeType.client_hello\n                else:\n                    subType = p.get(1)\n                    if subType not in secondaryType:\n                        for result in self._sendError(\\\n                                AlertDescription.unexpected_message,\n                                \"Expecting %s, got %s\" % (str(secondaryType), subType)):\n                            yield result\n\n                #Update handshake hashes\n                self._handshake_md5.update(compat26Str(p.bytes))\n                self._handshake_sha.update(compat26Str(p.bytes))\n                self._handshake_sha256.update(compat26Str(p.bytes))\n\n                #Parse based on handshake type\n                if subType == HandshakeType.client_hello:\n                    yield ClientHello(recordHeader.ssl2).parse(p)\n                elif subType == HandshakeType.server_hello:\n                    yield ServerHello().parse(p)\n                elif subType == HandshakeType.certificate:\n                    yield Certificate(constructorType).parse(p)\n                elif subType == HandshakeType.certificate_request:\n                    yield CertificateRequest(self.version).parse(p)\n                elif subType == HandshakeType.certificate_verify:\n                    yield CertificateVerify(self.version).parse(p)\n                elif subType == HandshakeType.server_key_exchange:\n                    yield ServerKeyExchange(constructorType).parse(p)\n                elif subType == HandshakeType.server_hello_done:\n                    yield ServerHelloDone().parse(p)\n                elif subType == HandshakeType.client_key_exchange:\n                    yield ClientKeyExchange(constructorType, \\\n                                            self.version).parse(p)\n                elif subType == HandshakeType.finished:\n                    yield Finished(self.version).parse(p)\n                elif subType == HandshakeType.next_protocol:\n                    yield NextProtocol().parse(p)\n                else:\n                    raise AssertionError()\n\n        #If an exception was raised by a Parser or Message instance:\n        except SyntaxError as e:\n            for result in self._sendError(AlertDescription.decode_error,\n                                         formatExceptionTrace(e)):\n                yield result\n\n\n    #Returns next record or next handshake message\n    def _getNextRecord(self):\n\n        #If there's a handshake message waiting, return it\n        if self._handshakeBuffer:\n            recordHeader, b = self._handshakeBuffer[0]\n            self._handshakeBuffer = self._handshakeBuffer[1:]\n            yield (recordHeader, Parser(b))\n            return\n\n        #Otherwise...\n        #Read the next record header\n        b = bytearray(0)\n        recordHeaderLength = 1\n        ssl2 = False\n        while 1:\n            try:\n                s = self.sock.recv(recordHeaderLength-len(b))\n            except socket.error as why:\n                if why.args[0] in (errno.EWOULDBLOCK, errno.EAGAIN):\n                    yield 0\n                    continue\n                else:\n                    raise\n\n            #If the connection was abruptly closed, raise an error\n            if len(s)==0:\n                raise TLSAbruptCloseError()\n\n            b += bytearray(s)\n            if len(b)==1:\n                if b[0] in ContentType.all:\n                    ssl2 = False\n                    recordHeaderLength = 5\n                elif b[0] == 128:\n                    ssl2 = True\n                    recordHeaderLength = 2\n                else:\n                    raise SyntaxError()\n            if len(b) == recordHeaderLength:\n                break\n\n        #Parse the record header\n        if ssl2:\n            r = RecordHeader2().parse(Parser(b))\n        else:\n            r = RecordHeader3().parse(Parser(b))\n\n        #Check the record header fields\n        if r.length > 18432:\n            for result in self._sendError(AlertDescription.record_overflow):\n                yield result\n\n        #Read the record contents\n        b = bytearray(0)\n        while 1:\n            try:\n                s = self.sock.recv(r.length - len(b))\n            except socket.error as why:\n                if why.args[0] in (errno.EWOULDBLOCK, errno.EAGAIN):\n                    yield 0\n                    continue\n                else:\n                    raise\n\n            #If the connection is closed, raise a socket error\n            if len(s)==0:\n                    raise TLSAbruptCloseError()\n\n            b += bytearray(s)\n            if len(b) == r.length:\n                break\n\n        #Check the record header fields (2)\n        #We do this after reading the contents from the socket, so that\n        #if there's an error, we at least don't leave extra bytes in the\n        #socket..\n        #\n        # THIS CHECK HAS NO SECURITY RELEVANCE (?), BUT COULD HURT INTEROP.\n        # SO WE LEAVE IT OUT FOR NOW.\n        #\n        #if self._versionCheck and r.version != self.version:\n        #    for result in self._sendError(AlertDescription.protocol_version,\n        #            \"Version in header field: %s, should be %s\" % (str(r.version),\n        #                                                       str(self.version))):\n        #        yield result\n\n        #Decrypt the record\n        for result in self._decryptRecord(r.type, b):\n            if result in (0,1): yield result\n            else: break\n        b = result\n        p = Parser(b)\n\n        #If it doesn't contain handshake messages, we can just return it\n        if r.type != ContentType.handshake:\n            yield (r, p)\n        #If it's an SSLv2 ClientHello, we can return it as well\n        elif r.ssl2:\n            yield (r, p)\n        else:\n            #Otherwise, we loop through and add the handshake messages to the\n            #handshake buffer\n            while 1:\n                if p.index == len(b): #If we're at the end\n                    if not self._handshakeBuffer:\n                        for result in self._sendError(\\\n                                AlertDescription.decode_error, \\\n                                \"Received empty handshake record\"):\n                            yield result\n                    break\n                #There needs to be at least 4 bytes to get a header\n                if p.index+4 > len(b):\n                    for result in self._sendError(\\\n                            AlertDescription.decode_error,\n                            \"A record has a partial handshake message (1)\"):\n                        yield result\n                p.get(1) # skip handshake type\n                msgLength = p.get(3)\n                if p.index+msgLength > len(b):\n                    for result in self._sendError(\\\n                            AlertDescription.decode_error,\n                            \"A record has a partial handshake message (2)\"):\n                        yield result\n\n                handshakePair = (r, b[p.index-4 : p.index+msgLength])\n                self._handshakeBuffer.append(handshakePair)\n                p.index += msgLength\n\n            #We've moved at least one handshake message into the\n            #handshakeBuffer, return the first one\n            recordHeader, b = self._handshakeBuffer[0]\n            self._handshakeBuffer = self._handshakeBuffer[1:]\n            yield (recordHeader, Parser(b))\n\n\n    def _decryptRecord(self, recordType, b):\n        if self._readState.encContext:\n\n            #Decrypt if it's a block cipher\n            if self._readState.encContext.isBlockCipher:\n                blockLength = self._readState.encContext.block_size\n                if len(b) % blockLength != 0:\n                    for result in self._sendError(\\\n                            AlertDescription.decryption_failed,\n                            \"Encrypted data not a multiple of blocksize\"):\n                        yield result\n                b = self._readState.encContext.decrypt(b)\n                if self.version >= (3,2): #For TLS 1.1, remove explicit IV\n                    b = b[self._readState.encContext.block_size : ]\n\n                if len(b) == 0:\n                    for result in self._sendError(\\\n                            AlertDescription.decryption_failed,\n                            \"No data left after decryption and IV removal\"):\n                        yield result\n\n                #Check padding\n                paddingGood = True\n                paddingLength = b[-1]\n                if (paddingLength+1) > len(b):\n                    paddingGood=False\n                    totalPaddingLength = 0\n                else:\n                    if self.version == (3,0):\n                        totalPaddingLength = paddingLength+1\n                    elif self.version in ((3,1), (3,2), (3,3)):\n                        totalPaddingLength = paddingLength+1\n                        paddingBytes = b[-totalPaddingLength:-1]\n                        for byte in paddingBytes:\n                            if byte != paddingLength:\n                                paddingGood = False\n                                totalPaddingLength = 0\n                    else:\n                        raise AssertionError()\n\n            #Decrypt if it's a stream cipher\n            else:\n                paddingGood = True\n                b = self._readState.encContext.decrypt(b)\n                totalPaddingLength = 0\n\n            #Check MAC\n            macGood = True\n            macLength = self._readState.macContext.digest_size\n            endLength = macLength + totalPaddingLength\n            if endLength > len(b):\n                macGood = False\n            else:\n                #Read MAC\n                startIndex = len(b) - endLength\n                endIndex = startIndex + macLength\n                checkBytes = b[startIndex : endIndex]\n\n                #Calculate MAC\n                seqnumBytes = self._readState.getSeqNumBytes()\n                b = b[:-endLength]\n                mac = self._readState.macContext.copy()\n                mac.update(compatHMAC(seqnumBytes))\n                mac.update(compatHMAC(bytearray([recordType])))\n                if self.version == (3,0):\n                    mac.update( compatHMAC(bytearray( [len(b)//256] ) ))\n                    mac.update( compatHMAC(bytearray( [len(b)%256] ) ))\n                elif self.version in ((3,1), (3,2), (3,3)):\n                    mac.update(compatHMAC(bytearray( [self.version[0]] ) ))\n                    mac.update(compatHMAC(bytearray( [self.version[1]] ) ))\n                    mac.update(compatHMAC(bytearray( [len(b)//256] ) ))\n                    mac.update(compatHMAC(bytearray( [len(b)%256] ) ))\n                else:\n                    raise AssertionError()\n                mac.update(compatHMAC(b))\n                macBytes = bytearray(mac.digest())\n\n                #Compare MACs\n                if macBytes != checkBytes:\n                    macGood = False\n\n            if not (paddingGood and macGood):\n                for result in self._sendError(AlertDescription.bad_record_mac,\n                                          \"MAC failure (or padding failure)\"):\n                    yield result\n\n        yield b\n\n    def _handshakeStart(self, client):\n        if not self.closed:\n            raise ValueError(\"Renegotiation disallowed for security reasons\")\n        self._client = client\n        self._handshake_md5 = hashlib.md5()\n        self._handshake_sha = hashlib.sha1()\n        self._handshake_sha256 = hashlib.sha256()\n        self._handshakeBuffer = []\n        self.allegedSrpUsername = None\n        self._refCount = 1\n\n    def _handshakeDone(self, resumed):\n        self.resumed = resumed\n        self.closed = False\n\n    def _calcPendingStates(self, cipherSuite, masterSecret,\n            clientRandom, serverRandom, implementations):\n        if cipherSuite in CipherSuite.aes128Suites:\n            keyLength = 16\n            ivLength = 16\n            createCipherFunc = createAES\n        elif cipherSuite in CipherSuite.aes256Suites:\n            keyLength = 32\n            ivLength = 16\n            createCipherFunc = createAES\n        elif cipherSuite in CipherSuite.rc4Suites:\n            keyLength = 16\n            ivLength = 0\n            createCipherFunc = createRC4\n        elif cipherSuite in CipherSuite.tripleDESSuites:\n            keyLength = 24\n            ivLength = 8\n            createCipherFunc = createTripleDES\n        else:\n            raise AssertionError()\n            \n        if cipherSuite in CipherSuite.shaSuites:\n            macLength = 20\n            digestmod = hashlib.sha1        \n        elif cipherSuite in CipherSuite.sha256Suites:\n            macLength = 32\n            digestmod = hashlib.sha256\n        elif cipherSuite in CipherSuite.md5Suites:\n            macLength = 16\n            digestmod = hashlib.md5\n\n        if self.version == (3,0):\n            createMACFunc = createMAC_SSL\n        elif self.version in ((3,1), (3,2), (3,3)):\n            createMACFunc = createHMAC\n\n        outputLength = (macLength*2) + (keyLength*2) + (ivLength*2)\n\n        #Calculate Keying Material from Master Secret\n        if self.version == (3,0):\n            keyBlock = PRF_SSL(masterSecret,\n                               serverRandom + clientRandom,\n                               outputLength)\n        elif self.version in ((3,1), (3,2)):\n            keyBlock = PRF(masterSecret,\n                           b\"key expansion\",\n                           serverRandom + clientRandom,\n                           outputLength)\n        elif self.version == (3,3):\n            keyBlock = PRF_1_2(masterSecret,\n                           b\"key expansion\",\n                           serverRandom + clientRandom,\n                           outputLength)\n        else:\n            raise AssertionError()\n\n        #Slice up Keying Material\n        clientPendingState = _ConnectionState()\n        serverPendingState = _ConnectionState()\n        p = Parser(keyBlock)\n        clientMACBlock = p.getFixBytes(macLength)\n        serverMACBlock = p.getFixBytes(macLength)\n        clientKeyBlock = p.getFixBytes(keyLength)\n        serverKeyBlock = p.getFixBytes(keyLength)\n        clientIVBlock  = p.getFixBytes(ivLength)\n        serverIVBlock  = p.getFixBytes(ivLength)\n        clientPendingState.macContext = createMACFunc(\n            compatHMAC(clientMACBlock), digestmod=digestmod)\n        serverPendingState.macContext = createMACFunc(\n            compatHMAC(serverMACBlock), digestmod=digestmod)\n        clientPendingState.encContext = createCipherFunc(clientKeyBlock,\n                                                         clientIVBlock,\n                                                         implementations)\n        serverPendingState.encContext = createCipherFunc(serverKeyBlock,\n                                                         serverIVBlock,\n                                                         implementations)\n\n        #Assign new connection states to pending states\n        if self._client:\n            self._pendingWriteState = clientPendingState\n            self._pendingReadState = serverPendingState\n        else:\n            self._pendingWriteState = serverPendingState\n            self._pendingReadState = clientPendingState\n\n        if self.version >= (3,2) and ivLength:\n            #Choose fixedIVBlock for TLS 1.1 (this is encrypted with the CBC\n            #residue to create the IV for each sent block)\n            self.fixedIVBlock = getRandomBytes(ivLength)\n\n    def _changeWriteState(self):\n        self._writeState = self._pendingWriteState\n        self._pendingWriteState = _ConnectionState()\n\n    def _changeReadState(self):\n        self._readState = self._pendingReadState\n        self._pendingReadState = _ConnectionState()\n\n    #Used for Finished messages and CertificateVerify messages in SSL v3\n    def _calcSSLHandshakeHash(self, masterSecret, label):\n        imac_md5 = self._handshake_md5.copy()\n        imac_sha = self._handshake_sha.copy()\n\n        imac_md5.update(compatHMAC(label + masterSecret + bytearray([0x36]*48)))\n        imac_sha.update(compatHMAC(label + masterSecret + bytearray([0x36]*40)))\n\n        md5Bytes = MD5(masterSecret + bytearray([0x5c]*48) + \\\n                         bytearray(imac_md5.digest()))\n        shaBytes = SHA1(masterSecret + bytearray([0x5c]*40) + \\\n                         bytearray(imac_sha.digest()))\n\n        return md5Bytes + shaBytes\n\n"], "filenames": ["tlslite/tlsrecordlayer.py"], "buggy_code_start_loc": [972], "buggy_code_end_loc": [972], "fixing_code_start_loc": [973], "fixing_code_end_loc": [979], "type": "CWE-119", "message": "The tlslite library before 0.4.9 for Python allows remote attackers to trigger a denial of service (runtime exception and process crash).", "other": {"cve": {"id": "CVE-2015-3220", "sourceIdentifier": "secalert@redhat.com", "published": "2017-06-13T16:29:00.183", "lastModified": "2018-08-13T21:47:52.320", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The tlslite library before 0.4.9 for Python allows remote attackers to trigger a denial of service (runtime exception and process crash)."}, {"lang": "es", "value": "La biblioteca tlslite versiones anteriores a 0.4.9 para Python permite a atacantes remotos desencadenar una denegaci\u00f3n de servicio (runtime exception and process crash)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tlslite_project:tlslite:*:*:*:*:*:python:*:*", "versionEndIncluding": "0.4.9", "matchCriteriaId": "90728FAD-66BE-4166-913C-DC43C4E232DA"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1254215", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/trevp/tlslite/commit/aca8d4f898b436ff6754e1a9ab96cae976c8a853", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/forum/#!topic/tlslite-dev/MoWE7B0A4iU", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/trevp/tlslite/commit/aca8d4f898b436ff6754e1a9ab96cae976c8a853"}}