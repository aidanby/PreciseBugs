{"buggy_code": ["/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.ingest.impl;\n\nimport static org.apache.commons.lang3.StringUtils.isBlank;\nimport static org.opencastproject.util.JobUtil.waitForJob;\nimport static org.opencastproject.util.data.Monadics.mlist;\nimport static org.opencastproject.util.data.Option.none;\n\nimport org.opencastproject.capture.CaptureParameters;\nimport org.opencastproject.ingest.api.IngestException;\nimport org.opencastproject.ingest.api.IngestService;\nimport org.opencastproject.ingest.impl.jmx.IngestStatistics;\nimport org.opencastproject.inspection.api.MediaInspectionService;\nimport org.opencastproject.job.api.AbstractJobProducer;\nimport org.opencastproject.job.api.Job;\nimport org.opencastproject.job.api.Job.Status;\nimport org.opencastproject.mediapackage.EName;\nimport org.opencastproject.mediapackage.MediaPackage;\nimport org.opencastproject.mediapackage.MediaPackageBuilderFactory;\nimport org.opencastproject.mediapackage.MediaPackageElement;\nimport org.opencastproject.mediapackage.MediaPackageElementFlavor;\nimport org.opencastproject.mediapackage.MediaPackageElementParser;\nimport org.opencastproject.mediapackage.MediaPackageElements;\nimport org.opencastproject.mediapackage.MediaPackageException;\nimport org.opencastproject.mediapackage.MediaPackageParser;\nimport org.opencastproject.mediapackage.MediaPackageSupport;\nimport org.opencastproject.mediapackage.Track;\nimport org.opencastproject.mediapackage.identifier.IdImpl;\nimport org.opencastproject.metadata.dublincore.DCMIPeriod;\nimport org.opencastproject.metadata.dublincore.DublinCore;\nimport org.opencastproject.metadata.dublincore.DublinCoreCatalog;\nimport org.opencastproject.metadata.dublincore.DublinCoreCatalogService;\nimport org.opencastproject.metadata.dublincore.DublinCoreValue;\nimport org.opencastproject.metadata.dublincore.EncodingSchemeUtils;\nimport org.opencastproject.scheduler.api.SchedulerException;\nimport org.opencastproject.scheduler.api.SchedulerService;\nimport org.opencastproject.security.api.OrganizationDirectoryService;\nimport org.opencastproject.security.api.SecurityService;\nimport org.opencastproject.security.api.TrustedHttpClient;\nimport org.opencastproject.security.api.UnauthorizedException;\nimport org.opencastproject.security.api.UserDirectoryService;\nimport org.opencastproject.series.api.SeriesService;\nimport org.opencastproject.serviceregistry.api.ServiceRegistry;\nimport org.opencastproject.serviceregistry.api.ServiceRegistryException;\nimport org.opencastproject.smil.api.util.SmilUtil;\nimport org.opencastproject.util.ConfigurationException;\nimport org.opencastproject.util.IoSupport;\nimport org.opencastproject.util.LoadUtil;\nimport org.opencastproject.util.MimeTypes;\nimport org.opencastproject.util.NotFoundException;\nimport org.opencastproject.util.ProgressInputStream;\nimport org.opencastproject.util.XmlSafeParser;\nimport org.opencastproject.util.XmlUtil;\nimport org.opencastproject.util.data.Function;\nimport org.opencastproject.util.data.Option;\nimport org.opencastproject.util.data.functions.Misc;\nimport org.opencastproject.util.jmx.JmxUtil;\nimport org.opencastproject.workflow.api.WorkflowDatabaseException;\nimport org.opencastproject.workflow.api.WorkflowDefinition;\nimport org.opencastproject.workflow.api.WorkflowException;\nimport org.opencastproject.workflow.api.WorkflowInstance;\nimport org.opencastproject.workflow.api.WorkflowService;\nimport org.opencastproject.workingfilerepository.api.WorkingFileRepository;\n\nimport com.entwinemedia.fn.Stream;\nimport com.entwinemedia.fn.data.Opt;\nimport com.google.common.cache.Cache;\nimport com.google.common.cache.CacheBuilder;\n\nimport org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.BooleanUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.cxf.jaxrs.ext.multipart.ContentDisposition;\nimport org.apache.http.Header;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.auth.AuthScope;\nimport org.apache.http.auth.UsernamePasswordCredentials;\nimport org.apache.http.client.CredentialsProvider;\nimport org.apache.http.client.config.AuthSchemes;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.BasicCredentialsProvider;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClientBuilder;\nimport org.osgi.service.cm.ManagedService;\nimport org.osgi.service.component.ComponentContext;\nimport org.osgi.service.component.annotations.Activate;\nimport org.osgi.service.component.annotations.Component;\nimport org.osgi.service.component.annotations.Deactivate;\nimport org.osgi.service.component.annotations.Reference;\nimport org.osgi.service.component.annotations.ReferenceCardinality;\nimport org.osgi.service.component.annotations.ReferencePolicy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.SAXException;\n\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URI;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.Dictionary;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\n\nimport javax.management.ObjectInstance;\n\n/**\n * Creates and augments Opencast MediaPackages. Stores media into the Working File Repository.\n */\n@Component(\n  immediate = true,\n  service = {\n    IngestService.class,\n    ManagedService.class\n  },\n  property = {\n    \"service.description=Ingest Service\",\n    \"service.pid=org.opencastproject.ingest.impl.IngestServiceImpl\"\n  }\n)\npublic class IngestServiceImpl extends AbstractJobProducer implements IngestService, ManagedService {\n\n  /** The logger */\n  private static final Logger logger = LoggerFactory.getLogger(IngestServiceImpl.class);\n\n  /** The source SMIL name */\n  private static final String PARTIAL_SMIL_NAME = \"source_partial.smil\";\n\n  /** The configuration key that defines the default workflow definition */\n  protected static final String WORKFLOW_DEFINITION_DEFAULT = \"org.opencastproject.workflow.default.definition\";\n\n  /** The workflow configuration property prefix **/\n  protected static final String WORKFLOW_CONFIGURATION_PREFIX = \"org.opencastproject.workflow.config.\";\n\n  /** The key for the legacy mediapackage identifier */\n  public static final String LEGACY_MEDIAPACKAGE_ID_KEY = \"org.opencastproject.ingest.legacy.mediapackage.id\";\n\n  public static final String JOB_TYPE = \"org.opencastproject.ingest\";\n\n  /** Methods that ingest zips create jobs with this operation type */\n  public static final String INGEST_ZIP = \"zip\";\n\n  /** Methods that ingest tracks directly create jobs with this operation type */\n  public static final String INGEST_TRACK = \"track\";\n\n  /** Methods that ingest tracks from a URI create jobs with this operation type */\n  public static final String INGEST_TRACK_FROM_URI = \"uri-track\";\n\n  /** Methods that ingest attachments directly create jobs with this operation type */\n  public static final String INGEST_ATTACHMENT = \"attachment\";\n\n  /** Methods that ingest attachments from a URI create jobs with this operation type */\n  public static final String INGEST_ATTACHMENT_FROM_URI = \"uri-attachment\";\n\n  /** Methods that ingest catalogs directly create jobs with this operation type */\n  public static final String INGEST_CATALOG = \"catalog\";\n\n  /** Methods that ingest catalogs from a URI create jobs with this operation type */\n  public static final String INGEST_CATALOG_FROM_URI = \"uri-catalog\";\n\n  /** The approximate load placed on the system by ingesting a file */\n  public static final float DEFAULT_INGEST_FILE_JOB_LOAD = 0.2f;\n\n  /** The approximate load placed on the system by ingesting a zip file */\n  public static final float DEFAULT_INGEST_ZIP_JOB_LOAD = 0.2f;\n\n  /** The key to look for in the service configuration file to override the {@link DEFAULT_INGEST_FILE_JOB_LOAD} */\n  public static final String FILE_JOB_LOAD_KEY = \"job.load.ingest.file\";\n\n  /** The key to look for in the service configuration file to override the {@link DEFAULT_INGEST_ZIP_JOB_LOAD} */\n  public static final String ZIP_JOB_LOAD_KEY = \"job.load.ingest.zip\";\n\n  /** The source to download from  */\n  public static final String DOWNLOAD_SOURCE = \"org.opencastproject.download.source\";\n\n  /** The user for download from external sources */\n  public static final String DOWNLOAD_USER = \"org.opencastproject.download.user\";\n\n  /** The password for download from external sources */\n  public static final String DOWNLOAD_PASSWORD = \"org.opencastproject.download.password\";\n\n  /** By default, do not allow event ingest to modify existing series metadata */\n  public static final boolean DEFAULT_ALLOW_SERIES_MODIFICATIONS = false;\n\n  /** The default is to preserve existing Opencast flavors during ingest. */\n  public static final boolean DEFAULT_ALLOW_ONLY_NEW_FLAVORS = true;\n\n  /** The default is not to automatically skip attachments and catalogs from capture agent */\n  public static final boolean DEFAULT_SKIP = false;\n\n  /** The maximum length of filenames ingested by Opencast */\n  public static final int FILENAME_LENGTH_MAX = 75;\n\n  /** Managed Property key to allow Opencast series modification during ingest\n   * Deprecated, the param potentially causes an update chain reaction for all\n   * events associated to that series, for each ingest */\n  @Deprecated\n  public static final String MODIFY_OPENCAST_SERIES_KEY = \"org.opencastproject.series.overwrite\";\n\n  /** Managed Property key to allow new flavors of ingested attachments and catalogs\n   * to be added to the existing Opencast mediapackage. But, not catalogs and attachments\n   * that would overwrite existing ones in Opencast.\n   */\n  public static final String ADD_ONLY_NEW_FLAVORS_KEY = \"add.only.new.catalogs.attachments.for.existing.events\";\n\n  /** Control if catalogs sent by capture agents for scheduled events are skipped. */\n  public static final String SKIP_CATALOGS_KEY = \"skip.catalogs.for.existing.events\";\n\n  /** Control if attachments sent by capture agents for scheduled events are skipped. */\n  public static final String SKIP_ATTACHMENTS_KEY = \"skip.attachments.for.existing.events\";\n\n  /** The approximate load placed on the system by ingesting a file */\n  private float ingestFileJobLoad = DEFAULT_INGEST_FILE_JOB_LOAD;\n\n  /** The approximate load placed on the system by ingesting a zip file */\n  private float ingestZipJobLoad = DEFAULT_INGEST_ZIP_JOB_LOAD;\n\n  /** The user for download from external sources */\n  private static String downloadUser = DOWNLOAD_USER;\n\n  /** The password for download from external sources */\n  private static String downloadPassword = DOWNLOAD_PASSWORD;\n\n  /** The external source dns name */\n  private static String downloadSource = DOWNLOAD_SOURCE;\n\n  /** The JMX business object for ingest statistics */\n  private IngestStatistics ingestStatistics = new IngestStatistics();\n\n  /** The JMX bean object instance */\n  private ObjectInstance registerMXBean;\n\n  /** The workflow service */\n  private WorkflowService workflowService;\n\n  /** The working file repository */\n  private WorkingFileRepository workingFileRepository;\n\n  /** The http client */\n  private TrustedHttpClient httpClient;\n\n  /** The series service */\n  private SeriesService seriesService;\n\n  /** The dublin core service */\n  private DublinCoreCatalogService dublinCoreService;\n\n  /** The opencast service registry */\n  private ServiceRegistry serviceRegistry;\n\n  /** The security service */\n  protected SecurityService securityService = null;\n\n  /** The user directory service */\n  protected UserDirectoryService userDirectoryService = null;\n\n  /** The organization directory service */\n  protected OrganizationDirectoryService organizationDirectoryService = null;\n\n  /** The scheduler service */\n  private SchedulerService schedulerService = null;\n\n  /** The media inspection service */\n  private MediaInspectionService mediaInspectionService = null;\n\n  /** The default workflow identifier, if one is configured */\n  protected String defaultWorkflowDefinionId;\n\n  /** The partial track start time map */\n  private Cache<String, Long> partialTrackStartTimes = CacheBuilder.newBuilder().expireAfterWrite(1, TimeUnit.DAYS)\n          .build();\n\n  /** Option to overwrite matching flavors (e.g. series and episode metadata) on ingest,\n   *  tracks are always taken on ingest */\n  protected boolean isAddOnlyNew = DEFAULT_ALLOW_ONLY_NEW_FLAVORS;\n  protected boolean isAllowModifySeries = DEFAULT_ALLOW_SERIES_MODIFICATIONS;\n\n  private boolean skipCatalogs = DEFAULT_SKIP;\n  private boolean skipAttachments = DEFAULT_SKIP;\n\n  protected boolean testMode = false;\n\n  /**\n   * Creates a new ingest service instance.\n   */\n  public IngestServiceImpl() {\n    super(JOB_TYPE);\n  }\n\n  /**\n   * OSGI callback for activating this component\n   *\n   * @param cc\n   *          the osgi component context\n   */\n  @Override\n  @Activate\n  public void activate(ComponentContext cc) {\n    super.activate(cc);\n    logger.info(\"Ingest Service started.\");\n    defaultWorkflowDefinionId = StringUtils.trimToNull(cc.getBundleContext().getProperty(WORKFLOW_DEFINITION_DEFAULT));\n    if (defaultWorkflowDefinionId == null) {\n      defaultWorkflowDefinionId = \"schedule-and-upload\";\n    }\n    registerMXBean = JmxUtil.registerMXBean(ingestStatistics, \"IngestStatistics\");\n  }\n\n  /**\n   * Callback from OSGi on service deactivation.\n   */\n  @Deactivate\n  public void deactivate() {\n    JmxUtil.unregisterMXBean(registerMXBean);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.osgi.service.cm.ManagedService#updated(java.util.Dictionary)\n   *      Retrieve ManagedService configuration, including option to overwrite series\n   */\n  @Override\n  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n\n    if (properties == null) {\n      logger.info(\"No configuration available, using defaults\");\n      return;\n    }\n\n    downloadPassword = StringUtils.trimToEmpty((String)properties.get(DOWNLOAD_PASSWORD));\n    downloadUser = StringUtils.trimToEmpty(((String) properties.get(DOWNLOAD_USER)));\n    downloadSource = StringUtils.trimToEmpty(((String) properties.get(DOWNLOAD_SOURCE)));\n\n    skipAttachments = BooleanUtils.toBoolean(Objects.toString(properties.get(SKIP_ATTACHMENTS_KEY),\n            BooleanUtils.toStringTrueFalse(DEFAULT_SKIP)));\n    skipCatalogs = BooleanUtils.toBoolean(Objects.toString(properties.get(SKIP_CATALOGS_KEY),\n            BooleanUtils.toStringTrueFalse(DEFAULT_SKIP)));\n    logger.debug(\"Skip attachments sent by agents for scheduled events: {}\", skipAttachments);\n    logger.debug(\"Skip metadata catalogs sent by agents for scheduled events: {}\", skipCatalogs);\n\n    ingestFileJobLoad = LoadUtil.getConfiguredLoadValue(properties, FILE_JOB_LOAD_KEY, DEFAULT_INGEST_FILE_JOB_LOAD,\n            serviceRegistry);\n    ingestZipJobLoad = LoadUtil.getConfiguredLoadValue(properties, ZIP_JOB_LOAD_KEY, DEFAULT_INGEST_ZIP_JOB_LOAD,\n            serviceRegistry);\n\n    isAllowModifySeries = BooleanUtils.toBoolean(Objects.toString(properties.get(MODIFY_OPENCAST_SERIES_KEY),\n              BooleanUtils.toStringTrueFalse(DEFAULT_ALLOW_SERIES_MODIFICATIONS)));\n    isAddOnlyNew = BooleanUtils.toBoolean(Objects.toString(properties.get(ADD_ONLY_NEW_FLAVORS_KEY),\n            BooleanUtils.toStringTrueFalse(DEFAULT_ALLOW_ONLY_NEW_FLAVORS)));\n    logger.info(\"Only allow new flavored catalogs and attachments on ingest:'{}'\", isAddOnlyNew);\n    logger.info(\"Allowing series modification:'{}'\", isAllowModifySeries);\n  }\n\n  /**\n   * Sets the trusted http client\n   *\n   * @param httpClient\n   *          the http client\n   */\n  @Reference\n  public void setHttpClient(TrustedHttpClient httpClient) {\n    this.httpClient = httpClient;\n  }\n\n  /**\n   * Sets the service registry\n   *\n   * @param serviceRegistry\n   *          the serviceRegistry to set\n   */\n  @Reference\n  public void setServiceRegistry(ServiceRegistry serviceRegistry) {\n    this.serviceRegistry = serviceRegistry;\n  }\n\n  /**\n   * Sets the media inspection service\n   *\n   * @param mediaInspectionService\n   *          the media inspection service to set\n   */\n  @Reference\n  public void setMediaInspectionService(MediaInspectionService mediaInspectionService) {\n    this.mediaInspectionService = mediaInspectionService;\n  }\n\n  public WorkflowInstance addZippedMediaPackage(InputStream zipStream)\n          throws IngestException, IOException, MediaPackageException {\n    try {\n      return addZippedMediaPackage(zipStream, null, null);\n    } catch (NotFoundException e) {\n      throw new IllegalStateException(\"A not found exception was thrown without a lookup\");\n    }\n  }\n\n  @Override\n  public WorkflowInstance addZippedMediaPackage(InputStream zipStream, String wd, Map<String, String> workflowConfig)\n          throws MediaPackageException, IOException, IngestException, NotFoundException {\n    try {\n      return addZippedMediaPackage(zipStream, wd, workflowConfig, null);\n    } catch (UnauthorizedException e) {\n      throw new IllegalStateException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addZippedMediaPackage(java.io.InputStream, java.lang.String,\n   *      java.util.Map, java.lang.Long)\n   */\n  @Override\n  public WorkflowInstance addZippedMediaPackage(InputStream zipStream, String workflowDefinitionId,\n          Map<String, String> workflowConfig, Long workflowInstanceId)\n          throws MediaPackageException, IOException, IngestException, NotFoundException, UnauthorizedException {\n    // Start a job synchronously. We can't keep the open input stream waiting around.\n    Job job = null;\n\n    if (StringUtils.isNotBlank(workflowDefinitionId)) {\n      try {\n        workflowService.getWorkflowDefinitionById(workflowDefinitionId);\n      } catch (WorkflowDatabaseException e) {\n        throw new IngestException(e);\n      } catch (NotFoundException nfe) {\n        logger.warn(\"Workflow definition {} not found, using default workflow {} instead\", workflowDefinitionId,\n                defaultWorkflowDefinionId);\n        workflowDefinitionId = defaultWorkflowDefinionId;\n      }\n    }\n\n    if (workflowInstanceId != null) {\n      logger.warn(\"Deprecated method! Ingesting zipped mediapackage with workflow {}\", workflowInstanceId);\n    } else {\n      logger.info(\"Ingesting zipped mediapackage\");\n    }\n\n    ZipArchiveInputStream zis = null;\n    Set<String> collectionFilenames = new HashSet<>();\n    try {\n      // We don't need anybody to do the dispatching for us. Therefore we need to make sure that the job is never in\n      // QUEUED state but set it to INSTANTIATED in the beginning and then manually switch it to RUNNING.\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_ZIP, null, null, false, ingestZipJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n\n      // Create the working file target collection for this ingest operation\n      String wfrCollectionId = Long.toString(job.getId());\n\n      zis = new ZipArchiveInputStream(zipStream);\n      ZipArchiveEntry entry;\n      MediaPackage mp = null;\n      Map<String, URI> uris = new HashMap<>();\n      // Sequential number to append to file names so that, if two files have the same\n      // name, one does not overwrite the other (see MH-9688)\n      int seq = 1;\n      // Folder name to compare with next one to figure out if there's a root folder\n      String folderName = null;\n      // Indicates if zip has a root folder or not, initialized as true\n      boolean hasRootFolder = true;\n      // While there are entries write them to a collection\n      while ((entry = zis.getNextZipEntry()) != null) {\n        try {\n          if (entry.isDirectory() || entry.getName().contains(\"__MACOSX\"))\n            continue;\n\n          if (entry.getName().endsWith(\"manifest.xml\") || entry.getName().endsWith(\"index.xml\")) {\n            // Build the media package\n            final InputStream is = new ZipEntryInputStream(zis, entry.getSize());\n            mp = MediaPackageParser.getFromXml(IOUtils.toString(is, StandardCharsets.UTF_8));\n          } else {\n            logger.info(\"Storing zip entry {}/{} in working file repository collection '{}'\", job.getId(),\n                    entry.getName(), wfrCollectionId);\n            // Since the directory structure is not being mirrored, makes sure the file\n            // name is different than the previous one(s) by adding a sequential number\n            String fileName = FilenameUtils.getBaseName(entry.getName()) + \"_\" + seq++ + \".\"\n                    + FilenameUtils.getExtension(entry.getName());\n            URI contentUri = workingFileRepository.putInCollection(wfrCollectionId, fileName,\n                    new ZipEntryInputStream(zis, entry.getSize()));\n            collectionFilenames.add(fileName);\n            // Key is the zip entry name as it is\n            String key = entry.getName();\n            uris.put(key, contentUri);\n            ingestStatistics.add(entry.getSize());\n            logger.info(\"Zip entry {}/{} stored at {}\", job.getId(), entry.getName(), contentUri);\n            // Figures out if there's a root folder. Does entry name starts with a folder?\n            int pos = entry.getName().indexOf('/');\n            if (pos == -1) {\n              // No, we can conclude there's no root folder\n              hasRootFolder = false;\n            } else if (hasRootFolder && folderName != null && !folderName.equals(entry.getName().substring(0, pos))) {\n              // Folder name different from previous so there's no root folder\n              hasRootFolder = false;\n            } else if (folderName == null) {\n              // Just initialize folder name\n              folderName = entry.getName().substring(0, pos);\n            }\n          }\n        } catch (IOException e) {\n          logger.warn(\"Unable to process zip entry {}: {}\", entry.getName(), e);\n          throw e;\n        }\n      }\n\n      if (mp == null)\n        throw new MediaPackageException(\"No manifest found in this zip\");\n\n      // Determine the mediapackage identifier\n      if (mp.getIdentifier() == null || isBlank(mp.getIdentifier().toString()))\n        mp.setIdentifier(IdImpl.fromUUID());\n\n      String mediaPackageId = mp.getIdentifier().toString();\n\n      logger.info(\"Ingesting mediapackage {} is named '{}'\", mediaPackageId, mp.getTitle());\n\n      // Make sure there are tracks in the mediapackage\n      if (mp.getTracks().length == 0) {\n        logger.warn(\"Mediapackage {} has no media tracks\", mediaPackageId);\n      }\n\n      // Update the element uris to point to their working file repository location\n      for (MediaPackageElement element : mp.elements()) {\n        // Key has root folder name if there is one\n        URI uri = uris.get((hasRootFolder ? folderName + \"/\" : \"\") + element.getURI().toString());\n\n        if (uri == null)\n          throw new MediaPackageException(\"Unable to map element name '\" + element.getURI() + \"' to workspace uri\");\n        logger.info(\"Ingested mediapackage element {}/{} located at {}\", mediaPackageId, element.getIdentifier(), uri);\n        URI dest = workingFileRepository.moveTo(wfrCollectionId, FilenameUtils.getName(uri.toString()), mediaPackageId,\n                element.getIdentifier(), FilenameUtils.getName(element.getURI().toString()));\n        element.setURI(dest);\n\n        // TODO: This should be triggered somehow instead of being handled here\n        if (MediaPackageElements.SERIES.equals(element.getFlavor())) {\n          logger.info(\"Ingested mediapackage {} contains updated series information\", mediaPackageId);\n          updateSeries(element.getURI());\n        }\n      }\n\n      // Now that all elements are in place, start with ingest\n      logger.info(\"Initiating processing of ingested mediapackage {}\", mediaPackageId);\n      WorkflowInstance workflowInstance = ingest(mp, workflowDefinitionId, workflowConfig, workflowInstanceId);\n      logger.info(\"Ingest of mediapackage {} done\", mediaPackageId);\n      job.setStatus(Job.Status.FINISHED);\n      return workflowInstance;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (MediaPackageException e) {\n      job.setStatus(Job.Status.FAILED, Job.FailureReason.DATA);\n      throw e;\n    } catch (Exception e) {\n      if (e instanceof IngestException)\n        throw (IngestException) e;\n      throw new IngestException(e);\n    } finally {\n      IOUtils.closeQuietly(zis);\n      finallyUpdateJob(job);\n      for (String filename : collectionFilenames) {\n        workingFileRepository.deleteFromCollection(Long.toString(job.getId()), filename, true);\n      }\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#createMediaPackage()\n   */\n  @Override\n  public MediaPackage createMediaPackage() throws MediaPackageException, ConfigurationException {\n    MediaPackage mediaPackage;\n    try {\n      mediaPackage = MediaPackageBuilderFactory.newInstance().newMediaPackageBuilder().createNew();\n    } catch (MediaPackageException e) {\n      logger.error(\"INGEST:Failed to create media package \" + e.getLocalizedMessage());\n      throw e;\n    }\n    mediaPackage.setDate(new Date());\n    logger.info(\"Created mediapackage {}\", mediaPackage);\n    return mediaPackage;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#createMediaPackage()\n   */\n  @Override\n  public MediaPackage createMediaPackage(String mediaPackageId)\n          throws MediaPackageException, ConfigurationException {\n    MediaPackage mediaPackage;\n    try {\n      mediaPackage = MediaPackageBuilderFactory.newInstance().newMediaPackageBuilder()\n              .createNew(new IdImpl(mediaPackageId));\n    } catch (MediaPackageException e) {\n      logger.error(\"INGEST:Failed to create media package \" + e.getLocalizedMessage());\n      throw e;\n    }\n    mediaPackage.setDate(new Date());\n    logger.info(\"Created mediapackage {}\", mediaPackage);\n    return mediaPackage;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addTrack(java.net.URI,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addTrack(URI uri, MediaPackageElementFlavor flavor, MediaPackage mediaPackage)\n          throws IOException, IngestException {\n    String[] tags = null;\n    return this.addTrack(uri, flavor, tags, mediaPackage);\n\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addTrack(java.net.URI,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, String[] ,\n   *      org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addTrack(URI uri, MediaPackageElementFlavor flavor, String[] tags, MediaPackage mediaPackage)\n          throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry\n              .createJob(\n                      JOB_TYPE, INGEST_TRACK_FROM_URI, Arrays.asList(uri.toString(),\n                              flavor == null ? null : flavor.toString(), MediaPackageParser.getAsXml(mediaPackage)),\n                      null, false, ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding track {} from URL {} on mediapackage {}\", elementId, uri, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, uri);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Track,\n              flavor);\n      if (tags != null && tags.length > 0) {\n        MediaPackageElement trackElement = mp.getTrack(elementId);\n        for (String tag : tags) {\n          logger.info(\"Adding Tag: \" + tag + \" to Element: \" + elementId);\n          trackElement.addTag(tag);\n        }\n      }\n\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added track {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (IOException e) {\n      throw e;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addTrack(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addTrack(InputStream in, String fileName, MediaPackageElementFlavor flavor,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    String[] tags = null;\n    return this.addTrack(in, fileName, flavor, tags, mediaPackage);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addTrack(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addTrack(InputStream in, String fileName, MediaPackageElementFlavor flavor, String[] tags,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_TRACK, null, null, false, ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding track {} from input stream on mediapackage {}\", elementId, mediaPackage);\n      if (fileName.length() > FILENAME_LENGTH_MAX) {\n        final String extension = \".\" + FilenameUtils.getExtension(fileName);\n        final int length = Math.max(0, FILENAME_LENGTH_MAX - extension.length());\n        fileName = fileName.substring(0, length) + extension;\n      }\n      URI newUrl = addContentToRepo(mediaPackage, elementId, fileName, in);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Track,\n              flavor);\n      if (tags != null && tags.length > 0) {\n        MediaPackageElement trackElement = mp.getTrack(elementId);\n        for (String tag : tags) {\n          logger.debug(\"Adding tag `{}` to element {}\", tag, elementId);\n          trackElement.addTag(tag);\n        }\n      }\n\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added track {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (IOException e) {\n      throw e;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  @Override\n  public MediaPackage addPartialTrack(URI uri, MediaPackageElementFlavor flavor, long startTime,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(\n              JOB_TYPE,\n              INGEST_TRACK_FROM_URI,\n              Arrays.asList(uri.toString(), flavor == null ? null : flavor.toString(),\n                      MediaPackageParser.getAsXml(mediaPackage)), null, false);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding partial track {} from URL {} on mediapackage {}\", elementId, uri, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, uri);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Track,\n              flavor);\n      job.setStatus(Job.Status.FINISHED);\n      // store startTime\n      partialTrackStartTimes.put(elementId, startTime);\n      logger.debug(\"Added start time {} for track {}\", startTime, elementId);\n      logger.info(\"Successful added partial track {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  @Override\n  public MediaPackage addPartialTrack(InputStream in, String fileName, MediaPackageElementFlavor flavor, long startTime,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_TRACK, null, null, false);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding partial track {} from input stream on mediapackage {}\", elementId, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, fileName, in);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Track,\n              flavor);\n      job.setStatus(Job.Status.FINISHED);\n      // store startTime\n      partialTrackStartTimes.put(elementId, startTime);\n      logger.debug(\"Added start time {} for track {}\", startTime, elementId);\n      logger.info(\"Successful added partial track {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addCatalog(java.net.URI,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addCatalog(URI uri, MediaPackageElementFlavor flavor, MediaPackage mediaPackage)\n          throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_CATALOG_FROM_URI,\n              Arrays.asList(uri.toString(), flavor.toString(), MediaPackageParser.getAsXml(mediaPackage)), null, false,\n              ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding catalog {} from URL {} on mediapackage {}\", elementId, uri, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, uri);\n      if (MediaPackageElements.SERIES.equals(flavor)) {\n        updateSeries(uri);\n      }\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Catalog,\n              flavor);\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added catalog {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  /**\n   * Updates the persistent representation of a series based on a potentially modified dublin core document.\n   *\n   * @param uri\n   *          the URI to the dublin core document containing series metadata.\n   * @return\n   *         true, if the series is created or overwritten, false if the existing series remains intact.\n   * @throws IOException if the series catalog was not found\n   * @throws IngestException if any other exception was encountered\n   */\n  protected boolean updateSeries(URI uri) throws IOException, IngestException {\n    HttpResponse response = null;\n    InputStream in = null;\n    boolean isUpdated = false;\n    try {\n      HttpGet getDc = new HttpGet(uri);\n      response = httpClient.execute(getDc);\n      in = response.getEntity().getContent();\n      DublinCoreCatalog dc = dublinCoreService.load(in);\n      String id = dc.getFirst(DublinCore.PROPERTY_IDENTIFIER);\n      if (id == null) {\n        logger.warn(\"Series dublin core document contains no identifier, rejecting ingested series cagtalog.\");\n      } else {\n        try {\n          try {\n            seriesService.getSeries(id);\n            if (isAllowModifySeries) {\n              // Update existing series\n              seriesService.updateSeries(dc);\n              isUpdated = true;\n              logger.debug(\"Ingest is overwriting the existing series {} with the ingested series\", id);\n            } else {\n              logger.debug(\"Series {} already exists. Ignoring series catalog from ingest.\", id);\n            }\n          } catch (NotFoundException e) {\n            logger.info(\"Creating new series {} with default ACL\", id);\n            seriesService.updateSeries(dc);\n            isUpdated = true;\n          }\n\n        } catch (Exception e) {\n          throw new IngestException(e);\n        }\n      }\n      in.close();\n    } catch (IOException e) {\n      logger.error(\"Error updating series from DublinCoreCatalog: {}\", e.getMessage());\n    } finally {\n      IOUtils.closeQuietly(in);\n      httpClient.close(response);\n    }\n    return isUpdated;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addCatalog(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addCatalog(InputStream in, String fileName, MediaPackageElementFlavor flavor,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    return addCatalog(in, fileName, flavor, null, mediaPackage);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addCatalog(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addCatalog(InputStream in, String fileName, MediaPackageElementFlavor flavor, String[] tags,\n          MediaPackage mediaPackage) throws IOException, IngestException, IllegalArgumentException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_CATALOG, null, null, false, ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      final String elementId = UUID.randomUUID().toString();\n      final String mediaPackageId = mediaPackage.getIdentifier().toString();\n      logger.info(\"Start adding catalog {} from input stream on mediapackage {}\", elementId, mediaPackageId);\n      final URI newUrl = addContentToRepo(mediaPackage, elementId, fileName, in);\n\n      final boolean isJSON;\n      try (InputStream inputStream = workingFileRepository.get(mediaPackageId, elementId)) {\n        try (BufferedReader reader  = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n          // Exception for current BBB integration and Extron SMP351 which is ingesting a JSON array/object as catalog\n          int firstChar = reader.read();\n          isJSON = firstChar == '[' || firstChar == '{';\n        }\n      }\n\n      if (isJSON) {\n        logger.warn(\"Input catalog seems to be JSON. This is a mistake and will fail in future Opencast versions.\"\n            + \"You will likely want to ingest this as a media package attachment instead.\");\n      } else {\n        // Verify XML is not corrupted\n        try {\n          XmlSafeParser.parse(workingFileRepository.get(mediaPackageId, elementId));\n        } catch (SAXException e) {\n          workingFileRepository.delete(mediaPackageId, elementId);\n          throw new IllegalArgumentException(\"Catalog XML is invalid\", e);\n        }\n      }\n\n      if (MediaPackageElements.SERIES.equals(flavor)) {\n        updateSeries(newUrl);\n      }\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Catalog,\n              flavor);\n      if (tags != null && tags.length > 0) {\n        MediaPackageElement trackElement = mp.getCatalog(elementId);\n        for (String tag : tags) {\n          logger.info(\"Adding tag {} to element {}\", tag, elementId);\n          trackElement.addTag(tag);\n        }\n      }\n\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added catalog {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addAttachment(java.net.URI,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addAttachment(URI uri, MediaPackageElementFlavor flavor, MediaPackage mediaPackage)\n          throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_ATTACHMENT_FROM_URI,\n              Arrays.asList(uri.toString(), flavor.toString(), MediaPackageParser.getAsXml(mediaPackage)), null, false,\n              ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding attachment {} from URL {} on mediapackage {}\", elementId, uri, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, uri);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Attachment,\n              flavor);\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added attachment {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addAttachment(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addAttachment(InputStream in, String fileName, MediaPackageElementFlavor flavor, String[] tags,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_ATTACHMENT, null, null, false, ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding attachment {} from input stream on mediapackage {}\", elementId, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, fileName, in);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Attachment,\n              flavor);\n      if (tags != null && tags.length > 0) {\n        MediaPackageElement trackElement = mp.getAttachment(elementId);\n        for (String tag : tags) {\n          logger.info(\"Adding Tag: \" + tag + \" to Element: \" + elementId);\n          trackElement.addTag(tag);\n        }\n      }\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added attachment {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addAttachment(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addAttachment(InputStream in, String fileName, MediaPackageElementFlavor flavor,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    String[] tags = null;\n    return addAttachment(in, fileName, flavor, tags, mediaPackage);\n  }\n\n  /**\n   *\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#ingest(org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public WorkflowInstance ingest(MediaPackage mp) throws IngestException {\n    try {\n      return ingest(mp, null, null, null);\n    } catch (NotFoundException e) {\n      throw new IngestException(e);\n    } catch (UnauthorizedException e) {\n      throw new IllegalStateException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#ingest(org.opencastproject.mediapackage.MediaPackage,\n   *      java.lang.String, java.util.Map)\n   */\n  @Override\n  public WorkflowInstance ingest(MediaPackage mp, String wd, Map<String, String> properties)\n          throws IngestException, NotFoundException {\n    try {\n      return ingest(mp, wd, properties, null);\n    } catch (UnauthorizedException e) {\n      throw new IllegalStateException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#ingest(org.opencastproject.mediapackage.MediaPackage,\n   *      java.lang.String, java.util.Map, java.lang.Long)\n   */\n  @Override\n  public WorkflowInstance ingest(MediaPackage mp, String workflowDefinitionId, Map<String, String> properties,\n          Long workflowInstanceId) throws IngestException, NotFoundException, UnauthorizedException {\n    // Check for legacy media package id\n    mp = checkForLegacyMediaPackageId(mp, properties);\n\n    try {\n      mp = createSmil(mp);\n    } catch (IOException e) {\n      throw new IngestException(\"Unable to add SMIL Catalog\", e);\n    }\n\n    // Done, update the job status and return the created workflow instance\n    if (workflowInstanceId != null) {\n      logger.warn(\n              \"Resuming workflow {} with ingested mediapackage {} is deprecated, skip resuming and start new workflow\",\n              workflowInstanceId, mp);\n    }\n\n    if (workflowDefinitionId == null) {\n      logger.info(\"Starting a new workflow with ingested mediapackage {} based on the default workflow definition '{}'\",\n              mp, defaultWorkflowDefinionId);\n    } else {\n      logger.info(\"Starting a new workflow with ingested mediapackage {} based on workflow definition '{}'\", mp,\n              workflowDefinitionId);\n    }\n\n    try {\n      // Determine the workflow definition\n      WorkflowDefinition workflowDef = getWorkflowDefinition(workflowDefinitionId, mp);\n\n      // Get the final set of workflow properties\n      properties = mergeWorkflowConfiguration(properties, mp.getIdentifier().toString());\n\n      // Remove potential workflow configuration prefixes from the workflow properties\n      properties = removePrefixFromProperties(properties);\n\n      // Merge scheduled mediapackage with ingested\n      mp = mergeScheduledMediaPackage(mp);\n\n      ingestStatistics.successful();\n      if (workflowDef != null) {\n        logger.info(\"Starting new workflow with ingested mediapackage '{}' using the specified template '{}'\",\n                mp.getIdentifier().toString(), workflowDefinitionId);\n      } else {\n        logger.info(\"Starting new workflow with ingested mediapackage '{}' using the default template '{}'\",\n                mp.getIdentifier().toString(), defaultWorkflowDefinionId);\n      }\n      return workflowService.start(workflowDef, mp, properties);\n    } catch (WorkflowException e) {\n      ingestStatistics.failed();\n      throw new IngestException(e);\n    }\n  }\n\n  @Override\n  public void schedule(MediaPackage mediaPackage, String workflowDefinitionID, Map<String, String> properties)\n          throws IllegalStateException, IngestException, NotFoundException, UnauthorizedException, SchedulerException {\n    MediaPackageElement[] mediaPackageElements = mediaPackage.getElementsByFlavor(MediaPackageElements.EPISODE);\n    if (mediaPackageElements.length != 1) {\n      logger.debug(\"There can be only one (and exactly one) episode dublin core catalog: https://youtu.be/_J3VeogFUOs\");\n      throw new IngestException(\"There can be only one (and exactly one) episode dublin core catalog\");\n    }\n    InputStream inputStream;\n    DublinCoreCatalog dublinCoreCatalog;\n    try {\n      inputStream = workingFileRepository.get(mediaPackage.getIdentifier().toString(),\n              mediaPackageElements[0].getIdentifier());\n      dublinCoreCatalog = dublinCoreService.load(inputStream);\n    } catch (IOException e) {\n      throw new IngestException(e);\n    }\n\n    EName temporal = new EName(DublinCore.TERMS_NS_URI, \"temporal\");\n    List<DublinCoreValue> periods = dublinCoreCatalog.get(temporal);\n    if (periods.size() != 1) {\n      logger.debug(\"There can be only one (and exactly one) period\");\n      throw new IngestException(\"There can be only one (and exactly one) period\");\n    }\n    DCMIPeriod period = EncodingSchemeUtils.decodeMandatoryPeriod(periods.get(0));\n    if (!period.hasStart() || !period.hasEnd()) {\n      logger.debug(\"A scheduled recording needs to have a start and end.\");\n      throw new IngestException(\"A scheduled recording needs to have a start and end.\");\n    }\n    EName createdEName = new EName(DublinCore.TERMS_NS_URI, \"created\");\n    List<DublinCoreValue> created = dublinCoreCatalog.get(createdEName);\n    if (created.size() == 0) {\n      logger.debug(\"Created not set\");\n    } else if (created.size() == 1) {\n      Date date = EncodingSchemeUtils.decodeMandatoryDate(created.get(0));\n      if (date.getTime() != period.getStart().getTime()) {\n        logger.debug(\"start and created date differ ({} vs {})\", date.getTime(), period.getStart().getTime());\n        throw new IngestException(\"Temporal start and created date differ\");\n      }\n    } else {\n      logger.debug(\"There can be only one created date\");\n      throw new IngestException(\"There can be only one created date\");\n    }\n    // spatial\n    EName spatial = new EName(DublinCore.TERMS_NS_URI, \"spatial\");\n    List<DublinCoreValue> captureAgents = dublinCoreCatalog.get(spatial);\n    if (captureAgents.size() != 1) {\n      logger.debug(\"Exactly one capture agent needs to be set\");\n      throw new IngestException(\"Exactly one capture agent needs to be set\");\n    }\n    String captureAgent = captureAgents.get(0).getValue();\n\n    // Go through properties\n    Map<String, String> agentProperties = new HashMap<>();\n    Map<String, String> workflowProperties = new HashMap<>();\n    for (String key : properties.keySet()) {\n      if (key.startsWith(\"org.opencastproject.workflow.config.\")) {\n        workflowProperties.put(key, properties.get(key));\n      } else {\n        agentProperties.put(key, properties.get(key));\n      }\n    }\n    try {\n      schedulerService.addEvent(period.getStart(), period.getEnd(), captureAgent, new HashSet<>(), mediaPackage,\n              workflowProperties, agentProperties, Opt.none());\n    } finally {\n      for (MediaPackageElement mediaPackageElement : mediaPackage.getElements()) {\n        try {\n          workingFileRepository.delete(mediaPackage.getIdentifier().toString(), mediaPackageElement.getIdentifier());\n        } catch (IOException e) {\n          logger.warn(\"Failed to delete media package element\", e);\n        }\n      }\n    }\n  }\n\n  /**\n   * Check whether the mediapackage id is set via the legacy workflow identifier and change the id if existing.\n   *\n   * @param mp\n   *          the mediapackage\n   * @param properties\n   *          the workflow properties\n   * @return the mediapackage\n   */\n  private MediaPackage checkForLegacyMediaPackageId(MediaPackage mp, Map<String, String> properties)\n          throws IngestException {\n    if (properties == null || properties.isEmpty())\n      return mp;\n\n    try {\n      String mediaPackageId = properties.get(LEGACY_MEDIAPACKAGE_ID_KEY);\n      if (StringUtils.isNotBlank(mediaPackageId) && schedulerService != null) {\n        logger.debug(\"Check ingested mediapackage {} for legacy mediapackage identifier {}\",\n                mp.getIdentifier().toString(), mediaPackageId);\n        try {\n          schedulerService.getMediaPackage(mp.getIdentifier().toString());\n          return mp;\n        } catch (NotFoundException e) {\n          logger.info(\"No scheduler mediapackage found with ingested id {}, try legacy mediapackage id {}\",\n                  mp.getIdentifier().toString(), mediaPackageId);\n          try {\n            schedulerService.getMediaPackage(mediaPackageId);\n            logger.info(\"Legacy mediapackage id {} exists, change ingested mediapackage id {} to legacy id\",\n                    mediaPackageId, mp.getIdentifier().toString());\n            mp.setIdentifier(new IdImpl(mediaPackageId));\n            return mp;\n          } catch (NotFoundException e1) {\n            logger.info(\"No scheduler mediapackage found with legacy mediapackage id {}, skip merging\", mediaPackageId);\n          } catch (Exception e1) {\n            logger.error(\"Unable to get event mediapackage from scheduler event {}\", mediaPackageId, e);\n            throw new IngestException(e);\n          }\n        } catch (Exception e) {\n          logger.error(\"Unable to get event mediapackage from scheduler event {}\", mp.getIdentifier().toString(), e);\n          throw new IngestException(e);\n        }\n      }\n      return mp;\n    } finally {\n      properties.remove(LEGACY_MEDIAPACKAGE_ID_KEY);\n    }\n  }\n\n  private Map<String, String> mergeWorkflowConfiguration(Map<String, String> properties, String mediaPackageId) {\n    if (isBlank(mediaPackageId) || schedulerService == null)\n      return properties;\n\n    HashMap<String, String> mergedProperties = new HashMap<>();\n\n    try {\n      Map<String, String> recordingProperties = schedulerService.getCaptureAgentConfiguration(mediaPackageId);\n      logger.debug(\"Restoring workflow properties from scheduler event {}\", mediaPackageId);\n      mergedProperties.putAll(recordingProperties);\n    } catch (SchedulerException e) {\n      logger.warn(\"Unable to get workflow properties from scheduler event {}\", mediaPackageId, e);\n    } catch (NotFoundException e) {\n      logger.info(\"No capture event found for id {}\", mediaPackageId);\n    } catch (UnauthorizedException e) {\n      throw new IllegalStateException(e);\n    }\n\n    if (properties != null) {\n      // Merge the properties, this must be after adding the recording properties\n      logger.debug(\"Merge workflow properties with the one from the scheduler event {}\", mediaPackageId);\n      mergedProperties.putAll(properties);\n    }\n\n    return mergedProperties;\n  }\n\n  /**\n   * Merges the ingested mediapackage with the scheduled mediapackage. The ingested mediapackage takes precedence over\n   * the scheduled mediapackage.\n   *\n   * @param mp\n   *          the ingested mediapackage\n   * @return the merged mediapackage\n   */\n  private MediaPackage mergeScheduledMediaPackage(MediaPackage mp) throws IngestException {\n    if (schedulerService == null) {\n      logger.warn(\"No scheduler service available to merge mediapackage!\");\n      return mp;\n    }\n\n    try {\n      MediaPackage scheduledMp = schedulerService.getMediaPackage(mp.getIdentifier().toString());\n      logger.info(\"Found matching scheduled event for id '{}', merging mediapackage...\", mp.getIdentifier().toString());\n      mergeMediaPackageElements(mp, scheduledMp);\n      mergeMediaPackageMetadata(mp, scheduledMp);\n      return mp;\n    } catch (NotFoundException e) {\n      logger.debug(\"No scheduler mediapackage found with id {}, skip merging\", mp.getIdentifier());\n      return mp;\n    } catch (Exception e) {\n      throw new IngestException(String.format(\"Unable to get event media package from scheduler event %s\",\n              mp.getIdentifier()), e);\n    }\n  }\n\n  /**\n   * Merge different elements from capture agent ingesting mp and Asset manager. Overwrite or replace same flavored\n   * elements depending on the Ingest Service overwrite configuration. Ignore publications (i.e. live publication\n   * channel from Asset Manager) Always keep tracks from the capture agent.\n   *\n   * @param mp\n   *          the medipackage being ingested from the Capture Agent\n   * @param scheduledMp\n   *          the mediapckage that was schedule and managed by the Asset Manager\n   */\n  private void mergeMediaPackageElements(MediaPackage mp, MediaPackage scheduledMp) {\n    // drop catalogs sent by the capture agent in favor of Opencast's own metadata\n    if (skipCatalogs) {\n      for (MediaPackageElement element : mp.getCatalogs()) {\n        if (!element.getFlavor().equals(MediaPackageElements.SMIL)) {\n          mp.remove(element);\n        }\n      }\n    }\n\n    // drop attachments the capture agent sent us in favor of Opencast's attachments\n    // e.g. prevent capture agents from modifying security rules of schedules events\n    if (skipAttachments) {\n      for (MediaPackageElement element : mp.getAttachments()) {\n        mp.remove(element);\n      }\n    }\n\n    for (MediaPackageElement element : scheduledMp.getElements()) {\n      if (MediaPackageElement.Type.Publication.equals(element.getElementType())) {\n        // The Asset managed media package may have a publication element for a live event, if retract live has not run yet.\n        // Publications do not have flavors and are never part of the mediapackage from the capture agent.\n        // Therefore, ignore publication element because it is removed when the recorded media is published and causes complications (on short media) if added.\n        logger.debug(\"Ignoring {}, not adding to ingested mediapackage {}\", MediaPackageElement.Type.Publication, mp);\n        continue;\n      } else if (mp.getElementsByFlavor(element.getFlavor()).length > 0) {\n        // The default is to overwrite matching flavored elements in the Asset managed mediapackage (e.g. catalogs)\n        // If isOverwrite is true, changes made from the CA overwrite (update/revert) changes made from the Admin UI.\n        // If isOverwrite is false, changes made from the CA do not overwrite (update/revert) changes made from the Admin UI.\n        // regardless of overwrite, always keep new ingested tracks.\n        if (!isAddOnlyNew || MediaPackageElement.Type.Track.equals(element.getElementType())) {\n          // Allow updates made from the Capture Agent to overwrite existing metadata in Opencast\n          logger.info(\n                  \"Omitting Opencast (Asset Managed) element '{}', replacing with ingested element of same flavor '{}'\",\n                  element,\n                  element.getFlavor());\n          continue;\n        }\n        // Remove flavored element from ingested mp and replaced it with maching element from Asset Managed mediapackage.\n        // This protects updates made from the admin UI during an event capture from being reverted by artifacts from the ingested CA.\n        for (MediaPackageElement el : mp.getElementsByFlavor(element.getFlavor())) {\n          logger.info(\"Omitting ingested element '{}' {}, keeping existing (Asset Managed) element of same flavor '{}'\", el, el.getURI(),\n                  element.getFlavor());\n          mp.remove(el);\n        }\n      }\n      logger.info(\"Adding element {} from scheduled (Asset Managed) event '{}' into ingested mediapackage\", element, mp);\n      mp.add(element);\n    }\n  }\n\n  /**\n   *\n   * The previous OC behaviour is for metadata in the ingested mediapackage to be updated by the\n   * Asset Managed metadata *only* when the field is blank on the ingested mediapackage.\n   * However, that field may have been intentionally emptied by\n   * removing its value from the Capture Agent UI (e.g. Galicaster)\n   *\n   * If isOverwrite is true, metadata values in the ingest mediapackage overwrite Asset Managed metadata.\n   * If isOverwrite is false, Asset Managed metadata is preserved.\n   *\n   * @param mp,\n   *          the inbound ingested mp\n   * @param scheduledMp,\n   *          the existing scheduled mp\n   */\n  private void mergeMediaPackageMetadata(MediaPackage mp, MediaPackage scheduledMp) {\n    // Merge media package fields depending on overwrite setting\n    boolean noOverwrite = (isAddOnlyNew && !skipCatalogs) || skipCatalogs;\n    if ((mp.getDate() == null) || noOverwrite)\n      mp.setDate(scheduledMp.getDate());\n    if (isBlank(mp.getLicense()) || noOverwrite)\n      mp.setLicense(scheduledMp.getLicense());\n    if (isBlank(mp.getSeries()) || noOverwrite)\n      mp.setSeries(scheduledMp.getSeries());\n    if (isBlank(mp.getSeriesTitle()) || noOverwrite)\n      mp.setSeriesTitle(scheduledMp.getSeriesTitle());\n    if (isBlank(mp.getTitle()) || noOverwrite)\n      mp.setTitle(scheduledMp.getTitle());\n\n    if (mp.getSubjects().length <= 0 || noOverwrite) {\n      Arrays.stream(mp.getSubjects()).forEach(mp::removeSubject);\n      for (String subject : scheduledMp.getSubjects()) {\n        mp.addSubject(subject);\n      }\n    }\n    if (noOverwrite || mp.getContributors().length == 0) {\n      Arrays.stream(mp.getContributors()).forEach(mp::removeContributor);\n      for (String contributor : scheduledMp.getContributors()) {\n        mp.addContributor(contributor);\n      }\n    }\n    if (noOverwrite || mp.getCreators().length == 0) {\n      Arrays.stream(mp.getCreators()).forEach(mp::removeCreator);\n      for (String creator : scheduledMp.getCreators()) {\n        mp.addCreator(creator);\n      }\n    }\n  }\n\n  /**\n   * Removes the workflow configuration file prefix from all properties in a map.\n   *\n   * @param properties\n   *          The properties to remove the prefixes from\n   * @return A Map with the same collection of properties without the prefix\n   */\n  private Map<String, String> removePrefixFromProperties(Map<String, String> properties) {\n    Map<String, String> fixedProperties = new HashMap<>();\n    if (properties != null) {\n      for (Entry<String, String> entry : properties.entrySet()) {\n        if (entry.getKey().startsWith(WORKFLOW_CONFIGURATION_PREFIX)) {\n          logger.debug(\"Removing prefix from key '\" + entry.getKey() + \" with value '\" + entry.getValue() + \"'\");\n          fixedProperties.put(entry.getKey().replace(WORKFLOW_CONFIGURATION_PREFIX, \"\"), entry.getValue());\n        } else {\n          fixedProperties.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    return fixedProperties;\n  }\n\n  private WorkflowDefinition getWorkflowDefinition(String workflowDefinitionID, MediaPackage mediapackage)\n          throws NotFoundException, WorkflowDatabaseException, IngestException {\n    // If the workflow definition and instance ID are null, use the default, or throw if there is none\n    if (isBlank(workflowDefinitionID)) {\n      String mediaPackageId = mediapackage.getIdentifier().toString();\n      if (schedulerService != null) {\n        logger.info(\"Determining workflow template for ingested mediapckage {} from capture event {}\", mediapackage,\n                mediaPackageId);\n        try {\n          Map<String, String> recordingProperties = schedulerService.getCaptureAgentConfiguration(mediaPackageId);\n          workflowDefinitionID = recordingProperties.get(CaptureParameters.INGEST_WORKFLOW_DEFINITION);\n          if (isBlank(workflowDefinitionID)) {\n            workflowDefinitionID = defaultWorkflowDefinionId;\n            logger.debug(\"No workflow set. Falling back to default.\");\n          }\n          if (isBlank(workflowDefinitionID)) {\n            throw new IngestException(\"No value found for key '\" + CaptureParameters.INGEST_WORKFLOW_DEFINITION\n                    + \"' from capture event configuration of scheduler event '\" + mediaPackageId + \"'\");\n          }\n          logger.info(\"Ingested event {} will be processed using workflow '{}'\", mediapackage, workflowDefinitionID);\n        } catch (NotFoundException e) {\n          logger.warn(\"Specified capture event {} was not found\", mediaPackageId);\n        } catch (UnauthorizedException e) {\n          throw new IllegalStateException(e);\n        } catch (SchedulerException e) {\n          logger.warn(\"Unable to get the workflow definition id from scheduler event {}\", mediaPackageId, e);\n          throw new IngestException(e);\n        }\n      } else {\n        logger.warn(\n                \"Scheduler service not bound, unable to determine the workflow template to use for ingested mediapckage {}\",\n                mediapackage);\n      }\n\n    } else {\n      logger.info(\"Ingested mediapackage {} is processed using workflow template '{}', specified during ingest\",\n              mediapackage, workflowDefinitionID);\n    }\n\n    // Use the default workflow definition if nothing was determined\n    if (isBlank(workflowDefinitionID) && defaultWorkflowDefinionId != null) {\n      logger.info(\"Using default workflow definition '{}' to process ingested mediapackage {}\",\n              defaultWorkflowDefinionId, mediapackage);\n      workflowDefinitionID = defaultWorkflowDefinionId;\n    }\n\n    // Check if the workflow definition is valid\n    if (StringUtils.isNotBlank(workflowDefinitionID) && StringUtils.isNotBlank(defaultWorkflowDefinionId)) {\n      try {\n        workflowService.getWorkflowDefinitionById(workflowDefinitionID);\n      } catch (WorkflowDatabaseException e) {\n        throw new IngestException(e);\n      } catch (NotFoundException nfe) {\n        logger.warn(\"Workflow definition {} not found, using default workflow {} instead\", workflowDefinitionID,\n                defaultWorkflowDefinionId);\n        workflowDefinitionID = defaultWorkflowDefinionId;\n      }\n    }\n\n    // Have we been able to find a workflow definition id?\n    if (isBlank(workflowDefinitionID)) {\n      ingestStatistics.failed();\n      throw new IllegalStateException(\n              \"Can not ingest a workflow without a workflow definition or an existing instance. No default definition is specified\");\n    }\n\n    // Let's make sure the workflow definition exists\n    return workflowService.getWorkflowDefinitionById(workflowDefinitionID);\n  }\n\n  /**\n   *\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#discardMediaPackage(org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public void discardMediaPackage(MediaPackage mp) throws IOException {\n    String mediaPackageId = mp.getIdentifier().toString();\n    for (MediaPackageElement element : mp.getElements()) {\n      if (!workingFileRepository.delete(mediaPackageId, element.getIdentifier()))\n        logger.warn(\"Unable to find (and hence, delete), this mediapackage element\");\n    }\n    logger.info(\"Successfully discarded media package {}\", mp);\n  }\n\n  protected URI addContentToRepo(MediaPackage mp, String elementId, URI uri) throws IOException {\n    InputStream in = null;\n    HttpResponse response = null;\n    CloseableHttpClient externalHttpClient = null;\n    try {\n      if (uri.toString().startsWith(\"http\")) {\n        HttpGet get = new HttpGet(uri);\n        List<String> clusterUrls = new LinkedList<>();\n        try {\n          // Note that we are not checking ports here.\n          clusterUrls = organizationDirectoryService.getOrganization(uri.toURL()).getServers()\n                          .keySet()\n                          .stream()\n                          .collect(Collectors.toUnmodifiableList());\n        } catch (NotFoundException e) {\n          logger.warn(\"Unable to determine cluster members, will not be able to authenticate any downloads from them\", e);\n        }\n\n        if (uri.toString().matches(downloadSource)) {\n          //NB: We're creating a new client here with *different* auth than the system auth creds\n          externalHttpClient = getAuthedHttpClient();\n          response = externalHttpClient.execute(get);\n        } else if (clusterUrls.contains(uri.getScheme() + \"://\" + uri.getHost())) {\n          // Only using the system-level httpclient and digest credentials against our own servers\n          response = httpClient.execute(get);\n        } else {\n          //NB: No auth here at all\n          externalHttpClient = getNoAuthHttpClient();\n          response = externalHttpClient.execute(get);\n        }\n\n        if (null == response) {\n          // If you get here then chances are you're using a mock httpClient which does not have appropriate\n          // mocking to respond to the URL you are feeding it.  Try adding that URL to the mock and see if that works.\n          throw new IOException(\"Null response object from the http client, refer to code for explanation\");\n        }\n\n        int httpStatusCode = response.getStatusLine().getStatusCode();\n        if (httpStatusCode != 200) {\n          throw new IOException(uri + \" returns http \" + httpStatusCode);\n        }\n        in = response.getEntity().getContent();\n        //If it does not start with file, or we're in test mode (ie, to allow arbitrary file:// access)\n      } else if (!uri.toString().startsWith(\"file\") || testMode) {\n        in = uri.toURL().openStream();\n      } else {\n        throw new IOException(\"Refusing to fetch files from the local filesystem\");\n      }\n      String fileName = FilenameUtils.getName(uri.getPath());\n      if (isBlank(FilenameUtils.getExtension(fileName)))\n        fileName = getContentDispositionFileName(response);\n\n      if (isBlank(FilenameUtils.getExtension(fileName)))\n        throw new IOException(\"No filename extension found: \" + fileName);\n      return addContentToRepo(mp, elementId, fileName, in);\n    } finally {\n      if (in != null) {\n        in.close();\n      }\n      if (externalHttpClient != null) {\n        externalHttpClient.close();\n      }\n      httpClient.close(response);\n    }\n  }\n\n  private String getContentDispositionFileName(HttpResponse response) {\n    if (response == null)\n      return null;\n\n    Header header = response.getFirstHeader(\"Content-Disposition\");\n    ContentDisposition contentDisposition = new ContentDisposition(header.getValue());\n    return contentDisposition.getParameter(\"filename\");\n  }\n\n  private URI addContentToRepo(MediaPackage mp, String elementId, String filename, InputStream file)\n          throws IOException {\n    ProgressInputStream progressInputStream = new ProgressInputStream(file);\n    progressInputStream.addPropertyChangeListener(new PropertyChangeListener() {\n      @Override\n      public void propertyChange(PropertyChangeEvent evt) {\n        long totalNumBytesRead = (Long) evt.getNewValue();\n        long oldTotalNumBytesRead = (Long) evt.getOldValue();\n        ingestStatistics.add(totalNumBytesRead - oldTotalNumBytesRead);\n      }\n    });\n    return workingFileRepository.put(mp.getIdentifier().toString(), elementId, filename, progressInputStream);\n  }\n\n  private MediaPackage addContentToMediaPackage(MediaPackage mp, String elementId, URI uri,\n          MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n    logger.info(\"Adding element of type {} to mediapackage {}\", type, mp);\n    MediaPackageElement mpe = mp.add(uri, type, flavor);\n    mpe.setIdentifier(elementId);\n    return mp;\n  }\n\n  // ---------------------------------------------\n  // --------- bind and unbind bundles ---------\n  // ---------------------------------------------\n  @Reference\n  public void setWorkflowService(WorkflowService workflowService) {\n    this.workflowService = workflowService;\n  }\n\n  @Reference\n  public void setWorkingFileRepository(WorkingFileRepository workingFileRepository) {\n    this.workingFileRepository = workingFileRepository;\n  }\n\n  @Reference\n  public void setSeriesService(SeriesService seriesService) {\n    this.seriesService = seriesService;\n  }\n\n  @Reference\n  public void setDublinCoreService(DublinCoreCatalogService dublinCoreService) {\n    this.dublinCoreService = dublinCoreService;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.job.api.AbstractJobProducer#getServiceRegistry()\n   */\n  @Override\n  protected ServiceRegistry getServiceRegistry() {\n    return serviceRegistry;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.job.api.AbstractJobProducer#process(org.opencastproject.job.api.Job)\n   */\n  @Override\n  protected String process(Job job) throws Exception {\n    throw new IllegalStateException(\"Ingest jobs are not expected to be dispatched\");\n  }\n\n  /**\n   * Callback for setting the security service.\n   *\n   * @param securityService\n   *          the securityService to set\n   */\n  @Reference\n  public void setSecurityService(SecurityService securityService) {\n    this.securityService = securityService;\n  }\n\n  /**\n   * Callback for setting the user directory service.\n   *\n   * @param userDirectoryService\n   *          the userDirectoryService to set\n   */\n  @Reference\n  public void setUserDirectoryService(UserDirectoryService userDirectoryService) {\n    this.userDirectoryService = userDirectoryService;\n  }\n\n  /**\n   * Callback for setting the scheduler service.\n   *\n   * @param schedulerService\n   *          the scheduler service to set\n   */\n  @Reference(\n    policy = ReferencePolicy.DYNAMIC,\n    cardinality = ReferenceCardinality.OPTIONAL,\n    unbind = \"unsetSchedulerService\"\n  )\n  public void setSchedulerService(SchedulerService schedulerService) {\n    this.schedulerService = schedulerService;\n  }\n\n  public void unsetSchedulerService(SchedulerService schedulerService) {\n    this.schedulerService = null;\n  }\n\n  /**\n   * Sets a reference to the organization directory service.\n   *\n   * @param organizationDirectory\n   *          the organization directory\n   */\n  @Reference\n  public void setOrganizationDirectoryService(OrganizationDirectoryService organizationDirectory) {\n    organizationDirectoryService = organizationDirectory;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.job.api.AbstractJobProducer#getSecurityService()\n   */\n  @Override\n  protected SecurityService getSecurityService() {\n    return securityService;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.job.api.AbstractJobProducer#getUserDirectoryService()\n   */\n  @Override\n  protected UserDirectoryService getUserDirectoryService() {\n    return userDirectoryService;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.job.api.AbstractJobProducer#getOrganizationDirectoryService()\n   */\n  @Override\n  protected OrganizationDirectoryService getOrganizationDirectoryService() {\n    return organizationDirectoryService;\n  }\n\n  //Used in testing\n  protected CloseableHttpClient getNoAuthHttpClient() {\n    return HttpClientBuilder.create().build();\n  }\n\n  protected CloseableHttpClient getAuthedHttpClient() {\n    HttpClientBuilder cb = HttpClientBuilder.create();\n    CredentialsProvider provider = new BasicCredentialsProvider();\n    provider.setCredentials(\n      new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT, AuthScope.ANY_REALM, AuthSchemes.DIGEST),\n      new UsernamePasswordCredentials(downloadUser, downloadPassword));\n    return cb.build();\n  }\n\n  private MediaPackage createSmil(MediaPackage mediaPackage) throws IOException, IngestException {\n    Stream<Track> partialTracks = Stream.empty();\n    for (Track track : mediaPackage.getTracks()) {\n      Long startTime = partialTrackStartTimes.getIfPresent(track.getIdentifier());\n      if (startTime == null)\n        continue;\n      partialTracks = partialTracks.append(Opt.nul(track));\n    }\n\n    // No partial track available return without adding SMIL catalog\n    if (partialTracks.isEmpty())\n      return mediaPackage;\n\n    // Inspect the partial tracks\n    List<Track> tracks = partialTracks.map(newEnrichJob(mediaInspectionService).toFn())\n            .map(payloadAsTrack(getServiceRegistry()).toFn())\n            .each(MediaPackageSupport.updateElement(mediaPackage).toFn().toFx()).toList();\n\n    // Create the SMIL document\n    org.w3c.dom.Document smilDocument = SmilUtil.createSmil();\n    for (Track track : tracks) {\n      Long startTime = partialTrackStartTimes.getIfPresent(track.getIdentifier());\n      if (startTime == null) {\n        logger.error(\"No start time found for track {}\", track);\n        throw new IngestException(\"No start time found for track \" + track.getIdentifier());\n      }\n      smilDocument = addSmilTrack(smilDocument, track, startTime);\n      partialTrackStartTimes.invalidate(track.getIdentifier());\n    }\n\n    // Store the SMIL document in the mediapackage\n    return addSmilCatalog(smilDocument, mediaPackage);\n  }\n\n  /**\n   * Adds a SMIL catalog to a mediapackage if it's not already existing.\n   *\n   * @param smilDocument\n   *          the smil document\n   * @param mediaPackage\n   *          the mediapackage to extend with the SMIL catalog\n   * @return the augmented mediapcakge\n   * @throws IOException\n   *           if reading or writing of the SMIL catalog fails\n   * @throws IngestException\n   *           if the SMIL catalog already exists\n   */\n  private MediaPackage addSmilCatalog(org.w3c.dom.Document smilDocument, MediaPackage mediaPackage)\n          throws IOException, IngestException {\n    Option<org.w3c.dom.Document> optSmilDocument = loadSmilDocument(workingFileRepository, mediaPackage);\n    if (optSmilDocument.isSome())\n      throw new IngestException(\"SMIL already exists!\");\n\n    InputStream in = null;\n    try {\n      in = XmlUtil.serializeDocument(smilDocument);\n      String elementId = UUID.randomUUID().toString();\n      URI uri = workingFileRepository.put(mediaPackage.getIdentifier().toString(), elementId, PARTIAL_SMIL_NAME, in);\n      MediaPackageElement mpe = mediaPackage.add(uri, MediaPackageElement.Type.Catalog, MediaPackageElements.SMIL);\n      mpe.setIdentifier(elementId);\n      // Reset the checksum since it changed\n      mpe.setChecksum(null);\n      mpe.setMimeType(MimeTypes.SMIL);\n      return mediaPackage;\n    } finally {\n      IoSupport.closeQuietly(in);\n    }\n  }\n\n  /**\n   * Load a SMIL document of a media package.\n   *\n   * @return the document or none if no media package element found.\n   */\n  private Option<org.w3c.dom.Document> loadSmilDocument(final WorkingFileRepository workingFileRepository,\n          MediaPackage mp) {\n    return mlist(mp.getElements()).filter(MediaPackageSupport.Filters.isSmilCatalog).headOpt()\n            .map(new Function<MediaPackageElement, org.w3c.dom.Document>() {\n              @Override\n              public org.w3c.dom.Document apply(MediaPackageElement mpe) {\n                InputStream in = null;\n                try {\n                  in = workingFileRepository.get(mpe.getMediaPackage().getIdentifier().toString(), mpe.getIdentifier());\n                  return SmilUtil.loadSmilDocument(in, mpe);\n                } catch (Exception e) {\n                  logger.warn(\"Unable to load smil document from catalog '{}'\", mpe, e);\n                  return Misc.chuck(e);\n                } finally {\n                  IOUtils.closeQuietly(in);\n                }\n              }\n            });\n  }\n\n  /**\n   * Adds a SMIL track by a mediapackage track to a SMIL document\n   *\n   * @param smilDocument\n   *          the SMIL document to extend\n   * @param track\n   *          the mediapackage track\n   * @param startTime\n   *          the start time\n   * @return the augmented SMIL document\n   * @throws IngestException\n   *           if the partial flavor type is not valid\n   */\n  private org.w3c.dom.Document addSmilTrack(org.w3c.dom.Document smilDocument, Track track, long startTime)\n          throws IngestException {\n    if (MediaPackageElements.PRESENTER_SOURCE.getType().equals(track.getFlavor().getType())) {\n      return SmilUtil.addTrack(smilDocument, SmilUtil.TrackType.PRESENTER, track.hasVideo(), startTime,\n              track.getDuration(), track.getURI(), track.getIdentifier());\n    } else if (MediaPackageElements.PRESENTATION_SOURCE.getType().equals(track.getFlavor().getType())) {\n      return SmilUtil.addTrack(smilDocument, SmilUtil.TrackType.PRESENTATION, track.hasVideo(), startTime,\n              track.getDuration(), track.getURI(), track.getIdentifier());\n    } else {\n      logger.warn(\"Invalid partial flavor type {} of track {}\", track.getFlavor(), track);\n      throw new IngestException(\n              \"Invalid partial flavor type \" + track.getFlavor().getType() + \" of track \" + track.getURI().toString());\n    }\n  }\n\n  /**\n   * Create a media inspection job for a mediapackage element.\n   *\n   * @param svc the media inspection service\n   * @return a function\n   */\n  public static Function<MediaPackageElement, Job> newEnrichJob(final MediaInspectionService svc) {\n    return new Function.X<MediaPackageElement, Job>() {\n      @Override\n      public Job xapply(MediaPackageElement e) throws Exception {\n        return svc.enrich(e, true);\n      }\n    };\n  }\n\n  /**\n   * Interpret the payload of a completed Job as a MediaPackageElement. Wait for the job to complete if necessary.\n   *\n   * @param reg the service registry\n   * @return a function\n   */\n  public static Function<Job, Track> payloadAsTrack(final ServiceRegistry reg) {\n    return new Function.X<Job, Track>() {\n      @Override\n      public Track xapply(Job job) throws MediaPackageException {\n        waitForJob(reg, none(0L), job);\n        return (Track) MediaPackageElementParser.getFromXml(job.getPayload());\n      }\n    };\n  }\n}\n"], "fixing_code": ["/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.ingest.impl;\n\nimport static org.apache.commons.lang3.StringUtils.isBlank;\nimport static org.opencastproject.util.JobUtil.waitForJob;\nimport static org.opencastproject.util.data.Monadics.mlist;\nimport static org.opencastproject.util.data.Option.none;\n\nimport org.opencastproject.capture.CaptureParameters;\nimport org.opencastproject.ingest.api.IngestException;\nimport org.opencastproject.ingest.api.IngestService;\nimport org.opencastproject.ingest.impl.jmx.IngestStatistics;\nimport org.opencastproject.inspection.api.MediaInspectionService;\nimport org.opencastproject.job.api.AbstractJobProducer;\nimport org.opencastproject.job.api.Job;\nimport org.opencastproject.job.api.Job.Status;\nimport org.opencastproject.mediapackage.EName;\nimport org.opencastproject.mediapackage.MediaPackage;\nimport org.opencastproject.mediapackage.MediaPackageBuilderFactory;\nimport org.opencastproject.mediapackage.MediaPackageElement;\nimport org.opencastproject.mediapackage.MediaPackageElementFlavor;\nimport org.opencastproject.mediapackage.MediaPackageElementParser;\nimport org.opencastproject.mediapackage.MediaPackageElements;\nimport org.opencastproject.mediapackage.MediaPackageException;\nimport org.opencastproject.mediapackage.MediaPackageParser;\nimport org.opencastproject.mediapackage.MediaPackageSupport;\nimport org.opencastproject.mediapackage.Track;\nimport org.opencastproject.mediapackage.identifier.IdImpl;\nimport org.opencastproject.metadata.dublincore.DCMIPeriod;\nimport org.opencastproject.metadata.dublincore.DublinCore;\nimport org.opencastproject.metadata.dublincore.DublinCoreCatalog;\nimport org.opencastproject.metadata.dublincore.DublinCoreCatalogService;\nimport org.opencastproject.metadata.dublincore.DublinCoreValue;\nimport org.opencastproject.metadata.dublincore.EncodingSchemeUtils;\nimport org.opencastproject.scheduler.api.SchedulerException;\nimport org.opencastproject.scheduler.api.SchedulerService;\nimport org.opencastproject.security.api.OrganizationDirectoryService;\nimport org.opencastproject.security.api.SecurityService;\nimport org.opencastproject.security.api.TrustedHttpClient;\nimport org.opencastproject.security.api.UnauthorizedException;\nimport org.opencastproject.security.api.UserDirectoryService;\nimport org.opencastproject.series.api.SeriesService;\nimport org.opencastproject.serviceregistry.api.ServiceRegistry;\nimport org.opencastproject.serviceregistry.api.ServiceRegistryException;\nimport org.opencastproject.smil.api.util.SmilUtil;\nimport org.opencastproject.util.ConfigurationException;\nimport org.opencastproject.util.IoSupport;\nimport org.opencastproject.util.LoadUtil;\nimport org.opencastproject.util.MimeTypes;\nimport org.opencastproject.util.NotFoundException;\nimport org.opencastproject.util.ProgressInputStream;\nimport org.opencastproject.util.XmlSafeParser;\nimport org.opencastproject.util.XmlUtil;\nimport org.opencastproject.util.data.Function;\nimport org.opencastproject.util.data.Option;\nimport org.opencastproject.util.data.functions.Misc;\nimport org.opencastproject.util.jmx.JmxUtil;\nimport org.opencastproject.workflow.api.WorkflowDatabaseException;\nimport org.opencastproject.workflow.api.WorkflowDefinition;\nimport org.opencastproject.workflow.api.WorkflowException;\nimport org.opencastproject.workflow.api.WorkflowInstance;\nimport org.opencastproject.workflow.api.WorkflowService;\nimport org.opencastproject.workingfilerepository.api.WorkingFileRepository;\n\nimport com.entwinemedia.fn.Stream;\nimport com.entwinemedia.fn.data.Opt;\nimport com.google.common.cache.Cache;\nimport com.google.common.cache.CacheBuilder;\n\nimport org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.BooleanUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.cxf.jaxrs.ext.multipart.ContentDisposition;\nimport org.apache.http.Header;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.auth.AuthScope;\nimport org.apache.http.auth.UsernamePasswordCredentials;\nimport org.apache.http.client.CredentialsProvider;\nimport org.apache.http.client.config.AuthSchemes;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.BasicCredentialsProvider;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClientBuilder;\nimport org.osgi.service.cm.ManagedService;\nimport org.osgi.service.component.ComponentContext;\nimport org.osgi.service.component.annotations.Activate;\nimport org.osgi.service.component.annotations.Component;\nimport org.osgi.service.component.annotations.Deactivate;\nimport org.osgi.service.component.annotations.Reference;\nimport org.osgi.service.component.annotations.ReferenceCardinality;\nimport org.osgi.service.component.annotations.ReferencePolicy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.SAXException;\n\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URI;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.Dictionary;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.management.ObjectInstance;\n\n/**\n * Creates and augments Opencast MediaPackages. Stores media into the Working File Repository.\n */\n@Component(\n  immediate = true,\n  service = {\n    IngestService.class,\n    ManagedService.class\n  },\n  property = {\n    \"service.description=Ingest Service\",\n    \"service.pid=org.opencastproject.ingest.impl.IngestServiceImpl\"\n  }\n)\npublic class IngestServiceImpl extends AbstractJobProducer implements IngestService, ManagedService {\n\n  /** The logger */\n  private static final Logger logger = LoggerFactory.getLogger(IngestServiceImpl.class);\n\n  /** The source SMIL name */\n  private static final String PARTIAL_SMIL_NAME = \"source_partial.smil\";\n\n  /** The configuration key that defines the default workflow definition */\n  protected static final String WORKFLOW_DEFINITION_DEFAULT = \"org.opencastproject.workflow.default.definition\";\n\n  /** The workflow configuration property prefix **/\n  protected static final String WORKFLOW_CONFIGURATION_PREFIX = \"org.opencastproject.workflow.config.\";\n\n  /** The key for the legacy mediapackage identifier */\n  public static final String LEGACY_MEDIAPACKAGE_ID_KEY = \"org.opencastproject.ingest.legacy.mediapackage.id\";\n\n  public static final String JOB_TYPE = \"org.opencastproject.ingest\";\n\n  /** Methods that ingest zips create jobs with this operation type */\n  public static final String INGEST_ZIP = \"zip\";\n\n  /** Methods that ingest tracks directly create jobs with this operation type */\n  public static final String INGEST_TRACK = \"track\";\n\n  /** Methods that ingest tracks from a URI create jobs with this operation type */\n  public static final String INGEST_TRACK_FROM_URI = \"uri-track\";\n\n  /** Methods that ingest attachments directly create jobs with this operation type */\n  public static final String INGEST_ATTACHMENT = \"attachment\";\n\n  /** Methods that ingest attachments from a URI create jobs with this operation type */\n  public static final String INGEST_ATTACHMENT_FROM_URI = \"uri-attachment\";\n\n  /** Methods that ingest catalogs directly create jobs with this operation type */\n  public static final String INGEST_CATALOG = \"catalog\";\n\n  /** Methods that ingest catalogs from a URI create jobs with this operation type */\n  public static final String INGEST_CATALOG_FROM_URI = \"uri-catalog\";\n\n  /** The approximate load placed on the system by ingesting a file */\n  public static final float DEFAULT_INGEST_FILE_JOB_LOAD = 0.2f;\n\n  /** The approximate load placed on the system by ingesting a zip file */\n  public static final float DEFAULT_INGEST_ZIP_JOB_LOAD = 0.2f;\n\n  /** The key to look for in the service configuration file to override the {@link DEFAULT_INGEST_FILE_JOB_LOAD} */\n  public static final String FILE_JOB_LOAD_KEY = \"job.load.ingest.file\";\n\n  /** The key to look for in the service configuration file to override the {@link DEFAULT_INGEST_ZIP_JOB_LOAD} */\n  public static final String ZIP_JOB_LOAD_KEY = \"job.load.ingest.zip\";\n\n  /** The source to download from  */\n  public static final String DOWNLOAD_SOURCE = \"org.opencastproject.download.source\";\n\n  /** The user for download from external sources */\n  public static final String DOWNLOAD_USER = \"org.opencastproject.download.user\";\n\n  /** The password for download from external sources */\n  public static final String DOWNLOAD_PASSWORD = \"org.opencastproject.download.password\";\n\n  /** By default, do not allow event ingest to modify existing series metadata */\n  public static final boolean DEFAULT_ALLOW_SERIES_MODIFICATIONS = false;\n\n  /** The default is to preserve existing Opencast flavors during ingest. */\n  public static final boolean DEFAULT_ALLOW_ONLY_NEW_FLAVORS = true;\n\n  /** The default is not to automatically skip attachments and catalogs from capture agent */\n  public static final boolean DEFAULT_SKIP = false;\n\n  /** The maximum length of filenames ingested by Opencast */\n  public static final int FILENAME_LENGTH_MAX = 75;\n\n  /** Managed Property key to allow Opencast series modification during ingest\n   * Deprecated, the param potentially causes an update chain reaction for all\n   * events associated to that series, for each ingest */\n  @Deprecated\n  public static final String MODIFY_OPENCAST_SERIES_KEY = \"org.opencastproject.series.overwrite\";\n\n  /** Managed Property key to allow new flavors of ingested attachments and catalogs\n   * to be added to the existing Opencast mediapackage. But, not catalogs and attachments\n   * that would overwrite existing ones in Opencast.\n   */\n  public static final String ADD_ONLY_NEW_FLAVORS_KEY = \"add.only.new.catalogs.attachments.for.existing.events\";\n\n  /** Control if catalogs sent by capture agents for scheduled events are skipped. */\n  public static final String SKIP_CATALOGS_KEY = \"skip.catalogs.for.existing.events\";\n\n  /** Control if attachments sent by capture agents for scheduled events are skipped. */\n  public static final String SKIP_ATTACHMENTS_KEY = \"skip.attachments.for.existing.events\";\n\n  /** The approximate load placed on the system by ingesting a file */\n  private float ingestFileJobLoad = DEFAULT_INGEST_FILE_JOB_LOAD;\n\n  /** The approximate load placed on the system by ingesting a zip file */\n  private float ingestZipJobLoad = DEFAULT_INGEST_ZIP_JOB_LOAD;\n\n  /** The user for download from external sources */\n  private static String downloadUser = DOWNLOAD_USER;\n\n  /** The password for download from external sources */\n  private static String downloadPassword = DOWNLOAD_PASSWORD;\n\n  /** The external source dns name */\n  private static String downloadSource = DOWNLOAD_SOURCE;\n\n  /** The JMX business object for ingest statistics */\n  private IngestStatistics ingestStatistics = new IngestStatistics();\n\n  /** The JMX bean object instance */\n  private ObjectInstance registerMXBean;\n\n  /** The workflow service */\n  private WorkflowService workflowService;\n\n  /** The working file repository */\n  private WorkingFileRepository workingFileRepository;\n\n  /** The http client */\n  private TrustedHttpClient httpClient;\n\n  /** The series service */\n  private SeriesService seriesService;\n\n  /** The dublin core service */\n  private DublinCoreCatalogService dublinCoreService;\n\n  /** The opencast service registry */\n  private ServiceRegistry serviceRegistry;\n\n  /** The security service */\n  protected SecurityService securityService = null;\n\n  /** The user directory service */\n  protected UserDirectoryService userDirectoryService = null;\n\n  /** The organization directory service */\n  protected OrganizationDirectoryService organizationDirectoryService = null;\n\n  /** The scheduler service */\n  private SchedulerService schedulerService = null;\n\n  /** The media inspection service */\n  private MediaInspectionService mediaInspectionService = null;\n\n  /** The default workflow identifier, if one is configured */\n  protected String defaultWorkflowDefinionId;\n\n  /** The partial track start time map */\n  private Cache<String, Long> partialTrackStartTimes = CacheBuilder.newBuilder().expireAfterWrite(1, TimeUnit.DAYS)\n          .build();\n\n  /** Option to overwrite matching flavors (e.g. series and episode metadata) on ingest,\n   *  tracks are always taken on ingest */\n  protected boolean isAddOnlyNew = DEFAULT_ALLOW_ONLY_NEW_FLAVORS;\n  protected boolean isAllowModifySeries = DEFAULT_ALLOW_SERIES_MODIFICATIONS;\n\n  private boolean skipCatalogs = DEFAULT_SKIP;\n  private boolean skipAttachments = DEFAULT_SKIP;\n\n  protected boolean testMode = false;\n\n  /**\n   * Creates a new ingest service instance.\n   */\n  public IngestServiceImpl() {\n    super(JOB_TYPE);\n  }\n\n  /**\n   * OSGI callback for activating this component\n   *\n   * @param cc\n   *          the osgi component context\n   */\n  @Override\n  @Activate\n  public void activate(ComponentContext cc) {\n    super.activate(cc);\n    logger.info(\"Ingest Service started.\");\n    defaultWorkflowDefinionId = StringUtils.trimToNull(cc.getBundleContext().getProperty(WORKFLOW_DEFINITION_DEFAULT));\n    if (defaultWorkflowDefinionId == null) {\n      defaultWorkflowDefinionId = \"schedule-and-upload\";\n    }\n    registerMXBean = JmxUtil.registerMXBean(ingestStatistics, \"IngestStatistics\");\n  }\n\n  /**\n   * Callback from OSGi on service deactivation.\n   */\n  @Deactivate\n  public void deactivate() {\n    JmxUtil.unregisterMXBean(registerMXBean);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.osgi.service.cm.ManagedService#updated(java.util.Dictionary)\n   *      Retrieve ManagedService configuration, including option to overwrite series\n   */\n  @Override\n  public void updated(Dictionary<String, ?> properties) throws ConfigurationException {\n\n    if (properties == null) {\n      logger.info(\"No configuration available, using defaults\");\n      return;\n    }\n\n    downloadPassword = StringUtils.trimToEmpty((String)properties.get(DOWNLOAD_PASSWORD));\n    downloadUser = StringUtils.trimToEmpty(((String) properties.get(DOWNLOAD_USER)));\n    downloadSource = StringUtils.trimToEmpty(((String) properties.get(DOWNLOAD_SOURCE)));\n\n    skipAttachments = BooleanUtils.toBoolean(Objects.toString(properties.get(SKIP_ATTACHMENTS_KEY),\n            BooleanUtils.toStringTrueFalse(DEFAULT_SKIP)));\n    skipCatalogs = BooleanUtils.toBoolean(Objects.toString(properties.get(SKIP_CATALOGS_KEY),\n            BooleanUtils.toStringTrueFalse(DEFAULT_SKIP)));\n    logger.debug(\"Skip attachments sent by agents for scheduled events: {}\", skipAttachments);\n    logger.debug(\"Skip metadata catalogs sent by agents for scheduled events: {}\", skipCatalogs);\n\n    ingestFileJobLoad = LoadUtil.getConfiguredLoadValue(properties, FILE_JOB_LOAD_KEY, DEFAULT_INGEST_FILE_JOB_LOAD,\n            serviceRegistry);\n    ingestZipJobLoad = LoadUtil.getConfiguredLoadValue(properties, ZIP_JOB_LOAD_KEY, DEFAULT_INGEST_ZIP_JOB_LOAD,\n            serviceRegistry);\n\n    isAllowModifySeries = BooleanUtils.toBoolean(Objects.toString(properties.get(MODIFY_OPENCAST_SERIES_KEY),\n              BooleanUtils.toStringTrueFalse(DEFAULT_ALLOW_SERIES_MODIFICATIONS)));\n    isAddOnlyNew = BooleanUtils.toBoolean(Objects.toString(properties.get(ADD_ONLY_NEW_FLAVORS_KEY),\n            BooleanUtils.toStringTrueFalse(DEFAULT_ALLOW_ONLY_NEW_FLAVORS)));\n    logger.info(\"Only allow new flavored catalogs and attachments on ingest:'{}'\", isAddOnlyNew);\n    logger.info(\"Allowing series modification:'{}'\", isAllowModifySeries);\n  }\n\n  /**\n   * Sets the trusted http client\n   *\n   * @param httpClient\n   *          the http client\n   */\n  @Reference\n  public void setHttpClient(TrustedHttpClient httpClient) {\n    this.httpClient = httpClient;\n  }\n\n  /**\n   * Sets the service registry\n   *\n   * @param serviceRegistry\n   *          the serviceRegistry to set\n   */\n  @Reference\n  public void setServiceRegistry(ServiceRegistry serviceRegistry) {\n    this.serviceRegistry = serviceRegistry;\n  }\n\n  /**\n   * Sets the media inspection service\n   *\n   * @param mediaInspectionService\n   *          the media inspection service to set\n   */\n  @Reference\n  public void setMediaInspectionService(MediaInspectionService mediaInspectionService) {\n    this.mediaInspectionService = mediaInspectionService;\n  }\n\n  public WorkflowInstance addZippedMediaPackage(InputStream zipStream)\n          throws IngestException, IOException, MediaPackageException {\n    try {\n      return addZippedMediaPackage(zipStream, null, null);\n    } catch (NotFoundException e) {\n      throw new IllegalStateException(\"A not found exception was thrown without a lookup\");\n    }\n  }\n\n  @Override\n  public WorkflowInstance addZippedMediaPackage(InputStream zipStream, String wd, Map<String, String> workflowConfig)\n          throws MediaPackageException, IOException, IngestException, NotFoundException {\n    try {\n      return addZippedMediaPackage(zipStream, wd, workflowConfig, null);\n    } catch (UnauthorizedException e) {\n      throw new IllegalStateException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addZippedMediaPackage(java.io.InputStream, java.lang.String,\n   *      java.util.Map, java.lang.Long)\n   */\n  @Override\n  public WorkflowInstance addZippedMediaPackage(InputStream zipStream, String workflowDefinitionId,\n          Map<String, String> workflowConfig, Long workflowInstanceId)\n          throws MediaPackageException, IOException, IngestException, NotFoundException, UnauthorizedException {\n    // Start a job synchronously. We can't keep the open input stream waiting around.\n    Job job = null;\n\n    if (StringUtils.isNotBlank(workflowDefinitionId)) {\n      try {\n        workflowService.getWorkflowDefinitionById(workflowDefinitionId);\n      } catch (WorkflowDatabaseException e) {\n        throw new IngestException(e);\n      } catch (NotFoundException nfe) {\n        logger.warn(\"Workflow definition {} not found, using default workflow {} instead\", workflowDefinitionId,\n                defaultWorkflowDefinionId);\n        workflowDefinitionId = defaultWorkflowDefinionId;\n      }\n    }\n\n    if (workflowInstanceId != null) {\n      logger.warn(\"Deprecated method! Ingesting zipped mediapackage with workflow {}\", workflowInstanceId);\n    } else {\n      logger.info(\"Ingesting zipped mediapackage\");\n    }\n\n    ZipArchiveInputStream zis = null;\n    Set<String> collectionFilenames = new HashSet<>();\n    try {\n      // We don't need anybody to do the dispatching for us. Therefore we need to make sure that the job is never in\n      // QUEUED state but set it to INSTANTIATED in the beginning and then manually switch it to RUNNING.\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_ZIP, null, null, false, ingestZipJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n\n      // Create the working file target collection for this ingest operation\n      String wfrCollectionId = Long.toString(job.getId());\n\n      zis = new ZipArchiveInputStream(zipStream);\n      ZipArchiveEntry entry;\n      MediaPackage mp = null;\n      Map<String, URI> uris = new HashMap<>();\n      // Sequential number to append to file names so that, if two files have the same\n      // name, one does not overwrite the other (see MH-9688)\n      int seq = 1;\n      // Folder name to compare with next one to figure out if there's a root folder\n      String folderName = null;\n      // Indicates if zip has a root folder or not, initialized as true\n      boolean hasRootFolder = true;\n      // While there are entries write them to a collection\n      while ((entry = zis.getNextZipEntry()) != null) {\n        try {\n          if (entry.isDirectory() || entry.getName().contains(\"__MACOSX\"))\n            continue;\n\n          if (entry.getName().endsWith(\"manifest.xml\") || entry.getName().endsWith(\"index.xml\")) {\n            // Build the media package\n            final InputStream is = new ZipEntryInputStream(zis, entry.getSize());\n            mp = MediaPackageParser.getFromXml(IOUtils.toString(is, StandardCharsets.UTF_8));\n          } else {\n            logger.info(\"Storing zip entry {}/{} in working file repository collection '{}'\", job.getId(),\n                    entry.getName(), wfrCollectionId);\n            // Since the directory structure is not being mirrored, makes sure the file\n            // name is different than the previous one(s) by adding a sequential number\n            String fileName = FilenameUtils.getBaseName(entry.getName()) + \"_\" + seq++ + \".\"\n                    + FilenameUtils.getExtension(entry.getName());\n            URI contentUri = workingFileRepository.putInCollection(wfrCollectionId, fileName,\n                    new ZipEntryInputStream(zis, entry.getSize()));\n            collectionFilenames.add(fileName);\n            // Key is the zip entry name as it is\n            String key = entry.getName();\n            uris.put(key, contentUri);\n            ingestStatistics.add(entry.getSize());\n            logger.info(\"Zip entry {}/{} stored at {}\", job.getId(), entry.getName(), contentUri);\n            // Figures out if there's a root folder. Does entry name starts with a folder?\n            int pos = entry.getName().indexOf('/');\n            if (pos == -1) {\n              // No, we can conclude there's no root folder\n              hasRootFolder = false;\n            } else if (hasRootFolder && folderName != null && !folderName.equals(entry.getName().substring(0, pos))) {\n              // Folder name different from previous so there's no root folder\n              hasRootFolder = false;\n            } else if (folderName == null) {\n              // Just initialize folder name\n              folderName = entry.getName().substring(0, pos);\n            }\n          }\n        } catch (IOException e) {\n          logger.warn(\"Unable to process zip entry {}: {}\", entry.getName(), e);\n          throw e;\n        }\n      }\n\n      if (mp == null)\n        throw new MediaPackageException(\"No manifest found in this zip\");\n\n      // Determine the mediapackage identifier\n      if (mp.getIdentifier() == null || isBlank(mp.getIdentifier().toString()))\n        mp.setIdentifier(IdImpl.fromUUID());\n\n      String mediaPackageId = mp.getIdentifier().toString();\n\n      logger.info(\"Ingesting mediapackage {} is named '{}'\", mediaPackageId, mp.getTitle());\n\n      // Make sure there are tracks in the mediapackage\n      if (mp.getTracks().length == 0) {\n        logger.warn(\"Mediapackage {} has no media tracks\", mediaPackageId);\n      }\n\n      // Update the element uris to point to their working file repository location\n      for (MediaPackageElement element : mp.elements()) {\n        // Key has root folder name if there is one\n        URI uri = uris.get((hasRootFolder ? folderName + \"/\" : \"\") + element.getURI().toString());\n\n        if (uri == null)\n          throw new MediaPackageException(\"Unable to map element name '\" + element.getURI() + \"' to workspace uri\");\n        logger.info(\"Ingested mediapackage element {}/{} located at {}\", mediaPackageId, element.getIdentifier(), uri);\n        URI dest = workingFileRepository.moveTo(wfrCollectionId, FilenameUtils.getName(uri.toString()), mediaPackageId,\n                element.getIdentifier(), FilenameUtils.getName(element.getURI().toString()));\n        element.setURI(dest);\n\n        // TODO: This should be triggered somehow instead of being handled here\n        if (MediaPackageElements.SERIES.equals(element.getFlavor())) {\n          logger.info(\"Ingested mediapackage {} contains updated series information\", mediaPackageId);\n          updateSeries(element.getURI());\n        }\n      }\n\n      // Now that all elements are in place, start with ingest\n      logger.info(\"Initiating processing of ingested mediapackage {}\", mediaPackageId);\n      WorkflowInstance workflowInstance = ingest(mp, workflowDefinitionId, workflowConfig, workflowInstanceId);\n      logger.info(\"Ingest of mediapackage {} done\", mediaPackageId);\n      job.setStatus(Job.Status.FINISHED);\n      return workflowInstance;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (MediaPackageException e) {\n      job.setStatus(Job.Status.FAILED, Job.FailureReason.DATA);\n      throw e;\n    } catch (Exception e) {\n      if (e instanceof IngestException)\n        throw (IngestException) e;\n      throw new IngestException(e);\n    } finally {\n      IOUtils.closeQuietly(zis);\n      finallyUpdateJob(job);\n      for (String filename : collectionFilenames) {\n        workingFileRepository.deleteFromCollection(Long.toString(job.getId()), filename, true);\n      }\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#createMediaPackage()\n   */\n  @Override\n  public MediaPackage createMediaPackage() throws MediaPackageException, ConfigurationException {\n    MediaPackage mediaPackage;\n    try {\n      mediaPackage = MediaPackageBuilderFactory.newInstance().newMediaPackageBuilder().createNew();\n    } catch (MediaPackageException e) {\n      logger.error(\"INGEST:Failed to create media package \" + e.getLocalizedMessage());\n      throw e;\n    }\n    mediaPackage.setDate(new Date());\n    logger.info(\"Created mediapackage {}\", mediaPackage);\n    return mediaPackage;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#createMediaPackage()\n   */\n  @Override\n  public MediaPackage createMediaPackage(String mediaPackageId)\n          throws MediaPackageException, ConfigurationException {\n    MediaPackage mediaPackage;\n    try {\n      mediaPackage = MediaPackageBuilderFactory.newInstance().newMediaPackageBuilder()\n              .createNew(new IdImpl(mediaPackageId));\n    } catch (MediaPackageException e) {\n      logger.error(\"INGEST:Failed to create media package \" + e.getLocalizedMessage());\n      throw e;\n    }\n    mediaPackage.setDate(new Date());\n    logger.info(\"Created mediapackage {}\", mediaPackage);\n    return mediaPackage;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addTrack(java.net.URI,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addTrack(URI uri, MediaPackageElementFlavor flavor, MediaPackage mediaPackage)\n          throws IOException, IngestException {\n    String[] tags = null;\n    return this.addTrack(uri, flavor, tags, mediaPackage);\n\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addTrack(java.net.URI,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, String[] ,\n   *      org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addTrack(URI uri, MediaPackageElementFlavor flavor, String[] tags, MediaPackage mediaPackage)\n          throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry\n              .createJob(\n                      JOB_TYPE, INGEST_TRACK_FROM_URI, Arrays.asList(uri.toString(),\n                              flavor == null ? null : flavor.toString(), MediaPackageParser.getAsXml(mediaPackage)),\n                      null, false, ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding track {} from URL {} on mediapackage {}\", elementId, uri, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, uri);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Track,\n              flavor);\n      if (tags != null && tags.length > 0) {\n        MediaPackageElement trackElement = mp.getTrack(elementId);\n        for (String tag : tags) {\n          logger.info(\"Adding Tag: \" + tag + \" to Element: \" + elementId);\n          trackElement.addTag(tag);\n        }\n      }\n\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added track {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (IOException e) {\n      throw e;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addTrack(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addTrack(InputStream in, String fileName, MediaPackageElementFlavor flavor,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    String[] tags = null;\n    return this.addTrack(in, fileName, flavor, tags, mediaPackage);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addTrack(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addTrack(InputStream in, String fileName, MediaPackageElementFlavor flavor, String[] tags,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_TRACK, null, null, false, ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding track {} from input stream on mediapackage {}\", elementId, mediaPackage);\n      if (fileName.length() > FILENAME_LENGTH_MAX) {\n        final String extension = \".\" + FilenameUtils.getExtension(fileName);\n        final int length = Math.max(0, FILENAME_LENGTH_MAX - extension.length());\n        fileName = fileName.substring(0, length) + extension;\n      }\n      URI newUrl = addContentToRepo(mediaPackage, elementId, fileName, in);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Track,\n              flavor);\n      if (tags != null && tags.length > 0) {\n        MediaPackageElement trackElement = mp.getTrack(elementId);\n        for (String tag : tags) {\n          logger.debug(\"Adding tag `{}` to element {}\", tag, elementId);\n          trackElement.addTag(tag);\n        }\n      }\n\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added track {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (IOException e) {\n      throw e;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  @Override\n  public MediaPackage addPartialTrack(URI uri, MediaPackageElementFlavor flavor, long startTime,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(\n              JOB_TYPE,\n              INGEST_TRACK_FROM_URI,\n              Arrays.asList(uri.toString(), flavor == null ? null : flavor.toString(),\n                      MediaPackageParser.getAsXml(mediaPackage)), null, false);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding partial track {} from URL {} on mediapackage {}\", elementId, uri, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, uri);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Track,\n              flavor);\n      job.setStatus(Job.Status.FINISHED);\n      // store startTime\n      partialTrackStartTimes.put(elementId, startTime);\n      logger.debug(\"Added start time {} for track {}\", startTime, elementId);\n      logger.info(\"Successful added partial track {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  @Override\n  public MediaPackage addPartialTrack(InputStream in, String fileName, MediaPackageElementFlavor flavor, long startTime,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_TRACK, null, null, false);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding partial track {} from input stream on mediapackage {}\", elementId, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, fileName, in);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Track,\n              flavor);\n      job.setStatus(Job.Status.FINISHED);\n      // store startTime\n      partialTrackStartTimes.put(elementId, startTime);\n      logger.debug(\"Added start time {} for track {}\", startTime, elementId);\n      logger.info(\"Successful added partial track {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addCatalog(java.net.URI,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addCatalog(URI uri, MediaPackageElementFlavor flavor, MediaPackage mediaPackage)\n          throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_CATALOG_FROM_URI,\n              Arrays.asList(uri.toString(), flavor.toString(), MediaPackageParser.getAsXml(mediaPackage)), null, false,\n              ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding catalog {} from URL {} on mediapackage {}\", elementId, uri, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, uri);\n      if (MediaPackageElements.SERIES.equals(flavor)) {\n        updateSeries(uri);\n      }\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Catalog,\n              flavor);\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added catalog {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  /**\n   * Updates the persistent representation of a series based on a potentially modified dublin core document.\n   *\n   * @param uri\n   *          the URI to the dublin core document containing series metadata.\n   * @return\n   *         true, if the series is created or overwritten, false if the existing series remains intact.\n   * @throws IOException if the series catalog was not found\n   * @throws IngestException if any other exception was encountered\n   */\n  protected boolean updateSeries(URI uri) throws IOException, IngestException {\n    HttpResponse response = null;\n    InputStream in = null;\n    boolean isUpdated = false;\n    try {\n      HttpGet getDc = new HttpGet(uri);\n      response = httpClient.execute(getDc);\n      in = response.getEntity().getContent();\n      DublinCoreCatalog dc = dublinCoreService.load(in);\n      String id = dc.getFirst(DublinCore.PROPERTY_IDENTIFIER);\n      if (id == null) {\n        logger.warn(\"Series dublin core document contains no identifier, rejecting ingested series cagtalog.\");\n      } else {\n        try {\n          try {\n            seriesService.getSeries(id);\n            if (isAllowModifySeries) {\n              // Update existing series\n              seriesService.updateSeries(dc);\n              isUpdated = true;\n              logger.debug(\"Ingest is overwriting the existing series {} with the ingested series\", id);\n            } else {\n              logger.debug(\"Series {} already exists. Ignoring series catalog from ingest.\", id);\n            }\n          } catch (NotFoundException e) {\n            logger.info(\"Creating new series {} with default ACL\", id);\n            seriesService.updateSeries(dc);\n            isUpdated = true;\n          }\n\n        } catch (Exception e) {\n          throw new IngestException(e);\n        }\n      }\n      in.close();\n    } catch (IOException e) {\n      logger.error(\"Error updating series from DublinCoreCatalog: {}\", e.getMessage());\n    } finally {\n      IOUtils.closeQuietly(in);\n      httpClient.close(response);\n    }\n    return isUpdated;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addCatalog(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addCatalog(InputStream in, String fileName, MediaPackageElementFlavor flavor,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    return addCatalog(in, fileName, flavor, null, mediaPackage);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addCatalog(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addCatalog(InputStream in, String fileName, MediaPackageElementFlavor flavor, String[] tags,\n          MediaPackage mediaPackage) throws IOException, IngestException, IllegalArgumentException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_CATALOG, null, null, false, ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      final String elementId = UUID.randomUUID().toString();\n      final String mediaPackageId = mediaPackage.getIdentifier().toString();\n      logger.info(\"Start adding catalog {} from input stream on mediapackage {}\", elementId, mediaPackageId);\n      final URI newUrl = addContentToRepo(mediaPackage, elementId, fileName, in);\n\n      final boolean isJSON;\n      try (InputStream inputStream = workingFileRepository.get(mediaPackageId, elementId)) {\n        try (BufferedReader reader  = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n          // Exception for current BBB integration and Extron SMP351 which is ingesting a JSON array/object as catalog\n          int firstChar = reader.read();\n          isJSON = firstChar == '[' || firstChar == '{';\n        }\n      }\n\n      if (isJSON) {\n        logger.warn(\"Input catalog seems to be JSON. This is a mistake and will fail in future Opencast versions.\"\n            + \"You will likely want to ingest this as a media package attachment instead.\");\n      } else {\n        // Verify XML is not corrupted\n        try {\n          XmlSafeParser.parse(workingFileRepository.get(mediaPackageId, elementId));\n        } catch (SAXException e) {\n          workingFileRepository.delete(mediaPackageId, elementId);\n          throw new IllegalArgumentException(\"Catalog XML is invalid\", e);\n        }\n      }\n\n      if (MediaPackageElements.SERIES.equals(flavor)) {\n        updateSeries(newUrl);\n      }\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Catalog,\n              flavor);\n      if (tags != null && tags.length > 0) {\n        MediaPackageElement trackElement = mp.getCatalog(elementId);\n        for (String tag : tags) {\n          logger.info(\"Adding tag {} to element {}\", tag, elementId);\n          trackElement.addTag(tag);\n        }\n      }\n\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added catalog {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addAttachment(java.net.URI,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addAttachment(URI uri, MediaPackageElementFlavor flavor, MediaPackage mediaPackage)\n          throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_ATTACHMENT_FROM_URI,\n              Arrays.asList(uri.toString(), flavor.toString(), MediaPackageParser.getAsXml(mediaPackage)), null, false,\n              ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding attachment {} from URL {} on mediapackage {}\", elementId, uri, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, uri);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Attachment,\n              flavor);\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added attachment {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addAttachment(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addAttachment(InputStream in, String fileName, MediaPackageElementFlavor flavor, String[] tags,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    Job job = null;\n    try {\n      job = serviceRegistry.createJob(JOB_TYPE, INGEST_ATTACHMENT, null, null, false, ingestFileJobLoad);\n      job.setStatus(Status.RUNNING);\n      job = serviceRegistry.updateJob(job);\n      String elementId = UUID.randomUUID().toString();\n      logger.info(\"Start adding attachment {} from input stream on mediapackage {}\", elementId, mediaPackage);\n      URI newUrl = addContentToRepo(mediaPackage, elementId, fileName, in);\n      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Attachment,\n              flavor);\n      if (tags != null && tags.length > 0) {\n        MediaPackageElement trackElement = mp.getAttachment(elementId);\n        for (String tag : tags) {\n          logger.info(\"Adding Tag: \" + tag + \" to Element: \" + elementId);\n          trackElement.addTag(tag);\n        }\n      }\n      job.setStatus(Job.Status.FINISHED);\n      logger.info(\"Successful added attachment {} on mediapackage {} at URL {}\", elementId, mediaPackage, newUrl);\n      return mp;\n    } catch (ServiceRegistryException e) {\n      throw new IngestException(e);\n    } catch (NotFoundException e) {\n      throw new IngestException(\"Unable to update ingest job\", e);\n    } finally {\n      finallyUpdateJob(job);\n    }\n\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#addAttachment(java.io.InputStream, java.lang.String,\n   *      org.opencastproject.mediapackage.MediaPackageElementFlavor, org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public MediaPackage addAttachment(InputStream in, String fileName, MediaPackageElementFlavor flavor,\n          MediaPackage mediaPackage) throws IOException, IngestException {\n    String[] tags = null;\n    return addAttachment(in, fileName, flavor, tags, mediaPackage);\n  }\n\n  /**\n   *\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#ingest(org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public WorkflowInstance ingest(MediaPackage mp) throws IngestException {\n    try {\n      return ingest(mp, null, null, null);\n    } catch (NotFoundException e) {\n      throw new IngestException(e);\n    } catch (UnauthorizedException e) {\n      throw new IllegalStateException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#ingest(org.opencastproject.mediapackage.MediaPackage,\n   *      java.lang.String, java.util.Map)\n   */\n  @Override\n  public WorkflowInstance ingest(MediaPackage mp, String wd, Map<String, String> properties)\n          throws IngestException, NotFoundException {\n    try {\n      return ingest(mp, wd, properties, null);\n    } catch (UnauthorizedException e) {\n      throw new IllegalStateException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#ingest(org.opencastproject.mediapackage.MediaPackage,\n   *      java.lang.String, java.util.Map, java.lang.Long)\n   */\n  @Override\n  public WorkflowInstance ingest(MediaPackage mp, String workflowDefinitionId, Map<String, String> properties,\n          Long workflowInstanceId) throws IngestException, NotFoundException, UnauthorizedException {\n    // Check for legacy media package id\n    mp = checkForLegacyMediaPackageId(mp, properties);\n\n    try {\n      mp = createSmil(mp);\n    } catch (IOException e) {\n      throw new IngestException(\"Unable to add SMIL Catalog\", e);\n    }\n\n    // Done, update the job status and return the created workflow instance\n    if (workflowInstanceId != null) {\n      logger.warn(\n              \"Resuming workflow {} with ingested mediapackage {} is deprecated, skip resuming and start new workflow\",\n              workflowInstanceId, mp);\n    }\n\n    if (workflowDefinitionId == null) {\n      logger.info(\"Starting a new workflow with ingested mediapackage {} based on the default workflow definition '{}'\",\n              mp, defaultWorkflowDefinionId);\n    } else {\n      logger.info(\"Starting a new workflow with ingested mediapackage {} based on workflow definition '{}'\", mp,\n              workflowDefinitionId);\n    }\n\n    try {\n      // Determine the workflow definition\n      WorkflowDefinition workflowDef = getWorkflowDefinition(workflowDefinitionId, mp);\n\n      // Get the final set of workflow properties\n      properties = mergeWorkflowConfiguration(properties, mp.getIdentifier().toString());\n\n      // Remove potential workflow configuration prefixes from the workflow properties\n      properties = removePrefixFromProperties(properties);\n\n      // Merge scheduled mediapackage with ingested\n      mp = mergeScheduledMediaPackage(mp);\n\n      ingestStatistics.successful();\n      if (workflowDef != null) {\n        logger.info(\"Starting new workflow with ingested mediapackage '{}' using the specified template '{}'\",\n                mp.getIdentifier().toString(), workflowDefinitionId);\n      } else {\n        logger.info(\"Starting new workflow with ingested mediapackage '{}' using the default template '{}'\",\n                mp.getIdentifier().toString(), defaultWorkflowDefinionId);\n      }\n      return workflowService.start(workflowDef, mp, properties);\n    } catch (WorkflowException e) {\n      ingestStatistics.failed();\n      throw new IngestException(e);\n    }\n  }\n\n  @Override\n  public void schedule(MediaPackage mediaPackage, String workflowDefinitionID, Map<String, String> properties)\n          throws IllegalStateException, IngestException, NotFoundException, UnauthorizedException, SchedulerException {\n    MediaPackageElement[] mediaPackageElements = mediaPackage.getElementsByFlavor(MediaPackageElements.EPISODE);\n    if (mediaPackageElements.length != 1) {\n      logger.debug(\"There can be only one (and exactly one) episode dublin core catalog: https://youtu.be/_J3VeogFUOs\");\n      throw new IngestException(\"There can be only one (and exactly one) episode dublin core catalog\");\n    }\n    InputStream inputStream;\n    DublinCoreCatalog dublinCoreCatalog;\n    try {\n      inputStream = workingFileRepository.get(mediaPackage.getIdentifier().toString(),\n              mediaPackageElements[0].getIdentifier());\n      dublinCoreCatalog = dublinCoreService.load(inputStream);\n    } catch (IOException e) {\n      throw new IngestException(e);\n    }\n\n    EName temporal = new EName(DublinCore.TERMS_NS_URI, \"temporal\");\n    List<DublinCoreValue> periods = dublinCoreCatalog.get(temporal);\n    if (periods.size() != 1) {\n      logger.debug(\"There can be only one (and exactly one) period\");\n      throw new IngestException(\"There can be only one (and exactly one) period\");\n    }\n    DCMIPeriod period = EncodingSchemeUtils.decodeMandatoryPeriod(periods.get(0));\n    if (!period.hasStart() || !period.hasEnd()) {\n      logger.debug(\"A scheduled recording needs to have a start and end.\");\n      throw new IngestException(\"A scheduled recording needs to have a start and end.\");\n    }\n    EName createdEName = new EName(DublinCore.TERMS_NS_URI, \"created\");\n    List<DublinCoreValue> created = dublinCoreCatalog.get(createdEName);\n    if (created.size() == 0) {\n      logger.debug(\"Created not set\");\n    } else if (created.size() == 1) {\n      Date date = EncodingSchemeUtils.decodeMandatoryDate(created.get(0));\n      if (date.getTime() != period.getStart().getTime()) {\n        logger.debug(\"start and created date differ ({} vs {})\", date.getTime(), period.getStart().getTime());\n        throw new IngestException(\"Temporal start and created date differ\");\n      }\n    } else {\n      logger.debug(\"There can be only one created date\");\n      throw new IngestException(\"There can be only one created date\");\n    }\n    // spatial\n    EName spatial = new EName(DublinCore.TERMS_NS_URI, \"spatial\");\n    List<DublinCoreValue> captureAgents = dublinCoreCatalog.get(spatial);\n    if (captureAgents.size() != 1) {\n      logger.debug(\"Exactly one capture agent needs to be set\");\n      throw new IngestException(\"Exactly one capture agent needs to be set\");\n    }\n    String captureAgent = captureAgents.get(0).getValue();\n\n    // Go through properties\n    Map<String, String> agentProperties = new HashMap<>();\n    Map<String, String> workflowProperties = new HashMap<>();\n    for (String key : properties.keySet()) {\n      if (key.startsWith(\"org.opencastproject.workflow.config.\")) {\n        workflowProperties.put(key, properties.get(key));\n      } else {\n        agentProperties.put(key, properties.get(key));\n      }\n    }\n    try {\n      schedulerService.addEvent(period.getStart(), period.getEnd(), captureAgent, new HashSet<>(), mediaPackage,\n              workflowProperties, agentProperties, Opt.none());\n    } finally {\n      for (MediaPackageElement mediaPackageElement : mediaPackage.getElements()) {\n        try {\n          workingFileRepository.delete(mediaPackage.getIdentifier().toString(), mediaPackageElement.getIdentifier());\n        } catch (IOException e) {\n          logger.warn(\"Failed to delete media package element\", e);\n        }\n      }\n    }\n  }\n\n  /**\n   * Check whether the mediapackage id is set via the legacy workflow identifier and change the id if existing.\n   *\n   * @param mp\n   *          the mediapackage\n   * @param properties\n   *          the workflow properties\n   * @return the mediapackage\n   */\n  private MediaPackage checkForLegacyMediaPackageId(MediaPackage mp, Map<String, String> properties)\n          throws IngestException {\n    if (properties == null || properties.isEmpty())\n      return mp;\n\n    try {\n      String mediaPackageId = properties.get(LEGACY_MEDIAPACKAGE_ID_KEY);\n      if (StringUtils.isNotBlank(mediaPackageId) && schedulerService != null) {\n        logger.debug(\"Check ingested mediapackage {} for legacy mediapackage identifier {}\",\n                mp.getIdentifier().toString(), mediaPackageId);\n        try {\n          schedulerService.getMediaPackage(mp.getIdentifier().toString());\n          return mp;\n        } catch (NotFoundException e) {\n          logger.info(\"No scheduler mediapackage found with ingested id {}, try legacy mediapackage id {}\",\n                  mp.getIdentifier().toString(), mediaPackageId);\n          try {\n            schedulerService.getMediaPackage(mediaPackageId);\n            logger.info(\"Legacy mediapackage id {} exists, change ingested mediapackage id {} to legacy id\",\n                    mediaPackageId, mp.getIdentifier().toString());\n            mp.setIdentifier(new IdImpl(mediaPackageId));\n            return mp;\n          } catch (NotFoundException e1) {\n            logger.info(\"No scheduler mediapackage found with legacy mediapackage id {}, skip merging\", mediaPackageId);\n          } catch (Exception e1) {\n            logger.error(\"Unable to get event mediapackage from scheduler event {}\", mediaPackageId, e);\n            throw new IngestException(e);\n          }\n        } catch (Exception e) {\n          logger.error(\"Unable to get event mediapackage from scheduler event {}\", mp.getIdentifier().toString(), e);\n          throw new IngestException(e);\n        }\n      }\n      return mp;\n    } finally {\n      properties.remove(LEGACY_MEDIAPACKAGE_ID_KEY);\n    }\n  }\n\n  private Map<String, String> mergeWorkflowConfiguration(Map<String, String> properties, String mediaPackageId) {\n    if (isBlank(mediaPackageId) || schedulerService == null)\n      return properties;\n\n    HashMap<String, String> mergedProperties = new HashMap<>();\n\n    try {\n      Map<String, String> recordingProperties = schedulerService.getCaptureAgentConfiguration(mediaPackageId);\n      logger.debug(\"Restoring workflow properties from scheduler event {}\", mediaPackageId);\n      mergedProperties.putAll(recordingProperties);\n    } catch (SchedulerException e) {\n      logger.warn(\"Unable to get workflow properties from scheduler event {}\", mediaPackageId, e);\n    } catch (NotFoundException e) {\n      logger.info(\"No capture event found for id {}\", mediaPackageId);\n    } catch (UnauthorizedException e) {\n      throw new IllegalStateException(e);\n    }\n\n    if (properties != null) {\n      // Merge the properties, this must be after adding the recording properties\n      logger.debug(\"Merge workflow properties with the one from the scheduler event {}\", mediaPackageId);\n      mergedProperties.putAll(properties);\n    }\n\n    return mergedProperties;\n  }\n\n  /**\n   * Merges the ingested mediapackage with the scheduled mediapackage. The ingested mediapackage takes precedence over\n   * the scheduled mediapackage.\n   *\n   * @param mp\n   *          the ingested mediapackage\n   * @return the merged mediapackage\n   */\n  private MediaPackage mergeScheduledMediaPackage(MediaPackage mp) throws IngestException {\n    if (schedulerService == null) {\n      logger.warn(\"No scheduler service available to merge mediapackage!\");\n      return mp;\n    }\n\n    try {\n      MediaPackage scheduledMp = schedulerService.getMediaPackage(mp.getIdentifier().toString());\n      logger.info(\"Found matching scheduled event for id '{}', merging mediapackage...\", mp.getIdentifier().toString());\n      mergeMediaPackageElements(mp, scheduledMp);\n      mergeMediaPackageMetadata(mp, scheduledMp);\n      return mp;\n    } catch (NotFoundException e) {\n      logger.debug(\"No scheduler mediapackage found with id {}, skip merging\", mp.getIdentifier());\n      return mp;\n    } catch (Exception e) {\n      throw new IngestException(String.format(\"Unable to get event media package from scheduler event %s\",\n              mp.getIdentifier()), e);\n    }\n  }\n\n  /**\n   * Merge different elements from capture agent ingesting mp and Asset manager. Overwrite or replace same flavored\n   * elements depending on the Ingest Service overwrite configuration. Ignore publications (i.e. live publication\n   * channel from Asset Manager) Always keep tracks from the capture agent.\n   *\n   * @param mp\n   *          the medipackage being ingested from the Capture Agent\n   * @param scheduledMp\n   *          the mediapckage that was schedule and managed by the Asset Manager\n   */\n  private void mergeMediaPackageElements(MediaPackage mp, MediaPackage scheduledMp) {\n    // drop catalogs sent by the capture agent in favor of Opencast's own metadata\n    if (skipCatalogs) {\n      for (MediaPackageElement element : mp.getCatalogs()) {\n        if (!element.getFlavor().equals(MediaPackageElements.SMIL)) {\n          mp.remove(element);\n        }\n      }\n    }\n\n    // drop attachments the capture agent sent us in favor of Opencast's attachments\n    // e.g. prevent capture agents from modifying security rules of schedules events\n    if (skipAttachments) {\n      for (MediaPackageElement element : mp.getAttachments()) {\n        mp.remove(element);\n      }\n    }\n\n    for (MediaPackageElement element : scheduledMp.getElements()) {\n      if (MediaPackageElement.Type.Publication.equals(element.getElementType())) {\n        // The Asset managed media package may have a publication element for a live event, if retract live has not run yet.\n        // Publications do not have flavors and are never part of the mediapackage from the capture agent.\n        // Therefore, ignore publication element because it is removed when the recorded media is published and causes complications (on short media) if added.\n        logger.debug(\"Ignoring {}, not adding to ingested mediapackage {}\", MediaPackageElement.Type.Publication, mp);\n        continue;\n      } else if (mp.getElementsByFlavor(element.getFlavor()).length > 0) {\n        // The default is to overwrite matching flavored elements in the Asset managed mediapackage (e.g. catalogs)\n        // If isOverwrite is true, changes made from the CA overwrite (update/revert) changes made from the Admin UI.\n        // If isOverwrite is false, changes made from the CA do not overwrite (update/revert) changes made from the Admin UI.\n        // regardless of overwrite, always keep new ingested tracks.\n        if (!isAddOnlyNew || MediaPackageElement.Type.Track.equals(element.getElementType())) {\n          // Allow updates made from the Capture Agent to overwrite existing metadata in Opencast\n          logger.info(\n                  \"Omitting Opencast (Asset Managed) element '{}', replacing with ingested element of same flavor '{}'\",\n                  element,\n                  element.getFlavor());\n          continue;\n        }\n        // Remove flavored element from ingested mp and replaced it with maching element from Asset Managed mediapackage.\n        // This protects updates made from the admin UI during an event capture from being reverted by artifacts from the ingested CA.\n        for (MediaPackageElement el : mp.getElementsByFlavor(element.getFlavor())) {\n          logger.info(\"Omitting ingested element '{}' {}, keeping existing (Asset Managed) element of same flavor '{}'\", el, el.getURI(),\n                  element.getFlavor());\n          mp.remove(el);\n        }\n      }\n      logger.info(\"Adding element {} from scheduled (Asset Managed) event '{}' into ingested mediapackage\", element, mp);\n      mp.add(element);\n    }\n  }\n\n  /**\n   *\n   * The previous OC behaviour is for metadata in the ingested mediapackage to be updated by the\n   * Asset Managed metadata *only* when the field is blank on the ingested mediapackage.\n   * However, that field may have been intentionally emptied by\n   * removing its value from the Capture Agent UI (e.g. Galicaster)\n   *\n   * If isOverwrite is true, metadata values in the ingest mediapackage overwrite Asset Managed metadata.\n   * If isOverwrite is false, Asset Managed metadata is preserved.\n   *\n   * @param mp,\n   *          the inbound ingested mp\n   * @param scheduledMp,\n   *          the existing scheduled mp\n   */\n  private void mergeMediaPackageMetadata(MediaPackage mp, MediaPackage scheduledMp) {\n    // Merge media package fields depending on overwrite setting\n    boolean noOverwrite = (isAddOnlyNew && !skipCatalogs) || skipCatalogs;\n    if ((mp.getDate() == null) || noOverwrite)\n      mp.setDate(scheduledMp.getDate());\n    if (isBlank(mp.getLicense()) || noOverwrite)\n      mp.setLicense(scheduledMp.getLicense());\n    if (isBlank(mp.getSeries()) || noOverwrite)\n      mp.setSeries(scheduledMp.getSeries());\n    if (isBlank(mp.getSeriesTitle()) || noOverwrite)\n      mp.setSeriesTitle(scheduledMp.getSeriesTitle());\n    if (isBlank(mp.getTitle()) || noOverwrite)\n      mp.setTitle(scheduledMp.getTitle());\n\n    if (mp.getSubjects().length <= 0 || noOverwrite) {\n      Arrays.stream(mp.getSubjects()).forEach(mp::removeSubject);\n      for (String subject : scheduledMp.getSubjects()) {\n        mp.addSubject(subject);\n      }\n    }\n    if (noOverwrite || mp.getContributors().length == 0) {\n      Arrays.stream(mp.getContributors()).forEach(mp::removeContributor);\n      for (String contributor : scheduledMp.getContributors()) {\n        mp.addContributor(contributor);\n      }\n    }\n    if (noOverwrite || mp.getCreators().length == 0) {\n      Arrays.stream(mp.getCreators()).forEach(mp::removeCreator);\n      for (String creator : scheduledMp.getCreators()) {\n        mp.addCreator(creator);\n      }\n    }\n  }\n\n  /**\n   * Removes the workflow configuration file prefix from all properties in a map.\n   *\n   * @param properties\n   *          The properties to remove the prefixes from\n   * @return A Map with the same collection of properties without the prefix\n   */\n  private Map<String, String> removePrefixFromProperties(Map<String, String> properties) {\n    Map<String, String> fixedProperties = new HashMap<>();\n    if (properties != null) {\n      for (Entry<String, String> entry : properties.entrySet()) {\n        if (entry.getKey().startsWith(WORKFLOW_CONFIGURATION_PREFIX)) {\n          logger.debug(\"Removing prefix from key '\" + entry.getKey() + \" with value '\" + entry.getValue() + \"'\");\n          fixedProperties.put(entry.getKey().replace(WORKFLOW_CONFIGURATION_PREFIX, \"\"), entry.getValue());\n        } else {\n          fixedProperties.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    return fixedProperties;\n  }\n\n  private WorkflowDefinition getWorkflowDefinition(String workflowDefinitionID, MediaPackage mediapackage)\n          throws NotFoundException, WorkflowDatabaseException, IngestException {\n    // If the workflow definition and instance ID are null, use the default, or throw if there is none\n    if (isBlank(workflowDefinitionID)) {\n      String mediaPackageId = mediapackage.getIdentifier().toString();\n      if (schedulerService != null) {\n        logger.info(\"Determining workflow template for ingested mediapckage {} from capture event {}\", mediapackage,\n                mediaPackageId);\n        try {\n          Map<String, String> recordingProperties = schedulerService.getCaptureAgentConfiguration(mediaPackageId);\n          workflowDefinitionID = recordingProperties.get(CaptureParameters.INGEST_WORKFLOW_DEFINITION);\n          if (isBlank(workflowDefinitionID)) {\n            workflowDefinitionID = defaultWorkflowDefinionId;\n            logger.debug(\"No workflow set. Falling back to default.\");\n          }\n          if (isBlank(workflowDefinitionID)) {\n            throw new IngestException(\"No value found for key '\" + CaptureParameters.INGEST_WORKFLOW_DEFINITION\n                    + \"' from capture event configuration of scheduler event '\" + mediaPackageId + \"'\");\n          }\n          logger.info(\"Ingested event {} will be processed using workflow '{}'\", mediapackage, workflowDefinitionID);\n        } catch (NotFoundException e) {\n          logger.warn(\"Specified capture event {} was not found\", mediaPackageId);\n        } catch (UnauthorizedException e) {\n          throw new IllegalStateException(e);\n        } catch (SchedulerException e) {\n          logger.warn(\"Unable to get the workflow definition id from scheduler event {}\", mediaPackageId, e);\n          throw new IngestException(e);\n        }\n      } else {\n        logger.warn(\n                \"Scheduler service not bound, unable to determine the workflow template to use for ingested mediapckage {}\",\n                mediapackage);\n      }\n\n    } else {\n      logger.info(\"Ingested mediapackage {} is processed using workflow template '{}', specified during ingest\",\n              mediapackage, workflowDefinitionID);\n    }\n\n    // Use the default workflow definition if nothing was determined\n    if (isBlank(workflowDefinitionID) && defaultWorkflowDefinionId != null) {\n      logger.info(\"Using default workflow definition '{}' to process ingested mediapackage {}\",\n              defaultWorkflowDefinionId, mediapackage);\n      workflowDefinitionID = defaultWorkflowDefinionId;\n    }\n\n    // Check if the workflow definition is valid\n    if (StringUtils.isNotBlank(workflowDefinitionID) && StringUtils.isNotBlank(defaultWorkflowDefinionId)) {\n      try {\n        workflowService.getWorkflowDefinitionById(workflowDefinitionID);\n      } catch (WorkflowDatabaseException e) {\n        throw new IngestException(e);\n      } catch (NotFoundException nfe) {\n        logger.warn(\"Workflow definition {} not found, using default workflow {} instead\", workflowDefinitionID,\n                defaultWorkflowDefinionId);\n        workflowDefinitionID = defaultWorkflowDefinionId;\n      }\n    }\n\n    // Have we been able to find a workflow definition id?\n    if (isBlank(workflowDefinitionID)) {\n      ingestStatistics.failed();\n      throw new IllegalStateException(\n              \"Can not ingest a workflow without a workflow definition or an existing instance. No default definition is specified\");\n    }\n\n    // Let's make sure the workflow definition exists\n    return workflowService.getWorkflowDefinitionById(workflowDefinitionID);\n  }\n\n  /**\n   *\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.ingest.api.IngestService#discardMediaPackage(org.opencastproject.mediapackage.MediaPackage)\n   */\n  @Override\n  public void discardMediaPackage(MediaPackage mp) throws IOException {\n    String mediaPackageId = mp.getIdentifier().toString();\n    for (MediaPackageElement element : mp.getElements()) {\n      if (!workingFileRepository.delete(mediaPackageId, element.getIdentifier()))\n        logger.warn(\"Unable to find (and hence, delete), this mediapackage element\");\n    }\n    logger.info(\"Successfully discarded media package {}\", mp);\n  }\n\n  protected URI addContentToRepo(MediaPackage mp, String elementId, URI uri) throws IOException {\n    InputStream in = null;\n    HttpResponse response = null;\n    CloseableHttpClient externalHttpClient = null;\n    try {\n      if (uri.toString().startsWith(\"http\")) {\n        HttpGet get = new HttpGet(uri);\n        var clusterUrls = securityService.getOrganization().getServers().keySet();\n\n        if (uri.toString().matches(downloadSource)) {\n          //NB: We're creating a new client here with *different* auth than the system auth creds\n          externalHttpClient = getAuthedHttpClient();\n          response = externalHttpClient.execute(get);\n        } else if (clusterUrls.contains(uri.getScheme() + \"://\" + uri.getHost())) {\n          // Only using the system-level httpclient and digest credentials against our own servers\n          response = httpClient.execute(get);\n        } else {\n          //NB: No auth here at all\n          externalHttpClient = getNoAuthHttpClient();\n          response = externalHttpClient.execute(get);\n        }\n\n        if (null == response) {\n          // If you get here then chances are you're using a mock httpClient which does not have appropriate\n          // mocking to respond to the URL you are feeding it.  Try adding that URL to the mock and see if that works.\n          throw new IOException(\"Null response object from the http client, refer to code for explanation\");\n        }\n\n        int httpStatusCode = response.getStatusLine().getStatusCode();\n        if (httpStatusCode != 200) {\n          throw new IOException(uri + \" returns http \" + httpStatusCode);\n        }\n        in = response.getEntity().getContent();\n        //If it does not start with file, or we're in test mode (ie, to allow arbitrary file:// access)\n      } else if (!uri.toString().startsWith(\"file\") || testMode) {\n        in = uri.toURL().openStream();\n      } else {\n        throw new IOException(\"Refusing to fetch files from the local filesystem\");\n      }\n      String fileName = FilenameUtils.getName(uri.getPath());\n      if (isBlank(FilenameUtils.getExtension(fileName)))\n        fileName = getContentDispositionFileName(response);\n\n      if (isBlank(FilenameUtils.getExtension(fileName)))\n        throw new IOException(\"No filename extension found: \" + fileName);\n      return addContentToRepo(mp, elementId, fileName, in);\n    } finally {\n      if (in != null) {\n        in.close();\n      }\n      if (externalHttpClient != null) {\n        externalHttpClient.close();\n      }\n      httpClient.close(response);\n    }\n  }\n\n  private String getContentDispositionFileName(HttpResponse response) {\n    if (response == null)\n      return null;\n\n    Header header = response.getFirstHeader(\"Content-Disposition\");\n    ContentDisposition contentDisposition = new ContentDisposition(header.getValue());\n    return contentDisposition.getParameter(\"filename\");\n  }\n\n  private URI addContentToRepo(MediaPackage mp, String elementId, String filename, InputStream file)\n          throws IOException {\n    ProgressInputStream progressInputStream = new ProgressInputStream(file);\n    progressInputStream.addPropertyChangeListener(new PropertyChangeListener() {\n      @Override\n      public void propertyChange(PropertyChangeEvent evt) {\n        long totalNumBytesRead = (Long) evt.getNewValue();\n        long oldTotalNumBytesRead = (Long) evt.getOldValue();\n        ingestStatistics.add(totalNumBytesRead - oldTotalNumBytesRead);\n      }\n    });\n    return workingFileRepository.put(mp.getIdentifier().toString(), elementId, filename, progressInputStream);\n  }\n\n  private MediaPackage addContentToMediaPackage(MediaPackage mp, String elementId, URI uri,\n          MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {\n    logger.info(\"Adding element of type {} to mediapackage {}\", type, mp);\n    MediaPackageElement mpe = mp.add(uri, type, flavor);\n    mpe.setIdentifier(elementId);\n    return mp;\n  }\n\n  // ---------------------------------------------\n  // --------- bind and unbind bundles ---------\n  // ---------------------------------------------\n  @Reference\n  public void setWorkflowService(WorkflowService workflowService) {\n    this.workflowService = workflowService;\n  }\n\n  @Reference\n  public void setWorkingFileRepository(WorkingFileRepository workingFileRepository) {\n    this.workingFileRepository = workingFileRepository;\n  }\n\n  @Reference\n  public void setSeriesService(SeriesService seriesService) {\n    this.seriesService = seriesService;\n  }\n\n  @Reference\n  public void setDublinCoreService(DublinCoreCatalogService dublinCoreService) {\n    this.dublinCoreService = dublinCoreService;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.job.api.AbstractJobProducer#getServiceRegistry()\n   */\n  @Override\n  protected ServiceRegistry getServiceRegistry() {\n    return serviceRegistry;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.job.api.AbstractJobProducer#process(org.opencastproject.job.api.Job)\n   */\n  @Override\n  protected String process(Job job) throws Exception {\n    throw new IllegalStateException(\"Ingest jobs are not expected to be dispatched\");\n  }\n\n  /**\n   * Callback for setting the security service.\n   *\n   * @param securityService\n   *          the securityService to set\n   */\n  @Reference\n  public void setSecurityService(SecurityService securityService) {\n    this.securityService = securityService;\n  }\n\n  /**\n   * Callback for setting the user directory service.\n   *\n   * @param userDirectoryService\n   *          the userDirectoryService to set\n   */\n  @Reference\n  public void setUserDirectoryService(UserDirectoryService userDirectoryService) {\n    this.userDirectoryService = userDirectoryService;\n  }\n\n  /**\n   * Callback for setting the scheduler service.\n   *\n   * @param schedulerService\n   *          the scheduler service to set\n   */\n  @Reference(\n    policy = ReferencePolicy.DYNAMIC,\n    cardinality = ReferenceCardinality.OPTIONAL,\n    unbind = \"unsetSchedulerService\"\n  )\n  public void setSchedulerService(SchedulerService schedulerService) {\n    this.schedulerService = schedulerService;\n  }\n\n  public void unsetSchedulerService(SchedulerService schedulerService) {\n    this.schedulerService = null;\n  }\n\n  /**\n   * Sets a reference to the organization directory service.\n   *\n   * @param organizationDirectory\n   *          the organization directory\n   */\n  @Reference\n  public void setOrganizationDirectoryService(OrganizationDirectoryService organizationDirectory) {\n    organizationDirectoryService = organizationDirectory;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.job.api.AbstractJobProducer#getSecurityService()\n   */\n  @Override\n  protected SecurityService getSecurityService() {\n    return securityService;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.job.api.AbstractJobProducer#getUserDirectoryService()\n   */\n  @Override\n  protected UserDirectoryService getUserDirectoryService() {\n    return userDirectoryService;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.job.api.AbstractJobProducer#getOrganizationDirectoryService()\n   */\n  @Override\n  protected OrganizationDirectoryService getOrganizationDirectoryService() {\n    return organizationDirectoryService;\n  }\n\n  //Used in testing\n  protected CloseableHttpClient getNoAuthHttpClient() {\n    return HttpClientBuilder.create().build();\n  }\n\n  protected CloseableHttpClient getAuthedHttpClient() {\n    HttpClientBuilder cb = HttpClientBuilder.create();\n    CredentialsProvider provider = new BasicCredentialsProvider();\n    provider.setCredentials(\n      new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT, AuthScope.ANY_REALM, AuthSchemes.DIGEST),\n      new UsernamePasswordCredentials(downloadUser, downloadPassword));\n    return cb.build();\n  }\n\n  private MediaPackage createSmil(MediaPackage mediaPackage) throws IOException, IngestException {\n    Stream<Track> partialTracks = Stream.empty();\n    for (Track track : mediaPackage.getTracks()) {\n      Long startTime = partialTrackStartTimes.getIfPresent(track.getIdentifier());\n      if (startTime == null)\n        continue;\n      partialTracks = partialTracks.append(Opt.nul(track));\n    }\n\n    // No partial track available return without adding SMIL catalog\n    if (partialTracks.isEmpty())\n      return mediaPackage;\n\n    // Inspect the partial tracks\n    List<Track> tracks = partialTracks.map(newEnrichJob(mediaInspectionService).toFn())\n            .map(payloadAsTrack(getServiceRegistry()).toFn())\n            .each(MediaPackageSupport.updateElement(mediaPackage).toFn().toFx()).toList();\n\n    // Create the SMIL document\n    org.w3c.dom.Document smilDocument = SmilUtil.createSmil();\n    for (Track track : tracks) {\n      Long startTime = partialTrackStartTimes.getIfPresent(track.getIdentifier());\n      if (startTime == null) {\n        logger.error(\"No start time found for track {}\", track);\n        throw new IngestException(\"No start time found for track \" + track.getIdentifier());\n      }\n      smilDocument = addSmilTrack(smilDocument, track, startTime);\n      partialTrackStartTimes.invalidate(track.getIdentifier());\n    }\n\n    // Store the SMIL document in the mediapackage\n    return addSmilCatalog(smilDocument, mediaPackage);\n  }\n\n  /**\n   * Adds a SMIL catalog to a mediapackage if it's not already existing.\n   *\n   * @param smilDocument\n   *          the smil document\n   * @param mediaPackage\n   *          the mediapackage to extend with the SMIL catalog\n   * @return the augmented mediapcakge\n   * @throws IOException\n   *           if reading or writing of the SMIL catalog fails\n   * @throws IngestException\n   *           if the SMIL catalog already exists\n   */\n  private MediaPackage addSmilCatalog(org.w3c.dom.Document smilDocument, MediaPackage mediaPackage)\n          throws IOException, IngestException {\n    Option<org.w3c.dom.Document> optSmilDocument = loadSmilDocument(workingFileRepository, mediaPackage);\n    if (optSmilDocument.isSome())\n      throw new IngestException(\"SMIL already exists!\");\n\n    InputStream in = null;\n    try {\n      in = XmlUtil.serializeDocument(smilDocument);\n      String elementId = UUID.randomUUID().toString();\n      URI uri = workingFileRepository.put(mediaPackage.getIdentifier().toString(), elementId, PARTIAL_SMIL_NAME, in);\n      MediaPackageElement mpe = mediaPackage.add(uri, MediaPackageElement.Type.Catalog, MediaPackageElements.SMIL);\n      mpe.setIdentifier(elementId);\n      // Reset the checksum since it changed\n      mpe.setChecksum(null);\n      mpe.setMimeType(MimeTypes.SMIL);\n      return mediaPackage;\n    } finally {\n      IoSupport.closeQuietly(in);\n    }\n  }\n\n  /**\n   * Load a SMIL document of a media package.\n   *\n   * @return the document or none if no media package element found.\n   */\n  private Option<org.w3c.dom.Document> loadSmilDocument(final WorkingFileRepository workingFileRepository,\n          MediaPackage mp) {\n    return mlist(mp.getElements()).filter(MediaPackageSupport.Filters.isSmilCatalog).headOpt()\n            .map(new Function<MediaPackageElement, org.w3c.dom.Document>() {\n              @Override\n              public org.w3c.dom.Document apply(MediaPackageElement mpe) {\n                InputStream in = null;\n                try {\n                  in = workingFileRepository.get(mpe.getMediaPackage().getIdentifier().toString(), mpe.getIdentifier());\n                  return SmilUtil.loadSmilDocument(in, mpe);\n                } catch (Exception e) {\n                  logger.warn(\"Unable to load smil document from catalog '{}'\", mpe, e);\n                  return Misc.chuck(e);\n                } finally {\n                  IOUtils.closeQuietly(in);\n                }\n              }\n            });\n  }\n\n  /**\n   * Adds a SMIL track by a mediapackage track to a SMIL document\n   *\n   * @param smilDocument\n   *          the SMIL document to extend\n   * @param track\n   *          the mediapackage track\n   * @param startTime\n   *          the start time\n   * @return the augmented SMIL document\n   * @throws IngestException\n   *           if the partial flavor type is not valid\n   */\n  private org.w3c.dom.Document addSmilTrack(org.w3c.dom.Document smilDocument, Track track, long startTime)\n          throws IngestException {\n    if (MediaPackageElements.PRESENTER_SOURCE.getType().equals(track.getFlavor().getType())) {\n      return SmilUtil.addTrack(smilDocument, SmilUtil.TrackType.PRESENTER, track.hasVideo(), startTime,\n              track.getDuration(), track.getURI(), track.getIdentifier());\n    } else if (MediaPackageElements.PRESENTATION_SOURCE.getType().equals(track.getFlavor().getType())) {\n      return SmilUtil.addTrack(smilDocument, SmilUtil.TrackType.PRESENTATION, track.hasVideo(), startTime,\n              track.getDuration(), track.getURI(), track.getIdentifier());\n    } else {\n      logger.warn(\"Invalid partial flavor type {} of track {}\", track.getFlavor(), track);\n      throw new IngestException(\n              \"Invalid partial flavor type \" + track.getFlavor().getType() + \" of track \" + track.getURI().toString());\n    }\n  }\n\n  /**\n   * Create a media inspection job for a mediapackage element.\n   *\n   * @param svc the media inspection service\n   * @return a function\n   */\n  public static Function<MediaPackageElement, Job> newEnrichJob(final MediaInspectionService svc) {\n    return new Function.X<MediaPackageElement, Job>() {\n      @Override\n      public Job xapply(MediaPackageElement e) throws Exception {\n        return svc.enrich(e, true);\n      }\n    };\n  }\n\n  /**\n   * Interpret the payload of a completed Job as a MediaPackageElement. Wait for the job to complete if necessary.\n   *\n   * @param reg the service registry\n   * @return a function\n   */\n  public static Function<Job, Track> payloadAsTrack(final ServiceRegistry reg) {\n    return new Function.X<Job, Track>() {\n      @Override\n      public Track xapply(Job job) throws MediaPackageException {\n        waitForJob(reg, none(0L), job);\n        return (Track) MediaPackageElementParser.getFromXml(job.getPayload());\n      }\n    };\n  }\n}\n"], "filenames": ["modules/ingest-service-impl/src/main/java/org/opencastproject/ingest/impl/IngestServiceImpl.java"], "buggy_code_start_loc": [132], "buggy_code_end_loc": [1581], "fixing_code_start_loc": [131], "fixing_code_end_loc": [1570], "type": "CWE-287", "message": "Opencast is a free and open source solution for automated video capture and distribution at scale. Prior to Opencast 10.14 and 11.7, users could pass along URLs for files belonging to organizations other than the user's own, which Opencast would then import into the current organization, bypassing organizational barriers. Attackers must have full access to Opencast's ingest REST interface, and also know internal links to resources in another organization of the same Opencast cluster. Users who do not run a multi-tenant cluster are not affected by this issue. This issue is fixed in Opencast 10.14 and 11.7.", "other": {"cve": {"id": "CVE-2022-29237", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-24T15:15:08.037", "lastModified": "2022-06-07T16:45:46.163", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Opencast is a free and open source solution for automated video capture and distribution at scale. Prior to Opencast 10.14 and 11.7, users could pass along URLs for files belonging to organizations other than the user's own, which Opencast would then import into the current organization, bypassing organizational barriers. Attackers must have full access to Opencast's ingest REST interface, and also know internal links to resources in another organization of the same Opencast cluster. Users who do not run a multi-tenant cluster are not affected by this issue. This issue is fixed in Opencast 10.14 and 11.7."}, {"lang": "es", "value": "Opencast es una soluci\u00f3n gratuita y de c\u00f3digo abierto para la captura y distribuci\u00f3n autom\u00e1tica de v\u00eddeo a escala. En versiones anteriores a Opencast versiones 10.14 y 11.7, los usuarios pod\u00edan pasar URLs de archivos que pertenec\u00edan a organizaciones distintas a la del usuario, que Opencast importaba a la organizaci\u00f3n actual, omitiendo las barreras organizativas. Los atacantes deben tener acceso completo a la interfaz REST de ingesta de Opencast, y tambi\u00e9n conocer los enlaces internos a los recursos de otra organizaci\u00f3n del mismo cl\u00faster de Opencast. Los usuarios que no ejecutan un cl\u00faster multi-tenant no est\u00e1n afectados por este problema. Este problema ha sido corregido en Opencast versiones 10.14 y 11.7"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apereo:opencast:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.14", "matchCriteriaId": "EF6725A1-C8B1-4008-8800-9769EB55D535"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apereo:opencast:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.0", "versionEndExcluding": "11.7", "matchCriteriaId": "D7820F47-8333-4F7D-9D09-8ED7831AE3AD"}]}]}], "references": [{"url": "https://github.com/opencast/opencast/commit/8d5ec1614eed109b812bc27b0c6d3214e456d4e7", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/opencast/opencast/security/advisories/GHSA-qm6v-cg9v-53j3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/opencast/opencast/commit/8d5ec1614eed109b812bc27b0c6d3214e456d4e7"}}