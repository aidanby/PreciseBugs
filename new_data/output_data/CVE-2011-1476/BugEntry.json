{"buggy_code": ["/*\n *\tdev_table.h\n *\n *\tGlobal definitions for device call tables\n *\n *\n * Copyright (C) by Hannu Savolainen 1993-1997\n *\n * OSS/Free for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)\n * Version 2 (June 1991). See the \"COPYING\" file distributed with this software\n * for more info.\n */\n\n\n#ifndef _DEV_TABLE_H_\n#define _DEV_TABLE_H_\n\n#include <linux/spinlock.h>\n/*\n * Sound card numbers 27 to 999. (1 to 26 are defined in soundcard.h)\n * Numbers 1000 to N are reserved for driver's internal use.\n */\n\n#define SNDCARD_DESKPROXL\t\t27\t/* Compaq Deskpro XL */\n#define SNDCARD_VIDC\t\t\t28\t/* ARMs VIDC */\n#define SNDCARD_SBPNP\t\t\t29\n#define SNDCARD_SOFTOSS\t\t\t36\n#define SNDCARD_VMIDI\t\t\t37\n#define SNDCARD_OPL3SA1\t\t\t38\t/* Note: clash in msnd.h */\n#define SNDCARD_OPL3SA1_SB\t\t39\n#define SNDCARD_OPL3SA1_MPU\t\t40\n#define SNDCARD_WAVEFRONT               41\n#define SNDCARD_OPL3SA2                 42\n#define SNDCARD_OPL3SA2_MPU             43\n#define SNDCARD_WAVEARTIST              44\t/* Waveartist */\n#define SNDCARD_OPL3SA2_MSS             45\t/* Originally missed */\n#define SNDCARD_AD1816                  88\n\n/*\n *\tNOTE! \tNOTE!\tNOTE!\tNOTE!\n *\n *\tIf you modify this file, please check the dev_table.c also.\n *\n *\tNOTE! \tNOTE!\tNOTE!\tNOTE!\n */\n\nstruct driver_info \n{\n\tchar *driver_id;\n\tint card_subtype;\t/* Driver specific. Usually 0 */\n\tint card_type;\t\t/*\tFrom soundcard.h\t*/\n\tchar *name;\n\tvoid (*attach) (struct address_info *hw_config);\n\tint (*probe) (struct address_info *hw_config);\n\tvoid (*unload) (struct address_info *hw_config);\n};\n\nstruct card_info \n{\n\tint card_type;\t/* Link (search key) to the driver list */\n\tstruct address_info config;\n\tint enabled;\n\tvoid *for_driver_use;\n};\n\n\n/*\n * Device specific parameters (used only by dmabuf.c)\n */\n#define MAX_SUB_BUFFERS\t\t(32*MAX_REALTIME_FACTOR)\n\n#define DMODE_NONE\t\t0\n#define DMODE_OUTPUT\t\tPCM_ENABLE_OUTPUT\n#define DMODE_INPUT\t\tPCM_ENABLE_INPUT\n\nstruct dma_buffparms \n{\n\tint      dma_mode;\t/* DMODE_INPUT, DMODE_OUTPUT or DMODE_NONE */\n\tint\t closing;\n\n\t/*\n \t * Pointers to raw buffers\n \t */\n\n  \tchar     *raw_buf;\n    \tunsigned long   raw_buf_phys;\n\tint buffsize;\n\n     \t/*\n         * Device state tables\n         */\n\n\tunsigned long flags;\n#define DMA_BUSY\t0x00000001\n#define DMA_RESTART\t0x00000002\n#define DMA_ACTIVE\t0x00000004\n#define DMA_STARTED\t0x00000008\n#define DMA_EMPTY\t0x00000010\t\n#define DMA_ALLOC_DONE\t0x00000020\n#define DMA_SYNCING\t0x00000040\n#define DMA_DIRTY\t0x00000080\n#define DMA_POST\t0x00000100\n#define DMA_NODMA\t0x00000200\n#define DMA_NOTIMEOUT\t0x00000400\n\n\tint      open_mode;\n\n\t/*\n\t * Queue parameters.\n\t */\n\tint      qlen;\n\tint      qhead;\n\tint      qtail;\n\tspinlock_t lock;\n\t\t\n\tint\t cfrag;\t/* Current incomplete fragment (write) */\n\n\tint      nbufs;\n\tint      counts[MAX_SUB_BUFFERS];\n\tint      subdivision;\n\n\tint      fragment_size;\n        int\t needs_reorg;\n\tint\t max_fragments;\n\n\tint\t bytes_in_use;\n\n\tint\t underrun_count;\n\tunsigned long\t byte_counter;\n\tunsigned long\t user_counter;\n\tunsigned long\t max_byte_counter;\n\tint\t data_rate; /* Bytes/second */\n\n\tint\t mapping_flags;\n#define\t\t\tDMA_MAP_MAPPED\t\t0x00000001\n\tchar\tneutral_byte;\n\tint\tdma;\t\t/* DMA channel */\n\n\tint     applic_profile;\t/* Application profile (APF_*) */\n\t/* Interrupt callback stuff */\n\tvoid (*audio_callback) (int dev, int parm);\n\tint callback_parm;\n\n\tint\t buf_flags[MAX_SUB_BUFFERS];\n#define\t\t BUFF_EOF\t\t0x00000001 /* Increment eof count */\n#define\t\t BUFF_DIRTY\t\t0x00000002 /* Buffer written */\n};\n\n/*\n * Structure for use with various microcontrollers and DSP processors \n * in the recent sound cards.\n */\ntypedef struct coproc_operations \n{\n\tchar name[64];\n\tstruct module *owner;\n\tint (*open) (void *devc, int sub_device);\n\tvoid (*close) (void *devc, int sub_device);\n\tint (*ioctl) (void *devc, unsigned int cmd, void __user * arg, int local);\n\tvoid (*reset) (void *devc);\n\n\tvoid *devc;\t\t/* Driver specific info */\n} coproc_operations;\n\nstruct audio_driver \n{\n\tstruct module *owner;\n\tint (*open) (int dev, int mode);\n\tvoid (*close) (int dev);\n\tvoid (*output_block) (int dev, unsigned long buf, \n\t\t\t      int count, int intrflag);\n\tvoid (*start_input) (int dev, unsigned long buf, \n\t\t\t     int count, int intrflag);\n\tint (*ioctl) (int dev, unsigned int cmd, void __user * arg);\n\tint (*prepare_for_input) (int dev, int bufsize, int nbufs);\n\tint (*prepare_for_output) (int dev, int bufsize, int nbufs);\n\tvoid (*halt_io) (int dev);\n\tint (*local_qlen)(int dev);\n\tvoid (*copy_user) (int dev,\n\t\t\tchar *localbuf, int localoffs,\n                        const char __user *userbuf, int useroffs,\n                        int max_in, int max_out,\n                        int *used, int *returned,\n                        int len);\n\tvoid (*halt_input) (int dev);\n\tvoid (*halt_output) (int dev);\n\tvoid (*trigger) (int dev, int bits);\n\tint (*set_speed)(int dev, int speed);\n\tunsigned int (*set_bits)(int dev, unsigned int bits);\n\tshort (*set_channels)(int dev, short channels);\n\tvoid (*postprocess_write)(int dev); \t/* Device spesific postprocessing for written data */\n\tvoid (*preprocess_read)(int dev); \t/* Device spesific preprocessing for read data */\n\tvoid (*mmap)(int dev);\n};\n\nstruct audio_operations \n{\n        char name[128];\n\tint flags;\n#define NOTHING_SPECIAL \t0x00\n#define NEEDS_RESTART\t\t0x01\n#define DMA_AUTOMODE\t\t0x02\n#define DMA_DUPLEX\t\t0x04\n#define DMA_PSEUDO_AUTOMODE\t0x08\n#define DMA_HARDSTOP\t\t0x10\n#define DMA_EXACT\t\t0x40\n#define DMA_NORESET\t\t0x80\n\tint  format_mask;\t/* Bitmask for supported audio formats */\n\tvoid *devc;\t\t/* Driver specific info */\n\tstruct audio_driver *d;\n\tvoid *portc;\t\t/* Driver specific info */\n\tstruct dma_buffparms *dmap_in, *dmap_out;\n\tstruct coproc_operations *coproc;\n\tint mixer_dev;\n\tint enable_bits;\n \tint open_mode;\n\tint go;\n\tint min_fragment;\t/* 0 == unlimited */\n\tint max_fragment;\t/* 0 == unlimited */\n\tint parent_dev;\t\t/* 0 -> no parent, 1 to n -> parent=parent_dev+1 */\n\n\t/* fields formerly in dmabuf.c */\n\twait_queue_head_t in_sleeper;\n\twait_queue_head_t out_sleeper;\n\twait_queue_head_t poll_sleeper;\n\n\t/* fields formerly in audio.c */\n\tint audio_mode;\n\n#define\t\tAM_NONE\t\t0\n#define\t\tAM_WRITE\tOPEN_WRITE\n#define \tAM_READ\t\tOPEN_READ\n\n\tint local_format;\n\tint audio_format;\n\tint local_conversion;\n#define CNV_MU_LAW\t0x00000001\n\n\t/* large structures at the end to keep offsets small */\n\tstruct dma_buffparms dmaps[2];\n};\n\nint *load_mixer_volumes(char *name, int *levels, int present);\n\nstruct mixer_operations \n{\n\tstruct module *owner;\n\tchar id[16];\n\tchar name[64];\n\tint (*ioctl) (int dev, unsigned int cmd, void __user * arg);\n\t\n\tvoid *devc;\n\tint modify_counter;\n};\n\nstruct synth_operations \n{\n\tstruct module *owner;\n\tchar *id;\t/* Unique identifier (ASCII) max 29 char */\n\tstruct synth_info *info;\n\tint midi_dev;\n\tint synth_type;\n\tint synth_subtype;\n\n\tint (*open) (int dev, int mode);\n\tvoid (*close) (int dev);\n\tint (*ioctl) (int dev, unsigned int cmd, void __user * arg);\n\tint (*kill_note) (int dev, int voice, int note, int velocity);\n\tint (*start_note) (int dev, int voice, int note, int velocity);\n\tint (*set_instr) (int dev, int voice, int instr);\n\tvoid (*reset) (int dev);\n\tvoid (*hw_control) (int dev, unsigned char *event);\n\tint (*load_patch) (int dev, int format, const char __user *addr,\n\t     int offs, int count, int pmgr_flag);\n\tvoid (*aftertouch) (int dev, int voice, int pressure);\n\tvoid (*controller) (int dev, int voice, int ctrl_num, int value);\n\tvoid (*panning) (int dev, int voice, int value);\n\tvoid (*volume_method) (int dev, int mode);\n\tvoid (*bender) (int dev, int chn, int value);\n\tint (*alloc_voice) (int dev, int chn, int note, struct voice_alloc_info *alloc);\n\tvoid (*setup_voice) (int dev, int voice, int chn);\n\tint (*send_sysex)(int dev, unsigned char *bytes, int len);\n\n \tstruct voice_alloc_info alloc;\n \tstruct channel_info chn_info[16];\n\tint emulation;\n#define\tEMU_GM\t\t\t1\t/* General MIDI */\n#define\tEMU_XG\t\t\t2\t/* Yamaha XG */\n#define MAX_SYSEX_BUF\t64\n\tunsigned char sysex_buf[MAX_SYSEX_BUF];\n\tint sysex_ptr;\n};\n\nstruct midi_input_info \n{\n\t/* MIDI input scanner variables */\n#define MI_MAX\t10\n\tvolatile int             m_busy;\n    \tunsigned char   m_buf[MI_MAX];\n\tunsigned char\tm_prev_status;\t/* For running status */\n    \tint             m_ptr;\n#define MST_INIT\t\t\t0\n#define MST_DATA\t\t\t1\n#define MST_SYSEX\t\t\t2\n    \tint             m_state;\n    \tint             m_left;\n};\n\nstruct midi_operations \n{\n\tstruct module *owner;\n\tstruct midi_info info;\n\tstruct synth_operations *converter;\n\tstruct midi_input_info in_info;\n\tint (*open) (int dev, int mode,\n\t\tvoid (*inputintr)(int dev, unsigned char data),\n\t\tvoid (*outputintr)(int dev)\n\t\t);\n\tvoid (*close) (int dev);\n\tint (*ioctl) (int dev, unsigned int cmd, void __user * arg);\n\tint (*outputc) (int dev, unsigned char data);\n\tint (*start_read) (int dev);\n\tint (*end_read) (int dev);\n\tvoid (*kick)(int dev);\n\tint (*command) (int dev, unsigned char *data);\n\tint (*buffer_status) (int dev);\n\tint (*prefix_cmd) (int dev, unsigned char status);\n\tstruct coproc_operations *coproc;\n\tvoid *devc;\n};\n\nstruct sound_lowlev_timer \n{\n\tint dev;\n\tint priority;\n\tunsigned int (*tmr_start)(int dev, unsigned int usecs);\n\tvoid (*tmr_disable)(int dev);\n\tvoid (*tmr_restart)(int dev);\n};\n\nstruct sound_timer_operations \n{\n\tstruct module *owner;\n\tstruct sound_timer_info info;\n\tint priority;\n\tint devlink;\n\tint (*open)(int dev, int mode);\n\tvoid (*close)(int dev);\n\tint (*event)(int dev, unsigned char *ev);\n\tunsigned long (*get_time)(int dev);\n\tint (*ioctl) (int dev, unsigned int cmd, void __user * arg);\n\tvoid (*arm_timer)(int dev, long time);\n};\n\nextern struct sound_timer_operations default_sound_timer;\n\nextern struct audio_operations *audio_devs[MAX_AUDIO_DEV];\nextern int num_audiodevs;\nextern struct mixer_operations *mixer_devs[MAX_MIXER_DEV];\nextern int num_mixers;\nextern struct synth_operations *synth_devs[MAX_SYNTH_DEV+MAX_MIDI_DEV];\nextern int num_synths;\nextern struct midi_operations *midi_devs[MAX_MIDI_DEV];\nextern int num_midis;\nextern struct sound_timer_operations * sound_timer_devs[MAX_TIMER_DEV];\nextern int num_sound_timers;\n\nextern int sound_map_buffer (int dev, struct dma_buffparms *dmap, buffmem_desc *info);\nvoid sound_timer_init (struct sound_lowlev_timer *t, char *name);\nvoid sound_dma_intr (int dev, struct dma_buffparms *dmap, int chan);\n\n#define AUDIO_DRIVER_VERSION\t2\n#define MIXER_DRIVER_VERSION\t2\nint sound_install_audiodrv(int vers, char *name, struct audio_driver *driver,\n\t\t\tint driver_size, int flags, unsigned int format_mask,\n\t\t\tvoid *devc, int dma1, int dma2);\nint sound_install_mixer(int vers, char *name, struct mixer_operations *driver,\n\t\t\tint driver_size, void *devc);\n\nvoid sound_unload_audiodev(int dev);\nvoid sound_unload_mixerdev(int dev);\nvoid sound_unload_mididev(int dev);\nvoid sound_unload_synthdev(int dev);\nvoid sound_unload_timerdev(int dev);\nint sound_alloc_mixerdev(void);\nint sound_alloc_timerdev(void);\nint sound_alloc_synthdev(void);\nint sound_alloc_mididev(void);\n#endif\t/* _DEV_TABLE_H_ */\n\n", "/*\n * sound/oss/midi_synth.c\n *\n * High level midi sequencer manager for dumb MIDI interfaces.\n */\n/*\n * Copyright (C) by Hannu Savolainen 1993-1997\n *\n * OSS/Free for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)\n * Version 2 (June 1991). See the \"COPYING\" file distributed with this software\n * for more info.\n */\n/*\n * Thomas Sailer   : ioctl code reworked (vmalloc/vfree removed)\n * Andrew Veliath  : fixed running status in MIDI input state machine\n */\n#define USE_SEQ_MACROS\n#define USE_SIMPLE_MACROS\n\n#include \"sound_config.h\"\n\n#define _MIDI_SYNTH_C_\n\n#include \"midi_synth.h\"\n\nstatic int      midi2synth[MAX_MIDI_DEV];\nstatic int      sysex_state[MAX_MIDI_DEV] =\n{0};\nstatic unsigned char prev_out_status[MAX_MIDI_DEV];\n\n#define STORE(cmd) \\\n{ \\\n  int len; \\\n  unsigned char obuf[8]; \\\n  cmd; \\\n  seq_input_event(obuf, len); \\\n}\n\n#define _seqbuf obuf\n#define _seqbufptr 0\n#define _SEQ_ADVBUF(x) len=x\n\nvoid\ndo_midi_msg(int synthno, unsigned char *msg, int mlen)\n{\n\tswitch (msg[0] & 0xf0)\n\t  {\n\t  case 0x90:\n\t\t  if (msg[2] != 0)\n\t\t    {\n\t\t\t    STORE(SEQ_START_NOTE(synthno, msg[0] & 0x0f, msg[1], msg[2]));\n\t\t\t    break;\n\t\t    }\n\t\t  msg[2] = 64;\n\n\t  case 0x80:\n\t\t  STORE(SEQ_STOP_NOTE(synthno, msg[0] & 0x0f, msg[1], msg[2]));\n\t\t  break;\n\n\t  case 0xA0:\n\t\t  STORE(SEQ_KEY_PRESSURE(synthno, msg[0] & 0x0f, msg[1], msg[2]));\n\t\t  break;\n\n\t  case 0xB0:\n\t\t  STORE(SEQ_CONTROL(synthno, msg[0] & 0x0f,\n\t\t\t\t    msg[1], msg[2]));\n\t\t  break;\n\n\t  case 0xC0:\n\t\t  STORE(SEQ_SET_PATCH(synthno, msg[0] & 0x0f, msg[1]));\n\t\t  break;\n\n\t  case 0xD0:\n\t\t  STORE(SEQ_CHN_PRESSURE(synthno, msg[0] & 0x0f, msg[1]));\n\t\t  break;\n\n\t  case 0xE0:\n\t\t  STORE(SEQ_BENDER(synthno, msg[0] & 0x0f,\n\t\t\t      (msg[1] & 0x7f) | ((msg[2] & 0x7f) << 7)));\n\t\t  break;\n\n\t  default:\n\t\t  /* printk( \"MPU: Unknown midi channel message %02x\\n\",  msg[0]); */\n\t\t  ;\n\t  }\n}\nEXPORT_SYMBOL(do_midi_msg);\n\nstatic void\nmidi_outc(int midi_dev, int data)\n{\n\tint             timeout;\n\n\tfor (timeout = 0; timeout < 3200; timeout++)\n\t\tif (midi_devs[midi_dev]->outputc(midi_dev, (unsigned char) (data & 0xff)))\n\t\t  {\n\t\t\t  if (data & 0x80)\t/*\n\t\t\t\t\t\t * Status byte\n\t\t\t\t\t\t */\n\t\t\t\t  prev_out_status[midi_dev] =\n\t\t\t\t      (unsigned char) (data & 0xff);\t/*\n\t\t\t\t\t\t\t\t\t * Store for running status\n\t\t\t\t\t\t\t\t\t */\n\t\t\t  return;\t/*\n\t\t\t\t\t * Mission complete\n\t\t\t\t\t */\n\t\t  }\n\t/*\n\t * Sorry! No space on buffers.\n\t */\n\tprintk(\"Midi send timed out\\n\");\n}\n\nstatic int\nprefix_cmd(int midi_dev, unsigned char status)\n{\n\tif ((char *) midi_devs[midi_dev]->prefix_cmd == NULL)\n\t\treturn 1;\n\n\treturn midi_devs[midi_dev]->prefix_cmd(midi_dev, status);\n}\n\nstatic void\nmidi_synth_input(int orig_dev, unsigned char data)\n{\n\tint             dev;\n\tstruct midi_input_info *inc;\n\n\tstatic unsigned char len_tab[] =\t/* # of data bytes following a status\n\t\t\t\t\t\t */\n\t{\n\t\t2,\t\t/* 8x */\n\t\t2,\t\t/* 9x */\n\t\t2,\t\t/* Ax */\n\t\t2,\t\t/* Bx */\n\t\t1,\t\t/* Cx */\n\t\t1,\t\t/* Dx */\n\t\t2,\t\t/* Ex */\n\t\t0\t\t/* Fx */\n\t};\n\n\tif (orig_dev < 0 || orig_dev > num_midis || midi_devs[orig_dev] == NULL)\n\t\treturn;\n\n\tif (data == 0xfe)\t/* Ignore active sensing */\n\t\treturn;\n\n\tdev = midi2synth[orig_dev];\n\tinc = &midi_devs[orig_dev]->in_info;\n\n\tswitch (inc->m_state)\n\t  {\n\t  case MST_INIT:\n\t\t  if (data & 0x80)\t/* MIDI status byte */\n\t\t    {\n\t\t\t    if ((data & 0xf0) == 0xf0)\t/* Common message */\n\t\t\t      {\n\t\t\t\t      switch (data)\n\t\t\t\t\t{\n\t\t\t\t\tcase 0xf0:\t/* Sysex */\n\t\t\t\t\t\tinc->m_state = MST_SYSEX;\n\t\t\t\t\t\tbreak;\t/* Sysex */\n\n\t\t\t\t\tcase 0xf1:\t/* MTC quarter frame */\n\t\t\t\t\tcase 0xf3:\t/* Song select */\n\t\t\t\t\t\tinc->m_state = MST_DATA;\n\t\t\t\t\t\tinc->m_ptr = 1;\n\t\t\t\t\t\tinc->m_left = 1;\n\t\t\t\t\t\tinc->m_buf[0] = data;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 0xf2:\t/* Song position pointer */\n\t\t\t\t\t\tinc->m_state = MST_DATA;\n\t\t\t\t\t\tinc->m_ptr = 1;\n\t\t\t\t\t\tinc->m_left = 2;\n\t\t\t\t\t\tinc->m_buf[0] = data;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tinc->m_buf[0] = data;\n\t\t\t\t\t\tinc->m_ptr = 1;\n\t\t\t\t\t\tdo_midi_msg(dev, inc->m_buf, inc->m_ptr);\n\t\t\t\t\t\tinc->m_ptr = 0;\n\t\t\t\t\t\tinc->m_left = 0;\n\t\t\t\t\t}\n\t\t\t    } else\n\t\t\t      {\n\t\t\t\t      inc->m_state = MST_DATA;\n\t\t\t\t      inc->m_ptr = 1;\n\t\t\t\t      inc->m_left = len_tab[(data >> 4) - 8];\n\t\t\t\t      inc->m_buf[0] = inc->m_prev_status = data;\n\t\t\t      }\n\t\t    } else if (inc->m_prev_status & 0x80) {\n\t\t\t    /* Data byte (use running status) */\n\t\t\t    inc->m_ptr = 2;\n\t\t\t    inc->m_buf[1] = data;\n\t\t\t    inc->m_buf[0] = inc->m_prev_status;\n\t\t\t    inc->m_left = len_tab[(inc->m_buf[0] >> 4) - 8] - 1;\n\t\t\t    if (inc->m_left > 0)\n\t\t\t\t    inc->m_state = MST_DATA; /* Not done yet */\n\t\t\t    else {\n\t\t\t\t    inc->m_state = MST_INIT;\n\t\t\t\t    do_midi_msg(dev, inc->m_buf, inc->m_ptr);\n\t\t\t\t    inc->m_ptr = 0;\n\t\t\t    }\n\t\t    }\n\t\t  break;\t/* MST_INIT */\n\n\t  case MST_DATA:\n\t\t  inc->m_buf[inc->m_ptr++] = data;\n\t\t  if (--inc->m_left <= 0)\n\t\t    {\n\t\t\t    inc->m_state = MST_INIT;\n\t\t\t    do_midi_msg(dev, inc->m_buf, inc->m_ptr);\n\t\t\t    inc->m_ptr = 0;\n\t\t    }\n\t\t  break;\t/* MST_DATA */\n\n\t  case MST_SYSEX:\n\t\t  if (data == 0xf7)\t/* Sysex end */\n\t\t    {\n\t\t\t    inc->m_state = MST_INIT;\n\t\t\t    inc->m_left = 0;\n\t\t\t    inc->m_ptr = 0;\n\t\t    }\n\t\t  break;\t/* MST_SYSEX */\n\n\t  default:\n\t\t  printk(\"MIDI%d: Unexpected state %d (%02x)\\n\", orig_dev, inc->m_state, (int) data);\n\t\t  inc->m_state = MST_INIT;\n\t  }\n}\n\nstatic void\nleave_sysex(int dev)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tint             timeout = 0;\n\n\tif (!sysex_state[dev])\n\t\treturn;\n\n\tsysex_state[dev] = 0;\n\n\twhile (!midi_devs[orig_dev]->outputc(orig_dev, 0xf7) &&\n\t       timeout < 1000)\n\t\ttimeout++;\n\n\tsysex_state[dev] = 0;\n}\n\nstatic void\nmidi_synth_output(int dev)\n{\n\t/*\n\t * Currently NOP\n\t */\n}\n\nint midi_synth_ioctl(int dev, unsigned int cmd, void __user *arg)\n{\n\t/*\n\t * int orig_dev = synth_devs[dev]->midi_dev;\n\t */\n\n\tswitch (cmd) {\n\n\tcase SNDCTL_SYNTH_INFO:\n\t\tif (__copy_to_user(arg, synth_devs[dev]->info, sizeof(struct synth_info)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t\t\n\tcase SNDCTL_SYNTH_MEMAVL:\n\t\treturn 0x7fffffff;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL(midi_synth_ioctl);\n\nint\nmidi_synth_kill_note(int dev, int channel, int note, int velocity)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tint             msg, chn;\n\n\tif (note < 0 || note > 127)\n\t\treturn 0;\n\tif (channel < 0 || channel > 15)\n\t\treturn 0;\n\tif (velocity < 0)\n\t\tvelocity = 0;\n\tif (velocity > 127)\n\t\tvelocity = 127;\n\n\tleave_sysex(dev);\n\n\tmsg = prev_out_status[orig_dev] & 0xf0;\n\tchn = prev_out_status[orig_dev] & 0x0f;\n\n\tif (chn == channel && ((msg == 0x90 && velocity == 64) || msg == 0x80))\n\t  {\t\t\t/*\n\t\t\t\t * Use running status\n\t\t\t\t */\n\t\t  if (!prefix_cmd(orig_dev, note))\n\t\t\t  return 0;\n\n\t\t  midi_outc(orig_dev, note);\n\n\t\t  if (msg == 0x90)\t/*\n\t\t\t\t\t * Running status = Note on\n\t\t\t\t\t */\n\t\t\t  midi_outc(orig_dev, 0);\t/*\n\t\t\t\t\t\t\t   * Note on with velocity 0 == note\n\t\t\t\t\t\t\t   * off\n\t\t\t\t\t\t\t */\n\t\t  else\n\t\t\t  midi_outc(orig_dev, velocity);\n\t} else\n\t  {\n\t\t  if (velocity == 64)\n\t\t    {\n\t\t\t    if (!prefix_cmd(orig_dev, 0x90 | (channel & 0x0f)))\n\t\t\t\t    return 0;\n\t\t\t    midi_outc(orig_dev, 0x90 | (channel & 0x0f));\t/*\n\t\t\t\t\t\t\t\t\t\t * Note on\n\t\t\t\t\t\t\t\t\t\t */\n\t\t\t    midi_outc(orig_dev, note);\n\t\t\t    midi_outc(orig_dev, 0);\t/*\n\t\t\t\t\t\t\t * Zero G\n\t\t\t\t\t\t\t */\n\t\t  } else\n\t\t    {\n\t\t\t    if (!prefix_cmd(orig_dev, 0x80 | (channel & 0x0f)))\n\t\t\t\t    return 0;\n\t\t\t    midi_outc(orig_dev, 0x80 | (channel & 0x0f));\t/*\n\t\t\t\t\t\t\t\t\t\t * Note off\n\t\t\t\t\t\t\t\t\t\t */\n\t\t\t    midi_outc(orig_dev, note);\n\t\t\t    midi_outc(orig_dev, velocity);\n\t\t    }\n\t  }\n\n\treturn 0;\n}\nEXPORT_SYMBOL(midi_synth_kill_note);\n\nint\nmidi_synth_set_instr(int dev, int channel, int instr_no)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\n\tif (instr_no < 0 || instr_no > 127)\n\t\tinstr_no = 0;\n\tif (channel < 0 || channel > 15)\n\t\treturn 0;\n\n\tleave_sysex(dev);\n\n\tif (!prefix_cmd(orig_dev, 0xc0 | (channel & 0x0f)))\n\t\treturn 0;\n\tmidi_outc(orig_dev, 0xc0 | (channel & 0x0f));\t/*\n\t\t\t\t\t\t\t * Program change\n\t\t\t\t\t\t\t */\n\tmidi_outc(orig_dev, instr_no);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(midi_synth_set_instr);\n\nint\nmidi_synth_start_note(int dev, int channel, int note, int velocity)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tint             msg, chn;\n\n\tif (note < 0 || note > 127)\n\t\treturn 0;\n\tif (channel < 0 || channel > 15)\n\t\treturn 0;\n\tif (velocity < 0)\n\t\tvelocity = 0;\n\tif (velocity > 127)\n\t\tvelocity = 127;\n\n\tleave_sysex(dev);\n\n\tmsg = prev_out_status[orig_dev] & 0xf0;\n\tchn = prev_out_status[orig_dev] & 0x0f;\n\n\tif (chn == channel && msg == 0x90)\n\t  {\t\t\t/*\n\t\t\t\t * Use running status\n\t\t\t\t */\n\t\t  if (!prefix_cmd(orig_dev, note))\n\t\t\t  return 0;\n\t\t  midi_outc(orig_dev, note);\n\t\t  midi_outc(orig_dev, velocity);\n\t} else\n\t  {\n\t\t  if (!prefix_cmd(orig_dev, 0x90 | (channel & 0x0f)))\n\t\t\t  return 0;\n\t\t  midi_outc(orig_dev, 0x90 | (channel & 0x0f));\t\t/*\n\t\t\t\t\t\t\t\t\t * Note on\n\t\t\t\t\t\t\t\t\t */\n\t\t  midi_outc(orig_dev, note);\n\t\t  midi_outc(orig_dev, velocity);\n\t  }\n\treturn 0;\n}\nEXPORT_SYMBOL(midi_synth_start_note);\n\nvoid\nmidi_synth_reset(int dev)\n{\n\n\tleave_sysex(dev);\n}\nEXPORT_SYMBOL(midi_synth_reset);\n\nint\nmidi_synth_open(int dev, int mode)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tint             err;\n\tstruct midi_input_info *inc;\n\n\tif (orig_dev < 0 || orig_dev >= num_midis || midi_devs[orig_dev] == NULL)\n\t\treturn -ENXIO;\n\n\tmidi2synth[orig_dev] = dev;\n\tsysex_state[dev] = 0;\n\tprev_out_status[orig_dev] = 0;\n\n\tif ((err = midi_devs[orig_dev]->open(orig_dev, mode,\n\t\t\t       midi_synth_input, midi_synth_output)) < 0)\n\t\treturn err;\n\tinc = &midi_devs[orig_dev]->in_info;\n\n\t/* save_flags(flags);\n\tcli(); \n\tdon't know against what irqhandler to protect*/\n\tinc->m_busy = 0;\n\tinc->m_state = MST_INIT;\n\tinc->m_ptr = 0;\n\tinc->m_left = 0;\n\tinc->m_prev_status = 0x00;\n\t/* restore_flags(flags); */\n\n\treturn 1;\n}\nEXPORT_SYMBOL(midi_synth_open);\n\nvoid\nmidi_synth_close(int dev)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\n\tleave_sysex(dev);\n\n\t/*\n\t * Shut up the synths by sending just single active sensing message.\n\t */\n\tmidi_devs[orig_dev]->outputc(orig_dev, 0xfe);\n\n\tmidi_devs[orig_dev]->close(orig_dev);\n}\nEXPORT_SYMBOL(midi_synth_close);\n\nvoid\nmidi_synth_hw_control(int dev, unsigned char *event)\n{\n}\nEXPORT_SYMBOL(midi_synth_hw_control);\n\nint\nmidi_synth_load_patch(int dev, int format, const char __user *addr,\n\t\t      int offs, int count, int pmgr_flag)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\n\tstruct sysex_info sysex;\n\tint             i;\n\tunsigned long   left, src_offs, eox_seen = 0;\n\tint             first_byte = 1;\n\tint             hdr_size = (unsigned long) &sysex.data[0] - (unsigned long) &sysex;\n\n\tleave_sysex(dev);\n\n\tif (!prefix_cmd(orig_dev, 0xf0))\n\t\treturn 0;\n\n\tif (format != SYSEX_PATCH)\n\t{\n/*\t\t  printk(\"MIDI Error: Invalid patch format (key) 0x%x\\n\", format);*/\n\t\t  return -EINVAL;\n\t}\n\tif (count < hdr_size)\n\t{\n/*\t\tprintk(\"MIDI Error: Patch header too short\\n\");*/\n\t\treturn -EINVAL;\n\t}\n\tcount -= hdr_size;\n\n\t/*\n\t * Copy the header from user space but ignore the first bytes which have\n\t * been transferred already.\n\t */\n\n\tif(copy_from_user(&((char *) &sysex)[offs], &(addr)[offs], hdr_size - offs))\n\t\treturn -EFAULT;\n \n \tif (count < sysex.len)\n\t{\n/*\t\tprintk(KERN_WARNING \"MIDI Warning: Sysex record too short (%d<%d)\\n\", count, (int) sysex.len);*/\n\t\tsysex.len = count;\n\t}\n  \tleft = sysex.len;\n  \tsrc_offs = 0;\n\n\tfor (i = 0; i < left && !signal_pending(current); i++)\n\t{\n\t\tunsigned char   data;\n\n\t\tif (get_user(data,\n\t\t    (unsigned char __user *)(addr + hdr_size + i)))\n\t\t\treturn -EFAULT;\n\n\t\teox_seen = (i > 0 && data & 0x80);\t/* End of sysex */\n\n\t\tif (eox_seen && data != 0xf7)\n\t\t\tdata = 0xf7;\n\n\t\tif (i == 0)\n\t\t{\n\t\t\tif (data != 0xf0)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"midi_synth: Sysex start missing\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\twhile (!midi_devs[orig_dev]->outputc(orig_dev, (unsigned char) (data & 0xff)) &&\n\t\t\t!signal_pending(current))\n\t\t\tschedule();\n\n\t\tif (!first_byte && data & 0x80)\n\t\t\treturn 0;\n\t\tfirst_byte = 0;\n\t}\n\n\tif (!eox_seen)\n\t\tmidi_outc(orig_dev, 0xf7);\n\treturn 0;\n}\nEXPORT_SYMBOL(midi_synth_load_patch);\n\nvoid midi_synth_panning(int dev, int channel, int pressure)\n{\n}\nEXPORT_SYMBOL(midi_synth_panning);\n\nvoid midi_synth_aftertouch(int dev, int channel, int pressure)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tint             msg, chn;\n\n\tif (pressure < 0 || pressure > 127)\n\t\treturn;\n\tif (channel < 0 || channel > 15)\n\t\treturn;\n\n\tleave_sysex(dev);\n\n\tmsg = prev_out_status[orig_dev] & 0xf0;\n\tchn = prev_out_status[orig_dev] & 0x0f;\n\n\tif (msg != 0xd0 || chn != channel)\t/*\n\t\t\t\t\t\t * Test for running status\n\t\t\t\t\t\t */\n\t  {\n\t\t  if (!prefix_cmd(orig_dev, 0xd0 | (channel & 0x0f)))\n\t\t\t  return;\n\t\t  midi_outc(orig_dev, 0xd0 | (channel & 0x0f));\t\t/*\n\t\t\t\t\t\t\t\t\t * Channel pressure\n\t\t\t\t\t\t\t\t\t */\n\t} else if (!prefix_cmd(orig_dev, pressure))\n\t\treturn;\n\n\tmidi_outc(orig_dev, pressure);\n}\nEXPORT_SYMBOL(midi_synth_aftertouch);\n\nvoid\nmidi_synth_controller(int dev, int channel, int ctrl_num, int value)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tint             chn, msg;\n\n\tif (ctrl_num < 0 || ctrl_num > 127)\n\t\treturn;\n\tif (channel < 0 || channel > 15)\n\t\treturn;\n\n\tleave_sysex(dev);\n\n\tmsg = prev_out_status[orig_dev] & 0xf0;\n\tchn = prev_out_status[orig_dev] & 0x0f;\n\n\tif (msg != 0xb0 || chn != channel)\n\t  {\n\t\t  if (!prefix_cmd(orig_dev, 0xb0 | (channel & 0x0f)))\n\t\t\t  return;\n\t\t  midi_outc(orig_dev, 0xb0 | (channel & 0x0f));\n\t} else if (!prefix_cmd(orig_dev, ctrl_num))\n\t\treturn;\n\n\tmidi_outc(orig_dev, ctrl_num);\n\tmidi_outc(orig_dev, value & 0x7f);\n}\nEXPORT_SYMBOL(midi_synth_controller);\n\nvoid\nmidi_synth_bender(int dev, int channel, int value)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tint             msg, prev_chn;\n\n\tif (channel < 0 || channel > 15)\n\t\treturn;\n\n\tif (value < 0 || value > 16383)\n\t\treturn;\n\n\tleave_sysex(dev);\n\n\tmsg = prev_out_status[orig_dev] & 0xf0;\n\tprev_chn = prev_out_status[orig_dev] & 0x0f;\n\n\tif (msg != 0xd0 || prev_chn != channel)\t\t/*\n\t\t\t\t\t\t\t * Test for running status\n\t\t\t\t\t\t\t */\n\t  {\n\t\t  if (!prefix_cmd(orig_dev, 0xe0 | (channel & 0x0f)))\n\t\t\t  return;\n\t\t  midi_outc(orig_dev, 0xe0 | (channel & 0x0f));\n\t} else if (!prefix_cmd(orig_dev, value & 0x7f))\n\t\treturn;\n\n\tmidi_outc(orig_dev, value & 0x7f);\n\tmidi_outc(orig_dev, (value >> 7) & 0x7f);\n}\nEXPORT_SYMBOL(midi_synth_bender);\n\nvoid\nmidi_synth_setup_voice(int dev, int voice, int channel)\n{\n}\nEXPORT_SYMBOL(midi_synth_setup_voice);\n\nint\nmidi_synth_send_sysex(int dev, unsigned char *bytes, int len)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tint             i;\n\n\tfor (i = 0; i < len; i++)\n\t  {\n\t\t  switch (bytes[i])\n\t\t    {\n\t\t    case 0xf0:\t/* Start sysex */\n\t\t\t    if (!prefix_cmd(orig_dev, 0xf0))\n\t\t\t\t    return 0;\n\t\t\t    sysex_state[dev] = 1;\n\t\t\t    break;\n\n\t\t    case 0xf7:\t/* End sysex */\n\t\t\t    if (!sysex_state[dev])\t/* Orphan sysex end */\n\t\t\t\t    return 0;\n\t\t\t    sysex_state[dev] = 0;\n\t\t\t    break;\n\n\t\t    default:\n\t\t\t    if (!sysex_state[dev])\n\t\t\t\t    return 0;\n\n\t\t\t    if (bytes[i] & 0x80)\t/* Error. Another message before sysex end */\n\t\t\t      {\n\t\t\t\t      bytes[i] = 0xf7;\t/* Sysex end */\n\t\t\t\t      sysex_state[dev] = 0;\n\t\t\t      }\n\t\t    }\n\n\t\t  if (!midi_devs[orig_dev]->outputc(orig_dev, bytes[i]))\n\t\t    {\n/*\n * Hardware level buffer is full. Abort the sysex message.\n */\n\n\t\t\t    int             timeout = 0;\n\n\t\t\t    bytes[i] = 0xf7;\n\t\t\t    sysex_state[dev] = 0;\n\n\t\t\t    while (!midi_devs[orig_dev]->outputc(orig_dev, bytes[i]) &&\n\t\t\t\t   timeout < 1000)\n\t\t\t\t    timeout++;\n\t\t    }\n\t\t  if (!sysex_state[dev])\n\t\t\t  return 0;\n\t  }\n\n\treturn 0;\n}\nEXPORT_SYMBOL(midi_synth_send_sysex);\n\n", "int midi_synth_ioctl (int dev,\n\t    unsigned int cmd, void __user * arg);\nint midi_synth_kill_note (int dev, int channel, int note, int velocity);\nint midi_synth_set_instr (int dev, int channel, int instr_no);\nint midi_synth_start_note (int dev, int channel, int note, int volume);\nvoid midi_synth_reset (int dev);\nint midi_synth_open (int dev, int mode);\nvoid midi_synth_close (int dev);\nvoid midi_synth_hw_control (int dev, unsigned char *event);\nint midi_synth_load_patch (int dev, int format, const char __user * addr,\n\t\t int offs, int count, int pmgr_flag);\nvoid midi_synth_panning (int dev, int channel, int pressure);\nvoid midi_synth_aftertouch (int dev, int channel, int pressure);\nvoid midi_synth_controller (int dev, int channel, int ctrl_num, int value);\nvoid midi_synth_bender (int dev, int chn, int value);\nvoid midi_synth_setup_voice (int dev, int voice, int chn);\nint midi_synth_send_sysex(int dev, unsigned char *bytes,int len);\n\n#ifndef _MIDI_SYNTH_C_\nstatic struct synth_info std_synth_info =\n{MIDI_SYNTH_NAME, 0, SYNTH_TYPE_MIDI, 0, 0, 128, 0, 128, MIDI_SYNTH_CAPS};\n\nstatic struct synth_operations std_midi_synth =\n{\n\t.owner\t\t= THIS_MODULE,\n\t.id\t\t= \"MIDI\",\n\t.info\t\t= &std_synth_info,\n\t.midi_dev\t= 0,\n\t.synth_type\t= SYNTH_TYPE_MIDI,\n\t.synth_subtype\t= 0,\n\t.open\t\t= midi_synth_open,\n\t.close\t\t= midi_synth_close,\n\t.ioctl\t\t= midi_synth_ioctl,\n\t.kill_note\t= midi_synth_kill_note,\n\t.start_note\t= midi_synth_start_note,\n\t.set_instr\t= midi_synth_set_instr,\n\t.reset\t\t= midi_synth_reset,\n\t.hw_control\t= midi_synth_hw_control,\n\t.load_patch\t= midi_synth_load_patch,\n\t.aftertouch\t= midi_synth_aftertouch,\n\t.controller\t= midi_synth_controller,\n\t.panning\t\t= midi_synth_panning,\n\t.bender\t\t= midi_synth_bender,\n\t.setup_voice\t= midi_synth_setup_voice,\n\t.send_sysex\t= midi_synth_send_sysex\n};\n#endif\n", "/*\n * sound/oss/opl3.c\n *\n * A low level driver for Yamaha YM3812 and OPL-3 -chips\n *\n *\n * Copyright (C) by Hannu Savolainen 1993-1997\n *\n * OSS/Free for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)\n * Version 2 (June 1991). See the \"COPYING\" file distributed with this software\n * for more info.\n *\n *\n * Changes\n *\tThomas Sailer   \tioctl code reworked (vmalloc/vfree removed)\n *\tAlan Cox\t\tmodularisation, fixed sound_mem allocs.\n *\tChristoph Hellwig\tAdapted to module_init/module_exit\n *\tArnaldo C. de Melo\tget rid of check_region, use request_region for\n *\t\t\t\tOPL4, release it on exit, some cleanups.\n *\n * Status\n *\tBelieved to work. Badly needs rewriting a bit to support multiple\n *\tOPL3 devices.\n */\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n\n/*\n * Major improvements to the FM handling 30AUG92 by Rob Hooft,\n * hooft@chem.ruu.nl\n */\n\n#include \"sound_config.h\"\n\n#include \"opl3_hw.h\"\n\n#define MAX_VOICE\t18\n#define OFFS_4OP\t11\n\nstruct voice_info\n{\n\tunsigned char   keyon_byte;\n\tlong            bender;\n\tlong            bender_range;\n\tunsigned long   orig_freq;\n\tunsigned long   current_freq;\n\tint             volume;\n\tint             mode;\n\tint             panning;\t/* 0xffff means not set */\n};\n\ntypedef struct opl_devinfo\n{\n\tint             base;\n\tint             left_io, right_io;\n\tint             nr_voice;\n\tint             lv_map[MAX_VOICE];\n\n\tstruct voice_info voc[MAX_VOICE];\n\tstruct voice_alloc_info *v_alloc;\n\tstruct channel_info *chn_info;\n\n\tstruct sbi_instrument i_map[SBFM_MAXINSTR];\n\tstruct sbi_instrument *act_i[MAX_VOICE];\n\n\tstruct synth_info fm_info;\n\n\tint             busy;\n\tint             model;\n\tunsigned char   cmask;\n\n\tint             is_opl4;\n} opl_devinfo;\n\nstatic struct opl_devinfo *devc = NULL;\n\nstatic int      detected_model;\n\nstatic int      store_instr(int instr_no, struct sbi_instrument *instr);\nstatic void     freq_to_fnum(int freq, int *block, int *fnum);\nstatic void     opl3_command(int io_addr, unsigned int addr, unsigned int val);\nstatic int      opl3_kill_note(int dev, int voice, int note, int velocity);\n\nstatic void enter_4op_mode(void)\n{\n\tint i;\n\tstatic int v4op[MAX_VOICE] = {\n\t\t0, 1, 2, 9, 10, 11, 6, 7, 8, 15, 16, 17\n\t};\n\n\tdevc->cmask = 0x3f;\t/* Connect all possible 4 OP voice operators */\n\topl3_command(devc->right_io, CONNECTION_SELECT_REGISTER, 0x3f);\n\n\tfor (i = 0; i < 3; i++)\n\t\tpv_map[i].voice_mode = 4;\n\tfor (i = 3; i < 6; i++)\n\t\tpv_map[i].voice_mode = 0;\n\n\tfor (i = 9; i < 12; i++)\n\t\tpv_map[i].voice_mode = 4;\n\tfor (i = 12; i < 15; i++)\n\t\tpv_map[i].voice_mode = 0;\n\n\tfor (i = 0; i < 12; i++)\n\t\tdevc->lv_map[i] = v4op[i];\n\tdevc->v_alloc->max_voice = devc->nr_voice = 12;\n}\n\nstatic int opl3_ioctl(int dev, unsigned int cmd, void __user * arg)\n{\n\tstruct sbi_instrument ins;\n\t\n\tswitch (cmd) {\n\t\tcase SNDCTL_FM_LOAD_INSTR:\n\t\t\tprintk(KERN_WARNING \"Warning: Obsolete ioctl(SNDCTL_FM_LOAD_INSTR) used. Fix the program.\\n\");\n\t\t\tif (copy_from_user(&ins, arg, sizeof(ins)))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR) {\n\t\t\t\tprintk(KERN_WARNING \"FM Error: Invalid instrument number %d\\n\", ins.channel);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\treturn store_instr(ins.channel, &ins);\n\n\t\tcase SNDCTL_SYNTH_INFO:\n\t\t\tdevc->fm_info.nr_voices = (devc->nr_voice == 12) ? 6 : devc->nr_voice;\n\t\t\tif (copy_to_user(arg, &devc->fm_info, sizeof(devc->fm_info)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\n\t\tcase SNDCTL_SYNTH_MEMAVL:\n\t\t\treturn 0x7fffffff;\n\n\t\tcase SNDCTL_FM_4OP_ENABLE:\n\t\t\tif (devc->model == 2)\n\t\t\t\tenter_4op_mode();\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n}\n\nstatic int opl3_detect(int ioaddr)\n{\n\t/*\n\t * This function returns 1 if the FM chip is present at the given I/O port\n\t * The detection algorithm plays with the timer built in the FM chip and\n\t * looks for a change in the status register.\n\t *\n\t * Note! The timers of the FM chip are not connected to AdLib (and compatible)\n\t * boards.\n\t *\n\t * Note2! The chip is initialized if detected.\n\t */\n\n\tunsigned char stat1, signature;\n\tint i;\n\n\tif (devc != NULL)\n\t{\n\t\tprintk(KERN_ERR \"opl3: Only one OPL3 supported.\\n\");\n\t\treturn 0;\n\t}\n\n\tdevc = kzalloc(sizeof(*devc), GFP_KERNEL);\n\n\tif (devc == NULL)\n\t{\n\t\tprintk(KERN_ERR \"opl3: Can't allocate memory for the device control \"\n\t\t\t\"structure \\n \");\n\t\treturn 0;\n\t}\n\n\tstrcpy(devc->fm_info.name, \"OPL2\");\n\n\tif (!request_region(ioaddr, 4, devc->fm_info.name)) {\n\t\tprintk(KERN_WARNING \"opl3: I/O port 0x%x already in use\\n\", ioaddr);\n\t\tgoto cleanup_devc;\n\t}\n\n\tdevc->base = ioaddr;\n\n\t/* Reset timers 1 and 2 */\n\topl3_command(ioaddr, TIMER_CONTROL_REGISTER, TIMER1_MASK | TIMER2_MASK);\n\n\t/* Reset the IRQ of the FM chip */\n\topl3_command(ioaddr, TIMER_CONTROL_REGISTER, IRQ_RESET);\n\n\tsignature = stat1 = inb(ioaddr);\t/* Status register */\n\n\tif (signature != 0x00 && signature != 0x06 && signature != 0x02 &&\n\t\tsignature != 0x0f)\n\t{\n\t\tMDB(printk(KERN_INFO \"OPL3 not detected %x\\n\", signature));\n\t\tgoto cleanup_region;\n\t}\n\n\tif (signature == 0x06)\t\t/* OPL2 */\n\t{\n\t\tdetected_model = 2;\n\t}\n\telse if (signature == 0x00 || signature == 0x0f)\t/* OPL3 or OPL4 */\n\t{\n\t\tunsigned char tmp;\n\n\t\tdetected_model = 3;\n\n\t\t/*\n\t\t * Detect availability of OPL4 (_experimental_). Works probably\n\t\t * only after a cold boot. In addition the OPL4 port\n\t\t * of the chip may not be connected to the PC bus at all.\n\t\t */\n\n\t\topl3_command(ioaddr + 2, OPL3_MODE_REGISTER, 0x00);\n\t\topl3_command(ioaddr + 2, OPL3_MODE_REGISTER, OPL3_ENABLE | OPL4_ENABLE);\n\n\t\tif ((tmp = inb(ioaddr)) == 0x02)\t/* Have a OPL4 */\n\t\t{\n\t\t\tdetected_model = 4;\n\t\t}\n\n\t\tif (request_region(ioaddr - 8, 2, \"OPL4\"))\t/* OPL4 port was free */\n\t\t{\n\t\t\tint tmp;\n\n\t\t\toutb((0x02), ioaddr - 8);\t/* Select OPL4 ID register */\n\t\t\tudelay(10);\n\t\t\ttmp = inb(ioaddr - 7);\t\t/* Read it */\n\t\t\tudelay(10);\n\n\t\t\tif (tmp == 0x20)\t/* OPL4 should return 0x20 here */\n\t\t\t{\n\t\t\t\tdetected_model = 4;\n\t\t\t\toutb((0xF8), ioaddr - 8);\t/* Select OPL4 FM mixer control */\n\t\t\t\tudelay(10);\n\t\t\t\toutb((0x1B), ioaddr - 7);\t/* Write value */\n\t\t\t\tudelay(10);\n\t\t\t}\n\t\t\telse\n\t\t\t{ /* release OPL4 port */\n\t\t\t\trelease_region(ioaddr - 8, 2);\n\t\t\t\tdetected_model = 3;\n\t\t\t}\n\t\t}\n\t\topl3_command(ioaddr + 2, OPL3_MODE_REGISTER, 0);\n\t}\n\tfor (i = 0; i < 9; i++)\n\t\topl3_command(ioaddr, KEYON_BLOCK + i, 0);\t/*\n\t\t\t\t\t\t\t\t * Note off\n\t\t\t\t\t\t\t\t */\n\n\topl3_command(ioaddr, TEST_REGISTER, ENABLE_WAVE_SELECT);\n\topl3_command(ioaddr, PERCOSSION_REGISTER, 0x00);\t/*\n\t\t\t\t\t\t\t\t * Melodic mode.\n\t\t\t\t\t\t\t\t */\n\treturn 1;\ncleanup_region:\n\trelease_region(ioaddr, 4);\ncleanup_devc:\n\tkfree(devc);\n\tdevc = NULL;\n\treturn 0;\n}\n\nstatic int opl3_kill_note  (int devno, int voice, int note, int velocity)\n{\n\t struct physical_voice_info *map;\n\n\t if (voice < 0 || voice >= devc->nr_voice)\n\t\t return 0;\n\n\t devc->v_alloc->map[voice] = 0;\n\n\t map = &pv_map[devc->lv_map[voice]];\n\t DEB(printk(\"Kill note %d\\n\", voice));\n\n\t if (map->voice_mode == 0)\n\t\t return 0;\n\n\t opl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num, devc->voc[voice].keyon_byte & ~0x20);\n\t devc->voc[voice].keyon_byte = 0;\n\t devc->voc[voice].bender = 0;\n\t devc->voc[voice].volume = 64;\n\t devc->voc[voice].panning = 0xffff;\t/* Not set */\n\t devc->voc[voice].bender_range = 200;\n\t devc->voc[voice].orig_freq = 0;\n\t devc->voc[voice].current_freq = 0;\n\t devc->voc[voice].mode = 0;\n\t return 0;\n}\n\n#define HIHAT\t\t\t0\n#define CYMBAL\t\t\t1\n#define TOMTOM\t\t\t2\n#define SNARE\t\t\t3\n#define BDRUM\t\t\t4\n#define UNDEFINED\t\tTOMTOM\n#define DEFAULT\t\t\tTOMTOM\n\nstatic int store_instr(int instr_no, struct sbi_instrument *instr)\n{\n\tif (instr->key != FM_PATCH && (instr->key != OPL3_PATCH || devc->model != 2))\n\t\tprintk(KERN_WARNING \"FM warning: Invalid patch format field (key) 0x%x\\n\", instr->key);\n\tmemcpy((char *) &(devc->i_map[instr_no]), (char *) instr, sizeof(*instr));\n\treturn 0;\n}\n\nstatic int opl3_set_instr  (int dev, int voice, int instr_no)\n{\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn 0;\n\tif (instr_no < 0 || instr_no >= SBFM_MAXINSTR)\n\t\tinstr_no = 0;\t/* Acoustic piano (usually) */\n\n\tdevc->act_i[voice] = &devc->i_map[instr_no];\n\treturn 0;\n}\n\n/*\n * The next table looks magical, but it certainly is not. Its values have\n * been calculated as table[i]=8*log(i/64)/log(2) with an obvious exception\n * for i=0. This log-table converts a linear volume-scaling (0..127) to a\n * logarithmic scaling as present in the FM-synthesizer chips. so :    Volume\n * 64 =  0 db = relative volume  0 and:    Volume 32 = -6 db = relative\n * volume -8 it was implemented as a table because it is only 128 bytes and\n * it saves a lot of log() calculations. (RH)\n */\n\nstatic char fm_volume_table[128] =\n{\n\t-64, -48, -40, -35, -32, -29, -27, -26,\n\t-24, -23, -21, -20, -19, -18, -18, -17,\n\t-16, -15, -15, -14, -13, -13, -12, -12,\n\t-11, -11, -10, -10, -10, -9, -9, -8,\n\t-8, -8, -7, -7, -7, -6, -6, -6,\n\t-5, -5, -5, -5, -4, -4, -4, -4,\n\t-3, -3, -3, -3, -2, -2, -2, -2,\n\t-2, -1, -1, -1, -1, 0, 0, 0,\n\t0, 0, 0, 1, 1, 1, 1, 1,\n\t1, 2, 2, 2, 2, 2, 2, 2,\n\t3, 3, 3, 3, 3, 3, 3, 4,\n\t4, 4, 4, 4, 4, 4, 4, 5,\n\t5, 5, 5, 5, 5, 5, 5, 5,\n\t6, 6, 6, 6, 6, 6, 6, 6,\n\t6, 7, 7, 7, 7, 7, 7, 7,\n\t7, 7, 7, 8, 8, 8, 8, 8\n};\n\nstatic void calc_vol(unsigned char *regbyte, int volume, int main_vol)\n{\n\tint level = (~*regbyte & 0x3f);\n\n\tif (main_vol > 127)\n\t\tmain_vol = 127;\n\tvolume = (volume * main_vol) / 127;\n\n\tif (level)\n\t\tlevel += fm_volume_table[volume];\n\n\tif (level > 0x3f)\n\t\tlevel = 0x3f;\n\tif (level < 0)\n\t\tlevel = 0;\n\n\t*regbyte = (*regbyte & 0xc0) | (~level & 0x3f);\n}\n\nstatic void set_voice_volume(int voice, int volume, int main_vol)\n{\n\tunsigned char vol1, vol2, vol3, vol4;\n\tstruct sbi_instrument *instr;\n\tstruct physical_voice_info *map;\n\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tmap = &pv_map[devc->lv_map[voice]];\n\tinstr = devc->act_i[voice];\n\n\tif (!instr)\n\t\tinstr = &devc->i_map[0];\n\n\tif (instr->channel < 0)\n\t\treturn;\n\n\tif (devc->voc[voice].mode == 0)\n\t\treturn;\n\n\tif (devc->voc[voice].mode == 2)\n\t{\n\t\tvol1 = instr->operators[2];\n\t\tvol2 = instr->operators[3];\n\t\tif ((instr->operators[10] & 0x01))\n\t\t{\n\t\t\tcalc_vol(&vol1, volume, main_vol);\n\t\t\tcalc_vol(&vol2, volume, main_vol);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcalc_vol(&vol2, volume, main_vol);\n\t\t}\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[0], vol1);\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[1], vol2);\n\t}\n\telse\n\t{\t/*\n\t\t * 4 OP voice\n\t\t */\n\t\tint connection;\n\n\t\tvol1 = instr->operators[2];\n\t\tvol2 = instr->operators[3];\n\t\tvol3 = instr->operators[OFFS_4OP + 2];\n\t\tvol4 = instr->operators[OFFS_4OP + 3];\n\n\t\t/*\n\t\t * The connection method for 4 OP devc->voc is defined by the rightmost\n\t\t * bits at the offsets 10 and 10+OFFS_4OP\n\t\t */\n\n\t\tconnection = ((instr->operators[10] & 0x01) << 1) | (instr->operators[10 + OFFS_4OP] & 0x01);\n\n\t\tswitch (connection)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tcalc_vol(&vol4, volume, main_vol);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tcalc_vol(&vol2, volume, main_vol);\n\t\t\t\tcalc_vol(&vol4, volume, main_vol);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tcalc_vol(&vol1, volume, main_vol);\n\t\t\t\tcalc_vol(&vol4, volume, main_vol);\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tcalc_vol(&vol1, volume, main_vol);\n\t\t\t\tcalc_vol(&vol3, volume, main_vol);\n\t\t\t\tcalc_vol(&vol4, volume, main_vol);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t;\n\t\t}\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[0], vol1);\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[1], vol2);\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[2], vol3);\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[3], vol4);\n\t}\n}\n\nstatic int opl3_start_note (int dev, int voice, int note, int volume)\n{\n\tunsigned char data, fpc;\n\tint block, fnum, freq, voice_mode, pan;\n\tstruct sbi_instrument *instr;\n\tstruct physical_voice_info *map;\n\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn 0;\n\n\tmap = &pv_map[devc->lv_map[voice]];\n\tpan = devc->voc[voice].panning;\n\n\tif (map->voice_mode == 0)\n\t\treturn 0;\n\n\tif (note == 255)\t/*\n\t\t\t\t * Just change the volume\n\t\t\t\t */\n\t{\n\t\tset_voice_volume(voice, volume, devc->voc[voice].volume);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Kill previous note before playing\n\t */\n\t\n\topl3_command(map->ioaddr, KSL_LEVEL + map->op[1], 0xff);\t/*\n\t\t\t\t\t\t\t\t\t * Carrier\n\t\t\t\t\t\t\t\t\t * volume to\n\t\t\t\t\t\t\t\t\t * min\n\t\t\t\t\t\t\t\t\t */\n\topl3_command(map->ioaddr, KSL_LEVEL + map->op[0], 0xff);\t/*\n\t\t\t\t\t\t\t\t\t * Modulator\n\t\t\t\t\t\t\t\t\t * volume to\n\t\t\t\t\t\t\t\t\t */\n\n\tif (map->voice_mode == 4)\n\t{\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[2], 0xff);\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[3], 0xff);\n\t}\n\n\topl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num, 0x00);\t/*\n\t\t\t\t\t\t\t\t\t * Note\n\t\t\t\t\t\t\t\t\t * off\n\t\t\t\t\t\t\t\t\t */\n\n\tinstr = devc->act_i[voice];\n\t\n\tif (!instr)\n\t\tinstr = &devc->i_map[0];\n\n\tif (instr->channel < 0)\n\t{\n\t\tprintk(KERN_WARNING \"opl3: Initializing voice %d with undefined instrument\\n\", voice);\n\t\treturn 0;\n\t}\n\n\tif (map->voice_mode == 2 && instr->key == OPL3_PATCH)\n\t\treturn 0;\t/*\n\t\t\t\t * Cannot play\n\t\t\t\t */\n\n\tvoice_mode = map->voice_mode;\n\n\tif (voice_mode == 4)\n\t{\n\t\tint voice_shift;\n\n\t\tvoice_shift = (map->ioaddr == devc->left_io) ? 0 : 3;\n\t\tvoice_shift += map->voice_num;\n\n\t\tif (instr->key != OPL3_PATCH)\t/*\n\t\t\t\t\t\t * Just 2 OP patch\n\t\t\t\t\t\t */\n\t\t{\n\t\t\tvoice_mode = 2;\n\t\t\tdevc->cmask &= ~(1 << voice_shift);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdevc->cmask |= (1 << voice_shift);\n\t\t}\n\n\t\topl3_command(devc->right_io, CONNECTION_SELECT_REGISTER, devc->cmask);\n\t}\n\n\t/*\n\t * Set Sound Characteristics\n\t */\n\t\n\topl3_command(map->ioaddr, AM_VIB + map->op[0], instr->operators[0]);\n\topl3_command(map->ioaddr, AM_VIB + map->op[1], instr->operators[1]);\n\n\t/*\n\t * Set Attack/Decay\n\t */\n\t\n\topl3_command(map->ioaddr, ATTACK_DECAY + map->op[0], instr->operators[4]);\n\topl3_command(map->ioaddr, ATTACK_DECAY + map->op[1], instr->operators[5]);\n\n\t/*\n\t * Set Sustain/Release\n\t */\n\t\n\topl3_command(map->ioaddr, SUSTAIN_RELEASE + map->op[0], instr->operators[6]);\n\topl3_command(map->ioaddr, SUSTAIN_RELEASE + map->op[1], instr->operators[7]);\n\n\t/*\n\t * Set Wave Select\n\t */\n\n\topl3_command(map->ioaddr, WAVE_SELECT + map->op[0], instr->operators[8]);\n\topl3_command(map->ioaddr, WAVE_SELECT + map->op[1], instr->operators[9]);\n\n\t/*\n\t * Set Feedback/Connection\n\t */\n\t\n\tfpc = instr->operators[10];\n\n\tif (pan != 0xffff)\n\t{\n\t\tfpc &= ~STEREO_BITS;\n\t\tif (pan < -64)\n\t\t\tfpc |= VOICE_TO_LEFT;\n\t\telse\n\t\t\tif (pan > 64)\n\t\t\t\tfpc |= VOICE_TO_RIGHT;\n\t\t\telse\n\t\t\t\tfpc |= (VOICE_TO_LEFT | VOICE_TO_RIGHT);\n\t}\n\n\tif (!(fpc & 0x30))\n\t\tfpc |= 0x30;\t/*\n\t\t\t\t * Ensure that at least one chn is enabled\n\t\t\t\t */\n\topl3_command(map->ioaddr, FEEDBACK_CONNECTION + map->voice_num, fpc);\n\n\t/*\n\t * If the voice is a 4 OP one, initialize the operators 3 and 4 also\n\t */\n\n\tif (voice_mode == 4)\n\t{\n\t\t/*\n\t\t * Set Sound Characteristics\n\t\t */\n\t\n\t\topl3_command(map->ioaddr, AM_VIB + map->op[2], instr->operators[OFFS_4OP + 0]);\n\t\topl3_command(map->ioaddr, AM_VIB + map->op[3], instr->operators[OFFS_4OP + 1]);\n\n\t\t/*\n\t\t * Set Attack/Decay\n\t\t */\n\t\t\n\t\topl3_command(map->ioaddr, ATTACK_DECAY + map->op[2], instr->operators[OFFS_4OP + 4]);\n\t\topl3_command(map->ioaddr, ATTACK_DECAY + map->op[3], instr->operators[OFFS_4OP + 5]);\n\n\t\t/*\n\t\t * Set Sustain/Release\n\t\t */\n\t\t\n\t\topl3_command(map->ioaddr, SUSTAIN_RELEASE + map->op[2], instr->operators[OFFS_4OP + 6]);\n\t\topl3_command(map->ioaddr, SUSTAIN_RELEASE + map->op[3], instr->operators[OFFS_4OP + 7]);\n\n\t\t/*\n\t\t * Set Wave Select\n\t\t */\n\t\t\n\t\topl3_command(map->ioaddr, WAVE_SELECT + map->op[2], instr->operators[OFFS_4OP + 8]);\n\t\topl3_command(map->ioaddr, WAVE_SELECT + map->op[3], instr->operators[OFFS_4OP + 9]);\n\n\t\t/*\n\t\t * Set Feedback/Connection\n\t\t */\n\t\t\n\t\tfpc = instr->operators[OFFS_4OP + 10];\n\t\tif (!(fpc & 0x30))\n\t\t\t fpc |= 0x30;\t/*\n\t\t\t\t\t * Ensure that at least one chn is enabled\n\t\t\t\t\t */\n\t\topl3_command(map->ioaddr, FEEDBACK_CONNECTION + map->voice_num + 3, fpc);\n\t}\n\n\tdevc->voc[voice].mode = voice_mode;\n\tset_voice_volume(voice, volume, devc->voc[voice].volume);\n\n\tfreq = devc->voc[voice].orig_freq = note_to_freq(note) / 1000;\n\n\t/*\n\t * Since the pitch bender may have been set before playing the note, we\n\t * have to calculate the bending now.\n\t */\n\n\tfreq = compute_finetune(devc->voc[voice].orig_freq, devc->voc[voice].bender, devc->voc[voice].bender_range, 0);\n\tdevc->voc[voice].current_freq = freq;\n\n\tfreq_to_fnum(freq, &block, &fnum);\n\n\t/*\n\t * Play note\n\t */\n\n\tdata = fnum & 0xff;\t/*\n\t\t\t\t * Least significant bits of fnumber\n\t\t\t\t */\n\topl3_command(map->ioaddr, FNUM_LOW + map->voice_num, data);\n\n\tdata = 0x20 | ((block & 0x7) << 2) | ((fnum >> 8) & 0x3);\n\t\t devc->voc[voice].keyon_byte = data;\n\topl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num, data);\n\tif (voice_mode == 4)\n\t\topl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num + 3, data);\n\n\treturn 0;\n}\n\nstatic void freq_to_fnum    (int freq, int *block, int *fnum)\n{\n\tint f, octave;\n\n\t/*\n\t * Converts the note frequency to block and fnum values for the FM chip\n\t */\n\t/*\n\t * First try to compute the block -value (octave) where the note belongs\n\t */\n\n\tf = freq;\n\n\toctave = 5;\n\n\tif (f == 0)\n\t\toctave = 0;\n\telse if (f < 261)\n\t{\n\t\twhile (f < 261)\n\t\t{\n\t\t\toctave--;\n\t\t\tf <<= 1;\n\t\t}\n\t}\n\telse if (f > 493)\n\t{\n\t\twhile (f > 493)\n\t\t{\n\t\t\t octave++;\n\t\t\t f >>= 1;\n\t\t}\n\t}\n\n\tif (octave > 7)\n\t\toctave = 7;\n\n\t*fnum = freq * (1 << (20 - octave)) / 49716;\n\t*block = octave;\n}\n\nstatic void opl3_command    (int io_addr, unsigned int addr, unsigned int val)\n{\n\t int i;\n\n\t/*\n\t * The original 2-OP synth requires a quite long delay after writing to a\n\t * register. The OPL-3 survives with just two INBs\n\t */\n\n\toutb(((unsigned char) (addr & 0xff)), io_addr);\n\n\tif (devc->model != 2)\n\t\tudelay(10);\n\telse\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tinb(io_addr);\n\n\toutb(((unsigned char) (val & 0xff)), io_addr + 1);\n\n\tif (devc->model != 2)\n\t\tudelay(30);\n\telse\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tinb(io_addr);\n}\n\nstatic void opl3_reset(int devno)\n{\n\tint i;\n\n\tfor (i = 0; i < 18; i++)\n\t\tdevc->lv_map[i] = i;\n\n\tfor (i = 0; i < devc->nr_voice; i++)\n\t{\n\t\topl3_command(pv_map[devc->lv_map[i]].ioaddr,\n\t\t\tKSL_LEVEL + pv_map[devc->lv_map[i]].op[0], 0xff);\n\n\t\topl3_command(pv_map[devc->lv_map[i]].ioaddr,\n\t\t\tKSL_LEVEL + pv_map[devc->lv_map[i]].op[1], 0xff);\n\n\t\tif (pv_map[devc->lv_map[i]].voice_mode == 4)\n\t\t{\n\t\t\topl3_command(pv_map[devc->lv_map[i]].ioaddr,\n\t\t\t\tKSL_LEVEL + pv_map[devc->lv_map[i]].op[2], 0xff);\n\n\t\t\topl3_command(pv_map[devc->lv_map[i]].ioaddr,\n\t\t\t\tKSL_LEVEL + pv_map[devc->lv_map[i]].op[3], 0xff);\n\t\t}\n\n\t\topl3_kill_note(devno, i, 0, 64);\n\t}\n\n\tif (devc->model == 2)\n\t{\n\t\tdevc->v_alloc->max_voice = devc->nr_voice = 18;\n\n\t\tfor (i = 0; i < 18; i++)\n\t\t\tpv_map[i].voice_mode = 2;\n\n\t}\n}\n\nstatic int opl3_open(int dev, int mode)\n{\n\tint i;\n\n\tif (devc->busy)\n\t\treturn -EBUSY;\n\tdevc->busy = 1;\n\n\tdevc->v_alloc->max_voice = devc->nr_voice = (devc->model == 2) ? 18 : 9;\n\tdevc->v_alloc->timestamp = 0;\n\n\tfor (i = 0; i < 18; i++)\n\t{\n\t\tdevc->v_alloc->map[i] = 0;\n\t\tdevc->v_alloc->alloc_times[i] = 0;\n\t}\n\n\tdevc->cmask = 0x00;\t/*\n\t\t\t\t * Just 2 OP mode\n\t\t\t\t */\n\tif (devc->model == 2)\n\t\topl3_command(devc->right_io, CONNECTION_SELECT_REGISTER, devc->cmask);\n\treturn 0;\n}\n\nstatic void opl3_close(int dev)\n{\n\tdevc->busy = 0;\n\tdevc->v_alloc->max_voice = devc->nr_voice = (devc->model == 2) ? 18 : 9;\n\n\tdevc->fm_info.nr_drums = 0;\n\tdevc->fm_info.perc_mode = 0;\n\n\topl3_reset(dev);\n}\n\nstatic void opl3_hw_control(int dev, unsigned char *event)\n{\n}\n\nstatic int opl3_load_patch(int dev, int format, const char __user *addr,\n\t\tint offs, int count, int pmgr_flag)\n{\n\tstruct sbi_instrument ins;\n\n\tif (count <sizeof(ins))\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Patch record too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * What the fuck is going on here?  We leave junk in the beginning\n\t * of ins and then check the field pretty close to that beginning?\n\t */\n\tif(copy_from_user(&((char *) &ins)[offs], addr + offs, sizeof(ins) - offs))\n\t\treturn -EFAULT;\n\n\tif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR)\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Invalid instrument number %d\\n\", ins.channel);\n\t\treturn -EINVAL;\n\t}\n\tins.key = format;\n\n\treturn store_instr(ins.channel, &ins);\n}\n\nstatic void opl3_panning(int dev, int voice, int value)\n{\n\tdevc->voc[voice].panning = value;\n}\n\nstatic void opl3_volume_method(int dev, int mode)\n{\n}\n\n#define SET_VIBRATO(cell) { \\\n\ttmp = instr->operators[(cell-1)+(((cell-1)/2)*OFFS_4OP)]; \\\n\tif (pressure > 110) \\\n\t\ttmp |= 0x40;\t\t/* Vibrato on */ \\\n\topl3_command (map->ioaddr, AM_VIB + map->op[cell-1], tmp);}\n\nstatic void opl3_aftertouch(int dev, int voice, int pressure)\n{\n\tint tmp;\n\tstruct sbi_instrument *instr;\n\tstruct physical_voice_info *map;\n\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tmap = &pv_map[devc->lv_map[voice]];\n\n\tDEB(printk(\"Aftertouch %d\\n\", voice));\n\n\tif (map->voice_mode == 0)\n\t\treturn;\n\n\t/*\n\t * Adjust the amount of vibrato depending the pressure\n\t */\n\n\tinstr = devc->act_i[voice];\n\n\tif (!instr)\n\t\tinstr = &devc->i_map[0];\n\n\tif (devc->voc[voice].mode == 4)\n\t{\n\t\tint connection = ((instr->operators[10] & 0x01) << 1) | (instr->operators[10 + OFFS_4OP] & 0x01);\n\n\t\tswitch (connection)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tSET_VIBRATO(4);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tSET_VIBRATO(2);\n\t\t\t\tSET_VIBRATO(4);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tSET_VIBRATO(1);\n\t\t\t\tSET_VIBRATO(4);\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tSET_VIBRATO(1);\n\t\t\t\tSET_VIBRATO(3);\n\t\t\t\tSET_VIBRATO(4);\n\t\t\t\tbreak;\n\n\t\t}\n\t\t/*\n\t\t * Not implemented yet\n\t\t */\n\t}\n\telse\n\t{\n\t\tSET_VIBRATO(1);\n\n\t\tif ((instr->operators[10] & 0x01))\t/*\n\t\t\t\t\t\t\t * Additive synthesis\n\t\t\t\t\t\t\t */\n\t\t\tSET_VIBRATO(2);\n\t}\n}\n\n#undef SET_VIBRATO\n\nstatic void bend_pitch(int dev, int voice, int value)\n{\n\tunsigned char data;\n\tint block, fnum, freq;\n\tstruct physical_voice_info *map;\n\n\tmap = &pv_map[devc->lv_map[voice]];\n\n\tif (map->voice_mode == 0)\n\t\treturn;\n\n\tdevc->voc[voice].bender = value;\n\tif (!value)\n\t\treturn;\n\tif (!(devc->voc[voice].keyon_byte & 0x20))\n\t\treturn;\t/*\n\t\t\t * Not keyed on\n\t\t\t */\n\n\tfreq = compute_finetune(devc->voc[voice].orig_freq, devc->voc[voice].bender, devc->voc[voice].bender_range, 0);\n\tdevc->voc[voice].current_freq = freq;\n\n\tfreq_to_fnum(freq, &block, &fnum);\n\n\tdata = fnum & 0xff;\t/*\n\t\t\t\t * Least significant bits of fnumber\n\t\t\t\t */\n\topl3_command(map->ioaddr, FNUM_LOW + map->voice_num, data);\n\n\tdata = 0x20 | ((block & 0x7) << 2) | ((fnum >> 8) & 0x3);\n\tdevc->voc[voice].keyon_byte = data;\n\topl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num, data);\n}\n\nstatic void opl3_controller (int dev, int voice, int ctrl_num, int value)\n{\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tswitch (ctrl_num)\n\t{\n\t\tcase CTRL_PITCH_BENDER:\n\t\t\tbend_pitch(dev, voice, value);\n\t\t\tbreak;\n\n\t\tcase CTRL_PITCH_BENDER_RANGE:\n\t\t\tdevc->voc[voice].bender_range = value;\n\t\t\tbreak;\n\n\t\tcase CTL_MAIN_VOLUME:\n\t\t\tdevc->voc[voice].volume = value / 128;\n\t\t\tbreak;\n\n\t\tcase CTL_PAN:\n\t\t\tdevc->voc[voice].panning = (value * 2) - 128;\n\t\t\tbreak;\n\t}\n}\n\nstatic void opl3_bender(int dev, int voice, int value)\n{\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tbend_pitch(dev, voice, value - 8192);\n}\n\nstatic int opl3_alloc_voice(int dev, int chn, int note, struct voice_alloc_info *alloc)\n{\n\tint i, p, best, first, avail, best_time = 0x7fffffff;\n\tstruct sbi_instrument *instr;\n\tint is4op;\n\tint instr_no;\n\n\tif (chn < 0 || chn > 15)\n\t\tinstr_no = 0;\n\telse\n\t\tinstr_no = devc->chn_info[chn].pgm_num;\n\n\tinstr = &devc->i_map[instr_no];\n\tif (instr->channel < 0 ||\t/* Instrument not loaded */\n\t\tdevc->nr_voice != 12)\t/* Not in 4 OP mode */\n\t\tis4op = 0;\n\telse if (devc->nr_voice == 12)\t/* 4 OP mode */\n\t\tis4op = (instr->key == OPL3_PATCH);\n\telse\n\t\tis4op = 0;\n\n\tif (is4op)\n\t{\n\t\tfirst = p = 0;\n\t\tavail = 6;\n\t}\n\telse\n\t{\n\t\tif (devc->nr_voice == 12)\t/* 4 OP mode. Use the '2 OP only' operators first */\n\t\t\tfirst = p = 6;\n\t\telse\n\t\t\tfirst = p = 0;\n\t\tavail = devc->nr_voice;\n\t}\n\n\t/*\n\t *    Now try to find a free voice\n\t */\n\tbest = first;\n\n\tfor (i = 0; i < avail; i++)\n\t{\n\t\tif (alloc->map[p] == 0)\n\t\t{\n\t\t\treturn p;\n\t\t}\n\t\tif (alloc->alloc_times[p] < best_time)\t\t/* Find oldest playing note */\n\t\t{\n\t\t\tbest_time = alloc->alloc_times[p];\n\t\t\tbest = p;\n\t\t}\n\t\tp = (p + 1) % avail;\n\t}\n\n\t/*\n\t *    Insert some kind of priority mechanism here.\n\t */\n\n\tif (best < 0)\n\t\tbest = 0;\n\tif (best > devc->nr_voice)\n\t\tbest -= devc->nr_voice;\n\n\treturn best;\t/* All devc->voc in use. Select the first one. */\n}\n\nstatic void opl3_setup_voice(int dev, int voice, int chn)\n{\n\tstruct channel_info *info =\n\t&synth_devs[dev]->chn_info[chn];\n\n\topl3_set_instr(dev, voice, info->pgm_num);\n\n\tdevc->voc[voice].bender = 0;\n\tdevc->voc[voice].bender_range = info->bender_range;\n\tdevc->voc[voice].volume = info->controllers[CTL_MAIN_VOLUME];\n\tdevc->voc[voice].panning = (info->controllers[CTL_PAN] * 2) - 128;\n}\n\nstatic struct synth_operations opl3_operations =\n{\n\t.owner\t\t= THIS_MODULE,\n\t.id\t\t= \"OPL\",\n\t.info\t\t= NULL,\n\t.midi_dev\t= 0,\n\t.synth_type\t= SYNTH_TYPE_FM,\n\t.synth_subtype\t= FM_TYPE_ADLIB,\n\t.open\t\t= opl3_open,\n\t.close\t\t= opl3_close,\n\t.ioctl\t\t= opl3_ioctl,\n\t.kill_note\t= opl3_kill_note,\n\t.start_note\t= opl3_start_note,\n\t.set_instr\t= opl3_set_instr,\n\t.reset\t\t= opl3_reset,\n\t.hw_control\t= opl3_hw_control,\n\t.load_patch\t= opl3_load_patch,\n\t.aftertouch\t= opl3_aftertouch,\n\t.controller\t= opl3_controller,\n\t.panning\t= opl3_panning,\n\t.volume_method\t= opl3_volume_method,\n\t.bender\t\t= opl3_bender,\n\t.alloc_voice\t= opl3_alloc_voice,\n\t.setup_voice\t= opl3_setup_voice\n};\n\nstatic int opl3_init(int ioaddr, struct module *owner)\n{\n\tint i;\n\tint me;\n\n\tif (devc == NULL)\n\t{\n\t\tprintk(KERN_ERR \"opl3: Device control structure not initialized.\\n\");\n\t\treturn -1;\n\t}\n\n\tif ((me = sound_alloc_synthdev()) == -1)\n\t{\n\t\tprintk(KERN_WARNING \"opl3: Too many synthesizers\\n\");\n\t\treturn -1;\n\t}\n\n\tdevc->nr_voice = 9;\n\n\tdevc->fm_info.device = 0;\n\tdevc->fm_info.synth_type = SYNTH_TYPE_FM;\n\tdevc->fm_info.synth_subtype = FM_TYPE_ADLIB;\n\tdevc->fm_info.perc_mode = 0;\n\tdevc->fm_info.nr_voices = 9;\n\tdevc->fm_info.nr_drums = 0;\n\tdevc->fm_info.instr_bank_size = SBFM_MAXINSTR;\n\tdevc->fm_info.capabilities = 0;\n\tdevc->left_io = ioaddr;\n\tdevc->right_io = ioaddr + 2;\n\n\tif (detected_model <= 2)\n\t\tdevc->model = 1;\n\telse\n\t{\n\t\tdevc->model = 2;\n\t\tif (detected_model == 4)\n\t\t\tdevc->is_opl4 = 1;\n\t}\n\n\topl3_operations.info = &devc->fm_info;\n\n\tsynth_devs[me] = &opl3_operations;\n\n\tif (owner)\n\t\tsynth_devs[me]->owner = owner;\n\t\n\tsequencer_init();\n\tdevc->v_alloc = &opl3_operations.alloc;\n\tdevc->chn_info = &opl3_operations.chn_info[0];\n\n\tif (devc->model == 2)\n\t{\n\t\tif (devc->is_opl4) \n\t\t\tstrcpy(devc->fm_info.name, \"Yamaha OPL4/OPL3 FM\");\n\t\telse \n\t\t\tstrcpy(devc->fm_info.name, \"Yamaha OPL3\");\n\n\t\tdevc->v_alloc->max_voice = devc->nr_voice = 18;\n\t\tdevc->fm_info.nr_drums = 0;\n\t\tdevc->fm_info.synth_subtype = FM_TYPE_OPL3;\n\t\tdevc->fm_info.capabilities |= SYNTH_CAP_OPL3;\n\n\t\tfor (i = 0; i < 18; i++)\n\t\t{\n\t\t\tif (pv_map[i].ioaddr == USE_LEFT)\n\t\t\t\tpv_map[i].ioaddr = devc->left_io;\n\t\t\telse\n\t\t\t\tpv_map[i].ioaddr = devc->right_io;\n\t\t}\n\t\topl3_command(devc->right_io, OPL3_MODE_REGISTER, OPL3_ENABLE);\n\t\topl3_command(devc->right_io, CONNECTION_SELECT_REGISTER, 0x00);\n\t}\n\telse\n\t{\n\t\tstrcpy(devc->fm_info.name, \"Yamaha OPL2\");\n\t\tdevc->v_alloc->max_voice = devc->nr_voice = 9;\n\t\tdevc->fm_info.nr_drums = 0;\n\n\t\tfor (i = 0; i < 18; i++)\n\t\t\tpv_map[i].ioaddr = devc->left_io;\n\t};\n\tconf_printf2(devc->fm_info.name, ioaddr, 0, -1, -1);\n\n\tfor (i = 0; i < SBFM_MAXINSTR; i++)\n\t\tdevc->i_map[i].channel = -1;\n\n\treturn me;\n}\n\nstatic int me;\n\nstatic int io = -1;\n\nmodule_param(io, int, 0);\n\nstatic int __init init_opl3 (void)\n{\n\tprintk(KERN_INFO \"YM3812 and OPL-3 driver Copyright (C) by Hannu Savolainen, Rob Hooft 1993-1996\\n\");\n\n\tif (io != -1)\t/* User loading pure OPL3 module */\n\t{\n\t\tif (!opl3_detect(io))\n\t\t{\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tme = opl3_init(io, THIS_MODULE);\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit cleanup_opl3(void)\n{\n\tif (devc && io != -1)\n\t{\n\t\tif (devc->base) {\n\t\t\trelease_region(devc->base,4);\n\t\t\tif (devc->is_opl4)\n\t\t\t\trelease_region(devc->base - 8, 2);\n\t\t}\n\t\tkfree(devc);\n\t\tdevc = NULL;\n\t\tsound_unload_synthdev(me);\n\t}\n}\n\nmodule_init(init_opl3);\nmodule_exit(cleanup_opl3);\n\n#ifndef MODULE\nstatic int __init setup_opl3(char *str)\n{\n        /* io  */\n\tint ints[2];\n\t\n\tstr = get_options(str, ARRAY_SIZE(ints), ints);\n\t\n\tio = ints[1];\n\n\treturn 1;\n}\n\n__setup(\"opl3=\", setup_opl3);\n#endif\nMODULE_LICENSE(\"GPL\");\n", "/*\n * sound/oss/sequencer.c\n *\n * The sequencer personality manager.\n */\n/*\n * Copyright (C) by Hannu Savolainen 1993-1997\n *\n * OSS/Free for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)\n * Version 2 (June 1991). See the \"COPYING\" file distributed with this software\n * for more info.\n */\n/*\n * Thomas Sailer   : ioctl code reworked (vmalloc/vfree removed)\n * Alan Cox\t   : reformatted and fixed a pair of null pointer bugs\n */\n#include <linux/kmod.h>\n#include <linux/spinlock.h>\n#include \"sound_config.h\"\n\n#include \"midi_ctrl.h\"\n\nstatic int      sequencer_ok;\nstatic struct sound_timer_operations *tmr;\nstatic int      tmr_no = -1;\t/* Currently selected timer */\nstatic int      pending_timer = -1;\t/* For timer change operation */\nextern unsigned long seq_time;\n\nstatic int      obsolete_api_used;\nstatic DEFINE_SPINLOCK(lock);\n\n/*\n * Local counts for number of synth and MIDI devices. These are initialized\n * by the sequencer_open.\n */\nstatic int      max_mididev;\nstatic int      max_synthdev;\n\n/*\n * The seq_mode gives the operating mode of the sequencer:\n *      1 = level1 (the default)\n *      2 = level2 (extended capabilities)\n */\n\n#define SEQ_1\t1\n#define SEQ_2\t2\nstatic int      seq_mode = SEQ_1;\n\nstatic DECLARE_WAIT_QUEUE_HEAD(seq_sleeper);\nstatic DECLARE_WAIT_QUEUE_HEAD(midi_sleeper);\n\nstatic int      midi_opened[MAX_MIDI_DEV];\n\nstatic int      midi_written[MAX_MIDI_DEV];\n\nstatic unsigned long prev_input_time;\nstatic int      prev_event_time;\n\n#include \"tuning.h\"\n\n#define EV_SZ\t8\n#define IEV_SZ\t8\n\nstatic unsigned char *queue;\nstatic unsigned char *iqueue;\n\nstatic volatile int qhead, qtail, qlen;\nstatic volatile int iqhead, iqtail, iqlen;\nstatic volatile int seq_playing;\nstatic volatile int sequencer_busy;\nstatic int      output_threshold;\nstatic long     pre_event_timeout;\nstatic unsigned synth_open_mask;\n\nstatic int      seq_queue(unsigned char *note, char nonblock);\nstatic void     seq_startplay(void);\nstatic int      seq_sync(void);\nstatic void     seq_reset(void);\n\n#if MAX_SYNTH_DEV > 15\n#error Too many synthesizer devices enabled.\n#endif\n\nint sequencer_read(int dev, struct file *file, char __user *buf, int count)\n{\n\tint c = count, p = 0;\n\tint ev_len;\n\tunsigned long flags;\n\n\tdev = dev >> 4;\n\n\tev_len = seq_mode == SEQ_1 ? 4 : 8;\n\n\tspin_lock_irqsave(&lock,flags);\n\n\tif (!iqlen)\n\t{\n\t\tspin_unlock_irqrestore(&lock,flags);\n \t\tif (file->f_flags & O_NONBLOCK) {\n  \t\t\treturn -EAGAIN;\n  \t\t}\n\n \t\tinterruptible_sleep_on_timeout(&midi_sleeper,\n\t\t\t\t\t       pre_event_timeout);\n\t\tspin_lock_irqsave(&lock,flags);\n\t\tif (!iqlen)\n\t\t{\n\t\t\tspin_unlock_irqrestore(&lock,flags);\n\t\t\treturn 0;\n\t\t}\n\t}\n\twhile (iqlen && c >= ev_len)\n\t{\n\t\tchar *fixit = (char *) &iqueue[iqhead * IEV_SZ];\n\t\tspin_unlock_irqrestore(&lock,flags);\n\t\tif (copy_to_user(&(buf)[p], fixit, ev_len))\n\t\t\treturn count - c;\n\t\tp += ev_len;\n\t\tc -= ev_len;\n\n\t\tspin_lock_irqsave(&lock,flags);\n\t\tiqhead = (iqhead + 1) % SEQ_MAX_QUEUE;\n\t\tiqlen--;\n\t}\n\tspin_unlock_irqrestore(&lock,flags);\n\treturn count - c;\n}\n\nstatic void sequencer_midi_output(int dev)\n{\n\t/*\n\t * Currently NOP\n\t */\n}\n\nvoid seq_copy_to_input(unsigned char *event_rec, int len)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Verify that the len is valid for the current mode.\n\t */\n\n\tif (len != 4 && len != 8)\n\t\treturn;\n\tif ((seq_mode == SEQ_1) != (len == 4))\n\t\treturn;\n\n\tif (iqlen >= (SEQ_MAX_QUEUE - 1))\n\t\treturn;\t\t/* Overflow */\n\n\tspin_lock_irqsave(&lock,flags);\n\tmemcpy(&iqueue[iqtail * IEV_SZ], event_rec, len);\n\tiqlen++;\n\tiqtail = (iqtail + 1) % SEQ_MAX_QUEUE;\n\twake_up(&midi_sleeper);\n\tspin_unlock_irqrestore(&lock,flags);\n}\nEXPORT_SYMBOL(seq_copy_to_input);\n\nstatic void sequencer_midi_input(int dev, unsigned char data)\n{\n\tunsigned int tstamp;\n\tunsigned char event_rec[4];\n\n\tif (data == 0xfe)\t/* Ignore active sensing */\n\t\treturn;\n\n\ttstamp = jiffies - seq_time;\n\n\tif (tstamp != prev_input_time)\n\t{\n\t\ttstamp = (tstamp << 8) | SEQ_WAIT;\n\t\tseq_copy_to_input((unsigned char *) &tstamp, 4);\n\t\tprev_input_time = tstamp;\n\t}\n\tevent_rec[0] = SEQ_MIDIPUTC;\n\tevent_rec[1] = data;\n\tevent_rec[2] = dev;\n\tevent_rec[3] = 0;\n\n\tseq_copy_to_input(event_rec, 4);\n}\n\nvoid seq_input_event(unsigned char *event_rec, int len)\n{\n\tunsigned long this_time;\n\n\tif (seq_mode == SEQ_2)\n\t\tthis_time = tmr->get_time(tmr_no);\n\telse\n\t\tthis_time = jiffies - seq_time;\n\n\tif (this_time != prev_input_time)\n\t{\n\t\tunsigned char   tmp_event[8];\n\n\t\ttmp_event[0] = EV_TIMING;\n\t\ttmp_event[1] = TMR_WAIT_ABS;\n\t\ttmp_event[2] = 0;\n\t\ttmp_event[3] = 0;\n\t\t*(unsigned int *) &tmp_event[4] = this_time;\n\n\t\tseq_copy_to_input(tmp_event, 8);\n\t\tprev_input_time = this_time;\n\t}\n\tseq_copy_to_input(event_rec, len);\n}\nEXPORT_SYMBOL(seq_input_event);\n\nint sequencer_write(int dev, struct file *file, const char __user *buf, int count)\n{\n\tunsigned char event_rec[EV_SZ], ev_code;\n\tint p = 0, c, ev_size;\n\tint mode = translate_mode(file);\n\n\tdev = dev >> 4;\n\n\tDEB(printk(\"sequencer_write(dev=%d, count=%d)\\n\", dev, count));\n\n\tif (mode == OPEN_READ)\n\t\treturn -EIO;\n\n\tc = count;\n\n\twhile (c >= 4)\n\t{\n\t\tif (copy_from_user((char *) event_rec, &(buf)[p], 4))\n\t\t\tgoto out;\n\t\tev_code = event_rec[0];\n\n\t\tif (ev_code == SEQ_FULLSIZE)\n\t\t{\n\t\t\tint err, fmt;\n\n\t\t\tdev = *(unsigned short *) &event_rec[2];\n\t\t\tif (dev < 0 || dev >= max_synthdev || synth_devs[dev] == NULL)\n\t\t\t\treturn -ENXIO;\n\n\t\t\tif (!(synth_open_mask & (1 << dev)))\n\t\t\t\treturn -ENXIO;\n\n\t\t\tfmt = (*(short *) &event_rec[0]) & 0xffff;\n\t\t\terr = synth_devs[dev]->load_patch(dev, fmt, buf, p + 4, c, 0);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\treturn err;\n\t\t}\n\t\tif (ev_code >= 128)\n\t\t{\n\t\t\tif (seq_mode == SEQ_2 && ev_code == SEQ_EXTENDED)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"Sequencer: Invalid level 2 event %x\\n\", ev_code);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tev_size = 8;\n\n\t\t\tif (c < ev_size)\n\t\t\t{\n\t\t\t\tif (!seq_playing)\n\t\t\t\t\tseq_startplay();\n\t\t\t\treturn count - c;\n\t\t\t}\n\t\t\tif (copy_from_user((char *)&event_rec[4],\n\t\t\t\t\t   &(buf)[p + 4], 4))\n\t\t\t\tgoto out;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (seq_mode == SEQ_2)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"Sequencer: 4 byte event in level 2 mode\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tev_size = 4;\n\n\t\t\tif (event_rec[0] != SEQ_MIDIPUTC)\n\t\t\t\tobsolete_api_used = 1;\n\t\t}\n\n\t\tif (event_rec[0] == SEQ_MIDIPUTC)\n\t\t{\n\t\t\tif (!midi_opened[event_rec[2]])\n\t\t\t{\n\t\t\t\tint err, mode;\n\t\t\t\tint dev = event_rec[2];\n\n\t\t\t\tif (dev >= max_mididev || midi_devs[dev]==NULL)\n\t\t\t\t{\n\t\t\t\t\t/*printk(\"Sequencer Error: Nonexistent MIDI device %d\\n\", dev);*/\n\t\t\t\t\treturn -ENXIO;\n\t\t\t\t}\n\t\t\t\tmode = translate_mode(file);\n\n\t\t\t\tif ((err = midi_devs[dev]->open(dev, mode,\n\t\t\t\t\t\t\t\tsequencer_midi_input, sequencer_midi_output)) < 0)\n\t\t\t\t{\n\t\t\t\t\tseq_reset();\n\t\t\t\t\tprintk(KERN_WARNING \"Sequencer Error: Unable to open Midi #%d\\n\", dev);\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t\tmidi_opened[dev] = 1;\n\t\t\t}\n\t\t}\n\t\tif (!seq_queue(event_rec, (file->f_flags & (O_NONBLOCK) ? 1 : 0)))\n\t\t{\n\t\t\tint processed = count - c;\n\n\t\t\tif (!seq_playing)\n\t\t\t\tseq_startplay();\n\n\t\t\tif (!processed && (file->f_flags & O_NONBLOCK))\n\t\t\t\treturn -EAGAIN;\n\t\t\telse\n\t\t\t\treturn processed;\n\t\t}\n\t\tp += ev_size;\n\t\tc -= ev_size;\n\t}\n\n\tif (!seq_playing)\n\t\tseq_startplay();\nout:\n\treturn count;\n}\n\nstatic int seq_queue(unsigned char *note, char nonblock)\n{\n\n\t/*\n\t * Test if there is space in the queue\n\t */\n\n\tif (qlen >= SEQ_MAX_QUEUE)\n\t\tif (!seq_playing)\n\t\t\tseq_startplay();\t/*\n\t\t\t\t\t\t * Give chance to drain the queue\n\t\t\t\t\t\t */\n\n\tif (!nonblock && qlen >= SEQ_MAX_QUEUE && !waitqueue_active(&seq_sleeper)) {\n\t\t/*\n\t\t * Sleep until there is enough space on the queue\n\t\t */\n\t\tinterruptible_sleep_on(&seq_sleeper);\n\t}\n\tif (qlen >= SEQ_MAX_QUEUE)\n\t{\n\t\treturn 0;\t/*\n\t\t\t\t * To be sure\n\t\t\t\t */\n\t}\n\tmemcpy(&queue[qtail * EV_SZ], note, EV_SZ);\n\n\tqtail = (qtail + 1) % SEQ_MAX_QUEUE;\n\tqlen++;\n\n\treturn 1;\n}\n\nstatic int extended_event(unsigned char *q)\n{\n\tint dev = q[2];\n\n\tif (dev < 0 || dev >= max_synthdev)\n\t\treturn -ENXIO;\n\n\tif (!(synth_open_mask & (1 << dev)))\n\t\treturn -ENXIO;\n\n\tswitch (q[1])\n\t{\n\t\tcase SEQ_NOTEOFF:\n\t\t\tsynth_devs[dev]->kill_note(dev, q[3], q[4], q[5]);\n\t\t\tbreak;\n\n\t\tcase SEQ_NOTEON:\n\t\t\tif (q[4] > 127 && q[4] != 255)\n\t\t\t\treturn 0;\n\n\t\t\tif (q[5] == 0)\n\t\t\t{\n\t\t\t\tsynth_devs[dev]->kill_note(dev, q[3], q[4], q[5]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsynth_devs[dev]->start_note(dev, q[3], q[4], q[5]);\n\t\t\tbreak;\n\n\t\tcase SEQ_PGMCHANGE:\n\t\t\tsynth_devs[dev]->set_instr(dev, q[3], q[4]);\n\t\t\tbreak;\n\n\t\tcase SEQ_AFTERTOUCH:\n\t\t\tsynth_devs[dev]->aftertouch(dev, q[3], q[4]);\n\t\t\tbreak;\n\n\t\tcase SEQ_BALANCE:\n\t\t\tsynth_devs[dev]->panning(dev, q[3], (char) q[4]);\n\t\t\tbreak;\n\n\t\tcase SEQ_CONTROLLER:\n\t\t\tsynth_devs[dev]->controller(dev, q[3], q[4], (short) (q[5] | (q[6] << 8)));\n\t\t\tbreak;\n\n\t\tcase SEQ_VOLMODE:\n\t\t\tif (synth_devs[dev]->volume_method != NULL)\n\t\t\t\tsynth_devs[dev]->volume_method(dev, q[3]);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int find_voice(int dev, int chn, int note)\n{\n\tunsigned short key;\n\tint i;\n\n\tkey = (chn << 8) | (note + 1);\n\tfor (i = 0; i < synth_devs[dev]->alloc.max_voice; i++)\n\t\tif (synth_devs[dev]->alloc.map[i] == key)\n\t\t\treturn i;\n\treturn -1;\n}\n\nstatic int alloc_voice(int dev, int chn, int note)\n{\n\tunsigned short  key;\n\tint voice;\n\n\tkey = (chn << 8) | (note + 1);\n\n\tvoice = synth_devs[dev]->alloc_voice(dev, chn, note,\n\t\t\t\t\t     &synth_devs[dev]->alloc);\n\tsynth_devs[dev]->alloc.map[voice] = key;\n\tsynth_devs[dev]->alloc.alloc_times[voice] =\n\t\t\tsynth_devs[dev]->alloc.timestamp++;\n\treturn voice;\n}\n\nstatic void seq_chn_voice_event(unsigned char *event_rec)\n{\n#define dev event_rec[1]\n#define cmd event_rec[2]\n#define chn event_rec[3]\n#define note event_rec[4]\n#define parm event_rec[5]\n\n\tint voice = -1;\n\n\tif ((int) dev > max_synthdev || synth_devs[dev] == NULL)\n\t\treturn;\n\tif (!(synth_open_mask & (1 << dev)))\n\t\treturn;\n\tif (!synth_devs[dev])\n\t\treturn;\n\n\tif (seq_mode == SEQ_2)\n\t{\n\t\tif (synth_devs[dev]->alloc_voice)\n\t\t\tvoice = find_voice(dev, chn, note);\n\n\t\tif (cmd == MIDI_NOTEON && parm == 0)\n\t\t{\n\t\t\tcmd = MIDI_NOTEOFF;\n\t\t\tparm = 64;\n\t\t}\n\t}\n\n\tswitch (cmd)\n\t{\n\t\tcase MIDI_NOTEON:\n\t\t\tif (note > 127 && note != 255)\t/* Not a seq2 feature */\n\t\t\t\treturn;\n\n\t\t\tif (voice == -1 && seq_mode == SEQ_2 && synth_devs[dev]->alloc_voice)\n\t\t\t{\n\t\t\t\t/* Internal synthesizer (FM, GUS, etc) */\n\t\t\t\tvoice = alloc_voice(dev, chn, note);\n\t\t\t}\n\t\t\tif (voice == -1)\n\t\t\t\tvoice = chn;\n\n\t\t\tif (seq_mode == SEQ_2 && (int) dev < num_synths)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * The MIDI channel 10 is a percussive channel. Use the note\n\t\t\t\t * number to select the proper patch (128 to 255) to play.\n\t\t\t\t */\n\n\t\t\t\tif (chn == 9)\n\t\t\t\t{\n\t\t\t\t\tsynth_devs[dev]->set_instr(dev, voice, 128 + note);\n\t\t\t\t\tsynth_devs[dev]->chn_info[chn].pgm_num = 128 + note;\n\t\t\t\t}\n\t\t\t\tsynth_devs[dev]->setup_voice(dev, voice, chn);\n\t\t\t}\n\t\t\tsynth_devs[dev]->start_note(dev, voice, note, parm);\n\t\t\tbreak;\n\n\t\tcase MIDI_NOTEOFF:\n\t\t\tif (voice == -1)\n\t\t\t\tvoice = chn;\n\t\t\tsynth_devs[dev]->kill_note(dev, voice, note, parm);\n\t\t\tbreak;\n\n\t\tcase MIDI_KEY_PRESSURE:\n\t\t\tif (voice == -1)\n\t\t\t\tvoice = chn;\n\t\t\tsynth_devs[dev]->aftertouch(dev, voice, parm);\n\t\t\tbreak;\n\n\t\tdefault:;\n\t}\n#undef dev\n#undef cmd\n#undef chn\n#undef note\n#undef parm\n}\n\n\nstatic void seq_chn_common_event(unsigned char *event_rec)\n{\n\tunsigned char dev = event_rec[1];\n\tunsigned char cmd = event_rec[2];\n\tunsigned char chn = event_rec[3];\n\tunsigned char p1 = event_rec[4];\n\n\t/* unsigned char p2 = event_rec[5]; */\n\tunsigned short w14 = *(short *) &event_rec[6];\n\n\tif ((int) dev > max_synthdev || synth_devs[dev] == NULL)\n\t\treturn;\n\tif (!(synth_open_mask & (1 << dev)))\n\t\treturn;\n\tif (!synth_devs[dev])\n\t\treturn;\n\n\tswitch (cmd)\n\t{\n\t\tcase MIDI_PGM_CHANGE:\n\t\t\tif (seq_mode == SEQ_2)\n\t\t\t{\n\t\t\t\tsynth_devs[dev]->chn_info[chn].pgm_num = p1;\n\t\t\t\tif ((int) dev >= num_synths)\n\t\t\t\t\tsynth_devs[dev]->set_instr(dev, chn, p1);\n\t\t\t}\n\t\t\telse\n\t\t\t\tsynth_devs[dev]->set_instr(dev, chn, p1);\n\n\t\t\tbreak;\n\n\t\tcase MIDI_CTL_CHANGE:\n\t\t\tif (seq_mode == SEQ_2)\n\t\t\t{\n\t\t\t\tif (chn > 15 || p1 > 127)\n\t\t\t\t\tbreak;\n\n\t\t\t\tsynth_devs[dev]->chn_info[chn].controllers[p1] = w14 & 0x7f;\n\n\t\t\t\tif (p1 < 32)\t/* Setting MSB should clear LSB to 0 */\n\t\t\t\t\tsynth_devs[dev]->chn_info[chn].controllers[p1 + 32] = 0;\n\n\t\t\t\tif ((int) dev < num_synths)\n\t\t\t\t{\n\t\t\t\t\tint val = w14 & 0x7f;\n\t\t\t\t\tint i, key;\n\n\t\t\t\t\tif (p1 < 64)\t/* Combine MSB and LSB */\n\t\t\t\t\t{\n\t\t\t\t\t\tval = ((synth_devs[dev]->\n\t\t\t\t\t\t\tchn_info[chn].controllers[p1 & ~32] & 0x7f) << 7)\n\t\t\t\t\t\t\t| (synth_devs[dev]->\n\t\t\t\t\t\t\tchn_info[chn].controllers[p1 | 32] & 0x7f);\n\t\t\t\t\t\tp1 &= ~32;\n\t\t\t\t\t}\n\t\t\t\t\t/* Handle all playing notes on this channel */\n\n\t\t\t\t\tkey = ((int) chn << 8);\n\n\t\t\t\t\tfor (i = 0; i < synth_devs[dev]->alloc.max_voice; i++)\n\t\t\t\t\t\tif ((synth_devs[dev]->alloc.map[i] & 0xff00) == key)\n\t\t\t\t\t\t\tsynth_devs[dev]->controller(dev, i, p1, val);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsynth_devs[dev]->controller(dev, chn, p1, w14);\n\t\t\t}\n\t\t\telse\t/* Mode 1 */\n\t\t\t\tsynth_devs[dev]->controller(dev, chn, p1, w14);\n\t\t\tbreak;\n\n\t\tcase MIDI_PITCH_BEND:\n\t\t\tif (seq_mode == SEQ_2)\n\t\t\t{\n\t\t\t\tsynth_devs[dev]->chn_info[chn].bender_value = w14;\n\n\t\t\t\tif ((int) dev < num_synths)\n\t\t\t\t{\n\t\t\t\t\t/* Handle all playing notes on this channel */\n\t\t\t\t\tint i, key;\n\n\t\t\t\t\tkey = (chn << 8);\n\n\t\t\t\t\tfor (i = 0; i < synth_devs[dev]->alloc.max_voice; i++)\n\t\t\t\t\t\tif ((synth_devs[dev]->alloc.map[i] & 0xff00) == key)\n\t\t\t\t\t\t\tsynth_devs[dev]->bender(dev, i, w14);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsynth_devs[dev]->bender(dev, chn, w14);\n\t\t\t}\n\t\t\telse\t/* MODE 1 */\n\t\t\t\tsynth_devs[dev]->bender(dev, chn, w14);\n\t\t\tbreak;\n\n\t\tdefault:;\n\t}\n}\n\nstatic int seq_timing_event(unsigned char *event_rec)\n{\n\tunsigned char cmd = event_rec[1];\n\tunsigned int parm = *(int *) &event_rec[4];\n\n\tif (seq_mode == SEQ_2)\n\t{\n\t\tint ret;\n\n\t\tif ((ret = tmr->event(tmr_no, event_rec)) == TIMER_ARMED)\n\t\t\tif ((SEQ_MAX_QUEUE - qlen) >= output_threshold)\n\t\t\t\twake_up(&seq_sleeper);\n\t\treturn ret;\n\t}\n\tswitch (cmd)\n\t{\n\t\tcase TMR_WAIT_REL:\n\t\t\tparm += prev_event_time;\n\n\t\t\t/*\n\t\t\t * NOTE!  No break here. Execution of TMR_WAIT_REL continues in the\n\t\t\t * next case (TMR_WAIT_ABS)\n\t\t\t */\n\n\t\tcase TMR_WAIT_ABS:\n\t\t\tif (parm > 0)\n\t\t\t{\n\t\t\t\tlong time;\n\n\t\t\t\ttime = parm;\n\t\t\t\tprev_event_time = time;\n\n\t\t\t\tseq_playing = 1;\n\t\t\t\trequest_sound_timer(time);\n\n\t\t\t\tif ((SEQ_MAX_QUEUE - qlen) >= output_threshold)\n\t\t\t\t\twake_up(&seq_sleeper);\n\t\t\t\treturn TIMER_ARMED;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TMR_START:\n\t\t\tseq_time = jiffies;\n\t\t\tprev_input_time = 0;\n\t\t\tprev_event_time = 0;\n\t\t\tbreak;\n\n\t\tcase TMR_STOP:\n\t\t\tbreak;\n\n\t\tcase TMR_CONTINUE:\n\t\t\tbreak;\n\n\t\tcase TMR_TEMPO:\n\t\t\tbreak;\n\n\t\tcase TMR_ECHO:\n\t\t\tif (seq_mode == SEQ_2)\n\t\t\t\tseq_copy_to_input(event_rec, 8);\n\t\t\telse\n\t\t\t{\n\t\t\t\tparm = (parm << 8 | SEQ_ECHO);\n\t\t\t\tseq_copy_to_input((unsigned char *) &parm, 4);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:;\n\t}\n\n\treturn TIMER_NOT_ARMED;\n}\n\nstatic void seq_local_event(unsigned char *event_rec)\n{\n\tunsigned char   cmd = event_rec[1];\n\tunsigned int    parm = *((unsigned int *) &event_rec[4]);\n\n\tswitch (cmd)\n\t{\n\t\tcase LOCL_STARTAUDIO:\n\t\t\tDMAbuf_start_devices(parm);\n\t\t\tbreak;\n\n\t\tdefault:;\n\t}\n}\n\nstatic void seq_sysex_message(unsigned char *event_rec)\n{\n\tunsigned int dev = event_rec[1];\n\tint i, l = 0;\n\tunsigned char  *buf = &event_rec[2];\n\n\tif (dev > max_synthdev)\n\t\treturn;\n\tif (!(synth_open_mask & (1 << dev)))\n\t\treturn;\n\tif (!synth_devs[dev])\n\t\treturn;\n\n\tl = 0;\n\tfor (i = 0; i < 6 && buf[i] != 0xff; i++)\n\t\tl = i + 1;\n\n\tif (!synth_devs[dev]->send_sysex)\n\t\treturn;\n\tif (l > 0)\n\t\tsynth_devs[dev]->send_sysex(dev, buf, l);\n}\n\nstatic int play_event(unsigned char *q)\n{\n\t/*\n\t * NOTE! This routine returns\n\t *   0 = normal event played.\n\t *   1 = Timer armed. Suspend playback until timer callback.\n\t *   2 = MIDI output buffer full. Restore queue and suspend until timer\n\t */\n\tunsigned int *delay;\n\n\tswitch (q[0])\n\t{\n\t\tcase SEQ_NOTEOFF:\n\t\t\tif (synth_open_mask & (1 << 0))\n\t\t\t\tif (synth_devs[0])\n\t\t\t\t\tsynth_devs[0]->kill_note(0, q[1], 255, q[3]);\n\t\t\tbreak;\n\n\t\tcase SEQ_NOTEON:\n\t\t\tif (q[4] < 128 || q[4] == 255)\n\t\t\t\tif (synth_open_mask & (1 << 0))\n\t\t\t\t\tif (synth_devs[0])\n\t\t\t\t\t\tsynth_devs[0]->start_note(0, q[1], q[2], q[3]);\n\t\t\tbreak;\n\n\t\tcase SEQ_WAIT:\n\t\t\tdelay = (unsigned int *) q;\t/*\n\t\t\t\t\t\t\t * Bytes 1 to 3 are containing the *\n\t\t\t\t\t\t\t * delay in 'ticks'\n\t\t\t\t\t\t\t */\n\t\t\t*delay = (*delay >> 8) & 0xffffff;\n\n\t\t\tif (*delay > 0)\n\t\t\t{\n\t\t\t\tlong time;\n\n\t\t\t\tseq_playing = 1;\n\t\t\t\ttime = *delay;\n\t\t\t\tprev_event_time = time;\n\n\t\t\t\trequest_sound_timer(time);\n\n\t\t\t\tif ((SEQ_MAX_QUEUE - qlen) >= output_threshold)\n\t\t\t\t\twake_up(&seq_sleeper);\n\t\t\t\t/*\n\t\t\t\t * The timer is now active and will reinvoke this function\n\t\t\t\t * after the timer expires. Return to the caller now.\n\t\t\t\t */\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SEQ_PGMCHANGE:\n\t\t\tif (synth_open_mask & (1 << 0))\n\t\t\t\tif (synth_devs[0])\n\t\t\t\t\tsynth_devs[0]->set_instr(0, q[1], q[2]);\n\t\t\tbreak;\n\n\t\tcase SEQ_SYNCTIMER: \t/*\n\t\t\t\t\t * Reset timer\n\t\t\t\t\t */\n\t\t\tseq_time = jiffies;\n\t\t\tprev_input_time = 0;\n\t\t\tprev_event_time = 0;\n\t\t\tbreak;\n\n\t\tcase SEQ_MIDIPUTC:\t/*\n\t\t\t\t\t * Put a midi character\n\t\t\t\t\t */\n\t\t\tif (midi_opened[q[2]])\n\t\t\t{\n\t\t\t\tint dev;\n\n\t\t\t\tdev = q[2];\n\n\t\t\t\tif (dev < 0 || dev >= num_midis || midi_devs[dev] == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (!midi_devs[dev]->outputc(dev, q[1]))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Output FIFO is full. Wait one timer cycle and try again.\n\t\t\t\t\t */\n\n\t\t\t\t\tseq_playing = 1;\n\t\t\t\t\trequest_sound_timer(-1);\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tmidi_written[dev] = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SEQ_ECHO:\n\t\t\tseq_copy_to_input(q, 4);\t/*\n\t\t\t\t\t\t\t * Echo back to the process\n\t\t\t\t\t\t\t */\n\t\t\tbreak;\n\n\t\tcase SEQ_PRIVATE:\n\t\t\tif ((int) q[1] < max_synthdev)\n\t\t\t\tsynth_devs[q[1]]->hw_control(q[1], q);\n\t\t\tbreak;\n\n\t\tcase SEQ_EXTENDED:\n\t\t\textended_event(q);\n\t\t\tbreak;\n\n\t\tcase EV_CHN_VOICE:\n\t\t\tseq_chn_voice_event(q);\n\t\t\tbreak;\n\n\t\tcase EV_CHN_COMMON:\n\t\t\tseq_chn_common_event(q);\n\t\t\tbreak;\n\n\t\tcase EV_TIMING:\n\t\t\tif (seq_timing_event(q) == TIMER_ARMED)\n\t\t\t{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase EV_SEQ_LOCAL:\n\t\t\tseq_local_event(q);\n\t\t\tbreak;\n\n\t\tcase EV_SYSEX:\n\t\t\tseq_sysex_message(q);\n\t\t\tbreak;\n\n\t\tdefault:;\n\t}\n\treturn 0;\n}\n\n/* called also as timer in irq context */\nstatic void seq_startplay(void)\n{\n\tint this_one, action;\n\tunsigned long flags;\n\n\twhile (qlen > 0)\n\t{\n\n\t\tspin_lock_irqsave(&lock,flags);\n\t\tqhead = ((this_one = qhead) + 1) % SEQ_MAX_QUEUE;\n\t\tqlen--;\n\t\tspin_unlock_irqrestore(&lock,flags);\n\n\t\tseq_playing = 1;\n\n\t\tif ((action = play_event(&queue[this_one * EV_SZ])))\n\t\t{\t\t/* Suspend playback. Next timer routine invokes this routine again */\n\t\t\tif (action == 2)\n\t\t\t{\n\t\t\t\tqlen++;\n\t\t\t\tqhead = this_one;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\tseq_playing = 0;\n\n\tif ((SEQ_MAX_QUEUE - qlen) >= output_threshold)\n\t\twake_up(&seq_sleeper);\n}\n\nstatic void reset_controllers(int dev, unsigned char *controller, int update_dev)\n{\n\tint i;\n\tfor (i = 0; i < 128; i++)\n\t\tcontroller[i] = ctrl_def_values[i];\n}\n\nstatic void setup_mode2(void)\n{\n\tint dev;\n\n\tmax_synthdev = num_synths;\n\n\tfor (dev = 0; dev < num_midis; dev++)\n\t{\n\t\tif (midi_devs[dev] && midi_devs[dev]->converter != NULL)\n\t\t{\n\t\t\tsynth_devs[max_synthdev++] = midi_devs[dev]->converter;\n\t\t}\n\t}\n\n\tfor (dev = 0; dev < max_synthdev; dev++)\n\t{\n\t\tint chn;\n\n\t\tsynth_devs[dev]->sysex_ptr = 0;\n\t\tsynth_devs[dev]->emulation = 0;\n\n\t\tfor (chn = 0; chn < 16; chn++)\n\t\t{\n\t\t\tsynth_devs[dev]->chn_info[chn].pgm_num = 0;\n\t\t\treset_controllers(dev,\n\t\t\t\tsynth_devs[dev]->chn_info[chn].controllers,0);\n\t\t\tsynth_devs[dev]->chn_info[chn].bender_value = (1 << 7);\t/* Neutral */\n\t\t\tsynth_devs[dev]->chn_info[chn].bender_range = 200;\n\t\t}\n\t}\n\tmax_mididev = 0;\n\tseq_mode = SEQ_2;\n}\n\nint sequencer_open(int dev, struct file *file)\n{\n\tint retval, mode, i;\n\tint level, tmp;\n\n\tif (!sequencer_ok)\n\t\tsequencer_init();\n\n\tlevel = ((dev & 0x0f) == SND_DEV_SEQ2) ? 2 : 1;\n\n\tdev = dev >> 4;\n\tmode = translate_mode(file);\n\n\tDEB(printk(\"sequencer_open(dev=%d)\\n\", dev));\n\n\tif (!sequencer_ok)\n\t{\n/*\t\tprintk(\"Sound card: sequencer not initialized\\n\");*/\n\t\treturn -ENXIO;\n\t}\n\tif (dev)\t\t/* Patch manager device (obsolete) */\n\t\treturn -ENXIO;\n\n\tif(synth_devs[dev] == NULL)\n\t\trequest_module(\"synth0\");\n\n\tif (mode == OPEN_READ)\n\t{\n\t\tif (!num_midis)\n\t\t{\n\t\t\t/*printk(\"Sequencer: No MIDI devices. Input not possible\\n\");*/\n\t\t\tsequencer_busy = 0;\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\tif (sequencer_busy)\n\t{\n\t\treturn -EBUSY;\n\t}\n\tsequencer_busy = 1;\n\tobsolete_api_used = 0;\n\n\tmax_mididev = num_midis;\n\tmax_synthdev = num_synths;\n\tpre_event_timeout = MAX_SCHEDULE_TIMEOUT;\n\tseq_mode = SEQ_1;\n\n\tif (pending_timer != -1)\n\t{\n\t\ttmr_no = pending_timer;\n\t\tpending_timer = -1;\n\t}\n\tif (tmr_no == -1)\t/* Not selected yet */\n\t{\n\t\tint i, best;\n\n\t\tbest = -1;\n\t\tfor (i = 0; i < num_sound_timers; i++)\n\t\t\tif (sound_timer_devs[i] && sound_timer_devs[i]->priority > best)\n\t\t\t{\n\t\t\t\ttmr_no = i;\n\t\t\t\tbest = sound_timer_devs[i]->priority;\n\t\t\t}\n\t\tif (tmr_no == -1)\t/* Should not be */\n\t\t\ttmr_no = 0;\n\t}\n\ttmr = sound_timer_devs[tmr_no];\n\n\tif (level == 2)\n\t{\n\t\tif (tmr == NULL)\n\t\t{\n\t\t\t/*printk(\"sequencer: No timer for level 2\\n\");*/\n\t\t\tsequencer_busy = 0;\n\t\t\treturn -ENXIO;\n\t\t}\n\t\tsetup_mode2();\n\t}\n\tif (!max_synthdev && !max_mididev)\n\t{\n\t\tsequencer_busy=0;\n\t\treturn -ENXIO;\n\t}\n\n\tsynth_open_mask = 0;\n\n\tfor (i = 0; i < max_mididev; i++)\n\t{\n\t\tmidi_opened[i] = 0;\n\t\tmidi_written[i] = 0;\n\t}\n\n\tfor (i = 0; i < max_synthdev; i++)\n\t{\n\t\tif (synth_devs[i]==NULL)\n\t\t\tcontinue;\n\n\t\tif (!try_module_get(synth_devs[i]->owner))\n\t\t\tcontinue;\n\n\t\tif ((tmp = synth_devs[i]->open(i, mode)) < 0)\n\t\t{\n\t\t\tprintk(KERN_WARNING \"Sequencer: Warning! Cannot open synth device #%d (%d)\\n\", i, tmp);\n\t\t\tif (synth_devs[i]->midi_dev)\n\t\t\t\tprintk(KERN_WARNING \"(Maps to MIDI dev #%d)\\n\", synth_devs[i]->midi_dev);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsynth_open_mask |= (1 << i);\n\t\t\tif (synth_devs[i]->midi_dev)\n\t\t\t\tmidi_opened[synth_devs[i]->midi_dev] = 1;\n\t\t}\n\t}\n\n\tseq_time = jiffies;\n\n\tprev_input_time = 0;\n\tprev_event_time = 0;\n\n\tif (seq_mode == SEQ_1 && (mode == OPEN_READ || mode == OPEN_READWRITE))\n\t{\n\t\t/*\n\t\t * Initialize midi input devices\n\t\t */\n\n\t\tfor (i = 0; i < max_mididev; i++)\n\t\t\tif (!midi_opened[i] && midi_devs[i])\n\t\t\t{\n\t\t\t\tif (!try_module_get(midi_devs[i]->owner))\n\t\t\t\t\tcontinue;\n\t\n\t\t\t\tif ((retval = midi_devs[i]->open(i, mode,\n\t\t\t\t\tsequencer_midi_input, sequencer_midi_output)) >= 0)\n\t\t\t\t{\n\t\t\t\t\tmidi_opened[i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\tif (seq_mode == SEQ_2) {\n\t\tif (try_module_get(tmr->owner))\n\t\t\ttmr->open(tmr_no, seq_mode);\n\t}\n\n \tinit_waitqueue_head(&seq_sleeper);\n \tinit_waitqueue_head(&midi_sleeper);\n\toutput_threshold = SEQ_MAX_QUEUE / 2;\n\n\treturn 0;\n}\n\nstatic void seq_drain_midi_queues(void)\n{\n\tint i, n;\n\n\t/*\n\t * Give the Midi drivers time to drain their output queues\n\t */\n\n\tn = 1;\n\n\twhile (!signal_pending(current) && n)\n\t{\n\t\tn = 0;\n\n\t\tfor (i = 0; i < max_mididev; i++)\n\t\t\tif (midi_opened[i] && midi_written[i])\n\t\t\t\tif (midi_devs[i]->buffer_status != NULL)\n\t\t\t\t\tif (midi_devs[i]->buffer_status(i))\n\t\t\t\t\t\tn++;\n\n\t\t/*\n\t\t * Let's have a delay\n\t\t */\n\n \t\tif (n)\n \t\t\tinterruptible_sleep_on_timeout(&seq_sleeper,\n\t\t\t\t\t\t       HZ/10);\n\t}\n}\n\nvoid sequencer_release(int dev, struct file *file)\n{\n\tint i;\n\tint mode = translate_mode(file);\n\n\tdev = dev >> 4;\n\n\tDEB(printk(\"sequencer_release(dev=%d)\\n\", dev));\n\n\t/*\n\t * Wait until the queue is empty (if we don't have nonblock)\n\t */\n\n\tif (mode != OPEN_READ && !(file->f_flags & O_NONBLOCK))\n\t{\n\t\twhile (!signal_pending(current) && qlen > 0)\n\t\t{\n  \t\t\tseq_sync();\n \t\t\tinterruptible_sleep_on_timeout(&seq_sleeper,\n\t\t\t\t\t\t       3*HZ);\n \t\t\t/* Extra delay */\n\t\t}\n\t}\n\n\tif (mode != OPEN_READ)\n\t\tseq_drain_midi_queues();\t/*\n\t\t\t\t\t\t * Ensure the output queues are empty\n\t\t\t\t\t\t */\n\tseq_reset();\n\tif (mode != OPEN_READ)\n\t\tseq_drain_midi_queues();\t/*\n\t\t\t\t\t\t * Flush the all notes off messages\n\t\t\t\t\t\t */\n\n\tfor (i = 0; i < max_synthdev; i++)\n\t{\n\t\tif (synth_open_mask & (1 << i))\t/*\n\t\t\t\t\t\t * Actually opened\n\t\t\t\t\t\t */\n\t\t\tif (synth_devs[i])\n\t\t\t{\n\t\t\t\tsynth_devs[i]->close(i);\n\n\t\t\t\tmodule_put(synth_devs[i]->owner);\n\n\t\t\t\tif (synth_devs[i]->midi_dev)\n\t\t\t\t\tmidi_opened[synth_devs[i]->midi_dev] = 0;\n\t\t\t}\n\t}\n\n\tfor (i = 0; i < max_mididev; i++)\n\t{\n\t\tif (midi_opened[i]) {\n\t\t\tmidi_devs[i]->close(i);\n\t\t\tmodule_put(midi_devs[i]->owner);\n\t\t}\n\t}\n\n\tif (seq_mode == SEQ_2) {\n\t\ttmr->close(tmr_no);\n\t\tmodule_put(tmr->owner);\n\t}\n\n\tif (obsolete_api_used)\n\t\tprintk(KERN_WARNING \"/dev/music: Obsolete (4 byte) API was used by %s\\n\", current->comm);\n\tsequencer_busy = 0;\n}\n\nstatic int seq_sync(void)\n{\n\tif (qlen && !seq_playing && !signal_pending(current))\n\t\tseq_startplay();\n\n \tif (qlen > 0)\n \t\tinterruptible_sleep_on_timeout(&seq_sleeper, HZ);\n\treturn qlen;\n}\n\nstatic void midi_outc(int dev, unsigned char data)\n{\n\t/*\n\t * NOTE! Calls sleep(). Don't call this from interrupt.\n\t */\n\n\tint n;\n\tunsigned long flags;\n\n\t/*\n\t * This routine sends one byte to the Midi channel.\n\t * If the output FIFO is full, it waits until there\n\t * is space in the queue\n\t */\n\n\tn = 3 * HZ;\t\t/* Timeout */\n\n\tspin_lock_irqsave(&lock,flags);\n \twhile (n && !midi_devs[dev]->outputc(dev, data)) {\n \t\tinterruptible_sleep_on_timeout(&seq_sleeper, HZ/25);\n  \t\tn--;\n  \t}\n\tspin_unlock_irqrestore(&lock,flags);\n}\n\nstatic void seq_reset(void)\n{\n\t/*\n\t * NOTE! Calls sleep(). Don't call this from interrupt.\n\t */\n\n\tint i;\n\tint chn;\n\tunsigned long flags;\n\n\tsound_stop_timer();\n\n\tseq_time = jiffies;\n\tprev_input_time = 0;\n\tprev_event_time = 0;\n\n\tqlen = qhead = qtail = 0;\n\tiqlen = iqhead = iqtail = 0;\n\n\tfor (i = 0; i < max_synthdev; i++)\n\t\tif (synth_open_mask & (1 << i))\n\t\t\tif (synth_devs[i])\n\t\t\t\tsynth_devs[i]->reset(i);\n\n\tif (seq_mode == SEQ_2)\n\t{\n\t\tfor (chn = 0; chn < 16; chn++)\n\t\t\tfor (i = 0; i < max_synthdev; i++)\n\t\t\t\tif (synth_open_mask & (1 << i))\n\t\t\t\t\tif (synth_devs[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tsynth_devs[i]->controller(i, chn, 123, 0);\t/* All notes off */\n\t\t\t\t\t\tsynth_devs[i]->controller(i, chn, 121, 0);\t/* Reset all ctl */\n\t\t\t\t\t\tsynth_devs[i]->bender(i, chn, 1 << 13);\t/* Bender off */\n\t\t\t\t\t}\n\t}\n\telse\t/* seq_mode == SEQ_1 */\n\t{\n\t\tfor (i = 0; i < max_mididev; i++)\n\t\t\tif (midi_written[i])\t/*\n\t\t\t\t\t\t * Midi used. Some notes may still be playing\n\t\t\t\t\t\t */\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t *      Sending just a ACTIVE SENSING message should be enough to stop all\n\t\t\t\t *      playing notes. Since there are devices not recognizing the\n\t\t\t\t *      active sensing, we have to send some all notes off messages also.\n\t\t\t\t */\n\t\t\t\tmidi_outc(i, 0xfe);\n\n\t\t\t\tfor (chn = 0; chn < 16; chn++)\n\t\t\t\t{\n\t\t\t\t\tmidi_outc(i, (unsigned char) (0xb0 + (chn & 0x0f)));\t\t/* control change */\n\t\t\t\t\tmidi_outc(i, 0x7b);\t/* All notes off */\n\t\t\t\t\tmidi_outc(i, 0);\t/* Dummy parameter */\n\t\t\t\t}\n\n\t\t\t\tmidi_devs[i]->close(i);\n\n\t\t\t\tmidi_written[i] = 0;\n\t\t\t\tmidi_opened[i] = 0;\n\t\t\t}\n\t}\n\n\tseq_playing = 0;\n\n\tspin_lock_irqsave(&lock,flags);\n\n\tif (waitqueue_active(&seq_sleeper)) {\n\t\t/*      printk( \"Sequencer Warning: Unexpected sleeping process - Waking up\\n\"); */\n\t\twake_up(&seq_sleeper);\n\t}\n\tspin_unlock_irqrestore(&lock,flags);\n}\n\nstatic void seq_panic(void)\n{\n\t/*\n\t * This routine is called by the application in case the user\n\t * wants to reset the system to the default state.\n\t */\n\n\tseq_reset();\n\n\t/*\n\t * Since some of the devices don't recognize the active sensing and\n\t * all notes off messages, we have to shut all notes manually.\n\t *\n\t *      TO BE IMPLEMENTED LATER\n\t */\n\n\t/*\n\t * Also return the controllers to their default states\n\t */\n}\n\nint sequencer_ioctl(int dev, struct file *file, unsigned int cmd, void __user *arg)\n{\n\tint midi_dev, orig_dev, val, err;\n\tint mode = translate_mode(file);\n\tstruct synth_info inf;\n\tstruct seq_event_rec event_rec;\n\tunsigned long flags;\n\tint __user *p = arg;\n\n\torig_dev = dev = dev >> 4;\n\n\tswitch (cmd)\n\t{\n\t\tcase SNDCTL_TMR_TIMEBASE:\n\t\tcase SNDCTL_TMR_TEMPO:\n\t\tcase SNDCTL_TMR_START:\n\t\tcase SNDCTL_TMR_STOP:\n\t\tcase SNDCTL_TMR_CONTINUE:\n\t\tcase SNDCTL_TMR_METRONOME:\n\t\tcase SNDCTL_TMR_SOURCE:\n\t\t\tif (seq_mode != SEQ_2)\n\t\t\t\treturn -EINVAL;\n\t\t\treturn tmr->ioctl(tmr_no, cmd, arg);\n\n\t\tcase SNDCTL_TMR_SELECT:\n\t\t\tif (seq_mode != SEQ_2)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (get_user(pending_timer, p))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (pending_timer < 0 || pending_timer >= num_sound_timers || sound_timer_devs[pending_timer] == NULL)\n\t\t\t{\n\t\t\t\tpending_timer = -1;\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tval = pending_timer;\n\t\t\tbreak;\n\n\t\tcase SNDCTL_SEQ_PANIC:\n\t\t\tseq_panic();\n\t\t\treturn -EINVAL;\n\n\t\tcase SNDCTL_SEQ_SYNC:\n\t\t\tif (mode == OPEN_READ)\n\t\t\t\treturn 0;\n\t\t\twhile (qlen > 0 && !signal_pending(current))\n\t\t\t\tseq_sync();\n\t\t\treturn qlen ? -EINTR : 0;\n\n\t\tcase SNDCTL_SEQ_RESET:\n\t\t\tseq_reset();\n\t\t\treturn 0;\n\n\t\tcase SNDCTL_SEQ_TESTMIDI:\n\t\t\tif (__get_user(midi_dev, p))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (midi_dev < 0 || midi_dev >= max_mididev || !midi_devs[midi_dev])\n\t\t\t\treturn -ENXIO;\n\n\t\t\tif (!midi_opened[midi_dev] &&\n\t\t\t\t(err = midi_devs[midi_dev]->open(midi_dev, mode, sequencer_midi_input,\n\t\t\t\t\t\t     sequencer_midi_output)) < 0)\n\t\t\t\treturn err;\n\t\t\tmidi_opened[midi_dev] = 1;\n\t\t\treturn 0;\n\n\t\tcase SNDCTL_SEQ_GETINCOUNT:\n\t\t\tif (mode == OPEN_WRITE)\n\t\t\t\treturn 0;\n\t\t\tval = iqlen;\n\t\t\tbreak;\n\n\t\tcase SNDCTL_SEQ_GETOUTCOUNT:\n\t\t\tif (mode == OPEN_READ)\n\t\t\t\treturn 0;\n\t\t\tval = SEQ_MAX_QUEUE - qlen;\n\t\t\tbreak;\n\n\t\tcase SNDCTL_SEQ_GETTIME:\n\t\t\tif (seq_mode == SEQ_2)\n\t\t\t\treturn tmr->ioctl(tmr_no, cmd, arg);\n\t\t\tval = jiffies - seq_time;\n\t\t\tbreak;\n\n\t\tcase SNDCTL_SEQ_CTRLRATE:\n\t\t\t/*\n\t\t\t * If *arg == 0, just return the current rate\n\t\t\t */\n\t\t\tif (seq_mode == SEQ_2)\n\t\t\t\treturn tmr->ioctl(tmr_no, cmd, arg);\n\n\t\t\tif (get_user(val, p))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (val != 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tval = HZ;\n\t\t\tbreak;\n\n\t\tcase SNDCTL_SEQ_RESETSAMPLES:\n\t\tcase SNDCTL_SYNTH_REMOVESAMPLE:\n\t\tcase SNDCTL_SYNTH_CONTROL:\n\t\t\tif (get_user(dev, p))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (dev < 0 || dev >= num_synths || synth_devs[dev] == NULL)\n\t\t\t\treturn -ENXIO;\n\t\t\tif (!(synth_open_mask & (1 << dev)) && !orig_dev)\n\t\t\t\treturn -EBUSY;\n\t\t\treturn synth_devs[dev]->ioctl(dev, cmd, arg);\n\n\t\tcase SNDCTL_SEQ_NRSYNTHS:\n\t\t\tval = max_synthdev;\n\t\t\tbreak;\n\n\t\tcase SNDCTL_SEQ_NRMIDIS:\n\t\t\tval = max_mididev;\n\t\t\tbreak;\n\n\t\tcase SNDCTL_SYNTH_MEMAVL:\n\t\t\tif (get_user(dev, p))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (dev < 0 || dev >= num_synths || synth_devs[dev] == NULL)\n\t\t\t\treturn -ENXIO;\n\t\t\tif (!(synth_open_mask & (1 << dev)) && !orig_dev)\n\t\t\t\treturn -EBUSY;\n\t\t\tval = synth_devs[dev]->ioctl(dev, cmd, arg);\n\t\t\tbreak;\n\n\t\tcase SNDCTL_FM_4OP_ENABLE:\n\t\t\tif (get_user(dev, p))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (dev < 0 || dev >= num_synths || synth_devs[dev] == NULL)\n\t\t\t\treturn -ENXIO;\n\t\t\tif (!(synth_open_mask & (1 << dev)))\n\t\t\t\treturn -ENXIO;\n\t\t\tsynth_devs[dev]->ioctl(dev, cmd, arg);\n\t\t\treturn 0;\n\n\t\tcase SNDCTL_SYNTH_INFO:\n\t\t\tif (get_user(dev, &((struct synth_info __user *)arg)->device))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (dev < 0 || dev >= max_synthdev)\n\t\t\t\treturn -ENXIO;\n\t\t\tif (!(synth_open_mask & (1 << dev)) && !orig_dev)\n\t\t\t\treturn -EBUSY;\n\t\t\treturn synth_devs[dev]->ioctl(dev, cmd, arg);\n\n\t\t/* Like SYNTH_INFO but returns ID in the name field */\n\t\tcase SNDCTL_SYNTH_ID:\n\t\t\tif (get_user(dev, &((struct synth_info __user *)arg)->device))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (dev < 0 || dev >= max_synthdev)\n\t\t\t\treturn -ENXIO;\n\t\t\tif (!(synth_open_mask & (1 << dev)) && !orig_dev)\n\t\t\t\treturn -EBUSY;\n\t\t\tmemcpy(&inf, synth_devs[dev]->info, sizeof(inf));\n\t\t\tstrlcpy(inf.name, synth_devs[dev]->id, sizeof(inf.name));\n\t\t\tinf.device = dev;\n\t\t\treturn copy_to_user(arg, &inf, sizeof(inf))?-EFAULT:0;\n\n\t\tcase SNDCTL_SEQ_OUTOFBAND:\n\t\t\tif (copy_from_user(&event_rec, arg, sizeof(event_rec)))\n\t\t\t\treturn -EFAULT;\n\t\t\tspin_lock_irqsave(&lock,flags);\n\t\t\tplay_event(event_rec.arr);\n\t\t\tspin_unlock_irqrestore(&lock,flags);\n\t\t\treturn 0;\n\n\t\tcase SNDCTL_MIDI_INFO:\n\t\t\tif (get_user(dev, &((struct midi_info __user *)arg)->device))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (dev < 0 || dev >= max_mididev || !midi_devs[dev])\n\t\t\t\treturn -ENXIO;\n\t\t\tmidi_devs[dev]->info.device = dev;\n\t\t\treturn copy_to_user(arg, &midi_devs[dev]->info, sizeof(struct midi_info))?-EFAULT:0;\n\n\t\tcase SNDCTL_SEQ_THRESHOLD:\n\t\t\tif (get_user(val, p))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (val < 1)\n\t\t\t\tval = 1;\n\t\t\tif (val >= SEQ_MAX_QUEUE)\n\t\t\t\tval = SEQ_MAX_QUEUE - 1;\n\t\t\toutput_threshold = val;\n\t\t\treturn 0;\n\n\t\tcase SNDCTL_MIDI_PRETIME:\n\t\t\tif (get_user(val, p))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (val < 0)\n\t\t\t\tval = 0;\n\t\t\tval = (HZ * val) / 10;\n\t\t\tpre_event_timeout = val;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (mode == OPEN_READ)\n\t\t\t\treturn -EIO;\n\t\t\tif (!synth_devs[0])\n\t\t\t\treturn -ENXIO;\n\t\t\tif (!(synth_open_mask & (1 << 0)))\n\t\t\t\treturn -ENXIO;\n\t\t\tif (!synth_devs[0]->ioctl)\n\t\t\t\treturn -EINVAL;\n\t\t\treturn synth_devs[0]->ioctl(0, cmd, arg);\n\t}\n\treturn put_user(val, p);\n}\n\n/* No kernel lock - we're using the global irq lock here */\nunsigned int sequencer_poll(int dev, struct file *file, poll_table * wait)\n{\n\tunsigned long flags;\n\tunsigned int mask = 0;\n\n\tdev = dev >> 4;\n\n\tspin_lock_irqsave(&lock,flags);\n\t/* input */\n\tpoll_wait(file, &midi_sleeper, wait);\n\tif (iqlen)\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\t/* output */\n\tpoll_wait(file, &seq_sleeper, wait);\n\tif ((SEQ_MAX_QUEUE - qlen) >= output_threshold)\n\t\tmask |= POLLOUT | POLLWRNORM;\n\tspin_unlock_irqrestore(&lock,flags);\n\treturn mask;\n}\n\n\nvoid sequencer_timer(unsigned long dummy)\n{\n\tseq_startplay();\n}\nEXPORT_SYMBOL(sequencer_timer);\n\nint note_to_freq(int note_num)\n{\n\n\t/*\n\t * This routine converts a midi note to a frequency (multiplied by 1000)\n\t */\n\n\tint note, octave, note_freq;\n\tstatic int notes[] =\n\t{\n\t\t261632, 277189, 293671, 311132, 329632, 349232,\n\t\t369998, 391998, 415306, 440000, 466162, 493880\n\t};\n\n#define BASE_OCTAVE\t5\n\n\toctave = note_num / 12;\n\tnote = note_num % 12;\n\n\tnote_freq = notes[note];\n\n\tif (octave < BASE_OCTAVE)\n\t\tnote_freq >>= (BASE_OCTAVE - octave);\n\telse if (octave > BASE_OCTAVE)\n\t\tnote_freq <<= (octave - BASE_OCTAVE);\n\n\t/*\n\t * note_freq >>= 1;\n\t */\n\n\treturn note_freq;\n}\nEXPORT_SYMBOL(note_to_freq);\n\nunsigned long compute_finetune(unsigned long base_freq, int bend, int range,\n\t\t int vibrato_cents)\n{\n\tunsigned long amount;\n\tint negative, semitones, cents, multiplier = 1;\n\n\tif (!bend)\n\t\treturn base_freq;\n\tif (!range)\n\t\treturn base_freq;\n\n\tif (!base_freq)\n\t\treturn base_freq;\n\n\tif (range >= 8192)\n\t\trange = 8192;\n\n\tbend = bend * range / 8192;\t/* Convert to cents */\n\tbend += vibrato_cents;\n\n\tif (!bend)\n\t\treturn base_freq;\n\n\tnegative = bend < 0 ? 1 : 0;\n\n\tif (bend < 0)\n\t\tbend *= -1;\n\tif (bend > range)\n\t\tbend = range;\n\n\t/*\n\t   if (bend > 2399)\n\t   bend = 2399;\n\t */\n\twhile (bend > 2399)\n\t{\n\t\tmultiplier *= 4;\n\t\tbend -= 2400;\n\t}\n\n\tsemitones = bend / 100;\n\tcents = bend % 100;\n\n\tamount = (int) (semitone_tuning[semitones] * multiplier * cent_tuning[cents]) / 10000;\n\n\tif (negative)\n\t\treturn (base_freq * 10000) / amount;\t/* Bend down */\n\telse\n\t\treturn (base_freq * amount) / 10000;\t/* Bend up */\n}\nEXPORT_SYMBOL(compute_finetune);\n\nvoid sequencer_init(void)\n{\n\tif (sequencer_ok)\n\t\treturn;\n\tqueue = vmalloc(SEQ_MAX_QUEUE * EV_SZ);\n\tif (queue == NULL)\n\t{\n\t\tprintk(KERN_ERR \"sequencer: Can't allocate memory for sequencer output queue\\n\");\n\t\treturn;\n\t}\n\tiqueue = vmalloc(SEQ_MAX_QUEUE * IEV_SZ);\n\tif (iqueue == NULL)\n\t{\n\t\tprintk(KERN_ERR \"sequencer: Can't allocate memory for sequencer input queue\\n\");\n\t\tvfree(queue);\n\t\treturn;\n\t}\n\tsequencer_ok = 1;\n}\nEXPORT_SYMBOL(sequencer_init);\n\nvoid sequencer_unload(void)\n{\n\tvfree(queue);\n\tvfree(iqueue);\n\tqueue = iqueue = NULL;\n}\n"], "fixing_code": ["/*\n *\tdev_table.h\n *\n *\tGlobal definitions for device call tables\n *\n *\n * Copyright (C) by Hannu Savolainen 1993-1997\n *\n * OSS/Free for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)\n * Version 2 (June 1991). See the \"COPYING\" file distributed with this software\n * for more info.\n */\n\n\n#ifndef _DEV_TABLE_H_\n#define _DEV_TABLE_H_\n\n#include <linux/spinlock.h>\n/*\n * Sound card numbers 27 to 999. (1 to 26 are defined in soundcard.h)\n * Numbers 1000 to N are reserved for driver's internal use.\n */\n\n#define SNDCARD_DESKPROXL\t\t27\t/* Compaq Deskpro XL */\n#define SNDCARD_VIDC\t\t\t28\t/* ARMs VIDC */\n#define SNDCARD_SBPNP\t\t\t29\n#define SNDCARD_SOFTOSS\t\t\t36\n#define SNDCARD_VMIDI\t\t\t37\n#define SNDCARD_OPL3SA1\t\t\t38\t/* Note: clash in msnd.h */\n#define SNDCARD_OPL3SA1_SB\t\t39\n#define SNDCARD_OPL3SA1_MPU\t\t40\n#define SNDCARD_WAVEFRONT               41\n#define SNDCARD_OPL3SA2                 42\n#define SNDCARD_OPL3SA2_MPU             43\n#define SNDCARD_WAVEARTIST              44\t/* Waveartist */\n#define SNDCARD_OPL3SA2_MSS             45\t/* Originally missed */\n#define SNDCARD_AD1816                  88\n\n/*\n *\tNOTE! \tNOTE!\tNOTE!\tNOTE!\n *\n *\tIf you modify this file, please check the dev_table.c also.\n *\n *\tNOTE! \tNOTE!\tNOTE!\tNOTE!\n */\n\nstruct driver_info \n{\n\tchar *driver_id;\n\tint card_subtype;\t/* Driver specific. Usually 0 */\n\tint card_type;\t\t/*\tFrom soundcard.h\t*/\n\tchar *name;\n\tvoid (*attach) (struct address_info *hw_config);\n\tint (*probe) (struct address_info *hw_config);\n\tvoid (*unload) (struct address_info *hw_config);\n};\n\nstruct card_info \n{\n\tint card_type;\t/* Link (search key) to the driver list */\n\tstruct address_info config;\n\tint enabled;\n\tvoid *for_driver_use;\n};\n\n\n/*\n * Device specific parameters (used only by dmabuf.c)\n */\n#define MAX_SUB_BUFFERS\t\t(32*MAX_REALTIME_FACTOR)\n\n#define DMODE_NONE\t\t0\n#define DMODE_OUTPUT\t\tPCM_ENABLE_OUTPUT\n#define DMODE_INPUT\t\tPCM_ENABLE_INPUT\n\nstruct dma_buffparms \n{\n\tint      dma_mode;\t/* DMODE_INPUT, DMODE_OUTPUT or DMODE_NONE */\n\tint\t closing;\n\n\t/*\n \t * Pointers to raw buffers\n \t */\n\n  \tchar     *raw_buf;\n    \tunsigned long   raw_buf_phys;\n\tint buffsize;\n\n     \t/*\n         * Device state tables\n         */\n\n\tunsigned long flags;\n#define DMA_BUSY\t0x00000001\n#define DMA_RESTART\t0x00000002\n#define DMA_ACTIVE\t0x00000004\n#define DMA_STARTED\t0x00000008\n#define DMA_EMPTY\t0x00000010\t\n#define DMA_ALLOC_DONE\t0x00000020\n#define DMA_SYNCING\t0x00000040\n#define DMA_DIRTY\t0x00000080\n#define DMA_POST\t0x00000100\n#define DMA_NODMA\t0x00000200\n#define DMA_NOTIMEOUT\t0x00000400\n\n\tint      open_mode;\n\n\t/*\n\t * Queue parameters.\n\t */\n\tint      qlen;\n\tint      qhead;\n\tint      qtail;\n\tspinlock_t lock;\n\t\t\n\tint\t cfrag;\t/* Current incomplete fragment (write) */\n\n\tint      nbufs;\n\tint      counts[MAX_SUB_BUFFERS];\n\tint      subdivision;\n\n\tint      fragment_size;\n        int\t needs_reorg;\n\tint\t max_fragments;\n\n\tint\t bytes_in_use;\n\n\tint\t underrun_count;\n\tunsigned long\t byte_counter;\n\tunsigned long\t user_counter;\n\tunsigned long\t max_byte_counter;\n\tint\t data_rate; /* Bytes/second */\n\n\tint\t mapping_flags;\n#define\t\t\tDMA_MAP_MAPPED\t\t0x00000001\n\tchar\tneutral_byte;\n\tint\tdma;\t\t/* DMA channel */\n\n\tint     applic_profile;\t/* Application profile (APF_*) */\n\t/* Interrupt callback stuff */\n\tvoid (*audio_callback) (int dev, int parm);\n\tint callback_parm;\n\n\tint\t buf_flags[MAX_SUB_BUFFERS];\n#define\t\t BUFF_EOF\t\t0x00000001 /* Increment eof count */\n#define\t\t BUFF_DIRTY\t\t0x00000002 /* Buffer written */\n};\n\n/*\n * Structure for use with various microcontrollers and DSP processors \n * in the recent sound cards.\n */\ntypedef struct coproc_operations \n{\n\tchar name[64];\n\tstruct module *owner;\n\tint (*open) (void *devc, int sub_device);\n\tvoid (*close) (void *devc, int sub_device);\n\tint (*ioctl) (void *devc, unsigned int cmd, void __user * arg, int local);\n\tvoid (*reset) (void *devc);\n\n\tvoid *devc;\t\t/* Driver specific info */\n} coproc_operations;\n\nstruct audio_driver \n{\n\tstruct module *owner;\n\tint (*open) (int dev, int mode);\n\tvoid (*close) (int dev);\n\tvoid (*output_block) (int dev, unsigned long buf, \n\t\t\t      int count, int intrflag);\n\tvoid (*start_input) (int dev, unsigned long buf, \n\t\t\t     int count, int intrflag);\n\tint (*ioctl) (int dev, unsigned int cmd, void __user * arg);\n\tint (*prepare_for_input) (int dev, int bufsize, int nbufs);\n\tint (*prepare_for_output) (int dev, int bufsize, int nbufs);\n\tvoid (*halt_io) (int dev);\n\tint (*local_qlen)(int dev);\n\tvoid (*copy_user) (int dev,\n\t\t\tchar *localbuf, int localoffs,\n                        const char __user *userbuf, int useroffs,\n                        int max_in, int max_out,\n                        int *used, int *returned,\n                        int len);\n\tvoid (*halt_input) (int dev);\n\tvoid (*halt_output) (int dev);\n\tvoid (*trigger) (int dev, int bits);\n\tint (*set_speed)(int dev, int speed);\n\tunsigned int (*set_bits)(int dev, unsigned int bits);\n\tshort (*set_channels)(int dev, short channels);\n\tvoid (*postprocess_write)(int dev); \t/* Device spesific postprocessing for written data */\n\tvoid (*preprocess_read)(int dev); \t/* Device spesific preprocessing for read data */\n\tvoid (*mmap)(int dev);\n};\n\nstruct audio_operations \n{\n        char name[128];\n\tint flags;\n#define NOTHING_SPECIAL \t0x00\n#define NEEDS_RESTART\t\t0x01\n#define DMA_AUTOMODE\t\t0x02\n#define DMA_DUPLEX\t\t0x04\n#define DMA_PSEUDO_AUTOMODE\t0x08\n#define DMA_HARDSTOP\t\t0x10\n#define DMA_EXACT\t\t0x40\n#define DMA_NORESET\t\t0x80\n\tint  format_mask;\t/* Bitmask for supported audio formats */\n\tvoid *devc;\t\t/* Driver specific info */\n\tstruct audio_driver *d;\n\tvoid *portc;\t\t/* Driver specific info */\n\tstruct dma_buffparms *dmap_in, *dmap_out;\n\tstruct coproc_operations *coproc;\n\tint mixer_dev;\n\tint enable_bits;\n \tint open_mode;\n\tint go;\n\tint min_fragment;\t/* 0 == unlimited */\n\tint max_fragment;\t/* 0 == unlimited */\n\tint parent_dev;\t\t/* 0 -> no parent, 1 to n -> parent=parent_dev+1 */\n\n\t/* fields formerly in dmabuf.c */\n\twait_queue_head_t in_sleeper;\n\twait_queue_head_t out_sleeper;\n\twait_queue_head_t poll_sleeper;\n\n\t/* fields formerly in audio.c */\n\tint audio_mode;\n\n#define\t\tAM_NONE\t\t0\n#define\t\tAM_WRITE\tOPEN_WRITE\n#define \tAM_READ\t\tOPEN_READ\n\n\tint local_format;\n\tint audio_format;\n\tint local_conversion;\n#define CNV_MU_LAW\t0x00000001\n\n\t/* large structures at the end to keep offsets small */\n\tstruct dma_buffparms dmaps[2];\n};\n\nint *load_mixer_volumes(char *name, int *levels, int present);\n\nstruct mixer_operations \n{\n\tstruct module *owner;\n\tchar id[16];\n\tchar name[64];\n\tint (*ioctl) (int dev, unsigned int cmd, void __user * arg);\n\t\n\tvoid *devc;\n\tint modify_counter;\n};\n\nstruct synth_operations \n{\n\tstruct module *owner;\n\tchar *id;\t/* Unique identifier (ASCII) max 29 char */\n\tstruct synth_info *info;\n\tint midi_dev;\n\tint synth_type;\n\tint synth_subtype;\n\n\tint (*open) (int dev, int mode);\n\tvoid (*close) (int dev);\n\tint (*ioctl) (int dev, unsigned int cmd, void __user * arg);\n\tint (*kill_note) (int dev, int voice, int note, int velocity);\n\tint (*start_note) (int dev, int voice, int note, int velocity);\n\tint (*set_instr) (int dev, int voice, int instr);\n\tvoid (*reset) (int dev);\n\tvoid (*hw_control) (int dev, unsigned char *event);\n\tint (*load_patch) (int dev, int format, const char __user *addr,\n\t     int count, int pmgr_flag);\n\tvoid (*aftertouch) (int dev, int voice, int pressure);\n\tvoid (*controller) (int dev, int voice, int ctrl_num, int value);\n\tvoid (*panning) (int dev, int voice, int value);\n\tvoid (*volume_method) (int dev, int mode);\n\tvoid (*bender) (int dev, int chn, int value);\n\tint (*alloc_voice) (int dev, int chn, int note, struct voice_alloc_info *alloc);\n\tvoid (*setup_voice) (int dev, int voice, int chn);\n\tint (*send_sysex)(int dev, unsigned char *bytes, int len);\n\n \tstruct voice_alloc_info alloc;\n \tstruct channel_info chn_info[16];\n\tint emulation;\n#define\tEMU_GM\t\t\t1\t/* General MIDI */\n#define\tEMU_XG\t\t\t2\t/* Yamaha XG */\n#define MAX_SYSEX_BUF\t64\n\tunsigned char sysex_buf[MAX_SYSEX_BUF];\n\tint sysex_ptr;\n};\n\nstruct midi_input_info \n{\n\t/* MIDI input scanner variables */\n#define MI_MAX\t10\n\tvolatile int             m_busy;\n    \tunsigned char   m_buf[MI_MAX];\n\tunsigned char\tm_prev_status;\t/* For running status */\n    \tint             m_ptr;\n#define MST_INIT\t\t\t0\n#define MST_DATA\t\t\t1\n#define MST_SYSEX\t\t\t2\n    \tint             m_state;\n    \tint             m_left;\n};\n\nstruct midi_operations \n{\n\tstruct module *owner;\n\tstruct midi_info info;\n\tstruct synth_operations *converter;\n\tstruct midi_input_info in_info;\n\tint (*open) (int dev, int mode,\n\t\tvoid (*inputintr)(int dev, unsigned char data),\n\t\tvoid (*outputintr)(int dev)\n\t\t);\n\tvoid (*close) (int dev);\n\tint (*ioctl) (int dev, unsigned int cmd, void __user * arg);\n\tint (*outputc) (int dev, unsigned char data);\n\tint (*start_read) (int dev);\n\tint (*end_read) (int dev);\n\tvoid (*kick)(int dev);\n\tint (*command) (int dev, unsigned char *data);\n\tint (*buffer_status) (int dev);\n\tint (*prefix_cmd) (int dev, unsigned char status);\n\tstruct coproc_operations *coproc;\n\tvoid *devc;\n};\n\nstruct sound_lowlev_timer \n{\n\tint dev;\n\tint priority;\n\tunsigned int (*tmr_start)(int dev, unsigned int usecs);\n\tvoid (*tmr_disable)(int dev);\n\tvoid (*tmr_restart)(int dev);\n};\n\nstruct sound_timer_operations \n{\n\tstruct module *owner;\n\tstruct sound_timer_info info;\n\tint priority;\n\tint devlink;\n\tint (*open)(int dev, int mode);\n\tvoid (*close)(int dev);\n\tint (*event)(int dev, unsigned char *ev);\n\tunsigned long (*get_time)(int dev);\n\tint (*ioctl) (int dev, unsigned int cmd, void __user * arg);\n\tvoid (*arm_timer)(int dev, long time);\n};\n\nextern struct sound_timer_operations default_sound_timer;\n\nextern struct audio_operations *audio_devs[MAX_AUDIO_DEV];\nextern int num_audiodevs;\nextern struct mixer_operations *mixer_devs[MAX_MIXER_DEV];\nextern int num_mixers;\nextern struct synth_operations *synth_devs[MAX_SYNTH_DEV+MAX_MIDI_DEV];\nextern int num_synths;\nextern struct midi_operations *midi_devs[MAX_MIDI_DEV];\nextern int num_midis;\nextern struct sound_timer_operations * sound_timer_devs[MAX_TIMER_DEV];\nextern int num_sound_timers;\n\nextern int sound_map_buffer (int dev, struct dma_buffparms *dmap, buffmem_desc *info);\nvoid sound_timer_init (struct sound_lowlev_timer *t, char *name);\nvoid sound_dma_intr (int dev, struct dma_buffparms *dmap, int chan);\n\n#define AUDIO_DRIVER_VERSION\t2\n#define MIXER_DRIVER_VERSION\t2\nint sound_install_audiodrv(int vers, char *name, struct audio_driver *driver,\n\t\t\tint driver_size, int flags, unsigned int format_mask,\n\t\t\tvoid *devc, int dma1, int dma2);\nint sound_install_mixer(int vers, char *name, struct mixer_operations *driver,\n\t\t\tint driver_size, void *devc);\n\nvoid sound_unload_audiodev(int dev);\nvoid sound_unload_mixerdev(int dev);\nvoid sound_unload_mididev(int dev);\nvoid sound_unload_synthdev(int dev);\nvoid sound_unload_timerdev(int dev);\nint sound_alloc_mixerdev(void);\nint sound_alloc_timerdev(void);\nint sound_alloc_synthdev(void);\nint sound_alloc_mididev(void);\n#endif\t/* _DEV_TABLE_H_ */\n\n", "/*\n * sound/oss/midi_synth.c\n *\n * High level midi sequencer manager for dumb MIDI interfaces.\n */\n/*\n * Copyright (C) by Hannu Savolainen 1993-1997\n *\n * OSS/Free for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)\n * Version 2 (June 1991). See the \"COPYING\" file distributed with this software\n * for more info.\n */\n/*\n * Thomas Sailer   : ioctl code reworked (vmalloc/vfree removed)\n * Andrew Veliath  : fixed running status in MIDI input state machine\n */\n#define USE_SEQ_MACROS\n#define USE_SIMPLE_MACROS\n\n#include \"sound_config.h\"\n\n#define _MIDI_SYNTH_C_\n\n#include \"midi_synth.h\"\n\nstatic int      midi2synth[MAX_MIDI_DEV];\nstatic int      sysex_state[MAX_MIDI_DEV] =\n{0};\nstatic unsigned char prev_out_status[MAX_MIDI_DEV];\n\n#define STORE(cmd) \\\n{ \\\n  int len; \\\n  unsigned char obuf[8]; \\\n  cmd; \\\n  seq_input_event(obuf, len); \\\n}\n\n#define _seqbuf obuf\n#define _seqbufptr 0\n#define _SEQ_ADVBUF(x) len=x\n\nvoid\ndo_midi_msg(int synthno, unsigned char *msg, int mlen)\n{\n\tswitch (msg[0] & 0xf0)\n\t  {\n\t  case 0x90:\n\t\t  if (msg[2] != 0)\n\t\t    {\n\t\t\t    STORE(SEQ_START_NOTE(synthno, msg[0] & 0x0f, msg[1], msg[2]));\n\t\t\t    break;\n\t\t    }\n\t\t  msg[2] = 64;\n\n\t  case 0x80:\n\t\t  STORE(SEQ_STOP_NOTE(synthno, msg[0] & 0x0f, msg[1], msg[2]));\n\t\t  break;\n\n\t  case 0xA0:\n\t\t  STORE(SEQ_KEY_PRESSURE(synthno, msg[0] & 0x0f, msg[1], msg[2]));\n\t\t  break;\n\n\t  case 0xB0:\n\t\t  STORE(SEQ_CONTROL(synthno, msg[0] & 0x0f,\n\t\t\t\t    msg[1], msg[2]));\n\t\t  break;\n\n\t  case 0xC0:\n\t\t  STORE(SEQ_SET_PATCH(synthno, msg[0] & 0x0f, msg[1]));\n\t\t  break;\n\n\t  case 0xD0:\n\t\t  STORE(SEQ_CHN_PRESSURE(synthno, msg[0] & 0x0f, msg[1]));\n\t\t  break;\n\n\t  case 0xE0:\n\t\t  STORE(SEQ_BENDER(synthno, msg[0] & 0x0f,\n\t\t\t      (msg[1] & 0x7f) | ((msg[2] & 0x7f) << 7)));\n\t\t  break;\n\n\t  default:\n\t\t  /* printk( \"MPU: Unknown midi channel message %02x\\n\",  msg[0]); */\n\t\t  ;\n\t  }\n}\nEXPORT_SYMBOL(do_midi_msg);\n\nstatic void\nmidi_outc(int midi_dev, int data)\n{\n\tint             timeout;\n\n\tfor (timeout = 0; timeout < 3200; timeout++)\n\t\tif (midi_devs[midi_dev]->outputc(midi_dev, (unsigned char) (data & 0xff)))\n\t\t  {\n\t\t\t  if (data & 0x80)\t/*\n\t\t\t\t\t\t * Status byte\n\t\t\t\t\t\t */\n\t\t\t\t  prev_out_status[midi_dev] =\n\t\t\t\t      (unsigned char) (data & 0xff);\t/*\n\t\t\t\t\t\t\t\t\t * Store for running status\n\t\t\t\t\t\t\t\t\t */\n\t\t\t  return;\t/*\n\t\t\t\t\t * Mission complete\n\t\t\t\t\t */\n\t\t  }\n\t/*\n\t * Sorry! No space on buffers.\n\t */\n\tprintk(\"Midi send timed out\\n\");\n}\n\nstatic int\nprefix_cmd(int midi_dev, unsigned char status)\n{\n\tif ((char *) midi_devs[midi_dev]->prefix_cmd == NULL)\n\t\treturn 1;\n\n\treturn midi_devs[midi_dev]->prefix_cmd(midi_dev, status);\n}\n\nstatic void\nmidi_synth_input(int orig_dev, unsigned char data)\n{\n\tint             dev;\n\tstruct midi_input_info *inc;\n\n\tstatic unsigned char len_tab[] =\t/* # of data bytes following a status\n\t\t\t\t\t\t */\n\t{\n\t\t2,\t\t/* 8x */\n\t\t2,\t\t/* 9x */\n\t\t2,\t\t/* Ax */\n\t\t2,\t\t/* Bx */\n\t\t1,\t\t/* Cx */\n\t\t1,\t\t/* Dx */\n\t\t2,\t\t/* Ex */\n\t\t0\t\t/* Fx */\n\t};\n\n\tif (orig_dev < 0 || orig_dev > num_midis || midi_devs[orig_dev] == NULL)\n\t\treturn;\n\n\tif (data == 0xfe)\t/* Ignore active sensing */\n\t\treturn;\n\n\tdev = midi2synth[orig_dev];\n\tinc = &midi_devs[orig_dev]->in_info;\n\n\tswitch (inc->m_state)\n\t  {\n\t  case MST_INIT:\n\t\t  if (data & 0x80)\t/* MIDI status byte */\n\t\t    {\n\t\t\t    if ((data & 0xf0) == 0xf0)\t/* Common message */\n\t\t\t      {\n\t\t\t\t      switch (data)\n\t\t\t\t\t{\n\t\t\t\t\tcase 0xf0:\t/* Sysex */\n\t\t\t\t\t\tinc->m_state = MST_SYSEX;\n\t\t\t\t\t\tbreak;\t/* Sysex */\n\n\t\t\t\t\tcase 0xf1:\t/* MTC quarter frame */\n\t\t\t\t\tcase 0xf3:\t/* Song select */\n\t\t\t\t\t\tinc->m_state = MST_DATA;\n\t\t\t\t\t\tinc->m_ptr = 1;\n\t\t\t\t\t\tinc->m_left = 1;\n\t\t\t\t\t\tinc->m_buf[0] = data;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 0xf2:\t/* Song position pointer */\n\t\t\t\t\t\tinc->m_state = MST_DATA;\n\t\t\t\t\t\tinc->m_ptr = 1;\n\t\t\t\t\t\tinc->m_left = 2;\n\t\t\t\t\t\tinc->m_buf[0] = data;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tinc->m_buf[0] = data;\n\t\t\t\t\t\tinc->m_ptr = 1;\n\t\t\t\t\t\tdo_midi_msg(dev, inc->m_buf, inc->m_ptr);\n\t\t\t\t\t\tinc->m_ptr = 0;\n\t\t\t\t\t\tinc->m_left = 0;\n\t\t\t\t\t}\n\t\t\t    } else\n\t\t\t      {\n\t\t\t\t      inc->m_state = MST_DATA;\n\t\t\t\t      inc->m_ptr = 1;\n\t\t\t\t      inc->m_left = len_tab[(data >> 4) - 8];\n\t\t\t\t      inc->m_buf[0] = inc->m_prev_status = data;\n\t\t\t      }\n\t\t    } else if (inc->m_prev_status & 0x80) {\n\t\t\t    /* Data byte (use running status) */\n\t\t\t    inc->m_ptr = 2;\n\t\t\t    inc->m_buf[1] = data;\n\t\t\t    inc->m_buf[0] = inc->m_prev_status;\n\t\t\t    inc->m_left = len_tab[(inc->m_buf[0] >> 4) - 8] - 1;\n\t\t\t    if (inc->m_left > 0)\n\t\t\t\t    inc->m_state = MST_DATA; /* Not done yet */\n\t\t\t    else {\n\t\t\t\t    inc->m_state = MST_INIT;\n\t\t\t\t    do_midi_msg(dev, inc->m_buf, inc->m_ptr);\n\t\t\t\t    inc->m_ptr = 0;\n\t\t\t    }\n\t\t    }\n\t\t  break;\t/* MST_INIT */\n\n\t  case MST_DATA:\n\t\t  inc->m_buf[inc->m_ptr++] = data;\n\t\t  if (--inc->m_left <= 0)\n\t\t    {\n\t\t\t    inc->m_state = MST_INIT;\n\t\t\t    do_midi_msg(dev, inc->m_buf, inc->m_ptr);\n\t\t\t    inc->m_ptr = 0;\n\t\t    }\n\t\t  break;\t/* MST_DATA */\n\n\t  case MST_SYSEX:\n\t\t  if (data == 0xf7)\t/* Sysex end */\n\t\t    {\n\t\t\t    inc->m_state = MST_INIT;\n\t\t\t    inc->m_left = 0;\n\t\t\t    inc->m_ptr = 0;\n\t\t    }\n\t\t  break;\t/* MST_SYSEX */\n\n\t  default:\n\t\t  printk(\"MIDI%d: Unexpected state %d (%02x)\\n\", orig_dev, inc->m_state, (int) data);\n\t\t  inc->m_state = MST_INIT;\n\t  }\n}\n\nstatic void\nleave_sysex(int dev)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tint             timeout = 0;\n\n\tif (!sysex_state[dev])\n\t\treturn;\n\n\tsysex_state[dev] = 0;\n\n\twhile (!midi_devs[orig_dev]->outputc(orig_dev, 0xf7) &&\n\t       timeout < 1000)\n\t\ttimeout++;\n\n\tsysex_state[dev] = 0;\n}\n\nstatic void\nmidi_synth_output(int dev)\n{\n\t/*\n\t * Currently NOP\n\t */\n}\n\nint midi_synth_ioctl(int dev, unsigned int cmd, void __user *arg)\n{\n\t/*\n\t * int orig_dev = synth_devs[dev]->midi_dev;\n\t */\n\n\tswitch (cmd) {\n\n\tcase SNDCTL_SYNTH_INFO:\n\t\tif (__copy_to_user(arg, synth_devs[dev]->info, sizeof(struct synth_info)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t\t\n\tcase SNDCTL_SYNTH_MEMAVL:\n\t\treturn 0x7fffffff;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL(midi_synth_ioctl);\n\nint\nmidi_synth_kill_note(int dev, int channel, int note, int velocity)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tint             msg, chn;\n\n\tif (note < 0 || note > 127)\n\t\treturn 0;\n\tif (channel < 0 || channel > 15)\n\t\treturn 0;\n\tif (velocity < 0)\n\t\tvelocity = 0;\n\tif (velocity > 127)\n\t\tvelocity = 127;\n\n\tleave_sysex(dev);\n\n\tmsg = prev_out_status[orig_dev] & 0xf0;\n\tchn = prev_out_status[orig_dev] & 0x0f;\n\n\tif (chn == channel && ((msg == 0x90 && velocity == 64) || msg == 0x80))\n\t  {\t\t\t/*\n\t\t\t\t * Use running status\n\t\t\t\t */\n\t\t  if (!prefix_cmd(orig_dev, note))\n\t\t\t  return 0;\n\n\t\t  midi_outc(orig_dev, note);\n\n\t\t  if (msg == 0x90)\t/*\n\t\t\t\t\t * Running status = Note on\n\t\t\t\t\t */\n\t\t\t  midi_outc(orig_dev, 0);\t/*\n\t\t\t\t\t\t\t   * Note on with velocity 0 == note\n\t\t\t\t\t\t\t   * off\n\t\t\t\t\t\t\t */\n\t\t  else\n\t\t\t  midi_outc(orig_dev, velocity);\n\t} else\n\t  {\n\t\t  if (velocity == 64)\n\t\t    {\n\t\t\t    if (!prefix_cmd(orig_dev, 0x90 | (channel & 0x0f)))\n\t\t\t\t    return 0;\n\t\t\t    midi_outc(orig_dev, 0x90 | (channel & 0x0f));\t/*\n\t\t\t\t\t\t\t\t\t\t * Note on\n\t\t\t\t\t\t\t\t\t\t */\n\t\t\t    midi_outc(orig_dev, note);\n\t\t\t    midi_outc(orig_dev, 0);\t/*\n\t\t\t\t\t\t\t * Zero G\n\t\t\t\t\t\t\t */\n\t\t  } else\n\t\t    {\n\t\t\t    if (!prefix_cmd(orig_dev, 0x80 | (channel & 0x0f)))\n\t\t\t\t    return 0;\n\t\t\t    midi_outc(orig_dev, 0x80 | (channel & 0x0f));\t/*\n\t\t\t\t\t\t\t\t\t\t * Note off\n\t\t\t\t\t\t\t\t\t\t */\n\t\t\t    midi_outc(orig_dev, note);\n\t\t\t    midi_outc(orig_dev, velocity);\n\t\t    }\n\t  }\n\n\treturn 0;\n}\nEXPORT_SYMBOL(midi_synth_kill_note);\n\nint\nmidi_synth_set_instr(int dev, int channel, int instr_no)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\n\tif (instr_no < 0 || instr_no > 127)\n\t\tinstr_no = 0;\n\tif (channel < 0 || channel > 15)\n\t\treturn 0;\n\n\tleave_sysex(dev);\n\n\tif (!prefix_cmd(orig_dev, 0xc0 | (channel & 0x0f)))\n\t\treturn 0;\n\tmidi_outc(orig_dev, 0xc0 | (channel & 0x0f));\t/*\n\t\t\t\t\t\t\t * Program change\n\t\t\t\t\t\t\t */\n\tmidi_outc(orig_dev, instr_no);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(midi_synth_set_instr);\n\nint\nmidi_synth_start_note(int dev, int channel, int note, int velocity)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tint             msg, chn;\n\n\tif (note < 0 || note > 127)\n\t\treturn 0;\n\tif (channel < 0 || channel > 15)\n\t\treturn 0;\n\tif (velocity < 0)\n\t\tvelocity = 0;\n\tif (velocity > 127)\n\t\tvelocity = 127;\n\n\tleave_sysex(dev);\n\n\tmsg = prev_out_status[orig_dev] & 0xf0;\n\tchn = prev_out_status[orig_dev] & 0x0f;\n\n\tif (chn == channel && msg == 0x90)\n\t  {\t\t\t/*\n\t\t\t\t * Use running status\n\t\t\t\t */\n\t\t  if (!prefix_cmd(orig_dev, note))\n\t\t\t  return 0;\n\t\t  midi_outc(orig_dev, note);\n\t\t  midi_outc(orig_dev, velocity);\n\t} else\n\t  {\n\t\t  if (!prefix_cmd(orig_dev, 0x90 | (channel & 0x0f)))\n\t\t\t  return 0;\n\t\t  midi_outc(orig_dev, 0x90 | (channel & 0x0f));\t\t/*\n\t\t\t\t\t\t\t\t\t * Note on\n\t\t\t\t\t\t\t\t\t */\n\t\t  midi_outc(orig_dev, note);\n\t\t  midi_outc(orig_dev, velocity);\n\t  }\n\treturn 0;\n}\nEXPORT_SYMBOL(midi_synth_start_note);\n\nvoid\nmidi_synth_reset(int dev)\n{\n\n\tleave_sysex(dev);\n}\nEXPORT_SYMBOL(midi_synth_reset);\n\nint\nmidi_synth_open(int dev, int mode)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tint             err;\n\tstruct midi_input_info *inc;\n\n\tif (orig_dev < 0 || orig_dev >= num_midis || midi_devs[orig_dev] == NULL)\n\t\treturn -ENXIO;\n\n\tmidi2synth[orig_dev] = dev;\n\tsysex_state[dev] = 0;\n\tprev_out_status[orig_dev] = 0;\n\n\tif ((err = midi_devs[orig_dev]->open(orig_dev, mode,\n\t\t\t       midi_synth_input, midi_synth_output)) < 0)\n\t\treturn err;\n\tinc = &midi_devs[orig_dev]->in_info;\n\n\t/* save_flags(flags);\n\tcli(); \n\tdon't know against what irqhandler to protect*/\n\tinc->m_busy = 0;\n\tinc->m_state = MST_INIT;\n\tinc->m_ptr = 0;\n\tinc->m_left = 0;\n\tinc->m_prev_status = 0x00;\n\t/* restore_flags(flags); */\n\n\treturn 1;\n}\nEXPORT_SYMBOL(midi_synth_open);\n\nvoid\nmidi_synth_close(int dev)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\n\tleave_sysex(dev);\n\n\t/*\n\t * Shut up the synths by sending just single active sensing message.\n\t */\n\tmidi_devs[orig_dev]->outputc(orig_dev, 0xfe);\n\n\tmidi_devs[orig_dev]->close(orig_dev);\n}\nEXPORT_SYMBOL(midi_synth_close);\n\nvoid\nmidi_synth_hw_control(int dev, unsigned char *event)\n{\n}\nEXPORT_SYMBOL(midi_synth_hw_control);\n\nint\nmidi_synth_load_patch(int dev, int format, const char __user *addr,\n\t\t      int count, int pmgr_flag)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\n\tstruct sysex_info sysex;\n\tint             i;\n\tunsigned long   left, src_offs, eox_seen = 0;\n\tint             first_byte = 1;\n\tint             hdr_size = (unsigned long) &sysex.data[0] - (unsigned long) &sysex;\n\n\tleave_sysex(dev);\n\n\tif (!prefix_cmd(orig_dev, 0xf0))\n\t\treturn 0;\n\n\t/* Invalid patch format */\n\tif (format != SYSEX_PATCH)\n\t\t  return -EINVAL;\n\n\t/* Patch header too short */\n\tif (count < hdr_size)\n\t\treturn -EINVAL;\n\n\tcount -= hdr_size;\n\n\t/*\n\t * Copy the header from user space\n\t */\n\n\tif (copy_from_user(&sysex, addr, hdr_size))\n\t\treturn -EFAULT;\n\n\t/* Sysex record too short */\n\tif ((unsigned)count < (unsigned)sysex.len)\n\t\tsysex.len = count;\n\n\tleft = sysex.len;\n\tsrc_offs = 0;\n\n\tfor (i = 0; i < left && !signal_pending(current); i++)\n\t{\n\t\tunsigned char   data;\n\n\t\tif (get_user(data,\n\t\t    (unsigned char __user *)(addr + hdr_size + i)))\n\t\t\treturn -EFAULT;\n\n\t\teox_seen = (i > 0 && data & 0x80);\t/* End of sysex */\n\n\t\tif (eox_seen && data != 0xf7)\n\t\t\tdata = 0xf7;\n\n\t\tif (i == 0)\n\t\t{\n\t\t\tif (data != 0xf0)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"midi_synth: Sysex start missing\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\twhile (!midi_devs[orig_dev]->outputc(orig_dev, (unsigned char) (data & 0xff)) &&\n\t\t\t!signal_pending(current))\n\t\t\tschedule();\n\n\t\tif (!first_byte && data & 0x80)\n\t\t\treturn 0;\n\t\tfirst_byte = 0;\n\t}\n\n\tif (!eox_seen)\n\t\tmidi_outc(orig_dev, 0xf7);\n\treturn 0;\n}\nEXPORT_SYMBOL(midi_synth_load_patch);\n\nvoid midi_synth_panning(int dev, int channel, int pressure)\n{\n}\nEXPORT_SYMBOL(midi_synth_panning);\n\nvoid midi_synth_aftertouch(int dev, int channel, int pressure)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tint             msg, chn;\n\n\tif (pressure < 0 || pressure > 127)\n\t\treturn;\n\tif (channel < 0 || channel > 15)\n\t\treturn;\n\n\tleave_sysex(dev);\n\n\tmsg = prev_out_status[orig_dev] & 0xf0;\n\tchn = prev_out_status[orig_dev] & 0x0f;\n\n\tif (msg != 0xd0 || chn != channel)\t/*\n\t\t\t\t\t\t * Test for running status\n\t\t\t\t\t\t */\n\t  {\n\t\t  if (!prefix_cmd(orig_dev, 0xd0 | (channel & 0x0f)))\n\t\t\t  return;\n\t\t  midi_outc(orig_dev, 0xd0 | (channel & 0x0f));\t\t/*\n\t\t\t\t\t\t\t\t\t * Channel pressure\n\t\t\t\t\t\t\t\t\t */\n\t} else if (!prefix_cmd(orig_dev, pressure))\n\t\treturn;\n\n\tmidi_outc(orig_dev, pressure);\n}\nEXPORT_SYMBOL(midi_synth_aftertouch);\n\nvoid\nmidi_synth_controller(int dev, int channel, int ctrl_num, int value)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tint             chn, msg;\n\n\tif (ctrl_num < 0 || ctrl_num > 127)\n\t\treturn;\n\tif (channel < 0 || channel > 15)\n\t\treturn;\n\n\tleave_sysex(dev);\n\n\tmsg = prev_out_status[orig_dev] & 0xf0;\n\tchn = prev_out_status[orig_dev] & 0x0f;\n\n\tif (msg != 0xb0 || chn != channel)\n\t  {\n\t\t  if (!prefix_cmd(orig_dev, 0xb0 | (channel & 0x0f)))\n\t\t\t  return;\n\t\t  midi_outc(orig_dev, 0xb0 | (channel & 0x0f));\n\t} else if (!prefix_cmd(orig_dev, ctrl_num))\n\t\treturn;\n\n\tmidi_outc(orig_dev, ctrl_num);\n\tmidi_outc(orig_dev, value & 0x7f);\n}\nEXPORT_SYMBOL(midi_synth_controller);\n\nvoid\nmidi_synth_bender(int dev, int channel, int value)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tint             msg, prev_chn;\n\n\tif (channel < 0 || channel > 15)\n\t\treturn;\n\n\tif (value < 0 || value > 16383)\n\t\treturn;\n\n\tleave_sysex(dev);\n\n\tmsg = prev_out_status[orig_dev] & 0xf0;\n\tprev_chn = prev_out_status[orig_dev] & 0x0f;\n\n\tif (msg != 0xd0 || prev_chn != channel)\t\t/*\n\t\t\t\t\t\t\t * Test for running status\n\t\t\t\t\t\t\t */\n\t  {\n\t\t  if (!prefix_cmd(orig_dev, 0xe0 | (channel & 0x0f)))\n\t\t\t  return;\n\t\t  midi_outc(orig_dev, 0xe0 | (channel & 0x0f));\n\t} else if (!prefix_cmd(orig_dev, value & 0x7f))\n\t\treturn;\n\n\tmidi_outc(orig_dev, value & 0x7f);\n\tmidi_outc(orig_dev, (value >> 7) & 0x7f);\n}\nEXPORT_SYMBOL(midi_synth_bender);\n\nvoid\nmidi_synth_setup_voice(int dev, int voice, int channel)\n{\n}\nEXPORT_SYMBOL(midi_synth_setup_voice);\n\nint\nmidi_synth_send_sysex(int dev, unsigned char *bytes, int len)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tint             i;\n\n\tfor (i = 0; i < len; i++)\n\t  {\n\t\t  switch (bytes[i])\n\t\t    {\n\t\t    case 0xf0:\t/* Start sysex */\n\t\t\t    if (!prefix_cmd(orig_dev, 0xf0))\n\t\t\t\t    return 0;\n\t\t\t    sysex_state[dev] = 1;\n\t\t\t    break;\n\n\t\t    case 0xf7:\t/* End sysex */\n\t\t\t    if (!sysex_state[dev])\t/* Orphan sysex end */\n\t\t\t\t    return 0;\n\t\t\t    sysex_state[dev] = 0;\n\t\t\t    break;\n\n\t\t    default:\n\t\t\t    if (!sysex_state[dev])\n\t\t\t\t    return 0;\n\n\t\t\t    if (bytes[i] & 0x80)\t/* Error. Another message before sysex end */\n\t\t\t      {\n\t\t\t\t      bytes[i] = 0xf7;\t/* Sysex end */\n\t\t\t\t      sysex_state[dev] = 0;\n\t\t\t      }\n\t\t    }\n\n\t\t  if (!midi_devs[orig_dev]->outputc(orig_dev, bytes[i]))\n\t\t    {\n/*\n * Hardware level buffer is full. Abort the sysex message.\n */\n\n\t\t\t    int             timeout = 0;\n\n\t\t\t    bytes[i] = 0xf7;\n\t\t\t    sysex_state[dev] = 0;\n\n\t\t\t    while (!midi_devs[orig_dev]->outputc(orig_dev, bytes[i]) &&\n\t\t\t\t   timeout < 1000)\n\t\t\t\t    timeout++;\n\t\t    }\n\t\t  if (!sysex_state[dev])\n\t\t\t  return 0;\n\t  }\n\n\treturn 0;\n}\nEXPORT_SYMBOL(midi_synth_send_sysex);\n\n", "int midi_synth_ioctl (int dev,\n\t    unsigned int cmd, void __user * arg);\nint midi_synth_kill_note (int dev, int channel, int note, int velocity);\nint midi_synth_set_instr (int dev, int channel, int instr_no);\nint midi_synth_start_note (int dev, int channel, int note, int volume);\nvoid midi_synth_reset (int dev);\nint midi_synth_open (int dev, int mode);\nvoid midi_synth_close (int dev);\nvoid midi_synth_hw_control (int dev, unsigned char *event);\nint midi_synth_load_patch (int dev, int format, const char __user * addr,\n\t\t int count, int pmgr_flag);\nvoid midi_synth_panning (int dev, int channel, int pressure);\nvoid midi_synth_aftertouch (int dev, int channel, int pressure);\nvoid midi_synth_controller (int dev, int channel, int ctrl_num, int value);\nvoid midi_synth_bender (int dev, int chn, int value);\nvoid midi_synth_setup_voice (int dev, int voice, int chn);\nint midi_synth_send_sysex(int dev, unsigned char *bytes,int len);\n\n#ifndef _MIDI_SYNTH_C_\nstatic struct synth_info std_synth_info =\n{MIDI_SYNTH_NAME, 0, SYNTH_TYPE_MIDI, 0, 0, 128, 0, 128, MIDI_SYNTH_CAPS};\n\nstatic struct synth_operations std_midi_synth =\n{\n\t.owner\t\t= THIS_MODULE,\n\t.id\t\t= \"MIDI\",\n\t.info\t\t= &std_synth_info,\n\t.midi_dev\t= 0,\n\t.synth_type\t= SYNTH_TYPE_MIDI,\n\t.synth_subtype\t= 0,\n\t.open\t\t= midi_synth_open,\n\t.close\t\t= midi_synth_close,\n\t.ioctl\t\t= midi_synth_ioctl,\n\t.kill_note\t= midi_synth_kill_note,\n\t.start_note\t= midi_synth_start_note,\n\t.set_instr\t= midi_synth_set_instr,\n\t.reset\t\t= midi_synth_reset,\n\t.hw_control\t= midi_synth_hw_control,\n\t.load_patch\t= midi_synth_load_patch,\n\t.aftertouch\t= midi_synth_aftertouch,\n\t.controller\t= midi_synth_controller,\n\t.panning\t\t= midi_synth_panning,\n\t.bender\t\t= midi_synth_bender,\n\t.setup_voice\t= midi_synth_setup_voice,\n\t.send_sysex\t= midi_synth_send_sysex\n};\n#endif\n", "/*\n * sound/oss/opl3.c\n *\n * A low level driver for Yamaha YM3812 and OPL-3 -chips\n *\n *\n * Copyright (C) by Hannu Savolainen 1993-1997\n *\n * OSS/Free for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)\n * Version 2 (June 1991). See the \"COPYING\" file distributed with this software\n * for more info.\n *\n *\n * Changes\n *\tThomas Sailer   \tioctl code reworked (vmalloc/vfree removed)\n *\tAlan Cox\t\tmodularisation, fixed sound_mem allocs.\n *\tChristoph Hellwig\tAdapted to module_init/module_exit\n *\tArnaldo C. de Melo\tget rid of check_region, use request_region for\n *\t\t\t\tOPL4, release it on exit, some cleanups.\n *\n * Status\n *\tBelieved to work. Badly needs rewriting a bit to support multiple\n *\tOPL3 devices.\n */\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n\n/*\n * Major improvements to the FM handling 30AUG92 by Rob Hooft,\n * hooft@chem.ruu.nl\n */\n\n#include \"sound_config.h\"\n\n#include \"opl3_hw.h\"\n\n#define MAX_VOICE\t18\n#define OFFS_4OP\t11\n\nstruct voice_info\n{\n\tunsigned char   keyon_byte;\n\tlong            bender;\n\tlong            bender_range;\n\tunsigned long   orig_freq;\n\tunsigned long   current_freq;\n\tint             volume;\n\tint             mode;\n\tint             panning;\t/* 0xffff means not set */\n};\n\ntypedef struct opl_devinfo\n{\n\tint             base;\n\tint             left_io, right_io;\n\tint             nr_voice;\n\tint             lv_map[MAX_VOICE];\n\n\tstruct voice_info voc[MAX_VOICE];\n\tstruct voice_alloc_info *v_alloc;\n\tstruct channel_info *chn_info;\n\n\tstruct sbi_instrument i_map[SBFM_MAXINSTR];\n\tstruct sbi_instrument *act_i[MAX_VOICE];\n\n\tstruct synth_info fm_info;\n\n\tint             busy;\n\tint             model;\n\tunsigned char   cmask;\n\n\tint             is_opl4;\n} opl_devinfo;\n\nstatic struct opl_devinfo *devc = NULL;\n\nstatic int      detected_model;\n\nstatic int      store_instr(int instr_no, struct sbi_instrument *instr);\nstatic void     freq_to_fnum(int freq, int *block, int *fnum);\nstatic void     opl3_command(int io_addr, unsigned int addr, unsigned int val);\nstatic int      opl3_kill_note(int dev, int voice, int note, int velocity);\n\nstatic void enter_4op_mode(void)\n{\n\tint i;\n\tstatic int v4op[MAX_VOICE] = {\n\t\t0, 1, 2, 9, 10, 11, 6, 7, 8, 15, 16, 17\n\t};\n\n\tdevc->cmask = 0x3f;\t/* Connect all possible 4 OP voice operators */\n\topl3_command(devc->right_io, CONNECTION_SELECT_REGISTER, 0x3f);\n\n\tfor (i = 0; i < 3; i++)\n\t\tpv_map[i].voice_mode = 4;\n\tfor (i = 3; i < 6; i++)\n\t\tpv_map[i].voice_mode = 0;\n\n\tfor (i = 9; i < 12; i++)\n\t\tpv_map[i].voice_mode = 4;\n\tfor (i = 12; i < 15; i++)\n\t\tpv_map[i].voice_mode = 0;\n\n\tfor (i = 0; i < 12; i++)\n\t\tdevc->lv_map[i] = v4op[i];\n\tdevc->v_alloc->max_voice = devc->nr_voice = 12;\n}\n\nstatic int opl3_ioctl(int dev, unsigned int cmd, void __user * arg)\n{\n\tstruct sbi_instrument ins;\n\t\n\tswitch (cmd) {\n\t\tcase SNDCTL_FM_LOAD_INSTR:\n\t\t\tprintk(KERN_WARNING \"Warning: Obsolete ioctl(SNDCTL_FM_LOAD_INSTR) used. Fix the program.\\n\");\n\t\t\tif (copy_from_user(&ins, arg, sizeof(ins)))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR) {\n\t\t\t\tprintk(KERN_WARNING \"FM Error: Invalid instrument number %d\\n\", ins.channel);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\treturn store_instr(ins.channel, &ins);\n\n\t\tcase SNDCTL_SYNTH_INFO:\n\t\t\tdevc->fm_info.nr_voices = (devc->nr_voice == 12) ? 6 : devc->nr_voice;\n\t\t\tif (copy_to_user(arg, &devc->fm_info, sizeof(devc->fm_info)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\n\t\tcase SNDCTL_SYNTH_MEMAVL:\n\t\t\treturn 0x7fffffff;\n\n\t\tcase SNDCTL_FM_4OP_ENABLE:\n\t\t\tif (devc->model == 2)\n\t\t\t\tenter_4op_mode();\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n}\n\nstatic int opl3_detect(int ioaddr)\n{\n\t/*\n\t * This function returns 1 if the FM chip is present at the given I/O port\n\t * The detection algorithm plays with the timer built in the FM chip and\n\t * looks for a change in the status register.\n\t *\n\t * Note! The timers of the FM chip are not connected to AdLib (and compatible)\n\t * boards.\n\t *\n\t * Note2! The chip is initialized if detected.\n\t */\n\n\tunsigned char stat1, signature;\n\tint i;\n\n\tif (devc != NULL)\n\t{\n\t\tprintk(KERN_ERR \"opl3: Only one OPL3 supported.\\n\");\n\t\treturn 0;\n\t}\n\n\tdevc = kzalloc(sizeof(*devc), GFP_KERNEL);\n\n\tif (devc == NULL)\n\t{\n\t\tprintk(KERN_ERR \"opl3: Can't allocate memory for the device control \"\n\t\t\t\"structure \\n \");\n\t\treturn 0;\n\t}\n\n\tstrcpy(devc->fm_info.name, \"OPL2\");\n\n\tif (!request_region(ioaddr, 4, devc->fm_info.name)) {\n\t\tprintk(KERN_WARNING \"opl3: I/O port 0x%x already in use\\n\", ioaddr);\n\t\tgoto cleanup_devc;\n\t}\n\n\tdevc->base = ioaddr;\n\n\t/* Reset timers 1 and 2 */\n\topl3_command(ioaddr, TIMER_CONTROL_REGISTER, TIMER1_MASK | TIMER2_MASK);\n\n\t/* Reset the IRQ of the FM chip */\n\topl3_command(ioaddr, TIMER_CONTROL_REGISTER, IRQ_RESET);\n\n\tsignature = stat1 = inb(ioaddr);\t/* Status register */\n\n\tif (signature != 0x00 && signature != 0x06 && signature != 0x02 &&\n\t\tsignature != 0x0f)\n\t{\n\t\tMDB(printk(KERN_INFO \"OPL3 not detected %x\\n\", signature));\n\t\tgoto cleanup_region;\n\t}\n\n\tif (signature == 0x06)\t\t/* OPL2 */\n\t{\n\t\tdetected_model = 2;\n\t}\n\telse if (signature == 0x00 || signature == 0x0f)\t/* OPL3 or OPL4 */\n\t{\n\t\tunsigned char tmp;\n\n\t\tdetected_model = 3;\n\n\t\t/*\n\t\t * Detect availability of OPL4 (_experimental_). Works probably\n\t\t * only after a cold boot. In addition the OPL4 port\n\t\t * of the chip may not be connected to the PC bus at all.\n\t\t */\n\n\t\topl3_command(ioaddr + 2, OPL3_MODE_REGISTER, 0x00);\n\t\topl3_command(ioaddr + 2, OPL3_MODE_REGISTER, OPL3_ENABLE | OPL4_ENABLE);\n\n\t\tif ((tmp = inb(ioaddr)) == 0x02)\t/* Have a OPL4 */\n\t\t{\n\t\t\tdetected_model = 4;\n\t\t}\n\n\t\tif (request_region(ioaddr - 8, 2, \"OPL4\"))\t/* OPL4 port was free */\n\t\t{\n\t\t\tint tmp;\n\n\t\t\toutb((0x02), ioaddr - 8);\t/* Select OPL4 ID register */\n\t\t\tudelay(10);\n\t\t\ttmp = inb(ioaddr - 7);\t\t/* Read it */\n\t\t\tudelay(10);\n\n\t\t\tif (tmp == 0x20)\t/* OPL4 should return 0x20 here */\n\t\t\t{\n\t\t\t\tdetected_model = 4;\n\t\t\t\toutb((0xF8), ioaddr - 8);\t/* Select OPL4 FM mixer control */\n\t\t\t\tudelay(10);\n\t\t\t\toutb((0x1B), ioaddr - 7);\t/* Write value */\n\t\t\t\tudelay(10);\n\t\t\t}\n\t\t\telse\n\t\t\t{ /* release OPL4 port */\n\t\t\t\trelease_region(ioaddr - 8, 2);\n\t\t\t\tdetected_model = 3;\n\t\t\t}\n\t\t}\n\t\topl3_command(ioaddr + 2, OPL3_MODE_REGISTER, 0);\n\t}\n\tfor (i = 0; i < 9; i++)\n\t\topl3_command(ioaddr, KEYON_BLOCK + i, 0);\t/*\n\t\t\t\t\t\t\t\t * Note off\n\t\t\t\t\t\t\t\t */\n\n\topl3_command(ioaddr, TEST_REGISTER, ENABLE_WAVE_SELECT);\n\topl3_command(ioaddr, PERCOSSION_REGISTER, 0x00);\t/*\n\t\t\t\t\t\t\t\t * Melodic mode.\n\t\t\t\t\t\t\t\t */\n\treturn 1;\ncleanup_region:\n\trelease_region(ioaddr, 4);\ncleanup_devc:\n\tkfree(devc);\n\tdevc = NULL;\n\treturn 0;\n}\n\nstatic int opl3_kill_note  (int devno, int voice, int note, int velocity)\n{\n\t struct physical_voice_info *map;\n\n\t if (voice < 0 || voice >= devc->nr_voice)\n\t\t return 0;\n\n\t devc->v_alloc->map[voice] = 0;\n\n\t map = &pv_map[devc->lv_map[voice]];\n\t DEB(printk(\"Kill note %d\\n\", voice));\n\n\t if (map->voice_mode == 0)\n\t\t return 0;\n\n\t opl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num, devc->voc[voice].keyon_byte & ~0x20);\n\t devc->voc[voice].keyon_byte = 0;\n\t devc->voc[voice].bender = 0;\n\t devc->voc[voice].volume = 64;\n\t devc->voc[voice].panning = 0xffff;\t/* Not set */\n\t devc->voc[voice].bender_range = 200;\n\t devc->voc[voice].orig_freq = 0;\n\t devc->voc[voice].current_freq = 0;\n\t devc->voc[voice].mode = 0;\n\t return 0;\n}\n\n#define HIHAT\t\t\t0\n#define CYMBAL\t\t\t1\n#define TOMTOM\t\t\t2\n#define SNARE\t\t\t3\n#define BDRUM\t\t\t4\n#define UNDEFINED\t\tTOMTOM\n#define DEFAULT\t\t\tTOMTOM\n\nstatic int store_instr(int instr_no, struct sbi_instrument *instr)\n{\n\tif (instr->key != FM_PATCH && (instr->key != OPL3_PATCH || devc->model != 2))\n\t\tprintk(KERN_WARNING \"FM warning: Invalid patch format field (key) 0x%x\\n\", instr->key);\n\tmemcpy((char *) &(devc->i_map[instr_no]), (char *) instr, sizeof(*instr));\n\treturn 0;\n}\n\nstatic int opl3_set_instr  (int dev, int voice, int instr_no)\n{\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn 0;\n\tif (instr_no < 0 || instr_no >= SBFM_MAXINSTR)\n\t\tinstr_no = 0;\t/* Acoustic piano (usually) */\n\n\tdevc->act_i[voice] = &devc->i_map[instr_no];\n\treturn 0;\n}\n\n/*\n * The next table looks magical, but it certainly is not. Its values have\n * been calculated as table[i]=8*log(i/64)/log(2) with an obvious exception\n * for i=0. This log-table converts a linear volume-scaling (0..127) to a\n * logarithmic scaling as present in the FM-synthesizer chips. so :    Volume\n * 64 =  0 db = relative volume  0 and:    Volume 32 = -6 db = relative\n * volume -8 it was implemented as a table because it is only 128 bytes and\n * it saves a lot of log() calculations. (RH)\n */\n\nstatic char fm_volume_table[128] =\n{\n\t-64, -48, -40, -35, -32, -29, -27, -26,\n\t-24, -23, -21, -20, -19, -18, -18, -17,\n\t-16, -15, -15, -14, -13, -13, -12, -12,\n\t-11, -11, -10, -10, -10, -9, -9, -8,\n\t-8, -8, -7, -7, -7, -6, -6, -6,\n\t-5, -5, -5, -5, -4, -4, -4, -4,\n\t-3, -3, -3, -3, -2, -2, -2, -2,\n\t-2, -1, -1, -1, -1, 0, 0, 0,\n\t0, 0, 0, 1, 1, 1, 1, 1,\n\t1, 2, 2, 2, 2, 2, 2, 2,\n\t3, 3, 3, 3, 3, 3, 3, 4,\n\t4, 4, 4, 4, 4, 4, 4, 5,\n\t5, 5, 5, 5, 5, 5, 5, 5,\n\t6, 6, 6, 6, 6, 6, 6, 6,\n\t6, 7, 7, 7, 7, 7, 7, 7,\n\t7, 7, 7, 8, 8, 8, 8, 8\n};\n\nstatic void calc_vol(unsigned char *regbyte, int volume, int main_vol)\n{\n\tint level = (~*regbyte & 0x3f);\n\n\tif (main_vol > 127)\n\t\tmain_vol = 127;\n\tvolume = (volume * main_vol) / 127;\n\n\tif (level)\n\t\tlevel += fm_volume_table[volume];\n\n\tif (level > 0x3f)\n\t\tlevel = 0x3f;\n\tif (level < 0)\n\t\tlevel = 0;\n\n\t*regbyte = (*regbyte & 0xc0) | (~level & 0x3f);\n}\n\nstatic void set_voice_volume(int voice, int volume, int main_vol)\n{\n\tunsigned char vol1, vol2, vol3, vol4;\n\tstruct sbi_instrument *instr;\n\tstruct physical_voice_info *map;\n\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tmap = &pv_map[devc->lv_map[voice]];\n\tinstr = devc->act_i[voice];\n\n\tif (!instr)\n\t\tinstr = &devc->i_map[0];\n\n\tif (instr->channel < 0)\n\t\treturn;\n\n\tif (devc->voc[voice].mode == 0)\n\t\treturn;\n\n\tif (devc->voc[voice].mode == 2)\n\t{\n\t\tvol1 = instr->operators[2];\n\t\tvol2 = instr->operators[3];\n\t\tif ((instr->operators[10] & 0x01))\n\t\t{\n\t\t\tcalc_vol(&vol1, volume, main_vol);\n\t\t\tcalc_vol(&vol2, volume, main_vol);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcalc_vol(&vol2, volume, main_vol);\n\t\t}\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[0], vol1);\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[1], vol2);\n\t}\n\telse\n\t{\t/*\n\t\t * 4 OP voice\n\t\t */\n\t\tint connection;\n\n\t\tvol1 = instr->operators[2];\n\t\tvol2 = instr->operators[3];\n\t\tvol3 = instr->operators[OFFS_4OP + 2];\n\t\tvol4 = instr->operators[OFFS_4OP + 3];\n\n\t\t/*\n\t\t * The connection method for 4 OP devc->voc is defined by the rightmost\n\t\t * bits at the offsets 10 and 10+OFFS_4OP\n\t\t */\n\n\t\tconnection = ((instr->operators[10] & 0x01) << 1) | (instr->operators[10 + OFFS_4OP] & 0x01);\n\n\t\tswitch (connection)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tcalc_vol(&vol4, volume, main_vol);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tcalc_vol(&vol2, volume, main_vol);\n\t\t\t\tcalc_vol(&vol4, volume, main_vol);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tcalc_vol(&vol1, volume, main_vol);\n\t\t\t\tcalc_vol(&vol4, volume, main_vol);\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tcalc_vol(&vol1, volume, main_vol);\n\t\t\t\tcalc_vol(&vol3, volume, main_vol);\n\t\t\t\tcalc_vol(&vol4, volume, main_vol);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t;\n\t\t}\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[0], vol1);\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[1], vol2);\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[2], vol3);\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[3], vol4);\n\t}\n}\n\nstatic int opl3_start_note (int dev, int voice, int note, int volume)\n{\n\tunsigned char data, fpc;\n\tint block, fnum, freq, voice_mode, pan;\n\tstruct sbi_instrument *instr;\n\tstruct physical_voice_info *map;\n\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn 0;\n\n\tmap = &pv_map[devc->lv_map[voice]];\n\tpan = devc->voc[voice].panning;\n\n\tif (map->voice_mode == 0)\n\t\treturn 0;\n\n\tif (note == 255)\t/*\n\t\t\t\t * Just change the volume\n\t\t\t\t */\n\t{\n\t\tset_voice_volume(voice, volume, devc->voc[voice].volume);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Kill previous note before playing\n\t */\n\t\n\topl3_command(map->ioaddr, KSL_LEVEL + map->op[1], 0xff);\t/*\n\t\t\t\t\t\t\t\t\t * Carrier\n\t\t\t\t\t\t\t\t\t * volume to\n\t\t\t\t\t\t\t\t\t * min\n\t\t\t\t\t\t\t\t\t */\n\topl3_command(map->ioaddr, KSL_LEVEL + map->op[0], 0xff);\t/*\n\t\t\t\t\t\t\t\t\t * Modulator\n\t\t\t\t\t\t\t\t\t * volume to\n\t\t\t\t\t\t\t\t\t */\n\n\tif (map->voice_mode == 4)\n\t{\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[2], 0xff);\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[3], 0xff);\n\t}\n\n\topl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num, 0x00);\t/*\n\t\t\t\t\t\t\t\t\t * Note\n\t\t\t\t\t\t\t\t\t * off\n\t\t\t\t\t\t\t\t\t */\n\n\tinstr = devc->act_i[voice];\n\t\n\tif (!instr)\n\t\tinstr = &devc->i_map[0];\n\n\tif (instr->channel < 0)\n\t{\n\t\tprintk(KERN_WARNING \"opl3: Initializing voice %d with undefined instrument\\n\", voice);\n\t\treturn 0;\n\t}\n\n\tif (map->voice_mode == 2 && instr->key == OPL3_PATCH)\n\t\treturn 0;\t/*\n\t\t\t\t * Cannot play\n\t\t\t\t */\n\n\tvoice_mode = map->voice_mode;\n\n\tif (voice_mode == 4)\n\t{\n\t\tint voice_shift;\n\n\t\tvoice_shift = (map->ioaddr == devc->left_io) ? 0 : 3;\n\t\tvoice_shift += map->voice_num;\n\n\t\tif (instr->key != OPL3_PATCH)\t/*\n\t\t\t\t\t\t * Just 2 OP patch\n\t\t\t\t\t\t */\n\t\t{\n\t\t\tvoice_mode = 2;\n\t\t\tdevc->cmask &= ~(1 << voice_shift);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdevc->cmask |= (1 << voice_shift);\n\t\t}\n\n\t\topl3_command(devc->right_io, CONNECTION_SELECT_REGISTER, devc->cmask);\n\t}\n\n\t/*\n\t * Set Sound Characteristics\n\t */\n\t\n\topl3_command(map->ioaddr, AM_VIB + map->op[0], instr->operators[0]);\n\topl3_command(map->ioaddr, AM_VIB + map->op[1], instr->operators[1]);\n\n\t/*\n\t * Set Attack/Decay\n\t */\n\t\n\topl3_command(map->ioaddr, ATTACK_DECAY + map->op[0], instr->operators[4]);\n\topl3_command(map->ioaddr, ATTACK_DECAY + map->op[1], instr->operators[5]);\n\n\t/*\n\t * Set Sustain/Release\n\t */\n\t\n\topl3_command(map->ioaddr, SUSTAIN_RELEASE + map->op[0], instr->operators[6]);\n\topl3_command(map->ioaddr, SUSTAIN_RELEASE + map->op[1], instr->operators[7]);\n\n\t/*\n\t * Set Wave Select\n\t */\n\n\topl3_command(map->ioaddr, WAVE_SELECT + map->op[0], instr->operators[8]);\n\topl3_command(map->ioaddr, WAVE_SELECT + map->op[1], instr->operators[9]);\n\n\t/*\n\t * Set Feedback/Connection\n\t */\n\t\n\tfpc = instr->operators[10];\n\n\tif (pan != 0xffff)\n\t{\n\t\tfpc &= ~STEREO_BITS;\n\t\tif (pan < -64)\n\t\t\tfpc |= VOICE_TO_LEFT;\n\t\telse\n\t\t\tif (pan > 64)\n\t\t\t\tfpc |= VOICE_TO_RIGHT;\n\t\t\telse\n\t\t\t\tfpc |= (VOICE_TO_LEFT | VOICE_TO_RIGHT);\n\t}\n\n\tif (!(fpc & 0x30))\n\t\tfpc |= 0x30;\t/*\n\t\t\t\t * Ensure that at least one chn is enabled\n\t\t\t\t */\n\topl3_command(map->ioaddr, FEEDBACK_CONNECTION + map->voice_num, fpc);\n\n\t/*\n\t * If the voice is a 4 OP one, initialize the operators 3 and 4 also\n\t */\n\n\tif (voice_mode == 4)\n\t{\n\t\t/*\n\t\t * Set Sound Characteristics\n\t\t */\n\t\n\t\topl3_command(map->ioaddr, AM_VIB + map->op[2], instr->operators[OFFS_4OP + 0]);\n\t\topl3_command(map->ioaddr, AM_VIB + map->op[3], instr->operators[OFFS_4OP + 1]);\n\n\t\t/*\n\t\t * Set Attack/Decay\n\t\t */\n\t\t\n\t\topl3_command(map->ioaddr, ATTACK_DECAY + map->op[2], instr->operators[OFFS_4OP + 4]);\n\t\topl3_command(map->ioaddr, ATTACK_DECAY + map->op[3], instr->operators[OFFS_4OP + 5]);\n\n\t\t/*\n\t\t * Set Sustain/Release\n\t\t */\n\t\t\n\t\topl3_command(map->ioaddr, SUSTAIN_RELEASE + map->op[2], instr->operators[OFFS_4OP + 6]);\n\t\topl3_command(map->ioaddr, SUSTAIN_RELEASE + map->op[3], instr->operators[OFFS_4OP + 7]);\n\n\t\t/*\n\t\t * Set Wave Select\n\t\t */\n\t\t\n\t\topl3_command(map->ioaddr, WAVE_SELECT + map->op[2], instr->operators[OFFS_4OP + 8]);\n\t\topl3_command(map->ioaddr, WAVE_SELECT + map->op[3], instr->operators[OFFS_4OP + 9]);\n\n\t\t/*\n\t\t * Set Feedback/Connection\n\t\t */\n\t\t\n\t\tfpc = instr->operators[OFFS_4OP + 10];\n\t\tif (!(fpc & 0x30))\n\t\t\t fpc |= 0x30;\t/*\n\t\t\t\t\t * Ensure that at least one chn is enabled\n\t\t\t\t\t */\n\t\topl3_command(map->ioaddr, FEEDBACK_CONNECTION + map->voice_num + 3, fpc);\n\t}\n\n\tdevc->voc[voice].mode = voice_mode;\n\tset_voice_volume(voice, volume, devc->voc[voice].volume);\n\n\tfreq = devc->voc[voice].orig_freq = note_to_freq(note) / 1000;\n\n\t/*\n\t * Since the pitch bender may have been set before playing the note, we\n\t * have to calculate the bending now.\n\t */\n\n\tfreq = compute_finetune(devc->voc[voice].orig_freq, devc->voc[voice].bender, devc->voc[voice].bender_range, 0);\n\tdevc->voc[voice].current_freq = freq;\n\n\tfreq_to_fnum(freq, &block, &fnum);\n\n\t/*\n\t * Play note\n\t */\n\n\tdata = fnum & 0xff;\t/*\n\t\t\t\t * Least significant bits of fnumber\n\t\t\t\t */\n\topl3_command(map->ioaddr, FNUM_LOW + map->voice_num, data);\n\n\tdata = 0x20 | ((block & 0x7) << 2) | ((fnum >> 8) & 0x3);\n\t\t devc->voc[voice].keyon_byte = data;\n\topl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num, data);\n\tif (voice_mode == 4)\n\t\topl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num + 3, data);\n\n\treturn 0;\n}\n\nstatic void freq_to_fnum    (int freq, int *block, int *fnum)\n{\n\tint f, octave;\n\n\t/*\n\t * Converts the note frequency to block and fnum values for the FM chip\n\t */\n\t/*\n\t * First try to compute the block -value (octave) where the note belongs\n\t */\n\n\tf = freq;\n\n\toctave = 5;\n\n\tif (f == 0)\n\t\toctave = 0;\n\telse if (f < 261)\n\t{\n\t\twhile (f < 261)\n\t\t{\n\t\t\toctave--;\n\t\t\tf <<= 1;\n\t\t}\n\t}\n\telse if (f > 493)\n\t{\n\t\twhile (f > 493)\n\t\t{\n\t\t\t octave++;\n\t\t\t f >>= 1;\n\t\t}\n\t}\n\n\tif (octave > 7)\n\t\toctave = 7;\n\n\t*fnum = freq * (1 << (20 - octave)) / 49716;\n\t*block = octave;\n}\n\nstatic void opl3_command    (int io_addr, unsigned int addr, unsigned int val)\n{\n\t int i;\n\n\t/*\n\t * The original 2-OP synth requires a quite long delay after writing to a\n\t * register. The OPL-3 survives with just two INBs\n\t */\n\n\toutb(((unsigned char) (addr & 0xff)), io_addr);\n\n\tif (devc->model != 2)\n\t\tudelay(10);\n\telse\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tinb(io_addr);\n\n\toutb(((unsigned char) (val & 0xff)), io_addr + 1);\n\n\tif (devc->model != 2)\n\t\tudelay(30);\n\telse\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tinb(io_addr);\n}\n\nstatic void opl3_reset(int devno)\n{\n\tint i;\n\n\tfor (i = 0; i < 18; i++)\n\t\tdevc->lv_map[i] = i;\n\n\tfor (i = 0; i < devc->nr_voice; i++)\n\t{\n\t\topl3_command(pv_map[devc->lv_map[i]].ioaddr,\n\t\t\tKSL_LEVEL + pv_map[devc->lv_map[i]].op[0], 0xff);\n\n\t\topl3_command(pv_map[devc->lv_map[i]].ioaddr,\n\t\t\tKSL_LEVEL + pv_map[devc->lv_map[i]].op[1], 0xff);\n\n\t\tif (pv_map[devc->lv_map[i]].voice_mode == 4)\n\t\t{\n\t\t\topl3_command(pv_map[devc->lv_map[i]].ioaddr,\n\t\t\t\tKSL_LEVEL + pv_map[devc->lv_map[i]].op[2], 0xff);\n\n\t\t\topl3_command(pv_map[devc->lv_map[i]].ioaddr,\n\t\t\t\tKSL_LEVEL + pv_map[devc->lv_map[i]].op[3], 0xff);\n\t\t}\n\n\t\topl3_kill_note(devno, i, 0, 64);\n\t}\n\n\tif (devc->model == 2)\n\t{\n\t\tdevc->v_alloc->max_voice = devc->nr_voice = 18;\n\n\t\tfor (i = 0; i < 18; i++)\n\t\t\tpv_map[i].voice_mode = 2;\n\n\t}\n}\n\nstatic int opl3_open(int dev, int mode)\n{\n\tint i;\n\n\tif (devc->busy)\n\t\treturn -EBUSY;\n\tdevc->busy = 1;\n\n\tdevc->v_alloc->max_voice = devc->nr_voice = (devc->model == 2) ? 18 : 9;\n\tdevc->v_alloc->timestamp = 0;\n\n\tfor (i = 0; i < 18; i++)\n\t{\n\t\tdevc->v_alloc->map[i] = 0;\n\t\tdevc->v_alloc->alloc_times[i] = 0;\n\t}\n\n\tdevc->cmask = 0x00;\t/*\n\t\t\t\t * Just 2 OP mode\n\t\t\t\t */\n\tif (devc->model == 2)\n\t\topl3_command(devc->right_io, CONNECTION_SELECT_REGISTER, devc->cmask);\n\treturn 0;\n}\n\nstatic void opl3_close(int dev)\n{\n\tdevc->busy = 0;\n\tdevc->v_alloc->max_voice = devc->nr_voice = (devc->model == 2) ? 18 : 9;\n\n\tdevc->fm_info.nr_drums = 0;\n\tdevc->fm_info.perc_mode = 0;\n\n\topl3_reset(dev);\n}\n\nstatic void opl3_hw_control(int dev, unsigned char *event)\n{\n}\n\nstatic int opl3_load_patch(int dev, int format, const char __user *addr,\n\t\tint count, int pmgr_flag)\n{\n\tstruct sbi_instrument ins;\n\n\tif (count <sizeof(ins))\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Patch record too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&ins, addr, sizeof(ins)))\n\t\treturn -EFAULT;\n\n\tif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR)\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Invalid instrument number %d\\n\", ins.channel);\n\t\treturn -EINVAL;\n\t}\n\tins.key = format;\n\n\treturn store_instr(ins.channel, &ins);\n}\n\nstatic void opl3_panning(int dev, int voice, int value)\n{\n\tdevc->voc[voice].panning = value;\n}\n\nstatic void opl3_volume_method(int dev, int mode)\n{\n}\n\n#define SET_VIBRATO(cell) { \\\n\ttmp = instr->operators[(cell-1)+(((cell-1)/2)*OFFS_4OP)]; \\\n\tif (pressure > 110) \\\n\t\ttmp |= 0x40;\t\t/* Vibrato on */ \\\n\topl3_command (map->ioaddr, AM_VIB + map->op[cell-1], tmp);}\n\nstatic void opl3_aftertouch(int dev, int voice, int pressure)\n{\n\tint tmp;\n\tstruct sbi_instrument *instr;\n\tstruct physical_voice_info *map;\n\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tmap = &pv_map[devc->lv_map[voice]];\n\n\tDEB(printk(\"Aftertouch %d\\n\", voice));\n\n\tif (map->voice_mode == 0)\n\t\treturn;\n\n\t/*\n\t * Adjust the amount of vibrato depending the pressure\n\t */\n\n\tinstr = devc->act_i[voice];\n\n\tif (!instr)\n\t\tinstr = &devc->i_map[0];\n\n\tif (devc->voc[voice].mode == 4)\n\t{\n\t\tint connection = ((instr->operators[10] & 0x01) << 1) | (instr->operators[10 + OFFS_4OP] & 0x01);\n\n\t\tswitch (connection)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tSET_VIBRATO(4);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tSET_VIBRATO(2);\n\t\t\t\tSET_VIBRATO(4);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tSET_VIBRATO(1);\n\t\t\t\tSET_VIBRATO(4);\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tSET_VIBRATO(1);\n\t\t\t\tSET_VIBRATO(3);\n\t\t\t\tSET_VIBRATO(4);\n\t\t\t\tbreak;\n\n\t\t}\n\t\t/*\n\t\t * Not implemented yet\n\t\t */\n\t}\n\telse\n\t{\n\t\tSET_VIBRATO(1);\n\n\t\tif ((instr->operators[10] & 0x01))\t/*\n\t\t\t\t\t\t\t * Additive synthesis\n\t\t\t\t\t\t\t */\n\t\t\tSET_VIBRATO(2);\n\t}\n}\n\n#undef SET_VIBRATO\n\nstatic void bend_pitch(int dev, int voice, int value)\n{\n\tunsigned char data;\n\tint block, fnum, freq;\n\tstruct physical_voice_info *map;\n\n\tmap = &pv_map[devc->lv_map[voice]];\n\n\tif (map->voice_mode == 0)\n\t\treturn;\n\n\tdevc->voc[voice].bender = value;\n\tif (!value)\n\t\treturn;\n\tif (!(devc->voc[voice].keyon_byte & 0x20))\n\t\treturn;\t/*\n\t\t\t * Not keyed on\n\t\t\t */\n\n\tfreq = compute_finetune(devc->voc[voice].orig_freq, devc->voc[voice].bender, devc->voc[voice].bender_range, 0);\n\tdevc->voc[voice].current_freq = freq;\n\n\tfreq_to_fnum(freq, &block, &fnum);\n\n\tdata = fnum & 0xff;\t/*\n\t\t\t\t * Least significant bits of fnumber\n\t\t\t\t */\n\topl3_command(map->ioaddr, FNUM_LOW + map->voice_num, data);\n\n\tdata = 0x20 | ((block & 0x7) << 2) | ((fnum >> 8) & 0x3);\n\tdevc->voc[voice].keyon_byte = data;\n\topl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num, data);\n}\n\nstatic void opl3_controller (int dev, int voice, int ctrl_num, int value)\n{\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tswitch (ctrl_num)\n\t{\n\t\tcase CTRL_PITCH_BENDER:\n\t\t\tbend_pitch(dev, voice, value);\n\t\t\tbreak;\n\n\t\tcase CTRL_PITCH_BENDER_RANGE:\n\t\t\tdevc->voc[voice].bender_range = value;\n\t\t\tbreak;\n\n\t\tcase CTL_MAIN_VOLUME:\n\t\t\tdevc->voc[voice].volume = value / 128;\n\t\t\tbreak;\n\n\t\tcase CTL_PAN:\n\t\t\tdevc->voc[voice].panning = (value * 2) - 128;\n\t\t\tbreak;\n\t}\n}\n\nstatic void opl3_bender(int dev, int voice, int value)\n{\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tbend_pitch(dev, voice, value - 8192);\n}\n\nstatic int opl3_alloc_voice(int dev, int chn, int note, struct voice_alloc_info *alloc)\n{\n\tint i, p, best, first, avail, best_time = 0x7fffffff;\n\tstruct sbi_instrument *instr;\n\tint is4op;\n\tint instr_no;\n\n\tif (chn < 0 || chn > 15)\n\t\tinstr_no = 0;\n\telse\n\t\tinstr_no = devc->chn_info[chn].pgm_num;\n\n\tinstr = &devc->i_map[instr_no];\n\tif (instr->channel < 0 ||\t/* Instrument not loaded */\n\t\tdevc->nr_voice != 12)\t/* Not in 4 OP mode */\n\t\tis4op = 0;\n\telse if (devc->nr_voice == 12)\t/* 4 OP mode */\n\t\tis4op = (instr->key == OPL3_PATCH);\n\telse\n\t\tis4op = 0;\n\n\tif (is4op)\n\t{\n\t\tfirst = p = 0;\n\t\tavail = 6;\n\t}\n\telse\n\t{\n\t\tif (devc->nr_voice == 12)\t/* 4 OP mode. Use the '2 OP only' operators first */\n\t\t\tfirst = p = 6;\n\t\telse\n\t\t\tfirst = p = 0;\n\t\tavail = devc->nr_voice;\n\t}\n\n\t/*\n\t *    Now try to find a free voice\n\t */\n\tbest = first;\n\n\tfor (i = 0; i < avail; i++)\n\t{\n\t\tif (alloc->map[p] == 0)\n\t\t{\n\t\t\treturn p;\n\t\t}\n\t\tif (alloc->alloc_times[p] < best_time)\t\t/* Find oldest playing note */\n\t\t{\n\t\t\tbest_time = alloc->alloc_times[p];\n\t\t\tbest = p;\n\t\t}\n\t\tp = (p + 1) % avail;\n\t}\n\n\t/*\n\t *    Insert some kind of priority mechanism here.\n\t */\n\n\tif (best < 0)\n\t\tbest = 0;\n\tif (best > devc->nr_voice)\n\t\tbest -= devc->nr_voice;\n\n\treturn best;\t/* All devc->voc in use. Select the first one. */\n}\n\nstatic void opl3_setup_voice(int dev, int voice, int chn)\n{\n\tstruct channel_info *info =\n\t&synth_devs[dev]->chn_info[chn];\n\n\topl3_set_instr(dev, voice, info->pgm_num);\n\n\tdevc->voc[voice].bender = 0;\n\tdevc->voc[voice].bender_range = info->bender_range;\n\tdevc->voc[voice].volume = info->controllers[CTL_MAIN_VOLUME];\n\tdevc->voc[voice].panning = (info->controllers[CTL_PAN] * 2) - 128;\n}\n\nstatic struct synth_operations opl3_operations =\n{\n\t.owner\t\t= THIS_MODULE,\n\t.id\t\t= \"OPL\",\n\t.info\t\t= NULL,\n\t.midi_dev\t= 0,\n\t.synth_type\t= SYNTH_TYPE_FM,\n\t.synth_subtype\t= FM_TYPE_ADLIB,\n\t.open\t\t= opl3_open,\n\t.close\t\t= opl3_close,\n\t.ioctl\t\t= opl3_ioctl,\n\t.kill_note\t= opl3_kill_note,\n\t.start_note\t= opl3_start_note,\n\t.set_instr\t= opl3_set_instr,\n\t.reset\t\t= opl3_reset,\n\t.hw_control\t= opl3_hw_control,\n\t.load_patch\t= opl3_load_patch,\n\t.aftertouch\t= opl3_aftertouch,\n\t.controller\t= opl3_controller,\n\t.panning\t= opl3_panning,\n\t.volume_method\t= opl3_volume_method,\n\t.bender\t\t= opl3_bender,\n\t.alloc_voice\t= opl3_alloc_voice,\n\t.setup_voice\t= opl3_setup_voice\n};\n\nstatic int opl3_init(int ioaddr, struct module *owner)\n{\n\tint i;\n\tint me;\n\n\tif (devc == NULL)\n\t{\n\t\tprintk(KERN_ERR \"opl3: Device control structure not initialized.\\n\");\n\t\treturn -1;\n\t}\n\n\tif ((me = sound_alloc_synthdev()) == -1)\n\t{\n\t\tprintk(KERN_WARNING \"opl3: Too many synthesizers\\n\");\n\t\treturn -1;\n\t}\n\n\tdevc->nr_voice = 9;\n\n\tdevc->fm_info.device = 0;\n\tdevc->fm_info.synth_type = SYNTH_TYPE_FM;\n\tdevc->fm_info.synth_subtype = FM_TYPE_ADLIB;\n\tdevc->fm_info.perc_mode = 0;\n\tdevc->fm_info.nr_voices = 9;\n\tdevc->fm_info.nr_drums = 0;\n\tdevc->fm_info.instr_bank_size = SBFM_MAXINSTR;\n\tdevc->fm_info.capabilities = 0;\n\tdevc->left_io = ioaddr;\n\tdevc->right_io = ioaddr + 2;\n\n\tif (detected_model <= 2)\n\t\tdevc->model = 1;\n\telse\n\t{\n\t\tdevc->model = 2;\n\t\tif (detected_model == 4)\n\t\t\tdevc->is_opl4 = 1;\n\t}\n\n\topl3_operations.info = &devc->fm_info;\n\n\tsynth_devs[me] = &opl3_operations;\n\n\tif (owner)\n\t\tsynth_devs[me]->owner = owner;\n\t\n\tsequencer_init();\n\tdevc->v_alloc = &opl3_operations.alloc;\n\tdevc->chn_info = &opl3_operations.chn_info[0];\n\n\tif (devc->model == 2)\n\t{\n\t\tif (devc->is_opl4) \n\t\t\tstrcpy(devc->fm_info.name, \"Yamaha OPL4/OPL3 FM\");\n\t\telse \n\t\t\tstrcpy(devc->fm_info.name, \"Yamaha OPL3\");\n\n\t\tdevc->v_alloc->max_voice = devc->nr_voice = 18;\n\t\tdevc->fm_info.nr_drums = 0;\n\t\tdevc->fm_info.synth_subtype = FM_TYPE_OPL3;\n\t\tdevc->fm_info.capabilities |= SYNTH_CAP_OPL3;\n\n\t\tfor (i = 0; i < 18; i++)\n\t\t{\n\t\t\tif (pv_map[i].ioaddr == USE_LEFT)\n\t\t\t\tpv_map[i].ioaddr = devc->left_io;\n\t\t\telse\n\t\t\t\tpv_map[i].ioaddr = devc->right_io;\n\t\t}\n\t\topl3_command(devc->right_io, OPL3_MODE_REGISTER, OPL3_ENABLE);\n\t\topl3_command(devc->right_io, CONNECTION_SELECT_REGISTER, 0x00);\n\t}\n\telse\n\t{\n\t\tstrcpy(devc->fm_info.name, \"Yamaha OPL2\");\n\t\tdevc->v_alloc->max_voice = devc->nr_voice = 9;\n\t\tdevc->fm_info.nr_drums = 0;\n\n\t\tfor (i = 0; i < 18; i++)\n\t\t\tpv_map[i].ioaddr = devc->left_io;\n\t};\n\tconf_printf2(devc->fm_info.name, ioaddr, 0, -1, -1);\n\n\tfor (i = 0; i < SBFM_MAXINSTR; i++)\n\t\tdevc->i_map[i].channel = -1;\n\n\treturn me;\n}\n\nstatic int me;\n\nstatic int io = -1;\n\nmodule_param(io, int, 0);\n\nstatic int __init init_opl3 (void)\n{\n\tprintk(KERN_INFO \"YM3812 and OPL-3 driver Copyright (C) by Hannu Savolainen, Rob Hooft 1993-1996\\n\");\n\n\tif (io != -1)\t/* User loading pure OPL3 module */\n\t{\n\t\tif (!opl3_detect(io))\n\t\t{\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tme = opl3_init(io, THIS_MODULE);\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit cleanup_opl3(void)\n{\n\tif (devc && io != -1)\n\t{\n\t\tif (devc->base) {\n\t\t\trelease_region(devc->base,4);\n\t\t\tif (devc->is_opl4)\n\t\t\t\trelease_region(devc->base - 8, 2);\n\t\t}\n\t\tkfree(devc);\n\t\tdevc = NULL;\n\t\tsound_unload_synthdev(me);\n\t}\n}\n\nmodule_init(init_opl3);\nmodule_exit(cleanup_opl3);\n\n#ifndef MODULE\nstatic int __init setup_opl3(char *str)\n{\n        /* io  */\n\tint ints[2];\n\t\n\tstr = get_options(str, ARRAY_SIZE(ints), ints);\n\t\n\tio = ints[1];\n\n\treturn 1;\n}\n\n__setup(\"opl3=\", setup_opl3);\n#endif\nMODULE_LICENSE(\"GPL\");\n", "/*\n * sound/oss/sequencer.c\n *\n * The sequencer personality manager.\n */\n/*\n * Copyright (C) by Hannu Savolainen 1993-1997\n *\n * OSS/Free for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)\n * Version 2 (June 1991). See the \"COPYING\" file distributed with this software\n * for more info.\n */\n/*\n * Thomas Sailer   : ioctl code reworked (vmalloc/vfree removed)\n * Alan Cox\t   : reformatted and fixed a pair of null pointer bugs\n */\n#include <linux/kmod.h>\n#include <linux/spinlock.h>\n#include \"sound_config.h\"\n\n#include \"midi_ctrl.h\"\n\nstatic int      sequencer_ok;\nstatic struct sound_timer_operations *tmr;\nstatic int      tmr_no = -1;\t/* Currently selected timer */\nstatic int      pending_timer = -1;\t/* For timer change operation */\nextern unsigned long seq_time;\n\nstatic int      obsolete_api_used;\nstatic DEFINE_SPINLOCK(lock);\n\n/*\n * Local counts for number of synth and MIDI devices. These are initialized\n * by the sequencer_open.\n */\nstatic int      max_mididev;\nstatic int      max_synthdev;\n\n/*\n * The seq_mode gives the operating mode of the sequencer:\n *      1 = level1 (the default)\n *      2 = level2 (extended capabilities)\n */\n\n#define SEQ_1\t1\n#define SEQ_2\t2\nstatic int      seq_mode = SEQ_1;\n\nstatic DECLARE_WAIT_QUEUE_HEAD(seq_sleeper);\nstatic DECLARE_WAIT_QUEUE_HEAD(midi_sleeper);\n\nstatic int      midi_opened[MAX_MIDI_DEV];\n\nstatic int      midi_written[MAX_MIDI_DEV];\n\nstatic unsigned long prev_input_time;\nstatic int      prev_event_time;\n\n#include \"tuning.h\"\n\n#define EV_SZ\t8\n#define IEV_SZ\t8\n\nstatic unsigned char *queue;\nstatic unsigned char *iqueue;\n\nstatic volatile int qhead, qtail, qlen;\nstatic volatile int iqhead, iqtail, iqlen;\nstatic volatile int seq_playing;\nstatic volatile int sequencer_busy;\nstatic int      output_threshold;\nstatic long     pre_event_timeout;\nstatic unsigned synth_open_mask;\n\nstatic int      seq_queue(unsigned char *note, char nonblock);\nstatic void     seq_startplay(void);\nstatic int      seq_sync(void);\nstatic void     seq_reset(void);\n\n#if MAX_SYNTH_DEV > 15\n#error Too many synthesizer devices enabled.\n#endif\n\nint sequencer_read(int dev, struct file *file, char __user *buf, int count)\n{\n\tint c = count, p = 0;\n\tint ev_len;\n\tunsigned long flags;\n\n\tdev = dev >> 4;\n\n\tev_len = seq_mode == SEQ_1 ? 4 : 8;\n\n\tspin_lock_irqsave(&lock,flags);\n\n\tif (!iqlen)\n\t{\n\t\tspin_unlock_irqrestore(&lock,flags);\n \t\tif (file->f_flags & O_NONBLOCK) {\n  \t\t\treturn -EAGAIN;\n  \t\t}\n\n \t\tinterruptible_sleep_on_timeout(&midi_sleeper,\n\t\t\t\t\t       pre_event_timeout);\n\t\tspin_lock_irqsave(&lock,flags);\n\t\tif (!iqlen)\n\t\t{\n\t\t\tspin_unlock_irqrestore(&lock,flags);\n\t\t\treturn 0;\n\t\t}\n\t}\n\twhile (iqlen && c >= ev_len)\n\t{\n\t\tchar *fixit = (char *) &iqueue[iqhead * IEV_SZ];\n\t\tspin_unlock_irqrestore(&lock,flags);\n\t\tif (copy_to_user(&(buf)[p], fixit, ev_len))\n\t\t\treturn count - c;\n\t\tp += ev_len;\n\t\tc -= ev_len;\n\n\t\tspin_lock_irqsave(&lock,flags);\n\t\tiqhead = (iqhead + 1) % SEQ_MAX_QUEUE;\n\t\tiqlen--;\n\t}\n\tspin_unlock_irqrestore(&lock,flags);\n\treturn count - c;\n}\n\nstatic void sequencer_midi_output(int dev)\n{\n\t/*\n\t * Currently NOP\n\t */\n}\n\nvoid seq_copy_to_input(unsigned char *event_rec, int len)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Verify that the len is valid for the current mode.\n\t */\n\n\tif (len != 4 && len != 8)\n\t\treturn;\n\tif ((seq_mode == SEQ_1) != (len == 4))\n\t\treturn;\n\n\tif (iqlen >= (SEQ_MAX_QUEUE - 1))\n\t\treturn;\t\t/* Overflow */\n\n\tspin_lock_irqsave(&lock,flags);\n\tmemcpy(&iqueue[iqtail * IEV_SZ], event_rec, len);\n\tiqlen++;\n\tiqtail = (iqtail + 1) % SEQ_MAX_QUEUE;\n\twake_up(&midi_sleeper);\n\tspin_unlock_irqrestore(&lock,flags);\n}\nEXPORT_SYMBOL(seq_copy_to_input);\n\nstatic void sequencer_midi_input(int dev, unsigned char data)\n{\n\tunsigned int tstamp;\n\tunsigned char event_rec[4];\n\n\tif (data == 0xfe)\t/* Ignore active sensing */\n\t\treturn;\n\n\ttstamp = jiffies - seq_time;\n\n\tif (tstamp != prev_input_time)\n\t{\n\t\ttstamp = (tstamp << 8) | SEQ_WAIT;\n\t\tseq_copy_to_input((unsigned char *) &tstamp, 4);\n\t\tprev_input_time = tstamp;\n\t}\n\tevent_rec[0] = SEQ_MIDIPUTC;\n\tevent_rec[1] = data;\n\tevent_rec[2] = dev;\n\tevent_rec[3] = 0;\n\n\tseq_copy_to_input(event_rec, 4);\n}\n\nvoid seq_input_event(unsigned char *event_rec, int len)\n{\n\tunsigned long this_time;\n\n\tif (seq_mode == SEQ_2)\n\t\tthis_time = tmr->get_time(tmr_no);\n\telse\n\t\tthis_time = jiffies - seq_time;\n\n\tif (this_time != prev_input_time)\n\t{\n\t\tunsigned char   tmp_event[8];\n\n\t\ttmp_event[0] = EV_TIMING;\n\t\ttmp_event[1] = TMR_WAIT_ABS;\n\t\ttmp_event[2] = 0;\n\t\ttmp_event[3] = 0;\n\t\t*(unsigned int *) &tmp_event[4] = this_time;\n\n\t\tseq_copy_to_input(tmp_event, 8);\n\t\tprev_input_time = this_time;\n\t}\n\tseq_copy_to_input(event_rec, len);\n}\nEXPORT_SYMBOL(seq_input_event);\n\nint sequencer_write(int dev, struct file *file, const char __user *buf, int count)\n{\n\tunsigned char event_rec[EV_SZ], ev_code;\n\tint p = 0, c, ev_size;\n\tint mode = translate_mode(file);\n\n\tdev = dev >> 4;\n\n\tDEB(printk(\"sequencer_write(dev=%d, count=%d)\\n\", dev, count));\n\n\tif (mode == OPEN_READ)\n\t\treturn -EIO;\n\n\tc = count;\n\n\twhile (c >= 4)\n\t{\n\t\tif (copy_from_user((char *) event_rec, &(buf)[p], 4))\n\t\t\tgoto out;\n\t\tev_code = event_rec[0];\n\n\t\tif (ev_code == SEQ_FULLSIZE)\n\t\t{\n\t\t\tint err, fmt;\n\n\t\t\tdev = *(unsigned short *) &event_rec[2];\n\t\t\tif (dev < 0 || dev >= max_synthdev || synth_devs[dev] == NULL)\n\t\t\t\treturn -ENXIO;\n\n\t\t\tif (!(synth_open_mask & (1 << dev)))\n\t\t\t\treturn -ENXIO;\n\n\t\t\tfmt = (*(short *) &event_rec[0]) & 0xffff;\n\t\t\terr = synth_devs[dev]->load_patch(dev, fmt, buf + p, c, 0);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\treturn err;\n\t\t}\n\t\tif (ev_code >= 128)\n\t\t{\n\t\t\tif (seq_mode == SEQ_2 && ev_code == SEQ_EXTENDED)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"Sequencer: Invalid level 2 event %x\\n\", ev_code);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tev_size = 8;\n\n\t\t\tif (c < ev_size)\n\t\t\t{\n\t\t\t\tif (!seq_playing)\n\t\t\t\t\tseq_startplay();\n\t\t\t\treturn count - c;\n\t\t\t}\n\t\t\tif (copy_from_user((char *)&event_rec[4],\n\t\t\t\t\t   &(buf)[p + 4], 4))\n\t\t\t\tgoto out;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (seq_mode == SEQ_2)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"Sequencer: 4 byte event in level 2 mode\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tev_size = 4;\n\n\t\t\tif (event_rec[0] != SEQ_MIDIPUTC)\n\t\t\t\tobsolete_api_used = 1;\n\t\t}\n\n\t\tif (event_rec[0] == SEQ_MIDIPUTC)\n\t\t{\n\t\t\tif (!midi_opened[event_rec[2]])\n\t\t\t{\n\t\t\t\tint err, mode;\n\t\t\t\tint dev = event_rec[2];\n\n\t\t\t\tif (dev >= max_mididev || midi_devs[dev]==NULL)\n\t\t\t\t{\n\t\t\t\t\t/*printk(\"Sequencer Error: Nonexistent MIDI device %d\\n\", dev);*/\n\t\t\t\t\treturn -ENXIO;\n\t\t\t\t}\n\t\t\t\tmode = translate_mode(file);\n\n\t\t\t\tif ((err = midi_devs[dev]->open(dev, mode,\n\t\t\t\t\t\t\t\tsequencer_midi_input, sequencer_midi_output)) < 0)\n\t\t\t\t{\n\t\t\t\t\tseq_reset();\n\t\t\t\t\tprintk(KERN_WARNING \"Sequencer Error: Unable to open Midi #%d\\n\", dev);\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t\tmidi_opened[dev] = 1;\n\t\t\t}\n\t\t}\n\t\tif (!seq_queue(event_rec, (file->f_flags & (O_NONBLOCK) ? 1 : 0)))\n\t\t{\n\t\t\tint processed = count - c;\n\n\t\t\tif (!seq_playing)\n\t\t\t\tseq_startplay();\n\n\t\t\tif (!processed && (file->f_flags & O_NONBLOCK))\n\t\t\t\treturn -EAGAIN;\n\t\t\telse\n\t\t\t\treturn processed;\n\t\t}\n\t\tp += ev_size;\n\t\tc -= ev_size;\n\t}\n\n\tif (!seq_playing)\n\t\tseq_startplay();\nout:\n\treturn count;\n}\n\nstatic int seq_queue(unsigned char *note, char nonblock)\n{\n\n\t/*\n\t * Test if there is space in the queue\n\t */\n\n\tif (qlen >= SEQ_MAX_QUEUE)\n\t\tif (!seq_playing)\n\t\t\tseq_startplay();\t/*\n\t\t\t\t\t\t * Give chance to drain the queue\n\t\t\t\t\t\t */\n\n\tif (!nonblock && qlen >= SEQ_MAX_QUEUE && !waitqueue_active(&seq_sleeper)) {\n\t\t/*\n\t\t * Sleep until there is enough space on the queue\n\t\t */\n\t\tinterruptible_sleep_on(&seq_sleeper);\n\t}\n\tif (qlen >= SEQ_MAX_QUEUE)\n\t{\n\t\treturn 0;\t/*\n\t\t\t\t * To be sure\n\t\t\t\t */\n\t}\n\tmemcpy(&queue[qtail * EV_SZ], note, EV_SZ);\n\n\tqtail = (qtail + 1) % SEQ_MAX_QUEUE;\n\tqlen++;\n\n\treturn 1;\n}\n\nstatic int extended_event(unsigned char *q)\n{\n\tint dev = q[2];\n\n\tif (dev < 0 || dev >= max_synthdev)\n\t\treturn -ENXIO;\n\n\tif (!(synth_open_mask & (1 << dev)))\n\t\treturn -ENXIO;\n\n\tswitch (q[1])\n\t{\n\t\tcase SEQ_NOTEOFF:\n\t\t\tsynth_devs[dev]->kill_note(dev, q[3], q[4], q[5]);\n\t\t\tbreak;\n\n\t\tcase SEQ_NOTEON:\n\t\t\tif (q[4] > 127 && q[4] != 255)\n\t\t\t\treturn 0;\n\n\t\t\tif (q[5] == 0)\n\t\t\t{\n\t\t\t\tsynth_devs[dev]->kill_note(dev, q[3], q[4], q[5]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsynth_devs[dev]->start_note(dev, q[3], q[4], q[5]);\n\t\t\tbreak;\n\n\t\tcase SEQ_PGMCHANGE:\n\t\t\tsynth_devs[dev]->set_instr(dev, q[3], q[4]);\n\t\t\tbreak;\n\n\t\tcase SEQ_AFTERTOUCH:\n\t\t\tsynth_devs[dev]->aftertouch(dev, q[3], q[4]);\n\t\t\tbreak;\n\n\t\tcase SEQ_BALANCE:\n\t\t\tsynth_devs[dev]->panning(dev, q[3], (char) q[4]);\n\t\t\tbreak;\n\n\t\tcase SEQ_CONTROLLER:\n\t\t\tsynth_devs[dev]->controller(dev, q[3], q[4], (short) (q[5] | (q[6] << 8)));\n\t\t\tbreak;\n\n\t\tcase SEQ_VOLMODE:\n\t\t\tif (synth_devs[dev]->volume_method != NULL)\n\t\t\t\tsynth_devs[dev]->volume_method(dev, q[3]);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int find_voice(int dev, int chn, int note)\n{\n\tunsigned short key;\n\tint i;\n\n\tkey = (chn << 8) | (note + 1);\n\tfor (i = 0; i < synth_devs[dev]->alloc.max_voice; i++)\n\t\tif (synth_devs[dev]->alloc.map[i] == key)\n\t\t\treturn i;\n\treturn -1;\n}\n\nstatic int alloc_voice(int dev, int chn, int note)\n{\n\tunsigned short  key;\n\tint voice;\n\n\tkey = (chn << 8) | (note + 1);\n\n\tvoice = synth_devs[dev]->alloc_voice(dev, chn, note,\n\t\t\t\t\t     &synth_devs[dev]->alloc);\n\tsynth_devs[dev]->alloc.map[voice] = key;\n\tsynth_devs[dev]->alloc.alloc_times[voice] =\n\t\t\tsynth_devs[dev]->alloc.timestamp++;\n\treturn voice;\n}\n\nstatic void seq_chn_voice_event(unsigned char *event_rec)\n{\n#define dev event_rec[1]\n#define cmd event_rec[2]\n#define chn event_rec[3]\n#define note event_rec[4]\n#define parm event_rec[5]\n\n\tint voice = -1;\n\n\tif ((int) dev > max_synthdev || synth_devs[dev] == NULL)\n\t\treturn;\n\tif (!(synth_open_mask & (1 << dev)))\n\t\treturn;\n\tif (!synth_devs[dev])\n\t\treturn;\n\n\tif (seq_mode == SEQ_2)\n\t{\n\t\tif (synth_devs[dev]->alloc_voice)\n\t\t\tvoice = find_voice(dev, chn, note);\n\n\t\tif (cmd == MIDI_NOTEON && parm == 0)\n\t\t{\n\t\t\tcmd = MIDI_NOTEOFF;\n\t\t\tparm = 64;\n\t\t}\n\t}\n\n\tswitch (cmd)\n\t{\n\t\tcase MIDI_NOTEON:\n\t\t\tif (note > 127 && note != 255)\t/* Not a seq2 feature */\n\t\t\t\treturn;\n\n\t\t\tif (voice == -1 && seq_mode == SEQ_2 && synth_devs[dev]->alloc_voice)\n\t\t\t{\n\t\t\t\t/* Internal synthesizer (FM, GUS, etc) */\n\t\t\t\tvoice = alloc_voice(dev, chn, note);\n\t\t\t}\n\t\t\tif (voice == -1)\n\t\t\t\tvoice = chn;\n\n\t\t\tif (seq_mode == SEQ_2 && (int) dev < num_synths)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * The MIDI channel 10 is a percussive channel. Use the note\n\t\t\t\t * number to select the proper patch (128 to 255) to play.\n\t\t\t\t */\n\n\t\t\t\tif (chn == 9)\n\t\t\t\t{\n\t\t\t\t\tsynth_devs[dev]->set_instr(dev, voice, 128 + note);\n\t\t\t\t\tsynth_devs[dev]->chn_info[chn].pgm_num = 128 + note;\n\t\t\t\t}\n\t\t\t\tsynth_devs[dev]->setup_voice(dev, voice, chn);\n\t\t\t}\n\t\t\tsynth_devs[dev]->start_note(dev, voice, note, parm);\n\t\t\tbreak;\n\n\t\tcase MIDI_NOTEOFF:\n\t\t\tif (voice == -1)\n\t\t\t\tvoice = chn;\n\t\t\tsynth_devs[dev]->kill_note(dev, voice, note, parm);\n\t\t\tbreak;\n\n\t\tcase MIDI_KEY_PRESSURE:\n\t\t\tif (voice == -1)\n\t\t\t\tvoice = chn;\n\t\t\tsynth_devs[dev]->aftertouch(dev, voice, parm);\n\t\t\tbreak;\n\n\t\tdefault:;\n\t}\n#undef dev\n#undef cmd\n#undef chn\n#undef note\n#undef parm\n}\n\n\nstatic void seq_chn_common_event(unsigned char *event_rec)\n{\n\tunsigned char dev = event_rec[1];\n\tunsigned char cmd = event_rec[2];\n\tunsigned char chn = event_rec[3];\n\tunsigned char p1 = event_rec[4];\n\n\t/* unsigned char p2 = event_rec[5]; */\n\tunsigned short w14 = *(short *) &event_rec[6];\n\n\tif ((int) dev > max_synthdev || synth_devs[dev] == NULL)\n\t\treturn;\n\tif (!(synth_open_mask & (1 << dev)))\n\t\treturn;\n\tif (!synth_devs[dev])\n\t\treturn;\n\n\tswitch (cmd)\n\t{\n\t\tcase MIDI_PGM_CHANGE:\n\t\t\tif (seq_mode == SEQ_2)\n\t\t\t{\n\t\t\t\tsynth_devs[dev]->chn_info[chn].pgm_num = p1;\n\t\t\t\tif ((int) dev >= num_synths)\n\t\t\t\t\tsynth_devs[dev]->set_instr(dev, chn, p1);\n\t\t\t}\n\t\t\telse\n\t\t\t\tsynth_devs[dev]->set_instr(dev, chn, p1);\n\n\t\t\tbreak;\n\n\t\tcase MIDI_CTL_CHANGE:\n\t\t\tif (seq_mode == SEQ_2)\n\t\t\t{\n\t\t\t\tif (chn > 15 || p1 > 127)\n\t\t\t\t\tbreak;\n\n\t\t\t\tsynth_devs[dev]->chn_info[chn].controllers[p1] = w14 & 0x7f;\n\n\t\t\t\tif (p1 < 32)\t/* Setting MSB should clear LSB to 0 */\n\t\t\t\t\tsynth_devs[dev]->chn_info[chn].controllers[p1 + 32] = 0;\n\n\t\t\t\tif ((int) dev < num_synths)\n\t\t\t\t{\n\t\t\t\t\tint val = w14 & 0x7f;\n\t\t\t\t\tint i, key;\n\n\t\t\t\t\tif (p1 < 64)\t/* Combine MSB and LSB */\n\t\t\t\t\t{\n\t\t\t\t\t\tval = ((synth_devs[dev]->\n\t\t\t\t\t\t\tchn_info[chn].controllers[p1 & ~32] & 0x7f) << 7)\n\t\t\t\t\t\t\t| (synth_devs[dev]->\n\t\t\t\t\t\t\tchn_info[chn].controllers[p1 | 32] & 0x7f);\n\t\t\t\t\t\tp1 &= ~32;\n\t\t\t\t\t}\n\t\t\t\t\t/* Handle all playing notes on this channel */\n\n\t\t\t\t\tkey = ((int) chn << 8);\n\n\t\t\t\t\tfor (i = 0; i < synth_devs[dev]->alloc.max_voice; i++)\n\t\t\t\t\t\tif ((synth_devs[dev]->alloc.map[i] & 0xff00) == key)\n\t\t\t\t\t\t\tsynth_devs[dev]->controller(dev, i, p1, val);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsynth_devs[dev]->controller(dev, chn, p1, w14);\n\t\t\t}\n\t\t\telse\t/* Mode 1 */\n\t\t\t\tsynth_devs[dev]->controller(dev, chn, p1, w14);\n\t\t\tbreak;\n\n\t\tcase MIDI_PITCH_BEND:\n\t\t\tif (seq_mode == SEQ_2)\n\t\t\t{\n\t\t\t\tsynth_devs[dev]->chn_info[chn].bender_value = w14;\n\n\t\t\t\tif ((int) dev < num_synths)\n\t\t\t\t{\n\t\t\t\t\t/* Handle all playing notes on this channel */\n\t\t\t\t\tint i, key;\n\n\t\t\t\t\tkey = (chn << 8);\n\n\t\t\t\t\tfor (i = 0; i < synth_devs[dev]->alloc.max_voice; i++)\n\t\t\t\t\t\tif ((synth_devs[dev]->alloc.map[i] & 0xff00) == key)\n\t\t\t\t\t\t\tsynth_devs[dev]->bender(dev, i, w14);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsynth_devs[dev]->bender(dev, chn, w14);\n\t\t\t}\n\t\t\telse\t/* MODE 1 */\n\t\t\t\tsynth_devs[dev]->bender(dev, chn, w14);\n\t\t\tbreak;\n\n\t\tdefault:;\n\t}\n}\n\nstatic int seq_timing_event(unsigned char *event_rec)\n{\n\tunsigned char cmd = event_rec[1];\n\tunsigned int parm = *(int *) &event_rec[4];\n\n\tif (seq_mode == SEQ_2)\n\t{\n\t\tint ret;\n\n\t\tif ((ret = tmr->event(tmr_no, event_rec)) == TIMER_ARMED)\n\t\t\tif ((SEQ_MAX_QUEUE - qlen) >= output_threshold)\n\t\t\t\twake_up(&seq_sleeper);\n\t\treturn ret;\n\t}\n\tswitch (cmd)\n\t{\n\t\tcase TMR_WAIT_REL:\n\t\t\tparm += prev_event_time;\n\n\t\t\t/*\n\t\t\t * NOTE!  No break here. Execution of TMR_WAIT_REL continues in the\n\t\t\t * next case (TMR_WAIT_ABS)\n\t\t\t */\n\n\t\tcase TMR_WAIT_ABS:\n\t\t\tif (parm > 0)\n\t\t\t{\n\t\t\t\tlong time;\n\n\t\t\t\ttime = parm;\n\t\t\t\tprev_event_time = time;\n\n\t\t\t\tseq_playing = 1;\n\t\t\t\trequest_sound_timer(time);\n\n\t\t\t\tif ((SEQ_MAX_QUEUE - qlen) >= output_threshold)\n\t\t\t\t\twake_up(&seq_sleeper);\n\t\t\t\treturn TIMER_ARMED;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TMR_START:\n\t\t\tseq_time = jiffies;\n\t\t\tprev_input_time = 0;\n\t\t\tprev_event_time = 0;\n\t\t\tbreak;\n\n\t\tcase TMR_STOP:\n\t\t\tbreak;\n\n\t\tcase TMR_CONTINUE:\n\t\t\tbreak;\n\n\t\tcase TMR_TEMPO:\n\t\t\tbreak;\n\n\t\tcase TMR_ECHO:\n\t\t\tif (seq_mode == SEQ_2)\n\t\t\t\tseq_copy_to_input(event_rec, 8);\n\t\t\telse\n\t\t\t{\n\t\t\t\tparm = (parm << 8 | SEQ_ECHO);\n\t\t\t\tseq_copy_to_input((unsigned char *) &parm, 4);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:;\n\t}\n\n\treturn TIMER_NOT_ARMED;\n}\n\nstatic void seq_local_event(unsigned char *event_rec)\n{\n\tunsigned char   cmd = event_rec[1];\n\tunsigned int    parm = *((unsigned int *) &event_rec[4]);\n\n\tswitch (cmd)\n\t{\n\t\tcase LOCL_STARTAUDIO:\n\t\t\tDMAbuf_start_devices(parm);\n\t\t\tbreak;\n\n\t\tdefault:;\n\t}\n}\n\nstatic void seq_sysex_message(unsigned char *event_rec)\n{\n\tunsigned int dev = event_rec[1];\n\tint i, l = 0;\n\tunsigned char  *buf = &event_rec[2];\n\n\tif (dev > max_synthdev)\n\t\treturn;\n\tif (!(synth_open_mask & (1 << dev)))\n\t\treturn;\n\tif (!synth_devs[dev])\n\t\treturn;\n\n\tl = 0;\n\tfor (i = 0; i < 6 && buf[i] != 0xff; i++)\n\t\tl = i + 1;\n\n\tif (!synth_devs[dev]->send_sysex)\n\t\treturn;\n\tif (l > 0)\n\t\tsynth_devs[dev]->send_sysex(dev, buf, l);\n}\n\nstatic int play_event(unsigned char *q)\n{\n\t/*\n\t * NOTE! This routine returns\n\t *   0 = normal event played.\n\t *   1 = Timer armed. Suspend playback until timer callback.\n\t *   2 = MIDI output buffer full. Restore queue and suspend until timer\n\t */\n\tunsigned int *delay;\n\n\tswitch (q[0])\n\t{\n\t\tcase SEQ_NOTEOFF:\n\t\t\tif (synth_open_mask & (1 << 0))\n\t\t\t\tif (synth_devs[0])\n\t\t\t\t\tsynth_devs[0]->kill_note(0, q[1], 255, q[3]);\n\t\t\tbreak;\n\n\t\tcase SEQ_NOTEON:\n\t\t\tif (q[4] < 128 || q[4] == 255)\n\t\t\t\tif (synth_open_mask & (1 << 0))\n\t\t\t\t\tif (synth_devs[0])\n\t\t\t\t\t\tsynth_devs[0]->start_note(0, q[1], q[2], q[3]);\n\t\t\tbreak;\n\n\t\tcase SEQ_WAIT:\n\t\t\tdelay = (unsigned int *) q;\t/*\n\t\t\t\t\t\t\t * Bytes 1 to 3 are containing the *\n\t\t\t\t\t\t\t * delay in 'ticks'\n\t\t\t\t\t\t\t */\n\t\t\t*delay = (*delay >> 8) & 0xffffff;\n\n\t\t\tif (*delay > 0)\n\t\t\t{\n\t\t\t\tlong time;\n\n\t\t\t\tseq_playing = 1;\n\t\t\t\ttime = *delay;\n\t\t\t\tprev_event_time = time;\n\n\t\t\t\trequest_sound_timer(time);\n\n\t\t\t\tif ((SEQ_MAX_QUEUE - qlen) >= output_threshold)\n\t\t\t\t\twake_up(&seq_sleeper);\n\t\t\t\t/*\n\t\t\t\t * The timer is now active and will reinvoke this function\n\t\t\t\t * after the timer expires. Return to the caller now.\n\t\t\t\t */\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SEQ_PGMCHANGE:\n\t\t\tif (synth_open_mask & (1 << 0))\n\t\t\t\tif (synth_devs[0])\n\t\t\t\t\tsynth_devs[0]->set_instr(0, q[1], q[2]);\n\t\t\tbreak;\n\n\t\tcase SEQ_SYNCTIMER: \t/*\n\t\t\t\t\t * Reset timer\n\t\t\t\t\t */\n\t\t\tseq_time = jiffies;\n\t\t\tprev_input_time = 0;\n\t\t\tprev_event_time = 0;\n\t\t\tbreak;\n\n\t\tcase SEQ_MIDIPUTC:\t/*\n\t\t\t\t\t * Put a midi character\n\t\t\t\t\t */\n\t\t\tif (midi_opened[q[2]])\n\t\t\t{\n\t\t\t\tint dev;\n\n\t\t\t\tdev = q[2];\n\n\t\t\t\tif (dev < 0 || dev >= num_midis || midi_devs[dev] == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (!midi_devs[dev]->outputc(dev, q[1]))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Output FIFO is full. Wait one timer cycle and try again.\n\t\t\t\t\t */\n\n\t\t\t\t\tseq_playing = 1;\n\t\t\t\t\trequest_sound_timer(-1);\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tmidi_written[dev] = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SEQ_ECHO:\n\t\t\tseq_copy_to_input(q, 4);\t/*\n\t\t\t\t\t\t\t * Echo back to the process\n\t\t\t\t\t\t\t */\n\t\t\tbreak;\n\n\t\tcase SEQ_PRIVATE:\n\t\t\tif ((int) q[1] < max_synthdev)\n\t\t\t\tsynth_devs[q[1]]->hw_control(q[1], q);\n\t\t\tbreak;\n\n\t\tcase SEQ_EXTENDED:\n\t\t\textended_event(q);\n\t\t\tbreak;\n\n\t\tcase EV_CHN_VOICE:\n\t\t\tseq_chn_voice_event(q);\n\t\t\tbreak;\n\n\t\tcase EV_CHN_COMMON:\n\t\t\tseq_chn_common_event(q);\n\t\t\tbreak;\n\n\t\tcase EV_TIMING:\n\t\t\tif (seq_timing_event(q) == TIMER_ARMED)\n\t\t\t{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase EV_SEQ_LOCAL:\n\t\t\tseq_local_event(q);\n\t\t\tbreak;\n\n\t\tcase EV_SYSEX:\n\t\t\tseq_sysex_message(q);\n\t\t\tbreak;\n\n\t\tdefault:;\n\t}\n\treturn 0;\n}\n\n/* called also as timer in irq context */\nstatic void seq_startplay(void)\n{\n\tint this_one, action;\n\tunsigned long flags;\n\n\twhile (qlen > 0)\n\t{\n\n\t\tspin_lock_irqsave(&lock,flags);\n\t\tqhead = ((this_one = qhead) + 1) % SEQ_MAX_QUEUE;\n\t\tqlen--;\n\t\tspin_unlock_irqrestore(&lock,flags);\n\n\t\tseq_playing = 1;\n\n\t\tif ((action = play_event(&queue[this_one * EV_SZ])))\n\t\t{\t\t/* Suspend playback. Next timer routine invokes this routine again */\n\t\t\tif (action == 2)\n\t\t\t{\n\t\t\t\tqlen++;\n\t\t\t\tqhead = this_one;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\tseq_playing = 0;\n\n\tif ((SEQ_MAX_QUEUE - qlen) >= output_threshold)\n\t\twake_up(&seq_sleeper);\n}\n\nstatic void reset_controllers(int dev, unsigned char *controller, int update_dev)\n{\n\tint i;\n\tfor (i = 0; i < 128; i++)\n\t\tcontroller[i] = ctrl_def_values[i];\n}\n\nstatic void setup_mode2(void)\n{\n\tint dev;\n\n\tmax_synthdev = num_synths;\n\n\tfor (dev = 0; dev < num_midis; dev++)\n\t{\n\t\tif (midi_devs[dev] && midi_devs[dev]->converter != NULL)\n\t\t{\n\t\t\tsynth_devs[max_synthdev++] = midi_devs[dev]->converter;\n\t\t}\n\t}\n\n\tfor (dev = 0; dev < max_synthdev; dev++)\n\t{\n\t\tint chn;\n\n\t\tsynth_devs[dev]->sysex_ptr = 0;\n\t\tsynth_devs[dev]->emulation = 0;\n\n\t\tfor (chn = 0; chn < 16; chn++)\n\t\t{\n\t\t\tsynth_devs[dev]->chn_info[chn].pgm_num = 0;\n\t\t\treset_controllers(dev,\n\t\t\t\tsynth_devs[dev]->chn_info[chn].controllers,0);\n\t\t\tsynth_devs[dev]->chn_info[chn].bender_value = (1 << 7);\t/* Neutral */\n\t\t\tsynth_devs[dev]->chn_info[chn].bender_range = 200;\n\t\t}\n\t}\n\tmax_mididev = 0;\n\tseq_mode = SEQ_2;\n}\n\nint sequencer_open(int dev, struct file *file)\n{\n\tint retval, mode, i;\n\tint level, tmp;\n\n\tif (!sequencer_ok)\n\t\tsequencer_init();\n\n\tlevel = ((dev & 0x0f) == SND_DEV_SEQ2) ? 2 : 1;\n\n\tdev = dev >> 4;\n\tmode = translate_mode(file);\n\n\tDEB(printk(\"sequencer_open(dev=%d)\\n\", dev));\n\n\tif (!sequencer_ok)\n\t{\n/*\t\tprintk(\"Sound card: sequencer not initialized\\n\");*/\n\t\treturn -ENXIO;\n\t}\n\tif (dev)\t\t/* Patch manager device (obsolete) */\n\t\treturn -ENXIO;\n\n\tif(synth_devs[dev] == NULL)\n\t\trequest_module(\"synth0\");\n\n\tif (mode == OPEN_READ)\n\t{\n\t\tif (!num_midis)\n\t\t{\n\t\t\t/*printk(\"Sequencer: No MIDI devices. Input not possible\\n\");*/\n\t\t\tsequencer_busy = 0;\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\tif (sequencer_busy)\n\t{\n\t\treturn -EBUSY;\n\t}\n\tsequencer_busy = 1;\n\tobsolete_api_used = 0;\n\n\tmax_mididev = num_midis;\n\tmax_synthdev = num_synths;\n\tpre_event_timeout = MAX_SCHEDULE_TIMEOUT;\n\tseq_mode = SEQ_1;\n\n\tif (pending_timer != -1)\n\t{\n\t\ttmr_no = pending_timer;\n\t\tpending_timer = -1;\n\t}\n\tif (tmr_no == -1)\t/* Not selected yet */\n\t{\n\t\tint i, best;\n\n\t\tbest = -1;\n\t\tfor (i = 0; i < num_sound_timers; i++)\n\t\t\tif (sound_timer_devs[i] && sound_timer_devs[i]->priority > best)\n\t\t\t{\n\t\t\t\ttmr_no = i;\n\t\t\t\tbest = sound_timer_devs[i]->priority;\n\t\t\t}\n\t\tif (tmr_no == -1)\t/* Should not be */\n\t\t\ttmr_no = 0;\n\t}\n\ttmr = sound_timer_devs[tmr_no];\n\n\tif (level == 2)\n\t{\n\t\tif (tmr == NULL)\n\t\t{\n\t\t\t/*printk(\"sequencer: No timer for level 2\\n\");*/\n\t\t\tsequencer_busy = 0;\n\t\t\treturn -ENXIO;\n\t\t}\n\t\tsetup_mode2();\n\t}\n\tif (!max_synthdev && !max_mididev)\n\t{\n\t\tsequencer_busy=0;\n\t\treturn -ENXIO;\n\t}\n\n\tsynth_open_mask = 0;\n\n\tfor (i = 0; i < max_mididev; i++)\n\t{\n\t\tmidi_opened[i] = 0;\n\t\tmidi_written[i] = 0;\n\t}\n\n\tfor (i = 0; i < max_synthdev; i++)\n\t{\n\t\tif (synth_devs[i]==NULL)\n\t\t\tcontinue;\n\n\t\tif (!try_module_get(synth_devs[i]->owner))\n\t\t\tcontinue;\n\n\t\tif ((tmp = synth_devs[i]->open(i, mode)) < 0)\n\t\t{\n\t\t\tprintk(KERN_WARNING \"Sequencer: Warning! Cannot open synth device #%d (%d)\\n\", i, tmp);\n\t\t\tif (synth_devs[i]->midi_dev)\n\t\t\t\tprintk(KERN_WARNING \"(Maps to MIDI dev #%d)\\n\", synth_devs[i]->midi_dev);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsynth_open_mask |= (1 << i);\n\t\t\tif (synth_devs[i]->midi_dev)\n\t\t\t\tmidi_opened[synth_devs[i]->midi_dev] = 1;\n\t\t}\n\t}\n\n\tseq_time = jiffies;\n\n\tprev_input_time = 0;\n\tprev_event_time = 0;\n\n\tif (seq_mode == SEQ_1 && (mode == OPEN_READ || mode == OPEN_READWRITE))\n\t{\n\t\t/*\n\t\t * Initialize midi input devices\n\t\t */\n\n\t\tfor (i = 0; i < max_mididev; i++)\n\t\t\tif (!midi_opened[i] && midi_devs[i])\n\t\t\t{\n\t\t\t\tif (!try_module_get(midi_devs[i]->owner))\n\t\t\t\t\tcontinue;\n\t\n\t\t\t\tif ((retval = midi_devs[i]->open(i, mode,\n\t\t\t\t\tsequencer_midi_input, sequencer_midi_output)) >= 0)\n\t\t\t\t{\n\t\t\t\t\tmidi_opened[i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\tif (seq_mode == SEQ_2) {\n\t\tif (try_module_get(tmr->owner))\n\t\t\ttmr->open(tmr_no, seq_mode);\n\t}\n\n \tinit_waitqueue_head(&seq_sleeper);\n \tinit_waitqueue_head(&midi_sleeper);\n\toutput_threshold = SEQ_MAX_QUEUE / 2;\n\n\treturn 0;\n}\n\nstatic void seq_drain_midi_queues(void)\n{\n\tint i, n;\n\n\t/*\n\t * Give the Midi drivers time to drain their output queues\n\t */\n\n\tn = 1;\n\n\twhile (!signal_pending(current) && n)\n\t{\n\t\tn = 0;\n\n\t\tfor (i = 0; i < max_mididev; i++)\n\t\t\tif (midi_opened[i] && midi_written[i])\n\t\t\t\tif (midi_devs[i]->buffer_status != NULL)\n\t\t\t\t\tif (midi_devs[i]->buffer_status(i))\n\t\t\t\t\t\tn++;\n\n\t\t/*\n\t\t * Let's have a delay\n\t\t */\n\n \t\tif (n)\n \t\t\tinterruptible_sleep_on_timeout(&seq_sleeper,\n\t\t\t\t\t\t       HZ/10);\n\t}\n}\n\nvoid sequencer_release(int dev, struct file *file)\n{\n\tint i;\n\tint mode = translate_mode(file);\n\n\tdev = dev >> 4;\n\n\tDEB(printk(\"sequencer_release(dev=%d)\\n\", dev));\n\n\t/*\n\t * Wait until the queue is empty (if we don't have nonblock)\n\t */\n\n\tif (mode != OPEN_READ && !(file->f_flags & O_NONBLOCK))\n\t{\n\t\twhile (!signal_pending(current) && qlen > 0)\n\t\t{\n  \t\t\tseq_sync();\n \t\t\tinterruptible_sleep_on_timeout(&seq_sleeper,\n\t\t\t\t\t\t       3*HZ);\n \t\t\t/* Extra delay */\n\t\t}\n\t}\n\n\tif (mode != OPEN_READ)\n\t\tseq_drain_midi_queues();\t/*\n\t\t\t\t\t\t * Ensure the output queues are empty\n\t\t\t\t\t\t */\n\tseq_reset();\n\tif (mode != OPEN_READ)\n\t\tseq_drain_midi_queues();\t/*\n\t\t\t\t\t\t * Flush the all notes off messages\n\t\t\t\t\t\t */\n\n\tfor (i = 0; i < max_synthdev; i++)\n\t{\n\t\tif (synth_open_mask & (1 << i))\t/*\n\t\t\t\t\t\t * Actually opened\n\t\t\t\t\t\t */\n\t\t\tif (synth_devs[i])\n\t\t\t{\n\t\t\t\tsynth_devs[i]->close(i);\n\n\t\t\t\tmodule_put(synth_devs[i]->owner);\n\n\t\t\t\tif (synth_devs[i]->midi_dev)\n\t\t\t\t\tmidi_opened[synth_devs[i]->midi_dev] = 0;\n\t\t\t}\n\t}\n\n\tfor (i = 0; i < max_mididev; i++)\n\t{\n\t\tif (midi_opened[i]) {\n\t\t\tmidi_devs[i]->close(i);\n\t\t\tmodule_put(midi_devs[i]->owner);\n\t\t}\n\t}\n\n\tif (seq_mode == SEQ_2) {\n\t\ttmr->close(tmr_no);\n\t\tmodule_put(tmr->owner);\n\t}\n\n\tif (obsolete_api_used)\n\t\tprintk(KERN_WARNING \"/dev/music: Obsolete (4 byte) API was used by %s\\n\", current->comm);\n\tsequencer_busy = 0;\n}\n\nstatic int seq_sync(void)\n{\n\tif (qlen && !seq_playing && !signal_pending(current))\n\t\tseq_startplay();\n\n \tif (qlen > 0)\n \t\tinterruptible_sleep_on_timeout(&seq_sleeper, HZ);\n\treturn qlen;\n}\n\nstatic void midi_outc(int dev, unsigned char data)\n{\n\t/*\n\t * NOTE! Calls sleep(). Don't call this from interrupt.\n\t */\n\n\tint n;\n\tunsigned long flags;\n\n\t/*\n\t * This routine sends one byte to the Midi channel.\n\t * If the output FIFO is full, it waits until there\n\t * is space in the queue\n\t */\n\n\tn = 3 * HZ;\t\t/* Timeout */\n\n\tspin_lock_irqsave(&lock,flags);\n \twhile (n && !midi_devs[dev]->outputc(dev, data)) {\n \t\tinterruptible_sleep_on_timeout(&seq_sleeper, HZ/25);\n  \t\tn--;\n  \t}\n\tspin_unlock_irqrestore(&lock,flags);\n}\n\nstatic void seq_reset(void)\n{\n\t/*\n\t * NOTE! Calls sleep(). Don't call this from interrupt.\n\t */\n\n\tint i;\n\tint chn;\n\tunsigned long flags;\n\n\tsound_stop_timer();\n\n\tseq_time = jiffies;\n\tprev_input_time = 0;\n\tprev_event_time = 0;\n\n\tqlen = qhead = qtail = 0;\n\tiqlen = iqhead = iqtail = 0;\n\n\tfor (i = 0; i < max_synthdev; i++)\n\t\tif (synth_open_mask & (1 << i))\n\t\t\tif (synth_devs[i])\n\t\t\t\tsynth_devs[i]->reset(i);\n\n\tif (seq_mode == SEQ_2)\n\t{\n\t\tfor (chn = 0; chn < 16; chn++)\n\t\t\tfor (i = 0; i < max_synthdev; i++)\n\t\t\t\tif (synth_open_mask & (1 << i))\n\t\t\t\t\tif (synth_devs[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tsynth_devs[i]->controller(i, chn, 123, 0);\t/* All notes off */\n\t\t\t\t\t\tsynth_devs[i]->controller(i, chn, 121, 0);\t/* Reset all ctl */\n\t\t\t\t\t\tsynth_devs[i]->bender(i, chn, 1 << 13);\t/* Bender off */\n\t\t\t\t\t}\n\t}\n\telse\t/* seq_mode == SEQ_1 */\n\t{\n\t\tfor (i = 0; i < max_mididev; i++)\n\t\t\tif (midi_written[i])\t/*\n\t\t\t\t\t\t * Midi used. Some notes may still be playing\n\t\t\t\t\t\t */\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t *      Sending just a ACTIVE SENSING message should be enough to stop all\n\t\t\t\t *      playing notes. Since there are devices not recognizing the\n\t\t\t\t *      active sensing, we have to send some all notes off messages also.\n\t\t\t\t */\n\t\t\t\tmidi_outc(i, 0xfe);\n\n\t\t\t\tfor (chn = 0; chn < 16; chn++)\n\t\t\t\t{\n\t\t\t\t\tmidi_outc(i, (unsigned char) (0xb0 + (chn & 0x0f)));\t\t/* control change */\n\t\t\t\t\tmidi_outc(i, 0x7b);\t/* All notes off */\n\t\t\t\t\tmidi_outc(i, 0);\t/* Dummy parameter */\n\t\t\t\t}\n\n\t\t\t\tmidi_devs[i]->close(i);\n\n\t\t\t\tmidi_written[i] = 0;\n\t\t\t\tmidi_opened[i] = 0;\n\t\t\t}\n\t}\n\n\tseq_playing = 0;\n\n\tspin_lock_irqsave(&lock,flags);\n\n\tif (waitqueue_active(&seq_sleeper)) {\n\t\t/*      printk( \"Sequencer Warning: Unexpected sleeping process - Waking up\\n\"); */\n\t\twake_up(&seq_sleeper);\n\t}\n\tspin_unlock_irqrestore(&lock,flags);\n}\n\nstatic void seq_panic(void)\n{\n\t/*\n\t * This routine is called by the application in case the user\n\t * wants to reset the system to the default state.\n\t */\n\n\tseq_reset();\n\n\t/*\n\t * Since some of the devices don't recognize the active sensing and\n\t * all notes off messages, we have to shut all notes manually.\n\t *\n\t *      TO BE IMPLEMENTED LATER\n\t */\n\n\t/*\n\t * Also return the controllers to their default states\n\t */\n}\n\nint sequencer_ioctl(int dev, struct file *file, unsigned int cmd, void __user *arg)\n{\n\tint midi_dev, orig_dev, val, err;\n\tint mode = translate_mode(file);\n\tstruct synth_info inf;\n\tstruct seq_event_rec event_rec;\n\tunsigned long flags;\n\tint __user *p = arg;\n\n\torig_dev = dev = dev >> 4;\n\n\tswitch (cmd)\n\t{\n\t\tcase SNDCTL_TMR_TIMEBASE:\n\t\tcase SNDCTL_TMR_TEMPO:\n\t\tcase SNDCTL_TMR_START:\n\t\tcase SNDCTL_TMR_STOP:\n\t\tcase SNDCTL_TMR_CONTINUE:\n\t\tcase SNDCTL_TMR_METRONOME:\n\t\tcase SNDCTL_TMR_SOURCE:\n\t\t\tif (seq_mode != SEQ_2)\n\t\t\t\treturn -EINVAL;\n\t\t\treturn tmr->ioctl(tmr_no, cmd, arg);\n\n\t\tcase SNDCTL_TMR_SELECT:\n\t\t\tif (seq_mode != SEQ_2)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (get_user(pending_timer, p))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (pending_timer < 0 || pending_timer >= num_sound_timers || sound_timer_devs[pending_timer] == NULL)\n\t\t\t{\n\t\t\t\tpending_timer = -1;\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tval = pending_timer;\n\t\t\tbreak;\n\n\t\tcase SNDCTL_SEQ_PANIC:\n\t\t\tseq_panic();\n\t\t\treturn -EINVAL;\n\n\t\tcase SNDCTL_SEQ_SYNC:\n\t\t\tif (mode == OPEN_READ)\n\t\t\t\treturn 0;\n\t\t\twhile (qlen > 0 && !signal_pending(current))\n\t\t\t\tseq_sync();\n\t\t\treturn qlen ? -EINTR : 0;\n\n\t\tcase SNDCTL_SEQ_RESET:\n\t\t\tseq_reset();\n\t\t\treturn 0;\n\n\t\tcase SNDCTL_SEQ_TESTMIDI:\n\t\t\tif (__get_user(midi_dev, p))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (midi_dev < 0 || midi_dev >= max_mididev || !midi_devs[midi_dev])\n\t\t\t\treturn -ENXIO;\n\n\t\t\tif (!midi_opened[midi_dev] &&\n\t\t\t\t(err = midi_devs[midi_dev]->open(midi_dev, mode, sequencer_midi_input,\n\t\t\t\t\t\t     sequencer_midi_output)) < 0)\n\t\t\t\treturn err;\n\t\t\tmidi_opened[midi_dev] = 1;\n\t\t\treturn 0;\n\n\t\tcase SNDCTL_SEQ_GETINCOUNT:\n\t\t\tif (mode == OPEN_WRITE)\n\t\t\t\treturn 0;\n\t\t\tval = iqlen;\n\t\t\tbreak;\n\n\t\tcase SNDCTL_SEQ_GETOUTCOUNT:\n\t\t\tif (mode == OPEN_READ)\n\t\t\t\treturn 0;\n\t\t\tval = SEQ_MAX_QUEUE - qlen;\n\t\t\tbreak;\n\n\t\tcase SNDCTL_SEQ_GETTIME:\n\t\t\tif (seq_mode == SEQ_2)\n\t\t\t\treturn tmr->ioctl(tmr_no, cmd, arg);\n\t\t\tval = jiffies - seq_time;\n\t\t\tbreak;\n\n\t\tcase SNDCTL_SEQ_CTRLRATE:\n\t\t\t/*\n\t\t\t * If *arg == 0, just return the current rate\n\t\t\t */\n\t\t\tif (seq_mode == SEQ_2)\n\t\t\t\treturn tmr->ioctl(tmr_no, cmd, arg);\n\n\t\t\tif (get_user(val, p))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (val != 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tval = HZ;\n\t\t\tbreak;\n\n\t\tcase SNDCTL_SEQ_RESETSAMPLES:\n\t\tcase SNDCTL_SYNTH_REMOVESAMPLE:\n\t\tcase SNDCTL_SYNTH_CONTROL:\n\t\t\tif (get_user(dev, p))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (dev < 0 || dev >= num_synths || synth_devs[dev] == NULL)\n\t\t\t\treturn -ENXIO;\n\t\t\tif (!(synth_open_mask & (1 << dev)) && !orig_dev)\n\t\t\t\treturn -EBUSY;\n\t\t\treturn synth_devs[dev]->ioctl(dev, cmd, arg);\n\n\t\tcase SNDCTL_SEQ_NRSYNTHS:\n\t\t\tval = max_synthdev;\n\t\t\tbreak;\n\n\t\tcase SNDCTL_SEQ_NRMIDIS:\n\t\t\tval = max_mididev;\n\t\t\tbreak;\n\n\t\tcase SNDCTL_SYNTH_MEMAVL:\n\t\t\tif (get_user(dev, p))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (dev < 0 || dev >= num_synths || synth_devs[dev] == NULL)\n\t\t\t\treturn -ENXIO;\n\t\t\tif (!(synth_open_mask & (1 << dev)) && !orig_dev)\n\t\t\t\treturn -EBUSY;\n\t\t\tval = synth_devs[dev]->ioctl(dev, cmd, arg);\n\t\t\tbreak;\n\n\t\tcase SNDCTL_FM_4OP_ENABLE:\n\t\t\tif (get_user(dev, p))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (dev < 0 || dev >= num_synths || synth_devs[dev] == NULL)\n\t\t\t\treturn -ENXIO;\n\t\t\tif (!(synth_open_mask & (1 << dev)))\n\t\t\t\treturn -ENXIO;\n\t\t\tsynth_devs[dev]->ioctl(dev, cmd, arg);\n\t\t\treturn 0;\n\n\t\tcase SNDCTL_SYNTH_INFO:\n\t\t\tif (get_user(dev, &((struct synth_info __user *)arg)->device))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (dev < 0 || dev >= max_synthdev)\n\t\t\t\treturn -ENXIO;\n\t\t\tif (!(synth_open_mask & (1 << dev)) && !orig_dev)\n\t\t\t\treturn -EBUSY;\n\t\t\treturn synth_devs[dev]->ioctl(dev, cmd, arg);\n\n\t\t/* Like SYNTH_INFO but returns ID in the name field */\n\t\tcase SNDCTL_SYNTH_ID:\n\t\t\tif (get_user(dev, &((struct synth_info __user *)arg)->device))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (dev < 0 || dev >= max_synthdev)\n\t\t\t\treturn -ENXIO;\n\t\t\tif (!(synth_open_mask & (1 << dev)) && !orig_dev)\n\t\t\t\treturn -EBUSY;\n\t\t\tmemcpy(&inf, synth_devs[dev]->info, sizeof(inf));\n\t\t\tstrlcpy(inf.name, synth_devs[dev]->id, sizeof(inf.name));\n\t\t\tinf.device = dev;\n\t\t\treturn copy_to_user(arg, &inf, sizeof(inf))?-EFAULT:0;\n\n\t\tcase SNDCTL_SEQ_OUTOFBAND:\n\t\t\tif (copy_from_user(&event_rec, arg, sizeof(event_rec)))\n\t\t\t\treturn -EFAULT;\n\t\t\tspin_lock_irqsave(&lock,flags);\n\t\t\tplay_event(event_rec.arr);\n\t\t\tspin_unlock_irqrestore(&lock,flags);\n\t\t\treturn 0;\n\n\t\tcase SNDCTL_MIDI_INFO:\n\t\t\tif (get_user(dev, &((struct midi_info __user *)arg)->device))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (dev < 0 || dev >= max_mididev || !midi_devs[dev])\n\t\t\t\treturn -ENXIO;\n\t\t\tmidi_devs[dev]->info.device = dev;\n\t\t\treturn copy_to_user(arg, &midi_devs[dev]->info, sizeof(struct midi_info))?-EFAULT:0;\n\n\t\tcase SNDCTL_SEQ_THRESHOLD:\n\t\t\tif (get_user(val, p))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (val < 1)\n\t\t\t\tval = 1;\n\t\t\tif (val >= SEQ_MAX_QUEUE)\n\t\t\t\tval = SEQ_MAX_QUEUE - 1;\n\t\t\toutput_threshold = val;\n\t\t\treturn 0;\n\n\t\tcase SNDCTL_MIDI_PRETIME:\n\t\t\tif (get_user(val, p))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (val < 0)\n\t\t\t\tval = 0;\n\t\t\tval = (HZ * val) / 10;\n\t\t\tpre_event_timeout = val;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (mode == OPEN_READ)\n\t\t\t\treturn -EIO;\n\t\t\tif (!synth_devs[0])\n\t\t\t\treturn -ENXIO;\n\t\t\tif (!(synth_open_mask & (1 << 0)))\n\t\t\t\treturn -ENXIO;\n\t\t\tif (!synth_devs[0]->ioctl)\n\t\t\t\treturn -EINVAL;\n\t\t\treturn synth_devs[0]->ioctl(0, cmd, arg);\n\t}\n\treturn put_user(val, p);\n}\n\n/* No kernel lock - we're using the global irq lock here */\nunsigned int sequencer_poll(int dev, struct file *file, poll_table * wait)\n{\n\tunsigned long flags;\n\tunsigned int mask = 0;\n\n\tdev = dev >> 4;\n\n\tspin_lock_irqsave(&lock,flags);\n\t/* input */\n\tpoll_wait(file, &midi_sleeper, wait);\n\tif (iqlen)\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\t/* output */\n\tpoll_wait(file, &seq_sleeper, wait);\n\tif ((SEQ_MAX_QUEUE - qlen) >= output_threshold)\n\t\tmask |= POLLOUT | POLLWRNORM;\n\tspin_unlock_irqrestore(&lock,flags);\n\treturn mask;\n}\n\n\nvoid sequencer_timer(unsigned long dummy)\n{\n\tseq_startplay();\n}\nEXPORT_SYMBOL(sequencer_timer);\n\nint note_to_freq(int note_num)\n{\n\n\t/*\n\t * This routine converts a midi note to a frequency (multiplied by 1000)\n\t */\n\n\tint note, octave, note_freq;\n\tstatic int notes[] =\n\t{\n\t\t261632, 277189, 293671, 311132, 329632, 349232,\n\t\t369998, 391998, 415306, 440000, 466162, 493880\n\t};\n\n#define BASE_OCTAVE\t5\n\n\toctave = note_num / 12;\n\tnote = note_num % 12;\n\n\tnote_freq = notes[note];\n\n\tif (octave < BASE_OCTAVE)\n\t\tnote_freq >>= (BASE_OCTAVE - octave);\n\telse if (octave > BASE_OCTAVE)\n\t\tnote_freq <<= (octave - BASE_OCTAVE);\n\n\t/*\n\t * note_freq >>= 1;\n\t */\n\n\treturn note_freq;\n}\nEXPORT_SYMBOL(note_to_freq);\n\nunsigned long compute_finetune(unsigned long base_freq, int bend, int range,\n\t\t int vibrato_cents)\n{\n\tunsigned long amount;\n\tint negative, semitones, cents, multiplier = 1;\n\n\tif (!bend)\n\t\treturn base_freq;\n\tif (!range)\n\t\treturn base_freq;\n\n\tif (!base_freq)\n\t\treturn base_freq;\n\n\tif (range >= 8192)\n\t\trange = 8192;\n\n\tbend = bend * range / 8192;\t/* Convert to cents */\n\tbend += vibrato_cents;\n\n\tif (!bend)\n\t\treturn base_freq;\n\n\tnegative = bend < 0 ? 1 : 0;\n\n\tif (bend < 0)\n\t\tbend *= -1;\n\tif (bend > range)\n\t\tbend = range;\n\n\t/*\n\t   if (bend > 2399)\n\t   bend = 2399;\n\t */\n\twhile (bend > 2399)\n\t{\n\t\tmultiplier *= 4;\n\t\tbend -= 2400;\n\t}\n\n\tsemitones = bend / 100;\n\tcents = bend % 100;\n\n\tamount = (int) (semitone_tuning[semitones] * multiplier * cent_tuning[cents]) / 10000;\n\n\tif (negative)\n\t\treturn (base_freq * 10000) / amount;\t/* Bend down */\n\telse\n\t\treturn (base_freq * amount) / 10000;\t/* Bend up */\n}\nEXPORT_SYMBOL(compute_finetune);\n\nvoid sequencer_init(void)\n{\n\tif (sequencer_ok)\n\t\treturn;\n\tqueue = vmalloc(SEQ_MAX_QUEUE * EV_SZ);\n\tif (queue == NULL)\n\t{\n\t\tprintk(KERN_ERR \"sequencer: Can't allocate memory for sequencer output queue\\n\");\n\t\treturn;\n\t}\n\tiqueue = vmalloc(SEQ_MAX_QUEUE * IEV_SZ);\n\tif (iqueue == NULL)\n\t{\n\t\tprintk(KERN_ERR \"sequencer: Can't allocate memory for sequencer input queue\\n\");\n\t\tvfree(queue);\n\t\treturn;\n\t}\n\tsequencer_ok = 1;\n}\nEXPORT_SYMBOL(sequencer_init);\n\nvoid sequencer_unload(void)\n{\n\tvfree(queue);\n\tvfree(iqueue);\n\tqueue = iqueue = NULL;\n}\n"], "filenames": ["sound/oss/dev_table.h", "sound/oss/midi_synth.c", "sound/oss/midi_synth.h", "sound/oss/opl3.c", "sound/oss/sequencer.c"], "buggy_code_start_loc": [274, 479, 11, 823, 244], "buggy_code_end_loc": [275, 521, 12, 838, 245], "fixing_code_start_loc": [274, 479, 11, 823, 244], "fixing_code_end_loc": [275, 517, 12, 834, 245], "type": "CWE-189", "message": "Integer underflow in the Open Sound System (OSS) subsystem in the Linux kernel before 2.6.39 on unspecified non-x86 platforms allows local users to cause a denial of service (memory corruption) by leveraging write access to /dev/sequencer.", "other": {"cve": {"id": "CVE-2011-1476", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-21T23:55:02.193", "lastModified": "2023-02-13T01:19:10.203", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Integer underflow in the Open Sound System (OSS) subsystem in the Linux kernel before 2.6.39 on unspecified non-x86 platforms allows local users to cause a denial of service (memory corruption) by leveraging write access to /dev/sequencer."}, {"lang": "es", "value": "Un desbordamiento de entero en el subsistema 'Open Sound System' (OSS) del kernel de Linux en versiones anteriores a v2.6.39 en plataformas no-x86 permite a usuarios locales provocar una denegaci\u00f3n de servicio (corrupci\u00f3n de memoria) mediante el aprovechamiento del acceso de escritura a /dev/sequencer."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:H/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 1.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-189"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.38.8", "matchCriteriaId": "57A0A2B0-3B9F-40C2-8C7A-CD9590B51315"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:*:*:*:*:*:*:*", "matchCriteriaId": "7462DB6D-E0A6-4DBB-8E21-66B875184FFC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc1:*:*:*:*:*:*", "matchCriteriaId": "2DDCB342-4F5F-4BF1-9624-882BBC57330D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc2:*:*:*:*:*:*", "matchCriteriaId": "C3AB4113-BF83-4587-8A85-0E4FECEE7D9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc3:*:*:*:*:*:*", "matchCriteriaId": "4B57F5AD-A697-4090-89B9-81BC12993A1A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc4:*:*:*:*:*:*", "matchCriteriaId": "CA141BCB-A705-4DF5-9EED-746B62C86111"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc5:*:*:*:*:*:*", "matchCriteriaId": "E9ECE134-58A3-4B9D-B9B3-F836C0EDD64C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc6:*:*:*:*:*:*", "matchCriteriaId": "56186720-6B4C-4D71-85C5-7EAC5C5D84A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc7:*:*:*:*:*:*", "matchCriteriaId": "9BBB4630-CBED-43B9-B203-BE65BBF011AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc8:*:*:*:*:*:*", "matchCriteriaId": "FD375A78-63D7-441A-9FB0-7BC878AB4EDD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.1:*:*:*:*:*:*:*", "matchCriteriaId": "A5BEFFDD-02BB-4A05-8372-891DBDB9AC5A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.2:*:*:*:*:*:*:*", "matchCriteriaId": "766E193D-819C-42EA-8411-AE0013AC15FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.3:*:*:*:*:*:*:*", "matchCriteriaId": "3B39B6AF-6A83-48C2-BED2-79228F8513A6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.4:*:*:*:*:*:*:*", "matchCriteriaId": "CD8A68D1-DFE9-4ADB-9FB8-4D69AB4CAFF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.5:*:*:*:*:*:*:*", "matchCriteriaId": "0D6EF951-AF15-4C30-A3A5-3392AA61813C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.6:*:*:*:*:*:*:*", "matchCriteriaId": "15154FA0-65DC-4855-AC70-3ACF92313F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.7:*:*:*:*:*:*:*", "matchCriteriaId": "F4B3A9F4-A61F-4919-A173-3E459F0C5AF8"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.39", "source": "secalert@redhat.com"}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=b769f49463711205d57286e64cf535ed4daf59e9", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00020.html", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/03/25/1", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/b769f49463711205d57286e64cf535ed4daf59e9", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/b769f49463711205d57286e64cf535ed4daf59e9"}}