{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * normal.c:\tContains the main routine for processing characters in command\n *\t\tmode.  Communicates closely with the code in ops.c to handle\n *\t\tthe operators.\n */\n\n#include \"vim.h\"\n\nstatic int\tVIsual_mode_orig = NUL;\t\t// saved Visual mode\n\n#ifdef FEAT_EVAL\nstatic void\tset_vcount_ca(cmdarg_T *cap, int *set_prevcount);\n#endif\nstatic int\tnv_compare(const void *s1, const void *s2);\nstatic void\tunshift_special(cmdarg_T *cap);\n#ifdef FEAT_CMDL_INFO\nstatic void\tdel_from_showcmd(int);\n#endif\n\n/*\n * nv_*(): functions called to handle Normal and Visual mode commands.\n * n_*(): functions called to handle Normal mode commands.\n * v_*(): functions called to handle Visual mode commands.\n */\nstatic void\tnv_ignore(cmdarg_T *cap);\nstatic void\tnv_nop(cmdarg_T *cap);\nstatic void\tnv_error(cmdarg_T *cap);\nstatic void\tnv_help(cmdarg_T *cap);\nstatic void\tnv_addsub(cmdarg_T *cap);\nstatic void\tnv_page(cmdarg_T *cap);\nstatic void\tnv_zet(cmdarg_T *cap);\n#ifdef FEAT_GUI\nstatic void\tnv_ver_scrollbar(cmdarg_T *cap);\nstatic void\tnv_hor_scrollbar(cmdarg_T *cap);\n#endif\n#ifdef FEAT_GUI_TABLINE\nstatic void\tnv_tabline(cmdarg_T *cap);\nstatic void\tnv_tabmenu(cmdarg_T *cap);\n#endif\nstatic void\tnv_exmode(cmdarg_T *cap);\nstatic void\tnv_colon(cmdarg_T *cap);\nstatic void\tnv_ctrlg(cmdarg_T *cap);\nstatic void\tnv_ctrlh(cmdarg_T *cap);\nstatic void\tnv_clear(cmdarg_T *cap);\nstatic void\tnv_ctrlo(cmdarg_T *cap);\nstatic void\tnv_hat(cmdarg_T *cap);\nstatic void\tnv_Zet(cmdarg_T *cap);\nstatic void\tnv_ident(cmdarg_T *cap);\nstatic void\tnv_tagpop(cmdarg_T *cap);\nstatic void\tnv_scroll(cmdarg_T *cap);\nstatic void\tnv_right(cmdarg_T *cap);\nstatic void\tnv_left(cmdarg_T *cap);\nstatic void\tnv_up(cmdarg_T *cap);\nstatic void\tnv_down(cmdarg_T *cap);\nstatic void\tnv_end(cmdarg_T *cap);\nstatic void\tnv_dollar(cmdarg_T *cap);\nstatic void\tnv_search(cmdarg_T *cap);\nstatic void\tnv_next(cmdarg_T *cap);\nstatic int\tnormal_search(cmdarg_T *cap, int dir, char_u *pat, int opt, int *wrapped);\nstatic void\tnv_csearch(cmdarg_T *cap);\nstatic void\tnv_brackets(cmdarg_T *cap);\nstatic void\tnv_percent(cmdarg_T *cap);\nstatic void\tnv_brace(cmdarg_T *cap);\nstatic void\tnv_mark(cmdarg_T *cap);\nstatic void\tnv_findpar(cmdarg_T *cap);\nstatic void\tnv_undo(cmdarg_T *cap);\nstatic void\tnv_kundo(cmdarg_T *cap);\nstatic void\tnv_Replace(cmdarg_T *cap);\nstatic void\tnv_replace(cmdarg_T *cap);\nstatic void\tnv_cursormark(cmdarg_T *cap, int flag, pos_T *pos);\nstatic void\tv_visop(cmdarg_T *cap);\nstatic void\tnv_subst(cmdarg_T *cap);\nstatic void\tnv_abbrev(cmdarg_T *cap);\nstatic void\tnv_optrans(cmdarg_T *cap);\nstatic void\tnv_gomark(cmdarg_T *cap);\nstatic void\tnv_pcmark(cmdarg_T *cap);\nstatic void\tnv_regname(cmdarg_T *cap);\nstatic void\tnv_visual(cmdarg_T *cap);\nstatic void\tn_start_visual_mode(int c);\nstatic void\tnv_window(cmdarg_T *cap);\nstatic void\tnv_suspend(cmdarg_T *cap);\nstatic void\tnv_g_cmd(cmdarg_T *cap);\nstatic void\tnv_dot(cmdarg_T *cap);\nstatic void\tnv_redo(cmdarg_T *cap);\nstatic void\tnv_Undo(cmdarg_T *cap);\nstatic void\tnv_tilde(cmdarg_T *cap);\nstatic void\tnv_operator(cmdarg_T *cap);\n#ifdef FEAT_EVAL\nstatic void\tset_op_var(int optype);\n#endif\nstatic void\tnv_lineop(cmdarg_T *cap);\nstatic void\tnv_home(cmdarg_T *cap);\nstatic void\tnv_pipe(cmdarg_T *cap);\nstatic void\tnv_bck_word(cmdarg_T *cap);\nstatic void\tnv_wordcmd(cmdarg_T *cap);\nstatic void\tnv_beginline(cmdarg_T *cap);\nstatic void\tadjust_cursor(oparg_T *oap);\nstatic void\tadjust_for_sel(cmdarg_T *cap);\nstatic void\tnv_select(cmdarg_T *cap);\nstatic void\tnv_goto(cmdarg_T *cap);\nstatic void\tnv_normal(cmdarg_T *cap);\nstatic void\tnv_esc(cmdarg_T *oap);\nstatic void\tnv_edit(cmdarg_T *cap);\nstatic void\tinvoke_edit(cmdarg_T *cap, int repl, int cmd, int startln);\n#ifdef FEAT_TEXTOBJ\nstatic void\tnv_object(cmdarg_T *cap);\n#endif\nstatic void\tnv_record(cmdarg_T *cap);\nstatic void\tnv_at(cmdarg_T *cap);\nstatic void\tnv_halfpage(cmdarg_T *cap);\nstatic void\tnv_join(cmdarg_T *cap);\nstatic void\tnv_put(cmdarg_T *cap);\nstatic void\tnv_put_opt(cmdarg_T *cap, int fix_indent);\nstatic void\tnv_open(cmdarg_T *cap);\n#ifdef FEAT_NETBEANS_INTG\nstatic void\tnv_nbcmd(cmdarg_T *cap);\n#endif\n#ifdef FEAT_DND\nstatic void\tnv_drop(cmdarg_T *cap);\n#endif\nstatic void\tnv_cursorhold(cmdarg_T *cap);\n\nstatic char *e_noident = N_(\"E349: No identifier under cursor\");\n\n/*\n * Function to be called for a Normal or Visual mode command.\n * The argument is a cmdarg_T.\n */\ntypedef void (*nv_func_T)(cmdarg_T *cap);\n\n// Values for cmd_flags.\n#define NV_NCH\t    0x01\t  // may need to get a second char\n#define NV_NCH_NOP  (0x02|NV_NCH) // get second char when no operator pending\n#define NV_NCH_ALW  (0x04|NV_NCH) // always get a second char\n#define NV_LANG\t    0x08\t// second char needs language adjustment\n\n#define NV_SS\t    0x10\t// may start selection\n#define NV_SSS\t    0x20\t// may start selection with shift modifier\n#define NV_STS\t    0x40\t// may stop selection without shift modif.\n#define NV_RL\t    0x80\t// 'rightleft' modifies command\n#define NV_KEEPREG  0x100\t// don't clear regname\n#define NV_NCW\t    0x200\t// not allowed in command-line window\n\n/*\n * Generally speaking, every Normal mode command should either clear any\n * pending operator (with *clearop*()), or set the motion type variable\n * oap->motion_type.\n *\n * When a cursor motion command is made, it is marked as being a character or\n * line oriented motion.  Then, if an operator is in effect, the operation\n * becomes character or line oriented accordingly.\n */\n\n/*\n * This table contains one entry for every Normal or Visual mode command.\n * The order doesn't matter, init_normal_cmds() will create a sorted index.\n * It is faster when all keys from zero to '~' are present.\n */\nstatic const struct nv_cmd\n{\n    int\t\tcmd_char;\t// (first) command character\n    nv_func_T   cmd_func;\t// function for this command\n    short_u\tcmd_flags;\t// NV_ flags\n    short\tcmd_arg;\t// value for ca.arg\n} nv_cmds[] =\n{\n    {NUL,\tnv_error,\t0,\t\t\t0},\n    {Ctrl_A,\tnv_addsub,\t0,\t\t\t0},\n    {Ctrl_B,\tnv_page,\tNV_STS,\t\t\tBACKWARD},\n    {Ctrl_C,\tnv_esc,\t\t0,\t\t\tTRUE},\n    {Ctrl_D,\tnv_halfpage,\t0,\t\t\t0},\n    {Ctrl_E,\tnv_scroll_line,\t0,\t\t\tTRUE},\n    {Ctrl_F,\tnv_page,\tNV_STS,\t\t\tFORWARD},\n    {Ctrl_G,\tnv_ctrlg,\t0,\t\t\t0},\n    {Ctrl_H,\tnv_ctrlh,\t0,\t\t\t0},\n    {Ctrl_I,\tnv_pcmark,\t0,\t\t\t0},\n    {NL,\tnv_down,\t0,\t\t\tFALSE},\n    {Ctrl_K,\tnv_error,\t0,\t\t\t0},\n    {Ctrl_L,\tnv_clear,\t0,\t\t\t0},\n    {CAR,\tnv_down,\t0,\t\t\tTRUE},\n    {Ctrl_N,\tnv_down,\tNV_STS,\t\t\tFALSE},\n    {Ctrl_O,\tnv_ctrlo,\t0,\t\t\t0},\n    {Ctrl_P,\tnv_up,\t\tNV_STS,\t\t\tFALSE},\n    {Ctrl_Q,\tnv_visual,\t0,\t\t\tFALSE},\n    {Ctrl_R,\tnv_redo,\t0,\t\t\t0},\n    {Ctrl_S,\tnv_ignore,\t0,\t\t\t0},\n    {Ctrl_T,\tnv_tagpop,\tNV_NCW,\t\t\t0},\n    {Ctrl_U,\tnv_halfpage,\t0,\t\t\t0},\n    {Ctrl_V,\tnv_visual,\t0,\t\t\tFALSE},\n    {'V',\tnv_visual,\t0,\t\t\tFALSE},\n    {'v',\tnv_visual,\t0,\t\t\tFALSE},\n    {Ctrl_W,\tnv_window,\t0,\t\t\t0},\n    {Ctrl_X,\tnv_addsub,\t0,\t\t\t0},\n    {Ctrl_Y,\tnv_scroll_line,\t0,\t\t\tFALSE},\n    {Ctrl_Z,\tnv_suspend,\t0,\t\t\t0},\n    {ESC,\tnv_esc,\t\t0,\t\t\tFALSE},\n    {Ctrl_BSL,\tnv_normal,\tNV_NCH_ALW,\t\t0},\n    {Ctrl_RSB,\tnv_ident,\tNV_NCW,\t\t\t0},\n    {Ctrl_HAT,\tnv_hat,\t\tNV_NCW,\t\t\t0},\n    {Ctrl__,\tnv_error,\t0,\t\t\t0},\n    {' ',\tnv_right,\t0,\t\t\t0},\n    {'!',\tnv_operator,\t0,\t\t\t0},\n    {'\"',\tnv_regname,\tNV_NCH_NOP|NV_KEEPREG,\t0},\n    {'#',\tnv_ident,\t0,\t\t\t0},\n    {'$',\tnv_dollar,\t0,\t\t\t0},\n    {'%',\tnv_percent,\t0,\t\t\t0},\n    {'&',\tnv_optrans,\t0,\t\t\t0},\n    {'\\'',\tnv_gomark,\tNV_NCH_ALW,\t\tTRUE},\n    {'(',\tnv_brace,\t0,\t\t\tBACKWARD},\n    {')',\tnv_brace,\t0,\t\t\tFORWARD},\n    {'*',\tnv_ident,\t0,\t\t\t0},\n    {'+',\tnv_down,\t0,\t\t\tTRUE},\n    {',',\tnv_csearch,\t0,\t\t\tTRUE},\n    {'-',\tnv_up,\t\t0,\t\t\tTRUE},\n    {'.',\tnv_dot,\t\tNV_KEEPREG,\t\t0},\n    {'/',\tnv_search,\t0,\t\t\tFALSE},\n    {'0',\tnv_beginline,\t0,\t\t\t0},\n    {'1',\tnv_ignore,\t0,\t\t\t0},\n    {'2',\tnv_ignore,\t0,\t\t\t0},\n    {'3',\tnv_ignore,\t0,\t\t\t0},\n    {'4',\tnv_ignore,\t0,\t\t\t0},\n    {'5',\tnv_ignore,\t0,\t\t\t0},\n    {'6',\tnv_ignore,\t0,\t\t\t0},\n    {'7',\tnv_ignore,\t0,\t\t\t0},\n    {'8',\tnv_ignore,\t0,\t\t\t0},\n    {'9',\tnv_ignore,\t0,\t\t\t0},\n    {':',\tnv_colon,\t0,\t\t\t0},\n    {';',\tnv_csearch,\t0,\t\t\tFALSE},\n    {'<',\tnv_operator,\tNV_RL,\t\t\t0},\n    {'=',\tnv_operator,\t0,\t\t\t0},\n    {'>',\tnv_operator,\tNV_RL,\t\t\t0},\n    {'?',\tnv_search,\t0,\t\t\tFALSE},\n    {'@',\tnv_at,\t\tNV_NCH_NOP,\t\tFALSE},\n    {'A',\tnv_edit,\t0,\t\t\t0},\n    {'B',\tnv_bck_word,\t0,\t\t\t1},\n    {'C',\tnv_abbrev,\tNV_KEEPREG,\t\t0},\n    {'D',\tnv_abbrev,\tNV_KEEPREG,\t\t0},\n    {'E',\tnv_wordcmd,\t0,\t\t\tTRUE},\n    {'F',\tnv_csearch,\tNV_NCH_ALW|NV_LANG,\tBACKWARD},\n    {'G',\tnv_goto,\t0,\t\t\tTRUE},\n    {'H',\tnv_scroll,\t0,\t\t\t0},\n    {'I',\tnv_edit,\t0,\t\t\t0},\n    {'J',\tnv_join,\t0,\t\t\t0},\n    {'K',\tnv_ident,\t0,\t\t\t0},\n    {'L',\tnv_scroll,\t0,\t\t\t0},\n    {'M',\tnv_scroll,\t0,\t\t\t0},\n    {'N',\tnv_next,\t0,\t\t\tSEARCH_REV},\n    {'O',\tnv_open,\t0,\t\t\t0},\n    {'P',\tnv_put,\t\t0,\t\t\t0},\n    {'Q',\tnv_exmode,\tNV_NCW,\t\t\t0},\n    {'R',\tnv_Replace,\t0,\t\t\tFALSE},\n    {'S',\tnv_subst,\tNV_KEEPREG,\t\t0},\n    {'T',\tnv_csearch,\tNV_NCH_ALW|NV_LANG,\tBACKWARD},\n    {'U',\tnv_Undo,\t0,\t\t\t0},\n    {'W',\tnv_wordcmd,\t0,\t\t\tTRUE},\n    {'X',\tnv_abbrev,\tNV_KEEPREG,\t\t0},\n    {'Y',\tnv_abbrev,\tNV_KEEPREG,\t\t0},\n    {'Z',\tnv_Zet,\t\tNV_NCH_NOP|NV_NCW,\t0},\n    {'[',\tnv_brackets,\tNV_NCH_ALW,\t\tBACKWARD},\n    {'\\\\',\tnv_error,\t0,\t\t\t0},\n    {']',\tnv_brackets,\tNV_NCH_ALW,\t\tFORWARD},\n    {'^',\tnv_beginline,\t0,\t\t\tBL_WHITE | BL_FIX},\n    {'_',\tnv_lineop,\t0,\t\t\t0},\n    {'`',\tnv_gomark,\tNV_NCH_ALW,\t\tFALSE},\n    {'a',\tnv_edit,\tNV_NCH,\t\t\t0},\n    {'b',\tnv_bck_word,\t0,\t\t\t0},\n    {'c',\tnv_operator,\t0,\t\t\t0},\n    {'d',\tnv_operator,\t0,\t\t\t0},\n    {'e',\tnv_wordcmd,\t0,\t\t\tFALSE},\n    {'f',\tnv_csearch,\tNV_NCH_ALW|NV_LANG,\tFORWARD},\n    {'g',\tnv_g_cmd,\tNV_NCH_ALW,\t\tFALSE},\n    {'h',\tnv_left,\tNV_RL,\t\t\t0},\n    {'i',\tnv_edit,\tNV_NCH,\t\t\t0},\n    {'j',\tnv_down,\t0,\t\t\tFALSE},\n    {'k',\tnv_up,\t\t0,\t\t\tFALSE},\n    {'l',\tnv_right,\tNV_RL,\t\t\t0},\n    {'m',\tnv_mark,\tNV_NCH_NOP,\t\t0},\n    {'n',\tnv_next,\t0,\t\t\t0},\n    {'o',\tnv_open,\t0,\t\t\t0},\n    {'p',\tnv_put,\t\t0,\t\t\t0},\n    {'q',\tnv_record,\tNV_NCH,\t\t\t0},\n    {'r',\tnv_replace,\tNV_NCH_NOP|NV_LANG,\t0},\n    {'s',\tnv_subst,\tNV_KEEPREG,\t\t0},\n    {'t',\tnv_csearch,\tNV_NCH_ALW|NV_LANG,\tFORWARD},\n    {'u',\tnv_undo,\t0,\t\t\t0},\n    {'w',\tnv_wordcmd,\t0,\t\t\tFALSE},\n    {'x',\tnv_abbrev,\tNV_KEEPREG,\t\t0},\n    {'y',\tnv_operator,\t0,\t\t\t0},\n    {'z',\tnv_zet,\t\tNV_NCH_ALW,\t\t0},\n    {'{',\tnv_findpar,\t0,\t\t\tBACKWARD},\n    {'|',\tnv_pipe,\t0,\t\t\t0},\n    {'}',\tnv_findpar,\t0,\t\t\tFORWARD},\n    {'~',\tnv_tilde,\t0,\t\t\t0},\n\n    // pound sign\n    {POUND,\tnv_ident,\t0,\t\t\t0},\n    {K_MOUSEUP, nv_mousescroll,\t0,\t\t\tMSCR_UP},\n    {K_MOUSEDOWN, nv_mousescroll, 0,\t\t\tMSCR_DOWN},\n    {K_MOUSELEFT, nv_mousescroll, 0,\t\t\tMSCR_LEFT},\n    {K_MOUSERIGHT, nv_mousescroll, 0,\t\t\tMSCR_RIGHT},\n    {K_LEFTMOUSE, nv_mouse,\t0,\t\t\t0},\n    {K_LEFTMOUSE_NM, nv_mouse,\t0,\t\t\t0},\n    {K_LEFTDRAG, nv_mouse,\t0,\t\t\t0},\n    {K_LEFTRELEASE, nv_mouse,\t0,\t\t\t0},\n    {K_LEFTRELEASE_NM, nv_mouse, 0,\t\t\t0},\n    {K_MOUSEMOVE, nv_mouse,\t0,\t\t\t0},\n    {K_MIDDLEMOUSE, nv_mouse,\t0,\t\t\t0},\n    {K_MIDDLEDRAG, nv_mouse,\t0,\t\t\t0},\n    {K_MIDDLERELEASE, nv_mouse,\t0,\t\t\t0},\n    {K_RIGHTMOUSE, nv_mouse,\t0,\t\t\t0},\n    {K_RIGHTDRAG, nv_mouse,\t0,\t\t\t0},\n    {K_RIGHTRELEASE, nv_mouse,\t0,\t\t\t0},\n    {K_X1MOUSE, nv_mouse,\t0,\t\t\t0},\n    {K_X1DRAG, nv_mouse,\t0,\t\t\t0},\n    {K_X1RELEASE, nv_mouse,\t0,\t\t\t0},\n    {K_X2MOUSE, nv_mouse,\t0,\t\t\t0},\n    {K_X2DRAG, nv_mouse,\t0,\t\t\t0},\n    {K_X2RELEASE, nv_mouse,\t0,\t\t\t0},\n    {K_IGNORE,\tnv_ignore,\tNV_KEEPREG,\t\t0},\n    {K_NOP,\tnv_nop,\t\t0,\t\t\t0},\n    {K_INS,\tnv_edit,\t0,\t\t\t0},\n    {K_KINS,\tnv_edit,\t0,\t\t\t0},\n    {K_BS,\tnv_ctrlh,\t0,\t\t\t0},\n    {K_UP,\tnv_up,\t\tNV_SSS|NV_STS,\t\tFALSE},\n    {K_S_UP,\tnv_page,\tNV_SS,\t\t\tBACKWARD},\n    {K_DOWN,\tnv_down,\tNV_SSS|NV_STS,\t\tFALSE},\n    {K_S_DOWN,\tnv_page,\tNV_SS,\t\t\tFORWARD},\n    {K_LEFT,\tnv_left,\tNV_SSS|NV_STS|NV_RL,\t0},\n    {K_S_LEFT,\tnv_bck_word,\tNV_SS|NV_RL,\t\t0},\n    {K_C_LEFT,\tnv_bck_word,\tNV_SSS|NV_RL|NV_STS,\t1},\n    {K_RIGHT,\tnv_right,\tNV_SSS|NV_STS|NV_RL,\t0},\n    {K_S_RIGHT,\tnv_wordcmd,\tNV_SS|NV_RL,\t\tFALSE},\n    {K_C_RIGHT,\tnv_wordcmd,\tNV_SSS|NV_RL|NV_STS,\tTRUE},\n    {K_PAGEUP,\tnv_page,\tNV_SSS|NV_STS,\t\tBACKWARD},\n    {K_KPAGEUP,\tnv_page,\tNV_SSS|NV_STS,\t\tBACKWARD},\n    {K_PAGEDOWN, nv_page,\tNV_SSS|NV_STS,\t\tFORWARD},\n    {K_KPAGEDOWN, nv_page,\tNV_SSS|NV_STS,\t\tFORWARD},\n    {K_END,\tnv_end,\t\tNV_SSS|NV_STS,\t\tFALSE},\n    {K_KEND,\tnv_end,\t\tNV_SSS|NV_STS,\t\tFALSE},\n    {K_S_END,\tnv_end,\t\tNV_SS,\t\t\tFALSE},\n    {K_C_END,\tnv_end,\t\tNV_SSS|NV_STS,\t\tTRUE},\n    {K_HOME,\tnv_home,\tNV_SSS|NV_STS,\t\t0},\n    {K_KHOME,\tnv_home,\tNV_SSS|NV_STS,\t\t0},\n    {K_S_HOME,\tnv_home,\tNV_SS,\t\t\t0},\n    {K_C_HOME,\tnv_goto,\tNV_SSS|NV_STS,\t\tFALSE},\n    {K_DEL,\tnv_abbrev,\t0,\t\t\t0},\n    {K_KDEL,\tnv_abbrev,\t0,\t\t\t0},\n    {K_UNDO,\tnv_kundo,\t0,\t\t\t0},\n    {K_HELP,\tnv_help,\tNV_NCW,\t\t\t0},\n    {K_F1,\tnv_help,\tNV_NCW,\t\t\t0},\n    {K_XF1,\tnv_help,\tNV_NCW,\t\t\t0},\n    {K_SELECT,\tnv_select,\t0,\t\t\t0},\n#ifdef FEAT_GUI\n    {K_VER_SCROLLBAR, nv_ver_scrollbar, 0,\t\t0},\n    {K_HOR_SCROLLBAR, nv_hor_scrollbar, 0,\t\t0},\n#endif\n#ifdef FEAT_GUI_TABLINE\n    {K_TABLINE, nv_tabline,\t0,\t\t\t0},\n    {K_TABMENU, nv_tabmenu,\t0,\t\t\t0},\n#endif\n#ifdef FEAT_NETBEANS_INTG\n    {K_F21,\tnv_nbcmd,\tNV_NCH_ALW,\t\t0},\n#endif\n#ifdef FEAT_DND\n    {K_DROP,\tnv_drop,\tNV_STS,\t\t\t0},\n#endif\n    {K_CURSORHOLD, nv_cursorhold, NV_KEEPREG,\t\t0},\n    {K_PS,\tnv_edit,\t0,\t\t\t0},\n    {K_COMMAND,\tnv_colon,\t0,\t\t\t0},\n};\n\n// Number of commands in nv_cmds[].\n#define NV_CMDS_SIZE ARRAY_LENGTH(nv_cmds)\n\n// Sorted index of commands in nv_cmds[].\nstatic short nv_cmd_idx[NV_CMDS_SIZE];\n\n// The highest index for which\n// nv_cmds[idx].cmd_char == nv_cmd_idx[nv_cmds[idx].cmd_char]\nstatic int nv_max_linear;\n\n/*\n * Compare functions for qsort() below, that checks the command character\n * through the index in nv_cmd_idx[].\n */\n    static int\nnv_compare(const void *s1, const void *s2)\n{\n    int\t\tc1, c2;\n\n    // The commands are sorted on absolute value.\n    c1 = nv_cmds[*(const short *)s1].cmd_char;\n    c2 = nv_cmds[*(const short *)s2].cmd_char;\n    if (c1 < 0)\n\tc1 = -c1;\n    if (c2 < 0)\n\tc2 = -c2;\n    return c1 - c2;\n}\n\n/*\n * Initialize the nv_cmd_idx[] table.\n */\n    void\ninit_normal_cmds(void)\n{\n    int\t\ti;\n\n    // Fill the index table with a one to one relation.\n    for (i = 0; i < (int)NV_CMDS_SIZE; ++i)\n\tnv_cmd_idx[i] = i;\n\n    // Sort the commands by the command character.\n    qsort((void *)&nv_cmd_idx, (size_t)NV_CMDS_SIZE, sizeof(short), nv_compare);\n\n    // Find the first entry that can't be indexed by the command character.\n    for (i = 0; i < (int)NV_CMDS_SIZE; ++i)\n\tif (i != nv_cmds[nv_cmd_idx[i]].cmd_char)\n\t    break;\n    nv_max_linear = i - 1;\n}\n\n/*\n * Search for a command in the commands table.\n * Returns -1 for invalid command.\n */\n    static int\nfind_command(int cmdchar)\n{\n    int\t\ti;\n    int\t\tidx;\n    int\t\ttop, bot;\n    int\t\tc;\n\n    // A multi-byte character is never a command.\n    if (cmdchar >= 0x100)\n\treturn -1;\n\n    // We use the absolute value of the character.  Special keys have a\n    // negative value, but are sorted on their absolute value.\n    if (cmdchar < 0)\n\tcmdchar = -cmdchar;\n\n    // If the character is in the first part: The character is the index into\n    // nv_cmd_idx[].\n    if (cmdchar <= nv_max_linear)\n\treturn nv_cmd_idx[cmdchar];\n\n    // Perform a binary search.\n    bot = nv_max_linear + 1;\n    top = NV_CMDS_SIZE - 1;\n    idx = -1;\n    while (bot <= top)\n    {\n\ti = (top + bot) / 2;\n\tc = nv_cmds[nv_cmd_idx[i]].cmd_char;\n\tif (c < 0)\n\t    c = -c;\n\tif (cmdchar == c)\n\t{\n\t    idx = nv_cmd_idx[i];\n\t    break;\n\t}\n\tif (cmdchar > c)\n\t    bot = i + 1;\n\telse\n\t    top = i - 1;\n    }\n    return idx;\n}\n\n/*\n * Execute a command in Normal mode.\n */\n    void\nnormal_cmd(\n    oparg_T\t*oap,\n    int\t\ttoplevel UNUSED)\t// TRUE when called from main()\n{\n    cmdarg_T\tca;\t\t\t// command arguments\n    int\t\tc;\n    int\t\tctrl_w = FALSE;\t\t// got CTRL-W command\n    int\t\told_col = curwin->w_curswant;\n#ifdef FEAT_CMDL_INFO\n    int\t\tneed_flushbuf;\t\t// need to call out_flush()\n#endif\n    pos_T\told_pos;\t\t// cursor position before command\n    int\t\tmapped_len;\n    static int\told_mapped_len = 0;\n    int\t\tidx;\n#ifdef FEAT_EVAL\n    int\t\tset_prevcount = FALSE;\n#endif\n    int\t\tsave_did_cursorhold = did_cursorhold;\n\n    CLEAR_FIELD(ca);\t// also resets ca.retval\n    ca.oap = oap;\n\n    // Use a count remembered from before entering an operator.  After typing\n    // \"3d\" we return from normal_cmd() and come back here, the \"3\" is\n    // remembered in \"opcount\".\n    ca.opcount = opcount;\n\n    /*\n     * If there is an operator pending, then the command we take this time\n     * will terminate it. Finish_op tells us to finish the operation before\n     * returning this time (unless the operation was cancelled).\n     */\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = (oap->op_type != OP_NOP);\n#ifdef CURSOR_SHAPE\n    if (finish_op != c)\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n\n    // When not finishing an operator and no register name typed, reset the\n    // count.\n    if (!finish_op && !oap->regname)\n    {\n\tca.opcount = 0;\n#ifdef FEAT_EVAL\n\tset_prevcount = TRUE;\n#endif\n    }\n\n    // Restore counts from before receiving K_CURSORHOLD.  This means after\n    // typing \"3\", handling K_CURSORHOLD and then typing \"2\" we get \"32\", not\n    // \"3 * 2\".\n    if (oap->prev_opcount > 0 || oap->prev_count0 > 0)\n    {\n\tca.opcount = oap->prev_opcount;\n\tca.count0 = oap->prev_count0;\n\toap->prev_opcount = 0;\n\toap->prev_count0 = 0;\n    }\n\n    mapped_len = typebuf_maplen();\n\n    State = NORMAL_BUSY;\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = FALSE;\t// allow scrolling here\n#endif\n\n#ifdef FEAT_EVAL\n    // Set v:count here, when called from main() and not a stuffed\n    // command, so that v:count can be used in an expression mapping\n    // when there is no count. Do set it for redo.\n    if (toplevel && readbuf1_empty())\n\tset_vcount_ca(&ca, &set_prevcount);\n#endif\n\n    /*\n     * Get the command character from the user.\n     */\n    c = safe_vgetc();\n    LANGMAP_ADJUST(c, get_real_state() != SELECTMODE);\n\n    /*\n     * If a mapping was started in Visual or Select mode, remember the length\n     * of the mapping.  This is used below to not return to Insert mode for as\n     * long as the mapping is being executed.\n     */\n    if (restart_edit == 0)\n\told_mapped_len = 0;\n    else if (old_mapped_len\n\t\t|| (VIsual_active && mapped_len == 0 && typebuf_maplen() > 0))\n\told_mapped_len = typebuf_maplen();\n\n    if (c == NUL)\n\tc = K_ZERO;\n\n    /*\n     * In Select mode, typed text replaces the selection.\n     */\n    if (VIsual_active\n\t    && VIsual_select\n\t    && (vim_isprintc(c) || c == NL || c == CAR || c == K_KENTER))\n    {\n\t// Fake a \"c\"hange command.  When \"restart_edit\" is set (e.g., because\n\t// 'insertmode' is set) fake a \"d\"elete command, Insert mode will\n\t// restart automatically.\n\t// Insert the typed character in the typeahead buffer, so that it can\n\t// be mapped in Insert mode.  Required for \":lmap\" to work.\n\tins_char_typebuf(vgetc_char, vgetc_mod_mask);\n\tif (restart_edit != 0)\n\t    c = 'd';\n\telse\n\t    c = 'c';\n\tmsg_nowait = TRUE;\t// don't delay going to insert mode\n\told_mapped_len = 0;\t// do go to Insert mode\n    }\n\n#ifdef FEAT_CMDL_INFO\n    need_flushbuf = add_to_showcmd(c);\n#endif\n\ngetcount:\n    if (!(VIsual_active && VIsual_select))\n    {\n\t/*\n\t * Handle a count before a command and compute ca.count0.\n\t * Note that '0' is a command and not the start of a count, but it's\n\t * part of a count after other digits.\n\t */\n\twhile (    (c >= '1' && c <= '9')\n\t\t|| (ca.count0 != 0 && (c == K_DEL || c == K_KDEL || c == '0')))\n\t{\n\t    if (c == K_DEL || c == K_KDEL)\n\t    {\n\t\tca.count0 /= 10;\n#ifdef FEAT_CMDL_INFO\n\t\tdel_from_showcmd(4);\t// delete the digit and ~@%\n#endif\n\t    }\n\t    else\n\t\tca.count0 = ca.count0 * 10 + (c - '0');\n\t    if (ca.count0 < 0)\t    // overflow\n\t\tca.count0 = 999999999L;\n#ifdef FEAT_EVAL\n\t    // Set v:count here, when called from main() and not a stuffed\n\t    // command, so that v:count can be used in an expression mapping\n\t    // right after the count. Do set it for redo.\n\t    if (toplevel && readbuf1_empty())\n\t\tset_vcount_ca(&ca, &set_prevcount);\n#endif\n\t    if (ctrl_w)\n\t    {\n\t\t++no_mapping;\n\t\t++allow_keys;\t\t// no mapping for nchar, but keys\n\t    }\n\t    ++no_zero_mapping;\t\t// don't map zero here\n\t    c = plain_vgetc();\n\t    LANGMAP_ADJUST(c, TRUE);\n\t    --no_zero_mapping;\n\t    if (ctrl_w)\n\t    {\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t    }\n#ifdef FEAT_CMDL_INFO\n\t    need_flushbuf |= add_to_showcmd(c);\n#endif\n\t}\n\n\t/*\n\t * If we got CTRL-W there may be a/another count\n\t */\n\tif (c == Ctrl_W && !ctrl_w && oap->op_type == OP_NOP)\n\t{\n\t    ctrl_w = TRUE;\n\t    ca.opcount = ca.count0;\t// remember first count\n\t    ca.count0 = 0;\n\t    ++no_mapping;\n\t    ++allow_keys;\t\t// no mapping for nchar, but keys\n\t    c = plain_vgetc();\t\t// get next character\n\t    LANGMAP_ADJUST(c, TRUE);\n\t    --no_mapping;\n\t    --allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t    need_flushbuf |= add_to_showcmd(c);\n#endif\n\t    goto getcount;\t\t// jump back\n\t}\n    }\n\n    if (c == K_CURSORHOLD)\n    {\n\t// Save the count values so that ca.opcount and ca.count0 are exactly\n\t// the same when coming back here after handling K_CURSORHOLD.\n\toap->prev_opcount = ca.opcount;\n\toap->prev_count0 = ca.count0;\n    }\n    else if (ca.opcount != 0)\n    {\n\t/*\n\t * If we're in the middle of an operator (including after entering a\n\t * yank buffer with '\"') AND we had a count before the operator, then\n\t * that count overrides the current value of ca.count0.\n\t * What this means effectively, is that commands like \"3dw\" get turned\n\t * into \"d3w\" which makes things fall into place pretty neatly.\n\t * If you give a count before AND after the operator, they are\n\t * multiplied.\n\t */\n\tif (ca.count0)\n\t    ca.count0 *= ca.opcount;\n\telse\n\t    ca.count0 = ca.opcount;\n\tif (ca.count0 < 0)\t    // overflow\n\t    ca.count0 = 999999999L;\n    }\n\n    /*\n     * Always remember the count.  It will be set to zero (on the next call,\n     * above) when there is no pending operator.\n     * When called from main(), save the count for use by the \"count\" built-in\n     * variable.\n     */\n    ca.opcount = ca.count0;\n    ca.count1 = (ca.count0 == 0 ? 1 : ca.count0);\n\n#ifdef FEAT_EVAL\n    /*\n     * Only set v:count when called from main() and not a stuffed command.\n     * Do set it for redo.\n     */\n    if (toplevel && readbuf1_empty())\n\tset_vcount(ca.count0, ca.count1, set_prevcount);\n#endif\n\n    /*\n     * Find the command character in the table of commands.\n     * For CTRL-W we already got nchar when looking for a count.\n     */\n    if (ctrl_w)\n    {\n\tca.nchar = c;\n\tca.cmdchar = Ctrl_W;\n    }\n    else\n\tca.cmdchar = c;\n    idx = find_command(ca.cmdchar);\n    if (idx < 0)\n    {\n\t// Not a known command: beep.\n\tclearopbeep(oap);\n\tgoto normal_end;\n    }\n\n    if (text_locked() && (nv_cmds[idx].cmd_flags & NV_NCW))\n    {\n\t// This command is not allowed while editing a cmdline: beep.\n\tclearopbeep(oap);\n\ttext_locked_msg();\n\tgoto normal_end;\n    }\n    if ((nv_cmds[idx].cmd_flags & NV_NCW) && curbuf_locked())\n\tgoto normal_end;\n\n    /*\n     * In Visual/Select mode, a few keys are handled in a special way.\n     */\n    if (VIsual_active)\n    {\n\t// when 'keymodel' contains \"stopsel\" may stop Select/Visual mode\n\tif (km_stopsel\n\t\t&& (nv_cmds[idx].cmd_flags & NV_STS)\n\t\t&& !(mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    end_visual_mode();\n\t    redraw_curbuf_later(INVERTED);\n\t}\n\n\t// Keys that work different when 'keymodel' contains \"startsel\"\n\tif (km_startsel)\n\t{\n\t    if (nv_cmds[idx].cmd_flags & NV_SS)\n\t    {\n\t\tunshift_special(&ca);\n\t\tidx = find_command(ca.cmdchar);\n\t\tif (idx < 0)\n\t\t{\n\t\t    // Just in case\n\t\t    clearopbeep(oap);\n\t\t    goto normal_end;\n\t\t}\n\t    }\n\t    else if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t       && (mod_mask & MOD_MASK_SHIFT))\n\t\tmod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && KeyTyped && !KeyStuffed\n\t\t\t\t\t  && (nv_cmds[idx].cmd_flags & NV_RL))\n    {\n\t// Invert horizontal movements and operations.  Only when typed by the\n\t// user directly, not when the result of a mapping or \"x\" translated\n\t// to \"dl\".\n\tswitch (ca.cmdchar)\n\t{\n\t    case 'l':\t    ca.cmdchar = 'h'; break;\n\t    case K_RIGHT:   ca.cmdchar = K_LEFT; break;\n\t    case K_S_RIGHT: ca.cmdchar = K_S_LEFT; break;\n\t    case K_C_RIGHT: ca.cmdchar = K_C_LEFT; break;\n\t    case 'h':\t    ca.cmdchar = 'l'; break;\n\t    case K_LEFT:    ca.cmdchar = K_RIGHT; break;\n\t    case K_S_LEFT:  ca.cmdchar = K_S_RIGHT; break;\n\t    case K_C_LEFT:  ca.cmdchar = K_C_RIGHT; break;\n\t    case '>':\t    ca.cmdchar = '<'; break;\n\t    case '<':\t    ca.cmdchar = '>'; break;\n\t}\n\tidx = find_command(ca.cmdchar);\n    }\n#endif\n\n    /*\n     * Get an additional character if we need one.\n     */\n    if ((nv_cmds[idx].cmd_flags & NV_NCH)\n\t    && (((nv_cmds[idx].cmd_flags & NV_NCH_NOP) == NV_NCH_NOP\n\t\t    && oap->op_type == OP_NOP)\n\t\t|| (nv_cmds[idx].cmd_flags & NV_NCH_ALW) == NV_NCH_ALW\n\t\t|| (ca.cmdchar == 'q'\n\t\t    && oap->op_type == OP_NOP\n\t\t    && reg_recording == 0\n\t\t    && reg_executing == 0)\n\t\t|| ((ca.cmdchar == 'a' || ca.cmdchar == 'i')\n\t\t    && (oap->op_type != OP_NOP || VIsual_active))))\n    {\n\tint\t*cp;\n\tint\trepl = FALSE;\t// get character for replace mode\n\tint\tlit = FALSE;\t// get extra character literally\n\tint\tlangmap_active = FALSE;    // using :lmap mappings\n\tint\tlang;\t\t// getting a text character\n#ifdef HAVE_INPUT_METHOD\n\tint\tsave_smd;\t// saved value of p_smd\n#endif\n\n\t++no_mapping;\n\t++allow_keys;\t\t// no mapping for nchar, but allow key codes\n\t// Don't generate a CursorHold event here, most commands can't handle\n\t// it, e.g., nv_replace(), nv_csearch().\n\tdid_cursorhold = TRUE;\n\tif (ca.cmdchar == 'g')\n\t{\n\t    /*\n\t     * For 'g' get the next character now, so that we can check for\n\t     * \"gr\", \"g'\" and \"g`\".\n\t     */\n\t    ca.nchar = plain_vgetc();\n\t    LANGMAP_ADJUST(ca.nchar, TRUE);\n#ifdef FEAT_CMDL_INFO\n\t    need_flushbuf |= add_to_showcmd(ca.nchar);\n#endif\n\t    if (ca.nchar == 'r' || ca.nchar == '\\'' || ca.nchar == '`'\n\t\t\t\t\t\t       || ca.nchar == Ctrl_BSL)\n\t    {\n\t\tcp = &ca.extra_char;\t// need to get a third character\n\t\tif (ca.nchar != 'r')\n\t\t    lit = TRUE;\t\t\t// get it literally\n\t\telse\n\t\t    repl = TRUE;\t\t// get it in replace mode\n\t    }\n\t    else\n\t\tcp = NULL;\t\t// no third character needed\n\t}\n\telse\n\t{\n\t    if (ca.cmdchar == 'r')\t\t// get it in replace mode\n\t\trepl = TRUE;\n\t    cp = &ca.nchar;\n\t}\n\tlang = (repl || (nv_cmds[idx].cmd_flags & NV_LANG));\n\n\t/*\n\t * Get a second or third character.\n\t */\n\tif (cp != NULL)\n\t{\n\t    if (repl)\n\t    {\n\t\tState = REPLACE;\t// pretend Replace mode\n#ifdef CURSOR_SHAPE\n\t\tui_cursor_shape();\t// show different cursor shape\n#endif\n\t    }\n\t    if (lang && curbuf->b_p_iminsert == B_IMODE_LMAP)\n\t    {\n\t\t// Allow mappings defined with \":lmap\".\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t\tif (repl)\n\t\t    State = LREPLACE;\n\t\telse\n\t\t    State = LANGMAP;\n\t\tlangmap_active = TRUE;\n\t    }\n#ifdef HAVE_INPUT_METHOD\n\t    save_smd = p_smd;\n\t    p_smd = FALSE;\t// Don't let the IM code show the mode here\n\t    if (lang && curbuf->b_p_iminsert == B_IMODE_IM)\n\t\tim_set_active(TRUE);\n#endif\n\t    if ((State & INSERT) && !p_ek)\n\t    {\n#ifdef FEAT_JOB_CHANNEL\n\t\tch_log_output = TRUE;\n#endif\n\t\t// Disable bracketed paste and modifyOtherKeys here, we won't\n\t\t// recognize the escape sequences with 'esckeys' off.\n\t\tout_str(T_BD);\n\t\tout_str(T_CTE);\n\t    }\n\n\t    *cp = plain_vgetc();\n\n\t    if ((State & INSERT) && !p_ek)\n\t    {\n#ifdef FEAT_JOB_CHANNEL\n\t\tch_log_output = TRUE;\n#endif\n\t\t// Re-enable bracketed paste mode and modifyOtherKeys\n\t\tout_str(T_BE);\n\t\tout_str(T_CTI);\n\t    }\n\n\t    if (langmap_active)\n\t    {\n\t\t// Undo the decrement done above\n\t\t++no_mapping;\n\t\t++allow_keys;\n\t\tState = NORMAL_BUSY;\n\t    }\n#ifdef HAVE_INPUT_METHOD\n\t    if (lang)\n\t    {\n\t\tif (curbuf->b_p_iminsert != B_IMODE_LMAP)\n\t\t    im_save_status(&curbuf->b_p_iminsert);\n\t\tim_set_active(FALSE);\n\t    }\n\t    p_smd = save_smd;\n#endif\n\t    State = NORMAL_BUSY;\n#ifdef FEAT_CMDL_INFO\n\t    need_flushbuf |= add_to_showcmd(*cp);\n#endif\n\n\t    if (!lit)\n\t    {\n#ifdef FEAT_DIGRAPHS\n\t\t// Typing CTRL-K gets a digraph.\n\t\tif (*cp == Ctrl_K\n\t\t\t&& ((nv_cmds[idx].cmd_flags & NV_LANG)\n\t\t\t    || cp == &ca.extra_char)\n\t\t\t&& vim_strchr(p_cpo, CPO_DIGRAPH) == NULL)\n\t\t{\n\t\t    c = get_digraph(FALSE);\n\t\t    if (c > 0)\n\t\t    {\n\t\t\t*cp = c;\n# ifdef FEAT_CMDL_INFO\n\t\t\t// Guessing how to update showcmd here...\n\t\t\tdel_from_showcmd(3);\n\t\t\tneed_flushbuf |= add_to_showcmd(*cp);\n# endif\n\t\t    }\n\t\t}\n#endif\n\n\t\t// adjust chars > 127, except after \"tTfFr\" commands\n\t\tLANGMAP_ADJUST(*cp, !lang);\n#ifdef FEAT_RIGHTLEFT\n\t\t// adjust Hebrew mapped char\n\t\tif (p_hkmap && lang && KeyTyped)\n\t\t    *cp = hkmap(*cp);\n#endif\n\t    }\n\n\t    /*\n\t     * When the next character is CTRL-\\ a following CTRL-N means the\n\t     * command is aborted and we go to Normal mode.\n\t     */\n\t    if (cp == &ca.extra_char\n\t\t    && ca.nchar == Ctrl_BSL\n\t\t    && (ca.extra_char == Ctrl_N || ca.extra_char == Ctrl_G))\n\t    {\n\t\tca.cmdchar = Ctrl_BSL;\n\t\tca.nchar = ca.extra_char;\n\t\tidx = find_command(ca.cmdchar);\n\t    }\n\t    else if ((ca.nchar == 'n' || ca.nchar == 'N') && ca.cmdchar == 'g')\n\t\tca.oap->op_type = get_op_type(*cp, NUL);\n\t    else if (*cp == Ctrl_BSL)\n\t    {\n\t\tlong towait = (p_ttm >= 0 ? p_ttm : p_tm);\n\n\t\t// There is a busy wait here when typing \"f<C-\\>\" and then\n\t\t// something different from CTRL-N.  Can't be avoided.\n\t\twhile ((c = vpeekc()) <= 0 && towait > 0L)\n\t\t{\n\t\t    do_sleep(towait > 50L ? 50L : towait, FALSE);\n\t\t    towait -= 50L;\n\t\t}\n\t\tif (c > 0)\n\t\t{\n\t\t    c = plain_vgetc();\n\t\t    if (c != Ctrl_N && c != Ctrl_G)\n\t\t\tvungetc(c);\n\t\t    else\n\t\t    {\n\t\t\tca.cmdchar = Ctrl_BSL;\n\t\t\tca.nchar = c;\n\t\t\tidx = find_command(ca.cmdchar);\n\t\t    }\n\t\t}\n\t    }\n\n\t    // When getting a text character and the next character is a\n\t    // multi-byte character, it could be a composing character.\n\t    // However, don't wait for it to arrive. Also, do enable mapping,\n\t    // because if it's put back with vungetc() it's too late to apply\n\t    // mapping.\n\t    --no_mapping;\n\t    while (enc_utf8 && lang && (c = vpeekc()) > 0\n\t\t\t\t && (c >= 0x100 || MB_BYTE2LEN(vpeekc()) > 1))\n\t    {\n\t\tc = plain_vgetc();\n\t\tif (!utf_iscomposing(c))\n\t\t{\n\t\t    vungetc(c);\t\t// it wasn't, put it back\n\t\t    break;\n\t\t}\n\t\telse if (ca.ncharC1 == 0)\n\t\t    ca.ncharC1 = c;\n\t\telse\n\t\t    ca.ncharC2 = c;\n\t    }\n\t    ++no_mapping;\n\t}\n\t--no_mapping;\n\t--allow_keys;\n    }\n\n#ifdef FEAT_CMDL_INFO\n    /*\n     * Flush the showcmd characters onto the screen so we can see them while\n     * the command is being executed.  Only do this when the shown command was\n     * actually displayed, otherwise this will slow down a lot when executing\n     * mappings.\n     */\n    if (need_flushbuf)\n\tout_flush();\n#endif\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tif (ex_normal_busy)\n\t    did_cursorhold = save_did_cursorhold;\n\telse\n\t    did_cursorhold = FALSE;\n    }\n\n    State = NORMAL;\n\n    if (ca.nchar == ESC)\n    {\n\tclearop(oap);\n\tif (restart_edit == 0 && goto_im())\n\t    restart_edit = 'a';\n\tgoto normal_end;\n    }\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tmsg_didout = FALSE;    // don't scroll screen up for normal command\n\tmsg_col = 0;\n    }\n\n    old_pos = curwin->w_cursor;\t\t// remember where cursor was\n\n    // When 'keymodel' contains \"startsel\" some keys start Select/Visual\n    // mode.\n    if (!VIsual_active && km_startsel)\n    {\n\tif (nv_cmds[idx].cmd_flags & NV_SS)\n\t{\n\t    start_selection();\n\t    unshift_special(&ca);\n\t    idx = find_command(ca.cmdchar);\n\t}\n\telse if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t   && (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    start_selection();\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    /*\n     * Execute the command!\n     * Call the command function found in the commands table.\n     */\n    ca.arg = nv_cmds[idx].cmd_arg;\n    (nv_cmds[idx].cmd_func)(&ca);\n\n    /*\n     * If we didn't start or finish an operator, reset oap->regname, unless we\n     * need it later.\n     */\n    if (!finish_op\n\t    && !oap->op_type\n\t    && (idx < 0 || !(nv_cmds[idx].cmd_flags & NV_KEEPREG)))\n    {\n\tclearop(oap);\n#ifdef FEAT_EVAL\n\treset_reg_var();\n#endif\n    }\n\n    // Get the length of mapped chars again after typing a count, second\n    // character or \"z333<cr>\".\n    if (old_mapped_len > 0)\n\told_mapped_len = typebuf_maplen();\n\n    /*\n     * If an operation is pending, handle it.  But not for K_IGNORE or\n     * K_MOUSEMOVE.\n     */\n    if (ca.cmdchar != K_IGNORE && ca.cmdchar != K_MOUSEMOVE)\n\tdo_pending_operator(&ca, old_col, FALSE);\n\n    /*\n     * Wait for a moment when a message is displayed that will be overwritten\n     * by the mode message.\n     * In Visual mode and with \"^O\" in Insert mode, a short message will be\n     * overwritten by the mode message.  Wait a bit, until a key is hit.\n     * In Visual mode, it's more important to keep the Visual area updated\n     * than keeping a message (e.g. from a /pat search).\n     * Only do this if the command was typed, not from a mapping.\n     * Don't wait when emsg_silent is non-zero.\n     * Also wait a bit after an error message, e.g. for \"^O:\".\n     * Don't redraw the screen, it would remove the message.\n     */\n    if (       ((p_smd\n\t\t    && msg_silent == 0\n\t\t    && (restart_edit != 0\n\t\t\t|| (VIsual_active\n\t\t\t    && old_pos.lnum == curwin->w_cursor.lnum\n\t\t\t    && old_pos.col == curwin->w_cursor.col)\n\t\t       )\n\t\t    && (clear_cmdline\n\t\t\t|| redraw_cmdline)\n\t\t    && (msg_didout || (msg_didany && msg_scroll))\n\t\t    && !msg_nowait\n\t\t    && KeyTyped)\n\t\t|| (restart_edit != 0\n\t\t    && !VIsual_active\n\t\t    && (msg_scroll\n\t\t\t|| emsg_on_display)))\n\t    && oap->regname == 0\n\t    && !(ca.retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && typebuf_typed()\n\t    && emsg_silent == 0\n\t    && !in_assert_fails\n\t    && !did_wait_return\n\t    && oap->op_type == OP_NOP)\n    {\n\tint\tsave_State = State;\n\n\t// Draw the cursor with the right shape here\n\tif (restart_edit != 0)\n\t    State = INSERT;\n\n\t// If need to redraw, and there is a \"keep_msg\", redraw before the\n\t// delay\n\tif (must_redraw && keep_msg != NULL && !emsg_on_display)\n\t{\n\t    char_u\t*kmsg;\n\n\t    kmsg = keep_msg;\n\t    keep_msg = NULL;\n\t    // Showmode() will clear keep_msg, but we want to use it anyway.\n\t    // First update w_topline.\n\t    setcursor();\n\t    update_screen(0);\n\t    // now reset it, otherwise it's put in the history again\n\t    keep_msg = kmsg;\n\n\t    kmsg = vim_strsave(keep_msg);\n\t    if (kmsg != NULL)\n\t    {\n\t\tmsg_attr((char *)kmsg, keep_msg_attr);\n\t\tvim_free(kmsg);\n\t    }\n\t}\n\tsetcursor();\n#ifdef CURSOR_SHAPE\n\tui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\tcursor_on();\n\tout_flush();\n\tif (msg_scroll || emsg_on_display)\n\t    ui_delay(1003L, TRUE);\t// wait at least one second\n\tui_delay(3003L, FALSE);\t\t// wait up to three seconds\n\tState = save_State;\n\n\tmsg_scroll = FALSE;\n\temsg_on_display = FALSE;\n    }\n\n    /*\n     * Finish up after executing a Normal mode command.\n     */\nnormal_end:\n\n    msg_nowait = FALSE;\n\n#ifdef FEAT_EVAL\n    if (finish_op)\n\treset_reg_var();\n#endif\n\n    // Reset finish_op, in case it was set\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = FALSE;\n#ifdef CURSOR_SHAPE\n    // Redraw the cursor with another shape, if we were in Operator-pending\n    // mode or did a replace command.\n    if (c || ca.cmdchar == 'r')\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n\n#ifdef FEAT_CMDL_INFO\n    if (oap->op_type == OP_NOP && oap->regname == 0\n\t    && ca.cmdchar != K_CURSORHOLD)\n\tclear_showcmd();\n#endif\n\n    checkpcmark();\t\t// check if we moved since setting pcmark\n    vim_free(ca.searchbuf);\n\n    if (has_mbyte)\n\tmb_adjust_cursor();\n\n    if (curwin->w_p_scb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_scrollbind(TRUE);\n    }\n\n    if (curwin->w_p_crb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_cursorbind();\n    }\n\n#ifdef FEAT_TERMINAL\n    // don't go to Insert mode if a terminal has a running job\n    if (term_job_running(curbuf->b_term))\n\trestart_edit = 0;\n#endif\n\n    /*\n     * May restart edit(), if we got here with CTRL-O in Insert mode (but not\n     * if still inside a mapping that started in Visual mode).\n     * May switch from Visual to Select mode after CTRL-O command.\n     */\n    if (       oap->op_type == OP_NOP\n\t    && ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t\t|| restart_VIsual_select == 1)\n\t    && !(ca.retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && oap->regname == 0)\n    {\n\tif (restart_VIsual_select == 1)\n\t{\n\t    VIsual_select = TRUE;\n\t    showmode();\n\t    restart_VIsual_select = 0;\n\t}\n\tif (restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t    (void)edit(restart_edit, FALSE, 1L);\n    }\n\n    if (restart_VIsual_select == 2)\n\trestart_VIsual_select = 1;\n\n    // Save count before an operator for next time.\n    opcount = ca.opcount;\n}\n\n#ifdef FEAT_EVAL\n/*\n * Set v:count and v:count1 according to \"cap\".\n * Set v:prevcount only when \"set_prevcount\" is TRUE.\n */\n    static void\nset_vcount_ca(cmdarg_T *cap, int *set_prevcount)\n{\n    long count = cap->count0;\n\n    // multiply with cap->opcount the same way as above\n    if (cap->opcount != 0)\n\tcount = cap->opcount * (count == 0 ? 1 : count);\n    set_vcount(count, count == 0 ? 1 : count, *set_prevcount);\n    *set_prevcount = FALSE;  // only set v:prevcount once\n}\n#endif\n\n/*\n * Check if highlighting for Visual mode is possible, give a warning message\n * if not.\n */\n    void\ncheck_visual_highlight(void)\n{\n    static int\t    did_check = FALSE;\n\n    if (full_screen)\n    {\n\tif (!did_check && HL_ATTR(HLF_V) == 0)\n\t    msg(_(\"Warning: terminal cannot highlight\"));\n\tdid_check = TRUE;\n    }\n}\n\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_EVAL)\n/*\n * Call yank_do_autocmd() for \"regname\".\n */\n    static void\ncall_yank_do_autocmd(int regname)\n{\n    oparg_T\toa;\n    yankreg_T\t*reg;\n\n    clear_oparg(&oa);\n    oa.regname = regname;\n    oa.op_type = OP_YANK;\n    oa.is_VIsual = TRUE;\n    reg = get_register(regname, TRUE);\n    yank_do_autocmd(&oa, reg);\n    free_register(reg);\n}\n#endif\n\n/*\n * End Visual mode.\n * This function or the next should ALWAYS be called to end Visual mode, except\n * from do_pending_operator().\n */\n    void\nend_visual_mode()\n{\n    end_visual_mode_keep_button();\n    reset_held_button();\n}\n\n    void\nend_visual_mode_keep_button()\n{\n#ifdef FEAT_CLIPBOARD\n    /*\n     * If we are using the clipboard, then remember what was selected in case\n     * we need to paste it somewhere while we still own the selection.\n     * Only do this when the clipboard is already owned.  Don't want to grab\n     * the selection when hitting ESC.\n     */\n    if (clip_star.available && clip_star.owned)\n\tclip_auto_select();\n\n# if defined(FEAT_EVAL)\n    // Emit a TextYankPost for the automatic copy of the selection into the\n    // star and/or plus register.\n    if (has_textyankpost())\n    {\n\tif (clip_isautosel_star())\n\t    call_yank_do_autocmd('*');\n\tif (clip_isautosel_plus())\n\t    call_yank_do_autocmd('+');\n    }\n# endif\n#endif\n\n    VIsual_active = FALSE;\n    setmouse();\n    mouse_dragging = 0;\n\n    // Save the current VIsual area for '< and '> marks, and \"gv\"\n    curbuf->b_visual.vi_mode = VIsual_mode;\n    curbuf->b_visual.vi_start = VIsual;\n    curbuf->b_visual.vi_end = curwin->w_cursor;\n    curbuf->b_visual.vi_curswant = curwin->w_curswant;\n#ifdef FEAT_EVAL\n    curbuf->b_visual_mode_eval = VIsual_mode;\n#endif\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    may_clear_cmdline();\n\n    adjust_cursor_eol();\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect.\n */\n    void\nreset_VIsual_and_resel(void)\n{\n    if (VIsual_active)\n    {\n\tend_visual_mode();\n\tredraw_curbuf_later(INVERTED);\t// delete the inversion later\n    }\n    VIsual_reselect = FALSE;\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect if it's set.\n */\n    void\nreset_VIsual(void)\n{\n    if (VIsual_active)\n    {\n\tend_visual_mode();\n\tredraw_curbuf_later(INVERTED);\t// delete the inversion later\n\tVIsual_reselect = FALSE;\n    }\n}\n\n    void\nrestore_visual_mode(void)\n{\n    if (VIsual_mode_orig != NUL)\n    {\n\tcurbuf->b_visual.vi_mode = VIsual_mode_orig;\n\tVIsual_mode_orig = NUL;\n    }\n}\n\n/*\n * Check for a balloon-eval special item to include when searching for an\n * identifier.  When \"dir\" is BACKWARD \"ptr[-1]\" must be valid!\n * Returns TRUE if the character at \"*ptr\" should be included.\n * \"dir\" is FORWARD or BACKWARD, the direction of searching.\n * \"*colp\" is in/decremented if \"ptr[-dir]\" should also be included.\n * \"bnp\" points to a counter for square brackets.\n */\n    static int\nfind_is_eval_item(\n    char_u\t*ptr,\n    int\t\t*colp,\n    int\t\t*bnp,\n    int\t\tdir)\n{\n    // Accept everything inside [].\n    if ((*ptr == ']' && dir == BACKWARD) || (*ptr == '[' && dir == FORWARD))\n\t++*bnp;\n    if (*bnp > 0)\n    {\n\tif ((*ptr == '[' && dir == BACKWARD) || (*ptr == ']' && dir == FORWARD))\n\t    --*bnp;\n\treturn TRUE;\n    }\n\n    // skip over \"s.var\"\n    if (*ptr == '.')\n\treturn TRUE;\n\n    // two-character item: s->var\n    if (ptr[dir == BACKWARD ? 0 : 1] == '>'\n\t    && ptr[dir == BACKWARD ? -1 : 0] == '-')\n    {\n\t*colp += dir;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Find the identifier under or to the right of the cursor.\n * \"find_type\" can have one of three values:\n * FIND_IDENT:   find an identifier (keyword)\n * FIND_STRING:  find any non-white text\n * FIND_IDENT + FIND_STRING: find any non-white text, identifier preferred.\n * FIND_EVAL:\t find text useful for C program debugging\n *\n * There are three steps:\n * 1. Search forward for the start of an identifier/text.  Doesn't move if\n *    already on one.\n * 2. Search backward for the start of this identifier/text.\n *    This doesn't match the real Vi but I like it a little better and it\n *    shouldn't bother anyone.\n * 3. Search forward to the end of this identifier/text.\n *    When FIND_IDENT isn't defined, we backup until a blank.\n *\n * Returns the length of the text, or zero if no text is found.\n * If text is found, a pointer to the text is put in \"*text\".  This\n * points into the current buffer line and is not always NUL terminated.\n */\n    int\nfind_ident_under_cursor(char_u **text, int find_type)\n{\n    return find_ident_at_pos(curwin, curwin->w_cursor.lnum,\n\t\t\t\tcurwin->w_cursor.col, text, NULL, find_type);\n}\n\n/*\n * Like find_ident_under_cursor(), but for any window and any position.\n * However: Uses 'iskeyword' from the current window!.\n */\n    int\nfind_ident_at_pos(\n    win_T\t*wp,\n    linenr_T\tlnum,\n    colnr_T\tstartcol,\n    char_u\t**text,\n    int\t\t*textcol,\t// column where \"text\" starts, can be NULL\n    int\t\tfind_type)\n{\n    char_u\t*ptr;\n    int\t\tcol = 0;\t// init to shut up GCC\n    int\t\ti;\n    int\t\tthis_class = 0;\n    int\t\tprev_class;\n    int\t\tprevcol;\n    int\t\tbn = 0;\t\t// bracket nesting\n\n    /*\n     * if i == 0: try to find an identifier\n     * if i == 1: try to find any non-white text\n     */\n    ptr = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    for (i = (find_type & FIND_IDENT) ? 0 : 1;\ti < 2; ++i)\n    {\n\t/*\n\t * 1. skip to start of identifier/text\n\t */\n\tcol = startcol;\n\tif (has_mbyte)\n\t{\n\t    while (ptr[col] != NUL)\n\t    {\n\t\t// Stop at a ']' to evaluate \"a[x]\".\n\t\tif ((find_type & FIND_EVAL) && ptr[col] == ']')\n\t\t    break;\n\t\tthis_class = mb_get_class(ptr + col);\n\t\tif (this_class != 0 && (i == 1 || this_class != 1))\n\t\t    break;\n\t\tcol += (*mb_ptr2len)(ptr + col);\n\t    }\n\t}\n\telse\n\t    while (ptr[col] != NUL\n\t\t    && (i == 0 ? !vim_iswordc(ptr[col]) : VIM_ISWHITE(ptr[col]))\n\t\t    && (!(find_type & FIND_EVAL) || ptr[col] != ']')\n\t\t    )\n\t\t++col;\n\n\t// When starting on a ']' count it, so that we include the '['.\n\tbn = ptr[col] == ']';\n\n\t/*\n\t * 2. Back up to start of identifier/text.\n\t */\n\tif (has_mbyte)\n\t{\n\t    // Remember class of character under cursor.\n\t    if ((find_type & FIND_EVAL) && ptr[col] == ']')\n\t\tthis_class = mb_get_class((char_u *)\"a\");\n\t    else\n\t\tthis_class = mb_get_class(ptr + col);\n\t    while (col > 0 && this_class != 0)\n\t    {\n\t\tprevcol = col - 1 - (*mb_head_off)(ptr, ptr + col - 1);\n\t\tprev_class = mb_get_class(ptr + prevcol);\n\t\tif (this_class != prev_class\n\t\t\t&& (i == 0\n\t\t\t    || prev_class == 0\n\t\t\t    || (find_type & FIND_IDENT))\n\t\t\t&& (!(find_type & FIND_EVAL)\n\t\t\t    || prevcol == 0\n\t\t\t    || !find_is_eval_item(ptr + prevcol, &prevcol,\n\t\t\t\t\t\t\t       &bn, BACKWARD))\n\t\t\t)\n\t\t    break;\n\t\tcol = prevcol;\n\t    }\n\n\t    // If we don't want just any old text, or we've found an\n\t    // identifier, stop searching.\n\t    if (this_class > 2)\n\t\tthis_class = 2;\n\t    if (!(find_type & FIND_STRING) || this_class == 2)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    while (col > 0\n\t\t    && ((i == 0\n\t\t\t    ? vim_iswordc(ptr[col - 1])\n\t\t\t    : (!VIM_ISWHITE(ptr[col - 1])\n\t\t\t\t&& (!(find_type & FIND_IDENT)\n\t\t\t\t    || !vim_iswordc(ptr[col - 1]))))\n\t\t\t|| ((find_type & FIND_EVAL)\n\t\t\t    && col > 1\n\t\t\t    && find_is_eval_item(ptr + col - 1, &col,\n\t\t\t\t\t\t\t       &bn, BACKWARD))\n\t\t\t))\n\t\t--col;\n\n\t    // If we don't want just any old text, or we've found an\n\t    // identifier, stop searching.\n\t    if (!(find_type & FIND_STRING) || vim_iswordc(ptr[col]))\n\t\tbreak;\n\t}\n    }\n\n    if (ptr[col] == NUL || (i == 0\n\t\t&& (has_mbyte ? this_class != 2 : !vim_iswordc(ptr[col]))))\n    {\n\t// didn't find an identifier or text\n\tif ((find_type & FIND_NOERROR) == 0)\n\t{\n\t    if (find_type & FIND_STRING)\n\t\temsg(_(\"E348: No string under cursor\"));\n\t    else\n\t\temsg(_(e_noident));\n\t}\n\treturn 0;\n    }\n    ptr += col;\n    *text = ptr;\n    if (textcol != NULL)\n\t*textcol = col;\n\n    /*\n     * 3. Find the end if the identifier/text.\n     */\n    bn = 0;\n    startcol -= col;\n    col = 0;\n    if (has_mbyte)\n    {\n\t// Search for point of changing multibyte character class.\n\tthis_class = mb_get_class(ptr);\n\twhile (ptr[col] != NUL\n\t\t&& ((i == 0 ? mb_get_class(ptr + col) == this_class\n\t\t\t    : mb_get_class(ptr + col) != 0)\n\t\t    || ((find_type & FIND_EVAL)\n\t\t\t&& col <= (int)startcol\n\t\t\t&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))\n\t\t))\n\t    col += (*mb_ptr2len)(ptr + col);\n    }\n    else\n\twhile ((i == 0 ? vim_iswordc(ptr[col])\n\t\t       : (ptr[col] != NUL && !VIM_ISWHITE(ptr[col])))\n\t\t    || ((find_type & FIND_EVAL)\n\t\t\t&& col <= (int)startcol\n\t\t\t&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))\n\t\t)\n\t    ++col;\n\n    return col;\n}\n\n/*\n * Prepare for redo of a normal command.\n */\n    static void\nprep_redo_cmd(cmdarg_T *cap)\n{\n    prep_redo(cap->oap->regname, cap->count0,\n\t\t\t\t     NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n}\n\n/*\n * Prepare for redo of any command.\n * Note that only the last argument can be a multi-byte char.\n */\n    void\nprep_redo(\n    int\t    regname,\n    long    num,\n    int\t    cmd1,\n    int\t    cmd2,\n    int\t    cmd3,\n    int\t    cmd4,\n    int\t    cmd5)\n{\n    ResetRedobuff();\n    if (regname != 0)\t// yank from specified buffer\n    {\n\tAppendCharToRedobuff('\"');\n\tAppendCharToRedobuff(regname);\n    }\n    if (num)\n\tAppendNumberToRedobuff(num);\n\n    if (cmd1 != NUL)\n\tAppendCharToRedobuff(cmd1);\n    if (cmd2 != NUL)\n\tAppendCharToRedobuff(cmd2);\n    if (cmd3 != NUL)\n\tAppendCharToRedobuff(cmd3);\n    if (cmd4 != NUL)\n\tAppendCharToRedobuff(cmd4);\n    if (cmd5 != NUL)\n\tAppendCharToRedobuff(cmd5);\n}\n\n/*\n * check for operator active and clear it\n *\n * return TRUE if operator was active\n */\n    static int\ncheckclearop(oparg_T *oap)\n{\n    if (oap->op_type == OP_NOP)\n\treturn FALSE;\n    clearopbeep(oap);\n    return TRUE;\n}\n\n/*\n * Check for operator or Visual active.  Clear active operator.\n *\n * Return TRUE if operator or Visual was active.\n */\n    static int\ncheckclearopq(oparg_T *oap)\n{\n    if (oap->op_type == OP_NOP && !VIsual_active)\n\treturn FALSE;\n    clearopbeep(oap);\n    return TRUE;\n}\n\n    void\nclearop(oparg_T *oap)\n{\n    oap->op_type = OP_NOP;\n    oap->regname = 0;\n    oap->motion_force = NUL;\n    oap->use_reg_one = FALSE;\n    motion_force = NUL;\n}\n\n    void\nclearopbeep(oparg_T *oap)\n{\n    clearop(oap);\n    beep_flush();\n}\n\n/*\n * Remove the shift modifier from a special key.\n */\n    static void\nunshift_special(cmdarg_T *cap)\n{\n    switch (cap->cmdchar)\n    {\n\tcase K_S_RIGHT:\tcap->cmdchar = K_RIGHT; break;\n\tcase K_S_LEFT:\tcap->cmdchar = K_LEFT; break;\n\tcase K_S_UP:\tcap->cmdchar = K_UP; break;\n\tcase K_S_DOWN:\tcap->cmdchar = K_DOWN; break;\n\tcase K_S_HOME:\tcap->cmdchar = K_HOME; break;\n\tcase K_S_END:\tcap->cmdchar = K_END; break;\n    }\n    cap->cmdchar = simplify_key(cap->cmdchar, &mod_mask);\n}\n\n/*\n * If the mode is currently displayed clear the command line or update the\n * command displayed.\n */\n    void\nmay_clear_cmdline(void)\n{\n    if (mode_displayed)\n\tclear_cmdline = TRUE;   // unshow visual mode later\n#ifdef FEAT_CMDL_INFO\n    else\n\tclear_showcmd();\n#endif\n}\n\n#if defined(FEAT_CMDL_INFO) || defined(PROTO)\n/*\n * Routines for displaying a partly typed command\n */\n\n#define SHOWCMD_BUFLEN SHOWCMD_COLS + 1 + 30\nstatic char_u\tshowcmd_buf[SHOWCMD_BUFLEN];\nstatic char_u\told_showcmd_buf[SHOWCMD_BUFLEN];  // For push_showcmd()\nstatic int\tshowcmd_is_clear = TRUE;\nstatic int\tshowcmd_visual = FALSE;\n\nstatic void display_showcmd(void);\n\n    void\nclear_showcmd(void)\n{\n    if (!p_sc)\n\treturn;\n\n    if (VIsual_active && !char_avail())\n    {\n\tint\t\tcursor_bot = LT_POS(VIsual, curwin->w_cursor);\n\tlong\t\tlines;\n\tcolnr_T\t\tleftcol, rightcol;\n\tlinenr_T\ttop, bot;\n\n\t// Show the size of the Visual area.\n\tif (cursor_bot)\n\t{\n\t    top = VIsual.lnum;\n\t    bot = curwin->w_cursor.lnum;\n\t}\n\telse\n\t{\n\t    top = curwin->w_cursor.lnum;\n\t    bot = VIsual.lnum;\n\t}\n# ifdef FEAT_FOLDING\n\t// Include closed folds as a whole.\n\t(void)hasFolding(top, &top, NULL);\n\t(void)hasFolding(bot, NULL, &bot);\n# endif\n\tlines = bot - top + 1;\n\n\tif (VIsual_mode == Ctrl_V)\n\t{\n# ifdef FEAT_LINEBREAK\n\t    char_u *saved_sbr = p_sbr;\n\t    char_u *saved_w_sbr = curwin->w_p_sbr;\n\n\t    // Make 'sbr' empty for a moment to get the correct size.\n\t    p_sbr = empty_option;\n\t    curwin->w_p_sbr = empty_option;\n# endif\n\t    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);\n# ifdef FEAT_LINEBREAK\n\t    p_sbr = saved_sbr;\n\t    curwin->w_p_sbr = saved_w_sbr;\n# endif\n\t    sprintf((char *)showcmd_buf, \"%ldx%ld\", lines,\n\t\t\t\t\t      (long)(rightcol - leftcol + 1));\n\t}\n\telse if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)\n\t    sprintf((char *)showcmd_buf, \"%ld\", lines);\n\telse\n\t{\n\t    char_u  *s, *e;\n\t    int\t    l;\n\t    int\t    bytes = 0;\n\t    int\t    chars = 0;\n\n\t    if (cursor_bot)\n\t    {\n\t\ts = ml_get_pos(&VIsual);\n\t\te = ml_get_cursor();\n\t    }\n\t    else\n\t    {\n\t\ts = ml_get_cursor();\n\t\te = ml_get_pos(&VIsual);\n\t    }\n\t    while ((*p_sel != 'e') ? s <= e : s < e)\n\t    {\n\t\tl = (*mb_ptr2len)(s);\n\t\tif (l == 0)\n\t\t{\n\t\t    ++bytes;\n\t\t    ++chars;\n\t\t    break;  // end of line\n\t\t}\n\t\tbytes += l;\n\t\t++chars;\n\t\ts += l;\n\t    }\n\t    if (bytes == chars)\n\t\tsprintf((char *)showcmd_buf, \"%d\", chars);\n\t    else\n\t\tsprintf((char *)showcmd_buf, \"%d-%d\", chars, bytes);\n\t}\n\tshowcmd_buf[SHOWCMD_COLS] = NUL;\t// truncate\n\tshowcmd_visual = TRUE;\n    }\n    else\n    {\n\tshowcmd_buf[0] = NUL;\n\tshowcmd_visual = FALSE;\n\n\t// Don't actually display something if there is nothing to clear.\n\tif (showcmd_is_clear)\n\t    return;\n    }\n\n    display_showcmd();\n}\n\n/*\n * Add 'c' to string of shown command chars.\n * Return TRUE if output has been written (and setcursor() has been called).\n */\n    int\nadd_to_showcmd(int c)\n{\n    char_u\t*p;\n    int\t\told_len;\n    int\t\textra_len;\n    int\t\toverflow;\n    int\t\ti;\n    static int\tignore[] =\n    {\n#ifdef FEAT_GUI\n\tK_VER_SCROLLBAR, K_HOR_SCROLLBAR,\n\tK_LEFTMOUSE_NM, K_LEFTRELEASE_NM,\n#endif\n\tK_IGNORE, K_PS,\n\tK_LEFTMOUSE, K_LEFTDRAG, K_LEFTRELEASE, K_MOUSEMOVE,\n\tK_MIDDLEMOUSE, K_MIDDLEDRAG, K_MIDDLERELEASE,\n\tK_RIGHTMOUSE, K_RIGHTDRAG, K_RIGHTRELEASE,\n\tK_MOUSEDOWN, K_MOUSEUP, K_MOUSELEFT, K_MOUSERIGHT,\n\tK_X1MOUSE, K_X1DRAG, K_X1RELEASE, K_X2MOUSE, K_X2DRAG, K_X2RELEASE,\n\tK_CURSORHOLD,\n\t0\n    };\n\n    if (!p_sc || msg_silent != 0)\n\treturn FALSE;\n\n    if (showcmd_visual)\n    {\n\tshowcmd_buf[0] = NUL;\n\tshowcmd_visual = FALSE;\n    }\n\n    // Ignore keys that are scrollbar updates and mouse clicks\n    if (IS_SPECIAL(c))\n\tfor (i = 0; ignore[i] != 0; ++i)\n\t    if (ignore[i] == c)\n\t\treturn FALSE;\n\n    p = transchar(c);\n    if (*p == ' ')\n\tSTRCPY(p, \"<20>\");\n    old_len = (int)STRLEN(showcmd_buf);\n    extra_len = (int)STRLEN(p);\n    overflow = old_len + extra_len - SHOWCMD_COLS;\n    if (overflow > 0)\n\tmch_memmove(showcmd_buf, showcmd_buf + overflow,\n\t\t\t\t\t\t      old_len - overflow + 1);\n    STRCAT(showcmd_buf, p);\n\n    if (char_avail())\n\treturn FALSE;\n\n    display_showcmd();\n\n    return TRUE;\n}\n\n    void\nadd_to_showcmd_c(int c)\n{\n    if (!add_to_showcmd(c))\n\tsetcursor();\n}\n\n/*\n * Delete 'len' characters from the end of the shown command.\n */\n    static void\ndel_from_showcmd(int len)\n{\n    int\t    old_len;\n\n    if (!p_sc)\n\treturn;\n\n    old_len = (int)STRLEN(showcmd_buf);\n    if (len > old_len)\n\tlen = old_len;\n    showcmd_buf[old_len - len] = NUL;\n\n    if (!char_avail())\n\tdisplay_showcmd();\n}\n\n/*\n * push_showcmd() and pop_showcmd() are used when waiting for the user to type\n * something and there is a partial mapping.\n */\n    void\npush_showcmd(void)\n{\n    if (p_sc)\n\tSTRCPY(old_showcmd_buf, showcmd_buf);\n}\n\n    void\npop_showcmd(void)\n{\n    if (!p_sc)\n\treturn;\n\n    STRCPY(showcmd_buf, old_showcmd_buf);\n\n    display_showcmd();\n}\n\n    static void\ndisplay_showcmd(void)\n{\n    int\t    len;\n\n    cursor_off();\n\n    len = (int)STRLEN(showcmd_buf);\n    if (len == 0)\n\tshowcmd_is_clear = TRUE;\n    else\n    {\n\tscreen_puts(showcmd_buf, (int)Rows - 1, sc_col, 0);\n\tshowcmd_is_clear = FALSE;\n    }\n\n    /*\n     * clear the rest of an old message by outputting up to SHOWCMD_COLS\n     * spaces\n     */\n    screen_puts((char_u *)\"          \" + len, (int)Rows - 1, sc_col + len, 0);\n\n    setcursor();\t    // put cursor back where it belongs\n}\n#endif\n\n/*\n * When \"check\" is FALSE, prepare for commands that scroll the window.\n * When \"check\" is TRUE, take care of scroll-binding after the window has\n * scrolled.  Called from normal_cmd() and edit().\n */\n    void\ndo_check_scrollbind(int check)\n{\n    static win_T\t*old_curwin = NULL;\n    static linenr_T\told_topline = 0;\n#ifdef FEAT_DIFF\n    static int\t\told_topfill = 0;\n#endif\n    static buf_T\t*old_buf = NULL;\n    static colnr_T\told_leftcol = 0;\n\n    if (check && curwin->w_p_scb)\n    {\n\t// If a \":syncbind\" command was just used, don't scroll, only reset\n\t// the values.\n\tif (did_syncbind)\n\t    did_syncbind = FALSE;\n\telse if (curwin == old_curwin)\n\t{\n\t    /*\n\t     * Synchronize other windows, as necessary according to\n\t     * 'scrollbind'.  Don't do this after an \":edit\" command, except\n\t     * when 'diff' is set.\n\t     */\n\t    if ((curwin->w_buffer == old_buf\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_p_diff\n#endif\n\t\t)\n\t\t&& (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t\t|| curwin->w_leftcol != old_leftcol))\n\t    {\n\t\tcheck_scrollbind(curwin->w_topline - old_topline,\n\t\t\t(long)(curwin->w_leftcol - old_leftcol));\n\t    }\n\t}\n\telse if (vim_strchr(p_sbo, 'j')) // jump flag set in 'scrollopt'\n\t{\n\t    /*\n\t     * When switching between windows, make sure that the relative\n\t     * vertical offset is valid for the new window.  The relative\n\t     * offset is invalid whenever another 'scrollbind' window has\n\t     * scrolled to a point that would force the current window to\n\t     * scroll past the beginning or end of its buffer.  When the\n\t     * resync is performed, some of the other 'scrollbind' windows may\n\t     * need to jump so that the current window's relative position is\n\t     * visible on-screen.\n\t     */\n\t    check_scrollbind(curwin->w_topline - curwin->w_scbind_pos, 0L);\n\t}\n\tcurwin->w_scbind_pos = curwin->w_topline;\n    }\n\n    old_curwin = curwin;\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n    old_buf = curwin->w_buffer;\n    old_leftcol = curwin->w_leftcol;\n}\n\n/*\n * Synchronize any windows that have \"scrollbind\" set, based on the\n * number of rows by which the current window has changed\n * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)\n */\n    void\ncheck_scrollbind(linenr_T topline_diff, long leftcol_diff)\n{\n    int\t\twant_ver;\n    int\t\twant_hor;\n    win_T\t*old_curwin = curwin;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\told_VIsual_select = VIsual_select;\n    int\t\told_VIsual_active = VIsual_active;\n    colnr_T\ttgt_leftcol = curwin->w_leftcol;\n    long\ttopline;\n    long\ty;\n\n    /*\n     * check 'scrollopt' string for vertical and horizontal scroll options\n     */\n    want_ver = (vim_strchr(p_sbo, 'v') && topline_diff != 0);\n#ifdef FEAT_DIFF\n    want_ver |= old_curwin->w_p_diff;\n#endif\n    want_hor = (vim_strchr(p_sbo, 'h') && (leftcol_diff || topline_diff != 0));\n\n    /*\n     * loop through the scrollbound windows and scroll accordingly\n     */\n    VIsual_select = VIsual_active = 0;\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tcurbuf = curwin->w_buffer;\n\t// skip original window  and windows with 'noscrollbind'\n\tif (curwin != old_curwin && curwin->w_p_scb)\n\t{\n\t    /*\n\t     * do the vertical scroll\n\t     */\n\t    if (want_ver)\n\t    {\n#ifdef FEAT_DIFF\n\t\tif (old_curwin->w_p_diff && curwin->w_p_diff)\n\t\t{\n\t\t    diff_set_topline(old_curwin, curwin);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    curwin->w_scbind_pos += topline_diff;\n\t\t    topline = curwin->w_scbind_pos;\n\t\t    if (topline > curbuf->b_ml.ml_line_count)\n\t\t\ttopline = curbuf->b_ml.ml_line_count;\n\t\t    if (topline < 1)\n\t\t\ttopline = 1;\n\n\t\t    y = topline - curwin->w_topline;\n\t\t    if (y > 0)\n\t\t\tscrollup(y, FALSE);\n\t\t    else\n\t\t\tscrolldown(-y, FALSE);\n\t\t}\n\n\t\tredraw_later(VALID);\n\t\tcursor_correct();\n\t\tcurwin->w_redr_status = TRUE;\n\t    }\n\n\t    /*\n\t     * do the horizontal scroll\n\t     */\n\t    if (want_hor && curwin->w_leftcol != tgt_leftcol)\n\t    {\n\t\tcurwin->w_leftcol = tgt_leftcol;\n\t\tleftcol_changed();\n\t    }\n\t}\n    }\n\n    /*\n     * reset current-window\n     */\n    VIsual_select = old_VIsual_select;\n    VIsual_active = old_VIsual_active;\n    curwin = old_curwin;\n    curbuf = old_curbuf;\n}\n\n/*\n * Command character that's ignored.\n * Used for CTRL-Q and CTRL-S to avoid problems with terminals that use\n * xon/xoff.\n */\n    static void\nnv_ignore(cmdarg_T *cap)\n{\n    cap->retval |= CA_COMMAND_BUSY;\t// don't call edit() now\n}\n\n/*\n * Command character that doesn't do anything, but unlike nv_ignore() does\n * start edit().  Used for \"startinsert\" executed while starting up.\n */\n    static void\nnv_nop(cmdarg_T *cap UNUSED)\n{\n}\n\n/*\n * Command character doesn't exist.\n */\n    static void\nnv_error(cmdarg_T *cap)\n{\n    clearopbeep(cap->oap);\n}\n\n/*\n * <Help> and <F1> commands.\n */\n    static void\nnv_help(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\tex_help(NULL);\n}\n\n/*\n * CTRL-A and CTRL-X: Add or subtract from letter or number under cursor.\n */\n    static void\nnv_addsub(cmdarg_T *cap)\n{\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n\tclearopbeep(cap->oap);\n    else\n#endif\n    if (!VIsual_active && cap->oap->op_type == OP_NOP)\n    {\n\tprep_redo_cmd(cap);\n\tcap->oap->op_type = cap->cmdchar == Ctrl_A ?  OP_NR_ADD : OP_NR_SUB;\n\top_addsub(cap->oap, cap->count1, cap->arg);\n\tcap->oap->op_type = OP_NOP;\n    }\n    else if (VIsual_active)\n\tnv_operator(cap);\n    else\n\tclearop(cap->oap);\n}\n\n/*\n * CTRL-F, CTRL-B, etc: Scroll page up or down.\n */\n    static void\nnv_page(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n\tif (mod_mask & MOD_MASK_CTRL)\n\t{\n\t    // <C-PageUp>: tab page back; <C-PageDown>: tab page forward\n\t    if (cap->arg == BACKWARD)\n\t\tgoto_tabpage(-(int)cap->count1);\n\t    else\n\t\tgoto_tabpage((int)cap->count0);\n\t}\n\telse\n\t    (void)onepage(cap->arg, cap->count1);\n    }\n}\n\n/*\n * Implementation of \"gd\" and \"gD\" command.\n */\n    static void\nnv_gd(\n    oparg_T\t*oap,\n    int\t\tnchar,\n    int\t\tthisblock)\t// 1 for \"1gd\" and \"1gD\"\n{\n    int\t\tlen;\n    char_u\t*ptr;\n\n    if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0\n\t    || find_decl(ptr, len, nchar == 'd', thisblock, SEARCH_START)\n\t\t\t\t\t\t\t\t      == FAIL)\n\tclearopbeep(oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_SEARCH) && KeyTyped && oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Return TRUE if line[offset] is not inside a C-style comment or string, FALSE\n * otherwise.\n */\n    static int\nis_ident(char_u *line, int offset)\n{\n    int\ti;\n    int\tincomment = FALSE;\n    int\tinstring = 0;\n    int\tprev = 0;\n\n    for (i = 0; i < offset && line[i] != NUL; i++)\n    {\n\tif (instring != 0)\n\t{\n\t    if (prev != '\\\\' && line[i] == instring)\n\t\tinstring = 0;\n\t}\n\telse if ((line[i] == '\"' || line[i] == '\\'') && !incomment)\n\t{\n\t    instring = line[i];\n\t}\n\telse\n\t{\n\t    if (incomment)\n\t    {\n\t\tif (prev == '*' && line[i] == '/')\n\t\t    incomment = FALSE;\n\t    }\n\t    else if (prev == '/' && line[i] == '*')\n\t    {\n\t\tincomment = TRUE;\n\t    }\n\t    else if (prev == '/' && line[i] == '/')\n\t    {\n\t\treturn FALSE;\n\t    }\n\t}\n\n\tprev = line[i];\n    }\n\n    return incomment == FALSE && instring == 0;\n}\n\n/*\n * Search for variable declaration of \"ptr[len]\".\n * When \"locally\" is TRUE in the current function (\"gd\"), otherwise in the\n * current file (\"gD\").\n * When \"thisblock\" is TRUE check the {} block scope.\n * Return FAIL when not found.\n */\n    int\nfind_decl(\n    char_u\t*ptr,\n    int\t\tlen,\n    int\t\tlocally,\n    int\t\tthisblock,\n    int\t\tflags_arg)\t// flags passed to searchit()\n{\n    char_u\t*pat;\n    pos_T\told_pos;\n    pos_T\tpar_pos;\n    pos_T\tfound_pos;\n    int\t\tt;\n    int\t\tsave_p_ws;\n    int\t\tsave_p_scs;\n    int\t\tretval = OK;\n    int\t\tincll;\n    int\t\tsearchflags = flags_arg;\n    int\t\tvalid;\n\n    if ((pat = alloc(len + 7)) == NULL)\n\treturn FAIL;\n\n    // Put \"\\V\" before the pattern to avoid that the special meaning of \".\"\n    // and \"~\" causes trouble.\n    sprintf((char *)pat, vim_iswordp(ptr) ? \"\\\\V\\\\<%.*s\\\\>\" : \"\\\\V%.*s\",\n\t\t\t\t\t\t\t\t    len, ptr);\n    old_pos = curwin->w_cursor;\n    save_p_ws = p_ws;\n    save_p_scs = p_scs;\n    p_ws = FALSE;\t// don't wrap around end of file now\n    p_scs = FALSE;\t// don't switch ignorecase off now\n\n    /*\n     * With \"gD\" go to line 1.\n     * With \"gd\" Search back for the start of the current function, then go\n     * back until a blank line.  If this fails go to line 1.\n     */\n    if (!locally || !findpar(&incll, BACKWARD, 1L, '{', FALSE))\n    {\n\tsetpcmark();\t\t\t// Set in findpar() otherwise\n\tcurwin->w_cursor.lnum = 1;\n\tpar_pos = curwin->w_cursor;\n    }\n    else\n    {\n\tpar_pos = curwin->w_cursor;\n\twhile (curwin->w_cursor.lnum > 1 && *skipwhite(ml_get_curline()) != NUL)\n\t    --curwin->w_cursor.lnum;\n    }\n    curwin->w_cursor.col = 0;\n\n    // Search forward for the identifier, ignore comment lines.\n    CLEAR_POS(&found_pos);\n    for (;;)\n    {\n\tt = searchit(curwin, curbuf, &curwin->w_cursor, NULL, FORWARD,\n\t\t\t\t\t  pat, 1L, searchflags, RE_LAST, NULL);\n\tif (curwin->w_cursor.lnum >= old_pos.lnum)\n\t    t = FAIL;\t// match after start is failure too\n\n\tif (thisblock && t != FAIL)\n\t{\n\t    pos_T\t*pos;\n\n\t    // Check that the block the match is in doesn't end before the\n\t    // position where we started the search from.\n\t    if ((pos = findmatchlimit(NULL, '}', FM_FORWARD,\n\t\t     (int)(old_pos.lnum - curwin->w_cursor.lnum + 1))) != NULL\n\t\t    && pos->lnum < old_pos.lnum)\n\t    {\n\t\t// There can't be a useful match before the end of this block.\n\t\t// Skip to the end.\n\t\tcurwin->w_cursor = *pos;\n\t\tcontinue;\n\t    }\n\t}\n\n\tif (t == FAIL)\n\t{\n\t    // If we previously found a valid position, use it.\n\t    if (found_pos.lnum != 0)\n\t    {\n\t\tcurwin->w_cursor = found_pos;\n\t\tt = OK;\n\t    }\n\t    break;\n\t}\n\tif (get_leader_len(ml_get_curline(), NULL, FALSE, TRUE) > 0)\n\t{\n\t    // Ignore this line, continue at start of next line.\n\t    ++curwin->w_cursor.lnum;\n\t    curwin->w_cursor.col = 0;\n\t    continue;\n\t}\n\tvalid = is_ident(ml_get_curline(), curwin->w_cursor.col);\n\n\t// If the current position is not a valid identifier and a previous\n\t// match is present, favor that one instead.\n\tif (!valid && found_pos.lnum != 0)\n\t{\n\t    curwin->w_cursor = found_pos;\n\t    break;\n\t}\n\n\t// Global search: use first valid match found\n\tif (valid && !locally)\n\t    break;\n\tif (valid && curwin->w_cursor.lnum >= par_pos.lnum)\n\t{\n\t    // If we previously found a valid position, use it.\n\t    if (found_pos.lnum != 0)\n\t\tcurwin->w_cursor = found_pos;\n\t    break;\n\t}\n\n\t// For finding a local variable and the match is before the \"{\" or\n\t// inside a comment, continue searching.  For K&R style function\n\t// declarations this skips the function header without types.\n\tif (!valid)\n\t    CLEAR_POS(&found_pos);\n\telse\n\t    found_pos = curwin->w_cursor;\n\t// Remove SEARCH_START from flags to avoid getting stuck at one\n\t// position.\n\tsearchflags &= ~SEARCH_START;\n    }\n\n    if (t == FAIL)\n    {\n\tretval = FAIL;\n\tcurwin->w_cursor = old_pos;\n    }\n    else\n    {\n\tcurwin->w_set_curswant = TRUE;\n\t// \"n\" searches forward now\n\treset_search_dir();\n    }\n\n    vim_free(pat);\n    p_ws = save_p_ws;\n    p_scs = save_p_scs;\n\n    return retval;\n}\n\n/*\n * Move 'dist' lines in direction 'dir', counting lines by *screen*\n * lines rather than lines in the file.\n * 'dist' must be positive.\n *\n * Return OK if able to move cursor, FAIL otherwise.\n */\n    static int\nnv_screengo(oparg_T *oap, int dir, long dist)\n{\n    int\t\tlinelen = linetabsize(ml_get_curline());\n    int\t\tretval = OK;\n    int\t\tatend = FALSE;\n    int\t\tn;\n    int\t\tcol_off1;\t// margin offset for first screen line\n    int\t\tcol_off2;\t// margin offset for wrapped screen line\n    int\t\twidth1;\t\t// text width for first screen line\n    int\t\twidth2;\t\t// test width for wrapped screen line\n\n    oap->motion_type = MCHAR;\n    oap->inclusive = (curwin->w_curswant == MAXCOL);\n\n    col_off1 = curwin_col_off();\n    col_off2 = col_off1 - curwin_col_off2();\n    width1 = curwin->w_width - col_off1;\n    width2 = curwin->w_width - col_off2;\n    if (width2 == 0)\n\twidth2 = 1; // avoid divide by zero\n\n    if (curwin->w_width != 0)\n    {\n      /*\n       * Instead of sticking at the last character of the buffer line we\n       * try to stick in the last column of the screen.\n       */\n      if (curwin->w_curswant == MAXCOL)\n      {\n\tatend = TRUE;\n\tvalidate_virtcol();\n\tif (width1 <= 0)\n\t    curwin->w_curswant = 0;\n\telse\n\t{\n\t    curwin->w_curswant = width1 - 1;\n\t    if (curwin->w_virtcol > curwin->w_curswant)\n\t\tcurwin->w_curswant += ((curwin->w_virtcol\n\t\t\t     - curwin->w_curswant - 1) / width2 + 1) * width2;\n\t}\n      }\n      else\n      {\n\tif (linelen > width1)\n\t    n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n\telse\n\t    n = width1;\n\tif (curwin->w_curswant >= (colnr_T)n)\n\t    curwin->w_curswant = n - 1;\n      }\n\n      while (dist--)\n      {\n\tif (dir == BACKWARD)\n\t{\n\t    if ((long)curwin->w_curswant >= width1\n#ifdef FEAT_FOLDING\n\t\t    && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)\n#endif\n\t       )\n\t\t// Move back within the line. This can give a negative value\n\t\t// for w_curswant if width1 < width2 (with cpoptions+=n),\n\t\t// which will get clipped to column 0.\n\t\tcurwin->w_curswant -= width2;\n\t    else\n\t    {\n\t\t// to previous line\n#ifdef FEAT_FOLDING\n\t\t// Move to the start of a closed fold.  Don't do that when\n\t\t// 'foldopen' contains \"all\": it will open in a moment.\n\t\tif (!(fdo_flags & FDO_ALL))\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n#endif\n\t\tif (curwin->w_cursor.lnum == 1)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\t--curwin->w_cursor.lnum;\n\n\t\tlinelen = linetabsize(ml_get_curline());\n\t\tif (linelen > width1)\n\t\t    curwin->w_curswant += (((linelen - width1 - 1) / width2)\n\t\t\t\t\t\t\t\t+ 1) * width2;\n\t    }\n\t}\n\telse // dir == FORWARD\n\t{\n\t    if (linelen > width1)\n\t\tn = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n\t    else\n\t\tn = width1;\n\t    if (curwin->w_curswant + width2 < (colnr_T)n\n#ifdef FEAT_FOLDING\n\t\t    && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)\n#endif\n\t\t    )\n\t\t// move forward within line\n\t\tcurwin->w_curswant += width2;\n\t    else\n\t    {\n\t\t// to next line\n#ifdef FEAT_FOLDING\n\t\t// Move to the end of a closed fold.\n\t\t(void)hasFolding(curwin->w_cursor.lnum, NULL,\n\t\t\t\t\t\t      &curwin->w_cursor.lnum);\n#endif\n\t\tif (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\tcurwin->w_cursor.lnum++;\n\t\tcurwin->w_curswant %= width2;\n\t\t// Check if the cursor has moved below the number display\n\t\t// when width1 < width2 (with cpoptions+=n). Subtract width2\n\t\t// to get a negative value for w_curswant, which will get\n\t\t// clipped to column 0.\n\t\tif (curwin->w_curswant >= width1)\n\t\t    curwin->w_curswant -= width2;\n\t\tlinelen = linetabsize(ml_get_curline());\n\t    }\n\t}\n      }\n    }\n\n    if (virtual_active() && atend)\n\tcoladvance(MAXCOL);\n    else\n\tcoladvance(curwin->w_curswant);\n\n    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)\n    {\n\tcolnr_T virtcol;\n\n\t/*\n\t * Check for landing on a character that got split at the end of the\n\t * last line.  We want to advance a screenline, not end up in the same\n\t * screenline or move two screenlines.\n\t */\n\tvalidate_virtcol();\n\tvirtcol = curwin->w_virtcol;\n#if defined(FEAT_LINEBREAK)\n\tif (virtcol > (colnr_T)width1 && *get_showbreak_value(curwin) != NUL)\n\t    virtcol -= vim_strsize(get_showbreak_value(curwin));\n#endif\n\n\tif (virtcol > curwin->w_curswant\n\t\t&& (curwin->w_curswant < (colnr_T)width1\n\t\t    ? (curwin->w_curswant > (colnr_T)width1 / 2)\n\t\t    : ((curwin->w_curswant - width1) % width2\n\t\t\t\t\t\t      > (colnr_T)width2 / 2)))\n\t    --curwin->w_cursor.col;\n    }\n\n    if (atend)\n\tcurwin->w_curswant = MAXCOL;\t    // stick in the last column\n\n    return retval;\n}\n\n/*\n * Handle CTRL-E and CTRL-Y commands: scroll a line up or down.\n * cap->arg must be TRUE for CTRL-E.\n */\n    void\nnv_scroll_line(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n\tscroll_redraw(cap->arg, cap->count1);\n}\n\n/*\n * Scroll \"count\" lines up or down, and redraw.\n */\n    void\nscroll_redraw(int up, long count)\n{\n    linenr_T\tprev_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    int\t\tprev_topfill = curwin->w_topfill;\n#endif\n    linenr_T\tprev_lnum = curwin->w_cursor.lnum;\n\n    if (up)\n\tscrollup(count, TRUE);\n    else\n\tscrolldown(count, TRUE);\n    if (get_scrolloff_value())\n    {\n\t// Adjust the cursor position for 'scrolloff'.  Mark w_topline as\n\t// valid, otherwise the screen jumps back at the end of the file.\n\tcursor_correct();\n\tcheck_cursor_moved(curwin);\n\tcurwin->w_valid |= VALID_TOPLINE;\n\n\t// If moved back to where we were, at least move the cursor, otherwise\n\t// we get stuck at one position.  Don't move the cursor up if the\n\t// first line of the buffer is already on the screen\n\twhile (curwin->w_topline == prev_topline\n#ifdef FEAT_DIFF\n\t\t&& curwin->w_topfill == prev_topfill\n#endif\n\t\t)\n\t{\n\t    if (up)\n\t    {\n\t\tif (curwin->w_cursor.lnum > prev_lnum\n\t\t\t|| cursor_down(1L, FALSE) == FAIL)\n\t\t    break;\n\t    }\n\t    else\n\t    {\n\t\tif (curwin->w_cursor.lnum < prev_lnum\n\t\t\t|| prev_topline == 1L\n\t\t\t|| cursor_up(1L, FALSE) == FAIL)\n\t\t    break;\n\t    }\n\t    // Mark w_topline as valid, otherwise the screen jumps back at the\n\t    // end of the file.\n\t    check_cursor_moved(curwin);\n\t    curwin->w_valid |= VALID_TOPLINE;\n\t}\n    }\n    if (curwin->w_cursor.lnum != prev_lnum)\n\tcoladvance(curwin->w_curswant);\n    redraw_later(VALID);\n}\n\n/*\n * Commands that start with \"z\".\n */\n    static void\nnv_zet(cmdarg_T *cap)\n{\n    long\tn;\n    colnr_T\tcol;\n    int\t\tnchar = cap->nchar;\n#ifdef FEAT_FOLDING\n    long\told_fdl = curwin->w_p_fdl;\n    int\t\told_fen = curwin->w_p_fen;\n#endif\n#ifdef FEAT_SPELL\n    int\t\tundo = FALSE;\n#endif\n    long        siso = get_sidescrolloff_value();\n\n    if (VIM_ISDIGIT(nchar))\n    {\n\t/*\n\t * \"z123{nchar}\": edit the count before obtaining {nchar}\n\t */\n\tif (checkclearop(cap->oap))\n\t    return;\n\tn = nchar - '0';\n\tfor (;;)\n\t{\n#ifdef USE_ON_FLY_SCROLL\n\t    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t    ++no_mapping;\n\t    ++allow_keys;   // no mapping for nchar, but allow key codes\n\t    nchar = plain_vgetc();\n\t    LANGMAP_ADJUST(nchar, TRUE);\n\t    --no_mapping;\n\t    --allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t    (void)add_to_showcmd(nchar);\n#endif\n\t    if (nchar == K_DEL || nchar == K_KDEL)\n\t\tn /= 10;\n\t    else if (VIM_ISDIGIT(nchar))\n\t\tn = n * 10 + (nchar - '0');\n\t    else if (nchar == CAR)\n\t    {\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight((int)n);\n\t\tbreak;\n\t    }\n\t    else if (nchar == 'l'\n\t\t    || nchar == 'h'\n\t\t    || nchar == K_LEFT\n\t\t    || nchar == K_RIGHT)\n\t    {\n\t\tcap->count1 = n ? n * cap->count1 : cap->count1;\n\t\tgoto dozet;\n\t    }\n\t    else\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t}\n\tcap->oap->op_type = OP_NOP;\n\treturn;\n    }\n\ndozet:\n    if (\n#ifdef FEAT_FOLDING\n\t    // \"zf\" and \"zF\" are always an operator, \"zd\", \"zo\", \"zO\", \"zc\"\n\t    // and \"zC\" only in Visual mode.  \"zj\" and \"zk\" are motion\n\t    // commands.\n\t    cap->nchar != 'f' && cap->nchar != 'F'\n\t    && !(VIsual_active && vim_strchr((char_u *)\"dcCoO\", cap->nchar))\n\t    && cap->nchar != 'j' && cap->nchar != 'k'\n\t    &&\n#endif\n\t    checkclearop(cap->oap))\n\treturn;\n\n    /*\n     * For \"z+\", \"z<CR>\", \"zt\", \"z.\", \"zz\", \"z^\", \"z-\", \"zb\":\n     * If line number given, set cursor.\n     */\n    if ((vim_strchr((char_u *)\"+\\r\\nt.z^-b\", nchar) != NULL)\n\t    && cap->count0\n\t    && cap->count0 != curwin->w_cursor.lnum)\n    {\n\tsetpcmark();\n\tif (cap->count0 > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\telse\n\t    curwin->w_cursor.lnum = cap->count0;\n\tcheck_cursor_col();\n    }\n\n    switch (nchar)\n    {\n\t\t// \"z+\", \"z<CR>\" and \"zt\": put cursor at top of screen\n    case '+':\n\t\tif (cap->count0 == 0)\n\t\t{\n\t\t    // No count given: put cursor at the line below screen\n\t\t    validate_botline();\t// make sure w_botline is valid\n\t\t    if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = curwin->w_botline;\n\t\t}\n\t\t// FALLTHROUGH\n    case NL:\n    case CAR:\n    case K_KENTER:\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 't':\tscroll_cursor_top(0, TRUE);\n\t\tredraw_later(VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"z.\" and \"zz\": put cursor in middle of screen\n    case '.':\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 'z':\tscroll_cursor_halfway(TRUE);\n\t\tredraw_later(VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"z^\", \"z-\" and \"zb\": put cursor at bottom of screen\n    case '^':\t// Strange Vi behavior: <count>z^ finds line at top of window\n\t\t// when <count> is at bottom of window, and puts that one at\n\t\t// bottom of window.\n\t\tif (cap->count0 != 0)\n\t\t{\n\t\t    scroll_cursor_bot(0, TRUE);\n\t\t    curwin->w_cursor.lnum = curwin->w_topline;\n\t\t}\n\t\telse if (curwin->w_topline == 1)\n\t\t    curwin->w_cursor.lnum = 1;\n\t\telse\n\t\t    curwin->w_cursor.lnum = curwin->w_topline - 1;\n\t\t// FALLTHROUGH\n    case '-':\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 'b':\tscroll_cursor_bot(0, TRUE);\n\t\tredraw_later(VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"zH\" - scroll screen right half-page\n    case 'H':\n\t\tcap->count1 *= curwin->w_width / 2;\n\t\t// FALLTHROUGH\n\n\t\t// \"zh\" - scroll screen to the right\n    case 'h':\n    case K_LEFT:\n\t\tif (!curwin->w_p_wrap)\n\t\t{\n\t\t    if ((colnr_T)cap->count1 > curwin->w_leftcol)\n\t\t\tcurwin->w_leftcol = 0;\n\t\t    else\n\t\t\tcurwin->w_leftcol -= (colnr_T)cap->count1;\n\t\t    leftcol_changed();\n\t\t}\n\t\tbreak;\n\n\t\t// \"zL\" - scroll screen left half-page\n    case 'L':\tcap->count1 *= curwin->w_width / 2;\n\t\t// FALLTHROUGH\n\n\t\t// \"zl\" - scroll screen to the left\n    case 'l':\n    case K_RIGHT:\n\t\tif (!curwin->w_p_wrap)\n\t\t{\n\t\t    // scroll the window left\n\t\t    curwin->w_leftcol += (colnr_T)cap->count1;\n\t\t    leftcol_changed();\n\t\t}\n\t\tbreak;\n\n\t\t// \"zs\" - scroll screen, cursor at the start\n    case 's':\tif (!curwin->w_p_wrap)\n\t\t{\n#ifdef FEAT_FOLDING\n\t\t    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t\tcol = 0;\t// like the cursor is in col 0\n\t\t    else\n#endif\n\t\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, NULL);\n\t\t    if ((long)col > siso)\n\t\t\tcol -= siso;\n\t\t    else\n\t\t\tcol = 0;\n\t\t    if (curwin->w_leftcol != col)\n\t\t    {\n\t\t\tcurwin->w_leftcol = col;\n\t\t\tredraw_later(NOT_VALID);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\t// \"ze\" - scroll screen, cursor at the end\n    case 'e':\tif (!curwin->w_p_wrap)\n\t\t{\n#ifdef FEAT_FOLDING\n\t\t    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t\tcol = 0;\t// like the cursor is in col 0\n\t\t    else\n#endif\n\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\t\t    n = curwin->w_width - curwin_col_off();\n\t\t    if ((long)col + siso < n)\n\t\t\tcol = 0;\n\t\t    else\n\t\t\tcol = col + siso - n + 1;\n\t\t    if (curwin->w_leftcol != col)\n\t\t    {\n\t\t\tcurwin->w_leftcol = col;\n\t\t\tredraw_later(NOT_VALID);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\t// \"zp\", \"zP\" in block mode put without addind trailing spaces\n    case 'P':\n    case 'p':  nv_put(cap);\n\t       break;\n\t\t// \"zy\" Yank without trailing spaces\n    case 'y':  nv_operator(cap);\n\t       break;\n#ifdef FEAT_FOLDING\n\t\t// \"zF\": create fold command\n\t\t// \"zf\": create fold operator\n    case 'F':\n    case 'f':   if (foldManualAllowed(TRUE))\n\t\t{\n\t\t    cap->nchar = 'f';\n\t\t    nv_operator(cap);\n\t\t    curwin->w_p_fen = TRUE;\n\n\t\t    // \"zF\" is like \"zfzf\"\n\t\t    if (nchar == 'F' && cap->oap->op_type == OP_FOLD)\n\t\t    {\n\t\t\tnv_operator(cap);\n\t\t\tfinish_op = TRUE;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    clearopbeep(cap->oap);\n\t\tbreak;\n\n\t\t// \"zd\": delete fold at cursor\n\t\t// \"zD\": delete fold at cursor recursively\n    case 'd':\n    case 'D':\tif (foldManualAllowed(FALSE))\n\t\t{\n\t\t    if (VIsual_active)\n\t\t\tnv_operator(cap);\n\t\t    else\n\t\t\tdeleteFold(curwin->w_cursor.lnum,\n\t\t\t\t  curwin->w_cursor.lnum, nchar == 'D', FALSE);\n\t\t}\n\t\tbreak;\n\n\t\t// \"zE\": erase all folds\n    case 'E':\tif (foldmethodIsManual(curwin))\n\t\t{\n\t\t    clearFolding(curwin);\n\t\t    changed_window_setting();\n\t\t}\n\t\telse if (foldmethodIsMarker(curwin))\n\t\t    deleteFold((linenr_T)1, curbuf->b_ml.ml_line_count,\n\t\t\t\t\t\t\t\t TRUE, FALSE);\n\t\telse\n\t\t    emsg(_(\"E352: Cannot erase folds with current 'foldmethod'\"));\n\t\tbreak;\n\n\t\t// \"zn\": fold none: reset 'foldenable'\n    case 'n':\tcurwin->w_p_fen = FALSE;\n\t\tbreak;\n\n\t\t// \"zN\": fold Normal: set 'foldenable'\n    case 'N':\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zi\": invert folding: toggle 'foldenable'\n    case 'i':\tcurwin->w_p_fen = !curwin->w_p_fen;\n\t\tbreak;\n\n\t\t// \"za\": open closed fold or close open fold at cursor\n    case 'a':\tif (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t    openFold(curwin->w_cursor.lnum, cap->count1);\n\t\telse\n\t\t{\n\t\t    closeFold(curwin->w_cursor.lnum, cap->count1);\n\t\t    curwin->w_p_fen = TRUE;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zA\": open fold at cursor recursively\n    case 'A':\tif (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t    openFoldRecurse(curwin->w_cursor.lnum);\n\t\telse\n\t\t{\n\t\t    closeFoldRecurse(curwin->w_cursor.lnum);\n\t\t    curwin->w_p_fen = TRUE;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zo\": open fold at cursor or Visual area\n    case 'o':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    openFold(curwin->w_cursor.lnum, cap->count1);\n\t\tbreak;\n\n\t\t// \"zO\": open fold recursively\n    case 'O':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    openFoldRecurse(curwin->w_cursor.lnum);\n\t\tbreak;\n\n\t\t// \"zc\": close fold at cursor or Visual area\n    case 'c':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    closeFold(curwin->w_cursor.lnum, cap->count1);\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zC\": close fold recursively\n    case 'C':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    closeFoldRecurse(curwin->w_cursor.lnum);\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zv\": open folds at the cursor\n    case 'v':\tfoldOpenCursor();\n\t\tbreak;\n\n\t\t// \"zx\": re-apply 'foldlevel' and open folds at the cursor\n    case 'x':\tcurwin->w_p_fen = TRUE;\n\t\tcurwin->w_foldinvalid = TRUE;\t// recompute folds\n\t\tnewFoldLevel();\t\t\t// update right now\n\t\tfoldOpenCursor();\n\t\tbreak;\n\n\t\t// \"zX\": undo manual opens/closes, re-apply 'foldlevel'\n    case 'X':\tcurwin->w_p_fen = TRUE;\n\t\tcurwin->w_foldinvalid = TRUE;\t// recompute folds\n\t\told_fdl = -1;\t\t\t// force an update\n\t\tbreak;\n\n\t\t// \"zm\": fold more\n    case 'm':\tif (curwin->w_p_fdl > 0)\n\t\t{\n\t\t    curwin->w_p_fdl -= cap->count1;\n\t\t    if (curwin->w_p_fdl < 0)\n\t\t\tcurwin->w_p_fdl = 0;\n\t\t}\n\t\told_fdl = -1;\t\t// force an update\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zM\": close all folds\n    case 'M':\tcurwin->w_p_fdl = 0;\n\t\told_fdl = -1;\t\t// force an update\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zr\": reduce folding\n    case 'r':\tcurwin->w_p_fdl += cap->count1;\n\t\t{\n\t\t    int d = getDeepestNesting();\n\n\t\t    if (curwin->w_p_fdl >= d)\n\t\t\tcurwin->w_p_fdl = d;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zR\": open all folds\n    case 'R':\tcurwin->w_p_fdl = getDeepestNesting();\n\t\told_fdl = -1;\t\t// force an update\n\t\tbreak;\n\n    case 'j':\t// \"zj\" move to next fold downwards\n    case 'k':\t// \"zk\" move to next fold upwards\n\t\tif (foldMoveTo(TRUE, nchar == 'j' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t  cap->count1) == FAIL)\n\t\t    clearopbeep(cap->oap);\n\t\tbreak;\n\n#endif // FEAT_FOLDING\n\n#ifdef FEAT_SPELL\n    case 'u':\t// \"zug\" and \"zuw\": undo \"zg\" and \"zw\"\n\t\t++no_mapping;\n\t\t++allow_keys;   // no mapping for nchar, but allow key codes\n\t\tnchar = plain_vgetc();\n\t\tLANGMAP_ADJUST(nchar, TRUE);\n\t\t--no_mapping;\n\t\t--allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t\t(void)add_to_showcmd(nchar);\n#endif\n\t\tif (vim_strchr((char_u *)\"gGwW\", nchar) == NULL)\n\t\t{\n\t\t    clearopbeep(cap->oap);\n\t\t    break;\n\t\t}\n\t\tundo = TRUE;\n\t\t// FALLTHROUGH\n\n    case 'g':\t// \"zg\": add good word to word list\n    case 'w':\t// \"zw\": add wrong word to word list\n    case 'G':\t// \"zG\": add good word to temp word list\n    case 'W':\t// \"zW\": add wrong word to temp word list\n\t\t{\n\t\t    char_u  *ptr = NULL;\n\t\t    int\t    len;\n\n\t\t    if (checkclearop(cap->oap))\n\t\t\tbreak;\n\t\t    if (VIsual_active && get_visual_text(cap, &ptr, &len)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\treturn;\n\t\t    if (ptr == NULL)\n\t\t    {\n\t\t\tpos_T\tpos = curwin->w_cursor;\n\n\t\t\t// Find bad word under the cursor.  When 'spell' is\n\t\t\t// off this fails and find_ident_under_cursor() is\n\t\t\t// used below.\n\t\t\temsg_off++;\n\t\t\tlen = spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL);\n\t\t\temsg_off--;\n\t\t\tif (len != 0 && curwin->w_cursor.col <= pos.col)\n\t\t\t    ptr = ml_get_pos(&curwin->w_cursor);\n\t\t\tcurwin->w_cursor = pos;\n\t\t    }\n\n\t\t    if (ptr == NULL && (len = find_ident_under_cursor(&ptr,\n\t\t\t\t\t\t\t    FIND_IDENT)) == 0)\n\t\t\treturn;\n\t\t    spell_add_word(ptr, len, nchar == 'w' || nchar == 'W'\n\t\t\t\t\t      ? SPELL_ADD_BAD : SPELL_ADD_GOOD,\n\t\t\t\t\t    (nchar == 'G' || nchar == 'W')\n\t\t\t\t\t\t       ? 0 : (int)cap->count1,\n\t\t\t\t\t    undo);\n\t\t}\n\t\tbreak;\n\n    case '=':\t// \"z=\": suggestions for a badly spelled word\n\t\tif (!checkclearop(cap->oap))\n\t\t    spell_suggest((int)cap->count0);\n\t\tbreak;\n#endif\n\n    default:\tclearopbeep(cap->oap);\n    }\n\n#ifdef FEAT_FOLDING\n    // Redraw when 'foldenable' changed\n    if (old_fen != curwin->w_p_fen)\n    {\n# ifdef FEAT_DIFF\n\twin_T\t    *wp;\n\n\tif (foldmethodIsDiff(curwin) && curwin->w_p_scb)\n\t{\n\t    // Adjust 'foldenable' in diff-synced windows.\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tif (wp != curwin && foldmethodIsDiff(wp) && wp->w_p_scb)\n\t\t{\n\t\t    wp->w_p_fen = curwin->w_p_fen;\n\t\t    changed_window_setting_win(wp);\n\t\t}\n\t    }\n\t}\n# endif\n\tchanged_window_setting();\n    }\n\n    // Redraw when 'foldlevel' changed.\n    if (old_fdl != curwin->w_p_fdl)\n\tnewFoldLevel();\n#endif\n}\n\n#ifdef FEAT_GUI\n/*\n * Vertical scrollbar movement.\n */\n    static void\nnv_ver_scrollbar(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to scroll\n    gui_do_scroll();\n}\n\n/*\n * Horizontal scrollbar movement.\n */\n    static void\nnv_hor_scrollbar(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to scroll\n    gui_do_horiz_scroll(scrollbar_value, FALSE);\n}\n#endif\n\n#if defined(FEAT_GUI_TABLINE) || defined(PROTO)\n/*\n * Click in GUI tab.\n */\n    static void\nnv_tabline(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to jump tabs.\n    goto_tabpage(current_tab);\n}\n\n/*\n * Selected item in tab line menu.\n */\n    static void\nnv_tabmenu(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to jump tabs.\n    handle_tabmenu();\n}\n\n/*\n * Handle selecting an item of the GUI tab line menu.\n * Used in Normal and Insert mode.\n */\n    void\nhandle_tabmenu(void)\n{\n    switch (current_tabmenu)\n    {\n\tcase TABLINE_MENU_CLOSE:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"tabclose\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"tabclose %d\",\n\t\t\t\t\t\t\t\t current_tab);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n\n\tcase TABLINE_MENU_NEW:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"$tabnew\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"%dtabnew\",\n\t\t\t\t\t\t\t     current_tab - 1);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n\n\tcase TABLINE_MENU_OPEN:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"browse $tabnew\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"browse %dtabnew\",\n\t\t\t\t\t\t\t     current_tab - 1);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n    }\n}\n#endif\n\n/*\n * \"Q\" command.\n */\n    static void\nnv_exmode(cmdarg_T *cap)\n{\n    /*\n     * Ignore 'Q' in Visual mode, just give a beep.\n     */\n    if (VIsual_active)\n\tvim_beep(BO_EX);\n    else if (!checkclearop(cap->oap))\n\tdo_exmode(FALSE);\n}\n\n/*\n * Handle a \":\" command.\n */\n    static void\nnv_colon(cmdarg_T *cap)\n{\n    int\told_p_im;\n    int\tcmd_result;\n    int\tis_cmdkey = cap->cmdchar == K_COMMAND;\n\n    if (VIsual_active && !is_cmdkey)\n\tnv_operator(cap);\n    else\n    {\n\tif (cap->oap->op_type != OP_NOP)\n\t{\n\t    // Using \":\" as a movement is characterwise exclusive.\n\t    cap->oap->motion_type = MCHAR;\n\t    cap->oap->inclusive = FALSE;\n\t}\n\telse if (cap->count0 && !is_cmdkey)\n\t{\n\t    // translate \"count:\" into \":.,.+(count - 1)\"\n\t    stuffcharReadbuff('.');\n\t    if (cap->count0 > 1)\n\t    {\n\t\tstuffReadbuff((char_u *)\",.+\");\n\t\tstuffnumReadbuff((long)cap->count0 - 1L);\n\t    }\n\t}\n\n\t// When typing, don't type below an old message\n\tif (KeyTyped)\n\t    compute_cmdrow();\n\n\told_p_im = p_im;\n\n\t// get a command line and execute it\n\tcmd_result = do_cmdline(NULL, is_cmdkey ? getcmdkeycmd : getexline, NULL,\n\t\t\t    cap->oap->op_type != OP_NOP ? DOCMD_KEEPLINE : 0);\n\n\t// If 'insertmode' changed, enter or exit Insert mode\n\tif (p_im != old_p_im)\n\t{\n\t    if (p_im)\n\t\trestart_edit = 'i';\n\t    else\n\t\trestart_edit = 0;\n\t}\n\n\tif (cmd_result == FAIL)\n\t    // The Ex command failed, do not execute the operator.\n\t    clearop(cap->oap);\n\telse if (cap->oap->op_type != OP_NOP\n\t\t&& (cap->oap->start.lnum > curbuf->b_ml.ml_line_count\n\t\t    || cap->oap->start.col >\n\t\t\t       (colnr_T)STRLEN(ml_get(cap->oap->start.lnum))\n\t\t    || did_emsg\n\t\t    ))\n\t    // The start of the operator has become invalid by the Ex command.\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * Handle CTRL-G command.\n */\n    static void\nnv_ctrlg(cmdarg_T *cap)\n{\n    if (VIsual_active)\t// toggle Selection/Visual mode\n    {\n\tVIsual_select = !VIsual_select;\n\tshowmode();\n    }\n    else if (!checkclearop(cap->oap))\n\t// print full name if count given or :cd used\n\tfileinfo((int)cap->count0, FALSE, TRUE);\n}\n\n/*\n * Handle CTRL-H <Backspace> command.\n */\n    static void\nnv_ctrlh(cmdarg_T *cap)\n{\n    if (VIsual_active && VIsual_select)\n    {\n\tcap->cmdchar = 'x';\t// BS key behaves like 'x' in Select mode\n\tv_visop(cap);\n    }\n    else\n\tnv_left(cap);\n}\n\n/*\n * CTRL-L: clear screen and redraw.\n */\n    static void\nnv_clear(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n#ifdef FEAT_SYN_HL\n\t// Clear all syntax states to force resyncing.\n\tsyn_stack_free_all(curwin->w_s);\n# ifdef FEAT_RELTIME\n\t{\n\t    win_T *wp;\n\n\t    FOR_ALL_WINDOWS(wp)\n\t\twp->w_s->b_syn_slow = FALSE;\n\t}\n# endif\n#endif\n\tredraw_later(CLEAR);\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n\tif (!gui.in_use)\n# endif\n\t    resize_console_buf();\n#endif\n    }\n}\n\n/*\n * CTRL-O: In Select mode: switch to Visual mode for one command.\n * Otherwise: Go to older pcmark.\n */\n    static void\nnv_ctrlo(cmdarg_T *cap)\n{\n    if (VIsual_active && VIsual_select)\n    {\n\tVIsual_select = FALSE;\n\tshowmode();\n\trestart_VIsual_select = 2;\t// restart Select mode later\n    }\n    else\n    {\n\tcap->count1 = -cap->count1;\n\tnv_pcmark(cap);\n    }\n}\n\n/*\n * CTRL-^ command, short for \":e #\".  Works even when the alternate buffer is\n * not named.\n */\n    static void\nnv_hat(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\t(void)buflist_getfile((int)cap->count0, (linenr_T)0,\n\t\t\t\t\t\tGETF_SETMARK|GETF_ALT, FALSE);\n}\n\n/*\n * \"Z\" commands.\n */\n    static void\nnv_Zet(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n\tswitch (cap->nchar)\n\t{\n\t\t\t// \"ZZ\": equivalent to \":x\".\n\t    case 'Z':\tdo_cmdline_cmd((char_u *)\"x\");\n\t\t\tbreak;\n\n\t\t\t// \"ZQ\": equivalent to \":q!\" (Elvis compatible).\n\t    case 'Q':\tdo_cmdline_cmd((char_u *)\"q!\");\n\t\t\tbreak;\n\n\t    default:\tclearopbeep(cap->oap);\n\t}\n    }\n}\n\n/*\n * Call nv_ident() as if \"c1\" was used, with \"c2\" as next character.\n */\n    void\ndo_nv_ident(int c1, int c2)\n{\n    oparg_T\toa;\n    cmdarg_T\tca;\n\n    clear_oparg(&oa);\n    CLEAR_FIELD(ca);\n    ca.oap = &oa;\n    ca.cmdchar = c1;\n    ca.nchar = c2;\n    nv_ident(&ca);\n}\n\n/*\n * Handle the commands that use the word under the cursor.\n * [g] CTRL-]\t:ta to current identifier\n * [g] 'K'\trun program for current identifier\n * [g] '*'\t/ to current identifier or string\n * [g] '#'\t? to current identifier or string\n *  g  ']'\t:tselect for current identifier\n */\n    static void\nnv_ident(cmdarg_T *cap)\n{\n    char_u\t*ptr = NULL;\n    char_u\t*buf;\n    unsigned\tbuflen;\n    char_u\t*newbuf;\n    char_u\t*p;\n    char_u\t*kp;\t\t// value of 'keywordprg'\n    int\t\tkp_help;\t// 'keywordprg' is \":he\"\n    int\t\tkp_ex;\t\t// 'keywordprg' starts with \":\"\n    int\t\tn = 0;\t\t// init for GCC\n    int\t\tcmdchar;\n    int\t\tg_cmd;\t\t// \"g\" command\n    int\t\ttag_cmd = FALSE;\n    char_u\t*aux_ptr;\n    int\t\tisman;\n    int\t\tisman_s;\n\n    if (cap->cmdchar == 'g')\t// \"g*\", \"g#\", \"g]\" and \"gCTRL-]\"\n    {\n\tcmdchar = cap->nchar;\n\tg_cmd = TRUE;\n    }\n    else\n    {\n\tcmdchar = cap->cmdchar;\n\tg_cmd = FALSE;\n    }\n\n    if (cmdchar == POUND)\t// the pound sign, '#' for English keyboards\n\tcmdchar = '#';\n\n    /*\n     * The \"]\", \"CTRL-]\" and \"K\" commands accept an argument in Visual mode.\n     */\n    if (cmdchar == ']' || cmdchar == Ctrl_RSB || cmdchar == 'K')\n    {\n\tif (VIsual_active && get_visual_text(cap, &ptr, &n) == FAIL)\n\t    return;\n\tif (checkclearopq(cap->oap))\n\t    return;\n    }\n\n    if (ptr == NULL && (n = find_ident_under_cursor(&ptr,\n\t\t    (cmdchar == '*' || cmdchar == '#')\n\t\t\t\t ? FIND_IDENT|FIND_STRING : FIND_IDENT)) == 0)\n    {\n\tclearop(cap->oap);\n\treturn;\n    }\n\n    // Allocate buffer to put the command in.  Inserting backslashes can\n    // double the length of the word.  p_kp / curbuf->b_p_kp could be added\n    // and some numbers.\n    kp = (*curbuf->b_p_kp == NUL ? p_kp : curbuf->b_p_kp);\n    kp_help = (*kp == NUL || STRCMP(kp, \":he\") == 0\n\t\t\t\t\t\t || STRCMP(kp, \":help\") == 0);\n    if (kp_help && *skipwhite(ptr) == NUL)\n    {\n\temsg(_(e_noident));\t // found white space only\n\treturn;\n    }\n    kp_ex = (*kp == ':');\n    buflen = (unsigned)(n * 2 + 30 + STRLEN(kp));\n    buf = alloc(buflen);\n    if (buf == NULL)\n\treturn;\n    buf[0] = NUL;\n\n    switch (cmdchar)\n    {\n\tcase '*':\n\tcase '#':\n\t    /*\n\t     * Put cursor at start of word, makes search skip the word\n\t     * under the cursor.\n\t     * Call setpcmark() first, so \"*``\" puts the cursor back where\n\t     * it was.\n\t     */\n\t    setpcmark();\n\t    curwin->w_cursor.col = (colnr_T) (ptr - ml_get_curline());\n\n\t    if (!g_cmd && vim_iswordp(ptr))\n\t\tSTRCPY(buf, \"\\\\<\");\n\t    no_smartcase = TRUE;\t// don't use 'smartcase' now\n\t    break;\n\n\tcase 'K':\n\t    if (kp_help)\n\t\tSTRCPY(buf, \"he! \");\n\t    else if (kp_ex)\n\t    {\n\t\tif (cap->count0 != 0)\n\t\t    vim_snprintf((char *)buf, buflen, \"%s %ld\",\n\t\t\t\t\t\t\t     kp, cap->count0);\n\t\telse\n\t\t    STRCPY(buf, kp);\n\t\tSTRCAT(buf, \" \");\n\t    }\n\t    else\n\t    {\n\t\t// An external command will probably use an argument starting\n\t\t// with \"-\" as an option.  To avoid trouble we skip the \"-\".\n\t\twhile (*ptr == '-' && n > 0)\n\t\t{\n\t\t    ++ptr;\n\t\t    --n;\n\t\t}\n\t\tif (n == 0)\n\t\t{\n\t\t    emsg(_(e_noident));\t // found dashes only\n\t\t    vim_free(buf);\n\t\t    return;\n\t\t}\n\n\t\t// When a count is given, turn it into a range.  Is this\n\t\t// really what we want?\n\t\tisman = (STRCMP(kp, \"man\") == 0);\n\t\tisman_s = (STRCMP(kp, \"man -s\") == 0);\n\t\tif (cap->count0 != 0 && !(isman || isman_s))\n\t\t    sprintf((char *)buf, \".,.+%ld\", cap->count0 - 1);\n\n\t\tSTRCAT(buf, \"! \");\n\t\tif (cap->count0 == 0 && isman_s)\n\t\t    STRCAT(buf, \"man\");\n\t\telse\n\t\t    STRCAT(buf, kp);\n\t\tSTRCAT(buf, \" \");\n\t\tif (cap->count0 != 0 && (isman || isman_s))\n\t\t{\n\t\t    sprintf((char *)buf + STRLEN(buf), \"%ld\", cap->count0);\n\t\t    STRCAT(buf, \" \");\n\t\t}\n\t    }\n\t    break;\n\n\tcase ']':\n\t    tag_cmd = TRUE;\n#ifdef FEAT_CSCOPE\n\t    if (p_cst)\n\t\tSTRCPY(buf, \"cstag \");\n\t    else\n#endif\n\t\tSTRCPY(buf, \"ts \");\n\t    break;\n\n\tdefault:\n\t    tag_cmd = TRUE;\n\t    if (curbuf->b_help)\n\t\tSTRCPY(buf, \"he! \");\n\t    else\n\t    {\n\t\tif (g_cmd)\n\t\t    STRCPY(buf, \"tj \");\n\t\telse if (cap->count0 == 0)\n\t\t    STRCPY(buf, \"ta \");\n\t\telse\n\t\t    sprintf((char *)buf, \":%ldta \", cap->count0);\n\t    }\n    }\n\n    /*\n     * Now grab the chars in the identifier\n     */\n    if (cmdchar == 'K' && !kp_help)\n    {\n\tptr = vim_strnsave(ptr, n);\n\tif (kp_ex)\n\t    // Escape the argument properly for an Ex command\n\t    p = vim_strsave_fnameescape(ptr, FALSE);\n\telse\n\t    // Escape the argument properly for a shell command\n\t    p = vim_strsave_shellescape(ptr, TRUE, TRUE);\n\tvim_free(ptr);\n\tif (p == NULL)\n\t{\n\t    vim_free(buf);\n\t    return;\n\t}\n\tnewbuf = vim_realloc(buf, STRLEN(buf) + STRLEN(p) + 1);\n\tif (newbuf == NULL)\n\t{\n\t    vim_free(buf);\n\t    vim_free(p);\n\t    return;\n\t}\n\tbuf = newbuf;\n\tSTRCAT(buf, p);\n\tvim_free(p);\n    }\n    else\n    {\n\tif (cmdchar == '*')\n\t    aux_ptr = (char_u *)(magic_isset() ? \"/.*~[^$\\\\\" : \"/^$\\\\\");\n\telse if (cmdchar == '#')\n\t    aux_ptr = (char_u *)(magic_isset() ? \"/?.*~[^$\\\\\" : \"/?^$\\\\\");\n\telse if (tag_cmd)\n\t{\n\t    if (curbuf->b_help)\n\t\t// \":help\" handles unescaped argument\n\t\taux_ptr = (char_u *)\"\";\n\t    else\n\t\taux_ptr = (char_u *)\"\\\\|\\\"\\n[\";\n\t}\n\telse\n\t    aux_ptr = (char_u *)\"\\\\|\\\"\\n*?[\";\n\n\tp = buf + STRLEN(buf);\n\twhile (n-- > 0)\n\t{\n\t    // put a backslash before \\ and some others\n\t    if (vim_strchr(aux_ptr, *ptr) != NULL)\n\t\t*p++ = '\\\\';\n\t    // When current byte is a part of multibyte character, copy all\n\t    // bytes of that character.\n\t    if (has_mbyte)\n\t    {\n\t\tint i;\n\t\tint len = (*mb_ptr2len)(ptr) - 1;\n\n\t\tfor (i = 0; i < len && n >= 1; ++i, --n)\n\t\t    *p++ = *ptr++;\n\t    }\n\t    *p++ = *ptr++;\n\t}\n\t*p = NUL;\n    }\n\n    /*\n     * Execute the command.\n     */\n    if (cmdchar == '*' || cmdchar == '#')\n    {\n\tif (!g_cmd && (has_mbyte\n\t\t    ? vim_iswordp(mb_prevptr(ml_get_curline(), ptr))\n\t\t    : vim_iswordc(ptr[-1])))\n\t    STRCAT(buf, \"\\\\>\");\n\n\t// put pattern in search history\n\tinit_history();\n\tadd_to_history(HIST_SEARCH, buf, TRUE, NUL);\n\n\t(void)normal_search(cap, cmdchar == '*' ? '/' : '?', buf, 0, NULL);\n    }\n    else\n    {\n\tg_tag_at_cursor = TRUE;\n\tdo_cmdline_cmd(buf);\n\tg_tag_at_cursor = FALSE;\n    }\n\n    vim_free(buf);\n}\n\n/*\n * Get visually selected text, within one line only.\n * Returns FAIL if more than one line selected.\n */\n    int\nget_visual_text(\n    cmdarg_T\t*cap,\n    char_u\t**pp,\t    // return: start of selected text\n    int\t\t*lenp)\t    // return: length of selected text\n{\n    if (VIsual_mode != 'V')\n\tunadjust_for_sel();\n    if (VIsual.lnum != curwin->w_cursor.lnum)\n    {\n\tif (cap != NULL)\n\t    clearopbeep(cap->oap);\n\treturn FAIL;\n    }\n    if (VIsual_mode == 'V')\n    {\n\t*pp = ml_get_curline();\n\t*lenp = (int)STRLEN(*pp);\n    }\n    else\n    {\n\tif (LT_POS(curwin->w_cursor, VIsual))\n\t{\n\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (has_mbyte)\n\t    // Correct the length to include the whole last character.\n\t    *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}\n\n/*\n * CTRL-T: backwards in tag stack\n */\n    static void\nnv_tagpop(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\tdo_tag((char_u *)\"\", DT_POP, (int)cap->count1, FALSE, TRUE);\n}\n\n/*\n * Handle scrolling command 'H', 'L' and 'M'.\n */\n    static void\nnv_scroll(cmdarg_T *cap)\n{\n    int\t\tused = 0;\n    long\tn;\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\thalf;\n\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    if (cap->cmdchar == 'L')\n    {\n\tvalidate_botline();\t    // make sure curwin->w_botline is valid\n\tcurwin->w_cursor.lnum = curwin->w_botline - 1;\n\tif (cap->count1 - 1 >= curwin->w_cursor.lnum)\n\t    curwin->w_cursor.lnum = 1;\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tfor (n = cap->count1 - 1; n > 0\n\t\t\t    && curwin->w_cursor.lnum > curwin->w_topline; --n)\n\t\t{\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\t\t    --curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tcurwin->w_cursor.lnum -= cap->count1 - 1;\n\t}\n    }\n    else\n    {\n\tif (cap->cmdchar == 'M')\n\t{\n#ifdef FEAT_DIFF\n\t    // Don't count filler lines above the window.\n\t    used -= diff_check_fill(curwin, curwin->w_topline)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#endif\n\t    validate_botline();\t    // make sure w_empty_rows is valid\n\t    half = (curwin->w_height - curwin->w_empty_rows + 1) / 2;\n\t    for (n = 0; curwin->w_topline + n < curbuf->b_ml.ml_line_count; ++n)\n\t    {\n#ifdef FEAT_DIFF\n\t\t// Count half he number of filler lines to be \"below this\n\t\t// line\" and half to be \"above the next line\".\n\t\tif (n > 0 && used + diff_check_fill(curwin, curwin->w_topline\n\t\t\t\t\t\t\t     + n) / 2 >= half)\n\t\t{\n\t\t    --n;\n\t\t    break;\n\t\t}\n#endif\n\t\tused += plines(curwin->w_topline + n);\n\t\tif (used >= half)\n\t\t    break;\n#ifdef FEAT_FOLDING\n\t\tif (hasFolding(curwin->w_topline + n, NULL, &lnum))\n\t\t    n = lnum - curwin->w_topline;\n#endif\n\t    }\n\t    if (n > 0 && used > curwin->w_height)\n\t\t--n;\n\t}\n\telse // (cap->cmdchar == 'H')\n\t{\n\t    n = cap->count1 - 1;\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tlnum = curwin->w_topline;\n\t\twhile (n-- > 0 && lnum < curwin->w_botline - 1)\n\t\t{\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t    ++lnum;\n\t\t}\n\t\tn = lnum - curwin->w_topline;\n\t    }\n#endif\n\t}\n\tcurwin->w_cursor.lnum = curwin->w_topline + n;\n\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    }\n\n    // Correct for 'so', except when an operator is pending.\n    if (cap->oap->op_type == OP_NOP)\n\tcursor_correct();\n    beginline(BL_SOL | BL_FIX);\n}\n\n/*\n * Cursor right commands.\n */\n    static void\nnv_right(cmdarg_T *cap)\n{\n    long\tn;\n    int\t\tpast_line;\n\n    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n    {\n\t// <C-Right> and <S-Right> move a word or WORD right\n\tif (mod_mask & MOD_MASK_CTRL)\n\t    cap->arg = TRUE;\n\tnv_wordcmd(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    past_line = (VIsual_active && *p_sel != 'o');\n\n    /*\n     * In virtual edit mode, there's no such thing as \"past_line\", as lines\n     * are (theoretically) infinitely long.\n     */\n    if (virtual_active())\n\tpast_line = 0;\n\n    for (n = cap->count1; n > 0; --n)\n    {\n\tif ((!past_line && oneright() == FAIL)\n\t\t|| (past_line && *ml_get_cursor() == NUL)\n\t\t)\n\t{\n\t    /*\n\t     *\t  <Space> wraps to next line if 'whichwrap' has 's'.\n\t     *\t      'l' wraps to next line if 'whichwrap' has 'l'.\n\t     * CURS_RIGHT wraps to next line if 'whichwrap' has '>'.\n\t     */\n\t    if (       ((cap->cmdchar == ' '\n\t\t\t    && vim_strchr(p_ww, 's') != NULL)\n\t\t\t|| (cap->cmdchar == 'l'\n\t\t\t    && vim_strchr(p_ww, 'l') != NULL)\n\t\t\t|| (cap->cmdchar == K_RIGHT\n\t\t\t    && vim_strchr(p_ww, '>') != NULL))\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// When deleting we also count the NL as a character.\n\t\t// Set cap->oap->inclusive when last char in the line is\n\t\t// included, move to next line after that\n\t\tif (\t   cap->oap->op_type != OP_NOP\n\t\t\t&& !cap->oap->inclusive\n\t\t\t&& !LINEEMPTY(curwin->w_cursor.lnum))\n\t\t    cap->oap->inclusive = TRUE;\n\t\telse\n\t\t{\n\t\t    ++curwin->w_cursor.lnum;\n\t\t    curwin->w_cursor.col = 0;\n\t\t    curwin->w_cursor.coladd = 0;\n\t\t    curwin->w_set_curswant = TRUE;\n\t\t    cap->oap->inclusive = FALSE;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    if (cap->oap->op_type == OP_NOP)\n\t    {\n\t\t// Only beep and flush if not moved at all\n\t\tif (n == cap->count1)\n\t\t    beep_flush();\n\t    }\n\t    else\n\t    {\n\t\tif (!LINEEMPTY(curwin->w_cursor.lnum))\n\t\t    cap->oap->inclusive = TRUE;\n\t    }\n\t    break;\n\t}\n\telse if (past_line)\n\t{\n\t    curwin->w_set_curswant = TRUE;\n\t    if (virtual_active())\n\t\toneright();\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t    curwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t\telse\n\t\t    ++curwin->w_cursor.col;\n\t    }\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Cursor left commands.\n *\n * Returns TRUE when operator end should not be adjusted.\n */\n    static void\nnv_left(cmdarg_T *cap)\n{\n    long\tn;\n\n    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n    {\n\t// <C-Left> and <S-Left> move a word or WORD left\n\tif (mod_mask & MOD_MASK_CTRL)\n\t    cap->arg = 1;\n\tnv_bck_word(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    for (n = cap->count1; n > 0; --n)\n    {\n\tif (oneleft() == FAIL)\n\t{\n\t    // <BS> and <Del> wrap to previous line if 'whichwrap' has 'b'.\n\t    //\t\t 'h' wraps to previous line if 'whichwrap' has 'h'.\n\t    //\t   CURS_LEFT wraps to previous line if 'whichwrap' has '<'.\n\t    if (       (((cap->cmdchar == K_BS\n\t\t\t\t|| cap->cmdchar == Ctrl_H)\n\t\t\t    && vim_strchr(p_ww, 'b') != NULL)\n\t\t\t|| (cap->cmdchar == 'h'\n\t\t\t    && vim_strchr(p_ww, 'h') != NULL)\n\t\t\t|| (cap->cmdchar == K_LEFT\n\t\t\t    && vim_strchr(p_ww, '<') != NULL))\n\t\t    && curwin->w_cursor.lnum > 1)\n\t    {\n\t\t--(curwin->w_cursor.lnum);\n\t\tcoladvance((colnr_T)MAXCOL);\n\t\tcurwin->w_set_curswant = TRUE;\n\n\t\t// When the NL before the first char has to be deleted we\n\t\t// put the cursor on the NUL after the previous line.\n\t\t// This is a very special case, be careful!\n\t\t// Don't adjust op_end now, otherwise it won't work.\n\t\tif (\t   (cap->oap->op_type == OP_DELETE\n\t\t\t    || cap->oap->op_type == OP_CHANGE)\n\t\t\t&& !LINEEMPTY(curwin->w_cursor.lnum))\n\t\t{\n\t\t    char_u *cp = ml_get_cursor();\n\n\t\t    if (*cp != NUL)\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t    curwin->w_cursor.col += (*mb_ptr2len)(cp);\n\t\t\telse\n\t\t\t    ++curwin->w_cursor.col;\n\t\t    }\n\t\t    cap->retval |= CA_NO_ADJ_OP_END;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    // Only beep and flush if not moved at all\n\t    else if (cap->oap->op_type == OP_NOP && n == cap->count1)\n\t\tbeep_flush();\n\t    break;\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Cursor up commands.\n * cap->arg is TRUE for \"-\": Move cursor to first non-blank.\n */\n    static void\nnv_up(cmdarg_T *cap)\n{\n    if (mod_mask & MOD_MASK_SHIFT)\n    {\n\t// <S-Up> is page up\n\tcap->arg = BACKWARD;\n\tnv_page(cap);\n    }\n    else\n    {\n\tcap->oap->motion_type = MLINE;\n\tif (cursor_up(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)\n\t    clearopbeep(cap->oap);\n\telse if (cap->arg)\n\t    beginline(BL_WHITE | BL_FIX);\n    }\n}\n\n/*\n * Cursor down commands.\n * cap->arg is TRUE for CR and \"+\": Move cursor to first non-blank.\n */\n    static void\nnv_down(cmdarg_T *cap)\n{\n    if (mod_mask & MOD_MASK_SHIFT)\n    {\n\t// <S-Down> is page down\n\tcap->arg = FORWARD;\n\tnv_page(cap);\n    }\n#if defined(FEAT_QUICKFIX)\n    // Quickfix window only: view the result under the cursor.\n    else if (bt_quickfix(curbuf) && cap->cmdchar == CAR)\n\tqf_view_result(FALSE);\n#endif\n    else\n    {\n#ifdef FEAT_CMDWIN\n\t// In the cmdline window a <CR> executes the command.\n\tif (cmdwin_type != 0 && cap->cmdchar == CAR)\n\t    cmdwin_result = CAR;\n\telse\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t// In a prompt buffer a <CR> in the last line invokes the callback.\n\tif (bt_prompt(curbuf) && cap->cmdchar == CAR\n\t\t       && curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t{\n\t    invoke_prompt_callback();\n\t    if (restart_edit == 0)\n\t\trestart_edit = 'a';\n\t}\n\telse\n#endif\n\t{\n\t    cap->oap->motion_type = MLINE;\n\t    if (cursor_down(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)\n\t\tclearopbeep(cap->oap);\n\t    else if (cap->arg)\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t}\n    }\n}\n\n#ifdef FEAT_SEARCHPATH\n/*\n * Grab the file name under the cursor and edit it.\n */\n    static void\nnv_gotofile(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    linenr_T\tlnum = -1;\n\n    if (text_locked())\n    {\n\tclearopbeep(cap->oap);\n\ttext_locked_msg();\n\treturn;\n    }\n    if (curbuf_locked())\n    {\n\tclearop(cap->oap);\n\treturn;\n    }\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n\n    ptr = grab_file_name(cap->count1, &lnum);\n\n    if (ptr != NULL)\n    {\n\t// do autowrite if necessary\n\tif (curbufIsChanged() && curbuf->b_nwindows <= 1 && !buf_hide(curbuf))\n\t    (void)autowrite(curbuf, FALSE);\n\tsetpcmark();\n\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,\n\t\t\t\tbuf_hide(curbuf) ? ECMD_HIDE : 0, curwin) == OK\n\t\t&& cap->nchar == 'F' && lnum >= 0)\n\t{\n\t    curwin->w_cursor.lnum = lnum;\n\t    check_cursor_lnum();\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n\tvim_free(ptr);\n    }\n    else\n\tclearop(cap->oap);\n}\n#endif\n\n/*\n * <End> command: to end of current line or last line.\n */\n    static void\nnv_end(cmdarg_T *cap)\n{\n    if (cap->arg || (mod_mask & MOD_MASK_CTRL))\t// CTRL-END = goto last line\n    {\n\tcap->arg = TRUE;\n\tnv_goto(cap);\n\tcap->count1 = 1;\t\t// to end of current line\n    }\n    nv_dollar(cap);\n}\n\n/*\n * Handle the \"$\" command.\n */\n    static void\nnv_dollar(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = TRUE;\n    // In virtual mode when off the edge of a line and an operator\n    // is pending (whew!) keep the cursor where it is.\n    // Otherwise, send it to the end of the line.\n    if (!virtual_active() || gchar_cursor() != NUL\n\t\t\t\t\t       || cap->oap->op_type == OP_NOP)\n\tcurwin->w_curswant = MAXCOL;\t// so we stay at the end\n    if (cursor_down((long)(cap->count1 - 1),\n\t\t\t\t\t cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Implementation of '?' and '/' commands.\n * If cap->arg is TRUE don't set PC mark.\n */\n    static void\nnv_search(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    pos_T\tsave_cursor = curwin->w_cursor;\n\n    if (cap->cmdchar == '?' && cap->oap->op_type == OP_ROT13)\n    {\n\t// Translate \"g??\" to \"g?g?\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = '?';\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // When using 'incsearch' the cursor may be moved to set a different search\n    // start position.\n    cap->searchbuf = getcmdline(cap->cmdchar, cap->count1, 0, TRUE);\n\n    if (cap->searchbuf == NULL)\n    {\n\tclearop(oap);\n\treturn;\n    }\n\n    (void)normal_search(cap, cap->cmdchar, cap->searchbuf,\n\t\t\t(cap->arg || !EQUAL_POS(save_cursor, curwin->w_cursor))\n\t\t\t\t\t\t      ? 0 : SEARCH_MARK, NULL);\n}\n\n/*\n * Handle \"N\" and \"n\" commands.\n * cap->arg is SEARCH_REV for \"N\", 0 for \"n\".\n */\n    static void\nnv_next(cmdarg_T *cap)\n{\n    pos_T   old = curwin->w_cursor;\n    int\t    wrapped = FALSE;\n    int\t    i = normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, &wrapped);\n\n    if (i == 1 && !wrapped && EQUAL_POS(old, curwin->w_cursor))\n    {\n\t// Avoid getting stuck on the current cursor position, which can\n\t// happen when an offset is given and the cursor is on the last char\n\t// in the buffer: Repeat with count + 1.\n\tcap->count1 += 1;\n\t(void)normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, NULL);\n\tcap->count1 -= 1;\n    }\n}\n\n/*\n * Search for \"pat\" in direction \"dir\" ('/' or '?', 0 for repeat).\n * Uses only cap->count1 and cap->oap from \"cap\".\n * Return 0 for failure, 1 for found, 2 for found and line offset added.\n */\n    static int\nnormal_search(\n    cmdarg_T\t*cap,\n    int\t\tdir,\n    char_u\t*pat,\n    int\t\topt,\t\t// extra flags for do_search()\n    int\t\t*wrapped)\n{\n    int\t\ti;\n    searchit_arg_T sia;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    cap->oap->use_reg_one = TRUE;\n    curwin->w_set_curswant = TRUE;\n\n    CLEAR_FIELD(sia);\n    i = do_search(cap->oap, dir, dir, pat, cap->count1,\n\t\t\t    opt | SEARCH_OPT | SEARCH_ECHO | SEARCH_MSG, &sia);\n    if (wrapped != NULL)\n\t*wrapped = sia.sa_wrapped;\n    if (i == 0)\n\tclearop(cap->oap);\n    else\n    {\n\tif (i == 2)\n\t    cap->oap->motion_type = MLINE;\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n#endif\n    }\n\n    // \"/$\" will put the cursor after the end of the line, may need to\n    // correct that here\n    check_cursor();\n    return i;\n}\n\n/*\n * Character search commands.\n * cap->arg is BACKWARD for 'F' and 'T', FORWARD for 'f' and 't', TRUE for\n * ',' and FALSE for ';'.\n * cap->nchar is NUL for ',' and ';' (repeat the search)\n */\n    static void\nnv_csearch(cmdarg_T *cap)\n{\n    int\t\tt_cmd;\n\n    if (cap->cmdchar == 't' || cap->cmdchar == 'T')\n\tt_cmd = TRUE;\n    else\n\tt_cmd = FALSE;\n\n    cap->oap->motion_type = MCHAR;\n    if (IS_SPECIAL(cap->nchar) || searchc(cap, t_cmd) == FAIL)\n\tclearopbeep(cap->oap);\n    else\n    {\n\tcurwin->w_set_curswant = TRUE;\n\t// Include a Tab for \"tx\" and for \"dfx\".\n\tif (gchar_cursor() == TAB && virtual_active() && cap->arg == FORWARD\n\t\t&& (t_cmd || cap->oap->op_type != OP_NOP))\n\t{\n\t    colnr_T\tscol, ecol;\n\n\t    getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);\n\t    curwin->w_cursor.coladd = ecol - scol;\n\t}\n\telse\n\t    curwin->w_cursor.coladd = 0;\n\tadjust_for_sel(cap);\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"[\" and \"]\" commands.\n * cap->arg is BACKWARD for \"[\" and FORWARD for \"]\".\n */\n    static void\nnv_brackets(cmdarg_T *cap)\n{\n    pos_T\tnew_pos = {0, 0, 0};\n    pos_T\tprev_pos;\n    pos_T\t*pos = NULL;\t    // init for GCC\n    pos_T\told_pos;\t    // cursor position before command\n    int\t\tflag;\n    long\tn;\n    int\t\tfindc;\n    int\t\tc;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    old_pos = curwin->w_cursor;\n    curwin->w_cursor.coladd = 0;    // TODO: don't do this for an error.\n\n#ifdef FEAT_SEARCHPATH\n    /*\n     * \"[f\" or \"]f\" : Edit file under the cursor (same as \"gf\")\n     */\n    if (cap->nchar == 'f')\n\tnv_gotofile(cap);\n    else\n#endif\n\n#ifdef FEAT_FIND_ID\n    /*\n     * Find the occurrence(s) of the identifier or define under cursor\n     * in current and included files or jump to the first occurrence.\n     *\n     *\t\t\tsearch\t     list\t    jump\n     *\t\t      fwd   bwd    fwd\t bwd\t fwd\tbwd\n     * identifier     \"]i\"  \"[i\"   \"]I\"  \"[I\"\t\"]^I\"  \"[^I\"\n     * define\t      \"]d\"  \"[d\"   \"]D\"  \"[D\"\t\"]^D\"  \"[^D\"\n     */\n    if (vim_strchr((char_u *)\n# ifdef EBCDIC\n\t\t\"iI\\005dD\\067\",\n# else\n\t\t\"iI\\011dD\\004\",\n# endif\n\t\tcap->nchar) != NULL)\n    {\n\tchar_u\t*ptr;\n\tint\tlen;\n\n\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t    clearop(cap->oap);\n\telse\n\t{\n\t    find_pattern_in_path(ptr, 0, len, TRUE,\n\t\tcap->count0 == 0 ? !isupper(cap->nchar) : FALSE,\n\t\t((cap->nchar & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,\n\t\tcap->count1,\n\t\tisupper(cap->nchar) ? ACTION_SHOW_ALL :\n\t\t\t    islower(cap->nchar) ? ACTION_SHOW : ACTION_GOTO,\n\t\tcap->cmdchar == ']' ? curwin->w_cursor.lnum + 1 : (linenr_T)1,\n\t\t(linenr_T)MAXLNUM);\n\t    curwin->w_set_curswant = TRUE;\n\t}\n    }\n    else\n#endif\n\n    /*\n     * \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n     * \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n     * \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n     * \"[m\" or \"]m\" search for prev/next start of (Java) method.\n     * \"[M\" or \"]M\" search for prev/next end of (Java) method.\n     */\n    if (  (cap->cmdchar == '['\n\t\t&& vim_strchr((char_u *)\"{(*/#mM\", cap->nchar) != NULL)\n\t    || (cap->cmdchar == ']'\n\t\t&& vim_strchr((char_u *)\"})*/#mM\", cap->nchar) != NULL))\n    {\n\tif (cap->nchar == '*')\n\t    cap->nchar = '/';\n\tprev_pos.lnum = 0;\n\tif (cap->nchar == 'm' || cap->nchar == 'M')\n\t{\n\t    if (cap->cmdchar == '[')\n\t\tfindc = '{';\n\t    else\n\t\tfindc = '}';\n\t    n = 9999;\n\t}\n\telse\n\t{\n\t    findc = cap->nchar;\n\t    n = cap->count1;\n\t}\n\tfor ( ; n > 0; --n)\n\t{\n\t    if ((pos = findmatchlimit(cap->oap, findc,\n\t\t(cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD, 0)) == NULL)\n\t    {\n\t\tif (new_pos.lnum == 0)\t// nothing found\n\t\t{\n\t\t    if (cap->nchar != 'm' && cap->nchar != 'M')\n\t\t\tclearopbeep(cap->oap);\n\t\t}\n\t\telse\n\t\t    pos = &new_pos;\t// use last one found\n\t\tbreak;\n\t    }\n\t    prev_pos = new_pos;\n\t    curwin->w_cursor = *pos;\n\t    new_pos = *pos;\n\t}\n\tcurwin->w_cursor = old_pos;\n\n\t/*\n\t * Handle \"[m\", \"]m\", \"[M\" and \"[M\".  The findmatchlimit() only\n\t * brought us to the match for \"[m\" and \"]M\" when inside a method.\n\t * Try finding the '{' or '}' we want to be at.\n\t * Also repeat for the given count.\n\t */\n\tif (cap->nchar == 'm' || cap->nchar == 'M')\n\t{\n\t    // norm is TRUE for \"]M\" and \"[m\"\n\t    int\t    norm = ((findc == '{') == (cap->nchar == 'm'));\n\n\t    n = cap->count1;\n\t    // found a match: we were inside a method\n\t    if (prev_pos.lnum != 0)\n\t    {\n\t\tpos = &prev_pos;\n\t\tcurwin->w_cursor = prev_pos;\n\t\tif (norm)\n\t\t    --n;\n\t    }\n\t    else\n\t\tpos = NULL;\n\t    while (n > 0)\n\t    {\n\t\tfor (;;)\n\t\t{\n\t\t    if ((findc == '{' ? dec_cursor() : inc_cursor()) < 0)\n\t\t    {\n\t\t\t// if not found anything, that's an error\n\t\t\tif (pos == NULL)\n\t\t\t    clearopbeep(cap->oap);\n\t\t\tn = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    c = gchar_cursor();\n\t\t    if (c == '{' || c == '}')\n\t\t    {\n\t\t\t// Must have found end/start of class: use it.\n\t\t\t// Or found the place to be at.\n\t\t\tif ((c == findc && norm) || (n == 1 && !norm))\n\t\t\t{\n\t\t\t    new_pos = curwin->w_cursor;\n\t\t\t    pos = &new_pos;\n\t\t\t    n = 0;\n\t\t\t}\n\t\t\t// if no match found at all, we started outside of the\n\t\t\t// class and we're inside now.  Just go on.\n\t\t\telse if (new_pos.lnum == 0)\n\t\t\t{\n\t\t\t    new_pos = curwin->w_cursor;\n\t\t\t    pos = &new_pos;\n\t\t\t}\n\t\t\t// found start/end of other method: go to match\n\t\t\telse if ((pos = findmatchlimit(cap->oap, findc,\n\t\t\t    (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD,\n\t\t\t\t\t\t\t\t  0)) == NULL)\n\t\t\t    n = 0;\n\t\t\telse\n\t\t\t    curwin->w_cursor = *pos;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t--n;\n\t    }\n\t    curwin->w_cursor = old_pos;\n\t    if (pos == NULL && new_pos.lnum != 0)\n\t\tclearopbeep(cap->oap);\n\t}\n\tif (pos != NULL)\n\t{\n\t    setpcmark();\n\t    curwin->w_cursor = *pos;\n\t    curwin->w_set_curswant = TRUE;\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_BLOCK) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\t\tfoldOpenCursor();\n#endif\n\t}\n    }\n\n    /*\n     * \"[[\", \"[]\", \"]]\" and \"][\": move to start or end of function\n     */\n    else if (cap->nchar == '[' || cap->nchar == ']')\n    {\n\tif (cap->nchar == cap->cmdchar)\t\t    // \"]]\" or \"[[\"\n\t    flag = '{';\n\telse\n\t    flag = '}';\t\t    // \"][\" or \"[]\"\n\n\tcurwin->w_set_curswant = TRUE;\n\t/*\n\t * Imitate strange Vi behaviour: When using \"]]\" with an operator\n\t * we also stop at '}'.\n\t */\n\tif (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,\n\t      (cap->oap->op_type != OP_NOP\n\t\t\t\t      && cap->arg == FORWARD && flag == '{')))\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    if (cap->oap->op_type == OP_NOP)\n\t\tbeginline(BL_WHITE | BL_FIX);\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t\tfoldOpenCursor();\n#endif\n\t}\n    }\n\n    /*\n     * \"[p\", \"[P\", \"]P\" and \"]p\": put with indent adjustment\n     */\n    else if (cap->nchar == 'p' || cap->nchar == 'P')\n    {\n\tnv_put_opt(cap, TRUE);\n    }\n\n    /*\n     * \"['\", \"[`\", \"]'\" and \"]`\": jump to next mark\n     */\n    else if (cap->nchar == '\\'' || cap->nchar == '`')\n    {\n\tpos = &curwin->w_cursor;\n\tfor (n = cap->count1; n > 0; --n)\n\t{\n\t    prev_pos = *pos;\n\t    pos = getnextmark(pos, cap->cmdchar == '[' ? BACKWARD : FORWARD,\n\t\t\t\t\t\t\t  cap->nchar == '\\'');\n\t    if (pos == NULL)\n\t\tbreak;\n\t}\n\tif (pos == NULL)\n\t    pos = &prev_pos;\n\tnv_cursormark(cap, cap->nchar == '\\'', pos);\n    }\n\n    /*\n     * [ or ] followed by a middle mouse click: put selected text with\n     * indent adjustment.  Any other button just does as usual.\n     */\n    else if (cap->nchar >= K_RIGHTRELEASE && cap->nchar <= K_LEFTMOUSE)\n    {\n\t(void)do_mouse(cap->oap, cap->nchar,\n\t\t       (cap->cmdchar == ']') ? FORWARD : BACKWARD,\n\t\t       cap->count1, PUT_FIXINDENT);\n    }\n\n#ifdef FEAT_FOLDING\n    /*\n     * \"[z\" and \"]z\": move to start or end of open fold.\n     */\n    else if (cap->nchar == 'z')\n    {\n\tif (foldMoveTo(FALSE, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    /*\n     * \"[c\" and \"]c\": move to next or previous diff-change.\n     */\n    else if (cap->nchar == 'c')\n    {\n\tif (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    /*\n     * \"[s\", \"[S\", \"]s\" and \"]S\": move to next spell error.\n     */\n    else if (cap->nchar == 's' || cap->nchar == 'S')\n    {\n\tsetpcmark();\n\tfor (n = 0; n < cap->count1; ++n)\n\t    if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t  cap->nchar == 's' ? TRUE : FALSE, FALSE, NULL) == 0)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n#endif\n\n    // Not a valid cap->nchar.\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle Normal mode \"%\" command.\n */\n    static void\nnv_percent(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n#if defined(FEAT_FOLDING)\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n#endif\n\n    cap->oap->inclusive = TRUE;\n    if (cap->count0)\t    // {cnt}% : goto {cnt} percentage in file\n    {\n\tif (cap->count0 > 100)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    cap->oap->motion_type = MLINE;\n\t    setpcmark();\n\t    // Round up, so 'normal 100%' always jumps at the line line.\n\t    // Beyond 21474836 lines, (ml_line_count * 100 + 99) would\n\t    // overflow on 32-bits, so use a formula with less accuracy\n\t    // to avoid overflows.\n\t    if (curbuf->b_ml.ml_line_count >= 21474836)\n\t\tcurwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count + 99L)\n\t\t\t\t\t\t\t / 100L * cap->count0;\n\t    else\n\t\tcurwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count *\n\t\t\t\t\t\t    cap->count0 + 99L) / 100L;\n\t    if (curwin->w_cursor.lnum < 1)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n    }\n    else\t\t    // \"%\" : go to matching paren\n    {\n\tcap->oap->motion_type = MCHAR;\n\tcap->oap->use_reg_one = TRUE;\n\tif ((pos = findmatch(cap->oap, NUL)) == NULL)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    setpcmark();\n\t    curwin->w_cursor = *pos;\n\t    curwin->w_set_curswant = TRUE;\n\t    curwin->w_cursor.coladd = 0;\n\t    adjust_for_sel(cap);\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && lnum != curwin->w_cursor.lnum\n\t    && (fdo_flags & FDO_PERCENT)\n\t    && KeyTyped)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle \"(\" and \")\" commands.\n * cap->arg is BACKWARD for \"(\" and FORWARD for \")\".\n */\n    static void\nnv_brace(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->use_reg_one = TRUE;\n    // The motion used to be inclusive for \"(\", but that is not what Vi does.\n    cap->oap->inclusive = FALSE;\n    curwin->w_set_curswant = TRUE;\n\n    if (findsent(cap->arg, cap->count1) == FAIL)\n\tclearopbeep(cap->oap);\n    else\n    {\n\t// Don't leave the cursor on the NUL past end of line.\n\tadjust_cursor(cap->oap);\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"m\" command: Mark a position.\n */\n    static void\nnv_mark(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n\tif (setmark(cap->nchar) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * \"{\" and \"}\" commands.\n * cmd->arg is BACKWARD for \"{\" and FORWARD for \"}\".\n */\n    static void\nnv_findpar(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    cap->oap->use_reg_one = TRUE;\n    curwin->w_set_curswant = TRUE;\n    if (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, NUL, FALSE))\n\tclearopbeep(cap->oap);\n    else\n    {\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"u\" command: Undo or make lower case.\n */\n    static void\nnv_undo(cmdarg_T *cap)\n{\n    if (cap->oap->op_type == OP_LOWER || VIsual_active)\n    {\n\t// translate \"<Visual>u\" to \"<Visual>gu\" and \"guu\" to \"gugu\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'u';\n\tnv_operator(cap);\n    }\n    else\n\tnv_kundo(cap);\n}\n\n/*\n * <Undo> command.\n */\n    static void\nnv_kundo(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf))\n\t{\n\t    clearopbeep(cap->oap);\n\t    return;\n\t}\n#endif\n\tu_undo((int)cap->count1);\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * Handle the \"r\" command.\n */\n    static void\nnv_replace(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    int\t\thad_ctrl_v;\n    long\tn;\n\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    // get another character\n    if (cap->nchar == Ctrl_V)\n    {\n\thad_ctrl_v = Ctrl_V;\n\tcap->nchar = get_literal(FALSE);\n\t// Don't redo a multibyte character with CTRL-V.\n\tif (cap->nchar > DEL)\n\t    had_ctrl_v = NUL;\n    }\n    else\n\thad_ctrl_v = NUL;\n\n    // Abort if the character is a special key.\n    if (IS_SPECIAL(cap->nchar))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    // Visual mode \"r\"\n    if (VIsual_active)\n    {\n\tif (got_int)\n\t    reset_VIsual();\n\tif (had_ctrl_v)\n\t{\n\t    // Use a special (negative) number to make a difference between a\n\t    // literal CR or NL and a line break.\n\t    if (cap->nchar == CAR)\n\t\tcap->nchar = REPLACE_CR_NCHAR;\n\t    else if (cap->nchar == NL)\n\t\tcap->nchar = REPLACE_NL_NCHAR;\n\t}\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // Break tabs, etc.\n    if (virtual_active())\n    {\n\tif (u_save_cursor() == FAIL)\n\t    return;\n\tif (gchar_cursor() == NUL)\n\t{\n\t    // Add extra space and put the cursor on the first one.\n\t    coladvance_force((colnr_T)(getviscol() + cap->count1));\n\t    curwin->w_cursor.col -= cap->count1;\n\t}\n\telse if (gchar_cursor() == TAB)\n\t    coladvance_force(getviscol());\n    }\n\n    // Abort if not enough characters to replace.\n    ptr = ml_get_cursor();\n    if (STRLEN(ptr) < (unsigned)cap->count1\n\t    || (has_mbyte && mb_charlen(ptr) < cap->count1))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    /*\n     * Replacing with a TAB is done by edit() when it is complicated because\n     * 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.\n     * Other characters are done below to avoid problems with things like\n     * CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).\n     */\n    if (had_ctrl_v != Ctrl_V && cap->nchar == '\\t' && (curbuf->b_p_et || p_sta))\n    {\n\tstuffnumReadbuff(cap->count1);\n\tstuffcharReadbuff('R');\n\tstuffcharReadbuff('\\t');\n\tstuffcharReadbuff(ESC);\n\treturn;\n    }\n\n    // save line for undo\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    if (had_ctrl_v != Ctrl_V && (cap->nchar == '\\r' || cap->nchar == '\\n'))\n    {\n\t/*\n\t * Replace character(s) by a single newline.\n\t * Strange vi behaviour: Only one newline is inserted.\n\t * Delete the characters here.\n\t * Insert the newline with an insert command, takes care of\n\t * autoindent.\tThe insert command depends on being on the last\n\t * character of a line or not.\n\t */\n\t(void)del_chars(cap->count1, FALSE);\t// delete the characters\n\tstuffcharReadbuff('\\r');\n\tstuffcharReadbuff(ESC);\n\n\t// Give 'r' to edit(), to get the redo command right.\n\tinvoke_edit(cap, TRUE, 'r', FALSE);\n    }\n    else\n    {\n\tprep_redo(cap->oap->regname, cap->count1,\n\t\t\t\t       NUL, 'r', NUL, had_ctrl_v, cap->nchar);\n\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tif (has_mbyte)\n\t{\n\t    int\t\told_State = State;\n\n\t    if (cap->ncharC1 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC1);\n\t    if (cap->ncharC2 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC2);\n\n\t    // This is slow, but it handles replacing a single-byte with a\n\t    // multi-byte and the other way around.  Also handles adding\n\t    // composing characters for utf-8.\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\tState = REPLACE;\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t    int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\t\t    if (c != NUL)\n\t\t\tins_char(c);\n\t\t    else\n\t\t\t// will be decremented further down\n\t\t\t++curwin->w_cursor.col;\n\t\t}\n\t\telse\n\t\t    ins_char(cap->nchar);\n\t\tState = old_State;\n\t\tif (cap->ncharC1 != 0)\n\t\t    ins_char(cap->ncharC1);\n\t\tif (cap->ncharC2 != 0)\n\t\t    ins_char(cap->ncharC2);\n\t    }\n\t}\n\telse\n\t{\n\t    /*\n\t     * Replace the characters within one line.\n\t     */\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\t/*\n\t\t * Get ptr again, because u_save and/or showmatch() will have\n\t\t * released the line.  At the same time we let know that the\n\t\t * line will be changed.\n\t\t */\n\t\tptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t  int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\t\t  if (c != NUL)\n\t\t    ptr[curwin->w_cursor.col] = c;\n\t\t}\n\t\telse\n\t\t    ptr[curwin->w_cursor.col] = cap->nchar;\n\t\tif (p_sm && msg_silent == 0)\n\t\t    showmatch(cap->nchar);\n\t\t++curwin->w_cursor.col;\n\t    }\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active())\n\t    {\n\t\tcolnr_T  start = (colnr_T)(curwin->w_cursor.col - cap->count1);\n\n\t\tnetbeans_removed(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t\t\t   (long)cap->count1);\n\t\tnetbeans_inserted(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t       &ptr[start], (int)cap->count1);\n\t    }\n#endif\n\n\t    // mark the buffer as changed and prepare for displaying\n\t    changed_bytes(curwin->w_cursor.lnum,\n\t\t\t       (colnr_T)(curwin->w_cursor.col - cap->count1));\n\t}\n\t--curwin->w_cursor.col;\t    // cursor on the last replaced char\n\t// if the character on the left of the current cursor is a multi-byte\n\t// character, move two characters left\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tcurwin->w_set_curswant = TRUE;\n\tset_last_insert(cap->nchar);\n    }\n}\n\n/*\n * 'o': Exchange start and end of Visual area.\n * 'O': same, but in block mode exchange left and right corners.\n */\n    static void\nv_swap_corners(int cmdchar)\n{\n    pos_T\told_cursor;\n    colnr_T\tleft, right;\n\n    if (cmdchar == 'O' && VIsual_mode == Ctrl_V)\n    {\n\told_cursor = curwin->w_cursor;\n\tgetvcols(curwin, &old_cursor, &VIsual, &left, &right);\n\tcurwin->w_cursor.lnum = VIsual.lnum;\n\tcoladvance(left);\n\tVIsual = curwin->w_cursor;\n\n\tcurwin->w_cursor.lnum = old_cursor.lnum;\n\tcurwin->w_curswant = right;\n\t// 'selection \"exclusive\" and cursor at right-bottom corner: move it\n\t// right one column\n\tif (old_cursor.lnum >= VIsual.lnum && *p_sel == 'e')\n\t    ++curwin->w_curswant;\n\tcoladvance(curwin->w_curswant);\n\tif (curwin->w_cursor.col == old_cursor.col\n\t\t&& (!virtual_active()\n\t\t    || curwin->w_cursor.coladd == old_cursor.coladd))\n\t{\n\t    curwin->w_cursor.lnum = VIsual.lnum;\n\t    if (old_cursor.lnum <= VIsual.lnum && *p_sel == 'e')\n\t\t++right;\n\t    coladvance(right);\n\t    VIsual = curwin->w_cursor;\n\n\t    curwin->w_cursor.lnum = old_cursor.lnum;\n\t    coladvance(left);\n\t    curwin->w_curswant = left;\n\t}\n    }\n    else\n    {\n\told_cursor = curwin->w_cursor;\n\tcurwin->w_cursor = VIsual;\n\tVIsual = old_cursor;\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * \"R\" (cap->arg is FALSE) and \"gR\" (cap->arg is TRUE).\n */\n    static void\nnv_Replace(cmdarg_T *cap)\n{\n    if (VIsual_active)\t\t// \"R\" is replace lines\n    {\n\tcap->cmdchar = 'c';\n\tcap->nchar = NUL;\n\tVIsual_mode_orig = VIsual_mode; // remember original area for gv\n\tVIsual_mode = 'V';\n\tnv_operator(cap);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tif (!curbuf->b_p_ma)\n\t    emsg(_(e_cannot_make_changes_modifiable_is_off));\n\telse\n\t{\n\t    if (virtual_active())\n\t\tcoladvance(getviscol());\n\t    invoke_edit(cap, FALSE, cap->arg ? 'V' : 'R', FALSE);\n\t}\n    }\n}\n\n/*\n * \"gr\".\n */\n    static void\nnv_vreplace(cmdarg_T *cap)\n{\n    if (VIsual_active)\n    {\n\tcap->cmdchar = 'r';\n\tcap->nchar = cap->extra_char;\n\tnv_replace(cap);\t// Do same as \"r\" in Visual mode for now\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tif (!curbuf->b_p_ma)\n\t    emsg(_(e_cannot_make_changes_modifiable_is_off));\n\telse\n\t{\n\t    if (cap->extra_char == Ctrl_V)\t// get another character\n\t\tcap->extra_char = get_literal(FALSE);\n\t    stuffcharReadbuff(cap->extra_char);\n\t    stuffcharReadbuff(ESC);\n\t    if (virtual_active())\n\t\tcoladvance(getviscol());\n\t    invoke_edit(cap, TRUE, 'v', FALSE);\n\t}\n    }\n}\n\n/*\n * Swap case for \"~\" command, when it does not work like an operator.\n */\n    static void\nn_swapchar(cmdarg_T *cap)\n{\n    long\tn;\n    pos_T\tstartpos;\n    int\t\tdid_change = 0;\n#ifdef FEAT_NETBEANS_INTG\n    pos_T\tpos;\n    char_u\t*ptr;\n    int\t\tcount;\n#endif\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    if (LINEEMPTY(curwin->w_cursor.lnum) && vim_strchr(p_ww, '~') == NULL)\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    prep_redo_cmd(cap);\n\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    startpos = curwin->w_cursor;\n#ifdef FEAT_NETBEANS_INTG\n    pos = startpos;\n#endif\n    for (n = cap->count1; n > 0; --n)\n    {\n\tdid_change |= swapchar(cap->oap->op_type, &curwin->w_cursor);\n\tinc_cursor();\n\tif (gchar_cursor() == NUL)\n\t{\n\t    if (vim_strchr(p_ww, '~') != NULL\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n#ifdef FEAT_NETBEANS_INTG\n\t\tif (netbeans_active())\n\t\t{\n\t\t    if (did_change)\n\t\t    {\n\t\t\tptr = ml_get(pos.lnum);\n\t\t\tcount = (int)STRLEN(ptr) - pos.col;\n\t\t\tnetbeans_removed(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t\t (long)count);\n\t\t\tnetbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t&ptr[pos.col], count);\n\t\t    }\n\t\t    pos.col = 0;\n\t\t    pos.lnum++;\n\t\t}\n#endif\n\t\t++curwin->w_cursor.lnum;\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (n > 1)\n\t\t{\n\t\t    if (u_savesub(curwin->w_cursor.lnum) == FAIL)\n\t\t\tbreak;\n\t\t    u_clearline();\n\t\t}\n\t    }\n\t    else\n\t\tbreak;\n\t}\n    }\n#ifdef FEAT_NETBEANS_INTG\n    if (did_change && netbeans_active())\n    {\n\tptr = ml_get(pos.lnum);\n\tcount = curwin->w_cursor.col - pos.col;\n\tnetbeans_removed(curbuf, pos.lnum, pos.col, (long)count);\n\tnetbeans_inserted(curbuf, pos.lnum, pos.col, &ptr[pos.col], count);\n    }\n#endif\n\n\n    check_cursor();\n    curwin->w_set_curswant = TRUE;\n    if (did_change)\n    {\n\tchanged_lines(startpos.lnum, startpos.col, curwin->w_cursor.lnum + 1,\n\t\t\t\t\t\t\t\t\t  0L);\n\tcurbuf->b_op_start = startpos;\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tif (curbuf->b_op_end.col > 0)\n\t    --curbuf->b_op_end.col;\n    }\n}\n\n/*\n * Move cursor to mark.\n */\n    static void\nnv_cursormark(cmdarg_T *cap, int flag, pos_T *pos)\n{\n    if (check_mark(pos) == FAIL)\n\tclearop(cap->oap);\n    else\n    {\n\tif (cap->cmdchar == '\\''\n\t\t|| cap->cmdchar == '`'\n\t\t|| cap->cmdchar == '['\n\t\t|| cap->cmdchar == ']')\n\t    setpcmark();\n\tcurwin->w_cursor = *pos;\n\tif (flag)\n\t    beginline(BL_WHITE | BL_FIX);\n\telse\n\t    check_cursor();\n    }\n    cap->oap->motion_type = flag ? MLINE : MCHAR;\n    if (cap->cmdchar == '`')\n\tcap->oap->use_reg_one = TRUE;\n    cap->oap->inclusive = FALSE;\t\t// ignored if not MCHAR\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * Handle commands that are operators in Visual mode.\n */\n    static void\nv_visop(cmdarg_T *cap)\n{\n    static char_u trans[] = \"YyDdCcxdXdAAIIrr\";\n\n    // Uppercase means linewise, except in block mode, then \"D\" deletes till\n    // the end of the line, and \"C\" replaces till EOL\n    if (isupper(cap->cmdchar))\n    {\n\tif (VIsual_mode != Ctrl_V)\n\t{\n\t    VIsual_mode_orig = VIsual_mode;\n\t    VIsual_mode = 'V';\n\t}\n\telse if (cap->cmdchar == 'C' || cap->cmdchar == 'D')\n\t    curwin->w_curswant = MAXCOL;\n    }\n    cap->cmdchar = *(vim_strchr(trans, cap->cmdchar) + 1);\n    nv_operator(cap);\n}\n\n/*\n * \"s\" and \"S\" commands.\n */\n    static void\nnv_subst(cmdarg_T *cap)\n{\n#ifdef FEAT_TERMINAL\n    // When showing output of term_dumpdiff() swap the top and bottom.\n    if (term_swap_diff() == OK)\n\treturn;\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n    if (VIsual_active)\t// \"vs\" and \"vS\" are the same as \"vc\"\n    {\n\tif (cap->cmdchar == 'S')\n\t{\n\t    VIsual_mode_orig = VIsual_mode;\n\t    VIsual_mode = 'V';\n\t}\n\tcap->cmdchar = 'c';\n\tnv_operator(cap);\n    }\n    else\n\tnv_optrans(cap);\n}\n\n/*\n * Abbreviated commands.\n */\n    static void\nnv_abbrev(cmdarg_T *cap)\n{\n    if (cap->cmdchar == K_DEL || cap->cmdchar == K_KDEL)\n\tcap->cmdchar = 'x';\t\t// DEL key behaves like 'x'\n\n    // in Visual mode these commands are operators\n    if (VIsual_active)\n\tv_visop(cap);\n    else\n\tnv_optrans(cap);\n}\n\n/*\n * Translate a command into another command.\n */\n    static void\nnv_optrans(cmdarg_T *cap)\n{\n    static char_u *(ar[8]) = {(char_u *)\"dl\", (char_u *)\"dh\",\n\t\t\t      (char_u *)\"d$\", (char_u *)\"c$\",\n\t\t\t      (char_u *)\"cl\", (char_u *)\"cc\",\n\t\t\t      (char_u *)\"yy\", (char_u *)\":s\\r\"};\n    static char_u *str = (char_u *)\"xXDCsSY&\";\n\n    if (!checkclearopq(cap->oap))\n    {\n\t// In Vi \"2D\" doesn't delete the next line.  Can't translate it\n\t// either, because \"2.\" should also not use the count.\n\tif (cap->cmdchar == 'D' && vim_strchr(p_cpo, CPO_HASH) != NULL)\n\t{\n\t    cap->oap->start = curwin->w_cursor;\n\t    cap->oap->op_type = OP_DELETE;\n#ifdef FEAT_EVAL\n\t    set_op_var(OP_DELETE);\n#endif\n\t    cap->count1 = 1;\n\t    nv_dollar(cap);\n\t    finish_op = TRUE;\n\t    ResetRedobuff();\n\t    AppendCharToRedobuff('D');\n\t}\n\telse\n\t{\n\t    if (cap->count0)\n\t\tstuffnumReadbuff(cap->count0);\n\t    stuffReadbuff(ar[(int)(vim_strchr(str, cap->cmdchar) - str)]);\n\t}\n    }\n    cap->opcount = 0;\n}\n\n/*\n * \"'\" and \"`\" commands.  Also for \"g'\" and \"g`\".\n * cap->arg is TRUE for \"'\" and \"g'\".\n */\n    static void\nnv_gomark(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n    int\t\tc;\n#ifdef FEAT_FOLDING\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\told_KeyTyped = KeyTyped;    // getting file may reset it\n#endif\n\n    if (cap->cmdchar == 'g')\n\tc = cap->extra_char;\n    else\n\tc = cap->nchar;\n    pos = getmark(c, (cap->oap->op_type == OP_NOP));\n    if (pos == (pos_T *)-1)\t    // jumped to other file\n    {\n\tif (cap->arg)\n\t{\n\t    check_cursor_lnum();\n\t    beginline(BL_WHITE | BL_FIX);\n\t}\n\telse\n\t    check_cursor();\n    }\n    else\n\tnv_cursormark(cap, cap->arg, pos);\n\n    // May need to clear the coladd that a mark includes.\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    check_cursor_col();\n#ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && pos != NULL\n\t    && (pos == (pos_T *)-1 || !EQUAL_POS(old_cursor, *pos))\n\t    && (fdo_flags & FDO_MARK)\n\t    && old_KeyTyped)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle CTRL-O, CTRL-I, \"g;\", \"g,\" and \"CTRL-Tab\" commands.\n */\n    static void\nnv_pcmark(cmdarg_T *cap)\n{\n#ifdef FEAT_JUMPLIST\n    pos_T\t*pos;\n# ifdef FEAT_FOLDING\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n    int\t\told_KeyTyped = KeyTyped;    // getting file may reset it\n# endif\n\n    if (!checkclearopq(cap->oap))\n    {\n\tif (cap->cmdchar == TAB && mod_mask == MOD_MASK_CTRL)\n\t{\n\t    if (goto_tabpage_lastused() == FAIL)\n\t\tclearopbeep(cap->oap);\n\t    return;\n\t}\n\tif (cap->cmdchar == 'g')\n\t    pos = movechangelist((int)cap->count1);\n\telse\n\t    pos = movemark((int)cap->count1);\n\tif (pos == (pos_T *)-1)\t\t// jump to other file\n\t{\n\t    curwin->w_set_curswant = TRUE;\n\t    check_cursor();\n\t}\n\telse if (pos != NULL)\t\t    // can jump\n\t    nv_cursormark(cap, FALSE, pos);\n\telse if (cap->cmdchar == 'g')\n\t{\n\t    if (curbuf->b_changelistlen == 0)\n\t\temsg(_(\"E664: changelist is empty\"));\n\t    else if (cap->count1 < 0)\n\t\temsg(_(\"E662: At start of changelist\"));\n\t    else\n\t\temsg(_(\"E663: At end of changelist\"));\n\t}\n\telse\n\t    clearopbeep(cap->oap);\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP\n\t\t&& (pos == (pos_T *)-1 || lnum != curwin->w_cursor.lnum)\n\t\t&& (fdo_flags & FDO_MARK)\n\t\t&& old_KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n#else\n    clearopbeep(cap->oap);\n#endif\n}\n\n/*\n * Handle '\"' command.\n */\n    static void\nnv_regname(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_EVAL\n    if (cap->nchar == '=')\n\tcap->nchar = get_expr_register();\n#endif\n    if (cap->nchar != NUL && valid_yank_reg(cap->nchar, FALSE))\n    {\n\tcap->oap->regname = cap->nchar;\n\tcap->opcount = cap->count0;\t// remember count before '\"'\n#ifdef FEAT_EVAL\n\tset_reg_var(cap->oap->regname);\n#endif\n    }\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle \"v\", \"V\" and \"CTRL-V\" commands.\n * Also for \"gh\", \"gH\" and \"g^H\" commands: Always start Select mode, cap->arg\n * is TRUE.\n * Handle CTRL-Q just like CTRL-V.\n */\n    static void\nnv_visual(cmdarg_T *cap)\n{\n    if (cap->cmdchar == Ctrl_Q)\n\tcap->cmdchar = Ctrl_V;\n\n    // 'v', 'V' and CTRL-V can be used while an operator is pending to make it\n    // characterwise, linewise, or blockwise.\n    if (cap->oap->op_type != OP_NOP)\n    {\n\tmotion_force = cap->oap->motion_force = cap->cmdchar;\n\tfinish_op = FALSE;\t// operator doesn't finish now but later\n\treturn;\n    }\n\n    VIsual_select = cap->arg;\n    if (VIsual_active)\t    // change Visual mode\n    {\n\tif (VIsual_mode == cap->cmdchar)    // stop visual mode\n\t    end_visual_mode();\n\telse\t\t\t\t    // toggle char/block mode\n\t{\t\t\t\t    //\t   or char/line mode\n\t    VIsual_mode = cap->cmdchar;\n\t    showmode();\n\t}\n\tredraw_curbuf_later(INVERTED);\t    // update the inversion\n    }\n    else\t\t    // start Visual mode\n    {\n\tcheck_visual_highlight();\n\tif (cap->count0 > 0 && resel_VIsual_mode != NUL)\n\t{\n\t    // use previously selected part\n\t    VIsual = curwin->w_cursor;\n\n\t    VIsual_active = TRUE;\n\t    VIsual_reselect = TRUE;\n\t    if (!cap->arg)\n\t\t// start Select mode when 'selectmode' contains \"cmd\"\n\t\tmay_start_select('c');\n\t    setmouse();\n\t    if (p_smd && msg_silent == 0)\n\t\tredraw_cmdline = TRUE;\t    // show visual mode later\n\t    /*\n\t     * For V and ^V, we multiply the number of lines even if there\n\t     * was only one -- webb\n\t     */\n\t    if (resel_VIsual_mode != 'v' || resel_VIsual_line_count > 1)\n\t    {\n\t\tcurwin->w_cursor.lnum +=\n\t\t\t\t    resel_VIsual_line_count * cap->count0 - 1;\n\t\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    }\n\t    VIsual_mode = resel_VIsual_mode;\n\t    if (VIsual_mode == 'v')\n\t    {\n\t\tif (resel_VIsual_line_count <= 1)\n\t\t{\n\t\t    validate_virtcol();\n\t\t    curwin->w_curswant = curwin->w_virtcol\n\t\t\t\t\t+ resel_VIsual_vcol * cap->count0 - 1;\n\t\t}\n\t\telse\n\t\t    curwin->w_curswant = resel_VIsual_vcol;\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    if (resel_VIsual_vcol == MAXCOL)\n\t    {\n\t\tcurwin->w_curswant = MAXCOL;\n\t\tcoladvance((colnr_T)MAXCOL);\n\t    }\n\t    else if (VIsual_mode == Ctrl_V)\n\t    {\n\t\tvalidate_virtcol();\n\t\tcurwin->w_curswant = curwin->w_virtcol\n\t\t\t\t\t+ resel_VIsual_vcol * cap->count0 - 1;\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n\t    redraw_curbuf_later(INVERTED);\t// show the inversion\n\t}\n\telse\n\t{\n\t    if (!cap->arg)\n\t\t// start Select mode when 'selectmode' contains \"cmd\"\n\t\tmay_start_select('c');\n\t    n_start_visual_mode(cap->cmdchar);\n\t    if (VIsual_mode != 'V' && *p_sel == 'e')\n\t\t++cap->count1;  // include one more char\n\t    if (cap->count0 > 0 && --cap->count1 > 0)\n\t    {\n\t\t// With a count select that many characters or lines.\n\t\tif (VIsual_mode == 'v' || VIsual_mode == Ctrl_V)\n\t\t    nv_right(cap);\n\t\telse if (VIsual_mode == 'V')\n\t\t    nv_down(cap);\n\t    }\n\t}\n    }\n}\n\n/*\n * Start selection for Shift-movement keys.\n */\n    void\nstart_selection(void)\n{\n    // if 'selectmode' contains \"key\", start Select mode\n    may_start_select('k');\n    n_start_visual_mode('v');\n}\n\n/*\n * Start Select mode, if \"c\" is in 'selectmode' and not in a mapping or menu.\n */\n    void\nmay_start_select(int c)\n{\n    VIsual_select = (stuff_empty() && typebuf_typed()\n\t\t    && (vim_strchr(p_slm, c) != NULL));\n}\n\n/*\n * Start Visual mode \"c\".\n * Should set VIsual_select before calling this.\n */\n    static void\nn_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n\n    // Corner case: the 0 position in a tab may change when going into\n    // virtualedit.  Recalculate curwin->w_cursor to avoid bad highlighting.\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n\n    setmouse();\n#ifdef FEAT_CONCEAL\n    // Check if redraw is needed after changing the state.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t// show visual mode later\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end may still be the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n\n    // Only need to redraw this line, unless still need to redraw an old\n    // Visual area (when 'lazyredraw' is set).\n    if (curwin->w_redr_type < INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}\n\n\n/*\n * CTRL-W: Window commands\n */\n    static void\nnv_window(cmdarg_T *cap)\n{\n    if (cap->nchar == ':')\n    {\n\t// \"CTRL-W :\" is the same as typing \":\"; useful in a terminal window\n\tcap->cmdchar = ':';\n\tcap->nchar = NUL;\n\tnv_colon(cap);\n    }\n    else if (!checkclearop(cap->oap))\n\tdo_window(cap->nchar, cap->count0, NUL); // everything is in window.c\n}\n\n/*\n * CTRL-Z: Suspend\n */\n    static void\nnv_suspend(cmdarg_T *cap)\n{\n    clearop(cap->oap);\n    if (VIsual_active)\n\tend_visual_mode();\t\t// stop Visual mode\n    do_cmdline_cmd((char_u *)\"stop\");\n}\n\n/*\n * Commands starting with \"g\".\n */\n    static void\nnv_g_cmd(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    pos_T\ttpos;\n    int\t\ti;\n    int\t\tflag = FALSE;\n\n    switch (cap->nchar)\n    {\n    case Ctrl_A:\n    case Ctrl_X:\n#ifdef MEM_PROFILE\n    /*\n     * \"g^A\": dump log of used memory.\n     */\n\tif (!VIsual_active && cap->nchar == Ctrl_A)\n\t    vim_mem_profile_dump();\n\telse\n#endif\n    /*\n     * \"g^A/g^X\": sequentially increment visually selected region\n     */\n\t     if (VIsual_active)\n\t{\n\t    cap->arg = TRUE;\n\t    cap->cmdchar = cap->nchar;\n\t    cap->nchar = NUL;\n\t    nv_addsub(cap);\n\t}\n\telse\n\t    clearopbeep(oap);\n\tbreak;\n\n    /*\n     * \"gR\": Enter virtual replace mode.\n     */\n    case 'R':\n\tcap->arg = TRUE;\n\tnv_Replace(cap);\n\tbreak;\n\n    case 'r':\n\tnv_vreplace(cap);\n\tbreak;\n\n    case '&':\n\tdo_cmdline_cmd((char_u *)\"%s//~/&\");\n\tbreak;\n\n    /*\n     * \"gv\": Reselect the previous Visual area.  If Visual already active,\n     *\t     exchange previous and current Visual area.\n     */\n    case 'v':\n\tif (checkclearop(oap))\n\t    break;\n\n\tif (\t   curbuf->b_visual.vi_start.lnum == 0\n\t\t|| curbuf->b_visual.vi_start.lnum > curbuf->b_ml.ml_line_count\n\t\t|| curbuf->b_visual.vi_end.lnum == 0)\n\t    beep_flush();\n\telse\n\t{\n\t    // set w_cursor to the start of the Visual area, tpos to the end\n\t    if (VIsual_active)\n\t    {\n\t\ti = VIsual_mode;\n\t\tVIsual_mode = curbuf->b_visual.vi_mode;\n\t\tcurbuf->b_visual.vi_mode = i;\n# ifdef FEAT_EVAL\n\t\tcurbuf->b_visual_mode_eval = i;\n# endif\n\t\ti = curwin->w_curswant;\n\t\tcurwin->w_curswant = curbuf->b_visual.vi_curswant;\n\t\tcurbuf->b_visual.vi_curswant = i;\n\n\t\ttpos = curbuf->b_visual.vi_end;\n\t\tcurbuf->b_visual.vi_end = curwin->w_cursor;\n\t\tcurwin->w_cursor = curbuf->b_visual.vi_start;\n\t\tcurbuf->b_visual.vi_start = VIsual;\n\t    }\n\t    else\n\t    {\n\t\tVIsual_mode = curbuf->b_visual.vi_mode;\n\t\tcurwin->w_curswant = curbuf->b_visual.vi_curswant;\n\t\ttpos = curbuf->b_visual.vi_end;\n\t\tcurwin->w_cursor = curbuf->b_visual.vi_start;\n\t    }\n\n\t    VIsual_active = TRUE;\n\t    VIsual_reselect = TRUE;\n\n\t    // Set Visual to the start and w_cursor to the end of the Visual\n\t    // area.  Make sure they are on an existing character.\n\t    check_cursor();\n\t    VIsual = curwin->w_cursor;\n\t    curwin->w_cursor = tpos;\n\t    check_cursor();\n\t    update_topline();\n\t    /*\n\t     * When called from normal \"g\" command: start Select mode when\n\t     * 'selectmode' contains \"cmd\".  When called for K_SELECT, always\n\t     * start Select mode.\n\t     */\n\t    if (cap->arg)\n\t\tVIsual_select = TRUE;\n\t    else\n\t\tmay_start_select('c');\n\t    setmouse();\n#ifdef FEAT_CLIPBOARD\n\t    // Make sure the clipboard gets updated.  Needed because start and\n\t    // end are still the same, and the selection needs to be owned\n\t    clip_star.vmode = NUL;\n#endif\n\t    redraw_curbuf_later(INVERTED);\n\t    showmode();\n\t}\n\tbreak;\n    /*\n     * \"gV\": Don't reselect the previous Visual area after a Select mode\n     *\t     mapping of menu.\n     */\n    case 'V':\n\tVIsual_reselect = FALSE;\n\tbreak;\n\n    /*\n     * \"gh\":  start Select mode.\n     * \"gH\":  start Select line mode.\n     * \"g^H\": start Select block mode.\n     */\n    case K_BS:\n\tcap->nchar = Ctrl_H;\n\t// FALLTHROUGH\n    case 'h':\n    case 'H':\n    case Ctrl_H:\n# ifdef EBCDIC\n\t// EBCDIC: 'v'-'h' != '^v'-'^h'\n\tif (cap->nchar == Ctrl_H)\n\t    cap->cmdchar = Ctrl_V;\n\telse\n# endif\n\tcap->cmdchar = cap->nchar + ('v' - 'h');\n\tcap->arg = TRUE;\n\tnv_visual(cap);\n\tbreak;\n\n    // \"gn\", \"gN\" visually select next/previous search match\n    // \"gn\" selects next match\n    // \"gN\" selects previous match\n    case 'N':\n    case 'n':\n\tif (!current_search(cap->count1, cap->nchar == 'n'))\n\t    clearopbeep(oap);\n\tbreak;\n\n    /*\n     * \"gj\" and \"gk\" two new funny movement keys -- up and down\n     * movement based on *screen* line rather than *file* line.\n     */\n    case 'j':\n    case K_DOWN:\n\t// with 'nowrap' it works just like the normal \"j\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_down(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, FORWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case 'k':\n    case K_UP:\n\t// with 'nowrap' it works just like the normal \"k\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_up(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, BACKWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    /*\n     * \"gJ\": join two lines without inserting a space.\n     */\n    case 'J':\n\tnv_join(cap);\n\tbreak;\n\n    /*\n     * \"g0\", \"g^\" and \"g$\": Like \"0\", \"^\" and \"$\" but for screen lines.\n     * \"gm\": middle of \"g0\" and \"g$\".\n     */\n    case '^':\n\tflag = TRUE;\n\t// FALLTHROUGH\n\n    case '0':\n    case 'm':\n    case K_HOME:\n    case K_KHOME:\n\toap->motion_type = MCHAR;\n\toap->inclusive = FALSE;\n\tif (curwin->w_p_wrap && curwin->w_width != 0)\n\t{\n\t    int\t\twidth1 = curwin->w_width - curwin_col_off();\n\t    int\t\twidth2 = width1 + curwin_col_off2();\n\n\t    validate_virtcol();\n\t    i = 0;\n\t    if (curwin->w_virtcol >= (colnr_T)width1 && width2 > 0)\n\t\ti = (curwin->w_virtcol - width1) / width2 * width2 + width1;\n\t}\n\telse\n\t    i = curwin->w_leftcol;\n\t// Go to the middle of the screen line.  When 'number' or\n\t// 'relativenumber' is on and lines are wrapping the middle can be more\n\t// to the left.\n\tif (cap->nchar == 'm')\n\t    i += (curwin->w_width - curwin_col_off()\n\t\t    + ((curwin->w_p_wrap && i > 0)\n\t\t\t? curwin_col_off2() : 0)) / 2;\n\tcoladvance((colnr_T)i);\n\tif (flag)\n\t{\n\t    do\n\t\ti = gchar_cursor();\n\t    while (VIM_ISWHITE(i) && oneright() == OK);\n\t    curwin->w_valid &= ~VALID_WCOL;\n\t}\n\tcurwin->w_set_curswant = TRUE;\n\tbreak;\n\n    case 'M':\n\t{\n\t    char_u  *ptr = ml_get_curline();\n\n\t    oap->motion_type = MCHAR;\n\t    oap->inclusive = FALSE;\n\t    if (has_mbyte)\n\t\ti = mb_string2cells(ptr, (int)STRLEN(ptr));\n\t    else\n\t\ti = (int)STRLEN(ptr);\n\t    if (cap->count0 > 0 && cap->count0 <= 100)\n\t\tcoladvance((colnr_T)(i * cap->count0 / 100));\n\t    else\n\t\tcoladvance((colnr_T)(i / 2));\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\tbreak;\n\n    case '_':\n\t// \"g_\": to the last non-blank character in the line or <count> lines\n\t// downward.\n\tcap->oap->motion_type = MCHAR;\n\tcap->oap->inclusive = TRUE;\n\tcurwin->w_curswant = MAXCOL;\n\tif (cursor_down((long)(cap->count1 - 1),\n\t\t\t\t\t cap->oap->op_type == OP_NOP) == FAIL)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    char_u  *ptr = ml_get_curline();\n\n\t    // In Visual mode we may end up after the line.\n\t    if (curwin->w_cursor.col > 0 && ptr[curwin->w_cursor.col] == NUL)\n\t\t--curwin->w_cursor.col;\n\n\t    // Decrease the cursor column until it's on a non-blank.\n\t    while (curwin->w_cursor.col > 0\n\t\t\t\t    && VIM_ISWHITE(ptr[curwin->w_cursor.col]))\n\t\t--curwin->w_cursor.col;\n\t    curwin->w_set_curswant = TRUE;\n\t    adjust_for_sel(cap);\n\t}\n\tbreak;\n\n    case '$':\n    case K_END:\n    case K_KEND:\n\t{\n\t    int col_off = curwin_col_off();\n\n\t    oap->motion_type = MCHAR;\n\t    oap->inclusive = TRUE;\n\t    if (curwin->w_p_wrap && curwin->w_width != 0)\n\t    {\n\t\tcurwin->w_curswant = MAXCOL;    // so we stay at the end\n\t\tif (cap->count1 == 1)\n\t\t{\n\t\t    int\t\twidth1 = curwin->w_width - col_off;\n\t\t    int\t\twidth2 = width1 + curwin_col_off2();\n\n\t\t    validate_virtcol();\n\t\t    i = width1 - 1;\n\t\t    if (curwin->w_virtcol >= (colnr_T)width1)\n\t\t\ti += ((curwin->w_virtcol - width1) / width2 + 1)\n\t\t\t\t\t\t\t\t     * width2;\n\t\t    coladvance((colnr_T)i);\n\n\t\t    // Make sure we stick in this column.\n\t\t    validate_virtcol();\n\t\t    curwin->w_curswant = curwin->w_virtcol;\n\t\t    curwin->w_set_curswant = FALSE;\n\t\t    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)\n\t\t    {\n\t\t\t/*\n\t\t\t * Check for landing on a character that got split at\n\t\t\t * the end of the line.  We do not want to advance to\n\t\t\t * the next screen line.\n\t\t\t */\n\t\t\tif (curwin->w_virtcol > (colnr_T)i)\n\t\t\t    --curwin->w_cursor.col;\n\t\t    }\n\t\t}\n\t\telse if (nv_screengo(oap, FORWARD, cap->count1 - 1) == FAIL)\n\t\t    clearopbeep(oap);\n\t    }\n\t    else\n\t    {\n\t\tif (cap->count1 > 1)\n\t\t    // if it fails, let the cursor still move to the last char\n\t\t    (void)cursor_down(cap->count1 - 1, FALSE);\n\n\t\ti = curwin->w_leftcol + curwin->w_width - col_off - 1;\n\t\tcoladvance((colnr_T)i);\n\n\t\t// if the character doesn't fit move one back\n\t\tif (curwin->w_cursor.col > 0\n\t\t\t\t       && (*mb_ptr2cells)(ml_get_cursor()) > 1)\n\t\t{\n\t\t    colnr_T vcol;\n\n\t\t    getvvcol(curwin, &curwin->w_cursor, NULL, NULL, &vcol);\n\t\t    if (vcol >= curwin->w_leftcol + curwin->w_width - col_off)\n\t\t\t--curwin->w_cursor.col;\n\t\t}\n\n\t\t// Make sure we stick in this column.\n\t\tvalidate_virtcol();\n\t\tcurwin->w_curswant = curwin->w_virtcol;\n\t\tcurwin->w_set_curswant = FALSE;\n\t    }\n\t}\n\tbreak;\n\n    /*\n     * \"g*\" and \"g#\", like \"*\" and \"#\" but without using \"\\<\" and \"\\>\"\n     */\n    case '*':\n    case '#':\n#if POUND != '#'\n    case POUND:\t\t// pound sign (sometimes equal to '#')\n#endif\n    case Ctrl_RSB:\t\t// :tag or :tselect for current identifier\n    case ']':\t\t\t// :tselect for current identifier\n\tnv_ident(cap);\n\tbreak;\n\n    /*\n     * ge and gE: go back to end of word\n     */\n    case 'e':\n    case 'E':\n\toap->motion_type = MCHAR;\n\tcurwin->w_set_curswant = TRUE;\n\toap->inclusive = TRUE;\n\tif (bckend_word(cap->count1, cap->nchar == 'E', FALSE) == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    /*\n     * \"g CTRL-G\": display info about cursor position\n     */\n    case Ctrl_G:\n\tcursor_pos_info(NULL);\n\tbreak;\n\n    /*\n     * \"gi\": start Insert at the last position.\n     */\n    case 'i':\n\tif (curbuf->b_last_insert.lnum != 0)\n\t{\n\t    curwin->w_cursor = curbuf->b_last_insert;\n\t    check_cursor_lnum();\n\t    i = (int)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > (colnr_T)i)\n\t    {\n\t\tif (virtual_active())\n\t\t    curwin->w_cursor.coladd += curwin->w_cursor.col - i;\n\t\tcurwin->w_cursor.col = i;\n\t    }\n\t}\n\tcap->cmdchar = 'i';\n\tnv_edit(cap);\n\tbreak;\n\n    /*\n     * \"gI\": Start insert in column 1.\n     */\n    case 'I':\n\tbeginline(0);\n\tif (!checkclearopq(oap))\n\t    invoke_edit(cap, FALSE, 'g', FALSE);\n\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n    /*\n     * \"gf\": goto file, edit file under cursor\n     * \"]f\" and \"[f\": can also be used.\n     */\n    case 'f':\n    case 'F':\n\tnv_gotofile(cap);\n\tbreak;\n#endif\n\n\t// \"g'm\" and \"g`m\": jump to mark without setting pcmark\n    case '\\'':\n\tcap->arg = TRUE;\n\t// FALLTHROUGH\n    case '`':\n\tnv_gomark(cap);\n\tbreak;\n\n    /*\n     * \"gs\": Goto sleep.\n     */\n    case 's':\n\tdo_sleep(cap->count1 * 1000L, FALSE);\n\tbreak;\n\n    /*\n     * \"ga\": Display the ascii value of the character under the\n     * cursor.\tIt is displayed in decimal, hex, and octal. -- webb\n     */\n    case 'a':\n\tdo_ascii(NULL);\n\tbreak;\n\n    /*\n     * \"g8\": Display the bytes used for the UTF-8 character under the\n     * cursor.\tIt is displayed in hex.\n     * \"8g8\" finds illegal byte sequence.\n     */\n    case '8':\n\tif (cap->count0 == 8)\n\t    utf_find_illegal();\n\telse\n\t    show_utf8();\n\tbreak;\n\n    // \"g<\": show scrollback text\n    case '<':\n\tshow_sb_text();\n\tbreak;\n\n    /*\n     * \"gg\": Goto the first line in file.  With a count it goes to\n     * that line number like for \"G\". -- webb\n     */\n    case 'g':\n\tcap->arg = FALSE;\n\tnv_goto(cap);\n\tbreak;\n\n    /*\n     *\t Two-character operators:\n     *\t \"gq\"\t    Format text\n     *\t \"gw\"\t    Format text and keep cursor position\n     *\t \"g~\"\t    Toggle the case of the text.\n     *\t \"gu\"\t    Change text to lower case.\n     *\t \"gU\"\t    Change text to upper case.\n     *   \"g?\"\t    rot13 encoding\n     *   \"g@\"\t    call 'operatorfunc'\n     */\n    case 'q':\n    case 'w':\n\toap->cursor_start = curwin->w_cursor;\n\t// FALLTHROUGH\n    case '~':\n    case 'u':\n    case 'U':\n    case '?':\n    case '@':\n\tnv_operator(cap);\n\tbreak;\n\n    /*\n     * \"gd\": Find first occurrence of pattern under the cursor in the\n     *\t current function\n     * \"gD\": idem, but in the current file.\n     */\n    case 'd':\n    case 'D':\n\tnv_gd(oap, cap->nchar, (int)cap->count0);\n\tbreak;\n\n    /*\n     * g<*Mouse> : <C-*mouse>\n     */\n    case K_MIDDLEMOUSE:\n    case K_MIDDLEDRAG:\n    case K_MIDDLERELEASE:\n    case K_LEFTMOUSE:\n    case K_LEFTDRAG:\n    case K_LEFTRELEASE:\n    case K_MOUSEMOVE:\n    case K_RIGHTMOUSE:\n    case K_RIGHTDRAG:\n    case K_RIGHTRELEASE:\n    case K_X1MOUSE:\n    case K_X1DRAG:\n    case K_X1RELEASE:\n    case K_X2MOUSE:\n    case K_X2DRAG:\n    case K_X2RELEASE:\n\tmod_mask = MOD_MASK_CTRL;\n\t(void)do_mouse(oap, cap->nchar, BACKWARD, cap->count1, 0);\n\tbreak;\n\n    case K_IGNORE:\n\tbreak;\n\n    /*\n     * \"gP\" and \"gp\": same as \"P\" and \"p\" but leave cursor just after new text\n     */\n    case 'p':\n    case 'P':\n\tnv_put(cap);\n\tbreak;\n\n#ifdef FEAT_BYTEOFF\n    // \"go\": goto byte count from start of buffer\n    case 'o':\n\tgoto_byte(cap->count0);\n\tbreak;\n#endif\n\n    // \"gQ\": improved Ex mode\n    case 'Q':\n\tif (text_locked())\n\t{\n\t    clearopbeep(cap->oap);\n\t    text_locked_msg();\n\t    break;\n\t}\n\n\tif (!checkclearopq(oap))\n\t    do_exmode(TRUE);\n\tbreak;\n\n#ifdef FEAT_JUMPLIST\n    case ',':\n\tnv_pcmark(cap);\n\tbreak;\n\n    case ';':\n\tcap->count1 = -cap->count1;\n\tnv_pcmark(cap);\n\tbreak;\n#endif\n\n    case 't':\n\tif (!checkclearop(oap))\n\t    goto_tabpage((int)cap->count0);\n\tbreak;\n    case 'T':\n\tif (!checkclearop(oap))\n\t    goto_tabpage(-(int)cap->count1);\n\tbreak;\n\n    case TAB:\n\tif (!checkclearop(oap) && goto_tabpage_lastused() == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case '+':\n    case '-': // \"g+\" and \"g-\": undo or redo along the timeline\n\tif (!checkclearopq(oap))\n\t    undo_time(cap->nchar == '-' ? -cap->count1 : cap->count1,\n\t\t\t\t\t\t\t FALSE, FALSE, FALSE);\n\tbreak;\n\n    default:\n\tclearopbeep(oap);\n\tbreak;\n    }\n}\n\n/*\n * Handle \"o\" and \"O\" commands.\n */\n    static void\nn_opencmd(cmdarg_T *cap)\n{\n#ifdef FEAT_CONCEAL\n    linenr_T\toldline = curwin->w_cursor.lnum;\n#endif\n\n    if (!checkclearopq(cap->oap))\n    {\n#ifdef FEAT_FOLDING\n\tif (cap->cmdchar == 'O')\n\t    // Open above the first line of a folded sequence of lines\n\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\telse\n\t    // Open below the last line of a folded sequence of lines\n\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\tNULL, &curwin->w_cursor.lnum);\n#endif\n\tif (u_save((linenr_T)(curwin->w_cursor.lnum -\n\t\t\t\t\t       (cap->cmdchar == 'O' ? 1 : 0)),\n\t\t   (linenr_T)(curwin->w_cursor.lnum +\n\t\t\t\t\t       (cap->cmdchar == 'o' ? 1 : 0))\n\t\t       ) == OK\n\t\t&& open_line(cap->cmdchar == 'O' ? BACKWARD : FORWARD,\n\t\t\t has_format_option(FO_OPEN_COMS) ? OPENLINE_DO_COM : 0,\n\t\t\t\t\t\t\t\t      0) == OK)\n\t{\n#ifdef FEAT_CONCEAL\n\t    if (curwin->w_p_cole > 0 && oldline != curwin->w_cursor.lnum)\n\t\tredrawWinline(curwin, oldline);\n#endif\n#ifdef FEAT_SYN_HL\n\t    if (curwin->w_p_cul)\n\t\t// force redraw of cursorline\n\t\tcurwin->w_valid &= ~VALID_CROW;\n#endif\n\t    // When '#' is in 'cpoptions' ignore the count.\n\t    if (vim_strchr(p_cpo, CPO_HASH) != NULL)\n\t\tcap->count1 = 1;\n\t    invoke_edit(cap, FALSE, cap->cmdchar, TRUE);\n\t}\n    }\n}\n\n/*\n * \".\" command: redo last change.\n */\n    static void\nnv_dot(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n\t/*\n\t * If \"restart_edit\" is TRUE, the last but one command is repeated\n\t * instead of the last command (inserting text). This is used for\n\t * CTRL-O <.> in insert mode.\n\t */\n\tif (start_redo(cap->count0, restart_edit != 0 && !arrow_used) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * CTRL-R: undo undo\n */\n    static void\nnv_redo(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n\tu_redo((int)cap->count1);\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * Handle \"U\" command.\n */\n    static void\nnv_Undo(cmdarg_T *cap)\n{\n    // In Visual mode and typing \"gUU\" triggers an operator\n    if (cap->oap->op_type == OP_UPPER || VIsual_active)\n    {\n\t// translate \"gUU\" to \"gUgU\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'U';\n\tnv_operator(cap);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tu_undoline();\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * '~' command: If tilde is not an operator and Visual is off: swap case of a\n * single character.\n */\n    static void\nnv_tilde(cmdarg_T *cap)\n{\n    if (!p_to && !VIsual_active && cap->oap->op_type != OP_TILDE)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf) && !prompt_curpos_editable())\n\t{\n\t    clearopbeep(cap->oap);\n\t    return;\n\t}\n#endif\n\tn_swapchar(cap);\n    }\n    else\n\tnv_operator(cap);\n}\n\n/*\n * Handle an operator command.\n * The actual work is done by do_pending_operator().\n */\n    static void\nnv_operator(cmdarg_T *cap)\n{\n    int\t    op_type;\n\n    op_type = get_op_type(cap->cmdchar, cap->nchar);\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && op_is_change(op_type) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    if (op_type == cap->oap->op_type)\t    // double operator works on lines\n\tnv_lineop(cap);\n    else if (!checkclearop(cap->oap))\n    {\n\tcap->oap->start = curwin->w_cursor;\n\tcap->oap->op_type = op_type;\n#ifdef FEAT_EVAL\n\tset_op_var(op_type);\n#endif\n    }\n}\n\n#ifdef FEAT_EVAL\n/*\n * Set v:operator to the characters for \"optype\".\n */\n    static void\nset_op_var(int optype)\n{\n    char_u\topchars[3];\n\n    if (optype == OP_NOP)\n\tset_vim_var_string(VV_OP, NULL, 0);\n    else\n    {\n\topchars[0] = get_op_char(optype);\n\topchars[1] = get_extra_op_char(optype);\n\topchars[2] = NUL;\n\tset_vim_var_string(VV_OP, opchars, -1);\n    }\n}\n#endif\n\n/*\n * Handle linewise operator \"dd\", \"yy\", etc.\n *\n * \"_\" is is a strange motion command that helps make operators more logical.\n * It is actually implemented, but not documented in the real Vi.  This motion\n * command actually refers to \"the current line\".  Commands like \"dd\" and \"yy\"\n * are really an alternate form of \"d_\" and \"y_\".  It does accept a count, so\n * \"d3_\" works to delete 3 lines.\n */\n    static void\nnv_lineop(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MLINE;\n    if (cursor_down(cap->count1 - 1L, cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n    else if (  (cap->oap->op_type == OP_DELETE // only with linewise motions\n\t\t&& cap->oap->motion_force != 'v'\n\t\t&& cap->oap->motion_force != Ctrl_V)\n\t    || cap->oap->op_type == OP_LSHIFT\n\t    || cap->oap->op_type == OP_RSHIFT)\n\tbeginline(BL_SOL | BL_FIX);\n    else if (cap->oap->op_type != OP_YANK)\t// 'Y' does not move cursor\n\tbeginline(BL_WHITE | BL_FIX);\n}\n\n/*\n * <Home> command.\n */\n    static void\nnv_home(cmdarg_T *cap)\n{\n    // CTRL-HOME is like \"gg\"\n    if (mod_mask & MOD_MASK_CTRL)\n\tnv_goto(cap);\n    else\n    {\n\tcap->count0 = 1;\n\tnv_pipe(cap);\n    }\n    ins_at_eol = FALSE;\t    // Don't move cursor past eol (only necessary in a\n\t\t\t    // one-character line).\n}\n\n/*\n * \"|\" command.\n */\n    static void\nnv_pipe(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    beginline(0);\n    if (cap->count0 > 0)\n    {\n\tcoladvance((colnr_T)(cap->count0 - 1));\n\tcurwin->w_curswant = (colnr_T)(cap->count0 - 1);\n    }\n    else\n\tcurwin->w_curswant = 0;\n    // keep curswant at the column where we wanted to go, not where\n    // we ended; differs if line is too short\n    curwin->w_set_curswant = FALSE;\n}\n\n/*\n * Handle back-word command \"b\" and \"B\".\n * cap->arg is 1 for \"B\"\n */\n    static void\nnv_bck_word(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    curwin->w_set_curswant = TRUE;\n    if (bck_word(cap->count1, cap->arg, FALSE) == FAIL)\n\tclearopbeep(cap->oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle word motion commands \"e\", \"E\", \"w\" and \"W\".\n * cap->arg is TRUE for \"E\" and \"W\".\n */\n    static void\nnv_wordcmd(cmdarg_T *cap)\n{\n    int\t\tn;\n    int\t\tword_end;\n    int\t\tflag = FALSE;\n    pos_T\tstartpos = curwin->w_cursor;\n\n    /*\n     * Set inclusive for the \"E\" and \"e\" command.\n     */\n    if (cap->cmdchar == 'e' || cap->cmdchar == 'E')\n\tword_end = TRUE;\n    else\n\tword_end = FALSE;\n    cap->oap->inclusive = word_end;\n\n    /*\n     * \"cw\" and \"cW\" are a special case.\n     */\n    if (!word_end && cap->oap->op_type == OP_CHANGE)\n    {\n\tn = gchar_cursor();\n\tif (n != NUL)\t\t\t// not an empty line\n\t{\n\t    if (VIM_ISWHITE(n))\n\t    {\n\t\t/*\n\t\t * Reproduce a funny Vi behaviour: \"cw\" on a blank only\n\t\t * changes one character, not all blanks until the start of\n\t\t * the next word.  Only do this when the 'w' flag is included\n\t\t * in 'cpoptions'.\n\t\t */\n\t\tif (cap->count1 == 1 && vim_strchr(p_cpo, CPO_CW) != NULL)\n\t\t{\n\t\t    cap->oap->inclusive = TRUE;\n\t\t    cap->oap->motion_type = MCHAR;\n\t\t    return;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t/*\n\t\t * This is a little strange. To match what the real Vi does,\n\t\t * we effectively map 'cw' to 'ce', and 'cW' to 'cE', provided\n\t\t * that we are not on a space or a TAB.  This seems impolite\n\t\t * at first, but it's really more what we mean when we say\n\t\t * 'cw'.\n\t\t * Another strangeness: When standing on the end of a word\n\t\t * \"ce\" will change until the end of the next word, but \"cw\"\n\t\t * will change only one character! This is done by setting\n\t\t * flag.\n\t\t */\n\t\tcap->oap->inclusive = TRUE;\n\t\tword_end = TRUE;\n\t\tflag = TRUE;\n\t    }\n\t}\n    }\n\n    cap->oap->motion_type = MCHAR;\n    curwin->w_set_curswant = TRUE;\n    if (word_end)\n\tn = end_word(cap->count1, cap->arg, flag, FALSE);\n    else\n\tn = fwd_word(cap->count1, cap->arg, cap->oap->op_type != OP_NOP);\n\n    // Don't leave the cursor on the NUL past the end of line. Unless we\n    // didn't move it forward.\n    if (LT_POS(startpos, curwin->w_cursor))\n\tadjust_cursor(cap->oap);\n\n    if (n == FAIL && cap->oap->op_type == OP_NOP)\n\tclearopbeep(cap->oap);\n    else\n    {\n\tadjust_for_sel(cap);\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * Used after a movement command: If the cursor ends up on the NUL after the\n * end of the line, may move it back to the last character and make the motion\n * inclusive.\n */\n    static void\nadjust_cursor(oparg_T *oap)\n{\n    // The cursor cannot remain on the NUL when:\n    // - the column is > 0\n    // - not in Visual mode or 'selection' is \"o\"\n    // - 'virtualedit' is not \"all\" and not \"onemore\".\n    if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL\n\t\t&& (!VIsual_active || *p_sel == 'o')\n\t\t&& !virtual_active() && (get_ve_flags() & VE_ONEMORE) == 0)\n    {\n\t--curwin->w_cursor.col;\n\t// prevent cursor from moving on the trail byte\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\toap->inclusive = TRUE;\n    }\n}\n\n/*\n * \"0\" and \"^\" commands.\n * cap->arg is the argument for beginline().\n */\n    static void\nnv_beginline(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    beginline(cap->arg);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n    ins_at_eol = FALSE;\t    // Don't move cursor past eol (only necessary in a\n\t\t\t    // one-character line).\n}\n\n/*\n * In exclusive Visual mode, may include the last character.\n */\n    static void\nadjust_for_sel(cmdarg_T *cap)\n{\n    if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'\n\t    && gchar_cursor() != NUL && LT_POS(VIsual, curwin->w_cursor))\n    {\n\tif (has_mbyte)\n\t    inc_cursor();\n\telse\n\t    ++curwin->w_cursor.col;\n\tcap->oap->inclusive = FALSE;\n    }\n}\n\n/*\n * Exclude last character at end of Visual area for 'selection' == \"exclusive\".\n * Should check VIsual_mode before calling this.\n * Returns TRUE when backed up to the previous line.\n */\n    int\nunadjust_for_sel(void)\n{\n    pos_T\t*pp;\n\n    if (*p_sel == 'e' && !EQUAL_POS(VIsual, curwin->w_cursor))\n    {\n\tif (LT_POS(VIsual, curwin->w_cursor))\n\t    pp = &curwin->w_cursor;\n\telse\n\t    pp = &VIsual;\n\tif (pp->coladd > 0)\n\t    --pp->coladd;\n\telse\n\tif (pp->col > 0)\n\t{\n\t    --pp->col;\n\t    mb_adjustpos(curbuf, pp);\n\t}\n\telse if (pp->lnum > 1)\n\t{\n\t    --pp->lnum;\n\t    pp->col = (colnr_T)STRLEN(ml_get(pp->lnum));\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * SELECT key in Normal or Visual mode: end of Select mode mapping.\n */\n    static void\nnv_select(cmdarg_T *cap)\n{\n    if (VIsual_active)\n\tVIsual_select = TRUE;\n    else if (VIsual_reselect)\n    {\n\tcap->nchar = 'v';\t    // fake \"gv\" command\n\tcap->arg = TRUE;\n\tnv_g_cmd(cap);\n    }\n}\n\n\n/*\n * \"G\", \"gg\", CTRL-END, CTRL-HOME.\n * cap->arg is TRUE for \"G\".\n */\n    static void\nnv_goto(cmdarg_T *cap)\n{\n    linenr_T\tlnum;\n\n    if (cap->arg)\n\tlnum = curbuf->b_ml.ml_line_count;\n    else\n\tlnum = 1L;\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    // When a count is given, use it instead of the default lnum\n    if (cap->count0 != 0)\n\tlnum = cap->count0;\n    if (lnum < 1L)\n\tlnum = 1L;\n    else if (lnum > curbuf->b_ml.ml_line_count)\n\tlnum = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor.lnum = lnum;\n    beginline(BL_SOL | BL_FIX);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_JUMP) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * CTRL-\\ in Normal mode.\n */\n    static void\nnv_normal(cmdarg_T *cap)\n{\n    if (cap->nchar == Ctrl_N || cap->nchar == Ctrl_G)\n    {\n\tclearop(cap->oap);\n\tif (restart_edit != 0 && mode_displayed)\n\t    clear_cmdline = TRUE;\t\t// unshow mode later\n\trestart_edit = 0;\n#ifdef FEAT_CMDWIN\n\tif (cmdwin_type != 0)\n\t    cmdwin_result = Ctrl_C;\n#endif\n\tif (VIsual_active)\n\t{\n\t    end_visual_mode();\t\t// stop Visual\n\t    redraw_curbuf_later(INVERTED);\n\t}\n\t// CTRL-\\ CTRL-G restarts Insert mode when 'insertmode' is set.\n\tif (cap->nchar == Ctrl_G && p_im)\n\t    restart_edit = 'a';\n    }\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * ESC in Normal mode: beep, but don't flush buffers.\n * Don't even beep if we are canceling a command.\n */\n    static void\nnv_esc(cmdarg_T *cap)\n{\n    int\t\tno_reason;\n\n    no_reason = (cap->oap->op_type == OP_NOP\n\t\t&& cap->opcount == 0\n\t\t&& cap->count0 == 0\n\t\t&& cap->oap->regname == 0\n\t\t&& !p_im);\n\n    if (cap->arg)\t\t// TRUE for CTRL-C\n    {\n\tif (restart_edit == 0\n#ifdef FEAT_CMDWIN\n\t\t&& cmdwin_type == 0\n#endif\n\t\t&& !VIsual_active\n\t\t&& no_reason)\n\t{\n\t    if (anyBufIsChanged())\n\t\tmsg(_(\"Type  :qa!  and press <Enter> to abandon all changes and exit Vim\"));\n\t    else\n\t\tmsg(_(\"Type  :qa  and press <Enter> to exit Vim\"));\n\t}\n\n\t// Don't reset \"restart_edit\" when 'insertmode' is set, it won't be\n\t// set again below when halfway a mapping.\n\tif (!p_im)\n\t    restart_edit = 0;\n#ifdef FEAT_CMDWIN\n\tif (cmdwin_type != 0)\n\t{\n\t    cmdwin_result = K_IGNORE;\n\t    got_int = FALSE;\t// don't stop executing autocommands et al.\n\t    return;\n\t}\n#endif\n    }\n#ifdef FEAT_CMDWIN\n    else if (cmdwin_type != 0 && ex_normal_busy)\n    {\n\t// When :normal runs out of characters while in the command line window\n\t// vgetorpeek() will return ESC.  Exit the cmdline window to break the\n\t// loop.\n\tcmdwin_result = K_IGNORE;\n\treturn;\n    }\n#endif\n\n    if (VIsual_active)\n    {\n\tend_visual_mode();\t// stop Visual\n\tcheck_cursor_col();\t// make sure cursor is not beyond EOL\n\tcurwin->w_set_curswant = TRUE;\n\tredraw_curbuf_later(INVERTED);\n    }\n    else if (no_reason)\n\tvim_beep(BO_ESC);\n    clearop(cap->oap);\n\n    // A CTRL-C is often used at the start of a menu.  When 'insertmode' is\n    // set return to Insert mode afterwards.\n    if (restart_edit == 0 && goto_im() && ex_normal_busy == 0)\n\trestart_edit = 'a';\n}\n\n/*\n * Move the cursor for the \"A\" command.\n */\n    void\nset_cursor_for_append_to_line(void)\n{\n    curwin->w_set_curswant = TRUE;\n    if (get_ve_flags() == VE_ALL)\n    {\n\tint save_State = State;\n\n\t// Pretend Insert mode here to allow the cursor on the\n\t// character past the end of the line\n\tState = INSERT;\n\tcoladvance((colnr_T)MAXCOL);\n\tState = save_State;\n    }\n    else\n\tcurwin->w_cursor.col += (colnr_T)STRLEN(ml_get_cursor());\n}\n\n/*\n * Handle \"A\", \"a\", \"I\", \"i\" and <Insert> commands.\n * Also handle K_PS, start bracketed paste.\n */\n    static void\nnv_edit(cmdarg_T *cap)\n{\n    // <Insert> is equal to \"i\"\n    if (cap->cmdchar == K_INS || cap->cmdchar == K_KINS)\n\tcap->cmdchar = 'i';\n\n    // in Visual mode \"A\" and \"I\" are an operator\n    if (VIsual_active && (cap->cmdchar == 'A' || cap->cmdchar == 'I'))\n    {\n#ifdef FEAT_TERMINAL\n\tif (term_in_normal_mode())\n\t{\n\t    end_visual_mode();\n\t    clearop(cap->oap);\n\t    term_enter_job_mode();\n\t    return;\n\t}\n#endif\n\tv_visop(cap);\n    }\n\n    // in Visual mode and after an operator \"a\" and \"i\" are for text objects\n    else if ((cap->cmdchar == 'a' || cap->cmdchar == 'i')\n\t    && (cap->oap->op_type != OP_NOP || VIsual_active))\n    {\n#ifdef FEAT_TEXTOBJ\n\tnv_object(cap);\n#else\n\tclearopbeep(cap->oap);\n#endif\n    }\n#ifdef FEAT_TERMINAL\n    else if (term_in_normal_mode())\n    {\n\tclearop(cap->oap);\n\tterm_enter_job_mode();\n\treturn;\n    }\n#endif\n    else if (!curbuf->b_p_ma && !p_im)\n    {\n\t// Only give this error when 'insertmode' is off.\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\tclearop(cap->oap);\n\tif (cap->cmdchar == K_PS)\n\t    // drop the pasted text\n\t    bracketed_paste(PASTE_INSERT, TRUE, NULL);\n    }\n    else if (cap->cmdchar == K_PS && VIsual_active)\n    {\n\tpos_T old_pos = curwin->w_cursor;\n\tpos_T old_visual = VIsual;\n\n\t// In Visual mode the selected text is deleted.\n\tif (VIsual_mode == 'V' || curwin->w_cursor.lnum != VIsual.lnum)\n\t{\n\t    shift_delete_registers();\n\t    cap->oap->regname = '1';\n\t}\n\telse\n\t    cap->oap->regname = '-';\n\tcap->cmdchar = 'd';\n\tcap->nchar = NUL;\n\tnv_operator(cap);\n\tdo_pending_operator(cap, 0, FALSE);\n\tcap->cmdchar = K_PS;\n\n\t// When the last char in the line was deleted then append. Detect this\n\t// by checking if the cursor moved to before the Visual area.\n\tif (*ml_get_cursor() != NUL && LT_POS(curwin->w_cursor, old_pos)\n\t\t\t\t       && LT_POS(curwin->w_cursor, old_visual))\n\t    inc_cursor();\n\n\t// Insert to replace the deleted text with the pasted text.\n\tinvoke_edit(cap, FALSE, cap->cmdchar, FALSE);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tswitch (cap->cmdchar)\n\t{\n\t    case 'A':\t// \"A\"ppend after the line\n\t\tset_cursor_for_append_to_line();\n\t\tbreak;\n\n\t    case 'I':\t// \"I\"nsert before the first non-blank\n\t\tif (vim_strchr(p_cpo, CPO_INSEND) == NULL)\n\t\t    beginline(BL_WHITE);\n\t\telse\n\t\t    beginline(BL_WHITE|BL_FIX);\n\t\tbreak;\n\n\t    case K_PS:\n\t\t// Bracketed paste works like \"a\"ppend, unless the cursor is in\n\t\t// the first column, then it inserts.\n\t\tif (curwin->w_cursor.col == 0)\n\t\t    break;\n\t\t// FALLTHROUGH\n\n\t    case 'a':\t// \"a\"ppend is like \"i\"nsert on the next character.\n\t\t// increment coladd when in virtual space, increment the\n\t\t// column otherwise, also to append after an unprintable char\n\t\tif (virtual_active()\n\t\t\t&& (curwin->w_cursor.coladd > 0\n\t\t\t    || *ml_get_cursor() == NUL\n\t\t\t    || *ml_get_cursor() == TAB))\n\t\t    curwin->w_cursor.coladd++;\n\t\telse if (*ml_get_cursor() != NUL)\n\t\t    inc_cursor();\n\t\tbreak;\n\t}\n\n\tif (curwin->w_cursor.coladd && cap->cmdchar != 'A')\n\t{\n\t    int save_State = State;\n\n\t    // Pretend Insert mode here to allow the cursor on the\n\t    // character past the end of the line\n\t    State = INSERT;\n\t    coladvance(getviscol());\n\t    State = save_State;\n\t}\n\n\tinvoke_edit(cap, FALSE, cap->cmdchar, FALSE);\n    }\n    else if (cap->cmdchar == K_PS)\n\t// drop the pasted text\n\tbracketed_paste(PASTE_INSERT, TRUE, NULL);\n}\n\n/*\n * Invoke edit() and take care of \"restart_edit\" and the return value.\n */\n    static void\ninvoke_edit(\n    cmdarg_T\t*cap,\n    int\t\trepl,\t\t// \"r\" or \"gr\" command\n    int\t\tcmd,\n    int\t\tstartln)\n{\n    int\t\trestart_edit_save = 0;\n\n    // Complicated: When the user types \"a<C-O>a\" we don't want to do Insert\n    // mode recursively.  But when doing \"a<C-O>.\" or \"a<C-O>rx\" we do allow\n    // it.\n    if (repl || !stuff_empty())\n\trestart_edit_save = restart_edit;\n    else\n\trestart_edit_save = 0;\n\n    // Always reset \"restart_edit\", this is not a restarted edit.\n    restart_edit = 0;\n\n    if (edit(cmd, startln, cap->count1))\n\tcap->retval |= CA_COMMAND_BUSY;\n\n    if (restart_edit == 0)\n\trestart_edit = restart_edit_save;\n}\n\n#ifdef FEAT_TEXTOBJ\n/*\n * \"a\" or \"i\" while an operator is pending or in Visual mode: object motion.\n */\n    static void\nnv_object(\n    cmdarg_T\t*cap)\n{\n    int\t\tflag;\n    int\t\tinclude;\n    char_u\t*mps_save;\n\n    if (cap->cmdchar == 'i')\n\tinclude = FALSE;    // \"ix\" = inner object: exclude white space\n    else\n\tinclude = TRUE;\t    // \"ax\" = an object: include white space\n\n    // Make sure (), [], {} and <> are in 'matchpairs'\n    mps_save = curbuf->b_p_mps;\n    curbuf->b_p_mps = (char_u *)\"(:),{:},[:],<:>\";\n\n    switch (cap->nchar)\n    {\n\tcase 'w': // \"aw\" = a word\n\t\tflag = current_word(cap->oap, cap->count1, include, FALSE);\n\t\tbreak;\n\tcase 'W': // \"aW\" = a WORD\n\t\tflag = current_word(cap->oap, cap->count1, include, TRUE);\n\t\tbreak;\n\tcase 'b': // \"ab\" = a braces block\n\tcase '(':\n\tcase ')':\n\t\tflag = current_block(cap->oap, cap->count1, include, '(', ')');\n\t\tbreak;\n\tcase 'B': // \"aB\" = a Brackets block\n\tcase '{':\n\tcase '}':\n\t\tflag = current_block(cap->oap, cap->count1, include, '{', '}');\n\t\tbreak;\n\tcase '[': // \"a[\" = a [] block\n\tcase ']':\n\t\tflag = current_block(cap->oap, cap->count1, include, '[', ']');\n\t\tbreak;\n\tcase '<': // \"a<\" = a <> block\n\tcase '>':\n\t\tflag = current_block(cap->oap, cap->count1, include, '<', '>');\n\t\tbreak;\n\tcase 't': // \"at\" = a tag block (xml and html)\n\t\t// Do not adjust oap->end in do_pending_operator()\n\t\t// otherwise there are different results for 'dit'\n\t\t// (note leading whitespace in last line):\n\t\t// 1) <b>      2) <b>\n\t\t//    foobar      foobar\n\t\t//    </b>            </b>\n\t\tcap->retval |= CA_NO_ADJ_OP_END;\n\t\tflag = current_tagblock(cap->oap, cap->count1, include);\n\t\tbreak;\n\tcase 'p': // \"ap\" = a paragraph\n\t\tflag = current_par(cap->oap, cap->count1, include, 'p');\n\t\tbreak;\n\tcase 's': // \"as\" = a sentence\n\t\tflag = current_sent(cap->oap, cap->count1, include);\n\t\tbreak;\n\tcase '\"': // \"a\"\" = a double quoted string\n\tcase '\\'': // \"a'\" = a single quoted string\n\tcase '`': // \"a`\" = a backtick quoted string\n\t\tflag = current_quote(cap->oap, cap->count1, include,\n\t\t\t\t\t\t\t\t  cap->nchar);\n\t\tbreak;\n#if 0\t// TODO\n\tcase 'S': // \"aS\" = a section\n\tcase 'f': // \"af\" = a filename\n\tcase 'u': // \"au\" = a URL\n#endif\n\tdefault:\n\t\tflag = FAIL;\n\t\tbreak;\n    }\n\n    curbuf->b_p_mps = mps_save;\n    if (flag == FAIL)\n\tclearopbeep(cap->oap);\n    adjust_cursor_col();\n    curwin->w_set_curswant = TRUE;\n}\n#endif\n\n/*\n * \"q\" command: Start/stop recording.\n * \"q:\", \"q/\", \"q?\": edit command-line in command-line window.\n */\n    static void\nnv_record(cmdarg_T *cap)\n{\n    if (cap->oap->op_type == OP_FORMAT)\n    {\n\t// \"gqq\" is the same as \"gqgq\": format line\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'q';\n\tnv_operator(cap);\n    }\n    else if (!checkclearop(cap->oap))\n    {\n#ifdef FEAT_CMDWIN\n\tif (cap->nchar == ':' || cap->nchar == '/' || cap->nchar == '?')\n\t{\n\t    stuffcharReadbuff(cap->nchar);\n\t    stuffcharReadbuff(K_CMDWIN);\n\t}\n\telse\n#endif\n\t    // (stop) recording into a named register, unless executing a\n\t    // register\n\t    if (reg_executing == 0 && do_record(cap->nchar) == FAIL)\n\t\tclearopbeep(cap->oap);\n    }\n}\n\n/*\n * Handle the \"@r\" command.\n */\n    static void\nnv_at(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_EVAL\n    if (cap->nchar == '=')\n    {\n\tif (get_expr_register() == NUL)\n\t    return;\n    }\n#endif\n    while (cap->count1-- && !got_int)\n    {\n\tif (do_execreg(cap->nchar, FALSE, FALSE, FALSE) == FAIL)\n\t{\n\t    clearopbeep(cap->oap);\n\t    break;\n\t}\n\tline_breakcheck();\n    }\n}\n\n/*\n * Handle the CTRL-U and CTRL-D commands.\n */\n    static void\nnv_halfpage(cmdarg_T *cap)\n{\n    if ((cap->cmdchar == Ctrl_U && curwin->w_cursor.lnum == 1)\n\t    || (cap->cmdchar == Ctrl_D\n\t\t&& curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count))\n\tclearopbeep(cap->oap);\n    else if (!checkclearop(cap->oap))\n\thalfpage(cap->cmdchar == Ctrl_D, cap->count0);\n}\n\n/*\n * Handle \"J\" or \"gJ\" command.\n */\n    static void\nnv_join(cmdarg_T *cap)\n{\n    if (VIsual_active)\t// join the visual lines\n\tnv_operator(cap);\n    else if (!checkclearop(cap->oap))\n    {\n\tif (cap->count0 <= 1)\n\t    cap->count0 = 2;\t    // default for join is two lines!\n\tif (curwin->w_cursor.lnum + cap->count0 - 1 >\n\t\t\t\t\t\t   curbuf->b_ml.ml_line_count)\n\t{\n\t    // can't join when on the last line\n\t    if (cap->count0 <= 2)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\treturn;\n\t    }\n\t    cap->count0 = curbuf->b_ml.ml_line_count\n\t\t\t\t\t\t  - curwin->w_cursor.lnum + 1;\n\t}\n\n\tprep_redo(cap->oap->regname, cap->count0,\n\t\t\t\t     NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n\t(void)do_join(cap->count0, cap->nchar == NUL, TRUE, TRUE, TRUE);\n    }\n}\n\n/*\n * \"P\", \"gP\", \"p\" and \"gp\" commands.\n */\n    static void\nnv_put(cmdarg_T *cap)\n{\n    nv_put_opt(cap, FALSE);\n}\n\n/*\n * \"P\", \"gP\", \"p\" and \"gp\" commands.\n * \"fix_indent\" is TRUE for \"[p\", \"[P\", \"]p\" and \"]P\".\n */\n    static void\nnv_put_opt(cmdarg_T *cap, int fix_indent)\n{\n    int\t\tregname = 0;\n    void\t*reg1 = NULL, *reg2 = NULL;\n    int\t\tempty = FALSE;\n    int\t\twas_visual = FALSE;\n    int\t\tdir;\n    int\t\tflags = 0;\n\n    if (cap->oap->op_type != OP_NOP)\n    {\n#ifdef FEAT_DIFF\n\t// \"dp\" is \":diffput\"\n\tif (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'p')\n\t{\n\t    clearop(cap->oap);\n\t    nv_diffgetput(TRUE, cap->opcount);\n\t}\n\telse\n#endif\n\tclearopbeep(cap->oap);\n    }\n#ifdef FEAT_JOB_CHANNEL\n    else if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n    }\n#endif\n    else\n    {\n\tif (fix_indent)\n\t{\n\t    dir = (cap->cmdchar == ']' && cap->nchar == 'p')\n\t\t\t\t\t\t\t ? FORWARD : BACKWARD;\n\t    flags |= PUT_FIXINDENT;\n\t}\n\telse\n\t    dir = (cap->cmdchar == 'P'\n\t\t    || ((cap->cmdchar == 'g' || cap->cmdchar == 'z')\n\t\t\t&& cap->nchar == 'P')) ? BACKWARD : FORWARD;\n\tprep_redo_cmd(cap);\n\tif (cap->cmdchar == 'g')\n\t    flags |= PUT_CURSEND;\n\telse if (cap->cmdchar == 'z')\n\t    flags |= PUT_BLOCK_INNER;\n\n\tif (VIsual_active)\n\t{\n\t    // Putting in Visual mode: The put text replaces the selected\n\t    // text.  First delete the selected text, then put the new text.\n\t    // Need to save and restore the registers that the delete\n\t    // overwrites if the old contents is being put.\n\t    was_visual = TRUE;\n\t    regname = cap->oap->regname;\n#ifdef FEAT_CLIPBOARD\n\t    adjust_clip_reg(&regname);\n#endif\n\t   if (regname == 0 || regname == '\"'\n\t\t\t\t     || VIM_ISDIGIT(regname) || regname == '-'\n#ifdef FEAT_CLIPBOARD\n\t\t    || (clip_unnamed && (regname == '*' || regname == '+'))\n#endif\n\n\t\t    )\n\t    {\n\t\t// The delete is going to overwrite the register we want to\n\t\t// put, save it first.\n\t\treg1 = get_register(regname, TRUE);\n\t    }\n\n\t    // Now delete the selected text. Avoid messages here.\n\t    cap->cmdchar = 'd';\n\t    cap->nchar = NUL;\n\t    cap->oap->regname = NUL;\n\t    ++msg_silent;\n\t    nv_operator(cap);\n\t    do_pending_operator(cap, 0, FALSE);\n\t    empty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n\t    --msg_silent;\n\n\t    // delete PUT_LINE_BACKWARD;\n\t    cap->oap->regname = regname;\n\n\t    if (reg1 != NULL)\n\t    {\n\t\t// Delete probably changed the register we want to put, save\n\t\t// it first. Then put back what was there before the delete.\n\t\treg2 = get_register(regname, FALSE);\n\t\tput_register(regname, reg1);\n\t    }\n\n\t    // When deleted a linewise Visual area, put the register as\n\t    // lines to avoid it joined with the next line.  When deletion was\n\t    // characterwise, split a line when putting lines.\n\t    if (VIsual_mode == 'V')\n\t\tflags |= PUT_LINE;\n\t    else if (VIsual_mode == 'v')\n\t\tflags |= PUT_LINE_SPLIT;\n\t    if (VIsual_mode == Ctrl_V && dir == FORWARD)\n\t\tflags |= PUT_LINE_FORWARD;\n\t    dir = BACKWARD;\n\t    if ((VIsual_mode != 'V'\n\t\t\t&& curwin->w_cursor.col < curbuf->b_op_start.col)\n\t\t    || (VIsual_mode == 'V'\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_op_start.lnum))\n\t\t// cursor is at the end of the line or end of file, put\n\t\t// forward.\n\t\tdir = FORWARD;\n\t    // May have been reset in do_put().\n\t    VIsual_active = TRUE;\n\t}\n\tdo_put(cap->oap->regname, NULL, dir, cap->count1, flags);\n\n\t// If a register was saved, put it back now.\n\tif (reg2 != NULL)\n\t    put_register(regname, reg2);\n\n\t// What to reselect with \"gv\"?  Selecting the just put text seems to\n\t// be the most useful, since the original text was removed.\n\tif (was_visual)\n\t{\n\t    curbuf->b_visual.vi_start = curbuf->b_op_start;\n\t    curbuf->b_visual.vi_end = curbuf->b_op_end;\n\t    // need to adjust cursor position\n\t    if (*p_sel == 'e')\n\t\tinc(&curbuf->b_visual.vi_end);\n\t}\n\n\t// When all lines were selected and deleted do_put() leaves an empty\n\t// line that needs to be deleted now.\n\tif (empty && *ml_get(curbuf->b_ml.ml_line_count) == NUL)\n\t{\n\t    ml_delete_flags(curbuf->b_ml.ml_line_count, ML_DEL_MESSAGE);\n\t    deleted_lines(curbuf->b_ml.ml_line_count + 1, 1);\n\n\t    // If the cursor was in that line, move it to the end of the last\n\t    // line.\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\tcoladvance((colnr_T)MAXCOL);\n\t    }\n\t}\n\tauto_format(FALSE, TRUE);\n    }\n}\n\n/*\n * \"o\" and \"O\" commands.\n */\n    static void\nnv_open(cmdarg_T *cap)\n{\n#ifdef FEAT_DIFF\n    // \"do\" is \":diffget\"\n    if (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'o')\n    {\n\tclearop(cap->oap);\n\tnv_diffgetput(FALSE, cap->opcount);\n    }\n    else\n#endif\n    if (VIsual_active)  // switch start and end of visual\n\tv_swap_corners(cap->cmdchar);\n#ifdef FEAT_JOB_CHANNEL\n    else if (bt_prompt(curbuf))\n\tclearopbeep(cap->oap);\n#endif\n    else\n\tn_opencmd(cap);\n}\n\n#ifdef FEAT_NETBEANS_INTG\n    static void\nnv_nbcmd(cmdarg_T *cap)\n{\n    netbeans_keycommand(cap->nchar);\n}\n#endif\n\n#ifdef FEAT_DND\n    static void\nnv_drop(cmdarg_T *cap UNUSED)\n{\n    do_put('~', NULL, BACKWARD, 1L, PUT_CURSEND);\n}\n#endif\n\n/*\n * Trigger CursorHold event.\n * When waiting for a character for 'updatetime' K_CURSORHOLD is put in the\n * input buffer.  \"did_cursorhold\" is set to avoid retriggering.\n */\n    static void\nnv_cursorhold(cmdarg_T *cap)\n{\n    apply_autocmds(EVENT_CURSORHOLD, NULL, NULL, FALSE, curbuf);\n    did_cursorhold = TRUE;\n    cap->retval |= CA_COMMAND_BUSY;\t// don't call edit() now\n}\n", "\" Test for edit functions\n\nif exists(\"+t_kD\")\n  let &t_kD=\"\u001b[3;*~\"\nendif\n\nsource check.vim\n\n\" Needed for testing basic rightleft: Test_edit_rightleft\nsource view_util.vim\n\n\" Needs to come first until the bug in getchar() is\n\" fixed: https://groups.google.com/d/msg/vim_dev/fXL9yme4H4c/bOR-U6_bAQAJ\nfunc Test_edit_00b()\n  new\n  call setline(1, ['abc '])\n  inoreabbr <buffer> h here some more\n  call cursor(1, 4)\n  \" <c-l> expands the abbreviation and ends insertmode\n  call feedkeys(\":set im\\<cr> h\\<c-l>:set noim\\<cr>\", 'tix')\n  call assert_equal(['abc here some more '], getline(1,'$'))\n  iunabbr <buffer> h\n  bw!\nendfunc\n\nfunc Test_edit_01()\n  \" set for Travis CI?\n  \"  set nocp noesckeys\n  new\n  \" 1) empty buffer\n  call assert_equal([''], getline(1,'$'))\n  \" 2) delete in an empty line\n  call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n  call assert_equal([''], getline(1,'$'))\n  %d\n  \" 3) delete one character\n  call setline(1, 'a')\n  call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n  call assert_equal([''], getline(1,'$'))\n  %d\n  \" 4) delete a multibyte character\n  call setline(1, \"\\u0401\")\n  call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n  call assert_equal([''], getline(1,'$'))\n  %d\n  \" 5.1) delete linebreak with 'bs' option containing eol\n  let _bs=&bs\n  set bs=eol\n  call setline(1, [\"abc def\", \"ghi jkl\"])\n  call cursor(1, 1)\n  call feedkeys(\"A\\<del>\\<esc>\", 'tnix')\n  call assert_equal(['abc defghi jkl'], getline(1, 2))\n  %d\n  \" 5.2) delete linebreak with backspace option w/out eol\n  set bs=\n  call setline(1, [\"abc def\", \"ghi jkl\"])\n  call cursor(1, 1)\n  call feedkeys(\"A\\<del>\\<esc>\", 'tnix')\n  call assert_equal([\"abc def\", \"ghi jkl\"], getline(1, 2))\n  let &bs=_bs\n  bw!\nendfunc\n\nfunc Test_edit_02()\n  \" Change cursor position in InsertCharPre command\n  new\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  fu! DoIt(...)\n    call cursor(1, 4)\n    if len(a:000)\n      let v:char=a:1\n    endif\n  endfu\n  au InsertCharPre <buffer> :call DoIt('y')\n  call feedkeys(\"ix\\<esc>\", 'tnix')\n  call assert_equal(['abcy'], getline(1, '$'))\n  \" Setting <Enter> in InsertCharPre\n  au! InsertCharPre <buffer> :call DoIt(\"\\n\")\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"ix\\<esc>\", 'tnix')\n  call assert_equal(['abc', ''], getline(1, '$'))\n  %d\n  au! InsertCharPre\n  \" Change cursor position in InsertEnter command\n  \" 1) when setting v:char, keeps changed cursor position\n  au! InsertEnter <buffer> :call DoIt('y')\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"ix\\<esc>\", 'tnix')\n  call assert_equal(['abxc'], getline(1, '$'))\n  \" 2) when not setting v:char, restores changed cursor position\n  au! InsertEnter <buffer> :call DoIt()\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"ix\\<esc>\", 'tnix')\n  call assert_equal(['xabc'], getline(1, '$'))\n  au! InsertEnter\n  delfu DoIt\n  bw!\nendfunc\n\nfunc Test_edit_03()\n  \" Change cursor after <c-o> command to end of line\n  new\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-o>$y\\<esc>\", 'tnix')\n  call assert_equal(['abcy'], getline(1, '$'))\n  %d\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-o>80|y\\<esc>\", 'tnix')\n  call assert_equal(['abcy'], getline(1, '$'))\n  %d\n  call setline(1, 'abc')\n  call feedkeys(\"Ad\\<c-o>:s/$/efg/\\<cr>hij\", 'tnix')\n  call assert_equal(['hijabcdefg'], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_edit_04()\n  \" test for :stopinsert\n  new\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-o>:stopinsert\\<cr>$\", 'tnix')\n  call feedkeys(\"aX\\<esc>\", 'tnix')\n  call assert_equal(['abcX'], getline(1, '$'))\n  %d\n  bw!\nendfunc\n\nfunc Test_edit_05()\n  \" test for folds being opened\n  new\n  call setline(1, ['abcX', 'abcX', 'zzzZ'])\n  call cursor(1, 1)\n  set foldmethod=manual foldopen+=insert\n  \" create fold for those two lines\n  norm! Vjzf\n  call feedkeys(\"$ay\\<esc>\", 'tnix')\n  call assert_equal(['abcXy', 'abcX', 'zzzZ'], getline(1, '$'))\n  %d\n  call setline(1, ['abcX', 'abcX', 'zzzZ'])\n  call cursor(1, 1)\n  set foldmethod=manual foldopen-=insert\n  \" create fold for those two lines\n  norm! Vjzf\n  call feedkeys(\"$ay\\<esc>\", 'tnix')\n  call assert_equal(['abcXy', 'abcX', 'zzzZ'], getline(1, '$'))\n  %d\n  bw!\nendfunc\n\nfunc Test_edit_06()\n  \" Test in diff mode\n  CheckFeature diff\n  CheckExecutable diff\n  new\n  call setline(1, ['abc', 'xxx', 'yyy'])\n  vnew\n  call setline(1, ['abc', 'zzz', 'xxx', 'yyy'])\n  wincmd p\n  diffthis\n  wincmd p\n  diffthis\n  wincmd p\n  call cursor(2, 1)\n  norm! zt\n  call feedkeys(\"Ozzz\\<esc>\", 'tnix')\n  call assert_equal(['abc', 'zzz', 'xxx', 'yyy'], getline(1,'$'))\n  bw!\n  bw!\nendfunc\n\nfunc Test_edit_07()\n  \" 1) Test with completion <c-l> when popupmenu is visible\n  new\n  call setline(1, 'J')\n\n  func! ListMonths()\n    call complete(col('.')-1, ['January', 'February', 'March',\n    \\ 'April', 'May', 'June', 'July', 'August', 'September',\n    \\ 'October', 'November', 'December'])\n    return ''\n  endfunc\n  inoremap <buffer> <F5> <C-R>=ListMonths()<CR>\n\n  call feedkeys(\"A\\<f5>\\<c-p>\". repeat(\"\\<down>\", 6).\"\\<c-l>\\<down>\\<c-l>\\<cr>\", 'tx')\n  call assert_equal(['July'], getline(1,'$'))\n  \" 1) Test completion when InsertCharPre kicks in\n  %d\n  call setline(1, 'J')\n  fu! DoIt()\n    if v:char=='u'\n      let v:char='an'\n    endif\n  endfu\n  au InsertCharPre <buffer> :call DoIt()\n  call feedkeys(\"A\\<f5>\\<c-p>u\\<cr>\\<c-l>\\<cr>\", 'tx')\n  call assert_equal([\"Jan\\<c-l>\",''], 1->getline('$'))\n  %d\n  call setline(1, 'J')\n  call feedkeys(\"A\\<f5>\\<c-p>u\\<down>\\<c-l>\\<cr>\", 'tx')\n  call assert_equal([\"January\"], 1->getline('$'))\n\n  delfu ListMonths\n  delfu DoIt\n  iunmap <buffer> <f5>\n  bw!\nendfunc\n\nfunc Test_edit_08()\n  \" reset insertmode from i_ctrl-r_=\n  let g:bufnr = bufnr('%')\n  new\n  call setline(1, ['abc'])\n  call cursor(1, 4)\n  call feedkeys(\":set im\\<cr>ZZZ\\<c-r>=setbufvar(g:bufnr,'&im', 0)\\<cr>\",'tnix')\n  call assert_equal(['abZZZc'], getline(1,'$'))\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call assert_false(0, '&im')\n  bw!\n  unlet g:bufnr\nendfunc\n\nfunc Test_edit_09()\n  \" test i_CTRL-\\ combinations\n  new\n  call setline(1, ['abc', 'def', 'ghi'])\n  call cursor(1, 1)\n  \" 1) CTRL-\\ CTLR-N\n  call feedkeys(\":set im\\<cr>\\<c-\\>\\<c-n>ccABC\\<c-l>\", 'txin')\n  call assert_equal(['ABC', 'def', 'ghi'], getline(1,'$'))\n  call setline(1, ['ABC', 'def', 'ghi'])\n  \" 2) CTRL-\\ CTLR-G\n  call feedkeys(\"j0\\<c-\\>\\<c-g>ZZZ\\<cr>\\<c-l>\", 'txin')\n  call assert_equal(['ABC', 'ZZZ', 'def', 'ghi'], getline(1,'$'))\n  call feedkeys(\"I\\<c-\\>\\<c-g>YYY\\<c-l>\", 'txin')\n  call assert_equal(['ABC', 'ZZZ', 'YYYdef', 'ghi'], getline(1,'$'))\n  set noinsertmode\n  \" 3) CTRL-\\ CTRL-O\n  call setline(1, ['ABC', 'ZZZ', 'def', 'ghi'])\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-o>ix\", 'txin')\n  call assert_equal(['ABxC', 'ZZZ', 'def', 'ghi'], getline(1,'$'))\n  call feedkeys(\"A\\<c-\\>\\<c-o>ix\", 'txin')\n  call assert_equal(['ABxCx', 'ZZZ', 'def', 'ghi'], getline(1,'$'))\n  \" 4) CTRL-\\ a (should be inserted literally, not special after <c-\\>\n  call setline(1, ['ABC', 'ZZZ', 'def', 'ghi'])\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-\\>a\", 'txin')\n  call assert_equal([\"ABC\\<c-\\>a\", 'ZZZ', 'def', 'ghi'], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_edit_11()\n  \" Test that indenting kicks in\n  new\n  set cindent\n  call setline(1, ['{', '', ''])\n  call cursor(2, 1)\n  call feedkeys(\"i\\<c-f>int c;\\<esc>\", 'tnix')\n  call cursor(3, 1)\n  call feedkeys(\"\\<Insert>/* comment */\", 'tnix')\n  call assert_equal(['{', \"\\<tab>int c;\", \"/* comment */\"], getline(1, '$'))\n  \" added changed cindentkeys slightly\n  set cindent cinkeys+=*/\n  call setline(1, ['{', '', ''])\n  call cursor(2, 1)\n  call feedkeys(\"i\\<c-f>int c;\\<esc>\", 'tnix')\n  call cursor(3, 1)\n  call feedkeys(\"i/* comment */\", 'tnix')\n  call assert_equal(['{', \"\\<tab>int c;\", \"\\<tab>/* comment */\"], getline(1, '$'))\n  set cindent cinkeys+==end\n  call feedkeys(\"oend\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['{', \"\\<tab>int c;\", \"\\<tab>/* comment */\", \"\\tend\", ''], getline(1, '$'))\n  set cinkeys-==end\n  %d\n  \" Use indentexpr instead of cindenting\n  func! Do_Indent()\n    if v:lnum == 3\n      return 3*shiftwidth()\n    else\n      return 2*shiftwidth()\n    endif\n  endfunc\n  setl indentexpr=Do_Indent() indentkeys+=*/\n  call setline(1, ['{', '', ''])\n  call cursor(2, 1)\n  call feedkeys(\"i\\<c-f>int c;\\<esc>\", 'tnix')\n  call cursor(3, 1)\n  call feedkeys(\"i/* comment */\", 'tnix')\n  call assert_equal(['{', \"\\<tab>\\<tab>int c;\", \"\\<tab>\\<tab>\\<tab>/* comment */\"], getline(1, '$'))\n  set cinkeys&vim indentkeys&vim\n  set nocindent indentexpr=\n  delfu Do_Indent\n  bw!\nendfunc\n\nfunc Test_edit_11_indentexpr()\n  \" Test that indenting kicks in\n  new\n  \" Use indentexpr instead of cindenting\n  func! Do_Indent()\n    let pline=prevnonblank(v:lnum)\n    if empty(getline(v:lnum))\n      if getline(pline) =~ 'if\\|then'\n        return shiftwidth()\n      else\n        return 0\n      endif\n    else\n        return 0\n    endif\n  endfunc\n  setl indentexpr=Do_Indent() indentkeys+=0=then,0=fi\n  call setline(1, ['if [ $this ]'])\n  call cursor(1, 1)\n  call feedkeys(\"othen\\<cr>that\\<cr>fi\", 'tnix')\n  call assert_equal(['if [ $this ]', \"then\", \"\\<tab>that\", \"fi\"], getline(1, '$'))\n  set cinkeys&vim indentkeys&vim\n  set nocindent indentexpr=\n  delfu Do_Indent\n  bw!\nendfunc\n\n\" Test changing indent in replace mode\nfunc Test_edit_12()\n  new\n  call setline(1, [\"\\tabc\", \"\\tdef\"])\n  call cursor(2, 4)\n  call feedkeys(\"R^\\<c-d>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"def\"], getline(1, '$'))\n  call assert_equal([0, 2, 2, 0], '.'->getpos())\n  %d\n  call setline(1, [\"\\tabc\", \"\\t\\tdef\"])\n  call cursor(2, 2)\n  call feedkeys(\"R^\\<c-d>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"def\"], getline(1, '$'))\n  call assert_equal([0, 2, 1, 0], getpos('.'))\n  %d\n  call setline(1, [\"\\tabc\", \"\\t\\tdef\"])\n  call cursor(2, 2)\n  call feedkeys(\"R\\<c-t>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"\\t\\t\\tdef\"], getline(1, '$'))\n  call assert_equal([0, 2, 2, 0], getpos('.'))\n  bw!\n  10vnew\n  call setline(1, [\"\\tabc\", \"\\t\\tdef\"])\n  call cursor(2, 2)\n  call feedkeys(\"R\\<c-t>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"\\t\\t\\tdef\"], getline(1, '$'))\n  call assert_equal([0, 2, 2, 0], getpos('.'))\n  %d\n  set sw=4\n  call setline(1, [\"\\tabc\", \"\\t\\tdef\"])\n  call cursor(2, 2)\n  call feedkeys(\"R\\<c-t>\\<c-t>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"\\t\\t\\tdef\"], getline(1, '$'))\n  call assert_equal([0, 2, 2, 0], getpos('.'))\n  %d\n  call setline(1, [\"\\tabc\", \"\\t\\tdef\"])\n  call cursor(2, 2)\n  call feedkeys(\"R\\<c-t>\\<c-t>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"\\t\\t\\tdef\"], getline(1, '$'))\n  call assert_equal([0, 2, 2, 0], getpos('.'))\n  set sw&\n\n  \" In replace mode, after hitting enter in a line with tab characters,\n  \" pressing backspace should restore the tab characters.\n  %d\n  setlocal autoindent backspace=2\n  call setline(1, \"\\tone\\t\\ttwo\")\n  exe \"normal ggRred\\<CR>six\" .. repeat(\"\\<BS>\", 8)\n  call assert_equal([\"\\tone\\t\\ttwo\"], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_edit_13()\n  \" Test smartindenting\n  if exists(\"+smartindent\")\n    new\n    set smartindent autoindent\n    call setline(1, [\"\\tabc\"])\n    call feedkeys(\"A {\\<cr>more\\<cr>}\\<esc>\", 'tnix')\n    call assert_equal([\"\\tabc {\", \"\\t\\tmore\", \"\\t}\"], getline(1, '$'))\n    set smartindent& autoindent&\n    bwipe!\n  endif\n\n  \" Test autoindent removing indent of blank line.\n  new\n  call setline(1, '    foo bar baz')\n  set autoindent\n  exe \"normal 0eea\\<CR>\\<CR>\\<Esc>\"\n  call assert_equal(\"    foo bar\", getline(1))\n  call assert_equal(\"\", getline(2))\n  call assert_equal(\"    baz\", getline(3))\n  set autoindent&\n\n  \" pressing <C-U> to erase line should keep the indent with 'autoindent'\n  set backspace=2 autoindent\n  %d\n  exe \"normal i\\tone\\<CR>three\\<C-U>two\"\n  call assert_equal([\"\\tone\", \"\\ttwo\"], getline(1, '$'))\n  set backspace& autoindent&\n\n  bwipe!\nendfunc\n\n\" Test for autoindent removing indent when insert mode is stopped.  Some parts\n\" of the code is exercised only when interactive mode is used. So use Vim in a\n\" terminal.\nfunc Test_autoindent_remove_indent()\n  CheckRunVimInTerminal\n  let buf = RunVimInTerminal('-N Xfile', {'rows': 6, 'cols' : 20})\n  call TermWait(buf)\n  call term_sendkeys(buf, \":set autoindent\\n\")\n  \" leaving insert mode in a new line with indent added by autoindent, should\n  \" remove the indent.\n  call term_sendkeys(buf, \"i\\<Tab>foo\\<CR>\\<Esc>\")\n  \" Need to delay for sometime, otherwise the code in getchar.c will not be\n  \" exercised.\n  call TermWait(buf, 50)\n  \" when a line is wrapped and the cursor is at the start of the second line,\n  \" leaving insert mode, should move the cursor back to the first line.\n  call term_sendkeys(buf, \"o\" .. repeat('x', 20) .. \"\\<Esc>\")\n  \" Need to delay for sometime, otherwise the code in getchar.c will not be\n  \" exercised.\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":w\\n\")\n  call TermWait(buf)\n  call StopVimInTerminal(buf)\n  call assert_equal([\"\\tfoo\", '', repeat('x', 20)], readfile('Xfile'))\n  call delete('Xfile')\nendfunc\n\nfunc Test_edit_CR()\n  \" Test for <CR> in insert mode\n  \" basically only in quickfix mode ist tested, the rest\n  \" has been taken care of by other tests\n  CheckFeature quickfix\n  botright new\n  call writefile(range(1, 10), 'Xqflist.txt')\n  call setqflist([{'filename': 'Xqflist.txt', 'lnum': 2}])\n  copen\n  set modifiable\n  call feedkeys(\"A\\<cr>\", 'tnix')\n  call assert_equal('Xqflist.txt', bufname(''))\n  call assert_equal(2, line('.'))\n  cclose\n  botright new\n  call setloclist(0, [{'filename': 'Xqflist.txt', 'lnum': 10}])\n  lopen\n  set modifiable\n  call feedkeys(\"A\\<cr>\", 'tnix')\n  call assert_equal('Xqflist.txt', bufname(''))\n  call assert_equal(10, line('.'))\n  call feedkeys(\"A\\<Enter>\", 'tnix')\n  call feedkeys(\"A\\<kEnter>\", 'tnix')\n  call feedkeys(\"A\\n\", 'tnix')\n  call feedkeys(\"A\\r\", 'tnix')\n  call assert_equal(map(range(1, 10), 'string(v:val)') + ['', '', '', ''], getline(1, '$'))\n  bw!\n  lclose\n  call delete('Xqflist.txt')\nendfunc\n\nfunc Test_edit_CTRL_()\n  CheckFeature rightleft\n  \" disabled for Windows builds, why?\n  CheckNotMSWindows\n  let _encoding=&encoding\n  set encoding=utf-8\n  \" Test for CTRL-_\n  new\n  call setline(1, ['abc'])\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-_>xyz\\<esc>\", 'tnix')\n  call assert_equal([\"\\<C-_>xyzabc\"], getline(1, '$'))\n  call assert_false(&revins)\n  set ari\n  call setline(1, ['abc'])\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-_>xyz\\<esc>\", 'tnix')\n  call assert_equal([\"\u00e6\u00e8\u00f1abc\"], getline(1, '$'))\n  call assert_true(&revins)\n  call setline(1, ['abc'])\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-_>xyz\\<esc>\", 'tnix')\n  call assert_equal([\"xyzabc\"], getline(1, '$'))\n  call assert_false(&revins)\n  set noari\n  let &encoding=_encoding\n  bw!\nendfunc\n\n\" needs to come first, to have the @. register empty\nfunc Test_edit_00a_CTRL_A()\n  \" Test pressing CTRL-A\n  new\n  call setline(1, repeat([''], 5))\n  call cursor(1, 1)\n  try\n    call feedkeys(\"A\\<NUL>\", 'tnix')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E29/\n    call assert_true(1, 'E29 error caught')\n  endtry\n  call cursor(1, 1)\n  call feedkeys(\"Afoobar \\<esc>\", 'tnix')\n  call cursor(2, 1)\n  call feedkeys(\"A\\<c-a>more\\<esc>\", 'tnix')\n  call cursor(3, 1)\n  call feedkeys(\"A\\<NUL>and more\\<esc>\", 'tnix')\n  call assert_equal(['foobar ', 'foobar more', 'foobar morend more', '', ''], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_EY()\n  \" Ctrl-E/ Ctrl-Y in insert mode completion to scroll\n  10new\n  call setline(1, range(1, 100))\n  call cursor(30, 1)\n  norm! z.\n  call feedkeys(\"A\\<c-x>\\<c-e>\\<c-e>\\<c-e>\\<c-e>\\<c-e>\", 'tnix')\n  call assert_equal(30, winsaveview()['topline'])\n  call assert_equal([0, 30, 2, 0], getpos('.'))\n  call feedkeys(\"A\\<c-x>\\<c-e>\\<c-e>\\<c-e>\\<c-e>\\<c-e>\", 'tnix')\n  call feedkeys(\"A\\<c-x>\".repeat(\"\\<c-y>\", 10), 'tnix')\n  call assert_equal(21, winsaveview()['topline'])\n  call assert_equal([0, 30, 2, 0], getpos('.'))\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_G()\n  new\n  call setline(1, ['foobar', 'foobar', 'foobar'])\n  call cursor(2, 4)\n  call feedkeys(\"ioooooooo\\<c-g>k\\<c-r>.\\<esc>\", 'tnix')\n  call assert_equal(['foooooooooobar', 'foooooooooobar', 'foobar'], getline(1, '$'))\n  call assert_equal([0, 1, 11, 0], getpos('.'))\n  call feedkeys(\"i\\<c-g>k\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 10, 0], getpos('.'))\n  call cursor(2, 4)\n  call feedkeys(\"i\\<c-g>jzzzz\\<esc>\", 'tnix')\n  call assert_equal(['foooooooooobar', 'foooooooooobar', 'foozzzzbar'], getline(1, '$'))\n  call assert_equal([0, 3, 7, 0], getpos('.'))\n  call feedkeys(\"i\\<c-g>j\\<esc>\", 'tnix')\n  call assert_equal([0, 3, 6, 0], getpos('.'))\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_I()\n  \" Tab in completion mode\n  let path=expand(\"%:p:h\")\n  new\n  call setline(1, [path. \"/\", ''])\n  call feedkeys(\"Arunt\\<c-x>\\<c-f>\\<tab>\\<cr>\\<esc>\", 'tnix')\n  call assert_match('runtest\\.vim', getline(1))\n  %d\n  call writefile(['one', 'two', 'three'], 'Xinclude.txt')\n  let include='#include Xinclude.txt'\n  call setline(1, [include, ''])\n  call cursor(2, 1)\n  call feedkeys(\"A\\<c-x>\\<tab>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([include, 'one', ''], getline(1, '$'))\n  call feedkeys(\"2ggC\\<c-x>\\<tab>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([include, 'two', ''], getline(1, '$'))\n  call feedkeys(\"2ggC\\<c-x>\\<tab>\\<down>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([include, 'three', ''], getline(1, '$'))\n  call feedkeys(\"2ggC\\<c-x>\\<tab>\\<down>\\<down>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([include, '', ''], getline(1, '$'))\n  call delete(\"Xinclude.txt\")\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_K()\n  \" Test pressing CTRL-K (basically only dictionary completion and digraphs\n  \" the rest is already covered\n  call writefile(['A', 'AA', 'AAA', 'AAAA'], 'Xdictionary.txt')\n  set dictionary=Xdictionary.txt\n  new\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['AA', ''], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['AAA'], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<down>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['AAAA'], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<down>\\<down>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['A'], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<down>\\<down>\\<down>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['AA'], getline(1, '$'))\n\n  \" press an unexpected key after dictionary completion\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<c-]>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['AA', ''], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<c-s>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([\"AA\\<c-s>\", ''], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<c-f>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([\"AA\\<c-f>\", ''], getline(1, '$'))\n\n  set dictionary=\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  let v:testing = 1\n  try\n    call feedkeys(\"A\\<c-x>\\<c-k>\\<esc>\", 'tnix')\n  catch\n    \" error sleeps 2 seconds, when v:testing is not set\n    let v:testing = 0\n  endtry\n  call delete('Xdictionary.txt')\n\n  call test_override(\"char_avail\", 1)\n  set showcmd\n  %d\n  call feedkeys(\"A\\<c-k>a:\\<esc>\", 'tnix')\n  call assert_equal(['\u00e4'], getline(1, '$'))\n  call test_override(\"char_avail\", 0)\n  set noshowcmd\n\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_L()\n  \" Test Ctrl-X Ctrl-L (line completion)\n  new\n  set complete=.\n  call setline(1, ['one', 'two', 'three', '', '', '', ''])\n  call cursor(4, 1)\n  call feedkeys(\"A\\<c-x>\\<c-l>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'three', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-n>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 't', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-n>\\<c-n>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'two', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-n>\\<c-n>\\<c-n>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'three', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-n>\\<c-n>\\<c-n>\\<c-n>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 't', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-p>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'two', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-p>\\<c-p>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 't', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-p>\\<c-p>\\<c-p>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'three', '', '', ''], getline(1, '$'))\n  set complete=\n  call cursor(5, 1)\n  call feedkeys(\"A\\<c-x>\\<c-l>\\<c-p>\\<c-n>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'three', \"\\<c-l>\\<c-p>\\<c-n>\", '', ''], getline(1, '$'))\n  set complete&\n  %d\n  if has(\"conceal\") && has(\"syntax\")\n    call setline(1, ['foo', 'bar', 'foobar'])\n    call test_override(\"char_avail\", 1)\n    set conceallevel=2 concealcursor=n\n    syn on\n    syn match ErrorMsg \"^bar\"\n    call matchadd(\"Conceal\", 'oo', 10, -1, {'conceal': 'X'})\n    func! DoIt()\n      let g:change=1\n    endfunc\n    au! TextChangedI <buffer> :call DoIt()\n\n    call cursor(2, 1)\n    call assert_false(exists(\"g:change\"))\n    call feedkeys(\"A \\<esc>\", 'tnix')\n    call assert_equal(['foo', 'bar ', 'foobar'], getline(1, '$'))\n    call assert_equal(1, g:change)\n\n    call test_override(\"char_avail\", 0)\n    call clearmatches()\n    syn off\n    au! TextChangedI\n    delfu DoIt\n    unlet! g:change\n  endif\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_N()\n  \" Check keyword completion\n  for e in ['latin1', 'utf-8']\n    exe 'set encoding=' .. e\n    new\n    set complete=.\n    call setline(1, ['INFER', 'loWER', '', '', ])\n    call cursor(3, 1)\n    call feedkeys(\"Ai\\<c-n>\\<cr>\\<esc>\", \"tnix\")\n    call feedkeys(\"ILO\\<c-n>\\<cr>\\<esc>\", 'tnix')\n    call assert_equal(['INFER', 'loWER', 'i', 'LO', '', ''], getline(1, '$'), e)\n    %d\n    call setline(1, ['INFER', 'loWER', '', '', ])\n    call cursor(3, 1)\n    set ignorecase infercase\n    call feedkeys(\"Ii\\<c-n>\\<cr>\\<esc>\", \"tnix\")\n    call feedkeys(\"ILO\\<c-n>\\<cr>\\<esc>\", 'tnix')\n    call assert_equal(['INFER', 'loWER', 'infer', 'LOWER', '', ''], getline(1, '$'), e)\n\n    set noignorecase noinfercase complete&\n    bw!\n  endfor\nendfunc\n\nfunc Test_edit_CTRL_O()\n  \" Check for CTRL-O in insert mode\n  new\n  inoreabbr <buffer> h here some more\n  call setline(1, ['abc', 'def'])\n  call cursor(1, 1)\n  \" Ctrl-O after an abbreviation\n  exe \"norm A h\\<c-o>:set nu\\<cr> text\"\n  call assert_equal(['abc here some more text', 'def'], getline(1, '$'))\n  call assert_true(&nu)\n  set nonu\n  iunabbr <buffer> h\n  \" Ctrl-O at end of line with 've'=onemore\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-o>:let g:a=getpos('.')\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 23, 0], g:a)\n  call cursor(1, 1)\n  set ve=onemore\n  call feedkeys(\"A\\<c-o>:let g:a=getpos('.')\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 24, 0], g:a)\n  set ve=\n  unlet! g:a\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_R()\n  \" Insert Register\n  new\n  call test_override(\"ALL\", 1)\n  set showcmd\n  call feedkeys(\"AFOOBAR eins zwei\\<esc>\", 'tnix')\n  call feedkeys(\"O\\<c-r>.\", 'tnix')\n  call feedkeys(\"O\\<c-r>=10*500\\<cr>\\<esc>\", 'tnix')\n  call feedkeys(\"O\\<c-r>=getreg('=', 1)\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([\"getreg('=', 1)\", '5000', \"FOOBAR eins zwei\", \"FOOBAR eins zwei\"], getline(1, '$'))\n  call test_override(\"ALL\", 0)\n  set noshowcmd\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_S()\n  \" Test pressing CTRL-S (basically only spellfile completion)\n  \" the rest is already covered\n  new\n  if !has(\"spell\")\n    call setline(1, 'vim')\n    call feedkeys(\"A\\<c-x>ss\\<cr>\\<esc>\", 'tnix')\n    call assert_equal(['vims', ''], getline(1, '$'))\n    bw!\n    return\n  endif\n  call setline(1, 'vim')\n  \" spell option not yet set\n  try\n    call feedkeys(\"A\\<c-x>\\<c-s>\\<cr>\\<esc>\", 'tnix')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E756/\n    call assert_true(1, 'error caught')\n  endtry\n  call assert_equal(['vim', ''], getline(1, '$'))\n  %d\n  setl spell spelllang=en\n  call setline(1, 'vim')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-s>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['Vim', ''], getline(1, '$'))\n  %d\n  call setline(1, 'vim')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-s>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['Aim'], getline(1, '$'))\n  %d\n  call setline(1, 'vim')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-s>\\<c-p>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['vim', ''], getline(1, '$'))\n  %d\n  \" empty buffer\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-s>\\<c-p>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['', ''], getline(1, '$'))\n  setl nospell\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_T()\n  \" Check for CTRL-T and CTRL-X CTRL-T in insert mode\n  \" 1) increase indent\n  new\n  call setline(1, \"abc\")\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-t>xyz\", 'tnix')\n  call assert_equal([\"\\<tab>abcxyz\"], getline(1, '$'))\n  \" 2) also when paste option is set\n  set paste\n  call setline(1, \"abc\")\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-t>xyz\", 'tnix')\n  call assert_equal([\"\\<tab>abcxyz\"], getline(1, '$'))\n  set nopaste\n  \" CTRL-X CTRL-T (thesaurus complete)\n  call writefile(['angry furious mad enraged'], 'Xthesaurus')\n  set thesaurus=Xthesaurus\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['mad', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['angry', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['furious', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<c-n>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['enraged', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<c-n>\\<c-n>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['mad', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<c-n>\\<c-n>\\<c-n>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['mad', ''], getline(1, '$'))\n  \" Using <c-p> <c-n> when 'complete' is empty\n  set complete=\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['angry', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-p>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['mad', ''], getline(1, '$'))\n  set complete&\n\n  set thesaurus=\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  let v:testing = 1\n  try\n    call feedkeys(\"A\\<c-x>\\<c-t>\\<esc>\", 'tnix')\n  catch\n    \" error sleeps 2 seconds, when v:testing is not set\n    let v:testing = 0\n  endtry\n  call assert_equal(['mad'], getline(1, '$'))\n  call delete('Xthesaurus')\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_U()\n  \" Test 'completefunc'\n  new\n  \" -1, -2 and -3 are special return values\n  let g:special=0\n  fun! CompleteMonths(findstart, base)\n    if a:findstart\n      \" locate the start of the word\n      return g:special\n    else\n      \" find months matching with \"a:base\"\n      let res = []\n      for m in split(\"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\")\n        if m =~ '^\\c'.a:base\n          call add(res, {'word': m, 'abbr': m.' Month', 'icase': 0})\n        endif\n      endfor\n      return {'words': res, 'refresh': 'always'}\n    endif\n  endfun\n  set completefunc=CompleteMonths\n  call setline(1, ['', ''])\n  call cursor(1, 1)\n  call feedkeys(\"AX\\<c-x>\\<c-u>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['X', '', ''], getline(1, '$'))\n  %d\n  let g:special=-1\n  call feedkeys(\"AX\\<c-x>\\<c-u>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['XJan', ''], getline(1, '$'))\n  %d\n  let g:special=-2\n  call feedkeys(\"AX\\<c-x>\\<c-u>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['X', ''], getline(1, '$'))\n  %d\n  let g:special=-3\n  call feedkeys(\"AX\\<c-x>\\<c-u>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['X', ''], getline(1, '$'))\n  %d\n  let g:special=0\n  call feedkeys(\"AM\\<c-x>\\<c-u>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['Mar', ''], getline(1, '$'))\n  %d\n  call feedkeys(\"AM\\<c-x>\\<c-u>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['May', ''], getline(1, '$'))\n  %d\n  call feedkeys(\"AM\\<c-x>\\<c-u>\\<c-n>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['M', ''], getline(1, '$'))\n  delfu CompleteMonths\n  %d\n  try\n    call feedkeys(\"A\\<c-x>\\<c-u>\", 'tnix')\n    call assert_fails(1, 'unknown completion function')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E117/\n    call assert_true(1, 'E117 error caught')\n  endtry\n  set completefunc=\n  bw!\nendfunc\n\nfunc Test_edit_completefunc_delete()\n  func CompleteFunc(findstart, base)\n    if a:findstart == 1\n      return col('.') - 1\n    endif\n    normal dd\n    return ['a', 'b']\n  endfunc\n  new\n  set completefunc=CompleteFunc\n  call setline(1, ['', 'abcd', ''])\n  2d\n  call assert_fails(\"normal 2G$a\\<C-X>\\<C-U>\", 'E578:')\n  bwipe!\nendfunc\n\n\nfunc Test_edit_CTRL_Z()\n  \" Ctrl-Z when insertmode is not set inserts it literally\n  new\n  call setline(1, 'abc')\n  call feedkeys(\"A\\<c-z>\\<esc>\", 'tnix')\n  call assert_equal([\"abc\\<c-z>\"], getline(1,'$'))\n  bw!\n  \" TODO: How to Test Ctrl-Z in insert mode, e.g. suspend?\nendfunc\n\nfunc Test_edit_DROP()\n  CheckFeature dnd\n  new\n  call setline(1, ['abc def ghi'])\n  call cursor(1, 1)\n  try\n    call feedkeys(\"i\\<Drop>\\<Esc>\", 'tnix')\n    call assert_fails(1, 'Invalid register name')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E353/\n    call assert_true(1, 'error caught')\n  endtry\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_V()\n  CheckFeature ebcdic\n  new\n  call setline(1, ['abc'])\n  call cursor(2, 1)\n  \" force some redraws\n  set showmode showcmd\n  \"call test_override_char_avail(1)\n  call test_override('ALL', 1)\n  call feedkeys(\"A\\<c-v>\\<c-n>\\<c-v>\\<c-l>\\<c-v>\\<c-b>\\<esc>\", 'tnix')\n  call assert_equal([\"abc\\x0e\\x0c\\x02\"], getline(1, '$'))\n\n  if has(\"rightleft\") && exists(\"+rl\")\n    set rl\n    call setline(1, ['abc'])\n    call cursor(2, 1)\n    call feedkeys(\"A\\<c-v>\\<c-n>\\<c-v>\\<c-l>\\<c-v>\\<c-b>\\<esc>\", 'tnix')\n    call assert_equal([\"abc\\x0e\\x0c\\x02\"], getline(1, '$'))\n    set norl\n  endif\n\n  call test_override('ALL', 0)\n  set noshowmode showcmd\n  bw!\nendfunc\n\nfunc Test_edit_F1()\n  CheckFeature quickfix\n\n  \" Pressing <f1>\n  new\n  call feedkeys(\":set im\\<cr>\\<f1>\\<c-l>\", 'tnix')\n  set noinsertmode\n  call assert_equal('help', &buftype)\n  bw\n  bw\nendfunc\n\nfunc Test_edit_F21()\n  \" Pressing <f21>\n  \" sends a netbeans command\n  CheckFeature netbeans_intg\n  new\n  \" I have no idea what this is supposed to do :)\n  call feedkeys(\"A\\<F21>\\<F1>\\<esc>\", 'tnix')\n  bw\nendfunc\n\nfunc Test_edit_HOME_END()\n  \" Test Home/End Keys\n  new\n  set foldopen+=hor\n  call setline(1, ['abc', 'def'])\n  call cursor(1, 1)\n  call feedkeys(\"AX\\<Home>Y\\<esc>\", 'tnix')\n  call cursor(2, 1)\n  call feedkeys(\"iZ\\<End>Y\\<esc>\", 'tnix')\n  call assert_equal(['YabcX', 'ZdefY'], getline(1, '$'))\n\n  set foldopen-=hor\n  bw!\nendfunc\n\nfunc Test_edit_INS()\n  \" Test for Pressing <Insert>\n  new\n  call setline(1, ['abc', 'def'])\n  call cursor(1, 1)\n  call feedkeys(\"i\\<Insert>ZYX>\", 'tnix')\n  call assert_equal(['ZYX>', 'def'], getline(1, '$'))\n  call setline(1, ['abc', 'def'])\n  call cursor(1, 1)\n  call feedkeys(\"i\\<Insert>Z\\<Insert>YX>\", 'tnix')\n  call assert_equal(['ZYX>bc', 'def'], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_edit_LEFT_RIGHT()\n  \" Left, Shift-Left, Right, Shift-Right\n  new\n  call setline(1, ['abc def ghi', 'ABC DEF GHI', 'ZZZ YYY XXX'])\n  let _ww=&ww\n  set ww=\n  call cursor(2, 1)\n  call feedkeys(\"i\\<left>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 1, 0], getpos('.'))\n  \" Is this a bug, <s-left> does not respect whichwrap option\n  call feedkeys(\"i\\<s-left>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 8, 0], getpos('.'))\n  call feedkeys(\"i\". repeat(\"\\<s-left>\", 3). \"\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<right>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<right>\\<right>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 2, 0], getpos('.'))\n  call feedkeys(\"A\\<right>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<s-right>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<s-right>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 4, 0], getpos('.'))\n  call cursor(3, 11)\n  call feedkeys(\"A\\<right>\\<esc>\", 'tnix')\n  call feedkeys(\"A\\<s-right>\\<esc>\", 'tnix')\n  call assert_equal([0, 3, 11, 0], getpos('.'))\n  call cursor(2, 11)\n  \" <S-Right> does not respect 'whichwrap' option\n  call feedkeys(\"A\\<s-right>\\<esc>\", 'tnix')\n  call assert_equal([0, 3, 1, 0], getpos('.'))\n  \" Check motion when 'whichwrap' contains cursor keys for insert mode\n  set ww+=[,]\n  call cursor(2, 1)\n  call feedkeys(\"i\\<left>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 11, 0], getpos('.'))\n  call cursor(2, 11)\n  call feedkeys(\"A\\<right>\\<esc>\", 'tnix')\n  call assert_equal([0, 3, 1, 0], getpos('.'))\n  call cursor(2, 11)\n  call feedkeys(\"A\\<s-right>\\<esc>\", 'tnix')\n  call assert_equal([0, 3, 1, 0], getpos('.'))\n  let &ww = _ww\n  bw!\nendfunc\n\nfunc Test_edit_MOUSE()\n  \" This is a simple test, since we not really using the mouse here\n  CheckFeature mouse\n  10new\n  call setline(1, range(1, 100))\n  call cursor(1, 1)\n  set mouse=a\n  call feedkeys(\"A\\<ScrollWheelDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 4, 1, 0], getpos('.'))\n  \" This should move by one pageDown, but only moves\n  \" by one line when the test is run...\n  call feedkeys(\"A\\<S-ScrollWheelDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 1, 0], getpos('.'))\n  set nostartofline\n  call feedkeys(\"A\\<C-ScrollWheelDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 6, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<LeftMouse>\\<esc>\", 'tnix')\n  call assert_equal([0, 6, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<RightMouse>\\<esc>\", 'tnix')\n  call assert_equal([0, 6, 1, 0], getpos('.'))\n  call cursor(1, 100)\n  norm! zt\n  \" this should move by a screen up, but when the test\n  \" is run, it moves up to the top of the buffer...\n  call feedkeys(\"A\\<ScrollWheelUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call cursor(1, 30)\n  norm! zt\n  call feedkeys(\"A\\<S-ScrollWheelUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call cursor(1, 30)\n  norm! zt\n  call feedkeys(\"A\\<C-ScrollWheelUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  %d\n  call setline(1, repeat([\"12345678901234567890\"], 100))\n  call cursor(2, 1)\n  call feedkeys(\"A\\<ScrollWheelRight>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  call feedkeys(\"A\\<ScrollWheelLeft>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  call feedkeys(\"A\\<S-ScrollWheelRight>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  call feedkeys(\"A\\<S-ScrollWheelLeft>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  call feedkeys(\"A\\<C-ScrollWheelRight>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  call feedkeys(\"A\\<C-ScrollWheelLeft>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  set mouse& startofline\n  bw!\nendfunc\n\nfunc Test_edit_PAGEUP_PAGEDOWN()\n  10new\n  call setline(1, repeat(['abc def ghi'], 30))\n  call cursor(1, 1)\n  call feedkeys(\"i\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 9, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 17, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 25, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 29, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 21, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 13, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  \" <S-Up> is the same as <PageUp>\n  \" <S-Down> is the same as <PageDown>\n  call cursor(1, 1)\n  call feedkeys(\"i\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 9, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 17, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 25, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 29, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 21, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 13, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  set nostartofline\n  call cursor(30, 11)\n  norm! zt\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 29, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 21, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 13, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  call cursor(1, 1)\n  call feedkeys(\"A\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 9, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 17, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 25, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 11, 0], getpos('.'))\n  \" <S-Up> is the same as <PageUp>\n  \" <S-Down> is the same as <PageDown>\n  call cursor(30, 11)\n  norm! zt\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 29, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 21, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 13, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  call cursor(1, 1)\n  call feedkeys(\"A\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 9, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 17, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 25, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 11, 0], getpos('.'))\n  bw!\nendfunc\n\nfunc Test_edit_forbidden()\n  new\n  \" 1) edit in the sandbox is not allowed\n  call setline(1, 'a')\n  com! Sandbox :sandbox call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n  call assert_fails(':Sandbox', 'E48:')\n  com! Sandbox :sandbox exe \"norm! i\\<del>\"\n  call assert_fails(':Sandbox', 'E48:')\n  delcom Sandbox\n  call assert_equal(['a'], getline(1,'$'))\n  \" 2) edit with textlock set\n  fu! DoIt()\n    call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n  endfu\n  au InsertCharPre <buffer> :call DoIt()\n  try\n    call feedkeys(\"ix\\<esc>\", 'tnix')\n    call assert_fails(1, 'textlock')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E565/ \" catch E565: not allowed here\n  endtry\n  \" TODO: Might be a bug: should x really be inserted here\n  call assert_equal(['xa'], getline(1, '$'))\n  delfu DoIt\n  try\n    call feedkeys(\"ix\\<esc>\", 'tnix')\n    call assert_fails(1, 'unknown function')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E117/ \" catch E117: unknown function\n  endtry\n  au! InsertCharPre\n  \" 3) edit when completion is shown\n  fun! Complete(findstart, base)\n    if a:findstart\n      return col('.')\n    else\n      call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n      return []\n    endif\n  endfun\n  set completefunc=Complete\n  try\n    call feedkeys(\"i\\<c-x>\\<c-u>\\<esc>\", 'tnix')\n    call assert_fails(1, 'change in complete function')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E565/ \" catch E565\n  endtry\n  delfu Complete\n  set completefunc=\n  if has(\"rightleft\") && exists(\"+fkmap\")\n    \" 4) 'R' when 'fkmap' and 'revins' is set.\n    set revins fkmap\n    try\n      normal Ri\n      call assert_fails(1, \"R with 'fkmap' and 'ri' set\")\n    catch\n    finally\n      set norevins nofkmap\n    endtry\n  endif\n  bw!\nendfunc\n\nfunc Test_edit_rightleft()\n  \" Cursor in rightleft mode moves differently\n  CheckFeature rightleft\n  call NewWindow(10, 20)\n  call setline(1, ['abc', 'def', 'ghi'])\n  call cursor(1, 2)\n  set rightleft\n  \" Screen looks as expected\n  let lines = ScreenLines([1, 4], winwidth(0))\n  let expect = [\n        \\\"                 cba\",\n        \\\"                 fed\",\n        \\\"                 ihg\",\n        \\\"                   ~\"]\n  call assert_equal(join(expect, \"\\n\"), join(lines, \"\\n\"))\n  \" 2) right moves to the left\n  call feedkeys(\"i\\<right>\\<esc>x\", 'txin')\n  call assert_equal(['bc', 'def', 'ghi'], getline(1,'$'))\n  call cursor(1, 2)\n  call feedkeys(\"i\\<s-right>\\<esc>\", 'txin')\n  call cursor(1, 2)\n  call feedkeys(\"i\\<c-right>\\<esc>\", 'txin')\n  \" Screen looks as expected\n  let lines = ScreenLines([1, 4], winwidth(0))\n  let expect = [\n        \\\"                  cb\",\n        \\\"                 fed\",\n        \\\"                 ihg\",\n        \\\"                   ~\"]\n  call assert_equal(join(expect, \"\\n\"), join(lines, \"\\n\"))\n  \" 2) left moves to the right\n  call setline(1, ['abc', 'def', 'ghi'])\n  call cursor(1, 2)\n  call feedkeys(\"i\\<left>\\<esc>x\", 'txin')\n  call assert_equal(['ac', 'def', 'ghi'], getline(1,'$'))\n  call cursor(1, 2)\n  call feedkeys(\"i\\<s-left>\\<esc>\", 'txin')\n  call cursor(1, 2)\n  call feedkeys(\"i\\<c-left>\\<esc>\", 'txin')\n  \" Screen looks as expected\n  let lines = ScreenLines([1, 4], winwidth(0))\n  let expect = [\n        \\\"                  ca\",\n        \\\"                 fed\",\n        \\\"                 ihg\",\n        \\\"                   ~\"]\n  call assert_equal(join(expect, \"\\n\"), join(lines, \"\\n\"))\n  %d _\n  call test_override('redraw_flag', 1)\n  call test_override('char_avail', 1)\n  call feedkeys(\"a\\<C-V>x41\", \"xt\")\n  redraw!\n  call assert_equal(repeat(' ', 19) .. 'A', Screenline(1))\n  call test_override('ALL', 0)\n  set norightleft\n  bw!\nendfunc\n\nfunc Test_edit_complete_very_long_name()\n  \" Long directory names only work on Unix.\n  CheckUnix\n\n  let dirname = getcwd() . \"/Xdir\"\n  let longdirname = dirname . repeat('/' . repeat('d', 255), 4)\n  try\n    call mkdir(longdirname, 'p')\n  catch /E739:/\n    \" Long directory name probably not supported.\n    call delete(dirname, 'rf')\n    return\n  endtry\n\n  \" Try to get the Vim window position before setting 'columns', so that we can\n  \" move the window back to where it was.\n  let winposx = getwinposx()\n  let winposy = getwinposy()\n\n  if winposx >= 0 && winposy >= 0 && !has('gui_running')\n    \" We did get the window position, but xterm may report the wrong numbers.\n    \" Move the window to the reported position and compute any offset.\n    exe 'winpos ' . winposx . ' ' . winposy\n    sleep 100m\n    let x = getwinposx()\n    if x >= 0\n      let winposx += winposx - x\n    endif\n    let y = getwinposy()\n    if y >= 0\n      let winposy += winposy - y\n    endif\n  endif\n\n  let save_columns = &columns\n  \" Need at least about 1100 columns to reproduce the problem.\n  set columns=2000\n  set noswapfile\n\n  let longfilename = longdirname . '/' . repeat('a', 255)\n  call writefile(['Totum', 'Table'], longfilename)\n  new\n  exe \"next Xfile \" . longfilename\n  exe \"normal iT\\<C-N>\"\n\n  bwipe!\n  exe 'bwipe! ' . longfilename\n  call delete(dirname, 'rf')\n  let &columns = save_columns\n  if winposx >= 0 && winposy >= 0\n    exe 'winpos ' . winposx . ' ' . winposy\n  endif\n  set swapfile&\nendfunc\n\nfunc Test_edit_backtick()\n  next a\\`b c\n  call assert_equal('a`b', expand('%'))\n  next\n  call assert_equal('c', expand('%'))\n  call assert_equal('a\\`b c', expand('##'))\nendfunc\n\nfunc Test_edit_quit()\n  edit foo.txt\n  split\n  new\n  call setline(1, 'hello')\n  3wincmd w\n  redraw!\n  call assert_fails('1q', 'E37:')\n  bwipe! foo.txt\n  only\nendfunc\n\nfunc Test_edit_alt()\n  \" Keeping the cursor line didn't happen when the first line has indent.\n  new\n  call setline(1, ['  one', 'two', 'three'])\n  w XAltFile\n  $\n  call assert_equal(3, line('.'))\n  e Xother\n  e #\n  call assert_equal(3, line('.'))\n\n  bwipe XAltFile\n  call delete('XAltFile')\nendfunc\n\nfunc Test_edit_InsertLeave()\n  new\n  au InsertLeavePre * let g:did_au_pre = 1\n  au InsertLeave * let g:did_au = 1\n  let g:did_au_pre = 0\n  let g:did_au = 0\n  call feedkeys(\"afoo\\<Esc>\", 'tx')\n  call assert_equal(1, g:did_au_pre)\n  call assert_equal(1, g:did_au)\n  call assert_equal('foo', getline(1))\n\n  let g:did_au_pre = 0\n  let g:did_au = 0\n  call feedkeys(\"Sbar\\<C-C>\", 'tx')\n  call assert_equal(1, g:did_au_pre)\n  call assert_equal(0, g:did_au)\n  call assert_equal('bar', getline(1))\n\n  inoremap x xx<Esc>\n  let g:did_au_pre = 0\n  let g:did_au = 0\n  call feedkeys(\"Saax\", 'tx')\n  call assert_equal(1, g:did_au_pre)\n  call assert_equal(1, g:did_au)\n  call assert_equal('aaxx', getline(1))\n\n  inoremap x xx<C-C>\n  let g:did_au_pre = 0\n  let g:did_au = 0\n  call feedkeys(\"Sbbx\", 'tx')\n  call assert_equal(1, g:did_au_pre)\n  call assert_equal(0, g:did_au)\n  call assert_equal('bbxx', getline(1))\n\n  bwipe!\n  au! InsertLeave InsertLeavePre\n  iunmap x\nendfunc\n\nfunc Test_edit_InsertLeave_undo()\n  new XtestUndo\n  set undofile\n  au InsertLeave * wall\n  exe \"normal ofoo\\<Esc>\"\n  call assert_equal(2, line('$'))\n  normal u\n  call assert_equal(1, line('$'))\n\n  bwipe!\n  au! InsertLeave\n  call delete('XtestUndo')\n  call delete(undofile('XtestUndo'))\n  set undofile&\nendfunc\n\n\" Test for inserting characters using CTRL-V followed by a number.\nfunc Test_edit_special_chars()\n  new\n\n  if has(\"ebcdic\")\n    let t = \"o\\<C-V>193\\<C-V>xc2\\<C-V>o303 \\<C-V>90a\\<C-V>xfg\\<C-V>o578\\<Esc>\"\n  else\n    let t = \"o\\<C-V>65\\<C-V>x42\\<C-V>o103 \\<C-V>33a\\<C-V>xfg\\<C-V>o78\\<Esc>\"\n  endif\n\n  exe \"normal \" . t\n  call assert_equal(\"ABC !a\\<C-O>g\\<C-G>8\", getline(2))\n\n  close!\nendfunc\n\nfunc Test_edit_startinsert()\n  new\n  set backspace+=start\n  call setline(1, 'foobar')\n  call feedkeys(\"A\\<C-U>\\<Esc>\", 'xt')\n  call assert_equal('', getline(1))\n\n  call setline(1, 'foobar')\n  call feedkeys(\":startinsert!\\<CR>\\<C-U>\\<Esc>\", 'xt')\n  call assert_equal('', getline(1))\n\n  set backspace&\n  bwipe!\nendfunc\n\n\" Test for :startreplace and :startgreplace\nfunc Test_edit_startreplace()\n  new\n  call setline(1, 'abc')\n  call feedkeys(\"l:startreplace\\<CR>xyz\\e\", 'xt')\n  call assert_equal('axyz', getline(1))\n  call feedkeys(\"0:startreplace!\\<CR>abc\\e\", 'xt')\n  call assert_equal('axyzabc', getline(1))\n  call setline(1, \"a\\tb\")\n  call feedkeys(\"0l:startgreplace\\<CR>xyz\\e\", 'xt')\n  call assert_equal(\"axyz\\tb\", getline(1))\n  call feedkeys(\"0i\\<C-R>=execute('startreplace')\\<CR>12\\e\", 'xt')\n  call assert_equal(\"12axyz\\tb\", getline(1))\n  close!\nendfunc\n\nfunc Test_edit_noesckeys()\n  CheckNotGui\n  new\n\n  \" <Left> moves cursor when 'esckeys' is set\n  exe \"set t_kl=\\<Esc>OD\"\n  set esckeys\n  call feedkeys(\"axyz\\<Esc>ODX\", \"xt\")\n  call assert_equal(\"xyXz\", getline(1))\n\n  \" <Left> exits Insert mode when 'esckeys' is off\n  set noesckeys\n  call setline(1, '')\n  call feedkeys(\"axyz\\<Esc>ODX\", \"xt\")\n  call assert_equal([\"DX\", \"xyz\"], getline(1, 2))\n\n  bwipe!\n  set esckeys\nendfunc\n\n\" Test for running an invalid ex command in insert mode using CTRL-O\nfunc Test_edit_ctrl_o_invalid_cmd()\n  new\n  set showmode showcmd\n  \" Avoid a sleep of 3 seconds. Zero might have side effects.\n  call test_override('ui_delay', 50)\n  let caught_e492 = 0\n  try\n    call feedkeys(\"i\\<C-O>:invalid\\<CR>abc\\<Esc>\", \"xt\")\n  catch /E492:/\n    let caught_e492 = 1\n  endtry\n  call assert_equal(1, caught_e492)\n  call assert_equal('abc', getline(1))\n  set showmode& showcmd&\n  call test_override('ui_delay', 0)\n  close!\nendfunc\n\n\" Test for editing a file with a very long name\nfunc Test_edit_illegal_filename()\n  CheckEnglish\n  new\n  redir => msg\n  exe 'edit ' . repeat('f', 5000)\n  redir END\n  call assert_match(\"Illegal file name$\", split(msg, \"\\n\")[0])\n  close!\nendfunc\n\n\" Test for editing a directory\nfunc Test_edit_is_a_directory()\n  CheckEnglish\n  let dirname = getcwd() . \"/Xdir\"\n  call mkdir(dirname, 'p')\n\n  new\n  redir => msg\n  exe 'edit' dirname\n  redir END\n  call assert_match(\"is a directory$\", split(msg, \"\\n\")[0])\n  bwipe!\n\n  let dirname .= '/'\n\n  new\n  redir => msg\n  exe 'edit' dirname\n  redir END\n  call assert_match(\"is a directory$\", split(msg, \"\\n\")[0])\n  bwipe!\n\n  call delete(dirname, 'rf')\nendfunc\n\n\" Test for editing a file using invalid file encoding\nfunc Test_edit_invalid_encoding()\n  CheckEnglish\n  call writefile([], 'Xfile')\n  redir => msg\n  new ++enc=axbyc Xfile\n  redir END\n  call assert_match('\\[NOT converted\\]', msg)\n  call delete('Xfile')\n  close!\nendfunc\n\n\" Test for the \"charconvert\" option\nfunc Test_edit_charconvert()\n  CheckEnglish\n  call writefile(['one', 'two'], 'Xfile')\n\n  \" set 'charconvert' to a non-existing function\n  set charconvert=NonExitingFunc()\n  new\n  let caught_e117 = v:false\n  try\n    redir => msg\n    edit ++enc=axbyc Xfile\n  catch /E117:/\n    let caught_e117 = v:true\n  finally\n    redir END\n  endtry\n  call assert_true(caught_e117)\n  call assert_equal(['one', 'two'], getline(1, '$'))\n  call assert_match(\"Conversion with 'charconvert' failed\", msg)\n  close!\n  set charconvert&\n\n  \" 'charconvert' function doesn't create a output file\n  func Cconv1()\n  endfunc\n  set charconvert=Cconv1()\n  new\n  redir => msg\n  edit ++enc=axbyc Xfile\n  redir END\n  call assert_equal(['one', 'two'], getline(1, '$'))\n  call assert_match(\"can't read output of 'charconvert'\", msg)\n  close!\n  delfunc Cconv1\n  set charconvert&\n\n  \" 'charconvert' function to convert to upper case\n  func Cconv2()\n    let data = readfile(v:fname_in)\n    call map(data, 'toupper(v:val)')\n    call writefile(data, v:fname_out)\n  endfunc\n  set charconvert=Cconv2()\n  new Xfile\n  write ++enc=ucase Xfile1\n  call assert_equal(['ONE', 'TWO'], readfile('Xfile1'))\n  call delete('Xfile1')\n  close!\n  delfunc Cconv2\n  set charconvert&\n\n  \" 'charconvert' function removes the input file\n  func Cconv3()\n    call delete(v:fname_in)\n  endfunc\n  set charconvert=Cconv3()\n  new\n  call assert_fails('edit ++enc=lcase Xfile', 'E202:')\n  call assert_equal([''], getline(1, '$'))\n  close!\n  delfunc Cconv3\n  set charconvert&\n\n  call delete('Xfile')\nendfunc\n\n\" Test for editing a file without read permission\nfunc Test_edit_file_no_read_perm()\n  CheckUnix\n  CheckNotRoot\n\n  call writefile(['one', 'two'], 'Xfile')\n  call setfperm('Xfile', '-w-------')\n  new\n  redir => msg\n  edit Xfile\n  redir END\n  call assert_equal(1, &readonly)\n  call assert_equal([''], getline(1, '$'))\n  call assert_match('\\[Permission Denied\\]', msg)\n  close!\n  call delete('Xfile')\nendfunc\n\n\" Pressing escape in 'insertmode' should beep\nfunc Test_edit_insertmode_esc_beeps()\n  new\n  set insertmode\n  call assert_beeps(\"call feedkeys(\\\"one\\<Esc>\\\", 'xt')\")\n  set insertmode&\n  \" unsupported CTRL-G command should beep in insert mode.\n  call assert_beeps(\"normal i\\<C-G>l\")\n  close!\nendfunc\n\n\" Test for 'hkmap' and 'hkmapp'\nfunc Test_edit_hkmap()\n  CheckFeature rightleft\n  if has('win32') && !has('gui')\n    throw 'Skipped: fails on the MS-Windows terminal version'\n  endif\n  new\n\n  set revins hkmap\n  let str = 'abcdefghijklmnopqrstuvwxyz'\n  let str ..= 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  let str ..= '`/'',.;'\n  call feedkeys('i' .. str, 'xt')\n  let expected = \"\u00f3\u00f5\u00fa,.;\"\n  let expected ..= \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"\n  let expected ..= \"\u00e6\u00e8\u00f1'\u00e4\u00e5\u00e0\u00e3\u00f8/\u00f4\u00ed\u00ee\u00f6\u00ea\u00ec\u00e7\u00ef\u00e9\u00f2\u00eb\u00f7\u00e2\u00e1\u00f0\u00f9\"\n  call assert_equal(expected, getline(1))\n\n  %d\n  set revins hkmap hkmapp\n  let str = 'abcdefghijklmnopqrstuvwxyz'\n  let str ..= 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  call feedkeys('i' .. str, 'xt')\n  let expected = \"\u00f5YXWVUTSRQ\u00f3O\u00ef\u00edLKJIHGFED\u00eaBA\"\n  let expected ..= \"\u00f6\u00f2X\u00f9\u00e5\u00e8\u00fa\u00e6\u00f8'\u00f4\u00f1\u00f0\u00ee\u00ec\u00f7\u00e7\u00e9\u00e4\u00e2\u00f3\u01df\u00e3\u00eb\u00e1\u00e0\"\n  call assert_equal(expected, getline(1))\n\n  set revins& hkmap& hkmapp&\n  close!\nendfunc\n\n\" Test for 'allowrevins' and using CTRL-_ in insert mode\nfunc Test_edit_allowrevins()\n  CheckFeature rightleft\n  new\n  set allowrevins\n  call feedkeys(\"iABC\\<C-_>DEF\\<C-_>GHI\", 'xt')\n  call assert_equal('ABCFEDGHI', getline(1))\n  set allowrevins&\n  close!\nendfunc\n\n\" Test for inserting a register in insert mode using CTRL-R\nfunc Test_edit_insert_reg()\n  new\n  let g:Line = ''\n  func SaveFirstLine()\n    let g:Line = Screenline(1)\n    return 'r'\n  endfunc\n  inoremap <expr> <buffer> <F2> SaveFirstLine()\n  call test_override('redraw_flag', 1)\n  call test_override('char_avail', 1)\n  let @r = 'sample'\n  call feedkeys(\"a\\<C-R>=SaveFirstLine()\\<CR>\", \"xt\")\n  call assert_equal('\"', g:Line)\n  call test_override('ALL', 0)\n  close!\nendfunc\n\n\" When a character is inserted at the last position of the last line in a\n\" window, the window contents should be scrolled one line up. If the top line\n\" is part of a fold, then the entire fold should be scrolled up.\nfunc Test_edit_lastline_scroll()\n  new\n  let h = winheight(0)\n  let lines = ['one', 'two', 'three']\n  let lines += repeat(['vim'], h - 4)\n  call setline(1, lines)\n  call setline(h, repeat('x', winwidth(0) - 1))\n  call feedkeys(\"GAx\", 'xt')\n  redraw!\n  call assert_equal(h - 1, winline())\n  call assert_equal(2, line('w0'))\n\n  \" scroll with a fold\n  1,2fold\n  normal gg\n  call setline(h + 1, repeat('x', winwidth(0) - 1))\n  call feedkeys(\"GAx\", 'xt')\n  redraw!\n  call assert_equal(h - 1, winline())\n  call assert_equal(3, line('w0'))\n\n  close!\nendfunc\n\nfunc Test_edit_browse()\n  \" in the GUI this opens a file picker, we only test the terminal behavior\n  CheckNotGui\n\n  \" \":browse xxx\" checks for the FileExplorer augroup and assumes editing \".\"\n  \" works then.\n  augroup FileExplorer\n    au!\n  augroup END\n\n  \" When the USE_FNAME_CASE is defined this used to cause a crash.\n  browse enew\n  bwipe!\n\n  browse split\n  bwipe!\nendfunc\n\nfunc Test_read_invalid()\n  set encoding=latin1\n  \" This was not properly checking for going past the end.\n  call assert_fails('r`=', 'E484')\n  set encoding=utf-8\nendfunc\n\n\" Test for the 'revins' option\nfunc Test_edit_revins()\n  CheckFeature rightleft\n  new\n  set revins\n  exe \"normal! ione\\ttwo three\"\n  call assert_equal(\"eerht owt\\teno\", getline(1))\n  call setline(1, \"one\\ttwo three\")\n  normal! gg$bi a\n  call assert_equal(\"one\\ttwo a three\", getline(1))\n  exe \"normal! $bi\\<BS>\\<BS>\"\n  call assert_equal(\"one\\ttwo a ree\", getline(1))\n  exe \"normal! 0wi\\<C-W>\"\n  call assert_equal(\"one\\t a ree\", getline(1))\n  exe \"normal! 0wi\\<C-U>\"\n  call assert_equal(\"one\\t \", getline(1))\n  \" newline in insert mode starts at the end of the line\n  call setline(1, 'one two three')\n  exe \"normal! wi\\nfour\"\n  call assert_equal(['one two three', 'ruof'], getline(1, '$'))\n  set revins&\n  bw!\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t\t  VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = (int)vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = (int)vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * normal.c:\tContains the main routine for processing characters in command\n *\t\tmode.  Communicates closely with the code in ops.c to handle\n *\t\tthe operators.\n */\n\n#include \"vim.h\"\n\nstatic int\tVIsual_mode_orig = NUL;\t\t// saved Visual mode\n\n#ifdef FEAT_EVAL\nstatic void\tset_vcount_ca(cmdarg_T *cap, int *set_prevcount);\n#endif\nstatic int\tnv_compare(const void *s1, const void *s2);\nstatic void\tunshift_special(cmdarg_T *cap);\n#ifdef FEAT_CMDL_INFO\nstatic void\tdel_from_showcmd(int);\n#endif\n\n/*\n * nv_*(): functions called to handle Normal and Visual mode commands.\n * n_*(): functions called to handle Normal mode commands.\n * v_*(): functions called to handle Visual mode commands.\n */\nstatic void\tnv_ignore(cmdarg_T *cap);\nstatic void\tnv_nop(cmdarg_T *cap);\nstatic void\tnv_error(cmdarg_T *cap);\nstatic void\tnv_help(cmdarg_T *cap);\nstatic void\tnv_addsub(cmdarg_T *cap);\nstatic void\tnv_page(cmdarg_T *cap);\nstatic void\tnv_zet(cmdarg_T *cap);\n#ifdef FEAT_GUI\nstatic void\tnv_ver_scrollbar(cmdarg_T *cap);\nstatic void\tnv_hor_scrollbar(cmdarg_T *cap);\n#endif\n#ifdef FEAT_GUI_TABLINE\nstatic void\tnv_tabline(cmdarg_T *cap);\nstatic void\tnv_tabmenu(cmdarg_T *cap);\n#endif\nstatic void\tnv_exmode(cmdarg_T *cap);\nstatic void\tnv_colon(cmdarg_T *cap);\nstatic void\tnv_ctrlg(cmdarg_T *cap);\nstatic void\tnv_ctrlh(cmdarg_T *cap);\nstatic void\tnv_clear(cmdarg_T *cap);\nstatic void\tnv_ctrlo(cmdarg_T *cap);\nstatic void\tnv_hat(cmdarg_T *cap);\nstatic void\tnv_Zet(cmdarg_T *cap);\nstatic void\tnv_ident(cmdarg_T *cap);\nstatic void\tnv_tagpop(cmdarg_T *cap);\nstatic void\tnv_scroll(cmdarg_T *cap);\nstatic void\tnv_right(cmdarg_T *cap);\nstatic void\tnv_left(cmdarg_T *cap);\nstatic void\tnv_up(cmdarg_T *cap);\nstatic void\tnv_down(cmdarg_T *cap);\nstatic void\tnv_end(cmdarg_T *cap);\nstatic void\tnv_dollar(cmdarg_T *cap);\nstatic void\tnv_search(cmdarg_T *cap);\nstatic void\tnv_next(cmdarg_T *cap);\nstatic int\tnormal_search(cmdarg_T *cap, int dir, char_u *pat, int opt, int *wrapped);\nstatic void\tnv_csearch(cmdarg_T *cap);\nstatic void\tnv_brackets(cmdarg_T *cap);\nstatic void\tnv_percent(cmdarg_T *cap);\nstatic void\tnv_brace(cmdarg_T *cap);\nstatic void\tnv_mark(cmdarg_T *cap);\nstatic void\tnv_findpar(cmdarg_T *cap);\nstatic void\tnv_undo(cmdarg_T *cap);\nstatic void\tnv_kundo(cmdarg_T *cap);\nstatic void\tnv_Replace(cmdarg_T *cap);\nstatic void\tnv_replace(cmdarg_T *cap);\nstatic void\tnv_cursormark(cmdarg_T *cap, int flag, pos_T *pos);\nstatic void\tv_visop(cmdarg_T *cap);\nstatic void\tnv_subst(cmdarg_T *cap);\nstatic void\tnv_abbrev(cmdarg_T *cap);\nstatic void\tnv_optrans(cmdarg_T *cap);\nstatic void\tnv_gomark(cmdarg_T *cap);\nstatic void\tnv_pcmark(cmdarg_T *cap);\nstatic void\tnv_regname(cmdarg_T *cap);\nstatic void\tnv_visual(cmdarg_T *cap);\nstatic void\tn_start_visual_mode(int c);\nstatic void\tnv_window(cmdarg_T *cap);\nstatic void\tnv_suspend(cmdarg_T *cap);\nstatic void\tnv_g_cmd(cmdarg_T *cap);\nstatic void\tnv_dot(cmdarg_T *cap);\nstatic void\tnv_redo(cmdarg_T *cap);\nstatic void\tnv_Undo(cmdarg_T *cap);\nstatic void\tnv_tilde(cmdarg_T *cap);\nstatic void\tnv_operator(cmdarg_T *cap);\n#ifdef FEAT_EVAL\nstatic void\tset_op_var(int optype);\n#endif\nstatic void\tnv_lineop(cmdarg_T *cap);\nstatic void\tnv_home(cmdarg_T *cap);\nstatic void\tnv_pipe(cmdarg_T *cap);\nstatic void\tnv_bck_word(cmdarg_T *cap);\nstatic void\tnv_wordcmd(cmdarg_T *cap);\nstatic void\tnv_beginline(cmdarg_T *cap);\nstatic void\tadjust_cursor(oparg_T *oap);\nstatic void\tadjust_for_sel(cmdarg_T *cap);\nstatic void\tnv_select(cmdarg_T *cap);\nstatic void\tnv_goto(cmdarg_T *cap);\nstatic void\tnv_normal(cmdarg_T *cap);\nstatic void\tnv_esc(cmdarg_T *oap);\nstatic void\tnv_edit(cmdarg_T *cap);\nstatic void\tinvoke_edit(cmdarg_T *cap, int repl, int cmd, int startln);\n#ifdef FEAT_TEXTOBJ\nstatic void\tnv_object(cmdarg_T *cap);\n#endif\nstatic void\tnv_record(cmdarg_T *cap);\nstatic void\tnv_at(cmdarg_T *cap);\nstatic void\tnv_halfpage(cmdarg_T *cap);\nstatic void\tnv_join(cmdarg_T *cap);\nstatic void\tnv_put(cmdarg_T *cap);\nstatic void\tnv_put_opt(cmdarg_T *cap, int fix_indent);\nstatic void\tnv_open(cmdarg_T *cap);\n#ifdef FEAT_NETBEANS_INTG\nstatic void\tnv_nbcmd(cmdarg_T *cap);\n#endif\n#ifdef FEAT_DND\nstatic void\tnv_drop(cmdarg_T *cap);\n#endif\nstatic void\tnv_cursorhold(cmdarg_T *cap);\n\nstatic char *e_noident = N_(\"E349: No identifier under cursor\");\n\n/*\n * Function to be called for a Normal or Visual mode command.\n * The argument is a cmdarg_T.\n */\ntypedef void (*nv_func_T)(cmdarg_T *cap);\n\n// Values for cmd_flags.\n#define NV_NCH\t    0x01\t  // may need to get a second char\n#define NV_NCH_NOP  (0x02|NV_NCH) // get second char when no operator pending\n#define NV_NCH_ALW  (0x04|NV_NCH) // always get a second char\n#define NV_LANG\t    0x08\t// second char needs language adjustment\n\n#define NV_SS\t    0x10\t// may start selection\n#define NV_SSS\t    0x20\t// may start selection with shift modifier\n#define NV_STS\t    0x40\t// may stop selection without shift modif.\n#define NV_RL\t    0x80\t// 'rightleft' modifies command\n#define NV_KEEPREG  0x100\t// don't clear regname\n#define NV_NCW\t    0x200\t// not allowed in command-line window\n\n/*\n * Generally speaking, every Normal mode command should either clear any\n * pending operator (with *clearop*()), or set the motion type variable\n * oap->motion_type.\n *\n * When a cursor motion command is made, it is marked as being a character or\n * line oriented motion.  Then, if an operator is in effect, the operation\n * becomes character or line oriented accordingly.\n */\n\n/*\n * This table contains one entry for every Normal or Visual mode command.\n * The order doesn't matter, init_normal_cmds() will create a sorted index.\n * It is faster when all keys from zero to '~' are present.\n */\nstatic const struct nv_cmd\n{\n    int\t\tcmd_char;\t// (first) command character\n    nv_func_T   cmd_func;\t// function for this command\n    short_u\tcmd_flags;\t// NV_ flags\n    short\tcmd_arg;\t// value for ca.arg\n} nv_cmds[] =\n{\n    {NUL,\tnv_error,\t0,\t\t\t0},\n    {Ctrl_A,\tnv_addsub,\t0,\t\t\t0},\n    {Ctrl_B,\tnv_page,\tNV_STS,\t\t\tBACKWARD},\n    {Ctrl_C,\tnv_esc,\t\t0,\t\t\tTRUE},\n    {Ctrl_D,\tnv_halfpage,\t0,\t\t\t0},\n    {Ctrl_E,\tnv_scroll_line,\t0,\t\t\tTRUE},\n    {Ctrl_F,\tnv_page,\tNV_STS,\t\t\tFORWARD},\n    {Ctrl_G,\tnv_ctrlg,\t0,\t\t\t0},\n    {Ctrl_H,\tnv_ctrlh,\t0,\t\t\t0},\n    {Ctrl_I,\tnv_pcmark,\t0,\t\t\t0},\n    {NL,\tnv_down,\t0,\t\t\tFALSE},\n    {Ctrl_K,\tnv_error,\t0,\t\t\t0},\n    {Ctrl_L,\tnv_clear,\t0,\t\t\t0},\n    {CAR,\tnv_down,\t0,\t\t\tTRUE},\n    {Ctrl_N,\tnv_down,\tNV_STS,\t\t\tFALSE},\n    {Ctrl_O,\tnv_ctrlo,\t0,\t\t\t0},\n    {Ctrl_P,\tnv_up,\t\tNV_STS,\t\t\tFALSE},\n    {Ctrl_Q,\tnv_visual,\t0,\t\t\tFALSE},\n    {Ctrl_R,\tnv_redo,\t0,\t\t\t0},\n    {Ctrl_S,\tnv_ignore,\t0,\t\t\t0},\n    {Ctrl_T,\tnv_tagpop,\tNV_NCW,\t\t\t0},\n    {Ctrl_U,\tnv_halfpage,\t0,\t\t\t0},\n    {Ctrl_V,\tnv_visual,\t0,\t\t\tFALSE},\n    {'V',\tnv_visual,\t0,\t\t\tFALSE},\n    {'v',\tnv_visual,\t0,\t\t\tFALSE},\n    {Ctrl_W,\tnv_window,\t0,\t\t\t0},\n    {Ctrl_X,\tnv_addsub,\t0,\t\t\t0},\n    {Ctrl_Y,\tnv_scroll_line,\t0,\t\t\tFALSE},\n    {Ctrl_Z,\tnv_suspend,\t0,\t\t\t0},\n    {ESC,\tnv_esc,\t\t0,\t\t\tFALSE},\n    {Ctrl_BSL,\tnv_normal,\tNV_NCH_ALW,\t\t0},\n    {Ctrl_RSB,\tnv_ident,\tNV_NCW,\t\t\t0},\n    {Ctrl_HAT,\tnv_hat,\t\tNV_NCW,\t\t\t0},\n    {Ctrl__,\tnv_error,\t0,\t\t\t0},\n    {' ',\tnv_right,\t0,\t\t\t0},\n    {'!',\tnv_operator,\t0,\t\t\t0},\n    {'\"',\tnv_regname,\tNV_NCH_NOP|NV_KEEPREG,\t0},\n    {'#',\tnv_ident,\t0,\t\t\t0},\n    {'$',\tnv_dollar,\t0,\t\t\t0},\n    {'%',\tnv_percent,\t0,\t\t\t0},\n    {'&',\tnv_optrans,\t0,\t\t\t0},\n    {'\\'',\tnv_gomark,\tNV_NCH_ALW,\t\tTRUE},\n    {'(',\tnv_brace,\t0,\t\t\tBACKWARD},\n    {')',\tnv_brace,\t0,\t\t\tFORWARD},\n    {'*',\tnv_ident,\t0,\t\t\t0},\n    {'+',\tnv_down,\t0,\t\t\tTRUE},\n    {',',\tnv_csearch,\t0,\t\t\tTRUE},\n    {'-',\tnv_up,\t\t0,\t\t\tTRUE},\n    {'.',\tnv_dot,\t\tNV_KEEPREG,\t\t0},\n    {'/',\tnv_search,\t0,\t\t\tFALSE},\n    {'0',\tnv_beginline,\t0,\t\t\t0},\n    {'1',\tnv_ignore,\t0,\t\t\t0},\n    {'2',\tnv_ignore,\t0,\t\t\t0},\n    {'3',\tnv_ignore,\t0,\t\t\t0},\n    {'4',\tnv_ignore,\t0,\t\t\t0},\n    {'5',\tnv_ignore,\t0,\t\t\t0},\n    {'6',\tnv_ignore,\t0,\t\t\t0},\n    {'7',\tnv_ignore,\t0,\t\t\t0},\n    {'8',\tnv_ignore,\t0,\t\t\t0},\n    {'9',\tnv_ignore,\t0,\t\t\t0},\n    {':',\tnv_colon,\t0,\t\t\t0},\n    {';',\tnv_csearch,\t0,\t\t\tFALSE},\n    {'<',\tnv_operator,\tNV_RL,\t\t\t0},\n    {'=',\tnv_operator,\t0,\t\t\t0},\n    {'>',\tnv_operator,\tNV_RL,\t\t\t0},\n    {'?',\tnv_search,\t0,\t\t\tFALSE},\n    {'@',\tnv_at,\t\tNV_NCH_NOP,\t\tFALSE},\n    {'A',\tnv_edit,\t0,\t\t\t0},\n    {'B',\tnv_bck_word,\t0,\t\t\t1},\n    {'C',\tnv_abbrev,\tNV_KEEPREG,\t\t0},\n    {'D',\tnv_abbrev,\tNV_KEEPREG,\t\t0},\n    {'E',\tnv_wordcmd,\t0,\t\t\tTRUE},\n    {'F',\tnv_csearch,\tNV_NCH_ALW|NV_LANG,\tBACKWARD},\n    {'G',\tnv_goto,\t0,\t\t\tTRUE},\n    {'H',\tnv_scroll,\t0,\t\t\t0},\n    {'I',\tnv_edit,\t0,\t\t\t0},\n    {'J',\tnv_join,\t0,\t\t\t0},\n    {'K',\tnv_ident,\t0,\t\t\t0},\n    {'L',\tnv_scroll,\t0,\t\t\t0},\n    {'M',\tnv_scroll,\t0,\t\t\t0},\n    {'N',\tnv_next,\t0,\t\t\tSEARCH_REV},\n    {'O',\tnv_open,\t0,\t\t\t0},\n    {'P',\tnv_put,\t\t0,\t\t\t0},\n    {'Q',\tnv_exmode,\tNV_NCW,\t\t\t0},\n    {'R',\tnv_Replace,\t0,\t\t\tFALSE},\n    {'S',\tnv_subst,\tNV_KEEPREG,\t\t0},\n    {'T',\tnv_csearch,\tNV_NCH_ALW|NV_LANG,\tBACKWARD},\n    {'U',\tnv_Undo,\t0,\t\t\t0},\n    {'W',\tnv_wordcmd,\t0,\t\t\tTRUE},\n    {'X',\tnv_abbrev,\tNV_KEEPREG,\t\t0},\n    {'Y',\tnv_abbrev,\tNV_KEEPREG,\t\t0},\n    {'Z',\tnv_Zet,\t\tNV_NCH_NOP|NV_NCW,\t0},\n    {'[',\tnv_brackets,\tNV_NCH_ALW,\t\tBACKWARD},\n    {'\\\\',\tnv_error,\t0,\t\t\t0},\n    {']',\tnv_brackets,\tNV_NCH_ALW,\t\tFORWARD},\n    {'^',\tnv_beginline,\t0,\t\t\tBL_WHITE | BL_FIX},\n    {'_',\tnv_lineop,\t0,\t\t\t0},\n    {'`',\tnv_gomark,\tNV_NCH_ALW,\t\tFALSE},\n    {'a',\tnv_edit,\tNV_NCH,\t\t\t0},\n    {'b',\tnv_bck_word,\t0,\t\t\t0},\n    {'c',\tnv_operator,\t0,\t\t\t0},\n    {'d',\tnv_operator,\t0,\t\t\t0},\n    {'e',\tnv_wordcmd,\t0,\t\t\tFALSE},\n    {'f',\tnv_csearch,\tNV_NCH_ALW|NV_LANG,\tFORWARD},\n    {'g',\tnv_g_cmd,\tNV_NCH_ALW,\t\tFALSE},\n    {'h',\tnv_left,\tNV_RL,\t\t\t0},\n    {'i',\tnv_edit,\tNV_NCH,\t\t\t0},\n    {'j',\tnv_down,\t0,\t\t\tFALSE},\n    {'k',\tnv_up,\t\t0,\t\t\tFALSE},\n    {'l',\tnv_right,\tNV_RL,\t\t\t0},\n    {'m',\tnv_mark,\tNV_NCH_NOP,\t\t0},\n    {'n',\tnv_next,\t0,\t\t\t0},\n    {'o',\tnv_open,\t0,\t\t\t0},\n    {'p',\tnv_put,\t\t0,\t\t\t0},\n    {'q',\tnv_record,\tNV_NCH,\t\t\t0},\n    {'r',\tnv_replace,\tNV_NCH_NOP|NV_LANG,\t0},\n    {'s',\tnv_subst,\tNV_KEEPREG,\t\t0},\n    {'t',\tnv_csearch,\tNV_NCH_ALW|NV_LANG,\tFORWARD},\n    {'u',\tnv_undo,\t0,\t\t\t0},\n    {'w',\tnv_wordcmd,\t0,\t\t\tFALSE},\n    {'x',\tnv_abbrev,\tNV_KEEPREG,\t\t0},\n    {'y',\tnv_operator,\t0,\t\t\t0},\n    {'z',\tnv_zet,\t\tNV_NCH_ALW,\t\t0},\n    {'{',\tnv_findpar,\t0,\t\t\tBACKWARD},\n    {'|',\tnv_pipe,\t0,\t\t\t0},\n    {'}',\tnv_findpar,\t0,\t\t\tFORWARD},\n    {'~',\tnv_tilde,\t0,\t\t\t0},\n\n    // pound sign\n    {POUND,\tnv_ident,\t0,\t\t\t0},\n    {K_MOUSEUP, nv_mousescroll,\t0,\t\t\tMSCR_UP},\n    {K_MOUSEDOWN, nv_mousescroll, 0,\t\t\tMSCR_DOWN},\n    {K_MOUSELEFT, nv_mousescroll, 0,\t\t\tMSCR_LEFT},\n    {K_MOUSERIGHT, nv_mousescroll, 0,\t\t\tMSCR_RIGHT},\n    {K_LEFTMOUSE, nv_mouse,\t0,\t\t\t0},\n    {K_LEFTMOUSE_NM, nv_mouse,\t0,\t\t\t0},\n    {K_LEFTDRAG, nv_mouse,\t0,\t\t\t0},\n    {K_LEFTRELEASE, nv_mouse,\t0,\t\t\t0},\n    {K_LEFTRELEASE_NM, nv_mouse, 0,\t\t\t0},\n    {K_MOUSEMOVE, nv_mouse,\t0,\t\t\t0},\n    {K_MIDDLEMOUSE, nv_mouse,\t0,\t\t\t0},\n    {K_MIDDLEDRAG, nv_mouse,\t0,\t\t\t0},\n    {K_MIDDLERELEASE, nv_mouse,\t0,\t\t\t0},\n    {K_RIGHTMOUSE, nv_mouse,\t0,\t\t\t0},\n    {K_RIGHTDRAG, nv_mouse,\t0,\t\t\t0},\n    {K_RIGHTRELEASE, nv_mouse,\t0,\t\t\t0},\n    {K_X1MOUSE, nv_mouse,\t0,\t\t\t0},\n    {K_X1DRAG, nv_mouse,\t0,\t\t\t0},\n    {K_X1RELEASE, nv_mouse,\t0,\t\t\t0},\n    {K_X2MOUSE, nv_mouse,\t0,\t\t\t0},\n    {K_X2DRAG, nv_mouse,\t0,\t\t\t0},\n    {K_X2RELEASE, nv_mouse,\t0,\t\t\t0},\n    {K_IGNORE,\tnv_ignore,\tNV_KEEPREG,\t\t0},\n    {K_NOP,\tnv_nop,\t\t0,\t\t\t0},\n    {K_INS,\tnv_edit,\t0,\t\t\t0},\n    {K_KINS,\tnv_edit,\t0,\t\t\t0},\n    {K_BS,\tnv_ctrlh,\t0,\t\t\t0},\n    {K_UP,\tnv_up,\t\tNV_SSS|NV_STS,\t\tFALSE},\n    {K_S_UP,\tnv_page,\tNV_SS,\t\t\tBACKWARD},\n    {K_DOWN,\tnv_down,\tNV_SSS|NV_STS,\t\tFALSE},\n    {K_S_DOWN,\tnv_page,\tNV_SS,\t\t\tFORWARD},\n    {K_LEFT,\tnv_left,\tNV_SSS|NV_STS|NV_RL,\t0},\n    {K_S_LEFT,\tnv_bck_word,\tNV_SS|NV_RL,\t\t0},\n    {K_C_LEFT,\tnv_bck_word,\tNV_SSS|NV_RL|NV_STS,\t1},\n    {K_RIGHT,\tnv_right,\tNV_SSS|NV_STS|NV_RL,\t0},\n    {K_S_RIGHT,\tnv_wordcmd,\tNV_SS|NV_RL,\t\tFALSE},\n    {K_C_RIGHT,\tnv_wordcmd,\tNV_SSS|NV_RL|NV_STS,\tTRUE},\n    {K_PAGEUP,\tnv_page,\tNV_SSS|NV_STS,\t\tBACKWARD},\n    {K_KPAGEUP,\tnv_page,\tNV_SSS|NV_STS,\t\tBACKWARD},\n    {K_PAGEDOWN, nv_page,\tNV_SSS|NV_STS,\t\tFORWARD},\n    {K_KPAGEDOWN, nv_page,\tNV_SSS|NV_STS,\t\tFORWARD},\n    {K_END,\tnv_end,\t\tNV_SSS|NV_STS,\t\tFALSE},\n    {K_KEND,\tnv_end,\t\tNV_SSS|NV_STS,\t\tFALSE},\n    {K_S_END,\tnv_end,\t\tNV_SS,\t\t\tFALSE},\n    {K_C_END,\tnv_end,\t\tNV_SSS|NV_STS,\t\tTRUE},\n    {K_HOME,\tnv_home,\tNV_SSS|NV_STS,\t\t0},\n    {K_KHOME,\tnv_home,\tNV_SSS|NV_STS,\t\t0},\n    {K_S_HOME,\tnv_home,\tNV_SS,\t\t\t0},\n    {K_C_HOME,\tnv_goto,\tNV_SSS|NV_STS,\t\tFALSE},\n    {K_DEL,\tnv_abbrev,\t0,\t\t\t0},\n    {K_KDEL,\tnv_abbrev,\t0,\t\t\t0},\n    {K_UNDO,\tnv_kundo,\t0,\t\t\t0},\n    {K_HELP,\tnv_help,\tNV_NCW,\t\t\t0},\n    {K_F1,\tnv_help,\tNV_NCW,\t\t\t0},\n    {K_XF1,\tnv_help,\tNV_NCW,\t\t\t0},\n    {K_SELECT,\tnv_select,\t0,\t\t\t0},\n#ifdef FEAT_GUI\n    {K_VER_SCROLLBAR, nv_ver_scrollbar, 0,\t\t0},\n    {K_HOR_SCROLLBAR, nv_hor_scrollbar, 0,\t\t0},\n#endif\n#ifdef FEAT_GUI_TABLINE\n    {K_TABLINE, nv_tabline,\t0,\t\t\t0},\n    {K_TABMENU, nv_tabmenu,\t0,\t\t\t0},\n#endif\n#ifdef FEAT_NETBEANS_INTG\n    {K_F21,\tnv_nbcmd,\tNV_NCH_ALW,\t\t0},\n#endif\n#ifdef FEAT_DND\n    {K_DROP,\tnv_drop,\tNV_STS,\t\t\t0},\n#endif\n    {K_CURSORHOLD, nv_cursorhold, NV_KEEPREG,\t\t0},\n    {K_PS,\tnv_edit,\t0,\t\t\t0},\n    {K_COMMAND,\tnv_colon,\t0,\t\t\t0},\n};\n\n// Number of commands in nv_cmds[].\n#define NV_CMDS_SIZE ARRAY_LENGTH(nv_cmds)\n\n// Sorted index of commands in nv_cmds[].\nstatic short nv_cmd_idx[NV_CMDS_SIZE];\n\n// The highest index for which\n// nv_cmds[idx].cmd_char == nv_cmd_idx[nv_cmds[idx].cmd_char]\nstatic int nv_max_linear;\n\n/*\n * Compare functions for qsort() below, that checks the command character\n * through the index in nv_cmd_idx[].\n */\n    static int\nnv_compare(const void *s1, const void *s2)\n{\n    int\t\tc1, c2;\n\n    // The commands are sorted on absolute value.\n    c1 = nv_cmds[*(const short *)s1].cmd_char;\n    c2 = nv_cmds[*(const short *)s2].cmd_char;\n    if (c1 < 0)\n\tc1 = -c1;\n    if (c2 < 0)\n\tc2 = -c2;\n    return c1 - c2;\n}\n\n/*\n * Initialize the nv_cmd_idx[] table.\n */\n    void\ninit_normal_cmds(void)\n{\n    int\t\ti;\n\n    // Fill the index table with a one to one relation.\n    for (i = 0; i < (int)NV_CMDS_SIZE; ++i)\n\tnv_cmd_idx[i] = i;\n\n    // Sort the commands by the command character.\n    qsort((void *)&nv_cmd_idx, (size_t)NV_CMDS_SIZE, sizeof(short), nv_compare);\n\n    // Find the first entry that can't be indexed by the command character.\n    for (i = 0; i < (int)NV_CMDS_SIZE; ++i)\n\tif (i != nv_cmds[nv_cmd_idx[i]].cmd_char)\n\t    break;\n    nv_max_linear = i - 1;\n}\n\n/*\n * Search for a command in the commands table.\n * Returns -1 for invalid command.\n */\n    static int\nfind_command(int cmdchar)\n{\n    int\t\ti;\n    int\t\tidx;\n    int\t\ttop, bot;\n    int\t\tc;\n\n    // A multi-byte character is never a command.\n    if (cmdchar >= 0x100)\n\treturn -1;\n\n    // We use the absolute value of the character.  Special keys have a\n    // negative value, but are sorted on their absolute value.\n    if (cmdchar < 0)\n\tcmdchar = -cmdchar;\n\n    // If the character is in the first part: The character is the index into\n    // nv_cmd_idx[].\n    if (cmdchar <= nv_max_linear)\n\treturn nv_cmd_idx[cmdchar];\n\n    // Perform a binary search.\n    bot = nv_max_linear + 1;\n    top = NV_CMDS_SIZE - 1;\n    idx = -1;\n    while (bot <= top)\n    {\n\ti = (top + bot) / 2;\n\tc = nv_cmds[nv_cmd_idx[i]].cmd_char;\n\tif (c < 0)\n\t    c = -c;\n\tif (cmdchar == c)\n\t{\n\t    idx = nv_cmd_idx[i];\n\t    break;\n\t}\n\tif (cmdchar > c)\n\t    bot = i + 1;\n\telse\n\t    top = i - 1;\n    }\n    return idx;\n}\n\n/*\n * Execute a command in Normal mode.\n */\n    void\nnormal_cmd(\n    oparg_T\t*oap,\n    int\t\ttoplevel UNUSED)\t// TRUE when called from main()\n{\n    cmdarg_T\tca;\t\t\t// command arguments\n    int\t\tc;\n    int\t\tctrl_w = FALSE;\t\t// got CTRL-W command\n    int\t\told_col = curwin->w_curswant;\n#ifdef FEAT_CMDL_INFO\n    int\t\tneed_flushbuf;\t\t// need to call out_flush()\n#endif\n    pos_T\told_pos;\t\t// cursor position before command\n    int\t\tmapped_len;\n    static int\told_mapped_len = 0;\n    int\t\tidx;\n#ifdef FEAT_EVAL\n    int\t\tset_prevcount = FALSE;\n#endif\n    int\t\tsave_did_cursorhold = did_cursorhold;\n\n    CLEAR_FIELD(ca);\t// also resets ca.retval\n    ca.oap = oap;\n\n    // Use a count remembered from before entering an operator.  After typing\n    // \"3d\" we return from normal_cmd() and come back here, the \"3\" is\n    // remembered in \"opcount\".\n    ca.opcount = opcount;\n\n    /*\n     * If there is an operator pending, then the command we take this time\n     * will terminate it. Finish_op tells us to finish the operation before\n     * returning this time (unless the operation was cancelled).\n     */\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = (oap->op_type != OP_NOP);\n#ifdef CURSOR_SHAPE\n    if (finish_op != c)\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n\n    // When not finishing an operator and no register name typed, reset the\n    // count.\n    if (!finish_op && !oap->regname)\n    {\n\tca.opcount = 0;\n#ifdef FEAT_EVAL\n\tset_prevcount = TRUE;\n#endif\n    }\n\n    // Restore counts from before receiving K_CURSORHOLD.  This means after\n    // typing \"3\", handling K_CURSORHOLD and then typing \"2\" we get \"32\", not\n    // \"3 * 2\".\n    if (oap->prev_opcount > 0 || oap->prev_count0 > 0)\n    {\n\tca.opcount = oap->prev_opcount;\n\tca.count0 = oap->prev_count0;\n\toap->prev_opcount = 0;\n\toap->prev_count0 = 0;\n    }\n\n    mapped_len = typebuf_maplen();\n\n    State = NORMAL_BUSY;\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = FALSE;\t// allow scrolling here\n#endif\n\n#ifdef FEAT_EVAL\n    // Set v:count here, when called from main() and not a stuffed\n    // command, so that v:count can be used in an expression mapping\n    // when there is no count. Do set it for redo.\n    if (toplevel && readbuf1_empty())\n\tset_vcount_ca(&ca, &set_prevcount);\n#endif\n\n    /*\n     * Get the command character from the user.\n     */\n    c = safe_vgetc();\n    LANGMAP_ADJUST(c, get_real_state() != SELECTMODE);\n\n    /*\n     * If a mapping was started in Visual or Select mode, remember the length\n     * of the mapping.  This is used below to not return to Insert mode for as\n     * long as the mapping is being executed.\n     */\n    if (restart_edit == 0)\n\told_mapped_len = 0;\n    else if (old_mapped_len\n\t\t|| (VIsual_active && mapped_len == 0 && typebuf_maplen() > 0))\n\told_mapped_len = typebuf_maplen();\n\n    if (c == NUL)\n\tc = K_ZERO;\n\n    /*\n     * In Select mode, typed text replaces the selection.\n     */\n    if (VIsual_active\n\t    && VIsual_select\n\t    && (vim_isprintc(c) || c == NL || c == CAR || c == K_KENTER))\n    {\n\t// Fake a \"c\"hange command.  When \"restart_edit\" is set (e.g., because\n\t// 'insertmode' is set) fake a \"d\"elete command, Insert mode will\n\t// restart automatically.\n\t// Insert the typed character in the typeahead buffer, so that it can\n\t// be mapped in Insert mode.  Required for \":lmap\" to work.\n\tins_char_typebuf(vgetc_char, vgetc_mod_mask);\n\tif (restart_edit != 0)\n\t    c = 'd';\n\telse\n\t    c = 'c';\n\tmsg_nowait = TRUE;\t// don't delay going to insert mode\n\told_mapped_len = 0;\t// do go to Insert mode\n    }\n\n#ifdef FEAT_CMDL_INFO\n    need_flushbuf = add_to_showcmd(c);\n#endif\n\ngetcount:\n    if (!(VIsual_active && VIsual_select))\n    {\n\t/*\n\t * Handle a count before a command and compute ca.count0.\n\t * Note that '0' is a command and not the start of a count, but it's\n\t * part of a count after other digits.\n\t */\n\twhile (    (c >= '1' && c <= '9')\n\t\t|| (ca.count0 != 0 && (c == K_DEL || c == K_KDEL || c == '0')))\n\t{\n\t    if (c == K_DEL || c == K_KDEL)\n\t    {\n\t\tca.count0 /= 10;\n#ifdef FEAT_CMDL_INFO\n\t\tdel_from_showcmd(4);\t// delete the digit and ~@%\n#endif\n\t    }\n\t    else\n\t\tca.count0 = ca.count0 * 10 + (c - '0');\n\t    if (ca.count0 < 0)\t    // overflow\n\t\tca.count0 = 999999999L;\n#ifdef FEAT_EVAL\n\t    // Set v:count here, when called from main() and not a stuffed\n\t    // command, so that v:count can be used in an expression mapping\n\t    // right after the count. Do set it for redo.\n\t    if (toplevel && readbuf1_empty())\n\t\tset_vcount_ca(&ca, &set_prevcount);\n#endif\n\t    if (ctrl_w)\n\t    {\n\t\t++no_mapping;\n\t\t++allow_keys;\t\t// no mapping for nchar, but keys\n\t    }\n\t    ++no_zero_mapping;\t\t// don't map zero here\n\t    c = plain_vgetc();\n\t    LANGMAP_ADJUST(c, TRUE);\n\t    --no_zero_mapping;\n\t    if (ctrl_w)\n\t    {\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t    }\n#ifdef FEAT_CMDL_INFO\n\t    need_flushbuf |= add_to_showcmd(c);\n#endif\n\t}\n\n\t/*\n\t * If we got CTRL-W there may be a/another count\n\t */\n\tif (c == Ctrl_W && !ctrl_w && oap->op_type == OP_NOP)\n\t{\n\t    ctrl_w = TRUE;\n\t    ca.opcount = ca.count0;\t// remember first count\n\t    ca.count0 = 0;\n\t    ++no_mapping;\n\t    ++allow_keys;\t\t// no mapping for nchar, but keys\n\t    c = plain_vgetc();\t\t// get next character\n\t    LANGMAP_ADJUST(c, TRUE);\n\t    --no_mapping;\n\t    --allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t    need_flushbuf |= add_to_showcmd(c);\n#endif\n\t    goto getcount;\t\t// jump back\n\t}\n    }\n\n    if (c == K_CURSORHOLD)\n    {\n\t// Save the count values so that ca.opcount and ca.count0 are exactly\n\t// the same when coming back here after handling K_CURSORHOLD.\n\toap->prev_opcount = ca.opcount;\n\toap->prev_count0 = ca.count0;\n    }\n    else if (ca.opcount != 0)\n    {\n\t/*\n\t * If we're in the middle of an operator (including after entering a\n\t * yank buffer with '\"') AND we had a count before the operator, then\n\t * that count overrides the current value of ca.count0.\n\t * What this means effectively, is that commands like \"3dw\" get turned\n\t * into \"d3w\" which makes things fall into place pretty neatly.\n\t * If you give a count before AND after the operator, they are\n\t * multiplied.\n\t */\n\tif (ca.count0)\n\t    ca.count0 *= ca.opcount;\n\telse\n\t    ca.count0 = ca.opcount;\n\tif (ca.count0 < 0)\t    // overflow\n\t    ca.count0 = 999999999L;\n    }\n\n    /*\n     * Always remember the count.  It will be set to zero (on the next call,\n     * above) when there is no pending operator.\n     * When called from main(), save the count for use by the \"count\" built-in\n     * variable.\n     */\n    ca.opcount = ca.count0;\n    ca.count1 = (ca.count0 == 0 ? 1 : ca.count0);\n\n#ifdef FEAT_EVAL\n    /*\n     * Only set v:count when called from main() and not a stuffed command.\n     * Do set it for redo.\n     */\n    if (toplevel && readbuf1_empty())\n\tset_vcount(ca.count0, ca.count1, set_prevcount);\n#endif\n\n    /*\n     * Find the command character in the table of commands.\n     * For CTRL-W we already got nchar when looking for a count.\n     */\n    if (ctrl_w)\n    {\n\tca.nchar = c;\n\tca.cmdchar = Ctrl_W;\n    }\n    else\n\tca.cmdchar = c;\n    idx = find_command(ca.cmdchar);\n    if (idx < 0)\n    {\n\t// Not a known command: beep.\n\tclearopbeep(oap);\n\tgoto normal_end;\n    }\n\n    if (text_locked() && (nv_cmds[idx].cmd_flags & NV_NCW))\n    {\n\t// This command is not allowed while editing a cmdline: beep.\n\tclearopbeep(oap);\n\ttext_locked_msg();\n\tgoto normal_end;\n    }\n    if ((nv_cmds[idx].cmd_flags & NV_NCW) && curbuf_locked())\n\tgoto normal_end;\n\n    /*\n     * In Visual/Select mode, a few keys are handled in a special way.\n     */\n    if (VIsual_active)\n    {\n\t// when 'keymodel' contains \"stopsel\" may stop Select/Visual mode\n\tif (km_stopsel\n\t\t&& (nv_cmds[idx].cmd_flags & NV_STS)\n\t\t&& !(mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    end_visual_mode();\n\t    redraw_curbuf_later(INVERTED);\n\t}\n\n\t// Keys that work different when 'keymodel' contains \"startsel\"\n\tif (km_startsel)\n\t{\n\t    if (nv_cmds[idx].cmd_flags & NV_SS)\n\t    {\n\t\tunshift_special(&ca);\n\t\tidx = find_command(ca.cmdchar);\n\t\tif (idx < 0)\n\t\t{\n\t\t    // Just in case\n\t\t    clearopbeep(oap);\n\t\t    goto normal_end;\n\t\t}\n\t    }\n\t    else if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t       && (mod_mask & MOD_MASK_SHIFT))\n\t\tmod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && KeyTyped && !KeyStuffed\n\t\t\t\t\t  && (nv_cmds[idx].cmd_flags & NV_RL))\n    {\n\t// Invert horizontal movements and operations.  Only when typed by the\n\t// user directly, not when the result of a mapping or \"x\" translated\n\t// to \"dl\".\n\tswitch (ca.cmdchar)\n\t{\n\t    case 'l':\t    ca.cmdchar = 'h'; break;\n\t    case K_RIGHT:   ca.cmdchar = K_LEFT; break;\n\t    case K_S_RIGHT: ca.cmdchar = K_S_LEFT; break;\n\t    case K_C_RIGHT: ca.cmdchar = K_C_LEFT; break;\n\t    case 'h':\t    ca.cmdchar = 'l'; break;\n\t    case K_LEFT:    ca.cmdchar = K_RIGHT; break;\n\t    case K_S_LEFT:  ca.cmdchar = K_S_RIGHT; break;\n\t    case K_C_LEFT:  ca.cmdchar = K_C_RIGHT; break;\n\t    case '>':\t    ca.cmdchar = '<'; break;\n\t    case '<':\t    ca.cmdchar = '>'; break;\n\t}\n\tidx = find_command(ca.cmdchar);\n    }\n#endif\n\n    /*\n     * Get an additional character if we need one.\n     */\n    if ((nv_cmds[idx].cmd_flags & NV_NCH)\n\t    && (((nv_cmds[idx].cmd_flags & NV_NCH_NOP) == NV_NCH_NOP\n\t\t    && oap->op_type == OP_NOP)\n\t\t|| (nv_cmds[idx].cmd_flags & NV_NCH_ALW) == NV_NCH_ALW\n\t\t|| (ca.cmdchar == 'q'\n\t\t    && oap->op_type == OP_NOP\n\t\t    && reg_recording == 0\n\t\t    && reg_executing == 0)\n\t\t|| ((ca.cmdchar == 'a' || ca.cmdchar == 'i')\n\t\t    && (oap->op_type != OP_NOP || VIsual_active))))\n    {\n\tint\t*cp;\n\tint\trepl = FALSE;\t// get character for replace mode\n\tint\tlit = FALSE;\t// get extra character literally\n\tint\tlangmap_active = FALSE;    // using :lmap mappings\n\tint\tlang;\t\t// getting a text character\n#ifdef HAVE_INPUT_METHOD\n\tint\tsave_smd;\t// saved value of p_smd\n#endif\n\n\t++no_mapping;\n\t++allow_keys;\t\t// no mapping for nchar, but allow key codes\n\t// Don't generate a CursorHold event here, most commands can't handle\n\t// it, e.g., nv_replace(), nv_csearch().\n\tdid_cursorhold = TRUE;\n\tif (ca.cmdchar == 'g')\n\t{\n\t    /*\n\t     * For 'g' get the next character now, so that we can check for\n\t     * \"gr\", \"g'\" and \"g`\".\n\t     */\n\t    ca.nchar = plain_vgetc();\n\t    LANGMAP_ADJUST(ca.nchar, TRUE);\n#ifdef FEAT_CMDL_INFO\n\t    need_flushbuf |= add_to_showcmd(ca.nchar);\n#endif\n\t    if (ca.nchar == 'r' || ca.nchar == '\\'' || ca.nchar == '`'\n\t\t\t\t\t\t       || ca.nchar == Ctrl_BSL)\n\t    {\n\t\tcp = &ca.extra_char;\t// need to get a third character\n\t\tif (ca.nchar != 'r')\n\t\t    lit = TRUE;\t\t\t// get it literally\n\t\telse\n\t\t    repl = TRUE;\t\t// get it in replace mode\n\t    }\n\t    else\n\t\tcp = NULL;\t\t// no third character needed\n\t}\n\telse\n\t{\n\t    if (ca.cmdchar == 'r')\t\t// get it in replace mode\n\t\trepl = TRUE;\n\t    cp = &ca.nchar;\n\t}\n\tlang = (repl || (nv_cmds[idx].cmd_flags & NV_LANG));\n\n\t/*\n\t * Get a second or third character.\n\t */\n\tif (cp != NULL)\n\t{\n\t    if (repl)\n\t    {\n\t\tState = REPLACE;\t// pretend Replace mode\n#ifdef CURSOR_SHAPE\n\t\tui_cursor_shape();\t// show different cursor shape\n#endif\n\t    }\n\t    if (lang && curbuf->b_p_iminsert == B_IMODE_LMAP)\n\t    {\n\t\t// Allow mappings defined with \":lmap\".\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t\tif (repl)\n\t\t    State = LREPLACE;\n\t\telse\n\t\t    State = LANGMAP;\n\t\tlangmap_active = TRUE;\n\t    }\n#ifdef HAVE_INPUT_METHOD\n\t    save_smd = p_smd;\n\t    p_smd = FALSE;\t// Don't let the IM code show the mode here\n\t    if (lang && curbuf->b_p_iminsert == B_IMODE_IM)\n\t\tim_set_active(TRUE);\n#endif\n\t    if ((State & INSERT) && !p_ek)\n\t    {\n#ifdef FEAT_JOB_CHANNEL\n\t\tch_log_output = TRUE;\n#endif\n\t\t// Disable bracketed paste and modifyOtherKeys here, we won't\n\t\t// recognize the escape sequences with 'esckeys' off.\n\t\tout_str(T_BD);\n\t\tout_str(T_CTE);\n\t    }\n\n\t    *cp = plain_vgetc();\n\n\t    if ((State & INSERT) && !p_ek)\n\t    {\n#ifdef FEAT_JOB_CHANNEL\n\t\tch_log_output = TRUE;\n#endif\n\t\t// Re-enable bracketed paste mode and modifyOtherKeys\n\t\tout_str(T_BE);\n\t\tout_str(T_CTI);\n\t    }\n\n\t    if (langmap_active)\n\t    {\n\t\t// Undo the decrement done above\n\t\t++no_mapping;\n\t\t++allow_keys;\n\t\tState = NORMAL_BUSY;\n\t    }\n#ifdef HAVE_INPUT_METHOD\n\t    if (lang)\n\t    {\n\t\tif (curbuf->b_p_iminsert != B_IMODE_LMAP)\n\t\t    im_save_status(&curbuf->b_p_iminsert);\n\t\tim_set_active(FALSE);\n\t    }\n\t    p_smd = save_smd;\n#endif\n\t    State = NORMAL_BUSY;\n#ifdef FEAT_CMDL_INFO\n\t    need_flushbuf |= add_to_showcmd(*cp);\n#endif\n\n\t    if (!lit)\n\t    {\n#ifdef FEAT_DIGRAPHS\n\t\t// Typing CTRL-K gets a digraph.\n\t\tif (*cp == Ctrl_K\n\t\t\t&& ((nv_cmds[idx].cmd_flags & NV_LANG)\n\t\t\t    || cp == &ca.extra_char)\n\t\t\t&& vim_strchr(p_cpo, CPO_DIGRAPH) == NULL)\n\t\t{\n\t\t    c = get_digraph(FALSE);\n\t\t    if (c > 0)\n\t\t    {\n\t\t\t*cp = c;\n# ifdef FEAT_CMDL_INFO\n\t\t\t// Guessing how to update showcmd here...\n\t\t\tdel_from_showcmd(3);\n\t\t\tneed_flushbuf |= add_to_showcmd(*cp);\n# endif\n\t\t    }\n\t\t}\n#endif\n\n\t\t// adjust chars > 127, except after \"tTfFr\" commands\n\t\tLANGMAP_ADJUST(*cp, !lang);\n#ifdef FEAT_RIGHTLEFT\n\t\t// adjust Hebrew mapped char\n\t\tif (p_hkmap && lang && KeyTyped)\n\t\t    *cp = hkmap(*cp);\n#endif\n\t    }\n\n\t    /*\n\t     * When the next character is CTRL-\\ a following CTRL-N means the\n\t     * command is aborted and we go to Normal mode.\n\t     */\n\t    if (cp == &ca.extra_char\n\t\t    && ca.nchar == Ctrl_BSL\n\t\t    && (ca.extra_char == Ctrl_N || ca.extra_char == Ctrl_G))\n\t    {\n\t\tca.cmdchar = Ctrl_BSL;\n\t\tca.nchar = ca.extra_char;\n\t\tidx = find_command(ca.cmdchar);\n\t    }\n\t    else if ((ca.nchar == 'n' || ca.nchar == 'N') && ca.cmdchar == 'g')\n\t\tca.oap->op_type = get_op_type(*cp, NUL);\n\t    else if (*cp == Ctrl_BSL)\n\t    {\n\t\tlong towait = (p_ttm >= 0 ? p_ttm : p_tm);\n\n\t\t// There is a busy wait here when typing \"f<C-\\>\" and then\n\t\t// something different from CTRL-N.  Can't be avoided.\n\t\twhile ((c = vpeekc()) <= 0 && towait > 0L)\n\t\t{\n\t\t    do_sleep(towait > 50L ? 50L : towait, FALSE);\n\t\t    towait -= 50L;\n\t\t}\n\t\tif (c > 0)\n\t\t{\n\t\t    c = plain_vgetc();\n\t\t    if (c != Ctrl_N && c != Ctrl_G)\n\t\t\tvungetc(c);\n\t\t    else\n\t\t    {\n\t\t\tca.cmdchar = Ctrl_BSL;\n\t\t\tca.nchar = c;\n\t\t\tidx = find_command(ca.cmdchar);\n\t\t    }\n\t\t}\n\t    }\n\n\t    // When getting a text character and the next character is a\n\t    // multi-byte character, it could be a composing character.\n\t    // However, don't wait for it to arrive. Also, do enable mapping,\n\t    // because if it's put back with vungetc() it's too late to apply\n\t    // mapping.\n\t    --no_mapping;\n\t    while (enc_utf8 && lang && (c = vpeekc()) > 0\n\t\t\t\t && (c >= 0x100 || MB_BYTE2LEN(vpeekc()) > 1))\n\t    {\n\t\tc = plain_vgetc();\n\t\tif (!utf_iscomposing(c))\n\t\t{\n\t\t    vungetc(c);\t\t// it wasn't, put it back\n\t\t    break;\n\t\t}\n\t\telse if (ca.ncharC1 == 0)\n\t\t    ca.ncharC1 = c;\n\t\telse\n\t\t    ca.ncharC2 = c;\n\t    }\n\t    ++no_mapping;\n\t}\n\t--no_mapping;\n\t--allow_keys;\n    }\n\n#ifdef FEAT_CMDL_INFO\n    /*\n     * Flush the showcmd characters onto the screen so we can see them while\n     * the command is being executed.  Only do this when the shown command was\n     * actually displayed, otherwise this will slow down a lot when executing\n     * mappings.\n     */\n    if (need_flushbuf)\n\tout_flush();\n#endif\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tif (ex_normal_busy)\n\t    did_cursorhold = save_did_cursorhold;\n\telse\n\t    did_cursorhold = FALSE;\n    }\n\n    State = NORMAL;\n\n    if (ca.nchar == ESC)\n    {\n\tclearop(oap);\n\tif (restart_edit == 0 && goto_im())\n\t    restart_edit = 'a';\n\tgoto normal_end;\n    }\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tmsg_didout = FALSE;    // don't scroll screen up for normal command\n\tmsg_col = 0;\n    }\n\n    old_pos = curwin->w_cursor;\t\t// remember where cursor was\n\n    // When 'keymodel' contains \"startsel\" some keys start Select/Visual\n    // mode.\n    if (!VIsual_active && km_startsel)\n    {\n\tif (nv_cmds[idx].cmd_flags & NV_SS)\n\t{\n\t    start_selection();\n\t    unshift_special(&ca);\n\t    idx = find_command(ca.cmdchar);\n\t}\n\telse if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t   && (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    start_selection();\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    /*\n     * Execute the command!\n     * Call the command function found in the commands table.\n     */\n    ca.arg = nv_cmds[idx].cmd_arg;\n    (nv_cmds[idx].cmd_func)(&ca);\n\n    /*\n     * If we didn't start or finish an operator, reset oap->regname, unless we\n     * need it later.\n     */\n    if (!finish_op\n\t    && !oap->op_type\n\t    && (idx < 0 || !(nv_cmds[idx].cmd_flags & NV_KEEPREG)))\n    {\n\tclearop(oap);\n#ifdef FEAT_EVAL\n\treset_reg_var();\n#endif\n    }\n\n    // Get the length of mapped chars again after typing a count, second\n    // character or \"z333<cr>\".\n    if (old_mapped_len > 0)\n\told_mapped_len = typebuf_maplen();\n\n    /*\n     * If an operation is pending, handle it.  But not for K_IGNORE or\n     * K_MOUSEMOVE.\n     */\n    if (ca.cmdchar != K_IGNORE && ca.cmdchar != K_MOUSEMOVE)\n\tdo_pending_operator(&ca, old_col, FALSE);\n\n    /*\n     * Wait for a moment when a message is displayed that will be overwritten\n     * by the mode message.\n     * In Visual mode and with \"^O\" in Insert mode, a short message will be\n     * overwritten by the mode message.  Wait a bit, until a key is hit.\n     * In Visual mode, it's more important to keep the Visual area updated\n     * than keeping a message (e.g. from a /pat search).\n     * Only do this if the command was typed, not from a mapping.\n     * Don't wait when emsg_silent is non-zero.\n     * Also wait a bit after an error message, e.g. for \"^O:\".\n     * Don't redraw the screen, it would remove the message.\n     */\n    if (       ((p_smd\n\t\t    && msg_silent == 0\n\t\t    && (restart_edit != 0\n\t\t\t|| (VIsual_active\n\t\t\t    && old_pos.lnum == curwin->w_cursor.lnum\n\t\t\t    && old_pos.col == curwin->w_cursor.col)\n\t\t       )\n\t\t    && (clear_cmdline\n\t\t\t|| redraw_cmdline)\n\t\t    && (msg_didout || (msg_didany && msg_scroll))\n\t\t    && !msg_nowait\n\t\t    && KeyTyped)\n\t\t|| (restart_edit != 0\n\t\t    && !VIsual_active\n\t\t    && (msg_scroll\n\t\t\t|| emsg_on_display)))\n\t    && oap->regname == 0\n\t    && !(ca.retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && typebuf_typed()\n\t    && emsg_silent == 0\n\t    && !in_assert_fails\n\t    && !did_wait_return\n\t    && oap->op_type == OP_NOP)\n    {\n\tint\tsave_State = State;\n\n\t// Draw the cursor with the right shape here\n\tif (restart_edit != 0)\n\t    State = INSERT;\n\n\t// If need to redraw, and there is a \"keep_msg\", redraw before the\n\t// delay\n\tif (must_redraw && keep_msg != NULL && !emsg_on_display)\n\t{\n\t    char_u\t*kmsg;\n\n\t    kmsg = keep_msg;\n\t    keep_msg = NULL;\n\t    // Showmode() will clear keep_msg, but we want to use it anyway.\n\t    // First update w_topline.\n\t    setcursor();\n\t    update_screen(0);\n\t    // now reset it, otherwise it's put in the history again\n\t    keep_msg = kmsg;\n\n\t    kmsg = vim_strsave(keep_msg);\n\t    if (kmsg != NULL)\n\t    {\n\t\tmsg_attr((char *)kmsg, keep_msg_attr);\n\t\tvim_free(kmsg);\n\t    }\n\t}\n\tsetcursor();\n#ifdef CURSOR_SHAPE\n\tui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\tcursor_on();\n\tout_flush();\n\tif (msg_scroll || emsg_on_display)\n\t    ui_delay(1003L, TRUE);\t// wait at least one second\n\tui_delay(3003L, FALSE);\t\t// wait up to three seconds\n\tState = save_State;\n\n\tmsg_scroll = FALSE;\n\temsg_on_display = FALSE;\n    }\n\n    /*\n     * Finish up after executing a Normal mode command.\n     */\nnormal_end:\n\n    msg_nowait = FALSE;\n\n#ifdef FEAT_EVAL\n    if (finish_op)\n\treset_reg_var();\n#endif\n\n    // Reset finish_op, in case it was set\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = FALSE;\n#ifdef CURSOR_SHAPE\n    // Redraw the cursor with another shape, if we were in Operator-pending\n    // mode or did a replace command.\n    if (c || ca.cmdchar == 'r')\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n\n#ifdef FEAT_CMDL_INFO\n    if (oap->op_type == OP_NOP && oap->regname == 0\n\t    && ca.cmdchar != K_CURSORHOLD)\n\tclear_showcmd();\n#endif\n\n    checkpcmark();\t\t// check if we moved since setting pcmark\n    vim_free(ca.searchbuf);\n\n    if (has_mbyte)\n\tmb_adjust_cursor();\n\n    if (curwin->w_p_scb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_scrollbind(TRUE);\n    }\n\n    if (curwin->w_p_crb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_cursorbind();\n    }\n\n#ifdef FEAT_TERMINAL\n    // don't go to Insert mode if a terminal has a running job\n    if (term_job_running(curbuf->b_term))\n\trestart_edit = 0;\n#endif\n\n    /*\n     * May restart edit(), if we got here with CTRL-O in Insert mode (but not\n     * if still inside a mapping that started in Visual mode).\n     * May switch from Visual to Select mode after CTRL-O command.\n     */\n    if (       oap->op_type == OP_NOP\n\t    && ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t\t|| restart_VIsual_select == 1)\n\t    && !(ca.retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && oap->regname == 0)\n    {\n\tif (restart_VIsual_select == 1)\n\t{\n\t    VIsual_select = TRUE;\n\t    showmode();\n\t    restart_VIsual_select = 0;\n\t}\n\tif (restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t    (void)edit(restart_edit, FALSE, 1L);\n    }\n\n    if (restart_VIsual_select == 2)\n\trestart_VIsual_select = 1;\n\n    // Save count before an operator for next time.\n    opcount = ca.opcount;\n}\n\n#ifdef FEAT_EVAL\n/*\n * Set v:count and v:count1 according to \"cap\".\n * Set v:prevcount only when \"set_prevcount\" is TRUE.\n */\n    static void\nset_vcount_ca(cmdarg_T *cap, int *set_prevcount)\n{\n    long count = cap->count0;\n\n    // multiply with cap->opcount the same way as above\n    if (cap->opcount != 0)\n\tcount = cap->opcount * (count == 0 ? 1 : count);\n    set_vcount(count, count == 0 ? 1 : count, *set_prevcount);\n    *set_prevcount = FALSE;  // only set v:prevcount once\n}\n#endif\n\n/*\n * Check if highlighting for Visual mode is possible, give a warning message\n * if not.\n */\n    void\ncheck_visual_highlight(void)\n{\n    static int\t    did_check = FALSE;\n\n    if (full_screen)\n    {\n\tif (!did_check && HL_ATTR(HLF_V) == 0)\n\t    msg(_(\"Warning: terminal cannot highlight\"));\n\tdid_check = TRUE;\n    }\n}\n\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_EVAL)\n/*\n * Call yank_do_autocmd() for \"regname\".\n */\n    static void\ncall_yank_do_autocmd(int regname)\n{\n    oparg_T\toa;\n    yankreg_T\t*reg;\n\n    clear_oparg(&oa);\n    oa.regname = regname;\n    oa.op_type = OP_YANK;\n    oa.is_VIsual = TRUE;\n    reg = get_register(regname, TRUE);\n    yank_do_autocmd(&oa, reg);\n    free_register(reg);\n}\n#endif\n\n/*\n * End Visual mode.\n * This function or the next should ALWAYS be called to end Visual mode, except\n * from do_pending_operator().\n */\n    void\nend_visual_mode()\n{\n    end_visual_mode_keep_button();\n    reset_held_button();\n}\n\n    void\nend_visual_mode_keep_button()\n{\n#ifdef FEAT_CLIPBOARD\n    /*\n     * If we are using the clipboard, then remember what was selected in case\n     * we need to paste it somewhere while we still own the selection.\n     * Only do this when the clipboard is already owned.  Don't want to grab\n     * the selection when hitting ESC.\n     */\n    if (clip_star.available && clip_star.owned)\n\tclip_auto_select();\n\n# if defined(FEAT_EVAL)\n    // Emit a TextYankPost for the automatic copy of the selection into the\n    // star and/or plus register.\n    if (has_textyankpost())\n    {\n\tif (clip_isautosel_star())\n\t    call_yank_do_autocmd('*');\n\tif (clip_isautosel_plus())\n\t    call_yank_do_autocmd('+');\n    }\n# endif\n#endif\n\n    VIsual_active = FALSE;\n    setmouse();\n    mouse_dragging = 0;\n\n    // Save the current VIsual area for '< and '> marks, and \"gv\"\n    curbuf->b_visual.vi_mode = VIsual_mode;\n    curbuf->b_visual.vi_start = VIsual;\n    curbuf->b_visual.vi_end = curwin->w_cursor;\n    curbuf->b_visual.vi_curswant = curwin->w_curswant;\n#ifdef FEAT_EVAL\n    curbuf->b_visual_mode_eval = VIsual_mode;\n#endif\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    may_clear_cmdline();\n\n    adjust_cursor_eol();\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect.\n */\n    void\nreset_VIsual_and_resel(void)\n{\n    if (VIsual_active)\n    {\n\tend_visual_mode();\n\tredraw_curbuf_later(INVERTED);\t// delete the inversion later\n    }\n    VIsual_reselect = FALSE;\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect if it's set.\n */\n    void\nreset_VIsual(void)\n{\n    if (VIsual_active)\n    {\n\tend_visual_mode();\n\tredraw_curbuf_later(INVERTED);\t// delete the inversion later\n\tVIsual_reselect = FALSE;\n    }\n}\n\n    void\nrestore_visual_mode(void)\n{\n    if (VIsual_mode_orig != NUL)\n    {\n\tcurbuf->b_visual.vi_mode = VIsual_mode_orig;\n\tVIsual_mode_orig = NUL;\n    }\n}\n\n/*\n * Check for a balloon-eval special item to include when searching for an\n * identifier.  When \"dir\" is BACKWARD \"ptr[-1]\" must be valid!\n * Returns TRUE if the character at \"*ptr\" should be included.\n * \"dir\" is FORWARD or BACKWARD, the direction of searching.\n * \"*colp\" is in/decremented if \"ptr[-dir]\" should also be included.\n * \"bnp\" points to a counter for square brackets.\n */\n    static int\nfind_is_eval_item(\n    char_u\t*ptr,\n    int\t\t*colp,\n    int\t\t*bnp,\n    int\t\tdir)\n{\n    // Accept everything inside [].\n    if ((*ptr == ']' && dir == BACKWARD) || (*ptr == '[' && dir == FORWARD))\n\t++*bnp;\n    if (*bnp > 0)\n    {\n\tif ((*ptr == '[' && dir == BACKWARD) || (*ptr == ']' && dir == FORWARD))\n\t    --*bnp;\n\treturn TRUE;\n    }\n\n    // skip over \"s.var\"\n    if (*ptr == '.')\n\treturn TRUE;\n\n    // two-character item: s->var\n    if (ptr[dir == BACKWARD ? 0 : 1] == '>'\n\t    && ptr[dir == BACKWARD ? -1 : 0] == '-')\n    {\n\t*colp += dir;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Find the identifier under or to the right of the cursor.\n * \"find_type\" can have one of three values:\n * FIND_IDENT:   find an identifier (keyword)\n * FIND_STRING:  find any non-white text\n * FIND_IDENT + FIND_STRING: find any non-white text, identifier preferred.\n * FIND_EVAL:\t find text useful for C program debugging\n *\n * There are three steps:\n * 1. Search forward for the start of an identifier/text.  Doesn't move if\n *    already on one.\n * 2. Search backward for the start of this identifier/text.\n *    This doesn't match the real Vi but I like it a little better and it\n *    shouldn't bother anyone.\n * 3. Search forward to the end of this identifier/text.\n *    When FIND_IDENT isn't defined, we backup until a blank.\n *\n * Returns the length of the text, or zero if no text is found.\n * If text is found, a pointer to the text is put in \"*text\".  This\n * points into the current buffer line and is not always NUL terminated.\n */\n    int\nfind_ident_under_cursor(char_u **text, int find_type)\n{\n    return find_ident_at_pos(curwin, curwin->w_cursor.lnum,\n\t\t\t\tcurwin->w_cursor.col, text, NULL, find_type);\n}\n\n/*\n * Like find_ident_under_cursor(), but for any window and any position.\n * However: Uses 'iskeyword' from the current window!.\n */\n    int\nfind_ident_at_pos(\n    win_T\t*wp,\n    linenr_T\tlnum,\n    colnr_T\tstartcol,\n    char_u\t**text,\n    int\t\t*textcol,\t// column where \"text\" starts, can be NULL\n    int\t\tfind_type)\n{\n    char_u\t*ptr;\n    int\t\tcol = 0;\t// init to shut up GCC\n    int\t\ti;\n    int\t\tthis_class = 0;\n    int\t\tprev_class;\n    int\t\tprevcol;\n    int\t\tbn = 0;\t\t// bracket nesting\n\n    /*\n     * if i == 0: try to find an identifier\n     * if i == 1: try to find any non-white text\n     */\n    ptr = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    for (i = (find_type & FIND_IDENT) ? 0 : 1;\ti < 2; ++i)\n    {\n\t/*\n\t * 1. skip to start of identifier/text\n\t */\n\tcol = startcol;\n\tif (has_mbyte)\n\t{\n\t    while (ptr[col] != NUL)\n\t    {\n\t\t// Stop at a ']' to evaluate \"a[x]\".\n\t\tif ((find_type & FIND_EVAL) && ptr[col] == ']')\n\t\t    break;\n\t\tthis_class = mb_get_class(ptr + col);\n\t\tif (this_class != 0 && (i == 1 || this_class != 1))\n\t\t    break;\n\t\tcol += (*mb_ptr2len)(ptr + col);\n\t    }\n\t}\n\telse\n\t    while (ptr[col] != NUL\n\t\t    && (i == 0 ? !vim_iswordc(ptr[col]) : VIM_ISWHITE(ptr[col]))\n\t\t    && (!(find_type & FIND_EVAL) || ptr[col] != ']')\n\t\t    )\n\t\t++col;\n\n\t// When starting on a ']' count it, so that we include the '['.\n\tbn = ptr[col] == ']';\n\n\t/*\n\t * 2. Back up to start of identifier/text.\n\t */\n\tif (has_mbyte)\n\t{\n\t    // Remember class of character under cursor.\n\t    if ((find_type & FIND_EVAL) && ptr[col] == ']')\n\t\tthis_class = mb_get_class((char_u *)\"a\");\n\t    else\n\t\tthis_class = mb_get_class(ptr + col);\n\t    while (col > 0 && this_class != 0)\n\t    {\n\t\tprevcol = col - 1 - (*mb_head_off)(ptr, ptr + col - 1);\n\t\tprev_class = mb_get_class(ptr + prevcol);\n\t\tif (this_class != prev_class\n\t\t\t&& (i == 0\n\t\t\t    || prev_class == 0\n\t\t\t    || (find_type & FIND_IDENT))\n\t\t\t&& (!(find_type & FIND_EVAL)\n\t\t\t    || prevcol == 0\n\t\t\t    || !find_is_eval_item(ptr + prevcol, &prevcol,\n\t\t\t\t\t\t\t       &bn, BACKWARD))\n\t\t\t)\n\t\t    break;\n\t\tcol = prevcol;\n\t    }\n\n\t    // If we don't want just any old text, or we've found an\n\t    // identifier, stop searching.\n\t    if (this_class > 2)\n\t\tthis_class = 2;\n\t    if (!(find_type & FIND_STRING) || this_class == 2)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    while (col > 0\n\t\t    && ((i == 0\n\t\t\t    ? vim_iswordc(ptr[col - 1])\n\t\t\t    : (!VIM_ISWHITE(ptr[col - 1])\n\t\t\t\t&& (!(find_type & FIND_IDENT)\n\t\t\t\t    || !vim_iswordc(ptr[col - 1]))))\n\t\t\t|| ((find_type & FIND_EVAL)\n\t\t\t    && col > 1\n\t\t\t    && find_is_eval_item(ptr + col - 1, &col,\n\t\t\t\t\t\t\t       &bn, BACKWARD))\n\t\t\t))\n\t\t--col;\n\n\t    // If we don't want just any old text, or we've found an\n\t    // identifier, stop searching.\n\t    if (!(find_type & FIND_STRING) || vim_iswordc(ptr[col]))\n\t\tbreak;\n\t}\n    }\n\n    if (ptr[col] == NUL || (i == 0\n\t\t&& (has_mbyte ? this_class != 2 : !vim_iswordc(ptr[col]))))\n    {\n\t// didn't find an identifier or text\n\tif ((find_type & FIND_NOERROR) == 0)\n\t{\n\t    if (find_type & FIND_STRING)\n\t\temsg(_(\"E348: No string under cursor\"));\n\t    else\n\t\temsg(_(e_noident));\n\t}\n\treturn 0;\n    }\n    ptr += col;\n    *text = ptr;\n    if (textcol != NULL)\n\t*textcol = col;\n\n    /*\n     * 3. Find the end if the identifier/text.\n     */\n    bn = 0;\n    startcol -= col;\n    col = 0;\n    if (has_mbyte)\n    {\n\t// Search for point of changing multibyte character class.\n\tthis_class = mb_get_class(ptr);\n\twhile (ptr[col] != NUL\n\t\t&& ((i == 0 ? mb_get_class(ptr + col) == this_class\n\t\t\t    : mb_get_class(ptr + col) != 0)\n\t\t    || ((find_type & FIND_EVAL)\n\t\t\t&& col <= (int)startcol\n\t\t\t&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))\n\t\t))\n\t    col += (*mb_ptr2len)(ptr + col);\n    }\n    else\n\twhile ((i == 0 ? vim_iswordc(ptr[col])\n\t\t       : (ptr[col] != NUL && !VIM_ISWHITE(ptr[col])))\n\t\t    || ((find_type & FIND_EVAL)\n\t\t\t&& col <= (int)startcol\n\t\t\t&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))\n\t\t)\n\t    ++col;\n\n    return col;\n}\n\n/*\n * Prepare for redo of a normal command.\n */\n    static void\nprep_redo_cmd(cmdarg_T *cap)\n{\n    prep_redo(cap->oap->regname, cap->count0,\n\t\t\t\t     NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n}\n\n/*\n * Prepare for redo of any command.\n * Note that only the last argument can be a multi-byte char.\n */\n    void\nprep_redo(\n    int\t    regname,\n    long    num,\n    int\t    cmd1,\n    int\t    cmd2,\n    int\t    cmd3,\n    int\t    cmd4,\n    int\t    cmd5)\n{\n    ResetRedobuff();\n    if (regname != 0)\t// yank from specified buffer\n    {\n\tAppendCharToRedobuff('\"');\n\tAppendCharToRedobuff(regname);\n    }\n    if (num)\n\tAppendNumberToRedobuff(num);\n\n    if (cmd1 != NUL)\n\tAppendCharToRedobuff(cmd1);\n    if (cmd2 != NUL)\n\tAppendCharToRedobuff(cmd2);\n    if (cmd3 != NUL)\n\tAppendCharToRedobuff(cmd3);\n    if (cmd4 != NUL)\n\tAppendCharToRedobuff(cmd4);\n    if (cmd5 != NUL)\n\tAppendCharToRedobuff(cmd5);\n}\n\n/*\n * check for operator active and clear it\n *\n * return TRUE if operator was active\n */\n    static int\ncheckclearop(oparg_T *oap)\n{\n    if (oap->op_type == OP_NOP)\n\treturn FALSE;\n    clearopbeep(oap);\n    return TRUE;\n}\n\n/*\n * Check for operator or Visual active.  Clear active operator.\n *\n * Return TRUE if operator or Visual was active.\n */\n    static int\ncheckclearopq(oparg_T *oap)\n{\n    if (oap->op_type == OP_NOP && !VIsual_active)\n\treturn FALSE;\n    clearopbeep(oap);\n    return TRUE;\n}\n\n    void\nclearop(oparg_T *oap)\n{\n    oap->op_type = OP_NOP;\n    oap->regname = 0;\n    oap->motion_force = NUL;\n    oap->use_reg_one = FALSE;\n    motion_force = NUL;\n}\n\n    void\nclearopbeep(oparg_T *oap)\n{\n    clearop(oap);\n    beep_flush();\n}\n\n/*\n * Remove the shift modifier from a special key.\n */\n    static void\nunshift_special(cmdarg_T *cap)\n{\n    switch (cap->cmdchar)\n    {\n\tcase K_S_RIGHT:\tcap->cmdchar = K_RIGHT; break;\n\tcase K_S_LEFT:\tcap->cmdchar = K_LEFT; break;\n\tcase K_S_UP:\tcap->cmdchar = K_UP; break;\n\tcase K_S_DOWN:\tcap->cmdchar = K_DOWN; break;\n\tcase K_S_HOME:\tcap->cmdchar = K_HOME; break;\n\tcase K_S_END:\tcap->cmdchar = K_END; break;\n    }\n    cap->cmdchar = simplify_key(cap->cmdchar, &mod_mask);\n}\n\n/*\n * If the mode is currently displayed clear the command line or update the\n * command displayed.\n */\n    void\nmay_clear_cmdline(void)\n{\n    if (mode_displayed)\n\tclear_cmdline = TRUE;   // unshow visual mode later\n#ifdef FEAT_CMDL_INFO\n    else\n\tclear_showcmd();\n#endif\n}\n\n#if defined(FEAT_CMDL_INFO) || defined(PROTO)\n/*\n * Routines for displaying a partly typed command\n */\n\n#define SHOWCMD_BUFLEN SHOWCMD_COLS + 1 + 30\nstatic char_u\tshowcmd_buf[SHOWCMD_BUFLEN];\nstatic char_u\told_showcmd_buf[SHOWCMD_BUFLEN];  // For push_showcmd()\nstatic int\tshowcmd_is_clear = TRUE;\nstatic int\tshowcmd_visual = FALSE;\n\nstatic void display_showcmd(void);\n\n    void\nclear_showcmd(void)\n{\n    if (!p_sc)\n\treturn;\n\n    if (VIsual_active && !char_avail())\n    {\n\tint\t\tcursor_bot = LT_POS(VIsual, curwin->w_cursor);\n\tlong\t\tlines;\n\tcolnr_T\t\tleftcol, rightcol;\n\tlinenr_T\ttop, bot;\n\n\t// Show the size of the Visual area.\n\tif (cursor_bot)\n\t{\n\t    top = VIsual.lnum;\n\t    bot = curwin->w_cursor.lnum;\n\t}\n\telse\n\t{\n\t    top = curwin->w_cursor.lnum;\n\t    bot = VIsual.lnum;\n\t}\n# ifdef FEAT_FOLDING\n\t// Include closed folds as a whole.\n\t(void)hasFolding(top, &top, NULL);\n\t(void)hasFolding(bot, NULL, &bot);\n# endif\n\tlines = bot - top + 1;\n\n\tif (VIsual_mode == Ctrl_V)\n\t{\n# ifdef FEAT_LINEBREAK\n\t    char_u *saved_sbr = p_sbr;\n\t    char_u *saved_w_sbr = curwin->w_p_sbr;\n\n\t    // Make 'sbr' empty for a moment to get the correct size.\n\t    p_sbr = empty_option;\n\t    curwin->w_p_sbr = empty_option;\n# endif\n\t    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);\n# ifdef FEAT_LINEBREAK\n\t    p_sbr = saved_sbr;\n\t    curwin->w_p_sbr = saved_w_sbr;\n# endif\n\t    sprintf((char *)showcmd_buf, \"%ldx%ld\", lines,\n\t\t\t\t\t      (long)(rightcol - leftcol + 1));\n\t}\n\telse if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)\n\t    sprintf((char *)showcmd_buf, \"%ld\", lines);\n\telse\n\t{\n\t    char_u  *s, *e;\n\t    int\t    l;\n\t    int\t    bytes = 0;\n\t    int\t    chars = 0;\n\n\t    if (cursor_bot)\n\t    {\n\t\ts = ml_get_pos(&VIsual);\n\t\te = ml_get_cursor();\n\t    }\n\t    else\n\t    {\n\t\ts = ml_get_cursor();\n\t\te = ml_get_pos(&VIsual);\n\t    }\n\t    while ((*p_sel != 'e') ? s <= e : s < e)\n\t    {\n\t\tl = (*mb_ptr2len)(s);\n\t\tif (l == 0)\n\t\t{\n\t\t    ++bytes;\n\t\t    ++chars;\n\t\t    break;  // end of line\n\t\t}\n\t\tbytes += l;\n\t\t++chars;\n\t\ts += l;\n\t    }\n\t    if (bytes == chars)\n\t\tsprintf((char *)showcmd_buf, \"%d\", chars);\n\t    else\n\t\tsprintf((char *)showcmd_buf, \"%d-%d\", chars, bytes);\n\t}\n\tshowcmd_buf[SHOWCMD_COLS] = NUL;\t// truncate\n\tshowcmd_visual = TRUE;\n    }\n    else\n    {\n\tshowcmd_buf[0] = NUL;\n\tshowcmd_visual = FALSE;\n\n\t// Don't actually display something if there is nothing to clear.\n\tif (showcmd_is_clear)\n\t    return;\n    }\n\n    display_showcmd();\n}\n\n/*\n * Add 'c' to string of shown command chars.\n * Return TRUE if output has been written (and setcursor() has been called).\n */\n    int\nadd_to_showcmd(int c)\n{\n    char_u\t*p;\n    int\t\told_len;\n    int\t\textra_len;\n    int\t\toverflow;\n    int\t\ti;\n    static int\tignore[] =\n    {\n#ifdef FEAT_GUI\n\tK_VER_SCROLLBAR, K_HOR_SCROLLBAR,\n\tK_LEFTMOUSE_NM, K_LEFTRELEASE_NM,\n#endif\n\tK_IGNORE, K_PS,\n\tK_LEFTMOUSE, K_LEFTDRAG, K_LEFTRELEASE, K_MOUSEMOVE,\n\tK_MIDDLEMOUSE, K_MIDDLEDRAG, K_MIDDLERELEASE,\n\tK_RIGHTMOUSE, K_RIGHTDRAG, K_RIGHTRELEASE,\n\tK_MOUSEDOWN, K_MOUSEUP, K_MOUSELEFT, K_MOUSERIGHT,\n\tK_X1MOUSE, K_X1DRAG, K_X1RELEASE, K_X2MOUSE, K_X2DRAG, K_X2RELEASE,\n\tK_CURSORHOLD,\n\t0\n    };\n\n    if (!p_sc || msg_silent != 0)\n\treturn FALSE;\n\n    if (showcmd_visual)\n    {\n\tshowcmd_buf[0] = NUL;\n\tshowcmd_visual = FALSE;\n    }\n\n    // Ignore keys that are scrollbar updates and mouse clicks\n    if (IS_SPECIAL(c))\n\tfor (i = 0; ignore[i] != 0; ++i)\n\t    if (ignore[i] == c)\n\t\treturn FALSE;\n\n    p = transchar(c);\n    if (*p == ' ')\n\tSTRCPY(p, \"<20>\");\n    old_len = (int)STRLEN(showcmd_buf);\n    extra_len = (int)STRLEN(p);\n    overflow = old_len + extra_len - SHOWCMD_COLS;\n    if (overflow > 0)\n\tmch_memmove(showcmd_buf, showcmd_buf + overflow,\n\t\t\t\t\t\t      old_len - overflow + 1);\n    STRCAT(showcmd_buf, p);\n\n    if (char_avail())\n\treturn FALSE;\n\n    display_showcmd();\n\n    return TRUE;\n}\n\n    void\nadd_to_showcmd_c(int c)\n{\n    if (!add_to_showcmd(c))\n\tsetcursor();\n}\n\n/*\n * Delete 'len' characters from the end of the shown command.\n */\n    static void\ndel_from_showcmd(int len)\n{\n    int\t    old_len;\n\n    if (!p_sc)\n\treturn;\n\n    old_len = (int)STRLEN(showcmd_buf);\n    if (len > old_len)\n\tlen = old_len;\n    showcmd_buf[old_len - len] = NUL;\n\n    if (!char_avail())\n\tdisplay_showcmd();\n}\n\n/*\n * push_showcmd() and pop_showcmd() are used when waiting for the user to type\n * something and there is a partial mapping.\n */\n    void\npush_showcmd(void)\n{\n    if (p_sc)\n\tSTRCPY(old_showcmd_buf, showcmd_buf);\n}\n\n    void\npop_showcmd(void)\n{\n    if (!p_sc)\n\treturn;\n\n    STRCPY(showcmd_buf, old_showcmd_buf);\n\n    display_showcmd();\n}\n\n    static void\ndisplay_showcmd(void)\n{\n    int\t    len;\n\n    cursor_off();\n\n    len = (int)STRLEN(showcmd_buf);\n    if (len == 0)\n\tshowcmd_is_clear = TRUE;\n    else\n    {\n\tscreen_puts(showcmd_buf, (int)Rows - 1, sc_col, 0);\n\tshowcmd_is_clear = FALSE;\n    }\n\n    /*\n     * clear the rest of an old message by outputting up to SHOWCMD_COLS\n     * spaces\n     */\n    screen_puts((char_u *)\"          \" + len, (int)Rows - 1, sc_col + len, 0);\n\n    setcursor();\t    // put cursor back where it belongs\n}\n#endif\n\n/*\n * When \"check\" is FALSE, prepare for commands that scroll the window.\n * When \"check\" is TRUE, take care of scroll-binding after the window has\n * scrolled.  Called from normal_cmd() and edit().\n */\n    void\ndo_check_scrollbind(int check)\n{\n    static win_T\t*old_curwin = NULL;\n    static linenr_T\told_topline = 0;\n#ifdef FEAT_DIFF\n    static int\t\told_topfill = 0;\n#endif\n    static buf_T\t*old_buf = NULL;\n    static colnr_T\told_leftcol = 0;\n\n    if (check && curwin->w_p_scb)\n    {\n\t// If a \":syncbind\" command was just used, don't scroll, only reset\n\t// the values.\n\tif (did_syncbind)\n\t    did_syncbind = FALSE;\n\telse if (curwin == old_curwin)\n\t{\n\t    /*\n\t     * Synchronize other windows, as necessary according to\n\t     * 'scrollbind'.  Don't do this after an \":edit\" command, except\n\t     * when 'diff' is set.\n\t     */\n\t    if ((curwin->w_buffer == old_buf\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_p_diff\n#endif\n\t\t)\n\t\t&& (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t\t|| curwin->w_leftcol != old_leftcol))\n\t    {\n\t\tcheck_scrollbind(curwin->w_topline - old_topline,\n\t\t\t(long)(curwin->w_leftcol - old_leftcol));\n\t    }\n\t}\n\telse if (vim_strchr(p_sbo, 'j')) // jump flag set in 'scrollopt'\n\t{\n\t    /*\n\t     * When switching between windows, make sure that the relative\n\t     * vertical offset is valid for the new window.  The relative\n\t     * offset is invalid whenever another 'scrollbind' window has\n\t     * scrolled to a point that would force the current window to\n\t     * scroll past the beginning or end of its buffer.  When the\n\t     * resync is performed, some of the other 'scrollbind' windows may\n\t     * need to jump so that the current window's relative position is\n\t     * visible on-screen.\n\t     */\n\t    check_scrollbind(curwin->w_topline - curwin->w_scbind_pos, 0L);\n\t}\n\tcurwin->w_scbind_pos = curwin->w_topline;\n    }\n\n    old_curwin = curwin;\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n    old_buf = curwin->w_buffer;\n    old_leftcol = curwin->w_leftcol;\n}\n\n/*\n * Synchronize any windows that have \"scrollbind\" set, based on the\n * number of rows by which the current window has changed\n * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)\n */\n    void\ncheck_scrollbind(linenr_T topline_diff, long leftcol_diff)\n{\n    int\t\twant_ver;\n    int\t\twant_hor;\n    win_T\t*old_curwin = curwin;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\told_VIsual_select = VIsual_select;\n    int\t\told_VIsual_active = VIsual_active;\n    colnr_T\ttgt_leftcol = curwin->w_leftcol;\n    long\ttopline;\n    long\ty;\n\n    /*\n     * check 'scrollopt' string for vertical and horizontal scroll options\n     */\n    want_ver = (vim_strchr(p_sbo, 'v') && topline_diff != 0);\n#ifdef FEAT_DIFF\n    want_ver |= old_curwin->w_p_diff;\n#endif\n    want_hor = (vim_strchr(p_sbo, 'h') && (leftcol_diff || topline_diff != 0));\n\n    /*\n     * loop through the scrollbound windows and scroll accordingly\n     */\n    VIsual_select = VIsual_active = 0;\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tcurbuf = curwin->w_buffer;\n\t// skip original window  and windows with 'noscrollbind'\n\tif (curwin != old_curwin && curwin->w_p_scb)\n\t{\n\t    /*\n\t     * do the vertical scroll\n\t     */\n\t    if (want_ver)\n\t    {\n#ifdef FEAT_DIFF\n\t\tif (old_curwin->w_p_diff && curwin->w_p_diff)\n\t\t{\n\t\t    diff_set_topline(old_curwin, curwin);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    curwin->w_scbind_pos += topline_diff;\n\t\t    topline = curwin->w_scbind_pos;\n\t\t    if (topline > curbuf->b_ml.ml_line_count)\n\t\t\ttopline = curbuf->b_ml.ml_line_count;\n\t\t    if (topline < 1)\n\t\t\ttopline = 1;\n\n\t\t    y = topline - curwin->w_topline;\n\t\t    if (y > 0)\n\t\t\tscrollup(y, FALSE);\n\t\t    else\n\t\t\tscrolldown(-y, FALSE);\n\t\t}\n\n\t\tredraw_later(VALID);\n\t\tcursor_correct();\n\t\tcurwin->w_redr_status = TRUE;\n\t    }\n\n\t    /*\n\t     * do the horizontal scroll\n\t     */\n\t    if (want_hor && curwin->w_leftcol != tgt_leftcol)\n\t    {\n\t\tcurwin->w_leftcol = tgt_leftcol;\n\t\tleftcol_changed();\n\t    }\n\t}\n    }\n\n    /*\n     * reset current-window\n     */\n    VIsual_select = old_VIsual_select;\n    VIsual_active = old_VIsual_active;\n    curwin = old_curwin;\n    curbuf = old_curbuf;\n}\n\n/*\n * Command character that's ignored.\n * Used for CTRL-Q and CTRL-S to avoid problems with terminals that use\n * xon/xoff.\n */\n    static void\nnv_ignore(cmdarg_T *cap)\n{\n    cap->retval |= CA_COMMAND_BUSY;\t// don't call edit() now\n}\n\n/*\n * Command character that doesn't do anything, but unlike nv_ignore() does\n * start edit().  Used for \"startinsert\" executed while starting up.\n */\n    static void\nnv_nop(cmdarg_T *cap UNUSED)\n{\n}\n\n/*\n * Command character doesn't exist.\n */\n    static void\nnv_error(cmdarg_T *cap)\n{\n    clearopbeep(cap->oap);\n}\n\n/*\n * <Help> and <F1> commands.\n */\n    static void\nnv_help(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\tex_help(NULL);\n}\n\n/*\n * CTRL-A and CTRL-X: Add or subtract from letter or number under cursor.\n */\n    static void\nnv_addsub(cmdarg_T *cap)\n{\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n\tclearopbeep(cap->oap);\n    else\n#endif\n    if (!VIsual_active && cap->oap->op_type == OP_NOP)\n    {\n\tprep_redo_cmd(cap);\n\tcap->oap->op_type = cap->cmdchar == Ctrl_A ?  OP_NR_ADD : OP_NR_SUB;\n\top_addsub(cap->oap, cap->count1, cap->arg);\n\tcap->oap->op_type = OP_NOP;\n    }\n    else if (VIsual_active)\n\tnv_operator(cap);\n    else\n\tclearop(cap->oap);\n}\n\n/*\n * CTRL-F, CTRL-B, etc: Scroll page up or down.\n */\n    static void\nnv_page(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n\tif (mod_mask & MOD_MASK_CTRL)\n\t{\n\t    // <C-PageUp>: tab page back; <C-PageDown>: tab page forward\n\t    if (cap->arg == BACKWARD)\n\t\tgoto_tabpage(-(int)cap->count1);\n\t    else\n\t\tgoto_tabpage((int)cap->count0);\n\t}\n\telse\n\t    (void)onepage(cap->arg, cap->count1);\n    }\n}\n\n/*\n * Implementation of \"gd\" and \"gD\" command.\n */\n    static void\nnv_gd(\n    oparg_T\t*oap,\n    int\t\tnchar,\n    int\t\tthisblock)\t// 1 for \"1gd\" and \"1gD\"\n{\n    int\t\tlen;\n    char_u\t*ptr;\n\n    if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0\n\t    || find_decl(ptr, len, nchar == 'd', thisblock, SEARCH_START)\n\t\t\t\t\t\t\t\t      == FAIL)\n\tclearopbeep(oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_SEARCH) && KeyTyped && oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Return TRUE if line[offset] is not inside a C-style comment or string, FALSE\n * otherwise.\n */\n    static int\nis_ident(char_u *line, int offset)\n{\n    int\ti;\n    int\tincomment = FALSE;\n    int\tinstring = 0;\n    int\tprev = 0;\n\n    for (i = 0; i < offset && line[i] != NUL; i++)\n    {\n\tif (instring != 0)\n\t{\n\t    if (prev != '\\\\' && line[i] == instring)\n\t\tinstring = 0;\n\t}\n\telse if ((line[i] == '\"' || line[i] == '\\'') && !incomment)\n\t{\n\t    instring = line[i];\n\t}\n\telse\n\t{\n\t    if (incomment)\n\t    {\n\t\tif (prev == '*' && line[i] == '/')\n\t\t    incomment = FALSE;\n\t    }\n\t    else if (prev == '/' && line[i] == '*')\n\t    {\n\t\tincomment = TRUE;\n\t    }\n\t    else if (prev == '/' && line[i] == '/')\n\t    {\n\t\treturn FALSE;\n\t    }\n\t}\n\n\tprev = line[i];\n    }\n\n    return incomment == FALSE && instring == 0;\n}\n\n/*\n * Search for variable declaration of \"ptr[len]\".\n * When \"locally\" is TRUE in the current function (\"gd\"), otherwise in the\n * current file (\"gD\").\n * When \"thisblock\" is TRUE check the {} block scope.\n * Return FAIL when not found.\n */\n    int\nfind_decl(\n    char_u\t*ptr,\n    int\t\tlen,\n    int\t\tlocally,\n    int\t\tthisblock,\n    int\t\tflags_arg)\t// flags passed to searchit()\n{\n    char_u\t*pat;\n    pos_T\told_pos;\n    pos_T\tpar_pos;\n    pos_T\tfound_pos;\n    int\t\tt;\n    int\t\tsave_p_ws;\n    int\t\tsave_p_scs;\n    int\t\tretval = OK;\n    int\t\tincll;\n    int\t\tsearchflags = flags_arg;\n    int\t\tvalid;\n\n    if ((pat = alloc(len + 7)) == NULL)\n\treturn FAIL;\n\n    // Put \"\\V\" before the pattern to avoid that the special meaning of \".\"\n    // and \"~\" causes trouble.\n    sprintf((char *)pat, vim_iswordp(ptr) ? \"\\\\V\\\\<%.*s\\\\>\" : \"\\\\V%.*s\",\n\t\t\t\t\t\t\t\t    len, ptr);\n    old_pos = curwin->w_cursor;\n    save_p_ws = p_ws;\n    save_p_scs = p_scs;\n    p_ws = FALSE;\t// don't wrap around end of file now\n    p_scs = FALSE;\t// don't switch ignorecase off now\n\n    /*\n     * With \"gD\" go to line 1.\n     * With \"gd\" Search back for the start of the current function, then go\n     * back until a blank line.  If this fails go to line 1.\n     */\n    if (!locally || !findpar(&incll, BACKWARD, 1L, '{', FALSE))\n    {\n\tsetpcmark();\t\t\t// Set in findpar() otherwise\n\tcurwin->w_cursor.lnum = 1;\n\tpar_pos = curwin->w_cursor;\n    }\n    else\n    {\n\tpar_pos = curwin->w_cursor;\n\twhile (curwin->w_cursor.lnum > 1 && *skipwhite(ml_get_curline()) != NUL)\n\t    --curwin->w_cursor.lnum;\n    }\n    curwin->w_cursor.col = 0;\n\n    // Search forward for the identifier, ignore comment lines.\n    CLEAR_POS(&found_pos);\n    for (;;)\n    {\n\tt = searchit(curwin, curbuf, &curwin->w_cursor, NULL, FORWARD,\n\t\t\t\t\t  pat, 1L, searchflags, RE_LAST, NULL);\n\tif (curwin->w_cursor.lnum >= old_pos.lnum)\n\t    t = FAIL;\t// match after start is failure too\n\n\tif (thisblock && t != FAIL)\n\t{\n\t    pos_T\t*pos;\n\n\t    // Check that the block the match is in doesn't end before the\n\t    // position where we started the search from.\n\t    if ((pos = findmatchlimit(NULL, '}', FM_FORWARD,\n\t\t     (int)(old_pos.lnum - curwin->w_cursor.lnum + 1))) != NULL\n\t\t    && pos->lnum < old_pos.lnum)\n\t    {\n\t\t// There can't be a useful match before the end of this block.\n\t\t// Skip to the end.\n\t\tcurwin->w_cursor = *pos;\n\t\tcontinue;\n\t    }\n\t}\n\n\tif (t == FAIL)\n\t{\n\t    // If we previously found a valid position, use it.\n\t    if (found_pos.lnum != 0)\n\t    {\n\t\tcurwin->w_cursor = found_pos;\n\t\tt = OK;\n\t    }\n\t    break;\n\t}\n\tif (get_leader_len(ml_get_curline(), NULL, FALSE, TRUE) > 0)\n\t{\n\t    // Ignore this line, continue at start of next line.\n\t    ++curwin->w_cursor.lnum;\n\t    curwin->w_cursor.col = 0;\n\t    continue;\n\t}\n\tvalid = is_ident(ml_get_curline(), curwin->w_cursor.col);\n\n\t// If the current position is not a valid identifier and a previous\n\t// match is present, favor that one instead.\n\tif (!valid && found_pos.lnum != 0)\n\t{\n\t    curwin->w_cursor = found_pos;\n\t    break;\n\t}\n\n\t// Global search: use first valid match found\n\tif (valid && !locally)\n\t    break;\n\tif (valid && curwin->w_cursor.lnum >= par_pos.lnum)\n\t{\n\t    // If we previously found a valid position, use it.\n\t    if (found_pos.lnum != 0)\n\t\tcurwin->w_cursor = found_pos;\n\t    break;\n\t}\n\n\t// For finding a local variable and the match is before the \"{\" or\n\t// inside a comment, continue searching.  For K&R style function\n\t// declarations this skips the function header without types.\n\tif (!valid)\n\t    CLEAR_POS(&found_pos);\n\telse\n\t    found_pos = curwin->w_cursor;\n\t// Remove SEARCH_START from flags to avoid getting stuck at one\n\t// position.\n\tsearchflags &= ~SEARCH_START;\n    }\n\n    if (t == FAIL)\n    {\n\tretval = FAIL;\n\tcurwin->w_cursor = old_pos;\n    }\n    else\n    {\n\tcurwin->w_set_curswant = TRUE;\n\t// \"n\" searches forward now\n\treset_search_dir();\n    }\n\n    vim_free(pat);\n    p_ws = save_p_ws;\n    p_scs = save_p_scs;\n\n    return retval;\n}\n\n/*\n * Move 'dist' lines in direction 'dir', counting lines by *screen*\n * lines rather than lines in the file.\n * 'dist' must be positive.\n *\n * Return OK if able to move cursor, FAIL otherwise.\n */\n    static int\nnv_screengo(oparg_T *oap, int dir, long dist)\n{\n    int\t\tlinelen = linetabsize(ml_get_curline());\n    int\t\tretval = OK;\n    int\t\tatend = FALSE;\n    int\t\tn;\n    int\t\tcol_off1;\t// margin offset for first screen line\n    int\t\tcol_off2;\t// margin offset for wrapped screen line\n    int\t\twidth1;\t\t// text width for first screen line\n    int\t\twidth2;\t\t// test width for wrapped screen line\n\n    oap->motion_type = MCHAR;\n    oap->inclusive = (curwin->w_curswant == MAXCOL);\n\n    col_off1 = curwin_col_off();\n    col_off2 = col_off1 - curwin_col_off2();\n    width1 = curwin->w_width - col_off1;\n    width2 = curwin->w_width - col_off2;\n    if (width2 == 0)\n\twidth2 = 1; // avoid divide by zero\n\n    if (curwin->w_width != 0)\n    {\n      /*\n       * Instead of sticking at the last character of the buffer line we\n       * try to stick in the last column of the screen.\n       */\n      if (curwin->w_curswant == MAXCOL)\n      {\n\tatend = TRUE;\n\tvalidate_virtcol();\n\tif (width1 <= 0)\n\t    curwin->w_curswant = 0;\n\telse\n\t{\n\t    curwin->w_curswant = width1 - 1;\n\t    if (curwin->w_virtcol > curwin->w_curswant)\n\t\tcurwin->w_curswant += ((curwin->w_virtcol\n\t\t\t     - curwin->w_curswant - 1) / width2 + 1) * width2;\n\t}\n      }\n      else\n      {\n\tif (linelen > width1)\n\t    n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n\telse\n\t    n = width1;\n\tif (curwin->w_curswant >= (colnr_T)n)\n\t    curwin->w_curswant = n - 1;\n      }\n\n      while (dist--)\n      {\n\tif (dir == BACKWARD)\n\t{\n\t    if ((long)curwin->w_curswant >= width1\n#ifdef FEAT_FOLDING\n\t\t    && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)\n#endif\n\t       )\n\t\t// Move back within the line. This can give a negative value\n\t\t// for w_curswant if width1 < width2 (with cpoptions+=n),\n\t\t// which will get clipped to column 0.\n\t\tcurwin->w_curswant -= width2;\n\t    else\n\t    {\n\t\t// to previous line\n#ifdef FEAT_FOLDING\n\t\t// Move to the start of a closed fold.  Don't do that when\n\t\t// 'foldopen' contains \"all\": it will open in a moment.\n\t\tif (!(fdo_flags & FDO_ALL))\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n#endif\n\t\tif (curwin->w_cursor.lnum == 1)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\t--curwin->w_cursor.lnum;\n\n\t\tlinelen = linetabsize(ml_get_curline());\n\t\tif (linelen > width1)\n\t\t    curwin->w_curswant += (((linelen - width1 - 1) / width2)\n\t\t\t\t\t\t\t\t+ 1) * width2;\n\t    }\n\t}\n\telse // dir == FORWARD\n\t{\n\t    if (linelen > width1)\n\t\tn = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n\t    else\n\t\tn = width1;\n\t    if (curwin->w_curswant + width2 < (colnr_T)n\n#ifdef FEAT_FOLDING\n\t\t    && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)\n#endif\n\t\t    )\n\t\t// move forward within line\n\t\tcurwin->w_curswant += width2;\n\t    else\n\t    {\n\t\t// to next line\n#ifdef FEAT_FOLDING\n\t\t// Move to the end of a closed fold.\n\t\t(void)hasFolding(curwin->w_cursor.lnum, NULL,\n\t\t\t\t\t\t      &curwin->w_cursor.lnum);\n#endif\n\t\tif (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\tcurwin->w_cursor.lnum++;\n\t\tcurwin->w_curswant %= width2;\n\t\t// Check if the cursor has moved below the number display\n\t\t// when width1 < width2 (with cpoptions+=n). Subtract width2\n\t\t// to get a negative value for w_curswant, which will get\n\t\t// clipped to column 0.\n\t\tif (curwin->w_curswant >= width1)\n\t\t    curwin->w_curswant -= width2;\n\t\tlinelen = linetabsize(ml_get_curline());\n\t    }\n\t}\n      }\n    }\n\n    if (virtual_active() && atend)\n\tcoladvance(MAXCOL);\n    else\n\tcoladvance(curwin->w_curswant);\n\n    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)\n    {\n\tcolnr_T virtcol;\n\n\t/*\n\t * Check for landing on a character that got split at the end of the\n\t * last line.  We want to advance a screenline, not end up in the same\n\t * screenline or move two screenlines.\n\t */\n\tvalidate_virtcol();\n\tvirtcol = curwin->w_virtcol;\n#if defined(FEAT_LINEBREAK)\n\tif (virtcol > (colnr_T)width1 && *get_showbreak_value(curwin) != NUL)\n\t    virtcol -= vim_strsize(get_showbreak_value(curwin));\n#endif\n\n\tif (virtcol > curwin->w_curswant\n\t\t&& (curwin->w_curswant < (colnr_T)width1\n\t\t    ? (curwin->w_curswant > (colnr_T)width1 / 2)\n\t\t    : ((curwin->w_curswant - width1) % width2\n\t\t\t\t\t\t      > (colnr_T)width2 / 2)))\n\t    --curwin->w_cursor.col;\n    }\n\n    if (atend)\n\tcurwin->w_curswant = MAXCOL;\t    // stick in the last column\n\n    return retval;\n}\n\n/*\n * Handle CTRL-E and CTRL-Y commands: scroll a line up or down.\n * cap->arg must be TRUE for CTRL-E.\n */\n    void\nnv_scroll_line(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n\tscroll_redraw(cap->arg, cap->count1);\n}\n\n/*\n * Scroll \"count\" lines up or down, and redraw.\n */\n    void\nscroll_redraw(int up, long count)\n{\n    linenr_T\tprev_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    int\t\tprev_topfill = curwin->w_topfill;\n#endif\n    linenr_T\tprev_lnum = curwin->w_cursor.lnum;\n\n    if (up)\n\tscrollup(count, TRUE);\n    else\n\tscrolldown(count, TRUE);\n    if (get_scrolloff_value())\n    {\n\t// Adjust the cursor position for 'scrolloff'.  Mark w_topline as\n\t// valid, otherwise the screen jumps back at the end of the file.\n\tcursor_correct();\n\tcheck_cursor_moved(curwin);\n\tcurwin->w_valid |= VALID_TOPLINE;\n\n\t// If moved back to where we were, at least move the cursor, otherwise\n\t// we get stuck at one position.  Don't move the cursor up if the\n\t// first line of the buffer is already on the screen\n\twhile (curwin->w_topline == prev_topline\n#ifdef FEAT_DIFF\n\t\t&& curwin->w_topfill == prev_topfill\n#endif\n\t\t)\n\t{\n\t    if (up)\n\t    {\n\t\tif (curwin->w_cursor.lnum > prev_lnum\n\t\t\t|| cursor_down(1L, FALSE) == FAIL)\n\t\t    break;\n\t    }\n\t    else\n\t    {\n\t\tif (curwin->w_cursor.lnum < prev_lnum\n\t\t\t|| prev_topline == 1L\n\t\t\t|| cursor_up(1L, FALSE) == FAIL)\n\t\t    break;\n\t    }\n\t    // Mark w_topline as valid, otherwise the screen jumps back at the\n\t    // end of the file.\n\t    check_cursor_moved(curwin);\n\t    curwin->w_valid |= VALID_TOPLINE;\n\t}\n    }\n    if (curwin->w_cursor.lnum != prev_lnum)\n\tcoladvance(curwin->w_curswant);\n    redraw_later(VALID);\n}\n\n/*\n * Commands that start with \"z\".\n */\n    static void\nnv_zet(cmdarg_T *cap)\n{\n    long\tn;\n    colnr_T\tcol;\n    int\t\tnchar = cap->nchar;\n#ifdef FEAT_FOLDING\n    long\told_fdl = curwin->w_p_fdl;\n    int\t\told_fen = curwin->w_p_fen;\n#endif\n#ifdef FEAT_SPELL\n    int\t\tundo = FALSE;\n#endif\n    long        siso = get_sidescrolloff_value();\n\n    if (VIM_ISDIGIT(nchar))\n    {\n\t/*\n\t * \"z123{nchar}\": edit the count before obtaining {nchar}\n\t */\n\tif (checkclearop(cap->oap))\n\t    return;\n\tn = nchar - '0';\n\tfor (;;)\n\t{\n#ifdef USE_ON_FLY_SCROLL\n\t    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t    ++no_mapping;\n\t    ++allow_keys;   // no mapping for nchar, but allow key codes\n\t    nchar = plain_vgetc();\n\t    LANGMAP_ADJUST(nchar, TRUE);\n\t    --no_mapping;\n\t    --allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t    (void)add_to_showcmd(nchar);\n#endif\n\t    if (nchar == K_DEL || nchar == K_KDEL)\n\t\tn /= 10;\n\t    else if (VIM_ISDIGIT(nchar))\n\t\tn = n * 10 + (nchar - '0');\n\t    else if (nchar == CAR)\n\t    {\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight((int)n);\n\t\tbreak;\n\t    }\n\t    else if (nchar == 'l'\n\t\t    || nchar == 'h'\n\t\t    || nchar == K_LEFT\n\t\t    || nchar == K_RIGHT)\n\t    {\n\t\tcap->count1 = n ? n * cap->count1 : cap->count1;\n\t\tgoto dozet;\n\t    }\n\t    else\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t}\n\tcap->oap->op_type = OP_NOP;\n\treturn;\n    }\n\ndozet:\n    if (\n#ifdef FEAT_FOLDING\n\t    // \"zf\" and \"zF\" are always an operator, \"zd\", \"zo\", \"zO\", \"zc\"\n\t    // and \"zC\" only in Visual mode.  \"zj\" and \"zk\" are motion\n\t    // commands.\n\t    cap->nchar != 'f' && cap->nchar != 'F'\n\t    && !(VIsual_active && vim_strchr((char_u *)\"dcCoO\", cap->nchar))\n\t    && cap->nchar != 'j' && cap->nchar != 'k'\n\t    &&\n#endif\n\t    checkclearop(cap->oap))\n\treturn;\n\n    /*\n     * For \"z+\", \"z<CR>\", \"zt\", \"z.\", \"zz\", \"z^\", \"z-\", \"zb\":\n     * If line number given, set cursor.\n     */\n    if ((vim_strchr((char_u *)\"+\\r\\nt.z^-b\", nchar) != NULL)\n\t    && cap->count0\n\t    && cap->count0 != curwin->w_cursor.lnum)\n    {\n\tsetpcmark();\n\tif (cap->count0 > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\telse\n\t    curwin->w_cursor.lnum = cap->count0;\n\tcheck_cursor_col();\n    }\n\n    switch (nchar)\n    {\n\t\t// \"z+\", \"z<CR>\" and \"zt\": put cursor at top of screen\n    case '+':\n\t\tif (cap->count0 == 0)\n\t\t{\n\t\t    // No count given: put cursor at the line below screen\n\t\t    validate_botline();\t// make sure w_botline is valid\n\t\t    if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = curwin->w_botline;\n\t\t}\n\t\t// FALLTHROUGH\n    case NL:\n    case CAR:\n    case K_KENTER:\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 't':\tscroll_cursor_top(0, TRUE);\n\t\tredraw_later(VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"z.\" and \"zz\": put cursor in middle of screen\n    case '.':\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 'z':\tscroll_cursor_halfway(TRUE);\n\t\tredraw_later(VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"z^\", \"z-\" and \"zb\": put cursor at bottom of screen\n    case '^':\t// Strange Vi behavior: <count>z^ finds line at top of window\n\t\t// when <count> is at bottom of window, and puts that one at\n\t\t// bottom of window.\n\t\tif (cap->count0 != 0)\n\t\t{\n\t\t    scroll_cursor_bot(0, TRUE);\n\t\t    curwin->w_cursor.lnum = curwin->w_topline;\n\t\t}\n\t\telse if (curwin->w_topline == 1)\n\t\t    curwin->w_cursor.lnum = 1;\n\t\telse\n\t\t    curwin->w_cursor.lnum = curwin->w_topline - 1;\n\t\t// FALLTHROUGH\n    case '-':\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 'b':\tscroll_cursor_bot(0, TRUE);\n\t\tredraw_later(VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"zH\" - scroll screen right half-page\n    case 'H':\n\t\tcap->count1 *= curwin->w_width / 2;\n\t\t// FALLTHROUGH\n\n\t\t// \"zh\" - scroll screen to the right\n    case 'h':\n    case K_LEFT:\n\t\tif (!curwin->w_p_wrap)\n\t\t{\n\t\t    if ((colnr_T)cap->count1 > curwin->w_leftcol)\n\t\t\tcurwin->w_leftcol = 0;\n\t\t    else\n\t\t\tcurwin->w_leftcol -= (colnr_T)cap->count1;\n\t\t    leftcol_changed();\n\t\t}\n\t\tbreak;\n\n\t\t// \"zL\" - scroll screen left half-page\n    case 'L':\tcap->count1 *= curwin->w_width / 2;\n\t\t// FALLTHROUGH\n\n\t\t// \"zl\" - scroll screen to the left\n    case 'l':\n    case K_RIGHT:\n\t\tif (!curwin->w_p_wrap)\n\t\t{\n\t\t    // scroll the window left\n\t\t    curwin->w_leftcol += (colnr_T)cap->count1;\n\t\t    leftcol_changed();\n\t\t}\n\t\tbreak;\n\n\t\t// \"zs\" - scroll screen, cursor at the start\n    case 's':\tif (!curwin->w_p_wrap)\n\t\t{\n#ifdef FEAT_FOLDING\n\t\t    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t\tcol = 0;\t// like the cursor is in col 0\n\t\t    else\n#endif\n\t\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, NULL);\n\t\t    if ((long)col > siso)\n\t\t\tcol -= siso;\n\t\t    else\n\t\t\tcol = 0;\n\t\t    if (curwin->w_leftcol != col)\n\t\t    {\n\t\t\tcurwin->w_leftcol = col;\n\t\t\tredraw_later(NOT_VALID);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\t// \"ze\" - scroll screen, cursor at the end\n    case 'e':\tif (!curwin->w_p_wrap)\n\t\t{\n#ifdef FEAT_FOLDING\n\t\t    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t\tcol = 0;\t// like the cursor is in col 0\n\t\t    else\n#endif\n\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\t\t    n = curwin->w_width - curwin_col_off();\n\t\t    if ((long)col + siso < n)\n\t\t\tcol = 0;\n\t\t    else\n\t\t\tcol = col + siso - n + 1;\n\t\t    if (curwin->w_leftcol != col)\n\t\t    {\n\t\t\tcurwin->w_leftcol = col;\n\t\t\tredraw_later(NOT_VALID);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\t// \"zp\", \"zP\" in block mode put without addind trailing spaces\n    case 'P':\n    case 'p':  nv_put(cap);\n\t       break;\n\t\t// \"zy\" Yank without trailing spaces\n    case 'y':  nv_operator(cap);\n\t       break;\n#ifdef FEAT_FOLDING\n\t\t// \"zF\": create fold command\n\t\t// \"zf\": create fold operator\n    case 'F':\n    case 'f':   if (foldManualAllowed(TRUE))\n\t\t{\n\t\t    cap->nchar = 'f';\n\t\t    nv_operator(cap);\n\t\t    curwin->w_p_fen = TRUE;\n\n\t\t    // \"zF\" is like \"zfzf\"\n\t\t    if (nchar == 'F' && cap->oap->op_type == OP_FOLD)\n\t\t    {\n\t\t\tnv_operator(cap);\n\t\t\tfinish_op = TRUE;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    clearopbeep(cap->oap);\n\t\tbreak;\n\n\t\t// \"zd\": delete fold at cursor\n\t\t// \"zD\": delete fold at cursor recursively\n    case 'd':\n    case 'D':\tif (foldManualAllowed(FALSE))\n\t\t{\n\t\t    if (VIsual_active)\n\t\t\tnv_operator(cap);\n\t\t    else\n\t\t\tdeleteFold(curwin->w_cursor.lnum,\n\t\t\t\t  curwin->w_cursor.lnum, nchar == 'D', FALSE);\n\t\t}\n\t\tbreak;\n\n\t\t// \"zE\": erase all folds\n    case 'E':\tif (foldmethodIsManual(curwin))\n\t\t{\n\t\t    clearFolding(curwin);\n\t\t    changed_window_setting();\n\t\t}\n\t\telse if (foldmethodIsMarker(curwin))\n\t\t    deleteFold((linenr_T)1, curbuf->b_ml.ml_line_count,\n\t\t\t\t\t\t\t\t TRUE, FALSE);\n\t\telse\n\t\t    emsg(_(\"E352: Cannot erase folds with current 'foldmethod'\"));\n\t\tbreak;\n\n\t\t// \"zn\": fold none: reset 'foldenable'\n    case 'n':\tcurwin->w_p_fen = FALSE;\n\t\tbreak;\n\n\t\t// \"zN\": fold Normal: set 'foldenable'\n    case 'N':\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zi\": invert folding: toggle 'foldenable'\n    case 'i':\tcurwin->w_p_fen = !curwin->w_p_fen;\n\t\tbreak;\n\n\t\t// \"za\": open closed fold or close open fold at cursor\n    case 'a':\tif (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t    openFold(curwin->w_cursor.lnum, cap->count1);\n\t\telse\n\t\t{\n\t\t    closeFold(curwin->w_cursor.lnum, cap->count1);\n\t\t    curwin->w_p_fen = TRUE;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zA\": open fold at cursor recursively\n    case 'A':\tif (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t    openFoldRecurse(curwin->w_cursor.lnum);\n\t\telse\n\t\t{\n\t\t    closeFoldRecurse(curwin->w_cursor.lnum);\n\t\t    curwin->w_p_fen = TRUE;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zo\": open fold at cursor or Visual area\n    case 'o':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    openFold(curwin->w_cursor.lnum, cap->count1);\n\t\tbreak;\n\n\t\t// \"zO\": open fold recursively\n    case 'O':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    openFoldRecurse(curwin->w_cursor.lnum);\n\t\tbreak;\n\n\t\t// \"zc\": close fold at cursor or Visual area\n    case 'c':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    closeFold(curwin->w_cursor.lnum, cap->count1);\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zC\": close fold recursively\n    case 'C':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    closeFoldRecurse(curwin->w_cursor.lnum);\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zv\": open folds at the cursor\n    case 'v':\tfoldOpenCursor();\n\t\tbreak;\n\n\t\t// \"zx\": re-apply 'foldlevel' and open folds at the cursor\n    case 'x':\tcurwin->w_p_fen = TRUE;\n\t\tcurwin->w_foldinvalid = TRUE;\t// recompute folds\n\t\tnewFoldLevel();\t\t\t// update right now\n\t\tfoldOpenCursor();\n\t\tbreak;\n\n\t\t// \"zX\": undo manual opens/closes, re-apply 'foldlevel'\n    case 'X':\tcurwin->w_p_fen = TRUE;\n\t\tcurwin->w_foldinvalid = TRUE;\t// recompute folds\n\t\told_fdl = -1;\t\t\t// force an update\n\t\tbreak;\n\n\t\t// \"zm\": fold more\n    case 'm':\tif (curwin->w_p_fdl > 0)\n\t\t{\n\t\t    curwin->w_p_fdl -= cap->count1;\n\t\t    if (curwin->w_p_fdl < 0)\n\t\t\tcurwin->w_p_fdl = 0;\n\t\t}\n\t\told_fdl = -1;\t\t// force an update\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zM\": close all folds\n    case 'M':\tcurwin->w_p_fdl = 0;\n\t\told_fdl = -1;\t\t// force an update\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zr\": reduce folding\n    case 'r':\tcurwin->w_p_fdl += cap->count1;\n\t\t{\n\t\t    int d = getDeepestNesting();\n\n\t\t    if (curwin->w_p_fdl >= d)\n\t\t\tcurwin->w_p_fdl = d;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zR\": open all folds\n    case 'R':\tcurwin->w_p_fdl = getDeepestNesting();\n\t\told_fdl = -1;\t\t// force an update\n\t\tbreak;\n\n    case 'j':\t// \"zj\" move to next fold downwards\n    case 'k':\t// \"zk\" move to next fold upwards\n\t\tif (foldMoveTo(TRUE, nchar == 'j' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t  cap->count1) == FAIL)\n\t\t    clearopbeep(cap->oap);\n\t\tbreak;\n\n#endif // FEAT_FOLDING\n\n#ifdef FEAT_SPELL\n    case 'u':\t// \"zug\" and \"zuw\": undo \"zg\" and \"zw\"\n\t\t++no_mapping;\n\t\t++allow_keys;   // no mapping for nchar, but allow key codes\n\t\tnchar = plain_vgetc();\n\t\tLANGMAP_ADJUST(nchar, TRUE);\n\t\t--no_mapping;\n\t\t--allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t\t(void)add_to_showcmd(nchar);\n#endif\n\t\tif (vim_strchr((char_u *)\"gGwW\", nchar) == NULL)\n\t\t{\n\t\t    clearopbeep(cap->oap);\n\t\t    break;\n\t\t}\n\t\tundo = TRUE;\n\t\t// FALLTHROUGH\n\n    case 'g':\t// \"zg\": add good word to word list\n    case 'w':\t// \"zw\": add wrong word to word list\n    case 'G':\t// \"zG\": add good word to temp word list\n    case 'W':\t// \"zW\": add wrong word to temp word list\n\t\t{\n\t\t    char_u  *ptr = NULL;\n\t\t    int\t    len;\n\n\t\t    if (checkclearop(cap->oap))\n\t\t\tbreak;\n\t\t    if (VIsual_active && get_visual_text(cap, &ptr, &len)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\treturn;\n\t\t    if (ptr == NULL)\n\t\t    {\n\t\t\tpos_T\tpos = curwin->w_cursor;\n\n\t\t\t// Find bad word under the cursor.  When 'spell' is\n\t\t\t// off this fails and find_ident_under_cursor() is\n\t\t\t// used below.\n\t\t\temsg_off++;\n\t\t\tlen = spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL);\n\t\t\temsg_off--;\n\t\t\tif (len != 0 && curwin->w_cursor.col <= pos.col)\n\t\t\t    ptr = ml_get_pos(&curwin->w_cursor);\n\t\t\tcurwin->w_cursor = pos;\n\t\t    }\n\n\t\t    if (ptr == NULL && (len = find_ident_under_cursor(&ptr,\n\t\t\t\t\t\t\t    FIND_IDENT)) == 0)\n\t\t\treturn;\n\t\t    spell_add_word(ptr, len, nchar == 'w' || nchar == 'W'\n\t\t\t\t\t      ? SPELL_ADD_BAD : SPELL_ADD_GOOD,\n\t\t\t\t\t    (nchar == 'G' || nchar == 'W')\n\t\t\t\t\t\t       ? 0 : (int)cap->count1,\n\t\t\t\t\t    undo);\n\t\t}\n\t\tbreak;\n\n    case '=':\t// \"z=\": suggestions for a badly spelled word\n\t\tif (!checkclearop(cap->oap))\n\t\t    spell_suggest((int)cap->count0);\n\t\tbreak;\n#endif\n\n    default:\tclearopbeep(cap->oap);\n    }\n\n#ifdef FEAT_FOLDING\n    // Redraw when 'foldenable' changed\n    if (old_fen != curwin->w_p_fen)\n    {\n# ifdef FEAT_DIFF\n\twin_T\t    *wp;\n\n\tif (foldmethodIsDiff(curwin) && curwin->w_p_scb)\n\t{\n\t    // Adjust 'foldenable' in diff-synced windows.\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tif (wp != curwin && foldmethodIsDiff(wp) && wp->w_p_scb)\n\t\t{\n\t\t    wp->w_p_fen = curwin->w_p_fen;\n\t\t    changed_window_setting_win(wp);\n\t\t}\n\t    }\n\t}\n# endif\n\tchanged_window_setting();\n    }\n\n    // Redraw when 'foldlevel' changed.\n    if (old_fdl != curwin->w_p_fdl)\n\tnewFoldLevel();\n#endif\n}\n\n#ifdef FEAT_GUI\n/*\n * Vertical scrollbar movement.\n */\n    static void\nnv_ver_scrollbar(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to scroll\n    gui_do_scroll();\n}\n\n/*\n * Horizontal scrollbar movement.\n */\n    static void\nnv_hor_scrollbar(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to scroll\n    gui_do_horiz_scroll(scrollbar_value, FALSE);\n}\n#endif\n\n#if defined(FEAT_GUI_TABLINE) || defined(PROTO)\n/*\n * Click in GUI tab.\n */\n    static void\nnv_tabline(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to jump tabs.\n    goto_tabpage(current_tab);\n}\n\n/*\n * Selected item in tab line menu.\n */\n    static void\nnv_tabmenu(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to jump tabs.\n    handle_tabmenu();\n}\n\n/*\n * Handle selecting an item of the GUI tab line menu.\n * Used in Normal and Insert mode.\n */\n    void\nhandle_tabmenu(void)\n{\n    switch (current_tabmenu)\n    {\n\tcase TABLINE_MENU_CLOSE:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"tabclose\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"tabclose %d\",\n\t\t\t\t\t\t\t\t current_tab);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n\n\tcase TABLINE_MENU_NEW:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"$tabnew\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"%dtabnew\",\n\t\t\t\t\t\t\t     current_tab - 1);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n\n\tcase TABLINE_MENU_OPEN:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"browse $tabnew\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"browse %dtabnew\",\n\t\t\t\t\t\t\t     current_tab - 1);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n    }\n}\n#endif\n\n/*\n * \"Q\" command.\n */\n    static void\nnv_exmode(cmdarg_T *cap)\n{\n    /*\n     * Ignore 'Q' in Visual mode, just give a beep.\n     */\n    if (VIsual_active)\n\tvim_beep(BO_EX);\n    else if (!checkclearop(cap->oap))\n\tdo_exmode(FALSE);\n}\n\n/*\n * Handle a \":\" command.\n */\n    static void\nnv_colon(cmdarg_T *cap)\n{\n    int\told_p_im;\n    int\tcmd_result;\n    int\tis_cmdkey = cap->cmdchar == K_COMMAND;\n\n    if (VIsual_active && !is_cmdkey)\n\tnv_operator(cap);\n    else\n    {\n\tif (cap->oap->op_type != OP_NOP)\n\t{\n\t    // Using \":\" as a movement is characterwise exclusive.\n\t    cap->oap->motion_type = MCHAR;\n\t    cap->oap->inclusive = FALSE;\n\t}\n\telse if (cap->count0 && !is_cmdkey)\n\t{\n\t    // translate \"count:\" into \":.,.+(count - 1)\"\n\t    stuffcharReadbuff('.');\n\t    if (cap->count0 > 1)\n\t    {\n\t\tstuffReadbuff((char_u *)\",.+\");\n\t\tstuffnumReadbuff((long)cap->count0 - 1L);\n\t    }\n\t}\n\n\t// When typing, don't type below an old message\n\tif (KeyTyped)\n\t    compute_cmdrow();\n\n\told_p_im = p_im;\n\n\t// get a command line and execute it\n\tcmd_result = do_cmdline(NULL, is_cmdkey ? getcmdkeycmd : getexline, NULL,\n\t\t\t    cap->oap->op_type != OP_NOP ? DOCMD_KEEPLINE : 0);\n\n\t// If 'insertmode' changed, enter or exit Insert mode\n\tif (p_im != old_p_im)\n\t{\n\t    if (p_im)\n\t\trestart_edit = 'i';\n\t    else\n\t\trestart_edit = 0;\n\t}\n\n\tif (cmd_result == FAIL)\n\t    // The Ex command failed, do not execute the operator.\n\t    clearop(cap->oap);\n\telse if (cap->oap->op_type != OP_NOP\n\t\t&& (cap->oap->start.lnum > curbuf->b_ml.ml_line_count\n\t\t    || cap->oap->start.col >\n\t\t\t       (colnr_T)STRLEN(ml_get(cap->oap->start.lnum))\n\t\t    || did_emsg\n\t\t    ))\n\t    // The start of the operator has become invalid by the Ex command.\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * Handle CTRL-G command.\n */\n    static void\nnv_ctrlg(cmdarg_T *cap)\n{\n    if (VIsual_active)\t// toggle Selection/Visual mode\n    {\n\tVIsual_select = !VIsual_select;\n\tshowmode();\n    }\n    else if (!checkclearop(cap->oap))\n\t// print full name if count given or :cd used\n\tfileinfo((int)cap->count0, FALSE, TRUE);\n}\n\n/*\n * Handle CTRL-H <Backspace> command.\n */\n    static void\nnv_ctrlh(cmdarg_T *cap)\n{\n    if (VIsual_active && VIsual_select)\n    {\n\tcap->cmdchar = 'x';\t// BS key behaves like 'x' in Select mode\n\tv_visop(cap);\n    }\n    else\n\tnv_left(cap);\n}\n\n/*\n * CTRL-L: clear screen and redraw.\n */\n    static void\nnv_clear(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n#ifdef FEAT_SYN_HL\n\t// Clear all syntax states to force resyncing.\n\tsyn_stack_free_all(curwin->w_s);\n# ifdef FEAT_RELTIME\n\t{\n\t    win_T *wp;\n\n\t    FOR_ALL_WINDOWS(wp)\n\t\twp->w_s->b_syn_slow = FALSE;\n\t}\n# endif\n#endif\n\tredraw_later(CLEAR);\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n\tif (!gui.in_use)\n# endif\n\t    resize_console_buf();\n#endif\n    }\n}\n\n/*\n * CTRL-O: In Select mode: switch to Visual mode for one command.\n * Otherwise: Go to older pcmark.\n */\n    static void\nnv_ctrlo(cmdarg_T *cap)\n{\n    if (VIsual_active && VIsual_select)\n    {\n\tVIsual_select = FALSE;\n\tshowmode();\n\trestart_VIsual_select = 2;\t// restart Select mode later\n    }\n    else\n    {\n\tcap->count1 = -cap->count1;\n\tnv_pcmark(cap);\n    }\n}\n\n/*\n * CTRL-^ command, short for \":e #\".  Works even when the alternate buffer is\n * not named.\n */\n    static void\nnv_hat(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\t(void)buflist_getfile((int)cap->count0, (linenr_T)0,\n\t\t\t\t\t\tGETF_SETMARK|GETF_ALT, FALSE);\n}\n\n/*\n * \"Z\" commands.\n */\n    static void\nnv_Zet(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n\tswitch (cap->nchar)\n\t{\n\t\t\t// \"ZZ\": equivalent to \":x\".\n\t    case 'Z':\tdo_cmdline_cmd((char_u *)\"x\");\n\t\t\tbreak;\n\n\t\t\t// \"ZQ\": equivalent to \":q!\" (Elvis compatible).\n\t    case 'Q':\tdo_cmdline_cmd((char_u *)\"q!\");\n\t\t\tbreak;\n\n\t    default:\tclearopbeep(cap->oap);\n\t}\n    }\n}\n\n/*\n * Call nv_ident() as if \"c1\" was used, with \"c2\" as next character.\n */\n    void\ndo_nv_ident(int c1, int c2)\n{\n    oparg_T\toa;\n    cmdarg_T\tca;\n\n    clear_oparg(&oa);\n    CLEAR_FIELD(ca);\n    ca.oap = &oa;\n    ca.cmdchar = c1;\n    ca.nchar = c2;\n    nv_ident(&ca);\n}\n\n/*\n * Handle the commands that use the word under the cursor.\n * [g] CTRL-]\t:ta to current identifier\n * [g] 'K'\trun program for current identifier\n * [g] '*'\t/ to current identifier or string\n * [g] '#'\t? to current identifier or string\n *  g  ']'\t:tselect for current identifier\n */\n    static void\nnv_ident(cmdarg_T *cap)\n{\n    char_u\t*ptr = NULL;\n    char_u\t*buf;\n    unsigned\tbuflen;\n    char_u\t*newbuf;\n    char_u\t*p;\n    char_u\t*kp;\t\t// value of 'keywordprg'\n    int\t\tkp_help;\t// 'keywordprg' is \":he\"\n    int\t\tkp_ex;\t\t// 'keywordprg' starts with \":\"\n    int\t\tn = 0;\t\t// init for GCC\n    int\t\tcmdchar;\n    int\t\tg_cmd;\t\t// \"g\" command\n    int\t\ttag_cmd = FALSE;\n    char_u\t*aux_ptr;\n    int\t\tisman;\n    int\t\tisman_s;\n\n    if (cap->cmdchar == 'g')\t// \"g*\", \"g#\", \"g]\" and \"gCTRL-]\"\n    {\n\tcmdchar = cap->nchar;\n\tg_cmd = TRUE;\n    }\n    else\n    {\n\tcmdchar = cap->cmdchar;\n\tg_cmd = FALSE;\n    }\n\n    if (cmdchar == POUND)\t// the pound sign, '#' for English keyboards\n\tcmdchar = '#';\n\n    /*\n     * The \"]\", \"CTRL-]\" and \"K\" commands accept an argument in Visual mode.\n     */\n    if (cmdchar == ']' || cmdchar == Ctrl_RSB || cmdchar == 'K')\n    {\n\tif (VIsual_active && get_visual_text(cap, &ptr, &n) == FAIL)\n\t    return;\n\tif (checkclearopq(cap->oap))\n\t    return;\n    }\n\n    if (ptr == NULL && (n = find_ident_under_cursor(&ptr,\n\t\t    (cmdchar == '*' || cmdchar == '#')\n\t\t\t\t ? FIND_IDENT|FIND_STRING : FIND_IDENT)) == 0)\n    {\n\tclearop(cap->oap);\n\treturn;\n    }\n\n    // Allocate buffer to put the command in.  Inserting backslashes can\n    // double the length of the word.  p_kp / curbuf->b_p_kp could be added\n    // and some numbers.\n    kp = (*curbuf->b_p_kp == NUL ? p_kp : curbuf->b_p_kp);\n    kp_help = (*kp == NUL || STRCMP(kp, \":he\") == 0\n\t\t\t\t\t\t || STRCMP(kp, \":help\") == 0);\n    if (kp_help && *skipwhite(ptr) == NUL)\n    {\n\temsg(_(e_noident));\t // found white space only\n\treturn;\n    }\n    kp_ex = (*kp == ':');\n    buflen = (unsigned)(n * 2 + 30 + STRLEN(kp));\n    buf = alloc(buflen);\n    if (buf == NULL)\n\treturn;\n    buf[0] = NUL;\n\n    switch (cmdchar)\n    {\n\tcase '*':\n\tcase '#':\n\t    /*\n\t     * Put cursor at start of word, makes search skip the word\n\t     * under the cursor.\n\t     * Call setpcmark() first, so \"*``\" puts the cursor back where\n\t     * it was.\n\t     */\n\t    setpcmark();\n\t    curwin->w_cursor.col = (colnr_T) (ptr - ml_get_curline());\n\n\t    if (!g_cmd && vim_iswordp(ptr))\n\t\tSTRCPY(buf, \"\\\\<\");\n\t    no_smartcase = TRUE;\t// don't use 'smartcase' now\n\t    break;\n\n\tcase 'K':\n\t    if (kp_help)\n\t\tSTRCPY(buf, \"he! \");\n\t    else if (kp_ex)\n\t    {\n\t\tif (cap->count0 != 0)\n\t\t    vim_snprintf((char *)buf, buflen, \"%s %ld\",\n\t\t\t\t\t\t\t     kp, cap->count0);\n\t\telse\n\t\t    STRCPY(buf, kp);\n\t\tSTRCAT(buf, \" \");\n\t    }\n\t    else\n\t    {\n\t\t// An external command will probably use an argument starting\n\t\t// with \"-\" as an option.  To avoid trouble we skip the \"-\".\n\t\twhile (*ptr == '-' && n > 0)\n\t\t{\n\t\t    ++ptr;\n\t\t    --n;\n\t\t}\n\t\tif (n == 0)\n\t\t{\n\t\t    emsg(_(e_noident));\t // found dashes only\n\t\t    vim_free(buf);\n\t\t    return;\n\t\t}\n\n\t\t// When a count is given, turn it into a range.  Is this\n\t\t// really what we want?\n\t\tisman = (STRCMP(kp, \"man\") == 0);\n\t\tisman_s = (STRCMP(kp, \"man -s\") == 0);\n\t\tif (cap->count0 != 0 && !(isman || isman_s))\n\t\t    sprintf((char *)buf, \".,.+%ld\", cap->count0 - 1);\n\n\t\tSTRCAT(buf, \"! \");\n\t\tif (cap->count0 == 0 && isman_s)\n\t\t    STRCAT(buf, \"man\");\n\t\telse\n\t\t    STRCAT(buf, kp);\n\t\tSTRCAT(buf, \" \");\n\t\tif (cap->count0 != 0 && (isman || isman_s))\n\t\t{\n\t\t    sprintf((char *)buf + STRLEN(buf), \"%ld\", cap->count0);\n\t\t    STRCAT(buf, \" \");\n\t\t}\n\t    }\n\t    break;\n\n\tcase ']':\n\t    tag_cmd = TRUE;\n#ifdef FEAT_CSCOPE\n\t    if (p_cst)\n\t\tSTRCPY(buf, \"cstag \");\n\t    else\n#endif\n\t\tSTRCPY(buf, \"ts \");\n\t    break;\n\n\tdefault:\n\t    tag_cmd = TRUE;\n\t    if (curbuf->b_help)\n\t\tSTRCPY(buf, \"he! \");\n\t    else\n\t    {\n\t\tif (g_cmd)\n\t\t    STRCPY(buf, \"tj \");\n\t\telse if (cap->count0 == 0)\n\t\t    STRCPY(buf, \"ta \");\n\t\telse\n\t\t    sprintf((char *)buf, \":%ldta \", cap->count0);\n\t    }\n    }\n\n    /*\n     * Now grab the chars in the identifier\n     */\n    if (cmdchar == 'K' && !kp_help)\n    {\n\tptr = vim_strnsave(ptr, n);\n\tif (kp_ex)\n\t    // Escape the argument properly for an Ex command\n\t    p = vim_strsave_fnameescape(ptr, FALSE);\n\telse\n\t    // Escape the argument properly for a shell command\n\t    p = vim_strsave_shellescape(ptr, TRUE, TRUE);\n\tvim_free(ptr);\n\tif (p == NULL)\n\t{\n\t    vim_free(buf);\n\t    return;\n\t}\n\tnewbuf = vim_realloc(buf, STRLEN(buf) + STRLEN(p) + 1);\n\tif (newbuf == NULL)\n\t{\n\t    vim_free(buf);\n\t    vim_free(p);\n\t    return;\n\t}\n\tbuf = newbuf;\n\tSTRCAT(buf, p);\n\tvim_free(p);\n    }\n    else\n    {\n\tif (cmdchar == '*')\n\t    aux_ptr = (char_u *)(magic_isset() ? \"/.*~[^$\\\\\" : \"/^$\\\\\");\n\telse if (cmdchar == '#')\n\t    aux_ptr = (char_u *)(magic_isset() ? \"/?.*~[^$\\\\\" : \"/?^$\\\\\");\n\telse if (tag_cmd)\n\t{\n\t    if (curbuf->b_help)\n\t\t// \":help\" handles unescaped argument\n\t\taux_ptr = (char_u *)\"\";\n\t    else\n\t\taux_ptr = (char_u *)\"\\\\|\\\"\\n[\";\n\t}\n\telse\n\t    aux_ptr = (char_u *)\"\\\\|\\\"\\n*?[\";\n\n\tp = buf + STRLEN(buf);\n\twhile (n-- > 0)\n\t{\n\t    // put a backslash before \\ and some others\n\t    if (vim_strchr(aux_ptr, *ptr) != NULL)\n\t\t*p++ = '\\\\';\n\t    // When current byte is a part of multibyte character, copy all\n\t    // bytes of that character.\n\t    if (has_mbyte)\n\t    {\n\t\tint i;\n\t\tint len = (*mb_ptr2len)(ptr) - 1;\n\n\t\tfor (i = 0; i < len && n >= 1; ++i, --n)\n\t\t    *p++ = *ptr++;\n\t    }\n\t    *p++ = *ptr++;\n\t}\n\t*p = NUL;\n    }\n\n    /*\n     * Execute the command.\n     */\n    if (cmdchar == '*' || cmdchar == '#')\n    {\n\tif (!g_cmd && (has_mbyte\n\t\t    ? vim_iswordp(mb_prevptr(ml_get_curline(), ptr))\n\t\t    : vim_iswordc(ptr[-1])))\n\t    STRCAT(buf, \"\\\\>\");\n\n\t// put pattern in search history\n\tinit_history();\n\tadd_to_history(HIST_SEARCH, buf, TRUE, NUL);\n\n\t(void)normal_search(cap, cmdchar == '*' ? '/' : '?', buf, 0, NULL);\n    }\n    else\n    {\n\tg_tag_at_cursor = TRUE;\n\tdo_cmdline_cmd(buf);\n\tg_tag_at_cursor = FALSE;\n    }\n\n    vim_free(buf);\n}\n\n/*\n * Get visually selected text, within one line only.\n * Returns FAIL if more than one line selected.\n */\n    int\nget_visual_text(\n    cmdarg_T\t*cap,\n    char_u\t**pp,\t    // return: start of selected text\n    int\t\t*lenp)\t    // return: length of selected text\n{\n    if (VIsual_mode != 'V')\n\tunadjust_for_sel();\n    if (VIsual.lnum != curwin->w_cursor.lnum)\n    {\n\tif (cap != NULL)\n\t    clearopbeep(cap->oap);\n\treturn FAIL;\n    }\n    if (VIsual_mode == 'V')\n    {\n\t*pp = ml_get_curline();\n\t*lenp = (int)STRLEN(*pp);\n    }\n    else\n    {\n\tif (LT_POS(curwin->w_cursor, VIsual))\n\t{\n\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (has_mbyte)\n\t    // Correct the length to include the whole last character.\n\t    *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}\n\n/*\n * CTRL-T: backwards in tag stack\n */\n    static void\nnv_tagpop(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\tdo_tag((char_u *)\"\", DT_POP, (int)cap->count1, FALSE, TRUE);\n}\n\n/*\n * Handle scrolling command 'H', 'L' and 'M'.\n */\n    static void\nnv_scroll(cmdarg_T *cap)\n{\n    int\t\tused = 0;\n    long\tn;\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\thalf;\n\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    if (cap->cmdchar == 'L')\n    {\n\tvalidate_botline();\t    // make sure curwin->w_botline is valid\n\tcurwin->w_cursor.lnum = curwin->w_botline - 1;\n\tif (cap->count1 - 1 >= curwin->w_cursor.lnum)\n\t    curwin->w_cursor.lnum = 1;\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tfor (n = cap->count1 - 1; n > 0\n\t\t\t    && curwin->w_cursor.lnum > curwin->w_topline; --n)\n\t\t{\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\t\t    --curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tcurwin->w_cursor.lnum -= cap->count1 - 1;\n\t}\n    }\n    else\n    {\n\tif (cap->cmdchar == 'M')\n\t{\n#ifdef FEAT_DIFF\n\t    // Don't count filler lines above the window.\n\t    used -= diff_check_fill(curwin, curwin->w_topline)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#endif\n\t    validate_botline();\t    // make sure w_empty_rows is valid\n\t    half = (curwin->w_height - curwin->w_empty_rows + 1) / 2;\n\t    for (n = 0; curwin->w_topline + n < curbuf->b_ml.ml_line_count; ++n)\n\t    {\n#ifdef FEAT_DIFF\n\t\t// Count half he number of filler lines to be \"below this\n\t\t// line\" and half to be \"above the next line\".\n\t\tif (n > 0 && used + diff_check_fill(curwin, curwin->w_topline\n\t\t\t\t\t\t\t     + n) / 2 >= half)\n\t\t{\n\t\t    --n;\n\t\t    break;\n\t\t}\n#endif\n\t\tused += plines(curwin->w_topline + n);\n\t\tif (used >= half)\n\t\t    break;\n#ifdef FEAT_FOLDING\n\t\tif (hasFolding(curwin->w_topline + n, NULL, &lnum))\n\t\t    n = lnum - curwin->w_topline;\n#endif\n\t    }\n\t    if (n > 0 && used > curwin->w_height)\n\t\t--n;\n\t}\n\telse // (cap->cmdchar == 'H')\n\t{\n\t    n = cap->count1 - 1;\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tlnum = curwin->w_topline;\n\t\twhile (n-- > 0 && lnum < curwin->w_botline - 1)\n\t\t{\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t    ++lnum;\n\t\t}\n\t\tn = lnum - curwin->w_topline;\n\t    }\n#endif\n\t}\n\tcurwin->w_cursor.lnum = curwin->w_topline + n;\n\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    }\n\n    // Correct for 'so', except when an operator is pending.\n    if (cap->oap->op_type == OP_NOP)\n\tcursor_correct();\n    beginline(BL_SOL | BL_FIX);\n}\n\n/*\n * Cursor right commands.\n */\n    static void\nnv_right(cmdarg_T *cap)\n{\n    long\tn;\n    int\t\tpast_line;\n\n    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n    {\n\t// <C-Right> and <S-Right> move a word or WORD right\n\tif (mod_mask & MOD_MASK_CTRL)\n\t    cap->arg = TRUE;\n\tnv_wordcmd(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    past_line = (VIsual_active && *p_sel != 'o');\n\n    /*\n     * In virtual edit mode, there's no such thing as \"past_line\", as lines\n     * are (theoretically) infinitely long.\n     */\n    if (virtual_active())\n\tpast_line = 0;\n\n    for (n = cap->count1; n > 0; --n)\n    {\n\tif ((!past_line && oneright() == FAIL)\n\t\t|| (past_line && *ml_get_cursor() == NUL)\n\t\t)\n\t{\n\t    /*\n\t     *\t  <Space> wraps to next line if 'whichwrap' has 's'.\n\t     *\t      'l' wraps to next line if 'whichwrap' has 'l'.\n\t     * CURS_RIGHT wraps to next line if 'whichwrap' has '>'.\n\t     */\n\t    if (       ((cap->cmdchar == ' '\n\t\t\t    && vim_strchr(p_ww, 's') != NULL)\n\t\t\t|| (cap->cmdchar == 'l'\n\t\t\t    && vim_strchr(p_ww, 'l') != NULL)\n\t\t\t|| (cap->cmdchar == K_RIGHT\n\t\t\t    && vim_strchr(p_ww, '>') != NULL))\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// When deleting we also count the NL as a character.\n\t\t// Set cap->oap->inclusive when last char in the line is\n\t\t// included, move to next line after that\n\t\tif (\t   cap->oap->op_type != OP_NOP\n\t\t\t&& !cap->oap->inclusive\n\t\t\t&& !LINEEMPTY(curwin->w_cursor.lnum))\n\t\t    cap->oap->inclusive = TRUE;\n\t\telse\n\t\t{\n\t\t    ++curwin->w_cursor.lnum;\n\t\t    curwin->w_cursor.col = 0;\n\t\t    curwin->w_cursor.coladd = 0;\n\t\t    curwin->w_set_curswant = TRUE;\n\t\t    cap->oap->inclusive = FALSE;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    if (cap->oap->op_type == OP_NOP)\n\t    {\n\t\t// Only beep and flush if not moved at all\n\t\tif (n == cap->count1)\n\t\t    beep_flush();\n\t    }\n\t    else\n\t    {\n\t\tif (!LINEEMPTY(curwin->w_cursor.lnum))\n\t\t    cap->oap->inclusive = TRUE;\n\t    }\n\t    break;\n\t}\n\telse if (past_line)\n\t{\n\t    curwin->w_set_curswant = TRUE;\n\t    if (virtual_active())\n\t\toneright();\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t    curwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t\telse\n\t\t    ++curwin->w_cursor.col;\n\t    }\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Cursor left commands.\n *\n * Returns TRUE when operator end should not be adjusted.\n */\n    static void\nnv_left(cmdarg_T *cap)\n{\n    long\tn;\n\n    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n    {\n\t// <C-Left> and <S-Left> move a word or WORD left\n\tif (mod_mask & MOD_MASK_CTRL)\n\t    cap->arg = 1;\n\tnv_bck_word(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    for (n = cap->count1; n > 0; --n)\n    {\n\tif (oneleft() == FAIL)\n\t{\n\t    // <BS> and <Del> wrap to previous line if 'whichwrap' has 'b'.\n\t    //\t\t 'h' wraps to previous line if 'whichwrap' has 'h'.\n\t    //\t   CURS_LEFT wraps to previous line if 'whichwrap' has '<'.\n\t    if (       (((cap->cmdchar == K_BS\n\t\t\t\t|| cap->cmdchar == Ctrl_H)\n\t\t\t    && vim_strchr(p_ww, 'b') != NULL)\n\t\t\t|| (cap->cmdchar == 'h'\n\t\t\t    && vim_strchr(p_ww, 'h') != NULL)\n\t\t\t|| (cap->cmdchar == K_LEFT\n\t\t\t    && vim_strchr(p_ww, '<') != NULL))\n\t\t    && curwin->w_cursor.lnum > 1)\n\t    {\n\t\t--(curwin->w_cursor.lnum);\n\t\tcoladvance((colnr_T)MAXCOL);\n\t\tcurwin->w_set_curswant = TRUE;\n\n\t\t// When the NL before the first char has to be deleted we\n\t\t// put the cursor on the NUL after the previous line.\n\t\t// This is a very special case, be careful!\n\t\t// Don't adjust op_end now, otherwise it won't work.\n\t\tif (\t   (cap->oap->op_type == OP_DELETE\n\t\t\t    || cap->oap->op_type == OP_CHANGE)\n\t\t\t&& !LINEEMPTY(curwin->w_cursor.lnum))\n\t\t{\n\t\t    char_u *cp = ml_get_cursor();\n\n\t\t    if (*cp != NUL)\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t    curwin->w_cursor.col += (*mb_ptr2len)(cp);\n\t\t\telse\n\t\t\t    ++curwin->w_cursor.col;\n\t\t    }\n\t\t    cap->retval |= CA_NO_ADJ_OP_END;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    // Only beep and flush if not moved at all\n\t    else if (cap->oap->op_type == OP_NOP && n == cap->count1)\n\t\tbeep_flush();\n\t    break;\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Cursor up commands.\n * cap->arg is TRUE for \"-\": Move cursor to first non-blank.\n */\n    static void\nnv_up(cmdarg_T *cap)\n{\n    if (mod_mask & MOD_MASK_SHIFT)\n    {\n\t// <S-Up> is page up\n\tcap->arg = BACKWARD;\n\tnv_page(cap);\n    }\n    else\n    {\n\tcap->oap->motion_type = MLINE;\n\tif (cursor_up(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)\n\t    clearopbeep(cap->oap);\n\telse if (cap->arg)\n\t    beginline(BL_WHITE | BL_FIX);\n    }\n}\n\n/*\n * Cursor down commands.\n * cap->arg is TRUE for CR and \"+\": Move cursor to first non-blank.\n */\n    static void\nnv_down(cmdarg_T *cap)\n{\n    if (mod_mask & MOD_MASK_SHIFT)\n    {\n\t// <S-Down> is page down\n\tcap->arg = FORWARD;\n\tnv_page(cap);\n    }\n#if defined(FEAT_QUICKFIX)\n    // Quickfix window only: view the result under the cursor.\n    else if (bt_quickfix(curbuf) && cap->cmdchar == CAR)\n\tqf_view_result(FALSE);\n#endif\n    else\n    {\n#ifdef FEAT_CMDWIN\n\t// In the cmdline window a <CR> executes the command.\n\tif (cmdwin_type != 0 && cap->cmdchar == CAR)\n\t    cmdwin_result = CAR;\n\telse\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t// In a prompt buffer a <CR> in the last line invokes the callback.\n\tif (bt_prompt(curbuf) && cap->cmdchar == CAR\n\t\t       && curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t{\n\t    invoke_prompt_callback();\n\t    if (restart_edit == 0)\n\t\trestart_edit = 'a';\n\t}\n\telse\n#endif\n\t{\n\t    cap->oap->motion_type = MLINE;\n\t    if (cursor_down(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)\n\t\tclearopbeep(cap->oap);\n\t    else if (cap->arg)\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t}\n    }\n}\n\n#ifdef FEAT_SEARCHPATH\n/*\n * Grab the file name under the cursor and edit it.\n */\n    static void\nnv_gotofile(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    linenr_T\tlnum = -1;\n\n    if (text_locked())\n    {\n\tclearopbeep(cap->oap);\n\ttext_locked_msg();\n\treturn;\n    }\n    if (curbuf_locked())\n    {\n\tclearop(cap->oap);\n\treturn;\n    }\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n\n    ptr = grab_file_name(cap->count1, &lnum);\n\n    if (ptr != NULL)\n    {\n\t// do autowrite if necessary\n\tif (curbufIsChanged() && curbuf->b_nwindows <= 1 && !buf_hide(curbuf))\n\t    (void)autowrite(curbuf, FALSE);\n\tsetpcmark();\n\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,\n\t\t\t\tbuf_hide(curbuf) ? ECMD_HIDE : 0, curwin) == OK\n\t\t&& cap->nchar == 'F' && lnum >= 0)\n\t{\n\t    curwin->w_cursor.lnum = lnum;\n\t    check_cursor_lnum();\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n\tvim_free(ptr);\n    }\n    else\n\tclearop(cap->oap);\n}\n#endif\n\n/*\n * <End> command: to end of current line or last line.\n */\n    static void\nnv_end(cmdarg_T *cap)\n{\n    if (cap->arg || (mod_mask & MOD_MASK_CTRL))\t// CTRL-END = goto last line\n    {\n\tcap->arg = TRUE;\n\tnv_goto(cap);\n\tcap->count1 = 1;\t\t// to end of current line\n    }\n    nv_dollar(cap);\n}\n\n/*\n * Handle the \"$\" command.\n */\n    static void\nnv_dollar(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = TRUE;\n    // In virtual mode when off the edge of a line and an operator\n    // is pending (whew!) keep the cursor where it is.\n    // Otherwise, send it to the end of the line.\n    if (!virtual_active() || gchar_cursor() != NUL\n\t\t\t\t\t       || cap->oap->op_type == OP_NOP)\n\tcurwin->w_curswant = MAXCOL;\t// so we stay at the end\n    if (cursor_down((long)(cap->count1 - 1),\n\t\t\t\t\t cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Implementation of '?' and '/' commands.\n * If cap->arg is TRUE don't set PC mark.\n */\n    static void\nnv_search(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    pos_T\tsave_cursor = curwin->w_cursor;\n\n    if (cap->cmdchar == '?' && cap->oap->op_type == OP_ROT13)\n    {\n\t// Translate \"g??\" to \"g?g?\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = '?';\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // When using 'incsearch' the cursor may be moved to set a different search\n    // start position.\n    cap->searchbuf = getcmdline(cap->cmdchar, cap->count1, 0, TRUE);\n\n    if (cap->searchbuf == NULL)\n    {\n\tclearop(oap);\n\treturn;\n    }\n\n    (void)normal_search(cap, cap->cmdchar, cap->searchbuf,\n\t\t\t(cap->arg || !EQUAL_POS(save_cursor, curwin->w_cursor))\n\t\t\t\t\t\t      ? 0 : SEARCH_MARK, NULL);\n}\n\n/*\n * Handle \"N\" and \"n\" commands.\n * cap->arg is SEARCH_REV for \"N\", 0 for \"n\".\n */\n    static void\nnv_next(cmdarg_T *cap)\n{\n    pos_T   old = curwin->w_cursor;\n    int\t    wrapped = FALSE;\n    int\t    i = normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, &wrapped);\n\n    if (i == 1 && !wrapped && EQUAL_POS(old, curwin->w_cursor))\n    {\n\t// Avoid getting stuck on the current cursor position, which can\n\t// happen when an offset is given and the cursor is on the last char\n\t// in the buffer: Repeat with count + 1.\n\tcap->count1 += 1;\n\t(void)normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, NULL);\n\tcap->count1 -= 1;\n    }\n}\n\n/*\n * Search for \"pat\" in direction \"dir\" ('/' or '?', 0 for repeat).\n * Uses only cap->count1 and cap->oap from \"cap\".\n * Return 0 for failure, 1 for found, 2 for found and line offset added.\n */\n    static int\nnormal_search(\n    cmdarg_T\t*cap,\n    int\t\tdir,\n    char_u\t*pat,\n    int\t\topt,\t\t// extra flags for do_search()\n    int\t\t*wrapped)\n{\n    int\t\ti;\n    searchit_arg_T sia;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    cap->oap->use_reg_one = TRUE;\n    curwin->w_set_curswant = TRUE;\n\n    CLEAR_FIELD(sia);\n    i = do_search(cap->oap, dir, dir, pat, cap->count1,\n\t\t\t    opt | SEARCH_OPT | SEARCH_ECHO | SEARCH_MSG, &sia);\n    if (wrapped != NULL)\n\t*wrapped = sia.sa_wrapped;\n    if (i == 0)\n\tclearop(cap->oap);\n    else\n    {\n\tif (i == 2)\n\t    cap->oap->motion_type = MLINE;\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n#endif\n    }\n\n    // \"/$\" will put the cursor after the end of the line, may need to\n    // correct that here\n    check_cursor();\n    return i;\n}\n\n/*\n * Character search commands.\n * cap->arg is BACKWARD for 'F' and 'T', FORWARD for 'f' and 't', TRUE for\n * ',' and FALSE for ';'.\n * cap->nchar is NUL for ',' and ';' (repeat the search)\n */\n    static void\nnv_csearch(cmdarg_T *cap)\n{\n    int\t\tt_cmd;\n\n    if (cap->cmdchar == 't' || cap->cmdchar == 'T')\n\tt_cmd = TRUE;\n    else\n\tt_cmd = FALSE;\n\n    cap->oap->motion_type = MCHAR;\n    if (IS_SPECIAL(cap->nchar) || searchc(cap, t_cmd) == FAIL)\n\tclearopbeep(cap->oap);\n    else\n    {\n\tcurwin->w_set_curswant = TRUE;\n\t// Include a Tab for \"tx\" and for \"dfx\".\n\tif (gchar_cursor() == TAB && virtual_active() && cap->arg == FORWARD\n\t\t&& (t_cmd || cap->oap->op_type != OP_NOP))\n\t{\n\t    colnr_T\tscol, ecol;\n\n\t    getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);\n\t    curwin->w_cursor.coladd = ecol - scol;\n\t}\n\telse\n\t    curwin->w_cursor.coladd = 0;\n\tadjust_for_sel(cap);\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"[\" and \"]\" commands.\n * cap->arg is BACKWARD for \"[\" and FORWARD for \"]\".\n */\n    static void\nnv_brackets(cmdarg_T *cap)\n{\n    pos_T\tnew_pos = {0, 0, 0};\n    pos_T\tprev_pos;\n    pos_T\t*pos = NULL;\t    // init for GCC\n    pos_T\told_pos;\t    // cursor position before command\n    int\t\tflag;\n    long\tn;\n    int\t\tfindc;\n    int\t\tc;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    old_pos = curwin->w_cursor;\n    curwin->w_cursor.coladd = 0;    // TODO: don't do this for an error.\n\n#ifdef FEAT_SEARCHPATH\n    /*\n     * \"[f\" or \"]f\" : Edit file under the cursor (same as \"gf\")\n     */\n    if (cap->nchar == 'f')\n\tnv_gotofile(cap);\n    else\n#endif\n\n#ifdef FEAT_FIND_ID\n    /*\n     * Find the occurrence(s) of the identifier or define under cursor\n     * in current and included files or jump to the first occurrence.\n     *\n     *\t\t\tsearch\t     list\t    jump\n     *\t\t      fwd   bwd    fwd\t bwd\t fwd\tbwd\n     * identifier     \"]i\"  \"[i\"   \"]I\"  \"[I\"\t\"]^I\"  \"[^I\"\n     * define\t      \"]d\"  \"[d\"   \"]D\"  \"[D\"\t\"]^D\"  \"[^D\"\n     */\n    if (vim_strchr((char_u *)\n# ifdef EBCDIC\n\t\t\"iI\\005dD\\067\",\n# else\n\t\t\"iI\\011dD\\004\",\n# endif\n\t\tcap->nchar) != NULL)\n    {\n\tchar_u\t*ptr;\n\tint\tlen;\n\n\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t    clearop(cap->oap);\n\telse\n\t{\n\t    find_pattern_in_path(ptr, 0, len, TRUE,\n\t\tcap->count0 == 0 ? !isupper(cap->nchar) : FALSE,\n\t\t((cap->nchar & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,\n\t\tcap->count1,\n\t\tisupper(cap->nchar) ? ACTION_SHOW_ALL :\n\t\t\t    islower(cap->nchar) ? ACTION_SHOW : ACTION_GOTO,\n\t\tcap->cmdchar == ']' ? curwin->w_cursor.lnum + 1 : (linenr_T)1,\n\t\t(linenr_T)MAXLNUM);\n\t    curwin->w_set_curswant = TRUE;\n\t}\n    }\n    else\n#endif\n\n    /*\n     * \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n     * \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n     * \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n     * \"[m\" or \"]m\" search for prev/next start of (Java) method.\n     * \"[M\" or \"]M\" search for prev/next end of (Java) method.\n     */\n    if (  (cap->cmdchar == '['\n\t\t&& vim_strchr((char_u *)\"{(*/#mM\", cap->nchar) != NULL)\n\t    || (cap->cmdchar == ']'\n\t\t&& vim_strchr((char_u *)\"})*/#mM\", cap->nchar) != NULL))\n    {\n\tif (cap->nchar == '*')\n\t    cap->nchar = '/';\n\tprev_pos.lnum = 0;\n\tif (cap->nchar == 'm' || cap->nchar == 'M')\n\t{\n\t    if (cap->cmdchar == '[')\n\t\tfindc = '{';\n\t    else\n\t\tfindc = '}';\n\t    n = 9999;\n\t}\n\telse\n\t{\n\t    findc = cap->nchar;\n\t    n = cap->count1;\n\t}\n\tfor ( ; n > 0; --n)\n\t{\n\t    if ((pos = findmatchlimit(cap->oap, findc,\n\t\t(cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD, 0)) == NULL)\n\t    {\n\t\tif (new_pos.lnum == 0)\t// nothing found\n\t\t{\n\t\t    if (cap->nchar != 'm' && cap->nchar != 'M')\n\t\t\tclearopbeep(cap->oap);\n\t\t}\n\t\telse\n\t\t    pos = &new_pos;\t// use last one found\n\t\tbreak;\n\t    }\n\t    prev_pos = new_pos;\n\t    curwin->w_cursor = *pos;\n\t    new_pos = *pos;\n\t}\n\tcurwin->w_cursor = old_pos;\n\n\t/*\n\t * Handle \"[m\", \"]m\", \"[M\" and \"[M\".  The findmatchlimit() only\n\t * brought us to the match for \"[m\" and \"]M\" when inside a method.\n\t * Try finding the '{' or '}' we want to be at.\n\t * Also repeat for the given count.\n\t */\n\tif (cap->nchar == 'm' || cap->nchar == 'M')\n\t{\n\t    // norm is TRUE for \"]M\" and \"[m\"\n\t    int\t    norm = ((findc == '{') == (cap->nchar == 'm'));\n\n\t    n = cap->count1;\n\t    // found a match: we were inside a method\n\t    if (prev_pos.lnum != 0)\n\t    {\n\t\tpos = &prev_pos;\n\t\tcurwin->w_cursor = prev_pos;\n\t\tif (norm)\n\t\t    --n;\n\t    }\n\t    else\n\t\tpos = NULL;\n\t    while (n > 0)\n\t    {\n\t\tfor (;;)\n\t\t{\n\t\t    if ((findc == '{' ? dec_cursor() : inc_cursor()) < 0)\n\t\t    {\n\t\t\t// if not found anything, that's an error\n\t\t\tif (pos == NULL)\n\t\t\t    clearopbeep(cap->oap);\n\t\t\tn = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    c = gchar_cursor();\n\t\t    if (c == '{' || c == '}')\n\t\t    {\n\t\t\t// Must have found end/start of class: use it.\n\t\t\t// Or found the place to be at.\n\t\t\tif ((c == findc && norm) || (n == 1 && !norm))\n\t\t\t{\n\t\t\t    new_pos = curwin->w_cursor;\n\t\t\t    pos = &new_pos;\n\t\t\t    n = 0;\n\t\t\t}\n\t\t\t// if no match found at all, we started outside of the\n\t\t\t// class and we're inside now.  Just go on.\n\t\t\telse if (new_pos.lnum == 0)\n\t\t\t{\n\t\t\t    new_pos = curwin->w_cursor;\n\t\t\t    pos = &new_pos;\n\t\t\t}\n\t\t\t// found start/end of other method: go to match\n\t\t\telse if ((pos = findmatchlimit(cap->oap, findc,\n\t\t\t    (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD,\n\t\t\t\t\t\t\t\t  0)) == NULL)\n\t\t\t    n = 0;\n\t\t\telse\n\t\t\t    curwin->w_cursor = *pos;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t--n;\n\t    }\n\t    curwin->w_cursor = old_pos;\n\t    if (pos == NULL && new_pos.lnum != 0)\n\t\tclearopbeep(cap->oap);\n\t}\n\tif (pos != NULL)\n\t{\n\t    setpcmark();\n\t    curwin->w_cursor = *pos;\n\t    curwin->w_set_curswant = TRUE;\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_BLOCK) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\t\tfoldOpenCursor();\n#endif\n\t}\n    }\n\n    /*\n     * \"[[\", \"[]\", \"]]\" and \"][\": move to start or end of function\n     */\n    else if (cap->nchar == '[' || cap->nchar == ']')\n    {\n\tif (cap->nchar == cap->cmdchar)\t\t    // \"]]\" or \"[[\"\n\t    flag = '{';\n\telse\n\t    flag = '}';\t\t    // \"][\" or \"[]\"\n\n\tcurwin->w_set_curswant = TRUE;\n\t/*\n\t * Imitate strange Vi behaviour: When using \"]]\" with an operator\n\t * we also stop at '}'.\n\t */\n\tif (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,\n\t      (cap->oap->op_type != OP_NOP\n\t\t\t\t      && cap->arg == FORWARD && flag == '{')))\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    if (cap->oap->op_type == OP_NOP)\n\t\tbeginline(BL_WHITE | BL_FIX);\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t\tfoldOpenCursor();\n#endif\n\t}\n    }\n\n    /*\n     * \"[p\", \"[P\", \"]P\" and \"]p\": put with indent adjustment\n     */\n    else if (cap->nchar == 'p' || cap->nchar == 'P')\n    {\n\tnv_put_opt(cap, TRUE);\n    }\n\n    /*\n     * \"['\", \"[`\", \"]'\" and \"]`\": jump to next mark\n     */\n    else if (cap->nchar == '\\'' || cap->nchar == '`')\n    {\n\tpos = &curwin->w_cursor;\n\tfor (n = cap->count1; n > 0; --n)\n\t{\n\t    prev_pos = *pos;\n\t    pos = getnextmark(pos, cap->cmdchar == '[' ? BACKWARD : FORWARD,\n\t\t\t\t\t\t\t  cap->nchar == '\\'');\n\t    if (pos == NULL)\n\t\tbreak;\n\t}\n\tif (pos == NULL)\n\t    pos = &prev_pos;\n\tnv_cursormark(cap, cap->nchar == '\\'', pos);\n    }\n\n    /*\n     * [ or ] followed by a middle mouse click: put selected text with\n     * indent adjustment.  Any other button just does as usual.\n     */\n    else if (cap->nchar >= K_RIGHTRELEASE && cap->nchar <= K_LEFTMOUSE)\n    {\n\t(void)do_mouse(cap->oap, cap->nchar,\n\t\t       (cap->cmdchar == ']') ? FORWARD : BACKWARD,\n\t\t       cap->count1, PUT_FIXINDENT);\n    }\n\n#ifdef FEAT_FOLDING\n    /*\n     * \"[z\" and \"]z\": move to start or end of open fold.\n     */\n    else if (cap->nchar == 'z')\n    {\n\tif (foldMoveTo(FALSE, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    /*\n     * \"[c\" and \"]c\": move to next or previous diff-change.\n     */\n    else if (cap->nchar == 'c')\n    {\n\tif (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    /*\n     * \"[s\", \"[S\", \"]s\" and \"]S\": move to next spell error.\n     */\n    else if (cap->nchar == 's' || cap->nchar == 'S')\n    {\n\tsetpcmark();\n\tfor (n = 0; n < cap->count1; ++n)\n\t    if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t  cap->nchar == 's' ? TRUE : FALSE, FALSE, NULL) == 0)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n#endif\n\n    // Not a valid cap->nchar.\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle Normal mode \"%\" command.\n */\n    static void\nnv_percent(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n#if defined(FEAT_FOLDING)\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n#endif\n\n    cap->oap->inclusive = TRUE;\n    if (cap->count0)\t    // {cnt}% : goto {cnt} percentage in file\n    {\n\tif (cap->count0 > 100)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    cap->oap->motion_type = MLINE;\n\t    setpcmark();\n\t    // Round up, so 'normal 100%' always jumps at the line line.\n\t    // Beyond 21474836 lines, (ml_line_count * 100 + 99) would\n\t    // overflow on 32-bits, so use a formula with less accuracy\n\t    // to avoid overflows.\n\t    if (curbuf->b_ml.ml_line_count >= 21474836)\n\t\tcurwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count + 99L)\n\t\t\t\t\t\t\t / 100L * cap->count0;\n\t    else\n\t\tcurwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count *\n\t\t\t\t\t\t    cap->count0 + 99L) / 100L;\n\t    if (curwin->w_cursor.lnum < 1)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n    }\n    else\t\t    // \"%\" : go to matching paren\n    {\n\tcap->oap->motion_type = MCHAR;\n\tcap->oap->use_reg_one = TRUE;\n\tif ((pos = findmatch(cap->oap, NUL)) == NULL)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    setpcmark();\n\t    curwin->w_cursor = *pos;\n\t    curwin->w_set_curswant = TRUE;\n\t    curwin->w_cursor.coladd = 0;\n\t    adjust_for_sel(cap);\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && lnum != curwin->w_cursor.lnum\n\t    && (fdo_flags & FDO_PERCENT)\n\t    && KeyTyped)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle \"(\" and \")\" commands.\n * cap->arg is BACKWARD for \"(\" and FORWARD for \")\".\n */\n    static void\nnv_brace(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->use_reg_one = TRUE;\n    // The motion used to be inclusive for \"(\", but that is not what Vi does.\n    cap->oap->inclusive = FALSE;\n    curwin->w_set_curswant = TRUE;\n\n    if (findsent(cap->arg, cap->count1) == FAIL)\n\tclearopbeep(cap->oap);\n    else\n    {\n\t// Don't leave the cursor on the NUL past end of line.\n\tadjust_cursor(cap->oap);\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"m\" command: Mark a position.\n */\n    static void\nnv_mark(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n\tif (setmark(cap->nchar) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * \"{\" and \"}\" commands.\n * cmd->arg is BACKWARD for \"{\" and FORWARD for \"}\".\n */\n    static void\nnv_findpar(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    cap->oap->use_reg_one = TRUE;\n    curwin->w_set_curswant = TRUE;\n    if (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, NUL, FALSE))\n\tclearopbeep(cap->oap);\n    else\n    {\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"u\" command: Undo or make lower case.\n */\n    static void\nnv_undo(cmdarg_T *cap)\n{\n    if (cap->oap->op_type == OP_LOWER || VIsual_active)\n    {\n\t// translate \"<Visual>u\" to \"<Visual>gu\" and \"guu\" to \"gugu\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'u';\n\tnv_operator(cap);\n    }\n    else\n\tnv_kundo(cap);\n}\n\n/*\n * <Undo> command.\n */\n    static void\nnv_kundo(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf))\n\t{\n\t    clearopbeep(cap->oap);\n\t    return;\n\t}\n#endif\n\tu_undo((int)cap->count1);\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * Handle the \"r\" command.\n */\n    static void\nnv_replace(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    int\t\thad_ctrl_v;\n    long\tn;\n\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    // get another character\n    if (cap->nchar == Ctrl_V)\n    {\n\thad_ctrl_v = Ctrl_V;\n\tcap->nchar = get_literal(FALSE);\n\t// Don't redo a multibyte character with CTRL-V.\n\tif (cap->nchar > DEL)\n\t    had_ctrl_v = NUL;\n    }\n    else\n\thad_ctrl_v = NUL;\n\n    // Abort if the character is a special key.\n    if (IS_SPECIAL(cap->nchar))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    // Visual mode \"r\"\n    if (VIsual_active)\n    {\n\tif (got_int)\n\t    reset_VIsual();\n\tif (had_ctrl_v)\n\t{\n\t    // Use a special (negative) number to make a difference between a\n\t    // literal CR or NL and a line break.\n\t    if (cap->nchar == CAR)\n\t\tcap->nchar = REPLACE_CR_NCHAR;\n\t    else if (cap->nchar == NL)\n\t\tcap->nchar = REPLACE_NL_NCHAR;\n\t}\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // Break tabs, etc.\n    if (virtual_active())\n    {\n\tif (u_save_cursor() == FAIL)\n\t    return;\n\tif (gchar_cursor() == NUL)\n\t{\n\t    // Add extra space and put the cursor on the first one.\n\t    coladvance_force((colnr_T)(getviscol() + cap->count1));\n\t    curwin->w_cursor.col -= cap->count1;\n\t}\n\telse if (gchar_cursor() == TAB)\n\t    coladvance_force(getviscol());\n    }\n\n    // Abort if not enough characters to replace.\n    ptr = ml_get_cursor();\n    if (STRLEN(ptr) < (unsigned)cap->count1\n\t    || (has_mbyte && mb_charlen(ptr) < cap->count1))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    /*\n     * Replacing with a TAB is done by edit() when it is complicated because\n     * 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.\n     * Other characters are done below to avoid problems with things like\n     * CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).\n     */\n    if (had_ctrl_v != Ctrl_V && cap->nchar == '\\t' && (curbuf->b_p_et || p_sta))\n    {\n\tstuffnumReadbuff(cap->count1);\n\tstuffcharReadbuff('R');\n\tstuffcharReadbuff('\\t');\n\tstuffcharReadbuff(ESC);\n\treturn;\n    }\n\n    // save line for undo\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    if (had_ctrl_v != Ctrl_V && (cap->nchar == '\\r' || cap->nchar == '\\n'))\n    {\n\t/*\n\t * Replace character(s) by a single newline.\n\t * Strange vi behaviour: Only one newline is inserted.\n\t * Delete the characters here.\n\t * Insert the newline with an insert command, takes care of\n\t * autoindent.\tThe insert command depends on being on the last\n\t * character of a line or not.\n\t */\n\t(void)del_chars(cap->count1, FALSE);\t// delete the characters\n\tstuffcharReadbuff('\\r');\n\tstuffcharReadbuff(ESC);\n\n\t// Give 'r' to edit(), to get the redo command right.\n\tinvoke_edit(cap, TRUE, 'r', FALSE);\n    }\n    else\n    {\n\tprep_redo(cap->oap->regname, cap->count1,\n\t\t\t\t       NUL, 'r', NUL, had_ctrl_v, cap->nchar);\n\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tif (has_mbyte)\n\t{\n\t    int\t\told_State = State;\n\n\t    if (cap->ncharC1 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC1);\n\t    if (cap->ncharC2 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC2);\n\n\t    // This is slow, but it handles replacing a single-byte with a\n\t    // multi-byte and the other way around.  Also handles adding\n\t    // composing characters for utf-8.\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\tState = REPLACE;\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t    int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\t\t    if (c != NUL)\n\t\t\tins_char(c);\n\t\t    else\n\t\t\t// will be decremented further down\n\t\t\t++curwin->w_cursor.col;\n\t\t}\n\t\telse\n\t\t    ins_char(cap->nchar);\n\t\tState = old_State;\n\t\tif (cap->ncharC1 != 0)\n\t\t    ins_char(cap->ncharC1);\n\t\tif (cap->ncharC2 != 0)\n\t\t    ins_char(cap->ncharC2);\n\t    }\n\t}\n\telse\n\t{\n\t    /*\n\t     * Replace the characters within one line.\n\t     */\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\t/*\n\t\t * Get ptr again, because u_save and/or showmatch() will have\n\t\t * released the line.  This may also happen in ins_copychar().\n\t\t * At the same time we let know that the line will be changed.\n\t\t */\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t  int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\n\t\t  ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t  if (c != NUL)\n\t\t    ptr[curwin->w_cursor.col] = c;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t    ptr[curwin->w_cursor.col] = cap->nchar;\n\t\t}\n\t\tif (p_sm && msg_silent == 0)\n\t\t    showmatch(cap->nchar);\n\t\t++curwin->w_cursor.col;\n\t    }\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active())\n\t    {\n\t\tcolnr_T  start = (colnr_T)(curwin->w_cursor.col - cap->count1);\n\n\t\tnetbeans_removed(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t\t\t   (long)cap->count1);\n\t\tnetbeans_inserted(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t       &ptr[start], (int)cap->count1);\n\t    }\n#endif\n\n\t    // mark the buffer as changed and prepare for displaying\n\t    changed_bytes(curwin->w_cursor.lnum,\n\t\t\t       (colnr_T)(curwin->w_cursor.col - cap->count1));\n\t}\n\t--curwin->w_cursor.col;\t    // cursor on the last replaced char\n\t// if the character on the left of the current cursor is a multi-byte\n\t// character, move two characters left\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tcurwin->w_set_curswant = TRUE;\n\tset_last_insert(cap->nchar);\n    }\n}\n\n/*\n * 'o': Exchange start and end of Visual area.\n * 'O': same, but in block mode exchange left and right corners.\n */\n    static void\nv_swap_corners(int cmdchar)\n{\n    pos_T\told_cursor;\n    colnr_T\tleft, right;\n\n    if (cmdchar == 'O' && VIsual_mode == Ctrl_V)\n    {\n\told_cursor = curwin->w_cursor;\n\tgetvcols(curwin, &old_cursor, &VIsual, &left, &right);\n\tcurwin->w_cursor.lnum = VIsual.lnum;\n\tcoladvance(left);\n\tVIsual = curwin->w_cursor;\n\n\tcurwin->w_cursor.lnum = old_cursor.lnum;\n\tcurwin->w_curswant = right;\n\t// 'selection \"exclusive\" and cursor at right-bottom corner: move it\n\t// right one column\n\tif (old_cursor.lnum >= VIsual.lnum && *p_sel == 'e')\n\t    ++curwin->w_curswant;\n\tcoladvance(curwin->w_curswant);\n\tif (curwin->w_cursor.col == old_cursor.col\n\t\t&& (!virtual_active()\n\t\t    || curwin->w_cursor.coladd == old_cursor.coladd))\n\t{\n\t    curwin->w_cursor.lnum = VIsual.lnum;\n\t    if (old_cursor.lnum <= VIsual.lnum && *p_sel == 'e')\n\t\t++right;\n\t    coladvance(right);\n\t    VIsual = curwin->w_cursor;\n\n\t    curwin->w_cursor.lnum = old_cursor.lnum;\n\t    coladvance(left);\n\t    curwin->w_curswant = left;\n\t}\n    }\n    else\n    {\n\told_cursor = curwin->w_cursor;\n\tcurwin->w_cursor = VIsual;\n\tVIsual = old_cursor;\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * \"R\" (cap->arg is FALSE) and \"gR\" (cap->arg is TRUE).\n */\n    static void\nnv_Replace(cmdarg_T *cap)\n{\n    if (VIsual_active)\t\t// \"R\" is replace lines\n    {\n\tcap->cmdchar = 'c';\n\tcap->nchar = NUL;\n\tVIsual_mode_orig = VIsual_mode; // remember original area for gv\n\tVIsual_mode = 'V';\n\tnv_operator(cap);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tif (!curbuf->b_p_ma)\n\t    emsg(_(e_cannot_make_changes_modifiable_is_off));\n\telse\n\t{\n\t    if (virtual_active())\n\t\tcoladvance(getviscol());\n\t    invoke_edit(cap, FALSE, cap->arg ? 'V' : 'R', FALSE);\n\t}\n    }\n}\n\n/*\n * \"gr\".\n */\n    static void\nnv_vreplace(cmdarg_T *cap)\n{\n    if (VIsual_active)\n    {\n\tcap->cmdchar = 'r';\n\tcap->nchar = cap->extra_char;\n\tnv_replace(cap);\t// Do same as \"r\" in Visual mode for now\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tif (!curbuf->b_p_ma)\n\t    emsg(_(e_cannot_make_changes_modifiable_is_off));\n\telse\n\t{\n\t    if (cap->extra_char == Ctrl_V)\t// get another character\n\t\tcap->extra_char = get_literal(FALSE);\n\t    stuffcharReadbuff(cap->extra_char);\n\t    stuffcharReadbuff(ESC);\n\t    if (virtual_active())\n\t\tcoladvance(getviscol());\n\t    invoke_edit(cap, TRUE, 'v', FALSE);\n\t}\n    }\n}\n\n/*\n * Swap case for \"~\" command, when it does not work like an operator.\n */\n    static void\nn_swapchar(cmdarg_T *cap)\n{\n    long\tn;\n    pos_T\tstartpos;\n    int\t\tdid_change = 0;\n#ifdef FEAT_NETBEANS_INTG\n    pos_T\tpos;\n    char_u\t*ptr;\n    int\t\tcount;\n#endif\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    if (LINEEMPTY(curwin->w_cursor.lnum) && vim_strchr(p_ww, '~') == NULL)\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    prep_redo_cmd(cap);\n\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    startpos = curwin->w_cursor;\n#ifdef FEAT_NETBEANS_INTG\n    pos = startpos;\n#endif\n    for (n = cap->count1; n > 0; --n)\n    {\n\tdid_change |= swapchar(cap->oap->op_type, &curwin->w_cursor);\n\tinc_cursor();\n\tif (gchar_cursor() == NUL)\n\t{\n\t    if (vim_strchr(p_ww, '~') != NULL\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n#ifdef FEAT_NETBEANS_INTG\n\t\tif (netbeans_active())\n\t\t{\n\t\t    if (did_change)\n\t\t    {\n\t\t\tptr = ml_get(pos.lnum);\n\t\t\tcount = (int)STRLEN(ptr) - pos.col;\n\t\t\tnetbeans_removed(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t\t (long)count);\n\t\t\tnetbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t&ptr[pos.col], count);\n\t\t    }\n\t\t    pos.col = 0;\n\t\t    pos.lnum++;\n\t\t}\n#endif\n\t\t++curwin->w_cursor.lnum;\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (n > 1)\n\t\t{\n\t\t    if (u_savesub(curwin->w_cursor.lnum) == FAIL)\n\t\t\tbreak;\n\t\t    u_clearline();\n\t\t}\n\t    }\n\t    else\n\t\tbreak;\n\t}\n    }\n#ifdef FEAT_NETBEANS_INTG\n    if (did_change && netbeans_active())\n    {\n\tptr = ml_get(pos.lnum);\n\tcount = curwin->w_cursor.col - pos.col;\n\tnetbeans_removed(curbuf, pos.lnum, pos.col, (long)count);\n\tnetbeans_inserted(curbuf, pos.lnum, pos.col, &ptr[pos.col], count);\n    }\n#endif\n\n\n    check_cursor();\n    curwin->w_set_curswant = TRUE;\n    if (did_change)\n    {\n\tchanged_lines(startpos.lnum, startpos.col, curwin->w_cursor.lnum + 1,\n\t\t\t\t\t\t\t\t\t  0L);\n\tcurbuf->b_op_start = startpos;\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tif (curbuf->b_op_end.col > 0)\n\t    --curbuf->b_op_end.col;\n    }\n}\n\n/*\n * Move cursor to mark.\n */\n    static void\nnv_cursormark(cmdarg_T *cap, int flag, pos_T *pos)\n{\n    if (check_mark(pos) == FAIL)\n\tclearop(cap->oap);\n    else\n    {\n\tif (cap->cmdchar == '\\''\n\t\t|| cap->cmdchar == '`'\n\t\t|| cap->cmdchar == '['\n\t\t|| cap->cmdchar == ']')\n\t    setpcmark();\n\tcurwin->w_cursor = *pos;\n\tif (flag)\n\t    beginline(BL_WHITE | BL_FIX);\n\telse\n\t    check_cursor();\n    }\n    cap->oap->motion_type = flag ? MLINE : MCHAR;\n    if (cap->cmdchar == '`')\n\tcap->oap->use_reg_one = TRUE;\n    cap->oap->inclusive = FALSE;\t\t// ignored if not MCHAR\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * Handle commands that are operators in Visual mode.\n */\n    static void\nv_visop(cmdarg_T *cap)\n{\n    static char_u trans[] = \"YyDdCcxdXdAAIIrr\";\n\n    // Uppercase means linewise, except in block mode, then \"D\" deletes till\n    // the end of the line, and \"C\" replaces till EOL\n    if (isupper(cap->cmdchar))\n    {\n\tif (VIsual_mode != Ctrl_V)\n\t{\n\t    VIsual_mode_orig = VIsual_mode;\n\t    VIsual_mode = 'V';\n\t}\n\telse if (cap->cmdchar == 'C' || cap->cmdchar == 'D')\n\t    curwin->w_curswant = MAXCOL;\n    }\n    cap->cmdchar = *(vim_strchr(trans, cap->cmdchar) + 1);\n    nv_operator(cap);\n}\n\n/*\n * \"s\" and \"S\" commands.\n */\n    static void\nnv_subst(cmdarg_T *cap)\n{\n#ifdef FEAT_TERMINAL\n    // When showing output of term_dumpdiff() swap the top and bottom.\n    if (term_swap_diff() == OK)\n\treturn;\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n    if (VIsual_active)\t// \"vs\" and \"vS\" are the same as \"vc\"\n    {\n\tif (cap->cmdchar == 'S')\n\t{\n\t    VIsual_mode_orig = VIsual_mode;\n\t    VIsual_mode = 'V';\n\t}\n\tcap->cmdchar = 'c';\n\tnv_operator(cap);\n    }\n    else\n\tnv_optrans(cap);\n}\n\n/*\n * Abbreviated commands.\n */\n    static void\nnv_abbrev(cmdarg_T *cap)\n{\n    if (cap->cmdchar == K_DEL || cap->cmdchar == K_KDEL)\n\tcap->cmdchar = 'x';\t\t// DEL key behaves like 'x'\n\n    // in Visual mode these commands are operators\n    if (VIsual_active)\n\tv_visop(cap);\n    else\n\tnv_optrans(cap);\n}\n\n/*\n * Translate a command into another command.\n */\n    static void\nnv_optrans(cmdarg_T *cap)\n{\n    static char_u *(ar[8]) = {(char_u *)\"dl\", (char_u *)\"dh\",\n\t\t\t      (char_u *)\"d$\", (char_u *)\"c$\",\n\t\t\t      (char_u *)\"cl\", (char_u *)\"cc\",\n\t\t\t      (char_u *)\"yy\", (char_u *)\":s\\r\"};\n    static char_u *str = (char_u *)\"xXDCsSY&\";\n\n    if (!checkclearopq(cap->oap))\n    {\n\t// In Vi \"2D\" doesn't delete the next line.  Can't translate it\n\t// either, because \"2.\" should also not use the count.\n\tif (cap->cmdchar == 'D' && vim_strchr(p_cpo, CPO_HASH) != NULL)\n\t{\n\t    cap->oap->start = curwin->w_cursor;\n\t    cap->oap->op_type = OP_DELETE;\n#ifdef FEAT_EVAL\n\t    set_op_var(OP_DELETE);\n#endif\n\t    cap->count1 = 1;\n\t    nv_dollar(cap);\n\t    finish_op = TRUE;\n\t    ResetRedobuff();\n\t    AppendCharToRedobuff('D');\n\t}\n\telse\n\t{\n\t    if (cap->count0)\n\t\tstuffnumReadbuff(cap->count0);\n\t    stuffReadbuff(ar[(int)(vim_strchr(str, cap->cmdchar) - str)]);\n\t}\n    }\n    cap->opcount = 0;\n}\n\n/*\n * \"'\" and \"`\" commands.  Also for \"g'\" and \"g`\".\n * cap->arg is TRUE for \"'\" and \"g'\".\n */\n    static void\nnv_gomark(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n    int\t\tc;\n#ifdef FEAT_FOLDING\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\told_KeyTyped = KeyTyped;    // getting file may reset it\n#endif\n\n    if (cap->cmdchar == 'g')\n\tc = cap->extra_char;\n    else\n\tc = cap->nchar;\n    pos = getmark(c, (cap->oap->op_type == OP_NOP));\n    if (pos == (pos_T *)-1)\t    // jumped to other file\n    {\n\tif (cap->arg)\n\t{\n\t    check_cursor_lnum();\n\t    beginline(BL_WHITE | BL_FIX);\n\t}\n\telse\n\t    check_cursor();\n    }\n    else\n\tnv_cursormark(cap, cap->arg, pos);\n\n    // May need to clear the coladd that a mark includes.\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    check_cursor_col();\n#ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && pos != NULL\n\t    && (pos == (pos_T *)-1 || !EQUAL_POS(old_cursor, *pos))\n\t    && (fdo_flags & FDO_MARK)\n\t    && old_KeyTyped)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle CTRL-O, CTRL-I, \"g;\", \"g,\" and \"CTRL-Tab\" commands.\n */\n    static void\nnv_pcmark(cmdarg_T *cap)\n{\n#ifdef FEAT_JUMPLIST\n    pos_T\t*pos;\n# ifdef FEAT_FOLDING\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n    int\t\told_KeyTyped = KeyTyped;    // getting file may reset it\n# endif\n\n    if (!checkclearopq(cap->oap))\n    {\n\tif (cap->cmdchar == TAB && mod_mask == MOD_MASK_CTRL)\n\t{\n\t    if (goto_tabpage_lastused() == FAIL)\n\t\tclearopbeep(cap->oap);\n\t    return;\n\t}\n\tif (cap->cmdchar == 'g')\n\t    pos = movechangelist((int)cap->count1);\n\telse\n\t    pos = movemark((int)cap->count1);\n\tif (pos == (pos_T *)-1)\t\t// jump to other file\n\t{\n\t    curwin->w_set_curswant = TRUE;\n\t    check_cursor();\n\t}\n\telse if (pos != NULL)\t\t    // can jump\n\t    nv_cursormark(cap, FALSE, pos);\n\telse if (cap->cmdchar == 'g')\n\t{\n\t    if (curbuf->b_changelistlen == 0)\n\t\temsg(_(\"E664: changelist is empty\"));\n\t    else if (cap->count1 < 0)\n\t\temsg(_(\"E662: At start of changelist\"));\n\t    else\n\t\temsg(_(\"E663: At end of changelist\"));\n\t}\n\telse\n\t    clearopbeep(cap->oap);\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP\n\t\t&& (pos == (pos_T *)-1 || lnum != curwin->w_cursor.lnum)\n\t\t&& (fdo_flags & FDO_MARK)\n\t\t&& old_KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n#else\n    clearopbeep(cap->oap);\n#endif\n}\n\n/*\n * Handle '\"' command.\n */\n    static void\nnv_regname(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_EVAL\n    if (cap->nchar == '=')\n\tcap->nchar = get_expr_register();\n#endif\n    if (cap->nchar != NUL && valid_yank_reg(cap->nchar, FALSE))\n    {\n\tcap->oap->regname = cap->nchar;\n\tcap->opcount = cap->count0;\t// remember count before '\"'\n#ifdef FEAT_EVAL\n\tset_reg_var(cap->oap->regname);\n#endif\n    }\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle \"v\", \"V\" and \"CTRL-V\" commands.\n * Also for \"gh\", \"gH\" and \"g^H\" commands: Always start Select mode, cap->arg\n * is TRUE.\n * Handle CTRL-Q just like CTRL-V.\n */\n    static void\nnv_visual(cmdarg_T *cap)\n{\n    if (cap->cmdchar == Ctrl_Q)\n\tcap->cmdchar = Ctrl_V;\n\n    // 'v', 'V' and CTRL-V can be used while an operator is pending to make it\n    // characterwise, linewise, or blockwise.\n    if (cap->oap->op_type != OP_NOP)\n    {\n\tmotion_force = cap->oap->motion_force = cap->cmdchar;\n\tfinish_op = FALSE;\t// operator doesn't finish now but later\n\treturn;\n    }\n\n    VIsual_select = cap->arg;\n    if (VIsual_active)\t    // change Visual mode\n    {\n\tif (VIsual_mode == cap->cmdchar)    // stop visual mode\n\t    end_visual_mode();\n\telse\t\t\t\t    // toggle char/block mode\n\t{\t\t\t\t    //\t   or char/line mode\n\t    VIsual_mode = cap->cmdchar;\n\t    showmode();\n\t}\n\tredraw_curbuf_later(INVERTED);\t    // update the inversion\n    }\n    else\t\t    // start Visual mode\n    {\n\tcheck_visual_highlight();\n\tif (cap->count0 > 0 && resel_VIsual_mode != NUL)\n\t{\n\t    // use previously selected part\n\t    VIsual = curwin->w_cursor;\n\n\t    VIsual_active = TRUE;\n\t    VIsual_reselect = TRUE;\n\t    if (!cap->arg)\n\t\t// start Select mode when 'selectmode' contains \"cmd\"\n\t\tmay_start_select('c');\n\t    setmouse();\n\t    if (p_smd && msg_silent == 0)\n\t\tredraw_cmdline = TRUE;\t    // show visual mode later\n\t    /*\n\t     * For V and ^V, we multiply the number of lines even if there\n\t     * was only one -- webb\n\t     */\n\t    if (resel_VIsual_mode != 'v' || resel_VIsual_line_count > 1)\n\t    {\n\t\tcurwin->w_cursor.lnum +=\n\t\t\t\t    resel_VIsual_line_count * cap->count0 - 1;\n\t\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    }\n\t    VIsual_mode = resel_VIsual_mode;\n\t    if (VIsual_mode == 'v')\n\t    {\n\t\tif (resel_VIsual_line_count <= 1)\n\t\t{\n\t\t    validate_virtcol();\n\t\t    curwin->w_curswant = curwin->w_virtcol\n\t\t\t\t\t+ resel_VIsual_vcol * cap->count0 - 1;\n\t\t}\n\t\telse\n\t\t    curwin->w_curswant = resel_VIsual_vcol;\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    if (resel_VIsual_vcol == MAXCOL)\n\t    {\n\t\tcurwin->w_curswant = MAXCOL;\n\t\tcoladvance((colnr_T)MAXCOL);\n\t    }\n\t    else if (VIsual_mode == Ctrl_V)\n\t    {\n\t\tvalidate_virtcol();\n\t\tcurwin->w_curswant = curwin->w_virtcol\n\t\t\t\t\t+ resel_VIsual_vcol * cap->count0 - 1;\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n\t    redraw_curbuf_later(INVERTED);\t// show the inversion\n\t}\n\telse\n\t{\n\t    if (!cap->arg)\n\t\t// start Select mode when 'selectmode' contains \"cmd\"\n\t\tmay_start_select('c');\n\t    n_start_visual_mode(cap->cmdchar);\n\t    if (VIsual_mode != 'V' && *p_sel == 'e')\n\t\t++cap->count1;  // include one more char\n\t    if (cap->count0 > 0 && --cap->count1 > 0)\n\t    {\n\t\t// With a count select that many characters or lines.\n\t\tif (VIsual_mode == 'v' || VIsual_mode == Ctrl_V)\n\t\t    nv_right(cap);\n\t\telse if (VIsual_mode == 'V')\n\t\t    nv_down(cap);\n\t    }\n\t}\n    }\n}\n\n/*\n * Start selection for Shift-movement keys.\n */\n    void\nstart_selection(void)\n{\n    // if 'selectmode' contains \"key\", start Select mode\n    may_start_select('k');\n    n_start_visual_mode('v');\n}\n\n/*\n * Start Select mode, if \"c\" is in 'selectmode' and not in a mapping or menu.\n */\n    void\nmay_start_select(int c)\n{\n    VIsual_select = (stuff_empty() && typebuf_typed()\n\t\t    && (vim_strchr(p_slm, c) != NULL));\n}\n\n/*\n * Start Visual mode \"c\".\n * Should set VIsual_select before calling this.\n */\n    static void\nn_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n\n    // Corner case: the 0 position in a tab may change when going into\n    // virtualedit.  Recalculate curwin->w_cursor to avoid bad highlighting.\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n\n    setmouse();\n#ifdef FEAT_CONCEAL\n    // Check if redraw is needed after changing the state.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t// show visual mode later\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end may still be the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n\n    // Only need to redraw this line, unless still need to redraw an old\n    // Visual area (when 'lazyredraw' is set).\n    if (curwin->w_redr_type < INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}\n\n\n/*\n * CTRL-W: Window commands\n */\n    static void\nnv_window(cmdarg_T *cap)\n{\n    if (cap->nchar == ':')\n    {\n\t// \"CTRL-W :\" is the same as typing \":\"; useful in a terminal window\n\tcap->cmdchar = ':';\n\tcap->nchar = NUL;\n\tnv_colon(cap);\n    }\n    else if (!checkclearop(cap->oap))\n\tdo_window(cap->nchar, cap->count0, NUL); // everything is in window.c\n}\n\n/*\n * CTRL-Z: Suspend\n */\n    static void\nnv_suspend(cmdarg_T *cap)\n{\n    clearop(cap->oap);\n    if (VIsual_active)\n\tend_visual_mode();\t\t// stop Visual mode\n    do_cmdline_cmd((char_u *)\"stop\");\n}\n\n/*\n * Commands starting with \"g\".\n */\n    static void\nnv_g_cmd(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    pos_T\ttpos;\n    int\t\ti;\n    int\t\tflag = FALSE;\n\n    switch (cap->nchar)\n    {\n    case Ctrl_A:\n    case Ctrl_X:\n#ifdef MEM_PROFILE\n    /*\n     * \"g^A\": dump log of used memory.\n     */\n\tif (!VIsual_active && cap->nchar == Ctrl_A)\n\t    vim_mem_profile_dump();\n\telse\n#endif\n    /*\n     * \"g^A/g^X\": sequentially increment visually selected region\n     */\n\t     if (VIsual_active)\n\t{\n\t    cap->arg = TRUE;\n\t    cap->cmdchar = cap->nchar;\n\t    cap->nchar = NUL;\n\t    nv_addsub(cap);\n\t}\n\telse\n\t    clearopbeep(oap);\n\tbreak;\n\n    /*\n     * \"gR\": Enter virtual replace mode.\n     */\n    case 'R':\n\tcap->arg = TRUE;\n\tnv_Replace(cap);\n\tbreak;\n\n    case 'r':\n\tnv_vreplace(cap);\n\tbreak;\n\n    case '&':\n\tdo_cmdline_cmd((char_u *)\"%s//~/&\");\n\tbreak;\n\n    /*\n     * \"gv\": Reselect the previous Visual area.  If Visual already active,\n     *\t     exchange previous and current Visual area.\n     */\n    case 'v':\n\tif (checkclearop(oap))\n\t    break;\n\n\tif (\t   curbuf->b_visual.vi_start.lnum == 0\n\t\t|| curbuf->b_visual.vi_start.lnum > curbuf->b_ml.ml_line_count\n\t\t|| curbuf->b_visual.vi_end.lnum == 0)\n\t    beep_flush();\n\telse\n\t{\n\t    // set w_cursor to the start of the Visual area, tpos to the end\n\t    if (VIsual_active)\n\t    {\n\t\ti = VIsual_mode;\n\t\tVIsual_mode = curbuf->b_visual.vi_mode;\n\t\tcurbuf->b_visual.vi_mode = i;\n# ifdef FEAT_EVAL\n\t\tcurbuf->b_visual_mode_eval = i;\n# endif\n\t\ti = curwin->w_curswant;\n\t\tcurwin->w_curswant = curbuf->b_visual.vi_curswant;\n\t\tcurbuf->b_visual.vi_curswant = i;\n\n\t\ttpos = curbuf->b_visual.vi_end;\n\t\tcurbuf->b_visual.vi_end = curwin->w_cursor;\n\t\tcurwin->w_cursor = curbuf->b_visual.vi_start;\n\t\tcurbuf->b_visual.vi_start = VIsual;\n\t    }\n\t    else\n\t    {\n\t\tVIsual_mode = curbuf->b_visual.vi_mode;\n\t\tcurwin->w_curswant = curbuf->b_visual.vi_curswant;\n\t\ttpos = curbuf->b_visual.vi_end;\n\t\tcurwin->w_cursor = curbuf->b_visual.vi_start;\n\t    }\n\n\t    VIsual_active = TRUE;\n\t    VIsual_reselect = TRUE;\n\n\t    // Set Visual to the start and w_cursor to the end of the Visual\n\t    // area.  Make sure they are on an existing character.\n\t    check_cursor();\n\t    VIsual = curwin->w_cursor;\n\t    curwin->w_cursor = tpos;\n\t    check_cursor();\n\t    update_topline();\n\t    /*\n\t     * When called from normal \"g\" command: start Select mode when\n\t     * 'selectmode' contains \"cmd\".  When called for K_SELECT, always\n\t     * start Select mode.\n\t     */\n\t    if (cap->arg)\n\t\tVIsual_select = TRUE;\n\t    else\n\t\tmay_start_select('c');\n\t    setmouse();\n#ifdef FEAT_CLIPBOARD\n\t    // Make sure the clipboard gets updated.  Needed because start and\n\t    // end are still the same, and the selection needs to be owned\n\t    clip_star.vmode = NUL;\n#endif\n\t    redraw_curbuf_later(INVERTED);\n\t    showmode();\n\t}\n\tbreak;\n    /*\n     * \"gV\": Don't reselect the previous Visual area after a Select mode\n     *\t     mapping of menu.\n     */\n    case 'V':\n\tVIsual_reselect = FALSE;\n\tbreak;\n\n    /*\n     * \"gh\":  start Select mode.\n     * \"gH\":  start Select line mode.\n     * \"g^H\": start Select block mode.\n     */\n    case K_BS:\n\tcap->nchar = Ctrl_H;\n\t// FALLTHROUGH\n    case 'h':\n    case 'H':\n    case Ctrl_H:\n# ifdef EBCDIC\n\t// EBCDIC: 'v'-'h' != '^v'-'^h'\n\tif (cap->nchar == Ctrl_H)\n\t    cap->cmdchar = Ctrl_V;\n\telse\n# endif\n\tcap->cmdchar = cap->nchar + ('v' - 'h');\n\tcap->arg = TRUE;\n\tnv_visual(cap);\n\tbreak;\n\n    // \"gn\", \"gN\" visually select next/previous search match\n    // \"gn\" selects next match\n    // \"gN\" selects previous match\n    case 'N':\n    case 'n':\n\tif (!current_search(cap->count1, cap->nchar == 'n'))\n\t    clearopbeep(oap);\n\tbreak;\n\n    /*\n     * \"gj\" and \"gk\" two new funny movement keys -- up and down\n     * movement based on *screen* line rather than *file* line.\n     */\n    case 'j':\n    case K_DOWN:\n\t// with 'nowrap' it works just like the normal \"j\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_down(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, FORWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case 'k':\n    case K_UP:\n\t// with 'nowrap' it works just like the normal \"k\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_up(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, BACKWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    /*\n     * \"gJ\": join two lines without inserting a space.\n     */\n    case 'J':\n\tnv_join(cap);\n\tbreak;\n\n    /*\n     * \"g0\", \"g^\" and \"g$\": Like \"0\", \"^\" and \"$\" but for screen lines.\n     * \"gm\": middle of \"g0\" and \"g$\".\n     */\n    case '^':\n\tflag = TRUE;\n\t// FALLTHROUGH\n\n    case '0':\n    case 'm':\n    case K_HOME:\n    case K_KHOME:\n\toap->motion_type = MCHAR;\n\toap->inclusive = FALSE;\n\tif (curwin->w_p_wrap && curwin->w_width != 0)\n\t{\n\t    int\t\twidth1 = curwin->w_width - curwin_col_off();\n\t    int\t\twidth2 = width1 + curwin_col_off2();\n\n\t    validate_virtcol();\n\t    i = 0;\n\t    if (curwin->w_virtcol >= (colnr_T)width1 && width2 > 0)\n\t\ti = (curwin->w_virtcol - width1) / width2 * width2 + width1;\n\t}\n\telse\n\t    i = curwin->w_leftcol;\n\t// Go to the middle of the screen line.  When 'number' or\n\t// 'relativenumber' is on and lines are wrapping the middle can be more\n\t// to the left.\n\tif (cap->nchar == 'm')\n\t    i += (curwin->w_width - curwin_col_off()\n\t\t    + ((curwin->w_p_wrap && i > 0)\n\t\t\t? curwin_col_off2() : 0)) / 2;\n\tcoladvance((colnr_T)i);\n\tif (flag)\n\t{\n\t    do\n\t\ti = gchar_cursor();\n\t    while (VIM_ISWHITE(i) && oneright() == OK);\n\t    curwin->w_valid &= ~VALID_WCOL;\n\t}\n\tcurwin->w_set_curswant = TRUE;\n\tbreak;\n\n    case 'M':\n\t{\n\t    char_u  *ptr = ml_get_curline();\n\n\t    oap->motion_type = MCHAR;\n\t    oap->inclusive = FALSE;\n\t    if (has_mbyte)\n\t\ti = mb_string2cells(ptr, (int)STRLEN(ptr));\n\t    else\n\t\ti = (int)STRLEN(ptr);\n\t    if (cap->count0 > 0 && cap->count0 <= 100)\n\t\tcoladvance((colnr_T)(i * cap->count0 / 100));\n\t    else\n\t\tcoladvance((colnr_T)(i / 2));\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\tbreak;\n\n    case '_':\n\t// \"g_\": to the last non-blank character in the line or <count> lines\n\t// downward.\n\tcap->oap->motion_type = MCHAR;\n\tcap->oap->inclusive = TRUE;\n\tcurwin->w_curswant = MAXCOL;\n\tif (cursor_down((long)(cap->count1 - 1),\n\t\t\t\t\t cap->oap->op_type == OP_NOP) == FAIL)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    char_u  *ptr = ml_get_curline();\n\n\t    // In Visual mode we may end up after the line.\n\t    if (curwin->w_cursor.col > 0 && ptr[curwin->w_cursor.col] == NUL)\n\t\t--curwin->w_cursor.col;\n\n\t    // Decrease the cursor column until it's on a non-blank.\n\t    while (curwin->w_cursor.col > 0\n\t\t\t\t    && VIM_ISWHITE(ptr[curwin->w_cursor.col]))\n\t\t--curwin->w_cursor.col;\n\t    curwin->w_set_curswant = TRUE;\n\t    adjust_for_sel(cap);\n\t}\n\tbreak;\n\n    case '$':\n    case K_END:\n    case K_KEND:\n\t{\n\t    int col_off = curwin_col_off();\n\n\t    oap->motion_type = MCHAR;\n\t    oap->inclusive = TRUE;\n\t    if (curwin->w_p_wrap && curwin->w_width != 0)\n\t    {\n\t\tcurwin->w_curswant = MAXCOL;    // so we stay at the end\n\t\tif (cap->count1 == 1)\n\t\t{\n\t\t    int\t\twidth1 = curwin->w_width - col_off;\n\t\t    int\t\twidth2 = width1 + curwin_col_off2();\n\n\t\t    validate_virtcol();\n\t\t    i = width1 - 1;\n\t\t    if (curwin->w_virtcol >= (colnr_T)width1)\n\t\t\ti += ((curwin->w_virtcol - width1) / width2 + 1)\n\t\t\t\t\t\t\t\t     * width2;\n\t\t    coladvance((colnr_T)i);\n\n\t\t    // Make sure we stick in this column.\n\t\t    validate_virtcol();\n\t\t    curwin->w_curswant = curwin->w_virtcol;\n\t\t    curwin->w_set_curswant = FALSE;\n\t\t    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)\n\t\t    {\n\t\t\t/*\n\t\t\t * Check for landing on a character that got split at\n\t\t\t * the end of the line.  We do not want to advance to\n\t\t\t * the next screen line.\n\t\t\t */\n\t\t\tif (curwin->w_virtcol > (colnr_T)i)\n\t\t\t    --curwin->w_cursor.col;\n\t\t    }\n\t\t}\n\t\telse if (nv_screengo(oap, FORWARD, cap->count1 - 1) == FAIL)\n\t\t    clearopbeep(oap);\n\t    }\n\t    else\n\t    {\n\t\tif (cap->count1 > 1)\n\t\t    // if it fails, let the cursor still move to the last char\n\t\t    (void)cursor_down(cap->count1 - 1, FALSE);\n\n\t\ti = curwin->w_leftcol + curwin->w_width - col_off - 1;\n\t\tcoladvance((colnr_T)i);\n\n\t\t// if the character doesn't fit move one back\n\t\tif (curwin->w_cursor.col > 0\n\t\t\t\t       && (*mb_ptr2cells)(ml_get_cursor()) > 1)\n\t\t{\n\t\t    colnr_T vcol;\n\n\t\t    getvvcol(curwin, &curwin->w_cursor, NULL, NULL, &vcol);\n\t\t    if (vcol >= curwin->w_leftcol + curwin->w_width - col_off)\n\t\t\t--curwin->w_cursor.col;\n\t\t}\n\n\t\t// Make sure we stick in this column.\n\t\tvalidate_virtcol();\n\t\tcurwin->w_curswant = curwin->w_virtcol;\n\t\tcurwin->w_set_curswant = FALSE;\n\t    }\n\t}\n\tbreak;\n\n    /*\n     * \"g*\" and \"g#\", like \"*\" and \"#\" but without using \"\\<\" and \"\\>\"\n     */\n    case '*':\n    case '#':\n#if POUND != '#'\n    case POUND:\t\t// pound sign (sometimes equal to '#')\n#endif\n    case Ctrl_RSB:\t\t// :tag or :tselect for current identifier\n    case ']':\t\t\t// :tselect for current identifier\n\tnv_ident(cap);\n\tbreak;\n\n    /*\n     * ge and gE: go back to end of word\n     */\n    case 'e':\n    case 'E':\n\toap->motion_type = MCHAR;\n\tcurwin->w_set_curswant = TRUE;\n\toap->inclusive = TRUE;\n\tif (bckend_word(cap->count1, cap->nchar == 'E', FALSE) == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    /*\n     * \"g CTRL-G\": display info about cursor position\n     */\n    case Ctrl_G:\n\tcursor_pos_info(NULL);\n\tbreak;\n\n    /*\n     * \"gi\": start Insert at the last position.\n     */\n    case 'i':\n\tif (curbuf->b_last_insert.lnum != 0)\n\t{\n\t    curwin->w_cursor = curbuf->b_last_insert;\n\t    check_cursor_lnum();\n\t    i = (int)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > (colnr_T)i)\n\t    {\n\t\tif (virtual_active())\n\t\t    curwin->w_cursor.coladd += curwin->w_cursor.col - i;\n\t\tcurwin->w_cursor.col = i;\n\t    }\n\t}\n\tcap->cmdchar = 'i';\n\tnv_edit(cap);\n\tbreak;\n\n    /*\n     * \"gI\": Start insert in column 1.\n     */\n    case 'I':\n\tbeginline(0);\n\tif (!checkclearopq(oap))\n\t    invoke_edit(cap, FALSE, 'g', FALSE);\n\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n    /*\n     * \"gf\": goto file, edit file under cursor\n     * \"]f\" and \"[f\": can also be used.\n     */\n    case 'f':\n    case 'F':\n\tnv_gotofile(cap);\n\tbreak;\n#endif\n\n\t// \"g'm\" and \"g`m\": jump to mark without setting pcmark\n    case '\\'':\n\tcap->arg = TRUE;\n\t// FALLTHROUGH\n    case '`':\n\tnv_gomark(cap);\n\tbreak;\n\n    /*\n     * \"gs\": Goto sleep.\n     */\n    case 's':\n\tdo_sleep(cap->count1 * 1000L, FALSE);\n\tbreak;\n\n    /*\n     * \"ga\": Display the ascii value of the character under the\n     * cursor.\tIt is displayed in decimal, hex, and octal. -- webb\n     */\n    case 'a':\n\tdo_ascii(NULL);\n\tbreak;\n\n    /*\n     * \"g8\": Display the bytes used for the UTF-8 character under the\n     * cursor.\tIt is displayed in hex.\n     * \"8g8\" finds illegal byte sequence.\n     */\n    case '8':\n\tif (cap->count0 == 8)\n\t    utf_find_illegal();\n\telse\n\t    show_utf8();\n\tbreak;\n\n    // \"g<\": show scrollback text\n    case '<':\n\tshow_sb_text();\n\tbreak;\n\n    /*\n     * \"gg\": Goto the first line in file.  With a count it goes to\n     * that line number like for \"G\". -- webb\n     */\n    case 'g':\n\tcap->arg = FALSE;\n\tnv_goto(cap);\n\tbreak;\n\n    /*\n     *\t Two-character operators:\n     *\t \"gq\"\t    Format text\n     *\t \"gw\"\t    Format text and keep cursor position\n     *\t \"g~\"\t    Toggle the case of the text.\n     *\t \"gu\"\t    Change text to lower case.\n     *\t \"gU\"\t    Change text to upper case.\n     *   \"g?\"\t    rot13 encoding\n     *   \"g@\"\t    call 'operatorfunc'\n     */\n    case 'q':\n    case 'w':\n\toap->cursor_start = curwin->w_cursor;\n\t// FALLTHROUGH\n    case '~':\n    case 'u':\n    case 'U':\n    case '?':\n    case '@':\n\tnv_operator(cap);\n\tbreak;\n\n    /*\n     * \"gd\": Find first occurrence of pattern under the cursor in the\n     *\t current function\n     * \"gD\": idem, but in the current file.\n     */\n    case 'd':\n    case 'D':\n\tnv_gd(oap, cap->nchar, (int)cap->count0);\n\tbreak;\n\n    /*\n     * g<*Mouse> : <C-*mouse>\n     */\n    case K_MIDDLEMOUSE:\n    case K_MIDDLEDRAG:\n    case K_MIDDLERELEASE:\n    case K_LEFTMOUSE:\n    case K_LEFTDRAG:\n    case K_LEFTRELEASE:\n    case K_MOUSEMOVE:\n    case K_RIGHTMOUSE:\n    case K_RIGHTDRAG:\n    case K_RIGHTRELEASE:\n    case K_X1MOUSE:\n    case K_X1DRAG:\n    case K_X1RELEASE:\n    case K_X2MOUSE:\n    case K_X2DRAG:\n    case K_X2RELEASE:\n\tmod_mask = MOD_MASK_CTRL;\n\t(void)do_mouse(oap, cap->nchar, BACKWARD, cap->count1, 0);\n\tbreak;\n\n    case K_IGNORE:\n\tbreak;\n\n    /*\n     * \"gP\" and \"gp\": same as \"P\" and \"p\" but leave cursor just after new text\n     */\n    case 'p':\n    case 'P':\n\tnv_put(cap);\n\tbreak;\n\n#ifdef FEAT_BYTEOFF\n    // \"go\": goto byte count from start of buffer\n    case 'o':\n\tgoto_byte(cap->count0);\n\tbreak;\n#endif\n\n    // \"gQ\": improved Ex mode\n    case 'Q':\n\tif (text_locked())\n\t{\n\t    clearopbeep(cap->oap);\n\t    text_locked_msg();\n\t    break;\n\t}\n\n\tif (!checkclearopq(oap))\n\t    do_exmode(TRUE);\n\tbreak;\n\n#ifdef FEAT_JUMPLIST\n    case ',':\n\tnv_pcmark(cap);\n\tbreak;\n\n    case ';':\n\tcap->count1 = -cap->count1;\n\tnv_pcmark(cap);\n\tbreak;\n#endif\n\n    case 't':\n\tif (!checkclearop(oap))\n\t    goto_tabpage((int)cap->count0);\n\tbreak;\n    case 'T':\n\tif (!checkclearop(oap))\n\t    goto_tabpage(-(int)cap->count1);\n\tbreak;\n\n    case TAB:\n\tif (!checkclearop(oap) && goto_tabpage_lastused() == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case '+':\n    case '-': // \"g+\" and \"g-\": undo or redo along the timeline\n\tif (!checkclearopq(oap))\n\t    undo_time(cap->nchar == '-' ? -cap->count1 : cap->count1,\n\t\t\t\t\t\t\t FALSE, FALSE, FALSE);\n\tbreak;\n\n    default:\n\tclearopbeep(oap);\n\tbreak;\n    }\n}\n\n/*\n * Handle \"o\" and \"O\" commands.\n */\n    static void\nn_opencmd(cmdarg_T *cap)\n{\n#ifdef FEAT_CONCEAL\n    linenr_T\toldline = curwin->w_cursor.lnum;\n#endif\n\n    if (!checkclearopq(cap->oap))\n    {\n#ifdef FEAT_FOLDING\n\tif (cap->cmdchar == 'O')\n\t    // Open above the first line of a folded sequence of lines\n\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\telse\n\t    // Open below the last line of a folded sequence of lines\n\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\tNULL, &curwin->w_cursor.lnum);\n#endif\n\tif (u_save((linenr_T)(curwin->w_cursor.lnum -\n\t\t\t\t\t       (cap->cmdchar == 'O' ? 1 : 0)),\n\t\t   (linenr_T)(curwin->w_cursor.lnum +\n\t\t\t\t\t       (cap->cmdchar == 'o' ? 1 : 0))\n\t\t       ) == OK\n\t\t&& open_line(cap->cmdchar == 'O' ? BACKWARD : FORWARD,\n\t\t\t has_format_option(FO_OPEN_COMS) ? OPENLINE_DO_COM : 0,\n\t\t\t\t\t\t\t\t      0) == OK)\n\t{\n#ifdef FEAT_CONCEAL\n\t    if (curwin->w_p_cole > 0 && oldline != curwin->w_cursor.lnum)\n\t\tredrawWinline(curwin, oldline);\n#endif\n#ifdef FEAT_SYN_HL\n\t    if (curwin->w_p_cul)\n\t\t// force redraw of cursorline\n\t\tcurwin->w_valid &= ~VALID_CROW;\n#endif\n\t    // When '#' is in 'cpoptions' ignore the count.\n\t    if (vim_strchr(p_cpo, CPO_HASH) != NULL)\n\t\tcap->count1 = 1;\n\t    invoke_edit(cap, FALSE, cap->cmdchar, TRUE);\n\t}\n    }\n}\n\n/*\n * \".\" command: redo last change.\n */\n    static void\nnv_dot(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n\t/*\n\t * If \"restart_edit\" is TRUE, the last but one command is repeated\n\t * instead of the last command (inserting text). This is used for\n\t * CTRL-O <.> in insert mode.\n\t */\n\tif (start_redo(cap->count0, restart_edit != 0 && !arrow_used) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * CTRL-R: undo undo\n */\n    static void\nnv_redo(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n\tu_redo((int)cap->count1);\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * Handle \"U\" command.\n */\n    static void\nnv_Undo(cmdarg_T *cap)\n{\n    // In Visual mode and typing \"gUU\" triggers an operator\n    if (cap->oap->op_type == OP_UPPER || VIsual_active)\n    {\n\t// translate \"gUU\" to \"gUgU\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'U';\n\tnv_operator(cap);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tu_undoline();\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * '~' command: If tilde is not an operator and Visual is off: swap case of a\n * single character.\n */\n    static void\nnv_tilde(cmdarg_T *cap)\n{\n    if (!p_to && !VIsual_active && cap->oap->op_type != OP_TILDE)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf) && !prompt_curpos_editable())\n\t{\n\t    clearopbeep(cap->oap);\n\t    return;\n\t}\n#endif\n\tn_swapchar(cap);\n    }\n    else\n\tnv_operator(cap);\n}\n\n/*\n * Handle an operator command.\n * The actual work is done by do_pending_operator().\n */\n    static void\nnv_operator(cmdarg_T *cap)\n{\n    int\t    op_type;\n\n    op_type = get_op_type(cap->cmdchar, cap->nchar);\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && op_is_change(op_type) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    if (op_type == cap->oap->op_type)\t    // double operator works on lines\n\tnv_lineop(cap);\n    else if (!checkclearop(cap->oap))\n    {\n\tcap->oap->start = curwin->w_cursor;\n\tcap->oap->op_type = op_type;\n#ifdef FEAT_EVAL\n\tset_op_var(op_type);\n#endif\n    }\n}\n\n#ifdef FEAT_EVAL\n/*\n * Set v:operator to the characters for \"optype\".\n */\n    static void\nset_op_var(int optype)\n{\n    char_u\topchars[3];\n\n    if (optype == OP_NOP)\n\tset_vim_var_string(VV_OP, NULL, 0);\n    else\n    {\n\topchars[0] = get_op_char(optype);\n\topchars[1] = get_extra_op_char(optype);\n\topchars[2] = NUL;\n\tset_vim_var_string(VV_OP, opchars, -1);\n    }\n}\n#endif\n\n/*\n * Handle linewise operator \"dd\", \"yy\", etc.\n *\n * \"_\" is is a strange motion command that helps make operators more logical.\n * It is actually implemented, but not documented in the real Vi.  This motion\n * command actually refers to \"the current line\".  Commands like \"dd\" and \"yy\"\n * are really an alternate form of \"d_\" and \"y_\".  It does accept a count, so\n * \"d3_\" works to delete 3 lines.\n */\n    static void\nnv_lineop(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MLINE;\n    if (cursor_down(cap->count1 - 1L, cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n    else if (  (cap->oap->op_type == OP_DELETE // only with linewise motions\n\t\t&& cap->oap->motion_force != 'v'\n\t\t&& cap->oap->motion_force != Ctrl_V)\n\t    || cap->oap->op_type == OP_LSHIFT\n\t    || cap->oap->op_type == OP_RSHIFT)\n\tbeginline(BL_SOL | BL_FIX);\n    else if (cap->oap->op_type != OP_YANK)\t// 'Y' does not move cursor\n\tbeginline(BL_WHITE | BL_FIX);\n}\n\n/*\n * <Home> command.\n */\n    static void\nnv_home(cmdarg_T *cap)\n{\n    // CTRL-HOME is like \"gg\"\n    if (mod_mask & MOD_MASK_CTRL)\n\tnv_goto(cap);\n    else\n    {\n\tcap->count0 = 1;\n\tnv_pipe(cap);\n    }\n    ins_at_eol = FALSE;\t    // Don't move cursor past eol (only necessary in a\n\t\t\t    // one-character line).\n}\n\n/*\n * \"|\" command.\n */\n    static void\nnv_pipe(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    beginline(0);\n    if (cap->count0 > 0)\n    {\n\tcoladvance((colnr_T)(cap->count0 - 1));\n\tcurwin->w_curswant = (colnr_T)(cap->count0 - 1);\n    }\n    else\n\tcurwin->w_curswant = 0;\n    // keep curswant at the column where we wanted to go, not where\n    // we ended; differs if line is too short\n    curwin->w_set_curswant = FALSE;\n}\n\n/*\n * Handle back-word command \"b\" and \"B\".\n * cap->arg is 1 for \"B\"\n */\n    static void\nnv_bck_word(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    curwin->w_set_curswant = TRUE;\n    if (bck_word(cap->count1, cap->arg, FALSE) == FAIL)\n\tclearopbeep(cap->oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle word motion commands \"e\", \"E\", \"w\" and \"W\".\n * cap->arg is TRUE for \"E\" and \"W\".\n */\n    static void\nnv_wordcmd(cmdarg_T *cap)\n{\n    int\t\tn;\n    int\t\tword_end;\n    int\t\tflag = FALSE;\n    pos_T\tstartpos = curwin->w_cursor;\n\n    /*\n     * Set inclusive for the \"E\" and \"e\" command.\n     */\n    if (cap->cmdchar == 'e' || cap->cmdchar == 'E')\n\tword_end = TRUE;\n    else\n\tword_end = FALSE;\n    cap->oap->inclusive = word_end;\n\n    /*\n     * \"cw\" and \"cW\" are a special case.\n     */\n    if (!word_end && cap->oap->op_type == OP_CHANGE)\n    {\n\tn = gchar_cursor();\n\tif (n != NUL)\t\t\t// not an empty line\n\t{\n\t    if (VIM_ISWHITE(n))\n\t    {\n\t\t/*\n\t\t * Reproduce a funny Vi behaviour: \"cw\" on a blank only\n\t\t * changes one character, not all blanks until the start of\n\t\t * the next word.  Only do this when the 'w' flag is included\n\t\t * in 'cpoptions'.\n\t\t */\n\t\tif (cap->count1 == 1 && vim_strchr(p_cpo, CPO_CW) != NULL)\n\t\t{\n\t\t    cap->oap->inclusive = TRUE;\n\t\t    cap->oap->motion_type = MCHAR;\n\t\t    return;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t/*\n\t\t * This is a little strange. To match what the real Vi does,\n\t\t * we effectively map 'cw' to 'ce', and 'cW' to 'cE', provided\n\t\t * that we are not on a space or a TAB.  This seems impolite\n\t\t * at first, but it's really more what we mean when we say\n\t\t * 'cw'.\n\t\t * Another strangeness: When standing on the end of a word\n\t\t * \"ce\" will change until the end of the next word, but \"cw\"\n\t\t * will change only one character! This is done by setting\n\t\t * flag.\n\t\t */\n\t\tcap->oap->inclusive = TRUE;\n\t\tword_end = TRUE;\n\t\tflag = TRUE;\n\t    }\n\t}\n    }\n\n    cap->oap->motion_type = MCHAR;\n    curwin->w_set_curswant = TRUE;\n    if (word_end)\n\tn = end_word(cap->count1, cap->arg, flag, FALSE);\n    else\n\tn = fwd_word(cap->count1, cap->arg, cap->oap->op_type != OP_NOP);\n\n    // Don't leave the cursor on the NUL past the end of line. Unless we\n    // didn't move it forward.\n    if (LT_POS(startpos, curwin->w_cursor))\n\tadjust_cursor(cap->oap);\n\n    if (n == FAIL && cap->oap->op_type == OP_NOP)\n\tclearopbeep(cap->oap);\n    else\n    {\n\tadjust_for_sel(cap);\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * Used after a movement command: If the cursor ends up on the NUL after the\n * end of the line, may move it back to the last character and make the motion\n * inclusive.\n */\n    static void\nadjust_cursor(oparg_T *oap)\n{\n    // The cursor cannot remain on the NUL when:\n    // - the column is > 0\n    // - not in Visual mode or 'selection' is \"o\"\n    // - 'virtualedit' is not \"all\" and not \"onemore\".\n    if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL\n\t\t&& (!VIsual_active || *p_sel == 'o')\n\t\t&& !virtual_active() && (get_ve_flags() & VE_ONEMORE) == 0)\n    {\n\t--curwin->w_cursor.col;\n\t// prevent cursor from moving on the trail byte\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\toap->inclusive = TRUE;\n    }\n}\n\n/*\n * \"0\" and \"^\" commands.\n * cap->arg is the argument for beginline().\n */\n    static void\nnv_beginline(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    beginline(cap->arg);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n    ins_at_eol = FALSE;\t    // Don't move cursor past eol (only necessary in a\n\t\t\t    // one-character line).\n}\n\n/*\n * In exclusive Visual mode, may include the last character.\n */\n    static void\nadjust_for_sel(cmdarg_T *cap)\n{\n    if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'\n\t    && gchar_cursor() != NUL && LT_POS(VIsual, curwin->w_cursor))\n    {\n\tif (has_mbyte)\n\t    inc_cursor();\n\telse\n\t    ++curwin->w_cursor.col;\n\tcap->oap->inclusive = FALSE;\n    }\n}\n\n/*\n * Exclude last character at end of Visual area for 'selection' == \"exclusive\".\n * Should check VIsual_mode before calling this.\n * Returns TRUE when backed up to the previous line.\n */\n    int\nunadjust_for_sel(void)\n{\n    pos_T\t*pp;\n\n    if (*p_sel == 'e' && !EQUAL_POS(VIsual, curwin->w_cursor))\n    {\n\tif (LT_POS(VIsual, curwin->w_cursor))\n\t    pp = &curwin->w_cursor;\n\telse\n\t    pp = &VIsual;\n\tif (pp->coladd > 0)\n\t    --pp->coladd;\n\telse\n\tif (pp->col > 0)\n\t{\n\t    --pp->col;\n\t    mb_adjustpos(curbuf, pp);\n\t}\n\telse if (pp->lnum > 1)\n\t{\n\t    --pp->lnum;\n\t    pp->col = (colnr_T)STRLEN(ml_get(pp->lnum));\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * SELECT key in Normal or Visual mode: end of Select mode mapping.\n */\n    static void\nnv_select(cmdarg_T *cap)\n{\n    if (VIsual_active)\n\tVIsual_select = TRUE;\n    else if (VIsual_reselect)\n    {\n\tcap->nchar = 'v';\t    // fake \"gv\" command\n\tcap->arg = TRUE;\n\tnv_g_cmd(cap);\n    }\n}\n\n\n/*\n * \"G\", \"gg\", CTRL-END, CTRL-HOME.\n * cap->arg is TRUE for \"G\".\n */\n    static void\nnv_goto(cmdarg_T *cap)\n{\n    linenr_T\tlnum;\n\n    if (cap->arg)\n\tlnum = curbuf->b_ml.ml_line_count;\n    else\n\tlnum = 1L;\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    // When a count is given, use it instead of the default lnum\n    if (cap->count0 != 0)\n\tlnum = cap->count0;\n    if (lnum < 1L)\n\tlnum = 1L;\n    else if (lnum > curbuf->b_ml.ml_line_count)\n\tlnum = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor.lnum = lnum;\n    beginline(BL_SOL | BL_FIX);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_JUMP) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * CTRL-\\ in Normal mode.\n */\n    static void\nnv_normal(cmdarg_T *cap)\n{\n    if (cap->nchar == Ctrl_N || cap->nchar == Ctrl_G)\n    {\n\tclearop(cap->oap);\n\tif (restart_edit != 0 && mode_displayed)\n\t    clear_cmdline = TRUE;\t\t// unshow mode later\n\trestart_edit = 0;\n#ifdef FEAT_CMDWIN\n\tif (cmdwin_type != 0)\n\t    cmdwin_result = Ctrl_C;\n#endif\n\tif (VIsual_active)\n\t{\n\t    end_visual_mode();\t\t// stop Visual\n\t    redraw_curbuf_later(INVERTED);\n\t}\n\t// CTRL-\\ CTRL-G restarts Insert mode when 'insertmode' is set.\n\tif (cap->nchar == Ctrl_G && p_im)\n\t    restart_edit = 'a';\n    }\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * ESC in Normal mode: beep, but don't flush buffers.\n * Don't even beep if we are canceling a command.\n */\n    static void\nnv_esc(cmdarg_T *cap)\n{\n    int\t\tno_reason;\n\n    no_reason = (cap->oap->op_type == OP_NOP\n\t\t&& cap->opcount == 0\n\t\t&& cap->count0 == 0\n\t\t&& cap->oap->regname == 0\n\t\t&& !p_im);\n\n    if (cap->arg)\t\t// TRUE for CTRL-C\n    {\n\tif (restart_edit == 0\n#ifdef FEAT_CMDWIN\n\t\t&& cmdwin_type == 0\n#endif\n\t\t&& !VIsual_active\n\t\t&& no_reason)\n\t{\n\t    if (anyBufIsChanged())\n\t\tmsg(_(\"Type  :qa!  and press <Enter> to abandon all changes and exit Vim\"));\n\t    else\n\t\tmsg(_(\"Type  :qa  and press <Enter> to exit Vim\"));\n\t}\n\n\t// Don't reset \"restart_edit\" when 'insertmode' is set, it won't be\n\t// set again below when halfway a mapping.\n\tif (!p_im)\n\t    restart_edit = 0;\n#ifdef FEAT_CMDWIN\n\tif (cmdwin_type != 0)\n\t{\n\t    cmdwin_result = K_IGNORE;\n\t    got_int = FALSE;\t// don't stop executing autocommands et al.\n\t    return;\n\t}\n#endif\n    }\n#ifdef FEAT_CMDWIN\n    else if (cmdwin_type != 0 && ex_normal_busy)\n    {\n\t// When :normal runs out of characters while in the command line window\n\t// vgetorpeek() will return ESC.  Exit the cmdline window to break the\n\t// loop.\n\tcmdwin_result = K_IGNORE;\n\treturn;\n    }\n#endif\n\n    if (VIsual_active)\n    {\n\tend_visual_mode();\t// stop Visual\n\tcheck_cursor_col();\t// make sure cursor is not beyond EOL\n\tcurwin->w_set_curswant = TRUE;\n\tredraw_curbuf_later(INVERTED);\n    }\n    else if (no_reason)\n\tvim_beep(BO_ESC);\n    clearop(cap->oap);\n\n    // A CTRL-C is often used at the start of a menu.  When 'insertmode' is\n    // set return to Insert mode afterwards.\n    if (restart_edit == 0 && goto_im() && ex_normal_busy == 0)\n\trestart_edit = 'a';\n}\n\n/*\n * Move the cursor for the \"A\" command.\n */\n    void\nset_cursor_for_append_to_line(void)\n{\n    curwin->w_set_curswant = TRUE;\n    if (get_ve_flags() == VE_ALL)\n    {\n\tint save_State = State;\n\n\t// Pretend Insert mode here to allow the cursor on the\n\t// character past the end of the line\n\tState = INSERT;\n\tcoladvance((colnr_T)MAXCOL);\n\tState = save_State;\n    }\n    else\n\tcurwin->w_cursor.col += (colnr_T)STRLEN(ml_get_cursor());\n}\n\n/*\n * Handle \"A\", \"a\", \"I\", \"i\" and <Insert> commands.\n * Also handle K_PS, start bracketed paste.\n */\n    static void\nnv_edit(cmdarg_T *cap)\n{\n    // <Insert> is equal to \"i\"\n    if (cap->cmdchar == K_INS || cap->cmdchar == K_KINS)\n\tcap->cmdchar = 'i';\n\n    // in Visual mode \"A\" and \"I\" are an operator\n    if (VIsual_active && (cap->cmdchar == 'A' || cap->cmdchar == 'I'))\n    {\n#ifdef FEAT_TERMINAL\n\tif (term_in_normal_mode())\n\t{\n\t    end_visual_mode();\n\t    clearop(cap->oap);\n\t    term_enter_job_mode();\n\t    return;\n\t}\n#endif\n\tv_visop(cap);\n    }\n\n    // in Visual mode and after an operator \"a\" and \"i\" are for text objects\n    else if ((cap->cmdchar == 'a' || cap->cmdchar == 'i')\n\t    && (cap->oap->op_type != OP_NOP || VIsual_active))\n    {\n#ifdef FEAT_TEXTOBJ\n\tnv_object(cap);\n#else\n\tclearopbeep(cap->oap);\n#endif\n    }\n#ifdef FEAT_TERMINAL\n    else if (term_in_normal_mode())\n    {\n\tclearop(cap->oap);\n\tterm_enter_job_mode();\n\treturn;\n    }\n#endif\n    else if (!curbuf->b_p_ma && !p_im)\n    {\n\t// Only give this error when 'insertmode' is off.\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\tclearop(cap->oap);\n\tif (cap->cmdchar == K_PS)\n\t    // drop the pasted text\n\t    bracketed_paste(PASTE_INSERT, TRUE, NULL);\n    }\n    else if (cap->cmdchar == K_PS && VIsual_active)\n    {\n\tpos_T old_pos = curwin->w_cursor;\n\tpos_T old_visual = VIsual;\n\n\t// In Visual mode the selected text is deleted.\n\tif (VIsual_mode == 'V' || curwin->w_cursor.lnum != VIsual.lnum)\n\t{\n\t    shift_delete_registers();\n\t    cap->oap->regname = '1';\n\t}\n\telse\n\t    cap->oap->regname = '-';\n\tcap->cmdchar = 'd';\n\tcap->nchar = NUL;\n\tnv_operator(cap);\n\tdo_pending_operator(cap, 0, FALSE);\n\tcap->cmdchar = K_PS;\n\n\t// When the last char in the line was deleted then append. Detect this\n\t// by checking if the cursor moved to before the Visual area.\n\tif (*ml_get_cursor() != NUL && LT_POS(curwin->w_cursor, old_pos)\n\t\t\t\t       && LT_POS(curwin->w_cursor, old_visual))\n\t    inc_cursor();\n\n\t// Insert to replace the deleted text with the pasted text.\n\tinvoke_edit(cap, FALSE, cap->cmdchar, FALSE);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tswitch (cap->cmdchar)\n\t{\n\t    case 'A':\t// \"A\"ppend after the line\n\t\tset_cursor_for_append_to_line();\n\t\tbreak;\n\n\t    case 'I':\t// \"I\"nsert before the first non-blank\n\t\tif (vim_strchr(p_cpo, CPO_INSEND) == NULL)\n\t\t    beginline(BL_WHITE);\n\t\telse\n\t\t    beginline(BL_WHITE|BL_FIX);\n\t\tbreak;\n\n\t    case K_PS:\n\t\t// Bracketed paste works like \"a\"ppend, unless the cursor is in\n\t\t// the first column, then it inserts.\n\t\tif (curwin->w_cursor.col == 0)\n\t\t    break;\n\t\t// FALLTHROUGH\n\n\t    case 'a':\t// \"a\"ppend is like \"i\"nsert on the next character.\n\t\t// increment coladd when in virtual space, increment the\n\t\t// column otherwise, also to append after an unprintable char\n\t\tif (virtual_active()\n\t\t\t&& (curwin->w_cursor.coladd > 0\n\t\t\t    || *ml_get_cursor() == NUL\n\t\t\t    || *ml_get_cursor() == TAB))\n\t\t    curwin->w_cursor.coladd++;\n\t\telse if (*ml_get_cursor() != NUL)\n\t\t    inc_cursor();\n\t\tbreak;\n\t}\n\n\tif (curwin->w_cursor.coladd && cap->cmdchar != 'A')\n\t{\n\t    int save_State = State;\n\n\t    // Pretend Insert mode here to allow the cursor on the\n\t    // character past the end of the line\n\t    State = INSERT;\n\t    coladvance(getviscol());\n\t    State = save_State;\n\t}\n\n\tinvoke_edit(cap, FALSE, cap->cmdchar, FALSE);\n    }\n    else if (cap->cmdchar == K_PS)\n\t// drop the pasted text\n\tbracketed_paste(PASTE_INSERT, TRUE, NULL);\n}\n\n/*\n * Invoke edit() and take care of \"restart_edit\" and the return value.\n */\n    static void\ninvoke_edit(\n    cmdarg_T\t*cap,\n    int\t\trepl,\t\t// \"r\" or \"gr\" command\n    int\t\tcmd,\n    int\t\tstartln)\n{\n    int\t\trestart_edit_save = 0;\n\n    // Complicated: When the user types \"a<C-O>a\" we don't want to do Insert\n    // mode recursively.  But when doing \"a<C-O>.\" or \"a<C-O>rx\" we do allow\n    // it.\n    if (repl || !stuff_empty())\n\trestart_edit_save = restart_edit;\n    else\n\trestart_edit_save = 0;\n\n    // Always reset \"restart_edit\", this is not a restarted edit.\n    restart_edit = 0;\n\n    if (edit(cmd, startln, cap->count1))\n\tcap->retval |= CA_COMMAND_BUSY;\n\n    if (restart_edit == 0)\n\trestart_edit = restart_edit_save;\n}\n\n#ifdef FEAT_TEXTOBJ\n/*\n * \"a\" or \"i\" while an operator is pending or in Visual mode: object motion.\n */\n    static void\nnv_object(\n    cmdarg_T\t*cap)\n{\n    int\t\tflag;\n    int\t\tinclude;\n    char_u\t*mps_save;\n\n    if (cap->cmdchar == 'i')\n\tinclude = FALSE;    // \"ix\" = inner object: exclude white space\n    else\n\tinclude = TRUE;\t    // \"ax\" = an object: include white space\n\n    // Make sure (), [], {} and <> are in 'matchpairs'\n    mps_save = curbuf->b_p_mps;\n    curbuf->b_p_mps = (char_u *)\"(:),{:},[:],<:>\";\n\n    switch (cap->nchar)\n    {\n\tcase 'w': // \"aw\" = a word\n\t\tflag = current_word(cap->oap, cap->count1, include, FALSE);\n\t\tbreak;\n\tcase 'W': // \"aW\" = a WORD\n\t\tflag = current_word(cap->oap, cap->count1, include, TRUE);\n\t\tbreak;\n\tcase 'b': // \"ab\" = a braces block\n\tcase '(':\n\tcase ')':\n\t\tflag = current_block(cap->oap, cap->count1, include, '(', ')');\n\t\tbreak;\n\tcase 'B': // \"aB\" = a Brackets block\n\tcase '{':\n\tcase '}':\n\t\tflag = current_block(cap->oap, cap->count1, include, '{', '}');\n\t\tbreak;\n\tcase '[': // \"a[\" = a [] block\n\tcase ']':\n\t\tflag = current_block(cap->oap, cap->count1, include, '[', ']');\n\t\tbreak;\n\tcase '<': // \"a<\" = a <> block\n\tcase '>':\n\t\tflag = current_block(cap->oap, cap->count1, include, '<', '>');\n\t\tbreak;\n\tcase 't': // \"at\" = a tag block (xml and html)\n\t\t// Do not adjust oap->end in do_pending_operator()\n\t\t// otherwise there are different results for 'dit'\n\t\t// (note leading whitespace in last line):\n\t\t// 1) <b>      2) <b>\n\t\t//    foobar      foobar\n\t\t//    </b>            </b>\n\t\tcap->retval |= CA_NO_ADJ_OP_END;\n\t\tflag = current_tagblock(cap->oap, cap->count1, include);\n\t\tbreak;\n\tcase 'p': // \"ap\" = a paragraph\n\t\tflag = current_par(cap->oap, cap->count1, include, 'p');\n\t\tbreak;\n\tcase 's': // \"as\" = a sentence\n\t\tflag = current_sent(cap->oap, cap->count1, include);\n\t\tbreak;\n\tcase '\"': // \"a\"\" = a double quoted string\n\tcase '\\'': // \"a'\" = a single quoted string\n\tcase '`': // \"a`\" = a backtick quoted string\n\t\tflag = current_quote(cap->oap, cap->count1, include,\n\t\t\t\t\t\t\t\t  cap->nchar);\n\t\tbreak;\n#if 0\t// TODO\n\tcase 'S': // \"aS\" = a section\n\tcase 'f': // \"af\" = a filename\n\tcase 'u': // \"au\" = a URL\n#endif\n\tdefault:\n\t\tflag = FAIL;\n\t\tbreak;\n    }\n\n    curbuf->b_p_mps = mps_save;\n    if (flag == FAIL)\n\tclearopbeep(cap->oap);\n    adjust_cursor_col();\n    curwin->w_set_curswant = TRUE;\n}\n#endif\n\n/*\n * \"q\" command: Start/stop recording.\n * \"q:\", \"q/\", \"q?\": edit command-line in command-line window.\n */\n    static void\nnv_record(cmdarg_T *cap)\n{\n    if (cap->oap->op_type == OP_FORMAT)\n    {\n\t// \"gqq\" is the same as \"gqgq\": format line\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'q';\n\tnv_operator(cap);\n    }\n    else if (!checkclearop(cap->oap))\n    {\n#ifdef FEAT_CMDWIN\n\tif (cap->nchar == ':' || cap->nchar == '/' || cap->nchar == '?')\n\t{\n\t    stuffcharReadbuff(cap->nchar);\n\t    stuffcharReadbuff(K_CMDWIN);\n\t}\n\telse\n#endif\n\t    // (stop) recording into a named register, unless executing a\n\t    // register\n\t    if (reg_executing == 0 && do_record(cap->nchar) == FAIL)\n\t\tclearopbeep(cap->oap);\n    }\n}\n\n/*\n * Handle the \"@r\" command.\n */\n    static void\nnv_at(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_EVAL\n    if (cap->nchar == '=')\n    {\n\tif (get_expr_register() == NUL)\n\t    return;\n    }\n#endif\n    while (cap->count1-- && !got_int)\n    {\n\tif (do_execreg(cap->nchar, FALSE, FALSE, FALSE) == FAIL)\n\t{\n\t    clearopbeep(cap->oap);\n\t    break;\n\t}\n\tline_breakcheck();\n    }\n}\n\n/*\n * Handle the CTRL-U and CTRL-D commands.\n */\n    static void\nnv_halfpage(cmdarg_T *cap)\n{\n    if ((cap->cmdchar == Ctrl_U && curwin->w_cursor.lnum == 1)\n\t    || (cap->cmdchar == Ctrl_D\n\t\t&& curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count))\n\tclearopbeep(cap->oap);\n    else if (!checkclearop(cap->oap))\n\thalfpage(cap->cmdchar == Ctrl_D, cap->count0);\n}\n\n/*\n * Handle \"J\" or \"gJ\" command.\n */\n    static void\nnv_join(cmdarg_T *cap)\n{\n    if (VIsual_active)\t// join the visual lines\n\tnv_operator(cap);\n    else if (!checkclearop(cap->oap))\n    {\n\tif (cap->count0 <= 1)\n\t    cap->count0 = 2;\t    // default for join is two lines!\n\tif (curwin->w_cursor.lnum + cap->count0 - 1 >\n\t\t\t\t\t\t   curbuf->b_ml.ml_line_count)\n\t{\n\t    // can't join when on the last line\n\t    if (cap->count0 <= 2)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\treturn;\n\t    }\n\t    cap->count0 = curbuf->b_ml.ml_line_count\n\t\t\t\t\t\t  - curwin->w_cursor.lnum + 1;\n\t}\n\n\tprep_redo(cap->oap->regname, cap->count0,\n\t\t\t\t     NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n\t(void)do_join(cap->count0, cap->nchar == NUL, TRUE, TRUE, TRUE);\n    }\n}\n\n/*\n * \"P\", \"gP\", \"p\" and \"gp\" commands.\n */\n    static void\nnv_put(cmdarg_T *cap)\n{\n    nv_put_opt(cap, FALSE);\n}\n\n/*\n * \"P\", \"gP\", \"p\" and \"gp\" commands.\n * \"fix_indent\" is TRUE for \"[p\", \"[P\", \"]p\" and \"]P\".\n */\n    static void\nnv_put_opt(cmdarg_T *cap, int fix_indent)\n{\n    int\t\tregname = 0;\n    void\t*reg1 = NULL, *reg2 = NULL;\n    int\t\tempty = FALSE;\n    int\t\twas_visual = FALSE;\n    int\t\tdir;\n    int\t\tflags = 0;\n\n    if (cap->oap->op_type != OP_NOP)\n    {\n#ifdef FEAT_DIFF\n\t// \"dp\" is \":diffput\"\n\tif (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'p')\n\t{\n\t    clearop(cap->oap);\n\t    nv_diffgetput(TRUE, cap->opcount);\n\t}\n\telse\n#endif\n\tclearopbeep(cap->oap);\n    }\n#ifdef FEAT_JOB_CHANNEL\n    else if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n    }\n#endif\n    else\n    {\n\tif (fix_indent)\n\t{\n\t    dir = (cap->cmdchar == ']' && cap->nchar == 'p')\n\t\t\t\t\t\t\t ? FORWARD : BACKWARD;\n\t    flags |= PUT_FIXINDENT;\n\t}\n\telse\n\t    dir = (cap->cmdchar == 'P'\n\t\t    || ((cap->cmdchar == 'g' || cap->cmdchar == 'z')\n\t\t\t&& cap->nchar == 'P')) ? BACKWARD : FORWARD;\n\tprep_redo_cmd(cap);\n\tif (cap->cmdchar == 'g')\n\t    flags |= PUT_CURSEND;\n\telse if (cap->cmdchar == 'z')\n\t    flags |= PUT_BLOCK_INNER;\n\n\tif (VIsual_active)\n\t{\n\t    // Putting in Visual mode: The put text replaces the selected\n\t    // text.  First delete the selected text, then put the new text.\n\t    // Need to save and restore the registers that the delete\n\t    // overwrites if the old contents is being put.\n\t    was_visual = TRUE;\n\t    regname = cap->oap->regname;\n#ifdef FEAT_CLIPBOARD\n\t    adjust_clip_reg(&regname);\n#endif\n\t   if (regname == 0 || regname == '\"'\n\t\t\t\t     || VIM_ISDIGIT(regname) || regname == '-'\n#ifdef FEAT_CLIPBOARD\n\t\t    || (clip_unnamed && (regname == '*' || regname == '+'))\n#endif\n\n\t\t    )\n\t    {\n\t\t// The delete is going to overwrite the register we want to\n\t\t// put, save it first.\n\t\treg1 = get_register(regname, TRUE);\n\t    }\n\n\t    // Now delete the selected text. Avoid messages here.\n\t    cap->cmdchar = 'd';\n\t    cap->nchar = NUL;\n\t    cap->oap->regname = NUL;\n\t    ++msg_silent;\n\t    nv_operator(cap);\n\t    do_pending_operator(cap, 0, FALSE);\n\t    empty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n\t    --msg_silent;\n\n\t    // delete PUT_LINE_BACKWARD;\n\t    cap->oap->regname = regname;\n\n\t    if (reg1 != NULL)\n\t    {\n\t\t// Delete probably changed the register we want to put, save\n\t\t// it first. Then put back what was there before the delete.\n\t\treg2 = get_register(regname, FALSE);\n\t\tput_register(regname, reg1);\n\t    }\n\n\t    // When deleted a linewise Visual area, put the register as\n\t    // lines to avoid it joined with the next line.  When deletion was\n\t    // characterwise, split a line when putting lines.\n\t    if (VIsual_mode == 'V')\n\t\tflags |= PUT_LINE;\n\t    else if (VIsual_mode == 'v')\n\t\tflags |= PUT_LINE_SPLIT;\n\t    if (VIsual_mode == Ctrl_V && dir == FORWARD)\n\t\tflags |= PUT_LINE_FORWARD;\n\t    dir = BACKWARD;\n\t    if ((VIsual_mode != 'V'\n\t\t\t&& curwin->w_cursor.col < curbuf->b_op_start.col)\n\t\t    || (VIsual_mode == 'V'\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_op_start.lnum))\n\t\t// cursor is at the end of the line or end of file, put\n\t\t// forward.\n\t\tdir = FORWARD;\n\t    // May have been reset in do_put().\n\t    VIsual_active = TRUE;\n\t}\n\tdo_put(cap->oap->regname, NULL, dir, cap->count1, flags);\n\n\t// If a register was saved, put it back now.\n\tif (reg2 != NULL)\n\t    put_register(regname, reg2);\n\n\t// What to reselect with \"gv\"?  Selecting the just put text seems to\n\t// be the most useful, since the original text was removed.\n\tif (was_visual)\n\t{\n\t    curbuf->b_visual.vi_start = curbuf->b_op_start;\n\t    curbuf->b_visual.vi_end = curbuf->b_op_end;\n\t    // need to adjust cursor position\n\t    if (*p_sel == 'e')\n\t\tinc(&curbuf->b_visual.vi_end);\n\t}\n\n\t// When all lines were selected and deleted do_put() leaves an empty\n\t// line that needs to be deleted now.\n\tif (empty && *ml_get(curbuf->b_ml.ml_line_count) == NUL)\n\t{\n\t    ml_delete_flags(curbuf->b_ml.ml_line_count, ML_DEL_MESSAGE);\n\t    deleted_lines(curbuf->b_ml.ml_line_count + 1, 1);\n\n\t    // If the cursor was in that line, move it to the end of the last\n\t    // line.\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\tcoladvance((colnr_T)MAXCOL);\n\t    }\n\t}\n\tauto_format(FALSE, TRUE);\n    }\n}\n\n/*\n * \"o\" and \"O\" commands.\n */\n    static void\nnv_open(cmdarg_T *cap)\n{\n#ifdef FEAT_DIFF\n    // \"do\" is \":diffget\"\n    if (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'o')\n    {\n\tclearop(cap->oap);\n\tnv_diffgetput(FALSE, cap->opcount);\n    }\n    else\n#endif\n    if (VIsual_active)  // switch start and end of visual\n\tv_swap_corners(cap->cmdchar);\n#ifdef FEAT_JOB_CHANNEL\n    else if (bt_prompt(curbuf))\n\tclearopbeep(cap->oap);\n#endif\n    else\n\tn_opencmd(cap);\n}\n\n#ifdef FEAT_NETBEANS_INTG\n    static void\nnv_nbcmd(cmdarg_T *cap)\n{\n    netbeans_keycommand(cap->nchar);\n}\n#endif\n\n#ifdef FEAT_DND\n    static void\nnv_drop(cmdarg_T *cap UNUSED)\n{\n    do_put('~', NULL, BACKWARD, 1L, PUT_CURSEND);\n}\n#endif\n\n/*\n * Trigger CursorHold event.\n * When waiting for a character for 'updatetime' K_CURSORHOLD is put in the\n * input buffer.  \"did_cursorhold\" is set to avoid retriggering.\n */\n    static void\nnv_cursorhold(cmdarg_T *cap)\n{\n    apply_autocmds(EVENT_CURSORHOLD, NULL, NULL, FALSE, curbuf);\n    did_cursorhold = TRUE;\n    cap->retval |= CA_COMMAND_BUSY;\t// don't call edit() now\n}\n", "\" Test for edit functions\n\nif exists(\"+t_kD\")\n  let &t_kD=\"\u001b[3;*~\"\nendif\n\nsource check.vim\n\n\" Needed for testing basic rightleft: Test_edit_rightleft\nsource view_util.vim\n\n\" Needs to come first until the bug in getchar() is\n\" fixed: https://groups.google.com/d/msg/vim_dev/fXL9yme4H4c/bOR-U6_bAQAJ\nfunc Test_edit_00b()\n  new\n  call setline(1, ['abc '])\n  inoreabbr <buffer> h here some more\n  call cursor(1, 4)\n  \" <c-l> expands the abbreviation and ends insertmode\n  call feedkeys(\":set im\\<cr> h\\<c-l>:set noim\\<cr>\", 'tix')\n  call assert_equal(['abc here some more '], getline(1,'$'))\n  iunabbr <buffer> h\n  bw!\nendfunc\n\nfunc Test_edit_01()\n  \" set for Travis CI?\n  \"  set nocp noesckeys\n  new\n  \" 1) empty buffer\n  call assert_equal([''], getline(1,'$'))\n  \" 2) delete in an empty line\n  call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n  call assert_equal([''], getline(1,'$'))\n  %d\n  \" 3) delete one character\n  call setline(1, 'a')\n  call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n  call assert_equal([''], getline(1,'$'))\n  %d\n  \" 4) delete a multibyte character\n  call setline(1, \"\\u0401\")\n  call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n  call assert_equal([''], getline(1,'$'))\n  %d\n  \" 5.1) delete linebreak with 'bs' option containing eol\n  let _bs=&bs\n  set bs=eol\n  call setline(1, [\"abc def\", \"ghi jkl\"])\n  call cursor(1, 1)\n  call feedkeys(\"A\\<del>\\<esc>\", 'tnix')\n  call assert_equal(['abc defghi jkl'], getline(1, 2))\n  %d\n  \" 5.2) delete linebreak with backspace option w/out eol\n  set bs=\n  call setline(1, [\"abc def\", \"ghi jkl\"])\n  call cursor(1, 1)\n  call feedkeys(\"A\\<del>\\<esc>\", 'tnix')\n  call assert_equal([\"abc def\", \"ghi jkl\"], getline(1, 2))\n  let &bs=_bs\n  bw!\nendfunc\n\nfunc Test_edit_02()\n  \" Change cursor position in InsertCharPre command\n  new\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  fu! DoIt(...)\n    call cursor(1, 4)\n    if len(a:000)\n      let v:char=a:1\n    endif\n  endfu\n  au InsertCharPre <buffer> :call DoIt('y')\n  call feedkeys(\"ix\\<esc>\", 'tnix')\n  call assert_equal(['abcy'], getline(1, '$'))\n  \" Setting <Enter> in InsertCharPre\n  au! InsertCharPre <buffer> :call DoIt(\"\\n\")\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"ix\\<esc>\", 'tnix')\n  call assert_equal(['abc', ''], getline(1, '$'))\n  %d\n  au! InsertCharPre\n  \" Change cursor position in InsertEnter command\n  \" 1) when setting v:char, keeps changed cursor position\n  au! InsertEnter <buffer> :call DoIt('y')\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"ix\\<esc>\", 'tnix')\n  call assert_equal(['abxc'], getline(1, '$'))\n  \" 2) when not setting v:char, restores changed cursor position\n  au! InsertEnter <buffer> :call DoIt()\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"ix\\<esc>\", 'tnix')\n  call assert_equal(['xabc'], getline(1, '$'))\n  au! InsertEnter\n  delfu DoIt\n  bw!\nendfunc\n\nfunc Test_edit_03()\n  \" Change cursor after <c-o> command to end of line\n  new\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-o>$y\\<esc>\", 'tnix')\n  call assert_equal(['abcy'], getline(1, '$'))\n  %d\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-o>80|y\\<esc>\", 'tnix')\n  call assert_equal(['abcy'], getline(1, '$'))\n  %d\n  call setline(1, 'abc')\n  call feedkeys(\"Ad\\<c-o>:s/$/efg/\\<cr>hij\", 'tnix')\n  call assert_equal(['hijabcdefg'], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_edit_04()\n  \" test for :stopinsert\n  new\n  call setline(1, 'abc')\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-o>:stopinsert\\<cr>$\", 'tnix')\n  call feedkeys(\"aX\\<esc>\", 'tnix')\n  call assert_equal(['abcX'], getline(1, '$'))\n  %d\n  bw!\nendfunc\n\nfunc Test_edit_05()\n  \" test for folds being opened\n  new\n  call setline(1, ['abcX', 'abcX', 'zzzZ'])\n  call cursor(1, 1)\n  set foldmethod=manual foldopen+=insert\n  \" create fold for those two lines\n  norm! Vjzf\n  call feedkeys(\"$ay\\<esc>\", 'tnix')\n  call assert_equal(['abcXy', 'abcX', 'zzzZ'], getline(1, '$'))\n  %d\n  call setline(1, ['abcX', 'abcX', 'zzzZ'])\n  call cursor(1, 1)\n  set foldmethod=manual foldopen-=insert\n  \" create fold for those two lines\n  norm! Vjzf\n  call feedkeys(\"$ay\\<esc>\", 'tnix')\n  call assert_equal(['abcXy', 'abcX', 'zzzZ'], getline(1, '$'))\n  %d\n  bw!\nendfunc\n\nfunc Test_edit_06()\n  \" Test in diff mode\n  CheckFeature diff\n  CheckExecutable diff\n  new\n  call setline(1, ['abc', 'xxx', 'yyy'])\n  vnew\n  call setline(1, ['abc', 'zzz', 'xxx', 'yyy'])\n  wincmd p\n  diffthis\n  wincmd p\n  diffthis\n  wincmd p\n  call cursor(2, 1)\n  norm! zt\n  call feedkeys(\"Ozzz\\<esc>\", 'tnix')\n  call assert_equal(['abc', 'zzz', 'xxx', 'yyy'], getline(1,'$'))\n  bw!\n  bw!\nendfunc\n\nfunc Test_edit_07()\n  \" 1) Test with completion <c-l> when popupmenu is visible\n  new\n  call setline(1, 'J')\n\n  func! ListMonths()\n    call complete(col('.')-1, ['January', 'February', 'March',\n    \\ 'April', 'May', 'June', 'July', 'August', 'September',\n    \\ 'October', 'November', 'December'])\n    return ''\n  endfunc\n  inoremap <buffer> <F5> <C-R>=ListMonths()<CR>\n\n  call feedkeys(\"A\\<f5>\\<c-p>\". repeat(\"\\<down>\", 6).\"\\<c-l>\\<down>\\<c-l>\\<cr>\", 'tx')\n  call assert_equal(['July'], getline(1,'$'))\n  \" 1) Test completion when InsertCharPre kicks in\n  %d\n  call setline(1, 'J')\n  fu! DoIt()\n    if v:char=='u'\n      let v:char='an'\n    endif\n  endfu\n  au InsertCharPre <buffer> :call DoIt()\n  call feedkeys(\"A\\<f5>\\<c-p>u\\<cr>\\<c-l>\\<cr>\", 'tx')\n  call assert_equal([\"Jan\\<c-l>\",''], 1->getline('$'))\n  %d\n  call setline(1, 'J')\n  call feedkeys(\"A\\<f5>\\<c-p>u\\<down>\\<c-l>\\<cr>\", 'tx')\n  call assert_equal([\"January\"], 1->getline('$'))\n\n  delfu ListMonths\n  delfu DoIt\n  iunmap <buffer> <f5>\n  bw!\nendfunc\n\nfunc Test_edit_08()\n  \" reset insertmode from i_ctrl-r_=\n  let g:bufnr = bufnr('%')\n  new\n  call setline(1, ['abc'])\n  call cursor(1, 4)\n  call feedkeys(\":set im\\<cr>ZZZ\\<c-r>=setbufvar(g:bufnr,'&im', 0)\\<cr>\",'tnix')\n  call assert_equal(['abZZZc'], getline(1,'$'))\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call assert_false(0, '&im')\n  bw!\n  unlet g:bufnr\nendfunc\n\nfunc Test_edit_09()\n  \" test i_CTRL-\\ combinations\n  new\n  call setline(1, ['abc', 'def', 'ghi'])\n  call cursor(1, 1)\n  \" 1) CTRL-\\ CTLR-N\n  call feedkeys(\":set im\\<cr>\\<c-\\>\\<c-n>ccABC\\<c-l>\", 'txin')\n  call assert_equal(['ABC', 'def', 'ghi'], getline(1,'$'))\n  call setline(1, ['ABC', 'def', 'ghi'])\n  \" 2) CTRL-\\ CTLR-G\n  call feedkeys(\"j0\\<c-\\>\\<c-g>ZZZ\\<cr>\\<c-l>\", 'txin')\n  call assert_equal(['ABC', 'ZZZ', 'def', 'ghi'], getline(1,'$'))\n  call feedkeys(\"I\\<c-\\>\\<c-g>YYY\\<c-l>\", 'txin')\n  call assert_equal(['ABC', 'ZZZ', 'YYYdef', 'ghi'], getline(1,'$'))\n  set noinsertmode\n  \" 3) CTRL-\\ CTRL-O\n  call setline(1, ['ABC', 'ZZZ', 'def', 'ghi'])\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-o>ix\", 'txin')\n  call assert_equal(['ABxC', 'ZZZ', 'def', 'ghi'], getline(1,'$'))\n  call feedkeys(\"A\\<c-\\>\\<c-o>ix\", 'txin')\n  call assert_equal(['ABxCx', 'ZZZ', 'def', 'ghi'], getline(1,'$'))\n  \" 4) CTRL-\\ a (should be inserted literally, not special after <c-\\>\n  call setline(1, ['ABC', 'ZZZ', 'def', 'ghi'])\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-\\>a\", 'txin')\n  call assert_equal([\"ABC\\<c-\\>a\", 'ZZZ', 'def', 'ghi'], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_edit_11()\n  \" Test that indenting kicks in\n  new\n  set cindent\n  call setline(1, ['{', '', ''])\n  call cursor(2, 1)\n  call feedkeys(\"i\\<c-f>int c;\\<esc>\", 'tnix')\n  call cursor(3, 1)\n  call feedkeys(\"\\<Insert>/* comment */\", 'tnix')\n  call assert_equal(['{', \"\\<tab>int c;\", \"/* comment */\"], getline(1, '$'))\n  \" added changed cindentkeys slightly\n  set cindent cinkeys+=*/\n  call setline(1, ['{', '', ''])\n  call cursor(2, 1)\n  call feedkeys(\"i\\<c-f>int c;\\<esc>\", 'tnix')\n  call cursor(3, 1)\n  call feedkeys(\"i/* comment */\", 'tnix')\n  call assert_equal(['{', \"\\<tab>int c;\", \"\\<tab>/* comment */\"], getline(1, '$'))\n  set cindent cinkeys+==end\n  call feedkeys(\"oend\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['{', \"\\<tab>int c;\", \"\\<tab>/* comment */\", \"\\tend\", ''], getline(1, '$'))\n  set cinkeys-==end\n  %d\n  \" Use indentexpr instead of cindenting\n  func! Do_Indent()\n    if v:lnum == 3\n      return 3*shiftwidth()\n    else\n      return 2*shiftwidth()\n    endif\n  endfunc\n  setl indentexpr=Do_Indent() indentkeys+=*/\n  call setline(1, ['{', '', ''])\n  call cursor(2, 1)\n  call feedkeys(\"i\\<c-f>int c;\\<esc>\", 'tnix')\n  call cursor(3, 1)\n  call feedkeys(\"i/* comment */\", 'tnix')\n  call assert_equal(['{', \"\\<tab>\\<tab>int c;\", \"\\<tab>\\<tab>\\<tab>/* comment */\"], getline(1, '$'))\n  set cinkeys&vim indentkeys&vim\n  set nocindent indentexpr=\n  delfu Do_Indent\n  bw!\nendfunc\n\nfunc Test_edit_11_indentexpr()\n  \" Test that indenting kicks in\n  new\n  \" Use indentexpr instead of cindenting\n  func! Do_Indent()\n    let pline=prevnonblank(v:lnum)\n    if empty(getline(v:lnum))\n      if getline(pline) =~ 'if\\|then'\n        return shiftwidth()\n      else\n        return 0\n      endif\n    else\n        return 0\n    endif\n  endfunc\n  setl indentexpr=Do_Indent() indentkeys+=0=then,0=fi\n  call setline(1, ['if [ $this ]'])\n  call cursor(1, 1)\n  call feedkeys(\"othen\\<cr>that\\<cr>fi\", 'tnix')\n  call assert_equal(['if [ $this ]', \"then\", \"\\<tab>that\", \"fi\"], getline(1, '$'))\n  set cinkeys&vim indentkeys&vim\n  set nocindent indentexpr=\n  delfu Do_Indent\n  bw!\nendfunc\n\n\" Test changing indent in replace mode\nfunc Test_edit_12()\n  new\n  call setline(1, [\"\\tabc\", \"\\tdef\"])\n  call cursor(2, 4)\n  call feedkeys(\"R^\\<c-d>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"def\"], getline(1, '$'))\n  call assert_equal([0, 2, 2, 0], '.'->getpos())\n  %d\n  call setline(1, [\"\\tabc\", \"\\t\\tdef\"])\n  call cursor(2, 2)\n  call feedkeys(\"R^\\<c-d>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"def\"], getline(1, '$'))\n  call assert_equal([0, 2, 1, 0], getpos('.'))\n  %d\n  call setline(1, [\"\\tabc\", \"\\t\\tdef\"])\n  call cursor(2, 2)\n  call feedkeys(\"R\\<c-t>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"\\t\\t\\tdef\"], getline(1, '$'))\n  call assert_equal([0, 2, 2, 0], getpos('.'))\n  bw!\n  10vnew\n  call setline(1, [\"\\tabc\", \"\\t\\tdef\"])\n  call cursor(2, 2)\n  call feedkeys(\"R\\<c-t>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"\\t\\t\\tdef\"], getline(1, '$'))\n  call assert_equal([0, 2, 2, 0], getpos('.'))\n  %d\n  set sw=4\n  call setline(1, [\"\\tabc\", \"\\t\\tdef\"])\n  call cursor(2, 2)\n  call feedkeys(\"R\\<c-t>\\<c-t>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"\\t\\t\\tdef\"], getline(1, '$'))\n  call assert_equal([0, 2, 2, 0], getpos('.'))\n  %d\n  call setline(1, [\"\\tabc\", \"\\t\\tdef\"])\n  call cursor(2, 2)\n  call feedkeys(\"R\\<c-t>\\<c-t>\", 'tnix')\n  call assert_equal([\"\\tabc\", \"\\t\\t\\tdef\"], getline(1, '$'))\n  call assert_equal([0, 2, 2, 0], getpos('.'))\n  set sw&\n\n  \" In replace mode, after hitting enter in a line with tab characters,\n  \" pressing backspace should restore the tab characters.\n  %d\n  setlocal autoindent backspace=2\n  call setline(1, \"\\tone\\t\\ttwo\")\n  exe \"normal ggRred\\<CR>six\" .. repeat(\"\\<BS>\", 8)\n  call assert_equal([\"\\tone\\t\\ttwo\"], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_edit_13()\n  \" Test smartindenting\n  if exists(\"+smartindent\")\n    new\n    set smartindent autoindent\n    call setline(1, [\"\\tabc\"])\n    call feedkeys(\"A {\\<cr>more\\<cr>}\\<esc>\", 'tnix')\n    call assert_equal([\"\\tabc {\", \"\\t\\tmore\", \"\\t}\"], getline(1, '$'))\n    set smartindent& autoindent&\n    bwipe!\n  endif\n\n  \" Test autoindent removing indent of blank line.\n  new\n  call setline(1, '    foo bar baz')\n  set autoindent\n  exe \"normal 0eea\\<CR>\\<CR>\\<Esc>\"\n  call assert_equal(\"    foo bar\", getline(1))\n  call assert_equal(\"\", getline(2))\n  call assert_equal(\"    baz\", getline(3))\n  set autoindent&\n\n  \" pressing <C-U> to erase line should keep the indent with 'autoindent'\n  set backspace=2 autoindent\n  %d\n  exe \"normal i\\tone\\<CR>three\\<C-U>two\"\n  call assert_equal([\"\\tone\", \"\\ttwo\"], getline(1, '$'))\n  set backspace& autoindent&\n\n  bwipe!\nendfunc\n\n\" Test for autoindent removing indent when insert mode is stopped.  Some parts\n\" of the code is exercised only when interactive mode is used. So use Vim in a\n\" terminal.\nfunc Test_autoindent_remove_indent()\n  CheckRunVimInTerminal\n  let buf = RunVimInTerminal('-N Xfile', {'rows': 6, 'cols' : 20})\n  call TermWait(buf)\n  call term_sendkeys(buf, \":set autoindent\\n\")\n  \" leaving insert mode in a new line with indent added by autoindent, should\n  \" remove the indent.\n  call term_sendkeys(buf, \"i\\<Tab>foo\\<CR>\\<Esc>\")\n  \" Need to delay for sometime, otherwise the code in getchar.c will not be\n  \" exercised.\n  call TermWait(buf, 50)\n  \" when a line is wrapped and the cursor is at the start of the second line,\n  \" leaving insert mode, should move the cursor back to the first line.\n  call term_sendkeys(buf, \"o\" .. repeat('x', 20) .. \"\\<Esc>\")\n  \" Need to delay for sometime, otherwise the code in getchar.c will not be\n  \" exercised.\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":w\\n\")\n  call TermWait(buf)\n  call StopVimInTerminal(buf)\n  call assert_equal([\"\\tfoo\", '', repeat('x', 20)], readfile('Xfile'))\n  call delete('Xfile')\nendfunc\n\nfunc Test_edit_CR()\n  \" Test for <CR> in insert mode\n  \" basically only in quickfix mode ist tested, the rest\n  \" has been taken care of by other tests\n  CheckFeature quickfix\n  botright new\n  call writefile(range(1, 10), 'Xqflist.txt')\n  call setqflist([{'filename': 'Xqflist.txt', 'lnum': 2}])\n  copen\n  set modifiable\n  call feedkeys(\"A\\<cr>\", 'tnix')\n  call assert_equal('Xqflist.txt', bufname(''))\n  call assert_equal(2, line('.'))\n  cclose\n  botright new\n  call setloclist(0, [{'filename': 'Xqflist.txt', 'lnum': 10}])\n  lopen\n  set modifiable\n  call feedkeys(\"A\\<cr>\", 'tnix')\n  call assert_equal('Xqflist.txt', bufname(''))\n  call assert_equal(10, line('.'))\n  call feedkeys(\"A\\<Enter>\", 'tnix')\n  call feedkeys(\"A\\<kEnter>\", 'tnix')\n  call feedkeys(\"A\\n\", 'tnix')\n  call feedkeys(\"A\\r\", 'tnix')\n  call assert_equal(map(range(1, 10), 'string(v:val)') + ['', '', '', ''], getline(1, '$'))\n  bw!\n  lclose\n  call delete('Xqflist.txt')\nendfunc\n\nfunc Test_edit_CTRL_()\n  CheckFeature rightleft\n  \" disabled for Windows builds, why?\n  CheckNotMSWindows\n  let _encoding=&encoding\n  set encoding=utf-8\n  \" Test for CTRL-_\n  new\n  call setline(1, ['abc'])\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-_>xyz\\<esc>\", 'tnix')\n  call assert_equal([\"\\<C-_>xyzabc\"], getline(1, '$'))\n  call assert_false(&revins)\n  set ari\n  call setline(1, ['abc'])\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-_>xyz\\<esc>\", 'tnix')\n  call assert_equal([\"\u00e6\u00e8\u00f1abc\"], getline(1, '$'))\n  call assert_true(&revins)\n  call setline(1, ['abc'])\n  call cursor(1, 1)\n  call feedkeys(\"i\\<c-_>xyz\\<esc>\", 'tnix')\n  call assert_equal([\"xyzabc\"], getline(1, '$'))\n  call assert_false(&revins)\n  set noari\n  let &encoding=_encoding\n  bw!\nendfunc\n\n\" needs to come first, to have the @. register empty\nfunc Test_edit_00a_CTRL_A()\n  \" Test pressing CTRL-A\n  new\n  call setline(1, repeat([''], 5))\n  call cursor(1, 1)\n  try\n    call feedkeys(\"A\\<NUL>\", 'tnix')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E29/\n    call assert_true(1, 'E29 error caught')\n  endtry\n  call cursor(1, 1)\n  call feedkeys(\"Afoobar \\<esc>\", 'tnix')\n  call cursor(2, 1)\n  call feedkeys(\"A\\<c-a>more\\<esc>\", 'tnix')\n  call cursor(3, 1)\n  call feedkeys(\"A\\<NUL>and more\\<esc>\", 'tnix')\n  call assert_equal(['foobar ', 'foobar more', 'foobar morend more', '', ''], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_EY()\n  \" Ctrl-E/ Ctrl-Y in insert mode completion to scroll\n  10new\n  call setline(1, range(1, 100))\n  call cursor(30, 1)\n  norm! z.\n  call feedkeys(\"A\\<c-x>\\<c-e>\\<c-e>\\<c-e>\\<c-e>\\<c-e>\", 'tnix')\n  call assert_equal(30, winsaveview()['topline'])\n  call assert_equal([0, 30, 2, 0], getpos('.'))\n  call feedkeys(\"A\\<c-x>\\<c-e>\\<c-e>\\<c-e>\\<c-e>\\<c-e>\", 'tnix')\n  call feedkeys(\"A\\<c-x>\".repeat(\"\\<c-y>\", 10), 'tnix')\n  call assert_equal(21, winsaveview()['topline'])\n  call assert_equal([0, 30, 2, 0], getpos('.'))\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_G()\n  new\n  call setline(1, ['foobar', 'foobar', 'foobar'])\n  call cursor(2, 4)\n  call feedkeys(\"ioooooooo\\<c-g>k\\<c-r>.\\<esc>\", 'tnix')\n  call assert_equal(['foooooooooobar', 'foooooooooobar', 'foobar'], getline(1, '$'))\n  call assert_equal([0, 1, 11, 0], getpos('.'))\n  call feedkeys(\"i\\<c-g>k\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 10, 0], getpos('.'))\n  call cursor(2, 4)\n  call feedkeys(\"i\\<c-g>jzzzz\\<esc>\", 'tnix')\n  call assert_equal(['foooooooooobar', 'foooooooooobar', 'foozzzzbar'], getline(1, '$'))\n  call assert_equal([0, 3, 7, 0], getpos('.'))\n  call feedkeys(\"i\\<c-g>j\\<esc>\", 'tnix')\n  call assert_equal([0, 3, 6, 0], getpos('.'))\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_I()\n  \" Tab in completion mode\n  let path=expand(\"%:p:h\")\n  new\n  call setline(1, [path. \"/\", ''])\n  call feedkeys(\"Arunt\\<c-x>\\<c-f>\\<tab>\\<cr>\\<esc>\", 'tnix')\n  call assert_match('runtest\\.vim', getline(1))\n  %d\n  call writefile(['one', 'two', 'three'], 'Xinclude.txt')\n  let include='#include Xinclude.txt'\n  call setline(1, [include, ''])\n  call cursor(2, 1)\n  call feedkeys(\"A\\<c-x>\\<tab>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([include, 'one', ''], getline(1, '$'))\n  call feedkeys(\"2ggC\\<c-x>\\<tab>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([include, 'two', ''], getline(1, '$'))\n  call feedkeys(\"2ggC\\<c-x>\\<tab>\\<down>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([include, 'three', ''], getline(1, '$'))\n  call feedkeys(\"2ggC\\<c-x>\\<tab>\\<down>\\<down>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([include, '', ''], getline(1, '$'))\n  call delete(\"Xinclude.txt\")\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_K()\n  \" Test pressing CTRL-K (basically only dictionary completion and digraphs\n  \" the rest is already covered\n  call writefile(['A', 'AA', 'AAA', 'AAAA'], 'Xdictionary.txt')\n  set dictionary=Xdictionary.txt\n  new\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['AA', ''], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['AAA'], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<down>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['AAAA'], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<down>\\<down>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['A'], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<down>\\<down>\\<down>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['AA'], getline(1, '$'))\n\n  \" press an unexpected key after dictionary completion\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<c-]>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['AA', ''], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<c-s>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([\"AA\\<c-s>\", ''], getline(1, '$'))\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-k>\\<c-f>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([\"AA\\<c-f>\", ''], getline(1, '$'))\n\n  set dictionary=\n  %d\n  call setline(1, 'A')\n  call cursor(1, 1)\n  let v:testing = 1\n  try\n    call feedkeys(\"A\\<c-x>\\<c-k>\\<esc>\", 'tnix')\n  catch\n    \" error sleeps 2 seconds, when v:testing is not set\n    let v:testing = 0\n  endtry\n  call delete('Xdictionary.txt')\n\n  call test_override(\"char_avail\", 1)\n  set showcmd\n  %d\n  call feedkeys(\"A\\<c-k>a:\\<esc>\", 'tnix')\n  call assert_equal(['\u00e4'], getline(1, '$'))\n  call test_override(\"char_avail\", 0)\n  set noshowcmd\n\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_L()\n  \" Test Ctrl-X Ctrl-L (line completion)\n  new\n  set complete=.\n  call setline(1, ['one', 'two', 'three', '', '', '', ''])\n  call cursor(4, 1)\n  call feedkeys(\"A\\<c-x>\\<c-l>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'three', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-n>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 't', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-n>\\<c-n>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'two', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-n>\\<c-n>\\<c-n>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'three', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-n>\\<c-n>\\<c-n>\\<c-n>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 't', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-p>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'two', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-p>\\<c-p>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 't', '', '', ''], getline(1, '$'))\n  call feedkeys(\"cct\\<c-x>\\<c-l>\\<c-p>\\<c-p>\\<c-p>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'three', '', '', ''], getline(1, '$'))\n  set complete=\n  call cursor(5, 1)\n  call feedkeys(\"A\\<c-x>\\<c-l>\\<c-p>\\<c-n>\\<esc>\", 'tnix')\n  call assert_equal(['one', 'two', 'three', 'three', \"\\<c-l>\\<c-p>\\<c-n>\", '', ''], getline(1, '$'))\n  set complete&\n  %d\n  if has(\"conceal\") && has(\"syntax\")\n    call setline(1, ['foo', 'bar', 'foobar'])\n    call test_override(\"char_avail\", 1)\n    set conceallevel=2 concealcursor=n\n    syn on\n    syn match ErrorMsg \"^bar\"\n    call matchadd(\"Conceal\", 'oo', 10, -1, {'conceal': 'X'})\n    func! DoIt()\n      let g:change=1\n    endfunc\n    au! TextChangedI <buffer> :call DoIt()\n\n    call cursor(2, 1)\n    call assert_false(exists(\"g:change\"))\n    call feedkeys(\"A \\<esc>\", 'tnix')\n    call assert_equal(['foo', 'bar ', 'foobar'], getline(1, '$'))\n    call assert_equal(1, g:change)\n\n    call test_override(\"char_avail\", 0)\n    call clearmatches()\n    syn off\n    au! TextChangedI\n    delfu DoIt\n    unlet! g:change\n  endif\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_N()\n  \" Check keyword completion\n  for e in ['latin1', 'utf-8']\n    exe 'set encoding=' .. e\n    new\n    set complete=.\n    call setline(1, ['INFER', 'loWER', '', '', ])\n    call cursor(3, 1)\n    call feedkeys(\"Ai\\<c-n>\\<cr>\\<esc>\", \"tnix\")\n    call feedkeys(\"ILO\\<c-n>\\<cr>\\<esc>\", 'tnix')\n    call assert_equal(['INFER', 'loWER', 'i', 'LO', '', ''], getline(1, '$'), e)\n    %d\n    call setline(1, ['INFER', 'loWER', '', '', ])\n    call cursor(3, 1)\n    set ignorecase infercase\n    call feedkeys(\"Ii\\<c-n>\\<cr>\\<esc>\", \"tnix\")\n    call feedkeys(\"ILO\\<c-n>\\<cr>\\<esc>\", 'tnix')\n    call assert_equal(['INFER', 'loWER', 'infer', 'LOWER', '', ''], getline(1, '$'), e)\n\n    set noignorecase noinfercase complete&\n    bw!\n  endfor\nendfunc\n\nfunc Test_edit_CTRL_O()\n  \" Check for CTRL-O in insert mode\n  new\n  inoreabbr <buffer> h here some more\n  call setline(1, ['abc', 'def'])\n  call cursor(1, 1)\n  \" Ctrl-O after an abbreviation\n  exe \"norm A h\\<c-o>:set nu\\<cr> text\"\n  call assert_equal(['abc here some more text', 'def'], getline(1, '$'))\n  call assert_true(&nu)\n  set nonu\n  iunabbr <buffer> h\n  \" Ctrl-O at end of line with 've'=onemore\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-o>:let g:a=getpos('.')\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 23, 0], g:a)\n  call cursor(1, 1)\n  set ve=onemore\n  call feedkeys(\"A\\<c-o>:let g:a=getpos('.')\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 24, 0], g:a)\n  set ve=\n  unlet! g:a\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_R()\n  \" Insert Register\n  new\n  call test_override(\"ALL\", 1)\n  set showcmd\n  call feedkeys(\"AFOOBAR eins zwei\\<esc>\", 'tnix')\n  call feedkeys(\"O\\<c-r>.\", 'tnix')\n  call feedkeys(\"O\\<c-r>=10*500\\<cr>\\<esc>\", 'tnix')\n  call feedkeys(\"O\\<c-r>=getreg('=', 1)\\<cr>\\<esc>\", 'tnix')\n  call assert_equal([\"getreg('=', 1)\", '5000', \"FOOBAR eins zwei\", \"FOOBAR eins zwei\"], getline(1, '$'))\n  call test_override(\"ALL\", 0)\n  set noshowcmd\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_S()\n  \" Test pressing CTRL-S (basically only spellfile completion)\n  \" the rest is already covered\n  new\n  if !has(\"spell\")\n    call setline(1, 'vim')\n    call feedkeys(\"A\\<c-x>ss\\<cr>\\<esc>\", 'tnix')\n    call assert_equal(['vims', ''], getline(1, '$'))\n    bw!\n    return\n  endif\n  call setline(1, 'vim')\n  \" spell option not yet set\n  try\n    call feedkeys(\"A\\<c-x>\\<c-s>\\<cr>\\<esc>\", 'tnix')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E756/\n    call assert_true(1, 'error caught')\n  endtry\n  call assert_equal(['vim', ''], getline(1, '$'))\n  %d\n  setl spell spelllang=en\n  call setline(1, 'vim')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-s>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['Vim', ''], getline(1, '$'))\n  %d\n  call setline(1, 'vim')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-s>\\<down>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['Aim'], getline(1, '$'))\n  %d\n  call setline(1, 'vim')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-s>\\<c-p>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['vim', ''], getline(1, '$'))\n  %d\n  \" empty buffer\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-s>\\<c-p>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['', ''], getline(1, '$'))\n  setl nospell\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_T()\n  \" Check for CTRL-T and CTRL-X CTRL-T in insert mode\n  \" 1) increase indent\n  new\n  call setline(1, \"abc\")\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-t>xyz\", 'tnix')\n  call assert_equal([\"\\<tab>abcxyz\"], getline(1, '$'))\n  \" 2) also when paste option is set\n  set paste\n  call setline(1, \"abc\")\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-t>xyz\", 'tnix')\n  call assert_equal([\"\\<tab>abcxyz\"], getline(1, '$'))\n  set nopaste\n  \" CTRL-X CTRL-T (thesaurus complete)\n  call writefile(['angry furious mad enraged'], 'Xthesaurus')\n  set thesaurus=Xthesaurus\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['mad', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['angry', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['furious', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<c-n>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['enraged', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<c-n>\\<c-n>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['mad', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<c-n>\\<c-n>\\<c-n>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['mad', ''], getline(1, '$'))\n  \" Using <c-p> <c-n> when 'complete' is empty\n  set complete=\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['angry', ''], getline(1, '$'))\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  call feedkeys(\"A\\<c-x>\\<c-t>\\<c-p>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['mad', ''], getline(1, '$'))\n  set complete&\n\n  set thesaurus=\n  %d\n  call setline(1, 'mad')\n  call cursor(1, 1)\n  let v:testing = 1\n  try\n    call feedkeys(\"A\\<c-x>\\<c-t>\\<esc>\", 'tnix')\n  catch\n    \" error sleeps 2 seconds, when v:testing is not set\n    let v:testing = 0\n  endtry\n  call assert_equal(['mad'], getline(1, '$'))\n  call delete('Xthesaurus')\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_U()\n  \" Test 'completefunc'\n  new\n  \" -1, -2 and -3 are special return values\n  let g:special=0\n  fun! CompleteMonths(findstart, base)\n    if a:findstart\n      \" locate the start of the word\n      return g:special\n    else\n      \" find months matching with \"a:base\"\n      let res = []\n      for m in split(\"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\")\n        if m =~ '^\\c'.a:base\n          call add(res, {'word': m, 'abbr': m.' Month', 'icase': 0})\n        endif\n      endfor\n      return {'words': res, 'refresh': 'always'}\n    endif\n  endfun\n  set completefunc=CompleteMonths\n  call setline(1, ['', ''])\n  call cursor(1, 1)\n  call feedkeys(\"AX\\<c-x>\\<c-u>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['X', '', ''], getline(1, '$'))\n  %d\n  let g:special=-1\n  call feedkeys(\"AX\\<c-x>\\<c-u>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['XJan', ''], getline(1, '$'))\n  %d\n  let g:special=-2\n  call feedkeys(\"AX\\<c-x>\\<c-u>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['X', ''], getline(1, '$'))\n  %d\n  let g:special=-3\n  call feedkeys(\"AX\\<c-x>\\<c-u>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['X', ''], getline(1, '$'))\n  %d\n  let g:special=0\n  call feedkeys(\"AM\\<c-x>\\<c-u>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['Mar', ''], getline(1, '$'))\n  %d\n  call feedkeys(\"AM\\<c-x>\\<c-u>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['May', ''], getline(1, '$'))\n  %d\n  call feedkeys(\"AM\\<c-x>\\<c-u>\\<c-n>\\<c-n>\\<cr>\\<esc>\", 'tnix')\n  call assert_equal(['M', ''], getline(1, '$'))\n  delfu CompleteMonths\n  %d\n  try\n    call feedkeys(\"A\\<c-x>\\<c-u>\", 'tnix')\n    call assert_fails(1, 'unknown completion function')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E117/\n    call assert_true(1, 'E117 error caught')\n  endtry\n  set completefunc=\n  bw!\nendfunc\n\nfunc Test_edit_completefunc_delete()\n  func CompleteFunc(findstart, base)\n    if a:findstart == 1\n      return col('.') - 1\n    endif\n    normal dd\n    return ['a', 'b']\n  endfunc\n  new\n  set completefunc=CompleteFunc\n  call setline(1, ['', 'abcd', ''])\n  2d\n  call assert_fails(\"normal 2G$a\\<C-X>\\<C-U>\", 'E578:')\n  bwipe!\nendfunc\n\n\nfunc Test_edit_CTRL_Z()\n  \" Ctrl-Z when insertmode is not set inserts it literally\n  new\n  call setline(1, 'abc')\n  call feedkeys(\"A\\<c-z>\\<esc>\", 'tnix')\n  call assert_equal([\"abc\\<c-z>\"], getline(1,'$'))\n  bw!\n  \" TODO: How to Test Ctrl-Z in insert mode, e.g. suspend?\nendfunc\n\nfunc Test_edit_DROP()\n  CheckFeature dnd\n  new\n  call setline(1, ['abc def ghi'])\n  call cursor(1, 1)\n  try\n    call feedkeys(\"i\\<Drop>\\<Esc>\", 'tnix')\n    call assert_fails(1, 'Invalid register name')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E353/\n    call assert_true(1, 'error caught')\n  endtry\n  bw!\nendfunc\n\nfunc Test_edit_CTRL_V()\n  CheckFeature ebcdic\n  new\n  call setline(1, ['abc'])\n  call cursor(2, 1)\n  \" force some redraws\n  set showmode showcmd\n  \"call test_override_char_avail(1)\n  call test_override('ALL', 1)\n  call feedkeys(\"A\\<c-v>\\<c-n>\\<c-v>\\<c-l>\\<c-v>\\<c-b>\\<esc>\", 'tnix')\n  call assert_equal([\"abc\\x0e\\x0c\\x02\"], getline(1, '$'))\n\n  if has(\"rightleft\") && exists(\"+rl\")\n    set rl\n    call setline(1, ['abc'])\n    call cursor(2, 1)\n    call feedkeys(\"A\\<c-v>\\<c-n>\\<c-v>\\<c-l>\\<c-v>\\<c-b>\\<esc>\", 'tnix')\n    call assert_equal([\"abc\\x0e\\x0c\\x02\"], getline(1, '$'))\n    set norl\n  endif\n\n  call test_override('ALL', 0)\n  set noshowmode showcmd\n  bw!\nendfunc\n\nfunc Test_edit_F1()\n  CheckFeature quickfix\n\n  \" Pressing <f1>\n  new\n  call feedkeys(\":set im\\<cr>\\<f1>\\<c-l>\", 'tnix')\n  set noinsertmode\n  call assert_equal('help', &buftype)\n  bw\n  bw\nendfunc\n\nfunc Test_edit_F21()\n  \" Pressing <f21>\n  \" sends a netbeans command\n  CheckFeature netbeans_intg\n  new\n  \" I have no idea what this is supposed to do :)\n  call feedkeys(\"A\\<F21>\\<F1>\\<esc>\", 'tnix')\n  bw\nendfunc\n\nfunc Test_edit_HOME_END()\n  \" Test Home/End Keys\n  new\n  set foldopen+=hor\n  call setline(1, ['abc', 'def'])\n  call cursor(1, 1)\n  call feedkeys(\"AX\\<Home>Y\\<esc>\", 'tnix')\n  call cursor(2, 1)\n  call feedkeys(\"iZ\\<End>Y\\<esc>\", 'tnix')\n  call assert_equal(['YabcX', 'ZdefY'], getline(1, '$'))\n\n  set foldopen-=hor\n  bw!\nendfunc\n\nfunc Test_edit_INS()\n  \" Test for Pressing <Insert>\n  new\n  call setline(1, ['abc', 'def'])\n  call cursor(1, 1)\n  call feedkeys(\"i\\<Insert>ZYX>\", 'tnix')\n  call assert_equal(['ZYX>', 'def'], getline(1, '$'))\n  call setline(1, ['abc', 'def'])\n  call cursor(1, 1)\n  call feedkeys(\"i\\<Insert>Z\\<Insert>YX>\", 'tnix')\n  call assert_equal(['ZYX>bc', 'def'], getline(1, '$'))\n  bw!\nendfunc\n\nfunc Test_edit_LEFT_RIGHT()\n  \" Left, Shift-Left, Right, Shift-Right\n  new\n  call setline(1, ['abc def ghi', 'ABC DEF GHI', 'ZZZ YYY XXX'])\n  let _ww=&ww\n  set ww=\n  call cursor(2, 1)\n  call feedkeys(\"i\\<left>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 1, 0], getpos('.'))\n  \" Is this a bug, <s-left> does not respect whichwrap option\n  call feedkeys(\"i\\<s-left>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 8, 0], getpos('.'))\n  call feedkeys(\"i\". repeat(\"\\<s-left>\", 3). \"\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<right>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<right>\\<right>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 2, 0], getpos('.'))\n  call feedkeys(\"A\\<right>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<s-right>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<s-right>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 4, 0], getpos('.'))\n  call cursor(3, 11)\n  call feedkeys(\"A\\<right>\\<esc>\", 'tnix')\n  call feedkeys(\"A\\<s-right>\\<esc>\", 'tnix')\n  call assert_equal([0, 3, 11, 0], getpos('.'))\n  call cursor(2, 11)\n  \" <S-Right> does not respect 'whichwrap' option\n  call feedkeys(\"A\\<s-right>\\<esc>\", 'tnix')\n  call assert_equal([0, 3, 1, 0], getpos('.'))\n  \" Check motion when 'whichwrap' contains cursor keys for insert mode\n  set ww+=[,]\n  call cursor(2, 1)\n  call feedkeys(\"i\\<left>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 11, 0], getpos('.'))\n  call cursor(2, 11)\n  call feedkeys(\"A\\<right>\\<esc>\", 'tnix')\n  call assert_equal([0, 3, 1, 0], getpos('.'))\n  call cursor(2, 11)\n  call feedkeys(\"A\\<s-right>\\<esc>\", 'tnix')\n  call assert_equal([0, 3, 1, 0], getpos('.'))\n  let &ww = _ww\n  bw!\nendfunc\n\nfunc Test_edit_MOUSE()\n  \" This is a simple test, since we not really using the mouse here\n  CheckFeature mouse\n  10new\n  call setline(1, range(1, 100))\n  call cursor(1, 1)\n  set mouse=a\n  call feedkeys(\"A\\<ScrollWheelDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 4, 1, 0], getpos('.'))\n  \" This should move by one pageDown, but only moves\n  \" by one line when the test is run...\n  call feedkeys(\"A\\<S-ScrollWheelDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 1, 0], getpos('.'))\n  set nostartofline\n  call feedkeys(\"A\\<C-ScrollWheelDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 6, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<LeftMouse>\\<esc>\", 'tnix')\n  call assert_equal([0, 6, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<RightMouse>\\<esc>\", 'tnix')\n  call assert_equal([0, 6, 1, 0], getpos('.'))\n  call cursor(1, 100)\n  norm! zt\n  \" this should move by a screen up, but when the test\n  \" is run, it moves up to the top of the buffer...\n  call feedkeys(\"A\\<ScrollWheelUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call cursor(1, 30)\n  norm! zt\n  call feedkeys(\"A\\<S-ScrollWheelUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  call cursor(1, 30)\n  norm! zt\n  call feedkeys(\"A\\<C-ScrollWheelUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  %d\n  call setline(1, repeat([\"12345678901234567890\"], 100))\n  call cursor(2, 1)\n  call feedkeys(\"A\\<ScrollWheelRight>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  call feedkeys(\"A\\<ScrollWheelLeft>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  call feedkeys(\"A\\<S-ScrollWheelRight>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  call feedkeys(\"A\\<S-ScrollWheelLeft>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  call feedkeys(\"A\\<C-ScrollWheelRight>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  call feedkeys(\"A\\<C-ScrollWheelLeft>\\<esc>\", 'tnix')\n  call assert_equal([0, 2, 20, 0], getpos('.'))\n  set mouse& startofline\n  bw!\nendfunc\n\nfunc Test_edit_PAGEUP_PAGEDOWN()\n  10new\n  call setline(1, repeat(['abc def ghi'], 30))\n  call cursor(1, 1)\n  call feedkeys(\"i\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 9, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 17, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 25, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 29, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 21, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 13, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  \" <S-Up> is the same as <PageUp>\n  \" <S-Down> is the same as <PageDown>\n  call cursor(1, 1)\n  call feedkeys(\"i\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 9, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 17, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 25, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 1, 0], getpos('.'))\n  call feedkeys(\"i\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 29, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 21, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 13, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 1, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  set nostartofline\n  call cursor(30, 11)\n  norm! zt\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 29, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 21, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 13, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageUp>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  call cursor(1, 1)\n  call feedkeys(\"A\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 9, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 17, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 25, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<PageDown>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 11, 0], getpos('.'))\n  \" <S-Up> is the same as <PageUp>\n  \" <S-Down> is the same as <PageDown>\n  call cursor(30, 11)\n  norm! zt\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 29, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 21, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 13, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Up>\\<esc>\", 'tnix')\n  call assert_equal([0, 5, 11, 0], getpos('.'))\n  call cursor(1, 1)\n  call feedkeys(\"A\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 9, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 17, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 25, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 11, 0], getpos('.'))\n  call feedkeys(\"A\\<S-Down>\\<esc>\", 'tnix')\n  call assert_equal([0, 30, 11, 0], getpos('.'))\n  bw!\nendfunc\n\nfunc Test_edit_forbidden()\n  new\n  \" 1) edit in the sandbox is not allowed\n  call setline(1, 'a')\n  com! Sandbox :sandbox call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n  call assert_fails(':Sandbox', 'E48:')\n  com! Sandbox :sandbox exe \"norm! i\\<del>\"\n  call assert_fails(':Sandbox', 'E48:')\n  delcom Sandbox\n  call assert_equal(['a'], getline(1,'$'))\n  \" 2) edit with textlock set\n  fu! DoIt()\n    call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n  endfu\n  au InsertCharPre <buffer> :call DoIt()\n  try\n    call feedkeys(\"ix\\<esc>\", 'tnix')\n    call assert_fails(1, 'textlock')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E565/ \" catch E565: not allowed here\n  endtry\n  \" TODO: Might be a bug: should x really be inserted here\n  call assert_equal(['xa'], getline(1, '$'))\n  delfu DoIt\n  try\n    call feedkeys(\"ix\\<esc>\", 'tnix')\n    call assert_fails(1, 'unknown function')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E117/ \" catch E117: unknown function\n  endtry\n  au! InsertCharPre\n  \" 3) edit when completion is shown\n  fun! Complete(findstart, base)\n    if a:findstart\n      return col('.')\n    else\n      call feedkeys(\"i\\<del>\\<esc>\", 'tnix')\n      return []\n    endif\n  endfun\n  set completefunc=Complete\n  try\n    call feedkeys(\"i\\<c-x>\\<c-u>\\<esc>\", 'tnix')\n    call assert_fails(1, 'change in complete function')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E565/ \" catch E565\n  endtry\n  delfu Complete\n  set completefunc=\n  if has(\"rightleft\") && exists(\"+fkmap\")\n    \" 4) 'R' when 'fkmap' and 'revins' is set.\n    set revins fkmap\n    try\n      normal Ri\n      call assert_fails(1, \"R with 'fkmap' and 'ri' set\")\n    catch\n    finally\n      set norevins nofkmap\n    endtry\n  endif\n  bw!\nendfunc\n\nfunc Test_edit_rightleft()\n  \" Cursor in rightleft mode moves differently\n  CheckFeature rightleft\n  call NewWindow(10, 20)\n  call setline(1, ['abc', 'def', 'ghi'])\n  call cursor(1, 2)\n  set rightleft\n  \" Screen looks as expected\n  let lines = ScreenLines([1, 4], winwidth(0))\n  let expect = [\n        \\\"                 cba\",\n        \\\"                 fed\",\n        \\\"                 ihg\",\n        \\\"                   ~\"]\n  call assert_equal(join(expect, \"\\n\"), join(lines, \"\\n\"))\n  \" 2) right moves to the left\n  call feedkeys(\"i\\<right>\\<esc>x\", 'txin')\n  call assert_equal(['bc', 'def', 'ghi'], getline(1,'$'))\n  call cursor(1, 2)\n  call feedkeys(\"i\\<s-right>\\<esc>\", 'txin')\n  call cursor(1, 2)\n  call feedkeys(\"i\\<c-right>\\<esc>\", 'txin')\n  \" Screen looks as expected\n  let lines = ScreenLines([1, 4], winwidth(0))\n  let expect = [\n        \\\"                  cb\",\n        \\\"                 fed\",\n        \\\"                 ihg\",\n        \\\"                   ~\"]\n  call assert_equal(join(expect, \"\\n\"), join(lines, \"\\n\"))\n  \" 2) left moves to the right\n  call setline(1, ['abc', 'def', 'ghi'])\n  call cursor(1, 2)\n  call feedkeys(\"i\\<left>\\<esc>x\", 'txin')\n  call assert_equal(['ac', 'def', 'ghi'], getline(1,'$'))\n  call cursor(1, 2)\n  call feedkeys(\"i\\<s-left>\\<esc>\", 'txin')\n  call cursor(1, 2)\n  call feedkeys(\"i\\<c-left>\\<esc>\", 'txin')\n  \" Screen looks as expected\n  let lines = ScreenLines([1, 4], winwidth(0))\n  let expect = [\n        \\\"                  ca\",\n        \\\"                 fed\",\n        \\\"                 ihg\",\n        \\\"                   ~\"]\n  call assert_equal(join(expect, \"\\n\"), join(lines, \"\\n\"))\n  %d _\n  call test_override('redraw_flag', 1)\n  call test_override('char_avail', 1)\n  call feedkeys(\"a\\<C-V>x41\", \"xt\")\n  redraw!\n  call assert_equal(repeat(' ', 19) .. 'A', Screenline(1))\n  call test_override('ALL', 0)\n  set norightleft\n  bw!\nendfunc\n\nfunc Test_edit_complete_very_long_name()\n  \" Long directory names only work on Unix.\n  CheckUnix\n\n  let dirname = getcwd() . \"/Xdir\"\n  let longdirname = dirname . repeat('/' . repeat('d', 255), 4)\n  try\n    call mkdir(longdirname, 'p')\n  catch /E739:/\n    \" Long directory name probably not supported.\n    call delete(dirname, 'rf')\n    return\n  endtry\n\n  \" Try to get the Vim window position before setting 'columns', so that we can\n  \" move the window back to where it was.\n  let winposx = getwinposx()\n  let winposy = getwinposy()\n\n  if winposx >= 0 && winposy >= 0 && !has('gui_running')\n    \" We did get the window position, but xterm may report the wrong numbers.\n    \" Move the window to the reported position and compute any offset.\n    exe 'winpos ' . winposx . ' ' . winposy\n    sleep 100m\n    let x = getwinposx()\n    if x >= 0\n      let winposx += winposx - x\n    endif\n    let y = getwinposy()\n    if y >= 0\n      let winposy += winposy - y\n    endif\n  endif\n\n  let save_columns = &columns\n  \" Need at least about 1100 columns to reproduce the problem.\n  set columns=2000\n  set noswapfile\n\n  let longfilename = longdirname . '/' . repeat('a', 255)\n  call writefile(['Totum', 'Table'], longfilename)\n  new\n  exe \"next Xfile \" . longfilename\n  exe \"normal iT\\<C-N>\"\n\n  bwipe!\n  exe 'bwipe! ' . longfilename\n  call delete(dirname, 'rf')\n  let &columns = save_columns\n  if winposx >= 0 && winposy >= 0\n    exe 'winpos ' . winposx . ' ' . winposy\n  endif\n  set swapfile&\nendfunc\n\nfunc Test_edit_backtick()\n  next a\\`b c\n  call assert_equal('a`b', expand('%'))\n  next\n  call assert_equal('c', expand('%'))\n  call assert_equal('a\\`b c', expand('##'))\nendfunc\n\nfunc Test_edit_quit()\n  edit foo.txt\n  split\n  new\n  call setline(1, 'hello')\n  3wincmd w\n  redraw!\n  call assert_fails('1q', 'E37:')\n  bwipe! foo.txt\n  only\nendfunc\n\nfunc Test_edit_alt()\n  \" Keeping the cursor line didn't happen when the first line has indent.\n  new\n  call setline(1, ['  one', 'two', 'three'])\n  w XAltFile\n  $\n  call assert_equal(3, line('.'))\n  e Xother\n  e #\n  call assert_equal(3, line('.'))\n\n  bwipe XAltFile\n  call delete('XAltFile')\nendfunc\n\nfunc Test_edit_InsertLeave()\n  new\n  au InsertLeavePre * let g:did_au_pre = 1\n  au InsertLeave * let g:did_au = 1\n  let g:did_au_pre = 0\n  let g:did_au = 0\n  call feedkeys(\"afoo\\<Esc>\", 'tx')\n  call assert_equal(1, g:did_au_pre)\n  call assert_equal(1, g:did_au)\n  call assert_equal('foo', getline(1))\n\n  let g:did_au_pre = 0\n  let g:did_au = 0\n  call feedkeys(\"Sbar\\<C-C>\", 'tx')\n  call assert_equal(1, g:did_au_pre)\n  call assert_equal(0, g:did_au)\n  call assert_equal('bar', getline(1))\n\n  inoremap x xx<Esc>\n  let g:did_au_pre = 0\n  let g:did_au = 0\n  call feedkeys(\"Saax\", 'tx')\n  call assert_equal(1, g:did_au_pre)\n  call assert_equal(1, g:did_au)\n  call assert_equal('aaxx', getline(1))\n\n  inoremap x xx<C-C>\n  let g:did_au_pre = 0\n  let g:did_au = 0\n  call feedkeys(\"Sbbx\", 'tx')\n  call assert_equal(1, g:did_au_pre)\n  call assert_equal(0, g:did_au)\n  call assert_equal('bbxx', getline(1))\n\n  bwipe!\n  au! InsertLeave InsertLeavePre\n  iunmap x\nendfunc\n\nfunc Test_edit_InsertLeave_undo()\n  new XtestUndo\n  set undofile\n  au InsertLeave * wall\n  exe \"normal ofoo\\<Esc>\"\n  call assert_equal(2, line('$'))\n  normal u\n  call assert_equal(1, line('$'))\n\n  bwipe!\n  au! InsertLeave\n  call delete('XtestUndo')\n  call delete(undofile('XtestUndo'))\n  set undofile&\nendfunc\n\n\" Test for inserting characters using CTRL-V followed by a number.\nfunc Test_edit_special_chars()\n  new\n\n  if has(\"ebcdic\")\n    let t = \"o\\<C-V>193\\<C-V>xc2\\<C-V>o303 \\<C-V>90a\\<C-V>xfg\\<C-V>o578\\<Esc>\"\n  else\n    let t = \"o\\<C-V>65\\<C-V>x42\\<C-V>o103 \\<C-V>33a\\<C-V>xfg\\<C-V>o78\\<Esc>\"\n  endif\n\n  exe \"normal \" . t\n  call assert_equal(\"ABC !a\\<C-O>g\\<C-G>8\", getline(2))\n\n  close!\nendfunc\n\nfunc Test_edit_startinsert()\n  new\n  set backspace+=start\n  call setline(1, 'foobar')\n  call feedkeys(\"A\\<C-U>\\<Esc>\", 'xt')\n  call assert_equal('', getline(1))\n\n  call setline(1, 'foobar')\n  call feedkeys(\":startinsert!\\<CR>\\<C-U>\\<Esc>\", 'xt')\n  call assert_equal('', getline(1))\n\n  set backspace&\n  bwipe!\nendfunc\n\n\" Test for :startreplace and :startgreplace\nfunc Test_edit_startreplace()\n  new\n  call setline(1, 'abc')\n  call feedkeys(\"l:startreplace\\<CR>xyz\\e\", 'xt')\n  call assert_equal('axyz', getline(1))\n  call feedkeys(\"0:startreplace!\\<CR>abc\\e\", 'xt')\n  call assert_equal('axyzabc', getline(1))\n  call setline(1, \"a\\tb\")\n  call feedkeys(\"0l:startgreplace\\<CR>xyz\\e\", 'xt')\n  call assert_equal(\"axyz\\tb\", getline(1))\n  call feedkeys(\"0i\\<C-R>=execute('startreplace')\\<CR>12\\e\", 'xt')\n  call assert_equal(\"12axyz\\tb\", getline(1))\n  close!\nendfunc\n\nfunc Test_edit_noesckeys()\n  CheckNotGui\n  new\n\n  \" <Left> moves cursor when 'esckeys' is set\n  exe \"set t_kl=\\<Esc>OD\"\n  set esckeys\n  call feedkeys(\"axyz\\<Esc>ODX\", \"xt\")\n  call assert_equal(\"xyXz\", getline(1))\n\n  \" <Left> exits Insert mode when 'esckeys' is off\n  set noesckeys\n  call setline(1, '')\n  call feedkeys(\"axyz\\<Esc>ODX\", \"xt\")\n  call assert_equal([\"DX\", \"xyz\"], getline(1, 2))\n\n  bwipe!\n  set esckeys\nendfunc\n\n\" Test for running an invalid ex command in insert mode using CTRL-O\nfunc Test_edit_ctrl_o_invalid_cmd()\n  new\n  set showmode showcmd\n  \" Avoid a sleep of 3 seconds. Zero might have side effects.\n  call test_override('ui_delay', 50)\n  let caught_e492 = 0\n  try\n    call feedkeys(\"i\\<C-O>:invalid\\<CR>abc\\<Esc>\", \"xt\")\n  catch /E492:/\n    let caught_e492 = 1\n  endtry\n  call assert_equal(1, caught_e492)\n  call assert_equal('abc', getline(1))\n  set showmode& showcmd&\n  call test_override('ui_delay', 0)\n  close!\nendfunc\n\n\" Test for editing a file with a very long name\nfunc Test_edit_illegal_filename()\n  CheckEnglish\n  new\n  redir => msg\n  exe 'edit ' . repeat('f', 5000)\n  redir END\n  call assert_match(\"Illegal file name$\", split(msg, \"\\n\")[0])\n  close!\nendfunc\n\n\" Test for editing a directory\nfunc Test_edit_is_a_directory()\n  CheckEnglish\n  let dirname = getcwd() . \"/Xdir\"\n  call mkdir(dirname, 'p')\n\n  new\n  redir => msg\n  exe 'edit' dirname\n  redir END\n  call assert_match(\"is a directory$\", split(msg, \"\\n\")[0])\n  bwipe!\n\n  let dirname .= '/'\n\n  new\n  redir => msg\n  exe 'edit' dirname\n  redir END\n  call assert_match(\"is a directory$\", split(msg, \"\\n\")[0])\n  bwipe!\n\n  call delete(dirname, 'rf')\nendfunc\n\n\" Test for editing a file using invalid file encoding\nfunc Test_edit_invalid_encoding()\n  CheckEnglish\n  call writefile([], 'Xfile')\n  redir => msg\n  new ++enc=axbyc Xfile\n  redir END\n  call assert_match('\\[NOT converted\\]', msg)\n  call delete('Xfile')\n  close!\nendfunc\n\n\" Test for the \"charconvert\" option\nfunc Test_edit_charconvert()\n  CheckEnglish\n  call writefile(['one', 'two'], 'Xfile')\n\n  \" set 'charconvert' to a non-existing function\n  set charconvert=NonExitingFunc()\n  new\n  let caught_e117 = v:false\n  try\n    redir => msg\n    edit ++enc=axbyc Xfile\n  catch /E117:/\n    let caught_e117 = v:true\n  finally\n    redir END\n  endtry\n  call assert_true(caught_e117)\n  call assert_equal(['one', 'two'], getline(1, '$'))\n  call assert_match(\"Conversion with 'charconvert' failed\", msg)\n  close!\n  set charconvert&\n\n  \" 'charconvert' function doesn't create a output file\n  func Cconv1()\n  endfunc\n  set charconvert=Cconv1()\n  new\n  redir => msg\n  edit ++enc=axbyc Xfile\n  redir END\n  call assert_equal(['one', 'two'], getline(1, '$'))\n  call assert_match(\"can't read output of 'charconvert'\", msg)\n  close!\n  delfunc Cconv1\n  set charconvert&\n\n  \" 'charconvert' function to convert to upper case\n  func Cconv2()\n    let data = readfile(v:fname_in)\n    call map(data, 'toupper(v:val)')\n    call writefile(data, v:fname_out)\n  endfunc\n  set charconvert=Cconv2()\n  new Xfile\n  write ++enc=ucase Xfile1\n  call assert_equal(['ONE', 'TWO'], readfile('Xfile1'))\n  call delete('Xfile1')\n  close!\n  delfunc Cconv2\n  set charconvert&\n\n  \" 'charconvert' function removes the input file\n  func Cconv3()\n    call delete(v:fname_in)\n  endfunc\n  set charconvert=Cconv3()\n  new\n  call assert_fails('edit ++enc=lcase Xfile', 'E202:')\n  call assert_equal([''], getline(1, '$'))\n  close!\n  delfunc Cconv3\n  set charconvert&\n\n  call delete('Xfile')\nendfunc\n\n\" Test for editing a file without read permission\nfunc Test_edit_file_no_read_perm()\n  CheckUnix\n  CheckNotRoot\n\n  call writefile(['one', 'two'], 'Xfile')\n  call setfperm('Xfile', '-w-------')\n  new\n  redir => msg\n  edit Xfile\n  redir END\n  call assert_equal(1, &readonly)\n  call assert_equal([''], getline(1, '$'))\n  call assert_match('\\[Permission Denied\\]', msg)\n  close!\n  call delete('Xfile')\nendfunc\n\n\" Pressing escape in 'insertmode' should beep\nfunc Test_edit_insertmode_esc_beeps()\n  new\n  set insertmode\n  call assert_beeps(\"call feedkeys(\\\"one\\<Esc>\\\", 'xt')\")\n  set insertmode&\n  \" unsupported CTRL-G command should beep in insert mode.\n  call assert_beeps(\"normal i\\<C-G>l\")\n  close!\nendfunc\n\n\" Test for 'hkmap' and 'hkmapp'\nfunc Test_edit_hkmap()\n  CheckFeature rightleft\n  if has('win32') && !has('gui')\n    throw 'Skipped: fails on the MS-Windows terminal version'\n  endif\n  new\n\n  set revins hkmap\n  let str = 'abcdefghijklmnopqrstuvwxyz'\n  let str ..= 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  let str ..= '`/'',.;'\n  call feedkeys('i' .. str, 'xt')\n  let expected = \"\u00f3\u00f5\u00fa,.;\"\n  let expected ..= \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"\n  let expected ..= \"\u00e6\u00e8\u00f1'\u00e4\u00e5\u00e0\u00e3\u00f8/\u00f4\u00ed\u00ee\u00f6\u00ea\u00ec\u00e7\u00ef\u00e9\u00f2\u00eb\u00f7\u00e2\u00e1\u00f0\u00f9\"\n  call assert_equal(expected, getline(1))\n\n  %d\n  set revins hkmap hkmapp\n  let str = 'abcdefghijklmnopqrstuvwxyz'\n  let str ..= 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  call feedkeys('i' .. str, 'xt')\n  let expected = \"\u00f5YXWVUTSRQ\u00f3O\u00ef\u00edLKJIHGFED\u00eaBA\"\n  let expected ..= \"\u00f6\u00f2X\u00f9\u00e5\u00e8\u00fa\u00e6\u00f8'\u00f4\u00f1\u00f0\u00ee\u00ec\u00f7\u00e7\u00e9\u00e4\u00e2\u00f3\u01df\u00e3\u00eb\u00e1\u00e0\"\n  call assert_equal(expected, getline(1))\n\n  set revins& hkmap& hkmapp&\n  close!\nendfunc\n\n\" Test for 'allowrevins' and using CTRL-_ in insert mode\nfunc Test_edit_allowrevins()\n  CheckFeature rightleft\n  new\n  set allowrevins\n  call feedkeys(\"iABC\\<C-_>DEF\\<C-_>GHI\", 'xt')\n  call assert_equal('ABCFEDGHI', getline(1))\n  set allowrevins&\n  close!\nendfunc\n\n\" Test for inserting a register in insert mode using CTRL-R\nfunc Test_edit_insert_reg()\n  new\n  let g:Line = ''\n  func SaveFirstLine()\n    let g:Line = Screenline(1)\n    return 'r'\n  endfunc\n  inoremap <expr> <buffer> <F2> SaveFirstLine()\n  call test_override('redraw_flag', 1)\n  call test_override('char_avail', 1)\n  let @r = 'sample'\n  call feedkeys(\"a\\<C-R>=SaveFirstLine()\\<CR>\", \"xt\")\n  call assert_equal('\"', g:Line)\n  call test_override('ALL', 0)\n  close!\nendfunc\n\n\" When a character is inserted at the last position of the last line in a\n\" window, the window contents should be scrolled one line up. If the top line\n\" is part of a fold, then the entire fold should be scrolled up.\nfunc Test_edit_lastline_scroll()\n  new\n  let h = winheight(0)\n  let lines = ['one', 'two', 'three']\n  let lines += repeat(['vim'], h - 4)\n  call setline(1, lines)\n  call setline(h, repeat('x', winwidth(0) - 1))\n  call feedkeys(\"GAx\", 'xt')\n  redraw!\n  call assert_equal(h - 1, winline())\n  call assert_equal(2, line('w0'))\n\n  \" scroll with a fold\n  1,2fold\n  normal gg\n  call setline(h + 1, repeat('x', winwidth(0) - 1))\n  call feedkeys(\"GAx\", 'xt')\n  redraw!\n  call assert_equal(h - 1, winline())\n  call assert_equal(3, line('w0'))\n\n  close!\nendfunc\n\nfunc Test_edit_browse()\n  \" in the GUI this opens a file picker, we only test the terminal behavior\n  CheckNotGui\n\n  \" \":browse xxx\" checks for the FileExplorer augroup and assumes editing \".\"\n  \" works then.\n  augroup FileExplorer\n    au!\n  augroup END\n\n  \" When the USE_FNAME_CASE is defined this used to cause a crash.\n  browse enew\n  bwipe!\n\n  browse split\n  bwipe!\nendfunc\n\nfunc Test_read_invalid()\n  set encoding=latin1\n  \" This was not properly checking for going past the end.\n  call assert_fails('r`=', 'E484')\n  set encoding=utf-8\nendfunc\n\n\" Test for the 'revins' option\nfunc Test_edit_revins()\n  CheckFeature rightleft\n  new\n  set revins\n  exe \"normal! ione\\ttwo three\"\n  call assert_equal(\"eerht owt\\teno\", getline(1))\n  call setline(1, \"one\\ttwo three\")\n  normal! gg$bi a\n  call assert_equal(\"one\\ttwo a three\", getline(1))\n  exe \"normal! $bi\\<BS>\\<BS>\"\n  call assert_equal(\"one\\ttwo a ree\", getline(1))\n  exe \"normal! 0wi\\<C-W>\"\n  call assert_equal(\"one\\t a ree\", getline(1))\n  exe \"normal! 0wi\\<C-U>\"\n  call assert_equal(\"one\\t \", getline(1))\n  \" newline in insert mode starts at the end of the line\n  call setline(1, 'one two three')\n  exe \"normal! wi\\nfour\"\n  call assert_equal(['one two three', 'ruof'], getline(1, '$'))\n  set revins&\n  bw!\nendfunc\n\n\" Test for getting the character of the line below after \"p\"\nfunc Test_edit_put_CTRL_E()\n  set encoding=latin1\n  new\n  let @\" = ''\n  sil! norm or\u0003ggRx\n  sil! norm pr\u0005\n  call assert_equal(['r', 'r'], getline(1, 2))\n  bwipe!\n  set encoding=utf-8\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t\t  VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = (int)vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = (int)vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/normal.c", "src/testdir/test_edit.vim", "src/version.c"], "buggy_code_start_loc": [5102, 1897, 757], "buggy_code_end_loc": [5114, 1897, 757], "fixing_code_start_loc": [5102, 1898, 758], "fixing_code_end_loc": [5119, 1910, 760], "type": "CWE-416", "message": "vim is vulnerable to Use After Free", "other": {"cve": {"id": "CVE-2021-3796", "sourceIdentifier": "security@huntr.dev", "published": "2021-09-15T13:15:08.223", "lastModified": "2023-01-11T16:58:46.850", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "vim is vulnerable to Use After Free"}, {"lang": "es", "value": "vim es vulnerable a un Uso de memoria Previamente Liberada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.5}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.3, "impactScore": 5.3}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.3428", "matchCriteriaId": "B0FDE0CD-BAC8-46E2-9613-5B2E5AD3146D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:ontap_select_deploy_administration_utility:-:*:*:*:*:*:*:*", "matchCriteriaId": "E7CF3019-975D-40BB-A8A4-894E62BD3797"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2021/10/01/1", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/35a9a00afcb20897d462a766793ff45534810dc3", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/ab60b7f3-6fb1-4ac2-a4fa-4d592e08008d", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/01/msg00003.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/7K4JJBIH3OQSZRVTWKCJCDLGMFGQ5DOH/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/S42L4Z4DTW4LHLQ4FJ33VEOXRCBE7WN4/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TE62UMYBZE4AE53K6OBBWK32XQ7544QM/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20221118-0004/", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/35a9a00afcb20897d462a766793ff45534810dc3"}}