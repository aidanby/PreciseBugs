{"buggy_code": ["/**\n * Copyright (c) 2021 Alban Fichet <alban dot fichet at gmx dot fr>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *  * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following\n * disclaimer in the documentation and/or other materials provided\n * with the distribution.\n *  * Neither the name of the organization(s) nor the names of its\n * contributors may be used to endorse or promote products derived\n * from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"FramebufferModel.h\"\n\n#include <array>\n#include <cmath>\n#include <cstddef>\n#include <fstream>\n\nFramebufferModel::FramebufferModel(QObject* parent)\n  : QObject(parent)\n  , m_pixelBuffer(nullptr)\n  , m_width(0)\n  , m_height(0)\n  , m_isImageLoaded(false)\n  , m_exposure(0)\n  , m_imageLoadingWatcher(new QFutureWatcher<void>(this))\n  , m_imageEditingWatcher(new QFutureWatcher<void>(this))\n  , m_pixelAspectRatio(1.f)\n{}\n\nQRect FramebufferModel::getDisplayWindow() const\n{\n    return m_displayWindow;\n}\n\nQRect FramebufferModel::getDataWindow() const\n{\n    return m_dataWindow;\n}\n\nFramebufferModel::~FramebufferModel()\n{\n    delete[] m_pixelBuffer;\n}\n", "/**\n * Copyright (c) 2021 Alban Fichet <alban dot fichet at gmx dot fr>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *  * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following\n * disclaimer in the documentation and/or other materials provided\n * with the distribution.\n *  * Neither the name of the organization(s) nor the names of its\n * contributors may be used to endorse or promote products derived\n * from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#pragma once\n\n#include <QFutureWatcher>\n#include <QImage>\n#include <QObject>\n#include <QRect>\n#include <QVector>\n#include <array>\n\nclass FramebufferModel: public QObject\n{\n    Q_OBJECT\n\n  public:\n    FramebufferModel(QObject* parent = nullptr);\n    virtual ~FramebufferModel();\n\n    const QImage& getLoadedImage() const { return m_image; }\n\n    bool isImageLoaded() const { return m_isImageLoaded; }\n\n    int   width() const { return m_width; }\n    int   height() const { return m_height; }\n    float pixelAspectRatio() const { return m_pixelAspectRatio; }\n\n    QRect getDisplayWindow() const;\n    QRect getDataWindow() const;\n\n    virtual std::string getColorInfo(int x, int y) const = 0;\n\n  signals:\n    void imageChanged();\n    void imageLoaded();\n    void exposureChanged(double exposure);\n    void loadFailed(QString message);\n\n  protected:\n    float* m_pixelBuffer;\n    QImage m_image;\n\n    // Right now, the width and height are defined as Vec2i in OpenEXR\n    // i.e. int type.\n    int m_width, m_height;\n\n    bool m_isImageLoaded;\n\n    double m_exposure;\n\n    QFutureWatcher<void>* m_imageLoadingWatcher;\n    QFutureWatcher<void>* m_imageEditingWatcher;\n\n    QRect m_dataWindow;\n    QRect m_displayWindow;\n    float m_pixelAspectRatio;\n};\n", "/**\n * Copyright (c) 2021 Alban Fichet <alban dot fichet at gmx dot fr>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *  * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following\n * disclaimer in the documentation and/or other materials provided\n * with the distribution.\n *  * Neither the name of the organization(s) nor the names of its\n * contributors may be used to endorse or promote products derived\n * from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"RGBFramebufferModel.h\"\n\n#include <util/ColorTransform.h>\n\n#include <QFuture>\n#include <QtConcurrent/QtConcurrent>\n\n#include <OpenEXR/ImfChromaticitiesAttribute.h>\n#include <OpenEXR/ImfFrameBuffer.h>\n#include <OpenEXR/ImfHeader.h>\n#include <OpenEXR/ImfInputPart.h>\n#include <OpenEXR/ImfRgbaYca.h>\n\n#include <Imath/ImathBox.h>\n\nRGBFramebufferModel::RGBFramebufferModel(\n  const std::string& parentLayerName, LayerType layerType, QObject* parent)\n  : FramebufferModel(parent)\n  , m_parentLayer(parentLayerName)\n  , m_layerType(layerType)\n  , m_exposure(0.)\n{}\n\nRGBFramebufferModel::~RGBFramebufferModel() {}\n\nvoid RGBFramebufferModel::load(\n  Imf::MultiPartInputFile& file, int partId, bool hasAlpha)\n{\n    QFuture<void> imageLoading = QtConcurrent::run([this,\n                                                    &file,\n                                                    partId,\n                                                    hasAlpha]() {\n        try {\n            Imf::InputPart part(file, partId);\n\n            Imath::Box2i datW = part.header().dataWindow();\n            m_width           = datW.max.x - datW.min.x + 1;\n            m_height          = datW.max.y - datW.min.y + 1;\n\n            m_pixelAspectRatio = part.header().pixelAspectRatio();\n\n            m_dataWindow = QRect(datW.min.x, datW.min.y, m_width, m_height);\n\n            Imath::Box2i dispW = part.header().displayWindow();\n\n            int dispW_width  = dispW.max.x - dispW.min.x + 1;\n            int dispW_height = dispW.max.y - dispW.min.y + 1;\n\n            m_displayWindow\n              = QRect(dispW.min.x, dispW.min.y, dispW_width, dispW_height);\n\n            // Check if there is specific chromaticities tied to the color\n            // representation in this part.\n            const Imf::ChromaticitiesAttribute* c\n              = part.header().findTypedAttribute<Imf::ChromaticitiesAttribute>(\n                \"chromaticities\");\n\n            Imf::Chromaticities chromaticities;\n\n            if (c != nullptr) {\n                chromaticities = c->value();\n            }\n\n            m_pixelBuffer = new float[4 * m_width * m_height];\n\n            // Check if there is alpha channel\n            if (hasAlpha) {\n                std::string      aLayer = m_parentLayer + \"A\";\n                Imf::FrameBuffer framebuffer;\n\n                Imf::Slice aSlice = Imf::Slice::Make(\n                  Imf::PixelType::FLOAT,\n                  &m_pixelBuffer[3],\n                  datW,\n                  4 * sizeof(float),\n                  4 * m_width * sizeof(float));\n\n                framebuffer.insert(aLayer, aSlice);\n\n                part.setFrameBuffer(framebuffer);\n                part.readPixels(datW.min.y, datW.max.y);\n\n            } else {\n                for (int y = 0; y < m_height; y++) {\n                    for (int x = 0; x < m_width; x++) {\n                        m_pixelBuffer[4 * (y * m_width + x) + 3] = 1.f;\n                    }\n                }\n            }\n\n            switch (m_layerType) {\n                case Layer_RGB: {\n                    std::string rLayer = m_parentLayer + \"R\";\n                    std::string gLayer = m_parentLayer + \"G\";\n                    std::string bLayer = m_parentLayer + \"B\";\n\n                    Imf::FrameBuffer framebuffer;\n\n                    Imf::Slice rSlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &m_pixelBuffer[0],\n                      datW,\n                      4 * sizeof(float),\n                      4 * m_width * sizeof(float));\n\n                    Imf::Slice gSlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &m_pixelBuffer[1],\n                      datW,\n                      4 * sizeof(float),\n                      4 * m_width * sizeof(float));\n\n                    Imf::Slice bSlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &m_pixelBuffer[2],\n                      datW,\n                      4 * sizeof(float),\n                      4 * m_width * sizeof(float));\n\n                    framebuffer.insert(rLayer, rSlice);\n                    framebuffer.insert(gLayer, gSlice);\n                    framebuffer.insert(bLayer, bSlice);\n\n                    part.setFrameBuffer(framebuffer);\n                    part.readPixels(datW.min.y, datW.max.y);\n\n                    // Handle custom chromaticities\n                    Imath::M44f RGB_XYZ = Imf::RGBtoXYZ(chromaticities, 1.f);\n                    Imath::M44f XYZ_RGB\n                      = Imf::XYZtoRGB(Imf::Chromaticities(), 1.f);\n\n                    Imath::M44f conversionMatrix = RGB_XYZ * XYZ_RGB;\n\n                    #pragma omp parallel for\n                    for (int y = 0; y < m_height; y++) {\n                        for (int x = 0; x < m_width; x++) {\n                            const float r\n                              = m_pixelBuffer[4 * (y * m_width + x) + 0];\n                            const float g\n                              = m_pixelBuffer[4 * (y * m_width + x) + 1];\n                            const float b\n                              = m_pixelBuffer[4 * (y * m_width + x) + 2];\n\n                            Imath::V3f rgb(r, g, b);\n                            rgb *= conversionMatrix;\n\n                            m_pixelBuffer[4 * (y * m_width + x) + 0] = rgb.x;\n                            m_pixelBuffer[4 * (y * m_width + x) + 1] = rgb.y;\n                            m_pixelBuffer[4 * (y * m_width + x) + 2] = rgb.z;\n                        }\n                    }\n                } break;\n\n                case Layer_YC: {\n                    std::string yLayer  = m_parentLayer + \"Y\";\n                    std::string ryLayer = m_parentLayer + \"RY\";\n                    std::string byLayer = m_parentLayer + \"BY\";\n\n                    Imf::FrameBuffer framebuffer;\n\n                    Imf::Rgba* buff1 = new Imf::Rgba[m_width * m_height];\n                    Imf::Rgba* buff2 = new Imf::Rgba[m_width * m_height];\n\n                    float* yBuffer  = new float[m_width * m_height];\n                    float* ryBuffer = new float[m_width / 2 * m_height / 2];\n                    float* byBuffer = new float[m_width / 2 * m_height / 2];\n\n                    Imf::Slice ySlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &yBuffer[0],\n                      datW,\n                      sizeof(float),\n                      m_width * sizeof(float));\n\n                    Imf::Slice rySlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &ryBuffer[0],\n                      datW,\n                      sizeof(float),\n                      m_width / 2 * sizeof(float),\n                      2,\n                      2);\n\n                    Imf::Slice bySlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &byBuffer[0],\n                      datW,\n                      sizeof(float),\n                      m_width / 2 * sizeof(float),\n                      2,\n                      2);\n\n                    framebuffer.insert(yLayer, ySlice);\n                    framebuffer.insert(ryLayer, rySlice);\n                    framebuffer.insert(byLayer, bySlice);\n\n                    part.setFrameBuffer(framebuffer);\n                    part.readPixels(datW.min.y, datW.max.y);\n\n                    // Filling missing values for chroma in the image\n                    // TODO: now, naive reconstruction.\n                    // Use later Imf::RgbaYca::reconstructChromaHoriz and\n                    // Imf::RgbaYca::reconstructChromaVert to reconstruct missing\n                    // pixels\n                    #pragma omp parallel for\n                    for (int y = 0; y < m_height; y++) {\n                        for (int x = 0; x < m_width; x++) {\n                            const float l = yBuffer[y * m_width + x];\n\n                            /*\n                            float ry = 0, by = 0;\n\n                            if (y % 2 == 0) {\n                                if (x % 2 == 0) {\n                                    ry = ryBuffer[y / 2 * m_width / 2 + x / 2];\n                                    by = byBuffer[y / 2 * m_width / 2 + x / 2];\n                                } else {\n                                    ry = .5 * (ryBuffer[y / 2 * m_width / 2 + x / 2] + ryBuffer[y / 2 * m_width / 2 + x / 2 + 1]);\n                                    by = .5 * (byBuffer[y / 2 * m_width / 2 + x / 2] + byBuffer[y / 2 * m_width / 2 + x / 2 + 1]);\n                                }\n                            } else {\n                                if (x % 2 == 0) {\n                                    ry = .5 * (ryBuffer[y / 2 * m_width / 2 + x / 2] + ryBuffer[(y / 2 + 1) * m_width / 2 + x / 2]);\n                                    by = .5 * (byBuffer[y / 2 * m_width / 2 + x / 2] + byBuffer[(y / 2 + 1) * m_width / 2 + x / 2]);\n                                } else {\n                                    ry = .25 * (ryBuffer[y / 2 * m_width / 2 + x / 2] + ryBuffer[(y / 2 + 1) * m_width / 2 + x / 2] + ryBuffer[y / 2 * m_width / 2 + x / 2 + 1] + ryBuffer[(y / 2 + 1) * m_width / 2 + x / 2 + 1]);\n                                    by = .25 * (byBuffer[y / 2 * m_width / 2 + x / 2] + byBuffer[(y / 2 + 1) * m_width / 2 + x / 2] + byBuffer[y / 2 * m_width / 2 + x / 2 + 1] + byBuffer[(y / 2 + 1) * m_width / 2 + x / 2 + 1]);\n                                }\n                            }\n                            */\n\n                            const float ry\n                              = ryBuffer[y / 2 * m_width / 2 + x / 2];\n                            const float by\n                              = byBuffer[y / 2 * m_width / 2 + x / 2];\n\n                            buff1[y * m_width + x].r = ry;\n                            buff1[y * m_width + x].g = l;\n                            buff1[y * m_width + x].b = by;\n                            // Do not forget the alpha values read earlier\n                            buff1[y * m_width + x].a\n                              = m_pixelBuffer[4 * (y * m_width + x) + 3];\n                        }\n                    }\n\n                    Imath::V3f yw = Imf::RgbaYca::computeYw(chromaticities);\n\n                    // Proceed to the YCA -> RGBA conversion\n                    #pragma omp parallel for\n                    for (int y = 0; y < m_height; y++) {\n                        Imf::RgbaYca::YCAtoRGBA(\n                          yw,\n                          m_width,\n                          &buff1[y * m_width],\n                          &buff1[y * m_width]);\n                    }\n\n                    // Fix over saturated pixels\n                    #pragma omp parallel for\n                    for (int y = 0; y < m_height; y++) {\n                        const Imf::Rgba* scanlines[3];\n\n                        if (y == 0) {\n                            scanlines[0] = &buff1[(y + 1) * m_width];\n                        } else {\n                            scanlines[0] = &buff1[(y - 1) * m_width];\n                        }\n\n                        scanlines[1] = &buff1[y * m_width];\n\n                        if (y == m_height - 1) {\n                            scanlines[2] = &buff1[(y - 1) * m_width];\n                        } else {\n                            scanlines[2] = &buff1[(y + 1) * m_width];\n                        }\n\n                        Imf::RgbaYca::fixSaturation(\n                          yw,\n                          m_width,\n                          scanlines,\n                          &buff2[y * m_width]);\n                    }\n\n                    // Handle custom chromaticities\n                    Imath::M44f RGB_XYZ = Imf::RGBtoXYZ(chromaticities, 1.f);\n                    Imath::M44f XYZ_RGB\n                      = Imf::XYZtoRGB(Imf::Chromaticities(), 1.f);\n\n                    Imath::M44f conversionMatrix = RGB_XYZ * XYZ_RGB;\n\n                    #pragma omp parallel for\n                    for (int y = 0; y < m_height; y++) {\n                        for (int x = 0; x < m_width; x++) {\n                            Imath::V3f rgb(\n                              buff2[y * m_width + x].r,\n                              buff2[y * m_width + x].g,\n                              buff2[y * m_width + x].b);\n\n                            rgb = rgb * conversionMatrix;\n\n                            m_pixelBuffer[4 * (y * m_width + x) + 0] = rgb.x;\n                            m_pixelBuffer[4 * (y * m_width + x) + 1] = rgb.y;\n                            m_pixelBuffer[4 * (y * m_width + x) + 2] = rgb.z;\n                        }\n                    }\n\n                    delete[] yBuffer;\n                    delete[] ryBuffer;\n                    delete[] byBuffer;\n                    delete[] buff1;\n                    delete[] buff2;\n                }\n\n                break;\n\n                case Layer_Y: {\n                    std::string yLayer = m_parentLayer;\n\n                    Imf::FrameBuffer framebuffer;\n\n                    Imf::Slice ySlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &m_pixelBuffer[0],\n                      datW,\n                      4 * sizeof(float),\n                      4 * m_width * sizeof(float));\n\n                    framebuffer.insert(yLayer, ySlice);\n\n                    part.setFrameBuffer(framebuffer);\n                    part.readPixels(datW.min.y, datW.max.y);\n\n                    #pragma omp parallel for\n                    for (int i = 0; i < m_height * m_width; i++) {\n                        m_pixelBuffer[4 * i + 1] = m_pixelBuffer[4 * i + 0];\n                        m_pixelBuffer[4 * i + 2] = m_pixelBuffer[4 * i + 0];\n                        m_pixelBuffer[4 * i + 3] = 1.f;\n                    }\n                } break;\n            }\n\n            m_image = QImage(m_width, m_height, QImage::Format_RGBA8888);\n            m_isImageLoaded = true;\n\n            emit imageLoaded();\n\n            updateImage();\n        } catch (std::exception& e) {\n            emit loadFailed(e.what());\n            return;\n        }\n    });\n\n    m_imageLoadingWatcher->setFuture(imageLoading);\n}\n\nstd::string RGBFramebufferModel::getColorInfo(int x, int y) const\n{\n    if (x < 0 || x >= width() || y < 0 || y >= height()) {\n        return \"\";\n    }\n\n    std::stringstream ss;\n    ss << \"x: \" << x << \" y: \" << y << \" | \"\n       << \" R: \" << m_pixelBuffer[4 * (y * width() + x) + 0]\n       << \" G: \" << m_pixelBuffer[4 * (y * width() + x) + 1]\n       << \" B: \" << m_pixelBuffer[4 * (y * width() + x) + 2]\n       << \" A: \" << m_pixelBuffer[4 * (y * width() + x) + 3];\n\n    return ss.str();\n}\n\n\nfloat RGBFramebufferModel::getRedInfo(int x, int y) const\n{\n    if (x < 0 || x >= width() || y < 0 || y >= height()) {\n        return 0;\n    }\n\n    return m_pixelBuffer[4 * (y * width() + x) + 0];\n}\n\n\nfloat RGBFramebufferModel::getGreenInfo(int x, int y) const\n{\n    if (x < 0 || x >= width() || y < 0 || y >= height()) {\n        return 0;\n    }\n\n    return m_pixelBuffer[4 * (y * width() + x) + 1];\n}\n\n\nfloat RGBFramebufferModel::getBlueInfo(int x, int y) const\n{\n    if (x < 0 || x >= width() || y < 0 || y >= height()) {\n        return 0;\n    }\n\n    return m_pixelBuffer[4 * (y * width() + x) + 2];\n}\n\nfloat RGBFramebufferModel::getAlphaInfo(int x, int y) const\n{\n    if (x < 0 || x >= width() || y < 0 || y >= height()) {\n        return 0;\n    }\n\n    return m_pixelBuffer[4 * (y * width() + x) + 3];\n}\n\n\nvoid RGBFramebufferModel::setExposure(double value)\n{\n    if (m_exposure == value) return;\n\n    m_exposure = value;\n    updateImage();\n}\n\nvoid RGBFramebufferModel::updateImage()\n{\n    if (!m_isImageLoaded) {\n        return;\n    }\n\n    // Several call can occur within a short time e.g., when changing exposure\n    // Ensure to cancel any previous running conversion and wait for the\n    // process to end\n    if (m_imageEditingWatcher->isRunning()) {\n        m_imageEditingWatcher->cancel();\n        m_imageEditingWatcher->waitForFinished();\n    }\n\n    float m_exposure_mul = std::exp2(m_exposure);\n\n    QFuture<void> imageConverting = QtConcurrent::run([=]() {\n        for (int y = 0; y < m_image.height(); y++) {\n            unsigned char* line = m_image.scanLine(y);\n\n            #pragma omp parallel for\n            for (int x = 0; x < m_image.width(); x++) {\n                const float r = ColorTransform::to_sRGB(\n                  m_exposure_mul * m_pixelBuffer[4 * (y * m_width + x) + 0]);\n                const float g = ColorTransform::to_sRGB(\n                  m_exposure_mul * m_pixelBuffer[4 * (y * m_width + x) + 1]);\n                const float b = ColorTransform::to_sRGB(\n                  m_exposure_mul * m_pixelBuffer[4 * (y * m_width + x) + 2]);\n\n                const float a = m_pixelBuffer[4 * (y * m_width + x) + 3];\n\n                line[4 * x + 0] = qMax(0, qMin(255, int(255.f * r)));\n                line[4 * x + 1] = qMax(0, qMin(255, int(255.f * g)));\n                line[4 * x + 2] = qMax(0, qMin(255, int(255.f * b)));\n                line[4 * x + 3] = qMax(0, qMin(255, int(255.f * a)));\n            }\n\n            if (m_imageEditingWatcher->isCanceled()) {\n                break;\n            }\n        }\n\n        // We do not notify any canceled process: this would result in\n        // potentially corrupted conversion\n        if (!m_imageEditingWatcher->isCanceled()) {\n            emit imageChanged();\n        }\n    });\n\n    m_imageEditingWatcher->setFuture(imageConverting);\n}\n", "/**\n * Copyright (c) 2021 Alban Fichet <alban dot fichet at gmx dot fr>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *  * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following\n * disclaimer in the documentation and/or other materials provided\n * with the distribution.\n *  * Neither the name of the organization(s) nor the names of its\n * contributors may be used to endorse or promote products derived\n * from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"YFramebufferModel.h\"\n\n#include <util/ColormapModule.h>\n\n#include <QFuture>\n#include <QtConcurrent/QtConcurrent>\n\n#include <OpenEXR/ImfAttribute.h>\n#include <OpenEXR/ImfFrameBuffer.h>\n#include <OpenEXR/ImfHeader.h>\n#include <OpenEXR/ImfInputPart.h>\n\n#include <Imath/ImathBox.h>\n\nYFramebufferModel::YFramebufferModel(\n  const std::string& layerName, QObject* parent)\n  : FramebufferModel(parent)\n  , m_layer(layerName)\n  , m_min(0.f)\n  , m_max(1.f)\n  , m_cmap(ColormapModule::create(\"grayscale\"))\n{}\n\nYFramebufferModel::~YFramebufferModel()\n{\n    delete m_cmap;\n}\n\nvoid YFramebufferModel::load(Imf::MultiPartInputFile& file, int partId)\n{\n    QFuture<void> imageLoading = QtConcurrent::run([this, &file, partId]() {\n        try {\n            Imf::InputPart part(file, partId);\n\n            Imath::Box2i datW = part.header().dataWindow();\n            m_width           = datW.max.x - datW.min.x + 1;\n            m_height          = datW.max.y - datW.min.y + 1;\n\n            m_pixelAspectRatio = part.header().pixelAspectRatio();\n\n            Imf::Slice graySlice;\n            // TODO: Check it that can be guess from the header\n            // also, check if this can be nested\n            if (m_layer == \"BY\" || m_layer == \"RY\") {\n                m_width /= 2;\n                m_height /= 2;\n\n                m_dataWindow = QRect(datW.min.x, datW.min.y, m_width, m_height);\n\n                Imath::Box2i dispW = part.header().displayWindow();\n\n                int dispW_width  = dispW.max.x - dispW.min.x + 1;\n                int dispW_height = dispW.max.y - dispW.min.y + 1;\n\n                m_displayWindow = QRect(\n                  dispW.min.x,\n                  dispW.min.y,\n                  dispW_width / 2,\n                  dispW_height / 2);\n\n                m_pixelBuffer = new float[m_width * m_height];\n\n                // Luminance Chroma channels\n                graySlice = Imf::Slice::Make(\n                  Imf::PixelType::FLOAT,\n                  m_pixelBuffer,\n                  datW,\n                  sizeof(float),\n                  m_width * sizeof(float),\n                  2,\n                  2);\n            } else {\n                m_dataWindow = QRect(datW.min.x, datW.min.y, m_width, m_height);\n\n                Imath::Box2i dispW = part.header().displayWindow();\n\n                int dispW_width  = dispW.max.x - dispW.min.x + 1;\n                int dispW_height = dispW.max.y - dispW.min.y + 1;\n\n                m_displayWindow\n                  = QRect(dispW.min.x, dispW.min.y, dispW_width, dispW_height);\n\n                m_pixelBuffer = new float[m_width * m_height];\n\n                graySlice = Imf::Slice::Make(\n                  Imf::PixelType::FLOAT,\n                  m_pixelBuffer,\n                  datW);\n            }\n\n            Imf::FrameBuffer framebuffer;\n\n            framebuffer.insert(m_layer, graySlice);\n\n            part.setFrameBuffer(framebuffer);\n            part.readPixels(datW.min.y, datW.max.y);\n\n            // Determine min and max of the dataset\n            m_datasetMin = std::numeric_limits<double>::infinity();\n            m_datasetMax = -std::numeric_limits<double>::infinity();\n\n            for (int i = 0; i < m_width * m_height; i++) {\n                m_datasetMin = std::min(m_datasetMin, (double)m_pixelBuffer[i]);\n                m_datasetMax = std::max(m_datasetMax, (double)m_pixelBuffer[i]);\n            }\n\n            m_image         = QImage(m_width, m_height, QImage::Format_RGB888);\n            m_isImageLoaded = true;\n\n            emit imageLoaded();\n\n            updateImage();\n        } catch (std::exception& e) {\n            emit loadFailed(e.what());\n            return;\n        }\n    });\n\n    m_imageLoadingWatcher->setFuture(imageLoading);\n}\n\nstd::string YFramebufferModel::getColorInfo(int x, int y) const\n{\n    if (x < 0 || x >= width() || y < 0 || y >= height()) {\n        return \"\";\n    }\n\n    std::stringstream ss;\n    ss << \"x: \" << x << \" y: \" << y << \" | \"\n       << \"value = \" << m_pixelBuffer[y * width() + x];\n\n    return ss.str();\n}\n\nvoid YFramebufferModel::setMinValue(double value)\n{\n    m_min = value;\n    updateImage();\n}\n\nvoid YFramebufferModel::setMaxValue(double value)\n{\n    m_max = value;\n    updateImage();\n}\n\nvoid YFramebufferModel::setColormap(ColormapModule::Map map)\n{\n    if (!m_isImageLoaded) {\n        return;\n    }\n\n    // Several calls can occur within a short time e.g., when changing exposure\n    // Ensure to cancel any previous running conversion and wait for the\n    // process to end\n    // Also, bad idea to change the colormap if a process is using it\n    if (m_imageEditingWatcher->isRunning()) {\n        m_imageEditingWatcher->cancel();\n        m_imageEditingWatcher->waitForFinished();\n    }\n\n    if (m_cmap) {\n        delete m_cmap;\n        m_cmap = nullptr;\n    }\n\n    m_cmap = ColormapModule::create(map);\n\n    updateImage();\n}\n\nvoid YFramebufferModel::updateImage()\n{\n    if (!m_isImageLoaded) {\n        return;\n    }\n\n    // Several calls can occur within a short time e.g., when changing exposure\n    // Ensure to cancel any previous running conversion and wait for the\n    // process to end\n    if (m_imageEditingWatcher->isRunning()) {\n        m_imageEditingWatcher->cancel();\n        m_imageEditingWatcher->waitForFinished();\n    }\n\n    QFuture<void> imageConverting = QtConcurrent::run([=]() {\n        for (int y = 0; y < m_image.height(); y++) {\n            unsigned char* line = m_image.scanLine(y);\n\n            #pragma omp parallel for\n            for (int x = 0; x < m_image.width(); x++) {\n                float value = m_pixelBuffer[y * m_width + x];\n                float RGB[3];\n\n                m_cmap->getRGBValue(value, m_min, m_max, RGB);\n\n                for (int c = 0; c < 3; c++) {\n                    line[3 * x + c] = qMax(0, qMin(255, int(255 * RGB[c])));\n                }\n            }\n\n            if (m_imageEditingWatcher->isCanceled()) {\n                break;\n            }\n        }\n\n        // We do not notify any canceled process: this would result in\n        // potentially corrupted conversion\n        if (!m_imageEditingWatcher->isCanceled()) {\n            emit imageChanged();\n        }\n    });\n\n    m_imageEditingWatcher->setFuture(imageConverting);\n}\n"], "fixing_code": ["/**\n * Copyright (c) 2021 Alban Fichet <alban dot fichet at gmx dot fr>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *  * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following\n * disclaimer in the documentation and/or other materials provided\n * with the distribution.\n *  * Neither the name of the organization(s) nor the names of its\n * contributors may be used to endorse or promote products derived\n * from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"FramebufferModel.h\"\n\n#include <array>\n#include <cmath>\n#include <cstddef>\n#include <fstream>\n\nFramebufferModel::FramebufferModel(QObject* parent)\n  : QObject(parent)\n  , m_width(0)\n  , m_height(0)\n  , m_isImageLoaded(false)\n  , m_exposure(0)\n  , m_imageLoadingWatcher(new QFutureWatcher<void>(this))\n  , m_imageEditingWatcher(new QFutureWatcher<void>(this))\n  , m_pixelAspectRatio(1.f)\n{}\n\nQRect FramebufferModel::getDisplayWindow() const\n{\n    return m_displayWindow;\n}\n\nQRect FramebufferModel::getDataWindow() const\n{\n    return m_dataWindow;\n}\n\nFramebufferModel::~FramebufferModel() {}\n", "/**\n * Copyright (c) 2021 Alban Fichet <alban dot fichet at gmx dot fr>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *  * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following\n * disclaimer in the documentation and/or other materials provided\n * with the distribution.\n *  * Neither the name of the organization(s) nor the names of its\n * contributors may be used to endorse or promote products derived\n * from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#pragma once\n\n#include <QFutureWatcher>\n#include <QImage>\n#include <QObject>\n#include <QRect>\n#include <QVector>\n#include <vector>\n\nclass FramebufferModel: public QObject\n{\n    Q_OBJECT\n\n  public:\n    FramebufferModel(QObject* parent = nullptr);\n    virtual ~FramebufferModel();\n\n    const QImage& getLoadedImage() const { return m_image; }\n\n    bool isImageLoaded() const { return m_isImageLoaded; }\n\n    int   width() const { return m_width; }\n    int   height() const { return m_height; }\n    float pixelAspectRatio() const { return m_pixelAspectRatio; }\n\n    QRect getDisplayWindow() const;\n    QRect getDataWindow() const;\n\n    virtual std::string getColorInfo(int x, int y) const = 0;\n\n  signals:\n    void imageChanged();\n    void imageLoaded();\n    void exposureChanged(double exposure);\n    void loadFailed(QString message);\n\n  protected:\n    std::vector<float> m_pixelBuffer;\n    QImage             m_image;\n\n    // Right now, the width and height are defined as Vec2i in OpenEXR\n    // i.e. int type.\n    int m_width, m_height;\n\n    bool m_isImageLoaded;\n\n    double m_exposure;\n\n    QFutureWatcher<void>* m_imageLoadingWatcher;\n    QFutureWatcher<void>* m_imageEditingWatcher;\n\n    QRect m_dataWindow;\n    QRect m_displayWindow;\n    float m_pixelAspectRatio;\n};\n", "/**\n * Copyright (c) 2021 Alban Fichet <alban dot fichet at gmx dot fr>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *  * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following\n * disclaimer in the documentation and/or other materials provided\n * with the distribution.\n *  * Neither the name of the organization(s) nor the names of its\n * contributors may be used to endorse or promote products derived\n * from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"RGBFramebufferModel.h\"\n\n#include <util/ColorTransform.h>\n\n#include <QFuture>\n#include <QtConcurrent/QtConcurrent>\n\n#include <OpenEXR/ImfChromaticitiesAttribute.h>\n#include <OpenEXR/ImfFrameBuffer.h>\n#include <OpenEXR/ImfHeader.h>\n#include <OpenEXR/ImfInputPart.h>\n#include <OpenEXR/ImfRgbaYca.h>\n\n#include <Imath/ImathBox.h>\n\nRGBFramebufferModel::RGBFramebufferModel(\n  const std::string& parentLayerName, LayerType layerType, QObject* parent)\n  : FramebufferModel(parent)\n  , m_parentLayer(parentLayerName)\n  , m_layerType(layerType)\n  , m_exposure(0.)\n{}\n\nRGBFramebufferModel::~RGBFramebufferModel() {}\n\nvoid RGBFramebufferModel::load(\n  Imf::MultiPartInputFile& file, int partId, bool hasAlpha)\n{\n    QFuture<void> imageLoading = QtConcurrent::run([this,\n                                                    &file,\n                                                    partId,\n                                                    hasAlpha]() {\n        try {\n            Imf::InputPart part(file, partId);\n\n            Imath::Box2i datW = part.header().dataWindow();\n            m_width           = datW.max.x - datW.min.x + 1;\n            m_height          = datW.max.y - datW.min.y + 1;\n\n            m_pixelAspectRatio = part.header().pixelAspectRatio();\n\n            m_dataWindow = QRect(datW.min.x, datW.min.y, m_width, m_height);\n\n            Imath::Box2i dispW = part.header().displayWindow();\n\n            int dispW_width  = dispW.max.x - dispW.min.x + 1;\n            int dispW_height = dispW.max.y - dispW.min.y + 1;\n\n            m_displayWindow\n              = QRect(dispW.min.x, dispW.min.y, dispW_width, dispW_height);\n\n            // Check to avoid type overflow, width and height are 32bits int\n            // representing a 2 dimentional image. Can overflow the type when\n            // multiplied together.\n            // 0x1FFFFFFF is a save limit for 4 * 0x7FFFFFFF the max\n            // representable int since we need 4 channels.\n            // TODO: Use larger type when manipulating framebuffer\n            const uint64_t partial_size\n              = (uint64_t)m_width * (uint64_t)m_height;\n\n            if (partial_size > 0x1FFFFFFF) {\n                throw std::runtime_error(\n                  \"The total image size is too large. May be supported in a \"\n                  \"future revision.\");\n            }\n\n            m_pixelBuffer.resize(4 * m_width * m_height);\n\n            // Check if there is specific chromaticities tied to the color\n            // representation in this part.\n            const Imf::ChromaticitiesAttribute* c\n              = part.header().findTypedAttribute<Imf::ChromaticitiesAttribute>(\n                \"chromaticities\");\n\n            Imf::Chromaticities chromaticities;\n\n            if (c != nullptr) {\n                chromaticities = c->value();\n            }\n\n            // Check if there is alpha channel\n            if (hasAlpha) {\n                std::string      aLayer = m_parentLayer + \"A\";\n                Imf::FrameBuffer framebuffer;\n\n                Imf::Slice aSlice = Imf::Slice::Make(\n                  Imf::PixelType::FLOAT,\n                  &m_pixelBuffer[3],\n                  datW,\n                  4 * sizeof(float),\n                  4 * m_width * sizeof(float));\n\n                framebuffer.insert(aLayer, aSlice);\n\n                part.setFrameBuffer(framebuffer);\n                part.readPixels(datW.min.y, datW.max.y);\n\n            } else {\n                for (int y = 0; y < m_height; y++) {\n                    for (int x = 0; x < m_width; x++) {\n                        m_pixelBuffer[4 * (y * m_width + x) + 3] = 1.f;\n                    }\n                }\n            }\n\n            switch (m_layerType) {\n                case Layer_RGB: {\n                    std::string rLayer = m_parentLayer + \"R\";\n                    std::string gLayer = m_parentLayer + \"G\";\n                    std::string bLayer = m_parentLayer + \"B\";\n\n                    Imf::FrameBuffer framebuffer;\n\n                    Imf::Slice rSlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &m_pixelBuffer[0],\n                      datW,\n                      4 * sizeof(float),\n                      4 * m_width * sizeof(float));\n\n                    Imf::Slice gSlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &m_pixelBuffer[1],\n                      datW,\n                      4 * sizeof(float),\n                      4 * m_width * sizeof(float));\n\n                    Imf::Slice bSlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &m_pixelBuffer[2],\n                      datW,\n                      4 * sizeof(float),\n                      4 * m_width * sizeof(float));\n\n                    framebuffer.insert(rLayer, rSlice);\n                    framebuffer.insert(gLayer, gSlice);\n                    framebuffer.insert(bLayer, bSlice);\n\n                    part.setFrameBuffer(framebuffer);\n                    part.readPixels(datW.min.y, datW.max.y);\n\n                    // Handle custom chromaticities\n                    Imath::M44f RGB_XYZ = Imf::RGBtoXYZ(chromaticities, 1.f);\n                    Imath::M44f XYZ_RGB\n                      = Imf::XYZtoRGB(Imf::Chromaticities(), 1.f);\n\n                    Imath::M44f conversionMatrix = RGB_XYZ * XYZ_RGB;\n\n                    #pragma omp parallel for\n                    for (int y = 0; y < m_height; y++) {\n                        for (int x = 0; x < m_width; x++) {\n                            const float r\n                              = m_pixelBuffer[4 * (y * m_width + x) + 0];\n                            const float g\n                              = m_pixelBuffer[4 * (y * m_width + x) + 1];\n                            const float b\n                              = m_pixelBuffer[4 * (y * m_width + x) + 2];\n\n                            Imath::V3f rgb(r, g, b);\n                            rgb *= conversionMatrix;\n\n                            m_pixelBuffer[4 * (y * m_width + x) + 0] = rgb.x;\n                            m_pixelBuffer[4 * (y * m_width + x) + 1] = rgb.y;\n                            m_pixelBuffer[4 * (y * m_width + x) + 2] = rgb.z;\n                        }\n                    }\n                } break;\n\n                case Layer_YC: {\n                    std::string yLayer  = m_parentLayer + \"Y\";\n                    std::string ryLayer = m_parentLayer + \"RY\";\n                    std::string byLayer = m_parentLayer + \"BY\";\n\n                    Imf::FrameBuffer framebuffer;\n\n                    std::vector<Imf::Rgba> buff1(m_width * m_height);\n                    std::vector<Imf::Rgba> buff2(m_width * m_height);\n\n                    std::vector<float> yBuffer(m_width * m_height);\n                    std::vector<float> ryBuffer(m_width / 2 * m_height / 2);\n                    std::vector<float> byBuffer(m_width / 2 * m_height / 2);\n\n                    Imf::Slice ySlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &yBuffer[0],\n                      datW,\n                      sizeof(float),\n                      m_width * sizeof(float));\n\n                    Imf::Slice rySlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &ryBuffer[0],\n                      datW,\n                      sizeof(float),\n                      m_width / 2 * sizeof(float),\n                      2,\n                      2);\n\n                    Imf::Slice bySlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &byBuffer[0],\n                      datW,\n                      sizeof(float),\n                      m_width / 2 * sizeof(float),\n                      2,\n                      2);\n\n                    framebuffer.insert(yLayer, ySlice);\n                    framebuffer.insert(ryLayer, rySlice);\n                    framebuffer.insert(byLayer, bySlice);\n\n                    part.setFrameBuffer(framebuffer);\n                    part.readPixels(datW.min.y, datW.max.y);\n\n                    // Filling missing values for chroma in the image\n                    // TODO: now, naive reconstruction.\n                    // Use later Imf::RgbaYca::reconstructChromaHoriz and\n                    // Imf::RgbaYca::reconstructChromaVert to reconstruct missing\n                    // pixels\n                    #pragma omp parallel for\n                    for (int y = 0; y < m_height; y++) {\n                        for (int x = 0; x < m_width; x++) {\n                            const float l = yBuffer[y * m_width + x];\n\n                            /*\n                            float ry = 0, by = 0;\n\n                            if (y % 2 == 0) {\n                                if (x % 2 == 0) {\n                                    ry = ryBuffer[y / 2 * m_width / 2 + x / 2];\n                                    by = byBuffer[y / 2 * m_width / 2 + x / 2];\n                                } else {\n                                    ry = .5 * (ryBuffer[y / 2 * m_width / 2 + x / 2] + ryBuffer[y / 2 * m_width / 2 + x / 2 + 1]);\n                                    by = .5 * (byBuffer[y / 2 * m_width / 2 + x / 2] + byBuffer[y / 2 * m_width / 2 + x / 2 + 1]);\n                                }\n                            } else {\n                                if (x % 2 == 0) {\n                                    ry = .5 * (ryBuffer[y / 2 * m_width / 2 + x / 2] + ryBuffer[(y / 2 + 1) * m_width / 2 + x / 2]);\n                                    by = .5 * (byBuffer[y / 2 * m_width / 2 + x / 2] + byBuffer[(y / 2 + 1) * m_width / 2 + x / 2]);\n                                } else {\n                                    ry = .25 * (ryBuffer[y / 2 * m_width / 2 + x / 2] + ryBuffer[(y / 2 + 1) * m_width / 2 + x / 2] + ryBuffer[y / 2 * m_width / 2 + x / 2 + 1] + ryBuffer[(y / 2 + 1) * m_width / 2 + x / 2 + 1]);\n                                    by = .25 * (byBuffer[y / 2 * m_width / 2 + x / 2] + byBuffer[(y / 2 + 1) * m_width / 2 + x / 2] + byBuffer[y / 2 * m_width / 2 + x / 2 + 1] + byBuffer[(y / 2 + 1) * m_width / 2 + x / 2 + 1]);\n                                }\n                            }\n                            */\n\n                            const float ry\n                              = ryBuffer[y / 2 * m_width / 2 + x / 2];\n                            const float by\n                              = byBuffer[y / 2 * m_width / 2 + x / 2];\n\n                            buff1[y * m_width + x].r = ry;\n                            buff1[y * m_width + x].g = l;\n                            buff1[y * m_width + x].b = by;\n                            // Do not forget the alpha values read earlier\n                            buff1[y * m_width + x].a\n                              = m_pixelBuffer[4 * (y * m_width + x) + 3];\n                        }\n                    }\n\n                    Imath::V3f yw = Imf::RgbaYca::computeYw(chromaticities);\n\n                    // Proceed to the YCA -> RGBA conversion\n                    #pragma omp parallel for\n                    for (int y = 0; y < m_height; y++) {\n                        Imf::RgbaYca::YCAtoRGBA(\n                          yw,\n                          m_width,\n                          &buff1[y * m_width],\n                          &buff1[y * m_width]);\n                    }\n\n                    // Fix over saturated pixels\n                    #pragma omp parallel for\n                    for (int y = 0; y < m_height; y++) {\n                        const Imf::Rgba* scanlines[3];\n\n                        if (y == 0) {\n                            scanlines[0] = &buff1[(y + 1) * m_width];\n                        } else {\n                            scanlines[0] = &buff1[(y - 1) * m_width];\n                        }\n\n                        scanlines[1] = &buff1[y * m_width];\n\n                        if (y == m_height - 1) {\n                            scanlines[2] = &buff1[(y - 1) * m_width];\n                        } else {\n                            scanlines[2] = &buff1[(y + 1) * m_width];\n                        }\n\n                        Imf::RgbaYca::fixSaturation(\n                          yw,\n                          m_width,\n                          scanlines,\n                          &buff2[y * m_width]);\n                    }\n\n                    // Handle custom chromaticities\n                    Imath::M44f RGB_XYZ = Imf::RGBtoXYZ(chromaticities, 1.f);\n                    Imath::M44f XYZ_RGB\n                      = Imf::XYZtoRGB(Imf::Chromaticities(), 1.f);\n\n                    Imath::M44f conversionMatrix = RGB_XYZ * XYZ_RGB;\n\n                    #pragma omp parallel for\n                    for (int y = 0; y < m_height; y++) {\n                        for (int x = 0; x < m_width; x++) {\n                            Imath::V3f rgb(\n                              buff2[y * m_width + x].r,\n                              buff2[y * m_width + x].g,\n                              buff2[y * m_width + x].b);\n\n                            rgb = rgb * conversionMatrix;\n\n                            m_pixelBuffer[4 * (y * m_width + x) + 0] = rgb.x;\n                            m_pixelBuffer[4 * (y * m_width + x) + 1] = rgb.y;\n                            m_pixelBuffer[4 * (y * m_width + x) + 2] = rgb.z;\n                        }\n                    }\n                }\n\n                break;\n\n                case Layer_Y: {\n                    std::string yLayer = m_parentLayer;\n\n                    Imf::FrameBuffer framebuffer;\n\n                    Imf::Slice ySlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &m_pixelBuffer[0],\n                      datW,\n                      4 * sizeof(float),\n                      4 * m_width * sizeof(float));\n\n                    framebuffer.insert(yLayer, ySlice);\n\n                    part.setFrameBuffer(framebuffer);\n                    part.readPixels(datW.min.y, datW.max.y);\n\n                    #pragma omp parallel for\n                    for (int i = 0; i < m_height * m_width; i++) {\n                        m_pixelBuffer[4 * i + 1] = m_pixelBuffer[4 * i + 0];\n                        m_pixelBuffer[4 * i + 2] = m_pixelBuffer[4 * i + 0];\n                        m_pixelBuffer[4 * i + 3] = 1.f;\n                    }\n                } break;\n            }\n\n            m_image = QImage(m_width, m_height, QImage::Format_RGBA8888);\n            m_isImageLoaded = true;\n\n            emit imageLoaded();\n\n            updateImage();\n        } catch (std::exception& e) {\n            emit loadFailed(e.what());\n            return;\n        }\n    });\n\n    m_imageLoadingWatcher->setFuture(imageLoading);\n}\n\nstd::string RGBFramebufferModel::getColorInfo(int x, int y) const\n{\n    if (x < 0 || x >= width() || y < 0 || y >= height()) {\n        return \"\";\n    }\n\n    std::stringstream ss;\n    ss << \"x: \" << x << \" y: \" << y << \" | \"\n       << \" R: \" << m_pixelBuffer[4 * (y * width() + x) + 0]\n       << \" G: \" << m_pixelBuffer[4 * (y * width() + x) + 1]\n       << \" B: \" << m_pixelBuffer[4 * (y * width() + x) + 2]\n       << \" A: \" << m_pixelBuffer[4 * (y * width() + x) + 3];\n\n    return ss.str();\n}\n\n\nfloat RGBFramebufferModel::getRedInfo(int x, int y) const\n{\n    if (x < 0 || x >= width() || y < 0 || y >= height()) {\n        return 0;\n    }\n\n    return m_pixelBuffer[4 * (y * width() + x) + 0];\n}\n\n\nfloat RGBFramebufferModel::getGreenInfo(int x, int y) const\n{\n    if (x < 0 || x >= width() || y < 0 || y >= height()) {\n        return 0;\n    }\n\n    return m_pixelBuffer[4 * (y * width() + x) + 1];\n}\n\n\nfloat RGBFramebufferModel::getBlueInfo(int x, int y) const\n{\n    if (x < 0 || x >= width() || y < 0 || y >= height()) {\n        return 0;\n    }\n\n    return m_pixelBuffer[4 * (y * width() + x) + 2];\n}\n\nfloat RGBFramebufferModel::getAlphaInfo(int x, int y) const\n{\n    if (x < 0 || x >= width() || y < 0 || y >= height()) {\n        return 0;\n    }\n\n    return m_pixelBuffer[4 * (y * width() + x) + 3];\n}\n\n\nvoid RGBFramebufferModel::setExposure(double value)\n{\n    if (m_exposure == value) return;\n\n    m_exposure = value;\n    updateImage();\n}\n\nvoid RGBFramebufferModel::updateImage()\n{\n    if (!m_isImageLoaded) {\n        return;\n    }\n\n    // Several call can occur within a short time e.g., when changing exposure\n    // Ensure to cancel any previous running conversion and wait for the\n    // process to end\n    if (m_imageEditingWatcher->isRunning()) {\n        m_imageEditingWatcher->cancel();\n        m_imageEditingWatcher->waitForFinished();\n    }\n\n    float m_exposure_mul = std::exp2(m_exposure);\n\n    QFuture<void> imageConverting = QtConcurrent::run([=]() {\n        for (int y = 0; y < m_image.height(); y++) {\n            unsigned char* line = m_image.scanLine(y);\n\n            #pragma omp parallel for\n            for (int x = 0; x < m_image.width(); x++) {\n                const float r = ColorTransform::to_sRGB(\n                  m_exposure_mul * m_pixelBuffer[4 * (y * m_width + x) + 0]);\n                const float g = ColorTransform::to_sRGB(\n                  m_exposure_mul * m_pixelBuffer[4 * (y * m_width + x) + 1]);\n                const float b = ColorTransform::to_sRGB(\n                  m_exposure_mul * m_pixelBuffer[4 * (y * m_width + x) + 2]);\n\n                const float a = m_pixelBuffer[4 * (y * m_width + x) + 3];\n\n                line[4 * x + 0] = qMax(0, qMin(255, int(255.f * r)));\n                line[4 * x + 1] = qMax(0, qMin(255, int(255.f * g)));\n                line[4 * x + 2] = qMax(0, qMin(255, int(255.f * b)));\n                line[4 * x + 3] = qMax(0, qMin(255, int(255.f * a)));\n            }\n\n            if (m_imageEditingWatcher->isCanceled()) {\n                break;\n            }\n        }\n\n        // We do not notify any canceled process: this would result in\n        // potentially corrupted conversion\n        if (!m_imageEditingWatcher->isCanceled()) {\n            emit imageChanged();\n        }\n    });\n\n    m_imageEditingWatcher->setFuture(imageConverting);\n}\n", "/**\n * Copyright (c) 2021 Alban Fichet <alban dot fichet at gmx dot fr>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *  * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following\n * disclaimer in the documentation and/or other materials provided\n * with the distribution.\n *  * Neither the name of the organization(s) nor the names of its\n * contributors may be used to endorse or promote products derived\n * from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"YFramebufferModel.h\"\n\n#include <util/ColormapModule.h>\n\n#include <QFuture>\n#include <QtConcurrent/QtConcurrent>\n\n#include <OpenEXR/ImfAttribute.h>\n#include <OpenEXR/ImfFrameBuffer.h>\n#include <OpenEXR/ImfHeader.h>\n#include <OpenEXR/ImfInputPart.h>\n\n#include <Imath/ImathBox.h>\n\nYFramebufferModel::YFramebufferModel(\n  const std::string& layerName, QObject* parent)\n  : FramebufferModel(parent)\n  , m_layer(layerName)\n  , m_min(0.f)\n  , m_max(1.f)\n  , m_cmap(ColormapModule::create(\"grayscale\"))\n{}\n\nYFramebufferModel::~YFramebufferModel()\n{\n    delete m_cmap;\n}\n\nvoid YFramebufferModel::load(Imf::MultiPartInputFile& file, int partId)\n{\n    QFuture<void> imageLoading = QtConcurrent::run([this, &file, partId]() {\n        try {\n            Imf::InputPart part(file, partId);\n\n            Imath::Box2i datW = part.header().dataWindow();\n            m_width           = datW.max.x - datW.min.x + 1;\n            m_height          = datW.max.y - datW.min.y + 1;\n\n            m_pixelAspectRatio = part.header().pixelAspectRatio();\n\n            Imf::Slice graySlice;\n            // TODO: Check it that can be guess from the header\n            // also, check if this can be nested\n            if (m_layer == \"BY\" || m_layer == \"RY\") {\n                m_width /= 2;\n                m_height /= 2;\n\n                m_dataWindow = QRect(datW.min.x, datW.min.y, m_width, m_height);\n\n                Imath::Box2i dispW = part.header().displayWindow();\n\n                int dispW_width  = dispW.max.x - dispW.min.x + 1;\n                int dispW_height = dispW.max.y - dispW.min.y + 1;\n\n                m_displayWindow = QRect(\n                  dispW.min.x,\n                  dispW.min.y,\n                  dispW_width / 2,\n                  dispW_height / 2);\n\n                // Check to avoid type overflow, width and height are 32bits int\n                // representing a 2 dimentional image. Can overflow the type when\n                // multiplied together\n                // TODO: Use larger type when manipulating framebuffer\n                const uint64_t partial_size\n                  = (uint64_t)m_width * (uint64_t)m_height;\n\n                if (partial_size > 0x7FFFFFFF) {\n                    throw std::runtime_error(\n                      \"The total image size is too large. May be supported in \"\n                      \"a future revision.\");\n                }\n\n                m_pixelBuffer.resize(m_width * m_height);\n\n                // Luminance Chroma channels\n                graySlice = Imf::Slice::Make(\n                  Imf::PixelType::FLOAT,\n                  m_pixelBuffer.data(),\n                  datW,\n                  sizeof(float),\n                  m_width * sizeof(float),\n                  2,\n                  2);\n            } else {\n                m_dataWindow = QRect(datW.min.x, datW.min.y, m_width, m_height);\n\n                Imath::Box2i dispW = part.header().displayWindow();\n\n                int dispW_width  = dispW.max.x - dispW.min.x + 1;\n                int dispW_height = dispW.max.y - dispW.min.y + 1;\n\n                m_displayWindow\n                  = QRect(dispW.min.x, dispW.min.y, dispW_width, dispW_height);\n\n                m_pixelBuffer.resize(m_width * m_height);\n\n                graySlice = Imf::Slice::Make(\n                  Imf::PixelType::FLOAT,\n                  m_pixelBuffer.data(),\n                  datW);\n            }\n\n            Imf::FrameBuffer framebuffer;\n\n            framebuffer.insert(m_layer, graySlice);\n\n            part.setFrameBuffer(framebuffer);\n            part.readPixels(datW.min.y, datW.max.y);\n\n            // Determine min and max of the dataset\n            m_datasetMin = std::numeric_limits<double>::infinity();\n            m_datasetMax = -std::numeric_limits<double>::infinity();\n\n            for (int i = 0; i < m_width * m_height; i++) {\n                m_datasetMin = std::min(m_datasetMin, (double)m_pixelBuffer[i]);\n                m_datasetMax = std::max(m_datasetMax, (double)m_pixelBuffer[i]);\n            }\n\n            m_image         = QImage(m_width, m_height, QImage::Format_RGB888);\n            m_isImageLoaded = true;\n\n            emit imageLoaded();\n\n            updateImage();\n        } catch (std::exception& e) {\n            emit loadFailed(e.what());\n            return;\n        }\n    });\n\n    m_imageLoadingWatcher->setFuture(imageLoading);\n}\n\nstd::string YFramebufferModel::getColorInfo(int x, int y) const\n{\n    if (x < 0 || x >= width() || y < 0 || y >= height()) {\n        return \"\";\n    }\n\n    std::stringstream ss;\n    ss << \"x: \" << x << \" y: \" << y << \" | \"\n       << \"value = \" << m_pixelBuffer[y * width() + x];\n\n    return ss.str();\n}\n\nvoid YFramebufferModel::setMinValue(double value)\n{\n    m_min = value;\n    updateImage();\n}\n\nvoid YFramebufferModel::setMaxValue(double value)\n{\n    m_max = value;\n    updateImage();\n}\n\nvoid YFramebufferModel::setColormap(ColormapModule::Map map)\n{\n    if (!m_isImageLoaded) {\n        return;\n    }\n\n    // Several calls can occur within a short time e.g., when changing exposure\n    // Ensure to cancel any previous running conversion and wait for the\n    // process to end\n    // Also, bad idea to change the colormap if a process is using it\n    if (m_imageEditingWatcher->isRunning()) {\n        m_imageEditingWatcher->cancel();\n        m_imageEditingWatcher->waitForFinished();\n    }\n\n    if (m_cmap) {\n        delete m_cmap;\n        m_cmap = nullptr;\n    }\n\n    m_cmap = ColormapModule::create(map);\n\n    updateImage();\n}\n\nvoid YFramebufferModel::updateImage()\n{\n    if (!m_isImageLoaded) {\n        return;\n    }\n\n    // Several calls can occur within a short time e.g., when changing exposure\n    // Ensure to cancel any previous running conversion and wait for the\n    // process to end\n    if (m_imageEditingWatcher->isRunning()) {\n        m_imageEditingWatcher->cancel();\n        m_imageEditingWatcher->waitForFinished();\n    }\n\n    QFuture<void> imageConverting = QtConcurrent::run([=]() {\n        for (int y = 0; y < m_image.height(); y++) {\n            unsigned char* line = m_image.scanLine(y);\n\n            #pragma omp parallel for\n            for (int x = 0; x < m_image.width(); x++) {\n                float value = m_pixelBuffer[y * m_width + x];\n                float RGB[3];\n\n                m_cmap->getRGBValue(value, m_min, m_max, RGB);\n\n                for (int c = 0; c < 3; c++) {\n                    line[3 * x + c] = qMax(0, qMin(255, int(255 * RGB[c])));\n                }\n            }\n\n            if (m_imageEditingWatcher->isCanceled()) {\n                break;\n            }\n        }\n\n        // We do not notify any canceled process: this would result in\n        // potentially corrupted conversion\n        if (!m_imageEditingWatcher->isCanceled()) {\n            emit imageChanged();\n        }\n    });\n\n    m_imageEditingWatcher->setFuture(imageConverting);\n}\n"], "filenames": ["src/model/framebuffer/FramebufferModel.cpp", "src/model/framebuffer/FramebufferModel.h", "src/model/framebuffer/RGBFramebufferModel.cpp", "src/model/framebuffer/YFramebufferModel.cpp"], "buggy_code_start_loc": [42, 40, 83, 93], "buggy_code_end_loc": [66, 72, 344, 120], "fixing_code_start_loc": [41, 40, 84, 93], "fixing_code_end_loc": [62, 72, 352, 133], "type": "CWE-120", "message": "OpenEXR-viewer is a viewer for OpenEXR files with detailed metadata probing. Versions prior to 0.6.1 have a memory overflow vulnerability. This issue is fixed in version 0.6.1.", "other": {"cve": {"id": "CVE-2023-50245", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-11T23:15:08.280", "lastModified": "2023-12-14T17:57:33.607", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenEXR-viewer is a viewer for OpenEXR files with detailed metadata probing. Versions prior to 0.6.1 have a memory overflow vulnerability. This issue is fixed in version 0.6.1."}, {"lang": "es", "value": "OpenEXR-viewer es un visor de archivos OpenEXR con sondeo detallado de metadatos. Las versiones anteriores a la 0.6.1 tienen una vulnerabilidad de desbordamiento de memoria. Este problema se solucion\u00f3 en la versi\u00f3n 0.6.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:afichet:openexr_viewer:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6.1", "matchCriteriaId": "395A1F99-2C73-4A59-B31D-C4B2155C5C7C"}]}]}], "references": [{"url": "https://github.com/afichet/openexr-viewer/commit/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/afichet/openexr-viewer/security/advisories/GHSA-99jg-r3f4-rpxj", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/afichet/openexr-viewer/commit/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9"}}