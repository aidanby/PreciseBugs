{"buggy_code": ["/* Configuration file parsing and CONFIG GET/SET commands implementation.\n *\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"cluster.h\"\n\n#include <fcntl.h>\n#include <sys/stat.h>\n\n/*-----------------------------------------------------------------------------\n * Config file name-value maps.\n *----------------------------------------------------------------------------*/\n\ntypedef struct configEnum {\n    const char *name;\n    const int val;\n} configEnum;\n\nconfigEnum maxmemory_policy_enum[] = {\n    {\"volatile-lru\", MAXMEMORY_VOLATILE_LRU},\n    {\"volatile-lfu\", MAXMEMORY_VOLATILE_LFU},\n    {\"volatile-random\",MAXMEMORY_VOLATILE_RANDOM},\n    {\"volatile-ttl\",MAXMEMORY_VOLATILE_TTL},\n    {\"allkeys-lru\",MAXMEMORY_ALLKEYS_LRU},\n    {\"allkeys-lfu\",MAXMEMORY_ALLKEYS_LFU},\n    {\"allkeys-random\",MAXMEMORY_ALLKEYS_RANDOM},\n    {\"noeviction\",MAXMEMORY_NO_EVICTION},\n    {NULL, 0}\n};\n\nconfigEnum syslog_facility_enum[] = {\n    {\"user\",    LOG_USER},\n    {\"local0\",  LOG_LOCAL0},\n    {\"local1\",  LOG_LOCAL1},\n    {\"local2\",  LOG_LOCAL2},\n    {\"local3\",  LOG_LOCAL3},\n    {\"local4\",  LOG_LOCAL4},\n    {\"local5\",  LOG_LOCAL5},\n    {\"local6\",  LOG_LOCAL6},\n    {\"local7\",  LOG_LOCAL7},\n    {NULL, 0}\n};\n\nconfigEnum loglevel_enum[] = {\n    {\"debug\", LL_DEBUG},\n    {\"verbose\", LL_VERBOSE},\n    {\"notice\", LL_NOTICE},\n    {\"warning\", LL_WARNING},\n    {NULL,0}\n};\n\nconfigEnum supervised_mode_enum[] = {\n    {\"upstart\", SUPERVISED_UPSTART},\n    {\"systemd\", SUPERVISED_SYSTEMD},\n    {\"auto\", SUPERVISED_AUTODETECT},\n    {\"no\", SUPERVISED_NONE},\n    {NULL, 0}\n};\n\nconfigEnum aof_fsync_enum[] = {\n    {\"everysec\", AOF_FSYNC_EVERYSEC},\n    {\"always\", AOF_FSYNC_ALWAYS},\n    {\"no\", AOF_FSYNC_NO},\n    {NULL, 0}\n};\n\n/* Output buffer limits presets. */\nclientBufferLimitsConfig clientBufferLimitsDefaults[CLIENT_TYPE_OBUF_COUNT] = {\n    {0, 0, 0}, /* normal */\n    {1024*1024*256, 1024*1024*64, 60}, /* slave */\n    {1024*1024*32, 1024*1024*8, 60}  /* pubsub */\n};\n\n/*-----------------------------------------------------------------------------\n * Enum access functions\n *----------------------------------------------------------------------------*/\n\n/* Get enum value from name. If there is no match INT_MIN is returned. */\nint configEnumGetValue(configEnum *ce, char *name) {\n    while(ce->name != NULL) {\n        if (!strcasecmp(ce->name,name)) return ce->val;\n        ce++;\n    }\n    return INT_MIN;\n}\n\n/* Get enum name from value. If no match is found NULL is returned. */\nconst char *configEnumGetName(configEnum *ce, int val) {\n    while(ce->name != NULL) {\n        if (ce->val == val) return ce->name;\n        ce++;\n    }\n    return NULL;\n}\n\n/* Wrapper for configEnumGetName() returning \"unknown\" insetad of NULL if\n * there is no match. */\nconst char *configEnumGetNameOrUnknown(configEnum *ce, int val) {\n    const char *name = configEnumGetName(ce,val);\n    return name ? name : \"unknown\";\n}\n\n/* Used for INFO generation. */\nconst char *evictPolicyToString(void) {\n    return configEnumGetNameOrUnknown(maxmemory_policy_enum,server.maxmemory_policy);\n}\n\n/*-----------------------------------------------------------------------------\n * Config file parsing\n *----------------------------------------------------------------------------*/\n\nint yesnotoi(char *s) {\n    if (!strcasecmp(s,\"yes\")) return 1;\n    else if (!strcasecmp(s,\"no\")) return 0;\n    else return -1;\n}\n\nvoid appendServerSaveParams(time_t seconds, int changes) {\n    server.saveparams = zrealloc(server.saveparams,sizeof(struct saveparam)*(server.saveparamslen+1));\n    server.saveparams[server.saveparamslen].seconds = seconds;\n    server.saveparams[server.saveparamslen].changes = changes;\n    server.saveparamslen++;\n}\n\nvoid resetServerSaveParams(void) {\n    zfree(server.saveparams);\n    server.saveparams = NULL;\n    server.saveparamslen = 0;\n}\n\nvoid queueLoadModule(sds path, sds *argv, int argc) {\n    int i;\n    struct moduleLoadQueueEntry *loadmod;\n\n    loadmod = zmalloc(sizeof(struct moduleLoadQueueEntry));\n    loadmod->argv = zmalloc(sizeof(robj*)*argc);\n    loadmod->path = sdsnew(path);\n    loadmod->argc = argc;\n    for (i = 0; i < argc; i++) {\n        loadmod->argv[i] = createRawStringObject(argv[i],sdslen(argv[i]));\n    }\n    listAddNodeTail(server.loadmodule_queue,loadmod);\n}\n\nvoid loadServerConfigFromString(char *config) {\n    char *err = NULL;\n    int linenum = 0, totlines, i;\n    int slaveof_linenum = 0;\n    sds *lines;\n\n    lines = sdssplitlen(config,strlen(config),\"\\n\",1,&totlines);\n\n    for (i = 0; i < totlines; i++) {\n        sds *argv;\n        int argc;\n\n        linenum = i+1;\n        lines[i] = sdstrim(lines[i],\" \\t\\r\\n\");\n\n        /* Skip comments and blank lines */\n        if (lines[i][0] == '#' || lines[i][0] == '\\0') continue;\n\n        /* Split into arguments */\n        argv = sdssplitargs(lines[i],&argc);\n        if (argv == NULL) {\n            err = \"Unbalanced quotes in configuration line\";\n            goto loaderr;\n        }\n\n        /* Skip this line if the resulting command vector is empty. */\n        if (argc == 0) {\n            sdsfreesplitres(argv,argc);\n            continue;\n        }\n        sdstolower(argv[0]);\n\n        /* Execute config directives */\n        if (!strcasecmp(argv[0],\"timeout\") && argc == 2) {\n            server.maxidletime = atoi(argv[1]);\n            if (server.maxidletime < 0) {\n                err = \"Invalid timeout value\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"tcp-keepalive\") && argc == 2) {\n            server.tcpkeepalive = atoi(argv[1]);\n            if (server.tcpkeepalive < 0) {\n                err = \"Invalid tcp-keepalive value\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"protected-mode\") && argc == 2) {\n            if ((server.protected_mode = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"port\") && argc == 2) {\n            server.port = atoi(argv[1]);\n            if (server.port < 0 || server.port > 65535) {\n                err = \"Invalid port\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"tcp-backlog\") && argc == 2) {\n            server.tcp_backlog = atoi(argv[1]);\n            if (server.tcp_backlog < 0) {\n                err = \"Invalid backlog value\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"bind\") && argc >= 2) {\n            int j, addresses = argc-1;\n\n            if (addresses > CONFIG_BINDADDR_MAX) {\n                err = \"Too many bind addresses specified\"; goto loaderr;\n            }\n            for (j = 0; j < addresses; j++)\n                server.bindaddr[j] = zstrdup(argv[j+1]);\n            server.bindaddr_count = addresses;\n        } else if (!strcasecmp(argv[0],\"unixsocket\") && argc == 2) {\n            server.unixsocket = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"unixsocketperm\") && argc == 2) {\n            errno = 0;\n            server.unixsocketperm = (mode_t)strtol(argv[1], NULL, 8);\n            if (errno || server.unixsocketperm > 0777) {\n                err = \"Invalid socket file permissions\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"save\")) {\n            if (argc == 3) {\n                int seconds = atoi(argv[1]);\n                int changes = atoi(argv[2]);\n                if (seconds < 1 || changes < 0) {\n                    err = \"Invalid save parameters\"; goto loaderr;\n                }\n                appendServerSaveParams(seconds,changes);\n            } else if (argc == 2 && !strcasecmp(argv[1],\"\")) {\n                resetServerSaveParams();\n            }\n        } else if (!strcasecmp(argv[0],\"dir\") && argc == 2) {\n            if (chdir(argv[1]) == -1) {\n                serverLog(LL_WARNING,\"Can't chdir to '%s': %s\",\n                    argv[1], strerror(errno));\n                exit(1);\n            }\n        } else if (!strcasecmp(argv[0],\"loglevel\") && argc == 2) {\n            server.verbosity = configEnumGetValue(loglevel_enum,argv[1]);\n            if (server.verbosity == INT_MIN) {\n                err = \"Invalid log level. \"\n                      \"Must be one of debug, verbose, notice, warning\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"logfile\") && argc == 2) {\n            FILE *logfp;\n\n            zfree(server.logfile);\n            server.logfile = zstrdup(argv[1]);\n            if (server.logfile[0] != '\\0') {\n                /* Test if we are able to open the file. The server will not\n                 * be able to abort just for this problem later... */\n                logfp = fopen(server.logfile,\"a\");\n                if (logfp == NULL) {\n                    err = sdscatprintf(sdsempty(),\n                        \"Can't open the log file: %s\", strerror(errno));\n                    goto loaderr;\n                }\n                fclose(logfp);\n            }\n        } else if (!strcasecmp(argv[0],\"syslog-enabled\") && argc == 2) {\n            if ((server.syslog_enabled = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"syslog-ident\") && argc == 2) {\n            if (server.syslog_ident) zfree(server.syslog_ident);\n            server.syslog_ident = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"syslog-facility\") && argc == 2) {\n            server.syslog_facility =\n                configEnumGetValue(syslog_facility_enum,argv[1]);\n            if (server.syslog_facility == INT_MIN) {\n                err = \"Invalid log facility. Must be one of USER or between LOCAL0-LOCAL7\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"databases\") && argc == 2) {\n            server.dbnum = atoi(argv[1]);\n            if (server.dbnum < 1) {\n                err = \"Invalid number of databases\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"include\") && argc == 2) {\n            loadServerConfig(argv[1],NULL);\n        } else if (!strcasecmp(argv[0],\"maxclients\") && argc == 2) {\n            server.maxclients = atoi(argv[1]);\n            if (server.maxclients < 1) {\n                err = \"Invalid max clients limit\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"maxmemory\") && argc == 2) {\n            server.maxmemory = memtoll(argv[1],NULL);\n        } else if (!strcasecmp(argv[0],\"maxmemory-policy\") && argc == 2) {\n            server.maxmemory_policy =\n                configEnumGetValue(maxmemory_policy_enum,argv[1]);\n            if (server.maxmemory_policy == INT_MIN) {\n                err = \"Invalid maxmemory policy\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"maxmemory-samples\") && argc == 2) {\n            server.maxmemory_samples = atoi(argv[1]);\n            if (server.maxmemory_samples <= 0) {\n                err = \"maxmemory-samples must be 1 or greater\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"lfu-log-factor\") && argc == 2) {\n            server.lfu_log_factor = atoi(argv[1]);\n            if (server.maxmemory_samples < 0) {\n                err = \"lfu-log-factor must be 0 or greater\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"lfu-decay-time\") && argc == 2) {\n            server.lfu_decay_time = atoi(argv[1]);\n            if (server.maxmemory_samples < 1) {\n                err = \"lfu-decay-time must be 0 or greater\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"slaveof\") && argc == 3) {\n            slaveof_linenum = linenum;\n            server.masterhost = sdsnew(argv[1]);\n            server.masterport = atoi(argv[2]);\n            server.repl_state = REPL_STATE_CONNECT;\n        } else if (!strcasecmp(argv[0],\"repl-ping-slave-period\") && argc == 2) {\n            server.repl_ping_slave_period = atoi(argv[1]);\n            if (server.repl_ping_slave_period <= 0) {\n                err = \"repl-ping-slave-period must be 1 or greater\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"repl-timeout\") && argc == 2) {\n            server.repl_timeout = atoi(argv[1]);\n            if (server.repl_timeout <= 0) {\n                err = \"repl-timeout must be 1 or greater\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"repl-disable-tcp-nodelay\") && argc==2) {\n            if ((server.repl_disable_tcp_nodelay = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"repl-diskless-sync\") && argc==2) {\n            if ((server.repl_diskless_sync = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"repl-diskless-sync-delay\") && argc==2) {\n            server.repl_diskless_sync_delay = atoi(argv[1]);\n            if (server.repl_diskless_sync_delay < 0) {\n                err = \"repl-diskless-sync-delay can't be negative\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"repl-backlog-size\") && argc == 2) {\n            long long size = memtoll(argv[1],NULL);\n            if (size <= 0) {\n                err = \"repl-backlog-size must be 1 or greater.\";\n                goto loaderr;\n            }\n            resizeReplicationBacklog(size);\n        } else if (!strcasecmp(argv[0],\"repl-backlog-ttl\") && argc == 2) {\n            server.repl_backlog_time_limit = atoi(argv[1]);\n            if (server.repl_backlog_time_limit < 0) {\n                err = \"repl-backlog-ttl can't be negative \";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"masterauth\") && argc == 2) {\n            zfree(server.masterauth);\n            server.masterauth = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"slave-serve-stale-data\") && argc == 2) {\n            if ((server.repl_serve_stale_data = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"slave-read-only\") && argc == 2) {\n            if ((server.repl_slave_ro = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"rdbcompression\") && argc == 2) {\n            if ((server.rdb_compression = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"rdbchecksum\") && argc == 2) {\n            if ((server.rdb_checksum = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"activerehashing\") && argc == 2) {\n            if ((server.activerehashing = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"lazyfree-lazy-eviction\") && argc == 2) {\n            if ((server.lazyfree_lazy_eviction = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"lazyfree-lazy-expire\") && argc == 2) {\n            if ((server.lazyfree_lazy_expire = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"lazyfree-lazy-server-del\") && argc == 2){\n            if ((server.lazyfree_lazy_server_del = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"slave-lazy-flush\") && argc == 2) {\n            if ((server.repl_slave_lazy_flush = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"daemonize\") && argc == 2) {\n            if ((server.daemonize = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"hz\") && argc == 2) {\n            server.hz = atoi(argv[1]);\n            if (server.hz < CONFIG_MIN_HZ) server.hz = CONFIG_MIN_HZ;\n            if (server.hz > CONFIG_MAX_HZ) server.hz = CONFIG_MAX_HZ;\n        } else if (!strcasecmp(argv[0],\"appendonly\") && argc == 2) {\n            int yes;\n\n            if ((yes = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n            server.aof_state = yes ? AOF_ON : AOF_OFF;\n        } else if (!strcasecmp(argv[0],\"appendfilename\") && argc == 2) {\n            if (!pathIsBaseName(argv[1])) {\n                err = \"appendfilename can't be a path, just a filename\";\n                goto loaderr;\n            }\n            zfree(server.aof_filename);\n            server.aof_filename = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"no-appendfsync-on-rewrite\")\n                   && argc == 2) {\n            if ((server.aof_no_fsync_on_rewrite= yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"appendfsync\") && argc == 2) {\n            server.aof_fsync = configEnumGetValue(aof_fsync_enum,argv[1]);\n            if (server.aof_fsync == INT_MIN) {\n                err = \"argument must be 'no', 'always' or 'everysec'\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"auto-aof-rewrite-percentage\") &&\n                   argc == 2)\n        {\n            server.aof_rewrite_perc = atoi(argv[1]);\n            if (server.aof_rewrite_perc < 0) {\n                err = \"Invalid negative percentage for AOF auto rewrite\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"auto-aof-rewrite-min-size\") &&\n                   argc == 2)\n        {\n            server.aof_rewrite_min_size = memtoll(argv[1],NULL);\n        } else if (!strcasecmp(argv[0],\"aof-rewrite-incremental-fsync\") &&\n                   argc == 2)\n        {\n            if ((server.aof_rewrite_incremental_fsync =\n                 yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"aof-load-truncated\") && argc == 2) {\n            if ((server.aof_load_truncated = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"aof-use-rdb-preamble\") && argc == 2) {\n            if ((server.aof_use_rdb_preamble = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"requirepass\") && argc == 2) {\n            if (strlen(argv[1]) > CONFIG_AUTHPASS_MAX_LEN) {\n                err = \"Password is longer than CONFIG_AUTHPASS_MAX_LEN\";\n                goto loaderr;\n            }\n            server.requirepass = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"pidfile\") && argc == 2) {\n            zfree(server.pidfile);\n            server.pidfile = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"dbfilename\") && argc == 2) {\n            if (!pathIsBaseName(argv[1])) {\n                err = \"dbfilename can't be a path, just a filename\";\n                goto loaderr;\n            }\n            zfree(server.rdb_filename);\n            server.rdb_filename = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"hash-max-ziplist-entries\") && argc == 2) {\n            server.hash_max_ziplist_entries = memtoll(argv[1], NULL);\n        } else if (!strcasecmp(argv[0],\"hash-max-ziplist-value\") && argc == 2) {\n            server.hash_max_ziplist_value = memtoll(argv[1], NULL);\n        } else if (!strcasecmp(argv[0],\"list-max-ziplist-entries\") && argc == 2){\n            /* DEAD OPTION */\n        } else if (!strcasecmp(argv[0],\"list-max-ziplist-value\") && argc == 2) {\n            /* DEAD OPTION */\n        } else if (!strcasecmp(argv[0],\"list-max-ziplist-size\") && argc == 2) {\n            server.list_max_ziplist_size = atoi(argv[1]);\n        } else if (!strcasecmp(argv[0],\"list-compress-depth\") && argc == 2) {\n            server.list_compress_depth = atoi(argv[1]);\n        } else if (!strcasecmp(argv[0],\"set-max-intset-entries\") && argc == 2) {\n            server.set_max_intset_entries = memtoll(argv[1], NULL);\n        } else if (!strcasecmp(argv[0],\"zset-max-ziplist-entries\") && argc == 2) {\n            server.zset_max_ziplist_entries = memtoll(argv[1], NULL);\n        } else if (!strcasecmp(argv[0],\"zset-max-ziplist-value\") && argc == 2) {\n            server.zset_max_ziplist_value = memtoll(argv[1], NULL);\n        } else if (!strcasecmp(argv[0],\"hll-sparse-max-bytes\") && argc == 2) {\n            server.hll_sparse_max_bytes = memtoll(argv[1], NULL);\n        } else if (!strcasecmp(argv[0],\"rename-command\") && argc == 3) {\n            struct redisCommand *cmd = lookupCommand(argv[1]);\n            int retval;\n\n            if (!cmd) {\n                err = \"No such command in rename-command\";\n                goto loaderr;\n            }\n\n            /* If the target command name is the empty string we just\n             * remove it from the command table. */\n            retval = dictDelete(server.commands, argv[1]);\n            serverAssert(retval == DICT_OK);\n\n            /* Otherwise we re-add the command under a different name. */\n            if (sdslen(argv[2]) != 0) {\n                sds copy = sdsdup(argv[2]);\n\n                retval = dictAdd(server.commands, copy, cmd);\n                if (retval != DICT_OK) {\n                    sdsfree(copy);\n                    err = \"Target command name already exists\"; goto loaderr;\n                }\n            }\n        } else if (!strcasecmp(argv[0],\"cluster-enabled\") && argc == 2) {\n            if ((server.cluster_enabled = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"cluster-config-file\") && argc == 2) {\n            zfree(server.cluster_configfile);\n            server.cluster_configfile = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"cluster-announce-ip\") && argc == 2) {\n            zfree(server.cluster_announce_ip);\n            server.cluster_announce_ip = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"cluster-announce-port\") && argc == 2) {\n            server.cluster_announce_port = atoi(argv[1]);\n            if (server.cluster_announce_port < 0 ||\n                server.cluster_announce_port > 65535)\n            {\n                err = \"Invalid port\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"cluster-announce-bus-port\") &&\n                   argc == 2)\n        {\n            server.cluster_announce_bus_port = atoi(argv[1]);\n            if (server.cluster_announce_bus_port < 0 ||\n                server.cluster_announce_bus_port > 65535)\n            {\n                err = \"Invalid port\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"cluster-require-full-coverage\") &&\n                    argc == 2)\n        {\n            if ((server.cluster_require_full_coverage = yesnotoi(argv[1])) == -1)\n            {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"cluster-node-timeout\") && argc == 2) {\n            server.cluster_node_timeout = strtoll(argv[1],NULL,10);\n            if (server.cluster_node_timeout <= 0) {\n                err = \"cluster node timeout must be 1 or greater\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"cluster-migration-barrier\")\n                   && argc == 2)\n        {\n            server.cluster_migration_barrier = atoi(argv[1]);\n            if (server.cluster_migration_barrier < 0) {\n                err = \"cluster migration barrier must zero or positive\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"cluster-slave-validity-factor\")\n                   && argc == 2)\n        {\n            server.cluster_slave_validity_factor = atoi(argv[1]);\n            if (server.cluster_slave_validity_factor < 0) {\n                err = \"cluster slave validity factor must be zero or positive\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"lua-time-limit\") && argc == 2) {\n            server.lua_time_limit = strtoll(argv[1],NULL,10);\n        } else if (!strcasecmp(argv[0],\"slowlog-log-slower-than\") &&\n                   argc == 2)\n        {\n            server.slowlog_log_slower_than = strtoll(argv[1],NULL,10);\n        } else if (!strcasecmp(argv[0],\"latency-monitor-threshold\") &&\n                   argc == 2)\n        {\n            server.latency_monitor_threshold = strtoll(argv[1],NULL,10);\n            if (server.latency_monitor_threshold < 0) {\n                err = \"The latency threshold can't be negative\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"slowlog-max-len\") && argc == 2) {\n            server.slowlog_max_len = strtoll(argv[1],NULL,10);\n        } else if (!strcasecmp(argv[0],\"client-output-buffer-limit\") &&\n                   argc == 5)\n        {\n            int class = getClientTypeByName(argv[1]);\n            unsigned long long hard, soft;\n            int soft_seconds;\n\n            if (class == -1) {\n                err = \"Unrecognized client limit class\";\n                goto loaderr;\n            }\n            hard = memtoll(argv[2],NULL);\n            soft = memtoll(argv[3],NULL);\n            soft_seconds = atoi(argv[4]);\n            if (soft_seconds < 0) {\n                err = \"Negative number of seconds in soft limit is invalid\";\n                goto loaderr;\n            }\n            server.client_obuf_limits[class].hard_limit_bytes = hard;\n            server.client_obuf_limits[class].soft_limit_bytes = soft;\n            server.client_obuf_limits[class].soft_limit_seconds = soft_seconds;\n        } else if (!strcasecmp(argv[0],\"stop-writes-on-bgsave-error\") &&\n                   argc == 2) {\n            if ((server.stop_writes_on_bgsave_err = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"slave-priority\") && argc == 2) {\n            server.slave_priority = atoi(argv[1]);\n        } else if (!strcasecmp(argv[0],\"slave-announce-ip\") && argc == 2) {\n            zfree(server.slave_announce_ip);\n            server.slave_announce_ip = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"slave-announce-port\") && argc == 2) {\n            server.slave_announce_port = atoi(argv[1]);\n            if (server.slave_announce_port < 0 ||\n                server.slave_announce_port > 65535)\n            {\n                err = \"Invalid port\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"min-slaves-to-write\") && argc == 2) {\n            server.repl_min_slaves_to_write = atoi(argv[1]);\n            if (server.repl_min_slaves_to_write < 0) {\n                err = \"Invalid value for min-slaves-to-write.\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"min-slaves-max-lag\") && argc == 2) {\n            server.repl_min_slaves_max_lag = atoi(argv[1]);\n            if (server.repl_min_slaves_max_lag < 0) {\n                err = \"Invalid value for min-slaves-max-lag.\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"notify-keyspace-events\") && argc == 2) {\n            int flags = keyspaceEventsStringToFlags(argv[1]);\n\n            if (flags == -1) {\n                err = \"Invalid event class character. Use 'g$lshzxeA'.\";\n                goto loaderr;\n            }\n            server.notify_keyspace_events = flags;\n        } else if (!strcasecmp(argv[0],\"supervised\") && argc == 2) {\n            server.supervised_mode =\n                configEnumGetValue(supervised_mode_enum,argv[1]);\n\n            if (server.supervised_mode == INT_MIN) {\n                err = \"Invalid option for 'supervised'. \"\n                    \"Allowed values: 'upstart', 'systemd', 'auto', or 'no'\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"loadmodule\") && argc >= 2) {\n            queueLoadModule(argv[1],&argv[2],argc-2);\n        } else if (!strcasecmp(argv[0],\"sentinel\")) {\n            /* argc == 1 is handled by main() as we need to enter the sentinel\n             * mode ASAP. */\n            if (argc != 1) {\n                if (!server.sentinel_mode) {\n                    err = \"sentinel directive while not in sentinel mode\";\n                    goto loaderr;\n                }\n                err = sentinelHandleConfiguration(argv+1,argc-1);\n                if (err) goto loaderr;\n            }\n        } else {\n            err = \"Bad directive or wrong number of arguments\"; goto loaderr;\n        }\n        sdsfreesplitres(argv,argc);\n    }\n\n    /* Sanity checks. */\n    if (server.cluster_enabled && server.masterhost) {\n        linenum = slaveof_linenum;\n        i = linenum-1;\n        err = \"slaveof directive not allowed in cluster mode\";\n        goto loaderr;\n    }\n\n    sdsfreesplitres(lines,totlines);\n    return;\n\nloaderr:\n    fprintf(stderr, \"\\n*** FATAL CONFIG FILE ERROR ***\\n\");\n    fprintf(stderr, \"Reading the configuration file, at line %d\\n\", linenum);\n    fprintf(stderr, \">>> '%s'\\n\", lines[i]);\n    fprintf(stderr, \"%s\\n\", err);\n    exit(1);\n}\n\n/* Load the server configuration from the specified filename.\n * The function appends the additional configuration directives stored\n * in the 'options' string to the config file before loading.\n *\n * Both filename and options can be NULL, in such a case are considered\n * empty. This way loadServerConfig can be used to just load a file or\n * just load a string. */\nvoid loadServerConfig(char *filename, char *options) {\n    sds config = sdsempty();\n    char buf[CONFIG_MAX_LINE+1];\n\n    /* Load the file content */\n    if (filename) {\n        FILE *fp;\n\n        if (filename[0] == '-' && filename[1] == '\\0') {\n            fp = stdin;\n        } else {\n            if ((fp = fopen(filename,\"r\")) == NULL) {\n                serverLog(LL_WARNING,\n                    \"Fatal error, can't open config file '%s'\", filename);\n                exit(1);\n            }\n        }\n        while(fgets(buf,CONFIG_MAX_LINE+1,fp) != NULL)\n            config = sdscat(config,buf);\n        if (fp != stdin) fclose(fp);\n    }\n    /* Append the additional options */\n    if (options) {\n        config = sdscat(config,\"\\n\");\n        config = sdscat(config,options);\n    }\n    loadServerConfigFromString(config);\n    sdsfree(config);\n}\n\n/*-----------------------------------------------------------------------------\n * CONFIG SET implementation\n *----------------------------------------------------------------------------*/\n\n#define config_set_bool_field(_name,_var) \\\n    } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \\\n        int yn = yesnotoi(o->ptr); \\\n        if (yn == -1) goto badfmt; \\\n        _var = yn;\n\n#define config_set_numerical_field(_name,_var,min,max) \\\n    } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \\\n        if (getLongLongFromObject(o,&ll) == C_ERR) goto badfmt; \\\n        if (min != LLONG_MIN && ll < min) goto badfmt; \\\n        if (max != LLONG_MAX && ll > max) goto badfmt; \\\n        _var = ll;\n\n#define config_set_memory_field(_name,_var) \\\n    } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \\\n        ll = memtoll(o->ptr,&err); \\\n        if (err || ll < 0) goto badfmt; \\\n        _var = ll;\n\n#define config_set_enum_field(_name,_var,_enumvar) \\\n    } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \\\n        int enumval = configEnumGetValue(_enumvar,o->ptr); \\\n        if (enumval == INT_MIN) goto badfmt; \\\n        _var = enumval;\n\n#define config_set_special_field(_name) \\\n    } else if (!strcasecmp(c->argv[2]->ptr,_name)) {\n\n#define config_set_else } else\n\nvoid configSetCommand(client *c) {\n    robj *o;\n    long long ll;\n    int err;\n    serverAssertWithInfo(c,c->argv[2],sdsEncodedObject(c->argv[2]));\n    serverAssertWithInfo(c,c->argv[3],sdsEncodedObject(c->argv[3]));\n    o = c->argv[3];\n\n    if (0) { /* this starts the config_set macros else-if chain. */\n\n    /* Special fields that can't be handled with general macros. */\n    config_set_special_field(\"dbfilename\") {\n        if (!pathIsBaseName(o->ptr)) {\n            addReplyError(c, \"dbfilename can't be a path, just a filename\");\n            return;\n        }\n        zfree(server.rdb_filename);\n        server.rdb_filename = zstrdup(o->ptr);\n    } config_set_special_field(\"requirepass\") {\n        if (sdslen(o->ptr) > CONFIG_AUTHPASS_MAX_LEN) goto badfmt;\n        zfree(server.requirepass);\n        server.requirepass = ((char*)o->ptr)[0] ? zstrdup(o->ptr) : NULL;\n    } config_set_special_field(\"masterauth\") {\n        zfree(server.masterauth);\n        server.masterauth = ((char*)o->ptr)[0] ? zstrdup(o->ptr) : NULL;\n    } config_set_special_field(\"cluster-announce-ip\") {\n        zfree(server.cluster_announce_ip);\n        server.cluster_announce_ip = ((char*)o->ptr)[0] ? zstrdup(o->ptr) : NULL;\n    } config_set_special_field(\"maxclients\") {\n        int orig_value = server.maxclients;\n\n        if (getLongLongFromObject(o,&ll) == C_ERR || ll < 1) goto badfmt;\n\n        /* Try to check if the OS is capable of supporting so many FDs. */\n        server.maxclients = ll;\n        if (ll > orig_value) {\n            adjustOpenFilesLimit();\n            if (server.maxclients != ll) {\n                addReplyErrorFormat(c,\"The operating system is not able to handle the specified number of clients, try with %d\", server.maxclients);\n                server.maxclients = orig_value;\n                return;\n            }\n            if ((unsigned int) aeGetSetSize(server.el) <\n                server.maxclients + CONFIG_FDSET_INCR)\n            {\n                if (aeResizeSetSize(server.el,\n                    server.maxclients + CONFIG_FDSET_INCR) == AE_ERR)\n                {\n                    addReplyError(c,\"The event loop API used by Redis is not able to handle the specified number of clients\");\n                    server.maxclients = orig_value;\n                    return;\n                }\n            }\n        }\n    } config_set_special_field(\"appendonly\") {\n        int enable = yesnotoi(o->ptr);\n\n        if (enable == -1) goto badfmt;\n        if (enable == 0 && server.aof_state != AOF_OFF) {\n            stopAppendOnly();\n        } else if (enable && server.aof_state == AOF_OFF) {\n            if (startAppendOnly() == C_ERR) {\n                addReplyError(c,\n                    \"Unable to turn on AOF. Check server logs.\");\n                return;\n            }\n        }\n    } config_set_special_field(\"save\") {\n        int vlen, j;\n        sds *v = sdssplitlen(o->ptr,sdslen(o->ptr),\" \",1,&vlen);\n\n        /* Perform sanity check before setting the new config:\n         * - Even number of args\n         * - Seconds >= 1, changes >= 0 */\n        if (vlen & 1) {\n            sdsfreesplitres(v,vlen);\n            goto badfmt;\n        }\n        for (j = 0; j < vlen; j++) {\n            char *eptr;\n            long val;\n\n            val = strtoll(v[j], &eptr, 10);\n            if (eptr[0] != '\\0' ||\n                ((j & 1) == 0 && val < 1) ||\n                ((j & 1) == 1 && val < 0)) {\n                sdsfreesplitres(v,vlen);\n                goto badfmt;\n            }\n        }\n        /* Finally set the new config */\n        resetServerSaveParams();\n        for (j = 0; j < vlen; j += 2) {\n            time_t seconds;\n            int changes;\n\n            seconds = strtoll(v[j],NULL,10);\n            changes = strtoll(v[j+1],NULL,10);\n            appendServerSaveParams(seconds, changes);\n        }\n        sdsfreesplitres(v,vlen);\n    } config_set_special_field(\"dir\") {\n        if (chdir((char*)o->ptr) == -1) {\n            addReplyErrorFormat(c,\"Changing directory: %s\", strerror(errno));\n            return;\n        }\n    } config_set_special_field(\"client-output-buffer-limit\") {\n        int vlen, j;\n        sds *v = sdssplitlen(o->ptr,sdslen(o->ptr),\" \",1,&vlen);\n\n        /* We need a multiple of 4: <class> <hard> <soft> <soft_seconds> */\n        if (vlen % 4) {\n            sdsfreesplitres(v,vlen);\n            goto badfmt;\n        }\n\n        /* Sanity check of single arguments, so that we either refuse the\n         * whole configuration string or accept it all, even if a single\n         * error in a single client class is present. */\n        for (j = 0; j < vlen; j++) {\n            long val;\n\n            if ((j % 4) == 0) {\n                if (getClientTypeByName(v[j]) == -1) {\n                    sdsfreesplitres(v,vlen);\n                    goto badfmt;\n                }\n            } else {\n                val = memtoll(v[j], &err);\n                if (err || val < 0) {\n                    sdsfreesplitres(v,vlen);\n                    goto badfmt;\n                }\n            }\n        }\n        /* Finally set the new config */\n        for (j = 0; j < vlen; j += 4) {\n            int class;\n            unsigned long long hard, soft;\n            int soft_seconds;\n\n            class = getClientTypeByName(v[j]);\n            hard = strtoll(v[j+1],NULL,10);\n            soft = strtoll(v[j+2],NULL,10);\n            soft_seconds = strtoll(v[j+3],NULL,10);\n\n            server.client_obuf_limits[class].hard_limit_bytes = hard;\n            server.client_obuf_limits[class].soft_limit_bytes = soft;\n            server.client_obuf_limits[class].soft_limit_seconds = soft_seconds;\n        }\n        sdsfreesplitres(v,vlen);\n    } config_set_special_field(\"notify-keyspace-events\") {\n        int flags = keyspaceEventsStringToFlags(o->ptr);\n\n        if (flags == -1) goto badfmt;\n        server.notify_keyspace_events = flags;\n    } config_set_special_field(\"slave-announce-ip\") {\n        zfree(server.slave_announce_ip);\n        server.slave_announce_ip = ((char*)o->ptr)[0] ? zstrdup(o->ptr) : NULL;\n\n    /* Boolean fields.\n     * config_set_bool_field(name,var). */\n    } config_set_bool_field(\n      \"rdbcompression\", server.rdb_compression) {\n    } config_set_bool_field(\n      \"repl-disable-tcp-nodelay\",server.repl_disable_tcp_nodelay) {\n    } config_set_bool_field(\n      \"repl-diskless-sync\",server.repl_diskless_sync) {\n    } config_set_bool_field(\n      \"cluster-require-full-coverage\",server.cluster_require_full_coverage) {\n    } config_set_bool_field(\n      \"aof-rewrite-incremental-fsync\",server.aof_rewrite_incremental_fsync) {\n    } config_set_bool_field(\n      \"aof-load-truncated\",server.aof_load_truncated) {\n    } config_set_bool_field(\n      \"aof-use-rdb-preamble\",server.aof_use_rdb_preamble) {\n    } config_set_bool_field(\n      \"slave-serve-stale-data\",server.repl_serve_stale_data) {\n    } config_set_bool_field(\n      \"slave-read-only\",server.repl_slave_ro) {\n    } config_set_bool_field(\n      \"activerehashing\",server.activerehashing) {\n    } config_set_bool_field(\n      \"protected-mode\",server.protected_mode) {\n    } config_set_bool_field(\n      \"stop-writes-on-bgsave-error\",server.stop_writes_on_bgsave_err) {\n    } config_set_bool_field(\n      \"lazyfree-lazy-eviction\",server.lazyfree_lazy_eviction) {\n    } config_set_bool_field(\n      \"lazyfree-lazy-expire\",server.lazyfree_lazy_expire) {\n    } config_set_bool_field(\n      \"lazyfree-lazy-server-del\",server.lazyfree_lazy_server_del) {\n    } config_set_bool_field(\n      \"slave-lazy-flush\",server.repl_slave_lazy_flush) {\n    } config_set_bool_field(\n      \"no-appendfsync-on-rewrite\",server.aof_no_fsync_on_rewrite) {\n\n    /* Numerical fields.\n     * config_set_numerical_field(name,var,min,max) */\n    } config_set_numerical_field(\n      \"tcp-keepalive\",server.tcpkeepalive,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"maxmemory-samples\",server.maxmemory_samples,1,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"lfu-log-factor\",server.lfu_log_factor,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"lfu-decay-time\",server.lfu_decay_time,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"timeout\",server.maxidletime,0,LONG_MAX) {\n    } config_set_numerical_field(\n      \"auto-aof-rewrite-percentage\",server.aof_rewrite_perc,0,LLONG_MAX){\n    } config_set_numerical_field(\n      \"auto-aof-rewrite-min-size\",server.aof_rewrite_min_size,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"hash-max-ziplist-entries\",server.hash_max_ziplist_entries,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"hash-max-ziplist-value\",server.hash_max_ziplist_value,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"list-max-ziplist-size\",server.list_max_ziplist_size,INT_MIN,INT_MAX) {\n    } config_set_numerical_field(\n      \"list-compress-depth\",server.list_compress_depth,0,INT_MAX) {\n    } config_set_numerical_field(\n      \"set-max-intset-entries\",server.set_max_intset_entries,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"zset-max-ziplist-entries\",server.zset_max_ziplist_entries,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"zset-max-ziplist-value\",server.zset_max_ziplist_value,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"hll-sparse-max-bytes\",server.hll_sparse_max_bytes,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"lua-time-limit\",server.lua_time_limit,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"slowlog-log-slower-than\",server.slowlog_log_slower_than,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"slowlog-max-len\",ll,0,LLONG_MAX) {\n      /* Cast to unsigned. */\n        server.slowlog_max_len = (unsigned)ll;\n    } config_set_numerical_field(\n      \"latency-monitor-threshold\",server.latency_monitor_threshold,0,LLONG_MAX){\n    } config_set_numerical_field(\n      \"repl-ping-slave-period\",server.repl_ping_slave_period,1,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"repl-timeout\",server.repl_timeout,1,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"repl-backlog-ttl\",server.repl_backlog_time_limit,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"repl-diskless-sync-delay\",server.repl_diskless_sync_delay,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"slave-priority\",server.slave_priority,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"slave-announce-port\",server.slave_announce_port,0,65535) {\n    } config_set_numerical_field(\n      \"min-slaves-to-write\",server.repl_min_slaves_to_write,0,LLONG_MAX) {\n        refreshGoodSlavesCount();\n    } config_set_numerical_field(\n      \"min-slaves-max-lag\",server.repl_min_slaves_max_lag,0,LLONG_MAX) {\n        refreshGoodSlavesCount();\n    } config_set_numerical_field(\n      \"cluster-node-timeout\",server.cluster_node_timeout,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"cluster-announce-port\",server.cluster_announce_port,0,65535) {\n    } config_set_numerical_field(\n      \"cluster-announce-bus-port\",server.cluster_announce_bus_port,0,65535) {\n    } config_set_numerical_field(\n      \"cluster-migration-barrier\",server.cluster_migration_barrier,0,LLONG_MAX){\n    } config_set_numerical_field(\n      \"cluster-slave-validity-factor\",server.cluster_slave_validity_factor,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"hz\",server.hz,0,LLONG_MAX) {\n        /* Hz is more an hint from the user, so we accept values out of range\n         * but cap them to reasonable values. */\n        if (server.hz < CONFIG_MIN_HZ) server.hz = CONFIG_MIN_HZ;\n        if (server.hz > CONFIG_MAX_HZ) server.hz = CONFIG_MAX_HZ;\n    } config_set_numerical_field(\n      \"watchdog-period\",ll,0,LLONG_MAX) {\n        if (ll)\n            enableWatchdog(ll);\n        else\n            disableWatchdog();\n\n    /* Memory fields.\n     * config_set_memory_field(name,var) */\n    } config_set_memory_field(\"maxmemory\",server.maxmemory) {\n        if (server.maxmemory) {\n            if (server.maxmemory < zmalloc_used_memory()) {\n                serverLog(LL_WARNING,\"WARNING: the new maxmemory value set via CONFIG SET is smaller than the current memory usage. This will result in keys eviction and/or inability to accept new write commands depending on the maxmemory-policy.\");\n            }\n            freeMemoryIfNeeded();\n        }\n    } config_set_memory_field(\"repl-backlog-size\",ll) {\n        resizeReplicationBacklog(ll);\n\n    /* Enumeration fields.\n     * config_set_enum_field(name,var,enum_var) */\n    } config_set_enum_field(\n      \"loglevel\",server.verbosity,loglevel_enum) {\n    } config_set_enum_field(\n      \"maxmemory-policy\",server.maxmemory_policy,maxmemory_policy_enum) {\n    } config_set_enum_field(\n      \"appendfsync\",server.aof_fsync,aof_fsync_enum) {\n\n    /* Everyhing else is an error... */\n    } config_set_else {\n        addReplyErrorFormat(c,\"Unsupported CONFIG parameter: %s\",\n            (char*)c->argv[2]->ptr);\n        return;\n    }\n\n    /* On success we just return a generic OK for all the options. */\n    addReply(c,shared.ok);\n    return;\n\nbadfmt: /* Bad format errors */\n    addReplyErrorFormat(c,\"Invalid argument '%s' for CONFIG SET '%s'\",\n            (char*)o->ptr,\n            (char*)c->argv[2]->ptr);\n}\n\n/*-----------------------------------------------------------------------------\n * CONFIG GET implementation\n *----------------------------------------------------------------------------*/\n\n#define config_get_string_field(_name,_var) do { \\\n    if (stringmatch(pattern,_name,1)) { \\\n        addReplyBulkCString(c,_name); \\\n        addReplyBulkCString(c,_var ? _var : \"\"); \\\n        matches++; \\\n    } \\\n} while(0);\n\n#define config_get_bool_field(_name,_var) do { \\\n    if (stringmatch(pattern,_name,1)) { \\\n        addReplyBulkCString(c,_name); \\\n        addReplyBulkCString(c,_var ? \"yes\" : \"no\"); \\\n        matches++; \\\n    } \\\n} while(0);\n\n#define config_get_numerical_field(_name,_var) do { \\\n    if (stringmatch(pattern,_name,1)) { \\\n        ll2string(buf,sizeof(buf),_var); \\\n        addReplyBulkCString(c,_name); \\\n        addReplyBulkCString(c,buf); \\\n        matches++; \\\n    } \\\n} while(0);\n\n#define config_get_enum_field(_name,_var,_enumvar) do { \\\n    if (stringmatch(pattern,_name,1)) { \\\n        addReplyBulkCString(c,_name); \\\n        addReplyBulkCString(c,configEnumGetNameOrUnknown(_enumvar,_var)); \\\n        matches++; \\\n    } \\\n} while(0);\n\nvoid configGetCommand(client *c) {\n    robj *o = c->argv[2];\n    void *replylen = addDeferredMultiBulkLength(c);\n    char *pattern = o->ptr;\n    char buf[128];\n    int matches = 0;\n    serverAssertWithInfo(c,o,sdsEncodedObject(o));\n\n    /* String values */\n    config_get_string_field(\"dbfilename\",server.rdb_filename);\n    config_get_string_field(\"requirepass\",server.requirepass);\n    config_get_string_field(\"masterauth\",server.masterauth);\n    config_get_string_field(\"cluster-announce-ip\",server.cluster_announce_ip);\n    config_get_string_field(\"unixsocket\",server.unixsocket);\n    config_get_string_field(\"logfile\",server.logfile);\n    config_get_string_field(\"pidfile\",server.pidfile);\n    config_get_string_field(\"slave-announce-ip\",server.slave_announce_ip);\n\n    /* Numerical values */\n    config_get_numerical_field(\"maxmemory\",server.maxmemory);\n    config_get_numerical_field(\"maxmemory-samples\",server.maxmemory_samples);\n    config_get_numerical_field(\"timeout\",server.maxidletime);\n    config_get_numerical_field(\"auto-aof-rewrite-percentage\",\n            server.aof_rewrite_perc);\n    config_get_numerical_field(\"auto-aof-rewrite-min-size\",\n            server.aof_rewrite_min_size);\n    config_get_numerical_field(\"hash-max-ziplist-entries\",\n            server.hash_max_ziplist_entries);\n    config_get_numerical_field(\"hash-max-ziplist-value\",\n            server.hash_max_ziplist_value);\n    config_get_numerical_field(\"list-max-ziplist-size\",\n            server.list_max_ziplist_size);\n    config_get_numerical_field(\"list-compress-depth\",\n            server.list_compress_depth);\n    config_get_numerical_field(\"set-max-intset-entries\",\n            server.set_max_intset_entries);\n    config_get_numerical_field(\"zset-max-ziplist-entries\",\n            server.zset_max_ziplist_entries);\n    config_get_numerical_field(\"zset-max-ziplist-value\",\n            server.zset_max_ziplist_value);\n    config_get_numerical_field(\"hll-sparse-max-bytes\",\n            server.hll_sparse_max_bytes);\n    config_get_numerical_field(\"lua-time-limit\",server.lua_time_limit);\n    config_get_numerical_field(\"slowlog-log-slower-than\",\n            server.slowlog_log_slower_than);\n    config_get_numerical_field(\"latency-monitor-threshold\",\n            server.latency_monitor_threshold);\n    config_get_numerical_field(\"slowlog-max-len\",\n            server.slowlog_max_len);\n    config_get_numerical_field(\"port\",server.port);\n    config_get_numerical_field(\"cluster-announce-port\",server.cluster_announce_port);\n    config_get_numerical_field(\"cluster-announce-bus-port\",server.cluster_announce_bus_port);\n    config_get_numerical_field(\"tcp-backlog\",server.tcp_backlog);\n    config_get_numerical_field(\"databases\",server.dbnum);\n    config_get_numerical_field(\"repl-ping-slave-period\",server.repl_ping_slave_period);\n    config_get_numerical_field(\"repl-timeout\",server.repl_timeout);\n    config_get_numerical_field(\"repl-backlog-size\",server.repl_backlog_size);\n    config_get_numerical_field(\"repl-backlog-ttl\",server.repl_backlog_time_limit);\n    config_get_numerical_field(\"maxclients\",server.maxclients);\n    config_get_numerical_field(\"watchdog-period\",server.watchdog_period);\n    config_get_numerical_field(\"slave-priority\",server.slave_priority);\n    config_get_numerical_field(\"slave-announce-port\",server.slave_announce_port);\n    config_get_numerical_field(\"min-slaves-to-write\",server.repl_min_slaves_to_write);\n    config_get_numerical_field(\"min-slaves-max-lag\",server.repl_min_slaves_max_lag);\n    config_get_numerical_field(\"hz\",server.hz);\n    config_get_numerical_field(\"cluster-node-timeout\",server.cluster_node_timeout);\n    config_get_numerical_field(\"cluster-migration-barrier\",server.cluster_migration_barrier);\n    config_get_numerical_field(\"cluster-slave-validity-factor\",server.cluster_slave_validity_factor);\n    config_get_numerical_field(\"repl-diskless-sync-delay\",server.repl_diskless_sync_delay);\n    config_get_numerical_field(\"tcp-keepalive\",server.tcpkeepalive);\n\n    /* Bool (yes/no) values */\n    config_get_bool_field(\"cluster-require-full-coverage\",\n            server.cluster_require_full_coverage);\n    config_get_bool_field(\"no-appendfsync-on-rewrite\",\n            server.aof_no_fsync_on_rewrite);\n    config_get_bool_field(\"slave-serve-stale-data\",\n            server.repl_serve_stale_data);\n    config_get_bool_field(\"slave-read-only\",\n            server.repl_slave_ro);\n    config_get_bool_field(\"stop-writes-on-bgsave-error\",\n            server.stop_writes_on_bgsave_err);\n    config_get_bool_field(\"daemonize\", server.daemonize);\n    config_get_bool_field(\"rdbcompression\", server.rdb_compression);\n    config_get_bool_field(\"rdbchecksum\", server.rdb_checksum);\n    config_get_bool_field(\"activerehashing\", server.activerehashing);\n    config_get_bool_field(\"protected-mode\", server.protected_mode);\n    config_get_bool_field(\"repl-disable-tcp-nodelay\",\n            server.repl_disable_tcp_nodelay);\n    config_get_bool_field(\"repl-diskless-sync\",\n            server.repl_diskless_sync);\n    config_get_bool_field(\"aof-rewrite-incremental-fsync\",\n            server.aof_rewrite_incremental_fsync);\n    config_get_bool_field(\"aof-load-truncated\",\n            server.aof_load_truncated);\n    config_get_bool_field(\"aof-use-rdb-preamble\",\n            server.aof_use_rdb_preamble);\n    config_get_bool_field(\"lazyfree-lazy-eviction\",\n            server.lazyfree_lazy_eviction);\n    config_get_bool_field(\"lazyfree-lazy-expire\",\n            server.lazyfree_lazy_expire);\n    config_get_bool_field(\"lazyfree-lazy-server-del\",\n            server.lazyfree_lazy_server_del);\n    config_get_bool_field(\"slave-lazy-flush\",\n            server.repl_slave_lazy_flush);\n\n    /* Enum values */\n    config_get_enum_field(\"maxmemory-policy\",\n            server.maxmemory_policy,maxmemory_policy_enum);\n    config_get_enum_field(\"loglevel\",\n            server.verbosity,loglevel_enum);\n    config_get_enum_field(\"supervised\",\n            server.supervised_mode,supervised_mode_enum);\n    config_get_enum_field(\"appendfsync\",\n            server.aof_fsync,aof_fsync_enum);\n    config_get_enum_field(\"syslog-facility\",\n            server.syslog_facility,syslog_facility_enum);\n\n    /* Everything we can't handle with macros follows. */\n\n    if (stringmatch(pattern,\"appendonly\",1)) {\n        addReplyBulkCString(c,\"appendonly\");\n        addReplyBulkCString(c,server.aof_state == AOF_OFF ? \"no\" : \"yes\");\n        matches++;\n    }\n    if (stringmatch(pattern,\"dir\",1)) {\n        char buf[1024];\n\n        if (getcwd(buf,sizeof(buf)) == NULL)\n            buf[0] = '\\0';\n\n        addReplyBulkCString(c,\"dir\");\n        addReplyBulkCString(c,buf);\n        matches++;\n    }\n    if (stringmatch(pattern,\"save\",1)) {\n        sds buf = sdsempty();\n        int j;\n\n        for (j = 0; j < server.saveparamslen; j++) {\n            buf = sdscatprintf(buf,\"%jd %d\",\n                    (intmax_t)server.saveparams[j].seconds,\n                    server.saveparams[j].changes);\n            if (j != server.saveparamslen-1)\n                buf = sdscatlen(buf,\" \",1);\n        }\n        addReplyBulkCString(c,\"save\");\n        addReplyBulkCString(c,buf);\n        sdsfree(buf);\n        matches++;\n    }\n    if (stringmatch(pattern,\"client-output-buffer-limit\",1)) {\n        sds buf = sdsempty();\n        int j;\n\n        for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++) {\n            buf = sdscatprintf(buf,\"%s %llu %llu %ld\",\n                    getClientTypeName(j),\n                    server.client_obuf_limits[j].hard_limit_bytes,\n                    server.client_obuf_limits[j].soft_limit_bytes,\n                    (long) server.client_obuf_limits[j].soft_limit_seconds);\n            if (j != CLIENT_TYPE_OBUF_COUNT-1)\n                buf = sdscatlen(buf,\" \",1);\n        }\n        addReplyBulkCString(c,\"client-output-buffer-limit\");\n        addReplyBulkCString(c,buf);\n        sdsfree(buf);\n        matches++;\n    }\n    if (stringmatch(pattern,\"unixsocketperm\",1)) {\n        char buf[32];\n        snprintf(buf,sizeof(buf),\"%o\",server.unixsocketperm);\n        addReplyBulkCString(c,\"unixsocketperm\");\n        addReplyBulkCString(c,buf);\n        matches++;\n    }\n    if (stringmatch(pattern,\"slaveof\",1)) {\n        char buf[256];\n\n        addReplyBulkCString(c,\"slaveof\");\n        if (server.masterhost)\n            snprintf(buf,sizeof(buf),\"%s %d\",\n                server.masterhost, server.masterport);\n        else\n            buf[0] = '\\0';\n        addReplyBulkCString(c,buf);\n        matches++;\n    }\n    if (stringmatch(pattern,\"notify-keyspace-events\",1)) {\n        robj *flagsobj = createObject(OBJ_STRING,\n            keyspaceEventsFlagsToString(server.notify_keyspace_events));\n\n        addReplyBulkCString(c,\"notify-keyspace-events\");\n        addReplyBulk(c,flagsobj);\n        decrRefCount(flagsobj);\n        matches++;\n    }\n    if (stringmatch(pattern,\"bind\",1)) {\n        sds aux = sdsjoin(server.bindaddr,server.bindaddr_count,\" \");\n\n        addReplyBulkCString(c,\"bind\");\n        addReplyBulkCString(c,aux);\n        sdsfree(aux);\n        matches++;\n    }\n    setDeferredMultiBulkLength(c,replylen,matches*2);\n}\n\n/*-----------------------------------------------------------------------------\n * CONFIG REWRITE implementation\n *----------------------------------------------------------------------------*/\n\n#define REDIS_CONFIG_REWRITE_SIGNATURE \"# Generated by CONFIG REWRITE\"\n\n/* We use the following dictionary type to store where a configuration\n * option is mentioned in the old configuration file, so it's\n * like \"maxmemory\" -> list of line numbers (first line is zero). */\nunsigned int dictSdsCaseHash(const void *key);\nint dictSdsKeyCaseCompare(void *privdata, const void *key1, const void *key2);\nvoid dictSdsDestructor(void *privdata, void *val);\nvoid dictListDestructor(void *privdata, void *val);\n\n/* Sentinel config rewriting is implemented inside sentinel.c by\n * rewriteConfigSentinelOption(). */\nvoid rewriteConfigSentinelOption(struct rewriteConfigState *state);\n\ndictType optionToLineDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    dictListDestructor          /* val destructor */\n};\n\ndictType optionSetDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL                        /* val destructor */\n};\n\n/* The config rewrite state. */\nstruct rewriteConfigState {\n    dict *option_to_line; /* Option -> list of config file lines map */\n    dict *rewritten;      /* Dictionary of already processed options */\n    int numlines;         /* Number of lines in current config */\n    sds *lines;           /* Current lines as an array of sds strings */\n    int has_tail;         /* True if we already added directives that were\n                             not present in the original config file. */\n};\n\n/* Append the new line to the current configuration state. */\nvoid rewriteConfigAppendLine(struct rewriteConfigState *state, sds line) {\n    state->lines = zrealloc(state->lines, sizeof(char*) * (state->numlines+1));\n    state->lines[state->numlines++] = line;\n}\n\n/* Populate the option -> list of line numbers map. */\nvoid rewriteConfigAddLineNumberToOption(struct rewriteConfigState *state, sds option, int linenum) {\n    list *l = dictFetchValue(state->option_to_line,option);\n\n    if (l == NULL) {\n        l = listCreate();\n        dictAdd(state->option_to_line,sdsdup(option),l);\n    }\n    listAddNodeTail(l,(void*)(long)linenum);\n}\n\n/* Add the specified option to the set of processed options.\n * This is useful as only unused lines of processed options will be blanked\n * in the config file, while options the rewrite process does not understand\n * remain untouched. */\nvoid rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, const char *option) {\n    sds opt = sdsnew(option);\n\n    if (dictAdd(state->rewritten,opt,NULL) != DICT_OK) sdsfree(opt);\n}\n\n/* Read the old file, split it into lines to populate a newly created\n * config rewrite state, and return it to the caller.\n *\n * If it is impossible to read the old file, NULL is returned.\n * If the old file does not exist at all, an empty state is returned. */\nstruct rewriteConfigState *rewriteConfigReadOldFile(char *path) {\n    FILE *fp = fopen(path,\"r\");\n    struct rewriteConfigState *state = zmalloc(sizeof(*state));\n    char buf[CONFIG_MAX_LINE+1];\n    int linenum = -1;\n\n    if (fp == NULL && errno != ENOENT) return NULL;\n\n    state->option_to_line = dictCreate(&optionToLineDictType,NULL);\n    state->rewritten = dictCreate(&optionSetDictType,NULL);\n    state->numlines = 0;\n    state->lines = NULL;\n    state->has_tail = 0;\n    if (fp == NULL) return state;\n\n    /* Read the old file line by line, populate the state. */\n    while(fgets(buf,CONFIG_MAX_LINE+1,fp) != NULL) {\n        int argc;\n        sds *argv;\n        sds line = sdstrim(sdsnew(buf),\"\\r\\n\\t \");\n\n        linenum++; /* Zero based, so we init at -1 */\n\n        /* Handle comments and empty lines. */\n        if (line[0] == '#' || line[0] == '\\0') {\n            if (!state->has_tail && !strcmp(line,REDIS_CONFIG_REWRITE_SIGNATURE))\n                state->has_tail = 1;\n            rewriteConfigAppendLine(state,line);\n            continue;\n        }\n\n        /* Not a comment, split into arguments. */\n        argv = sdssplitargs(line,&argc);\n        if (argv == NULL) {\n            /* Apparently the line is unparsable for some reason, for\n             * instance it may have unbalanced quotes. Load it as a\n             * comment. */\n            sds aux = sdsnew(\"# ??? \");\n            aux = sdscatsds(aux,line);\n            sdsfree(line);\n            rewriteConfigAppendLine(state,aux);\n            continue;\n        }\n\n        sdstolower(argv[0]); /* We only want lowercase config directives. */\n\n        /* Now we populate the state according to the content of this line.\n         * Append the line and populate the option -> line numbers map. */\n        rewriteConfigAppendLine(state,line);\n        rewriteConfigAddLineNumberToOption(state,argv[0],linenum);\n\n        sdsfreesplitres(argv,argc);\n    }\n    fclose(fp);\n    return state;\n}\n\n/* Rewrite the specified configuration option with the new \"line\".\n * It progressively uses lines of the file that were already used for the same\n * configuration option in the old version of the file, removing that line from\n * the map of options -> line numbers.\n *\n * If there are lines associated with a given configuration option and\n * \"force\" is non-zero, the line is appended to the configuration file.\n * Usually \"force\" is true when an option has not its default value, so it\n * must be rewritten even if not present previously.\n *\n * The first time a line is appended into a configuration file, a comment\n * is added to show that starting from that point the config file was generated\n * by CONFIG REWRITE.\n *\n * \"line\" is either used, or freed, so the caller does not need to free it\n * in any way. */\nvoid rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *option, sds line, int force) {\n    sds o = sdsnew(option);\n    list *l = dictFetchValue(state->option_to_line,o);\n\n    rewriteConfigMarkAsProcessed(state,option);\n\n    if (!l && !force) {\n        /* Option not used previously, and we are not forced to use it. */\n        sdsfree(line);\n        sdsfree(o);\n        return;\n    }\n\n    if (l) {\n        listNode *ln = listFirst(l);\n        int linenum = (long) ln->value;\n\n        /* There are still lines in the old configuration file we can reuse\n         * for this option. Replace the line with the new one. */\n        listDelNode(l,ln);\n        if (listLength(l) == 0) dictDelete(state->option_to_line,o);\n        sdsfree(state->lines[linenum]);\n        state->lines[linenum] = line;\n    } else {\n        /* Append a new line. */\n        if (!state->has_tail) {\n            rewriteConfigAppendLine(state,\n                sdsnew(REDIS_CONFIG_REWRITE_SIGNATURE));\n            state->has_tail = 1;\n        }\n        rewriteConfigAppendLine(state,line);\n    }\n    sdsfree(o);\n}\n\n/* Write the long long 'bytes' value as a string in a way that is parsable\n * inside redis.conf. If possible uses the GB, MB, KB notation. */\nint rewriteConfigFormatMemory(char *buf, size_t len, long long bytes) {\n    int gb = 1024*1024*1024;\n    int mb = 1024*1024;\n    int kb = 1024;\n\n    if (bytes && (bytes % gb) == 0) {\n        return snprintf(buf,len,\"%lldgb\",bytes/gb);\n    } else if (bytes && (bytes % mb) == 0) {\n        return snprintf(buf,len,\"%lldmb\",bytes/mb);\n    } else if (bytes && (bytes % kb) == 0) {\n        return snprintf(buf,len,\"%lldkb\",bytes/kb);\n    } else {\n        return snprintf(buf,len,\"%lld\",bytes);\n    }\n}\n\n/* Rewrite a simple \"option-name <bytes>\" configuration option. */\nvoid rewriteConfigBytesOption(struct rewriteConfigState *state, char *option, long long value, long long defvalue) {\n    char buf[64];\n    int force = value != defvalue;\n    sds line;\n\n    rewriteConfigFormatMemory(buf,sizeof(buf),value);\n    line = sdscatprintf(sdsempty(),\"%s %s\",option,buf);\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite a yes/no option. */\nvoid rewriteConfigYesNoOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {\n    int force = value != defvalue;\n    sds line = sdscatprintf(sdsempty(),\"%s %s\",option,\n        value ? \"yes\" : \"no\");\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite a string option. */\nvoid rewriteConfigStringOption(struct rewriteConfigState *state, char *option, char *value, char *defvalue) {\n    int force = 1;\n    sds line;\n\n    /* String options set to NULL need to be not present at all in the\n     * configuration file to be set to NULL again at the next reboot. */\n    if (value == NULL) {\n        rewriteConfigMarkAsProcessed(state,option);\n        return;\n    }\n\n    /* Set force to zero if the value is set to its default. */\n    if (defvalue && strcmp(value,defvalue) == 0) force = 0;\n\n    line = sdsnew(option);\n    line = sdscatlen(line, \" \", 1);\n    line = sdscatrepr(line, value, strlen(value));\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite a numerical (long long range) option. */\nvoid rewriteConfigNumericalOption(struct rewriteConfigState *state, char *option, long long value, long long defvalue) {\n    int force = value != defvalue;\n    sds line = sdscatprintf(sdsempty(),\"%s %lld\",option,value);\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite a octal option. */\nvoid rewriteConfigOctalOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {\n    int force = value != defvalue;\n    sds line = sdscatprintf(sdsempty(),\"%s %o\",option,value);\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite an enumeration option. It takes as usually state and option name,\n * and in addition the enumeration array and the default value for the\n * option. */\nvoid rewriteConfigEnumOption(struct rewriteConfigState *state, char *option, int value, configEnum *ce, int defval) {\n    sds line;\n    const char *name = configEnumGetNameOrUnknown(ce,value);\n    int force = value != defval;\n\n    line = sdscatprintf(sdsempty(),\"%s %s\",option,name);\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite the syslog-facility option. */\nvoid rewriteConfigSyslogfacilityOption(struct rewriteConfigState *state) {\n    int value = server.syslog_facility;\n    int force = value != LOG_LOCAL0;\n    const char *name = NULL, *option = \"syslog-facility\";\n    sds line;\n\n    name = configEnumGetNameOrUnknown(syslog_facility_enum,value);\n    line = sdscatprintf(sdsempty(),\"%s %s\",option,name);\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite the save option. */\nvoid rewriteConfigSaveOption(struct rewriteConfigState *state) {\n    int j;\n    sds line;\n\n    /* Note that if there are no save parameters at all, all the current\n     * config line with \"save\" will be detected as orphaned and deleted,\n     * resulting into no RDB persistence as expected. */\n    for (j = 0; j < server.saveparamslen; j++) {\n        line = sdscatprintf(sdsempty(),\"save %ld %d\",\n            (long) server.saveparams[j].seconds, server.saveparams[j].changes);\n        rewriteConfigRewriteLine(state,\"save\",line,1);\n    }\n    /* Mark \"save\" as processed in case server.saveparamslen is zero. */\n    rewriteConfigMarkAsProcessed(state,\"save\");\n}\n\n/* Rewrite the dir option, always using absolute paths.*/\nvoid rewriteConfigDirOption(struct rewriteConfigState *state) {\n    char cwd[1024];\n\n    if (getcwd(cwd,sizeof(cwd)) == NULL) {\n        rewriteConfigMarkAsProcessed(state,\"dir\");\n        return; /* no rewrite on error. */\n    }\n    rewriteConfigStringOption(state,\"dir\",cwd,NULL);\n}\n\n/* Rewrite the slaveof option. */\nvoid rewriteConfigSlaveofOption(struct rewriteConfigState *state) {\n    char *option = \"slaveof\";\n    sds line;\n\n    /* If this is a master, we want all the slaveof config options\n     * in the file to be removed. Note that if this is a cluster instance\n     * we don't want a slaveof directive inside redis.conf. */\n    if (server.cluster_enabled || server.masterhost == NULL) {\n        rewriteConfigMarkAsProcessed(state,\"slaveof\");\n        return;\n    }\n    line = sdscatprintf(sdsempty(),\"%s %s %d\", option,\n        server.masterhost, server.masterport);\n    rewriteConfigRewriteLine(state,option,line,1);\n}\n\n/* Rewrite the notify-keyspace-events option. */\nvoid rewriteConfigNotifykeyspaceeventsOption(struct rewriteConfigState *state) {\n    int force = server.notify_keyspace_events != 0;\n    char *option = \"notify-keyspace-events\";\n    sds line, flags;\n\n    flags = keyspaceEventsFlagsToString(server.notify_keyspace_events);\n    line = sdsnew(option);\n    line = sdscatlen(line, \" \", 1);\n    line = sdscatrepr(line, flags, sdslen(flags));\n    sdsfree(flags);\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite the client-output-buffer-limit option. */\nvoid rewriteConfigClientoutputbufferlimitOption(struct rewriteConfigState *state) {\n    int j;\n    char *option = \"client-output-buffer-limit\";\n\n    for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++) {\n        int force = (server.client_obuf_limits[j].hard_limit_bytes !=\n                    clientBufferLimitsDefaults[j].hard_limit_bytes) ||\n                    (server.client_obuf_limits[j].soft_limit_bytes !=\n                    clientBufferLimitsDefaults[j].soft_limit_bytes) ||\n                    (server.client_obuf_limits[j].soft_limit_seconds !=\n                    clientBufferLimitsDefaults[j].soft_limit_seconds);\n        sds line;\n        char hard[64], soft[64];\n\n        rewriteConfigFormatMemory(hard,sizeof(hard),\n                server.client_obuf_limits[j].hard_limit_bytes);\n        rewriteConfigFormatMemory(soft,sizeof(soft),\n                server.client_obuf_limits[j].soft_limit_bytes);\n\n        line = sdscatprintf(sdsempty(),\"%s %s %s %s %ld\",\n                option, getClientTypeName(j), hard, soft,\n                (long) server.client_obuf_limits[j].soft_limit_seconds);\n        rewriteConfigRewriteLine(state,option,line,force);\n    }\n}\n\n/* Rewrite the bind option. */\nvoid rewriteConfigBindOption(struct rewriteConfigState *state) {\n    int force = 1;\n    sds line, addresses;\n    char *option = \"bind\";\n\n    /* Nothing to rewrite if we don't have bind addresses. */\n    if (server.bindaddr_count == 0) {\n        rewriteConfigMarkAsProcessed(state,option);\n        return;\n    }\n\n    /* Rewrite as bind <addr1> <addr2> ... <addrN> */\n    addresses = sdsjoin(server.bindaddr,server.bindaddr_count,\" \");\n    line = sdsnew(option);\n    line = sdscatlen(line, \" \", 1);\n    line = sdscatsds(line, addresses);\n    sdsfree(addresses);\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Glue together the configuration lines in the current configuration\n * rewrite state into a single string, stripping multiple empty lines. */\nsds rewriteConfigGetContentFromState(struct rewriteConfigState *state) {\n    sds content = sdsempty();\n    int j, was_empty = 0;\n\n    for (j = 0; j < state->numlines; j++) {\n        /* Every cluster of empty lines is turned into a single empty line. */\n        if (sdslen(state->lines[j]) == 0) {\n            if (was_empty) continue;\n            was_empty = 1;\n        } else {\n            was_empty = 0;\n        }\n        content = sdscatsds(content,state->lines[j]);\n        content = sdscatlen(content,\"\\n\",1);\n    }\n    return content;\n}\n\n/* Free the configuration rewrite state. */\nvoid rewriteConfigReleaseState(struct rewriteConfigState *state) {\n    sdsfreesplitres(state->lines,state->numlines);\n    dictRelease(state->option_to_line);\n    dictRelease(state->rewritten);\n    zfree(state);\n}\n\n/* At the end of the rewrite process the state contains the remaining\n * map between \"option name\" => \"lines in the original config file\".\n * Lines used by the rewrite process were removed by the function\n * rewriteConfigRewriteLine(), all the other lines are \"orphaned\" and\n * should be replaced by empty lines.\n *\n * This function does just this, iterating all the option names and\n * blanking all the lines still associated. */\nvoid rewriteConfigRemoveOrphaned(struct rewriteConfigState *state) {\n    dictIterator *di = dictGetIterator(state->option_to_line);\n    dictEntry *de;\n\n    while((de = dictNext(di)) != NULL) {\n        list *l = dictGetVal(de);\n        sds option = dictGetKey(de);\n\n        /* Don't blank lines about options the rewrite process\n         * don't understand. */\n        if (dictFind(state->rewritten,option) == NULL) {\n            serverLog(LL_DEBUG,\"Not rewritten option: %s\", option);\n            continue;\n        }\n\n        while(listLength(l)) {\n            listNode *ln = listFirst(l);\n            int linenum = (long) ln->value;\n\n            sdsfree(state->lines[linenum]);\n            state->lines[linenum] = sdsempty();\n            listDelNode(l,ln);\n        }\n    }\n    dictReleaseIterator(di);\n}\n\n/* This function overwrites the old configuration file with the new content.\n *\n * 1) The old file length is obtained.\n * 2) If the new content is smaller, padding is added.\n * 3) A single write(2) call is used to replace the content of the file.\n * 4) Later the file is truncated to the length of the new content.\n *\n * This way we are sure the file is left in a consistent state even if the\n * process is stopped between any of the four operations.\n *\n * The function returns 0 on success, otherwise -1 is returned and errno\n * set accordingly. */\nint rewriteConfigOverwriteFile(char *configfile, sds content) {\n    int retval = 0;\n    int fd = open(configfile,O_RDWR|O_CREAT,0644);\n    int content_size = sdslen(content), padding = 0;\n    struct stat sb;\n    sds content_padded;\n\n    /* 1) Open the old file (or create a new one if it does not\n     *    exist), get the size. */\n    if (fd == -1) return -1; /* errno set by open(). */\n    if (fstat(fd,&sb) == -1) {\n        close(fd);\n        return -1; /* errno set by fstat(). */\n    }\n\n    /* 2) Pad the content at least match the old file size. */\n    content_padded = sdsdup(content);\n    if (content_size < sb.st_size) {\n        /* If the old file was bigger, pad the content with\n         * a newline plus as many \"#\" chars as required. */\n        padding = sb.st_size - content_size;\n        content_padded = sdsgrowzero(content_padded,sb.st_size);\n        content_padded[content_size] = '\\n';\n        memset(content_padded+content_size+1,'#',padding-1);\n    }\n\n    /* 3) Write the new content using a single write(2). */\n    if (write(fd,content_padded,strlen(content_padded)) == -1) {\n        retval = -1;\n        goto cleanup;\n    }\n\n    /* 4) Truncate the file to the right length if we used padding. */\n    if (padding) {\n        if (ftruncate(fd,content_size) == -1) {\n            /* Non critical error... */\n        }\n    }\n\ncleanup:\n    sdsfree(content_padded);\n    close(fd);\n    return retval;\n}\n\n/* Rewrite the configuration file at \"path\".\n * If the configuration file already exists, we try at best to retain comments\n * and overall structure.\n *\n * Configuration parameters that are at their default value, unless already\n * explicitly included in the old configuration file, are not rewritten.\n *\n * On error -1 is returned and errno is set accordingly, otherwise 0. */\nint rewriteConfig(char *path) {\n    struct rewriteConfigState *state;\n    sds newcontent;\n    int retval;\n\n    /* Step 1: read the old config into our rewrite state. */\n    if ((state = rewriteConfigReadOldFile(path)) == NULL) return -1;\n\n    /* Step 2: rewrite every single option, replacing or appending it inside\n     * the rewrite state. */\n\n    rewriteConfigYesNoOption(state,\"daemonize\",server.daemonize,0);\n    rewriteConfigStringOption(state,\"pidfile\",server.pidfile,CONFIG_DEFAULT_PID_FILE);\n    rewriteConfigNumericalOption(state,\"port\",server.port,CONFIG_DEFAULT_SERVER_PORT);\n    rewriteConfigNumericalOption(state,\"cluster-announce-port\",server.cluster_announce_port,CONFIG_DEFAULT_CLUSTER_ANNOUNCE_PORT);\n    rewriteConfigNumericalOption(state,\"cluster-announce-bus-port\",server.cluster_announce_bus_port,CONFIG_DEFAULT_CLUSTER_ANNOUNCE_BUS_PORT);\n    rewriteConfigNumericalOption(state,\"tcp-backlog\",server.tcp_backlog,CONFIG_DEFAULT_TCP_BACKLOG);\n    rewriteConfigBindOption(state);\n    rewriteConfigStringOption(state,\"unixsocket\",server.unixsocket,NULL);\n    rewriteConfigOctalOption(state,\"unixsocketperm\",server.unixsocketperm,CONFIG_DEFAULT_UNIX_SOCKET_PERM);\n    rewriteConfigNumericalOption(state,\"timeout\",server.maxidletime,CONFIG_DEFAULT_CLIENT_TIMEOUT);\n    rewriteConfigNumericalOption(state,\"tcp-keepalive\",server.tcpkeepalive,CONFIG_DEFAULT_TCP_KEEPALIVE);\n    rewriteConfigNumericalOption(state,\"slave-announce-port\",server.slave_announce_port,CONFIG_DEFAULT_SLAVE_ANNOUNCE_PORT);\n    rewriteConfigEnumOption(state,\"loglevel\",server.verbosity,loglevel_enum,CONFIG_DEFAULT_VERBOSITY);\n    rewriteConfigStringOption(state,\"logfile\",server.logfile,CONFIG_DEFAULT_LOGFILE);\n    rewriteConfigYesNoOption(state,\"syslog-enabled\",server.syslog_enabled,CONFIG_DEFAULT_SYSLOG_ENABLED);\n    rewriteConfigStringOption(state,\"syslog-ident\",server.syslog_ident,CONFIG_DEFAULT_SYSLOG_IDENT);\n    rewriteConfigSyslogfacilityOption(state);\n    rewriteConfigSaveOption(state);\n    rewriteConfigNumericalOption(state,\"databases\",server.dbnum,CONFIG_DEFAULT_DBNUM);\n    rewriteConfigYesNoOption(state,\"stop-writes-on-bgsave-error\",server.stop_writes_on_bgsave_err,CONFIG_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR);\n    rewriteConfigYesNoOption(state,\"rdbcompression\",server.rdb_compression,CONFIG_DEFAULT_RDB_COMPRESSION);\n    rewriteConfigYesNoOption(state,\"rdbchecksum\",server.rdb_checksum,CONFIG_DEFAULT_RDB_CHECKSUM);\n    rewriteConfigStringOption(state,\"dbfilename\",server.rdb_filename,CONFIG_DEFAULT_RDB_FILENAME);\n    rewriteConfigDirOption(state);\n    rewriteConfigSlaveofOption(state);\n    rewriteConfigStringOption(state,\"slave-announce-ip\",server.slave_announce_ip,CONFIG_DEFAULT_SLAVE_ANNOUNCE_IP);\n    rewriteConfigStringOption(state,\"masterauth\",server.masterauth,NULL);\n    rewriteConfigStringOption(state,\"cluster-announce-ip\",server.cluster_announce_ip,NULL);\n    rewriteConfigYesNoOption(state,\"slave-serve-stale-data\",server.repl_serve_stale_data,CONFIG_DEFAULT_SLAVE_SERVE_STALE_DATA);\n    rewriteConfigYesNoOption(state,\"slave-read-only\",server.repl_slave_ro,CONFIG_DEFAULT_SLAVE_READ_ONLY);\n    rewriteConfigNumericalOption(state,\"repl-ping-slave-period\",server.repl_ping_slave_period,CONFIG_DEFAULT_REPL_PING_SLAVE_PERIOD);\n    rewriteConfigNumericalOption(state,\"repl-timeout\",server.repl_timeout,CONFIG_DEFAULT_REPL_TIMEOUT);\n    rewriteConfigBytesOption(state,\"repl-backlog-size\",server.repl_backlog_size,CONFIG_DEFAULT_REPL_BACKLOG_SIZE);\n    rewriteConfigBytesOption(state,\"repl-backlog-ttl\",server.repl_backlog_time_limit,CONFIG_DEFAULT_REPL_BACKLOG_TIME_LIMIT);\n    rewriteConfigYesNoOption(state,\"repl-disable-tcp-nodelay\",server.repl_disable_tcp_nodelay,CONFIG_DEFAULT_REPL_DISABLE_TCP_NODELAY);\n    rewriteConfigYesNoOption(state,\"repl-diskless-sync\",server.repl_diskless_sync,CONFIG_DEFAULT_REPL_DISKLESS_SYNC);\n    rewriteConfigNumericalOption(state,\"repl-diskless-sync-delay\",server.repl_diskless_sync_delay,CONFIG_DEFAULT_REPL_DISKLESS_SYNC_DELAY);\n    rewriteConfigNumericalOption(state,\"slave-priority\",server.slave_priority,CONFIG_DEFAULT_SLAVE_PRIORITY);\n    rewriteConfigNumericalOption(state,\"min-slaves-to-write\",server.repl_min_slaves_to_write,CONFIG_DEFAULT_MIN_SLAVES_TO_WRITE);\n    rewriteConfigNumericalOption(state,\"min-slaves-max-lag\",server.repl_min_slaves_max_lag,CONFIG_DEFAULT_MIN_SLAVES_MAX_LAG);\n    rewriteConfigStringOption(state,\"requirepass\",server.requirepass,NULL);\n    rewriteConfigNumericalOption(state,\"maxclients\",server.maxclients,CONFIG_DEFAULT_MAX_CLIENTS);\n    rewriteConfigBytesOption(state,\"maxmemory\",server.maxmemory,CONFIG_DEFAULT_MAXMEMORY);\n    rewriteConfigEnumOption(state,\"maxmemory-policy\",server.maxmemory_policy,maxmemory_policy_enum,CONFIG_DEFAULT_MAXMEMORY_POLICY);\n    rewriteConfigNumericalOption(state,\"maxmemory-samples\",server.maxmemory_samples,CONFIG_DEFAULT_MAXMEMORY_SAMPLES);\n    rewriteConfigYesNoOption(state,\"appendonly\",server.aof_state != AOF_OFF,0);\n    rewriteConfigStringOption(state,\"appendfilename\",server.aof_filename,CONFIG_DEFAULT_AOF_FILENAME);\n    rewriteConfigEnumOption(state,\"appendfsync\",server.aof_fsync,aof_fsync_enum,CONFIG_DEFAULT_AOF_FSYNC);\n    rewriteConfigYesNoOption(state,\"no-appendfsync-on-rewrite\",server.aof_no_fsync_on_rewrite,CONFIG_DEFAULT_AOF_NO_FSYNC_ON_REWRITE);\n    rewriteConfigNumericalOption(state,\"auto-aof-rewrite-percentage\",server.aof_rewrite_perc,AOF_REWRITE_PERC);\n    rewriteConfigBytesOption(state,\"auto-aof-rewrite-min-size\",server.aof_rewrite_min_size,AOF_REWRITE_MIN_SIZE);\n    rewriteConfigNumericalOption(state,\"lua-time-limit\",server.lua_time_limit,LUA_SCRIPT_TIME_LIMIT);\n    rewriteConfigYesNoOption(state,\"cluster-enabled\",server.cluster_enabled,0);\n    rewriteConfigStringOption(state,\"cluster-config-file\",server.cluster_configfile,CONFIG_DEFAULT_CLUSTER_CONFIG_FILE);\n    rewriteConfigYesNoOption(state,\"cluster-require-full-coverage\",server.cluster_require_full_coverage,CLUSTER_DEFAULT_REQUIRE_FULL_COVERAGE);\n    rewriteConfigNumericalOption(state,\"cluster-node-timeout\",server.cluster_node_timeout,CLUSTER_DEFAULT_NODE_TIMEOUT);\n    rewriteConfigNumericalOption(state,\"cluster-migration-barrier\",server.cluster_migration_barrier,CLUSTER_DEFAULT_MIGRATION_BARRIER);\n    rewriteConfigNumericalOption(state,\"cluster-slave-validity-factor\",server.cluster_slave_validity_factor,CLUSTER_DEFAULT_SLAVE_VALIDITY);\n    rewriteConfigNumericalOption(state,\"slowlog-log-slower-than\",server.slowlog_log_slower_than,CONFIG_DEFAULT_SLOWLOG_LOG_SLOWER_THAN);\n    rewriteConfigNumericalOption(state,\"latency-monitor-threshold\",server.latency_monitor_threshold,CONFIG_DEFAULT_LATENCY_MONITOR_THRESHOLD);\n    rewriteConfigNumericalOption(state,\"slowlog-max-len\",server.slowlog_max_len,CONFIG_DEFAULT_SLOWLOG_MAX_LEN);\n    rewriteConfigNotifykeyspaceeventsOption(state);\n    rewriteConfigNumericalOption(state,\"hash-max-ziplist-entries\",server.hash_max_ziplist_entries,OBJ_HASH_MAX_ZIPLIST_ENTRIES);\n    rewriteConfigNumericalOption(state,\"hash-max-ziplist-value\",server.hash_max_ziplist_value,OBJ_HASH_MAX_ZIPLIST_VALUE);\n    rewriteConfigNumericalOption(state,\"list-max-ziplist-size\",server.list_max_ziplist_size,OBJ_LIST_MAX_ZIPLIST_SIZE);\n    rewriteConfigNumericalOption(state,\"list-compress-depth\",server.list_compress_depth,OBJ_LIST_COMPRESS_DEPTH);\n    rewriteConfigNumericalOption(state,\"set-max-intset-entries\",server.set_max_intset_entries,OBJ_SET_MAX_INTSET_ENTRIES);\n    rewriteConfigNumericalOption(state,\"zset-max-ziplist-entries\",server.zset_max_ziplist_entries,OBJ_ZSET_MAX_ZIPLIST_ENTRIES);\n    rewriteConfigNumericalOption(state,\"zset-max-ziplist-value\",server.zset_max_ziplist_value,OBJ_ZSET_MAX_ZIPLIST_VALUE);\n    rewriteConfigNumericalOption(state,\"hll-sparse-max-bytes\",server.hll_sparse_max_bytes,CONFIG_DEFAULT_HLL_SPARSE_MAX_BYTES);\n    rewriteConfigYesNoOption(state,\"activerehashing\",server.activerehashing,CONFIG_DEFAULT_ACTIVE_REHASHING);\n    rewriteConfigYesNoOption(state,\"protected-mode\",server.protected_mode,CONFIG_DEFAULT_PROTECTED_MODE);\n    rewriteConfigClientoutputbufferlimitOption(state);\n    rewriteConfigNumericalOption(state,\"hz\",server.hz,CONFIG_DEFAULT_HZ);\n    rewriteConfigYesNoOption(state,\"aof-rewrite-incremental-fsync\",server.aof_rewrite_incremental_fsync,CONFIG_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC);\n    rewriteConfigYesNoOption(state,\"aof-load-truncated\",server.aof_load_truncated,CONFIG_DEFAULT_AOF_LOAD_TRUNCATED);\n    rewriteConfigYesNoOption(state,\"aof-use-rdb-preamble\",server.aof_use_rdb_preamble,CONFIG_DEFAULT_AOF_USE_RDB_PREAMBLE);\n    rewriteConfigEnumOption(state,\"supervised\",server.supervised_mode,supervised_mode_enum,SUPERVISED_NONE);\n    rewriteConfigYesNoOption(state,\"lazyfree-lazy-eviction\",server.lazyfree_lazy_eviction,CONFIG_DEFAULT_LAZYFREE_LAZY_EVICTION);\n    rewriteConfigYesNoOption(state,\"lazyfree-lazy-expire\",server.lazyfree_lazy_expire,CONFIG_DEFAULT_LAZYFREE_LAZY_EXPIRE);\n    rewriteConfigYesNoOption(state,\"lazyfree-lazy-server-del\",server.lazyfree_lazy_server_del,CONFIG_DEFAULT_LAZYFREE_LAZY_SERVER_DEL);\n    rewriteConfigYesNoOption(state,\"slave-lazy-flush\",server.repl_slave_lazy_flush,CONFIG_DEFAULT_SLAVE_LAZY_FLUSH);\n\n    /* Rewrite Sentinel config if in Sentinel mode. */\n    if (server.sentinel_mode) rewriteConfigSentinelOption(state);\n\n    /* Step 3: remove all the orphaned lines in the old file, that is, lines\n     * that were used by a config option and are no longer used, like in case\n     * of multiple \"save\" options or duplicated options. */\n    rewriteConfigRemoveOrphaned(state);\n\n    /* Step 4: generate a new configuration file from the modified state\n     * and write it into the original file. */\n    newcontent = rewriteConfigGetContentFromState(state);\n    retval = rewriteConfigOverwriteFile(server.configfile,newcontent);\n\n    sdsfree(newcontent);\n    rewriteConfigReleaseState(state);\n    return retval;\n}\n\n/*-----------------------------------------------------------------------------\n * CONFIG command entry point\n *----------------------------------------------------------------------------*/\n\nvoid configCommand(client *c) {\n    /* Only allow CONFIG GET while loading. */\n    if (server.loading && strcasecmp(c->argv[1]->ptr,\"get\")) {\n        addReplyError(c,\"Only CONFIG GET is allowed during loading\");\n        return;\n    }\n\n    if (!strcasecmp(c->argv[1]->ptr,\"set\")) {\n        if (c->argc != 4) goto badarity;\n        configSetCommand(c);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"get\")) {\n        if (c->argc != 3) goto badarity;\n        configGetCommand(c);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"resetstat\")) {\n        if (c->argc != 2) goto badarity;\n        resetServerStats();\n        resetCommandTableStats();\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"rewrite\")) {\n        if (c->argc != 2) goto badarity;\n        if (server.configfile == NULL) {\n            addReplyError(c,\"The server is running without a config file\");\n            return;\n        }\n        if (rewriteConfig(server.configfile) == -1) {\n            serverLog(LL_WARNING,\"CONFIG REWRITE failed: %s\", strerror(errno));\n            addReplyErrorFormat(c,\"Rewriting config file: %s\", strerror(errno));\n        } else {\n            serverLog(LL_WARNING,\"CONFIG REWRITE executed with success.\");\n            addReply(c,shared.ok);\n        }\n    } else {\n        addReplyError(c,\n            \"CONFIG subcommand must be one of GET, SET, RESETSTAT, REWRITE\");\n    }\n    return;\n\nbadarity:\n    addReplyErrorFormat(c,\"Wrong number of arguments for CONFIG %s\",\n        (char*) c->argv[1]->ptr);\n}\n"], "fixing_code": ["/* Configuration file parsing and CONFIG GET/SET commands implementation.\n *\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"cluster.h\"\n\n#include <fcntl.h>\n#include <sys/stat.h>\n\n/*-----------------------------------------------------------------------------\n * Config file name-value maps.\n *----------------------------------------------------------------------------*/\n\ntypedef struct configEnum {\n    const char *name;\n    const int val;\n} configEnum;\n\nconfigEnum maxmemory_policy_enum[] = {\n    {\"volatile-lru\", MAXMEMORY_VOLATILE_LRU},\n    {\"volatile-lfu\", MAXMEMORY_VOLATILE_LFU},\n    {\"volatile-random\",MAXMEMORY_VOLATILE_RANDOM},\n    {\"volatile-ttl\",MAXMEMORY_VOLATILE_TTL},\n    {\"allkeys-lru\",MAXMEMORY_ALLKEYS_LRU},\n    {\"allkeys-lfu\",MAXMEMORY_ALLKEYS_LFU},\n    {\"allkeys-random\",MAXMEMORY_ALLKEYS_RANDOM},\n    {\"noeviction\",MAXMEMORY_NO_EVICTION},\n    {NULL, 0}\n};\n\nconfigEnum syslog_facility_enum[] = {\n    {\"user\",    LOG_USER},\n    {\"local0\",  LOG_LOCAL0},\n    {\"local1\",  LOG_LOCAL1},\n    {\"local2\",  LOG_LOCAL2},\n    {\"local3\",  LOG_LOCAL3},\n    {\"local4\",  LOG_LOCAL4},\n    {\"local5\",  LOG_LOCAL5},\n    {\"local6\",  LOG_LOCAL6},\n    {\"local7\",  LOG_LOCAL7},\n    {NULL, 0}\n};\n\nconfigEnum loglevel_enum[] = {\n    {\"debug\", LL_DEBUG},\n    {\"verbose\", LL_VERBOSE},\n    {\"notice\", LL_NOTICE},\n    {\"warning\", LL_WARNING},\n    {NULL,0}\n};\n\nconfigEnum supervised_mode_enum[] = {\n    {\"upstart\", SUPERVISED_UPSTART},\n    {\"systemd\", SUPERVISED_SYSTEMD},\n    {\"auto\", SUPERVISED_AUTODETECT},\n    {\"no\", SUPERVISED_NONE},\n    {NULL, 0}\n};\n\nconfigEnum aof_fsync_enum[] = {\n    {\"everysec\", AOF_FSYNC_EVERYSEC},\n    {\"always\", AOF_FSYNC_ALWAYS},\n    {\"no\", AOF_FSYNC_NO},\n    {NULL, 0}\n};\n\n/* Output buffer limits presets. */\nclientBufferLimitsConfig clientBufferLimitsDefaults[CLIENT_TYPE_OBUF_COUNT] = {\n    {0, 0, 0}, /* normal */\n    {1024*1024*256, 1024*1024*64, 60}, /* slave */\n    {1024*1024*32, 1024*1024*8, 60}  /* pubsub */\n};\n\n/*-----------------------------------------------------------------------------\n * Enum access functions\n *----------------------------------------------------------------------------*/\n\n/* Get enum value from name. If there is no match INT_MIN is returned. */\nint configEnumGetValue(configEnum *ce, char *name) {\n    while(ce->name != NULL) {\n        if (!strcasecmp(ce->name,name)) return ce->val;\n        ce++;\n    }\n    return INT_MIN;\n}\n\n/* Get enum name from value. If no match is found NULL is returned. */\nconst char *configEnumGetName(configEnum *ce, int val) {\n    while(ce->name != NULL) {\n        if (ce->val == val) return ce->name;\n        ce++;\n    }\n    return NULL;\n}\n\n/* Wrapper for configEnumGetName() returning \"unknown\" insetad of NULL if\n * there is no match. */\nconst char *configEnumGetNameOrUnknown(configEnum *ce, int val) {\n    const char *name = configEnumGetName(ce,val);\n    return name ? name : \"unknown\";\n}\n\n/* Used for INFO generation. */\nconst char *evictPolicyToString(void) {\n    return configEnumGetNameOrUnknown(maxmemory_policy_enum,server.maxmemory_policy);\n}\n\n/*-----------------------------------------------------------------------------\n * Config file parsing\n *----------------------------------------------------------------------------*/\n\nint yesnotoi(char *s) {\n    if (!strcasecmp(s,\"yes\")) return 1;\n    else if (!strcasecmp(s,\"no\")) return 0;\n    else return -1;\n}\n\nvoid appendServerSaveParams(time_t seconds, int changes) {\n    server.saveparams = zrealloc(server.saveparams,sizeof(struct saveparam)*(server.saveparamslen+1));\n    server.saveparams[server.saveparamslen].seconds = seconds;\n    server.saveparams[server.saveparamslen].changes = changes;\n    server.saveparamslen++;\n}\n\nvoid resetServerSaveParams(void) {\n    zfree(server.saveparams);\n    server.saveparams = NULL;\n    server.saveparamslen = 0;\n}\n\nvoid queueLoadModule(sds path, sds *argv, int argc) {\n    int i;\n    struct moduleLoadQueueEntry *loadmod;\n\n    loadmod = zmalloc(sizeof(struct moduleLoadQueueEntry));\n    loadmod->argv = zmalloc(sizeof(robj*)*argc);\n    loadmod->path = sdsnew(path);\n    loadmod->argc = argc;\n    for (i = 0; i < argc; i++) {\n        loadmod->argv[i] = createRawStringObject(argv[i],sdslen(argv[i]));\n    }\n    listAddNodeTail(server.loadmodule_queue,loadmod);\n}\n\nvoid loadServerConfigFromString(char *config) {\n    char *err = NULL;\n    int linenum = 0, totlines, i;\n    int slaveof_linenum = 0;\n    sds *lines;\n\n    lines = sdssplitlen(config,strlen(config),\"\\n\",1,&totlines);\n\n    for (i = 0; i < totlines; i++) {\n        sds *argv;\n        int argc;\n\n        linenum = i+1;\n        lines[i] = sdstrim(lines[i],\" \\t\\r\\n\");\n\n        /* Skip comments and blank lines */\n        if (lines[i][0] == '#' || lines[i][0] == '\\0') continue;\n\n        /* Split into arguments */\n        argv = sdssplitargs(lines[i],&argc);\n        if (argv == NULL) {\n            err = \"Unbalanced quotes in configuration line\";\n            goto loaderr;\n        }\n\n        /* Skip this line if the resulting command vector is empty. */\n        if (argc == 0) {\n            sdsfreesplitres(argv,argc);\n            continue;\n        }\n        sdstolower(argv[0]);\n\n        /* Execute config directives */\n        if (!strcasecmp(argv[0],\"timeout\") && argc == 2) {\n            server.maxidletime = atoi(argv[1]);\n            if (server.maxidletime < 0) {\n                err = \"Invalid timeout value\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"tcp-keepalive\") && argc == 2) {\n            server.tcpkeepalive = atoi(argv[1]);\n            if (server.tcpkeepalive < 0) {\n                err = \"Invalid tcp-keepalive value\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"protected-mode\") && argc == 2) {\n            if ((server.protected_mode = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"port\") && argc == 2) {\n            server.port = atoi(argv[1]);\n            if (server.port < 0 || server.port > 65535) {\n                err = \"Invalid port\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"tcp-backlog\") && argc == 2) {\n            server.tcp_backlog = atoi(argv[1]);\n            if (server.tcp_backlog < 0) {\n                err = \"Invalid backlog value\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"bind\") && argc >= 2) {\n            int j, addresses = argc-1;\n\n            if (addresses > CONFIG_BINDADDR_MAX) {\n                err = \"Too many bind addresses specified\"; goto loaderr;\n            }\n            for (j = 0; j < addresses; j++)\n                server.bindaddr[j] = zstrdup(argv[j+1]);\n            server.bindaddr_count = addresses;\n        } else if (!strcasecmp(argv[0],\"unixsocket\") && argc == 2) {\n            server.unixsocket = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"unixsocketperm\") && argc == 2) {\n            errno = 0;\n            server.unixsocketperm = (mode_t)strtol(argv[1], NULL, 8);\n            if (errno || server.unixsocketperm > 0777) {\n                err = \"Invalid socket file permissions\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"save\")) {\n            if (argc == 3) {\n                int seconds = atoi(argv[1]);\n                int changes = atoi(argv[2]);\n                if (seconds < 1 || changes < 0) {\n                    err = \"Invalid save parameters\"; goto loaderr;\n                }\n                appendServerSaveParams(seconds,changes);\n            } else if (argc == 2 && !strcasecmp(argv[1],\"\")) {\n                resetServerSaveParams();\n            }\n        } else if (!strcasecmp(argv[0],\"dir\") && argc == 2) {\n            if (chdir(argv[1]) == -1) {\n                serverLog(LL_WARNING,\"Can't chdir to '%s': %s\",\n                    argv[1], strerror(errno));\n                exit(1);\n            }\n        } else if (!strcasecmp(argv[0],\"loglevel\") && argc == 2) {\n            server.verbosity = configEnumGetValue(loglevel_enum,argv[1]);\n            if (server.verbosity == INT_MIN) {\n                err = \"Invalid log level. \"\n                      \"Must be one of debug, verbose, notice, warning\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"logfile\") && argc == 2) {\n            FILE *logfp;\n\n            zfree(server.logfile);\n            server.logfile = zstrdup(argv[1]);\n            if (server.logfile[0] != '\\0') {\n                /* Test if we are able to open the file. The server will not\n                 * be able to abort just for this problem later... */\n                logfp = fopen(server.logfile,\"a\");\n                if (logfp == NULL) {\n                    err = sdscatprintf(sdsempty(),\n                        \"Can't open the log file: %s\", strerror(errno));\n                    goto loaderr;\n                }\n                fclose(logfp);\n            }\n        } else if (!strcasecmp(argv[0],\"syslog-enabled\") && argc == 2) {\n            if ((server.syslog_enabled = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"syslog-ident\") && argc == 2) {\n            if (server.syslog_ident) zfree(server.syslog_ident);\n            server.syslog_ident = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"syslog-facility\") && argc == 2) {\n            server.syslog_facility =\n                configEnumGetValue(syslog_facility_enum,argv[1]);\n            if (server.syslog_facility == INT_MIN) {\n                err = \"Invalid log facility. Must be one of USER or between LOCAL0-LOCAL7\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"databases\") && argc == 2) {\n            server.dbnum = atoi(argv[1]);\n            if (server.dbnum < 1) {\n                err = \"Invalid number of databases\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"include\") && argc == 2) {\n            loadServerConfig(argv[1],NULL);\n        } else if (!strcasecmp(argv[0],\"maxclients\") && argc == 2) {\n            server.maxclients = atoi(argv[1]);\n            if (server.maxclients < 1) {\n                err = \"Invalid max clients limit\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"maxmemory\") && argc == 2) {\n            server.maxmemory = memtoll(argv[1],NULL);\n        } else if (!strcasecmp(argv[0],\"maxmemory-policy\") && argc == 2) {\n            server.maxmemory_policy =\n                configEnumGetValue(maxmemory_policy_enum,argv[1]);\n            if (server.maxmemory_policy == INT_MIN) {\n                err = \"Invalid maxmemory policy\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"maxmemory-samples\") && argc == 2) {\n            server.maxmemory_samples = atoi(argv[1]);\n            if (server.maxmemory_samples <= 0) {\n                err = \"maxmemory-samples must be 1 or greater\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"lfu-log-factor\") && argc == 2) {\n            server.lfu_log_factor = atoi(argv[1]);\n            if (server.maxmemory_samples < 0) {\n                err = \"lfu-log-factor must be 0 or greater\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"lfu-decay-time\") && argc == 2) {\n            server.lfu_decay_time = atoi(argv[1]);\n            if (server.maxmemory_samples < 1) {\n                err = \"lfu-decay-time must be 0 or greater\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"slaveof\") && argc == 3) {\n            slaveof_linenum = linenum;\n            server.masterhost = sdsnew(argv[1]);\n            server.masterport = atoi(argv[2]);\n            server.repl_state = REPL_STATE_CONNECT;\n        } else if (!strcasecmp(argv[0],\"repl-ping-slave-period\") && argc == 2) {\n            server.repl_ping_slave_period = atoi(argv[1]);\n            if (server.repl_ping_slave_period <= 0) {\n                err = \"repl-ping-slave-period must be 1 or greater\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"repl-timeout\") && argc == 2) {\n            server.repl_timeout = atoi(argv[1]);\n            if (server.repl_timeout <= 0) {\n                err = \"repl-timeout must be 1 or greater\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"repl-disable-tcp-nodelay\") && argc==2) {\n            if ((server.repl_disable_tcp_nodelay = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"repl-diskless-sync\") && argc==2) {\n            if ((server.repl_diskless_sync = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"repl-diskless-sync-delay\") && argc==2) {\n            server.repl_diskless_sync_delay = atoi(argv[1]);\n            if (server.repl_diskless_sync_delay < 0) {\n                err = \"repl-diskless-sync-delay can't be negative\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"repl-backlog-size\") && argc == 2) {\n            long long size = memtoll(argv[1],NULL);\n            if (size <= 0) {\n                err = \"repl-backlog-size must be 1 or greater.\";\n                goto loaderr;\n            }\n            resizeReplicationBacklog(size);\n        } else if (!strcasecmp(argv[0],\"repl-backlog-ttl\") && argc == 2) {\n            server.repl_backlog_time_limit = atoi(argv[1]);\n            if (server.repl_backlog_time_limit < 0) {\n                err = \"repl-backlog-ttl can't be negative \";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"masterauth\") && argc == 2) {\n            zfree(server.masterauth);\n            server.masterauth = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"slave-serve-stale-data\") && argc == 2) {\n            if ((server.repl_serve_stale_data = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"slave-read-only\") && argc == 2) {\n            if ((server.repl_slave_ro = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"rdbcompression\") && argc == 2) {\n            if ((server.rdb_compression = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"rdbchecksum\") && argc == 2) {\n            if ((server.rdb_checksum = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"activerehashing\") && argc == 2) {\n            if ((server.activerehashing = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"lazyfree-lazy-eviction\") && argc == 2) {\n            if ((server.lazyfree_lazy_eviction = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"lazyfree-lazy-expire\") && argc == 2) {\n            if ((server.lazyfree_lazy_expire = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"lazyfree-lazy-server-del\") && argc == 2){\n            if ((server.lazyfree_lazy_server_del = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"slave-lazy-flush\") && argc == 2) {\n            if ((server.repl_slave_lazy_flush = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"daemonize\") && argc == 2) {\n            if ((server.daemonize = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"hz\") && argc == 2) {\n            server.hz = atoi(argv[1]);\n            if (server.hz < CONFIG_MIN_HZ) server.hz = CONFIG_MIN_HZ;\n            if (server.hz > CONFIG_MAX_HZ) server.hz = CONFIG_MAX_HZ;\n        } else if (!strcasecmp(argv[0],\"appendonly\") && argc == 2) {\n            int yes;\n\n            if ((yes = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n            server.aof_state = yes ? AOF_ON : AOF_OFF;\n        } else if (!strcasecmp(argv[0],\"appendfilename\") && argc == 2) {\n            if (!pathIsBaseName(argv[1])) {\n                err = \"appendfilename can't be a path, just a filename\";\n                goto loaderr;\n            }\n            zfree(server.aof_filename);\n            server.aof_filename = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"no-appendfsync-on-rewrite\")\n                   && argc == 2) {\n            if ((server.aof_no_fsync_on_rewrite= yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"appendfsync\") && argc == 2) {\n            server.aof_fsync = configEnumGetValue(aof_fsync_enum,argv[1]);\n            if (server.aof_fsync == INT_MIN) {\n                err = \"argument must be 'no', 'always' or 'everysec'\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"auto-aof-rewrite-percentage\") &&\n                   argc == 2)\n        {\n            server.aof_rewrite_perc = atoi(argv[1]);\n            if (server.aof_rewrite_perc < 0) {\n                err = \"Invalid negative percentage for AOF auto rewrite\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"auto-aof-rewrite-min-size\") &&\n                   argc == 2)\n        {\n            server.aof_rewrite_min_size = memtoll(argv[1],NULL);\n        } else if (!strcasecmp(argv[0],\"aof-rewrite-incremental-fsync\") &&\n                   argc == 2)\n        {\n            if ((server.aof_rewrite_incremental_fsync =\n                 yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"aof-load-truncated\") && argc == 2) {\n            if ((server.aof_load_truncated = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"aof-use-rdb-preamble\") && argc == 2) {\n            if ((server.aof_use_rdb_preamble = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"requirepass\") && argc == 2) {\n            if (strlen(argv[1]) > CONFIG_AUTHPASS_MAX_LEN) {\n                err = \"Password is longer than CONFIG_AUTHPASS_MAX_LEN\";\n                goto loaderr;\n            }\n            server.requirepass = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"pidfile\") && argc == 2) {\n            zfree(server.pidfile);\n            server.pidfile = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"dbfilename\") && argc == 2) {\n            if (!pathIsBaseName(argv[1])) {\n                err = \"dbfilename can't be a path, just a filename\";\n                goto loaderr;\n            }\n            zfree(server.rdb_filename);\n            server.rdb_filename = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"hash-max-ziplist-entries\") && argc == 2) {\n            server.hash_max_ziplist_entries = memtoll(argv[1], NULL);\n        } else if (!strcasecmp(argv[0],\"hash-max-ziplist-value\") && argc == 2) {\n            server.hash_max_ziplist_value = memtoll(argv[1], NULL);\n        } else if (!strcasecmp(argv[0],\"list-max-ziplist-entries\") && argc == 2){\n            /* DEAD OPTION */\n        } else if (!strcasecmp(argv[0],\"list-max-ziplist-value\") && argc == 2) {\n            /* DEAD OPTION */\n        } else if (!strcasecmp(argv[0],\"list-max-ziplist-size\") && argc == 2) {\n            server.list_max_ziplist_size = atoi(argv[1]);\n        } else if (!strcasecmp(argv[0],\"list-compress-depth\") && argc == 2) {\n            server.list_compress_depth = atoi(argv[1]);\n        } else if (!strcasecmp(argv[0],\"set-max-intset-entries\") && argc == 2) {\n            server.set_max_intset_entries = memtoll(argv[1], NULL);\n        } else if (!strcasecmp(argv[0],\"zset-max-ziplist-entries\") && argc == 2) {\n            server.zset_max_ziplist_entries = memtoll(argv[1], NULL);\n        } else if (!strcasecmp(argv[0],\"zset-max-ziplist-value\") && argc == 2) {\n            server.zset_max_ziplist_value = memtoll(argv[1], NULL);\n        } else if (!strcasecmp(argv[0],\"hll-sparse-max-bytes\") && argc == 2) {\n            server.hll_sparse_max_bytes = memtoll(argv[1], NULL);\n        } else if (!strcasecmp(argv[0],\"rename-command\") && argc == 3) {\n            struct redisCommand *cmd = lookupCommand(argv[1]);\n            int retval;\n\n            if (!cmd) {\n                err = \"No such command in rename-command\";\n                goto loaderr;\n            }\n\n            /* If the target command name is the empty string we just\n             * remove it from the command table. */\n            retval = dictDelete(server.commands, argv[1]);\n            serverAssert(retval == DICT_OK);\n\n            /* Otherwise we re-add the command under a different name. */\n            if (sdslen(argv[2]) != 0) {\n                sds copy = sdsdup(argv[2]);\n\n                retval = dictAdd(server.commands, copy, cmd);\n                if (retval != DICT_OK) {\n                    sdsfree(copy);\n                    err = \"Target command name already exists\"; goto loaderr;\n                }\n            }\n        } else if (!strcasecmp(argv[0],\"cluster-enabled\") && argc == 2) {\n            if ((server.cluster_enabled = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"cluster-config-file\") && argc == 2) {\n            zfree(server.cluster_configfile);\n            server.cluster_configfile = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"cluster-announce-ip\") && argc == 2) {\n            zfree(server.cluster_announce_ip);\n            server.cluster_announce_ip = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"cluster-announce-port\") && argc == 2) {\n            server.cluster_announce_port = atoi(argv[1]);\n            if (server.cluster_announce_port < 0 ||\n                server.cluster_announce_port > 65535)\n            {\n                err = \"Invalid port\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"cluster-announce-bus-port\") &&\n                   argc == 2)\n        {\n            server.cluster_announce_bus_port = atoi(argv[1]);\n            if (server.cluster_announce_bus_port < 0 ||\n                server.cluster_announce_bus_port > 65535)\n            {\n                err = \"Invalid port\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"cluster-require-full-coverage\") &&\n                    argc == 2)\n        {\n            if ((server.cluster_require_full_coverage = yesnotoi(argv[1])) == -1)\n            {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"cluster-node-timeout\") && argc == 2) {\n            server.cluster_node_timeout = strtoll(argv[1],NULL,10);\n            if (server.cluster_node_timeout <= 0) {\n                err = \"cluster node timeout must be 1 or greater\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"cluster-migration-barrier\")\n                   && argc == 2)\n        {\n            server.cluster_migration_barrier = atoi(argv[1]);\n            if (server.cluster_migration_barrier < 0) {\n                err = \"cluster migration barrier must zero or positive\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"cluster-slave-validity-factor\")\n                   && argc == 2)\n        {\n            server.cluster_slave_validity_factor = atoi(argv[1]);\n            if (server.cluster_slave_validity_factor < 0) {\n                err = \"cluster slave validity factor must be zero or positive\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"lua-time-limit\") && argc == 2) {\n            server.lua_time_limit = strtoll(argv[1],NULL,10);\n        } else if (!strcasecmp(argv[0],\"slowlog-log-slower-than\") &&\n                   argc == 2)\n        {\n            server.slowlog_log_slower_than = strtoll(argv[1],NULL,10);\n        } else if (!strcasecmp(argv[0],\"latency-monitor-threshold\") &&\n                   argc == 2)\n        {\n            server.latency_monitor_threshold = strtoll(argv[1],NULL,10);\n            if (server.latency_monitor_threshold < 0) {\n                err = \"The latency threshold can't be negative\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"slowlog-max-len\") && argc == 2) {\n            server.slowlog_max_len = strtoll(argv[1],NULL,10);\n        } else if (!strcasecmp(argv[0],\"client-output-buffer-limit\") &&\n                   argc == 5)\n        {\n            int class = getClientTypeByName(argv[1]);\n            unsigned long long hard, soft;\n            int soft_seconds;\n\n            if (class == -1 || class == CLIENT_TYPE_MASTER) {\n                err = \"Unrecognized client limit class: the user specified \"\n                \"an invalid one, or 'master' which has no buffer limits.\";\n                goto loaderr;\n            }\n            hard = memtoll(argv[2],NULL);\n            soft = memtoll(argv[3],NULL);\n            soft_seconds = atoi(argv[4]);\n            if (soft_seconds < 0) {\n                err = \"Negative number of seconds in soft limit is invalid\";\n                goto loaderr;\n            }\n            server.client_obuf_limits[class].hard_limit_bytes = hard;\n            server.client_obuf_limits[class].soft_limit_bytes = soft;\n            server.client_obuf_limits[class].soft_limit_seconds = soft_seconds;\n        } else if (!strcasecmp(argv[0],\"stop-writes-on-bgsave-error\") &&\n                   argc == 2) {\n            if ((server.stop_writes_on_bgsave_err = yesnotoi(argv[1])) == -1) {\n                err = \"argument must be 'yes' or 'no'\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"slave-priority\") && argc == 2) {\n            server.slave_priority = atoi(argv[1]);\n        } else if (!strcasecmp(argv[0],\"slave-announce-ip\") && argc == 2) {\n            zfree(server.slave_announce_ip);\n            server.slave_announce_ip = zstrdup(argv[1]);\n        } else if (!strcasecmp(argv[0],\"slave-announce-port\") && argc == 2) {\n            server.slave_announce_port = atoi(argv[1]);\n            if (server.slave_announce_port < 0 ||\n                server.slave_announce_port > 65535)\n            {\n                err = \"Invalid port\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"min-slaves-to-write\") && argc == 2) {\n            server.repl_min_slaves_to_write = atoi(argv[1]);\n            if (server.repl_min_slaves_to_write < 0) {\n                err = \"Invalid value for min-slaves-to-write.\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"min-slaves-max-lag\") && argc == 2) {\n            server.repl_min_slaves_max_lag = atoi(argv[1]);\n            if (server.repl_min_slaves_max_lag < 0) {\n                err = \"Invalid value for min-slaves-max-lag.\"; goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"notify-keyspace-events\") && argc == 2) {\n            int flags = keyspaceEventsStringToFlags(argv[1]);\n\n            if (flags == -1) {\n                err = \"Invalid event class character. Use 'g$lshzxeA'.\";\n                goto loaderr;\n            }\n            server.notify_keyspace_events = flags;\n        } else if (!strcasecmp(argv[0],\"supervised\") && argc == 2) {\n            server.supervised_mode =\n                configEnumGetValue(supervised_mode_enum,argv[1]);\n\n            if (server.supervised_mode == INT_MIN) {\n                err = \"Invalid option for 'supervised'. \"\n                    \"Allowed values: 'upstart', 'systemd', 'auto', or 'no'\";\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0],\"loadmodule\") && argc >= 2) {\n            queueLoadModule(argv[1],&argv[2],argc-2);\n        } else if (!strcasecmp(argv[0],\"sentinel\")) {\n            /* argc == 1 is handled by main() as we need to enter the sentinel\n             * mode ASAP. */\n            if (argc != 1) {\n                if (!server.sentinel_mode) {\n                    err = \"sentinel directive while not in sentinel mode\";\n                    goto loaderr;\n                }\n                err = sentinelHandleConfiguration(argv+1,argc-1);\n                if (err) goto loaderr;\n            }\n        } else {\n            err = \"Bad directive or wrong number of arguments\"; goto loaderr;\n        }\n        sdsfreesplitres(argv,argc);\n    }\n\n    /* Sanity checks. */\n    if (server.cluster_enabled && server.masterhost) {\n        linenum = slaveof_linenum;\n        i = linenum-1;\n        err = \"slaveof directive not allowed in cluster mode\";\n        goto loaderr;\n    }\n\n    sdsfreesplitres(lines,totlines);\n    return;\n\nloaderr:\n    fprintf(stderr, \"\\n*** FATAL CONFIG FILE ERROR ***\\n\");\n    fprintf(stderr, \"Reading the configuration file, at line %d\\n\", linenum);\n    fprintf(stderr, \">>> '%s'\\n\", lines[i]);\n    fprintf(stderr, \"%s\\n\", err);\n    exit(1);\n}\n\n/* Load the server configuration from the specified filename.\n * The function appends the additional configuration directives stored\n * in the 'options' string to the config file before loading.\n *\n * Both filename and options can be NULL, in such a case are considered\n * empty. This way loadServerConfig can be used to just load a file or\n * just load a string. */\nvoid loadServerConfig(char *filename, char *options) {\n    sds config = sdsempty();\n    char buf[CONFIG_MAX_LINE+1];\n\n    /* Load the file content */\n    if (filename) {\n        FILE *fp;\n\n        if (filename[0] == '-' && filename[1] == '\\0') {\n            fp = stdin;\n        } else {\n            if ((fp = fopen(filename,\"r\")) == NULL) {\n                serverLog(LL_WARNING,\n                    \"Fatal error, can't open config file '%s'\", filename);\n                exit(1);\n            }\n        }\n        while(fgets(buf,CONFIG_MAX_LINE+1,fp) != NULL)\n            config = sdscat(config,buf);\n        if (fp != stdin) fclose(fp);\n    }\n    /* Append the additional options */\n    if (options) {\n        config = sdscat(config,\"\\n\");\n        config = sdscat(config,options);\n    }\n    loadServerConfigFromString(config);\n    sdsfree(config);\n}\n\n/*-----------------------------------------------------------------------------\n * CONFIG SET implementation\n *----------------------------------------------------------------------------*/\n\n#define config_set_bool_field(_name,_var) \\\n    } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \\\n        int yn = yesnotoi(o->ptr); \\\n        if (yn == -1) goto badfmt; \\\n        _var = yn;\n\n#define config_set_numerical_field(_name,_var,min,max) \\\n    } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \\\n        if (getLongLongFromObject(o,&ll) == C_ERR) goto badfmt; \\\n        if (min != LLONG_MIN && ll < min) goto badfmt; \\\n        if (max != LLONG_MAX && ll > max) goto badfmt; \\\n        _var = ll;\n\n#define config_set_memory_field(_name,_var) \\\n    } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \\\n        ll = memtoll(o->ptr,&err); \\\n        if (err || ll < 0) goto badfmt; \\\n        _var = ll;\n\n#define config_set_enum_field(_name,_var,_enumvar) \\\n    } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \\\n        int enumval = configEnumGetValue(_enumvar,o->ptr); \\\n        if (enumval == INT_MIN) goto badfmt; \\\n        _var = enumval;\n\n#define config_set_special_field(_name) \\\n    } else if (!strcasecmp(c->argv[2]->ptr,_name)) {\n\n#define config_set_else } else\n\nvoid configSetCommand(client *c) {\n    robj *o;\n    long long ll;\n    int err;\n    serverAssertWithInfo(c,c->argv[2],sdsEncodedObject(c->argv[2]));\n    serverAssertWithInfo(c,c->argv[3],sdsEncodedObject(c->argv[3]));\n    o = c->argv[3];\n\n    if (0) { /* this starts the config_set macros else-if chain. */\n\n    /* Special fields that can't be handled with general macros. */\n    config_set_special_field(\"dbfilename\") {\n        if (!pathIsBaseName(o->ptr)) {\n            addReplyError(c, \"dbfilename can't be a path, just a filename\");\n            return;\n        }\n        zfree(server.rdb_filename);\n        server.rdb_filename = zstrdup(o->ptr);\n    } config_set_special_field(\"requirepass\") {\n        if (sdslen(o->ptr) > CONFIG_AUTHPASS_MAX_LEN) goto badfmt;\n        zfree(server.requirepass);\n        server.requirepass = ((char*)o->ptr)[0] ? zstrdup(o->ptr) : NULL;\n    } config_set_special_field(\"masterauth\") {\n        zfree(server.masterauth);\n        server.masterauth = ((char*)o->ptr)[0] ? zstrdup(o->ptr) : NULL;\n    } config_set_special_field(\"cluster-announce-ip\") {\n        zfree(server.cluster_announce_ip);\n        server.cluster_announce_ip = ((char*)o->ptr)[0] ? zstrdup(o->ptr) : NULL;\n    } config_set_special_field(\"maxclients\") {\n        int orig_value = server.maxclients;\n\n        if (getLongLongFromObject(o,&ll) == C_ERR || ll < 1) goto badfmt;\n\n        /* Try to check if the OS is capable of supporting so many FDs. */\n        server.maxclients = ll;\n        if (ll > orig_value) {\n            adjustOpenFilesLimit();\n            if (server.maxclients != ll) {\n                addReplyErrorFormat(c,\"The operating system is not able to handle the specified number of clients, try with %d\", server.maxclients);\n                server.maxclients = orig_value;\n                return;\n            }\n            if ((unsigned int) aeGetSetSize(server.el) <\n                server.maxclients + CONFIG_FDSET_INCR)\n            {\n                if (aeResizeSetSize(server.el,\n                    server.maxclients + CONFIG_FDSET_INCR) == AE_ERR)\n                {\n                    addReplyError(c,\"The event loop API used by Redis is not able to handle the specified number of clients\");\n                    server.maxclients = orig_value;\n                    return;\n                }\n            }\n        }\n    } config_set_special_field(\"appendonly\") {\n        int enable = yesnotoi(o->ptr);\n\n        if (enable == -1) goto badfmt;\n        if (enable == 0 && server.aof_state != AOF_OFF) {\n            stopAppendOnly();\n        } else if (enable && server.aof_state == AOF_OFF) {\n            if (startAppendOnly() == C_ERR) {\n                addReplyError(c,\n                    \"Unable to turn on AOF. Check server logs.\");\n                return;\n            }\n        }\n    } config_set_special_field(\"save\") {\n        int vlen, j;\n        sds *v = sdssplitlen(o->ptr,sdslen(o->ptr),\" \",1,&vlen);\n\n        /* Perform sanity check before setting the new config:\n         * - Even number of args\n         * - Seconds >= 1, changes >= 0 */\n        if (vlen & 1) {\n            sdsfreesplitres(v,vlen);\n            goto badfmt;\n        }\n        for (j = 0; j < vlen; j++) {\n            char *eptr;\n            long val;\n\n            val = strtoll(v[j], &eptr, 10);\n            if (eptr[0] != '\\0' ||\n                ((j & 1) == 0 && val < 1) ||\n                ((j & 1) == 1 && val < 0)) {\n                sdsfreesplitres(v,vlen);\n                goto badfmt;\n            }\n        }\n        /* Finally set the new config */\n        resetServerSaveParams();\n        for (j = 0; j < vlen; j += 2) {\n            time_t seconds;\n            int changes;\n\n            seconds = strtoll(v[j],NULL,10);\n            changes = strtoll(v[j+1],NULL,10);\n            appendServerSaveParams(seconds, changes);\n        }\n        sdsfreesplitres(v,vlen);\n    } config_set_special_field(\"dir\") {\n        if (chdir((char*)o->ptr) == -1) {\n            addReplyErrorFormat(c,\"Changing directory: %s\", strerror(errno));\n            return;\n        }\n    } config_set_special_field(\"client-output-buffer-limit\") {\n        int vlen, j;\n        sds *v = sdssplitlen(o->ptr,sdslen(o->ptr),\" \",1,&vlen);\n\n        /* We need a multiple of 4: <class> <hard> <soft> <soft_seconds> */\n        if (vlen % 4) {\n            sdsfreesplitres(v,vlen);\n            goto badfmt;\n        }\n\n        /* Sanity check of single arguments, so that we either refuse the\n         * whole configuration string or accept it all, even if a single\n         * error in a single client class is present. */\n        for (j = 0; j < vlen; j++) {\n            long val;\n\n            if ((j % 4) == 0) {\n                int class = getClientTypeByName(v[j]);\n                if (class == -1 || class == CLIENT_TYPE_MASTER) {\n                    sdsfreesplitres(v,vlen);\n                    goto badfmt;\n                }\n            } else {\n                val = memtoll(v[j], &err);\n                if (err || val < 0) {\n                    sdsfreesplitres(v,vlen);\n                    goto badfmt;\n                }\n            }\n        }\n        /* Finally set the new config */\n        for (j = 0; j < vlen; j += 4) {\n            int class;\n            unsigned long long hard, soft;\n            int soft_seconds;\n\n            class = getClientTypeByName(v[j]);\n            hard = strtoll(v[j+1],NULL,10);\n            soft = strtoll(v[j+2],NULL,10);\n            soft_seconds = strtoll(v[j+3],NULL,10);\n\n            server.client_obuf_limits[class].hard_limit_bytes = hard;\n            server.client_obuf_limits[class].soft_limit_bytes = soft;\n            server.client_obuf_limits[class].soft_limit_seconds = soft_seconds;\n        }\n        sdsfreesplitres(v,vlen);\n    } config_set_special_field(\"notify-keyspace-events\") {\n        int flags = keyspaceEventsStringToFlags(o->ptr);\n\n        if (flags == -1) goto badfmt;\n        server.notify_keyspace_events = flags;\n    } config_set_special_field(\"slave-announce-ip\") {\n        zfree(server.slave_announce_ip);\n        server.slave_announce_ip = ((char*)o->ptr)[0] ? zstrdup(o->ptr) : NULL;\n\n    /* Boolean fields.\n     * config_set_bool_field(name,var). */\n    } config_set_bool_field(\n      \"rdbcompression\", server.rdb_compression) {\n    } config_set_bool_field(\n      \"repl-disable-tcp-nodelay\",server.repl_disable_tcp_nodelay) {\n    } config_set_bool_field(\n      \"repl-diskless-sync\",server.repl_diskless_sync) {\n    } config_set_bool_field(\n      \"cluster-require-full-coverage\",server.cluster_require_full_coverage) {\n    } config_set_bool_field(\n      \"aof-rewrite-incremental-fsync\",server.aof_rewrite_incremental_fsync) {\n    } config_set_bool_field(\n      \"aof-load-truncated\",server.aof_load_truncated) {\n    } config_set_bool_field(\n      \"aof-use-rdb-preamble\",server.aof_use_rdb_preamble) {\n    } config_set_bool_field(\n      \"slave-serve-stale-data\",server.repl_serve_stale_data) {\n    } config_set_bool_field(\n      \"slave-read-only\",server.repl_slave_ro) {\n    } config_set_bool_field(\n      \"activerehashing\",server.activerehashing) {\n    } config_set_bool_field(\n      \"protected-mode\",server.protected_mode) {\n    } config_set_bool_field(\n      \"stop-writes-on-bgsave-error\",server.stop_writes_on_bgsave_err) {\n    } config_set_bool_field(\n      \"lazyfree-lazy-eviction\",server.lazyfree_lazy_eviction) {\n    } config_set_bool_field(\n      \"lazyfree-lazy-expire\",server.lazyfree_lazy_expire) {\n    } config_set_bool_field(\n      \"lazyfree-lazy-server-del\",server.lazyfree_lazy_server_del) {\n    } config_set_bool_field(\n      \"slave-lazy-flush\",server.repl_slave_lazy_flush) {\n    } config_set_bool_field(\n      \"no-appendfsync-on-rewrite\",server.aof_no_fsync_on_rewrite) {\n\n    /* Numerical fields.\n     * config_set_numerical_field(name,var,min,max) */\n    } config_set_numerical_field(\n      \"tcp-keepalive\",server.tcpkeepalive,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"maxmemory-samples\",server.maxmemory_samples,1,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"lfu-log-factor\",server.lfu_log_factor,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"lfu-decay-time\",server.lfu_decay_time,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"timeout\",server.maxidletime,0,LONG_MAX) {\n    } config_set_numerical_field(\n      \"auto-aof-rewrite-percentage\",server.aof_rewrite_perc,0,LLONG_MAX){\n    } config_set_numerical_field(\n      \"auto-aof-rewrite-min-size\",server.aof_rewrite_min_size,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"hash-max-ziplist-entries\",server.hash_max_ziplist_entries,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"hash-max-ziplist-value\",server.hash_max_ziplist_value,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"list-max-ziplist-size\",server.list_max_ziplist_size,INT_MIN,INT_MAX) {\n    } config_set_numerical_field(\n      \"list-compress-depth\",server.list_compress_depth,0,INT_MAX) {\n    } config_set_numerical_field(\n      \"set-max-intset-entries\",server.set_max_intset_entries,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"zset-max-ziplist-entries\",server.zset_max_ziplist_entries,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"zset-max-ziplist-value\",server.zset_max_ziplist_value,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"hll-sparse-max-bytes\",server.hll_sparse_max_bytes,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"lua-time-limit\",server.lua_time_limit,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"slowlog-log-slower-than\",server.slowlog_log_slower_than,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"slowlog-max-len\",ll,0,LLONG_MAX) {\n      /* Cast to unsigned. */\n        server.slowlog_max_len = (unsigned)ll;\n    } config_set_numerical_field(\n      \"latency-monitor-threshold\",server.latency_monitor_threshold,0,LLONG_MAX){\n    } config_set_numerical_field(\n      \"repl-ping-slave-period\",server.repl_ping_slave_period,1,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"repl-timeout\",server.repl_timeout,1,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"repl-backlog-ttl\",server.repl_backlog_time_limit,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"repl-diskless-sync-delay\",server.repl_diskless_sync_delay,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"slave-priority\",server.slave_priority,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"slave-announce-port\",server.slave_announce_port,0,65535) {\n    } config_set_numerical_field(\n      \"min-slaves-to-write\",server.repl_min_slaves_to_write,0,LLONG_MAX) {\n        refreshGoodSlavesCount();\n    } config_set_numerical_field(\n      \"min-slaves-max-lag\",server.repl_min_slaves_max_lag,0,LLONG_MAX) {\n        refreshGoodSlavesCount();\n    } config_set_numerical_field(\n      \"cluster-node-timeout\",server.cluster_node_timeout,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"cluster-announce-port\",server.cluster_announce_port,0,65535) {\n    } config_set_numerical_field(\n      \"cluster-announce-bus-port\",server.cluster_announce_bus_port,0,65535) {\n    } config_set_numerical_field(\n      \"cluster-migration-barrier\",server.cluster_migration_barrier,0,LLONG_MAX){\n    } config_set_numerical_field(\n      \"cluster-slave-validity-factor\",server.cluster_slave_validity_factor,0,LLONG_MAX) {\n    } config_set_numerical_field(\n      \"hz\",server.hz,0,LLONG_MAX) {\n        /* Hz is more an hint from the user, so we accept values out of range\n         * but cap them to reasonable values. */\n        if (server.hz < CONFIG_MIN_HZ) server.hz = CONFIG_MIN_HZ;\n        if (server.hz > CONFIG_MAX_HZ) server.hz = CONFIG_MAX_HZ;\n    } config_set_numerical_field(\n      \"watchdog-period\",ll,0,LLONG_MAX) {\n        if (ll)\n            enableWatchdog(ll);\n        else\n            disableWatchdog();\n\n    /* Memory fields.\n     * config_set_memory_field(name,var) */\n    } config_set_memory_field(\"maxmemory\",server.maxmemory) {\n        if (server.maxmemory) {\n            if (server.maxmemory < zmalloc_used_memory()) {\n                serverLog(LL_WARNING,\"WARNING: the new maxmemory value set via CONFIG SET is smaller than the current memory usage. This will result in keys eviction and/or inability to accept new write commands depending on the maxmemory-policy.\");\n            }\n            freeMemoryIfNeeded();\n        }\n    } config_set_memory_field(\"repl-backlog-size\",ll) {\n        resizeReplicationBacklog(ll);\n\n    /* Enumeration fields.\n     * config_set_enum_field(name,var,enum_var) */\n    } config_set_enum_field(\n      \"loglevel\",server.verbosity,loglevel_enum) {\n    } config_set_enum_field(\n      \"maxmemory-policy\",server.maxmemory_policy,maxmemory_policy_enum) {\n    } config_set_enum_field(\n      \"appendfsync\",server.aof_fsync,aof_fsync_enum) {\n\n    /* Everyhing else is an error... */\n    } config_set_else {\n        addReplyErrorFormat(c,\"Unsupported CONFIG parameter: %s\",\n            (char*)c->argv[2]->ptr);\n        return;\n    }\n\n    /* On success we just return a generic OK for all the options. */\n    addReply(c,shared.ok);\n    return;\n\nbadfmt: /* Bad format errors */\n    addReplyErrorFormat(c,\"Invalid argument '%s' for CONFIG SET '%s'\",\n            (char*)o->ptr,\n            (char*)c->argv[2]->ptr);\n}\n\n/*-----------------------------------------------------------------------------\n * CONFIG GET implementation\n *----------------------------------------------------------------------------*/\n\n#define config_get_string_field(_name,_var) do { \\\n    if (stringmatch(pattern,_name,1)) { \\\n        addReplyBulkCString(c,_name); \\\n        addReplyBulkCString(c,_var ? _var : \"\"); \\\n        matches++; \\\n    } \\\n} while(0);\n\n#define config_get_bool_field(_name,_var) do { \\\n    if (stringmatch(pattern,_name,1)) { \\\n        addReplyBulkCString(c,_name); \\\n        addReplyBulkCString(c,_var ? \"yes\" : \"no\"); \\\n        matches++; \\\n    } \\\n} while(0);\n\n#define config_get_numerical_field(_name,_var) do { \\\n    if (stringmatch(pattern,_name,1)) { \\\n        ll2string(buf,sizeof(buf),_var); \\\n        addReplyBulkCString(c,_name); \\\n        addReplyBulkCString(c,buf); \\\n        matches++; \\\n    } \\\n} while(0);\n\n#define config_get_enum_field(_name,_var,_enumvar) do { \\\n    if (stringmatch(pattern,_name,1)) { \\\n        addReplyBulkCString(c,_name); \\\n        addReplyBulkCString(c,configEnumGetNameOrUnknown(_enumvar,_var)); \\\n        matches++; \\\n    } \\\n} while(0);\n\nvoid configGetCommand(client *c) {\n    robj *o = c->argv[2];\n    void *replylen = addDeferredMultiBulkLength(c);\n    char *pattern = o->ptr;\n    char buf[128];\n    int matches = 0;\n    serverAssertWithInfo(c,o,sdsEncodedObject(o));\n\n    /* String values */\n    config_get_string_field(\"dbfilename\",server.rdb_filename);\n    config_get_string_field(\"requirepass\",server.requirepass);\n    config_get_string_field(\"masterauth\",server.masterauth);\n    config_get_string_field(\"cluster-announce-ip\",server.cluster_announce_ip);\n    config_get_string_field(\"unixsocket\",server.unixsocket);\n    config_get_string_field(\"logfile\",server.logfile);\n    config_get_string_field(\"pidfile\",server.pidfile);\n    config_get_string_field(\"slave-announce-ip\",server.slave_announce_ip);\n\n    /* Numerical values */\n    config_get_numerical_field(\"maxmemory\",server.maxmemory);\n    config_get_numerical_field(\"maxmemory-samples\",server.maxmemory_samples);\n    config_get_numerical_field(\"timeout\",server.maxidletime);\n    config_get_numerical_field(\"auto-aof-rewrite-percentage\",\n            server.aof_rewrite_perc);\n    config_get_numerical_field(\"auto-aof-rewrite-min-size\",\n            server.aof_rewrite_min_size);\n    config_get_numerical_field(\"hash-max-ziplist-entries\",\n            server.hash_max_ziplist_entries);\n    config_get_numerical_field(\"hash-max-ziplist-value\",\n            server.hash_max_ziplist_value);\n    config_get_numerical_field(\"list-max-ziplist-size\",\n            server.list_max_ziplist_size);\n    config_get_numerical_field(\"list-compress-depth\",\n            server.list_compress_depth);\n    config_get_numerical_field(\"set-max-intset-entries\",\n            server.set_max_intset_entries);\n    config_get_numerical_field(\"zset-max-ziplist-entries\",\n            server.zset_max_ziplist_entries);\n    config_get_numerical_field(\"zset-max-ziplist-value\",\n            server.zset_max_ziplist_value);\n    config_get_numerical_field(\"hll-sparse-max-bytes\",\n            server.hll_sparse_max_bytes);\n    config_get_numerical_field(\"lua-time-limit\",server.lua_time_limit);\n    config_get_numerical_field(\"slowlog-log-slower-than\",\n            server.slowlog_log_slower_than);\n    config_get_numerical_field(\"latency-monitor-threshold\",\n            server.latency_monitor_threshold);\n    config_get_numerical_field(\"slowlog-max-len\",\n            server.slowlog_max_len);\n    config_get_numerical_field(\"port\",server.port);\n    config_get_numerical_field(\"cluster-announce-port\",server.cluster_announce_port);\n    config_get_numerical_field(\"cluster-announce-bus-port\",server.cluster_announce_bus_port);\n    config_get_numerical_field(\"tcp-backlog\",server.tcp_backlog);\n    config_get_numerical_field(\"databases\",server.dbnum);\n    config_get_numerical_field(\"repl-ping-slave-period\",server.repl_ping_slave_period);\n    config_get_numerical_field(\"repl-timeout\",server.repl_timeout);\n    config_get_numerical_field(\"repl-backlog-size\",server.repl_backlog_size);\n    config_get_numerical_field(\"repl-backlog-ttl\",server.repl_backlog_time_limit);\n    config_get_numerical_field(\"maxclients\",server.maxclients);\n    config_get_numerical_field(\"watchdog-period\",server.watchdog_period);\n    config_get_numerical_field(\"slave-priority\",server.slave_priority);\n    config_get_numerical_field(\"slave-announce-port\",server.slave_announce_port);\n    config_get_numerical_field(\"min-slaves-to-write\",server.repl_min_slaves_to_write);\n    config_get_numerical_field(\"min-slaves-max-lag\",server.repl_min_slaves_max_lag);\n    config_get_numerical_field(\"hz\",server.hz);\n    config_get_numerical_field(\"cluster-node-timeout\",server.cluster_node_timeout);\n    config_get_numerical_field(\"cluster-migration-barrier\",server.cluster_migration_barrier);\n    config_get_numerical_field(\"cluster-slave-validity-factor\",server.cluster_slave_validity_factor);\n    config_get_numerical_field(\"repl-diskless-sync-delay\",server.repl_diskless_sync_delay);\n    config_get_numerical_field(\"tcp-keepalive\",server.tcpkeepalive);\n\n    /* Bool (yes/no) values */\n    config_get_bool_field(\"cluster-require-full-coverage\",\n            server.cluster_require_full_coverage);\n    config_get_bool_field(\"no-appendfsync-on-rewrite\",\n            server.aof_no_fsync_on_rewrite);\n    config_get_bool_field(\"slave-serve-stale-data\",\n            server.repl_serve_stale_data);\n    config_get_bool_field(\"slave-read-only\",\n            server.repl_slave_ro);\n    config_get_bool_field(\"stop-writes-on-bgsave-error\",\n            server.stop_writes_on_bgsave_err);\n    config_get_bool_field(\"daemonize\", server.daemonize);\n    config_get_bool_field(\"rdbcompression\", server.rdb_compression);\n    config_get_bool_field(\"rdbchecksum\", server.rdb_checksum);\n    config_get_bool_field(\"activerehashing\", server.activerehashing);\n    config_get_bool_field(\"protected-mode\", server.protected_mode);\n    config_get_bool_field(\"repl-disable-tcp-nodelay\",\n            server.repl_disable_tcp_nodelay);\n    config_get_bool_field(\"repl-diskless-sync\",\n            server.repl_diskless_sync);\n    config_get_bool_field(\"aof-rewrite-incremental-fsync\",\n            server.aof_rewrite_incremental_fsync);\n    config_get_bool_field(\"aof-load-truncated\",\n            server.aof_load_truncated);\n    config_get_bool_field(\"aof-use-rdb-preamble\",\n            server.aof_use_rdb_preamble);\n    config_get_bool_field(\"lazyfree-lazy-eviction\",\n            server.lazyfree_lazy_eviction);\n    config_get_bool_field(\"lazyfree-lazy-expire\",\n            server.lazyfree_lazy_expire);\n    config_get_bool_field(\"lazyfree-lazy-server-del\",\n            server.lazyfree_lazy_server_del);\n    config_get_bool_field(\"slave-lazy-flush\",\n            server.repl_slave_lazy_flush);\n\n    /* Enum values */\n    config_get_enum_field(\"maxmemory-policy\",\n            server.maxmemory_policy,maxmemory_policy_enum);\n    config_get_enum_field(\"loglevel\",\n            server.verbosity,loglevel_enum);\n    config_get_enum_field(\"supervised\",\n            server.supervised_mode,supervised_mode_enum);\n    config_get_enum_field(\"appendfsync\",\n            server.aof_fsync,aof_fsync_enum);\n    config_get_enum_field(\"syslog-facility\",\n            server.syslog_facility,syslog_facility_enum);\n\n    /* Everything we can't handle with macros follows. */\n\n    if (stringmatch(pattern,\"appendonly\",1)) {\n        addReplyBulkCString(c,\"appendonly\");\n        addReplyBulkCString(c,server.aof_state == AOF_OFF ? \"no\" : \"yes\");\n        matches++;\n    }\n    if (stringmatch(pattern,\"dir\",1)) {\n        char buf[1024];\n\n        if (getcwd(buf,sizeof(buf)) == NULL)\n            buf[0] = '\\0';\n\n        addReplyBulkCString(c,\"dir\");\n        addReplyBulkCString(c,buf);\n        matches++;\n    }\n    if (stringmatch(pattern,\"save\",1)) {\n        sds buf = sdsempty();\n        int j;\n\n        for (j = 0; j < server.saveparamslen; j++) {\n            buf = sdscatprintf(buf,\"%jd %d\",\n                    (intmax_t)server.saveparams[j].seconds,\n                    server.saveparams[j].changes);\n            if (j != server.saveparamslen-1)\n                buf = sdscatlen(buf,\" \",1);\n        }\n        addReplyBulkCString(c,\"save\");\n        addReplyBulkCString(c,buf);\n        sdsfree(buf);\n        matches++;\n    }\n    if (stringmatch(pattern,\"client-output-buffer-limit\",1)) {\n        sds buf = sdsempty();\n        int j;\n\n        for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++) {\n            buf = sdscatprintf(buf,\"%s %llu %llu %ld\",\n                    getClientTypeName(j),\n                    server.client_obuf_limits[j].hard_limit_bytes,\n                    server.client_obuf_limits[j].soft_limit_bytes,\n                    (long) server.client_obuf_limits[j].soft_limit_seconds);\n            if (j != CLIENT_TYPE_OBUF_COUNT-1)\n                buf = sdscatlen(buf,\" \",1);\n        }\n        addReplyBulkCString(c,\"client-output-buffer-limit\");\n        addReplyBulkCString(c,buf);\n        sdsfree(buf);\n        matches++;\n    }\n    if (stringmatch(pattern,\"unixsocketperm\",1)) {\n        char buf[32];\n        snprintf(buf,sizeof(buf),\"%o\",server.unixsocketperm);\n        addReplyBulkCString(c,\"unixsocketperm\");\n        addReplyBulkCString(c,buf);\n        matches++;\n    }\n    if (stringmatch(pattern,\"slaveof\",1)) {\n        char buf[256];\n\n        addReplyBulkCString(c,\"slaveof\");\n        if (server.masterhost)\n            snprintf(buf,sizeof(buf),\"%s %d\",\n                server.masterhost, server.masterport);\n        else\n            buf[0] = '\\0';\n        addReplyBulkCString(c,buf);\n        matches++;\n    }\n    if (stringmatch(pattern,\"notify-keyspace-events\",1)) {\n        robj *flagsobj = createObject(OBJ_STRING,\n            keyspaceEventsFlagsToString(server.notify_keyspace_events));\n\n        addReplyBulkCString(c,\"notify-keyspace-events\");\n        addReplyBulk(c,flagsobj);\n        decrRefCount(flagsobj);\n        matches++;\n    }\n    if (stringmatch(pattern,\"bind\",1)) {\n        sds aux = sdsjoin(server.bindaddr,server.bindaddr_count,\" \");\n\n        addReplyBulkCString(c,\"bind\");\n        addReplyBulkCString(c,aux);\n        sdsfree(aux);\n        matches++;\n    }\n    setDeferredMultiBulkLength(c,replylen,matches*2);\n}\n\n/*-----------------------------------------------------------------------------\n * CONFIG REWRITE implementation\n *----------------------------------------------------------------------------*/\n\n#define REDIS_CONFIG_REWRITE_SIGNATURE \"# Generated by CONFIG REWRITE\"\n\n/* We use the following dictionary type to store where a configuration\n * option is mentioned in the old configuration file, so it's\n * like \"maxmemory\" -> list of line numbers (first line is zero). */\nunsigned int dictSdsCaseHash(const void *key);\nint dictSdsKeyCaseCompare(void *privdata, const void *key1, const void *key2);\nvoid dictSdsDestructor(void *privdata, void *val);\nvoid dictListDestructor(void *privdata, void *val);\n\n/* Sentinel config rewriting is implemented inside sentinel.c by\n * rewriteConfigSentinelOption(). */\nvoid rewriteConfigSentinelOption(struct rewriteConfigState *state);\n\ndictType optionToLineDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    dictListDestructor          /* val destructor */\n};\n\ndictType optionSetDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL                        /* val destructor */\n};\n\n/* The config rewrite state. */\nstruct rewriteConfigState {\n    dict *option_to_line; /* Option -> list of config file lines map */\n    dict *rewritten;      /* Dictionary of already processed options */\n    int numlines;         /* Number of lines in current config */\n    sds *lines;           /* Current lines as an array of sds strings */\n    int has_tail;         /* True if we already added directives that were\n                             not present in the original config file. */\n};\n\n/* Append the new line to the current configuration state. */\nvoid rewriteConfigAppendLine(struct rewriteConfigState *state, sds line) {\n    state->lines = zrealloc(state->lines, sizeof(char*) * (state->numlines+1));\n    state->lines[state->numlines++] = line;\n}\n\n/* Populate the option -> list of line numbers map. */\nvoid rewriteConfigAddLineNumberToOption(struct rewriteConfigState *state, sds option, int linenum) {\n    list *l = dictFetchValue(state->option_to_line,option);\n\n    if (l == NULL) {\n        l = listCreate();\n        dictAdd(state->option_to_line,sdsdup(option),l);\n    }\n    listAddNodeTail(l,(void*)(long)linenum);\n}\n\n/* Add the specified option to the set of processed options.\n * This is useful as only unused lines of processed options will be blanked\n * in the config file, while options the rewrite process does not understand\n * remain untouched. */\nvoid rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, const char *option) {\n    sds opt = sdsnew(option);\n\n    if (dictAdd(state->rewritten,opt,NULL) != DICT_OK) sdsfree(opt);\n}\n\n/* Read the old file, split it into lines to populate a newly created\n * config rewrite state, and return it to the caller.\n *\n * If it is impossible to read the old file, NULL is returned.\n * If the old file does not exist at all, an empty state is returned. */\nstruct rewriteConfigState *rewriteConfigReadOldFile(char *path) {\n    FILE *fp = fopen(path,\"r\");\n    struct rewriteConfigState *state = zmalloc(sizeof(*state));\n    char buf[CONFIG_MAX_LINE+1];\n    int linenum = -1;\n\n    if (fp == NULL && errno != ENOENT) return NULL;\n\n    state->option_to_line = dictCreate(&optionToLineDictType,NULL);\n    state->rewritten = dictCreate(&optionSetDictType,NULL);\n    state->numlines = 0;\n    state->lines = NULL;\n    state->has_tail = 0;\n    if (fp == NULL) return state;\n\n    /* Read the old file line by line, populate the state. */\n    while(fgets(buf,CONFIG_MAX_LINE+1,fp) != NULL) {\n        int argc;\n        sds *argv;\n        sds line = sdstrim(sdsnew(buf),\"\\r\\n\\t \");\n\n        linenum++; /* Zero based, so we init at -1 */\n\n        /* Handle comments and empty lines. */\n        if (line[0] == '#' || line[0] == '\\0') {\n            if (!state->has_tail && !strcmp(line,REDIS_CONFIG_REWRITE_SIGNATURE))\n                state->has_tail = 1;\n            rewriteConfigAppendLine(state,line);\n            continue;\n        }\n\n        /* Not a comment, split into arguments. */\n        argv = sdssplitargs(line,&argc);\n        if (argv == NULL) {\n            /* Apparently the line is unparsable for some reason, for\n             * instance it may have unbalanced quotes. Load it as a\n             * comment. */\n            sds aux = sdsnew(\"# ??? \");\n            aux = sdscatsds(aux,line);\n            sdsfree(line);\n            rewriteConfigAppendLine(state,aux);\n            continue;\n        }\n\n        sdstolower(argv[0]); /* We only want lowercase config directives. */\n\n        /* Now we populate the state according to the content of this line.\n         * Append the line and populate the option -> line numbers map. */\n        rewriteConfigAppendLine(state,line);\n        rewriteConfigAddLineNumberToOption(state,argv[0],linenum);\n\n        sdsfreesplitres(argv,argc);\n    }\n    fclose(fp);\n    return state;\n}\n\n/* Rewrite the specified configuration option with the new \"line\".\n * It progressively uses lines of the file that were already used for the same\n * configuration option in the old version of the file, removing that line from\n * the map of options -> line numbers.\n *\n * If there are lines associated with a given configuration option and\n * \"force\" is non-zero, the line is appended to the configuration file.\n * Usually \"force\" is true when an option has not its default value, so it\n * must be rewritten even if not present previously.\n *\n * The first time a line is appended into a configuration file, a comment\n * is added to show that starting from that point the config file was generated\n * by CONFIG REWRITE.\n *\n * \"line\" is either used, or freed, so the caller does not need to free it\n * in any way. */\nvoid rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *option, sds line, int force) {\n    sds o = sdsnew(option);\n    list *l = dictFetchValue(state->option_to_line,o);\n\n    rewriteConfigMarkAsProcessed(state,option);\n\n    if (!l && !force) {\n        /* Option not used previously, and we are not forced to use it. */\n        sdsfree(line);\n        sdsfree(o);\n        return;\n    }\n\n    if (l) {\n        listNode *ln = listFirst(l);\n        int linenum = (long) ln->value;\n\n        /* There are still lines in the old configuration file we can reuse\n         * for this option. Replace the line with the new one. */\n        listDelNode(l,ln);\n        if (listLength(l) == 0) dictDelete(state->option_to_line,o);\n        sdsfree(state->lines[linenum]);\n        state->lines[linenum] = line;\n    } else {\n        /* Append a new line. */\n        if (!state->has_tail) {\n            rewriteConfigAppendLine(state,\n                sdsnew(REDIS_CONFIG_REWRITE_SIGNATURE));\n            state->has_tail = 1;\n        }\n        rewriteConfigAppendLine(state,line);\n    }\n    sdsfree(o);\n}\n\n/* Write the long long 'bytes' value as a string in a way that is parsable\n * inside redis.conf. If possible uses the GB, MB, KB notation. */\nint rewriteConfigFormatMemory(char *buf, size_t len, long long bytes) {\n    int gb = 1024*1024*1024;\n    int mb = 1024*1024;\n    int kb = 1024;\n\n    if (bytes && (bytes % gb) == 0) {\n        return snprintf(buf,len,\"%lldgb\",bytes/gb);\n    } else if (bytes && (bytes % mb) == 0) {\n        return snprintf(buf,len,\"%lldmb\",bytes/mb);\n    } else if (bytes && (bytes % kb) == 0) {\n        return snprintf(buf,len,\"%lldkb\",bytes/kb);\n    } else {\n        return snprintf(buf,len,\"%lld\",bytes);\n    }\n}\n\n/* Rewrite a simple \"option-name <bytes>\" configuration option. */\nvoid rewriteConfigBytesOption(struct rewriteConfigState *state, char *option, long long value, long long defvalue) {\n    char buf[64];\n    int force = value != defvalue;\n    sds line;\n\n    rewriteConfigFormatMemory(buf,sizeof(buf),value);\n    line = sdscatprintf(sdsempty(),\"%s %s\",option,buf);\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite a yes/no option. */\nvoid rewriteConfigYesNoOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {\n    int force = value != defvalue;\n    sds line = sdscatprintf(sdsempty(),\"%s %s\",option,\n        value ? \"yes\" : \"no\");\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite a string option. */\nvoid rewriteConfigStringOption(struct rewriteConfigState *state, char *option, char *value, char *defvalue) {\n    int force = 1;\n    sds line;\n\n    /* String options set to NULL need to be not present at all in the\n     * configuration file to be set to NULL again at the next reboot. */\n    if (value == NULL) {\n        rewriteConfigMarkAsProcessed(state,option);\n        return;\n    }\n\n    /* Set force to zero if the value is set to its default. */\n    if (defvalue && strcmp(value,defvalue) == 0) force = 0;\n\n    line = sdsnew(option);\n    line = sdscatlen(line, \" \", 1);\n    line = sdscatrepr(line, value, strlen(value));\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite a numerical (long long range) option. */\nvoid rewriteConfigNumericalOption(struct rewriteConfigState *state, char *option, long long value, long long defvalue) {\n    int force = value != defvalue;\n    sds line = sdscatprintf(sdsempty(),\"%s %lld\",option,value);\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite a octal option. */\nvoid rewriteConfigOctalOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {\n    int force = value != defvalue;\n    sds line = sdscatprintf(sdsempty(),\"%s %o\",option,value);\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite an enumeration option. It takes as usually state and option name,\n * and in addition the enumeration array and the default value for the\n * option. */\nvoid rewriteConfigEnumOption(struct rewriteConfigState *state, char *option, int value, configEnum *ce, int defval) {\n    sds line;\n    const char *name = configEnumGetNameOrUnknown(ce,value);\n    int force = value != defval;\n\n    line = sdscatprintf(sdsempty(),\"%s %s\",option,name);\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite the syslog-facility option. */\nvoid rewriteConfigSyslogfacilityOption(struct rewriteConfigState *state) {\n    int value = server.syslog_facility;\n    int force = value != LOG_LOCAL0;\n    const char *name = NULL, *option = \"syslog-facility\";\n    sds line;\n\n    name = configEnumGetNameOrUnknown(syslog_facility_enum,value);\n    line = sdscatprintf(sdsempty(),\"%s %s\",option,name);\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite the save option. */\nvoid rewriteConfigSaveOption(struct rewriteConfigState *state) {\n    int j;\n    sds line;\n\n    /* Note that if there are no save parameters at all, all the current\n     * config line with \"save\" will be detected as orphaned and deleted,\n     * resulting into no RDB persistence as expected. */\n    for (j = 0; j < server.saveparamslen; j++) {\n        line = sdscatprintf(sdsempty(),\"save %ld %d\",\n            (long) server.saveparams[j].seconds, server.saveparams[j].changes);\n        rewriteConfigRewriteLine(state,\"save\",line,1);\n    }\n    /* Mark \"save\" as processed in case server.saveparamslen is zero. */\n    rewriteConfigMarkAsProcessed(state,\"save\");\n}\n\n/* Rewrite the dir option, always using absolute paths.*/\nvoid rewriteConfigDirOption(struct rewriteConfigState *state) {\n    char cwd[1024];\n\n    if (getcwd(cwd,sizeof(cwd)) == NULL) {\n        rewriteConfigMarkAsProcessed(state,\"dir\");\n        return; /* no rewrite on error. */\n    }\n    rewriteConfigStringOption(state,\"dir\",cwd,NULL);\n}\n\n/* Rewrite the slaveof option. */\nvoid rewriteConfigSlaveofOption(struct rewriteConfigState *state) {\n    char *option = \"slaveof\";\n    sds line;\n\n    /* If this is a master, we want all the slaveof config options\n     * in the file to be removed. Note that if this is a cluster instance\n     * we don't want a slaveof directive inside redis.conf. */\n    if (server.cluster_enabled || server.masterhost == NULL) {\n        rewriteConfigMarkAsProcessed(state,\"slaveof\");\n        return;\n    }\n    line = sdscatprintf(sdsempty(),\"%s %s %d\", option,\n        server.masterhost, server.masterport);\n    rewriteConfigRewriteLine(state,option,line,1);\n}\n\n/* Rewrite the notify-keyspace-events option. */\nvoid rewriteConfigNotifykeyspaceeventsOption(struct rewriteConfigState *state) {\n    int force = server.notify_keyspace_events != 0;\n    char *option = \"notify-keyspace-events\";\n    sds line, flags;\n\n    flags = keyspaceEventsFlagsToString(server.notify_keyspace_events);\n    line = sdsnew(option);\n    line = sdscatlen(line, \" \", 1);\n    line = sdscatrepr(line, flags, sdslen(flags));\n    sdsfree(flags);\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Rewrite the client-output-buffer-limit option. */\nvoid rewriteConfigClientoutputbufferlimitOption(struct rewriteConfigState *state) {\n    int j;\n    char *option = \"client-output-buffer-limit\";\n\n    for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++) {\n        int force = (server.client_obuf_limits[j].hard_limit_bytes !=\n                    clientBufferLimitsDefaults[j].hard_limit_bytes) ||\n                    (server.client_obuf_limits[j].soft_limit_bytes !=\n                    clientBufferLimitsDefaults[j].soft_limit_bytes) ||\n                    (server.client_obuf_limits[j].soft_limit_seconds !=\n                    clientBufferLimitsDefaults[j].soft_limit_seconds);\n        sds line;\n        char hard[64], soft[64];\n\n        rewriteConfigFormatMemory(hard,sizeof(hard),\n                server.client_obuf_limits[j].hard_limit_bytes);\n        rewriteConfigFormatMemory(soft,sizeof(soft),\n                server.client_obuf_limits[j].soft_limit_bytes);\n\n        line = sdscatprintf(sdsempty(),\"%s %s %s %s %ld\",\n                option, getClientTypeName(j), hard, soft,\n                (long) server.client_obuf_limits[j].soft_limit_seconds);\n        rewriteConfigRewriteLine(state,option,line,force);\n    }\n}\n\n/* Rewrite the bind option. */\nvoid rewriteConfigBindOption(struct rewriteConfigState *state) {\n    int force = 1;\n    sds line, addresses;\n    char *option = \"bind\";\n\n    /* Nothing to rewrite if we don't have bind addresses. */\n    if (server.bindaddr_count == 0) {\n        rewriteConfigMarkAsProcessed(state,option);\n        return;\n    }\n\n    /* Rewrite as bind <addr1> <addr2> ... <addrN> */\n    addresses = sdsjoin(server.bindaddr,server.bindaddr_count,\" \");\n    line = sdsnew(option);\n    line = sdscatlen(line, \" \", 1);\n    line = sdscatsds(line, addresses);\n    sdsfree(addresses);\n\n    rewriteConfigRewriteLine(state,option,line,force);\n}\n\n/* Glue together the configuration lines in the current configuration\n * rewrite state into a single string, stripping multiple empty lines. */\nsds rewriteConfigGetContentFromState(struct rewriteConfigState *state) {\n    sds content = sdsempty();\n    int j, was_empty = 0;\n\n    for (j = 0; j < state->numlines; j++) {\n        /* Every cluster of empty lines is turned into a single empty line. */\n        if (sdslen(state->lines[j]) == 0) {\n            if (was_empty) continue;\n            was_empty = 1;\n        } else {\n            was_empty = 0;\n        }\n        content = sdscatsds(content,state->lines[j]);\n        content = sdscatlen(content,\"\\n\",1);\n    }\n    return content;\n}\n\n/* Free the configuration rewrite state. */\nvoid rewriteConfigReleaseState(struct rewriteConfigState *state) {\n    sdsfreesplitres(state->lines,state->numlines);\n    dictRelease(state->option_to_line);\n    dictRelease(state->rewritten);\n    zfree(state);\n}\n\n/* At the end of the rewrite process the state contains the remaining\n * map between \"option name\" => \"lines in the original config file\".\n * Lines used by the rewrite process were removed by the function\n * rewriteConfigRewriteLine(), all the other lines are \"orphaned\" and\n * should be replaced by empty lines.\n *\n * This function does just this, iterating all the option names and\n * blanking all the lines still associated. */\nvoid rewriteConfigRemoveOrphaned(struct rewriteConfigState *state) {\n    dictIterator *di = dictGetIterator(state->option_to_line);\n    dictEntry *de;\n\n    while((de = dictNext(di)) != NULL) {\n        list *l = dictGetVal(de);\n        sds option = dictGetKey(de);\n\n        /* Don't blank lines about options the rewrite process\n         * don't understand. */\n        if (dictFind(state->rewritten,option) == NULL) {\n            serverLog(LL_DEBUG,\"Not rewritten option: %s\", option);\n            continue;\n        }\n\n        while(listLength(l)) {\n            listNode *ln = listFirst(l);\n            int linenum = (long) ln->value;\n\n            sdsfree(state->lines[linenum]);\n            state->lines[linenum] = sdsempty();\n            listDelNode(l,ln);\n        }\n    }\n    dictReleaseIterator(di);\n}\n\n/* This function overwrites the old configuration file with the new content.\n *\n * 1) The old file length is obtained.\n * 2) If the new content is smaller, padding is added.\n * 3) A single write(2) call is used to replace the content of the file.\n * 4) Later the file is truncated to the length of the new content.\n *\n * This way we are sure the file is left in a consistent state even if the\n * process is stopped between any of the four operations.\n *\n * The function returns 0 on success, otherwise -1 is returned and errno\n * set accordingly. */\nint rewriteConfigOverwriteFile(char *configfile, sds content) {\n    int retval = 0;\n    int fd = open(configfile,O_RDWR|O_CREAT,0644);\n    int content_size = sdslen(content), padding = 0;\n    struct stat sb;\n    sds content_padded;\n\n    /* 1) Open the old file (or create a new one if it does not\n     *    exist), get the size. */\n    if (fd == -1) return -1; /* errno set by open(). */\n    if (fstat(fd,&sb) == -1) {\n        close(fd);\n        return -1; /* errno set by fstat(). */\n    }\n\n    /* 2) Pad the content at least match the old file size. */\n    content_padded = sdsdup(content);\n    if (content_size < sb.st_size) {\n        /* If the old file was bigger, pad the content with\n         * a newline plus as many \"#\" chars as required. */\n        padding = sb.st_size - content_size;\n        content_padded = sdsgrowzero(content_padded,sb.st_size);\n        content_padded[content_size] = '\\n';\n        memset(content_padded+content_size+1,'#',padding-1);\n    }\n\n    /* 3) Write the new content using a single write(2). */\n    if (write(fd,content_padded,strlen(content_padded)) == -1) {\n        retval = -1;\n        goto cleanup;\n    }\n\n    /* 4) Truncate the file to the right length if we used padding. */\n    if (padding) {\n        if (ftruncate(fd,content_size) == -1) {\n            /* Non critical error... */\n        }\n    }\n\ncleanup:\n    sdsfree(content_padded);\n    close(fd);\n    return retval;\n}\n\n/* Rewrite the configuration file at \"path\".\n * If the configuration file already exists, we try at best to retain comments\n * and overall structure.\n *\n * Configuration parameters that are at their default value, unless already\n * explicitly included in the old configuration file, are not rewritten.\n *\n * On error -1 is returned and errno is set accordingly, otherwise 0. */\nint rewriteConfig(char *path) {\n    struct rewriteConfigState *state;\n    sds newcontent;\n    int retval;\n\n    /* Step 1: read the old config into our rewrite state. */\n    if ((state = rewriteConfigReadOldFile(path)) == NULL) return -1;\n\n    /* Step 2: rewrite every single option, replacing or appending it inside\n     * the rewrite state. */\n\n    rewriteConfigYesNoOption(state,\"daemonize\",server.daemonize,0);\n    rewriteConfigStringOption(state,\"pidfile\",server.pidfile,CONFIG_DEFAULT_PID_FILE);\n    rewriteConfigNumericalOption(state,\"port\",server.port,CONFIG_DEFAULT_SERVER_PORT);\n    rewriteConfigNumericalOption(state,\"cluster-announce-port\",server.cluster_announce_port,CONFIG_DEFAULT_CLUSTER_ANNOUNCE_PORT);\n    rewriteConfigNumericalOption(state,\"cluster-announce-bus-port\",server.cluster_announce_bus_port,CONFIG_DEFAULT_CLUSTER_ANNOUNCE_BUS_PORT);\n    rewriteConfigNumericalOption(state,\"tcp-backlog\",server.tcp_backlog,CONFIG_DEFAULT_TCP_BACKLOG);\n    rewriteConfigBindOption(state);\n    rewriteConfigStringOption(state,\"unixsocket\",server.unixsocket,NULL);\n    rewriteConfigOctalOption(state,\"unixsocketperm\",server.unixsocketperm,CONFIG_DEFAULT_UNIX_SOCKET_PERM);\n    rewriteConfigNumericalOption(state,\"timeout\",server.maxidletime,CONFIG_DEFAULT_CLIENT_TIMEOUT);\n    rewriteConfigNumericalOption(state,\"tcp-keepalive\",server.tcpkeepalive,CONFIG_DEFAULT_TCP_KEEPALIVE);\n    rewriteConfigNumericalOption(state,\"slave-announce-port\",server.slave_announce_port,CONFIG_DEFAULT_SLAVE_ANNOUNCE_PORT);\n    rewriteConfigEnumOption(state,\"loglevel\",server.verbosity,loglevel_enum,CONFIG_DEFAULT_VERBOSITY);\n    rewriteConfigStringOption(state,\"logfile\",server.logfile,CONFIG_DEFAULT_LOGFILE);\n    rewriteConfigYesNoOption(state,\"syslog-enabled\",server.syslog_enabled,CONFIG_DEFAULT_SYSLOG_ENABLED);\n    rewriteConfigStringOption(state,\"syslog-ident\",server.syslog_ident,CONFIG_DEFAULT_SYSLOG_IDENT);\n    rewriteConfigSyslogfacilityOption(state);\n    rewriteConfigSaveOption(state);\n    rewriteConfigNumericalOption(state,\"databases\",server.dbnum,CONFIG_DEFAULT_DBNUM);\n    rewriteConfigYesNoOption(state,\"stop-writes-on-bgsave-error\",server.stop_writes_on_bgsave_err,CONFIG_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR);\n    rewriteConfigYesNoOption(state,\"rdbcompression\",server.rdb_compression,CONFIG_DEFAULT_RDB_COMPRESSION);\n    rewriteConfigYesNoOption(state,\"rdbchecksum\",server.rdb_checksum,CONFIG_DEFAULT_RDB_CHECKSUM);\n    rewriteConfigStringOption(state,\"dbfilename\",server.rdb_filename,CONFIG_DEFAULT_RDB_FILENAME);\n    rewriteConfigDirOption(state);\n    rewriteConfigSlaveofOption(state);\n    rewriteConfigStringOption(state,\"slave-announce-ip\",server.slave_announce_ip,CONFIG_DEFAULT_SLAVE_ANNOUNCE_IP);\n    rewriteConfigStringOption(state,\"masterauth\",server.masterauth,NULL);\n    rewriteConfigStringOption(state,\"cluster-announce-ip\",server.cluster_announce_ip,NULL);\n    rewriteConfigYesNoOption(state,\"slave-serve-stale-data\",server.repl_serve_stale_data,CONFIG_DEFAULT_SLAVE_SERVE_STALE_DATA);\n    rewriteConfigYesNoOption(state,\"slave-read-only\",server.repl_slave_ro,CONFIG_DEFAULT_SLAVE_READ_ONLY);\n    rewriteConfigNumericalOption(state,\"repl-ping-slave-period\",server.repl_ping_slave_period,CONFIG_DEFAULT_REPL_PING_SLAVE_PERIOD);\n    rewriteConfigNumericalOption(state,\"repl-timeout\",server.repl_timeout,CONFIG_DEFAULT_REPL_TIMEOUT);\n    rewriteConfigBytesOption(state,\"repl-backlog-size\",server.repl_backlog_size,CONFIG_DEFAULT_REPL_BACKLOG_SIZE);\n    rewriteConfigBytesOption(state,\"repl-backlog-ttl\",server.repl_backlog_time_limit,CONFIG_DEFAULT_REPL_BACKLOG_TIME_LIMIT);\n    rewriteConfigYesNoOption(state,\"repl-disable-tcp-nodelay\",server.repl_disable_tcp_nodelay,CONFIG_DEFAULT_REPL_DISABLE_TCP_NODELAY);\n    rewriteConfigYesNoOption(state,\"repl-diskless-sync\",server.repl_diskless_sync,CONFIG_DEFAULT_REPL_DISKLESS_SYNC);\n    rewriteConfigNumericalOption(state,\"repl-diskless-sync-delay\",server.repl_diskless_sync_delay,CONFIG_DEFAULT_REPL_DISKLESS_SYNC_DELAY);\n    rewriteConfigNumericalOption(state,\"slave-priority\",server.slave_priority,CONFIG_DEFAULT_SLAVE_PRIORITY);\n    rewriteConfigNumericalOption(state,\"min-slaves-to-write\",server.repl_min_slaves_to_write,CONFIG_DEFAULT_MIN_SLAVES_TO_WRITE);\n    rewriteConfigNumericalOption(state,\"min-slaves-max-lag\",server.repl_min_slaves_max_lag,CONFIG_DEFAULT_MIN_SLAVES_MAX_LAG);\n    rewriteConfigStringOption(state,\"requirepass\",server.requirepass,NULL);\n    rewriteConfigNumericalOption(state,\"maxclients\",server.maxclients,CONFIG_DEFAULT_MAX_CLIENTS);\n    rewriteConfigBytesOption(state,\"maxmemory\",server.maxmemory,CONFIG_DEFAULT_MAXMEMORY);\n    rewriteConfigEnumOption(state,\"maxmemory-policy\",server.maxmemory_policy,maxmemory_policy_enum,CONFIG_DEFAULT_MAXMEMORY_POLICY);\n    rewriteConfigNumericalOption(state,\"maxmemory-samples\",server.maxmemory_samples,CONFIG_DEFAULT_MAXMEMORY_SAMPLES);\n    rewriteConfigYesNoOption(state,\"appendonly\",server.aof_state != AOF_OFF,0);\n    rewriteConfigStringOption(state,\"appendfilename\",server.aof_filename,CONFIG_DEFAULT_AOF_FILENAME);\n    rewriteConfigEnumOption(state,\"appendfsync\",server.aof_fsync,aof_fsync_enum,CONFIG_DEFAULT_AOF_FSYNC);\n    rewriteConfigYesNoOption(state,\"no-appendfsync-on-rewrite\",server.aof_no_fsync_on_rewrite,CONFIG_DEFAULT_AOF_NO_FSYNC_ON_REWRITE);\n    rewriteConfigNumericalOption(state,\"auto-aof-rewrite-percentage\",server.aof_rewrite_perc,AOF_REWRITE_PERC);\n    rewriteConfigBytesOption(state,\"auto-aof-rewrite-min-size\",server.aof_rewrite_min_size,AOF_REWRITE_MIN_SIZE);\n    rewriteConfigNumericalOption(state,\"lua-time-limit\",server.lua_time_limit,LUA_SCRIPT_TIME_LIMIT);\n    rewriteConfigYesNoOption(state,\"cluster-enabled\",server.cluster_enabled,0);\n    rewriteConfigStringOption(state,\"cluster-config-file\",server.cluster_configfile,CONFIG_DEFAULT_CLUSTER_CONFIG_FILE);\n    rewriteConfigYesNoOption(state,\"cluster-require-full-coverage\",server.cluster_require_full_coverage,CLUSTER_DEFAULT_REQUIRE_FULL_COVERAGE);\n    rewriteConfigNumericalOption(state,\"cluster-node-timeout\",server.cluster_node_timeout,CLUSTER_DEFAULT_NODE_TIMEOUT);\n    rewriteConfigNumericalOption(state,\"cluster-migration-barrier\",server.cluster_migration_barrier,CLUSTER_DEFAULT_MIGRATION_BARRIER);\n    rewriteConfigNumericalOption(state,\"cluster-slave-validity-factor\",server.cluster_slave_validity_factor,CLUSTER_DEFAULT_SLAVE_VALIDITY);\n    rewriteConfigNumericalOption(state,\"slowlog-log-slower-than\",server.slowlog_log_slower_than,CONFIG_DEFAULT_SLOWLOG_LOG_SLOWER_THAN);\n    rewriteConfigNumericalOption(state,\"latency-monitor-threshold\",server.latency_monitor_threshold,CONFIG_DEFAULT_LATENCY_MONITOR_THRESHOLD);\n    rewriteConfigNumericalOption(state,\"slowlog-max-len\",server.slowlog_max_len,CONFIG_DEFAULT_SLOWLOG_MAX_LEN);\n    rewriteConfigNotifykeyspaceeventsOption(state);\n    rewriteConfigNumericalOption(state,\"hash-max-ziplist-entries\",server.hash_max_ziplist_entries,OBJ_HASH_MAX_ZIPLIST_ENTRIES);\n    rewriteConfigNumericalOption(state,\"hash-max-ziplist-value\",server.hash_max_ziplist_value,OBJ_HASH_MAX_ZIPLIST_VALUE);\n    rewriteConfigNumericalOption(state,\"list-max-ziplist-size\",server.list_max_ziplist_size,OBJ_LIST_MAX_ZIPLIST_SIZE);\n    rewriteConfigNumericalOption(state,\"list-compress-depth\",server.list_compress_depth,OBJ_LIST_COMPRESS_DEPTH);\n    rewriteConfigNumericalOption(state,\"set-max-intset-entries\",server.set_max_intset_entries,OBJ_SET_MAX_INTSET_ENTRIES);\n    rewriteConfigNumericalOption(state,\"zset-max-ziplist-entries\",server.zset_max_ziplist_entries,OBJ_ZSET_MAX_ZIPLIST_ENTRIES);\n    rewriteConfigNumericalOption(state,\"zset-max-ziplist-value\",server.zset_max_ziplist_value,OBJ_ZSET_MAX_ZIPLIST_VALUE);\n    rewriteConfigNumericalOption(state,\"hll-sparse-max-bytes\",server.hll_sparse_max_bytes,CONFIG_DEFAULT_HLL_SPARSE_MAX_BYTES);\n    rewriteConfigYesNoOption(state,\"activerehashing\",server.activerehashing,CONFIG_DEFAULT_ACTIVE_REHASHING);\n    rewriteConfigYesNoOption(state,\"protected-mode\",server.protected_mode,CONFIG_DEFAULT_PROTECTED_MODE);\n    rewriteConfigClientoutputbufferlimitOption(state);\n    rewriteConfigNumericalOption(state,\"hz\",server.hz,CONFIG_DEFAULT_HZ);\n    rewriteConfigYesNoOption(state,\"aof-rewrite-incremental-fsync\",server.aof_rewrite_incremental_fsync,CONFIG_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC);\n    rewriteConfigYesNoOption(state,\"aof-load-truncated\",server.aof_load_truncated,CONFIG_DEFAULT_AOF_LOAD_TRUNCATED);\n    rewriteConfigYesNoOption(state,\"aof-use-rdb-preamble\",server.aof_use_rdb_preamble,CONFIG_DEFAULT_AOF_USE_RDB_PREAMBLE);\n    rewriteConfigEnumOption(state,\"supervised\",server.supervised_mode,supervised_mode_enum,SUPERVISED_NONE);\n    rewriteConfigYesNoOption(state,\"lazyfree-lazy-eviction\",server.lazyfree_lazy_eviction,CONFIG_DEFAULT_LAZYFREE_LAZY_EVICTION);\n    rewriteConfigYesNoOption(state,\"lazyfree-lazy-expire\",server.lazyfree_lazy_expire,CONFIG_DEFAULT_LAZYFREE_LAZY_EXPIRE);\n    rewriteConfigYesNoOption(state,\"lazyfree-lazy-server-del\",server.lazyfree_lazy_server_del,CONFIG_DEFAULT_LAZYFREE_LAZY_SERVER_DEL);\n    rewriteConfigYesNoOption(state,\"slave-lazy-flush\",server.repl_slave_lazy_flush,CONFIG_DEFAULT_SLAVE_LAZY_FLUSH);\n\n    /* Rewrite Sentinel config if in Sentinel mode. */\n    if (server.sentinel_mode) rewriteConfigSentinelOption(state);\n\n    /* Step 3: remove all the orphaned lines in the old file, that is, lines\n     * that were used by a config option and are no longer used, like in case\n     * of multiple \"save\" options or duplicated options. */\n    rewriteConfigRemoveOrphaned(state);\n\n    /* Step 4: generate a new configuration file from the modified state\n     * and write it into the original file. */\n    newcontent = rewriteConfigGetContentFromState(state);\n    retval = rewriteConfigOverwriteFile(server.configfile,newcontent);\n\n    sdsfree(newcontent);\n    rewriteConfigReleaseState(state);\n    return retval;\n}\n\n/*-----------------------------------------------------------------------------\n * CONFIG command entry point\n *----------------------------------------------------------------------------*/\n\nvoid configCommand(client *c) {\n    /* Only allow CONFIG GET while loading. */\n    if (server.loading && strcasecmp(c->argv[1]->ptr,\"get\")) {\n        addReplyError(c,\"Only CONFIG GET is allowed during loading\");\n        return;\n    }\n\n    if (!strcasecmp(c->argv[1]->ptr,\"set\")) {\n        if (c->argc != 4) goto badarity;\n        configSetCommand(c);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"get\")) {\n        if (c->argc != 3) goto badarity;\n        configGetCommand(c);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"resetstat\")) {\n        if (c->argc != 2) goto badarity;\n        resetServerStats();\n        resetCommandTableStats();\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr,\"rewrite\")) {\n        if (c->argc != 2) goto badarity;\n        if (server.configfile == NULL) {\n            addReplyError(c,\"The server is running without a config file\");\n            return;\n        }\n        if (rewriteConfig(server.configfile) == -1) {\n            serverLog(LL_WARNING,\"CONFIG REWRITE failed: %s\", strerror(errno));\n            addReplyErrorFormat(c,\"Rewriting config file: %s\", strerror(errno));\n        } else {\n            serverLog(LL_WARNING,\"CONFIG REWRITE executed with success.\");\n            addReply(c,shared.ok);\n        }\n    } else {\n        addReplyError(c,\n            \"CONFIG subcommand must be one of GET, SET, RESETSTAT, REWRITE\");\n    }\n    return;\n\nbadarity:\n    addReplyErrorFormat(c,\"Wrong number of arguments for CONFIG %s\",\n        (char*) c->argv[1]->ptr);\n}\n"], "filenames": ["src/config.c"], "buggy_code_start_loc": [619], "buggy_code_end_loc": [910], "fixing_code_start_loc": [619], "fixing_code_end_loc": [912], "type": "CWE-787", "message": "A buffer overflow in Redis 3.2.x prior to 3.2.4 causes arbitrary code execution when a crafted command is sent. An out of bounds write vulnerability exists in the handling of the client-output-buffer-limit option during the CONFIG SET command for the Redis data structure store. A crafted CONFIG SET command can lead to an out of bounds write potentially resulting in code execution.", "other": {"cve": {"id": "CVE-2016-8339", "sourceIdentifier": "talos-cna@cisco.com", "published": "2016-10-28T14:59:01.603", "lastModified": "2023-01-30T19:50:41.207", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A buffer overflow in Redis 3.2.x prior to 3.2.4 causes arbitrary code execution when a crafted command is sent. An out of bounds write vulnerability exists in the handling of the client-output-buffer-limit option during the CONFIG SET command for the Redis data structure store. A crafted CONFIG SET command can lead to an out of bounds write potentially resulting in code execution."}, {"lang": "es", "value": "Un desbordamiento de b\u00fafer en Redis 3.2.x antes de 3.2.4 provoca ejecuci\u00f3n de c\u00f3digo arbitrario cuando un comando manipulado es enviado. Una vulnerabilidad de escritura fuera de l\u00edmites existe en el manejo de la opci\u00f3n client-output-buffer-limit durante el comando CONFIG SET para la estructura de almac\u00e9n de datos Redis. Un comando CONFIG SET manipulado puede llevar a una escritura fuera de l\u00edmites resultando potencialmente en ejecuci\u00f3n de c\u00f3digo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "talos-cna@cisco.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redislabs:redis:3.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "54063636-8CE2-408B-BF17-6E68977D4028"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redislabs:redis:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "8F4E0B88-C020-47C0-9420-E508B9D196B2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redislabs:redis:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "EC52A6CD-A02A-4153-A353-8BA8AD36EDD1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redislabs:redis:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "227C8FB9-639D-46BD-9484-24F40B3339C1"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/93283", "source": "talos-cna@cisco.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.talosintelligence.com/reports/TALOS-2016-0206/", "source": "talos-cna@cisco.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/antirez/redis/commit/6d9f8e2462fc2c426d48c941edeb78e5df7d2977", "source": "talos-cna@cisco.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201702-16", "source": "talos-cna@cisco.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/antirez/redis/commit/6d9f8e2462fc2c426d48c941edeb78e5df7d2977"}}