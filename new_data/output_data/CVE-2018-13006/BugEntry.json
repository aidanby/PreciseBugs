{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#ifndef _GF_ISOMEDIA_DEV_H_\n#define _GF_ISOMEDIA_DEV_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <gpac/isomedia.h>\n\n\nenum\n{\n\tGF_ISOM_BOX_TYPE_CO64\t= GF_4CC( 'c', 'o', '6', '4' ),\n\tGF_ISOM_BOX_TYPE_STCO\t= GF_4CC( 's', 't', 'c', 'o' ),\n\tGF_ISOM_BOX_TYPE_CTTS\t= GF_4CC( 'c', 't', 't', 's' ),\n\tGF_ISOM_BOX_TYPE_CPRT\t= GF_4CC( 'c', 'p', 'r', 't' ),\n\tGF_ISOM_BOX_TYPE_KIND\t= GF_4CC( 'k', 'i', 'n', 'd' ),\n\tGF_ISOM_BOX_TYPE_CHPL\t= GF_4CC( 'c', 'h', 'p', 'l' ),\n\tGF_ISOM_BOX_TYPE_URL\t= GF_4CC( 'u', 'r', 'l', ' ' ),\n\tGF_ISOM_BOX_TYPE_URN\t= GF_4CC( 'u', 'r', 'n', ' ' ),\n\tGF_ISOM_BOX_TYPE_DINF\t= GF_4CC( 'd', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_DREF\t= GF_4CC( 'd', 'r', 'e', 'f' ),\n\tGF_ISOM_BOX_TYPE_STDP\t= GF_4CC( 's', 't', 'd', 'p' ),\n\tGF_ISOM_BOX_TYPE_EDTS\t= GF_4CC( 'e', 'd', 't', 's' ),\n\tGF_ISOM_BOX_TYPE_ELST\t= GF_4CC( 'e', 'l', 's', 't' ),\n\tGF_ISOM_BOX_TYPE_UUID\t= GF_4CC( 'u', 'u', 'i', 'd' ),\n\tGF_ISOM_BOX_TYPE_FREE\t= GF_4CC( 'f', 'r', 'e', 'e' ),\n\tGF_ISOM_BOX_TYPE_HDLR\t= GF_4CC( 'h', 'd', 'l', 'r' ),\n\tGF_ISOM_BOX_TYPE_GMHD\t= GF_4CC( 'g', 'm', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_HMHD\t= GF_4CC( 'h', 'm', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_HINT\t= GF_4CC( 'h', 'i', 'n', 't' ),\n\tGF_ISOM_BOX_TYPE_MDIA\t= GF_4CC( 'm', 'd', 'i', 'a' ),\n\tGF_ISOM_BOX_TYPE_ELNG\t= GF_4CC( 'e', 'l', 'n', 'g' ),\n\tGF_ISOM_BOX_TYPE_MDAT\t= GF_4CC( 'm', 'd', 'a', 't' ),\n\tGF_ISOM_BOX_TYPE_IDAT\t= GF_4CC( 'i', 'd', 'a', 't' ),\n\tGF_ISOM_BOX_TYPE_MDHD\t= GF_4CC( 'm', 'd', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_MINF\t= GF_4CC( 'm', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_MOOV\t= GF_4CC( 'm', 'o', 'o', 'v' ),\n\tGF_ISOM_BOX_TYPE_MVHD\t= GF_4CC( 'm', 'v', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_STSD\t= GF_4CC( 's', 't', 's', 'd' ),\n\tGF_ISOM_BOX_TYPE_STSZ\t= GF_4CC( 's', 't', 's', 'z' ),\n\tGF_ISOM_BOX_TYPE_STZ2\t= GF_4CC( 's', 't', 'z', '2' ),\n\tGF_ISOM_BOX_TYPE_STBL\t= GF_4CC( 's', 't', 'b', 'l' ),\n\tGF_ISOM_BOX_TYPE_STSC\t= GF_4CC( 's', 't', 's', 'c' ),\n\tGF_ISOM_BOX_TYPE_STSH\t= GF_4CC( 's', 't', 's', 'h' ),\n\tGF_ISOM_BOX_TYPE_SKIP\t= GF_4CC( 's', 'k', 'i', 'p' ),\n\tGF_ISOM_BOX_TYPE_SMHD\t= GF_4CC( 's', 'm', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_STSS\t= GF_4CC( 's', 't', 's', 's' ),\n\tGF_ISOM_BOX_TYPE_STTS\t= GF_4CC( 's', 't', 't', 's' ),\n\tGF_ISOM_BOX_TYPE_TRAK\t= GF_4CC( 't', 'r', 'a', 'k' ),\n\tGF_ISOM_BOX_TYPE_TKHD\t= GF_4CC( 't', 'k', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_TREF\t= GF_4CC( 't', 'r', 'e', 'f' ),\n\tGF_ISOM_BOX_TYPE_STRK\t= GF_4CC( 's', 't', 'r', 'k' ),\n\tGF_ISOM_BOX_TYPE_STRI\t= GF_4CC( 's', 't', 'r', 'i' ),\n\tGF_ISOM_BOX_TYPE_STRD\t= GF_4CC( 's', 't', 'r', 'd' ),\n\tGF_ISOM_BOX_TYPE_STSG\t= GF_4CC( 's', 't', 's', 'g' ),\n\n\tGF_ISOM_BOX_TYPE_UDTA\t= GF_4CC( 'u', 'd', 't', 'a' ),\n\tGF_ISOM_BOX_TYPE_VMHD\t= GF_4CC( 'v', 'm', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_FTYP\t= GF_4CC( 'f', 't', 'y', 'p' ),\n\tGF_ISOM_BOX_TYPE_PADB\t= GF_4CC( 'p', 'a', 'd', 'b' ),\n\tGF_ISOM_BOX_TYPE_PDIN\t= GF_4CC( 'p', 'd', 'i', 'n' ),\n\tGF_ISOM_BOX_TYPE_SDTP\t= GF_4CC( 's', 'd', 't', 'p' ),\n\tGF_ISOM_BOX_TYPE_CSLG\t= GF_4CC( 'c', 's', 'l', 'g' ),\n\n\tGF_ISOM_BOX_TYPE_SBGP\t= GF_4CC( 's', 'b', 'g', 'p' ),\n\tGF_ISOM_BOX_TYPE_SGPD\t= GF_4CC( 's', 'g', 'p', 'd' ),\n\tGF_ISOM_BOX_TYPE_SAIZ\t= GF_4CC( 's', 'a', 'i', 'z' ),\n\tGF_ISOM_BOX_TYPE_SAIO\t= GF_4CC( 's', 'a', 'i', 'o' ),\n\tGF_ISOM_BOX_TYPE_MFRA\t= GF_4CC( 'm', 'f', 'r', 'a' ),\n\tGF_ISOM_BOX_TYPE_MFRO\t= GF_4CC( 'm', 'f', 'r', 'o' ),\n\tGF_ISOM_BOX_TYPE_TFRA\t= GF_4CC( 't', 'f', 'r', 'a' ),\n\n\tGF_ISOM_BOX_TYPE_PSSH\t= GF_4CC( 'p', 's', 's', 'h' ),\n\tGF_ISOM_BOX_TYPE_TENC\t= GF_4CC( 't', 'e', 'n', 'c' ),\n\n\t//track group\n\tGF_ISOM_BOX_TYPE_TRGR\t= GF_4CC( 't', 'r', 'g', 'r' ),\n\t//track group types\n\tGF_ISOM_BOX_TYPE_TRGT\t= GF_4CC( 't', 'r', 'g', 't' ),\n\tGF_ISOM_BOX_TYPE_MSRC\t= GF_4CC( 'm', 's', 'r', 'c' ),\n\tGF_ISOM_BOX_TYPE_CSTG\t= GF_4CC( 'c', 's', 't', 'g' ),\n\tGF_ISOM_BOX_TYPE_STER\t= GF_4CC( 's', 't', 'e', 'r' ),\n\n\t/*Adobe's protection boxes*/\n\tGF_ISOM_BOX_TYPE_ADKM\t= GF_4CC( 'a', 'd', 'k', 'm' ),\n\tGF_ISOM_BOX_TYPE_AHDR\t= GF_4CC( 'a', 'h', 'd', 'r' ),\n\tGF_ISOM_BOX_TYPE_ADAF\t= GF_4CC( 'a', 'd', 'a', 'f' ),\n\tGF_ISOM_BOX_TYPE_APRM\t= GF_4CC( 'a', 'p', 'r', 'm' ),\n\tGF_ISOM_BOX_TYPE_AEIB\t= GF_4CC( 'a', 'e', 'i', 'b' ),\n\tGF_ISOM_BOX_TYPE_AKEY\t= GF_4CC( 'a', 'k', 'e', 'y' ),\n\tGF_ISOM_BOX_TYPE_FLXS\t= GF_4CC( 'f', 'l', 'x', 's' ),\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t/*Movie Fragments*/\n\tGF_ISOM_BOX_TYPE_MVEX\t= GF_4CC( 'm', 'v', 'e', 'x' ),\n\tGF_ISOM_BOX_TYPE_MEHD\t= GF_4CC( 'm', 'e', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_TREX\t= GF_4CC( 't', 'r', 'e', 'x' ),\n\tGF_ISOM_BOX_TYPE_TREP\t= GF_4CC( 't', 'r', 'e', 'p' ),\n\tGF_ISOM_BOX_TYPE_MOOF\t= GF_4CC( 'm', 'o', 'o', 'f' ),\n\tGF_ISOM_BOX_TYPE_MFHD\t= GF_4CC( 'm', 'f', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_TRAF\t= GF_4CC( 't', 'r', 'a', 'f' ),\n\tGF_ISOM_BOX_TYPE_TFHD\t= GF_4CC( 't', 'f', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_TRUN\t= GF_4CC( 't', 'r', 'u', 'n' ),\n#endif\n\n\n\t/*MP4 extensions*/\n\tGF_ISOM_BOX_TYPE_DPND\t= GF_4CC( 'd', 'p', 'n', 'd' ),\n\tGF_ISOM_BOX_TYPE_IODS\t= GF_4CC( 'i', 'o', 'd', 's' ),\n\tGF_ISOM_BOX_TYPE_ESDS\t= GF_4CC( 'e', 's', 'd', 's' ),\n\tGF_ISOM_BOX_TYPE_MPOD\t= GF_4CC( 'm', 'p', 'o', 'd' ),\n\tGF_ISOM_BOX_TYPE_SYNC\t= GF_4CC( 's', 'y', 'n', 'c' ),\n\tGF_ISOM_BOX_TYPE_IPIR\t= GF_4CC( 'i', 'p', 'i', 'r' ),\n\n\tGF_ISOM_BOX_TYPE_NMHD\t= GF_4CC( 'n', 'm', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_STHD\t= GF_4CC( 's', 't', 'h', 'd' ),\n\t/*reseved\n\tGF_ISOM_BOX_TYPE_SDHD\t= GF_4CC( 's', 'd', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_ODHD\t= GF_4CC( 'o', 'd', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_CRHD\t= GF_4CC( 'c', 'r', 'h', 'd' ),\n\t*/\n\tGF_ISOM_BOX_TYPE_MP4S\t= GF_4CC( 'm', 'p', '4', 's' ),\n\tGF_ISOM_BOX_TYPE_MP4A\t= GF_4CC( 'm', 'p', '4', 'a' ),\n\tGF_ISOM_BOX_TYPE_MP4V\t= GF_4CC( 'm', 'p', '4', 'v' ),\n\n\n\t/*AVC / H264 extension*/\n\tGF_ISOM_BOX_TYPE_AVCC\t= GF_4CC( 'a', 'v', 'c', 'C' ),\n\tGF_ISOM_BOX_TYPE_BTRT\t= GF_4CC( 'b', 't', 'r', 't' ),\n\tGF_ISOM_BOX_TYPE_M4DS\t= GF_4CC( 'm', '4', 'd', 's' ),\n\tGF_ISOM_BOX_TYPE_PASP\t= GF_4CC( 'p', 'a', 's', 'p' ),\n\tGF_ISOM_BOX_TYPE_CLAP\t= GF_4CC( 'c', 'l', 'a', 'p' ),\n\tGF_ISOM_BOX_TYPE_AVC1\t= GF_4CC( 'a', 'v', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_AVC2\t= GF_4CC( 'a', 'v', 'c', '2' ),\n\tGF_ISOM_BOX_TYPE_AVC3\t= GF_4CC( 'a', 'v', 'c', '3' ),\n\tGF_ISOM_BOX_TYPE_AVC4\t= GF_4CC( 'a', 'v', 'c', '4' ),\n\tGF_ISOM_BOX_TYPE_SVCC\t= GF_4CC( 's', 'v', 'c', 'C' ),\n\tGF_ISOM_BOX_TYPE_SVC1\t= GF_4CC( 's', 'v', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_SVC2\t= GF_4CC( 's', 'v', 'c', '2' ),\n\tGF_ISOM_BOX_TYPE_MVCC\t= GF_4CC( 'm', 'v', 'c', 'C' ),\n\tGF_ISOM_BOX_TYPE_MVC1\t= GF_4CC( 'm', 'v', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_MVC2\t= GF_4CC( 'm', 'v', 'c', '2' ),\n\tGF_ISOM_BOX_TYPE_MHC1\t= GF_4CC( 'm', 'h', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_MHV1\t= GF_4CC( 'm', 'h', 'v', '1' ),\n\n\tGF_ISOM_BOX_TYPE_HVCC\t= GF_4CC( 'h', 'v', 'c', 'C' ),\n\tGF_ISOM_BOX_TYPE_HVC1\t= GF_4CC( 'h', 'v', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_HEV1\t= GF_4CC( 'h', 'e', 'v', '1' ),\n\tGF_ISOM_BOX_TYPE_HVT1\t= GF_4CC( 'h', 'v', 't', '1' ),\n\n\tGF_ISOM_BOX_TYPE_HVC2\t= GF_4CC( 'h', 'v', 'c', '2' ),\n\tGF_ISOM_BOX_TYPE_HEV2\t= GF_4CC( 'h', 'e', 'v', '2' ),\n\tGF_ISOM_BOX_TYPE_LHV1\t= GF_4CC( 'l', 'h', 'v', '1' ),\n\tGF_ISOM_BOX_TYPE_LHE1\t= GF_4CC( 'l', 'h', 'e', '1' ),\n\tGF_ISOM_BOX_TYPE_LHT1\t= GF_4CC( 'l', 'h', 't', '1' ),\n\n\tGF_ISOM_BOX_TYPE_LHVC\t= GF_4CC( 'l', 'h', 'v', 'C' ),\n\n\t/*LASeR extension*/\n\tGF_ISOM_BOX_TYPE_LSRC\t= GF_4CC( 'l', 's', 'r', 'C' ),\n\tGF_ISOM_BOX_TYPE_LSR1\t= GF_4CC( 'l', 's', 'r', '1' ),\n\n\t/*3GPP extensions*/\n\tGF_ISOM_BOX_TYPE_DAMR\t= GF_4CC( 'd', 'a', 'm', 'r' ),\n\tGF_ISOM_BOX_TYPE_D263\t= GF_4CC( 'd', '2', '6', '3' ),\n\tGF_ISOM_BOX_TYPE_DEVC\t= GF_4CC( 'd', 'e', 'v', 'c' ),\n\tGF_ISOM_BOX_TYPE_DQCP\t= GF_4CC( 'd', 'q', 'c', 'p' ),\n\tGF_ISOM_BOX_TYPE_DSMV\t= GF_4CC( 'd', 's', 'm', 'v' ),\n\tGF_ISOM_BOX_TYPE_TSEL\t= GF_4CC( 't', 's', 'e', 'l' ),\n\n\t/* 3GPP Adaptive Streaming extensions */\n\tGF_ISOM_BOX_TYPE_STYP\t= GF_4CC( 's', 't', 'y', 'p' ),\n\tGF_ISOM_BOX_TYPE_TFDT\t= GF_4CC( 't', 'f', 'd', 't' ),\n\tGF_ISOM_BOX_TYPE_SIDX\t= GF_4CC( 's', 'i', 'd', 'x' ),\n\tGF_ISOM_BOX_TYPE_SSIX\t= GF_4CC( 's', 's', 'i', 'x' ),\n\tGF_ISOM_BOX_TYPE_LEVA   = GF_4CC( 'l', 'e', 'v', 'a' ),\n\tGF_ISOM_BOX_TYPE_PCRB\t= GF_4CC( 'p', 'c', 'r', 'b' ),\n\n\t/*3GPP text / MPEG-4 StreamingText*/\n\tGF_ISOM_BOX_TYPE_FTAB\t= GF_4CC( 'f', 't', 'a', 'b' ),\n\tGF_ISOM_BOX_TYPE_TX3G\t= GF_4CC( 't', 'x', '3', 'g' ),\n\tGF_ISOM_BOX_TYPE_STYL\t= GF_4CC( 's', 't', 'y', 'l' ),\n\tGF_ISOM_BOX_TYPE_HLIT\t= GF_4CC( 'h', 'l', 'i', 't' ),\n\tGF_ISOM_BOX_TYPE_HCLR\t= GF_4CC( 'h', 'c', 'l', 'r' ),\n\tGF_ISOM_BOX_TYPE_KROK\t= GF_4CC( 'k', 'r', 'o', 'k' ),\n\tGF_ISOM_BOX_TYPE_DLAY\t= GF_4CC( 'd', 'l', 'a', 'y' ),\n\tGF_ISOM_BOX_TYPE_HREF\t= GF_4CC( 'h', 'r', 'e', 'f' ),\n\tGF_ISOM_BOX_TYPE_TBOX\t= GF_4CC( 't', 'b', 'o', 'x' ),\n\tGF_ISOM_BOX_TYPE_BLNK\t= GF_4CC( 'b', 'l', 'n', 'k' ),\n\tGF_ISOM_BOX_TYPE_TWRP\t= GF_4CC( 't', 'w', 'r', 'p' ),\n\n\t/* ISO Base Media File Format Extensions for MPEG-21 */\n\tGF_ISOM_BOX_TYPE_META\t= GF_4CC( 'm', 'e', 't', 'a' ),\n\tGF_ISOM_BOX_TYPE_XML\t= GF_4CC( 'x', 'm', 'l', ' ' ),\n\tGF_ISOM_BOX_TYPE_BXML\t= GF_4CC( 'b', 'x', 'm', 'l' ),\n\tGF_ISOM_BOX_TYPE_ILOC\t= GF_4CC( 'i', 'l', 'o', 'c' ),\n\tGF_ISOM_BOX_TYPE_PITM\t= GF_4CC( 'p', 'i', 't', 'm' ),\n\tGF_ISOM_BOX_TYPE_IPRO\t= GF_4CC( 'i', 'p', 'r', 'o' ),\n\tGF_ISOM_BOX_TYPE_INFE\t= GF_4CC( 'i', 'n', 'f', 'e' ),\n\tGF_ISOM_BOX_TYPE_IINF\t= GF_4CC( 'i', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_IREF\t= GF_4CC( 'i', 'r', 'e', 'f' ),\n\tGF_ISOM_BOX_TYPE_ENCA\t= GF_4CC( 'e', 'n', 'c', 'a' ),\n\tGF_ISOM_BOX_TYPE_ENCV\t= GF_4CC( 'e', 'n', 'c', 'v' ),\n\tGF_ISOM_BOX_TYPE_RESV\t= GF_4CC( 'r', 'e', 's', 'v' ),\n\tGF_ISOM_BOX_TYPE_ENCT\t= GF_4CC( 'e', 'n', 'c', 't' ),\n\tGF_ISOM_BOX_TYPE_ENCS\t= GF_4CC( 'e', 'n', 'c', 's' ),\n\tGF_ISOM_BOX_TYPE_ENCF\t= GF_4CC( 'e', 'n', 'c', 'f' ),\n\tGF_ISOM_BOX_TYPE_ENCM\t= GF_4CC( 'e', 'n', 'c', 'm' ),\n\tGF_ISOM_BOX_TYPE_SINF\t= GF_4CC( 's', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_RINF\t= GF_4CC( 'r', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_FRMA\t= GF_4CC( 'f', 'r', 'm', 'a' ),\n\tGF_ISOM_BOX_TYPE_SCHM\t= GF_4CC( 's', 'c', 'h', 'm' ),\n\tGF_ISOM_BOX_TYPE_SCHI\t= GF_4CC( 's', 'c', 'h', 'i' ),\n\n\tGF_ISOM_BOX_TYPE_STVI\t= GF_4CC( 's', 't', 'v', 'i' ),\n\n\n\tGF_ISOM_BOX_TYPE_METX\t= GF_4CC( 'm', 'e', 't', 'x' ),\n\tGF_ISOM_BOX_TYPE_METT\t= GF_4CC( 'm', 'e', 't', 't' ),\n\n\t/* ISMA 1.0 Encryption and Authentication V 1.0 */\n\tGF_ISOM_BOX_TYPE_IKMS\t= GF_4CC( 'i', 'K', 'M', 'S' ),\n\tGF_ISOM_BOX_TYPE_ISFM\t= GF_4CC( 'i', 'S', 'F', 'M' ),\n\tGF_ISOM_BOX_TYPE_ISLT\t= GF_4CC( 'i', 'S', 'L', 'T' ),\n\n\t/* Hinting boxes */\n\tGF_ISOM_BOX_TYPE_RTP_STSD\t= GF_4CC( 'r', 't', 'p', ' ' ),\n\tGF_ISOM_BOX_TYPE_SRTP_STSD\t= GF_4CC( 's', 'r', 't', 'p' ),\n\tGF_ISOM_BOX_TYPE_FDP_STSD\t= GF_4CC( 'f', 'd', 'p', ' ' ),\n\tGF_ISOM_BOX_TYPE_RRTP_STSD\t= GF_4CC( 'r', 'r', 't', 'p' ),\n\tGF_ISOM_BOX_TYPE_RTCP_STSD\t= GF_4CC( 'r', 't', 'c', 'p' ),\n\tGF_ISOM_BOX_TYPE_HNTI\t= GF_4CC( 'h', 'n', 't', 'i' ),\n\tGF_ISOM_BOX_TYPE_RTP\t= GF_4CC( 'r', 't', 'p', ' ' ),\n\tGF_ISOM_BOX_TYPE_SDP\t= GF_4CC( 's', 'd', 'p', ' ' ),\n\tGF_ISOM_BOX_TYPE_HINF\t= GF_4CC( 'h', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_NAME\t= GF_4CC( 'n', 'a', 'm', 'e' ),\n\tGF_ISOM_BOX_TYPE_TRPY\t= GF_4CC( 't', 'r', 'p', 'y' ),\n\tGF_ISOM_BOX_TYPE_NUMP\t= GF_4CC( 'n', 'u', 'm', 'p' ),\n\tGF_ISOM_BOX_TYPE_TOTL\t= GF_4CC( 't', 'o', 't', 'l' ),\n\tGF_ISOM_BOX_TYPE_NPCK\t= GF_4CC( 'n', 'p', 'c', 'k' ),\n\tGF_ISOM_BOX_TYPE_TPYL\t= GF_4CC( 't', 'p', 'y', 'l' ),\n\tGF_ISOM_BOX_TYPE_TPAY\t= GF_4CC( 't', 'p', 'a', 'y' ),\n\tGF_ISOM_BOX_TYPE_MAXR\t= GF_4CC( 'm', 'a', 'x', 'r' ),\n\tGF_ISOM_BOX_TYPE_DMED\t= GF_4CC( 'd', 'm', 'e', 'd' ),\n\tGF_ISOM_BOX_TYPE_DIMM\t= GF_4CC( 'd', 'i', 'm', 'm' ),\n\tGF_ISOM_BOX_TYPE_DREP\t= GF_4CC( 'd', 'r', 'e', 'p' ),\n\tGF_ISOM_BOX_TYPE_TMIN\t= GF_4CC( 't', 'm', 'i', 'n' ),\n\tGF_ISOM_BOX_TYPE_TMAX\t= GF_4CC( 't', 'm', 'a', 'x' ),\n\tGF_ISOM_BOX_TYPE_PMAX\t= GF_4CC( 'p', 'm', 'a', 'x' ),\n\tGF_ISOM_BOX_TYPE_DMAX\t= GF_4CC( 'd', 'm', 'a', 'x' ),\n\tGF_ISOM_BOX_TYPE_PAYT\t= GF_4CC( 'p', 'a', 'y', 't' ),\n\tGF_ISOM_BOX_TYPE_RELY\t= GF_4CC( 'r', 'e', 'l', 'y' ),\n\tGF_ISOM_BOX_TYPE_TIMS\t= GF_4CC( 't', 'i', 'm', 's' ),\n\tGF_ISOM_BOX_TYPE_TSRO\t= GF_4CC( 't', 's', 'r', 'o' ),\n\tGF_ISOM_BOX_TYPE_SNRO\t= GF_4CC( 's', 'n', 'r', 'o' ),\n\tGF_ISOM_BOX_TYPE_RTPO\t= GF_4CC( 'r', 't', 'p', 'o' ),\n\tGF_ISOM_BOX_TYPE_TSSY\t= GF_4CC( 't', 's', 's', 'y' ),\n\tGF_ISOM_BOX_TYPE_RSSR\t= GF_4CC( 'r', 's', 's', 'r' ),\n\tGF_ISOM_BOX_TYPE_SRPP\t= GF_4CC( 's', 'r', 'p', 'p' ),\n\n\t//FEC boxes\n\tGF_ISOM_BOX_TYPE_FIIN\t= GF_4CC( 'f', 'i', 'i', 'n' ),\n\tGF_ISOM_BOX_TYPE_PAEN\t= GF_4CC( 'p', 'a', 'e', 'n' ),\n\tGF_ISOM_BOX_TYPE_FPAR\t= GF_4CC( 'f', 'p', 'a', 'r' ),\n\tGF_ISOM_BOX_TYPE_FECR\t= GF_4CC( 'f', 'e', 'c', 'r' ),\n\tGF_ISOM_BOX_TYPE_SEGR\t= GF_4CC( 's', 'e', 'g', 'r' ),\n\tGF_ISOM_BOX_TYPE_GITN\t= GF_4CC( 'g', 'i', 't', 'n' ),\n\tGF_ISOM_BOX_TYPE_FIRE\t= GF_4CC( 'f', 'i', 'r', 'e' ),\n\tGF_ISOM_BOX_TYPE_FDSA\t= GF_4CC( 'f', 'd', 's', 'a' ),\n\tGF_ISOM_BOX_TYPE_FDPA\t= GF_4CC( 'f', 'd', 'p', 'a' ),\n\tGF_ISOM_BOX_TYPE_EXTR\t= GF_4CC( 'e', 'x', 't', 'r' ),\n\n\t/*internal type for track and item references*/\n\tGF_ISOM_BOX_TYPE_REFT\t= GF_4CC( 'R', 'E', 'F', 'T' ),\n\tGF_ISOM_BOX_TYPE_REFI\t= GF_4CC( 'R', 'E', 'F', 'I'),\n\tGF_ISOM_BOX_TYPE_GRPT\t= GF_4CC( 'G', 'R', 'P', 'T'),\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\t/* Adobe extensions */\n\tGF_ISOM_BOX_TYPE_ABST\t= GF_4CC( 'a', 'b', 's', 't' ),\n\tGF_ISOM_BOX_TYPE_AFRA\t= GF_4CC( 'a', 'f', 'r', 'a' ),\n\tGF_ISOM_BOX_TYPE_ASRT\t= GF_4CC( 'a', 's', 'r', 't' ),\n\tGF_ISOM_BOX_TYPE_AFRT\t= GF_4CC( 'a', 'f', 'r', 't' ),\n#endif\n\n\t/* Apple extensions */\n\n\tGF_ISOM_BOX_TYPE_ILST\t= GF_4CC( 'i', 'l', 's', 't' ),\n\tGF_ISOM_BOX_TYPE_0xA9NAM\t= GF_4CC( 0xA9, 'n', 'a', 'm' ),\n\tGF_ISOM_BOX_TYPE_0xA9CMT\t= GF_4CC( 0xA9, 'c', 'm', 't' ),\n\tGF_ISOM_BOX_TYPE_0xA9DAY\t= GF_4CC( 0xA9, 'd', 'a', 'y' ),\n\tGF_ISOM_BOX_TYPE_0xA9ART\t= GF_4CC( 0xA9, 'A', 'R', 'T' ),\n\tGF_ISOM_BOX_TYPE_0xA9TRK\t= GF_4CC( 0xA9, 't', 'r', 'k' ),\n\tGF_ISOM_BOX_TYPE_0xA9ALB\t= GF_4CC( 0xA9, 'a', 'l', 'b' ),\n\tGF_ISOM_BOX_TYPE_0xA9COM\t= GF_4CC( 0xA9, 'c', 'o', 'm' ),\n\tGF_ISOM_BOX_TYPE_0xA9WRT\t= GF_4CC( 0xA9, 'w', 'r', 't' ),\n\tGF_ISOM_BOX_TYPE_0xA9TOO\t= GF_4CC( 0xA9, 't', 'o', 'o' ),\n\tGF_ISOM_BOX_TYPE_0xA9CPY\t= GF_4CC( 0xA9, 'c', 'p', 'y' ),\n\tGF_ISOM_BOX_TYPE_0xA9DES\t= GF_4CC( 0xA9, 'd', 'e', 's' ),\n\tGF_ISOM_BOX_TYPE_0xA9GEN\t= GF_4CC( 0xA9, 'g', 'e', 'n' ),\n\tGF_ISOM_BOX_TYPE_0xA9GRP\t= GF_4CC( 0xA9, 'g', 'r', 'p' ),\n\tGF_ISOM_BOX_TYPE_0xA9ENC\t= GF_4CC( 0xA9, 'e', 'n', 'c' ),\n\tGF_ISOM_BOX_TYPE_aART\t\t= GF_4CC( 'a', 'A', 'R', 'T' ),\n\tGF_ISOM_BOX_TYPE_PGAP = GF_4CC( 'p', 'g', 'a', 'p' ),\n\tGF_ISOM_BOX_TYPE_GNRE\t= GF_4CC( 'g', 'n', 'r', 'e' ),\n\tGF_ISOM_BOX_TYPE_DISK\t= GF_4CC( 'd', 'i', 's', 'k' ),\n\tGF_ISOM_BOX_TYPE_TRKN\t= GF_4CC( 't', 'r', 'k', 'n' ),\n\tGF_ISOM_BOX_TYPE_TMPO\t= GF_4CC( 't', 'm', 'p', 'o' ),\n\tGF_ISOM_BOX_TYPE_CPIL\t= GF_4CC( 'c', 'p', 'i', 'l' ),\n\tGF_ISOM_BOX_TYPE_COVR\t= GF_4CC( 'c', 'o', 'v', 'r' ),\n\tGF_ISOM_BOX_TYPE_iTunesSpecificInfo\t= GF_4CC( '-', '-', '-', '-' ),\n\tGF_ISOM_BOX_TYPE_DATA\t= GF_4CC( 'd', 'a', 't', 'a' ),\n\n\tGF_ISOM_HANDLER_TYPE_MDIR\t= GF_4CC( 'm', 'd', 'i', 'r' ),\n\tGF_ISOM_BOX_TYPE_CHAP\t= GF_4CC( 'c', 'h', 'a', 'p' ),\n\tGF_ISOM_BOX_TYPE_TEXT\t= GF_4CC( 't', 'e', 'x', 't' ),\n\n\t/*OMA (P)DCF boxes*/\n\tGF_ISOM_BOX_TYPE_OHDR\t= GF_4CC( 'o', 'h', 'd', 'r' ),\n\tGF_ISOM_BOX_TYPE_GRPI\t= GF_4CC( 'g', 'r', 'p', 'i' ),\n\tGF_ISOM_BOX_TYPE_MDRI\t= GF_4CC( 'm', 'd', 'r', 'i' ),\n\tGF_ISOM_BOX_TYPE_ODTT\t= GF_4CC( 'o', 'd', 't', 't' ),\n\tGF_ISOM_BOX_TYPE_ODRB\t= GF_4CC( 'o', 'd', 'r', 'b' ),\n\tGF_ISOM_BOX_TYPE_ODKM\t= GF_4CC( 'o', 'd', 'k', 'm' ),\n\tGF_ISOM_BOX_TYPE_ODAF\t= GF_4CC( 'o', 'd', 'a', 'f' ),\n\n\t/*3GPP DIMS */\n\tGF_ISOM_BOX_TYPE_DIMS\t= GF_4CC( 'd', 'i', 'm', 's' ),\n\tGF_ISOM_BOX_TYPE_DIMC\t= GF_4CC( 'd', 'i', 'm', 'C' ),\n\tGF_ISOM_BOX_TYPE_DIST\t= GF_4CC( 'd', 'i', 'S', 'T' ),\n\n\n\tGF_ISOM_BOX_TYPE_AC3\t= GF_4CC( 'a', 'c', '-', '3' ),\n\tGF_ISOM_BOX_TYPE_DAC3\t= GF_4CC( 'd', 'a', 'c', '3' ),\n\tGF_ISOM_BOX_TYPE_EC3\t= GF_4CC( 'e', 'c', '-', '3' ),\n\tGF_ISOM_BOX_TYPE_DEC3\t= GF_4CC( 'd', 'e', 'c', '3' ),\n\n\tGF_ISOM_BOX_TYPE_SUBS\t= GF_4CC( 's', 'u', 'b', 's' ),\n\n\tGF_ISOM_BOX_TYPE_RVCC\t= GF_4CC( 'r', 'v', 'c', 'c' ),\n\n\tGF_ISOM_BOX_TYPE_VTTC_CONFIG\t= GF_4CC( 'v', 't', 't', 'C' ),\n\tGF_ISOM_BOX_TYPE_VTCC_CUE\t= GF_4CC( 'v', 't', 't', 'c' ),\n\tGF_ISOM_BOX_TYPE_VTTE\t= GF_4CC( 'v', 't', 't', 'e' ),\n\tGF_ISOM_BOX_TYPE_VTTA\t= GF_4CC( 'v', 't', 't', 'a' ),\n\tGF_ISOM_BOX_TYPE_CTIM\t= GF_4CC( 'c', 't', 'i', 'm' ),\n\tGF_ISOM_BOX_TYPE_IDEN\t= GF_4CC( 'i', 'd', 'e', 'n' ),\n\tGF_ISOM_BOX_TYPE_STTG\t= GF_4CC( 's', 't', 't', 'g' ),\n\tGF_ISOM_BOX_TYPE_PAYL\t= GF_4CC( 'p', 'a', 'y', 'l' ),\n\tGF_ISOM_BOX_TYPE_WVTT\t= GF_4CC( 'w', 'v', 't', 't' ),\n\n\tGF_ISOM_BOX_TYPE_STPP\t= GF_4CC( 's', 't', 'p', 'p' ),\n\tGF_ISOM_BOX_TYPE_SBTT\t= GF_4CC( 's', 'b', 't', 't' ),\n\n\tGF_ISOM_BOX_TYPE_STXT\t= GF_4CC( 's', 't', 'x', 't' ),\n\tGF_ISOM_BOX_TYPE_TXTC\t= GF_4CC( 't', 'x', 't', 'C' ),\n\n\tGF_ISOM_BOX_TYPE_PRFT   = GF_4CC( 'p', 'r', 'f', 't' ),\n\n\t/* Image File Format Boxes */\n\tGF_ISOM_BOX_TYPE_ISPE   = GF_4CC( 'i', 's', 'p', 'e' ),\n\tGF_ISOM_BOX_TYPE_COLR   = GF_4CC( 'c', 'o', 'l', 'r' ),\n\tGF_ISOM_BOX_TYPE_PIXI   = GF_4CC( 'p', 'i', 'x', 'i' ),\n\tGF_ISOM_BOX_TYPE_RLOC   = GF_4CC( 'r', 'l', 'o', 'c' ),\n\tGF_ISOM_BOX_TYPE_IROT   = GF_4CC( 'i', 'r', 'o', 't' ),\n\tGF_ISOM_BOX_TYPE_IPCO   = GF_4CC( 'i', 'p', 'c', 'o' ),\n\tGF_ISOM_BOX_TYPE_IPRP   = GF_4CC( 'i', 'p', 'r', 'p' ),\n\tGF_ISOM_BOX_TYPE_IPMA   = GF_4CC( 'i', 'p', 'm', 'a' ),\n\tGF_ISOM_BOX_TYPE_GRPL   = GF_4CC( 'g', 'r', 'p', 'l'),\n\tGF_ISOM_BOX_TYPE_CCST\t= GF_4CC( 'c', 'c', 's', 't' ),\n\tGF_ISOM_BOX_TYPE_AUXC\t= GF_4CC( 'a', 'u', 'x', 'C' ),\n\tGF_ISOM_BOX_TYPE_OINF\t= GF_4CC( 'o', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_TOLS\t= GF_4CC( 't', 'o', 'l', 's' ),\n\n\tGF_ISOM_BOX_TYPE_ALTR\t= GF_4CC( 'a', 'l', 't', 'r' ),\n\n\t/*ALL INTERNAL BOXES - NEVER WRITTEN TO FILE!!*/\n\n\t/*generic handlers*/\n\tGF_ISOM_BOX_TYPE_GNRM\t= GF_4CC( 'G', 'N', 'R', 'M' ),\n\tGF_ISOM_BOX_TYPE_GNRV\t= GF_4CC( 'G', 'N', 'R', 'V' ),\n\tGF_ISOM_BOX_TYPE_GNRA\t= GF_4CC( 'G', 'N', 'R', 'A' ),\n\t/*storage of AU fragments (for MPEG-4 visual resync marker (video packets), located in stbl.*/\n\tGF_ISOM_BOX_TYPE_STSF\t=  GF_4CC( 'S', 'T', 'S', 'F' ),\n\t/*base constructor of all hint formats (currently only RTP uses it)*/\n\tGF_ISOM_BOX_TYPE_GHNT\t= GF_4CC( 'g', 'h', 'n', 't' ),\n\t/*for compatibility with old files hinted for DSS - needs special parsing*/\n\tGF_ISOM_BOX_TYPE_VOID\t= GF_4CC( 'V', 'O', 'I', 'D' ),\n\n\t/*MS Smooth - these are actually UUID boxes*/\n\tGF_ISOM_BOX_UUID_PSSH\t= GF_4CC( 'P', 'S', 'S', 'H' ),\n\tGF_ISOM_BOX_UUID_MSSM   = GF_4CC( 'M', 'S', 'S', 'M' ), /*Stream Manifest box*/\n\tGF_ISOM_BOX_UUID_TENC\t= GF_4CC( 'T', 'E', 'N', 'C' ),\n\tGF_ISOM_BOX_UUID_TFRF\t= GF_4CC( 'T', 'F', 'R', 'F' ),\n\tGF_ISOM_BOX_UUID_TFXD\t= GF_4CC( 'T', 'F', 'X', 'D' ),\n\n\tGF_ISOM_BOX_TYPE_MP3\t= GF_4CC( '.', 'm', 'p', '3' ),\n\n\tGF_ISOM_BOX_TYPE_TRIK\t= GF_4CC( 't', 'r', 'i', 'k' ),\n\tGF_ISOM_BOX_TYPE_BLOC\t= GF_4CC( 'b', 'l', 'o', 'c' ),\n\tGF_ISOM_BOX_TYPE_AINF\t= GF_4CC( 'a', 'i', 'n', 'f' ),\n\n\tGF_ISOM_BOX_TYPE_IHDR\t= GF_4CC('i','h','d','r'),\n\tGF_ISOM_BOX_TYPE_JP  \t= GF_4CC('j','P',' ',' '),\n\tGF_ISOM_BOX_TYPE_JP2H\t= GF_4CC('j','p','2','h'),\n\tGF_ISOM_BOX_TYPE_JP2K\t= GF_4CC('j','p','2','k'),\n\tGF_ISOM_BOX_TYPE_JPEG\t= GF_4CC('j','p','e','g'),\n\tGF_ISOM_BOX_TYPE_PNG \t= GF_4CC('p','n','g',' '),\n\n\tGF_ISOM_BOX_TYPE_WAVE \t= GF_4CC('w','a','v','e'),\n\n\t/* apple alis box */\n\tGF_ISOM_BOX_TYPE_ALIS \t= GF_4CC('a','l','i','s'),\n\n\tGF_ISOM_BOX_TYPE_WIDE \t= GF_4CC('w','i','d','e'),\n\n\t/* from drm_sample.c */\n\tGF_ISOM_BOX_TYPE_264B \t= GF_4CC('2','6','4','b'),\n\tGF_ISOM_BOX_TYPE_265B \t= GF_4CC('2','6','5','b'),\n\n\tGF_ISOM_BOX_TYPE_AUXV \t= GF_4CC('A','U','X','V'),\n\n\tGF_ISOM_BOX_TYPE_UNKNOWN = GF_4CC( 'U', 'N', 'K', 'N' ),\n};\n\nenum\n{\n\tGF_ISOM_SAMPLE_ENTRY_UNKN = 0,\n\tGF_ISOM_SAMPLE_ENTRY_VIDEO = GF_4CC('v','i','d','e'),\n\tGF_ISOM_SAMPLE_ENTRY_AUDIO = GF_4CC('a','u','d','i')\n};\n\n\n#ifndef GPAC_DISABLE_ISOM\n\n\n#if defined(GPAC_DISABLE_ISOM_FRAGMENTS) && !defined(GPAC_DISABLE_ISOM_ADOBE)\n#define GPAC_DISABLE_ISOM_ADOBE\n#endif\n\n\t/*the default size is 64, cause we need to handle large boxes...\n\n\tthe other_boxes container is by default NOT created. When parsing a box and adding\n\ta sub-box with gf_isom_box_add_default, the list is created.\n\tThis list is destroyed befaore calling the final box destructor\n\tThis list is automatically taken into account during size() and write() functions\n\t*/\n#define GF_ISOM_BOX\t\t\t\\\n\tu32 type;\t\t\t\\\n\tu64 size;\t\t\t\\\n\tconst struct box_registry_entry *registry;\\\n\tGF_List *other_boxes;\n\n#define GF_ISOM_FULL_BOX\t\t\\\n\tGF_ISOM_BOX\t\t\t\\\n\tu8 version;\t\t\t\\\n\tu32 flags;\t\t\t\\\n\n#define GF_ISOM_UUID_BOX\t\\\n\tGF_ISOM_BOX\t\t\t\\\n\tu8 uuid[16];\t\t\\\n\tu32 internal_4cc;\t\t\\\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_Box;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_FullBox;\n\ntypedef struct\n{\n\tGF_ISOM_UUID_BOX\n} GF_UUIDBox;\n\n\n#define ISOM_DECL_BOX_ALLOC(__TYPE, __4cc)\t__TYPE *tmp; \\\n\tGF_SAFEALLOC(tmp, __TYPE);\t\\\n\tif (tmp==NULL) return NULL;\t\\\n\ttmp->type = __4cc;\n\n#define ISOM_DECREASE_SIZE(__ptr, bytes)\tif (__ptr->size < (bytes) ) {\\\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\\n\", gf_4cc_to_str(__ptr->type), __ptr->size, (bytes), __FILE__, __LINE__ )); \\\n\t\t\treturn GF_ISOM_INVALID_FILE; \\\n\t\t}\\\n\t\t__ptr->size -= bytes; \\\n\n/*constructor*/\nGF_Box *gf_isom_box_new(u32 boxType);\n//some boxes may have different syntax based on container. Use this constructor for this case\nGF_Box *gf_isom_box_new_ex(u32 boxType, u32 parentType);\n\nGF_Err gf_isom_box_write(GF_Box *ptr, GF_BitStream *bs);\nGF_Err gf_isom_box_read(GF_Box *ptr, GF_BitStream *bs);\nvoid gf_isom_box_del(GF_Box *ptr);\nGF_Err gf_isom_box_size(GF_Box *ptr);\n\nGF_Err gf_isom_clone_box(GF_Box *src, GF_Box **dst);\n\nGF_Err gf_isom_box_parse(GF_Box **outBox, GF_BitStream *bs);\nGF_Err gf_isom_box_array_read(GF_Box *s, GF_BitStream *bs, GF_Err (*add_box)(GF_Box *par, GF_Box *b));\nGF_Err gf_isom_box_array_read_ex(GF_Box *parent, GF_BitStream *bs, GF_Err (*add_box)(GF_Box *par, GF_Box *b), u32 parent_type);\nGF_Err gf_isom_box_add_default(GF_Box *a, GF_Box *subbox);\nGF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box);\n\n//writes box header - shall be called at the begining of each xxxx_Write function\n//this function is not factorized in order to let box serializer modify box type before writing\nGF_Err gf_isom_box_write_header(GF_Box *ptr, GF_BitStream *bs);\n\n//writes box header then version+flags\nGF_Err gf_isom_full_box_write(GF_Box *s, GF_BitStream *bs);\n\nvoid gf_isom_box_array_del(GF_List *other_boxes);\nGF_Err gf_isom_box_array_write(GF_Box *parent, GF_List *list, GF_BitStream *bs);\nGF_Err gf_isom_box_array_size(GF_Box *parent, GF_List *list);\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\t/*note: the data is NEVER loaded to the mdat in this lib*/\n\tu64 dataSize;\n\t/* store the file offset when parsing to access the raw data */\n\tu64 bsOffset;\n\tchar *data;\n} GF_MediaDataBox;\n\ntypedef struct\n{\n  u64 time;\n  u64 moof_offset;\n  u32 traf_number;\n  u32 trun_number;\n  u32 sample_number;\n} GF_RandomAccessEntry;\n\ntypedef struct\n{\n  GF_ISOM_FULL_BOX\n  u32 track_id;\n  u8 traf_bits;\n  u8 trun_bits;\n  u8 sample_bits;\n  u32 nb_entries;\n  GF_RandomAccessEntry *entries;\n} GF_TrackFragmentRandomAccessBox;\n\ntypedef struct\n{\n  GF_ISOM_FULL_BOX\n\tu32 container_size;\n} GF_MovieFragmentRandomAccessOffsetBox;\n\ntypedef struct\n{\n  GF_ISOM_BOX\n  GF_List* tfra_list;\n  GF_MovieFragmentRandomAccessOffsetBox *mfro;\n} GF_MovieFragmentRandomAccessBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *data;\n\tu32 dataSize;\n\tu32 original_4cc;\n} GF_UnknownBox;\n\ntypedef struct\n{\n\tGF_ISOM_UUID_BOX\n\tchar *data;\n\tu32 dataSize;\n} GF_UnknownUUIDBox;\n\nu32 gf_isom_solve_uuid_box(char *UUID);\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 creationTime;\n\tu64 modificationTime;\n\tu32 timeScale;\n\tu64 duration;\n\tu64 original_duration;\n\tu32 nextTrackID;\n\tu32 preferredRate;\n\tu16 preferredVolume;\n\tchar reserved[10];\n\tu32 matrixA;\n\tu32 matrixB;\n\tu32 matrixU;\n\tu32 matrixC;\n\tu32 matrixD;\n\tu32 matrixV;\n\tu32 matrixW;\n\tu32 matrixX;\n\tu32 matrixY;\n\tu32 previewTime;\n\tu32 previewDuration;\n\tu32 posterTime;\n\tu32 selectionTime;\n\tu32 selectionDuration;\n\tu32 currentTime;\n} GF_MovieHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_Descriptor *descriptor;\n} GF_ObjectDescriptorBox;\n\n/*used for entry list*/\ntypedef struct\n{\n\tu64 segmentDuration;\n\ts64 mediaTime;\n\tu32 mediaRate;\n} GF_EdtsEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *entryList;\n} GF_EditListBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_EditListBox *editList;\n} GF_EditBox;\n\n\n/*used to classify boxes in the UserData GF_Box*/\ntypedef struct\n{\n\tu32 boxType;\n\tu8 uuid[16];\n\tGF_List *other_boxes;\n} GF_UserDataMap;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_List *recordList;\n} GF_UserDataBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_MovieHeaderBox *mvhd;\n\tGF_ObjectDescriptorBox *iods;\n\tGF_UserDataBox *udta;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tstruct __tag_mvex_box *mvex;\n#endif\n\t/*meta box if any*/\n\tstruct __tag_meta_box *meta;\n\t/*track boxes*/\n\tGF_List *trackList;\n\n\tGF_ISOFile *mov;\n\n} GF_MovieBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 creationTime;\n\tu64 modificationTime;\n\tu32 trackID;\n\tu32 reserved1;\n\tu64 duration;\n\tu32 reserved2[2];\n\tu16 layer;\n\tu16 alternate_group;\n\tu16 volume;\n\tu16 reserved3;\n\tu32 matrix[9];\n\tu32 width, height;\n} GF_TrackHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_TrackReferenceBox;\n\n\ntypedef struct {\n\tGF_ISOM_BOX\n\tGF_List *groups;\n} GF_TrackGroupBox;\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tu32 group_type;\n\tu32 track_group_id;\n} GF_TrackGroupTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_UserDataBox *udta;\n\tGF_TrackHeaderBox *Header;\n\tstruct __tag_media_box *Media;\n\tGF_EditBox *editBox;\n\tGF_TrackReferenceBox *References;\n\t/*meta box if any*/\n\tstruct __tag_meta_box *meta;\n\tGF_TrackGroupBox *groups;\n\n\tGF_MovieBox *moov;\n\t/*private for media padding*/\n\tu32 padding_bytes;\n\t/*private for editing*/\n\tchar *name;\n\t/*private for editing*/\n\tBool is_unpacked;\n\t/*private for checking dependency*/\n\tu32 originalFile;\n\tu32 originalID;\n\n\t//not sure about piff (not supposed to be stored in moov), but senc is in track according to CENC\n\tstruct __sample_encryption_box *sample_encryption;\n\n\t/*private for SVC/MVC extractors resolution*/\n\ts32 extractor_mode;\n\tBool has_base_layer;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu64 dts_at_seg_start;\n\tu32 sample_count_at_seg_start;\n\tBool first_traf_merged;\n\tBool present_in_scalable_segment;\n#endif\n} GF_TrackBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 creationTime;\n\tu64 modificationTime;\n\tu32 timeScale;\n\tu64 duration, original_duration;\n\tchar packedLanguage[4];\n\tu16 reserved;\n} GF_MediaHeaderBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 reserved1;\n\tu32 handlerType;\n\tu8 reserved2[12];\n\tchar *nameUTF8;\n\tBool store_counted_string;\n} GF_HandlerBox;\n\ntypedef struct __tag_media_box\n{\n\tGF_ISOM_BOX\n\tGF_TrackBox *mediaTrack;\n\tGF_MediaHeaderBox *mediaHeader;\n\tGF_HandlerBox *handler;\n\tstruct __tag_media_info_box *information;\n\tu64 BytesMissing;\n} GF_MediaBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *extended_language;\n} GF_ExtendedLanguageBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 reserved;\n} GF_VideoMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu16 balance;\n\tu16 reserved;\n} GF_SoundMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\t/*this is used for us INTERNALLY*/\n\tu32 subType;\n\tu32 maxPDUSize;\n\tu32 avgPDUSize;\n\tu32 maxBitrate;\n\tu32 avgBitrate;\n\tu32 slidingAverageBitrate;\n} GF_HintMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_MPEGMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_SubtitleMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_ODMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_OCRMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_SceneMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_DataReferenceBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_DataReferenceBox *dref;\n} GF_DataInformationBox;\n\n#define GF_ISOM_DATAENTRY_FIELDS\t\\\n\tchar *location;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOM_DATAENTRY_FIELDS\n} GF_DataEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOM_DATAENTRY_FIELDS\n} GF_DataEntryURLBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOM_DATAENTRY_FIELDS\n\tchar *nameURN;\n} GF_DataEntryURNBox;\n\ntypedef struct\n{\n\tu32 sampleCount;\n\tu32 sampleDelta;\n} GF_SttsEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_SttsEntry *entries;\n\tu32 nb_entries, alloc_size;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*cache for WRITE*/\n\tu32 w_currentSampleNum;\n\tu64 w_LastDTS;\n#endif\n\t/*cache for READ*/\n\tu32 r_FirstSampleInEntry;\n\tu32 r_currentEntryIndex;\n\tu64 r_CurrentDTS;\n} GF_TimeToSampleBox;\n\n\n/*TO CHECK - it could be reasonnable to only use 16bits for both count and offset*/\ntypedef struct\n{\n\tu32 sampleCount;\n\ts32 decodingOffset;\n} GF_DttsEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_DttsEntry *entries;\n\tu32 nb_entries, alloc_size;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tu32 w_LastSampleNumber;\n\t/*force one sample per entry*/\n\tBool unpack_mode;\n#endif\n\t/*Cache for read*/\n\tu32 r_currentEntryIndex;\n\tu32 r_FirstSampleInEntry;\n} GF_CompositionOffsetBox;\n\n\ntypedef struct\n{\n\tu32 SampleNumber;\n\tu32 fragmentCount;\n\tu16 *fragmentSizes;\n} GF_StsfEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *entryList;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*Cache for write*/\n\tGF_StsfEntry *w_currentEntry;\n\tu32 w_currentEntryIndex;\n#endif\n\t/*Cache for read*/\n\tu32 r_currentEntryIndex;\n\tGF_StsfEntry *r_currentEntry;\n} GF_SampleFragmentBox;\n\n\n#define GF_ISOM_SAMPLE_ENTRY_FIELDS\t\t\\\n\tGF_ISOM_UUID_BOX\t\t\t\t\t\\\n\tu16 dataReferenceIndex;\t\t\t\t\\\n\tchar reserved[ 6 ];\t\t\t\t\t\\\n\tu32 internal_type;\t\t\t\t\t\\\n\tGF_List *protections;\n\n/*base sample entry box (never used but for typecasting)*/\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n} GF_SampleEntryBox;\n\nvoid gf_isom_sample_entry_init(GF_SampleEntryBox *ptr);\nvoid gf_isom_sample_entry_predestroy(GF_SampleEntryBox *ptr);\nGF_Err gf_isom_base_sample_entry_read(GF_SampleEntryBox *ptr, GF_BitStream *bs);\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\t/*box type as specified in the file (not this box's type!!)*/\n\tu32 EntryType;\n\n\tchar *data;\n\tu32 data_size;\n} GF_GenericSampleEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ESD *desc;\n} GF_ESDBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 bufferSizeDB;\n\tu32 maxBitrate;\n\tu32 avgBitrate;\n} GF_BitRateBox;\n\nGF_BitRateBox *gf_isom_sample_entry_get_bitrate(GF_SampleEntryBox *ent, Bool create);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_List *descriptors;\n} GF_MPEG4ExtensionDescriptorsBox;\n\n/*for most MPEG4 media */\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\tGF_ESDBox *esd;\n\t/*used for hinting when extracting the OD stream...*/\n\tGF_SLConfig *slc;\n} GF_MPEGSampleEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *hdr;\n\tu32 hdr_size;\n} GF_LASERConfigurationBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\n\tGF_LASERConfigurationBox *lsr_config;\n\tGF_MPEG4ExtensionDescriptorsBox *descr;\n\n\t/*used for hinting when extracting the OD stream...*/\n\tGF_SLConfig *slc;\n} GF_LASeRSampleEntryBox;\n\n/*rewrites avcC based on the given esd - this destroys the esd*/\nGF_Err LSR_UpdateESD(GF_LASeRSampleEntryBox *lsr, GF_ESD *esd);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 hSpacing;\n\tu32 vSpacing;\n} GF_PixelAspectRatioBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 cleanApertureWidthN;\n\tu32 cleanApertureWidthD;\n\tu32 cleanApertureHeightN;\n\tu32 cleanApertureHeightD;\n\tu32 horizOffN;\n\tu32 horizOffD;\n\tu32 vertOffN;\n\tu32 vertOffD;\n} GF_CleanAppertureBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tBool all_ref_pics_intra;\n\tBool intra_pred_used;\n\tu32 max_ref_per_pic;\n\tu32 reserved;\n} GF_CodingConstraintsBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu16 predefined_rvc_config;\n\tu32 rvc_meta_idx;\n} GF_RVCConfigurationBox;\n\n#define GF_ISOM_VISUAL_SAMPLE_ENTRY\t\t\\\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\t\t\t\\\n\tu16 version;\t\t\t\t\t\t\\\n\tu16 revision;\t\t\t\t\t\t\\\n\tu32 vendor;\t\t\t\t\t\t\t\\\n\tu32 temporal_quality;\t\t\t\t\\\n\tu32 spatial_quality;\t\t\t\t\\\n\tu16 Width, Height;\t\t\t\t\t\\\n\tu32 horiz_res, vert_res;\t\t\t\\\n\tu32 entry_data_size;\t\t\t\t\\\n\tu16 frames_per_sample;\t\t\t\t\\\n\tchar compressor_name[33];\t\t\t\\\n\tu16 bit_depth;\t\t\t\t\t\t\\\n\ts16 color_table_index;\t\t\t\t\\\n\tGF_PixelAspectRatioBox *pasp;\t\t\\\n\tGF_CleanAppertureBox *clap;\t\t\\\n\tstruct __tag_protect_box *rinf;\t\t\t\t\\\n\tGF_RVCConfigurationBox *rvcc;\t\t\\\n\ntypedef struct\n{\n\tGF_ISOM_VISUAL_SAMPLE_ENTRY\n} GF_VisualSampleEntryBox;\n\nvoid gf_isom_video_sample_entry_init(GF_VisualSampleEntryBox *ent);\nGF_Err gf_isom_video_sample_entry_read(GF_VisualSampleEntryBox *ptr, GF_BitStream *bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\nvoid gf_isom_video_sample_entry_write(GF_VisualSampleEntryBox *ent, GF_BitStream *bs);\nvoid gf_isom_video_sample_entry_size(GF_VisualSampleEntryBox *ent);\n#endif\n\nvoid gf_isom_sample_entry_predestroy(GF_SampleEntryBox *ptr);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_AVCConfig *config;\n} GF_AVCConfigurationBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_HEVCConfig *config;\n} GF_HEVCConfigurationBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_3GPConfig cfg;\n} GF_3GPPConfigBox;\n\ntypedef struct\n{\n\tGF_ISOM_VISUAL_SAMPLE_ENTRY\n\tGF_ESDBox *esd;\n\t/*used for Publishing*/\n\tGF_SLConfig *slc;\n\n\t/*avc extensions - we merged with regular 'mp4v' box to handle isma E&A signaling of AVC*/\n\tGF_AVCConfigurationBox *avc_config;\n\tGF_AVCConfigurationBox *svc_config;\n\tGF_AVCConfigurationBox *mvc_config;\n\t/*hevc extension*/\n\tGF_HEVCConfigurationBox *hevc_config;\n\tGF_HEVCConfigurationBox *lhvc_config;\n\n\t/*ext descriptors*/\n\tGF_MPEG4ExtensionDescriptorsBox *descr;\n\t/*internally emulated esd*/\n\tGF_ESD *emul_esd;\n\n\t//3GPP\n\tGF_3GPPConfigBox *cfg_3gpp;\n\n\t/*iPod's hack*/\n\tGF_UnknownUUIDBox *ipod_ext;\n\n} GF_MPEGVisualSampleEntryBox;\n\nstatic const u8 GF_ISOM_IPOD_EXT[][16] = { { 0x6B, 0x68, 0x40, 0xF2, 0x5F, 0x24, 0x4F, 0xC5, 0xBA, 0x39, 0xA5, 0x1B, 0xCF, 0x03, 0x23, 0xF3} };\n\nBool gf_isom_is_nalu_based_entry(GF_MediaBox *mdia, GF_SampleEntryBox *_entry);\nGF_Err gf_isom_nalu_sample_rewrite(GF_MediaBox *mdia, GF_ISOSample *sample, u32 sampleNumber, GF_MPEGVisualSampleEntryBox *entry);\n\n/*this is the default visual sdst (to handle unknown media)*/\ntypedef struct\n{\n\tGF_ISOM_VISUAL_SAMPLE_ENTRY\n\t/*box type as specified in the file (not this box's type!!)*/\n\tu32 EntryType;\n\t/*opaque description data (ESDS in MP4, SMI in SVQ3, ...)*/\n\tchar *data;\n\tu32 data_size;\n} GF_GenericVisualSampleEntryBox;\n\n\n#define GF_ISOM_AUDIO_SAMPLE_ENTRY\t\\\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\t\t\\\n\tu16 version;\t\t\t\t\t\\\n\tu16 revision;\t\t\t\t\t\\\n\tu32 vendor;\t\t\t\t\t\t\\\n\tu16 channel_count;\t\t\t\t\\\n\tu16 bitspersample;\t\t\t\t\\\n\tu16 compression_id;\t\t\t\t\\\n\tu16 packet_size;\t\t\t\t\\\n\tu16 samplerate_hi;\t\t\t\t\\\n\tu16 samplerate_lo;\t\t\t\t\\\n\tu8 extensions[36];\t\t\t\t\\\n\n\ntypedef struct\n{\n\tGF_ISOM_AUDIO_SAMPLE_ENTRY\n} GF_AudioSampleEntryBox;\n\nvoid gf_isom_audio_sample_entry_init(GF_AudioSampleEntryBox *ptr);\nGF_Err gf_isom_audio_sample_entry_read(GF_AudioSampleEntryBox *ptr, GF_BitStream *bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\nvoid gf_isom_audio_sample_entry_write(GF_AudioSampleEntryBox *ptr, GF_BitStream *bs);\nvoid gf_isom_audio_sample_entry_size(GF_AudioSampleEntryBox *ptr);\n#endif\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_AC3Config cfg;\n} GF_AC3ConfigBox;\n\ntypedef struct\n{\n\tGF_ISOM_AUDIO_SAMPLE_ENTRY\n\t//for MPEG4 audio\n\tGF_ESDBox *esd;\n\tGF_SLConfig *slc;\n\t//for 3GPP audio\n\tGF_3GPPConfigBox *cfg_3gpp;\n\n\t//for AC3/EC3 audio\n\tGF_AC3ConfigBox *cfg_ac3;\n} GF_MPEGAudioSampleEntryBox;\n\n/*this is the default visual sdst (to handle unknown media)*/\ntypedef struct\n{\n\tGF_ISOM_AUDIO_SAMPLE_ENTRY\n\t/*box type as specified in the file (not this box's type!!)*/\n\tu32 EntryType;\n\t/*opaque description data (ESDS in MP4, ...)*/\n\tchar *data;\n\tu32 data_size;\n} GF_GenericAudioSampleEntryBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 profile;\n\tu8 level;\n\tu8 pathComponents;\n\tBool fullRequestHost;\n\tBool streamType;\n\tu8 containsRedundant;\n\tchar *textEncoding;\n\tchar *contentEncoding;\n} GF_DIMSSceneConfigBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *content_script_types;\n} GF_DIMSScriptTypesBox;\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\tGF_DIMSSceneConfigBox *config;\n\tGF_DIMSScriptTypesBox *scripts;\n} GF_DIMSSampleEntryBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *config;\n} GF_TextConfigBox;\n\n/*base metadata sample entry box for METT, METX, SBTT, STXT and STPP*/\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\tchar *content_encoding;\t//optional\n\tchar *mime_type; //for anything except metx\n\tchar *xml_namespace;\t//for metx and sttp only\n\tchar *xml_schema_loc;\t// for metx and sttp only\n\tGF_TextConfigBox *config; //optional for anything except metx and sttp\n} GF_MetaDataSampleEntryBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_SampleDescriptionBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\t/*if this is the compact version, sample size is actually fieldSize*/\n\tu32 sampleSize;\n\tu32 sampleCount;\n\tu32 alloc_size;\n\tu32 *sizes;\n} GF_SampleSizeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 nb_entries;\n\tu32 alloc_size;\n\tu32 *offsets;\n} GF_ChunkOffsetBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 nb_entries;\n\tu32 alloc_size;\n\tu64 *offsets;\n} GF_ChunkLargeOffsetBox;\n\ntypedef struct\n{\n\tu32 firstChunk;\n\tu32 nextChunk;\n\tu32 samplesPerChunk;\n\tu32 sampleDescriptionIndex;\n\tu8 isEdited;\n} GF_StscEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_StscEntry *entries;\n\tu32 alloc_size, nb_entries;\n\n\t/*0-based cache for READ. In WRITE mode, we always have 1 sample per chunk so no need for a cache*/\n\tu32 currentIndex;\n\t/*first sample number in this chunk*/\n\tu32 firstSampleInCurrentChunk;\n\tu32 currentChunk;\n\tu32 ghostNumber;\n} GF_SampleToChunkBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 alloc_size, nb_entries;\n\tu32 *sampleNumbers;\n\t/*cache for READ mode (in write we realloc no matter what)*/\n\tu32 r_LastSyncSample;\n\t/*0-based index in the array*/\n\tu32 r_LastSampleIndex;\n} GF_SyncSampleBox;\n\ntypedef struct\n{\n\tu32 shadowedSampleNumber;\n\ts32 syncSampleNumber;\n} GF_StshEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *entries;\n\t/*Cache for read mode*/\n\tu32 r_LastEntryIndex;\n\tu32 r_LastFoundSample;\n} GF_ShadowSyncBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 nb_entries;\n\tu16 *priorities;\n} GF_DegradationPriorityBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 SampleCount;\n\tu8 *padbits;\n} GF_PaddingBitsBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 sampleCount;\n\t/*each dep type is packed on 1 byte*/\n\tu8 *sample_info;\n} GF_SampleDependencyTypeBox;\n\n\ntypedef struct\n{\n\tu32 subsample_size;\n\tu8 subsample_priority;\n\tu8 discardable;\n\tu32 reserved;\n} GF_SubSampleEntry;\n\ntypedef struct\n{\n\tu32 sample_delta;\n\tGF_List *SubSamples;\n} GF_SubSampleInfoEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *Samples;\n} GF_SubSampleInformationBox;\n\nBool gf_isom_get_subsample_types(GF_ISOFile *movie, u32 track, u32 subs_index, u32 *flags);\nu32  gf_isom_sample_get_subsample_entry(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 entry_index, GF_SubSampleInfoEntry **sub_sample);\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err gf_isom_add_subsample_info(GF_SubSampleInformationBox *sub_samples, u32 sampleNumber, u32 subSampleSize, u8 priority, u32 reserved, Bool discardable);\n#endif\n\n/* Use to relate the composition and decoding timeline when signed composition is used*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\ts32 compositionToDTSShift;\n\ts32 leastDecodeToDisplayDelta;\n\ts32 greatestDecodeToDisplayDelta;\n\ts32 compositionStartTime;\n\ts32 compositionEndTime;\n} GF_CompositionToDecodeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 aux_info_type;\n\tu32 aux_info_type_parameter;\n\n\tu8 default_sample_info_size;\n\tu32 sample_count;\n\tu8 *sample_info_size;\n} GF_SampleAuxiliaryInfoSizeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 aux_info_type;\n\tu32 aux_info_type_parameter;\n\n\tu8 default_sample_info_size;\n\tu32 entry_count;  //1 or stco / trun count\n\tu32 *offsets;\n\tu64 *offsets_large;\n\n\tu64 offset_first_offset_field;\n} GF_SampleAuxiliaryInfoOffsetBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_TimeToSampleBox *TimeToSample;\n\tGF_CompositionOffsetBox *CompositionOffset;\n\tGF_CompositionToDecodeBox *CompositionToDecode;\n\tGF_SyncSampleBox *SyncSample;\n\tGF_SampleDescriptionBox *SampleDescription;\n\tGF_SampleSizeBox *SampleSize;\n\tGF_SampleToChunkBox *SampleToChunk;\n\t/*untyped, to handle 32 bits and 64 bits chunkOffsets*/\n\tGF_Box *ChunkOffset;\n\tGF_ShadowSyncBox *ShadowSync;\n\tGF_DegradationPriorityBox *DegradationPriority;\n\tGF_PaddingBitsBox *PaddingBits;\n\tGF_SampleDependencyTypeBox *SampleDep;\n\tGF_SampleFragmentBox *Fragments;\n\n//\tGF_SubSampleInformationBox *SubSamples;\n\tGF_List *sub_samples;\n\n\tGF_List *sampleGroups;\n\tGF_List *sampleGroupsDescription;\n\tu32 nb_sgpd_in_stbl;\n\tu32 nb_other_boxes_in_stbl;\n\n\tGF_List *sai_sizes;\n\tGF_List *sai_offsets;\n\n\tu32 MaxSamplePerChunk;\n\tu16 groupID;\n\tu16 trackPriority;\n\tu32 currentEntryIndex;\n\n\tBool no_sync_found;\n} GF_SampleTableBox;\n\ntypedef struct __tag_media_info_box\n{\n\tGF_ISOM_BOX\n\tGF_DataInformationBox *dataInformation;\n\tGF_SampleTableBox *sampleTable;\n\tGF_Box *InfoHeader;\n\tstruct __tag_data_map *scalableDataHandler;\n\tstruct __tag_data_map *dataHandler;\n\tu32 dataEntryIndex;\n} GF_MediaInformationBox;\n\nGF_Err stbl_AppendDependencyType(GF_SampleTableBox *stbl, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *data;\n\tu32 dataSize;\n\tu32 original_4cc;\n} GF_FreeSpaceBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar packedLanguageCode[4];\n\tchar *notice;\n} GF_CopyrightBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *schemeURI;\n\tchar *value;\n} GF_KindBox;\n\n\ntypedef struct\n{\n\tchar *name;\n\tu64 start_time;\n} GF_ChapterEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *list;\n} GF_ChapterListBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 reference_type;\n\tu32 trackIDCount;\n\tu32 *trackIDs;\n} GF_TrackReferenceTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 grouping_type;\n\tu32 group_id;\n\tu32 entity_id_count;\n\tu32 *entity_ids;\n} GF_EntityToGroupTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 majorBrand;\n\tu32 minorVersion;\n\tu32 altCount;\n\tu32 *altBrand;\n} GF_FileTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 *rates;\n\tu32 *times;\n\tu32 count;\n} GF_ProgressiveDownloadBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 switch_group;\n\tu32 alternate_group;\n\tu32 sub_track_id;\n\tu64 attribute_count;\n\tu32 *attribute_list;\n} GF_SubTrackInformationBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 grouping_type;\n\tu16 nb_groups;\n\tu32 *group_description_index;\n} GF_SubTrackSampleGroupBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_SubTrackInformationBox *info;\n\tGF_Box *strd;\n} GF_SubTrackBox;\n\n/*\n\t3GPP streaming text boxes\n*/\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 entry_count;\n\tGF_FontRecord *fonts;\n} GF_FontTableBox;\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\t\t\t\t\\\n\tu32 displayFlags;\n\ts8 horizontal_justification;\n\ts8 vertical_justification;\n\t/*ARGB*/\n\tu32 back_color;\n\tGF_BoxRecord default_box;\n\tGF_StyleRecord\tdefault_style;\n\tGF_FontTableBox *font_table;\n} GF_Tx3gSampleEntryBox;\n\n/*Apple specific*/\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\t\t\t\t\\\n\tu32 displayFlags;\n\tu32 textJustification;\n\tchar background_color[6], foreground_color[6];\n\tGF_BoxRecord default_box;\n\tu16 fontNumber;\n\tu16 fontFace;\n\tchar reserved1[8];\n\tu8 reserved2;\n\tu16 reserved3;\n\tchar *textName; /*font name*/\n} GF_TextSampleEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 entry_count;\n\tGF_StyleRecord *styles;\n} GF_TextStyleBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu16 startcharoffset;\n\tu16 endcharoffset;\n} GF_TextHighlightBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\t/*ARGB*/\n\tu32 hil_color;\n} GF_TextHighlightColorBox;\n\ntypedef struct\n{\n\tu32 highlight_endtime;\n\tu16 start_charoffset;\n\tu16 end_charoffset;\n} KaraokeRecord;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 highlight_starttime;\n\tu16 nb_entries;\n\tKaraokeRecord *records;\n} GF_TextKaraokeBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 scroll_delay;\n} GF_TextScrollDelayBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu16 startcharoffset;\n\tu16 endcharoffset;\n\tchar *URL;\n\tchar *URL_hint;\n} GF_TextHyperTextBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_BoxRecord box;\n} GF_TextBoxBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu16 startcharoffset;\n\tu16 endcharoffset;\n} GF_TextBlinkBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 wrap_flag;\n} GF_TextWrapBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 switchGroup;\n\tu32 *attributeList;\n\tu32 attributeListCount;\n} GF_TrackSelectionBox;\n\n/*\n\tMPEG-21 extensions\n*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *xml;\n} GF_XMLBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 data_length;\n\tchar *data;\n} GF_BinaryXMLBox;\n\ntypedef struct\n{\n\tu64 extent_offset;\n\tu64 extent_length;\n\tu64 extent_index;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*for storage only*/\n\tu64 original_extent_offset;\n#endif\n} GF_ItemExtentEntry;\n\ntypedef struct\n{\n\tu16 item_ID;\n\tu16 construction_method;\n\tu16 data_reference_index;\n\tu64 base_offset;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*for storage only*/\n\tu64 original_base_offset;\n#endif\n\tGF_List *extent_entries;\n} GF_ItemLocationEntry;\n\nvoid iloc_entry_del(GF_ItemLocationEntry *location);\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 offset_size;\n\tu8 length_size;\n\tu8 base_offset_size;\n\tu8 index_size;\n\tGF_List *location_entries;\n} GF_ItemLocationBox;\n\ntypedef\tstruct\n{\n\tGF_ISOM_FULL_BOX\n\tu16 item_ID;\n} GF_PrimaryItemBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *protection_information;\n} GF_ItemProtectionBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu16 item_ID;\n\tu16 item_protection_index;\n\tu32 item_type;\n\t/*zero-terminated strings*/\n\tchar *item_name;\n\tchar *content_type;\n\tchar *content_encoding;\n\t// needed to actually read the resource file, but not written in the MP21 file.\n\tchar *full_path;\n\t// if not 0, full_path is actually the data to write.\n\tu32 data_len;\n} GF_ItemInfoEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *item_infos;\n} GF_ItemInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 reference_type;\n\tu32 from_item_id;\n\tu32 reference_count;\n\tu32 *to_item_IDs;\n} GF_ItemReferenceTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *references;\n} GF_ItemReferenceBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 data_format;\n} GF_OriginalFormatBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 scheme_type;\n\tu32 scheme_version;\n\tchar *URI;\n} GF_SchemeTypeBox;\n\n/*ISMACryp specific*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\t/*zero-terminated string*/\n\tchar *URI;\n} GF_ISMAKMSBox;\n\n/*ISMACryp specific*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 salt;\n} GF_ISMACrypSaltBox;\n\n/*ISMACryp specific*/\ntypedef struct __isma_format_box\n{\n\tGF_ISOM_FULL_BOX\n\tu8 selective_encryption;\n\tu8 key_indicator_length;\n\tu8 IV_length;\n} GF_ISMASampleFormatBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_ISMAKMSBox *ikms;\n\tGF_ISMASampleFormatBox *isfm;\n\tGF_ISMACrypSaltBox *islt;\n\tstruct __oma_kms_box *odkm;\n\tstruct __cenc_tenc_box *tenc;\n\tstruct __piff_tenc_box *piff_tenc;\n\tstruct __adobe_drm_key_management_system_box *adkm;\n} GF_SchemeInformationBox;\n\ntypedef struct __tag_protect_box\n{\n\tGF_ISOM_BOX\n\tGF_OriginalFormatBox *original_format;\n\tGF_SchemeTypeBox *scheme_type;\n\tGF_SchemeInformationBox *info;\n} GF_ProtectionSchemeInfoBox;\ntypedef struct __tag_protect_box GF_RestrictedSchemeInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *descriptors;\n} GF_IPMPInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_IPMP_ToolList *ipmp_tools;\n\tGF_List *descriptors;\n} GF_IPMPControlBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n} GF_ItemPropertyContainerBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n\tGF_ItemPropertyContainerBox *property_container;\n\tstruct __item_association_box *property_association;\n} GF_ItemPropertiesBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n} GF_GroupListBox;\n\ntypedef struct __tag_meta_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_HandlerBox *handler;\n\tGF_PrimaryItemBox *primary_resource;\n\tGF_DataInformationBox *file_locations;\n\tGF_ItemLocationBox *item_locations;\n\tGF_ItemProtectionBox *protections;\n\tGF_ItemInfoBox *item_infos;\n\tGF_IPMPControlBox *IPMP_control;\n\tGF_ItemPropertiesBox *item_props;\n\tGF_ItemReferenceBox *item_refs;\n} GF_MetaBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 single_view_allowed;\n\tu32 stereo_scheme;\n\tu32 sit_len;\n\tchar *stereo_indication_type;\n} GF_StereoVideoBox;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\n/*V2 boxes - Movie Fragments*/\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 fragment_duration;\n} GF_MovieExtendsHeaderBox;\n\n\ntypedef struct __tag_mvex_box\n{\n\tGF_ISOM_BOX\n\tGF_List *TrackExList;\n\tGF_List *TrackExPropList;\n\tGF_MovieExtendsHeaderBox *mehd;\n\tGF_ISOFile *mov;\n} GF_MovieExtendsBox;\n\n/*the TrackExtends contains default values for the track fragments*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 trackID;\n\tu32 def_sample_desc_index;\n\tu32 def_sample_duration;\n\tu32 def_sample_size;\n\tu32 def_sample_flags;\n\tGF_TrackBox *track;\n\n\tGF_TrackFragmentRandomAccessBox *tfra;\n} GF_TrackExtendsBox;\n\n/*the TrackExtends contains default values for the track fragments*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 trackID;\n} GF_TrackExtensionPropertiesBox;\n\n/*indicates the seq num of this fragment*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 sequence_number;\n} GF_MovieFragmentHeaderBox;\n\n/*MovieFragment is a container IN THE FILE, contains 1 fragment*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_MovieFragmentHeaderBox *mfhd;\n\tGF_List *TrackList;\n\tGF_ISOFile *mov;\n\t/*offset in the file of moof or mdat (whichever comes first) for this fragment*/\n\tu64 fragment_offset;\n\tu32 mdat_size;\n\tchar *mdat;\n\n\t//temp storage of prft box\n\tu32 reference_track_ID;\n\tu64 ntp, timestamp;\n} GF_MovieFragmentBox;\n\n\n/*FLAGS for TRAF*/\nenum\n{\n\tGF_ISOM_TRAF_BASE_OFFSET\t=\t0x01,\n\tGF_ISOM_TRAF_SAMPLE_DESC\t=\t0x02,\n\tGF_ISOM_TRAF_SAMPLE_DUR\t=\t0x08,\n\tGF_ISOM_TRAF_SAMPLE_SIZE\t=\t0x10,\n\tGF_ISOM_TRAF_SAMPLE_FLAGS\t=\t0x20,\n\tGF_ISOM_TRAF_DUR_EMPTY\t=\t0x10000,\n\tGF_ISOM_MOOF_BASE_OFFSET\t=\t0x20000,\n};\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 trackID;\n\t/* all the following are optional fields */\n\tu64 base_data_offset;\n\tu32 sample_desc_index;\n\tu32 def_sample_duration;\n\tu32 def_sample_size;\n\tu32 def_sample_flags;\n\tu32 EmptyDuration;\n\tu8 IFrameSwitching;\n} GF_TrackFragmentHeaderBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 baseMediaDecodeTime;\n} GF_TFBaseMediaDecodeTimeBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_TrackFragmentHeaderBox *tfhd;\n\tGF_List *TrackRuns;\n\t/*keep a pointer to default flags*/\n\tGF_TrackExtendsBox *trex;\n\tGF_SampleDependencyTypeBox *sdtp;\n\n//\tGF_SubSampleInformationBox *subs;\n\tGF_List *sub_samples;\n\n\tGF_List *sampleGroups;\n\tGF_List *sampleGroupsDescription;\n\n\tGF_List *sai_sizes;\n\tGF_List *sai_offsets;\n\n\t//can be senc or PIFF psec\n\tstruct __sample_encryption_box *sample_encryption;\n\tstruct __traf_mss_timeext_box *tfxd; /*similar to PRFT but for Smooth Streaming*/\n\n\t/*when data caching is on*/\n\tu32 DataCache;\n\tGF_TFBaseMediaDecodeTimeBox *tfdt;\n\n\tu64 moof_start_in_bs;\n} GF_TrackFragmentBox;\n\n/*FLAGS for TRUN : specify what is written in the SampleTable of TRUN*/\nenum\n{\n\tGF_ISOM_TRUN_DATA_OFFSET\t= 0x01,\n\tGF_ISOM_TRUN_FIRST_FLAG\t\t= 0x04,\n\tGF_ISOM_TRUN_DURATION\t\t= 0x100,\n\tGF_ISOM_TRUN_SIZE\t\t\t= 0x200,\n\tGF_ISOM_TRUN_FLAGS\t\t\t= 0x400,\n\tGF_ISOM_TRUN_CTS_OFFSET\t\t= 0x800\n};\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 sample_count;\n\t/*the following are optional fields */\n\ts32 data_offset; /* unsigned for version 0 */\n\tu32 first_sample_flags;\n\t/*can be empty*/\n\tGF_List *entries;\n\n\t/*in write mode with data caching*/\n\tGF_BitStream *cache;\n} GF_TrackFragmentRunBox;\n\ntypedef struct\n{\n\tu32 Duration;\n\tu32 size;\n\tu32 flags;\n\ts32 CTS_Offset;\n\n\t/*internal*/\n\tu32 SAP_type;\n} GF_TrunEntry;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 majorBrand;\n\tu32 minorVersion;\n\tu32 altCount;\n\tu32 *altBrand;\n} GF_SegmentTypeBox;\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\n/*RTP Hint Track Sample Entry*/\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\tu16 HintTrackVersion;\n\tu16 LastCompatibleVersion;\n\tu32 MaxPacketSize;\n//\tGF_List *HintDataTable;\n\t/*this is where we store the current RTP sample in read/write mode*/\n\tstruct __tag_hint_sample *hint_sample;\n\t/*current hint sample in read mode, 1-based (0 is reset)*/\n\tu32 cur_sample;\n\tu32 pck_sn, ts_offset, ssrc;\n\tGF_TrackReferenceTypeBox *hint_ref;\n\n\t//for FEC\n\tu16 partition_entry_ID, FEC_overhead;\n} GF_HintSampleEntryBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 subType;\n\tchar *sdpText;\n} GF_RTPBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *sdpText;\n} GF_SDPBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\ts32 timeOffset;\n} GF_RTPOBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\t/*contains GF_SDPBox if in track, GF_RTPBox if in movie*/\n\tGF_Box *SDP;\n} GF_HintTrackInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 reserved;\n\tu8 prefered;\n\tu8 required;\n} GF_RelyHintBox;\n\n/***********************************************************\n\t\t\tdata entry tables for RTP\n***********************************************************/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 timeScale;\n} GF_TSHintEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 TimeOffset;\n} GF_TimeOffHintEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 SeqOffset;\n} GF_SeqOffHintEntryBox;\n\n\n\n/***********************************************************\n\t\t\thint track information boxes for RTP\n***********************************************************/\n\n/*Total number of bytes that will be sent, including 12-byte RTP headers, but not including any network headers*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbBytes;\n} GF_TRPYBox;\n\n/*32-bits version of trpy used in Darwin*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 nbBytes;\n} GF_TOTLBox;\n\n/*Total number of network packets that will be sent*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbPackets;\n} GF_NUMPBox;\n\n/*32-bits version of nump used in Darwin*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 nbPackets;\n} GF_NPCKBox;\n\n\n/*Total number of bytes that will be sent, not including 12-byte RTP headers*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbBytes;\n} GF_NTYLBox;\n\n/*32-bits version of tpyl used in Darwin*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 nbBytes;\n} GF_TPAYBox;\n\n/*Maximum data rate in bits per second.*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 granularity;\n\tu32 maxDataRate;\n} GF_MAXRBox;\n\n\n/*Total number of bytes from the media track to be sent*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbBytes;\n} GF_DMEDBox;\n\n/*Number of bytes of immediate data to be sent*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbBytes;\n} GF_DIMMBox;\n\n\n/*Number of bytes of repeated data to be sent*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbBytes;\n} GF_DREPBox;\n\n/*Smallest relative transmission time, in milliseconds. signed integer for smoothing*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\ts32 minTime;\n} GF_TMINBox;\n\n/*Largest relative transmission time, in milliseconds.*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\ts32 maxTime;\n} GF_TMAXBox;\n\n/*Largest packet, in bytes, including 12-byte RTP header*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 maxSize;\n} GF_PMAXBox;\n\n/*Longest packet duration, in milliseconds*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 maxDur;\n} GF_DMAXBox;\n\n/*32-bit payload type number, followed by rtpmap payload string */\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 payloadCode;\n\tchar *payloadString;\n} GF_PAYTBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *string;\n} GF_NameBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_HintInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 timestamp_sync;\n} GF_TimeStampSynchronyBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 ssrc;\n} GF_ReceivedSsrcBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 encryption_algorithm_rtp;\n\tu32 encryption_algorithm_rtcp;\n\tu32 integrity_algorithm_rtp;\n\tu32 integrity_algorithm_rtcp;\n\n\tGF_SchemeTypeBox *scheme_type;\n\tGF_SchemeInformationBox *info;\n} GF_SRTPProcessBox;\n\n/*Apple extension*/\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 reserved;\n\tchar *data;\n\tu32 dataSize;\n} GF_DataBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_DataBox *data;\n} GF_ListItemBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_ItemListBox;\n\n/*DECE*/\ntypedef struct\n{\n\tu8 pic_type;\n\tu8 dependency_level;\n} GF_TrickPlayBoxEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 entry_count;\n\tGF_TrickPlayBoxEntry *entries;\n} GF_TrickPlayBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8  baseLocation[256];\n\tu8 basePurlLocation[256];\n} GF_BaseLocationBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 profile_version;\n\tchar *APID;\n} GF_AssetInformationBox;\n\n/*OMA (P)DCF extensions*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 EncryptionMethod;\n\tu8 PaddingScheme;\n\tu64 PlaintextLength;\n\tchar *ContentID;\n\tchar *RightsIssuerURL;\n\tchar *TextualHeaders;\n\tu32 TextualHeadersLen;\n} GF_OMADRMCommonHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 GKEncryptionMethod;\n\tchar *GroupID;\n\tu16 GKLength;\n\tchar *GroupKey;\n} GF_OMADRMGroupIDBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_OMADRMMutableInformationBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar TransactionID[16];\n} GF_OMADRMTransactionTrackingBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *oma_ro;\n\tu32 oma_ro_size;\n} GF_OMADRMRightsObjectBox;\n\n/*identical*/\ntypedef struct __isma_format_box GF_OMADRMAUFormatBox;\n\ntypedef struct __oma_kms_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_OMADRMCommonHeaderBox *hdr;\n\tGF_OMADRMAUFormatBox *fmt;\n} GF_OMADRMKMSBox;\n\n\ntypedef struct\n{\n\tBool reference_type;\n\tu32 reference_size;\n\tu32 subsegment_duration;\n\tBool starts_with_SAP;\n\tu32 SAP_type;\n\tu32 SAP_delta_time;\n} GF_SIDXReference;\n\ntypedef struct __sidx_box\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 reference_ID;\n\tu32 timescale;\n\tu64 earliest_presentation_time;\n\tu64 first_offset;\n\tu32 nb_refs;\n\tGF_SIDXReference *refs;\n} GF_SegmentIndexBox;\n\ntypedef struct\n{\n\tu32 range_count;\n\tu8 *levels;\n\tu32 *range_sizes;\n} GF_Subsegment;\n\ntypedef struct __ssix_box\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 subsegment_count;\n\tGF_Subsegment *subsegments;\n} GF_SubsegmentIndexBox;\n\ntypedef struct\n{\n\tu32 track_id;\n\tBool padding_flag;\n\tu8 type;\n\tu32 grouping_type;\n\tu32 grouping_type_parameter;\n\tu32 sub_track_id;\n} GF_LevelAssignment;\n\ntypedef struct __leva_box\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 level_count;\n\tGF_LevelAssignment *levels;\n} GF_LevelAssignmentBox;\n\ntypedef struct __pcrInfo_box\n{\n\tGF_ISOM_BOX\n\tu32\tsubsegment_count;\n\tu64 *pcr_values;\n} GF_PcrInfoBox;\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\n/*Adobe specific boxes*/\ntypedef struct\n{\n\tu64 time;\n\tu64 offset;\n} GF_AfraEntry;\n\ntypedef struct\n{\n\tu64 time;\n\tu32 segment;\n\tu32 fragment;\n\tu64 afra_offset;\n\tu64 offset_from_afra;\n} GF_GlobalAfraEntry;\n\ntypedef struct __adobe_frag_random_access_box\n{\n\tGF_ISOM_FULL_BOX\n\tBool long_ids;\n\tBool long_offsets;\n\tBool global_entries;\n\tu8 reserved;\n\tu32 time_scale;\n\tu32 entry_count;\n\tGF_List *local_access_entries;\n\tu32 global_entry_count;\n\tGF_List *global_access_entries;\n} GF_AdobeFragRandomAccessBox;\n\ntypedef struct __adobe_bootstrap_info_box\n{\n\tGF_ISOM_FULL_BOX\n\tu32 bootstrapinfo_version;\n\tu8 profile;\n\tBool live;\n\tBool update;\n\tu8 reserved;\n\tu32 time_scale;\n\tu64 current_media_time;\n\tu64 smpte_time_code_offset;\n\tchar *movie_identifier;\n\tu8 server_entry_count;\n\tGF_List *server_entry_table;\n\tu8 quality_entry_count;\n\tGF_List *quality_entry_table;\n\tchar *drm_data;\n\tchar *meta_data;\n\tu8 segment_run_table_count;\n\tGF_List *segment_run_table_entries;\n\tu8 fragment_run_table_count;\n\tGF_List *fragment_run_table_entries;\n} GF_AdobeBootstrapInfoBox;\n\ntypedef struct\n{\n\tu32 first_segment;\n\tu32 fragment_per_segment;\n} GF_AdobeSegmentRunEntry;\n\ntypedef struct __adobe_segment_run_table_box\n{\n\tGF_ISOM_FULL_BOX\n\tu8 quality_entry_count;\n\tGF_List *quality_segment_url_modifiers;\n\tu32 segment_run_entry_count;\n\tGF_List *segment_run_entry_table;\n} GF_AdobeSegmentRunTableBox;\n\ntypedef struct\n{\n\tu32 first_fragment;\n\tu64 first_fragment_timestamp;\n\tu32 fragment_duration;\n\tu8 discontinuity_indicator;\n} GF_AdobeFragmentRunEntry;\n\ntypedef struct __adobe_fragment_run_table_box\n{\n\tGF_ISOM_FULL_BOX\n\tu32 timescale;\n\tu8 quality_entry_count;\n\tGF_List *quality_segment_url_modifiers;\n\tu32 fragment_run_entry_count;\n\tGF_List *fragment_run_entry_table;\n} GF_AdobeFragmentRunTableBox;\n\n#endif /*GPAC_DISABLE_ISOM_ADOBE*/\n\n\n/***********************************************************\n\t\t\tSample Groups\n***********************************************************/\ntypedef struct\n{\n\tu32 sample_count;\n\tu32 group_description_index;\n} GF_SampleGroupEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 grouping_type;\n\tu32 grouping_type_parameter;\n\n\tu32 entry_count;\n\tGF_SampleGroupEntry *sample_entries;\n\n} GF_SampleGroupBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 grouping_type;\n\tu32 default_length;\n\n\tu32 default_description_index;\n\tGF_List *group_descriptions;\n} GF_SampleGroupDescriptionBox;\n\n/*default entry */\ntypedef struct\n{\n\tu32 length;\n\tu8 *data;\n} GF_DefaultSampleGroupDescriptionEntry;\n\n/*VisualRandomAccessEntry - 'rap ' type*/\ntypedef struct\n{\n\tu8 num_leading_samples_known;\n\tu8 num_leading_samples;\n} GF_VisualRandomAccessEntry;\n\n/*RollRecoveryEntry - 'roll' and prol type*/\ntypedef struct\n{\n\ts16 roll_distance;\n} GF_RollRecoveryEntry;\n\n/*TemporalLevelEntry - 'tele' type*/\ntypedef struct\n{\n\tBool level_independently_decodable;\n} GF_TemporalLevelEntry;\n\n/*SAPEntry - 'sap ' type*/\ntypedef struct\n{\n\tBool dependent_flag;\n\tu8 SAP_type;\n} GF_SAPEntry;\n\n/*SAPEntry - 'sync' type*/\ntypedef struct\n{\n\tu8 NALU_type;\n} GF_SYNCEntry;\n\n/*Operating Points Information - 'oinf' type*/\ntypedef struct\n{\n\tu16 scalability_mask;\n\tGF_List* profile_tier_levels;\n\tGF_List* operating_points;\n\tGF_List* dependency_layers;\n} GF_OperatingPointsInformation;\n\nGF_OperatingPointsInformation *gf_isom_oinf_new_entry();\nvoid gf_isom_oinf_del_entry(void *entry);\nGF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs);\nGF_Err gf_isom_oinf_write_entry(void *entry, GF_BitStream *bs);\nu32 gf_isom_oinf_size_entry(void *entry);\nBool gf_isom_get_oinf_info(GF_ISOFile *file, u32 trackNumber, GF_OperatingPointsInformation **ptr);\n\n\n/*Operating Points Information - 'oinf' type*/\ntypedef struct\n{\n\tu8 layer_id;\n\tu8 min_TemporalId;\n\tu8 max_TemporalId;\n\tu8 sub_layer_presence_flags;\n} LHVCLayerInfoItem;\n\ntypedef struct\n{\n\tGF_List* num_layers_in_track;\n} GF_LHVCLayerInformation;\n\nGF_LHVCLayerInformation *gf_isom_linf_new_entry();\nvoid gf_isom_linf_del_entry(void *entry);\nGF_Err gf_isom_linf_read_entry(void *entry, GF_BitStream *bs);\nGF_Err gf_isom_linf_write_entry(void *entry, GF_BitStream *bs);\nu32 gf_isom_linf_size_entry(void *entry);\nBool gf_isom_get_linf_info(GF_ISOFile *file, u32 trackNumber, GF_LHVCLayerInformation **ptr);\n\n\n#define MAX_LHEVC_LAYERS\t64\n\ntypedef struct\n{\n\tu8 general_profile_space, general_tier_flag, general_profile_idc, general_level_idc;\n\tu32 general_profile_compatibility_flags;\n\tu64 general_constraint_indicator_flags;\n} LHEVC_ProfileTierLevel;\n\ntypedef struct\n{\n\tu8 ptl_idx;\n\tu8 layer_id;\n\tBool is_outputlayer, is_alternate_outputlayer;\n} LHEVC_LayerInfo;\n\ntypedef struct\n{\n\tu16 output_layer_set_idx;\n\tu8 max_temporal_id;\n\tu8 layer_count;\n\tLHEVC_LayerInfo layers_info[MAX_LHEVC_LAYERS];\n\tu16 minPicWidth, minPicHeight, maxPicWidth, maxPicHeight;\n\tu8 maxChromaFormat, maxBitDepth;\n\tBool frame_rate_info_flag, bit_rate_info_flag;\n\tu16 avgFrameRate;\n\tu8 constantFrameRate;\n\tu32 maxBitRate, avgBitRate;\n} LHEVC_OperatingPoint;\n\n\ntypedef struct\n{\n\tu8 dependent_layerID;\n\tu8 num_layers_dependent_on;\n\tu8 dependent_on_layerID[MAX_LHEVC_LAYERS];\n\tu8 dimension_identifier[16];\n} LHEVC_DependentLayer;\n\n\n/*\n\t\tCENC stuff\n*/\n\n/*CENCSampleEncryptionGroupEntry - 'seig' type*/\ntypedef struct\n{\n\tu8 crypt_byte_block, skip_byte_block;\n\tu8 IsProtected;\n\tu8 Per_Sample_IV_size;\n\tbin128 KID;\n\tu8 constant_IV_size;\n\tbin128 constant_IV;\n} GF_CENCSampleEncryptionGroupEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tbin128 SystemID;\n\tu32 KID_count;\n\tbin128 *KIDs;\n\tu32 private_data_size;\n\tu8 *private_data;\n} GF_ProtectionSystemHeaderBox;\n\ntypedef struct __cenc_tenc_box\n{\n\tGF_ISOM_FULL_BOX\n\n\tu8 crypt_byte_block, skip_byte_block;\n\tu8 isProtected;\n\tu8 Per_Sample_IV_Size;\n\tbin128 KID;\n\tu8 constant_IV_size;\n\tbin128 constant_IV;\n} GF_TrackEncryptionBox;\n\ntypedef struct __piff_tenc_box\n{\n\tGF_ISOM_UUID_BOX\n\tu8 version;\n\tu32 flags;\n\n\tu32 AlgorithmID;\n\tu8 IV_size;\n\tbin128 KID;\n} GF_PIFFTrackEncryptionBox;\n\ntypedef struct\n{\n\tGF_ISOM_UUID_BOX\n\tu8 version;\n\tu32 flags;\n\n\tbin128 SystemID;\n\tu32 private_data_size;\n\tu8 *private_data;\n} GF_PIFFProtectionSystemHeaderBox;\n\n\ntypedef struct __sample_encryption_box\n{\n\tGF_ISOM_UUID_BOX\n\tu8 version;\n\tu32 flags;\n\n\tBool is_piff;\n\n\tGF_List *samp_aux_info; /*GF_CENCSampleAuxInfo*/\n\tu64 bs_offset;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t/*pointer to container traf*/\n\tGF_TrackFragmentBox *traf;\n#endif\n\t/*pointer to associated saio*/\n\tGF_SampleAuxiliaryInfoSizeBox *cenc_saiz;\n\tGF_SampleAuxiliaryInfoOffsetBox *cenc_saio;\n\n\n\tu32 AlgorithmID;\n\tu8 IV_size;\n\tbin128 KID;\n\n} GF_SampleEncryptionBox;\n\ntypedef struct __traf_mss_timeext_box\n{\n\tGF_ISOM_UUID_BOX\n\tu8 version;\n\tu32 flags;\n\n\tu64 absolute_time_in_track_timescale;\n\tu64 fragment_duration_in_track_timescale;\n} GF_MSSTimeExtBox;\n\nGF_SampleEncryptionBox *gf_isom_create_piff_psec_box(u8 version, u32 flags, u32 AlgorithmID, u8 IV_size, bin128 KID);\nGF_SampleEncryptionBox * gf_isom_create_samp_enc_box(u8 version, u32 flags);\n\nvoid gf_isom_cenc_get_default_info_ex(GF_TrackBox *trak, u32 sampleDescriptionIndex, u32 *default_IsEncrypted, u8 *default_IV_size, bin128 *default_KID, u8 *constant_IV_size, bin128 *constant_IV, u8 *crypt_byte_block, u8 *skip_byte_block);\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err gf_isom_get_sample_cenc_info_ex(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc, u32 sample_number, u32 *IsEncrypted, u8 *IV_size, bin128 *KID, u8 *crypt_byte_block, u8 *skip_byte_block, u8 *constant_IV_size, bin128 *constant_IV);\nGF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *ptr);\n#else\nGF_Err gf_isom_get_sample_cenc_info_ex(GF_TrackBox *trak, void *traf, uGF_SampleEncryptionBox *senc, 32 sample_number, u32 *IsEncrypted, u8 *IV_size, bin128 *KID,\n\t\t\t\t\t\t\t\t\t\tu8 *crypt_byte_block, u8 *skip_byte_block, u8 *constant_IV_size, bin128 *constant_IV);\nGF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *ptr);\n#endif\n\n/*\n\tBoxes for Adobe's protection scheme\n*/\ntypedef struct __adobe_enc_info_box\n{\n\tGF_ISOM_FULL_BOX\n\tchar *enc_algo; /*spec: The encryption algorithm shall be 'AES-CBC'*/\n\tu8 key_length;\n} GF_AdobeEncryptionInfoBox;\n\ntypedef struct __adobe_flash_access_params_box\n{\n\tGF_ISOM_BOX\n\tchar *metadata; /*base-64 encoded metadata used by the DRM client to retrieve decrypted key*/\n} GF_AdobeFlashAccessParamsBox;\n\ntypedef struct __adobe_key_info_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_AdobeFlashAccessParamsBox * params; /*spec: APSParamsBox will no longer be produced by conformaing applications*/\n} GF_AdobeKeyInfoBox;\n\ntypedef struct __adobe_std_enc_params_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_AdobeEncryptionInfoBox *enc_info;\n\tGF_AdobeKeyInfoBox *key_info;\n} GF_AdobeStdEncryptionParamsBox;\n\ntypedef struct __adobe_drm_header_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_AdobeStdEncryptionParamsBox *std_enc_params;\n\t//AdobeSignatureBox *signature; /*AdobeSignatureBox is not described*/\n} GF_AdobeDRMHeaderBox;\n\n\ntypedef struct __adobe_drm_au_format_box\n{\n\tGF_ISOM_FULL_BOX\n\tu8 selective_enc;\n\tu8 IV_length;\n} GF_AdobeDRMAUFormatBox;\n\ntypedef struct __adobe_drm_key_management_system_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_AdobeDRMHeaderBox *header;\n\tGF_AdobeDRMAUFormatBox *au_format;\n} GF_AdobeDRMKeyManagementSystemBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 refTrackID;\n\tu64 ntp, timestamp;\n} GF_ProducerReferenceTimeBox;\n\n/* Image File Format Structures */\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tu32 image_width;\n\tu32 image_height;\n} GF_ImageSpatialExtentsPropertyBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n\tu32 colour_type;\n\tu16 colour_primaries;\n\tu16 transfer_characteristics;\n\tu16 matrix_coefficients;\n\tBool full_range_flag;\n\tu8 *opaque;\n\tu32 opaque_size;\n} GF_ColourInformationBox;\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tu8 num_channels;\n\tu8 *bits_per_channel;\n} GF_PixelInformationPropertyBox;\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tu32 horizontal_offset;\n\tu32 vertical_offset;\n} GF_RelativeLocationPropertyBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n\tu8 angle;\n} GF_ImageRotationBox;\n\ntypedef struct {\n\tu32 item_id;\n\tGF_List *essential;\n\tGF_List *property_index;\n} GF_ItemPropertyAssociationEntry;\n\ntypedef struct __item_association_box {\n\tGF_ISOM_FULL_BOX\n\tGF_List *entries;\n} GF_ItemPropertyAssociationBox;\n\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tchar *aux_urn;\n\tu32 data_size;\n\tchar *data;\n} GF_AuxiliaryTypePropertyBox;\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\n\tGF_OperatingPointsInformation *oinf;\n} GF_OINFPropertyBox;\n\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\n\tu16 target_ols_index;\n} GF_TargetOLSPropertyBox;\n\n/*flute hint track boxes*/\ntypedef struct\n{\n\tu16 block_count;\n\tu32 block_size;\n} FilePartitionEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 itemID;\n\tu16 packet_payload_size;\n\tu8 FEC_encoding_ID;\n\tu16 FEC_instance_ID;\n\tu16 max_source_block_length;\n\tu16 encoding_symbol_length;\n\tu16 max_number_of_encoding_symbols;\n\tchar *scheme_specific_info;\n\tu32 nb_entries;\n\tFilePartitionEntry *entries;\n} FilePartitionBox;\n\ntypedef struct\n{\n\tu32 item_id;\n\tu32 symbol_count;\n} FECReservoirEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 nb_entries;\n\tFECReservoirEntry *entries;\n} FECReservoirBox;\n\ntypedef struct\n{\n\tu32 nb_groups;\n\tu32 *group_ids;\n\tu32 nb_channels;\n\tu32 *channels;\n} SessionGroupEntry;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu16 num_session_groups;\n\tSessionGroupEntry *session_groups;\n} FDSessionGroupBox;\n\ntypedef struct\n{\n\tu32 group_id;\n\tchar *name;\n} GroupIdNameEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu16 nb_entries;\n\tGroupIdNameEntry *entries;\n} GroupIdToNameBox;\n\n\ntypedef struct\n{\n\tu32 item_id;\n\tu32 symbol_count;\n} FileReservoirEntry;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 nb_entries;\n\tFileReservoirEntry *entries;\n} FileReservoirBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tFilePartitionBox *blocks_and_symbols;\n\tFECReservoirBox *FEC_symbol_locations;\n\tFileReservoirBox *File_symbol_locations;\n} FDPartitionEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *partition_entries;\n\tFDSessionGroupBox *session_info;\n\tGroupIdToNameBox *group_id_to_name;\n} FDItemInformationBox;\n\n\n/*\n\t\tData Map (media storage) stuff\n*/\n\n/*regular file IO*/\n#define GF_ISOM_DATA_FILE         0x01\n/*File Mapping object, read-only mode on complete files (no download)*/\n#define GF_ISOM_DATA_FILE_MAPPING 0x02\n/*External file object. Needs implementation*/\n#define GF_ISOM_DATA_FILE_EXTERN  0x03\n/*regular memory IO*/\n#define GF_ISOM_DATA_MEM          0x04\n\n/*Data Map modes*/\nenum\n{\n\t/*read mode*/\n\tGF_ISOM_DATA_MAP_READ = 1,\n\t/*write mode*/\n\tGF_ISOM_DATA_MAP_WRITE = 2,\n\t/*the following modes are just ways of signaling extended functionalities\n\tedit mode, to make sure the file is here, set to GF_ISOM_DATA_MAP_READ afterwards*/\n\tGF_ISOM_DATA_MAP_EDIT = 3,\n\t/*read-only access to the movie file: we create a file mapping object\n\tmode is set to GF_ISOM_DATA_MAP_READ afterwards*/\n\tGF_ISOM_DATA_MAP_READ_ONLY = 4,\n\t/*write-only access at the end of the movie - only used for movie fragments concatenation*/\n\tGF_ISOM_DATA_MAP_CAT = 5,\n};\n\n/*this is the DataHandler structure each data handler has its own bitstream*/\n#define GF_ISOM_BASE_DATA_HANDLER\t\\\n\tu8\ttype;\t\t\\\n\tu64\tcurPos;\t\t\\\n\tu8\tmode;\t\t\\\n\tGF_BitStream *bs;\\\n\tchar *szName;\n\ntypedef struct __tag_data_map\n{\n\tGF_ISOM_BASE_DATA_HANDLER\n} GF_DataMap;\n\ntypedef struct\n{\n\tGF_ISOM_BASE_DATA_HANDLER\n\tFILE *stream;\n\tBool is_stdout;\n\tBool last_acces_was_read;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tchar *temp_file;\n#endif\n} GF_FileDataMap;\n\n/*file mapping handler. used if supported, only on read mode for complete files  (not in file download)*/\ntypedef struct\n{\n\tGF_ISOM_BASE_DATA_HANDLER\n\tchar *name;\n\tu64 file_size;\n\tchar *byte_map;\n\tu64 byte_pos;\n} GF_FileMappingDataMap;\n\nGF_Err gf_isom_datamap_new(const char *location, const char *parentPath, u8 mode, GF_DataMap **outDataMap);\nvoid gf_isom_datamap_del(GF_DataMap *ptr);\nGF_Err gf_isom_datamap_open(GF_MediaBox *minf, u32 dataRefIndex, u8 Edit);\nvoid gf_isom_datamap_close(GF_MediaInformationBox *minf);\nu32 gf_isom_datamap_get_data(GF_DataMap *map, char *buffer, u32 bufferLength, u64 Offset);\n\n/*File-based data map*/\nGF_DataMap *gf_isom_fdm_new(const char *sPath, u8 mode);\nvoid gf_isom_fdm_del(GF_FileDataMap *ptr);\nu32 gf_isom_fdm_get_data(GF_FileDataMap *ptr, char *buffer, u32 bufferLength, u64 fileOffset);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_DataMap *gf_isom_fdm_new_temp(const char *sTempPath);\n#endif\n\n/*file-mapping, read only*/\nGF_DataMap *gf_isom_fmo_new(const char *sPath, u8 mode);\nvoid gf_isom_fmo_del(GF_FileMappingDataMap *ptr);\nu32 gf_isom_fmo_get_data(GF_FileMappingDataMap *ptr, char *buffer, u32 bufferLength, u64 fileOffset);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nu64 gf_isom_datamap_get_offset(GF_DataMap *map);\nGF_Err gf_isom_datamap_add_data(GF_DataMap *ptr, char *data, u32 dataSize);\n#endif\n\nvoid gf_isom_datamap_flush(GF_DataMap *map);\n\n/*\n\t\tMovie stuff\n*/\n\n\n/*time def for MP4/QT/MJ2K files*/\n#define GF_ISOM_MAC_TIME_OFFSET 2082844800\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n#define GF_ISOM_FORMAT_FRAG_FLAGS(pad, sync, deg) ( ( (pad) << 17) | ( ( !(sync) ) << 16) | (deg) );\n#define GF_ISOM_GET_FRAG_PAD(flag) ( (flag) >> 17) & 0x7\n#define GF_ISOM_GET_FRAG_SYNC(flag) ( ! ( ( (flag) >> 16) & 0x1))\n#define GF_ISOM_GET_FRAG_DEG(flag)\t(flag) & 0x7FFF\n\n#define GF_ISOM_GET_FRAG_LEAD(flag) ( (flag) >> 26) & 0x3\n#define GF_ISOM_GET_FRAG_DEPENDS(flag) ( (flag) >> 24) & 0x3\n#define GF_ISOM_GET_FRAG_DEPENDED(flag) ( (flag) >> 22) & 0x3\n#define GF_ISOM_GET_FRAG_REDUNDANT(flag) ( (flag) >> 20) & 0x3\n\n#define GF_ISOM_GET_FRAG_DEPEND_FLAGS(lead, depends, depended, redundant) ( (lead<<26) | (depends<<24) | (depended<<22) | (redundant<<20) )\n#define GF_ISOM_RESET_FRAG_DEPEND_FLAGS(flags) flags = flags & 0xFFFFF\n\nGF_TrackExtendsBox *GetTrex(GF_MovieBox *moov, u32 TrackID);\n#endif\n\nenum\n{\n\tGF_ISOM_FRAG_WRITE_READY\t=\t0x01,\n\tGF_ISOM_FRAG_READ_DEBUG\t\t=\t0x02,\n};\n\n/*this is our movie object*/\nstruct __tag_isom {\n\t/*the last fatal error*/\n\tGF_Err LastError;\n\t/*the original filename*/\n\tchar *fileName;\n\t/*the original file in read/edit, and also used in fragments mode\n\tonce the first moov has been written\n\tNota: this API doesn't allow fragments BEFORE the MOOV in order\n\tto make easily parsable files (note there could be some data (mdat) before\n\tthe moov*/\n\tGF_DataMap *movieFileMap;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*the final file name*/\n\tchar *finalName;\n\t/*the file where we store edited samples (for READ_WRITE and WRITE mode only)*/\n\tGF_DataMap *editFileMap;\n\t/*the interleaving time for dummy mode (in movie TimeScale)*/\n\tu32 interleavingTime;\n#endif\n\n\tu8 openMode;\n\tu8 storageMode;\n\t/*if true 3GPP text streams are read as MPEG-4 StreamingText*/\n\tu8 convert_streaming_text;\n\tu8 is_jp2;\n\tu8 force_co64;\n\n\tBool keep_utc, drop_date_version_info;\n\t/*main boxes for fast access*/\n\t/*moov*/\n\tGF_MovieBox *moov;\n\t/*our MDAT box (one and only one when we store the file)*/\n\tGF_MediaDataBox *mdat;\n\t/*file brand (since v2, NULL means mp4 v1)*/\n\tGF_FileTypeBox *brand;\n\t/*progressive download info*/\n\tGF_ProgressiveDownloadBox *pdin;\n\t/*meta box if any*/\n\tGF_MetaBox *meta;\n\n\tBool dump_mode_alloc;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 FragmentsFlags, NextMoofNumber;\n\t/*active fragment*/\n\tGF_MovieFragmentBox *moof;\n\t/*in WRITE mode, this is the current MDAT where data is written*/\n\t/*in READ mode this is the last valid file position before a gf_isom_box_read failed*/\n\tu64 current_top_box_start;\n\tu64 segment_start;\n\n\tGF_List *moof_list;\n\tBool use_segments, moof_first, append_segment, styp_written, force_moof_base_offset;\n\n\t/*used when building single-indexed self initializing media segments*/\n\tGF_SegmentIndexBox *root_sidx;\n\tu64 root_sidx_offset;\n\tu32 root_sidx_index;\n\n\tBool is_index_segment;\n\n\tGF_BitStream *segment_bs;\n\t/* 0: no moof found yet, 1: 1 moof found, 2: next moof found */\n\tBool single_moof_mode;\n\tu32 single_moof_state;\n\n\t/* optional mfra box used in write mode */\n\tGF_MovieFragmentRandomAccessBox *mfra;\n#endif\n\tGF_ProducerReferenceTimeBox *last_producer_ref_time;\n\n\t/*this contains ALL the root boxes excepts fragments*/\n\tGF_List *TopBoxes;\n\n\t/*default track for sync of MPEG4 streams - this is the first accessed stream without OCR info - only set in READ mode*/\n\ts32 es_id_default_sync;\n\n\tBool is_smooth;\n};\n\n/*time function*/\nu64 gf_isom_get_mp4time();\n/*set the last error of the file. if file is NULL, set the static error (used for IO errors*/\nvoid gf_isom_set_last_error(GF_ISOFile *the_file, GF_Err error);\nGF_Err gf_isom_parse_movie_boxes(GF_ISOFile *mov, u64 *bytesMissing, Bool progressive_mode);\nGF_ISOFile *gf_isom_new_movie();\n/*Movie and Track access functions*/\nGF_TrackBox *gf_isom_get_track_from_file(GF_ISOFile *the_file, u32 trackNumber);\nGF_TrackBox *gf_isom_get_track(GF_MovieBox *moov, u32 trackNumber);\nGF_TrackBox *gf_isom_get_track_from_id(GF_MovieBox *moov, u32 trackID);\nGF_TrackBox *gf_isom_get_track_from_original_id(GF_MovieBox *moov, u32 originalID, u32 originalFile);\nu32 gf_isom_get_tracknum_from_id(GF_MovieBox *moov, u32 trackID);\n/*open a movie*/\nGF_ISOFile *gf_isom_open_file(const char *fileName, u32 OpenMode, const char *tmp_dir);\n/*close and delete a movie*/\nvoid gf_isom_delete_movie(GF_ISOFile *mov);\n/*StreamDescription reconstruction Functions*/\nGF_Err GetESD(GF_MovieBox *moov, u32 trackID, u32 StreamDescIndex, GF_ESD **outESD);\nGF_Err GetESDForTime(GF_MovieBox *moov, u32 trackID, u64 CTS, GF_ESD **outESD);\nGF_Err Media_GetSampleDesc(GF_MediaBox *mdia, u32 SampleDescIndex, GF_SampleEntryBox **out_entry, u32 *dataRefIndex);\nGF_Err Media_GetSampleDescIndex(GF_MediaBox *mdia, u64 DTS, u32 *sampleDescIndex);\n/*get esd for given sample desc -\n\t@true_desc_only: if true doesn't emulate desc and returns native ESD,\n\t\t\t\totherwise emulates if needed/possible (TimedText) and return a hard copy of the desc\n*/\nGF_Err Media_GetESD(GF_MediaBox *mdia, u32 sampleDescIndex, GF_ESD **esd, Bool true_desc_only);\nBool Track_IsMPEG4Stream(u32 HandlerType);\nBool IsMP4Description(u32 entryType);\n/*Find a reference of a given type*/\nGF_Err Track_FindRef(GF_TrackBox *trak, u32 ReferenceType, GF_TrackReferenceTypeBox **dpnd);\n/*Time and sample*/\nGF_Err GetMediaTime(GF_TrackBox *trak, Bool force_non_empty, u64 movieTime, u64 *MediaTime, s64 *SegmentStartTime, s64 *MediaOffset, u8 *useEdit, u64 *next_edit_start_plus_one);\nGF_Err Media_GetSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample **samp, u32 *sampleDescriptionIndex, Bool no_data, u64 *out_offset);\nGF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex);\nGF_Err Media_FindSyncSample(GF_SampleTableBox *stbl, u32 searchFromTime, u32 *sampleNumber, u8 mode);\nGF_Err Media_RewriteODFrame(GF_MediaBox *mdia, GF_ISOSample *sample);\nGF_Err Media_FindDataRef(GF_DataReferenceBox *dref, char *URLname, char *URNname, u32 *dataRefIndex);\nBool Media_IsSelfContained(GF_MediaBox *mdia, u32 StreamDescIndex);\n\n\nGF_TrackBox *GetTrackbyID(GF_MovieBox *moov, u32 TrackID);\n\n/*check the TimeToSample for the given time and return the Sample number\nif the entry is not found, return the closest sampleNumber in prevSampleNumber and 0 in sampleNumber\nif the DTS required is after all DTSs in the list, set prevSampleNumber and SampleNumber to 0\nuseCTS specifies that we're looking for a composition time\n*/\nGF_Err stbl_findEntryForTime(GF_SampleTableBox *stbl, u64 DTS, u8 useCTS, u32 *sampleNumber, u32 *prevSampleNumber);\n/*Reading of the sample tables*/\nGF_Err stbl_GetSampleSize(GF_SampleSizeBox *stsz, u32 SampleNumber, u32 *Size);\nGF_Err stbl_GetSampleCTS(GF_CompositionOffsetBox *ctts, u32 SampleNumber, s32 *CTSoffset);\nGF_Err stbl_GetSampleDTS(GF_TimeToSampleBox *stts, u32 SampleNumber, u64 *DTS);\nGF_Err stbl_GetSampleDTS_and_Duration(GF_TimeToSampleBox *stts, u32 SampleNumber, u64 *DTS, u32 *duration);\n\n/*find a RAP or set the prev / next RAPs if vars are passed*/\nGF_Err stbl_GetSampleRAP(GF_SyncSampleBox *stss, u32 SampleNumber, SAPType *IsRAP, u32 *prevRAP, u32 *nextRAP);\n/*same as above but only look for open-gop RAPs and GDR (roll)*/\nGF_Err stbl_SearchSAPs(GF_SampleTableBox *stbl, u32 SampleNumber, SAPType *IsRAP, u32 *prevRAP, u32 *nextRAP);\nGF_Err stbl_GetSampleInfos(GF_SampleTableBox *stbl, u32 sampleNumber, u64 *offset, u32 *chunkNumber, u32 *descIndex, u8 *isEdited);\nGF_Err stbl_GetSampleShadow(GF_ShadowSyncBox *stsh, u32 *sampleNumber, u32 *syncNum);\nGF_Err stbl_GetPaddingBits(GF_PaddingBitsBox *padb, u32 SampleNumber, u8 *PadBits);\nu32 stbl_GetSampleFragmentCount(GF_SampleFragmentBox *stsf, u32 sampleNumber);\nu32 stbl_GetSampleFragmentSize(GF_SampleFragmentBox *stsf, u32 sampleNumber, u32 FragmentIndex);\nGF_Err stbl_GetSampleDepType(GF_SampleDependencyTypeBox *stbl, u32 SampleNumber, u32 *isLeading, u32 *dependsOn, u32 *dependedOn, u32 *redundant);\n\n\n/*unpack sample2chunk and chunk offset so that we have 1 sample per chunk (edition mode only)*/\nGF_Err stbl_UnpackOffsets(GF_SampleTableBox *stbl);\nGF_Err stbl_unpackCTS(GF_SampleTableBox *stbl);\nGF_Err SetTrackDuration(GF_TrackBox *trak);\nGF_Err Media_SetDuration(GF_TrackBox *trak);\n\n/*rewrites 3GP samples desc as MPEG-4 ESD*/\nGF_Err gf_isom_get_ttxt_esd(GF_MediaBox *mdia, GF_ESD **out_esd);\n/*inserts TTU header - only used when conversion to StreamingText is on*/\nGF_Err gf_isom_rewrite_text_sample(GF_ISOSample *samp, u32 sampleDescriptionIndex, u32 sample_dur);\n\nGF_UserDataMap *udta_getEntry(GF_UserDataBox *ptr, u32 box_type, bin128 *uuid);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err FlushCaptureMode(GF_ISOFile *movie);\nGF_Err CanAccessMovie(GF_ISOFile *movie, u32 Mode);\nGF_ISOFile *gf_isom_create_movie(const char *fileName, u32 OpenMode, const char *tmp_dir);\nvoid gf_isom_insert_moov(GF_ISOFile *file);\n\nGF_Err WriteToFile(GF_ISOFile *movie);\nGF_Err Track_SetStreamDescriptor(GF_TrackBox *trak, u32 StreamDescriptionIndex, u32 DataReferenceIndex, GF_ESD *esd, u32 *outStreamIndex);\nu8 RequestTrack(GF_MovieBox *moov, u32 TrackID);\n/*Track-Media setup*/\nGF_Err NewMedia(GF_MediaBox **mdia, u32 MediaType, u32 TimeScale);\nGF_Err Media_ParseODFrame(GF_MediaBox *mdia, const GF_ISOSample *sample, GF_ISOSample **od_samp);\nGF_Err Media_AddSample(GF_MediaBox *mdia, u64 data_offset, const GF_ISOSample *sample, u32 StreamDescIndex, u32 syncShadowNumber);\nGF_Err Media_CreateDataRef(GF_DataReferenceBox *dref, char *URLname, char *URNname, u32 *dataRefIndex);\n/*update a media sample. ONLY in edit mode*/\nGF_Err Media_UpdateSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample *sample, Bool data_only);\nGF_Err Media_UpdateSampleReference(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample *sample, u64 data_offset);\n/*addition in the sample tables*/\nGF_Err stbl_AddDTS(GF_SampleTableBox *stbl, u64 DTS, u32 *sampleNumber, u32 LastAUDefDuration);\nGF_Err stbl_AddCTS(GF_SampleTableBox *stbl, u32 sampleNumber, s32 CTSoffset);\nGF_Err stbl_AddSize(GF_SampleSizeBox *stsz, u32 sampleNumber, u32 size);\nGF_Err stbl_AddRAP(GF_SyncSampleBox *stss, u32 sampleNumber);\nGF_Err stbl_AddShadow(GF_ShadowSyncBox *stsh, u32 sampleNumber, u32 shadowNumber);\nGF_Err stbl_AddChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u32 StreamDescIndex, u64 offset);\n/*NB - no add for padding, this is done only through SetPaddingBits*/\n\nGF_Err stbl_AddSampleFragment(GF_SampleTableBox *stbl, u32 sampleNumber, u16 size);\n\n/*update of the sample table\nall these functions are called in edit and we always have 1 sample per chunk*/\nGF_Err stbl_SetChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u64 offset);\nGF_Err stbl_SetSampleCTS(GF_SampleTableBox *stbl, u32 sampleNumber, s32 offset);\nGF_Err stbl_SetSampleSize(GF_SampleSizeBox *stsz, u32 SampleNumber, u32 size);\nGF_Err stbl_SetSampleRAP(GF_SyncSampleBox *stss, u32 SampleNumber, u8 isRAP);\nGF_Err stbl_SetSyncShadow(GF_ShadowSyncBox *stsh, u32 sampleNumber, u32 syncSample);\nGF_Err stbl_SetPaddingBits(GF_SampleTableBox *stbl, u32 SampleNumber, u8 bits);\n/*for adding fragmented samples*/\nGF_Err stbl_SampleSizeAppend(GF_SampleSizeBox *stsz, u32 data_size);\n/*writing of the final chunk info in edit mode*/\nGF_Err stbl_SetChunkAndOffset(GF_SampleTableBox *stbl, u32 sampleNumber, u32 StreamDescIndex, GF_SampleToChunkBox *the_stsc, GF_Box **the_stco, u64 data_offset, u8 forceNewChunk);\n/*EDIT LIST functions*/\nGF_EdtsEntry *CreateEditEntry(u64 EditDuration, u64 MediaTime, u8 EditMode);\n\nGF_Err stbl_SetRedundant(GF_SampleTableBox *stbl, u32 sampleNumber);\nGF_Err stbl_AddRedundant(GF_SampleTableBox *stbl, u32 sampleNumber);\n\n/*REMOVE functions*/\nGF_Err stbl_RemoveDTS(GF_SampleTableBox *stbl, u32 sampleNumber, u32 LastAUDefDuration);\nGF_Err stbl_RemoveCTS(GF_SampleTableBox *stbl, u32 sampleNumber);\nGF_Err stbl_RemoveSize(GF_SampleSizeBox *stsz, u32 sampleNumber);\nGF_Err stbl_RemoveChunk(GF_SampleTableBox *stbl, u32 sampleNumber);\nGF_Err stbl_RemoveRAP(GF_SampleTableBox *stbl, u32 sampleNumber);\nGF_Err stbl_RemoveShadow(GF_ShadowSyncBox *stsh, u32 sampleNumber);\nGF_Err stbl_RemovePaddingBits(GF_SampleTableBox *stbl, u32 SampleNumber);\nGF_Err stbl_RemoveSampleFragments(GF_SampleTableBox *stbl, u32 sampleNumber);\nGF_Err stbl_RemoveRedundant(GF_SampleTableBox *stbl, u32 SampleNumber);\nGF_Err stbl_RemoveSubSample(GF_SampleTableBox *stbl, u32 SampleNumber);\nGF_Err stbl_RemoveSampleGroup(GF_SampleTableBox *stbl, u32 SampleNumber);\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err gf_isom_close_fragments(GF_ISOFile *movie);\nGF_Err gf_isom_copy_sample_group_entry_to_traf(GF_TrackFragmentBox *traf, GF_SampleTableBox *stbl, u32 grouping_type, u32 grouping_type_parameter, u32 sampleGroupDescriptionIndex, Bool sgpd_in_traf);\n#endif\n\nBool gf_isom_is_identical_sgpd(void *ptr1, void *ptr2, u32 grouping_type);\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_DefaultSampleGroupDescriptionEntry * gf_isom_get_sample_group_info_entry(GF_ISOFile *the_file, GF_TrackBox *trak, u32 grouping_type, u32 sample_description_index, u32 *default_index, GF_SampleGroupDescriptionBox **out_sgdp);\n\nGF_Err GetNextMediaTime(GF_TrackBox *trak, u64 movieTime, u64 *OutMovieTime);\nGF_Err GetPrevMediaTime(GF_TrackBox *trak, u64 movieTime, u64 *OutMovieTime);\n\nBool IsHintTrack(GF_TrackBox *trak);\nBool CheckHintFormat(GF_TrackBox *trak, u32 HintType);\nu32 GetHintFormat(GF_TrackBox *trak);\n\n\nvoid gf_isom_box_add_for_dump_mode(GF_Box *parent, GF_Box *a);\n\n/*locate a box by its type or UUID*/\nGF_ItemListBox *gf_ismo_locate_box(GF_List *list, u32 boxType, bin128 UUID);\n\nGF_Err moov_AddBox(GF_Box *ptr, GF_Box *a);\nGF_Err tref_AddBox(GF_Box *ptr, GF_Box *a);\nGF_Err trak_AddBox(GF_Box *ptr, GF_Box *a);\nGF_Err mvex_AddBox(GF_Box *ptr, GF_Box *a);\nGF_Err stsd_AddBox(GF_Box *ptr, GF_Box *a);\nGF_Err hnti_AddBox(GF_Box *hnti, GF_Box *a);\nGF_Err udta_AddBox(GF_Box *ptr, GF_Box *a);\nGF_Err edts_AddBox(GF_Box *s, GF_Box *a);\nGF_Err stdp_Read(GF_Box *s, GF_BitStream *bs);\nGF_Err stbl_AddBox(GF_Box *ptr, GF_Box *a);\nGF_Err sdtp_Read(GF_Box *s, GF_BitStream *bs);\nGF_Err dinf_AddBox(GF_Box *s, GF_Box *a);\nGF_Err minf_AddBox(GF_Box *s, GF_Box *a);\nGF_Err mdia_AddBox(GF_Box *s, GF_Box *a);\nGF_Err traf_AddBox(GF_Box *s, GF_Box *a);\n\n/*rewrites avcC based on the given esd - this destroys the esd*/\nGF_Err AVC_HEVC_UpdateESD(GF_MPEGVisualSampleEntryBox *avc, GF_ESD *esd);\nvoid AVC_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *avc, GF_MediaBox *mdia);\nvoid AVC_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *avc);\nvoid HEVC_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *avc, GF_MediaBox *mdia);\nvoid HEVC_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *avc);\n\nGF_Err reftype_AddRefTrack(GF_TrackReferenceTypeBox *ref, u32 trackID, u16 *outRefIndex);\nGF_XMLBox *gf_isom_get_meta_xml(GF_ISOFile *file, Bool root_meta, u32 track_num, Bool *is_binary);\nBool gf_isom_cenc_has_saiz_saio_track(GF_SampleTableBox *stbl, u32 scheme_type);\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nBool gf_isom_cenc_has_saiz_saio_traf(GF_TrackFragmentBox *traf, u32 scheme_type);\nvoid gf_isom_cenc_set_saiz_saio(GF_SampleEncryptionBox *senc, GF_SampleTableBox *stbl, GF_TrackFragmentBox  *traf, u32 len);\n#endif\nvoid gf_isom_cenc_merge_saiz_saio(GF_SampleEncryptionBox *senc, GF_SampleTableBox *stbl, u64 offset, u32 len);\n\nvoid gf_isom_parse_trif_info(const char *data, u32 size, u32 *id, u32 *independent, Bool *full_picture, u32 *x, u32 *y, u32 *w, u32 *h);\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\n/*\n\t\tHinting stuff\n*/\n\n/*****************************************************\n\t\tRTP Data Entries\n*****************************************************/\n\ntypedef struct\n{\n\tu8 sender_current_time_present;\n\tu8 expected_residual_time_present;\n\tu8 session_close_bit;\n\tu8 object_close_bit;\n\tu16 transport_object_identifier;\n} GF_LCTheaderTemplate;\n\ntypedef struct\n{\n\tu8 header_extension_type;\n\tu8 content[3];\n\tu32 data_length;\n\tchar *data;\n} GF_LCTheaderExtension;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\n\tGF_LCTheaderTemplate info;\n\tu16 header_ext_count;\n\tGF_LCTheaderExtension *headers;\n\n\tGF_List *constructors;\n} GF_FDpacketBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\n\tu8 FEC_encoding_ID;\n\tu16 FEC_instance_ID;\n\tu16 source_block_number;\n\tu16 encoding_symbol_ID;\n} GF_FECInformationBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\n\tGF_FECInformationBox *feci;\n\tu32 data_length;\n\tchar *data;\n} GF_ExtraDataBox;\n\n\n#define GF_ISMO_BASE_DTE_ENTRY\t\\\n\tu8 source;\n\ntypedef struct\n{\n\tGF_ISMO_BASE_DTE_ENTRY\n} GF_GenericDTE;\n\ntypedef struct\n{\n\tGF_ISMO_BASE_DTE_ENTRY\n} GF_EmptyDTE;\n\ntypedef struct\n{\n\tGF_ISMO_BASE_DTE_ENTRY\n\tu8 dataLength;\n\tchar data[14];\n} GF_ImmediateDTE;\n\ntypedef struct\n{\n\tGF_ISMO_BASE_DTE_ENTRY\n\ts8 trackRefIndex;\n\tu32 sampleNumber;\n\tu16 dataLength;\n\tu32 byteOffset;\n\tu16 bytesPerComp;\n\tu16 samplesPerComp;\n} GF_SampleDTE;\n\ntypedef struct\n{\n\tGF_ISMO_BASE_DTE_ENTRY\n\ts8 trackRefIndex;\n\tu32 streamDescIndex;\n\tu16 dataLength;\n\tu32 byteOffset;\n\tu32 reserved;\n} GF_StreamDescDTE;\n\nGF_GenericDTE *NewDTE(u8 type);\nvoid DelDTE(GF_GenericDTE *dte);\nGF_Err ReadDTE(GF_GenericDTE *dte, GF_BitStream *bs);\nGF_Err WriteDTE(GF_GenericDTE *dte, GF_BitStream *bs);\nGF_Err OffsetDTE(GF_GenericDTE *dte, u32 offset, u32 HintSampleNumber);\n\n/*****************************************************\n\t\tRTP Sample\n*****************************************************/\n\n/*data cache when reading*/\ntypedef struct __tag_hint_data_cache\n{\n\tGF_ISOSample *samp;\n\tGF_TrackBox *trak;\n\tu32 sample_num;\n} GF_HintDataCache;\n\ntypedef struct __tag_hint_sample\n{\n\t//for samples deriving from box\n\tGF_ISOM_BOX\n\n\t/*contains 4cc of hint track sample entry*/\n\tu32 hint_subtype;\n\tu16 packetCount;\n\tu16 reserved;\n\tGF_List *packetTable;\n\tchar *AdditionalData;\n\tu32 dataLength;\n\t/*used internally for hinting*/\n\tu64 TransmissionTime;\n\t/*for read only, used to store samples fetched while building packets*/\n\tGF_List *sample_cache;\n\n\t//for dump\n\tu32 trackID, sampleNumber;\n\n\tGF_ExtraDataBox *extra_data;\n} GF_HintSample;\n\nGF_HintSample *gf_isom_hint_sample_new(u32 ProtocolType);\nvoid gf_isom_hint_sample_del(GF_HintSample *ptr);\nGF_Err gf_isom_hint_sample_read(GF_HintSample *ptr, GF_BitStream *bs, u32 sampleSize);\nGF_Err gf_isom_hint_sample_write(GF_HintSample *ptr, GF_BitStream *bs);\nu32 gf_isom_hint_sample_size(GF_HintSample *ptr);\n\n\n/*****************************************************\n\t\tHint Packets (generic packet for future protocol support)\n*****************************************************/\n#define GF_ISOM_BASE_PACKET\t\t\t\\\n\tu32 hint_subtype, trackID, sampleNumber;\t\\\n\ts32 relativeTransTime;\n\n\ntypedef struct\n{\n\tGF_ISOM_BASE_PACKET\n} GF_HintPacket;\n\nGF_HintPacket *gf_isom_hint_pck_new(u32 HintType);\nvoid gf_isom_hint_pck_del(GF_HintPacket *ptr);\nGF_Err gf_isom_hint_pck_read(GF_HintPacket *ptr, GF_BitStream *bs);\nGF_Err gf_isom_hint_pck_write(GF_HintPacket *ptr, GF_BitStream *bs);\nu32 gf_isom_hint_pck_size(GF_HintPacket *ptr);\nGF_Err gf_isom_hint_pck_offset(GF_HintPacket *ptr, u32 offset, u32 HintSampleNumber);\nGF_Err gf_isom_hint_pck_add_dte(GF_HintPacket *ptr, GF_GenericDTE *dte, u8 AtBegin);\n/*get the size of the packet AS RECONSTRUCTED BY THE SERVER (without CSRC)*/\nu32 gf_isom_hint_pck_length(GF_HintPacket *ptr);\n\n/*the RTP packet*/\ntypedef struct\n{\n\tGF_ISOM_BASE_PACKET\n\n\t/*RTP Header*/\n\tu8 P_bit;\n\tu8 X_bit;\n\tu8 M_bit;\n\t/*on 7 bits */\n\tu8 payloadType;\n\tu16 SequenceNumber;\n\t/*Hinting flags*/\n\tu8 B_bit;\n\tu8 R_bit;\n\t/*ExtraInfos TLVs - not really used */\n\tGF_List *TLV;\n\t/*DataTable - contains the DTEs...*/\n\tGF_List *DataTable;\n} GF_RTPPacket;\n\nGF_RTPPacket *gf_isom_hint_rtp_new();\nvoid gf_isom_hint_rtp_del(GF_RTPPacket *ptr);\nGF_Err gf_isom_hint_rtp_read(GF_RTPPacket *ptr, GF_BitStream *bs);\nGF_Err gf_isom_hint_rtp_write(GF_RTPPacket *ptr, GF_BitStream *bs);\nu32 gf_isom_hint_rtp_size(GF_RTPPacket *ptr);\nGF_Err gf_isom_hint_rtp_offset(GF_RTPPacket *ptr, u32 offset, u32 HintSampleNumber);\nu32 gf_isom_hint_rtp_length(GF_RTPPacket *ptr);\n\n\n/*the RTP packet*/\ntypedef struct\n{\n\tGF_ISOM_BASE_PACKET\n\n\t//RTCP report\n\tu8 Version, Padding, Count, PayloadType;\n\tu32 length;\n\tchar *data;\n} GF_RTCPPacket;\n\nGF_RTCPPacket *gf_isom_hint_rtcp_new();\nvoid gf_isom_hint_rtcp_del(GF_RTCPPacket *ptr);\nGF_Err gf_isom_hint_rtcp_read(GF_RTCPPacket *ptr, GF_BitStream *bs);\nGF_Err gf_isom_hint_rtcp_write(GF_RTCPPacket *ptr, GF_BitStream *bs);\nu32 gf_isom_hint_rtcp_size(GF_RTCPPacket *ptr);\nu32 gf_isom_hint_rtcp_length(GF_RTCPPacket *ptr);\n\n\n#endif\n\n\nstruct _3gpp_text_sample\n{\n\tchar *text;\n\tu32 len;\n\n\tGF_TextStyleBox *styles;\n\t/*at most one of these*/\n\tGF_TextHighlightColorBox *highlight_color;\n\tGF_TextScrollDelayBox *scroll_delay;\n\tGF_TextBoxBox *box;\n\tGF_TextWrapBox *wrap;\n\n\tGF_List *others;\n\tGF_TextKaraokeBox *cur_karaoke;\n};\n\nGF_TextSample *gf_isom_parse_texte_sample(GF_BitStream *bs);\nGF_TextSample *gf_isom_parse_texte_sample_from_data(char *data, u32 dataLength);\n\nstruct _generic_subtitle_sample\n{\n\tchar *text;\n\tu32 len;\n};\nGF_GenericSubtitleSample *gf_isom_parse_generic_subtitle_sample(GF_BitStream *bs);\nGF_GenericSubtitleSample *gf_isom_parse_generic_subtitle_sample_from_data(char *data, u32 dataLength);\n\n\n/*do not throw fatal errors if boxes are duplicated, just warn and remove extra ones*/\n#define ERROR_ON_DUPLICATED_BOX(__abox, __parent) {\t\\\n\t\tchar __ptype[5];\\\n\t\tstrcpy(__ptype, gf_4cc_to_str(__parent->type) );\\\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] extra box %s found in %s, deleting\\n\", gf_4cc_to_str(__abox->type), __ptype)); \\\n\t\tgf_isom_box_del(a);\\\n\t\treturn GF_OK;\\\n\t}\n\n\n#ifndef GPAC_DISABLE_VTT\n\nGF_Err gf_isom_update_webvtt_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex, const char *config);\nGF_ISOSample *gf_isom_webvtt_to_sample(void *samp);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *string;\n} GF_StringBox;\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\tGF_StringBox *config;\n} GF_WebVTTSampleEntryBox;\n\nGF_WebVTTSampleEntryBox *gf_webvtt_isom_get_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex);\n\nGF_List *gf_webvtt_parse_cues_from_data(const char *data, u32 dataLength, u64 start);\n\n#endif /* GPAC_DISABLE_VTT */\n\n//exported for sgpd comparison in traf merge\nvoid sgpd_write_entry(u32 grouping_type, void *entry, GF_BitStream *bs);\nBool gf_isom_box_equal(GF_Box *a, GF_Box *b);\nGF_Box *gf_isom_clone_config_box(GF_Box *box);\n\nGF_Err gf_isom_box_dump(void *ptr, FILE * trace);\nGF_Err gf_isom_box_array_dump(GF_List *list, FILE * trace);\n\n/*Apple extensions*/\nGF_MetaBox *gf_isom_apple_get_meta_extensions(GF_ISOFile *mov);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_MetaBox *gf_isom_apple_create_meta_extensions(GF_ISOFile *mov);\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\nGF_Err gf_isom_box_dump_ex(void *ptr, FILE * trace, u32 box_4cc);\nGF_Err gf_isom_box_dump_start(GF_Box *a, const char *name, FILE * trace);\nvoid gf_isom_box_dump_done(const char *name, GF_Box *ptr, FILE *trace);\nBool gf_isom_box_is_file_level(GF_Box *s);\n#endif\n\nGF_Box *boxstring_new_with_data(u32 type, const char *string);\n\nGF_Err gf_isom_read_null_terminated_string(GF_Box *s, GF_BitStream *bs, u64 size, char **out_str);\n\n#endif //GPAC_DISABLE_ISOM\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif //_GF_ISOMEDIA_DEV_H_\n\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n\n\n#ifndef GPAC_DISABLE_ISOM\n\nvoid co64_del(GF_Box *s)\n{\n\tGF_ChunkLargeOffsetBox *ptr;\n\tptr = (GF_ChunkLargeOffsetBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tgf_free(ptr);\n}\n\nGF_Err co64_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 entries;\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\n\tif (ptr->nb_entries > ptr->size / 8) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in co64\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->offsets = (u64 *) gf_malloc(ptr->nb_entries * sizeof(u64) );\n\tif (ptr->offsets == NULL) return GF_OUT_OF_MEM;\n\tptr->alloc_size = ptr->nb_entries;\n\tfor (entries = 0; entries < ptr->nb_entries; entries++) {\n\t\tptr->offsets[entries] = gf_bs_read_u64(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *co64_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChunkLargeOffsetBox, GF_ISOM_BOX_TYPE_CO64);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err co64_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++ ) {\n\t\tgf_bs_write_u64(bs, ptr->offsets[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err co64_Size(GF_Box *s)\n{\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid cprt_del(GF_Box *s)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->notice)\n\t\tgf_free(ptr->notice);\n\tgf_free(ptr);\n}\n\n\nGF_Box *chpl_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChapterListBox, GF_ISOM_BOX_TYPE_CHPL);\n\ttmp->list = gf_list_new();\n\ttmp->version = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid chpl_del(GF_Box *s)\n{\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *) s;\n\tif (ptr == NULL) return;\n\twhile (gf_list_count(ptr->list)) {\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, 0);\n\t\tif (ce->name) gf_free(ce->name);\n\t\tgf_free(ce);\n\t\tgf_list_rem(ptr->list, 0);\n\t}\n\tgf_list_del(ptr->list);\n\tgf_free(ptr);\n}\n\n/*this is using chpl format according to some NeroRecode samples*/\nGF_Err chpl_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ChapterEntry *ce;\n\tu32 nb_chaps, len, i, count;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *)s;\n\n\t/*reserved or ???*/\n\tgf_bs_read_u32(bs);\n\tnb_chaps = gf_bs_read_u8(bs);\n\n\tcount = 0;\n\twhile (nb_chaps) {\n\t\tGF_SAFEALLOC(ce, GF_ChapterEntry);\n\t\tif (!ce) return GF_OUT_OF_MEM;\n\t\tce->start_time = gf_bs_read_u64(bs);\n\t\tlen = gf_bs_read_u8(bs);\n\t\tif (len) {\n\t\t\tce->name = (char *)gf_malloc(sizeof(char)*(len+1));\n\t\t\tgf_bs_read_data(bs, ce->name, len);\n\t\t\tce->name[len] = 0;\n\t\t} else {\n\t\t\tce->name = gf_strdup(\"\");\n\t\t}\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ChapterEntry *ace = (GF_ChapterEntry *) gf_list_get(ptr->list, i);\n\t\t\tif (ace->start_time >= ce->start_time) {\n\t\t\t\tgf_list_insert(ptr->list, ce, i);\n\t\t\t\tce = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ce) gf_list_add(ptr->list, ce);\n\t\tcount++;\n\t\tnb_chaps--;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err chpl_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tcount = gf_list_count(ptr->list);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u8(bs, count);\n\tfor (i=0; i<count; i++) {\n\t\tu32 len;\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tgf_bs_write_u64(bs, ce->start_time);\n\t\tif (ce->name) {\n\t\t\tlen = (u32) strlen(ce->name);\n\t\t\tif (len>255) len = 255;\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, ce->name, len);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err chpl_Size(GF_Box *s)\n{\n\tu32 count, i;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *)s;\n\n\tptr->size += 5;\n\n\tcount = gf_list_count(ptr->list);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tptr->size += 9; /*64bit time stamp + 8bit str len*/\n\t\tif (ce->name) ptr->size += strlen(ce->name);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Err cprt_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *)s;\n\n\tgf_bs_read_int(bs, 1);\n\t//the spec is unclear here, just says \"the value 0 is interpreted as undetermined\"\n\tptr->packedLanguageCode[0] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguageCode[1] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguageCode[2] = gf_bs_read_int(bs, 5);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\n\t//but before or after compaction ?? We assume before\n\tif (ptr->packedLanguageCode[0] || ptr->packedLanguageCode[1] || ptr->packedLanguageCode[2]) {\n\t\tptr->packedLanguageCode[0] += 0x60;\n\t\tptr->packedLanguageCode[1] += 0x60;\n\t\tptr->packedLanguageCode[2] += 0x60;\n\t} else {\n\t\tptr->packedLanguageCode[0] = 'u';\n\t\tptr->packedLanguageCode[1] = 'n';\n\t\tptr->packedLanguageCode[2] = 'd';\n\t}\n\tif (ptr->size) {\n\t\tu32 bytesToRead = (u32) ptr->size;\n\t\tptr->notice = (char*)gf_malloc(bytesToRead * sizeof(char));\n\t\tif (ptr->notice == NULL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->notice, bytesToRead);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *cprt_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CopyrightBox, GF_ISOM_BOX_TYPE_CPRT);\n\ttmp->packedLanguageCode[0] = 'u';\n\ttmp->packedLanguageCode[1] = 'n';\n\ttmp->packedLanguageCode[2] = 'd';\n\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err cprt_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, 0, 1);\n\tif (ptr->packedLanguageCode[0]) {\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[0] - 0x60, 5);\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[1] - 0x60, 5);\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[2] - 0x60, 5);\n\t} else {\n\t\tgf_bs_write_int(bs, 0, 15);\n\t}\n\tif (ptr->notice) {\n\t\tgf_bs_write_data(bs, ptr->notice, (u32) (strlen(ptr->notice) + 1) );\n\t}\n\treturn GF_OK;\n}\n\nGF_Err cprt_Size(GF_Box *s)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *)s;\n\n\tptr->size += 2;\n\tif (ptr->notice)\n\t\tptr->size += strlen(ptr->notice) + 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid kind_del(GF_Box *s)\n{\n\tGF_KindBox *ptr = (GF_KindBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->schemeURI) gf_free(ptr->schemeURI);\n\tif (ptr->value) gf_free(ptr->value);\n\tgf_free(ptr);\n}\n\nGF_Err kind_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_KindBox *ptr = (GF_KindBox *)s;\n\n\tif (ptr->size) {\n\t\tu32 bytesToRead = (u32) ptr->size;\n\t\tchar *data;\n\t\tu32 schemeURIlen;\n\t\tdata = (char*)gf_malloc(bytesToRead * sizeof(char));\n\t\tif (data == NULL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, data, bytesToRead);\n\t\t/*safety check in case the string is not null-terminated*/\n\t\tif (data[bytesToRead-1]) {\n\t\t\tchar *str = (char*)gf_malloc((u32) bytesToRead + 1);\n\t\t\tmemcpy(str, data, (u32) bytesToRead);\n\t\t\tstr[ptr->size] = 0;\n\t\t\tgf_free(data);\n\t\t\tdata = str;\n\t\t\tbytesToRead++;\n\t\t}\n\t\tptr->schemeURI = gf_strdup(data);\n\t\tschemeURIlen = (u32) strlen(data);\n\t\tif (bytesToRead > schemeURIlen+1) {\n\t\t\t/* read the value */\n\t\t\tchar *data_value = data + schemeURIlen +1;\n\t\t\tptr->value = gf_strdup(data_value);\n\t\t}\n\t\tgf_free(data);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *kind_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_KindBox, GF_ISOM_BOX_TYPE_KIND);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err kind_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_KindBox *ptr = (GF_KindBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->schemeURI, (u32) (strlen(ptr->schemeURI) + 1 ));\n\tif (ptr->value) {\n\t\tgf_bs_write_data(bs, ptr->value, (u32) (strlen(ptr->value) + 1) );\n\t}\n\treturn GF_OK;\n}\n\nGF_Err kind_Size(GF_Box *s)\n{\n\tGF_KindBox *ptr = (GF_KindBox *)s;\n\n\tptr->size += strlen(ptr->schemeURI) + 1;\n\tif (ptr->value) {\n\t\tptr->size += strlen(ptr->value) + 1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ctts_del(GF_Box *s)\n{\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\n\nGF_Err ctts_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tu32 sampleCount;\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tif (ptr->nb_entries > ptr->size / 8) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = (GF_DttsEntry *)gf_malloc(sizeof(GF_DttsEntry)*ptr->alloc_size);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\tsampleCount = 0;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->entries[i].sampleCount = gf_bs_read_u32(bs);\n\t\tif (ptr->version)\n\t\t\tptr->entries[i].decodingOffset = gf_bs_read_int(bs, 32);\n\t\telse\n\t\t\tptr->entries[i].decodingOffset = (s32) gf_bs_read_u32(bs);\n\t\tsampleCount += ptr->entries[i].sampleCount;\n\t}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tptr->w_LastSampleNumber = sampleCount;\n#endif\n\treturn GF_OK;\n}\n\nGF_Box *ctts_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompositionOffsetBox, GF_ISOM_BOX_TYPE_CTTS);\n\treturn (GF_Box *) tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ctts_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++ ) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleCount);\n\t\tif (ptr->version) {\n\t\t\tgf_bs_write_int(bs, ptr->entries[i].decodingOffset, 32);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) ptr->entries[i].decodingOffset);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ctts_Size(GF_Box *s)\n{\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *) s;\n\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid cslg_del(GF_Box *s)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n\treturn;\n}\n\nGF_Err cslg_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\tptr->compositionToDTSShift = gf_bs_read_int(bs, 32);\n\tptr->leastDecodeToDisplayDelta = gf_bs_read_int(bs, 32);\n\tptr->greatestDecodeToDisplayDelta = gf_bs_read_int(bs, 32);\n\tptr->compositionStartTime = gf_bs_read_int(bs, 32);\n\tptr->compositionEndTime = gf_bs_read_int(bs, 32);\n\treturn GF_OK;\n}\n\nGF_Box *cslg_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompositionToDecodeBox, GF_ISOM_BOX_TYPE_CSLG);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err cslg_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->compositionToDTSShift, 32);\n\tgf_bs_write_int(bs, ptr->leastDecodeToDisplayDelta, 32);\n\tgf_bs_write_int(bs, ptr->greatestDecodeToDisplayDelta, 32);\n\tgf_bs_write_int(bs, ptr->compositionStartTime, 32);\n\tgf_bs_write_int(bs, ptr->compositionEndTime, 32);\n\treturn GF_OK;\n}\n\nGF_Err cslg_Size(GF_Box *s)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\tptr->size += 20;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ccst_del(GF_Box *s)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\tif (ptr) gf_free(ptr);\n\treturn;\n}\n\nGF_Err ccst_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->all_ref_pics_intra = gf_bs_read_int(bs, 1);\n\tptr->intra_pred_used = gf_bs_read_int(bs, 1);\n\tptr->max_ref_per_pic = gf_bs_read_int(bs, 4);\n\tptr->reserved = gf_bs_read_int(bs, 26);\n\treturn GF_OK;\n}\n\nGF_Box *ccst_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CodingConstraintsBox, GF_ISOM_BOX_TYPE_CCST);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ccst_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->all_ref_pics_intra, 1);\n\tgf_bs_write_int(bs, ptr->intra_pred_used, 1);\n\tgf_bs_write_int(bs, ptr->max_ref_per_pic, 4);\n\tgf_bs_write_int(bs, 0, 26);\n\treturn GF_OK;\n}\n\nGF_Err ccst_Size(GF_Box *s)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid url_del(GF_Box *s)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->location) gf_free(ptr->location);\n\tgf_free(ptr);\n\treturn;\n}\n\n\nGF_Err url_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\tif (ptr->size) {\n\t\tptr->location = (char*)gf_malloc((u32) ptr->size);\n\t\tif (! ptr->location) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->location, (u32)ptr->size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *url_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataEntryURLBox, GF_ISOM_BOX_TYPE_URL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err url_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//the flag set indicates we have a string (WE HAVE TO for URLs)\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->location) {\n\t\t\tgf_bs_write_data(bs, ptr->location, (u32)strlen(ptr->location) + 1);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err url_Size(GF_Box *s)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->location) ptr->size += 1 + strlen(ptr->location);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid urn_del(GF_Box *s)\n{\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->location) gf_free(ptr->location);\n\tif (ptr->nameURN) gf_free(ptr->nameURN);\n\tgf_free(ptr);\n}\n\n\nGF_Err urn_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, to_read;\n\tchar *tmpName;\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\tif (! ptr->size ) return GF_OK;\n\n\t//here we have to handle that in a clever way\n\tto_read = (u32) ptr->size;\n\ttmpName = (char*)gf_malloc(sizeof(char) * to_read);\n\tif (!tmpName) return GF_OUT_OF_MEM;\n\t//get the data\n\tgf_bs_read_data(bs, tmpName, to_read);\n\n\t//then get the break\n\ti = 0;\n\twhile ( (tmpName[i] != 0) && (i < to_read) ) {\n\t\ti++;\n\t}\n\t//check the data is consistent\n\tif (i == to_read) {\n\t\tgf_free(tmpName);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t//no NULL char, URL is not specified\n\tif (i == to_read - 1) {\n\t\tptr->nameURN = tmpName;\n\t\tptr->location = NULL;\n\t\treturn GF_OK;\n\t}\n\t//OK, this has both URN and URL\n\tptr->nameURN = (char*)gf_malloc(sizeof(char) * (i+1));\n\tif (!ptr->nameURN) {\n\t\tgf_free(tmpName);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tptr->location = (char*)gf_malloc(sizeof(char) * (to_read - i - 1));\n\tif (!ptr->location) {\n\t\tgf_free(tmpName);\n\t\tgf_free(ptr->nameURN);\n\t\tptr->nameURN = NULL;\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tmemcpy(ptr->nameURN, tmpName, i + 1);\n\tmemcpy(ptr->location, tmpName + i + 1, (to_read - i - 1));\n\tgf_free(tmpName);\n\treturn GF_OK;\n}\n\nGF_Box *urn_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataEntryURNBox, GF_ISOM_BOX_TYPE_URN);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err urn_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//the flag set indicates we have a string (WE HAVE TO for URLs)\n\tif ( !(ptr->flags & 1)) {\n\t\t//to check, the spec says: First name, then location\n\t\tif (ptr->nameURN) {\n\t\t\tgf_bs_write_data(bs, ptr->nameURN, (u32)strlen(ptr->nameURN) + 1);\n\t\t}\n\t\tif (ptr->location) {\n\t\t\tgf_bs_write_data(bs, ptr->location, (u32)strlen(ptr->location) + 1);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err urn_Size(GF_Box *s)\n{\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->nameURN) ptr->size += 1 + strlen(ptr->nameURN);\n\t\tif (ptr->location) ptr->size += 1 + strlen(ptr->location);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid unkn_del(GF_Box *s)\n{\n\tGF_UnknownBox *ptr = (GF_UnknownBox *) s;\n\tif (!s) return;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err unkn_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 bytesToRead, sub_size, sub_a;\n\tGF_BitStream *sub_bs;\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\tif (ptr->size > 0xFFFFFFFF) return GF_ISOM_INVALID_FILE;\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (!bytesToRead) return GF_OK;\n\tif (bytesToRead>1000000) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Unknown box %s (0x%08X) with payload larger than 1 MBytes, ignoring\\n\", gf_4cc_to_str(ptr->type), ptr->type ));\n\t\tgf_bs_skip_bytes(bs, ptr->dataSize);\n\t\treturn GF_OK;\n\t}\n\n\tptr->data = (char*)gf_malloc(bytesToRead);\n\tif (ptr->data == NULL ) return GF_OUT_OF_MEM;\n\tptr->dataSize = bytesToRead;\n\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\n\t//try to parse container boxes, check if next 8 bytes match a subbox\n\tsub_bs = gf_bs_new(ptr->data, ptr->dataSize, GF_BITSTREAM_READ);\n\tsub_size = gf_bs_read_u32(sub_bs);\n\tsub_a = gf_bs_read_u8(sub_bs);\n\te = (sub_size && (sub_size <= ptr->dataSize)) ? GF_OK : GF_NOT_SUPPORTED;\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\n\tif (e == GF_OK) {\n\t\tgf_bs_seek(sub_bs, 0);\n\t\te = gf_isom_box_array_read(s, sub_bs, gf_isom_box_add_default);\n\t}\n\tgf_bs_del(sub_bs);\n\tif (e==GF_OK) {\n\t\tgf_free(ptr->data);\n\t\tptr->data = NULL;\n\t\tptr->dataSize = 0;\n\t} else if (s->other_boxes) {\n\t\tgf_isom_box_array_del(s->other_boxes);\n\t\ts->other_boxes=NULL;\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *unkn_New(u32 box_type)\n{\n\tISOM_DECL_BOX_ALLOC(GF_UnknownBox, GF_ISOM_BOX_TYPE_UNKNOWN);\n\ttmp->original_4cc = box_type;\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err unkn_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 type = s->type;\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\ts->type = ptr->original_4cc;\n\te = gf_isom_box_write_header(s, bs);\n\ts->type = type;\n\tif (e) return e;\n\n\tif (ptr->dataSize && ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err unkn_Size(GF_Box *s)\n{\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\n\tif (ptr->dataSize && ptr->data) {\n\t\tptr->size += ptr->dataSize;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid def_cont_box_del(GF_Box *s)\n{\n\tif (s) gf_free(s);\n}\n\n\nGF_Err def_cont_box_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, gf_isom_box_add_default);\n}\n\nGF_Box *def_cont_box_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, 0);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITEHintSa\n\nGF_Err def_cont_box_Write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err def_cont_box_Size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid uuid_del(GF_Box *s)\n{\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox *) s;\n\tif (!s) return;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err uuid_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox *)s;\n\tif (ptr->size > 0xFFFFFFFF) return GF_ISOM_INVALID_FILE;\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (bytesToRead) {\n\t\tptr->data = (char*)gf_malloc(bytesToRead);\n\t\tif (ptr->data == NULL ) return GF_OUT_OF_MEM;\n\t\tptr->dataSize = bytesToRead;\n\t\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *uuid_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UnknownUUIDBox, GF_ISOM_BOX_TYPE_UUID);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err uuid_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox*)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err uuid_Size(GF_Box *s)\n{\n\tGF_UnknownUUIDBox*ptr = (GF_UnknownUUIDBox*)s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid dinf_del(GF_Box *s)\n{\n\tGF_DataInformationBox *ptr = (GF_DataInformationBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_box_del((GF_Box *)ptr->dref);\n\tgf_free(ptr);\n}\n\n\nGF_Err dinf_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_DataInformationBox *ptr = (GF_DataInformationBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_DREF:\n\t\tif (ptr->dref) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\n\t\t\tptr->dref = (GF_DataReferenceBox *)a;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);\n\tif (e) {\n\t\treturn e;\n\t}\n\tif (!((GF_DataInformationBox *)s)->dref) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *dinf_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataInformationBox, GF_ISOM_BOX_TYPE_DINF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dinf_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DataInformationBox *ptr = (GF_DataInformationBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->dref) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->dref, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dinf_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_DataInformationBox *ptr = (GF_DataInformationBox *)s;\n\tif (ptr->dref) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->dref);\n\t\tif (e) return e;\n\t\tptr->size += ptr->dref->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid dref_del(GF_Box *s)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *) s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err dref_AddDataEntry(GF_Box *ptr, GF_Box *entry)\n{\n\tif (entry->type==GF_ISOM_BOX_TYPE_ALIS) {\n\t\tGF_DataEntryURLBox *urle = (GF_DataEntryURLBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_URL);\n\t\turle->flags = 1;\n\t\tgf_isom_box_del(entry);\n\t\tgf_isom_box_add_default(ptr, (GF_Box *)urle);\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] Apple \\'alis\\' box found, not supported - converting to self-pointing \\'url \\' \\n\" ));\n\t} else {\n\t\treturn gf_isom_box_add_default(ptr, entry);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dref_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tgf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\treturn gf_isom_box_array_read(s, bs, dref_AddDataEntry);\n}\n\nGF_Box *dref_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataReferenceBox, GF_ISOM_BOX_TYPE_DREF);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dref_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count;\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tcount = ptr->other_boxes ? gf_list_count(ptr->other_boxes) : 0;\n\tgf_bs_write_u32(bs, count);\n\treturn GF_OK;\n}\n\nGF_Err dref_Size(GF_Box *s)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid edts_del(GF_Box *s)\n{\n\tGF_EditBox *ptr = (GF_EditBox *) s;\n\tgf_isom_box_del((GF_Box *)ptr->editList);\n\tgf_free(ptr);\n}\n\n\nGF_Err edts_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\tif (a->type == GF_ISOM_BOX_TYPE_ELST) {\n\t\tif (ptr->editList) return GF_BAD_PARAM;\n\t\tptr->editList = (GF_EditListBox *)a;\n\t\treturn GF_OK;\n\t} else {\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err edts_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, edts_AddBox);\n}\n\nGF_Box *edts_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EditBox, GF_ISOM_BOX_TYPE_EDTS);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err edts_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\n\t//here we have a trick: if editList is empty, skip the box\n\tif (ptr->editList && gf_list_count(ptr->editList->entryList)) {\n\t\te = gf_isom_box_write_header(s, bs);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *) ptr->editList, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err edts_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\n\t//here we have a trick: if editList is empty, skip the box\n\tif (!ptr->editList || ! gf_list_count(ptr->editList->entryList)) {\n\t\tptr->size = 0;\n\t} else {\n\t\te = gf_isom_box_size((GF_Box *)ptr->editList);\n\t\tif (e) return e;\n\t\tptr->size += ptr->editList->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid elst_del(GF_Box *s)\n{\n\tGF_EditListBox *ptr;\n\tGF_EdtsEntry *p;\n\tu32 nb_entries;\n\tu32 i;\n\n\tptr = (GF_EditListBox *)s;\n\tif (ptr == NULL) return;\n\tnb_entries = gf_list_count(ptr->entryList);\n\tfor (i = 0; i < nb_entries; i++) {\n\t\tp = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif (p) gf_free(p);\n\t}\n\tgf_list_del(ptr->entryList);\n\tgf_free(ptr);\n}\n\nGF_Err elst_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entries;\n\ts32 tr;\n\tu32 nb_entries;\n\tGF_EdtsEntry *p;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\n\tnb_entries = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tif (ptr->version == 1) {\n\t\tif (nb_entries > ptr->size / 20) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t} else {\n\t\tif (nb_entries > ptr->size / 12) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n\n\tfor (entries = 0; entries < nb_entries; entries++) {\n\t\tp = (GF_EdtsEntry *) gf_malloc(sizeof(GF_EdtsEntry));\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\tif (ptr->version == 1) {\n\t\t\tp->segmentDuration = gf_bs_read_u64(bs);\n\t\t\tp->mediaTime = (s64) gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tp->segmentDuration = gf_bs_read_u32(bs);\n\t\t\ttr = gf_bs_read_u32(bs);\n\t\t\tp->mediaTime = (s64) tr;\n\t\t}\n\t\tp->mediaRate = gf_bs_read_u16(bs);\n\t\tgf_bs_read_u16(bs);\n\t\tgf_list_add(ptr->entryList, p);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *elst_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EditListBox, GF_ISOM_BOX_TYPE_ELST);\n\ttmp->entryList = gf_list_new();\n\tif (!tmp->entryList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err elst_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tu32 nb_entries;\n\tGF_EdtsEntry *p;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\tif (!ptr) return GF_BAD_PARAM;\n\n\tnb_entries = gf_list_count(ptr->entryList);\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, nb_entries);\n\tfor (i = 0; i < nb_entries; i++ ) {\n\t\tp = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif (ptr->version == 1) {\n\t\t\tgf_bs_write_u64(bs, p->segmentDuration);\n\t\t\tgf_bs_write_u64(bs, p->mediaTime);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) p->segmentDuration);\n\t\t\tgf_bs_write_u32(bs, (s32) p->mediaTime);\n\t\t}\n\t\tgf_bs_write_u16(bs, p->mediaRate);\n\t\tgf_bs_write_u16(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err elst_Size(GF_Box *s)\n{\n\tu32 durtimebytes;\n\tu32 i, nb_entries;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\n\t//entry count\n\tptr->size += 4;\n\tnb_entries = gf_list_count(ptr->entryList);\n\tptr->version = 0;\n\tfor (i=0; i<nb_entries; i++) {\n\t\tGF_EdtsEntry *p = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif ((p->segmentDuration>0xFFFFFFFF) || (p->mediaTime>0xFFFFFFFF)) {\n\t\t\tptr->version = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdurtimebytes = (ptr->version == 1 ? 16 : 8) + 4;\n\tptr->size += (nb_entries * durtimebytes);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid esds_del(GF_Box *s)\n{\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\tif (ptr == NULL)\treturn;\n\tif (ptr->desc) gf_odf_desc_del((GF_Descriptor *)ptr->desc);\n\tgf_free(ptr);\n}\n\n\nGF_Err esds_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e=GF_OK;\n\tu32 descSize;\n\tchar *enc_desc;\n\tu32 SLIsPredefined(GF_SLConfig *sl);\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\n\tdescSize = (u32) (ptr->size);\n\n\tif (descSize) {\n\t\tenc_desc = (char*)gf_malloc(sizeof(char) * descSize);\n\t\tif (!enc_desc) return GF_OUT_OF_MEM;\n\t\t//get the payload\n\t\tgf_bs_read_data(bs, enc_desc, descSize);\n\t\t//send it to the OD Codec\n\t\te = gf_odf_desc_read(enc_desc, descSize, (GF_Descriptor **) &ptr->desc);\n\t\t//OK, free our desc\n\t\tgf_free(enc_desc);\n\n\t\tif (ptr->desc && (ptr->desc->tag!=GF_ODF_ESD_TAG) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid descriptor tag 0x%x in esds\\n\", ptr->desc->tag));\n\t\t\tgf_odf_desc_del((GF_Descriptor*)ptr->desc);\n\t\t\tptr->desc=NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tif (e) {\n\t\t\tptr->desc = NULL;\n\t\t} else {\n\t\t\t/*fix broken files*/\n\t\t\tif (!ptr->desc->URLString) {\n\t\t\t\tif (!ptr->desc->slConfig) {\n\t\t\t\t\tptr->desc->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\t\t\tptr->desc->slConfig->predefined = SLPredef_MP4;\n\t\t\t\t} else if (ptr->desc->slConfig->predefined != SLPredef_MP4) {\n\t\t\t\t\tptr->desc->slConfig->predefined = SLPredef_MP4;\n\t\t\t\t\tgf_odf_slc_set_pref(ptr->desc->slConfig);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Box *esds_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ESDBox, GF_ISOM_BOX_TYPE_ESDS);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err esds_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tchar *enc_desc;\n\tu32 descSize = 0;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\te = gf_odf_desc_write((GF_Descriptor *)ptr->desc, &enc_desc, &descSize);\n\tif (e) return e;\n\tgf_bs_write_data(bs, enc_desc, descSize);\n\t//free our buffer\n\tgf_free(enc_desc);\n\treturn GF_OK;\n}\n\nGF_Err esds_Size(GF_Box *s)\n{\n\tu32 descSize = 0;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\tdescSize = gf_odf_desc_size((GF_Descriptor *)ptr->desc);\n\tptr->size += descSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid free_del(GF_Box *s)\n{\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err free_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\n\tif (ptr->size > 0xFFFFFFFF) return GF_IO_ERR;\n\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (bytesToRead) {\n\t\tptr->data = (char*)gf_malloc(bytesToRead * sizeof(char));\n\t\tgf_bs_read_data(bs, ptr->data, bytesToRead);\n\t\tptr->dataSize = bytesToRead;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *free_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FreeSpaceBox, GF_ISOM_BOX_TYPE_FREE);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err free_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tif (ptr->original_4cc) {\n\t\tu32 t = s->type;\n\t\ts->type=ptr->original_4cc;\n\t\te = gf_isom_box_write_header(s, bs);\n\t\ts->type=t;\n\t} else {\n\t\te = gf_isom_box_write_header(s, bs);\n\t}\n\tif (e) return e;\n\tif (ptr->dataSize)\t{\n\t\tif (ptr->data) {\n\t\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t\t} else {\n\t\t\tu32 i = 0;\n\t\t\twhile (i<ptr->dataSize) {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err free_Size(GF_Box *s)\n{\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ftyp_del(GF_Box *s)\n{\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *) s;\n\tif (ptr->altBrand) gf_free(ptr->altBrand);\n\tgf_free(ptr);\n}\n\nGF_Box *ftyp_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FileTypeBox, GF_ISOM_BOX_TYPE_FTYP);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err ftyp_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *)s;\n\n\tif (ptr->size < 8) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Found ftyp with size < 8, likely broken!\\n\"));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tptr->majorBrand = gf_bs_read_u32(bs);\n\tptr->minorVersion = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 8);\n\n\tptr->altCount = ( (u32) (ptr->size)) / 4;\n\tif (!ptr->altCount) return GF_OK;\n\tif (ptr->altCount * 4 != (u32) (ptr->size)) return GF_ISOM_INVALID_FILE;\n\n\tptr->altBrand = (u32*)gf_malloc(sizeof(u32)*ptr->altCount);\n\tfor (i = 0; i<ptr->altCount; i++) {\n\t\tptr->altBrand[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ftyp_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->majorBrand);\n\tgf_bs_write_u32(bs, ptr->minorVersion);\n\tfor (i=0; i<ptr->altCount; i++) {\n\t\tgf_bs_write_u32(bs, ptr->altBrand[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ftyp_Size(GF_Box *s)\n{\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *)s;\n\n\tptr->size += 8 + ptr->altCount * 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid gnrm_del(GF_Box *s)\n{\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnrm_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericSampleEntryBox, GF_ISOM_BOX_TYPE_GNRM);\n\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n//dummy\nGF_Err gnrm_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gnrm_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\n\t//carefull we are not writing the box type but the entry type so switch for write\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRM;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\treturn GF_OK;\n}\n\nGF_Err gnrm_Size(GF_Box *s)\n{\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRM;\n\tptr->size += 8+ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid gnrv_del(GF_Box *s)\n{\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnrv_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericVisualSampleEntryBox, GF_ISOM_BOX_TYPE_GNRV);\n\tgf_isom_video_sample_entry_init((GF_VisualSampleEntryBox*) tmp);\n\treturn (GF_Box *)tmp;\n}\n//dummy\nGF_Err gnrv_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gnrv_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\n\t//carefull we are not writing the box type but the entry type so switch for write\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRV;\n\n\tgf_isom_video_sample_entry_write((GF_VisualSampleEntryBox *)ptr, bs);\n\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\treturn GF_OK;\n}\n\nGF_Err gnrv_Size(GF_Box *s)\n{\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRV;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\tptr->size += ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid gnra_del(GF_Box *s)\n{\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnra_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericAudioSampleEntryBox, GF_ISOM_BOX_TYPE_GNRA);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*) tmp);\n\treturn (GF_Box *)tmp;\n}\n//dummy\nGF_Err gnra_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err gnra_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\n\t//carefull we are not writing the box type but the entry type so switch for write\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRA;\n\n\tgf_isom_audio_sample_entry_write((GF_AudioSampleEntryBox *)ptr, bs);\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gnra_Size(GF_Box *s)\n{\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRA;\n\tgf_isom_audio_sample_entry_size((GF_AudioSampleEntryBox *)s);\n\tptr->size += ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid hdlr_del(GF_Box *s)\n{\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->nameUTF8) gf_free(ptr->nameUTF8);\n\tgf_free(ptr);\n}\n\n\nGF_Err hdlr_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\n\tptr->reserved1 = gf_bs_read_u32(bs);\n\tptr->handlerType = gf_bs_read_u32(bs);\n\tgf_bs_read_data(bs, (char*)ptr->reserved2, 12);\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\n\tif (ptr->size) {\n\t\tsize_t len;\n\t\tptr->nameUTF8 = (char*)gf_malloc((u32) ptr->size);\n\t\tif (ptr->nameUTF8 == NULL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->nameUTF8, (u32) ptr->size);\n\t\t/*safety check in case the string is not null-terminated*/\n\t\tif (ptr->nameUTF8[ptr->size-1]) {\n\t\t\tchar *str = (char*)gf_malloc((u32) ptr->size + 1);\n\t\t\tmemcpy(str, ptr->nameUTF8, (u32) ptr->size);\n\t\t\tstr[ptr->size] = 0;\n\t\t\tgf_free(ptr->nameUTF8);\n\t\t\tptr->nameUTF8 = str;\n\t\t}\n\t\t//patch for old QT files\n\t\tif (ptr->size > 1 && ptr->nameUTF8[0] == ptr->size-1) {\n\t\t\tlen = strlen(ptr->nameUTF8 + 1);\n\t\t\tmemmove(ptr->nameUTF8, ptr->nameUTF8+1, len );\n\t\t\tptr->nameUTF8[len] = 0;\n\t\t\tptr->store_counted_string = GF_TRUE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *hdlr_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HandlerBox, GF_ISOM_BOX_TYPE_HDLR);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hdlr_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->reserved1);\n\tgf_bs_write_u32(bs, ptr->handlerType);\n\tgf_bs_write_data(bs, (char*)ptr->reserved2, 12);\n\n\tif (ptr->nameUTF8) {\n\t\tu32 len = (u32)strlen(ptr->nameUTF8);\n\t\tif (ptr->store_counted_string) {\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, ptr->nameUTF8, len);\n\t\t} else {\n\t\t\tgf_bs_write_data(bs, ptr->nameUTF8, len);\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err hdlr_Size(GF_Box *s)\n{\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\tptr->size += 20 + 1; //null term or counted string\n\tif (ptr->nameUTF8) {\n\t\tptr->size += strlen(ptr->nameUTF8);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid hinf_del(GF_Box *s)\n{\n\tGF_HintInfoBox *hinf = (GF_HintInfoBox *)s;\n\tgf_free(hinf);\n}\n\nGF_Box *hinf_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintInfoBox, GF_ISOM_BOX_TYPE_HINF);\n\n\ttmp->other_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err hinf_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MAXRBox *maxR;\n\tGF_HintInfoBox *hinf = (GF_HintInfoBox *)s;\n\tu32 i;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_MAXR:\n\t\ti=0;\n\t\twhile ((maxR = (GF_MAXRBox *)gf_list_enum(hinf->other_boxes, &i))) {\n\t\t\tif ((maxR->type==GF_ISOM_BOX_TYPE_MAXR) && (maxR->granularity == ((GF_MAXRBox *)a)->granularity))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tbreak;\n\t}\n\treturn gf_isom_box_add_default(s, a);\n}\n\n\nGF_Err hinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, hinf_AddBox);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hinf_Write(GF_Box *s, GF_BitStream *bs)\n{\n//\tGF_HintInfoBox *ptr = (GF_HintInfoBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err hinf_Size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid hmhd_del(GF_Box *s)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err hmhd_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\n\tptr->maxPDUSize = gf_bs_read_u16(bs);\n\tptr->avgPDUSize = gf_bs_read_u16(bs);\n\tptr->maxBitrate = gf_bs_read_u32(bs);\n\tptr->avgBitrate = gf_bs_read_u32(bs);\n\tptr->slidingAverageBitrate = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *hmhd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintMediaHeaderBox, GF_ISOM_BOX_TYPE_HMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hmhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->maxPDUSize);\n\tgf_bs_write_u16(bs, ptr->avgPDUSize);\n\tgf_bs_write_u32(bs, ptr->maxBitrate);\n\tgf_bs_write_u32(bs, ptr->avgBitrate);\n\tgf_bs_write_u32(bs, ptr->slidingAverageBitrate);\n\treturn GF_OK;\n}\n\nGF_Err hmhd_Size(GF_Box *s)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\tptr->size += 16;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *hnti_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintTrackInfoBox, GF_ISOM_BOX_TYPE_HNTI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid hnti_del(GF_Box *a)\n{\n\tgf_free(a);\n}\n\nGF_Err hnti_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_HintTrackInfoBox *hnti = (GF_HintTrackInfoBox *)s;\n\tif (!hnti || !a) return GF_BAD_PARAM;\n\n\tswitch (a->type) {\n\t//this is the value for GF_RTPBox - same as HintSampleEntry for RTP !!!\n\tcase GF_ISOM_BOX_TYPE_RTP:\n\tcase GF_ISOM_BOX_TYPE_SDP:\n\t\tif (hnti->SDP) return GF_BAD_PARAM;\n\t\thnti->SDP = a;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn gf_isom_box_add_default(s, a);\n}\n\nGF_Err hnti_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(s, bs, hnti_AddBox, s->type);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err hnti_Write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\n\nGF_Err hnti_Size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tGF_SDPBox\n**********************************************************/\n\nvoid sdp_del(GF_Box *s)\n{\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr->sdpText) gf_free(ptr->sdpText);\n\tgf_free(ptr);\n\n}\nGF_Err sdp_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tlength = (u32) (ptr->size);\n\t//sdp text has no delimiter !!!\n\tptr->sdpText = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (!ptr->sdpText) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->sdpText, length);\n\tptr->sdpText[length] = 0;\n\treturn GF_OK;\n}\nGF_Box *sdp_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SDPBox, GF_ISOM_BOX_TYPE_SDP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sdp_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\t//don't write the NULL char!!!\n\tgf_bs_write_data(bs, ptr->sdpText, (u32) strlen(ptr->sdpText));\n\treturn GF_OK;\n}\nGF_Err sdp_Size(GF_Box *s)\n{\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\t//don't count the NULL char!!!\n\tptr->size += strlen(ptr->sdpText);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nvoid rtp_hnti_del(GF_Box *s)\n{\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr->sdpText) gf_free(ptr->sdpText);\n\tgf_free(ptr);\n\n}\nGF_Err rtp_hnti_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->subType = gf_bs_read_u32(bs);\n\n\tlength = (u32) (ptr->size);\n\t//sdp text has no delimiter !!!\n\tptr->sdpText = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (!ptr->sdpText) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->sdpText, length);\n\tptr->sdpText[length] = 0;\n\treturn GF_OK;\n}\n\nGF_Box *rtp_hnti_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RTPBox, GF_ISOM_BOX_TYPE_RTP);\n\ttmp->subType = GF_ISOM_BOX_TYPE_SDP;\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rtp_hnti_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->subType);\n\t//don't write the NULL char!!!\n\tgf_bs_write_data(bs, ptr->sdpText, (u32) strlen(ptr->sdpText));\n\treturn GF_OK;\n}\n\nGF_Err rtp_hnti_Size(GF_Box *s)\n{\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tptr->size += 4 + strlen(ptr->sdpText);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTRPY GF_Box\n**********************************************************/\n\nvoid trpy_del(GF_Box *s)\n{\n\tgf_free((GF_TRPYBox *)s);\n}\nGF_Err trpy_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TRPYBox *ptr = (GF_TRPYBox *)s;\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *trpy_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TRPYBox, GF_ISOM_BOX_TYPE_TRPY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trpy_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TRPYBox *ptr = (GF_TRPYBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err trpy_Size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tTOTL GF_Box\n**********************************************************/\n\nvoid totl_del(GF_Box *s)\n{\n\tgf_free((GF_TRPYBox *)s);\n}\nGF_Err totl_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TOTLBox *ptr = (GF_TOTLBox *)s;\n\tptr->nbBytes = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *totl_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TOTLBox, GF_ISOM_BOX_TYPE_TOTL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err totl_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TOTLBox *ptr = (GF_TOTLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err totl_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tNUMP GF_Box\n**********************************************************/\n\nvoid nump_del(GF_Box *s)\n{\n\tgf_free((GF_NUMPBox *)s);\n}\nGF_Err nump_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NUMPBox *ptr = (GF_NUMPBox *)s;\n\tptr->nbPackets = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *nump_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NUMPBox, GF_ISOM_BOX_TYPE_NUMP);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err nump_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NUMPBox *ptr = (GF_NUMPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbPackets);\n\treturn GF_OK;\n}\nGF_Err nump_Size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tNPCK GF_Box\n**********************************************************/\n\nvoid npck_del(GF_Box *s)\n{\n\tgf_free((GF_NPCKBox *)s);\n}\nGF_Err npck_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NPCKBox *ptr = (GF_NPCKBox *)s;\n\tptr->nbPackets = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *npck_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NPCKBox, GF_ISOM_BOX_TYPE_NPCK);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err npck_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NPCKBox *ptr = (GF_NPCKBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbPackets);\n\treturn GF_OK;\n}\nGF_Err npck_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTPYL GF_Box\n**********************************************************/\n\nvoid tpyl_del(GF_Box *s)\n{\n\tgf_free((GF_NTYLBox *)s);\n}\nGF_Err tpyl_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NTYLBox *ptr = (GF_NTYLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *tpyl_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NTYLBox, GF_ISOM_BOX_TYPE_TPYL);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tpyl_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NTYLBox *ptr = (GF_NTYLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err tpyl_Size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tTPAY GF_Box\n**********************************************************/\n\nvoid tpay_del(GF_Box *s)\n{\n\tgf_free((GF_TPAYBox *)s);\n}\nGF_Err tpay_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TPAYBox *ptr = (GF_TPAYBox *)s;\n\tptr->nbBytes = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tpay_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TPAYBox, GF_ISOM_BOX_TYPE_TPAY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tpay_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TPAYBox *ptr = (GF_TPAYBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err tpay_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tMAXR GF_Box\n**********************************************************/\n\nvoid maxr_del(GF_Box *s)\n{\n\tgf_free((GF_MAXRBox *)s);\n}\nGF_Err maxr_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MAXRBox *ptr = (GF_MAXRBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tptr->granularity = gf_bs_read_u32(bs);\n\tptr->maxDataRate = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *maxr_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MAXRBox, GF_ISOM_BOX_TYPE_MAXR);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err maxr_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MAXRBox *ptr = (GF_MAXRBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->granularity);\n\tgf_bs_write_u32(bs, ptr->maxDataRate);\n\treturn GF_OK;\n}\nGF_Err maxr_Size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tDMED GF_Box\n**********************************************************/\n\nvoid dmed_del(GF_Box *s)\n{\n\tgf_free((GF_DMEDBox *)s);\n}\nGF_Err dmed_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DMEDBox *ptr = (GF_DMEDBox *)s;\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *dmed_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DMEDBox, GF_ISOM_BOX_TYPE_DMED);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dmed_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DMEDBox *ptr = (GF_DMEDBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err dmed_Size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tDIMM GF_Box\n**********************************************************/\n\nvoid dimm_del(GF_Box *s)\n{\n\tgf_free((GF_DIMMBox *)s);\n}\nGF_Err dimm_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMMBox *ptr = (GF_DIMMBox *)s;\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *dimm_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DIMMBox, GF_ISOM_BOX_TYPE_DIMM);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dimm_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DIMMBox *ptr = (GF_DIMMBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err dimm_Size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tDREP GF_Box\n**********************************************************/\n\nvoid drep_del(GF_Box *s)\n{\n\tgf_free((GF_DREPBox *)s);\n}\nGF_Err drep_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DREPBox *ptr = (GF_DREPBox *)s;\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *drep_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DREPBox, GF_ISOM_BOX_TYPE_DREP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err drep_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DREPBox *ptr = (GF_DREPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err drep_Size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n/**********************************************************\n\t\tTMIN GF_Box\n**********************************************************/\n\nvoid tmin_del(GF_Box *s)\n{\n\tgf_free((GF_TMINBox *)s);\n}\nGF_Err tmin_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TMINBox *ptr = (GF_TMINBox *)s;\n\tptr->minTime = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tmin_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TMINBox, GF_ISOM_BOX_TYPE_TMIN);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tmin_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TMINBox *ptr = (GF_TMINBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->minTime);\n\treturn GF_OK;\n}\nGF_Err tmin_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTMAX GF_Box\n**********************************************************/\n\nvoid tmax_del(GF_Box *s)\n{\n\tgf_free((GF_TMAXBox *)s);\n}\nGF_Err tmax_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TMAXBox *ptr = (GF_TMAXBox *)s;\n\tptr->maxTime = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tmax_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TMAXBox, GF_ISOM_BOX_TYPE_TMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tmax_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TMAXBox *ptr = (GF_TMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxTime);\n\treturn GF_OK;\n}\nGF_Err tmax_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPMAX GF_Box\n**********************************************************/\n\nvoid pmax_del(GF_Box *s)\n{\n\tgf_free((GF_PMAXBox *)s);\n}\nGF_Err pmax_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PMAXBox *ptr = (GF_PMAXBox *)s;\n\tptr->maxSize = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *pmax_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PMAXBox, GF_ISOM_BOX_TYPE_PMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err pmax_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PMAXBox *ptr = (GF_PMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxSize);\n\treturn GF_OK;\n}\nGF_Err pmax_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tDMAX GF_Box\n**********************************************************/\n\nvoid dmax_del(GF_Box *s)\n{\n\tgf_free((GF_DMAXBox *)s);\n}\nGF_Err dmax_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DMAXBox *ptr = (GF_DMAXBox *)s;\n\tptr->maxDur = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *dmax_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DMAXBox, GF_ISOM_BOX_TYPE_DMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dmax_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DMAXBox *ptr = (GF_DMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxDur);\n\treturn GF_OK;\n}\nGF_Err dmax_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPAYT GF_Box\n**********************************************************/\n\nvoid payt_del(GF_Box *s)\n{\n\tGF_PAYTBox *payt = (GF_PAYTBox *)s;\n\tif (payt->payloadString) gf_free(payt->payloadString);\n\tgf_free(payt);\n}\nGF_Err payt_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\n\tptr->payloadCode = gf_bs_read_u32(bs);\n\tlength = gf_bs_read_u8(bs);\n\tptr->payloadString = (char*)gf_malloc(sizeof(char) * (length+1) );\n\tif (! ptr->payloadString) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->payloadString, length);\n\tptr->payloadString[length] = 0;\n\n\tISOM_DECREASE_SIZE(ptr, (4+length+1) );\n\treturn GF_OK;\n}\nGF_Box *payt_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PAYTBox, GF_ISOM_BOX_TYPE_PAYT);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err payt_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 len;\n\tGF_Err e;\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->payloadCode);\n\tlen = (u32) strlen(ptr->payloadString);\n\tgf_bs_write_u8(bs, len);\n\tif (len) gf_bs_write_data(bs, ptr->payloadString, len);\n\treturn GF_OK;\n}\nGF_Err payt_Size(GF_Box *s)\n{\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\ts->size += 4;\n\tif (ptr->payloadString) ptr->size += strlen(ptr->payloadString) + 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPAYT GF_Box\n**********************************************************/\n\nvoid name_del(GF_Box *s)\n{\n\tGF_NameBox *name = (GF_NameBox *)s;\n\tif (name->string) gf_free(name->string);\n\tgf_free(name);\n}\nGF_Err name_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\n\tlength = (u32) (ptr->size);\n\tptr->string = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (! ptr->string) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->string, length);\n\tptr->string[length] = 0;\n\treturn GF_OK;\n}\nGF_Box *name_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NameBox, GF_ISOM_BOX_TYPE_NAME);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err name_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->string) {\n\t\tgf_bs_write_data(bs, ptr->string, (u32) strlen(ptr->string) + 1);\n\t}\n\treturn GF_OK;\n}\nGF_Err name_Size(GF_Box *s)\n{\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\tif (ptr->string) ptr->size += strlen(ptr->string) + 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tssy_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err tssy_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TimeStampSynchronyBox *ptr = (GF_TimeStampSynchronyBox *)s;\n\tgf_bs_read_int(bs, 6);\n\tptr->timestamp_sync = gf_bs_read_int(bs, 2);\n\treturn GF_OK;\n}\nGF_Box *tssy_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeStampSynchronyBox, GF_ISOM_BOX_TYPE_TSSY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tssy_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TimeStampSynchronyBox *ptr = (GF_TimeStampSynchronyBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, 0, 6);\n\tgf_bs_write_int(bs, ptr->timestamp_sync, 2);\n\treturn GF_OK;\n}\nGF_Err tssy_Size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid srpp_del(GF_Box *s)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tif (ptr->info) gf_isom_box_del((GF_Box*)ptr->info);\n\tif (ptr->scheme_type) gf_isom_box_del((GF_Box*)ptr->scheme_type);\n\tgf_free(s);\n}\n\nGF_Err srpp_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_SCHI:\n\t\tif (ptr->info) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->info = (GF_SchemeInformationBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SCHM:\n\t\tif (ptr->scheme_type) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->scheme_type = (GF_SchemeTypeBox *)a;\n\t\treturn GF_OK;\n\t}\n\treturn gf_isom_box_add_default(s, a);\n}\n\nGF_Err srpp_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 16)\n\tptr->encryption_algorithm_rtp = gf_bs_read_u32(bs);\n\tptr->encryption_algorithm_rtcp = gf_bs_read_u32(bs);\n\tptr->integrity_algorithm_rtp = gf_bs_read_u32(bs);\n\tptr->integrity_algorithm_rtp = gf_bs_read_u32(bs);\n\treturn gf_isom_box_array_read(s, bs, gf_isom_box_add_default);\n}\nGF_Box *srpp_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SRTPProcessBox, GF_ISOM_BOX_TYPE_SRPP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err srpp_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->encryption_algorithm_rtp);\n\tgf_bs_write_u32(bs, ptr->encryption_algorithm_rtcp);\n\tgf_bs_write_u32(bs, ptr->integrity_algorithm_rtp);\n\tgf_bs_write_u32(bs, ptr->integrity_algorithm_rtcp);\n\tif (ptr->info) {\n\t\te = gf_isom_box_write((GF_Box*)ptr->info, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->scheme_type) {\n\t\te = gf_isom_box_write((GF_Box*)ptr->scheme_type, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\nGF_Err srpp_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\n\ts->size += 16;\n\tif (ptr->info) {\n\t\te = gf_isom_box_size((GF_Box*)ptr->info);\n\t\tif (e) return e;\n\t\tptr->size += ptr->info->size;\n\t}\n\tif (ptr->scheme_type) {\n\t\te = gf_isom_box_size((GF_Box*)ptr->scheme_type);\n\t\tif (e) return e;\n\t\tptr->size += ptr->scheme_type->size;\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid rssr_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err rssr_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ReceivedSsrcBox *ptr = (GF_ReceivedSsrcBox *)s;\n\tptr->ssrc = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *rssr_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ReceivedSsrcBox, GF_ISOM_BOX_TYPE_RSSR);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rssr_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ReceivedSsrcBox *ptr = (GF_ReceivedSsrcBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->ssrc);\n\treturn GF_OK;\n}\nGF_Err rssr_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nvoid iods_del(GF_Box *s)\n{\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->descriptor) gf_odf_desc_del(ptr->descriptor);\n\tgf_free(ptr);\n}\n\n\nGF_Err iods_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 descSize;\n\tchar *desc;\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\n\t//use the OD codec...\n\tdescSize = (u32) (ptr->size);\n\tdesc = (char*)gf_malloc(sizeof(char) * descSize);\n\tgf_bs_read_data(bs, desc, descSize);\n\te = gf_odf_desc_read(desc, descSize, &ptr->descriptor);\n\t//OK, free our desc\n\tgf_free(desc);\n\treturn e;\n}\n\nGF_Box *iods_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ObjectDescriptorBox, GF_ISOM_BOX_TYPE_IODS);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err iods_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 descSize;\n\tchar *desc;\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//call our OD codec\n\te = gf_odf_desc_write(ptr->descriptor, &desc, &descSize);\n\tif (e) return e;\n\tgf_bs_write_data(bs, desc, descSize);\n\t//and free our stuff maybe!!\n\tgf_free(desc);\n\treturn GF_OK;\n}\n\nGF_Err iods_Size(GF_Box *s)\n{\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\n\tptr->size += gf_odf_desc_size(ptr->descriptor);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mdat_del(GF_Box *s)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tif (!s) return;\n\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err mdat_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tptr->dataSize = s->size;\n\tptr->bsOffset = gf_bs_get_position(bs);\n\n\t//then skip these bytes\n\tgf_bs_skip_bytes(bs, ptr->dataSize);\n\treturn GF_OK;\n}\n\nGF_Box *mdat_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaDataBox, GF_ISOM_BOX_TYPE_MDAT);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdat_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\t//make sure we have some data ...\n\t//if not, we handle that independantly (edit files)\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, (u32) ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mdat_Size(GF_Box *s)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mdhd_del(GF_Box *s)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err mdhd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\n\tif (ptr->version == 1) {\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tif (!ptr->timeScale) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Media header timescale is 0 - defaulting to 90000\\n\" ));\n\t\tptr->timeScale = 90000;\n\t}\n\n\tptr->original_duration = ptr->duration;\n\n\t//our padding bit\n\tgf_bs_read_int(bs, 1);\n\t//the spec is unclear here, just says \"the value 0 is interpreted as undetermined\"\n\tptr->packedLanguage[0] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguage[1] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguage[2] = gf_bs_read_int(bs, 5);\n\t//but before or after compaction ?? We assume before\n\tif (ptr->packedLanguage[0] || ptr->packedLanguage[1] || ptr->packedLanguage[2]) {\n\t\tptr->packedLanguage[0] += 0x60;\n\t\tptr->packedLanguage[1] += 0x60;\n\t\tptr->packedLanguage[2] += 0x60;\n\t} else {\n\t\tptr->packedLanguage[0] = 'u';\n\t\tptr->packedLanguage[1] = 'n';\n\t\tptr->packedLanguage[2] = 'd';\n\t}\n\tptr->reserved = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\nGF_Box *mdhd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaHeaderBox, GF_ISOM_BOX_TYPE_MDHD);\n\n\ttmp->packedLanguage[0] = 'u';\n\ttmp->packedLanguage[1] = 'n';\n\ttmp->packedLanguage[2] = 'd';\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\t//SPECS: BIT(1) of padding\n\tgf_bs_write_int(bs, 0, 1);\n\tgf_bs_write_int(bs, ptr->packedLanguage[0] - 0x60, 5);\n\tgf_bs_write_int(bs, ptr->packedLanguage[1] - 0x60, 5);\n\tgf_bs_write_int(bs, ptr->packedLanguage[2] - 0x60, 5);\n\tgf_bs_write_u16(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err mdhd_Size(GF_Box *s)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\tptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\n\tptr->size += 4;\n\tptr->size += (ptr->version == 1) ? 28 : 16;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid mdia_del(GF_Box *s)\n{\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->mediaHeader) gf_isom_box_del((GF_Box *)ptr->mediaHeader);\n\tif (ptr->information) gf_isom_box_del((GF_Box *)ptr->information);\n\tif (ptr->handler) gf_isom_box_del((GF_Box *)ptr->handler);\n\tgf_free(ptr);\n}\n\n\nGF_Err mdia_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_MDHD:\n\t\tif (ptr->mediaHeader) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\n\t\t\tptr->mediaHeader = (GF_MediaHeaderBox *)a;\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_HDLR:\n\t\tif (ptr->handler) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\n\t\t\tptr->handler = (GF_HandlerBox *)a;\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_MINF:\n\t\tif (ptr->information) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\n\t\t\tptr->information = (GF_MediaInformationBox *)a;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err mdia_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, mdia_AddBox);\n\tif (e) return e;\n\tif (!((GF_MediaBox *)s)->information) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaInformationBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->handler) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing HandlerBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->mediaHeader) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaHeaderBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *mdia_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaBox, GF_ISOM_BOX_TYPE_MDIA);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdia_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\t//Header first\n\tif (ptr->mediaHeader) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->mediaHeader, bs);\n\t\tif (e) return e;\n\t}\n\t//then handler\n\tif (ptr->handler) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->handler, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->information) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->information, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mdia_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\n\tif (ptr->mediaHeader) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->mediaHeader);\n\t\tif (e) return e;\n\t\tptr->size += ptr->mediaHeader->size;\n\t}\n\tif (ptr->handler) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->handler);\n\t\tif (e) return e;\n\t\tptr->size += ptr->handler->size;\n\t}\n\tif (ptr->information) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->information);\n\t\tif (e) return e;\n\t\tptr->size += ptr->information->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mfra_del(GF_Box *s)\n{\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->mfro) gf_isom_box_del((GF_Box*)ptr->mfro);\n\tgf_isom_box_array_del(ptr->tfra_list);\n\tgf_free(ptr);\n}\n\nGF_Box *mfra_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentRandomAccessBox, GF_ISOM_BOX_TYPE_MFRA);\n\ttmp->tfra_list = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err mfra_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_TFRA:\n\t\treturn gf_list_add(ptr->tfra_list, a);\n\tcase GF_ISOM_BOX_TYPE_MFRO:\n\t\tif (ptr->mfro) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->mfro = (GF_MovieFragmentRandomAccessOffsetBox *)a;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mfra_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, mfra_AddBox);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mfra_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\te = gf_isom_box_array_write(s, ptr->tfra_list, bs);\n\tif (e) return e;\n\tif (ptr->mfro) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->mfro, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mfra_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\n\tif (ptr->mfro) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->mfro);\n\t\tif (e) return e;\n\t\tptr->size += ptr->mfro->size;\n\t}\n\treturn gf_isom_box_array_size(s, ptr->tfra_list);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tfra_del(GF_Box *s)\n{\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Box *tfra_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentRandomAccessBox, GF_ISOM_BOX_TYPE_TFRA);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err tfra_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_RandomAccessEntry *p = 0;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\n\tif (ptr->size<12) return GF_ISOM_INVALID_FILE;\n\n\tptr->track_id = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tif (gf_bs_read_int(bs, 26) !=0) return GF_ISOM_INVALID_FILE;\n\tptr->traf_bits = (gf_bs_read_int(bs, 2)+1)*8;\n\tptr->trun_bits = (gf_bs_read_int(bs, 2)+1)*8;\n\tptr->sample_bits = (gf_bs_read_int(bs, 2)+1)*8;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tif (ptr->version==1) {\n\t\tif (ptr->nb_entries > ptr->size / (16+(ptr->traf_bits+ptr->trun_bits+ptr->sample_bits)/8)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t} else {\n\t\tif (ptr->nb_entries > ptr->size / (8+(ptr->traf_bits+ptr->trun_bits+ptr->sample_bits)/8)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n\tif (ptr->nb_entries)\n\t{\n\t\tp = (GF_RandomAccessEntry *) gf_malloc(sizeof(GF_RandomAccessEntry) * ptr->nb_entries);\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t}\n\n\tptr->entries = p;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tmemset(p, 0, sizeof(GF_RandomAccessEntry));\n\n\t\tif (ptr->version==1) {\n\t\t\tp->time = gf_bs_read_u64(bs);\n\t\t\tp->moof_offset = gf_bs_read_u64(bs);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp->time = gf_bs_read_u32(bs);\n\t\t\tp->moof_offset = gf_bs_read_u32(bs);\n\t\t}\n\t\tp->traf_number = gf_bs_read_int(bs, ptr->traf_bits);\n\t\tp->trun_number = gf_bs_read_int(bs, ptr->trun_bits);\n\t\tp->sample_number = gf_bs_read_int(bs, ptr->sample_bits);\n\n\t\t++p;\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfra_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->track_id);\n\tgf_bs_write_int(bs, 0, 26);\n\n\tgf_bs_write_int(bs, ptr->traf_bits/8 - 1, 2);\n\tgf_bs_write_int(bs, ptr->trun_bits/8 - 1, 2);\n\tgf_bs_write_int(bs, ptr->sample_bits/8 - 1, 2);\n\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tGF_RandomAccessEntry *p = &ptr->entries[i];\n\t\tif (ptr->version==1) {\n\t\t\tgf_bs_write_u64(bs, p->time);\n\t\t\tgf_bs_write_u64(bs, p->moof_offset);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) p->time);\n\t\t\tgf_bs_write_u32(bs, (u32) p->moof_offset);\n\t\t}\n\t\tgf_bs_write_int(bs, p->traf_number, ptr->traf_bits);\n\t\tgf_bs_write_int(bs, p->trun_number, ptr->trun_bits);\n\t\tgf_bs_write_int(bs, p->sample_number, ptr->sample_bits);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfra_Size(GF_Box *s)\n{\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\n\tptr->size += 12;\n\n\tptr->size += ptr->nb_entries * ( ((ptr->version==1) ? 16 : 8 ) + ptr->traf_bits/8 + ptr->trun_bits/8 + ptr->sample_bits/8);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid mfro_del(GF_Box *s)\n{\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Box *mfro_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentRandomAccessOffsetBox, GF_ISOM_BOX_TYPE_MFRO);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err mfro_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\n\tptr->container_size = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mfro_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->container_size);\n\treturn GF_OK;\n}\n\nGF_Err mfro_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid elng_del(GF_Box *s)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->extended_language) gf_free(ptr->extended_language);\n\tgf_free(ptr);\n}\n\nGF_Err elng_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\n\tif (ptr->size) {\n\t\tptr->extended_language = (char*)gf_malloc((u32) ptr->size);\n\t\tif (ptr->extended_language == NULL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->extended_language, (u32) ptr->size);\n\t\t/*safety check in case the string is not null-terminated*/\n\t\tif (ptr->extended_language[ptr->size-1]) {\n\t\t\tchar *str = (char*)gf_malloc((u32) ptr->size + 1);\n\t\t\tmemcpy(str, ptr->extended_language, (u32) ptr->size);\n\t\t\tstr[ptr->size] = 0;\n\t\t\tgf_free(ptr->extended_language);\n\t\t\tptr->extended_language = str;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *elng_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaBox, GF_ISOM_BOX_TYPE_ELNG);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err elng_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->extended_language) {\n\t\tgf_bs_write_data(bs, ptr->extended_language, (u32)(strlen(ptr->extended_language)+1));\n\t}\n\treturn GF_OK;\n}\n\nGF_Err elng_Size(GF_Box *s)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\n\tif (ptr->extended_language) {\n\t\tptr->size += strlen(ptr->extended_language)+1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid mfhd_del(GF_Box *s)\n{\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err mfhd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *)s;\n\tptr->sequence_number = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *mfhd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentHeaderBox, GF_ISOM_BOX_TYPE_MFHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err mfhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->sequence_number);\n\treturn GF_OK;\n}\n\nGF_Err mfhd_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid minf_del(GF_Box *s)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tif (ptr == NULL) return;\n\n\t//if we have a Handler not self-contained, delete it (the self-contained belongs to the movie)\n\tif (ptr->dataHandler) {\n\t\tgf_isom_datamap_close(ptr);\n\t}\n\tif (ptr->InfoHeader) gf_isom_box_del((GF_Box *)ptr->InfoHeader);\n\tif (ptr->dataInformation) gf_isom_box_del((GF_Box *)ptr->dataInformation);\n\tif (ptr->sampleTable) gf_isom_box_del((GF_Box *)ptr->sampleTable);\n\tgf_free(ptr);\n}\n\nGF_Err minf_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_NMHD:\n\tcase GF_ISOM_BOX_TYPE_STHD:\n\tcase GF_ISOM_BOX_TYPE_VMHD:\n\tcase GF_ISOM_BOX_TYPE_SMHD:\n\tcase GF_ISOM_BOX_TYPE_HMHD:\n\tcase GF_ISOM_BOX_TYPE_GMHD:\n\t\tif (ptr->InfoHeader) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->InfoHeader = a;\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_DINF:\n\t\tif (ptr->dataInformation) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->dataInformation = (GF_DataInformationBox *)a;\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_STBL:\n\t\tif (ptr->sampleTable ) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->sampleTable = (GF_SampleTableBox *)a;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err minf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tGF_Err e;\n\te = gf_isom_box_array_read(s, bs, minf_AddBox);\n\tif (! ptr->dataInformation) {\n\t\tGF_Box *dinf, *dref, *url;\n\t\tBool dump_mode = GF_FALSE;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing DataInformationBox\\n\"));\n\t\t//commented on purpose, we are still able to handle the file, we only throw an error but keep processing\n//\t\te = GF_ISOM_INVALID_FILE;\n\n\t\t//add a dinf box to avoid any access to a null dinf\n\t\tdinf = gf_isom_box_new(GF_ISOM_BOX_TYPE_DINF);\n\t\tif (!dinf) return GF_OUT_OF_MEM;\n\t\tif (ptr->InfoHeader && gf_list_find(ptr->other_boxes, ptr->InfoHeader)>=0) dump_mode = GF_TRUE;\n\t\tif (ptr->sampleTable && gf_list_find(ptr->other_boxes, ptr->sampleTable)>=0) dump_mode = GF_TRUE;\n\n\t\tptr->dataInformation = (GF_DataInformationBox *)dinf;\n\n\t\tdref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n\t\tif (!dref) return GF_OUT_OF_MEM;\n\t\te = dinf_AddBox(dinf, dref);\n\n\t\turl = gf_isom_box_new(GF_ISOM_BOX_TYPE_URL);\n\t\tif (!url) return GF_OUT_OF_MEM;\n\t\t((GF_FullBox*)url)->flags = 1;\n\t\te = gf_isom_box_add_default(dref, url);\n\n\t\tif (dump_mode) {\n\t\t\tgf_list_add(ptr->other_boxes, ptr->dataInformation);\n\t\t\tif (!dinf->other_boxes) dinf->other_boxes = gf_list_new();\n\t\t\tgf_list_add(dinf->other_boxes, dref);\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Box *minf_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaInformationBox, GF_ISOM_BOX_TYPE_MINF);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err minf_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\t//Header first\n\tif (ptr->InfoHeader) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->InfoHeader, bs);\n\t\tif (e) return e;\n\t}\n\t//then dataInfo\n\tif (ptr->dataInformation) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->dataInformation, bs);\n\t\tif (e) return e;\n\t}\n\t//then sampleTable\n\tif (ptr->sampleTable) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->sampleTable, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err minf_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\n\tif (ptr->InfoHeader) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->InfoHeader);\n\t\tif (e) return e;\n\t\tptr->size += ptr->InfoHeader->size;\n\t}\n\tif (ptr->dataInformation) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->dataInformation);\n\t\tif (e) return e;\n\t\tptr->size += ptr->dataInformation->size;\n\t}\n\tif (ptr->sampleTable) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->sampleTable);\n\t\tif (e) return e;\n\t\tptr->size += ptr->sampleTable->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid moof_del(GF_Box *s)\n{\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->mfhd) gf_isom_box_del((GF_Box *) ptr->mfhd);\n\tgf_isom_box_array_del(ptr->TrackList);\n\tif (ptr->mdat) gf_free(ptr->mdat);\n\tgf_free(ptr);\n}\n\nGF_Err moof_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_MFHD:\n\t\tif (ptr->mfhd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\n\t\t\tptr->mfhd = (GF_MovieFragmentHeaderBox *) a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRAF:\n\t\treturn gf_list_add(ptr->TrackList, a);\n\tcase GF_ISOM_BOX_TYPE_PSSH:\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n}\n\nGF_Err moof_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, moof_AddBox);\n}\n\nGF_Box *moof_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentBox, GF_ISOM_BOX_TYPE_MOOF);\n\ttmp->TrackList = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err moof_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\t//Header First\n\tif (ptr->mfhd) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->mfhd, bs);\n\t\tif (e) return e;\n\t}\n//then the track list\nreturn gf_isom_box_array_write(s, ptr->TrackList, bs);\n}\n\nGF_Err moof_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\n\tif (ptr->mfhd) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->mfhd);\n\t\tif (e) return e;\n\t\tptr->size += ptr->mfhd->size;\n\t}\n\treturn gf_isom_box_array_size(s, ptr->TrackList);\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\nvoid moov_del(GF_Box *s)\n{\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->mvhd) gf_isom_box_del((GF_Box *)ptr->mvhd);\n\tif (ptr->meta) gf_isom_box_del((GF_Box *)ptr->meta);\n\tif (ptr->iods) gf_isom_box_del((GF_Box *)ptr->iods);\n\tif (ptr->udta) gf_isom_box_del((GF_Box *)ptr->udta);\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ptr->mvex) gf_isom_box_del((GF_Box *)ptr->mvex);\n#endif\n\n\tgf_isom_box_array_del(ptr->trackList);\n\tgf_free(ptr);\n}\n\n\nGF_Err moov_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_IODS:\n\t\tif (ptr->iods) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->iods = (GF_ObjectDescriptorBox *)a;\n\t\t//if no IOD, delete the box\n\t\tif (!ptr->iods->descriptor) {\n\t\t\tptr->iods = NULL;\n\t\t\tgf_isom_box_del(a);\n\t\t}\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_MVHD:\n\t\tif (ptr->mvhd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->mvhd = (GF_MovieHeaderBox *)a;\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\tif (ptr->udta) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->udta = (GF_UserDataBox *)a;\n\t\treturn GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tcase GF_ISOM_BOX_TYPE_MVEX:\n\t\tif (ptr->mvex) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->mvex = (GF_MovieExtendsBox *)a;\n\t\tptr->mvex->mov = ptr->mov;\n\t\treturn GF_OK;\n#endif\n\n\tcase GF_ISOM_BOX_TYPE_META:\n\t\tif (ptr->meta) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->meta = (GF_MetaBox *)a;\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_TRAK:\n\t\t//set our pointer to this obj\n\t\t((GF_TrackBox *)a)->moov = ptr;\n\t\treturn gf_list_add(ptr->trackList, a);\n\tcase GF_ISOM_BOX_TYPE_PSSH:\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n}\n\n\nGF_Err moov_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\te = gf_isom_box_array_read(s, bs, moov_AddBox);\n\tif (e) {\n\t\treturn e;\n\t}\n\telse {\n\t\tif (!((GF_MovieBox *)s)->mvhd) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MovieHeaderBox\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Box *moov_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieBox, GF_ISOM_BOX_TYPE_MOOV);\n\ttmp->trackList = gf_list_new();\n\tif (!tmp->trackList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err moov_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tif (ptr->mvhd) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->mvhd, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->iods) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->iods, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->meta) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->meta, bs);\n\t\tif (e) return e;\n\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ptr->mvex) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->mvex, bs);\n\t\tif (e) return e;\n\t}\n#endif\n\n\te = gf_isom_box_array_write(s, ptr->trackList, bs);\n\tif (e) return e;\n\n\tif (ptr->udta) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->udta, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err moov_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\n\tif (ptr->mvhd) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->mvhd);\n\t\tif (e) return e;\n\t\tptr->size += ptr->mvhd->size;\n\t}\n\tif (ptr->iods) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->iods);\n\t\tif (e) return e;\n\t\tptr->size += ptr->iods->size;\n\t}\n\tif (ptr->udta) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->udta);\n\t\tif (e) return e;\n\t\tptr->size += ptr->udta->size;\n\t}\n\tif (ptr->meta) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->meta);\n\t\tif (e) return e;\n\t\tptr->size += ptr->meta->size;\n\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ptr->mvex) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->mvex);\n\t\tif (e) return e;\n\t\tptr->size += ptr->mvex->size;\n\t}\n#endif\n\n\treturn gf_isom_box_array_size(s, ptr->trackList);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid audio_sample_entry_del(GF_Box *s)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->esd) gf_isom_box_del((GF_Box *)ptr->esd);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tif (ptr->cfg_ac3) gf_isom_box_del((GF_Box *)ptr->cfg_ac3);\n\tif (ptr->cfg_3gpp) gf_isom_box_del((GF_Box *)ptr->cfg_3gpp);\n\tgf_free(ptr);\n}\n\nGF_Err audio_sample_entry_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tif (ptr->esd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->esd = (GF_ESDBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SINF:\n\t\tgf_list_add(ptr->protections, a);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DAMR:\n\tcase GF_ISOM_BOX_TYPE_DEVC:\n\tcase GF_ISOM_BOX_TYPE_DQCP:\n\tcase GF_ISOM_BOX_TYPE_DSMV:\n\t\tptr->cfg_3gpp = (GF_3GPPConfigBox *) a;\n\t\t/*for 3GP config, remember sample entry type in config*/\n\t\tptr->cfg_3gpp->cfg.type = ptr->type;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_DAC3:\n\t\tptr->cfg_ac3 = (GF_AC3ConfigBox *) a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DEC3:\n\t\tptr->cfg_ac3 = (GF_AC3ConfigBox *) a;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\tif (ptr->esd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\t/*HACK for QT files: get the esds box from the track*/\n\t\t{\n\t\t\tGF_UnknownBox *wave = (GF_UnknownBox *)a;\n\t\t\t//wave subboxes may have been properly parsed\n \t\t\tif ((wave->original_4cc == GF_ISOM_BOX_TYPE_WAVE) && gf_list_count(wave->other_boxes)) {\n \t\t\t\tu32 i;\n                for (i =0; i<gf_list_count(wave->other_boxes); i++) {\n                    GF_Box *inner_box = (GF_Box *)gf_list_get(wave->other_boxes, i);\n                    if (inner_box->type == GF_ISOM_BOX_TYPE_ESDS) {\n                        ptr->esd = (GF_ESDBox *)inner_box;\n                    }\n                }\n                return gf_isom_box_add_default(s, a);\n            }\n            //unknown fomat, look for 'es' (esds) and try to parse box\n            else if (wave->data != NULL) {\n                u32 offset = 0;\n                while ((wave->data[offset + 4] != 'e') && (wave->data[offset + 5] != 's')) {\n                    offset++;\n                    if (offset == wave->dataSize) break;\n                }\n                if (offset < wave->dataSize) {\n                    GF_Box *a;\n                    GF_Err e;\n                    GF_BitStream *bs = gf_bs_new(wave->data + offset, wave->dataSize - offset, GF_BITSTREAM_READ);\n                    e = gf_isom_box_parse(&a, bs);\n                    gf_bs_del(bs);\n                    if (e) return e;\n                    ptr->esd = (GF_ESDBox *)a;\n                    gf_isom_box_add_for_dump_mode((GF_Box *)ptr, a);\n\n                }\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Cannot process box %s!\\n\", gf_4cc_to_str(wave->original_4cc)));\n\t\t\t\treturn gf_isom_box_add_default(s, a);\n\t\t\t}\n\t\t\tgf_isom_box_del(a);\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\nGF_Err audio_sample_entry_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr;\n\tchar *data;\n\tu32 i, size;\n\tGF_Err e;\n\tu64 pos;\n\n\te = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs);\n\tsize = (u32) s->size;\n\n\te = gf_isom_box_array_read(s, bs, audio_sample_entry_AddBox);\n\tif (!e) return GF_OK;\n\tif (size<8) return GF_ISOM_INVALID_FILE;\n\n\t/*hack for some weird files (possibly recorded with live.com tools, needs further investigations)*/\n\tptr = (GF_MPEGAudioSampleEntryBox *)s;\n\tgf_bs_seek(bs, pos);\n\tdata = (char*)gf_malloc(sizeof(char) * size);\n\tgf_bs_read_data(bs, data, size);\n\tfor (i=0; i<size-8; i++) {\n\t\tif (GF_4CC(data[i+4], data[i+5], data[i+6], data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {\n\t\t\tGF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);\n\t\t\te = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);\n\t\t\tgf_bs_del(mybs);\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}\n\nGF_Box *audio_sample_entry_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGAudioSampleEntryBox, GF_ISOM_BOX_TYPE_MP4A);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *enca_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGAudioSampleEntryBox, GF_ISOM_BOX_TYPE_ENCA);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err audio_sample_entry_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_isom_audio_sample_entry_write((GF_AudioSampleEntryBox*)s, bs);\n\tif (ptr->esd) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->esd, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->cfg_3gpp) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->cfg_3gpp, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->cfg_ac3) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->cfg_ac3, bs);\n\t\tif (e) return e;\n\t}\n\treturn gf_isom_box_array_write(s, ptr->protections, bs);\n}\n\nGF_Err audio_sample_entry_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tgf_isom_audio_sample_entry_size((GF_AudioSampleEntryBox*)s);\n\tif (ptr->esd) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->esd);\n\t\tif (e) return e;\n\t\tptr->size += ptr->esd->size;\n\t}\n\tif (ptr->cfg_3gpp) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->cfg_3gpp);\n\t\tif (e) return e;\n\t\tptr->size += ptr->cfg_3gpp->size;\n\t}\n\tif (ptr->cfg_ac3) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->cfg_ac3);\n\t\tif (e) return e;\n\t\tptr->size += ptr->cfg_ac3->size;\n\t}\n\treturn gf_isom_box_array_size(s, ptr->protections);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid mp4s_del(GF_Box *s)\n{\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->esd) gf_isom_box_del((GF_Box *)ptr->esd);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tgf_free(ptr);\n}\n\nGF_Err mp4s_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tif (ptr->esd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->esd = (GF_ESDBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SINF:\n\t\tgf_list_add(ptr->protections, a);\n\t\tbreak;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mp4s_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\treturn gf_isom_box_array_read(s, bs, mp4s_AddBox);\n}\n\nGF_Box *mp4s_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_MP4S);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *encs_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_ENCS);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mp4s_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\te = gf_isom_box_write((GF_Box *)ptr->esd, bs);\n\tif (e) return e;\n\treturn gf_isom_box_array_write(s, ptr->protections, bs);\n}\n\nGF_Err mp4s_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\n\tptr->size += 8;\n\te = gf_isom_box_size((GF_Box *)ptr->esd);\n\tif (e) return e;\n\tptr->size += ptr->esd->size;\n\treturn gf_isom_box_array_size(s, ptr->protections);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid video_sample_entry_del(GF_Box *s)\n{\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->esd) gf_isom_box_del((GF_Box *)ptr->esd);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\t/*for publishing*/\n\tif (ptr->emul_esd) gf_odf_desc_del((GF_Descriptor *)ptr->emul_esd);\n\n\tif (ptr->avc_config) gf_isom_box_del((GF_Box *) ptr->avc_config);\n\tif (ptr->svc_config) gf_isom_box_del((GF_Box *) ptr->svc_config);\n\tif (ptr->mvc_config) gf_isom_box_del((GF_Box *) ptr->mvc_config);\n\tif (ptr->hevc_config) gf_isom_box_del((GF_Box *) ptr->hevc_config);\n\tif (ptr->lhvc_config) gf_isom_box_del((GF_Box *) ptr->lhvc_config);\n\tif (ptr->cfg_3gpp) gf_isom_box_del((GF_Box *)ptr->cfg_3gpp);\n\n\tif (ptr->descr) gf_isom_box_del((GF_Box *) ptr->descr);\n\tif (ptr->ipod_ext) gf_isom_box_del((GF_Box *)ptr->ipod_ext);\n\n\tif (ptr->pasp) gf_isom_box_del((GF_Box *)ptr->pasp);\n\tif (ptr->clap) gf_isom_box_del((GF_Box *)ptr->clap);\n\tif (ptr->rinf) gf_isom_box_del((GF_Box *)ptr->rinf);\n\n\tif (ptr->rvcc) gf_isom_box_del((GF_Box *)ptr->rvcc);\n\n\tgf_free(ptr);\n}\n\nGF_Err video_sample_entry_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tif (ptr->esd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->esd = (GF_ESDBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SINF:\n\t\tgf_list_add(ptr->protections, a);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_RINF:\n\t\tif (ptr->rinf) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->rinf = (GF_RestrictedSchemeInfoBox *) a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVCC:\n\t\tif (ptr->avc_config) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->avc_config = (GF_AVCConfigurationBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_HVCC:\n\t\tif (ptr->hevc_config) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->hevc_config = (GF_HEVCConfigurationBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SVCC:\n\t\tif (ptr->svc_config) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->svc_config = (GF_AVCConfigurationBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MVCC:\n\t\tif (ptr->mvc_config) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->mvc_config = (GF_AVCConfigurationBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_LHVC:\n\t\tif (ptr->lhvc_config) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->lhvc_config = (GF_HEVCConfigurationBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_M4DS:\n\t\tif (ptr->descr) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->descr = (GF_MPEG4ExtensionDescriptorsBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif (! memcmp(((GF_UnknownUUIDBox*)a)->uuid, GF_ISOM_IPOD_EXT, 16)) {\n\t\t\tif (ptr->ipod_ext) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->ipod_ext = (GF_UnknownUUIDBox *)a;\n\t\t} else {\n\t\t\treturn gf_isom_box_add_default(s, a);\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_D263:\n\t\tptr->cfg_3gpp = (GF_3GPPConfigBox *)a;\n\t\t/*for 3GP config, remember sample entry type in config*/\n\t\tptr->cfg_3gpp->cfg.type = ptr->type;\n\t\tbreak;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_PASP:\n\t\tif (ptr->pasp) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->pasp = (GF_PixelAspectRatioBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_CLAP:\n\t\tif (ptr->clap) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->clap = (GF_CleanAppertureBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_RVCC:\n\t\tif (ptr->rvcc) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->rvcc = (GF_RVCConfigurationBox *)a;\n\t\tbreak;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err video_sample_entry_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGVisualSampleEntryBox *mp4v = (GF_MPEGVisualSampleEntryBox*)s;\n\tGF_Err e;\n\te = gf_isom_video_sample_entry_read((GF_VisualSampleEntryBox *)s, bs);\n\tif (e) return e;\n\te = gf_isom_box_array_read(s, bs, video_sample_entry_AddBox);\n\tif (e) return e;\n\t/*this is an AVC sample desc*/\n\tif (mp4v->avc_config || mp4v->svc_config || mp4v->mvc_config) AVC_RewriteESDescriptor(mp4v);\n\t/*this is an HEVC sample desc*/\n\tif (mp4v->hevc_config || mp4v->lhvc_config || (mp4v->type==GF_ISOM_BOX_TYPE_HVT1))\n\t\tHEVC_RewriteESDescriptor(mp4v);\n\treturn GF_OK;\n}\n\nGF_Box *video_sample_entry_New()\n{\n\tGF_MPEGVisualSampleEntryBox *tmp;\n\tGF_SAFEALLOC(tmp, GF_MPEGVisualSampleEntryBox);\n\tif (tmp == NULL) return NULL;\n\n\tgf_isom_video_sample_entry_init((GF_VisualSampleEntryBox *)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err video_sample_entry_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_isom_video_sample_entry_write((GF_VisualSampleEntryBox *)s, bs);\n\n\t/*mp4v*/\n\tif (ptr->esd) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->esd, bs);\n\t\tif (e) return e;\n\t}\n\t/*mp4v*/\n\telse if (ptr->cfg_3gpp) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->cfg_3gpp, bs);\n\t\tif (e) return e;\n\t}\n\t/*avc or hevc*/\n\telse {\n\t\tif (ptr->avc_config && ptr->avc_config->config) {\n\t\t\te = gf_isom_box_write((GF_Box *) ptr->avc_config, bs);\n\t\t\tif (e) return e;\n\t\t}\n\t\tif (ptr->hevc_config && ptr->hevc_config->config) {\n\t\t\te = gf_isom_box_write((GF_Box *) ptr->hevc_config, bs);\n\t\t\tif (e) return e;\n\t\t}\n\t\tif (ptr->ipod_ext)\t{\n\t\t\te = gf_isom_box_write((GF_Box *) ptr->ipod_ext, bs);\n\t\t\tif (e) return e;\n\t\t}\n\t\tif (ptr->descr)\t{\n\t\t\te = gf_isom_box_write((GF_Box *) ptr->descr, bs);\n\t\t\tif (e) return e;\n\t\t}\n\t\tif (ptr->svc_config && ptr->svc_config->config) {\n\t\t\te = gf_isom_box_write((GF_Box *) ptr->svc_config, bs);\n\t\t\tif (e) return e;\n\t\t}\n\t\tif (ptr->mvc_config && ptr->mvc_config->config) {\n\t\t\te = gf_isom_box_write((GF_Box *) ptr->mvc_config, bs);\n\t\t\tif (e) return e;\n\t\t}\n\t\tif (ptr->lhvc_config && ptr->lhvc_config->config) {\n\t\t\te = gf_isom_box_write((GF_Box *) ptr->lhvc_config, bs);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\tif (ptr->pasp) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->pasp, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->clap) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->clap, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->rvcc) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->rvcc, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->rinf) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->rinf, bs);\n\t\tif (e) return e;\n\t}\n\treturn gf_isom_box_array_write(s, ptr->protections, bs);\n}\n\nGF_Err video_sample_entry_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\n\tif (ptr->esd) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->esd);\n\t\tif (e) return e;\n\t\tptr->size += ptr->esd->size;\n\t} else if (ptr->cfg_3gpp) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->cfg_3gpp);\n\t\tif (e) return e;\n\t\tptr->size += ptr->cfg_3gpp->size;\n\t} else {\n\t\tif (!ptr->avc_config && !ptr->svc_config && !ptr->hevc_config && !ptr->lhvc_config && (ptr->type!=GF_ISOM_BOX_TYPE_HVT1) ) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tif (ptr->hevc_config && ptr->hevc_config->config) {\n\t\t\te = gf_isom_box_size((GF_Box *)ptr->hevc_config);\n\t\t\tif (e) return e;\n\t\t\tptr->size += ptr->hevc_config->size;\n\t\t}\n\n\t\tif (ptr->avc_config && ptr->avc_config->config) {\n\t\t\te = gf_isom_box_size((GF_Box *) ptr->avc_config);\n\t\t\tif (e) return e;\n\t\t\tptr->size += ptr->avc_config->size;\n\t\t}\n\n\t\tif (ptr->svc_config && ptr->svc_config->config) {\n\t\t\te = gf_isom_box_size((GF_Box *) ptr->svc_config);\n\t\t\tif (e) return e;\n\t\t\tptr->size += ptr->svc_config->size;\n\t\t}\n\n\t\tif (ptr->mvc_config && ptr->mvc_config->config) {\n\t\t\te = gf_isom_box_size((GF_Box *) ptr->mvc_config);\n\t\t\tif (e) return e;\n\t\t\tptr->size += ptr->mvc_config->size;\n\t\t}\n\n\t\tif (ptr->lhvc_config && ptr->lhvc_config->config) {\n\t\t\te = gf_isom_box_size((GF_Box *) ptr->lhvc_config);\n\t\t\tif (e) return e;\n\t\t\tptr->size += ptr->lhvc_config->size;\n\t\t}\n\n\t\tif (ptr->ipod_ext) {\n\t\t\te = gf_isom_box_size((GF_Box *) ptr->ipod_ext);\n\t\t\tif (e) return e;\n\t\t\tptr->size += ptr->ipod_ext->size;\n\t\t}\n\t\tif (ptr->descr) {\n\t\t\te = gf_isom_box_size((GF_Box *) ptr->descr);\n\t\t\tif (e) return e;\n\t\t\tptr->size += ptr->descr->size;\n\t\t}\n\t}\n\tif (ptr->pasp) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->pasp);\n\t\tif (e) return e;\n\t\tptr->size += ptr->pasp->size;\n\t}\n\tif (ptr->clap) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->clap);\n\t\tif (e) return e;\n\t\tptr->size += ptr->clap->size;\n\t}\n\tif (ptr->rvcc) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->rvcc);\n\t\tif (e) return e;\n\t\tptr->size += ptr->rvcc->size;\n\t}\n\tif (ptr->rinf) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->rinf);\n\t\tif (e) return e;\n\t\tptr->size += ptr->rinf->size;\n\t}\n\treturn gf_isom_box_array_size(s, ptr->protections);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid mvex_del(GF_Box *s)\n{\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->mehd) gf_isom_box_del((GF_Box*)ptr->mehd);\n\tgf_isom_box_array_del(ptr->TrackExList);\n\tgf_isom_box_array_del(ptr->TrackExPropList);\n\tgf_free(ptr);\n}\n\n\nGF_Err mvex_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TREX:\n\t\treturn gf_list_add(ptr->TrackExList, a);\n\tcase GF_ISOM_BOX_TYPE_TREP:\n\t\treturn gf_list_add(ptr->TrackExPropList, a);\n\tcase GF_ISOM_BOX_TYPE_MEHD:\n\t\tif (ptr->mehd) break;\n\t\tptr->mehd = (GF_MovieExtendsHeaderBox*)a;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\n\n\nGF_Err mvex_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, mvex_AddBox);\n}\n\nGF_Box *mvex_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieExtendsBox, GF_ISOM_BOX_TYPE_MVEX);\n\ttmp->TrackExList = gf_list_new();\n\tif (!tmp->TrackExList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\ttmp->TrackExPropList = gf_list_new();\n\tif (!tmp->TrackExPropList) {\n\t\tgf_list_del(tmp->TrackExList);\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err mvex_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->mehd) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->mehd, bs);\n\t\tif (e) return e;\n\t}\n\te = gf_isom_box_array_write(s, ptr->TrackExList, bs);\n\tif (e) return e;\n\treturn gf_isom_box_array_write(s, ptr->TrackExPropList, bs);\n}\n\nGF_Err mvex_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *)s;\n\n\tif (ptr->mehd) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->mehd);\n\t\tif (e) return e;\n\t\tptr->size += ptr->mehd->size;\n\t}\n\te = gf_isom_box_array_size(s, ptr->TrackExList);\n\tif (e) return e;\n\treturn gf_isom_box_array_size(s, ptr->TrackExPropList);\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *mehd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieExtendsHeaderBox, GF_ISOM_BOX_TYPE_MEHD);\n\treturn (GF_Box *)tmp;\n}\nvoid mehd_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err mehd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\n\tif (ptr->version==1) {\n\t\tptr->fragment_duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tptr->fragment_duration = (u64) gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err mehd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\tGF_Err e = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->fragment_duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->fragment_duration);\n\t}\n\treturn GF_OK;\n}\nGF_Err mehd_Size(GF_Box *s)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\tptr->version = (ptr->fragment_duration>0xFFFFFFFF) ? 1 : 0;\n\ts->size += (ptr->version == 1) ? 8 : 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid mvhd_del(GF_Box *s)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err mvhd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tif (ptr->version == 1) {\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tif (!ptr->timeScale) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Movie header timescale is invalid (0) - defaulting to 600\\n\" ));\n\t\tptr->timeScale = 600;\n\t}\n\tptr->preferredRate = gf_bs_read_u32(bs);\n\tptr->preferredVolume = gf_bs_read_u16(bs);\n\tgf_bs_read_data(bs, ptr->reserved, 10);\n\tptr->matrixA = gf_bs_read_u32(bs);\n\tptr->matrixB = gf_bs_read_u32(bs);\n\tptr->matrixU = gf_bs_read_u32(bs);\n\tptr->matrixC = gf_bs_read_u32(bs);\n\tptr->matrixD = gf_bs_read_u32(bs);\n\tptr->matrixV = gf_bs_read_u32(bs);\n\tptr->matrixX = gf_bs_read_u32(bs);\n\tptr->matrixY = gf_bs_read_u32(bs);\n\tptr->matrixW = gf_bs_read_u32(bs);\n\tptr->previewTime = gf_bs_read_u32(bs);\n\tptr->previewDuration = gf_bs_read_u32(bs);\n\tptr->posterTime = gf_bs_read_u32(bs);\n\tptr->selectionTime = gf_bs_read_u32(bs);\n\tptr->selectionDuration = gf_bs_read_u32(bs);\n\tptr->currentTime = gf_bs_read_u32(bs);\n\tptr->nextTrackID = gf_bs_read_u32(bs);\n\tptr->original_duration = ptr->duration;\n\treturn GF_OK;\n}\n\nGF_Box *mvhd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieHeaderBox, GF_ISOM_BOX_TYPE_MVHD);\n\n\ttmp->preferredRate = (1<<16);\n\ttmp->preferredVolume = (1<<8);\n\n\ttmp->matrixA = (1<<16);\n\ttmp->matrixD = (1<<16);\n\ttmp->matrixW = (1<<30);\n\n\ttmp->nextTrackID = 1;\n\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mvhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\tgf_bs_write_u32(bs, ptr->preferredRate);\n\tgf_bs_write_u16(bs, ptr->preferredVolume);\n\tgf_bs_write_data(bs, ptr->reserved, 10);\n\tgf_bs_write_u32(bs, ptr->matrixA);\n\tgf_bs_write_u32(bs, ptr->matrixB);\n\tgf_bs_write_u32(bs, ptr->matrixU);\n\tgf_bs_write_u32(bs, ptr->matrixC);\n\tgf_bs_write_u32(bs, ptr->matrixD);\n\tgf_bs_write_u32(bs, ptr->matrixV);\n\tgf_bs_write_u32(bs, ptr->matrixX);\n\tgf_bs_write_u32(bs, ptr->matrixY);\n\tgf_bs_write_u32(bs, ptr->matrixW);\n\tgf_bs_write_u32(bs, ptr->previewTime);\n\tgf_bs_write_u32(bs, ptr->previewDuration);\n\tgf_bs_write_u32(bs, ptr->posterTime);\n\tgf_bs_write_u32(bs, ptr->selectionTime);\n\tgf_bs_write_u32(bs, ptr->selectionDuration);\n\tgf_bs_write_u32(bs, ptr->currentTime);\n\tgf_bs_write_u32(bs, ptr->nextTrackID);\n\treturn GF_OK;\n}\n\nGF_Err mvhd_Size(GF_Box *s)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr->duration==(u64) -1) ptr->version = 0;\n\telse ptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\n\tptr->size += (ptr->version == 1) ? 28 : 16;\n\tptr->size += 80;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid nmhd_del(GF_Box *s)\n{\n\tGF_MPEGMediaHeaderBox *ptr = (GF_MPEGMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\n\nGF_Err nmhd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\nGF_Box *nmhd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGMediaHeaderBox, GF_ISOM_BOX_TYPE_NMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err nmhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err nmhd_Size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid padb_del(GF_Box *s)\n{\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->padbits) gf_free(ptr->padbits);\n\tgf_free(ptr);\n}\n\n\nGF_Err padb_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *)s;\n\n\tptr->SampleCount = gf_bs_read_u32(bs);\n\n\tptr->padbits = (u8 *)gf_malloc(sizeof(u8)*ptr->SampleCount);\n\tfor (i=0; i<ptr->SampleCount; i += 2) {\n\t\tgf_bs_read_int(bs, 1);\n\t\tif (i+1 < ptr->SampleCount) {\n\t\t\tptr->padbits[i+1] = gf_bs_read_int(bs, 3);\n\t\t} else {\n\t\t\tgf_bs_read_int(bs, 3);\n\t\t}\n\t\tgf_bs_read_int(bs, 1);\n\t\tptr->padbits[i] = gf_bs_read_int(bs, 3);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *padb_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PaddingBitsBox, GF_ISOM_BOX_TYPE_PADB);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err padb_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->SampleCount, 32);\n\n\tfor (i=0 ; i<ptr->SampleCount; i += 2) {\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tif (i+1 < ptr->SampleCount) {\n\t\t\tgf_bs_write_int(bs, ptr->padbits[i+1], 3);\n\t\t} else {\n\t\t\tgf_bs_write_int(bs, 0, 3);\n\t\t}\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tgf_bs_write_int(bs, ptr->padbits[i], 3);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err padb_Size(GF_Box *s)\n{\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *)s;\n\tptr->size += 4;\n\tif (ptr->SampleCount) ptr->size += (ptr->SampleCount + 1) / 2;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid rely_del(GF_Box *s)\n{\n\tGF_RelyHintBox *rely = (GF_RelyHintBox *)s;\n\tgf_free(rely);\n}\n\nGF_Err rely_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_RelyHintBox *ptr = (GF_RelyHintBox *)s;\n\tptr->reserved = gf_bs_read_int(bs, 6);\n\tptr->prefered = gf_bs_read_int(bs, 1);\n\tptr->required = gf_bs_read_int(bs, 1);\n\treturn GF_OK;\n}\n\nGF_Box *rely_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RelyHintBox, GF_ISOM_BOX_TYPE_RELY);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rely_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RelyHintBox *ptr = (GF_RelyHintBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->reserved, 6);\n\tgf_bs_write_int(bs, ptr->prefered, 1);\n\tgf_bs_write_int(bs, ptr->required, 1);\n\treturn GF_OK;\n}\n\nGF_Err rely_Size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid rtpo_del(GF_Box *s)\n{\n\tGF_RTPOBox *rtpo = (GF_RTPOBox *)s;\n\tgf_free(rtpo);\n}\n\nGF_Err rtpo_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_RTPOBox *ptr = (GF_RTPOBox *)s;\n\tptr->timeOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *rtpo_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RTPOBox, GF_ISOM_BOX_TYPE_RTPO);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rtpo_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RTPOBox *ptr = (GF_RTPOBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\t//here we have no pb, just remembed that some entries will have to\n\t//be 4-bytes aligned ...\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->timeOffset);\n\treturn GF_OK;\n}\n\nGF_Err rtpo_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid smhd_del(GF_Box *s)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\tif (ptr == NULL ) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err smhd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\tptr->balance = gf_bs_read_u16(bs);\n\tptr->reserved = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\nGF_Box *smhd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SoundMediaHeaderBox, GF_ISOM_BOX_TYPE_SMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err smhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->balance);\n\tgf_bs_write_u16(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err smhd_Size(GF_Box *s)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\n\tptr->reserved = 0;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid snro_del(GF_Box *s)\n{\n\tGF_SeqOffHintEntryBox *snro = (GF_SeqOffHintEntryBox *)s;\n\tgf_free(snro);\n}\n\nGF_Err snro_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SeqOffHintEntryBox *ptr = (GF_SeqOffHintEntryBox *)s;\n\tptr->SeqOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *snro_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SeqOffHintEntryBox, GF_ISOM_BOX_TYPE_SNRO);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err snro_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SeqOffHintEntryBox *ptr = (GF_SeqOffHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->SeqOffset);\n\treturn GF_OK;\n}\n\nGF_Err snro_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n#define WRITE_SAMPLE_FRAGMENTS\t\t1\n\nvoid stbl_del(GF_Box *s)\n{\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->ChunkOffset) gf_isom_box_del(ptr->ChunkOffset);\n\tif (ptr->CompositionOffset) gf_isom_box_del((GF_Box *) ptr->CompositionOffset);\n\tif (ptr->CompositionToDecode) gf_isom_box_del((GF_Box *) ptr->CompositionToDecode);\n\tif (ptr->DegradationPriority) gf_isom_box_del((GF_Box *) ptr->DegradationPriority);\n\tif (ptr->SampleDescription) gf_isom_box_del((GF_Box *) ptr->SampleDescription);\n\tif (ptr->SampleSize) gf_isom_box_del((GF_Box *) ptr->SampleSize);\n\tif (ptr->SampleToChunk) gf_isom_box_del((GF_Box *) ptr->SampleToChunk);\n\tif (ptr->ShadowSync) gf_isom_box_del((GF_Box *) ptr->ShadowSync);\n\tif (ptr->SyncSample) gf_isom_box_del((GF_Box *) ptr->SyncSample);\n\tif (ptr->TimeToSample) gf_isom_box_del((GF_Box *) ptr->TimeToSample);\n\tif (ptr->SampleDep) gf_isom_box_del((GF_Box *) ptr->SampleDep);\n\tif (ptr->PaddingBits) gf_isom_box_del((GF_Box *) ptr->PaddingBits);\n\tif (ptr->Fragments) gf_isom_box_del((GF_Box *) ptr->Fragments);\n\tif (ptr->sub_samples) gf_isom_box_array_del(ptr->sub_samples);\n\tif (ptr->sampleGroups) gf_isom_box_array_del(ptr->sampleGroups);\n\tif (ptr->sampleGroupsDescription) gf_isom_box_array_del(ptr->sampleGroupsDescription);\n\n\tif (ptr->sai_sizes) gf_isom_box_array_del(ptr->sai_sizes);\n\tif (ptr->sai_offsets) gf_isom_box_array_del(ptr->sai_offsets);\n\n\tgf_free(ptr);\n}\n\nGF_Err stbl_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\tif (!a) return GF_OK;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_STTS:\n\t\tif (ptr->TimeToSample) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->TimeToSample = (GF_TimeToSampleBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_CTTS:\n\t\tif (ptr->CompositionOffset) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->CompositionOffset = (GF_CompositionOffsetBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_CSLG:\n\t\tif (ptr->CompositionToDecode) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->CompositionToDecode = (GF_CompositionToDecodeBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSS:\n\t\tif (ptr->SyncSample) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->SyncSample = (GF_SyncSampleBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSD:\n\t\tif (ptr->SampleDescription) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->SampleDescription  =(GF_SampleDescriptionBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STZ2:\n\tcase GF_ISOM_BOX_TYPE_STSZ:\n\t\tif (ptr->SampleSize) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->SampleSize = (GF_SampleSizeBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSC:\n\t\tif (ptr->SampleToChunk) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->SampleToChunk = (GF_SampleToChunkBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_PADB:\n\t\tif (ptr->PaddingBits) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->PaddingBits = (GF_PaddingBitsBox *) a;\n\t\tbreak;\n\n\t//WARNING: AS THIS MAY CHANGE DYNAMICALLY DURING EDIT,\n\tcase GF_ISOM_BOX_TYPE_CO64:\n\tcase GF_ISOM_BOX_TYPE_STCO:\n\t\tif (ptr->ChunkOffset) {\n\t\t\tgf_isom_box_del(ptr->ChunkOffset);\n\t\t}\n\t\tptr->ChunkOffset = a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_STSH:\n\t\tif (ptr->ShadowSync) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->ShadowSync = (GF_ShadowSyncBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STDP:\n\t\tif (ptr->DegradationPriority) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->DegradationPriority = (GF_DegradationPriorityBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SDTP:\n\t\tif (ptr->SampleDep) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->SampleDep= (GF_SampleDependencyTypeBox *)a;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_STSF:\n\t\tif (ptr->Fragments) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->Fragments = (GF_SampleFragmentBox *)a;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_SUBS:\n\t\tif (!ptr->sub_samples) ptr->sub_samples = gf_list_new();\n\t\tgf_list_add(ptr->sub_samples, a);\n\t\t//check subsample box\n\t\t{\n\t\t\tGF_SubSampleInformationBox *subs = (GF_SubSampleInformationBox *)a;\n\t\t\tGF_SubSampleInfoEntry *ent = gf_list_get(subs->Samples, 0);\n\t\t\tif (ent->sample_delta==0) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] first entry in SubSample in track SampleTable has sample_delta of 0, should be one. Fixing\\n\"));\n\t\t\t\tent->sample_delta = 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_SBGP:\n\t\tif (!ptr->sampleGroups) ptr->sampleGroups = gf_list_new();\n\t\tgf_list_add(ptr->sampleGroups, a);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SGPD:\n\t\tif (!ptr->sampleGroupsDescription) ptr->sampleGroupsDescription = gf_list_new();\n\t\tgf_list_add(ptr->sampleGroupsDescription, a);\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_SAIZ:\n\t\tif (!ptr->sai_sizes) ptr->sai_sizes = gf_list_new();\n\t\tgf_list_add(ptr->sai_sizes, a);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SAIO:\n\t\tif (!ptr->sai_offsets) ptr->sai_offsets = gf_list_new();\n\t\tgf_list_add(ptr->sai_offsets, a);\n\t\tbreak;\n\tdefault:\n\t\treturn gf_isom_box_add_default((GF_Box *)ptr, a);\n\t}\n\treturn GF_OK;\n}\n\n\n\n\nGF_Err stbl_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\t//we need to parse DegPrior in a special way\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\n\te = gf_isom_box_array_read(s, bs, stbl_AddBox);\n\tif (e) return e;\n\n\tif (!ptr->SyncSample)\n\t\tptr->no_sync_found = 1;\n\n\tptr->nb_sgpd_in_stbl = gf_list_count(ptr->sampleGroupsDescription);\n\tptr->nb_other_boxes_in_stbl = gf_list_count(ptr->other_boxes);\n\n\treturn GF_OK;\n}\n\nGF_Box *stbl_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleTableBox, GF_ISOM_BOX_TYPE_STBL);\n\t//maxSamplePer chunk is 10 by default\n\ttmp->MaxSamplePerChunk = 10;\n\ttmp->groupID = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stbl_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tif (ptr->SampleDescription) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->SampleDescription, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->TimeToSample) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->TimeToSample, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->CompositionOffset)\t{\n\t\te = gf_isom_box_write((GF_Box *) ptr->CompositionOffset, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->CompositionToDecode)\t{\n\t\te = gf_isom_box_write((GF_Box *) ptr->CompositionToDecode, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->SyncSample) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->SyncSample, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->ShadowSync) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->ShadowSync, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->SampleToChunk) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->SampleToChunk, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->SampleSize) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->SampleSize, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->ChunkOffset) {\n\t\te = gf_isom_box_write(ptr->ChunkOffset, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->DegradationPriority) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->DegradationPriority, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->SampleDep && ptr->SampleDep->sampleCount) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->SampleDep, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->PaddingBits) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->PaddingBits, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sub_samples) {\n\t\te = gf_isom_box_array_write(s, ptr->sub_samples, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sampleGroupsDescription) {\n\t\te = gf_isom_box_array_write(s, ptr->sampleGroupsDescription, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sampleGroups) {\n\t\te = gf_isom_box_array_write(s, ptr->sampleGroups, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sai_sizes) {\n\t\te = gf_isom_box_array_write(s, ptr->sai_sizes, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sai_offsets) {\n\t\te = gf_isom_box_array_write(s, ptr->sai_offsets, bs);\n\t\tif (e) return e;\n\t}\n\n#if WRITE_SAMPLE_FRAGMENTS\n\t//sampleFragments\n\tif (ptr->Fragments) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->Fragments, bs);\n\t\tif (e) return e;\n\t}\n#endif\n\treturn GF_OK;\n}\n\nGF_Err stbl_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\n\t//Mandatory boxs (but not internally :)\n\tif (ptr->SampleDescription) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->SampleDescription);\n\t\tif (e) return e;\n\t\tptr->size += ptr->SampleDescription->size;\n\t}\n\tif (ptr->SampleSize) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->SampleSize);\n\t\tif (e) return e;\n\t\tptr->size += ptr->SampleSize->size;\n\t}\n\tif (ptr->SampleToChunk) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->SampleToChunk);\n\t\tif (e) return e;\n\t\tptr->size += ptr->SampleToChunk->size;\n\t}\n\tif (ptr->TimeToSample) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->TimeToSample);\n\t\tif (e) return e;\n\t\tptr->size += ptr->TimeToSample->size;\n\t}\n\tif (ptr->ChunkOffset) {\n\t\te = gf_isom_box_size(ptr->ChunkOffset);\n\t\tif (e) return e;\n\t\tptr->size += ptr->ChunkOffset->size;\n\t}\n\n\t//optional boxs\n\tif (ptr->CompositionOffset)\t{\n\t\te = gf_isom_box_size((GF_Box *) ptr->CompositionOffset);\n\t\tif (e) return e;\n\t\tptr->size += ptr->CompositionOffset->size;\n\t}\n\tif (ptr->CompositionToDecode)\t{\n\t\te = gf_isom_box_size((GF_Box *) ptr->CompositionToDecode);\n\t\tif (e) return e;\n\t\tptr->size += ptr->CompositionToDecode->size;\n\t}\n\tif (ptr->DegradationPriority) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->DegradationPriority);\n\t\tif (e) return e;\n\t\tptr->size += ptr->DegradationPriority->size;\n\t}\n\tif (ptr->ShadowSync) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->ShadowSync);\n\t\tif (e) return e;\n\t\tptr->size += ptr->ShadowSync->size;\n\t}\n\tif (ptr->SyncSample) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->SyncSample);\n\t\tif (e) return e;\n\t\tptr->size += ptr->SyncSample->size;\n\t}\n\tif (ptr->SampleDep && ptr->SampleDep->sampleCount) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->SampleDep);\n\t\tif (e) return e;\n\t\tptr->size += ptr->SampleDep->size;\n\t}\n\t//padb\n\tif (ptr->PaddingBits) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->PaddingBits);\n\t\tif (e) return e;\n\t\tptr->size += ptr->PaddingBits->size;\n\t}\n#if WRITE_SAMPLE_FRAGMENTS\n\t//sample fragments\n\tif (ptr->Fragments) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->Fragments);\n\t\tif (e) return e;\n\t\tptr->size += ptr->Fragments->size;\n\t}\n#endif\n\n\tif (ptr->sub_samples) {\n\t\te = gf_isom_box_array_size(s, ptr->sub_samples);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sampleGroups) {\n\t\te = gf_isom_box_array_size(s, ptr->sampleGroups);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sampleGroupsDescription) {\n\t\te = gf_isom_box_array_size(s, ptr->sampleGroupsDescription);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sai_sizes) {\n\t\te = gf_isom_box_array_size(s, ptr->sai_sizes);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sai_offsets) {\n\t\te = gf_isom_box_array_size(s, ptr->sai_offsets);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stco_del(GF_Box *s)\n{\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tgf_free(ptr);\n}\n\n\nGF_Err stco_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entries;\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tif (ptr->nb_entries > ptr->size / 4) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stco\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tif (ptr->nb_entries) {\n\t\tptr->offsets = (u32 *) gf_malloc(ptr->nb_entries * sizeof(u32) );\n\t\tif (ptr->offsets == NULL) return GF_OUT_OF_MEM;\n\t\tptr->alloc_size = ptr->nb_entries;\n\n\t\tfor (entries = 0; entries < ptr->nb_entries; entries++) {\n\t\t\tptr->offsets[entries] = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stco_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChunkOffsetBox, GF_ISOM_BOX_TYPE_STCO);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stco_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->offsets[i]);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err stco_Size(GF_Box *s)\n{\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\n\tptr->size += 4 + (4 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid stdp_del(GF_Box *s)\n{\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\tif (ptr == NULL ) return;\n\tif (ptr->priorities) gf_free(ptr->priorities);\n\tgf_free(ptr);\n}\n\n//this is called through stbl_read...\nGF_Err stdp_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entry;\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\n\t/*out-of-order stdp, assume no padding at the end and take the entire remaining data for entries*/\n\tif (!ptr->nb_entries) ptr->nb_entries = (u32) ptr->size / 2;\n\telse if (ptr->nb_entries > ptr->size / 2) return GF_ISOM_INVALID_FILE;\n\n\tptr->priorities = (u16 *) gf_malloc(ptr->nb_entries * sizeof(u16));\n\tif (ptr->priorities == NULL) return GF_OUT_OF_MEM;\n\tfor (entry = 0; entry < ptr->nb_entries; entry++) {\n\t\tptr->priorities[entry] = gf_bs_read_u16(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, (2*ptr->nb_entries) );\n\treturn GF_OK;\n}\n\nGF_Box *stdp_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DegradationPriorityBox, GF_ISOM_BOX_TYPE_STDP);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stdp_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u16(bs, ptr->priorities[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stdp_Size(GF_Box *s)\n{\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\n\tptr->size += (2 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsc_del(GF_Box *s)\n{\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err stsc_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tif (ptr->nb_entries > ptr->size / 12) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsc\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = gf_malloc(sizeof(GF_StscEntry)*ptr->alloc_size);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tptr->entries[i].firstChunk = gf_bs_read_u32(bs);\n\t\tptr->entries[i].samplesPerChunk = gf_bs_read_u32(bs);\n\t\tptr->entries[i].sampleDescriptionIndex = gf_bs_read_u32(bs);\n\t\tptr->entries[i].isEdited = 0;\n\t\tptr->entries[i].nextChunk = 0;\n\t\tif (!ptr->entries[i].firstChunk) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] invalid first chunk 0 in stsc entry\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t//update the next chunk in the previous entry\n\t\tif (i) ptr->entries[i-1].nextChunk = ptr->entries[i].firstChunk;\n\t}\n\tptr->currentIndex = 0;\n\tptr->firstSampleInCurrentChunk = 0;\n\tptr->currentChunk = 0;\n\tptr->ghostNumber = 0;\n\treturn GF_OK;\n}\n\nGF_Box *stsc_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleToChunkBox, GF_ISOM_BOX_TYPE_STSC);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsc_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].firstChunk);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].samplesPerChunk);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleDescriptionIndex);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsc_Size(GF_Box *s)\n{\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\tptr->size += 4 + (12 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stsd_del(GF_Box *s)\n{\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err stsd_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_UnknownBox *def;\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\tif (!a) return GF_OK;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_RESV:\n\tcase GF_ISOM_BOX_TYPE_GHNT:\n\tcase GF_ISOM_BOX_TYPE_RTP_STSD:\n\tcase GF_ISOM_BOX_TYPE_SRTP_STSD:\n\tcase GF_ISOM_BOX_TYPE_FDP_STSD:\n\tcase GF_ISOM_BOX_TYPE_RRTP_STSD:\n\tcase GF_ISOM_BOX_TYPE_RTCP_STSD:\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\tcase GF_ISOM_BOX_TYPE_ENCT:\n\tcase GF_ISOM_BOX_TYPE_METX:\n\tcase GF_ISOM_BOX_TYPE_METT:\n\tcase GF_ISOM_BOX_TYPE_STXT:\n\tcase GF_ISOM_BOX_TYPE_DIMS:\n\tcase GF_ISOM_BOX_TYPE_AC3:\n\tcase GF_ISOM_BOX_TYPE_EC3:\n\tcase GF_ISOM_BOX_TYPE_LSR1:\n\tcase GF_ISOM_BOX_TYPE_WVTT:\n\tcase GF_ISOM_BOX_TYPE_STPP:\n\tcase GF_ISOM_BOX_TYPE_SBTT:\n\tcase GF_ISOM_BOX_TYPE_ELNG:\n\tcase GF_ISOM_BOX_TYPE_MP3:\n\tcase GF_ISOM_BOX_TYPE_JPEG:\n\tcase GF_ISOM_BOX_TYPE_JP2K:\n\tcase GF_ISOM_BOX_TYPE_PNG:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\treturn gf_isom_box_add_default((GF_Box*)ptr, a);\n\n\t//unknown sample description: we need a specific box to handle the data ref index\n\t//rather than a default box ...\n\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\tdef = (GF_UnknownBox *)a;\n\t\t/*we need at least 8 bytes for unknown sample entries*/\n\t\tif (def->dataSize < 8) {\n\t\t\tgf_isom_box_del(a);\n\t\t\treturn GF_OK;\n\t\t}\n\t\treturn gf_isom_box_add_default((GF_Box*)ptr, a);\n\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Cannot process box of type %s\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n}\n\n\nGF_Err stsd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tgf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(s, 4)\n\n\treturn gf_isom_box_array_read_ex(s, bs, stsd_AddBox, GF_ISOM_BOX_TYPE_STSD);\n}\n\nGF_Box *stsd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleDescriptionBox, GF_ISOM_BOX_TYPE_STSD);\n\ttmp->other_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 nb_entries;\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tnb_entries = gf_list_count(ptr->other_boxes);\n\tgf_bs_write_u32(bs, nb_entries);\n\treturn GF_OK;\n}\n\nGF_Err stsd_Size(GF_Box *s)\n{\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stsf_del(GF_Box *s)\n{\n\tu32 nb_entries;\n\tu32 i;\n\tGF_StsfEntry *pe;\n\tGF_SampleFragmentBox *ptr = (GF_SampleFragmentBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->entryList) {\n\t\tnb_entries = gf_list_count(ptr->entryList);\n\t\tfor ( i = 0; i < nb_entries; i++ ) {\n\t\t\tpe = (GF_StsfEntry*)gf_list_get(ptr->entryList, i);\n\t\t\tif (pe->fragmentSizes) gf_free(pe->fragmentSizes);\n\t\t\tgf_free(pe);\n\t\t}\n\t\tgf_list_del(ptr->entryList);\n\t}\n\tgf_free(ptr);\n}\n\n\n\nGF_Err stsf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entries, i;\n\tu32 nb_entries;\n\tGF_StsfEntry *p;\n\tGF_SampleFragmentBox *ptr = (GF_SampleFragmentBox *)s;\n\n\tp = NULL;\n\tif (!ptr) return GF_BAD_PARAM;\n\tnb_entries = gf_bs_read_u32(bs);\n\n\tp = NULL;\n\tfor ( entries = 0; entries < nb_entries; entries++ ) {\n\t\tp = (GF_StsfEntry *) gf_malloc(sizeof(GF_StsfEntry));\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\tp->SampleNumber = gf_bs_read_u32(bs);\n\t\tp->fragmentCount = gf_bs_read_u32(bs);\n\t\tp->fragmentSizes = (u16*)gf_malloc(sizeof(GF_StsfEntry) * p->fragmentCount);\n\t\tfor (i=0; i<p->fragmentCount; i++) {\n\t\t\tp->fragmentSizes[i] = gf_bs_read_u16(bs);\n\t\t}\n\t\tgf_list_add(ptr->entryList, p);\n\t}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tptr->w_currentEntry = p;\n\tptr->w_currentEntryIndex = nb_entries-1;\n#endif\n\treturn GF_OK;\n}\n\nGF_Box *stsf_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleFragmentBox, GF_ISOM_BOX_TYPE_STSF);\n\n\ttmp->entryList = gf_list_new();\n\tif (! tmp->entryList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *) tmp;\n}\n\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsf_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j;\n\tu32 nb_entries;\n\tGF_StsfEntry *p;\n\tGF_SampleFragmentBox *ptr = (GF_SampleFragmentBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tnb_entries = gf_list_count(ptr->entryList);\n\tgf_bs_write_u32(bs, nb_entries);\n\tfor ( i = 0; i < nb_entries; i++ ) {\n\t\tp = (GF_StsfEntry*)gf_list_get(ptr->entryList, i);\n\t\tgf_bs_write_u32(bs, p->SampleNumber);\n\t\tgf_bs_write_u32(bs, p->fragmentCount);\n\t\tfor (j=0; j<p->fragmentCount; j++) {\n\t\t\tgf_bs_write_u16(bs, p->fragmentSizes[j]);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsf_Size(GF_Box *s)\n{\n\tGF_StsfEntry *p;\n\tu32 nb_entries, i;\n\tGF_SampleFragmentBox *ptr = (GF_SampleFragmentBox *) s;\n\n\tnb_entries = gf_list_count(ptr->entryList);\n\tptr->size += 4;\n\tfor (i=0; i<nb_entries; i++) {\n\t\tp = (GF_StsfEntry *)gf_list_get(ptr->entryList, i);\n\t\tptr->size += 8 + 2*p->fragmentCount;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stsh_del(GF_Box *s)\n{\n\tu32 i = 0;\n\tGF_StshEntry *ent;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\tif (ptr == NULL) return;\n\twhile ( (ent = (GF_StshEntry *)gf_list_enum(ptr->entries, &i)) ) {\n\t\tgf_free(ent);\n\t}\n\tgf_list_del(ptr->entries);\n\tgf_free(ptr);\n}\n\n\n\nGF_Err stsh_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tGF_StshEntry *ent;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\n\tcount = gf_bs_read_u32(bs);\n\n\tfor (i = 0; i < count; i++) {\n\t\tent = (GF_StshEntry *) gf_malloc(sizeof(GF_StshEntry));\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tent->shadowedSampleNumber = gf_bs_read_u32(bs);\n\t\tent->syncSampleNumber = gf_bs_read_u32(bs);\n\t\te = gf_list_add(ptr->entries, ent);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsh_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);\n\n\ttmp->entries = gf_list_new();\n\tif (!tmp->entries) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsh_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_StshEntry *ent;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, gf_list_count(ptr->entries));\n\ti=0;\n\twhile ((ent = (GF_StshEntry *)gf_list_enum(ptr->entries, &i))) {\n\t\tgf_bs_write_u32(bs, ent->shadowedSampleNumber);\n\t\tgf_bs_write_u32(bs, ent->syncSampleNumber);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsh_Size(GF_Box *s)\n{\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\tptr->size += 4 + (8 * gf_list_count(ptr->entries));\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid stss_del(GF_Box *s)\n{\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sampleNumbers) gf_free(ptr->sampleNumbers);\n\tgf_free(ptr);\n}\n\nGF_Err stss_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tif (ptr->nb_entries > ptr->size / 4) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stss\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->sampleNumbers = (u32 *) gf_malloc( ptr->alloc_size * sizeof(u32));\n\tif (ptr->sampleNumbers == NULL) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tptr->sampleNumbers[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stss_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SyncSampleBox, GF_ISOM_BOX_TYPE_STSS);\n\treturn (GF_Box*)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stss_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->sampleNumbers[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stss_Size(GF_Box *s)\n{\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\tptr->size += 4 + (4 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsz_del(GF_Box *s)\n{\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sizes) gf_free(ptr->sizes);\n\tgf_free(ptr);\n}\n\n\nGF_Err stsz_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, estSize;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\t//support for CompactSizes\n\tif (s->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tptr->sampleSize = gf_bs_read_u32(bs);\n\t\tptr->sampleCount = gf_bs_read_u32(bs);\n\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t} else {\n\t\t//24-reserved\n\t\tgf_bs_read_int(bs, 24);\n\t\ti = gf_bs_read_u8(bs);\n\t\tptr->sampleCount = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tswitch (i) {\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\t\tptr->sampleSize = i;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//try to fix the file\n\t\t\t//no samples, no parsing pb\n\t\t\tif (!ptr->sampleCount) {\n\t\t\t\tptr->sampleSize = 16;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\testSize = (u32) (ptr->size) / ptr->sampleCount;\n\t\t\tif (!estSize && ((ptr->sampleCount+1)/2 == (ptr->size)) ) {\n\t\t\t\tptr->sampleSize = 4;\n\t\t\t\tbreak;\n\t\t\t} else if (estSize == 1 || estSize == 2) {\n\t\t\t\tptr->sampleSize = 8 * estSize;\n\t\t\t} else {\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t}\n\t}\n\tif (s->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (! ptr->sampleSize && ptr->sampleCount) {\n\t\t\tif (ptr->sampleCount > ptr->size / 4) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tptr->sizes = (u32 *) gf_malloc(ptr->sampleCount * sizeof(u32));\n\t\t\tptr->alloc_size = ptr->sampleCount;\n\t\t\tif (! ptr->sizes) return GF_OUT_OF_MEM;\n\t\t\tfor (i = 0; i < ptr->sampleCount; i++) {\n\t\t\t\tptr->sizes[i] = gf_bs_read_u32(bs);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (ptr->sampleSize==4) {\n\t\t\tif (ptr->sampleCount / 2 > ptr->size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ptr->sampleCount > ptr->size / (ptr->sampleSize/8)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t}\n\t\t//note we could optimize the mem usage by keeping the table compact\n\t\t//in memory. But that would complicate both caching and editing\n\t\t//we therefore keep all sizes as u32 and uncompress the table\n\t\tptr->sizes = (u32 *) gf_malloc(ptr->sampleCount * sizeof(u32));\n\t\tif (! ptr->sizes) return GF_OUT_OF_MEM;\n\t\tptr->alloc_size = ptr->sampleCount;\n\n\t\tfor (i = 0; i < ptr->sampleCount; ) {\n\t\t\tswitch (ptr->sampleSize) {\n\t\t\tcase 4:\n\t\t\t\tptr->sizes[i] = gf_bs_read_int(bs, 4);\n\t\t\t\tif (i+1 < ptr->sampleCount) {\n\t\t\t\t\tptr->sizes[i+1] = gf_bs_read_int(bs, 4);\n\t\t\t\t} else {\n\t\t\t\t\t//0 padding in odd sample count\n\t\t\t\t\tgf_bs_read_int(bs, 4);\n\t\t\t\t}\n\t\t\t\ti += 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tptr->sizes[i] = gf_bs_read_int(bs, ptr->sampleSize);\n\t\t\t\ti += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsz_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleSizeBox, 0);\n\n\t//type is unknown here, can be regular or compact table\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsz_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//in both versions this is still valid\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tgf_bs_write_u32(bs, ptr->sampleSize);\n\t} else {\n\t\tgf_bs_write_u24(bs, 0);\n\t\tgf_bs_write_u8(bs, ptr->sampleSize);\n\t}\n\tgf_bs_write_u32(bs, ptr->sampleCount);\n\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (! ptr->sampleSize) {\n\t\t\tfor (i = 0; i < ptr->sampleCount; i++) {\n\t\t\t\tgf_bs_write_u32(bs, ptr->sizes ? ptr->sizes[i] : 0);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ptr->sampleCount; ) {\n\t\t\tswitch (ptr->sampleSize) {\n\t\t\tcase 4:\n\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i], 4);\n\t\t\t\tif (i+1 < ptr->sampleCount) {\n\t\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i+1], 4);\n\t\t\t\t} else {\n\t\t\t\t\t//0 padding in odd sample count\n\t\t\t\t\tgf_bs_write_int(bs, 0, 4);\n\t\t\t\t}\n\t\t\t\ti += 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i], ptr->sampleSize);\n\t\t\t\ti += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsz_Size(GF_Box *s)\n{\n\tu32 i, fieldSize, size;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\n\tptr->size += 8;\n\tif (!ptr->sampleCount) return GF_OK;\n\n\t//regular table\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (ptr->sampleSize) return GF_OK;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\n\tfieldSize = 4;\n\tsize = ptr->sizes[0];\n\n\tfor (i=0; i < ptr->sampleCount; i++) {\n\t\tif (ptr->sizes[i] <= 0xF) continue;\n\t\t//switch to 8-bit table\n\t\telse if (ptr->sizes[i] <= 0xFF) {\n\t\t\tfieldSize = 8;\n\t\t}\n\t\t//switch to 16-bit table\n\t\telse if (ptr->sizes[i] <= 0xFFFF) {\n\t\t\tfieldSize = 16;\n\t\t}\n\t\t//switch to 32-bit table\n\t\telse {\n\t\t\tfieldSize = 32;\n\t\t}\n\n\t\t//check the size\n\t\tif (size != ptr->sizes[i]) size = 0;\n\t}\n\t//if all samples are of the same size, switch to regular (more compact)\n\tif (size) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->sampleSize = size;\n\t\tgf_free(ptr->sizes);\n\t\tptr->sizes = NULL;\n\t}\n\n\tif (fieldSize == 32) {\n\t\t//oops, doesn't fit in a compact table\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\n\t//make sure we are a compact table (no need to change the mem representation)\n\tptr->type = GF_ISOM_BOX_TYPE_STZ2;\n\tptr->sampleSize = fieldSize;\n\tif (fieldSize == 4) {\n\t\t//do not forget the 0 padding field for odd count\n\t\tptr->size += (ptr->sampleCount + 1) / 2;\n\t} else {\n\t\tptr->size += (ptr->sampleCount) * (fieldSize/8);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stts_del(GF_Box *s)\n{\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err stts_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tptr->w_LastDTS = 0;\n#endif\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tif (ptr->nb_entries > ptr->size / 8) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stts\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = gf_malloc(sizeof(GF_SttsEntry)*ptr->alloc_size);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->entries[i].sampleCount = gf_bs_read_u32(bs);\n\t\tptr->entries[i].sampleDelta = gf_bs_read_u32(bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\tptr->w_currentSampleNum += ptr->entries[i].sampleCount;\n\t\tptr->w_LastDTS += (u64)ptr->entries[i].sampleCount * ptr->entries[i].sampleDelta;\n#endif\n\n\t\tif (!ptr->entries[i].sampleDelta) {\n\t\t\tif ((i+1<ptr->nb_entries) ) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Found stts entry with sample_delta=0 - forbidden ! Fixing to 1\\n\" ));\n\t\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t\t} else if (ptr->entries[i].sampleCount>1) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] more than one stts entry at the end of the track with sample_delta=0 - forbidden ! Fixing to 1\\n\" ));\n\t\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t\t}\n\t\t} else if ((s32) ptr->entries[i].sampleDelta < 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] stts entry %d has negative duration %d - forbidden ! Fixing to 1, sync may get lost (consider reimport raw media)\\n\", i, (s32) ptr->entries[i].sampleDelta ));\n\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t}\n\t}\n\tif (ptr->size<(ptr->nb_entries*8)) return GF_ISOM_INVALID_FILE;\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries*8);\n\n\t//remove the last sample delta.\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (ptr->nb_entries) ptr->w_LastDTS -= ptr->entries[ptr->nb_entries-1].sampleDelta;\n#endif\n\treturn GF_OK;\n}\n\nGF_Box *stts_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeToSampleBox, GF_ISOM_BOX_TYPE_STTS);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stts_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleCount);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleDelta);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stts_Size(GF_Box *s)\n{\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid tfhd_del(GF_Box *s)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err tfhd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\n\tptr->trackID = gf_bs_read_u32(bs);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) {\n\t\tptr->base_data_offset = gf_bs_read_u64(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) {\n\t\tptr->sample_desc_index = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) {\n\t\tptr->def_sample_duration = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) {\n\t\tptr->def_sample_size = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) {\n\t\tptr->def_sample_flags = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *tfhd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentHeaderBox, GF_ISOM_BOX_TYPE_TFHD);\n\t//NO FLAGS SET BY DEFAULT\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err tfhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->trackID);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) {\n\t\tgf_bs_write_u64(bs, ptr->base_data_offset);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) {\n\t\tgf_bs_write_u32(bs, ptr->sample_desc_index);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_duration);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_size);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_flags);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfhd_Size(GF_Box *s)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\tptr->size += 4;\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) ptr->size += 8;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid tims_del(GF_Box *s)\n{\n\tGF_TSHintEntryBox *tims = (GF_TSHintEntryBox *)s;\n\tgf_free(tims);\n}\n\nGF_Err tims_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TSHintEntryBox *ptr = (GF_TSHintEntryBox *)s;\n\tptr->timeScale = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tims_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TSHintEntryBox, GF_ISOM_BOX_TYPE_TIMS);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tims_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TSHintEntryBox *ptr = (GF_TSHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->timeScale);\n\treturn GF_OK;\n}\n\nGF_Err tims_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tkhd_del(GF_Box *s)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n\treturn;\n}\n\n\nGF_Err tkhd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\tif (ptr->version == 1) {\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->trackID = gf_bs_read_u32(bs);\n\t\tptr->reserved1 = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->trackID = gf_bs_read_u32(bs);\n\t\tptr->reserved1 = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tptr->reserved2[0] = gf_bs_read_u32(bs);\n\tptr->reserved2[1] = gf_bs_read_u32(bs);\n\tptr->layer = gf_bs_read_u16(bs);\n\tptr->alternate_group = gf_bs_read_u16(bs);\n\tptr->volume = gf_bs_read_u16(bs);\n\tptr->reserved3 = gf_bs_read_u16(bs);\n\tptr->matrix[0] = gf_bs_read_u32(bs);\n\tptr->matrix[1] = gf_bs_read_u32(bs);\n\tptr->matrix[2] = gf_bs_read_u32(bs);\n\tptr->matrix[3] = gf_bs_read_u32(bs);\n\tptr->matrix[4] = gf_bs_read_u32(bs);\n\tptr->matrix[5] = gf_bs_read_u32(bs);\n\tptr->matrix[6] = gf_bs_read_u32(bs);\n\tptr->matrix[7] = gf_bs_read_u32(bs);\n\tptr->matrix[8] = gf_bs_read_u32(bs);\n\tptr->width = gf_bs_read_u32(bs);\n\tptr->height = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tkhd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackHeaderBox, GF_ISOM_BOX_TYPE_TKHD);\n\ttmp->matrix[0] = 0x00010000;\n\ttmp->matrix[4] = 0x00010000;\n\ttmp->matrix[8] = 0x40000000;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tkhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->trackID);\n\t\tgf_bs_write_u32(bs, ptr->reserved1);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->trackID);\n\t\tgf_bs_write_u32(bs, ptr->reserved1);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\tgf_bs_write_u32(bs, ptr->reserved2[0]);\n\tgf_bs_write_u32(bs, ptr->reserved2[1]);\n\tgf_bs_write_u16(bs, ptr->layer);\n\tgf_bs_write_u16(bs, ptr->alternate_group);\n\tgf_bs_write_u16(bs, ptr->volume);\n\tgf_bs_write_u16(bs, ptr->reserved3);\n\tgf_bs_write_u32(bs, ptr->matrix[0]);\n\tgf_bs_write_u32(bs, ptr->matrix[1]);\n\tgf_bs_write_u32(bs, ptr->matrix[2]);\n\tgf_bs_write_u32(bs, ptr->matrix[3]);\n\tgf_bs_write_u32(bs, ptr->matrix[4]);\n\tgf_bs_write_u32(bs, ptr->matrix[5]);\n\tgf_bs_write_u32(bs, ptr->matrix[6]);\n\tgf_bs_write_u32(bs, ptr->matrix[7]);\n\tgf_bs_write_u32(bs, ptr->matrix[8]);\n\tgf_bs_write_u32(bs, ptr->width);\n\tgf_bs_write_u32(bs, ptr->height);\n\treturn GF_OK;\n}\n\nGF_Err tkhd_Size(GF_Box *s)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\tif (ptr->duration==(u64) -1) ptr->version = 0;\n\telse ptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\tptr->size += (ptr->version == 1) ? 32 : 20;\n\tptr->size += 60;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid traf_del(GF_Box *s)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->tfhd) gf_isom_box_del((GF_Box *) ptr->tfhd);\n\tif (ptr->sdtp) gf_isom_box_del((GF_Box *) ptr->sdtp);\n\tif (ptr->sub_samples) gf_isom_box_array_del(ptr->sub_samples);\n\tif (ptr->tfdt) gf_isom_box_del((GF_Box *) ptr->tfdt);\n\tif (ptr->sample_encryption) gf_isom_box_del((GF_Box *) ptr->sample_encryption);\n\tgf_isom_box_array_del(ptr->TrackRuns);\n\tif (ptr->sampleGroups) gf_isom_box_array_del(ptr->sampleGroups);\n\tif (ptr->sampleGroupsDescription) gf_isom_box_array_del(ptr->sampleGroupsDescription);\n\tif (ptr->sai_sizes) gf_isom_box_array_del(ptr->sai_sizes);\n\tif (ptr->sai_offsets) gf_isom_box_array_del(ptr->sai_offsets);\n\tgf_free(ptr);\n}\n\nGF_Err traf_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TFHD:\n\t\tif (ptr->tfhd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->tfhd = (GF_TrackFragmentHeaderBox *) a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRUN:\n\t\treturn gf_list_add(ptr->TrackRuns, a);\n\tcase GF_ISOM_BOX_TYPE_SDTP:\n\t\tif (ptr->sdtp) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->sdtp = (GF_SampleDependencyTypeBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TFDT:\n\t\tif (ptr->tfdt) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->tfdt = (GF_TFBaseMediaDecodeTimeBox*) a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SUBS:\n\t\tif (!ptr->sub_samples) ptr->sub_samples = gf_list_new();\n\t\treturn gf_list_add(ptr->sub_samples, a);\n\tcase GF_ISOM_BOX_TYPE_SBGP:\n\t\tif (!ptr->sampleGroups) ptr->sampleGroups = gf_list_new();\n\t\tgf_list_add(ptr->sampleGroups, a);\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SGPD:\n\t\tif (!ptr->sampleGroupsDescription) ptr->sampleGroupsDescription = gf_list_new();\n\t\tgf_list_add(ptr->sampleGroupsDescription, a);\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SAIZ:\n\t\tif (!ptr->sai_sizes) ptr->sai_sizes = gf_list_new();\n\t\tgf_list_add(ptr->sai_sizes, a);\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SAIO:\n\t\tif (!ptr->sai_offsets) ptr->sai_offsets = gf_list_new();\n\t\tgf_list_add(ptr->sai_offsets, a);\n\t\treturn GF_OK;\n\t//we will throw an error if both PIFF_PSEC and SENC are found. Not such files seen yet\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif ( ((GF_UUIDBox *)a)->internal_4cc==GF_ISOM_BOX_UUID_PSEC) {\n\t\t\tif (ptr->sample_encryption) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->sample_encryption = (GF_SampleEncryptionBox *)a;\n\t\t\tptr->sample_encryption->traf = ptr;\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\treturn gf_isom_box_add_default(s, a);\n\t\t}\n\tcase GF_ISOM_BOX_TYPE_SENC:\n\t\tif (ptr->sample_encryption) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->sample_encryption = (GF_SampleEncryptionBox *)a;\n\t\tptr->sample_encryption->traf = ptr;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err traf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\tGF_Err e = gf_isom_box_array_read(s, bs, traf_AddBox);\n\tif (e) return e;\n\n\tif (!ptr->tfhd) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing TrackFragmentHeaderBox \\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *traf_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentBox, GF_ISOM_BOX_TYPE_TRAF);\n\ttmp->TrackRuns = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Box *tfxd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MSSTimeExtBox, GF_ISOM_BOX_TYPE_UUID);\n\ttmp->internal_4cc = GF_ISOM_BOX_UUID_TFXD;\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfxd_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err tfxd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox *)s;\n\tif (ptr->size<4) return GF_ISOM_INVALID_FILE;\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tif (ptr->version == 0x01) {\n\t\tptr->absolute_time_in_track_timescale = gf_bs_read_u64(bs);\n\t\tptr->fragment_duration_in_track_timescale = gf_bs_read_u64(bs);\n\t} else {\n\t\tptr->absolute_time_in_track_timescale = gf_bs_read_u32(bs);\n\t\tptr->fragment_duration_in_track_timescale = gf_bs_read_u32(bs);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err tfxd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = GF_OK;\n\tGF_MSSTimeExtBox *uuid = (GF_MSSTimeExtBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, 1);\n\tgf_bs_write_u24(bs, 0);\n\tgf_bs_write_u64(bs, uuid->absolute_time_in_track_timescale);\n\tgf_bs_write_u64(bs, uuid->fragment_duration_in_track_timescale);\n\n\treturn GF_OK;\n}\n\nGF_Err tfxd_Size(GF_Box *s)\n{\n\ts->size += 20;\n\treturn GF_OK;\n}\n\nGF_Err traf_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\t//Header first\n\tif (ptr->tfhd) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->tfhd, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sub_samples) {\n\t\te = gf_isom_box_array_write(s, ptr->sub_samples, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->tfdt) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->tfdt, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sdtp) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->sdtp, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sampleGroupsDescription) {\n\t\te = gf_isom_box_array_write(s, ptr->sampleGroupsDescription, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sampleGroups) {\n\t\te = gf_isom_box_array_write(s, ptr->sampleGroups, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sai_sizes) {\n\t\te = gf_isom_box_array_write(s, ptr->sai_sizes, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sai_offsets) {\n\t\te = gf_isom_box_array_write(s, ptr->sai_offsets, bs);\n\t\tif (e) return e;\n\t}\n\te = gf_isom_box_array_write(s, ptr->TrackRuns, bs);\n\tif (e) return e;\n\n\tif (ptr->sample_encryption) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->sample_encryption, bs);\n\t\tif (e) return e;\n\t}\n\t//tfxd should be last ...\n\tif (ptr->tfxd) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->tfxd, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err traf_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\n\tif (ptr->tfhd) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->tfhd);\n\t\tif (e) return e;\n\t\tptr->size += ptr->tfhd->size;\n\t}\n\tif (ptr->sub_samples) {\n\t\te = gf_isom_box_array_size(s, ptr->sub_samples);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sdtp) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->sdtp);\n\t\tif (e) return e;\n\t\tptr->size += ptr->sdtp->size;\n\t}\n\tif (ptr->tfdt) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->tfdt);\n\t\tif (e) return e;\n\t\tptr->size += ptr->tfdt->size;\n\t}\n\n\tif (ptr->sampleGroups) {\n\t\te = gf_isom_box_array_size(s, ptr->sampleGroups);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sampleGroupsDescription) {\n\t\te = gf_isom_box_array_size(s, ptr->sampleGroupsDescription);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sai_sizes) {\n\t\te = gf_isom_box_array_size(s, ptr->sai_sizes);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sai_offsets) {\n\t\te = gf_isom_box_array_size(s, ptr->sai_offsets);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sample_encryption) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->sample_encryption);\n\t\tif (e) return e;\n\t\tptr->size += ptr->sample_encryption->size;\n\t}\n\tif (ptr->tfxd) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->tfxd);\n\t\tif (e) return e;\n\t\ts->size += ptr->tfxd->size;\n\t}\n\treturn gf_isom_box_array_size(s, ptr->TrackRuns);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid trak_del(GF_Box *s)\n{\n\tGF_TrackBox *ptr = (GF_TrackBox *) s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->Header) gf_isom_box_del((GF_Box *)ptr->Header);\n\tif (ptr->udta) gf_isom_box_del((GF_Box *)ptr->udta);\n\tif (ptr->Media) gf_isom_box_del((GF_Box *)ptr->Media);\n\tif (ptr->References) gf_isom_box_del((GF_Box *)ptr->References);\n\tif (ptr->editBox) gf_isom_box_del((GF_Box *)ptr->editBox);\n\tif (ptr->meta) gf_isom_box_del((GF_Box *)ptr->meta);\n\tif (ptr->name) gf_free(ptr->name);\n\tif (ptr->groups) gf_isom_box_del((GF_Box *)ptr->groups);\n\tgf_free(ptr);\n}\n\nstatic void gf_isom_check_sample_desc(GF_TrackBox *trak)\n{\n\tGF_BitStream *bs;\n\tGF_UnknownBox *a;\n\tu32 i;\n\n\tif (!trak->Media || !trak->Media->information) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no media box !\\n\" ));\n\t\treturn;\n\t}\n\tif (!trak->Media->information->sampleTable) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no sample table !\\n\" ));\n\t\ttrak->Media->information->sampleTable = (GF_SampleTableBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STBL);\n\t}\n\n\tif (!trak->Media->information->sampleTable->SampleDescription) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no sample description box !\\n\" ));\n\t\ttrak->Media->information->sampleTable->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STSD);\n\t\treturn;\n\t}\n\n\ti=0;\n\twhile ((a = (GF_UnknownBox*)gf_list_enum(trak->Media->information->sampleTable->SampleDescription->other_boxes, &i))) {\n\t\tswitch (a->type) {\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tcase GF_ISOM_BOX_TYPE_GHNT:\n\t\tcase GF_ISOM_BOX_TYPE_RTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_SRTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_FDP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_RRTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_RTCP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_METX:\n\t\tcase GF_ISOM_BOX_TYPE_METT:\n\t\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\tcase GF_ISOM_BOX_TYPE_AVC1:\n\t\tcase GF_ISOM_BOX_TYPE_AVC2:\n\t\tcase GF_ISOM_BOX_TYPE_AVC3:\n\t\tcase GF_ISOM_BOX_TYPE_AVC4:\n\t\tcase GF_ISOM_BOX_TYPE_SVC1:\n\t\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HEV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC2:\n\t\tcase GF_ISOM_BOX_TYPE_HEV2:\n\t\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tcase GF_ISOM_BOX_TYPE_LHE1:\n\t\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tcase GF_ISOM_BOX_TYPE_ENCT:\n\t\tcase GF_ISOM_BOX_TYPE_DIMS:\n\t\tcase GF_ISOM_BOX_TYPE_AC3:\n\t\tcase GF_ISOM_BOX_TYPE_EC3:\n\t\tcase GF_ISOM_BOX_TYPE_LSR1:\n\t\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\tcase GF_ISOM_BOX_TYPE_SBTT:\n\t\tcase GF_ISOM_BOX_TYPE_MP3:\n\t\tcase GF_ISOM_BOX_TYPE_JPEG:\n\t\tcase GF_ISOM_BOX_TYPE_PNG:\n\t\tcase GF_ISOM_BOX_TYPE_JP2K:\n\t\t\tcontinue;\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Unexpected box %s in stsd!\\n\", gf_4cc_to_str(a->type)));\n\t\t\tcontinue;\n\t\t}\n\t\t//we are sure to have an unknown box here\n\t\tassert(a->type==GF_ISOM_BOX_TYPE_UNKNOWN);\n\n\t\tif (!a->data || (a->dataSize<8) ) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Sample description %s does not have at least 8 bytes!\\n\", gf_4cc_to_str(a->original_4cc) ));\n\t\t\tcontinue;\n\t\t}\n\t\telse if (a->dataSize > a->size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Sample description %s has wrong data size %d!\\n\", gf_4cc_to_str(a->original_4cc), a->dataSize));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*only process visual or audio*/\n\t\tswitch (trak->Media->handler->handlerType) {\n        case GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t{\n\t\t\tGF_GenericVisualSampleEntryBox *genv;\n\t\t\t/*remove entry*/\n\t\t\tgf_list_rem(trak->Media->information->sampleTable->SampleDescription->other_boxes, i-1);\n\t\t\tgenv = (GF_GenericVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRV);\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\t\t\tgenv->size = a->size-8;\n\t\t\tgf_isom_video_sample_entry_read((GF_VisualSampleEntryBox *) genv, bs);\n\n\t\t\tif (gf_bs_available(bs)) {\n\t\t\t\tu64 pos = gf_bs_get_position(bs);\n\t\t\t\t//try to parse as boxes\n\t\t\t\tGF_Err e = gf_isom_box_array_read((GF_Box *) genv, bs, gf_isom_box_add_default);\n\t\t\t\tif (e) {\n\t\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\t\tgenv->data_size = (u32) gf_bs_available(bs);\n\t\t\t\t\tif (genv->data_size) {\n\t\t\t\t\t\tgenv->data = a->data;\n\t\t\t\t\t\ta->data = NULL;\n\t\t\t\t\t\tmemmove(genv->data, genv->data + pos, genv->data_size);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgenv->data_size = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_bs_del(bs);\n\t\t\tif (!genv->data_size && genv->data) {\n\t\t\t\tgf_free(genv->data);\n\t\t\t\tgenv->data = NULL;\n\t\t\t}\n\n\t\t\tgenv->size = 0;\n\t\t\tgenv->EntryType = a->original_4cc;\n\t\t\tgf_isom_box_del((GF_Box *)a);\n\t\t\tgf_list_insert(trak->Media->information->sampleTable->SampleDescription->other_boxes, genv, i-1);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t{\n\t\t\tGF_GenericAudioSampleEntryBox *gena;\n\t\t\t/*remove entry*/\n\t\t\tgf_list_rem(trak->Media->information->sampleTable->SampleDescription->other_boxes, i-1);\n\t\t\tgena = (GF_GenericAudioSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRA);\n\t\t\tgena->size = a->size-8;\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\t\t\tgf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox *) gena, bs);\n\n\t\t\tif (gf_bs_available(bs)) {\n\t\t\t\tu64 pos = gf_bs_get_position(bs);\n\t\t\t\t//try to parse as boxes\n\t\t\t\tGF_Err e = gf_isom_box_array_read((GF_Box *) gena, bs, gf_isom_box_add_default);\n\t\t\t\tif (e) {\n\t\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\t\tgena->data_size = (u32) gf_bs_available(bs);\n\t\t\t\t\tif (gena->data_size) {\n\t\t\t\t\t\tgena->data = a->data;\n\t\t\t\t\t\ta->data = NULL;\n\t\t\t\t\t\tmemmove(gena->data, gena->data + pos, gena->data_size);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgena->data_size = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_bs_del(bs);\n\t\t\tif (!gena->data_size && gena->data) {\n\t\t\t\tgf_free(gena->data);\n\t\t\t\tgena->data = NULL;\n\t\t\t}\n\t\t\tgena->size = 0;\n\t\t\tgena->EntryType = a->original_4cc;\n\t\t\tgf_isom_box_del((GF_Box *)a);\n\t\t\tgf_list_insert(trak->Media->information->sampleTable->SampleDescription->other_boxes, gena, i-1);\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tGF_GenericSampleEntryBox *genm;\n\t\t\t/*remove entry*/\n\t\t\tgf_list_rem(trak->Media->information->sampleTable->SampleDescription->other_boxes, i-1);\n\t\t\tgenm = (GF_GenericSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRM);\n\t\t\tgenm->size = a->size-8;\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\n\t\t\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)genm, bs);\n\t\t\tif (e) return;\n\n\t\t\tgenm->size -= 8;\n\n\t\t\tif (gf_bs_available(bs)) {\n\t\t\t\tu64 pos = gf_bs_get_position(bs);\n\t\t\t\t//try to parse as boxes\n\t\t\t\tGF_Err e = gf_isom_box_array_read((GF_Box *) genm, bs, gf_isom_box_add_default);\n\t\t\t\tif (e) {\n\t\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\t\tgenm->data_size = (u32) gf_bs_available(bs);\n\t\t\t\t\tif (genm->data_size) {\n\t\t\t\t\t\tgenm->data = a->data;\n\t\t\t\t\t\ta->data = NULL;\n\t\t\t\t\t\tmemmove(genm->data, genm->data + pos, genm->data_size);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgenm->data_size = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_bs_del(bs);\n\t\t\tif (!genm->data_size && genm->data) {\n\t\t\t\tgf_free(genm->data);\n\t\t\t\tgenm->data = NULL;\n\t\t\t}\n\t\t\tgenm->size = 0;\n\n\t\t\tgenm->EntryType = a->original_4cc;\n\t\t\tgf_isom_box_del((GF_Box *)a);\n\t\t\tgf_list_insert(trak->Media->information->sampleTable->SampleDescription->other_boxes, genm, i-1);\n\t\t}\n\t\tbreak;\n\t\t}\n\n\t}\n}\n\n\nGF_Err trak_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (!a) return GF_OK;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_TKHD:\n\t\tif (ptr->Header) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->Header = (GF_TrackHeaderBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_EDTS:\n\t\tif (ptr->editBox) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->editBox = (GF_EditBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\tif (ptr->udta) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->udta = (GF_UserDataBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_META:\n\t\tif (ptr->meta) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->meta = (GF_MetaBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TREF:\n\t\tif (ptr->References) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->References = (GF_TrackReferenceBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_MDIA:\n\t\tif (ptr->Media) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->Media = (GF_MediaBox *)a;\n\t\t((GF_MediaBox *)a)->mediaTrack = ptr;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRGR:\n\t\tif (ptr->groups) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->groups = (GF_TrackGroupBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SENC:\n\t\tptr->sample_encryption = (GF_SampleEncryptionBox*)a;\n\t\treturn gf_isom_box_add_default((GF_Box *)ptr, a);\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif (((GF_UnknownUUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC) {\n\t\t\tptr->sample_encryption = (GF_SampleEncryptionBox*) a;\n\t\t\treturn gf_isom_box_add_default((GF_Box *)ptr, a);\n\t\t}\n\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err trak_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\te = gf_isom_box_array_read(s, bs, trak_AddBox);\n\tif (e) return e;\n\tgf_isom_check_sample_desc(ptr);\n\n\tif (!ptr->Header) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing TrackHeaderBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!ptr->Media) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tfor (i=0; i<gf_list_count(ptr->Media->information->sampleTable->other_boxes); i++) {\n\t\tGF_Box *a = gf_list_get(ptr->Media->information->sampleTable->other_boxes, i);\n\t\tif ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\tptr->sample_encryption = (struct __sample_encryption_box *) a;\n\t\t\tbreak;\n\t\t}\n\t\telse if (a->type == GF_ISOM_BOX_TYPE_SENC) {\n\t\t\tptr->sample_encryption = (struct __sample_encryption_box *)a;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Box *trak_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackBox, GF_ISOM_BOX_TYPE_TRAK);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trak_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tif (ptr->Header) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->Header, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->References) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->References, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->editBox) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->editBox, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->Media) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->Media, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->meta) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->meta, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->groups) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->groups, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->udta) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->udta, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err trak_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\n\tif (ptr->Header) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->Header);\n\t\tif (e) return e;\n\t\tptr->size += ptr->Header->size;\n\t}\n\tif (ptr->udta) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->udta);\n\t\tif (e) return e;\n\t\tptr->size += ptr->udta->size;\n\t}\n\tif (ptr->References) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->References);\n\t\tif (e) return e;\n\t\tptr->size += ptr->References->size;\n\t}\n\tif (ptr->editBox) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->editBox);\n\t\tif (e) return e;\n\t\tptr->size += ptr->editBox->size;\n\t}\n\tif (ptr->Media) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->Media);\n\t\tif (e) return e;\n\t\tptr->size += ptr->Media->size;\n\t}\n\tif (ptr->meta) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->meta);\n\t\tif (e) return e;\n\t\tptr->size += ptr->meta->size;\n\t}\n\tif (ptr->groups) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->groups);\n\t\tif (e) return e;\n\t\tptr->size += ptr->groups->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stri_del(GF_Box *s)\n{\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->attribute_list) gf_free(ptr->attribute_list);\n\tgf_free(ptr);\n}\n\nGF_Err stri_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tsize_t i;\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\tptr->switch_group = gf_bs_read_u16(bs);\n\tptr->alternate_group = gf_bs_read_u16(bs);\n\tptr->sub_track_id = gf_bs_read_u32(bs);\n\tptr->size -= 8;\n\tptr->attribute_count = ptr->size / 4;\n\tGF_SAFE_ALLOC_N(ptr->attribute_list, (size_t)ptr->attribute_count, u32);\n\tif (!ptr->attribute_list) return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->attribute_count; i++) {\n\t\tptr->attribute_list[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stri_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackInformationBox, GF_ISOM_BOX_TYPE_STRI);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stri_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->switch_group);\n\tgf_bs_write_u16(bs, ptr->alternate_group);\n\tgf_bs_write_u32(bs, ptr->sub_track_id);\n\tfor (i = 0; i < ptr->attribute_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->attribute_list[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stri_Size(GF_Box *s)\n{\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\n\tptr->size += 8 + 4 * ptr->attribute_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stsg_del(GF_Box *s)\n{\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->group_description_index) gf_free(ptr->group_description_index);\n\tgf_free(ptr);\n}\n\nGF_Err stsg_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tISOM_DECREASE_SIZE(s, 6);\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\tptr->nb_groups = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(s, ptr->nb_groups*4);\n\tGF_SAFE_ALLOC_N(ptr->group_description_index, ptr->nb_groups, u32);\n\tif (!ptr->group_description_index) return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->nb_groups; i++) {\n\t\tptr->group_description_index[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsg_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackSampleGroupBox, GF_ISOM_BOX_TYPE_STSG);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsg_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->grouping_type);\n\tgf_bs_write_u16(bs, ptr->nb_groups);\n\tfor (i = 0; i < ptr->nb_groups; i++) {\n\t\tgf_bs_write_u32(bs, ptr->group_description_index[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsg_Size(GF_Box *s)\n{\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tptr->size += 6 + 4 * ptr->nb_groups;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid strk_del(GF_Box *s)\n{\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->info) gf_isom_box_del((GF_Box *)ptr->info);\n\tgf_free(ptr);\n}\n\nGF_Err strk_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\tif (!a) return GF_OK;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_STRI:\n\t\tif (ptr->info) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->info = (GF_SubTrackInformationBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_STRD:\n\t\tif (ptr->strd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->strd = a;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err strk_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\te = gf_isom_box_array_read(s, bs, strk_AddBox);\n\tif (e) return e;\n\n\tif (!ptr->info) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing SubTrackInformationBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn e;\n}\n\nGF_Box *strk_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackBox, GF_ISOM_BOX_TYPE_STRK);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err strk_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tif (ptr->info) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->info, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err strk_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\n\tif (ptr->info) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->info);\n\t\tif (e) return e;\n\t\tptr->size += ptr->info->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Err tref_AddBox(GF_Box *ptr, GF_Box *a)\n{\n\treturn gf_isom_box_add_default(ptr, a);\n}\n\nvoid tref_del(GF_Box *s)\n{\n\tGF_TrackReferenceBox *ptr = (GF_TrackReferenceBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err tref_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(s, bs, gf_isom_box_add_default, s->type);\n}\n\nGF_Box *tref_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackReferenceBox, GF_ISOM_BOX_TYPE_TREF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tref_Write(GF_Box *s, GF_BitStream *bs)\n{\n//\tGF_TrackReferenceBox *ptr = (GF_TrackReferenceBox *)s;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err tref_Size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid reftype_del(GF_Box *s)\n{\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tif (!ptr) return;\n\tif (ptr->trackIDs) gf_free(ptr->trackIDs);\n\tgf_free(ptr);\n}\n\n\nGF_Err reftype_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tu32 i;\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\n\tbytesToRead = (u32) (ptr->size);\n\tif (!bytesToRead) return GF_OK;\n\n\tptr->trackIDCount = (u32) (bytesToRead) / sizeof(u32);\n\tptr->trackIDs = (u32 *) gf_malloc(ptr->trackIDCount * sizeof(u32));\n\tif (!ptr->trackIDs) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->trackIDCount; i++) {\n\t\tptr->trackIDs[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *reftype_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackReferenceTypeBox, GF_ISOM_BOX_TYPE_REFT);\n\treturn (GF_Box *)tmp;\n}\n\n\nGF_Err reftype_AddRefTrack(GF_TrackReferenceTypeBox *ref, u32 trackID, u16 *outRefIndex)\n{\n\tu32 i;\n\tif (!ref || !trackID) return GF_BAD_PARAM;\n\n\tif (outRefIndex) *outRefIndex = 0;\n\t//don't add a dep if already here !!\n\tfor (i = 0; i < ref->trackIDCount; i++) {\n\t\tif (ref->trackIDs[i] == trackID) {\n\t\t\tif (outRefIndex) *outRefIndex = i+1;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tref->trackIDs = (u32 *) gf_realloc(ref->trackIDs, (ref->trackIDCount + 1) * sizeof(u32) );\n\tif (!ref->trackIDs) return GF_OUT_OF_MEM;\n\tref->trackIDs[ref->trackIDCount] = trackID;\n\tref->trackIDCount++;\n\tif (outRefIndex) *outRefIndex = ref->trackIDCount;\n\treturn GF_OK;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err reftype_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tptr->type = ptr->reference_type;\n\tif (!ptr->trackIDCount) return GF_OK;\n\n\te = gf_isom_box_write_header(s, bs);\n\tptr->type = GF_ISOM_BOX_TYPE_REFT;\n\tif (e) return e;\n\tfor (i = 0; i < ptr->trackIDCount; i++) {\n\t\tgf_bs_write_u32(bs, ptr->trackIDs[i]);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err reftype_Size(GF_Box *s)\n{\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tif (!ptr->trackIDCount)\n\t\tptr->size=0;\n\telse\n\t\tptr->size += (ptr->trackIDCount * sizeof(u32));\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid trex_del(GF_Box *s)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err trex_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\n\tptr->trackID = gf_bs_read_u32(bs);\n\tptr->def_sample_desc_index = gf_bs_read_u32(bs);\n\tptr->def_sample_duration = gf_bs_read_u32(bs);\n\tptr->def_sample_size = gf_bs_read_u32(bs);\n\tptr->def_sample_flags = gf_bs_read_u32(bs);\n\n\tif (!ptr->def_sample_desc_index) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] TREX with default sample description set to 0, likely broken ! Fixing to 1\\n\" ));\n\t\tptr->def_sample_desc_index = 1;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *trex_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackExtendsBox, GF_ISOM_BOX_TYPE_TREX);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trex_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->trackID);\n\tgf_bs_write_u32(bs, ptr->def_sample_desc_index);\n\tgf_bs_write_u32(bs, ptr->def_sample_duration);\n\tgf_bs_write_u32(bs, ptr->def_sample_size);\n\tgf_bs_write_u32(bs, ptr->def_sample_flags);\n\treturn GF_OK;\n}\n\nGF_Err trex_Size(GF_Box *s)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\tptr->size += 20;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid trep_del(GF_Box *s)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err trep_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\n\tptr->trackID = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\treturn gf_isom_box_array_read(s, bs, gf_isom_box_add_default);\n}\n\nGF_Box *trep_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackExtensionPropertiesBox, GF_ISOM_BOX_TYPE_TREP);\n\ttmp->other_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trep_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->trackID);\n\treturn GF_OK;\n}\n\nGF_Err trep_Size(GF_Box *s)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid trun_del(GF_Box *s)\n{\n\tGF_TrunEntry *p;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->entries)) {\n\t\tp = (GF_TrunEntry*)gf_list_get(ptr->entries, 0);\n\t\tgf_list_rem(ptr->entries, 0);\n\t\tgf_free(p);\n\t}\n\tgf_list_del(ptr->entries);\n\tif (ptr->cache) gf_bs_del(ptr->cache);\n\tgf_free(ptr);\n}\n\nGF_Err trun_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrunEntry *p;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\n\t//check this is a good file\n\tif ((ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) && (ptr->flags & GF_ISOM_TRUN_FLAGS))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->sample_count = gf_bs_read_u32(bs);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tptr->data_offset = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t}\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\tptr->first_sample_flags = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t}\n\n\t//read each entry (even though nothing may be written)\n\tfor (i=0; i<ptr->sample_count; i++) {\n\t\tu32 trun_size = 0;\n\t\tp = (GF_TrunEntry *) gf_malloc(sizeof(GF_TrunEntry));\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\tmemset(p, 0, sizeof(GF_TrunEntry));\n\n\t\tif (ptr->flags & GF_ISOM_TRUN_DURATION) {\n\t\t\tp->Duration = gf_bs_read_u32(bs);\n\t\t\ttrun_size += 4;\n\t\t}\n\t\tif (ptr->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\tp->size = gf_bs_read_u32(bs);\n\t\t\ttrun_size += 4;\n\t\t}\n\t\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\t\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\tp->flags = gf_bs_read_u32(bs);\n\t\t\ttrun_size += 4;\n\t\t}\n\t\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) {\n\t\t\tif (ptr->version==0) {\n\t\t\t\tp->CTS_Offset = (u32) gf_bs_read_u32(bs);\n\t\t\t} else {\n\t\t\t\tp->CTS_Offset = (s32) gf_bs_read_u32(bs);\n\t\t\t}\n\t\t}\n\t\tgf_list_add(ptr->entries, p);\n\t\tISOM_DECREASE_SIZE(ptr, trun_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *trun_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentRunBox, GF_ISOM_BOX_TYPE_TRUN);\n\ttmp->entries = gf_list_new();\n\t//NO FLAGS SET BY DEFAULT\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trun_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrunEntry *p;\n\tGF_Err e;\n\tu32 i, count;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->sample_count);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tgf_bs_write_u32(bs, ptr->data_offset);\n\t}\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\tgf_bs_write_u32(bs, ptr->first_sample_flags);\n\t}\n\n\t//if nothing to do, this will be skipped automatically\n\tcount = gf_list_count(ptr->entries);\n\tfor (i=0; i<count; i++) {\n\t\tp = (GF_TrunEntry*)gf_list_get(ptr->entries, i);\n\n\t\tif (ptr->flags & GF_ISOM_TRUN_DURATION) {\n\t\t\tgf_bs_write_u32(bs, p->Duration);\n\t\t}\n\t\tif (ptr->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\tgf_bs_write_u32(bs, p->size);\n\t\t}\n\t\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\t\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\tgf_bs_write_u32(bs, p->flags);\n\t\t}\n\t\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) {\n\t\t\tif (ptr->version==0) {\n\t\t\t\tgf_bs_write_u32(bs, p->CTS_Offset);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, (u32) p->CTS_Offset);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err trun_Size(GF_Box *s)\n{\n\tu32 i, count;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\n\tptr->size += 4;\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) ptr->size += 4;\n\n\t//if nothing to do, this will be skipped automatically\n\tcount = gf_list_count(ptr->entries);\n\tfor (i=0; i<count; i++) {\n\t\tif (ptr->flags & GF_ISOM_TRUN_DURATION) ptr->size += 4;\n\t\tif (ptr->flags & GF_ISOM_TRUN_SIZE) ptr->size += 4;\n\t\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\t\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) ptr->size += 4;\n\t\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) ptr->size += 4;\n\t}\n\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid tsro_del(GF_Box *s)\n{\n\tGF_TimeOffHintEntryBox *tsro = (GF_TimeOffHintEntryBox *)s;\n\tgf_free(tsro);\n}\n\nGF_Err tsro_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TimeOffHintEntryBox *ptr = (GF_TimeOffHintEntryBox *)s;\n\tptr->TimeOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tsro_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeOffHintEntryBox, GF_ISOM_BOX_TYPE_TSRO);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tsro_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TimeOffHintEntryBox *ptr = (GF_TimeOffHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->TimeOffset);\n\treturn GF_OK;\n}\n\nGF_Err tsro_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid udta_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\tif (ptr == NULL) return;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\tgf_isom_box_array_del(map->other_boxes);\n\t\tgf_free(map);\n\t}\n\tgf_list_del(ptr->recordList);\n\tgf_free(ptr);\n}\n\nGF_UserDataMap *udta_getEntry(GF_UserDataBox *ptr, u32 box_type, bin128 *uuid)\n{\n\tu32 i;\n\tGF_UserDataMap *map;\n\tif (ptr == NULL) return NULL;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\tif (map->boxType == box_type) {\n\t\t\tif ((box_type != GF_ISOM_BOX_TYPE_UUID) || !uuid) return map;\n\t\t\tif (!memcmp(map->uuid, *uuid, 16)) return map;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nGF_Err udta_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_Err e;\n\tu32 box_type;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\tif (!ptr) return GF_BAD_PARAM;\n\tif (!a) return GF_OK;\n\n\t/* for unknown udta boxes, we reference them by their original box type */\n\tbox_type = a->type;\n\tif (box_type == GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tGF_UnknownBox* unkn = (GF_UnknownBox *)a;\n\t\tif (unkn)\n\t\t\tbox_type = unkn->original_4cc;\n\t}\n\n\tmap = udta_getEntry(ptr, box_type, (a->type==GF_ISOM_BOX_TYPE_UUID) ? & ((GF_UUIDBox *)a)->uuid : NULL);\n\tif (map == NULL) {\n\t\tmap = (GF_UserDataMap *) gf_malloc(sizeof(GF_UserDataMap));\n\t\tif (map == NULL) return GF_OUT_OF_MEM;\n\t\tmemset(map, 0, sizeof(GF_UserDataMap));\n\n\t\tmap->boxType = box_type;\n\t\tif (a->type == GF_ISOM_BOX_TYPE_UUID)\n\t\t\tmemcpy(map->uuid, ((GF_UUIDBox *)a)->uuid, 16);\n\t\tmap->other_boxes = gf_list_new();\n\t\tif (!map->other_boxes) {\n\t\t\tgf_free(map);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(ptr->recordList, map);\n\t\tif (e) return e;\n\t}\n\treturn gf_list_add(map->other_boxes, a);\n}\n\n\nGF_Err udta_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, udta_AddBox);\n}\n\nGF_Box *udta_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UserDataBox, GF_ISOM_BOX_TYPE_UDTA);\n\ttmp->recordList = gf_list_new();\n\tif (!tmp->recordList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err udta_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\t//warning: here we are not passing the actual \"parent\" of the list\n\t\t//but the UDTA box. The parent itself is not an box, we don't care about it\n\t\te = gf_isom_box_array_write(s, map->other_boxes, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err udta_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\t//warning: here we are not passing the actual \"parent\" of the list\n\t\t//but the UDTA box. The parent itself is not an box, we don't care about it\n\t\te = gf_isom_box_array_size(s, map->other_boxes);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid vmhd_del(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err vmhd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\n\tptr->reserved = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\n\nGF_Box *vmhd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_VideoMediaHeaderBox, GF_ISOM_BOX_TYPE_VMHD);\n\ttmp->flags = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err vmhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err vmhd_Size(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tptr->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid void_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err void_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tif (s->size) return GF_ISOM_INVALID_FILE;\n\treturn GF_OK;\n}\n\nGF_Box *void_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, GF_ISOM_BOX_TYPE_VOID);\n\treturn tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err void_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tgf_bs_write_u32(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err void_Size(GF_Box *s)\n{\n\ts->size = 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *pdin_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProgressiveDownloadBox, GF_ISOM_BOX_TYPE_PDIN);\n\ttmp->flags = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid pdin_del(GF_Box *s)\n{\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->rates) gf_free(ptr->rates);\n\tif (ptr->times) gf_free(ptr->times);\n\tgf_free(ptr);\n}\n\n\nGF_Err pdin_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox*)s;\n\n\tptr->count = (u32) (ptr->size) / 8;\n\tptr->rates = (u32*)gf_malloc(sizeof(u32)*ptr->count);\n\tptr->times = (u32*)gf_malloc(sizeof(u32)*ptr->count);\n\tfor (i=0; i<ptr->count; i++) {\n\t\tptr->rates[i] = gf_bs_read_u32(bs);\n\t\tptr->times[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pdin_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tfor (i=0; i<ptr->count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->rates[i]);\n\t\tgf_bs_write_u32(bs, ptr->times[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err pdin_Size(GF_Box *s)\n{\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox *)s;\n\tptr->size += 8*ptr->count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *sdtp_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleDependencyTypeBox, GF_ISOM_BOX_TYPE_SDTP);\n\ttmp->flags = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid sdtp_del(GF_Box *s)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sample_info) gf_free(ptr->sample_info);\n\tgf_free(ptr);\n}\n\n\nGF_Err sdtp_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;\n\n\t/*out-of-order sdtp, assume no padding at the end*/\n\tif (!ptr->sampleCount) ptr->sampleCount = (u32) ptr->size;\n\telse if (ptr->sampleCount > (u32) ptr->size) return GF_ISOM_INVALID_FILE;\n\n\tptr->sample_info = (u8 *) gf_malloc(sizeof(u8)*ptr->sampleCount);\n\tgf_bs_read_data(bs, (char*)ptr->sample_info, ptr->sampleCount);\n\tISOM_DECREASE_SIZE(ptr, ptr->sampleCount);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err sdtp_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, (char*)ptr->sample_info, ptr->sampleCount);\n\treturn GF_OK;\n}\n\nGF_Err sdtp_Size(GF_Box *s)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox *)s;\n\tptr->size += ptr->sampleCount;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *pasp_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PixelAspectRatioBox, GF_ISOM_BOX_TYPE_PASP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid pasp_del(GF_Box *s)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox*)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err pasp_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox*)s;\n\tptr->hSpacing = gf_bs_read_u32(bs);\n\tptr->vSpacing = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 8);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pasp_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->hSpacing);\n\tgf_bs_write_u32(bs, ptr->vSpacing);\n\treturn GF_OK;\n}\n\nGF_Err pasp_Size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *clap_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CleanAppertureBox, GF_ISOM_BOX_TYPE_CLAP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid clap_del(GF_Box *s)\n{\n\tGF_CleanAppertureBox *ptr = (GF_CleanAppertureBox*)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err clap_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CleanAppertureBox *ptr = (GF_CleanAppertureBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 32);\n\tptr->cleanApertureWidthN = gf_bs_read_u32(bs);\n\tptr->cleanApertureWidthD = gf_bs_read_u32(bs);\n\tptr->cleanApertureHeightN = gf_bs_read_u32(bs);\n\tptr->cleanApertureHeightD = gf_bs_read_u32(bs);\n\tptr->horizOffN = gf_bs_read_u32(bs);\n\tptr->horizOffD = gf_bs_read_u32(bs);\n\tptr->vertOffN = gf_bs_read_u32(bs);\n\tptr->vertOffD = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err clap_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CleanAppertureBox *ptr = (GF_CleanAppertureBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->cleanApertureWidthN);\n\tgf_bs_write_u32(bs, ptr->cleanApertureWidthD);\n\tgf_bs_write_u32(bs, ptr->cleanApertureHeightN);\n\tgf_bs_write_u32(bs, ptr->cleanApertureHeightD);\n\tgf_bs_write_u32(bs, ptr->horizOffN);\n\tgf_bs_write_u32(bs, ptr->horizOffD);\n\tgf_bs_write_u32(bs, ptr->vertOffN);\n\tgf_bs_write_u32(bs, ptr->vertOffD);\n\treturn GF_OK;\n}\n\nGF_Err clap_Size(GF_Box *s)\n{\n\ts->size += 32;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *metx_New()\n{\n\t//type is overridden by the box constructor\n\tISOM_DECL_BOX_ALLOC(GF_MetaDataSampleEntryBox, GF_ISOM_BOX_TYPE_METX);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid metx_del(GF_Box *s)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->content_encoding) gf_free(ptr->content_encoding);\n\tif (ptr->xml_namespace) gf_free(ptr->xml_namespace);\n\tif (ptr->xml_schema_loc) gf_free(ptr->xml_schema_loc);\n\tif (ptr->mime_type) gf_free(ptr->mime_type);\n\tif (ptr->config) gf_isom_box_del((GF_Box *)ptr->config);\n\tgf_free(ptr);\n}\n\n\nGF_Err metx_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_SINF:\n\t\tgf_list_add(ptr->protections, a);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TXTC:\n\t\t//we allow the config box on metx\n\t\tif (ptr->config) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->config = (GF_TextConfigBox *)a;\n\t\tbreak;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err metx_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 size, i;\n\tGF_Err e;\n\tchar *str;\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tsize = (u32) ptr->size - 8;\n\tstr = gf_malloc(sizeof(char)*size);\n\n\ti=0;\n\n\twhile (size) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tsize--;\n\t\tif (!str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tptr->xml_namespace = gf_strdup(str);\n\t\t} else {\n\t\t\tptr->content_encoding = gf_strdup(str);\n\t\t}\n\t}\n\n\ti=0;\n\twhile (size) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tsize--;\n\t\tif (!str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\t\tif (i) {\n\t\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\t\tptr->xml_schema_loc = gf_strdup(str);\n\t\t\t} else {\n\t\t\t\tptr->xml_namespace = gf_strdup(str);\n\t\t\t}\n\t\t}\n\n\t\ti=0;\n\t\twhile (size) {\n\t\t\tstr[i] = gf_bs_read_u8(bs);\n\t\t\tsize--;\n\t\t\tif (!str[i])\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t}\n\t\tif (i) {\n\t\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\t\tptr->mime_type = gf_strdup(str);\n\t\t\t} else {\n\t\t\t\tptr->xml_schema_loc = gf_strdup(str);\n\t\t\t}\n\t\t}\n\t}\n\t//mett, sbtt, stxt, stpp\n\telse {\n\t\tif (i) ptr->mime_type = gf_strdup(str);\n\t}\n\tptr->size = size;\n\tgf_free(str);\n\treturn gf_isom_box_array_read(s, bs, metx_AddBox);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err metx_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\n\tif (ptr->type!=GF_ISOM_BOX_TYPE_STPP) {\n\t\tif (ptr->content_encoding)\n\t\t\tgf_bs_write_data(bs, ptr->content_encoding, (u32) strlen(ptr->content_encoding));\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\t\tif (ptr->xml_namespace)\n\t\t\tgf_bs_write_data(bs, ptr->xml_namespace, (u32) strlen(ptr->xml_namespace));\n\n\t\tgf_bs_write_u8(bs, 0);\n\n\t\tif (ptr->xml_schema_loc)\n\t\t\tgf_bs_write_data(bs, ptr->xml_schema_loc, (u32) strlen(ptr->xml_schema_loc));\n\t\tgf_bs_write_u8(bs, 0);\n\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tif (ptr->mime_type)\n\t\t\t\tgf_bs_write_data(bs, ptr->mime_type, (u32) strlen(ptr->mime_type));\n\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\t//mett, sbtt, stxt\n\telse {\n\t\tif (ptr->mime_type)\n\t\t\tgf_bs_write_data(bs, ptr->mime_type, (u32) strlen(ptr->mime_type));\n\n\t\tgf_bs_write_u8(bs, 0);\n\n\t\tif (ptr->config) {\n\t\t\tgf_isom_box_write((GF_Box *)ptr->config, bs);\n\t\t}\n\t}\n\n\treturn gf_isom_box_array_write(s, ptr->protections, bs);\n}\n\nGF_Err metx_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tptr->size += 8;\n\n\tif (ptr->type!=GF_ISOM_BOX_TYPE_STPP) {\n\t\tif (ptr->content_encoding)\n\t\t\tptr->size += strlen(ptr->content_encoding);\n\t\tptr->size++;\n\t}\n\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\n\t\tif (ptr->xml_namespace)\n\t\t\tptr->size += strlen(ptr->xml_namespace);\n\t\tptr->size++;\n\n\t\tif (ptr->xml_schema_loc)\n\t\t\tptr->size += strlen(ptr->xml_schema_loc);\n\t\tptr->size++;\n\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tif (ptr->mime_type)\n\t\t\t\tptr->size += strlen(ptr->mime_type);\n\t\t\tptr->size++;\n\t\t}\n\n\t}\n\t//mett, sbtt, stxt\n\telse {\n\t\tif (ptr->mime_type)\n\t\t\tptr->size += strlen(ptr->mime_type);\n\t\tptr->size++;\n\n\t\tif (ptr->config) {\n\t\t\te = gf_isom_box_size((GF_Box *)ptr->config);\n\t\t\tif (e) return e;\n\t\t\tptr->size += ptr->config->size;\n\t\t}\n\t}\n\treturn gf_isom_box_array_size(s, ptr->protections);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/* SimpleTextSampleEntry */\nGF_Box *txtc_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextConfigBox, GF_ISOM_BOX_TYPE_TXTC);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid txtc_del(GF_Box *s)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox*)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->config) gf_free(ptr->config);\n\tgf_free(ptr);\n}\n\nGF_Err txtc_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 size, i;\n\tchar *str;\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox*)s;\n\n\tsize = (u32) ptr->size;\n\tstr = (char *)gf_malloc(sizeof(char)*size);\n\n\ti=0;\n\n\twhile (size) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tsize--;\n\t\tif (!str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) ptr->config = gf_strdup(str);\n\tgf_free(str);\n\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err txtc_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox *)s;\n\tGF_Err e = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->config)\n\t\tgf_bs_write_data(bs, ptr->config, (u32) strlen(ptr->config));\n\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err txtc_Size(GF_Box *s)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox *)s;\n\tif (ptr->config)\n\t\tptr->size += strlen(ptr->config);\n\tptr->size++;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dac3_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *dec3_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);\n\ttmp->cfg.is_ec3 = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid dac3_del(GF_Box *s)\n{\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tgf_free(ptr);\n}\n\n\nGF_Err dac3_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tif (ptr->cfg.is_ec3) {\n\t\tu32 i;\n\t\tptr->cfg.brcode = gf_bs_read_int(bs, 13);\n\t\tptr->cfg.nb_streams = gf_bs_read_int(bs, 3) + 1;\n\t\tfor (i=0; i<ptr->cfg.nb_streams; i++) {\n\t\t\tptr->cfg.streams[i].fscod = gf_bs_read_int(bs, 2);\n\t\t\tptr->cfg.streams[i].bsid = gf_bs_read_int(bs, 5);\n\t\t\tptr->cfg.streams[i].bsmod = gf_bs_read_int(bs, 5);\n\t\t\tptr->cfg.streams[i].acmod = gf_bs_read_int(bs, 3);\n\t\t\tptr->cfg.streams[i].lfon = gf_bs_read_int(bs, 1);\n\t\t\tgf_bs_read_int(bs, 3);\n\t\t\tptr->cfg.streams[i].nb_dep_sub = gf_bs_read_int(bs, 4);\n\t\t\tif (ptr->cfg.streams[i].nb_dep_sub) {\n\t\t\t\tptr->cfg.streams[i].chan_loc = gf_bs_read_int(bs, 9);\n\t\t\t} else {\n\t\t\t\tgf_bs_read_int(bs, 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tptr->cfg.nb_streams = 1;\n\t\tptr->cfg.streams[0].fscod = gf_bs_read_int(bs, 2);\n\t\tptr->cfg.streams[0].bsid = gf_bs_read_int(bs, 5);\n\t\tptr->cfg.streams[0].bsmod = gf_bs_read_int(bs, 3);\n\t\tptr->cfg.streams[0].acmod = gf_bs_read_int(bs, 3);\n\t\tptr->cfg.streams[0].lfon = gf_bs_read_int(bs, 1);\n\t\tptr->cfg.brcode = gf_bs_read_int(bs, 5);\n\t\tgf_bs_read_int(bs, 5);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dac3_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\n\tif (ptr->cfg.is_ec3) {\n\t\tu32 i;\n\t\tgf_bs_write_int(bs, ptr->cfg.brcode, 13);\n\t\tgf_bs_write_int(bs, ptr->cfg.nb_streams - 1, 3);\n\t\tfor (i=0; i<ptr->cfg.nb_streams; i++) {\n\t\t\tgf_bs_write_int(bs, ptr->cfg.streams[i].fscod, 2);\n\t\t\tgf_bs_write_int(bs, ptr->cfg.streams[i].bsid, 5);\n\t\t\tgf_bs_write_int(bs, ptr->cfg.streams[i].bsmod, 5);\n\t\t\tgf_bs_write_int(bs, ptr->cfg.streams[i].acmod, 3);\n\t\t\tgf_bs_write_int(bs, ptr->cfg.streams[i].lfon, 1);\n\t\t\tgf_bs_write_int(bs, 0, 3);\n\t\t\tgf_bs_write_int(bs, ptr->cfg.streams[i].nb_dep_sub, 4);\n\t\t\tif (ptr->cfg.streams[i].nb_dep_sub) {\n\t\t\t\tgf_bs_write_int(bs, ptr->cfg.streams[i].chan_loc, 9);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(bs, 0, 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tgf_bs_write_int(bs, ptr->cfg.streams[0].fscod, 2);\n\t\tgf_bs_write_int(bs, ptr->cfg.streams[0].bsid, 5);\n\t\tgf_bs_write_int(bs, ptr->cfg.streams[0].bsmod, 3);\n\t\tgf_bs_write_int(bs, ptr->cfg.streams[0].acmod, 3);\n\t\tgf_bs_write_int(bs, ptr->cfg.streams[0].lfon, 1);\n\t\tgf_bs_write_int(bs, ptr->cfg.brcode, 5);\n\t\tgf_bs_write_int(bs, 0, 5);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dac3_Size(GF_Box *s)\n{\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\n\tif (ptr->cfg.is_ec3) {\n\t\tu32 i;\n\t\ts->size += 2;\n\t\tfor (i=0; i<ptr->cfg.nb_streams; i++) {\n\t\t\ts->size += 3;\n\t\t\tif (ptr->cfg.streams[i].nb_dep_sub)\n\t\t\t\ts->size += 1;\n\t\t}\n\t} else {\n\t\ts->size += 3;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid lsrc_del(GF_Box *s)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->hdr) gf_free(ptr->hdr);\n\tgf_free(ptr);\n}\n\n\nGF_Err lsrc_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tptr->hdr_size = (u32) ptr->size;\n\tptr->hdr = gf_malloc(sizeof(char)*ptr->hdr_size);\n\tgf_bs_read_data(bs, ptr->hdr, ptr->hdr_size);\n\treturn GF_OK;\n}\n\nGF_Box *lsrc_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LASERConfigurationBox, GF_ISOM_BOX_TYPE_LSRC);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err lsrc_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->hdr, ptr->hdr_size);\n\treturn GF_OK;\n}\n\nGF_Err lsrc_Size(GF_Box *s)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tptr->size += ptr->hdr_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid lsr1_del(GF_Box *s)\n{\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tif (ptr->lsr_config) gf_isom_box_del((GF_Box *) ptr->lsr_config);\n\tif (ptr->descr) gf_isom_box_del((GF_Box *) ptr->descr);\n\tgf_free(ptr);\n}\n\nGF_Err lsr1_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_LSRC:\n\t\tif (ptr->lsr_config) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->lsr_config = (GF_LASERConfigurationBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_M4DS:\n\t\tif (ptr->descr) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->descr = (GF_MPEG4ExtensionDescriptorsBox *)a;\n\t\tbreak;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err lsr1_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox*)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\n\treturn gf_isom_box_array_read(s, bs, lsr1_AddBox);\n}\n\nGF_Box *lsr1_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LASeRSampleEntryBox, GF_ISOM_BOX_TYPE_LSR1);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err lsr1_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tif (ptr->lsr_config) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->lsr_config, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->descr) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->descr, bs);\n\t\tif (e) return e;\n\t}\n\treturn e;\n}\n\nGF_Err lsr1_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\n\ts->size += 8;\n\tif (ptr->lsr_config) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->lsr_config);\n\t\tif (e) return e;\n\t\tptr->size += ptr->lsr_config->size;\n\t}\n\tif (ptr->descr) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->descr);\n\t\tif (e) return e;\n\t\tptr->size += ptr->descr->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid sidx_del(GF_Box *s)\n{\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->refs) gf_free(ptr->refs);\n\tgf_free(ptr);\n}\n\nGF_Err sidx_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\tptr->reference_ID = gf_bs_read_u32(bs);\n\tptr->timescale = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 8);\n\n\tif (ptr->version==0) {\n\t\tptr->earliest_presentation_time = gf_bs_read_u32(bs);\n\t\tptr->first_offset = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t} else {\n\t\tptr->earliest_presentation_time = gf_bs_read_u64(bs);\n\t\tptr->first_offset = gf_bs_read_u64(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t}\n\tgf_bs_read_u16(bs); /* reserved */\n\tptr->nb_refs = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tptr->refs = gf_malloc(sizeof(GF_SIDXReference)*ptr->nb_refs);\n\tfor (i=0; i<ptr->nb_refs; i++) {\n\t\tptr->refs[i].reference_type = gf_bs_read_int(bs, 1);\n\t\tptr->refs[i].reference_size = gf_bs_read_int(bs, 31);\n\t\tptr->refs[i].subsegment_duration = gf_bs_read_u32(bs);\n\t\tptr->refs[i].starts_with_SAP = gf_bs_read_int(bs, 1);\n\t\tptr->refs[i].SAP_type = gf_bs_read_int(bs, 3);\n\t\tptr->refs[i].SAP_delta_time = gf_bs_read_int(bs, 28);\n\n\t\tISOM_DECREASE_SIZE(ptr, 12);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *sidx_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SegmentIndexBox, GF_ISOM_BOX_TYPE_SIDX);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err sidx_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->reference_ID);\n\tgf_bs_write_u32(bs, ptr->timescale);\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, (u32) ptr->earliest_presentation_time);\n\t\tgf_bs_write_u32(bs, (u32) ptr->first_offset);\n\t} else {\n\t\tgf_bs_write_u64(bs, ptr->earliest_presentation_time);\n\t\tgf_bs_write_u64(bs, ptr->first_offset);\n\t}\n\tgf_bs_write_u16(bs, 0);\n\tgf_bs_write_u16(bs, ptr->nb_refs);\n\tfor (i=0; i<ptr->nb_refs; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->refs[i].reference_type, 1);\n\t\tgf_bs_write_int(bs, ptr->refs[i].reference_size, 31);\n\t\tgf_bs_write_u32(bs, ptr->refs[i].subsegment_duration);\n\t\tgf_bs_write_int(bs, ptr->refs[i].starts_with_SAP, 1);\n\t\tgf_bs_write_int(bs, ptr->refs[i].SAP_type, 3);\n\t\tgf_bs_write_int(bs, ptr->refs[i].SAP_delta_time, 28);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sidx_Size(GF_Box *s)\n{\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\tptr->size += 12;\n\tif (ptr->version==0) {\n\t\tptr->size += 8;\n\t} else {\n\t\tptr->size += 16;\n\t}\n\tptr->size += ptr->nb_refs * 12;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ssix_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->subsegments) {\n\t\tfor (i = 0; i < ptr->subsegment_count; i++) {\n\t\t\tGF_Subsegment *subsegment = &ptr->subsegments[i];\n\t\t\tif (subsegment->levels) gf_free(subsegment->levels);\n\t\t\tif (subsegment->range_sizes) gf_free(subsegment->range_sizes);\n\t\t}\n\t\tgf_free(ptr->subsegments);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err ssix_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i,j;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\tif (ptr->size < 4) return GF_BAD_PARAM;\n\tptr->subsegment_count = gf_bs_read_u32(bs);\n\tptr->size -= 4;\n\tptr->subsegments = gf_malloc(ptr->subsegment_count*sizeof(GF_Subsegment));\n\tfor (i = 0; i < ptr->subsegment_count; i++) {\n\t\tGF_Subsegment *subseg = &ptr->subsegments[i];\n\t\tif (ptr->size < 4) return GF_BAD_PARAM;\n\t\tsubseg->range_count = gf_bs_read_u32(bs);\n\t\tptr->size -= 4;\n\t\tif (ptr->size < subseg->range_count*4) return GF_BAD_PARAM;\n\t\tsubseg->levels = gf_malloc(sizeof(u8)*subseg->range_count);\n\t\tsubseg->range_sizes = gf_malloc(sizeof(u32)*subseg->range_count);\n\t\tfor (j = 0; j < subseg->range_count; j++) {\n\t\t\tsubseg->levels[j] = gf_bs_read_u8(bs);\n\t\t\tsubseg->range_sizes[j] = gf_bs_read_u24(bs);\n\t\t\tptr->size -= 4;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *ssix_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubsegmentIndexBox, GF_ISOM_BOX_TYPE_SSIX);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ssix_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->subsegment_count);\n\tfor (i = 0; i<ptr->subsegment_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->subsegments[i].range_count);\n\t\tfor (j = 0; j < ptr->subsegment_count; j++) {\n\t\t\tgf_bs_write_u8(bs, ptr->subsegments[i].levels[j]);\n\t\t\tgf_bs_write_u24(bs, ptr->subsegments[i].range_sizes[j]);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ssix_Size(GF_Box *s)\n{\n\tu32 i;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\tptr->size += 4;\n\tfor (i = 0; i < ptr->subsegment_count; i++) {\n\t\tptr->size += 4 + 4 * ptr->subsegments[i].range_count;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid leva_del(GF_Box *s)\n{\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->levels) gf_free(ptr->levels);\n\tgf_free(ptr);\n}\n\nGF_Err leva_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\tif (ptr->size < 4) return GF_BAD_PARAM;\n\tptr->level_count = gf_bs_read_u8(bs);\n\tptr->size -= 4;\n\tGF_SAFE_ALLOC_N(ptr->levels, ptr->level_count, GF_LevelAssignment);\n\tfor (i = 0; i < ptr->level_count; i++) {\n\t\tGF_LevelAssignment *level = &ptr->levels[i];\n\t\tu8 tmp;\n\t\tif (ptr->size < 5) return GF_BAD_PARAM;\n\t\tlevel->track_id = gf_bs_read_u32(bs);\n\t\ttmp = gf_bs_read_u8(bs);\n\t\tlevel->padding_flag = tmp >> 7;\n\t\tlevel->type = tmp & 0x7F;\n\t\tif (level->type == 0) {\n\t\t\tlevel->grouping_type = gf_bs_read_u32(bs);\n\t\t}\n\t\telse if (level->type == 1) {\n\t\t\tlevel->grouping_type = gf_bs_read_u32(bs);\n\t\t\tlevel->grouping_type_parameter = gf_bs_read_u32(bs);\n\t\t}\n\t\telse if (level->type == 4) {\n\t\t\tlevel->sub_track_id = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *leva_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LevelAssignmentBox, GF_ISOM_BOX_TYPE_LEVA);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err leva_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->level_count);\n\tfor (i = 0; i<ptr->level_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->levels[i].track_id);\n\t\tgf_bs_write_u8(bs, ptr->levels[i].padding_flag << 7 | (ptr->levels[i].type & 0x7F));\n\t\tif (ptr->levels[i].type == 0) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type);\n\t\t}\n\t\telse if (ptr->levels[i].type == 1) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type);\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type_parameter);\n\t\t}\n\t\telse if (ptr->levels[i].type == 4) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].sub_track_id);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err leva_Size(GF_Box *s)\n{\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\tptr->size += 1;\n\tfor (i = 0; i < ptr->level_count; i++) {\n\t\tptr->size += 5;\n\t\tif (ptr->levels[i].type == 0 || ptr->levels[i].type == 4) {\n\t\t\tptr->size += 4;\n\t\t}\n\t\telse if (ptr->levels[i].type == 1) {\n\t\t\tptr->size += 8;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *pcrb_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PcrInfoBox, GF_ISOM_BOX_TYPE_PCRB);\n\treturn (GF_Box *)tmp;\n}\n\nvoid pcrb_del(GF_Box *s)\n{\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->pcr_values) gf_free(ptr->pcr_values);\n\tgf_free(ptr);\n}\n\nGF_Err pcrb_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\tptr->subsegment_count = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tptr->pcr_values = gf_malloc(sizeof(u64)*ptr->subsegment_count);\n\tfor (i=0; i<ptr->subsegment_count; i++) {\n\t\tu64 data1 = gf_bs_read_u32(bs);\n\t\tu64 data2 = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 6);\n\t\tptr->pcr_values[i] = (data1 << 10) | (data2 >> 6);\n\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pcrb_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->subsegment_count);\n\n\tfor (i=0; i<ptr->subsegment_count; i++ ) {\n\t\tu32 data1 = (u32) (ptr->pcr_values[i] >> 10);\n\t\tu16 data2 = (u16) (ptr->pcr_values[i] << 6);\n\n\t\tgf_bs_write_u32(bs, data1);\n\t\tgf_bs_write_u16(bs, data2);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err pcrb_Size(GF_Box *s)\n{\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\tptr->size += 4;\n\tptr->size += ptr->subsegment_count * 6;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *subs_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubSampleInformationBox, GF_ISOM_BOX_TYPE_SUBS);\n\ttmp->Samples = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid subs_del(GF_Box *s)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->Samples)) {\n\t\tGF_SubSampleInfoEntry *pSamp;\n\t\tpSamp = (GF_SubSampleInfoEntry*)gf_list_get(ptr->Samples, 0);\n\t\twhile (gf_list_count(pSamp->SubSamples)) {\n\t\t\tGF_SubSampleEntry *pSubSamp;\n\t\t\tpSubSamp = (GF_SubSampleEntry*) gf_list_get(pSamp->SubSamples, 0);\n\t\t\tgf_free(pSubSamp);\n\t\t\tgf_list_rem(pSamp->SubSamples, 0);\n\t\t}\n\t\tgf_list_del(pSamp->SubSamples);\n\t\tgf_free(pSamp);\n\t\tgf_list_rem(ptr->Samples, 0);\n\t}\n\tgf_list_del(ptr->Samples);\n\tgf_free(ptr);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err subs_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j, entry_count;\n\tu16 subsample_count;\n\tGF_SubSampleInfoEntry *pSamp;\n\tGF_SubSampleEntry *pSubSamp;\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *) s;\n\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tentry_count = gf_list_count(ptr->Samples);\n\tgf_bs_write_u32(bs, entry_count);\n\n\tfor (i=0; i<entry_count; i++) {\n\t\tpSamp = (GF_SubSampleInfoEntry*) gf_list_get(ptr->Samples, i);\n\t\tsubsample_count = gf_list_count(pSamp->SubSamples);\n\t\tgf_bs_write_u32(bs, pSamp->sample_delta);\n\t\tgf_bs_write_u16(bs, subsample_count);\n\n\t\tfor (j=0; j<subsample_count; j++) {\n\t\t\tpSubSamp = (GF_SubSampleEntry*) gf_list_get(pSamp->SubSamples, j);\n\t\t\tif (ptr->version == 1) {\n\t\t\t\tgf_bs_write_u32(bs, pSubSamp->subsample_size);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u16(bs, pSubSamp->subsample_size);\n\t\t\t}\n\t\t\tgf_bs_write_u8(bs, pSubSamp->subsample_priority);\n\t\t\tgf_bs_write_u8(bs, pSubSamp->discardable);\n\t\t\tgf_bs_write_u32(bs, pSubSamp->reserved);\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Err subs_Size(GF_Box *s)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *) s;\n\tGF_SubSampleInfoEntry *pSamp;\n\tu32 entry_count, i;\n\tu16 subsample_count;\n\n\t// add 4 byte for entry_count\n\tptr->size += 4;\n\tentry_count = gf_list_count(ptr->Samples);\n\tfor (i=0; i<entry_count; i++) {\n\t\tpSamp = (GF_SubSampleInfoEntry*) gf_list_get(ptr->Samples, i);\n\t\tsubsample_count = gf_list_count(pSamp->SubSamples);\n\t\t// 4 byte for sample_delta, 2 byte for subsample_count\n\t\t// and 6 + (4 or 2) bytes for each subsample\n\t\tptr->size += 4 + 2 + subsample_count * (6 + (ptr->version==1 ? 4 : 2));\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Err subs_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *)s;\n\tu32 entry_count, i, j;\n\tu16 subsample_count;\n\n\tentry_count = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tfor (i=0; i<entry_count; i++) {\n\t\tu32 subs_size=0;\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry*) gf_malloc(sizeof(GF_SubSampleInfoEntry));\n\t\tif (!pSamp) return GF_OUT_OF_MEM;\n\n\t\tmemset(pSamp, 0, sizeof(GF_SubSampleInfoEntry));\n\t\tpSamp->SubSamples = gf_list_new();\n\t\tpSamp->sample_delta = gf_bs_read_u32(bs);\n\t\tsubsample_count = gf_bs_read_u16(bs);\n\t\tsubs_size=6;\n\n\t\tfor (j=0; j<subsample_count; j++) {\n\t\t\tGF_SubSampleEntry *pSubSamp = (GF_SubSampleEntry*) gf_malloc(sizeof(GF_SubSampleEntry));\n\t\t\tif (!pSubSamp) return GF_OUT_OF_MEM;\n\n\t\t\tmemset(pSubSamp, 0, sizeof(GF_SubSampleEntry));\n\t\t\tif (ptr->version==1) {\n\t\t\t\tpSubSamp->subsample_size = gf_bs_read_u32(bs);\n\t\t\t\tsubs_size+=4;\n\t\t\t} else {\n\t\t\t\tpSubSamp->subsample_size = gf_bs_read_u16(bs);\n\t\t\t\tsubs_size+=2;\n\t\t\t}\n\t\t\tpSubSamp->subsample_priority = gf_bs_read_u8(bs);\n\t\t\tpSubSamp->discardable = gf_bs_read_u8(bs);\n\t\t\tpSubSamp->reserved = gf_bs_read_u32(bs);\n\t\t\tsubs_size+=6;\n\n\t\t\tgf_list_add(pSamp->SubSamples, pSubSamp);\n\t\t}\n\t\tgf_list_add(ptr->Samples, pSamp);\n\t\tISOM_DECREASE_SIZE(ptr, subs_size);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\nGF_Box *tfdt_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TFBaseMediaDecodeTimeBox, GF_ISOM_BOX_TYPE_TFDT);\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfdt_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n/*this is using chpl format according to some NeroRecode samples*/\nGF_Err tfdt_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;\n\n\tif (ptr->version==1) {\n\t\tptr->baseMediaDecodeTime = gf_bs_read_u64(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t} else {\n\t\tptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfdt_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->version==1) {\n\t\tgf_bs_write_u64(bs, ptr->baseMediaDecodeTime);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->baseMediaDecodeTime);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfdt_Size(GF_Box *s)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;\n\n\tif (ptr->baseMediaDecodeTime<=0xFFFFFFFF) {\n\t\tptr->version = 0;\n\t\tptr->size += 4;\n\t} else {\n\t\tptr->version = 1;\n\t\tptr->size += 8;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nGF_Box *rvcc_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RVCConfigurationBox, GF_ISOM_BOX_TYPE_RVCC);\n\treturn (GF_Box *)tmp;\n}\n\nvoid rvcc_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err rvcc_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox*)s;\n\tptr->predefined_rvc_config = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tif (!ptr->predefined_rvc_config) {\n\t\tptr->rvc_meta_idx = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err rvcc_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox*) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->predefined_rvc_config);\n\tif (!ptr->predefined_rvc_config) {\n\t\tgf_bs_write_u16(bs, ptr->rvc_meta_idx);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err rvcc_Size(GF_Box *s)\n{\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox *)s;\n\tptr->size += 2;\n\tif (! ptr->predefined_rvc_config) ptr->size += 2;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *sbgp_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleGroupBox, GF_ISOM_BOX_TYPE_SBGP);\n\treturn (GF_Box *)tmp;\n}\nvoid sbgp_del(GF_Box *a)\n{\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox *)a;\n\tif (p->sample_entries) gf_free(p->sample_entries);\n\tgf_free(p);\n}\n\nGF_Err sbgp_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SampleGroupBox *ptr = (GF_SampleGroupBox *)s;\n\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tif (ptr->version==1) {\n\t\tptr->grouping_type_parameter = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t}\n\tptr->entry_count = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tptr->sample_entries = gf_malloc(sizeof(GF_SampleGroupEntry)*ptr->entry_count);\n\tif (!ptr->sample_entries) return GF_IO_ERR;\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tptr->sample_entries[i].sample_count = gf_bs_read_u32(bs);\n\t\tptr->sample_entries[i].group_description_index = gf_bs_read_u32(bs);\n\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sbgp_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, p->grouping_type);\n\tif (p->version==1)\n\t\tgf_bs_write_u32(bs, p->grouping_type_parameter);\n\n\tgf_bs_write_u32(bs, p->entry_count);\n\tfor (i = 0; i<p->entry_count; i++ ) {\n\t\tgf_bs_write_u32(bs, p->sample_entries[i].sample_count);\n\t\tgf_bs_write_u32(bs, p->sample_entries[i].group_description_index);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sbgp_Size(GF_Box *s)\n{\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox*)s;\n\n\tp->size += 8;\n\tif (p->grouping_type_parameter) p->version=1;\n\n\tif (p->version==1) p->size += 4;\n\tp->size += 8*p->entry_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nstatic void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, u32 entry_size, u32 *total_bytes)\n{\n\tBool null_size_ok = GF_FALSE;\n\n\tGF_DefaultSampleGroupDescriptionEntry *ptr;\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t{\n\t\tGF_RollRecoveryEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_RollRecoveryEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->roll_distance = gf_bs_read_int(bs, 16);\n\t\t*total_bytes = 2;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t{\n\t\tGF_VisualRandomAccessEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_VisualRandomAccessEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->num_leading_samples_known = gf_bs_read_int(bs, 1);\n\t\tptr->num_leading_samples = gf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t{\n\t\tGF_SAPEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SAPEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->dependent_flag = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 3);\n\t\tptr->SAP_type = gf_bs_read_int(bs, 4);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t{\n\t\tGF_SYNCEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SYNCEntry);\n\t\tif (!ptr) return NULL;\n\t\tgf_bs_read_int(bs, 2);\n\t\tptr->NALU_type = gf_bs_read_int(bs, 6);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t{\n\t\tGF_TemporalLevelEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_TemporalLevelEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->level_independently_decodable = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry);\n\t\tif (!ptr) return NULL;\n\t\tgf_bs_read_u8(bs); //reserved\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->IsProtected = gf_bs_read_u8(bs);\n\t\tptr->Per_Sample_IV_size = gf_bs_read_u8(bs);\n\t\tgf_bs_read_data(bs, (char *)ptr->KID, 16);\n\t\t*total_bytes = 20;\n\t\tif ((ptr->IsProtected == 1) && !ptr->Per_Sample_IV_size) {\n\t\t\tptr->constant_IV_size = gf_bs_read_u8(bs);\n\t\t\tassert((ptr->constant_IV_size == 8) || (ptr->constant_IV_size == 16));\n\t\t\tgf_bs_read_data(bs, (char *)ptr->constant_IV, ptr->constant_IV_size);\n\t\t\t*total_bytes += 1 + ptr->constant_IV_size;\n\t\t}\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t{\n\t\tGF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_oinf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] oinf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t{\n\t\tGF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_linf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] linf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\n\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n\t\tif (! entry_size) {\n\t\t\tu32 flags = gf_bs_peek_bits(bs, 24, 0);\n\t\t\tif (flags & 0x10000) entry_size=3;\n\t\t\telse {\n\t\t\t\tif (flags & 0x80000) entry_size=7;\n\t\t\t\telse entry_size=11;\n\t\t\t\t//have dependency list\n\t\t\t\tif (flags & 0x200000) {\n\t\t\t\t\tu32 nb_entries = gf_bs_peek_bits(bs, 16, entry_size);\n\t\t\t\t\tentry_size += 2 + 2*nb_entries;\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] trif sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n\t\tif (! entry_size) {\n\t\t\tu64 start = gf_bs_get_position(bs);\n\t\t\tBool rle, large_size;\n\t\t\tu32 entry_count;\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t\tlarge_size = gf_bs_read_int(bs, 1);\n\t\t\trle = gf_bs_read_int(bs, 1);\n\t\t\tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n\t\t\tgf_bs_seek(bs, start);\n\t\t\tentry_size = 1 + large_size ? 2 : 1;\n\t\t\tentry_size += entry_count * 2;\n\t\t\tif (rle) entry_size += entry_count * (large_size ? 2 : 1);\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] nalm sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_SAMPLE_GROUP_TSAS:\n\tcase GF_ISOM_SAMPLE_GROUP_STSA:\n\t\tnull_size_ok = GF_TRUE;\n\t\tbreak;\n\t//TODO, add support for these ones ?\n\tcase GF_ISOM_SAMPLE_GROUP_TSCL:\n\t\tentry_size = 20;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_LBLI:\n\t\tentry_size = 2;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!entry_size && !null_size_ok) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\\n\", gf_4cc_to_str( grouping_type) ));\n\t\treturn NULL;\n\t}\n\tGF_SAFEALLOC(ptr, GF_DefaultSampleGroupDescriptionEntry);\n\tif (!ptr) return NULL;\n\tif (entry_size) {\n\t\tptr->length = entry_size;\n\t\tptr->data = (u8 *) gf_malloc(sizeof(u8)*ptr->length);\n\t\tgf_bs_read_data(bs, (char *) ptr->data, ptr->length);\n\t\t*total_bytes = entry_size;\n\t}\n\treturn ptr;\n}\n\nstatic void\tsgpd_del_entry(u32 grouping_type, void *entry)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\tgf_free(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\tgf_isom_oinf_del_entry(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\tgf_isom_linf_del_entry(entry);\n\t\treturn;\n\tdefault:\n\t{\n\t\tGF_DefaultSampleGroupDescriptionEntry *ptr = (GF_DefaultSampleGroupDescriptionEntry *)entry;\n\t\tif (ptr->data) gf_free(ptr->data);\n\t\tgf_free(ptr);\n\t}\n\t}\n}\n\nvoid sgpd_write_entry(u32 grouping_type, void *entry, GF_BitStream *bs)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\tgf_bs_write_int(bs, ((GF_RollRecoveryEntry*)entry)->roll_distance, 16);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\tgf_bs_write_int(bs, ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples_known, 1);\n\t\tgf_bs_write_int(bs, ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples, 7);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\tgf_bs_write_int(bs, ((GF_SAPEntry*)entry)->dependent_flag, 1);\n\t\tgf_bs_write_int(bs, 0, 3);\n\t\tgf_bs_write_int(bs, ((GF_SAPEntry*)entry)->SAP_type, 4);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\tgf_bs_write_int(bs, 0, 2);\n\t\tgf_bs_write_int(bs, ((GF_SYNCEntry*)entry)->NALU_type, 6);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t\tgf_bs_write_int(bs, ((GF_TemporalLevelEntry*)entry)->level_independently_decodable, 1);\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t\tgf_bs_write_u8(bs, 0x0);\n\t\tgf_bs_write_int(bs, ((GF_CENCSampleEncryptionGroupEntry*)entry)->crypt_byte_block, 4);\n\t\tgf_bs_write_int(bs, ((GF_CENCSampleEncryptionGroupEntry*)entry)->skip_byte_block, 4);\n\t\tgf_bs_write_u8(bs, ((GF_CENCSampleEncryptionGroupEntry *)entry)->IsProtected);\n\t\tgf_bs_write_u8(bs, ((GF_CENCSampleEncryptionGroupEntry *)entry)->Per_Sample_IV_size);\n\t\tgf_bs_write_data(bs, (char *)((GF_CENCSampleEncryptionGroupEntry *)entry)->KID, 16);\n\t\tif ((((GF_CENCSampleEncryptionGroupEntry *)entry)->IsProtected == 1) && !((GF_CENCSampleEncryptionGroupEntry *)entry)->Per_Sample_IV_size) {\n\t\t\tgf_bs_write_u8(bs, ((GF_CENCSampleEncryptionGroupEntry *)entry)->constant_IV_size);\n\t\t\tgf_bs_write_data(bs, (char *)((GF_CENCSampleEncryptionGroupEntry *)entry)->constant_IV, ((GF_CENCSampleEncryptionGroupEntry *)entry)->constant_IV_size);\n\t\t}\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\tgf_isom_oinf_write_entry(entry, bs);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\tgf_isom_linf_write_entry(entry, bs);\n\t\treturn;\n\tdefault:\n\t{\n\t\tGF_DefaultSampleGroupDescriptionEntry *ptr = (GF_DefaultSampleGroupDescriptionEntry *)entry;\n\t\tif (ptr->length)\n\t\t\tgf_bs_write_data(bs, (char *) ptr->data, ptr->length);\n\t}\n\t}\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nstatic u32 sgpd_size_entry(u32 grouping_type, void *entry)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\treturn 2;\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\treturn 1;\n\tcase GF_ISOM_SAMPLE_GROUP_TSCL:\n\t\treturn 20;\n\tcase GF_ISOM_SAMPLE_GROUP_LBLI:\n\t\treturn 2;\n\tcase GF_ISOM_SAMPLE_GROUP_TSAS:\n\tcase GF_ISOM_SAMPLE_GROUP_STSA:\n\t\treturn 0;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t\treturn ((((GF_CENCSampleEncryptionGroupEntry *)entry)->IsProtected == 1) && !((GF_CENCSampleEncryptionGroupEntry *)entry)->Per_Sample_IV_size) ? 21 + ((GF_CENCSampleEncryptionGroupEntry *)entry)->constant_IV_size : 20;\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\treturn gf_isom_oinf_size_entry(entry);\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\treturn gf_isom_linf_size_entry(entry);\n\tdefault:\n\t\treturn ((GF_DefaultSampleGroupDescriptionEntry *)entry)->length;\n\t}\n}\n#endif\n\nGF_Box *sgpd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleGroupDescriptionBox, GF_ISOM_BOX_TYPE_SGPD);\n\t/*version 0 is deprecated, use v1 by default*/\n\ttmp->version = 1;\n\ttmp->group_descriptions = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid sgpd_del(GF_Box *a)\n{\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)a;\n\twhile (gf_list_count(p->group_descriptions)) {\n\t\tvoid *ptr = gf_list_last(p->group_descriptions);\n\t\tsgpd_del_entry(p->grouping_type, ptr);\n\t\tgf_list_rem_last(p->group_descriptions);\n\t}\n\tgf_list_del(p->group_descriptions);\n\tgf_free(p);\n}\n\nGF_Err sgpd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entry_count;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\n\tp->grouping_type = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(p, 4);\n\n\tif (p->version>=1) {\n\t\tp->default_length = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(p, 4);\n\t}\n\tif (p->version>=2) {\n\t\tp->default_description_index = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(p, 4);\n\t}\n\tentry_count = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(p, 4);\n\n\tif (entry_count>p->size)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\twhile (entry_count) {\n\t\tvoid *ptr;\n\t\tu32 parsed_bytes=0;\n\t\tu32 size = p->default_length;\n\t\tif ((p->version>=1) && !size) {\n\t\t\tsize = gf_bs_read_u32(bs);\n\t\t\tISOM_DECREASE_SIZE(p, 4);\n\t\t}\n\t\tptr = sgpd_parse_entry(p->grouping_type, bs, size, &parsed_bytes);\n\t\t//don't return an error, just stop parsing so that we skip over the sgpd box\n\t\tif (!ptr) return GF_OK;\n\n\t\tISOM_DECREASE_SIZE(p, parsed_bytes);\n\n\t\tgf_list_add(p->group_descriptions, ptr);\n\t\tentry_count--;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sgpd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\tGF_Err e;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, p->grouping_type);\n\tif (p->version>=1) gf_bs_write_u32(bs, p->default_length);\n\tif (p->version>=2) gf_bs_write_u32(bs, p->default_description_index);\n\tgf_bs_write_u32(bs, gf_list_count(p->group_descriptions) );\n\n\tfor (i=0; i<gf_list_count(p->group_descriptions); i++) {\n\t\tvoid *ptr = gf_list_get(p->group_descriptions, i);\n\t\tif ((p->version >= 1) && !p->default_length) {\n\t\t\tu32 size = sgpd_size_entry(p->grouping_type, ptr);\n\t\t\tgf_bs_write_u32(bs, size);\n\t\t}\n\t\tsgpd_write_entry(p->grouping_type, ptr, bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sgpd_Size(GF_Box *s)\n{\n\tu32 i;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\n\tp->size += 8;\n\n\t//we force all sample groups to version 1, v0 being deprecated\n\tp->version=1;\n\tp->size += 4;\n\n\tif (p->version>=2) p->size += 4;\n\tp->default_length = 0;\n\n\tfor (i=0; i<gf_list_count(p->group_descriptions); i++) {\n\t\tvoid *ptr = gf_list_get(p->group_descriptions, i);\n\t\tu32 size = sgpd_size_entry(p->grouping_type, ptr);\n\t\tp->size += size;\n\t\tif (!p->default_length) {\n\t\t\tp->default_length = size;\n\t\t} else if (p->default_length != size) {\n\t\t\tp->default_length = 0;\n\t\t}\n\t}\n\tif (p->version>=1) {\n\t\tif (!p->default_length) p->size += gf_list_count(p->group_descriptions)*4;\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid saiz_del(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sample_info_size) gf_free(ptr->sample_info_size);\n\tgf_free(ptr);\n}\n\n\nGF_Err saiz_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\n\tif (ptr->flags & 1) {\n\t\tptr->aux_info_type = gf_bs_read_u32(bs);\n\t\tptr->aux_info_type_parameter = gf_bs_read_u32(bs);\n\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t}\n\tptr->default_sample_info_size = gf_bs_read_u8(bs);\n\tptr->sample_count = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 5);\n\n\tif (ptr->default_sample_info_size == 0) {\n\t\tptr->sample_info_size = gf_malloc(sizeof(u8)*ptr->sample_count);\n\t\tgf_bs_read_data(bs, (char *) ptr->sample_info_size, ptr->sample_count);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->sample_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *saiz_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleAuxiliaryInfoSizeBox, GF_ISOM_BOX_TYPE_SAIZ);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err saiz_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->flags & 1) {\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type);\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type_parameter);\n\t}\n\tgf_bs_write_u8(bs, ptr->default_sample_info_size);\n\tgf_bs_write_u32(bs, ptr->sample_count);\n\tif (!ptr->default_sample_info_size) {\n\t\tgf_bs_write_data(bs, (char *) ptr->sample_info_size, ptr->sample_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err saiz_Size(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoSizeBox *ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\n\tif (ptr->aux_info_type || ptr->aux_info_type_parameter) {\n\t\tptr->flags |= 1;\n\t}\n\tif (ptr->flags & 1) ptr->size += 8;\n\tptr->size += 5;\n\tif (ptr->default_sample_info_size==0)  ptr->size += ptr->sample_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nvoid saio_del(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tif (ptr->offsets_large) gf_free(ptr->offsets_large);\n\tgf_free(ptr);\n}\n\n\nGF_Err saio_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox *)s;\n\n\tif (ptr->flags & 1) {\n\t\tptr->aux_info_type = gf_bs_read_u32(bs);\n\t\tptr->aux_info_type_parameter = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t}\n\tptr->entry_count = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tif (ptr->entry_count) {\n\t\tu32 i;\n\t\tif (ptr->version==0) {\n\t\t\tptr->offsets = gf_malloc(sizeof(u32)*ptr->entry_count);\n\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\tptr->offsets[i] = gf_bs_read_u32(bs);\n\n\t\t\tISOM_DECREASE_SIZE(ptr, 4*ptr->entry_count);\n\t\t} else {\n\t\t\tptr->offsets_large = gf_malloc(sizeof(u64)*ptr->entry_count);\n\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\tptr->offsets_large[i] = gf_bs_read_u64(bs);\n\t\t\tISOM_DECREASE_SIZE(ptr, 8*ptr->entry_count);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *saio_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleAuxiliaryInfoOffsetBox, GF_ISOM_BOX_TYPE_SAIO);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err saio_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->flags & 1) {\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type);\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type_parameter);\n\t}\n\n\n\tgf_bs_write_u32(bs, ptr->entry_count);\n\tif (ptr->entry_count) {\n\t\tu32 i;\n\t\t//store position in bitstream before writing data - offsets can be NULL if a single offset is rewritten later on (cf senc_write)\n\t\tptr->offset_first_offset_field = gf_bs_get_position(bs);\n\t\tif (ptr->version==0) {\n\t\t\tif (!ptr->offsets) {\n\t\t\t\tgf_bs_write_u32(bs, 0);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\t\tgf_bs_write_u32(bs, ptr->offsets[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!ptr->offsets_large) {\n\t\t\t\tgf_bs_write_u64(bs, 0);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\t\tgf_bs_write_u64(bs, ptr->offsets_large[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err saio_Size(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox*)s;\n\n\tif (ptr->aux_info_type || ptr->aux_info_type_parameter) {\n\t\tptr->flags |= 1;\n\t}\n\tif (ptr->offsets_large) {\n\t\tptr->version = 1;\n\t}\n\n\tif (ptr->flags & 1) ptr->size += 8;\n\tptr->size += 4;\n\t//a little optim here: in cenc, the saio always points to a single data block, only one entry is needed\n\tswitch (ptr->aux_info_type) {\n\tcase GF_ISOM_CENC_SCHEME:\n\tcase GF_ISOM_CBC_SCHEME:\n\tcase GF_ISOM_CENS_SCHEME:\n\tcase GF_ISOM_CBCS_SCHEME:\n\t\tif (ptr->offsets_large) gf_free(ptr->offsets_large);\n\t\tif (ptr->offsets) gf_free(ptr->offsets);\n\t\tptr->offsets_large = NULL;\n\t\tptr->offsets = NULL;\n\t\tptr->entry_count = 1;\n\t\tbreak;\n\t}\n\n\tptr->size += ((ptr->version==1) ? 8 : 4) * ptr->entry_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\nvoid prft_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err prft_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox *) s;\n\n\tptr->refTrackID = gf_bs_read_u32(bs);\n\tptr->ntp = gf_bs_read_u64(bs);\n\tif (ptr->version==0) {\n\t\tptr->timestamp = gf_bs_read_u32(bs);\n\t} else {\n\t\tptr->timestamp = gf_bs_read_u64(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *prft_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProducerReferenceTimeBox, GF_ISOM_BOX_TYPE_PRFT);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err prft_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->refTrackID);\n\tgf_bs_write_u64(bs, ptr->ntp);\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, (u32) ptr->timestamp);\n\t} else {\n\t\tgf_bs_write_u64(bs, ptr->timestamp);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err prft_Size(GF_Box *s)\n{\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox*)s;\n\n\tptr->size += 4+8+ (ptr->version ? 8 : 4);\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *trgr_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackGroupBox, GF_ISOM_BOX_TYPE_TRGR);\n\ttmp->groups = gf_list_new();\n\tif (!tmp->groups) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\nvoid trgr_del(GF_Box *s)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_box_array_del(ptr->groups);\n\tgf_free(ptr);\n}\n\n\nGF_Err trgr_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\treturn gf_list_add(ptr->groups, a);\n}\n\n\nGF_Err trgr_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(s, bs, trgr_AddBox, s->type);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trgr_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\treturn gf_isom_box_array_write(s, ptr->groups, bs);\n}\n\nGF_Err trgr_Size(GF_Box *s)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\treturn gf_isom_box_array_size(s, ptr->groups);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *trgt_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackGroupTypeBox, GF_ISOM_BOX_TYPE_TRGT);\n\treturn (GF_Box *)tmp;\n}\n\nvoid trgt_del(GF_Box *s)\n{\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err trgt_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *)s;\n\tptr->track_group_id = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trgt_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\ts->type = ptr->group_type;\n\te = gf_isom_full_box_write(s, bs);\n\ts->type = GF_ISOM_BOX_TYPE_TRGT;\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->track_group_id);\n\treturn GF_OK;\n}\n\nGF_Err trgt_Size(GF_Box *s)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\n\tptr->size+= 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *stvi_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_StereoVideoBox, GF_ISOM_BOX_TYPE_STVI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid stvi_del(GF_Box *s)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->stereo_indication_type) gf_free(ptr->stereo_indication_type);\n\tgf_free(ptr);\n}\n\nGF_Err stvi_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 12);\n\tgf_bs_read_int(bs, 30);\n\tptr->single_view_allowed = gf_bs_read_int(bs, 2);\n\tptr->stereo_scheme = gf_bs_read_u32(bs);\n\tptr->sit_len = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, ptr->sit_len);\n\tptr->stereo_indication_type = gf_malloc(sizeof(char)*ptr->sit_len);\n\tgf_bs_read_data(bs, ptr->stereo_indication_type, ptr->sit_len);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stvi_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, 0, 30);\n\tgf_bs_write_int(bs, ptr->single_view_allowed, 2);\n\tgf_bs_write_u32(bs, ptr->stereo_scheme);\n\tgf_bs_write_u32(bs, ptr->sit_len);\n\tgf_bs_write_data(bs, ptr->stereo_indication_type, ptr->sit_len);\n\n\treturn GF_OK;\n}\n\nGF_Err stvi_Size(GF_Box *s)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\n\tptr->size+= 12 + ptr->sit_len;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *fiin_New()\n{\n\tISOM_DECL_BOX_ALLOC(FDItemInformationBox, GF_ISOM_BOX_TYPE_FIIN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fiin_del(GF_Box *s)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->partition_entries) gf_isom_box_array_del(ptr->partition_entries);\n\tif (ptr->session_info) gf_isom_box_del((GF_Box*)ptr->session_info);\n\tif (ptr->group_id_to_name) gf_isom_box_del((GF_Box*)ptr->group_id_to_name);\n\tgf_free(ptr);\n}\n\n\nGF_Err fiin_AddBox(GF_Box *s, GF_Box *a)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_PAEN:\n\t\tif (!ptr->partition_entries) ptr->partition_entries = gf_list_new();\n\t\treturn gf_list_add(ptr->partition_entries, a);\n\tcase GF_ISOM_BOX_TYPE_SEGR:\n\t\tif (ptr->session_info) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->session_info = (FDSessionGroupBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_GITN:\n\t\tif (ptr->group_id_to_name) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->group_id_to_name = (GroupIdToNameBox *)a;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fiin_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tgf_bs_read_u16(bs);\n\treturn gf_isom_box_array_read(s, bs, fiin_AddBox);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fiin_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tFDItemInformationBox *ptr = (FDItemInformationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, gf_list_count(ptr->partition_entries) );\n\te = gf_isom_box_array_write(s, ptr->partition_entries, bs);\n\tif (e) return e;\n\tif (ptr->session_info) gf_isom_box_write((GF_Box*)ptr->session_info, bs);\n\tif (ptr->group_id_to_name) gf_isom_box_write((GF_Box*)ptr->group_id_to_name, bs);\n\treturn GF_OK;\n}\n\nGF_Err fiin_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\n\tptr->size+= 2;\n\tif (ptr->partition_entries) {\n\t\te = gf_isom_box_array_size(s, ptr->partition_entries);\n\t\tif (e) return e;\n\t}\n\tif (ptr->session_info) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->session_info);\n\t\tif (e) return e;\n\t\tptr->size += ptr->session_info->size;\n\t}\n\tif (ptr->group_id_to_name) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->group_id_to_name);\n\t\tif (e) return e;\n\t\tptr->size += ptr->group_id_to_name->size;\n\t}\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *paen_New()\n{\n\tISOM_DECL_BOX_ALLOC(FDPartitionEntryBox, GF_ISOM_BOX_TYPE_PAEN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid paen_del(GF_Box *s)\n{\n\tFDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->blocks_and_symbols) gf_isom_box_del((GF_Box*)ptr->blocks_and_symbols);\n\tif (ptr->FEC_symbol_locations) gf_isom_box_del((GF_Box*)ptr->FEC_symbol_locations);\n\tif (ptr->File_symbol_locations) gf_isom_box_del((GF_Box*)ptr->File_symbol_locations);\n\tgf_free(ptr);\n}\n\n\nGF_Err paen_AddBox(GF_Box *s, GF_Box *a)\n{\n\tFDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_FPAR:\n\t\tif (ptr->blocks_and_symbols) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->blocks_and_symbols = (FilePartitionBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_FECR:\n\t\tif (ptr->FEC_symbol_locations) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->FEC_symbol_locations = (FECReservoirBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_FIRE:\n\t\tif (ptr->File_symbol_locations) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->File_symbol_locations = (FileReservoirBox *)a;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err paen_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, fiin_AddBox);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err paen_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tFDPartitionEntryBox *ptr = (FDPartitionEntryBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\tif (ptr->blocks_and_symbols) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->blocks_and_symbols, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->FEC_symbol_locations) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->FEC_symbol_locations, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->File_symbol_locations) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->File_symbol_locations, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err paen_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tFDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;\n\n\tif (ptr->blocks_and_symbols) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);\n\t\tif (e) return e;\n\t\tptr->size += ptr->blocks_and_symbols->size;\n\t}\n\tif (ptr->FEC_symbol_locations) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);\n\t\tif (e) return e;\n\t\tptr->size += ptr->FEC_symbol_locations->size;\n\t}\n\tif (ptr->File_symbol_locations) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);\n\t\tif (e) return e;\n\t\tptr->size += ptr->File_symbol_locations->size;\n\t}\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *fpar_New()\n{\n\tISOM_DECL_BOX_ALLOC(FilePartitionBox, GF_ISOM_BOX_TYPE_FPAR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fpar_del(GF_Box *s)\n{\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->scheme_specific_info) gf_free(ptr->scheme_specific_info);\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err gf_isom_read_null_terminated_string(GF_Box *s, GF_BitStream *bs, u64 size, char **out_str)\n{\n\tu32 len=10;\n\tu32 i=0;\n\n\t*out_str = gf_malloc(sizeof(char)*len);\n\twhile (1) {\n\t\tISOM_DECREASE_SIZE(s, 1 );\n\t\t(*out_str)[i] = gf_bs_read_u8(bs);\n\t\tif (!(*out_str)[i]) break;\n\t\ti++;\n\t\tif (i==len) {\n\t\t\tlen += 10;\n\t\t\t*out_str = gf_realloc(*out_str, sizeof(char)*len);\n\t\t}\n\t\tif (gf_bs_available(bs) == 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] missing null character in null terminated string\\n\"));\n\t\t\t(*out_str)[i] = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (i >= size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] string bigger than container, probably missing null character\\n\"));\n\t\t\t(*out_str)[i] = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fpar_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, ((ptr->version ? 4 : 2) + 12) );\n\tptr->itemID = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\tptr->packet_payload_size = gf_bs_read_u16(bs);\n\tgf_bs_read_u8(bs);\n\tptr->FEC_encoding_ID = gf_bs_read_u8(bs);\n\tptr->FEC_instance_ID = gf_bs_read_u16(bs);\n\tptr->max_source_block_length = gf_bs_read_u16(bs);\n\tptr->encoding_symbol_length = gf_bs_read_u16(bs);\n\tptr->max_number_of_encoding_symbols = gf_bs_read_u16(bs);\n\n\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->scheme_specific_info);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, (ptr->version ? 4 : 2) );\n\tptr->nb_entries = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries * 6 );\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, FilePartitionEntry);\n\tfor (i=0;i < ptr->nb_entries; i++) {\n\t\tptr->entries[i].block_count = gf_bs_read_u16(bs);\n\t\tptr->entries[i].block_size = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fpar_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tFilePartitionBox *ptr = (FilePartitionBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->itemID, ptr->version ? 32 : 16);\n\tgf_bs_write_u16(bs, ptr->packet_payload_size);\n\tgf_bs_write_u8(bs, 0);\n\tgf_bs_write_u8(bs, ptr->FEC_encoding_ID);\n\tgf_bs_write_u16(bs, ptr->FEC_instance_ID);\n\tgf_bs_write_u16(bs, ptr->max_source_block_length);\n\tgf_bs_write_u16(bs, ptr->encoding_symbol_length);\n\tgf_bs_write_u16(bs, ptr->max_number_of_encoding_symbols);\n\tif (ptr->scheme_specific_info) {\n\t\tgf_bs_write_data(bs, ptr->scheme_specific_info, (u32)strlen(ptr->scheme_specific_info) );\n\t}\n\t//null terminated string\n\tgf_bs_write_u8(bs, 0);\n\n\tgf_bs_write_int(bs, ptr->nb_entries, ptr->version ? 32 : 16);\n\n\tfor (i=0;i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u16(bs, ptr->entries[i].block_count);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].block_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fpar_Size(GF_Box *s)\n{\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\n\tptr->size+= 13 + ptr->version ? 8 : 4;\n\tif (ptr->scheme_specific_info)\n\t\tptr->size += strlen(ptr->scheme_specific_info);\n\n\tptr->size+= ptr->nb_entries * 6;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *fecr_New()\n{\n\tISOM_DECL_BOX_ALLOC(FECReservoirBox, GF_ISOM_BOX_TYPE_FECR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fecr_del(GF_Box *s)\n{\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err fecr_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, (ptr->version ? 4 : 2) );\n\tptr->nb_entries = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries * (ptr->version ? 8 : 6) );\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, FECReservoirEntry);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->entries[i].item_id = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\t\tptr->entries[i].symbol_count = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fecr_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tFECReservoirBox *ptr = (FECReservoirBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->nb_entries, ptr->version ? 32 : 16);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_int(bs, ptr->entries[i].item_id, ptr->version ? 32 : 16);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].symbol_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fecr_Size(GF_Box *s)\n{\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\tptr->size += (ptr->version ? 4 : 2) +  ptr->nb_entries * (ptr->version ? 8 : 6);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *segr_New()\n{\n\tISOM_DECL_BOX_ALLOC(FDSessionGroupBox, GF_ISOM_BOX_TYPE_SEGR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid segr_del(GF_Box *s)\n{\n\tu32 i;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tif (ptr->session_groups[i].group_ids) gf_free(ptr->session_groups[i].group_ids);\n\t\tif (ptr->session_groups[i].channels) gf_free(ptr->session_groups[i].channels);\n\t}\n\tif (ptr->session_groups) gf_free(ptr->session_groups);\n\tgf_free(ptr);\n}\n\nGF_Err segr_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, k;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->num_session_groups = gf_bs_read_u16(bs);\n\tif (ptr->num_session_groups*3>ptr->size) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in segr\\n\", ptr->num_session_groups));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tGF_SAFE_ALLOC_N(ptr->session_groups, ptr->num_session_groups, SessionGroupEntry);\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tptr->session_groups[i].nb_groups = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\t\tGF_SAFE_ALLOC_N(ptr->session_groups[i].group_ids, ptr->session_groups[i].nb_groups, u32);\n\t\tfor (k=0; k<ptr->session_groups[i].nb_groups; k++) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\t\tptr->session_groups[i].group_ids[k] = gf_bs_read_u32(bs);\n\t\t}\n\n\t\tptr->session_groups[i].nb_channels = gf_bs_read_u16(bs);\n\t\tGF_SAFE_ALLOC_N(ptr->session_groups[i].channels, ptr->session_groups[i].nb_channels, u32);\n\t\tfor (k=0; k<ptr->session_groups[i].nb_channels; k++) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\t\tptr->session_groups[i].channels[k] = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err segr_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, k;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\tgf_bs_write_u16(bs, ptr->num_session_groups);\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tgf_bs_write_u8(bs, ptr->session_groups[i].nb_groups);\n\t\tfor (k=0; k<ptr->session_groups[i].nb_groups; k++) {\n\t\t\tgf_bs_write_u32(bs, ptr->session_groups[i].group_ids[k]);\n\t\t}\n\n\t\tgf_bs_write_u16(bs, ptr->session_groups[i].nb_channels);\n\t\tfor (k=0; k<ptr->session_groups[i].nb_channels; k++) {\n\t\t\tgf_bs_write_u32(bs, ptr->session_groups[i].channels[k]);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err segr_Size(GF_Box *s)\n{\n\tu32 i;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\n\tptr->size += 2;\n\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tptr->size += 1 + 4*ptr->session_groups[i].nb_groups;\n\t\tptr->size += 2 + 4*ptr->session_groups[i].nb_channels;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *gitn_New()\n{\n\tISOM_DECL_BOX_ALLOC(GroupIdToNameBox, GF_ISOM_BOX_TYPE_GITN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid gitn_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t}\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err gitn_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->nb_entries = gf_bs_read_u16(bs);\n\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, GroupIdNameEntry);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->entries[i].group_id = gf_bs_read_u32(bs);\n\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->entries[i].name);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gitn_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].group_id);\n\t\tif (ptr->entries[i].name) gf_bs_write_data(bs, ptr->entries[i].name, (u32)strlen(ptr->entries[i].name) );\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gitn_Size(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tptr->size += 2;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->size += 5;\n\t\tif (ptr->entries[i].name) ptr->size += strlen(ptr->entries[i].name);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\nGF_Box *fdpa_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FDpacketBox, GF_ISOM_BOX_TYPE_FDPA);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fdpa_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->headers) {\n\t\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\t\tif (ptr->headers[i].data) gf_free(ptr->headers[i].data);\n\t\t}\n\t\tgf_free(ptr->headers);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err fdpa_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 3);\n\tptr->info.sender_current_time_present = gf_bs_read_int(bs, 1);\n\tptr->info.expected_residual_time_present = gf_bs_read_int(bs, 1);\n\tptr->info.session_close_bit = gf_bs_read_int(bs, 1);\n\tptr->info.object_close_bit = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 4);\n\tptr->info.transport_object_identifier = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->header_ext_count = gf_bs_read_u16(bs);\n\tif (ptr->header_ext_count*2>ptr->size) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in fdpa\\n\", ptr->header_ext_count));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tGF_SAFE_ALLOC_N(ptr->headers, ptr->header_ext_count, GF_LCTheaderExtension);\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tptr->headers[i].header_extension_type = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tgf_bs_read_data(bs, (char *) ptr->headers[i].content, 3);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1);\n\t\t\tptr->headers[i].data_length = gf_bs_read_u8(bs);\n\t\t\tif (ptr->headers[i].data_length) {\n\t\t\t\tptr->headers[i].data_length = 4*ptr->headers[i].data_length - 2;\n\t\t\t\tptr->headers[i].data = gf_malloc(sizeof(char) * ptr->headers[i].data_length);\n\t\t\t\tgf_bs_read_data(bs, ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fdpa_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\tgf_bs_write_int(bs, ptr->info.sender_current_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.expected_residual_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.session_close_bit, 1);\n\tgf_bs_write_int(bs, ptr->info.object_close_bit, 1);\n\tgf_bs_write_int(bs, 0, 4);\n\tptr->info.transport_object_identifier = gf_bs_read_u16(bs);\n\tgf_bs_write_u16(bs, ptr->header_ext_count);\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tgf_bs_write_u8(bs, ptr->headers[i].header_extension_type);\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tgf_bs_write_data(bs, (const char *) ptr->headers[i].content, 3);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, ptr->headers[i].data_length ? (ptr->headers[i].data_length+2)/4 : 0);\n\t\t\tif (ptr->headers[i].data_length) {\n\t\t\t\tgf_bs_write_data(bs, ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fdpa_Size(GF_Box *s)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\n\tptr->size += 5;\n\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tptr->size += 1;\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tptr->size += 3;\n\t\t} else {\n\t\t\tptr->size += 1 + ptr->headers[i].data_length;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *extr_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ExtraDataBox, GF_ISOM_BOX_TYPE_EXTR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid extr_del(GF_Box *s)\n{\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->feci) gf_isom_box_del((GF_Box*)ptr->feci);\n\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Err extr_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;\n\n\te = gf_isom_box_parse((GF_Box**) &ptr->feci, bs);\n\tif (e) return e;\n\tif (ptr->feci->size>ptr->size) return GF_ISOM_INVALID_MEDIA;\n\tptr->data_length = (u32) (ptr->size - ptr->feci->size);\n\tptr->data = gf_malloc(sizeof(char)*ptr->data_length);\n\tgf_bs_read_data(bs, ptr->data, ptr->data_length);\n\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err extr_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (ptr->feci) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->feci, bs);\n\t\tif (e) return e;\n\t}\n\tgf_bs_write_data(bs, ptr->data, ptr->data_length);\n\treturn GF_OK;\n}\n\nGF_Err extr_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *) s;\n\n\tif (ptr->feci) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->feci);\n\t\tif (e) return e;\n\t\tptr->size += ptr->feci->size;\n\t}\n\tptr->size += ptr->data_length;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *fdsa_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintSample, GF_ISOM_BOX_TYPE_FDSA);\n\tif (!tmp) return NULL;\n\ttmp->packetTable = gf_list_new();\n\ttmp->hint_subtype = GF_ISOM_BOX_TYPE_FDP_STSD;\n\treturn (GF_Box*)tmp;\n}\n\nvoid fdsa_del(GF_Box *s)\n{\n\tGF_HintSample *ptr = (GF_HintSample *)s;\n\tgf_isom_box_array_del(ptr->packetTable);\n\tif (ptr->extra_data) gf_isom_box_del((GF_Box*)ptr->extra_data);\n\tgf_free(ptr);\n}\n\nGF_Err fdsa_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_HintSample *ptr = (GF_HintSample *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_FDPA:\n\t\tgf_list_add(ptr->packetTable, a);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_EXTR:\n\t\tif (ptr->extra_data) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->extra_data = (GF_ExtraDataBox*)a;\n\t\tbreak;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\nGF_Err fdsa_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, fdsa_AddBox);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fdsa_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HintSample *ptr = (GF_HintSample *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_array_write(s, ptr->packetTable, bs);\n\tif (e) return e;\n\tif (ptr->extra_data) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->extra_data, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fdsa_Size(GF_Box *s)\n{\n\tGF_HintSample *ptr = (GF_HintSample*)s;\n\tGF_Err e;\n\n\t if (ptr->extra_data) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->extra_data);\n\t\tif (e) return e;\n\t\tptr->size += ptr->extra_data->size;\n\t}\n\treturn gf_isom_box_array_size(s, ptr->packetTable);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\n\nvoid trik_del(GF_Box *s)\n{\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err trik_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tptr->entry_count = (u32) ptr->size;\n\tptr->entries = (GF_TrickPlayBoxEntry *) gf_malloc(ptr->entry_count * sizeof(GF_TrickPlayBoxEntry) );\n\tif (ptr->entries == NULL) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i< ptr->entry_count; i++) {\n\t\tptr->entries[i].pic_type = gf_bs_read_int(bs, 2);\n\t\tptr->entries[i].dependency_level = gf_bs_read_int(bs, 6);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *trik_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrickPlayBox, GF_ISOM_BOX_TYPE_TRIK);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trik_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tfor (i=0; i < ptr->entry_count; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->entries[i].pic_type, 2);\n\t\tgf_bs_write_int(bs, ptr->entries[i].dependency_level, 6);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err trik_Size(GF_Box *s)\n{\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tptr->size += 8 * ptr->entry_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid bloc_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err bloc_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_BaseLocationBox *ptr = (GF_BaseLocationBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 256)\n\tgf_bs_read_data(bs, (char *) ptr->baseLocation, 256);\n\tISOM_DECREASE_SIZE(s, 256)\n\tgf_bs_read_data(bs, (char *) ptr->basePurlLocation, 256);\n\tISOM_DECREASE_SIZE(s, 512)\n\tgf_bs_skip_bytes(bs, 512);\n\treturn GF_OK;\n}\n\nGF_Box *bloc_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_BaseLocationBox, GF_ISOM_BOX_TYPE_TRIK);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err bloc_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_BaseLocationBox *ptr = (GF_BaseLocationBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, (const char *) ptr->baseLocation, 256);\n\tgf_bs_write_data(bs, (const char *) ptr->basePurlLocation, 256);\n\tfor (i=0; i < 64; i++ ) {\n\t\tgf_bs_write_u64(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err bloc_Size(GF_Box *s)\n{\n\ts->size += 1024;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ainf_del(GF_Box *s)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\tif (ptr->APID) gf_free(ptr->APID);\n\tgf_free(s);\n}\n\nGF_Err ainf_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 4)\n\tptr->profile_version = gf_bs_read_u32(bs);\n\treturn gf_isom_read_null_terminated_string(s, bs, s->size, &ptr->APID);\n}\n\nGF_Box *ainf_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AssetInformationBox, GF_ISOM_BOX_TYPE_AINF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ainf_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->profile_version);\n\tgf_bs_write_data(bs, ptr->APID, (u32) strlen(ptr->APID) + 1);\n\treturn GF_OK;\n}\n\nGF_Err ainf_Size(GF_Box *s)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\ts->size += 4 +  strlen(ptr->APID) + 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/utf.h>\n#include <gpac/network.h>\n#include <gpac/color.h>\n#include <gpac/avparse.h>\n#include <time.h>\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\n\nstatic void dump_data(FILE *trace, char *data, u32 dataLength)\n{\n\tu32 i;\n\tfprintf(trace, \"data:application/octet-string,\");\n\tfor (i=0; i<dataLength; i++) {\n\t\tfprintf(trace, \"%02X\", (unsigned char) data[i]);\n\t}\n}\n\nstatic void dump_data_hex(FILE *trace, char *data, u32 dataLength)\n{\n\tu32 i;\n\tfprintf(trace, \"0x\");\n\tfor (i=0; i<dataLength; i++) {\n\t\tfprintf(trace, \"%02X\", (unsigned char) data[i]);\n\t}\n}\n\nstatic void dump_data_attribute(FILE *trace, char *name, char *data, u32 data_size)\n{\n\tu32 i;\n\tif (!data || !data_size) {\n\t\tfprintf(trace, \"%s=\\\"\\\"\", name);\n\t\treturn;\n\t}\n\tfprintf(trace, \"%s=\\\"0x\", name);\n\tfor (i=0; i<data_size; i++) fprintf(trace, \"%02X\", (unsigned char) data[i]);\n\tfprintf(trace, \"\\\" \");\n}\n\nstatic void dump_data_string(FILE *trace, char *data, u32 dataLength)\n{\n\tu32 i;\n\tfor (i=0; i<dataLength; i++) {\n\t\tswitch ((unsigned char) data[i]) {\n\t\tcase '\\'':\n\t\t\tfprintf(trace, \"&apos;\");\n\t\t\tbreak;\n\t\tcase '\\\"':\n\t\t\tfprintf(trace, \"&quot;\");\n\t\t\tbreak;\n\t\tcase '&':\n\t\t\tfprintf(trace, \"&amp;\");\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tfprintf(trace, \"&gt;\");\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tfprintf(trace, \"&lt;\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(trace, \"%c\", (u8) data[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nGF_Err gf_isom_box_dump(void *ptr, FILE * trace)\n{\n\treturn gf_isom_box_dump_ex(ptr, trace, 0);\n}\n\nGF_Err gf_isom_box_array_dump(GF_List *list, FILE * trace)\n{\n\tu32 i;\n\tGF_Box *a;\n\tif (!list) return GF_OK;\n\ti=0;\n\twhile ((a = (GF_Box *)gf_list_enum(list, &i))) {\n\t\tgf_isom_box_dump(a, trace);\n\t}\n\treturn GF_OK;\n}\n\nextern Bool use_dump_mode;\n\nGF_EXPORT\nGF_Err gf_isom_dump(GF_ISOFile *mov, FILE * trace)\n{\n\tu32 i;\n\tGF_Box *box;\n\tif (!mov || !trace) return GF_BAD_PARAM;\n\n\tuse_dump_mode = mov->dump_mode_alloc;\n\tfprintf(trace, \"<!--MP4Box dump trace-->\\n\");\n\n\tfprintf(trace, \"<IsoMediaFile xmlns=\\\"urn:mpeg:isobmff:schema:file:2016\\\" Name=\\\"%s\\\">\\n\", mov->fileName);\n\n\ti=0;\n\twhile ((box = (GF_Box *)gf_list_enum(mov->TopBoxes, &i))) {\n\t\tif (box->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\tfprintf(trace, \"<!--WARNING: Unknown Top-level Box Found -->\\n\");\n\t\t} else if (box->type==GF_ISOM_BOX_TYPE_UUID) {\n\t\t} else if (!gf_isom_box_is_file_level(box)) {\n\t\t\tfprintf(trace, \"<!--ERROR: Invalid Top-level Box Found (\\\"%s\\\")-->\\n\", gf_4cc_to_str(box->type));\n\t\t}\n\t\tgf_isom_box_dump(box, trace);\n\t}\n\tfprintf(trace, \"</IsoMediaFile>\\n\");\n\treturn GF_OK;\n}\n\nGF_Err reftype_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_TrackReferenceTypeBox *p = (GF_TrackReferenceTypeBox *)a;\n\tif (!p->reference_type) return GF_OK;\n\tp->type = p->reference_type;\n\n\tgf_isom_box_dump_start(a, \"TrackReferenceTypeBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tfor (i=0; i<p->trackIDCount; i++) {\n\t\tfprintf(trace, \"<TrackReferenceEntry TrackID=\\\"%d\\\"/>\\n\", p->trackIDs[i]);\n\t}\n\tif (!p->size)\n\t\tfprintf(trace, \"<TrackReferenceEntry TrackID=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"TrackReferenceTypeBox\", a, trace);\n\tp->type = GF_ISOM_BOX_TYPE_REFT;\n\treturn GF_OK;\n}\n\nGF_Err ireftype_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_ItemReferenceTypeBox *p = (GF_ItemReferenceTypeBox *)a;\n\tif (!p->reference_type) return GF_OK;\n\n\tp->type = p->reference_type;\n\tgf_isom_box_dump_start(a, \"ItemReferenceBox\", trace);\n\tfprintf(trace, \"from_item_id=\\\"%d\\\">\\n\", p->from_item_id);\n\tfor (i = 0; i < p->reference_count; i++) {\n\t\tfprintf(trace, \"<ItemReferenceBoxEntry ItemID=\\\"%d\\\"/>\\n\", p->to_item_IDs[i]);\n\t}\n\tif (!p->size)\n\t\tfprintf(trace, \"<ItemReferenceBoxEntry ItemID=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"ItemReferenceBox\", a, trace);\n\n\tp->type = GF_ISOM_BOX_TYPE_REFI;\n\treturn GF_OK;\n}\n\nGF_Err free_dump(GF_Box *a, FILE * trace)\n{\n\tGF_FreeSpaceBox *p = (GF_FreeSpaceBox *)a;\n\tgf_isom_box_dump_start(a, (a->type==GF_ISOM_BOX_TYPE_FREE) ? \"FreeSpaceBox\" : \"SkipBox\", trace);\n\tfprintf(trace, \"dataSize=\\\"%d\\\">\\n\", p->dataSize);\n\tgf_isom_box_dump_done( (a->type==GF_ISOM_BOX_TYPE_FREE) ? \"FreeSpaceBox\" : \"SkipBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err mdat_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MediaDataBox *p;\n\tconst char *name = (a->type==GF_ISOM_BOX_TYPE_IDAT ? \"ItemDataBox\" : \"MediaDataBox\");\n\tp = (GF_MediaDataBox *)a;\n\tgf_isom_box_dump_start(a, name, trace);\n\tfprintf(trace, \"dataSize=\\\"\"LLD\"\\\">\\n\", LLD_CAST p->dataSize);\n\tgf_isom_box_dump_done(name, a, trace);\n\treturn GF_OK;\n}\n\nGF_Err moov_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MovieBox *p;\n\tp = (GF_MovieBox *)a;\n\tgf_isom_box_dump_start(a, \"MovieBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->iods) gf_isom_box_dump(p->iods, trace);\n\tif (p->meta) gf_isom_box_dump(p->meta, trace);\n\t//dump only if size\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->mvhd, trace,GF_ISOM_BOX_TYPE_MVHD);\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (p->mvex) gf_isom_box_dump(p->mvex, trace);\n#endif\n\n\tgf_isom_box_array_dump(p->trackList, trace);\n\tif (p->udta) gf_isom_box_dump(p->udta, trace);\n\tgf_isom_box_dump_done(\"MovieBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err mvhd_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MovieHeaderBox *p;\n\n\tp = (GF_MovieHeaderBox *) a;\n\n\tgf_isom_box_dump_start(a, \"MovieHeaderBox\", trace);\n\tfprintf(trace, \"CreationTime=\\\"\"LLD\"\\\" \", LLD_CAST p->creationTime);\n\tfprintf(trace, \"ModificationTime=\\\"\"LLD\"\\\" \", LLD_CAST p->modificationTime);\n\tfprintf(trace, \"TimeScale=\\\"%d\\\" \", p->timeScale);\n\tfprintf(trace, \"Duration=\\\"\"LLD\"\\\" \", LLD_CAST p->duration);\n\tfprintf(trace, \"NextTrackID=\\\"%d\\\">\\n\", p->nextTrackID);\n\n\tgf_isom_box_dump_done(\"MovieHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err mdhd_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MediaHeaderBox *p;\n\n\tp = (GF_MediaHeaderBox *)a;\n\tgf_isom_box_dump_start(a, \"MediaHeaderBox\", trace);\n\tfprintf(trace, \"CreationTime=\\\"\"LLD\"\\\" \", LLD_CAST p->creationTime);\n\tfprintf(trace, \"ModificationTime=\\\"\"LLD\"\\\" \", LLD_CAST p->modificationTime);\n\tfprintf(trace, \"TimeScale=\\\"%d\\\" \", p->timeScale);\n\tfprintf(trace, \"Duration=\\\"\"LLD\"\\\" \", LLD_CAST p->duration);\n\tfprintf(trace, \"LanguageCode=\\\"%c%c%c\\\">\\n\", p->packedLanguage[0], p->packedLanguage[1], p->packedLanguage[2]);\n\tgf_isom_box_dump_done(\"MediaHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err vmhd_dump(GF_Box *a, FILE * trace)\n{\n\tgf_isom_box_dump_start(a, \"VideoMediaHeaderBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"VideoMediaHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err smhd_dump(GF_Box *a, FILE * trace)\n{\n\tgf_isom_box_dump_start(a, \"SoundMediaHeaderBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"SoundMediaHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err hmhd_dump(GF_Box *a, FILE * trace)\n{\n\tGF_HintMediaHeaderBox *p;\n\n\tp = (GF_HintMediaHeaderBox *)a;\n\n\tgf_isom_box_dump_start(a, \"HintMediaHeaderBox\", trace);\n\tfprintf(trace, \"MaximumPDUSize=\\\"%d\\\" \", p->maxPDUSize);\n\tfprintf(trace, \"AveragePDUSize=\\\"%d\\\" \", p->avgPDUSize);\n\tfprintf(trace, \"MaxBitRate=\\\"%d\\\" \", p->maxBitrate);\n\tfprintf(trace, \"AverageBitRate=\\\"%d\\\">\\n\", p->avgBitrate);\n\n\tgf_isom_box_dump_done(\"HintMediaHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err nmhd_dump(GF_Box *a, FILE * trace)\n{\n\tgf_isom_box_dump_start(a, \"MPEGMediaHeaderBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"MPEGMediaHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stbl_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SampleTableBox *p;\n\tp = (GF_SampleTableBox *)a;\n\tgf_isom_box_dump_start(a, \"SampleTableBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->SampleDescription, trace, GF_ISOM_BOX_TYPE_STSD);\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->TimeToSample, trace, GF_ISOM_BOX_TYPE_STTS);\n\n\tif (p->CompositionOffset) gf_isom_box_dump(p->CompositionOffset, trace);\n\tif (p->CompositionToDecode) gf_isom_box_dump(p->CompositionToDecode, trace);\n\tif (p->SyncSample) gf_isom_box_dump(p->SyncSample, trace);\n\tif (p->ShadowSync) gf_isom_box_dump(p->ShadowSync, trace);\n\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->SampleToChunk, trace, GF_ISOM_BOX_TYPE_STSC);\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->SampleSize, trace, GF_ISOM_BOX_TYPE_STSZ);\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->ChunkOffset, trace, GF_ISOM_BOX_TYPE_STCO);\n\n\tif (p->DegradationPriority) gf_isom_box_dump(p->DegradationPriority, trace);\n\tif (p->SampleDep) gf_isom_box_dump(p->SampleDep, trace);\n\tif (p->PaddingBits) gf_isom_box_dump(p->PaddingBits, trace);\n\tif (p->Fragments) gf_isom_box_dump(p->Fragments, trace);\n\tif (p->sub_samples) gf_isom_box_array_dump(p->sub_samples, trace);\n\tif (p->sampleGroupsDescription) gf_isom_box_array_dump(p->sampleGroupsDescription, trace);\n\tif (p->sampleGroups) gf_isom_box_array_dump(p->sampleGroups, trace);\n\tif (p->sai_sizes) {\n\t\tu32 i;\n\t\tfor (i = 0; i < gf_list_count(p->sai_sizes); i++) {\n\t\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(p->sai_sizes, i);\n\t\t\tgf_isom_box_dump(saiz, trace);\n\t\t}\n\t}\n\n\tif (p->sai_offsets) {\n\t\tu32 i;\n\t\tfor (i = 0; i < gf_list_count(p->sai_offsets); i++) {\n\t\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(p->sai_offsets, i);\n\t\t\tgf_isom_box_dump(saio, trace);\n\t\t}\n\t}\n\n\tgf_isom_box_dump_done(\"SampleTableBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err dinf_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DataInformationBox *p;\n\tp = (GF_DataInformationBox *)a;\n\tgf_isom_box_dump_start(a, \"DataInformationBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->dref, trace, GF_ISOM_BOX_TYPE_DREF);\n\n\tgf_isom_box_dump_done(\"DataInformationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err url_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DataEntryURLBox *p;\n\n\tp = (GF_DataEntryURLBox *)a;\n\tgf_isom_box_dump_start(a, \"URLDataEntryBox\", trace);\n\tif (p->location) {\n\t\tfprintf(trace, \" URL=\\\"%s\\\">\\n\", p->location);\n\t} else {\n\t\tfprintf(trace, \">\\n\");\n\t\tif (p->size) {\n\t\t\tif (! (p->flags & 1) ) {\n\t\t\t\tfprintf(trace, \"<!--ERROR: No location indicated-->\\n\");\n\t\t\t} else {\n\t\t\t\tfprintf(trace, \"<!--Data is contained in the movie file-->\\n\");\n\t\t\t}\n\t\t}\n\t}\n\tgf_isom_box_dump_done(\"URLDataEntryBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err urn_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DataEntryURNBox *p;\n\n\tp = (GF_DataEntryURNBox *)a;\n\tgf_isom_box_dump_start(a, \"URNDataEntryBox\", trace);\n\tif (p->nameURN) fprintf(trace, \" URN=\\\"%s\\\"\", p->nameURN);\n\tif (p->location) fprintf(trace, \" URL=\\\"%s\\\"\", p->location);\n\tfprintf(trace, \">\\n\");\n\n\tgf_isom_box_dump_done(\"URNDataEntryBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err cprt_dump(GF_Box *a, FILE * trace)\n{\n\tGF_CopyrightBox *p;\n\n\tp = (GF_CopyrightBox *)a;\n\tgf_isom_box_dump_start(a, \"CopyrightBox\", trace);\n\tfprintf(trace, \"LanguageCode=\\\"%s\\\" CopyrightNotice=\\\"%s\\\">\\n\", p->packedLanguageCode, p->notice);\n\tgf_isom_box_dump_done(\"CopyrightBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err kind_dump(GF_Box *a, FILE * trace)\n{\n\tGF_KindBox *p;\n\n\tp = (GF_KindBox *)a;\n\tgf_isom_box_dump_start(a, \"KindBox\", trace);\n\tfprintf(trace, \"schemeURI=\\\"%s\\\" value=\\\"%s\\\">\\n\", p->schemeURI, (p->value ? p->value : \"\"));\n\tgf_isom_box_dump_done(\"KindBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nstatic char *format_duration(u64 dur, u32 timescale, char *szDur)\n{\n\tu32 h, m, s, ms;\n\tdur = (u32) (( ((Double) (s64) dur)/timescale)*1000);\n\th = (u32) (dur / 3600000);\n\tdur -= h*3600000;\n\tm = (u32) (dur / 60000);\n\tdur -= m*60000;\n\ts = (u32) (dur/1000);\n\tdur -= s*1000;\n\tms = (u32) (dur);\n\tsprintf(szDur, \"%02d:%02d:%02d.%03d\", h, m, s, ms);\n\treturn szDur;\n}\n\nstatic void dump_escape_string(FILE * trace, char *name)\n{\n\tu32 i, len = (u32) strlen(name);\n\tfor (i=0; i<len; i++) {\n\t\tif (name[i]=='\"') fprintf(trace, \"&quot;\");\n\t\telse fputc(name[i], trace);\n\t}\n}\n\nGF_Err chpl_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i, count;\n\tchar szDur[20];\n\tGF_ChapterListBox *p = (GF_ChapterListBox *)a;\n\tgf_isom_box_dump_start(a, \"ChapterListBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\tif (p->size) {\n\t\tcount = gf_list_count(p->list);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(p->list, i);\n\t\t\tfprintf(trace, \"<Chapter name=\\\"\");\n\t\t\tdump_escape_string(trace, ce->name);\n\t\t\tfprintf(trace, \"\\\" startTime=\\\"%s\\\" />\\n\", format_duration(ce->start_time, 1000*10000, szDur));\n\t\t}\n\t} else {\n\t\tfprintf(trace, \"<Chapter name=\\\"\\\" startTime=\\\"\\\"/>\\n\");\n\t}\n\n\tgf_isom_box_dump_done(\"ChapterListBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err pdin_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_ProgressiveDownloadBox *p = (GF_ProgressiveDownloadBox *)a;\n\tgf_isom_box_dump_start(a, \"ProgressiveDownloadBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\tif (p->size) {\n\t\tfor (i=0; i<p->count; i++) {\n\t\t\tfprintf(trace, \"<DownloadInfo rate=\\\"%d\\\" estimatedTime=\\\"%d\\\" />\\n\", p->rates[i], p->times[i]);\n\t\t}\n\t} else {\n\t\tfprintf(trace, \"<DownloadInfo rate=\\\"\\\" estimatedTime=\\\"\\\" />\\n\");\n\t}\n\tgf_isom_box_dump_done(\"ProgressiveDownloadBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err hdlr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_HandlerBox *p = (GF_HandlerBox *)a;\n\tgf_isom_box_dump_start(a, \"HandlerBox\", trace);\n\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n\t} else {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n\t}\n\tfprintf(trace, \"reserved1=\\\"%d\\\" reserved2=\\\"\", p->reserved1);\n\tdump_data(trace, (char *) p->reserved2, 12);\n\tfprintf(trace, \"\\\"\");\n\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HandlerBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err iods_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ObjectDescriptorBox *p;\n\n\tp = (GF_ObjectDescriptorBox *)a;\n\tgf_isom_box_dump_start(a, \"ObjectDescriptorBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\tif (p->descriptor) {\n#ifndef GPAC_DISABLE_OD_DUMP\n\t\tgf_odf_dump_desc(p->descriptor, trace, 1, GF_TRUE);\n#else\n\t\tfprintf(trace, \"<!-- Object Descriptor Dumping disabled in this build of GPAC -->\\n\");\n#endif\n\t} else if (p->size) {\n\t\tfprintf(trace, \"<!--WARNING: Object Descriptor not present-->\\n\");\n\t}\n\tgf_isom_box_dump_done(\"ObjectDescriptorBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err trak_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackBox *p;\n\n\tp = (GF_TrackBox *)a;\n\tgf_isom_box_dump_start(a, \"TrackBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->Header) {\n\t\tgf_isom_box_dump(p->Header, trace);\n\t} else if (p->size) {\n\t\tfprintf(trace, \"<!--INVALID FILE: Missing Track Header-->\\n\");\n\t}\n\tif (p->References) gf_isom_box_dump(p->References, trace);\n\tif (p->meta) gf_isom_box_dump(p->meta, trace);\n\tif (p->editBox) gf_isom_box_dump(p->editBox, trace);\n\tif (p->Media) gf_isom_box_dump(p->Media, trace);\n\tif (p->groups) gf_isom_box_dump(p->groups, trace);\n\tif (p->udta) gf_isom_box_dump(p->udta, trace);\n\tgf_isom_box_dump_done(\"TrackBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err mp4s_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MPEGSampleEntryBox *p;\n\n\tp = (GF_MPEGSampleEntryBox *)a;\n\tgf_isom_box_dump_start(a, \"MPEGSystemsSampleDescriptionBox\", trace);\n\tfprintf(trace, \"DataReferenceIndex=\\\"%d\\\">\\n\", p->dataReferenceIndex);\n\tif (p->esd) {\n\t\tgf_isom_box_dump(p->esd, trace);\n\t} else if (p->size) {\n\t\tfprintf(trace, \"<!--INVALID MP4 FILE: ESDBox not present in MPEG Sample Description or corrupted-->\\n\");\n\t}\n\tif (a->type == GF_ISOM_BOX_TYPE_ENCS) {\n\t\tgf_isom_box_array_dump(p->protections, trace);\n\t}\n\tgf_isom_box_dump_done(\"MPEGSystemsSampleDescriptionBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err video_sample_entry_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MPEGVisualSampleEntryBox *p = (GF_MPEGVisualSampleEntryBox *)a;\n\tconst char *name;\n\n\tswitch (p->type) {\n\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tname = \"AVCSampleEntryBox\";\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\tname = \"MVCSampleEntryBox\";\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\tname = \"SVCSampleEntryBox\";\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_HVC1:\n\tcase GF_ISOM_SUBTYPE_HEV1:\n\tcase GF_ISOM_SUBTYPE_HVC2:\n\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\tname = \"HEVCSampleEntryBox\";\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_LHV1:\n\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\tname = \"LHEVCSampleEntryBox\";\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tname = \"H263SampleDescriptionBox\";\n\t\tbreak;\n\tdefault:\n\t\tname = \"MPEGVisualSampleDescriptionBox\";\n\t}\n\n\tgf_isom_box_dump_start(a, name, trace);\n\n\tfprintf(trace, \" DataReferenceIndex=\\\"%d\\\" Width=\\\"%d\\\" Height=\\\"%d\\\"\", p->dataReferenceIndex, p->Width, p->Height);\n\n\t//dump reserved info\n\tfprintf(trace, \" XDPI=\\\"%d\\\" YDPI=\\\"%d\\\" BitDepth=\\\"%d\\\"\", p->horiz_res, p->vert_res, p->bit_depth);\n\tif (strlen((const char*)p->compressor_name) )\n\t\tfprintf(trace, \" CompressorName=\\\"%s\\\"\\n\", p->compressor_name+1);\n\n\n\tfprintf(trace, \">\\n\");\n\n\tif (p->esd) {\n\t\tgf_isom_box_dump(p->esd, trace);\n\t} else {\n\t\tif (p->hevc_config) gf_isom_box_dump(p->hevc_config, trace);\n\t\tif (p->avc_config) gf_isom_box_dump(p->avc_config, trace);\n\t\tif (p->ipod_ext) gf_isom_box_dump(p->ipod_ext, trace);\n\t\tif (p->descr) gf_isom_box_dump(p->descr, trace);\n\t\tif (p->svc_config) gf_isom_box_dump(p->svc_config, trace);\n\t\tif (p->mvc_config) gf_isom_box_dump(p->mvc_config, trace);\n\t\tif (p->lhvc_config) gf_isom_box_dump(p->lhvc_config, trace);\n\t\tif (p->cfg_3gpp) gf_isom_box_dump(p->cfg_3gpp, trace);\n\t}\n\tif (a->type == GF_ISOM_BOX_TYPE_ENCV) {\n\t\tgf_isom_box_array_dump(p->protections, trace);\n\t}\n\tif (p->pasp) gf_isom_box_dump(p->pasp, trace);\n\tif (p->rvcc) gf_isom_box_dump(p->rvcc, trace);\n\tif (p->rinf) gf_isom_box_dump(p->rinf, trace);\n\n\tgf_isom_box_dump_done(name, a, trace);\n\treturn GF_OK;\n}\n\n\nvoid base_audio_entry_dump(GF_AudioSampleEntryBox *p, FILE * trace)\n{\n\tfprintf(trace, \" DataReferenceIndex=\\\"%d\\\" SampleRate=\\\"%d\\\"\", p->dataReferenceIndex, p->samplerate_hi);\n\tfprintf(trace, \" Channels=\\\"%d\\\" BitsPerSample=\\\"%d\\\"\", p->channel_count, p->bitspersample);\n}\n\nGF_Err audio_sample_entry_dump(GF_Box *a, FILE * trace)\n{\n\tchar *szName;\n\tBool is_3gpp = GF_FALSE;\n\tGF_MPEGAudioSampleEntryBox *p = (GF_MPEGAudioSampleEntryBox *)a;\n\n\tswitch (p->type) {\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\tszName = \"AMRSampleDescriptionBox\";\n\t\tis_3gpp = GF_TRUE;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\tszName = \"AMR_WB_SampleDescriptionBox\";\n\t\tis_3gpp = GF_TRUE;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tszName = \"EVRCSampleDescriptionBox\";\n\t\tis_3gpp = GF_TRUE;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\tszName = \"QCELPSampleDescriptionBox\";\n\t\tis_3gpp = GF_TRUE;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tszName = \"SMVSampleDescriptionBox\";\n\t\tis_3gpp = GF_TRUE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tszName = \"MPEGAudioSampleDescriptionBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AC3:\n\t\tszName = \"AC3SampleEntryBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_EC3:\n\t\tszName = \"EC3SampleEntryBox\";\n\t\tbreak;\n\tdefault:\n\t\tszName = \"AudioSampleDescriptionBox\";\n\t\tbreak;\n\t}\n\n\tgf_isom_box_dump_start(a, szName, trace);\n\tbase_audio_entry_dump((GF_AudioSampleEntryBox *)p, trace);\n\tfprintf(trace, \">\\n\");\n\n\tif (p->esd) {\n\t\tgf_isom_box_dump(p->esd, trace);\n\t} else if (p->cfg_3gpp) {\n\t\tgf_isom_box_dump(p->cfg_3gpp, trace);\n\n\t} else if (p->cfg_ac3) {\n\t\tif (p->size)\n\t\t\tgf_isom_box_dump(p->cfg_ac3, trace);\n\n\t} else if (p->size) {\n\t\tif (is_3gpp) {\n\t\t\tfprintf(trace, \"<!-- INVALID 3GPP FILE: Config not present in Sample Description-->\\n\");\n\t\t} else {\n\t\t\tfprintf(trace, \"<!--INVALID MP4 FILE: ESDBox not present in MPEG Sample Description or corrupted-->\\n\");\n\t\t}\n\t}\n\tif (a->type == GF_ISOM_BOX_TYPE_ENCA) {\n\t\tgf_isom_box_array_dump(p->protections, trace);\n\t}\n\tgf_isom_box_dump_done(szName, a, trace);\n\treturn GF_OK;\n}\n\nGF_Err gnrm_dump(GF_Box *a, FILE * trace)\n{\n\tGF_GenericSampleEntryBox *p = (GF_GenericSampleEntryBox *)a;\n\tif (p->EntryType)\n\t\ta->type = p->EntryType;\n\n\tgf_isom_box_dump_start(a, \"SampleDescriptionBox\", trace);\n\tfprintf(trace, \"DataReferenceIndex=\\\"%d\\\" ExtensionDataSize=\\\"%d\\\">\\n\", p->dataReferenceIndex, p->data_size);\n\ta->type = GF_ISOM_BOX_TYPE_GNRM;\n\tgf_isom_box_dump_done(\"SampleDescriptionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err gnrv_dump(GF_Box *a, FILE * trace)\n{\n\tGF_GenericVisualSampleEntryBox *p = (GF_GenericVisualSampleEntryBox *)a;\n\tif (p->EntryType)\n\t\ta->type = p->EntryType;\n\n\tgf_isom_box_dump_start(a, \"VisualSampleDescriptionBox\", trace);\n\tfprintf(trace, \"DataReferenceIndex=\\\"%d\\\" Version=\\\"%d\\\" Revision=\\\"%d\\\" Vendor=\\\"%d\\\" TemporalQuality=\\\"%d\\\" SpacialQuality=\\\"%d\\\" Width=\\\"%d\\\" Height=\\\"%d\\\" HorizontalResolution=\\\"%d\\\" VerticalResolution=\\\"%d\\\" CompressorName=\\\"%s\\\" BitDepth=\\\"%d\\\">\\n\",\n\t        p->dataReferenceIndex, p->version, p->revision, p->vendor, p->temporal_quality, p->spatial_quality, p->Width, p->Height, p->horiz_res, p->vert_res, p->compressor_name+1, p->bit_depth);\n\ta->type = GF_ISOM_BOX_TYPE_GNRV;\n\tgf_isom_box_dump_done(\"VisualSampleDescriptionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err gnra_dump(GF_Box *a, FILE * trace)\n{\n\tGF_GenericAudioSampleEntryBox *p = (GF_GenericAudioSampleEntryBox *)a;\n\tif (p->EntryType)\n\t\ta->type = p->EntryType;\n\n\tgf_isom_box_dump_start(a, \"AudioSampleDescriptionBox\", trace);\n\tfprintf(trace, \"DataReferenceIndex=\\\"%d\\\" Version=\\\"%d\\\" Revision=\\\"%d\\\" Vendor=\\\"%d\\\" ChannelCount=\\\"%d\\\" BitsPerSample=\\\"%d\\\" Samplerate=\\\"%d\\\">\\n\",\n\t        p->dataReferenceIndex, p->version, p->revision, p->vendor, p->channel_count, p->bitspersample, p->samplerate_hi);\n\ta->type = GF_ISOM_BOX_TYPE_GNRA;\n\tgf_isom_box_dump_done(\"AudioSampleDescriptionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err edts_dump(GF_Box *a, FILE * trace)\n{\n\tGF_EditBox *p;\n\n\tp = (GF_EditBox *)a;\n\tgf_isom_box_dump_start(a, \"EditBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->editList, trace, GF_ISOM_BOX_TYPE_ELST);\n\tgf_isom_box_dump_done(\"EditBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err udta_dump(GF_Box *a, FILE * trace)\n{\n\tGF_UserDataBox *p;\n\tGF_UserDataMap *map;\n\tu32 i;\n\n\tp = (GF_UserDataBox *)a;\n\tgf_isom_box_dump_start(a, \"UserDataBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(p->recordList, &i))) {\n\t\tgf_isom_box_array_dump(map->other_boxes, trace);\n\t}\n\tgf_isom_box_dump_done(\"UserDataBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err dref_dump(GF_Box *a, FILE * trace)\n{\n//\tGF_DataReferenceBox *p = (GF_DataReferenceBox *)a;\n\tgf_isom_box_dump_start(a, \"DataReferenceBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"DataReferenceBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stsd_dump(GF_Box *a, FILE * trace)\n{\n//\tGF_SampleDescriptionBox *p = (GF_SampleDescriptionBox *)a;\n\tgf_isom_box_dump_start(a, \"SampleDescriptionBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"SampleDescriptionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stts_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TimeToSampleBox *p;\n\tu32 i, nb_samples;\n\n\tp = (GF_TimeToSampleBox *)a;\n\tgf_isom_box_dump_start(a, \"TimeToSampleBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", p->nb_entries);\n\n\tnb_samples = 0;\n\tfor (i=0; i<p->nb_entries; i++) {\n\t\tfprintf(trace, \"<TimeToSampleEntry SampleDelta=\\\"%d\\\" SampleCount=\\\"%d\\\"/>\\n\", p->entries[i].sampleDelta, p->entries[i].sampleCount);\n\t\tnb_samples += p->entries[i].sampleCount;\n\t}\n\tif (p->size)\n\t\tfprintf(trace, \"<!-- counted %d samples in STTS entries -->\\n\", nb_samples);\n\telse\n\t\tfprintf(trace, \"<TimeToSampleEntry SampleDelta=\\\"\\\" SampleCount=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"TimeToSampleBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ctts_dump(GF_Box *a, FILE * trace)\n{\n\tGF_CompositionOffsetBox *p;\n\tu32 i, nb_samples;\n\tp = (GF_CompositionOffsetBox *)a;\n\tgf_isom_box_dump_start(a, \"CompositionOffsetBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", p->nb_entries);\n\n\tnb_samples = 0;\n\tfor (i=0; i<p->nb_entries; i++) {\n\t\tfprintf(trace, \"<CompositionOffsetEntry CompositionOffset=\\\"%d\\\" SampleCount=\\\"%d\\\"/>\\n\", p->entries[i].decodingOffset, p->entries[i].sampleCount);\n\t\tnb_samples += p->entries[i].sampleCount;\n\t}\n\tif (p->size)\n\t\tfprintf(trace, \"<!-- counted %d samples in CTTS entries -->\\n\", nb_samples);\n\telse\n\t\tfprintf(trace, \"<CompositionOffsetEntry CompositionOffset=\\\"\\\" SampleCount=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"CompositionOffsetBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err cslg_dump(GF_Box *a, FILE * trace)\n{\n\tGF_CompositionToDecodeBox *p;\n\n\tp = (GF_CompositionToDecodeBox *)a;\n\tgf_isom_box_dump_start(a, \"CompositionToDecodeBox\", trace);\n\tfprintf(trace, \"compositionToDTSShift=\\\"%d\\\" leastDecodeToDisplayDelta=\\\"%d\\\" compositionStartTime=\\\"%d\\\" compositionEndTime=\\\"%d\\\">\\n\", p->leastDecodeToDisplayDelta, p->greatestDecodeToDisplayDelta, p->compositionStartTime, p->compositionEndTime);\n\tgf_isom_box_dump_done(\"CompositionToDecodeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ccst_dump(GF_Box *a, FILE * trace)\n{\n\tGF_CodingConstraintsBox *p = (GF_CodingConstraintsBox *)a;\n\tgf_isom_box_dump_start(a, \"CodingConstraintsBox\", trace);\n\tfprintf(trace, \"all_ref_pics_intra=\\\"%d\\\" intra_pred_used=\\\"%d\\\" max_ref_per_pic=\\\"%d\\\" reserved=\\\"%d\\\">\\n\", p->all_ref_pics_intra, p->intra_pred_used, p->max_ref_per_pic, p->reserved);\n\tgf_isom_box_dump_done(\"CodingConstraintsBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stsh_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ShadowSyncBox *p;\n\tu32 i;\n\tGF_StshEntry *t;\n\n\tp = (GF_ShadowSyncBox *)a;\n\tgf_isom_box_dump_start(a, \"SyncShadowBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", gf_list_count(p->entries));\n\ti=0;\n\twhile ((t = (GF_StshEntry *)gf_list_enum(p->entries, &i))) {\n\t\tfprintf(trace, \"<SyncShadowEntry ShadowedSample=\\\"%d\\\" SyncSample=\\\"%d\\\"/>\\n\", t->shadowedSampleNumber, t->syncSampleNumber);\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<SyncShadowEntry ShadowedSample=\\\"\\\" SyncSample=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SyncShadowBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err elst_dump(GF_Box *a, FILE * trace)\n{\n\tGF_EditListBox *p;\n\tu32 i;\n\tGF_EdtsEntry *t;\n\n\tp = (GF_EditListBox *)a;\n\tgf_isom_box_dump_start(a, \"EditListBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", gf_list_count(p->entryList));\n\n\ti=0;\n\twhile ((t = (GF_EdtsEntry *)gf_list_enum(p->entryList, &i))) {\n\t\tfprintf(trace, \"<EditListEntry Duration=\\\"\"LLD\"\\\" MediaTime=\\\"\"LLD\"\\\" MediaRate=\\\"%u\\\"/>\\n\", LLD_CAST t->segmentDuration, LLD_CAST t->mediaTime, t->mediaRate);\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<EditListEntry Duration=\\\"\\\" MediaTime=\\\"\\\" MediaRate=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"EditListBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stsc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SampleToChunkBox *p;\n\tu32 i, nb_samples;\n\n\tp = (GF_SampleToChunkBox *)a;\n\tgf_isom_box_dump_start(a, \"SampleToChunkBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", p->nb_entries);\n\n\tnb_samples = 0;\n\tfor (i=0; i<p->nb_entries; i++) {\n\t\tfprintf(trace, \"<SampleToChunkEntry FirstChunk=\\\"%d\\\" SamplesPerChunk=\\\"%d\\\" SampleDescriptionIndex=\\\"%d\\\"/>\\n\", p->entries[i].firstChunk, p->entries[i].samplesPerChunk, p->entries[i].sampleDescriptionIndex);\n\t\tif (i+1<p->nb_entries) {\n\t\t\tnb_samples += (p->entries[i+1].firstChunk - p->entries[i].firstChunk) * p->entries[i].samplesPerChunk;\n\t\t} else {\n\t\t\tnb_samples += p->entries[i].samplesPerChunk;\n\t\t}\n\t}\n\tif (p->size)\n\t\tfprintf(trace, \"<!-- counted %d samples in STSC entries (could be less than sample count) -->\\n\", nb_samples);\n\telse\n\t\tfprintf(trace, \"<SampleToChunkEntry FirstChunk=\\\"\\\" SamplesPerChunk=\\\"\\\" SampleDescriptionIndex=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"SampleToChunkBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stsz_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SampleSizeBox *p;\n\tu32 i;\n\tp = (GF_SampleSizeBox *)a;\n\n\tif (a->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tgf_isom_box_dump_start(a, \"SampleSizeBox\", trace);\n\t}\n\telse {\n\t\tgf_isom_box_dump_start(a, \"CompactSampleSizeBox\", trace);\n\t}\n\n\tfprintf(trace, \"SampleCount=\\\"%d\\\"\",  p->sampleCount);\n\tif (a->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (p->sampleSize) {\n\t\t\tfprintf(trace, \" ConstantSampleSize=\\\"%d\\\"\", p->sampleSize);\n\t\t}\n\t} else {\n\t\tfprintf(trace, \" SampleSizeBits=\\\"%d\\\"\", p->sampleSize);\n\t}\n\tfprintf(trace, \">\\n\");\n\n\tif ((a->type != GF_ISOM_BOX_TYPE_STSZ) || !p->sampleSize) {\n\t\tif (!p->sizes && p->size) {\n\t\t\tfprintf(trace, \"<!--WARNING: No Sample Size indications-->\\n\");\n\t\t} else {\n\t\t\tfor (i=0; i<p->sampleCount; i++) {\n\t\t\t\tfprintf(trace, \"<SampleSizeEntry Size=\\\"%d\\\"/>\\n\", p->sizes[i]);\n\t\t\t}\n\t\t}\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<SampleSizeEntry Size=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done((a->type == GF_ISOM_BOX_TYPE_STSZ) ? \"SampleSizeBox\" : \"CompactSampleSizeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stco_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ChunkOffsetBox *p;\n\tu32 i;\n\n\tp = (GF_ChunkOffsetBox *)a;\n\tgf_isom_box_dump_start(a, \"ChunkOffsetBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", p->nb_entries);\n\n\tif (!p->offsets && p->size) {\n\t\tfprintf(trace, \"<!--Warning: No Chunk Offsets indications-->\\n\");\n\t} else {\n\t\tfor (i=0; i<p->nb_entries; i++) {\n\t\t\tfprintf(trace, \"<ChunkEntry offset=\\\"%u\\\"/>\\n\", p->offsets[i]);\n\t\t}\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<ChunkEntry offset=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"ChunkOffsetBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stss_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SyncSampleBox *p;\n\tu32 i;\n\n\tp = (GF_SyncSampleBox *)a;\n\tgf_isom_box_dump_start(a, \"SyncSampleBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", p->nb_entries);\n\n\tif (!p->sampleNumbers && p->size) {\n\t\tfprintf(trace, \"<!--Warning: No Key Frames indications-->\\n\");\n\t} else {\n\t\tfor (i=0; i<p->nb_entries; i++) {\n\t\t\tfprintf(trace, \"<SyncSampleEntry sampleNumber=\\\"%u\\\"/>\\n\", p->sampleNumbers[i]);\n\t\t}\n\t}\n\tif (!p->size) {\n\t\t\tfprintf(trace, \"<SyncSampleEntry sampleNumber=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SyncSampleBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stdp_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DegradationPriorityBox *p;\n\tu32 i;\n\n\tp = (GF_DegradationPriorityBox *)a;\n\tgf_isom_box_dump_start(a, \"DegradationPriorityBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", p->nb_entries);\n\n\tif (!p->priorities && p->size) {\n\t\tfprintf(trace, \"<!--Warning: No Degradation Priority indications-->\\n\");\n\t} else {\n\t\tfor (i=0; i<p->nb_entries; i++) {\n\t\t\tfprintf(trace, \"<DegradationPriorityEntry DegradationPriority=\\\"%d\\\"/>\\n\", p->priorities[i]);\n\t\t}\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<DegradationPriorityEntry DegradationPriority=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"DegradationPriorityBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err sdtp_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SampleDependencyTypeBox *p;\n\tu32 i;\n\n\tp = (GF_SampleDependencyTypeBox*)a;\n\tgf_isom_box_dump_start(a, \"SampleDependencyTypeBox\", trace);\n\tfprintf(trace, \"SampleCount=\\\"%d\\\">\\n\", p->sampleCount);\n\n\tif (!p->sample_info && p->size) {\n\t\tfprintf(trace, \"<!--Warning: No sample dependencies indications-->\\n\");\n\t} else {\n\t\tfor (i=0; i<p->sampleCount; i++) {\n\t\t\tu8 flag = p->sample_info[i];\n\t\t\tfprintf(trace, \"<SampleDependencyEntry \");\n\t\t\tswitch ( (flag >> 4) & 3) {\n\t\t\tcase 0:\n\t\t\t\tfprintf(trace, \"dependsOnOther=\\\"unknown\\\" \");\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tfprintf(trace, \"dependsOnOther=\\\"yes\\\" \");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tfprintf(trace, \"dependsOnOther=\\\"no\\\" \");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfprintf(trace, \"dependsOnOther=\\\"RESERVED\\\" \");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch ( (flag >> 2) & 3) {\n\t\t\tcase 0:\n\t\t\t\tfprintf(trace, \"dependedOn=\\\"unknown\\\" \");\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tfprintf(trace, \"dependedOn=\\\"yes\\\" \");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tfprintf(trace, \"dependedOn=\\\"no\\\" \");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfprintf(trace, \"dependedOn=\\\"RESERVED\\\" \");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch ( flag & 3) {\n\t\t\tcase 0:\n\t\t\t\tfprintf(trace, \"hasRedundancy=\\\"unknown\\\" \");\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tfprintf(trace, \"hasRedundancy=\\\"yes\\\" \");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tfprintf(trace, \"hasRedundancy=\\\"no\\\" \");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfprintf(trace, \"hasRedundancy=\\\"RESERVED\\\" \");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfprintf(trace, \" />\\n\");\n\t\t}\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<SampleDependencyEntry dependsOnOther=\\\"unknown|yes|no|RESERVED\\\" dependedOn=\\\"unknown|yes|no|RESERVED\\\" hasRedundancy=\\\"unknown|yes|no|RESERVED\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SampleDependencyTypeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err co64_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ChunkLargeOffsetBox *p;\n\tu32 i;\n\n\tp = (GF_ChunkLargeOffsetBox *)a;\n\tgf_isom_box_dump_start(a, \"ChunkLargeOffsetBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", p->nb_entries);\n\n\tif (!p->offsets && p->size) {\n\t\tfprintf(trace, \"<!-- Warning: No Chunk Offsets indications/>\\n\");\n\t} else {\n\t\tfor (i=0; i<p->nb_entries; i++)\n\t\t\tfprintf(trace, \"<ChunkOffsetEntry offset=\\\"\"LLU\"\\\"/>\\n\", LLU_CAST p->offsets[i]);\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<ChunkOffsetEntry offset=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"ChunkLargeOffsetBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err esds_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ESDBox *p;\n\n\tp = (GF_ESDBox *)a;\n\tgf_isom_box_dump_start(a, \"MPEG4ESDescriptorBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\tif (p->desc) {\n#ifndef GPAC_DISABLE_OD_DUMP\n\t\tgf_odf_dump_desc((GF_Descriptor *) p->desc, trace, 1, GF_TRUE);\n#else\n\t\tfprintf(trace, \"<!-- Object Descriptor Dumping disabled in this build of GPAC -->\\n\");\n#endif\n\t} else if (p->size) {\n\t\tfprintf(trace, \"<!--INVALID MP4 FILE: ESD not present in MPEG Sample Description or corrupted-->\\n\");\n\t}\n\tgf_isom_box_dump_done(\"MPEG4ESDescriptorBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err minf_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MediaInformationBox *p;\n\n\tp = (GF_MediaInformationBox *)a;\n\tgf_isom_box_dump_start(a, \"MediaInformationBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->InfoHeader, trace, GF_ISOM_BOX_TYPE_NMHD);\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->dataInformation, trace, GF_ISOM_BOX_TYPE_DINF);\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->sampleTable, trace, GF_ISOM_BOX_TYPE_STBL);\n\n\tgf_isom_box_dump_done(\"MediaInformationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tkhd_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackHeaderBox *p;\n\tp = (GF_TrackHeaderBox *)a;\n\tgf_isom_box_dump_start(a, \"TrackHeaderBox\", trace);\n\n\tfprintf(trace, \"CreationTime=\\\"\"LLD\"\\\" ModificationTime=\\\"\"LLD\"\\\" TrackID=\\\"%u\\\" Duration=\\\"\"LLD\"\\\"\",\n\t        LLD_CAST p->creationTime, LLD_CAST p->modificationTime, p->trackID, LLD_CAST p->duration);\n\n\tif (p->alternate_group) fprintf(trace, \" AlternateGroupID=\\\"%d\\\"\", p->alternate_group);\n\tif (p->volume) {\n\t\tfprintf(trace, \" Volume=\\\"%.2f\\\"\", (Float)p->volume / 256);\n\t} else if (p->width || p->height) {\n\t\tfprintf(trace, \" Width=\\\"%.2f\\\" Height=\\\"%.2f\\\"\", (Float)p->width / 65536, (Float)p->height / 65536);\n\t\tif (p->layer) fprintf(trace, \" Layer=\\\"%d\\\"\", p->layer);\n\t}\n\tfprintf(trace, \">\\n\");\n\tif (p->width || p->height) {\n\t\tfprintf(trace, \"<Matrix m11=\\\"0x%.8x\\\" m12=\\\"0x%.8x\\\" m13=\\\"0x%.8x\\\" \", p->matrix[0], p->matrix[1], p->matrix[2]);\n\t\tfprintf(trace, \"m21=\\\"0x%.8x\\\" m22=\\\"0x%.8x\\\" m23=\\\"0x%.8x\\\" \", p->matrix[3], p->matrix[4], p->matrix[5]);\n\t\tfprintf(trace, \"m31=\\\"0x%.8x\\\" m32=\\\"0x%.8x\\\" m33=\\\"0x%.8x\\\"/>\\n\", p->matrix[6], p->matrix[7], p->matrix[8]);\n\t}\n\n\tgf_isom_box_dump_done(\"TrackHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tref_dump(GF_Box *a, FILE * trace)\n{\n//\tGF_TrackReferenceBox *p = (GF_TrackReferenceBox *)a;\n\tgf_isom_box_dump_start(a, \"TrackReferenceBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"TrackReferenceBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err mdia_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MediaBox *p = (GF_MediaBox *)a;\n\tgf_isom_box_dump_start(a, \"MediaBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->mediaHeader, trace, GF_ISOM_BOX_TYPE_MDHD);\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->handler, trace,GF_ISOM_BOX_TYPE_HDLR);\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->information, trace, GF_ISOM_BOX_TYPE_MINF);\n\tgf_isom_box_dump_done(\"MediaBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err mfra_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MovieFragmentRandomAccessBox *p = (GF_MovieFragmentRandomAccessBox *)a;\n\tu32 i, count;\n\tGF_TrackFragmentRandomAccessBox *tfra;\n\n\tgf_isom_box_dump_start(a, \"MovieFragmentRandomAccessBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tcount = gf_list_count(p->tfra_list);\n\tfor (i=0; i<count; i++) {\n\t\ttfra = (GF_TrackFragmentRandomAccessBox *)gf_list_get(p->tfra_list, i);\n\t\tgf_isom_box_dump_ex(tfra, trace, GF_ISOM_BOX_TYPE_TFRA);\n\t}\n\tgf_isom_box_dump_done(\"MovieFragmentRandomAccessBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tfra_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_TrackFragmentRandomAccessBox *p = (GF_TrackFragmentRandomAccessBox *)a;\n\tgf_isom_box_dump_start(a, \"TrackFragmentRandomAccessBox\", trace);\n\tfprintf(trace, \"TrackId=\\\"%u\\\" number_of_entries=\\\"%u\\\">\\n\", p->track_id, p->nb_entries);\n\tfor (i=0; i<p->nb_entries; i++) {\n\t\tfprintf(trace, \"<RandomAccessEntry time=\\\"\"LLU\"\\\" moof_offset=\\\"\"LLU\"\\\" traf=\\\"%u\\\" trun=\\\"%u\\\" sample=\\\"%u\\\"/>\\n\",\n\t\t\tp->entries[i].time, p->entries[i].moof_offset,\n\t\t\tp->entries[i].traf_number, p->entries[i].trun_number, p->entries[i].sample_number);\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<RandomAccessEntry time=\\\"\\\" moof_offset=\\\"\\\" traf=\\\"\\\" trun=\\\"\\\" sample=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"TrackFragmentRandomAccessBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err mfro_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MovieFragmentRandomAccessOffsetBox *p = (GF_MovieFragmentRandomAccessOffsetBox *)a;\n\n\tgf_isom_box_dump_start(a, \"MovieFragmentRandomAccessOffsetBox\", trace);\n\n\tfprintf(trace, \"container_size=\\\"%d\\\" >\\n\", p->container_size);\n\tgf_isom_box_dump_done(\"MovieFragmentRandomAccessOffsetBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err elng_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ExtendedLanguageBox *p = (GF_ExtendedLanguageBox *)a;\n\tgf_isom_box_dump_start(a, \"ExtendedLanguageBox\", trace);\n\tfprintf(trace, \"LanguageCode=\\\"%s\\\">\\n\", p->extended_language);\n\tgf_isom_box_dump_done(\"ExtendedLanguageBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err unkn_dump(GF_Box *a, FILE * trace)\n{\n\tGF_UnknownBox *u = (GF_UnknownBox *)a;\n\tu->type = u->original_4cc;\n\tgf_isom_box_dump_start(a, \"UnknownBox\", trace);\n\tu->type = GF_ISOM_BOX_TYPE_UNKNOWN;\n\tif (u->dataSize<100)\n\t\tdump_data_attribute(trace, \"data\", u->data, u->dataSize);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"UnknownBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err uuid_dump(GF_Box *a, FILE * trace)\n{\n\tgf_isom_box_dump_start(a, \"UUIDBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"UUIDBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err void_dump(GF_Box *a, FILE * trace)\n{\n\tgf_isom_box_dump_start(a, \"VoidBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"VoidBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ftyp_dump(GF_Box *a, FILE * trace)\n{\n\tGF_FileTypeBox *p;\n\tu32 i;\n\n\tp = (GF_FileTypeBox *)a;\n\tgf_isom_box_dump_start(a, (a->type == GF_ISOM_BOX_TYPE_FTYP ? \"FileTypeBox\" : \"SegmentTypeBox\"), trace);\n\tfprintf(trace, \"MajorBrand=\\\"%s\\\" MinorVersion=\\\"%d\\\">\\n\", gf_4cc_to_str(p->majorBrand), p->minorVersion);\n\n\tfor (i=0; i<p->altCount; i++) {\n\t\tfprintf(trace, \"<BrandEntry AlternateBrand=\\\"%s\\\"/>\\n\", gf_4cc_to_str(p->altBrand[i]));\n\t}\n\tif (!p->type) {\n\t\tfprintf(trace, \"<BrandEntry AlternateBrand=\\\"4CC\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done((a->type == GF_ISOM_BOX_TYPE_FTYP ? \"FileTypeBox\" : \"SegmentTypeBox\"), a, trace);\n\treturn GF_OK;\n}\n\nGF_Err padb_dump(GF_Box *a, FILE * trace)\n{\n\tGF_PaddingBitsBox *p;\n\tu32 i;\n\n\tp = (GF_PaddingBitsBox *)a;\n\tgf_isom_box_dump_start(a, \"PaddingBitsBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", p->SampleCount);\n\tfor (i=0; i<p->SampleCount; i+=1) {\n\t\tfprintf(trace, \"<PaddingBitsEntry PaddingBits=\\\"%d\\\"/>\\n\", p->padbits[i]);\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<PaddingBitsEntry PaddingBits=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"PaddingBitsBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stsf_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SampleFragmentBox *p;\n\tGF_StsfEntry *ent;\n\tu32 i, j, count;\n\n\n\tp = (GF_SampleFragmentBox *)a;\n\tcount = gf_list_count(p->entryList);\n\tgf_isom_box_dump_start(a, \"SampleFragmentBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", count);\n\n\tfor (i=0; i<count; i++) {\n\t\tent = (GF_StsfEntry *)gf_list_get(p->entryList, i);\n\t\tfprintf(trace, \"<SampleFragmentEntry SampleNumber=\\\"%d\\\" FragmentCount=\\\"%d\\\">\\n\", ent->SampleNumber, ent->fragmentCount);\n\t\tfor (j=0; j<ent->fragmentCount; j++) fprintf(trace, \"<FragmentSizeEntry size=\\\"%d\\\"/>\\n\", ent->fragmentSizes[j]);\n\t\tfprintf(trace, \"</SampleFragmentEntry>\\n\");\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<SampleFragmentEntry SampleNumber=\\\"\\\" FragmentCount=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<FragmentSizeEntry size=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</SampleFragmentEntry>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SampleFragmentBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err gppc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_3GPPConfigBox *p = (GF_3GPPConfigBox *)a;\n\tconst char *name = gf_4cc_to_str(p->cfg.vendor);\n\tswitch (p->cfg.type) {\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\tgf_isom_box_dump_start(a, \"AMRConfigurationBox\", trace);\n\t\tfprintf(trace, \"Vendor=\\\"%s\\\" Version=\\\"%d\\\"\", name, p->cfg.decoder_version);\n\t\tfprintf(trace, \" FramesPerSample=\\\"%d\\\" SupportedModes=\\\"%x\\\" ModeRotating=\\\"%d\\\"\", p->cfg.frames_per_sample, p->cfg.AMR_mode_set, p->cfg.AMR_mode_change_period);\n\t\tfprintf(trace, \">\\n\");\n\t\tgf_isom_box_dump_done(\"AMRConfigurationBox\", a, trace);\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tgf_isom_box_dump_start(a, \"EVRCConfigurationBox\", trace);\n\t\tfprintf(trace, \"Vendor=\\\"%s\\\" Version=\\\"%d\\\" FramesPerSample=\\\"%d\\\" >\\n\", name, p->cfg.decoder_version, p->cfg.frames_per_sample);\n\t\tgf_isom_box_dump_done(\"EVRCConfigurationBox\", a, trace);\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\tgf_isom_box_dump_start(a, \"QCELPConfigurationBox\", trace);\n\t\tfprintf(trace, \"Vendor=\\\"%s\\\" Version=\\\"%d\\\" FramesPerSample=\\\"%d\\\" >\\n\", name, p->cfg.decoder_version, p->cfg.frames_per_sample);\n\t\tgf_isom_box_dump_done(\"QCELPConfigurationBox\", a, trace);\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tgf_isom_box_dump_start(a, \"SMVConfigurationBox\", trace);\n\t\tfprintf(trace, \"Vendor=\\\"%s\\\" Version=\\\"%d\\\" FramesPerSample=\\\"%d\\\" >\\n\", name, p->cfg.decoder_version, p->cfg.frames_per_sample);\n\t\tgf_isom_box_dump_done(\"SMVConfigurationBox\", a, trace);\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tgf_isom_box_dump_start(a, \"H263ConfigurationBox\", trace);\n\t\tfprintf(trace, \"Vendor=\\\"%s\\\" Version=\\\"%d\\\"\", name, p->cfg.decoder_version);\n\t\tfprintf(trace, \" Profile=\\\"%d\\\" Level=\\\"%d\\\"\", p->cfg.H263_profile, p->cfg.H263_level);\n\t\tfprintf(trace, \">\\n\");\n\t\tgf_isom_box_dump_done(\"H263ConfigurationBox\", a, trace);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err avcc_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i, count;\n\tGF_AVCConfigurationBox *p = (GF_AVCConfigurationBox *) a;\n\tconst char *name = (p->type==GF_ISOM_BOX_TYPE_MVCC) ? \"MVC\" : (p->type==GF_ISOM_BOX_TYPE_SVCC) ? \"SVC\" : \"AVC\";\n\tchar boxname[256];\n\tsprintf(boxname, \"%sConfigurationBox\", name);\n\tgf_isom_box_dump_start(a, boxname, trace);\n\tfprintf(trace, \">\\n\");\n\n\tfprintf(trace, \"<%sDecoderConfigurationRecord\", name);\n\n\tif (! p->config) {\n\t\tif (p->size) {\n\t\t\tfprintf(trace, \">\\n\");\n\t\t\tfprintf(trace, \"<!-- INVALID AVC ENTRY : no AVC/SVC config record -->\\n\");\n\t\t} else {\n\n\t\t\tfprintf(trace, \" configurationVersion=\\\"\\\" AVCProfileIndication=\\\"\\\" profile_compatibility=\\\"\\\" AVCLevelIndication=\\\"\\\" nal_unit_size=\\\"\\\" complete_representation=\\\"\\\"\");\n\n\t\t\tfprintf(trace, \" chroma_format=\\\"\\\" luma_bit_depth=\\\"\\\" chroma_bit_depth=\\\"\\\"\");\n\t\t\tfprintf(trace, \">\\n\");\n\n\t\t\tfprintf(trace, \"<SequenceParameterSet size=\\\"\\\" content=\\\"\\\"/>\\n\");\n\t\t\tfprintf(trace, \"<PictureParameterSet size=\\\"\\\" content=\\\"\\\"/>\\n\");\n\t\t\tfprintf(trace, \"<SequenceParameterSetExtensions size=\\\"\\\" content=\\\"\\\"/>\\n\");\n\t\t}\n\t\tfprintf(trace, \"</%sDecoderConfigurationRecord>\\n\", name);\n\t\tgf_isom_box_dump_done(boxname, a, trace);\n\t\treturn GF_OK;\n\t}\n\n\tfprintf(trace, \" configurationVersion=\\\"%d\\\" AVCProfileIndication=\\\"%d\\\" profile_compatibility=\\\"%d\\\" AVCLevelIndication=\\\"%d\\\" nal_unit_size=\\\"%d\\\"\", p->config->configurationVersion, p->config->AVCProfileIndication, p->config->profile_compatibility, p->config->AVCLevelIndication, p->config->nal_unit_size);\n\n\n\tif ((p->type==GF_ISOM_BOX_TYPE_SVCC) || (p->type==GF_ISOM_BOX_TYPE_MVCC) )\n\t\tfprintf(trace, \" complete_representation=\\\"%d\\\"\", p->config->complete_representation);\n\n\tif (p->type==GF_ISOM_BOX_TYPE_AVCC) {\n\t\tif (gf_avc_is_rext_profile(p->config->AVCProfileIndication)) {\n\t\t\tfprintf(trace, \" chroma_format=\\\"%s\\\" luma_bit_depth=\\\"%d\\\" chroma_bit_depth=\\\"%d\\\"\", gf_avc_hevc_get_chroma_format_name(p->config->chroma_format), p->config->luma_bit_depth, p->config->chroma_bit_depth);\n\t\t}\n\t}\n\n\tfprintf(trace, \">\\n\");\n\n\tcount = gf_list_count(p->config->sequenceParameterSets);\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *c = (GF_AVCConfigSlot *)gf_list_get(p->config->sequenceParameterSets, i);\n\t\tfprintf(trace, \"<SequenceParameterSet size=\\\"%d\\\" content=\\\"\", c->size);\n\t\tdump_data(trace, c->data, c->size);\n\t\tfprintf(trace, \"\\\"/>\\n\");\n\t}\n\tcount = gf_list_count(p->config->pictureParameterSets);\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *c = (GF_AVCConfigSlot *)gf_list_get(p->config->pictureParameterSets, i);\n\t\tfprintf(trace, \"<PictureParameterSet size=\\\"%d\\\" content=\\\"\", c->size);\n\t\tdump_data(trace, c->data, c->size);\n\t\tfprintf(trace, \"\\\"/>\\n\");\n\t}\n\n\tif (p->config->sequenceParameterSetExtensions) {\n\t\tcount = gf_list_count(p->config->sequenceParameterSetExtensions);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_AVCConfigSlot *c = (GF_AVCConfigSlot *)gf_list_get(p->config->sequenceParameterSetExtensions, i);\n\t\t\tfprintf(trace, \"<SequenceParameterSetExtensions size=\\\"%d\\\" content=\\\"\", c->size);\n\t\t\tdump_data(trace, c->data, c->size);\n\t\t\tfprintf(trace, \"\\\"/>\\n\");\n\t\t}\n\t}\n\n\tfprintf(trace, \"</%sDecoderConfigurationRecord>\\n\", name);\n\n\tgf_isom_box_dump_done(boxname, a, trace);\n\treturn GF_OK;\n}\n\nGF_Err hvcc_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i, count;\n\tconst char *name = (a->type==GF_ISOM_BOX_TYPE_HVCC) ? \"HEVC\" : \"L-HEVC\";\n\tchar boxname[256];\n\tGF_HEVCConfigurationBox *p = (GF_HEVCConfigurationBox *) a;\n\n\tsprintf(boxname, \"%sConfigurationBox\", name);\n\tgf_isom_box_dump_start(a, boxname, trace);\n\tfprintf(trace, \">\\n\");\n\n\tif (! p->config) {\n\t\tif (p->size) {\n\t\t\tfprintf(trace, \"<!-- INVALID HEVC ENTRY: no HEVC/SHVC config record -->\\n\");\n\t\t} else {\n\t\t\tfprintf(trace, \"<%sDecoderConfigurationRecord nal_unit_size=\\\"\\\" configurationVersion=\\\"\\\" \", name);\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_HVCC) {\n\t\t\t\tfprintf(trace, \"profile_space=\\\"\\\" tier_flag=\\\"\\\" profile_idc=\\\"\\\" general_profile_compatibility_flags=\\\"\\\" progressive_source_flag=\\\"\\\" interlaced_source_flag=\\\"\\\" non_packed_constraint_flag=\\\"\\\" frame_only_constraint_flag=\\\"\\\" constraint_indicator_flags=\\\"\\\" level_idc=\\\"\\\" \");\n\t\t\t}\n\t\t\tfprintf(trace, \"min_spatial_segmentation_idc=\\\"\\\" parallelismType=\\\"\\\" \");\n\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_HVCC)\n\t\t\t\tfprintf(trace, \"chroma_format=\\\"\\\" luma_bit_depth=\\\"\\\" chroma_bit_depth=\\\"\\\" avgFrameRate=\\\"\\\" constantFrameRate=\\\"\\\" numTemporalLayers=\\\"\\\" temporalIdNested=\\\"\\\"\");\n\n\t\t\tfprintf(trace, \">\\n\");\n\t\t\tfprintf(trace, \"<ParameterSetArray nalu_type=\\\"\\\" complete_set=\\\"\\\">\\n\");\n\t\t\tfprintf(trace, \"<ParameterSet size=\\\"\\\" content=\\\"\\\"/>\\n\");\n\t\t\tfprintf(trace, \"</ParameterSetArray>\\n\");\n\t\t\tfprintf(trace, \"</%sDecoderConfigurationRecord>\\n\", name);\n\t\t}\n\t\tfprintf(trace, \"</%sConfigurationBox>\\n\", name);\n\t\treturn GF_OK;\n\t}\n\n\tfprintf(trace, \"<%sDecoderConfigurationRecord nal_unit_size=\\\"%d\\\" \", name, p->config->nal_unit_size);\n\tfprintf(trace, \"configurationVersion=\\\"%u\\\" \", p->config->configurationVersion);\n\tif (a->type==GF_ISOM_BOX_TYPE_HVCC) {\n\t\tfprintf(trace, \"profile_space=\\\"%u\\\" \", p->config->profile_space);\n\t\tfprintf(trace, \"tier_flag=\\\"%u\\\" \", p->config->tier_flag);\n\t\tfprintf(trace, \"profile_idc=\\\"%u\\\" \", p->config->profile_idc);\n\t\tfprintf(trace, \"general_profile_compatibility_flags=\\\"%X\\\" \", p->config->general_profile_compatibility_flags);\n\t\tfprintf(trace, \"progressive_source_flag=\\\"%u\\\" \", p->config->progressive_source_flag);\n\t\tfprintf(trace, \"interlaced_source_flag=\\\"%u\\\" \", p->config->interlaced_source_flag);\n\t\tfprintf(trace, \"non_packed_constraint_flag=\\\"%u\\\" \", p->config->non_packed_constraint_flag);\n\t\tfprintf(trace, \"frame_only_constraint_flag=\\\"%u\\\" \", p->config->frame_only_constraint_flag);\n\t\tfprintf(trace, \"constraint_indicator_flags=\\\"\"LLX\"\\\" \", p->config->constraint_indicator_flags);\n\t\tfprintf(trace, \"level_idc=\\\"%d\\\" \", p->config->level_idc);\n\t}\n\tfprintf(trace, \"min_spatial_segmentation_idc=\\\"%u\\\" \", p->config->min_spatial_segmentation_idc);\n\tfprintf(trace, \"parallelismType=\\\"%u\\\" \", p->config->parallelismType);\n\n\tif (a->type==GF_ISOM_BOX_TYPE_HVCC)\n\t\tfprintf(trace, \"chroma_format=\\\"%s\\\" luma_bit_depth=\\\"%u\\\" chroma_bit_depth=\\\"%u\\\" avgFrameRate=\\\"%u\\\" constantFrameRate=\\\"%u\\\" numTemporalLayers=\\\"%u\\\" temporalIdNested=\\\"%u\\\"\",\n\t        gf_avc_hevc_get_chroma_format_name(p->config->chromaFormat), p->config->luma_bit_depth, p->config->chroma_bit_depth, p->config->avgFrameRate, p->config->constantFrameRate, p->config->numTemporalLayers, p->config->temporalIdNested);\n\n\tfprintf(trace, \">\\n\");\n\n\tcount = gf_list_count(p->config->param_array);\n\tfor (i=0; i<count; i++) {\n\t\tu32 nalucount, j;\n\t\tGF_HEVCParamArray *ar = (GF_HEVCParamArray*)gf_list_get(p->config->param_array, i);\n\t\tfprintf(trace, \"<ParameterSetArray nalu_type=\\\"%d\\\" complete_set=\\\"%d\\\">\\n\", ar->type, ar->array_completeness);\n\t\tnalucount = gf_list_count(ar->nalus);\n\t\tfor (j=0; j<nalucount; j++) {\n\t\t\tGF_AVCConfigSlot *c = (GF_AVCConfigSlot *)gf_list_get(ar->nalus, j);\n\t\t\tfprintf(trace, \"<ParameterSet size=\\\"%d\\\" content=\\\"\", c->size);\n\t\t\tdump_data(trace, c->data, c->size);\n\t\t\tfprintf(trace, \"\\\"/>\\n\");\n\t\t}\n\t\tfprintf(trace, \"</ParameterSetArray>\\n\");\n\t}\n\n\tfprintf(trace, \"</%sDecoderConfigurationRecord>\\n\", name);\n\n\tgf_isom_box_dump_done(boxname, a, trace);\n\treturn GF_OK;\n}\n\nGF_Err m4ds_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_Descriptor *desc;\n\tGF_MPEG4ExtensionDescriptorsBox *p = (GF_MPEG4ExtensionDescriptorsBox *) a;\n\tgf_isom_box_dump_start(a, \"MPEG4ExtensionDescriptorsBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\ti=0;\n\twhile ((desc = (GF_Descriptor *)gf_list_enum(p->descriptors, &i))) {\n#ifndef GPAC_DISABLE_OD_DUMP\n\t\tgf_odf_dump_desc(desc, trace, 1, GF_TRUE);\n#else\n\t\tfprintf(trace, \"<!-- Object Descriptor Dumping disabled in this build of GPAC -->\\n\");\n#endif\n\t}\n\tgf_isom_box_dump_done(\"MPEG4ExtensionDescriptorsBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err btrt_dump(GF_Box *a, FILE * trace)\n{\n\tGF_BitRateBox *p = (GF_BitRateBox*)a;\n\tgf_isom_box_dump_start(a, \"BitRateBox\", trace);\n\tfprintf(trace, \"BufferSizeDB=\\\"%d\\\" avgBitRate=\\\"%d\\\" maxBitRate=\\\"%d\\\">\\n\", p->bufferSizeDB, p->avgBitrate, p->maxBitrate);\n\tgf_isom_box_dump_done(\"BitRateBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ftab_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_FontTableBox *p = (GF_FontTableBox *)a;\n\tgf_isom_box_dump_start(a, \"FontTableBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tfor (i=0; i<p->entry_count; i++) {\n\t\tfprintf(trace, \"<FontRecord ID=\\\"%d\\\" name=\\\"%s\\\"/>\\n\", p->fonts[i].fontID, p->fonts[i].fontName ? p->fonts[i].fontName : \"NULL\");\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<FontRecord ID=\\\"\\\" name=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"FontTableBox\", a, trace);\n\treturn GF_OK;\n}\n\nstatic void tx3g_dump_rgba8(FILE * trace, char *name, u32 col)\n{\n\tfprintf(trace, \"%s=\\\"%x %x %x %x\\\"\", name, (col>>16)&0xFF, (col>>8)&0xFF, (col)&0xFF, (col>>24)&0xFF);\n}\nstatic void tx3g_dump_rgb16(FILE * trace, char *name, char col[6])\n{\n\tfprintf(trace, \"%s=\\\"%x %x %x\\\"\", name, *((u16*)col), *((u16*)(col+1)), *((u16*)(col+2)));\n}\nstatic void tx3g_dump_box(FILE * trace, GF_BoxRecord *rec)\n{\n\tfprintf(trace, \"<BoxRecord top=\\\"%d\\\" left=\\\"%d\\\" bottom=\\\"%d\\\" right=\\\"%d\\\"/>\\n\", rec->top, rec->left, rec->bottom, rec->right);\n}\nstatic void tx3g_dump_style(FILE * trace, GF_StyleRecord *rec)\n{\n\tfprintf(trace, \"<StyleRecord startChar=\\\"%d\\\" endChar=\\\"%d\\\" fontID=\\\"%d\\\" styles=\\\"\", rec->startCharOffset, rec->endCharOffset, rec->fontID);\n\tif (!rec->style_flags) {\n\t\tfprintf(trace, \"Normal\");\n\t} else {\n\t\tif (rec->style_flags & 1) fprintf(trace, \"Bold \");\n\t\tif (rec->style_flags & 2) fprintf(trace, \"Italic \");\n\t\tif (rec->style_flags & 4) fprintf(trace, \"Underlined \");\n\t}\n\tfprintf(trace, \"\\\" fontSize=\\\"%d\\\" \", rec->font_size);\n\ttx3g_dump_rgba8(trace, \"textColor\", rec->text_color);\n\tfprintf(trace, \"/>\\n\");\n}\n\nGF_Err tx3g_dump(GF_Box *a, FILE * trace)\n{\n\tGF_Tx3gSampleEntryBox *p = (GF_Tx3gSampleEntryBox *)a;\n\tgf_isom_box_dump_start(a, \"Tx3gSampleEntryBox\", trace);\n\tfprintf(trace, \"dataReferenceIndex=\\\"%d\\\" displayFlags=\\\"%x\\\" horizontal-justification=\\\"%d\\\" vertical-justification=\\\"%d\\\" \",\n\t        p->dataReferenceIndex, p->displayFlags, p->horizontal_justification, p->vertical_justification);\n\n\ttx3g_dump_rgba8(trace, \"backgroundColor\", p->back_color);\n\tfprintf(trace, \">\\n\");\n\tfprintf(trace, \"<DefaultBox>\\n\");\n\ttx3g_dump_box(trace, &p->default_box);\n\tgf_isom_box_dump_done(\"DefaultBox\", a, trace);\n\tfprintf(trace, \"<DefaultStyle>\\n\");\n\ttx3g_dump_style(trace, &p->default_style);\n\tfprintf(trace, \"</DefaultStyle>\\n\");\n\tif (p->size) {\n\t\tgf_isom_box_dump_ex(p->font_table, trace, GF_ISOM_BOX_TYPE_FTAB);\n\t}\n\tgf_isom_box_dump_done(\"Tx3gSampleEntryBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err text_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TextSampleEntryBox *p = (GF_TextSampleEntryBox *)a;\n\tgf_isom_box_dump_start(a, \"TextSampleEntryBox\", trace);\n\tfprintf(trace, \"dataReferenceIndex=\\\"%d\\\" displayFlags=\\\"%x\\\" textJustification=\\\"%d\\\"  \",\n\t        p->dataReferenceIndex, p->displayFlags, p->textJustification);\n\tif (p->textName)\n\t\tfprintf(trace, \"textName=\\\"%s\\\" \", p->textName);\n\ttx3g_dump_rgb16(trace, \"background-color\", p->background_color);\n\ttx3g_dump_rgb16(trace, \" foreground-color\", p->foreground_color);\n\tfprintf(trace, \">\\n\");\n\n\tfprintf(trace, \"<DefaultBox>\\n\");\n\ttx3g_dump_box(trace, &p->default_box);\n\tgf_isom_box_dump_done(\"DefaultBox\", a, trace);\n\tgf_isom_box_dump_done(\"TextSampleEntryBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err styl_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_TextStyleBox*p = (GF_TextStyleBox*)a;\n\tgf_isom_box_dump_start(a, \"TextStyleBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tfor (i=0; i<p->entry_count; i++) tx3g_dump_style(trace, &p->styles[i]);\n\tif (!p->size) {\n\t\tfprintf(trace, \"<StyleRecord startChar=\\\"\\\" endChar=\\\"\\\" fontID=\\\"\\\" styles=\\\"Normal|Bold|Italic|Underlined\\\" fontSize=\\\"\\\" textColor=\\\"\\\" />\\n\");\n\t}\n\tgf_isom_box_dump_done(\"TextStyleBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err hlit_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TextHighlightBox*p = (GF_TextHighlightBox*)a;\n\tgf_isom_box_dump_start(a, \"TextHighlightBox\", trace);\n\tfprintf(trace, \"startcharoffset=\\\"%d\\\" endcharoffset=\\\"%d\\\">\\n\", p->startcharoffset, p->endcharoffset);\n\tgf_isom_box_dump_done(\"TextHighlightBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err hclr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TextHighlightColorBox*p = (GF_TextHighlightColorBox*)a;\n\tgf_isom_box_dump_start(a, \"TextHighlightColorBox\", trace);\n\ttx3g_dump_rgba8(trace, \"highlight_color\", p->hil_color);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"TextHighlightColorBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err krok_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_TextKaraokeBox*p = (GF_TextKaraokeBox*)a;\n\tgf_isom_box_dump_start(a, \"TextKaraokeBox\", trace);\n\tfprintf(trace, \"highlight_starttime=\\\"%d\\\">\\n\", p->highlight_starttime);\n\tfor (i=0; i<p->nb_entries; i++) {\n\t\tfprintf(trace, \"<KaraokeRecord highlight_endtime=\\\"%d\\\" start_charoffset=\\\"%d\\\" end_charoffset=\\\"%d\\\"/>\\n\", p->records[i].highlight_endtime, p->records[i].start_charoffset, p->records[i].end_charoffset);\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<KaraokeRecord highlight_endtime=\\\"\\\" start_charoffset=\\\"\\\" end_charoffset=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"TextKaraokeBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err dlay_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TextScrollDelayBox*p = (GF_TextScrollDelayBox*)a;\n\tgf_isom_box_dump_start(a, \"TextScrollDelayBox\", trace);\n\tfprintf(trace, \"scroll_delay=\\\"%d\\\">\\n\", p->scroll_delay);\n\tgf_isom_box_dump_done(\"TextScrollDelayBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err href_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TextHyperTextBox*p = (GF_TextHyperTextBox*)a;\n\tgf_isom_box_dump_start(a, \"TextHyperTextBox\", trace);\n\tfprintf(trace, \"startcharoffset=\\\"%d\\\" endcharoffset=\\\"%d\\\" URL=\\\"%s\\\" altString=\\\"%s\\\">\\n\", p->startcharoffset, p->endcharoffset, p->URL ? p->URL : \"NULL\", p->URL_hint ? p->URL_hint : \"NULL\");\n\tgf_isom_box_dump_done(\"TextHyperTextBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err tbox_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TextBoxBox*p = (GF_TextBoxBox*)a;\n\tgf_isom_box_dump_start(a, \"TextBoxBox\", trace);\n\tfprintf(trace, \">\\n\");\n\ttx3g_dump_box(trace, &p->box);\n\tgf_isom_box_dump_done(\"TextBoxBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err blnk_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TextBlinkBox*p = (GF_TextBlinkBox*)a;\n\tgf_isom_box_dump_start(a, \"TextBlinkBox\", trace);\n\tfprintf(trace, \"start_charoffset=\\\"%d\\\" end_charoffset=\\\"%d\\\">\\n\", p->startcharoffset, p->endcharoffset);\n\tgf_isom_box_dump_done(\"TextBlinkBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err twrp_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TextWrapBox*p = (GF_TextWrapBox*)a;\n\tgf_isom_box_dump_start(a, \"TextWrapBox\", trace);\n\tfprintf(trace, \"wrap_flag=\\\"%s\\\">\\n\", p->wrap_flag ? ( (p->wrap_flag>1) ? \"Reserved\" : \"Automatic\" ) : \"No Wrap\");\n\tgf_isom_box_dump_done(\"TextWrapBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err meta_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MetaBox *p;\n\tp = (GF_MetaBox *)a;\n\tgf_isom_box_dump_start(a, \"MetaBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\tif (p->handler) gf_isom_box_dump(p->handler, trace);\n\tif (p->primary_resource) gf_isom_box_dump(p->primary_resource, trace);\n\tif (p->file_locations) gf_isom_box_dump(p->file_locations, trace);\n\tif (p->item_locations) gf_isom_box_dump(p->item_locations, trace);\n\tif (p->protections) gf_isom_box_dump(p->protections, trace);\n\tif (p->item_infos) gf_isom_box_dump(p->item_infos, trace);\n\tif (p->IPMP_control) gf_isom_box_dump(p->IPMP_control, trace);\n\tif (p->item_refs) gf_isom_box_dump(p->item_refs, trace);\n\tif (p->item_props) gf_isom_box_dump(p->item_props, trace);\n\tgf_isom_box_dump_done(\"MetaBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err xml_dump(GF_Box *a, FILE * trace)\n{\n\tGF_XMLBox *p = (GF_XMLBox *)a;\n\tgf_isom_box_dump_start(a, \"XMLBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tfprintf(trace, \"<![CDATA[\\n\");\n\tif (p->xml)\n\t\tgf_fwrite(p->xml, strlen(p->xml), 1, trace);\n\tfprintf(trace, \"]]>\\n\");\n\tgf_isom_box_dump_done(\"XMLBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err bxml_dump(GF_Box *a, FILE * trace)\n{\n\tGF_BinaryXMLBox *p = (GF_BinaryXMLBox *)a;\n\tgf_isom_box_dump_start(a, \"BinaryXMLBox\", trace);\n\tfprintf(trace, \"binarySize=\\\"%d\\\">\\n\", p->data_length);\n\tgf_isom_box_dump_done(\"BinaryXMLBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err pitm_dump(GF_Box *a, FILE * trace)\n{\n\tGF_PrimaryItemBox *p = (GF_PrimaryItemBox *)a;\n\tgf_isom_box_dump_start(a, \"PrimaryItemBox\", trace);\n\tfprintf(trace, \"item_ID=\\\"%d\\\">\\n\", p->item_ID);\n\tgf_isom_box_dump_done(\"PrimaryItemBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ipro_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ItemProtectionBox *p = (GF_ItemProtectionBox *)a;\n\tgf_isom_box_dump_start(a, \"ItemProtectionBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_array_dump(p->protection_information, trace);\n\tgf_isom_box_dump_done(\"ItemProtectionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err infe_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ItemInfoEntryBox *p = (GF_ItemInfoEntryBox *)a;\n\tgf_isom_box_dump_start(a, \"ItemInfoEntryBox\", trace);\n\tfprintf(trace, \"item_ID=\\\"%d\\\" item_protection_index=\\\"%d\\\" item_name=\\\"%s\\\" content_type=\\\"%s\\\" content_encoding=\\\"%s\\\" item_type=\\\"%s\\\">\\n\", p->item_ID, p->item_protection_index, p->item_name, p->content_type, p->content_encoding, gf_4cc_to_str(p->item_type));\n\tgf_isom_box_dump_done(\"ItemInfoEntryBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err iinf_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ItemInfoBox *p = (GF_ItemInfoBox *)a;\n\tgf_isom_box_dump_start(a, \"ItemInfoBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_array_dump(p->item_infos, trace);\n\tgf_isom_box_dump_done(\"ItemInfoBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err iloc_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i, j, count, count2;\n\tGF_ItemLocationBox *p = (GF_ItemLocationBox*)a;\n\tgf_isom_box_dump_start(a, \"ItemLocationBox\", trace);\n\tfprintf(trace, \"offset_size=\\\"%d\\\" length_size=\\\"%d\\\" base_offset_size=\\\"%d\\\" index_size=\\\"%d\\\">\\n\", p->offset_size, p->length_size, p->base_offset_size, p->index_size);\n\tcount = gf_list_count(p->location_entries);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ItemLocationEntry *ie = (GF_ItemLocationEntry *)gf_list_get(p->location_entries, i);\n\t\tcount2 = gf_list_count(ie->extent_entries);\n\t\tfprintf(trace, \"<ItemLocationEntry item_ID=\\\"%d\\\" data_reference_index=\\\"%d\\\" base_offset=\\\"\"LLD\"\\\" construction_method=\\\"%d\\\">\\n\", ie->item_ID, ie->data_reference_index, LLD_CAST ie->base_offset, ie->construction_method);\n\t\tfor (j=0; j<count2; j++) {\n\t\t\tGF_ItemExtentEntry *iee = (GF_ItemExtentEntry *)gf_list_get(ie->extent_entries, j);\n\t\t\tfprintf(trace, \"<ItemExtentEntry extent_offset=\\\"\"LLD\"\\\" extent_length=\\\"\"LLD\"\\\" extent_index=\\\"\"LLD\"\\\" />\\n\", LLD_CAST iee->extent_offset, LLD_CAST iee->extent_length, LLD_CAST iee->extent_index);\n\t\t}\n\t\tfprintf(trace, \"</ItemLocationEntry>\\n\");\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<ItemLocationEntry item_ID=\\\"\\\" data_reference_index=\\\"\\\" base_offset=\\\"\\\" construction_method=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<ItemExtentEntry extent_offset=\\\"\\\" extent_length=\\\"\\\" extent_index=\\\"\\\" />\\n\");\n\t\tfprintf(trace, \"</ItemLocationEntry>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"ItemLocationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err iref_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ItemReferenceBox *p = (GF_ItemReferenceBox *)a;\n\tgf_isom_box_dump_start(a, \"ItemReferenceBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_array_dump(p->references, trace);\n\tgf_isom_box_dump_done(\"ItemReferenceBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err hinf_dump(GF_Box *a, FILE * trace)\n{\n//\tGF_HintInfoBox *p  = (GF_HintInfoBox *)a;\n\tgf_isom_box_dump_start(a, \"HintInfoBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HintInfoBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err trpy_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TRPYBox *p = (GF_TRPYBox *)a;\n\tgf_isom_box_dump_start(a, \"LargeTotalRTPBytesBox\", trace);\n\tfprintf(trace, \"RTPBytesSent=\\\"\"LLD\"\\\">\\n\", LLD_CAST p->nbBytes);\n\tgf_isom_box_dump_done(\"LargeTotalRTPBytesBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err totl_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TOTLBox *p;\n\n\tp = (GF_TOTLBox *)a;\n\tgf_isom_box_dump_start(a, \"TotalRTPBytesBox\", trace);\n\tfprintf(trace, \"RTPBytesSent=\\\"%d\\\">\\n\", p->nbBytes);\n\tgf_isom_box_dump_done(\"TotalRTPBytesBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err nump_dump(GF_Box *a, FILE * trace)\n{\n\tGF_NUMPBox *p;\n\n\tp = (GF_NUMPBox *)a;\n\tgf_isom_box_dump_start(a, \"LargeTotalPacketBox\", trace);\n\tfprintf(trace, \"PacketsSent=\\\"\"LLD\"\\\">\\n\", LLD_CAST p->nbPackets);\n\tgf_isom_box_dump_done(\"LargeTotalPacketBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err npck_dump(GF_Box *a, FILE * trace)\n{\n\tGF_NPCKBox *p;\n\tp = (GF_NPCKBox *)a;\n\tgf_isom_box_dump_start(a, \"TotalPacketBox\", trace);\n\tfprintf(trace, \"packetsSent=\\\"%d\\\">\\n\", p->nbPackets);\n\tgf_isom_box_dump_done(\"TotalPacketBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tpyl_dump(GF_Box *a, FILE * trace)\n{\n\tGF_NTYLBox *p;\n\tp = (GF_NTYLBox *)a;\n\tgf_isom_box_dump_start(a, \"LargeTotalMediaBytesBox\", trace);\n\tfprintf(trace, \"BytesSent=\\\"\"LLD\"\\\">\\n\", LLD_CAST p->nbBytes);\n\tgf_isom_box_dump_done(\"LargeTotalMediaBytesBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tpay_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TPAYBox *p;\n\tp = (GF_TPAYBox *)a;\n\tgf_isom_box_dump_start(a, \"TotalMediaBytesBox\", trace);\n\tfprintf(trace, \"BytesSent=\\\"%d\\\">\\n\", p->nbBytes);\n\tgf_isom_box_dump_done(\"TotalMediaBytesBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err maxr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MAXRBox *p;\n\tp = (GF_MAXRBox *)a;\n\tgf_isom_box_dump_start(a, \"MaxDataRateBox\", trace);\n\tfprintf(trace, \"MaxDataRate=\\\"%d\\\" Granularity=\\\"%d\\\">\\n\", p->maxDataRate, p->granularity);\n\tgf_isom_box_dump_done(\"MaxDataRateBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err dmed_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DMEDBox *p;\n\n\tp = (GF_DMEDBox *)a;\n\tgf_isom_box_dump_start(a, \"BytesFromMediaTrackBox\", trace);\n\tfprintf(trace, \"BytesSent=\\\"\"LLD\"\\\">\\n\", LLD_CAST p->nbBytes);\n\tgf_isom_box_dump_done(\"BytesFromMediaTrackBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err dimm_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DIMMBox *p;\n\tp = (GF_DIMMBox *)a;\n\tgf_isom_box_dump_start(a, \"ImmediateDataBytesBox\", trace);\n\tfprintf(trace, \"BytesSent=\\\"\"LLD\"\\\">\\n\", LLD_CAST p->nbBytes);\n\tgf_isom_box_dump_done(\"ImmediateDataBytesBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err drep_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DREPBox *p;\n\tp = (GF_DREPBox *)a;\n\tgf_isom_box_dump_start(a, \"RepeatedDataBytesBox\", trace);\n\tfprintf(trace, \"RepeatedBytes=\\\"\"LLD\"\\\">\\n\", LLD_CAST p->nbBytes);\n\tgf_isom_box_dump_done(\"RepeatedDataBytesBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tssy_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TimeStampSynchronyBox *p = (GF_TimeStampSynchronyBox *)a;\n\tgf_isom_box_dump_start(a, \"TimeStampSynchronyBox\", trace);\n\tfprintf(trace, \"timestamp_sync=\\\"%d\\\">\\n\", p->timestamp_sync);\n\tgf_isom_box_dump_done(\"TimeStampSynchronyBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err rssr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ReceivedSsrcBox *p = (GF_ReceivedSsrcBox *)a;\n\tgf_isom_box_dump_start(a, \"ReceivedSsrcBox\", trace);\n\tfprintf(trace, \"SSRC=\\\"%d\\\">\\n\", p->ssrc);\n\tgf_isom_box_dump_done(\"ReceivedSsrcBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tmin_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TMINBox *p;\n\tp = (GF_TMINBox *)a;\n\tgf_isom_box_dump_start(a, \"MinTransmissionTimeBox\", trace);\n\tfprintf(trace, \"MinimumTransmitTime=\\\"%d\\\">\\n\", p->minTime);\n\tgf_isom_box_dump_done(\"MinTransmissionTimeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tmax_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TMAXBox *p;\n\tp = (GF_TMAXBox *)a;\n\tgf_isom_box_dump_start(a, \"MaxTransmissionTimeBox\", trace);\n\tfprintf(trace, \"MaximumTransmitTime=\\\"%d\\\">\\n\", p->maxTime);\n\tgf_isom_box_dump_done(\"MaxTransmissionTimeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err pmax_dump(GF_Box *a, FILE * trace)\n{\n\tGF_PMAXBox *p;\n\tp = (GF_PMAXBox *)a;\n\tgf_isom_box_dump_start(a, \"MaxPacketSizeBox\", trace);\n\tfprintf(trace, \"MaximumSize=\\\"%d\\\">\\n\", p->maxSize);\n\tgf_isom_box_dump_done(\"MaxPacketSizeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err dmax_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DMAXBox *p;\n\tp = (GF_DMAXBox *)a;\n\tgf_isom_box_dump_start(a, \"MaxPacketDurationBox\", trace);\n\tfprintf(trace, \"MaximumDuration=\\\"%d\\\">\\n\", p->maxDur);\n\tgf_isom_box_dump_done(\"MaxPacketDurationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err payt_dump(GF_Box *a, FILE * trace)\n{\n\tGF_PAYTBox *p;\n\tp = (GF_PAYTBox *)a;\n\tgf_isom_box_dump_start(a, \"PayloadTypeBox\", trace);\n\tfprintf(trace, \"PayloadID=\\\"%d\\\" PayloadString=\\\"%s\\\">\\n\", p->payloadCode, p->payloadString);\n\tgf_isom_box_dump_done(\"PayloadTypeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err name_dump(GF_Box *a, FILE * trace)\n{\n\tGF_NameBox *p;\n\tp = (GF_NameBox *)a;\n\tgf_isom_box_dump_start(a, \"NameBox\", trace);\n\tfprintf(trace, \"Name=\\\"%s\\\">\\n\", p->string);\n\tgf_isom_box_dump_done(\"NameBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err rely_dump(GF_Box *a, FILE * trace)\n{\n\tGF_RelyHintBox *p;\n\tp = (GF_RelyHintBox *)a;\n\tgf_isom_box_dump_start(a, \"RelyTransmissionBox\", trace);\n\tfprintf(trace, \"Prefered=\\\"%d\\\" required=\\\"%d\\\">\\n\", p->prefered, p->required);\n\tgf_isom_box_dump_done(\"RelyTransmissionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err snro_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SeqOffHintEntryBox *p;\n\tp = (GF_SeqOffHintEntryBox *)a;\n\tgf_isom_box_dump_start(a, \"PacketSequenceOffsetBox\", trace);\n\tfprintf(trace, \"SeqNumOffset=\\\"%d\\\">\\n\", p->SeqOffset);\n\tgf_isom_box_dump_done(\"PacketSequenceOffsetBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tims_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TSHintEntryBox *p;\n\tp = (GF_TSHintEntryBox *)a;\n\tgf_isom_box_dump_start(a, \"RTPTimeScaleBox\", trace);\n\tfprintf(trace, \"TimeScale=\\\"%d\\\">\\n\", p->timeScale);\n\tgf_isom_box_dump_done(\"RTPTimeScaleBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tsro_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TimeOffHintEntryBox *p;\n\tp = (GF_TimeOffHintEntryBox *)a;\n\tgf_isom_box_dump_start(a, \"TimeStampOffsetBox\", trace);\n\tfprintf(trace, \"TimeStampOffset=\\\"%d\\\">\\n\", p->TimeOffset);\n\tgf_isom_box_dump_done(\"TimeStampOffsetBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err ghnt_dump(GF_Box *a, FILE * trace)\n{\n\tchar *name;\n\tGF_HintSampleEntryBox *p;\n\tp = (GF_HintSampleEntryBox *)a;\n\n\tif (a->type == GF_ISOM_BOX_TYPE_RTP_STSD) {\n\t\tname = \"RTPHintSampleEntryBox\";\n\t} else if (a->type == GF_ISOM_BOX_TYPE_SRTP_STSD) {\n\t\tname = \"SRTPHintSampleEntryBox\";\n\t} else if (a->type == GF_ISOM_BOX_TYPE_FDP_STSD) {\n\t\tname = \"FDPHintSampleEntryBox\";\n\t} else if (a->type == GF_ISOM_BOX_TYPE_RRTP_STSD) {\n\t\tname = \"RTPReceptionHintSampleEntryBox\";\n\t} else if (a->type == GF_ISOM_BOX_TYPE_RTCP_STSD) {\n\t\tname = \"RTCPReceptionHintSampleEntryBox\";\n\t} else {\n\t\tname = \"GenericHintSampleEntryBox\";\n\t}\n\tgf_isom_box_dump_start(a, name, trace);\n\tfprintf(trace, \"DataReferenceIndex=\\\"%d\\\" HintTrackVersion=\\\"%d\\\" LastCompatibleVersion=\\\"%d\\\"\", p->dataReferenceIndex, p->HintTrackVersion, p->LastCompatibleVersion);\n\tif ((a->type == GF_ISOM_BOX_TYPE_RTP_STSD) || (a->type == GF_ISOM_BOX_TYPE_SRTP_STSD) || (a->type == GF_ISOM_BOX_TYPE_RRTP_STSD) || (a->type == GF_ISOM_BOX_TYPE_RTCP_STSD)) {\n\t\tfprintf(trace, \" MaxPacketSize=\\\"%d\\\"\", p->MaxPacketSize);\n\t} else if (a->type == GF_ISOM_BOX_TYPE_FDP_STSD) {\n\t\tfprintf(trace, \" partition_entry_ID=\\\"%d\\\" FEC_overhead=\\\"%d\\\"\", p->partition_entry_ID, p->FEC_overhead);\n\t}\n\tfprintf(trace, \">\\n\");\n\n\tgf_isom_box_dump_done(name, a, trace);\n\treturn GF_OK;\n}\n\nGF_Err hnti_dump(GF_Box *a, FILE * trace)\n{\n\tgf_isom_box_dump_start(a, \"HintTrackInfoBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HintTrackInfoBox\", NULL, trace);\n\treturn GF_OK;\n}\n\nGF_Err sdp_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SDPBox *p = (GF_SDPBox *)a;\n\tgf_isom_box_dump_start(a, \"SDPBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->sdpText)\n\t\tfprintf(trace, \"<!-- sdp text: %s -->\\n\", p->sdpText);\n\tgf_isom_box_dump_done(\"SDPBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err rtp_hnti_dump(GF_Box *a, FILE * trace)\n{\n\tGF_RTPBox *p = (GF_RTPBox *)a;\n\tgf_isom_box_dump_start(a, \"RTPMovieHintInformationBox\", trace);\n\tfprintf(trace, \"descriptionformat=\\\"%s\\\">\\n\", gf_4cc_to_str(p->subType));\n\tif (p->sdpText)\n\t\tfprintf(trace, \"<!-- sdp text: %s -->\\n\", p->sdpText);\n\tgf_isom_box_dump_done(\"RTPMovieHintInformationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err rtpo_dump(GF_Box *a, FILE * trace)\n{\n\tGF_RTPOBox *p;\n\tp = (GF_RTPOBox *)a;\n\tgf_isom_box_dump_start(a, \"RTPTimeOffsetBox\", trace);\n\tfprintf(trace, \"PacketTimeOffset=\\\"%d\\\">\\n\", p->timeOffset);\n\tgf_isom_box_dump_done(\"RTPTimeOffsetBox\", a, trace);\n\treturn GF_OK;\n}\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nGF_Err mvex_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MovieExtendsBox *p;\n\tp = (GF_MovieExtendsBox *)a;\n\tgf_isom_box_dump_start(a, \"MovieExtendsBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->mehd) gf_isom_box_dump(p->mehd, trace);\n\tgf_isom_box_array_dump(p->TrackExList, trace);\n\tgf_isom_box_array_dump(p->TrackExPropList, trace);\n\tgf_isom_box_dump_done(\"MovieExtendsBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err mehd_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MovieExtendsHeaderBox *p = (GF_MovieExtendsHeaderBox*)a;\n\tgf_isom_box_dump_start(a, \"MovieExtendsHeaderBox\", trace);\n\tfprintf(trace, \"fragmentDuration=\\\"\"LLD\"\\\" >\\n\", LLD_CAST p->fragment_duration);\n\tgf_isom_box_dump_done(\"MovieExtendsHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nvoid sample_flags_dump(const char *name, u32 sample_flags, FILE * trace)\n{\n\tfprintf(trace, \"<%s\", name);\n\tfprintf(trace, \" IsLeading=\\\"%d\\\"\", GF_ISOM_GET_FRAG_LEAD(sample_flags) );\n\tfprintf(trace, \" SampleDependsOn=\\\"%d\\\"\", GF_ISOM_GET_FRAG_DEPENDS(sample_flags) );\n\tfprintf(trace, \" SampleIsDependedOn=\\\"%d\\\"\", GF_ISOM_GET_FRAG_DEPENDED(sample_flags) );\n\tfprintf(trace, \" SampleHasRedundancy=\\\"%d\\\"\", GF_ISOM_GET_FRAG_REDUNDANT(sample_flags) );\n\tfprintf(trace, \" SamplePadding=\\\"%d\\\"\", GF_ISOM_GET_FRAG_PAD(sample_flags) );\n\tfprintf(trace, \" SampleSync=\\\"%d\\\"\", GF_ISOM_GET_FRAG_SYNC(sample_flags));\n\tfprintf(trace, \" SampleDegradationPriority=\\\"%d\\\"\", GF_ISOM_GET_FRAG_DEG(sample_flags));\n\tfprintf(trace, \"/>\\n\");\n}\n\nGF_Err trex_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackExtendsBox *p;\n\tp = (GF_TrackExtendsBox *)a;\n\tgf_isom_box_dump_start(a, \"TrackExtendsBox\", trace);\n\tfprintf(trace, \"TrackID=\\\"%d\\\"\", p->trackID);\n\tfprintf(trace, \" SampleDescriptionIndex=\\\"%d\\\" SampleDuration=\\\"%d\\\" SampleSize=\\\"%d\\\"\", p->def_sample_desc_index, p->def_sample_duration, p->def_sample_size);\n\tfprintf(trace, \">\\n\");\n\tsample_flags_dump(\"DefaultSampleFlags\", p->def_sample_flags, trace);\n\tgf_isom_box_dump_done(\"TrackExtendsBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err trep_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackExtensionPropertiesBox *p = (GF_TrackExtensionPropertiesBox*)a;\n\tgf_isom_box_dump_start(a, \"TrackExtensionPropertiesBox\", trace);\n\tfprintf(trace, \"TrackID=\\\"%d\\\">\\n\", p->trackID);\n\tgf_isom_box_dump_done(\"TrackExtensionPropertiesBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err moof_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MovieFragmentBox *p;\n\tp = (GF_MovieFragmentBox *)a;\n\tgf_isom_box_dump_start(a, \"MovieFragmentBox\", trace);\n\tfprintf(trace, \"TrackFragments=\\\"%d\\\">\\n\", gf_list_count(p->TrackList));\n\tif (p->mfhd) gf_isom_box_dump(p->mfhd, trace);\n\tgf_isom_box_array_dump(p->TrackList, trace);\n\tgf_isom_box_dump_done(\"MovieFragmentBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err mfhd_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MovieFragmentHeaderBox *p;\n\tp = (GF_MovieFragmentHeaderBox *)a;\n\tgf_isom_box_dump_start(a, \"MovieFragmentHeaderBox\", trace);\n\tfprintf(trace, \"FragmentSequenceNumber=\\\"%d\\\">\\n\", p->sequence_number);\n\tgf_isom_box_dump_done(\"MovieFragmentHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err traf_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackFragmentBox *p;\n\tp = (GF_TrackFragmentBox *)a;\n\tgf_isom_box_dump_start(a, \"TrackFragmentBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->tfhd) gf_isom_box_dump(p->tfhd, trace);\n\tif (p->sdtp) gf_isom_box_dump(p->sdtp, trace);\n\tif (p->tfdt) gf_isom_box_dump(p->tfdt, trace);\n\tif (p->sub_samples) gf_isom_box_array_dump(p->sub_samples, trace);\n\tif (p->sampleGroupsDescription) gf_isom_box_array_dump(p->sampleGroupsDescription, trace);\n\tif (p->sampleGroups) gf_isom_box_array_dump(p->sampleGroups, trace);\n\tgf_isom_box_array_dump(p->TrackRuns, trace);\n\tif (p->sai_sizes) gf_isom_box_array_dump(p->sai_sizes, trace);\n\tif (p->sai_offsets) gf_isom_box_array_dump(p->sai_offsets, trace);\n\tif (p->sample_encryption) gf_isom_box_dump(p->sample_encryption, trace);\n\tgf_isom_box_dump_done(\"TrackFragmentBox\", a, trace);\n\treturn GF_OK;\n}\n\nstatic void frag_dump_sample_flags(FILE * trace, u32 flags)\n{\n\tfprintf(trace, \" SamplePadding=\\\"%d\\\" Sync=\\\"%d\\\" DegradationPriority=\\\"%d\\\" IsLeading=\\\"%d\\\" DependsOn=\\\"%d\\\" IsDependedOn=\\\"%d\\\" HasRedundancy=\\\"%d\\\"\",\n\t        GF_ISOM_GET_FRAG_PAD(flags), GF_ISOM_GET_FRAG_SYNC(flags), GF_ISOM_GET_FRAG_DEG(flags),\n\t        GF_ISOM_GET_FRAG_LEAD(flags), GF_ISOM_GET_FRAG_DEPENDS(flags), GF_ISOM_GET_FRAG_DEPENDED(flags), GF_ISOM_GET_FRAG_REDUNDANT(flags));\n}\n\nGF_Err tfhd_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackFragmentHeaderBox *p;\n\tp = (GF_TrackFragmentHeaderBox *)a;\n\tgf_isom_box_dump_start(a, \"TrackFragmentHeaderBox\", trace);\n\tfprintf(trace, \"TrackID=\\\"%u\\\"\", p->trackID);\n\n\tif (p->flags & GF_ISOM_TRAF_BASE_OFFSET) {\n\t\tfprintf(trace, \" BaseDataOffset=\\\"\"LLU\"\\\"\", p->base_data_offset);\n\t} else {\n\t\tfprintf(trace, \" BaseDataOffset=\\\"%s\\\"\", (p->flags & GF_ISOM_MOOF_BASE_OFFSET) ? \"moof\" : \"moof-or-previous-traf\");\n\t}\n\n\tif (p->flags & GF_ISOM_TRAF_SAMPLE_DESC)\n\t\tfprintf(trace, \" SampleDescriptionIndex=\\\"%u\\\"\", p->sample_desc_index);\n\tif (p->flags & GF_ISOM_TRAF_SAMPLE_DUR)\n\t\tfprintf(trace, \" SampleDuration=\\\"%u\\\"\", p->def_sample_duration);\n\tif (p->flags & GF_ISOM_TRAF_SAMPLE_SIZE)\n\t\tfprintf(trace, \" SampleSize=\\\"%u\\\"\", p->def_sample_size);\n\n\tif (p->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) {\n\t\tfrag_dump_sample_flags(trace, p->def_sample_flags);\n\t}\n\n\tfprintf(trace, \">\\n\");\n\n\tgf_isom_box_dump_done(\"TrackFragmentHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tfxd_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"MSSTimeExtensionBox\", trace);\n\tfprintf(trace, \"AbsoluteTime=\\\"\"LLU\"\\\" FragmentDuration=\\\"\"LLU\"\\\">\\n\", ptr->absolute_time_in_track_timescale, ptr->fragment_duration_in_track_timescale);\n\tfprintf(trace, \"<FullBoxInfo Version=\\\"%d\\\" Flags=\\\"%d\\\"/>\\n\", ptr->version, ptr->flags);\n\tgf_isom_box_dump_done(\"MSSTimeExtensionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err trun_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentRunBox *p;\n\n\tp = (GF_TrackFragmentRunBox *)a;\n\tgf_isom_box_dump_start(a, \"TrackRunBox\", trace);\n\tfprintf(trace, \"SampleCount=\\\"%d\\\"\", p->sample_count);\n\n\tif (p->flags & GF_ISOM_TRUN_DATA_OFFSET)\n\t\tfprintf(trace, \" DataOffset=\\\"%d\\\"\", p->data_offset);\n\tfprintf(trace, \">\\n\");\n\n\tif (p->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\tsample_flags_dump(\"FirstSampleFlags\", p->first_sample_flags, trace);\n\t}\n\n\tif (p->flags & (GF_ISOM_TRUN_DURATION|GF_ISOM_TRUN_SIZE|GF_ISOM_TRUN_CTS_OFFSET|GF_ISOM_TRUN_FLAGS)) {\n\t\ti=0;\n\t\twhile ((ent = (GF_TrunEntry *)gf_list_enum(p->entries, &i))) {\n\n\t\t\tfprintf(trace, \"<TrackRunEntry\");\n\n\t\t\tif (p->flags & GF_ISOM_TRUN_DURATION)\n\t\t\t\tfprintf(trace, \" Duration=\\\"%u\\\"\", ent->Duration);\n\t\t\tif (p->flags & GF_ISOM_TRUN_SIZE)\n\t\t\t\tfprintf(trace, \" Size=\\\"%u\\\"\", ent->size);\n\t\t\tif (p->flags & GF_ISOM_TRUN_CTS_OFFSET)\n\t\t\t{\n\t\t\t\tif (p->version == 0)\n\t\t\t\t\tfprintf(trace, \" CTSOffset=\\\"%u\\\"\", (u32) ent->CTS_Offset);\n\t\t\t\telse\n\t\t\t\t\tfprintf(trace, \" CTSOffset=\\\"%d\\\"\", ent->CTS_Offset);\n\t\t\t}\n\n\t\t\tif (p->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\tfrag_dump_sample_flags(trace, ent->flags);\n\t\t\t}\n\t\t\tfprintf(trace, \"/>\\n\");\n\t\t}\n\t} else if (p->size) {\n\t\tfprintf(trace, \"<!-- all default values used -->\\n\");\n\t} else {\n\t\tfprintf(trace, \"<TrackRunEntry Duration=\\\"\\\" Size=\\\"\\\" CTSOffset=\\\"\\\"\");\n\t\tfrag_dump_sample_flags(trace, 0);\n\t\tfprintf(trace, \"/>\\n\");\n\t}\n\n\tgf_isom_box_dump_done(\"TrackRunBox\", a, trace);\n\treturn GF_OK;\n}\n\n#endif\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\nGF_Err DTE_Dump(GF_List *dte, FILE * trace)\n{\n\tGF_GenericDTE *p;\n\tGF_ImmediateDTE *i_p;\n\tGF_SampleDTE *s_p;\n\tGF_StreamDescDTE *sd_p;\n\tu32 i, count;\n\n\tcount = gf_list_count(dte);\n\tfor (i=0; i<count; i++) {\n\t\tp = (GF_GenericDTE *)gf_list_get(dte, i);\n\t\tswitch (p->source) {\n\t\tcase 0:\n\t\t\tfprintf(trace, \"<EmptyDataEntry/>\\n\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ti_p = (GF_ImmediateDTE *) p;\n\t\t\tfprintf(trace, \"<ImmediateDataEntry DataSize=\\\"%d\\\"/>\\n\", i_p->dataLength);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ts_p = (GF_SampleDTE *) p;\n\t\t\tfprintf(trace, \"<SampleDataEntry DataSize=\\\"%d\\\" SampleOffset=\\\"%d\\\" SampleNumber=\\\"%d\\\" TrackReference=\\\"%d\\\"/>\\n\",\n\t\t\t        s_p->dataLength, s_p->byteOffset, s_p->sampleNumber, s_p->trackRefIndex);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tsd_p = (GF_StreamDescDTE *) p;\n\t\t\tfprintf(trace, \"<SampleDescriptionEntry DataSize=\\\"%d\\\" DescriptionOffset=\\\"%d\\\" StreamDescriptionindex=\\\"%d\\\" TrackReference=\\\"%d\\\"/>\\n\",\n\t\t\t        sd_p->dataLength, sd_p->byteOffset, sd_p->streamDescIndex, sd_p->trackRefIndex);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(trace, \"<UnknownTableEntry/>\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_dump_hint_sample(GF_ISOFile *the_file, u32 trackNumber, u32 SampleNum, FILE * trace)\n{\n\tGF_ISOSample *tmp;\n\tGF_HintSampleEntryBox *entry;\n\tu32 descIndex, count, count2, i;\n\tGF_Err e=GF_OK;\n\tGF_BitStream *bs;\n\tGF_HintSample *s;\n\tGF_TrackBox *trak;\n\tGF_RTPPacket *pck;\n\tchar *szName;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !IsHintTrack(trak)) return GF_BAD_PARAM;\n\n\ttmp = gf_isom_get_sample(the_file, trackNumber, SampleNum, &descIndex);\n\tif (!tmp) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, descIndex, (GF_SampleEntryBox **) &entry, &count);\n\tif (e) {\n\t\tgf_isom_sample_del(&tmp);\n\t\treturn e;\n\t}\n\n\t//check we can read the sample\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_RTP_STSD:\n\tcase GF_ISOM_BOX_TYPE_SRTP_STSD:\n\tcase GF_ISOM_BOX_TYPE_RRTP_STSD:\n\t\tszName = \"RTP\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_RTCP_STSD:\n\t\tszName = \"RCTP\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_FDP_STSD:\n\t\tszName = \"FDP\";\n\t\tbreak;\n\tdefault:\n\t\tgf_isom_sample_del(&tmp);\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tbs = gf_bs_new(tmp->data, tmp->dataLength, GF_BITSTREAM_READ);\n\ts = gf_isom_hint_sample_new(entry->type);\n\ts->trackID = trak->Header->trackID;\n\ts->sampleNumber = SampleNum;\n\n\tgf_isom_hint_sample_read(s, bs, tmp->dataLength);\n\tgf_bs_del(bs);\n\n\tcount = gf_list_count(s->packetTable);\n\n\tfprintf(trace, \"<%sHintSample SampleNumber=\\\"%d\\\" DecodingTime=\\\"\"LLD\"\\\" RandomAccessPoint=\\\"%d\\\" PacketCount=\\\"%u\\\" reserved=\\\"%u\\\">\\n\", szName, SampleNum, LLD_CAST tmp->DTS, tmp->IsRAP, s->packetCount, s->reserved);\n\n\tif (s->hint_subtype==GF_ISOM_BOX_TYPE_FDP_STSD) {\n\t\te = gf_isom_box_dump((GF_Box*) s, trace);\n\t\tgoto err_exit;\n\t}\n\n\tif (s->packetCount != count) {\n\t\tfprintf(trace, \"<!-- WARNING: Broken %s hint sample, %d entries indicated but only %d parsed -->\\n\", szName, s->packetCount, count);\n\t}\n\n\n\tfor (i=0; i<count; i++) {\n\t\tpck = (GF_RTPPacket *)gf_list_get(s->packetTable, i);\n\n\t\tif (pck->hint_subtype==GF_ISOM_BOX_TYPE_RTCP_STSD) {\n\t\t\tGF_RTCPPacket *rtcp_pck = (GF_RTCPPacket *) pck;\n\t\t\tfprintf(trace, \"<RTCPHintPacket PacketNumber=\\\"%d\\\" V=\\\"%d\\\" P=\\\"%d\\\" Count=\\\"%d\\\" PayloadType=\\\"%d\\\" \",\n\t\t        i+1,  rtcp_pck->Version, rtcp_pck->Padding, rtcp_pck->Count, rtcp_pck->PayloadType);\n\n\t\t\tif (rtcp_pck->data) dump_data_attribute(trace, \"payload\", (char*)rtcp_pck->data, rtcp_pck->length);\n\t\t\tfprintf(trace, \">\\n\");\n\t\t\tfprintf(trace, \"</RTCPHintPacket>\\n\");\n\n\t\t} else {\n\t\t\tfprintf(trace, \"<RTPHintPacket PacketNumber=\\\"%d\\\" P=\\\"%d\\\" X=\\\"%d\\\" M=\\\"%d\\\" PayloadType=\\\"%d\\\"\",\n\t\t        i+1,  pck->P_bit, pck->X_bit, pck->M_bit, pck->payloadType);\n\n\t\t\tfprintf(trace, \" SequenceNumber=\\\"%d\\\" RepeatedPacket=\\\"%d\\\" DropablePacket=\\\"%d\\\" RelativeTransmissionTime=\\\"%d\\\" FullPacketSize=\\\"%d\\\">\\n\",\n\t\t        pck->SequenceNumber, pck->R_bit, pck->B_bit, pck->relativeTransTime, gf_isom_hint_rtp_length(pck));\n\n\n\t\t\t//TLV is made of Boxes\n\t\t\tcount2 = gf_list_count(pck->TLV);\n\t\t\tif (count2) {\n\t\t\t\tfprintf(trace, \"<PrivateExtensionTable EntryCount=\\\"%d\\\">\\n\", count2);\n\t\t\t\tgf_isom_box_array_dump(pck->TLV, trace);\n\t\t\t\tfprintf(trace, \"</PrivateExtensionTable>\\n\");\n\t\t\t}\n\t\t\t//DTE is made of NON boxes\n\t\t\tcount2 = gf_list_count(pck->DataTable);\n\t\t\tif (count2) {\n\t\t\t\tfprintf(trace, \"<PacketDataTable EntryCount=\\\"%d\\\">\\n\", count2);\n\t\t\t\tDTE_Dump(pck->DataTable, trace);\n\t\t\t\tfprintf(trace, \"</PacketDataTable>\\n\");\n\t\t\t}\n\t\t\tfprintf(trace, \"</RTPHintPacket>\\n\");\n\t\t}\n\t}\n\nerr_exit:\n\tfprintf(trace, \"</%sHintSample>\\n\", szName);\n\tgf_isom_sample_del(&tmp);\n\tgf_isom_hint_sample_del(s);\n\treturn e;\n}\n\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\nstatic void tx3g_dump_box_nobox(FILE * trace, GF_BoxRecord *rec)\n{\n\tfprintf(trace, \"<TextBox top=\\\"%d\\\" left=\\\"%d\\\" bottom=\\\"%d\\\" right=\\\"%d\\\"/>\\n\", rec->top, rec->left, rec->bottom, rec->right);\n}\n\nstatic void tx3g_print_char_offsets(FILE * trace, u32 start, u32 end, u32 *shift_offset, u32 so_count)\n{\n\tu32 i;\n\tif (shift_offset) {\n\t\tfor (i=0; i<so_count; i++) {\n\t\t\tif (start>shift_offset[i]) {\n\t\t\t\tstart --;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i<so_count; i++) {\n\t\t\tif (end>shift_offset[i]) {\n\t\t\t\tend --;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (start || end) fprintf(trace, \"fromChar=\\\"%d\\\" toChar=\\\"%d\\\" \", start, end);\n}\n\nstatic void tx3g_dump_style_nobox(FILE * trace, GF_StyleRecord *rec, u32 *shift_offset, u32 so_count)\n{\n\tfprintf(trace, \"<Style \");\n\tif (rec->startCharOffset || rec->endCharOffset)\n\t\ttx3g_print_char_offsets(trace, rec->startCharOffset, rec->endCharOffset, shift_offset, so_count);\n\n\tfprintf(trace, \"styles=\\\"\");\n\tif (!rec->style_flags) {\n\t\tfprintf(trace, \"Normal\");\n\t} else {\n\t\tif (rec->style_flags & 1) fprintf(trace, \"Bold \");\n\t\tif (rec->style_flags & 2) fprintf(trace, \"Italic \");\n\t\tif (rec->style_flags & 4) fprintf(trace, \"Underlined \");\n\t}\n\tfprintf(trace, \"\\\" fontID=\\\"%d\\\" fontSize=\\\"%d\\\" \", rec->fontID, rec->font_size);\n\ttx3g_dump_rgba8(trace, \"color\", rec->text_color);\n\tfprintf(trace, \"/>\\n\");\n}\n\nstatic char *tx3g_format_time(u64 ts, u32 timescale, char *szDur, Bool is_srt)\n{\n\tu32 h, m, s, ms;\n\tts = (u32) (ts*1000 / timescale);\n\th = (u32) (ts / 3600000);\n\tm = (u32) (ts/ 60000) - h*60;\n\ts = (u32) (ts/1000) - h*3600 - m*60;\n\tms = (u32) (ts) - h*3600000 - m*60000 - s*1000;\n\tif (is_srt) {\n\t\tsprintf(szDur, \"%02d:%02d:%02d,%03d\", h, m, s, ms);\n\t} else {\n\t\tsprintf(szDur, \"%02d:%02d:%02d.%03d\", h, m, s, ms);\n\t}\n\treturn szDur;\n}\n\nstatic GF_Err gf_isom_dump_ttxt_track(GF_ISOFile *the_file, u32 track, FILE *dump, Bool box_dump)\n{\n\tu32 i, j, count, di, nb_descs, shift_offset[20], so_count;\n\tu64 last_DTS;\n\tsize_t len;\n\tGF_Box *a;\n\tBool has_scroll;\n\tchar szDur[100];\n\tGF_Tx3gSampleEntryBox *txt;\n\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\ttxt = (GF_Tx3gSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, 0);\n\tswitch (txt->type) {\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STPP:\n\tcase GF_ISOM_BOX_TYPE_SBTT:\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (box_dump) {\n\t\tfprintf(dump, \"<TextTrack trackID=\\\"%d\\\" version=\\\"1.1\\\">\\n\", gf_isom_get_track_id(the_file, track) );\n\t} else {\n\t\tfprintf(dump, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\");\n\t\tfprintf(dump, \"<!-- GPAC 3GPP Text Stream -->\\n\");\n\n\t\tfprintf(dump, \"<TextStream version=\\\"1.1\\\">\\n\");\n\t}\n\tfprintf(dump, \"<TextStreamHeader width=\\\"%d\\\" height=\\\"%d\\\" layer=\\\"%d\\\" translation_x=\\\"%d\\\" translation_y=\\\"%d\\\">\\n\", trak->Header->width >> 16 , trak->Header->height >> 16, trak->Header->layer, trak->Header->matrix[6] >> 16, trak->Header->matrix[7] >> 16);\n\n\tnb_descs = gf_list_count(trak->Media->information->sampleTable->SampleDescription->other_boxes);\n\tfor (i=0; i<nb_descs; i++) {\n\t\tGF_Tx3gSampleEntryBox *txt = (GF_Tx3gSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, i);\n\n\t\tif (box_dump) {\n\t\t\tgf_isom_box_dump((GF_Box*) txt, dump);\n\t\t} else if  (txt->type==GF_ISOM_BOX_TYPE_TX3G) {\n\t\t\tfprintf(dump, \"<TextSampleDescription horizontalJustification=\\\"\");\n\t\t\tswitch (txt->horizontal_justification) {\n\t\t\tcase 1:\n\t\t\t\tfprintf(dump, \"center\");\n\t\t\t\tbreak;\n\t\t\tcase -1:\n\t\t\t\tfprintf(dump, \"right\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(dump, \"left\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfprintf(dump, \"\\\" verticalJustification=\\\"\");\n\t\t\tswitch (txt->vertical_justification) {\n\t\t\tcase 1:\n\t\t\t\tfprintf(dump, \"center\");\n\t\t\t\tbreak;\n\t\t\tcase -1:\n\t\t\t\tfprintf(dump, \"bottom\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(dump, \"top\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfprintf(dump, \"\\\" \");\n\t\t\ttx3g_dump_rgba8(dump, \"backColor\", txt->back_color);\n\t\t\tfprintf(dump, \" verticalText=\\\"%s\\\"\", (txt->displayFlags & GF_TXT_VERTICAL) ? \"yes\" : \"no\");\n\t\t\tfprintf(dump, \" fillTextRegion=\\\"%s\\\"\", (txt->displayFlags & GF_TXT_FILL_REGION) ? \"yes\" : \"no\");\n\t\t\tfprintf(dump, \" continuousKaraoke=\\\"%s\\\"\", (txt->displayFlags & GF_TXT_KARAOKE) ? \"yes\" : \"no\");\n\t\t\thas_scroll = GF_FALSE;\n\t\t\tif (txt->displayFlags & GF_TXT_SCROLL_IN) {\n\t\t\t\thas_scroll = GF_TRUE;\n\t\t\t\tif (txt->displayFlags & GF_TXT_SCROLL_OUT) fprintf(dump, \" scroll=\\\"InOut\\\"\");\n\t\t\t\telse fprintf(dump, \" scroll=\\\"In\\\"\");\n\t\t\t} else if (txt->displayFlags & GF_TXT_SCROLL_OUT) {\n\t\t\t\thas_scroll = GF_TRUE;\n\t\t\t\tfprintf(dump, \" scroll=\\\"Out\\\"\");\n\t\t\t} else {\n\t\t\t\tfprintf(dump, \" scroll=\\\"None\\\"\");\n\t\t\t}\n\t\t\tif (has_scroll) {\n\t\t\t\tu32 mode = (txt->displayFlags & GF_TXT_SCROLL_DIRECTION)>>7;\n\t\t\t\tswitch (mode) {\n\t\t\t\tcase GF_TXT_SCROLL_CREDITS:\n\t\t\t\t\tfprintf(dump, \" scrollMode=\\\"Credits\\\"\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_TXT_SCROLL_MARQUEE:\n\t\t\t\t\tfprintf(dump, \" scrollMode=\\\"Marquee\\\"\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_TXT_SCROLL_DOWN:\n\t\t\t\t\tfprintf(dump, \" scrollMode=\\\"Down\\\"\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_TXT_SCROLL_RIGHT:\n\t\t\t\t\tfprintf(dump, \" scrollMode=\\\"Right\\\"\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfprintf(dump, \" scrollMode=\\\"Unknown\\\"\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(dump, \">\\n\");\n\t\t\tfprintf(dump, \"<FontTable>\\n\");\n\t\t\tif (txt->font_table) {\n\t\t\t\tfor (j=0; j<txt->font_table->entry_count; j++) {\n\t\t\t\t\tfprintf(dump, \"<FontTableEntry fontName=\\\"%s\\\" fontID=\\\"%d\\\"/>\\n\", txt->font_table->fonts[j].fontName, txt->font_table->fonts[j].fontID);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(dump, \"</FontTable>\\n\");\n\t\t\tif ((txt->default_box.bottom == txt->default_box.top) || (txt->default_box.right == txt->default_box.left)) {\n\t\t\t\ttxt->default_box.top = txt->default_box.left = 0;\n\t\t\t\ttxt->default_box.right = trak->Header->width / 65536;\n\t\t\t\ttxt->default_box.bottom = trak->Header->height / 65536;\n\t\t\t}\n\t\t\ttx3g_dump_box_nobox(dump, &txt->default_box);\n\t\t\ttx3g_dump_style_nobox(dump, &txt->default_style, NULL, 0);\n\t\t\tfprintf(dump, \"</TextSampleDescription>\\n\");\n\t\t} else {\n\t\t\tGF_TextSampleEntryBox *text = (GF_TextSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, i);\n\t\t\tfprintf(dump, \"<TextSampleDescription horizontalJustification=\\\"\");\n\t\t\tswitch (text->textJustification) {\n\t\t\tcase 1:\n\t\t\t\tfprintf(dump, \"center\");\n\t\t\t\tbreak;\n\t\t\tcase -1:\n\t\t\t\tfprintf(dump, \"right\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(dump, \"left\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfprintf(dump, \"\\\"\");\n\n\t\t\ttx3g_dump_rgb16(dump, \" backColor\", text->background_color);\n\n\t\t\tif ((text->default_box.bottom == text->default_box.top) || (text->default_box.right == text->default_box.left)) {\n\t\t\t\ttext->default_box.top = text->default_box.left = 0;\n\t\t\t\ttext->default_box.right = trak->Header->width / 65536;\n\t\t\t\ttext->default_box.bottom = trak->Header->height / 65536;\n\t\t\t}\n\n\t\t\tif (text->displayFlags & GF_TXT_SCROLL_IN) {\n\t\t\t\tif (text->displayFlags & GF_TXT_SCROLL_OUT) fprintf(dump, \" scroll=\\\"InOut\\\"\");\n\t\t\t\telse fprintf(dump, \" scroll=\\\"In\\\"\");\n\t\t\t} else if (text->displayFlags & GF_TXT_SCROLL_OUT) {\n\t\t\t\tfprintf(dump, \" scroll=\\\"Out\\\"\");\n\t\t\t} else {\n\t\t\t\tfprintf(dump, \" scroll=\\\"None\\\"\");\n\t\t\t}\n\t\t\tfprintf(dump, \">\\n\");\n\n\t\t\ttx3g_dump_box_nobox(dump, &text->default_box);\n\t\t\tfprintf(dump, \"</TextSampleDescription>\\n\");\n\t\t}\n\t}\n\tfprintf(dump, \"</TextStreamHeader>\\n\");\n\n\tlast_DTS = 0;\n\tcount = gf_isom_get_sample_count(the_file, track);\n\tfor (i=0; i<count; i++) {\n\t\tGF_BitStream *bs;\n\t\tGF_TextSample *txt;\n\t\tGF_ISOSample *s = gf_isom_get_sample(the_file, track, i+1, &di);\n\t\tif (!s) continue;\n\n\t\tfprintf(dump, \"<TextSample sampleTime=\\\"%s\\\" sampleDescriptionIndex=\\\"%d\\\"\", tx3g_format_time(s->DTS, trak->Media->mediaHeader->timeScale, szDur, GF_FALSE), di);\n\t\tbs = gf_bs_new(s->data, s->dataLength, GF_BITSTREAM_READ);\n\t\ttxt = gf_isom_parse_texte_sample(bs);\n\t\tgf_bs_del(bs);\n\n\t\tif (!box_dump) {\n\t\t\tif (txt->highlight_color) {\n\t\t\t\tfprintf(dump, \" \");\n\t\t\t\ttx3g_dump_rgba8(dump, \"highlightColor\", txt->highlight_color->hil_color);\n\t\t\t}\n\t\t\tif (txt->scroll_delay) {\n\t\t\t\tDouble delay = txt->scroll_delay->scroll_delay;\n\t\t\t\tdelay /= trak->Media->mediaHeader->timeScale;\n\t\t\t\tfprintf(dump, \" scrollDelay=\\\"%g\\\"\", delay);\n\t\t\t}\n\t\t\tif (txt->wrap) fprintf(dump, \" wrap=\\\"%s\\\"\", (txt->wrap->wrap_flag==0x01) ? \"Automatic\" : \"None\");\n\t\t}\n\n\t\tso_count = 0;\n\n\t\tfprintf(dump, \" xml:space=\\\"preserve\\\">\");\n\t\tif (!txt->len) {\n\t\t\tlast_DTS = (u32) trak->Media->mediaHeader->duration;\n\t\t} else {\n\t\t\tunsigned short utf16Line[10000];\n\t\t\tlast_DTS = s->DTS;\n\t\t\t/*UTF16*/\n\t\t\tif ((txt->len>2) && ((unsigned char) txt->text[0] == (unsigned char) 0xFE) && ((unsigned char) txt->text[1] == (unsigned char) 0xFF)) {\n\t\t\t\t/*copy 2 more chars because the lib always add 2 '0' at the end for UTF16 end of string*/\n\t\t\t\tmemcpy((char *) utf16Line, txt->text+2, sizeof(char) * (txt->len));\n\t\t\t\tlen = gf_utf8_wcslen((const u16*)utf16Line);\n\t\t\t} else {\n\t\t\t\tchar *str;\n\t\t\t\tstr = txt->text;\n\t\t\t\tlen = gf_utf8_mbstowcs((u16*)utf16Line, 10000, (const char **) &str);\n\t\t\t}\n\t\t\tif (len != (size_t) -1) {\n\t\t\t\tutf16Line[len] = 0;\n\t\t\t\tfor (j=0; j<len; j++) {\n\t\t\t\t\tif ((utf16Line[j]=='\\n') || (utf16Line[j]=='\\r') || (utf16Line[j]==0x85) || (utf16Line[j]==0x2028) || (utf16Line[j]==0x2029) ) {\n\t\t\t\t\t\tfprintf(dump, \"\\n\");\n\t\t\t\t\t\tif ((utf16Line[j]=='\\r') && (utf16Line[j+1]=='\\n')) {\n\t\t\t\t\t\t\tshift_offset[so_count] = j;\n\t\t\t\t\t\t\tso_count++;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tswitch (utf16Line[j]) {\n\t\t\t\t\t\tcase '\\'':\n\t\t\t\t\t\t\tfprintf(dump, \"&apos;\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '\\\"':\n\t\t\t\t\t\t\tfprintf(dump, \"&quot;\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '&':\n\t\t\t\t\t\t\tfprintf(dump, \"&amp;\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '>':\n\t\t\t\t\t\t\tfprintf(dump, \"&gt;\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '<':\n\t\t\t\t\t\t\tfprintf(dump, \"&lt;\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tif (utf16Line[j] < 128) {\n\t\t\t\t\t\t\t\tfprintf(dump, \"%c\", (u8) utf16Line[j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfprintf(dump, \"&#%d;\", utf16Line[j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (box_dump) {\n\n\t\t\tif (txt->highlight_color)\n\t\t\t\tgf_isom_box_dump((GF_Box*) txt->highlight_color, dump);\n\t\t\tif (txt->scroll_delay)\n\t\t\t\tgf_isom_box_dump((GF_Box*) txt->scroll_delay, dump);\n\t\t\tif (txt->wrap)\n\t\t\t\tgf_isom_box_dump((GF_Box*) txt->wrap, dump);\n\t\t\tif (txt->box)\n\t\t\t\tgf_isom_box_dump((GF_Box*) txt->box, dump);\n\t\t\tif (txt->styles)\n\t\t\t\tgf_isom_box_dump((GF_Box*) txt->styles, dump);\n\t\t} else {\n\n\t\t\tif (txt->box) tx3g_dump_box_nobox(dump, &txt->box->box);\n\t\t\tif (txt->styles) {\n\t\t\t\tfor (j=0; j<txt->styles->entry_count; j++) {\n\t\t\t\t\ttx3g_dump_style_nobox(dump, &txt->styles->styles[j], shift_offset, so_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tj=0;\n\t\twhile ((a = (GF_Box *)gf_list_enum(txt->others, &j))) {\n\t\t\tif (box_dump) {\n\t\t\t\tgf_isom_box_dump((GF_Box*) a, dump);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (a->type) {\n\t\t\tcase GF_ISOM_BOX_TYPE_HLIT:\n\t\t\t\tfprintf(dump, \"<Highlight \");\n\t\t\t\ttx3g_print_char_offsets(dump, ((GF_TextHighlightBox *)a)->startcharoffset, ((GF_TextHighlightBox *)a)->endcharoffset, shift_offset, so_count);\n\t\t\t\tfprintf(dump, \"/>\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_BOX_TYPE_HREF:\n\t\t\t{\n\t\t\t\tGF_TextHyperTextBox *ht = (GF_TextHyperTextBox *)a;\n\t\t\t\tfprintf(dump, \"<HyperLink \");\n\t\t\t\ttx3g_print_char_offsets(dump, ht->startcharoffset, ht->endcharoffset, shift_offset, so_count);\n\t\t\t\tfprintf(dump, \"URL=\\\"%s\\\" URLToolTip=\\\"%s\\\"/>\\n\", ht->URL ? ht->URL : \"\", ht->URL_hint ? ht->URL_hint : \"\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase GF_ISOM_BOX_TYPE_BLNK:\n\t\t\t\tfprintf(dump, \"<Blinking \");\n\t\t\t\ttx3g_print_char_offsets(dump, ((GF_TextBlinkBox *)a)->startcharoffset, ((GF_TextBlinkBox *)a)->endcharoffset, shift_offset, so_count);\n\t\t\t\tfprintf(dump, \"/>\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_BOX_TYPE_KROK:\n\t\t\t{\n\t\t\t\tu32 k;\n\t\t\t\tDouble t;\n\t\t\t\tGF_TextKaraokeBox *krok = (GF_TextKaraokeBox *)a;\n\t\t\t\tt = krok->highlight_starttime;\n\t\t\t\tt /= trak->Media->mediaHeader->timeScale;\n\t\t\t\tfprintf(dump, \"<Karaoke startTime=\\\"%g\\\">\\n\", t);\n\t\t\t\tfor (k=0; k<krok->nb_entries; k++) {\n\t\t\t\t\tt = krok->records[k].highlight_endtime;\n\t\t\t\t\tt /= trak->Media->mediaHeader->timeScale;\n\t\t\t\t\tfprintf(dump, \"<KaraokeRange \");\n\t\t\t\t\ttx3g_print_char_offsets(dump, krok->records[k].start_charoffset, krok->records[k].end_charoffset, shift_offset, so_count);\n\t\t\t\t\tfprintf(dump, \"endTime=\\\"%g\\\"/>\\n\", t);\n\t\t\t\t}\n\t\t\t\tfprintf(dump, \"</Karaoke>\\n\");\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfprintf(dump, \"</TextSample>\\n\");\n\t\tgf_isom_sample_del(&s);\n\t\tgf_isom_delete_text_sample(txt);\n\t\tgf_set_progress(\"TTXT Extract\", i, count);\n\t}\n\tif (last_DTS < trak->Media->mediaHeader->duration) {\n\t\tfprintf(dump, \"<TextSample sampleTime=\\\"%s\\\" text=\\\"\\\" />\\n\", tx3g_format_time(trak->Media->mediaHeader->duration, trak->Media->mediaHeader->timeScale, szDur, GF_FALSE));\n\t}\n\n\tif (box_dump) {\n\t\tfprintf(dump, \"</TextTrack>\\n\");\n\t} else {\n\t\tfprintf(dump, \"</TextStream>\\n\");\n\t}\n\tif (count) gf_set_progress(\"TTXT Extract\", count, count);\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_isom_dump_srt_track(GF_ISOFile *the_file, u32 track, FILE *dump)\n{\n\tu32 i, j, k, count, di, len, ts, cur_frame;\n\tu64 start, end;\n\tGF_Tx3gSampleEntryBox *txtd;\n\tGF_BitStream *bs;\n\tchar szDur[100];\n\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tts = trak->Media->mediaHeader->timeScale;\n\tcur_frame = 0;\n\tend = 0;\n\n\tcount = gf_isom_get_sample_count(the_file, track);\n\tfor (i=0; i<count; i++) {\n\t\tGF_TextSample *txt;\n\t\tGF_ISOSample *s = gf_isom_get_sample(the_file, track, i+1, &di);\n\t\tif (!s) continue;\n\n\t\tstart = s->DTS;\n\t\tif (s->dataLength==2) {\n\t\t\tgf_isom_sample_del(&s);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i+1<count) {\n\t\t\tGF_ISOSample *next = gf_isom_get_sample_info(the_file, track, i+2, NULL, NULL);\n\t\t\tif (next) {\n\t\t\t\tend = next->DTS;\n\t\t\t\tgf_isom_sample_del(&next);\n\t\t\t}\n\t\t} else {\n\t\t\tend = gf_isom_get_media_duration(the_file, track) ;\n\t\t}\n\t\tcur_frame++;\n\t\tfprintf(dump, \"%d\\n\", cur_frame);\n\t\ttx3g_format_time(start, ts, szDur, GF_TRUE);\n\t\tfprintf(dump, \"%s --> \", szDur);\n\t\ttx3g_format_time(end, ts, szDur, GF_TRUE);\n\t\tfprintf(dump, \"%s\\n\", szDur);\n\n\t\tbs = gf_bs_new(s->data, s->dataLength, GF_BITSTREAM_READ);\n\t\ttxt = gf_isom_parse_texte_sample(bs);\n\t\tgf_bs_del(bs);\n\n\t\ttxtd = (GF_Tx3gSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, di-1);\n\n\t\tif (!txt->len) {\n\t\t\tfprintf(dump, \"\\n\");\n\t\t} else {\n\t\t\tu32 styles, char_num, new_styles, color, new_color;\n\t\t\tu16 utf16Line[10000];\n\n\t\t\t/*UTF16*/\n\t\t\tif ((txt->len>2) && ((unsigned char) txt->text[0] == (unsigned char) 0xFE) && ((unsigned char) txt->text[1] == (unsigned char) 0xFF)) {\n\t\t\t\tmemcpy(utf16Line, txt->text+2, sizeof(char)*txt->len);\n\t\t\t\t( ((char *)utf16Line)[txt->len] ) = 0;\n\t\t\t\tlen = txt->len;\n\t\t\t} else {\n\t\t\t\tu8 *str = (u8 *) (txt->text);\n\t\t\t\tsize_t res = gf_utf8_mbstowcs(utf16Line, 10000, (const char **) &str);\n\t\t\t\tif (res==(size_t)-1) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\tlen = (u32) res;\n\t\t\t\tutf16Line[len] = 0;\n\t\t\t}\n\t\t\tchar_num = 0;\n\t\t\tstyles = 0;\n\t\t\tnew_styles = txtd->default_style.style_flags;\n\t\t\tcolor = new_color = txtd->default_style.text_color;\n\n\t\t\tfor (j=0; j<len; j++) {\n\t\t\t\tBool is_new_line;\n\n\t\t\t\tif (txt->styles) {\n\t\t\t\t\tnew_styles = txtd->default_style.style_flags;\n\t\t\t\t\tnew_color = txtd->default_style.text_color;\n\t\t\t\t\tfor (k=0; k<txt->styles->entry_count; k++) {\n\t\t\t\t\t\tif (txt->styles->styles[k].startCharOffset>char_num) continue;\n\t\t\t\t\t\tif (txt->styles->styles[k].endCharOffset<char_num+1) continue;\n\n\t\t\t\t\t\tif (txt->styles->styles[k].style_flags & (GF_TXT_STYLE_ITALIC | GF_TXT_STYLE_BOLD | GF_TXT_STYLE_UNDERLINED)) {\n\t\t\t\t\t\t\tnew_styles = txt->styles->styles[k].style_flags;\n\t\t\t\t\t\t\tnew_color = txt->styles->styles[k].text_color;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (new_styles != styles) {\n\t\t\t\t\tif ((new_styles & GF_TXT_STYLE_BOLD) && !(styles & GF_TXT_STYLE_BOLD)) fprintf(dump, \"<b>\");\n\t\t\t\t\tif ((new_styles & GF_TXT_STYLE_ITALIC) && !(styles & GF_TXT_STYLE_ITALIC)) fprintf(dump, \"<i>\");\n\t\t\t\t\tif ((new_styles & GF_TXT_STYLE_UNDERLINED) && !(styles & GF_TXT_STYLE_UNDERLINED)) fprintf(dump, \"<u>\");\n\n\t\t\t\t\tif ((styles & GF_TXT_STYLE_UNDERLINED) && !(new_styles & GF_TXT_STYLE_UNDERLINED)) fprintf(dump, \"</u>\");\n\t\t\t\t\tif ((styles & GF_TXT_STYLE_ITALIC) && !(new_styles & GF_TXT_STYLE_ITALIC)) fprintf(dump, \"</i>\");\n\t\t\t\t\tif ((styles & GF_TXT_STYLE_BOLD) && !(new_styles & GF_TXT_STYLE_BOLD)) fprintf(dump, \"</b>\");\n\n\t\t\t\t\tstyles = new_styles;\n\t\t\t\t}\n\t\t\t\tif (new_color != color) {\n\t\t\t\t\tif (new_color ==txtd->default_style.text_color) {\n\t\t\t\t\t\tfprintf(dump, \"</font>\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(dump, \"<font color=\\\"%s\\\">\", gf_color_get_name(new_color) );\n\t\t\t\t\t}\n\t\t\t\t\tcolor = new_color;\n\t\t\t\t}\n\n\t\t\t\t/*not sure if styles must be reseted at line breaks in srt...*/\n\t\t\t\tis_new_line = GF_FALSE;\n\t\t\t\tif ((utf16Line[j]=='\\n') || (utf16Line[j]=='\\r') ) {\n\t\t\t\t\tif ((utf16Line[j]=='\\r') && (utf16Line[j+1]=='\\n')) j++;\n\t\t\t\t\tfprintf(dump, \"\\n\");\n\t\t\t\t\tis_new_line = GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tif (!is_new_line) {\n\t\t\t\t\tsize_t sl;\n\t\t\t\t\tchar szChar[30];\n\t\t\t\t\ts16 swT[2], *swz;\n\t\t\t\t\tswT[0] = utf16Line[j];\n\t\t\t\t\tswT[1] = 0;\n\t\t\t\t\tswz= (s16 *)swT;\n\t\t\t\t\tsl = gf_utf8_wcstombs(szChar, 30, (const unsigned short **) &swz);\n\t\t\t\t\tif (sl == (size_t)-1) sl=0;\n\t\t\t\t\tszChar[(u32) sl]=0;\n\t\t\t\t\tfprintf(dump, \"%s\", szChar);\n\t\t\t\t}\n\t\t\t\tchar_num++;\n\t\t\t}\n\t\t\tnew_styles = 0;\n\t\t\tif (new_styles != styles) {\n\t\t\t\tif (styles & GF_TXT_STYLE_UNDERLINED) fprintf(dump, \"</u>\");\n\t\t\t\tif (styles & GF_TXT_STYLE_ITALIC) fprintf(dump, \"</i>\");\n\t\t\t\tif (styles & GF_TXT_STYLE_BOLD) fprintf(dump, \"</b>\");\n\n//\t\t\t\tstyles = 0;\n\t\t\t}\n\n\t\t\tif (color != txtd->default_style.text_color) {\n\t\t\t\tfprintf(dump, \"</font>\");\n//\t\t\t\tcolor = txtd->default_style.text_color;\n\t\t\t}\n\t\t\tfprintf(dump, \"\\n\");\n\t\t}\n\t\tgf_isom_sample_del(&s);\n\t\tgf_isom_delete_text_sample(txt);\n\t\tfprintf(dump, \"\\n\");\n\t\tgf_set_progress(\"SRT Extract\", i, count);\n\t}\n\tif (count) gf_set_progress(\"SRT Extract\", i, count);\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_isom_dump_svg_track(GF_ISOFile *the_file, u32 track, FILE *dump)\n{\n\tchar nhmlFileName[1024];\n\tFILE *nhmlFile;\n\tu32 i, count, di, ts, cur_frame;\n\tu64 start, end;\n\tGF_BitStream *bs;\n\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tstrcpy(nhmlFileName, the_file->fileName);\n\tstrcat(nhmlFileName, \".nhml\");\n\tnhmlFile = gf_fopen(nhmlFileName, \"wt\");\n\tfprintf(nhmlFile, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n\tfprintf(nhmlFile, \"<NHNTStream streamType=\\\"3\\\" objectTypeIndication=\\\"10\\\" timeScale=\\\"%d\\\" baseMediaFile=\\\"file.svg\\\" inRootOD=\\\"yes\\\">\\n\", trak->Media->mediaHeader->timeScale);\n\tfprintf(nhmlFile, \"<NHNTSample isRAP=\\\"yes\\\" DTS=\\\"0\\\" xmlFrom=\\\"doc.start\\\" xmlTo=\\\"text_1.start\\\"/>\\n\");\n\n\tts = trak->Media->mediaHeader->timeScale;\n\tcur_frame = 0;\n\tend = 0;\n\n\tfprintf(dump, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n\tfprintf(dump, \"<svg version=\\\"1.2\\\" baseProfile=\\\"tiny\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" width=\\\"%d\\\" height=\\\"%d\\\" fill=\\\"black\\\">\\n\", trak->Header->width >> 16 , trak->Header->height >> 16);\n\tfprintf(dump, \"<g transform=\\\"translate(%d, %d)\\\" text-anchor=\\\"middle\\\">\\n\", (trak->Header->width >> 16)/2 , (trak->Header->height >> 16)/2);\n\n\tcount = gf_isom_get_sample_count(the_file, track);\n\tfor (i=0; i<count; i++) {\n\t\tGF_TextSample *txt;\n\t\tGF_ISOSample *s = gf_isom_get_sample(the_file, track, i+1, &di);\n\t\tif (!s) continue;\n\n\t\tstart = s->DTS;\n\t\tif (s->dataLength==2) {\n\t\t\tgf_isom_sample_del(&s);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i+1<count) {\n\t\t\tGF_ISOSample *next = gf_isom_get_sample_info(the_file, track, i+2, NULL, NULL);\n\t\t\tif (next) {\n\t\t\t\tend = next->DTS;\n\t\t\t\tgf_isom_sample_del(&next);\n\t\t\t}\n\t\t}\n\n\t\tcur_frame++;\n\t\tbs = gf_bs_new(s->data, s->dataLength, GF_BITSTREAM_READ);\n\t\ttxt = gf_isom_parse_texte_sample(bs);\n\t\tgf_bs_del(bs);\n\n\t\tif (!txt->len) continue;\n\n\t\tfprintf(dump, \" <text id=\\\"text_%d\\\" display=\\\"none\\\">%s\\n\", cur_frame, txt->text);\n\t\tfprintf(dump, \"  <set attributeName=\\\"display\\\" to=\\\"inline\\\" begin=\\\"%g\\\" end=\\\"%g\\\"/>\\n\", ((s64)start*1.0)/ts, ((s64)end*1.0)/ts);\n\t\tfprintf(dump, \"  <discard begin=\\\"%g\\\"/>\\n\", ((s64)end*1.0)/ts);\n\t\tfprintf(dump, \" </text>\\n\");\n\t\tgf_isom_sample_del(&s);\n\t\tgf_isom_delete_text_sample(txt);\n\t\tfprintf(dump, \"\\n\");\n\t\tgf_set_progress(\"SRT Extract\", i, count);\n\n\t\tif (i == count - 2) {\n\t\t\tfprintf(nhmlFile, \"<NHNTSample isRAP=\\\"no\\\" DTS=\\\"%f\\\" xmlFrom=\\\"text_%d.start\\\" xmlTo=\\\"doc.end\\\"/>\\n\", ((s64)start*1.0), cur_frame);\n\t\t} else {\n\t\t\tfprintf(nhmlFile, \"<NHNTSample isRAP=\\\"no\\\" DTS=\\\"%f\\\" xmlFrom=\\\"text_%d.start\\\" xmlTo=\\\"text_%d.start\\\"/>\\n\", ((s64)start*1.0), cur_frame, cur_frame+1);\n\t\t}\n\n\t}\n\tfprintf(dump, \"</g>\\n\");\n\tfprintf(dump, \"</svg>\\n\");\n\n\tfprintf(nhmlFile, \"</NHNTStream>\\n\");\n\tgf_fclose(nhmlFile);\n\n\tif (count) gf_set_progress(\"SRT Extract\", i, count);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_dump(GF_ISOFile *the_file, u32 track, FILE *dump, GF_TextDumpType dump_type)\n{\n\tswitch (dump_type) {\n\tcase GF_TEXTDUMPTYPE_SVG:\n\t\treturn gf_isom_dump_svg_track(the_file, track, dump);\n\tcase GF_TEXTDUMPTYPE_SRT:\n\t\treturn gf_isom_dump_srt_track(the_file, track, dump);\n\tcase GF_TEXTDUMPTYPE_TTXT:\n\tcase GF_TEXTDUMPTYPE_TTXT_BOXES:\n\t\treturn gf_isom_dump_ttxt_track(the_file, track, dump, (dump_type==GF_TEXTDUMPTYPE_TTXT_BOXES) ? GF_TRUE : GF_FALSE);\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\n\n/* ISMA 1.0 Encryption and Authentication V 1.0  dump */\nGF_Err sinf_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ProtectionSchemeInfoBox *p;\n\tp = (GF_ProtectionSchemeInfoBox *)a;\n\tgf_isom_box_dump_start(a, \"ProtectionSchemeInfoBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->original_format, trace, GF_ISOM_BOX_TYPE_FRMA);\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->scheme_type, trace, GF_ISOM_BOX_TYPE_SCHM);\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->info, trace, GF_ISOM_BOX_TYPE_SCHI);\n\tgf_isom_box_dump_done(\"ProtectionSchemeInfoBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err frma_dump(GF_Box *a, FILE * trace)\n{\n\tGF_OriginalFormatBox *p;\n\tp = (GF_OriginalFormatBox *)a;\n\tgf_isom_box_dump_start(a, \"OriginalFormatBox\", trace);\n\tfprintf(trace, \"data_format=\\\"%s\\\">\\n\", gf_4cc_to_str(p->data_format));\n\tgf_isom_box_dump_done(\"OriginalFormatBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err schm_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SchemeTypeBox *p;\n\tp = (GF_SchemeTypeBox *)a;\n\tgf_isom_box_dump_start(a, \"SchemeTypeBox\", trace);\n\tfprintf(trace, \"scheme_type=\\\"%s\\\" scheme_version=\\\"%d\\\" \", gf_4cc_to_str(p->scheme_type), p->scheme_version);\n\tif (p->URI) fprintf(trace, \"scheme_uri=\\\"%s\\\"\", p->URI);\n\tfprintf(trace, \">\\n\");\n\n\tgf_isom_box_dump_done(\"SchemeTypeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err schi_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SchemeInformationBox *p;\n\tp = (GF_SchemeInformationBox *)a;\n\tgf_isom_box_dump_start(a, \"SchemeInformationBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->ikms) gf_isom_box_dump(p->ikms, trace);\n\tif (p->isfm) gf_isom_box_dump(p->isfm, trace);\n\tif (p->islt) gf_isom_box_dump(p->islt, trace);\n\tif (p->odkm) gf_isom_box_dump(p->odkm, trace);\n\tif (p->tenc) gf_isom_box_dump(p->tenc, trace);\n\tif (p->adkm) gf_isom_box_dump(p->adkm, trace);\n\tgf_isom_box_dump_done(\"SchemeInformationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err iKMS_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ISMAKMSBox *p;\n\tp = (GF_ISMAKMSBox *)a;\n\tgf_isom_box_dump_start(a, \"KMSBox\", trace);\n\tfprintf(trace, \"kms_URI=\\\"%s\\\">\\n\", p->URI);\n\tgf_isom_box_dump_done(\"KMSBox\", a, trace);\n\treturn GF_OK;\n\n}\n\nGF_Err iSFM_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ISMASampleFormatBox *p;\n\tconst char *name = (a->type==GF_ISOM_BOX_TYPE_ISFM) ? \"ISMASampleFormat\" : \"OMADRMAUFormatBox\";\n\tp = (GF_ISMASampleFormatBox *)a;\n\tgf_isom_box_dump_start(a, name, trace);\n\tfprintf(trace, \"selective_encryption=\\\"%d\\\" key_indicator_length=\\\"%d\\\" IV_length=\\\"%d\\\">\\n\", p->selective_encryption, p->key_indicator_length, p->IV_length);\n\tgf_isom_box_dump_done(name, a, trace);\n\treturn GF_OK;\n}\n\nGF_Err iSLT_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ISMACrypSaltBox *p = (GF_ISMACrypSaltBox *)a;\n\tgf_isom_box_dump_start(a, \"ISMACrypSaltBox\", trace);\n\tfprintf(trace, \"salt=\\\"\"LLU\"\\\">\\n\", p->salt);\n\tgf_isom_box_dump_done(\"ISMACrypSaltBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_dump_ismacryp_protection(GF_ISOFile *the_file, u32 trackNumber, FILE * trace)\n{\n\tu32 i, count;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\tfprintf(trace, \"<ISMACrypSampleDescriptions>\\n\");\n\tcount = gf_isom_get_sample_description_count(the_file, trackNumber);\n\tfor (i=0; i<count; i++) {\n\t\te = Media_GetSampleDesc(trak->Media, i+1, (GF_SampleEntryBox **) &entry, NULL);\n\t\tif (e) return e;\n\n\t\tswitch (entry->type) {\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_ENCT:\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tgf_isom_box_dump(entry, trace);\n\t}\n\tfprintf(trace, \"</ISMACrypSampleDescriptions>\\n\");\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_dump_ismacryp_sample(GF_ISOFile *the_file, u32 trackNumber, u32 SampleNum, FILE * trace)\n{\n\tGF_ISOSample *samp;\n\tGF_ISMASample  *isma_samp;\n\tu32 descIndex;\n\n\tsamp = gf_isom_get_sample(the_file, trackNumber, SampleNum, &descIndex);\n\tif (!samp) return GF_BAD_PARAM;\n\n\tisma_samp = gf_isom_get_ismacryp_sample(the_file, trackNumber, samp, descIndex);\n\tif (!isma_samp) {\n\t\tgf_isom_sample_del(&samp);\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tfprintf(trace, \"<ISMACrypSample SampleNumber=\\\"%d\\\" DataSize=\\\"%d\\\" CompositionTime=\\\"\"LLD\"\\\" \", SampleNum, isma_samp->dataLength, LLD_CAST (samp->DTS+samp->CTS_Offset) );\n\tif (samp->CTS_Offset) fprintf(trace, \"DecodingTime=\\\"\"LLD\"\\\" \", LLD_CAST samp->DTS);\n\tif (gf_isom_has_sync_points(the_file, trackNumber)) fprintf(trace, \"RandomAccessPoint=\\\"%s\\\" \", samp->IsRAP ? \"Yes\" : \"No\");\n\tfprintf(trace, \"IsEncrypted=\\\"%s\\\" \", (isma_samp->flags & GF_ISOM_ISMA_IS_ENCRYPTED) ? \"Yes\" : \"No\");\n\tif (isma_samp->flags & GF_ISOM_ISMA_IS_ENCRYPTED) {\n\t\tfprintf(trace, \"IV=\\\"\"LLD\"\\\" \", LLD_CAST isma_samp->IV);\n\t\tif (isma_samp->key_indicator) dump_data_attribute(trace, \"KeyIndicator\", (char*)isma_samp->key_indicator, isma_samp->KI_length);\n\t}\n\tfprintf(trace, \"/>\\n\");\n\n\tgf_isom_sample_del(&samp);\n\tgf_isom_ismacryp_delete_sample(isma_samp);\n\treturn GF_OK;\n}\n\n/* end of ISMA 1.0 Encryption and Authentication V 1.0 */\n\n\n/* Apple extensions */\n\nGF_Err ilst_item_dump(GF_Box *a, FILE * trace)\n{\n\tGF_BitStream *bs;\n\tu32 val;\n\tBool no_dump = GF_FALSE;\n\tchar *name = \"UnknownBox\";\n\tGF_ListItemBox *itune = (GF_ListItemBox *)a;\n\tswitch (itune->type) {\n\tcase GF_ISOM_BOX_TYPE_0xA9NAM:\n\t\tname = \"NameBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9CMT:\n\t\tname = \"CommentBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9DAY:\n\t\tname = \"CreatedBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9ART:\n\t\tname = \"ArtistBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9TRK:\n\t\tname = \"TrackBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9ALB:\n\t\tname = \"AlbumBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9COM:\n\t\tname = \"CompositorBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9WRT:\n\t\tname = \"WriterBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9TOO:\n\t\tname = \"ToolBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9CPY:\n\t\tname = \"CopyrightBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9DES:\n\t\tname = \"DescriptionBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9GEN:\n\tcase GF_ISOM_BOX_TYPE_GNRE:\n\t\tname = \"GenreBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_aART:\n\t\tname = \"AlbumArtistBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_PGAP:\n\t\tname = \"GapelessBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DISK:\n\t\tname = \"DiskBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TRKN:\n\t\tname = \"TrackNumberBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TMPO:\n\t\tname = \"TempoBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_CPIL:\n\t\tname = \"CompilationBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_COVR:\n\t\tname = \"CoverArtBox\";\n\t\tno_dump = GF_TRUE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_iTunesSpecificInfo:\n\t\tname = \"iTunesSpecificBox\";\n\t\tno_dump = GF_TRUE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9GRP:\n\t\tname = \"GroupBox\";\n\t\tbreak;\n\tcase GF_ISOM_ITUNE_ENCODER:\n\t\tname = \"EncoderBox\";\n\t\tbreak;\n\t}\n\tgf_isom_box_dump_start(a, name, trace);\n\n\tif (!no_dump) {\n\t\tswitch (itune->type) {\n\t\tcase GF_ISOM_BOX_TYPE_DISK:\n\t\tcase GF_ISOM_BOX_TYPE_TRKN:\n\t\t\tbs = gf_bs_new(itune->data->data, itune->data->dataSize, GF_BITSTREAM_READ);\n\t\t\tgf_bs_read_int(bs, 16);\n\t\t\tval = gf_bs_read_int(bs, 16);\n\t\t\tif (itune->type==GF_ISOM_BOX_TYPE_DISK) {\n\t\t\t\tfprintf(trace, \" DiskNumber=\\\"%d\\\" NbDisks=\\\"%d\\\" \", val, gf_bs_read_int(bs, 16) );\n\t\t\t} else {\n\t\t\t\tfprintf(trace, \" TrackNumber=\\\"%d\\\" NbTracks=\\\"%d\\\" \", val, gf_bs_read_int(bs, 16) );\n\t\t\t}\n\t\t\tgf_bs_del(bs);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_TMPO:\n\t\t\tbs = gf_bs_new(itune->data->data, itune->data->dataSize, GF_BITSTREAM_READ);\n\t\t\tfprintf(trace, \" BPM=\\\"%d\\\" \", gf_bs_read_int(bs, 16) );\n\t\t\tgf_bs_del(bs);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_CPIL:\n\t\t\tfprintf(trace, \" IsCompilation=\\\"%s\\\" \", (itune->data && itune->data->data && itune->data->data[0]) ? \"yes\" : \"no\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_PGAP:\n\t\t\tfprintf(trace, \" IsGapeless=\\\"%s\\\" \", (itune->data && itune->data->data && itune->data->data[0]) ? \"yes\" : \"no\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (strcmp(name, \"UnknownBox\") && itune->data && itune->data->data) {\n\t\t\t\tfprintf(trace, \" value=\\\"\");\n\t\t\t\tif (itune->data && itune->data->data[0]) {\n\t\t\t\t\tdump_data_string(trace, itune->data->data, itune->data->dataSize);\n\t\t\t\t} else {\n\t\t\t\t\tdump_data(trace, itune->data->data, itune->data->dataSize);\n\t\t\t\t}\n\t\t\t\tfprintf(trace, \"\\\" \");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(name, a, trace);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\nGF_Err abst_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_AdobeBootstrapInfoBox *p = (GF_AdobeBootstrapInfoBox*)a;\n\tgf_isom_box_dump_start(a, \"AdobeBootstrapBox\", trace);\n\n\tfprintf(trace, \"BootstrapinfoVersion=\\\"%u\\\" Profile=\\\"%u\\\" Live=\\\"%u\\\" Update=\\\"%u\\\" TimeScale=\\\"%u\\\" CurrentMediaTime=\\\"\"LLU\"\\\" SmpteTimeCodeOffset=\\\"\"LLU\"\\\" \",\n\t        p->bootstrapinfo_version, p->profile, p->live, p->update, p->time_scale, p->current_media_time, p->smpte_time_code_offset);\n\tif (p->movie_identifier)\n\t\tfprintf(trace, \"MovieIdentifier=\\\"%s\\\" \", p->movie_identifier);\n\tif (p->drm_data)\n\t\tfprintf(trace, \"DrmData=\\\"%s\\\" \", p->drm_data);\n\tif (p->meta_data)\n\t\tfprintf(trace, \"MetaData=\\\"%s\\\" \", p->meta_data);\n\tfprintf(trace, \">\\n\");\n\n\tfor (i=0; i<p->server_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(p->server_entry_table, i);\n\t\tfprintf(trace, \"<ServerEntry>%s</ServerEntry>\\n\", str);\n\t}\n\n\tfor (i=0; i<p->quality_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(p->quality_entry_table, i);\n\t\tfprintf(trace, \"<QualityEntry>%s</QualityEntry>\\n\", str);\n\t}\n\n\tfor (i=0; i<p->segment_run_table_count; i++)\n\t\tgf_isom_box_dump(gf_list_get(p->segment_run_table_entries, i), trace);\n\n\tfor (i=0; i<p->fragment_run_table_count; i++)\n\t\tgf_isom_box_dump(gf_list_get(p->fragment_run_table_entries, i), trace);\n\n\tgf_isom_box_dump_done(\"AdobeBootstrapBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err afra_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_AdobeFragRandomAccessBox *p = (GF_AdobeFragRandomAccessBox*)a;\n\tgf_isom_box_dump_start(a, \"AdobeFragmentRandomAccessBox\", trace);\n\n\tfprintf(trace, \"LongIDs=\\\"%u\\\" LongOffsets=\\\"%u\\\" TimeScale=\\\"%u\\\">\\n\", p->long_ids, p->long_offsets, p->time_scale);\n\n\tfor (i=0; i<p->entry_count; i++) {\n\t\tGF_AfraEntry *ae = (GF_AfraEntry *)gf_list_get(p->local_access_entries, i);\n\t\tfprintf(trace, \"<LocalAccessEntry Time=\\\"\"LLU\"\\\" Offset=\\\"\"LLU\"\\\"/>\\n\", ae->time, ae->offset);\n\t}\n\n\tfor (i=0; i<p->global_entry_count; i++) {\n\t\tGF_GlobalAfraEntry *gae = (GF_GlobalAfraEntry *)gf_list_get(p->global_access_entries, i);\n\t\tfprintf(trace, \"<GlobalAccessEntry Time=\\\"\"LLU\"\\\" Segment=\\\"%u\\\" Fragment=\\\"%u\\\" AfraOffset=\\\"\"LLU\"\\\" OffsetFromAfra=\\\"\"LLU\"\\\"/>\\n\",\n\t\t        gae->time, gae->segment, gae->fragment, gae->afra_offset, gae->offset_from_afra);\n\t}\n\n\tgf_isom_box_dump_done(\"AdobeFragmentRandomAccessBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err afrt_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_AdobeFragmentRunTableBox *p = (GF_AdobeFragmentRunTableBox*)a;\n\tgf_isom_box_dump_start(a, \"AdobeFragmentRunTableBox\", trace);\n\n\tfprintf(trace, \"TimeScale=\\\"%u\\\">\\n\", p->timescale);\n\n\tfor (i=0; i<p->quality_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(p->quality_segment_url_modifiers, i);\n\t\tfprintf(trace, \"<QualityEntry>%s</QualityEntry>\\n\", str);\n\t}\n\n\tfor (i=0; i<p->fragment_run_entry_count; i++) {\n\t\tGF_AdobeFragmentRunEntry *fre = (GF_AdobeFragmentRunEntry *)gf_list_get(p->fragment_run_entry_table, i);\n\t\tfprintf(trace, \"<FragmentRunEntry FirstFragment=\\\"%u\\\" FirstFragmentTimestamp=\\\"\"LLU\"\\\" FirstFragmentDuration=\\\"%u\\\"\", fre->first_fragment, fre->first_fragment_timestamp, fre->fragment_duration);\n\t\tif (!fre->fragment_duration)\n\t\t\tfprintf(trace, \" DiscontinuityIndicator=\\\"%u\\\"\", fre->discontinuity_indicator);\n\t\tfprintf(trace, \"/>\\n\");\n\t}\n\n\tgf_isom_box_dump_done(\"AdobeFragmentRunTableBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err asrt_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_AdobeSegmentRunTableBox *p = (GF_AdobeSegmentRunTableBox*)a;\n\tgf_isom_box_dump_start(a, \"AdobeSegmentRunTableBox\", trace);\n\n\tfprintf(trace, \">\\n\");\n\n\tfor (i=0; i<p->quality_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(p->quality_segment_url_modifiers, i);\n\t\tfprintf(trace, \"<QualityEntry>%s</QualityEntry>\\n\", str);\n\t}\n\n\tfor (i=0; i<p->segment_run_entry_count; i++) {\n\t\tGF_AdobeSegmentRunEntry *sre = (GF_AdobeSegmentRunEntry *)gf_list_get(p->segment_run_entry_table, i);\n\t\tfprintf(trace, \"<SegmentRunEntry FirstSegment=\\\"%u\\\" FragmentsPerSegment=\\\"%u\\\"/>\\n\", sre->first_segment, sre->fragment_per_segment);\n\t}\n\n\tgf_isom_box_dump_done(\"AdobeSegmentRunTableBox\", a, trace);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_ADOBE*/\n\nGF_Err ilst_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_Box *tag;\n\tGF_Err e;\n\tGF_ItemListBox *ptr;\n\tptr = (GF_ItemListBox *)a;\n\tgf_isom_box_dump_start(a, \"ItemListBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\ti=0;\n\twhile ( (tag = (GF_Box*)gf_list_enum(ptr->other_boxes, &i))) {\n\t\te = ilst_item_dump(tag, trace);\n\t\tif(e) return e;\n\t}\n\tgf_isom_box_dump_done(\"ItemListBox\", NULL, trace);\n\treturn GF_OK;\n}\n\nGF_Err databox_dump(GF_Box *a, FILE * trace)\n{\n\tgf_isom_box_dump_start(a, \"data\", trace);\n\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"data\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ohdr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_OMADRMCommonHeaderBox *ptr = (GF_OMADRMCommonHeaderBox *)a;\n\tgf_isom_box_dump_start(a, \"OMADRMCommonHeaderBox\", trace);\n\n\tfprintf(trace, \"EncryptionMethod=\\\"%d\\\" PaddingScheme=\\\"%d\\\" PlaintextLength=\\\"\"LLD\"\\\" \",\n\t        ptr->EncryptionMethod, ptr->PaddingScheme, ptr->PlaintextLength);\n\tif (ptr->RightsIssuerURL) fprintf(trace, \"RightsIssuerURL=\\\"%s\\\" \", ptr->RightsIssuerURL);\n\tif (ptr->ContentID) fprintf(trace, \"ContentID=\\\"%s\\\" \", ptr->ContentID);\n\tif (ptr->TextualHeaders) {\n\t\tu32 i, offset;\n\t\tchar *start = ptr->TextualHeaders;\n\t\tfprintf(trace, \"TextualHeaders=\\\"\");\n\t\ti=offset=0;\n\t\twhile (i<ptr->TextualHeadersLen) {\n\t\t\tif (start[i]==0) {\n\t\t\t\tfprintf(trace, \"%s \", start+offset);\n\t\t\t\toffset=i+1;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfprintf(trace, \"%s\\\"  \", start+offset);\n\t}\n\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"OMADRMCommonHeaderBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err grpi_dump(GF_Box *a, FILE * trace)\n{\n\tGF_OMADRMGroupIDBox *ptr = (GF_OMADRMGroupIDBox *)a;\n\tgf_isom_box_dump_start(a, \"OMADRMGroupIDBox\", trace);\n\n\tfprintf(trace, \"GroupID=\\\"%s\\\" EncryptionMethod=\\\"%d\\\" GroupKey=\\\" \", ptr->GroupID, ptr->GKEncryptionMethod);\n\tif (ptr->GroupKey)\n\t\tdump_data(trace, ptr->GroupKey, ptr->GKLength);\n\tfprintf(trace, \"\\\">\\n\");\n\tgf_isom_box_dump_done(\"OMADRMGroupIDBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err mdri_dump(GF_Box *a, FILE * trace)\n{\n\t//GF_OMADRMMutableInformationBox *ptr = (GF_OMADRMMutableInformationBox*)a;\n\tgf_isom_box_dump_start(a, \"OMADRMMutableInformationBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"OMADRMMutableInformationBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err odtt_dump(GF_Box *a, FILE * trace)\n{\n\tGF_OMADRMTransactionTrackingBox *ptr = (GF_OMADRMTransactionTrackingBox *)a;\n\tgf_isom_box_dump_start(a, \"OMADRMTransactionTrackingBox\", trace);\n\n\tfprintf(trace, \"TransactionID=\\\"\");\n\tdump_data(trace, ptr->TransactionID, 16);\n\tfprintf(trace, \"\\\">\\n\");\n\tgf_isom_box_dump_done(\"OMADRMTransactionTrackingBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err odrb_dump(GF_Box *a, FILE * trace)\n{\n\tGF_OMADRMRightsObjectBox*ptr = (GF_OMADRMRightsObjectBox*)a;\n\tgf_isom_box_dump_start(a, \"OMADRMRightsObjectBox\", trace);\n\n\tfprintf(trace, \"OMARightsObject=\\\"\");\n\tdump_data(trace, ptr->oma_ro, ptr->oma_ro_size);\n\tfprintf(trace, \"\\\">\\n\");\n\tgf_isom_box_dump_done(\"OMADRMRightsObjectBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err odkm_dump(GF_Box *a, FILE * trace)\n{\n\tGF_OMADRMKMSBox *ptr = (GF_OMADRMKMSBox*)a;\n\tgf_isom_box_dump_start(a, \"OMADRMKMSBox\", trace);\n\n\tfprintf(trace, \">\\n\");\n\tif (ptr->hdr) gf_isom_box_dump((GF_Box *)ptr->hdr, trace);\n\tif (ptr->fmt) gf_isom_box_dump((GF_Box *)ptr->fmt, trace);\n\tgf_isom_box_dump_done(\"OMADRMKMSBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err pasp_dump(GF_Box *a, FILE * trace)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox*)a;\n\tgf_isom_box_dump_start(a, \"PixelAspectRatioBox\", trace);\n\tfprintf(trace, \"hSpacing=\\\"%d\\\" vSpacing=\\\"%d\\\" >\\n\", ptr->hSpacing, ptr->vSpacing);\n\tgf_isom_box_dump_done(\"PixelAspectRatioBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err clap_dump(GF_Box *a, FILE * trace)\n{\n\tGF_CleanAppertureBox *ptr = (GF_CleanAppertureBox*)a;\n\tgf_isom_box_dump_start(a, \"CleanAppertureBox\", trace);\n\tfprintf(trace, \"cleanApertureWidthN=\\\"%d\\\" cleanApertureWidthD=\\\"%d\\\" \", ptr->cleanApertureWidthN, ptr->cleanApertureWidthD);\n\tfprintf(trace, \"cleanApertureHeightN=\\\"%d\\\" cleanApertureHeightD=\\\"%d\\\" \", ptr->cleanApertureHeightN, ptr->cleanApertureHeightD);\n\tfprintf(trace, \"horizOffN=\\\"%d\\\" horizOffD=\\\"%d\\\" \", ptr->horizOffN, ptr->horizOffD);\n\tfprintf(trace, \"vertOffN=\\\"%d\\\" vertOffD=\\\"%d\\\"\", ptr->vertOffN, ptr->vertOffD);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"CleanAppertureBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err tsel_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_TrackSelectionBox *ptr = (GF_TrackSelectionBox *)a;\n\tgf_isom_box_dump_start(a, \"TrackSelectionBox\", trace);\n\n\tfprintf(trace, \"switchGroup=\\\"%d\\\" >\\n\", ptr->switchGroup);\n\tfor (i=0; i<ptr->attributeListCount; i++) {\n\t\tfprintf(trace, \"<TrackSelectionCriteria value=\\\"%s\\\"/>\\n\", gf_4cc_to_str(ptr->attributeList[i]) );\n\t}\n\tif (!ptr->size)\n\t\tfprintf(trace, \"<TrackSelectionCriteria value=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"TrackSelectionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err metx_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)a;\n\tconst char *name;\n\tswitch (ptr->type) {\n\tcase GF_ISOM_BOX_TYPE_METX:\n\t\tname = \"XMLMetaDataSampleEntryBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_METT:\n\t\tname = \"TextMetaDataSampleEntryBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SBTT:\n\t\tname = \"SubtitleSampleEntryBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\tname = \"SimpleTextSampleEntryBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\tname = \"XMLSubtitleSampleEntryBox\";\n\t\tbreak;\n\tdefault:\n\t\tname = \"UnknownTextSampleEntryBox\";\n\t\tbreak;\n\t}\n\tgf_isom_box_dump_start(a, name, trace);\n\n\tif (ptr->type==GF_ISOM_BOX_TYPE_METX) {\n\t\tfprintf(trace, \"namespace=\\\"%s\\\" \", ptr->xml_namespace);\n\t\tif (ptr->xml_schema_loc) fprintf(trace, \"schema_location=\\\"%s\\\" \", ptr->xml_schema_loc);\n\t\tif (ptr->content_encoding) fprintf(trace, \"content_encoding=\\\"%s\\\" \", ptr->content_encoding);\n\n\t} else if (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\tfprintf(trace, \"namespace=\\\"%s\\\" \", ptr->xml_namespace);\n\t\tif (ptr->xml_schema_loc) fprintf(trace, \"schema_location=\\\"%s\\\" \", ptr->xml_schema_loc);\n\t\tif (ptr->mime_type) fprintf(trace, \"auxiliary_mime_types=\\\"%s\\\" \", ptr->mime_type);\n\t}\n\t//mett, sbtt, stxt\n\telse {\n\t\tfprintf(trace, \"mime_type=\\\"%s\\\" \", ptr->mime_type);\n\t\tif (ptr->content_encoding) fprintf(trace, \"content_encoding=\\\"%s\\\" \", ptr->content_encoding);\n\t}\n\tfprintf(trace, \">\\n\");\n\n\tif ((ptr->type!=GF_ISOM_BOX_TYPE_METX) && (ptr->type!=GF_ISOM_BOX_TYPE_STPP) ) {\n\t\tif (ptr->config) gf_isom_box_dump(ptr->config, trace);\n\t}\n\tgf_isom_box_array_dump(ptr->protections, trace);\n\n\tgf_isom_box_dump_done(name, a, trace);\n\treturn GF_OK;\n}\n\nGF_Err txtc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox*)a;\n\tconst char *name = \"TextConfigBox\";\n\n\tgf_isom_box_dump_start(a, name, trace);\n\tfprintf(trace, \">\\n\");\n\n\tif (ptr->config) fprintf(trace, \"<![CDATA[%s]]>\", ptr->config);\n\n\tgf_isom_box_dump_done(name, a, trace);\n\treturn GF_OK;\n}\n\nGF_Err dims_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DIMSSampleEntryBox *p = (GF_DIMSSampleEntryBox*)a;\n\tgf_isom_box_dump_start(a, \"DIMSSampleEntryBox\", trace);\n\tfprintf(trace, \"dataReferenceIndex=\\\"%d\\\">\\n\", p->dataReferenceIndex);\n\tif (p->config) gf_isom_box_dump(p->config, trace);\n\tif (p->scripts) gf_isom_box_dump(p->scripts, trace);\n\tgf_isom_box_array_dump(p->protections, trace);\n\tgf_isom_box_dump_done(\"DIMSSampleEntryBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err diST_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox*)a;\n\tgf_isom_box_dump_start(a, \"DIMSScriptTypesBox\", trace);\n\tfprintf(trace, \"types=\\\"%s\\\">\\n\", p->content_script_types);\n\tgf_isom_box_dump_done(\"DIMSScriptTypesBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err dimC_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)a;\n\tgf_isom_box_dump_start(a, \"DIMSSceneConfigBox\", trace);\n\tfprintf(trace, \"profile=\\\"%d\\\" level=\\\"%d\\\" pathComponents=\\\"%d\\\" useFullRequestHosts=\\\"%d\\\" streamType=\\\"%d\\\" containsRedundant=\\\"%d\\\" textEncoding=\\\"%s\\\" contentEncoding=\\\"%s\\\" >\\n\",\n\t        p->profile, p->level, p->pathComponents, p->fullRequestHost, p->streamType, p->containsRedundant, p->textEncoding, p->contentEncoding);\n\tgf_isom_box_dump_done(\"DIMSSceneConfigBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err dac3_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AC3ConfigBox *p = (GF_AC3ConfigBox *)a;\n\n\tif (p->cfg.is_ec3) {\n\t\tu32 i;\n\t\ta->type = GF_ISOM_BOX_TYPE_DEC3;\n\t\tgf_isom_box_dump_start(a, \"EC3SpecificBox\", trace);\n\t\ta->type = GF_ISOM_BOX_TYPE_DAC3;\n\t\tfprintf(trace, \"nb_streams=\\\"%d\\\" data_rate=\\\"%d\\\">\\n\", p->cfg.nb_streams, p->cfg.brcode);\n\t\tfor (i=0; i<p->cfg.nb_streams; i++) {\n\t\t\tfprintf(trace, \"<EC3StreamConfig fscod=\\\"%d\\\" bsid=\\\"%d\\\" bsmod=\\\"%d\\\" acmod=\\\"%d\\\" lfon=\\\"%d\\\" num_sub_dep=\\\"%d\\\" chan_loc=\\\"%d\\\"/>\\n\",\n\t\t\t        p->cfg.streams[i].fscod, p->cfg.streams[i].bsid, p->cfg.streams[i].bsmod, p->cfg.streams[i].acmod, p->cfg.streams[i].lfon, p->cfg.streams[i].nb_dep_sub, p->cfg.streams[i].chan_loc);\n\t\t}\n\t\tgf_isom_box_dump_done(\"EC3SpecificBox\", a, trace);\n\t} else {\n\t\tgf_isom_box_dump_start(a, \"AC3SpecificBox\", trace);\n\t\tfprintf(trace, \"fscod=\\\"%d\\\" bsid=\\\"%d\\\" bsmod=\\\"%d\\\" acmod=\\\"%d\\\" lfon=\\\"%d\\\" bit_rate_code=\\\"%d\\\">\\n\",\n\t\t        p->cfg.streams[0].fscod, p->cfg.streams[0].bsid, p->cfg.streams[0].bsmod, p->cfg.streams[0].acmod, p->cfg.streams[0].lfon, p->cfg.brcode);\n\t\tgf_isom_box_dump_done(\"AC3SpecificBox\", a, trace);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err lsrc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_LASERConfigurationBox *p = (GF_LASERConfigurationBox *)a;\n\tgf_isom_box_dump_start(a, \"LASeRConfigurationBox\", trace);\n\tdump_data_attribute(trace, \"LASeRHeader\", p->hdr, p->hdr_size);\n\tfprintf(trace, \">\");\n\tgf_isom_box_dump_done(\"LASeRConfigurationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err lsr1_dump(GF_Box *a, FILE * trace)\n{\n\tGF_LASeRSampleEntryBox *p = (GF_LASeRSampleEntryBox*)a;\n\tgf_isom_box_dump_start(a, \"LASeRSampleEntryBox\", trace);\n\tfprintf(trace, \"DataReferenceIndex=\\\"%d\\\">\\n\", p->dataReferenceIndex);\n\tif (p->lsr_config) gf_isom_box_dump(p->lsr_config, trace);\n\tif (p->descr) gf_isom_box_dump(p->descr, trace);\n\tgf_isom_box_dump_done(\"LASeRSampleEntryBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err sidx_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_SegmentIndexBox *p = (GF_SegmentIndexBox *)a;\n\tgf_isom_box_dump_start(a, \"SegmentIndexBox\", trace);\n\tfprintf(trace, \"reference_ID=\\\"%d\\\" timescale=\\\"%d\\\" earliest_presentation_time=\\\"\"LLD\"\\\" first_offset=\\\"\"LLD\"\\\" \", p->reference_ID, p->timescale, p->earliest_presentation_time, p->first_offset);\n\n\tfprintf(trace, \">\\n\");\n\tfor (i=0; i<p->nb_refs; i++) {\n\t\tfprintf(trace, \"<Reference type=\\\"%d\\\" size=\\\"%d\\\" duration=\\\"%d\\\" startsWithSAP=\\\"%d\\\" SAP_type=\\\"%d\\\" SAPDeltaTime=\\\"%d\\\"/>\\n\", p->refs[i].reference_type, p->refs[i].reference_size, p->refs[i].subsegment_duration, p->refs[i].starts_with_SAP, p->refs[i].SAP_type, p->refs[i].SAP_delta_time);\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<Reference type=\\\"\\\" size=\\\"\\\" duration=\\\"\\\" startsWithSAP=\\\"\\\" SAP_type=\\\"\\\" SAPDeltaTime=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SegmentIndexBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ssix_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i, j;\n\tGF_SubsegmentIndexBox *p = (GF_SubsegmentIndexBox *)a;\n\tgf_isom_box_dump_start(a, \"SubsegmentIndexBox\", trace);\n\n\tfprintf(trace, \"subsegment_count=\\\"%d\\\" >\\n\", p->subsegment_count);\n\tfor (i = 0; i < p->subsegment_count; i++) {\n\t\tfprintf(trace, \"<Subsegment range_count=\\\"%d\\\">\\n\", p->subsegments[i].range_count);\n\t\tfor (j = 0; j < p->subsegments[i].range_count; j++) {\n\t\t\tfprintf(trace, \"<Range level=\\\"%d\\\" range_size=\\\"%d\\\"/>\\n\", p->subsegments[i].levels[j], p->subsegments[i].range_sizes[j]);\n\t\t}\n\t\tfprintf(trace, \"</Subsegment>\\n\");\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<Subsegment range_count=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<Range level=\\\"\\\" range_size=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</Subsegment>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SubsegmentIndexBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err leva_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_LevelAssignmentBox *p = (GF_LevelAssignmentBox *)a;\n\tgf_isom_box_dump_start(a, \"LevelAssignmentBox\", trace);\n\n\tfprintf(trace, \"level_count=\\\"%d\\\" >\\n\", p->level_count);\n\tfor (i = 0; i < p->level_count; i++) {\n\t\tfprintf(trace, \"<Assignement track_id=\\\"%d\\\" padding_flag=\\\"%d\\\" assignement_type=\\\"%d\\\" grouping_type=\\\"%s\\\" grouping_type_parameter=\\\"%d\\\" sub_track_id=\\\"%d\\\" />\\n\", p->levels[i].track_id, p->levels[i].padding_flag, p->levels[i].type, gf_4cc_to_str(p->levels[i].grouping_type) , p->levels[i].grouping_type_parameter, p->levels[i].sub_track_id);\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<Assignement track_id=\\\"\\\" padding_flag=\\\"\\\" assignement_type=\\\"\\\" grouping_type=\\\"\\\" grouping_type_parameter=\\\"\\\" sub_track_id=\\\"\\\" />\\n\");\n\t}\n\tgf_isom_box_dump_done(\"LevelAssignmentBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err strk_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SubTrackBox *p = (GF_SubTrackBox *)a;\n\tgf_isom_box_dump_start(a, \"SubTrackBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->info) {\n\t\tgf_isom_box_dump(p->info, trace);\n\t}\n\tgf_isom_box_dump_done(\"SubTrackBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stri_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_SubTrackInformationBox *p = (GF_SubTrackInformationBox *)a;\n\tgf_isom_box_dump_start(a, \"SubTrackInformationBox\", trace);\n\n\tfprintf(trace, \"switch_group=\\\"%d\\\" alternate_group=\\\"%d\\\" sub_track_id=\\\"%d\\\">\\n\", p->switch_group, p->alternate_group, p->sub_track_id);\n\n\tfor (i = 0; i < p->attribute_count; i++) {\n\t\tfprintf(trace, \"<SubTrackInformationAttribute value=\\\"%s\\\"/>\\n\", gf_4cc_to_str(p->attribute_list[i]) );\n\t}\n\tif (!p->size)\n\t\tfprintf(trace, \"<SubTrackInformationAttribute value=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"SubTrackInformationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stsg_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_SubTrackSampleGroupBox *p = (GF_SubTrackSampleGroupBox *)a;\n\tgf_isom_box_dump_start(a, \"SubTrackSampleGroupBox\", trace);\n\n\tif (p->grouping_type)\n\t\tfprintf(trace, \"grouping_type=\\\"%s\\\"\", gf_4cc_to_str(p->grouping_type) );\n\tfprintf(trace, \">\\n\");\n\n\tfor (i = 0; i < p->nb_groups; i++) {\n\t\tfprintf(trace, \"<SubTrackSampleGroupBoxEntry group_description_index=\\\"%d\\\"/>\\n\", p->group_description_index[i]);\n\t}\n\tif (!p->size)\n\t\tfprintf(trace, \"<SubTrackSampleGroupBoxEntry group_description_index=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"SubTrackSampleGroupBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err pcrb_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_PcrInfoBox *p = (GF_PcrInfoBox *)a;\n\tgf_isom_box_dump_start(a, \"MPEG2TSPCRInfoBox\", trace);\n\tfprintf(trace, \"subsegment_count=\\\"%d\\\">\\n\", p->subsegment_count);\n\n\tfor (i=0; i<p->subsegment_count; i++) {\n\t\tfprintf(trace, \"<PCRInfo PCR=\\\"\"LLU\"\\\" />\\n\", p->pcr_values[i]);\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<PCRInfo PCR=\\\"\\\" />\\n\");\n\t}\n\tgf_isom_box_dump_done(\"MPEG2TSPCRInfoBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err subs_dump(GF_Box *a, FILE * trace)\n{\n\tu32 entry_count, i, j;\n\tu16 subsample_count;\n\tGF_SubSampleInfoEntry *pSamp;\n\tGF_SubSampleEntry *pSubSamp;\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *) a;\n\n\tif (!a) return GF_BAD_PARAM;\n\n\tentry_count = gf_list_count(ptr->Samples);\n\tgf_isom_box_dump_start(a, \"SubSampleInformationBox\", trace);\n\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", entry_count);\n\n\tfor (i=0; i<entry_count; i++) {\n\t\tpSamp = (GF_SubSampleInfoEntry*) gf_list_get(ptr->Samples, i);\n\n\t\tsubsample_count = gf_list_count(pSamp->SubSamples);\n\n\t\tfprintf(trace, \"<SampleEntry SampleDelta=\\\"%d\\\" SubSampleCount=\\\"%d\\\">\\n\", pSamp->sample_delta, subsample_count);\n\n\t\tfor (j=0; j<subsample_count; j++) {\n\t\t\tpSubSamp = (GF_SubSampleEntry*) gf_list_get(pSamp->SubSamples, j);\n\t\t\tfprintf(trace, \"<SubSample Size=\\\"%u\\\" Priority=\\\"%u\\\" Discardable=\\\"%d\\\" Reserved=\\\"%08X\\\"/>\\n\", pSubSamp->subsample_size, pSubSamp->subsample_priority, pSubSamp->discardable, pSubSamp->reserved);\n\t\t}\n\t\tfprintf(trace, \"</SampleEntry>\\n\");\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \"<SampleEntry SampleDelta=\\\"\\\" SubSampleCount=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<SubSample Size=\\\"\\\" Priority=\\\"\\\" Discardable=\\\"\\\" Reserved=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</SampleEntry>\\n\");\n\t}\n\n\tgf_isom_box_dump_done(\"SubSampleInformationBox\", a, trace);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err tfdt_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"TrackFragmentBaseMediaDecodeTimeBox\", trace);\n\n\tfprintf(trace, \"baseMediaDecodeTime=\\\"\"LLD\"\\\">\\n\", ptr->baseMediaDecodeTime);\n\tgf_isom_box_dump_done(\"TrackFragmentBaseMediaDecodeTimeBox\", a, trace);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\nGF_Err rvcc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"RVCConfigurationBox\", trace);\n\tfprintf(trace, \"predefined=\\\"%d\\\"\", ptr->predefined_rvc_config);\n\tif (! ptr->predefined_rvc_config) fprintf(trace, \" rvc_meta_idx=\\\"%d\\\"\", ptr->rvc_meta_idx);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"RVCConfigurationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err sbgp_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_SampleGroupBox *ptr = (GF_SampleGroupBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"SampleGroupBox\", trace);\n\n\tif (ptr->grouping_type)\n\t\tfprintf(trace, \"grouping_type=\\\"%s\\\"\", gf_4cc_to_str(ptr->grouping_type) );\n\n\tif (ptr->version==1) {\n\t\tif (isalnum(ptr->grouping_type_parameter&0xFF)) {\n\t\t\tfprintf(trace, \" grouping_type_parameter=\\\"%s\\\"\", gf_4cc_to_str(ptr->grouping_type_parameter) );\n\t\t} else {\n\t\t\tfprintf(trace, \" grouping_type_parameter=\\\"%d\\\"\", ptr->grouping_type_parameter);\n\t\t}\n\t}\n\tfprintf(trace, \">\\n\");\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tfprintf(trace, \"<SampleGroupBoxEntry sample_count=\\\"%d\\\" group_description_index=\\\"%d\\\"/>\\n\", ptr->sample_entries[i].sample_count, ptr->sample_entries[i].group_description_index );\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \"<SampleGroupBoxEntry sample_count=\\\"\\\" group_description_index=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SampleGroupBox\", a, trace);\n\treturn GF_OK;\n}\n\nstatic void oinf_entry_dump(GF_OperatingPointsInformation *ptr, FILE * trace)\n{\n\tu32 i, count;\n\n\tif (!ptr) {\n\t\tfprintf(trace, \"<OperatingPointsInformation scalability_mask=\\\"Multiview|Spatial scalability|Auxilary|unknown\\\" num_profile_tier_level=\\\"\\\" num_operating_points=\\\"\\\" dependency_layers=\\\"\\\">\\n\");\n\n\t\tfprintf(trace, \" <ProfileTierLevel general_profile_space=\\\"\\\" general_tier_flag=\\\"\\\" general_profile_idc=\\\"\\\" general_profile_compatibility_flags=\\\"\\\" general_constraint_indicator_flags=\\\"\\\" />\\n\");\n\n\t\tfprintf(trace, \"<OperatingPoint output_layer_set_idx=\\\"\\\" max_temporal_id=\\\"\\\" layer_count=\\\"\\\" minPicWidth=\\\"\\\" minPicHeight=\\\"\\\" maxPicWidth=\\\"\\\" maxPicHeight=\\\"\\\" maxChromaFormat=\\\"\\\" maxBitDepth=\\\"\\\" frame_rate_info_flag=\\\"\\\" bit_rate_info_flag=\\\"\\\" avgFrameRate=\\\"\\\" constantFrameRate=\\\"\\\" maxBitRate=\\\"\\\" avgBitRate=\\\"\\\"/>\\n\");\n\n\t\tfprintf(trace, \"<Layer dependent_layerID=\\\"\\\" num_layers_dependent_on=\\\"\\\" dependent_on_layerID=\\\"\\\" dimension_identifier=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</OperatingPointsInformation>\\n\");\n\t\treturn;\n\t}\n\n\n\tfprintf(trace, \"<OperatingPointsInformation\");\n\tfprintf(trace, \" scalability_mask=\\\"%u (\", ptr->scalability_mask);\n\tswitch (ptr->scalability_mask) {\n\tcase 2:\n\t\tfprintf(trace, \"Multiview\");\n\t\tbreak;\n\tcase 4:\n\t\tfprintf(trace, \"Spatial scalability\");\n\t\tbreak;\n\tcase 8:\n\t\tfprintf(trace, \"Auxilary\");\n\t\tbreak;\n\tdefault:\n\t\tfprintf(trace, \"unknown\");\n\t}\n\tfprintf(trace, \")\\\" num_profile_tier_level=\\\"%u\\\"\", gf_list_count(ptr->profile_tier_levels) );\n\tfprintf(trace, \" num_operating_points=\\\"%u\\\" dependency_layers=\\\"%u\\\"\", gf_list_count(ptr->operating_points), gf_list_count(ptr->dependency_layers));\n\tfprintf(trace, \">\\n\");\n\n\n\tcount=gf_list_count(ptr->profile_tier_levels);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_ProfileTierLevel *ptl = (LHEVC_ProfileTierLevel *)gf_list_get(ptr->profile_tier_levels, i);\n\t\tfprintf(trace, \" <ProfileTierLevel general_profile_space=\\\"%u\\\" general_tier_flag=\\\"%u\\\" general_profile_idc=\\\"%u\\\" general_profile_compatibility_flags=\\\"%X\\\" general_constraint_indicator_flags=\\\"\"LLX\"\\\" />\\n\", ptl->general_profile_space, ptl->general_tier_flag, ptl->general_profile_idc, ptl->general_profile_compatibility_flags, ptl->general_constraint_indicator_flags);\n\t}\n\n\n\tcount=gf_list_count(ptr->operating_points);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op = (LHEVC_OperatingPoint *)gf_list_get(ptr->operating_points, i);\n\t\tfprintf(trace, \"<OperatingPoint output_layer_set_idx=\\\"%u\\\"\", op->output_layer_set_idx);\n\t\tfprintf(trace, \" max_temporal_id=\\\"%u\\\" layer_count=\\\"%u\\\"\", op->max_temporal_id, op->layer_count);\n\t\tfprintf(trace, \" minPicWidth=\\\"%u\\\" minPicHeight=\\\"%u\\\"\", op->minPicWidth, op->minPicHeight);\n\t\tfprintf(trace, \" maxPicWidth=\\\"%u\\\" maxPicHeight=\\\"%u\\\"\", op->maxPicWidth, op->maxPicHeight);\n\t\tfprintf(trace, \" maxChromaFormat=\\\"%u\\\" maxBitDepth=\\\"%u\\\"\", op->maxChromaFormat, op->maxBitDepth);\n\t\tfprintf(trace, \" frame_rate_info_flag=\\\"%u\\\" bit_rate_info_flag=\\\"%u\\\"\", op->frame_rate_info_flag, op->bit_rate_info_flag);\n\t\tif (op->frame_rate_info_flag) \n\t\t\tfprintf(trace, \" avgFrameRate=\\\"%u\\\" constantFrameRate=\\\"%u\\\"\", op->avgFrameRate, op->constantFrameRate);\n\t\tif (op->bit_rate_info_flag) \n\t\t\tfprintf(trace, \" maxBitRate=\\\"%u\\\" avgBitRate=\\\"%u\\\"\", op->maxBitRate, op->avgBitRate);\n\t\tfprintf(trace, \"/>\\n\");\n\t}\n\tcount=gf_list_count(ptr->dependency_layers);\n\tfor (i = 0; i < count; i++) {\n\t\tu32 j;\n\t\tLHEVC_DependentLayer *dep = (LHEVC_DependentLayer *)gf_list_get(ptr->dependency_layers, i);\n\t\tfprintf(trace, \"<Layer dependent_layerID=\\\"%u\\\" num_layers_dependent_on=\\\"%u\\\"\", dep->dependent_layerID, dep->num_layers_dependent_on);\n\t\tif (dep->num_layers_dependent_on) {\n\t\t\tfprintf(trace, \" dependent_on_layerID=\\\"\");\n\t\t\tfor (j = 0; j < dep->num_layers_dependent_on; j++)\n\t\t\t\tfprintf(trace, \"%d \", dep->dependent_on_layerID[j]);\n\t\t\tfprintf(trace, \"\\\"\");\n\t\t}\n\t\tfprintf(trace, \" dimension_identifier=\\\"\");\n\t\tfor (j = 0; j < 16; j++)\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tfprintf(trace, \"%d \", dep->dimension_identifier[j]);\n\t\tfprintf(trace, \"\\\"/>\\n\");\n\t}\n\tfprintf(trace, \"</OperatingPointsInformation>\\n\");\n\treturn;\n}\n\nstatic void linf_dump(GF_LHVCLayerInformation *ptr, FILE * trace)\n{\n\tu32 i, count;\n\tif (!ptr) {\n\t\tfprintf(trace, \"<LayerInformation num_layers=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<LayerInfoItem layer_id=\\\"\\\" min_temporalId=\\\"\\\" max_temporalId=\\\"\\\" sub_layer_presence_flags=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</LayerInformation>\\n\");\n\t\treturn;\n\t}\n\n\tcount = gf_list_count(ptr->num_layers_in_track);\n\tfprintf(trace, \"<LayerInformation num_layers=\\\"%d\\\">\\n\", count );\n\tfor (i = 0; i < count; i++) {\n\t\tLHVCLayerInfoItem *li = (LHVCLayerInfoItem *)gf_list_get(ptr->num_layers_in_track, i);\n\t\tfprintf(trace, \"<LayerInfoItem layer_id=\\\"%d\\\" min_temporalId=\\\"%d\\\" max_temporalId=\\\"%d\\\" sub_layer_presence_flags=\\\"%d\\\"/>\\n\", li->layer_id, li->min_TemporalId, li->max_TemporalId, li->sub_layer_presence_flags);\n\t}\n\tfprintf(trace, \"</LayerInformation>\\n\");\n\treturn;\n}\n\nstatic void trif_dump(FILE * trace, char *data, u32 data_size)\n{\n\tGF_BitStream *bs;\n\tu32 id, independent, filter_disabled;\n\tBool full_picture, has_dep, tile_group;\n\n\tif (!data) {\n\t\tfprintf(trace, \"<TileRegionGroupEntry ID=\\\"\\\" tileGroup=\\\"\\\" independent=\\\"\\\" full_picture=\\\"\\\" filter_disabled=\\\"\\\" x=\\\"\\\" y=\\\"\\\" w=\\\"\\\" h=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<TileRegionDependency tileID=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</TileRegionGroupEntry>\\n\");\n\t\treturn;\n\t}\n\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tid = gf_bs_read_u16(bs);\n\ttile_group = gf_bs_read_int(bs, 1);\n\tfprintf(trace, \"<TileRegionGroupEntry ID=\\\"%d\\\" tileGroup=\\\"%d\\\" \", id, tile_group);\n\tif (tile_group) {\n\t\tindependent = gf_bs_read_int(bs, 2);\n\t\tfull_picture = (Bool)gf_bs_read_int(bs, 1);\n\t\tfilter_disabled = gf_bs_read_int(bs, 1);\n\t\thas_dep = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 2);\n\t\tfprintf(trace, \"independent=\\\"%d\\\" full_picture=\\\"%d\\\" filter_disabled=\\\"%d\\\" \", independent, full_picture, filter_disabled);\n\n\t\tif (!full_picture) {\n\t\t\tfprintf(trace, \"x=\\\"%d\\\" y=\\\"%d\\\" \", gf_bs_read_u16(bs), gf_bs_read_u16(bs));\n\t\t}\n\t\tfprintf(trace, \"w=\\\"%d\\\" h=\\\"%d\\\" \", gf_bs_read_u16(bs), gf_bs_read_u16(bs));\n\t\tif (!has_dep) {\n\t\t\tfprintf(trace, \"/>\\n\");\n\t\t} else {\n\t\t\tu32 count = gf_bs_read_u16(bs);\n\t\t\tfprintf(trace, \">\\n\");\n\t\t\twhile (count) {\n\t\t\t\tcount--;\n\t\t\t\tfprintf(trace, \"<TileRegionDependency tileID=\\\"%d\\\"/>\\n\", gf_bs_read_u16(bs) );\n\t\t\t}\n\t\t\tfprintf(trace, \"</TileRegionGroupEntry>\\n\");\n\t\t}\n\t}\n\tgf_bs_del(bs);\n}\n\nstatic void nalm_dump(FILE * trace, char *data, u32 data_size)\n{\n\tGF_BitStream *bs;\n\n\tBool rle, large_size;\n\tu32 entry_count;\n\n\tif (!data) {\n\t\tfprintf(trace, \"<NALUMap rle=\\\"\\\" large_size=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<NALUMapEntry NALU_startNumber=\\\"\\\" groupID=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</NALUMap>\\n\");\n\t\treturn;\n\t}\n\t\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tgf_bs_read_int(bs, 6);\n\tlarge_size = gf_bs_read_int(bs, 1);\n\trle = gf_bs_read_int(bs, 1);\n\tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n\tfprintf(trace, \"<NALUMap rle=\\\"%d\\\" large_size=\\\"%d\\\">\\n\", rle, large_size);\n\t\n\twhile (entry_count) {\n\t\tu32 ID;\n\t\tfprintf(trace, \"<NALUMapEntry \");\n\t\tif (rle) {\n\t\t\tu32 start_num = gf_bs_read_int(bs, large_size ? 16 : 8);\n\t\t\tfprintf(trace, \"NALU_startNumber=\\\"%d\\\" \", start_num);\n\t\t}\n\t\tID = gf_bs_read_u16(bs);\n\t\tfprintf(trace, \"groupID=\\\"%d\\\"/>\\n\", ID);\n\t\tentry_count--;\n\t}\n\tgf_bs_del(bs);\n\tfprintf(trace, \"</NALUMap>\\n\");\n\treturn;\n}\n\n\nGF_Err sgpd_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_SampleGroupDescriptionBox *ptr = (GF_SampleGroupDescriptionBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"SampleGroupDescriptionBox\", trace);\n\n\tif (ptr->grouping_type)\n\t\tfprintf(trace, \"grouping_type=\\\"%s\\\"\", gf_4cc_to_str(ptr->grouping_type) );\n\tif (ptr->version==1) fprintf(trace, \" default_length=\\\"%d\\\"\", ptr->default_length);\n\tif ((ptr->version>=2) && ptr->default_description_index) fprintf(trace, \" default_group_index=\\\"%d\\\"\", ptr->default_description_index);\n\tfprintf(trace, \">\\n\");\n\tfor (i=0; i<gf_list_count(ptr->group_descriptions); i++) {\n\t\tvoid *entry = gf_list_get(ptr->group_descriptions, i);\n\t\tswitch (ptr->grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\t\tfprintf(trace, \"<RollRecoveryEntry roll_distance=\\\"%d\\\" />\\n\", ((GF_RollRecoveryEntry*)entry)->roll_distance );\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\t\tfprintf(trace, \"<AudioPreRollEntry roll_distance=\\\"%d\\\" />\\n\", ((GF_RollRecoveryEntry*)entry)->roll_distance );\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t\t\tfprintf(trace, \"<TemporalLevelEntry level_independently_decodable=\\\"%d\\\"/>\\n\", ((GF_TemporalLevelEntry*)entry)->level_independently_decodable);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\t\tfprintf(trace, \"<VisualRandomAccessEntry num_leading_samples_known=\\\"%s\\\"\", ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples_known ? \"yes\" : \"no\");\n\t\t\tif (((GF_VisualRandomAccessEntry*)entry)->num_leading_samples_known)\n\t\t\t\tfprintf(trace, \" num_leading_samples=\\\"%d\\\"\", ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples);\n\t\t\tfprintf(trace, \"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\tfprintf(trace, \"<SyncSampleGroupEntry NAL_unit_type=\\\"%d\\\"/>\\n\", ((GF_SYNCEntry*)entry)->NALU_type);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t\t\tfprintf(trace, \"<CENCSampleEncryptionGroupEntry IsEncrypted=\\\"%d\\\" IV_size=\\\"%d\\\" KID=\\\"\", ((GF_CENCSampleEncryptionGroupEntry*)entry)->IsProtected, ((GF_CENCSampleEncryptionGroupEntry*)entry)->Per_Sample_IV_size);\n\t\t\tdump_data_hex(trace, (char *)((GF_CENCSampleEncryptionGroupEntry*)entry)->KID, 16);\n\t\t\tif ((((GF_CENCSampleEncryptionGroupEntry*)entry)->IsProtected == 1) && !((GF_CENCSampleEncryptionGroupEntry*)entry)->Per_Sample_IV_size) {\n\t\t\t\tfprintf(trace, \"\\\" constant_IV_size=\\\"%d\\\"  constant_IV=\\\"\", ((GF_CENCSampleEncryptionGroupEntry*)entry)->constant_IV_size);\n\t\t\t\tdump_data_hex(trace, (char *)((GF_CENCSampleEncryptionGroupEntry*)entry)->constant_IV, ((GF_CENCSampleEncryptionGroupEntry*)entry)->constant_IV_size);\n\t\t\t}\n\t\t\tfprintf(trace, \"\\\"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\t\toinf_entry_dump(entry, trace);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\t\tlinf_dump(entry, trace);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n\t\t\ttrif_dump(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n\t\t\tbreak;\n\t\t\t\n\t\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n\t\t\tnalm_dump(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\t\tfprintf(trace, \"<SAPEntry dependent_flag=\\\"%d\\\" SAP_type=\\\"%d\\\" />\\n\", ((GF_SAPEntry*)entry)->dependent_flag, ((GF_SAPEntry*)entry)->SAP_type);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(trace, \"<DefaultSampleGroupDescriptionEntry size=\\\"%d\\\" data=\\\"\", ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n\t\t\tdump_data(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n\t\t\tfprintf(trace, \"\\\"/>\\n\");\n\t\t}\n\t}\n\tif (!ptr->size) {\n\t\tswitch (ptr->grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\t\tfprintf(trace, \"<RollRecoveryEntry roll_distance=\\\"\\\"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\t\tfprintf(trace, \"<AudioPreRollEntry roll_distance=\\\"\\\"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t\t\tfprintf(trace, \"<TemporalLevelEntry level_independently_decodable=\\\"\\\"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\t\tfprintf(trace, \"<VisualRandomAccessEntry num_leading_samples_known=\\\"yes|no\\\" num_leading_samples=\\\"\\\" />\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\tfprintf(trace, \"<SyncSampleGroupEntry NAL_unit_type=\\\"\\\" />\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t\t\tfprintf(trace, \"<CENCSampleEncryptionGroupEntry IsEncrypted=\\\"\\\" IV_size=\\\"\\\" KID=\\\"\\\" constant_IV_size=\\\"\\\"  constant_IV=\\\"\\\"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\t\toinf_entry_dump(NULL, trace);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\t\tlinf_dump(NULL, trace);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n\t\t\ttrif_dump(trace, NULL, 0);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n\t\t\tnalm_dump(trace, NULL, 0);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\t\tfprintf(trace, \"<SAPEntry dependent_flag=\\\"\\\" SAP_type=\\\"\\\" />\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(trace, \"<DefaultSampleGroupDescriptionEntry size=\\\"\\\" data=\\\"\\\"/>\\n\");\n\t\t}\n\t}\n\n\tgf_isom_box_dump_done(\"SampleGroupDescriptionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err saiz_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_SampleAuxiliaryInfoSizeBox *ptr = (GF_SampleAuxiliaryInfoSizeBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"SampleAuxiliaryInfoSizeBox\", trace);\n\n\tfprintf(trace, \"default_sample_info_size=\\\"%d\\\" sample_count=\\\"%d\\\"\", ptr->default_sample_info_size, ptr->sample_count);\n\tif (ptr->flags & 1) {\n\t\tif (isalnum(ptr->aux_info_type>>24)) {\n\t\t\tfprintf(trace, \" aux_info_type=\\\"%s\\\" aux_info_type_parameter=\\\"%d\\\"\", gf_4cc_to_str(ptr->aux_info_type), ptr->aux_info_type_parameter);\n\t\t} else {\n\t\t\tfprintf(trace, \" aux_info_type=\\\"%d\\\" aux_info_type_parameter=\\\"%d\\\"\", ptr->aux_info_type, ptr->aux_info_type_parameter);\n\t\t}\n\t}\n\tfprintf(trace, \">\\n\");\n\tif (ptr->default_sample_info_size==0) {\n\t\tfor (i=0; i<ptr->sample_count; i++) {\n\t\t\tfprintf(trace, \"<SAISize size=\\\"%d\\\" />\\n\", ptr->sample_info_size[i]);\n\t\t}\n\t}\n\tif (!ptr->size) {\n\t\t\tfprintf(trace, \"<SAISize size=\\\"\\\" />\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SampleAuxiliaryInfoSizeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err saio_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"SampleAuxiliaryInfoOffsetBox\", trace);\n\n\tfprintf(trace, \"entry_count=\\\"%d\\\"\", ptr->entry_count);\n\tif (ptr->flags & 1) {\n\t\tif (isalnum(ptr->aux_info_type>>24)) {\n\t\t\tfprintf(trace, \" aux_info_type=\\\"%s\\\" aux_info_type_parameter=\\\"%d\\\"\", gf_4cc_to_str(ptr->aux_info_type), ptr->aux_info_type_parameter);\n\t\t} else {\n\t\t\tfprintf(trace, \" aux_info_type=\\\"%d\\\" aux_info_type_parameter=\\\"%d\\\"\", ptr->aux_info_type, ptr->aux_info_type_parameter);\n\t\t}\n\t}\n\n\tfprintf(trace, \">\\n\");\n\n\tif (ptr->version==0) {\n\t\tfor (i=0; i<ptr->entry_count; i++) {\n\t\t\tfprintf(trace, \"<SAIChunkOffset offset=\\\"%d\\\"/>\\n\", ptr->offsets[i]);\n\t\t}\n\t} else {\n\t\tfor (i=0; i<ptr->entry_count; i++) {\n\t\t\tfprintf(trace, \"<SAIChunkOffset offset=\\\"\"LLD\"\\\"/>\\n\", ptr->offsets_large[i]);\n\t\t}\n\t}\n\tif (!ptr->size) {\n\t\t\tfprintf(trace, \"<SAIChunkOffset offset=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SampleAuxiliaryInfoOffsetBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err pssh_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ProtectionSystemHeaderBox *ptr = (GF_ProtectionSystemHeaderBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"ProtectionSystemHeaderBox\", trace);\n\n\tfprintf(trace, \"SystemID=\\\"\");\n\tdump_data_hex(trace, (char *) ptr->SystemID, 16);\n\tfprintf(trace, \"\\\">\\n\");\n\n\tif (ptr->KID_count) {\n\t\tu32 i;\n\t\tfor (i=0; i<ptr->KID_count; i++) {\n\t\t\tfprintf(trace, \" <PSSHKey KID=\\\"\");\n\t\t\tdump_data_hex(trace, (char *) ptr->KIDs[i], 16);\n\t\t\tfprintf(trace, \"\\\"/>\\n\");\n\t\t}\n\t}\n\tif (ptr->private_data_size) {\n\t\tfprintf(trace, \" <PSSHData size=\\\"%d\\\" value=\\\"\", ptr->private_data_size);\n\t\tdump_data_hex(trace, (char *) ptr->private_data, ptr->private_data_size);\n\t\tfprintf(trace, \"\\\"/>\\n\");\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \" <PSSHKey KID=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \" <PSSHData size=\\\"\\\" value=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"ProtectionSystemHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tenc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"TrackEncryptionBox\", trace);\n\n\tfprintf(trace, \"isEncrypted=\\\"%d\\\"\", ptr->isProtected);\n\tif (ptr->Per_Sample_IV_Size)\n\t\tfprintf(trace, \" IV_size=\\\"%d\\\" KID=\\\"\", ptr->Per_Sample_IV_Size);\n\telse {\n\t\tfprintf(trace, \" constant_IV_size=\\\"%d\\\" constant_IV=\\\"\", ptr->constant_IV_size);\n\t\tdump_data_hex(trace, (char *) ptr->constant_IV, ptr->constant_IV_size);\n\t\tfprintf(trace, \"\\\"  KID=\\\"\");\n\t}\n\tdump_data_hex(trace, (char *) ptr->KID, 16);\n\tif (ptr->version) \n\t\tfprintf(trace, \"\\\" crypt_byte_block=\\\"%d\\\" skip_byte_block=\\\"%d\", ptr->crypt_byte_block, ptr->skip_byte_block);\n\tfprintf(trace, \"\\\">\\n\");\n\tgf_isom_box_dump_done(\"TrackEncryptionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err piff_pssh_dump(GF_Box *a, FILE * trace)\n{\n\tGF_PIFFProtectionSystemHeaderBox *ptr = (GF_PIFFProtectionSystemHeaderBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"PIFFProtectionSystemHeaderBox\", trace);\n\n\tfprintf(trace, \"SystemID=\\\"\");\n\tdump_data_hex(trace, (char *) ptr->SystemID, 16);\n\tfprintf(trace, \"\\\" PrivateData=\\\"\");\n\tdump_data_hex(trace, (char *) ptr->private_data, ptr->private_data_size);\n\tfprintf(trace, \"\\\">\\n\");\n\tgf_isom_box_dump_done(\"PIFFProtectionSystemHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err piff_tenc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_PIFFTrackEncryptionBox *ptr = (GF_PIFFTrackEncryptionBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"PIFFTrackEncryptionBox\", trace);\n\n\tfprintf(trace, \"AlgorithmID=\\\"%d\\\" IV_size=\\\"%d\\\" KID=\\\"\", ptr->AlgorithmID, ptr->IV_size);\n\tdump_data_hex(trace,(char *) ptr->KID, 16);\n\tfprintf(trace, \"\\\">\\n\");\n\tgf_isom_box_dump_done(\"PIFFTrackEncryptionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err piff_psec_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i, j, sample_count;\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox *) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"PIFFSampleEncryptionBox\", trace);\n\tsample_count = gf_list_count(ptr->samp_aux_info);\n\tfprintf(trace, \"sampleCount=\\\"%d\\\"\", sample_count);\n\tif (ptr->flags & 1) {\n\t\tfprintf(trace, \" AlgorithmID=\\\"%d\\\" IV_size=\\\"%d\\\" KID=\\\"\", ptr->AlgorithmID, ptr->IV_size);\n\t\tdump_data(trace, (char *) ptr->KID, 16);\n\t\tfprintf(trace, \"\\\"\");\n\t}\n\tfprintf(trace, \">\\n\");\n\n\tif (sample_count) {\n\t\tfor (i=0; i<sample_count; i++) {\n\t\t\tGF_CENCSampleAuxInfo *cenc_sample = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, i);\n\n\t\t\tif (cenc_sample) {\n\t\t\t\tif  (!strlen((char *)cenc_sample->IV)) continue;\n\t\t\t\tfprintf(trace, \"<PIFFSampleEncryptionEntry IV_size=\\\"%u\\\" IV=\\\"\", cenc_sample->IV_size);\n\t\t\t\tdump_data_hex(trace, (char *) cenc_sample->IV, cenc_sample->IV_size);\n\t\t\t\tif (ptr->flags & 0x2) {\n\t\t\t\t\tfprintf(trace, \"\\\" SubsampleCount=\\\"%d\\\"\", cenc_sample->subsample_count);\n\t\t\t\t\tfprintf(trace, \">\\n\");\n\n\t\t\t\t\tfor (j=0; j<cenc_sample->subsample_count; j++) {\n\t\t\t\t\t\tfprintf(trace, \"<PIFFSubSampleEncryptionEntry NumClearBytes=\\\"%d\\\" NumEncryptedBytes=\\\"%d\\\"/>\\n\", cenc_sample->subsamples[j].bytes_clear_data, cenc_sample->subsamples[j].bytes_encrypted_data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfprintf(trace, \"</PIFFSampleEncryptionEntry>\\n\");\n\t\t\t}\n\t\t}\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \"<PIFFSampleEncryptionEntry IV=\\\"\\\" SubsampleCount=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<PIFFSubSampleEncryptionEntry NumClearBytes=\\\"\\\" NumEncryptedBytes=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</PIFFSampleEncryptionEntry>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"PIFFSampleEncryptionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err senc_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i, j, sample_count;\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox *) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"SampleEncryptionBox\", trace);\n\tsample_count = gf_list_count(ptr->samp_aux_info);\n\tfprintf(trace, \"sampleCount=\\\"%d\\\">\\n\", sample_count);\n\t//WARNING - PSEC (UUID) IS TYPECASTED TO SENC (FULL BOX) SO WE CANNOT USE USUAL FULL BOX FUNCTIONS\n\tfprintf(trace, \"<FullBoxInfo Version=\\\"%d\\\" Flags=\\\"0x%X\\\"/>\\n\", ptr->version, ptr->flags);\n\tfor (i=0; i<sample_count; i++) {\n\t\tGF_CENCSampleAuxInfo *cenc_sample = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, i);\n\n\t\tif (cenc_sample) {\n\t\t\tfprintf(trace, \"<SampleEncryptionEntry sampleNumber=\\\"%d\\\" IV_size=\\\"%u\\\" IV=\\\"\", i+1, cenc_sample->IV_size);\n\t\t\tdump_data_hex(trace, (char *) cenc_sample->IV, cenc_sample->IV_size);\n\t\t\tfprintf(trace, \"\\\"\");\n\t\t\tif (ptr->flags & 0x2) {\n\t\t\t\tfprintf(trace, \" SubsampleCount=\\\"%d\\\"\", cenc_sample->subsample_count);\n\t\t\t\tfprintf(trace, \">\\n\");\n\n\t\t\t\tfor (j=0; j<cenc_sample->subsample_count; j++) {\n\t\t\t\t\tfprintf(trace, \"<SubSampleEncryptionEntry NumClearBytes=\\\"%d\\\" NumEncryptedBytes=\\\"%d\\\"/>\\n\", cenc_sample->subsamples[j].bytes_clear_data, cenc_sample->subsamples[j].bytes_encrypted_data);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf(trace, \">\\n\");\n\t\t\t}\n\t\t\tfprintf(trace, \"</SampleEncryptionEntry>\\n\");\n\t\t}\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \"<SampleEncryptionEntry sampleCount=\\\"\\\" IV=\\\"\\\" SubsampleCount=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<SubSampleEncryptionEntry NumClearBytes=\\\"\\\" NumEncryptedBytes=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</SampleEncryptionEntry>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SampleEncryptionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err prft_dump(GF_Box *a, FILE * trace)\n{\n\tDouble fracs;\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox *) a;\n\ttime_t secs;\n\tstruct tm t;\n\tsecs = (ptr->ntp >> 32) - GF_NTP_SEC_1900_TO_1970;\n\tif (secs < 0) {\n\t\tif (ptr->size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"NTP time is not valid, using value 0\\n\"));\n\t\t}\n\t\tsecs = 0;\n\t}\n\tt = *gmtime(&secs);\n\tfracs = (Double) (ptr->ntp & 0xFFFFFFFFULL);\n\tfracs /= 0xFFFFFFFF;\n\tfracs *= 1000;\n\tgf_isom_box_dump_start(a, \"ProducerReferenceTimeBox\", trace);\n\n\tfprintf(trace, \"referenceTrackID=\\\"%d\\\" timestamp=\\\"\"LLU\"\\\" NTP=\\\"\"LLU\"\\\" UTC=\\\"%d-%02d-%02dT%02d:%02d:%02d.%03dZ\\\">\\n\", ptr->refTrackID, ptr->timestamp, ptr->ntp, 1900+t.tm_year, t.tm_mon+1, t.tm_mday, t.tm_hour, t.tm_min, (u32) t.tm_sec, (u32) fracs);\n\tgf_isom_box_dump_done(\"ProducerReferenceTimeBox\", a, trace);\n\n\treturn GF_OK;\n}\n\nGF_Err adkm_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AdobeDRMKeyManagementSystemBox *ptr = (GF_AdobeDRMKeyManagementSystemBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"AdobeDRMKeyManagementSystemBox\", trace);\n\n\tfprintf(trace, \">\\n\");\n\tif (ptr->header) gf_isom_box_dump((GF_Box *)ptr->header, trace);\n\tif (ptr->au_format) gf_isom_box_dump((GF_Box *)ptr->au_format, trace);\n\tgf_isom_box_dump_done(\"AdobeDRMKeyManagementSystemBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ahdr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AdobeDRMHeaderBox *ptr = (GF_AdobeDRMHeaderBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"AdobeDRMHeaderBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (ptr->std_enc_params) gf_isom_box_dump((GF_Box *)ptr->std_enc_params, trace);\n\tgf_isom_box_dump_done(\"AdobeDRMHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err aprm_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AdobeStdEncryptionParamsBox *ptr = (GF_AdobeStdEncryptionParamsBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"AdobeStdEncryptionParamsBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (ptr->enc_info) gf_isom_box_dump((GF_Box *)ptr->enc_info, trace);\n\tif (ptr->key_info) gf_isom_box_dump((GF_Box *)ptr->key_info, trace);\n\tgf_isom_box_dump_done(\"AdobeStdEncryptionParamsBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err aeib_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AdobeEncryptionInfoBox *ptr = (GF_AdobeEncryptionInfoBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"AdobeEncryptionInfoBox\", trace);\n\tfprintf(trace, \"EncryptionAlgorithm=\\\"%s\\\" KeyLength=\\\"%d\\\">\\n\", ptr->enc_algo, ptr->key_length);\n\tgf_isom_box_dump_done(\"AdobeEncryptionInfoBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err akey_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AdobeKeyInfoBox *ptr = (GF_AdobeKeyInfoBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"AdobeKeyInfoBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (ptr->params) gf_isom_box_dump((GF_Box *)ptr->params, trace);\n\tgf_isom_box_dump_done(\"AdobeKeyInfoBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err flxs_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AdobeFlashAccessParamsBox *ptr = (GF_AdobeFlashAccessParamsBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"AdobeFlashAccessParamsBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (ptr->metadata)\n\t\tfprintf(trace, \"<FmrmsV2Metadata=\\\"%s\\\"/>\\n\", ptr->metadata);\n\tgf_isom_box_dump_done(\"AdobeFlashAccessParamsBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err adaf_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AdobeDRMAUFormatBox *ptr = (GF_AdobeDRMAUFormatBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"AdobeDRMAUFormatBox \", trace);\n\tfprintf(trace, \"SelectiveEncryption=\\\"%d\\\" IV_length=\\\"%d\\\">\\n\", ptr->selective_enc ? 1 : 0, ptr->IV_length);\n\tgf_isom_box_dump_done(\"AdobeDRMAUFormatBox\", a, trace);\n\treturn GF_OK;\n}\n\n/* Image File Format dump */\nGF_Err ispe_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ImageSpatialExtentsPropertyBox *ptr = (GF_ImageSpatialExtentsPropertyBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"ImageSpatialExtentsPropertyBox\", trace);\n\tfprintf(trace, \"image_width=\\\"%d\\\" image_height=\\\"%d\\\">\\n\", ptr->image_width, ptr->image_height);\n\tgf_isom_box_dump_done(\"ImageSpatialExtentsPropertyBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err colr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ColourInformationBox *ptr = (GF_ColourInformationBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"ColourInformationBox\", trace);\n\tfprintf(trace, \"colour_type=\\\"%s\\\" colour_primaries=\\\"%d\\\" transfer_characteristics=\\\"%d\\\" matrix_coefficients=\\\"%d\\\" full_range_flag=\\\"%d\\\">\\n\", gf_4cc_to_str(ptr->colour_type), ptr->colour_primaries, ptr->transfer_characteristics, ptr->matrix_coefficients, ptr->full_range_flag);\n\tgf_isom_box_dump_done(\"ColourInformationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err pixi_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_PixelInformationPropertyBox *ptr = (GF_PixelInformationPropertyBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"PixelInformationPropertyBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tfor (i = 0; i < ptr->num_channels; i++) {\n\t\tfprintf(trace, \"<BitPerChannel bits_per_channel=\\\"%d\\\"/>\\n\", ptr->bits_per_channel[i]);\n\t}\n\tif (!ptr->size)\n\t\tfprintf(trace, \"<BitPerChannel bits_per_channel=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"PixelInformationPropertyBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err rloc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_RelativeLocationPropertyBox *ptr = (GF_RelativeLocationPropertyBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"RelativeLocationPropertyBox\", trace);\n\tfprintf(trace, \"horizontal_offset=\\\"%d\\\" vertical_offset=\\\"%d\\\">\\n\", ptr->horizontal_offset, ptr->vertical_offset);\n\tgf_isom_box_dump_done(\"RelativeLocationPropertyBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err irot_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ImageRotationBox *ptr = (GF_ImageRotationBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"ImageRotationBox\", trace);\n\tfprintf(trace, \"angle=\\\"%d\\\">\\n\", (ptr->angle*90));\n\tgf_isom_box_dump_done(\"ImageRotationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ipco_dump(GF_Box *a, FILE * trace)\n{\n\tgf_isom_box_dump_start(a, \"ItemPropertyContainerBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"ItemPropertyContainerBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err iprp_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ItemPropertiesBox *ptr = (GF_ItemPropertiesBox *)a;\n\tgf_isom_box_dump_start(a, \"ItemPropertiesBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (ptr->property_container) gf_isom_box_dump(ptr->property_container, trace);\n\tif (ptr->property_association) gf_isom_box_dump(ptr->property_association, trace);\n\tgf_isom_box_dump_done(\"ItemPropertiesBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ipma_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i, j;\n\tGF_ItemPropertyAssociationBox *ptr = (GF_ItemPropertyAssociationBox *)a;\n\tu32 entry_count = gf_list_count(ptr->entries);\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"ItemPropertyAssociationBox\", trace);\n\tfprintf(trace, \"entry_count=\\\"%d\\\">\\n\", entry_count);\n\tfor (i = 0; i < entry_count; i++) {\n\t\tGF_ItemPropertyAssociationEntry *entry = (GF_ItemPropertyAssociationEntry *)gf_list_get(ptr->entries, i);\n\t\tu32 association_count = gf_list_count(entry->essential);\n\t\tfprintf(trace, \"<AssociationEntry item_ID=\\\"%d\\\" association_count=\\\"%d\\\">\\n\", entry->item_id, association_count);\n\t\tfor (j = 0; j < association_count; j++) {\n\t\t\tBool *ess = (Bool *)gf_list_get(entry->essential, j);\n\t\t\tu32 *prop_index = (u32 *)gf_list_get(entry->property_index, j);\n\t\t\tfprintf(trace, \"<Property index=\\\"%d\\\" essential=\\\"%d\\\"/>\\n\", *prop_index, *ess);\n\t\t}\n\t\tfprintf(trace, \"</AssociationEntry>\\n\");\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \"<AssociationEntry item_ID=\\\"\\\" association_count=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<Property index=\\\"\\\" essential=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</AssociationEntry>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"ItemPropertyAssociationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err auxc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AuxiliaryTypePropertyBox *ptr = (GF_AuxiliaryTypePropertyBox *)a;\n\n\tgf_isom_box_dump_start(a, \"AuxiliaryTypePropertyBox\", trace);\n\tfprintf(trace, \"aux_type=\\\"%s\\\" \", ptr->aux_urn);\n\tdump_data_attribute(trace, \"aux_subtype\", ptr->data, ptr->data_size);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"AuxiliaryTypePropertyBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err oinf_dump(GF_Box *a, FILE * trace)\n{\n\tGF_OINFPropertyBox *ptr = (GF_OINFPropertyBox *)a;\n\tgf_isom_box_dump_start(a, \"OperatingPointsInformationPropertyBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\toinf_entry_dump(ptr->oinf, trace);\n\n\tgf_isom_box_dump_done(\"OperatingPointsInformationPropertyBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err tols_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TargetOLSPropertyBox *ptr = (GF_TargetOLSPropertyBox *)a;\n\tgf_isom_box_dump_start(a, \"TargetOLSPropertyBox\", trace);\n\tfprintf(trace, \"target_ols_index=\\\"%d\\\">\\n\", ptr->target_ols_index);\n\n\tgf_isom_box_dump_done(\"TargetOLSPropertyBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err trgr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *) a;\n\tgf_isom_box_dump_start(a, \"TrackGroupBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_array_dump(ptr->groups, trace);\n\tgf_isom_box_dump_done(\"TrackGroupBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err trgt_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *) a;\n\ta->type = ptr->group_type;\n\tgf_isom_box_dump_start(a, \"TrackGroupTypeBox\", trace);\n\ta->type = GF_ISOM_BOX_TYPE_TRGT;\n\tfprintf(trace, \"track_group_id=\\\"%d\\\">\\n\", ptr->track_group_id);\n\tgf_isom_box_dump_done(\"TrackGroupTypeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err grpl_dump(GF_Box *a, FILE * trace)\n{\n\tgf_isom_box_dump_start(a, \"GroupListBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"GroupListBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err grptype_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_EntityToGroupTypeBox *ptr = (GF_EntityToGroupTypeBox *) a;\n\ta->type = ptr->grouping_type;\n\tgf_isom_box_dump_start(a, \"EntityToGroupTypeBox\", trace);\n\ta->type = GF_ISOM_BOX_TYPE_GRPT;\n\tfprintf(trace, \"group_id=\\\"%d\\\">\\n\", ptr->group_id);\n\n\tfor (i=0; i<ptr->entity_id_count ; i++)\n\t\tfprintf(trace, \"<EntityToGroupTypeBoxEntry EntityID=\\\"%d\\\"/>\\n\", ptr->entity_ids[i]);\n\n\tif (!ptr->size)\n\t\tfprintf(trace, \"<EntityToGroupTypeBoxEntry EntityID=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"EntityToGroupTypeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stvi_dump(GF_Box *a, FILE * trace)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *) a;\n\tgf_isom_box_dump_start(a, \"StereoVideoBox\", trace);\n\n\tfprintf(trace, \"single_view_allowed=\\\"%d\\\" stereo_scheme=\\\"%d\\\" \", ptr->single_view_allowed, ptr->stereo_scheme);\n\tdump_data_attribute(trace, \"stereo_indication_type\", ptr->stereo_indication_type, ptr->sit_len);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"StereoVideoBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err def_cont_box_dump(GF_Box *a, FILE *trace)\n{\n\tchar *name = \"SubTrackDefinitionBox\"; //only one using generic box container for now\n\tgf_isom_box_dump_start(a, name, trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(name, a, trace);\n\treturn GF_OK;\n}\n\nGF_Err fiin_dump(GF_Box *a, FILE * trace)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *) a;\n\tgf_isom_box_dump_start(a, \"FDItemInformationBox\", trace);\n\n\tfprintf(trace, \">\\n\");\n\tif (ptr->partition_entries)\n\t\tgf_isom_box_array_dump(ptr->partition_entries, trace);\n\n\tif (ptr->session_info)\n\t\tgf_isom_box_dump(ptr->session_info, trace);\n\n\tif (ptr->group_id_to_name)\n\t\tgf_isom_box_dump(ptr->group_id_to_name, trace);\n\n\tgf_isom_box_dump_done(\"FDItemInformationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err fecr_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tchar *box_name;\n\tFECReservoirBox *ptr = (FECReservoirBox *) a;\n\tif (a->type==GF_ISOM_BOX_TYPE_FIRE) {\n\t\tbox_name = \"FILEReservoirBox\";\n\t} else {\n\t\tbox_name = \"FECReservoirBox\";\n\t}\n\tgf_isom_box_dump_start(a, box_name, trace);\n\n\tfprintf(trace, \">\\n\");\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tfprintf(trace, \"<%sEntry itemID=\\\"%d\\\" symbol_count=\\\"%d\\\"/>\\n\", box_name, ptr->entries[i].item_id, ptr->entries[i].symbol_count);\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \"<%sEntry itemID=\\\"\\\" symbol_count=\\\"\\\"/>\\n\", box_name);\n\t}\n\tgf_isom_box_dump_done(box_name, a, trace);\n\treturn GF_OK;\n}\n\nGF_Err gitn_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *) a;\n\tgf_isom_box_dump_start(a, \"GroupIdToNameBox\", trace);\n\n\tfprintf(trace, \">\\n\");\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tfprintf(trace, \"<GroupIdToNameBoxEntry groupID=\\\"%d\\\" name=\\\"%s\\\"/>\\n\", ptr->entries[i].group_id, ptr->entries[i].name);\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \"<GroupIdToNameBoxEntryEntry groupID=\\\"\\\" name=\\\"\\\"/>\\n\");\n\t}\n\n\tgf_isom_box_dump_done(\"GroupIdToNameBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err paen_dump(GF_Box *a, FILE * trace)\n{\n\tFDPartitionEntryBox *ptr = (FDPartitionEntryBox *) a;\n\tgf_isom_box_dump_start(a, \"FDPartitionEntryBox\", trace);\n\n\tfprintf(trace, \">\\n\");\n\tif (ptr->blocks_and_symbols)\n\t\tgf_isom_box_dump(ptr->blocks_and_symbols, trace);\n\n\tif (ptr->FEC_symbol_locations)\n\t\tgf_isom_box_dump(ptr->FEC_symbol_locations, trace);\n\n\tif (ptr->FEC_symbol_locations)\n\t\tgf_isom_box_dump(ptr->FEC_symbol_locations, trace);\n\n\tgf_isom_box_dump_done(\"FDPartitionEntryBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err fpar_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tFilePartitionBox *ptr = (FilePartitionBox *) a;\n\tgf_isom_box_dump_start(a, \"FilePartitionBox\", trace);\n\n\tfprintf(trace, \"itemID=\\\"%d\\\" FEC_encoding_ID=\\\"%d\\\" FEC_instance_ID=\\\"%d\\\" max_source_block_length=\\\"%d\\\" encoding_symbol_length=\\\"%d\\\" max_number_of_encoding_symbols=\\\"%d\\\" \", ptr->itemID, ptr->FEC_encoding_ID, ptr->FEC_instance_ID, ptr->max_source_block_length, ptr->encoding_symbol_length, ptr->max_number_of_encoding_symbols);\n\n\tif (ptr->scheme_specific_info)\n\t\tdump_data_attribute(trace, \"scheme_specific_info\", (char*)ptr->scheme_specific_info, (u32)strlen(ptr->scheme_specific_info) );\n\n\tfprintf(trace, \">\\n\");\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tfprintf(trace, \"<FilePartitionBoxEntry block_count=\\\"%d\\\" block_size=\\\"%d\\\"/>\\n\", ptr->entries[i].block_count, ptr->entries[i].block_size);\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \"<FilePartitionBoxEntry block_count=\\\"\\\" block_size=\\\"\\\"/>\\n\");\n\t}\n\n\tgf_isom_box_dump_done(\"FilePartitionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err segr_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i, k;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *) a;\n\tgf_isom_box_dump_start(a, \"FDSessionGroupBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tfprintf(trace, \"<FDSessionGroupBoxEntry groupIDs=\\\"\");\n\t\tfor (k=0; k<ptr->session_groups[i].nb_groups; k++) {\n\t\t\tfprintf(trace, \"%d \", ptr->session_groups[i].group_ids[k]);\n\t\t}\n\t\tfprintf(trace, \"\\\" channels=\\\"\");\n\t\tfor (k=0; k<ptr->session_groups[i].nb_channels; k++) {\n\t\t\tfprintf(trace, \"%d \", ptr->session_groups[i].channels[k]);\n\t\t}\n\t\tfprintf(trace, \"\\\"/>\\n\");\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \"<FDSessionGroupBoxEntry groupIDs=\\\"\\\" channels=\\\"\\\"/>\\n\");\n\t}\n\n\tgf_isom_box_dump_done(\"FDSessionGroupBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err srpp_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *) a;\n\tgf_isom_box_dump_start(a, \"SRTPProcessBox\", trace);\n\n\tfprintf(trace, \"encryption_algorithm_rtp=\\\"%d\\\" encryption_algorithm_rtcp=\\\"%d\\\" integrity_algorithm_rtp=\\\"%d\\\" integrity_algorithm_rtcp=\\\"%d\\\">\\n\", ptr->encryption_algorithm_rtp, ptr->encryption_algorithm_rtcp, ptr->integrity_algorithm_rtp, ptr->integrity_algorithm_rtcp);\n\n\tif (ptr->info) gf_isom_box_dump(ptr->info, trace);\n\tif (ptr->scheme_type) gf_isom_box_dump(ptr->scheme_type, trace);\n\n\tgf_isom_box_dump_done(\"SRTPProcessBox\", a, trace);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\nGF_Err fdpa_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"FDpacketBox\", trace);\n\tfprintf(trace, \"sender_current_time_present=\\\"%d\\\" expected_residual_time_present=\\\"%d\\\" session_close_bit=\\\"%d\\\" object_close_bit=\\\"%d\\\" transport_object_identifier=\\\"%d\\\">\\n\", ptr->info.sender_current_time_present, ptr->info.expected_residual_time_present, ptr->info.session_close_bit, ptr->info.object_close_bit, ptr->info.transport_object_identifier);\n\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tfprintf(trace, \"<FDHeaderExt type=\\\"%d\\\"\", ptr->headers[i].header_extension_type);\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tdump_data_attribute(trace, \"content\", (char *) ptr->headers[i].content, 3);\n\t\t} else if (ptr->headers[i].data_length) {\n\t\t\tdump_data_attribute(trace, \"data\", ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t}\n\t\tfprintf(trace, \"/>\\n\");\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \"<FDHeaderExt type=\\\"\\\" content=\\\"\\\" data=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"FDpacketBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err extr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *) a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"ExtraDataBox\", trace);\n\tdump_data_attribute(trace, \"data\", ptr->data, ptr->data_length);\n\tfprintf(trace, \">\\n\");\n\tif (ptr->feci) {\n\t\tgf_isom_box_dump((GF_Box *)ptr->feci, trace);\n\t}\n\tgf_isom_box_dump_done(\"ExtraDataBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err fdsa_dump(GF_Box *a, FILE * trace)\n{\n\tGF_Err e;\n\tGF_HintSample *ptr = (GF_HintSample *) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"FDSampleBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\te = gf_isom_box_array_dump(ptr->packetTable, trace);\n\tif (e) return e;\n\tif (ptr->extra_data) {\n\t\te = gf_isom_box_dump((GF_Box *)ptr->extra_data, trace);\n\t\tif (e) return e;\n\t}\n\tgf_isom_box_dump_done(\"FDSampleBox\", a, trace);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\nGF_Err trik_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_TrickPlayBox *p = (GF_TrickPlayBox *) a;\n\n\tgf_isom_box_dump_start(a, \"TrickPlayBox\", trace);\n\n\tfprintf(trace, \">\\n\");\n\tfor (i=0; i<p->entry_count; i++) {\n\t\tfprintf(trace, \"<TrickPlayBoxEntry pic_type=\\\"%d\\\" dependency_level=\\\"%d\\\"/>\\n\", p->entries[i].pic_type, p->entries[i].dependency_level);\n\t}\n\tif (!p->size)\n\t\tfprintf(trace, \"<TrickPlayBoxEntry pic_type=\\\"\\\" dependency_level=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"TrickPlayBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err bloc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_BaseLocationBox *p = (GF_BaseLocationBox *) a;\n\n\tgf_isom_box_dump_start(a, \"BaseLocationBox\", trace);\n\n\tfprintf(trace, \"baseLocation=\\\"%s\\\" basePurlLocation=\\\"%s\\\">\\n\", p->baseLocation, p->basePurlLocation);\n\tgf_isom_box_dump_done(\"BaseLocationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ainf_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AssetInformationBox *p = (GF_AssetInformationBox *) a;\n\n\tgf_isom_box_dump_start(a, \"AssetInformationBox\", trace);\n\n\tfprintf(trace, \"profile_version=\\\"%d\\\" APID=\\\"%s\\\">\\n\", p->profile_version, p->APID);\n\tgf_isom_box_dump_done(\"AssetInformationBox\", a, trace);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_DUMP*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#ifndef _GF_ISOMEDIA_DEV_H_\n#define _GF_ISOMEDIA_DEV_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <gpac/isomedia.h>\n\n\nenum\n{\n\tGF_ISOM_BOX_TYPE_CO64\t= GF_4CC( 'c', 'o', '6', '4' ),\n\tGF_ISOM_BOX_TYPE_STCO\t= GF_4CC( 's', 't', 'c', 'o' ),\n\tGF_ISOM_BOX_TYPE_CTTS\t= GF_4CC( 'c', 't', 't', 's' ),\n\tGF_ISOM_BOX_TYPE_CPRT\t= GF_4CC( 'c', 'p', 'r', 't' ),\n\tGF_ISOM_BOX_TYPE_KIND\t= GF_4CC( 'k', 'i', 'n', 'd' ),\n\tGF_ISOM_BOX_TYPE_CHPL\t= GF_4CC( 'c', 'h', 'p', 'l' ),\n\tGF_ISOM_BOX_TYPE_URL\t= GF_4CC( 'u', 'r', 'l', ' ' ),\n\tGF_ISOM_BOX_TYPE_URN\t= GF_4CC( 'u', 'r', 'n', ' ' ),\n\tGF_ISOM_BOX_TYPE_DINF\t= GF_4CC( 'd', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_DREF\t= GF_4CC( 'd', 'r', 'e', 'f' ),\n\tGF_ISOM_BOX_TYPE_STDP\t= GF_4CC( 's', 't', 'd', 'p' ),\n\tGF_ISOM_BOX_TYPE_EDTS\t= GF_4CC( 'e', 'd', 't', 's' ),\n\tGF_ISOM_BOX_TYPE_ELST\t= GF_4CC( 'e', 'l', 's', 't' ),\n\tGF_ISOM_BOX_TYPE_UUID\t= GF_4CC( 'u', 'u', 'i', 'd' ),\n\tGF_ISOM_BOX_TYPE_FREE\t= GF_4CC( 'f', 'r', 'e', 'e' ),\n\tGF_ISOM_BOX_TYPE_HDLR\t= GF_4CC( 'h', 'd', 'l', 'r' ),\n\tGF_ISOM_BOX_TYPE_GMHD\t= GF_4CC( 'g', 'm', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_HMHD\t= GF_4CC( 'h', 'm', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_HINT\t= GF_4CC( 'h', 'i', 'n', 't' ),\n\tGF_ISOM_BOX_TYPE_MDIA\t= GF_4CC( 'm', 'd', 'i', 'a' ),\n\tGF_ISOM_BOX_TYPE_ELNG\t= GF_4CC( 'e', 'l', 'n', 'g' ),\n\tGF_ISOM_BOX_TYPE_MDAT\t= GF_4CC( 'm', 'd', 'a', 't' ),\n\tGF_ISOM_BOX_TYPE_IDAT\t= GF_4CC( 'i', 'd', 'a', 't' ),\n\tGF_ISOM_BOX_TYPE_MDHD\t= GF_4CC( 'm', 'd', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_MINF\t= GF_4CC( 'm', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_MOOV\t= GF_4CC( 'm', 'o', 'o', 'v' ),\n\tGF_ISOM_BOX_TYPE_MVHD\t= GF_4CC( 'm', 'v', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_STSD\t= GF_4CC( 's', 't', 's', 'd' ),\n\tGF_ISOM_BOX_TYPE_STSZ\t= GF_4CC( 's', 't', 's', 'z' ),\n\tGF_ISOM_BOX_TYPE_STZ2\t= GF_4CC( 's', 't', 'z', '2' ),\n\tGF_ISOM_BOX_TYPE_STBL\t= GF_4CC( 's', 't', 'b', 'l' ),\n\tGF_ISOM_BOX_TYPE_STSC\t= GF_4CC( 's', 't', 's', 'c' ),\n\tGF_ISOM_BOX_TYPE_STSH\t= GF_4CC( 's', 't', 's', 'h' ),\n\tGF_ISOM_BOX_TYPE_SKIP\t= GF_4CC( 's', 'k', 'i', 'p' ),\n\tGF_ISOM_BOX_TYPE_SMHD\t= GF_4CC( 's', 'm', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_STSS\t= GF_4CC( 's', 't', 's', 's' ),\n\tGF_ISOM_BOX_TYPE_STTS\t= GF_4CC( 's', 't', 't', 's' ),\n\tGF_ISOM_BOX_TYPE_TRAK\t= GF_4CC( 't', 'r', 'a', 'k' ),\n\tGF_ISOM_BOX_TYPE_TKHD\t= GF_4CC( 't', 'k', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_TREF\t= GF_4CC( 't', 'r', 'e', 'f' ),\n\tGF_ISOM_BOX_TYPE_STRK\t= GF_4CC( 's', 't', 'r', 'k' ),\n\tGF_ISOM_BOX_TYPE_STRI\t= GF_4CC( 's', 't', 'r', 'i' ),\n\tGF_ISOM_BOX_TYPE_STRD\t= GF_4CC( 's', 't', 'r', 'd' ),\n\tGF_ISOM_BOX_TYPE_STSG\t= GF_4CC( 's', 't', 's', 'g' ),\n\n\tGF_ISOM_BOX_TYPE_UDTA\t= GF_4CC( 'u', 'd', 't', 'a' ),\n\tGF_ISOM_BOX_TYPE_VMHD\t= GF_4CC( 'v', 'm', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_FTYP\t= GF_4CC( 'f', 't', 'y', 'p' ),\n\tGF_ISOM_BOX_TYPE_PADB\t= GF_4CC( 'p', 'a', 'd', 'b' ),\n\tGF_ISOM_BOX_TYPE_PDIN\t= GF_4CC( 'p', 'd', 'i', 'n' ),\n\tGF_ISOM_BOX_TYPE_SDTP\t= GF_4CC( 's', 'd', 't', 'p' ),\n\tGF_ISOM_BOX_TYPE_CSLG\t= GF_4CC( 'c', 's', 'l', 'g' ),\n\n\tGF_ISOM_BOX_TYPE_SBGP\t= GF_4CC( 's', 'b', 'g', 'p' ),\n\tGF_ISOM_BOX_TYPE_SGPD\t= GF_4CC( 's', 'g', 'p', 'd' ),\n\tGF_ISOM_BOX_TYPE_SAIZ\t= GF_4CC( 's', 'a', 'i', 'z' ),\n\tGF_ISOM_BOX_TYPE_SAIO\t= GF_4CC( 's', 'a', 'i', 'o' ),\n\tGF_ISOM_BOX_TYPE_MFRA\t= GF_4CC( 'm', 'f', 'r', 'a' ),\n\tGF_ISOM_BOX_TYPE_MFRO\t= GF_4CC( 'm', 'f', 'r', 'o' ),\n\tGF_ISOM_BOX_TYPE_TFRA\t= GF_4CC( 't', 'f', 'r', 'a' ),\n\n\tGF_ISOM_BOX_TYPE_PSSH\t= GF_4CC( 'p', 's', 's', 'h' ),\n\tGF_ISOM_BOX_TYPE_TENC\t= GF_4CC( 't', 'e', 'n', 'c' ),\n\n\t//track group\n\tGF_ISOM_BOX_TYPE_TRGR\t= GF_4CC( 't', 'r', 'g', 'r' ),\n\t//track group types\n\tGF_ISOM_BOX_TYPE_TRGT\t= GF_4CC( 't', 'r', 'g', 't' ),\n\tGF_ISOM_BOX_TYPE_MSRC\t= GF_4CC( 'm', 's', 'r', 'c' ),\n\tGF_ISOM_BOX_TYPE_CSTG\t= GF_4CC( 'c', 's', 't', 'g' ),\n\tGF_ISOM_BOX_TYPE_STER\t= GF_4CC( 's', 't', 'e', 'r' ),\n\n\t/*Adobe's protection boxes*/\n\tGF_ISOM_BOX_TYPE_ADKM\t= GF_4CC( 'a', 'd', 'k', 'm' ),\n\tGF_ISOM_BOX_TYPE_AHDR\t= GF_4CC( 'a', 'h', 'd', 'r' ),\n\tGF_ISOM_BOX_TYPE_ADAF\t= GF_4CC( 'a', 'd', 'a', 'f' ),\n\tGF_ISOM_BOX_TYPE_APRM\t= GF_4CC( 'a', 'p', 'r', 'm' ),\n\tGF_ISOM_BOX_TYPE_AEIB\t= GF_4CC( 'a', 'e', 'i', 'b' ),\n\tGF_ISOM_BOX_TYPE_AKEY\t= GF_4CC( 'a', 'k', 'e', 'y' ),\n\tGF_ISOM_BOX_TYPE_FLXS\t= GF_4CC( 'f', 'l', 'x', 's' ),\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t/*Movie Fragments*/\n\tGF_ISOM_BOX_TYPE_MVEX\t= GF_4CC( 'm', 'v', 'e', 'x' ),\n\tGF_ISOM_BOX_TYPE_MEHD\t= GF_4CC( 'm', 'e', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_TREX\t= GF_4CC( 't', 'r', 'e', 'x' ),\n\tGF_ISOM_BOX_TYPE_TREP\t= GF_4CC( 't', 'r', 'e', 'p' ),\n\tGF_ISOM_BOX_TYPE_MOOF\t= GF_4CC( 'm', 'o', 'o', 'f' ),\n\tGF_ISOM_BOX_TYPE_MFHD\t= GF_4CC( 'm', 'f', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_TRAF\t= GF_4CC( 't', 'r', 'a', 'f' ),\n\tGF_ISOM_BOX_TYPE_TFHD\t= GF_4CC( 't', 'f', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_TRUN\t= GF_4CC( 't', 'r', 'u', 'n' ),\n#endif\n\n\n\t/*MP4 extensions*/\n\tGF_ISOM_BOX_TYPE_DPND\t= GF_4CC( 'd', 'p', 'n', 'd' ),\n\tGF_ISOM_BOX_TYPE_IODS\t= GF_4CC( 'i', 'o', 'd', 's' ),\n\tGF_ISOM_BOX_TYPE_ESDS\t= GF_4CC( 'e', 's', 'd', 's' ),\n\tGF_ISOM_BOX_TYPE_MPOD\t= GF_4CC( 'm', 'p', 'o', 'd' ),\n\tGF_ISOM_BOX_TYPE_SYNC\t= GF_4CC( 's', 'y', 'n', 'c' ),\n\tGF_ISOM_BOX_TYPE_IPIR\t= GF_4CC( 'i', 'p', 'i', 'r' ),\n\n\tGF_ISOM_BOX_TYPE_NMHD\t= GF_4CC( 'n', 'm', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_STHD\t= GF_4CC( 's', 't', 'h', 'd' ),\n\t/*reseved\n\tGF_ISOM_BOX_TYPE_SDHD\t= GF_4CC( 's', 'd', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_ODHD\t= GF_4CC( 'o', 'd', 'h', 'd' ),\n\tGF_ISOM_BOX_TYPE_CRHD\t= GF_4CC( 'c', 'r', 'h', 'd' ),\n\t*/\n\tGF_ISOM_BOX_TYPE_MP4S\t= GF_4CC( 'm', 'p', '4', 's' ),\n\tGF_ISOM_BOX_TYPE_MP4A\t= GF_4CC( 'm', 'p', '4', 'a' ),\n\tGF_ISOM_BOX_TYPE_MP4V\t= GF_4CC( 'm', 'p', '4', 'v' ),\n\n\n\t/*AVC / H264 extension*/\n\tGF_ISOM_BOX_TYPE_AVCC\t= GF_4CC( 'a', 'v', 'c', 'C' ),\n\tGF_ISOM_BOX_TYPE_BTRT\t= GF_4CC( 'b', 't', 'r', 't' ),\n\tGF_ISOM_BOX_TYPE_M4DS\t= GF_4CC( 'm', '4', 'd', 's' ),\n\tGF_ISOM_BOX_TYPE_PASP\t= GF_4CC( 'p', 'a', 's', 'p' ),\n\tGF_ISOM_BOX_TYPE_CLAP\t= GF_4CC( 'c', 'l', 'a', 'p' ),\n\tGF_ISOM_BOX_TYPE_AVC1\t= GF_4CC( 'a', 'v', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_AVC2\t= GF_4CC( 'a', 'v', 'c', '2' ),\n\tGF_ISOM_BOX_TYPE_AVC3\t= GF_4CC( 'a', 'v', 'c', '3' ),\n\tGF_ISOM_BOX_TYPE_AVC4\t= GF_4CC( 'a', 'v', 'c', '4' ),\n\tGF_ISOM_BOX_TYPE_SVCC\t= GF_4CC( 's', 'v', 'c', 'C' ),\n\tGF_ISOM_BOX_TYPE_SVC1\t= GF_4CC( 's', 'v', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_SVC2\t= GF_4CC( 's', 'v', 'c', '2' ),\n\tGF_ISOM_BOX_TYPE_MVCC\t= GF_4CC( 'm', 'v', 'c', 'C' ),\n\tGF_ISOM_BOX_TYPE_MVC1\t= GF_4CC( 'm', 'v', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_MVC2\t= GF_4CC( 'm', 'v', 'c', '2' ),\n\tGF_ISOM_BOX_TYPE_MHC1\t= GF_4CC( 'm', 'h', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_MHV1\t= GF_4CC( 'm', 'h', 'v', '1' ),\n\n\tGF_ISOM_BOX_TYPE_HVCC\t= GF_4CC( 'h', 'v', 'c', 'C' ),\n\tGF_ISOM_BOX_TYPE_HVC1\t= GF_4CC( 'h', 'v', 'c', '1' ),\n\tGF_ISOM_BOX_TYPE_HEV1\t= GF_4CC( 'h', 'e', 'v', '1' ),\n\tGF_ISOM_BOX_TYPE_HVT1\t= GF_4CC( 'h', 'v', 't', '1' ),\n\n\tGF_ISOM_BOX_TYPE_HVC2\t= GF_4CC( 'h', 'v', 'c', '2' ),\n\tGF_ISOM_BOX_TYPE_HEV2\t= GF_4CC( 'h', 'e', 'v', '2' ),\n\tGF_ISOM_BOX_TYPE_LHV1\t= GF_4CC( 'l', 'h', 'v', '1' ),\n\tGF_ISOM_BOX_TYPE_LHE1\t= GF_4CC( 'l', 'h', 'e', '1' ),\n\tGF_ISOM_BOX_TYPE_LHT1\t= GF_4CC( 'l', 'h', 't', '1' ),\n\n\tGF_ISOM_BOX_TYPE_LHVC\t= GF_4CC( 'l', 'h', 'v', 'C' ),\n\n\t/*LASeR extension*/\n\tGF_ISOM_BOX_TYPE_LSRC\t= GF_4CC( 'l', 's', 'r', 'C' ),\n\tGF_ISOM_BOX_TYPE_LSR1\t= GF_4CC( 'l', 's', 'r', '1' ),\n\n\t/*3GPP extensions*/\n\tGF_ISOM_BOX_TYPE_DAMR\t= GF_4CC( 'd', 'a', 'm', 'r' ),\n\tGF_ISOM_BOX_TYPE_D263\t= GF_4CC( 'd', '2', '6', '3' ),\n\tGF_ISOM_BOX_TYPE_DEVC\t= GF_4CC( 'd', 'e', 'v', 'c' ),\n\tGF_ISOM_BOX_TYPE_DQCP\t= GF_4CC( 'd', 'q', 'c', 'p' ),\n\tGF_ISOM_BOX_TYPE_DSMV\t= GF_4CC( 'd', 's', 'm', 'v' ),\n\tGF_ISOM_BOX_TYPE_TSEL\t= GF_4CC( 't', 's', 'e', 'l' ),\n\n\t/* 3GPP Adaptive Streaming extensions */\n\tGF_ISOM_BOX_TYPE_STYP\t= GF_4CC( 's', 't', 'y', 'p' ),\n\tGF_ISOM_BOX_TYPE_TFDT\t= GF_4CC( 't', 'f', 'd', 't' ),\n\tGF_ISOM_BOX_TYPE_SIDX\t= GF_4CC( 's', 'i', 'd', 'x' ),\n\tGF_ISOM_BOX_TYPE_SSIX\t= GF_4CC( 's', 's', 'i', 'x' ),\n\tGF_ISOM_BOX_TYPE_LEVA   = GF_4CC( 'l', 'e', 'v', 'a' ),\n\tGF_ISOM_BOX_TYPE_PCRB\t= GF_4CC( 'p', 'c', 'r', 'b' ),\n\n\t/*3GPP text / MPEG-4 StreamingText*/\n\tGF_ISOM_BOX_TYPE_FTAB\t= GF_4CC( 'f', 't', 'a', 'b' ),\n\tGF_ISOM_BOX_TYPE_TX3G\t= GF_4CC( 't', 'x', '3', 'g' ),\n\tGF_ISOM_BOX_TYPE_STYL\t= GF_4CC( 's', 't', 'y', 'l' ),\n\tGF_ISOM_BOX_TYPE_HLIT\t= GF_4CC( 'h', 'l', 'i', 't' ),\n\tGF_ISOM_BOX_TYPE_HCLR\t= GF_4CC( 'h', 'c', 'l', 'r' ),\n\tGF_ISOM_BOX_TYPE_KROK\t= GF_4CC( 'k', 'r', 'o', 'k' ),\n\tGF_ISOM_BOX_TYPE_DLAY\t= GF_4CC( 'd', 'l', 'a', 'y' ),\n\tGF_ISOM_BOX_TYPE_HREF\t= GF_4CC( 'h', 'r', 'e', 'f' ),\n\tGF_ISOM_BOX_TYPE_TBOX\t= GF_4CC( 't', 'b', 'o', 'x' ),\n\tGF_ISOM_BOX_TYPE_BLNK\t= GF_4CC( 'b', 'l', 'n', 'k' ),\n\tGF_ISOM_BOX_TYPE_TWRP\t= GF_4CC( 't', 'w', 'r', 'p' ),\n\n\t/* ISO Base Media File Format Extensions for MPEG-21 */\n\tGF_ISOM_BOX_TYPE_META\t= GF_4CC( 'm', 'e', 't', 'a' ),\n\tGF_ISOM_BOX_TYPE_XML\t= GF_4CC( 'x', 'm', 'l', ' ' ),\n\tGF_ISOM_BOX_TYPE_BXML\t= GF_4CC( 'b', 'x', 'm', 'l' ),\n\tGF_ISOM_BOX_TYPE_ILOC\t= GF_4CC( 'i', 'l', 'o', 'c' ),\n\tGF_ISOM_BOX_TYPE_PITM\t= GF_4CC( 'p', 'i', 't', 'm' ),\n\tGF_ISOM_BOX_TYPE_IPRO\t= GF_4CC( 'i', 'p', 'r', 'o' ),\n\tGF_ISOM_BOX_TYPE_INFE\t= GF_4CC( 'i', 'n', 'f', 'e' ),\n\tGF_ISOM_BOX_TYPE_IINF\t= GF_4CC( 'i', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_IREF\t= GF_4CC( 'i', 'r', 'e', 'f' ),\n\tGF_ISOM_BOX_TYPE_ENCA\t= GF_4CC( 'e', 'n', 'c', 'a' ),\n\tGF_ISOM_BOX_TYPE_ENCV\t= GF_4CC( 'e', 'n', 'c', 'v' ),\n\tGF_ISOM_BOX_TYPE_RESV\t= GF_4CC( 'r', 'e', 's', 'v' ),\n\tGF_ISOM_BOX_TYPE_ENCT\t= GF_4CC( 'e', 'n', 'c', 't' ),\n\tGF_ISOM_BOX_TYPE_ENCS\t= GF_4CC( 'e', 'n', 'c', 's' ),\n\tGF_ISOM_BOX_TYPE_ENCF\t= GF_4CC( 'e', 'n', 'c', 'f' ),\n\tGF_ISOM_BOX_TYPE_ENCM\t= GF_4CC( 'e', 'n', 'c', 'm' ),\n\tGF_ISOM_BOX_TYPE_SINF\t= GF_4CC( 's', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_RINF\t= GF_4CC( 'r', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_FRMA\t= GF_4CC( 'f', 'r', 'm', 'a' ),\n\tGF_ISOM_BOX_TYPE_SCHM\t= GF_4CC( 's', 'c', 'h', 'm' ),\n\tGF_ISOM_BOX_TYPE_SCHI\t= GF_4CC( 's', 'c', 'h', 'i' ),\n\n\tGF_ISOM_BOX_TYPE_STVI\t= GF_4CC( 's', 't', 'v', 'i' ),\n\n\n\tGF_ISOM_BOX_TYPE_METX\t= GF_4CC( 'm', 'e', 't', 'x' ),\n\tGF_ISOM_BOX_TYPE_METT\t= GF_4CC( 'm', 'e', 't', 't' ),\n\n\t/* ISMA 1.0 Encryption and Authentication V 1.0 */\n\tGF_ISOM_BOX_TYPE_IKMS\t= GF_4CC( 'i', 'K', 'M', 'S' ),\n\tGF_ISOM_BOX_TYPE_ISFM\t= GF_4CC( 'i', 'S', 'F', 'M' ),\n\tGF_ISOM_BOX_TYPE_ISLT\t= GF_4CC( 'i', 'S', 'L', 'T' ),\n\n\t/* Hinting boxes */\n\tGF_ISOM_BOX_TYPE_RTP_STSD\t= GF_4CC( 'r', 't', 'p', ' ' ),\n\tGF_ISOM_BOX_TYPE_SRTP_STSD\t= GF_4CC( 's', 'r', 't', 'p' ),\n\tGF_ISOM_BOX_TYPE_FDP_STSD\t= GF_4CC( 'f', 'd', 'p', ' ' ),\n\tGF_ISOM_BOX_TYPE_RRTP_STSD\t= GF_4CC( 'r', 'r', 't', 'p' ),\n\tGF_ISOM_BOX_TYPE_RTCP_STSD\t= GF_4CC( 'r', 't', 'c', 'p' ),\n\tGF_ISOM_BOX_TYPE_HNTI\t= GF_4CC( 'h', 'n', 't', 'i' ),\n\tGF_ISOM_BOX_TYPE_RTP\t= GF_4CC( 'r', 't', 'p', ' ' ),\n\tGF_ISOM_BOX_TYPE_SDP\t= GF_4CC( 's', 'd', 'p', ' ' ),\n\tGF_ISOM_BOX_TYPE_HINF\t= GF_4CC( 'h', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_NAME\t= GF_4CC( 'n', 'a', 'm', 'e' ),\n\tGF_ISOM_BOX_TYPE_TRPY\t= GF_4CC( 't', 'r', 'p', 'y' ),\n\tGF_ISOM_BOX_TYPE_NUMP\t= GF_4CC( 'n', 'u', 'm', 'p' ),\n\tGF_ISOM_BOX_TYPE_TOTL\t= GF_4CC( 't', 'o', 't', 'l' ),\n\tGF_ISOM_BOX_TYPE_NPCK\t= GF_4CC( 'n', 'p', 'c', 'k' ),\n\tGF_ISOM_BOX_TYPE_TPYL\t= GF_4CC( 't', 'p', 'y', 'l' ),\n\tGF_ISOM_BOX_TYPE_TPAY\t= GF_4CC( 't', 'p', 'a', 'y' ),\n\tGF_ISOM_BOX_TYPE_MAXR\t= GF_4CC( 'm', 'a', 'x', 'r' ),\n\tGF_ISOM_BOX_TYPE_DMED\t= GF_4CC( 'd', 'm', 'e', 'd' ),\n\tGF_ISOM_BOX_TYPE_DIMM\t= GF_4CC( 'd', 'i', 'm', 'm' ),\n\tGF_ISOM_BOX_TYPE_DREP\t= GF_4CC( 'd', 'r', 'e', 'p' ),\n\tGF_ISOM_BOX_TYPE_TMIN\t= GF_4CC( 't', 'm', 'i', 'n' ),\n\tGF_ISOM_BOX_TYPE_TMAX\t= GF_4CC( 't', 'm', 'a', 'x' ),\n\tGF_ISOM_BOX_TYPE_PMAX\t= GF_4CC( 'p', 'm', 'a', 'x' ),\n\tGF_ISOM_BOX_TYPE_DMAX\t= GF_4CC( 'd', 'm', 'a', 'x' ),\n\tGF_ISOM_BOX_TYPE_PAYT\t= GF_4CC( 'p', 'a', 'y', 't' ),\n\tGF_ISOM_BOX_TYPE_RELY\t= GF_4CC( 'r', 'e', 'l', 'y' ),\n\tGF_ISOM_BOX_TYPE_TIMS\t= GF_4CC( 't', 'i', 'm', 's' ),\n\tGF_ISOM_BOX_TYPE_TSRO\t= GF_4CC( 't', 's', 'r', 'o' ),\n\tGF_ISOM_BOX_TYPE_SNRO\t= GF_4CC( 's', 'n', 'r', 'o' ),\n\tGF_ISOM_BOX_TYPE_RTPO\t= GF_4CC( 'r', 't', 'p', 'o' ),\n\tGF_ISOM_BOX_TYPE_TSSY\t= GF_4CC( 't', 's', 's', 'y' ),\n\tGF_ISOM_BOX_TYPE_RSSR\t= GF_4CC( 'r', 's', 's', 'r' ),\n\tGF_ISOM_BOX_TYPE_SRPP\t= GF_4CC( 's', 'r', 'p', 'p' ),\n\n\t//FEC boxes\n\tGF_ISOM_BOX_TYPE_FIIN\t= GF_4CC( 'f', 'i', 'i', 'n' ),\n\tGF_ISOM_BOX_TYPE_PAEN\t= GF_4CC( 'p', 'a', 'e', 'n' ),\n\tGF_ISOM_BOX_TYPE_FPAR\t= GF_4CC( 'f', 'p', 'a', 'r' ),\n\tGF_ISOM_BOX_TYPE_FECR\t= GF_4CC( 'f', 'e', 'c', 'r' ),\n\tGF_ISOM_BOX_TYPE_SEGR\t= GF_4CC( 's', 'e', 'g', 'r' ),\n\tGF_ISOM_BOX_TYPE_GITN\t= GF_4CC( 'g', 'i', 't', 'n' ),\n\tGF_ISOM_BOX_TYPE_FIRE\t= GF_4CC( 'f', 'i', 'r', 'e' ),\n\tGF_ISOM_BOX_TYPE_FDSA\t= GF_4CC( 'f', 'd', 's', 'a' ),\n\tGF_ISOM_BOX_TYPE_FDPA\t= GF_4CC( 'f', 'd', 'p', 'a' ),\n\tGF_ISOM_BOX_TYPE_EXTR\t= GF_4CC( 'e', 'x', 't', 'r' ),\n\n\t/*internal type for track and item references*/\n\tGF_ISOM_BOX_TYPE_REFT\t= GF_4CC( 'R', 'E', 'F', 'T' ),\n\tGF_ISOM_BOX_TYPE_REFI\t= GF_4CC( 'R', 'E', 'F', 'I'),\n\tGF_ISOM_BOX_TYPE_GRPT\t= GF_4CC( 'G', 'R', 'P', 'T'),\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\t/* Adobe extensions */\n\tGF_ISOM_BOX_TYPE_ABST\t= GF_4CC( 'a', 'b', 's', 't' ),\n\tGF_ISOM_BOX_TYPE_AFRA\t= GF_4CC( 'a', 'f', 'r', 'a' ),\n\tGF_ISOM_BOX_TYPE_ASRT\t= GF_4CC( 'a', 's', 'r', 't' ),\n\tGF_ISOM_BOX_TYPE_AFRT\t= GF_4CC( 'a', 'f', 'r', 't' ),\n#endif\n\n\t/* Apple extensions */\n\n\tGF_ISOM_BOX_TYPE_ILST\t= GF_4CC( 'i', 'l', 's', 't' ),\n\tGF_ISOM_BOX_TYPE_0xA9NAM\t= GF_4CC( 0xA9, 'n', 'a', 'm' ),\n\tGF_ISOM_BOX_TYPE_0xA9CMT\t= GF_4CC( 0xA9, 'c', 'm', 't' ),\n\tGF_ISOM_BOX_TYPE_0xA9DAY\t= GF_4CC( 0xA9, 'd', 'a', 'y' ),\n\tGF_ISOM_BOX_TYPE_0xA9ART\t= GF_4CC( 0xA9, 'A', 'R', 'T' ),\n\tGF_ISOM_BOX_TYPE_0xA9TRK\t= GF_4CC( 0xA9, 't', 'r', 'k' ),\n\tGF_ISOM_BOX_TYPE_0xA9ALB\t= GF_4CC( 0xA9, 'a', 'l', 'b' ),\n\tGF_ISOM_BOX_TYPE_0xA9COM\t= GF_4CC( 0xA9, 'c', 'o', 'm' ),\n\tGF_ISOM_BOX_TYPE_0xA9WRT\t= GF_4CC( 0xA9, 'w', 'r', 't' ),\n\tGF_ISOM_BOX_TYPE_0xA9TOO\t= GF_4CC( 0xA9, 't', 'o', 'o' ),\n\tGF_ISOM_BOX_TYPE_0xA9CPY\t= GF_4CC( 0xA9, 'c', 'p', 'y' ),\n\tGF_ISOM_BOX_TYPE_0xA9DES\t= GF_4CC( 0xA9, 'd', 'e', 's' ),\n\tGF_ISOM_BOX_TYPE_0xA9GEN\t= GF_4CC( 0xA9, 'g', 'e', 'n' ),\n\tGF_ISOM_BOX_TYPE_0xA9GRP\t= GF_4CC( 0xA9, 'g', 'r', 'p' ),\n\tGF_ISOM_BOX_TYPE_0xA9ENC\t= GF_4CC( 0xA9, 'e', 'n', 'c' ),\n\tGF_ISOM_BOX_TYPE_aART\t\t= GF_4CC( 'a', 'A', 'R', 'T' ),\n\tGF_ISOM_BOX_TYPE_PGAP = GF_4CC( 'p', 'g', 'a', 'p' ),\n\tGF_ISOM_BOX_TYPE_GNRE\t= GF_4CC( 'g', 'n', 'r', 'e' ),\n\tGF_ISOM_BOX_TYPE_DISK\t= GF_4CC( 'd', 'i', 's', 'k' ),\n\tGF_ISOM_BOX_TYPE_TRKN\t= GF_4CC( 't', 'r', 'k', 'n' ),\n\tGF_ISOM_BOX_TYPE_TMPO\t= GF_4CC( 't', 'm', 'p', 'o' ),\n\tGF_ISOM_BOX_TYPE_CPIL\t= GF_4CC( 'c', 'p', 'i', 'l' ),\n\tGF_ISOM_BOX_TYPE_COVR\t= GF_4CC( 'c', 'o', 'v', 'r' ),\n\tGF_ISOM_BOX_TYPE_iTunesSpecificInfo\t= GF_4CC( '-', '-', '-', '-' ),\n\tGF_ISOM_BOX_TYPE_DATA\t= GF_4CC( 'd', 'a', 't', 'a' ),\n\n\tGF_ISOM_HANDLER_TYPE_MDIR\t= GF_4CC( 'm', 'd', 'i', 'r' ),\n\tGF_ISOM_BOX_TYPE_CHAP\t= GF_4CC( 'c', 'h', 'a', 'p' ),\n\tGF_ISOM_BOX_TYPE_TEXT\t= GF_4CC( 't', 'e', 'x', 't' ),\n\n\t/*OMA (P)DCF boxes*/\n\tGF_ISOM_BOX_TYPE_OHDR\t= GF_4CC( 'o', 'h', 'd', 'r' ),\n\tGF_ISOM_BOX_TYPE_GRPI\t= GF_4CC( 'g', 'r', 'p', 'i' ),\n\tGF_ISOM_BOX_TYPE_MDRI\t= GF_4CC( 'm', 'd', 'r', 'i' ),\n\tGF_ISOM_BOX_TYPE_ODTT\t= GF_4CC( 'o', 'd', 't', 't' ),\n\tGF_ISOM_BOX_TYPE_ODRB\t= GF_4CC( 'o', 'd', 'r', 'b' ),\n\tGF_ISOM_BOX_TYPE_ODKM\t= GF_4CC( 'o', 'd', 'k', 'm' ),\n\tGF_ISOM_BOX_TYPE_ODAF\t= GF_4CC( 'o', 'd', 'a', 'f' ),\n\n\t/*3GPP DIMS */\n\tGF_ISOM_BOX_TYPE_DIMS\t= GF_4CC( 'd', 'i', 'm', 's' ),\n\tGF_ISOM_BOX_TYPE_DIMC\t= GF_4CC( 'd', 'i', 'm', 'C' ),\n\tGF_ISOM_BOX_TYPE_DIST\t= GF_4CC( 'd', 'i', 'S', 'T' ),\n\n\n\tGF_ISOM_BOX_TYPE_AC3\t= GF_4CC( 'a', 'c', '-', '3' ),\n\tGF_ISOM_BOX_TYPE_DAC3\t= GF_4CC( 'd', 'a', 'c', '3' ),\n\tGF_ISOM_BOX_TYPE_EC3\t= GF_4CC( 'e', 'c', '-', '3' ),\n\tGF_ISOM_BOX_TYPE_DEC3\t= GF_4CC( 'd', 'e', 'c', '3' ),\n\n\tGF_ISOM_BOX_TYPE_SUBS\t= GF_4CC( 's', 'u', 'b', 's' ),\n\n\tGF_ISOM_BOX_TYPE_RVCC\t= GF_4CC( 'r', 'v', 'c', 'c' ),\n\n\tGF_ISOM_BOX_TYPE_VTTC_CONFIG\t= GF_4CC( 'v', 't', 't', 'C' ),\n\tGF_ISOM_BOX_TYPE_VTCC_CUE\t= GF_4CC( 'v', 't', 't', 'c' ),\n\tGF_ISOM_BOX_TYPE_VTTE\t= GF_4CC( 'v', 't', 't', 'e' ),\n\tGF_ISOM_BOX_TYPE_VTTA\t= GF_4CC( 'v', 't', 't', 'a' ),\n\tGF_ISOM_BOX_TYPE_CTIM\t= GF_4CC( 'c', 't', 'i', 'm' ),\n\tGF_ISOM_BOX_TYPE_IDEN\t= GF_4CC( 'i', 'd', 'e', 'n' ),\n\tGF_ISOM_BOX_TYPE_STTG\t= GF_4CC( 's', 't', 't', 'g' ),\n\tGF_ISOM_BOX_TYPE_PAYL\t= GF_4CC( 'p', 'a', 'y', 'l' ),\n\tGF_ISOM_BOX_TYPE_WVTT\t= GF_4CC( 'w', 'v', 't', 't' ),\n\n\tGF_ISOM_BOX_TYPE_STPP\t= GF_4CC( 's', 't', 'p', 'p' ),\n\tGF_ISOM_BOX_TYPE_SBTT\t= GF_4CC( 's', 'b', 't', 't' ),\n\n\tGF_ISOM_BOX_TYPE_STXT\t= GF_4CC( 's', 't', 'x', 't' ),\n\tGF_ISOM_BOX_TYPE_TXTC\t= GF_4CC( 't', 'x', 't', 'C' ),\n\n\tGF_ISOM_BOX_TYPE_PRFT   = GF_4CC( 'p', 'r', 'f', 't' ),\n\n\t/* Image File Format Boxes */\n\tGF_ISOM_BOX_TYPE_ISPE   = GF_4CC( 'i', 's', 'p', 'e' ),\n\tGF_ISOM_BOX_TYPE_COLR   = GF_4CC( 'c', 'o', 'l', 'r' ),\n\tGF_ISOM_BOX_TYPE_PIXI   = GF_4CC( 'p', 'i', 'x', 'i' ),\n\tGF_ISOM_BOX_TYPE_RLOC   = GF_4CC( 'r', 'l', 'o', 'c' ),\n\tGF_ISOM_BOX_TYPE_IROT   = GF_4CC( 'i', 'r', 'o', 't' ),\n\tGF_ISOM_BOX_TYPE_IPCO   = GF_4CC( 'i', 'p', 'c', 'o' ),\n\tGF_ISOM_BOX_TYPE_IPRP   = GF_4CC( 'i', 'p', 'r', 'p' ),\n\tGF_ISOM_BOX_TYPE_IPMA   = GF_4CC( 'i', 'p', 'm', 'a' ),\n\tGF_ISOM_BOX_TYPE_GRPL   = GF_4CC( 'g', 'r', 'p', 'l'),\n\tGF_ISOM_BOX_TYPE_CCST\t= GF_4CC( 'c', 'c', 's', 't' ),\n\tGF_ISOM_BOX_TYPE_AUXC\t= GF_4CC( 'a', 'u', 'x', 'C' ),\n\tGF_ISOM_BOX_TYPE_OINF\t= GF_4CC( 'o', 'i', 'n', 'f' ),\n\tGF_ISOM_BOX_TYPE_TOLS\t= GF_4CC( 't', 'o', 'l', 's' ),\n\n\tGF_ISOM_BOX_TYPE_ALTR\t= GF_4CC( 'a', 'l', 't', 'r' ),\n\n\t/*ALL INTERNAL BOXES - NEVER WRITTEN TO FILE!!*/\n\n\t/*generic handlers*/\n\tGF_ISOM_BOX_TYPE_GNRM\t= GF_4CC( 'G', 'N', 'R', 'M' ),\n\tGF_ISOM_BOX_TYPE_GNRV\t= GF_4CC( 'G', 'N', 'R', 'V' ),\n\tGF_ISOM_BOX_TYPE_GNRA\t= GF_4CC( 'G', 'N', 'R', 'A' ),\n\t/*storage of AU fragments (for MPEG-4 visual resync marker (video packets), located in stbl.*/\n\tGF_ISOM_BOX_TYPE_STSF\t=  GF_4CC( 'S', 'T', 'S', 'F' ),\n\t/*base constructor of all hint formats (currently only RTP uses it)*/\n\tGF_ISOM_BOX_TYPE_GHNT\t= GF_4CC( 'g', 'h', 'n', 't' ),\n\t/*for compatibility with old files hinted for DSS - needs special parsing*/\n\tGF_ISOM_BOX_TYPE_VOID\t= GF_4CC( 'V', 'O', 'I', 'D' ),\n\n\t/*MS Smooth - these are actually UUID boxes*/\n\tGF_ISOM_BOX_UUID_PSSH\t= GF_4CC( 'P', 'S', 'S', 'H' ),\n\tGF_ISOM_BOX_UUID_MSSM   = GF_4CC( 'M', 'S', 'S', 'M' ), /*Stream Manifest box*/\n\tGF_ISOM_BOX_UUID_TENC\t= GF_4CC( 'T', 'E', 'N', 'C' ),\n\tGF_ISOM_BOX_UUID_TFRF\t= GF_4CC( 'T', 'F', 'R', 'F' ),\n\tGF_ISOM_BOX_UUID_TFXD\t= GF_4CC( 'T', 'F', 'X', 'D' ),\n\n\tGF_ISOM_BOX_TYPE_MP3\t= GF_4CC( '.', 'm', 'p', '3' ),\n\n\tGF_ISOM_BOX_TYPE_TRIK\t= GF_4CC( 't', 'r', 'i', 'k' ),\n\tGF_ISOM_BOX_TYPE_BLOC\t= GF_4CC( 'b', 'l', 'o', 'c' ),\n\tGF_ISOM_BOX_TYPE_AINF\t= GF_4CC( 'a', 'i', 'n', 'f' ),\n\n\tGF_ISOM_BOX_TYPE_IHDR\t= GF_4CC('i','h','d','r'),\n\tGF_ISOM_BOX_TYPE_JP  \t= GF_4CC('j','P',' ',' '),\n\tGF_ISOM_BOX_TYPE_JP2H\t= GF_4CC('j','p','2','h'),\n\tGF_ISOM_BOX_TYPE_JP2K\t= GF_4CC('j','p','2','k'),\n\tGF_ISOM_BOX_TYPE_JPEG\t= GF_4CC('j','p','e','g'),\n\tGF_ISOM_BOX_TYPE_PNG \t= GF_4CC('p','n','g',' '),\n\n\tGF_ISOM_BOX_TYPE_WAVE \t= GF_4CC('w','a','v','e'),\n\n\t/* apple alis box */\n\tGF_ISOM_BOX_TYPE_ALIS \t= GF_4CC('a','l','i','s'),\n\n\tGF_ISOM_BOX_TYPE_WIDE \t= GF_4CC('w','i','d','e'),\n\n\t/* from drm_sample.c */\n\tGF_ISOM_BOX_TYPE_264B \t= GF_4CC('2','6','4','b'),\n\tGF_ISOM_BOX_TYPE_265B \t= GF_4CC('2','6','5','b'),\n\n\tGF_ISOM_BOX_TYPE_AUXV \t= GF_4CC('A','U','X','V'),\n\n\tGF_ISOM_BOX_TYPE_UNKNOWN = GF_4CC( 'U', 'N', 'K', 'N' ),\n};\n\nenum\n{\n\tGF_ISOM_SAMPLE_ENTRY_UNKN = 0,\n\tGF_ISOM_SAMPLE_ENTRY_VIDEO = GF_4CC('v','i','d','e'),\n\tGF_ISOM_SAMPLE_ENTRY_AUDIO = GF_4CC('a','u','d','i')\n};\n\n\n#ifndef GPAC_DISABLE_ISOM\n\n\n#if defined(GPAC_DISABLE_ISOM_FRAGMENTS) && !defined(GPAC_DISABLE_ISOM_ADOBE)\n#define GPAC_DISABLE_ISOM_ADOBE\n#endif\n\n\t/*the default size is 64, cause we need to handle large boxes...\n\n\tthe other_boxes container is by default NOT created. When parsing a box and adding\n\ta sub-box with gf_isom_box_add_default, the list is created.\n\tThis list is destroyed befaore calling the final box destructor\n\tThis list is automatically taken into account during size() and write() functions\n\t*/\n#define GF_ISOM_BOX\t\t\t\\\n\tu32 type;\t\t\t\\\n\tu64 size;\t\t\t\\\n\tconst struct box_registry_entry *registry;\\\n\tGF_List *other_boxes;\n\n#define GF_ISOM_FULL_BOX\t\t\\\n\tGF_ISOM_BOX\t\t\t\\\n\tu8 version;\t\t\t\\\n\tu32 flags;\t\t\t\\\n\n#define GF_ISOM_UUID_BOX\t\\\n\tGF_ISOM_BOX\t\t\t\\\n\tu8 uuid[16];\t\t\\\n\tu32 internal_4cc;\t\t\\\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_Box;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_FullBox;\n\ntypedef struct\n{\n\tGF_ISOM_UUID_BOX\n} GF_UUIDBox;\n\n\n#define ISOM_DECL_BOX_ALLOC(__TYPE, __4cc)\t__TYPE *tmp; \\\n\tGF_SAFEALLOC(tmp, __TYPE);\t\\\n\tif (tmp==NULL) return NULL;\t\\\n\ttmp->type = __4cc;\n\n#define ISOM_DECREASE_SIZE(__ptr, bytes)\tif (__ptr->size < (bytes) ) {\\\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\\n\", gf_4cc_to_str(__ptr->type), __ptr->size, (bytes), __FILE__, __LINE__ )); \\\n\t\t\treturn GF_ISOM_INVALID_FILE; \\\n\t\t}\\\n\t\t__ptr->size -= bytes; \\\n\n/*constructor*/\nGF_Box *gf_isom_box_new(u32 boxType);\n//some boxes may have different syntax based on container. Use this constructor for this case\nGF_Box *gf_isom_box_new_ex(u32 boxType, u32 parentType);\n\nGF_Err gf_isom_box_write(GF_Box *ptr, GF_BitStream *bs);\nGF_Err gf_isom_box_read(GF_Box *ptr, GF_BitStream *bs);\nvoid gf_isom_box_del(GF_Box *ptr);\nGF_Err gf_isom_box_size(GF_Box *ptr);\n\nGF_Err gf_isom_clone_box(GF_Box *src, GF_Box **dst);\n\nGF_Err gf_isom_box_parse(GF_Box **outBox, GF_BitStream *bs);\nGF_Err gf_isom_box_array_read(GF_Box *s, GF_BitStream *bs, GF_Err (*add_box)(GF_Box *par, GF_Box *b));\nGF_Err gf_isom_box_array_read_ex(GF_Box *parent, GF_BitStream *bs, GF_Err (*add_box)(GF_Box *par, GF_Box *b), u32 parent_type);\nGF_Err gf_isom_box_add_default(GF_Box *a, GF_Box *subbox);\nGF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box);\n\n//writes box header - shall be called at the begining of each xxxx_Write function\n//this function is not factorized in order to let box serializer modify box type before writing\nGF_Err gf_isom_box_write_header(GF_Box *ptr, GF_BitStream *bs);\n\n//writes box header then version+flags\nGF_Err gf_isom_full_box_write(GF_Box *s, GF_BitStream *bs);\n\nvoid gf_isom_box_array_del(GF_List *other_boxes);\nGF_Err gf_isom_box_array_write(GF_Box *parent, GF_List *list, GF_BitStream *bs);\nGF_Err gf_isom_box_array_size(GF_Box *parent, GF_List *list);\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\t/*note: the data is NEVER loaded to the mdat in this lib*/\n\tu64 dataSize;\n\t/* store the file offset when parsing to access the raw data */\n\tu64 bsOffset;\n\tchar *data;\n} GF_MediaDataBox;\n\ntypedef struct\n{\n  u64 time;\n  u64 moof_offset;\n  u32 traf_number;\n  u32 trun_number;\n  u32 sample_number;\n} GF_RandomAccessEntry;\n\ntypedef struct\n{\n  GF_ISOM_FULL_BOX\n  u32 track_id;\n  u8 traf_bits;\n  u8 trun_bits;\n  u8 sample_bits;\n  u32 nb_entries;\n  GF_RandomAccessEntry *entries;\n} GF_TrackFragmentRandomAccessBox;\n\ntypedef struct\n{\n  GF_ISOM_FULL_BOX\n\tu32 container_size;\n} GF_MovieFragmentRandomAccessOffsetBox;\n\ntypedef struct\n{\n  GF_ISOM_BOX\n  GF_List* tfra_list;\n  GF_MovieFragmentRandomAccessOffsetBox *mfro;\n} GF_MovieFragmentRandomAccessBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *data;\n\tu32 dataSize;\n\tu32 original_4cc;\n} GF_UnknownBox;\n\ntypedef struct\n{\n\tGF_ISOM_UUID_BOX\n\tchar *data;\n\tu32 dataSize;\n} GF_UnknownUUIDBox;\n\nu32 gf_isom_solve_uuid_box(char *UUID);\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 creationTime;\n\tu64 modificationTime;\n\tu32 timeScale;\n\tu64 duration;\n\tu64 original_duration;\n\tu32 nextTrackID;\n\tu32 preferredRate;\n\tu16 preferredVolume;\n\tchar reserved[10];\n\tu32 matrixA;\n\tu32 matrixB;\n\tu32 matrixU;\n\tu32 matrixC;\n\tu32 matrixD;\n\tu32 matrixV;\n\tu32 matrixW;\n\tu32 matrixX;\n\tu32 matrixY;\n\tu32 previewTime;\n\tu32 previewDuration;\n\tu32 posterTime;\n\tu32 selectionTime;\n\tu32 selectionDuration;\n\tu32 currentTime;\n} GF_MovieHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_Descriptor *descriptor;\n} GF_ObjectDescriptorBox;\n\n/*used for entry list*/\ntypedef struct\n{\n\tu64 segmentDuration;\n\ts64 mediaTime;\n\tu32 mediaRate;\n} GF_EdtsEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *entryList;\n} GF_EditListBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_EditListBox *editList;\n} GF_EditBox;\n\n\n/*used to classify boxes in the UserData GF_Box*/\ntypedef struct\n{\n\tu32 boxType;\n\tu8 uuid[16];\n\tGF_List *other_boxes;\n} GF_UserDataMap;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_List *recordList;\n} GF_UserDataBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_MovieHeaderBox *mvhd;\n\tGF_ObjectDescriptorBox *iods;\n\tGF_UserDataBox *udta;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tstruct __tag_mvex_box *mvex;\n#endif\n\t/*meta box if any*/\n\tstruct __tag_meta_box *meta;\n\t/*track boxes*/\n\tGF_List *trackList;\n\n\tGF_ISOFile *mov;\n\n} GF_MovieBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 creationTime;\n\tu64 modificationTime;\n\tu32 trackID;\n\tu32 reserved1;\n\tu64 duration;\n\tu32 reserved2[2];\n\tu16 layer;\n\tu16 alternate_group;\n\tu16 volume;\n\tu16 reserved3;\n\tu32 matrix[9];\n\tu32 width, height;\n} GF_TrackHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_TrackReferenceBox;\n\n\ntypedef struct {\n\tGF_ISOM_BOX\n\tGF_List *groups;\n} GF_TrackGroupBox;\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tu32 group_type;\n\tu32 track_group_id;\n} GF_TrackGroupTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_UserDataBox *udta;\n\tGF_TrackHeaderBox *Header;\n\tstruct __tag_media_box *Media;\n\tGF_EditBox *editBox;\n\tGF_TrackReferenceBox *References;\n\t/*meta box if any*/\n\tstruct __tag_meta_box *meta;\n\tGF_TrackGroupBox *groups;\n\n\tGF_MovieBox *moov;\n\t/*private for media padding*/\n\tu32 padding_bytes;\n\t/*private for editing*/\n\tchar *name;\n\t/*private for editing*/\n\tBool is_unpacked;\n\t/*private for checking dependency*/\n\tu32 originalFile;\n\tu32 originalID;\n\n\t//not sure about piff (not supposed to be stored in moov), but senc is in track according to CENC\n\tstruct __sample_encryption_box *sample_encryption;\n\n\t/*private for SVC/MVC extractors resolution*/\n\ts32 extractor_mode;\n\tBool has_base_layer;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu64 dts_at_seg_start;\n\tu32 sample_count_at_seg_start;\n\tBool first_traf_merged;\n\tBool present_in_scalable_segment;\n#endif\n} GF_TrackBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 creationTime;\n\tu64 modificationTime;\n\tu32 timeScale;\n\tu64 duration, original_duration;\n\tchar packedLanguage[4];\n\tu16 reserved;\n} GF_MediaHeaderBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 reserved1;\n\tu32 handlerType;\n\tu8 reserved2[12];\n\tchar *nameUTF8;\n\tBool store_counted_string;\n} GF_HandlerBox;\n\ntypedef struct __tag_media_box\n{\n\tGF_ISOM_BOX\n\tGF_TrackBox *mediaTrack;\n\tGF_MediaHeaderBox *mediaHeader;\n\tGF_HandlerBox *handler;\n\tstruct __tag_media_info_box *information;\n\tu64 BytesMissing;\n} GF_MediaBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *extended_language;\n} GF_ExtendedLanguageBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 reserved;\n} GF_VideoMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu16 balance;\n\tu16 reserved;\n} GF_SoundMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\t/*this is used for us INTERNALLY*/\n\tu32 subType;\n\tu32 maxPDUSize;\n\tu32 avgPDUSize;\n\tu32 maxBitrate;\n\tu32 avgBitrate;\n\tu32 slidingAverageBitrate;\n} GF_HintMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_MPEGMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_SubtitleMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_ODMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_OCRMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_SceneMediaHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_DataReferenceBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_DataReferenceBox *dref;\n} GF_DataInformationBox;\n\n#define GF_ISOM_DATAENTRY_FIELDS\t\\\n\tchar *location;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOM_DATAENTRY_FIELDS\n} GF_DataEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOM_DATAENTRY_FIELDS\n} GF_DataEntryURLBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ISOM_DATAENTRY_FIELDS\n\tchar *nameURN;\n} GF_DataEntryURNBox;\n\ntypedef struct\n{\n\tu32 sampleCount;\n\tu32 sampleDelta;\n} GF_SttsEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_SttsEntry *entries;\n\tu32 nb_entries, alloc_size;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*cache for WRITE*/\n\tu32 w_currentSampleNum;\n\tu64 w_LastDTS;\n#endif\n\t/*cache for READ*/\n\tu32 r_FirstSampleInEntry;\n\tu32 r_currentEntryIndex;\n\tu64 r_CurrentDTS;\n} GF_TimeToSampleBox;\n\n\n/*TO CHECK - it could be reasonnable to only use 16bits for both count and offset*/\ntypedef struct\n{\n\tu32 sampleCount;\n\ts32 decodingOffset;\n} GF_DttsEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_DttsEntry *entries;\n\tu32 nb_entries, alloc_size;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tu32 w_LastSampleNumber;\n\t/*force one sample per entry*/\n\tBool unpack_mode;\n#endif\n\t/*Cache for read*/\n\tu32 r_currentEntryIndex;\n\tu32 r_FirstSampleInEntry;\n} GF_CompositionOffsetBox;\n\n\ntypedef struct\n{\n\tu32 SampleNumber;\n\tu32 fragmentCount;\n\tu16 *fragmentSizes;\n} GF_StsfEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *entryList;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*Cache for write*/\n\tGF_StsfEntry *w_currentEntry;\n\tu32 w_currentEntryIndex;\n#endif\n\t/*Cache for read*/\n\tu32 r_currentEntryIndex;\n\tGF_StsfEntry *r_currentEntry;\n} GF_SampleFragmentBox;\n\n\n#define GF_ISOM_SAMPLE_ENTRY_FIELDS\t\t\\\n\tGF_ISOM_UUID_BOX\t\t\t\t\t\\\n\tu16 dataReferenceIndex;\t\t\t\t\\\n\tchar reserved[ 6 ];\t\t\t\t\t\\\n\tu32 internal_type;\t\t\t\t\t\\\n\tGF_List *protections;\n\n/*base sample entry box (never used but for typecasting)*/\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n} GF_SampleEntryBox;\n\nvoid gf_isom_sample_entry_init(GF_SampleEntryBox *ptr);\nvoid gf_isom_sample_entry_predestroy(GF_SampleEntryBox *ptr);\nGF_Err gf_isom_base_sample_entry_read(GF_SampleEntryBox *ptr, GF_BitStream *bs);\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\t/*box type as specified in the file (not this box's type!!)*/\n\tu32 EntryType;\n\n\tchar *data;\n\tu32 data_size;\n} GF_GenericSampleEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_ESD *desc;\n} GF_ESDBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 bufferSizeDB;\n\tu32 maxBitrate;\n\tu32 avgBitrate;\n} GF_BitRateBox;\n\nGF_BitRateBox *gf_isom_sample_entry_get_bitrate(GF_SampleEntryBox *ent, Bool create);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_List *descriptors;\n} GF_MPEG4ExtensionDescriptorsBox;\n\n/*for most MPEG4 media */\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\tGF_ESDBox *esd;\n\t/*used for hinting when extracting the OD stream...*/\n\tGF_SLConfig *slc;\n} GF_MPEGSampleEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *hdr;\n\tu32 hdr_size;\n} GF_LASERConfigurationBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\n\tGF_LASERConfigurationBox *lsr_config;\n\tGF_MPEG4ExtensionDescriptorsBox *descr;\n\n\t/*used for hinting when extracting the OD stream...*/\n\tGF_SLConfig *slc;\n} GF_LASeRSampleEntryBox;\n\n/*rewrites avcC based on the given esd - this destroys the esd*/\nGF_Err LSR_UpdateESD(GF_LASeRSampleEntryBox *lsr, GF_ESD *esd);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 hSpacing;\n\tu32 vSpacing;\n} GF_PixelAspectRatioBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 cleanApertureWidthN;\n\tu32 cleanApertureWidthD;\n\tu32 cleanApertureHeightN;\n\tu32 cleanApertureHeightD;\n\tu32 horizOffN;\n\tu32 horizOffD;\n\tu32 vertOffN;\n\tu32 vertOffD;\n} GF_CleanAppertureBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tBool all_ref_pics_intra;\n\tBool intra_pred_used;\n\tu32 max_ref_per_pic;\n\tu32 reserved;\n} GF_CodingConstraintsBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu16 predefined_rvc_config;\n\tu32 rvc_meta_idx;\n} GF_RVCConfigurationBox;\n\n#define GF_ISOM_VISUAL_SAMPLE_ENTRY\t\t\\\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\t\t\t\\\n\tu16 version;\t\t\t\t\t\t\\\n\tu16 revision;\t\t\t\t\t\t\\\n\tu32 vendor;\t\t\t\t\t\t\t\\\n\tu32 temporal_quality;\t\t\t\t\\\n\tu32 spatial_quality;\t\t\t\t\\\n\tu16 Width, Height;\t\t\t\t\t\\\n\tu32 horiz_res, vert_res;\t\t\t\\\n\tu32 entry_data_size;\t\t\t\t\\\n\tu16 frames_per_sample;\t\t\t\t\\\n\tchar compressor_name[33];\t\t\t\\\n\tu16 bit_depth;\t\t\t\t\t\t\\\n\ts16 color_table_index;\t\t\t\t\\\n\tGF_PixelAspectRatioBox *pasp;\t\t\\\n\tGF_CleanAppertureBox *clap;\t\t\\\n\tstruct __tag_protect_box *rinf;\t\t\t\t\\\n\tGF_RVCConfigurationBox *rvcc;\t\t\\\n\ntypedef struct\n{\n\tGF_ISOM_VISUAL_SAMPLE_ENTRY\n} GF_VisualSampleEntryBox;\n\nvoid gf_isom_video_sample_entry_init(GF_VisualSampleEntryBox *ent);\nGF_Err gf_isom_video_sample_entry_read(GF_VisualSampleEntryBox *ptr, GF_BitStream *bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\nvoid gf_isom_video_sample_entry_write(GF_VisualSampleEntryBox *ent, GF_BitStream *bs);\nvoid gf_isom_video_sample_entry_size(GF_VisualSampleEntryBox *ent);\n#endif\n\nvoid gf_isom_sample_entry_predestroy(GF_SampleEntryBox *ptr);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_AVCConfig *config;\n} GF_AVCConfigurationBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_HEVCConfig *config;\n} GF_HEVCConfigurationBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_3GPConfig cfg;\n} GF_3GPPConfigBox;\n\ntypedef struct\n{\n\tGF_ISOM_VISUAL_SAMPLE_ENTRY\n\tGF_ESDBox *esd;\n\t/*used for Publishing*/\n\tGF_SLConfig *slc;\n\n\t/*avc extensions - we merged with regular 'mp4v' box to handle isma E&A signaling of AVC*/\n\tGF_AVCConfigurationBox *avc_config;\n\tGF_AVCConfigurationBox *svc_config;\n\tGF_AVCConfigurationBox *mvc_config;\n\t/*hevc extension*/\n\tGF_HEVCConfigurationBox *hevc_config;\n\tGF_HEVCConfigurationBox *lhvc_config;\n\n\t/*ext descriptors*/\n\tGF_MPEG4ExtensionDescriptorsBox *descr;\n\t/*internally emulated esd*/\n\tGF_ESD *emul_esd;\n\n\t//3GPP\n\tGF_3GPPConfigBox *cfg_3gpp;\n\n\t/*iPod's hack*/\n\tGF_UnknownUUIDBox *ipod_ext;\n\n} GF_MPEGVisualSampleEntryBox;\n\nstatic const u8 GF_ISOM_IPOD_EXT[][16] = { { 0x6B, 0x68, 0x40, 0xF2, 0x5F, 0x24, 0x4F, 0xC5, 0xBA, 0x39, 0xA5, 0x1B, 0xCF, 0x03, 0x23, 0xF3} };\n\nBool gf_isom_is_nalu_based_entry(GF_MediaBox *mdia, GF_SampleEntryBox *_entry);\nGF_Err gf_isom_nalu_sample_rewrite(GF_MediaBox *mdia, GF_ISOSample *sample, u32 sampleNumber, GF_MPEGVisualSampleEntryBox *entry);\n\n/*this is the default visual sdst (to handle unknown media)*/\ntypedef struct\n{\n\tGF_ISOM_VISUAL_SAMPLE_ENTRY\n\t/*box type as specified in the file (not this box's type!!)*/\n\tu32 EntryType;\n\t/*opaque description data (ESDS in MP4, SMI in SVQ3, ...)*/\n\tchar *data;\n\tu32 data_size;\n} GF_GenericVisualSampleEntryBox;\n\n\n#define GF_ISOM_AUDIO_SAMPLE_ENTRY\t\\\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\t\t\\\n\tu16 version;\t\t\t\t\t\\\n\tu16 revision;\t\t\t\t\t\\\n\tu32 vendor;\t\t\t\t\t\t\\\n\tu16 channel_count;\t\t\t\t\\\n\tu16 bitspersample;\t\t\t\t\\\n\tu16 compression_id;\t\t\t\t\\\n\tu16 packet_size;\t\t\t\t\\\n\tu16 samplerate_hi;\t\t\t\t\\\n\tu16 samplerate_lo;\t\t\t\t\\\n\tu8 extensions[36];\t\t\t\t\\\n\n\ntypedef struct\n{\n\tGF_ISOM_AUDIO_SAMPLE_ENTRY\n} GF_AudioSampleEntryBox;\n\nvoid gf_isom_audio_sample_entry_init(GF_AudioSampleEntryBox *ptr);\nGF_Err gf_isom_audio_sample_entry_read(GF_AudioSampleEntryBox *ptr, GF_BitStream *bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\nvoid gf_isom_audio_sample_entry_write(GF_AudioSampleEntryBox *ptr, GF_BitStream *bs);\nvoid gf_isom_audio_sample_entry_size(GF_AudioSampleEntryBox *ptr);\n#endif\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_AC3Config cfg;\n} GF_AC3ConfigBox;\n\ntypedef struct\n{\n\tGF_ISOM_AUDIO_SAMPLE_ENTRY\n\t//for MPEG4 audio\n\tGF_ESDBox *esd;\n\tGF_SLConfig *slc;\n\t//for 3GPP audio\n\tGF_3GPPConfigBox *cfg_3gpp;\n\n\t//for AC3/EC3 audio\n\tGF_AC3ConfigBox *cfg_ac3;\n} GF_MPEGAudioSampleEntryBox;\n\n/*this is the default visual sdst (to handle unknown media)*/\ntypedef struct\n{\n\tGF_ISOM_AUDIO_SAMPLE_ENTRY\n\t/*box type as specified in the file (not this box's type!!)*/\n\tu32 EntryType;\n\t/*opaque description data (ESDS in MP4, ...)*/\n\tchar *data;\n\tu32 data_size;\n} GF_GenericAudioSampleEntryBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 profile;\n\tu8 level;\n\tu8 pathComponents;\n\tBool fullRequestHost;\n\tBool streamType;\n\tu8 containsRedundant;\n\tchar *textEncoding;\n\tchar *contentEncoding;\n} GF_DIMSSceneConfigBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *content_script_types;\n} GF_DIMSScriptTypesBox;\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\tGF_DIMSSceneConfigBox *config;\n\tGF_DIMSScriptTypesBox *scripts;\n} GF_DIMSSampleEntryBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *config;\n} GF_TextConfigBox;\n\n/*base metadata sample entry box for METT, METX, SBTT, STXT and STPP*/\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\tchar *content_encoding;\t//optional\n\tchar *mime_type; //for anything except metx\n\tchar *xml_namespace;\t//for metx and sttp only\n\tchar *xml_schema_loc;\t// for metx and sttp only\n\tGF_TextConfigBox *config; //optional for anything except metx and sttp\n} GF_MetaDataSampleEntryBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n} GF_SampleDescriptionBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\t/*if this is the compact version, sample size is actually fieldSize*/\n\tu32 sampleSize;\n\tu32 sampleCount;\n\tu32 alloc_size;\n\tu32 *sizes;\n} GF_SampleSizeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 nb_entries;\n\tu32 alloc_size;\n\tu32 *offsets;\n} GF_ChunkOffsetBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 nb_entries;\n\tu32 alloc_size;\n\tu64 *offsets;\n} GF_ChunkLargeOffsetBox;\n\ntypedef struct\n{\n\tu32 firstChunk;\n\tu32 nextChunk;\n\tu32 samplesPerChunk;\n\tu32 sampleDescriptionIndex;\n\tu8 isEdited;\n} GF_StscEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_StscEntry *entries;\n\tu32 alloc_size, nb_entries;\n\n\t/*0-based cache for READ. In WRITE mode, we always have 1 sample per chunk so no need for a cache*/\n\tu32 currentIndex;\n\t/*first sample number in this chunk*/\n\tu32 firstSampleInCurrentChunk;\n\tu32 currentChunk;\n\tu32 ghostNumber;\n} GF_SampleToChunkBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 alloc_size, nb_entries;\n\tu32 *sampleNumbers;\n\t/*cache for READ mode (in write we realloc no matter what)*/\n\tu32 r_LastSyncSample;\n\t/*0-based index in the array*/\n\tu32 r_LastSampleIndex;\n} GF_SyncSampleBox;\n\ntypedef struct\n{\n\tu32 shadowedSampleNumber;\n\ts32 syncSampleNumber;\n} GF_StshEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *entries;\n\t/*Cache for read mode*/\n\tu32 r_LastEntryIndex;\n\tu32 r_LastFoundSample;\n} GF_ShadowSyncBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 nb_entries;\n\tu16 *priorities;\n} GF_DegradationPriorityBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 SampleCount;\n\tu8 *padbits;\n} GF_PaddingBitsBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 sampleCount;\n\t/*each dep type is packed on 1 byte*/\n\tu8 *sample_info;\n} GF_SampleDependencyTypeBox;\n\n\ntypedef struct\n{\n\tu32 subsample_size;\n\tu8 subsample_priority;\n\tu8 discardable;\n\tu32 reserved;\n} GF_SubSampleEntry;\n\ntypedef struct\n{\n\tu32 sample_delta;\n\tGF_List *SubSamples;\n} GF_SubSampleInfoEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *Samples;\n} GF_SubSampleInformationBox;\n\nBool gf_isom_get_subsample_types(GF_ISOFile *movie, u32 track, u32 subs_index, u32 *flags);\nu32  gf_isom_sample_get_subsample_entry(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 entry_index, GF_SubSampleInfoEntry **sub_sample);\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err gf_isom_add_subsample_info(GF_SubSampleInformationBox *sub_samples, u32 sampleNumber, u32 subSampleSize, u8 priority, u32 reserved, Bool discardable);\n#endif\n\n/* Use to relate the composition and decoding timeline when signed composition is used*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\ts32 compositionToDTSShift;\n\ts32 leastDecodeToDisplayDelta;\n\ts32 greatestDecodeToDisplayDelta;\n\ts32 compositionStartTime;\n\ts32 compositionEndTime;\n} GF_CompositionToDecodeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 aux_info_type;\n\tu32 aux_info_type_parameter;\n\n\tu8 default_sample_info_size;\n\tu32 sample_count;\n\tu8 *sample_info_size;\n} GF_SampleAuxiliaryInfoSizeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 aux_info_type;\n\tu32 aux_info_type_parameter;\n\n\tu8 default_sample_info_size;\n\tu32 entry_count;  //1 or stco / trun count\n\tu32 *offsets;\n\tu64 *offsets_large;\n\n\tu64 offset_first_offset_field;\n} GF_SampleAuxiliaryInfoOffsetBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_TimeToSampleBox *TimeToSample;\n\tGF_CompositionOffsetBox *CompositionOffset;\n\tGF_CompositionToDecodeBox *CompositionToDecode;\n\tGF_SyncSampleBox *SyncSample;\n\tGF_SampleDescriptionBox *SampleDescription;\n\tGF_SampleSizeBox *SampleSize;\n\tGF_SampleToChunkBox *SampleToChunk;\n\t/*untyped, to handle 32 bits and 64 bits chunkOffsets*/\n\tGF_Box *ChunkOffset;\n\tGF_ShadowSyncBox *ShadowSync;\n\tGF_DegradationPriorityBox *DegradationPriority;\n\tGF_PaddingBitsBox *PaddingBits;\n\tGF_SampleDependencyTypeBox *SampleDep;\n\tGF_SampleFragmentBox *Fragments;\n\n//\tGF_SubSampleInformationBox *SubSamples;\n\tGF_List *sub_samples;\n\n\tGF_List *sampleGroups;\n\tGF_List *sampleGroupsDescription;\n\tu32 nb_sgpd_in_stbl;\n\tu32 nb_other_boxes_in_stbl;\n\n\tGF_List *sai_sizes;\n\tGF_List *sai_offsets;\n\n\tu32 MaxSamplePerChunk;\n\tu16 groupID;\n\tu16 trackPriority;\n\tu32 currentEntryIndex;\n\n\tBool no_sync_found;\n} GF_SampleTableBox;\n\ntypedef struct __tag_media_info_box\n{\n\tGF_ISOM_BOX\n\tGF_DataInformationBox *dataInformation;\n\tGF_SampleTableBox *sampleTable;\n\tGF_Box *InfoHeader;\n\tstruct __tag_data_map *scalableDataHandler;\n\tstruct __tag_data_map *dataHandler;\n\tu32 dataEntryIndex;\n} GF_MediaInformationBox;\n\nGF_Err stbl_AppendDependencyType(GF_SampleTableBox *stbl, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *data;\n\tu32 dataSize;\n\tu32 original_4cc;\n} GF_FreeSpaceBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar packedLanguageCode[4];\n\tchar *notice;\n} GF_CopyrightBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *schemeURI;\n\tchar *value;\n} GF_KindBox;\n\n\ntypedef struct\n{\n\tchar *name;\n\tu64 start_time;\n} GF_ChapterEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *list;\n} GF_ChapterListBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 reference_type;\n\tu32 trackIDCount;\n\tu32 *trackIDs;\n} GF_TrackReferenceTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 grouping_type;\n\tu32 group_id;\n\tu32 entity_id_count;\n\tu32 *entity_ids;\n} GF_EntityToGroupTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 majorBrand;\n\tu32 minorVersion;\n\tu32 altCount;\n\tu32 *altBrand;\n} GF_FileTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 *rates;\n\tu32 *times;\n\tu32 count;\n} GF_ProgressiveDownloadBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 switch_group;\n\tu32 alternate_group;\n\tu32 sub_track_id;\n\tu64 attribute_count;\n\tu32 *attribute_list;\n} GF_SubTrackInformationBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 grouping_type;\n\tu16 nb_groups;\n\tu32 *group_description_index;\n} GF_SubTrackSampleGroupBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_SubTrackInformationBox *info;\n\tGF_Box *strd;\n} GF_SubTrackBox;\n\n/*\n\t3GPP streaming text boxes\n*/\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 entry_count;\n\tGF_FontRecord *fonts;\n} GF_FontTableBox;\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\t\t\t\t\\\n\tu32 displayFlags;\n\ts8 horizontal_justification;\n\ts8 vertical_justification;\n\t/*ARGB*/\n\tu32 back_color;\n\tGF_BoxRecord default_box;\n\tGF_StyleRecord\tdefault_style;\n\tGF_FontTableBox *font_table;\n} GF_Tx3gSampleEntryBox;\n\n/*Apple specific*/\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\t\t\t\t\\\n\tu32 displayFlags;\n\tu32 textJustification;\n\tchar background_color[6], foreground_color[6];\n\tGF_BoxRecord default_box;\n\tu16 fontNumber;\n\tu16 fontFace;\n\tchar reserved1[8];\n\tu8 reserved2;\n\tu16 reserved3;\n\tchar *textName; /*font name*/\n} GF_TextSampleEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 entry_count;\n\tGF_StyleRecord *styles;\n} GF_TextStyleBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu16 startcharoffset;\n\tu16 endcharoffset;\n} GF_TextHighlightBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\t/*ARGB*/\n\tu32 hil_color;\n} GF_TextHighlightColorBox;\n\ntypedef struct\n{\n\tu32 highlight_endtime;\n\tu16 start_charoffset;\n\tu16 end_charoffset;\n} KaraokeRecord;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 highlight_starttime;\n\tu16 nb_entries;\n\tKaraokeRecord *records;\n} GF_TextKaraokeBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 scroll_delay;\n} GF_TextScrollDelayBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu16 startcharoffset;\n\tu16 endcharoffset;\n\tchar *URL;\n\tchar *URL_hint;\n} GF_TextHyperTextBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_BoxRecord box;\n} GF_TextBoxBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu16 startcharoffset;\n\tu16 endcharoffset;\n} GF_TextBlinkBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 wrap_flag;\n} GF_TextWrapBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 switchGroup;\n\tu32 *attributeList;\n\tu32 attributeListCount;\n} GF_TrackSelectionBox;\n\n/*\n\tMPEG-21 extensions\n*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *xml;\n} GF_XMLBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 data_length;\n\tchar *data;\n} GF_BinaryXMLBox;\n\ntypedef struct\n{\n\tu64 extent_offset;\n\tu64 extent_length;\n\tu64 extent_index;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*for storage only*/\n\tu64 original_extent_offset;\n#endif\n} GF_ItemExtentEntry;\n\ntypedef struct\n{\n\tu16 item_ID;\n\tu16 construction_method;\n\tu16 data_reference_index;\n\tu64 base_offset;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*for storage only*/\n\tu64 original_base_offset;\n#endif\n\tGF_List *extent_entries;\n} GF_ItemLocationEntry;\n\nvoid iloc_entry_del(GF_ItemLocationEntry *location);\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 offset_size;\n\tu8 length_size;\n\tu8 base_offset_size;\n\tu8 index_size;\n\tGF_List *location_entries;\n} GF_ItemLocationBox;\n\ntypedef\tstruct\n{\n\tGF_ISOM_FULL_BOX\n\tu16 item_ID;\n} GF_PrimaryItemBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *protection_information;\n} GF_ItemProtectionBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu16 item_ID;\n\tu16 item_protection_index;\n\tu32 item_type;\n\t/*zero-terminated strings*/\n\tchar *item_name;\n\tchar *content_type;\n\tchar *content_encoding;\n\t// needed to actually read the resource file, but not written in the MP21 file.\n\tchar *full_path;\n\t// if not 0, full_path is actually the data to write.\n\tu32 data_len;\n} GF_ItemInfoEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *item_infos;\n} GF_ItemInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 reference_type;\n\tu32 from_item_id;\n\tu32 reference_count;\n\tu32 *to_item_IDs;\n} GF_ItemReferenceTypeBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *references;\n} GF_ItemReferenceBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 data_format;\n} GF_OriginalFormatBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 scheme_type;\n\tu32 scheme_version;\n\tchar *URI;\n} GF_SchemeTypeBox;\n\n/*ISMACryp specific*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\t/*zero-terminated string*/\n\tchar *URI;\n} GF_ISMAKMSBox;\n\n/*ISMACryp specific*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 salt;\n} GF_ISMACrypSaltBox;\n\n/*ISMACryp specific*/\ntypedef struct __isma_format_box\n{\n\tGF_ISOM_FULL_BOX\n\tu8 selective_encryption;\n\tu8 key_indicator_length;\n\tu8 IV_length;\n} GF_ISMASampleFormatBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_ISMAKMSBox *ikms;\n\tGF_ISMASampleFormatBox *isfm;\n\tGF_ISMACrypSaltBox *islt;\n\tstruct __oma_kms_box *odkm;\n\tstruct __cenc_tenc_box *tenc;\n\tstruct __piff_tenc_box *piff_tenc;\n\tstruct __adobe_drm_key_management_system_box *adkm;\n} GF_SchemeInformationBox;\n\ntypedef struct __tag_protect_box\n{\n\tGF_ISOM_BOX\n\tGF_OriginalFormatBox *original_format;\n\tGF_SchemeTypeBox *scheme_type;\n\tGF_SchemeInformationBox *info;\n} GF_ProtectionSchemeInfoBox;\ntypedef struct __tag_protect_box GF_RestrictedSchemeInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *descriptors;\n} GF_IPMPInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_IPMP_ToolList *ipmp_tools;\n\tGF_List *descriptors;\n} GF_IPMPControlBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n} GF_ItemPropertyContainerBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n\tGF_ItemPropertyContainerBox *property_container;\n\tstruct __item_association_box *property_association;\n} GF_ItemPropertiesBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n} GF_GroupListBox;\n\ntypedef struct __tag_meta_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_HandlerBox *handler;\n\tGF_PrimaryItemBox *primary_resource;\n\tGF_DataInformationBox *file_locations;\n\tGF_ItemLocationBox *item_locations;\n\tGF_ItemProtectionBox *protections;\n\tGF_ItemInfoBox *item_infos;\n\tGF_IPMPControlBox *IPMP_control;\n\tGF_ItemPropertiesBox *item_props;\n\tGF_ItemReferenceBox *item_refs;\n} GF_MetaBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 single_view_allowed;\n\tu32 stereo_scheme;\n\tu32 sit_len;\n\tchar *stereo_indication_type;\n} GF_StereoVideoBox;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\n/*V2 boxes - Movie Fragments*/\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 fragment_duration;\n} GF_MovieExtendsHeaderBox;\n\n\ntypedef struct __tag_mvex_box\n{\n\tGF_ISOM_BOX\n\tGF_List *TrackExList;\n\tGF_List *TrackExPropList;\n\tGF_MovieExtendsHeaderBox *mehd;\n\tGF_ISOFile *mov;\n} GF_MovieExtendsBox;\n\n/*the TrackExtends contains default values for the track fragments*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 trackID;\n\tu32 def_sample_desc_index;\n\tu32 def_sample_duration;\n\tu32 def_sample_size;\n\tu32 def_sample_flags;\n\tGF_TrackBox *track;\n\n\tGF_TrackFragmentRandomAccessBox *tfra;\n} GF_TrackExtendsBox;\n\n/*the TrackExtends contains default values for the track fragments*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 trackID;\n} GF_TrackExtensionPropertiesBox;\n\n/*indicates the seq num of this fragment*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 sequence_number;\n} GF_MovieFragmentHeaderBox;\n\n/*MovieFragment is a container IN THE FILE, contains 1 fragment*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_MovieFragmentHeaderBox *mfhd;\n\tGF_List *TrackList;\n\tGF_ISOFile *mov;\n\t/*offset in the file of moof or mdat (whichever comes first) for this fragment*/\n\tu64 fragment_offset;\n\tu32 mdat_size;\n\tchar *mdat;\n\n\t//temp storage of prft box\n\tu32 reference_track_ID;\n\tu64 ntp, timestamp;\n} GF_MovieFragmentBox;\n\n\n/*FLAGS for TRAF*/\nenum\n{\n\tGF_ISOM_TRAF_BASE_OFFSET\t=\t0x01,\n\tGF_ISOM_TRAF_SAMPLE_DESC\t=\t0x02,\n\tGF_ISOM_TRAF_SAMPLE_DUR\t=\t0x08,\n\tGF_ISOM_TRAF_SAMPLE_SIZE\t=\t0x10,\n\tGF_ISOM_TRAF_SAMPLE_FLAGS\t=\t0x20,\n\tGF_ISOM_TRAF_DUR_EMPTY\t=\t0x10000,\n\tGF_ISOM_MOOF_BASE_OFFSET\t=\t0x20000,\n};\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 trackID;\n\t/* all the following are optional fields */\n\tu64 base_data_offset;\n\tu32 sample_desc_index;\n\tu32 def_sample_duration;\n\tu32 def_sample_size;\n\tu32 def_sample_flags;\n\tu32 EmptyDuration;\n\tu8 IFrameSwitching;\n} GF_TrackFragmentHeaderBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu64 baseMediaDecodeTime;\n} GF_TFBaseMediaDecodeTimeBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_TrackFragmentHeaderBox *tfhd;\n\tGF_List *TrackRuns;\n\t/*keep a pointer to default flags*/\n\tGF_TrackExtendsBox *trex;\n\tGF_SampleDependencyTypeBox *sdtp;\n\n//\tGF_SubSampleInformationBox *subs;\n\tGF_List *sub_samples;\n\n\tGF_List *sampleGroups;\n\tGF_List *sampleGroupsDescription;\n\n\tGF_List *sai_sizes;\n\tGF_List *sai_offsets;\n\n\t//can be senc or PIFF psec\n\tstruct __sample_encryption_box *sample_encryption;\n\tstruct __traf_mss_timeext_box *tfxd; /*similar to PRFT but for Smooth Streaming*/\n\n\t/*when data caching is on*/\n\tu32 DataCache;\n\tGF_TFBaseMediaDecodeTimeBox *tfdt;\n\n\tu64 moof_start_in_bs;\n} GF_TrackFragmentBox;\n\n/*FLAGS for TRUN : specify what is written in the SampleTable of TRUN*/\nenum\n{\n\tGF_ISOM_TRUN_DATA_OFFSET\t= 0x01,\n\tGF_ISOM_TRUN_FIRST_FLAG\t\t= 0x04,\n\tGF_ISOM_TRUN_DURATION\t\t= 0x100,\n\tGF_ISOM_TRUN_SIZE\t\t\t= 0x200,\n\tGF_ISOM_TRUN_FLAGS\t\t\t= 0x400,\n\tGF_ISOM_TRUN_CTS_OFFSET\t\t= 0x800\n};\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 sample_count;\n\t/*the following are optional fields */\n\ts32 data_offset; /* unsigned for version 0 */\n\tu32 first_sample_flags;\n\t/*can be empty*/\n\tGF_List *entries;\n\n\t/*in write mode with data caching*/\n\tGF_BitStream *cache;\n} GF_TrackFragmentRunBox;\n\ntypedef struct\n{\n\tu32 Duration;\n\tu32 size;\n\tu32 flags;\n\ts32 CTS_Offset;\n\n\t/*internal*/\n\tu32 SAP_type;\n} GF_TrunEntry;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 majorBrand;\n\tu32 minorVersion;\n\tu32 altCount;\n\tu32 *altBrand;\n} GF_SegmentTypeBox;\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\n/*RTP Hint Track Sample Entry*/\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\tu16 HintTrackVersion;\n\tu16 LastCompatibleVersion;\n\tu32 MaxPacketSize;\n//\tGF_List *HintDataTable;\n\t/*this is where we store the current RTP sample in read/write mode*/\n\tstruct __tag_hint_sample *hint_sample;\n\t/*current hint sample in read mode, 1-based (0 is reset)*/\n\tu32 cur_sample;\n\tu32 pck_sn, ts_offset, ssrc;\n\tGF_TrackReferenceTypeBox *hint_ref;\n\n\t//for FEC\n\tu16 partition_entry_ID, FEC_overhead;\n} GF_HintSampleEntryBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 subType;\n\tchar *sdpText;\n} GF_RTPBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *sdpText;\n} GF_SDPBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\ts32 timeOffset;\n} GF_RTPOBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\t/*contains GF_SDPBox if in track, GF_RTPBox if in movie*/\n\tGF_Box *SDP;\n} GF_HintTrackInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 reserved;\n\tu8 prefered;\n\tu8 required;\n} GF_RelyHintBox;\n\n/***********************************************************\n\t\t\tdata entry tables for RTP\n***********************************************************/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 timeScale;\n} GF_TSHintEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 TimeOffset;\n} GF_TimeOffHintEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 SeqOffset;\n} GF_SeqOffHintEntryBox;\n\n\n\n/***********************************************************\n\t\t\thint track information boxes for RTP\n***********************************************************/\n\n/*Total number of bytes that will be sent, including 12-byte RTP headers, but not including any network headers*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbBytes;\n} GF_TRPYBox;\n\n/*32-bits version of trpy used in Darwin*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 nbBytes;\n} GF_TOTLBox;\n\n/*Total number of network packets that will be sent*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbPackets;\n} GF_NUMPBox;\n\n/*32-bits version of nump used in Darwin*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 nbPackets;\n} GF_NPCKBox;\n\n\n/*Total number of bytes that will be sent, not including 12-byte RTP headers*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbBytes;\n} GF_NTYLBox;\n\n/*32-bits version of tpyl used in Darwin*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 nbBytes;\n} GF_TPAYBox;\n\n/*Maximum data rate in bits per second.*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 granularity;\n\tu32 maxDataRate;\n} GF_MAXRBox;\n\n\n/*Total number of bytes from the media track to be sent*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbBytes;\n} GF_DMEDBox;\n\n/*Number of bytes of immediate data to be sent*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbBytes;\n} GF_DIMMBox;\n\n\n/*Number of bytes of repeated data to be sent*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu64 nbBytes;\n} GF_DREPBox;\n\n/*Smallest relative transmission time, in milliseconds. signed integer for smoothing*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\ts32 minTime;\n} GF_TMINBox;\n\n/*Largest relative transmission time, in milliseconds.*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\ts32 maxTime;\n} GF_TMAXBox;\n\n/*Largest packet, in bytes, including 12-byte RTP header*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 maxSize;\n} GF_PMAXBox;\n\n/*Longest packet duration, in milliseconds*/\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 maxDur;\n} GF_DMAXBox;\n\n/*32-bit payload type number, followed by rtpmap payload string */\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 payloadCode;\n\tchar *payloadString;\n} GF_PAYTBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *string;\n} GF_NameBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_HintInfoBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu8 timestamp_sync;\n} GF_TimeStampSynchronyBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu32 ssrc;\n} GF_ReceivedSsrcBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 encryption_algorithm_rtp;\n\tu32 encryption_algorithm_rtcp;\n\tu32 integrity_algorithm_rtp;\n\tu32 integrity_algorithm_rtcp;\n\n\tGF_SchemeTypeBox *scheme_type;\n\tGF_SchemeInformationBox *info;\n} GF_SRTPProcessBox;\n\n/*Apple extension*/\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 reserved;\n\tchar *data;\n\tu32 dataSize;\n} GF_DataBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_DataBox *data;\n} GF_ListItemBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_ItemListBox;\n\n/*DECE*/\ntypedef struct\n{\n\tu8 pic_type;\n\tu8 dependency_level;\n} GF_TrickPlayBoxEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 entry_count;\n\tGF_TrickPlayBoxEntry *entries;\n} GF_TrickPlayBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8  baseLocation[256];\n\tu8 basePurlLocation[256];\n} GF_BaseLocationBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 profile_version;\n\tchar *APID;\n} GF_AssetInformationBox;\n\n/*OMA (P)DCF extensions*/\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 EncryptionMethod;\n\tu8 PaddingScheme;\n\tu64 PlaintextLength;\n\tchar *ContentID;\n\tchar *RightsIssuerURL;\n\tchar *TextualHeaders;\n\tu32 TextualHeadersLen;\n} GF_OMADRMCommonHeaderBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu8 GKEncryptionMethod;\n\tchar *GroupID;\n\tu16 GKLength;\n\tchar *GroupKey;\n} GF_OMADRMGroupIDBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n} GF_OMADRMMutableInformationBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar TransactionID[16];\n} GF_OMADRMTransactionTrackingBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tchar *oma_ro;\n\tu32 oma_ro_size;\n} GF_OMADRMRightsObjectBox;\n\n/*identical*/\ntypedef struct __isma_format_box GF_OMADRMAUFormatBox;\n\ntypedef struct __oma_kms_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_OMADRMCommonHeaderBox *hdr;\n\tGF_OMADRMAUFormatBox *fmt;\n} GF_OMADRMKMSBox;\n\n\ntypedef struct\n{\n\tBool reference_type;\n\tu32 reference_size;\n\tu32 subsegment_duration;\n\tBool starts_with_SAP;\n\tu32 SAP_type;\n\tu32 SAP_delta_time;\n} GF_SIDXReference;\n\ntypedef struct __sidx_box\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 reference_ID;\n\tu32 timescale;\n\tu64 earliest_presentation_time;\n\tu64 first_offset;\n\tu32 nb_refs;\n\tGF_SIDXReference *refs;\n} GF_SegmentIndexBox;\n\ntypedef struct\n{\n\tu32 range_count;\n\tu8 *levels;\n\tu32 *range_sizes;\n} GF_Subsegment;\n\ntypedef struct __ssix_box\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 subsegment_count;\n\tGF_Subsegment *subsegments;\n} GF_SubsegmentIndexBox;\n\ntypedef struct\n{\n\tu32 track_id;\n\tBool padding_flag;\n\tu8 type;\n\tu32 grouping_type;\n\tu32 grouping_type_parameter;\n\tu32 sub_track_id;\n} GF_LevelAssignment;\n\ntypedef struct __leva_box\n{\n\tGF_ISOM_FULL_BOX\n\n\tu32 level_count;\n\tGF_LevelAssignment *levels;\n} GF_LevelAssignmentBox;\n\ntypedef struct __pcrInfo_box\n{\n\tGF_ISOM_BOX\n\tu32\tsubsegment_count;\n\tu64 *pcr_values;\n} GF_PcrInfoBox;\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\n/*Adobe specific boxes*/\ntypedef struct\n{\n\tu64 time;\n\tu64 offset;\n} GF_AfraEntry;\n\ntypedef struct\n{\n\tu64 time;\n\tu32 segment;\n\tu32 fragment;\n\tu64 afra_offset;\n\tu64 offset_from_afra;\n} GF_GlobalAfraEntry;\n\ntypedef struct __adobe_frag_random_access_box\n{\n\tGF_ISOM_FULL_BOX\n\tBool long_ids;\n\tBool long_offsets;\n\tBool global_entries;\n\tu8 reserved;\n\tu32 time_scale;\n\tu32 entry_count;\n\tGF_List *local_access_entries;\n\tu32 global_entry_count;\n\tGF_List *global_access_entries;\n} GF_AdobeFragRandomAccessBox;\n\ntypedef struct __adobe_bootstrap_info_box\n{\n\tGF_ISOM_FULL_BOX\n\tu32 bootstrapinfo_version;\n\tu8 profile;\n\tBool live;\n\tBool update;\n\tu8 reserved;\n\tu32 time_scale;\n\tu64 current_media_time;\n\tu64 smpte_time_code_offset;\n\tchar *movie_identifier;\n\tu8 server_entry_count;\n\tGF_List *server_entry_table;\n\tu8 quality_entry_count;\n\tGF_List *quality_entry_table;\n\tchar *drm_data;\n\tchar *meta_data;\n\tu8 segment_run_table_count;\n\tGF_List *segment_run_table_entries;\n\tu8 fragment_run_table_count;\n\tGF_List *fragment_run_table_entries;\n} GF_AdobeBootstrapInfoBox;\n\ntypedef struct\n{\n\tu32 first_segment;\n\tu32 fragment_per_segment;\n} GF_AdobeSegmentRunEntry;\n\ntypedef struct __adobe_segment_run_table_box\n{\n\tGF_ISOM_FULL_BOX\n\tu8 quality_entry_count;\n\tGF_List *quality_segment_url_modifiers;\n\tu32 segment_run_entry_count;\n\tGF_List *segment_run_entry_table;\n} GF_AdobeSegmentRunTableBox;\n\ntypedef struct\n{\n\tu32 first_fragment;\n\tu64 first_fragment_timestamp;\n\tu32 fragment_duration;\n\tu8 discontinuity_indicator;\n} GF_AdobeFragmentRunEntry;\n\ntypedef struct __adobe_fragment_run_table_box\n{\n\tGF_ISOM_FULL_BOX\n\tu32 timescale;\n\tu8 quality_entry_count;\n\tGF_List *quality_segment_url_modifiers;\n\tu32 fragment_run_entry_count;\n\tGF_List *fragment_run_entry_table;\n} GF_AdobeFragmentRunTableBox;\n\n#endif /*GPAC_DISABLE_ISOM_ADOBE*/\n\n\n/***********************************************************\n\t\t\tSample Groups\n***********************************************************/\ntypedef struct\n{\n\tu32 sample_count;\n\tu32 group_description_index;\n} GF_SampleGroupEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 grouping_type;\n\tu32 grouping_type_parameter;\n\n\tu32 entry_count;\n\tGF_SampleGroupEntry *sample_entries;\n\n} GF_SampleGroupBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 grouping_type;\n\tu32 default_length;\n\n\tu32 default_description_index;\n\tGF_List *group_descriptions;\n} GF_SampleGroupDescriptionBox;\n\n/*default entry */\ntypedef struct\n{\n\tu32 length;\n\tu8 *data;\n} GF_DefaultSampleGroupDescriptionEntry;\n\n/*VisualRandomAccessEntry - 'rap ' type*/\ntypedef struct\n{\n\tu8 num_leading_samples_known;\n\tu8 num_leading_samples;\n} GF_VisualRandomAccessEntry;\n\n/*RollRecoveryEntry - 'roll' and prol type*/\ntypedef struct\n{\n\ts16 roll_distance;\n} GF_RollRecoveryEntry;\n\n/*TemporalLevelEntry - 'tele' type*/\ntypedef struct\n{\n\tBool level_independently_decodable;\n} GF_TemporalLevelEntry;\n\n/*SAPEntry - 'sap ' type*/\ntypedef struct\n{\n\tBool dependent_flag;\n\tu8 SAP_type;\n} GF_SAPEntry;\n\n/*SAPEntry - 'sync' type*/\ntypedef struct\n{\n\tu8 NALU_type;\n} GF_SYNCEntry;\n\n/*Operating Points Information - 'oinf' type*/\ntypedef struct\n{\n\tu16 scalability_mask;\n\tGF_List* profile_tier_levels;\n\tGF_List* operating_points;\n\tGF_List* dependency_layers;\n} GF_OperatingPointsInformation;\n\nGF_OperatingPointsInformation *gf_isom_oinf_new_entry();\nvoid gf_isom_oinf_del_entry(void *entry);\nGF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs);\nGF_Err gf_isom_oinf_write_entry(void *entry, GF_BitStream *bs);\nu32 gf_isom_oinf_size_entry(void *entry);\nBool gf_isom_get_oinf_info(GF_ISOFile *file, u32 trackNumber, GF_OperatingPointsInformation **ptr);\n\n\n/*Operating Points Information - 'oinf' type*/\ntypedef struct\n{\n\tu8 layer_id;\n\tu8 min_TemporalId;\n\tu8 max_TemporalId;\n\tu8 sub_layer_presence_flags;\n} LHVCLayerInfoItem;\n\ntypedef struct\n{\n\tGF_List* num_layers_in_track;\n} GF_LHVCLayerInformation;\n\nGF_LHVCLayerInformation *gf_isom_linf_new_entry();\nvoid gf_isom_linf_del_entry(void *entry);\nGF_Err gf_isom_linf_read_entry(void *entry, GF_BitStream *bs);\nGF_Err gf_isom_linf_write_entry(void *entry, GF_BitStream *bs);\nu32 gf_isom_linf_size_entry(void *entry);\nBool gf_isom_get_linf_info(GF_ISOFile *file, u32 trackNumber, GF_LHVCLayerInformation **ptr);\n\n\n#define MAX_LHEVC_LAYERS\t64\n\ntypedef struct\n{\n\tu8 general_profile_space, general_tier_flag, general_profile_idc, general_level_idc;\n\tu32 general_profile_compatibility_flags;\n\tu64 general_constraint_indicator_flags;\n} LHEVC_ProfileTierLevel;\n\ntypedef struct\n{\n\tu8 ptl_idx;\n\tu8 layer_id;\n\tBool is_outputlayer, is_alternate_outputlayer;\n} LHEVC_LayerInfo;\n\ntypedef struct\n{\n\tu16 output_layer_set_idx;\n\tu8 max_temporal_id;\n\tu8 layer_count;\n\tLHEVC_LayerInfo layers_info[MAX_LHEVC_LAYERS];\n\tu16 minPicWidth, minPicHeight, maxPicWidth, maxPicHeight;\n\tu8 maxChromaFormat, maxBitDepth;\n\tBool frame_rate_info_flag, bit_rate_info_flag;\n\tu16 avgFrameRate;\n\tu8 constantFrameRate;\n\tu32 maxBitRate, avgBitRate;\n} LHEVC_OperatingPoint;\n\n\ntypedef struct\n{\n\tu8 dependent_layerID;\n\tu8 num_layers_dependent_on;\n\tu8 dependent_on_layerID[MAX_LHEVC_LAYERS];\n\tu8 dimension_identifier[16];\n} LHEVC_DependentLayer;\n\n\n/*\n\t\tCENC stuff\n*/\n\n/*CENCSampleEncryptionGroupEntry - 'seig' type*/\ntypedef struct\n{\n\tu8 crypt_byte_block, skip_byte_block;\n\tu8 IsProtected;\n\tu8 Per_Sample_IV_size;\n\tbin128 KID;\n\tu8 constant_IV_size;\n\tbin128 constant_IV;\n} GF_CENCSampleEncryptionGroupEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\n\tbin128 SystemID;\n\tu32 KID_count;\n\tbin128 *KIDs;\n\tu32 private_data_size;\n\tu8 *private_data;\n} GF_ProtectionSystemHeaderBox;\n\ntypedef struct __cenc_tenc_box\n{\n\tGF_ISOM_FULL_BOX\n\n\tu8 crypt_byte_block, skip_byte_block;\n\tu8 isProtected;\n\tu8 Per_Sample_IV_Size;\n\tbin128 KID;\n\tu8 constant_IV_size;\n\tbin128 constant_IV;\n} GF_TrackEncryptionBox;\n\ntypedef struct __piff_tenc_box\n{\n\tGF_ISOM_UUID_BOX\n\tu8 version;\n\tu32 flags;\n\n\tu32 AlgorithmID;\n\tu8 IV_size;\n\tbin128 KID;\n} GF_PIFFTrackEncryptionBox;\n\ntypedef struct\n{\n\tGF_ISOM_UUID_BOX\n\tu8 version;\n\tu32 flags;\n\n\tbin128 SystemID;\n\tu32 private_data_size;\n\tu8 *private_data;\n} GF_PIFFProtectionSystemHeaderBox;\n\n\ntypedef struct __sample_encryption_box\n{\n\tGF_ISOM_UUID_BOX\n\tu8 version;\n\tu32 flags;\n\n\tBool is_piff;\n\n\tGF_List *samp_aux_info; /*GF_CENCSampleAuxInfo*/\n\tu64 bs_offset;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t/*pointer to container traf*/\n\tGF_TrackFragmentBox *traf;\n#endif\n\t/*pointer to associated saio*/\n\tGF_SampleAuxiliaryInfoSizeBox *cenc_saiz;\n\tGF_SampleAuxiliaryInfoOffsetBox *cenc_saio;\n\n\n\tu32 AlgorithmID;\n\tu8 IV_size;\n\tbin128 KID;\n\n} GF_SampleEncryptionBox;\n\ntypedef struct __traf_mss_timeext_box\n{\n\tGF_ISOM_UUID_BOX\n\tu8 version;\n\tu32 flags;\n\n\tu64 absolute_time_in_track_timescale;\n\tu64 fragment_duration_in_track_timescale;\n} GF_MSSTimeExtBox;\n\nGF_SampleEncryptionBox *gf_isom_create_piff_psec_box(u8 version, u32 flags, u32 AlgorithmID, u8 IV_size, bin128 KID);\nGF_SampleEncryptionBox * gf_isom_create_samp_enc_box(u8 version, u32 flags);\n\nvoid gf_isom_cenc_get_default_info_ex(GF_TrackBox *trak, u32 sampleDescriptionIndex, u32 *default_IsEncrypted, u8 *default_IV_size, bin128 *default_KID, u8 *constant_IV_size, bin128 *constant_IV, u8 *crypt_byte_block, u8 *skip_byte_block);\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err gf_isom_get_sample_cenc_info_ex(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc, u32 sample_number, u32 *IsEncrypted, u8 *IV_size, bin128 *KID, u8 *crypt_byte_block, u8 *skip_byte_block, u8 *constant_IV_size, bin128 *constant_IV);\nGF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *ptr);\n#else\nGF_Err gf_isom_get_sample_cenc_info_ex(GF_TrackBox *trak, void *traf, uGF_SampleEncryptionBox *senc, 32 sample_number, u32 *IsEncrypted, u8 *IV_size, bin128 *KID,\n\t\t\t\t\t\t\t\t\t\tu8 *crypt_byte_block, u8 *skip_byte_block, u8 *constant_IV_size, bin128 *constant_IV);\nGF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *ptr);\n#endif\n\n/*\n\tBoxes for Adobe's protection scheme\n*/\ntypedef struct __adobe_enc_info_box\n{\n\tGF_ISOM_FULL_BOX\n\tchar *enc_algo; /*spec: The encryption algorithm shall be 'AES-CBC'*/\n\tu8 key_length;\n} GF_AdobeEncryptionInfoBox;\n\ntypedef struct __adobe_flash_access_params_box\n{\n\tGF_ISOM_BOX\n\tchar *metadata; /*base-64 encoded metadata used by the DRM client to retrieve decrypted key*/\n} GF_AdobeFlashAccessParamsBox;\n\ntypedef struct __adobe_key_info_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_AdobeFlashAccessParamsBox * params; /*spec: APSParamsBox will no longer be produced by conformaing applications*/\n} GF_AdobeKeyInfoBox;\n\ntypedef struct __adobe_std_enc_params_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_AdobeEncryptionInfoBox *enc_info;\n\tGF_AdobeKeyInfoBox *key_info;\n} GF_AdobeStdEncryptionParamsBox;\n\ntypedef struct __adobe_drm_header_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_AdobeStdEncryptionParamsBox *std_enc_params;\n\t//AdobeSignatureBox *signature; /*AdobeSignatureBox is not described*/\n} GF_AdobeDRMHeaderBox;\n\n\ntypedef struct __adobe_drm_au_format_box\n{\n\tGF_ISOM_FULL_BOX\n\tu8 selective_enc;\n\tu8 IV_length;\n} GF_AdobeDRMAUFormatBox;\n\ntypedef struct __adobe_drm_key_management_system_box\n{\n\tGF_ISOM_FULL_BOX\n\tGF_AdobeDRMHeaderBox *header;\n\tGF_AdobeDRMAUFormatBox *au_format;\n} GF_AdobeDRMKeyManagementSystemBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 refTrackID;\n\tu64 ntp, timestamp;\n} GF_ProducerReferenceTimeBox;\n\n/* Image File Format Structures */\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tu32 image_width;\n\tu32 image_height;\n} GF_ImageSpatialExtentsPropertyBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n\tu32 colour_type;\n\tu16 colour_primaries;\n\tu16 transfer_characteristics;\n\tu16 matrix_coefficients;\n\tBool full_range_flag;\n\tu8 *opaque;\n\tu32 opaque_size;\n} GF_ColourInformationBox;\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tu8 num_channels;\n\tu8 *bits_per_channel;\n} GF_PixelInformationPropertyBox;\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tu32 horizontal_offset;\n\tu32 vertical_offset;\n} GF_RelativeLocationPropertyBox;\n\ntypedef struct {\n\tGF_ISOM_BOX\n\tu8 angle;\n} GF_ImageRotationBox;\n\ntypedef struct {\n\tu32 item_id;\n\tGF_List *essential;\n\tGF_List *property_index;\n} GF_ItemPropertyAssociationEntry;\n\ntypedef struct __item_association_box {\n\tGF_ISOM_FULL_BOX\n\tGF_List *entries;\n} GF_ItemPropertyAssociationBox;\n\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\tchar *aux_urn;\n\tu32 data_size;\n\tchar *data;\n} GF_AuxiliaryTypePropertyBox;\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\n\tGF_OperatingPointsInformation *oinf;\n} GF_OINFPropertyBox;\n\n\ntypedef struct {\n\tGF_ISOM_FULL_BOX\n\n\tu16 target_ols_index;\n} GF_TargetOLSPropertyBox;\n\n/*flute hint track boxes*/\ntypedef struct\n{\n\tu16 block_count;\n\tu32 block_size;\n} FilePartitionEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 itemID;\n\tu16 packet_payload_size;\n\tu8 FEC_encoding_ID;\n\tu16 FEC_instance_ID;\n\tu16 max_source_block_length;\n\tu16 encoding_symbol_length;\n\tu16 max_number_of_encoding_symbols;\n\tchar *scheme_specific_info;\n\tu32 nb_entries;\n\tFilePartitionEntry *entries;\n} FilePartitionBox;\n\ntypedef struct\n{\n\tu32 item_id;\n\tu32 symbol_count;\n} FECReservoirEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 nb_entries;\n\tFECReservoirEntry *entries;\n} FECReservoirBox;\n\ntypedef struct\n{\n\tu32 nb_groups;\n\tu32 *group_ids;\n\tu32 nb_channels;\n\tu32 *channels;\n} SessionGroupEntry;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tu16 num_session_groups;\n\tSessionGroupEntry *session_groups;\n} FDSessionGroupBox;\n\ntypedef struct\n{\n\tu32 group_id;\n\tchar *name;\n} GroupIdNameEntry;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu16 nb_entries;\n\tGroupIdNameEntry *entries;\n} GroupIdToNameBox;\n\n\ntypedef struct\n{\n\tu32 item_id;\n\tu32 symbol_count;\n} FileReservoirEntry;\n\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu32 nb_entries;\n\tFileReservoirEntry *entries;\n} FileReservoirBox;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tFilePartitionBox *blocks_and_symbols;\n\tFECReservoirBox *FEC_symbol_locations;\n\tFileReservoirBox *File_symbol_locations;\n} FDPartitionEntryBox;\n\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tGF_List *partition_entries;\n\tFDSessionGroupBox *session_info;\n\tGroupIdToNameBox *group_id_to_name;\n} FDItemInformationBox;\n\n\n/*\n\t\tData Map (media storage) stuff\n*/\n\n/*regular file IO*/\n#define GF_ISOM_DATA_FILE         0x01\n/*File Mapping object, read-only mode on complete files (no download)*/\n#define GF_ISOM_DATA_FILE_MAPPING 0x02\n/*External file object. Needs implementation*/\n#define GF_ISOM_DATA_FILE_EXTERN  0x03\n/*regular memory IO*/\n#define GF_ISOM_DATA_MEM          0x04\n\n/*Data Map modes*/\nenum\n{\n\t/*read mode*/\n\tGF_ISOM_DATA_MAP_READ = 1,\n\t/*write mode*/\n\tGF_ISOM_DATA_MAP_WRITE = 2,\n\t/*the following modes are just ways of signaling extended functionalities\n\tedit mode, to make sure the file is here, set to GF_ISOM_DATA_MAP_READ afterwards*/\n\tGF_ISOM_DATA_MAP_EDIT = 3,\n\t/*read-only access to the movie file: we create a file mapping object\n\tmode is set to GF_ISOM_DATA_MAP_READ afterwards*/\n\tGF_ISOM_DATA_MAP_READ_ONLY = 4,\n\t/*write-only access at the end of the movie - only used for movie fragments concatenation*/\n\tGF_ISOM_DATA_MAP_CAT = 5,\n};\n\n/*this is the DataHandler structure each data handler has its own bitstream*/\n#define GF_ISOM_BASE_DATA_HANDLER\t\\\n\tu8\ttype;\t\t\\\n\tu64\tcurPos;\t\t\\\n\tu8\tmode;\t\t\\\n\tGF_BitStream *bs;\\\n\tchar *szName;\n\ntypedef struct __tag_data_map\n{\n\tGF_ISOM_BASE_DATA_HANDLER\n} GF_DataMap;\n\ntypedef struct\n{\n\tGF_ISOM_BASE_DATA_HANDLER\n\tFILE *stream;\n\tBool is_stdout;\n\tBool last_acces_was_read;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tchar *temp_file;\n#endif\n} GF_FileDataMap;\n\n/*file mapping handler. used if supported, only on read mode for complete files  (not in file download)*/\ntypedef struct\n{\n\tGF_ISOM_BASE_DATA_HANDLER\n\tchar *name;\n\tu64 file_size;\n\tchar *byte_map;\n\tu64 byte_pos;\n} GF_FileMappingDataMap;\n\nGF_Err gf_isom_datamap_new(const char *location, const char *parentPath, u8 mode, GF_DataMap **outDataMap);\nvoid gf_isom_datamap_del(GF_DataMap *ptr);\nGF_Err gf_isom_datamap_open(GF_MediaBox *minf, u32 dataRefIndex, u8 Edit);\nvoid gf_isom_datamap_close(GF_MediaInformationBox *minf);\nu32 gf_isom_datamap_get_data(GF_DataMap *map, char *buffer, u32 bufferLength, u64 Offset);\n\n/*File-based data map*/\nGF_DataMap *gf_isom_fdm_new(const char *sPath, u8 mode);\nvoid gf_isom_fdm_del(GF_FileDataMap *ptr);\nu32 gf_isom_fdm_get_data(GF_FileDataMap *ptr, char *buffer, u32 bufferLength, u64 fileOffset);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_DataMap *gf_isom_fdm_new_temp(const char *sTempPath);\n#endif\n\n/*file-mapping, read only*/\nGF_DataMap *gf_isom_fmo_new(const char *sPath, u8 mode);\nvoid gf_isom_fmo_del(GF_FileMappingDataMap *ptr);\nu32 gf_isom_fmo_get_data(GF_FileMappingDataMap *ptr, char *buffer, u32 bufferLength, u64 fileOffset);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nu64 gf_isom_datamap_get_offset(GF_DataMap *map);\nGF_Err gf_isom_datamap_add_data(GF_DataMap *ptr, char *data, u32 dataSize);\n#endif\n\nvoid gf_isom_datamap_flush(GF_DataMap *map);\n\n/*\n\t\tMovie stuff\n*/\n\n\n/*time def for MP4/QT/MJ2K files*/\n#define GF_ISOM_MAC_TIME_OFFSET 2082844800\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n#define GF_ISOM_FORMAT_FRAG_FLAGS(pad, sync, deg) ( ( (pad) << 17) | ( ( !(sync) ) << 16) | (deg) );\n#define GF_ISOM_GET_FRAG_PAD(flag) ( (flag) >> 17) & 0x7\n#define GF_ISOM_GET_FRAG_SYNC(flag) ( ! ( ( (flag) >> 16) & 0x1))\n#define GF_ISOM_GET_FRAG_DEG(flag)\t(flag) & 0x7FFF\n\n#define GF_ISOM_GET_FRAG_LEAD(flag) ( (flag) >> 26) & 0x3\n#define GF_ISOM_GET_FRAG_DEPENDS(flag) ( (flag) >> 24) & 0x3\n#define GF_ISOM_GET_FRAG_DEPENDED(flag) ( (flag) >> 22) & 0x3\n#define GF_ISOM_GET_FRAG_REDUNDANT(flag) ( (flag) >> 20) & 0x3\n\n#define GF_ISOM_GET_FRAG_DEPEND_FLAGS(lead, depends, depended, redundant) ( (lead<<26) | (depends<<24) | (depended<<22) | (redundant<<20) )\n#define GF_ISOM_RESET_FRAG_DEPEND_FLAGS(flags) flags = flags & 0xFFFFF\n\nGF_TrackExtendsBox *GetTrex(GF_MovieBox *moov, u32 TrackID);\n#endif\n\nenum\n{\n\tGF_ISOM_FRAG_WRITE_READY\t=\t0x01,\n\tGF_ISOM_FRAG_READ_DEBUG\t\t=\t0x02,\n};\n\n/*this is our movie object*/\nstruct __tag_isom {\n\t/*the last fatal error*/\n\tGF_Err LastError;\n\t/*the original filename*/\n\tchar *fileName;\n\t/*the original file in read/edit, and also used in fragments mode\n\tonce the first moov has been written\n\tNota: this API doesn't allow fragments BEFORE the MOOV in order\n\tto make easily parsable files (note there could be some data (mdat) before\n\tthe moov*/\n\tGF_DataMap *movieFileMap;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*the final file name*/\n\tchar *finalName;\n\t/*the file where we store edited samples (for READ_WRITE and WRITE mode only)*/\n\tGF_DataMap *editFileMap;\n\t/*the interleaving time for dummy mode (in movie TimeScale)*/\n\tu32 interleavingTime;\n#endif\n\n\tu8 openMode;\n\tu8 storageMode;\n\t/*if true 3GPP text streams are read as MPEG-4 StreamingText*/\n\tu8 convert_streaming_text;\n\tu8 is_jp2;\n\tu8 force_co64;\n\n\tBool keep_utc, drop_date_version_info;\n\t/*main boxes for fast access*/\n\t/*moov*/\n\tGF_MovieBox *moov;\n\t/*our MDAT box (one and only one when we store the file)*/\n\tGF_MediaDataBox *mdat;\n\t/*file brand (since v2, NULL means mp4 v1)*/\n\tGF_FileTypeBox *brand;\n\t/*progressive download info*/\n\tGF_ProgressiveDownloadBox *pdin;\n\t/*meta box if any*/\n\tGF_MetaBox *meta;\n\n\tBool dump_mode_alloc;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 FragmentsFlags, NextMoofNumber;\n\t/*active fragment*/\n\tGF_MovieFragmentBox *moof;\n\t/*in WRITE mode, this is the current MDAT where data is written*/\n\t/*in READ mode this is the last valid file position before a gf_isom_box_read failed*/\n\tu64 current_top_box_start;\n\tu64 segment_start;\n\n\tGF_List *moof_list;\n\tBool use_segments, moof_first, append_segment, styp_written, force_moof_base_offset;\n\n\t/*used when building single-indexed self initializing media segments*/\n\tGF_SegmentIndexBox *root_sidx;\n\tu64 root_sidx_offset;\n\tu32 root_sidx_index;\n\n\tBool is_index_segment;\n\n\tGF_BitStream *segment_bs;\n\t/* 0: no moof found yet, 1: 1 moof found, 2: next moof found */\n\tBool single_moof_mode;\n\tu32 single_moof_state;\n\n\t/* optional mfra box used in write mode */\n\tGF_MovieFragmentRandomAccessBox *mfra;\n#endif\n\tGF_ProducerReferenceTimeBox *last_producer_ref_time;\n\n\t/*this contains ALL the root boxes excepts fragments*/\n\tGF_List *TopBoxes;\n\n\t/*default track for sync of MPEG4 streams - this is the first accessed stream without OCR info - only set in READ mode*/\n\ts32 es_id_default_sync;\n\n\tBool is_smooth;\n};\n\n/*time function*/\nu64 gf_isom_get_mp4time();\n/*set the last error of the file. if file is NULL, set the static error (used for IO errors*/\nvoid gf_isom_set_last_error(GF_ISOFile *the_file, GF_Err error);\nGF_Err gf_isom_parse_movie_boxes(GF_ISOFile *mov, u64 *bytesMissing, Bool progressive_mode);\nGF_ISOFile *gf_isom_new_movie();\n/*Movie and Track access functions*/\nGF_TrackBox *gf_isom_get_track_from_file(GF_ISOFile *the_file, u32 trackNumber);\nGF_TrackBox *gf_isom_get_track(GF_MovieBox *moov, u32 trackNumber);\nGF_TrackBox *gf_isom_get_track_from_id(GF_MovieBox *moov, u32 trackID);\nGF_TrackBox *gf_isom_get_track_from_original_id(GF_MovieBox *moov, u32 originalID, u32 originalFile);\nu32 gf_isom_get_tracknum_from_id(GF_MovieBox *moov, u32 trackID);\n/*open a movie*/\nGF_ISOFile *gf_isom_open_file(const char *fileName, u32 OpenMode, const char *tmp_dir);\n/*close and delete a movie*/\nvoid gf_isom_delete_movie(GF_ISOFile *mov);\n/*StreamDescription reconstruction Functions*/\nGF_Err GetESD(GF_MovieBox *moov, u32 trackID, u32 StreamDescIndex, GF_ESD **outESD);\nGF_Err GetESDForTime(GF_MovieBox *moov, u32 trackID, u64 CTS, GF_ESD **outESD);\nGF_Err Media_GetSampleDesc(GF_MediaBox *mdia, u32 SampleDescIndex, GF_SampleEntryBox **out_entry, u32 *dataRefIndex);\nGF_Err Media_GetSampleDescIndex(GF_MediaBox *mdia, u64 DTS, u32 *sampleDescIndex);\n/*get esd for given sample desc -\n\t@true_desc_only: if true doesn't emulate desc and returns native ESD,\n\t\t\t\totherwise emulates if needed/possible (TimedText) and return a hard copy of the desc\n*/\nGF_Err Media_GetESD(GF_MediaBox *mdia, u32 sampleDescIndex, GF_ESD **esd, Bool true_desc_only);\nBool Track_IsMPEG4Stream(u32 HandlerType);\nBool IsMP4Description(u32 entryType);\n/*Find a reference of a given type*/\nGF_Err Track_FindRef(GF_TrackBox *trak, u32 ReferenceType, GF_TrackReferenceTypeBox **dpnd);\n/*Time and sample*/\nGF_Err GetMediaTime(GF_TrackBox *trak, Bool force_non_empty, u64 movieTime, u64 *MediaTime, s64 *SegmentStartTime, s64 *MediaOffset, u8 *useEdit, u64 *next_edit_start_plus_one);\nGF_Err Media_GetSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample **samp, u32 *sampleDescriptionIndex, Bool no_data, u64 *out_offset);\nGF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex);\nGF_Err Media_FindSyncSample(GF_SampleTableBox *stbl, u32 searchFromTime, u32 *sampleNumber, u8 mode);\nGF_Err Media_RewriteODFrame(GF_MediaBox *mdia, GF_ISOSample *sample);\nGF_Err Media_FindDataRef(GF_DataReferenceBox *dref, char *URLname, char *URNname, u32 *dataRefIndex);\nBool Media_IsSelfContained(GF_MediaBox *mdia, u32 StreamDescIndex);\n\n\nGF_TrackBox *GetTrackbyID(GF_MovieBox *moov, u32 TrackID);\n\n/*check the TimeToSample for the given time and return the Sample number\nif the entry is not found, return the closest sampleNumber in prevSampleNumber and 0 in sampleNumber\nif the DTS required is after all DTSs in the list, set prevSampleNumber and SampleNumber to 0\nuseCTS specifies that we're looking for a composition time\n*/\nGF_Err stbl_findEntryForTime(GF_SampleTableBox *stbl, u64 DTS, u8 useCTS, u32 *sampleNumber, u32 *prevSampleNumber);\n/*Reading of the sample tables*/\nGF_Err stbl_GetSampleSize(GF_SampleSizeBox *stsz, u32 SampleNumber, u32 *Size);\nGF_Err stbl_GetSampleCTS(GF_CompositionOffsetBox *ctts, u32 SampleNumber, s32 *CTSoffset);\nGF_Err stbl_GetSampleDTS(GF_TimeToSampleBox *stts, u32 SampleNumber, u64 *DTS);\nGF_Err stbl_GetSampleDTS_and_Duration(GF_TimeToSampleBox *stts, u32 SampleNumber, u64 *DTS, u32 *duration);\n\n/*find a RAP or set the prev / next RAPs if vars are passed*/\nGF_Err stbl_GetSampleRAP(GF_SyncSampleBox *stss, u32 SampleNumber, SAPType *IsRAP, u32 *prevRAP, u32 *nextRAP);\n/*same as above but only look for open-gop RAPs and GDR (roll)*/\nGF_Err stbl_SearchSAPs(GF_SampleTableBox *stbl, u32 SampleNumber, SAPType *IsRAP, u32 *prevRAP, u32 *nextRAP);\nGF_Err stbl_GetSampleInfos(GF_SampleTableBox *stbl, u32 sampleNumber, u64 *offset, u32 *chunkNumber, u32 *descIndex, u8 *isEdited);\nGF_Err stbl_GetSampleShadow(GF_ShadowSyncBox *stsh, u32 *sampleNumber, u32 *syncNum);\nGF_Err stbl_GetPaddingBits(GF_PaddingBitsBox *padb, u32 SampleNumber, u8 *PadBits);\nu32 stbl_GetSampleFragmentCount(GF_SampleFragmentBox *stsf, u32 sampleNumber);\nu32 stbl_GetSampleFragmentSize(GF_SampleFragmentBox *stsf, u32 sampleNumber, u32 FragmentIndex);\nGF_Err stbl_GetSampleDepType(GF_SampleDependencyTypeBox *stbl, u32 SampleNumber, u32 *isLeading, u32 *dependsOn, u32 *dependedOn, u32 *redundant);\n\n\n/*unpack sample2chunk and chunk offset so that we have 1 sample per chunk (edition mode only)*/\nGF_Err stbl_UnpackOffsets(GF_SampleTableBox *stbl);\nGF_Err stbl_unpackCTS(GF_SampleTableBox *stbl);\nGF_Err SetTrackDuration(GF_TrackBox *trak);\nGF_Err Media_SetDuration(GF_TrackBox *trak);\n\n/*rewrites 3GP samples desc as MPEG-4 ESD*/\nGF_Err gf_isom_get_ttxt_esd(GF_MediaBox *mdia, GF_ESD **out_esd);\n/*inserts TTU header - only used when conversion to StreamingText is on*/\nGF_Err gf_isom_rewrite_text_sample(GF_ISOSample *samp, u32 sampleDescriptionIndex, u32 sample_dur);\n\nGF_UserDataMap *udta_getEntry(GF_UserDataBox *ptr, u32 box_type, bin128 *uuid);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err FlushCaptureMode(GF_ISOFile *movie);\nGF_Err CanAccessMovie(GF_ISOFile *movie, u32 Mode);\nGF_ISOFile *gf_isom_create_movie(const char *fileName, u32 OpenMode, const char *tmp_dir);\nvoid gf_isom_insert_moov(GF_ISOFile *file);\n\nGF_Err WriteToFile(GF_ISOFile *movie);\nGF_Err Track_SetStreamDescriptor(GF_TrackBox *trak, u32 StreamDescriptionIndex, u32 DataReferenceIndex, GF_ESD *esd, u32 *outStreamIndex);\nu8 RequestTrack(GF_MovieBox *moov, u32 TrackID);\n/*Track-Media setup*/\nGF_Err NewMedia(GF_MediaBox **mdia, u32 MediaType, u32 TimeScale);\nGF_Err Media_ParseODFrame(GF_MediaBox *mdia, const GF_ISOSample *sample, GF_ISOSample **od_samp);\nGF_Err Media_AddSample(GF_MediaBox *mdia, u64 data_offset, const GF_ISOSample *sample, u32 StreamDescIndex, u32 syncShadowNumber);\nGF_Err Media_CreateDataRef(GF_DataReferenceBox *dref, char *URLname, char *URNname, u32 *dataRefIndex);\n/*update a media sample. ONLY in edit mode*/\nGF_Err Media_UpdateSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample *sample, Bool data_only);\nGF_Err Media_UpdateSampleReference(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample *sample, u64 data_offset);\n/*addition in the sample tables*/\nGF_Err stbl_AddDTS(GF_SampleTableBox *stbl, u64 DTS, u32 *sampleNumber, u32 LastAUDefDuration);\nGF_Err stbl_AddCTS(GF_SampleTableBox *stbl, u32 sampleNumber, s32 CTSoffset);\nGF_Err stbl_AddSize(GF_SampleSizeBox *stsz, u32 sampleNumber, u32 size);\nGF_Err stbl_AddRAP(GF_SyncSampleBox *stss, u32 sampleNumber);\nGF_Err stbl_AddShadow(GF_ShadowSyncBox *stsh, u32 sampleNumber, u32 shadowNumber);\nGF_Err stbl_AddChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u32 StreamDescIndex, u64 offset);\n/*NB - no add for padding, this is done only through SetPaddingBits*/\n\nGF_Err stbl_AddSampleFragment(GF_SampleTableBox *stbl, u32 sampleNumber, u16 size);\n\n/*update of the sample table\nall these functions are called in edit and we always have 1 sample per chunk*/\nGF_Err stbl_SetChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u64 offset);\nGF_Err stbl_SetSampleCTS(GF_SampleTableBox *stbl, u32 sampleNumber, s32 offset);\nGF_Err stbl_SetSampleSize(GF_SampleSizeBox *stsz, u32 SampleNumber, u32 size);\nGF_Err stbl_SetSampleRAP(GF_SyncSampleBox *stss, u32 SampleNumber, u8 isRAP);\nGF_Err stbl_SetSyncShadow(GF_ShadowSyncBox *stsh, u32 sampleNumber, u32 syncSample);\nGF_Err stbl_SetPaddingBits(GF_SampleTableBox *stbl, u32 SampleNumber, u8 bits);\n/*for adding fragmented samples*/\nGF_Err stbl_SampleSizeAppend(GF_SampleSizeBox *stsz, u32 data_size);\n/*writing of the final chunk info in edit mode*/\nGF_Err stbl_SetChunkAndOffset(GF_SampleTableBox *stbl, u32 sampleNumber, u32 StreamDescIndex, GF_SampleToChunkBox *the_stsc, GF_Box **the_stco, u64 data_offset, u8 forceNewChunk);\n/*EDIT LIST functions*/\nGF_EdtsEntry *CreateEditEntry(u64 EditDuration, u64 MediaTime, u8 EditMode);\n\nGF_Err stbl_SetRedundant(GF_SampleTableBox *stbl, u32 sampleNumber);\nGF_Err stbl_AddRedundant(GF_SampleTableBox *stbl, u32 sampleNumber);\n\n/*REMOVE functions*/\nGF_Err stbl_RemoveDTS(GF_SampleTableBox *stbl, u32 sampleNumber, u32 LastAUDefDuration);\nGF_Err stbl_RemoveCTS(GF_SampleTableBox *stbl, u32 sampleNumber);\nGF_Err stbl_RemoveSize(GF_SampleSizeBox *stsz, u32 sampleNumber);\nGF_Err stbl_RemoveChunk(GF_SampleTableBox *stbl, u32 sampleNumber);\nGF_Err stbl_RemoveRAP(GF_SampleTableBox *stbl, u32 sampleNumber);\nGF_Err stbl_RemoveShadow(GF_ShadowSyncBox *stsh, u32 sampleNumber);\nGF_Err stbl_RemovePaddingBits(GF_SampleTableBox *stbl, u32 SampleNumber);\nGF_Err stbl_RemoveSampleFragments(GF_SampleTableBox *stbl, u32 sampleNumber);\nGF_Err stbl_RemoveRedundant(GF_SampleTableBox *stbl, u32 SampleNumber);\nGF_Err stbl_RemoveSubSample(GF_SampleTableBox *stbl, u32 SampleNumber);\nGF_Err stbl_RemoveSampleGroup(GF_SampleTableBox *stbl, u32 SampleNumber);\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err gf_isom_close_fragments(GF_ISOFile *movie);\nGF_Err gf_isom_copy_sample_group_entry_to_traf(GF_TrackFragmentBox *traf, GF_SampleTableBox *stbl, u32 grouping_type, u32 grouping_type_parameter, u32 sampleGroupDescriptionIndex, Bool sgpd_in_traf);\n#endif\n\nBool gf_isom_is_identical_sgpd(void *ptr1, void *ptr2, u32 grouping_type);\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_DefaultSampleGroupDescriptionEntry * gf_isom_get_sample_group_info_entry(GF_ISOFile *the_file, GF_TrackBox *trak, u32 grouping_type, u32 sample_description_index, u32 *default_index, GF_SampleGroupDescriptionBox **out_sgdp);\n\nGF_Err GetNextMediaTime(GF_TrackBox *trak, u64 movieTime, u64 *OutMovieTime);\nGF_Err GetPrevMediaTime(GF_TrackBox *trak, u64 movieTime, u64 *OutMovieTime);\n\nBool IsHintTrack(GF_TrackBox *trak);\nBool CheckHintFormat(GF_TrackBox *trak, u32 HintType);\nu32 GetHintFormat(GF_TrackBox *trak);\n\n\nvoid gf_isom_box_add_for_dump_mode(GF_Box *parent, GF_Box *a);\n\n/*locate a box by its type or UUID*/\nGF_ItemListBox *gf_ismo_locate_box(GF_List *list, u32 boxType, bin128 UUID);\n\nGF_Err moov_AddBox(GF_Box *ptr, GF_Box *a);\nGF_Err tref_AddBox(GF_Box *ptr, GF_Box *a);\nGF_Err trak_AddBox(GF_Box *ptr, GF_Box *a);\nGF_Err mvex_AddBox(GF_Box *ptr, GF_Box *a);\nGF_Err stsd_AddBox(GF_Box *ptr, GF_Box *a);\nGF_Err hnti_AddBox(GF_Box *hnti, GF_Box *a);\nGF_Err udta_AddBox(GF_Box *ptr, GF_Box *a);\nGF_Err edts_AddBox(GF_Box *s, GF_Box *a);\nGF_Err stdp_Read(GF_Box *s, GF_BitStream *bs);\nGF_Err stbl_AddBox(GF_Box *ptr, GF_Box *a);\nGF_Err sdtp_Read(GF_Box *s, GF_BitStream *bs);\nGF_Err dinf_AddBox(GF_Box *s, GF_Box *a);\nGF_Err minf_AddBox(GF_Box *s, GF_Box *a);\nGF_Err mdia_AddBox(GF_Box *s, GF_Box *a);\nGF_Err traf_AddBox(GF_Box *s, GF_Box *a);\n\n/*rewrites avcC based on the given esd - this destroys the esd*/\nGF_Err AVC_HEVC_UpdateESD(GF_MPEGVisualSampleEntryBox *avc, GF_ESD *esd);\nvoid AVC_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *avc, GF_MediaBox *mdia);\nvoid AVC_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *avc);\nvoid HEVC_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *avc, GF_MediaBox *mdia);\nvoid HEVC_RewriteESDescriptor(GF_MPEGVisualSampleEntryBox *avc);\n\nGF_Err reftype_AddRefTrack(GF_TrackReferenceTypeBox *ref, u32 trackID, u16 *outRefIndex);\nGF_XMLBox *gf_isom_get_meta_xml(GF_ISOFile *file, Bool root_meta, u32 track_num, Bool *is_binary);\nBool gf_isom_cenc_has_saiz_saio_track(GF_SampleTableBox *stbl, u32 scheme_type);\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nBool gf_isom_cenc_has_saiz_saio_traf(GF_TrackFragmentBox *traf, u32 scheme_type);\nvoid gf_isom_cenc_set_saiz_saio(GF_SampleEncryptionBox *senc, GF_SampleTableBox *stbl, GF_TrackFragmentBox  *traf, u32 len);\n#endif\nvoid gf_isom_cenc_merge_saiz_saio(GF_SampleEncryptionBox *senc, GF_SampleTableBox *stbl, u64 offset, u32 len);\n\nvoid gf_isom_parse_trif_info(const char *data, u32 size, u32 *id, u32 *independent, Bool *full_picture, u32 *x, u32 *y, u32 *w, u32 *h);\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\n/*\n\t\tHinting stuff\n*/\n\n/*****************************************************\n\t\tRTP Data Entries\n*****************************************************/\n\ntypedef struct\n{\n\tu8 sender_current_time_present;\n\tu8 expected_residual_time_present;\n\tu8 session_close_bit;\n\tu8 object_close_bit;\n\tu16 transport_object_identifier;\n} GF_LCTheaderTemplate;\n\ntypedef struct\n{\n\tu8 header_extension_type;\n\tu8 content[3];\n\tu32 data_length;\n\tchar *data;\n} GF_LCTheaderExtension;\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\n\tGF_LCTheaderTemplate info;\n\tu16 header_ext_count;\n\tGF_LCTheaderExtension *headers;\n\n\tGF_List *constructors;\n} GF_FDpacketBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\n\tu8 FEC_encoding_ID;\n\tu16 FEC_instance_ID;\n\tu16 source_block_number;\n\tu16 encoding_symbol_ID;\n} GF_FECInformationBox;\n\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\n\tGF_FECInformationBox *feci;\n\tu32 data_length;\n\tchar *data;\n} GF_ExtraDataBox;\n\n\n#define GF_ISMO_BASE_DTE_ENTRY\t\\\n\tu8 source;\n\ntypedef struct\n{\n\tGF_ISMO_BASE_DTE_ENTRY\n} GF_GenericDTE;\n\ntypedef struct\n{\n\tGF_ISMO_BASE_DTE_ENTRY\n} GF_EmptyDTE;\n\ntypedef struct\n{\n\tGF_ISMO_BASE_DTE_ENTRY\n\tu8 dataLength;\n\tchar data[14];\n} GF_ImmediateDTE;\n\ntypedef struct\n{\n\tGF_ISMO_BASE_DTE_ENTRY\n\ts8 trackRefIndex;\n\tu32 sampleNumber;\n\tu16 dataLength;\n\tu32 byteOffset;\n\tu16 bytesPerComp;\n\tu16 samplesPerComp;\n} GF_SampleDTE;\n\ntypedef struct\n{\n\tGF_ISMO_BASE_DTE_ENTRY\n\ts8 trackRefIndex;\n\tu32 streamDescIndex;\n\tu16 dataLength;\n\tu32 byteOffset;\n\tu32 reserved;\n} GF_StreamDescDTE;\n\nGF_GenericDTE *NewDTE(u8 type);\nvoid DelDTE(GF_GenericDTE *dte);\nGF_Err ReadDTE(GF_GenericDTE *dte, GF_BitStream *bs);\nGF_Err WriteDTE(GF_GenericDTE *dte, GF_BitStream *bs);\nGF_Err OffsetDTE(GF_GenericDTE *dte, u32 offset, u32 HintSampleNumber);\n\n/*****************************************************\n\t\tRTP Sample\n*****************************************************/\n\n/*data cache when reading*/\ntypedef struct __tag_hint_data_cache\n{\n\tGF_ISOSample *samp;\n\tGF_TrackBox *trak;\n\tu32 sample_num;\n} GF_HintDataCache;\n\ntypedef struct __tag_hint_sample\n{\n\t//for samples deriving from box\n\tGF_ISOM_BOX\n\n\t/*contains 4cc of hint track sample entry*/\n\tu32 hint_subtype;\n\tu16 packetCount;\n\tu16 reserved;\n\tGF_List *packetTable;\n\tchar *AdditionalData;\n\tu32 dataLength;\n\t/*used internally for hinting*/\n\tu64 TransmissionTime;\n\t/*for read only, used to store samples fetched while building packets*/\n\tGF_List *sample_cache;\n\n\t//for dump\n\tu32 trackID, sampleNumber;\n\n\tGF_ExtraDataBox *extra_data;\n} GF_HintSample;\n\nGF_HintSample *gf_isom_hint_sample_new(u32 ProtocolType);\nvoid gf_isom_hint_sample_del(GF_HintSample *ptr);\nGF_Err gf_isom_hint_sample_read(GF_HintSample *ptr, GF_BitStream *bs, u32 sampleSize);\nGF_Err gf_isom_hint_sample_write(GF_HintSample *ptr, GF_BitStream *bs);\nu32 gf_isom_hint_sample_size(GF_HintSample *ptr);\n\n\n/*****************************************************\n\t\tHint Packets (generic packet for future protocol support)\n*****************************************************/\n#define GF_ISOM_BASE_PACKET\t\t\t\\\n\tu32 hint_subtype, trackID, sampleNumber;\t\\\n\ts32 relativeTransTime;\n\n\ntypedef struct\n{\n\tGF_ISOM_BASE_PACKET\n} GF_HintPacket;\n\nGF_HintPacket *gf_isom_hint_pck_new(u32 HintType);\nvoid gf_isom_hint_pck_del(GF_HintPacket *ptr);\nGF_Err gf_isom_hint_pck_read(GF_HintPacket *ptr, GF_BitStream *bs);\nGF_Err gf_isom_hint_pck_write(GF_HintPacket *ptr, GF_BitStream *bs);\nu32 gf_isom_hint_pck_size(GF_HintPacket *ptr);\nGF_Err gf_isom_hint_pck_offset(GF_HintPacket *ptr, u32 offset, u32 HintSampleNumber);\nGF_Err gf_isom_hint_pck_add_dte(GF_HintPacket *ptr, GF_GenericDTE *dte, u8 AtBegin);\n/*get the size of the packet AS RECONSTRUCTED BY THE SERVER (without CSRC)*/\nu32 gf_isom_hint_pck_length(GF_HintPacket *ptr);\n\n/*the RTP packet*/\ntypedef struct\n{\n\tGF_ISOM_BASE_PACKET\n\n\t/*RTP Header*/\n\tu8 P_bit;\n\tu8 X_bit;\n\tu8 M_bit;\n\t/*on 7 bits */\n\tu8 payloadType;\n\tu16 SequenceNumber;\n\t/*Hinting flags*/\n\tu8 B_bit;\n\tu8 R_bit;\n\t/*ExtraInfos TLVs - not really used */\n\tGF_List *TLV;\n\t/*DataTable - contains the DTEs...*/\n\tGF_List *DataTable;\n} GF_RTPPacket;\n\nGF_RTPPacket *gf_isom_hint_rtp_new();\nvoid gf_isom_hint_rtp_del(GF_RTPPacket *ptr);\nGF_Err gf_isom_hint_rtp_read(GF_RTPPacket *ptr, GF_BitStream *bs);\nGF_Err gf_isom_hint_rtp_write(GF_RTPPacket *ptr, GF_BitStream *bs);\nu32 gf_isom_hint_rtp_size(GF_RTPPacket *ptr);\nGF_Err gf_isom_hint_rtp_offset(GF_RTPPacket *ptr, u32 offset, u32 HintSampleNumber);\nu32 gf_isom_hint_rtp_length(GF_RTPPacket *ptr);\n\n\n/*the RTP packet*/\ntypedef struct\n{\n\tGF_ISOM_BASE_PACKET\n\n\t//RTCP report\n\tu8 Version, Padding, Count, PayloadType;\n\tu32 length;\n\tchar *data;\n} GF_RTCPPacket;\n\nGF_RTCPPacket *gf_isom_hint_rtcp_new();\nvoid gf_isom_hint_rtcp_del(GF_RTCPPacket *ptr);\nGF_Err gf_isom_hint_rtcp_read(GF_RTCPPacket *ptr, GF_BitStream *bs);\nGF_Err gf_isom_hint_rtcp_write(GF_RTCPPacket *ptr, GF_BitStream *bs);\nu32 gf_isom_hint_rtcp_size(GF_RTCPPacket *ptr);\nu32 gf_isom_hint_rtcp_length(GF_RTCPPacket *ptr);\n\n\n#endif\n\n\nstruct _3gpp_text_sample\n{\n\tchar *text;\n\tu32 len;\n\n\tGF_TextStyleBox *styles;\n\t/*at most one of these*/\n\tGF_TextHighlightColorBox *highlight_color;\n\tGF_TextScrollDelayBox *scroll_delay;\n\tGF_TextBoxBox *box;\n\tGF_TextWrapBox *wrap;\n\n\tGF_List *others;\n\tGF_TextKaraokeBox *cur_karaoke;\n};\n\nGF_TextSample *gf_isom_parse_texte_sample(GF_BitStream *bs);\nGF_TextSample *gf_isom_parse_texte_sample_from_data(char *data, u32 dataLength);\n\nstruct _generic_subtitle_sample\n{\n\tchar *text;\n\tu32 len;\n};\nGF_GenericSubtitleSample *gf_isom_parse_generic_subtitle_sample(GF_BitStream *bs);\nGF_GenericSubtitleSample *gf_isom_parse_generic_subtitle_sample_from_data(char *data, u32 dataLength);\n\n\n/*do not throw fatal errors if boxes are duplicated, just warn and remove extra ones*/\n#define ERROR_ON_DUPLICATED_BOX(__abox, __parent) {\t\\\n\t\tchar __ptype[5];\\\n\t\tstrcpy(__ptype, gf_4cc_to_str(__parent->type) );\\\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] extra box %s found in %s, deleting\\n\", gf_4cc_to_str(__abox->type), __ptype)); \\\n\t\tgf_isom_box_del(__abox);\\\n\t\treturn GF_OK;\\\n\t}\n\n\n#ifndef GPAC_DISABLE_VTT\n\nGF_Err gf_isom_update_webvtt_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex, const char *config);\nGF_ISOSample *gf_isom_webvtt_to_sample(void *samp);\n\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tchar *string;\n} GF_StringBox;\n\ntypedef struct\n{\n\tGF_ISOM_SAMPLE_ENTRY_FIELDS\n\tGF_StringBox *config;\n} GF_WebVTTSampleEntryBox;\n\nGF_WebVTTSampleEntryBox *gf_webvtt_isom_get_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex);\n\nGF_List *gf_webvtt_parse_cues_from_data(const char *data, u32 dataLength, u64 start);\n\n#endif /* GPAC_DISABLE_VTT */\n\n//exported for sgpd comparison in traf merge\nvoid sgpd_write_entry(u32 grouping_type, void *entry, GF_BitStream *bs);\nBool gf_isom_box_equal(GF_Box *a, GF_Box *b);\nGF_Box *gf_isom_clone_config_box(GF_Box *box);\n\nGF_Err gf_isom_box_dump(void *ptr, FILE * trace);\nGF_Err gf_isom_box_array_dump(GF_List *list, FILE * trace);\n\n/*Apple extensions*/\nGF_MetaBox *gf_isom_apple_get_meta_extensions(GF_ISOFile *mov);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_MetaBox *gf_isom_apple_create_meta_extensions(GF_ISOFile *mov);\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\nGF_Err gf_isom_box_dump_ex(void *ptr, FILE * trace, u32 box_4cc);\nGF_Err gf_isom_box_dump_start(GF_Box *a, const char *name, FILE * trace);\nvoid gf_isom_box_dump_done(const char *name, GF_Box *ptr, FILE *trace);\nBool gf_isom_box_is_file_level(GF_Box *s);\n#endif\n\nGF_Box *boxstring_new_with_data(u32 type, const char *string);\n\nGF_Err gf_isom_read_null_terminated_string(GF_Box *s, GF_BitStream *bs, u64 size, char **out_str);\n\n#endif //GPAC_DISABLE_ISOM\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif //_GF_ISOMEDIA_DEV_H_\n\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n\n\n#ifndef GPAC_DISABLE_ISOM\n\nvoid co64_del(GF_Box *s)\n{\n\tGF_ChunkLargeOffsetBox *ptr;\n\tptr = (GF_ChunkLargeOffsetBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tgf_free(ptr);\n}\n\nGF_Err co64_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 entries;\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\n\tif (ptr->nb_entries > ptr->size / 8) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in co64\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->offsets = (u64 *) gf_malloc(ptr->nb_entries * sizeof(u64) );\n\tif (ptr->offsets == NULL) return GF_OUT_OF_MEM;\n\tptr->alloc_size = ptr->nb_entries;\n\tfor (entries = 0; entries < ptr->nb_entries; entries++) {\n\t\tptr->offsets[entries] = gf_bs_read_u64(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *co64_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChunkLargeOffsetBox, GF_ISOM_BOX_TYPE_CO64);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err co64_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++ ) {\n\t\tgf_bs_write_u64(bs, ptr->offsets[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err co64_Size(GF_Box *s)\n{\n\tGF_ChunkLargeOffsetBox *ptr = (GF_ChunkLargeOffsetBox *) s;\n\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid cprt_del(GF_Box *s)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->notice)\n\t\tgf_free(ptr->notice);\n\tgf_free(ptr);\n}\n\n\nGF_Box *chpl_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChapterListBox, GF_ISOM_BOX_TYPE_CHPL);\n\ttmp->list = gf_list_new();\n\ttmp->version = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid chpl_del(GF_Box *s)\n{\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *) s;\n\tif (ptr == NULL) return;\n\twhile (gf_list_count(ptr->list)) {\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, 0);\n\t\tif (ce->name) gf_free(ce->name);\n\t\tgf_free(ce);\n\t\tgf_list_rem(ptr->list, 0);\n\t}\n\tgf_list_del(ptr->list);\n\tgf_free(ptr);\n}\n\n/*this is using chpl format according to some NeroRecode samples*/\nGF_Err chpl_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ChapterEntry *ce;\n\tu32 nb_chaps, len, i, count;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *)s;\n\n\t/*reserved or ???*/\n\tgf_bs_read_u32(bs);\n\tnb_chaps = gf_bs_read_u8(bs);\n\n\tcount = 0;\n\twhile (nb_chaps) {\n\t\tGF_SAFEALLOC(ce, GF_ChapterEntry);\n\t\tif (!ce) return GF_OUT_OF_MEM;\n\t\tce->start_time = gf_bs_read_u64(bs);\n\t\tlen = gf_bs_read_u8(bs);\n\t\tif (len) {\n\t\t\tce->name = (char *)gf_malloc(sizeof(char)*(len+1));\n\t\t\tgf_bs_read_data(bs, ce->name, len);\n\t\t\tce->name[len] = 0;\n\t\t} else {\n\t\t\tce->name = gf_strdup(\"\");\n\t\t}\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ChapterEntry *ace = (GF_ChapterEntry *) gf_list_get(ptr->list, i);\n\t\t\tif (ace->start_time >= ce->start_time) {\n\t\t\t\tgf_list_insert(ptr->list, ce, i);\n\t\t\t\tce = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ce) gf_list_add(ptr->list, ce);\n\t\tcount++;\n\t\tnb_chaps--;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err chpl_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tcount = gf_list_count(ptr->list);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u8(bs, count);\n\tfor (i=0; i<count; i++) {\n\t\tu32 len;\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tgf_bs_write_u64(bs, ce->start_time);\n\t\tif (ce->name) {\n\t\t\tlen = (u32) strlen(ce->name);\n\t\t\tif (len>255) len = 255;\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, ce->name, len);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err chpl_Size(GF_Box *s)\n{\n\tu32 count, i;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *)s;\n\n\tptr->size += 5;\n\n\tcount = gf_list_count(ptr->list);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tptr->size += 9; /*64bit time stamp + 8bit str len*/\n\t\tif (ce->name) ptr->size += strlen(ce->name);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Err cprt_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *)s;\n\n\tgf_bs_read_int(bs, 1);\n\t//the spec is unclear here, just says \"the value 0 is interpreted as undetermined\"\n\tptr->packedLanguageCode[0] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguageCode[1] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguageCode[2] = gf_bs_read_int(bs, 5);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\n\t//but before or after compaction ?? We assume before\n\tif (ptr->packedLanguageCode[0] || ptr->packedLanguageCode[1] || ptr->packedLanguageCode[2]) {\n\t\tptr->packedLanguageCode[0] += 0x60;\n\t\tptr->packedLanguageCode[1] += 0x60;\n\t\tptr->packedLanguageCode[2] += 0x60;\n\t} else {\n\t\tptr->packedLanguageCode[0] = 'u';\n\t\tptr->packedLanguageCode[1] = 'n';\n\t\tptr->packedLanguageCode[2] = 'd';\n\t}\n\tif (ptr->size) {\n\t\tu32 bytesToRead = (u32) ptr->size;\n\t\tptr->notice = (char*)gf_malloc(bytesToRead * sizeof(char));\n\t\tif (ptr->notice == NULL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->notice, bytesToRead);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *cprt_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CopyrightBox, GF_ISOM_BOX_TYPE_CPRT);\n\ttmp->packedLanguageCode[0] = 'u';\n\ttmp->packedLanguageCode[1] = 'n';\n\ttmp->packedLanguageCode[2] = 'd';\n\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err cprt_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, 0, 1);\n\tif (ptr->packedLanguageCode[0]) {\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[0] - 0x60, 5);\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[1] - 0x60, 5);\n\t\tgf_bs_write_int(bs, ptr->packedLanguageCode[2] - 0x60, 5);\n\t} else {\n\t\tgf_bs_write_int(bs, 0, 15);\n\t}\n\tif (ptr->notice) {\n\t\tgf_bs_write_data(bs, ptr->notice, (u32) (strlen(ptr->notice) + 1) );\n\t}\n\treturn GF_OK;\n}\n\nGF_Err cprt_Size(GF_Box *s)\n{\n\tGF_CopyrightBox *ptr = (GF_CopyrightBox *)s;\n\n\tptr->size += 2;\n\tif (ptr->notice)\n\t\tptr->size += strlen(ptr->notice) + 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid kind_del(GF_Box *s)\n{\n\tGF_KindBox *ptr = (GF_KindBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->schemeURI) gf_free(ptr->schemeURI);\n\tif (ptr->value) gf_free(ptr->value);\n\tgf_free(ptr);\n}\n\nGF_Err kind_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_KindBox *ptr = (GF_KindBox *)s;\n\n\tif (ptr->size) {\n\t\tu32 bytesToRead = (u32) ptr->size;\n\t\tchar *data;\n\t\tu32 schemeURIlen;\n\t\tdata = (char*)gf_malloc(bytesToRead * sizeof(char));\n\t\tif (data == NULL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, data, bytesToRead);\n\t\t/*safety check in case the string is not null-terminated*/\n\t\tif (data[bytesToRead-1]) {\n\t\t\tchar *str = (char*)gf_malloc((u32) bytesToRead + 1);\n\t\t\tmemcpy(str, data, (u32) bytesToRead);\n\t\t\tstr[ptr->size] = 0;\n\t\t\tgf_free(data);\n\t\t\tdata = str;\n\t\t\tbytesToRead++;\n\t\t}\n\t\tptr->schemeURI = gf_strdup(data);\n\t\tschemeURIlen = (u32) strlen(data);\n\t\tif (bytesToRead > schemeURIlen+1) {\n\t\t\t/* read the value */\n\t\t\tchar *data_value = data + schemeURIlen +1;\n\t\t\tptr->value = gf_strdup(data_value);\n\t\t}\n\t\tgf_free(data);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *kind_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_KindBox, GF_ISOM_BOX_TYPE_KIND);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err kind_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_KindBox *ptr = (GF_KindBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->schemeURI, (u32) (strlen(ptr->schemeURI) + 1 ));\n\tif (ptr->value) {\n\t\tgf_bs_write_data(bs, ptr->value, (u32) (strlen(ptr->value) + 1) );\n\t}\n\treturn GF_OK;\n}\n\nGF_Err kind_Size(GF_Box *s)\n{\n\tGF_KindBox *ptr = (GF_KindBox *)s;\n\n\tptr->size += strlen(ptr->schemeURI) + 1;\n\tif (ptr->value) {\n\t\tptr->size += strlen(ptr->value) + 1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ctts_del(GF_Box *s)\n{\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\n\nGF_Err ctts_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tu32 sampleCount;\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tif (ptr->nb_entries > ptr->size / 8) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = (GF_DttsEntry *)gf_malloc(sizeof(GF_DttsEntry)*ptr->alloc_size);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\tsampleCount = 0;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->entries[i].sampleCount = gf_bs_read_u32(bs);\n\t\tif (ptr->version)\n\t\t\tptr->entries[i].decodingOffset = gf_bs_read_int(bs, 32);\n\t\telse\n\t\t\tptr->entries[i].decodingOffset = (s32) gf_bs_read_u32(bs);\n\t\tsampleCount += ptr->entries[i].sampleCount;\n\t}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tptr->w_LastSampleNumber = sampleCount;\n#endif\n\treturn GF_OK;\n}\n\nGF_Box *ctts_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompositionOffsetBox, GF_ISOM_BOX_TYPE_CTTS);\n\treturn (GF_Box *) tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ctts_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++ ) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleCount);\n\t\tif (ptr->version) {\n\t\t\tgf_bs_write_int(bs, ptr->entries[i].decodingOffset, 32);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) ptr->entries[i].decodingOffset);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ctts_Size(GF_Box *s)\n{\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *) s;\n\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid cslg_del(GF_Box *s)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n\treturn;\n}\n\nGF_Err cslg_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\tptr->compositionToDTSShift = gf_bs_read_int(bs, 32);\n\tptr->leastDecodeToDisplayDelta = gf_bs_read_int(bs, 32);\n\tptr->greatestDecodeToDisplayDelta = gf_bs_read_int(bs, 32);\n\tptr->compositionStartTime = gf_bs_read_int(bs, 32);\n\tptr->compositionEndTime = gf_bs_read_int(bs, 32);\n\treturn GF_OK;\n}\n\nGF_Box *cslg_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CompositionToDecodeBox, GF_ISOM_BOX_TYPE_CSLG);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err cslg_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->compositionToDTSShift, 32);\n\tgf_bs_write_int(bs, ptr->leastDecodeToDisplayDelta, 32);\n\tgf_bs_write_int(bs, ptr->greatestDecodeToDisplayDelta, 32);\n\tgf_bs_write_int(bs, ptr->compositionStartTime, 32);\n\tgf_bs_write_int(bs, ptr->compositionEndTime, 32);\n\treturn GF_OK;\n}\n\nGF_Err cslg_Size(GF_Box *s)\n{\n\tGF_CompositionToDecodeBox *ptr = (GF_CompositionToDecodeBox *)s;\n\n\tptr->size += 20;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ccst_del(GF_Box *s)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\tif (ptr) gf_free(ptr);\n\treturn;\n}\n\nGF_Err ccst_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->all_ref_pics_intra = gf_bs_read_int(bs, 1);\n\tptr->intra_pred_used = gf_bs_read_int(bs, 1);\n\tptr->max_ref_per_pic = gf_bs_read_int(bs, 4);\n\tptr->reserved = gf_bs_read_int(bs, 26);\n\treturn GF_OK;\n}\n\nGF_Box *ccst_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CodingConstraintsBox, GF_ISOM_BOX_TYPE_CCST);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ccst_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->all_ref_pics_intra, 1);\n\tgf_bs_write_int(bs, ptr->intra_pred_used, 1);\n\tgf_bs_write_int(bs, ptr->max_ref_per_pic, 4);\n\tgf_bs_write_int(bs, 0, 26);\n\treturn GF_OK;\n}\n\nGF_Err ccst_Size(GF_Box *s)\n{\n\tGF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid url_del(GF_Box *s)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->location) gf_free(ptr->location);\n\tgf_free(ptr);\n\treturn;\n}\n\n\nGF_Err url_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\tif (ptr->size) {\n\t\tptr->location = (char*)gf_malloc((u32) ptr->size);\n\t\tif (! ptr->location) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->location, (u32)ptr->size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *url_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataEntryURLBox, GF_ISOM_BOX_TYPE_URL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err url_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//the flag set indicates we have a string (WE HAVE TO for URLs)\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->location) {\n\t\t\tgf_bs_write_data(bs, ptr->location, (u32)strlen(ptr->location) + 1);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err url_Size(GF_Box *s)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->location) ptr->size += 1 + strlen(ptr->location);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid urn_del(GF_Box *s)\n{\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->location) gf_free(ptr->location);\n\tif (ptr->nameURN) gf_free(ptr->nameURN);\n\tgf_free(ptr);\n}\n\n\nGF_Err urn_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, to_read;\n\tchar *tmpName;\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\tif (! ptr->size ) return GF_OK;\n\n\t//here we have to handle that in a clever way\n\tto_read = (u32) ptr->size;\n\ttmpName = (char*)gf_malloc(sizeof(char) * to_read);\n\tif (!tmpName) return GF_OUT_OF_MEM;\n\t//get the data\n\tgf_bs_read_data(bs, tmpName, to_read);\n\n\t//then get the break\n\ti = 0;\n\twhile ( (i < to_read) && (tmpName[i] != 0) ) {\n\t\ti++;\n\t}\n\t//check the data is consistent\n\tif (i == to_read) {\n\t\tgf_free(tmpName);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t//no NULL char, URL is not specified\n\tif (i == to_read - 1) {\n\t\tptr->nameURN = tmpName;\n\t\tptr->location = NULL;\n\t\treturn GF_OK;\n\t}\n\t//OK, this has both URN and URL\n\tptr->nameURN = (char*)gf_malloc(sizeof(char) * (i+1));\n\tif (!ptr->nameURN) {\n\t\tgf_free(tmpName);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tptr->location = (char*)gf_malloc(sizeof(char) * (to_read - i - 1));\n\tif (!ptr->location) {\n\t\tgf_free(tmpName);\n\t\tgf_free(ptr->nameURN);\n\t\tptr->nameURN = NULL;\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tmemcpy(ptr->nameURN, tmpName, i + 1);\n\tmemcpy(ptr->location, tmpName + i + 1, (to_read - i - 1));\n\tgf_free(tmpName);\n\treturn GF_OK;\n}\n\nGF_Box *urn_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataEntryURNBox, GF_ISOM_BOX_TYPE_URN);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err urn_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//the flag set indicates we have a string (WE HAVE TO for URLs)\n\tif ( !(ptr->flags & 1)) {\n\t\t//to check, the spec says: First name, then location\n\t\tif (ptr->nameURN) {\n\t\t\tgf_bs_write_data(bs, ptr->nameURN, (u32)strlen(ptr->nameURN) + 1);\n\t\t}\n\t\tif (ptr->location) {\n\t\t\tgf_bs_write_data(bs, ptr->location, (u32)strlen(ptr->location) + 1);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err urn_Size(GF_Box *s)\n{\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\n\tif ( !(ptr->flags & 1)) {\n\t\tif (ptr->nameURN) ptr->size += 1 + strlen(ptr->nameURN);\n\t\tif (ptr->location) ptr->size += 1 + strlen(ptr->location);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid unkn_del(GF_Box *s)\n{\n\tGF_UnknownBox *ptr = (GF_UnknownBox *) s;\n\tif (!s) return;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err unkn_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 bytesToRead, sub_size, sub_a;\n\tGF_BitStream *sub_bs;\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\tif (ptr->size > 0xFFFFFFFF) return GF_ISOM_INVALID_FILE;\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (!bytesToRead) return GF_OK;\n\tif (bytesToRead>1000000) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Unknown box %s (0x%08X) with payload larger than 1 MBytes, ignoring\\n\", gf_4cc_to_str(ptr->type), ptr->type ));\n\t\tgf_bs_skip_bytes(bs, ptr->dataSize);\n\t\treturn GF_OK;\n\t}\n\n\tptr->data = (char*)gf_malloc(bytesToRead);\n\tif (ptr->data == NULL ) return GF_OUT_OF_MEM;\n\tptr->dataSize = bytesToRead;\n\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\n\t//try to parse container boxes, check if next 8 bytes match a subbox\n\tsub_bs = gf_bs_new(ptr->data, ptr->dataSize, GF_BITSTREAM_READ);\n\tsub_size = gf_bs_read_u32(sub_bs);\n\tsub_a = gf_bs_read_u8(sub_bs);\n\te = (sub_size && (sub_size <= ptr->dataSize)) ? GF_OK : GF_NOT_SUPPORTED;\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\tsub_a = gf_bs_read_u8(sub_bs);\n\tif (! isalnum(sub_a)) e = GF_NOT_SUPPORTED;\n\n\tif (e == GF_OK) {\n\t\tgf_bs_seek(sub_bs, 0);\n\t\te = gf_isom_box_array_read(s, sub_bs, gf_isom_box_add_default);\n\t}\n\tgf_bs_del(sub_bs);\n\tif (e==GF_OK) {\n\t\tgf_free(ptr->data);\n\t\tptr->data = NULL;\n\t\tptr->dataSize = 0;\n\t} else if (s->other_boxes) {\n\t\tgf_isom_box_array_del(s->other_boxes);\n\t\ts->other_boxes=NULL;\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *unkn_New(u32 box_type)\n{\n\tISOM_DECL_BOX_ALLOC(GF_UnknownBox, GF_ISOM_BOX_TYPE_UNKNOWN);\n\ttmp->original_4cc = box_type;\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err unkn_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 type = s->type;\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\ts->type = ptr->original_4cc;\n\te = gf_isom_box_write_header(s, bs);\n\ts->type = type;\n\tif (e) return e;\n\n\tif (ptr->dataSize && ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err unkn_Size(GF_Box *s)\n{\n\tGF_UnknownBox *ptr = (GF_UnknownBox *)s;\n\n\tif (ptr->dataSize && ptr->data) {\n\t\tptr->size += ptr->dataSize;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid def_cont_box_del(GF_Box *s)\n{\n\tif (s) gf_free(s);\n}\n\n\nGF_Err def_cont_box_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, gf_isom_box_add_default);\n}\n\nGF_Box *def_cont_box_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, 0);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITEHintSa\n\nGF_Err def_cont_box_Write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err def_cont_box_Size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid uuid_del(GF_Box *s)\n{\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox *) s;\n\tif (!s) return;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err uuid_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox *)s;\n\tif (ptr->size > 0xFFFFFFFF) return GF_ISOM_INVALID_FILE;\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (bytesToRead) {\n\t\tptr->data = (char*)gf_malloc(bytesToRead);\n\t\tif (ptr->data == NULL ) return GF_OUT_OF_MEM;\n\t\tptr->dataSize = bytesToRead;\n\t\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *uuid_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UnknownUUIDBox, GF_ISOM_BOX_TYPE_UUID);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err uuid_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_UnknownUUIDBox *ptr = (GF_UnknownUUIDBox*)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err uuid_Size(GF_Box *s)\n{\n\tGF_UnknownUUIDBox*ptr = (GF_UnknownUUIDBox*)s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid dinf_del(GF_Box *s)\n{\n\tGF_DataInformationBox *ptr = (GF_DataInformationBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_box_del((GF_Box *)ptr->dref);\n\tgf_free(ptr);\n}\n\n\nGF_Err dinf_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_DataInformationBox *ptr = (GF_DataInformationBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_DREF:\n\t\tif (ptr->dref) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\n\t\t\tptr->dref = (GF_DataReferenceBox *)a;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);\n\tif (e) {\n\t\treturn e;\n\t}\n\tif (!((GF_DataInformationBox *)s)->dref) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *dinf_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataInformationBox, GF_ISOM_BOX_TYPE_DINF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dinf_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DataInformationBox *ptr = (GF_DataInformationBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->dref) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->dref, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dinf_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_DataInformationBox *ptr = (GF_DataInformationBox *)s;\n\tif (ptr->dref) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->dref);\n\t\tif (e) return e;\n\t\tptr->size += ptr->dref->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid dref_del(GF_Box *s)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *) s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err dref_AddDataEntry(GF_Box *ptr, GF_Box *entry)\n{\n\tif (entry->type==GF_ISOM_BOX_TYPE_ALIS) {\n\t\tGF_DataEntryURLBox *urle = (GF_DataEntryURLBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_URL);\n\t\turle->flags = 1;\n\t\tgf_isom_box_del(entry);\n\t\tgf_isom_box_add_default(ptr, (GF_Box *)urle);\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] Apple \\'alis\\' box found, not supported - converting to self-pointing \\'url \\' \\n\" ));\n\t} else {\n\t\treturn gf_isom_box_add_default(ptr, entry);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dref_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tgf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\treturn gf_isom_box_array_read(s, bs, dref_AddDataEntry);\n}\n\nGF_Box *dref_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataReferenceBox, GF_ISOM_BOX_TYPE_DREF);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dref_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count;\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tcount = ptr->other_boxes ? gf_list_count(ptr->other_boxes) : 0;\n\tgf_bs_write_u32(bs, count);\n\treturn GF_OK;\n}\n\nGF_Err dref_Size(GF_Box *s)\n{\n\tGF_DataReferenceBox *ptr = (GF_DataReferenceBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid edts_del(GF_Box *s)\n{\n\tGF_EditBox *ptr = (GF_EditBox *) s;\n\tgf_isom_box_del((GF_Box *)ptr->editList);\n\tgf_free(ptr);\n}\n\n\nGF_Err edts_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\tif (a->type == GF_ISOM_BOX_TYPE_ELST) {\n\t\tif (ptr->editList) return GF_BAD_PARAM;\n\t\tptr->editList = (GF_EditListBox *)a;\n\t\treturn GF_OK;\n\t} else {\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err edts_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, edts_AddBox);\n}\n\nGF_Box *edts_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EditBox, GF_ISOM_BOX_TYPE_EDTS);\n\treturn (GF_Box *) tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err edts_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\n\t//here we have a trick: if editList is empty, skip the box\n\tif (ptr->editList && gf_list_count(ptr->editList->entryList)) {\n\t\te = gf_isom_box_write_header(s, bs);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *) ptr->editList, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err edts_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\n\t//here we have a trick: if editList is empty, skip the box\n\tif (!ptr->editList || ! gf_list_count(ptr->editList->entryList)) {\n\t\tptr->size = 0;\n\t} else {\n\t\te = gf_isom_box_size((GF_Box *)ptr->editList);\n\t\tif (e) return e;\n\t\tptr->size += ptr->editList->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid elst_del(GF_Box *s)\n{\n\tGF_EditListBox *ptr;\n\tGF_EdtsEntry *p;\n\tu32 nb_entries;\n\tu32 i;\n\n\tptr = (GF_EditListBox *)s;\n\tif (ptr == NULL) return;\n\tnb_entries = gf_list_count(ptr->entryList);\n\tfor (i = 0; i < nb_entries; i++) {\n\t\tp = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif (p) gf_free(p);\n\t}\n\tgf_list_del(ptr->entryList);\n\tgf_free(ptr);\n}\n\nGF_Err elst_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entries;\n\ts32 tr;\n\tu32 nb_entries;\n\tGF_EdtsEntry *p;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\n\tnb_entries = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tif (ptr->version == 1) {\n\t\tif (nb_entries > ptr->size / 20) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t} else {\n\t\tif (nb_entries > ptr->size / 12) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n\n\tfor (entries = 0; entries < nb_entries; entries++) {\n\t\tp = (GF_EdtsEntry *) gf_malloc(sizeof(GF_EdtsEntry));\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\tif (ptr->version == 1) {\n\t\t\tp->segmentDuration = gf_bs_read_u64(bs);\n\t\t\tp->mediaTime = (s64) gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tp->segmentDuration = gf_bs_read_u32(bs);\n\t\t\ttr = gf_bs_read_u32(bs);\n\t\t\tp->mediaTime = (s64) tr;\n\t\t}\n\t\tp->mediaRate = gf_bs_read_u16(bs);\n\t\tgf_bs_read_u16(bs);\n\t\tgf_list_add(ptr->entryList, p);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *elst_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EditListBox, GF_ISOM_BOX_TYPE_ELST);\n\ttmp->entryList = gf_list_new();\n\tif (!tmp->entryList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err elst_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tu32 nb_entries;\n\tGF_EdtsEntry *p;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\tif (!ptr) return GF_BAD_PARAM;\n\n\tnb_entries = gf_list_count(ptr->entryList);\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, nb_entries);\n\tfor (i = 0; i < nb_entries; i++ ) {\n\t\tp = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif (ptr->version == 1) {\n\t\t\tgf_bs_write_u64(bs, p->segmentDuration);\n\t\t\tgf_bs_write_u64(bs, p->mediaTime);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) p->segmentDuration);\n\t\t\tgf_bs_write_u32(bs, (s32) p->mediaTime);\n\t\t}\n\t\tgf_bs_write_u16(bs, p->mediaRate);\n\t\tgf_bs_write_u16(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err elst_Size(GF_Box *s)\n{\n\tu32 durtimebytes;\n\tu32 i, nb_entries;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\n\t//entry count\n\tptr->size += 4;\n\tnb_entries = gf_list_count(ptr->entryList);\n\tptr->version = 0;\n\tfor (i=0; i<nb_entries; i++) {\n\t\tGF_EdtsEntry *p = (GF_EdtsEntry*)gf_list_get(ptr->entryList, i);\n\t\tif ((p->segmentDuration>0xFFFFFFFF) || (p->mediaTime>0xFFFFFFFF)) {\n\t\t\tptr->version = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdurtimebytes = (ptr->version == 1 ? 16 : 8) + 4;\n\tptr->size += (nb_entries * durtimebytes);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid esds_del(GF_Box *s)\n{\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\tif (ptr == NULL)\treturn;\n\tif (ptr->desc) gf_odf_desc_del((GF_Descriptor *)ptr->desc);\n\tgf_free(ptr);\n}\n\n\nGF_Err esds_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e=GF_OK;\n\tu32 descSize;\n\tchar *enc_desc;\n\tu32 SLIsPredefined(GF_SLConfig *sl);\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\n\tdescSize = (u32) (ptr->size);\n\n\tif (descSize) {\n\t\tenc_desc = (char*)gf_malloc(sizeof(char) * descSize);\n\t\tif (!enc_desc) return GF_OUT_OF_MEM;\n\t\t//get the payload\n\t\tgf_bs_read_data(bs, enc_desc, descSize);\n\t\t//send it to the OD Codec\n\t\te = gf_odf_desc_read(enc_desc, descSize, (GF_Descriptor **) &ptr->desc);\n\t\t//OK, free our desc\n\t\tgf_free(enc_desc);\n\n\t\tif (ptr->desc && (ptr->desc->tag!=GF_ODF_ESD_TAG) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid descriptor tag 0x%x in esds\\n\", ptr->desc->tag));\n\t\t\tgf_odf_desc_del((GF_Descriptor*)ptr->desc);\n\t\t\tptr->desc=NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tif (e) {\n\t\t\tptr->desc = NULL;\n\t\t} else {\n\t\t\t/*fix broken files*/\n\t\t\tif (!ptr->desc->URLString) {\n\t\t\t\tif (!ptr->desc->slConfig) {\n\t\t\t\t\tptr->desc->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\t\t\tptr->desc->slConfig->predefined = SLPredef_MP4;\n\t\t\t\t} else if (ptr->desc->slConfig->predefined != SLPredef_MP4) {\n\t\t\t\t\tptr->desc->slConfig->predefined = SLPredef_MP4;\n\t\t\t\t\tgf_odf_slc_set_pref(ptr->desc->slConfig);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Box *esds_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ESDBox, GF_ISOM_BOX_TYPE_ESDS);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err esds_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tchar *enc_desc;\n\tu32 descSize = 0;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\te = gf_odf_desc_write((GF_Descriptor *)ptr->desc, &enc_desc, &descSize);\n\tif (e) return e;\n\tgf_bs_write_data(bs, enc_desc, descSize);\n\t//free our buffer\n\tgf_free(enc_desc);\n\treturn GF_OK;\n}\n\nGF_Err esds_Size(GF_Box *s)\n{\n\tu32 descSize = 0;\n\tGF_ESDBox *ptr = (GF_ESDBox *)s;\n\tdescSize = gf_odf_desc_size((GF_Descriptor *)ptr->desc);\n\tptr->size += descSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid free_del(GF_Box *s)\n{\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err free_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\n\tif (ptr->size > 0xFFFFFFFF) return GF_IO_ERR;\n\n\tbytesToRead = (u32) (ptr->size);\n\n\tif (bytesToRead) {\n\t\tptr->data = (char*)gf_malloc(bytesToRead * sizeof(char));\n\t\tgf_bs_read_data(bs, ptr->data, bytesToRead);\n\t\tptr->dataSize = bytesToRead;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *free_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FreeSpaceBox, GF_ISOM_BOX_TYPE_FREE);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err free_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tif (ptr->original_4cc) {\n\t\tu32 t = s->type;\n\t\ts->type=ptr->original_4cc;\n\t\te = gf_isom_box_write_header(s, bs);\n\t\ts->type=t;\n\t} else {\n\t\te = gf_isom_box_write_header(s, bs);\n\t}\n\tif (e) return e;\n\tif (ptr->dataSize)\t{\n\t\tif (ptr->data) {\n\t\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t\t} else {\n\t\t\tu32 i = 0;\n\t\t\twhile (i<ptr->dataSize) {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err free_Size(GF_Box *s)\n{\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ftyp_del(GF_Box *s)\n{\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *) s;\n\tif (ptr->altBrand) gf_free(ptr->altBrand);\n\tgf_free(ptr);\n}\n\nGF_Box *ftyp_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FileTypeBox, GF_ISOM_BOX_TYPE_FTYP);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err ftyp_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *)s;\n\n\tif (ptr->size < 8) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Found ftyp with size < 8, likely broken!\\n\"));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tptr->majorBrand = gf_bs_read_u32(bs);\n\tptr->minorVersion = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 8);\n\n\tptr->altCount = ( (u32) (ptr->size)) / 4;\n\tif (!ptr->altCount) return GF_OK;\n\tif (ptr->altCount * 4 != (u32) (ptr->size)) return GF_ISOM_INVALID_FILE;\n\n\tptr->altBrand = (u32*)gf_malloc(sizeof(u32)*ptr->altCount);\n\tfor (i = 0; i<ptr->altCount; i++) {\n\t\tptr->altBrand[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ftyp_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->majorBrand);\n\tgf_bs_write_u32(bs, ptr->minorVersion);\n\tfor (i=0; i<ptr->altCount; i++) {\n\t\tgf_bs_write_u32(bs, ptr->altBrand[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ftyp_Size(GF_Box *s)\n{\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *)s;\n\n\tptr->size += 8 + ptr->altCount * 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid gnrm_del(GF_Box *s)\n{\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnrm_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericSampleEntryBox, GF_ISOM_BOX_TYPE_GNRM);\n\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n//dummy\nGF_Err gnrm_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gnrm_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\n\t//carefull we are not writing the box type but the entry type so switch for write\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRM;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\treturn GF_OK;\n}\n\nGF_Err gnrm_Size(GF_Box *s)\n{\n\tGF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRM;\n\tptr->size += 8+ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid gnrv_del(GF_Box *s)\n{\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnrv_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericVisualSampleEntryBox, GF_ISOM_BOX_TYPE_GNRV);\n\tgf_isom_video_sample_entry_init((GF_VisualSampleEntryBox*) tmp);\n\treturn (GF_Box *)tmp;\n}\n//dummy\nGF_Err gnrv_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gnrv_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\n\t//carefull we are not writing the box type but the entry type so switch for write\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRV;\n\n\tgf_isom_video_sample_entry_write((GF_VisualSampleEntryBox *)ptr, bs);\n\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\treturn GF_OK;\n}\n\nGF_Err gnrv_Size(GF_Box *s)\n{\n\tGF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRV;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\tptr->size += ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid gnra_del(GF_Box *s)\n{\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)ptr);\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Box *gnra_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericAudioSampleEntryBox, GF_ISOM_BOX_TYPE_GNRA);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*) tmp);\n\treturn (GF_Box *)tmp;\n}\n//dummy\nGF_Err gnra_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err gnra_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\n\t//carefull we are not writing the box type but the entry type so switch for write\n\tptr->type = ptr->EntryType;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tptr->type = GF_ISOM_BOX_TYPE_GNRA;\n\n\tgf_isom_audio_sample_entry_write((GF_AudioSampleEntryBox *)ptr, bs);\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs,  ptr->data, ptr->data_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gnra_Size(GF_Box *s)\n{\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRA;\n\tgf_isom_audio_sample_entry_size((GF_AudioSampleEntryBox *)s);\n\tptr->size += ptr->data_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid hdlr_del(GF_Box *s)\n{\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->nameUTF8) gf_free(ptr->nameUTF8);\n\tgf_free(ptr);\n}\n\n\nGF_Err hdlr_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\n\tptr->reserved1 = gf_bs_read_u32(bs);\n\tptr->handlerType = gf_bs_read_u32(bs);\n\tgf_bs_read_data(bs, (char*)ptr->reserved2, 12);\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\n\tif (ptr->size) {\n\t\tsize_t len;\n\t\tptr->nameUTF8 = (char*)gf_malloc((u32) ptr->size);\n\t\tif (ptr->nameUTF8 == NULL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->nameUTF8, (u32) ptr->size);\n\t\t/*safety check in case the string is not null-terminated*/\n\t\tif (ptr->nameUTF8[ptr->size-1]) {\n\t\t\tchar *str = (char*)gf_malloc((u32) ptr->size + 1);\n\t\t\tmemcpy(str, ptr->nameUTF8, (u32) ptr->size);\n\t\t\tstr[ptr->size] = 0;\n\t\t\tgf_free(ptr->nameUTF8);\n\t\t\tptr->nameUTF8 = str;\n\t\t}\n\t\t//patch for old QT files\n\t\tif (ptr->size > 1 && ptr->nameUTF8[0] == ptr->size-1) {\n\t\t\tlen = strlen(ptr->nameUTF8 + 1);\n\t\t\tmemmove(ptr->nameUTF8, ptr->nameUTF8+1, len );\n\t\t\tptr->nameUTF8[len] = 0;\n\t\t\tptr->store_counted_string = GF_TRUE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *hdlr_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HandlerBox, GF_ISOM_BOX_TYPE_HDLR);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hdlr_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->reserved1);\n\tgf_bs_write_u32(bs, ptr->handlerType);\n\tgf_bs_write_data(bs, (char*)ptr->reserved2, 12);\n\n\tif (ptr->nameUTF8) {\n\t\tu32 len = (u32)strlen(ptr->nameUTF8);\n\t\tif (ptr->store_counted_string) {\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, ptr->nameUTF8, len);\n\t\t} else {\n\t\t\tgf_bs_write_data(bs, ptr->nameUTF8, len);\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err hdlr_Size(GF_Box *s)\n{\n\tGF_HandlerBox *ptr = (GF_HandlerBox *)s;\n\tptr->size += 20 + 1; //null term or counted string\n\tif (ptr->nameUTF8) {\n\t\tptr->size += strlen(ptr->nameUTF8);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid hinf_del(GF_Box *s)\n{\n\tGF_HintInfoBox *hinf = (GF_HintInfoBox *)s;\n\tgf_free(hinf);\n}\n\nGF_Box *hinf_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintInfoBox, GF_ISOM_BOX_TYPE_HINF);\n\n\ttmp->other_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err hinf_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MAXRBox *maxR;\n\tGF_HintInfoBox *hinf = (GF_HintInfoBox *)s;\n\tu32 i;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_MAXR:\n\t\ti=0;\n\t\twhile ((maxR = (GF_MAXRBox *)gf_list_enum(hinf->other_boxes, &i))) {\n\t\t\tif ((maxR->type==GF_ISOM_BOX_TYPE_MAXR) && (maxR->granularity == ((GF_MAXRBox *)a)->granularity))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tbreak;\n\t}\n\treturn gf_isom_box_add_default(s, a);\n}\n\n\nGF_Err hinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, hinf_AddBox);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hinf_Write(GF_Box *s, GF_BitStream *bs)\n{\n//\tGF_HintInfoBox *ptr = (GF_HintInfoBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err hinf_Size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid hmhd_del(GF_Box *s)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err hmhd_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\n\tptr->maxPDUSize = gf_bs_read_u16(bs);\n\tptr->avgPDUSize = gf_bs_read_u16(bs);\n\tptr->maxBitrate = gf_bs_read_u32(bs);\n\tptr->avgBitrate = gf_bs_read_u32(bs);\n\tptr->slidingAverageBitrate = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *hmhd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintMediaHeaderBox, GF_ISOM_BOX_TYPE_HMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err hmhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->maxPDUSize);\n\tgf_bs_write_u16(bs, ptr->avgPDUSize);\n\tgf_bs_write_u32(bs, ptr->maxBitrate);\n\tgf_bs_write_u32(bs, ptr->avgBitrate);\n\tgf_bs_write_u32(bs, ptr->slidingAverageBitrate);\n\treturn GF_OK;\n}\n\nGF_Err hmhd_Size(GF_Box *s)\n{\n\tGF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;\n\tptr->size += 16;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *hnti_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintTrackInfoBox, GF_ISOM_BOX_TYPE_HNTI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid hnti_del(GF_Box *a)\n{\n\tgf_free(a);\n}\n\nGF_Err hnti_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_HintTrackInfoBox *hnti = (GF_HintTrackInfoBox *)s;\n\tif (!hnti || !a) return GF_BAD_PARAM;\n\n\tswitch (a->type) {\n\t//this is the value for GF_RTPBox - same as HintSampleEntry for RTP !!!\n\tcase GF_ISOM_BOX_TYPE_RTP:\n\tcase GF_ISOM_BOX_TYPE_SDP:\n\t\tif (hnti->SDP) return GF_BAD_PARAM;\n\t\thnti->SDP = a;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn gf_isom_box_add_default(s, a);\n}\n\nGF_Err hnti_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(s, bs, hnti_AddBox, s->type);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err hnti_Write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\n\nGF_Err hnti_Size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tGF_SDPBox\n**********************************************************/\n\nvoid sdp_del(GF_Box *s)\n{\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr->sdpText) gf_free(ptr->sdpText);\n\tgf_free(ptr);\n\n}\nGF_Err sdp_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tlength = (u32) (ptr->size);\n\t//sdp text has no delimiter !!!\n\tptr->sdpText = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (!ptr->sdpText) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->sdpText, length);\n\tptr->sdpText[length] = 0;\n\treturn GF_OK;\n}\nGF_Box *sdp_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SDPBox, GF_ISOM_BOX_TYPE_SDP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sdp_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\t//don't write the NULL char!!!\n\tgf_bs_write_data(bs, ptr->sdpText, (u32) strlen(ptr->sdpText));\n\treturn GF_OK;\n}\nGF_Err sdp_Size(GF_Box *s)\n{\n\tGF_SDPBox *ptr = (GF_SDPBox *)s;\n\t//don't count the NULL char!!!\n\tptr->size += strlen(ptr->sdpText);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nvoid rtp_hnti_del(GF_Box *s)\n{\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr->sdpText) gf_free(ptr->sdpText);\n\tgf_free(ptr);\n\n}\nGF_Err rtp_hnti_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->subType = gf_bs_read_u32(bs);\n\n\tlength = (u32) (ptr->size);\n\t//sdp text has no delimiter !!!\n\tptr->sdpText = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (!ptr->sdpText) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->sdpText, length);\n\tptr->sdpText[length] = 0;\n\treturn GF_OK;\n}\n\nGF_Box *rtp_hnti_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RTPBox, GF_ISOM_BOX_TYPE_RTP);\n\ttmp->subType = GF_ISOM_BOX_TYPE_SDP;\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rtp_hnti_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->subType);\n\t//don't write the NULL char!!!\n\tgf_bs_write_data(bs, ptr->sdpText, (u32) strlen(ptr->sdpText));\n\treturn GF_OK;\n}\n\nGF_Err rtp_hnti_Size(GF_Box *s)\n{\n\tGF_RTPBox *ptr = (GF_RTPBox *)s;\n\tptr->size += 4 + strlen(ptr->sdpText);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTRPY GF_Box\n**********************************************************/\n\nvoid trpy_del(GF_Box *s)\n{\n\tgf_free((GF_TRPYBox *)s);\n}\nGF_Err trpy_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TRPYBox *ptr = (GF_TRPYBox *)s;\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *trpy_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TRPYBox, GF_ISOM_BOX_TYPE_TRPY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trpy_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TRPYBox *ptr = (GF_TRPYBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err trpy_Size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tTOTL GF_Box\n**********************************************************/\n\nvoid totl_del(GF_Box *s)\n{\n\tgf_free((GF_TRPYBox *)s);\n}\nGF_Err totl_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TOTLBox *ptr = (GF_TOTLBox *)s;\n\tptr->nbBytes = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *totl_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TOTLBox, GF_ISOM_BOX_TYPE_TOTL);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err totl_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TOTLBox *ptr = (GF_TOTLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err totl_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tNUMP GF_Box\n**********************************************************/\n\nvoid nump_del(GF_Box *s)\n{\n\tgf_free((GF_NUMPBox *)s);\n}\nGF_Err nump_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NUMPBox *ptr = (GF_NUMPBox *)s;\n\tptr->nbPackets = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *nump_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NUMPBox, GF_ISOM_BOX_TYPE_NUMP);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err nump_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NUMPBox *ptr = (GF_NUMPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbPackets);\n\treturn GF_OK;\n}\nGF_Err nump_Size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tNPCK GF_Box\n**********************************************************/\n\nvoid npck_del(GF_Box *s)\n{\n\tgf_free((GF_NPCKBox *)s);\n}\nGF_Err npck_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NPCKBox *ptr = (GF_NPCKBox *)s;\n\tptr->nbPackets = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *npck_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NPCKBox, GF_ISOM_BOX_TYPE_NPCK);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err npck_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NPCKBox *ptr = (GF_NPCKBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbPackets);\n\treturn GF_OK;\n}\nGF_Err npck_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTPYL GF_Box\n**********************************************************/\n\nvoid tpyl_del(GF_Box *s)\n{\n\tgf_free((GF_NTYLBox *)s);\n}\nGF_Err tpyl_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NTYLBox *ptr = (GF_NTYLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *tpyl_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NTYLBox, GF_ISOM_BOX_TYPE_TPYL);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tpyl_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NTYLBox *ptr = (GF_NTYLBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err tpyl_Size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tTPAY GF_Box\n**********************************************************/\n\nvoid tpay_del(GF_Box *s)\n{\n\tgf_free((GF_TPAYBox *)s);\n}\nGF_Err tpay_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TPAYBox *ptr = (GF_TPAYBox *)s;\n\tptr->nbBytes = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tpay_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TPAYBox, GF_ISOM_BOX_TYPE_TPAY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tpay_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TPAYBox *ptr = (GF_TPAYBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err tpay_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tMAXR GF_Box\n**********************************************************/\n\nvoid maxr_del(GF_Box *s)\n{\n\tgf_free((GF_MAXRBox *)s);\n}\nGF_Err maxr_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MAXRBox *ptr = (GF_MAXRBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tptr->granularity = gf_bs_read_u32(bs);\n\tptr->maxDataRate = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *maxr_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MAXRBox, GF_ISOM_BOX_TYPE_MAXR);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err maxr_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MAXRBox *ptr = (GF_MAXRBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->granularity);\n\tgf_bs_write_u32(bs, ptr->maxDataRate);\n\treturn GF_OK;\n}\nGF_Err maxr_Size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tDMED GF_Box\n**********************************************************/\n\nvoid dmed_del(GF_Box *s)\n{\n\tgf_free((GF_DMEDBox *)s);\n}\nGF_Err dmed_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DMEDBox *ptr = (GF_DMEDBox *)s;\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *dmed_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DMEDBox, GF_ISOM_BOX_TYPE_DMED);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dmed_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DMEDBox *ptr = (GF_DMEDBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err dmed_Size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tDIMM GF_Box\n**********************************************************/\n\nvoid dimm_del(GF_Box *s)\n{\n\tgf_free((GF_DIMMBox *)s);\n}\nGF_Err dimm_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMMBox *ptr = (GF_DIMMBox *)s;\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *dimm_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DIMMBox, GF_ISOM_BOX_TYPE_DIMM);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dimm_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DIMMBox *ptr = (GF_DIMMBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err dimm_Size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/**********************************************************\n\t\tDREP GF_Box\n**********************************************************/\n\nvoid drep_del(GF_Box *s)\n{\n\tgf_free((GF_DREPBox *)s);\n}\nGF_Err drep_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DREPBox *ptr = (GF_DREPBox *)s;\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\nGF_Box *drep_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DREPBox, GF_ISOM_BOX_TYPE_DREP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err drep_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DREPBox *ptr = (GF_DREPBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}\nGF_Err drep_Size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n/**********************************************************\n\t\tTMIN GF_Box\n**********************************************************/\n\nvoid tmin_del(GF_Box *s)\n{\n\tgf_free((GF_TMINBox *)s);\n}\nGF_Err tmin_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TMINBox *ptr = (GF_TMINBox *)s;\n\tptr->minTime = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tmin_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TMINBox, GF_ISOM_BOX_TYPE_TMIN);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tmin_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TMINBox *ptr = (GF_TMINBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->minTime);\n\treturn GF_OK;\n}\nGF_Err tmin_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tTMAX GF_Box\n**********************************************************/\n\nvoid tmax_del(GF_Box *s)\n{\n\tgf_free((GF_TMAXBox *)s);\n}\nGF_Err tmax_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TMAXBox *ptr = (GF_TMAXBox *)s;\n\tptr->maxTime = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *tmax_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TMAXBox, GF_ISOM_BOX_TYPE_TMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tmax_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TMAXBox *ptr = (GF_TMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxTime);\n\treturn GF_OK;\n}\nGF_Err tmax_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPMAX GF_Box\n**********************************************************/\n\nvoid pmax_del(GF_Box *s)\n{\n\tgf_free((GF_PMAXBox *)s);\n}\nGF_Err pmax_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PMAXBox *ptr = (GF_PMAXBox *)s;\n\tptr->maxSize = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *pmax_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PMAXBox, GF_ISOM_BOX_TYPE_PMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err pmax_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PMAXBox *ptr = (GF_PMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxSize);\n\treturn GF_OK;\n}\nGF_Err pmax_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tDMAX GF_Box\n**********************************************************/\n\nvoid dmax_del(GF_Box *s)\n{\n\tgf_free((GF_DMAXBox *)s);\n}\nGF_Err dmax_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DMAXBox *ptr = (GF_DMAXBox *)s;\n\tptr->maxDur = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *dmax_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DMAXBox, GF_ISOM_BOX_TYPE_DMAX);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dmax_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DMAXBox *ptr = (GF_DMAXBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->maxDur);\n\treturn GF_OK;\n}\nGF_Err dmax_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPAYT GF_Box\n**********************************************************/\n\nvoid payt_del(GF_Box *s)\n{\n\tGF_PAYTBox *payt = (GF_PAYTBox *)s;\n\tif (payt->payloadString) gf_free(payt->payloadString);\n\tgf_free(payt);\n}\nGF_Err payt_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\n\tptr->payloadCode = gf_bs_read_u32(bs);\n\tlength = gf_bs_read_u8(bs);\n\tptr->payloadString = (char*)gf_malloc(sizeof(char) * (length+1) );\n\tif (! ptr->payloadString) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->payloadString, length);\n\tptr->payloadString[length] = 0;\n\n\tISOM_DECREASE_SIZE(ptr, (4+length+1) );\n\treturn GF_OK;\n}\nGF_Box *payt_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PAYTBox, GF_ISOM_BOX_TYPE_PAYT);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err payt_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 len;\n\tGF_Err e;\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->payloadCode);\n\tlen = (u32) strlen(ptr->payloadString);\n\tgf_bs_write_u8(bs, len);\n\tif (len) gf_bs_write_data(bs, ptr->payloadString, len);\n\treturn GF_OK;\n}\nGF_Err payt_Size(GF_Box *s)\n{\n\tGF_PAYTBox *ptr = (GF_PAYTBox *)s;\n\ts->size += 4;\n\tif (ptr->payloadString) ptr->size += strlen(ptr->payloadString) + 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/**********************************************************\n\t\tPAYT GF_Box\n**********************************************************/\n\nvoid name_del(GF_Box *s)\n{\n\tGF_NameBox *name = (GF_NameBox *)s;\n\tif (name->string) gf_free(name->string);\n\tgf_free(name);\n}\nGF_Err name_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 length;\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\n\tlength = (u32) (ptr->size);\n\tptr->string = (char*)gf_malloc(sizeof(char) * (length+1));\n\tif (! ptr->string) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, ptr->string, length);\n\tptr->string[length] = 0;\n\treturn GF_OK;\n}\nGF_Box *name_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NameBox, GF_ISOM_BOX_TYPE_NAME);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err name_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->string) {\n\t\tgf_bs_write_data(bs, ptr->string, (u32) strlen(ptr->string) + 1);\n\t}\n\treturn GF_OK;\n}\nGF_Err name_Size(GF_Box *s)\n{\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\tif (ptr->string) ptr->size += strlen(ptr->string) + 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tssy_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err tssy_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TimeStampSynchronyBox *ptr = (GF_TimeStampSynchronyBox *)s;\n\tgf_bs_read_int(bs, 6);\n\tptr->timestamp_sync = gf_bs_read_int(bs, 2);\n\treturn GF_OK;\n}\nGF_Box *tssy_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeStampSynchronyBox, GF_ISOM_BOX_TYPE_TSSY);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tssy_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TimeStampSynchronyBox *ptr = (GF_TimeStampSynchronyBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, 0, 6);\n\tgf_bs_write_int(bs, ptr->timestamp_sync, 2);\n\treturn GF_OK;\n}\nGF_Err tssy_Size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid srpp_del(GF_Box *s)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tif (ptr->info) gf_isom_box_del((GF_Box*)ptr->info);\n\tif (ptr->scheme_type) gf_isom_box_del((GF_Box*)ptr->scheme_type);\n\tgf_free(s);\n}\n\nGF_Err srpp_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_SCHI:\n\t\tif (ptr->info) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->info = (GF_SchemeInformationBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SCHM:\n\t\tif (ptr->scheme_type) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->scheme_type = (GF_SchemeTypeBox *)a;\n\t\treturn GF_OK;\n\t}\n\treturn gf_isom_box_add_default(s, a);\n}\n\nGF_Err srpp_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 16)\n\tptr->encryption_algorithm_rtp = gf_bs_read_u32(bs);\n\tptr->encryption_algorithm_rtcp = gf_bs_read_u32(bs);\n\tptr->integrity_algorithm_rtp = gf_bs_read_u32(bs);\n\tptr->integrity_algorithm_rtp = gf_bs_read_u32(bs);\n\treturn gf_isom_box_array_read(s, bs, gf_isom_box_add_default);\n}\nGF_Box *srpp_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SRTPProcessBox, GF_ISOM_BOX_TYPE_SRPP);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err srpp_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->encryption_algorithm_rtp);\n\tgf_bs_write_u32(bs, ptr->encryption_algorithm_rtcp);\n\tgf_bs_write_u32(bs, ptr->integrity_algorithm_rtp);\n\tgf_bs_write_u32(bs, ptr->integrity_algorithm_rtcp);\n\tif (ptr->info) {\n\t\te = gf_isom_box_write((GF_Box*)ptr->info, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->scheme_type) {\n\t\te = gf_isom_box_write((GF_Box*)ptr->scheme_type, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\nGF_Err srpp_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\n\ts->size += 16;\n\tif (ptr->info) {\n\t\te = gf_isom_box_size((GF_Box*)ptr->info);\n\t\tif (e) return e;\n\t\tptr->size += ptr->info->size;\n\t}\n\tif (ptr->scheme_type) {\n\t\te = gf_isom_box_size((GF_Box*)ptr->scheme_type);\n\t\tif (e) return e;\n\t\tptr->size += ptr->scheme_type->size;\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid rssr_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err rssr_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ReceivedSsrcBox *ptr = (GF_ReceivedSsrcBox *)s;\n\tptr->ssrc = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\nGF_Box *rssr_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ReceivedSsrcBox, GF_ISOM_BOX_TYPE_RSSR);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rssr_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ReceivedSsrcBox *ptr = (GF_ReceivedSsrcBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->ssrc);\n\treturn GF_OK;\n}\nGF_Err rssr_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nvoid iods_del(GF_Box *s)\n{\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->descriptor) gf_odf_desc_del(ptr->descriptor);\n\tgf_free(ptr);\n}\n\n\nGF_Err iods_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 descSize;\n\tchar *desc;\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\n\t//use the OD codec...\n\tdescSize = (u32) (ptr->size);\n\tdesc = (char*)gf_malloc(sizeof(char) * descSize);\n\tgf_bs_read_data(bs, desc, descSize);\n\te = gf_odf_desc_read(desc, descSize, &ptr->descriptor);\n\t//OK, free our desc\n\tgf_free(desc);\n\treturn e;\n}\n\nGF_Box *iods_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ObjectDescriptorBox, GF_ISOM_BOX_TYPE_IODS);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err iods_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 descSize;\n\tchar *desc;\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//call our OD codec\n\te = gf_odf_desc_write(ptr->descriptor, &desc, &descSize);\n\tif (e) return e;\n\tgf_bs_write_data(bs, desc, descSize);\n\t//and free our stuff maybe!!\n\tgf_free(desc);\n\treturn GF_OK;\n}\n\nGF_Err iods_Size(GF_Box *s)\n{\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\n\tptr->size += gf_odf_desc_size(ptr->descriptor);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mdat_del(GF_Box *s)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tif (!s) return;\n\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\n\nGF_Err mdat_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tptr->dataSize = s->size;\n\tptr->bsOffset = gf_bs_get_position(bs);\n\n\t//then skip these bytes\n\tgf_bs_skip_bytes(bs, ptr->dataSize);\n\treturn GF_OK;\n}\n\nGF_Box *mdat_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaDataBox, GF_ISOM_BOX_TYPE_MDAT);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdat_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\t//make sure we have some data ...\n\t//if not, we handle that independantly (edit files)\n\tif (ptr->data) {\n\t\tgf_bs_write_data(bs, ptr->data, (u32) ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mdat_Size(GF_Box *s)\n{\n\tGF_MediaDataBox *ptr = (GF_MediaDataBox *)s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mdhd_del(GF_Box *s)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err mdhd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\n\tif (ptr->version == 1) {\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tif (!ptr->timeScale) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Media header timescale is 0 - defaulting to 90000\\n\" ));\n\t\tptr->timeScale = 90000;\n\t}\n\n\tptr->original_duration = ptr->duration;\n\n\t//our padding bit\n\tgf_bs_read_int(bs, 1);\n\t//the spec is unclear here, just says \"the value 0 is interpreted as undetermined\"\n\tptr->packedLanguage[0] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguage[1] = gf_bs_read_int(bs, 5);\n\tptr->packedLanguage[2] = gf_bs_read_int(bs, 5);\n\t//but before or after compaction ?? We assume before\n\tif (ptr->packedLanguage[0] || ptr->packedLanguage[1] || ptr->packedLanguage[2]) {\n\t\tptr->packedLanguage[0] += 0x60;\n\t\tptr->packedLanguage[1] += 0x60;\n\t\tptr->packedLanguage[2] += 0x60;\n\t} else {\n\t\tptr->packedLanguage[0] = 'u';\n\t\tptr->packedLanguage[1] = 'n';\n\t\tptr->packedLanguage[2] = 'd';\n\t}\n\tptr->reserved = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\nGF_Box *mdhd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaHeaderBox, GF_ISOM_BOX_TYPE_MDHD);\n\n\ttmp->packedLanguage[0] = 'u';\n\ttmp->packedLanguage[1] = 'n';\n\ttmp->packedLanguage[2] = 'd';\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\t//SPECS: BIT(1) of padding\n\tgf_bs_write_int(bs, 0, 1);\n\tgf_bs_write_int(bs, ptr->packedLanguage[0] - 0x60, 5);\n\tgf_bs_write_int(bs, ptr->packedLanguage[1] - 0x60, 5);\n\tgf_bs_write_int(bs, ptr->packedLanguage[2] - 0x60, 5);\n\tgf_bs_write_u16(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err mdhd_Size(GF_Box *s)\n{\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\tptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\n\tptr->size += 4;\n\tptr->size += (ptr->version == 1) ? 28 : 16;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid mdia_del(GF_Box *s)\n{\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->mediaHeader) gf_isom_box_del((GF_Box *)ptr->mediaHeader);\n\tif (ptr->information) gf_isom_box_del((GF_Box *)ptr->information);\n\tif (ptr->handler) gf_isom_box_del((GF_Box *)ptr->handler);\n\tgf_free(ptr);\n}\n\n\nGF_Err mdia_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_MDHD:\n\t\tif (ptr->mediaHeader) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\n\t\t\tptr->mediaHeader = (GF_MediaHeaderBox *)a;\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_HDLR:\n\t\tif (ptr->handler) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\n\t\t\tptr->handler = (GF_HandlerBox *)a;\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_MINF:\n\t\tif (ptr->information) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\n\t\t\tptr->information = (GF_MediaInformationBox *)a;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err mdia_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, mdia_AddBox);\n\tif (e) return e;\n\tif (!((GF_MediaBox *)s)->information) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaInformationBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->handler) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing HandlerBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->mediaHeader) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaHeaderBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *mdia_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaBox, GF_ISOM_BOX_TYPE_MDIA);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mdia_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\t//Header first\n\tif (ptr->mediaHeader) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->mediaHeader, bs);\n\t\tif (e) return e;\n\t}\n\t//then handler\n\tif (ptr->handler) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->handler, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->information) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->information, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mdia_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\n\tif (ptr->mediaHeader) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->mediaHeader);\n\t\tif (e) return e;\n\t\tptr->size += ptr->mediaHeader->size;\n\t}\n\tif (ptr->handler) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->handler);\n\t\tif (e) return e;\n\t\tptr->size += ptr->handler->size;\n\t}\n\tif (ptr->information) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->information);\n\t\tif (e) return e;\n\t\tptr->size += ptr->information->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid mfra_del(GF_Box *s)\n{\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->mfro) gf_isom_box_del((GF_Box*)ptr->mfro);\n\tgf_isom_box_array_del(ptr->tfra_list);\n\tgf_free(ptr);\n}\n\nGF_Box *mfra_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentRandomAccessBox, GF_ISOM_BOX_TYPE_MFRA);\n\ttmp->tfra_list = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err mfra_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_TFRA:\n\t\treturn gf_list_add(ptr->tfra_list, a);\n\tcase GF_ISOM_BOX_TYPE_MFRO:\n\t\tif (ptr->mfro) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->mfro = (GF_MovieFragmentRandomAccessOffsetBox *)a;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mfra_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, mfra_AddBox);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mfra_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\te = gf_isom_box_array_write(s, ptr->tfra_list, bs);\n\tif (e) return e;\n\tif (ptr->mfro) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->mfro, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mfra_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\n\tif (ptr->mfro) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->mfro);\n\t\tif (e) return e;\n\t\tptr->size += ptr->mfro->size;\n\t}\n\treturn gf_isom_box_array_size(s, ptr->tfra_list);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tfra_del(GF_Box *s)\n{\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Box *tfra_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentRandomAccessBox, GF_ISOM_BOX_TYPE_TFRA);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err tfra_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_RandomAccessEntry *p = 0;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\n\tif (ptr->size<12) return GF_ISOM_INVALID_FILE;\n\n\tptr->track_id = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tif (gf_bs_read_int(bs, 26) !=0) return GF_ISOM_INVALID_FILE;\n\tptr->traf_bits = (gf_bs_read_int(bs, 2)+1)*8;\n\tptr->trun_bits = (gf_bs_read_int(bs, 2)+1)*8;\n\tptr->sample_bits = (gf_bs_read_int(bs, 2)+1)*8;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tif (ptr->version==1) {\n\t\tif (ptr->nb_entries > ptr->size / (16+(ptr->traf_bits+ptr->trun_bits+ptr->sample_bits)/8)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t} else {\n\t\tif (ptr->nb_entries > ptr->size / (8+(ptr->traf_bits+ptr->trun_bits+ptr->sample_bits)/8)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in traf\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n\tif (ptr->nb_entries)\n\t{\n\t\tp = (GF_RandomAccessEntry *) gf_malloc(sizeof(GF_RandomAccessEntry) * ptr->nb_entries);\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t}\n\n\tptr->entries = p;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tmemset(p, 0, sizeof(GF_RandomAccessEntry));\n\n\t\tif (ptr->version==1) {\n\t\t\tp->time = gf_bs_read_u64(bs);\n\t\t\tp->moof_offset = gf_bs_read_u64(bs);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp->time = gf_bs_read_u32(bs);\n\t\t\tp->moof_offset = gf_bs_read_u32(bs);\n\t\t}\n\t\tp->traf_number = gf_bs_read_int(bs, ptr->traf_bits);\n\t\tp->trun_number = gf_bs_read_int(bs, ptr->trun_bits);\n\t\tp->sample_number = gf_bs_read_int(bs, ptr->sample_bits);\n\n\t\t++p;\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfra_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->track_id);\n\tgf_bs_write_int(bs, 0, 26);\n\n\tgf_bs_write_int(bs, ptr->traf_bits/8 - 1, 2);\n\tgf_bs_write_int(bs, ptr->trun_bits/8 - 1, 2);\n\tgf_bs_write_int(bs, ptr->sample_bits/8 - 1, 2);\n\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tGF_RandomAccessEntry *p = &ptr->entries[i];\n\t\tif (ptr->version==1) {\n\t\t\tgf_bs_write_u64(bs, p->time);\n\t\t\tgf_bs_write_u64(bs, p->moof_offset);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) p->time);\n\t\t\tgf_bs_write_u32(bs, (u32) p->moof_offset);\n\t\t}\n\t\tgf_bs_write_int(bs, p->traf_number, ptr->traf_bits);\n\t\tgf_bs_write_int(bs, p->trun_number, ptr->trun_bits);\n\t\tgf_bs_write_int(bs, p->sample_number, ptr->sample_bits);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfra_Size(GF_Box *s)\n{\n\tGF_TrackFragmentRandomAccessBox *ptr = (GF_TrackFragmentRandomAccessBox *)s;\n\n\tptr->size += 12;\n\n\tptr->size += ptr->nb_entries * ( ((ptr->version==1) ? 16 : 8 ) + ptr->traf_bits/8 + ptr->trun_bits/8 + ptr->sample_bits/8);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid mfro_del(GF_Box *s)\n{\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Box *mfro_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentRandomAccessOffsetBox, GF_ISOM_BOX_TYPE_MFRO);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Err mfro_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\n\tptr->container_size = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mfro_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieFragmentRandomAccessOffsetBox *ptr = (GF_MovieFragmentRandomAccessOffsetBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->container_size);\n\treturn GF_OK;\n}\n\nGF_Err mfro_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid elng_del(GF_Box *s)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->extended_language) gf_free(ptr->extended_language);\n\tgf_free(ptr);\n}\n\nGF_Err elng_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\n\tif (ptr->size) {\n\t\tptr->extended_language = (char*)gf_malloc((u32) ptr->size);\n\t\tif (ptr->extended_language == NULL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->extended_language, (u32) ptr->size);\n\t\t/*safety check in case the string is not null-terminated*/\n\t\tif (ptr->extended_language[ptr->size-1]) {\n\t\t\tchar *str = (char*)gf_malloc((u32) ptr->size + 1);\n\t\t\tmemcpy(str, ptr->extended_language, (u32) ptr->size);\n\t\t\tstr[ptr->size] = 0;\n\t\t\tgf_free(ptr->extended_language);\n\t\t\tptr->extended_language = str;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *elng_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaBox, GF_ISOM_BOX_TYPE_ELNG);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err elng_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->extended_language) {\n\t\tgf_bs_write_data(bs, ptr->extended_language, (u32)(strlen(ptr->extended_language)+1));\n\t}\n\treturn GF_OK;\n}\n\nGF_Err elng_Size(GF_Box *s)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\n\tif (ptr->extended_language) {\n\t\tptr->size += strlen(ptr->extended_language)+1;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid mfhd_del(GF_Box *s)\n{\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err mfhd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *)s;\n\tptr->sequence_number = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *mfhd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentHeaderBox, GF_ISOM_BOX_TYPE_MFHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err mfhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieFragmentHeaderBox *ptr = (GF_MovieFragmentHeaderBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->sequence_number);\n\treturn GF_OK;\n}\n\nGF_Err mfhd_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid minf_del(GF_Box *s)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tif (ptr == NULL) return;\n\n\t//if we have a Handler not self-contained, delete it (the self-contained belongs to the movie)\n\tif (ptr->dataHandler) {\n\t\tgf_isom_datamap_close(ptr);\n\t}\n\tif (ptr->InfoHeader) gf_isom_box_del((GF_Box *)ptr->InfoHeader);\n\tif (ptr->dataInformation) gf_isom_box_del((GF_Box *)ptr->dataInformation);\n\tif (ptr->sampleTable) gf_isom_box_del((GF_Box *)ptr->sampleTable);\n\tgf_free(ptr);\n}\n\nGF_Err minf_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_NMHD:\n\tcase GF_ISOM_BOX_TYPE_STHD:\n\tcase GF_ISOM_BOX_TYPE_VMHD:\n\tcase GF_ISOM_BOX_TYPE_SMHD:\n\tcase GF_ISOM_BOX_TYPE_HMHD:\n\tcase GF_ISOM_BOX_TYPE_GMHD:\n\t\tif (ptr->InfoHeader) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->InfoHeader = a;\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_DINF:\n\t\tif (ptr->dataInformation) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->dataInformation = (GF_DataInformationBox *)a;\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_STBL:\n\t\tif (ptr->sampleTable ) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->sampleTable = (GF_SampleTableBox *)a;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err minf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tGF_Err e;\n\te = gf_isom_box_array_read(s, bs, minf_AddBox);\n\tif (! ptr->dataInformation) {\n\t\tGF_Box *dinf, *dref, *url;\n\t\tBool dump_mode = GF_FALSE;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing DataInformationBox\\n\"));\n\t\t//commented on purpose, we are still able to handle the file, we only throw an error but keep processing\n//\t\te = GF_ISOM_INVALID_FILE;\n\n\t\t//add a dinf box to avoid any access to a null dinf\n\t\tdinf = gf_isom_box_new(GF_ISOM_BOX_TYPE_DINF);\n\t\tif (!dinf) return GF_OUT_OF_MEM;\n\t\tif (ptr->InfoHeader && gf_list_find(ptr->other_boxes, ptr->InfoHeader)>=0) dump_mode = GF_TRUE;\n\t\tif (ptr->sampleTable && gf_list_find(ptr->other_boxes, ptr->sampleTable)>=0) dump_mode = GF_TRUE;\n\n\t\tptr->dataInformation = (GF_DataInformationBox *)dinf;\n\n\t\tdref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n\t\tif (!dref) return GF_OUT_OF_MEM;\n\t\te = dinf_AddBox(dinf, dref);\n\n\t\turl = gf_isom_box_new(GF_ISOM_BOX_TYPE_URL);\n\t\tif (!url) return GF_OUT_OF_MEM;\n\t\t((GF_FullBox*)url)->flags = 1;\n\t\te = gf_isom_box_add_default(dref, url);\n\n\t\tif (dump_mode) {\n\t\t\tgf_list_add(ptr->other_boxes, ptr->dataInformation);\n\t\t\tif (!dinf->other_boxes) dinf->other_boxes = gf_list_new();\n\t\t\tgf_list_add(dinf->other_boxes, dref);\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Box *minf_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MediaInformationBox, GF_ISOM_BOX_TYPE_MINF);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err minf_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\t//Header first\n\tif (ptr->InfoHeader) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->InfoHeader, bs);\n\t\tif (e) return e;\n\t}\n\t//then dataInfo\n\tif (ptr->dataInformation) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->dataInformation, bs);\n\t\tif (e) return e;\n\t}\n\t//then sampleTable\n\tif (ptr->sampleTable) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->sampleTable, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err minf_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\n\tif (ptr->InfoHeader) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->InfoHeader);\n\t\tif (e) return e;\n\t\tptr->size += ptr->InfoHeader->size;\n\t}\n\tif (ptr->dataInformation) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->dataInformation);\n\t\tif (e) return e;\n\t\tptr->size += ptr->dataInformation->size;\n\t}\n\tif (ptr->sampleTable) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->sampleTable);\n\t\tif (e) return e;\n\t\tptr->size += ptr->sampleTable->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid moof_del(GF_Box *s)\n{\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->mfhd) gf_isom_box_del((GF_Box *) ptr->mfhd);\n\tgf_isom_box_array_del(ptr->TrackList);\n\tif (ptr->mdat) gf_free(ptr->mdat);\n\tgf_free(ptr);\n}\n\nGF_Err moof_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_MFHD:\n\t\tif (ptr->mfhd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\n\t\t\tptr->mfhd = (GF_MovieFragmentHeaderBox *) a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRAF:\n\t\treturn gf_list_add(ptr->TrackList, a);\n\tcase GF_ISOM_BOX_TYPE_PSSH:\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n}\n\nGF_Err moof_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, moof_AddBox);\n}\n\nGF_Box *moof_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieFragmentBox, GF_ISOM_BOX_TYPE_MOOF);\n\ttmp->TrackList = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err moof_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\t//Header First\n\tif (ptr->mfhd) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->mfhd, bs);\n\t\tif (e) return e;\n\t}\n//then the track list\nreturn gf_isom_box_array_write(s, ptr->TrackList, bs);\n}\n\nGF_Err moof_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\n\tif (ptr->mfhd) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->mfhd);\n\t\tif (e) return e;\n\t\tptr->size += ptr->mfhd->size;\n\t}\n\treturn gf_isom_box_array_size(s, ptr->TrackList);\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\nvoid moov_del(GF_Box *s)\n{\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->mvhd) gf_isom_box_del((GF_Box *)ptr->mvhd);\n\tif (ptr->meta) gf_isom_box_del((GF_Box *)ptr->meta);\n\tif (ptr->iods) gf_isom_box_del((GF_Box *)ptr->iods);\n\tif (ptr->udta) gf_isom_box_del((GF_Box *)ptr->udta);\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ptr->mvex) gf_isom_box_del((GF_Box *)ptr->mvex);\n#endif\n\n\tgf_isom_box_array_del(ptr->trackList);\n\tgf_free(ptr);\n}\n\n\nGF_Err moov_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_IODS:\n\t\tif (ptr->iods) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->iods = (GF_ObjectDescriptorBox *)a;\n\t\t//if no IOD, delete the box\n\t\tif (!ptr->iods->descriptor) {\n\t\t\tptr->iods = NULL;\n\t\t\tgf_isom_box_del(a);\n\t\t}\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_MVHD:\n\t\tif (ptr->mvhd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->mvhd = (GF_MovieHeaderBox *)a;\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\tif (ptr->udta) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->udta = (GF_UserDataBox *)a;\n\t\treturn GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tcase GF_ISOM_BOX_TYPE_MVEX:\n\t\tif (ptr->mvex) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->mvex = (GF_MovieExtendsBox *)a;\n\t\tptr->mvex->mov = ptr->mov;\n\t\treturn GF_OK;\n#endif\n\n\tcase GF_ISOM_BOX_TYPE_META:\n\t\tif (ptr->meta) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->meta = (GF_MetaBox *)a;\n\t\treturn GF_OK;\n\n\tcase GF_ISOM_BOX_TYPE_TRAK:\n\t\t//set our pointer to this obj\n\t\t((GF_TrackBox *)a)->moov = ptr;\n\t\treturn gf_list_add(ptr->trackList, a);\n\tcase GF_ISOM_BOX_TYPE_PSSH:\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n}\n\n\nGF_Err moov_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\te = gf_isom_box_array_read(s, bs, moov_AddBox);\n\tif (e) {\n\t\treturn e;\n\t}\n\telse {\n\t\tif (!((GF_MovieBox *)s)->mvhd) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MovieHeaderBox\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Box *moov_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieBox, GF_ISOM_BOX_TYPE_MOOV);\n\ttmp->trackList = gf_list_new();\n\tif (!tmp->trackList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err moov_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tif (ptr->mvhd) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->mvhd, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->iods) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->iods, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->meta) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->meta, bs);\n\t\tif (e) return e;\n\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ptr->mvex) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->mvex, bs);\n\t\tif (e) return e;\n\t}\n#endif\n\n\te = gf_isom_box_array_write(s, ptr->trackList, bs);\n\tif (e) return e;\n\n\tif (ptr->udta) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->udta, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err moov_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\n\tif (ptr->mvhd) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->mvhd);\n\t\tif (e) return e;\n\t\tptr->size += ptr->mvhd->size;\n\t}\n\tif (ptr->iods) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->iods);\n\t\tif (e) return e;\n\t\tptr->size += ptr->iods->size;\n\t}\n\tif (ptr->udta) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->udta);\n\t\tif (e) return e;\n\t\tptr->size += ptr->udta->size;\n\t}\n\tif (ptr->meta) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->meta);\n\t\tif (e) return e;\n\t\tptr->size += ptr->meta->size;\n\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ptr->mvex) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->mvex);\n\t\tif (e) return e;\n\t\tptr->size += ptr->mvex->size;\n\t}\n#endif\n\n\treturn gf_isom_box_array_size(s, ptr->trackList);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid audio_sample_entry_del(GF_Box *s)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->esd) gf_isom_box_del((GF_Box *)ptr->esd);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tif (ptr->cfg_ac3) gf_isom_box_del((GF_Box *)ptr->cfg_ac3);\n\tif (ptr->cfg_3gpp) gf_isom_box_del((GF_Box *)ptr->cfg_3gpp);\n\tgf_free(ptr);\n}\n\nGF_Err audio_sample_entry_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tif (ptr->esd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->esd = (GF_ESDBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SINF:\n\t\tgf_list_add(ptr->protections, a);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DAMR:\n\tcase GF_ISOM_BOX_TYPE_DEVC:\n\tcase GF_ISOM_BOX_TYPE_DQCP:\n\tcase GF_ISOM_BOX_TYPE_DSMV:\n\t\tptr->cfg_3gpp = (GF_3GPPConfigBox *) a;\n\t\t/*for 3GP config, remember sample entry type in config*/\n\t\tptr->cfg_3gpp->cfg.type = ptr->type;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_DAC3:\n\t\tptr->cfg_ac3 = (GF_AC3ConfigBox *) a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DEC3:\n\t\tptr->cfg_ac3 = (GF_AC3ConfigBox *) a;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\tif (ptr->esd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\t/*HACK for QT files: get the esds box from the track*/\n\t\t{\n\t\t\tGF_UnknownBox *wave = (GF_UnknownBox *)a;\n\t\t\t//wave subboxes may have been properly parsed\n \t\t\tif ((wave->original_4cc == GF_ISOM_BOX_TYPE_WAVE) && gf_list_count(wave->other_boxes)) {\n \t\t\t\tu32 i;\n                for (i =0; i<gf_list_count(wave->other_boxes); i++) {\n                    GF_Box *inner_box = (GF_Box *)gf_list_get(wave->other_boxes, i);\n                    if (inner_box->type == GF_ISOM_BOX_TYPE_ESDS) {\n                        ptr->esd = (GF_ESDBox *)inner_box;\n                    }\n                }\n                return gf_isom_box_add_default(s, a);\n            }\n            //unknown fomat, look for 'es' (esds) and try to parse box\n            else if (wave->data != NULL) {\n                u32 offset = 0;\n                while ((wave->data[offset + 4] != 'e') && (wave->data[offset + 5] != 's')) {\n                    offset++;\n                    if (offset == wave->dataSize) break;\n                }\n                if (offset < wave->dataSize) {\n                    GF_Box *a;\n                    GF_Err e;\n                    GF_BitStream *bs = gf_bs_new(wave->data + offset, wave->dataSize - offset, GF_BITSTREAM_READ);\n                    e = gf_isom_box_parse(&a, bs);\n                    gf_bs_del(bs);\n                    if (e) return e;\n                    ptr->esd = (GF_ESDBox *)a;\n                    gf_isom_box_add_for_dump_mode((GF_Box *)ptr, a);\n\n                }\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Cannot process box %s!\\n\", gf_4cc_to_str(wave->original_4cc)));\n\t\t\t\treturn gf_isom_box_add_default(s, a);\n\t\t\t}\n\t\t\tgf_isom_box_del(a);\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\nGF_Err audio_sample_entry_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr;\n\tchar *data;\n\tu32 i, size;\n\tGF_Err e;\n\tu64 pos;\n\n\te = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs);\n\tsize = (u32) s->size;\n\n\te = gf_isom_box_array_read(s, bs, audio_sample_entry_AddBox);\n\tif (!e) return GF_OK;\n\tif (size<8) return GF_ISOM_INVALID_FILE;\n\n\t/*hack for some weird files (possibly recorded with live.com tools, needs further investigations)*/\n\tptr = (GF_MPEGAudioSampleEntryBox *)s;\n\tgf_bs_seek(bs, pos);\n\tdata = (char*)gf_malloc(sizeof(char) * size);\n\tgf_bs_read_data(bs, data, size);\n\tfor (i=0; i<size-8; i++) {\n\t\tif (GF_4CC(data[i+4], data[i+5], data[i+6], data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {\n\t\t\tGF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);\n\t\t\te = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);\n\t\t\tgf_bs_del(mybs);\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}\n\nGF_Box *audio_sample_entry_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGAudioSampleEntryBox, GF_ISOM_BOX_TYPE_MP4A);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *enca_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGAudioSampleEntryBox, GF_ISOM_BOX_TYPE_ENCA);\n\tgf_isom_audio_sample_entry_init((GF_AudioSampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err audio_sample_entry_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_isom_audio_sample_entry_write((GF_AudioSampleEntryBox*)s, bs);\n\tif (ptr->esd) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->esd, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->cfg_3gpp) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->cfg_3gpp, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->cfg_ac3) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->cfg_ac3, bs);\n\t\tif (e) return e;\n\t}\n\treturn gf_isom_box_array_write(s, ptr->protections, bs);\n}\n\nGF_Err audio_sample_entry_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tgf_isom_audio_sample_entry_size((GF_AudioSampleEntryBox*)s);\n\tif (ptr->esd) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->esd);\n\t\tif (e) return e;\n\t\tptr->size += ptr->esd->size;\n\t}\n\tif (ptr->cfg_3gpp) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->cfg_3gpp);\n\t\tif (e) return e;\n\t\tptr->size += ptr->cfg_3gpp->size;\n\t}\n\tif (ptr->cfg_ac3) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->cfg_ac3);\n\t\tif (e) return e;\n\t\tptr->size += ptr->cfg_ac3->size;\n\t}\n\treturn gf_isom_box_array_size(s, ptr->protections);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid mp4s_del(GF_Box *s)\n{\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->esd) gf_isom_box_del((GF_Box *)ptr->esd);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tgf_free(ptr);\n}\n\nGF_Err mp4s_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tif (ptr->esd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->esd = (GF_ESDBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SINF:\n\t\tgf_list_add(ptr->protections, a);\n\t\tbreak;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err mp4s_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\treturn gf_isom_box_array_read(s, bs, mp4s_AddBox);\n}\n\nGF_Box *mp4s_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_MP4S);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *encs_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_ENCS);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mp4s_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\te = gf_isom_box_write((GF_Box *)ptr->esd, bs);\n\tif (e) return e;\n\treturn gf_isom_box_array_write(s, ptr->protections, bs);\n}\n\nGF_Err mp4s_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MPEGSampleEntryBox *ptr = (GF_MPEGSampleEntryBox *)s;\n\n\tptr->size += 8;\n\te = gf_isom_box_size((GF_Box *)ptr->esd);\n\tif (e) return e;\n\tptr->size += ptr->esd->size;\n\treturn gf_isom_box_array_size(s, ptr->protections);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid video_sample_entry_del(GF_Box *s)\n{\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->esd) gf_isom_box_del((GF_Box *)ptr->esd);\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\t/*for publishing*/\n\tif (ptr->emul_esd) gf_odf_desc_del((GF_Descriptor *)ptr->emul_esd);\n\n\tif (ptr->avc_config) gf_isom_box_del((GF_Box *) ptr->avc_config);\n\tif (ptr->svc_config) gf_isom_box_del((GF_Box *) ptr->svc_config);\n\tif (ptr->mvc_config) gf_isom_box_del((GF_Box *) ptr->mvc_config);\n\tif (ptr->hevc_config) gf_isom_box_del((GF_Box *) ptr->hevc_config);\n\tif (ptr->lhvc_config) gf_isom_box_del((GF_Box *) ptr->lhvc_config);\n\tif (ptr->cfg_3gpp) gf_isom_box_del((GF_Box *)ptr->cfg_3gpp);\n\n\tif (ptr->descr) gf_isom_box_del((GF_Box *) ptr->descr);\n\tif (ptr->ipod_ext) gf_isom_box_del((GF_Box *)ptr->ipod_ext);\n\n\tif (ptr->pasp) gf_isom_box_del((GF_Box *)ptr->pasp);\n\tif (ptr->clap) gf_isom_box_del((GF_Box *)ptr->clap);\n\tif (ptr->rinf) gf_isom_box_del((GF_Box *)ptr->rinf);\n\n\tif (ptr->rvcc) gf_isom_box_del((GF_Box *)ptr->rvcc);\n\n\tgf_free(ptr);\n}\n\nGF_Err video_sample_entry_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\tif (ptr->esd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->esd = (GF_ESDBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SINF:\n\t\tgf_list_add(ptr->protections, a);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_RINF:\n\t\tif (ptr->rinf) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->rinf = (GF_RestrictedSchemeInfoBox *) a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVCC:\n\t\tif (ptr->avc_config) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->avc_config = (GF_AVCConfigurationBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_HVCC:\n\t\tif (ptr->hevc_config) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->hevc_config = (GF_HEVCConfigurationBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SVCC:\n\t\tif (ptr->svc_config) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->svc_config = (GF_AVCConfigurationBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MVCC:\n\t\tif (ptr->mvc_config) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->mvc_config = (GF_AVCConfigurationBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_LHVC:\n\t\tif (ptr->lhvc_config) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->lhvc_config = (GF_HEVCConfigurationBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_M4DS:\n\t\tif (ptr->descr) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->descr = (GF_MPEG4ExtensionDescriptorsBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif (! memcmp(((GF_UnknownUUIDBox*)a)->uuid, GF_ISOM_IPOD_EXT, 16)) {\n\t\t\tif (ptr->ipod_ext) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->ipod_ext = (GF_UnknownUUIDBox *)a;\n\t\t} else {\n\t\t\treturn gf_isom_box_add_default(s, a);\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_D263:\n\t\tptr->cfg_3gpp = (GF_3GPPConfigBox *)a;\n\t\t/*for 3GP config, remember sample entry type in config*/\n\t\tptr->cfg_3gpp->cfg.type = ptr->type;\n\t\tbreak;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_PASP:\n\t\tif (ptr->pasp) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->pasp = (GF_PixelAspectRatioBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_CLAP:\n\t\tif (ptr->clap) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->clap = (GF_CleanAppertureBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_RVCC:\n\t\tif (ptr->rvcc) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->rvcc = (GF_RVCConfigurationBox *)a;\n\t\tbreak;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err video_sample_entry_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGVisualSampleEntryBox *mp4v = (GF_MPEGVisualSampleEntryBox*)s;\n\tGF_Err e;\n\te = gf_isom_video_sample_entry_read((GF_VisualSampleEntryBox *)s, bs);\n\tif (e) return e;\n\te = gf_isom_box_array_read(s, bs, video_sample_entry_AddBox);\n\tif (e) return e;\n\t/*this is an AVC sample desc*/\n\tif (mp4v->avc_config || mp4v->svc_config || mp4v->mvc_config) AVC_RewriteESDescriptor(mp4v);\n\t/*this is an HEVC sample desc*/\n\tif (mp4v->hevc_config || mp4v->lhvc_config || (mp4v->type==GF_ISOM_BOX_TYPE_HVT1))\n\t\tHEVC_RewriteESDescriptor(mp4v);\n\treturn GF_OK;\n}\n\nGF_Box *video_sample_entry_New()\n{\n\tGF_MPEGVisualSampleEntryBox *tmp;\n\tGF_SAFEALLOC(tmp, GF_MPEGVisualSampleEntryBox);\n\tif (tmp == NULL) return NULL;\n\n\tgf_isom_video_sample_entry_init((GF_VisualSampleEntryBox *)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err video_sample_entry_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_isom_video_sample_entry_write((GF_VisualSampleEntryBox *)s, bs);\n\n\t/*mp4v*/\n\tif (ptr->esd) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->esd, bs);\n\t\tif (e) return e;\n\t}\n\t/*mp4v*/\n\telse if (ptr->cfg_3gpp) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->cfg_3gpp, bs);\n\t\tif (e) return e;\n\t}\n\t/*avc or hevc*/\n\telse {\n\t\tif (ptr->avc_config && ptr->avc_config->config) {\n\t\t\te = gf_isom_box_write((GF_Box *) ptr->avc_config, bs);\n\t\t\tif (e) return e;\n\t\t}\n\t\tif (ptr->hevc_config && ptr->hevc_config->config) {\n\t\t\te = gf_isom_box_write((GF_Box *) ptr->hevc_config, bs);\n\t\t\tif (e) return e;\n\t\t}\n\t\tif (ptr->ipod_ext)\t{\n\t\t\te = gf_isom_box_write((GF_Box *) ptr->ipod_ext, bs);\n\t\t\tif (e) return e;\n\t\t}\n\t\tif (ptr->descr)\t{\n\t\t\te = gf_isom_box_write((GF_Box *) ptr->descr, bs);\n\t\t\tif (e) return e;\n\t\t}\n\t\tif (ptr->svc_config && ptr->svc_config->config) {\n\t\t\te = gf_isom_box_write((GF_Box *) ptr->svc_config, bs);\n\t\t\tif (e) return e;\n\t\t}\n\t\tif (ptr->mvc_config && ptr->mvc_config->config) {\n\t\t\te = gf_isom_box_write((GF_Box *) ptr->mvc_config, bs);\n\t\t\tif (e) return e;\n\t\t}\n\t\tif (ptr->lhvc_config && ptr->lhvc_config->config) {\n\t\t\te = gf_isom_box_write((GF_Box *) ptr->lhvc_config, bs);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\tif (ptr->pasp) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->pasp, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->clap) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->clap, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->rvcc) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->rvcc, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->rinf) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->rinf, bs);\n\t\tif (e) return e;\n\t}\n\treturn gf_isom_box_array_write(s, ptr->protections, bs);\n}\n\nGF_Err video_sample_entry_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\n\tif (ptr->esd) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->esd);\n\t\tif (e) return e;\n\t\tptr->size += ptr->esd->size;\n\t} else if (ptr->cfg_3gpp) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->cfg_3gpp);\n\t\tif (e) return e;\n\t\tptr->size += ptr->cfg_3gpp->size;\n\t} else {\n\t\tif (!ptr->avc_config && !ptr->svc_config && !ptr->hevc_config && !ptr->lhvc_config && (ptr->type!=GF_ISOM_BOX_TYPE_HVT1) ) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tif (ptr->hevc_config && ptr->hevc_config->config) {\n\t\t\te = gf_isom_box_size((GF_Box *)ptr->hevc_config);\n\t\t\tif (e) return e;\n\t\t\tptr->size += ptr->hevc_config->size;\n\t\t}\n\n\t\tif (ptr->avc_config && ptr->avc_config->config) {\n\t\t\te = gf_isom_box_size((GF_Box *) ptr->avc_config);\n\t\t\tif (e) return e;\n\t\t\tptr->size += ptr->avc_config->size;\n\t\t}\n\n\t\tif (ptr->svc_config && ptr->svc_config->config) {\n\t\t\te = gf_isom_box_size((GF_Box *) ptr->svc_config);\n\t\t\tif (e) return e;\n\t\t\tptr->size += ptr->svc_config->size;\n\t\t}\n\n\t\tif (ptr->mvc_config && ptr->mvc_config->config) {\n\t\t\te = gf_isom_box_size((GF_Box *) ptr->mvc_config);\n\t\t\tif (e) return e;\n\t\t\tptr->size += ptr->mvc_config->size;\n\t\t}\n\n\t\tif (ptr->lhvc_config && ptr->lhvc_config->config) {\n\t\t\te = gf_isom_box_size((GF_Box *) ptr->lhvc_config);\n\t\t\tif (e) return e;\n\t\t\tptr->size += ptr->lhvc_config->size;\n\t\t}\n\n\t\tif (ptr->ipod_ext) {\n\t\t\te = gf_isom_box_size((GF_Box *) ptr->ipod_ext);\n\t\t\tif (e) return e;\n\t\t\tptr->size += ptr->ipod_ext->size;\n\t\t}\n\t\tif (ptr->descr) {\n\t\t\te = gf_isom_box_size((GF_Box *) ptr->descr);\n\t\t\tif (e) return e;\n\t\t\tptr->size += ptr->descr->size;\n\t\t}\n\t}\n\tif (ptr->pasp) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->pasp);\n\t\tif (e) return e;\n\t\tptr->size += ptr->pasp->size;\n\t}\n\tif (ptr->clap) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->clap);\n\t\tif (e) return e;\n\t\tptr->size += ptr->clap->size;\n\t}\n\tif (ptr->rvcc) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->rvcc);\n\t\tif (e) return e;\n\t\tptr->size += ptr->rvcc->size;\n\t}\n\tif (ptr->rinf) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->rinf);\n\t\tif (e) return e;\n\t\tptr->size += ptr->rinf->size;\n\t}\n\treturn gf_isom_box_array_size(s, ptr->protections);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid mvex_del(GF_Box *s)\n{\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->mehd) gf_isom_box_del((GF_Box*)ptr->mehd);\n\tgf_isom_box_array_del(ptr->TrackExList);\n\tgf_isom_box_array_del(ptr->TrackExPropList);\n\tgf_free(ptr);\n}\n\n\nGF_Err mvex_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TREX:\n\t\treturn gf_list_add(ptr->TrackExList, a);\n\tcase GF_ISOM_BOX_TYPE_TREP:\n\t\treturn gf_list_add(ptr->TrackExPropList, a);\n\tcase GF_ISOM_BOX_TYPE_MEHD:\n\t\tif (ptr->mehd) break;\n\t\tptr->mehd = (GF_MovieExtendsHeaderBox*)a;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\n\n\nGF_Err mvex_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, mvex_AddBox);\n}\n\nGF_Box *mvex_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieExtendsBox, GF_ISOM_BOX_TYPE_MVEX);\n\ttmp->TrackExList = gf_list_new();\n\tif (!tmp->TrackExList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\ttmp->TrackExPropList = gf_list_new();\n\tif (!tmp->TrackExPropList) {\n\t\tgf_list_del(tmp->TrackExList);\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err mvex_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->mehd) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->mehd, bs);\n\t\tif (e) return e;\n\t}\n\te = gf_isom_box_array_write(s, ptr->TrackExList, bs);\n\tif (e) return e;\n\treturn gf_isom_box_array_write(s, ptr->TrackExPropList, bs);\n}\n\nGF_Err mvex_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MovieExtendsBox *ptr = (GF_MovieExtendsBox *)s;\n\n\tif (ptr->mehd) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->mehd);\n\t\tif (e) return e;\n\t\tptr->size += ptr->mehd->size;\n\t}\n\te = gf_isom_box_array_size(s, ptr->TrackExList);\n\tif (e) return e;\n\treturn gf_isom_box_array_size(s, ptr->TrackExPropList);\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *mehd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieExtendsHeaderBox, GF_ISOM_BOX_TYPE_MEHD);\n\treturn (GF_Box *)tmp;\n}\nvoid mehd_del(GF_Box *s)\n{\n\tgf_free(s);\n}\nGF_Err mehd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\n\tif (ptr->version==1) {\n\t\tptr->fragment_duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tptr->fragment_duration = (u64) gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err mehd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\tGF_Err e = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->fragment_duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->fragment_duration);\n\t}\n\treturn GF_OK;\n}\nGF_Err mehd_Size(GF_Box *s)\n{\n\tGF_MovieExtendsHeaderBox *ptr = (GF_MovieExtendsHeaderBox *)s;\n\tptr->version = (ptr->fragment_duration>0xFFFFFFFF) ? 1 : 0;\n\ts->size += (ptr->version == 1) ? 8 : 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid mvhd_del(GF_Box *s)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err mvhd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tif (ptr->version == 1) {\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tif (!ptr->timeScale) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Movie header timescale is invalid (0) - defaulting to 600\\n\" ));\n\t\tptr->timeScale = 600;\n\t}\n\tptr->preferredRate = gf_bs_read_u32(bs);\n\tptr->preferredVolume = gf_bs_read_u16(bs);\n\tgf_bs_read_data(bs, ptr->reserved, 10);\n\tptr->matrixA = gf_bs_read_u32(bs);\n\tptr->matrixB = gf_bs_read_u32(bs);\n\tptr->matrixU = gf_bs_read_u32(bs);\n\tptr->matrixC = gf_bs_read_u32(bs);\n\tptr->matrixD = gf_bs_read_u32(bs);\n\tptr->matrixV = gf_bs_read_u32(bs);\n\tptr->matrixX = gf_bs_read_u32(bs);\n\tptr->matrixY = gf_bs_read_u32(bs);\n\tptr->matrixW = gf_bs_read_u32(bs);\n\tptr->previewTime = gf_bs_read_u32(bs);\n\tptr->previewDuration = gf_bs_read_u32(bs);\n\tptr->posterTime = gf_bs_read_u32(bs);\n\tptr->selectionTime = gf_bs_read_u32(bs);\n\tptr->selectionDuration = gf_bs_read_u32(bs);\n\tptr->currentTime = gf_bs_read_u32(bs);\n\tptr->nextTrackID = gf_bs_read_u32(bs);\n\tptr->original_duration = ptr->duration;\n\treturn GF_OK;\n}\n\nGF_Box *mvhd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MovieHeaderBox, GF_ISOM_BOX_TYPE_MVHD);\n\n\ttmp->preferredRate = (1<<16);\n\ttmp->preferredVolume = (1<<8);\n\n\ttmp->matrixA = (1<<16);\n\ttmp->matrixD = (1<<16);\n\ttmp->matrixW = (1<<30);\n\n\ttmp->nextTrackID = 1;\n\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err mvhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\tgf_bs_write_u32(bs, ptr->preferredRate);\n\tgf_bs_write_u16(bs, ptr->preferredVolume);\n\tgf_bs_write_data(bs, ptr->reserved, 10);\n\tgf_bs_write_u32(bs, ptr->matrixA);\n\tgf_bs_write_u32(bs, ptr->matrixB);\n\tgf_bs_write_u32(bs, ptr->matrixU);\n\tgf_bs_write_u32(bs, ptr->matrixC);\n\tgf_bs_write_u32(bs, ptr->matrixD);\n\tgf_bs_write_u32(bs, ptr->matrixV);\n\tgf_bs_write_u32(bs, ptr->matrixX);\n\tgf_bs_write_u32(bs, ptr->matrixY);\n\tgf_bs_write_u32(bs, ptr->matrixW);\n\tgf_bs_write_u32(bs, ptr->previewTime);\n\tgf_bs_write_u32(bs, ptr->previewDuration);\n\tgf_bs_write_u32(bs, ptr->posterTime);\n\tgf_bs_write_u32(bs, ptr->selectionTime);\n\tgf_bs_write_u32(bs, ptr->selectionDuration);\n\tgf_bs_write_u32(bs, ptr->currentTime);\n\tgf_bs_write_u32(bs, ptr->nextTrackID);\n\treturn GF_OK;\n}\n\nGF_Err mvhd_Size(GF_Box *s)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr->duration==(u64) -1) ptr->version = 0;\n\telse ptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\n\tptr->size += (ptr->version == 1) ? 28 : 16;\n\tptr->size += 80;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid nmhd_del(GF_Box *s)\n{\n\tGF_MPEGMediaHeaderBox *ptr = (GF_MPEGMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\n\nGF_Err nmhd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}\n\nGF_Box *nmhd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGMediaHeaderBox, GF_ISOM_BOX_TYPE_NMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err nmhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err nmhd_Size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid padb_del(GF_Box *s)\n{\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->padbits) gf_free(ptr->padbits);\n\tgf_free(ptr);\n}\n\n\nGF_Err padb_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *)s;\n\n\tptr->SampleCount = gf_bs_read_u32(bs);\n\n\tptr->padbits = (u8 *)gf_malloc(sizeof(u8)*ptr->SampleCount);\n\tfor (i=0; i<ptr->SampleCount; i += 2) {\n\t\tgf_bs_read_int(bs, 1);\n\t\tif (i+1 < ptr->SampleCount) {\n\t\t\tptr->padbits[i+1] = gf_bs_read_int(bs, 3);\n\t\t} else {\n\t\t\tgf_bs_read_int(bs, 3);\n\t\t}\n\t\tgf_bs_read_int(bs, 1);\n\t\tptr->padbits[i] = gf_bs_read_int(bs, 3);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *padb_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PaddingBitsBox, GF_ISOM_BOX_TYPE_PADB);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err padb_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->SampleCount, 32);\n\n\tfor (i=0 ; i<ptr->SampleCount; i += 2) {\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tif (i+1 < ptr->SampleCount) {\n\t\t\tgf_bs_write_int(bs, ptr->padbits[i+1], 3);\n\t\t} else {\n\t\t\tgf_bs_write_int(bs, 0, 3);\n\t\t}\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tgf_bs_write_int(bs, ptr->padbits[i], 3);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err padb_Size(GF_Box *s)\n{\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *)s;\n\tptr->size += 4;\n\tif (ptr->SampleCount) ptr->size += (ptr->SampleCount + 1) / 2;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid rely_del(GF_Box *s)\n{\n\tGF_RelyHintBox *rely = (GF_RelyHintBox *)s;\n\tgf_free(rely);\n}\n\nGF_Err rely_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_RelyHintBox *ptr = (GF_RelyHintBox *)s;\n\tptr->reserved = gf_bs_read_int(bs, 6);\n\tptr->prefered = gf_bs_read_int(bs, 1);\n\tptr->required = gf_bs_read_int(bs, 1);\n\treturn GF_OK;\n}\n\nGF_Box *rely_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RelyHintBox, GF_ISOM_BOX_TYPE_RELY);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rely_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RelyHintBox *ptr = (GF_RelyHintBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->reserved, 6);\n\tgf_bs_write_int(bs, ptr->prefered, 1);\n\tgf_bs_write_int(bs, ptr->required, 1);\n\treturn GF_OK;\n}\n\nGF_Err rely_Size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid rtpo_del(GF_Box *s)\n{\n\tGF_RTPOBox *rtpo = (GF_RTPOBox *)s;\n\tgf_free(rtpo);\n}\n\nGF_Err rtpo_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_RTPOBox *ptr = (GF_RTPOBox *)s;\n\tptr->timeOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *rtpo_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RTPOBox, GF_ISOM_BOX_TYPE_RTPO);\n\treturn (GF_Box *)tmp;\n}\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err rtpo_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RTPOBox *ptr = (GF_RTPOBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\t//here we have no pb, just remembed that some entries will have to\n\t//be 4-bytes aligned ...\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->timeOffset);\n\treturn GF_OK;\n}\n\nGF_Err rtpo_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid smhd_del(GF_Box *s)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\tif (ptr == NULL ) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err smhd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\tptr->balance = gf_bs_read_u16(bs);\n\tptr->reserved = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\nGF_Box *smhd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SoundMediaHeaderBox, GF_ISOM_BOX_TYPE_SMHD);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err smhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->balance);\n\tgf_bs_write_u16(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err smhd_Size(GF_Box *s)\n{\n\tGF_SoundMediaHeaderBox *ptr = (GF_SoundMediaHeaderBox *)s;\n\n\tptr->reserved = 0;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid snro_del(GF_Box *s)\n{\n\tGF_SeqOffHintEntryBox *snro = (GF_SeqOffHintEntryBox *)s;\n\tgf_free(snro);\n}\n\nGF_Err snro_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SeqOffHintEntryBox *ptr = (GF_SeqOffHintEntryBox *)s;\n\tptr->SeqOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *snro_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SeqOffHintEntryBox, GF_ISOM_BOX_TYPE_SNRO);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err snro_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SeqOffHintEntryBox *ptr = (GF_SeqOffHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->SeqOffset);\n\treturn GF_OK;\n}\n\nGF_Err snro_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n#define WRITE_SAMPLE_FRAGMENTS\t\t1\n\nvoid stbl_del(GF_Box *s)\n{\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->ChunkOffset) gf_isom_box_del(ptr->ChunkOffset);\n\tif (ptr->CompositionOffset) gf_isom_box_del((GF_Box *) ptr->CompositionOffset);\n\tif (ptr->CompositionToDecode) gf_isom_box_del((GF_Box *) ptr->CompositionToDecode);\n\tif (ptr->DegradationPriority) gf_isom_box_del((GF_Box *) ptr->DegradationPriority);\n\tif (ptr->SampleDescription) gf_isom_box_del((GF_Box *) ptr->SampleDescription);\n\tif (ptr->SampleSize) gf_isom_box_del((GF_Box *) ptr->SampleSize);\n\tif (ptr->SampleToChunk) gf_isom_box_del((GF_Box *) ptr->SampleToChunk);\n\tif (ptr->ShadowSync) gf_isom_box_del((GF_Box *) ptr->ShadowSync);\n\tif (ptr->SyncSample) gf_isom_box_del((GF_Box *) ptr->SyncSample);\n\tif (ptr->TimeToSample) gf_isom_box_del((GF_Box *) ptr->TimeToSample);\n\tif (ptr->SampleDep) gf_isom_box_del((GF_Box *) ptr->SampleDep);\n\tif (ptr->PaddingBits) gf_isom_box_del((GF_Box *) ptr->PaddingBits);\n\tif (ptr->Fragments) gf_isom_box_del((GF_Box *) ptr->Fragments);\n\tif (ptr->sub_samples) gf_isom_box_array_del(ptr->sub_samples);\n\tif (ptr->sampleGroups) gf_isom_box_array_del(ptr->sampleGroups);\n\tif (ptr->sampleGroupsDescription) gf_isom_box_array_del(ptr->sampleGroupsDescription);\n\n\tif (ptr->sai_sizes) gf_isom_box_array_del(ptr->sai_sizes);\n\tif (ptr->sai_offsets) gf_isom_box_array_del(ptr->sai_offsets);\n\n\tgf_free(ptr);\n}\n\nGF_Err stbl_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\tif (!a) return GF_OK;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_STTS:\n\t\tif (ptr->TimeToSample) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->TimeToSample = (GF_TimeToSampleBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_CTTS:\n\t\tif (ptr->CompositionOffset) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->CompositionOffset = (GF_CompositionOffsetBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_CSLG:\n\t\tif (ptr->CompositionToDecode) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->CompositionToDecode = (GF_CompositionToDecodeBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSS:\n\t\tif (ptr->SyncSample) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->SyncSample = (GF_SyncSampleBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSD:\n\t\tif (ptr->SampleDescription) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->SampleDescription  =(GF_SampleDescriptionBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STZ2:\n\tcase GF_ISOM_BOX_TYPE_STSZ:\n\t\tif (ptr->SampleSize) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->SampleSize = (GF_SampleSizeBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STSC:\n\t\tif (ptr->SampleToChunk) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->SampleToChunk = (GF_SampleToChunkBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_PADB:\n\t\tif (ptr->PaddingBits) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->PaddingBits = (GF_PaddingBitsBox *) a;\n\t\tbreak;\n\n\t//WARNING: AS THIS MAY CHANGE DYNAMICALLY DURING EDIT,\n\tcase GF_ISOM_BOX_TYPE_CO64:\n\tcase GF_ISOM_BOX_TYPE_STCO:\n\t\tif (ptr->ChunkOffset) {\n\t\t\tgf_isom_box_del(ptr->ChunkOffset);\n\t\t}\n\t\tptr->ChunkOffset = a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_STSH:\n\t\tif (ptr->ShadowSync) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->ShadowSync = (GF_ShadowSyncBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STDP:\n\t\tif (ptr->DegradationPriority) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->DegradationPriority = (GF_DegradationPriorityBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SDTP:\n\t\tif (ptr->SampleDep) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->SampleDep= (GF_SampleDependencyTypeBox *)a;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_STSF:\n\t\tif (ptr->Fragments) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->Fragments = (GF_SampleFragmentBox *)a;\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_SUBS:\n\t\tif (!ptr->sub_samples) ptr->sub_samples = gf_list_new();\n\t\tgf_list_add(ptr->sub_samples, a);\n\t\t//check subsample box\n\t\t{\n\t\t\tGF_SubSampleInformationBox *subs = (GF_SubSampleInformationBox *)a;\n\t\t\tGF_SubSampleInfoEntry *ent = gf_list_get(subs->Samples, 0);\n\t\t\tif (ent->sample_delta==0) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] first entry in SubSample in track SampleTable has sample_delta of 0, should be one. Fixing\\n\"));\n\t\t\t\tent->sample_delta = 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_SBGP:\n\t\tif (!ptr->sampleGroups) ptr->sampleGroups = gf_list_new();\n\t\tgf_list_add(ptr->sampleGroups, a);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SGPD:\n\t\tif (!ptr->sampleGroupsDescription) ptr->sampleGroupsDescription = gf_list_new();\n\t\tgf_list_add(ptr->sampleGroupsDescription, a);\n\t\tbreak;\n\n\tcase GF_ISOM_BOX_TYPE_SAIZ:\n\t\tif (!ptr->sai_sizes) ptr->sai_sizes = gf_list_new();\n\t\tgf_list_add(ptr->sai_sizes, a);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SAIO:\n\t\tif (!ptr->sai_offsets) ptr->sai_offsets = gf_list_new();\n\t\tgf_list_add(ptr->sai_offsets, a);\n\t\tbreak;\n\tdefault:\n\t\treturn gf_isom_box_add_default((GF_Box *)ptr, a);\n\t}\n\treturn GF_OK;\n}\n\n\n\n\nGF_Err stbl_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\t//we need to parse DegPrior in a special way\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\n\te = gf_isom_box_array_read(s, bs, stbl_AddBox);\n\tif (e) return e;\n\n\tif (!ptr->SyncSample)\n\t\tptr->no_sync_found = 1;\n\n\tptr->nb_sgpd_in_stbl = gf_list_count(ptr->sampleGroupsDescription);\n\tptr->nb_other_boxes_in_stbl = gf_list_count(ptr->other_boxes);\n\n\treturn GF_OK;\n}\n\nGF_Box *stbl_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleTableBox, GF_ISOM_BOX_TYPE_STBL);\n\t//maxSamplePer chunk is 10 by default\n\ttmp->MaxSamplePerChunk = 10;\n\ttmp->groupID = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stbl_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tif (ptr->SampleDescription) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->SampleDescription, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->TimeToSample) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->TimeToSample, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->CompositionOffset)\t{\n\t\te = gf_isom_box_write((GF_Box *) ptr->CompositionOffset, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->CompositionToDecode)\t{\n\t\te = gf_isom_box_write((GF_Box *) ptr->CompositionToDecode, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->SyncSample) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->SyncSample, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->ShadowSync) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->ShadowSync, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->SampleToChunk) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->SampleToChunk, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->SampleSize) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->SampleSize, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->ChunkOffset) {\n\t\te = gf_isom_box_write(ptr->ChunkOffset, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->DegradationPriority) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->DegradationPriority, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->SampleDep && ptr->SampleDep->sampleCount) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->SampleDep, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->PaddingBits) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->PaddingBits, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sub_samples) {\n\t\te = gf_isom_box_array_write(s, ptr->sub_samples, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sampleGroupsDescription) {\n\t\te = gf_isom_box_array_write(s, ptr->sampleGroupsDescription, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sampleGroups) {\n\t\te = gf_isom_box_array_write(s, ptr->sampleGroups, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sai_sizes) {\n\t\te = gf_isom_box_array_write(s, ptr->sai_sizes, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sai_offsets) {\n\t\te = gf_isom_box_array_write(s, ptr->sai_offsets, bs);\n\t\tif (e) return e;\n\t}\n\n#if WRITE_SAMPLE_FRAGMENTS\n\t//sampleFragments\n\tif (ptr->Fragments) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->Fragments, bs);\n\t\tif (e) return e;\n\t}\n#endif\n\treturn GF_OK;\n}\n\nGF_Err stbl_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\n\t//Mandatory boxs (but not internally :)\n\tif (ptr->SampleDescription) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->SampleDescription);\n\t\tif (e) return e;\n\t\tptr->size += ptr->SampleDescription->size;\n\t}\n\tif (ptr->SampleSize) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->SampleSize);\n\t\tif (e) return e;\n\t\tptr->size += ptr->SampleSize->size;\n\t}\n\tif (ptr->SampleToChunk) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->SampleToChunk);\n\t\tif (e) return e;\n\t\tptr->size += ptr->SampleToChunk->size;\n\t}\n\tif (ptr->TimeToSample) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->TimeToSample);\n\t\tif (e) return e;\n\t\tptr->size += ptr->TimeToSample->size;\n\t}\n\tif (ptr->ChunkOffset) {\n\t\te = gf_isom_box_size(ptr->ChunkOffset);\n\t\tif (e) return e;\n\t\tptr->size += ptr->ChunkOffset->size;\n\t}\n\n\t//optional boxs\n\tif (ptr->CompositionOffset)\t{\n\t\te = gf_isom_box_size((GF_Box *) ptr->CompositionOffset);\n\t\tif (e) return e;\n\t\tptr->size += ptr->CompositionOffset->size;\n\t}\n\tif (ptr->CompositionToDecode)\t{\n\t\te = gf_isom_box_size((GF_Box *) ptr->CompositionToDecode);\n\t\tif (e) return e;\n\t\tptr->size += ptr->CompositionToDecode->size;\n\t}\n\tif (ptr->DegradationPriority) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->DegradationPriority);\n\t\tif (e) return e;\n\t\tptr->size += ptr->DegradationPriority->size;\n\t}\n\tif (ptr->ShadowSync) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->ShadowSync);\n\t\tif (e) return e;\n\t\tptr->size += ptr->ShadowSync->size;\n\t}\n\tif (ptr->SyncSample) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->SyncSample);\n\t\tif (e) return e;\n\t\tptr->size += ptr->SyncSample->size;\n\t}\n\tif (ptr->SampleDep && ptr->SampleDep->sampleCount) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->SampleDep);\n\t\tif (e) return e;\n\t\tptr->size += ptr->SampleDep->size;\n\t}\n\t//padb\n\tif (ptr->PaddingBits) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->PaddingBits);\n\t\tif (e) return e;\n\t\tptr->size += ptr->PaddingBits->size;\n\t}\n#if WRITE_SAMPLE_FRAGMENTS\n\t//sample fragments\n\tif (ptr->Fragments) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->Fragments);\n\t\tif (e) return e;\n\t\tptr->size += ptr->Fragments->size;\n\t}\n#endif\n\n\tif (ptr->sub_samples) {\n\t\te = gf_isom_box_array_size(s, ptr->sub_samples);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sampleGroups) {\n\t\te = gf_isom_box_array_size(s, ptr->sampleGroups);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sampleGroupsDescription) {\n\t\te = gf_isom_box_array_size(s, ptr->sampleGroupsDescription);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sai_sizes) {\n\t\te = gf_isom_box_array_size(s, ptr->sai_sizes);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sai_offsets) {\n\t\te = gf_isom_box_array_size(s, ptr->sai_offsets);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stco_del(GF_Box *s)\n{\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tgf_free(ptr);\n}\n\n\nGF_Err stco_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entries;\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tif (ptr->nb_entries > ptr->size / 4) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stco\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tif (ptr->nb_entries) {\n\t\tptr->offsets = (u32 *) gf_malloc(ptr->nb_entries * sizeof(u32) );\n\t\tif (ptr->offsets == NULL) return GF_OUT_OF_MEM;\n\t\tptr->alloc_size = ptr->nb_entries;\n\n\t\tfor (entries = 0; entries < ptr->nb_entries; entries++) {\n\t\t\tptr->offsets[entries] = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stco_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChunkOffsetBox, GF_ISOM_BOX_TYPE_STCO);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stco_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->offsets[i]);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err stco_Size(GF_Box *s)\n{\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\n\tptr->size += 4 + (4 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid stdp_del(GF_Box *s)\n{\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\tif (ptr == NULL ) return;\n\tif (ptr->priorities) gf_free(ptr->priorities);\n\tgf_free(ptr);\n}\n\n//this is called through stbl_read...\nGF_Err stdp_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entry;\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\n\t/*out-of-order stdp, assume no padding at the end and take the entire remaining data for entries*/\n\tif (!ptr->nb_entries) ptr->nb_entries = (u32) ptr->size / 2;\n\telse if (ptr->nb_entries > ptr->size / 2) return GF_ISOM_INVALID_FILE;\n\n\tptr->priorities = (u16 *) gf_malloc(ptr->nb_entries * sizeof(u16));\n\tif (ptr->priorities == NULL) return GF_OUT_OF_MEM;\n\tfor (entry = 0; entry < ptr->nb_entries; entry++) {\n\t\tptr->priorities[entry] = gf_bs_read_u16(bs);\n\t}\n\tISOM_DECREASE_SIZE(ptr, (2*ptr->nb_entries) );\n\treturn GF_OK;\n}\n\nGF_Box *stdp_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DegradationPriorityBox, GF_ISOM_BOX_TYPE_STDP);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stdp_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u16(bs, ptr->priorities[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stdp_Size(GF_Box *s)\n{\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\n\tptr->size += (2 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsc_del(GF_Box *s)\n{\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err stsc_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tif (ptr->nb_entries > ptr->size / 12) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsc\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = gf_malloc(sizeof(GF_StscEntry)*ptr->alloc_size);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tptr->entries[i].firstChunk = gf_bs_read_u32(bs);\n\t\tptr->entries[i].samplesPerChunk = gf_bs_read_u32(bs);\n\t\tptr->entries[i].sampleDescriptionIndex = gf_bs_read_u32(bs);\n\t\tptr->entries[i].isEdited = 0;\n\t\tptr->entries[i].nextChunk = 0;\n\t\tif (!ptr->entries[i].firstChunk) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] invalid first chunk 0 in stsc entry\\n\", ptr->nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t//update the next chunk in the previous entry\n\t\tif (i) ptr->entries[i-1].nextChunk = ptr->entries[i].firstChunk;\n\t}\n\tptr->currentIndex = 0;\n\tptr->firstSampleInCurrentChunk = 0;\n\tptr->currentChunk = 0;\n\tptr->ghostNumber = 0;\n\treturn GF_OK;\n}\n\nGF_Box *stsc_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleToChunkBox, GF_ISOM_BOX_TYPE_STSC);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsc_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].firstChunk);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].samplesPerChunk);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleDescriptionIndex);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsc_Size(GF_Box *s)\n{\n\tGF_SampleToChunkBox *ptr = (GF_SampleToChunkBox *)s;\n\n\tptr->size += 4 + (12 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stsd_del(GF_Box *s)\n{\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err stsd_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_UnknownBox *def;\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\tif (!a) return GF_OK;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_RESV:\n\tcase GF_ISOM_BOX_TYPE_GHNT:\n\tcase GF_ISOM_BOX_TYPE_RTP_STSD:\n\tcase GF_ISOM_BOX_TYPE_SRTP_STSD:\n\tcase GF_ISOM_BOX_TYPE_FDP_STSD:\n\tcase GF_ISOM_BOX_TYPE_RRTP_STSD:\n\tcase GF_ISOM_BOX_TYPE_RTCP_STSD:\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\tcase GF_ISOM_BOX_TYPE_ENCT:\n\tcase GF_ISOM_BOX_TYPE_METX:\n\tcase GF_ISOM_BOX_TYPE_METT:\n\tcase GF_ISOM_BOX_TYPE_STXT:\n\tcase GF_ISOM_BOX_TYPE_DIMS:\n\tcase GF_ISOM_BOX_TYPE_AC3:\n\tcase GF_ISOM_BOX_TYPE_EC3:\n\tcase GF_ISOM_BOX_TYPE_LSR1:\n\tcase GF_ISOM_BOX_TYPE_WVTT:\n\tcase GF_ISOM_BOX_TYPE_STPP:\n\tcase GF_ISOM_BOX_TYPE_SBTT:\n\tcase GF_ISOM_BOX_TYPE_ELNG:\n\tcase GF_ISOM_BOX_TYPE_MP3:\n\tcase GF_ISOM_BOX_TYPE_JPEG:\n\tcase GF_ISOM_BOX_TYPE_JP2K:\n\tcase GF_ISOM_BOX_TYPE_PNG:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\treturn gf_isom_box_add_default((GF_Box*)ptr, a);\n\n\t//unknown sample description: we need a specific box to handle the data ref index\n\t//rather than a default box ...\n\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\tdef = (GF_UnknownBox *)a;\n\t\t/*we need at least 8 bytes for unknown sample entries*/\n\t\tif (def->dataSize < 8) {\n\t\t\tgf_isom_box_del(a);\n\t\t\treturn GF_OK;\n\t\t}\n\t\treturn gf_isom_box_add_default((GF_Box*)ptr, a);\n\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Cannot process box of type %s\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n}\n\n\nGF_Err stsd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tgf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(s, 4)\n\n\treturn gf_isom_box_array_read_ex(s, bs, stsd_AddBox, GF_ISOM_BOX_TYPE_STSD);\n}\n\nGF_Box *stsd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleDescriptionBox, GF_ISOM_BOX_TYPE_STSD);\n\ttmp->other_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 nb_entries;\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tnb_entries = gf_list_count(ptr->other_boxes);\n\tgf_bs_write_u32(bs, nb_entries);\n\treturn GF_OK;\n}\n\nGF_Err stsd_Size(GF_Box *s)\n{\n\tGF_SampleDescriptionBox *ptr = (GF_SampleDescriptionBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stsf_del(GF_Box *s)\n{\n\tu32 nb_entries;\n\tu32 i;\n\tGF_StsfEntry *pe;\n\tGF_SampleFragmentBox *ptr = (GF_SampleFragmentBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->entryList) {\n\t\tnb_entries = gf_list_count(ptr->entryList);\n\t\tfor ( i = 0; i < nb_entries; i++ ) {\n\t\t\tpe = (GF_StsfEntry*)gf_list_get(ptr->entryList, i);\n\t\t\tif (pe->fragmentSizes) gf_free(pe->fragmentSizes);\n\t\t\tgf_free(pe);\n\t\t}\n\t\tgf_list_del(ptr->entryList);\n\t}\n\tgf_free(ptr);\n}\n\n\n\nGF_Err stsf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entries, i;\n\tu32 nb_entries;\n\tGF_StsfEntry *p;\n\tGF_SampleFragmentBox *ptr = (GF_SampleFragmentBox *)s;\n\n\tp = NULL;\n\tif (!ptr) return GF_BAD_PARAM;\n\tnb_entries = gf_bs_read_u32(bs);\n\n\tp = NULL;\n\tfor ( entries = 0; entries < nb_entries; entries++ ) {\n\t\tp = (GF_StsfEntry *) gf_malloc(sizeof(GF_StsfEntry));\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\tp->SampleNumber = gf_bs_read_u32(bs);\n\t\tp->fragmentCount = gf_bs_read_u32(bs);\n\t\tp->fragmentSizes = (u16*)gf_malloc(sizeof(GF_StsfEntry) * p->fragmentCount);\n\t\tfor (i=0; i<p->fragmentCount; i++) {\n\t\t\tp->fragmentSizes[i] = gf_bs_read_u16(bs);\n\t\t}\n\t\tgf_list_add(ptr->entryList, p);\n\t}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tptr->w_currentEntry = p;\n\tptr->w_currentEntryIndex = nb_entries-1;\n#endif\n\treturn GF_OK;\n}\n\nGF_Box *stsf_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleFragmentBox, GF_ISOM_BOX_TYPE_STSF);\n\n\ttmp->entryList = gf_list_new();\n\tif (! tmp->entryList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *) tmp;\n}\n\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsf_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j;\n\tu32 nb_entries;\n\tGF_StsfEntry *p;\n\tGF_SampleFragmentBox *ptr = (GF_SampleFragmentBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tnb_entries = gf_list_count(ptr->entryList);\n\tgf_bs_write_u32(bs, nb_entries);\n\tfor ( i = 0; i < nb_entries; i++ ) {\n\t\tp = (GF_StsfEntry*)gf_list_get(ptr->entryList, i);\n\t\tgf_bs_write_u32(bs, p->SampleNumber);\n\t\tgf_bs_write_u32(bs, p->fragmentCount);\n\t\tfor (j=0; j<p->fragmentCount; j++) {\n\t\t\tgf_bs_write_u16(bs, p->fragmentSizes[j]);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsf_Size(GF_Box *s)\n{\n\tGF_StsfEntry *p;\n\tu32 nb_entries, i;\n\tGF_SampleFragmentBox *ptr = (GF_SampleFragmentBox *) s;\n\n\tnb_entries = gf_list_count(ptr->entryList);\n\tptr->size += 4;\n\tfor (i=0; i<nb_entries; i++) {\n\t\tp = (GF_StsfEntry *)gf_list_get(ptr->entryList, i);\n\t\tptr->size += 8 + 2*p->fragmentCount;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stsh_del(GF_Box *s)\n{\n\tu32 i = 0;\n\tGF_StshEntry *ent;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\tif (ptr == NULL) return;\n\twhile ( (ent = (GF_StshEntry *)gf_list_enum(ptr->entries, &i)) ) {\n\t\tgf_free(ent);\n\t}\n\tgf_list_del(ptr->entries);\n\tgf_free(ptr);\n}\n\n\n\nGF_Err stsh_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 count, i;\n\tGF_StshEntry *ent;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\n\tcount = gf_bs_read_u32(bs);\n\n\tfor (i = 0; i < count; i++) {\n\t\tent = (GF_StshEntry *) gf_malloc(sizeof(GF_StshEntry));\n\t\tif (!ent) return GF_OUT_OF_MEM;\n\t\tent->shadowedSampleNumber = gf_bs_read_u32(bs);\n\t\tent->syncSampleNumber = gf_bs_read_u32(bs);\n\t\te = gf_list_add(ptr->entries, ent);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsh_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);\n\n\ttmp->entries = gf_list_new();\n\tif (!tmp->entries) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsh_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_StshEntry *ent;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, gf_list_count(ptr->entries));\n\ti=0;\n\twhile ((ent = (GF_StshEntry *)gf_list_enum(ptr->entries, &i))) {\n\t\tgf_bs_write_u32(bs, ent->shadowedSampleNumber);\n\t\tgf_bs_write_u32(bs, ent->syncSampleNumber);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsh_Size(GF_Box *s)\n{\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\tptr->size += 4 + (8 * gf_list_count(ptr->entries));\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid stss_del(GF_Box *s)\n{\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sampleNumbers) gf_free(ptr->sampleNumbers);\n\tgf_free(ptr);\n}\n\nGF_Err stss_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tif (ptr->nb_entries > ptr->size / 4) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stss\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->sampleNumbers = (u32 *) gf_malloc( ptr->alloc_size * sizeof(u32));\n\tif (ptr->sampleNumbers == NULL) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tptr->sampleNumbers[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stss_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SyncSampleBox, GF_ISOM_BOX_TYPE_STSS);\n\treturn (GF_Box*)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stss_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i = 0; i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->sampleNumbers[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stss_Size(GF_Box *s)\n{\n\tGF_SyncSampleBox *ptr = (GF_SyncSampleBox *)s;\n\tptr->size += 4 + (4 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stsz_del(GF_Box *s)\n{\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sizes) gf_free(ptr->sizes);\n\tgf_free(ptr);\n}\n\n\nGF_Err stsz_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, estSize;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\t//support for CompactSizes\n\tif (s->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tptr->sampleSize = gf_bs_read_u32(bs);\n\t\tptr->sampleCount = gf_bs_read_u32(bs);\n\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t} else {\n\t\t//24-reserved\n\t\tgf_bs_read_int(bs, 24);\n\t\ti = gf_bs_read_u8(bs);\n\t\tptr->sampleCount = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tswitch (i) {\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\t\tptr->sampleSize = i;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//try to fix the file\n\t\t\t//no samples, no parsing pb\n\t\t\tif (!ptr->sampleCount) {\n\t\t\t\tptr->sampleSize = 16;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\testSize = (u32) (ptr->size) / ptr->sampleCount;\n\t\t\tif (!estSize && ((ptr->sampleCount+1)/2 == (ptr->size)) ) {\n\t\t\t\tptr->sampleSize = 4;\n\t\t\t\tbreak;\n\t\t\t} else if (estSize == 1 || estSize == 2) {\n\t\t\t\tptr->sampleSize = 8 * estSize;\n\t\t\t} else {\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t}\n\t}\n\tif (s->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (! ptr->sampleSize && ptr->sampleCount) {\n\t\t\tif (ptr->sampleCount > ptr->size / 4) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tptr->sizes = (u32 *) gf_malloc(ptr->sampleCount * sizeof(u32));\n\t\t\tptr->alloc_size = ptr->sampleCount;\n\t\t\tif (! ptr->sizes) return GF_OUT_OF_MEM;\n\t\t\tfor (i = 0; i < ptr->sampleCount; i++) {\n\t\t\t\tptr->sizes[i] = gf_bs_read_u32(bs);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (ptr->sampleSize==4) {\n\t\t\tif (ptr->sampleCount / 2 > ptr->size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ptr->sampleCount > ptr->size / (ptr->sampleSize/8)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stsz\\n\", ptr->sampleCount));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t}\n\t\t//note we could optimize the mem usage by keeping the table compact\n\t\t//in memory. But that would complicate both caching and editing\n\t\t//we therefore keep all sizes as u32 and uncompress the table\n\t\tptr->sizes = (u32 *) gf_malloc(ptr->sampleCount * sizeof(u32));\n\t\tif (! ptr->sizes) return GF_OUT_OF_MEM;\n\t\tptr->alloc_size = ptr->sampleCount;\n\n\t\tfor (i = 0; i < ptr->sampleCount; ) {\n\t\t\tswitch (ptr->sampleSize) {\n\t\t\tcase 4:\n\t\t\t\tptr->sizes[i] = gf_bs_read_int(bs, 4);\n\t\t\t\tif (i+1 < ptr->sampleCount) {\n\t\t\t\t\tptr->sizes[i+1] = gf_bs_read_int(bs, 4);\n\t\t\t\t} else {\n\t\t\t\t\t//0 padding in odd sample count\n\t\t\t\t\tgf_bs_read_int(bs, 4);\n\t\t\t\t}\n\t\t\t\ti += 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tptr->sizes[i] = gf_bs_read_int(bs, ptr->sampleSize);\n\t\t\t\ti += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsz_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleSizeBox, 0);\n\n\t//type is unknown here, can be regular or compact table\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsz_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t//in both versions this is still valid\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tgf_bs_write_u32(bs, ptr->sampleSize);\n\t} else {\n\t\tgf_bs_write_u24(bs, 0);\n\t\tgf_bs_write_u8(bs, ptr->sampleSize);\n\t}\n\tgf_bs_write_u32(bs, ptr->sampleCount);\n\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (! ptr->sampleSize) {\n\t\t\tfor (i = 0; i < ptr->sampleCount; i++) {\n\t\t\t\tgf_bs_write_u32(bs, ptr->sizes ? ptr->sizes[i] : 0);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ptr->sampleCount; ) {\n\t\t\tswitch (ptr->sampleSize) {\n\t\t\tcase 4:\n\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i], 4);\n\t\t\t\tif (i+1 < ptr->sampleCount) {\n\t\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i+1], 4);\n\t\t\t\t} else {\n\t\t\t\t\t//0 padding in odd sample count\n\t\t\t\t\tgf_bs_write_int(bs, 0, 4);\n\t\t\t\t}\n\t\t\t\ti += 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgf_bs_write_int(bs, ptr->sizes[i], ptr->sampleSize);\n\t\t\t\ti += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsz_Size(GF_Box *s)\n{\n\tu32 i, fieldSize, size;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\n\tptr->size += 8;\n\tif (!ptr->sampleCount) return GF_OK;\n\n\t//regular table\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (ptr->sampleSize) return GF_OK;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\n\tfieldSize = 4;\n\tsize = ptr->sizes[0];\n\n\tfor (i=0; i < ptr->sampleCount; i++) {\n\t\tif (ptr->sizes[i] <= 0xF) continue;\n\t\t//switch to 8-bit table\n\t\telse if (ptr->sizes[i] <= 0xFF) {\n\t\t\tfieldSize = 8;\n\t\t}\n\t\t//switch to 16-bit table\n\t\telse if (ptr->sizes[i] <= 0xFFFF) {\n\t\t\tfieldSize = 16;\n\t\t}\n\t\t//switch to 32-bit table\n\t\telse {\n\t\t\tfieldSize = 32;\n\t\t}\n\n\t\t//check the size\n\t\tif (size != ptr->sizes[i]) size = 0;\n\t}\n\t//if all samples are of the same size, switch to regular (more compact)\n\tif (size) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->sampleSize = size;\n\t\tgf_free(ptr->sizes);\n\t\tptr->sizes = NULL;\n\t}\n\n\tif (fieldSize == 32) {\n\t\t//oops, doesn't fit in a compact table\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\n\t//make sure we are a compact table (no need to change the mem representation)\n\tptr->type = GF_ISOM_BOX_TYPE_STZ2;\n\tptr->sampleSize = fieldSize;\n\tif (fieldSize == 4) {\n\t\t//do not forget the 0 padding field for odd count\n\t\tptr->size += (ptr->sampleCount + 1) / 2;\n\t} else {\n\t\tptr->size += (ptr->sampleCount) * (fieldSize/8);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid stts_del(GF_Box *s)\n{\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\n\nGF_Err stts_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tptr->w_LastDTS = 0;\n#endif\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tif (ptr->nb_entries > ptr->size / 8) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in stts\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = gf_malloc(sizeof(GF_SttsEntry)*ptr->alloc_size);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->entries[i].sampleCount = gf_bs_read_u32(bs);\n\t\tptr->entries[i].sampleDelta = gf_bs_read_u32(bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\tptr->w_currentSampleNum += ptr->entries[i].sampleCount;\n\t\tptr->w_LastDTS += (u64)ptr->entries[i].sampleCount * ptr->entries[i].sampleDelta;\n#endif\n\n\t\tif (!ptr->entries[i].sampleDelta) {\n\t\t\tif ((i+1<ptr->nb_entries) ) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Found stts entry with sample_delta=0 - forbidden ! Fixing to 1\\n\" ));\n\t\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t\t} else if (ptr->entries[i].sampleCount>1) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] more than one stts entry at the end of the track with sample_delta=0 - forbidden ! Fixing to 1\\n\" ));\n\t\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t\t}\n\t\t} else if ((s32) ptr->entries[i].sampleDelta < 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] stts entry %d has negative duration %d - forbidden ! Fixing to 1, sync may get lost (consider reimport raw media)\\n\", i, (s32) ptr->entries[i].sampleDelta ));\n\t\t\tptr->entries[i].sampleDelta = 1;\n\t\t}\n\t}\n\tif (ptr->size<(ptr->nb_entries*8)) return GF_ISOM_INVALID_FILE;\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries*8);\n\n\t//remove the last sample delta.\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (ptr->nb_entries) ptr->w_LastDTS -= ptr->entries[ptr->nb_entries-1].sampleDelta;\n#endif\n\treturn GF_OK;\n}\n\nGF_Box *stts_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeToSampleBox, GF_ISOM_BOX_TYPE_STTS);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stts_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleCount);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].sampleDelta);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stts_Size(GF_Box *s)\n{\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\tptr->size += 4 + (8 * ptr->nb_entries);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid tfhd_del(GF_Box *s)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err tfhd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\n\tptr->trackID = gf_bs_read_u32(bs);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) {\n\t\tptr->base_data_offset = gf_bs_read_u64(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) {\n\t\tptr->sample_desc_index = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) {\n\t\tptr->def_sample_duration = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) {\n\t\tptr->def_sample_size = gf_bs_read_u32(bs);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) {\n\t\tptr->def_sample_flags = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *tfhd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentHeaderBox, GF_ISOM_BOX_TYPE_TFHD);\n\t//NO FLAGS SET BY DEFAULT\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err tfhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->trackID);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) {\n\t\tgf_bs_write_u64(bs, ptr->base_data_offset);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) {\n\t\tgf_bs_write_u32(bs, ptr->sample_desc_index);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_duration);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_size);\n\t}\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) {\n\t\tgf_bs_write_u32(bs, ptr->def_sample_flags);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfhd_Size(GF_Box *s)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\tptr->size += 4;\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) ptr->size += 8;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ptr->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid tims_del(GF_Box *s)\n{\n\tGF_TSHintEntryBox *tims = (GF_TSHintEntryBox *)s;\n\tgf_free(tims);\n}\n\nGF_Err tims_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TSHintEntryBox *ptr = (GF_TSHintEntryBox *)s;\n\tptr->timeScale = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tims_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TSHintEntryBox, GF_ISOM_BOX_TYPE_TIMS);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tims_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TSHintEntryBox *ptr = (GF_TSHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->timeScale);\n\treturn GF_OK;\n}\n\nGF_Err tims_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tkhd_del(GF_Box *s)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n\treturn;\n}\n\n\nGF_Err tkhd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\tif (ptr->version == 1) {\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->trackID = gf_bs_read_u32(bs);\n\t\tptr->reserved1 = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->trackID = gf_bs_read_u32(bs);\n\t\tptr->reserved1 = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tptr->reserved2[0] = gf_bs_read_u32(bs);\n\tptr->reserved2[1] = gf_bs_read_u32(bs);\n\tptr->layer = gf_bs_read_u16(bs);\n\tptr->alternate_group = gf_bs_read_u16(bs);\n\tptr->volume = gf_bs_read_u16(bs);\n\tptr->reserved3 = gf_bs_read_u16(bs);\n\tptr->matrix[0] = gf_bs_read_u32(bs);\n\tptr->matrix[1] = gf_bs_read_u32(bs);\n\tptr->matrix[2] = gf_bs_read_u32(bs);\n\tptr->matrix[3] = gf_bs_read_u32(bs);\n\tptr->matrix[4] = gf_bs_read_u32(bs);\n\tptr->matrix[5] = gf_bs_read_u32(bs);\n\tptr->matrix[6] = gf_bs_read_u32(bs);\n\tptr->matrix[7] = gf_bs_read_u32(bs);\n\tptr->matrix[8] = gf_bs_read_u32(bs);\n\tptr->width = gf_bs_read_u32(bs);\n\tptr->height = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tkhd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackHeaderBox, GF_ISOM_BOX_TYPE_TKHD);\n\ttmp->matrix[0] = 0x00010000;\n\ttmp->matrix[4] = 0x00010000;\n\ttmp->matrix[8] = 0x40000000;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tkhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->trackID);\n\t\tgf_bs_write_u32(bs, ptr->reserved1);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->trackID);\n\t\tgf_bs_write_u32(bs, ptr->reserved1);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\tgf_bs_write_u32(bs, ptr->reserved2[0]);\n\tgf_bs_write_u32(bs, ptr->reserved2[1]);\n\tgf_bs_write_u16(bs, ptr->layer);\n\tgf_bs_write_u16(bs, ptr->alternate_group);\n\tgf_bs_write_u16(bs, ptr->volume);\n\tgf_bs_write_u16(bs, ptr->reserved3);\n\tgf_bs_write_u32(bs, ptr->matrix[0]);\n\tgf_bs_write_u32(bs, ptr->matrix[1]);\n\tgf_bs_write_u32(bs, ptr->matrix[2]);\n\tgf_bs_write_u32(bs, ptr->matrix[3]);\n\tgf_bs_write_u32(bs, ptr->matrix[4]);\n\tgf_bs_write_u32(bs, ptr->matrix[5]);\n\tgf_bs_write_u32(bs, ptr->matrix[6]);\n\tgf_bs_write_u32(bs, ptr->matrix[7]);\n\tgf_bs_write_u32(bs, ptr->matrix[8]);\n\tgf_bs_write_u32(bs, ptr->width);\n\tgf_bs_write_u32(bs, ptr->height);\n\treturn GF_OK;\n}\n\nGF_Err tkhd_Size(GF_Box *s)\n{\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\tif (ptr->duration==(u64) -1) ptr->version = 0;\n\telse ptr->version = (ptr->duration>0xFFFFFFFF) ? 1 : 0;\n\tptr->size += (ptr->version == 1) ? 32 : 20;\n\tptr->size += 60;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid traf_del(GF_Box *s)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->tfhd) gf_isom_box_del((GF_Box *) ptr->tfhd);\n\tif (ptr->sdtp) gf_isom_box_del((GF_Box *) ptr->sdtp);\n\tif (ptr->sub_samples) gf_isom_box_array_del(ptr->sub_samples);\n\tif (ptr->tfdt) gf_isom_box_del((GF_Box *) ptr->tfdt);\n\tif (ptr->sample_encryption) gf_isom_box_del((GF_Box *) ptr->sample_encryption);\n\tgf_isom_box_array_del(ptr->TrackRuns);\n\tif (ptr->sampleGroups) gf_isom_box_array_del(ptr->sampleGroups);\n\tif (ptr->sampleGroupsDescription) gf_isom_box_array_del(ptr->sampleGroupsDescription);\n\tif (ptr->sai_sizes) gf_isom_box_array_del(ptr->sai_sizes);\n\tif (ptr->sai_offsets) gf_isom_box_array_del(ptr->sai_offsets);\n\tgf_free(ptr);\n}\n\nGF_Err traf_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TFHD:\n\t\tif (ptr->tfhd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->tfhd = (GF_TrackFragmentHeaderBox *) a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRUN:\n\t\treturn gf_list_add(ptr->TrackRuns, a);\n\tcase GF_ISOM_BOX_TYPE_SDTP:\n\t\tif (ptr->sdtp) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->sdtp = (GF_SampleDependencyTypeBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TFDT:\n\t\tif (ptr->tfdt) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->tfdt = (GF_TFBaseMediaDecodeTimeBox*) a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SUBS:\n\t\tif (!ptr->sub_samples) ptr->sub_samples = gf_list_new();\n\t\treturn gf_list_add(ptr->sub_samples, a);\n\tcase GF_ISOM_BOX_TYPE_SBGP:\n\t\tif (!ptr->sampleGroups) ptr->sampleGroups = gf_list_new();\n\t\tgf_list_add(ptr->sampleGroups, a);\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SGPD:\n\t\tif (!ptr->sampleGroupsDescription) ptr->sampleGroupsDescription = gf_list_new();\n\t\tgf_list_add(ptr->sampleGroupsDescription, a);\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SAIZ:\n\t\tif (!ptr->sai_sizes) ptr->sai_sizes = gf_list_new();\n\t\tgf_list_add(ptr->sai_sizes, a);\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SAIO:\n\t\tif (!ptr->sai_offsets) ptr->sai_offsets = gf_list_new();\n\t\tgf_list_add(ptr->sai_offsets, a);\n\t\treturn GF_OK;\n\t//we will throw an error if both PIFF_PSEC and SENC are found. Not such files seen yet\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif ( ((GF_UUIDBox *)a)->internal_4cc==GF_ISOM_BOX_UUID_PSEC) {\n\t\t\tif (ptr->sample_encryption) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->sample_encryption = (GF_SampleEncryptionBox *)a;\n\t\t\tptr->sample_encryption->traf = ptr;\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\treturn gf_isom_box_add_default(s, a);\n\t\t}\n\tcase GF_ISOM_BOX_TYPE_SENC:\n\t\tif (ptr->sample_encryption) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->sample_encryption = (GF_SampleEncryptionBox *)a;\n\t\tptr->sample_encryption->traf = ptr;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err traf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\tGF_Err e = gf_isom_box_array_read(s, bs, traf_AddBox);\n\tif (e) return e;\n\n\tif (!ptr->tfhd) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing TrackFragmentHeaderBox \\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *traf_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentBox, GF_ISOM_BOX_TYPE_TRAF);\n\ttmp->TrackRuns = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Box *tfxd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MSSTimeExtBox, GF_ISOM_BOX_TYPE_UUID);\n\ttmp->internal_4cc = GF_ISOM_BOX_UUID_TFXD;\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfxd_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err tfxd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox *)s;\n\tif (ptr->size<4) return GF_ISOM_INVALID_FILE;\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tif (ptr->version == 0x01) {\n\t\tptr->absolute_time_in_track_timescale = gf_bs_read_u64(bs);\n\t\tptr->fragment_duration_in_track_timescale = gf_bs_read_u64(bs);\n\t} else {\n\t\tptr->absolute_time_in_track_timescale = gf_bs_read_u32(bs);\n\t\tptr->fragment_duration_in_track_timescale = gf_bs_read_u32(bs);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err tfxd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = GF_OK;\n\tGF_MSSTimeExtBox *uuid = (GF_MSSTimeExtBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, 1);\n\tgf_bs_write_u24(bs, 0);\n\tgf_bs_write_u64(bs, uuid->absolute_time_in_track_timescale);\n\tgf_bs_write_u64(bs, uuid->fragment_duration_in_track_timescale);\n\n\treturn GF_OK;\n}\n\nGF_Err tfxd_Size(GF_Box *s)\n{\n\ts->size += 20;\n\treturn GF_OK;\n}\n\nGF_Err traf_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\t//Header first\n\tif (ptr->tfhd) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->tfhd, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sub_samples) {\n\t\te = gf_isom_box_array_write(s, ptr->sub_samples, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->tfdt) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->tfdt, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sdtp) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->sdtp, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sampleGroupsDescription) {\n\t\te = gf_isom_box_array_write(s, ptr->sampleGroupsDescription, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sampleGroups) {\n\t\te = gf_isom_box_array_write(s, ptr->sampleGroups, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sai_sizes) {\n\t\te = gf_isom_box_array_write(s, ptr->sai_sizes, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sai_offsets) {\n\t\te = gf_isom_box_array_write(s, ptr->sai_offsets, bs);\n\t\tif (e) return e;\n\t}\n\te = gf_isom_box_array_write(s, ptr->TrackRuns, bs);\n\tif (e) return e;\n\n\tif (ptr->sample_encryption) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->sample_encryption, bs);\n\t\tif (e) return e;\n\t}\n\t//tfxd should be last ...\n\tif (ptr->tfxd) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->tfxd, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err traf_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\n\tif (ptr->tfhd) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->tfhd);\n\t\tif (e) return e;\n\t\tptr->size += ptr->tfhd->size;\n\t}\n\tif (ptr->sub_samples) {\n\t\te = gf_isom_box_array_size(s, ptr->sub_samples);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sdtp) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->sdtp);\n\t\tif (e) return e;\n\t\tptr->size += ptr->sdtp->size;\n\t}\n\tif (ptr->tfdt) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->tfdt);\n\t\tif (e) return e;\n\t\tptr->size += ptr->tfdt->size;\n\t}\n\n\tif (ptr->sampleGroups) {\n\t\te = gf_isom_box_array_size(s, ptr->sampleGroups);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sampleGroupsDescription) {\n\t\te = gf_isom_box_array_size(s, ptr->sampleGroupsDescription);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sai_sizes) {\n\t\te = gf_isom_box_array_size(s, ptr->sai_sizes);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sai_offsets) {\n\t\te = gf_isom_box_array_size(s, ptr->sai_offsets);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sample_encryption) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->sample_encryption);\n\t\tif (e) return e;\n\t\tptr->size += ptr->sample_encryption->size;\n\t}\n\tif (ptr->tfxd) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->tfxd);\n\t\tif (e) return e;\n\t\ts->size += ptr->tfxd->size;\n\t}\n\treturn gf_isom_box_array_size(s, ptr->TrackRuns);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid trak_del(GF_Box *s)\n{\n\tGF_TrackBox *ptr = (GF_TrackBox *) s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->Header) gf_isom_box_del((GF_Box *)ptr->Header);\n\tif (ptr->udta) gf_isom_box_del((GF_Box *)ptr->udta);\n\tif (ptr->Media) gf_isom_box_del((GF_Box *)ptr->Media);\n\tif (ptr->References) gf_isom_box_del((GF_Box *)ptr->References);\n\tif (ptr->editBox) gf_isom_box_del((GF_Box *)ptr->editBox);\n\tif (ptr->meta) gf_isom_box_del((GF_Box *)ptr->meta);\n\tif (ptr->name) gf_free(ptr->name);\n\tif (ptr->groups) gf_isom_box_del((GF_Box *)ptr->groups);\n\tgf_free(ptr);\n}\n\nstatic void gf_isom_check_sample_desc(GF_TrackBox *trak)\n{\n\tGF_BitStream *bs;\n\tGF_UnknownBox *a;\n\tu32 i;\n\n\tif (!trak->Media || !trak->Media->information) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no media box !\\n\" ));\n\t\treturn;\n\t}\n\tif (!trak->Media->information->sampleTable) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no sample table !\\n\" ));\n\t\ttrak->Media->information->sampleTable = (GF_SampleTableBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STBL);\n\t}\n\n\tif (!trak->Media->information->sampleTable->SampleDescription) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Track with no sample description box !\\n\" ));\n\t\ttrak->Media->information->sampleTable->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STSD);\n\t\treturn;\n\t}\n\n\ti=0;\n\twhile ((a = (GF_UnknownBox*)gf_list_enum(trak->Media->information->sampleTable->SampleDescription->other_boxes, &i))) {\n\t\tswitch (a->type) {\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tcase GF_ISOM_BOX_TYPE_GHNT:\n\t\tcase GF_ISOM_BOX_TYPE_RTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_SRTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_FDP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_RRTP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_RTCP_STSD:\n\t\tcase GF_ISOM_BOX_TYPE_METX:\n\t\tcase GF_ISOM_BOX_TYPE_METT:\n\t\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\tcase GF_ISOM_BOX_TYPE_AVC1:\n\t\tcase GF_ISOM_BOX_TYPE_AVC2:\n\t\tcase GF_ISOM_BOX_TYPE_AVC3:\n\t\tcase GF_ISOM_BOX_TYPE_AVC4:\n\t\tcase GF_ISOM_BOX_TYPE_SVC1:\n\t\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HEV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC2:\n\t\tcase GF_ISOM_BOX_TYPE_HEV2:\n\t\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tcase GF_ISOM_BOX_TYPE_LHE1:\n\t\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tcase GF_ISOM_BOX_TYPE_ENCT:\n\t\tcase GF_ISOM_BOX_TYPE_DIMS:\n\t\tcase GF_ISOM_BOX_TYPE_AC3:\n\t\tcase GF_ISOM_BOX_TYPE_EC3:\n\t\tcase GF_ISOM_BOX_TYPE_LSR1:\n\t\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\tcase GF_ISOM_BOX_TYPE_SBTT:\n\t\tcase GF_ISOM_BOX_TYPE_MP3:\n\t\tcase GF_ISOM_BOX_TYPE_JPEG:\n\t\tcase GF_ISOM_BOX_TYPE_PNG:\n\t\tcase GF_ISOM_BOX_TYPE_JP2K:\n\t\t\tcontinue;\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Unexpected box %s in stsd!\\n\", gf_4cc_to_str(a->type)));\n\t\t\tcontinue;\n\t\t}\n\t\t//we are sure to have an unknown box here\n\t\tassert(a->type==GF_ISOM_BOX_TYPE_UNKNOWN);\n\n\t\tif (!a->data || (a->dataSize<8) ) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Sample description %s does not have at least 8 bytes!\\n\", gf_4cc_to_str(a->original_4cc) ));\n\t\t\tcontinue;\n\t\t}\n\t\telse if (a->dataSize > a->size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Sample description %s has wrong data size %d!\\n\", gf_4cc_to_str(a->original_4cc), a->dataSize));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*only process visual or audio*/\n\t\tswitch (trak->Media->handler->handlerType) {\n        case GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t{\n\t\t\tGF_GenericVisualSampleEntryBox *genv;\n\t\t\t/*remove entry*/\n\t\t\tgf_list_rem(trak->Media->information->sampleTable->SampleDescription->other_boxes, i-1);\n\t\t\tgenv = (GF_GenericVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRV);\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\t\t\tgenv->size = a->size-8;\n\t\t\tgf_isom_video_sample_entry_read((GF_VisualSampleEntryBox *) genv, bs);\n\n\t\t\tif (gf_bs_available(bs)) {\n\t\t\t\tu64 pos = gf_bs_get_position(bs);\n\t\t\t\t//try to parse as boxes\n\t\t\t\tGF_Err e = gf_isom_box_array_read((GF_Box *) genv, bs, gf_isom_box_add_default);\n\t\t\t\tif (e) {\n\t\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\t\tgenv->data_size = (u32) gf_bs_available(bs);\n\t\t\t\t\tif (genv->data_size) {\n\t\t\t\t\t\tgenv->data = a->data;\n\t\t\t\t\t\ta->data = NULL;\n\t\t\t\t\t\tmemmove(genv->data, genv->data + pos, genv->data_size);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgenv->data_size = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_bs_del(bs);\n\t\t\tif (!genv->data_size && genv->data) {\n\t\t\t\tgf_free(genv->data);\n\t\t\t\tgenv->data = NULL;\n\t\t\t}\n\n\t\t\tgenv->size = 0;\n\t\t\tgenv->EntryType = a->original_4cc;\n\t\t\tgf_isom_box_del((GF_Box *)a);\n\t\t\tgf_list_insert(trak->Media->information->sampleTable->SampleDescription->other_boxes, genv, i-1);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t{\n\t\t\tGF_GenericAudioSampleEntryBox *gena;\n\t\t\t/*remove entry*/\n\t\t\tgf_list_rem(trak->Media->information->sampleTable->SampleDescription->other_boxes, i-1);\n\t\t\tgena = (GF_GenericAudioSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRA);\n\t\t\tgena->size = a->size-8;\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\t\t\tgf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox *) gena, bs);\n\n\t\t\tif (gf_bs_available(bs)) {\n\t\t\t\tu64 pos = gf_bs_get_position(bs);\n\t\t\t\t//try to parse as boxes\n\t\t\t\tGF_Err e = gf_isom_box_array_read((GF_Box *) gena, bs, gf_isom_box_add_default);\n\t\t\t\tif (e) {\n\t\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\t\tgena->data_size = (u32) gf_bs_available(bs);\n\t\t\t\t\tif (gena->data_size) {\n\t\t\t\t\t\tgena->data = a->data;\n\t\t\t\t\t\ta->data = NULL;\n\t\t\t\t\t\tmemmove(gena->data, gena->data + pos, gena->data_size);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgena->data_size = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_bs_del(bs);\n\t\t\tif (!gena->data_size && gena->data) {\n\t\t\t\tgf_free(gena->data);\n\t\t\t\tgena->data = NULL;\n\t\t\t}\n\t\t\tgena->size = 0;\n\t\t\tgena->EntryType = a->original_4cc;\n\t\t\tgf_isom_box_del((GF_Box *)a);\n\t\t\tgf_list_insert(trak->Media->information->sampleTable->SampleDescription->other_boxes, gena, i-1);\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tGF_GenericSampleEntryBox *genm;\n\t\t\t/*remove entry*/\n\t\t\tgf_list_rem(trak->Media->information->sampleTable->SampleDescription->other_boxes, i-1);\n\t\t\tgenm = (GF_GenericSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRM);\n\t\t\tgenm->size = a->size-8;\n\t\t\tbs = gf_bs_new(a->data, a->dataSize, GF_BITSTREAM_READ);\n\n\t\t\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)genm, bs);\n\t\t\tif (e) return;\n\n\t\t\tgenm->size -= 8;\n\n\t\t\tif (gf_bs_available(bs)) {\n\t\t\t\tu64 pos = gf_bs_get_position(bs);\n\t\t\t\t//try to parse as boxes\n\t\t\t\tGF_Err e = gf_isom_box_array_read((GF_Box *) genm, bs, gf_isom_box_add_default);\n\t\t\t\tif (e) {\n\t\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\t\tgenm->data_size = (u32) gf_bs_available(bs);\n\t\t\t\t\tif (genm->data_size) {\n\t\t\t\t\t\tgenm->data = a->data;\n\t\t\t\t\t\ta->data = NULL;\n\t\t\t\t\t\tmemmove(genm->data, genm->data + pos, genm->data_size);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgenm->data_size = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_bs_del(bs);\n\t\t\tif (!genm->data_size && genm->data) {\n\t\t\t\tgf_free(genm->data);\n\t\t\t\tgenm->data = NULL;\n\t\t\t}\n\t\t\tgenm->size = 0;\n\n\t\t\tgenm->EntryType = a->original_4cc;\n\t\t\tgf_isom_box_del((GF_Box *)a);\n\t\t\tgf_list_insert(trak->Media->information->sampleTable->SampleDescription->other_boxes, genm, i-1);\n\t\t}\n\t\tbreak;\n\t\t}\n\n\t}\n}\n\n\nGF_Err trak_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (!a) return GF_OK;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_TKHD:\n\t\tif (ptr->Header) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->Header = (GF_TrackHeaderBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_EDTS:\n\t\tif (ptr->editBox) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->editBox = (GF_EditBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\t\tif (ptr->udta) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->udta = (GF_UserDataBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_META:\n\t\tif (ptr->meta) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->meta = (GF_MetaBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TREF:\n\t\tif (ptr->References) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->References = (GF_TrackReferenceBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_MDIA:\n\t\tif (ptr->Media) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->Media = (GF_MediaBox *)a;\n\t\t((GF_MediaBox *)a)->mediaTrack = ptr;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRGR:\n\t\tif (ptr->groups) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->groups = (GF_TrackGroupBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SENC:\n\t\tptr->sample_encryption = (GF_SampleEncryptionBox*)a;\n\t\treturn gf_isom_box_add_default((GF_Box *)ptr, a);\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif (((GF_UnknownUUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC) {\n\t\t\tptr->sample_encryption = (GF_SampleEncryptionBox*) a;\n\t\t\treturn gf_isom_box_add_default((GF_Box *)ptr, a);\n\t\t}\n\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err trak_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\te = gf_isom_box_array_read(s, bs, trak_AddBox);\n\tif (e) return e;\n\tgf_isom_check_sample_desc(ptr);\n\n\tif (!ptr->Header) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing TrackHeaderBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!ptr->Media) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tfor (i=0; i<gf_list_count(ptr->Media->information->sampleTable->other_boxes); i++) {\n\t\tGF_Box *a = gf_list_get(ptr->Media->information->sampleTable->other_boxes, i);\n\t\tif ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\tptr->sample_encryption = (struct __sample_encryption_box *) a;\n\t\t\tbreak;\n\t\t}\n\t\telse if (a->type == GF_ISOM_BOX_TYPE_SENC) {\n\t\t\tptr->sample_encryption = (struct __sample_encryption_box *)a;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Box *trak_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackBox, GF_ISOM_BOX_TYPE_TRAK);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trak_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tif (ptr->Header) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->Header, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->References) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->References, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->editBox) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->editBox, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->Media) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->Media, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->meta) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->meta, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->groups) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->groups, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->udta) {\n\t\te = gf_isom_box_write((GF_Box *) ptr->udta, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err trak_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\n\tif (ptr->Header) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->Header);\n\t\tif (e) return e;\n\t\tptr->size += ptr->Header->size;\n\t}\n\tif (ptr->udta) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->udta);\n\t\tif (e) return e;\n\t\tptr->size += ptr->udta->size;\n\t}\n\tif (ptr->References) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->References);\n\t\tif (e) return e;\n\t\tptr->size += ptr->References->size;\n\t}\n\tif (ptr->editBox) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->editBox);\n\t\tif (e) return e;\n\t\tptr->size += ptr->editBox->size;\n\t}\n\tif (ptr->Media) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->Media);\n\t\tif (e) return e;\n\t\tptr->size += ptr->Media->size;\n\t}\n\tif (ptr->meta) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->meta);\n\t\tif (e) return e;\n\t\tptr->size += ptr->meta->size;\n\t}\n\tif (ptr->groups) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->groups);\n\t\tif (e) return e;\n\t\tptr->size += ptr->groups->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stri_del(GF_Box *s)\n{\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->attribute_list) gf_free(ptr->attribute_list);\n\tgf_free(ptr);\n}\n\nGF_Err stri_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tsize_t i;\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\tptr->switch_group = gf_bs_read_u16(bs);\n\tptr->alternate_group = gf_bs_read_u16(bs);\n\tptr->sub_track_id = gf_bs_read_u32(bs);\n\tptr->size -= 8;\n\tptr->attribute_count = ptr->size / 4;\n\tGF_SAFE_ALLOC_N(ptr->attribute_list, (size_t)ptr->attribute_count, u32);\n\tif (!ptr->attribute_list) return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->attribute_count; i++) {\n\t\tptr->attribute_list[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stri_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackInformationBox, GF_ISOM_BOX_TYPE_STRI);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stri_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->switch_group);\n\tgf_bs_write_u16(bs, ptr->alternate_group);\n\tgf_bs_write_u32(bs, ptr->sub_track_id);\n\tfor (i = 0; i < ptr->attribute_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->attribute_list[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stri_Size(GF_Box *s)\n{\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\n\tptr->size += 8 + 4 * ptr->attribute_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid stsg_del(GF_Box *s)\n{\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->group_description_index) gf_free(ptr->group_description_index);\n\tgf_free(ptr);\n}\n\nGF_Err stsg_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tISOM_DECREASE_SIZE(s, 6);\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\tptr->nb_groups = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(s, ptr->nb_groups*4);\n\tGF_SAFE_ALLOC_N(ptr->group_description_index, ptr->nb_groups, u32);\n\tif (!ptr->group_description_index) return GF_OUT_OF_MEM;\n\tfor (i = 0; i < ptr->nb_groups; i++) {\n\t\tptr->group_description_index[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *stsg_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackSampleGroupBox, GF_ISOM_BOX_TYPE_STSG);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stsg_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->grouping_type);\n\tgf_bs_write_u16(bs, ptr->nb_groups);\n\tfor (i = 0; i < ptr->nb_groups; i++) {\n\t\tgf_bs_write_u32(bs, ptr->group_description_index[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err stsg_Size(GF_Box *s)\n{\n\tGF_SubTrackSampleGroupBox *ptr = (GF_SubTrackSampleGroupBox *)s;\n\tptr->size += 6 + 4 * ptr->nb_groups;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid strk_del(GF_Box *s)\n{\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->info) gf_isom_box_del((GF_Box *)ptr->info);\n\tgf_free(ptr);\n}\n\nGF_Err strk_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\tif (!a) return GF_OK;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_STRI:\n\t\tif (ptr->info) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->info = (GF_SubTrackInformationBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_STRD:\n\t\tif (ptr->strd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->strd = a;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err strk_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\te = gf_isom_box_array_read(s, bs, strk_AddBox);\n\tif (e) return e;\n\n\tif (!ptr->info) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing SubTrackInformationBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn e;\n}\n\nGF_Box *strk_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackBox, GF_ISOM_BOX_TYPE_STRK);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err strk_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tif (ptr->info) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->info, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err strk_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_SubTrackBox *ptr = (GF_SubTrackBox *)s;\n\n\tif (ptr->info) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->info);\n\t\tif (e) return e;\n\t\tptr->size += ptr->info->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Err tref_AddBox(GF_Box *ptr, GF_Box *a)\n{\n\treturn gf_isom_box_add_default(ptr, a);\n}\n\nvoid tref_del(GF_Box *s)\n{\n\tGF_TrackReferenceBox *ptr = (GF_TrackReferenceBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err tref_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(s, bs, gf_isom_box_add_default, s->type);\n}\n\nGF_Box *tref_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackReferenceBox, GF_ISOM_BOX_TYPE_TREF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tref_Write(GF_Box *s, GF_BitStream *bs)\n{\n//\tGF_TrackReferenceBox *ptr = (GF_TrackReferenceBox *)s;\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err tref_Size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid reftype_del(GF_Box *s)\n{\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tif (!ptr) return;\n\tif (ptr->trackIDs) gf_free(ptr->trackIDs);\n\tgf_free(ptr);\n}\n\n\nGF_Err reftype_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 bytesToRead;\n\tu32 i;\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\n\tbytesToRead = (u32) (ptr->size);\n\tif (!bytesToRead) return GF_OK;\n\n\tptr->trackIDCount = (u32) (bytesToRead) / sizeof(u32);\n\tptr->trackIDs = (u32 *) gf_malloc(ptr->trackIDCount * sizeof(u32));\n\tif (!ptr->trackIDs) return GF_OUT_OF_MEM;\n\n\tfor (i = 0; i < ptr->trackIDCount; i++) {\n\t\tptr->trackIDs[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *reftype_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackReferenceTypeBox, GF_ISOM_BOX_TYPE_REFT);\n\treturn (GF_Box *)tmp;\n}\n\n\nGF_Err reftype_AddRefTrack(GF_TrackReferenceTypeBox *ref, u32 trackID, u16 *outRefIndex)\n{\n\tu32 i;\n\tif (!ref || !trackID) return GF_BAD_PARAM;\n\n\tif (outRefIndex) *outRefIndex = 0;\n\t//don't add a dep if already here !!\n\tfor (i = 0; i < ref->trackIDCount; i++) {\n\t\tif (ref->trackIDs[i] == trackID) {\n\t\t\tif (outRefIndex) *outRefIndex = i+1;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tref->trackIDs = (u32 *) gf_realloc(ref->trackIDs, (ref->trackIDCount + 1) * sizeof(u32) );\n\tif (!ref->trackIDs) return GF_OUT_OF_MEM;\n\tref->trackIDs[ref->trackIDCount] = trackID;\n\tref->trackIDCount++;\n\tif (outRefIndex) *outRefIndex = ref->trackIDCount;\n\treturn GF_OK;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err reftype_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tptr->type = ptr->reference_type;\n\tif (!ptr->trackIDCount) return GF_OK;\n\n\te = gf_isom_box_write_header(s, bs);\n\tptr->type = GF_ISOM_BOX_TYPE_REFT;\n\tif (e) return e;\n\tfor (i = 0; i < ptr->trackIDCount; i++) {\n\t\tgf_bs_write_u32(bs, ptr->trackIDs[i]);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err reftype_Size(GF_Box *s)\n{\n\tGF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;\n\tif (!ptr->trackIDCount)\n\t\tptr->size=0;\n\telse\n\t\tptr->size += (ptr->trackIDCount * sizeof(u32));\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid trex_del(GF_Box *s)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err trex_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\n\tptr->trackID = gf_bs_read_u32(bs);\n\tptr->def_sample_desc_index = gf_bs_read_u32(bs);\n\tptr->def_sample_duration = gf_bs_read_u32(bs);\n\tptr->def_sample_size = gf_bs_read_u32(bs);\n\tptr->def_sample_flags = gf_bs_read_u32(bs);\n\n\tif (!ptr->def_sample_desc_index) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] TREX with default sample description set to 0, likely broken ! Fixing to 1\\n\" ));\n\t\tptr->def_sample_desc_index = 1;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *trex_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackExtendsBox, GF_ISOM_BOX_TYPE_TREX);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trex_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->trackID);\n\tgf_bs_write_u32(bs, ptr->def_sample_desc_index);\n\tgf_bs_write_u32(bs, ptr->def_sample_duration);\n\tgf_bs_write_u32(bs, ptr->def_sample_size);\n\tgf_bs_write_u32(bs, ptr->def_sample_flags);\n\treturn GF_OK;\n}\n\nGF_Err trex_Size(GF_Box *s)\n{\n\tGF_TrackExtendsBox *ptr = (GF_TrackExtendsBox *)s;\n\tptr->size += 20;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid trep_del(GF_Box *s)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err trep_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\n\tptr->trackID = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\treturn gf_isom_box_array_read(s, bs, gf_isom_box_add_default);\n}\n\nGF_Box *trep_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackExtensionPropertiesBox, GF_ISOM_BOX_TYPE_TREP);\n\ttmp->other_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trep_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->trackID);\n\treturn GF_OK;\n}\n\nGF_Err trep_Size(GF_Box *s)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid trun_del(GF_Box *s)\n{\n\tGF_TrunEntry *p;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->entries)) {\n\t\tp = (GF_TrunEntry*)gf_list_get(ptr->entries, 0);\n\t\tgf_list_rem(ptr->entries, 0);\n\t\tgf_free(p);\n\t}\n\tgf_list_del(ptr->entries);\n\tif (ptr->cache) gf_bs_del(ptr->cache);\n\tgf_free(ptr);\n}\n\nGF_Err trun_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrunEntry *p;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\n\t//check this is a good file\n\tif ((ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) && (ptr->flags & GF_ISOM_TRUN_FLAGS))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->sample_count = gf_bs_read_u32(bs);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tptr->data_offset = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t}\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\tptr->first_sample_flags = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t}\n\n\t//read each entry (even though nothing may be written)\n\tfor (i=0; i<ptr->sample_count; i++) {\n\t\tu32 trun_size = 0;\n\t\tp = (GF_TrunEntry *) gf_malloc(sizeof(GF_TrunEntry));\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\tmemset(p, 0, sizeof(GF_TrunEntry));\n\n\t\tif (ptr->flags & GF_ISOM_TRUN_DURATION) {\n\t\t\tp->Duration = gf_bs_read_u32(bs);\n\t\t\ttrun_size += 4;\n\t\t}\n\t\tif (ptr->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\tp->size = gf_bs_read_u32(bs);\n\t\t\ttrun_size += 4;\n\t\t}\n\t\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\t\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\tp->flags = gf_bs_read_u32(bs);\n\t\t\ttrun_size += 4;\n\t\t}\n\t\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) {\n\t\t\tif (ptr->version==0) {\n\t\t\t\tp->CTS_Offset = (u32) gf_bs_read_u32(bs);\n\t\t\t} else {\n\t\t\t\tp->CTS_Offset = (s32) gf_bs_read_u32(bs);\n\t\t\t}\n\t\t}\n\t\tgf_list_add(ptr->entries, p);\n\t\tISOM_DECREASE_SIZE(ptr, trun_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *trun_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentRunBox, GF_ISOM_BOX_TYPE_TRUN);\n\ttmp->entries = gf_list_new();\n\t//NO FLAGS SET BY DEFAULT\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trun_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrunEntry *p;\n\tGF_Err e;\n\tu32 i, count;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->sample_count);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tgf_bs_write_u32(bs, ptr->data_offset);\n\t}\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\tgf_bs_write_u32(bs, ptr->first_sample_flags);\n\t}\n\n\t//if nothing to do, this will be skipped automatically\n\tcount = gf_list_count(ptr->entries);\n\tfor (i=0; i<count; i++) {\n\t\tp = (GF_TrunEntry*)gf_list_get(ptr->entries, i);\n\n\t\tif (ptr->flags & GF_ISOM_TRUN_DURATION) {\n\t\t\tgf_bs_write_u32(bs, p->Duration);\n\t\t}\n\t\tif (ptr->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\tgf_bs_write_u32(bs, p->size);\n\t\t}\n\t\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\t\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\tgf_bs_write_u32(bs, p->flags);\n\t\t}\n\t\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) {\n\t\t\tif (ptr->version==0) {\n\t\t\t\tgf_bs_write_u32(bs, p->CTS_Offset);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, (u32) p->CTS_Offset);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err trun_Size(GF_Box *s)\n{\n\tu32 i, count;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\n\tptr->size += 4;\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) ptr->size += 4;\n\n\t//if nothing to do, this will be skipped automatically\n\tcount = gf_list_count(ptr->entries);\n\tfor (i=0; i<count; i++) {\n\t\tif (ptr->flags & GF_ISOM_TRUN_DURATION) ptr->size += 4;\n\t\tif (ptr->flags & GF_ISOM_TRUN_SIZE) ptr->size += 4;\n\t\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\t\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) ptr->size += 4;\n\t\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) ptr->size += 4;\n\t}\n\n\treturn GF_OK;\n}\n\n\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nvoid tsro_del(GF_Box *s)\n{\n\tGF_TimeOffHintEntryBox *tsro = (GF_TimeOffHintEntryBox *)s;\n\tgf_free(tsro);\n}\n\nGF_Err tsro_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TimeOffHintEntryBox *ptr = (GF_TimeOffHintEntryBox *)s;\n\tptr->TimeOffset = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *tsro_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeOffHintEntryBox, GF_ISOM_BOX_TYPE_TSRO);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tsro_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TimeOffHintEntryBox *ptr = (GF_TimeOffHintEntryBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->TimeOffset);\n\treturn GF_OK;\n}\n\nGF_Err tsro_Size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid udta_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\tif (ptr == NULL) return;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\tgf_isom_box_array_del(map->other_boxes);\n\t\tgf_free(map);\n\t}\n\tgf_list_del(ptr->recordList);\n\tgf_free(ptr);\n}\n\nGF_UserDataMap *udta_getEntry(GF_UserDataBox *ptr, u32 box_type, bin128 *uuid)\n{\n\tu32 i;\n\tGF_UserDataMap *map;\n\tif (ptr == NULL) return NULL;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\tif (map->boxType == box_type) {\n\t\t\tif ((box_type != GF_ISOM_BOX_TYPE_UUID) || !uuid) return map;\n\t\t\tif (!memcmp(map->uuid, *uuid, 16)) return map;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nGF_Err udta_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_Err e;\n\tu32 box_type;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\tif (!ptr) return GF_BAD_PARAM;\n\tif (!a) return GF_OK;\n\n\t/* for unknown udta boxes, we reference them by their original box type */\n\tbox_type = a->type;\n\tif (box_type == GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tGF_UnknownBox* unkn = (GF_UnknownBox *)a;\n\t\tif (unkn)\n\t\t\tbox_type = unkn->original_4cc;\n\t}\n\n\tmap = udta_getEntry(ptr, box_type, (a->type==GF_ISOM_BOX_TYPE_UUID) ? & ((GF_UUIDBox *)a)->uuid : NULL);\n\tif (map == NULL) {\n\t\tmap = (GF_UserDataMap *) gf_malloc(sizeof(GF_UserDataMap));\n\t\tif (map == NULL) return GF_OUT_OF_MEM;\n\t\tmemset(map, 0, sizeof(GF_UserDataMap));\n\n\t\tmap->boxType = box_type;\n\t\tif (a->type == GF_ISOM_BOX_TYPE_UUID)\n\t\t\tmemcpy(map->uuid, ((GF_UUIDBox *)a)->uuid, 16);\n\t\tmap->other_boxes = gf_list_new();\n\t\tif (!map->other_boxes) {\n\t\t\tgf_free(map);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(ptr->recordList, map);\n\t\tif (e) return e;\n\t}\n\treturn gf_list_add(map->other_boxes, a);\n}\n\n\nGF_Err udta_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, udta_AddBox);\n}\n\nGF_Box *udta_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UserDataBox, GF_ISOM_BOX_TYPE_UDTA);\n\ttmp->recordList = gf_list_new();\n\tif (!tmp->recordList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err udta_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\t//warning: here we are not passing the actual \"parent\" of the list\n\t\t//but the UDTA box. The parent itself is not an box, we don't care about it\n\t\te = gf_isom_box_array_write(s, map->other_boxes, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err udta_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_UserDataMap *map;\n\tGF_UserDataBox *ptr = (GF_UserDataBox *)s;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(ptr->recordList, &i))) {\n\t\t//warning: here we are not passing the actual \"parent\" of the list\n\t\t//but the UDTA box. The parent itself is not an box, we don't care about it\n\t\te = gf_isom_box_array_size(s, map->other_boxes);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid vmhd_del(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err vmhd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\n\tptr->reserved = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\n\nGF_Box *vmhd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_VideoMediaHeaderBox, GF_ISOM_BOX_TYPE_VMHD);\n\ttmp->flags = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err vmhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err vmhd_Size(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tptr->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid void_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err void_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tif (s->size) return GF_ISOM_INVALID_FILE;\n\treturn GF_OK;\n}\n\nGF_Box *void_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Box, GF_ISOM_BOX_TYPE_VOID);\n\treturn tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err void_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tgf_bs_write_u32(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err void_Size(GF_Box *s)\n{\n\ts->size = 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *pdin_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProgressiveDownloadBox, GF_ISOM_BOX_TYPE_PDIN);\n\ttmp->flags = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid pdin_del(GF_Box *s)\n{\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->rates) gf_free(ptr->rates);\n\tif (ptr->times) gf_free(ptr->times);\n\tgf_free(ptr);\n}\n\n\nGF_Err pdin_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox*)s;\n\n\tptr->count = (u32) (ptr->size) / 8;\n\tptr->rates = (u32*)gf_malloc(sizeof(u32)*ptr->count);\n\tptr->times = (u32*)gf_malloc(sizeof(u32)*ptr->count);\n\tfor (i=0; i<ptr->count; i++) {\n\t\tptr->rates[i] = gf_bs_read_u32(bs);\n\t\tptr->times[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pdin_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tfor (i=0; i<ptr->count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->rates[i]);\n\t\tgf_bs_write_u32(bs, ptr->times[i]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err pdin_Size(GF_Box *s)\n{\n\tGF_ProgressiveDownloadBox *ptr = (GF_ProgressiveDownloadBox *)s;\n\tptr->size += 8*ptr->count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *sdtp_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleDependencyTypeBox, GF_ISOM_BOX_TYPE_SDTP);\n\ttmp->flags = 1;\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid sdtp_del(GF_Box *s)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sample_info) gf_free(ptr->sample_info);\n\tgf_free(ptr);\n}\n\n\nGF_Err sdtp_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;\n\n\t/*out-of-order sdtp, assume no padding at the end*/\n\tif (!ptr->sampleCount) ptr->sampleCount = (u32) ptr->size;\n\telse if (ptr->sampleCount > (u32) ptr->size) return GF_ISOM_INVALID_FILE;\n\n\tptr->sample_info = (u8 *) gf_malloc(sizeof(u8)*ptr->sampleCount);\n\tgf_bs_read_data(bs, (char*)ptr->sample_info, ptr->sampleCount);\n\tISOM_DECREASE_SIZE(ptr, ptr->sampleCount);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err sdtp_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, (char*)ptr->sample_info, ptr->sampleCount);\n\treturn GF_OK;\n}\n\nGF_Err sdtp_Size(GF_Box *s)\n{\n\tGF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox *)s;\n\tptr->size += ptr->sampleCount;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *pasp_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PixelAspectRatioBox, GF_ISOM_BOX_TYPE_PASP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid pasp_del(GF_Box *s)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox*)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err pasp_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox*)s;\n\tptr->hSpacing = gf_bs_read_u32(bs);\n\tptr->vSpacing = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 8);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pasp_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->hSpacing);\n\tgf_bs_write_u32(bs, ptr->vSpacing);\n\treturn GF_OK;\n}\n\nGF_Err pasp_Size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *clap_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_CleanAppertureBox, GF_ISOM_BOX_TYPE_CLAP);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid clap_del(GF_Box *s)\n{\n\tGF_CleanAppertureBox *ptr = (GF_CleanAppertureBox*)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err clap_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CleanAppertureBox *ptr = (GF_CleanAppertureBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 32);\n\tptr->cleanApertureWidthN = gf_bs_read_u32(bs);\n\tptr->cleanApertureWidthD = gf_bs_read_u32(bs);\n\tptr->cleanApertureHeightN = gf_bs_read_u32(bs);\n\tptr->cleanApertureHeightD = gf_bs_read_u32(bs);\n\tptr->horizOffN = gf_bs_read_u32(bs);\n\tptr->horizOffD = gf_bs_read_u32(bs);\n\tptr->vertOffN = gf_bs_read_u32(bs);\n\tptr->vertOffD = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err clap_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_CleanAppertureBox *ptr = (GF_CleanAppertureBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->cleanApertureWidthN);\n\tgf_bs_write_u32(bs, ptr->cleanApertureWidthD);\n\tgf_bs_write_u32(bs, ptr->cleanApertureHeightN);\n\tgf_bs_write_u32(bs, ptr->cleanApertureHeightD);\n\tgf_bs_write_u32(bs, ptr->horizOffN);\n\tgf_bs_write_u32(bs, ptr->horizOffD);\n\tgf_bs_write_u32(bs, ptr->vertOffN);\n\tgf_bs_write_u32(bs, ptr->vertOffD);\n\treturn GF_OK;\n}\n\nGF_Err clap_Size(GF_Box *s)\n{\n\ts->size += 32;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *metx_New()\n{\n\t//type is overridden by the box constructor\n\tISOM_DECL_BOX_ALLOC(GF_MetaDataSampleEntryBox, GF_ISOM_BOX_TYPE_METX);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid metx_del(GF_Box *s)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->content_encoding) gf_free(ptr->content_encoding);\n\tif (ptr->xml_namespace) gf_free(ptr->xml_namespace);\n\tif (ptr->xml_schema_loc) gf_free(ptr->xml_schema_loc);\n\tif (ptr->mime_type) gf_free(ptr->mime_type);\n\tif (ptr->config) gf_isom_box_del((GF_Box *)ptr->config);\n\tgf_free(ptr);\n}\n\n\nGF_Err metx_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_SINF:\n\t\tgf_list_add(ptr->protections, a);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TXTC:\n\t\t//we allow the config box on metx\n\t\tif (ptr->config) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->config = (GF_TextConfigBox *)a;\n\t\tbreak;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err metx_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 size, i;\n\tGF_Err e;\n\tchar *str;\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tsize = (u32) ptr->size - 8;\n\tstr = gf_malloc(sizeof(char)*size);\n\n\ti=0;\n\n\twhile (size) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tsize--;\n\t\tif (!str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tptr->xml_namespace = gf_strdup(str);\n\t\t} else {\n\t\t\tptr->content_encoding = gf_strdup(str);\n\t\t}\n\t}\n\n\ti=0;\n\twhile (size) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tsize--;\n\t\tif (!str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\t\tif (i) {\n\t\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\t\tptr->xml_schema_loc = gf_strdup(str);\n\t\t\t} else {\n\t\t\t\tptr->xml_namespace = gf_strdup(str);\n\t\t\t}\n\t\t}\n\n\t\ti=0;\n\t\twhile (size) {\n\t\t\tstr[i] = gf_bs_read_u8(bs);\n\t\t\tsize--;\n\t\t\tif (!str[i])\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t}\n\t\tif (i) {\n\t\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\t\tptr->mime_type = gf_strdup(str);\n\t\t\t} else {\n\t\t\t\tptr->xml_schema_loc = gf_strdup(str);\n\t\t\t}\n\t\t}\n\t}\n\t//mett, sbtt, stxt, stpp\n\telse {\n\t\tif (i) ptr->mime_type = gf_strdup(str);\n\t}\n\tptr->size = size;\n\tgf_free(str);\n\treturn gf_isom_box_array_read(s, bs, metx_AddBox);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err metx_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\n\tif (ptr->type!=GF_ISOM_BOX_TYPE_STPP) {\n\t\tif (ptr->content_encoding)\n\t\t\tgf_bs_write_data(bs, ptr->content_encoding, (u32) strlen(ptr->content_encoding));\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\t\tif (ptr->xml_namespace)\n\t\t\tgf_bs_write_data(bs, ptr->xml_namespace, (u32) strlen(ptr->xml_namespace));\n\n\t\tgf_bs_write_u8(bs, 0);\n\n\t\tif (ptr->xml_schema_loc)\n\t\t\tgf_bs_write_data(bs, ptr->xml_schema_loc, (u32) strlen(ptr->xml_schema_loc));\n\t\tgf_bs_write_u8(bs, 0);\n\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tif (ptr->mime_type)\n\t\t\t\tgf_bs_write_data(bs, ptr->mime_type, (u32) strlen(ptr->mime_type));\n\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\t//mett, sbtt, stxt\n\telse {\n\t\tif (ptr->mime_type)\n\t\t\tgf_bs_write_data(bs, ptr->mime_type, (u32) strlen(ptr->mime_type));\n\n\t\tgf_bs_write_u8(bs, 0);\n\n\t\tif (ptr->config) {\n\t\t\tgf_isom_box_write((GF_Box *)ptr->config, bs);\n\t\t}\n\t}\n\n\treturn gf_isom_box_array_write(s, ptr->protections, bs);\n}\n\nGF_Err metx_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tptr->size += 8;\n\n\tif (ptr->type!=GF_ISOM_BOX_TYPE_STPP) {\n\t\tif (ptr->content_encoding)\n\t\t\tptr->size += strlen(ptr->content_encoding);\n\t\tptr->size++;\n\t}\n\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\n\t\tif (ptr->xml_namespace)\n\t\t\tptr->size += strlen(ptr->xml_namespace);\n\t\tptr->size++;\n\n\t\tif (ptr->xml_schema_loc)\n\t\t\tptr->size += strlen(ptr->xml_schema_loc);\n\t\tptr->size++;\n\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tif (ptr->mime_type)\n\t\t\t\tptr->size += strlen(ptr->mime_type);\n\t\t\tptr->size++;\n\t\t}\n\n\t}\n\t//mett, sbtt, stxt\n\telse {\n\t\tif (ptr->mime_type)\n\t\t\tptr->size += strlen(ptr->mime_type);\n\t\tptr->size++;\n\n\t\tif (ptr->config) {\n\t\t\te = gf_isom_box_size((GF_Box *)ptr->config);\n\t\t\tif (e) return e;\n\t\t\tptr->size += ptr->config->size;\n\t\t}\n\t}\n\treturn gf_isom_box_array_size(s, ptr->protections);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/* SimpleTextSampleEntry */\nGF_Box *txtc_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextConfigBox, GF_ISOM_BOX_TYPE_TXTC);\n\treturn (GF_Box *)tmp;\n}\n\n\nvoid txtc_del(GF_Box *s)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox*)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->config) gf_free(ptr->config);\n\tgf_free(ptr);\n}\n\nGF_Err txtc_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 size, i;\n\tchar *str;\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox*)s;\n\n\tsize = (u32) ptr->size;\n\tstr = (char *)gf_malloc(sizeof(char)*size);\n\n\ti=0;\n\n\twhile (size) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tsize--;\n\t\tif (!str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) ptr->config = gf_strdup(str);\n\tgf_free(str);\n\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err txtc_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox *)s;\n\tGF_Err e = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->config)\n\t\tgf_bs_write_data(bs, ptr->config, (u32) strlen(ptr->config));\n\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err txtc_Size(GF_Box *s)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox *)s;\n\tif (ptr->config)\n\t\tptr->size += strlen(ptr->config);\n\tptr->size++;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dac3_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);\n\treturn (GF_Box *)tmp;\n}\n\nGF_Box *dec3_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);\n\ttmp->cfg.is_ec3 = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid dac3_del(GF_Box *s)\n{\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tgf_free(ptr);\n}\n\n\nGF_Err dac3_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\tif (ptr->cfg.is_ec3) {\n\t\tu32 i;\n\t\tptr->cfg.brcode = gf_bs_read_int(bs, 13);\n\t\tptr->cfg.nb_streams = gf_bs_read_int(bs, 3) + 1;\n\t\tfor (i=0; i<ptr->cfg.nb_streams; i++) {\n\t\t\tptr->cfg.streams[i].fscod = gf_bs_read_int(bs, 2);\n\t\t\tptr->cfg.streams[i].bsid = gf_bs_read_int(bs, 5);\n\t\t\tptr->cfg.streams[i].bsmod = gf_bs_read_int(bs, 5);\n\t\t\tptr->cfg.streams[i].acmod = gf_bs_read_int(bs, 3);\n\t\t\tptr->cfg.streams[i].lfon = gf_bs_read_int(bs, 1);\n\t\t\tgf_bs_read_int(bs, 3);\n\t\t\tptr->cfg.streams[i].nb_dep_sub = gf_bs_read_int(bs, 4);\n\t\t\tif (ptr->cfg.streams[i].nb_dep_sub) {\n\t\t\t\tptr->cfg.streams[i].chan_loc = gf_bs_read_int(bs, 9);\n\t\t\t} else {\n\t\t\t\tgf_bs_read_int(bs, 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tptr->cfg.nb_streams = 1;\n\t\tptr->cfg.streams[0].fscod = gf_bs_read_int(bs, 2);\n\t\tptr->cfg.streams[0].bsid = gf_bs_read_int(bs, 5);\n\t\tptr->cfg.streams[0].bsmod = gf_bs_read_int(bs, 3);\n\t\tptr->cfg.streams[0].acmod = gf_bs_read_int(bs, 3);\n\t\tptr->cfg.streams[0].lfon = gf_bs_read_int(bs, 1);\n\t\tptr->cfg.brcode = gf_bs_read_int(bs, 5);\n\t\tgf_bs_read_int(bs, 5);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err dac3_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\n\tif (ptr->cfg.is_ec3) {\n\t\tu32 i;\n\t\tgf_bs_write_int(bs, ptr->cfg.brcode, 13);\n\t\tgf_bs_write_int(bs, ptr->cfg.nb_streams - 1, 3);\n\t\tfor (i=0; i<ptr->cfg.nb_streams; i++) {\n\t\t\tgf_bs_write_int(bs, ptr->cfg.streams[i].fscod, 2);\n\t\t\tgf_bs_write_int(bs, ptr->cfg.streams[i].bsid, 5);\n\t\t\tgf_bs_write_int(bs, ptr->cfg.streams[i].bsmod, 5);\n\t\t\tgf_bs_write_int(bs, ptr->cfg.streams[i].acmod, 3);\n\t\t\tgf_bs_write_int(bs, ptr->cfg.streams[i].lfon, 1);\n\t\t\tgf_bs_write_int(bs, 0, 3);\n\t\t\tgf_bs_write_int(bs, ptr->cfg.streams[i].nb_dep_sub, 4);\n\t\t\tif (ptr->cfg.streams[i].nb_dep_sub) {\n\t\t\t\tgf_bs_write_int(bs, ptr->cfg.streams[i].chan_loc, 9);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(bs, 0, 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tgf_bs_write_int(bs, ptr->cfg.streams[0].fscod, 2);\n\t\tgf_bs_write_int(bs, ptr->cfg.streams[0].bsid, 5);\n\t\tgf_bs_write_int(bs, ptr->cfg.streams[0].bsmod, 3);\n\t\tgf_bs_write_int(bs, ptr->cfg.streams[0].acmod, 3);\n\t\tgf_bs_write_int(bs, ptr->cfg.streams[0].lfon, 1);\n\t\tgf_bs_write_int(bs, ptr->cfg.brcode, 5);\n\t\tgf_bs_write_int(bs, 0, 5);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err dac3_Size(GF_Box *s)\n{\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\n\tif (ptr->cfg.is_ec3) {\n\t\tu32 i;\n\t\ts->size += 2;\n\t\tfor (i=0; i<ptr->cfg.nb_streams; i++) {\n\t\t\ts->size += 3;\n\t\t\tif (ptr->cfg.streams[i].nb_dep_sub)\n\t\t\t\ts->size += 1;\n\t\t}\n\t} else {\n\t\ts->size += 3;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid lsrc_del(GF_Box *s)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->hdr) gf_free(ptr->hdr);\n\tgf_free(ptr);\n}\n\n\nGF_Err lsrc_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tptr->hdr_size = (u32) ptr->size;\n\tptr->hdr = gf_malloc(sizeof(char)*ptr->hdr_size);\n\tgf_bs_read_data(bs, ptr->hdr, ptr->hdr_size);\n\treturn GF_OK;\n}\n\nGF_Box *lsrc_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LASERConfigurationBox, GF_ISOM_BOX_TYPE_LSRC);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err lsrc_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->hdr, ptr->hdr_size);\n\treturn GF_OK;\n}\n\nGF_Err lsrc_Size(GF_Box *s)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tptr->size += ptr->hdr_size;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid lsr1_del(GF_Box *s)\n{\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->slc) gf_odf_desc_del((GF_Descriptor *)ptr->slc);\n\tif (ptr->lsr_config) gf_isom_box_del((GF_Box *) ptr->lsr_config);\n\tif (ptr->descr) gf_isom_box_del((GF_Box *) ptr->descr);\n\tgf_free(ptr);\n}\n\nGF_Err lsr1_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_LSRC:\n\t\tif (ptr->lsr_config) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->lsr_config = (GF_LASERConfigurationBox *)a;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_M4DS:\n\t\tif (ptr->descr) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->descr = (GF_MPEG4ExtensionDescriptorsBox *)a;\n\t\tbreak;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err lsr1_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox*)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\n\treturn gf_isom_box_array_read(s, bs, lsr1_AddBox);\n}\n\nGF_Box *lsr1_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LASeRSampleEntryBox, GF_ISOM_BOX_TYPE_LSR1);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err lsr1_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tif (ptr->lsr_config) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->lsr_config, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->descr) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->descr, bs);\n\t\tif (e) return e;\n\t}\n\treturn e;\n}\n\nGF_Err lsr1_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox *)s;\n\n\ts->size += 8;\n\tif (ptr->lsr_config) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->lsr_config);\n\t\tif (e) return e;\n\t\tptr->size += ptr->lsr_config->size;\n\t}\n\tif (ptr->descr) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->descr);\n\t\tif (e) return e;\n\t\tptr->size += ptr->descr->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid sidx_del(GF_Box *s)\n{\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->refs) gf_free(ptr->refs);\n\tgf_free(ptr);\n}\n\nGF_Err sidx_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\tptr->reference_ID = gf_bs_read_u32(bs);\n\tptr->timescale = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 8);\n\n\tif (ptr->version==0) {\n\t\tptr->earliest_presentation_time = gf_bs_read_u32(bs);\n\t\tptr->first_offset = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t} else {\n\t\tptr->earliest_presentation_time = gf_bs_read_u64(bs);\n\t\tptr->first_offset = gf_bs_read_u64(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t}\n\tgf_bs_read_u16(bs); /* reserved */\n\tptr->nb_refs = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tptr->refs = gf_malloc(sizeof(GF_SIDXReference)*ptr->nb_refs);\n\tfor (i=0; i<ptr->nb_refs; i++) {\n\t\tptr->refs[i].reference_type = gf_bs_read_int(bs, 1);\n\t\tptr->refs[i].reference_size = gf_bs_read_int(bs, 31);\n\t\tptr->refs[i].subsegment_duration = gf_bs_read_u32(bs);\n\t\tptr->refs[i].starts_with_SAP = gf_bs_read_int(bs, 1);\n\t\tptr->refs[i].SAP_type = gf_bs_read_int(bs, 3);\n\t\tptr->refs[i].SAP_delta_time = gf_bs_read_int(bs, 28);\n\n\t\tISOM_DECREASE_SIZE(ptr, 12);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *sidx_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SegmentIndexBox, GF_ISOM_BOX_TYPE_SIDX);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err sidx_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->reference_ID);\n\tgf_bs_write_u32(bs, ptr->timescale);\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, (u32) ptr->earliest_presentation_time);\n\t\tgf_bs_write_u32(bs, (u32) ptr->first_offset);\n\t} else {\n\t\tgf_bs_write_u64(bs, ptr->earliest_presentation_time);\n\t\tgf_bs_write_u64(bs, ptr->first_offset);\n\t}\n\tgf_bs_write_u16(bs, 0);\n\tgf_bs_write_u16(bs, ptr->nb_refs);\n\tfor (i=0; i<ptr->nb_refs; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->refs[i].reference_type, 1);\n\t\tgf_bs_write_int(bs, ptr->refs[i].reference_size, 31);\n\t\tgf_bs_write_u32(bs, ptr->refs[i].subsegment_duration);\n\t\tgf_bs_write_int(bs, ptr->refs[i].starts_with_SAP, 1);\n\t\tgf_bs_write_int(bs, ptr->refs[i].SAP_type, 3);\n\t\tgf_bs_write_int(bs, ptr->refs[i].SAP_delta_time, 28);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sidx_Size(GF_Box *s)\n{\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\tptr->size += 12;\n\tif (ptr->version==0) {\n\t\tptr->size += 8;\n\t} else {\n\t\tptr->size += 16;\n\t}\n\tptr->size += ptr->nb_refs * 12;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ssix_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->subsegments) {\n\t\tfor (i = 0; i < ptr->subsegment_count; i++) {\n\t\t\tGF_Subsegment *subsegment = &ptr->subsegments[i];\n\t\t\tif (subsegment->levels) gf_free(subsegment->levels);\n\t\t\tif (subsegment->range_sizes) gf_free(subsegment->range_sizes);\n\t\t}\n\t\tgf_free(ptr->subsegments);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err ssix_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i,j;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\tif (ptr->size < 4) return GF_BAD_PARAM;\n\tptr->subsegment_count = gf_bs_read_u32(bs);\n\tptr->size -= 4;\n\tptr->subsegments = gf_malloc(ptr->subsegment_count*sizeof(GF_Subsegment));\n\tfor (i = 0; i < ptr->subsegment_count; i++) {\n\t\tGF_Subsegment *subseg = &ptr->subsegments[i];\n\t\tif (ptr->size < 4) return GF_BAD_PARAM;\n\t\tsubseg->range_count = gf_bs_read_u32(bs);\n\t\tptr->size -= 4;\n\t\tif (ptr->size < subseg->range_count*4) return GF_BAD_PARAM;\n\t\tsubseg->levels = gf_malloc(sizeof(u8)*subseg->range_count);\n\t\tsubseg->range_sizes = gf_malloc(sizeof(u32)*subseg->range_count);\n\t\tfor (j = 0; j < subseg->range_count; j++) {\n\t\t\tsubseg->levels[j] = gf_bs_read_u8(bs);\n\t\t\tsubseg->range_sizes[j] = gf_bs_read_u24(bs);\n\t\t\tptr->size -= 4;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *ssix_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubsegmentIndexBox, GF_ISOM_BOX_TYPE_SSIX);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ssix_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->subsegment_count);\n\tfor (i = 0; i<ptr->subsegment_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->subsegments[i].range_count);\n\t\tfor (j = 0; j < ptr->subsegment_count; j++) {\n\t\t\tgf_bs_write_u8(bs, ptr->subsegments[i].levels[j]);\n\t\t\tgf_bs_write_u24(bs, ptr->subsegments[i].range_sizes[j]);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ssix_Size(GF_Box *s)\n{\n\tu32 i;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\tptr->size += 4;\n\tfor (i = 0; i < ptr->subsegment_count; i++) {\n\t\tptr->size += 4 + 4 * ptr->subsegments[i].range_count;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid leva_del(GF_Box *s)\n{\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->levels) gf_free(ptr->levels);\n\tgf_free(ptr);\n}\n\nGF_Err leva_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\tif (ptr->size < 4) return GF_BAD_PARAM;\n\tptr->level_count = gf_bs_read_u8(bs);\n\tptr->size -= 4;\n\tGF_SAFE_ALLOC_N(ptr->levels, ptr->level_count, GF_LevelAssignment);\n\tfor (i = 0; i < ptr->level_count; i++) {\n\t\tGF_LevelAssignment *level = &ptr->levels[i];\n\t\tu8 tmp;\n\t\tif (ptr->size < 5) return GF_BAD_PARAM;\n\t\tlevel->track_id = gf_bs_read_u32(bs);\n\t\ttmp = gf_bs_read_u8(bs);\n\t\tlevel->padding_flag = tmp >> 7;\n\t\tlevel->type = tmp & 0x7F;\n\t\tif (level->type == 0) {\n\t\t\tlevel->grouping_type = gf_bs_read_u32(bs);\n\t\t}\n\t\telse if (level->type == 1) {\n\t\t\tlevel->grouping_type = gf_bs_read_u32(bs);\n\t\t\tlevel->grouping_type_parameter = gf_bs_read_u32(bs);\n\t\t}\n\t\telse if (level->type == 4) {\n\t\t\tlevel->sub_track_id = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *leva_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_LevelAssignmentBox, GF_ISOM_BOX_TYPE_LEVA);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err leva_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->level_count);\n\tfor (i = 0; i<ptr->level_count; i++) {\n\t\tgf_bs_write_u32(bs, ptr->levels[i].track_id);\n\t\tgf_bs_write_u8(bs, ptr->levels[i].padding_flag << 7 | (ptr->levels[i].type & 0x7F));\n\t\tif (ptr->levels[i].type == 0) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type);\n\t\t}\n\t\telse if (ptr->levels[i].type == 1) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type);\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].grouping_type_parameter);\n\t\t}\n\t\telse if (ptr->levels[i].type == 4) {\n\t\t\tgf_bs_write_u32(bs, ptr->levels[i].sub_track_id);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err leva_Size(GF_Box *s)\n{\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\n\tptr->size += 1;\n\tfor (i = 0; i < ptr->level_count; i++) {\n\t\tptr->size += 5;\n\t\tif (ptr->levels[i].type == 0 || ptr->levels[i].type == 4) {\n\t\t\tptr->size += 4;\n\t\t}\n\t\telse if (ptr->levels[i].type == 1) {\n\t\t\tptr->size += 8;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *pcrb_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PcrInfoBox, GF_ISOM_BOX_TYPE_PCRB);\n\treturn (GF_Box *)tmp;\n}\n\nvoid pcrb_del(GF_Box *s)\n{\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->pcr_values) gf_free(ptr->pcr_values);\n\tgf_free(ptr);\n}\n\nGF_Err pcrb_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\tptr->subsegment_count = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tptr->pcr_values = gf_malloc(sizeof(u64)*ptr->subsegment_count);\n\tfor (i=0; i<ptr->subsegment_count; i++) {\n\t\tu64 data1 = gf_bs_read_u32(bs);\n\t\tu64 data2 = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 6);\n\t\tptr->pcr_values[i] = (data1 << 10) | (data2 >> 6);\n\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pcrb_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->subsegment_count);\n\n\tfor (i=0; i<ptr->subsegment_count; i++ ) {\n\t\tu32 data1 = (u32) (ptr->pcr_values[i] >> 10);\n\t\tu16 data2 = (u16) (ptr->pcr_values[i] << 6);\n\n\t\tgf_bs_write_u32(bs, data1);\n\t\tgf_bs_write_u16(bs, data2);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err pcrb_Size(GF_Box *s)\n{\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\n\tptr->size += 4;\n\tptr->size += ptr->subsegment_count * 6;\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *subs_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubSampleInformationBox, GF_ISOM_BOX_TYPE_SUBS);\n\ttmp->Samples = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid subs_del(GF_Box *s)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->Samples)) {\n\t\tGF_SubSampleInfoEntry *pSamp;\n\t\tpSamp = (GF_SubSampleInfoEntry*)gf_list_get(ptr->Samples, 0);\n\t\twhile (gf_list_count(pSamp->SubSamples)) {\n\t\t\tGF_SubSampleEntry *pSubSamp;\n\t\t\tpSubSamp = (GF_SubSampleEntry*) gf_list_get(pSamp->SubSamples, 0);\n\t\t\tgf_free(pSubSamp);\n\t\t\tgf_list_rem(pSamp->SubSamples, 0);\n\t\t}\n\t\tgf_list_del(pSamp->SubSamples);\n\t\tgf_free(pSamp);\n\t\tgf_list_rem(ptr->Samples, 0);\n\t}\n\tgf_list_del(ptr->Samples);\n\tgf_free(ptr);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err subs_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i, j, entry_count;\n\tu16 subsample_count;\n\tGF_SubSampleInfoEntry *pSamp;\n\tGF_SubSampleEntry *pSubSamp;\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *) s;\n\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tentry_count = gf_list_count(ptr->Samples);\n\tgf_bs_write_u32(bs, entry_count);\n\n\tfor (i=0; i<entry_count; i++) {\n\t\tpSamp = (GF_SubSampleInfoEntry*) gf_list_get(ptr->Samples, i);\n\t\tsubsample_count = gf_list_count(pSamp->SubSamples);\n\t\tgf_bs_write_u32(bs, pSamp->sample_delta);\n\t\tgf_bs_write_u16(bs, subsample_count);\n\n\t\tfor (j=0; j<subsample_count; j++) {\n\t\t\tpSubSamp = (GF_SubSampleEntry*) gf_list_get(pSamp->SubSamples, j);\n\t\t\tif (ptr->version == 1) {\n\t\t\t\tgf_bs_write_u32(bs, pSubSamp->subsample_size);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u16(bs, pSubSamp->subsample_size);\n\t\t\t}\n\t\t\tgf_bs_write_u8(bs, pSubSamp->subsample_priority);\n\t\t\tgf_bs_write_u8(bs, pSubSamp->discardable);\n\t\t\tgf_bs_write_u32(bs, pSubSamp->reserved);\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_Err subs_Size(GF_Box *s)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *) s;\n\tGF_SubSampleInfoEntry *pSamp;\n\tu32 entry_count, i;\n\tu16 subsample_count;\n\n\t// add 4 byte for entry_count\n\tptr->size += 4;\n\tentry_count = gf_list_count(ptr->Samples);\n\tfor (i=0; i<entry_count; i++) {\n\t\tpSamp = (GF_SubSampleInfoEntry*) gf_list_get(ptr->Samples, i);\n\t\tsubsample_count = gf_list_count(pSamp->SubSamples);\n\t\t// 4 byte for sample_delta, 2 byte for subsample_count\n\t\t// and 6 + (4 or 2) bytes for each subsample\n\t\tptr->size += 4 + 2 + subsample_count * (6 + (ptr->version==1 ? 4 : 2));\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Err subs_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *)s;\n\tu32 entry_count, i, j;\n\tu16 subsample_count;\n\n\tentry_count = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tfor (i=0; i<entry_count; i++) {\n\t\tu32 subs_size=0;\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry*) gf_malloc(sizeof(GF_SubSampleInfoEntry));\n\t\tif (!pSamp) return GF_OUT_OF_MEM;\n\n\t\tmemset(pSamp, 0, sizeof(GF_SubSampleInfoEntry));\n\t\tpSamp->SubSamples = gf_list_new();\n\t\tpSamp->sample_delta = gf_bs_read_u32(bs);\n\t\tsubsample_count = gf_bs_read_u16(bs);\n\t\tsubs_size=6;\n\n\t\tfor (j=0; j<subsample_count; j++) {\n\t\t\tGF_SubSampleEntry *pSubSamp = (GF_SubSampleEntry*) gf_malloc(sizeof(GF_SubSampleEntry));\n\t\t\tif (!pSubSamp) return GF_OUT_OF_MEM;\n\n\t\t\tmemset(pSubSamp, 0, sizeof(GF_SubSampleEntry));\n\t\t\tif (ptr->version==1) {\n\t\t\t\tpSubSamp->subsample_size = gf_bs_read_u32(bs);\n\t\t\t\tsubs_size+=4;\n\t\t\t} else {\n\t\t\t\tpSubSamp->subsample_size = gf_bs_read_u16(bs);\n\t\t\t\tsubs_size+=2;\n\t\t\t}\n\t\t\tpSubSamp->subsample_priority = gf_bs_read_u8(bs);\n\t\t\tpSubSamp->discardable = gf_bs_read_u8(bs);\n\t\t\tpSubSamp->reserved = gf_bs_read_u32(bs);\n\t\t\tsubs_size+=6;\n\n\t\t\tgf_list_add(pSamp->SubSamples, pSubSamp);\n\t\t}\n\t\tgf_list_add(ptr->Samples, pSamp);\n\t\tISOM_DECREASE_SIZE(ptr, subs_size);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\nGF_Box *tfdt_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TFBaseMediaDecodeTimeBox, GF_ISOM_BOX_TYPE_TFDT);\n\treturn (GF_Box *)tmp;\n}\n\nvoid tfdt_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n/*this is using chpl format according to some NeroRecode samples*/\nGF_Err tfdt_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;\n\n\tif (ptr->version==1) {\n\t\tptr->baseMediaDecodeTime = gf_bs_read_u64(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t} else {\n\t\tptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tfdt_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->version==1) {\n\t\tgf_bs_write_u64(bs, ptr->baseMediaDecodeTime);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->baseMediaDecodeTime);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tfdt_Size(GF_Box *s)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;\n\n\tif (ptr->baseMediaDecodeTime<=0xFFFFFFFF) {\n\t\tptr->version = 0;\n\t\tptr->size += 4;\n\t} else {\n\t\tptr->version = 1;\n\t\tptr->size += 8;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n\nGF_Box *rvcc_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RVCConfigurationBox, GF_ISOM_BOX_TYPE_RVCC);\n\treturn (GF_Box *)tmp;\n}\n\nvoid rvcc_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err rvcc_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox*)s;\n\tptr->predefined_rvc_config = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tif (!ptr->predefined_rvc_config) {\n\t\tptr->rvc_meta_idx = gf_bs_read_u16(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err rvcc_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox*) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->predefined_rvc_config);\n\tif (!ptr->predefined_rvc_config) {\n\t\tgf_bs_write_u16(bs, ptr->rvc_meta_idx);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err rvcc_Size(GF_Box *s)\n{\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox *)s;\n\tptr->size += 2;\n\tif (! ptr->predefined_rvc_config) ptr->size += 2;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *sbgp_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleGroupBox, GF_ISOM_BOX_TYPE_SBGP);\n\treturn (GF_Box *)tmp;\n}\nvoid sbgp_del(GF_Box *a)\n{\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox *)a;\n\tif (p->sample_entries) gf_free(p->sample_entries);\n\tgf_free(p);\n}\n\nGF_Err sbgp_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SampleGroupBox *ptr = (GF_SampleGroupBox *)s;\n\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tif (ptr->version==1) {\n\t\tptr->grouping_type_parameter = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t}\n\tptr->entry_count = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tptr->sample_entries = gf_malloc(sizeof(GF_SampleGroupEntry)*ptr->entry_count);\n\tif (!ptr->sample_entries) return GF_IO_ERR;\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tptr->sample_entries[i].sample_count = gf_bs_read_u32(bs);\n\t\tptr->sample_entries[i].group_description_index = gf_bs_read_u32(bs);\n\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sbgp_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox*)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, p->grouping_type);\n\tif (p->version==1)\n\t\tgf_bs_write_u32(bs, p->grouping_type_parameter);\n\n\tgf_bs_write_u32(bs, p->entry_count);\n\tfor (i = 0; i<p->entry_count; i++ ) {\n\t\tgf_bs_write_u32(bs, p->sample_entries[i].sample_count);\n\t\tgf_bs_write_u32(bs, p->sample_entries[i].group_description_index);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sbgp_Size(GF_Box *s)\n{\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox*)s;\n\n\tp->size += 8;\n\tif (p->grouping_type_parameter) p->version=1;\n\n\tif (p->version==1) p->size += 4;\n\tp->size += 8*p->entry_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nstatic void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, u32 entry_size, u32 *total_bytes)\n{\n\tBool null_size_ok = GF_FALSE;\n\n\tGF_DefaultSampleGroupDescriptionEntry *ptr;\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t{\n\t\tGF_RollRecoveryEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_RollRecoveryEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->roll_distance = gf_bs_read_int(bs, 16);\n\t\t*total_bytes = 2;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t{\n\t\tGF_VisualRandomAccessEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_VisualRandomAccessEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->num_leading_samples_known = gf_bs_read_int(bs, 1);\n\t\tptr->num_leading_samples = gf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t{\n\t\tGF_SAPEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SAPEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->dependent_flag = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 3);\n\t\tptr->SAP_type = gf_bs_read_int(bs, 4);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t{\n\t\tGF_SYNCEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SYNCEntry);\n\t\tif (!ptr) return NULL;\n\t\tgf_bs_read_int(bs, 2);\n\t\tptr->NALU_type = gf_bs_read_int(bs, 6);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t{\n\t\tGF_TemporalLevelEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_TemporalLevelEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->level_independently_decodable = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry);\n\t\tif (!ptr) return NULL;\n\t\tgf_bs_read_u8(bs); //reserved\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->IsProtected = gf_bs_read_u8(bs);\n\t\tptr->Per_Sample_IV_size = gf_bs_read_u8(bs);\n\t\tgf_bs_read_data(bs, (char *)ptr->KID, 16);\n\t\t*total_bytes = 20;\n\t\tif ((ptr->IsProtected == 1) && !ptr->Per_Sample_IV_size) {\n\t\t\tptr->constant_IV_size = gf_bs_read_u8(bs);\n\t\t\tassert((ptr->constant_IV_size == 8) || (ptr->constant_IV_size == 16));\n\t\t\tgf_bs_read_data(bs, (char *)ptr->constant_IV, ptr->constant_IV_size);\n\t\t\t*total_bytes += 1 + ptr->constant_IV_size;\n\t\t}\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t{\n\t\tGF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_oinf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] oinf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t{\n\t\tGF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_linf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] linf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\n\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n\t\tif (! entry_size) {\n\t\t\tu32 flags = gf_bs_peek_bits(bs, 24, 0);\n\t\t\tif (flags & 0x10000) entry_size=3;\n\t\t\telse {\n\t\t\t\tif (flags & 0x80000) entry_size=7;\n\t\t\t\telse entry_size=11;\n\t\t\t\t//have dependency list\n\t\t\t\tif (flags & 0x200000) {\n\t\t\t\t\tu32 nb_entries = gf_bs_peek_bits(bs, 16, entry_size);\n\t\t\t\t\tentry_size += 2 + 2*nb_entries;\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] trif sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n\t\tif (! entry_size) {\n\t\t\tu64 start = gf_bs_get_position(bs);\n\t\t\tBool rle, large_size;\n\t\t\tu32 entry_count;\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t\tlarge_size = gf_bs_read_int(bs, 1);\n\t\t\trle = gf_bs_read_int(bs, 1);\n\t\t\tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n\t\t\tgf_bs_seek(bs, start);\n\t\t\tentry_size = 1 + large_size ? 2 : 1;\n\t\t\tentry_size += entry_count * 2;\n\t\t\tif (rle) entry_size += entry_count * (large_size ? 2 : 1);\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] nalm sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_SAMPLE_GROUP_TSAS:\n\tcase GF_ISOM_SAMPLE_GROUP_STSA:\n\t\tnull_size_ok = GF_TRUE;\n\t\tbreak;\n\t//TODO, add support for these ones ?\n\tcase GF_ISOM_SAMPLE_GROUP_TSCL:\n\t\tentry_size = 20;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_LBLI:\n\t\tentry_size = 2;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!entry_size && !null_size_ok) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\\n\", gf_4cc_to_str( grouping_type) ));\n\t\treturn NULL;\n\t}\n\tGF_SAFEALLOC(ptr, GF_DefaultSampleGroupDescriptionEntry);\n\tif (!ptr) return NULL;\n\tif (entry_size) {\n\t\tptr->length = entry_size;\n\t\tptr->data = (u8 *) gf_malloc(sizeof(u8)*ptr->length);\n\t\tgf_bs_read_data(bs, (char *) ptr->data, ptr->length);\n\t\t*total_bytes = entry_size;\n\t}\n\treturn ptr;\n}\n\nstatic void\tsgpd_del_entry(u32 grouping_type, void *entry)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\tgf_free(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\tgf_isom_oinf_del_entry(entry);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\tgf_isom_linf_del_entry(entry);\n\t\treturn;\n\tdefault:\n\t{\n\t\tGF_DefaultSampleGroupDescriptionEntry *ptr = (GF_DefaultSampleGroupDescriptionEntry *)entry;\n\t\tif (ptr->data) gf_free(ptr->data);\n\t\tgf_free(ptr);\n\t}\n\t}\n}\n\nvoid sgpd_write_entry(u32 grouping_type, void *entry, GF_BitStream *bs)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\tgf_bs_write_int(bs, ((GF_RollRecoveryEntry*)entry)->roll_distance, 16);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\tgf_bs_write_int(bs, ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples_known, 1);\n\t\tgf_bs_write_int(bs, ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples, 7);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\tgf_bs_write_int(bs, ((GF_SAPEntry*)entry)->dependent_flag, 1);\n\t\tgf_bs_write_int(bs, 0, 3);\n\t\tgf_bs_write_int(bs, ((GF_SAPEntry*)entry)->SAP_type, 4);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\tgf_bs_write_int(bs, 0, 2);\n\t\tgf_bs_write_int(bs, ((GF_SYNCEntry*)entry)->NALU_type, 6);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t\tgf_bs_write_int(bs, ((GF_TemporalLevelEntry*)entry)->level_independently_decodable, 1);\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t\tgf_bs_write_u8(bs, 0x0);\n\t\tgf_bs_write_int(bs, ((GF_CENCSampleEncryptionGroupEntry*)entry)->crypt_byte_block, 4);\n\t\tgf_bs_write_int(bs, ((GF_CENCSampleEncryptionGroupEntry*)entry)->skip_byte_block, 4);\n\t\tgf_bs_write_u8(bs, ((GF_CENCSampleEncryptionGroupEntry *)entry)->IsProtected);\n\t\tgf_bs_write_u8(bs, ((GF_CENCSampleEncryptionGroupEntry *)entry)->Per_Sample_IV_size);\n\t\tgf_bs_write_data(bs, (char *)((GF_CENCSampleEncryptionGroupEntry *)entry)->KID, 16);\n\t\tif ((((GF_CENCSampleEncryptionGroupEntry *)entry)->IsProtected == 1) && !((GF_CENCSampleEncryptionGroupEntry *)entry)->Per_Sample_IV_size) {\n\t\t\tgf_bs_write_u8(bs, ((GF_CENCSampleEncryptionGroupEntry *)entry)->constant_IV_size);\n\t\t\tgf_bs_write_data(bs, (char *)((GF_CENCSampleEncryptionGroupEntry *)entry)->constant_IV, ((GF_CENCSampleEncryptionGroupEntry *)entry)->constant_IV_size);\n\t\t}\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\tgf_isom_oinf_write_entry(entry, bs);\n\t\treturn;\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\tgf_isom_linf_write_entry(entry, bs);\n\t\treturn;\n\tdefault:\n\t{\n\t\tGF_DefaultSampleGroupDescriptionEntry *ptr = (GF_DefaultSampleGroupDescriptionEntry *)entry;\n\t\tif (ptr->length)\n\t\t\tgf_bs_write_data(bs, (char *) ptr->data, ptr->length);\n\t}\n\t}\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nstatic u32 sgpd_size_entry(u32 grouping_type, void *entry)\n{\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\treturn 2;\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\treturn 1;\n\tcase GF_ISOM_SAMPLE_GROUP_TSCL:\n\t\treturn 20;\n\tcase GF_ISOM_SAMPLE_GROUP_LBLI:\n\t\treturn 2;\n\tcase GF_ISOM_SAMPLE_GROUP_TSAS:\n\tcase GF_ISOM_SAMPLE_GROUP_STSA:\n\t\treturn 0;\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t\treturn ((((GF_CENCSampleEncryptionGroupEntry *)entry)->IsProtected == 1) && !((GF_CENCSampleEncryptionGroupEntry *)entry)->Per_Sample_IV_size) ? 21 + ((GF_CENCSampleEncryptionGroupEntry *)entry)->constant_IV_size : 20;\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\treturn gf_isom_oinf_size_entry(entry);\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\treturn gf_isom_linf_size_entry(entry);\n\tdefault:\n\t\treturn ((GF_DefaultSampleGroupDescriptionEntry *)entry)->length;\n\t}\n}\n#endif\n\nGF_Box *sgpd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleGroupDescriptionBox, GF_ISOM_BOX_TYPE_SGPD);\n\t/*version 0 is deprecated, use v1 by default*/\n\ttmp->version = 1;\n\ttmp->group_descriptions = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid sgpd_del(GF_Box *a)\n{\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)a;\n\twhile (gf_list_count(p->group_descriptions)) {\n\t\tvoid *ptr = gf_list_last(p->group_descriptions);\n\t\tsgpd_del_entry(p->grouping_type, ptr);\n\t\tgf_list_rem_last(p->group_descriptions);\n\t}\n\tgf_list_del(p->group_descriptions);\n\tgf_free(p);\n}\n\nGF_Err sgpd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entry_count;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\n\tp->grouping_type = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(p, 4);\n\n\tif (p->version>=1) {\n\t\tp->default_length = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(p, 4);\n\t}\n\tif (p->version>=2) {\n\t\tp->default_description_index = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(p, 4);\n\t}\n\tentry_count = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(p, 4);\n\n\tif (entry_count>p->size)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\twhile (entry_count) {\n\t\tvoid *ptr;\n\t\tu32 parsed_bytes=0;\n\t\tu32 size = p->default_length;\n\t\tif ((p->version>=1) && !size) {\n\t\t\tsize = gf_bs_read_u32(bs);\n\t\t\tISOM_DECREASE_SIZE(p, 4);\n\t\t}\n\t\tptr = sgpd_parse_entry(p->grouping_type, bs, size, &parsed_bytes);\n\t\t//don't return an error, just stop parsing so that we skip over the sgpd box\n\t\tif (!ptr) return GF_OK;\n\n\t\tISOM_DECREASE_SIZE(p, parsed_bytes);\n\n\t\tgf_list_add(p->group_descriptions, ptr);\n\t\tentry_count--;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sgpd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\tGF_Err e;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, p->grouping_type);\n\tif (p->version>=1) gf_bs_write_u32(bs, p->default_length);\n\tif (p->version>=2) gf_bs_write_u32(bs, p->default_description_index);\n\tgf_bs_write_u32(bs, gf_list_count(p->group_descriptions) );\n\n\tfor (i=0; i<gf_list_count(p->group_descriptions); i++) {\n\t\tvoid *ptr = gf_list_get(p->group_descriptions, i);\n\t\tif ((p->version >= 1) && !p->default_length) {\n\t\t\tu32 size = sgpd_size_entry(p->grouping_type, ptr);\n\t\t\tgf_bs_write_u32(bs, size);\n\t\t}\n\t\tsgpd_write_entry(p->grouping_type, ptr, bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sgpd_Size(GF_Box *s)\n{\n\tu32 i;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\n\tp->size += 8;\n\n\t//we force all sample groups to version 1, v0 being deprecated\n\tp->version=1;\n\tp->size += 4;\n\n\tif (p->version>=2) p->size += 4;\n\tp->default_length = 0;\n\n\tfor (i=0; i<gf_list_count(p->group_descriptions); i++) {\n\t\tvoid *ptr = gf_list_get(p->group_descriptions, i);\n\t\tu32 size = sgpd_size_entry(p->grouping_type, ptr);\n\t\tp->size += size;\n\t\tif (!p->default_length) {\n\t\t\tp->default_length = size;\n\t\t} else if (p->default_length != size) {\n\t\t\tp->default_length = 0;\n\t\t}\n\t}\n\tif (p->version>=1) {\n\t\tif (!p->default_length) p->size += gf_list_count(p->group_descriptions)*4;\n\t}\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid saiz_del(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->sample_info_size) gf_free(ptr->sample_info_size);\n\tgf_free(ptr);\n}\n\n\nGF_Err saiz_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\n\tif (ptr->flags & 1) {\n\t\tptr->aux_info_type = gf_bs_read_u32(bs);\n\t\tptr->aux_info_type_parameter = gf_bs_read_u32(bs);\n\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t}\n\tptr->default_sample_info_size = gf_bs_read_u8(bs);\n\tptr->sample_count = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 5);\n\n\tif (ptr->default_sample_info_size == 0) {\n\t\tptr->sample_info_size = gf_malloc(sizeof(u8)*ptr->sample_count);\n\t\tgf_bs_read_data(bs, (char *) ptr->sample_info_size, ptr->sample_count);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->sample_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *saiz_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleAuxiliaryInfoSizeBox, GF_ISOM_BOX_TYPE_SAIZ);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err saiz_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleAuxiliaryInfoSizeBox*ptr = (GF_SampleAuxiliaryInfoSizeBox*) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->flags & 1) {\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type);\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type_parameter);\n\t}\n\tgf_bs_write_u8(bs, ptr->default_sample_info_size);\n\tgf_bs_write_u32(bs, ptr->sample_count);\n\tif (!ptr->default_sample_info_size) {\n\t\tgf_bs_write_data(bs, (char *) ptr->sample_info_size, ptr->sample_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err saiz_Size(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoSizeBox *ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\n\tif (ptr->aux_info_type || ptr->aux_info_type_parameter) {\n\t\tptr->flags |= 1;\n\t}\n\tif (ptr->flags & 1) ptr->size += 8;\n\tptr->size += 5;\n\tif (ptr->default_sample_info_size==0)  ptr->size += ptr->sample_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nvoid saio_del(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tif (ptr->offsets_large) gf_free(ptr->offsets_large);\n\tgf_free(ptr);\n}\n\n\nGF_Err saio_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox *)s;\n\n\tif (ptr->flags & 1) {\n\t\tptr->aux_info_type = gf_bs_read_u32(bs);\n\t\tptr->aux_info_type_parameter = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t}\n\tptr->entry_count = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tif (ptr->entry_count) {\n\t\tu32 i;\n\t\tif (ptr->version==0) {\n\t\t\tptr->offsets = gf_malloc(sizeof(u32)*ptr->entry_count);\n\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\tptr->offsets[i] = gf_bs_read_u32(bs);\n\n\t\t\tISOM_DECREASE_SIZE(ptr, 4*ptr->entry_count);\n\t\t} else {\n\t\t\tptr->offsets_large = gf_malloc(sizeof(u64)*ptr->entry_count);\n\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\tptr->offsets_large[i] = gf_bs_read_u64(bs);\n\t\t\tISOM_DECREASE_SIZE(ptr, 8*ptr->entry_count);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *saio_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleAuxiliaryInfoOffsetBox, GF_ISOM_BOX_TYPE_SAIO);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err saio_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tif (ptr->flags & 1) {\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type);\n\t\tgf_bs_write_u32(bs, ptr->aux_info_type_parameter);\n\t}\n\n\n\tgf_bs_write_u32(bs, ptr->entry_count);\n\tif (ptr->entry_count) {\n\t\tu32 i;\n\t\t//store position in bitstream before writing data - offsets can be NULL if a single offset is rewritten later on (cf senc_write)\n\t\tptr->offset_first_offset_field = gf_bs_get_position(bs);\n\t\tif (ptr->version==0) {\n\t\t\tif (!ptr->offsets) {\n\t\t\t\tgf_bs_write_u32(bs, 0);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\t\tgf_bs_write_u32(bs, ptr->offsets[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!ptr->offsets_large) {\n\t\t\t\tgf_bs_write_u64(bs, 0);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\t\t\tgf_bs_write_u64(bs, ptr->offsets_large[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err saio_Size(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox*)s;\n\n\tif (ptr->aux_info_type || ptr->aux_info_type_parameter) {\n\t\tptr->flags |= 1;\n\t}\n\tif (ptr->offsets_large) {\n\t\tptr->version = 1;\n\t}\n\n\tif (ptr->flags & 1) ptr->size += 8;\n\tptr->size += 4;\n\t//a little optim here: in cenc, the saio always points to a single data block, only one entry is needed\n\tswitch (ptr->aux_info_type) {\n\tcase GF_ISOM_CENC_SCHEME:\n\tcase GF_ISOM_CBC_SCHEME:\n\tcase GF_ISOM_CENS_SCHEME:\n\tcase GF_ISOM_CBCS_SCHEME:\n\t\tif (ptr->offsets_large) gf_free(ptr->offsets_large);\n\t\tif (ptr->offsets) gf_free(ptr->offsets);\n\t\tptr->offsets_large = NULL;\n\t\tptr->offsets = NULL;\n\t\tptr->entry_count = 1;\n\t\tbreak;\n\t}\n\n\tptr->size += ((ptr->version==1) ? 8 : 4) * ptr->entry_count;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\nvoid prft_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err prft_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox *) s;\n\n\tptr->refTrackID = gf_bs_read_u32(bs);\n\tptr->ntp = gf_bs_read_u64(bs);\n\tif (ptr->version==0) {\n\t\tptr->timestamp = gf_bs_read_u32(bs);\n\t} else {\n\t\tptr->timestamp = gf_bs_read_u64(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *prft_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProducerReferenceTimeBox, GF_ISOM_BOX_TYPE_PRFT);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err prft_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->refTrackID);\n\tgf_bs_write_u64(bs, ptr->ntp);\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u32(bs, (u32) ptr->timestamp);\n\t} else {\n\t\tgf_bs_write_u64(bs, ptr->timestamp);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err prft_Size(GF_Box *s)\n{\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox*)s;\n\n\tptr->size += 4+8+ (ptr->version ? 8 : 4);\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *trgr_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackGroupBox, GF_ISOM_BOX_TYPE_TRGR);\n\ttmp->groups = gf_list_new();\n\tif (!tmp->groups) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\nvoid trgr_del(GF_Box *s)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\tif (ptr == NULL) return;\n\tgf_isom_box_array_del(ptr->groups);\n\tgf_free(ptr);\n}\n\n\nGF_Err trgr_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\treturn gf_list_add(ptr->groups, a);\n}\n\n\nGF_Err trgr_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(s, bs, trgr_AddBox, s->type);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err trgr_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\treturn gf_isom_box_array_write(s, ptr->groups, bs);\n}\n\nGF_Err trgr_Size(GF_Box *s)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\treturn gf_isom_box_array_size(s, ptr->groups);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *trgt_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackGroupTypeBox, GF_ISOM_BOX_TYPE_TRGT);\n\treturn (GF_Box *)tmp;\n}\n\nvoid trgt_del(GF_Box *s)\n{\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err trgt_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *)s;\n\tptr->track_group_id = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trgt_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\ts->type = ptr->group_type;\n\te = gf_isom_full_box_write(s, bs);\n\ts->type = GF_ISOM_BOX_TYPE_TRGT;\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->track_group_id);\n\treturn GF_OK;\n}\n\nGF_Err trgt_Size(GF_Box *s)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;\n\n\tptr->size+= 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *stvi_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_StereoVideoBox, GF_ISOM_BOX_TYPE_STVI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid stvi_del(GF_Box *s)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->stereo_indication_type) gf_free(ptr->stereo_indication_type);\n\tgf_free(ptr);\n}\n\nGF_Err stvi_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 12);\n\tgf_bs_read_int(bs, 30);\n\tptr->single_view_allowed = gf_bs_read_int(bs, 2);\n\tptr->stereo_scheme = gf_bs_read_u32(bs);\n\tptr->sit_len = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, ptr->sit_len);\n\tptr->stereo_indication_type = gf_malloc(sizeof(char)*ptr->sit_len);\n\tgf_bs_read_data(bs, ptr->stereo_indication_type, ptr->sit_len);\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err stvi_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, 0, 30);\n\tgf_bs_write_int(bs, ptr->single_view_allowed, 2);\n\tgf_bs_write_u32(bs, ptr->stereo_scheme);\n\tgf_bs_write_u32(bs, ptr->sit_len);\n\tgf_bs_write_data(bs, ptr->stereo_indication_type, ptr->sit_len);\n\n\treturn GF_OK;\n}\n\nGF_Err stvi_Size(GF_Box *s)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *)s;\n\n\tptr->size+= 12 + ptr->sit_len;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *fiin_New()\n{\n\tISOM_DECL_BOX_ALLOC(FDItemInformationBox, GF_ISOM_BOX_TYPE_FIIN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fiin_del(GF_Box *s)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->partition_entries) gf_isom_box_array_del(ptr->partition_entries);\n\tif (ptr->session_info) gf_isom_box_del((GF_Box*)ptr->session_info);\n\tif (ptr->group_id_to_name) gf_isom_box_del((GF_Box*)ptr->group_id_to_name);\n\tgf_free(ptr);\n}\n\n\nGF_Err fiin_AddBox(GF_Box *s, GF_Box *a)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_PAEN:\n\t\tif (!ptr->partition_entries) ptr->partition_entries = gf_list_new();\n\t\treturn gf_list_add(ptr->partition_entries, a);\n\tcase GF_ISOM_BOX_TYPE_SEGR:\n\t\tif (ptr->session_info) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->session_info = (FDSessionGroupBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_GITN:\n\t\tif (ptr->group_id_to_name) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->group_id_to_name = (GroupIdToNameBox *)a;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fiin_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tgf_bs_read_u16(bs);\n\treturn gf_isom_box_array_read(s, bs, fiin_AddBox);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fiin_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tFDItemInformationBox *ptr = (FDItemInformationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, gf_list_count(ptr->partition_entries) );\n\te = gf_isom_box_array_write(s, ptr->partition_entries, bs);\n\tif (e) return e;\n\tif (ptr->session_info) gf_isom_box_write((GF_Box*)ptr->session_info, bs);\n\tif (ptr->group_id_to_name) gf_isom_box_write((GF_Box*)ptr->group_id_to_name, bs);\n\treturn GF_OK;\n}\n\nGF_Err fiin_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\n\tptr->size+= 2;\n\tif (ptr->partition_entries) {\n\t\te = gf_isom_box_array_size(s, ptr->partition_entries);\n\t\tif (e) return e;\n\t}\n\tif (ptr->session_info) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->session_info);\n\t\tif (e) return e;\n\t\tptr->size += ptr->session_info->size;\n\t}\n\tif (ptr->group_id_to_name) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->group_id_to_name);\n\t\tif (e) return e;\n\t\tptr->size += ptr->group_id_to_name->size;\n\t}\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *paen_New()\n{\n\tISOM_DECL_BOX_ALLOC(FDPartitionEntryBox, GF_ISOM_BOX_TYPE_PAEN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid paen_del(GF_Box *s)\n{\n\tFDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->blocks_and_symbols) gf_isom_box_del((GF_Box*)ptr->blocks_and_symbols);\n\tif (ptr->FEC_symbol_locations) gf_isom_box_del((GF_Box*)ptr->FEC_symbol_locations);\n\tif (ptr->File_symbol_locations) gf_isom_box_del((GF_Box*)ptr->File_symbol_locations);\n\tgf_free(ptr);\n}\n\n\nGF_Err paen_AddBox(GF_Box *s, GF_Box *a)\n{\n\tFDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_FPAR:\n\t\tif (ptr->blocks_and_symbols) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->blocks_and_symbols = (FilePartitionBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_FECR:\n\t\tif (ptr->FEC_symbol_locations) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->FEC_symbol_locations = (FECReservoirBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_FIRE:\n\t\tif (ptr->File_symbol_locations) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->File_symbol_locations = (FileReservoirBox *)a;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err paen_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, fiin_AddBox);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err paen_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tFDPartitionEntryBox *ptr = (FDPartitionEntryBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\tif (ptr->blocks_and_symbols) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->blocks_and_symbols, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->FEC_symbol_locations) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->FEC_symbol_locations, bs);\n\t\tif (e) return e;\n\t}\n\tif (ptr->File_symbol_locations) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->File_symbol_locations, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err paen_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tFDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;\n\n\tif (ptr->blocks_and_symbols) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);\n\t\tif (e) return e;\n\t\tptr->size += ptr->blocks_and_symbols->size;\n\t}\n\tif (ptr->FEC_symbol_locations) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);\n\t\tif (e) return e;\n\t\tptr->size += ptr->FEC_symbol_locations->size;\n\t}\n\tif (ptr->File_symbol_locations) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);\n\t\tif (e) return e;\n\t\tptr->size += ptr->File_symbol_locations->size;\n\t}\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *fpar_New()\n{\n\tISOM_DECL_BOX_ALLOC(FilePartitionBox, GF_ISOM_BOX_TYPE_FPAR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fpar_del(GF_Box *s)\n{\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->scheme_specific_info) gf_free(ptr->scheme_specific_info);\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err gf_isom_read_null_terminated_string(GF_Box *s, GF_BitStream *bs, u64 size, char **out_str)\n{\n\tu32 len=10;\n\tu32 i=0;\n\n\t*out_str = gf_malloc(sizeof(char)*len);\n\twhile (1) {\n\t\tISOM_DECREASE_SIZE(s, 1 );\n\t\t(*out_str)[i] = gf_bs_read_u8(bs);\n\t\tif (!(*out_str)[i]) break;\n\t\ti++;\n\t\tif (i==len) {\n\t\t\tlen += 10;\n\t\t\t*out_str = gf_realloc(*out_str, sizeof(char)*len);\n\t\t}\n\t\tif (gf_bs_available(bs) == 0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] missing null character in null terminated string\\n\"));\n\t\t\t(*out_str)[i] = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (i >= size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] string bigger than container, probably missing null character\\n\"));\n\t\t\t(*out_str)[i] = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fpar_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, ((ptr->version ? 4 : 2) + 12) );\n\tptr->itemID = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\tptr->packet_payload_size = gf_bs_read_u16(bs);\n\tgf_bs_read_u8(bs);\n\tptr->FEC_encoding_ID = gf_bs_read_u8(bs);\n\tptr->FEC_instance_ID = gf_bs_read_u16(bs);\n\tptr->max_source_block_length = gf_bs_read_u16(bs);\n\tptr->encoding_symbol_length = gf_bs_read_u16(bs);\n\tptr->max_number_of_encoding_symbols = gf_bs_read_u16(bs);\n\n\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->scheme_specific_info);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(ptr, (ptr->version ? 4 : 2) );\n\tptr->nb_entries = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries * 6 );\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, FilePartitionEntry);\n\tfor (i=0;i < ptr->nb_entries; i++) {\n\t\tptr->entries[i].block_count = gf_bs_read_u16(bs);\n\t\tptr->entries[i].block_size = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fpar_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tFilePartitionBox *ptr = (FilePartitionBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->itemID, ptr->version ? 32 : 16);\n\tgf_bs_write_u16(bs, ptr->packet_payload_size);\n\tgf_bs_write_u8(bs, 0);\n\tgf_bs_write_u8(bs, ptr->FEC_encoding_ID);\n\tgf_bs_write_u16(bs, ptr->FEC_instance_ID);\n\tgf_bs_write_u16(bs, ptr->max_source_block_length);\n\tgf_bs_write_u16(bs, ptr->encoding_symbol_length);\n\tgf_bs_write_u16(bs, ptr->max_number_of_encoding_symbols);\n\tif (ptr->scheme_specific_info) {\n\t\tgf_bs_write_data(bs, ptr->scheme_specific_info, (u32)strlen(ptr->scheme_specific_info) );\n\t}\n\t//null terminated string\n\tgf_bs_write_u8(bs, 0);\n\n\tgf_bs_write_int(bs, ptr->nb_entries, ptr->version ? 32 : 16);\n\n\tfor (i=0;i < ptr->nb_entries; i++) {\n\t\tgf_bs_write_u16(bs, ptr->entries[i].block_count);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].block_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fpar_Size(GF_Box *s)\n{\n\tFilePartitionBox *ptr = (FilePartitionBox *)s;\n\n\tptr->size+= 13 + ptr->version ? 8 : 4;\n\tif (ptr->scheme_specific_info)\n\t\tptr->size += strlen(ptr->scheme_specific_info);\n\n\tptr->size+= ptr->nb_entries * 6;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *fecr_New()\n{\n\tISOM_DECL_BOX_ALLOC(FECReservoirBox, GF_ISOM_BOX_TYPE_FECR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fecr_del(GF_Box *s)\n{\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err fecr_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, (ptr->version ? 4 : 2) );\n\tptr->nb_entries = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\n\tISOM_DECREASE_SIZE(ptr, ptr->nb_entries * (ptr->version ? 8 : 6) );\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, FECReservoirEntry);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->entries[i].item_id = gf_bs_read_int(bs, ptr->version ? 32 : 16);\n\t\tptr->entries[i].symbol_count = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fecr_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tFECReservoirBox *ptr = (FECReservoirBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->nb_entries, ptr->version ? 32 : 16);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_int(bs, ptr->entries[i].item_id, ptr->version ? 32 : 16);\n\t\tgf_bs_write_u32(bs, ptr->entries[i].symbol_count);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fecr_Size(GF_Box *s)\n{\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\tptr->size += (ptr->version ? 4 : 2) +  ptr->nb_entries * (ptr->version ? 8 : 6);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *segr_New()\n{\n\tISOM_DECL_BOX_ALLOC(FDSessionGroupBox, GF_ISOM_BOX_TYPE_SEGR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid segr_del(GF_Box *s)\n{\n\tu32 i;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tif (ptr->session_groups[i].group_ids) gf_free(ptr->session_groups[i].group_ids);\n\t\tif (ptr->session_groups[i].channels) gf_free(ptr->session_groups[i].channels);\n\t}\n\tif (ptr->session_groups) gf_free(ptr->session_groups);\n\tgf_free(ptr);\n}\n\nGF_Err segr_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, k;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->num_session_groups = gf_bs_read_u16(bs);\n\tif (ptr->num_session_groups*3>ptr->size) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in segr\\n\", ptr->num_session_groups));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tGF_SAFE_ALLOC_N(ptr->session_groups, ptr->num_session_groups, SessionGroupEntry);\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tptr->session_groups[i].nb_groups = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\t\tGF_SAFE_ALLOC_N(ptr->session_groups[i].group_ids, ptr->session_groups[i].nb_groups, u32);\n\t\tfor (k=0; k<ptr->session_groups[i].nb_groups; k++) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\t\tptr->session_groups[i].group_ids[k] = gf_bs_read_u32(bs);\n\t\t}\n\n\t\tptr->session_groups[i].nb_channels = gf_bs_read_u16(bs);\n\t\tGF_SAFE_ALLOC_N(ptr->session_groups[i].channels, ptr->session_groups[i].nb_channels, u32);\n\t\tfor (k=0; k<ptr->session_groups[i].nb_channels; k++) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\t\tptr->session_groups[i].channels[k] = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err segr_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, k;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\tgf_bs_write_u16(bs, ptr->num_session_groups);\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tgf_bs_write_u8(bs, ptr->session_groups[i].nb_groups);\n\t\tfor (k=0; k<ptr->session_groups[i].nb_groups; k++) {\n\t\t\tgf_bs_write_u32(bs, ptr->session_groups[i].group_ids[k]);\n\t\t}\n\n\t\tgf_bs_write_u16(bs, ptr->session_groups[i].nb_channels);\n\t\tfor (k=0; k<ptr->session_groups[i].nb_channels; k++) {\n\t\t\tgf_bs_write_u32(bs, ptr->session_groups[i].channels[k]);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err segr_Size(GF_Box *s)\n{\n\tu32 i;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *)s;\n\n\tptr->size += 2;\n\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tptr->size += 1 + 4*ptr->session_groups[i].nb_groups;\n\t\tptr->size += 2 + 4*ptr->session_groups[i].nb_channels;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *gitn_New()\n{\n\tISOM_DECL_BOX_ALLOC(GroupIdToNameBox, GF_ISOM_BOX_TYPE_GITN);\n\treturn (GF_Box *)tmp;\n}\n\nvoid gitn_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t}\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err gitn_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_Err e;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->nb_entries = gf_bs_read_u16(bs);\n\n\tGF_SAFE_ALLOC_N(ptr->entries, ptr->nb_entries, GroupIdNameEntry);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->entries[i].group_id = gf_bs_read_u32(bs);\n\n\t\te = gf_isom_read_null_terminated_string(s, bs, ptr->size, &ptr->entries[i].name);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gitn_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].group_id);\n\t\tif (ptr->entries[i].name) gf_bs_write_data(bs, ptr->entries[i].name, (u32)strlen(ptr->entries[i].name) );\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gitn_Size(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tptr->size += 2;\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->size += 5;\n\t\tif (ptr->entries[i].name) ptr->size += strlen(ptr->entries[i].name);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\nGF_Box *fdpa_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FDpacketBox, GF_ISOM_BOX_TYPE_FDPA);\n\treturn (GF_Box *)tmp;\n}\n\nvoid fdpa_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->headers) {\n\t\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\t\tif (ptr->headers[i].data) gf_free(ptr->headers[i].data);\n\t\t}\n\t\tgf_free(ptr->headers);\n\t}\n\tgf_free(ptr);\n}\n\nGF_Err fdpa_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 3);\n\tptr->info.sender_current_time_present = gf_bs_read_int(bs, 1);\n\tptr->info.expected_residual_time_present = gf_bs_read_int(bs, 1);\n\tptr->info.session_close_bit = gf_bs_read_int(bs, 1);\n\tptr->info.object_close_bit = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 4);\n\tptr->info.transport_object_identifier = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->header_ext_count = gf_bs_read_u16(bs);\n\tif (ptr->header_ext_count*2>ptr->size) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in fdpa\\n\", ptr->header_ext_count));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tGF_SAFE_ALLOC_N(ptr->headers, ptr->header_ext_count, GF_LCTheaderExtension);\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tptr->headers[i].header_extension_type = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tgf_bs_read_data(bs, (char *) ptr->headers[i].content, 3);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1);\n\t\t\tptr->headers[i].data_length = gf_bs_read_u8(bs);\n\t\t\tif (ptr->headers[i].data_length) {\n\t\t\t\tptr->headers[i].data_length = 4*ptr->headers[i].data_length - 2;\n\t\t\t\tptr->headers[i].data = gf_malloc(sizeof(char) * ptr->headers[i].data_length);\n\t\t\t\tgf_bs_read_data(bs, ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fdpa_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\tgf_bs_write_int(bs, ptr->info.sender_current_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.expected_residual_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.session_close_bit, 1);\n\tgf_bs_write_int(bs, ptr->info.object_close_bit, 1);\n\tgf_bs_write_int(bs, 0, 4);\n\tptr->info.transport_object_identifier = gf_bs_read_u16(bs);\n\tgf_bs_write_u16(bs, ptr->header_ext_count);\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tgf_bs_write_u8(bs, ptr->headers[i].header_extension_type);\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tgf_bs_write_data(bs, (const char *) ptr->headers[i].content, 3);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, ptr->headers[i].data_length ? (ptr->headers[i].data_length+2)/4 : 0);\n\t\t\tif (ptr->headers[i].data_length) {\n\t\t\t\tgf_bs_write_data(bs, ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fdpa_Size(GF_Box *s)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *)s;\n\n\tptr->size += 5;\n\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tptr->size += 1;\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tptr->size += 3;\n\t\t} else {\n\t\t\tptr->size += 1 + ptr->headers[i].data_length;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *extr_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ExtraDataBox, GF_ISOM_BOX_TYPE_EXTR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid extr_del(GF_Box *s)\n{\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->feci) gf_isom_box_del((GF_Box*)ptr->feci);\n\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}\n\nGF_Err extr_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;\n\n\te = gf_isom_box_parse((GF_Box**) &ptr->feci, bs);\n\tif (e) return e;\n\tif (ptr->feci->size>ptr->size) return GF_ISOM_INVALID_MEDIA;\n\tptr->data_length = (u32) (ptr->size - ptr->feci->size);\n\tptr->data = gf_malloc(sizeof(char)*ptr->data_length);\n\tgf_bs_read_data(bs, ptr->data, ptr->data_length);\n\n\treturn GF_OK;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err extr_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (ptr->feci) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->feci, bs);\n\t\tif (e) return e;\n\t}\n\tgf_bs_write_data(bs, ptr->data, ptr->data_length);\n\treturn GF_OK;\n}\n\nGF_Err extr_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *) s;\n\n\tif (ptr->feci) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->feci);\n\t\tif (e) return e;\n\t\tptr->size += ptr->feci->size;\n\t}\n\tptr->size += ptr->data_length;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *fdsa_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HintSample, GF_ISOM_BOX_TYPE_FDSA);\n\tif (!tmp) return NULL;\n\ttmp->packetTable = gf_list_new();\n\ttmp->hint_subtype = GF_ISOM_BOX_TYPE_FDP_STSD;\n\treturn (GF_Box*)tmp;\n}\n\nvoid fdsa_del(GF_Box *s)\n{\n\tGF_HintSample *ptr = (GF_HintSample *)s;\n\tgf_isom_box_array_del(ptr->packetTable);\n\tif (ptr->extra_data) gf_isom_box_del((GF_Box*)ptr->extra_data);\n\tgf_free(ptr);\n}\n\nGF_Err fdsa_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_HintSample *ptr = (GF_HintSample *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_FDPA:\n\t\tgf_list_add(ptr->packetTable, a);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_EXTR:\n\t\tif (ptr->extra_data) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->extra_data = (GF_ExtraDataBox*)a;\n\t\tbreak;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\nGF_Err fdsa_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, fdsa_AddBox);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fdsa_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HintSample *ptr = (GF_HintSample *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_array_write(s, ptr->packetTable, bs);\n\tif (e) return e;\n\tif (ptr->extra_data) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->extra_data, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err fdsa_Size(GF_Box *s)\n{\n\tGF_HintSample *ptr = (GF_HintSample*)s;\n\tGF_Err e;\n\n\t if (ptr->extra_data) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->extra_data);\n\t\tif (e) return e;\n\t\tptr->size += ptr->extra_data->size;\n\t}\n\treturn gf_isom_box_array_size(s, ptr->packetTable);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\n\nvoid trik_del(GF_Box *s)\n{\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n\nGF_Err trik_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tptr->entry_count = (u32) ptr->size;\n\tptr->entries = (GF_TrickPlayBoxEntry *) gf_malloc(ptr->entry_count * sizeof(GF_TrickPlayBoxEntry) );\n\tif (ptr->entries == NULL) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i< ptr->entry_count; i++) {\n\t\tptr->entries[i].pic_type = gf_bs_read_int(bs, 2);\n\t\tptr->entries[i].dependency_level = gf_bs_read_int(bs, 6);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *trik_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrickPlayBox, GF_ISOM_BOX_TYPE_TRIK);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err trik_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tfor (i=0; i < ptr->entry_count; i++ ) {\n\t\tgf_bs_write_int(bs, ptr->entries[i].pic_type, 2);\n\t\tgf_bs_write_int(bs, ptr->entries[i].dependency_level, 6);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err trik_Size(GF_Box *s)\n{\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tptr->size += 8 * ptr->entry_count;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid bloc_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err bloc_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_BaseLocationBox *ptr = (GF_BaseLocationBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 256)\n\tgf_bs_read_data(bs, (char *) ptr->baseLocation, 256);\n\tISOM_DECREASE_SIZE(s, 256)\n\tgf_bs_read_data(bs, (char *) ptr->basePurlLocation, 256);\n\tISOM_DECREASE_SIZE(s, 512)\n\tgf_bs_skip_bytes(bs, 512);\n\treturn GF_OK;\n}\n\nGF_Box *bloc_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_BaseLocationBox, GF_ISOM_BOX_TYPE_TRIK);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err bloc_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_BaseLocationBox *ptr = (GF_BaseLocationBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, (const char *) ptr->baseLocation, 256);\n\tgf_bs_write_data(bs, (const char *) ptr->basePurlLocation, 256);\n\tfor (i=0; i < 64; i++ ) {\n\t\tgf_bs_write_u64(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err bloc_Size(GF_Box *s)\n{\n\ts->size += 1024;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ainf_del(GF_Box *s)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\tif (ptr->APID) gf_free(ptr->APID);\n\tgf_free(s);\n}\n\nGF_Err ainf_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\n\tISOM_DECREASE_SIZE(s, 4)\n\tptr->profile_version = gf_bs_read_u32(bs);\n\treturn gf_isom_read_null_terminated_string(s, bs, s->size, &ptr->APID);\n}\n\nGF_Box *ainf_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AssetInformationBox, GF_ISOM_BOX_TYPE_AINF);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ainf_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->profile_version);\n\tgf_bs_write_data(bs, ptr->APID, (u32) strlen(ptr->APID) + 1);\n\treturn GF_OK;\n}\n\nGF_Err ainf_Size(GF_Box *s)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\ts->size += 4 +  strlen(ptr->APID) + 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/utf.h>\n#include <gpac/network.h>\n#include <gpac/color.h>\n#include <gpac/avparse.h>\n#include <time.h>\n\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\n\nstatic void dump_data(FILE *trace, char *data, u32 dataLength)\n{\n\tu32 i;\n\tfprintf(trace, \"data:application/octet-string,\");\n\tfor (i=0; i<dataLength; i++) {\n\t\tfprintf(trace, \"%02X\", (unsigned char) data[i]);\n\t}\n}\n\nstatic void dump_data_hex(FILE *trace, char *data, u32 dataLength)\n{\n\tu32 i;\n\tfprintf(trace, \"0x\");\n\tfor (i=0; i<dataLength; i++) {\n\t\tfprintf(trace, \"%02X\", (unsigned char) data[i]);\n\t}\n}\n\nstatic void dump_data_attribute(FILE *trace, char *name, char *data, u32 data_size)\n{\n\tu32 i;\n\tif (!data || !data_size) {\n\t\tfprintf(trace, \"%s=\\\"\\\"\", name);\n\t\treturn;\n\t}\n\tfprintf(trace, \"%s=\\\"0x\", name);\n\tfor (i=0; i<data_size; i++) fprintf(trace, \"%02X\", (unsigned char) data[i]);\n\tfprintf(trace, \"\\\" \");\n}\n\nstatic void dump_data_string(FILE *trace, char *data, u32 dataLength)\n{\n\tu32 i;\n\tfor (i=0; i<dataLength; i++) {\n\t\tswitch ((unsigned char) data[i]) {\n\t\tcase '\\'':\n\t\t\tfprintf(trace, \"&apos;\");\n\t\t\tbreak;\n\t\tcase '\\\"':\n\t\t\tfprintf(trace, \"&quot;\");\n\t\t\tbreak;\n\t\tcase '&':\n\t\t\tfprintf(trace, \"&amp;\");\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tfprintf(trace, \"&gt;\");\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tfprintf(trace, \"&lt;\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(trace, \"%c\", (u8) data[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nGF_Err gf_isom_box_dump(void *ptr, FILE * trace)\n{\n\treturn gf_isom_box_dump_ex(ptr, trace, 0);\n}\n\nGF_Err gf_isom_box_array_dump(GF_List *list, FILE * trace)\n{\n\tu32 i;\n\tGF_Box *a;\n\tif (!list) return GF_OK;\n\ti=0;\n\twhile ((a = (GF_Box *)gf_list_enum(list, &i))) {\n\t\tgf_isom_box_dump(a, trace);\n\t}\n\treturn GF_OK;\n}\n\nextern Bool use_dump_mode;\n\nGF_EXPORT\nGF_Err gf_isom_dump(GF_ISOFile *mov, FILE * trace)\n{\n\tu32 i;\n\tGF_Box *box;\n\tif (!mov || !trace) return GF_BAD_PARAM;\n\n\tuse_dump_mode = mov->dump_mode_alloc;\n\tfprintf(trace, \"<!--MP4Box dump trace-->\\n\");\n\n\tfprintf(trace, \"<IsoMediaFile xmlns=\\\"urn:mpeg:isobmff:schema:file:2016\\\" Name=\\\"%s\\\">\\n\", mov->fileName);\n\n\ti=0;\n\twhile ((box = (GF_Box *)gf_list_enum(mov->TopBoxes, &i))) {\n\t\tif (box->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\tfprintf(trace, \"<!--WARNING: Unknown Top-level Box Found -->\\n\");\n\t\t} else if (box->type==GF_ISOM_BOX_TYPE_UUID) {\n\t\t} else if (!gf_isom_box_is_file_level(box)) {\n\t\t\tfprintf(trace, \"<!--ERROR: Invalid Top-level Box Found (\\\"%s\\\")-->\\n\", gf_4cc_to_str(box->type));\n\t\t}\n\t\tgf_isom_box_dump(box, trace);\n\t}\n\tfprintf(trace, \"</IsoMediaFile>\\n\");\n\treturn GF_OK;\n}\n\nGF_Err reftype_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_TrackReferenceTypeBox *p = (GF_TrackReferenceTypeBox *)a;\n\tif (!p->reference_type) return GF_OK;\n\tp->type = p->reference_type;\n\n\tgf_isom_box_dump_start(a, \"TrackReferenceTypeBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tfor (i=0; i<p->trackIDCount; i++) {\n\t\tfprintf(trace, \"<TrackReferenceEntry TrackID=\\\"%d\\\"/>\\n\", p->trackIDs[i]);\n\t}\n\tif (!p->size)\n\t\tfprintf(trace, \"<TrackReferenceEntry TrackID=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"TrackReferenceTypeBox\", a, trace);\n\tp->type = GF_ISOM_BOX_TYPE_REFT;\n\treturn GF_OK;\n}\n\nGF_Err ireftype_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_ItemReferenceTypeBox *p = (GF_ItemReferenceTypeBox *)a;\n\tif (!p->reference_type) return GF_OK;\n\n\tp->type = p->reference_type;\n\tgf_isom_box_dump_start(a, \"ItemReferenceBox\", trace);\n\tfprintf(trace, \"from_item_id=\\\"%d\\\">\\n\", p->from_item_id);\n\tfor (i = 0; i < p->reference_count; i++) {\n\t\tfprintf(trace, \"<ItemReferenceBoxEntry ItemID=\\\"%d\\\"/>\\n\", p->to_item_IDs[i]);\n\t}\n\tif (!p->size)\n\t\tfprintf(trace, \"<ItemReferenceBoxEntry ItemID=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"ItemReferenceBox\", a, trace);\n\n\tp->type = GF_ISOM_BOX_TYPE_REFI;\n\treturn GF_OK;\n}\n\nGF_Err free_dump(GF_Box *a, FILE * trace)\n{\n\tGF_FreeSpaceBox *p = (GF_FreeSpaceBox *)a;\n\tgf_isom_box_dump_start(a, (a->type==GF_ISOM_BOX_TYPE_FREE) ? \"FreeSpaceBox\" : \"SkipBox\", trace);\n\tfprintf(trace, \"dataSize=\\\"%d\\\">\\n\", p->dataSize);\n\tgf_isom_box_dump_done( (a->type==GF_ISOM_BOX_TYPE_FREE) ? \"FreeSpaceBox\" : \"SkipBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err mdat_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MediaDataBox *p;\n\tconst char *name = (a->type==GF_ISOM_BOX_TYPE_IDAT ? \"ItemDataBox\" : \"MediaDataBox\");\n\tp = (GF_MediaDataBox *)a;\n\tgf_isom_box_dump_start(a, name, trace);\n\tfprintf(trace, \"dataSize=\\\"\"LLD\"\\\">\\n\", LLD_CAST p->dataSize);\n\tgf_isom_box_dump_done(name, a, trace);\n\treturn GF_OK;\n}\n\nGF_Err moov_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MovieBox *p;\n\tp = (GF_MovieBox *)a;\n\tgf_isom_box_dump_start(a, \"MovieBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->iods) gf_isom_box_dump(p->iods, trace);\n\tif (p->meta) gf_isom_box_dump(p->meta, trace);\n\t//dump only if size\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->mvhd, trace,GF_ISOM_BOX_TYPE_MVHD);\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (p->mvex) gf_isom_box_dump(p->mvex, trace);\n#endif\n\n\tgf_isom_box_array_dump(p->trackList, trace);\n\tif (p->udta) gf_isom_box_dump(p->udta, trace);\n\tgf_isom_box_dump_done(\"MovieBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err mvhd_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MovieHeaderBox *p;\n\n\tp = (GF_MovieHeaderBox *) a;\n\n\tgf_isom_box_dump_start(a, \"MovieHeaderBox\", trace);\n\tfprintf(trace, \"CreationTime=\\\"\"LLD\"\\\" \", LLD_CAST p->creationTime);\n\tfprintf(trace, \"ModificationTime=\\\"\"LLD\"\\\" \", LLD_CAST p->modificationTime);\n\tfprintf(trace, \"TimeScale=\\\"%d\\\" \", p->timeScale);\n\tfprintf(trace, \"Duration=\\\"\"LLD\"\\\" \", LLD_CAST p->duration);\n\tfprintf(trace, \"NextTrackID=\\\"%d\\\">\\n\", p->nextTrackID);\n\n\tgf_isom_box_dump_done(\"MovieHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err mdhd_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MediaHeaderBox *p;\n\n\tp = (GF_MediaHeaderBox *)a;\n\tgf_isom_box_dump_start(a, \"MediaHeaderBox\", trace);\n\tfprintf(trace, \"CreationTime=\\\"\"LLD\"\\\" \", LLD_CAST p->creationTime);\n\tfprintf(trace, \"ModificationTime=\\\"\"LLD\"\\\" \", LLD_CAST p->modificationTime);\n\tfprintf(trace, \"TimeScale=\\\"%d\\\" \", p->timeScale);\n\tfprintf(trace, \"Duration=\\\"\"LLD\"\\\" \", LLD_CAST p->duration);\n\tfprintf(trace, \"LanguageCode=\\\"%c%c%c\\\">\\n\", p->packedLanguage[0], p->packedLanguage[1], p->packedLanguage[2]);\n\tgf_isom_box_dump_done(\"MediaHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err vmhd_dump(GF_Box *a, FILE * trace)\n{\n\tgf_isom_box_dump_start(a, \"VideoMediaHeaderBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"VideoMediaHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err smhd_dump(GF_Box *a, FILE * trace)\n{\n\tgf_isom_box_dump_start(a, \"SoundMediaHeaderBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"SoundMediaHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err hmhd_dump(GF_Box *a, FILE * trace)\n{\n\tGF_HintMediaHeaderBox *p;\n\n\tp = (GF_HintMediaHeaderBox *)a;\n\n\tgf_isom_box_dump_start(a, \"HintMediaHeaderBox\", trace);\n\tfprintf(trace, \"MaximumPDUSize=\\\"%d\\\" \", p->maxPDUSize);\n\tfprintf(trace, \"AveragePDUSize=\\\"%d\\\" \", p->avgPDUSize);\n\tfprintf(trace, \"MaxBitRate=\\\"%d\\\" \", p->maxBitrate);\n\tfprintf(trace, \"AverageBitRate=\\\"%d\\\">\\n\", p->avgBitrate);\n\n\tgf_isom_box_dump_done(\"HintMediaHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err nmhd_dump(GF_Box *a, FILE * trace)\n{\n\tgf_isom_box_dump_start(a, \"MPEGMediaHeaderBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"MPEGMediaHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stbl_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SampleTableBox *p;\n\tp = (GF_SampleTableBox *)a;\n\tgf_isom_box_dump_start(a, \"SampleTableBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->SampleDescription, trace, GF_ISOM_BOX_TYPE_STSD);\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->TimeToSample, trace, GF_ISOM_BOX_TYPE_STTS);\n\n\tif (p->CompositionOffset) gf_isom_box_dump(p->CompositionOffset, trace);\n\tif (p->CompositionToDecode) gf_isom_box_dump(p->CompositionToDecode, trace);\n\tif (p->SyncSample) gf_isom_box_dump(p->SyncSample, trace);\n\tif (p->ShadowSync) gf_isom_box_dump(p->ShadowSync, trace);\n\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->SampleToChunk, trace, GF_ISOM_BOX_TYPE_STSC);\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->SampleSize, trace, GF_ISOM_BOX_TYPE_STSZ);\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->ChunkOffset, trace, GF_ISOM_BOX_TYPE_STCO);\n\n\tif (p->DegradationPriority) gf_isom_box_dump(p->DegradationPriority, trace);\n\tif (p->SampleDep) gf_isom_box_dump(p->SampleDep, trace);\n\tif (p->PaddingBits) gf_isom_box_dump(p->PaddingBits, trace);\n\tif (p->Fragments) gf_isom_box_dump(p->Fragments, trace);\n\tif (p->sub_samples) gf_isom_box_array_dump(p->sub_samples, trace);\n\tif (p->sampleGroupsDescription) gf_isom_box_array_dump(p->sampleGroupsDescription, trace);\n\tif (p->sampleGroups) gf_isom_box_array_dump(p->sampleGroups, trace);\n\tif (p->sai_sizes) {\n\t\tu32 i;\n\t\tfor (i = 0; i < gf_list_count(p->sai_sizes); i++) {\n\t\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(p->sai_sizes, i);\n\t\t\tgf_isom_box_dump(saiz, trace);\n\t\t}\n\t}\n\n\tif (p->sai_offsets) {\n\t\tu32 i;\n\t\tfor (i = 0; i < gf_list_count(p->sai_offsets); i++) {\n\t\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(p->sai_offsets, i);\n\t\t\tgf_isom_box_dump(saio, trace);\n\t\t}\n\t}\n\n\tgf_isom_box_dump_done(\"SampleTableBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err dinf_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DataInformationBox *p;\n\tp = (GF_DataInformationBox *)a;\n\tgf_isom_box_dump_start(a, \"DataInformationBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->dref, trace, GF_ISOM_BOX_TYPE_DREF);\n\n\tgf_isom_box_dump_done(\"DataInformationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err url_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DataEntryURLBox *p;\n\n\tp = (GF_DataEntryURLBox *)a;\n\tgf_isom_box_dump_start(a, \"URLDataEntryBox\", trace);\n\tif (p->location) {\n\t\tfprintf(trace, \" URL=\\\"%s\\\">\\n\", p->location);\n\t} else {\n\t\tfprintf(trace, \">\\n\");\n\t\tif (p->size) {\n\t\t\tif (! (p->flags & 1) ) {\n\t\t\t\tfprintf(trace, \"<!--ERROR: No location indicated-->\\n\");\n\t\t\t} else {\n\t\t\t\tfprintf(trace, \"<!--Data is contained in the movie file-->\\n\");\n\t\t\t}\n\t\t}\n\t}\n\tgf_isom_box_dump_done(\"URLDataEntryBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err urn_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DataEntryURNBox *p;\n\n\tp = (GF_DataEntryURNBox *)a;\n\tgf_isom_box_dump_start(a, \"URNDataEntryBox\", trace);\n\tif (p->nameURN) fprintf(trace, \" URN=\\\"%s\\\"\", p->nameURN);\n\tif (p->location) fprintf(trace, \" URL=\\\"%s\\\"\", p->location);\n\tfprintf(trace, \">\\n\");\n\n\tgf_isom_box_dump_done(\"URNDataEntryBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err cprt_dump(GF_Box *a, FILE * trace)\n{\n\tGF_CopyrightBox *p;\n\n\tp = (GF_CopyrightBox *)a;\n\tgf_isom_box_dump_start(a, \"CopyrightBox\", trace);\n\tfprintf(trace, \"LanguageCode=\\\"%s\\\" CopyrightNotice=\\\"%s\\\">\\n\", p->packedLanguageCode, p->notice);\n\tgf_isom_box_dump_done(\"CopyrightBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err kind_dump(GF_Box *a, FILE * trace)\n{\n\tGF_KindBox *p;\n\n\tp = (GF_KindBox *)a;\n\tgf_isom_box_dump_start(a, \"KindBox\", trace);\n\tfprintf(trace, \"schemeURI=\\\"%s\\\" value=\\\"%s\\\">\\n\", p->schemeURI, (p->value ? p->value : \"\"));\n\tgf_isom_box_dump_done(\"KindBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nstatic char *format_duration(u64 dur, u32 timescale, char *szDur)\n{\n\tu32 h, m, s, ms;\n\tdur = (u32) (( ((Double) (s64) dur)/timescale)*1000);\n\th = (u32) (dur / 3600000);\n\tdur -= h*3600000;\n\tm = (u32) (dur / 60000);\n\tdur -= m*60000;\n\ts = (u32) (dur/1000);\n\tdur -= s*1000;\n\tms = (u32) (dur);\n\tsprintf(szDur, \"%02d:%02d:%02d.%03d\", h, m, s, ms);\n\treturn szDur;\n}\n\nstatic void dump_escape_string(FILE * trace, char *name)\n{\n\tu32 i, len = (u32) strlen(name);\n\tfor (i=0; i<len; i++) {\n\t\tif (name[i]=='\"') fprintf(trace, \"&quot;\");\n\t\telse fputc(name[i], trace);\n\t}\n}\n\nGF_Err chpl_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i, count;\n\tchar szDur[20];\n\tGF_ChapterListBox *p = (GF_ChapterListBox *)a;\n\tgf_isom_box_dump_start(a, \"ChapterListBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\tif (p->size) {\n\t\tcount = gf_list_count(p->list);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ChapterEntry *ce = (GF_ChapterEntry *)gf_list_get(p->list, i);\n\t\t\tfprintf(trace, \"<Chapter name=\\\"\");\n\t\t\tdump_escape_string(trace, ce->name);\n\t\t\tfprintf(trace, \"\\\" startTime=\\\"%s\\\" />\\n\", format_duration(ce->start_time, 1000*10000, szDur));\n\t\t}\n\t} else {\n\t\tfprintf(trace, \"<Chapter name=\\\"\\\" startTime=\\\"\\\"/>\\n\");\n\t}\n\n\tgf_isom_box_dump_done(\"ChapterListBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err pdin_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_ProgressiveDownloadBox *p = (GF_ProgressiveDownloadBox *)a;\n\tgf_isom_box_dump_start(a, \"ProgressiveDownloadBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\tif (p->size) {\n\t\tfor (i=0; i<p->count; i++) {\n\t\t\tfprintf(trace, \"<DownloadInfo rate=\\\"%d\\\" estimatedTime=\\\"%d\\\" />\\n\", p->rates[i], p->times[i]);\n\t\t}\n\t} else {\n\t\tfprintf(trace, \"<DownloadInfo rate=\\\"\\\" estimatedTime=\\\"\\\" />\\n\");\n\t}\n\tgf_isom_box_dump_done(\"ProgressiveDownloadBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err hdlr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_HandlerBox *p = (GF_HandlerBox *)a;\n\tgf_isom_box_dump_start(a, \"HandlerBox\", trace);\n\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8)-1) {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n\t} else {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n\t}\n\tfprintf(trace, \"reserved1=\\\"%d\\\" reserved2=\\\"\", p->reserved1);\n\tdump_data(trace, (char *) p->reserved2, 12);\n\tfprintf(trace, \"\\\"\");\n\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HandlerBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err iods_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ObjectDescriptorBox *p;\n\n\tp = (GF_ObjectDescriptorBox *)a;\n\tgf_isom_box_dump_start(a, \"ObjectDescriptorBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\tif (p->descriptor) {\n#ifndef GPAC_DISABLE_OD_DUMP\n\t\tgf_odf_dump_desc(p->descriptor, trace, 1, GF_TRUE);\n#else\n\t\tfprintf(trace, \"<!-- Object Descriptor Dumping disabled in this build of GPAC -->\\n\");\n#endif\n\t} else if (p->size) {\n\t\tfprintf(trace, \"<!--WARNING: Object Descriptor not present-->\\n\");\n\t}\n\tgf_isom_box_dump_done(\"ObjectDescriptorBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err trak_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackBox *p;\n\n\tp = (GF_TrackBox *)a;\n\tgf_isom_box_dump_start(a, \"TrackBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->Header) {\n\t\tgf_isom_box_dump(p->Header, trace);\n\t} else if (p->size) {\n\t\tfprintf(trace, \"<!--INVALID FILE: Missing Track Header-->\\n\");\n\t}\n\tif (p->References) gf_isom_box_dump(p->References, trace);\n\tif (p->meta) gf_isom_box_dump(p->meta, trace);\n\tif (p->editBox) gf_isom_box_dump(p->editBox, trace);\n\tif (p->Media) gf_isom_box_dump(p->Media, trace);\n\tif (p->groups) gf_isom_box_dump(p->groups, trace);\n\tif (p->udta) gf_isom_box_dump(p->udta, trace);\n\tgf_isom_box_dump_done(\"TrackBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err mp4s_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MPEGSampleEntryBox *p;\n\n\tp = (GF_MPEGSampleEntryBox *)a;\n\tgf_isom_box_dump_start(a, \"MPEGSystemsSampleDescriptionBox\", trace);\n\tfprintf(trace, \"DataReferenceIndex=\\\"%d\\\">\\n\", p->dataReferenceIndex);\n\tif (p->esd) {\n\t\tgf_isom_box_dump(p->esd, trace);\n\t} else if (p->size) {\n\t\tfprintf(trace, \"<!--INVALID MP4 FILE: ESDBox not present in MPEG Sample Description or corrupted-->\\n\");\n\t}\n\tif (a->type == GF_ISOM_BOX_TYPE_ENCS) {\n\t\tgf_isom_box_array_dump(p->protections, trace);\n\t}\n\tgf_isom_box_dump_done(\"MPEGSystemsSampleDescriptionBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err video_sample_entry_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MPEGVisualSampleEntryBox *p = (GF_MPEGVisualSampleEntryBox *)a;\n\tconst char *name;\n\n\tswitch (p->type) {\n\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tname = \"AVCSampleEntryBox\";\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\tname = \"MVCSampleEntryBox\";\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\tname = \"SVCSampleEntryBox\";\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_HVC1:\n\tcase GF_ISOM_SUBTYPE_HEV1:\n\tcase GF_ISOM_SUBTYPE_HVC2:\n\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\tname = \"HEVCSampleEntryBox\";\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_LHV1:\n\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\tname = \"LHEVCSampleEntryBox\";\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tname = \"H263SampleDescriptionBox\";\n\t\tbreak;\n\tdefault:\n\t\tname = \"MPEGVisualSampleDescriptionBox\";\n\t}\n\n\tgf_isom_box_dump_start(a, name, trace);\n\n\tfprintf(trace, \" DataReferenceIndex=\\\"%d\\\" Width=\\\"%d\\\" Height=\\\"%d\\\"\", p->dataReferenceIndex, p->Width, p->Height);\n\n\t//dump reserved info\n\tfprintf(trace, \" XDPI=\\\"%d\\\" YDPI=\\\"%d\\\" BitDepth=\\\"%d\\\"\", p->horiz_res, p->vert_res, p->bit_depth);\n\tif (strlen((const char*)p->compressor_name) )\n\t\tfprintf(trace, \" CompressorName=\\\"%s\\\"\\n\", p->compressor_name+1);\n\n\n\tfprintf(trace, \">\\n\");\n\n\tif (p->esd) {\n\t\tgf_isom_box_dump(p->esd, trace);\n\t} else {\n\t\tif (p->hevc_config) gf_isom_box_dump(p->hevc_config, trace);\n\t\tif (p->avc_config) gf_isom_box_dump(p->avc_config, trace);\n\t\tif (p->ipod_ext) gf_isom_box_dump(p->ipod_ext, trace);\n\t\tif (p->descr) gf_isom_box_dump(p->descr, trace);\n\t\tif (p->svc_config) gf_isom_box_dump(p->svc_config, trace);\n\t\tif (p->mvc_config) gf_isom_box_dump(p->mvc_config, trace);\n\t\tif (p->lhvc_config) gf_isom_box_dump(p->lhvc_config, trace);\n\t\tif (p->cfg_3gpp) gf_isom_box_dump(p->cfg_3gpp, trace);\n\t}\n\tif (a->type == GF_ISOM_BOX_TYPE_ENCV) {\n\t\tgf_isom_box_array_dump(p->protections, trace);\n\t}\n\tif (p->pasp) gf_isom_box_dump(p->pasp, trace);\n\tif (p->rvcc) gf_isom_box_dump(p->rvcc, trace);\n\tif (p->rinf) gf_isom_box_dump(p->rinf, trace);\n\n\tgf_isom_box_dump_done(name, a, trace);\n\treturn GF_OK;\n}\n\n\nvoid base_audio_entry_dump(GF_AudioSampleEntryBox *p, FILE * trace)\n{\n\tfprintf(trace, \" DataReferenceIndex=\\\"%d\\\" SampleRate=\\\"%d\\\"\", p->dataReferenceIndex, p->samplerate_hi);\n\tfprintf(trace, \" Channels=\\\"%d\\\" BitsPerSample=\\\"%d\\\"\", p->channel_count, p->bitspersample);\n}\n\nGF_Err audio_sample_entry_dump(GF_Box *a, FILE * trace)\n{\n\tchar *szName;\n\tBool is_3gpp = GF_FALSE;\n\tGF_MPEGAudioSampleEntryBox *p = (GF_MPEGAudioSampleEntryBox *)a;\n\n\tswitch (p->type) {\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\tszName = \"AMRSampleDescriptionBox\";\n\t\tis_3gpp = GF_TRUE;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\tszName = \"AMR_WB_SampleDescriptionBox\";\n\t\tis_3gpp = GF_TRUE;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tszName = \"EVRCSampleDescriptionBox\";\n\t\tis_3gpp = GF_TRUE;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\tszName = \"QCELPSampleDescriptionBox\";\n\t\tis_3gpp = GF_TRUE;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tszName = \"SMVSampleDescriptionBox\";\n\t\tis_3gpp = GF_TRUE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tszName = \"MPEGAudioSampleDescriptionBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AC3:\n\t\tszName = \"AC3SampleEntryBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_EC3:\n\t\tszName = \"EC3SampleEntryBox\";\n\t\tbreak;\n\tdefault:\n\t\tszName = \"AudioSampleDescriptionBox\";\n\t\tbreak;\n\t}\n\n\tgf_isom_box_dump_start(a, szName, trace);\n\tbase_audio_entry_dump((GF_AudioSampleEntryBox *)p, trace);\n\tfprintf(trace, \">\\n\");\n\n\tif (p->esd) {\n\t\tgf_isom_box_dump(p->esd, trace);\n\t} else if (p->cfg_3gpp) {\n\t\tgf_isom_box_dump(p->cfg_3gpp, trace);\n\n\t} else if (p->cfg_ac3) {\n\t\tif (p->size)\n\t\t\tgf_isom_box_dump(p->cfg_ac3, trace);\n\n\t} else if (p->size) {\n\t\tif (is_3gpp) {\n\t\t\tfprintf(trace, \"<!-- INVALID 3GPP FILE: Config not present in Sample Description-->\\n\");\n\t\t} else {\n\t\t\tfprintf(trace, \"<!--INVALID MP4 FILE: ESDBox not present in MPEG Sample Description or corrupted-->\\n\");\n\t\t}\n\t}\n\tif (a->type == GF_ISOM_BOX_TYPE_ENCA) {\n\t\tgf_isom_box_array_dump(p->protections, trace);\n\t}\n\tgf_isom_box_dump_done(szName, a, trace);\n\treturn GF_OK;\n}\n\nGF_Err gnrm_dump(GF_Box *a, FILE * trace)\n{\n\tGF_GenericSampleEntryBox *p = (GF_GenericSampleEntryBox *)a;\n\tif (p->EntryType)\n\t\ta->type = p->EntryType;\n\n\tgf_isom_box_dump_start(a, \"SampleDescriptionBox\", trace);\n\tfprintf(trace, \"DataReferenceIndex=\\\"%d\\\" ExtensionDataSize=\\\"%d\\\">\\n\", p->dataReferenceIndex, p->data_size);\n\ta->type = GF_ISOM_BOX_TYPE_GNRM;\n\tgf_isom_box_dump_done(\"SampleDescriptionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err gnrv_dump(GF_Box *a, FILE * trace)\n{\n\tGF_GenericVisualSampleEntryBox *p = (GF_GenericVisualSampleEntryBox *)a;\n\tif (p->EntryType)\n\t\ta->type = p->EntryType;\n\n\tgf_isom_box_dump_start(a, \"VisualSampleDescriptionBox\", trace);\n\tfprintf(trace, \"DataReferenceIndex=\\\"%d\\\" Version=\\\"%d\\\" Revision=\\\"%d\\\" Vendor=\\\"%d\\\" TemporalQuality=\\\"%d\\\" SpacialQuality=\\\"%d\\\" Width=\\\"%d\\\" Height=\\\"%d\\\" HorizontalResolution=\\\"%d\\\" VerticalResolution=\\\"%d\\\" CompressorName=\\\"%s\\\" BitDepth=\\\"%d\\\">\\n\",\n\t        p->dataReferenceIndex, p->version, p->revision, p->vendor, p->temporal_quality, p->spatial_quality, p->Width, p->Height, p->horiz_res, p->vert_res, p->compressor_name+1, p->bit_depth);\n\ta->type = GF_ISOM_BOX_TYPE_GNRV;\n\tgf_isom_box_dump_done(\"VisualSampleDescriptionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err gnra_dump(GF_Box *a, FILE * trace)\n{\n\tGF_GenericAudioSampleEntryBox *p = (GF_GenericAudioSampleEntryBox *)a;\n\tif (p->EntryType)\n\t\ta->type = p->EntryType;\n\n\tgf_isom_box_dump_start(a, \"AudioSampleDescriptionBox\", trace);\n\tfprintf(trace, \"DataReferenceIndex=\\\"%d\\\" Version=\\\"%d\\\" Revision=\\\"%d\\\" Vendor=\\\"%d\\\" ChannelCount=\\\"%d\\\" BitsPerSample=\\\"%d\\\" Samplerate=\\\"%d\\\">\\n\",\n\t        p->dataReferenceIndex, p->version, p->revision, p->vendor, p->channel_count, p->bitspersample, p->samplerate_hi);\n\ta->type = GF_ISOM_BOX_TYPE_GNRA;\n\tgf_isom_box_dump_done(\"AudioSampleDescriptionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err edts_dump(GF_Box *a, FILE * trace)\n{\n\tGF_EditBox *p;\n\n\tp = (GF_EditBox *)a;\n\tgf_isom_box_dump_start(a, \"EditBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->editList, trace, GF_ISOM_BOX_TYPE_ELST);\n\tgf_isom_box_dump_done(\"EditBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err udta_dump(GF_Box *a, FILE * trace)\n{\n\tGF_UserDataBox *p;\n\tGF_UserDataMap *map;\n\tu32 i;\n\n\tp = (GF_UserDataBox *)a;\n\tgf_isom_box_dump_start(a, \"UserDataBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap *)gf_list_enum(p->recordList, &i))) {\n\t\tgf_isom_box_array_dump(map->other_boxes, trace);\n\t}\n\tgf_isom_box_dump_done(\"UserDataBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err dref_dump(GF_Box *a, FILE * trace)\n{\n//\tGF_DataReferenceBox *p = (GF_DataReferenceBox *)a;\n\tgf_isom_box_dump_start(a, \"DataReferenceBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"DataReferenceBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stsd_dump(GF_Box *a, FILE * trace)\n{\n//\tGF_SampleDescriptionBox *p = (GF_SampleDescriptionBox *)a;\n\tgf_isom_box_dump_start(a, \"SampleDescriptionBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"SampleDescriptionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stts_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TimeToSampleBox *p;\n\tu32 i, nb_samples;\n\n\tp = (GF_TimeToSampleBox *)a;\n\tgf_isom_box_dump_start(a, \"TimeToSampleBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", p->nb_entries);\n\n\tnb_samples = 0;\n\tfor (i=0; i<p->nb_entries; i++) {\n\t\tfprintf(trace, \"<TimeToSampleEntry SampleDelta=\\\"%d\\\" SampleCount=\\\"%d\\\"/>\\n\", p->entries[i].sampleDelta, p->entries[i].sampleCount);\n\t\tnb_samples += p->entries[i].sampleCount;\n\t}\n\tif (p->size)\n\t\tfprintf(trace, \"<!-- counted %d samples in STTS entries -->\\n\", nb_samples);\n\telse\n\t\tfprintf(trace, \"<TimeToSampleEntry SampleDelta=\\\"\\\" SampleCount=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"TimeToSampleBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ctts_dump(GF_Box *a, FILE * trace)\n{\n\tGF_CompositionOffsetBox *p;\n\tu32 i, nb_samples;\n\tp = (GF_CompositionOffsetBox *)a;\n\tgf_isom_box_dump_start(a, \"CompositionOffsetBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", p->nb_entries);\n\n\tnb_samples = 0;\n\tfor (i=0; i<p->nb_entries; i++) {\n\t\tfprintf(trace, \"<CompositionOffsetEntry CompositionOffset=\\\"%d\\\" SampleCount=\\\"%d\\\"/>\\n\", p->entries[i].decodingOffset, p->entries[i].sampleCount);\n\t\tnb_samples += p->entries[i].sampleCount;\n\t}\n\tif (p->size)\n\t\tfprintf(trace, \"<!-- counted %d samples in CTTS entries -->\\n\", nb_samples);\n\telse\n\t\tfprintf(trace, \"<CompositionOffsetEntry CompositionOffset=\\\"\\\" SampleCount=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"CompositionOffsetBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err cslg_dump(GF_Box *a, FILE * trace)\n{\n\tGF_CompositionToDecodeBox *p;\n\n\tp = (GF_CompositionToDecodeBox *)a;\n\tgf_isom_box_dump_start(a, \"CompositionToDecodeBox\", trace);\n\tfprintf(trace, \"compositionToDTSShift=\\\"%d\\\" leastDecodeToDisplayDelta=\\\"%d\\\" compositionStartTime=\\\"%d\\\" compositionEndTime=\\\"%d\\\">\\n\", p->leastDecodeToDisplayDelta, p->greatestDecodeToDisplayDelta, p->compositionStartTime, p->compositionEndTime);\n\tgf_isom_box_dump_done(\"CompositionToDecodeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ccst_dump(GF_Box *a, FILE * trace)\n{\n\tGF_CodingConstraintsBox *p = (GF_CodingConstraintsBox *)a;\n\tgf_isom_box_dump_start(a, \"CodingConstraintsBox\", trace);\n\tfprintf(trace, \"all_ref_pics_intra=\\\"%d\\\" intra_pred_used=\\\"%d\\\" max_ref_per_pic=\\\"%d\\\" reserved=\\\"%d\\\">\\n\", p->all_ref_pics_intra, p->intra_pred_used, p->max_ref_per_pic, p->reserved);\n\tgf_isom_box_dump_done(\"CodingConstraintsBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stsh_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ShadowSyncBox *p;\n\tu32 i;\n\tGF_StshEntry *t;\n\n\tp = (GF_ShadowSyncBox *)a;\n\tgf_isom_box_dump_start(a, \"SyncShadowBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", gf_list_count(p->entries));\n\ti=0;\n\twhile ((t = (GF_StshEntry *)gf_list_enum(p->entries, &i))) {\n\t\tfprintf(trace, \"<SyncShadowEntry ShadowedSample=\\\"%d\\\" SyncSample=\\\"%d\\\"/>\\n\", t->shadowedSampleNumber, t->syncSampleNumber);\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<SyncShadowEntry ShadowedSample=\\\"\\\" SyncSample=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SyncShadowBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err elst_dump(GF_Box *a, FILE * trace)\n{\n\tGF_EditListBox *p;\n\tu32 i;\n\tGF_EdtsEntry *t;\n\n\tp = (GF_EditListBox *)a;\n\tgf_isom_box_dump_start(a, \"EditListBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", gf_list_count(p->entryList));\n\n\ti=0;\n\twhile ((t = (GF_EdtsEntry *)gf_list_enum(p->entryList, &i))) {\n\t\tfprintf(trace, \"<EditListEntry Duration=\\\"\"LLD\"\\\" MediaTime=\\\"\"LLD\"\\\" MediaRate=\\\"%u\\\"/>\\n\", LLD_CAST t->segmentDuration, LLD_CAST t->mediaTime, t->mediaRate);\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<EditListEntry Duration=\\\"\\\" MediaTime=\\\"\\\" MediaRate=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"EditListBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stsc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SampleToChunkBox *p;\n\tu32 i, nb_samples;\n\n\tp = (GF_SampleToChunkBox *)a;\n\tgf_isom_box_dump_start(a, \"SampleToChunkBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", p->nb_entries);\n\n\tnb_samples = 0;\n\tfor (i=0; i<p->nb_entries; i++) {\n\t\tfprintf(trace, \"<SampleToChunkEntry FirstChunk=\\\"%d\\\" SamplesPerChunk=\\\"%d\\\" SampleDescriptionIndex=\\\"%d\\\"/>\\n\", p->entries[i].firstChunk, p->entries[i].samplesPerChunk, p->entries[i].sampleDescriptionIndex);\n\t\tif (i+1<p->nb_entries) {\n\t\t\tnb_samples += (p->entries[i+1].firstChunk - p->entries[i].firstChunk) * p->entries[i].samplesPerChunk;\n\t\t} else {\n\t\t\tnb_samples += p->entries[i].samplesPerChunk;\n\t\t}\n\t}\n\tif (p->size)\n\t\tfprintf(trace, \"<!-- counted %d samples in STSC entries (could be less than sample count) -->\\n\", nb_samples);\n\telse\n\t\tfprintf(trace, \"<SampleToChunkEntry FirstChunk=\\\"\\\" SamplesPerChunk=\\\"\\\" SampleDescriptionIndex=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"SampleToChunkBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stsz_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SampleSizeBox *p;\n\tu32 i;\n\tp = (GF_SampleSizeBox *)a;\n\n\tif (a->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tgf_isom_box_dump_start(a, \"SampleSizeBox\", trace);\n\t}\n\telse {\n\t\tgf_isom_box_dump_start(a, \"CompactSampleSizeBox\", trace);\n\t}\n\n\tfprintf(trace, \"SampleCount=\\\"%d\\\"\",  p->sampleCount);\n\tif (a->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (p->sampleSize) {\n\t\t\tfprintf(trace, \" ConstantSampleSize=\\\"%d\\\"\", p->sampleSize);\n\t\t}\n\t} else {\n\t\tfprintf(trace, \" SampleSizeBits=\\\"%d\\\"\", p->sampleSize);\n\t}\n\tfprintf(trace, \">\\n\");\n\n\tif ((a->type != GF_ISOM_BOX_TYPE_STSZ) || !p->sampleSize) {\n\t\tif (!p->sizes && p->size) {\n\t\t\tfprintf(trace, \"<!--WARNING: No Sample Size indications-->\\n\");\n\t\t} else {\n\t\t\tfor (i=0; i<p->sampleCount; i++) {\n\t\t\t\tfprintf(trace, \"<SampleSizeEntry Size=\\\"%d\\\"/>\\n\", p->sizes[i]);\n\t\t\t}\n\t\t}\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<SampleSizeEntry Size=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done((a->type == GF_ISOM_BOX_TYPE_STSZ) ? \"SampleSizeBox\" : \"CompactSampleSizeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stco_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ChunkOffsetBox *p;\n\tu32 i;\n\n\tp = (GF_ChunkOffsetBox *)a;\n\tgf_isom_box_dump_start(a, \"ChunkOffsetBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", p->nb_entries);\n\n\tif (!p->offsets && p->size) {\n\t\tfprintf(trace, \"<!--Warning: No Chunk Offsets indications-->\\n\");\n\t} else {\n\t\tfor (i=0; i<p->nb_entries; i++) {\n\t\t\tfprintf(trace, \"<ChunkEntry offset=\\\"%u\\\"/>\\n\", p->offsets[i]);\n\t\t}\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<ChunkEntry offset=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"ChunkOffsetBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stss_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SyncSampleBox *p;\n\tu32 i;\n\n\tp = (GF_SyncSampleBox *)a;\n\tgf_isom_box_dump_start(a, \"SyncSampleBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", p->nb_entries);\n\n\tif (!p->sampleNumbers && p->size) {\n\t\tfprintf(trace, \"<!--Warning: No Key Frames indications-->\\n\");\n\t} else {\n\t\tfor (i=0; i<p->nb_entries; i++) {\n\t\t\tfprintf(trace, \"<SyncSampleEntry sampleNumber=\\\"%u\\\"/>\\n\", p->sampleNumbers[i]);\n\t\t}\n\t}\n\tif (!p->size) {\n\t\t\tfprintf(trace, \"<SyncSampleEntry sampleNumber=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SyncSampleBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stdp_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DegradationPriorityBox *p;\n\tu32 i;\n\n\tp = (GF_DegradationPriorityBox *)a;\n\tgf_isom_box_dump_start(a, \"DegradationPriorityBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", p->nb_entries);\n\n\tif (!p->priorities && p->size) {\n\t\tfprintf(trace, \"<!--Warning: No Degradation Priority indications-->\\n\");\n\t} else {\n\t\tfor (i=0; i<p->nb_entries; i++) {\n\t\t\tfprintf(trace, \"<DegradationPriorityEntry DegradationPriority=\\\"%d\\\"/>\\n\", p->priorities[i]);\n\t\t}\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<DegradationPriorityEntry DegradationPriority=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"DegradationPriorityBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err sdtp_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SampleDependencyTypeBox *p;\n\tu32 i;\n\n\tp = (GF_SampleDependencyTypeBox*)a;\n\tgf_isom_box_dump_start(a, \"SampleDependencyTypeBox\", trace);\n\tfprintf(trace, \"SampleCount=\\\"%d\\\">\\n\", p->sampleCount);\n\n\tif (!p->sample_info && p->size) {\n\t\tfprintf(trace, \"<!--Warning: No sample dependencies indications-->\\n\");\n\t} else {\n\t\tfor (i=0; i<p->sampleCount; i++) {\n\t\t\tu8 flag = p->sample_info[i];\n\t\t\tfprintf(trace, \"<SampleDependencyEntry \");\n\t\t\tswitch ( (flag >> 4) & 3) {\n\t\t\tcase 0:\n\t\t\t\tfprintf(trace, \"dependsOnOther=\\\"unknown\\\" \");\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tfprintf(trace, \"dependsOnOther=\\\"yes\\\" \");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tfprintf(trace, \"dependsOnOther=\\\"no\\\" \");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfprintf(trace, \"dependsOnOther=\\\"RESERVED\\\" \");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch ( (flag >> 2) & 3) {\n\t\t\tcase 0:\n\t\t\t\tfprintf(trace, \"dependedOn=\\\"unknown\\\" \");\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tfprintf(trace, \"dependedOn=\\\"yes\\\" \");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tfprintf(trace, \"dependedOn=\\\"no\\\" \");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfprintf(trace, \"dependedOn=\\\"RESERVED\\\" \");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch ( flag & 3) {\n\t\t\tcase 0:\n\t\t\t\tfprintf(trace, \"hasRedundancy=\\\"unknown\\\" \");\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tfprintf(trace, \"hasRedundancy=\\\"yes\\\" \");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tfprintf(trace, \"hasRedundancy=\\\"no\\\" \");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfprintf(trace, \"hasRedundancy=\\\"RESERVED\\\" \");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfprintf(trace, \" />\\n\");\n\t\t}\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<SampleDependencyEntry dependsOnOther=\\\"unknown|yes|no|RESERVED\\\" dependedOn=\\\"unknown|yes|no|RESERVED\\\" hasRedundancy=\\\"unknown|yes|no|RESERVED\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SampleDependencyTypeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err co64_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ChunkLargeOffsetBox *p;\n\tu32 i;\n\n\tp = (GF_ChunkLargeOffsetBox *)a;\n\tgf_isom_box_dump_start(a, \"ChunkLargeOffsetBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", p->nb_entries);\n\n\tif (!p->offsets && p->size) {\n\t\tfprintf(trace, \"<!-- Warning: No Chunk Offsets indications/>\\n\");\n\t} else {\n\t\tfor (i=0; i<p->nb_entries; i++)\n\t\t\tfprintf(trace, \"<ChunkOffsetEntry offset=\\\"\"LLU\"\\\"/>\\n\", LLU_CAST p->offsets[i]);\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<ChunkOffsetEntry offset=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"ChunkLargeOffsetBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err esds_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ESDBox *p;\n\n\tp = (GF_ESDBox *)a;\n\tgf_isom_box_dump_start(a, \"MPEG4ESDescriptorBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\tif (p->desc) {\n#ifndef GPAC_DISABLE_OD_DUMP\n\t\tgf_odf_dump_desc((GF_Descriptor *) p->desc, trace, 1, GF_TRUE);\n#else\n\t\tfprintf(trace, \"<!-- Object Descriptor Dumping disabled in this build of GPAC -->\\n\");\n#endif\n\t} else if (p->size) {\n\t\tfprintf(trace, \"<!--INVALID MP4 FILE: ESD not present in MPEG Sample Description or corrupted-->\\n\");\n\t}\n\tgf_isom_box_dump_done(\"MPEG4ESDescriptorBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err minf_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MediaInformationBox *p;\n\n\tp = (GF_MediaInformationBox *)a;\n\tgf_isom_box_dump_start(a, \"MediaInformationBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->InfoHeader, trace, GF_ISOM_BOX_TYPE_NMHD);\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->dataInformation, trace, GF_ISOM_BOX_TYPE_DINF);\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->sampleTable, trace, GF_ISOM_BOX_TYPE_STBL);\n\n\tgf_isom_box_dump_done(\"MediaInformationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tkhd_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackHeaderBox *p;\n\tp = (GF_TrackHeaderBox *)a;\n\tgf_isom_box_dump_start(a, \"TrackHeaderBox\", trace);\n\n\tfprintf(trace, \"CreationTime=\\\"\"LLD\"\\\" ModificationTime=\\\"\"LLD\"\\\" TrackID=\\\"%u\\\" Duration=\\\"\"LLD\"\\\"\",\n\t        LLD_CAST p->creationTime, LLD_CAST p->modificationTime, p->trackID, LLD_CAST p->duration);\n\n\tif (p->alternate_group) fprintf(trace, \" AlternateGroupID=\\\"%d\\\"\", p->alternate_group);\n\tif (p->volume) {\n\t\tfprintf(trace, \" Volume=\\\"%.2f\\\"\", (Float)p->volume / 256);\n\t} else if (p->width || p->height) {\n\t\tfprintf(trace, \" Width=\\\"%.2f\\\" Height=\\\"%.2f\\\"\", (Float)p->width / 65536, (Float)p->height / 65536);\n\t\tif (p->layer) fprintf(trace, \" Layer=\\\"%d\\\"\", p->layer);\n\t}\n\tfprintf(trace, \">\\n\");\n\tif (p->width || p->height) {\n\t\tfprintf(trace, \"<Matrix m11=\\\"0x%.8x\\\" m12=\\\"0x%.8x\\\" m13=\\\"0x%.8x\\\" \", p->matrix[0], p->matrix[1], p->matrix[2]);\n\t\tfprintf(trace, \"m21=\\\"0x%.8x\\\" m22=\\\"0x%.8x\\\" m23=\\\"0x%.8x\\\" \", p->matrix[3], p->matrix[4], p->matrix[5]);\n\t\tfprintf(trace, \"m31=\\\"0x%.8x\\\" m32=\\\"0x%.8x\\\" m33=\\\"0x%.8x\\\"/>\\n\", p->matrix[6], p->matrix[7], p->matrix[8]);\n\t}\n\n\tgf_isom_box_dump_done(\"TrackHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tref_dump(GF_Box *a, FILE * trace)\n{\n//\tGF_TrackReferenceBox *p = (GF_TrackReferenceBox *)a;\n\tgf_isom_box_dump_start(a, \"TrackReferenceBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"TrackReferenceBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err mdia_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MediaBox *p = (GF_MediaBox *)a;\n\tgf_isom_box_dump_start(a, \"MediaBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->mediaHeader, trace, GF_ISOM_BOX_TYPE_MDHD);\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->handler, trace,GF_ISOM_BOX_TYPE_HDLR);\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->information, trace, GF_ISOM_BOX_TYPE_MINF);\n\tgf_isom_box_dump_done(\"MediaBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err mfra_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MovieFragmentRandomAccessBox *p = (GF_MovieFragmentRandomAccessBox *)a;\n\tu32 i, count;\n\tGF_TrackFragmentRandomAccessBox *tfra;\n\n\tgf_isom_box_dump_start(a, \"MovieFragmentRandomAccessBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tcount = gf_list_count(p->tfra_list);\n\tfor (i=0; i<count; i++) {\n\t\ttfra = (GF_TrackFragmentRandomAccessBox *)gf_list_get(p->tfra_list, i);\n\t\tgf_isom_box_dump_ex(tfra, trace, GF_ISOM_BOX_TYPE_TFRA);\n\t}\n\tgf_isom_box_dump_done(\"MovieFragmentRandomAccessBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tfra_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_TrackFragmentRandomAccessBox *p = (GF_TrackFragmentRandomAccessBox *)a;\n\tgf_isom_box_dump_start(a, \"TrackFragmentRandomAccessBox\", trace);\n\tfprintf(trace, \"TrackId=\\\"%u\\\" number_of_entries=\\\"%u\\\">\\n\", p->track_id, p->nb_entries);\n\tfor (i=0; i<p->nb_entries; i++) {\n\t\tfprintf(trace, \"<RandomAccessEntry time=\\\"\"LLU\"\\\" moof_offset=\\\"\"LLU\"\\\" traf=\\\"%u\\\" trun=\\\"%u\\\" sample=\\\"%u\\\"/>\\n\",\n\t\t\tp->entries[i].time, p->entries[i].moof_offset,\n\t\t\tp->entries[i].traf_number, p->entries[i].trun_number, p->entries[i].sample_number);\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<RandomAccessEntry time=\\\"\\\" moof_offset=\\\"\\\" traf=\\\"\\\" trun=\\\"\\\" sample=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"TrackFragmentRandomAccessBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err mfro_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MovieFragmentRandomAccessOffsetBox *p = (GF_MovieFragmentRandomAccessOffsetBox *)a;\n\n\tgf_isom_box_dump_start(a, \"MovieFragmentRandomAccessOffsetBox\", trace);\n\n\tfprintf(trace, \"container_size=\\\"%d\\\" >\\n\", p->container_size);\n\tgf_isom_box_dump_done(\"MovieFragmentRandomAccessOffsetBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err elng_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ExtendedLanguageBox *p = (GF_ExtendedLanguageBox *)a;\n\tgf_isom_box_dump_start(a, \"ExtendedLanguageBox\", trace);\n\tfprintf(trace, \"LanguageCode=\\\"%s\\\">\\n\", p->extended_language);\n\tgf_isom_box_dump_done(\"ExtendedLanguageBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err unkn_dump(GF_Box *a, FILE * trace)\n{\n\tGF_UnknownBox *u = (GF_UnknownBox *)a;\n\tu->type = u->original_4cc;\n\tgf_isom_box_dump_start(a, \"UnknownBox\", trace);\n\tu->type = GF_ISOM_BOX_TYPE_UNKNOWN;\n\tif (u->dataSize<100)\n\t\tdump_data_attribute(trace, \"data\", u->data, u->dataSize);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"UnknownBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err uuid_dump(GF_Box *a, FILE * trace)\n{\n\tgf_isom_box_dump_start(a, \"UUIDBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"UUIDBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err void_dump(GF_Box *a, FILE * trace)\n{\n\tgf_isom_box_dump_start(a, \"VoidBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"VoidBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ftyp_dump(GF_Box *a, FILE * trace)\n{\n\tGF_FileTypeBox *p;\n\tu32 i;\n\n\tp = (GF_FileTypeBox *)a;\n\tgf_isom_box_dump_start(a, (a->type == GF_ISOM_BOX_TYPE_FTYP ? \"FileTypeBox\" : \"SegmentTypeBox\"), trace);\n\tfprintf(trace, \"MajorBrand=\\\"%s\\\" MinorVersion=\\\"%d\\\">\\n\", gf_4cc_to_str(p->majorBrand), p->minorVersion);\n\n\tfor (i=0; i<p->altCount; i++) {\n\t\tfprintf(trace, \"<BrandEntry AlternateBrand=\\\"%s\\\"/>\\n\", gf_4cc_to_str(p->altBrand[i]));\n\t}\n\tif (!p->type) {\n\t\tfprintf(trace, \"<BrandEntry AlternateBrand=\\\"4CC\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done((a->type == GF_ISOM_BOX_TYPE_FTYP ? \"FileTypeBox\" : \"SegmentTypeBox\"), a, trace);\n\treturn GF_OK;\n}\n\nGF_Err padb_dump(GF_Box *a, FILE * trace)\n{\n\tGF_PaddingBitsBox *p;\n\tu32 i;\n\n\tp = (GF_PaddingBitsBox *)a;\n\tgf_isom_box_dump_start(a, \"PaddingBitsBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", p->SampleCount);\n\tfor (i=0; i<p->SampleCount; i+=1) {\n\t\tfprintf(trace, \"<PaddingBitsEntry PaddingBits=\\\"%d\\\"/>\\n\", p->padbits[i]);\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<PaddingBitsEntry PaddingBits=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"PaddingBitsBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stsf_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SampleFragmentBox *p;\n\tGF_StsfEntry *ent;\n\tu32 i, j, count;\n\n\n\tp = (GF_SampleFragmentBox *)a;\n\tcount = gf_list_count(p->entryList);\n\tgf_isom_box_dump_start(a, \"SampleFragmentBox\", trace);\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", count);\n\n\tfor (i=0; i<count; i++) {\n\t\tent = (GF_StsfEntry *)gf_list_get(p->entryList, i);\n\t\tfprintf(trace, \"<SampleFragmentEntry SampleNumber=\\\"%d\\\" FragmentCount=\\\"%d\\\">\\n\", ent->SampleNumber, ent->fragmentCount);\n\t\tfor (j=0; j<ent->fragmentCount; j++) fprintf(trace, \"<FragmentSizeEntry size=\\\"%d\\\"/>\\n\", ent->fragmentSizes[j]);\n\t\tfprintf(trace, \"</SampleFragmentEntry>\\n\");\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<SampleFragmentEntry SampleNumber=\\\"\\\" FragmentCount=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<FragmentSizeEntry size=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</SampleFragmentEntry>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SampleFragmentBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err gppc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_3GPPConfigBox *p = (GF_3GPPConfigBox *)a;\n\tconst char *name = gf_4cc_to_str(p->cfg.vendor);\n\tswitch (p->cfg.type) {\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\tgf_isom_box_dump_start(a, \"AMRConfigurationBox\", trace);\n\t\tfprintf(trace, \"Vendor=\\\"%s\\\" Version=\\\"%d\\\"\", name, p->cfg.decoder_version);\n\t\tfprintf(trace, \" FramesPerSample=\\\"%d\\\" SupportedModes=\\\"%x\\\" ModeRotating=\\\"%d\\\"\", p->cfg.frames_per_sample, p->cfg.AMR_mode_set, p->cfg.AMR_mode_change_period);\n\t\tfprintf(trace, \">\\n\");\n\t\tgf_isom_box_dump_done(\"AMRConfigurationBox\", a, trace);\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tgf_isom_box_dump_start(a, \"EVRCConfigurationBox\", trace);\n\t\tfprintf(trace, \"Vendor=\\\"%s\\\" Version=\\\"%d\\\" FramesPerSample=\\\"%d\\\" >\\n\", name, p->cfg.decoder_version, p->cfg.frames_per_sample);\n\t\tgf_isom_box_dump_done(\"EVRCConfigurationBox\", a, trace);\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\tgf_isom_box_dump_start(a, \"QCELPConfigurationBox\", trace);\n\t\tfprintf(trace, \"Vendor=\\\"%s\\\" Version=\\\"%d\\\" FramesPerSample=\\\"%d\\\" >\\n\", name, p->cfg.decoder_version, p->cfg.frames_per_sample);\n\t\tgf_isom_box_dump_done(\"QCELPConfigurationBox\", a, trace);\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tgf_isom_box_dump_start(a, \"SMVConfigurationBox\", trace);\n\t\tfprintf(trace, \"Vendor=\\\"%s\\\" Version=\\\"%d\\\" FramesPerSample=\\\"%d\\\" >\\n\", name, p->cfg.decoder_version, p->cfg.frames_per_sample);\n\t\tgf_isom_box_dump_done(\"SMVConfigurationBox\", a, trace);\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tgf_isom_box_dump_start(a, \"H263ConfigurationBox\", trace);\n\t\tfprintf(trace, \"Vendor=\\\"%s\\\" Version=\\\"%d\\\"\", name, p->cfg.decoder_version);\n\t\tfprintf(trace, \" Profile=\\\"%d\\\" Level=\\\"%d\\\"\", p->cfg.H263_profile, p->cfg.H263_level);\n\t\tfprintf(trace, \">\\n\");\n\t\tgf_isom_box_dump_done(\"H263ConfigurationBox\", a, trace);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err avcc_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i, count;\n\tGF_AVCConfigurationBox *p = (GF_AVCConfigurationBox *) a;\n\tconst char *name = (p->type==GF_ISOM_BOX_TYPE_MVCC) ? \"MVC\" : (p->type==GF_ISOM_BOX_TYPE_SVCC) ? \"SVC\" : \"AVC\";\n\tchar boxname[256];\n\tsprintf(boxname, \"%sConfigurationBox\", name);\n\tgf_isom_box_dump_start(a, boxname, trace);\n\tfprintf(trace, \">\\n\");\n\n\tfprintf(trace, \"<%sDecoderConfigurationRecord\", name);\n\n\tif (! p->config) {\n\t\tif (p->size) {\n\t\t\tfprintf(trace, \">\\n\");\n\t\t\tfprintf(trace, \"<!-- INVALID AVC ENTRY : no AVC/SVC config record -->\\n\");\n\t\t} else {\n\n\t\t\tfprintf(trace, \" configurationVersion=\\\"\\\" AVCProfileIndication=\\\"\\\" profile_compatibility=\\\"\\\" AVCLevelIndication=\\\"\\\" nal_unit_size=\\\"\\\" complete_representation=\\\"\\\"\");\n\n\t\t\tfprintf(trace, \" chroma_format=\\\"\\\" luma_bit_depth=\\\"\\\" chroma_bit_depth=\\\"\\\"\");\n\t\t\tfprintf(trace, \">\\n\");\n\n\t\t\tfprintf(trace, \"<SequenceParameterSet size=\\\"\\\" content=\\\"\\\"/>\\n\");\n\t\t\tfprintf(trace, \"<PictureParameterSet size=\\\"\\\" content=\\\"\\\"/>\\n\");\n\t\t\tfprintf(trace, \"<SequenceParameterSetExtensions size=\\\"\\\" content=\\\"\\\"/>\\n\");\n\t\t}\n\t\tfprintf(trace, \"</%sDecoderConfigurationRecord>\\n\", name);\n\t\tgf_isom_box_dump_done(boxname, a, trace);\n\t\treturn GF_OK;\n\t}\n\n\tfprintf(trace, \" configurationVersion=\\\"%d\\\" AVCProfileIndication=\\\"%d\\\" profile_compatibility=\\\"%d\\\" AVCLevelIndication=\\\"%d\\\" nal_unit_size=\\\"%d\\\"\", p->config->configurationVersion, p->config->AVCProfileIndication, p->config->profile_compatibility, p->config->AVCLevelIndication, p->config->nal_unit_size);\n\n\n\tif ((p->type==GF_ISOM_BOX_TYPE_SVCC) || (p->type==GF_ISOM_BOX_TYPE_MVCC) )\n\t\tfprintf(trace, \" complete_representation=\\\"%d\\\"\", p->config->complete_representation);\n\n\tif (p->type==GF_ISOM_BOX_TYPE_AVCC) {\n\t\tif (gf_avc_is_rext_profile(p->config->AVCProfileIndication)) {\n\t\t\tfprintf(trace, \" chroma_format=\\\"%s\\\" luma_bit_depth=\\\"%d\\\" chroma_bit_depth=\\\"%d\\\"\", gf_avc_hevc_get_chroma_format_name(p->config->chroma_format), p->config->luma_bit_depth, p->config->chroma_bit_depth);\n\t\t}\n\t}\n\n\tfprintf(trace, \">\\n\");\n\n\tcount = gf_list_count(p->config->sequenceParameterSets);\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *c = (GF_AVCConfigSlot *)gf_list_get(p->config->sequenceParameterSets, i);\n\t\tfprintf(trace, \"<SequenceParameterSet size=\\\"%d\\\" content=\\\"\", c->size);\n\t\tdump_data(trace, c->data, c->size);\n\t\tfprintf(trace, \"\\\"/>\\n\");\n\t}\n\tcount = gf_list_count(p->config->pictureParameterSets);\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *c = (GF_AVCConfigSlot *)gf_list_get(p->config->pictureParameterSets, i);\n\t\tfprintf(trace, \"<PictureParameterSet size=\\\"%d\\\" content=\\\"\", c->size);\n\t\tdump_data(trace, c->data, c->size);\n\t\tfprintf(trace, \"\\\"/>\\n\");\n\t}\n\n\tif (p->config->sequenceParameterSetExtensions) {\n\t\tcount = gf_list_count(p->config->sequenceParameterSetExtensions);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_AVCConfigSlot *c = (GF_AVCConfigSlot *)gf_list_get(p->config->sequenceParameterSetExtensions, i);\n\t\t\tfprintf(trace, \"<SequenceParameterSetExtensions size=\\\"%d\\\" content=\\\"\", c->size);\n\t\t\tdump_data(trace, c->data, c->size);\n\t\t\tfprintf(trace, \"\\\"/>\\n\");\n\t\t}\n\t}\n\n\tfprintf(trace, \"</%sDecoderConfigurationRecord>\\n\", name);\n\n\tgf_isom_box_dump_done(boxname, a, trace);\n\treturn GF_OK;\n}\n\nGF_Err hvcc_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i, count;\n\tconst char *name = (a->type==GF_ISOM_BOX_TYPE_HVCC) ? \"HEVC\" : \"L-HEVC\";\n\tchar boxname[256];\n\tGF_HEVCConfigurationBox *p = (GF_HEVCConfigurationBox *) a;\n\n\tsprintf(boxname, \"%sConfigurationBox\", name);\n\tgf_isom_box_dump_start(a, boxname, trace);\n\tfprintf(trace, \">\\n\");\n\n\tif (! p->config) {\n\t\tif (p->size) {\n\t\t\tfprintf(trace, \"<!-- INVALID HEVC ENTRY: no HEVC/SHVC config record -->\\n\");\n\t\t} else {\n\t\t\tfprintf(trace, \"<%sDecoderConfigurationRecord nal_unit_size=\\\"\\\" configurationVersion=\\\"\\\" \", name);\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_HVCC) {\n\t\t\t\tfprintf(trace, \"profile_space=\\\"\\\" tier_flag=\\\"\\\" profile_idc=\\\"\\\" general_profile_compatibility_flags=\\\"\\\" progressive_source_flag=\\\"\\\" interlaced_source_flag=\\\"\\\" non_packed_constraint_flag=\\\"\\\" frame_only_constraint_flag=\\\"\\\" constraint_indicator_flags=\\\"\\\" level_idc=\\\"\\\" \");\n\t\t\t}\n\t\t\tfprintf(trace, \"min_spatial_segmentation_idc=\\\"\\\" parallelismType=\\\"\\\" \");\n\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_HVCC)\n\t\t\t\tfprintf(trace, \"chroma_format=\\\"\\\" luma_bit_depth=\\\"\\\" chroma_bit_depth=\\\"\\\" avgFrameRate=\\\"\\\" constantFrameRate=\\\"\\\" numTemporalLayers=\\\"\\\" temporalIdNested=\\\"\\\"\");\n\n\t\t\tfprintf(trace, \">\\n\");\n\t\t\tfprintf(trace, \"<ParameterSetArray nalu_type=\\\"\\\" complete_set=\\\"\\\">\\n\");\n\t\t\tfprintf(trace, \"<ParameterSet size=\\\"\\\" content=\\\"\\\"/>\\n\");\n\t\t\tfprintf(trace, \"</ParameterSetArray>\\n\");\n\t\t\tfprintf(trace, \"</%sDecoderConfigurationRecord>\\n\", name);\n\t\t}\n\t\tfprintf(trace, \"</%sConfigurationBox>\\n\", name);\n\t\treturn GF_OK;\n\t}\n\n\tfprintf(trace, \"<%sDecoderConfigurationRecord nal_unit_size=\\\"%d\\\" \", name, p->config->nal_unit_size);\n\tfprintf(trace, \"configurationVersion=\\\"%u\\\" \", p->config->configurationVersion);\n\tif (a->type==GF_ISOM_BOX_TYPE_HVCC) {\n\t\tfprintf(trace, \"profile_space=\\\"%u\\\" \", p->config->profile_space);\n\t\tfprintf(trace, \"tier_flag=\\\"%u\\\" \", p->config->tier_flag);\n\t\tfprintf(trace, \"profile_idc=\\\"%u\\\" \", p->config->profile_idc);\n\t\tfprintf(trace, \"general_profile_compatibility_flags=\\\"%X\\\" \", p->config->general_profile_compatibility_flags);\n\t\tfprintf(trace, \"progressive_source_flag=\\\"%u\\\" \", p->config->progressive_source_flag);\n\t\tfprintf(trace, \"interlaced_source_flag=\\\"%u\\\" \", p->config->interlaced_source_flag);\n\t\tfprintf(trace, \"non_packed_constraint_flag=\\\"%u\\\" \", p->config->non_packed_constraint_flag);\n\t\tfprintf(trace, \"frame_only_constraint_flag=\\\"%u\\\" \", p->config->frame_only_constraint_flag);\n\t\tfprintf(trace, \"constraint_indicator_flags=\\\"\"LLX\"\\\" \", p->config->constraint_indicator_flags);\n\t\tfprintf(trace, \"level_idc=\\\"%d\\\" \", p->config->level_idc);\n\t}\n\tfprintf(trace, \"min_spatial_segmentation_idc=\\\"%u\\\" \", p->config->min_spatial_segmentation_idc);\n\tfprintf(trace, \"parallelismType=\\\"%u\\\" \", p->config->parallelismType);\n\n\tif (a->type==GF_ISOM_BOX_TYPE_HVCC)\n\t\tfprintf(trace, \"chroma_format=\\\"%s\\\" luma_bit_depth=\\\"%u\\\" chroma_bit_depth=\\\"%u\\\" avgFrameRate=\\\"%u\\\" constantFrameRate=\\\"%u\\\" numTemporalLayers=\\\"%u\\\" temporalIdNested=\\\"%u\\\"\",\n\t        gf_avc_hevc_get_chroma_format_name(p->config->chromaFormat), p->config->luma_bit_depth, p->config->chroma_bit_depth, p->config->avgFrameRate, p->config->constantFrameRate, p->config->numTemporalLayers, p->config->temporalIdNested);\n\n\tfprintf(trace, \">\\n\");\n\n\tcount = gf_list_count(p->config->param_array);\n\tfor (i=0; i<count; i++) {\n\t\tu32 nalucount, j;\n\t\tGF_HEVCParamArray *ar = (GF_HEVCParamArray*)gf_list_get(p->config->param_array, i);\n\t\tfprintf(trace, \"<ParameterSetArray nalu_type=\\\"%d\\\" complete_set=\\\"%d\\\">\\n\", ar->type, ar->array_completeness);\n\t\tnalucount = gf_list_count(ar->nalus);\n\t\tfor (j=0; j<nalucount; j++) {\n\t\t\tGF_AVCConfigSlot *c = (GF_AVCConfigSlot *)gf_list_get(ar->nalus, j);\n\t\t\tfprintf(trace, \"<ParameterSet size=\\\"%d\\\" content=\\\"\", c->size);\n\t\t\tdump_data(trace, c->data, c->size);\n\t\t\tfprintf(trace, \"\\\"/>\\n\");\n\t\t}\n\t\tfprintf(trace, \"</ParameterSetArray>\\n\");\n\t}\n\n\tfprintf(trace, \"</%sDecoderConfigurationRecord>\\n\", name);\n\n\tgf_isom_box_dump_done(boxname, a, trace);\n\treturn GF_OK;\n}\n\nGF_Err m4ds_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_Descriptor *desc;\n\tGF_MPEG4ExtensionDescriptorsBox *p = (GF_MPEG4ExtensionDescriptorsBox *) a;\n\tgf_isom_box_dump_start(a, \"MPEG4ExtensionDescriptorsBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\ti=0;\n\twhile ((desc = (GF_Descriptor *)gf_list_enum(p->descriptors, &i))) {\n#ifndef GPAC_DISABLE_OD_DUMP\n\t\tgf_odf_dump_desc(desc, trace, 1, GF_TRUE);\n#else\n\t\tfprintf(trace, \"<!-- Object Descriptor Dumping disabled in this build of GPAC -->\\n\");\n#endif\n\t}\n\tgf_isom_box_dump_done(\"MPEG4ExtensionDescriptorsBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err btrt_dump(GF_Box *a, FILE * trace)\n{\n\tGF_BitRateBox *p = (GF_BitRateBox*)a;\n\tgf_isom_box_dump_start(a, \"BitRateBox\", trace);\n\tfprintf(trace, \"BufferSizeDB=\\\"%d\\\" avgBitRate=\\\"%d\\\" maxBitRate=\\\"%d\\\">\\n\", p->bufferSizeDB, p->avgBitrate, p->maxBitrate);\n\tgf_isom_box_dump_done(\"BitRateBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ftab_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_FontTableBox *p = (GF_FontTableBox *)a;\n\tgf_isom_box_dump_start(a, \"FontTableBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tfor (i=0; i<p->entry_count; i++) {\n\t\tfprintf(trace, \"<FontRecord ID=\\\"%d\\\" name=\\\"%s\\\"/>\\n\", p->fonts[i].fontID, p->fonts[i].fontName ? p->fonts[i].fontName : \"NULL\");\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<FontRecord ID=\\\"\\\" name=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"FontTableBox\", a, trace);\n\treturn GF_OK;\n}\n\nstatic void tx3g_dump_rgba8(FILE * trace, char *name, u32 col)\n{\n\tfprintf(trace, \"%s=\\\"%x %x %x %x\\\"\", name, (col>>16)&0xFF, (col>>8)&0xFF, (col)&0xFF, (col>>24)&0xFF);\n}\nstatic void tx3g_dump_rgb16(FILE * trace, char *name, char col[6])\n{\n\tfprintf(trace, \"%s=\\\"%x %x %x\\\"\", name, *((u16*)col), *((u16*)(col+1)), *((u16*)(col+2)));\n}\nstatic void tx3g_dump_box(FILE * trace, GF_BoxRecord *rec)\n{\n\tfprintf(trace, \"<BoxRecord top=\\\"%d\\\" left=\\\"%d\\\" bottom=\\\"%d\\\" right=\\\"%d\\\"/>\\n\", rec->top, rec->left, rec->bottom, rec->right);\n}\nstatic void tx3g_dump_style(FILE * trace, GF_StyleRecord *rec)\n{\n\tfprintf(trace, \"<StyleRecord startChar=\\\"%d\\\" endChar=\\\"%d\\\" fontID=\\\"%d\\\" styles=\\\"\", rec->startCharOffset, rec->endCharOffset, rec->fontID);\n\tif (!rec->style_flags) {\n\t\tfprintf(trace, \"Normal\");\n\t} else {\n\t\tif (rec->style_flags & 1) fprintf(trace, \"Bold \");\n\t\tif (rec->style_flags & 2) fprintf(trace, \"Italic \");\n\t\tif (rec->style_flags & 4) fprintf(trace, \"Underlined \");\n\t}\n\tfprintf(trace, \"\\\" fontSize=\\\"%d\\\" \", rec->font_size);\n\ttx3g_dump_rgba8(trace, \"textColor\", rec->text_color);\n\tfprintf(trace, \"/>\\n\");\n}\n\nGF_Err tx3g_dump(GF_Box *a, FILE * trace)\n{\n\tGF_Tx3gSampleEntryBox *p = (GF_Tx3gSampleEntryBox *)a;\n\tgf_isom_box_dump_start(a, \"Tx3gSampleEntryBox\", trace);\n\tfprintf(trace, \"dataReferenceIndex=\\\"%d\\\" displayFlags=\\\"%x\\\" horizontal-justification=\\\"%d\\\" vertical-justification=\\\"%d\\\" \",\n\t        p->dataReferenceIndex, p->displayFlags, p->horizontal_justification, p->vertical_justification);\n\n\ttx3g_dump_rgba8(trace, \"backgroundColor\", p->back_color);\n\tfprintf(trace, \">\\n\");\n\tfprintf(trace, \"<DefaultBox>\\n\");\n\ttx3g_dump_box(trace, &p->default_box);\n\tgf_isom_box_dump_done(\"DefaultBox\", a, trace);\n\tfprintf(trace, \"<DefaultStyle>\\n\");\n\ttx3g_dump_style(trace, &p->default_style);\n\tfprintf(trace, \"</DefaultStyle>\\n\");\n\tif (p->size) {\n\t\tgf_isom_box_dump_ex(p->font_table, trace, GF_ISOM_BOX_TYPE_FTAB);\n\t}\n\tgf_isom_box_dump_done(\"Tx3gSampleEntryBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err text_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TextSampleEntryBox *p = (GF_TextSampleEntryBox *)a;\n\tgf_isom_box_dump_start(a, \"TextSampleEntryBox\", trace);\n\tfprintf(trace, \"dataReferenceIndex=\\\"%d\\\" displayFlags=\\\"%x\\\" textJustification=\\\"%d\\\"  \",\n\t        p->dataReferenceIndex, p->displayFlags, p->textJustification);\n\tif (p->textName)\n\t\tfprintf(trace, \"textName=\\\"%s\\\" \", p->textName);\n\ttx3g_dump_rgb16(trace, \"background-color\", p->background_color);\n\ttx3g_dump_rgb16(trace, \" foreground-color\", p->foreground_color);\n\tfprintf(trace, \">\\n\");\n\n\tfprintf(trace, \"<DefaultBox>\\n\");\n\ttx3g_dump_box(trace, &p->default_box);\n\tgf_isom_box_dump_done(\"DefaultBox\", a, trace);\n\tgf_isom_box_dump_done(\"TextSampleEntryBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err styl_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_TextStyleBox*p = (GF_TextStyleBox*)a;\n\tgf_isom_box_dump_start(a, \"TextStyleBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tfor (i=0; i<p->entry_count; i++) tx3g_dump_style(trace, &p->styles[i]);\n\tif (!p->size) {\n\t\tfprintf(trace, \"<StyleRecord startChar=\\\"\\\" endChar=\\\"\\\" fontID=\\\"\\\" styles=\\\"Normal|Bold|Italic|Underlined\\\" fontSize=\\\"\\\" textColor=\\\"\\\" />\\n\");\n\t}\n\tgf_isom_box_dump_done(\"TextStyleBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err hlit_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TextHighlightBox*p = (GF_TextHighlightBox*)a;\n\tgf_isom_box_dump_start(a, \"TextHighlightBox\", trace);\n\tfprintf(trace, \"startcharoffset=\\\"%d\\\" endcharoffset=\\\"%d\\\">\\n\", p->startcharoffset, p->endcharoffset);\n\tgf_isom_box_dump_done(\"TextHighlightBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err hclr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TextHighlightColorBox*p = (GF_TextHighlightColorBox*)a;\n\tgf_isom_box_dump_start(a, \"TextHighlightColorBox\", trace);\n\ttx3g_dump_rgba8(trace, \"highlight_color\", p->hil_color);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"TextHighlightColorBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err krok_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_TextKaraokeBox*p = (GF_TextKaraokeBox*)a;\n\tgf_isom_box_dump_start(a, \"TextKaraokeBox\", trace);\n\tfprintf(trace, \"highlight_starttime=\\\"%d\\\">\\n\", p->highlight_starttime);\n\tfor (i=0; i<p->nb_entries; i++) {\n\t\tfprintf(trace, \"<KaraokeRecord highlight_endtime=\\\"%d\\\" start_charoffset=\\\"%d\\\" end_charoffset=\\\"%d\\\"/>\\n\", p->records[i].highlight_endtime, p->records[i].start_charoffset, p->records[i].end_charoffset);\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<KaraokeRecord highlight_endtime=\\\"\\\" start_charoffset=\\\"\\\" end_charoffset=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"TextKaraokeBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err dlay_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TextScrollDelayBox*p = (GF_TextScrollDelayBox*)a;\n\tgf_isom_box_dump_start(a, \"TextScrollDelayBox\", trace);\n\tfprintf(trace, \"scroll_delay=\\\"%d\\\">\\n\", p->scroll_delay);\n\tgf_isom_box_dump_done(\"TextScrollDelayBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err href_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TextHyperTextBox*p = (GF_TextHyperTextBox*)a;\n\tgf_isom_box_dump_start(a, \"TextHyperTextBox\", trace);\n\tfprintf(trace, \"startcharoffset=\\\"%d\\\" endcharoffset=\\\"%d\\\" URL=\\\"%s\\\" altString=\\\"%s\\\">\\n\", p->startcharoffset, p->endcharoffset, p->URL ? p->URL : \"NULL\", p->URL_hint ? p->URL_hint : \"NULL\");\n\tgf_isom_box_dump_done(\"TextHyperTextBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err tbox_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TextBoxBox*p = (GF_TextBoxBox*)a;\n\tgf_isom_box_dump_start(a, \"TextBoxBox\", trace);\n\tfprintf(trace, \">\\n\");\n\ttx3g_dump_box(trace, &p->box);\n\tgf_isom_box_dump_done(\"TextBoxBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err blnk_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TextBlinkBox*p = (GF_TextBlinkBox*)a;\n\tgf_isom_box_dump_start(a, \"TextBlinkBox\", trace);\n\tfprintf(trace, \"start_charoffset=\\\"%d\\\" end_charoffset=\\\"%d\\\">\\n\", p->startcharoffset, p->endcharoffset);\n\tgf_isom_box_dump_done(\"TextBlinkBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err twrp_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TextWrapBox*p = (GF_TextWrapBox*)a;\n\tgf_isom_box_dump_start(a, \"TextWrapBox\", trace);\n\tfprintf(trace, \"wrap_flag=\\\"%s\\\">\\n\", p->wrap_flag ? ( (p->wrap_flag>1) ? \"Reserved\" : \"Automatic\" ) : \"No Wrap\");\n\tgf_isom_box_dump_done(\"TextWrapBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err meta_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MetaBox *p;\n\tp = (GF_MetaBox *)a;\n\tgf_isom_box_dump_start(a, \"MetaBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\tif (p->handler) gf_isom_box_dump(p->handler, trace);\n\tif (p->primary_resource) gf_isom_box_dump(p->primary_resource, trace);\n\tif (p->file_locations) gf_isom_box_dump(p->file_locations, trace);\n\tif (p->item_locations) gf_isom_box_dump(p->item_locations, trace);\n\tif (p->protections) gf_isom_box_dump(p->protections, trace);\n\tif (p->item_infos) gf_isom_box_dump(p->item_infos, trace);\n\tif (p->IPMP_control) gf_isom_box_dump(p->IPMP_control, trace);\n\tif (p->item_refs) gf_isom_box_dump(p->item_refs, trace);\n\tif (p->item_props) gf_isom_box_dump(p->item_props, trace);\n\tgf_isom_box_dump_done(\"MetaBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err xml_dump(GF_Box *a, FILE * trace)\n{\n\tGF_XMLBox *p = (GF_XMLBox *)a;\n\tgf_isom_box_dump_start(a, \"XMLBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tfprintf(trace, \"<![CDATA[\\n\");\n\tif (p->xml)\n\t\tgf_fwrite(p->xml, strlen(p->xml), 1, trace);\n\tfprintf(trace, \"]]>\\n\");\n\tgf_isom_box_dump_done(\"XMLBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err bxml_dump(GF_Box *a, FILE * trace)\n{\n\tGF_BinaryXMLBox *p = (GF_BinaryXMLBox *)a;\n\tgf_isom_box_dump_start(a, \"BinaryXMLBox\", trace);\n\tfprintf(trace, \"binarySize=\\\"%d\\\">\\n\", p->data_length);\n\tgf_isom_box_dump_done(\"BinaryXMLBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err pitm_dump(GF_Box *a, FILE * trace)\n{\n\tGF_PrimaryItemBox *p = (GF_PrimaryItemBox *)a;\n\tgf_isom_box_dump_start(a, \"PrimaryItemBox\", trace);\n\tfprintf(trace, \"item_ID=\\\"%d\\\">\\n\", p->item_ID);\n\tgf_isom_box_dump_done(\"PrimaryItemBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ipro_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ItemProtectionBox *p = (GF_ItemProtectionBox *)a;\n\tgf_isom_box_dump_start(a, \"ItemProtectionBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_array_dump(p->protection_information, trace);\n\tgf_isom_box_dump_done(\"ItemProtectionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err infe_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ItemInfoEntryBox *p = (GF_ItemInfoEntryBox *)a;\n\tgf_isom_box_dump_start(a, \"ItemInfoEntryBox\", trace);\n\tfprintf(trace, \"item_ID=\\\"%d\\\" item_protection_index=\\\"%d\\\" item_name=\\\"%s\\\" content_type=\\\"%s\\\" content_encoding=\\\"%s\\\" item_type=\\\"%s\\\">\\n\", p->item_ID, p->item_protection_index, p->item_name, p->content_type, p->content_encoding, gf_4cc_to_str(p->item_type));\n\tgf_isom_box_dump_done(\"ItemInfoEntryBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err iinf_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ItemInfoBox *p = (GF_ItemInfoBox *)a;\n\tgf_isom_box_dump_start(a, \"ItemInfoBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_array_dump(p->item_infos, trace);\n\tgf_isom_box_dump_done(\"ItemInfoBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err iloc_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i, j, count, count2;\n\tGF_ItemLocationBox *p = (GF_ItemLocationBox*)a;\n\tgf_isom_box_dump_start(a, \"ItemLocationBox\", trace);\n\tfprintf(trace, \"offset_size=\\\"%d\\\" length_size=\\\"%d\\\" base_offset_size=\\\"%d\\\" index_size=\\\"%d\\\">\\n\", p->offset_size, p->length_size, p->base_offset_size, p->index_size);\n\tcount = gf_list_count(p->location_entries);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ItemLocationEntry *ie = (GF_ItemLocationEntry *)gf_list_get(p->location_entries, i);\n\t\tcount2 = gf_list_count(ie->extent_entries);\n\t\tfprintf(trace, \"<ItemLocationEntry item_ID=\\\"%d\\\" data_reference_index=\\\"%d\\\" base_offset=\\\"\"LLD\"\\\" construction_method=\\\"%d\\\">\\n\", ie->item_ID, ie->data_reference_index, LLD_CAST ie->base_offset, ie->construction_method);\n\t\tfor (j=0; j<count2; j++) {\n\t\t\tGF_ItemExtentEntry *iee = (GF_ItemExtentEntry *)gf_list_get(ie->extent_entries, j);\n\t\t\tfprintf(trace, \"<ItemExtentEntry extent_offset=\\\"\"LLD\"\\\" extent_length=\\\"\"LLD\"\\\" extent_index=\\\"\"LLD\"\\\" />\\n\", LLD_CAST iee->extent_offset, LLD_CAST iee->extent_length, LLD_CAST iee->extent_index);\n\t\t}\n\t\tfprintf(trace, \"</ItemLocationEntry>\\n\");\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<ItemLocationEntry item_ID=\\\"\\\" data_reference_index=\\\"\\\" base_offset=\\\"\\\" construction_method=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<ItemExtentEntry extent_offset=\\\"\\\" extent_length=\\\"\\\" extent_index=\\\"\\\" />\\n\");\n\t\tfprintf(trace, \"</ItemLocationEntry>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"ItemLocationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err iref_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ItemReferenceBox *p = (GF_ItemReferenceBox *)a;\n\tgf_isom_box_dump_start(a, \"ItemReferenceBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_array_dump(p->references, trace);\n\tgf_isom_box_dump_done(\"ItemReferenceBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err hinf_dump(GF_Box *a, FILE * trace)\n{\n//\tGF_HintInfoBox *p  = (GF_HintInfoBox *)a;\n\tgf_isom_box_dump_start(a, \"HintInfoBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HintInfoBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err trpy_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TRPYBox *p = (GF_TRPYBox *)a;\n\tgf_isom_box_dump_start(a, \"LargeTotalRTPBytesBox\", trace);\n\tfprintf(trace, \"RTPBytesSent=\\\"\"LLD\"\\\">\\n\", LLD_CAST p->nbBytes);\n\tgf_isom_box_dump_done(\"LargeTotalRTPBytesBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err totl_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TOTLBox *p;\n\n\tp = (GF_TOTLBox *)a;\n\tgf_isom_box_dump_start(a, \"TotalRTPBytesBox\", trace);\n\tfprintf(trace, \"RTPBytesSent=\\\"%d\\\">\\n\", p->nbBytes);\n\tgf_isom_box_dump_done(\"TotalRTPBytesBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err nump_dump(GF_Box *a, FILE * trace)\n{\n\tGF_NUMPBox *p;\n\n\tp = (GF_NUMPBox *)a;\n\tgf_isom_box_dump_start(a, \"LargeTotalPacketBox\", trace);\n\tfprintf(trace, \"PacketsSent=\\\"\"LLD\"\\\">\\n\", LLD_CAST p->nbPackets);\n\tgf_isom_box_dump_done(\"LargeTotalPacketBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err npck_dump(GF_Box *a, FILE * trace)\n{\n\tGF_NPCKBox *p;\n\tp = (GF_NPCKBox *)a;\n\tgf_isom_box_dump_start(a, \"TotalPacketBox\", trace);\n\tfprintf(trace, \"packetsSent=\\\"%d\\\">\\n\", p->nbPackets);\n\tgf_isom_box_dump_done(\"TotalPacketBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tpyl_dump(GF_Box *a, FILE * trace)\n{\n\tGF_NTYLBox *p;\n\tp = (GF_NTYLBox *)a;\n\tgf_isom_box_dump_start(a, \"LargeTotalMediaBytesBox\", trace);\n\tfprintf(trace, \"BytesSent=\\\"\"LLD\"\\\">\\n\", LLD_CAST p->nbBytes);\n\tgf_isom_box_dump_done(\"LargeTotalMediaBytesBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tpay_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TPAYBox *p;\n\tp = (GF_TPAYBox *)a;\n\tgf_isom_box_dump_start(a, \"TotalMediaBytesBox\", trace);\n\tfprintf(trace, \"BytesSent=\\\"%d\\\">\\n\", p->nbBytes);\n\tgf_isom_box_dump_done(\"TotalMediaBytesBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err maxr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MAXRBox *p;\n\tp = (GF_MAXRBox *)a;\n\tgf_isom_box_dump_start(a, \"MaxDataRateBox\", trace);\n\tfprintf(trace, \"MaxDataRate=\\\"%d\\\" Granularity=\\\"%d\\\">\\n\", p->maxDataRate, p->granularity);\n\tgf_isom_box_dump_done(\"MaxDataRateBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err dmed_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DMEDBox *p;\n\n\tp = (GF_DMEDBox *)a;\n\tgf_isom_box_dump_start(a, \"BytesFromMediaTrackBox\", trace);\n\tfprintf(trace, \"BytesSent=\\\"\"LLD\"\\\">\\n\", LLD_CAST p->nbBytes);\n\tgf_isom_box_dump_done(\"BytesFromMediaTrackBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err dimm_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DIMMBox *p;\n\tp = (GF_DIMMBox *)a;\n\tgf_isom_box_dump_start(a, \"ImmediateDataBytesBox\", trace);\n\tfprintf(trace, \"BytesSent=\\\"\"LLD\"\\\">\\n\", LLD_CAST p->nbBytes);\n\tgf_isom_box_dump_done(\"ImmediateDataBytesBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err drep_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DREPBox *p;\n\tp = (GF_DREPBox *)a;\n\tgf_isom_box_dump_start(a, \"RepeatedDataBytesBox\", trace);\n\tfprintf(trace, \"RepeatedBytes=\\\"\"LLD\"\\\">\\n\", LLD_CAST p->nbBytes);\n\tgf_isom_box_dump_done(\"RepeatedDataBytesBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tssy_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TimeStampSynchronyBox *p = (GF_TimeStampSynchronyBox *)a;\n\tgf_isom_box_dump_start(a, \"TimeStampSynchronyBox\", trace);\n\tfprintf(trace, \"timestamp_sync=\\\"%d\\\">\\n\", p->timestamp_sync);\n\tgf_isom_box_dump_done(\"TimeStampSynchronyBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err rssr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ReceivedSsrcBox *p = (GF_ReceivedSsrcBox *)a;\n\tgf_isom_box_dump_start(a, \"ReceivedSsrcBox\", trace);\n\tfprintf(trace, \"SSRC=\\\"%d\\\">\\n\", p->ssrc);\n\tgf_isom_box_dump_done(\"ReceivedSsrcBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tmin_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TMINBox *p;\n\tp = (GF_TMINBox *)a;\n\tgf_isom_box_dump_start(a, \"MinTransmissionTimeBox\", trace);\n\tfprintf(trace, \"MinimumTransmitTime=\\\"%d\\\">\\n\", p->minTime);\n\tgf_isom_box_dump_done(\"MinTransmissionTimeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tmax_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TMAXBox *p;\n\tp = (GF_TMAXBox *)a;\n\tgf_isom_box_dump_start(a, \"MaxTransmissionTimeBox\", trace);\n\tfprintf(trace, \"MaximumTransmitTime=\\\"%d\\\">\\n\", p->maxTime);\n\tgf_isom_box_dump_done(\"MaxTransmissionTimeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err pmax_dump(GF_Box *a, FILE * trace)\n{\n\tGF_PMAXBox *p;\n\tp = (GF_PMAXBox *)a;\n\tgf_isom_box_dump_start(a, \"MaxPacketSizeBox\", trace);\n\tfprintf(trace, \"MaximumSize=\\\"%d\\\">\\n\", p->maxSize);\n\tgf_isom_box_dump_done(\"MaxPacketSizeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err dmax_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DMAXBox *p;\n\tp = (GF_DMAXBox *)a;\n\tgf_isom_box_dump_start(a, \"MaxPacketDurationBox\", trace);\n\tfprintf(trace, \"MaximumDuration=\\\"%d\\\">\\n\", p->maxDur);\n\tgf_isom_box_dump_done(\"MaxPacketDurationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err payt_dump(GF_Box *a, FILE * trace)\n{\n\tGF_PAYTBox *p;\n\tp = (GF_PAYTBox *)a;\n\tgf_isom_box_dump_start(a, \"PayloadTypeBox\", trace);\n\tfprintf(trace, \"PayloadID=\\\"%d\\\" PayloadString=\\\"%s\\\">\\n\", p->payloadCode, p->payloadString);\n\tgf_isom_box_dump_done(\"PayloadTypeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err name_dump(GF_Box *a, FILE * trace)\n{\n\tGF_NameBox *p;\n\tp = (GF_NameBox *)a;\n\tgf_isom_box_dump_start(a, \"NameBox\", trace);\n\tfprintf(trace, \"Name=\\\"%s\\\">\\n\", p->string);\n\tgf_isom_box_dump_done(\"NameBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err rely_dump(GF_Box *a, FILE * trace)\n{\n\tGF_RelyHintBox *p;\n\tp = (GF_RelyHintBox *)a;\n\tgf_isom_box_dump_start(a, \"RelyTransmissionBox\", trace);\n\tfprintf(trace, \"Prefered=\\\"%d\\\" required=\\\"%d\\\">\\n\", p->prefered, p->required);\n\tgf_isom_box_dump_done(\"RelyTransmissionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err snro_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SeqOffHintEntryBox *p;\n\tp = (GF_SeqOffHintEntryBox *)a;\n\tgf_isom_box_dump_start(a, \"PacketSequenceOffsetBox\", trace);\n\tfprintf(trace, \"SeqNumOffset=\\\"%d\\\">\\n\", p->SeqOffset);\n\tgf_isom_box_dump_done(\"PacketSequenceOffsetBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tims_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TSHintEntryBox *p;\n\tp = (GF_TSHintEntryBox *)a;\n\tgf_isom_box_dump_start(a, \"RTPTimeScaleBox\", trace);\n\tfprintf(trace, \"TimeScale=\\\"%d\\\">\\n\", p->timeScale);\n\tgf_isom_box_dump_done(\"RTPTimeScaleBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tsro_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TimeOffHintEntryBox *p;\n\tp = (GF_TimeOffHintEntryBox *)a;\n\tgf_isom_box_dump_start(a, \"TimeStampOffsetBox\", trace);\n\tfprintf(trace, \"TimeStampOffset=\\\"%d\\\">\\n\", p->TimeOffset);\n\tgf_isom_box_dump_done(\"TimeStampOffsetBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err ghnt_dump(GF_Box *a, FILE * trace)\n{\n\tchar *name;\n\tGF_HintSampleEntryBox *p;\n\tp = (GF_HintSampleEntryBox *)a;\n\n\tif (a->type == GF_ISOM_BOX_TYPE_RTP_STSD) {\n\t\tname = \"RTPHintSampleEntryBox\";\n\t} else if (a->type == GF_ISOM_BOX_TYPE_SRTP_STSD) {\n\t\tname = \"SRTPHintSampleEntryBox\";\n\t} else if (a->type == GF_ISOM_BOX_TYPE_FDP_STSD) {\n\t\tname = \"FDPHintSampleEntryBox\";\n\t} else if (a->type == GF_ISOM_BOX_TYPE_RRTP_STSD) {\n\t\tname = \"RTPReceptionHintSampleEntryBox\";\n\t} else if (a->type == GF_ISOM_BOX_TYPE_RTCP_STSD) {\n\t\tname = \"RTCPReceptionHintSampleEntryBox\";\n\t} else {\n\t\tname = \"GenericHintSampleEntryBox\";\n\t}\n\tgf_isom_box_dump_start(a, name, trace);\n\tfprintf(trace, \"DataReferenceIndex=\\\"%d\\\" HintTrackVersion=\\\"%d\\\" LastCompatibleVersion=\\\"%d\\\"\", p->dataReferenceIndex, p->HintTrackVersion, p->LastCompatibleVersion);\n\tif ((a->type == GF_ISOM_BOX_TYPE_RTP_STSD) || (a->type == GF_ISOM_BOX_TYPE_SRTP_STSD) || (a->type == GF_ISOM_BOX_TYPE_RRTP_STSD) || (a->type == GF_ISOM_BOX_TYPE_RTCP_STSD)) {\n\t\tfprintf(trace, \" MaxPacketSize=\\\"%d\\\"\", p->MaxPacketSize);\n\t} else if (a->type == GF_ISOM_BOX_TYPE_FDP_STSD) {\n\t\tfprintf(trace, \" partition_entry_ID=\\\"%d\\\" FEC_overhead=\\\"%d\\\"\", p->partition_entry_ID, p->FEC_overhead);\n\t}\n\tfprintf(trace, \">\\n\");\n\n\tgf_isom_box_dump_done(name, a, trace);\n\treturn GF_OK;\n}\n\nGF_Err hnti_dump(GF_Box *a, FILE * trace)\n{\n\tgf_isom_box_dump_start(a, \"HintTrackInfoBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HintTrackInfoBox\", NULL, trace);\n\treturn GF_OK;\n}\n\nGF_Err sdp_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SDPBox *p = (GF_SDPBox *)a;\n\tgf_isom_box_dump_start(a, \"SDPBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->sdpText)\n\t\tfprintf(trace, \"<!-- sdp text: %s -->\\n\", p->sdpText);\n\tgf_isom_box_dump_done(\"SDPBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err rtp_hnti_dump(GF_Box *a, FILE * trace)\n{\n\tGF_RTPBox *p = (GF_RTPBox *)a;\n\tgf_isom_box_dump_start(a, \"RTPMovieHintInformationBox\", trace);\n\tfprintf(trace, \"descriptionformat=\\\"%s\\\">\\n\", gf_4cc_to_str(p->subType));\n\tif (p->sdpText)\n\t\tfprintf(trace, \"<!-- sdp text: %s -->\\n\", p->sdpText);\n\tgf_isom_box_dump_done(\"RTPMovieHintInformationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err rtpo_dump(GF_Box *a, FILE * trace)\n{\n\tGF_RTPOBox *p;\n\tp = (GF_RTPOBox *)a;\n\tgf_isom_box_dump_start(a, \"RTPTimeOffsetBox\", trace);\n\tfprintf(trace, \"PacketTimeOffset=\\\"%d\\\">\\n\", p->timeOffset);\n\tgf_isom_box_dump_done(\"RTPTimeOffsetBox\", a, trace);\n\treturn GF_OK;\n}\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nGF_Err mvex_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MovieExtendsBox *p;\n\tp = (GF_MovieExtendsBox *)a;\n\tgf_isom_box_dump_start(a, \"MovieExtendsBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->mehd) gf_isom_box_dump(p->mehd, trace);\n\tgf_isom_box_array_dump(p->TrackExList, trace);\n\tgf_isom_box_array_dump(p->TrackExPropList, trace);\n\tgf_isom_box_dump_done(\"MovieExtendsBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err mehd_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MovieExtendsHeaderBox *p = (GF_MovieExtendsHeaderBox*)a;\n\tgf_isom_box_dump_start(a, \"MovieExtendsHeaderBox\", trace);\n\tfprintf(trace, \"fragmentDuration=\\\"\"LLD\"\\\" >\\n\", LLD_CAST p->fragment_duration);\n\tgf_isom_box_dump_done(\"MovieExtendsHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nvoid sample_flags_dump(const char *name, u32 sample_flags, FILE * trace)\n{\n\tfprintf(trace, \"<%s\", name);\n\tfprintf(trace, \" IsLeading=\\\"%d\\\"\", GF_ISOM_GET_FRAG_LEAD(sample_flags) );\n\tfprintf(trace, \" SampleDependsOn=\\\"%d\\\"\", GF_ISOM_GET_FRAG_DEPENDS(sample_flags) );\n\tfprintf(trace, \" SampleIsDependedOn=\\\"%d\\\"\", GF_ISOM_GET_FRAG_DEPENDED(sample_flags) );\n\tfprintf(trace, \" SampleHasRedundancy=\\\"%d\\\"\", GF_ISOM_GET_FRAG_REDUNDANT(sample_flags) );\n\tfprintf(trace, \" SamplePadding=\\\"%d\\\"\", GF_ISOM_GET_FRAG_PAD(sample_flags) );\n\tfprintf(trace, \" SampleSync=\\\"%d\\\"\", GF_ISOM_GET_FRAG_SYNC(sample_flags));\n\tfprintf(trace, \" SampleDegradationPriority=\\\"%d\\\"\", GF_ISOM_GET_FRAG_DEG(sample_flags));\n\tfprintf(trace, \"/>\\n\");\n}\n\nGF_Err trex_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackExtendsBox *p;\n\tp = (GF_TrackExtendsBox *)a;\n\tgf_isom_box_dump_start(a, \"TrackExtendsBox\", trace);\n\tfprintf(trace, \"TrackID=\\\"%d\\\"\", p->trackID);\n\tfprintf(trace, \" SampleDescriptionIndex=\\\"%d\\\" SampleDuration=\\\"%d\\\" SampleSize=\\\"%d\\\"\", p->def_sample_desc_index, p->def_sample_duration, p->def_sample_size);\n\tfprintf(trace, \">\\n\");\n\tsample_flags_dump(\"DefaultSampleFlags\", p->def_sample_flags, trace);\n\tgf_isom_box_dump_done(\"TrackExtendsBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err trep_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackExtensionPropertiesBox *p = (GF_TrackExtensionPropertiesBox*)a;\n\tgf_isom_box_dump_start(a, \"TrackExtensionPropertiesBox\", trace);\n\tfprintf(trace, \"TrackID=\\\"%d\\\">\\n\", p->trackID);\n\tgf_isom_box_dump_done(\"TrackExtensionPropertiesBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err moof_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MovieFragmentBox *p;\n\tp = (GF_MovieFragmentBox *)a;\n\tgf_isom_box_dump_start(a, \"MovieFragmentBox\", trace);\n\tfprintf(trace, \"TrackFragments=\\\"%d\\\">\\n\", gf_list_count(p->TrackList));\n\tif (p->mfhd) gf_isom_box_dump(p->mfhd, trace);\n\tgf_isom_box_array_dump(p->TrackList, trace);\n\tgf_isom_box_dump_done(\"MovieFragmentBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err mfhd_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MovieFragmentHeaderBox *p;\n\tp = (GF_MovieFragmentHeaderBox *)a;\n\tgf_isom_box_dump_start(a, \"MovieFragmentHeaderBox\", trace);\n\tfprintf(trace, \"FragmentSequenceNumber=\\\"%d\\\">\\n\", p->sequence_number);\n\tgf_isom_box_dump_done(\"MovieFragmentHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err traf_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackFragmentBox *p;\n\tp = (GF_TrackFragmentBox *)a;\n\tgf_isom_box_dump_start(a, \"TrackFragmentBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->tfhd) gf_isom_box_dump(p->tfhd, trace);\n\tif (p->sdtp) gf_isom_box_dump(p->sdtp, trace);\n\tif (p->tfdt) gf_isom_box_dump(p->tfdt, trace);\n\tif (p->sub_samples) gf_isom_box_array_dump(p->sub_samples, trace);\n\tif (p->sampleGroupsDescription) gf_isom_box_array_dump(p->sampleGroupsDescription, trace);\n\tif (p->sampleGroups) gf_isom_box_array_dump(p->sampleGroups, trace);\n\tgf_isom_box_array_dump(p->TrackRuns, trace);\n\tif (p->sai_sizes) gf_isom_box_array_dump(p->sai_sizes, trace);\n\tif (p->sai_offsets) gf_isom_box_array_dump(p->sai_offsets, trace);\n\tif (p->sample_encryption) gf_isom_box_dump(p->sample_encryption, trace);\n\tgf_isom_box_dump_done(\"TrackFragmentBox\", a, trace);\n\treturn GF_OK;\n}\n\nstatic void frag_dump_sample_flags(FILE * trace, u32 flags)\n{\n\tfprintf(trace, \" SamplePadding=\\\"%d\\\" Sync=\\\"%d\\\" DegradationPriority=\\\"%d\\\" IsLeading=\\\"%d\\\" DependsOn=\\\"%d\\\" IsDependedOn=\\\"%d\\\" HasRedundancy=\\\"%d\\\"\",\n\t        GF_ISOM_GET_FRAG_PAD(flags), GF_ISOM_GET_FRAG_SYNC(flags), GF_ISOM_GET_FRAG_DEG(flags),\n\t        GF_ISOM_GET_FRAG_LEAD(flags), GF_ISOM_GET_FRAG_DEPENDS(flags), GF_ISOM_GET_FRAG_DEPENDED(flags), GF_ISOM_GET_FRAG_REDUNDANT(flags));\n}\n\nGF_Err tfhd_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackFragmentHeaderBox *p;\n\tp = (GF_TrackFragmentHeaderBox *)a;\n\tgf_isom_box_dump_start(a, \"TrackFragmentHeaderBox\", trace);\n\tfprintf(trace, \"TrackID=\\\"%u\\\"\", p->trackID);\n\n\tif (p->flags & GF_ISOM_TRAF_BASE_OFFSET) {\n\t\tfprintf(trace, \" BaseDataOffset=\\\"\"LLU\"\\\"\", p->base_data_offset);\n\t} else {\n\t\tfprintf(trace, \" BaseDataOffset=\\\"%s\\\"\", (p->flags & GF_ISOM_MOOF_BASE_OFFSET) ? \"moof\" : \"moof-or-previous-traf\");\n\t}\n\n\tif (p->flags & GF_ISOM_TRAF_SAMPLE_DESC)\n\t\tfprintf(trace, \" SampleDescriptionIndex=\\\"%u\\\"\", p->sample_desc_index);\n\tif (p->flags & GF_ISOM_TRAF_SAMPLE_DUR)\n\t\tfprintf(trace, \" SampleDuration=\\\"%u\\\"\", p->def_sample_duration);\n\tif (p->flags & GF_ISOM_TRAF_SAMPLE_SIZE)\n\t\tfprintf(trace, \" SampleSize=\\\"%u\\\"\", p->def_sample_size);\n\n\tif (p->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) {\n\t\tfrag_dump_sample_flags(trace, p->def_sample_flags);\n\t}\n\n\tfprintf(trace, \">\\n\");\n\n\tgf_isom_box_dump_done(\"TrackFragmentHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tfxd_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"MSSTimeExtensionBox\", trace);\n\tfprintf(trace, \"AbsoluteTime=\\\"\"LLU\"\\\" FragmentDuration=\\\"\"LLU\"\\\">\\n\", ptr->absolute_time_in_track_timescale, ptr->fragment_duration_in_track_timescale);\n\tfprintf(trace, \"<FullBoxInfo Version=\\\"%d\\\" Flags=\\\"%d\\\"/>\\n\", ptr->version, ptr->flags);\n\tgf_isom_box_dump_done(\"MSSTimeExtensionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err trun_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentRunBox *p;\n\n\tp = (GF_TrackFragmentRunBox *)a;\n\tgf_isom_box_dump_start(a, \"TrackRunBox\", trace);\n\tfprintf(trace, \"SampleCount=\\\"%d\\\"\", p->sample_count);\n\n\tif (p->flags & GF_ISOM_TRUN_DATA_OFFSET)\n\t\tfprintf(trace, \" DataOffset=\\\"%d\\\"\", p->data_offset);\n\tfprintf(trace, \">\\n\");\n\n\tif (p->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\tsample_flags_dump(\"FirstSampleFlags\", p->first_sample_flags, trace);\n\t}\n\n\tif (p->flags & (GF_ISOM_TRUN_DURATION|GF_ISOM_TRUN_SIZE|GF_ISOM_TRUN_CTS_OFFSET|GF_ISOM_TRUN_FLAGS)) {\n\t\ti=0;\n\t\twhile ((ent = (GF_TrunEntry *)gf_list_enum(p->entries, &i))) {\n\n\t\t\tfprintf(trace, \"<TrackRunEntry\");\n\n\t\t\tif (p->flags & GF_ISOM_TRUN_DURATION)\n\t\t\t\tfprintf(trace, \" Duration=\\\"%u\\\"\", ent->Duration);\n\t\t\tif (p->flags & GF_ISOM_TRUN_SIZE)\n\t\t\t\tfprintf(trace, \" Size=\\\"%u\\\"\", ent->size);\n\t\t\tif (p->flags & GF_ISOM_TRUN_CTS_OFFSET)\n\t\t\t{\n\t\t\t\tif (p->version == 0)\n\t\t\t\t\tfprintf(trace, \" CTSOffset=\\\"%u\\\"\", (u32) ent->CTS_Offset);\n\t\t\t\telse\n\t\t\t\t\tfprintf(trace, \" CTSOffset=\\\"%d\\\"\", ent->CTS_Offset);\n\t\t\t}\n\n\t\t\tif (p->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\tfrag_dump_sample_flags(trace, ent->flags);\n\t\t\t}\n\t\t\tfprintf(trace, \"/>\\n\");\n\t\t}\n\t} else if (p->size) {\n\t\tfprintf(trace, \"<!-- all default values used -->\\n\");\n\t} else {\n\t\tfprintf(trace, \"<TrackRunEntry Duration=\\\"\\\" Size=\\\"\\\" CTSOffset=\\\"\\\"\");\n\t\tfrag_dump_sample_flags(trace, 0);\n\t\tfprintf(trace, \"/>\\n\");\n\t}\n\n\tgf_isom_box_dump_done(\"TrackRunBox\", a, trace);\n\treturn GF_OK;\n}\n\n#endif\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\nGF_Err DTE_Dump(GF_List *dte, FILE * trace)\n{\n\tGF_GenericDTE *p;\n\tGF_ImmediateDTE *i_p;\n\tGF_SampleDTE *s_p;\n\tGF_StreamDescDTE *sd_p;\n\tu32 i, count;\n\n\tcount = gf_list_count(dte);\n\tfor (i=0; i<count; i++) {\n\t\tp = (GF_GenericDTE *)gf_list_get(dte, i);\n\t\tswitch (p->source) {\n\t\tcase 0:\n\t\t\tfprintf(trace, \"<EmptyDataEntry/>\\n\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ti_p = (GF_ImmediateDTE *) p;\n\t\t\tfprintf(trace, \"<ImmediateDataEntry DataSize=\\\"%d\\\"/>\\n\", i_p->dataLength);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ts_p = (GF_SampleDTE *) p;\n\t\t\tfprintf(trace, \"<SampleDataEntry DataSize=\\\"%d\\\" SampleOffset=\\\"%d\\\" SampleNumber=\\\"%d\\\" TrackReference=\\\"%d\\\"/>\\n\",\n\t\t\t        s_p->dataLength, s_p->byteOffset, s_p->sampleNumber, s_p->trackRefIndex);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tsd_p = (GF_StreamDescDTE *) p;\n\t\t\tfprintf(trace, \"<SampleDescriptionEntry DataSize=\\\"%d\\\" DescriptionOffset=\\\"%d\\\" StreamDescriptionindex=\\\"%d\\\" TrackReference=\\\"%d\\\"/>\\n\",\n\t\t\t        sd_p->dataLength, sd_p->byteOffset, sd_p->streamDescIndex, sd_p->trackRefIndex);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(trace, \"<UnknownTableEntry/>\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_dump_hint_sample(GF_ISOFile *the_file, u32 trackNumber, u32 SampleNum, FILE * trace)\n{\n\tGF_ISOSample *tmp;\n\tGF_HintSampleEntryBox *entry;\n\tu32 descIndex, count, count2, i;\n\tGF_Err e=GF_OK;\n\tGF_BitStream *bs;\n\tGF_HintSample *s;\n\tGF_TrackBox *trak;\n\tGF_RTPPacket *pck;\n\tchar *szName;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !IsHintTrack(trak)) return GF_BAD_PARAM;\n\n\ttmp = gf_isom_get_sample(the_file, trackNumber, SampleNum, &descIndex);\n\tif (!tmp) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, descIndex, (GF_SampleEntryBox **) &entry, &count);\n\tif (e) {\n\t\tgf_isom_sample_del(&tmp);\n\t\treturn e;\n\t}\n\n\t//check we can read the sample\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_RTP_STSD:\n\tcase GF_ISOM_BOX_TYPE_SRTP_STSD:\n\tcase GF_ISOM_BOX_TYPE_RRTP_STSD:\n\t\tszName = \"RTP\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_RTCP_STSD:\n\t\tszName = \"RCTP\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_FDP_STSD:\n\t\tszName = \"FDP\";\n\t\tbreak;\n\tdefault:\n\t\tgf_isom_sample_del(&tmp);\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tbs = gf_bs_new(tmp->data, tmp->dataLength, GF_BITSTREAM_READ);\n\ts = gf_isom_hint_sample_new(entry->type);\n\ts->trackID = trak->Header->trackID;\n\ts->sampleNumber = SampleNum;\n\n\tgf_isom_hint_sample_read(s, bs, tmp->dataLength);\n\tgf_bs_del(bs);\n\n\tcount = gf_list_count(s->packetTable);\n\n\tfprintf(trace, \"<%sHintSample SampleNumber=\\\"%d\\\" DecodingTime=\\\"\"LLD\"\\\" RandomAccessPoint=\\\"%d\\\" PacketCount=\\\"%u\\\" reserved=\\\"%u\\\">\\n\", szName, SampleNum, LLD_CAST tmp->DTS, tmp->IsRAP, s->packetCount, s->reserved);\n\n\tif (s->hint_subtype==GF_ISOM_BOX_TYPE_FDP_STSD) {\n\t\te = gf_isom_box_dump((GF_Box*) s, trace);\n\t\tgoto err_exit;\n\t}\n\n\tif (s->packetCount != count) {\n\t\tfprintf(trace, \"<!-- WARNING: Broken %s hint sample, %d entries indicated but only %d parsed -->\\n\", szName, s->packetCount, count);\n\t}\n\n\n\tfor (i=0; i<count; i++) {\n\t\tpck = (GF_RTPPacket *)gf_list_get(s->packetTable, i);\n\n\t\tif (pck->hint_subtype==GF_ISOM_BOX_TYPE_RTCP_STSD) {\n\t\t\tGF_RTCPPacket *rtcp_pck = (GF_RTCPPacket *) pck;\n\t\t\tfprintf(trace, \"<RTCPHintPacket PacketNumber=\\\"%d\\\" V=\\\"%d\\\" P=\\\"%d\\\" Count=\\\"%d\\\" PayloadType=\\\"%d\\\" \",\n\t\t        i+1,  rtcp_pck->Version, rtcp_pck->Padding, rtcp_pck->Count, rtcp_pck->PayloadType);\n\n\t\t\tif (rtcp_pck->data) dump_data_attribute(trace, \"payload\", (char*)rtcp_pck->data, rtcp_pck->length);\n\t\t\tfprintf(trace, \">\\n\");\n\t\t\tfprintf(trace, \"</RTCPHintPacket>\\n\");\n\n\t\t} else {\n\t\t\tfprintf(trace, \"<RTPHintPacket PacketNumber=\\\"%d\\\" P=\\\"%d\\\" X=\\\"%d\\\" M=\\\"%d\\\" PayloadType=\\\"%d\\\"\",\n\t\t        i+1,  pck->P_bit, pck->X_bit, pck->M_bit, pck->payloadType);\n\n\t\t\tfprintf(trace, \" SequenceNumber=\\\"%d\\\" RepeatedPacket=\\\"%d\\\" DropablePacket=\\\"%d\\\" RelativeTransmissionTime=\\\"%d\\\" FullPacketSize=\\\"%d\\\">\\n\",\n\t\t        pck->SequenceNumber, pck->R_bit, pck->B_bit, pck->relativeTransTime, gf_isom_hint_rtp_length(pck));\n\n\n\t\t\t//TLV is made of Boxes\n\t\t\tcount2 = gf_list_count(pck->TLV);\n\t\t\tif (count2) {\n\t\t\t\tfprintf(trace, \"<PrivateExtensionTable EntryCount=\\\"%d\\\">\\n\", count2);\n\t\t\t\tgf_isom_box_array_dump(pck->TLV, trace);\n\t\t\t\tfprintf(trace, \"</PrivateExtensionTable>\\n\");\n\t\t\t}\n\t\t\t//DTE is made of NON boxes\n\t\t\tcount2 = gf_list_count(pck->DataTable);\n\t\t\tif (count2) {\n\t\t\t\tfprintf(trace, \"<PacketDataTable EntryCount=\\\"%d\\\">\\n\", count2);\n\t\t\t\tDTE_Dump(pck->DataTable, trace);\n\t\t\t\tfprintf(trace, \"</PacketDataTable>\\n\");\n\t\t\t}\n\t\t\tfprintf(trace, \"</RTPHintPacket>\\n\");\n\t\t}\n\t}\n\nerr_exit:\n\tfprintf(trace, \"</%sHintSample>\\n\", szName);\n\tgf_isom_sample_del(&tmp);\n\tgf_isom_hint_sample_del(s);\n\treturn e;\n}\n\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\nstatic void tx3g_dump_box_nobox(FILE * trace, GF_BoxRecord *rec)\n{\n\tfprintf(trace, \"<TextBox top=\\\"%d\\\" left=\\\"%d\\\" bottom=\\\"%d\\\" right=\\\"%d\\\"/>\\n\", rec->top, rec->left, rec->bottom, rec->right);\n}\n\nstatic void tx3g_print_char_offsets(FILE * trace, u32 start, u32 end, u32 *shift_offset, u32 so_count)\n{\n\tu32 i;\n\tif (shift_offset) {\n\t\tfor (i=0; i<so_count; i++) {\n\t\t\tif (start>shift_offset[i]) {\n\t\t\t\tstart --;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i<so_count; i++) {\n\t\t\tif (end>shift_offset[i]) {\n\t\t\t\tend --;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (start || end) fprintf(trace, \"fromChar=\\\"%d\\\" toChar=\\\"%d\\\" \", start, end);\n}\n\nstatic void tx3g_dump_style_nobox(FILE * trace, GF_StyleRecord *rec, u32 *shift_offset, u32 so_count)\n{\n\tfprintf(trace, \"<Style \");\n\tif (rec->startCharOffset || rec->endCharOffset)\n\t\ttx3g_print_char_offsets(trace, rec->startCharOffset, rec->endCharOffset, shift_offset, so_count);\n\n\tfprintf(trace, \"styles=\\\"\");\n\tif (!rec->style_flags) {\n\t\tfprintf(trace, \"Normal\");\n\t} else {\n\t\tif (rec->style_flags & 1) fprintf(trace, \"Bold \");\n\t\tif (rec->style_flags & 2) fprintf(trace, \"Italic \");\n\t\tif (rec->style_flags & 4) fprintf(trace, \"Underlined \");\n\t}\n\tfprintf(trace, \"\\\" fontID=\\\"%d\\\" fontSize=\\\"%d\\\" \", rec->fontID, rec->font_size);\n\ttx3g_dump_rgba8(trace, \"color\", rec->text_color);\n\tfprintf(trace, \"/>\\n\");\n}\n\nstatic char *tx3g_format_time(u64 ts, u32 timescale, char *szDur, Bool is_srt)\n{\n\tu32 h, m, s, ms;\n\tts = (u32) (ts*1000 / timescale);\n\th = (u32) (ts / 3600000);\n\tm = (u32) (ts/ 60000) - h*60;\n\ts = (u32) (ts/1000) - h*3600 - m*60;\n\tms = (u32) (ts) - h*3600000 - m*60000 - s*1000;\n\tif (is_srt) {\n\t\tsprintf(szDur, \"%02d:%02d:%02d,%03d\", h, m, s, ms);\n\t} else {\n\t\tsprintf(szDur, \"%02d:%02d:%02d.%03d\", h, m, s, ms);\n\t}\n\treturn szDur;\n}\n\nstatic GF_Err gf_isom_dump_ttxt_track(GF_ISOFile *the_file, u32 track, FILE *dump, Bool box_dump)\n{\n\tu32 i, j, count, di, nb_descs, shift_offset[20], so_count;\n\tu64 last_DTS;\n\tsize_t len;\n\tGF_Box *a;\n\tBool has_scroll;\n\tchar szDur[100];\n\tGF_Tx3gSampleEntryBox *txt;\n\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\ttxt = (GF_Tx3gSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, 0);\n\tswitch (txt->type) {\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STPP:\n\tcase GF_ISOM_BOX_TYPE_SBTT:\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (box_dump) {\n\t\tfprintf(dump, \"<TextTrack trackID=\\\"%d\\\" version=\\\"1.1\\\">\\n\", gf_isom_get_track_id(the_file, track) );\n\t} else {\n\t\tfprintf(dump, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\");\n\t\tfprintf(dump, \"<!-- GPAC 3GPP Text Stream -->\\n\");\n\n\t\tfprintf(dump, \"<TextStream version=\\\"1.1\\\">\\n\");\n\t}\n\tfprintf(dump, \"<TextStreamHeader width=\\\"%d\\\" height=\\\"%d\\\" layer=\\\"%d\\\" translation_x=\\\"%d\\\" translation_y=\\\"%d\\\">\\n\", trak->Header->width >> 16 , trak->Header->height >> 16, trak->Header->layer, trak->Header->matrix[6] >> 16, trak->Header->matrix[7] >> 16);\n\n\tnb_descs = gf_list_count(trak->Media->information->sampleTable->SampleDescription->other_boxes);\n\tfor (i=0; i<nb_descs; i++) {\n\t\tGF_Tx3gSampleEntryBox *txt = (GF_Tx3gSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, i);\n\n\t\tif (box_dump) {\n\t\t\tgf_isom_box_dump((GF_Box*) txt, dump);\n\t\t} else if  (txt->type==GF_ISOM_BOX_TYPE_TX3G) {\n\t\t\tfprintf(dump, \"<TextSampleDescription horizontalJustification=\\\"\");\n\t\t\tswitch (txt->horizontal_justification) {\n\t\t\tcase 1:\n\t\t\t\tfprintf(dump, \"center\");\n\t\t\t\tbreak;\n\t\t\tcase -1:\n\t\t\t\tfprintf(dump, \"right\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(dump, \"left\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfprintf(dump, \"\\\" verticalJustification=\\\"\");\n\t\t\tswitch (txt->vertical_justification) {\n\t\t\tcase 1:\n\t\t\t\tfprintf(dump, \"center\");\n\t\t\t\tbreak;\n\t\t\tcase -1:\n\t\t\t\tfprintf(dump, \"bottom\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(dump, \"top\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfprintf(dump, \"\\\" \");\n\t\t\ttx3g_dump_rgba8(dump, \"backColor\", txt->back_color);\n\t\t\tfprintf(dump, \" verticalText=\\\"%s\\\"\", (txt->displayFlags & GF_TXT_VERTICAL) ? \"yes\" : \"no\");\n\t\t\tfprintf(dump, \" fillTextRegion=\\\"%s\\\"\", (txt->displayFlags & GF_TXT_FILL_REGION) ? \"yes\" : \"no\");\n\t\t\tfprintf(dump, \" continuousKaraoke=\\\"%s\\\"\", (txt->displayFlags & GF_TXT_KARAOKE) ? \"yes\" : \"no\");\n\t\t\thas_scroll = GF_FALSE;\n\t\t\tif (txt->displayFlags & GF_TXT_SCROLL_IN) {\n\t\t\t\thas_scroll = GF_TRUE;\n\t\t\t\tif (txt->displayFlags & GF_TXT_SCROLL_OUT) fprintf(dump, \" scroll=\\\"InOut\\\"\");\n\t\t\t\telse fprintf(dump, \" scroll=\\\"In\\\"\");\n\t\t\t} else if (txt->displayFlags & GF_TXT_SCROLL_OUT) {\n\t\t\t\thas_scroll = GF_TRUE;\n\t\t\t\tfprintf(dump, \" scroll=\\\"Out\\\"\");\n\t\t\t} else {\n\t\t\t\tfprintf(dump, \" scroll=\\\"None\\\"\");\n\t\t\t}\n\t\t\tif (has_scroll) {\n\t\t\t\tu32 mode = (txt->displayFlags & GF_TXT_SCROLL_DIRECTION)>>7;\n\t\t\t\tswitch (mode) {\n\t\t\t\tcase GF_TXT_SCROLL_CREDITS:\n\t\t\t\t\tfprintf(dump, \" scrollMode=\\\"Credits\\\"\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_TXT_SCROLL_MARQUEE:\n\t\t\t\t\tfprintf(dump, \" scrollMode=\\\"Marquee\\\"\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_TXT_SCROLL_DOWN:\n\t\t\t\t\tfprintf(dump, \" scrollMode=\\\"Down\\\"\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_TXT_SCROLL_RIGHT:\n\t\t\t\t\tfprintf(dump, \" scrollMode=\\\"Right\\\"\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfprintf(dump, \" scrollMode=\\\"Unknown\\\"\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(dump, \">\\n\");\n\t\t\tfprintf(dump, \"<FontTable>\\n\");\n\t\t\tif (txt->font_table) {\n\t\t\t\tfor (j=0; j<txt->font_table->entry_count; j++) {\n\t\t\t\t\tfprintf(dump, \"<FontTableEntry fontName=\\\"%s\\\" fontID=\\\"%d\\\"/>\\n\", txt->font_table->fonts[j].fontName, txt->font_table->fonts[j].fontID);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(dump, \"</FontTable>\\n\");\n\t\t\tif ((txt->default_box.bottom == txt->default_box.top) || (txt->default_box.right == txt->default_box.left)) {\n\t\t\t\ttxt->default_box.top = txt->default_box.left = 0;\n\t\t\t\ttxt->default_box.right = trak->Header->width / 65536;\n\t\t\t\ttxt->default_box.bottom = trak->Header->height / 65536;\n\t\t\t}\n\t\t\ttx3g_dump_box_nobox(dump, &txt->default_box);\n\t\t\ttx3g_dump_style_nobox(dump, &txt->default_style, NULL, 0);\n\t\t\tfprintf(dump, \"</TextSampleDescription>\\n\");\n\t\t} else {\n\t\t\tGF_TextSampleEntryBox *text = (GF_TextSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, i);\n\t\t\tfprintf(dump, \"<TextSampleDescription horizontalJustification=\\\"\");\n\t\t\tswitch (text->textJustification) {\n\t\t\tcase 1:\n\t\t\t\tfprintf(dump, \"center\");\n\t\t\t\tbreak;\n\t\t\tcase -1:\n\t\t\t\tfprintf(dump, \"right\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(dump, \"left\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfprintf(dump, \"\\\"\");\n\n\t\t\ttx3g_dump_rgb16(dump, \" backColor\", text->background_color);\n\n\t\t\tif ((text->default_box.bottom == text->default_box.top) || (text->default_box.right == text->default_box.left)) {\n\t\t\t\ttext->default_box.top = text->default_box.left = 0;\n\t\t\t\ttext->default_box.right = trak->Header->width / 65536;\n\t\t\t\ttext->default_box.bottom = trak->Header->height / 65536;\n\t\t\t}\n\n\t\t\tif (text->displayFlags & GF_TXT_SCROLL_IN) {\n\t\t\t\tif (text->displayFlags & GF_TXT_SCROLL_OUT) fprintf(dump, \" scroll=\\\"InOut\\\"\");\n\t\t\t\telse fprintf(dump, \" scroll=\\\"In\\\"\");\n\t\t\t} else if (text->displayFlags & GF_TXT_SCROLL_OUT) {\n\t\t\t\tfprintf(dump, \" scroll=\\\"Out\\\"\");\n\t\t\t} else {\n\t\t\t\tfprintf(dump, \" scroll=\\\"None\\\"\");\n\t\t\t}\n\t\t\tfprintf(dump, \">\\n\");\n\n\t\t\ttx3g_dump_box_nobox(dump, &text->default_box);\n\t\t\tfprintf(dump, \"</TextSampleDescription>\\n\");\n\t\t}\n\t}\n\tfprintf(dump, \"</TextStreamHeader>\\n\");\n\n\tlast_DTS = 0;\n\tcount = gf_isom_get_sample_count(the_file, track);\n\tfor (i=0; i<count; i++) {\n\t\tGF_BitStream *bs;\n\t\tGF_TextSample *txt;\n\t\tGF_ISOSample *s = gf_isom_get_sample(the_file, track, i+1, &di);\n\t\tif (!s) continue;\n\n\t\tfprintf(dump, \"<TextSample sampleTime=\\\"%s\\\" sampleDescriptionIndex=\\\"%d\\\"\", tx3g_format_time(s->DTS, trak->Media->mediaHeader->timeScale, szDur, GF_FALSE), di);\n\t\tbs = gf_bs_new(s->data, s->dataLength, GF_BITSTREAM_READ);\n\t\ttxt = gf_isom_parse_texte_sample(bs);\n\t\tgf_bs_del(bs);\n\n\t\tif (!box_dump) {\n\t\t\tif (txt->highlight_color) {\n\t\t\t\tfprintf(dump, \" \");\n\t\t\t\ttx3g_dump_rgba8(dump, \"highlightColor\", txt->highlight_color->hil_color);\n\t\t\t}\n\t\t\tif (txt->scroll_delay) {\n\t\t\t\tDouble delay = txt->scroll_delay->scroll_delay;\n\t\t\t\tdelay /= trak->Media->mediaHeader->timeScale;\n\t\t\t\tfprintf(dump, \" scrollDelay=\\\"%g\\\"\", delay);\n\t\t\t}\n\t\t\tif (txt->wrap) fprintf(dump, \" wrap=\\\"%s\\\"\", (txt->wrap->wrap_flag==0x01) ? \"Automatic\" : \"None\");\n\t\t}\n\n\t\tso_count = 0;\n\n\t\tfprintf(dump, \" xml:space=\\\"preserve\\\">\");\n\t\tif (!txt->len) {\n\t\t\tlast_DTS = (u32) trak->Media->mediaHeader->duration;\n\t\t} else {\n\t\t\tunsigned short utf16Line[10000];\n\t\t\tlast_DTS = s->DTS;\n\t\t\t/*UTF16*/\n\t\t\tif ((txt->len>2) && ((unsigned char) txt->text[0] == (unsigned char) 0xFE) && ((unsigned char) txt->text[1] == (unsigned char) 0xFF)) {\n\t\t\t\t/*copy 2 more chars because the lib always add 2 '0' at the end for UTF16 end of string*/\n\t\t\t\tmemcpy((char *) utf16Line, txt->text+2, sizeof(char) * (txt->len));\n\t\t\t\tlen = gf_utf8_wcslen((const u16*)utf16Line);\n\t\t\t} else {\n\t\t\t\tchar *str;\n\t\t\t\tstr = txt->text;\n\t\t\t\tlen = gf_utf8_mbstowcs((u16*)utf16Line, 10000, (const char **) &str);\n\t\t\t}\n\t\t\tif (len != (size_t) -1) {\n\t\t\t\tutf16Line[len] = 0;\n\t\t\t\tfor (j=0; j<len; j++) {\n\t\t\t\t\tif ((utf16Line[j]=='\\n') || (utf16Line[j]=='\\r') || (utf16Line[j]==0x85) || (utf16Line[j]==0x2028) || (utf16Line[j]==0x2029) ) {\n\t\t\t\t\t\tfprintf(dump, \"\\n\");\n\t\t\t\t\t\tif ((utf16Line[j]=='\\r') && (utf16Line[j+1]=='\\n')) {\n\t\t\t\t\t\t\tshift_offset[so_count] = j;\n\t\t\t\t\t\t\tso_count++;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tswitch (utf16Line[j]) {\n\t\t\t\t\t\tcase '\\'':\n\t\t\t\t\t\t\tfprintf(dump, \"&apos;\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '\\\"':\n\t\t\t\t\t\t\tfprintf(dump, \"&quot;\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '&':\n\t\t\t\t\t\t\tfprintf(dump, \"&amp;\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '>':\n\t\t\t\t\t\t\tfprintf(dump, \"&gt;\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '<':\n\t\t\t\t\t\t\tfprintf(dump, \"&lt;\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tif (utf16Line[j] < 128) {\n\t\t\t\t\t\t\t\tfprintf(dump, \"%c\", (u8) utf16Line[j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfprintf(dump, \"&#%d;\", utf16Line[j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (box_dump) {\n\n\t\t\tif (txt->highlight_color)\n\t\t\t\tgf_isom_box_dump((GF_Box*) txt->highlight_color, dump);\n\t\t\tif (txt->scroll_delay)\n\t\t\t\tgf_isom_box_dump((GF_Box*) txt->scroll_delay, dump);\n\t\t\tif (txt->wrap)\n\t\t\t\tgf_isom_box_dump((GF_Box*) txt->wrap, dump);\n\t\t\tif (txt->box)\n\t\t\t\tgf_isom_box_dump((GF_Box*) txt->box, dump);\n\t\t\tif (txt->styles)\n\t\t\t\tgf_isom_box_dump((GF_Box*) txt->styles, dump);\n\t\t} else {\n\n\t\t\tif (txt->box) tx3g_dump_box_nobox(dump, &txt->box->box);\n\t\t\tif (txt->styles) {\n\t\t\t\tfor (j=0; j<txt->styles->entry_count; j++) {\n\t\t\t\t\ttx3g_dump_style_nobox(dump, &txt->styles->styles[j], shift_offset, so_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tj=0;\n\t\twhile ((a = (GF_Box *)gf_list_enum(txt->others, &j))) {\n\t\t\tif (box_dump) {\n\t\t\t\tgf_isom_box_dump((GF_Box*) a, dump);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (a->type) {\n\t\t\tcase GF_ISOM_BOX_TYPE_HLIT:\n\t\t\t\tfprintf(dump, \"<Highlight \");\n\t\t\t\ttx3g_print_char_offsets(dump, ((GF_TextHighlightBox *)a)->startcharoffset, ((GF_TextHighlightBox *)a)->endcharoffset, shift_offset, so_count);\n\t\t\t\tfprintf(dump, \"/>\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_BOX_TYPE_HREF:\n\t\t\t{\n\t\t\t\tGF_TextHyperTextBox *ht = (GF_TextHyperTextBox *)a;\n\t\t\t\tfprintf(dump, \"<HyperLink \");\n\t\t\t\ttx3g_print_char_offsets(dump, ht->startcharoffset, ht->endcharoffset, shift_offset, so_count);\n\t\t\t\tfprintf(dump, \"URL=\\\"%s\\\" URLToolTip=\\\"%s\\\"/>\\n\", ht->URL ? ht->URL : \"\", ht->URL_hint ? ht->URL_hint : \"\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase GF_ISOM_BOX_TYPE_BLNK:\n\t\t\t\tfprintf(dump, \"<Blinking \");\n\t\t\t\ttx3g_print_char_offsets(dump, ((GF_TextBlinkBox *)a)->startcharoffset, ((GF_TextBlinkBox *)a)->endcharoffset, shift_offset, so_count);\n\t\t\t\tfprintf(dump, \"/>\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_BOX_TYPE_KROK:\n\t\t\t{\n\t\t\t\tu32 k;\n\t\t\t\tDouble t;\n\t\t\t\tGF_TextKaraokeBox *krok = (GF_TextKaraokeBox *)a;\n\t\t\t\tt = krok->highlight_starttime;\n\t\t\t\tt /= trak->Media->mediaHeader->timeScale;\n\t\t\t\tfprintf(dump, \"<Karaoke startTime=\\\"%g\\\">\\n\", t);\n\t\t\t\tfor (k=0; k<krok->nb_entries; k++) {\n\t\t\t\t\tt = krok->records[k].highlight_endtime;\n\t\t\t\t\tt /= trak->Media->mediaHeader->timeScale;\n\t\t\t\t\tfprintf(dump, \"<KaraokeRange \");\n\t\t\t\t\ttx3g_print_char_offsets(dump, krok->records[k].start_charoffset, krok->records[k].end_charoffset, shift_offset, so_count);\n\t\t\t\t\tfprintf(dump, \"endTime=\\\"%g\\\"/>\\n\", t);\n\t\t\t\t}\n\t\t\t\tfprintf(dump, \"</Karaoke>\\n\");\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfprintf(dump, \"</TextSample>\\n\");\n\t\tgf_isom_sample_del(&s);\n\t\tgf_isom_delete_text_sample(txt);\n\t\tgf_set_progress(\"TTXT Extract\", i, count);\n\t}\n\tif (last_DTS < trak->Media->mediaHeader->duration) {\n\t\tfprintf(dump, \"<TextSample sampleTime=\\\"%s\\\" text=\\\"\\\" />\\n\", tx3g_format_time(trak->Media->mediaHeader->duration, trak->Media->mediaHeader->timeScale, szDur, GF_FALSE));\n\t}\n\n\tif (box_dump) {\n\t\tfprintf(dump, \"</TextTrack>\\n\");\n\t} else {\n\t\tfprintf(dump, \"</TextStream>\\n\");\n\t}\n\tif (count) gf_set_progress(\"TTXT Extract\", count, count);\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_isom_dump_srt_track(GF_ISOFile *the_file, u32 track, FILE *dump)\n{\n\tu32 i, j, k, count, di, len, ts, cur_frame;\n\tu64 start, end;\n\tGF_Tx3gSampleEntryBox *txtd;\n\tGF_BitStream *bs;\n\tchar szDur[100];\n\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tts = trak->Media->mediaHeader->timeScale;\n\tcur_frame = 0;\n\tend = 0;\n\n\tcount = gf_isom_get_sample_count(the_file, track);\n\tfor (i=0; i<count; i++) {\n\t\tGF_TextSample *txt;\n\t\tGF_ISOSample *s = gf_isom_get_sample(the_file, track, i+1, &di);\n\t\tif (!s) continue;\n\n\t\tstart = s->DTS;\n\t\tif (s->dataLength==2) {\n\t\t\tgf_isom_sample_del(&s);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i+1<count) {\n\t\t\tGF_ISOSample *next = gf_isom_get_sample_info(the_file, track, i+2, NULL, NULL);\n\t\t\tif (next) {\n\t\t\t\tend = next->DTS;\n\t\t\t\tgf_isom_sample_del(&next);\n\t\t\t}\n\t\t} else {\n\t\t\tend = gf_isom_get_media_duration(the_file, track) ;\n\t\t}\n\t\tcur_frame++;\n\t\tfprintf(dump, \"%d\\n\", cur_frame);\n\t\ttx3g_format_time(start, ts, szDur, GF_TRUE);\n\t\tfprintf(dump, \"%s --> \", szDur);\n\t\ttx3g_format_time(end, ts, szDur, GF_TRUE);\n\t\tfprintf(dump, \"%s\\n\", szDur);\n\n\t\tbs = gf_bs_new(s->data, s->dataLength, GF_BITSTREAM_READ);\n\t\ttxt = gf_isom_parse_texte_sample(bs);\n\t\tgf_bs_del(bs);\n\n\t\ttxtd = (GF_Tx3gSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->other_boxes, di-1);\n\n\t\tif (!txt->len) {\n\t\t\tfprintf(dump, \"\\n\");\n\t\t} else {\n\t\t\tu32 styles, char_num, new_styles, color, new_color;\n\t\t\tu16 utf16Line[10000];\n\n\t\t\t/*UTF16*/\n\t\t\tif ((txt->len>2) && ((unsigned char) txt->text[0] == (unsigned char) 0xFE) && ((unsigned char) txt->text[1] == (unsigned char) 0xFF)) {\n\t\t\t\tmemcpy(utf16Line, txt->text+2, sizeof(char)*txt->len);\n\t\t\t\t( ((char *)utf16Line)[txt->len] ) = 0;\n\t\t\t\tlen = txt->len;\n\t\t\t} else {\n\t\t\t\tu8 *str = (u8 *) (txt->text);\n\t\t\t\tsize_t res = gf_utf8_mbstowcs(utf16Line, 10000, (const char **) &str);\n\t\t\t\tif (res==(size_t)-1) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\tlen = (u32) res;\n\t\t\t\tutf16Line[len] = 0;\n\t\t\t}\n\t\t\tchar_num = 0;\n\t\t\tstyles = 0;\n\t\t\tnew_styles = txtd->default_style.style_flags;\n\t\t\tcolor = new_color = txtd->default_style.text_color;\n\n\t\t\tfor (j=0; j<len; j++) {\n\t\t\t\tBool is_new_line;\n\n\t\t\t\tif (txt->styles) {\n\t\t\t\t\tnew_styles = txtd->default_style.style_flags;\n\t\t\t\t\tnew_color = txtd->default_style.text_color;\n\t\t\t\t\tfor (k=0; k<txt->styles->entry_count; k++) {\n\t\t\t\t\t\tif (txt->styles->styles[k].startCharOffset>char_num) continue;\n\t\t\t\t\t\tif (txt->styles->styles[k].endCharOffset<char_num+1) continue;\n\n\t\t\t\t\t\tif (txt->styles->styles[k].style_flags & (GF_TXT_STYLE_ITALIC | GF_TXT_STYLE_BOLD | GF_TXT_STYLE_UNDERLINED)) {\n\t\t\t\t\t\t\tnew_styles = txt->styles->styles[k].style_flags;\n\t\t\t\t\t\t\tnew_color = txt->styles->styles[k].text_color;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (new_styles != styles) {\n\t\t\t\t\tif ((new_styles & GF_TXT_STYLE_BOLD) && !(styles & GF_TXT_STYLE_BOLD)) fprintf(dump, \"<b>\");\n\t\t\t\t\tif ((new_styles & GF_TXT_STYLE_ITALIC) && !(styles & GF_TXT_STYLE_ITALIC)) fprintf(dump, \"<i>\");\n\t\t\t\t\tif ((new_styles & GF_TXT_STYLE_UNDERLINED) && !(styles & GF_TXT_STYLE_UNDERLINED)) fprintf(dump, \"<u>\");\n\n\t\t\t\t\tif ((styles & GF_TXT_STYLE_UNDERLINED) && !(new_styles & GF_TXT_STYLE_UNDERLINED)) fprintf(dump, \"</u>\");\n\t\t\t\t\tif ((styles & GF_TXT_STYLE_ITALIC) && !(new_styles & GF_TXT_STYLE_ITALIC)) fprintf(dump, \"</i>\");\n\t\t\t\t\tif ((styles & GF_TXT_STYLE_BOLD) && !(new_styles & GF_TXT_STYLE_BOLD)) fprintf(dump, \"</b>\");\n\n\t\t\t\t\tstyles = new_styles;\n\t\t\t\t}\n\t\t\t\tif (new_color != color) {\n\t\t\t\t\tif (new_color ==txtd->default_style.text_color) {\n\t\t\t\t\t\tfprintf(dump, \"</font>\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(dump, \"<font color=\\\"%s\\\">\", gf_color_get_name(new_color) );\n\t\t\t\t\t}\n\t\t\t\t\tcolor = new_color;\n\t\t\t\t}\n\n\t\t\t\t/*not sure if styles must be reseted at line breaks in srt...*/\n\t\t\t\tis_new_line = GF_FALSE;\n\t\t\t\tif ((utf16Line[j]=='\\n') || (utf16Line[j]=='\\r') ) {\n\t\t\t\t\tif ((utf16Line[j]=='\\r') && (utf16Line[j+1]=='\\n')) j++;\n\t\t\t\t\tfprintf(dump, \"\\n\");\n\t\t\t\t\tis_new_line = GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tif (!is_new_line) {\n\t\t\t\t\tsize_t sl;\n\t\t\t\t\tchar szChar[30];\n\t\t\t\t\ts16 swT[2], *swz;\n\t\t\t\t\tswT[0] = utf16Line[j];\n\t\t\t\t\tswT[1] = 0;\n\t\t\t\t\tswz= (s16 *)swT;\n\t\t\t\t\tsl = gf_utf8_wcstombs(szChar, 30, (const unsigned short **) &swz);\n\t\t\t\t\tif (sl == (size_t)-1) sl=0;\n\t\t\t\t\tszChar[(u32) sl]=0;\n\t\t\t\t\tfprintf(dump, \"%s\", szChar);\n\t\t\t\t}\n\t\t\t\tchar_num++;\n\t\t\t}\n\t\t\tnew_styles = 0;\n\t\t\tif (new_styles != styles) {\n\t\t\t\tif (styles & GF_TXT_STYLE_UNDERLINED) fprintf(dump, \"</u>\");\n\t\t\t\tif (styles & GF_TXT_STYLE_ITALIC) fprintf(dump, \"</i>\");\n\t\t\t\tif (styles & GF_TXT_STYLE_BOLD) fprintf(dump, \"</b>\");\n\n//\t\t\t\tstyles = 0;\n\t\t\t}\n\n\t\t\tif (color != txtd->default_style.text_color) {\n\t\t\t\tfprintf(dump, \"</font>\");\n//\t\t\t\tcolor = txtd->default_style.text_color;\n\t\t\t}\n\t\t\tfprintf(dump, \"\\n\");\n\t\t}\n\t\tgf_isom_sample_del(&s);\n\t\tgf_isom_delete_text_sample(txt);\n\t\tfprintf(dump, \"\\n\");\n\t\tgf_set_progress(\"SRT Extract\", i, count);\n\t}\n\tif (count) gf_set_progress(\"SRT Extract\", i, count);\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_isom_dump_svg_track(GF_ISOFile *the_file, u32 track, FILE *dump)\n{\n\tchar nhmlFileName[1024];\n\tFILE *nhmlFile;\n\tu32 i, count, di, ts, cur_frame;\n\tu64 start, end;\n\tGF_BitStream *bs;\n\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tstrcpy(nhmlFileName, the_file->fileName);\n\tstrcat(nhmlFileName, \".nhml\");\n\tnhmlFile = gf_fopen(nhmlFileName, \"wt\");\n\tfprintf(nhmlFile, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n\tfprintf(nhmlFile, \"<NHNTStream streamType=\\\"3\\\" objectTypeIndication=\\\"10\\\" timeScale=\\\"%d\\\" baseMediaFile=\\\"file.svg\\\" inRootOD=\\\"yes\\\">\\n\", trak->Media->mediaHeader->timeScale);\n\tfprintf(nhmlFile, \"<NHNTSample isRAP=\\\"yes\\\" DTS=\\\"0\\\" xmlFrom=\\\"doc.start\\\" xmlTo=\\\"text_1.start\\\"/>\\n\");\n\n\tts = trak->Media->mediaHeader->timeScale;\n\tcur_frame = 0;\n\tend = 0;\n\n\tfprintf(dump, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n\tfprintf(dump, \"<svg version=\\\"1.2\\\" baseProfile=\\\"tiny\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" width=\\\"%d\\\" height=\\\"%d\\\" fill=\\\"black\\\">\\n\", trak->Header->width >> 16 , trak->Header->height >> 16);\n\tfprintf(dump, \"<g transform=\\\"translate(%d, %d)\\\" text-anchor=\\\"middle\\\">\\n\", (trak->Header->width >> 16)/2 , (trak->Header->height >> 16)/2);\n\n\tcount = gf_isom_get_sample_count(the_file, track);\n\tfor (i=0; i<count; i++) {\n\t\tGF_TextSample *txt;\n\t\tGF_ISOSample *s = gf_isom_get_sample(the_file, track, i+1, &di);\n\t\tif (!s) continue;\n\n\t\tstart = s->DTS;\n\t\tif (s->dataLength==2) {\n\t\t\tgf_isom_sample_del(&s);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i+1<count) {\n\t\t\tGF_ISOSample *next = gf_isom_get_sample_info(the_file, track, i+2, NULL, NULL);\n\t\t\tif (next) {\n\t\t\t\tend = next->DTS;\n\t\t\t\tgf_isom_sample_del(&next);\n\t\t\t}\n\t\t}\n\n\t\tcur_frame++;\n\t\tbs = gf_bs_new(s->data, s->dataLength, GF_BITSTREAM_READ);\n\t\ttxt = gf_isom_parse_texte_sample(bs);\n\t\tgf_bs_del(bs);\n\n\t\tif (!txt->len) continue;\n\n\t\tfprintf(dump, \" <text id=\\\"text_%d\\\" display=\\\"none\\\">%s\\n\", cur_frame, txt->text);\n\t\tfprintf(dump, \"  <set attributeName=\\\"display\\\" to=\\\"inline\\\" begin=\\\"%g\\\" end=\\\"%g\\\"/>\\n\", ((s64)start*1.0)/ts, ((s64)end*1.0)/ts);\n\t\tfprintf(dump, \"  <discard begin=\\\"%g\\\"/>\\n\", ((s64)end*1.0)/ts);\n\t\tfprintf(dump, \" </text>\\n\");\n\t\tgf_isom_sample_del(&s);\n\t\tgf_isom_delete_text_sample(txt);\n\t\tfprintf(dump, \"\\n\");\n\t\tgf_set_progress(\"SRT Extract\", i, count);\n\n\t\tif (i == count - 2) {\n\t\t\tfprintf(nhmlFile, \"<NHNTSample isRAP=\\\"no\\\" DTS=\\\"%f\\\" xmlFrom=\\\"text_%d.start\\\" xmlTo=\\\"doc.end\\\"/>\\n\", ((s64)start*1.0), cur_frame);\n\t\t} else {\n\t\t\tfprintf(nhmlFile, \"<NHNTSample isRAP=\\\"no\\\" DTS=\\\"%f\\\" xmlFrom=\\\"text_%d.start\\\" xmlTo=\\\"text_%d.start\\\"/>\\n\", ((s64)start*1.0), cur_frame, cur_frame+1);\n\t\t}\n\n\t}\n\tfprintf(dump, \"</g>\\n\");\n\tfprintf(dump, \"</svg>\\n\");\n\n\tfprintf(nhmlFile, \"</NHNTStream>\\n\");\n\tgf_fclose(nhmlFile);\n\n\tif (count) gf_set_progress(\"SRT Extract\", i, count);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_dump(GF_ISOFile *the_file, u32 track, FILE *dump, GF_TextDumpType dump_type)\n{\n\tswitch (dump_type) {\n\tcase GF_TEXTDUMPTYPE_SVG:\n\t\treturn gf_isom_dump_svg_track(the_file, track, dump);\n\tcase GF_TEXTDUMPTYPE_SRT:\n\t\treturn gf_isom_dump_srt_track(the_file, track, dump);\n\tcase GF_TEXTDUMPTYPE_TTXT:\n\tcase GF_TEXTDUMPTYPE_TTXT_BOXES:\n\t\treturn gf_isom_dump_ttxt_track(the_file, track, dump, (dump_type==GF_TEXTDUMPTYPE_TTXT_BOXES) ? GF_TRUE : GF_FALSE);\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\n\n/* ISMA 1.0 Encryption and Authentication V 1.0  dump */\nGF_Err sinf_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ProtectionSchemeInfoBox *p;\n\tp = (GF_ProtectionSchemeInfoBox *)a;\n\tgf_isom_box_dump_start(a, \"ProtectionSchemeInfoBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->original_format, trace, GF_ISOM_BOX_TYPE_FRMA);\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->scheme_type, trace, GF_ISOM_BOX_TYPE_SCHM);\n\tif (p->size)\n\t\tgf_isom_box_dump_ex(p->info, trace, GF_ISOM_BOX_TYPE_SCHI);\n\tgf_isom_box_dump_done(\"ProtectionSchemeInfoBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err frma_dump(GF_Box *a, FILE * trace)\n{\n\tGF_OriginalFormatBox *p;\n\tp = (GF_OriginalFormatBox *)a;\n\tgf_isom_box_dump_start(a, \"OriginalFormatBox\", trace);\n\tfprintf(trace, \"data_format=\\\"%s\\\">\\n\", gf_4cc_to_str(p->data_format));\n\tgf_isom_box_dump_done(\"OriginalFormatBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err schm_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SchemeTypeBox *p;\n\tp = (GF_SchemeTypeBox *)a;\n\tgf_isom_box_dump_start(a, \"SchemeTypeBox\", trace);\n\tfprintf(trace, \"scheme_type=\\\"%s\\\" scheme_version=\\\"%d\\\" \", gf_4cc_to_str(p->scheme_type), p->scheme_version);\n\tif (p->URI) fprintf(trace, \"scheme_uri=\\\"%s\\\"\", p->URI);\n\tfprintf(trace, \">\\n\");\n\n\tgf_isom_box_dump_done(\"SchemeTypeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err schi_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SchemeInformationBox *p;\n\tp = (GF_SchemeInformationBox *)a;\n\tgf_isom_box_dump_start(a, \"SchemeInformationBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->ikms) gf_isom_box_dump(p->ikms, trace);\n\tif (p->isfm) gf_isom_box_dump(p->isfm, trace);\n\tif (p->islt) gf_isom_box_dump(p->islt, trace);\n\tif (p->odkm) gf_isom_box_dump(p->odkm, trace);\n\tif (p->tenc) gf_isom_box_dump(p->tenc, trace);\n\tif (p->adkm) gf_isom_box_dump(p->adkm, trace);\n\tgf_isom_box_dump_done(\"SchemeInformationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err iKMS_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ISMAKMSBox *p;\n\tp = (GF_ISMAKMSBox *)a;\n\tgf_isom_box_dump_start(a, \"KMSBox\", trace);\n\tfprintf(trace, \"kms_URI=\\\"%s\\\">\\n\", p->URI);\n\tgf_isom_box_dump_done(\"KMSBox\", a, trace);\n\treturn GF_OK;\n\n}\n\nGF_Err iSFM_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ISMASampleFormatBox *p;\n\tconst char *name = (a->type==GF_ISOM_BOX_TYPE_ISFM) ? \"ISMASampleFormat\" : \"OMADRMAUFormatBox\";\n\tp = (GF_ISMASampleFormatBox *)a;\n\tgf_isom_box_dump_start(a, name, trace);\n\tfprintf(trace, \"selective_encryption=\\\"%d\\\" key_indicator_length=\\\"%d\\\" IV_length=\\\"%d\\\">\\n\", p->selective_encryption, p->key_indicator_length, p->IV_length);\n\tgf_isom_box_dump_done(name, a, trace);\n\treturn GF_OK;\n}\n\nGF_Err iSLT_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ISMACrypSaltBox *p = (GF_ISMACrypSaltBox *)a;\n\tgf_isom_box_dump_start(a, \"ISMACrypSaltBox\", trace);\n\tfprintf(trace, \"salt=\\\"\"LLU\"\\\">\\n\", p->salt);\n\tgf_isom_box_dump_done(\"ISMACrypSaltBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_dump_ismacryp_protection(GF_ISOFile *the_file, u32 trackNumber, FILE * trace)\n{\n\tu32 i, count;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\tfprintf(trace, \"<ISMACrypSampleDescriptions>\\n\");\n\tcount = gf_isom_get_sample_description_count(the_file, trackNumber);\n\tfor (i=0; i<count; i++) {\n\t\te = Media_GetSampleDesc(trak->Media, i+1, (GF_SampleEntryBox **) &entry, NULL);\n\t\tif (e) return e;\n\n\t\tswitch (entry->type) {\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_ENCT:\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tgf_isom_box_dump(entry, trace);\n\t}\n\tfprintf(trace, \"</ISMACrypSampleDescriptions>\\n\");\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_dump_ismacryp_sample(GF_ISOFile *the_file, u32 trackNumber, u32 SampleNum, FILE * trace)\n{\n\tGF_ISOSample *samp;\n\tGF_ISMASample  *isma_samp;\n\tu32 descIndex;\n\n\tsamp = gf_isom_get_sample(the_file, trackNumber, SampleNum, &descIndex);\n\tif (!samp) return GF_BAD_PARAM;\n\n\tisma_samp = gf_isom_get_ismacryp_sample(the_file, trackNumber, samp, descIndex);\n\tif (!isma_samp) {\n\t\tgf_isom_sample_del(&samp);\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tfprintf(trace, \"<ISMACrypSample SampleNumber=\\\"%d\\\" DataSize=\\\"%d\\\" CompositionTime=\\\"\"LLD\"\\\" \", SampleNum, isma_samp->dataLength, LLD_CAST (samp->DTS+samp->CTS_Offset) );\n\tif (samp->CTS_Offset) fprintf(trace, \"DecodingTime=\\\"\"LLD\"\\\" \", LLD_CAST samp->DTS);\n\tif (gf_isom_has_sync_points(the_file, trackNumber)) fprintf(trace, \"RandomAccessPoint=\\\"%s\\\" \", samp->IsRAP ? \"Yes\" : \"No\");\n\tfprintf(trace, \"IsEncrypted=\\\"%s\\\" \", (isma_samp->flags & GF_ISOM_ISMA_IS_ENCRYPTED) ? \"Yes\" : \"No\");\n\tif (isma_samp->flags & GF_ISOM_ISMA_IS_ENCRYPTED) {\n\t\tfprintf(trace, \"IV=\\\"\"LLD\"\\\" \", LLD_CAST isma_samp->IV);\n\t\tif (isma_samp->key_indicator) dump_data_attribute(trace, \"KeyIndicator\", (char*)isma_samp->key_indicator, isma_samp->KI_length);\n\t}\n\tfprintf(trace, \"/>\\n\");\n\n\tgf_isom_sample_del(&samp);\n\tgf_isom_ismacryp_delete_sample(isma_samp);\n\treturn GF_OK;\n}\n\n/* end of ISMA 1.0 Encryption and Authentication V 1.0 */\n\n\n/* Apple extensions */\n\nGF_Err ilst_item_dump(GF_Box *a, FILE * trace)\n{\n\tGF_BitStream *bs;\n\tu32 val;\n\tBool no_dump = GF_FALSE;\n\tchar *name = \"UnknownBox\";\n\tGF_ListItemBox *itune = (GF_ListItemBox *)a;\n\tswitch (itune->type) {\n\tcase GF_ISOM_BOX_TYPE_0xA9NAM:\n\t\tname = \"NameBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9CMT:\n\t\tname = \"CommentBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9DAY:\n\t\tname = \"CreatedBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9ART:\n\t\tname = \"ArtistBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9TRK:\n\t\tname = \"TrackBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9ALB:\n\t\tname = \"AlbumBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9COM:\n\t\tname = \"CompositorBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9WRT:\n\t\tname = \"WriterBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9TOO:\n\t\tname = \"ToolBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9CPY:\n\t\tname = \"CopyrightBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9DES:\n\t\tname = \"DescriptionBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9GEN:\n\tcase GF_ISOM_BOX_TYPE_GNRE:\n\t\tname = \"GenreBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_aART:\n\t\tname = \"AlbumArtistBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_PGAP:\n\t\tname = \"GapelessBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DISK:\n\t\tname = \"DiskBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TRKN:\n\t\tname = \"TrackNumberBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TMPO:\n\t\tname = \"TempoBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_CPIL:\n\t\tname = \"CompilationBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_COVR:\n\t\tname = \"CoverArtBox\";\n\t\tno_dump = GF_TRUE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_iTunesSpecificInfo:\n\t\tname = \"iTunesSpecificBox\";\n\t\tno_dump = GF_TRUE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9GRP:\n\t\tname = \"GroupBox\";\n\t\tbreak;\n\tcase GF_ISOM_ITUNE_ENCODER:\n\t\tname = \"EncoderBox\";\n\t\tbreak;\n\t}\n\tgf_isom_box_dump_start(a, name, trace);\n\n\tif (!no_dump) {\n\t\tswitch (itune->type) {\n\t\tcase GF_ISOM_BOX_TYPE_DISK:\n\t\tcase GF_ISOM_BOX_TYPE_TRKN:\n\t\t\tbs = gf_bs_new(itune->data->data, itune->data->dataSize, GF_BITSTREAM_READ);\n\t\t\tgf_bs_read_int(bs, 16);\n\t\t\tval = gf_bs_read_int(bs, 16);\n\t\t\tif (itune->type==GF_ISOM_BOX_TYPE_DISK) {\n\t\t\t\tfprintf(trace, \" DiskNumber=\\\"%d\\\" NbDisks=\\\"%d\\\" \", val, gf_bs_read_int(bs, 16) );\n\t\t\t} else {\n\t\t\t\tfprintf(trace, \" TrackNumber=\\\"%d\\\" NbTracks=\\\"%d\\\" \", val, gf_bs_read_int(bs, 16) );\n\t\t\t}\n\t\t\tgf_bs_del(bs);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_TMPO:\n\t\t\tbs = gf_bs_new(itune->data->data, itune->data->dataSize, GF_BITSTREAM_READ);\n\t\t\tfprintf(trace, \" BPM=\\\"%d\\\" \", gf_bs_read_int(bs, 16) );\n\t\t\tgf_bs_del(bs);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_CPIL:\n\t\t\tfprintf(trace, \" IsCompilation=\\\"%s\\\" \", (itune->data && itune->data->data && itune->data->data[0]) ? \"yes\" : \"no\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_PGAP:\n\t\t\tfprintf(trace, \" IsGapeless=\\\"%s\\\" \", (itune->data && itune->data->data && itune->data->data[0]) ? \"yes\" : \"no\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (strcmp(name, \"UnknownBox\") && itune->data && itune->data->data) {\n\t\t\t\tfprintf(trace, \" value=\\\"\");\n\t\t\t\tif (itune->data && itune->data->data[0]) {\n\t\t\t\t\tdump_data_string(trace, itune->data->data, itune->data->dataSize);\n\t\t\t\t} else {\n\t\t\t\t\tdump_data(trace, itune->data->data, itune->data->dataSize);\n\t\t\t\t}\n\t\t\t\tfprintf(trace, \"\\\" \");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(name, a, trace);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\nGF_Err abst_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_AdobeBootstrapInfoBox *p = (GF_AdobeBootstrapInfoBox*)a;\n\tgf_isom_box_dump_start(a, \"AdobeBootstrapBox\", trace);\n\n\tfprintf(trace, \"BootstrapinfoVersion=\\\"%u\\\" Profile=\\\"%u\\\" Live=\\\"%u\\\" Update=\\\"%u\\\" TimeScale=\\\"%u\\\" CurrentMediaTime=\\\"\"LLU\"\\\" SmpteTimeCodeOffset=\\\"\"LLU\"\\\" \",\n\t        p->bootstrapinfo_version, p->profile, p->live, p->update, p->time_scale, p->current_media_time, p->smpte_time_code_offset);\n\tif (p->movie_identifier)\n\t\tfprintf(trace, \"MovieIdentifier=\\\"%s\\\" \", p->movie_identifier);\n\tif (p->drm_data)\n\t\tfprintf(trace, \"DrmData=\\\"%s\\\" \", p->drm_data);\n\tif (p->meta_data)\n\t\tfprintf(trace, \"MetaData=\\\"%s\\\" \", p->meta_data);\n\tfprintf(trace, \">\\n\");\n\n\tfor (i=0; i<p->server_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(p->server_entry_table, i);\n\t\tfprintf(trace, \"<ServerEntry>%s</ServerEntry>\\n\", str);\n\t}\n\n\tfor (i=0; i<p->quality_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(p->quality_entry_table, i);\n\t\tfprintf(trace, \"<QualityEntry>%s</QualityEntry>\\n\", str);\n\t}\n\n\tfor (i=0; i<p->segment_run_table_count; i++)\n\t\tgf_isom_box_dump(gf_list_get(p->segment_run_table_entries, i), trace);\n\n\tfor (i=0; i<p->fragment_run_table_count; i++)\n\t\tgf_isom_box_dump(gf_list_get(p->fragment_run_table_entries, i), trace);\n\n\tgf_isom_box_dump_done(\"AdobeBootstrapBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err afra_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_AdobeFragRandomAccessBox *p = (GF_AdobeFragRandomAccessBox*)a;\n\tgf_isom_box_dump_start(a, \"AdobeFragmentRandomAccessBox\", trace);\n\n\tfprintf(trace, \"LongIDs=\\\"%u\\\" LongOffsets=\\\"%u\\\" TimeScale=\\\"%u\\\">\\n\", p->long_ids, p->long_offsets, p->time_scale);\n\n\tfor (i=0; i<p->entry_count; i++) {\n\t\tGF_AfraEntry *ae = (GF_AfraEntry *)gf_list_get(p->local_access_entries, i);\n\t\tfprintf(trace, \"<LocalAccessEntry Time=\\\"\"LLU\"\\\" Offset=\\\"\"LLU\"\\\"/>\\n\", ae->time, ae->offset);\n\t}\n\n\tfor (i=0; i<p->global_entry_count; i++) {\n\t\tGF_GlobalAfraEntry *gae = (GF_GlobalAfraEntry *)gf_list_get(p->global_access_entries, i);\n\t\tfprintf(trace, \"<GlobalAccessEntry Time=\\\"\"LLU\"\\\" Segment=\\\"%u\\\" Fragment=\\\"%u\\\" AfraOffset=\\\"\"LLU\"\\\" OffsetFromAfra=\\\"\"LLU\"\\\"/>\\n\",\n\t\t        gae->time, gae->segment, gae->fragment, gae->afra_offset, gae->offset_from_afra);\n\t}\n\n\tgf_isom_box_dump_done(\"AdobeFragmentRandomAccessBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err afrt_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_AdobeFragmentRunTableBox *p = (GF_AdobeFragmentRunTableBox*)a;\n\tgf_isom_box_dump_start(a, \"AdobeFragmentRunTableBox\", trace);\n\n\tfprintf(trace, \"TimeScale=\\\"%u\\\">\\n\", p->timescale);\n\n\tfor (i=0; i<p->quality_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(p->quality_segment_url_modifiers, i);\n\t\tfprintf(trace, \"<QualityEntry>%s</QualityEntry>\\n\", str);\n\t}\n\n\tfor (i=0; i<p->fragment_run_entry_count; i++) {\n\t\tGF_AdobeFragmentRunEntry *fre = (GF_AdobeFragmentRunEntry *)gf_list_get(p->fragment_run_entry_table, i);\n\t\tfprintf(trace, \"<FragmentRunEntry FirstFragment=\\\"%u\\\" FirstFragmentTimestamp=\\\"\"LLU\"\\\" FirstFragmentDuration=\\\"%u\\\"\", fre->first_fragment, fre->first_fragment_timestamp, fre->fragment_duration);\n\t\tif (!fre->fragment_duration)\n\t\t\tfprintf(trace, \" DiscontinuityIndicator=\\\"%u\\\"\", fre->discontinuity_indicator);\n\t\tfprintf(trace, \"/>\\n\");\n\t}\n\n\tgf_isom_box_dump_done(\"AdobeFragmentRunTableBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err asrt_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_AdobeSegmentRunTableBox *p = (GF_AdobeSegmentRunTableBox*)a;\n\tgf_isom_box_dump_start(a, \"AdobeSegmentRunTableBox\", trace);\n\n\tfprintf(trace, \">\\n\");\n\n\tfor (i=0; i<p->quality_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(p->quality_segment_url_modifiers, i);\n\t\tfprintf(trace, \"<QualityEntry>%s</QualityEntry>\\n\", str);\n\t}\n\n\tfor (i=0; i<p->segment_run_entry_count; i++) {\n\t\tGF_AdobeSegmentRunEntry *sre = (GF_AdobeSegmentRunEntry *)gf_list_get(p->segment_run_entry_table, i);\n\t\tfprintf(trace, \"<SegmentRunEntry FirstSegment=\\\"%u\\\" FragmentsPerSegment=\\\"%u\\\"/>\\n\", sre->first_segment, sre->fragment_per_segment);\n\t}\n\n\tgf_isom_box_dump_done(\"AdobeSegmentRunTableBox\", a, trace);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_ADOBE*/\n\nGF_Err ilst_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_Box *tag;\n\tGF_Err e;\n\tGF_ItemListBox *ptr;\n\tptr = (GF_ItemListBox *)a;\n\tgf_isom_box_dump_start(a, \"ItemListBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\ti=0;\n\twhile ( (tag = (GF_Box*)gf_list_enum(ptr->other_boxes, &i))) {\n\t\te = ilst_item_dump(tag, trace);\n\t\tif(e) return e;\n\t}\n\tgf_isom_box_dump_done(\"ItemListBox\", NULL, trace);\n\treturn GF_OK;\n}\n\nGF_Err databox_dump(GF_Box *a, FILE * trace)\n{\n\tgf_isom_box_dump_start(a, \"data\", trace);\n\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"data\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ohdr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_OMADRMCommonHeaderBox *ptr = (GF_OMADRMCommonHeaderBox *)a;\n\tgf_isom_box_dump_start(a, \"OMADRMCommonHeaderBox\", trace);\n\n\tfprintf(trace, \"EncryptionMethod=\\\"%d\\\" PaddingScheme=\\\"%d\\\" PlaintextLength=\\\"\"LLD\"\\\" \",\n\t        ptr->EncryptionMethod, ptr->PaddingScheme, ptr->PlaintextLength);\n\tif (ptr->RightsIssuerURL) fprintf(trace, \"RightsIssuerURL=\\\"%s\\\" \", ptr->RightsIssuerURL);\n\tif (ptr->ContentID) fprintf(trace, \"ContentID=\\\"%s\\\" \", ptr->ContentID);\n\tif (ptr->TextualHeaders) {\n\t\tu32 i, offset;\n\t\tchar *start = ptr->TextualHeaders;\n\t\tfprintf(trace, \"TextualHeaders=\\\"\");\n\t\ti=offset=0;\n\t\twhile (i<ptr->TextualHeadersLen) {\n\t\t\tif (start[i]==0) {\n\t\t\t\tfprintf(trace, \"%s \", start+offset);\n\t\t\t\toffset=i+1;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfprintf(trace, \"%s\\\"  \", start+offset);\n\t}\n\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"OMADRMCommonHeaderBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err grpi_dump(GF_Box *a, FILE * trace)\n{\n\tGF_OMADRMGroupIDBox *ptr = (GF_OMADRMGroupIDBox *)a;\n\tgf_isom_box_dump_start(a, \"OMADRMGroupIDBox\", trace);\n\n\tfprintf(trace, \"GroupID=\\\"%s\\\" EncryptionMethod=\\\"%d\\\" GroupKey=\\\" \", ptr->GroupID, ptr->GKEncryptionMethod);\n\tif (ptr->GroupKey)\n\t\tdump_data(trace, ptr->GroupKey, ptr->GKLength);\n\tfprintf(trace, \"\\\">\\n\");\n\tgf_isom_box_dump_done(\"OMADRMGroupIDBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err mdri_dump(GF_Box *a, FILE * trace)\n{\n\t//GF_OMADRMMutableInformationBox *ptr = (GF_OMADRMMutableInformationBox*)a;\n\tgf_isom_box_dump_start(a, \"OMADRMMutableInformationBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"OMADRMMutableInformationBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err odtt_dump(GF_Box *a, FILE * trace)\n{\n\tGF_OMADRMTransactionTrackingBox *ptr = (GF_OMADRMTransactionTrackingBox *)a;\n\tgf_isom_box_dump_start(a, \"OMADRMTransactionTrackingBox\", trace);\n\n\tfprintf(trace, \"TransactionID=\\\"\");\n\tdump_data(trace, ptr->TransactionID, 16);\n\tfprintf(trace, \"\\\">\\n\");\n\tgf_isom_box_dump_done(\"OMADRMTransactionTrackingBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err odrb_dump(GF_Box *a, FILE * trace)\n{\n\tGF_OMADRMRightsObjectBox*ptr = (GF_OMADRMRightsObjectBox*)a;\n\tgf_isom_box_dump_start(a, \"OMADRMRightsObjectBox\", trace);\n\n\tfprintf(trace, \"OMARightsObject=\\\"\");\n\tdump_data(trace, ptr->oma_ro, ptr->oma_ro_size);\n\tfprintf(trace, \"\\\">\\n\");\n\tgf_isom_box_dump_done(\"OMADRMRightsObjectBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err odkm_dump(GF_Box *a, FILE * trace)\n{\n\tGF_OMADRMKMSBox *ptr = (GF_OMADRMKMSBox*)a;\n\tgf_isom_box_dump_start(a, \"OMADRMKMSBox\", trace);\n\n\tfprintf(trace, \">\\n\");\n\tif (ptr->hdr) gf_isom_box_dump((GF_Box *)ptr->hdr, trace);\n\tif (ptr->fmt) gf_isom_box_dump((GF_Box *)ptr->fmt, trace);\n\tgf_isom_box_dump_done(\"OMADRMKMSBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err pasp_dump(GF_Box *a, FILE * trace)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox*)a;\n\tgf_isom_box_dump_start(a, \"PixelAspectRatioBox\", trace);\n\tfprintf(trace, \"hSpacing=\\\"%d\\\" vSpacing=\\\"%d\\\" >\\n\", ptr->hSpacing, ptr->vSpacing);\n\tgf_isom_box_dump_done(\"PixelAspectRatioBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err clap_dump(GF_Box *a, FILE * trace)\n{\n\tGF_CleanAppertureBox *ptr = (GF_CleanAppertureBox*)a;\n\tgf_isom_box_dump_start(a, \"CleanAppertureBox\", trace);\n\tfprintf(trace, \"cleanApertureWidthN=\\\"%d\\\" cleanApertureWidthD=\\\"%d\\\" \", ptr->cleanApertureWidthN, ptr->cleanApertureWidthD);\n\tfprintf(trace, \"cleanApertureHeightN=\\\"%d\\\" cleanApertureHeightD=\\\"%d\\\" \", ptr->cleanApertureHeightN, ptr->cleanApertureHeightD);\n\tfprintf(trace, \"horizOffN=\\\"%d\\\" horizOffD=\\\"%d\\\" \", ptr->horizOffN, ptr->horizOffD);\n\tfprintf(trace, \"vertOffN=\\\"%d\\\" vertOffD=\\\"%d\\\"\", ptr->vertOffN, ptr->vertOffD);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"CleanAppertureBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err tsel_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_TrackSelectionBox *ptr = (GF_TrackSelectionBox *)a;\n\tgf_isom_box_dump_start(a, \"TrackSelectionBox\", trace);\n\n\tfprintf(trace, \"switchGroup=\\\"%d\\\" >\\n\", ptr->switchGroup);\n\tfor (i=0; i<ptr->attributeListCount; i++) {\n\t\tfprintf(trace, \"<TrackSelectionCriteria value=\\\"%s\\\"/>\\n\", gf_4cc_to_str(ptr->attributeList[i]) );\n\t}\n\tif (!ptr->size)\n\t\tfprintf(trace, \"<TrackSelectionCriteria value=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"TrackSelectionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err metx_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)a;\n\tconst char *name;\n\tswitch (ptr->type) {\n\tcase GF_ISOM_BOX_TYPE_METX:\n\t\tname = \"XMLMetaDataSampleEntryBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_METT:\n\t\tname = \"TextMetaDataSampleEntryBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SBTT:\n\t\tname = \"SubtitleSampleEntryBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\tname = \"SimpleTextSampleEntryBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\tname = \"XMLSubtitleSampleEntryBox\";\n\t\tbreak;\n\tdefault:\n\t\tname = \"UnknownTextSampleEntryBox\";\n\t\tbreak;\n\t}\n\tgf_isom_box_dump_start(a, name, trace);\n\n\tif (ptr->type==GF_ISOM_BOX_TYPE_METX) {\n\t\tfprintf(trace, \"namespace=\\\"%s\\\" \", ptr->xml_namespace);\n\t\tif (ptr->xml_schema_loc) fprintf(trace, \"schema_location=\\\"%s\\\" \", ptr->xml_schema_loc);\n\t\tif (ptr->content_encoding) fprintf(trace, \"content_encoding=\\\"%s\\\" \", ptr->content_encoding);\n\n\t} else if (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\tfprintf(trace, \"namespace=\\\"%s\\\" \", ptr->xml_namespace);\n\t\tif (ptr->xml_schema_loc) fprintf(trace, \"schema_location=\\\"%s\\\" \", ptr->xml_schema_loc);\n\t\tif (ptr->mime_type) fprintf(trace, \"auxiliary_mime_types=\\\"%s\\\" \", ptr->mime_type);\n\t}\n\t//mett, sbtt, stxt\n\telse {\n\t\tfprintf(trace, \"mime_type=\\\"%s\\\" \", ptr->mime_type);\n\t\tif (ptr->content_encoding) fprintf(trace, \"content_encoding=\\\"%s\\\" \", ptr->content_encoding);\n\t}\n\tfprintf(trace, \">\\n\");\n\n\tif ((ptr->type!=GF_ISOM_BOX_TYPE_METX) && (ptr->type!=GF_ISOM_BOX_TYPE_STPP) ) {\n\t\tif (ptr->config) gf_isom_box_dump(ptr->config, trace);\n\t}\n\tgf_isom_box_array_dump(ptr->protections, trace);\n\n\tgf_isom_box_dump_done(name, a, trace);\n\treturn GF_OK;\n}\n\nGF_Err txtc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TextConfigBox *ptr = (GF_TextConfigBox*)a;\n\tconst char *name = \"TextConfigBox\";\n\n\tgf_isom_box_dump_start(a, name, trace);\n\tfprintf(trace, \">\\n\");\n\n\tif (ptr->config) fprintf(trace, \"<![CDATA[%s]]>\", ptr->config);\n\n\tgf_isom_box_dump_done(name, a, trace);\n\treturn GF_OK;\n}\n\nGF_Err dims_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DIMSSampleEntryBox *p = (GF_DIMSSampleEntryBox*)a;\n\tgf_isom_box_dump_start(a, \"DIMSSampleEntryBox\", trace);\n\tfprintf(trace, \"dataReferenceIndex=\\\"%d\\\">\\n\", p->dataReferenceIndex);\n\tif (p->config) gf_isom_box_dump(p->config, trace);\n\tif (p->scripts) gf_isom_box_dump(p->scripts, trace);\n\tgf_isom_box_array_dump(p->protections, trace);\n\tgf_isom_box_dump_done(\"DIMSSampleEntryBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err diST_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox*)a;\n\tgf_isom_box_dump_start(a, \"DIMSScriptTypesBox\", trace);\n\tfprintf(trace, \"types=\\\"%s\\\">\\n\", p->content_script_types);\n\tgf_isom_box_dump_done(\"DIMSScriptTypesBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err dimC_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)a;\n\tgf_isom_box_dump_start(a, \"DIMSSceneConfigBox\", trace);\n\tfprintf(trace, \"profile=\\\"%d\\\" level=\\\"%d\\\" pathComponents=\\\"%d\\\" useFullRequestHosts=\\\"%d\\\" streamType=\\\"%d\\\" containsRedundant=\\\"%d\\\" textEncoding=\\\"%s\\\" contentEncoding=\\\"%s\\\" >\\n\",\n\t        p->profile, p->level, p->pathComponents, p->fullRequestHost, p->streamType, p->containsRedundant, p->textEncoding, p->contentEncoding);\n\tgf_isom_box_dump_done(\"DIMSSceneConfigBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err dac3_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AC3ConfigBox *p = (GF_AC3ConfigBox *)a;\n\n\tif (p->cfg.is_ec3) {\n\t\tu32 i;\n\t\ta->type = GF_ISOM_BOX_TYPE_DEC3;\n\t\tgf_isom_box_dump_start(a, \"EC3SpecificBox\", trace);\n\t\ta->type = GF_ISOM_BOX_TYPE_DAC3;\n\t\tfprintf(trace, \"nb_streams=\\\"%d\\\" data_rate=\\\"%d\\\">\\n\", p->cfg.nb_streams, p->cfg.brcode);\n\t\tfor (i=0; i<p->cfg.nb_streams; i++) {\n\t\t\tfprintf(trace, \"<EC3StreamConfig fscod=\\\"%d\\\" bsid=\\\"%d\\\" bsmod=\\\"%d\\\" acmod=\\\"%d\\\" lfon=\\\"%d\\\" num_sub_dep=\\\"%d\\\" chan_loc=\\\"%d\\\"/>\\n\",\n\t\t\t        p->cfg.streams[i].fscod, p->cfg.streams[i].bsid, p->cfg.streams[i].bsmod, p->cfg.streams[i].acmod, p->cfg.streams[i].lfon, p->cfg.streams[i].nb_dep_sub, p->cfg.streams[i].chan_loc);\n\t\t}\n\t\tgf_isom_box_dump_done(\"EC3SpecificBox\", a, trace);\n\t} else {\n\t\tgf_isom_box_dump_start(a, \"AC3SpecificBox\", trace);\n\t\tfprintf(trace, \"fscod=\\\"%d\\\" bsid=\\\"%d\\\" bsmod=\\\"%d\\\" acmod=\\\"%d\\\" lfon=\\\"%d\\\" bit_rate_code=\\\"%d\\\">\\n\",\n\t\t        p->cfg.streams[0].fscod, p->cfg.streams[0].bsid, p->cfg.streams[0].bsmod, p->cfg.streams[0].acmod, p->cfg.streams[0].lfon, p->cfg.brcode);\n\t\tgf_isom_box_dump_done(\"AC3SpecificBox\", a, trace);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err lsrc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_LASERConfigurationBox *p = (GF_LASERConfigurationBox *)a;\n\tgf_isom_box_dump_start(a, \"LASeRConfigurationBox\", trace);\n\tdump_data_attribute(trace, \"LASeRHeader\", p->hdr, p->hdr_size);\n\tfprintf(trace, \">\");\n\tgf_isom_box_dump_done(\"LASeRConfigurationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err lsr1_dump(GF_Box *a, FILE * trace)\n{\n\tGF_LASeRSampleEntryBox *p = (GF_LASeRSampleEntryBox*)a;\n\tgf_isom_box_dump_start(a, \"LASeRSampleEntryBox\", trace);\n\tfprintf(trace, \"DataReferenceIndex=\\\"%d\\\">\\n\", p->dataReferenceIndex);\n\tif (p->lsr_config) gf_isom_box_dump(p->lsr_config, trace);\n\tif (p->descr) gf_isom_box_dump(p->descr, trace);\n\tgf_isom_box_dump_done(\"LASeRSampleEntryBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err sidx_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_SegmentIndexBox *p = (GF_SegmentIndexBox *)a;\n\tgf_isom_box_dump_start(a, \"SegmentIndexBox\", trace);\n\tfprintf(trace, \"reference_ID=\\\"%d\\\" timescale=\\\"%d\\\" earliest_presentation_time=\\\"\"LLD\"\\\" first_offset=\\\"\"LLD\"\\\" \", p->reference_ID, p->timescale, p->earliest_presentation_time, p->first_offset);\n\n\tfprintf(trace, \">\\n\");\n\tfor (i=0; i<p->nb_refs; i++) {\n\t\tfprintf(trace, \"<Reference type=\\\"%d\\\" size=\\\"%d\\\" duration=\\\"%d\\\" startsWithSAP=\\\"%d\\\" SAP_type=\\\"%d\\\" SAPDeltaTime=\\\"%d\\\"/>\\n\", p->refs[i].reference_type, p->refs[i].reference_size, p->refs[i].subsegment_duration, p->refs[i].starts_with_SAP, p->refs[i].SAP_type, p->refs[i].SAP_delta_time);\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<Reference type=\\\"\\\" size=\\\"\\\" duration=\\\"\\\" startsWithSAP=\\\"\\\" SAP_type=\\\"\\\" SAPDeltaTime=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SegmentIndexBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ssix_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i, j;\n\tGF_SubsegmentIndexBox *p = (GF_SubsegmentIndexBox *)a;\n\tgf_isom_box_dump_start(a, \"SubsegmentIndexBox\", trace);\n\n\tfprintf(trace, \"subsegment_count=\\\"%d\\\" >\\n\", p->subsegment_count);\n\tfor (i = 0; i < p->subsegment_count; i++) {\n\t\tfprintf(trace, \"<Subsegment range_count=\\\"%d\\\">\\n\", p->subsegments[i].range_count);\n\t\tfor (j = 0; j < p->subsegments[i].range_count; j++) {\n\t\t\tfprintf(trace, \"<Range level=\\\"%d\\\" range_size=\\\"%d\\\"/>\\n\", p->subsegments[i].levels[j], p->subsegments[i].range_sizes[j]);\n\t\t}\n\t\tfprintf(trace, \"</Subsegment>\\n\");\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<Subsegment range_count=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<Range level=\\\"\\\" range_size=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</Subsegment>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SubsegmentIndexBox\", a, trace);\n\treturn GF_OK;\n}\n\n\nGF_Err leva_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_LevelAssignmentBox *p = (GF_LevelAssignmentBox *)a;\n\tgf_isom_box_dump_start(a, \"LevelAssignmentBox\", trace);\n\n\tfprintf(trace, \"level_count=\\\"%d\\\" >\\n\", p->level_count);\n\tfor (i = 0; i < p->level_count; i++) {\n\t\tfprintf(trace, \"<Assignement track_id=\\\"%d\\\" padding_flag=\\\"%d\\\" assignement_type=\\\"%d\\\" grouping_type=\\\"%s\\\" grouping_type_parameter=\\\"%d\\\" sub_track_id=\\\"%d\\\" />\\n\", p->levels[i].track_id, p->levels[i].padding_flag, p->levels[i].type, gf_4cc_to_str(p->levels[i].grouping_type) , p->levels[i].grouping_type_parameter, p->levels[i].sub_track_id);\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<Assignement track_id=\\\"\\\" padding_flag=\\\"\\\" assignement_type=\\\"\\\" grouping_type=\\\"\\\" grouping_type_parameter=\\\"\\\" sub_track_id=\\\"\\\" />\\n\");\n\t}\n\tgf_isom_box_dump_done(\"LevelAssignmentBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err strk_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SubTrackBox *p = (GF_SubTrackBox *)a;\n\tgf_isom_box_dump_start(a, \"SubTrackBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->info) {\n\t\tgf_isom_box_dump(p->info, trace);\n\t}\n\tgf_isom_box_dump_done(\"SubTrackBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stri_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_SubTrackInformationBox *p = (GF_SubTrackInformationBox *)a;\n\tgf_isom_box_dump_start(a, \"SubTrackInformationBox\", trace);\n\n\tfprintf(trace, \"switch_group=\\\"%d\\\" alternate_group=\\\"%d\\\" sub_track_id=\\\"%d\\\">\\n\", p->switch_group, p->alternate_group, p->sub_track_id);\n\n\tfor (i = 0; i < p->attribute_count; i++) {\n\t\tfprintf(trace, \"<SubTrackInformationAttribute value=\\\"%s\\\"/>\\n\", gf_4cc_to_str(p->attribute_list[i]) );\n\t}\n\tif (!p->size)\n\t\tfprintf(trace, \"<SubTrackInformationAttribute value=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"SubTrackInformationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stsg_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_SubTrackSampleGroupBox *p = (GF_SubTrackSampleGroupBox *)a;\n\tgf_isom_box_dump_start(a, \"SubTrackSampleGroupBox\", trace);\n\n\tif (p->grouping_type)\n\t\tfprintf(trace, \"grouping_type=\\\"%s\\\"\", gf_4cc_to_str(p->grouping_type) );\n\tfprintf(trace, \">\\n\");\n\n\tfor (i = 0; i < p->nb_groups; i++) {\n\t\tfprintf(trace, \"<SubTrackSampleGroupBoxEntry group_description_index=\\\"%d\\\"/>\\n\", p->group_description_index[i]);\n\t}\n\tif (!p->size)\n\t\tfprintf(trace, \"<SubTrackSampleGroupBoxEntry group_description_index=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"SubTrackSampleGroupBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err pcrb_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_PcrInfoBox *p = (GF_PcrInfoBox *)a;\n\tgf_isom_box_dump_start(a, \"MPEG2TSPCRInfoBox\", trace);\n\tfprintf(trace, \"subsegment_count=\\\"%d\\\">\\n\", p->subsegment_count);\n\n\tfor (i=0; i<p->subsegment_count; i++) {\n\t\tfprintf(trace, \"<PCRInfo PCR=\\\"\"LLU\"\\\" />\\n\", p->pcr_values[i]);\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<PCRInfo PCR=\\\"\\\" />\\n\");\n\t}\n\tgf_isom_box_dump_done(\"MPEG2TSPCRInfoBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err subs_dump(GF_Box *a, FILE * trace)\n{\n\tu32 entry_count, i, j;\n\tu16 subsample_count;\n\tGF_SubSampleInfoEntry *pSamp;\n\tGF_SubSampleEntry *pSubSamp;\n\tGF_SubSampleInformationBox *ptr = (GF_SubSampleInformationBox *) a;\n\n\tif (!a) return GF_BAD_PARAM;\n\n\tentry_count = gf_list_count(ptr->Samples);\n\tgf_isom_box_dump_start(a, \"SubSampleInformationBox\", trace);\n\n\tfprintf(trace, \"EntryCount=\\\"%d\\\">\\n\", entry_count);\n\n\tfor (i=0; i<entry_count; i++) {\n\t\tpSamp = (GF_SubSampleInfoEntry*) gf_list_get(ptr->Samples, i);\n\n\t\tsubsample_count = gf_list_count(pSamp->SubSamples);\n\n\t\tfprintf(trace, \"<SampleEntry SampleDelta=\\\"%d\\\" SubSampleCount=\\\"%d\\\">\\n\", pSamp->sample_delta, subsample_count);\n\n\t\tfor (j=0; j<subsample_count; j++) {\n\t\t\tpSubSamp = (GF_SubSampleEntry*) gf_list_get(pSamp->SubSamples, j);\n\t\t\tfprintf(trace, \"<SubSample Size=\\\"%u\\\" Priority=\\\"%u\\\" Discardable=\\\"%d\\\" Reserved=\\\"%08X\\\"/>\\n\", pSubSamp->subsample_size, pSubSamp->subsample_priority, pSubSamp->discardable, pSubSamp->reserved);\n\t\t}\n\t\tfprintf(trace, \"</SampleEntry>\\n\");\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \"<SampleEntry SampleDelta=\\\"\\\" SubSampleCount=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<SubSample Size=\\\"\\\" Priority=\\\"\\\" Discardable=\\\"\\\" Reserved=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</SampleEntry>\\n\");\n\t}\n\n\tgf_isom_box_dump_done(\"SubSampleInformationBox\", a, trace);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err tfdt_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"TrackFragmentBaseMediaDecodeTimeBox\", trace);\n\n\tfprintf(trace, \"baseMediaDecodeTime=\\\"\"LLD\"\\\">\\n\", ptr->baseMediaDecodeTime);\n\tgf_isom_box_dump_done(\"TrackFragmentBaseMediaDecodeTimeBox\", a, trace);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\nGF_Err rvcc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_RVCConfigurationBox *ptr = (GF_RVCConfigurationBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"RVCConfigurationBox\", trace);\n\tfprintf(trace, \"predefined=\\\"%d\\\"\", ptr->predefined_rvc_config);\n\tif (! ptr->predefined_rvc_config) fprintf(trace, \" rvc_meta_idx=\\\"%d\\\"\", ptr->rvc_meta_idx);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"RVCConfigurationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err sbgp_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_SampleGroupBox *ptr = (GF_SampleGroupBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"SampleGroupBox\", trace);\n\n\tif (ptr->grouping_type)\n\t\tfprintf(trace, \"grouping_type=\\\"%s\\\"\", gf_4cc_to_str(ptr->grouping_type) );\n\n\tif (ptr->version==1) {\n\t\tif (isalnum(ptr->grouping_type_parameter&0xFF)) {\n\t\t\tfprintf(trace, \" grouping_type_parameter=\\\"%s\\\"\", gf_4cc_to_str(ptr->grouping_type_parameter) );\n\t\t} else {\n\t\t\tfprintf(trace, \" grouping_type_parameter=\\\"%d\\\"\", ptr->grouping_type_parameter);\n\t\t}\n\t}\n\tfprintf(trace, \">\\n\");\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tfprintf(trace, \"<SampleGroupBoxEntry sample_count=\\\"%d\\\" group_description_index=\\\"%d\\\"/>\\n\", ptr->sample_entries[i].sample_count, ptr->sample_entries[i].group_description_index );\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \"<SampleGroupBoxEntry sample_count=\\\"\\\" group_description_index=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SampleGroupBox\", a, trace);\n\treturn GF_OK;\n}\n\nstatic void oinf_entry_dump(GF_OperatingPointsInformation *ptr, FILE * trace)\n{\n\tu32 i, count;\n\n\tif (!ptr) {\n\t\tfprintf(trace, \"<OperatingPointsInformation scalability_mask=\\\"Multiview|Spatial scalability|Auxilary|unknown\\\" num_profile_tier_level=\\\"\\\" num_operating_points=\\\"\\\" dependency_layers=\\\"\\\">\\n\");\n\n\t\tfprintf(trace, \" <ProfileTierLevel general_profile_space=\\\"\\\" general_tier_flag=\\\"\\\" general_profile_idc=\\\"\\\" general_profile_compatibility_flags=\\\"\\\" general_constraint_indicator_flags=\\\"\\\" />\\n\");\n\n\t\tfprintf(trace, \"<OperatingPoint output_layer_set_idx=\\\"\\\" max_temporal_id=\\\"\\\" layer_count=\\\"\\\" minPicWidth=\\\"\\\" minPicHeight=\\\"\\\" maxPicWidth=\\\"\\\" maxPicHeight=\\\"\\\" maxChromaFormat=\\\"\\\" maxBitDepth=\\\"\\\" frame_rate_info_flag=\\\"\\\" bit_rate_info_flag=\\\"\\\" avgFrameRate=\\\"\\\" constantFrameRate=\\\"\\\" maxBitRate=\\\"\\\" avgBitRate=\\\"\\\"/>\\n\");\n\n\t\tfprintf(trace, \"<Layer dependent_layerID=\\\"\\\" num_layers_dependent_on=\\\"\\\" dependent_on_layerID=\\\"\\\" dimension_identifier=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</OperatingPointsInformation>\\n\");\n\t\treturn;\n\t}\n\n\n\tfprintf(trace, \"<OperatingPointsInformation\");\n\tfprintf(trace, \" scalability_mask=\\\"%u (\", ptr->scalability_mask);\n\tswitch (ptr->scalability_mask) {\n\tcase 2:\n\t\tfprintf(trace, \"Multiview\");\n\t\tbreak;\n\tcase 4:\n\t\tfprintf(trace, \"Spatial scalability\");\n\t\tbreak;\n\tcase 8:\n\t\tfprintf(trace, \"Auxilary\");\n\t\tbreak;\n\tdefault:\n\t\tfprintf(trace, \"unknown\");\n\t}\n\tfprintf(trace, \")\\\" num_profile_tier_level=\\\"%u\\\"\", gf_list_count(ptr->profile_tier_levels) );\n\tfprintf(trace, \" num_operating_points=\\\"%u\\\" dependency_layers=\\\"%u\\\"\", gf_list_count(ptr->operating_points), gf_list_count(ptr->dependency_layers));\n\tfprintf(trace, \">\\n\");\n\n\n\tcount=gf_list_count(ptr->profile_tier_levels);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_ProfileTierLevel *ptl = (LHEVC_ProfileTierLevel *)gf_list_get(ptr->profile_tier_levels, i);\n\t\tfprintf(trace, \" <ProfileTierLevel general_profile_space=\\\"%u\\\" general_tier_flag=\\\"%u\\\" general_profile_idc=\\\"%u\\\" general_profile_compatibility_flags=\\\"%X\\\" general_constraint_indicator_flags=\\\"\"LLX\"\\\" />\\n\", ptl->general_profile_space, ptl->general_tier_flag, ptl->general_profile_idc, ptl->general_profile_compatibility_flags, ptl->general_constraint_indicator_flags);\n\t}\n\n\n\tcount=gf_list_count(ptr->operating_points);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op = (LHEVC_OperatingPoint *)gf_list_get(ptr->operating_points, i);\n\t\tfprintf(trace, \"<OperatingPoint output_layer_set_idx=\\\"%u\\\"\", op->output_layer_set_idx);\n\t\tfprintf(trace, \" max_temporal_id=\\\"%u\\\" layer_count=\\\"%u\\\"\", op->max_temporal_id, op->layer_count);\n\t\tfprintf(trace, \" minPicWidth=\\\"%u\\\" minPicHeight=\\\"%u\\\"\", op->minPicWidth, op->minPicHeight);\n\t\tfprintf(trace, \" maxPicWidth=\\\"%u\\\" maxPicHeight=\\\"%u\\\"\", op->maxPicWidth, op->maxPicHeight);\n\t\tfprintf(trace, \" maxChromaFormat=\\\"%u\\\" maxBitDepth=\\\"%u\\\"\", op->maxChromaFormat, op->maxBitDepth);\n\t\tfprintf(trace, \" frame_rate_info_flag=\\\"%u\\\" bit_rate_info_flag=\\\"%u\\\"\", op->frame_rate_info_flag, op->bit_rate_info_flag);\n\t\tif (op->frame_rate_info_flag)\n\t\t\tfprintf(trace, \" avgFrameRate=\\\"%u\\\" constantFrameRate=\\\"%u\\\"\", op->avgFrameRate, op->constantFrameRate);\n\t\tif (op->bit_rate_info_flag)\n\t\t\tfprintf(trace, \" maxBitRate=\\\"%u\\\" avgBitRate=\\\"%u\\\"\", op->maxBitRate, op->avgBitRate);\n\t\tfprintf(trace, \"/>\\n\");\n\t}\n\tcount=gf_list_count(ptr->dependency_layers);\n\tfor (i = 0; i < count; i++) {\n\t\tu32 j;\n\t\tLHEVC_DependentLayer *dep = (LHEVC_DependentLayer *)gf_list_get(ptr->dependency_layers, i);\n\t\tfprintf(trace, \"<Layer dependent_layerID=\\\"%u\\\" num_layers_dependent_on=\\\"%u\\\"\", dep->dependent_layerID, dep->num_layers_dependent_on);\n\t\tif (dep->num_layers_dependent_on) {\n\t\t\tfprintf(trace, \" dependent_on_layerID=\\\"\");\n\t\t\tfor (j = 0; j < dep->num_layers_dependent_on; j++)\n\t\t\t\tfprintf(trace, \"%d \", dep->dependent_on_layerID[j]);\n\t\t\tfprintf(trace, \"\\\"\");\n\t\t}\n\t\tfprintf(trace, \" dimension_identifier=\\\"\");\n\t\tfor (j = 0; j < 16; j++)\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tfprintf(trace, \"%d \", dep->dimension_identifier[j]);\n\t\tfprintf(trace, \"\\\"/>\\n\");\n\t}\n\tfprintf(trace, \"</OperatingPointsInformation>\\n\");\n\treturn;\n}\n\nstatic void linf_dump(GF_LHVCLayerInformation *ptr, FILE * trace)\n{\n\tu32 i, count;\n\tif (!ptr) {\n\t\tfprintf(trace, \"<LayerInformation num_layers=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<LayerInfoItem layer_id=\\\"\\\" min_temporalId=\\\"\\\" max_temporalId=\\\"\\\" sub_layer_presence_flags=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</LayerInformation>\\n\");\n\t\treturn;\n\t}\n\n\tcount = gf_list_count(ptr->num_layers_in_track);\n\tfprintf(trace, \"<LayerInformation num_layers=\\\"%d\\\">\\n\", count );\n\tfor (i = 0; i < count; i++) {\n\t\tLHVCLayerInfoItem *li = (LHVCLayerInfoItem *)gf_list_get(ptr->num_layers_in_track, i);\n\t\tfprintf(trace, \"<LayerInfoItem layer_id=\\\"%d\\\" min_temporalId=\\\"%d\\\" max_temporalId=\\\"%d\\\" sub_layer_presence_flags=\\\"%d\\\"/>\\n\", li->layer_id, li->min_TemporalId, li->max_TemporalId, li->sub_layer_presence_flags);\n\t}\n\tfprintf(trace, \"</LayerInformation>\\n\");\n\treturn;\n}\n\nstatic void trif_dump(FILE * trace, char *data, u32 data_size)\n{\n\tGF_BitStream *bs;\n\tu32 id, independent, filter_disabled;\n\tBool full_picture, has_dep, tile_group;\n\n\tif (!data) {\n\t\tfprintf(trace, \"<TileRegionGroupEntry ID=\\\"\\\" tileGroup=\\\"\\\" independent=\\\"\\\" full_picture=\\\"\\\" filter_disabled=\\\"\\\" x=\\\"\\\" y=\\\"\\\" w=\\\"\\\" h=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<TileRegionDependency tileID=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</TileRegionGroupEntry>\\n\");\n\t\treturn;\n\t}\n\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tid = gf_bs_read_u16(bs);\n\ttile_group = gf_bs_read_int(bs, 1);\n\tfprintf(trace, \"<TileRegionGroupEntry ID=\\\"%d\\\" tileGroup=\\\"%d\\\" \", id, tile_group);\n\tif (tile_group) {\n\t\tindependent = gf_bs_read_int(bs, 2);\n\t\tfull_picture = (Bool)gf_bs_read_int(bs, 1);\n\t\tfilter_disabled = gf_bs_read_int(bs, 1);\n\t\thas_dep = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 2);\n\t\tfprintf(trace, \"independent=\\\"%d\\\" full_picture=\\\"%d\\\" filter_disabled=\\\"%d\\\" \", independent, full_picture, filter_disabled);\n\n\t\tif (!full_picture) {\n\t\t\tfprintf(trace, \"x=\\\"%d\\\" y=\\\"%d\\\" \", gf_bs_read_u16(bs), gf_bs_read_u16(bs));\n\t\t}\n\t\tfprintf(trace, \"w=\\\"%d\\\" h=\\\"%d\\\" \", gf_bs_read_u16(bs), gf_bs_read_u16(bs));\n\t\tif (!has_dep) {\n\t\t\tfprintf(trace, \"/>\\n\");\n\t\t} else {\n\t\t\tu32 count = gf_bs_read_u16(bs);\n\t\t\tfprintf(trace, \">\\n\");\n\t\t\twhile (count) {\n\t\t\t\tcount--;\n\t\t\t\tfprintf(trace, \"<TileRegionDependency tileID=\\\"%d\\\"/>\\n\", gf_bs_read_u16(bs) );\n\t\t\t}\n\t\t\tfprintf(trace, \"</TileRegionGroupEntry>\\n\");\n\t\t}\n\t}\n\tgf_bs_del(bs);\n}\n\nstatic void nalm_dump(FILE * trace, char *data, u32 data_size)\n{\n\tGF_BitStream *bs;\n\n\tBool rle, large_size;\n\tu32 entry_count;\n\n\tif (!data) {\n\t\tfprintf(trace, \"<NALUMap rle=\\\"\\\" large_size=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<NALUMapEntry NALU_startNumber=\\\"\\\" groupID=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</NALUMap>\\n\");\n\t\treturn;\n\t}\n\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tgf_bs_read_int(bs, 6);\n\tlarge_size = gf_bs_read_int(bs, 1);\n\trle = gf_bs_read_int(bs, 1);\n\tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n\tfprintf(trace, \"<NALUMap rle=\\\"%d\\\" large_size=\\\"%d\\\">\\n\", rle, large_size);\n\n\twhile (entry_count) {\n\t\tu32 ID;\n\t\tfprintf(trace, \"<NALUMapEntry \");\n\t\tif (rle) {\n\t\t\tu32 start_num = gf_bs_read_int(bs, large_size ? 16 : 8);\n\t\t\tfprintf(trace, \"NALU_startNumber=\\\"%d\\\" \", start_num);\n\t\t}\n\t\tID = gf_bs_read_u16(bs);\n\t\tfprintf(trace, \"groupID=\\\"%d\\\"/>\\n\", ID);\n\t\tentry_count--;\n\t}\n\tgf_bs_del(bs);\n\tfprintf(trace, \"</NALUMap>\\n\");\n\treturn;\n}\n\n\nGF_Err sgpd_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_SampleGroupDescriptionBox *ptr = (GF_SampleGroupDescriptionBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"SampleGroupDescriptionBox\", trace);\n\n\tif (ptr->grouping_type)\n\t\tfprintf(trace, \"grouping_type=\\\"%s\\\"\", gf_4cc_to_str(ptr->grouping_type) );\n\tif (ptr->version==1) fprintf(trace, \" default_length=\\\"%d\\\"\", ptr->default_length);\n\tif ((ptr->version>=2) && ptr->default_description_index) fprintf(trace, \" default_group_index=\\\"%d\\\"\", ptr->default_description_index);\n\tfprintf(trace, \">\\n\");\n\tfor (i=0; i<gf_list_count(ptr->group_descriptions); i++) {\n\t\tvoid *entry = gf_list_get(ptr->group_descriptions, i);\n\t\tswitch (ptr->grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\t\tfprintf(trace, \"<RollRecoveryEntry roll_distance=\\\"%d\\\" />\\n\", ((GF_RollRecoveryEntry*)entry)->roll_distance );\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\t\tfprintf(trace, \"<AudioPreRollEntry roll_distance=\\\"%d\\\" />\\n\", ((GF_RollRecoveryEntry*)entry)->roll_distance );\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t\t\tfprintf(trace, \"<TemporalLevelEntry level_independently_decodable=\\\"%d\\\"/>\\n\", ((GF_TemporalLevelEntry*)entry)->level_independently_decodable);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\t\tfprintf(trace, \"<VisualRandomAccessEntry num_leading_samples_known=\\\"%s\\\"\", ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples_known ? \"yes\" : \"no\");\n\t\t\tif (((GF_VisualRandomAccessEntry*)entry)->num_leading_samples_known)\n\t\t\t\tfprintf(trace, \" num_leading_samples=\\\"%d\\\"\", ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples);\n\t\t\tfprintf(trace, \"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\tfprintf(trace, \"<SyncSampleGroupEntry NAL_unit_type=\\\"%d\\\"/>\\n\", ((GF_SYNCEntry*)entry)->NALU_type);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t\t\tfprintf(trace, \"<CENCSampleEncryptionGroupEntry IsEncrypted=\\\"%d\\\" IV_size=\\\"%d\\\" KID=\\\"\", ((GF_CENCSampleEncryptionGroupEntry*)entry)->IsProtected, ((GF_CENCSampleEncryptionGroupEntry*)entry)->Per_Sample_IV_size);\n\t\t\tdump_data_hex(trace, (char *)((GF_CENCSampleEncryptionGroupEntry*)entry)->KID, 16);\n\t\t\tif ((((GF_CENCSampleEncryptionGroupEntry*)entry)->IsProtected == 1) && !((GF_CENCSampleEncryptionGroupEntry*)entry)->Per_Sample_IV_size) {\n\t\t\t\tfprintf(trace, \"\\\" constant_IV_size=\\\"%d\\\"  constant_IV=\\\"\", ((GF_CENCSampleEncryptionGroupEntry*)entry)->constant_IV_size);\n\t\t\t\tdump_data_hex(trace, (char *)((GF_CENCSampleEncryptionGroupEntry*)entry)->constant_IV, ((GF_CENCSampleEncryptionGroupEntry*)entry)->constant_IV_size);\n\t\t\t}\n\t\t\tfprintf(trace, \"\\\"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\t\toinf_entry_dump(entry, trace);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\t\tlinf_dump(entry, trace);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n\t\t\ttrif_dump(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n\t\t\tnalm_dump(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\t\tfprintf(trace, \"<SAPEntry dependent_flag=\\\"%d\\\" SAP_type=\\\"%d\\\" />\\n\", ((GF_SAPEntry*)entry)->dependent_flag, ((GF_SAPEntry*)entry)->SAP_type);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(trace, \"<DefaultSampleGroupDescriptionEntry size=\\\"%d\\\" data=\\\"\", ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n\t\t\tdump_data(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n\t\t\tfprintf(trace, \"\\\"/>\\n\");\n\t\t}\n\t}\n\tif (!ptr->size) {\n\t\tswitch (ptr->grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\t\tfprintf(trace, \"<RollRecoveryEntry roll_distance=\\\"\\\"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\t\tfprintf(trace, \"<AudioPreRollEntry roll_distance=\\\"\\\"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t\t\tfprintf(trace, \"<TemporalLevelEntry level_independently_decodable=\\\"\\\"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\t\tfprintf(trace, \"<VisualRandomAccessEntry num_leading_samples_known=\\\"yes|no\\\" num_leading_samples=\\\"\\\" />\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\tfprintf(trace, \"<SyncSampleGroupEntry NAL_unit_type=\\\"\\\" />\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t\t\tfprintf(trace, \"<CENCSampleEncryptionGroupEntry IsEncrypted=\\\"\\\" IV_size=\\\"\\\" KID=\\\"\\\" constant_IV_size=\\\"\\\"  constant_IV=\\\"\\\"/>\\n\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t\t\toinf_entry_dump(NULL, trace);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\t\tlinf_dump(NULL, trace);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n\t\t\ttrif_dump(trace, NULL, 0);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n\t\t\tnalm_dump(trace, NULL, 0);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t\t\tfprintf(trace, \"<SAPEntry dependent_flag=\\\"\\\" SAP_type=\\\"\\\" />\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(trace, \"<DefaultSampleGroupDescriptionEntry size=\\\"\\\" data=\\\"\\\"/>\\n\");\n\t\t}\n\t}\n\n\tgf_isom_box_dump_done(\"SampleGroupDescriptionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err saiz_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_SampleAuxiliaryInfoSizeBox *ptr = (GF_SampleAuxiliaryInfoSizeBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"SampleAuxiliaryInfoSizeBox\", trace);\n\n\tfprintf(trace, \"default_sample_info_size=\\\"%d\\\" sample_count=\\\"%d\\\"\", ptr->default_sample_info_size, ptr->sample_count);\n\tif (ptr->flags & 1) {\n\t\tif (isalnum(ptr->aux_info_type>>24)) {\n\t\t\tfprintf(trace, \" aux_info_type=\\\"%s\\\" aux_info_type_parameter=\\\"%d\\\"\", gf_4cc_to_str(ptr->aux_info_type), ptr->aux_info_type_parameter);\n\t\t} else {\n\t\t\tfprintf(trace, \" aux_info_type=\\\"%d\\\" aux_info_type_parameter=\\\"%d\\\"\", ptr->aux_info_type, ptr->aux_info_type_parameter);\n\t\t}\n\t}\n\tfprintf(trace, \">\\n\");\n\tif (ptr->default_sample_info_size==0) {\n\t\tfor (i=0; i<ptr->sample_count; i++) {\n\t\t\tfprintf(trace, \"<SAISize size=\\\"%d\\\" />\\n\", ptr->sample_info_size[i]);\n\t\t}\n\t}\n\tif (!ptr->size) {\n\t\t\tfprintf(trace, \"<SAISize size=\\\"\\\" />\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SampleAuxiliaryInfoSizeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err saio_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_SampleAuxiliaryInfoOffsetBox *ptr = (GF_SampleAuxiliaryInfoOffsetBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"SampleAuxiliaryInfoOffsetBox\", trace);\n\n\tfprintf(trace, \"entry_count=\\\"%d\\\"\", ptr->entry_count);\n\tif (ptr->flags & 1) {\n\t\tif (isalnum(ptr->aux_info_type>>24)) {\n\t\t\tfprintf(trace, \" aux_info_type=\\\"%s\\\" aux_info_type_parameter=\\\"%d\\\"\", gf_4cc_to_str(ptr->aux_info_type), ptr->aux_info_type_parameter);\n\t\t} else {\n\t\t\tfprintf(trace, \" aux_info_type=\\\"%d\\\" aux_info_type_parameter=\\\"%d\\\"\", ptr->aux_info_type, ptr->aux_info_type_parameter);\n\t\t}\n\t}\n\n\tfprintf(trace, \">\\n\");\n\n\tif (ptr->version==0) {\n\t\tfor (i=0; i<ptr->entry_count; i++) {\n\t\t\tfprintf(trace, \"<SAIChunkOffset offset=\\\"%d\\\"/>\\n\", ptr->offsets[i]);\n\t\t}\n\t} else {\n\t\tfor (i=0; i<ptr->entry_count; i++) {\n\t\t\tfprintf(trace, \"<SAIChunkOffset offset=\\\"\"LLD\"\\\"/>\\n\", ptr->offsets_large[i]);\n\t\t}\n\t}\n\tif (!ptr->size) {\n\t\t\tfprintf(trace, \"<SAIChunkOffset offset=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SampleAuxiliaryInfoOffsetBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err pssh_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ProtectionSystemHeaderBox *ptr = (GF_ProtectionSystemHeaderBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"ProtectionSystemHeaderBox\", trace);\n\n\tfprintf(trace, \"SystemID=\\\"\");\n\tdump_data_hex(trace, (char *) ptr->SystemID, 16);\n\tfprintf(trace, \"\\\">\\n\");\n\n\tif (ptr->KID_count) {\n\t\tu32 i;\n\t\tfor (i=0; i<ptr->KID_count; i++) {\n\t\t\tfprintf(trace, \" <PSSHKey KID=\\\"\");\n\t\t\tdump_data_hex(trace, (char *) ptr->KIDs[i], 16);\n\t\t\tfprintf(trace, \"\\\"/>\\n\");\n\t\t}\n\t}\n\tif (ptr->private_data_size) {\n\t\tfprintf(trace, \" <PSSHData size=\\\"%d\\\" value=\\\"\", ptr->private_data_size);\n\t\tdump_data_hex(trace, (char *) ptr->private_data, ptr->private_data_size);\n\t\tfprintf(trace, \"\\\"/>\\n\");\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \" <PSSHKey KID=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \" <PSSHData size=\\\"\\\" value=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"ProtectionSystemHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err tenc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"TrackEncryptionBox\", trace);\n\n\tfprintf(trace, \"isEncrypted=\\\"%d\\\"\", ptr->isProtected);\n\tif (ptr->Per_Sample_IV_Size)\n\t\tfprintf(trace, \" IV_size=\\\"%d\\\" KID=\\\"\", ptr->Per_Sample_IV_Size);\n\telse {\n\t\tfprintf(trace, \" constant_IV_size=\\\"%d\\\" constant_IV=\\\"\", ptr->constant_IV_size);\n\t\tdump_data_hex(trace, (char *) ptr->constant_IV, ptr->constant_IV_size);\n\t\tfprintf(trace, \"\\\"  KID=\\\"\");\n\t}\n\tdump_data_hex(trace, (char *) ptr->KID, 16);\n\tif (ptr->version)\n\t\tfprintf(trace, \"\\\" crypt_byte_block=\\\"%d\\\" skip_byte_block=\\\"%d\", ptr->crypt_byte_block, ptr->skip_byte_block);\n\tfprintf(trace, \"\\\">\\n\");\n\tgf_isom_box_dump_done(\"TrackEncryptionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err piff_pssh_dump(GF_Box *a, FILE * trace)\n{\n\tGF_PIFFProtectionSystemHeaderBox *ptr = (GF_PIFFProtectionSystemHeaderBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"PIFFProtectionSystemHeaderBox\", trace);\n\n\tfprintf(trace, \"SystemID=\\\"\");\n\tdump_data_hex(trace, (char *) ptr->SystemID, 16);\n\tfprintf(trace, \"\\\" PrivateData=\\\"\");\n\tdump_data_hex(trace, (char *) ptr->private_data, ptr->private_data_size);\n\tfprintf(trace, \"\\\">\\n\");\n\tgf_isom_box_dump_done(\"PIFFProtectionSystemHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err piff_tenc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_PIFFTrackEncryptionBox *ptr = (GF_PIFFTrackEncryptionBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"PIFFTrackEncryptionBox\", trace);\n\n\tfprintf(trace, \"AlgorithmID=\\\"%d\\\" IV_size=\\\"%d\\\" KID=\\\"\", ptr->AlgorithmID, ptr->IV_size);\n\tdump_data_hex(trace,(char *) ptr->KID, 16);\n\tfprintf(trace, \"\\\">\\n\");\n\tgf_isom_box_dump_done(\"PIFFTrackEncryptionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err piff_psec_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i, j, sample_count;\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox *) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"PIFFSampleEncryptionBox\", trace);\n\tsample_count = gf_list_count(ptr->samp_aux_info);\n\tfprintf(trace, \"sampleCount=\\\"%d\\\"\", sample_count);\n\tif (ptr->flags & 1) {\n\t\tfprintf(trace, \" AlgorithmID=\\\"%d\\\" IV_size=\\\"%d\\\" KID=\\\"\", ptr->AlgorithmID, ptr->IV_size);\n\t\tdump_data(trace, (char *) ptr->KID, 16);\n\t\tfprintf(trace, \"\\\"\");\n\t}\n\tfprintf(trace, \">\\n\");\n\n\tif (sample_count) {\n\t\tfor (i=0; i<sample_count; i++) {\n\t\t\tGF_CENCSampleAuxInfo *cenc_sample = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, i);\n\n\t\t\tif (cenc_sample) {\n\t\t\t\tif  (!strlen((char *)cenc_sample->IV)) continue;\n\t\t\t\tfprintf(trace, \"<PIFFSampleEncryptionEntry IV_size=\\\"%u\\\" IV=\\\"\", cenc_sample->IV_size);\n\t\t\t\tdump_data_hex(trace, (char *) cenc_sample->IV, cenc_sample->IV_size);\n\t\t\t\tif (ptr->flags & 0x2) {\n\t\t\t\t\tfprintf(trace, \"\\\" SubsampleCount=\\\"%d\\\"\", cenc_sample->subsample_count);\n\t\t\t\t\tfprintf(trace, \">\\n\");\n\n\t\t\t\t\tfor (j=0; j<cenc_sample->subsample_count; j++) {\n\t\t\t\t\t\tfprintf(trace, \"<PIFFSubSampleEncryptionEntry NumClearBytes=\\\"%d\\\" NumEncryptedBytes=\\\"%d\\\"/>\\n\", cenc_sample->subsamples[j].bytes_clear_data, cenc_sample->subsamples[j].bytes_encrypted_data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfprintf(trace, \"</PIFFSampleEncryptionEntry>\\n\");\n\t\t\t}\n\t\t}\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \"<PIFFSampleEncryptionEntry IV=\\\"\\\" SubsampleCount=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<PIFFSubSampleEncryptionEntry NumClearBytes=\\\"\\\" NumEncryptedBytes=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</PIFFSampleEncryptionEntry>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"PIFFSampleEncryptionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err senc_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i, j, sample_count;\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox *) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"SampleEncryptionBox\", trace);\n\tsample_count = gf_list_count(ptr->samp_aux_info);\n\tfprintf(trace, \"sampleCount=\\\"%d\\\">\\n\", sample_count);\n\t//WARNING - PSEC (UUID) IS TYPECASTED TO SENC (FULL BOX) SO WE CANNOT USE USUAL FULL BOX FUNCTIONS\n\tfprintf(trace, \"<FullBoxInfo Version=\\\"%d\\\" Flags=\\\"0x%X\\\"/>\\n\", ptr->version, ptr->flags);\n\tfor (i=0; i<sample_count; i++) {\n\t\tGF_CENCSampleAuxInfo *cenc_sample = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, i);\n\n\t\tif (cenc_sample) {\n\t\t\tfprintf(trace, \"<SampleEncryptionEntry sampleNumber=\\\"%d\\\" IV_size=\\\"%u\\\" IV=\\\"\", i+1, cenc_sample->IV_size);\n\t\t\tdump_data_hex(trace, (char *) cenc_sample->IV, cenc_sample->IV_size);\n\t\t\tfprintf(trace, \"\\\"\");\n\t\t\tif (ptr->flags & 0x2) {\n\t\t\t\tfprintf(trace, \" SubsampleCount=\\\"%d\\\"\", cenc_sample->subsample_count);\n\t\t\t\tfprintf(trace, \">\\n\");\n\n\t\t\t\tfor (j=0; j<cenc_sample->subsample_count; j++) {\n\t\t\t\t\tfprintf(trace, \"<SubSampleEncryptionEntry NumClearBytes=\\\"%d\\\" NumEncryptedBytes=\\\"%d\\\"/>\\n\", cenc_sample->subsamples[j].bytes_clear_data, cenc_sample->subsamples[j].bytes_encrypted_data);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf(trace, \">\\n\");\n\t\t\t}\n\t\t\tfprintf(trace, \"</SampleEncryptionEntry>\\n\");\n\t\t}\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \"<SampleEncryptionEntry sampleCount=\\\"\\\" IV=\\\"\\\" SubsampleCount=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<SubSampleEncryptionEntry NumClearBytes=\\\"\\\" NumEncryptedBytes=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</SampleEncryptionEntry>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SampleEncryptionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err prft_dump(GF_Box *a, FILE * trace)\n{\n\tDouble fracs;\n\tGF_ProducerReferenceTimeBox *ptr = (GF_ProducerReferenceTimeBox *) a;\n\ttime_t secs;\n\tstruct tm t;\n\tsecs = (ptr->ntp >> 32) - GF_NTP_SEC_1900_TO_1970;\n\tif (secs < 0) {\n\t\tif (ptr->size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"NTP time is not valid, using value 0\\n\"));\n\t\t}\n\t\tsecs = 0;\n\t}\n\tt = *gmtime(&secs);\n\tfracs = (Double) (ptr->ntp & 0xFFFFFFFFULL);\n\tfracs /= 0xFFFFFFFF;\n\tfracs *= 1000;\n\tgf_isom_box_dump_start(a, \"ProducerReferenceTimeBox\", trace);\n\n\tfprintf(trace, \"referenceTrackID=\\\"%d\\\" timestamp=\\\"\"LLU\"\\\" NTP=\\\"\"LLU\"\\\" UTC=\\\"%d-%02d-%02dT%02d:%02d:%02d.%03dZ\\\">\\n\", ptr->refTrackID, ptr->timestamp, ptr->ntp, 1900+t.tm_year, t.tm_mon+1, t.tm_mday, t.tm_hour, t.tm_min, (u32) t.tm_sec, (u32) fracs);\n\tgf_isom_box_dump_done(\"ProducerReferenceTimeBox\", a, trace);\n\n\treturn GF_OK;\n}\n\nGF_Err adkm_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AdobeDRMKeyManagementSystemBox *ptr = (GF_AdobeDRMKeyManagementSystemBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"AdobeDRMKeyManagementSystemBox\", trace);\n\n\tfprintf(trace, \">\\n\");\n\tif (ptr->header) gf_isom_box_dump((GF_Box *)ptr->header, trace);\n\tif (ptr->au_format) gf_isom_box_dump((GF_Box *)ptr->au_format, trace);\n\tgf_isom_box_dump_done(\"AdobeDRMKeyManagementSystemBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ahdr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AdobeDRMHeaderBox *ptr = (GF_AdobeDRMHeaderBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"AdobeDRMHeaderBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (ptr->std_enc_params) gf_isom_box_dump((GF_Box *)ptr->std_enc_params, trace);\n\tgf_isom_box_dump_done(\"AdobeDRMHeaderBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err aprm_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AdobeStdEncryptionParamsBox *ptr = (GF_AdobeStdEncryptionParamsBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"AdobeStdEncryptionParamsBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (ptr->enc_info) gf_isom_box_dump((GF_Box *)ptr->enc_info, trace);\n\tif (ptr->key_info) gf_isom_box_dump((GF_Box *)ptr->key_info, trace);\n\tgf_isom_box_dump_done(\"AdobeStdEncryptionParamsBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err aeib_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AdobeEncryptionInfoBox *ptr = (GF_AdobeEncryptionInfoBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"AdobeEncryptionInfoBox\", trace);\n\tfprintf(trace, \"EncryptionAlgorithm=\\\"%s\\\" KeyLength=\\\"%d\\\">\\n\", ptr->enc_algo, ptr->key_length);\n\tgf_isom_box_dump_done(\"AdobeEncryptionInfoBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err akey_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AdobeKeyInfoBox *ptr = (GF_AdobeKeyInfoBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"AdobeKeyInfoBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (ptr->params) gf_isom_box_dump((GF_Box *)ptr->params, trace);\n\tgf_isom_box_dump_done(\"AdobeKeyInfoBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err flxs_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AdobeFlashAccessParamsBox *ptr = (GF_AdobeFlashAccessParamsBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"AdobeFlashAccessParamsBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (ptr->metadata)\n\t\tfprintf(trace, \"<FmrmsV2Metadata=\\\"%s\\\"/>\\n\", ptr->metadata);\n\tgf_isom_box_dump_done(\"AdobeFlashAccessParamsBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err adaf_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AdobeDRMAUFormatBox *ptr = (GF_AdobeDRMAUFormatBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"AdobeDRMAUFormatBox \", trace);\n\tfprintf(trace, \"SelectiveEncryption=\\\"%d\\\" IV_length=\\\"%d\\\">\\n\", ptr->selective_enc ? 1 : 0, ptr->IV_length);\n\tgf_isom_box_dump_done(\"AdobeDRMAUFormatBox\", a, trace);\n\treturn GF_OK;\n}\n\n/* Image File Format dump */\nGF_Err ispe_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ImageSpatialExtentsPropertyBox *ptr = (GF_ImageSpatialExtentsPropertyBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"ImageSpatialExtentsPropertyBox\", trace);\n\tfprintf(trace, \"image_width=\\\"%d\\\" image_height=\\\"%d\\\">\\n\", ptr->image_width, ptr->image_height);\n\tgf_isom_box_dump_done(\"ImageSpatialExtentsPropertyBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err colr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ColourInformationBox *ptr = (GF_ColourInformationBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"ColourInformationBox\", trace);\n\tfprintf(trace, \"colour_type=\\\"%s\\\" colour_primaries=\\\"%d\\\" transfer_characteristics=\\\"%d\\\" matrix_coefficients=\\\"%d\\\" full_range_flag=\\\"%d\\\">\\n\", gf_4cc_to_str(ptr->colour_type), ptr->colour_primaries, ptr->transfer_characteristics, ptr->matrix_coefficients, ptr->full_range_flag);\n\tgf_isom_box_dump_done(\"ColourInformationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err pixi_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_PixelInformationPropertyBox *ptr = (GF_PixelInformationPropertyBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"PixelInformationPropertyBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tfor (i = 0; i < ptr->num_channels; i++) {\n\t\tfprintf(trace, \"<BitPerChannel bits_per_channel=\\\"%d\\\"/>\\n\", ptr->bits_per_channel[i]);\n\t}\n\tif (!ptr->size)\n\t\tfprintf(trace, \"<BitPerChannel bits_per_channel=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"PixelInformationPropertyBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err rloc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_RelativeLocationPropertyBox *ptr = (GF_RelativeLocationPropertyBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"RelativeLocationPropertyBox\", trace);\n\tfprintf(trace, \"horizontal_offset=\\\"%d\\\" vertical_offset=\\\"%d\\\">\\n\", ptr->horizontal_offset, ptr->vertical_offset);\n\tgf_isom_box_dump_done(\"RelativeLocationPropertyBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err irot_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ImageRotationBox *ptr = (GF_ImageRotationBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"ImageRotationBox\", trace);\n\tfprintf(trace, \"angle=\\\"%d\\\">\\n\", (ptr->angle*90));\n\tgf_isom_box_dump_done(\"ImageRotationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ipco_dump(GF_Box *a, FILE * trace)\n{\n\tgf_isom_box_dump_start(a, \"ItemPropertyContainerBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"ItemPropertyContainerBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err iprp_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ItemPropertiesBox *ptr = (GF_ItemPropertiesBox *)a;\n\tgf_isom_box_dump_start(a, \"ItemPropertiesBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (ptr->property_container) gf_isom_box_dump(ptr->property_container, trace);\n\tif (ptr->property_association) gf_isom_box_dump(ptr->property_association, trace);\n\tgf_isom_box_dump_done(\"ItemPropertiesBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ipma_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i, j;\n\tGF_ItemPropertyAssociationBox *ptr = (GF_ItemPropertyAssociationBox *)a;\n\tu32 entry_count = gf_list_count(ptr->entries);\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"ItemPropertyAssociationBox\", trace);\n\tfprintf(trace, \"entry_count=\\\"%d\\\">\\n\", entry_count);\n\tfor (i = 0; i < entry_count; i++) {\n\t\tGF_ItemPropertyAssociationEntry *entry = (GF_ItemPropertyAssociationEntry *)gf_list_get(ptr->entries, i);\n\t\tu32 association_count = gf_list_count(entry->essential);\n\t\tfprintf(trace, \"<AssociationEntry item_ID=\\\"%d\\\" association_count=\\\"%d\\\">\\n\", entry->item_id, association_count);\n\t\tfor (j = 0; j < association_count; j++) {\n\t\t\tBool *ess = (Bool *)gf_list_get(entry->essential, j);\n\t\t\tu32 *prop_index = (u32 *)gf_list_get(entry->property_index, j);\n\t\t\tfprintf(trace, \"<Property index=\\\"%d\\\" essential=\\\"%d\\\"/>\\n\", *prop_index, *ess);\n\t\t}\n\t\tfprintf(trace, \"</AssociationEntry>\\n\");\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \"<AssociationEntry item_ID=\\\"\\\" association_count=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<Property index=\\\"\\\" essential=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</AssociationEntry>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"ItemPropertyAssociationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err auxc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AuxiliaryTypePropertyBox *ptr = (GF_AuxiliaryTypePropertyBox *)a;\n\n\tgf_isom_box_dump_start(a, \"AuxiliaryTypePropertyBox\", trace);\n\tfprintf(trace, \"aux_type=\\\"%s\\\" \", ptr->aux_urn);\n\tdump_data_attribute(trace, \"aux_subtype\", ptr->data, ptr->data_size);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"AuxiliaryTypePropertyBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err oinf_dump(GF_Box *a, FILE * trace)\n{\n\tGF_OINFPropertyBox *ptr = (GF_OINFPropertyBox *)a;\n\tgf_isom_box_dump_start(a, \"OperatingPointsInformationPropertyBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\toinf_entry_dump(ptr->oinf, trace);\n\n\tgf_isom_box_dump_done(\"OperatingPointsInformationPropertyBox\", a, trace);\n\treturn GF_OK;\n}\nGF_Err tols_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TargetOLSPropertyBox *ptr = (GF_TargetOLSPropertyBox *)a;\n\tgf_isom_box_dump_start(a, \"TargetOLSPropertyBox\", trace);\n\tfprintf(trace, \"target_ols_index=\\\"%d\\\">\\n\", ptr->target_ols_index);\n\n\tgf_isom_box_dump_done(\"TargetOLSPropertyBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err trgr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackGroupBox *ptr = (GF_TrackGroupBox *) a;\n\tgf_isom_box_dump_start(a, \"TrackGroupBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_array_dump(ptr->groups, trace);\n\tgf_isom_box_dump_done(\"TrackGroupBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err trgt_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *) a;\n\ta->type = ptr->group_type;\n\tgf_isom_box_dump_start(a, \"TrackGroupTypeBox\", trace);\n\ta->type = GF_ISOM_BOX_TYPE_TRGT;\n\tfprintf(trace, \"track_group_id=\\\"%d\\\">\\n\", ptr->track_group_id);\n\tgf_isom_box_dump_done(\"TrackGroupTypeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err grpl_dump(GF_Box *a, FILE * trace)\n{\n\tgf_isom_box_dump_start(a, \"GroupListBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"GroupListBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err grptype_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_EntityToGroupTypeBox *ptr = (GF_EntityToGroupTypeBox *) a;\n\ta->type = ptr->grouping_type;\n\tgf_isom_box_dump_start(a, \"EntityToGroupTypeBox\", trace);\n\ta->type = GF_ISOM_BOX_TYPE_GRPT;\n\tfprintf(trace, \"group_id=\\\"%d\\\">\\n\", ptr->group_id);\n\n\tfor (i=0; i<ptr->entity_id_count ; i++)\n\t\tfprintf(trace, \"<EntityToGroupTypeBoxEntry EntityID=\\\"%d\\\"/>\\n\", ptr->entity_ids[i]);\n\n\tif (!ptr->size)\n\t\tfprintf(trace, \"<EntityToGroupTypeBoxEntry EntityID=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"EntityToGroupTypeBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err stvi_dump(GF_Box *a, FILE * trace)\n{\n\tGF_StereoVideoBox *ptr = (GF_StereoVideoBox *) a;\n\tgf_isom_box_dump_start(a, \"StereoVideoBox\", trace);\n\n\tfprintf(trace, \"single_view_allowed=\\\"%d\\\" stereo_scheme=\\\"%d\\\" \", ptr->single_view_allowed, ptr->stereo_scheme);\n\tdump_data_attribute(trace, \"stereo_indication_type\", ptr->stereo_indication_type, ptr->sit_len);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"StereoVideoBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err def_cont_box_dump(GF_Box *a, FILE *trace)\n{\n\tchar *name = \"SubTrackDefinitionBox\"; //only one using generic box container for now\n\tgf_isom_box_dump_start(a, name, trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(name, a, trace);\n\treturn GF_OK;\n}\n\nGF_Err fiin_dump(GF_Box *a, FILE * trace)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *) a;\n\tgf_isom_box_dump_start(a, \"FDItemInformationBox\", trace);\n\n\tfprintf(trace, \">\\n\");\n\tif (ptr->partition_entries)\n\t\tgf_isom_box_array_dump(ptr->partition_entries, trace);\n\n\tif (ptr->session_info)\n\t\tgf_isom_box_dump(ptr->session_info, trace);\n\n\tif (ptr->group_id_to_name)\n\t\tgf_isom_box_dump(ptr->group_id_to_name, trace);\n\n\tgf_isom_box_dump_done(\"FDItemInformationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err fecr_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tchar *box_name;\n\tFECReservoirBox *ptr = (FECReservoirBox *) a;\n\tif (a->type==GF_ISOM_BOX_TYPE_FIRE) {\n\t\tbox_name = \"FILEReservoirBox\";\n\t} else {\n\t\tbox_name = \"FECReservoirBox\";\n\t}\n\tgf_isom_box_dump_start(a, box_name, trace);\n\n\tfprintf(trace, \">\\n\");\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tfprintf(trace, \"<%sEntry itemID=\\\"%d\\\" symbol_count=\\\"%d\\\"/>\\n\", box_name, ptr->entries[i].item_id, ptr->entries[i].symbol_count);\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \"<%sEntry itemID=\\\"\\\" symbol_count=\\\"\\\"/>\\n\", box_name);\n\t}\n\tgf_isom_box_dump_done(box_name, a, trace);\n\treturn GF_OK;\n}\n\nGF_Err gitn_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *) a;\n\tgf_isom_box_dump_start(a, \"GroupIdToNameBox\", trace);\n\n\tfprintf(trace, \">\\n\");\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tfprintf(trace, \"<GroupIdToNameBoxEntry groupID=\\\"%d\\\" name=\\\"%s\\\"/>\\n\", ptr->entries[i].group_id, ptr->entries[i].name);\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \"<GroupIdToNameBoxEntryEntry groupID=\\\"\\\" name=\\\"\\\"/>\\n\");\n\t}\n\n\tgf_isom_box_dump_done(\"GroupIdToNameBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err paen_dump(GF_Box *a, FILE * trace)\n{\n\tFDPartitionEntryBox *ptr = (FDPartitionEntryBox *) a;\n\tgf_isom_box_dump_start(a, \"FDPartitionEntryBox\", trace);\n\n\tfprintf(trace, \">\\n\");\n\tif (ptr->blocks_and_symbols)\n\t\tgf_isom_box_dump(ptr->blocks_and_symbols, trace);\n\n\tif (ptr->FEC_symbol_locations)\n\t\tgf_isom_box_dump(ptr->FEC_symbol_locations, trace);\n\n\tif (ptr->FEC_symbol_locations)\n\t\tgf_isom_box_dump(ptr->FEC_symbol_locations, trace);\n\n\tgf_isom_box_dump_done(\"FDPartitionEntryBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err fpar_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tFilePartitionBox *ptr = (FilePartitionBox *) a;\n\tgf_isom_box_dump_start(a, \"FilePartitionBox\", trace);\n\n\tfprintf(trace, \"itemID=\\\"%d\\\" FEC_encoding_ID=\\\"%d\\\" FEC_instance_ID=\\\"%d\\\" max_source_block_length=\\\"%d\\\" encoding_symbol_length=\\\"%d\\\" max_number_of_encoding_symbols=\\\"%d\\\" \", ptr->itemID, ptr->FEC_encoding_ID, ptr->FEC_instance_ID, ptr->max_source_block_length, ptr->encoding_symbol_length, ptr->max_number_of_encoding_symbols);\n\n\tif (ptr->scheme_specific_info)\n\t\tdump_data_attribute(trace, \"scheme_specific_info\", (char*)ptr->scheme_specific_info, (u32)strlen(ptr->scheme_specific_info) );\n\n\tfprintf(trace, \">\\n\");\n\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tfprintf(trace, \"<FilePartitionBoxEntry block_count=\\\"%d\\\" block_size=\\\"%d\\\"/>\\n\", ptr->entries[i].block_count, ptr->entries[i].block_size);\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \"<FilePartitionBoxEntry block_count=\\\"\\\" block_size=\\\"\\\"/>\\n\");\n\t}\n\n\tgf_isom_box_dump_done(\"FilePartitionBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err segr_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i, k;\n\tFDSessionGroupBox *ptr = (FDSessionGroupBox *) a;\n\tgf_isom_box_dump_start(a, \"FDSessionGroupBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\tfor (i=0; i<ptr->num_session_groups; i++) {\n\t\tfprintf(trace, \"<FDSessionGroupBoxEntry groupIDs=\\\"\");\n\t\tfor (k=0; k<ptr->session_groups[i].nb_groups; k++) {\n\t\t\tfprintf(trace, \"%d \", ptr->session_groups[i].group_ids[k]);\n\t\t}\n\t\tfprintf(trace, \"\\\" channels=\\\"\");\n\t\tfor (k=0; k<ptr->session_groups[i].nb_channels; k++) {\n\t\t\tfprintf(trace, \"%d \", ptr->session_groups[i].channels[k]);\n\t\t}\n\t\tfprintf(trace, \"\\\"/>\\n\");\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \"<FDSessionGroupBoxEntry groupIDs=\\\"\\\" channels=\\\"\\\"/>\\n\");\n\t}\n\n\tgf_isom_box_dump_done(\"FDSessionGroupBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err srpp_dump(GF_Box *a, FILE * trace)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *) a;\n\tgf_isom_box_dump_start(a, \"SRTPProcessBox\", trace);\n\n\tfprintf(trace, \"encryption_algorithm_rtp=\\\"%d\\\" encryption_algorithm_rtcp=\\\"%d\\\" integrity_algorithm_rtp=\\\"%d\\\" integrity_algorithm_rtcp=\\\"%d\\\">\\n\", ptr->encryption_algorithm_rtp, ptr->encryption_algorithm_rtcp, ptr->integrity_algorithm_rtp, ptr->integrity_algorithm_rtcp);\n\n\tif (ptr->info) gf_isom_box_dump(ptr->info, trace);\n\tif (ptr->scheme_type) gf_isom_box_dump(ptr->scheme_type, trace);\n\n\tgf_isom_box_dump_done(\"SRTPProcessBox\", a, trace);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\nGF_Err fdpa_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"FDpacketBox\", trace);\n\tfprintf(trace, \"sender_current_time_present=\\\"%d\\\" expected_residual_time_present=\\\"%d\\\" session_close_bit=\\\"%d\\\" object_close_bit=\\\"%d\\\" transport_object_identifier=\\\"%d\\\">\\n\", ptr->info.sender_current_time_present, ptr->info.expected_residual_time_present, ptr->info.session_close_bit, ptr->info.object_close_bit, ptr->info.transport_object_identifier);\n\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tfprintf(trace, \"<FDHeaderExt type=\\\"%d\\\"\", ptr->headers[i].header_extension_type);\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tdump_data_attribute(trace, \"content\", (char *) ptr->headers[i].content, 3);\n\t\t} else if (ptr->headers[i].data_length) {\n\t\t\tdump_data_attribute(trace, \"data\", ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t}\n\t\tfprintf(trace, \"/>\\n\");\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \"<FDHeaderExt type=\\\"\\\" content=\\\"\\\" data=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"FDpacketBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err extr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *) a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"ExtraDataBox\", trace);\n\tdump_data_attribute(trace, \"data\", ptr->data, ptr->data_length);\n\tfprintf(trace, \">\\n\");\n\tif (ptr->feci) {\n\t\tgf_isom_box_dump((GF_Box *)ptr->feci, trace);\n\t}\n\tgf_isom_box_dump_done(\"ExtraDataBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err fdsa_dump(GF_Box *a, FILE * trace)\n{\n\tGF_Err e;\n\tGF_HintSample *ptr = (GF_HintSample *) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"FDSampleBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\te = gf_isom_box_array_dump(ptr->packetTable, trace);\n\tif (e) return e;\n\tif (ptr->extra_data) {\n\t\te = gf_isom_box_dump((GF_Box *)ptr->extra_data, trace);\n\t\tif (e) return e;\n\t}\n\tgf_isom_box_dump_done(\"FDSampleBox\", a, trace);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\nGF_Err trik_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_TrickPlayBox *p = (GF_TrickPlayBox *) a;\n\n\tgf_isom_box_dump_start(a, \"TrickPlayBox\", trace);\n\n\tfprintf(trace, \">\\n\");\n\tfor (i=0; i<p->entry_count; i++) {\n\t\tfprintf(trace, \"<TrickPlayBoxEntry pic_type=\\\"%d\\\" dependency_level=\\\"%d\\\"/>\\n\", p->entries[i].pic_type, p->entries[i].dependency_level);\n\t}\n\tif (!p->size)\n\t\tfprintf(trace, \"<TrickPlayBoxEntry pic_type=\\\"\\\" dependency_level=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"TrickPlayBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err bloc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_BaseLocationBox *p = (GF_BaseLocationBox *) a;\n\n\tgf_isom_box_dump_start(a, \"BaseLocationBox\", trace);\n\n\tfprintf(trace, \"baseLocation=\\\"%s\\\" basePurlLocation=\\\"%s\\\">\\n\", p->baseLocation, p->basePurlLocation);\n\tgf_isom_box_dump_done(\"BaseLocationBox\", a, trace);\n\treturn GF_OK;\n}\n\nGF_Err ainf_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AssetInformationBox *p = (GF_AssetInformationBox *) a;\n\n\tgf_isom_box_dump_start(a, \"AssetInformationBox\", trace);\n\n\tfprintf(trace, \"profile_version=\\\"%d\\\" APID=\\\"%s\\\">\\n\", p->profile_version, p->APID);\n\tgf_isom_box_dump_done(\"AssetInformationBox\", a, trace);\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_DUMP*/\n"], "filenames": ["include/gpac/internal/isomedia_dev.h", "src/isomedia/box_code_base.c", "src/isomedia/box_dump.c"], "buggy_code_start_loc": [3713, 635, 487], "buggy_code_end_loc": [3714, 636, 4511], "fixing_code_start_loc": [3713, 635, 487], "fixing_code_end_loc": [3714, 636, 4511], "type": "CWE-125", "message": "An issue was discovered in MP4Box in GPAC 0.7.1. There is a heap-based buffer over-read in the isomedia/box_dump.c function hdlr_dump.", "other": {"cve": {"id": "CVE-2018-13006", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-29T14:29:00.433", "lastModified": "2019-03-29T18:58:03.973", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in MP4Box in GPAC 0.7.1. There is a heap-based buffer over-read in the isomedia/box_dump.c function hdlr_dump."}, {"lang": "es", "value": "Se ha descubierto un problema en MP4Box en GPAC 0.7.1. Hay una sobrelectura de b\u00fafer basada en memoria din\u00e1mica (heap) en la funci\u00f3n hdlr_dump en media/box_dump.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:0.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "2CC18384-9350-47D7-A07D-C7D29622AE9E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/bceb03fd2be95097a7b409ea59914f332fb6bc86", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00024.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3926-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/bceb03fd2be95097a7b409ea59914f332fb6bc86"}}