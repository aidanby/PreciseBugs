{"buggy_code": ["require 'sinatra'\nrequire 'sinatra/reloader' if development?\nrequire 'sinatra/cookies'\nrequire 'rexml/document'\nrequire 'webrick'\nrequire 'webrick/https'\nrequire 'openssl'\nrequire 'logger'\nrequire 'thread'\n\nrequire 'bootstrap.rb'\nrequire 'resource.rb'\nrequire 'remote.rb'\nrequire 'fenceagent.rb'\nrequire 'cluster.rb'\nrequire 'config.rb'\nrequire 'pcs.rb'\nrequire 'auth.rb'\nrequire 'wizard.rb'\nrequire 'cfgsync.rb'\nrequire 'permissions.rb'\nrequire 'session.rb'\n\nDir[\"wizards/*.rb\"].each {|file| require file}\n\nuse Rack::CommonLogger\n\nset :app_file, __FILE__\n\ndef generate_cookie_secret\n  return SecureRandom.hex(30)\nend\n\nbegin\n  secret = File.read(COOKIE_FILE)\n  secret_errors = verify_cookie_secret(secret)\n  if secret_errors and not secret_errors.empty?\n    secret_errors.each { |err| $logger.error err }\n    $logger.error \"Invalid cookie secret, using temporary one\"\n    secret = generate_cookie_secret()\n  end\nrescue Errno::ENOENT\n  secret = generate_cookie_secret()\n  File.open(COOKIE_FILE, 'w', 0700) {|f| f.write(secret)}\nend\n\nsession_lifetime = ENV['SESSION_LIFETIME'].to_i()\nsession_lifetime = 60 * 60 unless session_lifetime > 0\nuse SessionPoolLifetime,\n  :expire_after => session_lifetime,\n  :secret => secret,\n  :secure => true, # only send over HTTPS\n  :httponly => true # don't provide to javascript\n\n# session storage instance\n# will be created by Rack later and fetched in \"before\" filter\n$session_storage = nil\n$session_storage_env = {}\n\n#use Rack::SSL\n\nif development?\n  Dir[\"wizards/*.rb\"].each {|file| also_reload file}\n  also_reload 'resource.rb'\n  also_reload 'remote.rb'\n  also_reload 'fenceagent.rb'\n  also_reload 'cluster.rb'\n  also_reload 'config.rb'\n  also_reload 'pcs.rb'\n  also_reload 'auth.rb'\n  also_reload 'wizard.rb'\n  also_reload 'cfgsync.rb'\nend\n\nbefore do\n  @auth_user = nil\n\n  # get session storage instance from env\n  if not $session_storage and env[:__session_storage]\n    $session_storage = env[:__session_storage]\n    $session_storage_env = env\n  end\n\n  if request.path != '/login' and not request.path == \"/logout\" and not request.path == '/remote/auth'\n    protected! \n  end\n  $cluster_name = get_cluster_name()\nend\n\nconfigure do\n  DISABLE_GUI = (ENV['DISABLE_GUI'] and ENV['DISABLE_GUI'].downcase == 'true')\n  PCS = get_pcs_path(File.expand_path(File.dirname(__FILE__)))\n  logger = File.open(\"/var/log/pcsd/pcsd.log\", \"a+\", 0600)\n  STDOUT.reopen(logger)\n  STDERR.reopen(logger)\n  STDOUT.sync = true\n  STDERR.sync = true\n  $logger = configure_logger('/var/log/pcsd/pcsd.log')\n  $semaphore_cfgsync = Mutex.new\nend\n\nset :logging, true\nset :run, false\n\n$thread_cfgsync = Thread.new {\n  while true\n    $semaphore_cfgsync.synchronize {\n      $logger.debug('Config files sync thread started')\n      if Cfgsync::ConfigSyncControl.sync_thread_allowed?()\n        begin\n          # do not sync if this host is not in a cluster\n          cluster_name = get_cluster_name()\n          if cluster_name and !cluster_name.empty?()\n            $logger.debug('Config files sync thread fetching')\n            fetcher = Cfgsync::ConfigFetcher.new(\n              PCSAuth.getSuperuserAuth(), Cfgsync::get_cfg_classes(),\n              get_corosync_nodes(), cluster_name\n            )\n            cfgs_to_save, _ = fetcher.fetch()\n            cfgs_to_save.each { |cfg_to_save|\n              cfg_to_save.save()\n            }\n          end\n        rescue => e\n          $logger.warn(\"Config files sync thread exception: #{e}\")\n        end\n      end\n      $logger.debug('Config files sync thread finished')\n    }\n    sleep(Cfgsync::ConfigSyncControl.sync_thread_interval())\n  end\n}\n\n$thread_session_expired = Thread.new {\n  while true\n    sleep(60 * 5)\n    begin\n      if $session_storage\n        $session_storage.drop_expired($session_storage_env)\n      end\n    rescue => e\n      $logger.warn(\"Exception while removing expired sessions: #{e}\")\n    end\n  end\n}\n\nhelpers do\n  def protected!\n    gui_request = ( # these are URLs for web pages\n      request.path == '/' or\n      request.path == '/manage' or\n      request.path == '/permissions' or\n      request.path.match('/managec/.+/main')\n    )\n    if request.path.start_with?('/remote/') or request.path == '/run_pcs'\n      @auth_user = PCSAuth.loginByToken(cookies)\n      unless @auth_user\n        halt [401, '{\"notauthorized\":\"true\"}']\n      end\n    else #/managec/* /manage/* /permissions\n      if !gui_request and\n        request.env['HTTP_X_REQUESTED_WITH'] != 'XMLHttpRequest'\n      then\n        # Accept non GUI requests only with header\n        # \"X_REQUESTED_WITH: XMLHttpRequest\". (check if they are send via AJAX).\n        # This prevents CSRF attack.\n        halt [401, '{\"notauthorized\":\"true\"}']\n      elsif not PCSAuth.isLoggedIn(session)\n        if gui_request\n          session[:pre_login_path] = request.path\n          redirect '/login'\n        else\n          halt [401, '{\"notauthorized\":\"true\"}']\n        end\n      end\n    end\n  end\n\n  def getParamList(params)\n    param_line = []\n    meta_options = []\n    params.each { |param, val|\n      if param.start_with?(\"_res_paramne_\") or (param.start_with?(\"_res_paramempty_\") and val != \"\")\n        myparam = param.sub(/^_res_paramne_/,\"\").sub(/^_res_paramempty_/,\"\")\n        param_line << \"#{myparam}=#{val}\"\n      end\n      if param == \"disabled\"\n        meta_options << 'meta' << 'target-role=Stopped'\n      end\n    }\n    return param_line + meta_options\n  end\nend\n\nget '/remote/?:command?' do\n  return remote(params, request, @auth_user)\nend\n\npost '/remote/?:command?' do\n  return remote(params, request, @auth_user)\nend\n\npost '/run_pcs' do\n  command = params['command'] || '{}'\n  std_in = params['stdin'] || nil\n  begin\n    command_decoded = JSON.parse(command)\n  rescue JSON::ParserError\n    result = {\n      'status' => 'error',\n      'data' => {},\n    }\n    return JSON.pretty_generate(result)\n  end\n  # do not reveal potentialy sensitive information\n  command_decoded.delete('--debug')\n\n  allowed_commands = {\n    ['cluster', 'auth', '...'] => {\n      'only_superuser' => false,\n      'permissions' => nil,\n    },\n    # runs on the local node, check permissions\n    ['cluster', 'corosync'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::READ,\n    },\n    # runs on a remote node which checks permissions by itself\n    ['cluster', 'corosync', '...'] => {\n      'only_superuser' => false,\n      'permissions' => nil,\n    },\n    ['cluster', 'destroy', '...'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::FULL,\n    },\n    # runs on the local node, check permissions\n    ['cluster', 'disable'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::WRITE,\n    },\n    # runs on a remote node which checks permissions by itself\n    ['cluster', 'disable', '...'] => {\n      'only_superuser' => false,\n      'permissions' => nil,\n    },\n    # runs on the local node, check permissions\n    ['cluster', 'enable'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::WRITE,\n    },\n    # runs on a remote node which checks permissions by itself\n    ['cluster', 'enable', '...'] => {\n      'only_superuser' => false,\n      'permissions' => nil,\n    },\n    ['cluster', 'node', '...'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::FULL,\n    },\n    ['cluster', 'pcsd-status', '...'] => {\n      'only_superuser' => false,\n      'permissions' => nil,\n    },\n    ['cluster', 'setup', '...'] => {\n      'only_superuser' => true,\n      'permissions' => nil,\n    },\n    # runs on the local node, check permissions\n    ['cluster', 'start'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::WRITE,\n    },\n    # runs on a remote node which checks permissions by itself\n    ['cluster', 'start', '...'] => {\n      'only_superuser' => false,\n      'permissions' => nil,\n    },\n    # runs on the local node, check permissions\n    ['cluster', 'stop'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::WRITE,\n    },\n    # runs on a remote node which checks permissions by itself\n    ['cluster', 'stop', '...'] => {\n      'only_superuser' => false,\n      'permissions' => nil,\n    },\n    ['cluster', 'sync', '...'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::FULL,\n    },\n    ['config', 'restore', '...'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::FULL,\n    },\n    ['pcsd', 'sync-certificates', '...'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::FULL,\n    },\n    ['status', 'nodes', 'corosync-id', '...'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::READ,\n    },\n    ['status', 'nodes', 'pacemaker-id', '...'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::READ,\n    },\n    ['status', 'pcsd', '...'] => {\n      'only_superuser' => false,\n      'permissions' => nil,\n    },\n  }\n  allowed = false\n  command_settings = {}\n  allowed_commands.each { |cmd, cmd_settings|\n    if command_decoded == cmd \\\n      or \\\n      (cmd[-1] == '...' and cmd[0..-2] == command_decoded[0..(cmd.length - 2)])\n      then\n        allowed = true\n        command_settings = cmd_settings\n        break\n    end\n  }\n  if !allowed\n    result = {\n      'status' => 'bad_command',\n      'data' => {},\n    }\n    return JSON.pretty_generate(result)\n  end\n\n  if command_settings['only_superuser']\n    if not allowed_for_superuser(@auth_user)\n      return 403, 'Permission denied'\n    end\n  end\n  if command_settings['permissions']\n    if not allowed_for_local_cluster(@auth_user, command_settings['permissions'])\n      return 403, 'Permission denied'\n    end\n  end\n\n  options = {}\n  options['stdin'] = std_in if std_in\n  std_out, std_err, retval = run_cmd_options(\n    @auth_user, options, PCS, *command_decoded\n  )\n  result = {\n    'status' => 'ok',\n    'data' => {\n      'stdout' => std_out.join(\"\"),\n      'stderr' => std_err.join(\"\"),\n      'code' => retval,\n    },\n  }\n  return JSON.pretty_generate(result)\nend\n\nif not DISABLE_GUI\n  get('/login'){ erb :login, :layout => :main }\n\n  get '/logout' do \n    session.destroy\n    erb :login, :layout => :main\n  end\n\n  post '/login' do\n    auth_user = PCSAuth.loginByPassword(\n      params['username'], params['password']\n    )\n    if auth_user\n      PCSAuth.authUserToSession(auth_user, session)\n      # Temporarily ignore pre_login_path until we come up with a list of valid\n      # paths to redirect to (to prevent status_all issues)\n      #    if session[\"pre_login_path\"]\n      #      plp = session[\"pre_login_path\"]\n      #      session.delete(\"pre_login_path\")\n      #      pp \"Pre Login Path: \" + plp\n      #      if plp == \"\" or plp == \"/\"\n      #        plp = '/manage'\n      #      end\n      #      redirect plp\n      #    else\n      redirect '/manage'\n      #    end\n    else\n      session[\"bad_login_name\"] = params['username']\n      redirect '/login?badlogin=1'\n    end\n  end\n\n  post '/manage/existingcluster' do\n    pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text())\n    node = params['node-name']\n    code, result = send_request_with_token(\n      PCSAuth.getSuperuserAuth(), node, 'status'\n    )\n    begin\n      status = JSON.parse(result)\n    rescue JSON::ParserError\n      return 400, \"Unable to communicate with remote pcsd on node '#{node}'.\"\n    end\n\n    warning_messages = []\n\n    if status.has_key?(\"corosync_offline\") and\n      status.has_key?(\"corosync_online\") then\n      nodes = status[\"corosync_offline\"] + status[\"corosync_online\"]\n\n      if status[\"cluster_name\"] == ''\n        return 400, \"The node, '#{noname}', does not currently have a cluster\n configured.  You must create a cluster using this node before adding it to pcsd.\"\n      end\n\n      if pcs_config.is_cluster_name_in_use(status[\"cluster_name\"])\n        return 400, \"The cluster name, '#{status['cluster_name']}' has\nalready been added to pcsd.  You may not add two clusters with the same name into pcsd.\"\n      end\n\n      # auth begin\n      retval, out = send_request_with_token(\n        PCSAuth.getSuperuserAuth(), node, '/get_cluster_tokens'\n      )\n      if retval == 404 # backward compatibility layer\n        warning_messages << \"Unable to do correct authentication of cluster because it is running old version of pcs/pcsd.\"\n      else\n        if retval != 200\n          return 400, \"Unable to get authentication info from cluster '#{status['cluster_name']}'.\"\n        end\n        begin\n          new_tokens = JSON.parse(out)\n        rescue\n          return 400, \"Unable to get authentication info from cluster '#{status['cluster_name']}'.\"\n        end\n\n        sync_config = Cfgsync::PcsdTokens.from_file('')\n        pushed, _ = Cfgsync::save_sync_new_tokens(\n          sync_config, new_tokens, get_corosync_nodes(), $cluster_name\n        )\n        if not pushed\n          return 400, \"Configuration conflict detected.\\n\\nSome nodes had a newer configuration than the local node. Local node's configuration was updated.  Please repeat the last action if appropriate.\"\n        end\n      end\n      #auth end\n\n      pcs_config.clusters << Cluster.new(status[\"cluster_name\"], nodes)\n\n      sync_config = Cfgsync::PcsdSettings.from_text(pcs_config.text())\n      pushed, _ = Cfgsync::save_sync_new_version(\n        sync_config, get_corosync_nodes(), $cluster_name, true\n      )\n      if not pushed\n        return 400, \"Configuration conflict detected.\\n\\nSome nodes had a newer configuration than the local node. Local node's configuration was updated.  Please repeat the last action if appropriate.\"\n      end\n      return 200, warning_messages.join(\"\\n\\n\")\n    else\n      return 400, \"Unable to communicate with remote pcsd on node '#{node}'.\"\n    end\n  end\n\n  post '/manage/newcluster' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    if not allowed_for_superuser(auth_user)\n      return 400, 'Permission denied.'\n    end\n\n    warning_messages = []\n\n    pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text())\n    @manage = true\n    @cluster_name = params[:clustername]\n    @nodes = []\n    nodes_with_indexes = []\n    @nodes_rrp = []\n    options = {}\n    params.each {|k,v|\n      if k.start_with?(\"node-\") and v != \"\"\n        @nodes << v\n        nodes_with_indexes << [k[5..-1].to_i, v]\n        if params.has_key?(\"ring1-\" + k) and params[\"ring1-\" + k] != \"\"\n          @nodes_rrp << v + \",\" + params[\"ring1-\" + k]\n        else\n          @nodes_rrp << v\n        end\n      end\n      if k.start_with?(\"config-\") and v != \"\"\n        options[k.sub(\"config-\",\"\")] = v\n      end\n    }\n    if pcs_config.is_cluster_name_in_use(@cluster_name)\n      return 400, \"The cluster name, '#{@cluster_name}' has already been added to pcsd.  You may not add two clusters with the same name into pcsd.\"\n    end\n\n    @nodes.each {|n|\n      if pcs_config.is_node_in_use(n)\n        return 400, \"The node, '#{n}' is already configured in pcsd.  You may not add a node to two different clusters in pcsd.\"\n      end\n    }\n\n    # first we need to authenticate nodes to each other\n    tokens = add_prefix_to_keys(get_tokens_of_nodes(@nodes), \"node:\")\n    @nodes.each {|n|\n      retval, out = send_request_with_token(\n        auth_user, n, \"/save_tokens\", true, tokens\n      )\n      if retval == 404 # backward compatibility layer\n        warning_messages << \"Unable to do correct authentication of cluster on node '#{n}', because it is running old version of pcs/pcsd.\"\n        break\n      elsif retval != 200\n        return 400, \"Unable to authenticate all nodes on node '#{n}'.\"\n      end\n    }\n\n    # the first node from the form is the source of config files\n    node_to_send_to = nodes_with_indexes.sort[0][1]\n    $logger.info(\n      \"Sending setup cluster request for: #{@cluster_name} to: #{node_to_send_to}\"\n    )\n    code,out = send_request_with_token(\n      auth_user,\n      node_to_send_to,\n      'setup_cluster',\n      true,\n      {\n        :clustername => @cluster_name,\n        :nodes => @nodes_rrp.join(';'),\n        :options => options.to_json\n      },\n      true,\n      nil,\n      60\n    )\n\n    if code == 200\n      pushed = false\n      2.times {\n        # Add the new cluster to config and publish the config.\n        # If this host is a node of the cluster, some other node may send its\n        # own PcsdSettings.  To handle it we just need to reload the config, as\n        # we are waiting for the request to finish, so no locking is needed.\n        # If we are in a different cluster we just try twice to update the\n        # config, dealing with any updates in between.\n        pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text())\n        pcs_config.clusters << Cluster.new(@cluster_name, @nodes)\n        sync_config = Cfgsync::PcsdSettings.from_text(pcs_config.text())\n        pushed, _ = Cfgsync::save_sync_new_version(\n          sync_config, get_corosync_nodes(), $cluster_name, true\n        )\n        break if pushed\n      }\n      if not pushed\n        return 400, \"Configuration conflict detected.\\n\\nSome nodes had a newer configuration than the local node. Local node's configuration was updated.  Please repeat the last action if appropriate.\"\n      end\n    else\n      return 400, \"Unable to create new cluster. If cluster already exists on one or more of the nodes run 'pcs cluster destroy' on all nodes to remove current cluster configuration.\\n\\n#{node_to_send_to}: #{out}\"\n    end\n\n    return warning_messages.join(\"\\n\\n\")\n  end\n\n  post '/manage/removecluster' do\n    pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text())\n    params.each { |k,v|\n      if k.start_with?(\"clusterid-\")\n        pcs_config.remove_cluster(k.sub(\"clusterid-\",\"\"))\n      end\n    }\n    sync_config = Cfgsync::PcsdSettings.from_text(pcs_config.text())\n    pushed, _ = Cfgsync::save_sync_new_version(\n      sync_config, get_corosync_nodes(), $cluster_name, true\n    )\n    if not pushed\n      return 400, \"Configuration conflict detected.\\n\\nSome nodes had a newer configuration than the local node.  Local node's configuration was updated.  Please repeat the last action if appropriate.\"\n    end\n  end\n\n  get '/manage/check_pcsd_status' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    node_results = {}\n    if params[:nodes] != nil and params[:nodes] != ''\n      node_array = params[:nodes].split(',')\n      online, offline, notauthorized = check_gui_status_of_nodes(\n        auth_user, node_array\n      )\n      online.each { |node|\n        node_results[node] = 'Online'\n      }\n      offline.each { |node|\n        node_results[node] = 'Offline'\n      }\n      notauthorized.each { |node|\n        node_results[node] = 'Unable to authenticate'\n      }\n    end\n    return JSON.generate(node_results)\n  end\n\n  get '/manage/get_nodes_sw_versions' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    if params[:nodes] != nil and params[:nodes] != ''\n      nodes = params[:nodes].split(',')\n      final_response = {}\n      threads = []\n      nodes.each {|node|\n        threads << Thread.new {\n          code, response = send_request_with_token(\n            auth_user, node, 'get_sw_versions'\n          )\n          begin\n            node_response = JSON.parse(response)\n            if node_response and node_response['notoken'] == true\n              $logger.error(\"ERROR: bad token for #{node}\")\n            end\n            final_response[node] = node_response\n          rescue JSON::ParserError\n          end\n        }\n      }\n      threads.each { |t| t.join }\n      return JSON.generate(final_response)\n    end\n    return '{}'\n  end\n\n  post '/manage/auth_gui_against_nodes' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    node_auth_error = {}\n    new_tokens = {}\n    threads = []\n    params.each { |node|\n      threads << Thread.new {\n        if node[0].end_with?(\"-pass\") and node[0].length > 5\n          nodename = node[0][0..-6]\n          if params.has_key?(\"all\")\n            pass = params[\"pass-all\"]\n          else\n            pass = node[1]\n          end\n          data = {\n            'node-0' => nodename,\n            'username' => SUPERUSER,\n            'password' => pass,\n            'force' => 1,\n          }\n          node_auth_error[nodename] = 1\n          code, response = send_request(auth_user, nodename, 'auth', true, data)\n          if 200 == code\n            token = response.strip\n            if not token.empty?\n              new_tokens[nodename] = token\n              node_auth_error[nodename] = 0\n            end\n          end\n        end\n      }\n    }\n    threads.each { |t| t.join }\n\n    if not new_tokens.empty?\n      cluster_nodes = get_corosync_nodes()\n      tokens_cfg = Cfgsync::PcsdTokens.from_file('')\n      sync_successful, sync_responses = Cfgsync::save_sync_new_tokens(\n        tokens_cfg, new_tokens, cluster_nodes, $cluster_name\n      )\n    end\n\n    return [200, JSON.generate({'node_auth_error' => node_auth_error})]\n  end\n\n  get '/manage/?' do\n    @manage = true\n    erb :manage, :layout => :main\n  end\n\n  get '/clusters_overview' do\n    clusters_overview(params, request, PCSAuth.sessionToAuthUser(session))\n  end\n\n  get '/permissions/?' do\n    @manage = true\n    pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text())\n    @clusters = pcs_config.clusters.sort { |a, b| a.name <=> b.name }\n    erb :permissions, :layout => :main\n  end\n\n  get '/permissions_cluster_form/:cluster/?' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    @cluster_name = params[:cluster]\n    @error = nil\n    @permission_types = []\n    @permissions_dependencies = {}\n    @user_types = []\n    @users_permissions = []\n\n    pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text())\n\n    if not pcs_config.is_cluster_name_in_use(@cluster_name)\n      @error = 'Cluster not found'\n    else\n      code, data = send_cluster_request_with_token(\n        auth_user, @cluster_name, 'get_permissions'\n      )\n      if 404 == code\n        @error = 'Cluster is running an old version of pcsd which does not support permissions'\n      elsif 403 == code\n        @error = 'Permission denied'\n      elsif 200 != code\n        @error = 'Unable to load permissions of the cluster'\n      else\n        begin\n          permissions = JSON.parse(data)\n          if permissions['notoken'] or permissions['noresponse']\n            @error = 'Unable to load permissions of the cluster'\n          else\n            @permission_types = permissions['permission_types'] || []\n            @permissions_dependencies = permissions['permissions_dependencies'] || {}\n            @user_types = permissions['user_types'] || []\n            @users_permissions = permissions['users_permissions'] || []\n          end\n        rescue JSON::ParserError\n          @error = 'Unable to read permissions of the cluster'\n        end\n      end\n    end\n    erb :_permissions_cluster\n  end\n\n  get '/managec/:cluster/main' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    @cluster_name = params[:cluster]\n    pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text())\n    @clusters = pcs_config.clusters\n    @nodes = get_cluster_nodes(params[:cluster])\n    if @nodes == []\n      redirect '/manage/'\n    end\n    @resource_agents = get_resource_agents_avail(auth_user, params)\n    @stonith_agents = get_stonith_agents_avail(auth_user, params)\n    erb :nodes, :layout => :main\n  end\n\n  post '/managec/:cluster/permissions_save/?' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    new_params = {\n      'json_data' => JSON.generate(params)\n    }\n    return send_cluster_request_with_token(\n      auth_user, params[:cluster], \"set_permissions\", true, new_params\n    )\n  end\n\n  get '/managec/:cluster/status_all' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    status_all(params, request, auth_user, get_cluster_nodes(params[:cluster]))\n  end\n\n  get '/managec/:cluster/cluster_status' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    cluster_status_gui(auth_user, params[:cluster])\n  end\n\n  get '/managec/:cluster/cluster_properties' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    cluster = params[:cluster]\n    unless cluster\n      return 200, {}\n    end\n    code, out = send_cluster_request_with_token(auth_user, cluster, 'get_cib')\n    if code == 403\n      return [403, 'Permission denied']\n    elsif code != 200\n      return [400, 'getting CIB failed']\n    end\n    begin\n      properties = getAllSettings(nil, REXML::Document.new(out))\n      code, out = send_cluster_request_with_token(\n        auth_user, cluster, 'get_cluster_properties_definition'\n      )\n\n      if code == 403\n        return [403, 'Permission denied']\n      elsif code == 404\n        definition = {\n          'batch-limit' => {\n            'name' => 'batch-limit',\n            'source' => 'pengine',\n            'default' => '0',\n            'type' => 'integer',\n            'shortdesc' => 'The number of jobs that pacemaker is allowed to execute in parallel.',\n            'longdesc' => 'The \"correct\" value will depend on the speed and load of your network and cluster nodes.',\n            'readable_name' => 'Batch Limit',\n            'advanced' => false\n          },\n          'no-quorum-policy' => {\n            'name' => 'no-quorum-policy',\n            'source' => 'pengine',\n            'default' => 'stop',\n            'type' => 'enum',\n            'enum' => ['stop', 'freeze', 'ignore', 'suicide'],\n            'shortdesc' => 'What to do when the cluster does not have quorum.',\n            'longdesc' => 'Allowed values:\n    * ignore - continue all resource management\n    * freeze - continue resource management, but don\\'t recover resources from nodes not in the affected partition\n    * stop - stop all resources in the affected cluster partition\n    * suicide - fence all nodes in the affected cluster partition',\n            'readable_name' => 'No Quorum Policy',\n            'advanced' => false\n          },\n          'symmetric-cluster' => {\n            'name' => 'symmetric-cluster',\n            'source' => 'pengine',\n            'default' => 'true',\n            'type' => 'boolean',\n            'shortdesc' => 'All resources can run anywhere by default.',\n            'longdesc' => 'All resources can run anywhere by default.',\n            'readable_name' => 'Symmetric',\n            'advanced' => false\n          },\n          'stonith-enabled' => {\n            'name' => 'stonith-enabled',\n            'source' => 'pengine',\n            'default' => 'true',\n            'type' => 'boolean',\n            'shortdesc' => 'Failed nodes are STONITH\\'d',\n            'longdesc' => 'Failed nodes are STONITH\\'d',\n            'readable_name' => 'Stonith Enabled',\n            'advanced' => false\n          },\n          'stonith-action' => {\n            'name' => 'stonith-action',\n            'source' => 'pengine',\n            'default' => 'reboot',\n            'type' => 'enum',\n            'enum' => ['reboot', 'poweroff', 'off'],\n            'shortdesc' => 'Action to send to STONITH device',\n            'longdesc' => 'Action to send to STONITH device Allowed values: reboot, poweroff, off',\n            'readable_name' => 'Stonith Action',\n            'advanced' => false\n          },\n          'cluster-delay' => {\n            'name' => 'cluster-delay',\n            'source' => 'pengine',\n            'default' => '60s',\n            'type' => 'time',\n            'shortdesc' => 'Round trip delay over the network (excluding action execution)',\n            'longdesc' => 'The \"correct\" value will depend on the speed and load of your network and cluster nodes.',\n            'readable_name' => 'Cluster Delay',\n            'advanced' => false\n          },\n          'stop-orphan-resources' => {\n            'name' => 'stop-orphan-resources',\n            'source' => 'pengine',\n            'default' => 'true',\n            'type' => 'boolean',\n            'shortdesc' => 'Should deleted resources be stopped',\n            'longdesc' => 'Should deleted resources be stopped',\n            'readable_name' => 'Stop Orphan Resources',\n            'advanced' => false\n          },\n          'stop-orphan-actions' => {\n            'name' => 'stop-orphan-actions',\n            'source' => 'pengine',\n            'default' => 'true',\n            'type' => 'boolean',\n            'shortdesc' => 'Should deleted actions be cancelled',\n            'longdesc' => 'Should deleted actions be cancelled',\n            'readable_name' => 'top Orphan Actions',\n            'advanced' => false\n          },\n          'start-failure-is-fatal' => {\n            'name' => 'start-failure-is-fatal',\n            'source' => 'pengine',\n            'default' => 'true',\n            'type' => 'boolean',\n            'shortdesc' => 'Always treat start failures as fatal',\n            'longdesc' => 'This was the old default. However when set to FALSE, the cluster will instead use the resource\\'s failcount and value for resource-failure-stickiness',\n            'readable_name' => 'Start Failure is Fatal',\n            'advanced' => false\n          },\n          'pe-error-series-max' => {\n            'name' => 'pe-error-series-max',\n            'source' => 'pengine',\n            'default' => '-1',\n            'type' => 'integer',\n            'shortdesc' => 'The number of PE inputs resulting in ERRORs to save',\n            'longdesc' => 'Zero to disable, -1 to store unlimited.',\n            'readable_name' => 'PE Error Storage',\n            'advanced' => false\n          },\n          'pe-warn-series-max' => {\n            'name' => 'pe-warn-series-max',\n            'source' => 'pengine',\n            'default' => '5000',\n            'type' => 'integer',\n            'shortdesc' => 'The number of PE inputs resulting in WARNINGs to save',\n            'longdesc' => 'Zero to disable, -1 to store unlimited.',\n            'readable_name' => 'PE Warning Storage',\n            'advanced' => false\n          },\n          'pe-input-series-max' => {\n            'name' => 'pe-input-series-max',\n            'source' => 'pengine',\n            'default' => '4000',\n            'type' => 'integer',\n            'shortdesc' => 'The number of other PE inputs to save',\n            'longdesc' => 'Zero to disable, -1 to store unlimited.',\n            'readable_name' => 'PE Input Storage',\n            'advanced' => false\n          },\n          'enable-acl' => {\n            'name' => 'enable-acl',\n            'source' => 'cib',\n            'default' => 'false',\n            'type' => 'boolean',\n            'shortdesc' => 'Enable CIB ACL',\n            'longdesc' => 'Should pacemaker use ACLs to determine access to cluster',\n            'readable_name' => 'Enable ACLs',\n            'advanced' => false\n          },\n        }\n      elsif code != 200\n        return [400, 'getting properties definition failed']\n      else\n        definition = JSON.parse(out)\n      end\n  \n      definition.each { |name, prop|\n        prop['value'] = properties[name]\n      }\n      return [200, JSON.generate(definition)]\n    rescue\n      return [400, 'unable to get cluster properties']\n    end\n  end\n\n  post '/managec/:cluster/fix_auth_of_cluster' do\n    clustername = params[:cluster]\n    unless clustername\n      return [400, \"cluster name not defined\"]\n    end\n\n    nodes = get_cluster_nodes(clustername)\n    tokens_data = add_prefix_to_keys(get_tokens_of_nodes(nodes), \"node:\")\n\n    retval, out = send_cluster_request_with_token(\n      PCSAuth.getSuperuserAuth(), clustername, \"/save_tokens\", true,\n      tokens_data, true\n    )\n    if retval == 404\n      return [400, \"Old version of PCS/PCSD is running on cluster nodes. Fixing authentication is not supported. Use 'pcs cluster auth' command to authenticate the nodes.\"]\n    elsif retval != 200\n      return [400, \"Authentication failed.\"]\n    end\n    return [200, \"Auhentication of nodes in cluster should be fixed.\"]\n  end\n\n  post '/managec/:cluster/add_node_to_cluster' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    clustername = params[:cluster]\n    new_node = params[\"new_nodename\"]\n\n    if clustername == $cluster_name\n      if not allowed_for_local_cluster(auth_user, Permissions::FULL)\n        return 403, 'Permission denied'\n      end\n    end\n\n    tokens = read_tokens\n\n    if not tokens.include? new_node\n      return [400, \"New node is not authenticated.\"]\n    end\n\n    # Save the new node token on all nodes in a cluster the new node is beeing\n    # added to. Send the token to one node and let the cluster nodes synchronize\n    # it by themselves.\n    token_data = {\"node:#{new_node}\" => tokens[new_node]}\n    retval, out = send_cluster_request_with_token(\n      # new node doesn't have config with permissions yet\n      PCSAuth.getSuperuserAuth(), clustername, '/save_tokens', true, token_data\n    )\n    # If the cluster runs an old pcsd which doesn't support /save_tokens,\n    # ignore 404 in order to not prevent the node to be added.\n    if retval != 404 and retval != 200\n      return [400, 'Failed to save the token of the new node in target cluster.']\n    end\n\n    retval, out = send_cluster_request_with_token(\n      auth_user, clustername, \"/add_node_all\", true, params\n    )\n    if 403 == retval\n      return [retval, out]\n    end\n    if retval != 200\n      return [400, \"Failed to add new node '#{new_node}' into cluster '#{clustername}': #{out}\"]\n    end\n\n    return [200, \"Node added successfully.\"]\n  end\n\n  post '/managec/:cluster/?*' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    raw_data = request.env[\"rack.input\"].read\n    if params[:cluster]\n      request = \"/\" + params[:splat].join(\"/\")\n      code, out = send_cluster_request_with_token(\n        auth_user, params[:cluster], request, true, params, true, raw_data\n      )\n\n      # backward compatibility layer BEGIN\n      # This code correctly remove constraints on pcs/pcsd version 0.9.137 and older\n      redirection = {\n          \"/remove_constraint_remote\" => \"/resource_cmd/rm_constraint\",\n          \"/remove_constraint_rule_remote\" => \"/resource_cmd/rm_constraint_rule\"\n      }\n      if code == 404 and redirection.key?(request)\n        code, out = send_cluster_request_with_token(\n          auth_user,\n          params[:cluster],\n          redirection[request],\n          true,\n          params,\n          false,\n          raw_data\n        )\n      end\n      # bcl END\n      return code, out\n    end\n  end\n\n  get '/managec/:cluster/?*' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    raw_data = request.env[\"rack.input\"].read\n    if params[:cluster]\n      send_cluster_request_with_token(\n        auth_user,\n        params[:cluster],\n        \"/\" + params[:splat].join(\"/\"),\n        false,\n        params,\n        true,\n        raw_data\n      )\n    end\n  end\n\n  get '/' do\n    $logger.info \"Redirecting '/'...\\n\"\n    redirect '/manage'\n  end\n\n  get '/wizards/?:wizard?' do\n    return wizard(params, request, params[:wizard])\n  end\n\n  post '/wizards/?:wizard?' do\n    return wizard(params, request, params[:wizard])\n  end\n\n  get '*' do\n    $logger.debug \"Bad URL\"\n    $logger.debug params[:splat]\n    $logger.info \"Redirecting '*'...\\n\"\n    redirect '/manage'\n    redirect \"Bad URL\"\n    call(env.merge(\"PATH_INFO\" => '/nodes'))\n  end\nelse\n  get '*' do\n    $logger.debug \"ERROR: GUI Disabled, Bad URL\"\n    $logger.debug params[:splat]\n    $logger.info \"Redirecting '*'...\\n\"\n    return \"PCSD GUI is disabled\"\n  end\n\nend\n\nclass Node\n  attr_accessor :active, :id, :name, :hostname\n\n  def initialize(id=nil, name=nil, hostname=nil, active=nil)\n    @id, @name, @hostname, @active = id, name, hostname, active\n  end\nend\n\nhelpers do\n  def h(text)\n    Rack::Utils.escape_html(text)\n  end\n\n  def nl2br(text)\n    text.gsub(/\\n/, \"<br>\")\n  end\nend\n", "Pcs = Ember.Application.createWithMixins({\n  LOG_TRANSITIONS: true,\n  cluster_name: get_cluster_name(),\n  cluster_settings: null,\n  cur_page: \"\",\n  opening_resource: \"\",\n  opening_node: \"\",\n  opening_aclrole: \"\",\n  resource_page: function() {\n    if (this.cur_page == \"resources\") return \"display: table-row;\";\n    else return \"display: none;\";\n  }.property(\"cur_page\"),\n  node_page: function() {\n    if (this.cur_page == \"nodes\") return \"display: table-row;\";\n    else return \"display: none;\";\n  }.property(\"cur_page\"),\n  stonith_page: function() {\n    if (this.cur_page == \"stonith\") return \"display: table-row;\";\n    else return \"display: none;\";\n  }.property(\"cur_page\"),\n  configure_page: function() {\n    if (this.cur_page == \"configure\") return \"display: table-row;\";\n    else return \"display: none;\";\n  }.property(\"cur_page\"),\n  acls_page: function() {\n    if (this.cur_page == \"acls\") return \"display: table-row;\";\n    else return \"display: none;\";\n  }.property(\"cur_page\"),\n  manage_page: function() {\n    if (this.cur_page == \"manage\") return \"display: table-row;\";\n    else return \"display: none;\";\n  }.property(\"cur_page\"),\n  permissions_page: function() {\n    if (this.cur_page == \"permissions\") return \"display: table-row;\";\n    else return \"display: none;\";\n  }.property(\"cur_page\"),\n  wizards_page: function() {\n    if (this.cur_page == \"wizards\") return \"display: table-row;\";\n    else return \"display: none;\";\n  }.property(\"cur_page\"),\n\n  getResourcesFromID: function(resources) {\n    var retArray = [];\n    var resource_map = Pcs.resourcesContainer.get('resource_map');\n    $.each(resources, function(_, resource_id) {\n      if (resource_id in resource_map && !resource_map[resource_id].get('stonith')) {\n        retArray.pushObject(resource_map[resource_id]);\n      }\n    });\n    return retArray;\n  },\n  updater: null,\n\n  update: function() {\n    Pcs.get('updater').update();\n  },\n\n  _update: function(first_run) {\n    if (window.location.pathname.lastIndexOf('/manage', 0) !== 0) {\n      return;\n    }\n    if (first_run) {\n      show_loading_screen();\n    }\n    var self = Pcs;\n    var cluster_name = self.cluster_name;\n    if (cluster_name == null) {\n      if (location.pathname.indexOf(\"/manage\") != 0) {\n        return;\n      }\n      Ember.debug(\"Empty Cluster Name\");\n      $.ajax({\n        url: \"/clusters_overview\",\n        dataType: \"json\",\n        timeout: 20000,\n        success: function(data) {\n          Pcs.clusterController.update(data);\n          if (Pcs.clusterController.get('cur_cluster')) {\n            Pcs.clusterController.update_cur_cluster(Pcs.clusterController.get('cur_cluster').get('name'));\n          }\n          if (data[\"not_current_data\"]) {\n            self.update();\n          }\n          hide_loading_screen();\n        },\n        error: function(jqhxr,b,c) {\n          if (jqhxr.responseText) {\n            try {\n              var obj = $.parseJSON(jqhxr.responseText);\n              if (obj.notauthorized == \"true\") {\n                location.reload();\n              }\n            } catch(e) {\n              console.log(\"Error: Unable to parse json for clusters_overview\");\n            }\n          }\n          hide_loading_screen();\n        },\n        complete: function() {\n          Pcs.get('updater').update_finished();\n        }\n      });\n      return;\n    }\n    $.ajax({\n      url: \"cluster_status\",\n      dataType: \"json\",\n      success: function(data) {\n        Pcs.resourcesContainer.update(data);\n        Pcs.nodesController.update(data);\n        Pcs.aclsController.update(data);\n        Pcs.set(\"cluster_settings\",data.cluster_settings);\n        Pcs.set('need_ring1_address', false);\n        Pcs.set('is_cman_with_udpu_transport', false);\n        if (data['need_ring1_address']) {\n          Pcs.set('need_ring1_address', true);\n        }\n        if (data['is_cman_with_udpu_transport']) {\n          Pcs.set('is_cman_with_udpu_transport', true);\n        }\n        var fence_change = false;\n        var resource_change = false;\n        Ember.run.next(function () {\n          var self = Pcs.resourcesContainer;\n          var cur_fence = self.get('cur_fence');\n          var cur_resource = self.get('cur_resource');\n          var resource_map = self.get('resource_map');\n          if (first_run) {\n            refresh_cluster_properties();\n            setup_node_links();\n            Pcs.nodesController.load_node($('#node_list_row').find('.node_selected').first(),true);\n            Pcs.aclsController.load_role($('#acls_list_row').find('.node_selected').first(), true);\n            if (self.get(\"fence_id_to_load\")) {\n              cur_fence = self.get_resource_by_id(self.get(\"fence_id_to_load\"));\n              fence_change = true;\n            }\n            if (self.get(\"resource_id_to_load\")) {\n              cur_resource = self.get_resource_by_id(self.get(\"resource_id_to_load\"));\n              resource_change = true;\n            }\n          }\n\n          if (cur_fence && cur_fence.get('id') in resource_map) {\n            if (resource_map[cur_fence.get('id')] !== cur_fence) {\n              cur_fence = resource_map[cur_fence.get('id')];\n            }\n          } else {\n            if (self.get('fence_list').length > 0) {\n              cur_fence = self.get('fence_list')[0];\n            } else {\n              cur_fence = null;\n            }\n            fence_change = true;\n          }\n\n          if (cur_resource && cur_resource.get('id') in resource_map) {\n            if (resource_map[cur_resource.get('id')] !== cur_resource) {\n              cur_resource = resource_map[cur_resource.get('id')];\n            }\n          } else {\n            if (self.get('resource_list').length > 0) {\n              cur_resource = self.get('resource_list')[0];\n            } else {\n              cur_resource = null;\n            }\n            resource_change = true;\n          }\n\n          self.set('cur_fence', cur_fence);\n          self.set('cur_resource', cur_resource);\n\n          Ember.run.scheduleOnce('afterRender', Pcs, function () {\n            if (self.get('cur_fence')) {\n              if (fence_change)\n                tree_view_onclick(self.get('cur_fence').get('id'), true);\n              else\n                tree_view_select(self.get('cur_fence').get('id'));\n            }\n            if (self.get('cur_resource')) {\n              if (resource_change)\n                tree_view_onclick(self.get('cur_resource').get('id'), true);\n              else\n                tree_view_select(self.get('cur_resource').get('id'));\n            }\n            Pcs.selectedNodeController.reset();\n            disable_checkbox_clicks();\n          });\n        });\n      },\n      error: function(jqhxr,b,c) {\n        try {\n          var obj = $.parseJSON(jqhxr.responseText);\n          if (obj.notauthorized == \"true\") {\n            location.reload();\n          }\n        } catch(e) {\n          console.log(\"Error: Unable to parse json for cluster_status\")\n        }\n      },\n      complete: function() {\n        hide_loading_screen();\n        Pcs.get('updater').update_finished();\n      }\n    });\n  }\n});\n\nPcs.ValueSelectorComponent = Ember.Component.extend({\n  tagName: 'select',\n  attributeBindings: ['name'],\n  name: null,\n  prompt: \"Select one value\",\n  show_prompt: true,\n  content: [],\n  value: null,\n  _change: function() {\n    var selectedIndex = this.$()[0].selectedIndex,\n      content = this.get('content'),\n      prompt = this.get('show_prompt');\n\n    if (!content || !content.get('length')) { return; }\n    if (prompt && selectedIndex === 0) { this.set('value', \"\"); return; }\n\n    if (prompt) { selectedIndex -= 1; }\n    this.set('value', content.objectAt(selectedIndex)['value']);\n  },\n  init: function() {\n    this._super();\n    this.on(\"change\", this, this._change);\n  }\n});\n\nPcs.ClusterPropertyComponent = Ember.Component.extend({\n  tagName: 'tr',\n  prop: null,\n  attributeBindings: ['name'],\n  boolean_options: [\n    {\n      name: \"true\",\n      value: \"true\"\n    },\n    {\n      name: \"false\",\n      value: \"false\"\n    }\n  ]\n});\n\nPcs.UtilizationTableComponent = Ember.Component.extend({\n  entity: null,\n  type: \"node\", // node or resource\n  form_id: Ember.computed(\"type\", function() {\n    return \"new_\" + this.get(\"type\") + \"_utilization\";\n  }),\n  show_content: false,\n  utilization: [],\n  last_count: 0,\n  util_count: function() {\n    var l = 0;\n    if (this.utilization) {\n      l = this.utilization.length;\n    }\n    //this is needed for not showing/hiding table on each update\n    if (this.last_count != l) {\n      if (l > 0) {\n        this.set('show_content', true);\n      } else {\n        this.set('show_content', false);\n      }\n    }\n    this.set(\"last_count\", l);\n    return l;\n  }.property(\"utilization\"),\n  actions: {\n    toggleBody: function() {\n      this.toggleProperty('show_content');\n    },\n    remove: function(name) {\n      set_utilization(this.type, this.entity.get(\"id\"), name, \"\");\n    },\n    add: function(form_id) {\n      var id = \"#\" + form_id;\n      var name = $(id + \" input[name='new_utilization_name']\").val();\n      if (name == \"\") {\n        return;\n      }\n      var value = $(id + \" input[name='new_utilization_value']\").val().trim();\n      if (!is_integer(value)) {\n        alert(\"Value of utilization attribute has to be integer.\");\n        return;\n      }\n      set_utilization(\n        this.type,\n        this.entity.get(\"id\"),\n        name,\n        value\n      );\n      fade_in_out($(id));\n      $(id + \" input\").val(\"\");\n    }\n  }\n});\n\nPcs.Updater = Ember.Object.extend({\n  timeout: 20000,\n  first_run: true,\n  async: true,\n  autostart: true,\n  started: false,\n  in_progress: false,\n  waiting: false,\n  update_function: null,\n  update_target: null,\n  timer: null,\n\n  start: function() {\n    this.set('started', true);\n    this.update();\n  },\n\n  stop: function() {\n    this.set('started', false);\n    this.cancel_timer();\n  },\n\n  cancel_timer: function() {\n    var self = this;\n    var timer = self.get('timer');\n    if (timer) {\n      self.set('timer', null);\n      Ember.run.cancel(timer);\n    }\n  },\n\n  update: function() {\n    var self = this;\n    if (!self.get('update_function')) {\n      console.log('No update_function defined!');\n      return;\n    }\n    self.cancel_timer();\n    self.set('waiting', false);\n    if (self.get('in_progress')) {\n      self.set('waiting', true);\n    } else {\n      self.set('in_progress', true);\n      self.get('update_function').apply(self.get('update_target'), [self.get('first_run')]);\n      self.set('first_run', false);\n      if (!self.get('async')) {\n        self.update_finished();\n      }\n    }\n  },\n\n  update_finished: function() {\n    var self = this;\n    if (self.get('waiting')) {\n      Ember.run.next(self, self.update);\n    } else if (self.get('started')) {\n      self.set('timer', Ember.run.later(self, self.update, self.get('timeout')));\n    }\n    self.set('in_progress', false);\n  },\n\n  init: function() {\n    var self = this;\n    if (!self.get('update_target')) {\n      self.set('update_target', self);\n    }\n    if (self.get('autostart')) {\n      self.start();\n    }\n  }\n});\n\nPcs.resourcesContainer = Ember.Object.create({\n  resource_map: {},\n  top_level_resource_map: {},\n  fence_list: [],\n  resource_list: [],\n  resource_id_to_load: null,\n  fence_id_to_load: null,\n  cur_resource: null,\n  cur_fence: null,\n  constraints: {},\n  group_list: [],\n  data_version: null,\n\n  get_resource_by_id: function(resource_id) {\n    var resource_map = this.get('resource_map');\n    if (resource_id in resource_map)\n      return resource_map[resource_id];\n    return null;\n  },\n\n  get_family_list: function(parent) {\n    var family = [];\n    family.push(parent);\n    switch (parent[\"class_type\"]) {\n      case \"group\":\n        $.each(parent.get('members'), function(index, member) {\n          family = family.concat(Pcs.resourcesContainer.get_family_list(member));\n        });\n        break;\n      case \"clone\":\n      case \"master\":\n        family = family.concat(Pcs.resourcesContainer.get_family_list(parent.get('member')));\n        break;\n    }\n    return family;\n  },\n\n  get_constraints: function(cons) {\n    var ord_con = {};\n    var loc_con = {};\n    var col_con = {};\n    var ord_set_con = {};\n    var res_loc_constraints = {};\n    var res_ord_constraints = {};\n    var res_ord_set_constraints = {};\n    var res_col_constraints = {};\n    if (cons) {\n      if (cons[\"rsc_location\"]) {\n        $.each(cons[\"rsc_location\"], function (key, value) {\n          loc_con[value[\"id\"]] = value;\n        });\n      }\n      if (cons[\"rsc_order\"]) {\n        $.each(cons[\"rsc_order\"], function (key, value) {\n          if (value[\"sets\"]) {\n            ord_set_con[value[\"id\"]] = value;\n          }\n          else {\n            ord_con[value[\"id\"]] = value;\n          }\n        });\n      }\n      if (cons[\"rsc_colocation\"]) {\n        $.each(cons[\"rsc_colocation\"], function (key, value) {\n          col_con[value[\"id\"]] = value;\n        });\n      }\n    }\n\n    $.each(loc_con, function (key, value) {\n      res_loc_constraints[value[\"rsc\"]] = res_loc_constraints[value[\"rsc\"]] || [];\n      res_loc_constraints[value[\"rsc\"]].push(value);\n    });\n    $.each(ord_con, function (key, value) {\n      first = $.extend({\"other_rsc\":value[\"then\"],\"before\":false}, value);\n      if (value[\"first\"] in res_ord_constraints)\n        res_ord_constraints[value[\"first\"]].push(first);\n      else res_ord_constraints[value[\"first\"]] = [first];\n      then = $.extend({\"other_rsc\":value[\"first\"],\"before\":true}, value);\n      if (value[\"then\"] in res_ord_constraints)\n        res_ord_constraints[value[\"then\"]].push(then);\n      else res_ord_constraints[value[\"then\"]] = [then];\n    });\n\n    $.each(ord_set_con, function(key, set_con) {\n      $.each(set_con[\"sets\"], function(key, set) {\n        $.each(set[\"resources\"], function(key, resource) {\n          res_ord_set_constraints[resource] = res_ord_set_constraints[resource] || [];\n          if (res_ord_set_constraints[resource].indexOf(set_con) != -1) {\n            return;\n          }\n          res_ord_set_constraints[resource].push(set_con);\n        })\n      })\n    });\n\n    $.each(col_con, function (key, value) {\n      if (value[\"score\"] == \"INFINITY\")\n        value[\"together\"] = \"Together\";\n      else if (value[\"score\"] == \"-INFINITY\" || value[\"score\"] < 0)\n        value[\"together\"] = \"Apart\";\n      else if (value[\"score\"] >= 0)\n        value[\"together\"] = \"Together\";\n\n      first = $.extend({\"other_rsc\":value[\"with-rsc\"],\"first\":true}, value);\n      if (value[\"rsc\"] in res_col_constraints)\n        res_col_constraints[value[\"rsc\"]].push(first);\n      else res_col_constraints[value[\"rsc\"]] = [first];\n      second = $.extend({\"other_rsc\":value[\"rsc\"],\"first\":false}, value);\n      if (value[\"with-rsc\"] in res_col_constraints)\n        res_col_constraints[value[\"with-rsc\"]].push(second);\n      else res_col_constraints[value[\"with-rsc\"]] = [second];\n    });\n    return {\n      \"location_constraints\": res_loc_constraints,\n      \"ordering_constraints\": res_ord_constraints,\n      \"ordering_set_constraints\": res_ord_set_constraints,\n      \"colocation_constraints\": res_col_constraints\n    };\n  },\n\n  update_meta_attr: function(resource_id, attr, value) {\n    value = typeof value !== 'undefined' ? value.trim() : \"\";\n    var data = {\n      res_id: resource_id,\n      key: attr,\n      value: value\n    };\n\n    $.ajax({\n      type: 'POST',\n      url: get_cluster_remote_url() + 'add_meta_attr_remote',\n      data: data,\n      timeout: pcs_timeout,\n      error: function (xhr, status, error) {\n        alert(\n          \"Unable to update meta attribute '\" + attr + \"' \"\n          + ajax_simple_error(xhr, status, error)\n        );\n      },\n      complete: function() {\n        Pcs.update();\n      }\n    });\n  },\n\n  enable_resource: function(resource_id) {\n    if (resource_id == null) {\n      return;\n    }\n    $.ajax({\n      type: 'POST',\n      url: get_cluster_remote_url() + 'resource_start',\n      data: {resource: resource_id},\n      timeout: pcs_timeout,\n      success: function(data) {\n        if (data['error']) {\n          alert(\"Unable to enable resource '\" + resource_id + \"': (\" + data['stderr'] + \")\");\n        }\n      },\n      error: function(xhr, status, error) {\n        alert(\n          \"Unable to enable resource '\" + resource_id + \"' \"\n          + ajax_simple_error(xhr, status, error)\n        );\n      },\n      complete: function() {\n        Pcs.update();\n      }\n    });\n  },\n\n  disable_resource: function(resource_id) {\n    if (resource_id == null) {\n      return;\n    }\n    $.ajax({\n      type: 'POST',\n      url: get_cluster_remote_url() + 'resource_stop',\n      data: {resource: resource_id},\n      timeout: pcs_timeout,\n      success: function(data) {\n        if (data['error']) {\n          alert(\"Unable to disable resource '\" + resource_id + \"': (\" + data['stderr'] + \")\");\n        }\n      },\n      error: function(xhr, status, error) {\n        alert(\n          \"Unable to disable resource '\" + resource_id + \"' \"\n          + ajax_simple_error(xhr, status, error)\n        );\n      },\n      complete: function() {\n        Pcs.update();\n      }\n    });\n  },\n\n  delete_resources: function(type, resource_list) {\n    var self = this;\n    var list = self.get(type);\n    $.each(resource_list, function(i, resource) {\n      list.removeObject(resource);\n    });\n  },\n\n  delete_unused_resources: function(type, used_map) {\n    var self = this;\n    var to_delete = [];\n    var list = self.get(type);\n    $.each(list, function(i, resource) {\n      if (!(resource.get('id') in used_map)) {\n        to_delete.push(resource);\n      }\n    });\n    self.delete_resources(type, to_delete);\n  },\n\n  update: function(data) {\n    var self = this;\n    self.set('group_list', data['groups']);\n    self.set(\"data_version\", data['status_version']);\n    var resources = data[\"resource_list\"];\n    var resource_obj = null;\n    var resource_id;\n    var new_resource_map = {};\n    var top_resource_map = {};\n    $.each(resources, function(index, resource) {\n      var update = false;\n      resource_id = resource.id;\n      if (resource_id in self.get('top_level_resource_map')) {\n        resource_obj = self.get('top_level_resource_map')[resource_id];\n        resource_obj.update(resource_obj, resource);\n        update = true;\n      } else {\n        switch (resource[\"class_type\"]) {\n          case \"primitive\":\n            resource_obj = Pcs.PrimitiveObj.create(resource);\n            break;\n          case \"group\":\n            resource_obj = Pcs.GroupObj.create(resource);\n            break;\n          case \"clone\":\n            resource_obj = Pcs.CloneObj.create(resource);\n            break;\n          case \"master\":\n            resource_obj = Pcs.MasterSlaveObj.create(resource);\n            break;\n        }\n      }\n\n      top_resource_map[resource_obj.get('id')] = resource_obj;\n      $.each(self.get_family_list(resource_obj), function(index, resource) {\n        new_resource_map[resource.get('id')] = resource;\n      });\n\n      if (!update) {\n        if (resource_obj.stonith) {\n          self.get('fence_list').pushObject(resource_obj);\n        } else {\n          self.get('resource_list').pushObject(resource_obj);\n        }\n      }\n    });\n\n    self.set('top_level_resource_map', top_resource_map);\n    self.set('resource_map', new_resource_map);\n\n    self.delete_unused_resources(\"fence_list\", top_resource_map);\n    self.delete_unused_resources(\"resource_list\", top_resource_map);\n\n    var constraints = self.get_constraints(data[\"constraints\"]);\n    self.set('constraints', constraints);\n    var resource_map = self.get('resource_map');\n    update_resource_form_groups($(\"#new_resource_agent\"), self.get('group_list').sort());\n    $.each(constraints, function(const_type, cons) {\n      $.each(resource_map, function(resource_id, resource_obj) {\n        if (resource_id in cons) {\n          resource_obj.set(const_type, cons[resource_id]);\n        } else {\n          resource_obj.set(const_type, []);\n        }\n      });\n    });\n    $.each(resource_map, function(resource_id, resource_obj) {\n      resource_obj.set('group_list', self.get('group_list'));\n    });\n    self.set('resource_list', Ember.copy(self.get('resource_list')).sort(function(a,b){return a.get('id').localeCompare(b.get('id'))}));\n    self.set('fence_list', Ember.copy(self.get('fence_list')).sort(function(a,b){return a.get('id').localeCompare(b.get('id'))}));\n  }\n});\n\nPcs.resourcesContainer.reopen({\n  is_version_1: function() {\n    return (this.get(\"data_version\") == '1');\n  }.property('data_version')\n});\n\nPcs.ResourceObj = Ember.Object.extend({\n  id: null,\n  _id: Ember.computed.alias('id'),\n  name: Ember.computed.alias('id'),\n  parent: null,\n  meta_attr: [],\n  meta_attributes: Ember.computed.alias('meta_attr'),\n  disabled: false,\n  error_list: [],\n  warning_list: [],\n  group_list: [],\n  get_group_id: function() {\n    var self = this;\n    var p = self.get('parent');\n    if (p && p.get('class_type') == 'group') {\n      return p.get('id');\n    }\n    return null;\n  }.property('parent'),\n  group_selector: function() {\n    var self = this;\n    var cur_group = self.get('get_group_id');\n    var html = '<select>\\n<option value=\"\">None</option>\\n';\n    $.each(self.get('group_list'), function(_, group) {\n      html += '<option value=\"' + group + '\"';\n      if (cur_group === group) {\n        html += 'selected';\n      }\n      html += '>' + group + '</option>\\n';\n    });\n    html += '</select><input type=\"button\" value=\"Change group\" onclick=\"resource_change_group(curResource(), $(this).prev().prop(\\'value\\'));\">';\n    return html;\n  }.property('group_list', 'get_group_id'),\n  status: \"unknown\",\n  class_type: null, // property to determine type of the resource\n  resource_type: function() { // this property is just for displaying resource type in GUI\n    var t = this.get(\"class_type\");\n    return t[0].toUpperCase() + t.slice(1);\n  }.property(\"class_type\"),\n  res_type: Ember.computed.alias('resource_type'),\n  status_icon: function() {\n    var icon_class = get_status_icon_class(this.get(\"status_val\"));\n    return \"<div style=\\\"float:left;margin-right:6px;height:16px;\\\" class=\\\"\" + icon_class + \" sprites\\\"></div>\";\n  }.property(\"status_val\"),\n  status_val: function() {\n    var status_val = get_status_value(this.get('status'));\n    if (this.get('warning_list').length && status_val != get_status_value('disabled'))\n      status_val = get_status_value(\"warning\");\n    if (this.get('error_list').length)\n      status_val = get_status_value(\"error\");\n    if ((get_status_value(this.get('status')) - status_val) < 0) {\n      return get_status_value(this.get('status'));\n    } else {\n      return status_val;\n    }\n  }.property('status', 'error_list.@each.message', 'warning_list.@each.message'),\n  status_color: function() {\n    return get_status_color(this.get(\"status_val\"));\n  }.property(\"status_val\"),\n  status_style: function() {\n    var color = get_status_color(this.get(\"status_val\"));\n    return \"color: \" + color + ((color != \"green\")? \"; font-weight: bold;\" : \"\");\n  }.property(\"status_val\"),\n  show_status: function() {\n    return '<span style=\"' + this.get('status_style') + '\">' + this.get('status') + '</span>';\n  }.property(\"status_style\", \"disabled\"),\n  status_class: function() {\n    var show = ((Pcs.clusterController.get(\"show_all_resources\"))? \"\" : \"hidden \");\n    return ((this.get(\"status_val\") == get_status_value(\"ok\") || this.status == \"disabled\") ? show + \"default-hidden\" : \"\");\n  }.property(\"status_val\"),\n  status_class_fence: function() {\n    var show = ((Pcs.clusterController.get(\"show_all_fence\"))? \"\" : \"hidden \");\n    return ((this.get(\"status_val\") == get_status_value(\"ok\")) ? show + \"default-hidden\" : \"\");\n  }.property(\"status\", \"status_val\"),\n  tooltip: function() {\n    var self = this;\n    var out = \"\";\n    if (self.error_list.length > 0) {\n      out += \"<span style='color: red;  font-weight: bold;'>ERRORS:</span><br>\\n\";\n      out += get_formated_html_list(self.error_list);\n    }\n    if (self.warning_list.length > 0) {\n      out += \"<span style='color: orange;  font-weight: bold;'>WARNINGS:</span><br>\\n\";\n      out += get_formated_html_list(self.warning_list);\n    }\n    return out;\n  }.property(\"error_list.@each\", \"warning_list.@each\"),\n  span_class: function() {\n    switch (this.get(\"status_val\")) {\n      case get_status_value(\"failed\"):\n        return \"status-error\";\n      case get_status_value(\"warning\"):\n      case get_status_value(\"disabled\"):\n        return \"status-warning\";\n      default:\n        return \"\";\n    }\n  }.property(\"status_val\"),\n\n  location_constraints: [],\n  ordering_constraints: [],\n  ordering_set_constraints: [],\n  colocation_constraints: [],\n\n  get_map: function() {\n    var self = this;\n    var map = {};\n    map[self.get('id')] = self;\n    return map;\n  },\n\n  get_full_warning_list: function() {\n    var self = this;\n    var warning_list = [];\n    $.each(self.get_map(), function(name, resource){\n      warning_list = warning_list.concat(resource.get('warning_list'));\n    });\n    return warning_list;\n  },\n\n  get_full_error_list: function() {\n    var self = this;\n    var error_list = [];\n    $.each(self.get_map(), function(name, resource){\n      error_list = error_list.concat(resource.get('error_list'));\n    });\n    return error_list;\n  },\n\n  update: function(self, data) {\n    $.each(data, function(k, v) {\n      self.set(k, v);\n    });\n    self.refresh();\n  }\n});\n\nPcs.ResourceStatusObj = Ember.Object.extend({\n  id: null,\n  resource_agent: null,\n  managed: false,\n  failed: false,\n  role: null,\n  active: false,\n  orphaned: false,\n  failure_ignored: false,\n  nodes_running_on: 0,\n  pending: null,\n  node: null\n});\n\nPcs.ResourceOperationObj = Ember.Object.extend({\n  call_id: 0,\n  crm_debug_origin: null,\n  crm_feature_set: null,\n  exec_time: 0,\n  exit_reason: null,\n  id: null,\n  interval: 0,\n  last_rc_change: 0,\n  last_run: 0,\n  on_node: null,\n  op_digest: null,\n  operation: null,\n  operation_key: null,\n  op_force_restart: null,\n  op_restart_digest: null,\n  op_status: 0,\n  queue_time: 0,\n  rc_code: 0,\n  transition_key: null,\n  transition_magic: null\n});\n\nPcs.PrimitiveObj = Pcs.ResourceObj.extend({\n  agentname: null,\n  provider: null,\n  type: null,\n  stonith: false,\n  instance_attr: [],\n  instance_status: [],\n  operations: [],\n  utilization: [],\n  resource_type: Ember.computed.alias('agentname'),\n  is_primitive: true,\n  nodes_running_on: function() {\n    var self = this;\n    var nodes = [];\n    var node = null;\n    $.each(self.get('instance_status'), function(index, status) {\n      node = status.get('node');\n      if (node)\n        nodes.push(node.name);\n    });\n    return nodes;\n  }.property('instance_status.@each.node'),\n  is_in_group: function() {\n    var self = this;\n    var p = self.get('parent');\n    return (p && p.get('class_type') == 'group');\n  }.property('parent'),\n  nodes_running_on_string: function() {\n    return this.get('nodes_running_on').join(', ');\n  }.property('nodes_running_on'),\n\n  refresh: function() {\n    var self = this;\n    var stat = self.get(\"crm_status\");\n    var new_stat = [];\n    $.each(stat, function(i,v) {\n      new_stat.push(Pcs.ResourceStatusObj.create(v));\n    });\n    var ops = self.get(\"operations\");\n    var new_ops = [];\n    $.each(ops, function(i,v) {\n      new_ops.push(Pcs.ResourceOperationObj.create(v));\n    });\n    self.set(\"instance_status\", new_stat);\n    self.set(\"operations\", new_ops);\n    self.set(\"crm_status\", null);\n  },\n\n  init: function() {\n    this.refresh();\n  }\n});\n\nPcs.GroupObj = Pcs.ResourceObj.extend({\n  members: [],\n  is_group: true,\n  children: Ember.computed.alias('members'),\n\n  init: function() {\n    this.refresh();\n  },\n\n  get_map: function() {\n    var self = this;\n    var map = self._super();\n    var members = self.get('members');\n    $.each(members, function(i, m){\n      $.extend(map, m.get_map());\n    });\n    return map;\n  },\n\n  refresh: function() {\n    var self = this;\n    var members = self.get(\"members\");\n    var member;\n    var new_members = [];\n    $.each(members, function(i,v) {\n      member = Pcs.PrimitiveObj.create(v);\n      member.set('parent', self);\n      new_members.push(member);\n    });\n    self.set(\"members\", new_members);\n  }\n});\n\nPcs.MultiInstanceObj = Pcs.ResourceObj.extend({\n  member: null,\n  children: function() {\n    return [this.get('member')];\n  }.property('member'),\n  unique: false,\n  managed: false,\n  failed: false,\n  failure_ignored: false,\n  is_multi_instance: true,\n\n  get_map: function() {\n    var self = this;\n    var map = self._super();\n    $.extend(map, self.get('member').get_map());\n    return map;\n  },\n\n  init: function() {\n    this.refresh();\n  },\n\n  refresh: function() {\n    var self = this;\n    var member = self.get(\"member\");\n    var new_member = null;\n    switch (member.class_type) {\n      case \"primitive\":\n        new_member = Pcs.PrimitiveObj.create(member);\n        break;\n      case \"group\":\n        new_member = Pcs.GroupObj.create(member);\n    }\n    new_member.set('parent', self);\n    self.set(\"member\", new_member);\n  }\n});\n\nPcs.CloneObj = Pcs.MultiInstanceObj.extend({\n  is_clone: true\n});\n\nPcs.MasterSlaveObj = Pcs.MultiInstanceObj.extend({\n  masters: [],\n  slaves: [],\n  resource_type: 'Master/Slave'\n});\n\nPcs.Router.map(function() {\n  this.route(\"Configuration\", { path: \"configure\"});\n\n  this.resource(\"ACLs\", {path: \"acls/:aclrole_id\"}, function () {\n    this.route(\"new\");\n  });\n  this.route(\"ACLs\", {path: \"acls\"});\n\n  this.resource(\"Fence Devices\", {path: \"fencedevices/:stonith_id\"}, function () {\n    this.route('new');\n  });\n  this.route(\"Fence Devices\", { path: \"fencedevices\"});\n\n  this.resource(\"Resources\", {path: \"resources/:resource_id\"}, function () {\n    this.route('new');\n  });\n  this.route(\"Resources\", { path: \"resources\"});\n\n  this.resource(\"Nodes\", {path: \"nodes/:node_id\"}, function () {\n    this.route('new');\n  });\n  this.route(\"Nodes\", { path: \"nodes\"});\n\n//  this.resource(\"Resource\", {path: 'resources/:resource_id'});\n  this.route(\"Manage\", {path: \"manage\"});\n  this.route(\"Wizards\", {path: \"wizards\"});\n  this.route(\"Default Route\", { path: \"*x\" });\n});\n\nPcs.ManageRoute = Ember.Route.extend({\n  setupController: function(controller, model) {\n    select_menu(\"MANAGE\");\n  }\n});\n\nPcs.WizardsRoute = Ember.Route.extend({\n  setupController: function(controller, model) {\n    select_menu(\"WIZARDS\");\n  }\n});\n\nPcs.IndexRoute = Ember.Route.extend({\n  setupController: function(controller, model) {\n    if (\n      window.location.pathname == \"/manage\"\n      ||\n      window.location.pathname == \"/manage/\"\n    ) {\n      select_menu(\"MANAGE\");\n    }\n    else if (\n      window.location.pathname == \"/permissions\"\n      ||\n      window.location.pathname == \"/permissions/\"\n    ) {\n      select_menu(\"PERMISSIONS\");\n      Ember.run.scheduleOnce('afterRender', this, permissions_load_all);\n    }\n    else {\n      select_menu(\"NODES\");\n    }\n  }\n});\n\nPcs.DefaultRouteRoute = Ember.Route.extend({\n  setupController: function(controller, model) {\n    if (window.location.pathname.substring(0,7) == \"/manage\")\n      select_menu(\"MANAGE\");\n    else\n      select_menu(\"NODES\");\n  }\n});\n\nPcs.FenceDevicesRoute = Ember.Route.extend({\n  setupController: function(controller, model) {\n    select_menu(\"FENCE DEVICES\");\n  },\n  model: function(params) {\n    Pcs.resourcesContainer.set('fence_id_to_load', params.stonith_id);\n    return params.stonith_id;\n  }\n});\n\nPcs.NodesRoute = Ember.Route.extend({\n  setupController: function(controller, model) {\n    select_menu(\"NODES\");\n  },\n  model: function(params) {\n    Pcs.opening_node = params.node_id;\n    return null;\n  }\n});\n\nPcs.ACLsRoute = Ember.Route.extend({\n  setupController: function(controller, model) {\n    select_menu(\"ACLS\");\n  },\n  model: function(params) {\n    Pcs.opening_aclrole = params.aclrole_id;\n    return null;\n  }\n});\n\nPcs.ConfigurationRoute = Ember.Route.extend({\n  setupController: function(controller, model) {\n    select_menu(\"CONFIGURE\"); \n  }\n});\n\nPcs.ResourcesRoute = Ember.Route.extend({\n  setupController: function(controller, model) {\n    if (model) {\n      select_menu(\"RESOURCES\",model.name);\n    } else {\n      select_menu(\"RESOURCES\"); \n    }\n  },\n  model: function(params) {\n    Pcs.resourcesContainer.set('resource_id_to_load', params.resource_id);\n    return params.resource_id;\n  }\n});\n\nPcs.Setting = Ember.Object.extend({\n  name: null,\n  readable_name: null,\n  form_name: function() {\n    return \"config[\" + this.get(\"name\") + \"]\";\n  }.property(\"name\"),\n  value: null,\n  cur_val: Ember.computed.oneWay('value'),\n  type: null,\n  source: \"\",\n  default: null,\n  advanced: false,\n  longdesc: \"\",\n  shortdesc: \"\",\n  description: function() {\n    var self = this;\n    var desc = $(\"<div>\").text(self.get(\"shortdesc\")).html();\n    if (self.get(\"longdesc\")) {\n      desc += \"<br><br>\";\n      desc += $(\"<div>\").text(self.get(\"longdesc\")).html();\n    }\n    desc += \"<br><br>\";\n    desc += $(\"<div>\").text(\"Default value: \" + self.get(\"default\")).html();\n    return desc;\n  }.property(\"longdesc\", \"shortdesc\"),\n  is_boolean: function() {\n    return (this.get(\"type\") == \"boolean\");\n  }.property(\"type\"),\n  is_enum: function() {\n    return (this.get(\"type\") == \"enum\");\n  }.property(\"type\"),\n  enum: [],\n  enum_show: function() {\n    var self = this;\n    var out = [];\n    $.each(self.get(\"enum\"), function(_, val) {\n      out.push({\n        name: val,\n        value: val\n      });\n    });\n    return out;\n  }.property(\"enum.@each\")\n});\n\nPcs.Clusternode = Ember.Object.extend({\n  name: null,\n  id: Ember.computed.alias(\"name\"),\n  status: null,\n  status_unknown: function() {\n    return this.get('status') == \"unknown\";\n  }.property(\"status\"),\n  status_val: function() {\n    var status_val = get_status_value(this.get('status'));\n    if (this.get('warning_list').length)\n      status_val = get_status_value(\"warning\");\n    if (this.get('error_list').length)\n      status_val = get_status_value(\"error\");\n    if ((get_status_value(this.get('status')) - status_val) < 0) {\n      return get_status_value(this.get('status'));\n    } else {\n      return status_val;\n    }\n  }.property('status', 'error_list.@each.message', 'warning_list.@each.message'),\n  status_style: function() {\n    var color = get_status_color(this.get(\"status_val\"));\n    return \"color: \" + color + ((color != \"green\")? \"; font-weight: bold;\" : \"\");\n  }.property(\"status_val\"),\n  status_class: function() {\n    var show = ((Pcs.clusterController.get(\"show_all_nodes\"))? \"\" : \"hidden \");\n    return (\n      (this.get(\"status_val\") == get_status_value(\"ok\") || this.status == \"standby\" ||\n      this.status == \"maintenance\")\n        ? show + \"default-hidden\" : \"\"\n    );\n  }.property(\"status_val\"),\n  status_icon: function() {\n    var icon_class = get_status_icon_class(this.get(\"status_val\"));\n    return \"<div style=\\\"float:left;margin-right:6px;\\\" class=\\\"\" + icon_class + \" sprites\\\"></div>\";\n  }.property(\"status_val\"),\n  error_list: [],\n  warning_list: [],\n  tooltip: function() {\n    var self = this;\n    var out = \"\";\n    if (self.error_list && self.error_list.length > 0) {\n      out += \"<span style='color: red;  font-weight: bold;'>ERRORS:</span><br>\\n\";\n      out += get_formated_html_list(self.error_list);\n    }\n    if (self.warning_list && self.warning_list.length > 0) {\n      out += \"<span style='color: orange;  font-weight: bold;'>WARNINGS:</span><br>\\n\";\n      out += get_formated_html_list(self.warning_list);\n    }\n    return out;\n  }.property(\"error_list\", \"warning_list\"),\n  quorum: null,\n  quorum_show: function() {\n    if (this.status == \"unknown\" || this.status == \"offline\" || this.get('quorum') === null) {\n      return '<span style=\"color: orange; font-weight: bold;\">unknown</span>';\n    } else if (this.quorum) {\n      return '<span style=\"color: green;\">YES</span>';\n    } else {\n      return '<span style=\"color: red; font-weight: bold;\">NO</span>';\n    }\n  }.property(\"status\", \"quorum\"),\n  cur_node: false,\n  checked: false,\n  resources_running: [],\n  url: function() { return \"window.location='/nodes/\" + this.get(\"name\")+\"'\"\n  }.property(),\n  trclass: function(){\n    if (this.cur_node == true)\n      return \"node_selected\";\n  }.property(\"cur_node\"),\n  onmouseover: function(){\n    if (this.cur_node == true)\n      return \"\"\n    else\n      return \"hover_over(this);\"\n  }.property(\"cur_node\"),\n  onmouseout: function(){\n    if (this.cur_node == true)\n      return \"\"\n    else\n      return \"hover_out(this);\"\n  }.property(\"cur_node\"),\n  showArrow: function(){\n    if (this.cur_node != true)\n      return \"display:none;\"\n    else\n      return \"\"\n  }.property(\"cur_node\"),\n  node_name_style: function() {\n    if (this.up && !this.get('pacemaker_maintenance')) {\n      return \"\";\n    } else {\n      if (this.get(\"pacemaker_standby\") || this.get(\"pacemaker_maintenance\"))\n        return \"color: #ff6600\";\n      else\n        return \"color:red\";\n    }\n  }.property(\"up\",\"pacemaker_standby\",\"pacemaker_maintenance\"),\n  pacemaker_standby: null,\n  pacemaker_maintenance: Ember.computed.alias('is_in_maintenance'),\n  corosync_enabled: null,\n  pacemaker_enabled: null,\n  pcsd_enabled: null,\n  standby_style: function () {\n    if (this.pacemaker_standby)\n      return \"display: none;\";\n    else\n      return \"\";\n  }.property(\"pacemaker_standby\"),\n  unstandby_style: function() {\n    if (this.pacemaker_standby)\n      return \"\";\n    else\n      return \"display: none;\";\n  }.property(\"pacemaker_standby\"),\n  corosync_startup: function() {\n    if (this.corosync_enabled)\n      return \"Enabled\";\n    else\n      return \"Disabled\";\n  }.property(\"corosync_enabled\"),\n  pacemaker_startup: function() {\n    if (this.pacemaker_enabled)\n      return \"Enabled\";\n    else\n      return \"Disabled\";\n  }.property(\"pacemaker_enabled\"),\n  pcsd_startup: function() {\n    if (this.pcsd_enabled)\n      return \"Enabled\";\n    else\n      return \"Disabled\";\n  }.property(\"pcsd_enabled\"),\n  location_constraints: null,\n  node_attrs: [],\n  utilization: [],\n  is_in_maintenance: function() {\n    var self = this;\n    var result = false;\n    $.each(self.get('node_attrs'), function(_, attr) {\n      if (attr[\"name\"] == \"maintenance\") {\n        result = is_cib_true(attr[\"value\"]);\n        return false; // break foreach loop\n      }\n    });\n    return result;\n  }.property('node_attrs'),\n  fence_levels: [],\n  pcsd: null,\n  corosync_daemon: null,\n  pacemaker_daemon: null,\n});\n\nPcs.Aclrole = Ember.Object.extend({\n  name: null,\n  cur_role: false,\n  checked: false,\n  description: \"\",\n  user_list: null,\n  group_list: null,\n  trclass: function() {\n    return this.cur_role ? \"node_selected\" : \"\";\n  }.property(\"cur_role\"),\n  onmouseover: function() {\n    return this.cur_role ? \"\" : \"hover_over(this);\"\n  }.property(\"cur_role\"),\n  onmouseout: function() {\n    return this.cur_role ? \"\" : \"hover_out(this);\"\n  }.property(\"cur_role\"),\n  showArrow: function(){\n    return this.cur_role ? \"\" : \"display:none\";\n  }.property(\"cur_role\"),\n});\n\nPcs.Cluster = Ember.Object.extend({\n  name: null,\n  url_link: function(){return get_cluster_remote_url(this.name) + \"main\";}.property(\"name\"),\n  input_name: function(){return \"clusterid-\" + this.name;}.property(\"name\"),\n  div_id: function(){return \"cluster_info_\" + this.name}.property(\"name\"),\n  status: \"unknown\",\n  status_unknown: function() {\n    return this.status == \"unknown\";\n  }.property(\"status\"),\n  forbidden: function() {\n    var out = false;\n    $.each(this.get(\"error_list\"), function(key, value) {\n      if (\"forbidden\" == value[\"type\"]) {\n        out = true;\n      }\n    });\n    return out;\n  }.property(\"error_list\"),\n  status_icon: function() {\n    var icon_class = get_status_icon_class(get_status_value(this.get('status')));\n    return \"<div style=\\\"float:left;margin-right:6px;\\\" class=\\\"\" + icon_class + \" sprites\\\"></div>\";\n  }.property(\"status\"),\n  quorum_show: function() {\n    if (this.get('status') == \"unknown\") {\n      return \"<span style='color:orange'>(quorate unknown)</span>\"\n    } else if (!this.get('quorate')) {\n      return \"<span style='color: red'>(doesn't have quorum)</span>\"\n    } else {\n      return \"\"\n    }\n  }.property(\"status\", \"quorate\"),\n  nodes: [],\n  nodes_failed: 0,\n  resource_list: [],\n  resources_failed: 0,\n  fence_list: [],\n  fence_failed: 0,\n  error_list: [],\n  warning_list: [],\n  need_reauth: false,\n  quorate: false,\n\n  get_num_of_failed: function(type) {\n    var num = 0;\n    $.each(this.get(type), function(key, value) {\n      if (value.get(\"status_val\") < get_status_value(\"ok\") &&\n        value.status != \"disabled\" && value.status != \"standby\" &&\n        value.status != \"maintenance\"\n      ) {\n        num++;\n      }\n    });\n    return num;\n  },\n\n  status_sort: function(a,b) {\n    if (a.get(\"status_val\") == b.get(\"status_val\"))\n      return ((a.status == b.status) ? a.get('name').localeCompare(b.get('name')) : ((a.status > b.status) ? 1 : -1));\n    return status_comparator(a.status, b.status)\n  },\n\n  add_resources: function(data) {\n    var self = this;\n    var resources = [];\n    var fence = [];\n    var resource_obj;\n    $.each(data, function (index, resource) {\n      switch (resource[\"class_type\"]) {\n        case \"primitive\":\n          resource_obj = Pcs.PrimitiveObj.create(resource);\n          break;\n        case \"group\":\n          resource_obj = Pcs.GroupObj.create(resource);\n          break;\n        case \"clone\":\n          resource_obj = Pcs.CloneObj.create(resource);\n          break;\n        case \"master\":\n          resource_obj = Pcs.MasterSlaveObj.create(resource);\n          break;\n      }\n\n      var url_link = get_cluster_remote_url(self.get('name')) + \"main#/\" +\n        (resource_obj.get('stonith') ? \"fencedevices/\" : \"resources/\") +\n        resource_obj.get('id');\n      resource_obj.set('url_link', url_link);\n\n      resource_obj.set('warning_list', resource_obj.get_full_warning_list());\n      resource_obj.set('error_list', resource_obj.get_full_error_list());\n\n      if (resource_obj.stonith) {\n        fence.pushObject(resource_obj);\n      } else {\n        resources.pushObject(resource_obj);\n      }\n    });\n    resources.sort(self.status_sort);\n    fence.sort(self.status_sort);\n    self.set('fence_list', fence);\n    self.set('resource_list', resources);\n  },\n\n  add_nodes: function(data, node_attrs) {\n    var self = this;\n    self.set(\"need_reauth\", false);\n    var nodes = [];\n    var node;\n    $.each(data, function(key, val) {\n      if (val[\"warning_list\"]) {\n        $.each(val[\"warning_list\"], function (key, value) {\n          if (self.get('need_reauth'))\n            return false;\n          if (typeof(value.type) !== 'undefined' && value.type == \"nodes_not_authorized\") {\n            self.set(\"need_reauth\", true);\n          }\n        });\n      }\n\n      var attrs = [];\n      if (node_attrs && val[\"name\"] in node_attrs) {\n        attrs = node_attrs[val[\"name\"]];\n      }\n\n      node = Pcs.Clusternode.create({\n        name: val[\"name\"],\n        url_link: get_cluster_remote_url(self.name) + \"main#/nodes/\" + val[\"name\"],\n        status: val[\"status\"],\n        quorum: val[\"quorum\"],\n        error_list: val[\"error_list\"],\n        warning_list: val[\"warning_list\"]\n      });\n      node.set(\"node_attrs\", attrs);\n      if (node.get(\"is_in_maintenance\") && node.get('status_val') > get_status_value(\"maintenance\")) {\n        node.set(\"status\", \"maintenance\");\n      }\n      nodes.push(node);\n    });\n    nodes.sort(self.status_sort);\n    self.set(\"nodes\", nodes);\n  }\n});\n\nPcs.clusterController = Ember.Object.create({\n  cluster_list: Ember.ArrayController.create({\n    content: Ember.A(),\n    sortProperties: ['name'],\n    sortAscending: true\n  }),\n  cur_cluster: null,\n  show_all_nodes: false,\n  show_all_resources: false,\n  show_all_fence: false,\n  num_ok: 0,\n  num_error: 0,\n  num_warning: 0,\n  num_unknown: 0,\n\n  update_cur_cluster: function(cluster_name) {\n    var self = this;\n    $(\"#clusters_list div.arrow\").hide();\n    var selected_cluster = null;\n\n    $.each(self.get('cluster_list').get('content'), function(key, cluster) {\n      if (cluster.get(\"name\") == cluster_name) {\n        selected_cluster = cluster;\n        return false;\n      }\n    });\n\n    self.set('cur_cluster', selected_cluster);\n    if (selected_cluster) {\n      Ember.run.next(function() {\n        $(\"#clusters_list tr[nodeID=\" + cluster_name + \"] div.arrow\").show();\n        correct_visibility_dashboard(self.get('cur_cluster'));\n      });\n    }\n  },\n\n  update: function(data) {\n    var self = this;\n    var clusters = data[\"cluster_list\"];\n    var cluster_name_list = [];\n    self.set(\"num_ok\", 0);\n    self.set(\"num_error\", 0);\n    self.set(\"num_warning\", 0);\n    self.set(\"num_unknown\", 0);\n\n    $.each(clusters, function(key, value) {\n      cluster_name_list.push(value[\"cluster_name\"]);\n      var found = false;\n      var cluster = null;\n\n      $.each(self.get('cluster_list').get('content'), function(key, pre_existing_cluster) {\n        if (pre_existing_cluster && pre_existing_cluster.get('name') == value[\"cluster_name\"]) {\n          found = true;\n          cluster = pre_existing_cluster;\n          cluster.set(\"status\", value[\"status\"]);\n          cluster.set(\"quorate\",value[\"quorate\"]);\n          cluster.set(\"error_list\",value[\"error_list\"]);\n          cluster.set(\"warning_list\",value[\"warning_list\"]);\n        }\n      });\n\n      if (!found) {\n        cluster = Pcs.Cluster.create({\n          name: value[\"cluster_name\"],\n          status: value[\"status\"],\n          quorate: value[\"quorate\"],\n          error_list: value[\"error_list\"],\n          warning_list: value[\"warning_list\"]\n        });\n      }\n\n      cluster.add_nodes(value[\"node_list\"], value[\"node_attr\"]);\n      cluster.add_resources(value[\"resource_list\"]);\n      cluster.set(\"nodes_failed\", cluster.get_num_of_failed(\"nodes\"));\n      cluster.set(\"resources_failed\", cluster.get_num_of_failed(\"resource_list\"));\n      cluster.set(\"fence_failed\", cluster.get_num_of_failed(\"fence_list\"));\n\n      if (cluster.get('status') == \"ok\") {\n        $.each(cluster.get('fence_list').concat(cluster.get('resource_list')), function(index, res) {\n          if (res.get('warning_list').length > 0) {\n            cluster.set(\"status\", \"warning\");\n            return false;\n          }\n        });\n      }\n\n      var nodes_to_auth = [];\n      $.each(cluster.get('warning_list'), function(key, val){\n        if (val.hasOwnProperty(\"type\") && val.type == \"nodes_not_authorized\"){\n          nodes_to_auth = nodes_to_auth.concat(val['node_list']);\n        }\n      });\n      nodes_to_auth = $.unique(nodes_to_auth);\n\n      if (cluster.get('need_reauth') || nodes_to_auth.length > 0) {\n        cluster.get('warning_list').pushObject({\n          message: \"There are few authentication problems. To fix them, click <a href='#' onclick='auth_nodes_dialog(\" + JSON.stringify(nodes_to_auth) + \", null, function() {fix_auth_of_cluster();})'>here</a>.\",\n          type: \"nodes_not_authorized\",\n          node_list: self.nodes_to_auth\n        });\n      }\n\n      if (!found) {\n        self.get('cluster_list').pushObject(cluster);\n      }\n\n      if (cluster.get_num_of_failed(\"nodes\") == cluster.nodes.length) {\n        if (cluster.get('status') != \"unknown\")\n          cluster.get('warning_list').pushObject({\n            message: \"Cluster is offline\"\n          });\n\n        cluster.set(\"status\", \"unknown\");\n      }\n\n      switch (get_status_value(cluster.get('status'))) {\n        case get_status_value(\"ok\"):\n          self.incrementProperty('num_ok');\n          break;\n        case get_status_value(\"error\"):\n          self.incrementProperty('num_error');\n          break;\n        case get_status_value(\"warning\"):\n          self.incrementProperty('num_warning');\n          break;\n        default:\n          self.incrementProperty('num_unknown');\n          break;\n      }\n    });\n\n    var to_remove = [];\n    $.each(self.get('cluster_list').get('content'), function(key,val) {\n      if (cluster_name_list.indexOf(val.get('name')) == -1) {\n        to_remove.pushObject(val);\n      }\n    });\n\n    $.each(to_remove, function(index, val) {\n      self.get('cluster_list').removeObject(val);\n    });\n  }\n});\n\nPcs.aclsController = Ember.ArrayController.createWithMixins({\n  content: [],\n  cur_role: null,\n  role_list: function() {\n    if (this.get(\"roles\"))\n      return Object.keys(this.get(\"roles\"));\n    return [];\n  }.property(\"roles\"),\n  user_list: function() {\n    if (this.get(\"users\"))\n      return Object.keys(this.get(\"users\"));\n    return [];\n  }.property(\"users\"),\n  group_list: function() {\n    if (this.get(\"groups\"))\n      return Object.keys(this.get(\"groups\"));\n    return [];\n  }.property(\"groups\"),\n  load_role: function(role_row, dont_update_hash) {\n    load_row(role_row, this, 'cur_role', '#role_info_div');\n    if (!dont_update_hash) {\n      window.location.hash = \"/acls/\" + $(role_row).attr(\"nodeID\");\n    }\n  },\n  update: function(data) {\n    var self = this;\n    self.set('content',[]);\n    var my_groups = {}, my_users = {}, my_roles = {};\n    var cur_role_holder = \"\";\n    var cur_role_name = \"\";\n    if (data[\"acls\"]) {\n      if (data[\"acls\"][\"group\"]) {\n        $.each(data[\"acls\"][\"group\"], function (k2,v2) {\n          my_groups[k2] = v2;\n        });\n      }\n      if (data[\"acls\"][\"user\"]) {\n        $.each(data[\"acls\"][\"user\"], function (k2,v2) {\n          my_users[k2] = v2;\n        });\n      }\n      if (data[\"acls\"][\"role\"]) {\n        $.each(data[\"acls\"][\"role\"], function (k2,v2) {\n          my_roles[k2] = v2;\n        });\n      }\n    }\n    self.set('roles',my_roles);\n    self.set('users',my_users);\n    self.set('groups',my_groups);\n\n    cur_role_holder = self.cur_role ? self.cur_role.name : \"\";\n\n    $.each(my_roles, function(role_name, role_data) {\n      var found = false;\n      var role = null;\n      $.each(self.content, function(key, pre_existing_role) {\n        if(pre_existing_role && pre_existing_role.name == role_name) {\n          found = true;\n          role = pre_existing_role;\n          role.set(\"name\", role_name);\n          role.set(\"cur_role\", false);\n          role.set(\"description\", role_data[\"description\"]);\n        }\n      });\n      if (!found) {\n        role = Pcs.Aclrole.create({\n          name: role_name,\n          cur_role: false,\n          description: role_data[\"description\"],\n        });\n      }\n      if (role_data[\"permissions\"]) {\n        $.each(role_data[\"permissions\"], function(key, permission) {\n          var parsed = permission.match(/(\\S+)\\s+(\\S+)\\s+(.+)\\((.*)\\)/);\n          role[\"permissions\"] = role[\"permissions\"] || [];\n          role[\"permissions\"].push({\n            type: parsed[1],\n            xpath_id: parsed[2],\n            query_id: parsed[3],\n            permission_id: parsed[4],\n          });\n        });\n      }\n\n      if (cur_role_holder == \"\") {\n        cur_role_name = Pcs.opening_aclrole;\n      }\n      else {\n        cur_role_name = cur_role_holder;\n      }\n      if (role.name == cur_role_name) {\n        role.set(\"cur_role\", true);\n        self.set(\"cur_role\", role);\n      }\n\n      if (!found) {\n        self.pushObject(role);\n      }\n    });\n\n    if (self.content && self.content.length > 0 && self.cur_role == null) {\n      self.set(\"cur_role\", self.content[0]);\n      self.content[0].set(\"cur_role\", true);\n    }\n\n    $.each(my_users, function(user_name, role_list) {\n      $.each(role_list, function(key1, role_name) {\n        $.each(self.content, function(key2, existing_role) {\n          if (existing_role.name == role_name) {\n            if (!existing_role.user_list) {\n              existing_role.user_list = [user_name];\n            }\n            else if (existing_role.user_list.indexOf(user_name) == -1) {\n              existing_role.user_list.push(user_name);\n            }\n          }\n        });\n      });\n    });\n    $.each(my_groups, function(group_name, role_list) {\n      $.each(role_list, function(key1, role_name) {\n        $.each(self.content, function(key2, existing_role) {\n          if (existing_role.name == role_name) {\n            if (!existing_role.group_list) {\n              existing_role.group_list = [group_name];\n            }\n            else if (existing_role.group_list.indexOf(group_name) == -1) {\n              existing_role.group_list.push(group_name);\n            }\n          }\n        });\n      });\n    });\n  }\n});\n\nPcs.settingsController = Ember.Controller.create({\n  properties: [],\n  filtered: [],\n  show_advanced: false,\n  filter: \"\",\n  update: function(properties_definition) {\n    var self = this;\n    var new_properties = [];\n    var property;\n    var value;\n    $.each(properties_definition, function(_, prop_def) {\n      property = Pcs.Setting.create(prop_def);\n      value = property.get(\"value\");\n      if (value) {\n        switch (property.get(\"type\")) {\n          case \"boolean\":\n            value = (is_cib_true(value)) ? \"true\" : \"false\";\n            break;\n          case \"enum\":\n            if (property.get(\"enum\").indexOf(value) == -1) {\n              property.get(\"enum\").push(value);\n            }\n        }\n        property.set(\"value\", value);\n      }\n      new_properties.pushObject(property);\n    });\n    // first basic and then advanced\n    self.set(\"properties\", new_properties.sort(function(a,b) {\n      if (!a.get(\"advanced\") && b.get(\"advanced\")) {\n        return -1;\n      } else if (a.get(\"advanced\") && !b.get(\"advanced\")) {\n        return 1;\n      } else {\n        return a.get('name').localeCompare(b.get('name'));\n      }\n    }));\n  }\n});\n\nPcs.settingsController.reopen({\n  filtered: function() {\n    var self = this;\n    var substr = self.get(\"filter\").toLowerCase();\n    \n    var to_show = [];\n    $.each(self.get(\"properties\"), function(_, e) {\n      if (self.get(\"show_advanced\")) {\n        to_show.pushObject(e);\n      } else if (!e.get(\"advanced\")) {\n        to_show.pushObject(e);\n      }\n    });\n\n    if (!substr) {\n      return to_show;\n    }\n    \n    var filtered = [];\n    $.each(to_show, function(_, e) {\n      if (e.get(\"name\").toLowerCase().includes(substr) || e.get(\"readable_name\").toLowerCase().includes(substr)) {\n        filtered.pushObject(e);\n      }\n    });\n    return filtered;\n  }.property(\"properties\", \"filter\", \"show_advanced\")\n});\n\nPcs.selectedNodeController = Ember.Object.createWithMixins({\n  node: null,\n  reset: function() {\n    if (Pcs.nodesController)\n      this.set('node', Pcs.nodesController.objectAt(0));\n  }\n});\n\nPcs.nodesController = Ember.ArrayController.createWithMixins({\n  content: [],\n  utilization_support: false,\n  cur_node: null,\n  cur_node_attr: function () {\n    var nc = this;\n    if (nc.get('cur_node')) {\n      return nc.get('cur_node').get('node_attrs');\n    }\n    return [];\n  }.property(\"cur_node\", \"content.@each.node_attrs\"),\n  cur_node_fence_levels: function () {\n    var ret_val = [];\n    var nc = this;\n    $.each(this.content, function(node, value) {\n      if (\"fence_levels\" in value && nc.cur_node && value[\"fence_levels\"]) {\n        if (nc.cur_node.name in value[\"fence_levels\"]) {\n          ret_val = ret_val.concat(value[\"fence_levels\"][nc.cur_node.name]);\n        }\n        return false;\n      }\n    });\n    return ret_val;\n  }.property(\"cur_node\", \"content.@each.fence_levels\"),\n  init: function(){\n    this._super();\n  },\n\n  load_node: function(node_row, dont_update_hash){\n    load_row(node_row, this, 'cur_node', '#node_info_div');\n    if (!dont_update_hash)\n      window.location.hash = \"/nodes/\" + $(node_row).attr(\"nodeID\");\n  },\n\n  update: function(data){\n    var self = this;\n    var nodes = [];\n    var corosync_nodes_online = data[\"corosync_online\"];\n    var pacemaker_nodes_online = data[\"pacemaker_online\"];\n    var pacemaker_nodes_standby = data[\"pacemaker_standby\"];\n\n    var resources_on_nodes = {};\n    var lc_on_nodes = {};\n    $.each(data['node_list'], function(index, node) {\n      nodes.push(node.name);\n\n      resources_on_nodes[node.name] = [];\n      $.each(Pcs.resourcesContainer.get('resource_map'), function(resource_id, resource_obj) {\n        var nodes_running_on = resource_obj.get('nodes_running_on');\n        if (nodes_running_on) {\n          $.each(nodes_running_on, function(index, node_name) {\n            if (node.name == node_name) {\n              resources_on_nodes[node.name].push(resource_id);\n            }\n          });\n        }\n      });\n\n      lc_on_nodes[node.name] = [];\n      if (data[\"constraints\"] && data[\"constraints\"][\"rsc_location\"]) {\n        $.each(data[\"constraints\"][\"rsc_location\"], function(key, constraint) {\n          if (constraint[\"node\"] == node.name)\n            lc_on_nodes[node.name].push(constraint)\n        });\n      }\n    });\n\n    var nodes_checked = {};\n    var cur_node_holder = \"\";\n    if (self.cur_node)\n      cur_node_holder = self.cur_node.name;\n    $.each(self.content, function (key, value) {\n      if (value.checked)\n        nodes_checked[value.name] = true;\n    });\n\n    if (data[\"nodes_utilization\"]) {\n      self.set(\"utilization_support\", true);\n    } else {\n      self.set(\"utilization_support\", false);\n    }\n\n    $.each(data['node_list'], function(_, node_obj) {\n      var node_id = node_obj.name;\n      if ($.inArray(node_id, corosync_nodes_online) > -1) {\n        corosync_online = true;\n      } else {\n        corosync_online = false;\n      }\n\n      if ($.inArray(node_id, pacemaker_nodes_online) > -1) {\n        pacemaker_online = true;\n      } else {\n        pacemaker_online = false;\n      }\n\n      if ($.inArray(node_id, pacemaker_nodes_standby) > -1) {\n        pacemaker_standby = true;\n      } else {\n        pacemaker_standby = false;\n      }\n\n      if (node_obj[\"status\"] == 'unknown') {\n        pcsd_daemon = false\n      } else {\n        pcsd_daemon = true\n      }\n\n      if (node_obj[\"notauthorized\"] == \"true\" || node_obj[\"notoken\"] == true) {\n        authorized = false;\n      } else {\n        authorized = true;\n      }\n\n      if (node_obj[\"corosync\"] && node_obj[\"pacemaker\"] &&\n        pacemaker_online && corosync_online) {\n        up_status = true;\n      } else {\n        up_status = false;\n      }\n\n      var node_attr = [];\n      if (data[\"node_attr\"] && data[\"node_attr\"][node_id]) {\n        node_attr = data[\"node_attr\"][node_id];\n      }\n\n      var utilization = [];\n      if (data[\"nodes_utilization\"] && data[\"nodes_utilization\"][node_id]) {\n        utilization = data[\"nodes_utilization\"][node_id];\n      }\n\n      found = false;\n      var node = null;\n      $.each(self.content, function(key, pre_existing_node) {\n        if (pre_existing_node && pre_existing_node.name == node_id) {\n          node = pre_existing_node;\n          found = true;\n          node.set(\"authorized\",authorized);\n          node.set(\"up\",up_status);\n          node.set(\"pcsd\",pcsd_daemon && authorized);\n          node.set(\"corosync_daemon\", node_obj[\"corosync\"]);\n          node.set(\"corosync_enabled\", node_obj[\"corosync_enabled\"]);\n          node.set(\"pacemaker_daemon\", node_obj[\"pacemaker\"]);\n          node.set(\"pacemaker_enabled\", node_obj[\"pacemaker_enabled\"]);\n          node.set(\"pcsd_enabled\", node_obj[\"pcsd_enabled\"]);\n          node.set(\"corosync\", corosync_online);\n          node.set(\"pacemaker\", pacemaker_online);\n          node.set(\"pacemaker_standby\", pacemaker_standby);\n          node.set(\"cur_node\",false);\n          node.set(\"running_resources\", Pcs.getResourcesFromID($.unique(resources_on_nodes[node_id].sort().reverse())));\n          node.set(\"location_constraints\", lc_on_nodes[node_id].sort());\n          node.set(\"uptime\", node_obj[\"uptime\"]);\n          node.set(\"node_id\", node_obj[\"id\"]);\n          node.set(\"node_attrs\", node_attr);\n          node.set(\"fence_levels\", data[\"fence_levels\"]);\n          node.set(\"status\", node_obj[\"status\"]);\n          node.set(\"utilization\", utilization);\n        }\n      });\n\n      if (found == false) {\n        var node = Pcs.Clusternode.create({\n          name: node_id,\n          authorized:  authorized,\n          up: up_status,\n          pcsd: pcsd_daemon && authorized,\n          corosync_daemon: node_obj[\"corosync\"],\n          corosync_enabled: node_obj[\"corosync_enabled\"],\n          pacemaker_daemon: node_obj[\"pacemaker\"],\n          pacemaker_enabled: node_obj[\"pacemaker_enabled\"],\n          pcsd_enabled: node_obj[\"pcsd_enabled\"],\n          corosync: corosync_online,\n          pacemaker: pacemaker_online,\n          pacemaker_standby: pacemaker_standby,\n          cur_node: false,\n          running_resources: Pcs.getResourcesFromID($.unique(resources_on_nodes[node_id].sort().reverse())),\n          location_constraints: lc_on_nodes[node_id].sort(),\n          uptime: node_obj[\"uptime\"],\n          node_id: node_obj[\"id\"],\n          node_attrs: node_attr,\n          fence_levels: data[\"fence_levels\"],\n          status: node_obj[\"status\"],\n          utilization: utilization\n        });\n      }\n      var pathname = window.location.pathname.split('/');\n\n      if (cur_node_holder == \"\") {\n        cur_node_name = Pcs.opening_node;\n      } else {\n        cur_node_name = cur_node_holder;\n      }\n      if (node.name == cur_node_name) {\n        node.set(\"cur_node\",true);\n        self.set(\"cur_node\", node);\n      }\n\n      if (nodes_checked[node.name])\n        node.set(\"checked\",true);\n\n      if (found == false)\n        self.pushObject(node);\n    });\n    if (self.content && self.content.length > 0 && self.cur_node == null) {\n      self.set(\"cur_node\", self.content[0]);\n      self.content[0].set(\"cur_node\",true);\n    }\n\n    nodesToRemove = [];\n    $.each(self.content, function (key, node) {\n      found = false;\n      $.each(nodes, function (k,v) {\n        if (v == node.name)\n          found = true;\n      });\n      if (!found) {\n        nodesToRemove.push(node);\n      }\n    });\n\n    $.each(nodesToRemove, function(k,v) {\n      self.content.removeObject(v);\n    });\n    self.set('content', Ember.copy(self.get('content').sort(function(a,b){return a.get('name').localeCompare(b.get('name'))})));\n  }\n});\n\nfunction myUpdate() {\n  Pcs.update();\n//  window.setTimeout(myUpdate,4000);\n}\n\nPcs.set('updater', Pcs.Updater.create({\n  timeout: 20000,\n  update_function: Pcs._update,\n  update_target: Pcs\n}));\n", "var pcs_timeout = 30000;\n\nfunction curResource() {\n  var obj = Pcs.resourcesContainer.get('cur_resource');\n  if (obj == null) {\n    return null;\n  }\n  return obj.get('id');\n}\n\nfunction curStonith() {\n  var obj = Pcs.resourcesContainer.get('cur_fence');\n  if (obj == null) {\n    return null;\n  }\n  return obj.get('id');\n}\n\nfunction configure_menu_show(item) {\n  $(\"#configure-\"+item).show();\n  $(\".configure-\"+item).addClass(\"selected\");\n}\n\nfunction menu_show(item,show) {\n  if (show) {\n    $(\"#\" + item + \"_menu\").addClass(\"active\");\n  } else {\n    $(\"#\" + item + \"_menu\").removeClass(\"active\");\n  }\n}\n\n// Changes the visible change when another menu is selected\n// If item is specified, we load that item as well\n// If initial is set to true, we load default (first item) on other pages\n// and load the default item on the specified page if item is set\nfunction select_menu(menu, item, initial) {\n  if (menu == \"NODES\") {\n    Pcs.set('cur_page',\"nodes\")\n    if (item)\n      Pcs.nodesController.load_node($('[nodeID='+item+']'));\n    menu_show(\"node\", true);\n  } else {\n    menu_show(\"node\", false);\n  }\n\n  if (menu == \"RESOURCES\") {\n    Pcs.set('cur_page',\"resources\");\n    menu_show(\"resource\", true);\n  } else {\n    menu_show(\"resource\", false);\n  }\n\n  if (menu == \"FENCE DEVICES\") {\n    Pcs.set('cur_page',\"stonith\");\n    menu_show(\"stonith\", true);\n  } else {\n    menu_show(\"stonith\", false);\n  }\n\n  if (menu == \"MANAGE\") {\n    Pcs.set('cur_page',\"manage\");\n    menu_show(\"cluster\", true);\n  } else {\n    menu_show(\"cluster\", false);\n  }\n\n  if (menu == \"PERMISSIONS\") {\n    Pcs.set('cur_page', \"permissions\");\n    menu_show(\"cluster\", true);\n  } else {\n    menu_show(\"cluster\", false);\n  }\n\n  if (menu == \"CONFIGURE\") {\n    Pcs.set('cur_page',\"configure\");\n    menu_show(\"configure\", true);\n  } else {\n    menu_show(\"configure\", false);\n  }\n\n  if (menu == \"ACLS\") {\n    Pcs.set('cur_page',\"acls\");\n    menu_show(\"acls\", true);\n  } else {\n    menu_show(\"acls\", false);\n  }\n\n  if (menu == \"WIZARDS\") {\n    Pcs.set('cur_page',\"wizards\");\n    menu_show(\"wizards\", true);\n  } else {\n    menu_show(\"wizards\", false);\n  }\n}\n\nfunction create_group() {\n  var num_nodes = 0;\n  var node_names = \"\";\n  $(\"#resource_list :checked\").parent().parent().each(function (index,element) {\n    if (element.getAttribute(\"nodeID\")) {\n      num_nodes++;\n      node_names += element.getAttribute(\"nodeID\") + \" \"\n    }\n  });\n\n  if (num_nodes == 0) {\n    alert(\"You must select at least one resource to add to a group\");\n    return;\n  }\n\n  $(\"#resources_to_add_to_group\").val(node_names);\n  $(\"#add_group\").dialog({\n    title: 'Create Group',\n    modal: true,\n    resizable: false,\n    buttons: {\n      Cancel: function() {\n        $(this).dialog(\"close\");\n      },\n      \"Create Group\": function() {\n        var data = $('#add_group > form').serialize();\n        var url = get_cluster_remote_url() + \"add_group\";\n        $.ajax({\n          type: \"POST\",\n          url: url,\n          data: data,\n          success: function() {\n            Pcs.update();\n            $(\"#add_group\").dialog(\"close\");\n          },\n          error: function (xhr, status, error) {\n            alert(\n              \"Error creating group \"\n              + ajax_simple_error(xhr, status, error)\n            );\n            $(\"#add_group\").dialog(\"close\");\n          }\n        });\n      }\n    }\n  });\n}\n\nfunction add_node_dialog() {\n  var buttonOpts = [\n    {\n      text: \"Add Node\",\n      id: \"add_node_submit_btn\",\n      click: function() {\n        $(\"#add_node_submit_btn\").button(\"option\", \"disabled\", true);\n        checkAddingNode();\n      }\n    },\n    {\n      text: \"Cancel\",\n      click: function() {\n        $(this).dialog(\"close\");\n      }\n    }\n  ];\n\n  buttonOpts[\"Cancel\"] = function() {\n    $(this).dialog(\"close\");\n  };\n\n  // If you hit enter it triggers the first button: Add Node\n  $('#add_node').keypress(function(e) {\n    if (e.keyCode == $.ui.keyCode.ENTER && !$(\"#add_node_submit_btn\").button(\"option\", \"disabled\")) {\n        $(\"#add_node_submit_btn\").trigger(\"click\");\n      return false;\n    }\n  });\n\n  $('#add_node').dialog({\n    title: 'Add Node',\n    modal:true,\n    resizable: false,\n    width: 'auto',\n    buttons: buttonOpts\n  });\n}\n\nfunction checkAddingNode(){\n  var nodeName = $(\"#add_node\").children(\"form\").find(\"[name='new_nodename']\").val().trim();\n  if (nodeName == \"\") {\n    $(\"#add_node_submit_btn\").button(\"option\", \"disabled\", false);\n    return false;\n  }\n\n  $.ajax({\n    type: 'GET',\n    url: '/manage/check_pcsd_status',\n    data: {\"nodes\": nodeName},\n    timeout: pcs_timeout,\n    success: function (data) {\n      var mydata = jQuery.parseJSON(data);\n      if (mydata[nodeName] == \"Unable to authenticate\") {\n        auth_nodes_dialog([nodeName], function(){$(\"#add_node_submit_btn\").trigger(\"click\");});\n        $(\"#add_node_submit_btn\").button(\"option\", \"disabled\", false);\n      } else if (mydata[nodeName] == \"Offline\") {\n        alert(\"Unable to contact node '\" + nodeName + \"'\");\n        $(\"#add_node_submit_btn\").button(\"option\", \"disabled\", false);\n      } else {\n        create_node($(\"#add_node\").children(\"form\"));\n      }\n    },\n    error: function (XMLHttpRequest, textStatus, errorThrown) {\n      alert(\"ERROR: Unable to contact server\");\n      $(\"#add_node_submit_btn\").button(\"option\", \"disabled\", false);\n    }\n  });\n}\n\nfunction create_node(form) {\n  var dataString = $(form).serialize();\n  $.ajax({\n    type: \"POST\",\n    url: get_cluster_remote_url() + \"add_node_to_cluster\",\n    data: dataString,\n    success: function(returnValue) {\n      $(\"#add_node_submit_btn\").button(\"option\", \"disabled\", false);\n      $('#add_node').dialog('close');\n      Pcs.update();\n    },\n    error: function(error) {\n      alert(error.responseText);\n      $(\"#add_node_submit_btn\").button(\"option\", \"disabled\", false);\n    }\n  });\n}\n\n// If update is set to true we update the resource instead of create it\n// if stonith is set to true we update/create a stonith agent\nfunction create_resource(form, update, stonith) {\n  dataString = $(form).serialize();\n  var resourceID = $(form).find(\"[name='name']\").val(); \n  url = get_cluster_remote_url() + $(form).attr(\"action\");\n  var name;\n\n  if (stonith)\n    name = \"fence device\";\n  else\n    name = \"resource\"\n\n  $.ajax({\n    type: \"POST\",\n    url: url,\n    data: dataString,\n    dataType: \"json\",\n    success: function(returnValue) {\n      $('input.apply_changes').show();\n      if (returnValue[\"error\"] == \"true\") {\n        alert(returnValue[\"stderr\"]);\n      } else {\n        Pcs.update();\n        if (!update) {\n          if (stonith)\n            $('#add_stonith').dialog('close');\n          else\n            $('#add_resource').dialog('close');\n        } else {\n          reload_current_resource();\n        }\n      }\n    },\n    error: function(xhr, status, error) {\n      if (update) {\n        alert(\n          \"Unable to update \" + name + \" \"\n          + ajax_simple_error(xhr, status, error)\n        );\n      }\n      else {\n        alert(\n          \"Unable to add \" + name + \" \"\n          + ajax_simple_error(xhr, status, error)\n        );\n      }\n      $('input.apply_changes').show();\n    }\n  });\n}\n\n// Don't allow spaces in input fields\nfunction disable_spaces(item) {\n  myitem = item;\n  $(item).find(\"input\").on(\"keydown\", function (e) {\n    return e.which !== 32;\n  });\n}\n\nfunction load_resource_form(item, ra, stonith) {\n  var data = { new: true, resourcename: ra};\n  var command;\n  if (!stonith)\n    command = \"resource_metadata\";\n  else\n    command = \"fence_device_metadata\";\n  \n  item.load(get_cluster_remote_url() + command, data);\n}\n\nfunction update_resource_form_groups(form, group_list) {\n  var select = $(form).find(\"select[name='resource_group']\").first();\n  if (select.length < 1) {\n    return;\n  }\n  var selected = select.val();\n  var selected_valid = false;\n  var select_new = select.clone();\n  select_new.empty();\n  select_new.append('<option value=\"\">None</options>');\n  $.each(group_list, function(index, group) {\n    select_new.append('<option value=\"' + group + '\">' + group + '</options>');\n    if (selected == group) {\n      selected_valid = true;\n    }\n  });\n  if (selected_valid) {\n    select_new.val(selected);\n  }\n  select.replaceWith(select_new);\n}\n\nfunction verify_remove(remove_func, forceable, checklist_id, dialog_id, label, ok_text, title, remove_id) {\n  var remove_id_list = new Array();\n  if (remove_id) {\n    remove_id_list = [remove_id];\n  }\n  else {\n    remove_id_list = get_checked_ids_from_nodelist(checklist_id);\n  }\n  if (remove_id_list.length < 1) {\n    alert(\"You must select at least one \" + label + \" to remove.\");\n    return;\n  }\n\n  var buttonOpts = [\n    {\n      text: ok_text,\n      id: \"verify_remove_submit_btn\",\n      click: function() {\n        if (remove_id_list.length < 1) {\n          return;\n        }\n        $(\"#verify_remove_submit_btn\").button(\"option\", \"disabled\", true);\n        if (forceable) {\n          force = $(\"#\" + dialog_id + \" :checked\").length > 0\n          remove_func(remove_id_list, force);\n        }\n        else {\n          remove_func(remove_id_list);\n        }\n      }\n    },\n    {\n      text: \"Cancel\",\n      id: \"verify_remove_cancel_btn\",\n      click: function() {\n        $(this).dialog(\"destroy\");\n        if (forceable) {\n          $(\"#\" + dialog_id + \" input[name=force]\").attr(\"checked\", false);\n        }\n      }\n    }\n  ];\n\n  var name_list = \"<ul>\";\n  $.each(remove_id_list, function(key, remid) {\n    name_list += \"<li>\" + remid + \"</li>\";\n  });\n  name_list += \"</ul>\";\n  $(\"#\" + dialog_id + \" .name_list\").html(name_list);\n  $(\"#\" + dialog_id).dialog({\n    title: title,\n    modal: true,\n    resizable: false,\n    buttons: buttonOpts\n  });\n}\n\nfunction verify_remove_clusters(cluster_id) {\n  verify_remove(\n    remove_cluster, false, \"cluster_list\", \"dialog_verify_remove_clusters\",\n    \"cluster\", \"Remove Cluster(s)\", \"Cluster Removal\", cluster_id\n  );\n}\n\nfunction verify_remove_nodes(node_id) {\n  verify_remove(\n    remove_nodes, false, \"node_list\", \"dialog_verify_remove_nodes\",\n    \"node\", \"Remove Node(s)\", \"Remove Node\", node_id\n  );\n}\n\nfunction verify_remove_resources(resource_id) {\n  verify_remove(\n    remove_resource, true, \"resource_list\", \"dialog_verify_remove_resources\",\n    \"resource\", \"Remove resource(s)\", \"Resurce Removal\", resource_id\n  );\n}\n\nfunction verify_remove_fence_devices(resource_id) {\n  verify_remove(\n    remove_resource, false, \"stonith_list\", \"dialog_verify_remove_resources\",\n    \"fence device\", \"Remove device(s)\", \"Fence Device Removal\", resource_id\n  );\n}\n\nfunction verify_remove_acl_roles(role_id) {\n  verify_remove(\n    remove_acl_roles, false, \"acls_roles_list\", \"dialog_verify_remove_acl_roles\",\n    \"ACL role\", \"Remove Role(s)\", \"Remove ACL Role\", role_id\n  );\n}\n\nfunction get_checked_ids_from_nodelist(nodelist_id) {\n  var ids = new Array()\n  $(\"#\" + nodelist_id + \" .node_list_check :checked\").each(function (index, element) {\n    if($(element).parent().parent().attr(\"nodeID\")) {\n      ids.push($(element).parent().parent().attr(\"nodeID\"));\n    }\n  });\n  return ids;\n}\n\nfunction local_node_update(node, data) {\n  node_data = data[node];\n\n  for (var n in data) {\n    if (data[n].pacemaker_online && (jQuery.inArray(n, data[n].pacemaker_online) != -1)) {\n      setNodeStatus(n, true);\n    } else {\n      setNodeStatus(n,false);\n    }\n  }\n}\n\nfunction disable_checkbox_clicks() {\n  $('.node_list_check input[type=checkbox]').click(function(e) {\n    e.stopPropagation();\n  });\n}\n\n// Set the status of a service\n// 0 = Running (green)\n// 1 = Stopped (red)\n// 2 = Unknown (gray)\nfunction setStatus(item, status, message) {\n  if (status == 0) {\n    item.removeClass();\n    item.addClass('status');\n  } else if (status == 1) {\n    item.removeClass();\n    item.addClass('status-offline');\n  } else if (status == 2) {\n    item.removeClass();\n    item.addClass('status-unknown');\n  }\n\n  if (typeof message !== 'undefined')\n    item.html(message)\n}\n\n// Set the node in the node list blue or red depending on\n// whether pacemaker is connected or not\nfunction setNodeStatus(node, running) {\n  if (running) {\n    $('.node_name:contains(\"'+node+'\")').css('color','');\n  } else {\n    $('.node_name:contains(\"'+node+'\")').css('color','red');\n  }\n}\n  \n\nfunction fade_in_out(id) {\n  $(id).fadeTo(1000, 0.01, function() {\n    $(id).fadeTo(1000, 1);\n  });\n}\n\nfunction node_link_action(link_selector, url, label) {\n  var node = $.trim($(\"#node_info_header_title_name\").text());\n  fade_in_out(link_selector);\n  $.ajax({\n    type: 'POST',\n    url: url,\n    data: {\"name\": node},\n    success: function() {\n    },\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to \" + label + \" node '\" + node + \"' \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    }\n  });\n}\n\nfunction setup_node_links() {\n  Ember.debug(\"Setup node links\");\n  $(\"#node_start\").click(function() {\n    node_link_action(\n      \"#node_start\", get_cluster_remote_url() +\"cluster_start\", \"start\"\n    );\n  });\n  $(\"#node_stop\").click(function() {\n    var node = $.trim($(\"#node_info_header_title_name\").text());\n    fade_in_out(\"#node_stop\");\n    node_stop(node, false);\n  });\n  $(\"#node_restart\").click(function() {\n    node_link_action(\n      \"#node_restart\", get_cluster_remote_url() + \"node_restart\", \"restart\"\n    );\n  });\n  $(\"#node_standby\").click(function() {\n    node_link_action(\n      \"#node_standby\", get_cluster_remote_url() + \"node_standby\", \"standby\"\n    );\n  });\n  $(\"#node_unstandby\").click(function() {\n    node_link_action(\n      \"#node_unstandby\",\n      get_cluster_remote_url() + \"node_unstandby\",\n      \"unstandby\"\n    );\n  });\n}\n\nfunction node_stop(node, force) {\n  var data = {};\n  data[\"name\"] = node;\n  if (force) {\n    data[\"force\"] = force;\n  }\n  $.ajax({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'cluster_stop',\n    data: data,\n    timeout: pcs_timeout,\n    success: function() {\n    },\n    error: function(xhr, status, error) {\n      if ((status == \"timeout\") || ($.trim(error) == \"timeout\")) {\n        /*\n         We are not interested in timeout because:\n         - it can take minutes to stop a node (resources running on it have\n           to be stopped/moved and we do not need to wait for that)\n         - if pcs is not able to stop a node it returns an (forceable) error\n           immediatelly\n        */\n        return;\n      }\n      var message = \"Unable to stop node '\" + node + \" \" + ajax_simple_error(\n        xhr, status, error\n      );\n      if (message.indexOf('--force') == -1) {\n        alert(message);\n      }\n      else {\n        message = message.replace(', use --force to override', '');\n        if (confirm(message + \"\\n\\nDo you want to force the operation?\")) {\n          node_stop(node, true);\n        }\n      }\n    }\n  });\n}\n\nfunction enable_resource() {\n  fade_in_out(\"#resource_start_link\");\n  Pcs.resourcesContainer.enable_resource(curResource());\n}\n\nfunction disable_resource() {\n  fade_in_out(\"#resource_stop_link\");\n  Pcs.resourcesContainer.disable_resource(curResource());\n}\n\nfunction cleanup_resource() {\n  var resource = curResource();\n  if (resource == null) {\n    return;\n  }\n  fade_in_out(\"#resource_cleanup_link\");\n  $.ajax({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'resource_cleanup',\n    data: {\"resource\": resource},\n    success: function() {\n    },\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to cleanup resource '\" + resource + \"' \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    }\n  });\n}\n\nfunction cleanup_stonith() {\n  var resource = curStonith();\n  if (resource == null) {\n    return;\n  }\n  fade_in_out(\"#stonith_cleanup_link\");\n  $.ajax({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'resource_cleanup',\n    data: {\"resource\": resource},\n    success: function() {\n    },\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to cleanup resource '\" + resource + \"' \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    }\n  });\n}\n\nfunction checkExistingNode() {\n  var node = \"\";\n  $('input[name=\"node-name\"]').each(function(i,e) {\n    node = e.value;\n  });\n\n  $.ajax({\n    type: 'GET',\n    url: '/manage/check_pcsd_status',\n    data: {\"nodes\": node},\n    timeout: pcs_timeout,\n    success: function (data) {\n      mydata = jQuery.parseJSON(data);\n      update_existing_cluster_dialog(mydata);\n\n    },\n    error: function (XMLHttpRequest, textStatus, errorThrown) {\n      alert(\"ERROR: Unable to contact server\");\n    }\n  });\n}\n\nfunction checkClusterNodes() {\n  var nodes = [];\n  $('input[name^=\"node-\"]').each(function(i,e) {\n    if (e.value != \"\") {\n      nodes.push(e.value)\n    }\n  });\n\n  $.ajax({\n    type: 'GET',\n    url: '/manage/check_pcsd_status',\n    data: {\"nodes\": nodes.join(\",\")},\n    timeout: pcs_timeout,\n    success: function (data) {\n      mydata = jQuery.parseJSON(data);\n      $.ajax({\n        type: 'GET',\n        url: '/manage/get_nodes_sw_versions',\n        data: {\"nodes\": nodes.join(\",\")},\n        timeout: pcs_timeout,\n        success: function(data) {\n          versions = jQuery.parseJSON(data);\n          update_create_cluster_dialog(mydata, versions);\n        },\n        error: function (XMLHttpRequest, textStatus, errorThrown) {\n          alert(\"ERROR: Unable to contact server\");\n        }\n      });\n    },\n    error: function (XMLHttpRequest, textStatus, errorThrown) {\n      alert(\"ERROR: Unable to contact server\");\n    }\n  });\n}\n\nfunction auth_nodes(dialog) {\n  $(\"#auth_failed_error_msg\").hide();\n  $.ajax({\n    type: 'POST',\n    url: '/manage/auth_gui_against_nodes',\n    data: dialog.find(\"#auth_nodes_form\").serialize(),\n    timeout: pcs_timeout,\n    success: function (data) {\n      mydata = jQuery.parseJSON(data);\n      auth_nodes_dialog_update(dialog, mydata);\n    },\n    error: function (XMLHttpRequest, textStatus, errorThrown) {\n      alert(\"ERROR: Unable to contact server\");\n    }\n  });\n}\n\nfunction auth_nodes_dialog_update(dialog_obj, data) {\n  var unauth_nodes = [];\n  var node;\n  if (data['node_auth_error']) {\n    for (node in data['node_auth_error']) {\n      if (data['node_auth_error'][node] != 0) {\n        unauth_nodes.push(node);\n      }\n    }\n  }\n\n  var callback_one = dialog_obj.dialog(\"option\", \"callback_success_one_\");\n  var callback = dialog_obj.dialog(\"option\", \"callback_success_\");\n  if (unauth_nodes.length == 0) {\n    dialog_obj.parent().find(\"#authenticate_submit_btn\").button(\n      \"option\", \"disabled\", false\n    );\n    dialog_obj.find(\"#auth_failed_error_msg\").hide();\n    dialog_obj.dialog(\"close\");\n    if (callback_one !== null)\n      callback_one();\n    if (callback !== null)\n      callback();\n    return unauth_nodes;\n  } else {\n    dialog_obj.find(\"#auth_failed_error_msg\").show();\n  }\n\n  if (unauth_nodes.length == 1) {\n    dialog_obj.find(\"#same_pass\").hide();\n    dialog_obj.find('#auth_nodes_list').find('input:password').each(\n      function(){$(this).show()}\n    );\n  }\n\n  var one_success = false;\n  dialog_obj.find(\"input:password[name$=-pass]\").each(function() {\n    node = $(this).attr(\"name\");\n    node = node.substring(0, node.length - 5);\n    if (unauth_nodes.indexOf(node) == -1) {\n      $(this).parent().parent().remove();\n      one_success = true;\n    } else {\n      $(this).parent().parent().css(\"color\", \"red\");\n    }\n  });\n\n  if (one_success && callback_one !== null)\n    callback_one();\n\n  dialog_obj.parent().find(\"#authenticate_submit_btn\").button(\n    \"option\", \"disabled\", false\n  );\n  return unauth_nodes;\n}\n\nfunction auth_nodes_dialog(unauth_nodes, callback_success, callback_success_one) {\n  callback_success = typeof callback_success !== 'undefined' ? callback_success : null;\n  callback_success_one = typeof callback_success_one !== 'undefined' ? callback_success_one : null;\n\n  var buttonsOpts = [\n    {\n      text: \"Authenticate\",\n      id: \"authenticate_submit_btn\",\n      click: function() {\n        var dialog = $(this);\n        dialog.parent().find(\"#authenticate_submit_btn\").button(\n          \"option\", \"disabled\", true\n        );\n        dialog.find(\"table.err_msg_table\").find(\"span[id$=_error_msg]\").hide();\n        auth_nodes(dialog);\n      }\n    },\n    {\n      text:\"Cancel\",\n      click: function () {\n        $(this).dialog(\"close\");\n      }\n    }\n  ];\n  var dialog_obj = $(\"#auth_nodes\").dialog({title: 'Authentification of nodes',\n    modal: true, resizable: false,\n    width: 'auto',\n    buttons: buttonsOpts,\n    callback_success_: callback_success,\n    callback_success_one_: callback_success_one\n  });\n\n  dialog_obj.find(\"#auth_failed_error_msg\").hide();\n\n  // If you hit enter it triggers the submit button\n  dialog_obj.keypress(function(e) {\n    if (e.keyCode == $.ui.keyCode.ENTER && !dialog_obj.parent().find(\"#authenticate_submit_btn\").button(\"option\", \"disabled\")) {\n      dialog_obj.parent().find(\"#authenticate_submit_btn\").trigger(\"click\");\n      return false;\n    }\n  });\n\n  if (unauth_nodes.length == 0) {\n    if (callback_success !== null) {\n      callback_success();\n    }\n    return;\n  }\n\n  if (unauth_nodes.length == 1) {\n    dialog_obj.find(\"#same_pass\").hide();\n  } else {\n    dialog_obj.find(\"#same_pass\").show();\n    dialog_obj.find(\"input:checkbox[name=all]\").prop(\"checked\", false);\n    dialog_obj.find(\"#pass_for_all\").val(\"\");\n    dialog_obj.find(\"#pass_for_all\").hide();\n  }\n\n  dialog_obj.find('#auth_nodes_list').empty();\n  unauth_nodes.forEach(function(node) {\n    dialog_obj.find('#auth_nodes_list').append(\"\\t\\t\\t<tr><td>\" + node + '</td><td><input type=\"password\" name=\"' + node + '-pass\"></td></tr>\\n');\n  });\n\n}\n\nfunction add_existing_dialog() {\n  var buttonOpts = [\n    {\n      text: \"Add Existing\",\n      id: \"add_existing_submit_btn\",\n      click: function () {\n        $(\"#add_existing_cluster\").find(\"table.err_msg_table\").find(\"span[id$=_error_msg]\").hide();\n        $(\"#add_existing_submit_btn\").button(\"option\", \"disabled\", true);\n        checkExistingNode();\n      }\n    },\n    {\n      text: \"Cancel\",\n      click: function() {\n        $(this).dialog(\"close\");\n      }\n    }\n  ];\n\n  // If you hit enter it triggers the first button: Add Existing\n  $('#add_existing_cluster').keypress(function(e) {\n    if (e.keyCode == $.ui.keyCode.ENTER && !$(\"#add_existing_submit_btn\").button(\"option\", \"disabled\")) {\n      $(this).parent().find(\"button:eq(1)\").trigger(\"click\");\n      return false;\n    }\n  });\n\n  $(\"#add_existing_cluster\").dialog({title: 'Add Existing Cluster',\n    modal: false, resizable: false,\n    width: 'auto',\n    buttons: buttonOpts\n  });\n}\n\nfunction update_existing_cluster_dialog(data) {\n  for (var i in data) {\n    if (data[i] == \"Online\") {\n      $.ajax({\n        type: \"POST\",\n        url: \"/manage/existingcluster\",\n        timeout: pcs_timeout,\n        data: $('#add_existing_cluster_form').serialize(),\n        success: function(data) {\n          if (data) {\n            alert(\"Operation Successful!\\n\\nWarnings:\\n\" + data);\n          }\n          $(\"#add_existing_cluster.ui-dialog-content\").each(function(key, item) {$(item).dialog(\"destroy\")});\n          Pcs.update();\n        },\n        error: function (xhr, status, error) {\n          alert(xhr.responseText);\n          $(\"#add_existing_submit_btn\").button(\"option\", \"disabled\", false);\n        }\n      });\n      return;\n    } else if (data[i] == \"Unable to authenticate\") {\n      auth_nodes_dialog([i], function() {$(\"#add_existing_submit_btn\").trigger(\"click\");});\n      $(\"#add_existing_submit_btn\").button(\"option\", \"disabled\", false);\n      return;\n    }\n    break;\n  }\n  if (data.length > 0) {\n    $('#add_existing_cluster_error_msg').html(i + \": \" + data[i]);\n    $('#add_existing_cluster_error_msg').show();\n  }\n  $('#unable_to_connect_error_msg_ae').show();\n  $(\"#add_existing_submit_btn\").button(\"option\", \"disabled\", false);\n}\n\nfunction update_create_cluster_dialog(nodes, version_info) {\n  var keys = [];\n  for (var i in nodes) {\n    if (nodes.hasOwnProperty(i)) {\n      keys.push(i);\n    }\n  }\n\n  var cant_connect_nodes = 0;\n  var cant_auth_nodes = [];\n  var good_nodes = 0;\n  var addr1_match = 1;\n  var ring0_nodes = [];\n  var ring1_nodes = [];\n  var cman_nodes = [];\n  var noncman_nodes = [];\n  var rhel_versions = [];\n  var versions_check_ok = 1;\n  var cluster_name = $('input[name^=\"clustername\"]').val()\n  var transport = $(\"#create_new_cluster select[name='config-transport']\").val()\n\n    $('#create_new_cluster input[name^=\"node-\"]').each(function() {\n      if ($(this).val() == \"\") {\n        $(this).parent().prev().css(\"background-color\", \"\");\n        return;\n      }\n      for (var i = 0; i < keys.length; i++) {\n        if ($(this).val() == keys[i]) {\n          if (nodes[keys[i]] != \"Online\") {\n            if (nodes[keys[i]] == \"Unable to authenticate\") {\n              cant_auth_nodes.push(keys[i]);\n            } else {\n              $(this).parent().prev().css(\"background-color\", \"red\");\n              cant_connect_nodes++;\n            }\n          } else {\n            $(this).parent().prev().css(\"background-color\", \"\");\n            good_nodes++;\n          }\n        }\n      }\n    });\n\n    if (cant_auth_nodes.length > 0) {\n      auth_nodes_dialog(cant_auth_nodes, function(){$(\"#create_cluster_submit_btn\").trigger(\"click\")});\n      $(\"#create_cluster_submit_btn\").button(\"option\", \"disabled\", false);\n      return;\n    }\n\n  if (transport == \"udpu\") {\n    $('#create_new_cluster input[name^=\"node-\"]').each(function() {\n      if ($(this).val().trim() != \"\") {\n        ring0_nodes.push($(this).attr(\"name\"));\n      }\n    });\n    $('#create_new_cluster input[name^=\"ring1-node-\"]').each(function() {\n      if ($(this).val().trim() != \"\") {\n        ring1_nodes.push($(this).attr(\"name\").substr(\"ring1-\".length));\n      }\n    });\n    if (ring1_nodes.length > 0) {\n      if (ring0_nodes.length != ring1_nodes.length) {\n        addr1_match = 0\n      }\n      else {\n        for (var i = 0; i < ring0_nodes.length; i++) {\n          if (ring0_nodes[i] != ring1_nodes[i]) {\n            addr1_match = 0;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  if(version_info) {\n    $.each(version_info, function(node, versions) {\n      if(! versions[\"pcs\"]) {\n        // we do not have valid info for this node\n        return;\n      }\n      if(versions[\"cman\"]) {\n        cman_nodes.push(node);\n      }\n      else {\n        noncman_nodes.push(node);\n      }\n      if(versions[\"rhel\"]) {\n        if($.inArray(versions[\"rhel\"].join(\".\"), rhel_versions) == -1) {\n          rhel_versions.push(versions[\"rhel\"].join(\".\"))\n        }\n      }\n    });\n  }\n\n  if (cant_connect_nodes != 0) {\n    $(\"#unable_to_connect_error_msg\").show();\n  } else {\n    $(\"#unable_to_connect_error_msg\").hide();\n  }\n\n  if (good_nodes == 0 && cant_connect_nodes == 0) {\n    $(\"#at_least_one_node_error_msg\").show();\n  } else {\n    $(\"#at_least_one_node_error_msg\").hide();\n  }\n\n  if (cluster_name == \"\") {\n    $(\"#bad_cluster_name_error_msg\").show();\n  } else {\n    $(\"#bad_cluster_name_error_msg\").hide();\n  }\n\n  if (addr1_match == 0) {\n    $(\"#addr0_addr1_mismatch_error_msg\").show();\n  }\n  else {\n    $(\"#addr0_addr1_mismatch_error_msg\").hide();\n  }\n  if(versions) {\n    if(cman_nodes.length > 0 && transport == \"udpu\") {\n      if(noncman_nodes.length < 1 && ring1_nodes.length < 1) {\n        transport = \"udp\";\n        $(\"#create_new_cluster select[name='config-transport']\").val(transport);\n        create_cluster_display_rrp(transport);\n      }\n      else {\n        versions_check_ok = 0;\n        $(\"#cman_udpu_transport_error_msg\").show();\n      }\n    }\n    else {\n      $(\"#cman_udpu_transport_error_msg\").hide();\n    }\n\n    if(cman_nodes.length > 1 && noncman_nodes.length > 1) {\n      versions_check_ok = 0;\n      $(\"#cman_mismatch_error_msg\").show();\n    }\n    else {\n      $(\"#cman_mismatch_error_msg\").hide();\n    }\n\n    if(rhel_versions.length > 1) {\n      versions_check_ok = 0;\n      $(\"#rhel_version_mismatch_error_msg\").show();\n    }\n    else {\n      $(\"#rhel_version_mismatch_error_msg\").hide();\n    }\n  }\n  else {\n    $(\"#cman_udpu_transport_error_msg\").hide();\n    $(\"#cman_mismatch_error_msg\").hide();\n    $(\"#rhel_version_mismatch_error_msg\").hide();\n  }\n\n  if (good_nodes != 0 && cant_connect_nodes == 0 && cant_auth_nodes.length == 0 && cluster_name != \"\" && addr1_match == 1 && versions_check_ok == 1) {\n    $.ajax({\n      type: \"POST\",\n      url: \"/manage/newcluster\",\n      timeout: pcs_timeout,\n      data: $('#create_new_cluster_form').serialize(),\n      success: function(data) {\n        if (data) {\n          alert(\"Operation Successful!\\n\\nWarnings:\\n\" + data);\n        }\n        $(\"#create_new_cluster.ui-dialog-content\").each(function(key, item) {$(item).dialog(\"destroy\")});\n        Pcs.update();\n      },\n      error: function (xhr, status, error) {\n        alert(xhr.responseText);\n        $(\"#create_cluster_submit_btn\").button(\"option\", \"disabled\", false);\n      }\n    });\n  } else {\n    $(\"#create_cluster_submit_btn\").button(\"option\", \"disabled\", false);\n  }\n\n}\n\nfunction create_cluster_dialog() {\n  var buttonOpts = [{\n    text: \"Create Cluster\",\n    id: \"create_cluster_submit_btn\",\n    click: function() {\n      $(\"#create_new_cluster\").find(\"table.err_msg_table\").find(\"span[id$=_error_msg]\").hide();\n      $(\"#create_cluster_submit_btn\").button(\"option\", \"disabled\", true);\n      checkClusterNodes();\n    }\n  },\n  {\n    text: \"Cancel\",\n    id: \"create_cluster_cancel_btn\",\n    click: function() {\n      $(this).dialog(\"close\");\n    }\n  }]\n\n  $(\"#create_new_cluster\").dialog({title: 'Create Cluster',\n    modal: false, resizable: false,\n    width: 'auto',\n    buttons: buttonOpts\n  });\n}\n\nfunction create_cluster_add_nodes() {\n  node_list = $(\"#create_new_cluster_form tr\").has(\"input[name^='node-']\");;\n  var ring1_node_list = $(\"#create_new_cluster_form tr\").has(\n    \"input[name^='ring1-node-']\"\n  );\n  cur_num_nodes = node_list.length;\n\n  first_node = node_list.eq(0);\n  new_node = first_node.clone();\n  $(\"input\",new_node).attr(\"name\", \"node-\"+(cur_num_nodes+1));\n  $(\"input\",new_node).val(\"\");\n  $(\"td\", new_node).first().text(\"Node \" + (cur_num_nodes+1)+ \":\");\n  new_node.insertAfter(node_list.last());\n\n  var ring1_first_node = ring1_node_list.eq(0);\n  var ring1_new_node = ring1_first_node.clone();\n  $(\"input\", ring1_new_node).attr(\"name\", \"ring1-node-\" + (cur_num_nodes + 1));\n  $(\"input\", ring1_new_node).val(\"\");\n  $(\"td\", ring1_new_node).first().text(\n    \"Node \" + (cur_num_nodes+1) + \" (Ring 1):\"\n  );\n  ring1_new_node.insertAfter(ring1_node_list.last());\n\n  if (node_list.length == 7)\n    $(\"#create_new_cluster_form tr\").has(\"input[name^='node-']\").last().next().remove();\n}\n\nfunction create_cluster_display_rrp(transport) {\n  if(transport == 'udp') {\n    $('#rrp_udp_transport').show();\n    $('#rrp_udpu_transport').hide();\n  }\n  else {\n    $('#rrp_udp_transport').hide();\n    $('#rrp_udpu_transport').show();\n  };\n}\n\nfunction show_hide_constraints(element) {\n  //$(element).parent().siblings().each (function(index,element) {\n  $(element).parent().nextUntil(\".stop\").toggle();\n  $(element).children(\"span, p\").toggle();\n}\n\nfunction show_hide_constraint_tables(element) {\n  $(element).siblings().hide();\n  $(\"#add_constraint_\" + $(element).val()).show();\n}\n\nfunction hover_over(o) {\n  $(o).addClass(\"node_selected\");\n}\n\nfunction hover_out(o) {\n  $(o).removeClass(\"node_selected\");\n}\n\nfunction reload_current_resource() {\n  tree_view_onclick(curResource(), true);\n  tree_view_onclick(curStonith(), true);\n}\n\nfunction load_row(node_row, ac, cur_elem, containing_elem, also_set, initial_load){\n  hover_over(node_row);\n  $(node_row).siblings().each(function(key,sib) {\n    hover_out(sib);\n  });\n  var self = ac;\n  $(containing_elem).fadeTo(500, .01,function() {\n    node_name = $(node_row).attr(\"nodeID\");\n    $.each(self.content, function(key, node) {\n      if (node.name == node_name) {\n        if (!initial_load) {\n          self.set(cur_elem,node);\n        }\n        node.set(cur_elem, true);\n        if (also_set)\n          self.set(also_set, node);\n      } else {\n        if (self.cur_resource_ston && self.cur_resource_ston.name == node.name)\n          self.content[key].set(cur_elem,true);\n        else if (self.cur_resource_res && self.cur_resource_res.name == node.name)\n          self.content[key].set(cur_elem,true);\n        else\n          self.content[key].set(cur_elem,false);\n      }\n    });\n    $(containing_elem).fadeTo(500,1);\n  });\n}\n\nfunction load_agent_form(resource_id, stonith) {\n  var url;\n  var form;\n  if (stonith) {\n    form = $(\"#stonith_agent_form\");\n    url = '/managec/' + Pcs.cluster_name + '/fence_device_form';\n  } else {\n    form = $(\"#resource_agent_form\");\n    url = '/managec/' + Pcs.cluster_name + '/resource_form?version=2';\n  }\n\n  form.empty();\n\n  var resource_obj = Pcs.resourcesContainer.get_resource_by_id(resource_id);\n  if (!resource_obj || !resource_obj.get('is_primitive'))\n    return;\n\n  var data = {resource: resource_id};\n\n  $.ajax({\n    type: 'GET',\n    url: url,\n    data: data,\n    timeout: pcs_timeout,\n    success: function (data) {\n      Ember.run.next(function(){form.html(data);});\n    }\n  });\n}\n\nfunction show_loading_screen() {\n  $(\"#loading_screen_progress_bar\").progressbar({ value: 100});\n  $(\"#loading_screen\").dialog({\n    modal: true,\n    title: \"Loading\",\n    height: 100,\n    width: 250,\n    hide: {\n      effect: 'fade',\n      direction: 'down',\n      speed: 750\n    }\n  });\n}\n\nfunction hide_loading_screen() {\n  $(\"#loading_screen\").dialog('close');\n  destroy_tooltips();\n}\n\nfunction destroy_tooltips() {\n  $(\"div[id^=ui-tooltip-]\").remove();\n}\n\nfunction remove_cluster(ids) {\n  var data = {};\n  $.each(ids, function(_, cluster) {\n    data[ \"clusterid-\" + cluster] = true;\n  });\n  $.ajax({\n    type: 'POST',\n    url: '/manage/removecluster',\n    data: data,\n    timeout: pcs_timeout,\n    success: function () {\n      $(\"#dialog_verify_remove_clusters.ui-dialog-content\").each(function(key, item) {$(item).dialog(\"destroy\")});\n      Pcs.update();\n    },\n    error: function (xhr, status, error) {\n      alert(\"Unable to remove cluster: \" + res + \" (\"+error+\")\");\n      $(\"#dialog_verify_remove_clusters.ui-dialog-content\").each(function(key, item) {$(item).dialog(\"destroy\")});\n    }\n  });\n}\n\nfunction remove_nodes(ids, force) {\n  var data = {};\n  for (var i=0; i<ids.length; i++) {\n    data[\"nodename-\"+i] = ids[i];\n  }\n  if (force) {\n    data[\"force\"] = force;\n  }\n\n  $.ajax({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'remove_nodes',\n    data: data,\n    timeout: pcs_timeout*3,\n    success: function(data,textStatus) {\n      $(\"#dialog_verify_remove_nodes.ui-dialog-content\").each(function(key, item) {$(item).dialog(\"destroy\")});\n      if (data == \"No More Nodes\") {\n        window.location.href = \"/manage\";\n      } else {\n        Pcs.update();\n      }\n    },\n    error: function (xhr, status, error) {\n      $(\"#dialog_verify_remove_nodes.ui-dialog-content\").each(function(key, item) {$(item).dialog(\"destroy\")});\n      if ((status == \"timeout\") || ($.trim(error) == \"timeout\")) {\n        /*\n         We are not interested in timeout because:\n         - it can take minutes to stop a node (resources running on it have\n           to be stopped/moved and we do not need to wait for that)\n         - if pcs is not able to stop a node it returns an (forceable) error\n           immediatelly\n        */\n        return;\n      }\n      var message = \"Unable to remove nodes (\" + $.trim(error) + \")\";\n      message += \"\\n\" + xhr.responseText;\n      if (message.indexOf('--force') == -1) {\n        alert(message);\n      }\n      else {\n        message = message.replace(', use --force to override', '');\n        if (confirm(message + \"\\n\\nDo you want to force the operation?\")) {\n          remove_nodes(ids, true);\n        }\n      }\n    }\n  });\n}\n\nfunction remove_resource(ids, force) {\n  var data = {};\n  if (force) {\n    data[\"force\"] = force;\n  }\n  var res_obj;\n  $.each(ids, function(_, id) {\n    res_obj = Pcs.resourcesContainer.get_resource_by_id(id);\n    if (!res_obj) {\n      return true; // continue\n    } else if ($.inArray(res_obj.get(\"parent_id\"), ids) == -1) {\n      data[\"resid-\" + id] = true;\n    }\n  });\n\n  $.ajax({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'remove_resource',\n    data: data,\n    timeout: pcs_timeout*3,\n    success: function () {\n      $(\"#dialog_verify_remove_resources.ui-dialog-content\").each(function(key, item) {$(item).dialog(\"destroy\")});\n      $(\"#dialog_verify_remove_resources input[name=force]\").attr(\"checked\", false);\n      Pcs.update();\n    },\n    error: function (xhr, status, error) {\n      error = $.trim(error)\n      var message = \"Unable to remove resources (\" + error + \")\";\n      if (\n        (xhr.responseText.substring(0,6) == \"Error:\") || (\"Forbidden\" == error)\n      ) {\n        message += \"\\n\\n\" + xhr.responseText.replace(\"--force\", \"'Enforce removal'\");\n      }\n      alert(message);\n      $(\"#dialog_verify_remove_resources.ui-dialog-content\").each(\n        function(key, item) { $(item).dialog(\"destroy\"); }\n      );\n      $(\"#dialog_verify_remove_resources input[name=force]\").attr(\"checked\", false);\n      Pcs.update();\n    }\n  });\n}\n\nfunction add_remove_fence_level(parent_id,remove) {\n  var data = {};\n  if (remove == true) {\n    data[\"remove\"] = true;\n    data[\"level\"] = parent_id.attr(\"fence_level\");\n    data[\"node\"] = Pcs.nodesController.cur_node.name;\n    data[\"devices\"] = parent_id.attr(\"fence_devices\");\n  } else {\n    data[\"level\"] = parent_id.parent().find(\"input[name='new_level_level']\").val();\n    data[\"devices\"] = parent_id.parent().find(\"select[name='new_level_value']\").val();\n    data[\"node\"] = Pcs.nodesController.cur_node.name;\n  }\n  fade_in_out(parent_id.parent());\n  $.ajax({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'add_fence_level_remote',\n    data: data,\n    timeout: pcs_timeout,\n    success: function() {\n//      Pcs.nodesController.remove_fence_level();\n      if (!remove) {\n        $(parent_id.parent()).find(\"input\").val(\"\");\n        $(parent_id.parent()).find(\"select\").val(\"\");\n      }\n      Pcs.update();\n    },\n    error: function (xhr, status, error) {\n      if (remove) {\n        alert(\n          \"Unable to remove fence level \"\n          + ajax_simple_error(xhr, status, error)\n        );\n      }\n      else {\n        if (xhr.responseText.substring(0,6) == \"Error:\") {\n          alert(xhr.responseText);\n        } else {\n          alert(\n            \"Unable to add fence level \"\n            + ajax_simple_error(xhr, status, error)\n          );\n        }\n      }\n    }\n  });\n}\n\nfunction remove_node_attr(parent_id) {\n  var data = {};\n  data[\"node\"] = Pcs.nodesController.cur_node.name;\n  data[\"key\"] = parent_id.attr(\"node_attr_key\");\n  data[\"value\"] = \"\"; // empty value will remove attribute\n  fade_in_out(parent_id.parent());\n\n  $.ajax({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'add_node_attr_remote',\n    data: data,\n    timeout: pcs_timeout,\n    success: function() {\n//      Pcs.nodesController.remove_node_attr(data[\"res_id\"], data[\"key\"]);\n      Pcs.update();\n    },\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to remove node attribute \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    }\n  });\n}\n\nfunction add_node_attr(parent_id) {\n  var data = {};\n  data[\"node\"] = Pcs.nodesController.cur_node.name;\n  data[\"key\"] = $(parent_id + \" input[name='new_node_attr_key']\").val();\n  data[\"value\"] = $(parent_id + \" input[name='new_node_attr_value']\").val();\n  fade_in_out($(parent_id));\n\n  $.ajax({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'add_node_attr_remote',\n    data: data,\n    timeout: pcs_timeout,\n    success: function() {\n      $(parent_id + \" input\").val(\"\");\n//      Pcs.nodesController.add_node_attr(data[\"res_id\"], data[\"key\"], data[\"value\"]);\n      Pcs.update();\n    },\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to add node attribute \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    }\n  });\n}\n\nfunction node_maintenance(node) {\n  var data = {\n    node: node,\n    key: \"maintenance\",\n    value: \"on\"\n  };\n  $.ajax({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'add_node_attr_remote',\n    data: data,\n    timeout: pcs_timeout,\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to put node '\" + node + \"' to maintenance mode. \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    },\n    complete: function() {\n      Pcs.update();\n    }\n  });\n}\n\nfunction node_unmaintenance(node) {\n  var data = {\n    node: node,\n    key: \"maintenance\",\n    value: \"\"\n  };\n  $.ajax({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'add_node_attr_remote',\n    data: data,\n    timeout: pcs_timeout,\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to remove node '\" + node + \"' from maintenance mode. \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    },\n    complete: function() {\n      Pcs.update();\n    }\n  });\n}\n\nfunction remove_meta_attr(parent_id) {\n  var resource_id = curResource();\n  if (resource_id == null) {\n    return;\n  }\n  var attr = parent_id.attr(\"meta_attr_key\");\n  fade_in_out(parent_id.parent());\n  Pcs.resourcesContainer.update_meta_attr(resource_id, attr);\n}\n\nfunction add_meta_attr(parent_id) {\n  var resource_id = curResource();\n  if (resource_id == null) {\n    return;\n  }\n  var attr = $(parent_id + \" input[name='new_meta_key']\").val();\n  var value = $(parent_id + \" input[name='new_meta_value']\").val();\n  fade_in_out($(parent_id));\n  $(parent_id + \" input\").val(\"\");\n  Pcs.resourcesContainer.update_meta_attr(resource_id, attr, value);\n}\n\nfunction add_constraint(parent_id, c_type, force) {\n  var data = {};\n  data[\"disable_autocorrect\"] = true;\n  data[\"res_id\"] = Pcs.resourcesContainer.cur_resource.get('id');\n  data[\"node_id\"] = $(parent_id + \" input[name='node_id']\").val();\n  data[\"rule\"] = $(parent_id + \" input[name='node_id']\").val();\n  data[\"score\"] = $(parent_id + \" input[name='score']\").val();\n  data[\"target_res_id\"] = $(parent_id + \" input[name='target_res_id']\").val();\n  data[\"order\"] = $(parent_id + \" select[name='order']\").val();\n  data[\"target_action\"] = $(parent_id + \" select[name='target_action']\").val();\n  data[\"res_action\"] = $(parent_id + \" select[name='res_action']\").val();\n  data[\"colocation_type\"] = $(parent_id + \" select[name='colocate']\").val();\n  data[\"c_type\"] = c_type;\n  if (force) {\n    data[\"force\"] = force;\n  }\n  fade_in_out($(parent_id));\n\n  $.ajax({\n    type: 'POST',\n    url: get_cluster_remote_url() + (\n      data['node_id'] && (data['node_id'].trim().indexOf(' ') != -1)\n      ? 'add_constraint_rule_remote'\n      : 'add_constraint_remote'\n    ),\n    data: data,\n    timeout: pcs_timeout,\n    success: function() {\n      $(parent_id + \" input\").val(\"\");\n      Pcs.update();\n    },\n    error: function (xhr, status, error) {\n      var message = \"Unable to add constraint (\" + $.trim(error) + \")\";\n      var error_prefix = 'Error adding constraint: ';\n      if (xhr.responseText.indexOf('cib_replace failed') == -1) {\n        if (xhr.responseText.indexOf(error_prefix) == 0) {\n          message += \"\\n\\n\" + xhr.responseText.slice(error_prefix.length);\n        }\n        else {\n          message += \"\\n\\n\" + xhr.responseText;\n        }\n      }\n      if (message.indexOf('--force') == -1) {\n        alert(message);\n        Pcs.update();\n      }\n      else {\n        message = message.replace(', use --force to override', '');\n        message = message.replace('Use --force to override.', '');\n        if (confirm(message + \"\\n\\nDo you want to force the operation?\")) {\n          add_constraint(parent_id, c_type, true);\n        }\n      }\n    }\n  });\n}\n\nfunction add_constraint_set(parent_id, c_type, force) {\n  var data = {\n    resources: [],\n    disable_autocorrect: true\n  };\n  $(parent_id + \" input[name='resource_ids[]']\").each(function(index, element) {\n    var resources = element.value.trim();\n    if (resources.length > 0) {\n      data['resources'].push(resources.split(/\\s+/));\n    }\n  });\n  data[\"c_type\"] = c_type;\n  if (force) {\n    data[\"force\"] = force;\n  }\n  if (data['resources'].length < 1) {\n    return;\n  }\n  fade_in_out($(parent_id))\n\n  $.ajax({\n    type: \"POST\",\n    url: get_cluster_remote_url() + \"add_constraint_set_remote\",\n    data: data,\n    timeout: pcs_timeout,\n    success: function() {\n      reset_constraint_set_form(parent_id);\n      Pcs.update();\n    },\n    error: function (xhr, status, error){\n      var message = \"Unable to add constraint (\" + $.trim(error) + \")\";\n      var error_prefix = 'Error adding constraint: ';\n      if (xhr.responseText.indexOf('cib_replace failed') == -1) {\n        if (xhr.responseText.indexOf(error_prefix) == 0) {\n          message += \"\\n\\n\" + xhr.responseText.slice(error_prefix.length);\n        }\n        else {\n          message += \"\\n\\n\" + xhr.responseText;\n        }\n      }\n      if (message.indexOf('--force') == -1) {\n        alert(message);\n        Pcs.update();\n      }\n      else {\n        message = message.replace(', use --force to override', '');\n        message = message.replace('Use --force to override.', '');\n        if (confirm(message + \"\\n\\nDo you want to force the operation?\")) {\n          add_constraint_set(parent_id, c_type, true);\n        }\n      }\n    },\n  });\n}\n\nfunction new_constraint_set_row(parent_id) {\n  $(parent_id + \" td\").first().append(\n    '<br>Set: <input type=\"text\" name=\"resource_ids[]\">'\n  );\n}\n\nfunction reset_constraint_set_form(parent_id) {\n  $(parent_id + \" td\").first().html(\n    'Set: <input type=\"text\" name=\"resource_ids[]\">'\n  );\n}\n\nfunction remove_constraint(id) {\n  fade_in_out($(\"[constraint_id='\"+id+\"']\").parent());\n  $.ajax({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'remove_constraint_remote',\n    data: {\"constraint_id\": id},\n    timeout: pcs_timeout,\n    error: function (xhr, status, error) {\n      alert(\n        \"Error removing constraint \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    },\n    complete: function() {\n      Pcs.update();\n    }\n  });\n}\n\nfunction remove_constraint_rule(id) {\n  fade_in_out($(\"[rule_id='\"+id+\"']\").parent());\n  $.ajax({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'remove_constraint_rule_remote',\n    data: {\"rule_id\": id},\n    timeout: pcs_timeout,\n    error: function (xhr, status, error) {\n      alert(\n        \"Error removing constraint rule \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    },\n    complete: function() {\n      Pcs.update();\n    }\n  });\n}\n\nfunction add_acl_role(form) {\n  var data = {}\n  data[\"name\"] = $(form).find(\"input[name='name']\").val().trim();\n  data[\"description\"] = $(form).find(\"input[name='description']\").val().trim();\n  $.ajax({\n    type: \"POST\",\n    url: get_cluster_remote_url() + \"add_acl_role\",\n    data: data,\n    success: function(data) {\n      Pcs.update();\n      $(form).find(\"input\").val(\"\");\n      $(\"#add_acl_role\").dialog(\"close\");\n    },\n    error: function(xhr, status, error) {\n      alert(\n        \"Error adding ACL role \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    }\n  });\n}\n\nfunction remove_acl_roles(ids) {\n  var data = {};\n  for (var i = 0; i < ids.length; i++) {\n    data[\"role-\" + i] = ids[i];\n  }\n  $.ajax({\n    type: \"POST\",\n    url: get_cluster_remote_url() + \"remove_acl_roles\",\n    data: data,\n    timeout: pcs_timeout*3,\n    success: function(data,textStatus) {\n      $(\"#dialog_verify_remove_acl_roles.ui-dialog-content\").each(\n        function(key, item) { $(item).dialog(\"destroy\"); }\n      );\n      Pcs.update();\n    },\n    error: function (xhr, status, error) {\n      alert(\n        \"Error removing ACL role \"\n        + ajax_simple_error(xhr, status, error)\n      );\n      $(\"#dialog_verify_remove_acl_roles.ui-dialog-content\").each(\n        function(key, item) { $(item).dialog(\"destroy\"); }\n      );\n    }\n  });\n}\n\nfunction add_acl_item(parent_id, item_type) {\n  var data = {};\n  data[\"role_id\"] = Pcs.aclsController.cur_role.name;\n  var item_label = \"\";\n  switch (item_type) {\n    case \"perm\":\n      data[\"item\"] = \"permission\";\n      data[\"type\"] = $(parent_id + \" select[name='role_type']\").val();\n      data[\"xpath_id\"] = $(parent_id + \" select[name='role_xpath_id']\").val();\n      data[\"query_id\"] = $(parent_id + \" input[name='role_query_id']\").val().trim();\n      item_label = \"permission\"\n      break;\n    case \"user\":\n    case \"group\":\n      data[\"item\"] = item_type;\n      data[\"usergroup\"] = $(parent_id + \" input[name='role_assign_user']\").val().trim();\n      item_label = item_type\n      break;\n  }\n  fade_in_out($(parent_id));\n  $.ajax({\n    type: \"POST\",\n    url: get_cluster_remote_url() + 'add_acl',\n    data: data,\n    timeout: pcs_timeout,\n    success: function(data) {\n      $(parent_id + \" input\").val(\"\");\n      Pcs.update();\n    },\n    error: function (xhr, status, error) {\n      alert(\n        \"Error adding \" + item_label + \" \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    }\n  });\n}\n\nfunction remove_acl_item(id,item) {\n  fade_in_out(id);\n  var data = {};\n  var item_label = \"\";\n  switch (item) {\n    case \"perm\":\n      data[\"item\"] = \"permission\";\n      data[\"acl_perm_id\"] = id.attr(\"acl_perm_id\");\n      item_label = \"permission\"\n      break;\n    case \"usergroup\":\n      data[\"item\"] = \"usergroup\";\n      data[\"usergroup_id\"] = id.attr(\"usergroup_id\")\n      data[\"role_id\"] = id.attr(\"role_id\")\n      item_label = \"user / group\"\n      break;\n  }\n\n  $.ajax({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'remove_acl',\n    data: data,\n    timeout: pcs_timeout,\n    success: function (data) {\n      Pcs.update();\n    },\n    error: function (xhr, status, error) {\n      alert(\n        \"Error removing \" + item_label + \" \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    }\n  });\n}\n\nfunction update_cluster_settings() {\n  $(\"#cluster_properties button\").prop(\"disabled\", true);\n  var data = {\n    'hidden[hidden_input]': null // this is needed for backward compatibility \n  };\n  $.each(Pcs.settingsController.get(\"properties\"), function(_, prop) {\n    data[prop.get(\"form_name\")] = prop.get(\"cur_val\");\n  });\n  show_loading_screen();\n  $.ajax({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'update_cluster_settings',\n    data: data,\n    timeout: pcs_timeout,\n    success: function() {\n      refresh_cluster_properties();\n    },\n    error: function (xhr, status, error) {\n      alert(\n        \"Error updating configuration \"\n        + ajax_simple_error(xhr, status, error)\n      );\n      hide_loading_screen();\n      $(\"#cluster_properties button\").prop(\"disabled\", false);\n    }\n  });\n}\n\nfunction refresh_cluster_properties() {\n  Pcs.settingsController.set(\"filter\", \"\");\n  $(\"#cluster_properties button\").prop(\"disabled\", true);\n  $.ajax({\n    url: get_cluster_remote_url() + \"cluster_properties\",\n    timeout: pcs_timeout,\n    dataType: \"json\",\n    success: function(data) {\n      Pcs.settingsController.update(data);\n    },\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to get cluster properties: \"\n        + ajax_simple_error(xhr, status, error)\n      );\n      Pcs.settingsController.update({});\n    },\n    complete: function() {\n      hide_loading_screen();\n      $(\"#cluster_properties button\").prop(\"disabled\", false);\n    }\n  });\n}\n\n// Pull currently managed cluster name out of URL\nfunction get_cluster_name() {\n  var cluster_name = location.pathname.match(\"/managec/(.*)/\");\n  if (cluster_name && cluster_name.length >= 2) {\n    Ember.debug(\"Cluster Name: \" + cluster_name[1]);\n    cluster_name = cluster_name[1];\n    return cluster_name;\n  }\n  Ember.debug(\"Cluster Name is 'null'\");\n  cluster_name = null;\n  return cluster_name;\n}\n\nfunction get_cluster_remote_url(cluster_name) {\n  cluster_name = typeof cluster_name !== 'undefined' ? cluster_name : Pcs.cluster_name;\n  return '/managec/' + cluster_name + \"/\";\n}\n\nfunction checkBoxToggle(cb,nodes) {\n  if (nodes) {\n    cbs = $('#node_list table').find(\".node_list_check input[type=checkbox]\");\n  } else {\n    cbs = $(cb).closest(\"tr\").parent().find(\".node_list_check input[type=checkbox]\")\n  }\n  if ($(cb).prop('checked'))\n    cbs.prop('checked',true).change();\n  else\n    cbs.prop('checked',false).change();\n}\n\nfunction loadWizard(item) {\n  wizard_name = $(item).val();\n  data = {wizard: wizard_name};\n\n  $(\"#wizard_location\").load(\n   get_cluster_remote_url() + 'get_wizard',\n   data);\n}\n\nfunction wizard_submit(form) {\n  data = $(form).serialize();\n  $(\"#wizard_location\").load(\n    get_cluster_remote_url() + 'wizard_submit',\n    data);\n}\n\nfunction update_resource_type_options() {\n  var cp = $(\"#resource_class_provider_selector\").val();\n  var target = $(\"#add_ra_type\");\n  var source = $(\"#all_ra_types\");\n\n  target.empty();\n  source.find(\"option\").each(function(i,v) {\n    if ($(v).val().indexOf(cp) == 0) {\n      new_option = $(v).clone();\n      target.append(new_option);\n    }\n  });\n  target.change();\n}\n\nfunction setup_resource_class_provider_selection() {\n  $(\"#resource_class_provider_selector\").change(function() {\n    update_resource_type_options();\n  });\n  $(\"#resource_class_provider_selector\").change();\n}\n\nfunction get_status_value(status) {\n  var values = {\n    failed: 1,\n    error: 1,\n    offline: 1,\n    blocked: 1,\n    warning: 2,\n    standby: 2,\n    maintenance: 2,\n    \"partially running\": 2,\n    disabled: 3,\n    unknown: 4,\n    ok: 5,\n    running: 5,\n    online: 5\n  };\n  return ((values.hasOwnProperty(status)) ? values[status] : -1);\n}\n\nfunction status_comparator(a,b) {\n  var valA = get_status_value(a);\n  var valB = get_status_value(b);\n  if (valA == -1) return 1;\n  if (valB == -1) return -1;\n  return valA - valB;\n}\n\nfunction get_status_icon_class(status_val) {\n  switch (status_val) {\n    case get_status_value(\"error\"):\n      return \"error\";\n    case get_status_value(\"disabled\"):\n    case get_status_value(\"warning\"):\n      return \"warning\";\n    case get_status_value(\"ok\"):\n      return \"check\";\n    default:\n      return \"x\";\n  }\n}\n\nfunction get_status_color(status_val) {\n  if (status_val == get_status_value(\"ok\")) {\n    return \"green\";\n  }\n  else if (status_val == get_status_value(\"warning\") || status_val == get_status_value(\"unknown\") || status_val == get_status_value('disabled')) {\n    return \"orange\";\n  }\n  return \"red\";\n}\n\nfunction show_hide_dashboard(element, type) {\n  var cluster = Pcs.clusterController.cur_cluster;\n  if (Pcs.clusterController.get(\"show_all_\" + type)) { // show only failed\n    Pcs.clusterController.set(\"show_all_\" + type, false);\n  } else { // show all\n    Pcs.clusterController.set(\"show_all_\" + type, true);\n  }\n  correct_visibility_dashboard_type(cluster, type);\n}\n\nfunction correct_visibility_dashboard(cluster) {\n  if (cluster == null)\n    return;\n  $.each([\"nodes\", \"resources\", \"fence\"], function(key, type) {\n    correct_visibility_dashboard_type(cluster, type);\n  });\n}\n\nfunction correct_visibility_dashboard_type(cluster, type) {\n  if (cluster == null) {\n    return;\n  }\n  destroy_tooltips();\n  var listTable = $(\"#cluster_info_\" + cluster.name).find(\"table.\" + type + \"_list\");\n  var datatable = listTable.find(\"table.datatable\");\n  if (Pcs.clusterController.get(\"show_all_\" + type)) {\n    listTable.find(\"span.downarrow\").show();\n    listTable.find(\"span.rightarrow\").hide();\n    datatable.find(\"tr.default-hidden\").removeClass(\"hidden\");\n  } else {\n    listTable.find(\"span.downarrow\").hide();\n    listTable.find(\"span.rightarrow\").show();\n    datatable.find(\"tr.default-hidden\").addClass(\"hidden\");\n  }\n  if (cluster.get(type + \"_failed\") == 0 && !Pcs.clusterController.get(\"show_all_\" + type)) {\n    datatable.hide();\n  } else {\n    datatable.show();\n  }\n}\n\nfunction get_formated_html_list(data) {\n  if (data == null || data.length == 0) {\n    return \"\";\n  }\n  var out = \"<ul>\";\n  $.each(data, function(key, value) {\n    out += \"<li>\" + htmlEncode(value.message) + \"</li>\";\n  });\n  out += \"</ul>\";\n  return out;\n}\n\nfunction htmlEncode(s)\n{\n  return $(\"<div/>\").text(s).html().replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n}\n\nfunction fix_auth_of_cluster() {\n  show_loading_screen();\n  var clustername = Pcs.clusterController.cur_cluster.name;\n  $.ajax({\n    url: get_cluster_remote_url(clustername) + \"fix_auth_of_cluster\",\n    type: \"POST\",\n    success: function(data) {\n      hide_loading_screen();\n      Pcs.update();\n    },\n    error: function(jqhxr,b,c) {\n      hide_loading_screen();\n      Pcs.update();\n      alert(jqhxr.responseText);\n    }\n  });\n}\n\nfunction get_tree_view_element_id(element) {\n  return $(element).parents('table.tree-element')[0].id;\n}\n\nfunction get_list_view_element_id(element) {\n  return $(element)[0].id;\n}\n\nfunction auto_show_hide_constraints() {\n  var cont = [\"location_constraints\", \"ordering_constraints\", \"ordering_set_constraints\", \"colocation_constraints\", \"meta_attributes\"];\n  $.each(cont, function(index, name) {\n    var elem = $(\"#\" + name)[0];\n    var cur_resource = Pcs.resourcesContainer.get('cur_resource');\n    if (elem && cur_resource) {\n      var visible = $(elem).children(\"span\")[0].style.display != 'none';\n      if (visible && (!cur_resource.get(name) || cur_resource.get(name).length == 0))\n        show_hide_constraints(elem);\n      else if (!visible && cur_resource.get(name) && cur_resource.get(name).length > 0)\n        show_hide_constraints(elem);\n    }\n  });\n}\n\nfunction tree_view_onclick(resource_id, auto) {\n  auto = typeof auto !== 'undefined' ? auto : false;\n  var resource_obj = Pcs.resourcesContainer.get_resource_by_id(resource_id);\n  if (!resource_obj) {\n    console.log(\"Resource \" + resource_id + \"not found.\");\n    return;\n  }\n  if (resource_obj.get('stonith')) {\n    Pcs.resourcesContainer.set('cur_fence', resource_obj);\n    if (!auto) window.location.hash = \"/fencedevices/\" + resource_id;\n  } else {\n    Pcs.resourcesContainer.set('cur_resource', resource_obj);\n    if (!auto) window.location.hash = \"/resources/\" + resource_id;\n    auto_show_hide_constraints();\n  }\n\n  tree_view_select(resource_id);\n\n  Ember.run.next(Pcs, function() {\n    load_agent_form(resource_id, resource_obj.get('stonith'));\n  });\n}\n\nfunction tree_view_select(element_id) {\n  var e = $('#' + element_id);\n  var view = e.parents('table.tree-view');\n  view.find('div.arrow').hide();\n  view.find('tr.children').hide();\n  view.find('table.tree-element').show();\n  view.find('tr.tree-element-name').removeClass(\"node_selected\");\n  e.find('tr.tree-element-name:first').addClass(\"node_selected\");\n  e.find('tr.tree-element-name div.arrow:first').show();\n  e.parents('tr.children').show();\n  e.find('tr.children').show();\n}\n\nfunction list_view_select(element_id) {\n  var e = $('#' + element_id);\n  var view = e.parents('table.list-view');\n  view.find('div.arrow').hide();\n  view.find('tr.list-view-element').removeClass(\"node_selected\");\n  e.addClass('node_selected');\n  e.find('div.arrow').show();\n}\n\nfunction tree_view_checkbox_onchange(element) {\n  var e = $(element);\n  var children = $(element).closest(\".tree-element\").find(\".children\" +\n    \" input:checkbox\");\n  var val = e.prop('checked');\n  children.prop('checked', val);\n  children.prop('disabled', val);\n}\n\nfunction resource_master(resource_id) {\n  if (resource_id == null) {\n    return;\n  }\n  show_loading_screen();\n  $.ajax({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'resource_master',\n    data: {resource_id: resource_id},\n    timeout: pcs_timeout,\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to create master/slave resource \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    },\n    complete: function() {\n      Pcs.update();\n    }\n  });\n}\n\nfunction resource_clone(resource_id) {\n  if (resource_id == null) {\n    return;\n  }\n  show_loading_screen();\n  $.ajax({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'resource_clone',\n    data: {resource_id: resource_id},\n    timeout: pcs_timeout,\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to clone the resource \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    },\n    complete: function() {\n      Pcs.update();\n    }\n  });\n}\n\nfunction resource_unclone(resource_id) {\n  if (resource_id == null) {\n    return;\n  }\n  show_loading_screen();\n  var resource_obj = Pcs.resourcesContainer.get_resource_by_id(resource_id);\n  if (resource_obj.get('class_type') == 'clone') {\n    resource_id = resource_obj.get('member').get('id');\n  }\n  $.ajax({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'resource_unclone',\n    data: {resource_id: resource_id},\n    timeout: pcs_timeout,\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to unclone the resource \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    },\n    complete: function() {\n      Pcs.update();\n    }\n  });\n}\n\nfunction resource_ungroup(group_id) {\n  if (group_id == null) {\n    return;\n  }\n  show_loading_screen();\n  $.ajax({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'resource_ungroup',\n    data: {group_id: group_id},\n    timeout: pcs_timeout,\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to ungroup the resource \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    },\n    complete: function() {\n      Pcs.update();\n    }\n  });\n}\n\nfunction resource_change_group(resource_id, group_id) {\n  if (resource_id == null) {\n    return;\n  }\n  show_loading_screen();\n  var resource_obj = Pcs.resourcesContainer.get_resource_by_id(resource_id);\n  var data = {\n    resource_id: resource_id,\n    group_id: group_id\n  };\n  \n  if (resource_obj.get('parent')) {\n    if (resource_obj.get('parent').get('id') == group_id) {\n      return;  \n    }\n    if (resource_obj.get('parent').get('class_type') == 'group') {\n      data['old_group_id'] = resource_obj.get('parent').get('id');\n    }\n  }\n\n  $.ajax({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'resource_change_group',\n    data: data,\n    timeout: pcs_timeout,\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to change group \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    },\n    complete: function() {\n      Pcs.update();\n    }\n  });\n}\n\nfunction ajax_simple_error(xhr, status, error) {\n  var message = \"(\" + $.trim(error) + \")\"\n  if (\n    $.trim(xhr.responseText).length > 0\n    &&\n    xhr.responseText.indexOf('cib_replace failed') == -1\n  ) {\n    message = message + \"\\n\\n\" + $.trim(xhr.responseText);\n  }\n  return message;\n}\n\nvar permissions_current_cluster;\n\nfunction permissions_load_all() {\n  show_loading_screen();\n\n  var cluster_list = [];\n  $(\"#node_info div[id^='permissions_cluster_']\").each(function(i, div) {\n    cluster_list.push(\n      $(div).attr(\"id\").substring(\"permissions_cluster_\".length)\n    );\n  });\n\n  var call_count = cluster_list.length;\n  var callback = function() {\n    call_count = call_count - 1;\n    if (call_count < 1) {\n      hide_loading_screen();\n    }\n  }\n\n  $.each(cluster_list, function(index, cluster) {\n    permissions_load_cluster(cluster, callback);\n  });\n\n  if (cluster_list.length > 0) {\n    permissions_current_cluster = cluster_list[0];\n    permissions_show_cluster(\n      permissions_current_cluster,\n      $(\"#cluster_list tr\").first().next() /* the first row is a heading */\n    );\n  }\n  else {\n    hide_loading_screen();\n  }\n}\n\nfunction permissions_load_cluster(cluster_name, callback) {\n  var element_id = \"permissions_cluster_\" + cluster_name;\n  $.ajax({\n    type: \"GET\",\n    url: \"/permissions_cluster_form/\" + cluster_name,\n    timeout: pcs_timeout,\n    success: function(data) {\n      $(\"#\" + element_id).html(data);\n      $(\"#\" + element_id + \" :checkbox\").each(function(key, checkbox) {\n        permissions_fix_dependent_checkboxes(checkbox);\n      });\n      permissions_cluster_dirty_flag(cluster_name, false);\n      if (callback) {\n        callback();\n      }\n    },\n    error: function(xhr, status, error) {\n      $(\"#\" + element_id).html(\n        \"Error loading permissions \" + ajax_simple_error(xhr, status, error)\n      );\n      if (callback) {\n        callback();\n      }\n    }\n  });\n}\n\nfunction permissions_show_cluster(cluster_name, list_row) {\n  permissions_current_cluster = cluster_name;\n\n  var container = $(\"#node_info\");\n  container.fadeTo(500, .01, function() {\n    container.children().hide();\n    $(\"#permissions_cluster_\" + cluster_name).show();\n    container.fadeTo(500, 1);\n  });\n\n  $(list_row).siblings(\"tr\").each(function(index, row) {\n    hover_out(row);\n    $(row).find(\"td\").last().children().hide();\n  });\n  hover_over(list_row);\n  $(list_row).find(\"td\").last().children().show();\n}\n\nfunction permissions_save_cluster(form) {\n  var dataString = $(form).serialize();\n  var cluster_name = permissions_get_clustername(form);\n  $.ajax({\n    type: \"POST\",\n    url: get_cluster_remote_url(cluster_name) + \"permissions_save\",\n    timeout: pcs_timeout,\n    data: dataString,\n    success: function() {\n      show_loading_screen();\n      permissions_load_cluster(cluster_name, hide_loading_screen);\n    },\n    error: function(xhr, status, error) {\n      alert(\n        \"Unable to save permissions of cluster \" + cluster_name + \" \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    }\n  });\n}\n\nfunction permissions_cluster_dirty_flag(cluster_name, flag) {\n  var cluster_row = permissions_get_cluster_row(cluster_name);\n  if (cluster_row) {\n    var dirty_elem = cluster_row.find(\"span[class=unsaved_changes]\");\n    if (dirty_elem) {\n      if (flag) {\n        dirty_elem.show();\n      }\n      else {\n        dirty_elem.hide();\n      }\n    }\n  }\n}\n\nfunction permission_remove_row(button) {\n  var cluster_name = permissions_get_clustername(\n    $(button).parents(\"form\").first()\n  );\n  $(button).parent().parent().remove();\n  permissions_cluster_dirty_flag(cluster_name, true);\n}\n\nfunction permissions_add_row(template_row) {\n  var user_name = permissions_get_row_name(template_row);\n  var user_type = permissions_get_row_type(template_row);\n  var max_key = -1;\n  var exists = false;\n  var cluster_name = permissions_get_clustername(\n    $(template_row).parents(\"form\").first()\n  );\n\n  if(\"\" == user_name) {\n    alert(\"Please enter the name\");\n    return;\n  }\n  if(\"\" == user_type) {\n    alert(\"Please enter the type\");\n    return;\n  }\n\n  $(template_row).siblings().each(function(index, row) {\n    if(\n      (permissions_get_row_name(row) == user_name)\n      &&\n      (permissions_get_row_type(row) == user_type)\n    ) {\n      exists = true;\n    }\n    $(row).find(\"input\").each(function(index, input) {\n      var match = input.name.match(/^[^[]*\\[(\\d+)\\].*$/);\n      if (match) {\n        var key = parseInt(match[1]);\n        if(key > max_key) {\n          max_key = key;\n        }\n      }\n    });\n  });\n  if(exists) {\n    alert(\"Permissions already set for the user\");\n    return;\n  }\n\n  max_key = max_key + 1;\n  var new_row = $(template_row).clone();\n  new_row.find(\"[name*='_new']\").each(function(index, element) {\n    element.name = element.name.replace(\"_new\", \"[\" + max_key + \"]\");\n  });\n  new_row.find(\"td\").last().html(\n    '<a class=\"remove\" href=\"#\" onclick=\"permission_remove_row(this);\">X</a>'\n  );\n  new_row.find(\"[name$='[name]']\").each(function(index, element) {\n    $(element).after(user_name);\n    $(element).attr(\"type\", \"hidden\");\n  });\n  new_row.find(\"[name$='[type]']\").each(function(index, element) {\n    $(element).after(user_type);\n    $(element).after(\n      '<input type=\"hidden\" name=\"' + element.name  + '\" value=\"' + user_type + '\">'\n    );\n    $(element).remove();\n  });\n\n  $(template_row).before(new_row);\n  var template_inputs = $(template_row).find(\":input\");\n  template_inputs.removeAttr(\"checked\").removeAttr(\"selected\");\n  template_inputs.removeAttr(\"disabled\").removeAttr(\"readonly\");\n  $(template_row).find(\":input[type=text]\").val(\"\");\n\n  permissions_cluster_dirty_flag(cluster_name, true);\n}\n\nfunction permissions_get_dependent_checkboxes(checkbox) {\n  var cluster_name = permissions_get_clustername(\n    $(checkbox).parents(\"form\").first()\n  );\n  var checkbox_permission = permissions_get_checkbox_permission(checkbox);\n  var deps = {};\n  var dependent_permissions = [];\n  var dependent_checkboxes = [];\n\n  if (permissions_dependencies[cluster_name]) {\n    deps = permissions_dependencies[cluster_name];\n    if (deps[\"also_allows\"] && deps[\"also_allows\"][checkbox_permission]) {\n      dependent_permissions = deps[\"also_allows\"][checkbox_permission];\n      $(checkbox).parents(\"tr\").first().find(\":checkbox\").not(checkbox).each(\n        function(key, check) {\n          var perm = permissions_get_checkbox_permission(check);\n          if (dependent_permissions.indexOf(perm) != -1) {\n            dependent_checkboxes.push(check);\n          }\n        }\n      );\n    }\n  }\n  return dependent_checkboxes;\n}\n\nfunction permissions_fix_dependent_checkboxes(checkbox) {\n  var dep_checks = $(permissions_get_dependent_checkboxes(checkbox));\n  if ($(checkbox).prop(\"checked\")) {\n    /* the checkbox is now checked */\n    dep_checks.each(function(key, check) {\n      var jq_check = $(check);\n      jq_check.prop(\"checked\", true);\n      jq_check.prop(\"readonly\", true);\n      // readonly on checkbox makes it look like readonly but doesn't prevent\n      // changing its state (checked - not checked), setting disabled works\n      jq_check.prop(\"disabled\", true);\n      permissions_fix_dependent_checkboxes(check);\n    });\n  }\n  else {\n    /* the checkbox is now empty */\n    dep_checks.each(function(key, check) {\n      var jq_check = $(check);\n      jq_check.prop(\"checked\", jq_check.prop(\"defaultChecked\"));\n      jq_check.prop(\"readonly\", false);\n      jq_check.prop(\"disabled\", false);\n      permissions_fix_dependent_checkboxes(check);\n    });\n  }\n}\n\nfunction permissions_get_row_name(row) {\n  return $.trim($(row).find(\"[name$='[name]']\").val());\n}\n\nfunction permissions_get_row_type(row) {\n  return $.trim($(row).find(\"[name$='[type]']\").val());\n}\n\nfunction permissions_get_clustername(form) {\n  return $.trim($(form).find(\"[name=cluster_name]\").val());\n}\n\nfunction permissions_get_checkbox_permission(checkbox) {\n  var match = checkbox.name.match(/^.*\\[([^[]+)\\]$/);\n  if (match) {\n    return match[1];\n  }\n  return \"\";\n}\n\nfunction permissions_get_cluster_row(cluster_name) {\n  var cluster_row = null;\n  $('#cluster_list td[class=node_name]').each(function(index, elem) {\n    var jq_elem = $(elem);\n    if (jq_elem.text().trim() == cluster_name.trim()) {\n      cluster_row = jq_elem.parents(\"tr\").first();\n    }\n  });\n  return cluster_row;\n}\n\nfunction is_cib_true(value) {\n  if (value) {\n    return (['true', 'on', 'yes', 'y', '1'].indexOf(value.toString().toLowerCase()) != -1);\n  }\n  return false;\n}\n\nfunction set_utilization(type, entity_id, name, value) {\n  var data = {\n    name: name,\n    value: value\n  };\n  if (type == \"node\") {\n    data[\"node\"] = entity_id;\n  } else if (type == \"resource\") {\n    data[\"resource_id\"] = entity_id;\n  } else return false;\n  var url = get_cluster_remote_url() + \"set_\" + type + \"_utilization\";\n\n  $.ajax({\n    type: 'POST',\n    url: url,\n    data: data,\n    timeout: pcs_timeout,\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to set utilization: \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    },\n    complete: function() {\n      Pcs.update();\n    }\n  });\n}\n\nfunction is_integer(str) {\n  if (Number(str) === str && str % 1 === 0) // if argument isn't string but number\n    return true;\n  var n = ~~Number(str);\n  return String(n) === str;\n}\n\nEmber.Handlebars.helper('selector-helper', function (content, value, place_holder, options) {\n  var out = \"\";\n  var line;\n  if (place_holder) {\n    out += '<option value=\"\">' + place_holder + '</option>'; \n  }\n  $.each(content, function(_, opt){\n    line = '<option value=\"' + opt[\"value\"] + '\"';\n    if (value == opt[\"value\"]) {\n      line += ' selected=\"selected\"'\n    }\n    line += \">\" + Handlebars.Utils.escapeExpression(opt[\"name\"]) + \"</option>\";\n    out += line + \"\\n\";\n  });\n  return new Handlebars.SafeString(out);\n});\n", "<div id=\"auth_nodes\" style=\"display:none;\">\n  <form id=\"auth_nodes_form\">\n    Enter password for user 'hacluster' to authenticate nodes.<br>\n    Nodes to authenticate:\n    <table class=\"err_msg_table\" style=\"width: 100%\">\n      <tr><td align=center style=\"color: red\" colspan=2\"><span id=\"auth_failed_error_msg\" style=\"display:none;\">Authentication on some nodes failed.</span></td></tr>\n    </table>\n    <table id=\"auth_nodes_list\">\n    </table>\n    <div id=\"same_pass\"><label><input type=\"checkbox\" name=\"all\" onchange=\"if ($(this).is(':checked')) {$('#auth_nodes_list').find('input:password').each(function(){$(this).hide()}); $('#pass_for_all').show();} else {$('#auth_nodes_list').find('input:password').each(function(){$(this).show()}); $('#pass_for_all').hide();}\"> Use same password for all nodes:</label>\n      <input type=\"password\" name=\"pass-all\" id=\"pass_for_all\" style=\"display: none;\"></div>\n  </form>\n</div>\n\n<div id=\"dialog_verify_remove_clusters\" style=\"display: none;\">\n  <p style=\"font-size:12px;\">Are you sure you want to remove the following cluster(s) from the GUI? (This only removes the cluster from the GUI, it does not stop the cluster from running.)</p>\n  <span class=\"name_list\"></span>\n</div>\n\n<div id=\"dialog_verify_remove_nodes\" style=\"display:none;\">\n  <p style=\"font-size:12px;\">Are you sure you want to remove the following node(s)?</p>\n  <span class=\"name_list\"></span>\n  {{#if Pcs.is_cman_with_udpu_transport}}\n    <p style=\"color: orange\">This is a CMAN cluster with UDPU transport, cluster restart is required to apply node removal.</p>\n  {{/if}}\n</div>\n\n<div id=\"dialog_verify_remove_resources\" style=\"display: none;\">\n  <p style=\"font-size:12px;\">Are you sure you want to remove the following resource(s)?</p>\n  <span class=\"name_list\"></span>\n  <input type=\"checkbox\" name=\"force\">\n  Enforce removal (Remove the resources without stopping them first.)\n</div>\n\n<div id=\"dialog_verify_remove_acl_roles\" style=\"display:none;\">\n  <p style=\"font-size:12px;\">Are you sure you want to remove the following ACL role(s)?</p>\n  <span class=\"name_list\"></span>\n</div>\n", "<table id=\"main\">\n  <tr id=\"cluster_title_row\" {{bind-attr style=Pcs.permissions_page}}>\n    <td id=\"page_header\" colspan=\"2\" style=\"vertical-align:middle;\">\n      <table id=\"permissions_commands\">\n        <tr>\n          <td>PERMISSIONS</td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n  <tr id=\"cluster_header_row\" {{bind-attr style=Pcs.permissions_page}}>\n    <td class=\"borderbottom\" colspan=\"2\"> </td>\n  </tr>\n  <tr id=\"cluster_list_row\" {{bind-attr style=Pcs.permissions_page}}>\n    <td id=\"cluster_list\" class=\"node_list\" style=\"width:auto;\">\n      <table cellpadding=\"0\" cellspacing=\"0\" style=\"width:100%;\">\n        <tr>\n          <th> </th>\n          <th> </th>\n          <th>CLUSTER&nbsp;NAME</th>\n          <th style=\"padding-right: 16px;\"> </th>\n        </tr>\n        <% @clusters.each do |c| %>\n          <tr\n            onmouseover=\"if(permissions_current_cluster != '<%= h(c.name) %>') hover_over(this);\"\n            onmouseout=\"if(permissions_current_cluster != '<%= h(c.name) %>') hover_out(this);\"\n            onclick=\"permissions_show_cluster('<%= h(c.name) %>', this);\"\n          >\n            <td class=\"node_list_sprite\">\n              <div class=\"check sprites\"></div>\n            </td>\n            <td style=\"min-width:1em; padding-right:0.5em;\">\n              <span class=\"unsaved_changes\" style=\"display:none;\"\n                title=\"There are unsaved changes in the form\"\n              >(*)</span>\n            </td>\n            <td nowrap class=\"node_name\">\n              <%= h(c.name) %>\n            </td>\n            <td>\n              <div class=\"arrow sprites\" style=\"display:none;\"></div>\n            </td>\n          </tr>\n        <% end %>\n      </table>\n    </td>\n    <td id=\"node_info\">\n      <% @clusters.each { |c| %>\n        <div id=\"permissions_cluster_<%= h(c.name) %>\" style=\"display:none;\">\n        </div>\n      <% } %>\n    </td>\n  </tr>\n</table>\n"], "fixing_code": ["require 'sinatra'\nrequire 'sinatra/reloader' if development?\nrequire 'sinatra/cookies'\nrequire 'rexml/document'\nrequire 'webrick'\nrequire 'webrick/https'\nrequire 'openssl'\nrequire 'logger'\nrequire 'thread'\n\nrequire 'bootstrap.rb'\nrequire 'resource.rb'\nrequire 'remote.rb'\nrequire 'fenceagent.rb'\nrequire 'cluster.rb'\nrequire 'config.rb'\nrequire 'pcs.rb'\nrequire 'auth.rb'\nrequire 'wizard.rb'\nrequire 'cfgsync.rb'\nrequire 'permissions.rb'\nrequire 'session.rb'\n\nDir[\"wizards/*.rb\"].each {|file| require file}\n\nuse Rack::CommonLogger\n\nset :app_file, __FILE__\n\ndef generate_cookie_secret\n  return SecureRandom.hex(30)\nend\n\nbegin\n  secret = File.read(COOKIE_FILE)\n  secret_errors = verify_cookie_secret(secret)\n  if secret_errors and not secret_errors.empty?\n    secret_errors.each { |err| $logger.error err }\n    $logger.error \"Invalid cookie secret, using temporary one\"\n    secret = generate_cookie_secret()\n  end\nrescue Errno::ENOENT\n  secret = generate_cookie_secret()\n  File.open(COOKIE_FILE, 'w', 0700) {|f| f.write(secret)}\nend\n\nsession_lifetime = ENV['SESSION_LIFETIME'].to_i()\nsession_lifetime = 60 * 60 unless session_lifetime > 0\nuse SessionPoolLifetime,\n  :expire_after => session_lifetime,\n  :secret => secret,\n  :secure => true, # only send over HTTPS\n  :httponly => true # don't provide to javascript\n\n# session storage instance\n# will be created by Rack later and fetched in \"before\" filter\n$session_storage = nil\n$session_storage_env = {}\n\n#use Rack::SSL\n\nif development?\n  Dir[\"wizards/*.rb\"].each {|file| also_reload file}\n  also_reload 'resource.rb'\n  also_reload 'remote.rb'\n  also_reload 'fenceagent.rb'\n  also_reload 'cluster.rb'\n  also_reload 'config.rb'\n  also_reload 'pcs.rb'\n  also_reload 'auth.rb'\n  also_reload 'wizard.rb'\n  also_reload 'cfgsync.rb'\nend\n\nbefore do\n  @auth_user = nil\n\n  # get session storage instance from env\n  if not $session_storage and env[:__session_storage]\n    $session_storage = env[:__session_storage]\n    $session_storage_env = env\n  end\n\n  if request.path != '/login' and not request.path == \"/logout\" and not request.path == '/remote/auth'\n    protected! \n  end\n  $cluster_name = get_cluster_name()\nend\n\nconfigure do\n  DISABLE_GUI = (ENV['DISABLE_GUI'] and ENV['DISABLE_GUI'].downcase == 'true')\n  PCS = get_pcs_path(File.expand_path(File.dirname(__FILE__)))\n  logger = File.open(\"/var/log/pcsd/pcsd.log\", \"a+\", 0600)\n  STDOUT.reopen(logger)\n  STDERR.reopen(logger)\n  STDOUT.sync = true\n  STDERR.sync = true\n  $logger = configure_logger('/var/log/pcsd/pcsd.log')\n  $semaphore_cfgsync = Mutex.new\nend\n\nset :logging, true\nset :run, false\n\n$thread_cfgsync = Thread.new {\n  while true\n    $semaphore_cfgsync.synchronize {\n      $logger.debug('Config files sync thread started')\n      if Cfgsync::ConfigSyncControl.sync_thread_allowed?()\n        begin\n          # do not sync if this host is not in a cluster\n          cluster_name = get_cluster_name()\n          if cluster_name and !cluster_name.empty?()\n            $logger.debug('Config files sync thread fetching')\n            fetcher = Cfgsync::ConfigFetcher.new(\n              PCSAuth.getSuperuserAuth(), Cfgsync::get_cfg_classes(),\n              get_corosync_nodes(), cluster_name\n            )\n            cfgs_to_save, _ = fetcher.fetch()\n            cfgs_to_save.each { |cfg_to_save|\n              cfg_to_save.save()\n            }\n          end\n        rescue => e\n          $logger.warn(\"Config files sync thread exception: #{e}\")\n        end\n      end\n      $logger.debug('Config files sync thread finished')\n    }\n    sleep(Cfgsync::ConfigSyncControl.sync_thread_interval())\n  end\n}\n\n$thread_session_expired = Thread.new {\n  while true\n    sleep(60 * 5)\n    begin\n      if $session_storage\n        $session_storage.drop_expired($session_storage_env)\n      end\n    rescue => e\n      $logger.warn(\"Exception while removing expired sessions: #{e}\")\n    end\n  end\n}\n\nhelpers do\n  def is_ajax?\n    return request.env['HTTP_X_REQUESTED_WITH'] == 'XMLHttpRequest'\n  end\n\n  def protected!\n    gui_request = ( # these are URLs for web pages\n      request.path == '/' or\n      request.path == '/manage' or\n      request.path == '/permissions' or\n      request.path.match('/managec/.+/main')\n    )\n    if request.path.start_with?('/remote/') or request.path == '/run_pcs'\n      @auth_user = PCSAuth.loginByToken(cookies)\n      unless @auth_user\n        halt [401, '{\"notauthorized\":\"true\"}']\n      end\n    else #/managec/* /manage/* /permissions\n      if !gui_request and !is_ajax? then\n        # Accept non GUI requests only with header\n        # \"X_REQUESTED_WITH: XMLHttpRequest\". (check if they are send via AJAX).\n        # This prevents CSRF attack.\n        halt [401, '{\"notauthorized\":\"true\"}']\n      elsif not PCSAuth.isLoggedIn(session)\n        if gui_request\n          session[:pre_login_path] = request.path\n          redirect '/login'\n        else\n          halt [401, '{\"notauthorized\":\"true\"}']\n        end\n      end\n    end\n  end\n\n  def getParamList(params)\n    param_line = []\n    meta_options = []\n    params.each { |param, val|\n      if param.start_with?(\"_res_paramne_\") or (param.start_with?(\"_res_paramempty_\") and val != \"\")\n        myparam = param.sub(/^_res_paramne_/,\"\").sub(/^_res_paramempty_/,\"\")\n        param_line << \"#{myparam}=#{val}\"\n      end\n      if param == \"disabled\"\n        meta_options << 'meta' << 'target-role=Stopped'\n      end\n    }\n    return param_line + meta_options\n  end\nend\n\nget '/remote/?:command?' do\n  return remote(params, request, @auth_user)\nend\n\npost '/remote/?:command?' do\n  return remote(params, request, @auth_user)\nend\n\npost '/run_pcs' do\n  command = params['command'] || '{}'\n  std_in = params['stdin'] || nil\n  begin\n    command_decoded = JSON.parse(command)\n  rescue JSON::ParserError\n    result = {\n      'status' => 'error',\n      'data' => {},\n    }\n    return JSON.pretty_generate(result)\n  end\n  # do not reveal potentialy sensitive information\n  command_decoded.delete('--debug')\n\n  allowed_commands = {\n    ['cluster', 'auth', '...'] => {\n      'only_superuser' => false,\n      'permissions' => nil,\n    },\n    # runs on the local node, check permissions\n    ['cluster', 'corosync'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::READ,\n    },\n    # runs on a remote node which checks permissions by itself\n    ['cluster', 'corosync', '...'] => {\n      'only_superuser' => false,\n      'permissions' => nil,\n    },\n    ['cluster', 'destroy', '...'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::FULL,\n    },\n    # runs on the local node, check permissions\n    ['cluster', 'disable'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::WRITE,\n    },\n    # runs on a remote node which checks permissions by itself\n    ['cluster', 'disable', '...'] => {\n      'only_superuser' => false,\n      'permissions' => nil,\n    },\n    # runs on the local node, check permissions\n    ['cluster', 'enable'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::WRITE,\n    },\n    # runs on a remote node which checks permissions by itself\n    ['cluster', 'enable', '...'] => {\n      'only_superuser' => false,\n      'permissions' => nil,\n    },\n    ['cluster', 'node', '...'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::FULL,\n    },\n    ['cluster', 'pcsd-status', '...'] => {\n      'only_superuser' => false,\n      'permissions' => nil,\n    },\n    ['cluster', 'setup', '...'] => {\n      'only_superuser' => true,\n      'permissions' => nil,\n    },\n    # runs on the local node, check permissions\n    ['cluster', 'start'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::WRITE,\n    },\n    # runs on a remote node which checks permissions by itself\n    ['cluster', 'start', '...'] => {\n      'only_superuser' => false,\n      'permissions' => nil,\n    },\n    # runs on the local node, check permissions\n    ['cluster', 'stop'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::WRITE,\n    },\n    # runs on a remote node which checks permissions by itself\n    ['cluster', 'stop', '...'] => {\n      'only_superuser' => false,\n      'permissions' => nil,\n    },\n    ['cluster', 'sync', '...'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::FULL,\n    },\n    ['config', 'restore', '...'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::FULL,\n    },\n    ['pcsd', 'sync-certificates', '...'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::FULL,\n    },\n    ['status', 'nodes', 'corosync-id', '...'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::READ,\n    },\n    ['status', 'nodes', 'pacemaker-id', '...'] => {\n      'only_superuser' => false,\n      'permissions' => Permissions::READ,\n    },\n    ['status', 'pcsd', '...'] => {\n      'only_superuser' => false,\n      'permissions' => nil,\n    },\n  }\n  allowed = false\n  command_settings = {}\n  allowed_commands.each { |cmd, cmd_settings|\n    if command_decoded == cmd \\\n      or \\\n      (cmd[-1] == '...' and cmd[0..-2] == command_decoded[0..(cmd.length - 2)])\n      then\n        allowed = true\n        command_settings = cmd_settings\n        break\n    end\n  }\n  if !allowed\n    result = {\n      'status' => 'bad_command',\n      'data' => {},\n    }\n    return JSON.pretty_generate(result)\n  end\n\n  if command_settings['only_superuser']\n    if not allowed_for_superuser(@auth_user)\n      return 403, 'Permission denied'\n    end\n  end\n  if command_settings['permissions']\n    if not allowed_for_local_cluster(@auth_user, command_settings['permissions'])\n      return 403, 'Permission denied'\n    end\n  end\n\n  options = {}\n  options['stdin'] = std_in if std_in\n  std_out, std_err, retval = run_cmd_options(\n    @auth_user, options, PCS, *command_decoded\n  )\n  result = {\n    'status' => 'ok',\n    'data' => {\n      'stdout' => std_out.join(\"\"),\n      'stderr' => std_err.join(\"\"),\n      'code' => retval,\n    },\n  }\n  return JSON.pretty_generate(result)\nend\n\nif not DISABLE_GUI\n  get('/login'){ erb :login, :layout => :main }\n\n  get '/logout' do\n    session.destroy\n    redirect '/login'\n  end\n\n  post '/login' do\n    auth_user = PCSAuth.loginByPassword(\n      params['username'], params['password']\n    )\n    if auth_user\n      PCSAuth.authUserToSession(auth_user, session)\n      # Temporarily ignore pre_login_path until we come up with a list of valid\n      # paths to redirect to (to prevent status_all issues)\n      #    if session[\"pre_login_path\"]\n      #      plp = session[\"pre_login_path\"]\n      #      session.delete(\"pre_login_path\")\n      #      pp \"Pre Login Path: \" + plp\n      #      if plp == \"\" or plp == \"/\"\n      #        plp = '/manage'\n      #      end\n      #      redirect plp\n      #    else\n      if is_ajax?\n        halt [200, \"OK\"]\n      else\n        redirect '/manage'\n      end\n      #    end\n    else\n      if is_ajax?\n        halt [401, '{\"notauthorized\":\"true\"}']\n      else\n        session[\"bad_login_name\"] = params['username']\n        redirect '/login?badlogin=1'\n      end\n    end\n  end\n\n  post '/manage/existingcluster' do\n    pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text())\n    node = params['node-name']\n    code, result = send_request_with_token(\n      PCSAuth.getSuperuserAuth(), node, 'status'\n    )\n    begin\n      status = JSON.parse(result)\n    rescue JSON::ParserError\n      return 400, \"Unable to communicate with remote pcsd on node '#{node}'.\"\n    end\n\n    warning_messages = []\n\n    if status.has_key?(\"corosync_offline\") and\n      status.has_key?(\"corosync_online\") then\n      nodes = status[\"corosync_offline\"] + status[\"corosync_online\"]\n\n      if status[\"cluster_name\"] == ''\n        return 400, \"The node, '#{noname}', does not currently have a cluster\n configured.  You must create a cluster using this node before adding it to pcsd.\"\n      end\n\n      if pcs_config.is_cluster_name_in_use(status[\"cluster_name\"])\n        return 400, \"The cluster name, '#{status['cluster_name']}' has\nalready been added to pcsd.  You may not add two clusters with the same name into pcsd.\"\n      end\n\n      # auth begin\n      retval, out = send_request_with_token(\n        PCSAuth.getSuperuserAuth(), node, '/get_cluster_tokens'\n      )\n      if retval == 404 # backward compatibility layer\n        warning_messages << \"Unable to do correct authentication of cluster because it is running old version of pcs/pcsd.\"\n      else\n        if retval != 200\n          return 400, \"Unable to get authentication info from cluster '#{status['cluster_name']}'.\"\n        end\n        begin\n          new_tokens = JSON.parse(out)\n        rescue\n          return 400, \"Unable to get authentication info from cluster '#{status['cluster_name']}'.\"\n        end\n\n        sync_config = Cfgsync::PcsdTokens.from_file('')\n        pushed, _ = Cfgsync::save_sync_new_tokens(\n          sync_config, new_tokens, get_corosync_nodes(), $cluster_name\n        )\n        if not pushed\n          return 400, \"Configuration conflict detected.\\n\\nSome nodes had a newer configuration than the local node. Local node's configuration was updated.  Please repeat the last action if appropriate.\"\n        end\n      end\n      #auth end\n\n      pcs_config.clusters << Cluster.new(status[\"cluster_name\"], nodes)\n\n      sync_config = Cfgsync::PcsdSettings.from_text(pcs_config.text())\n      pushed, _ = Cfgsync::save_sync_new_version(\n        sync_config, get_corosync_nodes(), $cluster_name, true\n      )\n      if not pushed\n        return 400, \"Configuration conflict detected.\\n\\nSome nodes had a newer configuration than the local node. Local node's configuration was updated.  Please repeat the last action if appropriate.\"\n      end\n      return 200, warning_messages.join(\"\\n\\n\")\n    else\n      return 400, \"Unable to communicate with remote pcsd on node '#{node}'.\"\n    end\n  end\n\n  post '/manage/newcluster' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    if not allowed_for_superuser(auth_user)\n      return 400, 'Permission denied.'\n    end\n\n    warning_messages = []\n\n    pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text())\n    @manage = true\n    @cluster_name = params[:clustername]\n    @nodes = []\n    nodes_with_indexes = []\n    @nodes_rrp = []\n    options = {}\n    params.each {|k,v|\n      if k.start_with?(\"node-\") and v != \"\"\n        @nodes << v\n        nodes_with_indexes << [k[5..-1].to_i, v]\n        if params.has_key?(\"ring1-\" + k) and params[\"ring1-\" + k] != \"\"\n          @nodes_rrp << v + \",\" + params[\"ring1-\" + k]\n        else\n          @nodes_rrp << v\n        end\n      end\n      if k.start_with?(\"config-\") and v != \"\"\n        options[k.sub(\"config-\",\"\")] = v\n      end\n    }\n    if pcs_config.is_cluster_name_in_use(@cluster_name)\n      return 400, \"The cluster name, '#{@cluster_name}' has already been added to pcsd.  You may not add two clusters with the same name into pcsd.\"\n    end\n\n    @nodes.each {|n|\n      if pcs_config.is_node_in_use(n)\n        return 400, \"The node, '#{n}' is already configured in pcsd.  You may not add a node to two different clusters in pcsd.\"\n      end\n    }\n\n    # first we need to authenticate nodes to each other\n    tokens = add_prefix_to_keys(get_tokens_of_nodes(@nodes), \"node:\")\n    @nodes.each {|n|\n      retval, out = send_request_with_token(\n        auth_user, n, \"/save_tokens\", true, tokens\n      )\n      if retval == 404 # backward compatibility layer\n        warning_messages << \"Unable to do correct authentication of cluster on node '#{n}', because it is running old version of pcs/pcsd.\"\n        break\n      elsif retval != 200\n        return 400, \"Unable to authenticate all nodes on node '#{n}'.\"\n      end\n    }\n\n    # the first node from the form is the source of config files\n    node_to_send_to = nodes_with_indexes.sort[0][1]\n    $logger.info(\n      \"Sending setup cluster request for: #{@cluster_name} to: #{node_to_send_to}\"\n    )\n    code,out = send_request_with_token(\n      auth_user,\n      node_to_send_to,\n      'setup_cluster',\n      true,\n      {\n        :clustername => @cluster_name,\n        :nodes => @nodes_rrp.join(';'),\n        :options => options.to_json\n      },\n      true,\n      nil,\n      60\n    )\n\n    if code == 200\n      pushed = false\n      2.times {\n        # Add the new cluster to config and publish the config.\n        # If this host is a node of the cluster, some other node may send its\n        # own PcsdSettings.  To handle it we just need to reload the config, as\n        # we are waiting for the request to finish, so no locking is needed.\n        # If we are in a different cluster we just try twice to update the\n        # config, dealing with any updates in between.\n        pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text())\n        pcs_config.clusters << Cluster.new(@cluster_name, @nodes)\n        sync_config = Cfgsync::PcsdSettings.from_text(pcs_config.text())\n        pushed, _ = Cfgsync::save_sync_new_version(\n          sync_config, get_corosync_nodes(), $cluster_name, true\n        )\n        break if pushed\n      }\n      if not pushed\n        return 400, \"Configuration conflict detected.\\n\\nSome nodes had a newer configuration than the local node. Local node's configuration was updated.  Please repeat the last action if appropriate.\"\n      end\n    else\n      return 400, \"Unable to create new cluster. If cluster already exists on one or more of the nodes run 'pcs cluster destroy' on all nodes to remove current cluster configuration.\\n\\n#{node_to_send_to}: #{out}\"\n    end\n\n    return warning_messages.join(\"\\n\\n\")\n  end\n\n  post '/manage/removecluster' do\n    pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text())\n    params.each { |k,v|\n      if k.start_with?(\"clusterid-\")\n        pcs_config.remove_cluster(k.sub(\"clusterid-\",\"\"))\n      end\n    }\n    sync_config = Cfgsync::PcsdSettings.from_text(pcs_config.text())\n    pushed, _ = Cfgsync::save_sync_new_version(\n      sync_config, get_corosync_nodes(), $cluster_name, true\n    )\n    if not pushed\n      return 400, \"Configuration conflict detected.\\n\\nSome nodes had a newer configuration than the local node.  Local node's configuration was updated.  Please repeat the last action if appropriate.\"\n    end\n  end\n\n  get '/manage/check_pcsd_status' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    node_results = {}\n    if params[:nodes] != nil and params[:nodes] != ''\n      node_array = params[:nodes].split(',')\n      online, offline, notauthorized = check_gui_status_of_nodes(\n        auth_user, node_array\n      )\n      online.each { |node|\n        node_results[node] = 'Online'\n      }\n      offline.each { |node|\n        node_results[node] = 'Offline'\n      }\n      notauthorized.each { |node|\n        node_results[node] = 'Unable to authenticate'\n      }\n    end\n    return JSON.generate(node_results)\n  end\n\n  get '/manage/get_nodes_sw_versions' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    if params[:nodes] != nil and params[:nodes] != ''\n      nodes = params[:nodes].split(',')\n      final_response = {}\n      threads = []\n      nodes.each {|node|\n        threads << Thread.new {\n          code, response = send_request_with_token(\n            auth_user, node, 'get_sw_versions'\n          )\n          begin\n            node_response = JSON.parse(response)\n            if node_response and node_response['notoken'] == true\n              $logger.error(\"ERROR: bad token for #{node}\")\n            end\n            final_response[node] = node_response\n          rescue JSON::ParserError\n          end\n        }\n      }\n      threads.each { |t| t.join }\n      return JSON.generate(final_response)\n    end\n    return '{}'\n  end\n\n  post '/manage/auth_gui_against_nodes' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    node_auth_error = {}\n    new_tokens = {}\n    threads = []\n    params.each { |node|\n      threads << Thread.new {\n        if node[0].end_with?(\"-pass\") and node[0].length > 5\n          nodename = node[0][0..-6]\n          if params.has_key?(\"all\")\n            pass = params[\"pass-all\"]\n          else\n            pass = node[1]\n          end\n          data = {\n            'node-0' => nodename,\n            'username' => SUPERUSER,\n            'password' => pass,\n            'force' => 1,\n          }\n          node_auth_error[nodename] = 1\n          code, response = send_request(auth_user, nodename, 'auth', true, data)\n          if 200 == code\n            token = response.strip\n            if not token.empty?\n              new_tokens[nodename] = token\n              node_auth_error[nodename] = 0\n            end\n          end\n        end\n      }\n    }\n    threads.each { |t| t.join }\n\n    if not new_tokens.empty?\n      cluster_nodes = get_corosync_nodes()\n      tokens_cfg = Cfgsync::PcsdTokens.from_file('')\n      sync_successful, sync_responses = Cfgsync::save_sync_new_tokens(\n        tokens_cfg, new_tokens, cluster_nodes, $cluster_name\n      )\n    end\n\n    return [200, JSON.generate({'node_auth_error' => node_auth_error})]\n  end\n\n  get '/manage/?' do\n    @manage = true\n    erb :manage, :layout => :main\n  end\n\n  get '/clusters_overview' do\n    clusters_overview(params, request, PCSAuth.sessionToAuthUser(session))\n  end\n\n  get '/permissions/?' do\n    @manage = true\n    pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text())\n    @clusters = pcs_config.clusters.sort { |a, b| a.name <=> b.name }\n    erb :permissions, :layout => :main\n  end\n\n  get '/permissions_cluster_form/:cluster/?' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    @cluster_name = params[:cluster]\n    @error = nil\n    @permission_types = []\n    @permissions_dependencies = {}\n    @user_types = []\n    @users_permissions = []\n\n    pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text())\n\n    if not pcs_config.is_cluster_name_in_use(@cluster_name)\n      @error = 'Cluster not found'\n    else\n      code, data = send_cluster_request_with_token(\n        auth_user, @cluster_name, 'get_permissions'\n      )\n      if 404 == code\n        @error = 'Cluster is running an old version of pcsd which does not support permissions'\n      elsif 403 == code\n        @error = 'Permission denied'\n      elsif 200 != code\n        @error = 'Unable to load permissions of the cluster'\n      else\n        begin\n          permissions = JSON.parse(data)\n          if permissions['notoken'] or permissions['noresponse']\n            @error = 'Unable to load permissions of the cluster'\n          else\n            @permission_types = permissions['permission_types'] || []\n            @permissions_dependencies = permissions['permissions_dependencies'] || {}\n            @user_types = permissions['user_types'] || []\n            @users_permissions = permissions['users_permissions'] || []\n          end\n        rescue JSON::ParserError\n          @error = 'Unable to read permissions of the cluster'\n        end\n      end\n    end\n    erb :_permissions_cluster\n  end\n\n  get '/managec/:cluster/main' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    @cluster_name = params[:cluster]\n    pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text())\n    @clusters = pcs_config.clusters\n    @nodes = get_cluster_nodes(params[:cluster])\n    if @nodes == []\n      redirect '/manage/'\n    end\n    @resource_agents = get_resource_agents_avail(auth_user, params)\n    @stonith_agents = get_stonith_agents_avail(auth_user, params)\n    erb :nodes, :layout => :main\n  end\n\n  post '/managec/:cluster/permissions_save/?' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    new_params = {\n      'json_data' => JSON.generate(params)\n    }\n    return send_cluster_request_with_token(\n      auth_user, params[:cluster], \"set_permissions\", true, new_params\n    )\n  end\n\n  get '/managec/:cluster/status_all' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    status_all(params, request, auth_user, get_cluster_nodes(params[:cluster]))\n  end\n\n  get '/managec/:cluster/cluster_status' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    cluster_status_gui(auth_user, params[:cluster])\n  end\n\n  get '/managec/:cluster/cluster_properties' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    cluster = params[:cluster]\n    unless cluster\n      return 200, {}\n    end\n    code, out = send_cluster_request_with_token(auth_user, cluster, 'get_cib')\n    if code == 403\n      return [403, 'Permission denied']\n    elsif code != 200\n      return [400, 'getting CIB failed']\n    end\n    begin\n      properties = getAllSettings(nil, REXML::Document.new(out))\n      code, out = send_cluster_request_with_token(\n        auth_user, cluster, 'get_cluster_properties_definition'\n      )\n\n      if code == 403\n        return [403, 'Permission denied']\n      elsif code == 404\n        definition = {\n          'batch-limit' => {\n            'name' => 'batch-limit',\n            'source' => 'pengine',\n            'default' => '0',\n            'type' => 'integer',\n            'shortdesc' => 'The number of jobs that pacemaker is allowed to execute in parallel.',\n            'longdesc' => 'The \"correct\" value will depend on the speed and load of your network and cluster nodes.',\n            'readable_name' => 'Batch Limit',\n            'advanced' => false\n          },\n          'no-quorum-policy' => {\n            'name' => 'no-quorum-policy',\n            'source' => 'pengine',\n            'default' => 'stop',\n            'type' => 'enum',\n            'enum' => ['stop', 'freeze', 'ignore', 'suicide'],\n            'shortdesc' => 'What to do when the cluster does not have quorum.',\n            'longdesc' => 'Allowed values:\n    * ignore - continue all resource management\n    * freeze - continue resource management, but don\\'t recover resources from nodes not in the affected partition\n    * stop - stop all resources in the affected cluster partition\n    * suicide - fence all nodes in the affected cluster partition',\n            'readable_name' => 'No Quorum Policy',\n            'advanced' => false\n          },\n          'symmetric-cluster' => {\n            'name' => 'symmetric-cluster',\n            'source' => 'pengine',\n            'default' => 'true',\n            'type' => 'boolean',\n            'shortdesc' => 'All resources can run anywhere by default.',\n            'longdesc' => 'All resources can run anywhere by default.',\n            'readable_name' => 'Symmetric',\n            'advanced' => false\n          },\n          'stonith-enabled' => {\n            'name' => 'stonith-enabled',\n            'source' => 'pengine',\n            'default' => 'true',\n            'type' => 'boolean',\n            'shortdesc' => 'Failed nodes are STONITH\\'d',\n            'longdesc' => 'Failed nodes are STONITH\\'d',\n            'readable_name' => 'Stonith Enabled',\n            'advanced' => false\n          },\n          'stonith-action' => {\n            'name' => 'stonith-action',\n            'source' => 'pengine',\n            'default' => 'reboot',\n            'type' => 'enum',\n            'enum' => ['reboot', 'poweroff', 'off'],\n            'shortdesc' => 'Action to send to STONITH device',\n            'longdesc' => 'Action to send to STONITH device Allowed values: reboot, poweroff, off',\n            'readable_name' => 'Stonith Action',\n            'advanced' => false\n          },\n          'cluster-delay' => {\n            'name' => 'cluster-delay',\n            'source' => 'pengine',\n            'default' => '60s',\n            'type' => 'time',\n            'shortdesc' => 'Round trip delay over the network (excluding action execution)',\n            'longdesc' => 'The \"correct\" value will depend on the speed and load of your network and cluster nodes.',\n            'readable_name' => 'Cluster Delay',\n            'advanced' => false\n          },\n          'stop-orphan-resources' => {\n            'name' => 'stop-orphan-resources',\n            'source' => 'pengine',\n            'default' => 'true',\n            'type' => 'boolean',\n            'shortdesc' => 'Should deleted resources be stopped',\n            'longdesc' => 'Should deleted resources be stopped',\n            'readable_name' => 'Stop Orphan Resources',\n            'advanced' => false\n          },\n          'stop-orphan-actions' => {\n            'name' => 'stop-orphan-actions',\n            'source' => 'pengine',\n            'default' => 'true',\n            'type' => 'boolean',\n            'shortdesc' => 'Should deleted actions be cancelled',\n            'longdesc' => 'Should deleted actions be cancelled',\n            'readable_name' => 'top Orphan Actions',\n            'advanced' => false\n          },\n          'start-failure-is-fatal' => {\n            'name' => 'start-failure-is-fatal',\n            'source' => 'pengine',\n            'default' => 'true',\n            'type' => 'boolean',\n            'shortdesc' => 'Always treat start failures as fatal',\n            'longdesc' => 'This was the old default. However when set to FALSE, the cluster will instead use the resource\\'s failcount and value for resource-failure-stickiness',\n            'readable_name' => 'Start Failure is Fatal',\n            'advanced' => false\n          },\n          'pe-error-series-max' => {\n            'name' => 'pe-error-series-max',\n            'source' => 'pengine',\n            'default' => '-1',\n            'type' => 'integer',\n            'shortdesc' => 'The number of PE inputs resulting in ERRORs to save',\n            'longdesc' => 'Zero to disable, -1 to store unlimited.',\n            'readable_name' => 'PE Error Storage',\n            'advanced' => false\n          },\n          'pe-warn-series-max' => {\n            'name' => 'pe-warn-series-max',\n            'source' => 'pengine',\n            'default' => '5000',\n            'type' => 'integer',\n            'shortdesc' => 'The number of PE inputs resulting in WARNINGs to save',\n            'longdesc' => 'Zero to disable, -1 to store unlimited.',\n            'readable_name' => 'PE Warning Storage',\n            'advanced' => false\n          },\n          'pe-input-series-max' => {\n            'name' => 'pe-input-series-max',\n            'source' => 'pengine',\n            'default' => '4000',\n            'type' => 'integer',\n            'shortdesc' => 'The number of other PE inputs to save',\n            'longdesc' => 'Zero to disable, -1 to store unlimited.',\n            'readable_name' => 'PE Input Storage',\n            'advanced' => false\n          },\n          'enable-acl' => {\n            'name' => 'enable-acl',\n            'source' => 'cib',\n            'default' => 'false',\n            'type' => 'boolean',\n            'shortdesc' => 'Enable CIB ACL',\n            'longdesc' => 'Should pacemaker use ACLs to determine access to cluster',\n            'readable_name' => 'Enable ACLs',\n            'advanced' => false\n          },\n        }\n      elsif code != 200\n        return [400, 'getting properties definition failed']\n      else\n        definition = JSON.parse(out)\n      end\n  \n      definition.each { |name, prop|\n        prop['value'] = properties[name]\n      }\n      return [200, JSON.generate(definition)]\n    rescue\n      return [400, 'unable to get cluster properties']\n    end\n  end\n\n  post '/managec/:cluster/fix_auth_of_cluster' do\n    clustername = params[:cluster]\n    unless clustername\n      return [400, \"cluster name not defined\"]\n    end\n\n    nodes = get_cluster_nodes(clustername)\n    tokens_data = add_prefix_to_keys(get_tokens_of_nodes(nodes), \"node:\")\n\n    retval, out = send_cluster_request_with_token(\n      PCSAuth.getSuperuserAuth(), clustername, \"/save_tokens\", true,\n      tokens_data, true\n    )\n    if retval == 404\n      return [400, \"Old version of PCS/PCSD is running on cluster nodes. Fixing authentication is not supported. Use 'pcs cluster auth' command to authenticate the nodes.\"]\n    elsif retval != 200\n      return [400, \"Authentication failed.\"]\n    end\n    return [200, \"Auhentication of nodes in cluster should be fixed.\"]\n  end\n\n  post '/managec/:cluster/add_node_to_cluster' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    clustername = params[:cluster]\n    new_node = params[\"new_nodename\"]\n\n    if clustername == $cluster_name\n      if not allowed_for_local_cluster(auth_user, Permissions::FULL)\n        return 403, 'Permission denied'\n      end\n    end\n\n    tokens = read_tokens\n\n    if not tokens.include? new_node\n      return [400, \"New node is not authenticated.\"]\n    end\n\n    # Save the new node token on all nodes in a cluster the new node is beeing\n    # added to. Send the token to one node and let the cluster nodes synchronize\n    # it by themselves.\n    token_data = {\"node:#{new_node}\" => tokens[new_node]}\n    retval, out = send_cluster_request_with_token(\n      # new node doesn't have config with permissions yet\n      PCSAuth.getSuperuserAuth(), clustername, '/save_tokens', true, token_data\n    )\n    # If the cluster runs an old pcsd which doesn't support /save_tokens,\n    # ignore 404 in order to not prevent the node to be added.\n    if retval != 404 and retval != 200\n      return [400, 'Failed to save the token of the new node in target cluster.']\n    end\n\n    retval, out = send_cluster_request_with_token(\n      auth_user, clustername, \"/add_node_all\", true, params\n    )\n    if 403 == retval\n      return [retval, out]\n    end\n    if retval != 200\n      return [400, \"Failed to add new node '#{new_node}' into cluster '#{clustername}': #{out}\"]\n    end\n\n    return [200, \"Node added successfully.\"]\n  end\n\n  post '/managec/:cluster/?*' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    raw_data = request.env[\"rack.input\"].read\n    if params[:cluster]\n      request = \"/\" + params[:splat].join(\"/\")\n      code, out = send_cluster_request_with_token(\n        auth_user, params[:cluster], request, true, params, true, raw_data\n      )\n\n      # backward compatibility layer BEGIN\n      # This code correctly remove constraints on pcs/pcsd version 0.9.137 and older\n      redirection = {\n          \"/remove_constraint_remote\" => \"/resource_cmd/rm_constraint\",\n          \"/remove_constraint_rule_remote\" => \"/resource_cmd/rm_constraint_rule\"\n      }\n      if code == 404 and redirection.key?(request)\n        code, out = send_cluster_request_with_token(\n          auth_user,\n          params[:cluster],\n          redirection[request],\n          true,\n          params,\n          false,\n          raw_data\n        )\n      end\n      # bcl END\n      return code, out\n    end\n  end\n\n  get '/managec/:cluster/?*' do\n    auth_user = PCSAuth.sessionToAuthUser(session)\n    raw_data = request.env[\"rack.input\"].read\n    if params[:cluster]\n      send_cluster_request_with_token(\n        auth_user,\n        params[:cluster],\n        \"/\" + params[:splat].join(\"/\"),\n        false,\n        params,\n        true,\n        raw_data\n      )\n    end\n  end\n\n  get '/' do\n    $logger.info \"Redirecting '/'...\\n\"\n    redirect '/manage'\n  end\n\n  get '/wizards/?:wizard?' do\n    return wizard(params, request, params[:wizard])\n  end\n\n  post '/wizards/?:wizard?' do\n    return wizard(params, request, params[:wizard])\n  end\n\n  get '*' do\n    $logger.debug \"Bad URL\"\n    $logger.debug params[:splat]\n    $logger.info \"Redirecting '*'...\\n\"\n    redirect '/manage'\n    redirect \"Bad URL\"\n    call(env.merge(\"PATH_INFO\" => '/nodes'))\n  end\nelse\n  get '*' do\n    $logger.debug \"ERROR: GUI Disabled, Bad URL\"\n    $logger.debug params[:splat]\n    $logger.info \"Redirecting '*'...\\n\"\n    return \"PCSD GUI is disabled\"\n  end\n\nend\n\nclass Node\n  attr_accessor :active, :id, :name, :hostname\n\n  def initialize(id=nil, name=nil, hostname=nil, active=nil)\n    @id, @name, @hostname, @active = id, name, hostname, active\n  end\nend\n\nhelpers do\n  def h(text)\n    Rack::Utils.escape_html(text)\n  end\n\n  def nl2br(text)\n    text.gsub(/\\n/, \"<br>\")\n  end\nend\n", "Pcs = Ember.Application.createWithMixins({\n  LOG_TRANSITIONS: true,\n  cluster_name: get_cluster_name(),\n  cluster_settings: null,\n  cur_page: \"\",\n  opening_resource: \"\",\n  opening_node: \"\",\n  opening_aclrole: \"\",\n  resource_page: function() {\n    if (this.cur_page == \"resources\") return \"display: table-row;\";\n    else return \"display: none;\";\n  }.property(\"cur_page\"),\n  node_page: function() {\n    if (this.cur_page == \"nodes\") return \"display: table-row;\";\n    else return \"display: none;\";\n  }.property(\"cur_page\"),\n  stonith_page: function() {\n    if (this.cur_page == \"stonith\") return \"display: table-row;\";\n    else return \"display: none;\";\n  }.property(\"cur_page\"),\n  configure_page: function() {\n    if (this.cur_page == \"configure\") return \"display: table-row;\";\n    else return \"display: none;\";\n  }.property(\"cur_page\"),\n  acls_page: function() {\n    if (this.cur_page == \"acls\") return \"display: table-row;\";\n    else return \"display: none;\";\n  }.property(\"cur_page\"),\n  manage_page: function() {\n    if (this.cur_page == \"manage\") return \"display: table-row;\";\n    else return \"display: none;\";\n  }.property(\"cur_page\"),\n  permissions_page: function() {\n    if (this.cur_page == \"permissions\") return \"display: table-row;\";\n    else return \"display: none;\";\n  }.property(\"cur_page\"),\n  wizards_page: function() {\n    if (this.cur_page == \"wizards\") return \"display: table-row;\";\n    else return \"display: none;\";\n  }.property(\"cur_page\"),\n\n  getResourcesFromID: function(resources) {\n    var retArray = [];\n    var resource_map = Pcs.resourcesContainer.get('resource_map');\n    $.each(resources, function(_, resource_id) {\n      if (resource_id in resource_map && !resource_map[resource_id].get('stonith')) {\n        retArray.pushObject(resource_map[resource_id]);\n      }\n    });\n    return retArray;\n  },\n  updater: null,\n\n  update: function() {\n    Pcs.get('updater').update();\n  },\n\n  _update: function(first_run) {\n    if (window.location.pathname.lastIndexOf('/manage', 0) !== 0) {\n      return;\n    }\n    if (first_run) {\n      show_loading_screen();\n    }\n    var self = Pcs;\n    var cluster_name = self.cluster_name;\n    if (cluster_name == null) {\n      if (location.pathname.indexOf(\"/manage\") != 0) {\n        return;\n      }\n      Ember.debug(\"Empty Cluster Name\");\n      ajax_wrapper({\n        url: \"/clusters_overview\",\n        dataType: \"json\",\n        timeout: 20000,\n        success: function(data) {\n          Pcs.clusterController.update(data);\n          if (Pcs.clusterController.get('cur_cluster')) {\n            Pcs.clusterController.update_cur_cluster(Pcs.clusterController.get('cur_cluster').get('name'));\n          }\n          if (data[\"not_current_data\"]) {\n            self.update();\n          }\n          hide_loading_screen();\n        },\n        error: function(jqhxr,b,c) {\n          if (jqhxr.responseText) {\n            try {\n              var obj = $.parseJSON(jqhxr.responseText);\n              if (obj.notauthorized == \"true\") {\n                location.reload();\n              }\n            } catch(e) {\n              console.log(\"Error: Unable to parse json for clusters_overview\");\n            }\n          }\n          hide_loading_screen();\n        },\n        complete: function() {\n          Pcs.get('updater').update_finished();\n        }\n      });\n      return;\n    }\n    ajax_wrapper({\n      url: \"cluster_status\",\n      dataType: \"json\",\n      success: function(data) {\n        Pcs.resourcesContainer.update(data);\n        Pcs.nodesController.update(data);\n        Pcs.aclsController.update(data);\n        Pcs.set(\"cluster_settings\",data.cluster_settings);\n        Pcs.set('need_ring1_address', false);\n        Pcs.set('is_cman_with_udpu_transport', false);\n        if (data['need_ring1_address']) {\n          Pcs.set('need_ring1_address', true);\n        }\n        if (data['is_cman_with_udpu_transport']) {\n          Pcs.set('is_cman_with_udpu_transport', true);\n        }\n        var fence_change = false;\n        var resource_change = false;\n        Ember.run.next(function () {\n          var self = Pcs.resourcesContainer;\n          var cur_fence = self.get('cur_fence');\n          var cur_resource = self.get('cur_resource');\n          var resource_map = self.get('resource_map');\n          if (first_run) {\n            refresh_cluster_properties();\n            setup_node_links();\n            Pcs.nodesController.load_node($('#node_list_row').find('.node_selected').first(),true);\n            Pcs.aclsController.load_role($('#acls_list_row').find('.node_selected').first(), true);\n            if (self.get(\"fence_id_to_load\")) {\n              cur_fence = self.get_resource_by_id(self.get(\"fence_id_to_load\"));\n              fence_change = true;\n            }\n            if (self.get(\"resource_id_to_load\")) {\n              cur_resource = self.get_resource_by_id(self.get(\"resource_id_to_load\"));\n              resource_change = true;\n            }\n          }\n\n          if (cur_fence && cur_fence.get('id') in resource_map) {\n            if (resource_map[cur_fence.get('id')] !== cur_fence) {\n              cur_fence = resource_map[cur_fence.get('id')];\n            }\n          } else {\n            if (self.get('fence_list').length > 0) {\n              cur_fence = self.get('fence_list')[0];\n            } else {\n              cur_fence = null;\n            }\n            fence_change = true;\n          }\n\n          if (cur_resource && cur_resource.get('id') in resource_map) {\n            if (resource_map[cur_resource.get('id')] !== cur_resource) {\n              cur_resource = resource_map[cur_resource.get('id')];\n            }\n          } else {\n            if (self.get('resource_list').length > 0) {\n              cur_resource = self.get('resource_list')[0];\n            } else {\n              cur_resource = null;\n            }\n            resource_change = true;\n          }\n\n          self.set('cur_fence', cur_fence);\n          self.set('cur_resource', cur_resource);\n\n          Ember.run.scheduleOnce('afterRender', Pcs, function () {\n            if (self.get('cur_fence')) {\n              if (fence_change)\n                tree_view_onclick(self.get('cur_fence').get('id'), true);\n              else\n                tree_view_select(self.get('cur_fence').get('id'));\n            }\n            if (self.get('cur_resource')) {\n              if (resource_change)\n                tree_view_onclick(self.get('cur_resource').get('id'), true);\n              else\n                tree_view_select(self.get('cur_resource').get('id'));\n            }\n            Pcs.selectedNodeController.reset();\n            disable_checkbox_clicks();\n          });\n        });\n      },\n      error: function(jqhxr,b,c) {\n        try {\n          var obj = $.parseJSON(jqhxr.responseText);\n          if (obj.notauthorized == \"true\") {\n            location.reload();\n          }\n        } catch(e) {\n          console.log(\"Error: Unable to parse json for cluster_status\")\n        }\n      },\n      complete: function() {\n        hide_loading_screen();\n        Pcs.get('updater').update_finished();\n      }\n    });\n  }\n});\n\nPcs.ValueSelectorComponent = Ember.Component.extend({\n  tagName: 'select',\n  attributeBindings: ['name'],\n  name: null,\n  prompt: \"Select one value\",\n  show_prompt: true,\n  content: [],\n  value: null,\n  _change: function() {\n    var selectedIndex = this.$()[0].selectedIndex,\n      content = this.get('content'),\n      prompt = this.get('show_prompt');\n\n    if (!content || !content.get('length')) { return; }\n    if (prompt && selectedIndex === 0) { this.set('value', \"\"); return; }\n\n    if (prompt) { selectedIndex -= 1; }\n    this.set('value', content.objectAt(selectedIndex)['value']);\n  },\n  init: function() {\n    this._super();\n    this.on(\"change\", this, this._change);\n  }\n});\n\nPcs.ClusterPropertyComponent = Ember.Component.extend({\n  tagName: 'tr',\n  prop: null,\n  attributeBindings: ['name'],\n  boolean_options: [\n    {\n      name: \"true\",\n      value: \"true\"\n    },\n    {\n      name: \"false\",\n      value: \"false\"\n    }\n  ]\n});\n\nPcs.UtilizationTableComponent = Ember.Component.extend({\n  entity: null,\n  type: \"node\", // node or resource\n  form_id: Ember.computed(\"type\", function() {\n    return \"new_\" + this.get(\"type\") + \"_utilization\";\n  }),\n  show_content: false,\n  utilization: [],\n  last_count: 0,\n  util_count: function() {\n    var l = 0;\n    if (this.utilization) {\n      l = this.utilization.length;\n    }\n    //this is needed for not showing/hiding table on each update\n    if (this.last_count != l) {\n      if (l > 0) {\n        this.set('show_content', true);\n      } else {\n        this.set('show_content', false);\n      }\n    }\n    this.set(\"last_count\", l);\n    return l;\n  }.property(\"utilization\"),\n  actions: {\n    toggleBody: function() {\n      this.toggleProperty('show_content');\n    },\n    remove: function(name) {\n      set_utilization(this.type, this.entity.get(\"id\"), name, \"\");\n    },\n    add: function(form_id) {\n      var id = \"#\" + form_id;\n      var name = $(id + \" input[name='new_utilization_name']\").val();\n      if (name == \"\") {\n        return;\n      }\n      var value = $(id + \" input[name='new_utilization_value']\").val().trim();\n      if (!is_integer(value)) {\n        alert(\"Value of utilization attribute has to be integer.\");\n        return;\n      }\n      set_utilization(\n        this.type,\n        this.entity.get(\"id\"),\n        name,\n        value\n      );\n      fade_in_out($(id));\n      $(id + \" input\").val(\"\");\n    }\n  }\n});\n\nPcs.Updater = Ember.Object.extend({\n  timeout: 20000,\n  first_run: true,\n  async: true,\n  autostart: true,\n  started: false,\n  in_progress: false,\n  waiting: false,\n  update_function: null,\n  update_target: null,\n  timer: null,\n\n  start: function() {\n    this.set('started', true);\n    this.update();\n  },\n\n  stop: function() {\n    this.set('started', false);\n    this.cancel_timer();\n  },\n\n  cancel_timer: function() {\n    var self = this;\n    var timer = self.get('timer');\n    if (timer) {\n      self.set('timer', null);\n      Ember.run.cancel(timer);\n    }\n  },\n\n  update: function() {\n    var self = this;\n    if (!self.get('update_function')) {\n      console.log('No update_function defined!');\n      return;\n    }\n    self.cancel_timer();\n    self.set('waiting', false);\n    if (self.get('in_progress')) {\n      self.set('waiting', true);\n    } else {\n      self.set('in_progress', true);\n      self.get('update_function').apply(self.get('update_target'), [self.get('first_run')]);\n      self.set('first_run', false);\n      if (!self.get('async')) {\n        self.update_finished();\n      }\n    }\n  },\n\n  update_finished: function() {\n    var self = this;\n    if (self.get('waiting')) {\n      Ember.run.next(self, self.update);\n    } else if (self.get('started')) {\n      self.set('timer', Ember.run.later(self, self.update, self.get('timeout')));\n    }\n    self.set('in_progress', false);\n  },\n\n  init: function() {\n    var self = this;\n    if (!self.get('update_target')) {\n      self.set('update_target', self);\n    }\n    if (self.get('autostart')) {\n      self.start();\n    }\n  }\n});\n\nPcs.resourcesContainer = Ember.Object.create({\n  resource_map: {},\n  top_level_resource_map: {},\n  fence_list: [],\n  resource_list: [],\n  resource_id_to_load: null,\n  fence_id_to_load: null,\n  cur_resource: null,\n  cur_fence: null,\n  constraints: {},\n  group_list: [],\n  data_version: null,\n\n  get_resource_by_id: function(resource_id) {\n    var resource_map = this.get('resource_map');\n    if (resource_id in resource_map)\n      return resource_map[resource_id];\n    return null;\n  },\n\n  get_family_list: function(parent) {\n    var family = [];\n    family.push(parent);\n    switch (parent[\"class_type\"]) {\n      case \"group\":\n        $.each(parent.get('members'), function(index, member) {\n          family = family.concat(Pcs.resourcesContainer.get_family_list(member));\n        });\n        break;\n      case \"clone\":\n      case \"master\":\n        family = family.concat(Pcs.resourcesContainer.get_family_list(parent.get('member')));\n        break;\n    }\n    return family;\n  },\n\n  get_constraints: function(cons) {\n    var ord_con = {};\n    var loc_con = {};\n    var col_con = {};\n    var ord_set_con = {};\n    var res_loc_constraints = {};\n    var res_ord_constraints = {};\n    var res_ord_set_constraints = {};\n    var res_col_constraints = {};\n    if (cons) {\n      if (cons[\"rsc_location\"]) {\n        $.each(cons[\"rsc_location\"], function (key, value) {\n          loc_con[value[\"id\"]] = value;\n        });\n      }\n      if (cons[\"rsc_order\"]) {\n        $.each(cons[\"rsc_order\"], function (key, value) {\n          if (value[\"sets\"]) {\n            ord_set_con[value[\"id\"]] = value;\n          }\n          else {\n            ord_con[value[\"id\"]] = value;\n          }\n        });\n      }\n      if (cons[\"rsc_colocation\"]) {\n        $.each(cons[\"rsc_colocation\"], function (key, value) {\n          col_con[value[\"id\"]] = value;\n        });\n      }\n    }\n\n    $.each(loc_con, function (key, value) {\n      res_loc_constraints[value[\"rsc\"]] = res_loc_constraints[value[\"rsc\"]] || [];\n      res_loc_constraints[value[\"rsc\"]].push(value);\n    });\n    $.each(ord_con, function (key, value) {\n      first = $.extend({\"other_rsc\":value[\"then\"],\"before\":false}, value);\n      if (value[\"first\"] in res_ord_constraints)\n        res_ord_constraints[value[\"first\"]].push(first);\n      else res_ord_constraints[value[\"first\"]] = [first];\n      then = $.extend({\"other_rsc\":value[\"first\"],\"before\":true}, value);\n      if (value[\"then\"] in res_ord_constraints)\n        res_ord_constraints[value[\"then\"]].push(then);\n      else res_ord_constraints[value[\"then\"]] = [then];\n    });\n\n    $.each(ord_set_con, function(key, set_con) {\n      $.each(set_con[\"sets\"], function(key, set) {\n        $.each(set[\"resources\"], function(key, resource) {\n          res_ord_set_constraints[resource] = res_ord_set_constraints[resource] || [];\n          if (res_ord_set_constraints[resource].indexOf(set_con) != -1) {\n            return;\n          }\n          res_ord_set_constraints[resource].push(set_con);\n        })\n      })\n    });\n\n    $.each(col_con, function (key, value) {\n      if (value[\"score\"] == \"INFINITY\")\n        value[\"together\"] = \"Together\";\n      else if (value[\"score\"] == \"-INFINITY\" || value[\"score\"] < 0)\n        value[\"together\"] = \"Apart\";\n      else if (value[\"score\"] >= 0)\n        value[\"together\"] = \"Together\";\n\n      first = $.extend({\"other_rsc\":value[\"with-rsc\"],\"first\":true}, value);\n      if (value[\"rsc\"] in res_col_constraints)\n        res_col_constraints[value[\"rsc\"]].push(first);\n      else res_col_constraints[value[\"rsc\"]] = [first];\n      second = $.extend({\"other_rsc\":value[\"rsc\"],\"first\":false}, value);\n      if (value[\"with-rsc\"] in res_col_constraints)\n        res_col_constraints[value[\"with-rsc\"]].push(second);\n      else res_col_constraints[value[\"with-rsc\"]] = [second];\n    });\n    return {\n      \"location_constraints\": res_loc_constraints,\n      \"ordering_constraints\": res_ord_constraints,\n      \"ordering_set_constraints\": res_ord_set_constraints,\n      \"colocation_constraints\": res_col_constraints\n    };\n  },\n\n  update_meta_attr: function(resource_id, attr, value) {\n    value = typeof value !== 'undefined' ? value.trim() : \"\";\n    var data = {\n      res_id: resource_id,\n      key: attr,\n      value: value\n    };\n\n    ajax_wrapper({\n      type: 'POST',\n      url: get_cluster_remote_url() + 'add_meta_attr_remote',\n      data: data,\n      timeout: pcs_timeout,\n      error: function (xhr, status, error) {\n        alert(\n          \"Unable to update meta attribute '\" + attr + \"' \"\n          + ajax_simple_error(xhr, status, error)\n        );\n      },\n      complete: function() {\n        Pcs.update();\n      }\n    });\n  },\n\n  enable_resource: function(resource_id) {\n    if (resource_id == null) {\n      return;\n    }\n    ajax_wrapper({\n      type: 'POST',\n      url: get_cluster_remote_url() + 'resource_start',\n      data: {resource: resource_id},\n      timeout: pcs_timeout,\n      success: function(data) {\n        if (data['error']) {\n          alert(\"Unable to enable resource '\" + resource_id + \"': (\" + data['stderr'] + \")\");\n        }\n      },\n      error: function(xhr, status, error) {\n        alert(\n          \"Unable to enable resource '\" + resource_id + \"' \"\n          + ajax_simple_error(xhr, status, error)\n        );\n      },\n      complete: function() {\n        Pcs.update();\n      }\n    });\n  },\n\n  disable_resource: function(resource_id) {\n    if (resource_id == null) {\n      return;\n    }\n    ajax_wrapper({\n      type: 'POST',\n      url: get_cluster_remote_url() + 'resource_stop',\n      data: {resource: resource_id},\n      timeout: pcs_timeout,\n      success: function(data) {\n        if (data['error']) {\n          alert(\"Unable to disable resource '\" + resource_id + \"': (\" + data['stderr'] + \")\");\n        }\n      },\n      error: function(xhr, status, error) {\n        alert(\n          \"Unable to disable resource '\" + resource_id + \"' \"\n          + ajax_simple_error(xhr, status, error)\n        );\n      },\n      complete: function() {\n        Pcs.update();\n      }\n    });\n  },\n\n  delete_resources: function(type, resource_list) {\n    var self = this;\n    var list = self.get(type);\n    $.each(resource_list, function(i, resource) {\n      list.removeObject(resource);\n    });\n  },\n\n  delete_unused_resources: function(type, used_map) {\n    var self = this;\n    var to_delete = [];\n    var list = self.get(type);\n    $.each(list, function(i, resource) {\n      if (!(resource.get('id') in used_map)) {\n        to_delete.push(resource);\n      }\n    });\n    self.delete_resources(type, to_delete);\n  },\n\n  update: function(data) {\n    var self = this;\n    self.set('group_list', data['groups']);\n    self.set(\"data_version\", data['status_version']);\n    var resources = data[\"resource_list\"];\n    var resource_obj = null;\n    var resource_id;\n    var new_resource_map = {};\n    var top_resource_map = {};\n    $.each(resources, function(index, resource) {\n      var update = false;\n      resource_id = resource.id;\n      if (resource_id in self.get('top_level_resource_map')) {\n        resource_obj = self.get('top_level_resource_map')[resource_id];\n        resource_obj.update(resource_obj, resource);\n        update = true;\n      } else {\n        switch (resource[\"class_type\"]) {\n          case \"primitive\":\n            resource_obj = Pcs.PrimitiveObj.create(resource);\n            break;\n          case \"group\":\n            resource_obj = Pcs.GroupObj.create(resource);\n            break;\n          case \"clone\":\n            resource_obj = Pcs.CloneObj.create(resource);\n            break;\n          case \"master\":\n            resource_obj = Pcs.MasterSlaveObj.create(resource);\n            break;\n        }\n      }\n\n      top_resource_map[resource_obj.get('id')] = resource_obj;\n      $.each(self.get_family_list(resource_obj), function(index, resource) {\n        new_resource_map[resource.get('id')] = resource;\n      });\n\n      if (!update) {\n        if (resource_obj.stonith) {\n          self.get('fence_list').pushObject(resource_obj);\n        } else {\n          self.get('resource_list').pushObject(resource_obj);\n        }\n      }\n    });\n\n    self.set('top_level_resource_map', top_resource_map);\n    self.set('resource_map', new_resource_map);\n\n    self.delete_unused_resources(\"fence_list\", top_resource_map);\n    self.delete_unused_resources(\"resource_list\", top_resource_map);\n\n    var constraints = self.get_constraints(data[\"constraints\"]);\n    self.set('constraints', constraints);\n    var resource_map = self.get('resource_map');\n    update_resource_form_groups($(\"#new_resource_agent\"), self.get('group_list').sort());\n    $.each(constraints, function(const_type, cons) {\n      $.each(resource_map, function(resource_id, resource_obj) {\n        if (resource_id in cons) {\n          resource_obj.set(const_type, cons[resource_id]);\n        } else {\n          resource_obj.set(const_type, []);\n        }\n      });\n    });\n    $.each(resource_map, function(resource_id, resource_obj) {\n      resource_obj.set('group_list', self.get('group_list'));\n    });\n    self.set('resource_list', Ember.copy(self.get('resource_list')).sort(function(a,b){return a.get('id').localeCompare(b.get('id'))}));\n    self.set('fence_list', Ember.copy(self.get('fence_list')).sort(function(a,b){return a.get('id').localeCompare(b.get('id'))}));\n  }\n});\n\nPcs.resourcesContainer.reopen({\n  is_version_1: function() {\n    return (this.get(\"data_version\") == '1');\n  }.property('data_version')\n});\n\nPcs.ResourceObj = Ember.Object.extend({\n  id: null,\n  _id: Ember.computed.alias('id'),\n  name: Ember.computed.alias('id'),\n  parent: null,\n  meta_attr: [],\n  meta_attributes: Ember.computed.alias('meta_attr'),\n  disabled: false,\n  error_list: [],\n  warning_list: [],\n  group_list: [],\n  get_group_id: function() {\n    var self = this;\n    var p = self.get('parent');\n    if (p && p.get('class_type') == 'group') {\n      return p.get('id');\n    }\n    return null;\n  }.property('parent'),\n  group_selector: function() {\n    var self = this;\n    var cur_group = self.get('get_group_id');\n    var html = '<select>\\n<option value=\"\">None</option>\\n';\n    $.each(self.get('group_list'), function(_, group) {\n      html += '<option value=\"' + group + '\"';\n      if (cur_group === group) {\n        html += 'selected';\n      }\n      html += '>' + group + '</option>\\n';\n    });\n    html += '</select><input type=\"button\" value=\"Change group\" onclick=\"resource_change_group(curResource(), $(this).prev().prop(\\'value\\'));\">';\n    return html;\n  }.property('group_list', 'get_group_id'),\n  status: \"unknown\",\n  class_type: null, // property to determine type of the resource\n  resource_type: function() { // this property is just for displaying resource type in GUI\n    var t = this.get(\"class_type\");\n    return t[0].toUpperCase() + t.slice(1);\n  }.property(\"class_type\"),\n  res_type: Ember.computed.alias('resource_type'),\n  status_icon: function() {\n    var icon_class = get_status_icon_class(this.get(\"status_val\"));\n    return \"<div style=\\\"float:left;margin-right:6px;height:16px;\\\" class=\\\"\" + icon_class + \" sprites\\\"></div>\";\n  }.property(\"status_val\"),\n  status_val: function() {\n    var status_val = get_status_value(this.get('status'));\n    if (this.get('warning_list').length && status_val != get_status_value('disabled'))\n      status_val = get_status_value(\"warning\");\n    if (this.get('error_list').length)\n      status_val = get_status_value(\"error\");\n    if ((get_status_value(this.get('status')) - status_val) < 0) {\n      return get_status_value(this.get('status'));\n    } else {\n      return status_val;\n    }\n  }.property('status', 'error_list.@each.message', 'warning_list.@each.message'),\n  status_color: function() {\n    return get_status_color(this.get(\"status_val\"));\n  }.property(\"status_val\"),\n  status_style: function() {\n    var color = get_status_color(this.get(\"status_val\"));\n    return \"color: \" + color + ((color != \"green\")? \"; font-weight: bold;\" : \"\");\n  }.property(\"status_val\"),\n  show_status: function() {\n    return '<span style=\"' + this.get('status_style') + '\">' + this.get('status') + '</span>';\n  }.property(\"status_style\", \"disabled\"),\n  status_class: function() {\n    var show = ((Pcs.clusterController.get(\"show_all_resources\"))? \"\" : \"hidden \");\n    return ((this.get(\"status_val\") == get_status_value(\"ok\") || this.status == \"disabled\") ? show + \"default-hidden\" : \"\");\n  }.property(\"status_val\"),\n  status_class_fence: function() {\n    var show = ((Pcs.clusterController.get(\"show_all_fence\"))? \"\" : \"hidden \");\n    return ((this.get(\"status_val\") == get_status_value(\"ok\")) ? show + \"default-hidden\" : \"\");\n  }.property(\"status\", \"status_val\"),\n  tooltip: function() {\n    var self = this;\n    var out = \"\";\n    if (self.error_list.length > 0) {\n      out += \"<span style='color: red;  font-weight: bold;'>ERRORS:</span><br>\\n\";\n      out += get_formated_html_list(self.error_list);\n    }\n    if (self.warning_list.length > 0) {\n      out += \"<span style='color: orange;  font-weight: bold;'>WARNINGS:</span><br>\\n\";\n      out += get_formated_html_list(self.warning_list);\n    }\n    return out;\n  }.property(\"error_list.@each\", \"warning_list.@each\"),\n  span_class: function() {\n    switch (this.get(\"status_val\")) {\n      case get_status_value(\"failed\"):\n        return \"status-error\";\n      case get_status_value(\"warning\"):\n      case get_status_value(\"disabled\"):\n        return \"status-warning\";\n      default:\n        return \"\";\n    }\n  }.property(\"status_val\"),\n\n  location_constraints: [],\n  ordering_constraints: [],\n  ordering_set_constraints: [],\n  colocation_constraints: [],\n\n  get_map: function() {\n    var self = this;\n    var map = {};\n    map[self.get('id')] = self;\n    return map;\n  },\n\n  get_full_warning_list: function() {\n    var self = this;\n    var warning_list = [];\n    $.each(self.get_map(), function(name, resource){\n      warning_list = warning_list.concat(resource.get('warning_list'));\n    });\n    return warning_list;\n  },\n\n  get_full_error_list: function() {\n    var self = this;\n    var error_list = [];\n    $.each(self.get_map(), function(name, resource){\n      error_list = error_list.concat(resource.get('error_list'));\n    });\n    return error_list;\n  },\n\n  update: function(self, data) {\n    $.each(data, function(k, v) {\n      self.set(k, v);\n    });\n    self.refresh();\n  }\n});\n\nPcs.ResourceStatusObj = Ember.Object.extend({\n  id: null,\n  resource_agent: null,\n  managed: false,\n  failed: false,\n  role: null,\n  active: false,\n  orphaned: false,\n  failure_ignored: false,\n  nodes_running_on: 0,\n  pending: null,\n  node: null\n});\n\nPcs.ResourceOperationObj = Ember.Object.extend({\n  call_id: 0,\n  crm_debug_origin: null,\n  crm_feature_set: null,\n  exec_time: 0,\n  exit_reason: null,\n  id: null,\n  interval: 0,\n  last_rc_change: 0,\n  last_run: 0,\n  on_node: null,\n  op_digest: null,\n  operation: null,\n  operation_key: null,\n  op_force_restart: null,\n  op_restart_digest: null,\n  op_status: 0,\n  queue_time: 0,\n  rc_code: 0,\n  transition_key: null,\n  transition_magic: null\n});\n\nPcs.PrimitiveObj = Pcs.ResourceObj.extend({\n  agentname: null,\n  provider: null,\n  type: null,\n  stonith: false,\n  instance_attr: [],\n  instance_status: [],\n  operations: [],\n  utilization: [],\n  resource_type: Ember.computed.alias('agentname'),\n  is_primitive: true,\n  nodes_running_on: function() {\n    var self = this;\n    var nodes = [];\n    var node = null;\n    $.each(self.get('instance_status'), function(index, status) {\n      node = status.get('node');\n      if (node)\n        nodes.push(node.name);\n    });\n    return nodes;\n  }.property('instance_status.@each.node'),\n  is_in_group: function() {\n    var self = this;\n    var p = self.get('parent');\n    return (p && p.get('class_type') == 'group');\n  }.property('parent'),\n  nodes_running_on_string: function() {\n    return this.get('nodes_running_on').join(', ');\n  }.property('nodes_running_on'),\n\n  refresh: function() {\n    var self = this;\n    var stat = self.get(\"crm_status\");\n    var new_stat = [];\n    $.each(stat, function(i,v) {\n      new_stat.push(Pcs.ResourceStatusObj.create(v));\n    });\n    var ops = self.get(\"operations\");\n    var new_ops = [];\n    $.each(ops, function(i,v) {\n      new_ops.push(Pcs.ResourceOperationObj.create(v));\n    });\n    self.set(\"instance_status\", new_stat);\n    self.set(\"operations\", new_ops);\n    self.set(\"crm_status\", null);\n  },\n\n  init: function() {\n    this.refresh();\n  }\n});\n\nPcs.GroupObj = Pcs.ResourceObj.extend({\n  members: [],\n  is_group: true,\n  children: Ember.computed.alias('members'),\n\n  init: function() {\n    this.refresh();\n  },\n\n  get_map: function() {\n    var self = this;\n    var map = self._super();\n    var members = self.get('members');\n    $.each(members, function(i, m){\n      $.extend(map, m.get_map());\n    });\n    return map;\n  },\n\n  refresh: function() {\n    var self = this;\n    var members = self.get(\"members\");\n    var member;\n    var new_members = [];\n    $.each(members, function(i,v) {\n      member = Pcs.PrimitiveObj.create(v);\n      member.set('parent', self);\n      new_members.push(member);\n    });\n    self.set(\"members\", new_members);\n  }\n});\n\nPcs.MultiInstanceObj = Pcs.ResourceObj.extend({\n  member: null,\n  children: function() {\n    return [this.get('member')];\n  }.property('member'),\n  unique: false,\n  managed: false,\n  failed: false,\n  failure_ignored: false,\n  is_multi_instance: true,\n\n  get_map: function() {\n    var self = this;\n    var map = self._super();\n    $.extend(map, self.get('member').get_map());\n    return map;\n  },\n\n  init: function() {\n    this.refresh();\n  },\n\n  refresh: function() {\n    var self = this;\n    var member = self.get(\"member\");\n    var new_member = null;\n    switch (member.class_type) {\n      case \"primitive\":\n        new_member = Pcs.PrimitiveObj.create(member);\n        break;\n      case \"group\":\n        new_member = Pcs.GroupObj.create(member);\n    }\n    new_member.set('parent', self);\n    self.set(\"member\", new_member);\n  }\n});\n\nPcs.CloneObj = Pcs.MultiInstanceObj.extend({\n  is_clone: true\n});\n\nPcs.MasterSlaveObj = Pcs.MultiInstanceObj.extend({\n  masters: [],\n  slaves: [],\n  resource_type: 'Master/Slave'\n});\n\nPcs.Router.map(function() {\n  this.route(\"Configuration\", { path: \"configure\"});\n\n  this.resource(\"ACLs\", {path: \"acls/:aclrole_id\"}, function () {\n    this.route(\"new\");\n  });\n  this.route(\"ACLs\", {path: \"acls\"});\n\n  this.resource(\"Fence Devices\", {path: \"fencedevices/:stonith_id\"}, function () {\n    this.route('new');\n  });\n  this.route(\"Fence Devices\", { path: \"fencedevices\"});\n\n  this.resource(\"Resources\", {path: \"resources/:resource_id\"}, function () {\n    this.route('new');\n  });\n  this.route(\"Resources\", { path: \"resources\"});\n\n  this.resource(\"Nodes\", {path: \"nodes/:node_id\"}, function () {\n    this.route('new');\n  });\n  this.route(\"Nodes\", { path: \"nodes\"});\n\n//  this.resource(\"Resource\", {path: 'resources/:resource_id'});\n  this.route(\"Manage\", {path: \"manage\"});\n  this.route(\"Wizards\", {path: \"wizards\"});\n  this.route(\"Default Route\", { path: \"*x\" });\n});\n\nPcs.ManageRoute = Ember.Route.extend({\n  setupController: function(controller, model) {\n    select_menu(\"MANAGE\");\n  }\n});\n\nPcs.WizardsRoute = Ember.Route.extend({\n  setupController: function(controller, model) {\n    select_menu(\"WIZARDS\");\n  }\n});\n\nPcs.IndexRoute = Ember.Route.extend({\n  setupController: function(controller, model) {\n    if (\n      window.location.pathname == \"/manage\"\n      ||\n      window.location.pathname == \"/manage/\"\n    ) {\n      select_menu(\"MANAGE\");\n    }\n    else if (\n      window.location.pathname == \"/permissions\"\n      ||\n      window.location.pathname == \"/permissions/\"\n    ) {\n      select_menu(\"PERMISSIONS\");\n      Ember.run.scheduleOnce('afterRender', this, permissions_load_all);\n    }\n    else {\n      select_menu(\"NODES\");\n    }\n  }\n});\n\nPcs.DefaultRouteRoute = Ember.Route.extend({\n  setupController: function(controller, model) {\n    if (window.location.pathname.substring(0,7) == \"/manage\")\n      select_menu(\"MANAGE\");\n    else\n      select_menu(\"NODES\");\n  }\n});\n\nPcs.FenceDevicesRoute = Ember.Route.extend({\n  setupController: function(controller, model) {\n    select_menu(\"FENCE DEVICES\");\n  },\n  model: function(params) {\n    Pcs.resourcesContainer.set('fence_id_to_load', params.stonith_id);\n    return params.stonith_id;\n  }\n});\n\nPcs.NodesRoute = Ember.Route.extend({\n  setupController: function(controller, model) {\n    select_menu(\"NODES\");\n  },\n  model: function(params) {\n    Pcs.opening_node = params.node_id;\n    return null;\n  }\n});\n\nPcs.ACLsRoute = Ember.Route.extend({\n  setupController: function(controller, model) {\n    select_menu(\"ACLS\");\n  },\n  model: function(params) {\n    Pcs.opening_aclrole = params.aclrole_id;\n    return null;\n  }\n});\n\nPcs.ConfigurationRoute = Ember.Route.extend({\n  setupController: function(controller, model) {\n    select_menu(\"CONFIGURE\"); \n  }\n});\n\nPcs.ResourcesRoute = Ember.Route.extend({\n  setupController: function(controller, model) {\n    if (model) {\n      select_menu(\"RESOURCES\",model.name);\n    } else {\n      select_menu(\"RESOURCES\"); \n    }\n  },\n  model: function(params) {\n    Pcs.resourcesContainer.set('resource_id_to_load', params.resource_id);\n    return params.resource_id;\n  }\n});\n\nPcs.Setting = Ember.Object.extend({\n  name: null,\n  readable_name: null,\n  form_name: function() {\n    return \"config[\" + this.get(\"name\") + \"]\";\n  }.property(\"name\"),\n  value: null,\n  cur_val: Ember.computed.oneWay('value'),\n  type: null,\n  source: \"\",\n  default: null,\n  advanced: false,\n  longdesc: \"\",\n  shortdesc: \"\",\n  description: function() {\n    var self = this;\n    var desc = $(\"<div>\").text(self.get(\"shortdesc\")).html();\n    if (self.get(\"longdesc\")) {\n      desc += \"<br><br>\";\n      desc += $(\"<div>\").text(self.get(\"longdesc\")).html();\n    }\n    desc += \"<br><br>\";\n    desc += $(\"<div>\").text(\"Default value: \" + self.get(\"default\")).html();\n    return desc;\n  }.property(\"longdesc\", \"shortdesc\"),\n  is_boolean: function() {\n    return (this.get(\"type\") == \"boolean\");\n  }.property(\"type\"),\n  is_enum: function() {\n    return (this.get(\"type\") == \"enum\");\n  }.property(\"type\"),\n  enum: [],\n  enum_show: function() {\n    var self = this;\n    var out = [];\n    $.each(self.get(\"enum\"), function(_, val) {\n      out.push({\n        name: val,\n        value: val\n      });\n    });\n    return out;\n  }.property(\"enum.@each\")\n});\n\nPcs.Clusternode = Ember.Object.extend({\n  name: null,\n  id: Ember.computed.alias(\"name\"),\n  status: null,\n  status_unknown: function() {\n    return this.get('status') == \"unknown\";\n  }.property(\"status\"),\n  status_val: function() {\n    var status_val = get_status_value(this.get('status'));\n    if (this.get('warning_list').length)\n      status_val = get_status_value(\"warning\");\n    if (this.get('error_list').length)\n      status_val = get_status_value(\"error\");\n    if ((get_status_value(this.get('status')) - status_val) < 0) {\n      return get_status_value(this.get('status'));\n    } else {\n      return status_val;\n    }\n  }.property('status', 'error_list.@each.message', 'warning_list.@each.message'),\n  status_style: function() {\n    var color = get_status_color(this.get(\"status_val\"));\n    return \"color: \" + color + ((color != \"green\")? \"; font-weight: bold;\" : \"\");\n  }.property(\"status_val\"),\n  status_class: function() {\n    var show = ((Pcs.clusterController.get(\"show_all_nodes\"))? \"\" : \"hidden \");\n    return (\n      (this.get(\"status_val\") == get_status_value(\"ok\") || this.status == \"standby\" ||\n      this.status == \"maintenance\")\n        ? show + \"default-hidden\" : \"\"\n    );\n  }.property(\"status_val\"),\n  status_icon: function() {\n    var icon_class = get_status_icon_class(this.get(\"status_val\"));\n    return \"<div style=\\\"float:left;margin-right:6px;\\\" class=\\\"\" + icon_class + \" sprites\\\"></div>\";\n  }.property(\"status_val\"),\n  error_list: [],\n  warning_list: [],\n  tooltip: function() {\n    var self = this;\n    var out = \"\";\n    if (self.error_list && self.error_list.length > 0) {\n      out += \"<span style='color: red;  font-weight: bold;'>ERRORS:</span><br>\\n\";\n      out += get_formated_html_list(self.error_list);\n    }\n    if (self.warning_list && self.warning_list.length > 0) {\n      out += \"<span style='color: orange;  font-weight: bold;'>WARNINGS:</span><br>\\n\";\n      out += get_formated_html_list(self.warning_list);\n    }\n    return out;\n  }.property(\"error_list\", \"warning_list\"),\n  quorum: null,\n  quorum_show: function() {\n    if (this.status == \"unknown\" || this.status == \"offline\" || this.get('quorum') === null) {\n      return '<span style=\"color: orange; font-weight: bold;\">unknown</span>';\n    } else if (this.quorum) {\n      return '<span style=\"color: green;\">YES</span>';\n    } else {\n      return '<span style=\"color: red; font-weight: bold;\">NO</span>';\n    }\n  }.property(\"status\", \"quorum\"),\n  cur_node: false,\n  checked: false,\n  resources_running: [],\n  url: function() { return \"window.location='/nodes/\" + this.get(\"name\")+\"'\"\n  }.property(),\n  trclass: function(){\n    if (this.cur_node == true)\n      return \"node_selected\";\n  }.property(\"cur_node\"),\n  onmouseover: function(){\n    if (this.cur_node == true)\n      return \"\"\n    else\n      return \"hover_over(this);\"\n  }.property(\"cur_node\"),\n  onmouseout: function(){\n    if (this.cur_node == true)\n      return \"\"\n    else\n      return \"hover_out(this);\"\n  }.property(\"cur_node\"),\n  showArrow: function(){\n    if (this.cur_node != true)\n      return \"display:none;\"\n    else\n      return \"\"\n  }.property(\"cur_node\"),\n  node_name_style: function() {\n    if (this.up && !this.get('pacemaker_maintenance')) {\n      return \"\";\n    } else {\n      if (this.get(\"pacemaker_standby\") || this.get(\"pacemaker_maintenance\"))\n        return \"color: #ff6600\";\n      else\n        return \"color:red\";\n    }\n  }.property(\"up\",\"pacemaker_standby\",\"pacemaker_maintenance\"),\n  pacemaker_standby: null,\n  pacemaker_maintenance: Ember.computed.alias('is_in_maintenance'),\n  corosync_enabled: null,\n  pacemaker_enabled: null,\n  pcsd_enabled: null,\n  standby_style: function () {\n    if (this.pacemaker_standby)\n      return \"display: none;\";\n    else\n      return \"\";\n  }.property(\"pacemaker_standby\"),\n  unstandby_style: function() {\n    if (this.pacemaker_standby)\n      return \"\";\n    else\n      return \"display: none;\";\n  }.property(\"pacemaker_standby\"),\n  corosync_startup: function() {\n    if (this.corosync_enabled)\n      return \"Enabled\";\n    else\n      return \"Disabled\";\n  }.property(\"corosync_enabled\"),\n  pacemaker_startup: function() {\n    if (this.pacemaker_enabled)\n      return \"Enabled\";\n    else\n      return \"Disabled\";\n  }.property(\"pacemaker_enabled\"),\n  pcsd_startup: function() {\n    if (this.pcsd_enabled)\n      return \"Enabled\";\n    else\n      return \"Disabled\";\n  }.property(\"pcsd_enabled\"),\n  location_constraints: null,\n  node_attrs: [],\n  utilization: [],\n  is_in_maintenance: function() {\n    var self = this;\n    var result = false;\n    $.each(self.get('node_attrs'), function(_, attr) {\n      if (attr[\"name\"] == \"maintenance\") {\n        result = is_cib_true(attr[\"value\"]);\n        return false; // break foreach loop\n      }\n    });\n    return result;\n  }.property('node_attrs'),\n  fence_levels: [],\n  pcsd: null,\n  corosync_daemon: null,\n  pacemaker_daemon: null,\n});\n\nPcs.Aclrole = Ember.Object.extend({\n  name: null,\n  cur_role: false,\n  checked: false,\n  description: \"\",\n  user_list: null,\n  group_list: null,\n  trclass: function() {\n    return this.cur_role ? \"node_selected\" : \"\";\n  }.property(\"cur_role\"),\n  onmouseover: function() {\n    return this.cur_role ? \"\" : \"hover_over(this);\"\n  }.property(\"cur_role\"),\n  onmouseout: function() {\n    return this.cur_role ? \"\" : \"hover_out(this);\"\n  }.property(\"cur_role\"),\n  showArrow: function(){\n    return this.cur_role ? \"\" : \"display:none\";\n  }.property(\"cur_role\"),\n});\n\nPcs.Cluster = Ember.Object.extend({\n  name: null,\n  url_link: function(){return get_cluster_remote_url(this.name) + \"main\";}.property(\"name\"),\n  input_name: function(){return \"clusterid-\" + this.name;}.property(\"name\"),\n  div_id: function(){return \"cluster_info_\" + this.name}.property(\"name\"),\n  status: \"unknown\",\n  status_unknown: function() {\n    return this.status == \"unknown\";\n  }.property(\"status\"),\n  forbidden: function() {\n    var out = false;\n    $.each(this.get(\"error_list\"), function(key, value) {\n      if (\"forbidden\" == value[\"type\"]) {\n        out = true;\n      }\n    });\n    return out;\n  }.property(\"error_list\"),\n  status_icon: function() {\n    var icon_class = get_status_icon_class(get_status_value(this.get('status')));\n    return \"<div style=\\\"float:left;margin-right:6px;\\\" class=\\\"\" + icon_class + \" sprites\\\"></div>\";\n  }.property(\"status\"),\n  quorum_show: function() {\n    if (this.get('status') == \"unknown\") {\n      return \"<span style='color:orange'>(quorate unknown)</span>\"\n    } else if (!this.get('quorate')) {\n      return \"<span style='color: red'>(doesn't have quorum)</span>\"\n    } else {\n      return \"\"\n    }\n  }.property(\"status\", \"quorate\"),\n  nodes: [],\n  nodes_failed: 0,\n  resource_list: [],\n  resources_failed: 0,\n  fence_list: [],\n  fence_failed: 0,\n  error_list: [],\n  warning_list: [],\n  need_reauth: false,\n  quorate: false,\n\n  get_num_of_failed: function(type) {\n    var num = 0;\n    $.each(this.get(type), function(key, value) {\n      if (value.get(\"status_val\") < get_status_value(\"ok\") &&\n        value.status != \"disabled\" && value.status != \"standby\" &&\n        value.status != \"maintenance\"\n      ) {\n        num++;\n      }\n    });\n    return num;\n  },\n\n  status_sort: function(a,b) {\n    if (a.get(\"status_val\") == b.get(\"status_val\"))\n      return ((a.status == b.status) ? a.get('name').localeCompare(b.get('name')) : ((a.status > b.status) ? 1 : -1));\n    return status_comparator(a.status, b.status)\n  },\n\n  add_resources: function(data) {\n    var self = this;\n    var resources = [];\n    var fence = [];\n    var resource_obj;\n    $.each(data, function (index, resource) {\n      switch (resource[\"class_type\"]) {\n        case \"primitive\":\n          resource_obj = Pcs.PrimitiveObj.create(resource);\n          break;\n        case \"group\":\n          resource_obj = Pcs.GroupObj.create(resource);\n          break;\n        case \"clone\":\n          resource_obj = Pcs.CloneObj.create(resource);\n          break;\n        case \"master\":\n          resource_obj = Pcs.MasterSlaveObj.create(resource);\n          break;\n      }\n\n      var url_link = get_cluster_remote_url(self.get('name')) + \"main#/\" +\n        (resource_obj.get('stonith') ? \"fencedevices/\" : \"resources/\") +\n        resource_obj.get('id');\n      resource_obj.set('url_link', url_link);\n\n      resource_obj.set('warning_list', resource_obj.get_full_warning_list());\n      resource_obj.set('error_list', resource_obj.get_full_error_list());\n\n      if (resource_obj.stonith) {\n        fence.pushObject(resource_obj);\n      } else {\n        resources.pushObject(resource_obj);\n      }\n    });\n    resources.sort(self.status_sort);\n    fence.sort(self.status_sort);\n    self.set('fence_list', fence);\n    self.set('resource_list', resources);\n  },\n\n  add_nodes: function(data, node_attrs) {\n    var self = this;\n    self.set(\"need_reauth\", false);\n    var nodes = [];\n    var node;\n    $.each(data, function(key, val) {\n      if (val[\"warning_list\"]) {\n        $.each(val[\"warning_list\"], function (key, value) {\n          if (self.get('need_reauth'))\n            return false;\n          if (typeof(value.type) !== 'undefined' && value.type == \"nodes_not_authorized\") {\n            self.set(\"need_reauth\", true);\n          }\n        });\n      }\n\n      var attrs = [];\n      if (node_attrs && val[\"name\"] in node_attrs) {\n        attrs = node_attrs[val[\"name\"]];\n      }\n\n      node = Pcs.Clusternode.create({\n        name: val[\"name\"],\n        url_link: get_cluster_remote_url(self.name) + \"main#/nodes/\" + val[\"name\"],\n        status: val[\"status\"],\n        quorum: val[\"quorum\"],\n        error_list: val[\"error_list\"],\n        warning_list: val[\"warning_list\"]\n      });\n      node.set(\"node_attrs\", attrs);\n      if (node.get(\"is_in_maintenance\") && node.get('status_val') > get_status_value(\"maintenance\")) {\n        node.set(\"status\", \"maintenance\");\n      }\n      nodes.push(node);\n    });\n    nodes.sort(self.status_sort);\n    self.set(\"nodes\", nodes);\n  }\n});\n\nPcs.clusterController = Ember.Object.create({\n  cluster_list: Ember.ArrayController.create({\n    content: Ember.A(),\n    sortProperties: ['name'],\n    sortAscending: true\n  }),\n  cur_cluster: null,\n  show_all_nodes: false,\n  show_all_resources: false,\n  show_all_fence: false,\n  num_ok: 0,\n  num_error: 0,\n  num_warning: 0,\n  num_unknown: 0,\n\n  update_cur_cluster: function(cluster_name) {\n    var self = this;\n    $(\"#clusters_list div.arrow\").hide();\n    var selected_cluster = null;\n\n    $.each(self.get('cluster_list').get('content'), function(key, cluster) {\n      if (cluster.get(\"name\") == cluster_name) {\n        selected_cluster = cluster;\n        return false;\n      }\n    });\n\n    self.set('cur_cluster', selected_cluster);\n    if (selected_cluster) {\n      Ember.run.next(function() {\n        $(\"#clusters_list tr[nodeID=\" + cluster_name + \"] div.arrow\").show();\n        correct_visibility_dashboard(self.get('cur_cluster'));\n      });\n    }\n  },\n\n  update: function(data) {\n    var self = this;\n    var clusters = data[\"cluster_list\"];\n    var cluster_name_list = [];\n    self.set(\"num_ok\", 0);\n    self.set(\"num_error\", 0);\n    self.set(\"num_warning\", 0);\n    self.set(\"num_unknown\", 0);\n\n    $.each(clusters, function(key, value) {\n      cluster_name_list.push(value[\"cluster_name\"]);\n      var found = false;\n      var cluster = null;\n\n      $.each(self.get('cluster_list').get('content'), function(key, pre_existing_cluster) {\n        if (pre_existing_cluster && pre_existing_cluster.get('name') == value[\"cluster_name\"]) {\n          found = true;\n          cluster = pre_existing_cluster;\n          cluster.set(\"status\", value[\"status\"]);\n          cluster.set(\"quorate\",value[\"quorate\"]);\n          cluster.set(\"error_list\",value[\"error_list\"]);\n          cluster.set(\"warning_list\",value[\"warning_list\"]);\n        }\n      });\n\n      if (!found) {\n        cluster = Pcs.Cluster.create({\n          name: value[\"cluster_name\"],\n          status: value[\"status\"],\n          quorate: value[\"quorate\"],\n          error_list: value[\"error_list\"],\n          warning_list: value[\"warning_list\"]\n        });\n      }\n\n      cluster.add_nodes(value[\"node_list\"], value[\"node_attr\"]);\n      cluster.add_resources(value[\"resource_list\"]);\n      cluster.set(\"nodes_failed\", cluster.get_num_of_failed(\"nodes\"));\n      cluster.set(\"resources_failed\", cluster.get_num_of_failed(\"resource_list\"));\n      cluster.set(\"fence_failed\", cluster.get_num_of_failed(\"fence_list\"));\n\n      if (cluster.get('status') == \"ok\") {\n        $.each(cluster.get('fence_list').concat(cluster.get('resource_list')), function(index, res) {\n          if (res.get('warning_list').length > 0) {\n            cluster.set(\"status\", \"warning\");\n            return false;\n          }\n        });\n      }\n\n      var nodes_to_auth = [];\n      $.each(cluster.get('warning_list'), function(key, val){\n        if (val.hasOwnProperty(\"type\") && val.type == \"nodes_not_authorized\"){\n          nodes_to_auth = nodes_to_auth.concat(val['node_list']);\n        }\n      });\n      nodes_to_auth = $.unique(nodes_to_auth);\n\n      if (cluster.get('need_reauth') || nodes_to_auth.length > 0) {\n        cluster.get('warning_list').pushObject({\n          message: \"There are few authentication problems. To fix them, click <a href='#' onclick='auth_nodes_dialog(\" + JSON.stringify(nodes_to_auth) + \", null, function() {fix_auth_of_cluster();})'>here</a>.\",\n          type: \"nodes_not_authorized\",\n          node_list: self.nodes_to_auth\n        });\n      }\n\n      if (!found) {\n        self.get('cluster_list').pushObject(cluster);\n      }\n\n      if (cluster.get_num_of_failed(\"nodes\") == cluster.nodes.length) {\n        if (cluster.get('status') != \"unknown\")\n          cluster.get('warning_list').pushObject({\n            message: \"Cluster is offline\"\n          });\n\n        cluster.set(\"status\", \"unknown\");\n      }\n\n      switch (get_status_value(cluster.get('status'))) {\n        case get_status_value(\"ok\"):\n          self.incrementProperty('num_ok');\n          break;\n        case get_status_value(\"error\"):\n          self.incrementProperty('num_error');\n          break;\n        case get_status_value(\"warning\"):\n          self.incrementProperty('num_warning');\n          break;\n        default:\n          self.incrementProperty('num_unknown');\n          break;\n      }\n    });\n\n    var to_remove = [];\n    $.each(self.get('cluster_list').get('content'), function(key,val) {\n      if (cluster_name_list.indexOf(val.get('name')) == -1) {\n        to_remove.pushObject(val);\n      }\n    });\n\n    $.each(to_remove, function(index, val) {\n      self.get('cluster_list').removeObject(val);\n    });\n  }\n});\n\nPcs.aclsController = Ember.ArrayController.createWithMixins({\n  content: [],\n  cur_role: null,\n  role_list: function() {\n    if (this.get(\"roles\"))\n      return Object.keys(this.get(\"roles\"));\n    return [];\n  }.property(\"roles\"),\n  user_list: function() {\n    if (this.get(\"users\"))\n      return Object.keys(this.get(\"users\"));\n    return [];\n  }.property(\"users\"),\n  group_list: function() {\n    if (this.get(\"groups\"))\n      return Object.keys(this.get(\"groups\"));\n    return [];\n  }.property(\"groups\"),\n  load_role: function(role_row, dont_update_hash) {\n    load_row(role_row, this, 'cur_role', '#role_info_div');\n    if (!dont_update_hash) {\n      window.location.hash = \"/acls/\" + $(role_row).attr(\"nodeID\");\n    }\n  },\n  update: function(data) {\n    var self = this;\n    self.set('content',[]);\n    var my_groups = {}, my_users = {}, my_roles = {};\n    var cur_role_holder = \"\";\n    var cur_role_name = \"\";\n    if (data[\"acls\"]) {\n      if (data[\"acls\"][\"group\"]) {\n        $.each(data[\"acls\"][\"group\"], function (k2,v2) {\n          my_groups[k2] = v2;\n        });\n      }\n      if (data[\"acls\"][\"user\"]) {\n        $.each(data[\"acls\"][\"user\"], function (k2,v2) {\n          my_users[k2] = v2;\n        });\n      }\n      if (data[\"acls\"][\"role\"]) {\n        $.each(data[\"acls\"][\"role\"], function (k2,v2) {\n          my_roles[k2] = v2;\n        });\n      }\n    }\n    self.set('roles',my_roles);\n    self.set('users',my_users);\n    self.set('groups',my_groups);\n\n    cur_role_holder = self.cur_role ? self.cur_role.name : \"\";\n\n    $.each(my_roles, function(role_name, role_data) {\n      var found = false;\n      var role = null;\n      $.each(self.content, function(key, pre_existing_role) {\n        if(pre_existing_role && pre_existing_role.name == role_name) {\n          found = true;\n          role = pre_existing_role;\n          role.set(\"name\", role_name);\n          role.set(\"cur_role\", false);\n          role.set(\"description\", role_data[\"description\"]);\n        }\n      });\n      if (!found) {\n        role = Pcs.Aclrole.create({\n          name: role_name,\n          cur_role: false,\n          description: role_data[\"description\"],\n        });\n      }\n      if (role_data[\"permissions\"]) {\n        $.each(role_data[\"permissions\"], function(key, permission) {\n          var parsed = permission.match(/(\\S+)\\s+(\\S+)\\s+(.+)\\((.*)\\)/);\n          role[\"permissions\"] = role[\"permissions\"] || [];\n          role[\"permissions\"].push({\n            type: parsed[1],\n            xpath_id: parsed[2],\n            query_id: parsed[3],\n            permission_id: parsed[4],\n          });\n        });\n      }\n\n      if (cur_role_holder == \"\") {\n        cur_role_name = Pcs.opening_aclrole;\n      }\n      else {\n        cur_role_name = cur_role_holder;\n      }\n      if (role.name == cur_role_name) {\n        role.set(\"cur_role\", true);\n        self.set(\"cur_role\", role);\n      }\n\n      if (!found) {\n        self.pushObject(role);\n      }\n    });\n\n    if (self.content && self.content.length > 0 && self.cur_role == null) {\n      self.set(\"cur_role\", self.content[0]);\n      self.content[0].set(\"cur_role\", true);\n    }\n\n    $.each(my_users, function(user_name, role_list) {\n      $.each(role_list, function(key1, role_name) {\n        $.each(self.content, function(key2, existing_role) {\n          if (existing_role.name == role_name) {\n            if (!existing_role.user_list) {\n              existing_role.user_list = [user_name];\n            }\n            else if (existing_role.user_list.indexOf(user_name) == -1) {\n              existing_role.user_list.push(user_name);\n            }\n          }\n        });\n      });\n    });\n    $.each(my_groups, function(group_name, role_list) {\n      $.each(role_list, function(key1, role_name) {\n        $.each(self.content, function(key2, existing_role) {\n          if (existing_role.name == role_name) {\n            if (!existing_role.group_list) {\n              existing_role.group_list = [group_name];\n            }\n            else if (existing_role.group_list.indexOf(group_name) == -1) {\n              existing_role.group_list.push(group_name);\n            }\n          }\n        });\n      });\n    });\n  }\n});\n\nPcs.settingsController = Ember.Controller.create({\n  properties: [],\n  filtered: [],\n  show_advanced: false,\n  filter: \"\",\n  update: function(properties_definition) {\n    var self = this;\n    var new_properties = [];\n    var property;\n    var value;\n    $.each(properties_definition, function(_, prop_def) {\n      property = Pcs.Setting.create(prop_def);\n      value = property.get(\"value\");\n      if (value) {\n        switch (property.get(\"type\")) {\n          case \"boolean\":\n            value = (is_cib_true(value)) ? \"true\" : \"false\";\n            break;\n          case \"enum\":\n            if (property.get(\"enum\").indexOf(value) == -1) {\n              property.get(\"enum\").push(value);\n            }\n        }\n        property.set(\"value\", value);\n      }\n      new_properties.pushObject(property);\n    });\n    // first basic and then advanced\n    self.set(\"properties\", new_properties.sort(function(a,b) {\n      if (!a.get(\"advanced\") && b.get(\"advanced\")) {\n        return -1;\n      } else if (a.get(\"advanced\") && !b.get(\"advanced\")) {\n        return 1;\n      } else {\n        return a.get('name').localeCompare(b.get('name'));\n      }\n    }));\n  }\n});\n\nPcs.settingsController.reopen({\n  filtered: function() {\n    var self = this;\n    var substr = self.get(\"filter\").toLowerCase();\n    \n    var to_show = [];\n    $.each(self.get(\"properties\"), function(_, e) {\n      if (self.get(\"show_advanced\")) {\n        to_show.pushObject(e);\n      } else if (!e.get(\"advanced\")) {\n        to_show.pushObject(e);\n      }\n    });\n\n    if (!substr) {\n      return to_show;\n    }\n    \n    var filtered = [];\n    $.each(to_show, function(_, e) {\n      if (e.get(\"name\").toLowerCase().includes(substr) || e.get(\"readable_name\").toLowerCase().includes(substr)) {\n        filtered.pushObject(e);\n      }\n    });\n    return filtered;\n  }.property(\"properties\", \"filter\", \"show_advanced\")\n});\n\nPcs.selectedNodeController = Ember.Object.createWithMixins({\n  node: null,\n  reset: function() {\n    if (Pcs.nodesController)\n      this.set('node', Pcs.nodesController.objectAt(0));\n  }\n});\n\nPcs.nodesController = Ember.ArrayController.createWithMixins({\n  content: [],\n  utilization_support: false,\n  cur_node: null,\n  cur_node_attr: function () {\n    var nc = this;\n    if (nc.get('cur_node')) {\n      return nc.get('cur_node').get('node_attrs');\n    }\n    return [];\n  }.property(\"cur_node\", \"content.@each.node_attrs\"),\n  cur_node_fence_levels: function () {\n    var ret_val = [];\n    var nc = this;\n    $.each(this.content, function(node, value) {\n      if (\"fence_levels\" in value && nc.cur_node && value[\"fence_levels\"]) {\n        if (nc.cur_node.name in value[\"fence_levels\"]) {\n          ret_val = ret_val.concat(value[\"fence_levels\"][nc.cur_node.name]);\n        }\n        return false;\n      }\n    });\n    return ret_val;\n  }.property(\"cur_node\", \"content.@each.fence_levels\"),\n  init: function(){\n    this._super();\n  },\n\n  load_node: function(node_row, dont_update_hash){\n    load_row(node_row, this, 'cur_node', '#node_info_div');\n    if (!dont_update_hash)\n      window.location.hash = \"/nodes/\" + $(node_row).attr(\"nodeID\");\n  },\n\n  update: function(data){\n    var self = this;\n    var nodes = [];\n    var corosync_nodes_online = data[\"corosync_online\"];\n    var pacemaker_nodes_online = data[\"pacemaker_online\"];\n    var pacemaker_nodes_standby = data[\"pacemaker_standby\"];\n\n    var resources_on_nodes = {};\n    var lc_on_nodes = {};\n    $.each(data['node_list'], function(index, node) {\n      nodes.push(node.name);\n\n      resources_on_nodes[node.name] = [];\n      $.each(Pcs.resourcesContainer.get('resource_map'), function(resource_id, resource_obj) {\n        var nodes_running_on = resource_obj.get('nodes_running_on');\n        if (nodes_running_on) {\n          $.each(nodes_running_on, function(index, node_name) {\n            if (node.name == node_name) {\n              resources_on_nodes[node.name].push(resource_id);\n            }\n          });\n        }\n      });\n\n      lc_on_nodes[node.name] = [];\n      if (data[\"constraints\"] && data[\"constraints\"][\"rsc_location\"]) {\n        $.each(data[\"constraints\"][\"rsc_location\"], function(key, constraint) {\n          if (constraint[\"node\"] == node.name)\n            lc_on_nodes[node.name].push(constraint)\n        });\n      }\n    });\n\n    var nodes_checked = {};\n    var cur_node_holder = \"\";\n    if (self.cur_node)\n      cur_node_holder = self.cur_node.name;\n    $.each(self.content, function (key, value) {\n      if (value.checked)\n        nodes_checked[value.name] = true;\n    });\n\n    if (data[\"nodes_utilization\"]) {\n      self.set(\"utilization_support\", true);\n    } else {\n      self.set(\"utilization_support\", false);\n    }\n\n    $.each(data['node_list'], function(_, node_obj) {\n      var node_id = node_obj.name;\n      if ($.inArray(node_id, corosync_nodes_online) > -1) {\n        corosync_online = true;\n      } else {\n        corosync_online = false;\n      }\n\n      if ($.inArray(node_id, pacemaker_nodes_online) > -1) {\n        pacemaker_online = true;\n      } else {\n        pacemaker_online = false;\n      }\n\n      if ($.inArray(node_id, pacemaker_nodes_standby) > -1) {\n        pacemaker_standby = true;\n      } else {\n        pacemaker_standby = false;\n      }\n\n      if (node_obj[\"status\"] == 'unknown') {\n        pcsd_daemon = false\n      } else {\n        pcsd_daemon = true\n      }\n\n      if (node_obj[\"notauthorized\"] == \"true\" || node_obj[\"notoken\"] == true) {\n        authorized = false;\n      } else {\n        authorized = true;\n      }\n\n      if (node_obj[\"corosync\"] && node_obj[\"pacemaker\"] &&\n        pacemaker_online && corosync_online) {\n        up_status = true;\n      } else {\n        up_status = false;\n      }\n\n      var node_attr = [];\n      if (data[\"node_attr\"] && data[\"node_attr\"][node_id]) {\n        node_attr = data[\"node_attr\"][node_id];\n      }\n\n      var utilization = [];\n      if (data[\"nodes_utilization\"] && data[\"nodes_utilization\"][node_id]) {\n        utilization = data[\"nodes_utilization\"][node_id];\n      }\n\n      found = false;\n      var node = null;\n      $.each(self.content, function(key, pre_existing_node) {\n        if (pre_existing_node && pre_existing_node.name == node_id) {\n          node = pre_existing_node;\n          found = true;\n          node.set(\"authorized\",authorized);\n          node.set(\"up\",up_status);\n          node.set(\"pcsd\",pcsd_daemon && authorized);\n          node.set(\"corosync_daemon\", node_obj[\"corosync\"]);\n          node.set(\"corosync_enabled\", node_obj[\"corosync_enabled\"]);\n          node.set(\"pacemaker_daemon\", node_obj[\"pacemaker\"]);\n          node.set(\"pacemaker_enabled\", node_obj[\"pacemaker_enabled\"]);\n          node.set(\"pcsd_enabled\", node_obj[\"pcsd_enabled\"]);\n          node.set(\"corosync\", corosync_online);\n          node.set(\"pacemaker\", pacemaker_online);\n          node.set(\"pacemaker_standby\", pacemaker_standby);\n          node.set(\"cur_node\",false);\n          node.set(\"running_resources\", Pcs.getResourcesFromID($.unique(resources_on_nodes[node_id].sort().reverse())));\n          node.set(\"location_constraints\", lc_on_nodes[node_id].sort());\n          node.set(\"uptime\", node_obj[\"uptime\"]);\n          node.set(\"node_id\", node_obj[\"id\"]);\n          node.set(\"node_attrs\", node_attr);\n          node.set(\"fence_levels\", data[\"fence_levels\"]);\n          node.set(\"status\", node_obj[\"status\"]);\n          node.set(\"utilization\", utilization);\n        }\n      });\n\n      if (found == false) {\n        var node = Pcs.Clusternode.create({\n          name: node_id,\n          authorized:  authorized,\n          up: up_status,\n          pcsd: pcsd_daemon && authorized,\n          corosync_daemon: node_obj[\"corosync\"],\n          corosync_enabled: node_obj[\"corosync_enabled\"],\n          pacemaker_daemon: node_obj[\"pacemaker\"],\n          pacemaker_enabled: node_obj[\"pacemaker_enabled\"],\n          pcsd_enabled: node_obj[\"pcsd_enabled\"],\n          corosync: corosync_online,\n          pacemaker: pacemaker_online,\n          pacemaker_standby: pacemaker_standby,\n          cur_node: false,\n          running_resources: Pcs.getResourcesFromID($.unique(resources_on_nodes[node_id].sort().reverse())),\n          location_constraints: lc_on_nodes[node_id].sort(),\n          uptime: node_obj[\"uptime\"],\n          node_id: node_obj[\"id\"],\n          node_attrs: node_attr,\n          fence_levels: data[\"fence_levels\"],\n          status: node_obj[\"status\"],\n          utilization: utilization\n        });\n      }\n      var pathname = window.location.pathname.split('/');\n\n      if (cur_node_holder == \"\") {\n        cur_node_name = Pcs.opening_node;\n      } else {\n        cur_node_name = cur_node_holder;\n      }\n      if (node.name == cur_node_name) {\n        node.set(\"cur_node\",true);\n        self.set(\"cur_node\", node);\n      }\n\n      if (nodes_checked[node.name])\n        node.set(\"checked\",true);\n\n      if (found == false)\n        self.pushObject(node);\n    });\n    if (self.content && self.content.length > 0 && self.cur_node == null) {\n      self.set(\"cur_node\", self.content[0]);\n      self.content[0].set(\"cur_node\",true);\n    }\n\n    nodesToRemove = [];\n    $.each(self.content, function (key, node) {\n      found = false;\n      $.each(nodes, function (k,v) {\n        if (v == node.name)\n          found = true;\n      });\n      if (!found) {\n        nodesToRemove.push(node);\n      }\n    });\n\n    $.each(nodesToRemove, function(k,v) {\n      self.content.removeObject(v);\n    });\n    self.set('content', Ember.copy(self.get('content').sort(function(a,b){return a.get('name').localeCompare(b.get('name'))})));\n  }\n});\n\nfunction myUpdate() {\n  Pcs.update();\n//  window.setTimeout(myUpdate,4000);\n}\n\nPcs.set('updater', Pcs.Updater.create({\n  timeout: 20000,\n  update_function: Pcs._update,\n  update_target: Pcs\n}));\n", "var pcs_timeout = 30000;\nvar login_dialog_opened = false;\nvar ajax_queue = Array();\n\nfunction curResource() {\n  var obj = Pcs.resourcesContainer.get('cur_resource');\n  if (obj == null) {\n    return null;\n  }\n  return obj.get('id');\n}\n\nfunction curStonith() {\n  var obj = Pcs.resourcesContainer.get('cur_fence');\n  if (obj == null) {\n    return null;\n  }\n  return obj.get('id');\n}\n\nfunction configure_menu_show(item) {\n  $(\"#configure-\"+item).show();\n  $(\".configure-\"+item).addClass(\"selected\");\n}\n\nfunction menu_show(item,show) {\n  if (show) {\n    $(\"#\" + item + \"_menu\").addClass(\"active\");\n  } else {\n    $(\"#\" + item + \"_menu\").removeClass(\"active\");\n  }\n}\n\n// Changes the visible change when another menu is selected\n// If item is specified, we load that item as well\n// If initial is set to true, we load default (first item) on other pages\n// and load the default item on the specified page if item is set\nfunction select_menu(menu, item, initial) {\n  if (menu == \"NODES\") {\n    Pcs.set('cur_page',\"nodes\")\n    if (item)\n      Pcs.nodesController.load_node($('[nodeID='+item+']'));\n    menu_show(\"node\", true);\n  } else {\n    menu_show(\"node\", false);\n  }\n\n  if (menu == \"RESOURCES\") {\n    Pcs.set('cur_page',\"resources\");\n    menu_show(\"resource\", true);\n  } else {\n    menu_show(\"resource\", false);\n  }\n\n  if (menu == \"FENCE DEVICES\") {\n    Pcs.set('cur_page',\"stonith\");\n    menu_show(\"stonith\", true);\n  } else {\n    menu_show(\"stonith\", false);\n  }\n\n  if (menu == \"MANAGE\") {\n    Pcs.set('cur_page',\"manage\");\n    menu_show(\"cluster\", true);\n  } else {\n    menu_show(\"cluster\", false);\n  }\n\n  if (menu == \"PERMISSIONS\") {\n    Pcs.set('cur_page', \"permissions\");\n    menu_show(\"cluster\", true);\n  } else {\n    menu_show(\"cluster\", false);\n  }\n\n  if (menu == \"CONFIGURE\") {\n    Pcs.set('cur_page',\"configure\");\n    menu_show(\"configure\", true);\n  } else {\n    menu_show(\"configure\", false);\n  }\n\n  if (menu == \"ACLS\") {\n    Pcs.set('cur_page',\"acls\");\n    menu_show(\"acls\", true);\n  } else {\n    menu_show(\"acls\", false);\n  }\n\n  if (menu == \"WIZARDS\") {\n    Pcs.set('cur_page',\"wizards\");\n    menu_show(\"wizards\", true);\n  } else {\n    menu_show(\"wizards\", false);\n  }\n}\n\nfunction create_group() {\n  var num_nodes = 0;\n  var node_names = \"\";\n  $(\"#resource_list :checked\").parent().parent().each(function (index,element) {\n    if (element.getAttribute(\"nodeID\")) {\n      num_nodes++;\n      node_names += element.getAttribute(\"nodeID\") + \" \"\n    }\n  });\n\n  if (num_nodes == 0) {\n    alert(\"You must select at least one resource to add to a group\");\n    return;\n  }\n\n  $(\"#resources_to_add_to_group\").val(node_names);\n  $(\"#add_group\").dialog({\n    title: 'Create Group',\n    modal: true,\n    resizable: false,\n    buttons: {\n      Cancel: function() {\n        $(this).dialog(\"close\");\n      },\n      \"Create Group\": function() {\n        var data = $('#add_group > form').serialize();\n        var url = get_cluster_remote_url() + \"add_group\";\n        ajax_wrapper({\n          type: \"POST\",\n          url: url,\n          data: data,\n          success: function() {\n            Pcs.update();\n            $(\"#add_group\").dialog(\"close\");\n          },\n          error: function (xhr, status, error) {\n            alert(\n              \"Error creating group \"\n              + ajax_simple_error(xhr, status, error)\n            );\n            $(\"#add_group\").dialog(\"close\");\n          }\n        });\n      }\n    }\n  });\n}\n\nfunction add_node_dialog() {\n  var buttonOpts = [\n    {\n      text: \"Add Node\",\n      id: \"add_node_submit_btn\",\n      click: function() {\n        $(\"#add_node_submit_btn\").button(\"option\", \"disabled\", true);\n        checkAddingNode();\n      }\n    },\n    {\n      text: \"Cancel\",\n      click: function() {\n        $(this).dialog(\"close\");\n      }\n    }\n  ];\n\n  buttonOpts[\"Cancel\"] = function() {\n    $(this).dialog(\"close\");\n  };\n\n  // If you hit enter it triggers the first button: Add Node\n  $('#add_node').keypress(function(e) {\n    if (e.keyCode == $.ui.keyCode.ENTER && !$(\"#add_node_submit_btn\").button(\"option\", \"disabled\")) {\n        $(\"#add_node_submit_btn\").trigger(\"click\");\n      return false;\n    }\n  });\n\n  $('#add_node').dialog({\n    title: 'Add Node',\n    modal:true,\n    resizable: false,\n    width: 'auto',\n    buttons: buttonOpts\n  });\n}\n\nfunction checkAddingNode(){\n  var nodeName = $(\"#add_node\").children(\"form\").find(\"[name='new_nodename']\").val().trim();\n  if (nodeName == \"\") {\n    $(\"#add_node_submit_btn\").button(\"option\", \"disabled\", false);\n    return false;\n  }\n\n  ajax_wrapper({\n    type: 'GET',\n    url: '/manage/check_pcsd_status',\n    data: {\"nodes\": nodeName},\n    timeout: pcs_timeout,\n    success: function (data) {\n      var mydata = jQuery.parseJSON(data);\n      if (mydata[nodeName] == \"Unable to authenticate\") {\n        auth_nodes_dialog([nodeName], function(){$(\"#add_node_submit_btn\").trigger(\"click\");});\n        $(\"#add_node_submit_btn\").button(\"option\", \"disabled\", false);\n      } else if (mydata[nodeName] == \"Offline\") {\n        alert(\"Unable to contact node '\" + nodeName + \"'\");\n        $(\"#add_node_submit_btn\").button(\"option\", \"disabled\", false);\n      } else {\n        create_node($(\"#add_node\").children(\"form\"));\n      }\n    },\n    error: function (XMLHttpRequest, textStatus, errorThrown) {\n      alert(\"ERROR: Unable to contact server\");\n      $(\"#add_node_submit_btn\").button(\"option\", \"disabled\", false);\n    }\n  });\n}\n\nfunction create_node(form) {\n  var dataString = $(form).serialize();\n  ajax_wrapper({\n    type: \"POST\",\n    url: get_cluster_remote_url() + \"add_node_to_cluster\",\n    data: dataString,\n    success: function(returnValue) {\n      $(\"#add_node_submit_btn\").button(\"option\", \"disabled\", false);\n      $('#add_node').dialog('close');\n      Pcs.update();\n    },\n    error: function(error) {\n      alert(error.responseText);\n      $(\"#add_node_submit_btn\").button(\"option\", \"disabled\", false);\n    }\n  });\n}\n\n// If update is set to true we update the resource instead of create it\n// if stonith is set to true we update/create a stonith agent\nfunction create_resource(form, update, stonith) {\n  dataString = $(form).serialize();\n  var resourceID = $(form).find(\"[name='name']\").val(); \n  url = get_cluster_remote_url() + $(form).attr(\"action\");\n  var name;\n\n  if (stonith)\n    name = \"fence device\";\n  else\n    name = \"resource\"\n\n  ajax_wrapper({\n    type: \"POST\",\n    url: url,\n    data: dataString,\n    dataType: \"json\",\n    success: function(returnValue) {\n      $('input.apply_changes').show();\n      if (returnValue[\"error\"] == \"true\") {\n        alert(returnValue[\"stderr\"]);\n      } else {\n        Pcs.update();\n        if (!update) {\n          if (stonith)\n            $('#add_stonith').dialog('close');\n          else\n            $('#add_resource').dialog('close');\n        } else {\n          reload_current_resource();\n        }\n      }\n    },\n    error: function(xhr, status, error) {\n      if (update) {\n        alert(\n          \"Unable to update \" + name + \" \"\n          + ajax_simple_error(xhr, status, error)\n        );\n      }\n      else {\n        alert(\n          \"Unable to add \" + name + \" \"\n          + ajax_simple_error(xhr, status, error)\n        );\n      }\n      $('input.apply_changes').show();\n    }\n  });\n}\n\n// Don't allow spaces in input fields\nfunction disable_spaces(item) {\n  myitem = item;\n  $(item).find(\"input\").on(\"keydown\", function (e) {\n    return e.which !== 32;\n  });\n}\n\nfunction load_resource_form(item, ra, stonith) {\n  var data = { new: true, resourcename: ra};\n  var command;\n  if (!stonith)\n    command = \"resource_metadata\";\n  else\n    command = \"fence_device_metadata\";\n  \n  item.load(get_cluster_remote_url() + command, data);\n}\n\nfunction update_resource_form_groups(form, group_list) {\n  var select = $(form).find(\"select[name='resource_group']\").first();\n  if (select.length < 1) {\n    return;\n  }\n  var selected = select.val();\n  var selected_valid = false;\n  var select_new = select.clone();\n  select_new.empty();\n  select_new.append('<option value=\"\">None</options>');\n  $.each(group_list, function(index, group) {\n    select_new.append('<option value=\"' + group + '\">' + group + '</options>');\n    if (selected == group) {\n      selected_valid = true;\n    }\n  });\n  if (selected_valid) {\n    select_new.val(selected);\n  }\n  select.replaceWith(select_new);\n}\n\nfunction verify_remove(remove_func, forceable, checklist_id, dialog_id, label, ok_text, title, remove_id) {\n  var remove_id_list = new Array();\n  if (remove_id) {\n    remove_id_list = [remove_id];\n  }\n  else {\n    remove_id_list = get_checked_ids_from_nodelist(checklist_id);\n  }\n  if (remove_id_list.length < 1) {\n    alert(\"You must select at least one \" + label + \" to remove.\");\n    return;\n  }\n\n  var buttonOpts = [\n    {\n      text: ok_text,\n      id: \"verify_remove_submit_btn\",\n      click: function() {\n        if (remove_id_list.length < 1) {\n          return;\n        }\n        $(\"#verify_remove_submit_btn\").button(\"option\", \"disabled\", true);\n        if (forceable) {\n          force = $(\"#\" + dialog_id + \" :checked\").length > 0\n          remove_func(remove_id_list, force);\n        }\n        else {\n          remove_func(remove_id_list);\n        }\n      }\n    },\n    {\n      text: \"Cancel\",\n      id: \"verify_remove_cancel_btn\",\n      click: function() {\n        $(this).dialog(\"destroy\");\n        if (forceable) {\n          $(\"#\" + dialog_id + \" input[name=force]\").attr(\"checked\", false);\n        }\n      }\n    }\n  ];\n\n  var name_list = \"<ul>\";\n  $.each(remove_id_list, function(key, remid) {\n    name_list += \"<li>\" + remid + \"</li>\";\n  });\n  name_list += \"</ul>\";\n  $(\"#\" + dialog_id + \" .name_list\").html(name_list);\n  $(\"#\" + dialog_id).dialog({\n    title: title,\n    modal: true,\n    resizable: false,\n    buttons: buttonOpts\n  });\n}\n\nfunction verify_remove_clusters(cluster_id) {\n  verify_remove(\n    remove_cluster, false, \"cluster_list\", \"dialog_verify_remove_clusters\",\n    \"cluster\", \"Remove Cluster(s)\", \"Cluster Removal\", cluster_id\n  );\n}\n\nfunction verify_remove_nodes(node_id) {\n  verify_remove(\n    remove_nodes, false, \"node_list\", \"dialog_verify_remove_nodes\",\n    \"node\", \"Remove Node(s)\", \"Remove Node\", node_id\n  );\n}\n\nfunction verify_remove_resources(resource_id) {\n  verify_remove(\n    remove_resource, true, \"resource_list\", \"dialog_verify_remove_resources\",\n    \"resource\", \"Remove resource(s)\", \"Resurce Removal\", resource_id\n  );\n}\n\nfunction verify_remove_fence_devices(resource_id) {\n  verify_remove(\n    remove_resource, false, \"stonith_list\", \"dialog_verify_remove_resources\",\n    \"fence device\", \"Remove device(s)\", \"Fence Device Removal\", resource_id\n  );\n}\n\nfunction verify_remove_acl_roles(role_id) {\n  verify_remove(\n    remove_acl_roles, false, \"acls_roles_list\", \"dialog_verify_remove_acl_roles\",\n    \"ACL role\", \"Remove Role(s)\", \"Remove ACL Role\", role_id\n  );\n}\n\nfunction get_checked_ids_from_nodelist(nodelist_id) {\n  var ids = new Array()\n  $(\"#\" + nodelist_id + \" .node_list_check :checked\").each(function (index, element) {\n    if($(element).parent().parent().attr(\"nodeID\")) {\n      ids.push($(element).parent().parent().attr(\"nodeID\"));\n    }\n  });\n  return ids;\n}\n\nfunction local_node_update(node, data) {\n  node_data = data[node];\n\n  for (var n in data) {\n    if (data[n].pacemaker_online && (jQuery.inArray(n, data[n].pacemaker_online) != -1)) {\n      setNodeStatus(n, true);\n    } else {\n      setNodeStatus(n,false);\n    }\n  }\n}\n\nfunction disable_checkbox_clicks() {\n  $('.node_list_check input[type=checkbox]').click(function(e) {\n    e.stopPropagation();\n  });\n}\n\n// Set the status of a service\n// 0 = Running (green)\n// 1 = Stopped (red)\n// 2 = Unknown (gray)\nfunction setStatus(item, status, message) {\n  if (status == 0) {\n    item.removeClass();\n    item.addClass('status');\n  } else if (status == 1) {\n    item.removeClass();\n    item.addClass('status-offline');\n  } else if (status == 2) {\n    item.removeClass();\n    item.addClass('status-unknown');\n  }\n\n  if (typeof message !== 'undefined')\n    item.html(message)\n}\n\n// Set the node in the node list blue or red depending on\n// whether pacemaker is connected or not\nfunction setNodeStatus(node, running) {\n  if (running) {\n    $('.node_name:contains(\"'+node+'\")').css('color','');\n  } else {\n    $('.node_name:contains(\"'+node+'\")').css('color','red');\n  }\n}\n  \n\nfunction fade_in_out(id) {\n  $(id).fadeTo(1000, 0.01, function() {\n    $(id).fadeTo(1000, 1);\n  });\n}\n\nfunction node_link_action(link_selector, url, label) {\n  var node = $.trim($(\"#node_info_header_title_name\").text());\n  fade_in_out(link_selector);\n  ajax_wrapper({\n    type: 'POST',\n    url: url,\n    data: {\"name\": node},\n    success: function() {\n    },\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to \" + label + \" node '\" + node + \"' \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    }\n  });\n}\n\nfunction setup_node_links() {\n  Ember.debug(\"Setup node links\");\n  $(\"#node_start\").click(function() {\n    node_link_action(\n      \"#node_start\", get_cluster_remote_url() + \"cluster_start\", \"start\"\n    );\n  });\n  $(\"#node_stop\").click(function() {\n    var node = $.trim($(\"#node_info_header_title_name\").text());\n    fade_in_out(\"#node_stop\");\n    node_stop(node, false);\n  });\n  $(\"#node_restart\").click(function() {\n    node_link_action(\n      \"#node_restart\", get_cluster_remote_url() + \"node_restart\", \"restart\"\n    );\n  });\n  $(\"#node_standby\").click(function() {\n    node_link_action(\n      \"#node_standby\", get_cluster_remote_url() + \"node_standby\", \"standby\"\n    );\n  });\n  $(\"#node_unstandby\").click(function() {\n    node_link_action(\n      \"#node_unstandby\",\n      get_cluster_remote_url() + \"node_unstandby\",\n      \"unstandby\"\n    );\n  });\n}\n\nfunction node_stop(node, force) {\n  var data = {};\n  data[\"name\"] = node;\n  if (force) {\n    data[\"force\"] = force;\n  }\n  ajax_wrapper({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'cluster_stop',\n    data: data,\n    timeout: pcs_timeout,\n    success: function() {\n    },\n    error: function(xhr, status, error) {\n      if ((status == \"timeout\") || ($.trim(error) == \"timeout\")) {\n        /*\n         We are not interested in timeout because:\n         - it can take minutes to stop a node (resources running on it have\n           to be stopped/moved and we do not need to wait for that)\n         - if pcs is not able to stop a node it returns an (forceable) error\n           immediatelly\n        */\n        return;\n      }\n      var message = \"Unable to stop node '\" + node + \"' \" + ajax_simple_error(\n        xhr, status, error\n      );\n      if (message.indexOf('--force') == -1) {\n        alert(message);\n      }\n      else {\n        message = message.replace(', use --force to override', '');\n        if (confirm(message + \"\\n\\nDo you want to force the operation?\")) {\n          node_stop(node, true);\n        }\n      }\n    }\n  });\n}\n\nfunction enable_resource() {\n  fade_in_out(\"#resource_start_link\");\n  Pcs.resourcesContainer.enable_resource(curResource());\n}\n\nfunction disable_resource() {\n  fade_in_out(\"#resource_stop_link\");\n  Pcs.resourcesContainer.disable_resource(curResource());\n}\n\nfunction cleanup_resource() {\n  var resource = curResource();\n  if (resource == null) {\n    return;\n  }\n  fade_in_out(\"#resource_cleanup_link\");\n  ajax_wrapper({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'resource_cleanup',\n    data: {\"resource\": resource},\n    success: function() {\n    },\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to cleanup resource '\" + resource + \"' \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    }\n  });\n}\n\nfunction cleanup_stonith() {\n  var resource = curStonith();\n  if (resource == null) {\n    return;\n  }\n  fade_in_out(\"#stonith_cleanup_link\");\n  ajax_wrapper({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'resource_cleanup',\n    data: {\"resource\": resource},\n    success: function() {\n    },\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to cleanup resource '\" + resource + \"' \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    }\n  });\n}\n\nfunction checkExistingNode() {\n  var node = \"\";\n  $('input[name=\"node-name\"]').each(function(i,e) {\n    node = e.value;\n  });\n\n  ajax_wrapper({\n    type: 'GET',\n    url: '/manage/check_pcsd_status',\n    data: {\"nodes\": node},\n    timeout: pcs_timeout,\n    success: function (data) {\n      mydata = jQuery.parseJSON(data);\n      update_existing_cluster_dialog(mydata);\n\n    },\n    error: function (XMLHttpRequest, textStatus, errorThrown) {\n      alert(\"ERROR: Unable to contact server\");\n    }\n  });\n}\n\nfunction checkClusterNodes() {\n  var nodes = [];\n  $('input[name^=\"node-\"]').each(function(i,e) {\n    if (e.value != \"\") {\n      nodes.push(e.value)\n    }\n  });\n\n  ajax_wrapper({\n    type: 'GET',\n    url: '/manage/check_pcsd_status',\n    data: {\"nodes\": nodes.join(\",\")},\n    timeout: pcs_timeout,\n    success: function (data) {\n      mydata = jQuery.parseJSON(data);\n      ajax_wrapper({\n        type: 'GET',\n        url: '/manage/get_nodes_sw_versions',\n        data: {\"nodes\": nodes.join(\",\")},\n        timeout: pcs_timeout,\n        success: function(data) {\n          versions = jQuery.parseJSON(data);\n          update_create_cluster_dialog(mydata, versions);\n        },\n        error: function (XMLHttpRequest, textStatus, errorThrown) {\n          alert(\"ERROR: Unable to contact server\");\n        }\n      });\n    },\n    error: function (XMLHttpRequest, textStatus, errorThrown) {\n      alert(\"ERROR: Unable to contact server\");\n    }\n  });\n}\n\nfunction auth_nodes(dialog) {\n  $(\"#auth_failed_error_msg\").hide();\n  ajax_wrapper({\n    type: 'POST',\n    url: '/manage/auth_gui_against_nodes',\n    data: dialog.find(\"#auth_nodes_form\").serialize(),\n    timeout: pcs_timeout,\n    success: function (data) {\n      mydata = jQuery.parseJSON(data);\n      auth_nodes_dialog_update(dialog, mydata);\n    },\n    error: function (XMLHttpRequest, textStatus, errorThrown) {\n      alert(\"ERROR: Unable to contact server\");\n    }\n  });\n}\n\nfunction auth_nodes_dialog_update(dialog_obj, data) {\n  var unauth_nodes = [];\n  var node;\n  if (data['node_auth_error']) {\n    for (node in data['node_auth_error']) {\n      if (data['node_auth_error'][node] != 0) {\n        unauth_nodes.push(node);\n      }\n    }\n  }\n\n  var callback_one = dialog_obj.dialog(\"option\", \"callback_success_one_\");\n  var callback = dialog_obj.dialog(\"option\", \"callback_success_\");\n  if (unauth_nodes.length == 0) {\n    dialog_obj.parent().find(\"#authenticate_submit_btn\").button(\n      \"option\", \"disabled\", false\n    );\n    dialog_obj.find(\"#auth_failed_error_msg\").hide();\n    dialog_obj.dialog(\"close\");\n    if (callback_one !== null)\n      callback_one();\n    if (callback !== null)\n      callback();\n    return unauth_nodes;\n  } else {\n    dialog_obj.find(\"#auth_failed_error_msg\").show();\n  }\n\n  if (unauth_nodes.length == 1) {\n    dialog_obj.find(\"#same_pass\").hide();\n    dialog_obj.find('#auth_nodes_list').find('input:password').each(\n      function(){$(this).show()}\n    );\n  }\n\n  var one_success = false;\n  dialog_obj.find(\"input:password[name$=-pass]\").each(function() {\n    node = $(this).attr(\"name\");\n    node = node.substring(0, node.length - 5);\n    if (unauth_nodes.indexOf(node) == -1) {\n      $(this).parent().parent().remove();\n      one_success = true;\n    } else {\n      $(this).parent().parent().css(\"color\", \"red\");\n    }\n  });\n\n  if (one_success && callback_one !== null)\n    callback_one();\n\n  dialog_obj.parent().find(\"#authenticate_submit_btn\").button(\n    \"option\", \"disabled\", false\n  );\n  return unauth_nodes;\n}\n\nfunction auth_nodes_dialog(unauth_nodes, callback_success, callback_success_one) {\n  callback_success = typeof callback_success !== 'undefined' ? callback_success : null;\n  callback_success_one = typeof callback_success_one !== 'undefined' ? callback_success_one : null;\n\n  var buttonsOpts = [\n    {\n      text: \"Authenticate\",\n      id: \"authenticate_submit_btn\",\n      click: function() {\n        var dialog = $(this);\n        dialog.parent().find(\"#authenticate_submit_btn\").button(\n          \"option\", \"disabled\", true\n        );\n        dialog.find(\"table.err_msg_table\").find(\"span[id$=_error_msg]\").hide();\n        auth_nodes(dialog);\n      }\n    },\n    {\n      text:\"Cancel\",\n      click: function () {\n        $(this).dialog(\"close\");\n      }\n    }\n  ];\n  var dialog_obj = $(\"#auth_nodes\").dialog({title: 'Authentification of nodes',\n    modal: true, resizable: false,\n    width: 'auto',\n    buttons: buttonsOpts,\n    callback_success_: callback_success,\n    callback_success_one_: callback_success_one\n  });\n\n  dialog_obj.find(\"#auth_failed_error_msg\").hide();\n\n  // If you hit enter it triggers the submit button\n  dialog_obj.keypress(function(e) {\n    if (e.keyCode == $.ui.keyCode.ENTER && !dialog_obj.parent().find(\"#authenticate_submit_btn\").button(\"option\", \"disabled\")) {\n      dialog_obj.parent().find(\"#authenticate_submit_btn\").trigger(\"click\");\n      return false;\n    }\n  });\n\n  if (unauth_nodes.length == 0) {\n    if (callback_success !== null) {\n      callback_success();\n    }\n    return;\n  }\n\n  if (unauth_nodes.length == 1) {\n    dialog_obj.find(\"#same_pass\").hide();\n  } else {\n    dialog_obj.find(\"#same_pass\").show();\n    dialog_obj.find(\"input:checkbox[name=all]\").prop(\"checked\", false);\n    dialog_obj.find(\"#pass_for_all\").val(\"\");\n    dialog_obj.find(\"#pass_for_all\").hide();\n  }\n\n  dialog_obj.find('#auth_nodes_list').empty();\n  unauth_nodes.forEach(function(node) {\n    dialog_obj.find('#auth_nodes_list').append(\"\\t\\t\\t<tr><td>\" + node + '</td><td><input type=\"password\" name=\"' + node + '-pass\"></td></tr>\\n');\n  });\n\n}\n\nfunction add_existing_dialog() {\n  var buttonOpts = [\n    {\n      text: \"Add Existing\",\n      id: \"add_existing_submit_btn\",\n      click: function () {\n        $(\"#add_existing_cluster\").find(\"table.err_msg_table\").find(\"span[id$=_error_msg]\").hide();\n        $(\"#add_existing_submit_btn\").button(\"option\", \"disabled\", true);\n        checkExistingNode();\n      }\n    },\n    {\n      text: \"Cancel\",\n      click: function() {\n        $(this).dialog(\"close\");\n      }\n    }\n  ];\n\n  // If you hit enter it triggers the first button: Add Existing\n  $('#add_existing_cluster').keypress(function(e) {\n    if (e.keyCode == $.ui.keyCode.ENTER && !$(\"#add_existing_submit_btn\").button(\"option\", \"disabled\")) {\n      $(this).parent().find(\"button:eq(1)\").trigger(\"click\");\n      return false;\n    }\n  });\n\n  $(\"#add_existing_cluster\").dialog({title: 'Add Existing Cluster',\n    modal: false, resizable: false,\n    width: 'auto',\n    buttons: buttonOpts\n  });\n}\n\nfunction update_existing_cluster_dialog(data) {\n  for (var i in data) {\n    if (data[i] == \"Online\") {\n      ajax_wrapper({\n        type: \"POST\",\n        url: \"/manage/existingcluster\",\n        timeout: pcs_timeout,\n        data: $('#add_existing_cluster_form').serialize(),\n        success: function(data) {\n          if (data) {\n            alert(\"Operation Successful!\\n\\nWarnings:\\n\" + data);\n          }\n          $(\"#add_existing_cluster.ui-dialog-content\").each(function(key, item) {$(item).dialog(\"destroy\")});\n          Pcs.update();\n        },\n        error: function (xhr, status, error) {\n          alert(xhr.responseText);\n          $(\"#add_existing_submit_btn\").button(\"option\", \"disabled\", false);\n        }\n      });\n      return;\n    } else if (data[i] == \"Unable to authenticate\") {\n      auth_nodes_dialog([i], function() {$(\"#add_existing_submit_btn\").trigger(\"click\");});\n      $(\"#add_existing_submit_btn\").button(\"option\", \"disabled\", false);\n      return;\n    }\n    break;\n  }\n  if (data.length > 0) {\n    $('#add_existing_cluster_error_msg').html(i + \": \" + data[i]);\n    $('#add_existing_cluster_error_msg').show();\n  }\n  $('#unable_to_connect_error_msg_ae').show();\n  $(\"#add_existing_submit_btn\").button(\"option\", \"disabled\", false);\n}\n\nfunction update_create_cluster_dialog(nodes, version_info) {\n  var keys = [];\n  for (var i in nodes) {\n    if (nodes.hasOwnProperty(i)) {\n      keys.push(i);\n    }\n  }\n\n  var cant_connect_nodes = 0;\n  var cant_auth_nodes = [];\n  var good_nodes = 0;\n  var addr1_match = 1;\n  var ring0_nodes = [];\n  var ring1_nodes = [];\n  var cman_nodes = [];\n  var noncman_nodes = [];\n  var rhel_versions = [];\n  var versions_check_ok = 1;\n  var cluster_name = $('input[name^=\"clustername\"]').val()\n  var transport = $(\"#create_new_cluster select[name='config-transport']\").val()\n\n    $('#create_new_cluster input[name^=\"node-\"]').each(function() {\n      if ($(this).val() == \"\") {\n        $(this).parent().prev().css(\"background-color\", \"\");\n        return;\n      }\n      for (var i = 0; i < keys.length; i++) {\n        if ($(this).val() == keys[i]) {\n          if (nodes[keys[i]] != \"Online\") {\n            if (nodes[keys[i]] == \"Unable to authenticate\") {\n              cant_auth_nodes.push(keys[i]);\n            } else {\n              $(this).parent().prev().css(\"background-color\", \"red\");\n              cant_connect_nodes++;\n            }\n          } else {\n            $(this).parent().prev().css(\"background-color\", \"\");\n            good_nodes++;\n          }\n        }\n      }\n    });\n\n    if (cant_auth_nodes.length > 0) {\n      auth_nodes_dialog(cant_auth_nodes, function(){$(\"#create_cluster_submit_btn\").trigger(\"click\")});\n      $(\"#create_cluster_submit_btn\").button(\"option\", \"disabled\", false);\n      return;\n    }\n\n  if (transport == \"udpu\") {\n    $('#create_new_cluster input[name^=\"node-\"]').each(function() {\n      if ($(this).val().trim() != \"\") {\n        ring0_nodes.push($(this).attr(\"name\"));\n      }\n    });\n    $('#create_new_cluster input[name^=\"ring1-node-\"]').each(function() {\n      if ($(this).val().trim() != \"\") {\n        ring1_nodes.push($(this).attr(\"name\").substr(\"ring1-\".length));\n      }\n    });\n    if (ring1_nodes.length > 0) {\n      if (ring0_nodes.length != ring1_nodes.length) {\n        addr1_match = 0\n      }\n      else {\n        for (var i = 0; i < ring0_nodes.length; i++) {\n          if (ring0_nodes[i] != ring1_nodes[i]) {\n            addr1_match = 0;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  if(version_info) {\n    $.each(version_info, function(node, versions) {\n      if(! versions[\"pcs\"]) {\n        // we do not have valid info for this node\n        return;\n      }\n      if(versions[\"cman\"]) {\n        cman_nodes.push(node);\n      }\n      else {\n        noncman_nodes.push(node);\n      }\n      if(versions[\"rhel\"]) {\n        if($.inArray(versions[\"rhel\"].join(\".\"), rhel_versions) == -1) {\n          rhel_versions.push(versions[\"rhel\"].join(\".\"))\n        }\n      }\n    });\n  }\n\n  if (cant_connect_nodes != 0) {\n    $(\"#unable_to_connect_error_msg\").show();\n  } else {\n    $(\"#unable_to_connect_error_msg\").hide();\n  }\n\n  if (good_nodes == 0 && cant_connect_nodes == 0) {\n    $(\"#at_least_one_node_error_msg\").show();\n  } else {\n    $(\"#at_least_one_node_error_msg\").hide();\n  }\n\n  if (cluster_name == \"\") {\n    $(\"#bad_cluster_name_error_msg\").show();\n  } else {\n    $(\"#bad_cluster_name_error_msg\").hide();\n  }\n\n  if (addr1_match == 0) {\n    $(\"#addr0_addr1_mismatch_error_msg\").show();\n  }\n  else {\n    $(\"#addr0_addr1_mismatch_error_msg\").hide();\n  }\n  if(versions) {\n    if(cman_nodes.length > 0 && transport == \"udpu\") {\n      if(noncman_nodes.length < 1 && ring1_nodes.length < 1) {\n        transport = \"udp\";\n        $(\"#create_new_cluster select[name='config-transport']\").val(transport);\n        create_cluster_display_rrp(transport);\n      }\n      else {\n        versions_check_ok = 0;\n        $(\"#cman_udpu_transport_error_msg\").show();\n      }\n    }\n    else {\n      $(\"#cman_udpu_transport_error_msg\").hide();\n    }\n\n    if(cman_nodes.length > 1 && noncman_nodes.length > 1) {\n      versions_check_ok = 0;\n      $(\"#cman_mismatch_error_msg\").show();\n    }\n    else {\n      $(\"#cman_mismatch_error_msg\").hide();\n    }\n\n    if(rhel_versions.length > 1) {\n      versions_check_ok = 0;\n      $(\"#rhel_version_mismatch_error_msg\").show();\n    }\n    else {\n      $(\"#rhel_version_mismatch_error_msg\").hide();\n    }\n  }\n  else {\n    $(\"#cman_udpu_transport_error_msg\").hide();\n    $(\"#cman_mismatch_error_msg\").hide();\n    $(\"#rhel_version_mismatch_error_msg\").hide();\n  }\n\n  if (good_nodes != 0 && cant_connect_nodes == 0 && cant_auth_nodes.length == 0 && cluster_name != \"\" && addr1_match == 1 && versions_check_ok == 1) {\n    ajax_wrapper({\n      type: \"POST\",\n      url: \"/manage/newcluster\",\n      timeout: pcs_timeout,\n      data: $('#create_new_cluster_form').serialize(),\n      success: function(data) {\n        if (data) {\n          alert(\"Operation Successful!\\n\\nWarnings:\\n\" + data);\n        }\n        $(\"#create_new_cluster.ui-dialog-content\").each(function(key, item) {$(item).dialog(\"destroy\")});\n        Pcs.update();\n      },\n      error: function (xhr, status, error) {\n        alert(xhr.responseText);\n        $(\"#create_cluster_submit_btn\").button(\"option\", \"disabled\", false);\n      }\n    });\n  } else {\n    $(\"#create_cluster_submit_btn\").button(\"option\", \"disabled\", false);\n  }\n\n}\n\nfunction create_cluster_dialog() {\n  var buttonOpts = [{\n    text: \"Create Cluster\",\n    id: \"create_cluster_submit_btn\",\n    click: function() {\n      $(\"#create_new_cluster\").find(\"table.err_msg_table\").find(\"span[id$=_error_msg]\").hide();\n      $(\"#create_cluster_submit_btn\").button(\"option\", \"disabled\", true);\n      checkClusterNodes();\n    }\n  },\n  {\n    text: \"Cancel\",\n    id: \"create_cluster_cancel_btn\",\n    click: function() {\n      $(this).dialog(\"close\");\n    }\n  }]\n\n  $(\"#create_new_cluster\").dialog({title: 'Create Cluster',\n    modal: false, resizable: false,\n    width: 'auto',\n    buttons: buttonOpts\n  });\n}\n\nfunction create_cluster_add_nodes() {\n  node_list = $(\"#create_new_cluster_form tr\").has(\"input[name^='node-']\");;\n  var ring1_node_list = $(\"#create_new_cluster_form tr\").has(\n    \"input[name^='ring1-node-']\"\n  );\n  cur_num_nodes = node_list.length;\n\n  first_node = node_list.eq(0);\n  new_node = first_node.clone();\n  $(\"input\",new_node).attr(\"name\", \"node-\"+(cur_num_nodes+1));\n  $(\"input\",new_node).val(\"\");\n  $(\"td\", new_node).first().text(\"Node \" + (cur_num_nodes+1)+ \":\");\n  new_node.insertAfter(node_list.last());\n\n  var ring1_first_node = ring1_node_list.eq(0);\n  var ring1_new_node = ring1_first_node.clone();\n  $(\"input\", ring1_new_node).attr(\"name\", \"ring1-node-\" + (cur_num_nodes + 1));\n  $(\"input\", ring1_new_node).val(\"\");\n  $(\"td\", ring1_new_node).first().text(\n    \"Node \" + (cur_num_nodes+1) + \" (Ring 1):\"\n  );\n  ring1_new_node.insertAfter(ring1_node_list.last());\n\n  if (node_list.length == 7)\n    $(\"#create_new_cluster_form tr\").has(\"input[name^='node-']\").last().next().remove();\n}\n\nfunction create_cluster_display_rrp(transport) {\n  if(transport == 'udp') {\n    $('#rrp_udp_transport').show();\n    $('#rrp_udpu_transport').hide();\n  }\n  else {\n    $('#rrp_udp_transport').hide();\n    $('#rrp_udpu_transport').show();\n  };\n}\n\nfunction show_hide_constraints(element) {\n  //$(element).parent().siblings().each (function(index,element) {\n  $(element).parent().nextUntil(\".stop\").toggle();\n  $(element).children(\"span, p\").toggle();\n}\n\nfunction show_hide_constraint_tables(element) {\n  $(element).siblings().hide();\n  $(\"#add_constraint_\" + $(element).val()).show();\n}\n\nfunction hover_over(o) {\n  $(o).addClass(\"node_selected\");\n}\n\nfunction hover_out(o) {\n  $(o).removeClass(\"node_selected\");\n}\n\nfunction reload_current_resource() {\n  tree_view_onclick(curResource(), true);\n  tree_view_onclick(curStonith(), true);\n}\n\nfunction load_row(node_row, ac, cur_elem, containing_elem, also_set, initial_load){\n  hover_over(node_row);\n  $(node_row).siblings().each(function(key,sib) {\n    hover_out(sib);\n  });\n  var self = ac;\n  $(containing_elem).fadeTo(500, .01,function() {\n    node_name = $(node_row).attr(\"nodeID\");\n    $.each(self.content, function(key, node) {\n      if (node.name == node_name) {\n        if (!initial_load) {\n          self.set(cur_elem,node);\n        }\n        node.set(cur_elem, true);\n        if (also_set)\n          self.set(also_set, node);\n      } else {\n        if (self.cur_resource_ston && self.cur_resource_ston.name == node.name)\n          self.content[key].set(cur_elem,true);\n        else if (self.cur_resource_res && self.cur_resource_res.name == node.name)\n          self.content[key].set(cur_elem,true);\n        else\n          self.content[key].set(cur_elem,false);\n      }\n    });\n    $(containing_elem).fadeTo(500,1);\n  });\n}\n\nfunction load_agent_form(resource_id, stonith) {\n  var url;\n  var form;\n  if (stonith) {\n    form = $(\"#stonith_agent_form\");\n    url = '/managec/' + Pcs.cluster_name + '/fence_device_form';\n  } else {\n    form = $(\"#resource_agent_form\");\n    url = '/managec/' + Pcs.cluster_name + '/resource_form?version=2';\n  }\n\n  form.empty();\n\n  var resource_obj = Pcs.resourcesContainer.get_resource_by_id(resource_id);\n  if (!resource_obj || !resource_obj.get('is_primitive'))\n    return;\n\n  var data = {resource: resource_id};\n\n  ajax_wrapper({\n    type: 'GET',\n    url: url,\n    data: data,\n    timeout: pcs_timeout,\n    success: function (data) {\n      Ember.run.next(function(){form.html(data);});\n    }\n  });\n}\n\nfunction show_loading_screen() {\n  $(\"#loading_screen_progress_bar\").progressbar({ value: 100});\n  $(\"#loading_screen\").dialog({\n    modal: true,\n    title: \"Loading\",\n    height: 100,\n    width: 250,\n    hide: {\n      effect: 'fade',\n      direction: 'down',\n      speed: 750\n    }\n  });\n}\n\nfunction hide_loading_screen() {\n  $(\"#loading_screen\").dialog('close');\n  destroy_tooltips();\n}\n\nfunction destroy_tooltips() {\n  $(\"div[id^=ui-tooltip-]\").remove();\n}\n\nfunction remove_cluster(ids) {\n  var data = {};\n  $.each(ids, function(_, cluster) {\n    data[ \"clusterid-\" + cluster] = true;\n  });\n  ajax_wrapper({\n    type: 'POST',\n    url: '/manage/removecluster',\n    data: data,\n    timeout: pcs_timeout,\n    success: function () {\n      $(\"#dialog_verify_remove_clusters.ui-dialog-content\").each(function(key, item) {$(item).dialog(\"destroy\")});\n      Pcs.update();\n    },\n    error: function (xhr, status, error) {\n      alert(\"Unable to remove cluster: \" + res + \" (\"+error+\")\");\n      $(\"#dialog_verify_remove_clusters.ui-dialog-content\").each(function(key, item) {$(item).dialog(\"destroy\")});\n    }\n  });\n}\n\nfunction remove_nodes(ids, force) {\n  var data = {};\n  for (var i=0; i<ids.length; i++) {\n    data[\"nodename-\"+i] = ids[i];\n  }\n  if (force) {\n    data[\"force\"] = force;\n  }\n\n  ajax_wrapper({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'remove_nodes',\n    data: data,\n    timeout: pcs_timeout*3,\n    success: function(data,textStatus) {\n      $(\"#dialog_verify_remove_nodes.ui-dialog-content\").each(function(key, item) {$(item).dialog(\"destroy\")});\n      if (data == \"No More Nodes\") {\n        window.location.href = \"/manage\";\n      } else {\n        Pcs.update();\n      }\n    },\n    error: function (xhr, status, error) {\n      $(\"#dialog_verify_remove_nodes.ui-dialog-content\").each(function(key, item) {$(item).dialog(\"destroy\")});\n      if ((status == \"timeout\") || ($.trim(error) == \"timeout\")) {\n        /*\n         We are not interested in timeout because:\n         - it can take minutes to stop a node (resources running on it have\n           to be stopped/moved and we do not need to wait for that)\n         - if pcs is not able to stop a node it returns an (forceable) error\n           immediatelly\n        */\n        return;\n      }\n      var message = \"Unable to remove nodes (\" + $.trim(error) + \")\";\n      message += \"\\n\" + xhr.responseText;\n      if (message.indexOf('--force') == -1) {\n        alert(message);\n      }\n      else {\n        message = message.replace(', use --force to override', '');\n        if (confirm(message + \"\\n\\nDo you want to force the operation?\")) {\n          remove_nodes(ids, true);\n        }\n      }\n    }\n  });\n}\n\nfunction remove_resource(ids, force) {\n  var data = {};\n  if (force) {\n    data[\"force\"] = force;\n  }\n  var res_obj;\n  $.each(ids, function(_, id) {\n    res_obj = Pcs.resourcesContainer.get_resource_by_id(id);\n    if (!res_obj) {\n      return true; // continue\n    } else if ($.inArray(res_obj.get(\"parent_id\"), ids) == -1) {\n      data[\"resid-\" + id] = true;\n    }\n  });\n\n  ajax_wrapper({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'remove_resource',\n    data: data,\n    timeout: pcs_timeout*3,\n    success: function () {\n      $(\"#dialog_verify_remove_resources.ui-dialog-content\").each(function(key, item) {$(item).dialog(\"destroy\")});\n      $(\"#dialog_verify_remove_resources input[name=force]\").attr(\"checked\", false);\n      Pcs.update();\n    },\n    error: function (xhr, status, error) {\n      error = $.trim(error)\n      var message = \"Unable to remove resources (\" + error + \")\";\n      if (\n        (xhr.responseText.substring(0,6) == \"Error:\") || (\"Forbidden\" == error)\n      ) {\n        message += \"\\n\\n\" + xhr.responseText.replace(\"--force\", \"'Enforce removal'\");\n      }\n      alert(message);\n      $(\"#dialog_verify_remove_resources.ui-dialog-content\").each(\n        function(key, item) { $(item).dialog(\"destroy\"); }\n      );\n      $(\"#dialog_verify_remove_resources input[name=force]\").attr(\"checked\", false);\n      Pcs.update();\n    }\n  });\n}\n\nfunction add_remove_fence_level(parent_id,remove) {\n  var data = {};\n  if (remove == true) {\n    data[\"remove\"] = true;\n    data[\"level\"] = parent_id.attr(\"fence_level\");\n    data[\"node\"] = Pcs.nodesController.cur_node.name;\n    data[\"devices\"] = parent_id.attr(\"fence_devices\");\n  } else {\n    data[\"level\"] = parent_id.parent().find(\"input[name='new_level_level']\").val();\n    data[\"devices\"] = parent_id.parent().find(\"select[name='new_level_value']\").val();\n    data[\"node\"] = Pcs.nodesController.cur_node.name;\n  }\n  fade_in_out(parent_id.parent());\n  ajax_wrapper({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'add_fence_level_remote',\n    data: data,\n    timeout: pcs_timeout,\n    success: function() {\n//      Pcs.nodesController.remove_fence_level();\n      if (!remove) {\n        $(parent_id.parent()).find(\"input\").val(\"\");\n        $(parent_id.parent()).find(\"select\").val(\"\");\n      }\n      Pcs.update();\n    },\n    error: function (xhr, status, error) {\n      if (remove) {\n        alert(\n          \"Unable to remove fence level \"\n          + ajax_simple_error(xhr, status, error)\n        );\n      }\n      else {\n        if (xhr.responseText.substring(0,6) == \"Error:\") {\n          alert(xhr.responseText);\n        } else {\n          alert(\n            \"Unable to add fence level \"\n            + ajax_simple_error(xhr, status, error)\n          );\n        }\n      }\n    }\n  });\n}\n\nfunction remove_node_attr(parent_id) {\n  var data = {};\n  data[\"node\"] = Pcs.nodesController.cur_node.name;\n  data[\"key\"] = parent_id.attr(\"node_attr_key\");\n  data[\"value\"] = \"\"; // empty value will remove attribute\n  fade_in_out(parent_id.parent());\n\n  ajax_wrapper({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'add_node_attr_remote',\n    data: data,\n    timeout: pcs_timeout,\n    success: function() {\n//      Pcs.nodesController.remove_node_attr(data[\"res_id\"], data[\"key\"]);\n      Pcs.update();\n    },\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to remove node attribute \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    }\n  });\n}\n\nfunction add_node_attr(parent_id) {\n  var data = {};\n  data[\"node\"] = Pcs.nodesController.cur_node.name;\n  data[\"key\"] = $(parent_id + \" input[name='new_node_attr_key']\").val();\n  data[\"value\"] = $(parent_id + \" input[name='new_node_attr_value']\").val();\n  fade_in_out($(parent_id));\n\n  ajax_wrapper({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'add_node_attr_remote',\n    data: data,\n    timeout: pcs_timeout,\n    success: function() {\n      $(parent_id + \" input\").val(\"\");\n//      Pcs.nodesController.add_node_attr(data[\"res_id\"], data[\"key\"], data[\"value\"]);\n      Pcs.update();\n    },\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to add node attribute \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    }\n  });\n}\n\nfunction node_maintenance(node) {\n  var data = {\n    node: node,\n    key: \"maintenance\",\n    value: \"on\"\n  };\n  ajax_wrapper({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'add_node_attr_remote',\n    data: data,\n    timeout: pcs_timeout,\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to put node '\" + node + \"' to maintenance mode. \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    },\n    complete: function() {\n      Pcs.update();\n    }\n  });\n}\n\nfunction node_unmaintenance(node) {\n  var data = {\n    node: node,\n    key: \"maintenance\",\n    value: \"\"\n  };\n  ajax_wrapper({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'add_node_attr_remote',\n    data: data,\n    timeout: pcs_timeout,\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to remove node '\" + node + \"' from maintenance mode. \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    },\n    complete: function() {\n      Pcs.update();\n    }\n  });\n}\n\nfunction remove_meta_attr(parent_id) {\n  var resource_id = curResource();\n  if (resource_id == null) {\n    return;\n  }\n  var attr = parent_id.attr(\"meta_attr_key\");\n  fade_in_out(parent_id.parent());\n  Pcs.resourcesContainer.update_meta_attr(resource_id, attr);\n}\n\nfunction add_meta_attr(parent_id) {\n  var resource_id = curResource();\n  if (resource_id == null) {\n    return;\n  }\n  var attr = $(parent_id + \" input[name='new_meta_key']\").val();\n  var value = $(parent_id + \" input[name='new_meta_value']\").val();\n  fade_in_out($(parent_id));\n  $(parent_id + \" input\").val(\"\");\n  Pcs.resourcesContainer.update_meta_attr(resource_id, attr, value);\n}\n\nfunction add_constraint(parent_id, c_type, force) {\n  var data = {};\n  data[\"disable_autocorrect\"] = true;\n  data[\"res_id\"] = Pcs.resourcesContainer.cur_resource.get('id');\n  data[\"node_id\"] = $(parent_id + \" input[name='node_id']\").val();\n  data[\"rule\"] = $(parent_id + \" input[name='node_id']\").val();\n  data[\"score\"] = $(parent_id + \" input[name='score']\").val();\n  data[\"target_res_id\"] = $(parent_id + \" input[name='target_res_id']\").val();\n  data[\"order\"] = $(parent_id + \" select[name='order']\").val();\n  data[\"target_action\"] = $(parent_id + \" select[name='target_action']\").val();\n  data[\"res_action\"] = $(parent_id + \" select[name='res_action']\").val();\n  data[\"colocation_type\"] = $(parent_id + \" select[name='colocate']\").val();\n  data[\"c_type\"] = c_type;\n  if (force) {\n    data[\"force\"] = force;\n  }\n  fade_in_out($(parent_id));\n\n  ajax_wrapper({\n    type: 'POST',\n    url: get_cluster_remote_url() + (\n      data['node_id'] && (data['node_id'].trim().indexOf(' ') != -1)\n      ? 'add_constraint_rule_remote'\n      : 'add_constraint_remote'\n    ),\n    data: data,\n    timeout: pcs_timeout,\n    success: function() {\n      $(parent_id + \" input\").val(\"\");\n      Pcs.update();\n    },\n    error: function (xhr, status, error) {\n      var message = \"Unable to add constraint (\" + $.trim(error) + \")\";\n      var error_prefix = 'Error adding constraint: ';\n      if (xhr.responseText.indexOf('cib_replace failed') == -1) {\n        if (xhr.responseText.indexOf(error_prefix) == 0) {\n          message += \"\\n\\n\" + xhr.responseText.slice(error_prefix.length);\n        }\n        else {\n          message += \"\\n\\n\" + xhr.responseText;\n        }\n      }\n      if (message.indexOf('--force') == -1) {\n        alert(message);\n        Pcs.update();\n      }\n      else {\n        message = message.replace(', use --force to override', '');\n        message = message.replace('Use --force to override.', '');\n        if (confirm(message + \"\\n\\nDo you want to force the operation?\")) {\n          add_constraint(parent_id, c_type, true);\n        }\n      }\n    }\n  });\n}\n\nfunction add_constraint_set(parent_id, c_type, force) {\n  var data = {\n    resources: [],\n    disable_autocorrect: true\n  };\n  $(parent_id + \" input[name='resource_ids[]']\").each(function(index, element) {\n    var resources = element.value.trim();\n    if (resources.length > 0) {\n      data['resources'].push(resources.split(/\\s+/));\n    }\n  });\n  data[\"c_type\"] = c_type;\n  if (force) {\n    data[\"force\"] = force;\n  }\n  if (data['resources'].length < 1) {\n    return;\n  }\n  fade_in_out($(parent_id))\n\n  ajax_wrapper({\n    type: \"POST\",\n    url: get_cluster_remote_url() + \"add_constraint_set_remote\",\n    data: data,\n    timeout: pcs_timeout,\n    success: function() {\n      reset_constraint_set_form(parent_id);\n      Pcs.update();\n    },\n    error: function (xhr, status, error){\n      var message = \"Unable to add constraint (\" + $.trim(error) + \")\";\n      var error_prefix = 'Error adding constraint: ';\n      if (xhr.responseText.indexOf('cib_replace failed') == -1) {\n        if (xhr.responseText.indexOf(error_prefix) == 0) {\n          message += \"\\n\\n\" + xhr.responseText.slice(error_prefix.length);\n        }\n        else {\n          message += \"\\n\\n\" + xhr.responseText;\n        }\n      }\n      if (message.indexOf('--force') == -1) {\n        alert(message);\n        Pcs.update();\n      }\n      else {\n        message = message.replace(', use --force to override', '');\n        message = message.replace('Use --force to override.', '');\n        if (confirm(message + \"\\n\\nDo you want to force the operation?\")) {\n          add_constraint_set(parent_id, c_type, true);\n        }\n      }\n    },\n  });\n}\n\nfunction new_constraint_set_row(parent_id) {\n  $(parent_id + \" td\").first().append(\n    '<br>Set: <input type=\"text\" name=\"resource_ids[]\">'\n  );\n}\n\nfunction reset_constraint_set_form(parent_id) {\n  $(parent_id + \" td\").first().html(\n    'Set: <input type=\"text\" name=\"resource_ids[]\">'\n  );\n}\n\nfunction remove_constraint(id) {\n  fade_in_out($(\"[constraint_id='\"+id+\"']\").parent());\n  ajax_wrapper({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'remove_constraint_remote',\n    data: {\"constraint_id\": id},\n    timeout: pcs_timeout,\n    error: function (xhr, status, error) {\n      alert(\n        \"Error removing constraint \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    },\n    complete: function() {\n      Pcs.update();\n    }\n  });\n}\n\nfunction remove_constraint_rule(id) {\n  fade_in_out($(\"[rule_id='\"+id+\"']\").parent());\n  ajax_wrapper({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'remove_constraint_rule_remote',\n    data: {\"rule_id\": id},\n    timeout: pcs_timeout,\n    error: function (xhr, status, error) {\n      alert(\n        \"Error removing constraint rule \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    },\n    complete: function() {\n      Pcs.update();\n    }\n  });\n}\n\nfunction add_acl_role(form) {\n  var data = {}\n  data[\"name\"] = $(form).find(\"input[name='name']\").val().trim();\n  data[\"description\"] = $(form).find(\"input[name='description']\").val().trim();\n  ajax_wrapper({\n    type: \"POST\",\n    url: get_cluster_remote_url() + \"add_acl_role\",\n    data: data,\n    success: function(data) {\n      Pcs.update();\n      $(form).find(\"input\").val(\"\");\n      $(\"#add_acl_role\").dialog(\"close\");\n    },\n    error: function(xhr, status, error) {\n      alert(\n        \"Error adding ACL role \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    }\n  });\n}\n\nfunction remove_acl_roles(ids) {\n  var data = {};\n  for (var i = 0; i < ids.length; i++) {\n    data[\"role-\" + i] = ids[i];\n  }\n  ajax_wrapper({\n    type: \"POST\",\n    url: get_cluster_remote_url() + \"remove_acl_roles\",\n    data: data,\n    timeout: pcs_timeout*3,\n    success: function(data,textStatus) {\n      $(\"#dialog_verify_remove_acl_roles.ui-dialog-content\").each(\n        function(key, item) { $(item).dialog(\"destroy\"); }\n      );\n      Pcs.update();\n    },\n    error: function (xhr, status, error) {\n      alert(\n        \"Error removing ACL role \"\n        + ajax_simple_error(xhr, status, error)\n      );\n      $(\"#dialog_verify_remove_acl_roles.ui-dialog-content\").each(\n        function(key, item) { $(item).dialog(\"destroy\"); }\n      );\n    }\n  });\n}\n\nfunction add_acl_item(parent_id, item_type) {\n  var data = {};\n  data[\"role_id\"] = Pcs.aclsController.cur_role.name;\n  var item_label = \"\";\n  switch (item_type) {\n    case \"perm\":\n      data[\"item\"] = \"permission\";\n      data[\"type\"] = $(parent_id + \" select[name='role_type']\").val();\n      data[\"xpath_id\"] = $(parent_id + \" select[name='role_xpath_id']\").val();\n      data[\"query_id\"] = $(parent_id + \" input[name='role_query_id']\").val().trim();\n      item_label = \"permission\"\n      break;\n    case \"user\":\n    case \"group\":\n      data[\"item\"] = item_type;\n      data[\"usergroup\"] = $(parent_id + \" input[name='role_assign_user']\").val().trim();\n      item_label = item_type\n      break;\n  }\n  fade_in_out($(parent_id));\n  ajax_wrapper({\n    type: \"POST\",\n    url: get_cluster_remote_url() + 'add_acl',\n    data: data,\n    timeout: pcs_timeout,\n    success: function(data) {\n      $(parent_id + \" input\").val(\"\");\n      Pcs.update();\n    },\n    error: function (xhr, status, error) {\n      alert(\n        \"Error adding \" + item_label + \" \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    }\n  });\n}\n\nfunction remove_acl_item(id,item) {\n  fade_in_out(id);\n  var data = {};\n  var item_label = \"\";\n  switch (item) {\n    case \"perm\":\n      data[\"item\"] = \"permission\";\n      data[\"acl_perm_id\"] = id.attr(\"acl_perm_id\");\n      item_label = \"permission\"\n      break;\n    case \"usergroup\":\n      data[\"item\"] = \"usergroup\";\n      data[\"usergroup_id\"] = id.attr(\"usergroup_id\")\n      data[\"role_id\"] = id.attr(\"role_id\")\n      item_label = \"user / group\"\n      break;\n  }\n\n  ajax_wrapper({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'remove_acl',\n    data: data,\n    timeout: pcs_timeout,\n    success: function (data) {\n      Pcs.update();\n    },\n    error: function (xhr, status, error) {\n      alert(\n        \"Error removing \" + item_label + \" \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    }\n  });\n}\n\nfunction update_cluster_settings() {\n  $(\"#cluster_properties button\").prop(\"disabled\", true);\n  var data = {\n    'hidden[hidden_input]': null // this is needed for backward compatibility \n  };\n  $.each(Pcs.settingsController.get(\"properties\"), function(_, prop) {\n    data[prop.get(\"form_name\")] = prop.get(\"cur_val\");\n  });\n  show_loading_screen();\n  ajax_wrapper({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'update_cluster_settings',\n    data: data,\n    timeout: pcs_timeout,\n    success: function() {\n      refresh_cluster_properties();\n    },\n    error: function (xhr, status, error) {\n      alert(\n        \"Error updating configuration \"\n        + ajax_simple_error(xhr, status, error)\n      );\n      hide_loading_screen();\n      $(\"#cluster_properties button\").prop(\"disabled\", false);\n    }\n  });\n}\n\nfunction refresh_cluster_properties() {\n  Pcs.settingsController.set(\"filter\", \"\");\n  $(\"#cluster_properties button\").prop(\"disabled\", true);\n  ajax_wrapper({\n    url: get_cluster_remote_url() + \"cluster_properties\",\n    timeout: pcs_timeout,\n    dataType: \"json\",\n    success: function(data) {\n      Pcs.settingsController.update(data);\n    },\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to get cluster properties: \"\n        + ajax_simple_error(xhr, status, error)\n      );\n      Pcs.settingsController.update({});\n    },\n    complete: function() {\n      hide_loading_screen();\n      $(\"#cluster_properties button\").prop(\"disabled\", false);\n    }\n  });\n}\n\n// Pull currently managed cluster name out of URL\nfunction get_cluster_name() {\n  var cluster_name = location.pathname.match(\"/managec/(.*)/\");\n  if (cluster_name && cluster_name.length >= 2) {\n    Ember.debug(\"Cluster Name: \" + cluster_name[1]);\n    cluster_name = cluster_name[1];\n    return cluster_name;\n  }\n  Ember.debug(\"Cluster Name is 'null'\");\n  cluster_name = null;\n  return cluster_name;\n}\n\nfunction get_cluster_remote_url(cluster_name) {\n  cluster_name = typeof cluster_name !== 'undefined' ? cluster_name : Pcs.cluster_name;\n  return '/managec/' + cluster_name + \"/\";\n}\n\nfunction checkBoxToggle(cb,nodes) {\n  if (nodes) {\n    cbs = $('#node_list table').find(\".node_list_check input[type=checkbox]\");\n  } else {\n    cbs = $(cb).closest(\"tr\").parent().find(\".node_list_check input[type=checkbox]\")\n  }\n  if ($(cb).prop('checked'))\n    cbs.prop('checked',true).change();\n  else\n    cbs.prop('checked',false).change();\n}\n\nfunction loadWizard(item) {\n  wizard_name = $(item).val();\n  data = {wizard: wizard_name};\n\n  $(\"#wizard_location\").load(\n   get_cluster_remote_url() + 'get_wizard',\n   data);\n}\n\nfunction wizard_submit(form) {\n  data = $(form).serialize();\n  $(\"#wizard_location\").load(\n    get_cluster_remote_url() + 'wizard_submit',\n    data);\n}\n\nfunction update_resource_type_options() {\n  var cp = $(\"#resource_class_provider_selector\").val();\n  var target = $(\"#add_ra_type\");\n  var source = $(\"#all_ra_types\");\n\n  target.empty();\n  source.find(\"option\").each(function(i,v) {\n    if ($(v).val().indexOf(cp) == 0) {\n      new_option = $(v).clone();\n      target.append(new_option);\n    }\n  });\n  target.change();\n}\n\nfunction setup_resource_class_provider_selection() {\n  $(\"#resource_class_provider_selector\").change(function() {\n    update_resource_type_options();\n  });\n  $(\"#resource_class_provider_selector\").change();\n}\n\nfunction get_status_value(status) {\n  var values = {\n    failed: 1,\n    error: 1,\n    offline: 1,\n    blocked: 1,\n    warning: 2,\n    standby: 2,\n    maintenance: 2,\n    \"partially running\": 2,\n    disabled: 3,\n    unknown: 4,\n    ok: 5,\n    running: 5,\n    online: 5\n  };\n  return ((values.hasOwnProperty(status)) ? values[status] : -1);\n}\n\nfunction status_comparator(a,b) {\n  var valA = get_status_value(a);\n  var valB = get_status_value(b);\n  if (valA == -1) return 1;\n  if (valB == -1) return -1;\n  return valA - valB;\n}\n\nfunction get_status_icon_class(status_val) {\n  switch (status_val) {\n    case get_status_value(\"error\"):\n      return \"error\";\n    case get_status_value(\"disabled\"):\n    case get_status_value(\"warning\"):\n      return \"warning\";\n    case get_status_value(\"ok\"):\n      return \"check\";\n    default:\n      return \"x\";\n  }\n}\n\nfunction get_status_color(status_val) {\n  if (status_val == get_status_value(\"ok\")) {\n    return \"green\";\n  }\n  else if (status_val == get_status_value(\"warning\") || status_val == get_status_value(\"unknown\") || status_val == get_status_value('disabled')) {\n    return \"orange\";\n  }\n  return \"red\";\n}\n\nfunction show_hide_dashboard(element, type) {\n  var cluster = Pcs.clusterController.cur_cluster;\n  if (Pcs.clusterController.get(\"show_all_\" + type)) { // show only failed\n    Pcs.clusterController.set(\"show_all_\" + type, false);\n  } else { // show all\n    Pcs.clusterController.set(\"show_all_\" + type, true);\n  }\n  correct_visibility_dashboard_type(cluster, type);\n}\n\nfunction correct_visibility_dashboard(cluster) {\n  if (cluster == null)\n    return;\n  $.each([\"nodes\", \"resources\", \"fence\"], function(key, type) {\n    correct_visibility_dashboard_type(cluster, type);\n  });\n}\n\nfunction correct_visibility_dashboard_type(cluster, type) {\n  if (cluster == null) {\n    return;\n  }\n  destroy_tooltips();\n  var listTable = $(\"#cluster_info_\" + cluster.name).find(\"table.\" + type + \"_list\");\n  var datatable = listTable.find(\"table.datatable\");\n  if (Pcs.clusterController.get(\"show_all_\" + type)) {\n    listTable.find(\"span.downarrow\").show();\n    listTable.find(\"span.rightarrow\").hide();\n    datatable.find(\"tr.default-hidden\").removeClass(\"hidden\");\n  } else {\n    listTable.find(\"span.downarrow\").hide();\n    listTable.find(\"span.rightarrow\").show();\n    datatable.find(\"tr.default-hidden\").addClass(\"hidden\");\n  }\n  if (cluster.get(type + \"_failed\") == 0 && !Pcs.clusterController.get(\"show_all_\" + type)) {\n    datatable.hide();\n  } else {\n    datatable.show();\n  }\n}\n\nfunction get_formated_html_list(data) {\n  if (data == null || data.length == 0) {\n    return \"\";\n  }\n  var out = \"<ul>\";\n  $.each(data, function(key, value) {\n    out += \"<li>\" + htmlEncode(value.message) + \"</li>\";\n  });\n  out += \"</ul>\";\n  return out;\n}\n\nfunction htmlEncode(s)\n{\n  return $(\"<div/>\").text(s).html().replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n}\n\nfunction fix_auth_of_cluster() {\n  show_loading_screen();\n  var clustername = Pcs.clusterController.cur_cluster.name;\n  ajax_wrapper({\n    url: get_cluster_remote_url(clustername) + \"fix_auth_of_cluster\",\n    type: \"POST\",\n    success: function(data) {\n      hide_loading_screen();\n      Pcs.update();\n    },\n    error: function(jqhxr,b,c) {\n      hide_loading_screen();\n      Pcs.update();\n      alert(jqhxr.responseText);\n    }\n  });\n}\n\nfunction get_tree_view_element_id(element) {\n  return $(element).parents('table.tree-element')[0].id;\n}\n\nfunction get_list_view_element_id(element) {\n  return $(element)[0].id;\n}\n\nfunction auto_show_hide_constraints() {\n  var cont = [\"location_constraints\", \"ordering_constraints\", \"ordering_set_constraints\", \"colocation_constraints\", \"meta_attributes\"];\n  $.each(cont, function(index, name) {\n    var elem = $(\"#\" + name)[0];\n    var cur_resource = Pcs.resourcesContainer.get('cur_resource');\n    if (elem && cur_resource) {\n      var visible = $(elem).children(\"span\")[0].style.display != 'none';\n      if (visible && (!cur_resource.get(name) || cur_resource.get(name).length == 0))\n        show_hide_constraints(elem);\n      else if (!visible && cur_resource.get(name) && cur_resource.get(name).length > 0)\n        show_hide_constraints(elem);\n    }\n  });\n}\n\nfunction tree_view_onclick(resource_id, auto) {\n  auto = typeof auto !== 'undefined' ? auto : false;\n  var resource_obj = Pcs.resourcesContainer.get_resource_by_id(resource_id);\n  if (!resource_obj) {\n    console.log(\"Resource \" + resource_id + \"not found.\");\n    return;\n  }\n  if (resource_obj.get('stonith')) {\n    Pcs.resourcesContainer.set('cur_fence', resource_obj);\n    if (!auto) window.location.hash = \"/fencedevices/\" + resource_id;\n  } else {\n    Pcs.resourcesContainer.set('cur_resource', resource_obj);\n    if (!auto) window.location.hash = \"/resources/\" + resource_id;\n    auto_show_hide_constraints();\n  }\n\n  tree_view_select(resource_id);\n\n  Ember.run.next(Pcs, function() {\n    load_agent_form(resource_id, resource_obj.get('stonith'));\n  });\n}\n\nfunction tree_view_select(element_id) {\n  var e = $('#' + element_id);\n  var view = e.parents('table.tree-view');\n  view.find('div.arrow').hide();\n  view.find('tr.children').hide();\n  view.find('table.tree-element').show();\n  view.find('tr.tree-element-name').removeClass(\"node_selected\");\n  e.find('tr.tree-element-name:first').addClass(\"node_selected\");\n  e.find('tr.tree-element-name div.arrow:first').show();\n  e.parents('tr.children').show();\n  e.find('tr.children').show();\n}\n\nfunction list_view_select(element_id) {\n  var e = $('#' + element_id);\n  var view = e.parents('table.list-view');\n  view.find('div.arrow').hide();\n  view.find('tr.list-view-element').removeClass(\"node_selected\");\n  e.addClass('node_selected');\n  e.find('div.arrow').show();\n}\n\nfunction tree_view_checkbox_onchange(element) {\n  var e = $(element);\n  var children = $(element).closest(\".tree-element\").find(\".children\" +\n    \" input:checkbox\");\n  var val = e.prop('checked');\n  children.prop('checked', val);\n  children.prop('disabled', val);\n}\n\nfunction resource_master(resource_id) {\n  if (resource_id == null) {\n    return;\n  }\n  show_loading_screen();\n  ajax_wrapper({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'resource_master',\n    data: {resource_id: resource_id},\n    timeout: pcs_timeout,\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to create master/slave resource \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    },\n    complete: function() {\n      Pcs.update();\n    }\n  });\n}\n\nfunction resource_clone(resource_id) {\n  if (resource_id == null) {\n    return;\n  }\n  show_loading_screen();\n  ajax_wrapper({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'resource_clone',\n    data: {resource_id: resource_id},\n    timeout: pcs_timeout,\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to clone the resource \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    },\n    complete: function() {\n      Pcs.update();\n    }\n  });\n}\n\nfunction resource_unclone(resource_id) {\n  if (resource_id == null) {\n    return;\n  }\n  show_loading_screen();\n  var resource_obj = Pcs.resourcesContainer.get_resource_by_id(resource_id);\n  if (resource_obj.get('class_type') == 'clone') {\n    resource_id = resource_obj.get('member').get('id');\n  }\n  ajax_wrapper({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'resource_unclone',\n    data: {resource_id: resource_id},\n    timeout: pcs_timeout,\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to unclone the resource \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    },\n    complete: function() {\n      Pcs.update();\n    }\n  });\n}\n\nfunction resource_ungroup(group_id) {\n  if (group_id == null) {\n    return;\n  }\n  show_loading_screen();\n  ajax_wrapper({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'resource_ungroup',\n    data: {group_id: group_id},\n    timeout: pcs_timeout,\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to ungroup the resource \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    },\n    complete: function() {\n      Pcs.update();\n    }\n  });\n}\n\nfunction resource_change_group(resource_id, group_id) {\n  if (resource_id == null) {\n    return;\n  }\n  show_loading_screen();\n  var resource_obj = Pcs.resourcesContainer.get_resource_by_id(resource_id);\n  var data = {\n    resource_id: resource_id,\n    group_id: group_id\n  };\n  \n  if (resource_obj.get('parent')) {\n    if (resource_obj.get('parent').get('id') == group_id) {\n      return;  \n    }\n    if (resource_obj.get('parent').get('class_type') == 'group') {\n      data['old_group_id'] = resource_obj.get('parent').get('id');\n    }\n  }\n\n  ajax_wrapper({\n    type: 'POST',\n    url: get_cluster_remote_url() + 'resource_change_group',\n    data: data,\n    timeout: pcs_timeout,\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to change group \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    },\n    complete: function() {\n      Pcs.update();\n    }\n  });\n}\n\nfunction ajax_simple_error(xhr, status, error) {\n  var message = \"(\" + $.trim(error) + \")\"\n  if (\n    $.trim(xhr.responseText).length > 0\n    &&\n    xhr.responseText.indexOf('cib_replace failed') == -1\n  ) {\n    message = message + \"\\n\\n\" + $.trim(xhr.responseText);\n  }\n  return message;\n}\n\nfunction ajax_wrapper(options) {\n  // get original callback functions\n  var error_original = function(xhr, status, error) {};\n  if (options.error) {\n    error_original = options.error;\n  }\n  var complete_original = function(xhr, status) {};\n  if (options.complete) {\n    complete_original = options.complete;\n  }\n\n  // prepare new callback functions\n  var options_new = $.extend(true, {}, options);\n  // display login dialog on error\n  options_new.error = function(xhr, status, error) {\n    if (xhr.status == 401) {\n      ajax_queue.push(options);\n      if (!login_dialog_opened) {\n        login_dialog(function() {\n          var item;\n          while (ajax_queue.length > 0) {\n            item = ajax_queue.shift();\n            ajax_wrapper(item);\n          }\n        });\n      }\n    }\n    else {\n      error_original(xhr, status, error);\n    }\n  }\n  // Do not run complete function if login dialog is open.\n  // Once user is logged in again, the original complete function will be run\n  // in repeated ajax call run by login dialog on success.\n  options_new.complete = function(xhr, status) {\n    if (xhr.status == 401) {\n      return;\n    }\n    else {\n      complete_original(xhr, status);\n    }\n  }\n\n  // run ajax request or put it into a queue\n  if (login_dialog_opened) {\n    ajax_queue.push(options);\n  }\n  else {\n    $.ajax(options_new);\n  }\n}\n\nfunction login_dialog(on_success) {\n  var ok_button_id = \"login_form_ok\";\n  var ok_button_selector = \"#\" + ok_button_id;\n  var buttons = [\n    {\n      text: \"Log In\",\n      id: ok_button_id,\n      click: function() {\n        var me = $(this);\n        var my_dialog = $(this).dialog()\n        my_dialog.find(\"#login_form_denied\").hide();\n        $(ok_button_selector).button(\"option\", \"disabled\", true);\n        $.ajax({\n          type: \"POST\",\n          url: \"/login\",\n          data: my_dialog.find(\"#login_form\").serialize(),\n          complete: function() {\n            $(ok_button_selector).button(\"option\", \"disabled\", false);\n          },\n          success: function() {\n            my_dialog.find(\"#login_form_username\").val(\"\");\n            my_dialog.find(\"#login_form_password\").val(\"\");\n            me.dialog(\"destroy\");\n            login_dialog_opened = false;\n            on_success();\n          },\n          error: function(xhr, status, error) {\n            if (xhr.status == 401) {\n              my_dialog.find(\"#login_form_denied\").show();\n              my_dialog.find(\"#login_form_password\").val(\"\");\n            }\n            else {\n              alert(\"Login error \" + ajax_simple_error(xhr, status, error));\n            }\n          },\n        });\n      },\n    },\n    {\n      text: \"Cancel\",\n      id: \"login_form_cancel\",\n      // cancel will close the dialog the same way as X button does\n      click: function() {\n        $(this).dialog(\"close\");\n      },\n    },\n  ];\n  var dialog_obj = $(\"#dialog_login\").dialog({\n    title: \"Log In\",\n    modal: true,\n    resizable: true,\n    width: 400,\n    buttons: buttons,\n    open: function(event, ui) {\n      login_dialog_opened = true;\n    },\n    create: function(event, ui) {\n      login_dialog_opened = true;\n    },\n    // make sure to logout the user on dialog close\n    close: function(event, ui) {\n      login_dialog_opened = false;\n      location = \"/logout\";\n    },\n  });\n  dialog_obj.find(\"#login_form_denied\").hide();\n  // submit on enter\n  dialog_obj.keypress(function(e) {\n    if (\n      e.keyCode == $.ui.keyCode.ENTER\n      &&\n      !dialog_obj.parent().find(ok_button_selector).button(\"option\", \"disabled\")\n    ) {\n      dialog_obj.parent().find(ok_button_selector).trigger(\"click\");\n      return false;\n    }\n  });\n}\n\nvar permissions_current_cluster;\n\nfunction permissions_load_all() {\n  show_loading_screen();\n\n  var cluster_list = [];\n  $(\"#node_info div[id^='permissions_cluster_']\").each(function(i, div) {\n    cluster_list.push(\n      $(div).attr(\"id\").substring(\"permissions_cluster_\".length)\n    );\n  });\n\n  var call_count = cluster_list.length;\n  var callback = function() {\n    call_count = call_count - 1;\n    if (call_count < 1) {\n      hide_loading_screen();\n    }\n  }\n\n  $.each(cluster_list, function(index, cluster) {\n    permissions_load_cluster(cluster, callback);\n  });\n\n  if (cluster_list.length > 0) {\n    permissions_current_cluster = cluster_list[0];\n    permissions_show_cluster(\n      permissions_current_cluster,\n      $(\"#cluster_list tr\").first().next() /* the first row is a heading */\n    );\n  }\n  else {\n    hide_loading_screen();\n  }\n}\n\nfunction permissions_load_cluster(cluster_name, callback) {\n  var element_id = \"permissions_cluster_\" + cluster_name;\n  ajax_wrapper({\n    type: \"GET\",\n    url: \"/permissions_cluster_form/\" + cluster_name,\n    timeout: pcs_timeout,\n    success: function(data) {\n      $(\"#\" + element_id).html(data);\n      $(\"#\" + element_id + \" :checkbox\").each(function(key, checkbox) {\n        permissions_fix_dependent_checkboxes(checkbox);\n      });\n      permissions_cluster_dirty_flag(cluster_name, false);\n      if (callback) {\n        callback();\n      }\n    },\n    error: function(xhr, status, error) {\n      $(\"#\" + element_id).html(\n        \"Error loading permissions \" + ajax_simple_error(xhr, status, error)\n      );\n      if (callback) {\n        callback();\n      }\n    }\n  });\n}\n\nfunction permissions_show_cluster(cluster_name, list_row) {\n  permissions_current_cluster = cluster_name;\n\n  var container = $(\"#node_info\");\n  container.fadeTo(500, .01, function() {\n    container.children().hide();\n    $(\"#permissions_cluster_\" + cluster_name).show();\n    container.fadeTo(500, 1);\n  });\n\n  $(list_row).siblings(\"tr\").each(function(index, row) {\n    hover_out(row);\n    $(row).find(\"td\").last().children().hide();\n  });\n  hover_over(list_row);\n  $(list_row).find(\"td\").last().children().show();\n}\n\nfunction permissions_save_cluster(form) {\n  var dataString = $(form).serialize();\n  var cluster_name = permissions_get_clustername(form);\n  ajax_wrapper({\n    type: \"POST\",\n    url: get_cluster_remote_url(cluster_name) + \"permissions_save\",\n    timeout: pcs_timeout,\n    data: dataString,\n    success: function() {\n      show_loading_screen();\n      permissions_load_cluster(cluster_name, hide_loading_screen);\n    },\n    error: function(xhr, status, error) {\n      alert(\n        \"Unable to save permissions of cluster \" + cluster_name + \" \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    }\n  });\n}\n\nfunction permissions_cluster_dirty_flag(cluster_name, flag) {\n  var cluster_row = permissions_get_cluster_row(cluster_name);\n  if (cluster_row) {\n    var dirty_elem = cluster_row.find(\"span[class=unsaved_changes]\");\n    if (dirty_elem) {\n      if (flag) {\n        dirty_elem.show();\n      }\n      else {\n        dirty_elem.hide();\n      }\n    }\n  }\n}\n\nfunction permission_remove_row(button) {\n  var cluster_name = permissions_get_clustername(\n    $(button).parents(\"form\").first()\n  );\n  $(button).parent().parent().remove();\n  permissions_cluster_dirty_flag(cluster_name, true);\n}\n\nfunction permissions_add_row(template_row) {\n  var user_name = permissions_get_row_name(template_row);\n  var user_type = permissions_get_row_type(template_row);\n  var max_key = -1;\n  var exists = false;\n  var cluster_name = permissions_get_clustername(\n    $(template_row).parents(\"form\").first()\n  );\n\n  if(\"\" == user_name) {\n    alert(\"Please enter the name\");\n    return;\n  }\n  if(\"\" == user_type) {\n    alert(\"Please enter the type\");\n    return;\n  }\n\n  $(template_row).siblings().each(function(index, row) {\n    if(\n      (permissions_get_row_name(row) == user_name)\n      &&\n      (permissions_get_row_type(row) == user_type)\n    ) {\n      exists = true;\n    }\n    $(row).find(\"input\").each(function(index, input) {\n      var match = input.name.match(/^[^[]*\\[(\\d+)\\].*$/);\n      if (match) {\n        var key = parseInt(match[1]);\n        if(key > max_key) {\n          max_key = key;\n        }\n      }\n    });\n  });\n  if(exists) {\n    alert(\"Permissions already set for the user\");\n    return;\n  }\n\n  max_key = max_key + 1;\n  var new_row = $(template_row).clone();\n  new_row.find(\"[name*='_new']\").each(function(index, element) {\n    element.name = element.name.replace(\"_new\", \"[\" + max_key + \"]\");\n  });\n  new_row.find(\"td\").last().html(\n    '<a class=\"remove\" href=\"#\" onclick=\"permission_remove_row(this);\">X</a>'\n  );\n  new_row.find(\"[name$='[name]']\").each(function(index, element) {\n    $(element).after(user_name);\n    $(element).attr(\"type\", \"hidden\");\n  });\n  new_row.find(\"[name$='[type]']\").each(function(index, element) {\n    $(element).after(user_type);\n    $(element).after(\n      '<input type=\"hidden\" name=\"' + element.name  + '\" value=\"' + user_type + '\">'\n    );\n    $(element).remove();\n  });\n\n  $(template_row).before(new_row);\n  var template_inputs = $(template_row).find(\":input\");\n  template_inputs.removeAttr(\"checked\").removeAttr(\"selected\");\n  template_inputs.removeAttr(\"disabled\").removeAttr(\"readonly\");\n  $(template_row).find(\":input[type=text]\").val(\"\");\n\n  permissions_cluster_dirty_flag(cluster_name, true);\n}\n\nfunction permissions_get_dependent_checkboxes(checkbox) {\n  var cluster_name = permissions_get_clustername(\n    $(checkbox).parents(\"form\").first()\n  );\n  var checkbox_permission = permissions_get_checkbox_permission(checkbox);\n  var deps = {};\n  var dependent_permissions = [];\n  var dependent_checkboxes = [];\n\n  if (permissions_dependencies[cluster_name]) {\n    deps = permissions_dependencies[cluster_name];\n    if (deps[\"also_allows\"] && deps[\"also_allows\"][checkbox_permission]) {\n      dependent_permissions = deps[\"also_allows\"][checkbox_permission];\n      $(checkbox).parents(\"tr\").first().find(\":checkbox\").not(checkbox).each(\n        function(key, check) {\n          var perm = permissions_get_checkbox_permission(check);\n          if (dependent_permissions.indexOf(perm) != -1) {\n            dependent_checkboxes.push(check);\n          }\n        }\n      );\n    }\n  }\n  return dependent_checkboxes;\n}\n\nfunction permissions_fix_dependent_checkboxes(checkbox) {\n  var dep_checks = $(permissions_get_dependent_checkboxes(checkbox));\n  if ($(checkbox).prop(\"checked\")) {\n    /* the checkbox is now checked */\n    dep_checks.each(function(key, check) {\n      var jq_check = $(check);\n      jq_check.prop(\"checked\", true);\n      jq_check.prop(\"readonly\", true);\n      // readonly on checkbox makes it look like readonly but doesn't prevent\n      // changing its state (checked - not checked), setting disabled works\n      jq_check.prop(\"disabled\", true);\n      permissions_fix_dependent_checkboxes(check);\n    });\n  }\n  else {\n    /* the checkbox is now empty */\n    dep_checks.each(function(key, check) {\n      var jq_check = $(check);\n      jq_check.prop(\"checked\", jq_check.prop(\"defaultChecked\"));\n      jq_check.prop(\"readonly\", false);\n      jq_check.prop(\"disabled\", false);\n      permissions_fix_dependent_checkboxes(check);\n    });\n  }\n}\n\nfunction permissions_get_row_name(row) {\n  return $.trim($(row).find(\"[name$='[name]']\").val());\n}\n\nfunction permissions_get_row_type(row) {\n  return $.trim($(row).find(\"[name$='[type]']\").val());\n}\n\nfunction permissions_get_clustername(form) {\n  return $.trim($(form).find(\"[name=cluster_name]\").val());\n}\n\nfunction permissions_get_checkbox_permission(checkbox) {\n  var match = checkbox.name.match(/^.*\\[([^[]+)\\]$/);\n  if (match) {\n    return match[1];\n  }\n  return \"\";\n}\n\nfunction permissions_get_cluster_row(cluster_name) {\n  var cluster_row = null;\n  $('#cluster_list td[class=node_name]').each(function(index, elem) {\n    var jq_elem = $(elem);\n    if (jq_elem.text().trim() == cluster_name.trim()) {\n      cluster_row = jq_elem.parents(\"tr\").first();\n    }\n  });\n  return cluster_row;\n}\n\nfunction is_cib_true(value) {\n  if (value) {\n    return (['true', 'on', 'yes', 'y', '1'].indexOf(value.toString().toLowerCase()) != -1);\n  }\n  return false;\n}\n\nfunction set_utilization(type, entity_id, name, value) {\n  var data = {\n    name: name,\n    value: value\n  };\n  if (type == \"node\") {\n    data[\"node\"] = entity_id;\n  } else if (type == \"resource\") {\n    data[\"resource_id\"] = entity_id;\n  } else return false;\n  var url = get_cluster_remote_url() + \"set_\" + type + \"_utilization\";\n\n  ajax_wrapper({\n    type: 'POST',\n    url: url,\n    data: data,\n    timeout: pcs_timeout,\n    error: function (xhr, status, error) {\n      alert(\n        \"Unable to set utilization: \"\n        + ajax_simple_error(xhr, status, error)\n      );\n    },\n    complete: function() {\n      Pcs.update();\n    }\n  });\n}\n\nfunction is_integer(str) {\n  if (Number(str) === str && str % 1 === 0) // if argument isn't string but number\n    return true;\n  var n = ~~Number(str);\n  return String(n) === str;\n}\n\nEmber.Handlebars.helper('selector-helper', function (content, value, place_holder, options) {\n  var out = \"\";\n  var line;\n  if (place_holder) {\n    out += '<option value=\"\">' + place_holder + '</option>'; \n  }\n  $.each(content, function(_, opt){\n    line = '<option value=\"' + opt[\"value\"] + '\"';\n    if (value == opt[\"value\"]) {\n      line += ' selected=\"selected\"'\n    }\n    line += \">\" + Handlebars.Utils.escapeExpression(opt[\"name\"]) + \"</option>\";\n    out += line + \"\\n\";\n  });\n  return new Handlebars.SafeString(out);\n});\n", "<div id=\"dialog_login\" style=\"display:none;\">\n  <form id=\"login_form\">\n    <div>Your session has expired. Log in again, please.</div>\n    <div id=\"login_form_denied\" style=\"color:red; display:none;\">\n      Bad username or password\n    </div>\n    <table>\n      <tr>\n        <td><label for=\"login_form_username\">Username:</label></td>\n        <td><input type=\"text\" id=\"login_form_username\" name=\"username\"></td>\n      </tr>\n      <tr>\n        <td><label for=\"login_form_password\">Password:</label></td>\n        <td><input type=\"password\" id=\"login_form_password\" name=\"password\"></td>\n      </tr>\n    </table>\n  </form>\n</div>\n\n<div id=\"auth_nodes\" style=\"display:none;\">\n  <form id=\"auth_nodes_form\">\n    Enter password for user 'hacluster' to authenticate nodes.<br>\n    Nodes to authenticate:\n    <table class=\"err_msg_table\" style=\"width: 100%\">\n      <tr><td align=center style=\"color: red\" colspan=2\"><span id=\"auth_failed_error_msg\" style=\"display:none;\">Authentication on some nodes failed.</span></td></tr>\n    </table>\n    <table id=\"auth_nodes_list\">\n    </table>\n    <div id=\"same_pass\"><label><input type=\"checkbox\" name=\"all\" onchange=\"if ($(this).is(':checked')) {$('#auth_nodes_list').find('input:password').each(function(){$(this).hide()}); $('#pass_for_all').show();} else {$('#auth_nodes_list').find('input:password').each(function(){$(this).show()}); $('#pass_for_all').hide();}\"> Use same password for all nodes:</label>\n      <input type=\"password\" name=\"pass-all\" id=\"pass_for_all\" style=\"display: none;\"></div>\n  </form>\n</div>\n\n<div id=\"dialog_verify_remove_clusters\" style=\"display: none;\">\n  <p style=\"font-size:12px;\">Are you sure you want to remove the following cluster(s) from the GUI? (This only removes the cluster from the GUI, it does not stop the cluster from running.)</p>\n  <span class=\"name_list\"></span>\n</div>\n\n<div id=\"dialog_verify_remove_nodes\" style=\"display:none;\">\n  <p style=\"font-size:12px;\">Are you sure you want to remove the following node(s)?</p>\n  <span class=\"name_list\"></span>\n  {{#if Pcs.is_cman_with_udpu_transport}}\n    <p style=\"color: orange\">This is a CMAN cluster with UDPU transport, cluster restart is required to apply node removal.</p>\n  {{/if}}\n</div>\n\n<div id=\"dialog_verify_remove_resources\" style=\"display: none;\">\n  <p style=\"font-size:12px;\">Are you sure you want to remove the following resource(s)?</p>\n  <span class=\"name_list\"></span>\n  <input type=\"checkbox\" name=\"force\">\n  Enforce removal (Remove the resources without stopping them first.)\n</div>\n\n<div id=\"dialog_verify_remove_acl_roles\" style=\"display:none;\">\n  <p style=\"font-size:12px;\">Are you sure you want to remove the following ACL role(s)?</p>\n  <span class=\"name_list\"></span>\n</div>\n", "<table id=\"main\">\n  <tr id=\"cluster_title_row\" {{bind-attr style=Pcs.permissions_page}}>\n    <td id=\"page_header\" colspan=\"2\" style=\"vertical-align:middle;\">\n      <table id=\"permissions_commands\">\n        <tr>\n          <td>PERMISSIONS</td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n  <tr id=\"cluster_header_row\" {{bind-attr style=Pcs.permissions_page}}>\n    <td class=\"borderbottom\" colspan=\"2\"> </td>\n  </tr>\n  <tr id=\"cluster_list_row\" {{bind-attr style=Pcs.permissions_page}}>\n    <td id=\"cluster_list\" class=\"node_list\" style=\"width:auto;\">\n      <table cellpadding=\"0\" cellspacing=\"0\" style=\"width:100%;\">\n        <tr>\n          <th> </th>\n          <th> </th>\n          <th>CLUSTER&nbsp;NAME</th>\n          <th style=\"padding-right: 16px;\"> </th>\n        </tr>\n        <% @clusters.each do |c| %>\n          <tr\n            onmouseover=\"if(permissions_current_cluster != '<%= h(c.name) %>') hover_over(this);\"\n            onmouseout=\"if(permissions_current_cluster != '<%= h(c.name) %>') hover_out(this);\"\n            onclick=\"permissions_show_cluster('<%= h(c.name) %>', this);\"\n          >\n            <td class=\"node_list_sprite\">\n              <div class=\"check sprites\"></div>\n            </td>\n            <td style=\"min-width:1em; padding-right:0.5em;\">\n              <span class=\"unsaved_changes\" style=\"display:none;\"\n                title=\"There are unsaved changes in the form\"\n              >(*)</span>\n            </td>\n            <td nowrap class=\"node_name\">\n              <%= h(c.name) %>\n            </td>\n            <td>\n              <div class=\"arrow sprites\" style=\"display:none;\"></div>\n            </td>\n          </tr>\n        <% end %>\n      </table>\n    </td>\n    <td id=\"node_info\">\n      <% @clusters.each { |c| %>\n        <div id=\"permissions_cluster_<%= h(c.name) %>\" style=\"display:none;\">\n        </div>\n      <% } %>\n    </td>\n  </tr>\n</table>\n<%= erb :_dialogs %>\n"], "filenames": ["pcsd/pcsd.rb", "pcsd/public/js/nodes-ember.js", "pcsd/public/js/pcsd.js", "pcsd/views/_dialogs.erb", "pcsd/views/permissions.erb"], "buggy_code_start_loc": [147, 72, 1, 0, 54], "buggy_code_end_loc": [391, 553, 2566, 0, 54], "fixing_code_start_loc": [148, 72, 2, 1, 55], "fixing_code_end_loc": [401, 553, 2699, 20, 56], "type": "CWE-384", "message": "Session fixation vulnerability in pcsd in pcs before 0.9.157.", "other": {"cve": {"id": "CVE-2016-0721", "sourceIdentifier": "secalert@redhat.com", "published": "2017-04-21T15:59:00.223", "lastModified": "2023-02-12T23:15:51.407", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Session fixation vulnerability in pcsd in pcs before 0.9.157."}, {"lang": "es", "value": "Vulnerabilidad de fijaci\u00f3n de sesi\u00f3n en pcsd en pcs en versiones anteriores a 0.9.157."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-384"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:clusterlabs:pcs:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.9.156", "matchCriteriaId": "ECE5DF87-C8A6-4CEE-BAB7-12E0C347887C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:22:*:*:*:*:*:*:*", "matchCriteriaId": "253C303A-E577-4488-93E6-68A8DD942C38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:23:*:*:*:*:*:*:*", "matchCriteriaId": "E79AB8DD-C907-4038-A931-1A5A4CFB6A5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2016-March/178261.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2016-March/178384.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2596.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/97977", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1299615", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ClusterLabs/pcs/commit/acdbbe8307e6f4a36b2c7754765e732e43fe8d17", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://github.com/ClusterLabs/pcs/commit/bc6ad9086857559db57f4e3e6de66762291c0774", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://github.com/ClusterLabs/pcs/commit/e9b28833d54a47ec441f6dbad0db96e1fc662a5b", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/ClusterLabs/pcs/commit/acdbbe8307e6f4a36b2c7754765e732e43fe8d17"}}