{"buggy_code": ["2017-07-29  7.0.6-5 Glenn Randers-Pehrson <glennrp@image...>\n  * Properly set image->colorspace in the PNG decoder (previously\n    it was setting image->gamma, but only setting image->colorspace\n    for grayscale and gray-alpha images.  Reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=32418).\n  * Fix improper use of NULL in the JNG decoder (Reference\n    https://github.com/ImageMagick/ImageMagick/issues/632).\n\n2017-07-29  7.0.6-5 Cristy  <quetzlzacatenango@image...>\n  * Off by one error for gradient coder (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=32416),\n    https://github.com/ImageMagick/ImageMagick/issues/612).\n\n2017-07-28  7.0.6-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-4, GIT revision 20657:4e81160d6:20170728.\n\n2017-07-24  7.0.6-4 Cristy  <quetzlzacatenango@image...>\n  * YUV coder no longer renders streaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues/612).\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * coders/png.c: Initialized quantum_scanline and quantum_info\n    to prevent a bad free (reference\n    https://github.com/ImageMagick/ImageMagick/issues/621).\n\n2017-07-25  7.0.6-4 Glenn Randers-Pehrson <glennrp@image...>\n  * Removed write_chunk_from_profile() from coders/png.c because it has\n    not worked at least since version 6.7.6.\n  * Removed many redundant checks before RelinquishMagickMemory(), which\n    is safe to call with a NULL argument.\n  * Added experimental PNG orNT chunk, to store image->orientation.\n  * Removed vpAg chunk write support (we are now writing caNv instead).\n\n2017-07-24  7.0.6-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-3, GIT revision 20598:cc9c43b44:20170724.\n\n2017-07-23  7.0.6-3 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-07-23  7.0.6-3 Glenn Randers-Pehrson <glennrp@image...>\n  * Fix memory leaks when reading a malformed JNG image:\n    https://github.com/ImageMagick/ImageMagick/issues/600,\n    https://github.com/ImageMagick/ImageMagick/issues/602).\n\n2017-07-21  7.0.6-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-2, GIT revision 20549:62fcf3d96:20170721.\n\n2017-07-19  7.0.6-2 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * The -monochrome option no longer returns a blank canvas (reference\n    https://github.com/ImageMagick/ImageMagick/issues/594).\n  * coders/png.c: fixed memory leak of quantum_info (CVE-2017-11539, reference\n    https://github.com/ImageMagick/ImageMagick/issues/582\n\n2017-07-15  7.0.6-2 Glenn Randers-Pehrson <glennrp@image...>\n  * Added caNv, eXIf, and pHYs to the list of PNG chunks to be removed\n    by the \"-strip\" option.\n\n2017-07-15  7.0.6-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-1, GIT revision 20447:c2a315e10:20170715.\n\n2017-07-13  7.0.6-1 Glenn Randers-Pehrson <glennrp@image...>\n  * Implemented PNG eXIf chunk support.\n\n2017-07-08  7.0.6-1 Cristy  <quetzlzacatenango@image...>\n  * Support new -auto-threshold option.  OTSU and Triangle methods are\n    currently supported.  Look for the Kapur method in the next release.\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Don't use variable float_t / double_t, bump SO (reference\n    https://github.com/ImageMagick/ImageMagick/issues/510).\n  * Support DNG images with libraw delegate library.\n\n2017-07-02  7.0.6-1 Glenn Randers-Pehrson <glennrp@image...>\n  * Reject PNG file that is too small (under 60 bytes) to contain\n    a valid image.\n  * Reject JPEG file that is too small (under 107 bytes) to contain\n    a valid image.\n  * Reject JNG file that is too small (under 147 bytes) to contain\n    a valid image.\n\n2017-06-22  7.0.6-1 Glenn Randers-Pehrson <glennrp@image...>\n  * Stop a memory leak in read_user_chunk_callback() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/517,\n    CVE 2017-11310).\n\n2017-06-10  7.0.6-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-0, GIT revision 20194:b0c0d00:20170611.\n\n2017-06-10  7.0.6-0 Glenn Randers-Pehrson <glennrp@image...>\n  * coders/png.c: Accept exIf chunks whose data segment\n    erroneously begins with \"Exif\\0\\0\".\n\n2017-06-10  7.0.6-0 Cristy  <quetzlzacatenango@image...>\n  * Introduce SetMagickSecurityPolicy() (MagickCore) and\n    MagickSetSecurityPolicy() (MagickWand) to set the ImageMagick security\n    policy (reference https://github.com/ImageMagick/ImageMagick/issues/407).\n\n2017-06-02  7.0.5-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-10, GIT revision 20155:38ebc02:20170602.\n\n2017-06-01  7.0.5-10 Glenn Randers-Pehrson <glennrp@image...>\n  * Removed experimental PNG zxIF chunk support; the proposal is dead.\n\n2017-06-01  7.0.5-10 Cristy  <quetzlzacatenango@image...>\n  * Fix choppy bitmap font rendering (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=32071).\n  * The +opaque option is not longer a noop (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=32081).\n  * Add support  for 'hex:' property.\n\n2017-05-28  7.0.5-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-9, GIT revision 20113:8b67333:20170528.\n\n2017-05-28  7.0.5-9 Cristy  <quetzlzacatenango@image...>\n  * Transient error validating the JPEG-2000 image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/501).\n  * Properly allocate DCM image colormap (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=32063).\n\n2017-05-26  7.0.5-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-8, GIT revision 20099:870a016:20170526.\n\n2017-05-23  7.0.5-8 Cristy  <quetzlzacatenango@image...>\n  * Improper allocation of memory for IM instances without threads (reference\n    https://github.com/ImageMagick/ImageMagick/issues/497).\n  * Delete corrupt image from list (reference\n    https://github.com/ImageMagick/ImageMagick/issues/500).\n\n2017-05-19  7.0.5-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-6, GIT revision 20078:7ce2d38:20170519.\n\n2017-05-15  7.0.5-7 Cristy  <quetzlzacatenango@image...>\n  * Support various image operators for the compare utility (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=2&t=31938).\n\n 2017-05-12  7.0.5-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-6, GIT revision 20039:9371904:20170512.\n\n2017-05-10  7.0.5-6 John Cupitt <jcupitt@gmail.com>\n  * Revise DICOM window and rescale handling (reference \n    https://github.com/ImageMagick/ImageMagick/pull/484)\n\n2017-05-06  7.0.5-6 Cristy  <quetzlzacatenango@image...>\n  * Restore the -alpha Shape option (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31879).\n  * Fix transient PDF bug (reference\n    https://github.com/ImageMagick/ImageMagick/issues/463).\n  * The +opaque option now works on all channels (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31862).\n  * Ensure backwards compatibility for the -combine option (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31855).\n  * Check for EOF conditions for RLE image format.\n  * Reset histogram page geometry (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31920).\n\n2017-04-24  7.0.5-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-5, GIT revision 19915:12eec43:20170424.\n\n2017-03-26  7.0.5-5 Cristy  <quetzlzacatenango@image...>\n  * Minimize buffer copies to improve OpenCL performance.\n  * Morphology thinning is no longer a no-op (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31650).\n  * Patch two PCD writer problems, corrupt output and dark pixels (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=3164).\n  * Support ICC based PDF's (reference\n    https://github.com/ImageMagick/ImageMagick/issues/417).\n  * Fix improper EPS clip path rendering (reference\n    http://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31722).\n\n2017-03-24  7.0.5-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-4, GIT revision 19754:350fff3:20170324.\n\n2017-03-21  7.0.5-4 Cristy  <quetzlzacatenango@image...>\n  * Respect -loop option for animate -window (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31619).\n\n2017-03-17  7.0.5-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-3, GIT revision 19741:070c3fb:20170317.\n\n2017-03-14  7.0.5-3 Cristy  <quetzlzacatenango@image...>\n  * Support namespaces for the security policy.\n  * Support the -authenticate option for PDF (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31530).\n\n2017-03-11  7.0.5-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-2, GIT revision 19696:da91a7c:20170311.\n\n2017-03-06  7.0.5-2 Cristy  <quetzlzacatenango@image...>\n  * Respect throttle policy (reference\n    https://github.com/ImageMagick/ImageMagick/issues/393).\n  * Return proper minima / maxima (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31377).\n\n2017-03-03  7.0.5-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-1, GIT revision 19662:b7f455a:20170303.\n\n2017-02-21  7.0.5-1 Cristy  <quetzlzacatenango@image...>\n  * Fix Spurious memory allocation message (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31438).\n  * Identical images should return inf for PSNR (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31487).\n\n2017-02-20  7.0.5-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-0, GIT revision 19616:505fea9:20170220.\n\n2017-02-20  7.0.5-0 Cristy  <quetzlzacatenango@image...>\n  * Fix transient bug with -separate option (reference\n    https://github.com/ImageMagick/ImageMagick/issues/385).\n\n2017-02-18  7.0.4-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-10, GIT revision 19608:fe757a2:20170218.\n\n2017-02-18  7.0.4-10 Dirk Lemstra <dirk@lem.....org>\n  * Fixed fd leak for webp coder (reference\n    https://github.com/ImageMagick/ImageMagick/pull/382)\n\n2017-02-15  7.0.4-10 Cristy  <quetzlzacatenango@image...>\n  * Prevent random pixel data for corrupt JPEG image (bug report from\n    Hirokazu Moriguchi, Sony).\n  * Restore -mattecolor option.\n  * Support pixel-cache and shred security policies.\n  * Bump Magick++ SO.  Previously a global replace changed matteColor to\n    alphaColor.\n\n2017-02-14  7.0.4-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-9, GIT revision 19580:d474b37:20170214.\n\n2017-02-14  7.0.4-9 Cristy  <quetzlzacatenango@image...>\n  * Revert patch that did not set update trait on alpha channel.\n\n2017-02-13  7.0.4-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-8, GIT revision 19574:7642384:20170213.\n\n2017-02-09  7.0.4-8 Dirk Lemstra <dirk@lem.....org>\n  * Fixed memory leak when creating nested exceptions in Magick++ (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=23&p=142634)\n\n2017-02-09  7.0.4-8 Cristy  <quetzlzacatenango@image...>\n  * Unbreak build without JPEG support (reference\n    https://github.com/ImageMagick/ImageMagick/pull/373).\n  * Document behavior change in the security policy (thanks to yoya @\n    https://blog.awm.jp/2017/02/09/imagemagick-en/).\n  * Return unbiased standard deviation for image statistics (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31377).\n  * Don't set update trait on alpha channel (private e-mail concerning\n    -levels-colors option).\n\n2017-02-04  7.0.4-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-7, GIT revision 19513:5783e57:20170204.\n\n2017-01-28  7.0.4-7 Cristy  <quetzlzacatenango@image...>\n  * Sanitize comments that include braces for the MIFF image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/368).\n\n2017-01-27  7.0.4-7 Glenn Randers-Pehrson <glennrp@image...>\n  * coders/png.c: Added support for a proposed new PNG chunk\n    (zxIf, read-only) that is currently being discussed on the\n    png-mng-misc at lists.sourceforge.net mailing list.  Enable\n    exIf and zxIf with CPPFLAGS=\"-DexIf_SUPPORTED -DxzIf_SUPPORTED\".\n    If exIf is enabled, only the uncompressed exIF chunk will be\n    written and the hex-encoded zTXt chunk containing the raw Exif\n    profile won't be written.\n\n2017-01-27  7.0.4-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-6, GIT revision 19442:4747de9:20170127.\n\n2017-01-27  7.0.4-6 Cristy  <quetzlzacatenango@image...>\n  * Uninitialized data in MAT image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/362).\n  * Properly auto-fit caption (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30887).\n  * Correction to composite Over operator (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31282).\n  * Respect gravity option (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31284).\n\n2017-01-22  7.0.4-6 Glenn Randers-Pehrson <glennrp@image...>\n  * Renamed read_vpag_chunk_callback() function to png_user_chunk_callback()\n    in coders/png.c\n  * Implemented a private PNG caNv (canvas) chunk for remembering the\n    original dimensions and offsets when an image is cropped.  Previously\n    we used the oFFs and vpAg chunks for this purpose, but this had potential\n    conflicts with other applications that also use the oFFs chunk.\n  * coders/png.c: Added support for a proposed new PNG chunk (exIf\n    read-write, eXIf read-only) that is currently being discussed on the\n    png-mng-misc at lists.sourceforge.net mailing list.\n\n2017-01-22  7.0.4-6 Dirk Lemstra <dirk@lem.....org>\n  * Replaced CoderSeekableStreamFlag with CoderDecoderSeekableStreamFlag and\n    CoderEncoderSeekableStreamFlag.\n\n2017-01-21  7.0.4-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-5, GIT revision 19381:7ae396f:20170121.\n\n2017-01-18  7.0.4-5 Cristy  <quetzlzacatenango@image...>\n  * Don't set background for transparent tiled images (reference\n    http://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31210).\n\n2017-01-14  7.0.4-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-4, GIT revision 19361:a12953c:20170114.\n\n2017-01-14  7.0.4-4 Dirk Lemstra <dirk@lem.....org>\n  * Added support for RGB555, RGB565, ARGB4444 and ARGB1555 to the\n    BMP encoder (reference\n    https://github.com/ImageMagick/ImageMagick/issues/344).\n\n2017-01-10  7.0.4-4 Cristy  <quetzlzacatenango@image...>\n  * Recognize XML policy closing tags (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31182).\n  * Fix memory leak in the MPC format.\n\n2017-01-07  7.0.4-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-3, GIT revision 19329:930ca78:20170107.\n\n2017-01-04  7.0.4-3 Cristy  <quetzlzacatenango@image...>\n  * Increase memory allocation for TIFF pixels (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31161).\n\n2017-01-03  7.0.4-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-2, GIT revision 19318:8766311:20170103.\n\n2017-01-02  7.0.4-2 Cristy  <quetzlzacatenango@image...>\n  * Validation unit test for MNG works again.\n\n2016-12-31  7.0.4-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-1, GIT revision 19292:c5ccfa8:20161231.\n\n2016-12-26  7.0.4-1 Cristy  <quetzlzacatenango@image...>\n  * Initialize draw_info alpha member to OpaqueAlpha.\n  * Monochrome images no longer have inverted colors (reference\n    https://github.com/ImageMagick/ImageMagick/issues/332).\n\n2016-12-18  7.0.4-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-0, GIT revision 19221:d5e8abc:20161218.\n\n2016-12-14  7.0.4-0 Cristy  <quetzlzacatenango@image...>\n * Do not close path for linejoins of round (reference\n   https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31039).\n\n2016-12-10  7.0.3-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-10, GIT revision 19191:338f088:20161210.\n\n2016-12-07  7.0.3-10 Cristy  <quetzlzacatenango@image...>\n  * Set colorspace to sRGB if -append has non-homogenous colorspaces (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29105).\n  * Respect connected-components:area-threshold define (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31006). \n  * Enable alpha channel if background color is non-opaque (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31016).\n  * Return correct offset for negative index for -fx option (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31019).\n  * Fixed improper scaling of certain FITS images (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31028).\n  * Properly center text label (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31027).\n\n2016-12-05  7.0.3-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-9, GIT revision 19139:6fed3f1:20161205.\n\n2016-11-26  7.0.3-9 Cristy  <quetzlzacatenango@image...>\n  * Support the compare -read-mask option.\n  * Support read-masks for the -modulate option.\n  * Prevent buffer overflow when streaming an image (reference\n    https://github.com/ImageMagick/ImageMagick/issues/312).\n  * Fix possible buffer overflow when writing compressed TIFFS (vulnerability\n    report from Cisco Talos, CVE-2016-8707).\n\n2016-11-15  7.0.3-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-8, GIT revision 19067:5aceded:20161125.\n\n2016-11-18  7.0.3-8 Cristy  <quetzlzacatenango@image...>\n  * Support the phash:colorspaces and phash:normalize options.\n  * If a convenient line break is not found, force it for caption: (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30887).\n  * Set alpha member of draw structure to OpaqueAlpha (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30894).\n  * Off by 1 error when computing the standard deviation (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=2&t=30866).\n  * Apply Debian patches, (reference\n    https://github.com/ImageMagick/ImageMagick/issues/304).\n  * Permit EPT images with just a TIFF or EPS image, not both (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30921).\n  * The -clone option no longer leaks memory.\n  * Render to clip mask rather than image for clip-path MVG graphics primitive.\n\n2016-11-15  7.0.3-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-7, GIT revision 19024:87aca83:20161115.\n\n2016-11-10  7.0.3-7 Cristy  <quetzlzacatenango@image...>\n  * Web pages were broken when we moved to HTTPS protocol.\n\n2016-11-08  7.0.3-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-6, GIT revision 19001:4cff747:20161108.\n\n2016-11-01  7.0.3-6 Cristy  <quetzlzacatenango@image...>\n  * Off by one memory allocation (reference\n    https://github.com/ImageMagick/ImageMagick/issues/296).\n  * The -extent option now matches the results of IMv6 (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=1&t=30779).\n  * Prevent fault in MSL interpreter (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30797).\n  * Mask composite produces proper results for the convert utility (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29675).\n    \n\n2016-10-10  7.0.3-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-5, GIT revision 18975:a8174a2:20161030.\n\n2016-10-16  7.0.3-5 Dirk Lemstra <dirk@lem.....org>\n  * Added layer RLE compression to the PSD encoder.\n\n2016-10-10  7.0.3-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-4, GIT revision 18937:83da034:20161010.\n\n2016-10-10  7.0.3-4 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect parsing with ordered dither. (reference\n    https://github.com/ImageMagick/ImageMagick/issues/254)\n\n2016-10-10  7.0.3-4 Cristy  <quetzlzacatenango@image...>\n  * Unit test pass again after small SUN image patch.\n\n2016-10-08  7.0.3-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-3, GIT revision 18924:d6614e7:20161008.\n\n2016-10-07  7.0.3-3 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect RLE decoding when reading a DCM image that contains\n    multiple segments.\n\n2016-10-02  7.0.3-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-2, GIT revision 18887:6b27c5b:20161002.\n\n2016-09-27  7.0.3-2 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect RLE decoding when reading an SGI image (reference \n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30514)\n\n2016-09-20  7.0.3-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-1, GIT revision 18851:ad91ea8:20160920.\n\n2016-09-16  7.0.3-1 Dirk Lemstra <dirk@lem.....org>\n  * Added layer RLE compression to the PSD encoder.\n  * Added define 'psd:preserve-opacity-mask' to preserve the opacity mask\n    in a PSD file.\n  * Fixed issue where the display window was used instead of the data window\n    when reading EXR files (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&p=137849).\n\n2016-09-05  7.0.3-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-0, GIT revision 18786:10aa64c:20160905.\n\n2016-08-29  7.0.3-0 Dirk Lemstra <dirk@lem.....org>\n  * Fixed reading DXT1 images with an alpha channel.\n  * Fixed incorrect padding calculation in PSD encoder.\n\n2016-08-27  7.0.2-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-10, GIT revision 18750:e3335b3:20160827.\n\n2016-08-27  7.0.2-10 Dirk Lemstra <dirk@lem.....org>\n  * Added define 'psd:additional-info' to preserve the additional information\n    in a PSD file.\n\n2016-08-15  7.0.2-10 Cristy  <quetzlzacatenango@image...>\n  * Prevent buffer overflow in BMP & SGI coders (bug report from\n    pwchen&rayzhong of tencent).\n  * Prevent buffer overflow and other problems in SIXEL, PDB, MAP, TIFF and\n    CALS coders (bug report from Donghai Zhu).\n  * The -stream option now increments the pixel pointer properly (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30327).\n\n2016-08-14  7.0.2-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-9, GIT revision 18707:2c02f09:20160814.\n\n2016-08-14  7.0.2-9 Cristy  <quetzlzacatenango@image...>\n  * Fix compile error in opencl.c (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30289).\n  * Eliminate compiler warning.\n\n2016-08-14  7.0.2-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-8, GIT revision 18698:74b1d5d:20160814.\n\n2016-08-07  7.0.2-8 Cristy  <quetzlzacatenango@image...>\n  * Prevent spurious removal of MPC cache files (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30256).\n  * Note alpha channel when combining 4 or more images (reference\n    https://github.com/ImageMagick/ImageMagick/issues/250).\n\n2016-08-06  7.0.2-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-7, GIT revision 10980:ecc03a2:20160806.\n\n2016-08-01  7.0.2-7 Cristy  <quetzlzacatenango@image...>\n  * Evaluate lazy pixel cache morphology to prevent buffer overflow (bug report\n    from Ibrahim M. El-Sayed).\n  * Prevent buffer overflow (bug report from Max Thrane).\n  * Prevent memory use after free (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30245).\n\n2016-07-30  7.0.2-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-6, GIT revision 18651:df24175:20160729.\n\n2016-07-29  7.0.2-6 Cristy  <quetzlzacatenango@image...>\n  * Support -region option (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=1&t=29692).\n\n2016-07-21  7.0.2-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-5, GIT revision 18627:2b5ddbd:20160721.\n\n2016-07-13  7.0.2-5 Cristy  <quetzlzacatenango@image...>\n  * Fix MVG stroke-opacity (reference\n    https://github.com/ImageMagick/ImageMagick/issues/229).\n  * Prevent possible buffer overflow when reading TIFF images (bug report from\n    Shi Pu of MS509 Team).\n  * Initialize index channel to get expected results from the stegano coder.\n\n2016-07-11  7.0.2-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-4, GIT revision 18591:50debe5:20160710.\n\n2016-07-10  7.0.2-4 Cristy  <quetzlzacatenango@image...>\n  * To comply with the SVG standard, use stroke-opacity for transparent strokes.\n  * Define CompositeChannels mask to Red, Green, Blue, Alpha, and Black.\n\n2016-07-09  7.0.2-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-3, GIT revision 18572:28560fc:20160709.\n\n2016-07-01  7.0.2-3 Cristy  <quetzlzacatenango@image...>\n  * Patch so -kuwahara option can preserve colormapped edges.\n  * The histogram coder now returns the correct extent.\n  * Use CopyMagickString() rather than CopyMagickMemory() for strings.\n\n2016-06-26  7.0.2-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-2, GIT revision 18514:a7b5b46:20160626.\n\n2016-06-23  7.0.2-2 Cristy  <quetzlzacatenango@image...>\n  * Correct for numerical instability (reference\n    https://github.com/ImageMagick/ImageMagick/issues/218).\n\t\t\t \n2016-06-21  7.0.2-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-1, GIT revision 18479:931319b:20160622.\n\n2016-06-17  7.0.2-1 Dirk Lemstra <dirk@lem.....org>\n  * Added support for GROUP4 compression to the FAX coder.\n\n2016-06-12  7.0.2-1 Cristy  <quetzlzacatenango@image...>\n  * Distort no longer converts grayscale image to sRGB (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=1&t=29895).\n  * Don't return a zero bounding box for QueryMultilineFontMetrics() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/222).\n\n2016-06-12  7.0.2-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-0, GIT revision 10884:f0e15e8:20160612.\n\n2016-06-09  7.0.2-0 Cristy  <quetzlzacatenango@image...>\n  * Backoff finite precision epsilon (reference\n    https://github.com/ImageMagick/ImageMagick/issues/215).\n  * Fix drawing glitch for stroke widths greater than 2 (reference\n    https://github.com/ImageMagick/ImageMagick/issues/218).\n\n2016-06-05  7.0.1-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-10, GIT revision 18406:ba4ad2d:20160607.\n\n2016-06-04  7.0.1-10 Cristy  <quetzlzacatenango@image...>\n  * Deny indirect reads by policy, remove policy to permit, e.g.,\n    convert caption:@mytext.txt ...\n  * RLE check for pixel offset less than 0 (heap overflow report from Craig\n    Young).\n  * Properly initialze PES blocks (reference\n    https://github.com/ImageMagick/ImageMagick/issues/213).\n\n2016-06-03  7.0.1-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-9, GIT revision 10847:339f803:20160602.\n\n2016-06-02  7.0.1-9 Cristy  <quetzlzacatenango@image...>\n  * Fix small memory leak (patch provided by \u0410\u043d\u0434\u0440\u0435\u0439 \u0427\u0435\u0440\u043d\u044b\u0439).\n  * Coder path traversal is not authorized (bug report provided by\n    Masaaki Chida).\n  * Turn off alpha channel for the compare difference image (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29828).\n\n2016-05-31  7.0.1-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-8, GIT revision 18334:97775b5:20160531.\n\n2016-05-31  7.0.1-8 Cristy  <quetzlzacatenango@image...>\n  * Support configure script --enable-pipes option to enable pipes (|) in\n    filenames.\n  * Support configure script --enable-indirect-reads option to enable\n    indirect reads (@) in filenames.\n\n2016-05-30  7.0.1-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-7, GIT revision 18321:5511ef5:20160530.\n\n2016-05-25  7.0.1-7 Cristy  <quetzlzacatenango@image...>\n  * Security improvements to TEXT coder broke it (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29754).\n  * Fix stroke offset problem for -annotate (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29626).\n  * Don't interpret -fx option arguments (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29774);\n  * Add additional checks to DCM reader to prevent data-driven faults (bug\n    report from Hanno B\u00f6ck).\n\n2016-05-21  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-6, GIT revision 18241:d4f277c:20160521.\n\n2016-05-20  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n  * Fixed proper placement of text annotation for east / west gravity.\n\n2016-05-18  7.0.1-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-5, GIT revision 10789:f7c2e89:20160518,\n\n2016-05-18  7.0.1-5 Cristy  <quetzlzacatenango@image...>\n  * Process channels independently for -channel -equalize (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29708).\n  * Fix pixel cache on disk regression (reference\n    https://github.com/ImageMagick/ImageMagick/issues/202).\n\n2016-05-15  7.0.1-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-4, GIT revision 10778:52dae14:20160516.\n\n2016-05-10  7.0.1-4 Cristy  <quetzlzacatenango@image...>\n  * Prevent possible shell command injection vulnerability through the\n    authenticate parameter of the PDF, PCL and XPS coders (report from\n    Erez Turjeman).\n  * Quote passwords when passed to a delegate program.\n  * Iterate channels over source image rather than destination (bug report\n    from Hanno B\u00f6ck).\n  * Can read geo-related EXIF metdata once-again (reference\n    https://github.com/ImageMagick/ImageMagick/issues/198).\n  * Sanitize all delegate emedded formatting characters.\n  * Don't sync pixel cache in AcquireAuthenticCacheView() (bug report from\n    Hanno B\u00f6ck).\n\n2016-05-09  7.0.1-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-3, GIT revision 10755:d540dda:20160509.\n\n2016-05-07  7.0.1-3 Cristy  <quetzlzacatenango@image...>\n  * Remove https delegate.\n\n2016-05-06  7.0.1-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-2, GIT revision 10741:5746147:20160507.\n\n2016-05-04  7.0.1-2 Cristy  <quetzlzacatenango@image...>\n  * Check for buffer overflow in magick/draw.c/DrawStrokePolygon().\n  * Replace show delegate title with image filename rather than label.\n  * Fix GetNextToken() off by one error.\n  * Remove support for internal ephemeral coder.\n\n2016-05-03  7.0.1-1 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.1-1, GIT revision 10723:9fc8a0c:20160503.\n\n2016-05-03  7.0.1-1 Cristy  <quetzlzacatenango@image...>\n  * Sanitize input filename for http / https delegates (improved patch).\n  * Fix for possible security vulnerabilities (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=4&t=29588).\n\n2016-04-30  7.0.1-0 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.1-0, GIT revision 10716:b527bce:20160430.\n\n2016-01-30  7.0.0-0 \tFahad-Alsaidi & ShamsaHamed\n  * Add support for languages that require complex text layout (reference\n    https://github.com/ImageMagick/ImageMagick/pull/88).\n\n2012-04-27  7.0.0-0 Anthony thyssen <A.Thyssen@griffith...>\n  * Allow the use of set and escapes when no images in memory\n    (unless you attempt to access per-image meta-data)\n    Currently does not include %[fx:...] and %[pixel:...]\n\n2012-10-05  7.0.0-0 Anthony thyssen <A.Thyssen@griffith...>\n  * Rather than replicate 'options' into 'artifacts' make a link\n    from image to image_info and lookup a global option if no artifact\n    is defined.\n\n2012-09-11  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * sigmoidal-contrast:\n  * Remove unnecessary initial ClampToQuantum.\n\n2012-09-10  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * sigmoidal-contrast:\n  * Direct computation, without LUT;\n  * Fix re-declaration of i (at the top, and inside a conditional).\n\n2012-09-04  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * Add tanh/atanh clone of legacy sigmoidal map (faster & more accurate).\n\n2012-08-08  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * Add final ClampToQuantum in sigmoidal colormap loop.\n  * Remove OpenMP calls from colormap update loops.\n\n2011-08-01  7.0.0-0 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.0-0.\n\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                             M   M  SSSSS  L                                 %\n%                             MM MM  SS     L                                 %\n%                             M M M   SSS   L                                 %\n%                             M   M     SS  L                                 %\n%                             M   M  SSSSS  LLLLL                             %\n%                                                                             %\n%                                                                             %\n%                    Execute Magick Scripting Language Scripts.               %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                             Leonard Rosenthol                               %\n%                             William Radcliffe                               %\n%                               December 2001                                 %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/annotate.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/decorate.h\"\n#include \"MagickCore/display.h\"\n#include \"MagickCore/distort.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/effect.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/fx.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/paint.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/registry.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/segment.h\"\n#include \"MagickCore/shear.h\"\n#include \"MagickCore/signature.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/threshold.h\"\n#include \"MagickCore/utility.h\"\n#if defined(MAGICKCORE_XML_DELEGATE)\n#  if defined(MAGICKCORE_WINDOWS_SUPPORT)\n#    if !defined(__MINGW32__) && !defined(__MINGW64__)\n#      include <win32config.h>\n#    endif\n#  endif\n#  include <libxml/parser.h>\n#  include <libxml/xmlmemory.h>\n#  include <libxml/parserInternals.h>\n#  include <libxml/xmlerror.h>\n#endif\n\f\n/*\n  Define Declatations.\n*/\n#define ThrowMSLException(severity,tag,reason) \\\n  (void) ThrowMagickException(msl_info->exception,GetMagickModule(),severity, \\\n    tag,\"`%s'\",reason);\n\f\n/*\n  Typedef declaractions.\n*/\ntypedef struct _MSLGroupInfo\n{\n  size_t\n    numImages;  /* how many images are in this group */\n} MSLGroupInfo;\n\ntypedef struct _MSLInfo\n{\n  ExceptionInfo\n    *exception;\n\n  ssize_t\n    n,\n    number_groups;\n\n  ImageInfo\n    **image_info;\n\n  DrawInfo\n   **draw_info;\n\n  Image\n    **attributes,\n    **image;\n\n  char\n    *content;\n\n  MSLGroupInfo\n    *group_info;\n\n#if defined(MAGICKCORE_XML_DELEGATE)\n  xmlParserCtxtPtr\n    parser;\n\n  xmlDocPtr\n    document;\n#endif\n} MSLInfo;\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_XML_DELEGATE)\nstatic MagickBooleanType\n  WriteMSLImage(const ImageInfo *,Image *,ExceptionInfo *);\n\nstatic MagickBooleanType\n  SetMSLAttributes(MSLInfo *,const char *,const char *);\n#endif\n\f\n#if defined(MAGICKCORE_XML_DELEGATE)\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d M S L I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadMSLImage() reads a Magick Scripting Language file and returns it.\n%  It allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadMSLImage method is:\n%\n%      Image *ReadMSLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic inline Image *GetImageCache(const ImageInfo *image_info,const char *path,\n  ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent];\n\n  ExceptionInfo\n    *sans_exception;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  (void) FormatLocaleString(key,MagickPathExtent,\"cache:%s\",path);\n  sans_exception=AcquireExceptionInfo();\n  image=(Image *) GetImageRegistry(ImageRegistryType,key,sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if (image != (Image *) NULL)\n    return(image);\n  read_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(read_info->filename,path,MagickPathExtent);\n  image=ReadImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    (void) SetImageRegistry(ImageRegistryType,key,image,exception);\n  return(image);\n}\n\nstatic int IsPathDirectory(const char *path)\n{\n  MagickBooleanType\n    status;\n\n  struct stat\n    attributes;\n\n  if ((path == (const char *) NULL) || (*path == '\\0'))\n    return(MagickFalse);\n  status=GetPathAttributes(path,&attributes);\n  if (status == MagickFalse)\n    return(-1);\n  if (S_ISDIR(attributes.st_mode) == 0)\n    return(0);\n  return(1);\n}\n\nstatic int MSLIsStandalone(void *context)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    Is this document tagged standalone?\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.MSLIsStandalone()\");\n  msl_info=(MSLInfo *) context;\n  return(msl_info->document->standalone == 1);\n}\n\nstatic int MSLHasInternalSubset(void *context)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    Does this document has an internal subset?\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.MSLHasInternalSubset()\");\n  msl_info=(MSLInfo *) context;\n  return(msl_info->document->intSubset != NULL);\n}\n\nstatic int MSLHasExternalSubset(void *context)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    Does this document has an external subset?\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.MSLHasExternalSubset()\");\n  msl_info=(MSLInfo *) context;\n  return(msl_info->document->extSubset != NULL);\n}\n\nstatic void MSLInternalSubset(void *context,const xmlChar *name,\n  const xmlChar *external_id,const xmlChar *system_id)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    Does this document has an internal subset?\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.internalSubset(%s %s %s)\",name,\n    (external_id != (const xmlChar *) NULL ? (const char *) external_id : \" \"),\n    (system_id != (const xmlChar *) NULL ? (const char *) system_id : \" \"));\n  msl_info=(MSLInfo *) context;\n  (void) xmlCreateIntSubset(msl_info->document,name,external_id,system_id);\n}\n\nstatic xmlParserInputPtr MSLResolveEntity(void *context,\n  const xmlChar *public_id,const xmlChar *system_id)\n{\n  MSLInfo\n    *msl_info;\n\n  xmlParserInputPtr\n    stream;\n\n  /*\n    Special entity resolver, better left to the parser, it has more\n    context than the application layer.  The default behaviour is to\n    not resolve the entities, in that case the ENTITY_REF nodes are\n    built in the structure (and the parameter values).\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.resolveEntity(%s, %s)\",\n    (public_id != (const xmlChar *) NULL ? (const char *) public_id : \"none\"),\n    (system_id != (const xmlChar *) NULL ? (const char *) system_id : \"none\"));\n  msl_info=(MSLInfo *) context;\n  stream=xmlLoadExternalEntity((const char *) system_id,(const char *)\n    public_id,msl_info->parser);\n  return(stream);\n}\n\nstatic xmlEntityPtr MSLGetEntity(void *context,const xmlChar *name)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    Get an entity by name.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.MSLGetEntity(%s)\",(const char *) name);\n  msl_info=(MSLInfo *) context;\n  return(xmlGetDocEntity(msl_info->document,name));\n}\n\nstatic xmlEntityPtr MSLGetParameterEntity(void *context,const xmlChar *name)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    Get a parameter entity by name.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.getParameterEntity(%s)\",(const char *) name);\n  msl_info=(MSLInfo *) context;\n  return(xmlGetParameterEntity(msl_info->document,name));\n}\n\nstatic void MSLEntityDeclaration(void *context,const xmlChar *name,int type,\n  const xmlChar *public_id,const xmlChar *system_id,xmlChar *content)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    An entity definition has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.entityDecl(%s, %d, %s, %s, %s)\",name,type,\n    public_id != (const xmlChar *) NULL ? (const char *) public_id : \"none\",\n    system_id != (const xmlChar *) NULL ? (const char *) system_id : \"none\",\n    content);\n  msl_info=(MSLInfo *) context;\n  if (msl_info->parser->inSubset == 1)\n    (void) xmlAddDocEntity(msl_info->document,name,type,public_id,system_id,\n      content);\n  else\n    if (msl_info->parser->inSubset == 2)\n      (void) xmlAddDtdEntity(msl_info->document,name,type,public_id,system_id,\n        content);\n}\n\nstatic void MSLAttributeDeclaration(void *context,const xmlChar *element,\n  const xmlChar *name,int type,int value,const xmlChar *default_value,\n  xmlEnumerationPtr tree)\n{\n  MSLInfo\n    *msl_info;\n\n  xmlChar\n    *fullname,\n    *prefix;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    An attribute definition has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.attributeDecl(%s, %s, %d, %d, %s, ...)\\n\",element,name,type,value,\n    default_value);\n  msl_info=(MSLInfo *) context;\n  fullname=(xmlChar *) NULL;\n  prefix=(xmlChar *) NULL;\n  parser=msl_info->parser;\n  fullname=(xmlChar *) xmlSplitQName(parser,name,&prefix);\n  if (parser->inSubset == 1)\n    (void) xmlAddAttributeDecl(&parser->vctxt,msl_info->document->intSubset,\n      element,fullname,prefix,(xmlAttributeType) type,\n      (xmlAttributeDefault) value,default_value,tree);\n  else\n    if (parser->inSubset == 2)\n      (void) xmlAddAttributeDecl(&parser->vctxt,msl_info->document->extSubset,\n        element,fullname,prefix,(xmlAttributeType) type,\n        (xmlAttributeDefault) value,default_value,tree);\n  if (prefix != (xmlChar *) NULL)\n    xmlFree(prefix);\n  if (fullname != (xmlChar *) NULL)\n    xmlFree(fullname);\n}\n\nstatic void MSLElementDeclaration(void *context,const xmlChar *name,int type,\n  xmlElementContentPtr content)\n{\n  MSLInfo\n    *msl_info;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    An element definition has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.elementDecl(%s, %d, ...)\",name,type);\n  msl_info=(MSLInfo *) context;\n  parser=msl_info->parser;\n  if (parser->inSubset == 1)\n    (void) xmlAddElementDecl(&parser->vctxt,msl_info->document->intSubset,\n      name,(xmlElementTypeVal) type,content);\n  else\n    if (parser->inSubset == 2)\n      (void) xmlAddElementDecl(&parser->vctxt,msl_info->document->extSubset,\n        name,(xmlElementTypeVal) type,content);\n}\n\nstatic void MSLNotationDeclaration(void *context,const xmlChar *name,\n  const xmlChar *public_id,const xmlChar *system_id)\n{\n  MSLInfo\n    *msl_info;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    What to do when a notation declaration has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.notationDecl(%s, %s, %s)\",name,\n    public_id != (const xmlChar *) NULL ? (const char *) public_id : \"none\",\n    system_id != (const xmlChar *) NULL ? (const char *) system_id : \"none\");\n  msl_info=(MSLInfo *) context;\n  parser=msl_info->parser;\n  if (parser->inSubset == 1)\n    (void) xmlAddNotationDecl(&parser->vctxt,msl_info->document->intSubset,\n      name,public_id,system_id);\n  else\n    if (parser->inSubset == 2)\n      (void) xmlAddNotationDecl(&parser->vctxt,msl_info->document->intSubset,\n        name,public_id,system_id);\n}\n\nstatic void MSLUnparsedEntityDeclaration(void *context,const xmlChar *name,\n  const xmlChar *public_id,const xmlChar *system_id,const xmlChar *notation)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    What to do when an unparsed entity declaration is parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.unparsedEntityDecl(%s, %s, %s, %s)\",name,\n    public_id != (const xmlChar *) NULL ? (const char *) public_id : \"none\",\n    system_id != (const xmlChar *) NULL ? (const char *) system_id : \"none\",\n    notation);\n  msl_info=(MSLInfo *) context;\n  (void) xmlAddDocEntity(msl_info->document,name,\n    XML_EXTERNAL_GENERAL_UNPARSED_ENTITY,public_id,system_id,notation);\n\n}\n\nstatic void MSLSetDocumentLocator(void *context,xmlSAXLocatorPtr location)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    Receive the document locator at startup, actually xmlDefaultSAXLocator.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.setDocumentLocator()\\n\");\n  (void) location;\n  msl_info=(MSLInfo *) context;\n  (void) msl_info;\n}\n\nstatic void MSLStartDocument(void *context)\n{\n  MSLInfo\n    *msl_info;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    Called when the document start being processed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.startDocument()\");\n  msl_info=(MSLInfo *) context;\n  parser=msl_info->parser;\n  msl_info->document=xmlNewDoc(parser->version);\n  if (msl_info->document == (xmlDocPtr) NULL)\n    return;\n  if (parser->encoding == NULL)\n    msl_info->document->encoding=NULL;\n  else\n    msl_info->document->encoding=xmlStrdup(parser->encoding);\n  msl_info->document->standalone=parser->standalone;\n}\n\nstatic void MSLEndDocument(void *context)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    Called when the document end has been detected.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.endDocument()\");\n  msl_info=(MSLInfo *) context;\n  if (msl_info->content != (char *) NULL)\n    msl_info->content=DestroyString(msl_info->content);\n}\n\nstatic void MSLPushImage(MSLInfo *msl_info,Image *image)\n{\n  ssize_t\n    n;\n\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(msl_info != (MSLInfo *) NULL);\n  msl_info->n++;\n  n=msl_info->n;\n  msl_info->image_info=(ImageInfo **) ResizeQuantumMemory(msl_info->image_info,\n    (n+1),sizeof(*msl_info->image_info));\n  msl_info->draw_info=(DrawInfo **) ResizeQuantumMemory(msl_info->draw_info,\n    (n+1),sizeof(*msl_info->draw_info));\n  msl_info->attributes=(Image **) ResizeQuantumMemory(msl_info->attributes,\n    (n+1),sizeof(*msl_info->attributes));\n  msl_info->image=(Image **) ResizeQuantumMemory(msl_info->image,(n+1),\n    sizeof(*msl_info->image));\n  if ((msl_info->image_info == (ImageInfo **) NULL) ||\n      (msl_info->draw_info == (DrawInfo **) NULL) ||\n      (msl_info->attributes == (Image **) NULL) ||\n      (msl_info->image == (Image **) NULL))\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\")\n  msl_info->image_info[n]=CloneImageInfo(msl_info->image_info[n-1]);\n  msl_info->draw_info[n]=CloneDrawInfo(msl_info->image_info[n-1],\n    msl_info->draw_info[n-1]);\n  if (image == (Image *) NULL)\n    msl_info->attributes[n]=AcquireImage(msl_info->image_info[n],\n      msl_info->exception);\n  else\n    msl_info->attributes[n]=CloneImage(image,0,0,MagickTrue,\n      msl_info->exception);\n  msl_info->image[n]=(Image *) image;\n  if ((msl_info->image_info[n] == (ImageInfo *) NULL) ||\n      (msl_info->attributes[n] == (Image *) NULL))\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\")\n  if (msl_info->number_groups != 0)\n    msl_info->group_info[msl_info->number_groups-1].numImages++;\n}\n\nstatic void MSLPopImage(MSLInfo *msl_info)\n{\n  if (msl_info->number_groups != 0)\n    return;\n  if (msl_info->image[msl_info->n] != (Image *) NULL)\n    msl_info->image[msl_info->n]=DestroyImage(msl_info->image[msl_info->n]);\n  msl_info->attributes[msl_info->n]=DestroyImage(\n    msl_info->attributes[msl_info->n]);\n  msl_info->image_info[msl_info->n]=DestroyImageInfo(\n    msl_info->image_info[msl_info->n]);\n  msl_info->n--;\n}\n\nstatic void MSLStartElement(void *context,const xmlChar *tag,\n  const xmlChar **attributes)\n{\n  AffineMatrix\n    affine,\n    current;\n\n  ChannelType\n    channel;\n\n  ChannelType\n    channel_mask;\n\n  char\n    *attribute,\n    key[MagickPathExtent],\n    *value;\n\n  const char\n    *keyword;\n\n  double\n    angle;\n\n  DrawInfo\n    *draw_info;\n\n  ExceptionInfo\n    *exception;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image;\n\n  int\n    flags;\n\n  ssize_t\n    option,\n    j,\n    n,\n    x,\n    y;\n\n  MSLInfo\n    *msl_info;\n\n  RectangleInfo\n    geometry;\n\n  register ssize_t\n    i;\n\n  size_t\n    height,\n    width;\n\n  /*\n    Called when an opening tag has been processed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.startElement(%s\",tag);\n  exception=AcquireExceptionInfo();\n  msl_info=(MSLInfo *) context;\n  n=msl_info->n;\n  keyword=(const char *) NULL;\n  value=(char *) NULL;\n  SetGeometryInfo(&geometry_info);\n  (void) ResetMagickMemory(&geometry,0,sizeof(geometry));\n  channel=DefaultChannels;\n  switch (*tag)\n  {\n    case 'A':\n    case 'a':\n    {\n      if (LocaleCompare((const char *) tag,\"add-noise\") == 0)\n        {\n          Image\n            *noise_image;\n\n          NoiseType\n            noise;\n\n          /*\n            Add noise image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          noise=UniformNoise;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"channel\") == 0)\n                    {\n                      option=ParseChannelOption(value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedChannelType\",\n                          value);\n                      channel=(ChannelType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'N':\n                case 'n':\n                {\n                  if (LocaleCompare(keyword,\"noise\") == 0)\n                    {\n                      option=ParseCommandOption(MagickNoiseOptions,MagickFalse,\n                        value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedNoiseType\",\n                          value);\n                      noise=(NoiseType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          channel_mask=SetImageChannelMask(msl_info->image[n],channel);\n          noise_image=AddNoiseImage(msl_info->image[n],noise,1.0,\n            msl_info->exception);\n          (void) SetPixelChannelMask(msl_info->image[n],channel_mask);\n          if (noise_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=noise_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"annotate\") == 0)\n        {\n          char\n            text[MagickPathExtent];\n\n          /*\n            Annotate image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          draw_info=CloneDrawInfo(msl_info->image_info[n],\n            msl_info->draw_info[n]);\n          angle=0.0;\n          current=draw_info->affine;\n          GetAffineMatrix(&affine);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'A':\n                case 'a':\n                {\n                  if (LocaleCompare(keyword,\"affine\") == 0)\n                    {\n                      char\n                        *p;\n\n                      p=value;\n                      draw_info->affine.sx=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.rx=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.ry=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.sy=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.tx=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.ty=StringToDouble(p,&p);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"align\") == 0)\n                    {\n                      option=ParseCommandOption(MagickAlignOptions,MagickFalse,\n                        value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedAlignType\",\n                          value);\n                      draw_info->align=(AlignType) option;\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"antialias\") == 0)\n                    {\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedBooleanType\",\n                          value);\n                      draw_info->stroke_antialias=(MagickBooleanType) option;\n                      draw_info->text_antialias=(MagickBooleanType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'D':\n                case 'd':\n                {\n                  if (LocaleCompare(keyword,\"density\") == 0)\n                    {\n                      CloneString(&draw_info->density,value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'E':\n                case 'e':\n                {\n                  if (LocaleCompare(keyword,\"encoding\") == 0)\n                    {\n                      CloneString(&draw_info->encoding,value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword, \"fill\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &draw_info->fill,exception);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"family\") == 0)\n                    {\n                      CloneString(&draw_info->family,value);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"font\") == 0)\n                    {\n                      CloneString(&draw_info->font,value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGravityGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"gravity\") == 0)\n                    {\n                      option=ParseCommandOption(MagickGravityOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedGravityType\",\n                          value);\n                      draw_info->gravity=(GravityType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'P':\n                case 'p':\n                {\n                  if (LocaleCompare(keyword,\"pointsize\") == 0)\n                    {\n                      draw_info->pointsize=StringToDouble(value,(char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"rotate\") == 0)\n                    {\n                      angle=StringToDouble(value,(char **) NULL);\n                      affine.sx=cos(DegreesToRadians(fmod(angle,360.0)));\n                      affine.rx=sin(DegreesToRadians(fmod(angle,360.0)));\n                      affine.ry=(-sin(DegreesToRadians(fmod(angle,360.0))));\n                      affine.sy=cos(DegreesToRadians(fmod(angle,360.0)));\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'S':\n                case 's':\n                {\n                  if (LocaleCompare(keyword,\"scale\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      affine.sx=geometry_info.rho;\n                      affine.sy=geometry_info.sigma;\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"skewX\") == 0)\n                    {\n                      angle=StringToDouble(value,(char **) NULL);\n                      affine.ry=tan(DegreesToRadians(fmod((double) angle,\n                        360.0)));\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"skewY\") == 0)\n                    {\n                      angle=StringToDouble(value,(char **) NULL);\n                      affine.rx=tan(DegreesToRadians(fmod((double) angle,\n                        360.0)));\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"stretch\") == 0)\n                    {\n                      option=ParseCommandOption(MagickStretchOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedStretchType\",\n                          value);\n                      draw_info->stretch=(StretchType) option;\n                      break;\n                    }\n                  if (LocaleCompare(keyword, \"stroke\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &draw_info->stroke,exception);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"strokewidth\") == 0)\n                    {\n                      draw_info->stroke_width=StringToLong(value);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"style\") == 0)\n                    {\n                      option=ParseCommandOption(MagickStyleOptions,MagickFalse,\n                        value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedStyleType\",\n                          value);\n                      draw_info->style=(StyleType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'T':\n                case 't':\n                {\n                  if (LocaleCompare(keyword,\"text\") == 0)\n                    {\n                      CloneString(&draw_info->text,value);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"translate\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      affine.tx=geometry_info.rho;\n                      affine.ty=geometry_info.sigma;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'U':\n                case 'u':\n                {\n                  if (LocaleCompare(keyword, \"undercolor\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &draw_info->undercolor,exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"weight\") == 0)\n                    {\n                      draw_info->weight=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry.x=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry.y=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) FormatLocaleString(text,MagickPathExtent,\n            \"%.20gx%.20g%+.20g%+.20g\",(double) geometry.width,(double)\n            geometry.height,(double) geometry.x,(double) geometry.y);\n          CloneString(&draw_info->geometry,text);\n          draw_info->affine.sx=affine.sx*current.sx+affine.ry*current.rx;\n          draw_info->affine.rx=affine.rx*current.sx+affine.sy*current.rx;\n          draw_info->affine.ry=affine.sx*current.ry+affine.ry*current.sy;\n          draw_info->affine.sy=affine.rx*current.ry+affine.sy*current.sy;\n          draw_info->affine.tx=affine.sx*current.tx+affine.ry*current.ty+\n            affine.tx;\n          draw_info->affine.ty=affine.rx*current.tx+affine.sy*current.ty+\n            affine.ty;\n          (void) AnnotateImage(msl_info->image[n],draw_info,\n            msl_info->exception);\n          draw_info=DestroyDrawInfo(draw_info);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"append\") == 0)\n        {\n          Image\n            *append_image;\n\n          MagickBooleanType\n            stack;\n\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          stack=MagickFalse;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'S':\n                case 's':\n                {\n                  if (LocaleCompare(keyword,\"stack\") == 0)\n                    {\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedBooleanType\",\n                          value);\n                      stack=(MagickBooleanType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          append_image=AppendImages(msl_info->image[n],stack,\n            msl_info->exception);\n          if (append_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=append_image;\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n      break;\n    }\n    case 'B':\n    case 'b':\n    {\n      if (LocaleCompare((const char *) tag,\"blur\") == 0)\n        {\n          Image\n            *blur_image;\n\n          /*\n            Blur image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"channel\") == 0)\n                    {\n                      option=ParseChannelOption(value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedChannelType\",\n                          value);\n                      channel=(ChannelType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"radius\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,(char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'S':\n                case 's':\n                {\n                  if (LocaleCompare(keyword,\"sigma\") == 0)\n                    {\n                      geometry_info.sigma=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          channel_mask=SetImageChannelMask(msl_info->image[n],channel);\n          blur_image=BlurImage(msl_info->image[n],geometry_info.rho,\n            geometry_info.sigma,msl_info->exception);\n          (void) SetPixelChannelMask(msl_info->image[n],channel_mask);\n          if (blur_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=blur_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"border\") == 0)\n        {\n          Image\n            *border_image;\n\n          /*\n            Border image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          SetGeometry(msl_info->image[n],&geometry);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"compose\") == 0)\n                    {\n                      option=ParseCommandOption(MagickComposeOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedComposeType\",\n                          value);\n                      msl_info->image[n]->compose=(CompositeOperator) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword, \"fill\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &msl_info->image[n]->border_color,exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParsePageGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      if ((flags & HeightValue) == 0)\n                        geometry.height=geometry.width;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'H':\n                case 'h':\n                {\n                  if (LocaleCompare(keyword,\"height\") == 0)\n                    {\n                      geometry.height=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"width\") == 0)\n                    {\n                      geometry.width=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          border_image=BorderImage(msl_info->image[n],&geometry,\n            msl_info->image[n]->compose,msl_info->exception);\n          if (border_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=border_image;\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'C':\n    case 'c':\n    {\n      if (LocaleCompare((const char *) tag,\"colorize\") == 0)\n        {\n          char\n            blend[MagickPathExtent];\n\n          Image\n            *colorize_image;\n\n          PixelInfo\n            target;\n\n          /*\n            Add noise image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          GetPixelInfo(msl_info->image[n],&target);\n          (void) CopyMagickString(blend,\"100\",MagickPathExtent);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'B':\n                case 'b':\n                {\n                  if (LocaleCompare(keyword,\"blend\") == 0)\n                    {\n                      (void) CopyMagickString(blend,value,MagickPathExtent);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword,\"fill\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &target,msl_info->exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          colorize_image=ColorizeImage(msl_info->image[n],blend,&target,\n            msl_info->exception);\n          if (colorize_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=colorize_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag, \"charcoal\") == 0)\n      {\n        double \n            radius = 0.0,\n            sigma = 1.0;\n\n        if (msl_info->image[n] == (Image *) NULL)\n        {\n          ThrowMSLException(OptionError,\"NoImagesDefined\",\n            (const char *) tag);\n          break;\n        }\n        /*\n          NOTE: charcoal can have no attributes, since we use all the defaults!\n        */\n        if (attributes != (const xmlChar **) NULL)\n        {\n          for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n          {\n            keyword=(const char *) attributes[i++];\n            attribute=InterpretImageProperties(msl_info->image_info[n],\n              msl_info->attributes[n],(const char *) attributes[i],exception);\n            CloneString(&value,attribute);\n            attribute=DestroyString(attribute);\n          switch (*keyword)\n          {\n            case 'R':\n            case 'r':\n            {\n              if (LocaleCompare(keyword,\"radius\") == 0)\n              {\n                radius=StringToDouble(value,(char **) NULL);\n                break;\n              }\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n            case 'S':\n            case 's':\n            {\n              if (LocaleCompare(keyword,\"sigma\") == 0)\n              {\n                sigma = StringToLong( value );\n                break;\n              }\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n            default:\n            {\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n          }\n          }\n        }\n\n        /*\n          charcoal image.\n        */\n        {\n        Image\n          *newImage;\n\n        newImage=CharcoalImage(msl_info->image[n],radius,sigma,\n          msl_info->exception);\n        if (newImage == (Image *) NULL)\n          break;\n        msl_info->image[n]=DestroyImage(msl_info->image[n]);\n        msl_info->image[n]=newImage;\n        break;\n        }\n      }\n      if (LocaleCompare((const char *) tag,\"chop\") == 0)\n        {\n          Image\n            *chop_image;\n\n          /*\n            Chop image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          SetGeometry(msl_info->image[n],&geometry);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParsePageGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      if ((flags & HeightValue) == 0)\n                        geometry.height=geometry.width;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'H':\n                case 'h':\n                {\n                  if (LocaleCompare(keyword,\"height\") == 0)\n                    {\n                      geometry.height=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"width\") == 0)\n                    {\n                      geometry.width=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry.x=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry.y=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          chop_image=ChopImage(msl_info->image[n],&geometry,\n            msl_info->exception);\n          if (chop_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=chop_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"color-floodfill\") == 0)\n        {\n          PaintMethod\n            paint_method;\n\n          PixelInfo\n            target;\n\n          /*\n            Color floodfill image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          draw_info=CloneDrawInfo(msl_info->image_info[n],\n            msl_info->draw_info[n]);\n          SetGeometry(msl_info->image[n],&geometry);\n          paint_method=FloodfillMethod;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'B':\n                case 'b':\n                {\n                  if (LocaleCompare(keyword,\"bordercolor\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &target,exception);\n                      paint_method=FillToBorderMethod;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword,\"fill\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &draw_info->fill,exception);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"fuzz\") == 0)\n                    {\n                      msl_info->image[n]->fuzz=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParsePageGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      if ((flags & HeightValue) == 0)\n                        geometry.height=geometry.width;\n                      (void) GetOneVirtualPixelInfo(msl_info->image[n],\n                        TileVirtualPixelMethod,geometry.x,geometry.y,&target,\n                        exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry.x=StringToLong(value);\n                      (void) GetOneVirtualPixelInfo(msl_info->image[n],\n                        TileVirtualPixelMethod,geometry.x,geometry.y,&target,\n                        exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry.y=StringToLong(value);\n                      (void) GetOneVirtualPixelInfo(msl_info->image[n],\n                        TileVirtualPixelMethod,geometry.x,geometry.y,&target,\n                        exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) FloodfillPaintImage(msl_info->image[n],draw_info,&target,\n            geometry.x,geometry.y,paint_method == FloodfillMethod ?\n            MagickFalse : MagickTrue,msl_info->exception);\n          draw_info=DestroyDrawInfo(draw_info);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"comment\") == 0)\n        break;\n      if (LocaleCompare((const char *) tag,\"composite\") == 0)\n        {\n          char\n            composite_geometry[MagickPathExtent];\n\n          CompositeOperator\n            compose;\n\n          Image\n            *composite_image,\n            *rotate_image;\n\n          /*\n            Composite image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          composite_image=NewImageList();\n          compose=OverCompositeOp;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"compose\") == 0)\n                    {\n                      option=ParseCommandOption(MagickComposeOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedComposeType\",\n                          value);\n                      compose=(CompositeOperator) option;\n                      break;\n                    }\n                  break;\n                }\n                case 'I':\n                case 'i':\n                {\n                  if (LocaleCompare(keyword,\"image\") == 0)\n                    for (j=0; j < msl_info->n; j++)\n                    {\n                      const char\n                        *attribute;\n\n                      attribute=GetImageProperty(msl_info->attributes[j],\"id\",\n                        exception);\n                      if ((attribute != (const char *) NULL)  &&\n                          (LocaleCompare(attribute,value) == 0))\n                        {\n                          composite_image=CloneImage(msl_info->image[j],0,0,\n                            MagickFalse,exception);\n                          break;\n                        }\n                    }\n                  break;\n                }\n                default:\n                  break;\n              }\n            }\n          if (composite_image == (Image *) NULL)\n            break;\n          rotate_image=NewImageList();\n          SetGeometry(msl_info->image[n],&geometry);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'B':\n                case 'b':\n                {\n                  if (LocaleCompare(keyword,\"blend\") == 0)\n                    {\n                      (void) SetImageArtifact(composite_image,\n                                            \"compose:args\",value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"channel\") == 0)\n                    {\n                      option=ParseChannelOption(value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedChannelType\",\n                          value);\n                      channel=(ChannelType) option;\n                      break;\n                    }\n                  if (LocaleCompare(keyword, \"color\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &composite_image->background_color,exception);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"compose\") == 0)\n                    break;\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParsePageGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      if ((flags & HeightValue) == 0)\n                        geometry.height=geometry.width;\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"gravity\") == 0)\n                    {\n                      option=ParseCommandOption(MagickGravityOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedGravityType\",\n                          value);\n                      msl_info->image[n]->gravity=(GravityType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'I':\n                case 'i':\n                {\n                  if (LocaleCompare(keyword,\"image\") == 0)\n                    break;\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'M':\n                case 'm':\n                {\n                  if (LocaleCompare(keyword,\"mask\") == 0)\n                    for (j=0; j < msl_info->n; j++)\n                    {\n                      const char\n                        *attribute;\n\n                      attribute=GetImageProperty(msl_info->attributes[j],\"id\",\n                        exception);\n                      if ((attribute != (const char *) NULL)  &&\n                          (LocaleCompare(value,value) == 0))\n                        {\n                          SetImageType(composite_image,TrueColorAlphaType,\n                            exception);\n                          (void) CompositeImage(composite_image,\n                            msl_info->image[j],CopyAlphaCompositeOp,MagickTrue,\n                            0,0,exception);\n                          break;\n                        }\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'O':\n                case 'o':\n                {\n                  if (LocaleCompare(keyword,\"opacity\") == 0)\n                    {\n                      ssize_t\n                        opacity,\n                        y;\n\n                      register ssize_t\n                        x;\n\n                      register Quantum\n                        *q;\n\n                      CacheView\n                        *composite_view;\n\n                      opacity=StringToLong(value);\n                      if (compose != DissolveCompositeOp)\n                        {\n                          (void) SetImageAlpha(composite_image,(Quantum)\n                            opacity,exception);\n                          break;\n                        }\n                      (void) SetImageArtifact(msl_info->image[n],\n                                            \"compose:args\",value);\n                      if (composite_image->alpha_trait == UndefinedPixelTrait)\n                        (void) SetImageAlpha(composite_image,OpaqueAlpha,\n                          exception);\n                      composite_view=AcquireAuthenticCacheView(composite_image,exception);\n                      for (y=0; y < (ssize_t) composite_image->rows ; y++)\n                      {\n                        q=GetCacheViewAuthenticPixels(composite_view,0,y,\n                          (ssize_t) composite_image->columns,1,exception);\n                        for (x=0; x < (ssize_t) composite_image->columns; x++)\n                        {\n                          if (GetPixelAlpha(composite_image,q) == OpaqueAlpha)\n                            SetPixelAlpha(composite_image,\n                              ClampToQuantum(opacity),q);\n                          q+=GetPixelChannels(composite_image);\n                        }\n                        if (SyncCacheViewAuthenticPixels(composite_view,exception) == MagickFalse)\n                          break;\n                      }\n                      composite_view=DestroyCacheView(composite_view);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"rotate\") == 0)\n                    {\n                      rotate_image=RotateImage(composite_image,\n                        StringToDouble(value,(char **) NULL),exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'T':\n                case 't':\n                {\n                  if (LocaleCompare(keyword,\"tile\") == 0)\n                    {\n                      MagickBooleanType\n                        tile;\n\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedBooleanType\",\n                          value);\n                      tile=(MagickBooleanType) option;\n                      (void) tile;\n                      if (rotate_image != (Image *) NULL)\n                        (void) SetImageArtifact(rotate_image,\n                          \"compose:outside-overlay\",\"false\");\n                      else\n                        (void) SetImageArtifact(composite_image,\n                          \"compose:outside-overlay\",\"false\");\n                       image=msl_info->image[n];\n                       height=composite_image->rows;\n                       width=composite_image->columns;\n                       for (y=0; y < (ssize_t) image->rows; y+=(ssize_t) height)\n                         for (x=0; x < (ssize_t) image->columns; x+=(ssize_t) width)\n                         {\n                           if (rotate_image != (Image *) NULL)\n                             (void) CompositeImage(image,rotate_image,compose,\n                               MagickTrue,x,y,exception);\n                           else\n                             (void) CompositeImage(image,composite_image,\n                               compose,MagickTrue,x,y,exception);\n                         }\n                      if (rotate_image != (Image *) NULL)\n                        rotate_image=DestroyImage(rotate_image);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry.x=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry.y=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          image=msl_info->image[n];\n          (void) FormatLocaleString(composite_geometry,MagickPathExtent,\n            \"%.20gx%.20g%+.20g%+.20g\",(double) composite_image->columns,\n            (double) composite_image->rows,(double) geometry.x,(double)\n            geometry.y);\n          flags=ParseGravityGeometry(image,composite_geometry,&geometry,\n            exception);\n          channel_mask=SetImageChannelMask(image,channel);\n          if (rotate_image == (Image *) NULL)\n            CompositeImage(image,composite_image,compose,MagickTrue,geometry.x,\n              geometry.y,exception);\n          else\n            {\n              /*\n                Rotate image.\n              */\n              geometry.x-=(ssize_t) (rotate_image->columns-\n                composite_image->columns)/2;\n              geometry.y-=(ssize_t) (rotate_image->rows-\n                composite_image->rows)/2;\n              CompositeImage(image,rotate_image,compose,MagickTrue,geometry.x,\n                geometry.y,exception);\n              rotate_image=DestroyImage(rotate_image);\n            }\n          (void) SetImageChannelMask(image,channel_mask);\n          composite_image=DestroyImage(composite_image);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"contrast\") == 0)\n        {\n          MagickBooleanType\n            sharpen;\n\n          /*\n            Contrast image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          sharpen=MagickFalse;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'S':\n                case 's':\n                {\n                  if (LocaleCompare(keyword,\"sharpen\") == 0)\n                    {\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedBooleanType\",\n                          value);\n                      sharpen=(MagickBooleanType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) ContrastImage(msl_info->image[n],sharpen,\n            msl_info->exception);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"crop\") == 0)\n        {\n          Image\n            *crop_image;\n\n          /*\n            Crop image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          SetGeometry(msl_info->image[n],&geometry);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGravityGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'H':\n                case 'h':\n                {\n                  if (LocaleCompare(keyword,\"height\") == 0)\n                    {\n                      geometry.height=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"width\") == 0)\n                    {\n                      geometry.width=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry.x=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry.y=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          crop_image=CropImage(msl_info->image[n],&geometry,\n            msl_info->exception);\n          if (crop_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=crop_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"cycle-colormap\") == 0)\n        {\n          ssize_t\n            display;\n\n          /*\n            Cycle-colormap image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          display=0;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'D':\n                case 'd':\n                {\n                  if (LocaleCompare(keyword,\"display\") == 0)\n                    {\n                      display=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) CycleColormapImage(msl_info->image[n],display,exception);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleCompare((const char *) tag,\"despeckle\") == 0)\n        {\n          Image\n            *despeckle_image;\n\n          /*\n            Despeckle image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            }\n          despeckle_image=DespeckleImage(msl_info->image[n],\n            msl_info->exception);\n          if (despeckle_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=despeckle_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"display\") == 0)\n        {\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) DisplayImages(msl_info->image_info[n],msl_info->image[n],\n            msl_info->exception);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"draw\") == 0)\n        {\n          char\n            text[MagickPathExtent];\n\n          /*\n            Annotate image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          draw_info=CloneDrawInfo(msl_info->image_info[n],\n            msl_info->draw_info[n]);\n          angle=0.0;\n          current=draw_info->affine;\n          GetAffineMatrix(&affine);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'A':\n                case 'a':\n                {\n                  if (LocaleCompare(keyword,\"affine\") == 0)\n                    {\n                      char\n                        *p;\n\n                      p=value;\n                      draw_info->affine.sx=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.rx=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.ry=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.sy=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.tx=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.ty=StringToDouble(p,&p);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"align\") == 0)\n                    {\n                      option=ParseCommandOption(MagickAlignOptions,MagickFalse,\n                        value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedAlignType\",\n                          value);\n                      draw_info->align=(AlignType) option;\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"antialias\") == 0)\n                    {\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedBooleanType\",\n                          value);\n                      draw_info->stroke_antialias=(MagickBooleanType) option;\n                      draw_info->text_antialias=(MagickBooleanType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'D':\n                case 'd':\n                {\n                  if (LocaleCompare(keyword,\"density\") == 0)\n                    {\n                      CloneString(&draw_info->density,value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'E':\n                case 'e':\n                {\n                  if (LocaleCompare(keyword,\"encoding\") == 0)\n                    {\n                      CloneString(&draw_info->encoding,value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword, \"fill\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &draw_info->fill,exception);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"family\") == 0)\n                    {\n                      CloneString(&draw_info->family,value);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"font\") == 0)\n                    {\n                      CloneString(&draw_info->font,value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParsePageGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      if ((flags & HeightValue) == 0)\n                        geometry.height=geometry.width;\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"gravity\") == 0)\n                    {\n                      option=ParseCommandOption(MagickGravityOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedGravityType\",\n                          value);\n                      draw_info->gravity=(GravityType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'P':\n                case 'p':\n                {\n                  if (LocaleCompare(keyword,\"points\") == 0)\n                    {\n                      if (LocaleCompare(draw_info->primitive,\"path\") == 0)\n                        {\n                          (void) ConcatenateString(&draw_info->primitive,\" '\");\n                          ConcatenateString(&draw_info->primitive,value);\n                          (void) ConcatenateString(&draw_info->primitive,\"'\");\n                        }\n                      else\n                        {\n                          (void) ConcatenateString(&draw_info->primitive,\" \");\n                          ConcatenateString(&draw_info->primitive,value);\n                        }\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"pointsize\") == 0)\n                    {\n                      draw_info->pointsize=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"primitive\") == 0)\n                    {\n                      CloneString(&draw_info->primitive,value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"rotate\") == 0)\n                    {\n                      angle=StringToDouble(value,(char **) NULL);\n                      affine.sx=cos(DegreesToRadians(fmod(angle,360.0)));\n                      affine.rx=sin(DegreesToRadians(fmod(angle,360.0)));\n                      affine.ry=(-sin(DegreesToRadians(fmod(angle,360.0))));\n                      affine.sy=cos(DegreesToRadians(fmod(angle,360.0)));\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'S':\n                case 's':\n                {\n                  if (LocaleCompare(keyword,\"scale\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      affine.sx=geometry_info.rho;\n                      affine.sy=geometry_info.sigma;\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"skewX\") == 0)\n                    {\n                      angle=StringToDouble(value,(char **) NULL);\n                      affine.ry=cos(DegreesToRadians(fmod(angle,360.0)));\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"skewY\") == 0)\n                    {\n                      angle=StringToDouble(value,(char **) NULL);\n                      affine.rx=cos(DegreesToRadians(fmod(angle,360.0)));\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"stretch\") == 0)\n                    {\n                      option=ParseCommandOption(MagickStretchOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedStretchType\",\n                          value);\n                      draw_info->stretch=(StretchType) option;\n                      break;\n                    }\n                  if (LocaleCompare(keyword, \"stroke\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &draw_info->stroke,exception);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"strokewidth\") == 0)\n                    {\n                      draw_info->stroke_width=StringToLong(value);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"style\") == 0)\n                    {\n                      option=ParseCommandOption(MagickStyleOptions,MagickFalse,\n                        value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedStyleType\",\n                          value);\n                      draw_info->style=(StyleType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'T':\n                case 't':\n                {\n                  if (LocaleCompare(keyword,\"text\") == 0)\n                    {\n                      (void) ConcatenateString(&draw_info->primitive,\" '\");\n                      (void) ConcatenateString(&draw_info->primitive,value);\n                      (void) ConcatenateString(&draw_info->primitive,\"'\");\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"translate\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      affine.tx=geometry_info.rho;\n                      affine.ty=geometry_info.sigma;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'U':\n                case 'u':\n                {\n                  if (LocaleCompare(keyword, \"undercolor\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &draw_info->undercolor,exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"weight\") == 0)\n                    {\n                      draw_info->weight=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry.x=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry.y=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) FormatLocaleString(text,MagickPathExtent,\n            \"%.20gx%.20g%+.20g%+.20g\",(double) geometry.width,(double)\n            geometry.height,(double) geometry.x,(double) geometry.y);\n          CloneString(&draw_info->geometry,text);\n          draw_info->affine.sx=affine.sx*current.sx+affine.ry*current.rx;\n          draw_info->affine.rx=affine.rx*current.sx+affine.sy*current.rx;\n          draw_info->affine.ry=affine.sx*current.ry+affine.ry*current.sy;\n          draw_info->affine.sy=affine.rx*current.ry+affine.sy*current.sy;\n          draw_info->affine.tx=affine.sx*current.tx+affine.ry*current.ty+\n            affine.tx;\n          draw_info->affine.ty=affine.rx*current.tx+affine.sy*current.ty+\n            affine.ty;\n          (void) DrawImage(msl_info->image[n],draw_info,exception);\n          draw_info=DestroyDrawInfo(draw_info);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'E':\n    case 'e':\n    {\n      if (LocaleCompare((const char *) tag,\"edge\") == 0)\n        {\n          Image\n            *edge_image;\n\n          /*\n            Edge image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"radius\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,(char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          edge_image=EdgeImage(msl_info->image[n],geometry_info.rho,\n            msl_info->exception);\n          if (edge_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=edge_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"emboss\") == 0)\n        {\n          Image\n            *emboss_image;\n\n          /*\n            Emboss image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"radius\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'S':\n                case 's':\n                {\n                  if (LocaleCompare(keyword,\"sigma\") == 0)\n                    {\n                      geometry_info.sigma=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          emboss_image=EmbossImage(msl_info->image[n],geometry_info.rho,\n            geometry_info.sigma,msl_info->exception);\n          if (emboss_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=emboss_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"enhance\") == 0)\n        {\n          Image\n            *enhance_image;\n\n          /*\n            Enhance image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            }\n          enhance_image=EnhanceImage(msl_info->image[n],\n            msl_info->exception);\n          if (enhance_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=enhance_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"equalize\") == 0)\n        {\n          /*\n            Equalize image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) EqualizeImage(msl_info->image[n],\n            msl_info->exception);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleCompare((const char *) tag, \"flatten\") == 0)\n      {\n        if (msl_info->image[n] == (Image *) NULL)\n        {\n          ThrowMSLException(OptionError,\"NoImagesDefined\",\n            (const char *) tag);\n          break;\n        }\n\n        /* no attributes here */\n\n        /* process the image */\n        {\n          Image\n            *newImage;\n\n          newImage=MergeImageLayers(msl_info->image[n],FlattenLayer,\n            msl_info->exception);\n          if (newImage == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=newImage;\n          break;\n        }\n      }\n      if (LocaleCompare((const char *) tag,\"flip\") == 0)\n        {\n          Image\n            *flip_image;\n\n          /*\n            Flip image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            }\n          flip_image=FlipImage(msl_info->image[n],\n            msl_info->exception);\n          if (flip_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=flip_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"flop\") == 0)\n        {\n          Image\n            *flop_image;\n\n          /*\n            Flop image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            }\n          flop_image=FlopImage(msl_info->image[n],\n            msl_info->exception);\n          if (flop_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=flop_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"frame\") == 0)\n        {\n          FrameInfo\n            frame_info;\n\n          Image\n            *frame_image;\n\n          /*\n            Frame image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          (void) ResetMagickMemory(&frame_info,0,sizeof(frame_info));\n          SetGeometry(msl_info->image[n],&geometry);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"compose\") == 0)\n                    {\n                      option=ParseCommandOption(MagickComposeOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedComposeType\",\n                          value);\n                      msl_info->image[n]->compose=(CompositeOperator) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword, \"fill\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &msl_info->image[n]->matte_color,exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParsePageGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      if ((flags & HeightValue) == 0)\n                        geometry.height=geometry.width;\n                      frame_info.width=geometry.width;\n                      frame_info.height=geometry.height;\n                      frame_info.outer_bevel=geometry.x;\n                      frame_info.inner_bevel=geometry.y;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'H':\n                case 'h':\n                {\n                  if (LocaleCompare(keyword,\"height\") == 0)\n                    {\n                      frame_info.height=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'I':\n                case 'i':\n                {\n                  if (LocaleCompare(keyword,\"inner\") == 0)\n                    {\n                      frame_info.inner_bevel=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'O':\n                case 'o':\n                {\n                  if (LocaleCompare(keyword,\"outer\") == 0)\n                    {\n                      frame_info.outer_bevel=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"width\") == 0)\n                    {\n                      frame_info.width=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          frame_info.x=(ssize_t) frame_info.width;\n          frame_info.y=(ssize_t) frame_info.height;\n          frame_info.width=msl_info->image[n]->columns+2*frame_info.x;\n          frame_info.height=msl_info->image[n]->rows+2*frame_info.y;\n          frame_image=FrameImage(msl_info->image[n],&frame_info,\n            msl_info->image[n]->compose,msl_info->exception);\n          if (frame_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=frame_image;\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare((const char *) tag,\"gamma\") == 0)\n        {\n          char\n            gamma[MagickPathExtent];\n\n          PixelInfo\n            pixel;\n\n          /*\n            Gamma image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          channel=UndefinedChannel;\n          pixel.red=0.0;\n          pixel.green=0.0;\n          pixel.blue=0.0;\n          *gamma='\\0';\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'B':\n                case 'b':\n                {\n                  if (LocaleCompare(keyword,\"blue\") == 0)\n                    {\n                      pixel.blue=StringToDouble(value,(char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"channel\") == 0)\n                    {\n                      option=ParseChannelOption(value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedChannelType\",\n                          value);\n                      channel=(ChannelType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"gamma\") == 0)\n                    {\n                      (void) CopyMagickString(gamma,value,MagickPathExtent);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"green\") == 0)\n                    {\n                      pixel.green=StringToDouble(value,(char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"red\") == 0)\n                    {\n                      pixel.red=StringToDouble(value,(char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          if (*gamma == '\\0')\n            (void) FormatLocaleString(gamma,MagickPathExtent,\"%g,%g,%g\",\n              (double) pixel.red,(double) pixel.green,(double) pixel.blue);\n          (void) GammaImage(msl_info->image[n],strtod(gamma,(char **) NULL),\n            msl_info->exception);\n          break;\n        }\n      else if (LocaleCompare((const char *) tag,\"get\") == 0)\n        {\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes == (const xmlChar **) NULL)\n            break;\n          for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n          {\n            keyword=(const char *) attributes[i++];\n            CloneString(&value,(const char *) attributes[i]);\n            (void) CopyMagickString(key,value,MagickPathExtent);\n            switch (*keyword)\n            {\n              case 'H':\n              case 'h':\n              {\n                if (LocaleCompare(keyword,\"height\") == 0)\n                  {\n                    (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n                      (double) msl_info->image[n]->rows);\n                    (void) SetImageProperty(msl_info->attributes[n],key,value,\n                      exception);\n                    break;\n                  }\n                ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              }\n              case 'W':\n              case 'w':\n              {\n                if (LocaleCompare(keyword,\"width\") == 0)\n                  {\n                    (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n                      (double) msl_info->image[n]->columns);\n                    (void) SetImageProperty(msl_info->attributes[n],key,value,\n                      exception);\n                    break;\n                  }\n                ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              }\n              default:\n              {\n                ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n                break;\n              }\n            }\n          }\n          break;\n        }\n    else if (LocaleCompare((const char *) tag, \"group\") == 0)\n    {\n      msl_info->number_groups++;\n      msl_info->group_info=(MSLGroupInfo *) ResizeQuantumMemory(\n        msl_info->group_info,msl_info->number_groups+1UL,\n        sizeof(*msl_info->group_info));\n      break;\n    }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare((const char *) tag,\"image\") == 0)\n        {\n          MSLPushImage(msl_info,(Image *) NULL);\n          if (attributes == (const xmlChar **) NULL)\n            break;\n          for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n          {\n            keyword=(const char *) attributes[i++];\n            attribute=InterpretImageProperties(msl_info->image_info[n],\n              msl_info->attributes[n],(const char *) attributes[i],exception);\n            CloneString(&value,attribute);\n            attribute=DestroyString(attribute);\n            switch (*keyword)\n            {\n              case 'C':\n              case 'c':\n              {\n                if (LocaleCompare(keyword,\"color\") == 0)\n                  {\n                    Image\n                      *next_image;\n\n                    (void) CopyMagickString(msl_info->image_info[n]->filename,\n                      \"xc:\",MagickPathExtent);\n                    (void) ConcatenateMagickString(msl_info->image_info[n]->\n                      filename,value,MagickPathExtent);\n                    next_image=ReadImage(msl_info->image_info[n],exception);\n                    CatchException(exception);\n                    if (next_image == (Image *) NULL)\n                      continue;\n                    if (msl_info->image[n] == (Image *) NULL)\n                      msl_info->image[n]=next_image;\n                    else\n                      {\n                        register Image\n                          *p;\n\n                        /*\n                          Link image into image list.\n                        */\n                        p=msl_info->image[n];\n                        while (p->next != (Image *) NULL)\n                          p=GetNextImageInList(p);\n                        next_image->previous=p;\n                        p->next=next_image;\n                      }\n                    break;\n                  }\n                (void) SetMSLAttributes(msl_info,keyword,value);\n                break;\n              }\n              default:\n              {\n                (void) SetMSLAttributes(msl_info,keyword,value);\n                break;\n              }\n            }\n          }\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"implode\") == 0)\n        {\n          Image\n            *implode_image;\n\n          /*\n            Implode image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'A':\n                case 'a':\n                {\n                  if (LocaleCompare(keyword,\"amount\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          implode_image=ImplodeImage(msl_info->image[n],geometry_info.rho,\n            msl_info->image[n]->interpolate,msl_info->exception);\n          if (implode_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=implode_image;\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare((const char *) tag,\"label\") == 0)\n        break;\n      if (LocaleCompare((const char *) tag, \"level\") == 0)\n      {\n        double\n          levelBlack = 0, levelGamma = 1, levelWhite = QuantumRange;\n\n        if (msl_info->image[n] == (Image *) NULL)\n        {\n          ThrowMSLException(OptionError,\"NoImagesDefined\",\n            (const char *) tag);\n          break;\n        }\n        if (attributes == (const xmlChar **) NULL)\n          break;\n        for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n        {\n          keyword=(const char *) attributes[i++];\n          CloneString(&value,(const char *) attributes[i]);\n          (void) CopyMagickString(key,value,MagickPathExtent);\n          switch (*keyword)\n          {\n            case 'B':\n            case 'b':\n            {\n              if (LocaleCompare(keyword,\"black\") == 0)\n              {\n                levelBlack = StringToDouble(value,(char **) NULL);\n                break;\n              }\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n            case 'G':\n            case 'g':\n            {\n              if (LocaleCompare(keyword,\"gamma\") == 0)\n              {\n                levelGamma = StringToDouble(value,(char **) NULL);\n                break;\n              }\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n            case 'W':\n            case 'w':\n            {\n              if (LocaleCompare(keyword,\"white\") == 0)\n              {\n                levelWhite = StringToDouble(value,(char **) NULL);\n                break;\n              }\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n            default:\n            {\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n          }\n        }\n\n        /* process image */\n        LevelImage(msl_info->image[n],levelBlack,levelWhite,levelGamma,\n          msl_info->exception);\n        break;\n      }\n    }\n    case 'M':\n    case 'm':\n    {\n      if (LocaleCompare((const char *) tag,\"magnify\") == 0)\n        {\n          Image\n            *magnify_image;\n\n          /*\n            Magnify image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            }\n          magnify_image=MagnifyImage(msl_info->image[n],\n            msl_info->exception);\n          if (magnify_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=magnify_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"map\") == 0)\n        {\n          Image\n            *affinity_image;\n\n          MagickBooleanType\n            dither;\n\n          QuantizeInfo\n            *quantize_info;\n\n          /*\n            Map image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          affinity_image=NewImageList();\n          dither=MagickFalse;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'D':\n                case 'd':\n                {\n                  if (LocaleCompare(keyword,\"dither\") == 0)\n                    {\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedBooleanType\",\n                          value);\n                      dither=(MagickBooleanType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'I':\n                case 'i':\n                {\n                  if (LocaleCompare(keyword,\"image\") == 0)\n                    for (j=0; j < msl_info->n; j++)\n                    {\n                      const char\n                        *attribute;\n\n                      attribute=GetImageProperty(msl_info->attributes[j],\"id\",\n                        exception);\n                      if ((attribute != (const char *) NULL)  &&\n                          (LocaleCompare(attribute,value) == 0))\n                        {\n                          affinity_image=CloneImage(msl_info->image[j],0,0,\n                            MagickFalse,exception);\n                          break;\n                        }\n                    }\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          quantize_info=AcquireQuantizeInfo(msl_info->image_info[n]);\n          quantize_info->dither_method=dither != MagickFalse ?\n            RiemersmaDitherMethod : NoDitherMethod;\n          (void) RemapImages(quantize_info,msl_info->image[n],\n            affinity_image,exception);\n          quantize_info=DestroyQuantizeInfo(quantize_info);\n          affinity_image=DestroyImage(affinity_image);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"matte-floodfill\") == 0)\n        {\n          double\n            opacity;\n\n          PixelInfo\n            target;\n\n          PaintMethod\n            paint_method;\n\n          /*\n            Matte floodfill image.\n          */\n          opacity=0.0;\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          SetGeometry(msl_info->image[n],&geometry);\n          paint_method=FloodfillMethod;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'B':\n                case 'b':\n                {\n                  if (LocaleCompare(keyword,\"bordercolor\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &target,exception);\n                      paint_method=FillToBorderMethod;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword,\"fuzz\") == 0)\n                    {\n                      msl_info->image[n]->fuzz=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParsePageGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      if ((flags & HeightValue) == 0)\n                        geometry.height=geometry.width;\n                      (void) GetOneVirtualPixelInfo(msl_info->image[n],\n                        TileVirtualPixelMethod,geometry.x,geometry.y,&target,\n                        exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'O':\n                case 'o':\n                {\n                  if (LocaleCompare(keyword,\"opacity\") == 0)\n                    {\n                      opacity=StringToDouble(value,(char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry.x=StringToLong(value);\n                      (void) GetOneVirtualPixelInfo(msl_info->image[n],\n                        TileVirtualPixelMethod,geometry.x,geometry.y,&target,\n                        exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry.y=StringToLong(value);\n                      (void) GetOneVirtualPixelInfo(msl_info->image[n],\n                        TileVirtualPixelMethod,geometry.x,geometry.y,&target,\n                        exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          draw_info=CloneDrawInfo(msl_info->image_info[n],\n            msl_info->draw_info[n]);\n          draw_info->fill.alpha=ClampToQuantum(opacity);\n          channel_mask=SetImageChannelMask(msl_info->image[n],AlphaChannel);\n          (void) FloodfillPaintImage(msl_info->image[n],draw_info,&target,\n            geometry.x,geometry.y,paint_method == FloodfillMethod ?\n            MagickFalse : MagickTrue,msl_info->exception);\n          (void) SetPixelChannelMask(msl_info->image[n],channel_mask);\n          draw_info=DestroyDrawInfo(draw_info);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"median-filter\") == 0)\n        {\n          Image\n            *median_image;\n\n          /*\n            Median-filter image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"radius\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          median_image=StatisticImage(msl_info->image[n],MedianStatistic,\n            (size_t) geometry_info.rho,(size_t) geometry_info.sigma,\n            msl_info->exception);\n          if (median_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=median_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"minify\") == 0)\n        {\n          Image\n            *minify_image;\n\n          /*\n            Minify image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            }\n          minify_image=MinifyImage(msl_info->image[n],\n            msl_info->exception);\n          if (minify_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=minify_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"msl\") == 0 )\n        break;\n      if (LocaleCompare((const char *) tag,\"modulate\") == 0)\n        {\n          char\n            modulate[MagickPathExtent];\n\n          /*\n            Modulate image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          geometry_info.rho=100.0;\n          geometry_info.sigma=100.0;\n          geometry_info.xi=100.0;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'B':\n                case 'b':\n                {\n                  if (LocaleCompare(keyword,\"blackness\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"brightness\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword,\"factor\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'H':\n                case 'h':\n                {\n                  if (LocaleCompare(keyword,\"hue\") == 0)\n                    {\n                      geometry_info.xi=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'L':\n                case 'l':\n                {\n                  if (LocaleCompare(keyword,\"lightness\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'S':\n                case 's':\n                {\n                  if (LocaleCompare(keyword,\"saturation\") == 0)\n                    {\n                      geometry_info.sigma=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"whiteness\") == 0)\n                    {\n                      geometry_info.sigma=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) FormatLocaleString(modulate,MagickPathExtent,\"%g,%g,%g\",\n            geometry_info.rho,geometry_info.sigma,geometry_info.xi);\n          (void) ModulateImage(msl_info->image[n],modulate,\n            msl_info->exception);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'N':\n    case 'n':\n    {\n      if (LocaleCompare((const char *) tag,\"negate\") == 0)\n        {\n          MagickBooleanType\n            gray;\n\n          /*\n            Negate image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          gray=MagickFalse;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"channel\") == 0)\n                    {\n                      option=ParseChannelOption(value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedChannelType\",\n                          value);\n                      channel=(ChannelType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"gray\") == 0)\n                    {\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedBooleanType\",\n                          value);\n                      gray=(MagickBooleanType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          channel_mask=SetImageChannelMask(msl_info->image[n],channel);\n          (void) NegateImage(msl_info->image[n],gray,\n            msl_info->exception);\n          (void) SetPixelChannelMask(msl_info->image[n],channel_mask);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"normalize\") == 0)\n        {\n          /*\n            Normalize image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"channel\") == 0)\n                    {\n                      option=ParseChannelOption(value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedChannelType\",\n                          value);\n                      channel=(ChannelType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) NormalizeImage(msl_info->image[n],\n            msl_info->exception);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'O':\n    case 'o':\n    {\n      if (LocaleCompare((const char *) tag,\"oil-paint\") == 0)\n        {\n          Image\n            *paint_image;\n\n          /*\n            Oil-paint image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"radius\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          paint_image=OilPaintImage(msl_info->image[n],geometry_info.rho,\n            geometry_info.sigma,msl_info->exception);\n          if (paint_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=paint_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"opaque\") == 0)\n        {\n          PixelInfo\n            fill_color,\n            target;\n\n          /*\n            Opaque image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          (void) QueryColorCompliance(\"none\",AllCompliance,&target,\n            exception);\n          (void) QueryColorCompliance(\"none\",AllCompliance,&fill_color,\n            exception);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"channel\") == 0)\n                    {\n                      option=ParseChannelOption(value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedChannelType\",\n                          value);\n                      channel=(ChannelType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword,\"fill\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &fill_color,exception);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"fuzz\") == 0)\n                    {\n                      msl_info->image[n]->fuzz=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          channel_mask=SetImageChannelMask(msl_info->image[n],channel);\n          (void) OpaquePaintImage(msl_info->image[n],&target,&fill_color,\n            MagickFalse,msl_info->exception);\n          (void) SetPixelChannelMask(msl_info->image[n],channel_mask);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare((const char *) tag,\"print\") == 0)\n        {\n          if (attributes == (const xmlChar **) NULL)\n            break;\n          for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n          {\n            keyword=(const char *) attributes[i++];\n            attribute=InterpretImageProperties(msl_info->image_info[n],\n              msl_info->attributes[n],(const char *) attributes[i],\n              exception);\n            CloneString(&value,attribute);\n            attribute=DestroyString(attribute);\n            switch (*keyword)\n            {\n              case 'O':\n              case 'o':\n              {\n                if (LocaleCompare(keyword,\"output\") == 0)\n                  {\n                    (void) FormatLocaleFile(stdout,\"%s\",value);\n                    break;\n                  }\n                ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n                break;\n              }\n              default:\n              {\n                ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n                break;\n              }\n            }\n          }\n          break;\n        }\n        if (LocaleCompare((const char *) tag, \"profile\") == 0)\n          {\n            if (msl_info->image[n] == (Image *) NULL)\n              {\n                ThrowMSLException(OptionError,\"NoImagesDefined\",\n                  (const char *) tag);\n                break;\n              }\n            if (attributes == (const xmlChar **) NULL)\n              break;\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              const char\n                *name;\n\n              const StringInfo\n                *profile;\n\n              Image\n                *profile_image;\n\n              ImageInfo\n                *profile_info;\n\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              if (*keyword == '!')\n                {\n                  /*\n                    Remove a profile from the image.\n                  */\n                  (void) ProfileImage(msl_info->image[n],keyword,\n                    (const unsigned char *) NULL,0,exception);\n                  continue;\n                }\n              /*\n                Associate a profile with the image.\n              */\n              profile_info=CloneImageInfo(msl_info->image_info[n]);\n              profile=GetImageProfile(msl_info->image[n],\"iptc\");\n              if (profile != (StringInfo *) NULL)\n                profile_info->profile=(void *) CloneStringInfo(profile);\n              profile_image=GetImageCache(profile_info,keyword,exception);\n              profile_info=DestroyImageInfo(profile_info);\n              if (profile_image == (Image *) NULL)\n                {\n                  char\n                    name[MagickPathExtent],\n                    filename[MagickPathExtent];\n\n                  register char\n                    *p;\n\n                  StringInfo\n                    *profile;\n\n                  (void) CopyMagickString(filename,keyword,MagickPathExtent);\n                  (void) CopyMagickString(name,keyword,MagickPathExtent);\n                  for (p=filename; *p != '\\0'; p++)\n                    if ((*p == ':') && (IsPathDirectory(keyword) < 0) &&\n                        (IsPathAccessible(keyword) == MagickFalse))\n                      {\n                        register char\n                          *q;\n\n                        /*\n                          Look for profile name (e.g. name:profile).\n                        */\n                        (void) CopyMagickString(name,filename,(size_t)\n                          (p-filename+1));\n                        for (q=filename; *q != '\\0'; q++)\n                          *q=(*++p);\n                        break;\n                      }\n                  profile=FileToStringInfo(filename,~0UL,exception);\n                  if (profile != (StringInfo *) NULL)\n                    {\n                      (void) ProfileImage(msl_info->image[n],name,\n                        GetStringInfoDatum(profile),(size_t)\n                        GetStringInfoLength(profile),exception);\n                      profile=DestroyStringInfo(profile);\n                    }\n                  continue;\n                }\n              ResetImageProfileIterator(profile_image);\n              name=GetNextImageProfile(profile_image);\n              while (name != (const char *) NULL)\n              {\n                profile=GetImageProfile(profile_image,name);\n                if (profile != (StringInfo *) NULL)\n                  (void) ProfileImage(msl_info->image[n],name,\n                    GetStringInfoDatum(profile),(size_t)\n                    GetStringInfoLength(profile),exception);\n                name=GetNextImageProfile(profile_image);\n              }\n              profile_image=DestroyImage(profile_image);\n            }\n            break;\n          }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'Q':\n    case 'q':\n    {\n      if (LocaleCompare((const char *) tag,\"quantize\") == 0)\n        {\n          QuantizeInfo\n            quantize_info;\n\n          /*\n            Quantize image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          GetQuantizeInfo(&quantize_info);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"colors\") == 0)\n                    {\n                      quantize_info.number_colors=StringToLong(value);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"colorspace\") == 0)\n                    {\n                      option=ParseCommandOption(MagickColorspaceOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\n                          \"UnrecognizedColorspaceType\",value);\n                      quantize_info.colorspace=(ColorspaceType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'D':\n                case 'd':\n                {\n                  if (LocaleCompare(keyword,\"dither\") == 0)\n                    {\n                      option=ParseCommandOption(MagickDitherOptions,MagickFalse,\n                        value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedBooleanType\",\n                          value);\n                      quantize_info.dither_method=(DitherMethod) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'M':\n                case 'm':\n                {\n                  if (LocaleCompare(keyword,\"measure\") == 0)\n                    {\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedBooleanType\",\n                          value);\n                      quantize_info.measure_error=(MagickBooleanType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'T':\n                case 't':\n                {\n                  if (LocaleCompare(keyword,\"treedepth\") == 0)\n                    {\n                      quantize_info.tree_depth=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) QuantizeImage(&quantize_info,msl_info->image[n],exception);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"query-font-metrics\") == 0)\n        {\n          char\n            text[MagickPathExtent];\n\n          MagickBooleanType\n            status;\n\n          TypeMetric\n            metrics;\n\n          /*\n            Query font metrics.\n          */\n          draw_info=CloneDrawInfo(msl_info->image_info[n],\n            msl_info->draw_info[n]);\n          angle=0.0;\n          current=draw_info->affine;\n          GetAffineMatrix(&affine);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'A':\n                case 'a':\n                {\n                  if (LocaleCompare(keyword,\"affine\") == 0)\n                    {\n                      char\n                        *p;\n\n                      p=value;\n                      draw_info->affine.sx=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.rx=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.ry=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.sy=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.tx=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.ty=StringToDouble(p,&p);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"align\") == 0)\n                    {\n                      option=ParseCommandOption(MagickAlignOptions,MagickFalse,\n                        value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedAlignType\",\n                          value);\n                      draw_info->align=(AlignType) option;\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"antialias\") == 0)\n                    {\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedBooleanType\",\n                          value);\n                      draw_info->stroke_antialias=(MagickBooleanType) option;\n                      draw_info->text_antialias=(MagickBooleanType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'D':\n                case 'd':\n                {\n                  if (LocaleCompare(keyword,\"density\") == 0)\n                    {\n                      CloneString(&draw_info->density,value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'E':\n                case 'e':\n                {\n                  if (LocaleCompare(keyword,\"encoding\") == 0)\n                    {\n                      CloneString(&draw_info->encoding,value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword, \"fill\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &draw_info->fill,exception);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"family\") == 0)\n                    {\n                      CloneString(&draw_info->family,value);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"font\") == 0)\n                    {\n                      CloneString(&draw_info->font,value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParsePageGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      if ((flags & HeightValue) == 0)\n                        geometry.height=geometry.width;\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"gravity\") == 0)\n                    {\n                      option=ParseCommandOption(MagickGravityOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedGravityType\",\n                          value);\n                      draw_info->gravity=(GravityType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'P':\n                case 'p':\n                {\n                  if (LocaleCompare(keyword,\"pointsize\") == 0)\n                    {\n                      draw_info->pointsize=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"rotate\") == 0)\n                    {\n                      angle=StringToDouble(value,(char **) NULL);\n                      affine.sx=cos(DegreesToRadians(fmod(angle,360.0)));\n                      affine.rx=sin(DegreesToRadians(fmod(angle,360.0)));\n                      affine.ry=(-sin(DegreesToRadians(fmod(angle,360.0))));\n                      affine.sy=cos(DegreesToRadians(fmod(angle,360.0)));\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'S':\n                case 's':\n                {\n                  if (LocaleCompare(keyword,\"scale\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      affine.sx=geometry_info.rho;\n                      affine.sy=geometry_info.sigma;\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"skewX\") == 0)\n                    {\n                      angle=StringToDouble(value,(char **) NULL);\n                      affine.ry=cos(DegreesToRadians(fmod(angle,360.0)));\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"skewY\") == 0)\n                    {\n                      angle=StringToDouble(value,(char **) NULL);\n                      affine.rx=cos(DegreesToRadians(fmod(angle,360.0)));\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"stretch\") == 0)\n                    {\n                      option=ParseCommandOption(MagickStretchOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedStretchType\",\n                          value);\n                      draw_info->stretch=(StretchType) option;\n                      break;\n                    }\n                  if (LocaleCompare(keyword, \"stroke\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &draw_info->stroke,exception);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"strokewidth\") == 0)\n                    {\n                      draw_info->stroke_width=StringToLong(value);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"style\") == 0)\n                    {\n                      option=ParseCommandOption(MagickStyleOptions,MagickFalse,\n                        value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedStyleType\",\n                          value);\n                      draw_info->style=(StyleType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'T':\n                case 't':\n                {\n                  if (LocaleCompare(keyword,\"text\") == 0)\n                    {\n                      CloneString(&draw_info->text,value);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"translate\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      affine.tx=geometry_info.rho;\n                      affine.ty=geometry_info.sigma;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'U':\n                case 'u':\n                {\n                  if (LocaleCompare(keyword, \"undercolor\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &draw_info->undercolor,exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"weight\") == 0)\n                    {\n                      draw_info->weight=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry.x=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry.y=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) FormatLocaleString(text,MagickPathExtent,\n            \"%.20gx%.20g%+.20g%+.20g\",(double) geometry.width,(double)\n            geometry.height,(double) geometry.x,(double) geometry.y);\n          CloneString(&draw_info->geometry,text);\n          draw_info->affine.sx=affine.sx*current.sx+affine.ry*current.rx;\n          draw_info->affine.rx=affine.rx*current.sx+affine.sy*current.rx;\n          draw_info->affine.ry=affine.sx*current.ry+affine.ry*current.sy;\n          draw_info->affine.sy=affine.rx*current.ry+affine.sy*current.sy;\n          draw_info->affine.tx=affine.sx*current.tx+affine.ry*current.ty+\n            affine.tx;\n          draw_info->affine.ty=affine.rx*current.tx+affine.sy*current.ty+\n            affine.ty;\n          status=GetTypeMetrics(msl_info->attributes[n],draw_info,&metrics,\n            msl_info->exception);\n          if (status != MagickFalse)\n            {\n              Image\n                *image;\n\n              image=msl_info->attributes[n];\n              FormatImageProperty(image,\"msl:font-metrics.pixels_per_em.x\",\n                \"%g\",metrics.pixels_per_em.x);\n              FormatImageProperty(image,\"msl:font-metrics.pixels_per_em.y\",\n                \"%g\",metrics.pixels_per_em.y);\n              FormatImageProperty(image,\"msl:font-metrics.ascent\",\"%g\",\n                metrics.ascent);\n              FormatImageProperty(image,\"msl:font-metrics.descent\",\"%g\",\n                metrics.descent);\n              FormatImageProperty(image,\"msl:font-metrics.width\",\"%g\",\n                metrics.width);\n              FormatImageProperty(image,\"msl:font-metrics.height\",\"%g\",\n                metrics.height);\n              FormatImageProperty(image,\"msl:font-metrics.max_advance\",\"%g\",\n                metrics.max_advance);\n              FormatImageProperty(image,\"msl:font-metrics.bounds.x1\",\"%g\",\n                metrics.bounds.x1);\n              FormatImageProperty(image,\"msl:font-metrics.bounds.y1\",\"%g\",\n                metrics.bounds.y1);\n              FormatImageProperty(image,\"msl:font-metrics.bounds.x2\",\"%g\",\n                metrics.bounds.x2);\n              FormatImageProperty(image,\"msl:font-metrics.bounds.y2\",\"%g\",\n                metrics.bounds.y2);\n              FormatImageProperty(image,\"msl:font-metrics.origin.x\",\"%g\",\n                metrics.origin.x);\n              FormatImageProperty(image,\"msl:font-metrics.origin.y\",\"%g\",\n                metrics.origin.y);\n            }\n          draw_info=DestroyDrawInfo(draw_info);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleCompare((const char *) tag,\"raise\") == 0)\n        {\n          MagickBooleanType\n            raise;\n\n          /*\n            Raise image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          raise=MagickFalse;\n          SetGeometry(msl_info->image[n],&geometry);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParsePageGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      if ((flags & HeightValue) == 0)\n                        geometry.height=geometry.width;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'H':\n                case 'h':\n                {\n                  if (LocaleCompare(keyword,\"height\") == 0)\n                    {\n                      geometry.height=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"raise\") == 0)\n                    {\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedNoiseType\",\n                          value);\n                      raise=(MagickBooleanType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"width\") == 0)\n                    {\n                      geometry.width=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) RaiseImage(msl_info->image[n],&geometry,raise,\n            msl_info->exception);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"read\") == 0)\n        {\n          if (attributes == (const xmlChar **) NULL)\n            break;\n          for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n          {\n            keyword=(const char *) attributes[i++];\n            attribute=InterpretImageProperties(msl_info->image_info[n],\n              msl_info->attributes[n],(const char *) attributes[i],exception);\n            CloneString(&value,attribute);\n            attribute=DestroyString(attribute);\n            switch (*keyword)\n            {\n              case 'F':\n              case 'f':\n              {\n                if (LocaleCompare(keyword,\"filename\") == 0)\n                  {\n                    Image\n                      *image;\n\n                    if (value == (char *) NULL)\n                      break;\n                    (void) CopyMagickString(msl_info->image_info[n]->filename,\n                      value,MagickPathExtent);\n                    image=ReadImage(msl_info->image_info[n],exception);\n                    CatchException(exception);\n                    if (image == (Image *) NULL)\n                      continue;\n                    AppendImageToList(&msl_info->image[n],image);\n                    break;\n                  }\n                (void) SetMSLAttributes(msl_info,keyword,value);\n                break;\n              }\n              default:\n              {\n                (void) SetMSLAttributes(msl_info,keyword,value);\n                break;\n              }\n            }\n          }\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"reduce-noise\") == 0)\n        {\n          Image\n            *paint_image;\n\n          /*\n            Reduce-noise image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"radius\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          paint_image=StatisticImage(msl_info->image[n],NonpeakStatistic,\n            (size_t) geometry_info.rho,(size_t) geometry_info.sigma,\n            msl_info->exception);\n          if (paint_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=paint_image;\n          break;\n        }\n      else if (LocaleCompare((const char *) tag,\"repage\") == 0)\n      {\n        /* init the values */\n        width=msl_info->image[n]->page.width;\n        height=msl_info->image[n]->page.height;\n        x=msl_info->image[n]->page.x;\n        y=msl_info->image[n]->page.y;\n\n        if (msl_info->image[n] == (Image *) NULL)\n        {\n          ThrowMSLException(OptionError,\"NoImagesDefined\",\n            (const char *) tag);\n          break;\n        }\n        if (attributes == (const xmlChar **) NULL)\n        break;\n        for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n        {\n          keyword=(const char *) attributes[i++];\n          attribute=InterpretImageProperties(msl_info->image_info[n],\n            msl_info->attributes[n],(const char *) attributes[i],exception);\n          CloneString(&value,attribute);\n          attribute=DestroyString(attribute);\n        switch (*keyword)\n        {\n          case 'G':\n          case 'g':\n          {\n          if (LocaleCompare(keyword,\"geometry\") == 0)\n            {\n              int\n                flags;\n\n              RectangleInfo\n                geometry;\n\n            flags=ParseAbsoluteGeometry(value,&geometry);\n            if ((flags & WidthValue) != 0)\n              {\n                if ((flags & HeightValue) == 0)\n                  geometry.height=geometry.width;\n                width=geometry.width;\n                height=geometry.height;\n              }\n            if ((flags & AspectValue) != 0)\n              {\n                if ((flags & XValue) != 0)\n                  x+=geometry.x;\n                if ((flags & YValue) != 0)\n                  y+=geometry.y;\n              }\n            else\n              {\n                if ((flags & XValue) != 0)\n                  {\n                    x=geometry.x;\n                    if ((width == 0) && (geometry.x > 0))\n                      width=msl_info->image[n]->columns+geometry.x;\n                  }\n                if ((flags & YValue) != 0)\n                  {\n                    y=geometry.y;\n                    if ((height == 0) && (geometry.y > 0))\n                      height=msl_info->image[n]->rows+geometry.y;\n                  }\n              }\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          case 'H':\n          case 'h':\n          {\n          if (LocaleCompare(keyword,\"height\") == 0)\n            {\n            height = StringToLong( value );\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          case 'W':\n          case 'w':\n          {\n          if (LocaleCompare(keyword,\"width\") == 0)\n            {\n            width = StringToLong( value );\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          case 'X':\n          case 'x':\n          {\n          if (LocaleCompare(keyword,\"x\") == 0)\n            {\n            x = StringToLong( value );\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          case 'Y':\n          case 'y':\n          {\n          if (LocaleCompare(keyword,\"y\") == 0)\n            {\n            y = StringToLong( value );\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          default:\n          {\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n        }\n        }\n\n         msl_info->image[n]->page.width=width;\n         msl_info->image[n]->page.height=height;\n         msl_info->image[n]->page.x=x;\n         msl_info->image[n]->page.y=y;\n        break;\n      }\n    else if (LocaleCompare((const char *) tag,\"resample\") == 0)\n    {\n      double\n        x_resolution,\n        y_resolution;\n\n      if (msl_info->image[n] == (Image *) NULL)\n        {\n          ThrowMSLException(OptionError,\"NoImagesDefined\",\n            (const char *) tag);\n          break;\n        }\n      if (attributes == (const xmlChar **) NULL)\n        break;\n      x_resolution=DefaultResolution;\n      y_resolution=DefaultResolution;\n      for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n      {\n        keyword=(const char *) attributes[i++];\n        attribute=InterpretImageProperties(msl_info->image_info[n],\n          msl_info->attributes[n],(const char *) attributes[i],exception);\n        CloneString(&value,attribute);\n        attribute=DestroyString(attribute);\n        switch (*keyword)\n        {\n          case 'G':\n          case 'g':\n          {\n            if (LocaleCompare(keyword,\"geometry\") == 0)\n              {\n                ssize_t\n                  flags;\n\n                flags=ParseGeometry(value,&geometry_info);\n                if ((flags & SigmaValue) == 0)\n                  geometry_info.sigma*=geometry_info.rho;\n                x_resolution=geometry_info.rho;\n                y_resolution=geometry_info.sigma;\n                break;\n              }\n            ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            break;\n          }\n          case 'X':\n          case 'x':\n          {\n            if (LocaleCompare(keyword,\"x-resolution\") == 0)\n              {\n                x_resolution=StringToDouble(value,(char **) NULL);\n                break;\n              }\n            ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            break;\n          }\n          case 'Y':\n          case 'y':\n          {\n            if (LocaleCompare(keyword,\"y-resolution\") == 0)\n              {\n                y_resolution=StringToDouble(value,(char **) NULL);\n                break;\n              }\n            ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            break;\n          }\n          default:\n          {\n            ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            break;\n          }\n        }\n      }\n      /*\n        Resample image.\n      */\n      {\n        double\n          factor;\n\n        Image\n          *resample_image;\n\n        factor=1.0;\n        if (msl_info->image[n]->units == PixelsPerCentimeterResolution)\n          factor=2.54;\n        width=(size_t) (x_resolution*msl_info->image[n]->columns/\n          (factor*(msl_info->image[n]->resolution.x == 0.0 ? DefaultResolution :\n          msl_info->image[n]->resolution.x))+0.5);\n        height=(size_t) (y_resolution*msl_info->image[n]->rows/\n          (factor*(msl_info->image[n]->resolution.y == 0.0 ? DefaultResolution :\n          msl_info->image[n]->resolution.y))+0.5);\n        resample_image=ResizeImage(msl_info->image[n],width,height,\n          msl_info->image[n]->filter,msl_info->exception);\n        if (resample_image == (Image *) NULL)\n          break;\n        msl_info->image[n]=DestroyImage(msl_info->image[n]);\n        msl_info->image[n]=resample_image;\n      }\n      break;\n    }\n      if (LocaleCompare((const char *) tag,\"resize\") == 0)\n        {\n          FilterType\n            filter;\n\n          Image\n            *resize_image;\n\n          /*\n            Resize image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          filter=UndefinedFilter;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword,\"filter\") == 0)\n                    {\n                      option=ParseCommandOption(MagickFilterOptions,MagickFalse,\n                        value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedNoiseType\",\n                          value);\n                      filter=(FilterType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseRegionGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'H':\n                case 'h':\n                {\n                  if (LocaleCompare(keyword,\"height\") == 0)\n                    {\n                      geometry.height=StringToUnsignedLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"width\") == 0)\n                    {\n                      geometry.width=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          resize_image=ResizeImage(msl_info->image[n],geometry.width,\n            geometry.height,filter,msl_info->exception);\n          if (resize_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=resize_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"roll\") == 0)\n        {\n          Image\n            *roll_image;\n\n          /*\n            Roll image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          SetGeometry(msl_info->image[n],&geometry);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParsePageGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      if ((flags & HeightValue) == 0)\n                        geometry.height=geometry.width;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry.x=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry.y=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          roll_image=RollImage(msl_info->image[n],geometry.x,geometry.y,\n            msl_info->exception);\n          if (roll_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=roll_image;\n          break;\n        }\n      else if (LocaleCompare((const char *) tag,\"roll\") == 0)\n      {\n        /* init the values */\n        width=msl_info->image[n]->columns;\n        height=msl_info->image[n]->rows;\n        x = y = 0;\n\n        if (msl_info->image[n] == (Image *) NULL)\n        {\n          ThrowMSLException(OptionError,\"NoImagesDefined\",\n            (const char *) tag);\n          break;\n        }\n        if (attributes == (const xmlChar **) NULL)\n        break;\n        for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n        {\n          keyword=(const char *) attributes[i++];\n          attribute=InterpretImageProperties(msl_info->image_info[n],\n            msl_info->attributes[n],(const char *) attributes[i],exception);\n          CloneString(&value,attribute);\n          attribute=DestroyString(attribute);\n        switch (*keyword)\n        {\n          case 'G':\n          case 'g':\n          {\n          if (LocaleCompare(keyword,\"geometry\") == 0)\n            {\n            (void) ParseMetaGeometry(value,&x,&y,&width,&height);\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          case 'X':\n          case 'x':\n          {\n          if (LocaleCompare(keyword,\"x\") == 0)\n            {\n            x = StringToLong( value );\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          case 'Y':\n          case 'y':\n          {\n          if (LocaleCompare(keyword,\"y\") == 0)\n            {\n            y = StringToLong( value );\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          default:\n          {\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n        }\n        }\n\n        /*\n          process image.\n        */\n        {\n        Image\n          *newImage;\n\n        newImage=RollImage(msl_info->image[n], x, y, msl_info->exception);\n        if (newImage == (Image *) NULL)\n          break;\n        msl_info->image[n]=DestroyImage(msl_info->image[n]);\n        msl_info->image[n]=newImage;\n        }\n\n        break;\n      }\n      if (LocaleCompare((const char *) tag,\"rotate\") == 0)\n        {\n          Image\n            *rotate_image;\n\n          /*\n            Rotate image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'D':\n                case 'd':\n                {\n                  if (LocaleCompare(keyword,\"degrees\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          rotate_image=RotateImage(msl_info->image[n],geometry_info.rho,\n            msl_info->exception);\n          if (rotate_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=rotate_image;\n          break;\n        }\n      else if (LocaleCompare((const char *) tag,\"rotate\") == 0)\n      {\n        /* init the values */\n        double  degrees = 0;\n\n        if (msl_info->image[n] == (Image *) NULL)\n        {\n          ThrowMSLException(OptionError,\"NoImagesDefined\",\n            (const char *) tag);\n          break;\n        }\n        if (attributes == (const xmlChar **) NULL)\n          break;\n        for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n        {\n          keyword=(const char *) attributes[i++];\n          attribute=InterpretImageProperties(msl_info->image_info[n],\n            msl_info->attributes[n],(const char *) attributes[i],exception);\n          CloneString(&value,attribute);\n          attribute=DestroyString(attribute);\n        switch (*keyword)\n        {\n          case 'D':\n          case 'd':\n          {\n          if (LocaleCompare(keyword,\"degrees\") == 0)\n            {\n            degrees = StringToDouble(value,(char **) NULL);\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          default:\n          {\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n        }\n        }\n\n        /*\n          process image.\n        */\n        {\n        Image\n          *newImage;\n\n        newImage=RotateImage(msl_info->image[n], degrees, msl_info->exception);\n        if (newImage == (Image *) NULL)\n          break;\n        msl_info->image[n]=DestroyImage(msl_info->image[n]);\n        msl_info->image[n]=newImage;\n        }\n\n        break;\n      }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'S':\n    case 's':\n    {\n      if (LocaleCompare((const char *) tag,\"sample\") == 0)\n        {\n          Image\n            *sample_image;\n\n          /*\n            Sample image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseRegionGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'H':\n                case 'h':\n                {\n                  if (LocaleCompare(keyword,\"height\") == 0)\n                    {\n                      geometry.height=StringToUnsignedLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"width\") == 0)\n                    {\n                      geometry.width=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          sample_image=SampleImage(msl_info->image[n],geometry.width,\n            geometry.height,msl_info->exception);\n          if (sample_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=sample_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"scale\") == 0)\n        {\n          Image\n            *scale_image;\n\n          /*\n            Scale image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseRegionGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'H':\n                case 'h':\n                {\n                  if (LocaleCompare(keyword,\"height\") == 0)\n                    {\n                      geometry.height=StringToUnsignedLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"width\") == 0)\n                    {\n                      geometry.width=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          scale_image=ScaleImage(msl_info->image[n],geometry.width,\n            geometry.height,msl_info->exception);\n          if (scale_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=scale_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"segment\") == 0)\n        {\n          ColorspaceType\n            colorspace;\n\n          MagickBooleanType\n            verbose;\n\n          /*\n            Segment image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          geometry_info.rho=1.0;\n          geometry_info.sigma=1.5;\n          colorspace=sRGBColorspace;\n          verbose=MagickFalse;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"cluster-threshold\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"colorspace\") == 0)\n                    {\n                      option=ParseCommandOption(MagickColorspaceOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\n                          \"UnrecognizedColorspaceType\",value);\n                      colorspace=(ColorspaceType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.5;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'S':\n                case 's':\n                {\n                  if (LocaleCompare(keyword,\"smoothing-threshold\") == 0)\n                    {\n                      geometry_info.sigma=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) SegmentImage(msl_info->image[n],colorspace,verbose,\n            geometry_info.rho,geometry_info.sigma,exception);\n          break;\n        }\n      else if (LocaleCompare((const char *) tag, \"set\") == 0)\n      {\n        if (msl_info->image[n] == (Image *) NULL)\n        {\n          ThrowMSLException(OptionError,\"NoImagesDefined\",(const char *) tag);\n          break;\n        }\n\n        if (attributes == (const xmlChar **) NULL)\n          break;\n        for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n        {\n          keyword=(const char *) attributes[i++];\n          attribute=InterpretImageProperties(msl_info->image_info[n],\n            msl_info->attributes[n],(const char *) attributes[i],exception);\n          CloneString(&value,attribute);\n          attribute=DestroyString(attribute);\n          switch (*keyword)\n          {\n            case 'C':\n            case 'c':\n            {\n              if (LocaleCompare(keyword,\"clip-mask\") == 0)\n                {\n                  for (j=0; j < msl_info->n; j++)\n                  {\n                    const char\n                      *property;\n\n                    property=GetImageProperty(msl_info->attributes[j],\"id\",\n                      exception);\n                    if (LocaleCompare(property,value) == 0)\n                      {\n                        SetImageMask(msl_info->image[n],ReadPixelMask,\n                          msl_info->image[j],exception);\n                        break;\n                      }\n                  }\n                  break;\n                }\n              if (LocaleCompare(keyword,\"clip-path\") == 0)\n                {\n                  for (j=0; j < msl_info->n; j++)\n                  {\n                    const char\n                      *property;\n\n                    property=GetImageProperty(msl_info->attributes[j],\"id\",\n                      exception);\n                    if (LocaleCompare(property,value) == 0)\n                      {\n                        SetImageMask(msl_info->image[n],ReadPixelMask,\n                          msl_info->image[j],exception);\n                        break;\n                      }\n                  }\n                  break;\n                }\n              if (LocaleCompare(keyword,\"colorspace\") == 0)\n                {\n                  ssize_t\n                    colorspace;\n\n                  colorspace=(ColorspaceType) ParseCommandOption(\n                    MagickColorspaceOptions,MagickFalse,value);\n                  if (colorspace < 0)\n                    ThrowMSLException(OptionError,\"UnrecognizedColorspace\",\n                      value);\n                  (void) TransformImageColorspace(msl_info->image[n],\n                    (ColorspaceType) colorspace,exception);\n                  break;\n                }\n              (void) SetMSLAttributes(msl_info,keyword,value);\n              (void) SetImageProperty(msl_info->image[n],keyword,value,\n                exception);\n              break;\n            }\n            case 'D':\n            case 'd':\n            {\n              if (LocaleCompare(keyword,\"density\") == 0)\n                {\n                  flags=ParseGeometry(value,&geometry_info);\n                  msl_info->image[n]->resolution.x=geometry_info.rho;\n                  msl_info->image[n]->resolution.y=geometry_info.sigma;\n                  if ((flags & SigmaValue) == 0)\n                    msl_info->image[n]->resolution.y=\n                      msl_info->image[n]->resolution.x;\n                  break;\n                }\n              (void) SetMSLAttributes(msl_info,keyword,value);\n              (void) SetImageProperty(msl_info->image[n],keyword,value,\n                exception);\n              break;\n            }\n            case 'O':\n            case 'o':\n            {\n              if (LocaleCompare(keyword, \"opacity\") == 0)\n                {\n                  ssize_t  opac = OpaqueAlpha,\n                  len = (ssize_t) strlen( value );\n\n                  if (value[len-1] == '%') {\n                    char  tmp[100];\n                    (void) CopyMagickString(tmp,value,len);\n                    opac = StringToLong( tmp );\n                    opac = (int)(QuantumRange * ((float)opac/100));\n                  } else\n                    opac = StringToLong( value );\n                  (void) SetImageAlpha( msl_info->image[n], (Quantum) opac,\n                    exception);\n                  break;\n              }\n              (void) SetMSLAttributes(msl_info,keyword,value);\n              (void) SetImageProperty(msl_info->image[n],keyword,value,\n                msl_info->exception);\n              break;\n            }\n            case 'P':\n            case 'p':\n            {\n              if (LocaleCompare(keyword, \"page\") == 0)\n              {\n                char\n                  page[MagickPathExtent];\n\n                const char\n                  *image_option;\n\n                MagickStatusType\n                  flags;\n\n                RectangleInfo\n                  geometry;\n\n                (void) ResetMagickMemory(&geometry,0,sizeof(geometry));\n                image_option=GetImageArtifact(msl_info->image[n],\"page\");\n                if (image_option != (const char *) NULL)\n                  flags=ParseAbsoluteGeometry(image_option,&geometry);\n                flags=ParseAbsoluteGeometry(value,&geometry);\n                (void) FormatLocaleString(page,MagickPathExtent,\"%.20gx%.20g\",\n                  (double) geometry.width,(double) geometry.height);\n                if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n                  (void) FormatLocaleString(page,MagickPathExtent,\n                    \"%.20gx%.20g%+.20g%+.20g\",(double) geometry.width,\n                    (double) geometry.height,(double) geometry.x,(double)\n                    geometry.y);\n                (void) SetImageOption(msl_info->image_info[n],keyword,page);\n                msl_info->image_info[n]->page=GetPageGeometry(page);\n                break;\n              }\n              (void) SetMSLAttributes(msl_info,keyword,value);\n              (void) SetImageProperty(msl_info->image[n],keyword,value,\n                msl_info->exception);\n              break;\n            }\n            default:\n            {\n              (void) SetMSLAttributes(msl_info,keyword,value);\n              (void) SetImageProperty(msl_info->image[n],keyword,value,\n                msl_info->exception);\n              break;\n            }\n          }\n        }\n        break;\n      }\n      if (LocaleCompare((const char *) tag,\"shade\") == 0)\n        {\n          Image\n            *shade_image;\n\n          MagickBooleanType\n            gray;\n\n          /*\n            Shade image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          gray=MagickFalse;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'A':\n                case 'a':\n                {\n                  if (LocaleCompare(keyword,\"azimuth\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'E':\n                case 'e':\n                {\n                  if (LocaleCompare(keyword,\"elevation\") == 0)\n                    {\n                      geometry_info.sigma=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"gray\") == 0)\n                    {\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedNoiseType\",\n                          value);\n                      gray=(MagickBooleanType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          shade_image=ShadeImage(msl_info->image[n],gray,geometry_info.rho,\n            geometry_info.sigma,msl_info->exception);\n          if (shade_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=shade_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"shadow\") == 0)\n        {\n          Image\n            *shadow_image;\n\n          /*\n            Shear image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'O':\n                case 'o':\n                {\n                  if (LocaleCompare(keyword,\"opacity\") == 0)\n                    {\n                      geometry_info.rho=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'S':\n                case 's':\n                {\n                  if (LocaleCompare(keyword,\"sigma\") == 0)\n                    {\n                      geometry_info.sigma=StringToLong(value);\n                      break;\n                    }\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry_info.xi=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry_info.psi=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          shadow_image=ShadowImage(msl_info->image[n],geometry_info.rho,\n            geometry_info.sigma,(ssize_t) ceil(geometry_info.xi-0.5),\n            (ssize_t) ceil(geometry_info.psi-0.5),msl_info->exception);\n          if (shadow_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=shadow_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"sharpen\") == 0)\n      {\n        double \n            radius = 0.0,\n            sigma = 1.0;\n\n        if (msl_info->image[n] == (Image *) NULL)\n          {\n            ThrowMSLException(OptionError,\"NoImagesDefined\",\n              (const char *) tag);\n            break;\n          }\n        /*\n        NOTE: sharpen can have no attributes, since we use all the defaults!\n        */\n        if (attributes != (const xmlChar **) NULL)\n        {\n          for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n          {\n            keyword=(const char *) attributes[i++];\n            attribute=InterpretImageProperties(msl_info->image_info[n],\n              msl_info->attributes[n],(const char *) attributes[i],exception);\n            CloneString(&value,attribute);\n            attribute=DestroyString(attribute);\n          switch (*keyword)\n          {\n            case 'R':\n            case 'r':\n            {\n              if (LocaleCompare(keyword, \"radius\") == 0)\n              {\n                radius = StringToDouble(value,(char **) NULL);\n                break;\n              }\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n            case 'S':\n            case 's':\n            {\n              if (LocaleCompare(keyword,\"sigma\") == 0)\n              {\n                sigma = StringToLong( value );\n                break;\n              }\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n            default:\n            {\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n          }\n          }\n        }\n\n        /*\n          sharpen image.\n        */\n        {\n        Image\n          *newImage;\n\n        newImage=SharpenImage(msl_info->image[n],radius,sigma,\n          msl_info->exception);\n        if (newImage == (Image *) NULL)\n          break;\n        msl_info->image[n]=DestroyImage(msl_info->image[n]);\n        msl_info->image[n]=newImage;\n        break;\n        }\n      }\n      else if (LocaleCompare((const char *) tag,\"shave\") == 0)\n      {\n        /* init the values */\n        width = height = 0;\n        x = y = 0;\n\n        if (msl_info->image[n] == (Image *) NULL)\n        {\n          ThrowMSLException(OptionError,\"NoImagesDefined\",\n            (const char *) tag);\n          break;\n        }\n        if (attributes == (const xmlChar **) NULL)\n        break;\n        for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n        {\n          keyword=(const char *) attributes[i++];\n          attribute=InterpretImageProperties(msl_info->image_info[n],\n            msl_info->attributes[n],(const char *) attributes[i],exception);\n          CloneString(&value,attribute);\n          attribute=DestroyString(attribute);\n        switch (*keyword)\n        {\n          case 'G':\n          case 'g':\n          {\n          if (LocaleCompare(keyword,\"geometry\") == 0)\n            {\n            (void) ParseMetaGeometry(value,&x,&y,&width,&height);\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          case 'H':\n          case 'h':\n          {\n          if (LocaleCompare(keyword,\"height\") == 0)\n            {\n            height = StringToLong( value );\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          case 'W':\n          case 'w':\n          {\n          if (LocaleCompare(keyword,\"width\") == 0)\n            {\n            width = StringToLong( value );\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          default:\n          {\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n        }\n        }\n\n        /*\n          process image.\n        */\n        {\n        Image\n          *newImage;\n        RectangleInfo\n          rectInfo;\n\n        rectInfo.height = height;\n        rectInfo.width = width;\n        rectInfo.x = x;\n        rectInfo.y = y;\n\n\n        newImage=ShaveImage(msl_info->image[n], &rectInfo,\n          msl_info->exception);\n        if (newImage == (Image *) NULL)\n          break;\n        msl_info->image[n]=DestroyImage(msl_info->image[n]);\n        msl_info->image[n]=newImage;\n        }\n\n        break;\n      }\n      if (LocaleCompare((const char *) tag,\"shear\") == 0)\n        {\n          Image\n            *shear_image;\n\n          /*\n            Shear image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword, \"fill\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &msl_info->image[n]->background_color,exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry_info.sigma=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          shear_image=ShearImage(msl_info->image[n],geometry_info.rho,\n            geometry_info.sigma,msl_info->exception);\n          if (shear_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=shear_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"signature\") == 0)\n        {\n          /*\n            Signature image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) SignatureImage(msl_info->image[n],exception);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"solarize\") == 0)\n        {\n          /*\n            Solarize image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          geometry_info.rho=QuantumRange/2.0;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'T':\n                case 't':\n                {\n                  if (LocaleCompare(keyword,\"threshold\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) SolarizeImage(msl_info->image[n],geometry_info.rho,\n            msl_info->exception);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"spread\") == 0)\n        {\n          Image\n            *spread_image;\n\n          /*\n            Spread image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"radius\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          spread_image=SpreadImage(msl_info->image[n],\n            msl_info->image[n]->interpolate,geometry_info.rho,\n            msl_info->exception);\n          if (spread_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=spread_image;\n          break;\n        }\n      else if (LocaleCompare((const char *) tag,\"stegano\") == 0)\n      {\n        Image *\n          watermark = (Image*) NULL;\n\n        if (msl_info->image[n] == (Image *) NULL)\n          {\n            ThrowMSLException(OptionError,\"NoImagesDefined\",\n              (const char *) tag);\n            break;\n          }\n        if (attributes == (const xmlChar **) NULL)\n        break;\n        for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n        {\n          keyword=(const char *) attributes[i++];\n          attribute=InterpretImageProperties(msl_info->image_info[n],\n            msl_info->attributes[n],(const char *) attributes[i],exception);\n          CloneString(&value,attribute);\n          attribute=DestroyString(attribute);\n        switch (*keyword)\n        {\n          case 'I':\n          case 'i':\n          {\n          if (LocaleCompare(keyword,\"image\") == 0)\n            {\n            for (j=0; j<msl_info->n;j++)\n            {\n              const char *\n                theAttr = GetImageProperty(msl_info->attributes[j], \"id\",\n                      exception);\n              if (theAttr && LocaleCompare(theAttr, value) == 0)\n              {\n                watermark = msl_info->image[j];\n                break;\n              }\n            }\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          default:\n          {\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n        }\n        }\n\n        /*\n          process image.\n        */\n        if ( watermark != (Image*) NULL )\n        {\n        Image\n          *newImage;\n\n        newImage=SteganoImage(msl_info->image[n], watermark, msl_info->exception);\n        if (newImage == (Image *) NULL)\n          break;\n        msl_info->image[n]=DestroyImage(msl_info->image[n]);\n        msl_info->image[n]=newImage;\n        break;\n        } else\n          ThrowMSLException(OptionError,\"MissingWatermarkImage\",keyword);\n      }\n      else if (LocaleCompare((const char *) tag,\"stereo\") == 0)\n      {\n        Image *\n          stereoImage = (Image*) NULL;\n\n        if (msl_info->image[n] == (Image *) NULL)\n          {\n            ThrowMSLException(OptionError,\"NoImagesDefined\",(const char *) tag);\n            break;\n          }\n        if (attributes == (const xmlChar **) NULL)\n        break;\n        for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n        {\n          keyword=(const char *) attributes[i++];\n          attribute=InterpretImageProperties(msl_info->image_info[n],\n            msl_info->attributes[n],(const char *) attributes[i],exception);\n          CloneString(&value,attribute);\n          attribute=DestroyString(attribute);\n        switch (*keyword)\n        {\n          case 'I':\n          case 'i':\n          {\n          if (LocaleCompare(keyword,\"image\") == 0)\n            {\n            for (j=0; j<msl_info->n;j++)\n            {\n              const char *\n                theAttr = GetImageProperty(msl_info->attributes[j], \"id\",\n                      exception);\n              if (theAttr && LocaleCompare(theAttr, value) == 0)\n              {\n                stereoImage = msl_info->image[j];\n                break;\n              }\n            }\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          default:\n          {\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n        }\n        }\n\n        /*\n          process image.\n        */\n        if ( stereoImage != (Image*) NULL )\n        {\n        Image\n          *newImage;\n\n        newImage=StereoImage(msl_info->image[n], stereoImage, msl_info->exception);\n        if (newImage == (Image *) NULL)\n          break;\n        msl_info->image[n]=DestroyImage(msl_info->image[n]);\n        msl_info->image[n]=newImage;\n        break;\n        } else\n          ThrowMSLException(OptionError,\"Missing stereo image\",keyword);\n      }\n      if (LocaleCompare((const char *) tag,\"strip\") == 0)\n        {\n          /*\n            Strip image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            }\n          (void) StripImage(msl_info->image[n],msl_info->exception);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"swap\") == 0)\n        {\n          Image\n            *p,\n            *q,\n            *swap;\n\n          ssize_t\n            index,\n            swap_index;\n\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          index=(-1);\n          swap_index=(-2);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"indexes\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      index=(ssize_t) geometry_info.rho;\n                      if ((flags & SigmaValue) == 0)\n                        swap_index=(ssize_t) geometry_info.sigma;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          /*\n            Swap images.\n          */\n          p=GetImageFromList(msl_info->image[n],index);\n          q=GetImageFromList(msl_info->image[n],swap_index);\n          if ((p == (Image *) NULL) || (q == (Image *) NULL))\n            {\n              ThrowMSLException(OptionError,\"NoSuchImage\",(const char *) tag);\n              break;\n            }\n          swap=CloneImage(p,0,0,MagickTrue,msl_info->exception);\n          ReplaceImageInList(&p,CloneImage(q,0,0,MagickTrue,\n            msl_info->exception));\n          ReplaceImageInList(&q,swap);\n          msl_info->image[n]=GetFirstImageInList(q);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"swirl\") == 0)\n        {\n          Image\n            *swirl_image;\n\n          /*\n            Swirl image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'D':\n                case 'd':\n                {\n                  if (LocaleCompare(keyword,\"degrees\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          swirl_image=SwirlImage(msl_info->image[n],geometry_info.rho,\n            msl_info->image[n]->interpolate,msl_info->exception);\n          if (swirl_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=swirl_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"sync\") == 0)\n        {\n          /*\n            Sync image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) SyncImage(msl_info->image[n],exception);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'T':\n    case 't':\n    {\n      if (LocaleCompare((const char *) tag,\"map\") == 0)\n        {\n          Image\n            *texture_image;\n\n          /*\n            Texture image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          texture_image=NewImageList();\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'I':\n                case 'i':\n                {\n                  if (LocaleCompare(keyword,\"image\") == 0)\n                    for (j=0; j < msl_info->n; j++)\n                    {\n                      const char\n                        *attribute;\n\n                      attribute=GetImageProperty(msl_info->attributes[j],\"id\",\n                      exception);\n                      if ((attribute != (const char *) NULL)  &&\n                          (LocaleCompare(attribute,value) == 0))\n                        {\n                          texture_image=CloneImage(msl_info->image[j],0,0,\n                            MagickFalse,exception);\n                          break;\n                        }\n                    }\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) TextureImage(msl_info->image[n],texture_image,exception);\n          texture_image=DestroyImage(texture_image);\n          break;\n        }\n      else if (LocaleCompare((const char *) tag,\"threshold\") == 0)\n      {\n        /* init the values */\n        double  threshold = 0;\n\n        if (msl_info->image[n] == (Image *) NULL)\n          {\n            ThrowMSLException(OptionError,\"NoImagesDefined\",(const char *) tag);\n            break;\n          }\n        if (attributes == (const xmlChar **) NULL)\n        break;\n        for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n        {\n          keyword=(const char *) attributes[i++];\n          attribute=InterpretImageProperties(msl_info->image_info[n],\n            msl_info->attributes[n],(const char *) attributes[i],exception);\n          CloneString(&value,attribute);\n          attribute=DestroyString(attribute);\n        switch (*keyword)\n        {\n          case 'T':\n          case 't':\n          {\n          if (LocaleCompare(keyword,\"threshold\") == 0)\n            {\n            threshold = StringToDouble(value,(char **) NULL);\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          default:\n          {\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n        }\n        }\n\n        /*\n          process image.\n        */\n        {\n          BilevelImage(msl_info->image[n],threshold,exception);\n          break;\n        }\n      }\n      else if (LocaleCompare((const char *) tag, \"transparent\") == 0)\n      {\n        if (msl_info->image[n] == (Image *) NULL)\n          {\n            ThrowMSLException(OptionError,\"NoImagesDefined\",(const char *) tag);\n            break;\n          }\n        if (attributes == (const xmlChar **) NULL)\n          break;\n        for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n        {\n          keyword=(const char *) attributes[i++];\n          attribute=InterpretImageProperties(msl_info->image_info[n],\n            msl_info->attributes[n],(const char *) attributes[i],exception);\n          CloneString(&value,attribute);\n          attribute=DestroyString(attribute);\n          switch (*keyword)\n          {\n            case 'C':\n            case 'c':\n            {\n              if (LocaleCompare(keyword,\"color\") == 0)\n              {\n                PixelInfo\n                  target;\n\n                (void) QueryColorCompliance(value,AllCompliance,&target,\n                  exception);\n                (void) TransparentPaintImage(msl_info->image[n],&target,\n                  TransparentAlpha,MagickFalse,msl_info->exception);\n                break;\n              }\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n            default:\n            {\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            break;\n            }\n          }\n        }\n        break;\n      }\n      else if (LocaleCompare((const char *) tag, \"trim\") == 0)\n      {\n        if (msl_info->image[n] == (Image *) NULL)\n          {\n            ThrowMSLException(OptionError,\"NoImagesDefined\",(const char *) tag);\n            break;\n          }\n\n        /* no attributes here */\n\n        /* process the image */\n        {\n          Image\n            *newImage;\n          RectangleInfo\n            rectInfo;\n\n          /* all zeros on a crop == trim edges! */\n          rectInfo.height = rectInfo.width = 0;\n          rectInfo.x =  rectInfo.y = 0;\n\n          newImage=CropImage(msl_info->image[n],&rectInfo, msl_info->exception);\n          if (newImage == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=newImage;\n          break;\n        }\n      }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'W':\n    case 'w':\n    {\n      if (LocaleCompare((const char *) tag,\"write\") == 0)\n        {\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes == (const xmlChar **) NULL)\n            break;\n          for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n          {\n            keyword=(const char *) attributes[i++];\n            attribute=InterpretImageProperties(msl_info->image_info[n],\n              msl_info->attributes[n],(const char *) attributes[i],exception);\n            CloneString(&value,attribute);\n            attribute=DestroyString(attribute);\n            switch (*keyword)\n            {\n              case 'F':\n              case 'f':\n              {\n                if (LocaleCompare(keyword,\"filename\") == 0)\n                  {\n                    (void) CopyMagickString(msl_info->image[n]->filename,value,\n                      MagickPathExtent);\n                    break;\n                  }\n                (void) SetMSLAttributes(msl_info,keyword,value);\n              }\n              default:\n              {\n                (void) SetMSLAttributes(msl_info,keyword,value);\n                break;\n              }\n            }\n          }\n\n          /* process */\n          {\n            *msl_info->image_info[n]->magick='\\0';\n            (void) WriteImage(msl_info->image_info[n], msl_info->image[n],\n              msl_info->exception);\n            break;\n          }\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    default:\n    {\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n      break;\n    }\n  }\n  if (value != (char *) NULL)\n    value=DestroyString(value);\n  (void) DestroyExceptionInfo(exception);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  )\");\n}\n\nstatic void MSLEndElement(void *context,const xmlChar *tag)\n{\n  ssize_t\n    n;\n\n  MSLInfo\n    *msl_info;\n\n  /*\n    Called when the end of an element has been detected.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.endElement(%s)\",\n    tag);\n  msl_info=(MSLInfo *) context;\n  n=msl_info->n;\n  switch (*tag)\n  {\n    case 'C':\n    case 'c':\n    {\n      if (LocaleCompare((const char *) tag,\"comment\") == 0 )\n        {\n          (void) DeleteImageProperty(msl_info->image[n],\"comment\");\n          if (msl_info->content == (char *) NULL)\n            break;\n          StripString(msl_info->content);\n          (void) SetImageProperty(msl_info->image[n],\"comment\",\n            msl_info->content,msl_info->exception);\n          break;\n        }\n      break;\n    }\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare((const char *) tag, \"group\") == 0 )\n      {\n        if (msl_info->group_info[msl_info->number_groups-1].numImages > 0 )\n        {\n          ssize_t  i = (ssize_t)\n            (msl_info->group_info[msl_info->number_groups-1].numImages);\n          while ( i-- )\n          {\n            if (msl_info->image[msl_info->n] != (Image *) NULL)\n              msl_info->image[msl_info->n]=DestroyImage(\n                msl_info->image[msl_info->n]);\n            msl_info->attributes[msl_info->n]=DestroyImage(\n                msl_info->attributes[msl_info->n]);\n            msl_info->image_info[msl_info->n]=DestroyImageInfo(\n                msl_info->image_info[msl_info->n]);\n            msl_info->n--;\n          }\n        }\n        msl_info->number_groups--;\n      }\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare((const char *) tag, \"image\") == 0)\n        MSLPopImage(msl_info);\n       break;\n    }\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare((const char *) tag,\"label\") == 0 )\n        {\n          (void) DeleteImageProperty(msl_info->image[n],\"label\");\n          if (msl_info->content == (char *) NULL)\n            break;\n          StripString(msl_info->content);\n          (void) SetImageProperty(msl_info->image[n],\"label\",\n            msl_info->content,msl_info->exception);\n          break;\n        }\n      break;\n    }\n    case 'M':\n    case 'm':\n    {\n      if (LocaleCompare((const char *) tag, \"msl\") == 0 )\n      {\n        /*\n          This our base element.\n            at the moment we don't do anything special\n            but someday we might!\n        */\n      }\n      break;\n    }\n    default:\n      break;\n  }\n  if (msl_info->content != (char *) NULL)\n    msl_info->content=DestroyString(msl_info->content);\n}\n\nstatic void MSLCharacters(void *context,const xmlChar *c,int length)\n{\n  MSLInfo\n    *msl_info;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  /*\n    Receiving some characters from the parser.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.characters(%s,%d)\",c,length);\n  msl_info=(MSLInfo *) context;\n  if (msl_info->content != (char *) NULL)\n    msl_info->content=(char *) ResizeQuantumMemory(msl_info->content,\n      strlen(msl_info->content)+length+MagickPathExtent,\n      sizeof(*msl_info->content));\n  else\n    {\n      msl_info->content=(char *) NULL;\n      if (~(size_t) length >= (MagickPathExtent-1))\n        msl_info->content=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n          sizeof(*msl_info->content));\n      if (msl_info->content != (char *) NULL)\n        *msl_info->content='\\0';\n    }\n  if (msl_info->content == (char *) NULL)\n    return;\n  p=msl_info->content+strlen(msl_info->content);\n  for (i=0; i < length; i++)\n    *p++=c[i];\n  *p='\\0';\n}\n\nstatic void MSLReference(void *context,const xmlChar *name)\n{\n  MSLInfo\n    *msl_info;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    Called when an entity reference is detected.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.reference(%s)\",name);\n  msl_info=(MSLInfo *) context;\n  parser=msl_info->parser;\n  if (*name == '#')\n    (void) xmlAddChild(parser->node,xmlNewCharRef(msl_info->document,name));\n  else\n    (void) xmlAddChild(parser->node,xmlNewReference(msl_info->document,name));\n}\n\nstatic void MSLIgnorableWhitespace(void *context,const xmlChar *c,int length)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    Receiving some ignorable whitespaces from the parser.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.ignorableWhitespace(%.30s, %d)\",c,length);\n  msl_info=(MSLInfo *) context;\n  (void) msl_info;\n}\n\nstatic void MSLProcessingInstructions(void *context,const xmlChar *target,\n  const xmlChar *data)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    A processing instruction has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.processingInstruction(%s, %s)\",\n    target,data);\n  msl_info=(MSLInfo *) context;\n  (void) msl_info;\n}\n\nstatic void MSLComment(void *context,const xmlChar *value)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    A comment has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.comment(%s)\",value);\n  msl_info=(MSLInfo *) context;\n  (void) msl_info;\n}\n\nstatic void MSLWarning(void *context,const char *format,...)\n{\n  char\n    *message,\n    reason[MagickPathExtent];\n\n  MSLInfo\n    *msl_info;\n\n  va_list\n    operands;\n\n  /**\n    Display and format a warning messages, gives file, line, position and\n    extra parameters.\n  */\n  va_start(operands,format);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.warning: \");\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),format,operands);\n  msl_info=(MSLInfo *) context;\n  (void) msl_info;\n#if !defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsprintf(reason,format,operands);\n#else\n  (void) vsnprintf(reason,MagickPathExtent,format,operands);\n#endif\n  message=GetExceptionMessage(errno);\n  ThrowMSLException(CoderError,reason,message);\n  message=DestroyString(message);\n  va_end(operands);\n}\n\nstatic void MSLError(void *context,const char *format,...)\n{\n  char\n    reason[MagickPathExtent];\n\n  MSLInfo\n    *msl_info;\n\n  va_list\n    operands;\n\n  /*\n    Display and format a error formats, gives file, line, position and\n    extra parameters.\n  */\n  va_start(operands,format);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.error: \");\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),format,operands);\n  msl_info=(MSLInfo *) context;\n  (void) msl_info;\n#if !defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsprintf(reason,format,operands);\n#else\n  (void) vsnprintf(reason,MagickPathExtent,format,operands);\n#endif\n  ThrowMSLException(DelegateFatalError,reason,\"SAX error\");\n  va_end(operands);\n}\n\nstatic void MSLCDataBlock(void *context,const xmlChar *value,int length)\n{\n  MSLInfo\n    *msl_info;\n\n   xmlNodePtr\n     child;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    Called when a pcdata block has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.pcdata(%s, %d)\",value,length);\n  msl_info=(MSLInfo *) context;\n  (void) msl_info;\n  parser=msl_info->parser;\n  child=xmlGetLastChild(parser->node);\n  if ((child != (xmlNodePtr) NULL) && (child->type == XML_CDATA_SECTION_NODE))\n    {\n      xmlTextConcat(child,value,length);\n      return;\n    }\n  (void) xmlAddChild(parser->node,xmlNewCDataBlock(parser->myDoc,value,length));\n}\n\nstatic void MSLExternalSubset(void *context,const xmlChar *name,\n  const xmlChar *external_id,const xmlChar *system_id)\n{\n  MSLInfo\n    *msl_info;\n\n  xmlParserCtxt\n    parser_context;\n\n  xmlParserCtxtPtr\n    parser;\n\n  xmlParserInputPtr\n    input;\n\n  /*\n    Does this document has an external subset?\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.externalSubset(%s %s %s)\",name,\n    (external_id != (const xmlChar *) NULL ? (const char *) external_id : \" \"),\n    (system_id != (const xmlChar *) NULL ? (const char *) system_id : \" \"));\n  msl_info=(MSLInfo *) context;\n  (void) msl_info;\n  parser=msl_info->parser;\n  if (((external_id == NULL) && (system_id == NULL)) ||\n      ((parser->validate == 0) || (parser->wellFormed == 0) ||\n      (msl_info->document == 0)))\n    return;\n  input=MSLResolveEntity(context,external_id,system_id);\n  if (input == NULL)\n    return;\n  (void) xmlNewDtd(msl_info->document,name,external_id,system_id);\n  parser_context=(*parser);\n  parser->inputTab=(xmlParserInputPtr *) xmlMalloc(5*sizeof(*parser->inputTab));\n  if (parser->inputTab == (xmlParserInputPtr *) NULL)\n    {\n      parser->errNo=XML_ERR_NO_MEMORY;\n      parser->input=parser_context.input;\n      parser->inputNr=parser_context.inputNr;\n      parser->inputMax=parser_context.inputMax;\n      parser->inputTab=parser_context.inputTab;\n      return;\n  }\n  parser->inputNr=0;\n  parser->inputMax=5;\n  parser->input=NULL;\n  xmlPushInput(parser,input);\n  (void) xmlSwitchEncoding(parser,xmlDetectCharEncoding(parser->input->cur,4));\n  if (input->filename == (char *) NULL)\n    input->filename=(char *) xmlStrdup(system_id);\n  input->line=1;\n  input->col=1;\n  input->base=parser->input->cur;\n  input->cur=parser->input->cur;\n  input->free=NULL;\n  xmlParseExternalSubset(parser,external_id,system_id);\n  while (parser->inputNr > 1)\n    (void) xmlPopInput(parser);\n  xmlFreeInputStream(parser->input);\n  xmlFree(parser->inputTab);\n  parser->input=parser_context.input;\n  parser->inputNr=parser_context.inputNr;\n  parser->inputMax=parser_context.inputMax;\n  parser->inputTab=parser_context.inputTab;\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic MagickBooleanType ProcessMSLScript(const ImageInfo *image_info,\n  Image **image,ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent];\n\n  Image\n    *msl_image;\n\n  int\n    status;\n\n  ssize_t\n    n;\n\n  MSLInfo\n    msl_info;\n\n  xmlSAXHandler\n    sax_modules;\n\n  xmlSAXHandlerPtr\n    sax_handler;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(image != (Image **) NULL);\n  msl_image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,msl_image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        msl_image->filename);\n      msl_image=DestroyImageList(msl_image);\n      return(MagickFalse);\n    }\n  msl_image->columns=1;\n  msl_image->rows=1;\n  /*\n    Parse MSL file.\n  */\n  (void) ResetMagickMemory(&msl_info,0,sizeof(msl_info));\n  msl_info.exception=exception;\n  msl_info.image_info=(ImageInfo **) AcquireMagickMemory(\n    sizeof(*msl_info.image_info));\n  msl_info.draw_info=(DrawInfo **) AcquireMagickMemory(\n    sizeof(*msl_info.draw_info));\n  /* top of the stack is the MSL file itself */\n  msl_info.image=(Image **) AcquireMagickMemory(sizeof(*msl_info.image));\n  msl_info.attributes=(Image **) AcquireMagickMemory(\n    sizeof(*msl_info.attributes));\n  msl_info.group_info=(MSLGroupInfo *) AcquireMagickMemory(\n    sizeof(*msl_info.group_info));\n  if ((msl_info.image_info == (ImageInfo **) NULL) ||\n      (msl_info.image == (Image **) NULL) ||\n      (msl_info.attributes == (Image **) NULL) ||\n      (msl_info.group_info == (MSLGroupInfo *) NULL))\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToInterpretMSLImage\");\n  *msl_info.image_info=CloneImageInfo(image_info);\n  *msl_info.draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  *msl_info.attributes=AcquireImage(image_info,exception);\n  msl_info.group_info[0].numImages=0;\n  /* the first slot is used to point to the MSL file image */\n  *msl_info.image=msl_image;\n  if (*image != (Image *) NULL)\n    MSLPushImage(&msl_info,*image);\n  (void) xmlSubstituteEntitiesDefault(1);\n  (void) ResetMagickMemory(&sax_modules,0,sizeof(sax_modules));\n  sax_modules.internalSubset=MSLInternalSubset;\n  sax_modules.isStandalone=MSLIsStandalone;\n  sax_modules.hasInternalSubset=MSLHasInternalSubset;\n  sax_modules.hasExternalSubset=MSLHasExternalSubset;\n  sax_modules.resolveEntity=MSLResolveEntity;\n  sax_modules.getEntity=MSLGetEntity;\n  sax_modules.entityDecl=MSLEntityDeclaration;\n  sax_modules.notationDecl=MSLNotationDeclaration;\n  sax_modules.attributeDecl=MSLAttributeDeclaration;\n  sax_modules.elementDecl=MSLElementDeclaration;\n  sax_modules.unparsedEntityDecl=MSLUnparsedEntityDeclaration;\n  sax_modules.setDocumentLocator=MSLSetDocumentLocator;\n  sax_modules.startDocument=MSLStartDocument;\n  sax_modules.endDocument=MSLEndDocument;\n  sax_modules.startElement=MSLStartElement;\n  sax_modules.endElement=MSLEndElement;\n  sax_modules.reference=MSLReference;\n  sax_modules.characters=MSLCharacters;\n  sax_modules.ignorableWhitespace=MSLIgnorableWhitespace;\n  sax_modules.processingInstruction=MSLProcessingInstructions;\n  sax_modules.comment=MSLComment;\n  sax_modules.warning=MSLWarning;\n  sax_modules.error=MSLError;\n  sax_modules.fatalError=MSLError;\n  sax_modules.getParameterEntity=MSLGetParameterEntity;\n  sax_modules.cdataBlock=MSLCDataBlock;\n  sax_modules.externalSubset=MSLExternalSubset;\n  sax_handler=(&sax_modules);\n  msl_info.parser=xmlCreatePushParserCtxt(sax_handler,&msl_info,(char *) NULL,0,\n    msl_image->filename);\n  while (ReadBlobString(msl_image,message) != (char *) NULL)\n  {\n    n=(ssize_t) strlen(message);\n    if (n == 0)\n      continue;\n    status=xmlParseChunk(msl_info.parser,message,(int) n,MagickFalse);\n    if (status != 0)\n      break;\n    (void) xmlParseChunk(msl_info.parser,\" \",1,MagickFalse);\n    if (msl_info.exception->severity >= ErrorException)\n      break;\n  }\n  if (msl_info.exception->severity == UndefinedException)\n    (void) xmlParseChunk(msl_info.parser,\" \",1,MagickTrue);\n  xmlFreeParserCtxt(msl_info.parser);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"end SAX\");\n  msl_info.group_info=(MSLGroupInfo *) RelinquishMagickMemory(\n    msl_info.group_info);\n  if (*image == (Image *) NULL)\n    *image=(*msl_info.image);\n  if (msl_info.exception->severity != UndefinedException)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\nstatic Image *ReadMSLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=(Image *) NULL;\n  (void) ProcessMSLScript(image_info,&image,exception);\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r M S L I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterMSLImage() adds attributes for the MSL image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterMSLImage method is:\n%\n%      size_t RegisterMSLImage(void)\n%\n*/\nModuleExport size_t RegisterMSLImage(void)\n{\n  MagickInfo\n    *entry;\n\n#if defined(MAGICKCORE_XML_DELEGATE)\n  xmlInitParser();\n#endif\n  entry=AcquireMagickInfo(\"MSL\",\"MSL\",\"Magick Scripting Language\");\n#if defined(MAGICKCORE_XML_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadMSLImage;\n  entry->encoder=(EncodeImageHandler *) WriteMSLImage;\n#endif\n  entry->format_type=ImplicitFormatType;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n#if defined(MAGICKCORE_XML_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t M S L A t t r i b u t e s                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetMSLAttributes() ...\n%\n%  The format of the SetMSLAttributes method is:\n%\n%      MagickBooleanType SetMSLAttributes(MSLInfo *msl_info,\n%        const char *keyword,const char *value)\n%\n%  A description of each parameter follows:\n%\n%    o msl_info: the MSL info.\n%\n%    o keyword: the keyword.\n%\n%    o value: the value.\n%\n*/\nstatic MagickBooleanType SetMSLAttributes(MSLInfo *msl_info,const char *keyword,\n  const char *value)\n{\n  Image\n    *attributes;\n\n  DrawInfo\n    *draw_info;\n\n  ExceptionInfo\n    *exception;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image;\n\n  ImageInfo\n    *image_info;\n\n  int\n    flags;\n\n  ssize_t\n    n;\n\n  assert(msl_info != (MSLInfo *) NULL);\n  if (keyword == (const char *) NULL)\n    return(MagickTrue);\n  if (value == (const char *) NULL)\n    return(MagickTrue);\n  exception=msl_info->exception;\n  n=msl_info->n;\n  attributes=msl_info->attributes[n];\n  image_info=msl_info->image_info[n];\n  draw_info=msl_info->draw_info[n];\n  image=msl_info->image[n];\n  switch (*keyword)\n  {\n    case 'A':\n    case 'a':\n    {\n      if (LocaleCompare(keyword,\"adjoin\") == 0)\n        {\n          ssize_t\n            adjoin;\n\n          adjoin=ParseCommandOption(MagickBooleanOptions,MagickFalse,value);\n          if (adjoin < 0)\n            ThrowMSLException(OptionError,\"UnrecognizedType\",value);\n          image_info->adjoin=(MagickBooleanType) adjoin;\n          break;\n        }\n      if (LocaleCompare(keyword,\"alpha\") == 0)\n        {\n          ssize_t\n            alpha;\n\n          alpha=ParseCommandOption(MagickAlphaChannelOptions,MagickFalse,value);\n          if (alpha < 0)\n            ThrowMSLException(OptionError,\"UnrecognizedType\",value);\n          if (image != (Image *) NULL)\n            (void) SetImageAlphaChannel(image,(AlphaChannelOption) alpha,\n              exception);\n          break;\n        }\n      if (LocaleCompare(keyword,\"antialias\") == 0)\n        {\n          ssize_t\n            antialias;\n\n          antialias=ParseCommandOption(MagickBooleanOptions,MagickFalse,value);\n          if (antialias < 0)\n            ThrowMSLException(OptionError,\"UnrecognizedGravityType\",value);\n          image_info->antialias=(MagickBooleanType) antialias;\n          break;\n        }\n      if (LocaleCompare(keyword,\"area-limit\") == 0)\n        {\n          MagickSizeType\n            limit;\n\n          limit=MagickResourceInfinity;\n          if (LocaleCompare(value,\"unlimited\") != 0)\n            limit=(MagickSizeType) StringToDoubleInterval(value,100.0);\n          (void) SetMagickResourceLimit(AreaResource,limit);\n          break;\n        }\n      if (LocaleCompare(keyword,\"attenuate\") == 0)\n        {\n          (void) SetImageOption(image_info,keyword,value);\n          break;\n        }\n      if (LocaleCompare(keyword,\"authenticate\") == 0)\n        {\n          (void) CloneString(&image_info->density,value);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n      break;\n    }\n    case 'B':\n    case 'b':\n    {\n      if (LocaleCompare(keyword,\"background\") == 0)\n        {\n          (void) QueryColorCompliance(value,AllCompliance,\n            &image_info->background_color,exception);\n          break;\n        }\n      if (LocaleCompare(keyword,\"blue-primary\") == 0)\n        {\n          if (image == (Image *) NULL)\n            break;\n          flags=ParseGeometry(value,&geometry_info);\n          image->chromaticity.blue_primary.x=geometry_info.rho;\n          image->chromaticity.blue_primary.y=geometry_info.sigma;\n          if ((flags & SigmaValue) == 0)\n            image->chromaticity.blue_primary.y=\n              image->chromaticity.blue_primary.x;\n          break;\n        }\n      if (LocaleCompare(keyword,\"bordercolor\") == 0)\n        {\n          (void) QueryColorCompliance(value,AllCompliance,\n            &image_info->border_color,exception);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n      break;\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleCompare(keyword,\"density\") == 0)\n        {\n          (void) CloneString(&image_info->density,value);\n          (void) CloneString(&draw_info->density,value);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n      break;\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleCompare(keyword,\"fill\") == 0)\n        {\n          (void) QueryColorCompliance(value,AllCompliance,&draw_info->fill,\n            exception);\n          (void) SetImageOption(image_info,keyword,value);\n          break;\n        }\n      if (LocaleCompare(keyword,\"filename\") == 0)\n        {\n          (void) CopyMagickString(image_info->filename,value,MagickPathExtent);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n      break;\n    }\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare(keyword,\"gravity\") == 0)\n        {\n          ssize_t\n            gravity;\n\n          gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,value);\n          if (gravity < 0)\n            ThrowMSLException(OptionError,\"UnrecognizedGravityType\",value);\n          (void) SetImageOption(image_info,keyword,value);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare(keyword,\"id\") == 0)\n        {\n          (void) SetImageProperty(attributes,keyword,value,exception);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n      break;\n    }\n    case 'M':\n    case 'm':\n    {\n      if (LocaleCompare(keyword,\"magick\") == 0)\n        {\n          (void) CopyMagickString(image_info->magick,value,MagickPathExtent);\n          break;\n        }\n      if (LocaleCompare(keyword,\"mattecolor\") == 0)\n        {\n          (void) QueryColorCompliance(value,AllCompliance,\n            &image_info->matte_color,exception);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n      break;\n    }\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare(keyword,\"pointsize\") == 0)\n        {\n          image_info->pointsize=StringToDouble(value,(char **) NULL);\n          draw_info->pointsize=StringToDouble(value,(char **) NULL);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n      break;\n    }\n    case 'Q':\n    case 'q':\n    {\n      if (LocaleCompare(keyword,\"quality\") == 0)\n        {\n          image_info->quality=StringToLong(value);\n          if (image == (Image *) NULL)\n            break;\n          image->quality=StringToLong(value);\n          break;\n        }\n      break;\n    }\n    case 'S':\n    case 's':\n    {\n      if (LocaleCompare(keyword,\"size\") == 0)\n        {\n          (void) CloneString(&image_info->size,value);\n          break;\n        }\n      if (LocaleCompare(keyword,\"stroke\") == 0)\n        {\n          (void) QueryColorCompliance(value,AllCompliance,&draw_info->stroke,\n            exception);\n          (void) SetImageOption(image_info,keyword,value);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n      break;\n    }\n    default:\n    {\n      ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n      break;\n    }\n  }\n  return(MagickTrue);\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r M S L I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterMSLImage() removes format registrations made by the\n%  MSL module from the list of supported formats.\n%\n%  The format of the UnregisterMSLImage method is:\n%\n%      UnregisterMSLImage(void)\n%\n*/\nModuleExport void UnregisterMSLImage(void)\n{\n  (void) UnregisterMagickInfo(\"MSL\");\n#if defined(MAGICKCORE_XML_DELEGATE)\n  xmlCleanupParser();\n#endif\n}\n\f\n#if defined(MAGICKCORE_XML_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e M S L I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteMSLImage() writes an image to a file in MVG image format.\n%\n%  The format of the WriteMSLImage method is:\n%\n%      MagickBooleanType WriteMSLImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteMSLImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  Image\n    *msl_image;\n\n  MagickBooleanType\n    status;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  msl_image=CloneImage(image,0,0,MagickTrue,exception);\n  status=ProcessMSLScript(image_info,&msl_image,exception);\n  if (msl_image != (Image *) NULL)\n    msl_image=DestroyImage(msl_image);\n  return(status);\n}\n#endif\n"], "fixing_code": ["2017-07-01  7.0.6-5 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-07-29  7.0.6-5 Glenn Randers-Pehrson <glennrp@image...>\n  * Properly set image->colorspace in the PNG decoder (previously\n    it was setting image->gamma, but only setting image->colorspace\n    for grayscale and gray-alpha images.  Reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=32418).\n  * Fix improper use of NULL in the JNG decoder (Reference\n    https://github.com/ImageMagick/ImageMagick/issues/632).\n\n2017-07-29  7.0.6-5 Cristy  <quetzlzacatenango@image...>\n  * Off by one error for gradient coder (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=32416),\n    https://github.com/ImageMagick/ImageMagick/issues/612).\n\n2017-07-28  7.0.6-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-4, GIT revision 20657:4e81160d6:20170728.\n\n2017-07-24  7.0.6-4 Cristy  <quetzlzacatenango@image...>\n  * YUV coder no longer renders streaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues/612).\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * coders/png.c: Initialized quantum_scanline and quantum_info\n    to prevent a bad free (reference\n    https://github.com/ImageMagick/ImageMagick/issues/621).\n\n2017-07-25  7.0.6-4 Glenn Randers-Pehrson <glennrp@image...>\n  * Removed write_chunk_from_profile() from coders/png.c because it has\n    not worked at least since version 6.7.6.\n  * Removed many redundant checks before RelinquishMagickMemory(), which\n    is safe to call with a NULL argument.\n  * Added experimental PNG orNT chunk, to store image->orientation.\n  * Removed vpAg chunk write support (we are now writing caNv instead).\n\n2017-07-24  7.0.6-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-3, GIT revision 20598:cc9c43b44:20170724.\n\n2017-07-23  7.0.6-3 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-07-23  7.0.6-3 Glenn Randers-Pehrson <glennrp@image...>\n  * Fix memory leaks when reading a malformed JNG image:\n    https://github.com/ImageMagick/ImageMagick/issues/600,\n    https://github.com/ImageMagick/ImageMagick/issues/602).\n\n2017-07-21  7.0.6-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-2, GIT revision 20549:62fcf3d96:20170721.\n\n2017-07-19  7.0.6-2 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * The -monochrome option no longer returns a blank canvas (reference\n    https://github.com/ImageMagick/ImageMagick/issues/594).\n  * coders/png.c: fixed memory leak of quantum_info (CVE-2017-11539, reference\n    https://github.com/ImageMagick/ImageMagick/issues/582\n\n2017-07-15  7.0.6-2 Glenn Randers-Pehrson <glennrp@image...>\n  * Added caNv, eXIf, and pHYs to the list of PNG chunks to be removed\n    by the \"-strip\" option.\n\n2017-07-15  7.0.6-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-1, GIT revision 20447:c2a315e10:20170715.\n\n2017-07-13  7.0.6-1 Glenn Randers-Pehrson <glennrp@image...>\n  * Implemented PNG eXIf chunk support.\n\n2017-07-08  7.0.6-1 Cristy  <quetzlzacatenango@image...>\n  * Support new -auto-threshold option.  OTSU and Triangle methods are\n    currently supported.  Look for the Kapur method in the next release.\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Don't use variable float_t / double_t, bump SO (reference\n    https://github.com/ImageMagick/ImageMagick/issues/510).\n  * Support DNG images with libraw delegate library.\n\n2017-07-02  7.0.6-1 Glenn Randers-Pehrson <glennrp@image...>\n  * Reject PNG file that is too small (under 60 bytes) to contain\n    a valid image.\n  * Reject JPEG file that is too small (under 107 bytes) to contain\n    a valid image.\n  * Reject JNG file that is too small (under 147 bytes) to contain\n    a valid image.\n\n2017-06-22  7.0.6-1 Glenn Randers-Pehrson <glennrp@image...>\n  * Stop a memory leak in read_user_chunk_callback() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/517,\n    CVE 2017-11310).\n\n2017-06-10  7.0.6-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-0, GIT revision 20194:b0c0d00:20170611.\n\n2017-06-10  7.0.6-0 Glenn Randers-Pehrson <glennrp@image...>\n  * coders/png.c: Accept exIf chunks whose data segment\n    erroneously begins with \"Exif\\0\\0\".\n\n2017-06-10  7.0.6-0 Cristy  <quetzlzacatenango@image...>\n  * Introduce SetMagickSecurityPolicy() (MagickCore) and\n    MagickSetSecurityPolicy() (MagickWand) to set the ImageMagick security\n    policy (reference https://github.com/ImageMagick/ImageMagick/issues/407).\n\n2017-06-02  7.0.5-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-10, GIT revision 20155:38ebc02:20170602.\n\n2017-06-01  7.0.5-10 Glenn Randers-Pehrson <glennrp@image...>\n  * Removed experimental PNG zxIF chunk support; the proposal is dead.\n\n2017-06-01  7.0.5-10 Cristy  <quetzlzacatenango@image...>\n  * Fix choppy bitmap font rendering (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=32071).\n  * The +opaque option is not longer a noop (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=32081).\n  * Add support  for 'hex:' property.\n\n2017-05-28  7.0.5-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-9, GIT revision 20113:8b67333:20170528.\n\n2017-05-28  7.0.5-9 Cristy  <quetzlzacatenango@image...>\n  * Transient error validating the JPEG-2000 image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/501).\n  * Properly allocate DCM image colormap (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=32063).\n\n2017-05-26  7.0.5-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-8, GIT revision 20099:870a016:20170526.\n\n2017-05-23  7.0.5-8 Cristy  <quetzlzacatenango@image...>\n  * Improper allocation of memory for IM instances without threads (reference\n    https://github.com/ImageMagick/ImageMagick/issues/497).\n  * Delete corrupt image from list (reference\n    https://github.com/ImageMagick/ImageMagick/issues/500).\n\n2017-05-19  7.0.5-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-6, GIT revision 20078:7ce2d38:20170519.\n\n2017-05-15  7.0.5-7 Cristy  <quetzlzacatenango@image...>\n  * Support various image operators for the compare utility (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=2&t=31938).\n\n 2017-05-12  7.0.5-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-6, GIT revision 20039:9371904:20170512.\n\n2017-05-10  7.0.5-6 John Cupitt <jcupitt@gmail.com>\n  * Revise DICOM window and rescale handling (reference \n    https://github.com/ImageMagick/ImageMagick/pull/484)\n\n2017-05-06  7.0.5-6 Cristy  <quetzlzacatenango@image...>\n  * Restore the -alpha Shape option (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31879).\n  * Fix transient PDF bug (reference\n    https://github.com/ImageMagick/ImageMagick/issues/463).\n  * The +opaque option now works on all channels (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31862).\n  * Ensure backwards compatibility for the -combine option (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31855).\n  * Check for EOF conditions for RLE image format.\n  * Reset histogram page geometry (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31920).\n\n2017-04-24  7.0.5-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-5, GIT revision 19915:12eec43:20170424.\n\n2017-03-26  7.0.5-5 Cristy  <quetzlzacatenango@image...>\n  * Minimize buffer copies to improve OpenCL performance.\n  * Morphology thinning is no longer a no-op (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31650).\n  * Patch two PCD writer problems, corrupt output and dark pixels (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=3164).\n  * Support ICC based PDF's (reference\n    https://github.com/ImageMagick/ImageMagick/issues/417).\n  * Fix improper EPS clip path rendering (reference\n    http://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31722).\n\n2017-03-24  7.0.5-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-4, GIT revision 19754:350fff3:20170324.\n\n2017-03-21  7.0.5-4 Cristy  <quetzlzacatenango@image...>\n  * Respect -loop option for animate -window (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31619).\n\n2017-03-17  7.0.5-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-3, GIT revision 19741:070c3fb:20170317.\n\n2017-03-14  7.0.5-3 Cristy  <quetzlzacatenango@image...>\n  * Support namespaces for the security policy.\n  * Support the -authenticate option for PDF (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31530).\n\n2017-03-11  7.0.5-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-2, GIT revision 19696:da91a7c:20170311.\n\n2017-03-06  7.0.5-2 Cristy  <quetzlzacatenango@image...>\n  * Respect throttle policy (reference\n    https://github.com/ImageMagick/ImageMagick/issues/393).\n  * Return proper minima / maxima (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31377).\n\n2017-03-03  7.0.5-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-1, GIT revision 19662:b7f455a:20170303.\n\n2017-02-21  7.0.5-1 Cristy  <quetzlzacatenango@image...>\n  * Fix Spurious memory allocation message (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31438).\n  * Identical images should return inf for PSNR (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31487).\n\n2017-02-20  7.0.5-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-0, GIT revision 19616:505fea9:20170220.\n\n2017-02-20  7.0.5-0 Cristy  <quetzlzacatenango@image...>\n  * Fix transient bug with -separate option (reference\n    https://github.com/ImageMagick/ImageMagick/issues/385).\n\n2017-02-18  7.0.4-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-10, GIT revision 19608:fe757a2:20170218.\n\n2017-02-18  7.0.4-10 Dirk Lemstra <dirk@lem.....org>\n  * Fixed fd leak for webp coder (reference\n    https://github.com/ImageMagick/ImageMagick/pull/382)\n\n2017-02-15  7.0.4-10 Cristy  <quetzlzacatenango@image...>\n  * Prevent random pixel data for corrupt JPEG image (bug report from\n    Hirokazu Moriguchi, Sony).\n  * Restore -mattecolor option.\n  * Support pixel-cache and shred security policies.\n  * Bump Magick++ SO.  Previously a global replace changed matteColor to\n    alphaColor.\n\n2017-02-14  7.0.4-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-9, GIT revision 19580:d474b37:20170214.\n\n2017-02-14  7.0.4-9 Cristy  <quetzlzacatenango@image...>\n  * Revert patch that did not set update trait on alpha channel.\n\n2017-02-13  7.0.4-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-8, GIT revision 19574:7642384:20170213.\n\n2017-02-09  7.0.4-8 Dirk Lemstra <dirk@lem.....org>\n  * Fixed memory leak when creating nested exceptions in Magick++ (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=23&p=142634)\n\n2017-02-09  7.0.4-8 Cristy  <quetzlzacatenango@image...>\n  * Unbreak build without JPEG support (reference\n    https://github.com/ImageMagick/ImageMagick/pull/373).\n  * Document behavior change in the security policy (thanks to yoya @\n    https://blog.awm.jp/2017/02/09/imagemagick-en/).\n  * Return unbiased standard deviation for image statistics (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31377).\n  * Don't set update trait on alpha channel (private e-mail concerning\n    -levels-colors option).\n\n2017-02-04  7.0.4-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-7, GIT revision 19513:5783e57:20170204.\n\n2017-01-28  7.0.4-7 Cristy  <quetzlzacatenango@image...>\n  * Sanitize comments that include braces for the MIFF image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/368).\n\n2017-01-27  7.0.4-7 Glenn Randers-Pehrson <glennrp@image...>\n  * coders/png.c: Added support for a proposed new PNG chunk\n    (zxIf, read-only) that is currently being discussed on the\n    png-mng-misc at lists.sourceforge.net mailing list.  Enable\n    exIf and zxIf with CPPFLAGS=\"-DexIf_SUPPORTED -DxzIf_SUPPORTED\".\n    If exIf is enabled, only the uncompressed exIF chunk will be\n    written and the hex-encoded zTXt chunk containing the raw Exif\n    profile won't be written.\n\n2017-01-27  7.0.4-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-6, GIT revision 19442:4747de9:20170127.\n\n2017-01-27  7.0.4-6 Cristy  <quetzlzacatenango@image...>\n  * Uninitialized data in MAT image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/362).\n  * Properly auto-fit caption (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30887).\n  * Correction to composite Over operator (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31282).\n  * Respect gravity option (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31284).\n\n2017-01-22  7.0.4-6 Glenn Randers-Pehrson <glennrp@image...>\n  * Renamed read_vpag_chunk_callback() function to png_user_chunk_callback()\n    in coders/png.c\n  * Implemented a private PNG caNv (canvas) chunk for remembering the\n    original dimensions and offsets when an image is cropped.  Previously\n    we used the oFFs and vpAg chunks for this purpose, but this had potential\n    conflicts with other applications that also use the oFFs chunk.\n  * coders/png.c: Added support for a proposed new PNG chunk (exIf\n    read-write, eXIf read-only) that is currently being discussed on the\n    png-mng-misc at lists.sourceforge.net mailing list.\n\n2017-01-22  7.0.4-6 Dirk Lemstra <dirk@lem.....org>\n  * Replaced CoderSeekableStreamFlag with CoderDecoderSeekableStreamFlag and\n    CoderEncoderSeekableStreamFlag.\n\n2017-01-21  7.0.4-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-5, GIT revision 19381:7ae396f:20170121.\n\n2017-01-18  7.0.4-5 Cristy  <quetzlzacatenango@image...>\n  * Don't set background for transparent tiled images (reference\n    http://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31210).\n\n2017-01-14  7.0.4-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-4, GIT revision 19361:a12953c:20170114.\n\n2017-01-14  7.0.4-4 Dirk Lemstra <dirk@lem.....org>\n  * Added support for RGB555, RGB565, ARGB4444 and ARGB1555 to the\n    BMP encoder (reference\n    https://github.com/ImageMagick/ImageMagick/issues/344).\n\n2017-01-10  7.0.4-4 Cristy  <quetzlzacatenango@image...>\n  * Recognize XML policy closing tags (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31182).\n  * Fix memory leak in the MPC format.\n\n2017-01-07  7.0.4-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-3, GIT revision 19329:930ca78:20170107.\n\n2017-01-04  7.0.4-3 Cristy  <quetzlzacatenango@image...>\n  * Increase memory allocation for TIFF pixels (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31161).\n\n2017-01-03  7.0.4-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-2, GIT revision 19318:8766311:20170103.\n\n2017-01-02  7.0.4-2 Cristy  <quetzlzacatenango@image...>\n  * Validation unit test for MNG works again.\n\n2016-12-31  7.0.4-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-1, GIT revision 19292:c5ccfa8:20161231.\n\n2016-12-26  7.0.4-1 Cristy  <quetzlzacatenango@image...>\n  * Initialize draw_info alpha member to OpaqueAlpha.\n  * Monochrome images no longer have inverted colors (reference\n    https://github.com/ImageMagick/ImageMagick/issues/332).\n\n2016-12-18  7.0.4-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-0, GIT revision 19221:d5e8abc:20161218.\n\n2016-12-14  7.0.4-0 Cristy  <quetzlzacatenango@image...>\n * Do not close path for linejoins of round (reference\n   https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31039).\n\n2016-12-10  7.0.3-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-10, GIT revision 19191:338f088:20161210.\n\n2016-12-07  7.0.3-10 Cristy  <quetzlzacatenango@image...>\n  * Set colorspace to sRGB if -append has non-homogenous colorspaces (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29105).\n  * Respect connected-components:area-threshold define (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31006). \n  * Enable alpha channel if background color is non-opaque (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31016).\n  * Return correct offset for negative index for -fx option (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31019).\n  * Fixed improper scaling of certain FITS images (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31028).\n  * Properly center text label (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=31027).\n\n2016-12-05  7.0.3-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-9, GIT revision 19139:6fed3f1:20161205.\n\n2016-11-26  7.0.3-9 Cristy  <quetzlzacatenango@image...>\n  * Support the compare -read-mask option.\n  * Support read-masks for the -modulate option.\n  * Prevent buffer overflow when streaming an image (reference\n    https://github.com/ImageMagick/ImageMagick/issues/312).\n  * Fix possible buffer overflow when writing compressed TIFFS (vulnerability\n    report from Cisco Talos, CVE-2016-8707).\n\n2016-11-15  7.0.3-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-8, GIT revision 19067:5aceded:20161125.\n\n2016-11-18  7.0.3-8 Cristy  <quetzlzacatenango@image...>\n  * Support the phash:colorspaces and phash:normalize options.\n  * If a convenient line break is not found, force it for caption: (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30887).\n  * Set alpha member of draw structure to OpaqueAlpha (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30894).\n  * Off by 1 error when computing the standard deviation (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=2&t=30866).\n  * Apply Debian patches, (reference\n    https://github.com/ImageMagick/ImageMagick/issues/304).\n  * Permit EPT images with just a TIFF or EPS image, not both (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30921).\n  * The -clone option no longer leaks memory.\n  * Render to clip mask rather than image for clip-path MVG graphics primitive.\n\n2016-11-15  7.0.3-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-7, GIT revision 19024:87aca83:20161115.\n\n2016-11-10  7.0.3-7 Cristy  <quetzlzacatenango@image...>\n  * Web pages were broken when we moved to HTTPS protocol.\n\n2016-11-08  7.0.3-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-6, GIT revision 19001:4cff747:20161108.\n\n2016-11-01  7.0.3-6 Cristy  <quetzlzacatenango@image...>\n  * Off by one memory allocation (reference\n    https://github.com/ImageMagick/ImageMagick/issues/296).\n  * The -extent option now matches the results of IMv6 (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=1&t=30779).\n  * Prevent fault in MSL interpreter (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30797).\n  * Mask composite produces proper results for the convert utility (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29675).\n    \n\n2016-10-10  7.0.3-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-5, GIT revision 18975:a8174a2:20161030.\n\n2016-10-16  7.0.3-5 Dirk Lemstra <dirk@lem.....org>\n  * Added layer RLE compression to the PSD encoder.\n\n2016-10-10  7.0.3-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-4, GIT revision 18937:83da034:20161010.\n\n2016-10-10  7.0.3-4 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect parsing with ordered dither. (reference\n    https://github.com/ImageMagick/ImageMagick/issues/254)\n\n2016-10-10  7.0.3-4 Cristy  <quetzlzacatenango@image...>\n  * Unit test pass again after small SUN image patch.\n\n2016-10-08  7.0.3-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-3, GIT revision 18924:d6614e7:20161008.\n\n2016-10-07  7.0.3-3 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect RLE decoding when reading a DCM image that contains\n    multiple segments.\n\n2016-10-02  7.0.3-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-2, GIT revision 18887:6b27c5b:20161002.\n\n2016-09-27  7.0.3-2 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect RLE decoding when reading an SGI image (reference \n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30514)\n\n2016-09-20  7.0.3-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-1, GIT revision 18851:ad91ea8:20160920.\n\n2016-09-16  7.0.3-1 Dirk Lemstra <dirk@lem.....org>\n  * Added layer RLE compression to the PSD encoder.\n  * Added define 'psd:preserve-opacity-mask' to preserve the opacity mask\n    in a PSD file.\n  * Fixed issue where the display window was used instead of the data window\n    when reading EXR files (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&p=137849).\n\n2016-09-05  7.0.3-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-0, GIT revision 18786:10aa64c:20160905.\n\n2016-08-29  7.0.3-0 Dirk Lemstra <dirk@lem.....org>\n  * Fixed reading DXT1 images with an alpha channel.\n  * Fixed incorrect padding calculation in PSD encoder.\n\n2016-08-27  7.0.2-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-10, GIT revision 18750:e3335b3:20160827.\n\n2016-08-27  7.0.2-10 Dirk Lemstra <dirk@lem.....org>\n  * Added define 'psd:additional-info' to preserve the additional information\n    in a PSD file.\n\n2016-08-15  7.0.2-10 Cristy  <quetzlzacatenango@image...>\n  * Prevent buffer overflow in BMP & SGI coders (bug report from\n    pwchen&rayzhong of tencent).\n  * Prevent buffer overflow and other problems in SIXEL, PDB, MAP, TIFF and\n    CALS coders (bug report from Donghai Zhu).\n  * The -stream option now increments the pixel pointer properly (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30327).\n\n2016-08-14  7.0.2-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-9, GIT revision 18707:2c02f09:20160814.\n\n2016-08-14  7.0.2-9 Cristy  <quetzlzacatenango@image...>\n  * Fix compile error in opencl.c (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30289).\n  * Eliminate compiler warning.\n\n2016-08-14  7.0.2-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-8, GIT revision 18698:74b1d5d:20160814.\n\n2016-08-07  7.0.2-8 Cristy  <quetzlzacatenango@image...>\n  * Prevent spurious removal of MPC cache files (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30256).\n  * Note alpha channel when combining 4 or more images (reference\n    https://github.com/ImageMagick/ImageMagick/issues/250).\n\n2016-08-06  7.0.2-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-7, GIT revision 10980:ecc03a2:20160806.\n\n2016-08-01  7.0.2-7 Cristy  <quetzlzacatenango@image...>\n  * Evaluate lazy pixel cache morphology to prevent buffer overflow (bug report\n    from Ibrahim M. El-Sayed).\n  * Prevent buffer overflow (bug report from Max Thrane).\n  * Prevent memory use after free (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30245).\n\n2016-07-30  7.0.2-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-6, GIT revision 18651:df24175:20160729.\n\n2016-07-29  7.0.2-6 Cristy  <quetzlzacatenango@image...>\n  * Support -region option (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=1&t=29692).\n\n2016-07-21  7.0.2-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-5, GIT revision 18627:2b5ddbd:20160721.\n\n2016-07-13  7.0.2-5 Cristy  <quetzlzacatenango@image...>\n  * Fix MVG stroke-opacity (reference\n    https://github.com/ImageMagick/ImageMagick/issues/229).\n  * Prevent possible buffer overflow when reading TIFF images (bug report from\n    Shi Pu of MS509 Team).\n  * Initialize index channel to get expected results from the stegano coder.\n\n2016-07-11  7.0.2-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-4, GIT revision 18591:50debe5:20160710.\n\n2016-07-10  7.0.2-4 Cristy  <quetzlzacatenango@image...>\n  * To comply with the SVG standard, use stroke-opacity for transparent strokes.\n  * Define CompositeChannels mask to Red, Green, Blue, Alpha, and Black.\n\n2016-07-09  7.0.2-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-3, GIT revision 18572:28560fc:20160709.\n\n2016-07-01  7.0.2-3 Cristy  <quetzlzacatenango@image...>\n  * Patch so -kuwahara option can preserve colormapped edges.\n  * The histogram coder now returns the correct extent.\n  * Use CopyMagickString() rather than CopyMagickMemory() for strings.\n\n2016-06-26  7.0.2-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-2, GIT revision 18514:a7b5b46:20160626.\n\n2016-06-23  7.0.2-2 Cristy  <quetzlzacatenango@image...>\n  * Correct for numerical instability (reference\n    https://github.com/ImageMagick/ImageMagick/issues/218).\n\t\t\t \n2016-06-21  7.0.2-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-1, GIT revision 18479:931319b:20160622.\n\n2016-06-17  7.0.2-1 Dirk Lemstra <dirk@lem.....org>\n  * Added support for GROUP4 compression to the FAX coder.\n\n2016-06-12  7.0.2-1 Cristy  <quetzlzacatenango@image...>\n  * Distort no longer converts grayscale image to sRGB (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=1&t=29895).\n  * Don't return a zero bounding box for QueryMultilineFontMetrics() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/222).\n\n2016-06-12  7.0.2-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-0, GIT revision 10884:f0e15e8:20160612.\n\n2016-06-09  7.0.2-0 Cristy  <quetzlzacatenango@image...>\n  * Backoff finite precision epsilon (reference\n    https://github.com/ImageMagick/ImageMagick/issues/215).\n  * Fix drawing glitch for stroke widths greater than 2 (reference\n    https://github.com/ImageMagick/ImageMagick/issues/218).\n\n2016-06-05  7.0.1-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-10, GIT revision 18406:ba4ad2d:20160607.\n\n2016-06-04  7.0.1-10 Cristy  <quetzlzacatenango@image...>\n  * Deny indirect reads by policy, remove policy to permit, e.g.,\n    convert caption:@mytext.txt ...\n  * RLE check for pixel offset less than 0 (heap overflow report from Craig\n    Young).\n  * Properly initialze PES blocks (reference\n    https://github.com/ImageMagick/ImageMagick/issues/213).\n\n2016-06-03  7.0.1-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-9, GIT revision 10847:339f803:20160602.\n\n2016-06-02  7.0.1-9 Cristy  <quetzlzacatenango@image...>\n  * Fix small memory leak (patch provided by \u0410\u043d\u0434\u0440\u0435\u0439 \u0427\u0435\u0440\u043d\u044b\u0439).\n  * Coder path traversal is not authorized (bug report provided by\n    Masaaki Chida).\n  * Turn off alpha channel for the compare difference image (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29828).\n\n2016-05-31  7.0.1-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-8, GIT revision 18334:97775b5:20160531.\n\n2016-05-31  7.0.1-8 Cristy  <quetzlzacatenango@image...>\n  * Support configure script --enable-pipes option to enable pipes (|) in\n    filenames.\n  * Support configure script --enable-indirect-reads option to enable\n    indirect reads (@) in filenames.\n\n2016-05-30  7.0.1-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-7, GIT revision 18321:5511ef5:20160530.\n\n2016-05-25  7.0.1-7 Cristy  <quetzlzacatenango@image...>\n  * Security improvements to TEXT coder broke it (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29754).\n  * Fix stroke offset problem for -annotate (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29626).\n  * Don't interpret -fx option arguments (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29774);\n  * Add additional checks to DCM reader to prevent data-driven faults (bug\n    report from Hanno B\u00f6ck).\n\n2016-05-21  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-6, GIT revision 18241:d4f277c:20160521.\n\n2016-05-20  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n  * Fixed proper placement of text annotation for east / west gravity.\n\n2016-05-18  7.0.1-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-5, GIT revision 10789:f7c2e89:20160518,\n\n2016-05-18  7.0.1-5 Cristy  <quetzlzacatenango@image...>\n  * Process channels independently for -channel -equalize (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29708).\n  * Fix pixel cache on disk regression (reference\n    https://github.com/ImageMagick/ImageMagick/issues/202).\n\n2016-05-15  7.0.1-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-4, GIT revision 10778:52dae14:20160516.\n\n2016-05-10  7.0.1-4 Cristy  <quetzlzacatenango@image...>\n  * Prevent possible shell command injection vulnerability through the\n    authenticate parameter of the PDF, PCL and XPS coders (report from\n    Erez Turjeman).\n  * Quote passwords when passed to a delegate program.\n  * Iterate channels over source image rather than destination (bug report\n    from Hanno B\u00f6ck).\n  * Can read geo-related EXIF metdata once-again (reference\n    https://github.com/ImageMagick/ImageMagick/issues/198).\n  * Sanitize all delegate emedded formatting characters.\n  * Don't sync pixel cache in AcquireAuthenticCacheView() (bug report from\n    Hanno B\u00f6ck).\n\n2016-05-09  7.0.1-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-3, GIT revision 10755:d540dda:20160509.\n\n2016-05-07  7.0.1-3 Cristy  <quetzlzacatenango@image...>\n  * Remove https delegate.\n\n2016-05-06  7.0.1-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-2, GIT revision 10741:5746147:20160507.\n\n2016-05-04  7.0.1-2 Cristy  <quetzlzacatenango@image...>\n  * Check for buffer overflow in magick/draw.c/DrawStrokePolygon().\n  * Replace show delegate title with image filename rather than label.\n  * Fix GetNextToken() off by one error.\n  * Remove support for internal ephemeral coder.\n\n2016-05-03  7.0.1-1 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.1-1, GIT revision 10723:9fc8a0c:20160503.\n\n2016-05-03  7.0.1-1 Cristy  <quetzlzacatenango@image...>\n  * Sanitize input filename for http / https delegates (improved patch).\n  * Fix for possible security vulnerabilities (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=4&t=29588).\n\n2016-04-30  7.0.1-0 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.1-0, GIT revision 10716:b527bce:20160430.\n\n2016-01-30  7.0.0-0 \tFahad-Alsaidi & ShamsaHamed\n  * Add support for languages that require complex text layout (reference\n    https://github.com/ImageMagick/ImageMagick/pull/88).\n\n2012-04-27  7.0.0-0 Anthony thyssen <A.Thyssen@griffith...>\n  * Allow the use of set and escapes when no images in memory\n    (unless you attempt to access per-image meta-data)\n    Currently does not include %[fx:...] and %[pixel:...]\n\n2012-10-05  7.0.0-0 Anthony thyssen <A.Thyssen@griffith...>\n  * Rather than replicate 'options' into 'artifacts' make a link\n    from image to image_info and lookup a global option if no artifact\n    is defined.\n\n2012-09-11  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * sigmoidal-contrast:\n  * Remove unnecessary initial ClampToQuantum.\n\n2012-09-10  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * sigmoidal-contrast:\n  * Direct computation, without LUT;\n  * Fix re-declaration of i (at the top, and inside a conditional).\n\n2012-09-04  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * Add tanh/atanh clone of legacy sigmoidal map (faster & more accurate).\n\n2012-08-08  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * Add final ClampToQuantum in sigmoidal colormap loop.\n  * Remove OpenMP calls from colormap update loops.\n\n2011-08-01  7.0.0-0 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.0-0.\n\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                             M   M  SSSSS  L                                 %\n%                             MM MM  SS     L                                 %\n%                             M M M   SSS   L                                 %\n%                             M   M     SS  L                                 %\n%                             M   M  SSSSS  LLLLL                             %\n%                                                                             %\n%                                                                             %\n%                    Execute Magick Scripting Language Scripts.               %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                             Leonard Rosenthol                               %\n%                             William Radcliffe                               %\n%                               December 2001                                 %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/annotate.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/decorate.h\"\n#include \"MagickCore/display.h\"\n#include \"MagickCore/distort.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/effect.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/fx.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/paint.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/registry.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/segment.h\"\n#include \"MagickCore/shear.h\"\n#include \"MagickCore/signature.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/threshold.h\"\n#include \"MagickCore/utility.h\"\n#if defined(MAGICKCORE_XML_DELEGATE)\n#  if defined(MAGICKCORE_WINDOWS_SUPPORT)\n#    if !defined(__MINGW32__) && !defined(__MINGW64__)\n#      include <win32config.h>\n#    endif\n#  endif\n#  include <libxml/parser.h>\n#  include <libxml/xmlmemory.h>\n#  include <libxml/parserInternals.h>\n#  include <libxml/xmlerror.h>\n#endif\n\f\n/*\n  Define Declatations.\n*/\n#define ThrowMSLException(severity,tag,reason) \\\n  (void) ThrowMagickException(msl_info->exception,GetMagickModule(),severity, \\\n    tag,\"`%s'\",reason);\n\f\n/*\n  Typedef declaractions.\n*/\ntypedef struct _MSLGroupInfo\n{\n  size_t\n    numImages;  /* how many images are in this group */\n} MSLGroupInfo;\n\ntypedef struct _MSLInfo\n{\n  ExceptionInfo\n    *exception;\n\n  ssize_t\n    n,\n    number_groups;\n\n  ImageInfo\n    **image_info;\n\n  DrawInfo\n   **draw_info;\n\n  Image\n    **attributes,\n    **image;\n\n  char\n    *content;\n\n  MSLGroupInfo\n    *group_info;\n\n#if defined(MAGICKCORE_XML_DELEGATE)\n  xmlParserCtxtPtr\n    parser;\n\n  xmlDocPtr\n    document;\n#endif\n} MSLInfo;\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_XML_DELEGATE)\nstatic MagickBooleanType\n  WriteMSLImage(const ImageInfo *,Image *,ExceptionInfo *);\n\nstatic MagickBooleanType\n  SetMSLAttributes(MSLInfo *,const char *,const char *);\n#endif\n\f\n#if defined(MAGICKCORE_XML_DELEGATE)\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d M S L I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadMSLImage() reads a Magick Scripting Language file and returns it.\n%  It allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadMSLImage method is:\n%\n%      Image *ReadMSLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic inline Image *GetImageCache(const ImageInfo *image_info,const char *path,\n  ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent];\n\n  ExceptionInfo\n    *sans_exception;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  (void) FormatLocaleString(key,MagickPathExtent,\"cache:%s\",path);\n  sans_exception=AcquireExceptionInfo();\n  image=(Image *) GetImageRegistry(ImageRegistryType,key,sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if (image != (Image *) NULL)\n    return(image);\n  read_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(read_info->filename,path,MagickPathExtent);\n  image=ReadImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    (void) SetImageRegistry(ImageRegistryType,key,image,exception);\n  return(image);\n}\n\nstatic int IsPathDirectory(const char *path)\n{\n  MagickBooleanType\n    status;\n\n  struct stat\n    attributes;\n\n  if ((path == (const char *) NULL) || (*path == '\\0'))\n    return(MagickFalse);\n  status=GetPathAttributes(path,&attributes);\n  if (status == MagickFalse)\n    return(-1);\n  if (S_ISDIR(attributes.st_mode) == 0)\n    return(0);\n  return(1);\n}\n\nstatic int MSLIsStandalone(void *context)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    Is this document tagged standalone?\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.MSLIsStandalone()\");\n  msl_info=(MSLInfo *) context;\n  return(msl_info->document->standalone == 1);\n}\n\nstatic int MSLHasInternalSubset(void *context)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    Does this document has an internal subset?\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.MSLHasInternalSubset()\");\n  msl_info=(MSLInfo *) context;\n  return(msl_info->document->intSubset != NULL);\n}\n\nstatic int MSLHasExternalSubset(void *context)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    Does this document has an external subset?\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.MSLHasExternalSubset()\");\n  msl_info=(MSLInfo *) context;\n  return(msl_info->document->extSubset != NULL);\n}\n\nstatic void MSLInternalSubset(void *context,const xmlChar *name,\n  const xmlChar *external_id,const xmlChar *system_id)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    Does this document has an internal subset?\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.internalSubset(%s %s %s)\",name,\n    (external_id != (const xmlChar *) NULL ? (const char *) external_id : \" \"),\n    (system_id != (const xmlChar *) NULL ? (const char *) system_id : \" \"));\n  msl_info=(MSLInfo *) context;\n  (void) xmlCreateIntSubset(msl_info->document,name,external_id,system_id);\n}\n\nstatic xmlParserInputPtr MSLResolveEntity(void *context,\n  const xmlChar *public_id,const xmlChar *system_id)\n{\n  MSLInfo\n    *msl_info;\n\n  xmlParserInputPtr\n    stream;\n\n  /*\n    Special entity resolver, better left to the parser, it has more\n    context than the application layer.  The default behaviour is to\n    not resolve the entities, in that case the ENTITY_REF nodes are\n    built in the structure (and the parameter values).\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.resolveEntity(%s, %s)\",\n    (public_id != (const xmlChar *) NULL ? (const char *) public_id : \"none\"),\n    (system_id != (const xmlChar *) NULL ? (const char *) system_id : \"none\"));\n  msl_info=(MSLInfo *) context;\n  stream=xmlLoadExternalEntity((const char *) system_id,(const char *)\n    public_id,msl_info->parser);\n  return(stream);\n}\n\nstatic xmlEntityPtr MSLGetEntity(void *context,const xmlChar *name)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    Get an entity by name.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.MSLGetEntity(%s)\",(const char *) name);\n  msl_info=(MSLInfo *) context;\n  return(xmlGetDocEntity(msl_info->document,name));\n}\n\nstatic xmlEntityPtr MSLGetParameterEntity(void *context,const xmlChar *name)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    Get a parameter entity by name.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.getParameterEntity(%s)\",(const char *) name);\n  msl_info=(MSLInfo *) context;\n  return(xmlGetParameterEntity(msl_info->document,name));\n}\n\nstatic void MSLEntityDeclaration(void *context,const xmlChar *name,int type,\n  const xmlChar *public_id,const xmlChar *system_id,xmlChar *content)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    An entity definition has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.entityDecl(%s, %d, %s, %s, %s)\",name,type,\n    public_id != (const xmlChar *) NULL ? (const char *) public_id : \"none\",\n    system_id != (const xmlChar *) NULL ? (const char *) system_id : \"none\",\n    content);\n  msl_info=(MSLInfo *) context;\n  if (msl_info->parser->inSubset == 1)\n    (void) xmlAddDocEntity(msl_info->document,name,type,public_id,system_id,\n      content);\n  else\n    if (msl_info->parser->inSubset == 2)\n      (void) xmlAddDtdEntity(msl_info->document,name,type,public_id,system_id,\n        content);\n}\n\nstatic void MSLAttributeDeclaration(void *context,const xmlChar *element,\n  const xmlChar *name,int type,int value,const xmlChar *default_value,\n  xmlEnumerationPtr tree)\n{\n  MSLInfo\n    *msl_info;\n\n  xmlChar\n    *fullname,\n    *prefix;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    An attribute definition has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.attributeDecl(%s, %s, %d, %d, %s, ...)\\n\",element,name,type,value,\n    default_value);\n  msl_info=(MSLInfo *) context;\n  fullname=(xmlChar *) NULL;\n  prefix=(xmlChar *) NULL;\n  parser=msl_info->parser;\n  fullname=(xmlChar *) xmlSplitQName(parser,name,&prefix);\n  if (parser->inSubset == 1)\n    (void) xmlAddAttributeDecl(&parser->vctxt,msl_info->document->intSubset,\n      element,fullname,prefix,(xmlAttributeType) type,\n      (xmlAttributeDefault) value,default_value,tree);\n  else\n    if (parser->inSubset == 2)\n      (void) xmlAddAttributeDecl(&parser->vctxt,msl_info->document->extSubset,\n        element,fullname,prefix,(xmlAttributeType) type,\n        (xmlAttributeDefault) value,default_value,tree);\n  if (prefix != (xmlChar *) NULL)\n    xmlFree(prefix);\n  if (fullname != (xmlChar *) NULL)\n    xmlFree(fullname);\n}\n\nstatic void MSLElementDeclaration(void *context,const xmlChar *name,int type,\n  xmlElementContentPtr content)\n{\n  MSLInfo\n    *msl_info;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    An element definition has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.elementDecl(%s, %d, ...)\",name,type);\n  msl_info=(MSLInfo *) context;\n  parser=msl_info->parser;\n  if (parser->inSubset == 1)\n    (void) xmlAddElementDecl(&parser->vctxt,msl_info->document->intSubset,\n      name,(xmlElementTypeVal) type,content);\n  else\n    if (parser->inSubset == 2)\n      (void) xmlAddElementDecl(&parser->vctxt,msl_info->document->extSubset,\n        name,(xmlElementTypeVal) type,content);\n}\n\nstatic void MSLNotationDeclaration(void *context,const xmlChar *name,\n  const xmlChar *public_id,const xmlChar *system_id)\n{\n  MSLInfo\n    *msl_info;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    What to do when a notation declaration has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.notationDecl(%s, %s, %s)\",name,\n    public_id != (const xmlChar *) NULL ? (const char *) public_id : \"none\",\n    system_id != (const xmlChar *) NULL ? (const char *) system_id : \"none\");\n  msl_info=(MSLInfo *) context;\n  parser=msl_info->parser;\n  if (parser->inSubset == 1)\n    (void) xmlAddNotationDecl(&parser->vctxt,msl_info->document->intSubset,\n      name,public_id,system_id);\n  else\n    if (parser->inSubset == 2)\n      (void) xmlAddNotationDecl(&parser->vctxt,msl_info->document->intSubset,\n        name,public_id,system_id);\n}\n\nstatic void MSLUnparsedEntityDeclaration(void *context,const xmlChar *name,\n  const xmlChar *public_id,const xmlChar *system_id,const xmlChar *notation)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    What to do when an unparsed entity declaration is parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.unparsedEntityDecl(%s, %s, %s, %s)\",name,\n    public_id != (const xmlChar *) NULL ? (const char *) public_id : \"none\",\n    system_id != (const xmlChar *) NULL ? (const char *) system_id : \"none\",\n    notation);\n  msl_info=(MSLInfo *) context;\n  (void) xmlAddDocEntity(msl_info->document,name,\n    XML_EXTERNAL_GENERAL_UNPARSED_ENTITY,public_id,system_id,notation);\n\n}\n\nstatic void MSLSetDocumentLocator(void *context,xmlSAXLocatorPtr location)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    Receive the document locator at startup, actually xmlDefaultSAXLocator.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.setDocumentLocator()\\n\");\n  (void) location;\n  msl_info=(MSLInfo *) context;\n  (void) msl_info;\n}\n\nstatic void MSLStartDocument(void *context)\n{\n  MSLInfo\n    *msl_info;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    Called when the document start being processed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.startDocument()\");\n  msl_info=(MSLInfo *) context;\n  parser=msl_info->parser;\n  msl_info->document=xmlNewDoc(parser->version);\n  if (msl_info->document == (xmlDocPtr) NULL)\n    return;\n  if (parser->encoding == NULL)\n    msl_info->document->encoding=NULL;\n  else\n    msl_info->document->encoding=xmlStrdup(parser->encoding);\n  msl_info->document->standalone=parser->standalone;\n}\n\nstatic void MSLEndDocument(void *context)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    Called when the document end has been detected.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.endDocument()\");\n  msl_info=(MSLInfo *) context;\n  if (msl_info->content != (char *) NULL)\n    msl_info->content=DestroyString(msl_info->content);\n}\n\nstatic void MSLPushImage(MSLInfo *msl_info,Image *image)\n{\n  ssize_t\n    n;\n\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(msl_info != (MSLInfo *) NULL);\n  msl_info->n++;\n  n=msl_info->n;\n  msl_info->image_info=(ImageInfo **) ResizeQuantumMemory(msl_info->image_info,\n    (n+1),sizeof(*msl_info->image_info));\n  msl_info->draw_info=(DrawInfo **) ResizeQuantumMemory(msl_info->draw_info,\n    (n+1),sizeof(*msl_info->draw_info));\n  msl_info->attributes=(Image **) ResizeQuantumMemory(msl_info->attributes,\n    (n+1),sizeof(*msl_info->attributes));\n  msl_info->image=(Image **) ResizeQuantumMemory(msl_info->image,(n+1),\n    sizeof(*msl_info->image));\n  if ((msl_info->image_info == (ImageInfo **) NULL) ||\n      (msl_info->draw_info == (DrawInfo **) NULL) ||\n      (msl_info->attributes == (Image **) NULL) ||\n      (msl_info->image == (Image **) NULL))\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\")\n  msl_info->image_info[n]=CloneImageInfo(msl_info->image_info[n-1]);\n  msl_info->draw_info[n]=CloneDrawInfo(msl_info->image_info[n-1],\n    msl_info->draw_info[n-1]);\n  if (image == (Image *) NULL)\n    msl_info->attributes[n]=AcquireImage(msl_info->image_info[n],\n      msl_info->exception);\n  else\n    msl_info->attributes[n]=CloneImage(image,0,0,MagickTrue,\n      msl_info->exception);\n  msl_info->image[n]=(Image *) image;\n  if ((msl_info->image_info[n] == (ImageInfo *) NULL) ||\n      (msl_info->attributes[n] == (Image *) NULL))\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\")\n  if (msl_info->number_groups != 0)\n    msl_info->group_info[msl_info->number_groups-1].numImages++;\n}\n\nstatic void MSLPopImage(MSLInfo *msl_info)\n{\n  if (msl_info->number_groups != 0)\n    return;\n  if (msl_info->image[msl_info->n] != (Image *) NULL)\n    msl_info->image[msl_info->n]=DestroyImage(msl_info->image[msl_info->n]);\n  msl_info->attributes[msl_info->n]=DestroyImage(\n    msl_info->attributes[msl_info->n]);\n  msl_info->image_info[msl_info->n]=DestroyImageInfo(\n    msl_info->image_info[msl_info->n]);\n  msl_info->n--;\n}\n\nstatic void MSLStartElement(void *context,const xmlChar *tag,\n  const xmlChar **attributes)\n{\n  AffineMatrix\n    affine,\n    current;\n\n  ChannelType\n    channel;\n\n  ChannelType\n    channel_mask;\n\n  char\n    *attribute,\n    key[MagickPathExtent],\n    *value;\n\n  const char\n    *keyword;\n\n  double\n    angle;\n\n  DrawInfo\n    *draw_info;\n\n  ExceptionInfo\n    *exception;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image;\n\n  int\n    flags;\n\n  ssize_t\n    option,\n    j,\n    n,\n    x,\n    y;\n\n  MSLInfo\n    *msl_info;\n\n  RectangleInfo\n    geometry;\n\n  register ssize_t\n    i;\n\n  size_t\n    height,\n    width;\n\n  /*\n    Called when an opening tag has been processed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.startElement(%s\",tag);\n  exception=AcquireExceptionInfo();\n  msl_info=(MSLInfo *) context;\n  n=msl_info->n;\n  keyword=(const char *) NULL;\n  value=(char *) NULL;\n  SetGeometryInfo(&geometry_info);\n  (void) ResetMagickMemory(&geometry,0,sizeof(geometry));\n  channel=DefaultChannels;\n  switch (*tag)\n  {\n    case 'A':\n    case 'a':\n    {\n      if (LocaleCompare((const char *) tag,\"add-noise\") == 0)\n        {\n          Image\n            *noise_image;\n\n          NoiseType\n            noise;\n\n          /*\n            Add noise image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          noise=UniformNoise;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"channel\") == 0)\n                    {\n                      option=ParseChannelOption(value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedChannelType\",\n                          value);\n                      channel=(ChannelType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'N':\n                case 'n':\n                {\n                  if (LocaleCompare(keyword,\"noise\") == 0)\n                    {\n                      option=ParseCommandOption(MagickNoiseOptions,MagickFalse,\n                        value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedNoiseType\",\n                          value);\n                      noise=(NoiseType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          channel_mask=SetImageChannelMask(msl_info->image[n],channel);\n          noise_image=AddNoiseImage(msl_info->image[n],noise,1.0,\n            msl_info->exception);\n          (void) SetPixelChannelMask(msl_info->image[n],channel_mask);\n          if (noise_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=noise_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"annotate\") == 0)\n        {\n          char\n            text[MagickPathExtent];\n\n          /*\n            Annotate image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          draw_info=CloneDrawInfo(msl_info->image_info[n],\n            msl_info->draw_info[n]);\n          angle=0.0;\n          current=draw_info->affine;\n          GetAffineMatrix(&affine);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'A':\n                case 'a':\n                {\n                  if (LocaleCompare(keyword,\"affine\") == 0)\n                    {\n                      char\n                        *p;\n\n                      p=value;\n                      draw_info->affine.sx=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.rx=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.ry=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.sy=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.tx=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.ty=StringToDouble(p,&p);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"align\") == 0)\n                    {\n                      option=ParseCommandOption(MagickAlignOptions,MagickFalse,\n                        value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedAlignType\",\n                          value);\n                      draw_info->align=(AlignType) option;\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"antialias\") == 0)\n                    {\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedBooleanType\",\n                          value);\n                      draw_info->stroke_antialias=(MagickBooleanType) option;\n                      draw_info->text_antialias=(MagickBooleanType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'D':\n                case 'd':\n                {\n                  if (LocaleCompare(keyword,\"density\") == 0)\n                    {\n                      CloneString(&draw_info->density,value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'E':\n                case 'e':\n                {\n                  if (LocaleCompare(keyword,\"encoding\") == 0)\n                    {\n                      CloneString(&draw_info->encoding,value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword, \"fill\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &draw_info->fill,exception);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"family\") == 0)\n                    {\n                      CloneString(&draw_info->family,value);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"font\") == 0)\n                    {\n                      CloneString(&draw_info->font,value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGravityGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"gravity\") == 0)\n                    {\n                      option=ParseCommandOption(MagickGravityOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedGravityType\",\n                          value);\n                      draw_info->gravity=(GravityType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'P':\n                case 'p':\n                {\n                  if (LocaleCompare(keyword,\"pointsize\") == 0)\n                    {\n                      draw_info->pointsize=StringToDouble(value,(char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"rotate\") == 0)\n                    {\n                      angle=StringToDouble(value,(char **) NULL);\n                      affine.sx=cos(DegreesToRadians(fmod(angle,360.0)));\n                      affine.rx=sin(DegreesToRadians(fmod(angle,360.0)));\n                      affine.ry=(-sin(DegreesToRadians(fmod(angle,360.0))));\n                      affine.sy=cos(DegreesToRadians(fmod(angle,360.0)));\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'S':\n                case 's':\n                {\n                  if (LocaleCompare(keyword,\"scale\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      affine.sx=geometry_info.rho;\n                      affine.sy=geometry_info.sigma;\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"skewX\") == 0)\n                    {\n                      angle=StringToDouble(value,(char **) NULL);\n                      affine.ry=tan(DegreesToRadians(fmod((double) angle,\n                        360.0)));\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"skewY\") == 0)\n                    {\n                      angle=StringToDouble(value,(char **) NULL);\n                      affine.rx=tan(DegreesToRadians(fmod((double) angle,\n                        360.0)));\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"stretch\") == 0)\n                    {\n                      option=ParseCommandOption(MagickStretchOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedStretchType\",\n                          value);\n                      draw_info->stretch=(StretchType) option;\n                      break;\n                    }\n                  if (LocaleCompare(keyword, \"stroke\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &draw_info->stroke,exception);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"strokewidth\") == 0)\n                    {\n                      draw_info->stroke_width=StringToLong(value);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"style\") == 0)\n                    {\n                      option=ParseCommandOption(MagickStyleOptions,MagickFalse,\n                        value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedStyleType\",\n                          value);\n                      draw_info->style=(StyleType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'T':\n                case 't':\n                {\n                  if (LocaleCompare(keyword,\"text\") == 0)\n                    {\n                      CloneString(&draw_info->text,value);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"translate\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      affine.tx=geometry_info.rho;\n                      affine.ty=geometry_info.sigma;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'U':\n                case 'u':\n                {\n                  if (LocaleCompare(keyword, \"undercolor\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &draw_info->undercolor,exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"weight\") == 0)\n                    {\n                      draw_info->weight=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry.x=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry.y=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) FormatLocaleString(text,MagickPathExtent,\n            \"%.20gx%.20g%+.20g%+.20g\",(double) geometry.width,(double)\n            geometry.height,(double) geometry.x,(double) geometry.y);\n          CloneString(&draw_info->geometry,text);\n          draw_info->affine.sx=affine.sx*current.sx+affine.ry*current.rx;\n          draw_info->affine.rx=affine.rx*current.sx+affine.sy*current.rx;\n          draw_info->affine.ry=affine.sx*current.ry+affine.ry*current.sy;\n          draw_info->affine.sy=affine.rx*current.ry+affine.sy*current.sy;\n          draw_info->affine.tx=affine.sx*current.tx+affine.ry*current.ty+\n            affine.tx;\n          draw_info->affine.ty=affine.rx*current.tx+affine.sy*current.ty+\n            affine.ty;\n          (void) AnnotateImage(msl_info->image[n],draw_info,\n            msl_info->exception);\n          draw_info=DestroyDrawInfo(draw_info);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"append\") == 0)\n        {\n          Image\n            *append_image;\n\n          MagickBooleanType\n            stack;\n\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          stack=MagickFalse;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'S':\n                case 's':\n                {\n                  if (LocaleCompare(keyword,\"stack\") == 0)\n                    {\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedBooleanType\",\n                          value);\n                      stack=(MagickBooleanType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          append_image=AppendImages(msl_info->image[n],stack,\n            msl_info->exception);\n          if (append_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=append_image;\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n      break;\n    }\n    case 'B':\n    case 'b':\n    {\n      if (LocaleCompare((const char *) tag,\"blur\") == 0)\n        {\n          Image\n            *blur_image;\n\n          /*\n            Blur image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"channel\") == 0)\n                    {\n                      option=ParseChannelOption(value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedChannelType\",\n                          value);\n                      channel=(ChannelType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"radius\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,(char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'S':\n                case 's':\n                {\n                  if (LocaleCompare(keyword,\"sigma\") == 0)\n                    {\n                      geometry_info.sigma=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          channel_mask=SetImageChannelMask(msl_info->image[n],channel);\n          blur_image=BlurImage(msl_info->image[n],geometry_info.rho,\n            geometry_info.sigma,msl_info->exception);\n          (void) SetPixelChannelMask(msl_info->image[n],channel_mask);\n          if (blur_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=blur_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"border\") == 0)\n        {\n          Image\n            *border_image;\n\n          /*\n            Border image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          SetGeometry(msl_info->image[n],&geometry);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"compose\") == 0)\n                    {\n                      option=ParseCommandOption(MagickComposeOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedComposeType\",\n                          value);\n                      msl_info->image[n]->compose=(CompositeOperator) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword, \"fill\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &msl_info->image[n]->border_color,exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParsePageGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      if ((flags & HeightValue) == 0)\n                        geometry.height=geometry.width;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'H':\n                case 'h':\n                {\n                  if (LocaleCompare(keyword,\"height\") == 0)\n                    {\n                      geometry.height=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"width\") == 0)\n                    {\n                      geometry.width=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          border_image=BorderImage(msl_info->image[n],&geometry,\n            msl_info->image[n]->compose,msl_info->exception);\n          if (border_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=border_image;\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'C':\n    case 'c':\n    {\n      if (LocaleCompare((const char *) tag,\"colorize\") == 0)\n        {\n          char\n            blend[MagickPathExtent];\n\n          Image\n            *colorize_image;\n\n          PixelInfo\n            target;\n\n          /*\n            Add noise image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          GetPixelInfo(msl_info->image[n],&target);\n          (void) CopyMagickString(blend,\"100\",MagickPathExtent);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'B':\n                case 'b':\n                {\n                  if (LocaleCompare(keyword,\"blend\") == 0)\n                    {\n                      (void) CopyMagickString(blend,value,MagickPathExtent);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword,\"fill\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &target,msl_info->exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          colorize_image=ColorizeImage(msl_info->image[n],blend,&target,\n            msl_info->exception);\n          if (colorize_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=colorize_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag, \"charcoal\") == 0)\n      {\n        double \n            radius = 0.0,\n            sigma = 1.0;\n\n        if (msl_info->image[n] == (Image *) NULL)\n        {\n          ThrowMSLException(OptionError,\"NoImagesDefined\",\n            (const char *) tag);\n          break;\n        }\n        /*\n          NOTE: charcoal can have no attributes, since we use all the defaults!\n        */\n        if (attributes != (const xmlChar **) NULL)\n        {\n          for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n          {\n            keyword=(const char *) attributes[i++];\n            attribute=InterpretImageProperties(msl_info->image_info[n],\n              msl_info->attributes[n],(const char *) attributes[i],exception);\n            CloneString(&value,attribute);\n            attribute=DestroyString(attribute);\n          switch (*keyword)\n          {\n            case 'R':\n            case 'r':\n            {\n              if (LocaleCompare(keyword,\"radius\") == 0)\n              {\n                radius=StringToDouble(value,(char **) NULL);\n                break;\n              }\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n            case 'S':\n            case 's':\n            {\n              if (LocaleCompare(keyword,\"sigma\") == 0)\n              {\n                sigma = StringToLong( value );\n                break;\n              }\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n            default:\n            {\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n          }\n          }\n        }\n\n        /*\n          charcoal image.\n        */\n        {\n        Image\n          *newImage;\n\n        newImage=CharcoalImage(msl_info->image[n],radius,sigma,\n          msl_info->exception);\n        if (newImage == (Image *) NULL)\n          break;\n        msl_info->image[n]=DestroyImage(msl_info->image[n]);\n        msl_info->image[n]=newImage;\n        break;\n        }\n      }\n      if (LocaleCompare((const char *) tag,\"chop\") == 0)\n        {\n          Image\n            *chop_image;\n\n          /*\n            Chop image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          SetGeometry(msl_info->image[n],&geometry);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParsePageGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      if ((flags & HeightValue) == 0)\n                        geometry.height=geometry.width;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'H':\n                case 'h':\n                {\n                  if (LocaleCompare(keyword,\"height\") == 0)\n                    {\n                      geometry.height=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"width\") == 0)\n                    {\n                      geometry.width=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry.x=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry.y=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          chop_image=ChopImage(msl_info->image[n],&geometry,\n            msl_info->exception);\n          if (chop_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=chop_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"color-floodfill\") == 0)\n        {\n          PaintMethod\n            paint_method;\n\n          PixelInfo\n            target;\n\n          /*\n            Color floodfill image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          draw_info=CloneDrawInfo(msl_info->image_info[n],\n            msl_info->draw_info[n]);\n          SetGeometry(msl_info->image[n],&geometry);\n          paint_method=FloodfillMethod;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'B':\n                case 'b':\n                {\n                  if (LocaleCompare(keyword,\"bordercolor\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &target,exception);\n                      paint_method=FillToBorderMethod;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword,\"fill\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &draw_info->fill,exception);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"fuzz\") == 0)\n                    {\n                      msl_info->image[n]->fuzz=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParsePageGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      if ((flags & HeightValue) == 0)\n                        geometry.height=geometry.width;\n                      (void) GetOneVirtualPixelInfo(msl_info->image[n],\n                        TileVirtualPixelMethod,geometry.x,geometry.y,&target,\n                        exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry.x=StringToLong(value);\n                      (void) GetOneVirtualPixelInfo(msl_info->image[n],\n                        TileVirtualPixelMethod,geometry.x,geometry.y,&target,\n                        exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry.y=StringToLong(value);\n                      (void) GetOneVirtualPixelInfo(msl_info->image[n],\n                        TileVirtualPixelMethod,geometry.x,geometry.y,&target,\n                        exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) FloodfillPaintImage(msl_info->image[n],draw_info,&target,\n            geometry.x,geometry.y,paint_method == FloodfillMethod ?\n            MagickFalse : MagickTrue,msl_info->exception);\n          draw_info=DestroyDrawInfo(draw_info);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"comment\") == 0)\n        break;\n      if (LocaleCompare((const char *) tag,\"composite\") == 0)\n        {\n          char\n            composite_geometry[MagickPathExtent];\n\n          CompositeOperator\n            compose;\n\n          Image\n            *composite_image,\n            *rotate_image;\n\n          /*\n            Composite image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          composite_image=NewImageList();\n          compose=OverCompositeOp;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"compose\") == 0)\n                    {\n                      option=ParseCommandOption(MagickComposeOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedComposeType\",\n                          value);\n                      compose=(CompositeOperator) option;\n                      break;\n                    }\n                  break;\n                }\n                case 'I':\n                case 'i':\n                {\n                  if (LocaleCompare(keyword,\"image\") == 0)\n                    for (j=0; j < msl_info->n; j++)\n                    {\n                      const char\n                        *attribute;\n\n                      attribute=GetImageProperty(msl_info->attributes[j],\"id\",\n                        exception);\n                      if ((attribute != (const char *) NULL)  &&\n                          (LocaleCompare(attribute,value) == 0))\n                        {\n                          composite_image=CloneImage(msl_info->image[j],0,0,\n                            MagickFalse,exception);\n                          break;\n                        }\n                    }\n                  break;\n                }\n                default:\n                  break;\n              }\n            }\n          if (composite_image == (Image *) NULL)\n            break;\n          rotate_image=NewImageList();\n          SetGeometry(msl_info->image[n],&geometry);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'B':\n                case 'b':\n                {\n                  if (LocaleCompare(keyword,\"blend\") == 0)\n                    {\n                      (void) SetImageArtifact(composite_image,\n                                            \"compose:args\",value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"channel\") == 0)\n                    {\n                      option=ParseChannelOption(value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedChannelType\",\n                          value);\n                      channel=(ChannelType) option;\n                      break;\n                    }\n                  if (LocaleCompare(keyword, \"color\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &composite_image->background_color,exception);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"compose\") == 0)\n                    break;\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParsePageGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      if ((flags & HeightValue) == 0)\n                        geometry.height=geometry.width;\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"gravity\") == 0)\n                    {\n                      option=ParseCommandOption(MagickGravityOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedGravityType\",\n                          value);\n                      msl_info->image[n]->gravity=(GravityType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'I':\n                case 'i':\n                {\n                  if (LocaleCompare(keyword,\"image\") == 0)\n                    break;\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'M':\n                case 'm':\n                {\n                  if (LocaleCompare(keyword,\"mask\") == 0)\n                    for (j=0; j < msl_info->n; j++)\n                    {\n                      const char\n                        *attribute;\n\n                      attribute=GetImageProperty(msl_info->attributes[j],\"id\",\n                        exception);\n                      if ((attribute != (const char *) NULL)  &&\n                          (LocaleCompare(value,value) == 0))\n                        {\n                          SetImageType(composite_image,TrueColorAlphaType,\n                            exception);\n                          (void) CompositeImage(composite_image,\n                            msl_info->image[j],CopyAlphaCompositeOp,MagickTrue,\n                            0,0,exception);\n                          break;\n                        }\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'O':\n                case 'o':\n                {\n                  if (LocaleCompare(keyword,\"opacity\") == 0)\n                    {\n                      ssize_t\n                        opacity,\n                        y;\n\n                      register ssize_t\n                        x;\n\n                      register Quantum\n                        *q;\n\n                      CacheView\n                        *composite_view;\n\n                      opacity=StringToLong(value);\n                      if (compose != DissolveCompositeOp)\n                        {\n                          (void) SetImageAlpha(composite_image,(Quantum)\n                            opacity,exception);\n                          break;\n                        }\n                      (void) SetImageArtifact(msl_info->image[n],\n                                            \"compose:args\",value);\n                      if (composite_image->alpha_trait == UndefinedPixelTrait)\n                        (void) SetImageAlpha(composite_image,OpaqueAlpha,\n                          exception);\n                      composite_view=AcquireAuthenticCacheView(composite_image,exception);\n                      for (y=0; y < (ssize_t) composite_image->rows ; y++)\n                      {\n                        q=GetCacheViewAuthenticPixels(composite_view,0,y,\n                          (ssize_t) composite_image->columns,1,exception);\n                        for (x=0; x < (ssize_t) composite_image->columns; x++)\n                        {\n                          if (GetPixelAlpha(composite_image,q) == OpaqueAlpha)\n                            SetPixelAlpha(composite_image,\n                              ClampToQuantum(opacity),q);\n                          q+=GetPixelChannels(composite_image);\n                        }\n                        if (SyncCacheViewAuthenticPixels(composite_view,exception) == MagickFalse)\n                          break;\n                      }\n                      composite_view=DestroyCacheView(composite_view);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"rotate\") == 0)\n                    {\n                      rotate_image=RotateImage(composite_image,\n                        StringToDouble(value,(char **) NULL),exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'T':\n                case 't':\n                {\n                  if (LocaleCompare(keyword,\"tile\") == 0)\n                    {\n                      MagickBooleanType\n                        tile;\n\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedBooleanType\",\n                          value);\n                      tile=(MagickBooleanType) option;\n                      (void) tile;\n                      if (rotate_image != (Image *) NULL)\n                        (void) SetImageArtifact(rotate_image,\n                          \"compose:outside-overlay\",\"false\");\n                      else\n                        (void) SetImageArtifact(composite_image,\n                          \"compose:outside-overlay\",\"false\");\n                       image=msl_info->image[n];\n                       height=composite_image->rows;\n                       width=composite_image->columns;\n                       for (y=0; y < (ssize_t) image->rows; y+=(ssize_t) height)\n                         for (x=0; x < (ssize_t) image->columns; x+=(ssize_t) width)\n                         {\n                           if (rotate_image != (Image *) NULL)\n                             (void) CompositeImage(image,rotate_image,compose,\n                               MagickTrue,x,y,exception);\n                           else\n                             (void) CompositeImage(image,composite_image,\n                               compose,MagickTrue,x,y,exception);\n                         }\n                      if (rotate_image != (Image *) NULL)\n                        rotate_image=DestroyImage(rotate_image);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry.x=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry.y=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          image=msl_info->image[n];\n          (void) FormatLocaleString(composite_geometry,MagickPathExtent,\n            \"%.20gx%.20g%+.20g%+.20g\",(double) composite_image->columns,\n            (double) composite_image->rows,(double) geometry.x,(double)\n            geometry.y);\n          flags=ParseGravityGeometry(image,composite_geometry,&geometry,\n            exception);\n          channel_mask=SetImageChannelMask(image,channel);\n          if (rotate_image == (Image *) NULL)\n            CompositeImage(image,composite_image,compose,MagickTrue,geometry.x,\n              geometry.y,exception);\n          else\n            {\n              /*\n                Rotate image.\n              */\n              geometry.x-=(ssize_t) (rotate_image->columns-\n                composite_image->columns)/2;\n              geometry.y-=(ssize_t) (rotate_image->rows-\n                composite_image->rows)/2;\n              CompositeImage(image,rotate_image,compose,MagickTrue,geometry.x,\n                geometry.y,exception);\n              rotate_image=DestroyImage(rotate_image);\n            }\n          (void) SetImageChannelMask(image,channel_mask);\n          composite_image=DestroyImage(composite_image);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"contrast\") == 0)\n        {\n          MagickBooleanType\n            sharpen;\n\n          /*\n            Contrast image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          sharpen=MagickFalse;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'S':\n                case 's':\n                {\n                  if (LocaleCompare(keyword,\"sharpen\") == 0)\n                    {\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedBooleanType\",\n                          value);\n                      sharpen=(MagickBooleanType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) ContrastImage(msl_info->image[n],sharpen,\n            msl_info->exception);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"crop\") == 0)\n        {\n          Image\n            *crop_image;\n\n          /*\n            Crop image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          SetGeometry(msl_info->image[n],&geometry);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGravityGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'H':\n                case 'h':\n                {\n                  if (LocaleCompare(keyword,\"height\") == 0)\n                    {\n                      geometry.height=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"width\") == 0)\n                    {\n                      geometry.width=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry.x=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry.y=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          crop_image=CropImage(msl_info->image[n],&geometry,\n            msl_info->exception);\n          if (crop_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=crop_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"cycle-colormap\") == 0)\n        {\n          ssize_t\n            display;\n\n          /*\n            Cycle-colormap image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          display=0;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'D':\n                case 'd':\n                {\n                  if (LocaleCompare(keyword,\"display\") == 0)\n                    {\n                      display=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) CycleColormapImage(msl_info->image[n],display,exception);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleCompare((const char *) tag,\"despeckle\") == 0)\n        {\n          Image\n            *despeckle_image;\n\n          /*\n            Despeckle image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            }\n          despeckle_image=DespeckleImage(msl_info->image[n],\n            msl_info->exception);\n          if (despeckle_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=despeckle_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"display\") == 0)\n        {\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) DisplayImages(msl_info->image_info[n],msl_info->image[n],\n            msl_info->exception);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"draw\") == 0)\n        {\n          char\n            text[MagickPathExtent];\n\n          /*\n            Annotate image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          draw_info=CloneDrawInfo(msl_info->image_info[n],\n            msl_info->draw_info[n]);\n          angle=0.0;\n          current=draw_info->affine;\n          GetAffineMatrix(&affine);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'A':\n                case 'a':\n                {\n                  if (LocaleCompare(keyword,\"affine\") == 0)\n                    {\n                      char\n                        *p;\n\n                      p=value;\n                      draw_info->affine.sx=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.rx=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.ry=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.sy=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.tx=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.ty=StringToDouble(p,&p);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"align\") == 0)\n                    {\n                      option=ParseCommandOption(MagickAlignOptions,MagickFalse,\n                        value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedAlignType\",\n                          value);\n                      draw_info->align=(AlignType) option;\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"antialias\") == 0)\n                    {\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedBooleanType\",\n                          value);\n                      draw_info->stroke_antialias=(MagickBooleanType) option;\n                      draw_info->text_antialias=(MagickBooleanType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'D':\n                case 'd':\n                {\n                  if (LocaleCompare(keyword,\"density\") == 0)\n                    {\n                      CloneString(&draw_info->density,value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'E':\n                case 'e':\n                {\n                  if (LocaleCompare(keyword,\"encoding\") == 0)\n                    {\n                      CloneString(&draw_info->encoding,value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword, \"fill\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &draw_info->fill,exception);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"family\") == 0)\n                    {\n                      CloneString(&draw_info->family,value);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"font\") == 0)\n                    {\n                      CloneString(&draw_info->font,value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParsePageGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      if ((flags & HeightValue) == 0)\n                        geometry.height=geometry.width;\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"gravity\") == 0)\n                    {\n                      option=ParseCommandOption(MagickGravityOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedGravityType\",\n                          value);\n                      draw_info->gravity=(GravityType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'P':\n                case 'p':\n                {\n                  if (LocaleCompare(keyword,\"points\") == 0)\n                    {\n                      if (LocaleCompare(draw_info->primitive,\"path\") == 0)\n                        {\n                          (void) ConcatenateString(&draw_info->primitive,\" '\");\n                          ConcatenateString(&draw_info->primitive,value);\n                          (void) ConcatenateString(&draw_info->primitive,\"'\");\n                        }\n                      else\n                        {\n                          (void) ConcatenateString(&draw_info->primitive,\" \");\n                          ConcatenateString(&draw_info->primitive,value);\n                        }\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"pointsize\") == 0)\n                    {\n                      draw_info->pointsize=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"primitive\") == 0)\n                    {\n                      CloneString(&draw_info->primitive,value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"rotate\") == 0)\n                    {\n                      angle=StringToDouble(value,(char **) NULL);\n                      affine.sx=cos(DegreesToRadians(fmod(angle,360.0)));\n                      affine.rx=sin(DegreesToRadians(fmod(angle,360.0)));\n                      affine.ry=(-sin(DegreesToRadians(fmod(angle,360.0))));\n                      affine.sy=cos(DegreesToRadians(fmod(angle,360.0)));\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'S':\n                case 's':\n                {\n                  if (LocaleCompare(keyword,\"scale\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      affine.sx=geometry_info.rho;\n                      affine.sy=geometry_info.sigma;\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"skewX\") == 0)\n                    {\n                      angle=StringToDouble(value,(char **) NULL);\n                      affine.ry=cos(DegreesToRadians(fmod(angle,360.0)));\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"skewY\") == 0)\n                    {\n                      angle=StringToDouble(value,(char **) NULL);\n                      affine.rx=cos(DegreesToRadians(fmod(angle,360.0)));\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"stretch\") == 0)\n                    {\n                      option=ParseCommandOption(MagickStretchOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedStretchType\",\n                          value);\n                      draw_info->stretch=(StretchType) option;\n                      break;\n                    }\n                  if (LocaleCompare(keyword, \"stroke\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &draw_info->stroke,exception);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"strokewidth\") == 0)\n                    {\n                      draw_info->stroke_width=StringToLong(value);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"style\") == 0)\n                    {\n                      option=ParseCommandOption(MagickStyleOptions,MagickFalse,\n                        value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedStyleType\",\n                          value);\n                      draw_info->style=(StyleType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'T':\n                case 't':\n                {\n                  if (LocaleCompare(keyword,\"text\") == 0)\n                    {\n                      (void) ConcatenateString(&draw_info->primitive,\" '\");\n                      (void) ConcatenateString(&draw_info->primitive,value);\n                      (void) ConcatenateString(&draw_info->primitive,\"'\");\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"translate\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      affine.tx=geometry_info.rho;\n                      affine.ty=geometry_info.sigma;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'U':\n                case 'u':\n                {\n                  if (LocaleCompare(keyword, \"undercolor\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &draw_info->undercolor,exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"weight\") == 0)\n                    {\n                      draw_info->weight=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry.x=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry.y=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) FormatLocaleString(text,MagickPathExtent,\n            \"%.20gx%.20g%+.20g%+.20g\",(double) geometry.width,(double)\n            geometry.height,(double) geometry.x,(double) geometry.y);\n          CloneString(&draw_info->geometry,text);\n          draw_info->affine.sx=affine.sx*current.sx+affine.ry*current.rx;\n          draw_info->affine.rx=affine.rx*current.sx+affine.sy*current.rx;\n          draw_info->affine.ry=affine.sx*current.ry+affine.ry*current.sy;\n          draw_info->affine.sy=affine.rx*current.ry+affine.sy*current.sy;\n          draw_info->affine.tx=affine.sx*current.tx+affine.ry*current.ty+\n            affine.tx;\n          draw_info->affine.ty=affine.rx*current.tx+affine.sy*current.ty+\n            affine.ty;\n          (void) DrawImage(msl_info->image[n],draw_info,exception);\n          draw_info=DestroyDrawInfo(draw_info);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'E':\n    case 'e':\n    {\n      if (LocaleCompare((const char *) tag,\"edge\") == 0)\n        {\n          Image\n            *edge_image;\n\n          /*\n            Edge image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"radius\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,(char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          edge_image=EdgeImage(msl_info->image[n],geometry_info.rho,\n            msl_info->exception);\n          if (edge_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=edge_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"emboss\") == 0)\n        {\n          Image\n            *emboss_image;\n\n          /*\n            Emboss image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"radius\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'S':\n                case 's':\n                {\n                  if (LocaleCompare(keyword,\"sigma\") == 0)\n                    {\n                      geometry_info.sigma=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          emboss_image=EmbossImage(msl_info->image[n],geometry_info.rho,\n            geometry_info.sigma,msl_info->exception);\n          if (emboss_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=emboss_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"enhance\") == 0)\n        {\n          Image\n            *enhance_image;\n\n          /*\n            Enhance image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            }\n          enhance_image=EnhanceImage(msl_info->image[n],\n            msl_info->exception);\n          if (enhance_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=enhance_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"equalize\") == 0)\n        {\n          /*\n            Equalize image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) EqualizeImage(msl_info->image[n],\n            msl_info->exception);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleCompare((const char *) tag, \"flatten\") == 0)\n      {\n        if (msl_info->image[n] == (Image *) NULL)\n        {\n          ThrowMSLException(OptionError,\"NoImagesDefined\",\n            (const char *) tag);\n          break;\n        }\n\n        /* no attributes here */\n\n        /* process the image */\n        {\n          Image\n            *newImage;\n\n          newImage=MergeImageLayers(msl_info->image[n],FlattenLayer,\n            msl_info->exception);\n          if (newImage == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=newImage;\n          break;\n        }\n      }\n      if (LocaleCompare((const char *) tag,\"flip\") == 0)\n        {\n          Image\n            *flip_image;\n\n          /*\n            Flip image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            }\n          flip_image=FlipImage(msl_info->image[n],\n            msl_info->exception);\n          if (flip_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=flip_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"flop\") == 0)\n        {\n          Image\n            *flop_image;\n\n          /*\n            Flop image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            }\n          flop_image=FlopImage(msl_info->image[n],\n            msl_info->exception);\n          if (flop_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=flop_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"frame\") == 0)\n        {\n          FrameInfo\n            frame_info;\n\n          Image\n            *frame_image;\n\n          /*\n            Frame image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          (void) ResetMagickMemory(&frame_info,0,sizeof(frame_info));\n          SetGeometry(msl_info->image[n],&geometry);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"compose\") == 0)\n                    {\n                      option=ParseCommandOption(MagickComposeOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedComposeType\",\n                          value);\n                      msl_info->image[n]->compose=(CompositeOperator) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword, \"fill\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &msl_info->image[n]->matte_color,exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParsePageGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      if ((flags & HeightValue) == 0)\n                        geometry.height=geometry.width;\n                      frame_info.width=geometry.width;\n                      frame_info.height=geometry.height;\n                      frame_info.outer_bevel=geometry.x;\n                      frame_info.inner_bevel=geometry.y;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'H':\n                case 'h':\n                {\n                  if (LocaleCompare(keyword,\"height\") == 0)\n                    {\n                      frame_info.height=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'I':\n                case 'i':\n                {\n                  if (LocaleCompare(keyword,\"inner\") == 0)\n                    {\n                      frame_info.inner_bevel=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'O':\n                case 'o':\n                {\n                  if (LocaleCompare(keyword,\"outer\") == 0)\n                    {\n                      frame_info.outer_bevel=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"width\") == 0)\n                    {\n                      frame_info.width=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          frame_info.x=(ssize_t) frame_info.width;\n          frame_info.y=(ssize_t) frame_info.height;\n          frame_info.width=msl_info->image[n]->columns+2*frame_info.x;\n          frame_info.height=msl_info->image[n]->rows+2*frame_info.y;\n          frame_image=FrameImage(msl_info->image[n],&frame_info,\n            msl_info->image[n]->compose,msl_info->exception);\n          if (frame_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=frame_image;\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare((const char *) tag,\"gamma\") == 0)\n        {\n          char\n            gamma[MagickPathExtent];\n\n          PixelInfo\n            pixel;\n\n          /*\n            Gamma image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          channel=UndefinedChannel;\n          pixel.red=0.0;\n          pixel.green=0.0;\n          pixel.blue=0.0;\n          *gamma='\\0';\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'B':\n                case 'b':\n                {\n                  if (LocaleCompare(keyword,\"blue\") == 0)\n                    {\n                      pixel.blue=StringToDouble(value,(char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"channel\") == 0)\n                    {\n                      option=ParseChannelOption(value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedChannelType\",\n                          value);\n                      channel=(ChannelType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"gamma\") == 0)\n                    {\n                      (void) CopyMagickString(gamma,value,MagickPathExtent);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"green\") == 0)\n                    {\n                      pixel.green=StringToDouble(value,(char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"red\") == 0)\n                    {\n                      pixel.red=StringToDouble(value,(char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          if (*gamma == '\\0')\n            (void) FormatLocaleString(gamma,MagickPathExtent,\"%g,%g,%g\",\n              (double) pixel.red,(double) pixel.green,(double) pixel.blue);\n          (void) GammaImage(msl_info->image[n],strtod(gamma,(char **) NULL),\n            msl_info->exception);\n          break;\n        }\n      else if (LocaleCompare((const char *) tag,\"get\") == 0)\n        {\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes == (const xmlChar **) NULL)\n            break;\n          for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n          {\n            keyword=(const char *) attributes[i++];\n            CloneString(&value,(const char *) attributes[i]);\n            (void) CopyMagickString(key,value,MagickPathExtent);\n            switch (*keyword)\n            {\n              case 'H':\n              case 'h':\n              {\n                if (LocaleCompare(keyword,\"height\") == 0)\n                  {\n                    (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n                      (double) msl_info->image[n]->rows);\n                    (void) SetImageProperty(msl_info->attributes[n],key,value,\n                      exception);\n                    break;\n                  }\n                ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              }\n              case 'W':\n              case 'w':\n              {\n                if (LocaleCompare(keyword,\"width\") == 0)\n                  {\n                    (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n                      (double) msl_info->image[n]->columns);\n                    (void) SetImageProperty(msl_info->attributes[n],key,value,\n                      exception);\n                    break;\n                  }\n                ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              }\n              default:\n              {\n                ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n                break;\n              }\n            }\n          }\n          break;\n        }\n    else if (LocaleCompare((const char *) tag, \"group\") == 0)\n    {\n      msl_info->number_groups++;\n      msl_info->group_info=(MSLGroupInfo *) ResizeQuantumMemory(\n        msl_info->group_info,msl_info->number_groups+1UL,\n        sizeof(*msl_info->group_info));\n      break;\n    }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare((const char *) tag,\"image\") == 0)\n        {\n          MSLPushImage(msl_info,(Image *) NULL);\n          if (attributes == (const xmlChar **) NULL)\n            break;\n          for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n          {\n            keyword=(const char *) attributes[i++];\n            attribute=InterpretImageProperties(msl_info->image_info[n],\n              msl_info->attributes[n],(const char *) attributes[i],exception);\n            CloneString(&value,attribute);\n            attribute=DestroyString(attribute);\n            switch (*keyword)\n            {\n              case 'C':\n              case 'c':\n              {\n                if (LocaleCompare(keyword,\"color\") == 0)\n                  {\n                    Image\n                      *next_image;\n\n                    (void) CopyMagickString(msl_info->image_info[n]->filename,\n                      \"xc:\",MagickPathExtent);\n                    (void) ConcatenateMagickString(msl_info->image_info[n]->\n                      filename,value,MagickPathExtent);\n                    next_image=ReadImage(msl_info->image_info[n],exception);\n                    CatchException(exception);\n                    if (next_image == (Image *) NULL)\n                      continue;\n                    if (msl_info->image[n] == (Image *) NULL)\n                      msl_info->image[n]=next_image;\n                    else\n                      {\n                        register Image\n                          *p;\n\n                        /*\n                          Link image into image list.\n                        */\n                        p=msl_info->image[n];\n                        while (p->next != (Image *) NULL)\n                          p=GetNextImageInList(p);\n                        next_image->previous=p;\n                        p->next=next_image;\n                      }\n                    break;\n                  }\n                (void) SetMSLAttributes(msl_info,keyword,value);\n                break;\n              }\n              default:\n              {\n                (void) SetMSLAttributes(msl_info,keyword,value);\n                break;\n              }\n            }\n          }\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"implode\") == 0)\n        {\n          Image\n            *implode_image;\n\n          /*\n            Implode image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'A':\n                case 'a':\n                {\n                  if (LocaleCompare(keyword,\"amount\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          implode_image=ImplodeImage(msl_info->image[n],geometry_info.rho,\n            msl_info->image[n]->interpolate,msl_info->exception);\n          if (implode_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=implode_image;\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare((const char *) tag,\"label\") == 0)\n        break;\n      if (LocaleCompare((const char *) tag, \"level\") == 0)\n      {\n        double\n          levelBlack = 0, levelGamma = 1, levelWhite = QuantumRange;\n\n        if (msl_info->image[n] == (Image *) NULL)\n        {\n          ThrowMSLException(OptionError,\"NoImagesDefined\",\n            (const char *) tag);\n          break;\n        }\n        if (attributes == (const xmlChar **) NULL)\n          break;\n        for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n        {\n          keyword=(const char *) attributes[i++];\n          CloneString(&value,(const char *) attributes[i]);\n          (void) CopyMagickString(key,value,MagickPathExtent);\n          switch (*keyword)\n          {\n            case 'B':\n            case 'b':\n            {\n              if (LocaleCompare(keyword,\"black\") == 0)\n              {\n                levelBlack = StringToDouble(value,(char **) NULL);\n                break;\n              }\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n            case 'G':\n            case 'g':\n            {\n              if (LocaleCompare(keyword,\"gamma\") == 0)\n              {\n                levelGamma = StringToDouble(value,(char **) NULL);\n                break;\n              }\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n            case 'W':\n            case 'w':\n            {\n              if (LocaleCompare(keyword,\"white\") == 0)\n              {\n                levelWhite = StringToDouble(value,(char **) NULL);\n                break;\n              }\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n            default:\n            {\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n          }\n        }\n\n        /* process image */\n        LevelImage(msl_info->image[n],levelBlack,levelWhite,levelGamma,\n          msl_info->exception);\n        break;\n      }\n    }\n    case 'M':\n    case 'm':\n    {\n      if (LocaleCompare((const char *) tag,\"magnify\") == 0)\n        {\n          Image\n            *magnify_image;\n\n          /*\n            Magnify image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            }\n          magnify_image=MagnifyImage(msl_info->image[n],\n            msl_info->exception);\n          if (magnify_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=magnify_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"map\") == 0)\n        {\n          Image\n            *affinity_image;\n\n          MagickBooleanType\n            dither;\n\n          QuantizeInfo\n            *quantize_info;\n\n          /*\n            Map image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          affinity_image=NewImageList();\n          dither=MagickFalse;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'D':\n                case 'd':\n                {\n                  if (LocaleCompare(keyword,\"dither\") == 0)\n                    {\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedBooleanType\",\n                          value);\n                      dither=(MagickBooleanType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'I':\n                case 'i':\n                {\n                  if (LocaleCompare(keyword,\"image\") == 0)\n                    for (j=0; j < msl_info->n; j++)\n                    {\n                      const char\n                        *attribute;\n\n                      attribute=GetImageProperty(msl_info->attributes[j],\"id\",\n                        exception);\n                      if ((attribute != (const char *) NULL)  &&\n                          (LocaleCompare(attribute,value) == 0))\n                        {\n                          affinity_image=CloneImage(msl_info->image[j],0,0,\n                            MagickFalse,exception);\n                          break;\n                        }\n                    }\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          quantize_info=AcquireQuantizeInfo(msl_info->image_info[n]);\n          quantize_info->dither_method=dither != MagickFalse ?\n            RiemersmaDitherMethod : NoDitherMethod;\n          (void) RemapImages(quantize_info,msl_info->image[n],\n            affinity_image,exception);\n          quantize_info=DestroyQuantizeInfo(quantize_info);\n          affinity_image=DestroyImage(affinity_image);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"matte-floodfill\") == 0)\n        {\n          double\n            opacity;\n\n          PixelInfo\n            target;\n\n          PaintMethod\n            paint_method;\n\n          /*\n            Matte floodfill image.\n          */\n          opacity=0.0;\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          SetGeometry(msl_info->image[n],&geometry);\n          paint_method=FloodfillMethod;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'B':\n                case 'b':\n                {\n                  if (LocaleCompare(keyword,\"bordercolor\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &target,exception);\n                      paint_method=FillToBorderMethod;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword,\"fuzz\") == 0)\n                    {\n                      msl_info->image[n]->fuzz=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParsePageGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      if ((flags & HeightValue) == 0)\n                        geometry.height=geometry.width;\n                      (void) GetOneVirtualPixelInfo(msl_info->image[n],\n                        TileVirtualPixelMethod,geometry.x,geometry.y,&target,\n                        exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'O':\n                case 'o':\n                {\n                  if (LocaleCompare(keyword,\"opacity\") == 0)\n                    {\n                      opacity=StringToDouble(value,(char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry.x=StringToLong(value);\n                      (void) GetOneVirtualPixelInfo(msl_info->image[n],\n                        TileVirtualPixelMethod,geometry.x,geometry.y,&target,\n                        exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry.y=StringToLong(value);\n                      (void) GetOneVirtualPixelInfo(msl_info->image[n],\n                        TileVirtualPixelMethod,geometry.x,geometry.y,&target,\n                        exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          draw_info=CloneDrawInfo(msl_info->image_info[n],\n            msl_info->draw_info[n]);\n          draw_info->fill.alpha=ClampToQuantum(opacity);\n          channel_mask=SetImageChannelMask(msl_info->image[n],AlphaChannel);\n          (void) FloodfillPaintImage(msl_info->image[n],draw_info,&target,\n            geometry.x,geometry.y,paint_method == FloodfillMethod ?\n            MagickFalse : MagickTrue,msl_info->exception);\n          (void) SetPixelChannelMask(msl_info->image[n],channel_mask);\n          draw_info=DestroyDrawInfo(draw_info);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"median-filter\") == 0)\n        {\n          Image\n            *median_image;\n\n          /*\n            Median-filter image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"radius\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          median_image=StatisticImage(msl_info->image[n],MedianStatistic,\n            (size_t) geometry_info.rho,(size_t) geometry_info.sigma,\n            msl_info->exception);\n          if (median_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=median_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"minify\") == 0)\n        {\n          Image\n            *minify_image;\n\n          /*\n            Minify image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            }\n          minify_image=MinifyImage(msl_info->image[n],\n            msl_info->exception);\n          if (minify_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=minify_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"msl\") == 0 )\n        break;\n      if (LocaleCompare((const char *) tag,\"modulate\") == 0)\n        {\n          char\n            modulate[MagickPathExtent];\n\n          /*\n            Modulate image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          geometry_info.rho=100.0;\n          geometry_info.sigma=100.0;\n          geometry_info.xi=100.0;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'B':\n                case 'b':\n                {\n                  if (LocaleCompare(keyword,\"blackness\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"brightness\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword,\"factor\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'H':\n                case 'h':\n                {\n                  if (LocaleCompare(keyword,\"hue\") == 0)\n                    {\n                      geometry_info.xi=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'L':\n                case 'l':\n                {\n                  if (LocaleCompare(keyword,\"lightness\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'S':\n                case 's':\n                {\n                  if (LocaleCompare(keyword,\"saturation\") == 0)\n                    {\n                      geometry_info.sigma=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"whiteness\") == 0)\n                    {\n                      geometry_info.sigma=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) FormatLocaleString(modulate,MagickPathExtent,\"%g,%g,%g\",\n            geometry_info.rho,geometry_info.sigma,geometry_info.xi);\n          (void) ModulateImage(msl_info->image[n],modulate,\n            msl_info->exception);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'N':\n    case 'n':\n    {\n      if (LocaleCompare((const char *) tag,\"negate\") == 0)\n        {\n          MagickBooleanType\n            gray;\n\n          /*\n            Negate image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          gray=MagickFalse;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"channel\") == 0)\n                    {\n                      option=ParseChannelOption(value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedChannelType\",\n                          value);\n                      channel=(ChannelType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"gray\") == 0)\n                    {\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedBooleanType\",\n                          value);\n                      gray=(MagickBooleanType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          channel_mask=SetImageChannelMask(msl_info->image[n],channel);\n          (void) NegateImage(msl_info->image[n],gray,\n            msl_info->exception);\n          (void) SetPixelChannelMask(msl_info->image[n],channel_mask);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"normalize\") == 0)\n        {\n          /*\n            Normalize image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"channel\") == 0)\n                    {\n                      option=ParseChannelOption(value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedChannelType\",\n                          value);\n                      channel=(ChannelType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) NormalizeImage(msl_info->image[n],\n            msl_info->exception);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'O':\n    case 'o':\n    {\n      if (LocaleCompare((const char *) tag,\"oil-paint\") == 0)\n        {\n          Image\n            *paint_image;\n\n          /*\n            Oil-paint image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"radius\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          paint_image=OilPaintImage(msl_info->image[n],geometry_info.rho,\n            geometry_info.sigma,msl_info->exception);\n          if (paint_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=paint_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"opaque\") == 0)\n        {\n          PixelInfo\n            fill_color,\n            target;\n\n          /*\n            Opaque image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          (void) QueryColorCompliance(\"none\",AllCompliance,&target,\n            exception);\n          (void) QueryColorCompliance(\"none\",AllCompliance,&fill_color,\n            exception);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"channel\") == 0)\n                    {\n                      option=ParseChannelOption(value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedChannelType\",\n                          value);\n                      channel=(ChannelType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword,\"fill\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &fill_color,exception);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"fuzz\") == 0)\n                    {\n                      msl_info->image[n]->fuzz=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          channel_mask=SetImageChannelMask(msl_info->image[n],channel);\n          (void) OpaquePaintImage(msl_info->image[n],&target,&fill_color,\n            MagickFalse,msl_info->exception);\n          (void) SetPixelChannelMask(msl_info->image[n],channel_mask);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare((const char *) tag,\"print\") == 0)\n        {\n          if (attributes == (const xmlChar **) NULL)\n            break;\n          for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n          {\n            keyword=(const char *) attributes[i++];\n            attribute=InterpretImageProperties(msl_info->image_info[n],\n              msl_info->attributes[n],(const char *) attributes[i],\n              exception);\n            CloneString(&value,attribute);\n            attribute=DestroyString(attribute);\n            switch (*keyword)\n            {\n              case 'O':\n              case 'o':\n              {\n                if (LocaleCompare(keyword,\"output\") == 0)\n                  {\n                    (void) FormatLocaleFile(stdout,\"%s\",value);\n                    break;\n                  }\n                ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n                break;\n              }\n              default:\n              {\n                ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n                break;\n              }\n            }\n          }\n          break;\n        }\n        if (LocaleCompare((const char *) tag, \"profile\") == 0)\n          {\n            if (msl_info->image[n] == (Image *) NULL)\n              {\n                ThrowMSLException(OptionError,\"NoImagesDefined\",\n                  (const char *) tag);\n                break;\n              }\n            if (attributes == (const xmlChar **) NULL)\n              break;\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              const char\n                *name;\n\n              const StringInfo\n                *profile;\n\n              Image\n                *profile_image;\n\n              ImageInfo\n                *profile_info;\n\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              if (*keyword == '!')\n                {\n                  /*\n                    Remove a profile from the image.\n                  */\n                  (void) ProfileImage(msl_info->image[n],keyword,\n                    (const unsigned char *) NULL,0,exception);\n                  continue;\n                }\n              /*\n                Associate a profile with the image.\n              */\n              profile_info=CloneImageInfo(msl_info->image_info[n]);\n              profile=GetImageProfile(msl_info->image[n],\"iptc\");\n              if (profile != (StringInfo *) NULL)\n                profile_info->profile=(void *) CloneStringInfo(profile);\n              profile_image=GetImageCache(profile_info,keyword,exception);\n              profile_info=DestroyImageInfo(profile_info);\n              if (profile_image == (Image *) NULL)\n                {\n                  char\n                    name[MagickPathExtent],\n                    filename[MagickPathExtent];\n\n                  register char\n                    *p;\n\n                  StringInfo\n                    *profile;\n\n                  (void) CopyMagickString(filename,keyword,MagickPathExtent);\n                  (void) CopyMagickString(name,keyword,MagickPathExtent);\n                  for (p=filename; *p != '\\0'; p++)\n                    if ((*p == ':') && (IsPathDirectory(keyword) < 0) &&\n                        (IsPathAccessible(keyword) == MagickFalse))\n                      {\n                        register char\n                          *q;\n\n                        /*\n                          Look for profile name (e.g. name:profile).\n                        */\n                        (void) CopyMagickString(name,filename,(size_t)\n                          (p-filename+1));\n                        for (q=filename; *q != '\\0'; q++)\n                          *q=(*++p);\n                        break;\n                      }\n                  profile=FileToStringInfo(filename,~0UL,exception);\n                  if (profile != (StringInfo *) NULL)\n                    {\n                      (void) ProfileImage(msl_info->image[n],name,\n                        GetStringInfoDatum(profile),(size_t)\n                        GetStringInfoLength(profile),exception);\n                      profile=DestroyStringInfo(profile);\n                    }\n                  continue;\n                }\n              ResetImageProfileIterator(profile_image);\n              name=GetNextImageProfile(profile_image);\n              while (name != (const char *) NULL)\n              {\n                profile=GetImageProfile(profile_image,name);\n                if (profile != (StringInfo *) NULL)\n                  (void) ProfileImage(msl_info->image[n],name,\n                    GetStringInfoDatum(profile),(size_t)\n                    GetStringInfoLength(profile),exception);\n                name=GetNextImageProfile(profile_image);\n              }\n              profile_image=DestroyImage(profile_image);\n            }\n            break;\n          }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'Q':\n    case 'q':\n    {\n      if (LocaleCompare((const char *) tag,\"quantize\") == 0)\n        {\n          QuantizeInfo\n            quantize_info;\n\n          /*\n            Quantize image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          GetQuantizeInfo(&quantize_info);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"colors\") == 0)\n                    {\n                      quantize_info.number_colors=StringToLong(value);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"colorspace\") == 0)\n                    {\n                      option=ParseCommandOption(MagickColorspaceOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\n                          \"UnrecognizedColorspaceType\",value);\n                      quantize_info.colorspace=(ColorspaceType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'D':\n                case 'd':\n                {\n                  if (LocaleCompare(keyword,\"dither\") == 0)\n                    {\n                      option=ParseCommandOption(MagickDitherOptions,MagickFalse,\n                        value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedBooleanType\",\n                          value);\n                      quantize_info.dither_method=(DitherMethod) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'M':\n                case 'm':\n                {\n                  if (LocaleCompare(keyword,\"measure\") == 0)\n                    {\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedBooleanType\",\n                          value);\n                      quantize_info.measure_error=(MagickBooleanType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'T':\n                case 't':\n                {\n                  if (LocaleCompare(keyword,\"treedepth\") == 0)\n                    {\n                      quantize_info.tree_depth=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) QuantizeImage(&quantize_info,msl_info->image[n],exception);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"query-font-metrics\") == 0)\n        {\n          char\n            text[MagickPathExtent];\n\n          MagickBooleanType\n            status;\n\n          TypeMetric\n            metrics;\n\n          /*\n            Query font metrics.\n          */\n          draw_info=CloneDrawInfo(msl_info->image_info[n],\n            msl_info->draw_info[n]);\n          angle=0.0;\n          current=draw_info->affine;\n          GetAffineMatrix(&affine);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'A':\n                case 'a':\n                {\n                  if (LocaleCompare(keyword,\"affine\") == 0)\n                    {\n                      char\n                        *p;\n\n                      p=value;\n                      draw_info->affine.sx=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.rx=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.ry=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.sy=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.tx=StringToDouble(p,&p);\n                      if (*p ==',')\n                        p++;\n                      draw_info->affine.ty=StringToDouble(p,&p);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"align\") == 0)\n                    {\n                      option=ParseCommandOption(MagickAlignOptions,MagickFalse,\n                        value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedAlignType\",\n                          value);\n                      draw_info->align=(AlignType) option;\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"antialias\") == 0)\n                    {\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedBooleanType\",\n                          value);\n                      draw_info->stroke_antialias=(MagickBooleanType) option;\n                      draw_info->text_antialias=(MagickBooleanType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'D':\n                case 'd':\n                {\n                  if (LocaleCompare(keyword,\"density\") == 0)\n                    {\n                      CloneString(&draw_info->density,value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'E':\n                case 'e':\n                {\n                  if (LocaleCompare(keyword,\"encoding\") == 0)\n                    {\n                      CloneString(&draw_info->encoding,value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword, \"fill\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &draw_info->fill,exception);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"family\") == 0)\n                    {\n                      CloneString(&draw_info->family,value);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"font\") == 0)\n                    {\n                      CloneString(&draw_info->font,value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParsePageGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      if ((flags & HeightValue) == 0)\n                        geometry.height=geometry.width;\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"gravity\") == 0)\n                    {\n                      option=ParseCommandOption(MagickGravityOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedGravityType\",\n                          value);\n                      draw_info->gravity=(GravityType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'P':\n                case 'p':\n                {\n                  if (LocaleCompare(keyword,\"pointsize\") == 0)\n                    {\n                      draw_info->pointsize=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"rotate\") == 0)\n                    {\n                      angle=StringToDouble(value,(char **) NULL);\n                      affine.sx=cos(DegreesToRadians(fmod(angle,360.0)));\n                      affine.rx=sin(DegreesToRadians(fmod(angle,360.0)));\n                      affine.ry=(-sin(DegreesToRadians(fmod(angle,360.0))));\n                      affine.sy=cos(DegreesToRadians(fmod(angle,360.0)));\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'S':\n                case 's':\n                {\n                  if (LocaleCompare(keyword,\"scale\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      affine.sx=geometry_info.rho;\n                      affine.sy=geometry_info.sigma;\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"skewX\") == 0)\n                    {\n                      angle=StringToDouble(value,(char **) NULL);\n                      affine.ry=cos(DegreesToRadians(fmod(angle,360.0)));\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"skewY\") == 0)\n                    {\n                      angle=StringToDouble(value,(char **) NULL);\n                      affine.rx=cos(DegreesToRadians(fmod(angle,360.0)));\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"stretch\") == 0)\n                    {\n                      option=ParseCommandOption(MagickStretchOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedStretchType\",\n                          value);\n                      draw_info->stretch=(StretchType) option;\n                      break;\n                    }\n                  if (LocaleCompare(keyword, \"stroke\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &draw_info->stroke,exception);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"strokewidth\") == 0)\n                    {\n                      draw_info->stroke_width=StringToLong(value);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"style\") == 0)\n                    {\n                      option=ParseCommandOption(MagickStyleOptions,MagickFalse,\n                        value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedStyleType\",\n                          value);\n                      draw_info->style=(StyleType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'T':\n                case 't':\n                {\n                  if (LocaleCompare(keyword,\"text\") == 0)\n                    {\n                      CloneString(&draw_info->text,value);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"translate\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      affine.tx=geometry_info.rho;\n                      affine.ty=geometry_info.sigma;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'U':\n                case 'u':\n                {\n                  if (LocaleCompare(keyword, \"undercolor\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &draw_info->undercolor,exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"weight\") == 0)\n                    {\n                      draw_info->weight=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry.x=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry.y=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) FormatLocaleString(text,MagickPathExtent,\n            \"%.20gx%.20g%+.20g%+.20g\",(double) geometry.width,(double)\n            geometry.height,(double) geometry.x,(double) geometry.y);\n          CloneString(&draw_info->geometry,text);\n          draw_info->affine.sx=affine.sx*current.sx+affine.ry*current.rx;\n          draw_info->affine.rx=affine.rx*current.sx+affine.sy*current.rx;\n          draw_info->affine.ry=affine.sx*current.ry+affine.ry*current.sy;\n          draw_info->affine.sy=affine.rx*current.ry+affine.sy*current.sy;\n          draw_info->affine.tx=affine.sx*current.tx+affine.ry*current.ty+\n            affine.tx;\n          draw_info->affine.ty=affine.rx*current.tx+affine.sy*current.ty+\n            affine.ty;\n          status=GetTypeMetrics(msl_info->attributes[n],draw_info,&metrics,\n            msl_info->exception);\n          if (status != MagickFalse)\n            {\n              Image\n                *image;\n\n              image=msl_info->attributes[n];\n              FormatImageProperty(image,\"msl:font-metrics.pixels_per_em.x\",\n                \"%g\",metrics.pixels_per_em.x);\n              FormatImageProperty(image,\"msl:font-metrics.pixels_per_em.y\",\n                \"%g\",metrics.pixels_per_em.y);\n              FormatImageProperty(image,\"msl:font-metrics.ascent\",\"%g\",\n                metrics.ascent);\n              FormatImageProperty(image,\"msl:font-metrics.descent\",\"%g\",\n                metrics.descent);\n              FormatImageProperty(image,\"msl:font-metrics.width\",\"%g\",\n                metrics.width);\n              FormatImageProperty(image,\"msl:font-metrics.height\",\"%g\",\n                metrics.height);\n              FormatImageProperty(image,\"msl:font-metrics.max_advance\",\"%g\",\n                metrics.max_advance);\n              FormatImageProperty(image,\"msl:font-metrics.bounds.x1\",\"%g\",\n                metrics.bounds.x1);\n              FormatImageProperty(image,\"msl:font-metrics.bounds.y1\",\"%g\",\n                metrics.bounds.y1);\n              FormatImageProperty(image,\"msl:font-metrics.bounds.x2\",\"%g\",\n                metrics.bounds.x2);\n              FormatImageProperty(image,\"msl:font-metrics.bounds.y2\",\"%g\",\n                metrics.bounds.y2);\n              FormatImageProperty(image,\"msl:font-metrics.origin.x\",\"%g\",\n                metrics.origin.x);\n              FormatImageProperty(image,\"msl:font-metrics.origin.y\",\"%g\",\n                metrics.origin.y);\n            }\n          draw_info=DestroyDrawInfo(draw_info);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleCompare((const char *) tag,\"raise\") == 0)\n        {\n          MagickBooleanType\n            raise;\n\n          /*\n            Raise image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          raise=MagickFalse;\n          SetGeometry(msl_info->image[n],&geometry);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParsePageGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      if ((flags & HeightValue) == 0)\n                        geometry.height=geometry.width;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'H':\n                case 'h':\n                {\n                  if (LocaleCompare(keyword,\"height\") == 0)\n                    {\n                      geometry.height=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"raise\") == 0)\n                    {\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedNoiseType\",\n                          value);\n                      raise=(MagickBooleanType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"width\") == 0)\n                    {\n                      geometry.width=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) RaiseImage(msl_info->image[n],&geometry,raise,\n            msl_info->exception);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"read\") == 0)\n        {\n          if (attributes == (const xmlChar **) NULL)\n            break;\n          for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n          {\n            keyword=(const char *) attributes[i++];\n            attribute=InterpretImageProperties(msl_info->image_info[n],\n              msl_info->attributes[n],(const char *) attributes[i],exception);\n            CloneString(&value,attribute);\n            attribute=DestroyString(attribute);\n            switch (*keyword)\n            {\n              case 'F':\n              case 'f':\n              {\n                if (LocaleCompare(keyword,\"filename\") == 0)\n                  {\n                    Image\n                      *image;\n\n                    if (value == (char *) NULL)\n                      break;\n                    (void) CopyMagickString(msl_info->image_info[n]->filename,\n                      value,MagickPathExtent);\n                    image=ReadImage(msl_info->image_info[n],exception);\n                    CatchException(exception);\n                    if (image == (Image *) NULL)\n                      continue;\n                    AppendImageToList(&msl_info->image[n],image);\n                    break;\n                  }\n                (void) SetMSLAttributes(msl_info,keyword,value);\n                break;\n              }\n              default:\n              {\n                (void) SetMSLAttributes(msl_info,keyword,value);\n                break;\n              }\n            }\n          }\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"reduce-noise\") == 0)\n        {\n          Image\n            *paint_image;\n\n          /*\n            Reduce-noise image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"radius\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          paint_image=StatisticImage(msl_info->image[n],NonpeakStatistic,\n            (size_t) geometry_info.rho,(size_t) geometry_info.sigma,\n            msl_info->exception);\n          if (paint_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=paint_image;\n          break;\n        }\n      else if (LocaleCompare((const char *) tag,\"repage\") == 0)\n      {\n        /* init the values */\n        width=msl_info->image[n]->page.width;\n        height=msl_info->image[n]->page.height;\n        x=msl_info->image[n]->page.x;\n        y=msl_info->image[n]->page.y;\n\n        if (msl_info->image[n] == (Image *) NULL)\n        {\n          ThrowMSLException(OptionError,\"NoImagesDefined\",\n            (const char *) tag);\n          break;\n        }\n        if (attributes == (const xmlChar **) NULL)\n        break;\n        for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n        {\n          keyword=(const char *) attributes[i++];\n          attribute=InterpretImageProperties(msl_info->image_info[n],\n            msl_info->attributes[n],(const char *) attributes[i],exception);\n          CloneString(&value,attribute);\n          attribute=DestroyString(attribute);\n        switch (*keyword)\n        {\n          case 'G':\n          case 'g':\n          {\n          if (LocaleCompare(keyword,\"geometry\") == 0)\n            {\n              int\n                flags;\n\n              RectangleInfo\n                geometry;\n\n            flags=ParseAbsoluteGeometry(value,&geometry);\n            if ((flags & WidthValue) != 0)\n              {\n                if ((flags & HeightValue) == 0)\n                  geometry.height=geometry.width;\n                width=geometry.width;\n                height=geometry.height;\n              }\n            if ((flags & AspectValue) != 0)\n              {\n                if ((flags & XValue) != 0)\n                  x+=geometry.x;\n                if ((flags & YValue) != 0)\n                  y+=geometry.y;\n              }\n            else\n              {\n                if ((flags & XValue) != 0)\n                  {\n                    x=geometry.x;\n                    if ((width == 0) && (geometry.x > 0))\n                      width=msl_info->image[n]->columns+geometry.x;\n                  }\n                if ((flags & YValue) != 0)\n                  {\n                    y=geometry.y;\n                    if ((height == 0) && (geometry.y > 0))\n                      height=msl_info->image[n]->rows+geometry.y;\n                  }\n              }\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          case 'H':\n          case 'h':\n          {\n          if (LocaleCompare(keyword,\"height\") == 0)\n            {\n            height = StringToLong( value );\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          case 'W':\n          case 'w':\n          {\n          if (LocaleCompare(keyword,\"width\") == 0)\n            {\n            width = StringToLong( value );\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          case 'X':\n          case 'x':\n          {\n          if (LocaleCompare(keyword,\"x\") == 0)\n            {\n            x = StringToLong( value );\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          case 'Y':\n          case 'y':\n          {\n          if (LocaleCompare(keyword,\"y\") == 0)\n            {\n            y = StringToLong( value );\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          default:\n          {\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n        }\n        }\n\n         msl_info->image[n]->page.width=width;\n         msl_info->image[n]->page.height=height;\n         msl_info->image[n]->page.x=x;\n         msl_info->image[n]->page.y=y;\n        break;\n      }\n    else if (LocaleCompare((const char *) tag,\"resample\") == 0)\n    {\n      double\n        x_resolution,\n        y_resolution;\n\n      if (msl_info->image[n] == (Image *) NULL)\n        {\n          ThrowMSLException(OptionError,\"NoImagesDefined\",\n            (const char *) tag);\n          break;\n        }\n      if (attributes == (const xmlChar **) NULL)\n        break;\n      x_resolution=DefaultResolution;\n      y_resolution=DefaultResolution;\n      for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n      {\n        keyword=(const char *) attributes[i++];\n        attribute=InterpretImageProperties(msl_info->image_info[n],\n          msl_info->attributes[n],(const char *) attributes[i],exception);\n        CloneString(&value,attribute);\n        attribute=DestroyString(attribute);\n        switch (*keyword)\n        {\n          case 'G':\n          case 'g':\n          {\n            if (LocaleCompare(keyword,\"geometry\") == 0)\n              {\n                ssize_t\n                  flags;\n\n                flags=ParseGeometry(value,&geometry_info);\n                if ((flags & SigmaValue) == 0)\n                  geometry_info.sigma*=geometry_info.rho;\n                x_resolution=geometry_info.rho;\n                y_resolution=geometry_info.sigma;\n                break;\n              }\n            ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            break;\n          }\n          case 'X':\n          case 'x':\n          {\n            if (LocaleCompare(keyword,\"x-resolution\") == 0)\n              {\n                x_resolution=StringToDouble(value,(char **) NULL);\n                break;\n              }\n            ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            break;\n          }\n          case 'Y':\n          case 'y':\n          {\n            if (LocaleCompare(keyword,\"y-resolution\") == 0)\n              {\n                y_resolution=StringToDouble(value,(char **) NULL);\n                break;\n              }\n            ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            break;\n          }\n          default:\n          {\n            ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            break;\n          }\n        }\n      }\n      /*\n        Resample image.\n      */\n      {\n        double\n          factor;\n\n        Image\n          *resample_image;\n\n        factor=1.0;\n        if (msl_info->image[n]->units == PixelsPerCentimeterResolution)\n          factor=2.54;\n        width=(size_t) (x_resolution*msl_info->image[n]->columns/\n          (factor*(msl_info->image[n]->resolution.x == 0.0 ? DefaultResolution :\n          msl_info->image[n]->resolution.x))+0.5);\n        height=(size_t) (y_resolution*msl_info->image[n]->rows/\n          (factor*(msl_info->image[n]->resolution.y == 0.0 ? DefaultResolution :\n          msl_info->image[n]->resolution.y))+0.5);\n        resample_image=ResizeImage(msl_info->image[n],width,height,\n          msl_info->image[n]->filter,msl_info->exception);\n        if (resample_image == (Image *) NULL)\n          break;\n        msl_info->image[n]=DestroyImage(msl_info->image[n]);\n        msl_info->image[n]=resample_image;\n      }\n      break;\n    }\n      if (LocaleCompare((const char *) tag,\"resize\") == 0)\n        {\n          FilterType\n            filter;\n\n          Image\n            *resize_image;\n\n          /*\n            Resize image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          filter=UndefinedFilter;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword,\"filter\") == 0)\n                    {\n                      option=ParseCommandOption(MagickFilterOptions,MagickFalse,\n                        value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedNoiseType\",\n                          value);\n                      filter=(FilterType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseRegionGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'H':\n                case 'h':\n                {\n                  if (LocaleCompare(keyword,\"height\") == 0)\n                    {\n                      geometry.height=StringToUnsignedLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"width\") == 0)\n                    {\n                      geometry.width=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          resize_image=ResizeImage(msl_info->image[n],geometry.width,\n            geometry.height,filter,msl_info->exception);\n          if (resize_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=resize_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"roll\") == 0)\n        {\n          Image\n            *roll_image;\n\n          /*\n            Roll image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          SetGeometry(msl_info->image[n],&geometry);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParsePageGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      if ((flags & HeightValue) == 0)\n                        geometry.height=geometry.width;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry.x=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry.y=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          roll_image=RollImage(msl_info->image[n],geometry.x,geometry.y,\n            msl_info->exception);\n          if (roll_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=roll_image;\n          break;\n        }\n      else if (LocaleCompare((const char *) tag,\"roll\") == 0)\n      {\n        /* init the values */\n        width=msl_info->image[n]->columns;\n        height=msl_info->image[n]->rows;\n        x = y = 0;\n\n        if (msl_info->image[n] == (Image *) NULL)\n        {\n          ThrowMSLException(OptionError,\"NoImagesDefined\",\n            (const char *) tag);\n          break;\n        }\n        if (attributes == (const xmlChar **) NULL)\n        break;\n        for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n        {\n          keyword=(const char *) attributes[i++];\n          attribute=InterpretImageProperties(msl_info->image_info[n],\n            msl_info->attributes[n],(const char *) attributes[i],exception);\n          CloneString(&value,attribute);\n          attribute=DestroyString(attribute);\n        switch (*keyword)\n        {\n          case 'G':\n          case 'g':\n          {\n          if (LocaleCompare(keyword,\"geometry\") == 0)\n            {\n            (void) ParseMetaGeometry(value,&x,&y,&width,&height);\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          case 'X':\n          case 'x':\n          {\n          if (LocaleCompare(keyword,\"x\") == 0)\n            {\n            x = StringToLong( value );\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          case 'Y':\n          case 'y':\n          {\n          if (LocaleCompare(keyword,\"y\") == 0)\n            {\n            y = StringToLong( value );\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          default:\n          {\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n        }\n        }\n\n        /*\n          process image.\n        */\n        {\n        Image\n          *newImage;\n\n        newImage=RollImage(msl_info->image[n], x, y, msl_info->exception);\n        if (newImage == (Image *) NULL)\n          break;\n        msl_info->image[n]=DestroyImage(msl_info->image[n]);\n        msl_info->image[n]=newImage;\n        }\n\n        break;\n      }\n      if (LocaleCompare((const char *) tag,\"rotate\") == 0)\n        {\n          Image\n            *rotate_image;\n\n          /*\n            Rotate image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'D':\n                case 'd':\n                {\n                  if (LocaleCompare(keyword,\"degrees\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          rotate_image=RotateImage(msl_info->image[n],geometry_info.rho,\n            msl_info->exception);\n          if (rotate_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=rotate_image;\n          break;\n        }\n      else if (LocaleCompare((const char *) tag,\"rotate\") == 0)\n      {\n        /* init the values */\n        double  degrees = 0;\n\n        if (msl_info->image[n] == (Image *) NULL)\n        {\n          ThrowMSLException(OptionError,\"NoImagesDefined\",\n            (const char *) tag);\n          break;\n        }\n        if (attributes == (const xmlChar **) NULL)\n          break;\n        for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n        {\n          keyword=(const char *) attributes[i++];\n          attribute=InterpretImageProperties(msl_info->image_info[n],\n            msl_info->attributes[n],(const char *) attributes[i],exception);\n          CloneString(&value,attribute);\n          attribute=DestroyString(attribute);\n        switch (*keyword)\n        {\n          case 'D':\n          case 'd':\n          {\n          if (LocaleCompare(keyword,\"degrees\") == 0)\n            {\n            degrees = StringToDouble(value,(char **) NULL);\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          default:\n          {\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n        }\n        }\n\n        /*\n          process image.\n        */\n        {\n        Image\n          *newImage;\n\n        newImage=RotateImage(msl_info->image[n], degrees, msl_info->exception);\n        if (newImage == (Image *) NULL)\n          break;\n        msl_info->image[n]=DestroyImage(msl_info->image[n]);\n        msl_info->image[n]=newImage;\n        }\n\n        break;\n      }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'S':\n    case 's':\n    {\n      if (LocaleCompare((const char *) tag,\"sample\") == 0)\n        {\n          Image\n            *sample_image;\n\n          /*\n            Sample image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseRegionGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'H':\n                case 'h':\n                {\n                  if (LocaleCompare(keyword,\"height\") == 0)\n                    {\n                      geometry.height=StringToUnsignedLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"width\") == 0)\n                    {\n                      geometry.width=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          sample_image=SampleImage(msl_info->image[n],geometry.width,\n            geometry.height,msl_info->exception);\n          if (sample_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=sample_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"scale\") == 0)\n        {\n          Image\n            *scale_image;\n\n          /*\n            Scale image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseRegionGeometry(msl_info->image[n],value,\n                        &geometry,exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'H':\n                case 'h':\n                {\n                  if (LocaleCompare(keyword,\"height\") == 0)\n                    {\n                      geometry.height=StringToUnsignedLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'W':\n                case 'w':\n                {\n                  if (LocaleCompare(keyword,\"width\") == 0)\n                    {\n                      geometry.width=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          scale_image=ScaleImage(msl_info->image[n],geometry.width,\n            geometry.height,msl_info->exception);\n          if (scale_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=scale_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"segment\") == 0)\n        {\n          ColorspaceType\n            colorspace;\n\n          MagickBooleanType\n            verbose;\n\n          /*\n            Segment image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          geometry_info.rho=1.0;\n          geometry_info.sigma=1.5;\n          colorspace=sRGBColorspace;\n          verbose=MagickFalse;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'C':\n                case 'c':\n                {\n                  if (LocaleCompare(keyword,\"cluster-threshold\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"colorspace\") == 0)\n                    {\n                      option=ParseCommandOption(MagickColorspaceOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\n                          \"UnrecognizedColorspaceType\",value);\n                      colorspace=(ColorspaceType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.5;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'S':\n                case 's':\n                {\n                  if (LocaleCompare(keyword,\"smoothing-threshold\") == 0)\n                    {\n                      geometry_info.sigma=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) SegmentImage(msl_info->image[n],colorspace,verbose,\n            geometry_info.rho,geometry_info.sigma,exception);\n          break;\n        }\n      else if (LocaleCompare((const char *) tag, \"set\") == 0)\n      {\n        if (msl_info->image[n] == (Image *) NULL)\n        {\n          ThrowMSLException(OptionError,\"NoImagesDefined\",(const char *) tag);\n          break;\n        }\n\n        if (attributes == (const xmlChar **) NULL)\n          break;\n        for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n        {\n          keyword=(const char *) attributes[i++];\n          attribute=InterpretImageProperties(msl_info->image_info[n],\n            msl_info->attributes[n],(const char *) attributes[i],exception);\n          CloneString(&value,attribute);\n          attribute=DestroyString(attribute);\n          switch (*keyword)\n          {\n            case 'C':\n            case 'c':\n            {\n              if (LocaleCompare(keyword,\"clip-mask\") == 0)\n                {\n                  for (j=0; j < msl_info->n; j++)\n                  {\n                    const char\n                      *property;\n\n                    property=GetImageProperty(msl_info->attributes[j],\"id\",\n                      exception);\n                    if (LocaleCompare(property,value) == 0)\n                      {\n                        SetImageMask(msl_info->image[n],ReadPixelMask,\n                          msl_info->image[j],exception);\n                        break;\n                      }\n                  }\n                  break;\n                }\n              if (LocaleCompare(keyword,\"clip-path\") == 0)\n                {\n                  for (j=0; j < msl_info->n; j++)\n                  {\n                    const char\n                      *property;\n\n                    property=GetImageProperty(msl_info->attributes[j],\"id\",\n                      exception);\n                    if (LocaleCompare(property,value) == 0)\n                      {\n                        SetImageMask(msl_info->image[n],ReadPixelMask,\n                          msl_info->image[j],exception);\n                        break;\n                      }\n                  }\n                  break;\n                }\n              if (LocaleCompare(keyword,\"colorspace\") == 0)\n                {\n                  ssize_t\n                    colorspace;\n\n                  colorspace=(ColorspaceType) ParseCommandOption(\n                    MagickColorspaceOptions,MagickFalse,value);\n                  if (colorspace < 0)\n                    ThrowMSLException(OptionError,\"UnrecognizedColorspace\",\n                      value);\n                  (void) TransformImageColorspace(msl_info->image[n],\n                    (ColorspaceType) colorspace,exception);\n                  break;\n                }\n              (void) SetMSLAttributes(msl_info,keyword,value);\n              (void) SetImageProperty(msl_info->image[n],keyword,value,\n                exception);\n              break;\n            }\n            case 'D':\n            case 'd':\n            {\n              if (LocaleCompare(keyword,\"density\") == 0)\n                {\n                  flags=ParseGeometry(value,&geometry_info);\n                  msl_info->image[n]->resolution.x=geometry_info.rho;\n                  msl_info->image[n]->resolution.y=geometry_info.sigma;\n                  if ((flags & SigmaValue) == 0)\n                    msl_info->image[n]->resolution.y=\n                      msl_info->image[n]->resolution.x;\n                  break;\n                }\n              (void) SetMSLAttributes(msl_info,keyword,value);\n              (void) SetImageProperty(msl_info->image[n],keyword,value,\n                exception);\n              break;\n            }\n            case 'O':\n            case 'o':\n            {\n              if (LocaleCompare(keyword, \"opacity\") == 0)\n                {\n                  ssize_t  opac = OpaqueAlpha,\n                  len = (ssize_t) strlen( value );\n\n                  if (value[len-1] == '%') {\n                    char  tmp[100];\n                    (void) CopyMagickString(tmp,value,len);\n                    opac = StringToLong( tmp );\n                    opac = (int)(QuantumRange * ((float)opac/100));\n                  } else\n                    opac = StringToLong( value );\n                  (void) SetImageAlpha( msl_info->image[n], (Quantum) opac,\n                    exception);\n                  break;\n              }\n              (void) SetMSLAttributes(msl_info,keyword,value);\n              (void) SetImageProperty(msl_info->image[n],keyword,value,\n                msl_info->exception);\n              break;\n            }\n            case 'P':\n            case 'p':\n            {\n              if (LocaleCompare(keyword, \"page\") == 0)\n              {\n                char\n                  page[MagickPathExtent];\n\n                const char\n                  *image_option;\n\n                MagickStatusType\n                  flags;\n\n                RectangleInfo\n                  geometry;\n\n                (void) ResetMagickMemory(&geometry,0,sizeof(geometry));\n                image_option=GetImageArtifact(msl_info->image[n],\"page\");\n                if (image_option != (const char *) NULL)\n                  flags=ParseAbsoluteGeometry(image_option,&geometry);\n                flags=ParseAbsoluteGeometry(value,&geometry);\n                (void) FormatLocaleString(page,MagickPathExtent,\"%.20gx%.20g\",\n                  (double) geometry.width,(double) geometry.height);\n                if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n                  (void) FormatLocaleString(page,MagickPathExtent,\n                    \"%.20gx%.20g%+.20g%+.20g\",(double) geometry.width,\n                    (double) geometry.height,(double) geometry.x,(double)\n                    geometry.y);\n                (void) SetImageOption(msl_info->image_info[n],keyword,page);\n                msl_info->image_info[n]->page=GetPageGeometry(page);\n                break;\n              }\n              (void) SetMSLAttributes(msl_info,keyword,value);\n              (void) SetImageProperty(msl_info->image[n],keyword,value,\n                msl_info->exception);\n              break;\n            }\n            default:\n            {\n              (void) SetMSLAttributes(msl_info,keyword,value);\n              (void) SetImageProperty(msl_info->image[n],keyword,value,\n                msl_info->exception);\n              break;\n            }\n          }\n        }\n        break;\n      }\n      if (LocaleCompare((const char *) tag,\"shade\") == 0)\n        {\n          Image\n            *shade_image;\n\n          MagickBooleanType\n            gray;\n\n          /*\n            Shade image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          gray=MagickFalse;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'A':\n                case 'a':\n                {\n                  if (LocaleCompare(keyword,\"azimuth\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'E':\n                case 'e':\n                {\n                  if (LocaleCompare(keyword,\"elevation\") == 0)\n                    {\n                      geometry_info.sigma=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  if (LocaleCompare(keyword,\"gray\") == 0)\n                    {\n                      option=ParseCommandOption(MagickBooleanOptions,\n                        MagickFalse,value);\n                      if (option < 0)\n                        ThrowMSLException(OptionError,\"UnrecognizedNoiseType\",\n                          value);\n                      gray=(MagickBooleanType) option;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          shade_image=ShadeImage(msl_info->image[n],gray,geometry_info.rho,\n            geometry_info.sigma,msl_info->exception);\n          if (shade_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=shade_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"shadow\") == 0)\n        {\n          Image\n            *shadow_image;\n\n          /*\n            Shear image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'O':\n                case 'o':\n                {\n                  if (LocaleCompare(keyword,\"opacity\") == 0)\n                    {\n                      geometry_info.rho=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'S':\n                case 's':\n                {\n                  if (LocaleCompare(keyword,\"sigma\") == 0)\n                    {\n                      geometry_info.sigma=StringToLong(value);\n                      break;\n                    }\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry_info.xi=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry_info.psi=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          shadow_image=ShadowImage(msl_info->image[n],geometry_info.rho,\n            geometry_info.sigma,(ssize_t) ceil(geometry_info.xi-0.5),\n            (ssize_t) ceil(geometry_info.psi-0.5),msl_info->exception);\n          if (shadow_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=shadow_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"sharpen\") == 0)\n      {\n        double \n            radius = 0.0,\n            sigma = 1.0;\n\n        if (msl_info->image[n] == (Image *) NULL)\n          {\n            ThrowMSLException(OptionError,\"NoImagesDefined\",\n              (const char *) tag);\n            break;\n          }\n        /*\n        NOTE: sharpen can have no attributes, since we use all the defaults!\n        */\n        if (attributes != (const xmlChar **) NULL)\n        {\n          for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n          {\n            keyword=(const char *) attributes[i++];\n            attribute=InterpretImageProperties(msl_info->image_info[n],\n              msl_info->attributes[n],(const char *) attributes[i],exception);\n            CloneString(&value,attribute);\n            attribute=DestroyString(attribute);\n          switch (*keyword)\n          {\n            case 'R':\n            case 'r':\n            {\n              if (LocaleCompare(keyword, \"radius\") == 0)\n              {\n                radius = StringToDouble(value,(char **) NULL);\n                break;\n              }\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n            case 'S':\n            case 's':\n            {\n              if (LocaleCompare(keyword,\"sigma\") == 0)\n              {\n                sigma = StringToLong( value );\n                break;\n              }\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n            default:\n            {\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n          }\n          }\n        }\n\n        /*\n          sharpen image.\n        */\n        {\n        Image\n          *newImage;\n\n        newImage=SharpenImage(msl_info->image[n],radius,sigma,\n          msl_info->exception);\n        if (newImage == (Image *) NULL)\n          break;\n        msl_info->image[n]=DestroyImage(msl_info->image[n]);\n        msl_info->image[n]=newImage;\n        break;\n        }\n      }\n      else if (LocaleCompare((const char *) tag,\"shave\") == 0)\n      {\n        /* init the values */\n        width = height = 0;\n        x = y = 0;\n\n        if (msl_info->image[n] == (Image *) NULL)\n        {\n          ThrowMSLException(OptionError,\"NoImagesDefined\",\n            (const char *) tag);\n          break;\n        }\n        if (attributes == (const xmlChar **) NULL)\n        break;\n        for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n        {\n          keyword=(const char *) attributes[i++];\n          attribute=InterpretImageProperties(msl_info->image_info[n],\n            msl_info->attributes[n],(const char *) attributes[i],exception);\n          CloneString(&value,attribute);\n          attribute=DestroyString(attribute);\n        switch (*keyword)\n        {\n          case 'G':\n          case 'g':\n          {\n          if (LocaleCompare(keyword,\"geometry\") == 0)\n            {\n            (void) ParseMetaGeometry(value,&x,&y,&width,&height);\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          case 'H':\n          case 'h':\n          {\n          if (LocaleCompare(keyword,\"height\") == 0)\n            {\n            height = StringToLong( value );\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          case 'W':\n          case 'w':\n          {\n          if (LocaleCompare(keyword,\"width\") == 0)\n            {\n            width = StringToLong( value );\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          default:\n          {\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n        }\n        }\n\n        /*\n          process image.\n        */\n        {\n        Image\n          *newImage;\n        RectangleInfo\n          rectInfo;\n\n        rectInfo.height = height;\n        rectInfo.width = width;\n        rectInfo.x = x;\n        rectInfo.y = y;\n\n\n        newImage=ShaveImage(msl_info->image[n], &rectInfo,\n          msl_info->exception);\n        if (newImage == (Image *) NULL)\n          break;\n        msl_info->image[n]=DestroyImage(msl_info->image[n]);\n        msl_info->image[n]=newImage;\n        }\n\n        break;\n      }\n      if (LocaleCompare((const char *) tag,\"shear\") == 0)\n        {\n          Image\n            *shear_image;\n\n          /*\n            Shear image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'F':\n                case 'f':\n                {\n                  if (LocaleCompare(keyword, \"fill\") == 0)\n                    {\n                      (void) QueryColorCompliance(value,AllCompliance,\n                        &msl_info->image[n]->background_color,exception);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'X':\n                case 'x':\n                {\n                  if (LocaleCompare(keyword,\"x\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'Y':\n                case 'y':\n                {\n                  if (LocaleCompare(keyword,\"y\") == 0)\n                    {\n                      geometry_info.sigma=StringToLong(value);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          shear_image=ShearImage(msl_info->image[n],geometry_info.rho,\n            geometry_info.sigma,msl_info->exception);\n          if (shear_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=shear_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"signature\") == 0)\n        {\n          /*\n            Signature image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) SignatureImage(msl_info->image[n],exception);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"solarize\") == 0)\n        {\n          /*\n            Solarize image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          geometry_info.rho=QuantumRange/2.0;\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'T':\n                case 't':\n                {\n                  if (LocaleCompare(keyword,\"threshold\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) SolarizeImage(msl_info->image[n],geometry_info.rho,\n            msl_info->exception);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"spread\") == 0)\n        {\n          Image\n            *spread_image;\n\n          /*\n            Spread image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'R':\n                case 'r':\n                {\n                  if (LocaleCompare(keyword,\"radius\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          spread_image=SpreadImage(msl_info->image[n],\n            msl_info->image[n]->interpolate,geometry_info.rho,\n            msl_info->exception);\n          if (spread_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=spread_image;\n          break;\n        }\n      else if (LocaleCompare((const char *) tag,\"stegano\") == 0)\n      {\n        Image *\n          watermark = (Image*) NULL;\n\n        if (msl_info->image[n] == (Image *) NULL)\n          {\n            ThrowMSLException(OptionError,\"NoImagesDefined\",\n              (const char *) tag);\n            break;\n          }\n        if (attributes == (const xmlChar **) NULL)\n        break;\n        for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n        {\n          keyword=(const char *) attributes[i++];\n          attribute=InterpretImageProperties(msl_info->image_info[n],\n            msl_info->attributes[n],(const char *) attributes[i],exception);\n          CloneString(&value,attribute);\n          attribute=DestroyString(attribute);\n        switch (*keyword)\n        {\n          case 'I':\n          case 'i':\n          {\n          if (LocaleCompare(keyword,\"image\") == 0)\n            {\n            for (j=0; j<msl_info->n;j++)\n            {\n              const char *\n                theAttr = GetImageProperty(msl_info->attributes[j], \"id\",\n                      exception);\n              if (theAttr && LocaleCompare(theAttr, value) == 0)\n              {\n                watermark = msl_info->image[j];\n                break;\n              }\n            }\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          default:\n          {\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n        }\n        }\n\n        /*\n          process image.\n        */\n        if ( watermark != (Image*) NULL )\n        {\n        Image\n          *newImage;\n\n        newImage=SteganoImage(msl_info->image[n], watermark, msl_info->exception);\n        if (newImage == (Image *) NULL)\n          break;\n        msl_info->image[n]=DestroyImage(msl_info->image[n]);\n        msl_info->image[n]=newImage;\n        break;\n        } else\n          ThrowMSLException(OptionError,\"MissingWatermarkImage\",keyword);\n      }\n      else if (LocaleCompare((const char *) tag,\"stereo\") == 0)\n      {\n        Image *\n          stereoImage = (Image*) NULL;\n\n        if (msl_info->image[n] == (Image *) NULL)\n          {\n            ThrowMSLException(OptionError,\"NoImagesDefined\",(const char *) tag);\n            break;\n          }\n        if (attributes == (const xmlChar **) NULL)\n        break;\n        for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n        {\n          keyword=(const char *) attributes[i++];\n          attribute=InterpretImageProperties(msl_info->image_info[n],\n            msl_info->attributes[n],(const char *) attributes[i],exception);\n          CloneString(&value,attribute);\n          attribute=DestroyString(attribute);\n        switch (*keyword)\n        {\n          case 'I':\n          case 'i':\n          {\n          if (LocaleCompare(keyword,\"image\") == 0)\n            {\n            for (j=0; j<msl_info->n;j++)\n            {\n              const char *\n                theAttr = GetImageProperty(msl_info->attributes[j], \"id\",\n                      exception);\n              if (theAttr && LocaleCompare(theAttr, value) == 0)\n              {\n                stereoImage = msl_info->image[j];\n                break;\n              }\n            }\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          default:\n          {\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n        }\n        }\n\n        /*\n          process image.\n        */\n        if ( stereoImage != (Image*) NULL )\n        {\n        Image\n          *newImage;\n\n        newImage=StereoImage(msl_info->image[n], stereoImage, msl_info->exception);\n        if (newImage == (Image *) NULL)\n          break;\n        msl_info->image[n]=DestroyImage(msl_info->image[n]);\n        msl_info->image[n]=newImage;\n        break;\n        } else\n          ThrowMSLException(OptionError,\"Missing stereo image\",keyword);\n      }\n      if (LocaleCompare((const char *) tag,\"strip\") == 0)\n        {\n          /*\n            Strip image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            }\n          (void) StripImage(msl_info->image[n],msl_info->exception);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"swap\") == 0)\n        {\n          Image\n            *p,\n            *q,\n            *swap;\n\n          ssize_t\n            index,\n            swap_index;\n\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          index=(-1);\n          swap_index=(-2);\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"indexes\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      index=(ssize_t) geometry_info.rho;\n                      if ((flags & SigmaValue) == 0)\n                        swap_index=(ssize_t) geometry_info.sigma;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          /*\n            Swap images.\n          */\n          p=GetImageFromList(msl_info->image[n],index);\n          q=GetImageFromList(msl_info->image[n],swap_index);\n          if ((p == (Image *) NULL) || (q == (Image *) NULL))\n            {\n              ThrowMSLException(OptionError,\"NoSuchImage\",(const char *) tag);\n              break;\n            }\n          swap=CloneImage(p,0,0,MagickTrue,msl_info->exception);\n          ReplaceImageInList(&p,CloneImage(q,0,0,MagickTrue,\n            msl_info->exception));\n          ReplaceImageInList(&q,swap);\n          msl_info->image[n]=GetFirstImageInList(q);\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"swirl\") == 0)\n        {\n          Image\n            *swirl_image;\n\n          /*\n            Swirl image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'D':\n                case 'd':\n                {\n                  if (LocaleCompare(keyword,\"degrees\") == 0)\n                    {\n                      geometry_info.rho=StringToDouble(value,\n                        (char **) NULL);\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                case 'G':\n                case 'g':\n                {\n                  if (LocaleCompare(keyword,\"geometry\") == 0)\n                    {\n                      flags=ParseGeometry(value,&geometry_info);\n                      if ((flags & SigmaValue) == 0)\n                        geometry_info.sigma=1.0;\n                      break;\n                    }\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          swirl_image=SwirlImage(msl_info->image[n],geometry_info.rho,\n            msl_info->image[n]->interpolate,msl_info->exception);\n          if (swirl_image == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=swirl_image;\n          break;\n        }\n      if (LocaleCompare((const char *) tag,\"sync\") == 0)\n        {\n          /*\n            Sync image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) SyncImage(msl_info->image[n],exception);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'T':\n    case 't':\n    {\n      if (LocaleCompare((const char *) tag,\"map\") == 0)\n        {\n          Image\n            *texture_image;\n\n          /*\n            Texture image.\n          */\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          texture_image=NewImageList();\n          if (attributes != (const xmlChar **) NULL)\n            for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n            {\n              keyword=(const char *) attributes[i++];\n              attribute=InterpretImageProperties(msl_info->image_info[n],\n                msl_info->attributes[n],(const char *) attributes[i],\n                exception);\n              CloneString(&value,attribute);\n              attribute=DestroyString(attribute);\n              switch (*keyword)\n              {\n                case 'I':\n                case 'i':\n                {\n                  if (LocaleCompare(keyword,\"image\") == 0)\n                    for (j=0; j < msl_info->n; j++)\n                    {\n                      const char\n                        *attribute;\n\n                      attribute=GetImageProperty(msl_info->attributes[j],\"id\",\n                      exception);\n                      if ((attribute != (const char *) NULL)  &&\n                          (LocaleCompare(attribute,value) == 0))\n                        {\n                          texture_image=CloneImage(msl_info->image[j],0,0,\n                            MagickFalse,exception);\n                          break;\n                        }\n                    }\n                  break;\n                }\n                default:\n                {\n                  ThrowMSLException(OptionError,\"UnrecognizedAttribute\",\n                    keyword);\n                  break;\n                }\n              }\n            }\n          (void) TextureImage(msl_info->image[n],texture_image,exception);\n          texture_image=DestroyImage(texture_image);\n          break;\n        }\n      else if (LocaleCompare((const char *) tag,\"threshold\") == 0)\n      {\n        /* init the values */\n        double  threshold = 0;\n\n        if (msl_info->image[n] == (Image *) NULL)\n          {\n            ThrowMSLException(OptionError,\"NoImagesDefined\",(const char *) tag);\n            break;\n          }\n        if (attributes == (const xmlChar **) NULL)\n        break;\n        for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n        {\n          keyword=(const char *) attributes[i++];\n          attribute=InterpretImageProperties(msl_info->image_info[n],\n            msl_info->attributes[n],(const char *) attributes[i],exception);\n          CloneString(&value,attribute);\n          attribute=DestroyString(attribute);\n        switch (*keyword)\n        {\n          case 'T':\n          case 't':\n          {\n          if (LocaleCompare(keyword,\"threshold\") == 0)\n            {\n            threshold = StringToDouble(value,(char **) NULL);\n            break;\n            }\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n          default:\n          {\n          ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n          break;\n          }\n        }\n        }\n\n        /*\n          process image.\n        */\n        {\n          BilevelImage(msl_info->image[n],threshold,exception);\n          break;\n        }\n      }\n      else if (LocaleCompare((const char *) tag, \"transparent\") == 0)\n      {\n        if (msl_info->image[n] == (Image *) NULL)\n          {\n            ThrowMSLException(OptionError,\"NoImagesDefined\",(const char *) tag);\n            break;\n          }\n        if (attributes == (const xmlChar **) NULL)\n          break;\n        for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n        {\n          keyword=(const char *) attributes[i++];\n          attribute=InterpretImageProperties(msl_info->image_info[n],\n            msl_info->attributes[n],(const char *) attributes[i],exception);\n          CloneString(&value,attribute);\n          attribute=DestroyString(attribute);\n          switch (*keyword)\n          {\n            case 'C':\n            case 'c':\n            {\n              if (LocaleCompare(keyword,\"color\") == 0)\n              {\n                PixelInfo\n                  target;\n\n                (void) QueryColorCompliance(value,AllCompliance,&target,\n                  exception);\n                (void) TransparentPaintImage(msl_info->image[n],&target,\n                  TransparentAlpha,MagickFalse,msl_info->exception);\n                break;\n              }\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n              break;\n            }\n            default:\n            {\n              ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n            break;\n            }\n          }\n        }\n        break;\n      }\n      else if (LocaleCompare((const char *) tag, \"trim\") == 0)\n      {\n        if (msl_info->image[n] == (Image *) NULL)\n          {\n            ThrowMSLException(OptionError,\"NoImagesDefined\",(const char *) tag);\n            break;\n          }\n\n        /* no attributes here */\n\n        /* process the image */\n        {\n          Image\n            *newImage;\n          RectangleInfo\n            rectInfo;\n\n          /* all zeros on a crop == trim edges! */\n          rectInfo.height = rectInfo.width = 0;\n          rectInfo.x =  rectInfo.y = 0;\n\n          newImage=CropImage(msl_info->image[n],&rectInfo, msl_info->exception);\n          if (newImage == (Image *) NULL)\n            break;\n          msl_info->image[n]=DestroyImage(msl_info->image[n]);\n          msl_info->image[n]=newImage;\n          break;\n        }\n      }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    case 'W':\n    case 'w':\n    {\n      if (LocaleCompare((const char *) tag,\"write\") == 0)\n        {\n          if (msl_info->image[n] == (Image *) NULL)\n            {\n              ThrowMSLException(OptionError,\"NoImagesDefined\",\n                (const char *) tag);\n              break;\n            }\n          if (attributes == (const xmlChar **) NULL)\n            break;\n          for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)\n          {\n            keyword=(const char *) attributes[i++];\n            attribute=InterpretImageProperties(msl_info->image_info[n],\n              msl_info->attributes[n],(const char *) attributes[i],exception);\n            CloneString(&value,attribute);\n            attribute=DestroyString(attribute);\n            switch (*keyword)\n            {\n              case 'F':\n              case 'f':\n              {\n                if (LocaleCompare(keyword,\"filename\") == 0)\n                  {\n                    (void) CopyMagickString(msl_info->image[n]->filename,value,\n                      MagickPathExtent);\n                    break;\n                  }\n                (void) SetMSLAttributes(msl_info,keyword,value);\n              }\n              default:\n              {\n                (void) SetMSLAttributes(msl_info,keyword,value);\n                break;\n              }\n            }\n          }\n\n          /* process */\n          {\n            *msl_info->image_info[n]->magick='\\0';\n            (void) WriteImage(msl_info->image_info[n], msl_info->image[n],\n              msl_info->exception);\n            break;\n          }\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n    }\n    default:\n    {\n      ThrowMSLException(OptionError,\"UnrecognizedElement\",(const char *) tag);\n      break;\n    }\n  }\n  if (value != (char *) NULL)\n    value=DestroyString(value);\n  (void) DestroyExceptionInfo(exception);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  )\");\n}\n\nstatic void MSLEndElement(void *context,const xmlChar *tag)\n{\n  ssize_t\n    n;\n\n  MSLInfo\n    *msl_info;\n\n  /*\n    Called when the end of an element has been detected.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.endElement(%s)\",\n    tag);\n  msl_info=(MSLInfo *) context;\n  n=msl_info->n;\n  switch (*tag)\n  {\n    case 'C':\n    case 'c':\n    {\n      if (LocaleCompare((const char *) tag,\"comment\") == 0 )\n        {\n          (void) DeleteImageProperty(msl_info->image[n],\"comment\");\n          if (msl_info->content == (char *) NULL)\n            break;\n          StripString(msl_info->content);\n          (void) SetImageProperty(msl_info->image[n],\"comment\",\n            msl_info->content,msl_info->exception);\n          break;\n        }\n      break;\n    }\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare((const char *) tag, \"group\") == 0 )\n      {\n        if (msl_info->group_info[msl_info->number_groups-1].numImages > 0 )\n        {\n          ssize_t  i = (ssize_t)\n            (msl_info->group_info[msl_info->number_groups-1].numImages);\n          while ( i-- )\n          {\n            if (msl_info->image[msl_info->n] != (Image *) NULL)\n              msl_info->image[msl_info->n]=DestroyImage(\n                msl_info->image[msl_info->n]);\n            msl_info->attributes[msl_info->n]=DestroyImage(\n                msl_info->attributes[msl_info->n]);\n            msl_info->image_info[msl_info->n]=DestroyImageInfo(\n                msl_info->image_info[msl_info->n]);\n            msl_info->n--;\n          }\n        }\n        msl_info->number_groups--;\n      }\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare((const char *) tag, \"image\") == 0)\n        MSLPopImage(msl_info);\n       break;\n    }\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare((const char *) tag,\"label\") == 0 )\n        {\n          (void) DeleteImageProperty(msl_info->image[n],\"label\");\n          if (msl_info->content == (char *) NULL)\n            break;\n          StripString(msl_info->content);\n          (void) SetImageProperty(msl_info->image[n],\"label\",\n            msl_info->content,msl_info->exception);\n          break;\n        }\n      break;\n    }\n    case 'M':\n    case 'm':\n    {\n      if (LocaleCompare((const char *) tag, \"msl\") == 0 )\n      {\n        /*\n          This our base element.\n            at the moment we don't do anything special\n            but someday we might!\n        */\n      }\n      break;\n    }\n    default:\n      break;\n  }\n  if (msl_info->content != (char *) NULL)\n    msl_info->content=DestroyString(msl_info->content);\n}\n\nstatic void MSLCharacters(void *context,const xmlChar *c,int length)\n{\n  MSLInfo\n    *msl_info;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  /*\n    Receiving some characters from the parser.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.characters(%s,%d)\",c,length);\n  msl_info=(MSLInfo *) context;\n  if (msl_info->content != (char *) NULL)\n    msl_info->content=(char *) ResizeQuantumMemory(msl_info->content,\n      strlen(msl_info->content)+length+MagickPathExtent,\n      sizeof(*msl_info->content));\n  else\n    {\n      msl_info->content=(char *) NULL;\n      if (~(size_t) length >= (MagickPathExtent-1))\n        msl_info->content=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n          sizeof(*msl_info->content));\n      if (msl_info->content != (char *) NULL)\n        *msl_info->content='\\0';\n    }\n  if (msl_info->content == (char *) NULL)\n    return;\n  p=msl_info->content+strlen(msl_info->content);\n  for (i=0; i < length; i++)\n    *p++=c[i];\n  *p='\\0';\n}\n\nstatic void MSLReference(void *context,const xmlChar *name)\n{\n  MSLInfo\n    *msl_info;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    Called when an entity reference is detected.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.reference(%s)\",name);\n  msl_info=(MSLInfo *) context;\n  parser=msl_info->parser;\n  if (*name == '#')\n    (void) xmlAddChild(parser->node,xmlNewCharRef(msl_info->document,name));\n  else\n    (void) xmlAddChild(parser->node,xmlNewReference(msl_info->document,name));\n}\n\nstatic void MSLIgnorableWhitespace(void *context,const xmlChar *c,int length)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    Receiving some ignorable whitespaces from the parser.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.ignorableWhitespace(%.30s, %d)\",c,length);\n  msl_info=(MSLInfo *) context;\n  (void) msl_info;\n}\n\nstatic void MSLProcessingInstructions(void *context,const xmlChar *target,\n  const xmlChar *data)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    A processing instruction has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.processingInstruction(%s, %s)\",\n    target,data);\n  msl_info=(MSLInfo *) context;\n  (void) msl_info;\n}\n\nstatic void MSLComment(void *context,const xmlChar *value)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    A comment has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.comment(%s)\",value);\n  msl_info=(MSLInfo *) context;\n  (void) msl_info;\n}\n\nstatic void MSLWarning(void *context,const char *format,...)\n{\n  char\n    *message,\n    reason[MagickPathExtent];\n\n  MSLInfo\n    *msl_info;\n\n  va_list\n    operands;\n\n  /**\n    Display and format a warning messages, gives file, line, position and\n    extra parameters.\n  */\n  va_start(operands,format);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.warning: \");\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),format,operands);\n  msl_info=(MSLInfo *) context;\n  (void) msl_info;\n#if !defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsprintf(reason,format,operands);\n#else\n  (void) vsnprintf(reason,MagickPathExtent,format,operands);\n#endif\n  message=GetExceptionMessage(errno);\n  ThrowMSLException(CoderError,reason,message);\n  message=DestroyString(message);\n  va_end(operands);\n}\n\nstatic void MSLError(void *context,const char *format,...)\n{\n  char\n    reason[MagickPathExtent];\n\n  MSLInfo\n    *msl_info;\n\n  va_list\n    operands;\n\n  /*\n    Display and format a error formats, gives file, line, position and\n    extra parameters.\n  */\n  va_start(operands,format);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.error: \");\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),format,operands);\n  msl_info=(MSLInfo *) context;\n  (void) msl_info;\n#if !defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsprintf(reason,format,operands);\n#else\n  (void) vsnprintf(reason,MagickPathExtent,format,operands);\n#endif\n  ThrowMSLException(DelegateFatalError,reason,\"SAX error\");\n  va_end(operands);\n}\n\nstatic void MSLCDataBlock(void *context,const xmlChar *value,int length)\n{\n  MSLInfo\n    *msl_info;\n\n   xmlNodePtr\n     child;\n\n  xmlParserCtxtPtr\n    parser;\n\n  /*\n    Called when a pcdata block has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.pcdata(%s, %d)\",value,length);\n  msl_info=(MSLInfo *) context;\n  (void) msl_info;\n  parser=msl_info->parser;\n  child=xmlGetLastChild(parser->node);\n  if ((child != (xmlNodePtr) NULL) && (child->type == XML_CDATA_SECTION_NODE))\n    {\n      xmlTextConcat(child,value,length);\n      return;\n    }\n  (void) xmlAddChild(parser->node,xmlNewCDataBlock(parser->myDoc,value,length));\n}\n\nstatic void MSLExternalSubset(void *context,const xmlChar *name,\n  const xmlChar *external_id,const xmlChar *system_id)\n{\n  MSLInfo\n    *msl_info;\n\n  xmlParserCtxt\n    parser_context;\n\n  xmlParserCtxtPtr\n    parser;\n\n  xmlParserInputPtr\n    input;\n\n  /*\n    Does this document has an external subset?\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.externalSubset(%s %s %s)\",name,\n    (external_id != (const xmlChar *) NULL ? (const char *) external_id : \" \"),\n    (system_id != (const xmlChar *) NULL ? (const char *) system_id : \" \"));\n  msl_info=(MSLInfo *) context;\n  (void) msl_info;\n  parser=msl_info->parser;\n  if (((external_id == NULL) && (system_id == NULL)) ||\n      ((parser->validate == 0) || (parser->wellFormed == 0) ||\n      (msl_info->document == 0)))\n    return;\n  input=MSLResolveEntity(context,external_id,system_id);\n  if (input == NULL)\n    return;\n  (void) xmlNewDtd(msl_info->document,name,external_id,system_id);\n  parser_context=(*parser);\n  parser->inputTab=(xmlParserInputPtr *) xmlMalloc(5*sizeof(*parser->inputTab));\n  if (parser->inputTab == (xmlParserInputPtr *) NULL)\n    {\n      parser->errNo=XML_ERR_NO_MEMORY;\n      parser->input=parser_context.input;\n      parser->inputNr=parser_context.inputNr;\n      parser->inputMax=parser_context.inputMax;\n      parser->inputTab=parser_context.inputTab;\n      return;\n  }\n  parser->inputNr=0;\n  parser->inputMax=5;\n  parser->input=NULL;\n  xmlPushInput(parser,input);\n  (void) xmlSwitchEncoding(parser,xmlDetectCharEncoding(parser->input->cur,4));\n  if (input->filename == (char *) NULL)\n    input->filename=(char *) xmlStrdup(system_id);\n  input->line=1;\n  input->col=1;\n  input->base=parser->input->cur;\n  input->cur=parser->input->cur;\n  input->free=NULL;\n  xmlParseExternalSubset(parser,external_id,system_id);\n  while (parser->inputNr > 1)\n    (void) xmlPopInput(parser);\n  xmlFreeInputStream(parser->input);\n  xmlFree(parser->inputTab);\n  parser->input=parser_context.input;\n  parser->inputNr=parser_context.inputNr;\n  parser->inputMax=parser_context.inputMax;\n  parser->inputTab=parser_context.inputTab;\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic MagickBooleanType ProcessMSLScript(const ImageInfo *image_info,\n  Image **image,ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent];\n\n  Image\n    *msl_image;\n\n  int\n    status;\n\n  ssize_t\n    n;\n\n  MSLInfo\n    msl_info;\n\n  xmlSAXHandler\n    sax_modules;\n\n  xmlSAXHandlerPtr\n    sax_handler;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(image != (Image **) NULL);\n  msl_image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,msl_image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        msl_image->filename);\n      msl_image=DestroyImageList(msl_image);\n      return(MagickFalse);\n    }\n  msl_image->columns=1;\n  msl_image->rows=1;\n  /*\n    Parse MSL file.\n  */\n  (void) ResetMagickMemory(&msl_info,0,sizeof(msl_info));\n  msl_info.exception=exception;\n  msl_info.image_info=(ImageInfo **) AcquireMagickMemory(\n    sizeof(*msl_info.image_info));\n  msl_info.draw_info=(DrawInfo **) AcquireMagickMemory(\n    sizeof(*msl_info.draw_info));\n  /* top of the stack is the MSL file itself */\n  msl_info.image=(Image **) AcquireMagickMemory(sizeof(*msl_info.image));\n  msl_info.attributes=(Image **) AcquireMagickMemory(\n    sizeof(*msl_info.attributes));\n  msl_info.group_info=(MSLGroupInfo *) AcquireMagickMemory(\n    sizeof(*msl_info.group_info));\n  if ((msl_info.image_info == (ImageInfo **) NULL) ||\n      (msl_info.image == (Image **) NULL) ||\n      (msl_info.attributes == (Image **) NULL) ||\n      (msl_info.group_info == (MSLGroupInfo *) NULL))\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToInterpretMSLImage\");\n  *msl_info.image_info=CloneImageInfo(image_info);\n  *msl_info.draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  *msl_info.attributes=AcquireImage(image_info,exception);\n  msl_info.group_info[0].numImages=0;\n  /* the first slot is used to point to the MSL file image */\n  *msl_info.image=msl_image;\n  if (*image != (Image *) NULL)\n    MSLPushImage(&msl_info,*image);\n  (void) xmlSubstituteEntitiesDefault(1);\n  (void) ResetMagickMemory(&sax_modules,0,sizeof(sax_modules));\n  sax_modules.internalSubset=MSLInternalSubset;\n  sax_modules.isStandalone=MSLIsStandalone;\n  sax_modules.hasInternalSubset=MSLHasInternalSubset;\n  sax_modules.hasExternalSubset=MSLHasExternalSubset;\n  sax_modules.resolveEntity=MSLResolveEntity;\n  sax_modules.getEntity=MSLGetEntity;\n  sax_modules.entityDecl=MSLEntityDeclaration;\n  sax_modules.notationDecl=MSLNotationDeclaration;\n  sax_modules.attributeDecl=MSLAttributeDeclaration;\n  sax_modules.elementDecl=MSLElementDeclaration;\n  sax_modules.unparsedEntityDecl=MSLUnparsedEntityDeclaration;\n  sax_modules.setDocumentLocator=MSLSetDocumentLocator;\n  sax_modules.startDocument=MSLStartDocument;\n  sax_modules.endDocument=MSLEndDocument;\n  sax_modules.startElement=MSLStartElement;\n  sax_modules.endElement=MSLEndElement;\n  sax_modules.reference=MSLReference;\n  sax_modules.characters=MSLCharacters;\n  sax_modules.ignorableWhitespace=MSLIgnorableWhitespace;\n  sax_modules.processingInstruction=MSLProcessingInstructions;\n  sax_modules.comment=MSLComment;\n  sax_modules.warning=MSLWarning;\n  sax_modules.error=MSLError;\n  sax_modules.fatalError=MSLError;\n  sax_modules.getParameterEntity=MSLGetParameterEntity;\n  sax_modules.cdataBlock=MSLCDataBlock;\n  sax_modules.externalSubset=MSLExternalSubset;\n  sax_handler=(&sax_modules);\n  msl_info.parser=xmlCreatePushParserCtxt(sax_handler,&msl_info,(char *) NULL,0,\n    msl_image->filename);\n  while (ReadBlobString(msl_image,message) != (char *) NULL)\n  {\n    n=(ssize_t) strlen(message);\n    if (n == 0)\n      continue;\n    status=xmlParseChunk(msl_info.parser,message,(int) n,MagickFalse);\n    if (status != 0)\n      break;\n    (void) xmlParseChunk(msl_info.parser,\" \",1,MagickFalse);\n    if (msl_info.exception->severity >= ErrorException)\n      break;\n  }\n  if (msl_info.exception->severity == UndefinedException)\n    (void) xmlParseChunk(msl_info.parser,\" \",1,MagickTrue);\n  /*\n    Free resources.\n  */\n  xmlFreeParserCtxt(msl_info.parser);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"end SAX\");\n  msl_info.group_info=(MSLGroupInfo *) RelinquishMagickMemory(\n    msl_info.group_info);\n  if (*image == (Image *) NULL)\n    *image=(*msl_info.image);\n  *msl_info.image_info=DestroyImageInfo(*msl_info.image_info);\n  msl_info.image_info=(ImageInfo **) RelinquishMagickMemory(\n    msl_info.image_info);\n  *msl_info.draw_info=DestroyDrawInfo(*msl_info.draw_info);\n  msl_info.draw_info=(DrawInfo **) RelinquishMagickMemory(msl_info.draw_info);\n  msl_info.image=(Image **) RelinquishMagickMemory(msl_info.image);\n  *msl_info.attributes=DestroyImage(*msl_info.attributes);\n  msl_info.attributes=(Image **) RelinquishMagickMemory(msl_info.attributes);\n  msl_info.group_info=(MSLGroupInfo *) RelinquishMagickMemory(\n    msl_info.group_info);\n  if (msl_info.exception->severity != UndefinedException)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\nstatic Image *ReadMSLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=(Image *) NULL;\n  (void) ProcessMSLScript(image_info,&image,exception);\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r M S L I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterMSLImage() adds attributes for the MSL image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterMSLImage method is:\n%\n%      size_t RegisterMSLImage(void)\n%\n*/\nModuleExport size_t RegisterMSLImage(void)\n{\n  MagickInfo\n    *entry;\n\n#if defined(MAGICKCORE_XML_DELEGATE)\n  xmlInitParser();\n#endif\n  entry=AcquireMagickInfo(\"MSL\",\"MSL\",\"Magick Scripting Language\");\n#if defined(MAGICKCORE_XML_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadMSLImage;\n  entry->encoder=(EncodeImageHandler *) WriteMSLImage;\n#endif\n  entry->format_type=ImplicitFormatType;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n#if defined(MAGICKCORE_XML_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t M S L A t t r i b u t e s                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetMSLAttributes() ...\n%\n%  The format of the SetMSLAttributes method is:\n%\n%      MagickBooleanType SetMSLAttributes(MSLInfo *msl_info,\n%        const char *keyword,const char *value)\n%\n%  A description of each parameter follows:\n%\n%    o msl_info: the MSL info.\n%\n%    o keyword: the keyword.\n%\n%    o value: the value.\n%\n*/\nstatic MagickBooleanType SetMSLAttributes(MSLInfo *msl_info,const char *keyword,\n  const char *value)\n{\n  Image\n    *attributes;\n\n  DrawInfo\n    *draw_info;\n\n  ExceptionInfo\n    *exception;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image;\n\n  ImageInfo\n    *image_info;\n\n  int\n    flags;\n\n  ssize_t\n    n;\n\n  assert(msl_info != (MSLInfo *) NULL);\n  if (keyword == (const char *) NULL)\n    return(MagickTrue);\n  if (value == (const char *) NULL)\n    return(MagickTrue);\n  exception=msl_info->exception;\n  n=msl_info->n;\n  attributes=msl_info->attributes[n];\n  image_info=msl_info->image_info[n];\n  draw_info=msl_info->draw_info[n];\n  image=msl_info->image[n];\n  switch (*keyword)\n  {\n    case 'A':\n    case 'a':\n    {\n      if (LocaleCompare(keyword,\"adjoin\") == 0)\n        {\n          ssize_t\n            adjoin;\n\n          adjoin=ParseCommandOption(MagickBooleanOptions,MagickFalse,value);\n          if (adjoin < 0)\n            ThrowMSLException(OptionError,\"UnrecognizedType\",value);\n          image_info->adjoin=(MagickBooleanType) adjoin;\n          break;\n        }\n      if (LocaleCompare(keyword,\"alpha\") == 0)\n        {\n          ssize_t\n            alpha;\n\n          alpha=ParseCommandOption(MagickAlphaChannelOptions,MagickFalse,value);\n          if (alpha < 0)\n            ThrowMSLException(OptionError,\"UnrecognizedType\",value);\n          if (image != (Image *) NULL)\n            (void) SetImageAlphaChannel(image,(AlphaChannelOption) alpha,\n              exception);\n          break;\n        }\n      if (LocaleCompare(keyword,\"antialias\") == 0)\n        {\n          ssize_t\n            antialias;\n\n          antialias=ParseCommandOption(MagickBooleanOptions,MagickFalse,value);\n          if (antialias < 0)\n            ThrowMSLException(OptionError,\"UnrecognizedGravityType\",value);\n          image_info->antialias=(MagickBooleanType) antialias;\n          break;\n        }\n      if (LocaleCompare(keyword,\"area-limit\") == 0)\n        {\n          MagickSizeType\n            limit;\n\n          limit=MagickResourceInfinity;\n          if (LocaleCompare(value,\"unlimited\") != 0)\n            limit=(MagickSizeType) StringToDoubleInterval(value,100.0);\n          (void) SetMagickResourceLimit(AreaResource,limit);\n          break;\n        }\n      if (LocaleCompare(keyword,\"attenuate\") == 0)\n        {\n          (void) SetImageOption(image_info,keyword,value);\n          break;\n        }\n      if (LocaleCompare(keyword,\"authenticate\") == 0)\n        {\n          (void) CloneString(&image_info->density,value);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n      break;\n    }\n    case 'B':\n    case 'b':\n    {\n      if (LocaleCompare(keyword,\"background\") == 0)\n        {\n          (void) QueryColorCompliance(value,AllCompliance,\n            &image_info->background_color,exception);\n          break;\n        }\n      if (LocaleCompare(keyword,\"blue-primary\") == 0)\n        {\n          if (image == (Image *) NULL)\n            break;\n          flags=ParseGeometry(value,&geometry_info);\n          image->chromaticity.blue_primary.x=geometry_info.rho;\n          image->chromaticity.blue_primary.y=geometry_info.sigma;\n          if ((flags & SigmaValue) == 0)\n            image->chromaticity.blue_primary.y=\n              image->chromaticity.blue_primary.x;\n          break;\n        }\n      if (LocaleCompare(keyword,\"bordercolor\") == 0)\n        {\n          (void) QueryColorCompliance(value,AllCompliance,\n            &image_info->border_color,exception);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n      break;\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleCompare(keyword,\"density\") == 0)\n        {\n          (void) CloneString(&image_info->density,value);\n          (void) CloneString(&draw_info->density,value);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n      break;\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleCompare(keyword,\"fill\") == 0)\n        {\n          (void) QueryColorCompliance(value,AllCompliance,&draw_info->fill,\n            exception);\n          (void) SetImageOption(image_info,keyword,value);\n          break;\n        }\n      if (LocaleCompare(keyword,\"filename\") == 0)\n        {\n          (void) CopyMagickString(image_info->filename,value,MagickPathExtent);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n      break;\n    }\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare(keyword,\"gravity\") == 0)\n        {\n          ssize_t\n            gravity;\n\n          gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,value);\n          if (gravity < 0)\n            ThrowMSLException(OptionError,\"UnrecognizedGravityType\",value);\n          (void) SetImageOption(image_info,keyword,value);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare(keyword,\"id\") == 0)\n        {\n          (void) SetImageProperty(attributes,keyword,value,exception);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n      break;\n    }\n    case 'M':\n    case 'm':\n    {\n      if (LocaleCompare(keyword,\"magick\") == 0)\n        {\n          (void) CopyMagickString(image_info->magick,value,MagickPathExtent);\n          break;\n        }\n      if (LocaleCompare(keyword,\"mattecolor\") == 0)\n        {\n          (void) QueryColorCompliance(value,AllCompliance,\n            &image_info->matte_color,exception);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n      break;\n    }\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare(keyword,\"pointsize\") == 0)\n        {\n          image_info->pointsize=StringToDouble(value,(char **) NULL);\n          draw_info->pointsize=StringToDouble(value,(char **) NULL);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n      break;\n    }\n    case 'Q':\n    case 'q':\n    {\n      if (LocaleCompare(keyword,\"quality\") == 0)\n        {\n          image_info->quality=StringToLong(value);\n          if (image == (Image *) NULL)\n            break;\n          image->quality=StringToLong(value);\n          break;\n        }\n      break;\n    }\n    case 'S':\n    case 's':\n    {\n      if (LocaleCompare(keyword,\"size\") == 0)\n        {\n          (void) CloneString(&image_info->size,value);\n          break;\n        }\n      if (LocaleCompare(keyword,\"stroke\") == 0)\n        {\n          (void) QueryColorCompliance(value,AllCompliance,&draw_info->stroke,\n            exception);\n          (void) SetImageOption(image_info,keyword,value);\n          break;\n        }\n      ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n      break;\n    }\n    default:\n    {\n      ThrowMSLException(OptionError,\"UnrecognizedAttribute\",keyword);\n      break;\n    }\n  }\n  return(MagickTrue);\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r M S L I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterMSLImage() removes format registrations made by the\n%  MSL module from the list of supported formats.\n%\n%  The format of the UnregisterMSLImage method is:\n%\n%      UnregisterMSLImage(void)\n%\n*/\nModuleExport void UnregisterMSLImage(void)\n{\n  (void) UnregisterMagickInfo(\"MSL\");\n#if defined(MAGICKCORE_XML_DELEGATE)\n  xmlCleanupParser();\n#endif\n}\n\f\n#if defined(MAGICKCORE_XML_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e M S L I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteMSLImage() writes an image to a file in MVG image format.\n%\n%  The format of the WriteMSLImage method is:\n%\n%      MagickBooleanType WriteMSLImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteMSLImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  Image\n    *msl_image;\n\n  MagickBooleanType\n    status;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  msl_image=CloneImage(image,0,0,MagickTrue,exception);\n  status=ProcessMSLScript(image_info,&msl_image,exception);\n  if (msl_image != (Image *) NULL)\n    msl_image=DestroyImage(msl_image);\n  return(status);\n}\n#endif\n"], "filenames": ["ChangeLog", "coders/msl.c"], "buggy_code_start_loc": [0, 7907], "buggy_code_end_loc": [0, 7913], "fixing_code_start_loc": [1, 7908], "fixing_code_end_loc": [5, 7927], "type": "CWE-772", "message": "The ProcessMSLScript function in coders/msl.c in ImageMagick before 6.9.9-5 and 7.x before 7.0.6-5 allows remote attackers to cause a denial of service (memory leak) via a crafted file, related to the WriteMSLImage function.", "other": {"cve": {"id": "CVE-2017-12427", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-04T09:29:00.283", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The ProcessMSLScript function in coders/msl.c in ImageMagick before 6.9.9-5 and 7.x before 7.0.6-5 allows remote attackers to cause a denial of service (memory leak) via a crafted file, related to the WriteMSLImage function."}, {"lang": "es", "value": "La funci\u00f3n ProcessMSLScript en coders/msl.c de ImageMagick anterior a la versi\u00f3n 6.9.9-5 y 7.x anterior a 7.0.6-5 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (filtrado de memoria) mediante un archivo manipulado, relacionado con la funci\u00f3n WriteMSLImage."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-772"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.9.9-4", "matchCriteriaId": "D6A41663-3042-4B23-A030-542E6E3F2951"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-0:*:*:*:*:*:*:*", "matchCriteriaId": "693C9F8F-A8C1-4D06-8F31-E085E16E701C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-1:*:*:*:*:*:*:*", "matchCriteriaId": "6D3D3DFC-8459-41BA-BF3E-AE84E48FCEE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-2:*:*:*:*:*:*:*", "matchCriteriaId": "A3E12EB4-B8F6-43A3-847D-DBC96AE10905"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-3:*:*:*:*:*:*:*", "matchCriteriaId": "30539421-5872-4C2E-94AE-8A2B05C952C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-4:*:*:*:*:*:*:*", "matchCriteriaId": "1A5B7537-8563-409D-82DE-EB07107D3C04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-5:*:*:*:*:*:*:*", "matchCriteriaId": "FA648D3C-A464-4F54-8B5E-E8431531FBB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-6:*:*:*:*:*:*:*", "matchCriteriaId": "D6666BB0-B211-490F-884C-BE410CD19DAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-7:*:*:*:*:*:*:*", "matchCriteriaId": "5FF2582D-1513-448B-8B61-9C4844B08324"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-8:*:*:*:*:*:*:*", "matchCriteriaId": "E57E6BA4-A727-4CF5-B15F-76632D02617A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-9:*:*:*:*:*:*:*", "matchCriteriaId": "C721BC6F-61DD-4ED1-8024-2946C494AEC4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-10:*:*:*:*:*:*:*", "matchCriteriaId": "CD319D32-FE7A-456D-AFEE-DC9F0D98652C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-0:*:*:*:*:*:*:*", "matchCriteriaId": "09CDF263-38F5-469F-984B-9D9A223159B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-1:*:*:*:*:*:*:*", "matchCriteriaId": "243FF3C1-D676-4D5F-A90C-3017DCBBE73A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-2:*:*:*:*:*:*:*", "matchCriteriaId": "1B8BDDE6-6B38-442B-83A4-FAADBAE1C792"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-3:*:*:*:*:*:*:*", "matchCriteriaId": "4DCD89B9-6A69-41DE-BE38-5E9193828279"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-4:*:*:*:*:*:*:*", "matchCriteriaId": "139BC277-8E00-4700-8B47-6D3A3CB38B04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-5:*:*:*:*:*:*:*", "matchCriteriaId": "D0FA2E18-6F7B-49D6-B60C-38851398F9B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-6:*:*:*:*:*:*:*", "matchCriteriaId": "7B7F510A-A439-47A3-AF31-4BF7F74D58A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-7:*:*:*:*:*:*:*", "matchCriteriaId": "A91B94E3-33BB-46B6-A1AE-EAA9906605CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-8:*:*:*:*:*:*:*", "matchCriteriaId": "F5B3DE17-08A8-457D-9AEB-BD6E04376B34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-9:*:*:*:*:*:*:*", "matchCriteriaId": "98AD438E-28B7-4491-B58F-55FDE7F67CFD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-10:*:*:*:*:*:*:*", "matchCriteriaId": "7E033A09-4F2F-4957-A9A8-5C9E7D90A1CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-0:*:*:*:*:*:*:*", "matchCriteriaId": "BB9B68E7-0E40-437A-A71B-0C078FE76FD8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-1:*:*:*:*:*:*:*", "matchCriteriaId": "948D5778-AD2A-4293-AE39-A406D75F5678"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-2:*:*:*:*:*:*:*", "matchCriteriaId": "D391DECE-2408-4A8F-ACE6-F18028C422A3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-3:*:*:*:*:*:*:*", "matchCriteriaId": "CC773CB4-0E7B-4D73-AB9C-D7CC98C38BD7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-4:*:*:*:*:*:*:*", "matchCriteriaId": "24A0C584-9DA3-48B0-B152-67B9E0239876"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-5:*:*:*:*:*:*:*", "matchCriteriaId": "E42943C5-CC66-4E88-9085-1BD39937C09B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-6:*:*:*:*:*:*:*", "matchCriteriaId": "E396985D-BE6A-4F4C-B294-FE69724534EF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-7:*:*:*:*:*:*:*", "matchCriteriaId": "D1D84944-322C-4B5D-9B1C-587301747A34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-8:*:*:*:*:*:*:*", "matchCriteriaId": "B48F5327-CA20-4756-A06F-B30B660E8DA7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-9:*:*:*:*:*:*:*", "matchCriteriaId": "84C11EC2-C798-4C3B-8E00-9C70C3499B33"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-10:*:*:*:*:*:*:*", "matchCriteriaId": "D30A3BD6-5903-42D6-A1E3-C6D2FE468A1E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-0:*:*:*:*:*:*:*", "matchCriteriaId": "441F9FAE-11FA-4976-8BB3-4A3A79B57663"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-1:*:*:*:*:*:*:*", "matchCriteriaId": "F4389D4A-8AD4-421E-AD4D-6761F45B7F6B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-2:*:*:*:*:*:*:*", "matchCriteriaId": "1620AF57-49AF-4487-80A1-07627F50F817"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-3:*:*:*:*:*:*:*", "matchCriteriaId": "DF373D13-0AB1-4518-AFFE-D09A5F56E992"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-4:*:*:*:*:*:*:*", "matchCriteriaId": "86483865-BFC3-4845-80DE-A6AC632A92A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-5:*:*:*:*:*:*:*", "matchCriteriaId": "2A147E12-E5D4-400E-9432-BB5BCF2352CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-6:*:*:*:*:*:*:*", "matchCriteriaId": "B1F2BF9D-9821-424E-8F06-BFB637C103A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-7:*:*:*:*:*:*:*", "matchCriteriaId": "26D7231D-442B-4E7C-BCB2-EE8D787FD46D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-8:*:*:*:*:*:*:*", "matchCriteriaId": "749B8733-47B0-4F63-874D-62DF323CD045"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-9:*:*:*:*:*:*:*", "matchCriteriaId": "AD9D1C91-B67A-430B-AB24-DCC7DAF69D7C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-10:*:*:*:*:*:*:*", "matchCriteriaId": "0C5BE761-44E8-4614-BBD4-3FA7148156B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-0:*:*:*:*:*:*:*", "matchCriteriaId": "79AA4723-3637-4FA7-AE60-9CEE7C535A13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-1:*:*:*:*:*:*:*", "matchCriteriaId": "2D1F577A-316C-4ECE-91CB-4C15F12CC63B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-4:*:*:*:*:*:*:*", "matchCriteriaId": "68F19A0F-29E9-40A5-B6BB-23C20343CDBE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-5:*:*:*:*:*:*:*", "matchCriteriaId": "72A65A02-CD63-4DDD-AFCC-FE6988F85E13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-6:*:*:*:*:*:*:*", "matchCriteriaId": "25690796-E494-4D28-BB4F-AAF40D596AC7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-7:*:*:*:*:*:*:*", "matchCriteriaId": "A2C0242E-0292-4DF7-A3FC-BE96DA95E7D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-8:*:*:*:*:*:*:*", "matchCriteriaId": "9F853E8E-1ED2-4BDA-BE60-BBE1F658695B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-9:*:*:*:*:*:*:*", "matchCriteriaId": "859F0FF1-EAA3-4DAC-A669-0C6B8590576F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-10:*:*:*:*:*:*:*", "matchCriteriaId": "3D7D7BFB-7FE0-4477-AF72-E5BCE1A39FFC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.6-0:*:*:*:*:*:*:*", "matchCriteriaId": "5F56AEC8-473C-4898-A9A8-14E151F3A322"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.6-1:*:*:*:*:*:*:*", "matchCriteriaId": "72A6252A-35A7-4D74-AF0E-0A7B4B12B146"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.6-2:*:*:*:*:*:*:*", "matchCriteriaId": "7E47D35D-B2EB-4957-A0C8-7DE54233997F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.6-3:*:*:*:*:*:*:*", "matchCriteriaId": "06235879-834B-4D96-A5FA-5613E968D612"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.6-4:*:*:*:*:*:*:*", "matchCriteriaId": "5232BD2F-4F7B-483C-B605-D7EBD4C227A3"}]}]}], "references": [{"url": "https://github.com/ImageMagick/ImageMagick/commit/e793eb203e5e0f91f5037aed6585e81b1e27395b", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/636", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201711-07", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/e793eb203e5e0f91f5037aed6585e81b1e27395b"}}