{"buggy_code": ["<p align=\"center\">\n  <img src=\"https://github.com/jcubic/sysend.js/blob/master/assets/logo.svg?raw=true\" alt=\"Sysend.js logo\"/>\n</p>\n\n[![npm](https://img.shields.io/badge/npm-1.9.0-blue.svg)](https://www.npmjs.com/package/sysend)\n![bower](https://img.shields.io/badge/bower-1.9.0-yellow.svg)\n![downloads](https://img.shields.io/npm/dt/sysend.svg)\n[![jsdelivr](https://img.shields.io/jsdelivr/npm/hm/sysend)](https://www.jsdelivr.com/package/npm/sysend)\n\n# [Web application synchronization between different tabs](https://github.com/jcubic/sysend.js/)\n\nsysend.js is a small library that allows to send messages between pages that are\nopen in the same browser. It also supports Cross-Domain communication. The library doesn't have\nany dependencies and uses the HTML5 LocalStorage API or BroadcastChannel API.\nIf your browser don't support BroadcastChannel (see [Can I Use](https://caniuse.com/#feat=broadcastchannel))\nthen you can send any object that can be serialized to JSON. With BroadcastChannel you can send any object\n(it will not be serialized to string but the values are limited to the ones that can be copied by\nthe [structured cloning algorithm](https://html.spec.whatwg.org/multipage/structured-data.html#structured-clone)).\nYou can also send empty notifications.\n\nTested on:\n\nGNU/Linux: in Chromium 34, FireFox 29, Opera 12.16 (64bit)<br/>\nWindows 10 64bit: in IE11 and Edge 38, Chrome 56, Firefox 51<br/>\nMacOS X El Captain: Safari 9, Chrome 56, Firefox 51\n\n## Note about Safari 7+ and Cross-Domain communication\n\nAll cross-domain communication is disabled by default with Safari 7+.\nBecause of a feature that block 3rd party tracking for iframe, and any\niframe used for cross-domain communication runs in sandboxed environment.\nThat's why this library like any other solution for cross-domain comunication,\ndon't work on Safari.\n\n## Installation\n\nInclude `sysend.js` file in your html, you can grab the file from npm:\n\n```\nnpm install sysend\n```\n\nor bower\n\n\n```\nbower install sysend\n```\n\nyou can also get it from unpkg.com CDN:\n\n```\nhttps://unpkg.com/sysend\n```\n\nor jsDelivr:\n\n```\nhttps://cdn.jsdelivr.net/npm/sysend\n```\n\njsDelivr will minify the file. From my testing it's faster then unpkg.com.\n\n## Usage\n\n```javascript\nwindow.onload = function() {\n    sysend.on('foo', function(data) {\n        console.log(data.message);\n    });\n    var input = document.getElementsByTagName('input')[0];\n    document.getElementsByTagName('button')[0].onclick = function() {\n        sysend.broadcast('foo', { message: input.value });\n    };\n};\n```\n\nIf you want to add support for Cross-Domain communication, you need to call proxy method with url on target domain\nthat have [proxy.html file](https://github.com/jcubic/sysend.js/blob/master/proxy.html).\n\n```javascript\nsysend.proxy('https://jcubic.pl');\nsysend.proxy('https://terminal.jcubic.pl');\n```\n\non Firefox you need to add **CORS** for the proxy.html that will be loaded into iframe (see [Cross-Domain LocalStorage](https://jcubic.wordpress.com/2014/06/20/cross-domain-localstorage/))\n\nif you want to send custom data you can use serializer (new in 1.4.0).\nExample serializer can be [json-dry](https://github.com/11ways/json-dry).\n\n```javascript\nsysend.serializer(function(data) {\n    return Dry.stringify(data);\n}, function(string) {\n    return Dry.parse(string);\n});\n````\n\n## Demo\n\nOpen this [demo page](http://jcubic.pl/sysend.php) in two tabs/windows (there is also link to other domain).\n\nHere is another example that shows [ReactJS shopping cart synchronization](https://codepen.io/jcubic/pen/QWgmBmE).\n\nAnd here is [multiple window tracking demo](https://jcubic.pl/windows.html). Open the link in multiple windows (not tabs). First window will track position and size for all windows.\n\n![Screen capture of Operating System Windows dragging and moving around animation](https://github.com/jcubic/sysend.js/blob/master/assets/windows-demo.gif?raw=true)\n\n## Cross-domain Commuication Security\n\nThe iframe communication proxy, allow attackers to listen to any events sent to the iframe.\nAll they need to do is to use this code on any domain to connect to sysend channel:\n\n```javascript\nsysend.proxy('https://jcubic.pl/');\nwindow.addEventListener('message', (e) => {\n    console.log(e);\n});\n```\n\nThis can lead to potential leaking of sensitive information from the website.\nAs of now there are not soution how to secure sysend cross-domain communication channel.\n\n**To protect your application, don't send any sensitive infromation with cross-domain communication!**\n\n## API\n\nsysend object:\n\n| function | description | arguments | Version |\n|---|---|---|---|\n| `on(name, callback)` | add event handler for specified name | name - `string` - The name of the event<br>callback - function `(object, name) => void` | 1.0.0 |\n| `off(name [, callback])` | remove event handler for given name, if callback is not specified it will remove all callbacks for given name | name - `string` - The name of the event<br>callback - optional function `(object, name) => void` | 1.0.0 |\n| `broadcast(name [, object])` | send any object and fire all events with specified name (in different pages that register callback using on). You can also just send notification without an object | name - string - The name of the event<br>object - optional any data | 1.0.0 |\n| `proxy(url)` | create iframe proxy for different domain, the target domain/URL should have [proxy.html](https://github.com/jcubic/sysend.js/blob/master/proxy.html)<br> file. If url domain is the same as page domain, it's ignored. So you can put both proxy calls on both | url - string | 1.3.0 |\n| `serializer(to_string, from_string)` | add serializer and deserializer functions | both arguments are functions (data: any) => string | 1.4.0 |\n| `emit(name, [, object])` | same as `broadcast()` but also invoke the even on same page | name - string - The name of the event<br>object - optional any data | 1.5.0 |\n| `post(<window_id>, [, object])` | send any data to other window | window_id - string of the target window<br>object - any data | 1.6.0 |\n| `list()` | returns a Promise of objects `{id:<UUID>, primary}` for other windows, you can use those to send a message with `post()` | NA | 1.6.0 |\n| `track(event, callback)` | track inter window communication events  | event - any of the strings: `\"open\"`, `\"close\"`, `\"primary\"`, <br>`\"secondary\"`, `\"message\"`<br>callback - different function depend on the event:<br>* `\"message\"` - `{data, origin}` - where data is anything the `post()` sends, and origin is `id` of the sender.<br>* `\"open\"` - `{count, primary, id}` when new window/tab is opened<br>* `\"close\"` - `{count, primary, id, self}` when window/tab is closed<br>* `\"primary\"` and `\"secondary\"` function has no arguments and is called when window/tab become secondary or primary.<br>* `\"ready\"` - event when tracking is ready. | 1.6.0 except `ready` - 1.9.0 |\n| `untrack(event [,callback])` | remove sigle event listener all all listeners for a given event | event - any of the strings `'open'`, `'close'`, `'primary'`, `'secondary'`, or `'message'`. | 1.6.0 |\n| `isPrimary()` | function returns true if window is primary (first open or last that remain) | NA  | 1.6.0 |\n\nTo see details of using the API, see [demo.html source code](https://github.com/jcubic/sysend.js/blob/master/demo.html) or [TypeScript definition file](https://github.com/jcubic/sysend.js/blob/master/sysend.d.ts).\n\n## License\n\nCopyright (C) 2014-2022 [Jakub T. Jankiewicz](https://jcubic.pl/me)<br/>\nReleased under the [MIT license](https://opensource.org/licenses/MIT)\n\nThis is free software; you are free to change and redistribute it.<br/>\nThere is NO WARRANTY, to the extent permitted by law.\n", "{\n  \"name\": \"sysend\",\n  \"version\": \"1.9.0\",\n  \"description\": \"Web application synchronization between different tabs\",\n  \"main\": \"sysend.js\",\n  \"typings\": \"sysend.d.ts\",\n  \"scripts\": {\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/jcubic/sysend.js.git\"\n  },\n  \"keywords\": [\n    \"tabs\",\n    \"windows\",\n    \"messages\",\n    \"cross-domain\",\n    \"cors\",\n    \"domain\",\n    \"communication\",\n    \"events\",\n    \"callback\",\n    \"notifications\",\n    \"browser\"\n  ],\n  \"author\": \"Jakub T. Jankiewicz <jcubic@onet.pl> (https://jcubic.pl/me/)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/jcubic/sysend.js/issues\"\n  },\n  \"homepage\": \"https://github.com/jcubic/sysend.js#readme\"\n}\n", "<!DOCTYPE HTML>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"robots\" content=\"noindex,nofollow\"/>\n    <script src=\"https://cdn.jsdelivr.net/npm/sysend\"></script>\n</head>\n<body>\n</body>\n</html>\n", "/**@license\n *  sysend.js - send messages between browser windows/tabs version 1.9.0\n *\n *  Copyright (C) 2014-2022 Jakub T. Jankiewicz <https://jcubic.pl/me>\n *  Released under the MIT license\n *\n */\ntype callback = (message: any, event: string) => void;\n\ninterface Sysend {\n    id: string;\n    broadcast(event: string, data?: any): void;\n    emit(event: string, data?: any): void;\n    on(event: string, callback: callback): void;\n    off(event: string, callback?: callback): void;\n    proxy(url: string): void;\n    serializer(to: (data: any) => string, from: (data: string) => any): void;\n    track(event: 'open', callback: (data: {id: string, count: number, primary: boolean}) => void): void;\n    track(event: 'close', callback: (data: {id: string, count: number, primary: boolean, self: boolean}) => void): void;\n    track(event: 'primary', callback: () => void): void;\n    track(event: 'message', callback: (payload: {data: any, origin: string}) => void): void;\n    track(event: 'secondary', callback: () => void): void;\n    untrack(event: 'open' | 'close' | 'primary' | 'secondary' | 'message', fn?: (input?: any) => void): void;\n    list(): Promise<Array<{ id: string, primary: boolean }>>;\n    post(target: string, data?: any): void;\n    isPrimary(): boolean;\n}\n\ndeclare const sysend: Sysend;\n\nexport default sysend;\n", "/**@license\n *  sysend.js - send messages between browser windows/tabs version 1.9.0\n *\n *  Copyright (C) 2014-2022 Jakub T. Jankiewicz <https://jcubic.pl/me>\n *  Released under the MIT license\n *\n *  The idea for localStorage implementation came from this StackOverflow question:\n *  http://stackoverflow.com/q/24182409/387194\n *\n */\n/* global define, module, exports, localStorage, setTimeout */\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define(['sysend'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.sysend = factory();\n    }\n})(typeof window !== \"undefined\" ? window : this, function() {\n    var collecting_timeout = 400;\n    // we use prefix so `foo' event don't collide with `foo' locaStorage value\n    var uniq_prefix = '___sysend___';\n    var prefix_re = new RegExp(uniq_prefix);\n    var random_value = Math.random();\n    var serializer = {};\n    // object with user events as keys and values arrays of callback functions\n    var callbacks = {};\n    var has_primary;\n    var iframes = [];\n    var index = 0;\n    var channel;\n    var primary = true;\n    // we use id because storage event is not executed if message was not\n    // changed, and we want it if user send same object twice (before it will\n    // be removed)\n    var id = 0;\n    // identifier for making each call to list unique\n    var list_id = 0;\n\n    // id of the window/tab\n    var target_id = generate_uuid();\n    var target_count = 1;\n\n    var handlers = {\n        primary: [],\n        close: [],\n        open: [],\n        secondary: [],\n        message: [],\n        visbility: [],\n        ready: []\n    };\n    var events = Object.keys(handlers);\n    // -------------------------------------------------------------------------\n    var serialize = make_process(serializer, 'to');\n    var unserialize = make_process(serializer, 'from');\n    // -------------------------------------------------------------------------\n    var sysend = {\n        id: target_id,\n        broadcast: function(event, data) {\n            if (channel) {\n                channel.postMessage({name: event, data: serialize(data)});\n            } else {\n                set(event, to_json(data));\n                // clean up localstorage\n                setTimeout(function() {\n                    remove(event);\n                }, 0);\n            }\n            send_to_iframes(event, data);\n        },\n        emit: function(event, data) {\n            sysend.broadcast(event, data);\n            invoke(event, data);\n        },\n        serializer: function(to, from) {\n            if (typeof to !== 'function' || typeof from !== 'function') {\n                throw new Error('sysend::serializer: Invalid argument, expecting' +\n                                ' function');\n            }\n            serializer.to = to;\n            serializer.from = from;\n        },\n        proxy: function(url) {\n            if (typeof url === 'string' && host(url) !== window.location.host) {\n                var iframe = document.createElement('iframe');\n                iframe.style.width = iframe.style.height = 0;\n                iframe.style.border = 'none';\n                var proxy_url = url;\n                if (!url.match(/\\.html$/)) {\n                    proxy_url = url.replace(/\\/$/, '') + '/proxy.html';\n                }\n                iframe.addEventListener('error', function handler() {\n                    setTimeout(function() {\n                        throw new Error('html proxy file not found on \"' + url +\n                                        '\" url');\n                    }, 0);\n                    iframe.removeEventListener('error', handler);\n                });\n                iframe.addEventListener('load', function handler() {\n                    var win;\n                    // fix for Safari\n                    // https://stackoverflow.com/q/42632188/387194\n                    try {\n                        win = iframe.contentWindow;\n                    } catch(e) {\n                        win = iframe.contentWindow;\n                    }\n                    iframes.push({window: win, node: iframe});\n                    iframe.removeEventListener('load', handler);\n                });\n                document.body.appendChild(iframe);\n                iframe.src = proxy_url;\n            }\n        },\n        on: function(event, fn) {\n            if (!callbacks[event]) {\n                callbacks[event] = [];\n            }\n            callbacks[event].push(fn);\n        },\n        off: function(event, fn) {\n            if (callbacks[event]) {\n                if (fn) {\n                    for (var i = callbacks[event].length; i--;) {\n                        if (callbacks[event][i] == fn) {\n                            callbacks[event].splice(i, 1);\n                        }\n                    }\n                } else {\n                    callbacks[event] = [];\n                }\n            }\n        },\n        track: function(event, fn) {\n            if (events.includes(event)) {\n                handlers[event].push(fn);\n            }\n        },\n        untrack: function(event, fn) {\n            if (events.includes(event) && handlers[event].length) {\n                if (fn === undefined) {\n                    handlers[event] = [];\n                } else {\n                    handlers[event] = handlers[event].filter(function(handler) {\n                        return handler !== fn;\n                    });\n                }\n            }\n        },\n        post: function(target, data) {\n            sysend.broadcast('__message__', {\n                target: target,\n                data: data,\n                origin: target_id\n            });\n        },\n        list: function() {\n            var id = list_id++;\n            var marker = { target: target_id, id: id };\n            var timer = delay(sysend.timeout);\n            return new Promise(function(resolve) {\n                var ids = [];\n                sysend.on('__window_ack__', function(data) {\n                    if (data.origin.target === target_id && data.origin.id === id) {\n                        ids.push({\n                            id: data.id,\n                            primary: data.primary\n                        });\n                    }\n                });\n                sysend.broadcast('__window__', { id: marker });\n                timer().then(function() {\n                    resolve(ids);\n                });\n            });\n        },\n        isPrimary: function() {\n            return primary;\n        }\n    };\n    // -------------------------------------------------------------------------\n    Object.defineProperty(sysend, 'timeout', {\n        enumerable: true,\n        get: function() {\n            return collecting_timeout;\n        },\n        set: function(value) {\n            if (typeof value === 'number' && !isNaN(value)) {\n                collecting_timeout = value;\n            }\n        }\n    });\n    // -------------------------------------------------------------------------\n    var host = (function() {\n        if (typeof URL !== 'undefined') {\n            return function(url) {\n                url = new URL(url);\n                return url.host;\n            };\n        }\n        var a = document.createElement('a');\n        return function(url) {\n            a.href = url;\n            return a.host;\n        };\n    })();\n    // -------------------------------------------------------------------------\n    init();\n    // -------------------------------------------------------------------------\n    function delay(time) {\n        return function() {\n            return new Promise(function(resolve) {\n                setTimeout(resolve, time);\n            });\n        };\n    }\n    // -------------------------------------------------------------------------\n    function onLoad() {\n        return new Promise(function(resolve) {\n            window.addEventListener('load', resolve, true);\n        }).then(iframeLoaded);\n    }\n    // -------------------------------------------------------------------------\n    function iframeLoaded() {\n        var iframes = Array.from(document.querySelectorAll('iframe'));\n        return Promise.all(iframes.filter(function(iframe) {\n            return iframe.src;\n        }).map(function(iframe) {\n            return new Promise(function(resolve, reject) {\n                iframe.addEventListener('load', () => {\n                    resolve();\n                }, true);\n                iframe.addEventListener('error', reject, true);\n            });\n        })).then(delay(sysend.timeout));\n        // delay is required, something with browser is not intitled properly\n        // the number was pick by experimentation\n    }\n    // -------------------------------------------------------------------------\n    // ref: https://stackoverflow.com/a/8809472/387194\n    // license: Public Domain/MIT\n    function generate_uuid() {\n        var d = new Date().getTime();\n        //Time in microseconds since page-load or 0 if unsupported\n        var d2 = (performance && performance.now && (performance.now() * 1000)) || 0;\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n            var r = Math.random() * 16;\n            if (d > 0) { // Use timestamp until depleted\n                r = (d + r)%16 | 0;\n                d = Math.floor(d/16);\n            } else { // Use microseconds since page-load if supported\n                r = (d2 + r)%16 | 0;\n                d2 = Math.floor(d2/16);\n            }\n            return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);\n        });\n    }\n    // -------------------------------------------------------------------------\n    function trigger(arr) {\n        var args = [].slice.call(arguments, 1);\n        arr.forEach(function(fn) {\n            fn.apply(null, args);\n        });\n    }\n    // -------------------------------------------------------------------------\n    function get(key) {\n        return localStorage.getItem(uniq_prefix + key);\n    }\n    // -------------------------------------------------------------------------\n    function set(key, value) {\n        // storage event is not fired when value is set first time\n        if (id == 0) {\n            localStorage.setItem(uniq_prefix + key, random_value);\n        }\n        localStorage.setItem(uniq_prefix + key, value);\n    }\n    // -------------------------------------------------------------------------\n    function remove(key) {\n        localStorage.removeItem(uniq_prefix + key);\n    }\n    // -------------------------------------------------------------------------\n    function make_process(object, prop) {\n        var labels = {\n            from: 'Unserialize',\n            to: 'Serialize'\n        };\n        var prefix_message = labels[prop] + ' Error: ';\n        return function(data) {\n            var fn = object[prop];\n            try {\n                if (fn) {\n                    return fn(data);\n                }\n                return data;\n            } catch (e) {\n                console.warn(prefix_message + e.message);\n            }\n        };\n    }\n    // -------------------------------------------------------------------------\n    // ref: https://stackoverflow.com/a/326076/387194\n    // -------------------------------------------------------------------------\n    function is_iframe() {\n        try {\n            return window.self !== window.top;\n        } catch (e) {\n            return true;\n        }\n    }\n    // -------------------------------------------------------------------------\n    function send_to_iframes(key, data) {\n        // propagate events to iframes\n        iframes.forEach(function(iframe) {\n            var payload = {\n              name: uniq_prefix,\n              key: key,\n              data: data\n            };\n            iframe.window.postMessage(JSON.stringify(payload), \"*\");\n        });\n    }\n    // -------------------------------------------------------------------------\n    function to_json(input) {\n        // save random_value in storage to fix issue in IE that storage event\n        // is fired on same page where setItem was called\n        var obj = [id++, random_value];\n        // undefined in array get stringified as null\n        if (typeof input != 'undefined') {\n            obj.push(input);\n        }\n        var data = serialize(obj);\n        if (data === obj) {\n            return JSON.stringify(obj);\n        }\n        return data;\n    }\n    // -------------------------------------------------------------------------\n    function from_json(json) {\n        var result = unserialize(json);\n        if (result === json) {\n            return JSON.parse(json);\n        }\n        return result;\n    }\n    // -------------------------------------------------------------------------\n    function invoke(key, data) {\n        callbacks[key].forEach(function(fn) {\n            fn(data, key);\n        });\n    }\n    // -------------------------------------------------------------------------\n    function is_private_mode() {\n        try {\n            localStorage.setItem(uniq_prefix, 1);\n            localStorage.removeItem(uniq_prefix);\n            return false;\n        } catch (e) {\n            return true;\n        }\n    }\n    // -------------------------------------------------------------------------\n    function init_visiblity() {\n        // ref: https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API\n        var hidden, visibilityChange;\n        if (typeof document.hidden !== \"undefined\") { // Opera 12.10 and Firefox 18 and later support\n            hidden = \"hidden\";\n            visibilityChange = \"visibilitychange\";\n        } else if (typeof document.msHidden !== \"undefined\") {\n            hidden = \"msHidden\";\n            visibilityChange = \"msvisibilitychange\";\n        } else if (typeof document.webkitHidden !== \"undefined\") {\n            hidden = \"webkitHidden\";\n            visibilityChange = \"webkitvisibilitychange\";\n        }\n        if (typeof document.addEventListener === 'function' && hidden) {\n            document.addEventListener(visibilityChange, function() {\n                trigger(handlers.visbility, !document[hidden]);\n            }, false);\n        }\n    }\n    // -------------------------------------------------------------------------\n    function become_primary() {\n        primary = true;\n        trigger(handlers.primary);\n        sysend.emit('__primary__');\n    }\n    // -------------------------------------------------------------------------\n    function init() {\n        if (typeof window.BroadcastChannel === 'function') {\n            channel = new window.BroadcastChannel(uniq_prefix);\n            channel.addEventListener('message', function(event) {\n                if (event.target.name === uniq_prefix) {\n                    var key = event.data && event.data.name;\n                    if (callbacks[key]) {\n                        invoke(key, unserialize(event.data.data));\n                    }\n                }\n            });\n        } else if (is_private_mode()) {\n            console.warn('Your browser don\\'t support localStorgage. ' +\n                         'In Safari this is most of the time because ' +\n                         'of \"Private Browsing Mode\"');\n        } else {\n            // we need to clean up localStorage if broadcast called on unload\n            // because setTimeout will never fire, even setTimeout 0\n            var re = new RegExp('^' + uniq_prefix);\n            for(var key in localStorage) {\n                if (key.match(re)) {\n                    localStorage.removeItem(key);\n                }\n            }\n            window.addEventListener('storage', function(e) {\n                // prevent event to be executed on remove in IE\n                if (e.key.match(re) && index++ % 2 === 0) {\n                    var key = e.key.replace(re, '');\n                    if (callbacks[key]) {\n                        var value = e.newValue || get(key);\n                        if (value && value != random_value) {\n                            var obj = from_json(value);\n                            // don't call on remove\n                            if (obj && obj[1] != random_value) {\n                                invoke(key, obj[2]);\n                            }\n                        }\n                    }\n                }\n            }, false);\n        }\n\n        if (is_iframe()) {\n            window.addEventListener('message', function(e) {\n                if (typeof e.data === 'string' && e.data.match(prefix_re)) {\n                    try {\n                        var payload = JSON.parse(e.data);\n                        if (payload && payload.name === uniq_prefix) {\n                            var data = unserialize(payload.data);\n                            sysend.broadcast(payload.key, data);\n                        }\n                    } catch(e) {\n                        // ignore wrong JSON, the message don't came from Sysend\n                        // even that the string have unix_prefix, this is just in case\n                    }\n                }\n            });\n        } else {\n            init_visiblity();\n\n            sysend.track('visbility', function(visible) {\n                console.log({visible, has_primary});\n                if (visible && !has_primary) {\n                    become_primary();\n                }\n            });\n\n            sysend.on('__primary__', function() {\n                has_primary = true;\n            });\n\n            sysend.on('__open__', function(data) {\n                var id = data.id;\n                target_count++;\n                if (primary) {\n                    sysend.broadcast('__ack__');\n                }\n                trigger(handlers.open, {\n                    count: target_count,\n                    primary: data.primary,\n                    id: data.id\n                });\n                if (id === target_id) {\n                    trigger(handlers.ready);\n                }\n            });\n\n            sysend.on('__ack__', function() {\n                if (!primary) {\n                    trigger(handlers.secondary);\n                }\n            });\n\n            sysend.on('__close__', function(data) {\n                --target_count;\n                var last = target_count === 1;\n                if (data.wasPrimary && !primary) {\n                    has_primary = false;\n                }\n                var payload = {\n                    id: data.id,\n                    count: target_count,\n                    primary: data.wasPrimary,\n                    self: data.id === target_id\n                };\n                // we need to trigger primary when tab is in different window\n                // and is not be hidden\n                if (!document.hidden) {\n                    become_primary();\n                }\n                trigger(handlers.close, payload);\n            });\n\n            sysend.on('__window__', function(data) {\n                sysend.broadcast('__window_ack__', {\n                    id: target_id,\n                    origin: data.id,\n                    primary: primary\n                });\n            });\n\n            sysend.on('__message__', function(data) {\n                if (data.target === target_id) {\n                    trigger(handlers.message, data);\n                }\n            });\n\n            addEventListener('beforeunload', function() {\n                sysend.emit('__close__', { id: target_id, wasPrimary: primary });\n            }, { capture: true });\n\n            onLoad().then(function() {\n                sysend.list().then(function(list) {\n                    target_count = list.length;\n                    primary = list.length === 0;\n                    var found = list.find(function(item) {\n                        return item.primary;\n                    });\n                    if (found || primary) {\n                        has_primary = true;\n                    }\n                    sysend.emit('__open__', {\n                        id: target_id,\n                        primary: primary\n                    });\n                    if (primary) {\n                        trigger(handlers.primary);\n                    }\n                });\n            });\n        }\n    }\n    return sysend;\n});\n"], "fixing_code": ["<p align=\"center\">\n  <img src=\"https://github.com/jcubic/sysend.js/blob/master/assets/logo.svg?raw=true\" alt=\"Sysend.js logo\"/>\n</p>\n\n[![npm](https://img.shields.io/badge/npm-1.10.0-blue.svg)](https://www.npmjs.com/package/sysend)\n![bower](https://img.shields.io/badge/bower-1.10.0-yellow.svg)\n![downloads](https://img.shields.io/npm/dt/sysend.svg)\n[![jsdelivr](https://img.shields.io/jsdelivr/npm/hm/sysend)](https://www.jsdelivr.com/package/npm/sysend)\n\n# [Web application synchronization between different tabs](https://github.com/jcubic/sysend.js/)\n\nsysend.js is a small library that allows to send messages between pages that are open in the same\nbrowser. It also supports Cross-Domain communication (Cross-Origin). The library doesn't have any\ndependencies and uses the HTML5 LocalStorage API or BroadcastChannel API.  If your browser don't\nsupport BroadcastChannel (see [Can I Use](https://caniuse.com/#feat=broadcastchannel)) then you can\nsend any object that can be serialized to JSON. With BroadcastChannel you can send any object (it\nwill not be serialized to string but the values are limited to the ones that can be copied by the\n[structured cloning algorithm](https://html.spec.whatwg.org/multipage/structured-data.html#structured-clone)).\nYou can also send empty notifications.\n\nTested on:\n\nGNU/Linux: in Chromium 34, FireFox 29, Opera 12.16 (64bit)<br/>\nWindows 10 64bit: in IE11 and Edge 38, Chrome 56, Firefox 51<br/>\nMacOS X El Captain: Safari 9, Chrome 56, Firefox 51\n\n## Note about Safari 7+ and Cross-Domain communication\n\nAll cross-domain communication is disabled by default with Safari 7+.  Because of a feature that\nblock 3rd party tracking for iframe, and any iframe used for cross-domain communication runs in\nsandboxed environment.  That's why this library like any other solution for cross-domain\ncomunication, don't work on Safari.\n\n## Installation\n\nInclude `sysend.js` file in your html, you can grab the file from npm:\n\n```\nnpm install sysend\n```\n\nor bower\n\n\n```\nbower install sysend\n```\n\nyou can also get it from unpkg.com CDN:\n\n```\nhttps://unpkg.com/sysend\n```\n\nor jsDelivr:\n\n```\nhttps://cdn.jsdelivr.net/npm/sysend\n```\n\njsDelivr will minify the file. From my testing it's faster then unpkg.com.\n\n## Usage\n\n```javascript\nwindow.onload = function() {\n    sysend.on('foo', function(data) {\n        console.log(data.message);\n    });\n    var input = document.getElementsByTagName('input')[0];\n    document.getElementsByTagName('button')[0].onclick = function() {\n        sysend.broadcast('foo', { message: input.value });\n    };\n};\n```\n\nIf you want to add support for Cross-Domain communication, you need to call proxy method with url on target domain\nthat have [proxy.html file](https://github.com/jcubic/sysend.js/blob/master/proxy.html).\n\n```javascript\nsysend.proxy('https://jcubic.pl');\nsysend.proxy('https://terminal.jcubic.pl');\n```\n\non Firefox you need to add **CORS** for the proxy.html that will be loaded into iframe (see [Cross-Domain LocalStorage](https://jcubic.wordpress.com/2014/06/20/cross-domain-localstorage/))\n\nif you want to send custom data you can use serializer (new in 1.4.0).\nExample serializer can be [json-dry](https://github.com/11ways/json-dry).\n\n```javascript\nsysend.serializer(function(data) {\n    return Dry.stringify(data);\n}, function(string) {\n    return Dry.parse(string);\n});\n````\n\n## Demo\n\nOpen this [demo page](http://jcubic.pl/sysend.php) in two tabs/windows (there is also link to other domain).\n\nHere is another example that shows [ReactJS shopping cart synchronization](https://codepen.io/jcubic/pen/QWgmBmE).\n\nAnd here is [multiple window tracking demo](https://jcubic.pl/windows.html). Open the link in multiple windows (not tabs). First window will track position and size for all windows.\n\n![Screen capture of Operating System Windows dragging and moving around animation](https://github.com/jcubic/sysend.js/blob/master/assets/windows-demo.gif?raw=true)\n\n## API\n\nsysend object:\n\n| function | description | arguments | Version |\n|---|---|---|---|\n| `on(name, callback)` | add event handler for specified name | name - `string` - The name of the event<br>callback - function `(object, name) => void` | 1.0.0 |\n| `off(name [, callback])` | remove event handler for given name, if callback is not specified it will remove all callbacks for given name | name - `string` - The name of the event<br>callback - optional function `(object, name) => void` | 1.0.0 |\n| `broadcast(name [, object])` | send any object and fire all events with specified name (in different pages that register callback using on). You can also just send notification without an object | name - string - The name of the event<br>object - optional any data | 1.0.0 |\n| `proxy(url)` | create iframe proxy for different domain, the target domain/URL should have [proxy.html](https://github.com/jcubic/sysend.js/blob/master/proxy.html)<br> file. If url domain is the same as page domain, it's ignored. So you can put both proxy calls on both | url - string | 1.3.0 |\n| `serializer(to_string, from_string)` | add serializer and deserializer functions | both arguments are functions (data: any) => string | 1.4.0 |\n| `emit(name, [, object])` | same as `broadcast()` but also invoke the even on same page | name - string - The name of the event<br>object - optional any data | 1.5.0 |\n| `post(<window_id>, [, object])` | send any data to other window | window_id - string of the target window<br>object - any data | 1.6.0 |\n| `list()` | returns a Promise of objects `{id:<UUID>, primary}` for other windows, you can use those to send a message with `post()` | NA | 1.6.0 |\n| `track(event, callback)` | track inter window communication events  | event - any of the strings: `\"open\"`, `\"close\"`, `\"primary\"`, <br>`\"secondary\"`, `\"message\"`<br>callback - different function depend on the event:<br>* `\"message\"` - `{data, origin}` - where data is anything the `post()` sends, and origin is `id` of the sender.<br>* `\"open\"` - `{count, primary, id}` when new window/tab is opened<br>* `\"close\"` - `{count, primary, id, self}` when window/tab is closed<br>* `\"primary\"` and `\"secondary\"` function has no arguments and is called when window/tab become secondary or primary.<br>* `\"ready\"` - event when tracking is ready. | 1.6.0 except `ready` - 1.10.0 |\n| `untrack(event [,callback])` | remove sigle event listener all all listeners for a given event | event - any of the strings `'open'`, `'close'`, `'primary'`, `'secondary'`, or `'message'`. | 1.6.0 |\n| `isPrimary()` | function returns true if window is primary (first open or last that remain) | NA  | 1.6.0 |\n| `channel()` | function restrict cross domain communication to only allowed domains. You need to call this function on proxy iframe to limit number of domains (origins) that can listen and send events.  | any number of origins (e.g. 'http://localhost:8080' or 'https://jcubic.github.io') you can also use valid URL. | 1.10.0 |\n\n\nTo see details of using the API, see [demo.html source code](https://github.com/jcubic/sysend.js/blob/master/demo.html) or [TypeScript definition file](https://github.com/jcubic/sysend.js/blob/master/sysend.d.ts).\n\n## License\n\nCopyright (C) 2014-2022 [Jakub T. Jankiewicz](https://jcubic.pl/me)<br/>\nReleased under the [MIT license](https://opensource.org/licenses/MIT)\n\nThis is free software; you are free to change and redistribute it.<br/>\nThere is NO WARRANTY, to the extent permitted by law.\n", "{\n  \"name\": \"sysend\",\n  \"version\": \"1.10.0\",\n  \"description\": \"Web application synchronization between different tabs\",\n  \"main\": \"sysend.js\",\n  \"typings\": \"sysend.d.ts\",\n  \"scripts\": {\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/jcubic/sysend.js.git\"\n  },\n  \"keywords\": [\n    \"tabs\",\n    \"windows\",\n    \"messages\",\n    \"cross-domain\",\n    \"cors\",\n    \"domain\",\n    \"communication\",\n    \"events\",\n    \"callback\",\n    \"notifications\",\n    \"browser\"\n  ],\n  \"author\": \"Jakub T. Jankiewicz <jcubic@onet.pl> (https://jcubic.pl/me/)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/jcubic/sysend.js/issues\"\n  },\n  \"homepage\": \"https://github.com/jcubic/sysend.js#readme\"\n}\n", "<!DOCTYPE HTML>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"robots\" content=\"noindex,nofollow\"/>\n    <script src=\"./sysend.js\"></script>\n    <!-- EDIT THIS FILE AND CALL sysend.channel() WITH ALLOWED DOMAINS -->\n    <script>\n       sysend.channel();\n    </script>\n</head>\n<body>\n</body>\n</html>\n", "/**@license\n *  sysend.js - send messages between browser windows/tabs version 1.10.0\n *\n *  Copyright (C) 2014-2022 Jakub T. Jankiewicz <https://jcubic.pl/me>\n *  Released under the MIT license\n *\n */\ntype callback = (message: any, event: string) => void;\n\ninterface Sysend {\n    id: string;\n    broadcast(event: string, data?: any): void;\n    emit(event: string, data?: any): void;\n    on(event: string, callback: callback): void;\n    off(event: string, callback?: callback): void;\n    proxy(url: string): void;\n    serializer(to: (data: any) => string, from: (data: string) => any): void;\n    track(event: 'open', callback: (data: {id: string, count: number, primary: boolean}) => void): void;\n    track(event: 'close', callback: (data: {id: string, count: number, primary: boolean, self: boolean}) => void): void;\n    track(event: 'primary', callback: () => void): void;\n    track(event: 'message', callback: (payload: {data: any, origin: string}) => void): void;\n    track(event: 'secondary', callback: () => void): void;\n    untrack(event: 'open' | 'close' | 'primary' | 'secondary' | 'message', fn?: (input?: any) => void): void;\n    list(): Promise<Array<{ id: string, primary: boolean }>>;\n    post(target: string, data?: any): void;\n    channel(...domains: string[]): void;\n    isPrimary(): boolean;\n}\n\ndeclare const sysend: Sysend;\n\nexport default sysend;\n", "/**@license\n *  sysend.js - send messages between browser windows/tabs version 1.10.0\n *\n *  Copyright (C) 2014-2022 Jakub T. Jankiewicz <https://jcubic.pl/me>\n *  Released under the MIT license\n *\n *  The idea for localStorage implementation came from this StackOverflow question:\n *  http://stackoverflow.com/q/24182409/387194\n *\n */\n/* global define, module, exports, localStorage, setTimeout */\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define(['sysend'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.sysend = factory();\n    }\n})(typeof window !== \"undefined\" ? window : this, function() {\n    var collecting_timeout = 400;\n    // we use prefix so `foo' event don't collide with `foo' locaStorage value\n    var uniq_prefix = '___sysend___';\n    var prefix_re = new RegExp(uniq_prefix);\n    var random_value = Math.random();\n    var serializer = {};\n    // object with user events as keys and values arrays of callback functions\n    var callbacks = {};\n    var has_primary;\n    var iframes = [];\n    var index = 0;\n    var channel;\n    var primary = true;\n    // we use id because storage event is not executed if message was not\n    // changed, and we want it if user send same object twice (before it will\n    // be removed)\n    var id = 0;\n    // identifier for making each call to list unique\n    var list_id = 0;\n\n    // id of the window/tab\n    var target_id = generate_uuid();\n    var target_count = 1;\n    var domains;\n\n    var handlers = {\n        primary: [],\n        close: [],\n        open: [],\n        secondary: [],\n        message: [],\n        visbility: [],\n        ready: []\n    };\n    var events = Object.keys(handlers);\n    // -------------------------------------------------------------------------\n    var serialize = make_process(serializer, 'to');\n    var unserialize = make_process(serializer, 'from');\n    // -------------------------------------------------------------------------\n    var sysend = {\n        id: target_id,\n        broadcast: function(event, data) {\n            if (channel) {\n                channel.postMessage({name: event, data: serialize(data)});\n            } else {\n                set(event, to_json(data));\n                // clean up localstorage\n                setTimeout(function() {\n                    remove(event);\n                }, 0);\n            }\n            send_to_iframes(event, data);\n        },\n        emit: function(event, data) {\n            sysend.broadcast(event, data);\n            invoke(event, data);\n        },\n        serializer: function(to, from) {\n            if (typeof to !== 'function' || typeof from !== 'function') {\n                throw new Error('sysend::serializer: Invalid argument, expecting' +\n                                ' function');\n            }\n            serializer.to = to;\n            serializer.from = from;\n        },\n        proxy: function(url) {\n            if (typeof url === 'string' && host(url) !== window.location.host) {\n                domains = domains || [];\n                domains.push(origin(url));\n                var iframe = document.createElement('iframe');\n                iframe.style.width = iframe.style.height = 0;\n                iframe.style.border = 'none';\n                var proxy_url = url;\n                if (!url.match(/\\.html$/)) {\n                    proxy_url = url.replace(/\\/$/, '') + '/proxy.html';\n                }\n                iframe.addEventListener('error', function handler() {\n                    setTimeout(function() {\n                        throw new Error('html proxy file not found on \"' + url +\n                                        '\" url');\n                    }, 0);\n                    iframe.removeEventListener('error', handler);\n                });\n                iframe.addEventListener('load', function handler() {\n                    var win;\n                    // fix for Safari\n                    // https://stackoverflow.com/q/42632188/387194\n                    try {\n                        win = iframe.contentWindow;\n                    } catch(e) {\n                        win = iframe.contentWindow;\n                    }\n                    iframes.push({window: win, node: iframe});\n                    iframe.removeEventListener('load', handler);\n                });\n                document.body.appendChild(iframe);\n                iframe.src = proxy_url;\n            }\n        },\n        on: function(event, fn) {\n            if (!callbacks[event]) {\n                callbacks[event] = [];\n            }\n            callbacks[event].push(fn);\n        },\n        off: function(event, fn) {\n            if (callbacks[event]) {\n                if (fn) {\n                    for (var i = callbacks[event].length; i--;) {\n                        if (callbacks[event][i] == fn) {\n                            callbacks[event].splice(i, 1);\n                        }\n                    }\n                } else {\n                    callbacks[event] = [];\n                }\n            }\n        },\n        track: function(event, fn) {\n            if (events.includes(event)) {\n                handlers[event].push(fn);\n            }\n        },\n        untrack: function(event, fn) {\n            if (events.includes(event) && handlers[event].length) {\n                if (fn === undefined) {\n                    handlers[event] = [];\n                } else {\n                    handlers[event] = handlers[event].filter(function(handler) {\n                        return handler !== fn;\n                    });\n                }\n            }\n        },\n        post: function(target, data) {\n            sysend.broadcast('__message__', {\n                target: target,\n                data: data,\n                origin: target_id\n            });\n        },\n        list: function() {\n            var id = list_id++;\n            var marker = { target: target_id, id: id };\n            var timer = delay(sysend.timeout);\n            return new Promise(function(resolve) {\n                var ids = [];\n                sysend.on('__window_ack__', function(data) {\n                    if (data.origin.target === target_id && data.origin.id === id) {\n                        ids.push({\n                            id: data.id,\n                            primary: data.primary\n                        });\n                    }\n                });\n                sysend.broadcast('__window__', { id: marker });\n                timer().then(function() {\n                    resolve(ids);\n                });\n            });\n        },\n        channel: function() {\n            domains = [].slice.apply(arguments).map(origin);\n        },\n        isPrimary: function() {\n            return primary;\n        }\n    };\n    // -------------------------------------------------------------------------\n    Object.defineProperty(sysend, 'timeout', {\n        enumerable: true,\n        get: function() {\n            return collecting_timeout;\n        },\n        set: function(value) {\n            if (typeof value === 'number' && !isNaN(value)) {\n                collecting_timeout = value;\n            }\n        }\n    });\n    // -------------------------------------------------------------------------\n    var host = (function() {\n        if (typeof URL !== 'undefined') {\n            return function(url) {\n                url = new URL(url);\n                return url.host;\n            };\n        }\n        var a = document.createElement('a');\n        return function(url) {\n            a.href = url;\n            return a.host;\n        };\n    })();\n    // -------------------------------------------------------------------------\n    function delay(time) {\n        return function() {\n            return new Promise(function(resolve) {\n                setTimeout(resolve, time);\n            });\n        };\n    }\n    // -------------------------------------------------------------------------\n    var origin = (function() {\n        var a = document.createElement('a');\n        return function origin(url) {\n            a.href = url;\n            return a.origin;\n        };\n    })();\n    // -------------------------------------------------------------------------\n    // :: show only single message of this kind\n    // -------------------------------------------------------------------------\n    var warn_messages = [];\n    function warn(message) {\n        if (!warn_messages.includes(message)) {\n            warn_messages.push(message);\n            if (console && console.warn) {\n                console.warn(message);\n            } else {\n                setTimeout(function() {\n                    throw new Error(message);\n                }, 0);\n            }\n        }\n    }\n    // -------------------------------------------------------------------------\n    function on_load() {\n        return new Promise(function(resolve) {\n            window.addEventListener('load', resolve, true);\n        }).then(iframe_loaded);\n    }\n    // -------------------------------------------------------------------------\n    function iframe_loaded() {\n        var iframes = Array.from(document.querySelectorAll('iframe'));\n        return Promise.all(iframes.filter(function(iframe) {\n            return iframe.src;\n        }).map(function(iframe) {\n            return new Promise(function(resolve, reject) {\n                iframe.addEventListener('load', () => {\n                    resolve();\n                }, true);\n                iframe.addEventListener('error', reject, true);\n            });\n        })).then(delay(sysend.timeout));\n        // delay is required, something with browser is not intitled properly\n        // the number was pick by experimentation\n    }\n    // -------------------------------------------------------------------------\n    // :: valid sysend message\n    // -------------------------------------------------------------------------\n    function is_sysend_post_message(e) {\n        return typeof e.data === 'string' && e.data.match(prefix_re);\n    }\n    // -------------------------------------------------------------------------\n    function is_valid_origin(origin) {\n        if (!domains) {\n            warn('Call sysend.channel() on iframe to restrict domains that can '+\n                 'use sysend channel');\n            return true;\n        }\n        var valid = domains.includes(origin);\n        if (!valid) {\n            warn(origin + ' domain is not on the list of allowed '+\n                 'domains use sysend.channel() on iframe to allow'+\n                 ' access to this domain');\n        }\n        return valid;\n    }\n    // -------------------------------------------------------------------------\n    // :: ref: https://stackoverflow.com/a/8809472/387194\n    // :: license: Public Domain/MIT\n    // -------------------------------------------------------------------------\n    function generate_uuid() {\n        var d = new Date().getTime();\n        //Time in microseconds since page-load or 0 if unsupported\n        var d2 = (performance && performance.now && (performance.now() * 1000)) || 0;\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n            var r = Math.random() * 16;\n            if (d > 0) { // Use timestamp until depleted\n                r = (d + r)%16 | 0;\n                d = Math.floor(d/16);\n            } else { // Use microseconds since page-load if supported\n                r = (d2 + r)%16 | 0;\n                d2 = Math.floor(d2/16);\n            }\n            return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);\n        });\n    }\n    // -------------------------------------------------------------------------\n    function trigger(arr) {\n        var args = [].slice.call(arguments, 1);\n        arr.forEach(function(fn) {\n            fn.apply(null, args);\n        });\n    }\n    // -------------------------------------------------------------------------\n    function get(key) {\n        return localStorage.getItem(uniq_prefix + key);\n    }\n    // -------------------------------------------------------------------------\n    function set(key, value) {\n        // storage event is not fired when value is set first time\n        if (id == 0) {\n            localStorage.setItem(uniq_prefix + key, random_value);\n        }\n        localStorage.setItem(uniq_prefix + key, value);\n    }\n    // -------------------------------------------------------------------------\n    function remove(key) {\n        localStorage.removeItem(uniq_prefix + key);\n    }\n    // -------------------------------------------------------------------------\n    function make_process(object, prop) {\n        var labels = {\n            from: 'Unserialize',\n            to: 'Serialize'\n        };\n        var prefix_message = labels[prop] + ' Error: ';\n        return function(data) {\n            var fn = object[prop];\n            try {\n                if (fn) {\n                    return fn(data);\n                }\n                return data;\n            } catch (e) {\n                warn(prefix_message + e.message);\n            }\n        };\n    }\n    // -------------------------------------------------------------------------\n    // ref: https://stackoverflow.com/a/326076/387194\n    // -------------------------------------------------------------------------\n    var is_iframe = (function is_iframe() {\n        try {\n            return window.self !== window.top;\n        } catch (e) {\n            return true;\n        }\n    })();\n    // -------------------------------------------------------------------------\n    function send_to_iframes(key, data) {\n        // propagate events to iframes\n        iframes.forEach(function(iframe) {\n            var payload = {\n              name: uniq_prefix,\n              key: key,\n              data: data\n            };\n            if (is_valid_origin(origin(iframe.node.src))) {\n                iframe.window.postMessage(JSON.stringify(payload), \"*\");\n            }\n        });\n    }\n    // -------------------------------------------------------------------------\n    function to_json(input) {\n        // save random_value in storage to fix issue in IE that storage event\n        // is fired on same page where setItem was called\n        var obj = [id++, random_value];\n        // undefined in array get stringified as null\n        if (typeof input != 'undefined') {\n            obj.push(input);\n        }\n        var data = serialize(obj);\n        if (data === obj) {\n            return JSON.stringify(obj);\n        }\n        return data;\n    }\n    // -------------------------------------------------------------------------\n    function from_json(json) {\n        var result = unserialize(json);\n        if (result === json) {\n            return JSON.parse(json);\n        }\n        return result;\n    }\n    // -------------------------------------------------------------------------\n    function invoke(key, data) {\n        callbacks[key].forEach(function(fn) {\n            fn(data, key);\n        });\n    }\n    // -------------------------------------------------------------------------\n    function is_private_mode() {\n        try {\n            localStorage.setItem(uniq_prefix, 1);\n            localStorage.removeItem(uniq_prefix);\n            return false;\n        } catch (e) {\n            return true;\n        }\n    }\n    // -------------------------------------------------------------------------\n    function init_visiblity() {\n        // ref: https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API\n        var hidden, visibilityChange;\n        if (typeof document.hidden !== \"undefined\") { // Opera 12.10 and Firefox 18 and later support\n            hidden = \"hidden\";\n            visibilityChange = \"visibilitychange\";\n        } else if (typeof document.msHidden !== \"undefined\") {\n            hidden = \"msHidden\";\n            visibilityChange = \"msvisibilitychange\";\n        } else if (typeof document.webkitHidden !== \"undefined\") {\n            hidden = \"webkitHidden\";\n            visibilityChange = \"webkitvisibilitychange\";\n        }\n        if (typeof document.addEventListener === 'function' && hidden) {\n            document.addEventListener(visibilityChange, function() {\n                trigger(handlers.visbility, !document[hidden]);\n            }, false);\n        }\n    }\n    // -------------------------------------------------------------------------\n    function become_primary() {\n        primary = true;\n        trigger(handlers.primary);\n        sysend.emit('__primary__');\n    }\n    // -------------------------------------------------------------------------\n    init();\n    // -------------------------------------------------------------------------\n    function init() {\n        if (typeof window.BroadcastChannel === 'function') {\n            channel = new window.BroadcastChannel(uniq_prefix);\n            channel.addEventListener('message', function(event) {\n                if (event.target.name === uniq_prefix) {\n                    if (is_iframe) {\n                        var payload = {\n                          name: uniq_prefix,\n                          data: event.data,\n                          iframe_id: target_id\n                        };\n                        if (is_valid_origin(origin(document.referrer))) {\n                            window.parent.postMessage(JSON.stringify(payload), \"*\");\n                        }\n                    } else {\n                        var key = event.data && event.data.name;\n                        if (callbacks[key]) {\n                            invoke(key, unserialize(event.data.data));\n                        }\n                    }\n                }\n            });\n        } else if (is_private_mode()) {\n            warn('Your browser don\\'t support localStorgage. ' +\n                 'In Safari this is most of the time because ' +\n                 'of \"Private Browsing Mode\"');\n        } else {\n            // we need to clean up localStorage if broadcast called on unload\n            // because setTimeout will never fire, even setTimeout 0\n            var re = new RegExp('^' + uniq_prefix);\n            for(var key in localStorage) {\n                if (key.match(re)) {\n                    localStorage.removeItem(key);\n                }\n            }\n            window.addEventListener('storage', function(e) {\n                // prevent event to be executed on remove in IE\n                if (e.key.match(re) && index++ % 2 === 0) {\n                    var key = e.key.replace(re, '');\n                    if (callbacks[key]) {\n                        var value = e.newValue || get(key);\n                        if (value && value != random_value) {\n                            var obj = from_json(value);\n                            // don't call on remove\n                            if (obj && obj[1] != random_value) {\n                                invoke(key, obj[2]);\n                            }\n                        }\n                    }\n                }\n            }, false);\n        }\n\n        if (is_iframe) {\n            window.addEventListener('message', function(e) {\n                if (is_sysend_post_message(e) && is_valid_origin(e.origin)) {\n                    try {\n                        var payload = JSON.parse(e.data);\n                        if (payload && payload.name === uniq_prefix) {\n                            var data = unserialize(payload.data);\n                            sysend.broadcast(payload.key, data);\n                        }\n                    } catch(e) {\n                        // ignore wrong JSON, the message don't came from Sysend\n                        // even that the string have unix_prefix, this is just in case\n                    }\n                }\n            });\n        } else {\n            init_visiblity();\n\n            sysend.track('visbility', function(visible) {\n                if (visible && !has_primary) {\n                    become_primary();\n                }\n            });\n\n            sysend.on('__primary__', function() {\n                has_primary = true;\n            });\n\n            sysend.on('__open__', function(data) {\n                var id = data.id;\n                target_count++;\n                if (primary) {\n                    sysend.broadcast('__ack__');\n                }\n                trigger(handlers.open, {\n                    count: target_count,\n                    primary: data.primary,\n                    id: data.id\n                });\n                if (id === target_id) {\n                    trigger(handlers.ready);\n                }\n            });\n\n            sysend.on('__ack__', function() {\n                if (!primary) {\n                    trigger(handlers.secondary);\n                }\n            });\n\n            sysend.on('__close__', function(data) {\n                --target_count;\n                var last = target_count === 1;\n                if (data.wasPrimary && !primary) {\n                    has_primary = false;\n                }\n                var payload = {\n                    id: data.id,\n                    count: target_count,\n                    primary: data.wasPrimary,\n                    self: data.id === target_id\n                };\n                // we need to trigger primary when tab is in different window\n                // and is not be hidden\n                if (!document.hidden) {\n                    become_primary();\n                }\n                trigger(handlers.close, payload);\n            });\n\n            sysend.on('__window__', function(data) {\n                sysend.broadcast('__window_ack__', {\n                    id: target_id,\n                    origin: data.id,\n                    primary: primary\n                });\n            });\n\n            sysend.on('__message__', function(data) {\n                if (data.target === target_id) {\n                    trigger(handlers.message, data);\n                }\n            });\n\n            addEventListener('beforeunload', function() {\n                sysend.emit('__close__', { id: target_id, wasPrimary: primary });\n            }, { capture: true });\n\n            on_load().then(function() {\n                sysend.list().then(function(list) {\n                    target_count = list.length;\n                    primary = list.length === 0;\n                    var found = list.find(function(item) {\n                        return item.primary;\n                    });\n                    if (found || primary) {\n                        has_primary = true;\n                    }\n                    sysend.emit('__open__', {\n                        id: target_id,\n                        primary: primary\n                    });\n                    if (primary) {\n                        trigger(handlers.primary);\n                    }\n                });\n            });\n        }\n    }\n    return sysend;\n});\n"], "filenames": ["README.md", "package.json", "proxy.html", "sysend.d.ts", "sysend.js"], "buggy_code_start_loc": [5, 3, 6, 2, 2], "buggy_code_end_loc": [142, 4, 7, 25, 522], "fixing_code_start_loc": [5, 3, 6, 2, 2], "fixing_code_end_loc": [127, 4, 11, 27, 586], "type": "CWE-200", "message": "sysend.js is a library that allows a user to send messages between pages that are open in the same browser. Users that use cross-origin communication may have their communications intercepted. Impact is limited by the communication occurring in the same browser. This issue has been patched in sysend.js version 1.10.0. The only currently known workaround is to avoid sending communications that a user does not want to have intercepted via sysend messages.", "other": {"cve": {"id": "CVE-2022-24762", "sourceIdentifier": "security-advisories@github.com", "published": "2022-03-14T23:15:08.427", "lastModified": "2022-03-21T18:48:38.580", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "sysend.js is a library that allows a user to send messages between pages that are open in the same browser. Users that use cross-origin communication may have their communications intercepted. Impact is limited by the communication occurring in the same browser. This issue has been patched in sysend.js version 1.10.0. The only currently known workaround is to avoid sending communications that a user does not want to have intercepted via sysend messages."}, {"lang": "es", "value": "sysend.js es una biblioteca que permite a un usuario enviar mensajes entre p\u00e1ginas que est\u00e1n abiertas en el mismo navegador. Los usuarios que usan la comunicaci\u00f3n entre or\u00edgenes pueden ver interceptadas sus comunicaciones. El impacto est\u00e1 limitado por la comunicaci\u00f3n que es producida en el mismo navegador. Este problema ha sido parcheado en la versi\u00f3n 1.10.0 de sysend.js. La \u00fanica medida de mitigaci\u00f3n conocida actualmente es evitar el env\u00edo de comunicaciones que el usuario no quiere que sean interceptadas por medio de mensajes sysend"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sysend.js_project:sysend.js:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.10.0", "matchCriteriaId": "A43EE609-11E5-4F09-852C-915CA49B4597"}]}]}], "references": [{"url": "https://github.com/jcubic/sysend.js/commit/a24f4b776fb18191ae0f7e3d90c2c7bec459431a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jcubic/sysend.js/issues/33", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/jcubic/sysend.js/releases/tag/1.10.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/jcubic/sysend.js/security/advisories/GHSA-4vvg-x86p-mvqc", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jcubic/sysend.js/commit/a24f4b776fb18191ae0f7e3d90c2c7bec459431a"}}