{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0+\n/*\n * linux/fs/jbd2/transaction.c\n *\n * Written by Stephen C. Tweedie <sct@redhat.com>, 1998\n *\n * Copyright 1998 Red Hat corp --- All Rights Reserved\n *\n * Generic filesystem transaction handling code; part of the ext2fs\n * journaling system.\n *\n * This file manages transactions (compound commits managed by the\n * journaling code) and handles (individual atomic operations by the\n * filesystem).\n */\n\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/jbd2.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/hrtimer.h>\n#include <linux/backing-dev.h>\n#include <linux/bug.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n\n#include <trace/events/jbd2.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nstatic struct kmem_cache *transaction_cache;\nint __init jbd2_journal_init_transaction_cache(void)\n{\n\tJ_ASSERT(!transaction_cache);\n\ttransaction_cache = kmem_cache_create(\"jbd2_transaction_s\",\n\t\t\t\t\tsizeof(transaction_t),\n\t\t\t\t\t0,\n\t\t\t\t\tSLAB_HWCACHE_ALIGN|SLAB_TEMPORARY,\n\t\t\t\t\tNULL);\n\tif (!transaction_cache) {\n\t\tpr_emerg(\"JBD2: failed to create transaction cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nvoid jbd2_journal_destroy_transaction_cache(void)\n{\n\tkmem_cache_destroy(transaction_cache);\n\ttransaction_cache = NULL;\n}\n\nvoid jbd2_journal_free_transaction(transaction_t *transaction)\n{\n\tif (unlikely(ZERO_OR_NULL_PTR(transaction)))\n\t\treturn;\n\tkmem_cache_free(transaction_cache, transaction);\n}\n\n/*\n * Base amount of descriptor blocks we reserve for each transaction.\n */\nstatic int jbd2_descriptor_blocks_per_trans(journal_t *journal)\n{\n\tint tag_space = journal->j_blocksize - sizeof(journal_header_t);\n\tint tags_per_block;\n\n\t/* Subtract UUID */\n\ttag_space -= 16;\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\ttag_space -= sizeof(struct jbd2_journal_block_tail);\n\t/* Commit code leaves a slack space of 16 bytes at the end of block */\n\ttags_per_block = (tag_space - 16) / journal_tag_bytes(journal);\n\t/*\n\t * Revoke descriptors are accounted separately so we need to reserve\n\t * space for commit block and normal transaction descriptor blocks.\n\t */\n\treturn 1 + DIV_ROUND_UP(journal->j_max_transaction_buffers,\n\t\t\t\ttags_per_block);\n}\n\n/*\n * jbd2_get_transaction: obtain a new transaction_t object.\n *\n * Simply initialise a new transaction. Initialize it in\n * RUNNING state and add it to the current journal (which should not\n * have an existing running transaction: we only make a new transaction\n * once we have started to commit the old one).\n *\n * Preconditions:\n *\tThe journal MUST be locked.  We don't perform atomic mallocs on the\n *\tnew transaction\tand we can't block without protecting against other\n *\tprocesses trying to touch the journal while it is in transition.\n *\n */\n\nstatic void jbd2_get_transaction(journal_t *journal,\n\t\t\t\ttransaction_t *transaction)\n{\n\ttransaction->t_journal = journal;\n\ttransaction->t_state = T_RUNNING;\n\ttransaction->t_start_time = ktime_get();\n\ttransaction->t_tid = journal->j_transaction_sequence++;\n\ttransaction->t_expires = jiffies + journal->j_commit_interval;\n\tspin_lock_init(&transaction->t_handle_lock);\n\tatomic_set(&transaction->t_updates, 0);\n\tatomic_set(&transaction->t_outstanding_credits,\n\t\t   jbd2_descriptor_blocks_per_trans(journal) +\n\t\t   atomic_read(&journal->j_reserved_credits));\n\tatomic_set(&transaction->t_outstanding_revokes, 0);\n\tatomic_set(&transaction->t_handle_count, 0);\n\tINIT_LIST_HEAD(&transaction->t_inode_list);\n\tINIT_LIST_HEAD(&transaction->t_private_list);\n\n\t/* Set up the commit timer for the new transaction. */\n\tjournal->j_commit_timer.expires = round_jiffies_up(transaction->t_expires);\n\tadd_timer(&journal->j_commit_timer);\n\n\tJ_ASSERT(journal->j_running_transaction == NULL);\n\tjournal->j_running_transaction = transaction;\n\ttransaction->t_max_wait = 0;\n\ttransaction->t_start = jiffies;\n\ttransaction->t_requested = 0;\n}\n\n/*\n * Handle management.\n *\n * A handle_t is an object which represents a single atomic update to a\n * filesystem, and which tracks all of the modifications which form part\n * of that one update.\n */\n\n/*\n * Update transaction's maximum wait time, if debugging is enabled.\n *\n * In order for t_max_wait to be reliable, it must be protected by a\n * lock.  But doing so will mean that start_this_handle() can not be\n * run in parallel on SMP systems, which limits our scalability.  So\n * unless debugging is enabled, we no longer update t_max_wait, which\n * means that maximum wait time reported by the jbd2_run_stats\n * tracepoint will always be zero.\n */\nstatic inline void update_t_max_wait(transaction_t *transaction,\n\t\t\t\t     unsigned long ts)\n{\n#ifdef CONFIG_JBD2_DEBUG\n\tif (jbd2_journal_enable_debug &&\n\t    time_after(transaction->t_start, ts)) {\n\t\tts = jbd2_time_diff(ts, transaction->t_start);\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tif (ts > transaction->t_max_wait)\n\t\t\ttransaction->t_max_wait = ts;\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t}\n#endif\n}\n\n/*\n * Wait until running transaction passes to T_FLUSH state and new transaction\n * can thus be started. Also starts the commit if needed. The function expects\n * running transaction to exist and releases j_state_lock.\n */\nstatic void wait_transaction_locked(journal_t *journal)\n\t__releases(journal->j_state_lock)\n{\n\tDEFINE_WAIT(wait);\n\tint need_to_start;\n\ttid_t tid = journal->j_running_transaction->t_tid;\n\n\tprepare_to_wait(&journal->j_wait_transaction_locked, &wait,\n\t\t\tTASK_UNINTERRUPTIBLE);\n\tneed_to_start = !tid_geq(journal->j_commit_request, tid);\n\tread_unlock(&journal->j_state_lock);\n\tif (need_to_start)\n\t\tjbd2_log_start_commit(journal, tid);\n\tjbd2_might_wait_for_commit(journal);\n\tschedule();\n\tfinish_wait(&journal->j_wait_transaction_locked, &wait);\n}\n\n/*\n * Wait until running transaction transitions from T_SWITCH to T_FLUSH\n * state and new transaction can thus be started. The function releases\n * j_state_lock.\n */\nstatic void wait_transaction_switching(journal_t *journal)\n\t__releases(journal->j_state_lock)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (WARN_ON(!journal->j_running_transaction ||\n\t\t    journal->j_running_transaction->t_state != T_SWITCH)) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\treturn;\n\t}\n\tprepare_to_wait(&journal->j_wait_transaction_locked, &wait,\n\t\t\tTASK_UNINTERRUPTIBLE);\n\tread_unlock(&journal->j_state_lock);\n\t/*\n\t * We don't call jbd2_might_wait_for_commit() here as there's no\n\t * waiting for outstanding handles happening anymore in T_SWITCH state\n\t * and handling of reserved handles actually relies on that for\n\t * correctness.\n\t */\n\tschedule();\n\tfinish_wait(&journal->j_wait_transaction_locked, &wait);\n}\n\nstatic void sub_reserved_credits(journal_t *journal, int blocks)\n{\n\tatomic_sub(blocks, &journal->j_reserved_credits);\n\twake_up(&journal->j_wait_reserved);\n}\n\n/*\n * Wait until we can add credits for handle to the running transaction.  Called\n * with j_state_lock held for reading. Returns 0 if handle joined the running\n * transaction. Returns 1 if we had to wait, j_state_lock is dropped, and\n * caller must retry.\n *\n * Note: because j_state_lock may be dropped depending on the return\n * value, we need to fake out sparse so ti doesn't complain about a\n * locking imbalance.  Callers of add_transaction_credits will need to\n * make a similar accomodation.\n */\nstatic int add_transaction_credits(journal_t *journal, int blocks,\n\t\t\t\t   int rsv_blocks)\n__must_hold(&journal->j_state_lock)\n{\n\ttransaction_t *t = journal->j_running_transaction;\n\tint needed;\n\tint total = blocks + rsv_blocks;\n\n\t/*\n\t * If the current transaction is locked down for commit, wait\n\t * for the lock to be released.\n\t */\n\tif (t->t_state != T_RUNNING) {\n\t\tWARN_ON_ONCE(t->t_state >= T_FLUSH);\n\t\twait_transaction_locked(journal);\n\t\t__acquire(&journal->j_state_lock); /* fake out sparse */\n\t\treturn 1;\n\t}\n\n\t/*\n\t * If there is not enough space left in the log to write all\n\t * potential buffers requested by this operation, we need to\n\t * stall pending a log checkpoint to free some more log space.\n\t */\n\tneeded = atomic_add_return(total, &t->t_outstanding_credits);\n\tif (needed > journal->j_max_transaction_buffers) {\n\t\t/*\n\t\t * If the current transaction is already too large,\n\t\t * then start to commit it: we can then go back and\n\t\t * attach this handle to a new transaction.\n\t\t */\n\t\tatomic_sub(total, &t->t_outstanding_credits);\n\n\t\t/*\n\t\t * Is the number of reserved credits in the current transaction too\n\t\t * big to fit this handle? Wait until reserved credits are freed.\n\t\t */\n\t\tif (atomic_read(&journal->j_reserved_credits) + total >\n\t\t    journal->j_max_transaction_buffers) {\n\t\t\tread_unlock(&journal->j_state_lock);\n\t\t\tjbd2_might_wait_for_commit(journal);\n\t\t\twait_event(journal->j_wait_reserved,\n\t\t\t\t   atomic_read(&journal->j_reserved_credits) + total <=\n\t\t\t\t   journal->j_max_transaction_buffers);\n\t\t\t__acquire(&journal->j_state_lock); /* fake out sparse */\n\t\t\treturn 1;\n\t\t}\n\n\t\twait_transaction_locked(journal);\n\t\t__acquire(&journal->j_state_lock); /* fake out sparse */\n\t\treturn 1;\n\t}\n\n\t/*\n\t * The commit code assumes that it can get enough log space\n\t * without forcing a checkpoint.  This is *critical* for\n\t * correctness: a checkpoint of a buffer which is also\n\t * associated with a committing transaction creates a deadlock,\n\t * so commit simply cannot force through checkpoints.\n\t *\n\t * We must therefore ensure the necessary space in the journal\n\t * *before* starting to dirty potentially checkpointed buffers\n\t * in the new transaction.\n\t */\n\tif (jbd2_log_space_left(journal) < journal->j_max_transaction_buffers) {\n\t\tatomic_sub(total, &t->t_outstanding_credits);\n\t\tread_unlock(&journal->j_state_lock);\n\t\tjbd2_might_wait_for_commit(journal);\n\t\twrite_lock(&journal->j_state_lock);\n\t\tif (jbd2_log_space_left(journal) <\n\t\t\t\t\tjournal->j_max_transaction_buffers)\n\t\t\t__jbd2_log_wait_for_space(journal);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\t__acquire(&journal->j_state_lock); /* fake out sparse */\n\t\treturn 1;\n\t}\n\n\t/* No reservation? We are done... */\n\tif (!rsv_blocks)\n\t\treturn 0;\n\n\tneeded = atomic_add_return(rsv_blocks, &journal->j_reserved_credits);\n\t/* We allow at most half of a transaction to be reserved */\n\tif (needed > journal->j_max_transaction_buffers / 2) {\n\t\tsub_reserved_credits(journal, rsv_blocks);\n\t\tatomic_sub(total, &t->t_outstanding_credits);\n\t\tread_unlock(&journal->j_state_lock);\n\t\tjbd2_might_wait_for_commit(journal);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t atomic_read(&journal->j_reserved_credits) + rsv_blocks\n\t\t\t <= journal->j_max_transaction_buffers / 2);\n\t\t__acquire(&journal->j_state_lock); /* fake out sparse */\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * start_this_handle: Given a handle, deal with any locking or stalling\n * needed to make sure that there is enough journal space for the handle\n * to begin.  Attach the handle to a transaction and set up the\n * transaction's buffer credits.\n */\n\nstatic int start_this_handle(journal_t *journal, handle_t *handle,\n\t\t\t     gfp_t gfp_mask)\n{\n\ttransaction_t\t*transaction, *new_transaction = NULL;\n\tint\t\tblocks = handle->h_total_credits;\n\tint\t\trsv_blocks = 0;\n\tunsigned long ts = jiffies;\n\n\tif (handle->h_rsv_handle)\n\t\trsv_blocks = handle->h_rsv_handle->h_total_credits;\n\n\t/*\n\t * Limit the number of reserved credits to 1/2 of maximum transaction\n\t * size and limit the number of total credits to not exceed maximum\n\t * transaction size per operation.\n\t */\n\tif ((rsv_blocks > journal->j_max_transaction_buffers / 2) ||\n\t    (rsv_blocks + blocks > journal->j_max_transaction_buffers)) {\n\t\tprintk(KERN_ERR \"JBD2: %s wants too many credits \"\n\t\t       \"credits:%d rsv_credits:%d max:%d\\n\",\n\t\t       current->comm, blocks, rsv_blocks,\n\t\t       journal->j_max_transaction_buffers);\n\t\tWARN_ON(1);\n\t\treturn -ENOSPC;\n\t}\n\nalloc_transaction:\n\t/*\n\t * This check is racy but it is just an optimization of allocating new\n\t * transaction early if there are high chances we'll need it. If we\n\t * guess wrong, we'll retry or free unused transaction.\n\t */\n\tif (!data_race(journal->j_running_transaction)) {\n\t\t/*\n\t\t * If __GFP_FS is not present, then we may be being called from\n\t\t * inside the fs writeback layer, so we MUST NOT fail.\n\t\t */\n\t\tif ((gfp_mask & __GFP_FS) == 0)\n\t\t\tgfp_mask |= __GFP_NOFAIL;\n\t\tnew_transaction = kmem_cache_zalloc(transaction_cache,\n\t\t\t\t\t\t    gfp_mask);\n\t\tif (!new_transaction)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tjbd_debug(3, \"New handle %p going live.\\n\", handle);\n\n\t/*\n\t * We need to hold j_state_lock until t_updates has been incremented,\n\t * for proper journal barrier handling\n\t */\nrepeat:\n\tread_lock(&journal->j_state_lock);\n\tBUG_ON(journal->j_flags & JBD2_UNMOUNT);\n\tif (is_journal_aborted(journal) ||\n\t    (journal->j_errno != 0 && !(journal->j_flags & JBD2_ACK_ERR))) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\tjbd2_journal_free_transaction(new_transaction);\n\t\treturn -EROFS;\n\t}\n\n\t/*\n\t * Wait on the journal's transaction barrier if necessary. Specifically\n\t * we allow reserved handles to proceed because otherwise commit could\n\t * deadlock on page writeback not being able to complete.\n\t */\n\tif (!handle->h_reserved && journal->j_barrier_count) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_transaction_locked,\n\t\t\t\tjournal->j_barrier_count == 0);\n\t\tgoto repeat;\n\t}\n\n\tif (!journal->j_running_transaction) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\tif (!new_transaction)\n\t\t\tgoto alloc_transaction;\n\t\twrite_lock(&journal->j_state_lock);\n\t\tif (!journal->j_running_transaction &&\n\t\t    (handle->h_reserved || !journal->j_barrier_count)) {\n\t\t\tjbd2_get_transaction(journal, new_transaction);\n\t\t\tnew_transaction = NULL;\n\t\t}\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tgoto repeat;\n\t}\n\n\ttransaction = journal->j_running_transaction;\n\n\tif (!handle->h_reserved) {\n\t\t/* We may have dropped j_state_lock - restart in that case */\n\t\tif (add_transaction_credits(journal, blocks, rsv_blocks)) {\n\t\t\t/*\n\t\t\t * add_transaction_credits releases\n\t\t\t * j_state_lock on a non-zero return\n\t\t\t */\n\t\t\t__release(&journal->j_state_lock);\n\t\t\tgoto repeat;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We have handle reserved so we are allowed to join T_LOCKED\n\t\t * transaction and we don't have to check for transaction size\n\t\t * and journal space. But we still have to wait while running\n\t\t * transaction is being switched to a committing one as it\n\t\t * won't wait for any handles anymore.\n\t\t */\n\t\tif (transaction->t_state == T_SWITCH) {\n\t\t\twait_transaction_switching(journal);\n\t\t\tgoto repeat;\n\t\t}\n\t\tsub_reserved_credits(journal, blocks);\n\t\thandle->h_reserved = 0;\n\t}\n\n\t/* OK, account for the buffers that this operation expects to\n\t * use and add the handle to the running transaction.\n\t */\n\tupdate_t_max_wait(transaction, ts);\n\thandle->h_transaction = transaction;\n\thandle->h_requested_credits = blocks;\n\thandle->h_revoke_credits_requested = handle->h_revoke_credits;\n\thandle->h_start_jiffies = jiffies;\n\tatomic_inc(&transaction->t_updates);\n\tatomic_inc(&transaction->t_handle_count);\n\tjbd_debug(4, \"Handle %p given %d credits (total %d, free %lu)\\n\",\n\t\t  handle, blocks,\n\t\t  atomic_read(&transaction->t_outstanding_credits),\n\t\t  jbd2_log_space_left(journal));\n\tread_unlock(&journal->j_state_lock);\n\tcurrent->journal_info = handle;\n\n\trwsem_acquire_read(&journal->j_trans_commit_map, 0, 0, _THIS_IP_);\n\tjbd2_journal_free_transaction(new_transaction);\n\t/*\n\t * Ensure that no allocations done while the transaction is open are\n\t * going to recurse back to the fs layer.\n\t */\n\thandle->saved_alloc_context = memalloc_nofs_save();\n\treturn 0;\n}\n\n/* Allocate a new handle.  This should probably be in a slab... */\nstatic handle_t *new_handle(int nblocks)\n{\n\thandle_t *handle = jbd2_alloc_handle(GFP_NOFS);\n\tif (!handle)\n\t\treturn NULL;\n\thandle->h_total_credits = nblocks;\n\thandle->h_ref = 1;\n\n\treturn handle;\n}\n\nhandle_t *jbd2__journal_start(journal_t *journal, int nblocks, int rsv_blocks,\n\t\t\t      int revoke_records, gfp_t gfp_mask,\n\t\t\t      unsigned int type, unsigned int line_no)\n{\n\thandle_t *handle = journal_current_handle();\n\tint err;\n\n\tif (!journal)\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (handle) {\n\t\tJ_ASSERT(handle->h_transaction->t_journal == journal);\n\t\thandle->h_ref++;\n\t\treturn handle;\n\t}\n\n\tnblocks += DIV_ROUND_UP(revoke_records,\n\t\t\t\tjournal->j_revoke_records_per_block);\n\thandle = new_handle(nblocks);\n\tif (!handle)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (rsv_blocks) {\n\t\thandle_t *rsv_handle;\n\n\t\trsv_handle = new_handle(rsv_blocks);\n\t\tif (!rsv_handle) {\n\t\t\tjbd2_free_handle(handle);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\trsv_handle->h_reserved = 1;\n\t\trsv_handle->h_journal = journal;\n\t\thandle->h_rsv_handle = rsv_handle;\n\t}\n\thandle->h_revoke_credits = revoke_records;\n\n\terr = start_this_handle(journal, handle, gfp_mask);\n\tif (err < 0) {\n\t\tif (handle->h_rsv_handle)\n\t\t\tjbd2_free_handle(handle->h_rsv_handle);\n\t\tjbd2_free_handle(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\thandle->h_type = type;\n\thandle->h_line_no = line_no;\n\ttrace_jbd2_handle_start(journal->j_fs_dev->bd_dev,\n\t\t\t\thandle->h_transaction->t_tid, type,\n\t\t\t\tline_no, nblocks);\n\n\treturn handle;\n}\nEXPORT_SYMBOL(jbd2__journal_start);\n\n\n/**\n * jbd2_journal_start() - Obtain a new handle.\n * @journal: Journal to start transaction on.\n * @nblocks: number of block buffer we might modify\n *\n * We make sure that the transaction can guarantee at least nblocks of\n * modified buffers in the log.  We block until the log can guarantee\n * that much space. Additionally, if rsv_blocks > 0, we also create another\n * handle with rsv_blocks reserved blocks in the journal. This handle is\n * stored in h_rsv_handle. It is not attached to any particular transaction\n * and thus doesn't block transaction commit. If the caller uses this reserved\n * handle, it has to set h_rsv_handle to NULL as otherwise jbd2_journal_stop()\n * on the parent handle will dispose the reserved one. Reserved handle has to\n * be converted to a normal handle using jbd2_journal_start_reserved() before\n * it can be used.\n *\n * Return a pointer to a newly allocated handle, or an ERR_PTR() value\n * on failure.\n */\nhandle_t *jbd2_journal_start(journal_t *journal, int nblocks)\n{\n\treturn jbd2__journal_start(journal, nblocks, 0, 0, GFP_NOFS, 0, 0);\n}\nEXPORT_SYMBOL(jbd2_journal_start);\n\nstatic void __jbd2_journal_unreserve_handle(handle_t *handle, transaction_t *t)\n{\n\tjournal_t *journal = handle->h_journal;\n\n\tWARN_ON(!handle->h_reserved);\n\tsub_reserved_credits(journal, handle->h_total_credits);\n\tif (t)\n\t\tatomic_sub(handle->h_total_credits, &t->t_outstanding_credits);\n}\n\nvoid jbd2_journal_free_reserved(handle_t *handle)\n{\n\tjournal_t *journal = handle->h_journal;\n\n\t/* Get j_state_lock to pin running transaction if it exists */\n\tread_lock(&journal->j_state_lock);\n\t__jbd2_journal_unreserve_handle(handle, journal->j_running_transaction);\n\tread_unlock(&journal->j_state_lock);\n\tjbd2_free_handle(handle);\n}\nEXPORT_SYMBOL(jbd2_journal_free_reserved);\n\n/**\n * jbd2_journal_start_reserved() - start reserved handle\n * @handle: handle to start\n * @type: for handle statistics\n * @line_no: for handle statistics\n *\n * Start handle that has been previously reserved with jbd2_journal_reserve().\n * This attaches @handle to the running transaction (or creates one if there's\n * not transaction running). Unlike jbd2_journal_start() this function cannot\n * block on journal commit, checkpointing, or similar stuff. It can block on\n * memory allocation or frozen journal though.\n *\n * Return 0 on success, non-zero on error - handle is freed in that case.\n */\nint jbd2_journal_start_reserved(handle_t *handle, unsigned int type,\n\t\t\t\tunsigned int line_no)\n{\n\tjournal_t *journal = handle->h_journal;\n\tint ret = -EIO;\n\n\tif (WARN_ON(!handle->h_reserved)) {\n\t\t/* Someone passed in normal handle? Just stop it. */\n\t\tjbd2_journal_stop(handle);\n\t\treturn ret;\n\t}\n\t/*\n\t * Usefulness of mixing of reserved and unreserved handles is\n\t * questionable. So far nobody seems to need it so just error out.\n\t */\n\tif (WARN_ON(current->journal_info)) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ret;\n\t}\n\n\thandle->h_journal = NULL;\n\t/*\n\t * GFP_NOFS is here because callers are likely from writeback or\n\t * similarly constrained call sites\n\t */\n\tret = start_this_handle(journal, handle, GFP_NOFS);\n\tif (ret < 0) {\n\t\thandle->h_journal = journal;\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ret;\n\t}\n\thandle->h_type = type;\n\thandle->h_line_no = line_no;\n\ttrace_jbd2_handle_start(journal->j_fs_dev->bd_dev,\n\t\t\t\thandle->h_transaction->t_tid, type,\n\t\t\t\tline_no, handle->h_total_credits);\n\treturn 0;\n}\nEXPORT_SYMBOL(jbd2_journal_start_reserved);\n\n/**\n * jbd2_journal_extend() - extend buffer credits.\n * @handle:  handle to 'extend'\n * @nblocks: nr blocks to try to extend by.\n * @revoke_records: number of revoke records to try to extend by.\n *\n * Some transactions, such as large extends and truncates, can be done\n * atomically all at once or in several stages.  The operation requests\n * a credit for a number of buffer modifications in advance, but can\n * extend its credit if it needs more.\n *\n * jbd2_journal_extend tries to give the running handle more buffer credits.\n * It does not guarantee that allocation - this is a best-effort only.\n * The calling process MUST be able to deal cleanly with a failure to\n * extend here.\n *\n * Return 0 on success, non-zero on failure.\n *\n * return code < 0 implies an error\n * return code > 0 implies normal transaction-full status.\n */\nint jbd2_journal_extend(handle_t *handle, int nblocks, int revoke_records)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tint result;\n\tint wanted;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\n\tresult = 1;\n\n\tread_lock(&journal->j_state_lock);\n\n\t/* Don't extend a locked-down transaction! */\n\tif (transaction->t_state != T_RUNNING) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction not running\\n\", handle, nblocks);\n\t\tgoto error_out;\n\t}\n\n\tnblocks += DIV_ROUND_UP(\n\t\t\thandle->h_revoke_credits_requested + revoke_records,\n\t\t\tjournal->j_revoke_records_per_block) -\n\t\tDIV_ROUND_UP(\n\t\t\thandle->h_revoke_credits_requested,\n\t\t\tjournal->j_revoke_records_per_block);\n\tspin_lock(&transaction->t_handle_lock);\n\twanted = atomic_add_return(nblocks,\n\t\t\t\t   &transaction->t_outstanding_credits);\n\n\tif (wanted > journal->j_max_transaction_buffers) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction too large\\n\", handle, nblocks);\n\t\tatomic_sub(nblocks, &transaction->t_outstanding_credits);\n\t\tgoto unlock;\n\t}\n\n\ttrace_jbd2_handle_extend(journal->j_fs_dev->bd_dev,\n\t\t\t\t transaction->t_tid,\n\t\t\t\t handle->h_type, handle->h_line_no,\n\t\t\t\t handle->h_total_credits,\n\t\t\t\t nblocks);\n\n\thandle->h_total_credits += nblocks;\n\thandle->h_requested_credits += nblocks;\n\thandle->h_revoke_credits += revoke_records;\n\thandle->h_revoke_credits_requested += revoke_records;\n\tresult = 0;\n\n\tjbd_debug(3, \"extended handle %p by %d\\n\", handle, nblocks);\nunlock:\n\tspin_unlock(&transaction->t_handle_lock);\nerror_out:\n\tread_unlock(&journal->j_state_lock);\n\treturn result;\n}\n\nstatic void stop_this_handle(handle_t *handle)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tint revokes;\n\n\tJ_ASSERT(journal_current_handle() == handle);\n\tJ_ASSERT(atomic_read(&transaction->t_updates) > 0);\n\tcurrent->journal_info = NULL;\n\t/*\n\t * Subtract necessary revoke descriptor blocks from handle credits. We\n\t * take care to account only for revoke descriptor blocks the\n\t * transaction will really need as large sequences of transactions with\n\t * small numbers of revokes are relatively common.\n\t */\n\trevokes = handle->h_revoke_credits_requested - handle->h_revoke_credits;\n\tif (revokes) {\n\t\tint t_revokes, revoke_descriptors;\n\t\tint rr_per_blk = journal->j_revoke_records_per_block;\n\n\t\tWARN_ON_ONCE(DIV_ROUND_UP(revokes, rr_per_blk)\n\t\t\t\t> handle->h_total_credits);\n\t\tt_revokes = atomic_add_return(revokes,\n\t\t\t\t&transaction->t_outstanding_revokes);\n\t\trevoke_descriptors =\n\t\t\tDIV_ROUND_UP(t_revokes, rr_per_blk) -\n\t\t\tDIV_ROUND_UP(t_revokes - revokes, rr_per_blk);\n\t\thandle->h_total_credits -= revoke_descriptors;\n\t}\n\tatomic_sub(handle->h_total_credits,\n\t\t   &transaction->t_outstanding_credits);\n\tif (handle->h_rsv_handle)\n\t\t__jbd2_journal_unreserve_handle(handle->h_rsv_handle,\n\t\t\t\t\t\ttransaction);\n\tif (atomic_dec_and_test(&transaction->t_updates))\n\t\twake_up(&journal->j_wait_updates);\n\n\trwsem_release(&journal->j_trans_commit_map, _THIS_IP_);\n\t/*\n\t * Scope of the GFP_NOFS context is over here and so we can restore the\n\t * original alloc context.\n\t */\n\tmemalloc_nofs_restore(handle->saved_alloc_context);\n}\n\n/**\n * jbd2__journal_restart() - restart a handle .\n * @handle:  handle to restart\n * @nblocks: nr credits requested\n * @revoke_records: number of revoke record credits requested\n * @gfp_mask: memory allocation flags (for start_this_handle)\n *\n * Restart a handle for a multi-transaction filesystem\n * operation.\n *\n * If the jbd2_journal_extend() call above fails to grant new buffer credits\n * to a running handle, a call to jbd2_journal_restart will commit the\n * handle's transaction so far and reattach the handle to a new\n * transaction capable of guaranteeing the requested number of\n * credits. We preserve reserved handle if there's any attached to the\n * passed in handle.\n */\nint jbd2__journal_restart(handle_t *handle, int nblocks, int revoke_records,\n\t\t\t  gfp_t gfp_mask)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\ttid_t\t\ttid;\n\tint\t\tneed_to_start;\n\tint\t\tret;\n\n\t/* If we've had an abort of any type, don't even think about\n\t * actually doing the restart! */\n\tif (is_handle_aborted(handle))\n\t\treturn 0;\n\tjournal = transaction->t_journal;\n\ttid = transaction->t_tid;\n\n\t/*\n\t * First unlink the handle from its current transaction, and start the\n\t * commit on that.\n\t */\n\tjbd_debug(2, \"restarting handle %p\\n\", handle);\n\tstop_this_handle(handle);\n\thandle->h_transaction = NULL;\n\n\t/*\n\t * TODO: If we use READ_ONCE / WRITE_ONCE for j_commit_request we can\n \t * get rid of pointless j_state_lock traffic like this.\n\t */\n\tread_lock(&journal->j_state_lock);\n\tneed_to_start = !tid_geq(journal->j_commit_request, tid);\n\tread_unlock(&journal->j_state_lock);\n\tif (need_to_start)\n\t\tjbd2_log_start_commit(journal, tid);\n\thandle->h_total_credits = nblocks +\n\t\tDIV_ROUND_UP(revoke_records,\n\t\t\t     journal->j_revoke_records_per_block);\n\thandle->h_revoke_credits = revoke_records;\n\tret = start_this_handle(journal, handle, gfp_mask);\n\ttrace_jbd2_handle_restart(journal->j_fs_dev->bd_dev,\n\t\t\t\t ret ? 0 : handle->h_transaction->t_tid,\n\t\t\t\t handle->h_type, handle->h_line_no,\n\t\t\t\t handle->h_total_credits);\n\treturn ret;\n}\nEXPORT_SYMBOL(jbd2__journal_restart);\n\n\nint jbd2_journal_restart(handle_t *handle, int nblocks)\n{\n\treturn jbd2__journal_restart(handle, nblocks, 0, GFP_NOFS);\n}\nEXPORT_SYMBOL(jbd2_journal_restart);\n\n/*\n * Waits for any outstanding t_updates to finish.\n * This is called with write j_state_lock held.\n */\nvoid jbd2_journal_wait_updates(journal_t *journal)\n{\n\ttransaction_t *commit_transaction = journal->j_running_transaction;\n\n\tif (!commit_transaction)\n\t\treturn;\n\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (atomic_read(&commit_transaction->t_updates)) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&commit_transaction->t_updates)) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n}\n\n/**\n * jbd2_journal_lock_updates () - establish a transaction barrier.\n * @journal:  Journal to establish a barrier on.\n *\n * This locks out any further updates from being started, and blocks\n * until all existing updates have completed, returning only once the\n * journal is in a quiescent state with no updates running.\n *\n * The journal lock should not be held on entry.\n */\nvoid jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\tjbd2_might_wait_for_commit(journal);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running t_updates */\n\tjbd2_journal_wait_updates(journal);\n\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}\n\n/**\n * jbd2_journal_unlock_updates () - release barrier\n * @journal:  Journal to release the barrier on.\n *\n * Release a transaction barrier obtained with jbd2_journal_lock_updates().\n *\n * Should be called without the journal lock held.\n */\nvoid jbd2_journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tmutex_unlock(&journal->j_barrier);\n\twrite_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}\n\nstatic void warn_dirty_buffer(struct buffer_head *bh)\n{\n\tprintk(KERN_WARNING\n\t       \"JBD2: Spotted dirty metadata buffer (dev = %pg, blocknr = %llu). \"\n\t       \"There's a risk of filesystem corruption in case of system \"\n\t       \"crash.\\n\",\n\t       bh->b_bdev, (unsigned long long)bh->b_blocknr);\n}\n\n/* Call t_frozen trigger and copy buffer data into jh->b_frozen_data. */\nstatic void jbd2_freeze_jh_data(struct journal_head *jh)\n{\n\tstruct page *page;\n\tint offset;\n\tchar *source;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_EXPECT_JH(jh, buffer_uptodate(bh), \"Possible IO failure.\\n\");\n\tpage = bh->b_page;\n\toffset = offset_in_page(bh->b_data);\n\tsource = kmap_atomic(page);\n\t/* Fire data frozen trigger just before we copy the data */\n\tjbd2_buffer_frozen_trigger(jh, source + offset, jh->b_triggers);\n\tmemcpy(jh->b_frozen_data, source + offset, bh->b_size);\n\tkunmap_atomic(source);\n\n\t/*\n\t * Now that the frozen data is saved off, we need to store any matching\n\t * triggers.\n\t */\n\tjh->b_frozen_triggers = jh->b_triggers;\n}\n\n/*\n * If the buffer is already part of the current transaction, then there\n * is nothing we need to do.  If it is already part of a prior\n * transaction which we are still committing to disk, then we need to\n * make sure that we do not overwrite the old copy: we do copy-out to\n * preserve the copy going to disk.  We also account the buffer against\n * the handle's metadata buffer credits (unless the buffer is already\n * part of the transaction, that is).\n *\n */\nstatic int\ndo_get_write_access(handle_t *handle, struct journal_head *jh,\n\t\t\tint force_copy)\n{\n\tstruct buffer_head *bh;\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tint error;\n\tchar *frozen_buffer = NULL;\n\tunsigned long start_lock, time_lock;\n\n\tjournal = transaction->t_journal;\n\n\tjbd_debug(5, \"journal_head %p, force_copy %d\\n\", jh, force_copy);\n\n\tJBUFFER_TRACE(jh, \"entry\");\nrepeat:\n\tbh = jh2bh(jh);\n\n\t/* @@@ Need to check for errors here at some point. */\n\n \tstart_lock = jiffies;\n\tlock_buffer(bh);\n\tspin_lock(&jh->b_state_lock);\n\n\t/* If it takes too long to lock the buffer, trace it */\n\ttime_lock = jbd2_time_diff(start_lock, jiffies);\n\tif (time_lock > HZ/10)\n\t\ttrace_jbd2_lock_buffer_stall(bh->b_bdev->bd_dev,\n\t\t\tjiffies_to_msecs(time_lock));\n\n\t/* We now hold the buffer lock so it is safe to query the buffer\n\t * state.  Is the buffer dirty?\n\t *\n\t * If so, there are two possibilities.  The buffer may be\n\t * non-journaled, and undergoing a quite legitimate writeback.\n\t * Otherwise, it is journaled, and we don't expect dirty buffers\n\t * in that state (the buffers should be marked JBD_Dirty\n\t * instead.)  So either the IO is being done under our own\n\t * control and this is a bug, or it's a third party IO such as\n\t * dump(8) (which may leave the buffer scheduled for read ---\n\t * ie. locked but not dirty) or tune2fs (which may actually have\n\t * the buffer dirtied, ugh.)  */\n\n\tif (buffer_dirty(bh)) {\n\t\t/*\n\t\t * First question: is this buffer already part of the current\n\t\t * transaction or the existing committing transaction?\n\t\t */\n\t\tif (jh->b_transaction) {\n\t\t\tJ_ASSERT_JH(jh,\n\t\t\t\tjh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\t\tif (jh->b_next_transaction)\n\t\t\t\tJ_ASSERT_JH(jh, jh->b_next_transaction ==\n\t\t\t\t\t\t\ttransaction);\n\t\t\twarn_dirty_buffer(bh);\n\t\t}\n\t\t/*\n\t\t * In any case we need to clean the dirty flag and we must\n\t\t * do it under the buffer lock to be sure we don't race\n\t\t * with running write-out.\n\t\t */\n\t\tJBUFFER_TRACE(jh, \"Journalling dirty buffer\");\n\t\tclear_buffer_dirty(bh);\n\t\tset_buffer_jbddirty(bh);\n\t}\n\n\tunlock_buffer(bh);\n\n\terror = -EROFS;\n\tif (is_handle_aborted(handle)) {\n\t\tspin_unlock(&jh->b_state_lock);\n\t\tgoto out;\n\t}\n\terror = 0;\n\n\t/*\n\t * The buffer is already part of this transaction if b_transaction or\n\t * b_next_transaction points to it\n\t */\n\tif (jh->b_transaction == transaction ||\n\t    jh->b_next_transaction == transaction)\n\t\tgoto done;\n\n\t/*\n\t * this is the first time this transaction is touching this buffer,\n\t * reset the modified flag\n\t */\n\tjh->b_modified = 0;\n\n\t/*\n\t * If the buffer is not journaled right now, we need to make sure it\n\t * doesn't get written to disk before the caller actually commits the\n\t * new data\n\t */\n\tif (!jh->b_transaction) {\n\t\tJBUFFER_TRACE(jh, \"no transaction\");\n\t\tJ_ASSERT_JH(jh, !jh->b_next_transaction);\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Reserved\");\n\t\t/*\n\t\t * Make sure all stores to jh (b_modified, b_frozen_data) are\n\t\t * visible before attaching it to the running transaction.\n\t\t * Paired with barrier in jbd2_write_access_granted()\n\t\t */\n\t\tsmp_wmb();\n\t\tspin_lock(&journal->j_list_lock);\n\t\t__jbd2_journal_file_buffer(jh, transaction, BJ_Reserved);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tgoto done;\n\t}\n\t/*\n\t * If there is already a copy-out version of this buffer, then we don't\n\t * need to make another one\n\t */\n\tif (jh->b_frozen_data) {\n\t\tJBUFFER_TRACE(jh, \"has frozen data\");\n\t\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\t\tgoto attach_next;\n\t}\n\n\tJBUFFER_TRACE(jh, \"owned by older transaction\");\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_transaction == journal->j_committing_transaction);\n\n\t/*\n\t * There is one case we have to be very careful about.  If the\n\t * committing transaction is currently writing this buffer out to disk\n\t * and has NOT made a copy-out, then we cannot modify the buffer\n\t * contents at all right now.  The essence of copy-out is that it is\n\t * the extra copy, not the primary copy, which gets journaled.  If the\n\t * primary copy is already going to disk then we cannot do copy-out\n\t * here.\n\t */\n\tif (buffer_shadow(bh)) {\n\t\tJBUFFER_TRACE(jh, \"on shadow: sleep\");\n\t\tspin_unlock(&jh->b_state_lock);\n\t\twait_on_bit_io(&bh->b_state, BH_Shadow, TASK_UNINTERRUPTIBLE);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * Only do the copy if the currently-owning transaction still needs it.\n\t * If buffer isn't on BJ_Metadata list, the committing transaction is\n\t * past that stage (here we use the fact that BH_Shadow is set under\n\t * bh_state lock together with refiling to BJ_Shadow list and at this\n\t * point we know the buffer doesn't have BH_Shadow set).\n\t *\n\t * Subtle point, though: if this is a get_undo_access, then we will be\n\t * relying on the frozen_data to contain the new value of the\n\t * committed_data record after the transaction, so we HAVE to force the\n\t * frozen_data copy in that case.\n\t */\n\tif (jh->b_jlist == BJ_Metadata || force_copy) {\n\t\tJBUFFER_TRACE(jh, \"generate frozen data\");\n\t\tif (!frozen_buffer) {\n\t\t\tJBUFFER_TRACE(jh, \"allocate memory for buffer\");\n\t\t\tspin_unlock(&jh->b_state_lock);\n\t\t\tfrozen_buffer = jbd2_alloc(jh2bh(jh)->b_size,\n\t\t\t\t\t\t   GFP_NOFS | __GFP_NOFAIL);\n\t\t\tgoto repeat;\n\t\t}\n\t\tjh->b_frozen_data = frozen_buffer;\n\t\tfrozen_buffer = NULL;\n\t\tjbd2_freeze_jh_data(jh);\n\t}\nattach_next:\n\t/*\n\t * Make sure all stores to jh (b_modified, b_frozen_data) are visible\n\t * before attaching it to the running transaction. Paired with barrier\n\t * in jbd2_write_access_granted()\n\t */\n\tsmp_wmb();\n\tjh->b_next_transaction = transaction;\n\ndone:\n\tspin_unlock(&jh->b_state_lock);\n\n\t/*\n\t * If we are about to journal a buffer, then any revoke pending on it is\n\t * no longer valid\n\t */\n\tjbd2_journal_cancel_revoke(handle, jh);\n\nout:\n\tif (unlikely(frozen_buffer))\t/* It's usually NULL */\n\t\tjbd2_free(frozen_buffer, bh->b_size);\n\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn error;\n}\n\n/* Fast check whether buffer is already attached to the required transaction */\nstatic bool jbd2_write_access_granted(handle_t *handle, struct buffer_head *bh,\n\t\t\t\t\t\t\tbool undo)\n{\n\tstruct journal_head *jh;\n\tbool ret = false;\n\n\t/* Dirty buffers require special handling... */\n\tif (buffer_dirty(bh))\n\t\treturn false;\n\n\t/*\n\t * RCU protects us from dereferencing freed pages. So the checks we do\n\t * are guaranteed not to oops. However the jh slab object can get freed\n\t * & reallocated while we work with it. So we have to be careful. When\n\t * we see jh attached to the running transaction, we know it must stay\n\t * so until the transaction is committed. Thus jh won't be freed and\n\t * will be attached to the same bh while we run.  However it can\n\t * happen jh gets freed, reallocated, and attached to the transaction\n\t * just after we get pointer to it from bh. So we have to be careful\n\t * and recheck jh still belongs to our bh before we return success.\n\t */\n\trcu_read_lock();\n\tif (!buffer_jbd(bh))\n\t\tgoto out;\n\t/* This should be bh2jh() but that doesn't work with inline functions */\n\tjh = READ_ONCE(bh->b_private);\n\tif (!jh)\n\t\tgoto out;\n\t/* For undo access buffer must have data copied */\n\tif (undo && !jh->b_committed_data)\n\t\tgoto out;\n\tif (READ_ONCE(jh->b_transaction) != handle->h_transaction &&\n\t    READ_ONCE(jh->b_next_transaction) != handle->h_transaction)\n\t\tgoto out;\n\t/*\n\t * There are two reasons for the barrier here:\n\t * 1) Make sure to fetch b_bh after we did previous checks so that we\n\t * detect when jh went through free, realloc, attach to transaction\n\t * while we were checking. Paired with implicit barrier in that path.\n\t * 2) So that access to bh done after jbd2_write_access_granted()\n\t * doesn't get reordered and see inconsistent state of concurrent\n\t * do_get_write_access().\n\t */\n\tsmp_mb();\n\tif (unlikely(jh->b_bh != bh))\n\t\tgoto out;\n\tret = true;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\n\n/**\n * jbd2_journal_get_write_access() - notify intent to modify a buffer\n *\t\t\t\t     for metadata (not data) update.\n * @handle: transaction to add buffer modifications to\n * @bh:     bh to be used for metadata writes\n *\n * Returns: error code or 0 on success.\n *\n * In full data journalling mode the buffer may be of type BJ_AsyncData,\n * because we're ``write()ing`` a buffer which is also part of a shared mapping.\n */\n\nint jbd2_journal_get_write_access(handle_t *handle, struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\tint rc;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\n\tif (jbd2_write_access_granted(handle, bh, false))\n\t\treturn 0;\n\n\tjh = jbd2_journal_add_journal_head(bh);\n\t/* We do not want to get caught playing with fields which the\n\t * log thread also manipulates.  Make sure that the buffer\n\t * completes any outstanding IO before proceeding. */\n\trc = do_get_write_access(handle, jh, 0);\n\tjbd2_journal_put_journal_head(jh);\n\treturn rc;\n}\n\n\n/*\n * When the user wants to journal a newly created buffer_head\n * (ie. getblk() returned a new buffer and we are going to populate it\n * manually rather than reading off disk), then we need to keep the\n * buffer_head locked until it has been completely filled with new\n * data.  In this case, we should be able to make the assertion that\n * the bh is not already part of an existing transaction.\n *\n * The buffer should already be locked by the caller by this point.\n * There is no lock ranking violation: it was a newly created,\n * unlocked buffer beforehand. */\n\n/**\n * jbd2_journal_get_create_access () - notify intent to use newly created bh\n * @handle: transaction to new buffer to\n * @bh: new buffer.\n *\n * Call this if you create a new bh.\n */\nint jbd2_journal_get_create_access(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh = jbd2_journal_add_journal_head(bh);\n\tint err;\n\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\terr = -EROFS;\n\tif (is_handle_aborted(handle))\n\t\tgoto out;\n\tjournal = transaction->t_journal;\n\terr = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\t/*\n\t * The buffer may already belong to this transaction due to pre-zeroing\n\t * in the filesystem's new_block code.  It may also be on the previous,\n\t * committing transaction's lists, but it HAS to be in Forget state in\n\t * that case: the transaction must have deleted the buffer for it to be\n\t * reused here.\n\t */\n\tspin_lock(&jh->b_state_lock);\n\tJ_ASSERT_JH(jh, (jh->b_transaction == transaction ||\n\t\tjh->b_transaction == NULL ||\n\t\t(jh->b_transaction == journal->j_committing_transaction &&\n\t\t\t  jh->b_jlist == BJ_Forget)));\n\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\tJ_ASSERT_JH(jh, buffer_locked(jh2bh(jh)));\n\n\tif (jh->b_transaction == NULL) {\n\t\t/*\n\t\t * Previous jbd2_journal_forget() could have left the buffer\n\t\t * with jbddirty bit set because it was being committed. When\n\t\t * the commit finished, we've filed the buffer for\n\t\t * checkpointing and marked it dirty. Now we are reallocating\n\t\t * the buffer so the transaction freeing it must have\n\t\t * committed and so it's safe to clear the dirty bit.\n\t\t */\n\t\tclear_buffer_dirty(jh2bh(jh));\n\t\t/* first access by this transaction */\n\t\tjh->b_modified = 0;\n\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Reserved\");\n\t\tspin_lock(&journal->j_list_lock);\n\t\t__jbd2_journal_file_buffer(jh, transaction, BJ_Reserved);\n\t\tspin_unlock(&journal->j_list_lock);\n\t} else if (jh->b_transaction == journal->j_committing_transaction) {\n\t\t/* first access by this transaction */\n\t\tjh->b_modified = 0;\n\n\t\tJBUFFER_TRACE(jh, \"set next transaction\");\n\t\tspin_lock(&journal->j_list_lock);\n\t\tjh->b_next_transaction = transaction;\n\t\tspin_unlock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&jh->b_state_lock);\n\n\t/*\n\t * akpm: I added this.  ext3_alloc_branch can pick up new indirect\n\t * blocks which contain freed but then revoked metadata.  We need\n\t * to cancel the revoke in case we end up freeing it yet again\n\t * and the reallocating as data - this would cause a second revoke,\n\t * which hits an assertion error.\n\t */\n\tJBUFFER_TRACE(jh, \"cancelling revoke\");\n\tjbd2_journal_cancel_revoke(handle, jh);\nout:\n\tjbd2_journal_put_journal_head(jh);\n\treturn err;\n}\n\n/**\n * jbd2_journal_get_undo_access() -  Notify intent to modify metadata with\n *     non-rewindable consequences\n * @handle: transaction\n * @bh: buffer to undo\n *\n * Sometimes there is a need to distinguish between metadata which has\n * been committed to disk and that which has not.  The ext3fs code uses\n * this for freeing and allocating space, we have to make sure that we\n * do not reuse freed space until the deallocation has been committed,\n * since if we overwrote that space we would make the delete\n * un-rewindable in case of a crash.\n *\n * To deal with that, jbd2_journal_get_undo_access requests write access to a\n * buffer for parts of non-rewindable operations such as delete\n * operations on the bitmaps.  The journaling code must keep a copy of\n * the buffer's contents prior to the undo_access call until such time\n * as we know that the buffer has definitely been committed to disk.\n *\n * We never need to know which transaction the committed data is part\n * of, buffers touched here are guaranteed to be dirtied later and so\n * will be committed to a new transaction in due course, at which point\n * we can discard the old committed data pointer.\n *\n * Returns error number or 0 on success.\n */\nint jbd2_journal_get_undo_access(handle_t *handle, struct buffer_head *bh)\n{\n\tint err;\n\tstruct journal_head *jh;\n\tchar *committed_data = NULL;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\n\tif (jbd2_write_access_granted(handle, bh, true))\n\t\treturn 0;\n\n\tjh = jbd2_journal_add_journal_head(bh);\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\t/*\n\t * Do this first --- it can drop the journal lock, so we want to\n\t * make sure that obtaining the committed_data is done\n\t * atomically wrt. completion of any outstanding commits.\n\t */\n\terr = do_get_write_access(handle, jh, 1);\n\tif (err)\n\t\tgoto out;\n\nrepeat:\n\tif (!jh->b_committed_data)\n\t\tcommitted_data = jbd2_alloc(jh2bh(jh)->b_size,\n\t\t\t\t\t    GFP_NOFS|__GFP_NOFAIL);\n\n\tspin_lock(&jh->b_state_lock);\n\tif (!jh->b_committed_data) {\n\t\t/* Copy out the current buffer contents into the\n\t\t * preserved, committed copy. */\n\t\tJBUFFER_TRACE(jh, \"generate b_committed data\");\n\t\tif (!committed_data) {\n\t\t\tspin_unlock(&jh->b_state_lock);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh->b_committed_data = committed_data;\n\t\tcommitted_data = NULL;\n\t\tmemcpy(jh->b_committed_data, bh->b_data, bh->b_size);\n\t}\n\tspin_unlock(&jh->b_state_lock);\nout:\n\tjbd2_journal_put_journal_head(jh);\n\tif (unlikely(committed_data))\n\t\tjbd2_free(committed_data, bh->b_size);\n\treturn err;\n}\n\n/**\n * jbd2_journal_set_triggers() - Add triggers for commit writeout\n * @bh: buffer to trigger on\n * @type: struct jbd2_buffer_trigger_type containing the trigger(s).\n *\n * Set any triggers on this journal_head.  This is always safe, because\n * triggers for a committing buffer will be saved off, and triggers for\n * a running transaction will match the buffer in that transaction.\n *\n * Call with NULL to clear the triggers.\n */\nvoid jbd2_journal_set_triggers(struct buffer_head *bh,\n\t\t\t       struct jbd2_buffer_trigger_type *type)\n{\n\tstruct journal_head *jh = jbd2_journal_grab_journal_head(bh);\n\n\tif (WARN_ON_ONCE(!jh))\n\t\treturn;\n\tjh->b_triggers = type;\n\tjbd2_journal_put_journal_head(jh);\n}\n\nvoid jbd2_buffer_frozen_trigger(struct journal_head *jh, void *mapped_data,\n\t\t\t\tstruct jbd2_buffer_trigger_type *triggers)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tif (!triggers || !triggers->t_frozen)\n\t\treturn;\n\n\ttriggers->t_frozen(triggers, bh, mapped_data, bh->b_size);\n}\n\nvoid jbd2_buffer_abort_trigger(struct journal_head *jh,\n\t\t\t       struct jbd2_buffer_trigger_type *triggers)\n{\n\tif (!triggers || !triggers->t_abort)\n\t\treturn;\n\n\ttriggers->t_abort(triggers, jh2bh(jh));\n}\n\n/**\n * jbd2_journal_dirty_metadata() -  mark a buffer as containing dirty metadata\n * @handle: transaction to add buffer to.\n * @bh: buffer to mark\n *\n * mark dirty metadata which needs to be journaled as part of the current\n * transaction.\n *\n * The buffer must have previously had jbd2_journal_get_write_access()\n * called so that it has a valid journal_head attached to the buffer\n * head.\n *\n * The buffer is placed on the transaction's metadata list and is marked\n * as belonging to the transaction.\n *\n * Returns error number or 0 on success.\n *\n * Special care needs to be taken if the buffer already belongs to the\n * current committing transaction (in which case we should have frozen\n * data present for that commit).  In that case, we don't relink the\n * buffer: that only gets done when the old transaction finally\n * completes its commit.\n */\nint jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh;\n\tint ret = 0;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tif (!buffer_jbd(bh))\n\t\treturn -EUCLEAN;\n\n\t/*\n\t * We don't grab jh reference here since the buffer must be part\n\t * of the running transaction.\n\t */\n\tjh = bh2jh(bh);\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\t/*\n\t * This and the following assertions are unreliable since we may see jh\n\t * in inconsistent state unless we grab bh_state lock. But this is\n\t * crucial to catch bugs so let's do a reliable check until the\n\t * lockless handling is fully proven.\n\t */\n\tif (data_race(jh->b_transaction != transaction &&\n\t    jh->b_next_transaction != transaction)) {\n\t\tspin_lock(&jh->b_state_lock);\n\t\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_next_transaction == transaction);\n\t\tspin_unlock(&jh->b_state_lock);\n\t}\n\tif (jh->b_modified == 1) {\n\t\t/* If it's in our transaction it must be in BJ_Metadata list. */\n\t\tif (data_race(jh->b_transaction == transaction &&\n\t\t    jh->b_jlist != BJ_Metadata)) {\n\t\t\tspin_lock(&jh->b_state_lock);\n\t\t\tif (jh->b_transaction == transaction &&\n\t\t\t    jh->b_jlist != BJ_Metadata)\n\t\t\t\tpr_err(\"JBD2: assertion failure: h_type=%u \"\n\t\t\t\t       \"h_line_no=%u block_no=%llu jlist=%u\\n\",\n\t\t\t\t       handle->h_type, handle->h_line_no,\n\t\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t\t       jh->b_jlist);\n\t\t\tJ_ASSERT_JH(jh, jh->b_transaction != transaction ||\n\t\t\t\t\tjh->b_jlist == BJ_Metadata);\n\t\t\tspin_unlock(&jh->b_state_lock);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tjournal = transaction->t_journal;\n\tspin_lock(&jh->b_state_lock);\n\n\tif (jh->b_modified == 0) {\n\t\t/*\n\t\t * This buffer's got modified and becoming part\n\t\t * of the transaction. This needs to be done\n\t\t * once a transaction -bzzz\n\t\t */\n\t\tif (WARN_ON_ONCE(jbd2_handle_buffer_credits(handle) <= 0)) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out_unlock_bh;\n\t\t}\n\t\tjh->b_modified = 1;\n\t\thandle->h_total_credits--;\n\t}\n\n\t/*\n\t * fastpath, to avoid expensive locking.  If this buffer is already\n\t * on the running transaction's metadata list there is nothing to do.\n\t * Nobody can take it off again because there is a handle open.\n\t * I _think_ we're OK here with SMP barriers - a mistaken decision will\n\t * result in this test being false, so we go in and take the locks.\n\t */\n\tif (jh->b_transaction == transaction && jh->b_jlist == BJ_Metadata) {\n\t\tJBUFFER_TRACE(jh, \"fastpath\");\n\t\tif (unlikely(jh->b_transaction !=\n\t\t\t     journal->j_running_transaction)) {\n\t\t\tprintk(KERN_ERR \"JBD2: %s: \"\n\t\t\t       \"jh->b_transaction (%llu, %p, %u) != \"\n\t\t\t       \"journal->j_running_transaction (%p, %u)\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ? jh->b_transaction->t_tid : 0,\n\t\t\t       journal->j_running_transaction,\n\t\t\t       journal->j_running_transaction ?\n\t\t\t       journal->j_running_transaction->t_tid : 0);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tgoto out_unlock_bh;\n\t}\n\n\tset_buffer_jbddirty(bh);\n\n\t/*\n\t * Metadata already on the current transaction list doesn't\n\t * need to be filed.  Metadata on another transaction's list must\n\t * be committing, and will be refiled once the commit completes:\n\t * leave it alone for now.\n\t */\n\tif (jh->b_transaction != transaction) {\n\t\tJBUFFER_TRACE(jh, \"already on other transaction\");\n\t\tif (unlikely(((jh->b_transaction !=\n\t\t\t       journal->j_committing_transaction)) ||\n\t\t\t     (jh->b_next_transaction != transaction))) {\n\t\t\tprintk(KERN_ERR \"jbd2_journal_dirty_metadata: %s: \"\n\t\t\t       \"bad jh for block %llu: \"\n\t\t\t       \"transaction (%p, %u), \"\n\t\t\t       \"jh->b_transaction (%p, %u), \"\n\t\t\t       \"jh->b_next_transaction (%p, %u), jlist %u\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       transaction, transaction->t_tid,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ?\n\t\t\t       jh->b_transaction->t_tid : 0,\n\t\t\t       jh->b_next_transaction,\n\t\t\t       jh->b_next_transaction ?\n\t\t\t       jh->b_next_transaction->t_tid : 0,\n\t\t\t       jh->b_jlist);\n\t\t\tWARN_ON(1);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\t/* And this case is illegal: we can't reuse another\n\t\t * transaction's data buffer, ever. */\n\t\tgoto out_unlock_bh;\n\t}\n\n\t/* That test should have eliminated the following case: */\n\tJ_ASSERT_JH(jh, jh->b_frozen_data == NULL);\n\n\tJBUFFER_TRACE(jh, \"file as BJ_Metadata\");\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_file_buffer(jh, transaction, BJ_Metadata);\n\tspin_unlock(&journal->j_list_lock);\nout_unlock_bh:\n\tspin_unlock(&jh->b_state_lock);\nout:\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn ret;\n}\n\n/**\n * jbd2_journal_forget() - bforget() for potentially-journaled buffers.\n * @handle: transaction handle\n * @bh:     bh to 'forget'\n *\n * We can only do the bforget if there are no commits pending against the\n * buffer.  If the buffer is dirty in the current running transaction we\n * can safely unlink it.\n *\n * bh may not be a journalled buffer at all - it may be a non-JBD\n * buffer which came off the hashtable.  Check for this.\n *\n * Decrements bh->b_count by one.\n *\n * Allow this call even if the handle has aborted --- it may be part of\n * the caller's cleanup after an abort.\n */\nint jbd2_journal_forget(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh;\n\tint drop_reserve = 0;\n\tint err = 0;\n\tint was_modified = 0;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\n\tjh = jbd2_journal_grab_journal_head(bh);\n\tif (!jh) {\n\t\t__bforget(bh);\n\t\treturn 0;\n\t}\n\n\tspin_lock(&jh->b_state_lock);\n\n\t/* Critical error: attempting to delete a bitmap buffer, maybe?\n\t * Don't do any jbd operations, and return an error. */\n\tif (!J_EXPECT_JH(jh, !jh->b_committed_data,\n\t\t\t \"inconsistent data on disk\")) {\n\t\terr = -EIO;\n\t\tgoto drop;\n\t}\n\n\t/* keep track of whether or not this transaction modified us */\n\twas_modified = jh->b_modified;\n\n\t/*\n\t * The buffer's going from the transaction, we must drop\n\t * all references -bzzz\n\t */\n\tjh->b_modified = 0;\n\n\tif (jh->b_transaction == transaction) {\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\n\t\t/* If we are forgetting a buffer which is already part\n\t\t * of this transaction, then we can just drop it from\n\t\t * the transaction immediately. */\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_jbddirty(bh);\n\n\t\tJBUFFER_TRACE(jh, \"belongs to current transaction: unfile\");\n\n\t\t/*\n\t\t * we only want to drop a reference if this transaction\n\t\t * modified the buffer\n\t\t */\n\t\tif (was_modified)\n\t\t\tdrop_reserve = 1;\n\n\t\t/*\n\t\t * We are no longer going to journal this buffer.\n\t\t * However, the commit of this transaction is still\n\t\t * important to the buffer: the delete that we are now\n\t\t * processing might obsolete an old log entry, so by\n\t\t * committing, we can satisfy the buffer's checkpoint.\n\t\t *\n\t\t * So, if we have a checkpoint on the buffer, we should\n\t\t * now refile the buffer on our BJ_Forget list so that\n\t\t * we know to remove the checkpoint after we commit.\n\t\t */\n\n\t\tspin_lock(&journal->j_list_lock);\n\t\tif (jh->b_cp_transaction) {\n\t\t\t__jbd2_journal_temp_unlink_buffer(jh);\n\t\t\t__jbd2_journal_file_buffer(jh, transaction, BJ_Forget);\n\t\t} else {\n\t\t\t__jbd2_journal_unfile_buffer(jh);\n\t\t\tjbd2_journal_put_journal_head(jh);\n\t\t}\n\t\tspin_unlock(&journal->j_list_lock);\n\t} else if (jh->b_transaction) {\n\t\tJ_ASSERT_JH(jh, (jh->b_transaction ==\n\t\t\t\t journal->j_committing_transaction));\n\t\t/* However, if the buffer is still owned by a prior\n\t\t * (committing) transaction, we can't drop it yet... */\n\t\tJBUFFER_TRACE(jh, \"belongs to older transaction\");\n\t\t/* ... but we CAN drop it from the new transaction through\n\t\t * marking the buffer as freed and set j_next_transaction to\n\t\t * the new transaction, so that not only the commit code\n\t\t * knows it should clear dirty bits when it is done with the\n\t\t * buffer, but also the buffer can be checkpointed only\n\t\t * after the new transaction commits. */\n\n\t\tset_buffer_freed(bh);\n\n\t\tif (!jh->b_next_transaction) {\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tjh->b_next_transaction = transaction;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t} else {\n\t\t\tJ_ASSERT(jh->b_next_transaction == transaction);\n\n\t\t\t/*\n\t\t\t * only drop a reference if this transaction modified\n\t\t\t * the buffer\n\t\t\t */\n\t\t\tif (was_modified)\n\t\t\t\tdrop_reserve = 1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Finally, if the buffer is not belongs to any\n\t\t * transaction, we can just drop it now if it has no\n\t\t * checkpoint.\n\t\t */\n\t\tspin_lock(&journal->j_list_lock);\n\t\tif (!jh->b_cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"belongs to none transaction\");\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, if the buffer has been written to disk,\n\t\t * it is safe to remove the checkpoint and drop it.\n\t\t */\n\t\tif (!buffer_dirty(bh)) {\n\t\t\t__jbd2_journal_remove_checkpoint(jh);\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/*\n\t\t * The buffer is still not written to disk, we should\n\t\t * attach this buffer to current transaction so that the\n\t\t * buffer can be checkpointed only after the current\n\t\t * transaction commits.\n\t\t */\n\t\tclear_buffer_dirty(bh);\n\t\t__jbd2_journal_file_buffer(jh, transaction, BJ_Forget);\n\t\tspin_unlock(&journal->j_list_lock);\n\t}\ndrop:\n\t__brelse(bh);\n\tspin_unlock(&jh->b_state_lock);\n\tjbd2_journal_put_journal_head(jh);\n\tif (drop_reserve) {\n\t\t/* no need to reserve log space for this block -bzzz */\n\t\thandle->h_total_credits++;\n\t}\n\treturn err;\n}\n\n/**\n * jbd2_journal_stop() - complete a transaction\n * @handle: transaction to complete.\n *\n * All done for a particular handle.\n *\n * There is not much action needed here.  We just return any remaining\n * buffer credits to the transaction and remove the handle.  The only\n * complication is that we need to start a commit operation if the\n * filesystem is marked for synchronous update.\n *\n * jbd2_journal_stop itself will not usually return an error, but it may\n * do so in unusual circumstances.  In particular, expect it to\n * return -EIO if a jbd2_journal_abort has been executed since the\n * transaction began.\n */\nint jbd2_journal_stop(handle_t *handle)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tint err = 0, wait_for_commit = 0;\n\ttid_t tid;\n\tpid_t pid;\n\n\tif (--handle->h_ref > 0) {\n\t\tjbd_debug(4, \"h_ref %d -> %d\\n\", handle->h_ref + 1,\n\t\t\t\t\t\t handle->h_ref);\n\t\tif (is_handle_aborted(handle))\n\t\t\treturn -EIO;\n\t\treturn 0;\n\t}\n\tif (!transaction) {\n\t\t/*\n\t\t * Handle is already detached from the transaction so there is\n\t\t * nothing to do other than free the handle.\n\t\t */\n\t\tmemalloc_nofs_restore(handle->saved_alloc_context);\n\t\tgoto free_and_exit;\n\t}\n\tjournal = transaction->t_journal;\n\ttid = transaction->t_tid;\n\n\tif (is_handle_aborted(handle))\n\t\terr = -EIO;\n\n\tjbd_debug(4, \"Handle %p going down\\n\", handle);\n\ttrace_jbd2_handle_stats(journal->j_fs_dev->bd_dev,\n\t\t\t\ttid, handle->h_type, handle->h_line_no,\n\t\t\t\tjiffies - handle->h_start_jiffies,\n\t\t\t\thandle->h_sync, handle->h_requested_credits,\n\t\t\t\t(handle->h_requested_credits -\n\t\t\t\t handle->h_total_credits));\n\n\t/*\n\t * Implement synchronous transaction batching.  If the handle\n\t * was synchronous, don't force a commit immediately.  Let's\n\t * yield and let another thread piggyback onto this\n\t * transaction.  Keep doing that while new threads continue to\n\t * arrive.  It doesn't cost much - we're about to run a commit\n\t * and sleep on IO anyway.  Speeds up many-threaded, many-dir\n\t * operations by 30x or more...\n\t *\n\t * We try and optimize the sleep time against what the\n\t * underlying disk can do, instead of having a static sleep\n\t * time.  This is useful for the case where our storage is so\n\t * fast that it is more optimal to go ahead and force a flush\n\t * and wait for the transaction to be committed than it is to\n\t * wait for an arbitrary amount of time for new writers to\n\t * join the transaction.  We achieve this by measuring how\n\t * long it takes to commit a transaction, and compare it with\n\t * how long this transaction has been running, and if run time\n\t * < commit time then we sleep for the delta and commit.  This\n\t * greatly helps super fast disks that would see slowdowns as\n\t * more threads started doing fsyncs.\n\t *\n\t * But don't do this if this process was the most recent one\n\t * to perform a synchronous write.  We do this to detect the\n\t * case where a single process is doing a stream of sync\n\t * writes.  No point in waiting for joiners in that case.\n\t *\n\t * Setting max_batch_time to 0 disables this completely.\n\t */\n\tpid = current->pid;\n\tif (handle->h_sync && journal->j_last_sync_writer != pid &&\n\t    journal->j_max_batch_time) {\n\t\tu64 commit_time, trans_time;\n\n\t\tjournal->j_last_sync_writer = pid;\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tcommit_time = journal->j_average_commit_time;\n\t\tread_unlock(&journal->j_state_lock);\n\n\t\ttrans_time = ktime_to_ns(ktime_sub(ktime_get(),\n\t\t\t\t\t\t   transaction->t_start_time));\n\n\t\tcommit_time = max_t(u64, commit_time,\n\t\t\t\t    1000*journal->j_min_batch_time);\n\t\tcommit_time = min_t(u64, commit_time,\n\t\t\t\t    1000*journal->j_max_batch_time);\n\n\t\tif (trans_time < commit_time) {\n\t\t\tktime_t expires = ktime_add_ns(ktime_get(),\n\t\t\t\t\t\t       commit_time);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&expires, HRTIMER_MODE_ABS);\n\t\t}\n\t}\n\n\tif (handle->h_sync)\n\t\ttransaction->t_synchronous_commit = 1;\n\n\t/*\n\t * If the handle is marked SYNC, we need to set another commit\n\t * going!  We also want to force a commit if the transaction is too\n\t * old now.\n\t */\n\tif (handle->h_sync ||\n\t    time_after_eq(jiffies, transaction->t_expires)) {\n\t\t/* Do this even for aborted journals: an abort still\n\t\t * completes the commit thread, it just doesn't write\n\t\t * anything to disk. */\n\n\t\tjbd_debug(2, \"transaction too old, requesting commit for \"\n\t\t\t\t\t\"handle %p\\n\", handle);\n\t\t/* This is non-blocking */\n\t\tjbd2_log_start_commit(journal, tid);\n\n\t\t/*\n\t\t * Special case: JBD2_SYNC synchronous updates require us\n\t\t * to wait for the commit to complete.\n\t\t */\n\t\tif (handle->h_sync && !(current->flags & PF_MEMALLOC))\n\t\t\twait_for_commit = 1;\n\t}\n\n\t/*\n\t * Once stop_this_handle() drops t_updates, the transaction could start\n\t * committing on us and eventually disappear.  So we must not\n\t * dereference transaction pointer again after calling\n\t * stop_this_handle().\n\t */\n\tstop_this_handle(handle);\n\n\tif (wait_for_commit)\n\t\terr = jbd2_log_wait_commit(journal, tid);\n\nfree_and_exit:\n\tif (handle->h_rsv_handle)\n\t\tjbd2_free_handle(handle->h_rsv_handle);\n\tjbd2_free_handle(handle);\n\treturn err;\n}\n\n/*\n *\n * List management code snippets: various functions for manipulating the\n * transaction buffer lists.\n *\n */\n\n/*\n * Append a buffer to a transaction list, given the transaction's list head\n * pointer.\n *\n * j_list_lock is held.\n *\n * jh->b_state_lock is held.\n */\n\nstatic inline void\n__blist_add_buffer(struct journal_head **list, struct journal_head *jh)\n{\n\tif (!*list) {\n\t\tjh->b_tnext = jh->b_tprev = jh;\n\t\t*list = jh;\n\t} else {\n\t\t/* Insert at the tail of the list to preserve order */\n\t\tstruct journal_head *first = *list, *last = first->b_tprev;\n\t\tjh->b_tprev = last;\n\t\tjh->b_tnext = first;\n\t\tlast->b_tnext = first->b_tprev = jh;\n\t}\n}\n\n/*\n * Remove a buffer from a transaction list, given the transaction's list\n * head pointer.\n *\n * Called with j_list_lock held, and the journal may not be locked.\n *\n * jh->b_state_lock is held.\n */\n\nstatic inline void\n__blist_del_buffer(struct journal_head **list, struct journal_head *jh)\n{\n\tif (*list == jh) {\n\t\t*list = jh->b_tnext;\n\t\tif (*list == jh)\n\t\t\t*list = NULL;\n\t}\n\tjh->b_tprev->b_tnext = jh->b_tnext;\n\tjh->b_tnext->b_tprev = jh->b_tprev;\n}\n\n/*\n * Remove a buffer from the appropriate transaction list.\n *\n * Note that this function can *change* the value of\n * bh->b_transaction->t_buffers, t_forget, t_shadow_list, t_log_list or\n * t_reserved_list.  If the caller is holding onto a copy of one of these\n * pointers, it could go bad.  Generally the caller needs to re-read the\n * pointer from the transaction_t.\n *\n * Called under j_list_lock.\n */\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh)\n{\n\tstruct journal_head **list = NULL;\n\ttransaction_t *transaction;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tlockdep_assert_held(&jh->b_state_lock);\n\ttransaction = jh->b_transaction;\n\tif (transaction)\n\t\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tif (jh->b_jlist != BJ_None)\n\t\tJ_ASSERT_JH(jh, transaction != NULL);\n\n\tswitch (jh->b_jlist) {\n\tcase BJ_None:\n\t\treturn;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers--;\n\t\tJ_ASSERT_JH(jh, transaction->t_nr_buffers >= 0);\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\t}\n\n\t__blist_del_buffer(list, jh);\n\tjh->b_jlist = BJ_None;\n\tif (transaction && is_journal_aborted(transaction->t_journal))\n\t\tclear_buffer_jbddirty(bh);\n\telse if (test_clear_buffer_jbddirty(bh))\n\t\tmark_buffer_dirty(bh);\t/* Expose it to the VM */\n}\n\n/*\n * Remove buffer from all transactions. The caller is responsible for dropping\n * the jh reference that belonged to the transaction.\n *\n * Called with bh_state lock and j_list_lock\n */\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh)\n{\n\tJ_ASSERT_JH(jh, jh->b_transaction != NULL);\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\n\t__jbd2_journal_temp_unlink_buffer(jh);\n\tjh->b_transaction = NULL;\n}\n\nvoid jbd2_journal_unfile_buffer(journal_t *journal, struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\t/* Get reference so that buffer cannot be freed before we unlock it */\n\tget_bh(bh);\n\tspin_lock(&jh->b_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_unfile_buffer(jh);\n\tspin_unlock(&journal->j_list_lock);\n\tspin_unlock(&jh->b_state_lock);\n\tjbd2_journal_put_journal_head(jh);\n\t__brelse(bh);\n}\n\n/*\n * Called from jbd2_journal_try_to_free_buffers().\n *\n * Called under jh->b_state_lock\n */\nstatic void\n__journal_try_to_free_buffer(journal_t *journal, struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\n\tjh = bh2jh(bh);\n\n\tif (buffer_locked(bh) || buffer_dirty(bh))\n\t\tgoto out;\n\n\tif (jh->b_next_transaction != NULL || jh->b_transaction != NULL)\n\t\tgoto out;\n\n\tspin_lock(&journal->j_list_lock);\n\tif (jh->b_cp_transaction != NULL) {\n\t\t/* written-back checkpointed metadata buffer */\n\t\tJBUFFER_TRACE(jh, \"remove from checkpoint list\");\n\t\t__jbd2_journal_remove_checkpoint(jh);\n\t}\n\tspin_unlock(&journal->j_list_lock);\nout:\n\treturn;\n}\n\n/**\n * jbd2_journal_try_to_free_buffers() - try to free page buffers.\n * @journal: journal for operation\n * @page: to try and free\n *\n * For all the buffers on this page,\n * if they are fully written out ordered data, move them onto BUF_CLEAN\n * so try_to_free_buffers() can reap them.\n *\n * This function returns non-zero if we wish try_to_free_buffers()\n * to be called. We do this if the page is releasable by try_to_free_buffers().\n * We also do it if the page has locked or dirty buffers and the caller wants\n * us to perform sync or async writeout.\n *\n * This complicates JBD locking somewhat.  We aren't protected by the\n * BKL here.  We wish to remove the buffer from its committing or\n * running transaction's ->t_datalist via __jbd2_journal_unfile_buffer.\n *\n * This may *change* the value of transaction_t->t_datalist, so anyone\n * who looks at t_datalist needs to lock against this function.\n *\n * Even worse, someone may be doing a jbd2_journal_dirty_data on this\n * buffer.  So we need to lock against that.  jbd2_journal_dirty_data()\n * will come out of the lock with the buffer dirty, which makes it\n * ineligible for release here.\n *\n * Who else is affected by this?  hmm...  Really the only contender\n * is do_get_write_access() - it could be looking at the buffer while\n * journal_try_to_free_buffer() is changing its state.  But that\n * cannot happen because we never reallocate freed data as metadata\n * while the data is part of a transaction.  Yes?\n *\n * Return 0 on failure, 1 on success\n */\nint jbd2_journal_try_to_free_buffers(journal_t *journal, struct page *page)\n{\n\tstruct buffer_head *head;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tJ_ASSERT(PageLocked(page));\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tstruct journal_head *jh;\n\n\t\t/*\n\t\t * We take our own ref against the journal_head here to avoid\n\t\t * having to add tons of locking around each instance of\n\t\t * jbd2_journal_put_journal_head().\n\t\t */\n\t\tjh = jbd2_journal_grab_journal_head(bh);\n\t\tif (!jh)\n\t\t\tcontinue;\n\n\t\tspin_lock(&jh->b_state_lock);\n\t\t__journal_try_to_free_buffer(journal, bh);\n\t\tspin_unlock(&jh->b_state_lock);\n\t\tjbd2_journal_put_journal_head(jh);\n\t\tif (buffer_jbd(bh))\n\t\t\tgoto busy;\n\t} while ((bh = bh->b_this_page) != head);\n\n\tret = try_to_free_buffers(page);\nbusy:\n\treturn ret;\n}\n\n/*\n * This buffer is no longer needed.  If it is on an older transaction's\n * checkpoint list we need to record it on this transaction's forget list\n * to pin this buffer (and hence its checkpointing transaction) down until\n * this transaction commits.  If the buffer isn't on a checkpoint list, we\n * release it.\n * Returns non-zero if JBD no longer has an interest in the buffer.\n *\n * Called under j_list_lock.\n *\n * Called under jh->b_state_lock.\n */\nstatic int __dispose_buffer(struct journal_head *jh, transaction_t *transaction)\n{\n\tint may_free = 1;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tif (jh->b_cp_transaction) {\n\t\tJBUFFER_TRACE(jh, \"on running+cp transaction\");\n\t\t__jbd2_journal_temp_unlink_buffer(jh);\n\t\t/*\n\t\t * We don't want to write the buffer anymore, clear the\n\t\t * bit so that we don't confuse checks in\n\t\t * __journal_file_buffer\n\t\t */\n\t\tclear_buffer_dirty(bh);\n\t\t__jbd2_journal_file_buffer(jh, transaction, BJ_Forget);\n\t\tmay_free = 0;\n\t} else {\n\t\tJBUFFER_TRACE(jh, \"on running transaction\");\n\t\t__jbd2_journal_unfile_buffer(jh);\n\t\tjbd2_journal_put_journal_head(jh);\n\t}\n\treturn may_free;\n}\n\n/*\n * jbd2_journal_invalidatepage\n *\n * This code is tricky.  It has a number of cases to deal with.\n *\n * There are two invariants which this code relies on:\n *\n * i_size must be updated on disk before we start calling invalidatepage on the\n * data.\n *\n *  This is done in ext3 by defining an ext3_setattr method which\n *  updates i_size before truncate gets going.  By maintaining this\n *  invariant, we can be sure that it is safe to throw away any buffers\n *  attached to the current transaction: once the transaction commits,\n *  we know that the data will not be needed.\n *\n *  Note however that we can *not* throw away data belonging to the\n *  previous, committing transaction!\n *\n * Any disk blocks which *are* part of the previous, committing\n * transaction (and which therefore cannot be discarded immediately) are\n * not going to be reused in the new running transaction\n *\n *  The bitmap committed_data images guarantee this: any block which is\n *  allocated in one transaction and removed in the next will be marked\n *  as in-use in the committed_data bitmap, so cannot be reused until\n *  the next transaction to delete the block commits.  This means that\n *  leaving committing buffers dirty is quite safe: the disk blocks\n *  cannot be reallocated to a different file and so buffer aliasing is\n *  not possible.\n *\n *\n * The above applies mainly to ordered data mode.  In writeback mode we\n * don't make guarantees about the order in which data hits disk --- in\n * particular we don't guarantee that new dirty data is flushed before\n * transaction commit --- so it is always safe just to discard data\n * immediately in that mode.  --sct\n */\n\n/*\n * The journal_unmap_buffer helper function returns zero if the buffer\n * concerned remains pinned as an anonymous buffer belonging to an older\n * transaction.\n *\n * We're outside-transaction here.  Either or both of j_running_transaction\n * and j_committing_transaction may be NULL.\n */\nstatic int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh,\n\t\t\t\tint partial_page)\n{\n\ttransaction_t *transaction;\n\tstruct journal_head *jh;\n\tint may_free = 1;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\n\t/*\n\t * It is safe to proceed here without the j_list_lock because the\n\t * buffers cannot be stolen by try_to_free_buffers as long as we are\n\t * holding the page lock. --sct\n\t */\n\n\tjh = jbd2_journal_grab_journal_head(bh);\n\tif (!jh)\n\t\tgoto zap_buffer_unlocked;\n\n\t/* OK, we have data buffer in journaled mode */\n\twrite_lock(&journal->j_state_lock);\n\tspin_lock(&jh->b_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\n\t/*\n\t * We cannot remove the buffer from checkpoint lists until the\n\t * transaction adding inode to orphan list (let's call it T)\n\t * is committed.  Otherwise if the transaction changing the\n\t * buffer would be cleaned from the journal before T is\n\t * committed, a crash will cause that the correct contents of\n\t * the buffer will be lost.  On the other hand we have to\n\t * clear the buffer dirty bit at latest at the moment when the\n\t * transaction marking the buffer as freed in the filesystem\n\t * structures is committed because from that moment on the\n\t * block can be reallocated and used by a different page.\n\t * Since the block hasn't been freed yet but the inode has\n\t * already been added to orphan list, it is safe for us to add\n\t * the buffer to BJ_Forget list of the newest transaction.\n\t *\n\t * Also we have to clear buffer_mapped flag of a truncated buffer\n\t * because the buffer_head may be attached to the page straddling\n\t * i_size (can happen only when blocksize < pagesize) and thus the\n\t * buffer_head can be reused when the file is extended again. So we end\n\t * up keeping around invalidated buffers attached to transactions'\n\t * BJ_Forget list just to stop checkpointing code from cleaning up\n\t * the transaction this buffer was modified in.\n\t */\n\ttransaction = jh->b_transaction;\n\tif (transaction == NULL) {\n\t\t/* First case: not on any transaction.  If it\n\t\t * has no checkpoint link, then we can zap it:\n\t\t * it's a writeback-mode buffer so we don't care\n\t\t * if it hits disk safely. */\n\t\tif (!jh->b_cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"not on any transaction: zap\");\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\tif (!buffer_dirty(bh)) {\n\t\t\t/* bdflush has written it.  We can drop it now */\n\t\t\t__jbd2_journal_remove_checkpoint(jh);\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\t/* OK, it must be in the journal but still not\n\t\t * written fully to disk: it's metadata or\n\t\t * journaled data... */\n\n\t\tif (journal->j_running_transaction) {\n\t\t\t/* ... and once the current transaction has\n\t\t\t * committed, the buffer won't be needed any\n\t\t\t * longer. */\n\t\t\tJBUFFER_TRACE(jh, \"checkpointed: add to BJ_Forget\");\n\t\t\tmay_free = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_running_transaction);\n\t\t\tgoto zap_buffer;\n\t\t} else {\n\t\t\t/* There is no currently-running transaction. So the\n\t\t\t * orphan record which we wrote for this file must have\n\t\t\t * passed into commit.  We must attach this buffer to\n\t\t\t * the committing transaction, if it exists. */\n\t\t\tif (journal->j_committing_transaction) {\n\t\t\t\tJBUFFER_TRACE(jh, \"give to committing trans\");\n\t\t\t\tmay_free = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\t\t\tgoto zap_buffer;\n\t\t\t} else {\n\t\t\t\t/* The orphan record's transaction has\n\t\t\t\t * committed.  We can cleanse this buffer */\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\t__jbd2_journal_remove_checkpoint(jh);\n\t\t\t\tgoto zap_buffer;\n\t\t\t}\n\t\t}\n\t} else if (transaction == journal->j_committing_transaction) {\n\t\tJBUFFER_TRACE(jh, \"on committing transaction\");\n\t\t/*\n\t\t * The buffer is committing, we simply cannot touch\n\t\t * it. If the page is straddling i_size we have to wait\n\t\t * for commit and try again.\n\t\t */\n\t\tif (partial_page) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tspin_unlock(&jh->b_state_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tjbd2_journal_put_journal_head(jh);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t/*\n\t\t * OK, buffer won't be reachable after truncate. We just clear\n\t\t * b_modified to not confuse transaction credit accounting, and\n\t\t * set j_next_transaction to the running transaction (if there\n\t\t * is one) and mark buffer as freed so that commit code knows\n\t\t * it should clear dirty bits when it is done with the buffer.\n\t\t */\n\t\tset_buffer_freed(bh);\n\t\tif (journal->j_running_transaction && buffer_jbddirty(bh))\n\t\t\tjh->b_next_transaction = journal->j_running_transaction;\n\t\tjh->b_modified = 0;\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tspin_unlock(&jh->b_state_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_journal_put_journal_head(jh);\n\t\treturn 0;\n\t} else {\n\t\t/* Good, the buffer belongs to the running transaction.\n\t\t * We are writing our own transaction's data, not any\n\t\t * previous one's, so it is safe to throw it away\n\t\t * (remember that we expect the filesystem to have set\n\t\t * i_size already for this truncate so recovery will not\n\t\t * expose the disk blocks we are discarding here.) */\n\t\tJ_ASSERT_JH(jh, transaction == journal->j_running_transaction);\n\t\tJBUFFER_TRACE(jh, \"on running transaction\");\n\t\tmay_free = __dispose_buffer(jh, transaction);\n\t}\n\nzap_buffer:\n\t/*\n\t * This is tricky. Although the buffer is truncated, it may be reused\n\t * if blocksize < pagesize and it is attached to the page straddling\n\t * EOF. Since the buffer might have been added to BJ_Forget list of the\n\t * running transaction, journal_get_write_access() won't clear\n\t * b_modified and credit accounting gets confused. So clear b_modified\n\t * here.\n\t */\n\tjh->b_modified = 0;\n\tspin_unlock(&journal->j_list_lock);\n\tspin_unlock(&jh->b_state_lock);\n\twrite_unlock(&journal->j_state_lock);\n\tjbd2_journal_put_journal_head(jh);\nzap_buffer_unlocked:\n\tclear_buffer_dirty(bh);\n\tJ_ASSERT_BH(bh, !buffer_jbddirty(bh));\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tclear_buffer_delay(bh);\n\tclear_buffer_unwritten(bh);\n\tbh->b_bdev = NULL;\n\treturn may_free;\n}\n\n/**\n * jbd2_journal_invalidatepage()\n * @journal: journal to use for flush...\n * @page:    page to flush\n * @offset:  start of the range to invalidate\n * @length:  length of the range to invalidate\n *\n * Reap page buffers containing data after in the specified range in page.\n * Can return -EBUSY if buffers are part of the committing transaction and\n * the page is straddling i_size. Caller then has to wait for current commit\n * and try again.\n */\nint jbd2_journal_invalidatepage(journal_t *journal,\n\t\t\t\tstruct page *page,\n\t\t\t\tunsigned int offset,\n\t\t\t\tunsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tunsigned int stop = offset + length;\n\tunsigned int curr_off = 0;\n\tint partial_page = (offset || length < PAGE_SIZE);\n\tint may_free = 1;\n\tint ret = 0;\n\n\tif (!PageLocked(page))\n\t\tBUG();\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\n\tBUG_ON(stop > PAGE_SIZE || stop < length);\n\n\t/* We will potentially be playing with lists other than just the\n\t * data lists (especially for journaled data mode), so be\n\t * cautious in our locking. */\n\n\thead = bh = page_buffers(page);\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\tif (next_off > stop)\n\t\t\treturn 0;\n\n\t\tif (offset <= curr_off) {\n\t\t\t/* This block is wholly outside the truncation point */\n\t\t\tlock_buffer(bh);\n\t\t\tret = journal_unmap_buffer(journal, bh, partial_page);\n\t\t\tunlock_buffer(bh);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tmay_free &= ret;\n\t\t}\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\n\t} while (bh != head);\n\n\tif (!partial_page) {\n\t\tif (may_free && try_to_free_buffers(page))\n\t\t\tJ_ASSERT(!page_has_buffers(page));\n\t}\n\treturn 0;\n}\n\n/*\n * File a buffer on the given transaction list.\n */\nvoid __jbd2_journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tlockdep_assert_held(&jh->b_state_lock);\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__jbd2_journal_temp_unlink_buffer(jh);\n\telse\n\t\tjbd2_journal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}\n\nvoid jbd2_journal_file_buffer(struct journal_head *jh,\n\t\t\t\ttransaction_t *transaction, int jlist)\n{\n\tspin_lock(&jh->b_state_lock);\n\tspin_lock(&transaction->t_journal->j_list_lock);\n\t__jbd2_journal_file_buffer(jh, transaction, jlist);\n\tspin_unlock(&transaction->t_journal->j_list_lock);\n\tspin_unlock(&jh->b_state_lock);\n}\n\n/*\n * Remove a buffer from its current buffer list in preparation for\n * dropping it from its current transaction entirely.  If the buffer has\n * already started to be used by a subsequent transaction, refile the\n * buffer on that transaction's metadata list.\n *\n * Called under j_list_lock\n * Called under jh->b_state_lock\n *\n * When this function returns true, there's no next transaction to refile to\n * and the caller has to drop jh reference through\n * jbd2_journal_put_journal_head().\n */\nbool __jbd2_journal_refile_buffer(struct journal_head *jh)\n{\n\tint was_dirty, jlist;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tlockdep_assert_held(&jh->b_state_lock);\n\tif (jh->b_transaction)\n\t\tassert_spin_locked(&jh->b_transaction->t_journal->j_list_lock);\n\n\t/* If the buffer is now unused, just drop it. */\n\tif (jh->b_next_transaction == NULL) {\n\t\t__jbd2_journal_unfile_buffer(jh);\n\t\treturn true;\n\t}\n\n\t/*\n\t * It has been modified by a later transaction: add it to the new\n\t * transaction's metadata list.\n\t */\n\n\twas_dirty = test_clear_buffer_jbddirty(bh);\n\t__jbd2_journal_temp_unlink_buffer(jh);\n\n\t/*\n\t * b_transaction must be set, otherwise the new b_transaction won't\n\t * be holding jh reference\n\t */\n\tJ_ASSERT_JH(jh, jh->b_transaction != NULL);\n\n\t/*\n\t * We set b_transaction here because b_next_transaction will inherit\n\t * our jh reference and thus __jbd2_journal_file_buffer() must not\n\t * take a new one.\n\t */\n\tWRITE_ONCE(jh->b_transaction, jh->b_next_transaction);\n\tWRITE_ONCE(jh->b_next_transaction, NULL);\n\tif (buffer_freed(bh))\n\t\tjlist = BJ_Forget;\n\telse if (jh->b_modified)\n\t\tjlist = BJ_Metadata;\n\telse\n\t\tjlist = BJ_Reserved;\n\t__jbd2_journal_file_buffer(jh, jh->b_transaction, jlist);\n\tJ_ASSERT_JH(jh, jh->b_transaction->t_state == T_RUNNING);\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n\treturn false;\n}\n\n/*\n * __jbd2_journal_refile_buffer() with necessary locking added. We take our\n * bh reference so that we can safely unlock bh.\n *\n * The jh and bh may be freed by this call.\n */\nvoid jbd2_journal_refile_buffer(journal_t *journal, struct journal_head *jh)\n{\n\tbool drop;\n\n\tspin_lock(&jh->b_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\tdrop = __jbd2_journal_refile_buffer(jh);\n\tspin_unlock(&jh->b_state_lock);\n\tspin_unlock(&journal->j_list_lock);\n\tif (drop)\n\t\tjbd2_journal_put_journal_head(jh);\n}\n\n/*\n * File inode in the inode list of the handle's transaction\n */\nstatic int jbd2_journal_file_inode(handle_t *handle, struct jbd2_inode *jinode,\n\t\tunsigned long flags, loff_t start_byte, loff_t end_byte)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\n\tjbd_debug(4, \"Adding inode %lu, tid:%d\\n\", jinode->i_vfs_inode->i_ino,\n\t\t\ttransaction->t_tid);\n\n\tspin_lock(&journal->j_list_lock);\n\tjinode->i_flags |= flags;\n\n\tif (jinode->i_dirty_end) {\n\t\tjinode->i_dirty_start = min(jinode->i_dirty_start, start_byte);\n\t\tjinode->i_dirty_end = max(jinode->i_dirty_end, end_byte);\n\t} else {\n\t\tjinode->i_dirty_start = start_byte;\n\t\tjinode->i_dirty_end = end_byte;\n\t}\n\n\t/* Is inode already attached where we need it? */\n\tif (jinode->i_transaction == transaction ||\n\t    jinode->i_next_transaction == transaction)\n\t\tgoto done;\n\n\t/*\n\t * We only ever set this variable to 1 so the test is safe. Since\n\t * t_need_data_flush is likely to be set, we do the test to save some\n\t * cacheline bouncing\n\t */\n\tif (!transaction->t_need_data_flush)\n\t\ttransaction->t_need_data_flush = 1;\n\t/* On some different transaction's list - should be\n\t * the committing one */\n\tif (jinode->i_transaction) {\n\t\tJ_ASSERT(jinode->i_next_transaction == NULL);\n\t\tJ_ASSERT(jinode->i_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\tjinode->i_next_transaction = transaction;\n\t\tgoto done;\n\t}\n\t/* Not on any transaction list... */\n\tJ_ASSERT(!jinode->i_next_transaction);\n\tjinode->i_transaction = transaction;\n\tlist_add(&jinode->i_list, &transaction->t_inode_list);\ndone:\n\tspin_unlock(&journal->j_list_lock);\n\n\treturn 0;\n}\n\nint jbd2_journal_inode_ranged_write(handle_t *handle,\n\t\tstruct jbd2_inode *jinode, loff_t start_byte, loff_t length)\n{\n\treturn jbd2_journal_file_inode(handle, jinode,\n\t\t\tJI_WRITE_DATA | JI_WAIT_DATA, start_byte,\n\t\t\tstart_byte + length - 1);\n}\n\nint jbd2_journal_inode_ranged_wait(handle_t *handle, struct jbd2_inode *jinode,\n\t\tloff_t start_byte, loff_t length)\n{\n\treturn jbd2_journal_file_inode(handle, jinode, JI_WAIT_DATA,\n\t\t\tstart_byte, start_byte + length - 1);\n}\n\n/*\n * File truncate and transaction commit interact with each other in a\n * non-trivial way.  If a transaction writing data block A is\n * committing, we cannot discard the data by truncate until we have\n * written them.  Otherwise if we crashed after the transaction with\n * write has committed but before the transaction with truncate has\n * committed, we could see stale data in block A.  This function is a\n * helper to solve this problem.  It starts writeout of the truncated\n * part in case it is in the committing transaction.\n *\n * Filesystem code must call this function when inode is journaled in\n * ordered mode before truncation happens and after the inode has been\n * placed on orphan list with the new inode size. The second condition\n * avoids the race that someone writes new data and we start\n * committing the transaction after this function has been called but\n * before a transaction for truncate is started (and furthermore it\n * allows us to optimize the case where the addition to orphan list\n * happens in the same transaction as write --- we don't have to write\n * any data in such case).\n */\nint jbd2_journal_begin_ordered_truncate(journal_t *journal,\n\t\t\t\t\tstruct jbd2_inode *jinode,\n\t\t\t\t\tloff_t new_size)\n{\n\ttransaction_t *inode_trans, *commit_trans;\n\tint ret = 0;\n\n\t/* This is a quick check to avoid locking if not necessary */\n\tif (!jinode->i_transaction)\n\t\tgoto out;\n\t/* Locks are here just to force reading of recent values, it is\n\t * enough that the transaction was not committing before we started\n\t * a transaction adding the inode to orphan list */\n\tread_lock(&journal->j_state_lock);\n\tcommit_trans = journal->j_committing_transaction;\n\tread_unlock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\tinode_trans = jinode->i_transaction;\n\tspin_unlock(&journal->j_list_lock);\n\tif (inode_trans == commit_trans) {\n\t\tret = filemap_fdatawrite_range(jinode->i_vfs_inode->i_mapping,\n\t\t\tnew_size, LLONG_MAX);\n\t\tif (ret)\n\t\t\tjbd2_journal_abort(journal, ret);\n\t}\nout:\n\treturn ret;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0+\n/*\n * linux/fs/jbd2/transaction.c\n *\n * Written by Stephen C. Tweedie <sct@redhat.com>, 1998\n *\n * Copyright 1998 Red Hat corp --- All Rights Reserved\n *\n * Generic filesystem transaction handling code; part of the ext2fs\n * journaling system.\n *\n * This file manages transactions (compound commits managed by the\n * journaling code) and handles (individual atomic operations by the\n * filesystem).\n */\n\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/jbd2.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/hrtimer.h>\n#include <linux/backing-dev.h>\n#include <linux/bug.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n\n#include <trace/events/jbd2.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nstatic struct kmem_cache *transaction_cache;\nint __init jbd2_journal_init_transaction_cache(void)\n{\n\tJ_ASSERT(!transaction_cache);\n\ttransaction_cache = kmem_cache_create(\"jbd2_transaction_s\",\n\t\t\t\t\tsizeof(transaction_t),\n\t\t\t\t\t0,\n\t\t\t\t\tSLAB_HWCACHE_ALIGN|SLAB_TEMPORARY,\n\t\t\t\t\tNULL);\n\tif (!transaction_cache) {\n\t\tpr_emerg(\"JBD2: failed to create transaction cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nvoid jbd2_journal_destroy_transaction_cache(void)\n{\n\tkmem_cache_destroy(transaction_cache);\n\ttransaction_cache = NULL;\n}\n\nvoid jbd2_journal_free_transaction(transaction_t *transaction)\n{\n\tif (unlikely(ZERO_OR_NULL_PTR(transaction)))\n\t\treturn;\n\tkmem_cache_free(transaction_cache, transaction);\n}\n\n/*\n * Base amount of descriptor blocks we reserve for each transaction.\n */\nstatic int jbd2_descriptor_blocks_per_trans(journal_t *journal)\n{\n\tint tag_space = journal->j_blocksize - sizeof(journal_header_t);\n\tint tags_per_block;\n\n\t/* Subtract UUID */\n\ttag_space -= 16;\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\ttag_space -= sizeof(struct jbd2_journal_block_tail);\n\t/* Commit code leaves a slack space of 16 bytes at the end of block */\n\ttags_per_block = (tag_space - 16) / journal_tag_bytes(journal);\n\t/*\n\t * Revoke descriptors are accounted separately so we need to reserve\n\t * space for commit block and normal transaction descriptor blocks.\n\t */\n\treturn 1 + DIV_ROUND_UP(journal->j_max_transaction_buffers,\n\t\t\t\ttags_per_block);\n}\n\n/*\n * jbd2_get_transaction: obtain a new transaction_t object.\n *\n * Simply initialise a new transaction. Initialize it in\n * RUNNING state and add it to the current journal (which should not\n * have an existing running transaction: we only make a new transaction\n * once we have started to commit the old one).\n *\n * Preconditions:\n *\tThe journal MUST be locked.  We don't perform atomic mallocs on the\n *\tnew transaction\tand we can't block without protecting against other\n *\tprocesses trying to touch the journal while it is in transition.\n *\n */\n\nstatic void jbd2_get_transaction(journal_t *journal,\n\t\t\t\ttransaction_t *transaction)\n{\n\ttransaction->t_journal = journal;\n\ttransaction->t_state = T_RUNNING;\n\ttransaction->t_start_time = ktime_get();\n\ttransaction->t_tid = journal->j_transaction_sequence++;\n\ttransaction->t_expires = jiffies + journal->j_commit_interval;\n\tspin_lock_init(&transaction->t_handle_lock);\n\tatomic_set(&transaction->t_updates, 0);\n\tatomic_set(&transaction->t_outstanding_credits,\n\t\t   jbd2_descriptor_blocks_per_trans(journal) +\n\t\t   atomic_read(&journal->j_reserved_credits));\n\tatomic_set(&transaction->t_outstanding_revokes, 0);\n\tatomic_set(&transaction->t_handle_count, 0);\n\tINIT_LIST_HEAD(&transaction->t_inode_list);\n\tINIT_LIST_HEAD(&transaction->t_private_list);\n\n\t/* Set up the commit timer for the new transaction. */\n\tjournal->j_commit_timer.expires = round_jiffies_up(transaction->t_expires);\n\tadd_timer(&journal->j_commit_timer);\n\n\tJ_ASSERT(journal->j_running_transaction == NULL);\n\tjournal->j_running_transaction = transaction;\n\ttransaction->t_max_wait = 0;\n\ttransaction->t_start = jiffies;\n\ttransaction->t_requested = 0;\n}\n\n/*\n * Handle management.\n *\n * A handle_t is an object which represents a single atomic update to a\n * filesystem, and which tracks all of the modifications which form part\n * of that one update.\n */\n\n/*\n * Update transaction's maximum wait time, if debugging is enabled.\n *\n * In order for t_max_wait to be reliable, it must be protected by a\n * lock.  But doing so will mean that start_this_handle() can not be\n * run in parallel on SMP systems, which limits our scalability.  So\n * unless debugging is enabled, we no longer update t_max_wait, which\n * means that maximum wait time reported by the jbd2_run_stats\n * tracepoint will always be zero.\n */\nstatic inline void update_t_max_wait(transaction_t *transaction,\n\t\t\t\t     unsigned long ts)\n{\n#ifdef CONFIG_JBD2_DEBUG\n\tif (jbd2_journal_enable_debug &&\n\t    time_after(transaction->t_start, ts)) {\n\t\tts = jbd2_time_diff(ts, transaction->t_start);\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tif (ts > transaction->t_max_wait)\n\t\t\ttransaction->t_max_wait = ts;\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t}\n#endif\n}\n\n/*\n * Wait until running transaction passes to T_FLUSH state and new transaction\n * can thus be started. Also starts the commit if needed. The function expects\n * running transaction to exist and releases j_state_lock.\n */\nstatic void wait_transaction_locked(journal_t *journal)\n\t__releases(journal->j_state_lock)\n{\n\tDEFINE_WAIT(wait);\n\tint need_to_start;\n\ttid_t tid = journal->j_running_transaction->t_tid;\n\n\tprepare_to_wait(&journal->j_wait_transaction_locked, &wait,\n\t\t\tTASK_UNINTERRUPTIBLE);\n\tneed_to_start = !tid_geq(journal->j_commit_request, tid);\n\tread_unlock(&journal->j_state_lock);\n\tif (need_to_start)\n\t\tjbd2_log_start_commit(journal, tid);\n\tjbd2_might_wait_for_commit(journal);\n\tschedule();\n\tfinish_wait(&journal->j_wait_transaction_locked, &wait);\n}\n\n/*\n * Wait until running transaction transitions from T_SWITCH to T_FLUSH\n * state and new transaction can thus be started. The function releases\n * j_state_lock.\n */\nstatic void wait_transaction_switching(journal_t *journal)\n\t__releases(journal->j_state_lock)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (WARN_ON(!journal->j_running_transaction ||\n\t\t    journal->j_running_transaction->t_state != T_SWITCH)) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\treturn;\n\t}\n\tprepare_to_wait(&journal->j_wait_transaction_locked, &wait,\n\t\t\tTASK_UNINTERRUPTIBLE);\n\tread_unlock(&journal->j_state_lock);\n\t/*\n\t * We don't call jbd2_might_wait_for_commit() here as there's no\n\t * waiting for outstanding handles happening anymore in T_SWITCH state\n\t * and handling of reserved handles actually relies on that for\n\t * correctness.\n\t */\n\tschedule();\n\tfinish_wait(&journal->j_wait_transaction_locked, &wait);\n}\n\nstatic void sub_reserved_credits(journal_t *journal, int blocks)\n{\n\tatomic_sub(blocks, &journal->j_reserved_credits);\n\twake_up(&journal->j_wait_reserved);\n}\n\n/*\n * Wait until we can add credits for handle to the running transaction.  Called\n * with j_state_lock held for reading. Returns 0 if handle joined the running\n * transaction. Returns 1 if we had to wait, j_state_lock is dropped, and\n * caller must retry.\n *\n * Note: because j_state_lock may be dropped depending on the return\n * value, we need to fake out sparse so ti doesn't complain about a\n * locking imbalance.  Callers of add_transaction_credits will need to\n * make a similar accomodation.\n */\nstatic int add_transaction_credits(journal_t *journal, int blocks,\n\t\t\t\t   int rsv_blocks)\n__must_hold(&journal->j_state_lock)\n{\n\ttransaction_t *t = journal->j_running_transaction;\n\tint needed;\n\tint total = blocks + rsv_blocks;\n\n\t/*\n\t * If the current transaction is locked down for commit, wait\n\t * for the lock to be released.\n\t */\n\tif (t->t_state != T_RUNNING) {\n\t\tWARN_ON_ONCE(t->t_state >= T_FLUSH);\n\t\twait_transaction_locked(journal);\n\t\t__acquire(&journal->j_state_lock); /* fake out sparse */\n\t\treturn 1;\n\t}\n\n\t/*\n\t * If there is not enough space left in the log to write all\n\t * potential buffers requested by this operation, we need to\n\t * stall pending a log checkpoint to free some more log space.\n\t */\n\tneeded = atomic_add_return(total, &t->t_outstanding_credits);\n\tif (needed > journal->j_max_transaction_buffers) {\n\t\t/*\n\t\t * If the current transaction is already too large,\n\t\t * then start to commit it: we can then go back and\n\t\t * attach this handle to a new transaction.\n\t\t */\n\t\tatomic_sub(total, &t->t_outstanding_credits);\n\n\t\t/*\n\t\t * Is the number of reserved credits in the current transaction too\n\t\t * big to fit this handle? Wait until reserved credits are freed.\n\t\t */\n\t\tif (atomic_read(&journal->j_reserved_credits) + total >\n\t\t    journal->j_max_transaction_buffers) {\n\t\t\tread_unlock(&journal->j_state_lock);\n\t\t\tjbd2_might_wait_for_commit(journal);\n\t\t\twait_event(journal->j_wait_reserved,\n\t\t\t\t   atomic_read(&journal->j_reserved_credits) + total <=\n\t\t\t\t   journal->j_max_transaction_buffers);\n\t\t\t__acquire(&journal->j_state_lock); /* fake out sparse */\n\t\t\treturn 1;\n\t\t}\n\n\t\twait_transaction_locked(journal);\n\t\t__acquire(&journal->j_state_lock); /* fake out sparse */\n\t\treturn 1;\n\t}\n\n\t/*\n\t * The commit code assumes that it can get enough log space\n\t * without forcing a checkpoint.  This is *critical* for\n\t * correctness: a checkpoint of a buffer which is also\n\t * associated with a committing transaction creates a deadlock,\n\t * so commit simply cannot force through checkpoints.\n\t *\n\t * We must therefore ensure the necessary space in the journal\n\t * *before* starting to dirty potentially checkpointed buffers\n\t * in the new transaction.\n\t */\n\tif (jbd2_log_space_left(journal) < journal->j_max_transaction_buffers) {\n\t\tatomic_sub(total, &t->t_outstanding_credits);\n\t\tread_unlock(&journal->j_state_lock);\n\t\tjbd2_might_wait_for_commit(journal);\n\t\twrite_lock(&journal->j_state_lock);\n\t\tif (jbd2_log_space_left(journal) <\n\t\t\t\t\tjournal->j_max_transaction_buffers)\n\t\t\t__jbd2_log_wait_for_space(journal);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\t__acquire(&journal->j_state_lock); /* fake out sparse */\n\t\treturn 1;\n\t}\n\n\t/* No reservation? We are done... */\n\tif (!rsv_blocks)\n\t\treturn 0;\n\n\tneeded = atomic_add_return(rsv_blocks, &journal->j_reserved_credits);\n\t/* We allow at most half of a transaction to be reserved */\n\tif (needed > journal->j_max_transaction_buffers / 2) {\n\t\tsub_reserved_credits(journal, rsv_blocks);\n\t\tatomic_sub(total, &t->t_outstanding_credits);\n\t\tread_unlock(&journal->j_state_lock);\n\t\tjbd2_might_wait_for_commit(journal);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t atomic_read(&journal->j_reserved_credits) + rsv_blocks\n\t\t\t <= journal->j_max_transaction_buffers / 2);\n\t\t__acquire(&journal->j_state_lock); /* fake out sparse */\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * start_this_handle: Given a handle, deal with any locking or stalling\n * needed to make sure that there is enough journal space for the handle\n * to begin.  Attach the handle to a transaction and set up the\n * transaction's buffer credits.\n */\n\nstatic int start_this_handle(journal_t *journal, handle_t *handle,\n\t\t\t     gfp_t gfp_mask)\n{\n\ttransaction_t\t*transaction, *new_transaction = NULL;\n\tint\t\tblocks = handle->h_total_credits;\n\tint\t\trsv_blocks = 0;\n\tunsigned long ts = jiffies;\n\n\tif (handle->h_rsv_handle)\n\t\trsv_blocks = handle->h_rsv_handle->h_total_credits;\n\n\t/*\n\t * Limit the number of reserved credits to 1/2 of maximum transaction\n\t * size and limit the number of total credits to not exceed maximum\n\t * transaction size per operation.\n\t */\n\tif ((rsv_blocks > journal->j_max_transaction_buffers / 2) ||\n\t    (rsv_blocks + blocks > journal->j_max_transaction_buffers)) {\n\t\tprintk(KERN_ERR \"JBD2: %s wants too many credits \"\n\t\t       \"credits:%d rsv_credits:%d max:%d\\n\",\n\t\t       current->comm, blocks, rsv_blocks,\n\t\t       journal->j_max_transaction_buffers);\n\t\tWARN_ON(1);\n\t\treturn -ENOSPC;\n\t}\n\nalloc_transaction:\n\t/*\n\t * This check is racy but it is just an optimization of allocating new\n\t * transaction early if there are high chances we'll need it. If we\n\t * guess wrong, we'll retry or free unused transaction.\n\t */\n\tif (!data_race(journal->j_running_transaction)) {\n\t\t/*\n\t\t * If __GFP_FS is not present, then we may be being called from\n\t\t * inside the fs writeback layer, so we MUST NOT fail.\n\t\t */\n\t\tif ((gfp_mask & __GFP_FS) == 0)\n\t\t\tgfp_mask |= __GFP_NOFAIL;\n\t\tnew_transaction = kmem_cache_zalloc(transaction_cache,\n\t\t\t\t\t\t    gfp_mask);\n\t\tif (!new_transaction)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tjbd_debug(3, \"New handle %p going live.\\n\", handle);\n\n\t/*\n\t * We need to hold j_state_lock until t_updates has been incremented,\n\t * for proper journal barrier handling\n\t */\nrepeat:\n\tread_lock(&journal->j_state_lock);\n\tBUG_ON(journal->j_flags & JBD2_UNMOUNT);\n\tif (is_journal_aborted(journal) ||\n\t    (journal->j_errno != 0 && !(journal->j_flags & JBD2_ACK_ERR))) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\tjbd2_journal_free_transaction(new_transaction);\n\t\treturn -EROFS;\n\t}\n\n\t/*\n\t * Wait on the journal's transaction barrier if necessary. Specifically\n\t * we allow reserved handles to proceed because otherwise commit could\n\t * deadlock on page writeback not being able to complete.\n\t */\n\tif (!handle->h_reserved && journal->j_barrier_count) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_transaction_locked,\n\t\t\t\tjournal->j_barrier_count == 0);\n\t\tgoto repeat;\n\t}\n\n\tif (!journal->j_running_transaction) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\tif (!new_transaction)\n\t\t\tgoto alloc_transaction;\n\t\twrite_lock(&journal->j_state_lock);\n\t\tif (!journal->j_running_transaction &&\n\t\t    (handle->h_reserved || !journal->j_barrier_count)) {\n\t\t\tjbd2_get_transaction(journal, new_transaction);\n\t\t\tnew_transaction = NULL;\n\t\t}\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tgoto repeat;\n\t}\n\n\ttransaction = journal->j_running_transaction;\n\n\tif (!handle->h_reserved) {\n\t\t/* We may have dropped j_state_lock - restart in that case */\n\t\tif (add_transaction_credits(journal, blocks, rsv_blocks)) {\n\t\t\t/*\n\t\t\t * add_transaction_credits releases\n\t\t\t * j_state_lock on a non-zero return\n\t\t\t */\n\t\t\t__release(&journal->j_state_lock);\n\t\t\tgoto repeat;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We have handle reserved so we are allowed to join T_LOCKED\n\t\t * transaction and we don't have to check for transaction size\n\t\t * and journal space. But we still have to wait while running\n\t\t * transaction is being switched to a committing one as it\n\t\t * won't wait for any handles anymore.\n\t\t */\n\t\tif (transaction->t_state == T_SWITCH) {\n\t\t\twait_transaction_switching(journal);\n\t\t\tgoto repeat;\n\t\t}\n\t\tsub_reserved_credits(journal, blocks);\n\t\thandle->h_reserved = 0;\n\t}\n\n\t/* OK, account for the buffers that this operation expects to\n\t * use and add the handle to the running transaction.\n\t */\n\tupdate_t_max_wait(transaction, ts);\n\thandle->h_transaction = transaction;\n\thandle->h_requested_credits = blocks;\n\thandle->h_revoke_credits_requested = handle->h_revoke_credits;\n\thandle->h_start_jiffies = jiffies;\n\tatomic_inc(&transaction->t_updates);\n\tatomic_inc(&transaction->t_handle_count);\n\tjbd_debug(4, \"Handle %p given %d credits (total %d, free %lu)\\n\",\n\t\t  handle, blocks,\n\t\t  atomic_read(&transaction->t_outstanding_credits),\n\t\t  jbd2_log_space_left(journal));\n\tread_unlock(&journal->j_state_lock);\n\tcurrent->journal_info = handle;\n\n\trwsem_acquire_read(&journal->j_trans_commit_map, 0, 0, _THIS_IP_);\n\tjbd2_journal_free_transaction(new_transaction);\n\t/*\n\t * Ensure that no allocations done while the transaction is open are\n\t * going to recurse back to the fs layer.\n\t */\n\thandle->saved_alloc_context = memalloc_nofs_save();\n\treturn 0;\n}\n\n/* Allocate a new handle.  This should probably be in a slab... */\nstatic handle_t *new_handle(int nblocks)\n{\n\thandle_t *handle = jbd2_alloc_handle(GFP_NOFS);\n\tif (!handle)\n\t\treturn NULL;\n\thandle->h_total_credits = nblocks;\n\thandle->h_ref = 1;\n\n\treturn handle;\n}\n\nhandle_t *jbd2__journal_start(journal_t *journal, int nblocks, int rsv_blocks,\n\t\t\t      int revoke_records, gfp_t gfp_mask,\n\t\t\t      unsigned int type, unsigned int line_no)\n{\n\thandle_t *handle = journal_current_handle();\n\tint err;\n\n\tif (!journal)\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (handle) {\n\t\tJ_ASSERT(handle->h_transaction->t_journal == journal);\n\t\thandle->h_ref++;\n\t\treturn handle;\n\t}\n\n\tnblocks += DIV_ROUND_UP(revoke_records,\n\t\t\t\tjournal->j_revoke_records_per_block);\n\thandle = new_handle(nblocks);\n\tif (!handle)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (rsv_blocks) {\n\t\thandle_t *rsv_handle;\n\n\t\trsv_handle = new_handle(rsv_blocks);\n\t\tif (!rsv_handle) {\n\t\t\tjbd2_free_handle(handle);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\trsv_handle->h_reserved = 1;\n\t\trsv_handle->h_journal = journal;\n\t\thandle->h_rsv_handle = rsv_handle;\n\t}\n\thandle->h_revoke_credits = revoke_records;\n\n\terr = start_this_handle(journal, handle, gfp_mask);\n\tif (err < 0) {\n\t\tif (handle->h_rsv_handle)\n\t\t\tjbd2_free_handle(handle->h_rsv_handle);\n\t\tjbd2_free_handle(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\thandle->h_type = type;\n\thandle->h_line_no = line_no;\n\ttrace_jbd2_handle_start(journal->j_fs_dev->bd_dev,\n\t\t\t\thandle->h_transaction->t_tid, type,\n\t\t\t\tline_no, nblocks);\n\n\treturn handle;\n}\nEXPORT_SYMBOL(jbd2__journal_start);\n\n\n/**\n * jbd2_journal_start() - Obtain a new handle.\n * @journal: Journal to start transaction on.\n * @nblocks: number of block buffer we might modify\n *\n * We make sure that the transaction can guarantee at least nblocks of\n * modified buffers in the log.  We block until the log can guarantee\n * that much space. Additionally, if rsv_blocks > 0, we also create another\n * handle with rsv_blocks reserved blocks in the journal. This handle is\n * stored in h_rsv_handle. It is not attached to any particular transaction\n * and thus doesn't block transaction commit. If the caller uses this reserved\n * handle, it has to set h_rsv_handle to NULL as otherwise jbd2_journal_stop()\n * on the parent handle will dispose the reserved one. Reserved handle has to\n * be converted to a normal handle using jbd2_journal_start_reserved() before\n * it can be used.\n *\n * Return a pointer to a newly allocated handle, or an ERR_PTR() value\n * on failure.\n */\nhandle_t *jbd2_journal_start(journal_t *journal, int nblocks)\n{\n\treturn jbd2__journal_start(journal, nblocks, 0, 0, GFP_NOFS, 0, 0);\n}\nEXPORT_SYMBOL(jbd2_journal_start);\n\nstatic void __jbd2_journal_unreserve_handle(handle_t *handle, transaction_t *t)\n{\n\tjournal_t *journal = handle->h_journal;\n\n\tWARN_ON(!handle->h_reserved);\n\tsub_reserved_credits(journal, handle->h_total_credits);\n\tif (t)\n\t\tatomic_sub(handle->h_total_credits, &t->t_outstanding_credits);\n}\n\nvoid jbd2_journal_free_reserved(handle_t *handle)\n{\n\tjournal_t *journal = handle->h_journal;\n\n\t/* Get j_state_lock to pin running transaction if it exists */\n\tread_lock(&journal->j_state_lock);\n\t__jbd2_journal_unreserve_handle(handle, journal->j_running_transaction);\n\tread_unlock(&journal->j_state_lock);\n\tjbd2_free_handle(handle);\n}\nEXPORT_SYMBOL(jbd2_journal_free_reserved);\n\n/**\n * jbd2_journal_start_reserved() - start reserved handle\n * @handle: handle to start\n * @type: for handle statistics\n * @line_no: for handle statistics\n *\n * Start handle that has been previously reserved with jbd2_journal_reserve().\n * This attaches @handle to the running transaction (or creates one if there's\n * not transaction running). Unlike jbd2_journal_start() this function cannot\n * block on journal commit, checkpointing, or similar stuff. It can block on\n * memory allocation or frozen journal though.\n *\n * Return 0 on success, non-zero on error - handle is freed in that case.\n */\nint jbd2_journal_start_reserved(handle_t *handle, unsigned int type,\n\t\t\t\tunsigned int line_no)\n{\n\tjournal_t *journal = handle->h_journal;\n\tint ret = -EIO;\n\n\tif (WARN_ON(!handle->h_reserved)) {\n\t\t/* Someone passed in normal handle? Just stop it. */\n\t\tjbd2_journal_stop(handle);\n\t\treturn ret;\n\t}\n\t/*\n\t * Usefulness of mixing of reserved and unreserved handles is\n\t * questionable. So far nobody seems to need it so just error out.\n\t */\n\tif (WARN_ON(current->journal_info)) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ret;\n\t}\n\n\thandle->h_journal = NULL;\n\t/*\n\t * GFP_NOFS is here because callers are likely from writeback or\n\t * similarly constrained call sites\n\t */\n\tret = start_this_handle(journal, handle, GFP_NOFS);\n\tif (ret < 0) {\n\t\thandle->h_journal = journal;\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ret;\n\t}\n\thandle->h_type = type;\n\thandle->h_line_no = line_no;\n\ttrace_jbd2_handle_start(journal->j_fs_dev->bd_dev,\n\t\t\t\thandle->h_transaction->t_tid, type,\n\t\t\t\tline_no, handle->h_total_credits);\n\treturn 0;\n}\nEXPORT_SYMBOL(jbd2_journal_start_reserved);\n\n/**\n * jbd2_journal_extend() - extend buffer credits.\n * @handle:  handle to 'extend'\n * @nblocks: nr blocks to try to extend by.\n * @revoke_records: number of revoke records to try to extend by.\n *\n * Some transactions, such as large extends and truncates, can be done\n * atomically all at once or in several stages.  The operation requests\n * a credit for a number of buffer modifications in advance, but can\n * extend its credit if it needs more.\n *\n * jbd2_journal_extend tries to give the running handle more buffer credits.\n * It does not guarantee that allocation - this is a best-effort only.\n * The calling process MUST be able to deal cleanly with a failure to\n * extend here.\n *\n * Return 0 on success, non-zero on failure.\n *\n * return code < 0 implies an error\n * return code > 0 implies normal transaction-full status.\n */\nint jbd2_journal_extend(handle_t *handle, int nblocks, int revoke_records)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tint result;\n\tint wanted;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\n\tresult = 1;\n\n\tread_lock(&journal->j_state_lock);\n\n\t/* Don't extend a locked-down transaction! */\n\tif (transaction->t_state != T_RUNNING) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction not running\\n\", handle, nblocks);\n\t\tgoto error_out;\n\t}\n\n\tnblocks += DIV_ROUND_UP(\n\t\t\thandle->h_revoke_credits_requested + revoke_records,\n\t\t\tjournal->j_revoke_records_per_block) -\n\t\tDIV_ROUND_UP(\n\t\t\thandle->h_revoke_credits_requested,\n\t\t\tjournal->j_revoke_records_per_block);\n\tspin_lock(&transaction->t_handle_lock);\n\twanted = atomic_add_return(nblocks,\n\t\t\t\t   &transaction->t_outstanding_credits);\n\n\tif (wanted > journal->j_max_transaction_buffers) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction too large\\n\", handle, nblocks);\n\t\tatomic_sub(nblocks, &transaction->t_outstanding_credits);\n\t\tgoto unlock;\n\t}\n\n\ttrace_jbd2_handle_extend(journal->j_fs_dev->bd_dev,\n\t\t\t\t transaction->t_tid,\n\t\t\t\t handle->h_type, handle->h_line_no,\n\t\t\t\t handle->h_total_credits,\n\t\t\t\t nblocks);\n\n\thandle->h_total_credits += nblocks;\n\thandle->h_requested_credits += nblocks;\n\thandle->h_revoke_credits += revoke_records;\n\thandle->h_revoke_credits_requested += revoke_records;\n\tresult = 0;\n\n\tjbd_debug(3, \"extended handle %p by %d\\n\", handle, nblocks);\nunlock:\n\tspin_unlock(&transaction->t_handle_lock);\nerror_out:\n\tread_unlock(&journal->j_state_lock);\n\treturn result;\n}\n\nstatic void stop_this_handle(handle_t *handle)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tint revokes;\n\n\tJ_ASSERT(journal_current_handle() == handle);\n\tJ_ASSERT(atomic_read(&transaction->t_updates) > 0);\n\tcurrent->journal_info = NULL;\n\t/*\n\t * Subtract necessary revoke descriptor blocks from handle credits. We\n\t * take care to account only for revoke descriptor blocks the\n\t * transaction will really need as large sequences of transactions with\n\t * small numbers of revokes are relatively common.\n\t */\n\trevokes = handle->h_revoke_credits_requested - handle->h_revoke_credits;\n\tif (revokes) {\n\t\tint t_revokes, revoke_descriptors;\n\t\tint rr_per_blk = journal->j_revoke_records_per_block;\n\n\t\tWARN_ON_ONCE(DIV_ROUND_UP(revokes, rr_per_blk)\n\t\t\t\t> handle->h_total_credits);\n\t\tt_revokes = atomic_add_return(revokes,\n\t\t\t\t&transaction->t_outstanding_revokes);\n\t\trevoke_descriptors =\n\t\t\tDIV_ROUND_UP(t_revokes, rr_per_blk) -\n\t\t\tDIV_ROUND_UP(t_revokes - revokes, rr_per_blk);\n\t\thandle->h_total_credits -= revoke_descriptors;\n\t}\n\tatomic_sub(handle->h_total_credits,\n\t\t   &transaction->t_outstanding_credits);\n\tif (handle->h_rsv_handle)\n\t\t__jbd2_journal_unreserve_handle(handle->h_rsv_handle,\n\t\t\t\t\t\ttransaction);\n\tif (atomic_dec_and_test(&transaction->t_updates))\n\t\twake_up(&journal->j_wait_updates);\n\n\trwsem_release(&journal->j_trans_commit_map, _THIS_IP_);\n\t/*\n\t * Scope of the GFP_NOFS context is over here and so we can restore the\n\t * original alloc context.\n\t */\n\tmemalloc_nofs_restore(handle->saved_alloc_context);\n}\n\n/**\n * jbd2__journal_restart() - restart a handle .\n * @handle:  handle to restart\n * @nblocks: nr credits requested\n * @revoke_records: number of revoke record credits requested\n * @gfp_mask: memory allocation flags (for start_this_handle)\n *\n * Restart a handle for a multi-transaction filesystem\n * operation.\n *\n * If the jbd2_journal_extend() call above fails to grant new buffer credits\n * to a running handle, a call to jbd2_journal_restart will commit the\n * handle's transaction so far and reattach the handle to a new\n * transaction capable of guaranteeing the requested number of\n * credits. We preserve reserved handle if there's any attached to the\n * passed in handle.\n */\nint jbd2__journal_restart(handle_t *handle, int nblocks, int revoke_records,\n\t\t\t  gfp_t gfp_mask)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\ttid_t\t\ttid;\n\tint\t\tneed_to_start;\n\tint\t\tret;\n\n\t/* If we've had an abort of any type, don't even think about\n\t * actually doing the restart! */\n\tif (is_handle_aborted(handle))\n\t\treturn 0;\n\tjournal = transaction->t_journal;\n\ttid = transaction->t_tid;\n\n\t/*\n\t * First unlink the handle from its current transaction, and start the\n\t * commit on that.\n\t */\n\tjbd_debug(2, \"restarting handle %p\\n\", handle);\n\tstop_this_handle(handle);\n\thandle->h_transaction = NULL;\n\n\t/*\n\t * TODO: If we use READ_ONCE / WRITE_ONCE for j_commit_request we can\n \t * get rid of pointless j_state_lock traffic like this.\n\t */\n\tread_lock(&journal->j_state_lock);\n\tneed_to_start = !tid_geq(journal->j_commit_request, tid);\n\tread_unlock(&journal->j_state_lock);\n\tif (need_to_start)\n\t\tjbd2_log_start_commit(journal, tid);\n\thandle->h_total_credits = nblocks +\n\t\tDIV_ROUND_UP(revoke_records,\n\t\t\t     journal->j_revoke_records_per_block);\n\thandle->h_revoke_credits = revoke_records;\n\tret = start_this_handle(journal, handle, gfp_mask);\n\ttrace_jbd2_handle_restart(journal->j_fs_dev->bd_dev,\n\t\t\t\t ret ? 0 : handle->h_transaction->t_tid,\n\t\t\t\t handle->h_type, handle->h_line_no,\n\t\t\t\t handle->h_total_credits);\n\treturn ret;\n}\nEXPORT_SYMBOL(jbd2__journal_restart);\n\n\nint jbd2_journal_restart(handle_t *handle, int nblocks)\n{\n\treturn jbd2__journal_restart(handle, nblocks, 0, GFP_NOFS);\n}\nEXPORT_SYMBOL(jbd2_journal_restart);\n\n/*\n * Waits for any outstanding t_updates to finish.\n * This is called with write j_state_lock held.\n */\nvoid jbd2_journal_wait_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twhile (1) {\n\t\t/*\n\t\t * Note that the running transaction can get freed under us if\n\t\t * this transaction is getting committed in\n\t\t * jbd2_journal_commit_transaction() ->\n\t\t * jbd2_journal_free_transaction(). This can only happen when we\n\t\t * release j_state_lock -> schedule() -> acquire j_state_lock.\n\t\t * Hence we should everytime retrieve new j_running_transaction\n\t\t * value (after j_state_lock release acquire cycle), else it may\n\t\t * lead to use-after-free of old freed transaction.\n\t\t */\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n}\n\n/**\n * jbd2_journal_lock_updates () - establish a transaction barrier.\n * @journal:  Journal to establish a barrier on.\n *\n * This locks out any further updates from being started, and blocks\n * until all existing updates have completed, returning only once the\n * journal is in a quiescent state with no updates running.\n *\n * The journal lock should not be held on entry.\n */\nvoid jbd2_journal_lock_updates(journal_t *journal)\n{\n\tjbd2_might_wait_for_commit(journal);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running t_updates */\n\tjbd2_journal_wait_updates(journal);\n\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}\n\n/**\n * jbd2_journal_unlock_updates () - release barrier\n * @journal:  Journal to release the barrier on.\n *\n * Release a transaction barrier obtained with jbd2_journal_lock_updates().\n *\n * Should be called without the journal lock held.\n */\nvoid jbd2_journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tmutex_unlock(&journal->j_barrier);\n\twrite_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}\n\nstatic void warn_dirty_buffer(struct buffer_head *bh)\n{\n\tprintk(KERN_WARNING\n\t       \"JBD2: Spotted dirty metadata buffer (dev = %pg, blocknr = %llu). \"\n\t       \"There's a risk of filesystem corruption in case of system \"\n\t       \"crash.\\n\",\n\t       bh->b_bdev, (unsigned long long)bh->b_blocknr);\n}\n\n/* Call t_frozen trigger and copy buffer data into jh->b_frozen_data. */\nstatic void jbd2_freeze_jh_data(struct journal_head *jh)\n{\n\tstruct page *page;\n\tint offset;\n\tchar *source;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_EXPECT_JH(jh, buffer_uptodate(bh), \"Possible IO failure.\\n\");\n\tpage = bh->b_page;\n\toffset = offset_in_page(bh->b_data);\n\tsource = kmap_atomic(page);\n\t/* Fire data frozen trigger just before we copy the data */\n\tjbd2_buffer_frozen_trigger(jh, source + offset, jh->b_triggers);\n\tmemcpy(jh->b_frozen_data, source + offset, bh->b_size);\n\tkunmap_atomic(source);\n\n\t/*\n\t * Now that the frozen data is saved off, we need to store any matching\n\t * triggers.\n\t */\n\tjh->b_frozen_triggers = jh->b_triggers;\n}\n\n/*\n * If the buffer is already part of the current transaction, then there\n * is nothing we need to do.  If it is already part of a prior\n * transaction which we are still committing to disk, then we need to\n * make sure that we do not overwrite the old copy: we do copy-out to\n * preserve the copy going to disk.  We also account the buffer against\n * the handle's metadata buffer credits (unless the buffer is already\n * part of the transaction, that is).\n *\n */\nstatic int\ndo_get_write_access(handle_t *handle, struct journal_head *jh,\n\t\t\tint force_copy)\n{\n\tstruct buffer_head *bh;\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tint error;\n\tchar *frozen_buffer = NULL;\n\tunsigned long start_lock, time_lock;\n\n\tjournal = transaction->t_journal;\n\n\tjbd_debug(5, \"journal_head %p, force_copy %d\\n\", jh, force_copy);\n\n\tJBUFFER_TRACE(jh, \"entry\");\nrepeat:\n\tbh = jh2bh(jh);\n\n\t/* @@@ Need to check for errors here at some point. */\n\n \tstart_lock = jiffies;\n\tlock_buffer(bh);\n\tspin_lock(&jh->b_state_lock);\n\n\t/* If it takes too long to lock the buffer, trace it */\n\ttime_lock = jbd2_time_diff(start_lock, jiffies);\n\tif (time_lock > HZ/10)\n\t\ttrace_jbd2_lock_buffer_stall(bh->b_bdev->bd_dev,\n\t\t\tjiffies_to_msecs(time_lock));\n\n\t/* We now hold the buffer lock so it is safe to query the buffer\n\t * state.  Is the buffer dirty?\n\t *\n\t * If so, there are two possibilities.  The buffer may be\n\t * non-journaled, and undergoing a quite legitimate writeback.\n\t * Otherwise, it is journaled, and we don't expect dirty buffers\n\t * in that state (the buffers should be marked JBD_Dirty\n\t * instead.)  So either the IO is being done under our own\n\t * control and this is a bug, or it's a third party IO such as\n\t * dump(8) (which may leave the buffer scheduled for read ---\n\t * ie. locked but not dirty) or tune2fs (which may actually have\n\t * the buffer dirtied, ugh.)  */\n\n\tif (buffer_dirty(bh)) {\n\t\t/*\n\t\t * First question: is this buffer already part of the current\n\t\t * transaction or the existing committing transaction?\n\t\t */\n\t\tif (jh->b_transaction) {\n\t\t\tJ_ASSERT_JH(jh,\n\t\t\t\tjh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\t\tif (jh->b_next_transaction)\n\t\t\t\tJ_ASSERT_JH(jh, jh->b_next_transaction ==\n\t\t\t\t\t\t\ttransaction);\n\t\t\twarn_dirty_buffer(bh);\n\t\t}\n\t\t/*\n\t\t * In any case we need to clean the dirty flag and we must\n\t\t * do it under the buffer lock to be sure we don't race\n\t\t * with running write-out.\n\t\t */\n\t\tJBUFFER_TRACE(jh, \"Journalling dirty buffer\");\n\t\tclear_buffer_dirty(bh);\n\t\tset_buffer_jbddirty(bh);\n\t}\n\n\tunlock_buffer(bh);\n\n\terror = -EROFS;\n\tif (is_handle_aborted(handle)) {\n\t\tspin_unlock(&jh->b_state_lock);\n\t\tgoto out;\n\t}\n\terror = 0;\n\n\t/*\n\t * The buffer is already part of this transaction if b_transaction or\n\t * b_next_transaction points to it\n\t */\n\tif (jh->b_transaction == transaction ||\n\t    jh->b_next_transaction == transaction)\n\t\tgoto done;\n\n\t/*\n\t * this is the first time this transaction is touching this buffer,\n\t * reset the modified flag\n\t */\n\tjh->b_modified = 0;\n\n\t/*\n\t * If the buffer is not journaled right now, we need to make sure it\n\t * doesn't get written to disk before the caller actually commits the\n\t * new data\n\t */\n\tif (!jh->b_transaction) {\n\t\tJBUFFER_TRACE(jh, \"no transaction\");\n\t\tJ_ASSERT_JH(jh, !jh->b_next_transaction);\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Reserved\");\n\t\t/*\n\t\t * Make sure all stores to jh (b_modified, b_frozen_data) are\n\t\t * visible before attaching it to the running transaction.\n\t\t * Paired with barrier in jbd2_write_access_granted()\n\t\t */\n\t\tsmp_wmb();\n\t\tspin_lock(&journal->j_list_lock);\n\t\t__jbd2_journal_file_buffer(jh, transaction, BJ_Reserved);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tgoto done;\n\t}\n\t/*\n\t * If there is already a copy-out version of this buffer, then we don't\n\t * need to make another one\n\t */\n\tif (jh->b_frozen_data) {\n\t\tJBUFFER_TRACE(jh, \"has frozen data\");\n\t\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\t\tgoto attach_next;\n\t}\n\n\tJBUFFER_TRACE(jh, \"owned by older transaction\");\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_transaction == journal->j_committing_transaction);\n\n\t/*\n\t * There is one case we have to be very careful about.  If the\n\t * committing transaction is currently writing this buffer out to disk\n\t * and has NOT made a copy-out, then we cannot modify the buffer\n\t * contents at all right now.  The essence of copy-out is that it is\n\t * the extra copy, not the primary copy, which gets journaled.  If the\n\t * primary copy is already going to disk then we cannot do copy-out\n\t * here.\n\t */\n\tif (buffer_shadow(bh)) {\n\t\tJBUFFER_TRACE(jh, \"on shadow: sleep\");\n\t\tspin_unlock(&jh->b_state_lock);\n\t\twait_on_bit_io(&bh->b_state, BH_Shadow, TASK_UNINTERRUPTIBLE);\n\t\tgoto repeat;\n\t}\n\n\t/*\n\t * Only do the copy if the currently-owning transaction still needs it.\n\t * If buffer isn't on BJ_Metadata list, the committing transaction is\n\t * past that stage (here we use the fact that BH_Shadow is set under\n\t * bh_state lock together with refiling to BJ_Shadow list and at this\n\t * point we know the buffer doesn't have BH_Shadow set).\n\t *\n\t * Subtle point, though: if this is a get_undo_access, then we will be\n\t * relying on the frozen_data to contain the new value of the\n\t * committed_data record after the transaction, so we HAVE to force the\n\t * frozen_data copy in that case.\n\t */\n\tif (jh->b_jlist == BJ_Metadata || force_copy) {\n\t\tJBUFFER_TRACE(jh, \"generate frozen data\");\n\t\tif (!frozen_buffer) {\n\t\t\tJBUFFER_TRACE(jh, \"allocate memory for buffer\");\n\t\t\tspin_unlock(&jh->b_state_lock);\n\t\t\tfrozen_buffer = jbd2_alloc(jh2bh(jh)->b_size,\n\t\t\t\t\t\t   GFP_NOFS | __GFP_NOFAIL);\n\t\t\tgoto repeat;\n\t\t}\n\t\tjh->b_frozen_data = frozen_buffer;\n\t\tfrozen_buffer = NULL;\n\t\tjbd2_freeze_jh_data(jh);\n\t}\nattach_next:\n\t/*\n\t * Make sure all stores to jh (b_modified, b_frozen_data) are visible\n\t * before attaching it to the running transaction. Paired with barrier\n\t * in jbd2_write_access_granted()\n\t */\n\tsmp_wmb();\n\tjh->b_next_transaction = transaction;\n\ndone:\n\tspin_unlock(&jh->b_state_lock);\n\n\t/*\n\t * If we are about to journal a buffer, then any revoke pending on it is\n\t * no longer valid\n\t */\n\tjbd2_journal_cancel_revoke(handle, jh);\n\nout:\n\tif (unlikely(frozen_buffer))\t/* It's usually NULL */\n\t\tjbd2_free(frozen_buffer, bh->b_size);\n\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn error;\n}\n\n/* Fast check whether buffer is already attached to the required transaction */\nstatic bool jbd2_write_access_granted(handle_t *handle, struct buffer_head *bh,\n\t\t\t\t\t\t\tbool undo)\n{\n\tstruct journal_head *jh;\n\tbool ret = false;\n\n\t/* Dirty buffers require special handling... */\n\tif (buffer_dirty(bh))\n\t\treturn false;\n\n\t/*\n\t * RCU protects us from dereferencing freed pages. So the checks we do\n\t * are guaranteed not to oops. However the jh slab object can get freed\n\t * & reallocated while we work with it. So we have to be careful. When\n\t * we see jh attached to the running transaction, we know it must stay\n\t * so until the transaction is committed. Thus jh won't be freed and\n\t * will be attached to the same bh while we run.  However it can\n\t * happen jh gets freed, reallocated, and attached to the transaction\n\t * just after we get pointer to it from bh. So we have to be careful\n\t * and recheck jh still belongs to our bh before we return success.\n\t */\n\trcu_read_lock();\n\tif (!buffer_jbd(bh))\n\t\tgoto out;\n\t/* This should be bh2jh() but that doesn't work with inline functions */\n\tjh = READ_ONCE(bh->b_private);\n\tif (!jh)\n\t\tgoto out;\n\t/* For undo access buffer must have data copied */\n\tif (undo && !jh->b_committed_data)\n\t\tgoto out;\n\tif (READ_ONCE(jh->b_transaction) != handle->h_transaction &&\n\t    READ_ONCE(jh->b_next_transaction) != handle->h_transaction)\n\t\tgoto out;\n\t/*\n\t * There are two reasons for the barrier here:\n\t * 1) Make sure to fetch b_bh after we did previous checks so that we\n\t * detect when jh went through free, realloc, attach to transaction\n\t * while we were checking. Paired with implicit barrier in that path.\n\t * 2) So that access to bh done after jbd2_write_access_granted()\n\t * doesn't get reordered and see inconsistent state of concurrent\n\t * do_get_write_access().\n\t */\n\tsmp_mb();\n\tif (unlikely(jh->b_bh != bh))\n\t\tgoto out;\n\tret = true;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\n\n/**\n * jbd2_journal_get_write_access() - notify intent to modify a buffer\n *\t\t\t\t     for metadata (not data) update.\n * @handle: transaction to add buffer modifications to\n * @bh:     bh to be used for metadata writes\n *\n * Returns: error code or 0 on success.\n *\n * In full data journalling mode the buffer may be of type BJ_AsyncData,\n * because we're ``write()ing`` a buffer which is also part of a shared mapping.\n */\n\nint jbd2_journal_get_write_access(handle_t *handle, struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\tint rc;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\n\tif (jbd2_write_access_granted(handle, bh, false))\n\t\treturn 0;\n\n\tjh = jbd2_journal_add_journal_head(bh);\n\t/* We do not want to get caught playing with fields which the\n\t * log thread also manipulates.  Make sure that the buffer\n\t * completes any outstanding IO before proceeding. */\n\trc = do_get_write_access(handle, jh, 0);\n\tjbd2_journal_put_journal_head(jh);\n\treturn rc;\n}\n\n\n/*\n * When the user wants to journal a newly created buffer_head\n * (ie. getblk() returned a new buffer and we are going to populate it\n * manually rather than reading off disk), then we need to keep the\n * buffer_head locked until it has been completely filled with new\n * data.  In this case, we should be able to make the assertion that\n * the bh is not already part of an existing transaction.\n *\n * The buffer should already be locked by the caller by this point.\n * There is no lock ranking violation: it was a newly created,\n * unlocked buffer beforehand. */\n\n/**\n * jbd2_journal_get_create_access () - notify intent to use newly created bh\n * @handle: transaction to new buffer to\n * @bh: new buffer.\n *\n * Call this if you create a new bh.\n */\nint jbd2_journal_get_create_access(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh = jbd2_journal_add_journal_head(bh);\n\tint err;\n\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\terr = -EROFS;\n\tif (is_handle_aborted(handle))\n\t\tgoto out;\n\tjournal = transaction->t_journal;\n\terr = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\t/*\n\t * The buffer may already belong to this transaction due to pre-zeroing\n\t * in the filesystem's new_block code.  It may also be on the previous,\n\t * committing transaction's lists, but it HAS to be in Forget state in\n\t * that case: the transaction must have deleted the buffer for it to be\n\t * reused here.\n\t */\n\tspin_lock(&jh->b_state_lock);\n\tJ_ASSERT_JH(jh, (jh->b_transaction == transaction ||\n\t\tjh->b_transaction == NULL ||\n\t\t(jh->b_transaction == journal->j_committing_transaction &&\n\t\t\t  jh->b_jlist == BJ_Forget)));\n\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\tJ_ASSERT_JH(jh, buffer_locked(jh2bh(jh)));\n\n\tif (jh->b_transaction == NULL) {\n\t\t/*\n\t\t * Previous jbd2_journal_forget() could have left the buffer\n\t\t * with jbddirty bit set because it was being committed. When\n\t\t * the commit finished, we've filed the buffer for\n\t\t * checkpointing and marked it dirty. Now we are reallocating\n\t\t * the buffer so the transaction freeing it must have\n\t\t * committed and so it's safe to clear the dirty bit.\n\t\t */\n\t\tclear_buffer_dirty(jh2bh(jh));\n\t\t/* first access by this transaction */\n\t\tjh->b_modified = 0;\n\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Reserved\");\n\t\tspin_lock(&journal->j_list_lock);\n\t\t__jbd2_journal_file_buffer(jh, transaction, BJ_Reserved);\n\t\tspin_unlock(&journal->j_list_lock);\n\t} else if (jh->b_transaction == journal->j_committing_transaction) {\n\t\t/* first access by this transaction */\n\t\tjh->b_modified = 0;\n\n\t\tJBUFFER_TRACE(jh, \"set next transaction\");\n\t\tspin_lock(&journal->j_list_lock);\n\t\tjh->b_next_transaction = transaction;\n\t\tspin_unlock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&jh->b_state_lock);\n\n\t/*\n\t * akpm: I added this.  ext3_alloc_branch can pick up new indirect\n\t * blocks which contain freed but then revoked metadata.  We need\n\t * to cancel the revoke in case we end up freeing it yet again\n\t * and the reallocating as data - this would cause a second revoke,\n\t * which hits an assertion error.\n\t */\n\tJBUFFER_TRACE(jh, \"cancelling revoke\");\n\tjbd2_journal_cancel_revoke(handle, jh);\nout:\n\tjbd2_journal_put_journal_head(jh);\n\treturn err;\n}\n\n/**\n * jbd2_journal_get_undo_access() -  Notify intent to modify metadata with\n *     non-rewindable consequences\n * @handle: transaction\n * @bh: buffer to undo\n *\n * Sometimes there is a need to distinguish between metadata which has\n * been committed to disk and that which has not.  The ext3fs code uses\n * this for freeing and allocating space, we have to make sure that we\n * do not reuse freed space until the deallocation has been committed,\n * since if we overwrote that space we would make the delete\n * un-rewindable in case of a crash.\n *\n * To deal with that, jbd2_journal_get_undo_access requests write access to a\n * buffer for parts of non-rewindable operations such as delete\n * operations on the bitmaps.  The journaling code must keep a copy of\n * the buffer's contents prior to the undo_access call until such time\n * as we know that the buffer has definitely been committed to disk.\n *\n * We never need to know which transaction the committed data is part\n * of, buffers touched here are guaranteed to be dirtied later and so\n * will be committed to a new transaction in due course, at which point\n * we can discard the old committed data pointer.\n *\n * Returns error number or 0 on success.\n */\nint jbd2_journal_get_undo_access(handle_t *handle, struct buffer_head *bh)\n{\n\tint err;\n\tstruct journal_head *jh;\n\tchar *committed_data = NULL;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\n\tif (jbd2_write_access_granted(handle, bh, true))\n\t\treturn 0;\n\n\tjh = jbd2_journal_add_journal_head(bh);\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\t/*\n\t * Do this first --- it can drop the journal lock, so we want to\n\t * make sure that obtaining the committed_data is done\n\t * atomically wrt. completion of any outstanding commits.\n\t */\n\terr = do_get_write_access(handle, jh, 1);\n\tif (err)\n\t\tgoto out;\n\nrepeat:\n\tif (!jh->b_committed_data)\n\t\tcommitted_data = jbd2_alloc(jh2bh(jh)->b_size,\n\t\t\t\t\t    GFP_NOFS|__GFP_NOFAIL);\n\n\tspin_lock(&jh->b_state_lock);\n\tif (!jh->b_committed_data) {\n\t\t/* Copy out the current buffer contents into the\n\t\t * preserved, committed copy. */\n\t\tJBUFFER_TRACE(jh, \"generate b_committed data\");\n\t\tif (!committed_data) {\n\t\t\tspin_unlock(&jh->b_state_lock);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh->b_committed_data = committed_data;\n\t\tcommitted_data = NULL;\n\t\tmemcpy(jh->b_committed_data, bh->b_data, bh->b_size);\n\t}\n\tspin_unlock(&jh->b_state_lock);\nout:\n\tjbd2_journal_put_journal_head(jh);\n\tif (unlikely(committed_data))\n\t\tjbd2_free(committed_data, bh->b_size);\n\treturn err;\n}\n\n/**\n * jbd2_journal_set_triggers() - Add triggers for commit writeout\n * @bh: buffer to trigger on\n * @type: struct jbd2_buffer_trigger_type containing the trigger(s).\n *\n * Set any triggers on this journal_head.  This is always safe, because\n * triggers for a committing buffer will be saved off, and triggers for\n * a running transaction will match the buffer in that transaction.\n *\n * Call with NULL to clear the triggers.\n */\nvoid jbd2_journal_set_triggers(struct buffer_head *bh,\n\t\t\t       struct jbd2_buffer_trigger_type *type)\n{\n\tstruct journal_head *jh = jbd2_journal_grab_journal_head(bh);\n\n\tif (WARN_ON_ONCE(!jh))\n\t\treturn;\n\tjh->b_triggers = type;\n\tjbd2_journal_put_journal_head(jh);\n}\n\nvoid jbd2_buffer_frozen_trigger(struct journal_head *jh, void *mapped_data,\n\t\t\t\tstruct jbd2_buffer_trigger_type *triggers)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tif (!triggers || !triggers->t_frozen)\n\t\treturn;\n\n\ttriggers->t_frozen(triggers, bh, mapped_data, bh->b_size);\n}\n\nvoid jbd2_buffer_abort_trigger(struct journal_head *jh,\n\t\t\t       struct jbd2_buffer_trigger_type *triggers)\n{\n\tif (!triggers || !triggers->t_abort)\n\t\treturn;\n\n\ttriggers->t_abort(triggers, jh2bh(jh));\n}\n\n/**\n * jbd2_journal_dirty_metadata() -  mark a buffer as containing dirty metadata\n * @handle: transaction to add buffer to.\n * @bh: buffer to mark\n *\n * mark dirty metadata which needs to be journaled as part of the current\n * transaction.\n *\n * The buffer must have previously had jbd2_journal_get_write_access()\n * called so that it has a valid journal_head attached to the buffer\n * head.\n *\n * The buffer is placed on the transaction's metadata list and is marked\n * as belonging to the transaction.\n *\n * Returns error number or 0 on success.\n *\n * Special care needs to be taken if the buffer already belongs to the\n * current committing transaction (in which case we should have frozen\n * data present for that commit).  In that case, we don't relink the\n * buffer: that only gets done when the old transaction finally\n * completes its commit.\n */\nint jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh;\n\tint ret = 0;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tif (!buffer_jbd(bh))\n\t\treturn -EUCLEAN;\n\n\t/*\n\t * We don't grab jh reference here since the buffer must be part\n\t * of the running transaction.\n\t */\n\tjh = bh2jh(bh);\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\t/*\n\t * This and the following assertions are unreliable since we may see jh\n\t * in inconsistent state unless we grab bh_state lock. But this is\n\t * crucial to catch bugs so let's do a reliable check until the\n\t * lockless handling is fully proven.\n\t */\n\tif (data_race(jh->b_transaction != transaction &&\n\t    jh->b_next_transaction != transaction)) {\n\t\tspin_lock(&jh->b_state_lock);\n\t\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_next_transaction == transaction);\n\t\tspin_unlock(&jh->b_state_lock);\n\t}\n\tif (jh->b_modified == 1) {\n\t\t/* If it's in our transaction it must be in BJ_Metadata list. */\n\t\tif (data_race(jh->b_transaction == transaction &&\n\t\t    jh->b_jlist != BJ_Metadata)) {\n\t\t\tspin_lock(&jh->b_state_lock);\n\t\t\tif (jh->b_transaction == transaction &&\n\t\t\t    jh->b_jlist != BJ_Metadata)\n\t\t\t\tpr_err(\"JBD2: assertion failure: h_type=%u \"\n\t\t\t\t       \"h_line_no=%u block_no=%llu jlist=%u\\n\",\n\t\t\t\t       handle->h_type, handle->h_line_no,\n\t\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t\t       jh->b_jlist);\n\t\t\tJ_ASSERT_JH(jh, jh->b_transaction != transaction ||\n\t\t\t\t\tjh->b_jlist == BJ_Metadata);\n\t\t\tspin_unlock(&jh->b_state_lock);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tjournal = transaction->t_journal;\n\tspin_lock(&jh->b_state_lock);\n\n\tif (jh->b_modified == 0) {\n\t\t/*\n\t\t * This buffer's got modified and becoming part\n\t\t * of the transaction. This needs to be done\n\t\t * once a transaction -bzzz\n\t\t */\n\t\tif (WARN_ON_ONCE(jbd2_handle_buffer_credits(handle) <= 0)) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out_unlock_bh;\n\t\t}\n\t\tjh->b_modified = 1;\n\t\thandle->h_total_credits--;\n\t}\n\n\t/*\n\t * fastpath, to avoid expensive locking.  If this buffer is already\n\t * on the running transaction's metadata list there is nothing to do.\n\t * Nobody can take it off again because there is a handle open.\n\t * I _think_ we're OK here with SMP barriers - a mistaken decision will\n\t * result in this test being false, so we go in and take the locks.\n\t */\n\tif (jh->b_transaction == transaction && jh->b_jlist == BJ_Metadata) {\n\t\tJBUFFER_TRACE(jh, \"fastpath\");\n\t\tif (unlikely(jh->b_transaction !=\n\t\t\t     journal->j_running_transaction)) {\n\t\t\tprintk(KERN_ERR \"JBD2: %s: \"\n\t\t\t       \"jh->b_transaction (%llu, %p, %u) != \"\n\t\t\t       \"journal->j_running_transaction (%p, %u)\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ? jh->b_transaction->t_tid : 0,\n\t\t\t       journal->j_running_transaction,\n\t\t\t       journal->j_running_transaction ?\n\t\t\t       journal->j_running_transaction->t_tid : 0);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tgoto out_unlock_bh;\n\t}\n\n\tset_buffer_jbddirty(bh);\n\n\t/*\n\t * Metadata already on the current transaction list doesn't\n\t * need to be filed.  Metadata on another transaction's list must\n\t * be committing, and will be refiled once the commit completes:\n\t * leave it alone for now.\n\t */\n\tif (jh->b_transaction != transaction) {\n\t\tJBUFFER_TRACE(jh, \"already on other transaction\");\n\t\tif (unlikely(((jh->b_transaction !=\n\t\t\t       journal->j_committing_transaction)) ||\n\t\t\t     (jh->b_next_transaction != transaction))) {\n\t\t\tprintk(KERN_ERR \"jbd2_journal_dirty_metadata: %s: \"\n\t\t\t       \"bad jh for block %llu: \"\n\t\t\t       \"transaction (%p, %u), \"\n\t\t\t       \"jh->b_transaction (%p, %u), \"\n\t\t\t       \"jh->b_next_transaction (%p, %u), jlist %u\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       transaction, transaction->t_tid,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ?\n\t\t\t       jh->b_transaction->t_tid : 0,\n\t\t\t       jh->b_next_transaction,\n\t\t\t       jh->b_next_transaction ?\n\t\t\t       jh->b_next_transaction->t_tid : 0,\n\t\t\t       jh->b_jlist);\n\t\t\tWARN_ON(1);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\t/* And this case is illegal: we can't reuse another\n\t\t * transaction's data buffer, ever. */\n\t\tgoto out_unlock_bh;\n\t}\n\n\t/* That test should have eliminated the following case: */\n\tJ_ASSERT_JH(jh, jh->b_frozen_data == NULL);\n\n\tJBUFFER_TRACE(jh, \"file as BJ_Metadata\");\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_file_buffer(jh, transaction, BJ_Metadata);\n\tspin_unlock(&journal->j_list_lock);\nout_unlock_bh:\n\tspin_unlock(&jh->b_state_lock);\nout:\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn ret;\n}\n\n/**\n * jbd2_journal_forget() - bforget() for potentially-journaled buffers.\n * @handle: transaction handle\n * @bh:     bh to 'forget'\n *\n * We can only do the bforget if there are no commits pending against the\n * buffer.  If the buffer is dirty in the current running transaction we\n * can safely unlink it.\n *\n * bh may not be a journalled buffer at all - it may be a non-JBD\n * buffer which came off the hashtable.  Check for this.\n *\n * Decrements bh->b_count by one.\n *\n * Allow this call even if the handle has aborted --- it may be part of\n * the caller's cleanup after an abort.\n */\nint jbd2_journal_forget(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh;\n\tint drop_reserve = 0;\n\tint err = 0;\n\tint was_modified = 0;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\n\tjh = jbd2_journal_grab_journal_head(bh);\n\tif (!jh) {\n\t\t__bforget(bh);\n\t\treturn 0;\n\t}\n\n\tspin_lock(&jh->b_state_lock);\n\n\t/* Critical error: attempting to delete a bitmap buffer, maybe?\n\t * Don't do any jbd operations, and return an error. */\n\tif (!J_EXPECT_JH(jh, !jh->b_committed_data,\n\t\t\t \"inconsistent data on disk\")) {\n\t\terr = -EIO;\n\t\tgoto drop;\n\t}\n\n\t/* keep track of whether or not this transaction modified us */\n\twas_modified = jh->b_modified;\n\n\t/*\n\t * The buffer's going from the transaction, we must drop\n\t * all references -bzzz\n\t */\n\tjh->b_modified = 0;\n\n\tif (jh->b_transaction == transaction) {\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\n\t\t/* If we are forgetting a buffer which is already part\n\t\t * of this transaction, then we can just drop it from\n\t\t * the transaction immediately. */\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_jbddirty(bh);\n\n\t\tJBUFFER_TRACE(jh, \"belongs to current transaction: unfile\");\n\n\t\t/*\n\t\t * we only want to drop a reference if this transaction\n\t\t * modified the buffer\n\t\t */\n\t\tif (was_modified)\n\t\t\tdrop_reserve = 1;\n\n\t\t/*\n\t\t * We are no longer going to journal this buffer.\n\t\t * However, the commit of this transaction is still\n\t\t * important to the buffer: the delete that we are now\n\t\t * processing might obsolete an old log entry, so by\n\t\t * committing, we can satisfy the buffer's checkpoint.\n\t\t *\n\t\t * So, if we have a checkpoint on the buffer, we should\n\t\t * now refile the buffer on our BJ_Forget list so that\n\t\t * we know to remove the checkpoint after we commit.\n\t\t */\n\n\t\tspin_lock(&journal->j_list_lock);\n\t\tif (jh->b_cp_transaction) {\n\t\t\t__jbd2_journal_temp_unlink_buffer(jh);\n\t\t\t__jbd2_journal_file_buffer(jh, transaction, BJ_Forget);\n\t\t} else {\n\t\t\t__jbd2_journal_unfile_buffer(jh);\n\t\t\tjbd2_journal_put_journal_head(jh);\n\t\t}\n\t\tspin_unlock(&journal->j_list_lock);\n\t} else if (jh->b_transaction) {\n\t\tJ_ASSERT_JH(jh, (jh->b_transaction ==\n\t\t\t\t journal->j_committing_transaction));\n\t\t/* However, if the buffer is still owned by a prior\n\t\t * (committing) transaction, we can't drop it yet... */\n\t\tJBUFFER_TRACE(jh, \"belongs to older transaction\");\n\t\t/* ... but we CAN drop it from the new transaction through\n\t\t * marking the buffer as freed and set j_next_transaction to\n\t\t * the new transaction, so that not only the commit code\n\t\t * knows it should clear dirty bits when it is done with the\n\t\t * buffer, but also the buffer can be checkpointed only\n\t\t * after the new transaction commits. */\n\n\t\tset_buffer_freed(bh);\n\n\t\tif (!jh->b_next_transaction) {\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tjh->b_next_transaction = transaction;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t} else {\n\t\t\tJ_ASSERT(jh->b_next_transaction == transaction);\n\n\t\t\t/*\n\t\t\t * only drop a reference if this transaction modified\n\t\t\t * the buffer\n\t\t\t */\n\t\t\tif (was_modified)\n\t\t\t\tdrop_reserve = 1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Finally, if the buffer is not belongs to any\n\t\t * transaction, we can just drop it now if it has no\n\t\t * checkpoint.\n\t\t */\n\t\tspin_lock(&journal->j_list_lock);\n\t\tif (!jh->b_cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"belongs to none transaction\");\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, if the buffer has been written to disk,\n\t\t * it is safe to remove the checkpoint and drop it.\n\t\t */\n\t\tif (!buffer_dirty(bh)) {\n\t\t\t__jbd2_journal_remove_checkpoint(jh);\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/*\n\t\t * The buffer is still not written to disk, we should\n\t\t * attach this buffer to current transaction so that the\n\t\t * buffer can be checkpointed only after the current\n\t\t * transaction commits.\n\t\t */\n\t\tclear_buffer_dirty(bh);\n\t\t__jbd2_journal_file_buffer(jh, transaction, BJ_Forget);\n\t\tspin_unlock(&journal->j_list_lock);\n\t}\ndrop:\n\t__brelse(bh);\n\tspin_unlock(&jh->b_state_lock);\n\tjbd2_journal_put_journal_head(jh);\n\tif (drop_reserve) {\n\t\t/* no need to reserve log space for this block -bzzz */\n\t\thandle->h_total_credits++;\n\t}\n\treturn err;\n}\n\n/**\n * jbd2_journal_stop() - complete a transaction\n * @handle: transaction to complete.\n *\n * All done for a particular handle.\n *\n * There is not much action needed here.  We just return any remaining\n * buffer credits to the transaction and remove the handle.  The only\n * complication is that we need to start a commit operation if the\n * filesystem is marked for synchronous update.\n *\n * jbd2_journal_stop itself will not usually return an error, but it may\n * do so in unusual circumstances.  In particular, expect it to\n * return -EIO if a jbd2_journal_abort has been executed since the\n * transaction began.\n */\nint jbd2_journal_stop(handle_t *handle)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tint err = 0, wait_for_commit = 0;\n\ttid_t tid;\n\tpid_t pid;\n\n\tif (--handle->h_ref > 0) {\n\t\tjbd_debug(4, \"h_ref %d -> %d\\n\", handle->h_ref + 1,\n\t\t\t\t\t\t handle->h_ref);\n\t\tif (is_handle_aborted(handle))\n\t\t\treturn -EIO;\n\t\treturn 0;\n\t}\n\tif (!transaction) {\n\t\t/*\n\t\t * Handle is already detached from the transaction so there is\n\t\t * nothing to do other than free the handle.\n\t\t */\n\t\tmemalloc_nofs_restore(handle->saved_alloc_context);\n\t\tgoto free_and_exit;\n\t}\n\tjournal = transaction->t_journal;\n\ttid = transaction->t_tid;\n\n\tif (is_handle_aborted(handle))\n\t\terr = -EIO;\n\n\tjbd_debug(4, \"Handle %p going down\\n\", handle);\n\ttrace_jbd2_handle_stats(journal->j_fs_dev->bd_dev,\n\t\t\t\ttid, handle->h_type, handle->h_line_no,\n\t\t\t\tjiffies - handle->h_start_jiffies,\n\t\t\t\thandle->h_sync, handle->h_requested_credits,\n\t\t\t\t(handle->h_requested_credits -\n\t\t\t\t handle->h_total_credits));\n\n\t/*\n\t * Implement synchronous transaction batching.  If the handle\n\t * was synchronous, don't force a commit immediately.  Let's\n\t * yield and let another thread piggyback onto this\n\t * transaction.  Keep doing that while new threads continue to\n\t * arrive.  It doesn't cost much - we're about to run a commit\n\t * and sleep on IO anyway.  Speeds up many-threaded, many-dir\n\t * operations by 30x or more...\n\t *\n\t * We try and optimize the sleep time against what the\n\t * underlying disk can do, instead of having a static sleep\n\t * time.  This is useful for the case where our storage is so\n\t * fast that it is more optimal to go ahead and force a flush\n\t * and wait for the transaction to be committed than it is to\n\t * wait for an arbitrary amount of time for new writers to\n\t * join the transaction.  We achieve this by measuring how\n\t * long it takes to commit a transaction, and compare it with\n\t * how long this transaction has been running, and if run time\n\t * < commit time then we sleep for the delta and commit.  This\n\t * greatly helps super fast disks that would see slowdowns as\n\t * more threads started doing fsyncs.\n\t *\n\t * But don't do this if this process was the most recent one\n\t * to perform a synchronous write.  We do this to detect the\n\t * case where a single process is doing a stream of sync\n\t * writes.  No point in waiting for joiners in that case.\n\t *\n\t * Setting max_batch_time to 0 disables this completely.\n\t */\n\tpid = current->pid;\n\tif (handle->h_sync && journal->j_last_sync_writer != pid &&\n\t    journal->j_max_batch_time) {\n\t\tu64 commit_time, trans_time;\n\n\t\tjournal->j_last_sync_writer = pid;\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tcommit_time = journal->j_average_commit_time;\n\t\tread_unlock(&journal->j_state_lock);\n\n\t\ttrans_time = ktime_to_ns(ktime_sub(ktime_get(),\n\t\t\t\t\t\t   transaction->t_start_time));\n\n\t\tcommit_time = max_t(u64, commit_time,\n\t\t\t\t    1000*journal->j_min_batch_time);\n\t\tcommit_time = min_t(u64, commit_time,\n\t\t\t\t    1000*journal->j_max_batch_time);\n\n\t\tif (trans_time < commit_time) {\n\t\t\tktime_t expires = ktime_add_ns(ktime_get(),\n\t\t\t\t\t\t       commit_time);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&expires, HRTIMER_MODE_ABS);\n\t\t}\n\t}\n\n\tif (handle->h_sync)\n\t\ttransaction->t_synchronous_commit = 1;\n\n\t/*\n\t * If the handle is marked SYNC, we need to set another commit\n\t * going!  We also want to force a commit if the transaction is too\n\t * old now.\n\t */\n\tif (handle->h_sync ||\n\t    time_after_eq(jiffies, transaction->t_expires)) {\n\t\t/* Do this even for aborted journals: an abort still\n\t\t * completes the commit thread, it just doesn't write\n\t\t * anything to disk. */\n\n\t\tjbd_debug(2, \"transaction too old, requesting commit for \"\n\t\t\t\t\t\"handle %p\\n\", handle);\n\t\t/* This is non-blocking */\n\t\tjbd2_log_start_commit(journal, tid);\n\n\t\t/*\n\t\t * Special case: JBD2_SYNC synchronous updates require us\n\t\t * to wait for the commit to complete.\n\t\t */\n\t\tif (handle->h_sync && !(current->flags & PF_MEMALLOC))\n\t\t\twait_for_commit = 1;\n\t}\n\n\t/*\n\t * Once stop_this_handle() drops t_updates, the transaction could start\n\t * committing on us and eventually disappear.  So we must not\n\t * dereference transaction pointer again after calling\n\t * stop_this_handle().\n\t */\n\tstop_this_handle(handle);\n\n\tif (wait_for_commit)\n\t\terr = jbd2_log_wait_commit(journal, tid);\n\nfree_and_exit:\n\tif (handle->h_rsv_handle)\n\t\tjbd2_free_handle(handle->h_rsv_handle);\n\tjbd2_free_handle(handle);\n\treturn err;\n}\n\n/*\n *\n * List management code snippets: various functions for manipulating the\n * transaction buffer lists.\n *\n */\n\n/*\n * Append a buffer to a transaction list, given the transaction's list head\n * pointer.\n *\n * j_list_lock is held.\n *\n * jh->b_state_lock is held.\n */\n\nstatic inline void\n__blist_add_buffer(struct journal_head **list, struct journal_head *jh)\n{\n\tif (!*list) {\n\t\tjh->b_tnext = jh->b_tprev = jh;\n\t\t*list = jh;\n\t} else {\n\t\t/* Insert at the tail of the list to preserve order */\n\t\tstruct journal_head *first = *list, *last = first->b_tprev;\n\t\tjh->b_tprev = last;\n\t\tjh->b_tnext = first;\n\t\tlast->b_tnext = first->b_tprev = jh;\n\t}\n}\n\n/*\n * Remove a buffer from a transaction list, given the transaction's list\n * head pointer.\n *\n * Called with j_list_lock held, and the journal may not be locked.\n *\n * jh->b_state_lock is held.\n */\n\nstatic inline void\n__blist_del_buffer(struct journal_head **list, struct journal_head *jh)\n{\n\tif (*list == jh) {\n\t\t*list = jh->b_tnext;\n\t\tif (*list == jh)\n\t\t\t*list = NULL;\n\t}\n\tjh->b_tprev->b_tnext = jh->b_tnext;\n\tjh->b_tnext->b_tprev = jh->b_tprev;\n}\n\n/*\n * Remove a buffer from the appropriate transaction list.\n *\n * Note that this function can *change* the value of\n * bh->b_transaction->t_buffers, t_forget, t_shadow_list, t_log_list or\n * t_reserved_list.  If the caller is holding onto a copy of one of these\n * pointers, it could go bad.  Generally the caller needs to re-read the\n * pointer from the transaction_t.\n *\n * Called under j_list_lock.\n */\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh)\n{\n\tstruct journal_head **list = NULL;\n\ttransaction_t *transaction;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tlockdep_assert_held(&jh->b_state_lock);\n\ttransaction = jh->b_transaction;\n\tif (transaction)\n\t\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tif (jh->b_jlist != BJ_None)\n\t\tJ_ASSERT_JH(jh, transaction != NULL);\n\n\tswitch (jh->b_jlist) {\n\tcase BJ_None:\n\t\treturn;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers--;\n\t\tJ_ASSERT_JH(jh, transaction->t_nr_buffers >= 0);\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\t}\n\n\t__blist_del_buffer(list, jh);\n\tjh->b_jlist = BJ_None;\n\tif (transaction && is_journal_aborted(transaction->t_journal))\n\t\tclear_buffer_jbddirty(bh);\n\telse if (test_clear_buffer_jbddirty(bh))\n\t\tmark_buffer_dirty(bh);\t/* Expose it to the VM */\n}\n\n/*\n * Remove buffer from all transactions. The caller is responsible for dropping\n * the jh reference that belonged to the transaction.\n *\n * Called with bh_state lock and j_list_lock\n */\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh)\n{\n\tJ_ASSERT_JH(jh, jh->b_transaction != NULL);\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\n\t__jbd2_journal_temp_unlink_buffer(jh);\n\tjh->b_transaction = NULL;\n}\n\nvoid jbd2_journal_unfile_buffer(journal_t *journal, struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\t/* Get reference so that buffer cannot be freed before we unlock it */\n\tget_bh(bh);\n\tspin_lock(&jh->b_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_unfile_buffer(jh);\n\tspin_unlock(&journal->j_list_lock);\n\tspin_unlock(&jh->b_state_lock);\n\tjbd2_journal_put_journal_head(jh);\n\t__brelse(bh);\n}\n\n/*\n * Called from jbd2_journal_try_to_free_buffers().\n *\n * Called under jh->b_state_lock\n */\nstatic void\n__journal_try_to_free_buffer(journal_t *journal, struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\n\tjh = bh2jh(bh);\n\n\tif (buffer_locked(bh) || buffer_dirty(bh))\n\t\tgoto out;\n\n\tif (jh->b_next_transaction != NULL || jh->b_transaction != NULL)\n\t\tgoto out;\n\n\tspin_lock(&journal->j_list_lock);\n\tif (jh->b_cp_transaction != NULL) {\n\t\t/* written-back checkpointed metadata buffer */\n\t\tJBUFFER_TRACE(jh, \"remove from checkpoint list\");\n\t\t__jbd2_journal_remove_checkpoint(jh);\n\t}\n\tspin_unlock(&journal->j_list_lock);\nout:\n\treturn;\n}\n\n/**\n * jbd2_journal_try_to_free_buffers() - try to free page buffers.\n * @journal: journal for operation\n * @page: to try and free\n *\n * For all the buffers on this page,\n * if they are fully written out ordered data, move them onto BUF_CLEAN\n * so try_to_free_buffers() can reap them.\n *\n * This function returns non-zero if we wish try_to_free_buffers()\n * to be called. We do this if the page is releasable by try_to_free_buffers().\n * We also do it if the page has locked or dirty buffers and the caller wants\n * us to perform sync or async writeout.\n *\n * This complicates JBD locking somewhat.  We aren't protected by the\n * BKL here.  We wish to remove the buffer from its committing or\n * running transaction's ->t_datalist via __jbd2_journal_unfile_buffer.\n *\n * This may *change* the value of transaction_t->t_datalist, so anyone\n * who looks at t_datalist needs to lock against this function.\n *\n * Even worse, someone may be doing a jbd2_journal_dirty_data on this\n * buffer.  So we need to lock against that.  jbd2_journal_dirty_data()\n * will come out of the lock with the buffer dirty, which makes it\n * ineligible for release here.\n *\n * Who else is affected by this?  hmm...  Really the only contender\n * is do_get_write_access() - it could be looking at the buffer while\n * journal_try_to_free_buffer() is changing its state.  But that\n * cannot happen because we never reallocate freed data as metadata\n * while the data is part of a transaction.  Yes?\n *\n * Return 0 on failure, 1 on success\n */\nint jbd2_journal_try_to_free_buffers(journal_t *journal, struct page *page)\n{\n\tstruct buffer_head *head;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tJ_ASSERT(PageLocked(page));\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tstruct journal_head *jh;\n\n\t\t/*\n\t\t * We take our own ref against the journal_head here to avoid\n\t\t * having to add tons of locking around each instance of\n\t\t * jbd2_journal_put_journal_head().\n\t\t */\n\t\tjh = jbd2_journal_grab_journal_head(bh);\n\t\tif (!jh)\n\t\t\tcontinue;\n\n\t\tspin_lock(&jh->b_state_lock);\n\t\t__journal_try_to_free_buffer(journal, bh);\n\t\tspin_unlock(&jh->b_state_lock);\n\t\tjbd2_journal_put_journal_head(jh);\n\t\tif (buffer_jbd(bh))\n\t\t\tgoto busy;\n\t} while ((bh = bh->b_this_page) != head);\n\n\tret = try_to_free_buffers(page);\nbusy:\n\treturn ret;\n}\n\n/*\n * This buffer is no longer needed.  If it is on an older transaction's\n * checkpoint list we need to record it on this transaction's forget list\n * to pin this buffer (and hence its checkpointing transaction) down until\n * this transaction commits.  If the buffer isn't on a checkpoint list, we\n * release it.\n * Returns non-zero if JBD no longer has an interest in the buffer.\n *\n * Called under j_list_lock.\n *\n * Called under jh->b_state_lock.\n */\nstatic int __dispose_buffer(struct journal_head *jh, transaction_t *transaction)\n{\n\tint may_free = 1;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tif (jh->b_cp_transaction) {\n\t\tJBUFFER_TRACE(jh, \"on running+cp transaction\");\n\t\t__jbd2_journal_temp_unlink_buffer(jh);\n\t\t/*\n\t\t * We don't want to write the buffer anymore, clear the\n\t\t * bit so that we don't confuse checks in\n\t\t * __journal_file_buffer\n\t\t */\n\t\tclear_buffer_dirty(bh);\n\t\t__jbd2_journal_file_buffer(jh, transaction, BJ_Forget);\n\t\tmay_free = 0;\n\t} else {\n\t\tJBUFFER_TRACE(jh, \"on running transaction\");\n\t\t__jbd2_journal_unfile_buffer(jh);\n\t\tjbd2_journal_put_journal_head(jh);\n\t}\n\treturn may_free;\n}\n\n/*\n * jbd2_journal_invalidatepage\n *\n * This code is tricky.  It has a number of cases to deal with.\n *\n * There are two invariants which this code relies on:\n *\n * i_size must be updated on disk before we start calling invalidatepage on the\n * data.\n *\n *  This is done in ext3 by defining an ext3_setattr method which\n *  updates i_size before truncate gets going.  By maintaining this\n *  invariant, we can be sure that it is safe to throw away any buffers\n *  attached to the current transaction: once the transaction commits,\n *  we know that the data will not be needed.\n *\n *  Note however that we can *not* throw away data belonging to the\n *  previous, committing transaction!\n *\n * Any disk blocks which *are* part of the previous, committing\n * transaction (and which therefore cannot be discarded immediately) are\n * not going to be reused in the new running transaction\n *\n *  The bitmap committed_data images guarantee this: any block which is\n *  allocated in one transaction and removed in the next will be marked\n *  as in-use in the committed_data bitmap, so cannot be reused until\n *  the next transaction to delete the block commits.  This means that\n *  leaving committing buffers dirty is quite safe: the disk blocks\n *  cannot be reallocated to a different file and so buffer aliasing is\n *  not possible.\n *\n *\n * The above applies mainly to ordered data mode.  In writeback mode we\n * don't make guarantees about the order in which data hits disk --- in\n * particular we don't guarantee that new dirty data is flushed before\n * transaction commit --- so it is always safe just to discard data\n * immediately in that mode.  --sct\n */\n\n/*\n * The journal_unmap_buffer helper function returns zero if the buffer\n * concerned remains pinned as an anonymous buffer belonging to an older\n * transaction.\n *\n * We're outside-transaction here.  Either or both of j_running_transaction\n * and j_committing_transaction may be NULL.\n */\nstatic int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh,\n\t\t\t\tint partial_page)\n{\n\ttransaction_t *transaction;\n\tstruct journal_head *jh;\n\tint may_free = 1;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\n\t/*\n\t * It is safe to proceed here without the j_list_lock because the\n\t * buffers cannot be stolen by try_to_free_buffers as long as we are\n\t * holding the page lock. --sct\n\t */\n\n\tjh = jbd2_journal_grab_journal_head(bh);\n\tif (!jh)\n\t\tgoto zap_buffer_unlocked;\n\n\t/* OK, we have data buffer in journaled mode */\n\twrite_lock(&journal->j_state_lock);\n\tspin_lock(&jh->b_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\n\t/*\n\t * We cannot remove the buffer from checkpoint lists until the\n\t * transaction adding inode to orphan list (let's call it T)\n\t * is committed.  Otherwise if the transaction changing the\n\t * buffer would be cleaned from the journal before T is\n\t * committed, a crash will cause that the correct contents of\n\t * the buffer will be lost.  On the other hand we have to\n\t * clear the buffer dirty bit at latest at the moment when the\n\t * transaction marking the buffer as freed in the filesystem\n\t * structures is committed because from that moment on the\n\t * block can be reallocated and used by a different page.\n\t * Since the block hasn't been freed yet but the inode has\n\t * already been added to orphan list, it is safe for us to add\n\t * the buffer to BJ_Forget list of the newest transaction.\n\t *\n\t * Also we have to clear buffer_mapped flag of a truncated buffer\n\t * because the buffer_head may be attached to the page straddling\n\t * i_size (can happen only when blocksize < pagesize) and thus the\n\t * buffer_head can be reused when the file is extended again. So we end\n\t * up keeping around invalidated buffers attached to transactions'\n\t * BJ_Forget list just to stop checkpointing code from cleaning up\n\t * the transaction this buffer was modified in.\n\t */\n\ttransaction = jh->b_transaction;\n\tif (transaction == NULL) {\n\t\t/* First case: not on any transaction.  If it\n\t\t * has no checkpoint link, then we can zap it:\n\t\t * it's a writeback-mode buffer so we don't care\n\t\t * if it hits disk safely. */\n\t\tif (!jh->b_cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"not on any transaction: zap\");\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\tif (!buffer_dirty(bh)) {\n\t\t\t/* bdflush has written it.  We can drop it now */\n\t\t\t__jbd2_journal_remove_checkpoint(jh);\n\t\t\tgoto zap_buffer;\n\t\t}\n\n\t\t/* OK, it must be in the journal but still not\n\t\t * written fully to disk: it's metadata or\n\t\t * journaled data... */\n\n\t\tif (journal->j_running_transaction) {\n\t\t\t/* ... and once the current transaction has\n\t\t\t * committed, the buffer won't be needed any\n\t\t\t * longer. */\n\t\t\tJBUFFER_TRACE(jh, \"checkpointed: add to BJ_Forget\");\n\t\t\tmay_free = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_running_transaction);\n\t\t\tgoto zap_buffer;\n\t\t} else {\n\t\t\t/* There is no currently-running transaction. So the\n\t\t\t * orphan record which we wrote for this file must have\n\t\t\t * passed into commit.  We must attach this buffer to\n\t\t\t * the committing transaction, if it exists. */\n\t\t\tif (journal->j_committing_transaction) {\n\t\t\t\tJBUFFER_TRACE(jh, \"give to committing trans\");\n\t\t\t\tmay_free = __dispose_buffer(jh,\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\t\t\tgoto zap_buffer;\n\t\t\t} else {\n\t\t\t\t/* The orphan record's transaction has\n\t\t\t\t * committed.  We can cleanse this buffer */\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\t__jbd2_journal_remove_checkpoint(jh);\n\t\t\t\tgoto zap_buffer;\n\t\t\t}\n\t\t}\n\t} else if (transaction == journal->j_committing_transaction) {\n\t\tJBUFFER_TRACE(jh, \"on committing transaction\");\n\t\t/*\n\t\t * The buffer is committing, we simply cannot touch\n\t\t * it. If the page is straddling i_size we have to wait\n\t\t * for commit and try again.\n\t\t */\n\t\tif (partial_page) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tspin_unlock(&jh->b_state_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tjbd2_journal_put_journal_head(jh);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t/*\n\t\t * OK, buffer won't be reachable after truncate. We just clear\n\t\t * b_modified to not confuse transaction credit accounting, and\n\t\t * set j_next_transaction to the running transaction (if there\n\t\t * is one) and mark buffer as freed so that commit code knows\n\t\t * it should clear dirty bits when it is done with the buffer.\n\t\t */\n\t\tset_buffer_freed(bh);\n\t\tif (journal->j_running_transaction && buffer_jbddirty(bh))\n\t\t\tjh->b_next_transaction = journal->j_running_transaction;\n\t\tjh->b_modified = 0;\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tspin_unlock(&jh->b_state_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_journal_put_journal_head(jh);\n\t\treturn 0;\n\t} else {\n\t\t/* Good, the buffer belongs to the running transaction.\n\t\t * We are writing our own transaction's data, not any\n\t\t * previous one's, so it is safe to throw it away\n\t\t * (remember that we expect the filesystem to have set\n\t\t * i_size already for this truncate so recovery will not\n\t\t * expose the disk blocks we are discarding here.) */\n\t\tJ_ASSERT_JH(jh, transaction == journal->j_running_transaction);\n\t\tJBUFFER_TRACE(jh, \"on running transaction\");\n\t\tmay_free = __dispose_buffer(jh, transaction);\n\t}\n\nzap_buffer:\n\t/*\n\t * This is tricky. Although the buffer is truncated, it may be reused\n\t * if blocksize < pagesize and it is attached to the page straddling\n\t * EOF. Since the buffer might have been added to BJ_Forget list of the\n\t * running transaction, journal_get_write_access() won't clear\n\t * b_modified and credit accounting gets confused. So clear b_modified\n\t * here.\n\t */\n\tjh->b_modified = 0;\n\tspin_unlock(&journal->j_list_lock);\n\tspin_unlock(&jh->b_state_lock);\n\twrite_unlock(&journal->j_state_lock);\n\tjbd2_journal_put_journal_head(jh);\nzap_buffer_unlocked:\n\tclear_buffer_dirty(bh);\n\tJ_ASSERT_BH(bh, !buffer_jbddirty(bh));\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tclear_buffer_delay(bh);\n\tclear_buffer_unwritten(bh);\n\tbh->b_bdev = NULL;\n\treturn may_free;\n}\n\n/**\n * jbd2_journal_invalidatepage()\n * @journal: journal to use for flush...\n * @page:    page to flush\n * @offset:  start of the range to invalidate\n * @length:  length of the range to invalidate\n *\n * Reap page buffers containing data after in the specified range in page.\n * Can return -EBUSY if buffers are part of the committing transaction and\n * the page is straddling i_size. Caller then has to wait for current commit\n * and try again.\n */\nint jbd2_journal_invalidatepage(journal_t *journal,\n\t\t\t\tstruct page *page,\n\t\t\t\tunsigned int offset,\n\t\t\t\tunsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tunsigned int stop = offset + length;\n\tunsigned int curr_off = 0;\n\tint partial_page = (offset || length < PAGE_SIZE);\n\tint may_free = 1;\n\tint ret = 0;\n\n\tif (!PageLocked(page))\n\t\tBUG();\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\n\tBUG_ON(stop > PAGE_SIZE || stop < length);\n\n\t/* We will potentially be playing with lists other than just the\n\t * data lists (especially for journaled data mode), so be\n\t * cautious in our locking. */\n\n\thead = bh = page_buffers(page);\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\tif (next_off > stop)\n\t\t\treturn 0;\n\n\t\tif (offset <= curr_off) {\n\t\t\t/* This block is wholly outside the truncation point */\n\t\t\tlock_buffer(bh);\n\t\t\tret = journal_unmap_buffer(journal, bh, partial_page);\n\t\t\tunlock_buffer(bh);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tmay_free &= ret;\n\t\t}\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\n\t} while (bh != head);\n\n\tif (!partial_page) {\n\t\tif (may_free && try_to_free_buffers(page))\n\t\t\tJ_ASSERT(!page_has_buffers(page));\n\t}\n\treturn 0;\n}\n\n/*\n * File a buffer on the given transaction list.\n */\nvoid __jbd2_journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tlockdep_assert_held(&jh->b_state_lock);\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__jbd2_journal_temp_unlink_buffer(jh);\n\telse\n\t\tjbd2_journal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}\n\nvoid jbd2_journal_file_buffer(struct journal_head *jh,\n\t\t\t\ttransaction_t *transaction, int jlist)\n{\n\tspin_lock(&jh->b_state_lock);\n\tspin_lock(&transaction->t_journal->j_list_lock);\n\t__jbd2_journal_file_buffer(jh, transaction, jlist);\n\tspin_unlock(&transaction->t_journal->j_list_lock);\n\tspin_unlock(&jh->b_state_lock);\n}\n\n/*\n * Remove a buffer from its current buffer list in preparation for\n * dropping it from its current transaction entirely.  If the buffer has\n * already started to be used by a subsequent transaction, refile the\n * buffer on that transaction's metadata list.\n *\n * Called under j_list_lock\n * Called under jh->b_state_lock\n *\n * When this function returns true, there's no next transaction to refile to\n * and the caller has to drop jh reference through\n * jbd2_journal_put_journal_head().\n */\nbool __jbd2_journal_refile_buffer(struct journal_head *jh)\n{\n\tint was_dirty, jlist;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tlockdep_assert_held(&jh->b_state_lock);\n\tif (jh->b_transaction)\n\t\tassert_spin_locked(&jh->b_transaction->t_journal->j_list_lock);\n\n\t/* If the buffer is now unused, just drop it. */\n\tif (jh->b_next_transaction == NULL) {\n\t\t__jbd2_journal_unfile_buffer(jh);\n\t\treturn true;\n\t}\n\n\t/*\n\t * It has been modified by a later transaction: add it to the new\n\t * transaction's metadata list.\n\t */\n\n\twas_dirty = test_clear_buffer_jbddirty(bh);\n\t__jbd2_journal_temp_unlink_buffer(jh);\n\n\t/*\n\t * b_transaction must be set, otherwise the new b_transaction won't\n\t * be holding jh reference\n\t */\n\tJ_ASSERT_JH(jh, jh->b_transaction != NULL);\n\n\t/*\n\t * We set b_transaction here because b_next_transaction will inherit\n\t * our jh reference and thus __jbd2_journal_file_buffer() must not\n\t * take a new one.\n\t */\n\tWRITE_ONCE(jh->b_transaction, jh->b_next_transaction);\n\tWRITE_ONCE(jh->b_next_transaction, NULL);\n\tif (buffer_freed(bh))\n\t\tjlist = BJ_Forget;\n\telse if (jh->b_modified)\n\t\tjlist = BJ_Metadata;\n\telse\n\t\tjlist = BJ_Reserved;\n\t__jbd2_journal_file_buffer(jh, jh->b_transaction, jlist);\n\tJ_ASSERT_JH(jh, jh->b_transaction->t_state == T_RUNNING);\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n\treturn false;\n}\n\n/*\n * __jbd2_journal_refile_buffer() with necessary locking added. We take our\n * bh reference so that we can safely unlock bh.\n *\n * The jh and bh may be freed by this call.\n */\nvoid jbd2_journal_refile_buffer(journal_t *journal, struct journal_head *jh)\n{\n\tbool drop;\n\n\tspin_lock(&jh->b_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\tdrop = __jbd2_journal_refile_buffer(jh);\n\tspin_unlock(&jh->b_state_lock);\n\tspin_unlock(&journal->j_list_lock);\n\tif (drop)\n\t\tjbd2_journal_put_journal_head(jh);\n}\n\n/*\n * File inode in the inode list of the handle's transaction\n */\nstatic int jbd2_journal_file_inode(handle_t *handle, struct jbd2_inode *jinode,\n\t\tunsigned long flags, loff_t start_byte, loff_t end_byte)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\n\tjbd_debug(4, \"Adding inode %lu, tid:%d\\n\", jinode->i_vfs_inode->i_ino,\n\t\t\ttransaction->t_tid);\n\n\tspin_lock(&journal->j_list_lock);\n\tjinode->i_flags |= flags;\n\n\tif (jinode->i_dirty_end) {\n\t\tjinode->i_dirty_start = min(jinode->i_dirty_start, start_byte);\n\t\tjinode->i_dirty_end = max(jinode->i_dirty_end, end_byte);\n\t} else {\n\t\tjinode->i_dirty_start = start_byte;\n\t\tjinode->i_dirty_end = end_byte;\n\t}\n\n\t/* Is inode already attached where we need it? */\n\tif (jinode->i_transaction == transaction ||\n\t    jinode->i_next_transaction == transaction)\n\t\tgoto done;\n\n\t/*\n\t * We only ever set this variable to 1 so the test is safe. Since\n\t * t_need_data_flush is likely to be set, we do the test to save some\n\t * cacheline bouncing\n\t */\n\tif (!transaction->t_need_data_flush)\n\t\ttransaction->t_need_data_flush = 1;\n\t/* On some different transaction's list - should be\n\t * the committing one */\n\tif (jinode->i_transaction) {\n\t\tJ_ASSERT(jinode->i_next_transaction == NULL);\n\t\tJ_ASSERT(jinode->i_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\tjinode->i_next_transaction = transaction;\n\t\tgoto done;\n\t}\n\t/* Not on any transaction list... */\n\tJ_ASSERT(!jinode->i_next_transaction);\n\tjinode->i_transaction = transaction;\n\tlist_add(&jinode->i_list, &transaction->t_inode_list);\ndone:\n\tspin_unlock(&journal->j_list_lock);\n\n\treturn 0;\n}\n\nint jbd2_journal_inode_ranged_write(handle_t *handle,\n\t\tstruct jbd2_inode *jinode, loff_t start_byte, loff_t length)\n{\n\treturn jbd2_journal_file_inode(handle, jinode,\n\t\t\tJI_WRITE_DATA | JI_WAIT_DATA, start_byte,\n\t\t\tstart_byte + length - 1);\n}\n\nint jbd2_journal_inode_ranged_wait(handle_t *handle, struct jbd2_inode *jinode,\n\t\tloff_t start_byte, loff_t length)\n{\n\treturn jbd2_journal_file_inode(handle, jinode, JI_WAIT_DATA,\n\t\t\tstart_byte, start_byte + length - 1);\n}\n\n/*\n * File truncate and transaction commit interact with each other in a\n * non-trivial way.  If a transaction writing data block A is\n * committing, we cannot discard the data by truncate until we have\n * written them.  Otherwise if we crashed after the transaction with\n * write has committed but before the transaction with truncate has\n * committed, we could see stale data in block A.  This function is a\n * helper to solve this problem.  It starts writeout of the truncated\n * part in case it is in the committing transaction.\n *\n * Filesystem code must call this function when inode is journaled in\n * ordered mode before truncation happens and after the inode has been\n * placed on orphan list with the new inode size. The second condition\n * avoids the race that someone writes new data and we start\n * committing the transaction after this function has been called but\n * before a transaction for truncate is started (and furthermore it\n * allows us to optimize the case where the addition to orphan list\n * happens in the same transaction as write --- we don't have to write\n * any data in such case).\n */\nint jbd2_journal_begin_ordered_truncate(journal_t *journal,\n\t\t\t\t\tstruct jbd2_inode *jinode,\n\t\t\t\t\tloff_t new_size)\n{\n\ttransaction_t *inode_trans, *commit_trans;\n\tint ret = 0;\n\n\t/* This is a quick check to avoid locking if not necessary */\n\tif (!jinode->i_transaction)\n\t\tgoto out;\n\t/* Locks are here just to force reading of recent values, it is\n\t * enough that the transaction was not committing before we started\n\t * a transaction adding the inode to orphan list */\n\tread_lock(&journal->j_state_lock);\n\tcommit_trans = journal->j_committing_transaction;\n\tread_unlock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\tinode_trans = jinode->i_transaction;\n\tspin_unlock(&journal->j_list_lock);\n\tif (inode_trans == commit_trans) {\n\t\tret = filemap_fdatawrite_range(jinode->i_vfs_inode->i_mapping,\n\t\t\tnew_size, LLONG_MAX);\n\t\tif (ret)\n\t\t\tjbd2_journal_abort(journal, ret);\n\t}\nout:\n\treturn ret;\n}\n"], "filenames": ["fs/jbd2/transaction.c"], "buggy_code_start_loc": [845], "buggy_code_end_loc": [882], "fixing_code_start_loc": [845], "fixing_code_end_loc": [890], "type": "CWE-416", "message": "jbd2_journal_wait_updates in fs/jbd2/transaction.c in the Linux kernel before 5.17.1 has a use-after-free caused by a transaction_t race condition.", "other": {"cve": {"id": "CVE-2022-28796", "sourceIdentifier": "cve@mitre.org", "published": "2022-04-08T05:15:07.067", "lastModified": "2022-05-12T20:06:19.163", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "jbd2_journal_wait_updates in fs/jbd2/transaction.c in the Linux kernel before 5.17.1 has a use-after-free caused by a transaction_t race condition."}, {"lang": "es", "value": "La funci\u00f3n jbd2_journal_wait_updates en el archivo fs/jbd2/transaction.c en el kernel de Linux versiones anteriores a 5.17.1, presenta un uso de memoria previamente liberada causado por una condici\u00f3n de carrera transaction_t"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.17.1", "matchCriteriaId": "C4C36454-2CDC-4F8D-A717-878F1C39CAD1"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F6AB192-9D7D-4A9A-8995-E53A9DE9EAFC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vsphere:*:*", "matchCriteriaId": "E8F29E19-3A64-4426-A2AA-F169440267CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire\\,_enterprise_sds_\\&_hci_storage_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "DAA3919C-B2B1-4CB5-BA76-7A079AAFFC52"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire_\\&_hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "D6D700C5-F67F-4FFB-BE69-D524592A3D2E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:hci_compute_node_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "F921BC85-568E-4B69-A3CD-CF75C76672F1"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_compute_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "AD7447BC-F315-4298-A822-549942FC118B"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "108A2215-50FB-4074-94CF-C130FA14566D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "7AFC73CE-ABB9-42D3-9A71-3F5BC5381E0E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "32F0B6C0-F930-480D-962B-3F4EFDCC13C7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "803BC414-B250-4E3A-A478-A3881340D6B8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "0FEB3337-BFDE-462A-908B-176F92053CEC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "736AEAE9-782B-4F71-9893-DED53367E102"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.17.1", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/cc16eecae687912238ee6efbff71ad31e2bc414e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220506-0006/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/cc16eecae687912238ee6efbff71ad31e2bc414e"}}