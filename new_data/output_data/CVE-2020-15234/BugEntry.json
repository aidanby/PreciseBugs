{"buggy_code": ["/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"net/url\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/asaskevich/govalidator\"\n\t\"github.com/pkg/errors\"\n)\n\n// GetRedirectURIFromRequestValues extracts the redirect_uri from values but does not do any sort of validation.\n//\n// Considered specifications\n// * https://tools.ietf.org/html/rfc6749#section-3.1.2\n//   The endpoint URI MAY include an\n//   \"application/x-www-form-urlencoded\" formatted (per Appendix B) query\n//   component ([RFC3986] Section 3.4), which MUST be retained when adding\n//   additional query parameters.\nfunc GetRedirectURIFromRequestValues(values url.Values) (string, error) {\n\t// rfc6749 3.1.   Authorization Endpoint\n\t// The endpoint URI MAY include an \"application/x-www-form-urlencoded\" formatted (per Appendix B) query component\n\tredirectURI, err := url.QueryUnescape(values.Get(\"redirect_uri\"))\n\tif err != nil {\n\t\treturn \"\", errors.WithStack(ErrInvalidRequest.WithHint(`The \"redirect_uri\" parameter is malformed or missing.`).WithCause(err).WithDebug(err.Error()))\n\t}\n\treturn redirectURI, nil\n}\n\n// MatchRedirectURIWithClientRedirectURIs if the given uri is a registered redirect uri. Does not perform\n// uri validation.\n//\n// Considered specifications\n// * https://tools.ietf.org/html/rfc6749#section-3.1.2.3\n//   If multiple redirection URIs have been registered, if only part of\n//   the redirection URI has been registered, or if no redirection URI has\n//   been registered, the client MUST include a redirection URI with the\n//   authorization request using the \"redirect_uri\" request parameter.\n//\n//   When a redirection URI is included in an authorization request, the\n//   authorization server MUST compare and match the value received\n//   against at least one of the registered redirection URIs (or URI\n//   components) as defined in [RFC3986] Section 6, if any redirection\n//   URIs were registered.  If the client registration included the full\n//   redirection URI, the authorization server MUST compare the two URIs\n//   using simple string comparison as defined in [RFC3986] Section 6.2.1.\n//\n// * https://tools.ietf.org/html/rfc6819#section-4.4.1.7\n//   * The authorization server may also enforce the usage and validation\n//     of pre-registered redirect URIs (see Section 5.2.3.5).  This will\n//     allow for early recognition of authorization \"code\" disclosure to\n//     counterfeit clients.\n//   * The attacker will need to use another redirect URI for its\n//     authorization process rather than the target web site because it\n//     needs to intercept the flow.  So, if the authorization server\n//     associates the authorization \"code\" with the redirect URI of a\n//     particular end-user authorization and validates this redirect URI\n//     with the redirect URI passed to the token's endpoint, such an\n//     attack is detected (see Section 5.2.4.5).\nfunc MatchRedirectURIWithClientRedirectURIs(rawurl string, client Client) (*url.URL, error) {\n\tif rawurl == \"\" && len(client.GetRedirectURIs()) == 1 {\n\t\tif redirectURIFromClient, err := url.Parse(client.GetRedirectURIs()[0]); err == nil && IsValidRedirectURI(redirectURIFromClient) {\n\t\t\t// If no redirect_uri was given and the client has exactly one valid redirect_uri registered, use that instead\n\t\t\treturn redirectURIFromClient, nil\n\t\t}\n\t} else if rawurl != \"\" && isMatchingRedirectURI(rawurl, client.GetRedirectURIs()) {\n\t\t// If a redirect_uri was given and the clients knows it (simple string comparison!)\n\t\t// return it.\n\t\tif parsed, err := url.Parse(rawurl); err == nil && IsValidRedirectURI(parsed) {\n\t\t\t// If no redirect_uri was given and the client has exactly one valid redirect_uri registered, use that instead\n\t\t\treturn parsed, nil\n\t\t}\n\t}\n\n\treturn nil, errors.WithStack(ErrInvalidRequest.WithHint(`The \"redirect_uri\" parameter does not match any of the OAuth 2.0 Client's pre-registered redirect urls.`))\n}\n\n// Match a requested  redirect URI against a pool of registered client URIs\n//\n// Test a given redirect URI against a pool of URIs provided by a registered client.\n// If the OAuth 2.0 Client has loopback URIs registered either an IPv4 URI http://127.0.0.1 or\n// an IPv6 URI http://[::1] a client is allowed to request a dynamic port and the server MUST accept\n// it as a valid redirection uri.\n//\n// https://tools.ietf.org/html/rfc8252#section-7.3\n// Native apps that are able to open a port on the loopback network\n// interface without needing special permissions (typically, those on\n// desktop operating systems) can use the loopback interface to receive\n// the OAuth redirect.\n//\n// Loopback redirect URIs use the \"http\" scheme and are constructed with\n// the loopback IP literal and whatever port the client is listening on.\nfunc isMatchingRedirectURI(uri string, haystack []string) bool {\n\trequested, err := url.Parse(uri)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tfor _, b := range haystack {\n\t\tif strings.ToLower(b) == strings.ToLower(uri) || isLoopbackURI(requested, b) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc isLoopbackURI(requested *url.URL, registeredURI string) bool {\n\tregistered, err := url.Parse(registeredURI)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tif registered.Scheme != \"http\" || !isLoopbackAddress(registered.Host) {\n\t\treturn false\n\t}\n\n\tif requested.Scheme == \"http\" && isLoopbackAddress(requested.Host) && registered.Path == requested.Path {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// Check if address is either an IPv4 loopback or an IPv6 loopback-\n// An optional port is ignored\nfunc isLoopbackAddress(address string) bool {\n\tmatch, _ := regexp.MatchString(\"^(127.0.0.1|\\\\[::1\\\\])(:?)(\\\\d*)$\", address)\n\treturn match\n}\n\n// IsValidRedirectURI validates a redirect_uri as specified in:\n//\n// * https://tools.ietf.org/html/rfc6749#section-3.1.2\n//   * The redirection endpoint URI MUST be an absolute URI as defined by [RFC3986] Section 4.3.\n//   * The endpoint URI MUST NOT include a fragment component.\n// * https://tools.ietf.org/html/rfc3986#section-4.3\n//   absolute-URI  = scheme \":\" hier-part [ \"?\" query ]\n// * https://tools.ietf.org/html/rfc6819#section-5.1.1\nfunc IsValidRedirectURI(redirectURI *url.URL) bool {\n\t// We need to explicitly check for a scheme\n\tif !govalidator.IsRequestURL(redirectURI.String()) {\n\t\treturn false\n\t}\n\n\tif redirectURI.Fragment != \"\" {\n\t\t// \"The endpoint URI MUST NOT include a fragment component.\"\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc IsRedirectURISecure(redirectURI *url.URL) bool {\n\treturn !(redirectURI.Scheme == \"http\" && !IsLocalhost(redirectURI))\n}\n\nfunc IsLocalhost(redirectURI *url.URL) bool {\n\thn := redirectURI.Hostname()\n\treturn strings.HasSuffix(hn, \".localhost\") || hn == \"127.0.0.1\" || hn == \"localhost\"\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"net/url\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestIsLocalhost(t *testing.T) {\n\tfor k, c := range []struct {\n\t\texpect bool\n\t\trawurl string\n\t}{\n\t\t{expect: false, rawurl: \"https://foo.bar\"},\n\t\t{expect: true, rawurl: \"https://localhost\"},\n\t\t{expect: true, rawurl: \"https://localhost:1234\"},\n\t\t{expect: true, rawurl: \"https://127.0.0.1:1234\"},\n\t\t{expect: true, rawurl: \"https://127.0.0.1\"},\n\t\t{expect: true, rawurl: \"https://test.localhost:1234\"},\n\t\t{expect: true, rawurl: \"https://test.localhost\"},\n\t} {\n\t\tu, _ := url.Parse(c.rawurl)\n\t\tassert.Equal(t, c.expect, IsLocalhost(u), \"case %d\", k)\n\t}\n}\n\n// Test for\n// * https://tools.ietf.org/html/rfc6749#section-3.1.2\n//   The endpoint URI MAY include an\n//   \"application/x-www-form-urlencoded\" formatted (per Appendix B) query\n//   component ([RFC3986] Section 3.4), which MUST be retained when adding\n//   additional query parameters.\nfunc TestGetRedirectURI(t *testing.T) {\n\tfor k, c := range []struct {\n\t\tin       string\n\t\tisError  bool\n\t\texpected string\n\t}{\n\t\t{in: \"\", isError: false, expected: \"\"},\n\t\t{in: \"https://google.com/\", isError: false, expected: \"https://google.com/\"},\n\t\t{in: \"https://google.com/?foo=bar%20foo+baz\", isError: false, expected: \"https://google.com/?foo=bar foo baz\"},\n\t} {\n\t\tvalues := url.Values{}\n\t\tvalues.Set(\"redirect_uri\", c.in)\n\t\tres, err := GetRedirectURIFromRequestValues(values)\n\t\tassert.Equal(t, c.isError, err != nil, \"%s\", err)\n\t\tif err == nil {\n\t\t\tassert.Equal(t, c.expected, res)\n\t\t}\n\t\tt.Logf(\"Passed test case %d\", k)\n\t}\n}\n\n// rfc6749 10.6.\n// Authorization Code Redirection URI Manipulation\n// The authorization server\tMUST require public clients and SHOULD require confidential clients\n// to register their redirection URIs.  If a redirection URI is provided\n// in the request, the authorization server MUST validate it against the\n// registered value.\n//\n// rfc6819 4.4.1.7.\n// Threat: Authorization \"code\" Leakage through Counterfeit Client\n// The authorization server may also enforce the usage and validation\n// of pre-registered redirect URIs (see Section 5.2.3.5).\nfunc TestDoesClientWhiteListRedirect(t *testing.T) {\n\tfor k, c := range []struct {\n\t\tclient   Client\n\t\turl      string\n\t\tisError  bool\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"\"}},\n\t\t\turl:     \"https://foo.com/cb\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"wta://auth\"}},\n\t\t\turl:      \"wta://auth\",\n\t\t\texpected: \"wta://auth\",\n\t\t\tisError:  false,\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"wta:///auth\"}},\n\t\t\turl:      \"wta:///auth\",\n\t\t\texpected: \"wta:///auth\",\n\t\t\tisError:  false,\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"wta://foo/auth\"}},\n\t\t\turl:      \"wta://foo/auth\",\n\t\t\texpected: \"wta://foo/auth\",\n\t\t\tisError:  false,\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"https://bar.com/cb\"}},\n\t\t\turl:     \"https://foo.com/cb\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"https://bar.com/cb\"}},\n\t\t\turl:      \"\",\n\t\t\tisError:  false,\n\t\t\texpected: \"https://bar.com/cb\",\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"\"}},\n\t\t\turl:     \"\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"https://bar.com/cb\"}},\n\t\t\turl:      \"https://bar.com/cb\",\n\t\t\tisError:  false,\n\t\t\texpected: \"https://bar.com/cb\",\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"https://bar.Com/cb\"}},\n\t\t\turl:      \"https://bar.com/cb\",\n\t\t\tisError:  false,\n\t\t\texpected: \"https://bar.com/cb\",\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"https://bar.com/cb\"}},\n\t\t\turl:      \"https://bar.Com/cb\",\n\t\t\tisError:  false,\n\t\t\texpected: \"https://bar.Com/cb\",\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"https://bar.com/cb\"}},\n\t\t\turl:     \"https://bar.com/cb123\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"http://[::1]\"}},\n\t\t\turl:      \"http://[::1]:1024\",\n\t\t\tisError:  false,\n\t\t\texpected: \"http://[::1]:1024\",\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://[::1]\"}},\n\t\t\turl:     \"http://[::1]:1024/cb\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"http://[::1]/cb\"}},\n\t\t\turl:      \"http://[::1]:1024/cb\",\n\t\t\tisError:  false,\n\t\t\texpected: \"http://[::1]:1024/cb\",\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://[::1]\"}},\n\t\t\turl:     \"http://foo.bar/bar\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1\"}},\n\t\t\turl:      \"http://127.0.0.1:1024\",\n\t\t\tisError:  false,\n\t\t\texpected: \"http://127.0.0.1:1024\",\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1/cb\"}},\n\t\t\turl:      \"http://127.0.0.1:64000/cb\",\n\t\t\tisError:  false,\n\t\t\texpected: \"http://127.0.0.1:64000/cb\",\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1\"}},\n\t\t\turl:     \"http://127.0.0.1:64000/cb\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1\"}},\n\t\t\turl:      \"http://127.0.0.1\",\n\t\t\tisError:  false,\n\t\t\texpected: \"http://127.0.0.1\",\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1/Cb\"}},\n\t\t\turl:      \"http://127.0.0.1:8080/Cb\",\n\t\t\tisError:  false,\n\t\t\texpected: \"http://127.0.0.1:8080/Cb\",\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1\"}},\n\t\t\turl:     \"http://foo.bar/bar\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1\"}},\n\t\t\turl:     \":/invalid.uri)bar\",\n\t\t\tisError: true,\n\t\t},\n\t} {\n\t\tredir, err := MatchRedirectURIWithClientRedirectURIs(c.url, c.client)\n\t\tassert.Equal(t, c.isError, err != nil, \"%d: %s\", k, err)\n\t\tif err == nil {\n\t\t\trequire.NotNil(t, redir, \"%d\", k)\n\t\t\tassert.Equal(t, c.expected, redir.String(), \"%d\", k)\n\t\t}\n\t\tt.Logf(\"Passed test case %d\", k)\n\t}\n}\n\nfunc TestIsRedirectURISecure(t *testing.T) {\n\tfor d, c := range []struct {\n\t\tu   string\n\t\terr bool\n\t}{\n\t\t{u: \"http://google.com\", err: true},\n\t\t{u: \"https://google.com\", err: false},\n\t\t{u: \"http://localhost\", err: false},\n\t\t{u: \"http://test.localhost\", err: false},\n\t\t{u: \"http://127.0.0.1/\", err: false},\n\t\t{u: \"http://testlocalhost\", err: true},\n\t\t{u: \"wta://auth\", err: false},\n\t} {\n\t\tuu, err := url.Parse(c.u)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, !c.err, IsRedirectURISecure(uu), \"case %d\", d)\n\t}\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestStringInSlice(t *testing.T) {\n\tfor k, c := range []struct {\n\t\tneedle   string\n\t\thaystack []string\n\t\tok       bool\n\t}{\n\t\t{needle: \"foo\", haystack: []string{\"foo\", \"bar\"}, ok: true},\n\t\t{needle: \"bar\", haystack: []string{\"foo\", \"bar\"}, ok: true},\n\t\t{needle: \"baz\", haystack: []string{\"foo\", \"bar\"}, ok: false},\n\t\t{needle: \"foo\", haystack: []string{\"bar\"}, ok: false},\n\t\t{needle: \"bar\", haystack: []string{\"bar\"}, ok: true},\n\t\t{needle: \"foo\", haystack: []string{}, ok: false},\n\t} {\n\t\tassert.Equal(t, c.ok, StringInSlice(c.needle, c.haystack), \"%d\", k)\n\t\tt.Logf(\"Passed test case %d\", k)\n\t}\n}\n\nfunc TestEscapeJSONString(t *testing.T) {\n\tfor _, str := range []string{\"\", \"foobar\", `foo\"bar`, `foo\\bar`, \"foo\\n\\tbar\"} {\n\t\tescaped := EscapeJSONString(str)\n\t\tvar unmarshaled string\n\t\terr := json.Unmarshal([]byte(`\"` + escaped + `\"`), &unmarshaled)\n\t\trequire.NoError(t, err, str)\n\t\tassert.Equal(t, str, unmarshaled, str)\n\t}\n}\n"], "fixing_code": ["/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"net/url\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/asaskevich/govalidator\"\n\t\"github.com/pkg/errors\"\n)\n\n// GetRedirectURIFromRequestValues extracts the redirect_uri from values but does not do any sort of validation.\n//\n// Considered specifications\n// * https://tools.ietf.org/html/rfc6749#section-3.1.2\n//   The endpoint URI MAY include an\n//   \"application/x-www-form-urlencoded\" formatted (per Appendix B) query\n//   component ([RFC3986] Section 3.4), which MUST be retained when adding\n//   additional query parameters.\nfunc GetRedirectURIFromRequestValues(values url.Values) (string, error) {\n\t// rfc6749 3.1.   Authorization Endpoint\n\t// The endpoint URI MAY include an \"application/x-www-form-urlencoded\" formatted (per Appendix B) query component\n\tredirectURI, err := url.QueryUnescape(values.Get(\"redirect_uri\"))\n\tif err != nil {\n\t\treturn \"\", errors.WithStack(ErrInvalidRequest.WithHint(`The \"redirect_uri\" parameter is malformed or missing.`).WithCause(err).WithDebug(err.Error()))\n\t}\n\treturn redirectURI, nil\n}\n\n// MatchRedirectURIWithClientRedirectURIs if the given uri is a registered redirect uri. Does not perform\n// uri validation.\n//\n// Considered specifications\n// * https://tools.ietf.org/html/rfc6749#section-3.1.2.3\n//   If multiple redirection URIs have been registered, if only part of\n//   the redirection URI has been registered, or if no redirection URI has\n//   been registered, the client MUST include a redirection URI with the\n//   authorization request using the \"redirect_uri\" request parameter.\n//\n//   When a redirection URI is included in an authorization request, the\n//   authorization server MUST compare and match the value received\n//   against at least one of the registered redirection URIs (or URI\n//   components) as defined in [RFC3986] Section 6, if any redirection\n//   URIs were registered.  If the client registration included the full\n//   redirection URI, the authorization server MUST compare the two URIs\n//   using simple string comparison as defined in [RFC3986] Section 6.2.1.\n//\n// * https://tools.ietf.org/html/rfc6819#section-4.4.1.7\n//   * The authorization server may also enforce the usage and validation\n//     of pre-registered redirect URIs (see Section 5.2.3.5).  This will\n//     allow for early recognition of authorization \"code\" disclosure to\n//     counterfeit clients.\n//   * The attacker will need to use another redirect URI for its\n//     authorization process rather than the target web site because it\n//     needs to intercept the flow.  So, if the authorization server\n//     associates the authorization \"code\" with the redirect URI of a\n//     particular end-user authorization and validates this redirect URI\n//     with the redirect URI passed to the token's endpoint, such an\n//     attack is detected (see Section 5.2.4.5).\nfunc MatchRedirectURIWithClientRedirectURIs(rawurl string, client Client) (*url.URL, error) {\n\tif rawurl == \"\" && len(client.GetRedirectURIs()) == 1 {\n\t\tif redirectURIFromClient, err := url.Parse(client.GetRedirectURIs()[0]); err == nil && IsValidRedirectURI(redirectURIFromClient) {\n\t\t\t// If no redirect_uri was given and the client has exactly one valid redirect_uri registered, use that instead\n\t\t\treturn redirectURIFromClient, nil\n\t\t}\n\t} else if rawurl != \"\" && isMatchingRedirectURI(rawurl, client.GetRedirectURIs()) {\n\t\t// If a redirect_uri was given and the clients knows it (simple string comparison!)\n\t\t// return it.\n\t\tif parsed, err := url.Parse(rawurl); err == nil && IsValidRedirectURI(parsed) {\n\t\t\t// If no redirect_uri was given and the client has exactly one valid redirect_uri registered, use that instead\n\t\t\treturn parsed, nil\n\t\t}\n\t}\n\n\treturn nil, errors.WithStack(ErrInvalidRequest.WithHint(`The \"redirect_uri\" parameter does not match any of the OAuth 2.0 Client's pre-registered redirect urls.`))\n}\n\n// Match a requested  redirect URI against a pool of registered client URIs\n//\n// Test a given redirect URI against a pool of URIs provided by a registered client.\n// If the OAuth 2.0 Client has loopback URIs registered either an IPv4 URI http://127.0.0.1 or\n// an IPv6 URI http://[::1] a client is allowed to request a dynamic port and the server MUST accept\n// it as a valid redirection uri.\n//\n// https://tools.ietf.org/html/rfc8252#section-7.3\n// Native apps that are able to open a port on the loopback network\n// interface without needing special permissions (typically, those on\n// desktop operating systems) can use the loopback interface to receive\n// the OAuth redirect.\n//\n// Loopback redirect URIs use the \"http\" scheme and are constructed with\n// the loopback IP literal and whatever port the client is listening on.\nfunc isMatchingRedirectURI(uri string, haystack []string) bool {\n\trequested, err := url.Parse(uri)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tfor _, b := range haystack {\n\t\tif b == uri || isMatchingAsLoopback(requested, b) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc isMatchingAsLoopback(requested *url.URL, registeredURI string) bool {\n\tregistered, err := url.Parse(registeredURI)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\t// Native apps that are able to open a port on the loopback network\n\t// interface without needing special permissions (typically, those on\n\t// desktop operating systems) can use the loopback interface to receive\n\t// the OAuth redirect.\n\t//\n\t// Loopback redirect URIs use the \"http\" scheme and are constructed with\n\t// the loopback IP literal and whatever port the client is listening on.\n\t//\n\t// Source: https://tools.ietf.org/html/rfc8252#section-7.3\n\tif requested.Scheme == \"http\" &&\n\t\tisLoopbackAddress(requested.Host) &&\n\t\tregistered.Hostname() == requested.Hostname() &&\n\t\t// The port is skipped here - see codedoc above!\n\t\tregistered.Path == requested.Path &&\n\t\tregistered.RawQuery == requested.RawQuery {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// Check if address is either an IPv4 loopback or an IPv6 loopback-\n// An optional port is ignored\nfunc isLoopbackAddress(address string) bool {\n\tmatch, _ := regexp.MatchString(\"^(127.0.0.1|\\\\[::1\\\\])(:?)(\\\\d*)$\", address)\n\treturn match\n}\n\n// IsValidRedirectURI validates a redirect_uri as specified in:\n//\n// * https://tools.ietf.org/html/rfc6749#section-3.1.2\n//   * The redirection endpoint URI MUST be an absolute URI as defined by [RFC3986] Section 4.3.\n//   * The endpoint URI MUST NOT include a fragment component.\n// * https://tools.ietf.org/html/rfc3986#section-4.3\n//   absolute-URI  = scheme \":\" hier-part [ \"?\" query ]\n// * https://tools.ietf.org/html/rfc6819#section-5.1.1\nfunc IsValidRedirectURI(redirectURI *url.URL) bool {\n\t// We need to explicitly check for a scheme\n\tif !govalidator.IsRequestURL(redirectURI.String()) {\n\t\treturn false\n\t}\n\n\tif redirectURI.Fragment != \"\" {\n\t\t// \"The endpoint URI MUST NOT include a fragment component.\"\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc IsRedirectURISecure(redirectURI *url.URL) bool {\n\treturn !(redirectURI.Scheme == \"http\" && !IsLocalhost(redirectURI))\n}\n\nfunc IsLocalhost(redirectURI *url.URL) bool {\n\thn := redirectURI.Hostname()\n\treturn strings.HasSuffix(hn, \".localhost\") || hn == \"127.0.0.1\" || hn == \"localhost\"\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"net/url\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestIsLocalhost(t *testing.T) {\n\tfor k, c := range []struct {\n\t\texpect bool\n\t\trawurl string\n\t}{\n\t\t{expect: false, rawurl: \"https://foo.bar\"},\n\t\t{expect: true, rawurl: \"https://localhost\"},\n\t\t{expect: true, rawurl: \"https://localhost:1234\"},\n\t\t{expect: true, rawurl: \"https://127.0.0.1:1234\"},\n\t\t{expect: true, rawurl: \"https://127.0.0.1\"},\n\t\t{expect: true, rawurl: \"https://test.localhost:1234\"},\n\t\t{expect: true, rawurl: \"https://test.localhost\"},\n\t} {\n\t\tu, _ := url.Parse(c.rawurl)\n\t\tassert.Equal(t, c.expect, IsLocalhost(u), \"case %d\", k)\n\t}\n}\n\n// Test for\n// * https://tools.ietf.org/html/rfc6749#section-3.1.2\n//   The endpoint URI MAY include an\n//   \"application/x-www-form-urlencoded\" formatted (per Appendix B) query\n//   component ([RFC3986] Section 3.4), which MUST be retained when adding\n//   additional query parameters.\nfunc TestGetRedirectURI(t *testing.T) {\n\tfor k, c := range []struct {\n\t\tin       string\n\t\tisError  bool\n\t\texpected string\n\t}{\n\t\t{in: \"\", isError: false, expected: \"\"},\n\t\t{in: \"https://google.com/\", isError: false, expected: \"https://google.com/\"},\n\t\t{in: \"https://google.com/?foo=bar%20foo+baz\", isError: false, expected: \"https://google.com/?foo=bar foo baz\"},\n\t} {\n\t\tvalues := url.Values{}\n\t\tvalues.Set(\"redirect_uri\", c.in)\n\t\tres, err := GetRedirectURIFromRequestValues(values)\n\t\tassert.Equal(t, c.isError, err != nil, \"%s\", err)\n\t\tif err == nil {\n\t\t\tassert.Equal(t, c.expected, res)\n\t\t}\n\t\tt.Logf(\"Passed test case %d\", k)\n\t}\n}\n\n// rfc6749 10.6.\n// Authorization Code Redirection URI Manipulation\n// The authorization server\tMUST require public clients and SHOULD require confidential clients\n// to register their redirection URIs.  If a redirection URI is provided\n// in the request, the authorization server MUST validate it against the\n// registered value.\n//\n// rfc6819 4.4.1.7.\n// Threat: Authorization \"code\" Leakage through Counterfeit Client\n// The authorization server may also enforce the usage and validation\n// of pre-registered redirect URIs (see Section 5.2.3.5).\nfunc TestDoesClientWhiteListRedirect(t *testing.T) {\n\tfor k, c := range []struct {\n\t\tclient   Client\n\t\turl      string\n\t\tisError  bool\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"\"}},\n\t\t\turl:     \"https://foo.com/cb\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"wta://auth\"}},\n\t\t\turl:      \"wta://auth\",\n\t\t\texpected: \"wta://auth\",\n\t\t\tisError:  false,\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"wta:///auth\"}},\n\t\t\turl:      \"wta:///auth\",\n\t\t\texpected: \"wta:///auth\",\n\t\t\tisError:  false,\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"wta://foo/auth\"}},\n\t\t\turl:      \"wta://foo/auth\",\n\t\t\texpected: \"wta://foo/auth\",\n\t\t\tisError:  false,\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"https://bar.com/cb\"}},\n\t\t\turl:     \"https://foo.com/cb\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"https://bar.com/cb\"}},\n\t\t\turl:      \"\",\n\t\t\tisError:  false,\n\t\t\texpected: \"https://bar.com/cb\",\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"\"}},\n\t\t\turl:     \"\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"https://bar.com/cb\"}},\n\t\t\turl:      \"https://bar.com/cb\",\n\t\t\tisError:  false,\n\t\t\texpected: \"https://bar.com/cb\",\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"https://bar.com/cb\"}},\n\t\t\turl:     \"https://bar.com/cb123\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"http://[::1]\"}},\n\t\t\turl:      \"http://[::1]:1024\",\n\t\t\texpected: \"http://[::1]:1024\",\n\t\t\tisError:  false,\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://[::1]\"}},\n\t\t\turl:     \"http://[::1]:1024/cb\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"http://[::1]/cb\"}},\n\t\t\turl:      \"http://[::1]:1024/cb\",\n\t\t\texpected: \"http://[::1]:1024/cb\",\n\t\t\tisError:  false,\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://[::1]\"}},\n\t\t\turl:     \"http://foo.bar/bar\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1\"}},\n\t\t\turl:      \"http://127.0.0.1:1024\",\n\t\t\texpected: \"http://127.0.0.1:1024\",\n\t\t\tisError:  false,\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1/cb\"}},\n\t\t\turl:      \"http://127.0.0.1:64000/cb\",\n\t\t\texpected: \"http://127.0.0.1:64000/cb\",\n\t\t\tisError:  false,\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1\"}},\n\t\t\turl:     \"http://127.0.0.1:64000/cb\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1\"}},\n\t\t\turl:      \"http://127.0.0.1\",\n\t\t\texpected: \"http://127.0.0.1\",\n\t\t\tisError:  false,\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1/Cb\"}},\n\t\t\turl:      \"http://127.0.0.1:8080/Cb\",\n\t\t\texpected: \"http://127.0.0.1:8080/Cb\",\n\t\t\tisError:  false,\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1\"}},\n\t\t\turl:     \"http://foo.bar/bar\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1\"}},\n\t\t\turl:     \":/invalid.uri)bar\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1:8080/cb\"}},\n\t\t\turl:     \"http://127.0.0.1:8080/Cb\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1:8080/cb\"}},\n\t\t\turl:     \"http://127.0.0.1:8080/cb?foo=bar\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:   &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1:8080/cb?foo=bar\"}},\n\t\t\turl:      \"http://127.0.0.1:8080/cb?foo=bar\",\n\t\t\texpected: \"http://127.0.0.1:8080/cb?foo=bar\",\n\t\t\tisError:  false,\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1:8080/cb?foo=bar\"}},\n\t\t\turl:     \"http://127.0.0.1:8080/cb?baz=bar&foo=bar\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1:8080/cb?foo=bar&baz=bar\"}},\n\t\t\turl:     \"http://127.0.0.1:8080/cb?baz=bar&foo=bar\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"https://www.ory.sh/cb\"}},\n\t\t\turl:     \"http://127.0.0.1:8080/cb\",\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tclient:  &DefaultClient{RedirectURIs: []string{\"http://127.0.0.1:8080/cb\"}},\n\t\t\turl:     \"https://www.ory.sh/cb\",\n\t\t\tisError: true,\n\t\t},\n\t} {\n\t\tredir, err := MatchRedirectURIWithClientRedirectURIs(c.url, c.client)\n\t\tassert.Equal(t, c.isError, err != nil, \"%d: %+v\", k, c)\n\t\tif err == nil {\n\t\t\trequire.NotNil(t, redir, \"%d\", k)\n\t\t\tassert.Equal(t, c.expected, redir.String(), \"%d\", k)\n\t\t}\n\t\tt.Logf(\"Passed test case %d\", k)\n\t}\n}\n\nfunc TestIsRedirectURISecure(t *testing.T) {\n\tfor d, c := range []struct {\n\t\tu   string\n\t\terr bool\n\t}{\n\t\t{u: \"http://google.com\", err: true},\n\t\t{u: \"https://google.com\", err: false},\n\t\t{u: \"http://localhost\", err: false},\n\t\t{u: \"http://test.localhost\", err: false},\n\t\t{u: \"http://127.0.0.1/\", err: false},\n\t\t{u: \"http://testlocalhost\", err: true},\n\t\t{u: \"wta://auth\", err: false},\n\t} {\n\t\tuu, err := url.Parse(c.u)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, !c.err, IsRedirectURISecure(uu), \"case %d\", d)\n\t}\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestStringInSlice(t *testing.T) {\n\tfor k, c := range []struct {\n\t\tneedle   string\n\t\thaystack []string\n\t\tok       bool\n\t}{\n\t\t{needle: \"foo\", haystack: []string{\"foo\", \"bar\"}, ok: true},\n\t\t{needle: \"bar\", haystack: []string{\"foo\", \"bar\"}, ok: true},\n\t\t{needle: \"baz\", haystack: []string{\"foo\", \"bar\"}, ok: false},\n\t\t{needle: \"foo\", haystack: []string{\"bar\"}, ok: false},\n\t\t{needle: \"bar\", haystack: []string{\"bar\"}, ok: true},\n\t\t{needle: \"foo\", haystack: []string{}, ok: false},\n\t} {\n\t\tassert.Equal(t, c.ok, StringInSlice(c.needle, c.haystack), \"%d\", k)\n\t\tt.Logf(\"Passed test case %d\", k)\n\t}\n}\n\nfunc TestEscapeJSONString(t *testing.T) {\n\tfor _, str := range []string{\"\", \"foobar\", `foo\"bar`, `foo\\bar`, \"foo\\n\\tbar\"} {\n\t\tescaped := EscapeJSONString(str)\n\t\tvar unmarshaled string\n\t\terr := json.Unmarshal([]byte(`\"`+escaped+`\"`), &unmarshaled)\n\t\trequire.NoError(t, err, str)\n\t\tassert.Equal(t, str, unmarshaled, str)\n\t}\n}\n"], "filenames": ["authorize_helper.go", "authorize_helper_test.go", "helper_test.go"], "buggy_code_start_loc": [121, 141, 54], "buggy_code_end_loc": [139, 221, 55], "fixing_code_start_loc": [121, 140, 54], "fixing_code_end_loc": [149, 245, 55], "type": "CWE-178", "message": "ORY Fosite is a security first OAuth2 & OpenID Connect framework for Go. In Fosite before version 0.34.1, the OAuth 2.0 Client's registered redirect URLs and the redirect URL provided at the OAuth2 Authorization Endpoint where compared using strings.ToLower while they should have been compared with a simple string match. This allows an attacker to register a client with allowed redirect URL https://example.com/callback. Then perform an OAuth2 flow and requesting redirect URL https://example.com/CALLBACK. Instead of an error (invalid redirect URL), the browser is redirected to https://example.com/CALLBACK with a potentially successful OAuth2 response, depending on the state of the overall OAuth2 flow (the user might still deny the request for example). This vulnerability has been patched in ORY Fosite v0.34.1.", "other": {"cve": {"id": "CVE-2020-15234", "sourceIdentifier": "security-advisories@github.com", "published": "2020-10-02T21:15:12.513", "lastModified": "2021-11-18T16:52:36.403", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ORY Fosite is a security first OAuth2 & OpenID Connect framework for Go. In Fosite before version 0.34.1, the OAuth 2.0 Client's registered redirect URLs and the redirect URL provided at the OAuth2 Authorization Endpoint where compared using strings.ToLower while they should have been compared with a simple string match. This allows an attacker to register a client with allowed redirect URL https://example.com/callback. Then perform an OAuth2 flow and requesting redirect URL https://example.com/CALLBACK. Instead of an error (invalid redirect URL), the browser is redirected to https://example.com/CALLBACK with a potentially successful OAuth2 response, depending on the state of the overall OAuth2 flow (the user might still deny the request for example). This vulnerability has been patched in ORY Fosite v0.34.1."}, {"lang": "es", "value": "ORY Fosite es el primer framework de seguridad OAuth2 y OpenID Connect para Go.&#xa0;En Fosite versiones anteriores a 0.34.1, las URL de redireccionamiento registradas del cliente OAuth versi\u00f3n 2.0 y la URL de redireccionamiento proporcionada en el OAuth2 Authorization Endpoint se compararon usando strings.ToLower, aunque deber\u00edan haberse comparado con una coincidencia de cadena simple.&#xa0;Esto permite a un atacante registrar un cliente con la URL de redireccionamiento permitida https://example.com/callback.&#xa0;Luego, llevar a cabo un flujo de OAuth2 y solicitando la URL de redireccionamiento https://example.com/CALLBACK.&#xa0;En lugar de un error (una URL de redireccionamiento no v\u00e1lida), el navegador es redireccionado a https://example.com/CALLBACK con una respuesta OAuth2 potencialmente exitosa, dependiendo del estado del flujo OAuth2 general (el usuario a\u00fan puede denegar la petici\u00f3n, por ejemplo ).&#xa0;Esta vulnerabilidad ha sido parcheada en ORY Fosite versi\u00f3n v0.34.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.7, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-178"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ory:fosite:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.34.1", "matchCriteriaId": "93BF64E6-5CA3-4E91-A6B3-DBD8B6AE6B73"}]}]}], "references": [{"url": "https://github.com/ory/fosite/commit/cdee51ebe721bfc8acca0fd0b86b030ca70867bf", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ory/fosite/security/advisories/GHSA-grfp-q2mm-hfp6", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ory/fosite/commit/cdee51ebe721bfc8acca0fd0b86b030ca70867bf"}}