{"buggy_code": ["/*\n * This file Copyright (C) 2008-2014 Mnemosyne LLC\n *\n * It may be used under the GNU GPL versions 2 or 3\n * or any future license endorsed by Mnemosyne LLC.\n *\n */\n\n#if defined(HAVE_USELOCALE) && (!defined(_XOPEN_SOURCE) || _XOPEN_SOURCE < 700)\n#undef _XOPEN_SOURCE\n#define _XOPEN_SOURCE 700\n#endif\n\n#if defined(HAVE_USELOCALE) && !defined(_GNU_SOURCE)\n#define _GNU_SOURCE\n#endif\n\n#include <errno.h>\n#include <stdlib.h> /* strtod(), realloc(), qsort() */\n#include <string.h>\n\n#ifdef _WIN32\n#include <share.h>\n#endif\n\n#include <locale.h> /* setlocale() */\n\n#if defined(HAVE_USELOCALE) && defined(HAVE_XLOCALE_H)\n#include <xlocale.h>\n#endif\n\n#include <event2/buffer.h>\n\n#define __LIBTRANSMISSION_VARIANT_MODULE__\n\n#include \"transmission.h\"\n#include \"ConvertUTF.h\"\n#include \"error.h\"\n#include \"file.h\"\n#include \"log.h\"\n#include \"tr-assert.h\"\n#include \"utils.h\" /* tr_new(), tr_free() */\n#include \"variant.h\"\n#include \"variant-common.h\"\n\n/* don't use newlocale/uselocale on old versions of uClibc because they're buggy.\n * https://trac.transmissionbt.com/ticket/6006 */\n#if defined(__UCLIBC__) && !TR_UCLIBC_CHECK_VERSION(0, 9, 34)\n#undef HAVE_USELOCALE\n#endif\n\n/**\n***\n**/\n\nstruct locale_context\n{\n#ifdef HAVE_USELOCALE\n    locale_t new_locale;\n    locale_t old_locale;\n#else\n#if defined(HAVE__CONFIGTHREADLOCALE) && defined(_ENABLE_PER_THREAD_LOCALE)\n    int old_thread_config;\n#endif\n    int category;\n    char old_locale[128];\n#endif\n};\n\nstatic void use_numeric_locale(struct locale_context* context, char const* locale_name)\n{\n#ifdef HAVE_USELOCALE\n\n    context->new_locale = newlocale(LC_NUMERIC_MASK, locale_name, NULL);\n    context->old_locale = uselocale(context->new_locale);\n\n#else\n\n#if defined(HAVE__CONFIGTHREADLOCALE) && defined(_ENABLE_PER_THREAD_LOCALE)\n    context->old_thread_config = _configthreadlocale(_ENABLE_PER_THREAD_LOCALE);\n#endif\n\n    context->category = LC_NUMERIC;\n    tr_strlcpy(context->old_locale, setlocale(context->category, NULL), sizeof(context->old_locale));\n    setlocale(context->category, locale_name);\n\n#endif\n}\n\nstatic void restore_locale(struct locale_context* context)\n{\n#ifdef HAVE_USELOCALE\n\n    uselocale(context->old_locale);\n    freelocale(context->new_locale);\n\n#else\n\n    setlocale(context->category, context->old_locale);\n\n#if defined(HAVE__CONFIGTHREADLOCALE) && defined(_ENABLE_PER_THREAD_LOCALE)\n    _configthreadlocale(context->old_thread_config);\n#endif\n\n#endif\n}\n\n/***\n****\n***/\n\nstatic bool tr_variantIsContainer(tr_variant const* v)\n{\n    return tr_variantIsList(v) || tr_variantIsDict(v);\n}\n\nstatic bool tr_variantIsSomething(tr_variant const* v)\n{\n    return tr_variantIsContainer(v) || tr_variantIsInt(v) || tr_variantIsString(v) || tr_variantIsReal(v) ||\n        tr_variantIsBool(v);\n}\n\nvoid tr_variantInit(tr_variant* v, char type)\n{\n    v->type = type;\n    memset(&v->val, 0, sizeof(v->val));\n}\n\n/***\n****\n***/\n\nstatic struct tr_variant_string const STRING_INIT =\n{\n    .type = TR_STRING_TYPE_QUARK,\n    .quark = TR_KEY_NONE,\n    .len = 0,\n    .str.str = \"\"\n};\n\nstatic void tr_variant_string_clear(struct tr_variant_string* str)\n{\n    if (str->type == TR_STRING_TYPE_HEAP)\n    {\n        tr_free((char*)(str->str.str));\n    }\n\n    *str = STRING_INIT;\n}\n\n/* returns a const pointer to the variant's string */\nstatic char const* tr_variant_string_get_string(struct tr_variant_string const* str)\n{\n    char const* ret;\n\n    switch (str->type)\n    {\n    case TR_STRING_TYPE_BUF:\n        ret = str->str.buf;\n        break;\n\n    case TR_STRING_TYPE_HEAP:\n        ret = str->str.str;\n        break;\n\n    case TR_STRING_TYPE_QUARK:\n        ret = str->str.str;\n        break;\n\n    default:\n        ret = NULL;\n    }\n\n    return ret;\n}\n\nstatic void tr_variant_string_set_quark(struct tr_variant_string* str, tr_quark const quark)\n{\n    tr_variant_string_clear(str);\n\n    str->type = TR_STRING_TYPE_QUARK;\n    str->quark = quark;\n    str->str.str = tr_quark_get_string(quark, &str->len);\n}\n\nstatic void tr_variant_string_set_string(struct tr_variant_string* str, char const* bytes, size_t len)\n{\n    tr_variant_string_clear(str);\n\n    if (bytes == NULL)\n    {\n        len = 0;\n    }\n    else if (len == TR_BAD_SIZE)\n    {\n        len = strlen(bytes);\n    }\n\n    if (len < sizeof(str->str.buf))\n    {\n        str->type = TR_STRING_TYPE_BUF;\n        memcpy(str->str.buf, bytes, len);\n        str->str.buf[len] = '\\0';\n        str->len = len;\n    }\n    else\n    {\n        char* tmp = tr_new(char, len + 1);\n        memcpy(tmp, bytes, len);\n        tmp[len] = '\\0';\n        str->type = TR_STRING_TYPE_HEAP;\n        str->str.str = tmp;\n        str->len = len;\n    }\n}\n\n/***\n****\n***/\n\nstatic inline char const* getStr(tr_variant const* v)\n{\n    TR_ASSERT(tr_variantIsString(v));\n\n    return tr_variant_string_get_string(&v->val.s);\n}\n\nstatic int dictIndexOf(tr_variant const* dict, tr_quark const key)\n{\n    if (tr_variantIsDict(dict))\n    {\n        for (size_t i = 0; i < dict->val.l.count; ++i)\n        {\n            if (dict->val.l.vals[i].key == key)\n            {\n                return (int)i;\n            }\n        }\n    }\n\n    return -1;\n}\n\ntr_variant* tr_variantDictFind(tr_variant* dict, tr_quark const key)\n{\n    int const i = dictIndexOf(dict, key);\n\n    return i < 0 ? NULL : dict->val.l.vals + i;\n}\n\nstatic bool tr_variantDictFindType(tr_variant* dict, tr_quark const key, int type, tr_variant** setme)\n{\n    *setme = tr_variantDictFind(dict, key);\n    return tr_variantIsType(*setme, type);\n}\n\nsize_t tr_variantListSize(tr_variant const* list)\n{\n    return tr_variantIsList(list) ? list->val.l.count : 0;\n}\n\ntr_variant* tr_variantListChild(tr_variant* v, size_t i)\n{\n    tr_variant* ret = NULL;\n\n    if (tr_variantIsList(v) && i < v->val.l.count)\n    {\n        ret = v->val.l.vals + i;\n    }\n\n    return ret;\n}\n\nbool tr_variantListRemove(tr_variant* list, size_t i)\n{\n    bool removed = false;\n\n    if (tr_variantIsList(list) && i < list->val.l.count)\n    {\n        removed = true;\n        tr_variantFree(&list->val.l.vals[i]);\n        tr_removeElementFromArray(list->val.l.vals, i, sizeof(tr_variant), list->val.l.count);\n        --list->val.l.count;\n    }\n\n    return removed;\n}\n\nbool tr_variantGetInt(tr_variant const* v, int64_t* setme)\n{\n    bool success = false;\n\n    if (tr_variantIsInt(v))\n    {\n        if (setme != NULL)\n        {\n            *setme = v->val.i;\n        }\n\n        success = true;\n    }\n\n    if (!success && tr_variantIsBool(v))\n    {\n        if (setme != NULL)\n        {\n            *setme = v->val.b ? 1 : 0;\n        }\n\n        success = true;\n    }\n\n    return success;\n}\n\nbool tr_variantGetStr(tr_variant const* v, char const** setme, size_t* len)\n{\n    bool const success = tr_variantIsString(v);\n\n    if (success)\n    {\n        *setme = getStr(v);\n    }\n\n    if (len != NULL)\n    {\n        *len = success ? v->val.s.len : 0;\n    }\n\n    return success;\n}\n\nbool tr_variantGetRaw(tr_variant const* v, uint8_t const** setme_raw, size_t* setme_len)\n{\n    bool const success = tr_variantIsString(v);\n\n    if (success)\n    {\n        *setme_raw = (uint8_t*)getStr(v);\n        *setme_len = v->val.s.len;\n    }\n\n    return success;\n}\n\nbool tr_variantGetBool(tr_variant const* v, bool* setme)\n{\n    char const* str;\n    bool success = false;\n\n    if (tr_variantIsBool(v))\n    {\n        *setme = v->val.b;\n        success = true;\n    }\n\n    if (!success && tr_variantIsInt(v))\n    {\n        if (v->val.i == 0 || v->val.i == 1)\n        {\n            *setme = v->val.i != 0;\n            success = true;\n        }\n    }\n\n    if (!success && tr_variantGetStr(v, &str, NULL))\n    {\n        if (strcmp(str, \"true\") == 0 || strcmp(str, \"false\") == 0)\n        {\n            *setme = strcmp(str, \"true\") == 0;\n            success = true;\n        }\n    }\n\n    return success;\n}\n\nbool tr_variantGetReal(tr_variant const* v, double* setme)\n{\n    bool success = false;\n\n    if (tr_variantIsReal(v))\n    {\n        *setme = v->val.d;\n        success = true;\n    }\n\n    if (!success && tr_variantIsInt(v))\n    {\n        *setme = v->val.i;\n        success = true;\n    }\n\n    if (!success && tr_variantIsString(v))\n    {\n        char* endptr;\n        struct locale_context locale_ctx;\n        double d;\n\n        /* the json spec requires a '.' decimal point regardless of locale */\n        use_numeric_locale(&locale_ctx, \"C\");\n        d = strtod(getStr(v), &endptr);\n        restore_locale(&locale_ctx);\n\n        if (getStr(v) != endptr && *endptr == '\\0')\n        {\n            *setme = d;\n            success = true;\n        }\n    }\n\n    return success;\n}\n\nbool tr_variantDictFindInt(tr_variant* dict, tr_quark const key, int64_t* setme)\n{\n    tr_variant* child = tr_variantDictFind(dict, key);\n    return tr_variantGetInt(child, setme);\n}\n\nbool tr_variantDictFindBool(tr_variant* dict, tr_quark const key, bool* setme)\n{\n    tr_variant* child = tr_variantDictFind(dict, key);\n    return tr_variantGetBool(child, setme);\n}\n\nbool tr_variantDictFindReal(tr_variant* dict, tr_quark const key, double* setme)\n{\n    tr_variant* child = tr_variantDictFind(dict, key);\n    return tr_variantGetReal(child, setme);\n}\n\nbool tr_variantDictFindStr(tr_variant* dict, tr_quark const key, char const** setme, size_t* len)\n{\n    tr_variant* child = tr_variantDictFind(dict, key);\n    return tr_variantGetStr(child, setme, len);\n}\n\nbool tr_variantDictFindList(tr_variant* dict, tr_quark const key, tr_variant** setme)\n{\n    return tr_variantDictFindType(dict, key, TR_VARIANT_TYPE_LIST, setme);\n}\n\nbool tr_variantDictFindDict(tr_variant* dict, tr_quark const key, tr_variant** setme)\n{\n    return tr_variantDictFindType(dict, key, TR_VARIANT_TYPE_DICT, setme);\n}\n\nbool tr_variantDictFindRaw(tr_variant* dict, tr_quark const key, uint8_t const** setme_raw, size_t* setme_len)\n{\n    tr_variant* child = tr_variantDictFind(dict, key);\n    return tr_variantGetRaw(child, setme_raw, setme_len);\n}\n\n/***\n****\n***/\n\nvoid tr_variantInitRaw(tr_variant* v, void const* src, size_t byteCount)\n{\n    tr_variantInit(v, TR_VARIANT_TYPE_STR);\n    tr_variant_string_set_string(&v->val.s, src, byteCount);\n}\n\nvoid tr_variantInitQuark(tr_variant* v, tr_quark const q)\n{\n    tr_variantInit(v, TR_VARIANT_TYPE_STR);\n    tr_variant_string_set_quark(&v->val.s, q);\n}\n\nvoid tr_variantInitStr(tr_variant* v, void const* str, size_t len)\n{\n    tr_variantInit(v, TR_VARIANT_TYPE_STR);\n    tr_variant_string_set_string(&v->val.s, str, len);\n}\n\nvoid tr_variantInitBool(tr_variant* v, bool value)\n{\n    tr_variantInit(v, TR_VARIANT_TYPE_BOOL);\n    v->val.b = value != 0;\n}\n\nvoid tr_variantInitReal(tr_variant* v, double value)\n{\n    tr_variantInit(v, TR_VARIANT_TYPE_REAL);\n    v->val.d = value;\n}\n\nvoid tr_variantInitInt(tr_variant* v, int64_t value)\n{\n    tr_variantInit(v, TR_VARIANT_TYPE_INT);\n    v->val.i = value;\n}\n\nvoid tr_variantInitList(tr_variant* v, size_t reserve_count)\n{\n    tr_variantInit(v, TR_VARIANT_TYPE_LIST);\n    tr_variantListReserve(v, reserve_count);\n}\n\nstatic void containerReserve(tr_variant* v, size_t count)\n{\n    TR_ASSERT(tr_variantIsContainer(v));\n\n    size_t const needed = v->val.l.count + count;\n\n    if (needed > v->val.l.alloc)\n    {\n        /* scale the alloc size in powers-of-2 */\n        size_t n = v->val.l.alloc != 0 ? v->val.l.alloc : 8;\n\n        while (n < needed)\n        {\n            n *= 2U;\n        }\n\n        v->val.l.vals = tr_renew(tr_variant, v->val.l.vals, n);\n        v->val.l.alloc = n;\n    }\n}\n\nvoid tr_variantListReserve(tr_variant* list, size_t count)\n{\n    TR_ASSERT(tr_variantIsList(list));\n\n    containerReserve(list, count);\n}\n\nvoid tr_variantInitDict(tr_variant* v, size_t reserve_count)\n{\n    tr_variantInit(v, TR_VARIANT_TYPE_DICT);\n    tr_variantDictReserve(v, reserve_count);\n}\n\nvoid tr_variantDictReserve(tr_variant* dict, size_t reserve_count)\n{\n    TR_ASSERT(tr_variantIsDict(dict));\n\n    containerReserve(dict, reserve_count);\n}\n\ntr_variant* tr_variantListAdd(tr_variant* list)\n{\n    TR_ASSERT(tr_variantIsList(list));\n\n    containerReserve(list, 1);\n\n    tr_variant* child = &list->val.l.vals[list->val.l.count++];\n    child->key = 0;\n    tr_variantInit(child, TR_VARIANT_TYPE_INT);\n\n    return child;\n}\n\ntr_variant* tr_variantListAddInt(tr_variant* list, int64_t val)\n{\n    tr_variant* child = tr_variantListAdd(list);\n    tr_variantInitInt(child, val);\n    return child;\n}\n\ntr_variant* tr_variantListAddReal(tr_variant* list, double val)\n{\n    tr_variant* child = tr_variantListAdd(list);\n    tr_variantInitReal(child, val);\n    return child;\n}\n\ntr_variant* tr_variantListAddBool(tr_variant* list, bool val)\n{\n    tr_variant* child = tr_variantListAdd(list);\n    tr_variantInitBool(child, val);\n    return child;\n}\n\ntr_variant* tr_variantListAddStr(tr_variant* list, char const* val)\n{\n    tr_variant* child = tr_variantListAdd(list);\n    tr_variantInitStr(child, val, TR_BAD_SIZE);\n    return child;\n}\n\ntr_variant* tr_variantListAddQuark(tr_variant* list, tr_quark const val)\n{\n    tr_variant* child = tr_variantListAdd(list);\n    tr_variantInitQuark(child, val);\n    return child;\n}\n\ntr_variant* tr_variantListAddRaw(tr_variant* list, void const* val, size_t len)\n{\n    tr_variant* child = tr_variantListAdd(list);\n    tr_variantInitRaw(child, val, len);\n    return child;\n}\n\ntr_variant* tr_variantListAddList(tr_variant* list, size_t reserve_count)\n{\n    tr_variant* child = tr_variantListAdd(list);\n    tr_variantInitList(child, reserve_count);\n    return child;\n}\n\ntr_variant* tr_variantListAddDict(tr_variant* list, size_t reserve_count)\n{\n    tr_variant* child = tr_variantListAdd(list);\n    tr_variantInitDict(child, reserve_count);\n    return child;\n}\n\ntr_variant* tr_variantDictAdd(tr_variant* dict, tr_quark const key)\n{\n    TR_ASSERT(tr_variantIsDict(dict));\n\n    containerReserve(dict, 1);\n\n    tr_variant* val = dict->val.l.vals + dict->val.l.count++;\n    tr_variantInit(val, TR_VARIANT_TYPE_INT);\n    val->key = key;\n\n    return val;\n}\n\nstatic tr_variant* dictFindOrAdd(tr_variant* dict, tr_quark const key, int type)\n{\n    tr_variant* child;\n\n    /* see if it already exists, and if so, try to reuse it */\n    if ((child = tr_variantDictFind(dict, key)) != NULL)\n    {\n        if (!tr_variantIsType(child, type))\n        {\n            tr_variantDictRemove(dict, key);\n            child = NULL;\n        }\n        else if (child->type == TR_VARIANT_TYPE_STR)\n        {\n            tr_variant_string_clear(&child->val.s);\n        }\n    }\n\n    /* if it doesn't exist, create it */\n    if (child == NULL)\n    {\n        child = tr_variantDictAdd(dict, key);\n    }\n\n    return child;\n}\n\ntr_variant* tr_variantDictAddInt(tr_variant* dict, tr_quark const key, int64_t val)\n{\n    tr_variant* child = dictFindOrAdd(dict, key, TR_VARIANT_TYPE_INT);\n    tr_variantInitInt(child, val);\n    return child;\n}\n\ntr_variant* tr_variantDictAddBool(tr_variant* dict, tr_quark const key, bool val)\n{\n    tr_variant* child = dictFindOrAdd(dict, key, TR_VARIANT_TYPE_BOOL);\n    tr_variantInitBool(child, val);\n    return child;\n}\n\ntr_variant* tr_variantDictAddReal(tr_variant* dict, tr_quark const key, double val)\n{\n    tr_variant* child = dictFindOrAdd(dict, key, TR_VARIANT_TYPE_REAL);\n    tr_variantInitReal(child, val);\n    return child;\n}\n\ntr_variant* tr_variantDictAddQuark(tr_variant* dict, tr_quark const key, tr_quark const val)\n{\n    tr_variant* child = dictFindOrAdd(dict, key, TR_VARIANT_TYPE_STR);\n    tr_variantInitQuark(child, val);\n    return child;\n}\n\ntr_variant* tr_variantDictAddStr(tr_variant* dict, tr_quark const key, char const* val)\n{\n    tr_variant* child = dictFindOrAdd(dict, key, TR_VARIANT_TYPE_STR);\n    tr_variantInitStr(child, val, TR_BAD_SIZE);\n    return child;\n}\n\ntr_variant* tr_variantDictAddRaw(tr_variant* dict, tr_quark const key, void const* src, size_t len)\n{\n    tr_variant* child = dictFindOrAdd(dict, key, TR_VARIANT_TYPE_STR);\n    tr_variantInitRaw(child, src, len);\n    return child;\n}\n\ntr_variant* tr_variantDictAddList(tr_variant* dict, tr_quark const key, size_t reserve_count)\n{\n    tr_variant* child = tr_variantDictAdd(dict, key);\n    tr_variantInitList(child, reserve_count);\n    return child;\n}\n\ntr_variant* tr_variantDictAddDict(tr_variant* dict, tr_quark const key, size_t reserve_count)\n{\n    tr_variant* child = tr_variantDictAdd(dict, key);\n    tr_variantInitDict(child, reserve_count);\n    return child;\n}\n\ntr_variant* tr_variantDictSteal(tr_variant* dict, tr_quark const key, tr_variant* value)\n{\n    tr_variant* child = tr_variantDictAdd(dict, key);\n    *child = *value;\n    child->key = key;\n    tr_variantInit(value, value->type);\n    return child;\n}\n\nbool tr_variantDictRemove(tr_variant* dict, tr_quark const key)\n{\n    bool removed = false;\n    int const i = dictIndexOf(dict, key);\n\n    if (i >= 0)\n    {\n        int const last = dict->val.l.count - 1;\n\n        tr_variantFree(&dict->val.l.vals[i]);\n\n        if (i != last)\n        {\n            dict->val.l.vals[i] = dict->val.l.vals[last];\n        }\n\n        --dict->val.l.count;\n\n        removed = true;\n    }\n\n    return removed;\n}\n\n/***\n****  BENC WALKING\n***/\n\nstruct KeyIndex\n{\n    char const* keystr;\n    tr_variant* val;\n};\n\nstatic int compareKeyIndex(void const* va, void const* vb)\n{\n    struct KeyIndex const* a = va;\n    struct KeyIndex const* b = vb;\n\n    return strcmp(a->keystr, b->keystr);\n}\n\nstruct SaveNode\n{\n    tr_variant const* v;\n    tr_variant sorted;\n    size_t childIndex;\n    bool isVisited;\n};\n\nstatic void nodeConstruct(struct SaveNode* node, tr_variant const* v, bool sort_dicts)\n{\n    node->isVisited = false;\n    node->childIndex = 0;\n\n    if (sort_dicts && tr_variantIsDict(v))\n    {\n        /* make node->sorted a sorted version of this dictionary */\n\n        size_t const n = v->val.l.count;\n        struct KeyIndex* tmp = tr_new(struct KeyIndex, n);\n\n        for (size_t i = 0; i < n; i++)\n        {\n            tmp[i].val = v->val.l.vals + i;\n            tmp[i].keystr = tr_quark_get_string(tmp[i].val->key, NULL);\n        }\n\n        qsort(tmp, n, sizeof(struct KeyIndex), compareKeyIndex);\n\n        tr_variantInitDict(&node->sorted, n);\n\n        for (size_t i = 0; i < n; ++i)\n        {\n            node->sorted.val.l.vals[i] = *tmp[i].val;\n        }\n\n        node->sorted.val.l.count = n;\n\n        tr_free(tmp);\n\n        node->v = &node->sorted;\n    }\n    else\n    {\n        node->v = v;\n    }\n}\n\nstatic void nodeDestruct(struct SaveNode* node)\n{\n    if (node->v == &node->sorted)\n    {\n        tr_free(node->sorted.val.l.vals);\n    }\n}\n\n/**\n * This function's previous recursive implementation was\n * easier to read, but was vulnerable to a smash-stacking\n * attack via maliciously-crafted data. (#667)\n */\nvoid tr_variantWalk(tr_variant const* v, struct VariantWalkFuncs const* walkFuncs, void* user_data, bool sort_dicts)\n{\n    int stackSize = 0;\n    int stackAlloc = 64;\n    struct SaveNode* stack = tr_new(struct SaveNode, stackAlloc);\n\n    nodeConstruct(&stack[stackSize++], v, sort_dicts);\n\n    while (stackSize > 0)\n    {\n        struct SaveNode* node = &stack[stackSize - 1];\n        tr_variant const* v;\n\n        if (!node->isVisited)\n        {\n            v = node->v;\n            node->isVisited = true;\n        }\n        else if (tr_variantIsContainer(node->v) && node->childIndex < node->v->val.l.count)\n        {\n            int const index = node->childIndex;\n            ++node->childIndex;\n\n            v = node->v->val.l.vals + index;\n\n            if (tr_variantIsDict(node->v))\n            {\n                tr_variant tmp;\n                tr_variantInitQuark(&tmp, v->key);\n                walkFuncs->stringFunc(&tmp, user_data);\n            }\n        }\n        else /* done with this node */\n        {\n            if (tr_variantIsContainer(node->v))\n            {\n                walkFuncs->containerEndFunc(node->v, user_data);\n            }\n\n            --stackSize;\n            nodeDestruct(node);\n            continue;\n        }\n\n        if (v != NULL)\n        {\n            switch (v->type)\n            {\n            case TR_VARIANT_TYPE_INT:\n                walkFuncs->intFunc(v, user_data);\n                break;\n\n            case TR_VARIANT_TYPE_BOOL:\n                walkFuncs->boolFunc(v, user_data);\n                break;\n\n            case TR_VARIANT_TYPE_REAL:\n                walkFuncs->realFunc(v, user_data);\n                break;\n\n            case TR_VARIANT_TYPE_STR:\n                walkFuncs->stringFunc(v, user_data);\n                break;\n\n            case TR_VARIANT_TYPE_LIST:\n                if (v == node->v)\n                {\n                    walkFuncs->listBeginFunc(v, user_data);\n                }\n                else\n                {\n                    if (stackAlloc == stackSize)\n                    {\n                        stackAlloc *= 2;\n                        stack = tr_renew(struct SaveNode, stack, stackAlloc);\n                    }\n\n                    nodeConstruct(&stack[stackSize++], v, sort_dicts);\n                }\n\n                break;\n\n            case TR_VARIANT_TYPE_DICT:\n                if (v == node->v)\n                {\n                    walkFuncs->dictBeginFunc(v, user_data);\n                }\n                else\n                {\n                    if (stackAlloc == stackSize)\n                    {\n                        stackAlloc *= 2;\n                        stack = tr_renew(struct SaveNode, stack, stackAlloc);\n                    }\n\n                    nodeConstruct(&stack[stackSize++], v, sort_dicts);\n                }\n\n                break;\n\n            default:\n                /* did caller give us an uninitialized val? */\n                tr_logAddError(\"%s\", _(\"Invalid metadata\"));\n                break;\n            }\n        }\n    }\n\n    tr_free(stack);\n}\n\n/****\n*****\n****/\n\nstatic void freeDummyFunc(tr_variant const* v UNUSED, void* buf UNUSED)\n{\n}\n\nstatic void freeStringFunc(tr_variant const* v, void* unused UNUSED)\n{\n    tr_variant_string_clear(&((tr_variant*)v)->val.s);\n}\n\nstatic void freeContainerEndFunc(tr_variant const* v, void* unused UNUSED)\n{\n    tr_free(v->val.l.vals);\n}\n\nstatic struct VariantWalkFuncs const freeWalkFuncs =\n{\n    freeDummyFunc,\n    freeDummyFunc,\n    freeDummyFunc,\n    freeStringFunc,\n    freeDummyFunc,\n    freeDummyFunc,\n    freeContainerEndFunc\n};\n\nvoid tr_variantFree(tr_variant* v)\n{\n    if (tr_variantIsSomething(v))\n    {\n        tr_variantWalk(v, &freeWalkFuncs, NULL, false);\n    }\n}\n\n/***\n****\n***/\n\nstatic void tr_variantListCopy(tr_variant* target, tr_variant const* src)\n{\n    int i = 0;\n    tr_variant const* val;\n\n    while ((val = tr_variantListChild((tr_variant*)src, i)) != NULL)\n    {\n        if (tr_variantIsBool(val))\n        {\n            bool boolVal = false;\n            tr_variantGetBool(val, &boolVal);\n            tr_variantListAddBool(target, boolVal);\n        }\n        else if (tr_variantIsReal(val))\n        {\n            double realVal = 0;\n            tr_variantGetReal(val, &realVal);\n            tr_variantListAddReal(target, realVal);\n        }\n        else if (tr_variantIsInt(val))\n        {\n            int64_t intVal = 0;\n            tr_variantGetInt(val, &intVal);\n            tr_variantListAddInt(target, intVal);\n        }\n        else if (tr_variantIsString(val))\n        {\n            size_t len;\n            char const* str;\n            tr_variantGetStr(val, &str, &len);\n            tr_variantListAddRaw(target, str, len);\n        }\n        else if (tr_variantIsDict(val))\n        {\n            tr_variantMergeDicts(tr_variantListAddDict(target, 0), val);\n        }\n        else if (tr_variantIsList(val))\n        {\n            tr_variantListCopy(tr_variantListAddList(target, 0), val);\n        }\n        else\n        {\n            tr_logAddError(\"tr_variantListCopy skipping item\");\n        }\n\n        ++i;\n    }\n}\n\nstatic size_t tr_variantDictSize(tr_variant const* dict)\n{\n    return tr_variantIsDict(dict) ? dict->val.l.count : 0;\n}\n\nbool tr_variantDictChild(tr_variant* dict, size_t n, tr_quark* key, tr_variant** val)\n{\n    TR_ASSERT(tr_variantIsDict(dict));\n\n    bool success = false;\n\n    if (tr_variantIsDict(dict) && n < dict->val.l.count)\n    {\n        *key = dict->val.l.vals[n].key;\n        *val = dict->val.l.vals + n;\n        success = true;\n    }\n\n    return success;\n}\n\nvoid tr_variantMergeDicts(tr_variant* target, tr_variant const* source)\n{\n    TR_ASSERT(tr_variantIsDict(target));\n    TR_ASSERT(tr_variantIsDict(source));\n\n    size_t const sourceCount = tr_variantDictSize(source);\n\n    tr_variantDictReserve(target, sourceCount + tr_variantDictSize(target));\n\n    for (size_t i = 0; i < sourceCount; ++i)\n    {\n        tr_quark key;\n        tr_variant* val;\n        tr_variant* t;\n\n        if (tr_variantDictChild((tr_variant*)source, i, &key, &val))\n        {\n            if (tr_variantIsBool(val))\n            {\n                bool boolVal;\n                tr_variantGetBool(val, &boolVal);\n                tr_variantDictAddBool(target, key, boolVal);\n            }\n            else if (tr_variantIsReal(val))\n            {\n                double realVal = 0;\n                tr_variantGetReal(val, &realVal);\n                tr_variantDictAddReal(target, key, realVal);\n            }\n            else if (tr_variantIsInt(val))\n            {\n                int64_t intVal = 0;\n                tr_variantGetInt(val, &intVal);\n                tr_variantDictAddInt(target, key, intVal);\n            }\n            else if (tr_variantIsString(val))\n            {\n                size_t len;\n                char const* str;\n                tr_variantGetStr(val, &str, &len);\n                tr_variantDictAddRaw(target, key, str, len);\n            }\n            else if (tr_variantIsDict(val) && tr_variantDictFindDict(target, key, &t))\n            {\n                tr_variantMergeDicts(t, val);\n            }\n            else if (tr_variantIsList(val))\n            {\n                if (tr_variantDictFind(target, key) == NULL)\n                {\n                    tr_variantListCopy(tr_variantDictAddList(target, key, tr_variantListSize(val)), val);\n                }\n            }\n            else if (tr_variantIsDict(val))\n            {\n                tr_variant* target_dict = tr_variantDictFind(target, key);\n\n                if (target_dict == NULL)\n                {\n                    target_dict = tr_variantDictAddDict(target, key, tr_variantDictSize(val));\n                }\n\n                if (tr_variantIsDict(target_dict))\n                {\n                    tr_variantMergeDicts(target_dict, val);\n                }\n            }\n            else\n            {\n                tr_logAddDebug(\"tr_variantMergeDicts skipping \\\"%s\\\"\", tr_quark_get_string(key, NULL));\n            }\n        }\n    }\n}\n\n/***\n****\n***/\n\nstruct evbuffer* tr_variantToBuf(tr_variant const* v, tr_variant_fmt fmt)\n{\n    struct locale_context locale_ctx;\n    struct evbuffer* buf = evbuffer_new();\n\n    /* parse with LC_NUMERIC=\"C\" to ensure a \".\" decimal separator */\n    use_numeric_locale(&locale_ctx, \"C\");\n\n    evbuffer_expand(buf, 4096); /* alloc a little memory to start off with */\n\n    switch (fmt)\n    {\n    case TR_VARIANT_FMT_BENC:\n        tr_variantToBufBenc(v, buf);\n        break;\n\n    case TR_VARIANT_FMT_JSON:\n        tr_variantToBufJson(v, buf, false);\n        break;\n\n    case TR_VARIANT_FMT_JSON_LEAN:\n        tr_variantToBufJson(v, buf, true);\n        break;\n    }\n\n    /* restore the previous locale */\n    restore_locale(&locale_ctx);\n    return buf;\n}\n\nchar* tr_variantToStr(tr_variant const* v, tr_variant_fmt fmt, size_t* len)\n{\n    struct evbuffer* buf = tr_variantToBuf(v, fmt);\n    return evbuffer_free_to_str(buf, len);\n}\n\nint tr_variantToFile(tr_variant const* v, tr_variant_fmt fmt, char const* filename)\n{\n    char* tmp;\n    tr_sys_file_t fd;\n    int err = 0;\n    char* real_filename;\n    tr_error* error = NULL;\n\n    /* follow symlinks to find the \"real\" file, to make sure the temporary\n     * we build with tr_sys_file_open_temp() is created on the right partition */\n    if ((real_filename = tr_sys_path_resolve(filename, NULL)) != NULL)\n    {\n        filename = real_filename;\n    }\n\n    /* if the file already exists, try to move it out of the way & keep it as a backup */\n    tmp = tr_strdup_printf(\"%s.tmp.XXXXXX\", filename);\n    fd = tr_sys_file_open_temp(tmp, &error);\n\n    if (fd != TR_BAD_SYS_FILE)\n    {\n        uint64_t nleft;\n\n        /* save the variant to a temporary file */\n        {\n            struct evbuffer* buf = tr_variantToBuf(v, fmt);\n            char const* walk = (char const*)evbuffer_pullup(buf, -1);\n            nleft = evbuffer_get_length(buf);\n\n            while (nleft > 0)\n            {\n                uint64_t n;\n\n                if (!tr_sys_file_write(fd, walk, nleft, &n, &error))\n                {\n                    err = error->code;\n                    break;\n                }\n\n                nleft -= n;\n                walk += n;\n            }\n\n            evbuffer_free(buf);\n        }\n\n        tr_sys_file_close(fd, NULL);\n\n        if (nleft > 0)\n        {\n            tr_logAddError(_(\"Couldn't save temporary file \\\"%1$s\\\": %2$s\"), tmp, error->message);\n            tr_sys_path_remove(tmp, NULL);\n            tr_error_free(error);\n        }\n        else\n        {\n            tr_error_clear(&error);\n\n            if (tr_sys_path_rename(tmp, filename, &error))\n            {\n                tr_logAddInfo(_(\"Saved \\\"%s\\\"\"), filename);\n            }\n            else\n            {\n                err = error->code;\n                tr_logAddError(_(\"Couldn't save file \\\"%1$s\\\": %2$s\"), filename, error->message);\n                tr_sys_path_remove(tmp, NULL);\n                tr_error_free(error);\n            }\n        }\n    }\n    else\n    {\n        err = error->code;\n        tr_logAddError(_(\"Couldn't save temporary file \\\"%1$s\\\": %2$s\"), tmp, error->message);\n        tr_error_free(error);\n    }\n\n    tr_free(tmp);\n    tr_free(real_filename);\n    return err;\n}\n\n/***\n****\n***/\n\nbool tr_variantFromFile(tr_variant* setme, tr_variant_fmt fmt, char const* filename, tr_error** error)\n{\n    bool ret = false;\n    uint8_t* buf;\n    size_t buflen;\n\n    buf = tr_loadFile(filename, &buflen, error);\n\n    if (buf != NULL)\n    {\n        if (tr_variantFromBuf(setme, fmt, buf, buflen, filename, NULL) == 0)\n        {\n            ret = true;\n        }\n        else\n        {\n            tr_error_set_literal(error, 0, _(\"Unable to parse file content\"));\n        }\n\n        tr_free(buf);\n    }\n\n    return ret;\n}\n\nint tr_variantFromBuf(tr_variant* setme, tr_variant_fmt fmt, void const* buf, size_t buflen, char const* optional_source,\n    char const** setme_end)\n{\n    int err;\n    struct locale_context locale_ctx;\n\n    /* parse with LC_NUMERIC=\"C\" to ensure a \".\" decimal separator */\n    use_numeric_locale(&locale_ctx, \"C\");\n\n    switch (fmt)\n    {\n    case TR_VARIANT_FMT_JSON:\n    case TR_VARIANT_FMT_JSON_LEAN:\n        err = tr_jsonParse(optional_source, buf, buflen, setme, setme_end);\n        break;\n\n    default /* TR_VARIANT_FMT_BENC */:\n        err = tr_variantParseBenc(buf, (char const*)buf + buflen, setme, setme_end);\n        break;\n    }\n\n    /* restore the previous locale */\n    restore_locale(&locale_ctx);\n    return err;\n}\n"], "fixing_code": ["/*\n * This file Copyright (C) 2008-2014 Mnemosyne LLC\n *\n * It may be used under the GNU GPL versions 2 or 3\n * or any future license endorsed by Mnemosyne LLC.\n *\n */\n\n#if defined(HAVE_USELOCALE) && (!defined(_XOPEN_SOURCE) || _XOPEN_SOURCE < 700)\n#undef _XOPEN_SOURCE\n#define _XOPEN_SOURCE 700\n#endif\n\n#if defined(HAVE_USELOCALE) && !defined(_GNU_SOURCE)\n#define _GNU_SOURCE\n#endif\n\n#include <errno.h>\n#include <stdlib.h> /* strtod(), realloc(), qsort() */\n#include <string.h>\n\n#ifdef _WIN32\n#include <share.h>\n#endif\n\n#include <locale.h> /* setlocale() */\n\n#if defined(HAVE_USELOCALE) && defined(HAVE_XLOCALE_H)\n#include <xlocale.h>\n#endif\n\n#include <event2/buffer.h>\n\n#define __LIBTRANSMISSION_VARIANT_MODULE__\n\n#include \"transmission.h\"\n#include \"ConvertUTF.h\"\n#include \"error.h\"\n#include \"file.h\"\n#include \"log.h\"\n#include \"tr-assert.h\"\n#include \"utils.h\" /* tr_new(), tr_free() */\n#include \"variant.h\"\n#include \"variant-common.h\"\n\n/* don't use newlocale/uselocale on old versions of uClibc because they're buggy.\n * https://trac.transmissionbt.com/ticket/6006 */\n#if defined(__UCLIBC__) && !TR_UCLIBC_CHECK_VERSION(0, 9, 34)\n#undef HAVE_USELOCALE\n#endif\n\n/**\n***\n**/\n\nstruct locale_context\n{\n#ifdef HAVE_USELOCALE\n    locale_t new_locale;\n    locale_t old_locale;\n#else\n#if defined(HAVE__CONFIGTHREADLOCALE) && defined(_ENABLE_PER_THREAD_LOCALE)\n    int old_thread_config;\n#endif\n    int category;\n    char old_locale[128];\n#endif\n};\n\nstatic void use_numeric_locale(struct locale_context* context, char const* locale_name)\n{\n#ifdef HAVE_USELOCALE\n\n    context->new_locale = newlocale(LC_NUMERIC_MASK, locale_name, NULL);\n    context->old_locale = uselocale(context->new_locale);\n\n#else\n\n#if defined(HAVE__CONFIGTHREADLOCALE) && defined(_ENABLE_PER_THREAD_LOCALE)\n    context->old_thread_config = _configthreadlocale(_ENABLE_PER_THREAD_LOCALE);\n#endif\n\n    context->category = LC_NUMERIC;\n    tr_strlcpy(context->old_locale, setlocale(context->category, NULL), sizeof(context->old_locale));\n    setlocale(context->category, locale_name);\n\n#endif\n}\n\nstatic void restore_locale(struct locale_context* context)\n{\n#ifdef HAVE_USELOCALE\n\n    uselocale(context->old_locale);\n    freelocale(context->new_locale);\n\n#else\n\n    setlocale(context->category, context->old_locale);\n\n#if defined(HAVE__CONFIGTHREADLOCALE) && defined(_ENABLE_PER_THREAD_LOCALE)\n    _configthreadlocale(context->old_thread_config);\n#endif\n\n#endif\n}\n\n/***\n****\n***/\n\nstatic bool tr_variantIsContainer(tr_variant const* v)\n{\n    return tr_variantIsList(v) || tr_variantIsDict(v);\n}\n\nstatic bool tr_variantIsSomething(tr_variant const* v)\n{\n    return tr_variantIsContainer(v) || tr_variantIsInt(v) || tr_variantIsString(v) || tr_variantIsReal(v) ||\n        tr_variantIsBool(v);\n}\n\nvoid tr_variantInit(tr_variant* v, char type)\n{\n    v->type = type;\n    memset(&v->val, 0, sizeof(v->val));\n}\n\n/***\n****\n***/\n\nstatic struct tr_variant_string const STRING_INIT =\n{\n    .type = TR_STRING_TYPE_QUARK,\n    .quark = TR_KEY_NONE,\n    .len = 0,\n    .str.str = \"\"\n};\n\nstatic void tr_variant_string_clear(struct tr_variant_string* str)\n{\n    if (str->type == TR_STRING_TYPE_HEAP)\n    {\n        tr_free((char*)(str->str.str));\n    }\n\n    *str = STRING_INIT;\n}\n\n/* returns a const pointer to the variant's string */\nstatic char const* tr_variant_string_get_string(struct tr_variant_string const* str)\n{\n    char const* ret;\n\n    switch (str->type)\n    {\n    case TR_STRING_TYPE_BUF:\n        ret = str->str.buf;\n        break;\n\n    case TR_STRING_TYPE_HEAP:\n        ret = str->str.str;\n        break;\n\n    case TR_STRING_TYPE_QUARK:\n        ret = str->str.str;\n        break;\n\n    default:\n        ret = NULL;\n    }\n\n    return ret;\n}\n\nstatic void tr_variant_string_set_quark(struct tr_variant_string* str, tr_quark const quark)\n{\n    tr_variant_string_clear(str);\n\n    str->type = TR_STRING_TYPE_QUARK;\n    str->quark = quark;\n    str->str.str = tr_quark_get_string(quark, &str->len);\n}\n\nstatic void tr_variant_string_set_string(struct tr_variant_string* str, char const* bytes, size_t len)\n{\n    tr_variant_string_clear(str);\n\n    if (bytes == NULL)\n    {\n        len = 0;\n    }\n    else if (len == TR_BAD_SIZE)\n    {\n        len = strlen(bytes);\n    }\n\n    if (len < sizeof(str->str.buf))\n    {\n        str->type = TR_STRING_TYPE_BUF;\n        memcpy(str->str.buf, bytes, len);\n        str->str.buf[len] = '\\0';\n        str->len = len;\n    }\n    else\n    {\n        char* tmp = tr_new(char, len + 1);\n        memcpy(tmp, bytes, len);\n        tmp[len] = '\\0';\n        str->type = TR_STRING_TYPE_HEAP;\n        str->str.str = tmp;\n        str->len = len;\n    }\n}\n\n/***\n****\n***/\n\nstatic inline char const* getStr(tr_variant const* v)\n{\n    TR_ASSERT(tr_variantIsString(v));\n\n    return tr_variant_string_get_string(&v->val.s);\n}\n\nstatic int dictIndexOf(tr_variant const* dict, tr_quark const key)\n{\n    if (tr_variantIsDict(dict))\n    {\n        for (size_t i = 0; i < dict->val.l.count; ++i)\n        {\n            if (dict->val.l.vals[i].key == key)\n            {\n                return (int)i;\n            }\n        }\n    }\n\n    return -1;\n}\n\ntr_variant* tr_variantDictFind(tr_variant* dict, tr_quark const key)\n{\n    int const i = dictIndexOf(dict, key);\n\n    return i < 0 ? NULL : dict->val.l.vals + i;\n}\n\nstatic bool tr_variantDictFindType(tr_variant* dict, tr_quark const key, int type, tr_variant** setme)\n{\n    *setme = tr_variantDictFind(dict, key);\n    return tr_variantIsType(*setme, type);\n}\n\nsize_t tr_variantListSize(tr_variant const* list)\n{\n    return tr_variantIsList(list) ? list->val.l.count : 0;\n}\n\ntr_variant* tr_variantListChild(tr_variant* v, size_t i)\n{\n    tr_variant* ret = NULL;\n\n    if (tr_variantIsList(v) && i < v->val.l.count)\n    {\n        ret = v->val.l.vals + i;\n    }\n\n    return ret;\n}\n\nbool tr_variantListRemove(tr_variant* list, size_t i)\n{\n    bool removed = false;\n\n    if (tr_variantIsList(list) && i < list->val.l.count)\n    {\n        removed = true;\n        tr_variantFree(&list->val.l.vals[i]);\n        tr_removeElementFromArray(list->val.l.vals, i, sizeof(tr_variant), list->val.l.count);\n        --list->val.l.count;\n    }\n\n    return removed;\n}\n\nbool tr_variantGetInt(tr_variant const* v, int64_t* setme)\n{\n    bool success = false;\n\n    if (tr_variantIsInt(v))\n    {\n        if (setme != NULL)\n        {\n            *setme = v->val.i;\n        }\n\n        success = true;\n    }\n\n    if (!success && tr_variantIsBool(v))\n    {\n        if (setme != NULL)\n        {\n            *setme = v->val.b ? 1 : 0;\n        }\n\n        success = true;\n    }\n\n    return success;\n}\n\nbool tr_variantGetStr(tr_variant const* v, char const** setme, size_t* len)\n{\n    bool const success = tr_variantIsString(v);\n\n    if (success)\n    {\n        *setme = getStr(v);\n    }\n\n    if (len != NULL)\n    {\n        *len = success ? v->val.s.len : 0;\n    }\n\n    return success;\n}\n\nbool tr_variantGetRaw(tr_variant const* v, uint8_t const** setme_raw, size_t* setme_len)\n{\n    bool const success = tr_variantIsString(v);\n\n    if (success)\n    {\n        *setme_raw = (uint8_t*)getStr(v);\n        *setme_len = v->val.s.len;\n    }\n\n    return success;\n}\n\nbool tr_variantGetBool(tr_variant const* v, bool* setme)\n{\n    char const* str;\n    bool success = false;\n\n    if (tr_variantIsBool(v))\n    {\n        *setme = v->val.b;\n        success = true;\n    }\n\n    if (!success && tr_variantIsInt(v))\n    {\n        if (v->val.i == 0 || v->val.i == 1)\n        {\n            *setme = v->val.i != 0;\n            success = true;\n        }\n    }\n\n    if (!success && tr_variantGetStr(v, &str, NULL))\n    {\n        if (strcmp(str, \"true\") == 0 || strcmp(str, \"false\") == 0)\n        {\n            *setme = strcmp(str, \"true\") == 0;\n            success = true;\n        }\n    }\n\n    return success;\n}\n\nbool tr_variantGetReal(tr_variant const* v, double* setme)\n{\n    bool success = false;\n\n    if (tr_variantIsReal(v))\n    {\n        *setme = v->val.d;\n        success = true;\n    }\n\n    if (!success && tr_variantIsInt(v))\n    {\n        *setme = v->val.i;\n        success = true;\n    }\n\n    if (!success && tr_variantIsString(v))\n    {\n        char* endptr;\n        struct locale_context locale_ctx;\n        double d;\n\n        /* the json spec requires a '.' decimal point regardless of locale */\n        use_numeric_locale(&locale_ctx, \"C\");\n        d = strtod(getStr(v), &endptr);\n        restore_locale(&locale_ctx);\n\n        if (getStr(v) != endptr && *endptr == '\\0')\n        {\n            *setme = d;\n            success = true;\n        }\n    }\n\n    return success;\n}\n\nbool tr_variantDictFindInt(tr_variant* dict, tr_quark const key, int64_t* setme)\n{\n    tr_variant* child = tr_variantDictFind(dict, key);\n    return tr_variantGetInt(child, setme);\n}\n\nbool tr_variantDictFindBool(tr_variant* dict, tr_quark const key, bool* setme)\n{\n    tr_variant* child = tr_variantDictFind(dict, key);\n    return tr_variantGetBool(child, setme);\n}\n\nbool tr_variantDictFindReal(tr_variant* dict, tr_quark const key, double* setme)\n{\n    tr_variant* child = tr_variantDictFind(dict, key);\n    return tr_variantGetReal(child, setme);\n}\n\nbool tr_variantDictFindStr(tr_variant* dict, tr_quark const key, char const** setme, size_t* len)\n{\n    tr_variant* child = tr_variantDictFind(dict, key);\n    return tr_variantGetStr(child, setme, len);\n}\n\nbool tr_variantDictFindList(tr_variant* dict, tr_quark const key, tr_variant** setme)\n{\n    return tr_variantDictFindType(dict, key, TR_VARIANT_TYPE_LIST, setme);\n}\n\nbool tr_variantDictFindDict(tr_variant* dict, tr_quark const key, tr_variant** setme)\n{\n    return tr_variantDictFindType(dict, key, TR_VARIANT_TYPE_DICT, setme);\n}\n\nbool tr_variantDictFindRaw(tr_variant* dict, tr_quark const key, uint8_t const** setme_raw, size_t* setme_len)\n{\n    tr_variant* child = tr_variantDictFind(dict, key);\n    return tr_variantGetRaw(child, setme_raw, setme_len);\n}\n\n/***\n****\n***/\n\nvoid tr_variantInitRaw(tr_variant* v, void const* src, size_t byteCount)\n{\n    tr_variantInit(v, TR_VARIANT_TYPE_STR);\n    tr_variant_string_set_string(&v->val.s, src, byteCount);\n}\n\nvoid tr_variantInitQuark(tr_variant* v, tr_quark const q)\n{\n    tr_variantInit(v, TR_VARIANT_TYPE_STR);\n    tr_variant_string_set_quark(&v->val.s, q);\n}\n\nvoid tr_variantInitStr(tr_variant* v, void const* str, size_t len)\n{\n    tr_variantInit(v, TR_VARIANT_TYPE_STR);\n    tr_variant_string_set_string(&v->val.s, str, len);\n}\n\nvoid tr_variantInitBool(tr_variant* v, bool value)\n{\n    tr_variantInit(v, TR_VARIANT_TYPE_BOOL);\n    v->val.b = value != 0;\n}\n\nvoid tr_variantInitReal(tr_variant* v, double value)\n{\n    tr_variantInit(v, TR_VARIANT_TYPE_REAL);\n    v->val.d = value;\n}\n\nvoid tr_variantInitInt(tr_variant* v, int64_t value)\n{\n    tr_variantInit(v, TR_VARIANT_TYPE_INT);\n    v->val.i = value;\n}\n\nvoid tr_variantInitList(tr_variant* v, size_t reserve_count)\n{\n    tr_variantInit(v, TR_VARIANT_TYPE_LIST);\n    tr_variantListReserve(v, reserve_count);\n}\n\nstatic void containerReserve(tr_variant* v, size_t count)\n{\n    TR_ASSERT(tr_variantIsContainer(v));\n\n    size_t const needed = v->val.l.count + count;\n\n    if (needed > v->val.l.alloc)\n    {\n        /* scale the alloc size in powers-of-2 */\n        size_t n = v->val.l.alloc != 0 ? v->val.l.alloc : 8;\n\n        while (n < needed)\n        {\n            n *= 2U;\n        }\n\n        v->val.l.vals = tr_renew(tr_variant, v->val.l.vals, n);\n        v->val.l.alloc = n;\n    }\n}\n\nvoid tr_variantListReserve(tr_variant* list, size_t count)\n{\n    TR_ASSERT(tr_variantIsList(list));\n\n    containerReserve(list, count);\n}\n\nvoid tr_variantInitDict(tr_variant* v, size_t reserve_count)\n{\n    tr_variantInit(v, TR_VARIANT_TYPE_DICT);\n    tr_variantDictReserve(v, reserve_count);\n}\n\nvoid tr_variantDictReserve(tr_variant* dict, size_t reserve_count)\n{\n    TR_ASSERT(tr_variantIsDict(dict));\n\n    containerReserve(dict, reserve_count);\n}\n\ntr_variant* tr_variantListAdd(tr_variant* list)\n{\n    TR_ASSERT(tr_variantIsList(list));\n\n    containerReserve(list, 1);\n\n    tr_variant* child = &list->val.l.vals[list->val.l.count++];\n    child->key = 0;\n    tr_variantInit(child, TR_VARIANT_TYPE_INT);\n\n    return child;\n}\n\ntr_variant* tr_variantListAddInt(tr_variant* list, int64_t val)\n{\n    tr_variant* child = tr_variantListAdd(list);\n    tr_variantInitInt(child, val);\n    return child;\n}\n\ntr_variant* tr_variantListAddReal(tr_variant* list, double val)\n{\n    tr_variant* child = tr_variantListAdd(list);\n    tr_variantInitReal(child, val);\n    return child;\n}\n\ntr_variant* tr_variantListAddBool(tr_variant* list, bool val)\n{\n    tr_variant* child = tr_variantListAdd(list);\n    tr_variantInitBool(child, val);\n    return child;\n}\n\ntr_variant* tr_variantListAddStr(tr_variant* list, char const* val)\n{\n    tr_variant* child = tr_variantListAdd(list);\n    tr_variantInitStr(child, val, TR_BAD_SIZE);\n    return child;\n}\n\ntr_variant* tr_variantListAddQuark(tr_variant* list, tr_quark const val)\n{\n    tr_variant* child = tr_variantListAdd(list);\n    tr_variantInitQuark(child, val);\n    return child;\n}\n\ntr_variant* tr_variantListAddRaw(tr_variant* list, void const* val, size_t len)\n{\n    tr_variant* child = tr_variantListAdd(list);\n    tr_variantInitRaw(child, val, len);\n    return child;\n}\n\ntr_variant* tr_variantListAddList(tr_variant* list, size_t reserve_count)\n{\n    tr_variant* child = tr_variantListAdd(list);\n    tr_variantInitList(child, reserve_count);\n    return child;\n}\n\ntr_variant* tr_variantListAddDict(tr_variant* list, size_t reserve_count)\n{\n    tr_variant* child = tr_variantListAdd(list);\n    tr_variantInitDict(child, reserve_count);\n    return child;\n}\n\ntr_variant* tr_variantDictAdd(tr_variant* dict, tr_quark const key)\n{\n    TR_ASSERT(tr_variantIsDict(dict));\n\n    containerReserve(dict, 1);\n\n    tr_variant* val = dict->val.l.vals + dict->val.l.count++;\n    tr_variantInit(val, TR_VARIANT_TYPE_INT);\n    val->key = key;\n\n    return val;\n}\n\nstatic tr_variant* dictFindOrAdd(tr_variant* dict, tr_quark const key, int type)\n{\n    tr_variant* child;\n\n    /* see if it already exists, and if so, try to reuse it */\n    if ((child = tr_variantDictFind(dict, key)) != NULL)\n    {\n        if (!tr_variantIsType(child, type))\n        {\n            tr_variantDictRemove(dict, key);\n            child = NULL;\n        }\n        else if (child->type == TR_VARIANT_TYPE_STR)\n        {\n            tr_variant_string_clear(&child->val.s);\n        }\n    }\n\n    /* if it doesn't exist, create it */\n    if (child == NULL)\n    {\n        child = tr_variantDictAdd(dict, key);\n    }\n\n    return child;\n}\n\ntr_variant* tr_variantDictAddInt(tr_variant* dict, tr_quark const key, int64_t val)\n{\n    tr_variant* child = dictFindOrAdd(dict, key, TR_VARIANT_TYPE_INT);\n    tr_variantInitInt(child, val);\n    return child;\n}\n\ntr_variant* tr_variantDictAddBool(tr_variant* dict, tr_quark const key, bool val)\n{\n    tr_variant* child = dictFindOrAdd(dict, key, TR_VARIANT_TYPE_BOOL);\n    tr_variantInitBool(child, val);\n    return child;\n}\n\ntr_variant* tr_variantDictAddReal(tr_variant* dict, tr_quark const key, double val)\n{\n    tr_variant* child = dictFindOrAdd(dict, key, TR_VARIANT_TYPE_REAL);\n    tr_variantInitReal(child, val);\n    return child;\n}\n\ntr_variant* tr_variantDictAddQuark(tr_variant* dict, tr_quark const key, tr_quark const val)\n{\n    tr_variant* child = dictFindOrAdd(dict, key, TR_VARIANT_TYPE_STR);\n    tr_variantInitQuark(child, val);\n    return child;\n}\n\ntr_variant* tr_variantDictAddStr(tr_variant* dict, tr_quark const key, char const* val)\n{\n    tr_variant* child = dictFindOrAdd(dict, key, TR_VARIANT_TYPE_STR);\n    tr_variantInitStr(child, val, TR_BAD_SIZE);\n    return child;\n}\n\ntr_variant* tr_variantDictAddRaw(tr_variant* dict, tr_quark const key, void const* src, size_t len)\n{\n    tr_variant* child = dictFindOrAdd(dict, key, TR_VARIANT_TYPE_STR);\n    tr_variantInitRaw(child, src, len);\n    return child;\n}\n\ntr_variant* tr_variantDictAddList(tr_variant* dict, tr_quark const key, size_t reserve_count)\n{\n    tr_variant* child = tr_variantDictAdd(dict, key);\n    tr_variantInitList(child, reserve_count);\n    return child;\n}\n\ntr_variant* tr_variantDictAddDict(tr_variant* dict, tr_quark const key, size_t reserve_count)\n{\n    tr_variant* child = tr_variantDictAdd(dict, key);\n    tr_variantInitDict(child, reserve_count);\n    return child;\n}\n\ntr_variant* tr_variantDictSteal(tr_variant* dict, tr_quark const key, tr_variant* value)\n{\n    tr_variant* child = tr_variantDictAdd(dict, key);\n    *child = *value;\n    child->key = key;\n    tr_variantInit(value, value->type);\n    return child;\n}\n\nbool tr_variantDictRemove(tr_variant* dict, tr_quark const key)\n{\n    bool removed = false;\n    int const i = dictIndexOf(dict, key);\n\n    if (i >= 0)\n    {\n        int const last = dict->val.l.count - 1;\n\n        tr_variantFree(&dict->val.l.vals[i]);\n\n        if (i != last)\n        {\n            dict->val.l.vals[i] = dict->val.l.vals[last];\n        }\n\n        --dict->val.l.count;\n\n        removed = true;\n    }\n\n    return removed;\n}\n\n/***\n****  BENC WALKING\n***/\n\nstruct KeyIndex\n{\n    char const* keystr;\n    tr_variant* val;\n};\n\nstatic int compareKeyIndex(void const* va, void const* vb)\n{\n    struct KeyIndex const* a = va;\n    struct KeyIndex const* b = vb;\n\n    return strcmp(a->keystr, b->keystr);\n}\n\nstruct SaveNode\n{\n    tr_variant const* v;\n    tr_variant* sorted;\n    size_t childIndex;\n    bool isVisited;\n};\n\nstatic void nodeConstruct(struct SaveNode* node, tr_variant const* v, bool sort_dicts)\n{\n    node->isVisited = false;\n    node->childIndex = 0;\n\n    if (sort_dicts && tr_variantIsDict(v))\n    {\n        /* make node->sorted a sorted version of this dictionary */\n\n        size_t const n = v->val.l.count;\n        struct KeyIndex* tmp = tr_new(struct KeyIndex, n);\n\n        for (size_t i = 0; i < n; i++)\n        {\n            tmp[i].val = v->val.l.vals + i;\n            tmp[i].keystr = tr_quark_get_string(tmp[i].val->key, NULL);\n        }\n\n        qsort(tmp, n, sizeof(struct KeyIndex), compareKeyIndex);\n\n        node->sorted = tr_new(tr_variant, 1);\n        tr_variantInitDict(node->sorted, n);\n\n        for (size_t i = 0; i < n; ++i)\n        {\n            node->sorted->val.l.vals[i] = *tmp[i].val;\n        }\n\n        node->sorted->val.l.count = n;\n\n        tr_free(tmp);\n\n        v = node->sorted;\n    }\n    else\n    {\n        node->sorted = NULL;\n    }\n\n    node->v = v;\n}\n\nstatic void nodeDestruct(struct SaveNode* node)\n{\n    TR_ASSERT(node != NULL);\n\n    if (node->sorted != NULL)\n    {\n        tr_free(node->sorted->val.l.vals);\n        tr_free(node->sorted);\n    }\n}\n\n/**\n * This function's previous recursive implementation was\n * easier to read, but was vulnerable to a smash-stacking\n * attack via maliciously-crafted data. (#667)\n */\nvoid tr_variantWalk(tr_variant const* v, struct VariantWalkFuncs const* walkFuncs, void* user_data, bool sort_dicts)\n{\n    int stackSize = 0;\n    int stackAlloc = 64;\n    struct SaveNode* stack = tr_new(struct SaveNode, stackAlloc);\n\n    nodeConstruct(&stack[stackSize++], v, sort_dicts);\n\n    while (stackSize > 0)\n    {\n        struct SaveNode* node = &stack[stackSize - 1];\n        tr_variant const* v;\n\n        if (!node->isVisited)\n        {\n            v = node->v;\n            node->isVisited = true;\n        }\n        else if (tr_variantIsContainer(node->v) && node->childIndex < node->v->val.l.count)\n        {\n            int const index = node->childIndex;\n            ++node->childIndex;\n\n            v = node->v->val.l.vals + index;\n\n            if (tr_variantIsDict(node->v))\n            {\n                tr_variant tmp;\n                tr_variantInitQuark(&tmp, v->key);\n                walkFuncs->stringFunc(&tmp, user_data);\n            }\n        }\n        else /* done with this node */\n        {\n            if (tr_variantIsContainer(node->v))\n            {\n                walkFuncs->containerEndFunc(node->v, user_data);\n            }\n\n            --stackSize;\n            nodeDestruct(node);\n            continue;\n        }\n\n        if (v != NULL)\n        {\n            switch (v->type)\n            {\n            case TR_VARIANT_TYPE_INT:\n                walkFuncs->intFunc(v, user_data);\n                break;\n\n            case TR_VARIANT_TYPE_BOOL:\n                walkFuncs->boolFunc(v, user_data);\n                break;\n\n            case TR_VARIANT_TYPE_REAL:\n                walkFuncs->realFunc(v, user_data);\n                break;\n\n            case TR_VARIANT_TYPE_STR:\n                walkFuncs->stringFunc(v, user_data);\n                break;\n\n            case TR_VARIANT_TYPE_LIST:\n                if (v == node->v)\n                {\n                    walkFuncs->listBeginFunc(v, user_data);\n                }\n                else\n                {\n                    if (stackAlloc == stackSize)\n                    {\n                        stackAlloc *= 2;\n                        stack = tr_renew(struct SaveNode, stack, stackAlloc);\n                    }\n\n                    nodeConstruct(&stack[stackSize++], v, sort_dicts);\n                }\n\n                break;\n\n            case TR_VARIANT_TYPE_DICT:\n                if (v == node->v)\n                {\n                    walkFuncs->dictBeginFunc(v, user_data);\n                }\n                else\n                {\n                    if (stackAlloc == stackSize)\n                    {\n                        stackAlloc *= 2;\n                        stack = tr_renew(struct SaveNode, stack, stackAlloc);\n                    }\n\n                    nodeConstruct(&stack[stackSize++], v, sort_dicts);\n                }\n\n                break;\n\n            default:\n                /* did caller give us an uninitialized val? */\n                tr_logAddError(\"%s\", _(\"Invalid metadata\"));\n                break;\n            }\n        }\n    }\n\n    tr_free(stack);\n}\n\n/****\n*****\n****/\n\nstatic void freeDummyFunc(tr_variant const* v UNUSED, void* buf UNUSED)\n{\n}\n\nstatic void freeStringFunc(tr_variant const* v, void* unused UNUSED)\n{\n    tr_variant_string_clear(&((tr_variant*)v)->val.s);\n}\n\nstatic void freeContainerEndFunc(tr_variant const* v, void* unused UNUSED)\n{\n    tr_free(v->val.l.vals);\n}\n\nstatic struct VariantWalkFuncs const freeWalkFuncs =\n{\n    freeDummyFunc,\n    freeDummyFunc,\n    freeDummyFunc,\n    freeStringFunc,\n    freeDummyFunc,\n    freeDummyFunc,\n    freeContainerEndFunc\n};\n\nvoid tr_variantFree(tr_variant* v)\n{\n    if (tr_variantIsSomething(v))\n    {\n        tr_variantWalk(v, &freeWalkFuncs, NULL, false);\n    }\n}\n\n/***\n****\n***/\n\nstatic void tr_variantListCopy(tr_variant* target, tr_variant const* src)\n{\n    int i = 0;\n    tr_variant const* val;\n\n    while ((val = tr_variantListChild((tr_variant*)src, i)) != NULL)\n    {\n        if (tr_variantIsBool(val))\n        {\n            bool boolVal = false;\n            tr_variantGetBool(val, &boolVal);\n            tr_variantListAddBool(target, boolVal);\n        }\n        else if (tr_variantIsReal(val))\n        {\n            double realVal = 0;\n            tr_variantGetReal(val, &realVal);\n            tr_variantListAddReal(target, realVal);\n        }\n        else if (tr_variantIsInt(val))\n        {\n            int64_t intVal = 0;\n            tr_variantGetInt(val, &intVal);\n            tr_variantListAddInt(target, intVal);\n        }\n        else if (tr_variantIsString(val))\n        {\n            size_t len;\n            char const* str;\n            tr_variantGetStr(val, &str, &len);\n            tr_variantListAddRaw(target, str, len);\n        }\n        else if (tr_variantIsDict(val))\n        {\n            tr_variantMergeDicts(tr_variantListAddDict(target, 0), val);\n        }\n        else if (tr_variantIsList(val))\n        {\n            tr_variantListCopy(tr_variantListAddList(target, 0), val);\n        }\n        else\n        {\n            tr_logAddError(\"tr_variantListCopy skipping item\");\n        }\n\n        ++i;\n    }\n}\n\nstatic size_t tr_variantDictSize(tr_variant const* dict)\n{\n    return tr_variantIsDict(dict) ? dict->val.l.count : 0;\n}\n\nbool tr_variantDictChild(tr_variant* dict, size_t n, tr_quark* key, tr_variant** val)\n{\n    TR_ASSERT(tr_variantIsDict(dict));\n\n    bool success = false;\n\n    if (tr_variantIsDict(dict) && n < dict->val.l.count)\n    {\n        *key = dict->val.l.vals[n].key;\n        *val = dict->val.l.vals + n;\n        success = true;\n    }\n\n    return success;\n}\n\nvoid tr_variantMergeDicts(tr_variant* target, tr_variant const* source)\n{\n    TR_ASSERT(tr_variantIsDict(target));\n    TR_ASSERT(tr_variantIsDict(source));\n\n    size_t const sourceCount = tr_variantDictSize(source);\n\n    tr_variantDictReserve(target, sourceCount + tr_variantDictSize(target));\n\n    for (size_t i = 0; i < sourceCount; ++i)\n    {\n        tr_quark key;\n        tr_variant* val;\n        tr_variant* t;\n\n        if (tr_variantDictChild((tr_variant*)source, i, &key, &val))\n        {\n            if (tr_variantIsBool(val))\n            {\n                bool boolVal;\n                tr_variantGetBool(val, &boolVal);\n                tr_variantDictAddBool(target, key, boolVal);\n            }\n            else if (tr_variantIsReal(val))\n            {\n                double realVal = 0;\n                tr_variantGetReal(val, &realVal);\n                tr_variantDictAddReal(target, key, realVal);\n            }\n            else if (tr_variantIsInt(val))\n            {\n                int64_t intVal = 0;\n                tr_variantGetInt(val, &intVal);\n                tr_variantDictAddInt(target, key, intVal);\n            }\n            else if (tr_variantIsString(val))\n            {\n                size_t len;\n                char const* str;\n                tr_variantGetStr(val, &str, &len);\n                tr_variantDictAddRaw(target, key, str, len);\n            }\n            else if (tr_variantIsDict(val) && tr_variantDictFindDict(target, key, &t))\n            {\n                tr_variantMergeDicts(t, val);\n            }\n            else if (tr_variantIsList(val))\n            {\n                if (tr_variantDictFind(target, key) == NULL)\n                {\n                    tr_variantListCopy(tr_variantDictAddList(target, key, tr_variantListSize(val)), val);\n                }\n            }\n            else if (tr_variantIsDict(val))\n            {\n                tr_variant* target_dict = tr_variantDictFind(target, key);\n\n                if (target_dict == NULL)\n                {\n                    target_dict = tr_variantDictAddDict(target, key, tr_variantDictSize(val));\n                }\n\n                if (tr_variantIsDict(target_dict))\n                {\n                    tr_variantMergeDicts(target_dict, val);\n                }\n            }\n            else\n            {\n                tr_logAddDebug(\"tr_variantMergeDicts skipping \\\"%s\\\"\", tr_quark_get_string(key, NULL));\n            }\n        }\n    }\n}\n\n/***\n****\n***/\n\nstruct evbuffer* tr_variantToBuf(tr_variant const* v, tr_variant_fmt fmt)\n{\n    struct locale_context locale_ctx;\n    struct evbuffer* buf = evbuffer_new();\n\n    /* parse with LC_NUMERIC=\"C\" to ensure a \".\" decimal separator */\n    use_numeric_locale(&locale_ctx, \"C\");\n\n    evbuffer_expand(buf, 4096); /* alloc a little memory to start off with */\n\n    switch (fmt)\n    {\n    case TR_VARIANT_FMT_BENC:\n        tr_variantToBufBenc(v, buf);\n        break;\n\n    case TR_VARIANT_FMT_JSON:\n        tr_variantToBufJson(v, buf, false);\n        break;\n\n    case TR_VARIANT_FMT_JSON_LEAN:\n        tr_variantToBufJson(v, buf, true);\n        break;\n    }\n\n    /* restore the previous locale */\n    restore_locale(&locale_ctx);\n    return buf;\n}\n\nchar* tr_variantToStr(tr_variant const* v, tr_variant_fmt fmt, size_t* len)\n{\n    struct evbuffer* buf = tr_variantToBuf(v, fmt);\n    return evbuffer_free_to_str(buf, len);\n}\n\nint tr_variantToFile(tr_variant const* v, tr_variant_fmt fmt, char const* filename)\n{\n    char* tmp;\n    tr_sys_file_t fd;\n    int err = 0;\n    char* real_filename;\n    tr_error* error = NULL;\n\n    /* follow symlinks to find the \"real\" file, to make sure the temporary\n     * we build with tr_sys_file_open_temp() is created on the right partition */\n    if ((real_filename = tr_sys_path_resolve(filename, NULL)) != NULL)\n    {\n        filename = real_filename;\n    }\n\n    /* if the file already exists, try to move it out of the way & keep it as a backup */\n    tmp = tr_strdup_printf(\"%s.tmp.XXXXXX\", filename);\n    fd = tr_sys_file_open_temp(tmp, &error);\n\n    if (fd != TR_BAD_SYS_FILE)\n    {\n        uint64_t nleft;\n\n        /* save the variant to a temporary file */\n        {\n            struct evbuffer* buf = tr_variantToBuf(v, fmt);\n            char const* walk = (char const*)evbuffer_pullup(buf, -1);\n            nleft = evbuffer_get_length(buf);\n\n            while (nleft > 0)\n            {\n                uint64_t n;\n\n                if (!tr_sys_file_write(fd, walk, nleft, &n, &error))\n                {\n                    err = error->code;\n                    break;\n                }\n\n                nleft -= n;\n                walk += n;\n            }\n\n            evbuffer_free(buf);\n        }\n\n        tr_sys_file_close(fd, NULL);\n\n        if (nleft > 0)\n        {\n            tr_logAddError(_(\"Couldn't save temporary file \\\"%1$s\\\": %2$s\"), tmp, error->message);\n            tr_sys_path_remove(tmp, NULL);\n            tr_error_free(error);\n        }\n        else\n        {\n            tr_error_clear(&error);\n\n            if (tr_sys_path_rename(tmp, filename, &error))\n            {\n                tr_logAddInfo(_(\"Saved \\\"%s\\\"\"), filename);\n            }\n            else\n            {\n                err = error->code;\n                tr_logAddError(_(\"Couldn't save file \\\"%1$s\\\": %2$s\"), filename, error->message);\n                tr_sys_path_remove(tmp, NULL);\n                tr_error_free(error);\n            }\n        }\n    }\n    else\n    {\n        err = error->code;\n        tr_logAddError(_(\"Couldn't save temporary file \\\"%1$s\\\": %2$s\"), tmp, error->message);\n        tr_error_free(error);\n    }\n\n    tr_free(tmp);\n    tr_free(real_filename);\n    return err;\n}\n\n/***\n****\n***/\n\nbool tr_variantFromFile(tr_variant* setme, tr_variant_fmt fmt, char const* filename, tr_error** error)\n{\n    bool ret = false;\n    uint8_t* buf;\n    size_t buflen;\n\n    buf = tr_loadFile(filename, &buflen, error);\n\n    if (buf != NULL)\n    {\n        if (tr_variantFromBuf(setme, fmt, buf, buflen, filename, NULL) == 0)\n        {\n            ret = true;\n        }\n        else\n        {\n            tr_error_set_literal(error, 0, _(\"Unable to parse file content\"));\n        }\n\n        tr_free(buf);\n    }\n\n    return ret;\n}\n\nint tr_variantFromBuf(tr_variant* setme, tr_variant_fmt fmt, void const* buf, size_t buflen, char const* optional_source,\n    char const** setme_end)\n{\n    int err;\n    struct locale_context locale_ctx;\n\n    /* parse with LC_NUMERIC=\"C\" to ensure a \".\" decimal separator */\n    use_numeric_locale(&locale_ctx, \"C\");\n\n    switch (fmt)\n    {\n    case TR_VARIANT_FMT_JSON:\n    case TR_VARIANT_FMT_JSON_LEAN:\n        err = tr_jsonParse(optional_source, buf, buflen, setme, setme_end);\n        break;\n\n    default /* TR_VARIANT_FMT_BENC */:\n        err = tr_variantParseBenc(buf, (char const*)buf + buflen, setme, setme_end);\n        break;\n    }\n\n    /* restore the previous locale */\n    restore_locale(&locale_ctx);\n    return err;\n}\n"], "filenames": ["libtransmission/variant.c"], "buggy_code_start_loc": [761], "buggy_code_end_loc": [810], "fixing_code_start_loc": [761], "fixing_code_end_loc": [816], "type": "CWE-416", "message": "Use-after-free in libtransmission/variant.c in Transmission before 3.00 allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a crafted torrent file.", "other": {"cve": {"id": "CVE-2018-10756", "sourceIdentifier": "cve@mitre.org", "published": "2020-05-15T16:15:11.437", "lastModified": "2020-08-14T14:28:27.523", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Use-after-free in libtransmission/variant.c in Transmission before 3.00 allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a crafted torrent file."}, {"lang": "es", "value": "Un uso de la memoria previamente liberada en el archivo libtransmission/variant.c en Transmission versiones anteriores a 3.00, permite a atacantes remotos causar una denegaci\u00f3n de servicio (bloqueo) o posiblemente ejecutar c\u00f3digo arbitrario por medio de un archivo torrent dise\u00f1ado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:transmissionbt:transmission:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.00", "matchCriteriaId": "D13F8427-7635-4583-8666-E49CC4CB0C28"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}], "references": [{"url": "https://github.com/transmission/transmission/commit/2123adf8e5e1c2b48791f9d22fc8c747e974180e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/05/msg00022.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/CD3GLZ5URIK74RCGLSH72IVLDIJJMLQC/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/OVAG2HNKNRLWOACFN5F2ANJD2SQ53WI7/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202007-07", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://tomrichards.net/2020/05/cve-2018-10756-transmission/", "source": "cve@mitre.org", "tags": ["Exploit", "Mitigation", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/transmission/transmission/commit/2123adf8e5e1c2b48791f9d22fc8c747e974180e"}}