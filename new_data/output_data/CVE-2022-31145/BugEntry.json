{"buggy_code": ["package authzserver\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\tconfig2 \"github.com/flyteorg/flytestdlib/config\"\n\n\t\"github.com/flyteorg/flyteadmin/auth\"\n\t\"github.com/stretchr/testify/mock\"\n\n\t\"github.com/flyteorg/flyteadmin/auth/interfaces/mocks\"\n\n\t\"github.com/flyteorg/flyteadmin/auth/config\"\n\n\t\"github.com/ory/fosite\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestAuthEndpoint(t *testing.T) {\n\tt.Run(\"Success\", func(t *testing.T) {\n\t\toriginalURL := \"http://localhost:8088/oauth2/authorize?client_id=my-client&redirect_uri=http%3A%2F%2Flocalhost%3A3846%2Fcallback&response_type=code&scope=photos+openid+offline&state=some-random-state-foobar&nonce=some-random-nonce&code_challenge=p0v_UR0KrXl4--BpxM2BQa7qIW5k3k4WauBhjmkVQw8&code_challenge_method=S256\"\n\t\treq := httptest.NewRequest(http.MethodGet, originalURL, nil)\n\t\tw := httptest.NewRecorder()\n\n\t\tauthCtx := &mocks.AuthenticationContext{}\n\t\toauth2Provider := &mocks.OAuth2Provider{}\n\t\toauth2Provider.OnNewAuthorizeRequest(req.Context(), req).Return(fosite.NewAuthorizeRequest(), nil)\n\t\tauthCtx.OnOAuth2Provider().Return(oauth2Provider)\n\n\t\tcookieManager := &mocks.CookieHandler{}\n\t\tcookieManager.OnSetAuthCodeCookie(req.Context(), w, originalURL).Return(nil)\n\t\tauthCtx.OnCookieManager().Return(cookieManager)\n\n\t\tauthEndpoint(authCtx, w, req)\n\t\tassert.Equal(t, http.StatusTemporaryRedirect, w.Code)\n\t})\n\n\tt.Run(\"Fail to write cookie\", func(t *testing.T) {\n\t\toriginalURL := \"http://localhost:8088/oauth2/authorize?client_id=my-client&redirect_uri=http%3A%2F%2Flocalhost%3A3846%2Fcallback&response_type=code&scope=photos+openid+offline&state=some-random-state-foobar&nonce=some-random-nonce&code_challenge=p0v_UR0KrXl4--BpxM2BQa7qIW5k3k4WauBhjmkVQw8&code_challenge_method=S256\"\n\t\treq := httptest.NewRequest(http.MethodGet, originalURL, nil)\n\t\tw := httptest.NewRecorder()\n\n\t\tauthCtx := &mocks.AuthenticationContext{}\n\t\toauth2Provider := &mocks.OAuth2Provider{}\n\t\trequester := fosite.NewAuthorizeRequest()\n\t\toauth2Provider.OnNewAuthorizeRequest(req.Context(), req).Return(requester, nil)\n\t\toauth2Provider.On(\"WriteAuthorizeError\", w, requester, mock.Anything).Run(func(args mock.Arguments) {\n\t\t\trw := args.Get(0).(http.ResponseWriter)\n\t\t\trw.WriteHeader(http.StatusForbidden)\n\t\t})\n\t\tauthCtx.OnOAuth2Provider().Return(oauth2Provider)\n\n\t\tcookieManager := &mocks.CookieHandler{}\n\t\tcookieManager.OnSetAuthCodeCookie(req.Context(), w, originalURL).Return(fmt.Errorf(\"failure injection\"))\n\t\tauthCtx.OnCookieManager().Return(cookieManager)\n\n\t\tauthEndpoint(authCtx, w, req)\n\t\tassert.Equal(t, http.StatusForbidden, w.Code)\n\t})\n}\n\n// #nosec\nconst sampleIDToken = `eyJraWQiOiJaNmRtWl9UWGhkdXctalVCWjZ1RUV6dm5oLWpoTk8wWWhlbUI3cWFfTE9jIiwiYWxnIjoiUlMyNTYifQ.eyJzdWIiOiIwMHVra2k0OHBzSDhMaWtZVjVkNiIsIm5hbWUiOiJIYXl0aGFtIEFidWVsZnV0dWgiLCJ2ZXIiOjEsImlzcyI6Imh0dHBzOi8vZGV2LTE0MTg2NDIyLm9rdGEuY29tL29hdXRoMi9hdXNrbmdubjd1QlZpUXE2YjVkNiIsImF1ZCI6IjBvYWtraGV0ZU5qQ01FUnN0NWQ2IiwiaWF0IjoxNjE4NDUzNjc5LCJleHAiOjE2MTg0NTcyNzksImp0aSI6IklELmE0YXpLdUphVFM2YzNTeHdpWWdTMHhPbTM2bVFnVlVVN0I4V2dEdk80dFkiLCJhbXIiOlsicHdkIl0sImlkcCI6IjBvYWtrbTFjaTFVZVBwTlUwNWQ2IiwicHJlZmVycmVkX3VzZXJuYW1lIjoiaGF5dGhhbUB1bmlvbi5haSIsImF1dGhfdGltZSI6MTYxODQ0NjI0NywiYXRfaGFzaCI6Ikg5Q0FweWlrQkpGYXJ4d1FUbnB6ZFEifQ.SJ3BTD_MFcrYvTnql181Ddeb_mOm81z_S7ZKQ6P8mMgWqn94LZ2nG8k8-_odaaNAAT-M1nAFKWqZAQGvliwS1_TsD8_j0cen5zYnGcz2Uu5fFlvoHwuPgy5JYYNOXkXYgPnIb3kNkgXKbkdjS9hdbMfvnPd9rr8v0yzqf0AQBnUe-cPrzY-ZJjvh80IWDZgSjoP244tTYppPkx8UtedJLJZ4tzB7aXlEyoRV-DpmOLfJkAmblRm4OsO1qjwmx3HSIy_T-0PANn-g4AS07rpoMYHRcqncdgcAsVfGxjyWiOg3kbymLqpGlkIZgzmev-TmpoDp0QkUVPOntuiB57GZ6g`\n\n//func TestAuthCallbackEndpoint(t *testing.T) {\n//\toriginalURL := \"http://localhost:8088/oauth2/authorize?client_id=my-client&redirect_uri=http%3A%2F%2Flocalhost%3A3846%2Fcallback&response_type=code&scope=photos+openid+offline&state=some-random-state-foobar&nonce=some-random-nonce&code_challenge=p0v_UR0KrXl4--BpxM2BQa7qIW5k3k4WauBhjmkVQw8&code_challenge_method=S256\"\n//\treq := httptest.NewRequest(http.MethodGet, originalURL, nil)\n//\tw := httptest.NewRecorder()\n//\n//\tauthCtx := &mocks.AuthenticationContext{}\n//\n//\toauth2Provider := &mocks.OAuth2Provider{}\n//\trequester := fosite.NewAuthorizeRequest()\n//\toauth2Provider.OnNewAuthorizeRequest(req.Context(), req).Return(requester, nil)\n//\toauth2Provider.On(\"WriteAuthorizeError\", w, requester, mock.Anything).Run(func(args mock.Arguments) {\n//\t\trw := args.Get(0).(http.ResponseWriter)\n//\t\trw.WriteHeader(http.StatusForbidden)\n//\t})\n//\n//\tauthCtx.OnOAuth2Provider().Return(oauth2Provider)\n//\n//\tcookieManager := &mocks.CookieHandler{}\n//\tcookieManager.OnSetAuthCodeCookie(req.Context(), w, originalURL).Return(nil)\n//\tcookieManager.OnRetrieveTokenValues(req.Context(), req).Return(sampleIDToken, \"\", \"\", nil)\n//\tcookieManager.OnRetrieveUserInfo(req.Context(), req).Return(&service.UserInfoResponse{Subject: \"abc\"}, nil)\n//\tauthCtx.OnCookieManager().Return(cookieManager)\n//\n//\tauthCtx.OnOptions().Return(&config.Config{\n//\t\tUserAuth: config.UserAuthConfig{\n//\t\t\tOpenID: config.OpenIDOptions{\n//\t\t\t\t//ClientID: \"http://localhost\",\n//\t\t\t},\n//\t\t},\n//\t})\n//\n//\tctx, cancel := context.WithCancel(context.Background())\n//\tdefer cancel()\n//\n//\tvar issuer string\n//\thf := func(w http.ResponseWriter, r *http.Request) {\n//\t\tif r.URL.Path == \"/.well-known/openid-configuration\" {\n//\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n//\t\t\tio.WriteString(w, strings.ReplaceAll(`{\n//\t\t\t\t\"issuer\": \"ISSUER\",\n//\t\t\t\t\"authorization_endpoint\": \"https://example.com/auth\",\n//\t\t\t\t\"token_endpoint\": \"https://example.com/token\",\n//\t\t\t\t\"jwks_uri\": \"ISSUER/keys\",\n//\t\t\t\t\"id_token_signing_alg_values_supported\": [\"RS256\"]\n//\t\t\t}`, \"ISSUER\", issuer))\n//\t\t\treturn\n//\t\t} else if r.URL.Path == \"/keys\" {\n//\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n//\t\t\tio.WriteString(w, `{\"keys\":[{\"kty\":\"RSA\",\"alg\":\"RS256\",\"kid\":\"Z6dmZ_TXhduw-jUBZ6uEEzvnh-jhNO0YhemB7qa_LOc\",\"use\":\"sig\",\"e\":\"AQAB\",\"n\":\"jyMcudBiz7XqeDIvxfMlmG4fvAUU7cl3R4iSIv_ahHanCcVRvqcXOsIknwn7i4rOUjP6MlH45uIYsaj6MuLYgoaIbC-Z823Tu4asoC-rGbpZgf-bMcJLxtZVBNsSagr_M0n8xA1oogHRF1LGRiD93wNr2b9OkKVbWnyNdASk5_xui024nVzakm2-RAEyaC048nHfnjVBvwo4BdJVDgBEK03fbkBCyuaZyE1ZQF545MTbD4keCv58prSCmbDRJgRk48FzaFnQeYTho-pUxXxM9pvhMykeI62WZ7diDfIc9isOpv6ALFOHgKy7Ihhve6pLIylLRTnn2qhHFkGPtU3djQ\"}]}`)\n//\t\t\treturn\n//\t\t}\n//\n//\t\thttp.NotFound(w, r)\n//\t\treturn\n//\n//\t}\n//\n//\ts := httptest.NewServer(http.HandlerFunc(hf))\n//\tdefer s.Close()\n//\n//\tissuer = s.URL\n//\tmockOidcProvider, err := oidc.NewProvider(ctx, issuer)\n//\tif !assert.NoError(t, err) {\n//\t\tt.FailNow()\n//\t}\n//\n//\tauthCtx.OnOidcProvider().Return(mockOidcProvider)\n//\n//\tauthCallbackEndpoint(authCtx, w, req)\n//\tassert.Equal(t, http.StatusTemporaryRedirect, w.Code)\n//}\n\nfunc TestGetIssuer(t *testing.T) {\n\tt.Run(\"SelfAuthServerIssuer wins\", func(t *testing.T) {\n\t\tissuer := GetIssuer(context.Background(), nil, &config.Config{\n\t\t\tAppAuth: config.OAuth2Options{\n\t\t\t\tSelfAuthServer: config.AuthorizationServer{\n\t\t\t\t\tIssuer: \"my_issuer\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAuthorizedURIs: []config2.URL{{URL: *config.MustParseURL(\"http://localhost/\")}},\n\t\t})\n\n\t\tassert.Equal(t, \"my_issuer\", issuer)\n\t})\n\n\tt.Run(\"Fallback to http public uri\", func(t *testing.T) {\n\t\tissuer := GetIssuer(context.Background(), nil, &config.Config{\n\t\t\tAuthorizedURIs: []config2.URL{{URL: *config.MustParseURL(\"http://localhost/\")}},\n\t\t})\n\n\t\tassert.Equal(t, \"http://localhost/\", issuer)\n\t})\n}\n\nfunc TestEncryptDecrypt(t *testing.T) {\n\tcookieHashKey := [auth.SymmetricKeyLength]byte{}\n\t_, err := rand.Read(cookieHashKey[:])\n\tassert.NoError(t, err)\n\n\tinput := \"hello world\"\n\tencrypted, err := encryptString(input, cookieHashKey)\n\tassert.NoError(t, err)\n\n\tdecrypted, err := decryptString(encrypted, cookieHashKey)\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, input, decrypted)\n\tassert.NotEqual(t, input, encrypted)\n}\n", "package authzserver\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"mime\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"k8s.io/apimachinery/pkg/util/sets\"\n\n\t\"github.com/flyteorg/flytestdlib/config\"\n\n\t\"github.com/coreos/go-oidc\"\n\tauthConfig \"github.com/flyteorg/flyteadmin/auth/config\"\n\t\"github.com/flyteorg/flyteadmin/auth/interfaces\"\n\t\"github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/service\"\n\t\"golang.org/x/oauth2\"\n)\n\n// ResourceServer authorizes access requests issued by an external Authorization Server.\ntype ResourceServer struct {\n\tsignatureVerifier oidc.KeySet\n\tallowedAudience   []string\n}\n\nfunc (r ResourceServer) ValidateAccessToken(ctx context.Context, expectedAudience, tokenStr string) (interfaces.IdentityContext, error) {\n\traw, err := r.signatureVerifier.VerifySignature(ctx, tokenStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclaimsRaw := map[string]interface{}{}\n\tif err = json.Unmarshal(raw, &claimsRaw); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal user info claim into UserInfo type. Error: %w\", err)\n\t}\n\n\treturn verifyClaims(sets.NewString(append(r.allowedAudience, expectedAudience)...), claimsRaw)\n}\n\nfunc doRequest(ctx context.Context, req *http.Request) (*http.Response, error) {\n\tclient := http.DefaultClient\n\tif c, ok := ctx.Value(oauth2.HTTPClient).(*http.Client); ok {\n\t\tclient = c\n\t}\n\treturn client.Do(req.WithContext(ctx))\n}\n\nfunc unmarshalResp(r *http.Response, body []byte, v interface{}) error {\n\terr := json.Unmarshal(body, &v)\n\tif err == nil {\n\t\treturn nil\n\t}\n\tct := r.Header.Get(\"Content-Type\")\n\tmediaType, _, parseErr := mime.ParseMediaType(ct)\n\tif parseErr == nil && mediaType == \"application/json\" {\n\t\treturn fmt.Errorf(\"got Content-Type = application/json, but could not unmarshal as JSON: %v\", err)\n\t}\n\treturn fmt.Errorf(\"expected Content-Type = application/json, got %q: %v\", ct, err)\n}\n\nfunc getJwksForIssuer(ctx context.Context, issuerBaseURL url.URL, customMetadataURL url.URL) (keySet oidc.KeySet, err error) {\n\tissuerBaseURL.Path = strings.TrimSuffix(issuerBaseURL.Path, \"/\") + \"/\"\n\tvar wellKnown *url.URL\n\tif len(customMetadataURL.String()) > 0 {\n\t\twellKnown = issuerBaseURL.ResolveReference(&customMetadataURL)\n\t} else {\n\t\twellKnown = issuerBaseURL.ResolveReference(oauth2MetadataEndpoint)\n\t}\n\n\treq, err := http.NewRequest(http.MethodGet, wellKnown.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp, err := doRequest(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to read response body: %v\", err)\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"%s: %s\", resp.Status, body)\n\t}\n\n\tp := &service.OAuth2MetadataResponse{}\n\terr = unmarshalResp(resp, body, &p)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to decode provider discovery object: %v\", err)\n\t}\n\n\treturn oidc.NewRemoteKeySet(ctx, p.JwksUri), nil\n}\n\n// NewOAuth2ResourceServer initializes a new OAuth2ResourceServer.\nfunc NewOAuth2ResourceServer(ctx context.Context, cfg authConfig.ExternalAuthorizationServer, fallbackBaseURL config.URL) (ResourceServer, error) {\n\tu := cfg.BaseURL\n\tif len(u.String()) == 0 {\n\t\tu = fallbackBaseURL\n\t}\n\n\tverifier, err := getJwksForIssuer(ctx, u.URL, cfg.MetadataEndpointURL.URL)\n\tif err != nil {\n\t\treturn ResourceServer{}, err\n\t}\n\n\treturn ResourceServer{\n\t\tsignatureVerifier: verifier,\n\t\tallowedAudience:   cfg.AllowedAudience,\n\t}, nil\n}\n", "package authzserver\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"github.com/lestrrat-go/jwx/jwk\"\n\n\t\"github.com/coreos/go-oidc\"\n\t\"github.com/flyteorg/flyteadmin/auth/config\"\n\tauthConfig \"github.com/flyteorg/flyteadmin/auth/config\"\n\tstdlibConfig \"github.com/flyteorg/flytestdlib/config\"\n)\n\nfunc newMockResourceServer(t testing.TB) ResourceServer {\n\tctx := context.Background()\n\tdummy := \"\"\n\tserverURL := &dummy\n\thf := func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.URL.Path == \"/.well-known/oauth-authorization-server\" {\n\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\t_, err := io.WriteString(w, strings.ReplaceAll(`{\n\t\t\t\t\"issuer\": \"https://dev-14186422.okta.com\",\n\t\t\t\t\"authorization_endpoint\": \"https://example.com/auth\",\n\t\t\t\t\"token_endpoint\": \"https://example.com/token\",\n\t\t\t\t\"jwks_uri\": \"URL/keys\",\n\t\t\t\t\"id_token_signing_alg_values_supported\": [\"RS256\"]\n\t\t\t}`, \"URL\", *serverURL))\n\n\t\t\tif !assert.NoError(t, err) {\n\t\t\t\tt.FailNow()\n\t\t\t}\n\n\t\t\treturn\n\t\t} else if r.URL.Path == \"/keys\" {\n\t\t\tkeys := jwk.NewSet()\n\t\t\traw, err := json.Marshal(keys)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), 400)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\t_, err = io.WriteString(w, string(raw))\n\n\t\t\tif !assert.NoError(t, err) {\n\t\t\t\tt.FailNow()\n\t\t\t}\n\t\t}\n\n\t\thttp.NotFound(w, r)\n\t}\n\n\ts := httptest.NewServer(http.HandlerFunc(hf))\n\tdefer s.Close()\n\n\t*serverURL = s.URL\n\n\thttp.DefaultClient = s.Client()\n\n\tr, err := NewOAuth2ResourceServer(ctx, authConfig.ExternalAuthorizationServer{\n\t\tBaseURL: stdlibConfig.URL{URL: *config.MustParseURL(s.URL)},\n\t}, stdlibConfig.URL{})\n\tif !assert.NoError(t, err) {\n\t\tt.FailNow()\n\t}\n\n\treturn r\n}\n\nfunc TestNewOAuth2ResourceServer(t *testing.T) {\n\tnewMockResourceServer(t)\n}\n\nfunc TestResourceServer_ValidateAccessToken(t *testing.T) {\n\tr := newMockResourceServer(t)\n\t_, err := r.ValidateAccessToken(context.Background(), \"myserver\", sampleIDToken)\n\tassert.Error(t, err)\n}\n\nfunc Test_doRequest(t *testing.T) {\n\ttype args struct {\n\t\tctx context.Context\n\t\treq *http.Request\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *http.Response\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := doRequest(tt.args.ctx, tt.args.req)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"doRequest() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"doRequest() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_getJwksForIssuer(t *testing.T) {\n\ttype args struct {\n\t\tctx           context.Context\n\t\tissuerBaseURL url.URL\n\t\tcustomMetaURL url.URL\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    oidc.KeySet\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := getJwksForIssuer(tt.args.ctx, tt.args.issuerBaseURL, tt.args.customMetaURL)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"getJwksForIssuer() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"getJwksForIssuer() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unmarshalResp(t *testing.T) {\n\ttype args struct {\n\t\tr    *http.Response\n\t\tbody []byte\n\t\tv    interface{}\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif err := unmarshalResp(tt.args.r, tt.args.body, tt.args.v); (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"unmarshalResp() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n"], "fixing_code": ["package authzserver\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\tconfig2 \"github.com/flyteorg/flytestdlib/config\"\n\n\t\"github.com/flyteorg/flyteadmin/auth\"\n\t\"github.com/stretchr/testify/mock\"\n\n\t\"github.com/flyteorg/flyteadmin/auth/interfaces/mocks\"\n\n\t\"github.com/flyteorg/flyteadmin/auth/config\"\n\n\t\"github.com/ory/fosite\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestAuthEndpoint(t *testing.T) {\n\tt.Run(\"Success\", func(t *testing.T) {\n\t\toriginalURL := \"http://localhost:8088/oauth2/authorize?client_id=my-client&redirect_uri=http%3A%2F%2Flocalhost%3A3846%2Fcallback&response_type=code&scope=photos+openid+offline&state=some-random-state-foobar&nonce=some-random-nonce&code_challenge=p0v_UR0KrXl4--BpxM2BQa7qIW5k3k4WauBhjmkVQw8&code_challenge_method=S256\"\n\t\treq := httptest.NewRequest(http.MethodGet, originalURL, nil)\n\t\tw := httptest.NewRecorder()\n\n\t\tauthCtx := &mocks.AuthenticationContext{}\n\t\toauth2Provider := &mocks.OAuth2Provider{}\n\t\toauth2Provider.OnNewAuthorizeRequest(req.Context(), req).Return(fosite.NewAuthorizeRequest(), nil)\n\t\tauthCtx.OnOAuth2Provider().Return(oauth2Provider)\n\n\t\tcookieManager := &mocks.CookieHandler{}\n\t\tcookieManager.OnSetAuthCodeCookie(req.Context(), w, originalURL).Return(nil)\n\t\tauthCtx.OnCookieManager().Return(cookieManager)\n\n\t\tauthEndpoint(authCtx, w, req)\n\t\tassert.Equal(t, http.StatusTemporaryRedirect, w.Code)\n\t})\n\n\tt.Run(\"Fail to write cookie\", func(t *testing.T) {\n\t\toriginalURL := \"http://localhost:8088/oauth2/authorize?client_id=my-client&redirect_uri=http%3A%2F%2Flocalhost%3A3846%2Fcallback&response_type=code&scope=photos+openid+offline&state=some-random-state-foobar&nonce=some-random-nonce&code_challenge=p0v_UR0KrXl4--BpxM2BQa7qIW5k3k4WauBhjmkVQw8&code_challenge_method=S256\"\n\t\treq := httptest.NewRequest(http.MethodGet, originalURL, nil)\n\t\tw := httptest.NewRecorder()\n\n\t\tauthCtx := &mocks.AuthenticationContext{}\n\t\toauth2Provider := &mocks.OAuth2Provider{}\n\t\trequester := fosite.NewAuthorizeRequest()\n\t\toauth2Provider.OnNewAuthorizeRequest(req.Context(), req).Return(requester, nil)\n\t\toauth2Provider.On(\"WriteAuthorizeError\", w, requester, mock.Anything).Run(func(args mock.Arguments) {\n\t\t\trw := args.Get(0).(http.ResponseWriter)\n\t\t\trw.WriteHeader(http.StatusForbidden)\n\t\t})\n\t\tauthCtx.OnOAuth2Provider().Return(oauth2Provider)\n\n\t\tcookieManager := &mocks.CookieHandler{}\n\t\tcookieManager.OnSetAuthCodeCookie(req.Context(), w, originalURL).Return(fmt.Errorf(\"failure injection\"))\n\t\tauthCtx.OnCookieManager().Return(cookieManager)\n\n\t\tauthEndpoint(authCtx, w, req)\n\t\tassert.Equal(t, http.StatusForbidden, w.Code)\n\t})\n}\n\n//func TestAuthCallbackEndpoint(t *testing.T) {\n//\toriginalURL := \"http://localhost:8088/oauth2/authorize?client_id=my-client&redirect_uri=http%3A%2F%2Flocalhost%3A3846%2Fcallback&response_type=code&scope=photos+openid+offline&state=some-random-state-foobar&nonce=some-random-nonce&code_challenge=p0v_UR0KrXl4--BpxM2BQa7qIW5k3k4WauBhjmkVQw8&code_challenge_method=S256\"\n//\treq := httptest.NewRequest(http.MethodGet, originalURL, nil)\n//\tw := httptest.NewRecorder()\n//\n//\tauthCtx := &mocks.AuthenticationContext{}\n//\n//\toauth2Provider := &mocks.OAuth2Provider{}\n//\trequester := fosite.NewAuthorizeRequest()\n//\toauth2Provider.OnNewAuthorizeRequest(req.Context(), req).Return(requester, nil)\n//\toauth2Provider.On(\"WriteAuthorizeError\", w, requester, mock.Anything).Run(func(args mock.Arguments) {\n//\t\trw := args.Get(0).(http.ResponseWriter)\n//\t\trw.WriteHeader(http.StatusForbidden)\n//\t})\n//\n//\tauthCtx.OnOAuth2Provider().Return(oauth2Provider)\n//\n//\tcookieManager := &mocks.CookieHandler{}\n//\tcookieManager.OnSetAuthCodeCookie(req.Context(), w, originalURL).Return(nil)\n//\tcookieManager.OnRetrieveTokenValues(req.Context(), req).Return(sampleIDToken, \"\", \"\", nil)\n//\tcookieManager.OnRetrieveUserInfo(req.Context(), req).Return(&service.UserInfoResponse{Subject: \"abc\"}, nil)\n//\tauthCtx.OnCookieManager().Return(cookieManager)\n//\n//\tauthCtx.OnOptions().Return(&config.Config{\n//\t\tUserAuth: config.UserAuthConfig{\n//\t\t\tOpenID: config.OpenIDOptions{\n//\t\t\t\t//ClientID: \"http://localhost\",\n//\t\t\t},\n//\t\t},\n//\t})\n//\n//\tctx, cancel := context.WithCancel(context.Background())\n//\tdefer cancel()\n//\n//\tvar issuer string\n//\thf := func(w http.ResponseWriter, r *http.Request) {\n//\t\tif r.URL.Path == \"/.well-known/openid-configuration\" {\n//\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n//\t\t\tio.WriteString(w, strings.ReplaceAll(`{\n//\t\t\t\t\"issuer\": \"ISSUER\",\n//\t\t\t\t\"authorization_endpoint\": \"https://example.com/auth\",\n//\t\t\t\t\"token_endpoint\": \"https://example.com/token\",\n//\t\t\t\t\"jwks_uri\": \"ISSUER/keys\",\n//\t\t\t\t\"id_token_signing_alg_values_supported\": [\"RS256\"]\n//\t\t\t}`, \"ISSUER\", issuer))\n//\t\t\treturn\n//\t\t} else if r.URL.Path == \"/keys\" {\n//\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n//\t\t\tio.WriteString(w, `{\"keys\":[{\"kty\":\"RSA\",\"alg\":\"RS256\",\"kid\":\"Z6dmZ_TXhduw-jUBZ6uEEzvnh-jhNO0YhemB7qa_LOc\",\"use\":\"sig\",\"e\":\"AQAB\",\"n\":\"jyMcudBiz7XqeDIvxfMlmG4fvAUU7cl3R4iSIv_ahHanCcVRvqcXOsIknwn7i4rOUjP6MlH45uIYsaj6MuLYgoaIbC-Z823Tu4asoC-rGbpZgf-bMcJLxtZVBNsSagr_M0n8xA1oogHRF1LGRiD93wNr2b9OkKVbWnyNdASk5_xui024nVzakm2-RAEyaC048nHfnjVBvwo4BdJVDgBEK03fbkBCyuaZyE1ZQF545MTbD4keCv58prSCmbDRJgRk48FzaFnQeYTho-pUxXxM9pvhMykeI62WZ7diDfIc9isOpv6ALFOHgKy7Ihhve6pLIylLRTnn2qhHFkGPtU3djQ\"}]}`)\n//\t\t\treturn\n//\t\t}\n//\n//\t\thttp.NotFound(w, r)\n//\t\treturn\n//\n//\t}\n//\n//\ts := httptest.NewServer(http.HandlerFunc(hf))\n//\tdefer s.Close()\n//\n//\tissuer = s.URL\n//\tmockOidcProvider, err := oidc.NewProvider(ctx, issuer)\n//\tif !assert.NoError(t, err) {\n//\t\tt.FailNow()\n//\t}\n//\n//\tauthCtx.OnOidcProvider().Return(mockOidcProvider)\n//\n//\tauthCallbackEndpoint(authCtx, w, req)\n//\tassert.Equal(t, http.StatusTemporaryRedirect, w.Code)\n//}\n\nfunc TestGetIssuer(t *testing.T) {\n\tt.Run(\"SelfAuthServerIssuer wins\", func(t *testing.T) {\n\t\tissuer := GetIssuer(context.Background(), nil, &config.Config{\n\t\t\tAppAuth: config.OAuth2Options{\n\t\t\t\tSelfAuthServer: config.AuthorizationServer{\n\t\t\t\t\tIssuer: \"my_issuer\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAuthorizedURIs: []config2.URL{{URL: *config.MustParseURL(\"http://localhost/\")}},\n\t\t})\n\n\t\tassert.Equal(t, \"my_issuer\", issuer)\n\t})\n\n\tt.Run(\"Fallback to http public uri\", func(t *testing.T) {\n\t\tissuer := GetIssuer(context.Background(), nil, &config.Config{\n\t\t\tAuthorizedURIs: []config2.URL{{URL: *config.MustParseURL(\"http://localhost/\")}},\n\t\t})\n\n\t\tassert.Equal(t, \"http://localhost/\", issuer)\n\t})\n}\n\nfunc TestEncryptDecrypt(t *testing.T) {\n\tcookieHashKey := [auth.SymmetricKeyLength]byte{}\n\t_, err := rand.Read(cookieHashKey[:])\n\tassert.NoError(t, err)\n\n\tinput := \"hello world\"\n\tencrypted, err := encryptString(input, cookieHashKey)\n\tassert.NoError(t, err)\n\n\tdecrypted, err := decryptString(encrypted, cookieHashKey)\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, input, decrypted)\n\tassert.NotEqual(t, input, encrypted)\n}\n", "package authzserver\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\tjwtgo \"github.com/golang-jwt/jwt/v4\"\n\t\"io/ioutil\"\n\t\"mime\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"k8s.io/apimachinery/pkg/util/sets\"\n\n\t\"github.com/flyteorg/flytestdlib/config\"\n\n\t\"github.com/coreos/go-oidc\"\n\tauthConfig \"github.com/flyteorg/flyteadmin/auth/config\"\n\t\"github.com/flyteorg/flyteadmin/auth/interfaces\"\n\t\"github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/service\"\n\t\"golang.org/x/oauth2\"\n)\n\n// ResourceServer authorizes access requests issued by an external Authorization Server.\ntype ResourceServer struct {\n\tsignatureVerifier oidc.KeySet\n\tallowedAudience   []string\n}\n\nfunc (r ResourceServer) ValidateAccessToken(ctx context.Context, expectedAudience, tokenStr string) (interfaces.IdentityContext, error) {\n\t_, err := r.signatureVerifier.VerifySignature(ctx, tokenStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tt, _, err := jwtgo.NewParser().ParseUnverified(tokenStr, jwtgo.MapClaims{})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse token: %v\", err)\n\t}\n\n\tif err = t.Claims.Valid(); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to validate token: %v\", err)\n\t}\n\n\treturn verifyClaims(sets.NewString(append(r.allowedAudience, expectedAudience)...), t.Claims.(jwtgo.MapClaims))\n}\n\nfunc doRequest(ctx context.Context, req *http.Request) (*http.Response, error) {\n\tclient := http.DefaultClient\n\tif c, ok := ctx.Value(oauth2.HTTPClient).(*http.Client); ok {\n\t\tclient = c\n\t}\n\treturn client.Do(req.WithContext(ctx))\n}\n\nfunc unmarshalResp(r *http.Response, body []byte, v interface{}) error {\n\terr := json.Unmarshal(body, &v)\n\tif err == nil {\n\t\treturn nil\n\t}\n\tct := r.Header.Get(\"Content-Type\")\n\tmediaType, _, parseErr := mime.ParseMediaType(ct)\n\tif parseErr == nil && mediaType == \"application/json\" {\n\t\treturn fmt.Errorf(\"got Content-Type = application/json, but could not unmarshal as JSON: %v\", err)\n\t}\n\treturn fmt.Errorf(\"expected Content-Type = application/json, got %q: %v\", ct, err)\n}\n\nfunc getJwksForIssuer(ctx context.Context, issuerBaseURL url.URL, customMetadataURL url.URL) (keySet oidc.KeySet, err error) {\n\tissuerBaseURL.Path = strings.TrimSuffix(issuerBaseURL.Path, \"/\") + \"/\"\n\tvar wellKnown *url.URL\n\tif len(customMetadataURL.String()) > 0 {\n\t\twellKnown = issuerBaseURL.ResolveReference(&customMetadataURL)\n\t} else {\n\t\twellKnown = issuerBaseURL.ResolveReference(oauth2MetadataEndpoint)\n\t}\n\n\treq, err := http.NewRequest(http.MethodGet, wellKnown.String(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp, err := doRequest(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to read response body: %v\", err)\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"%s: %s\", resp.Status, body)\n\t}\n\n\tp := &service.OAuth2MetadataResponse{}\n\terr = unmarshalResp(resp, body, &p)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to decode provider discovery object: %v\", err)\n\t}\n\n\treturn oidc.NewRemoteKeySet(ctx, p.JwksUri), nil\n}\n\n// NewOAuth2ResourceServer initializes a new OAuth2ResourceServer.\nfunc NewOAuth2ResourceServer(ctx context.Context, cfg authConfig.ExternalAuthorizationServer, fallbackBaseURL config.URL) (ResourceServer, error) {\n\tu := cfg.BaseURL\n\tif len(u.String()) == 0 {\n\t\tu = fallbackBaseURL\n\t}\n\n\tverifier, err := getJwksForIssuer(ctx, u.URL, cfg.MetadataEndpointURL.URL)\n\tif err != nil {\n\t\treturn ResourceServer{}, err\n\t}\n\n\treturn ResourceServer{\n\t\tsignatureVerifier: verifier,\n\t\tallowedAudience:   cfg.AllowedAudience,\n\t}, nil\n}\n", "package authzserver\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/golang-jwt/jwt/v4\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"github.com/lestrrat-go/jwx/jwk\"\n\n\t\"github.com/coreos/go-oidc\"\n\t\"github.com/flyteorg/flyteadmin/auth/config\"\n\tauthConfig \"github.com/flyteorg/flyteadmin/auth/config\"\n\tstdlibConfig \"github.com/flyteorg/flytestdlib/config\"\n)\n\nfunc newMockResourceServer(t testing.TB, publicKey rsa.PublicKey) (resourceServer ResourceServer, closer func()) {\n\tctx := context.Background()\n\tdummy := \"\"\n\tserverURL := &dummy\n\thf := func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.URL.Path == \"/.well-known/oauth-authorization-server\" {\n\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\t_, err := io.WriteString(w, strings.ReplaceAll(`{\n\t\t\t\t\"issuer\": \"https://whatever.okta.com\",\n\t\t\t\t\"authorization_endpoint\": \"https://example.com/auth\",\n\t\t\t\t\"token_endpoint\": \"https://example.com/token\",\n\t\t\t\t\"jwks_uri\": \"{URL}/keys\",\n\t\t\t\t\"id_token_signing_alg_values_supported\": [\"RS256\"]\n\t\t\t}`, \"{URL}\", *serverURL))\n\n\t\t\tif !assert.NoError(t, err) {\n\t\t\t\tt.FailNow()\n\t\t\t}\n\n\t\t\treturn\n\t\t} else if r.URL.Path == \"/keys\" {\n\t\t\tkeys := jwk.NewSet()\n\t\t\tkey := jwk.NewRSAPublicKey()\n\t\t\terr := key.FromRaw(&publicKey)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), 400)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tkeys.Add(key)\n\t\t\traw, err := json.Marshal(keys)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), 400)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\t_, err = io.WriteString(w, string(raw))\n\n\t\t\tif !assert.NoError(t, err) {\n\t\t\t\tt.FailNow()\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\thttp.NotFound(w, r)\n\t}\n\n\ts := httptest.NewServer(http.HandlerFunc(hf))\n\t*serverURL = s.URL\n\n\thttp.DefaultClient = s.Client()\n\n\tr, err := NewOAuth2ResourceServer(ctx, authConfig.ExternalAuthorizationServer{\n\t\tBaseURL:         stdlibConfig.URL{URL: *config.MustParseURL(s.URL)},\n\t\tAllowedAudience: []string{\"https://localhost\"},\n\t}, stdlibConfig.URL{})\n\tif !assert.NoError(t, err) {\n\t\tt.FailNow()\n\t}\n\n\treturn r, func() {\n\t\ts.Close()\n\t}\n}\n\nfunc TestResourceServer_ValidateAccessToken(t *testing.T) {\n\tsampleRSAKey, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif !assert.NoError(t, err) {\n\t\tt.FailNow()\n\t}\n\n\tr, closer := newMockResourceServer(t, sampleRSAKey.PublicKey)\n\tdefer closer()\n\n\tt.Run(\"No signature\", func(t *testing.T) {\n\t\tsampleIDToken, err := jwt.NewWithClaims(jwt.SigningMethodRS512, jwt.RegisteredClaims{\n\t\t\tAudience:  r.allowedAudience,\n\t\t\tExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Hour)),\n\t\t\tIssuedAt:  jwt.NewNumericDate(time.Now()),\n\t\t\tIssuer:    \"localhost\",\n\t\t\tSubject:   \"someone\",\n\t\t}).SignedString(sampleRSAKey)\n\t\tif !assert.NoError(t, err) {\n\t\t\tt.FailNow()\n\t\t}\n\n\t\tparts := strings.Split(sampleIDToken, \".\")\n\t\tsampleIDToken = strings.Join(parts[:len(parts)-1], \".\") + \".\"\n\n\t\t_, err = r.ValidateAccessToken(context.Background(), \"myserver\", sampleIDToken)\n\t\tif !assert.Error(t, err) {\n\t\t\tt.FailNow()\n\t\t}\n\n\t\tassert.Contains(t, err.Error(), \"failed to verify id token signature\")\n\t})\n\n\tt.Run(\"Invalid signature\", func(t *testing.T) {\n\t\tsampleRSAKey, err := rsa.GenerateKey(rand.Reader, 2048)\n\t\tif !assert.NoError(t, err) {\n\t\t\tt.FailNow()\n\t\t}\n\n\t\tsampleIDToken, err := jwt.NewWithClaims(jwt.SigningMethodRS512, jwt.RegisteredClaims{\n\t\t\tAudience:  r.allowedAudience,\n\t\t\tExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Hour)),\n\t\t\tIssuedAt:  jwt.NewNumericDate(time.Now()),\n\t\t\tIssuer:    \"localhost\",\n\t\t\tSubject:   \"someone\",\n\t\t}).SignedString(sampleRSAKey)\n\t\tif !assert.NoError(t, err) {\n\t\t\tt.FailNow()\n\t\t}\n\n\t\t_, err = r.ValidateAccessToken(context.Background(), \"myserver\", sampleIDToken)\n\t\tif !assert.Error(t, err) {\n\t\t\tt.FailNow()\n\t\t}\n\n\t\tassert.Contains(t, err.Error(), \"failed to verify id token signature\")\n\t})\n\n\tt.Run(\"Invalid audience\", func(t *testing.T) {\n\t\tsampleIDToken, err := jwt.NewWithClaims(jwt.SigningMethodRS512, jwt.RegisteredClaims{\n\t\t\tAudience:  []string{\"https://hello world\"},\n\t\t\tExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Hour)),\n\t\t\tIssuedAt:  jwt.NewNumericDate(time.Now()),\n\t\t\tIssuer:    \"localhost\",\n\t\t\tSubject:   \"someone\",\n\t\t}).SignedString(sampleRSAKey)\n\t\tif !assert.NoError(t, err) {\n\t\t\tt.FailNow()\n\t\t}\n\n\t\t_, err = r.ValidateAccessToken(context.Background(), \"myserver\", sampleIDToken)\n\t\tif !assert.Error(t, err) {\n\t\t\tt.FailNow()\n\t\t}\n\n\t\tassert.Contains(t, err.Error(), \"invalid audience\")\n\t})\n\n\tt.Run(\"Expired token\", func(t *testing.T) {\n\t\tsampleIDToken, err := jwt.NewWithClaims(jwt.SigningMethodRS512, jwt.StandardClaims{\n\t\t\tAudience:  r.allowedAudience[0],\n\t\t\tExpiresAt: time.Now().Add(-time.Hour).Unix(),\n\t\t\tIssuedAt:  time.Now().Add(-2 * time.Hour).Unix(),\n\t\t\tIssuer:    \"localhost\",\n\t\t\tSubject:   \"someone\",\n\t\t}).SignedString(sampleRSAKey)\n\t\tif !assert.NoError(t, err) {\n\t\t\tt.FailNow()\n\t\t}\n\n\t\t_, err = r.ValidateAccessToken(context.Background(), \"myserver\", sampleIDToken)\n\t\tif !assert.Error(t, err) {\n\t\t\tt.FailNow()\n\t\t}\n\n\t\tassert.Contains(t, err.Error(), \"failed to validate token: Token is expired\")\n\t})\n}\n\nfunc Test_doRequest(t *testing.T) {\n\ttype args struct {\n\t\tctx context.Context\n\t\treq *http.Request\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    *http.Response\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := doRequest(tt.args.ctx, tt.args.req)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"doRequest() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"doRequest() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_getJwksForIssuer(t *testing.T) {\n\ttype args struct {\n\t\tctx           context.Context\n\t\tissuerBaseURL url.URL\n\t\tcustomMetaURL url.URL\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    oidc.KeySet\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := getJwksForIssuer(tt.args.ctx, tt.args.issuerBaseURL, tt.args.customMetaURL)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"getJwksForIssuer() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"getJwksForIssuer() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_unmarshalResp(t *testing.T) {\n\ttype args struct {\n\t\tr    *http.Response\n\t\tbody []byte\n\t\tv    interface{}\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif err := unmarshalResp(tt.args.r, tt.args.body, tt.args.v); (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"unmarshalResp() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n"], "filenames": ["auth/authzserver/authorize_test.go", "auth/authzserver/resource_server.go", "auth/authzserver/resource_server_test.go"], "buggy_code_start_loc": [67, 6, 4], "buggy_code_end_loc": [70, 42, 88], "fixing_code_start_loc": [66, 7, 5], "fixing_code_end_loc": [66, 47, 192], "type": "CWE-613", "message": "FlyteAdmin is the control plane for Flyte responsible for managing entities and administering workflow executions. In versions 1.1.30 and prior, authenticated users using an external identity provider can continue to use Access Tokens and ID Tokens even after they expire. Users who use FlyteAdmin as the OAuth2 Authorization Server are unaffected by this issue. A patch is available on the `master` branch of the repository. As a workaround, rotating signing keys immediately will invalidate all open sessions and force all users to attempt to obtain new tokens. Those who use this workaround should continue to rotate keys until FlyteAdmin has been upgraded and hide FlyteAdmin deployment ingress URL from the internet.", "other": {"cve": {"id": "CVE-2022-31145", "sourceIdentifier": "security-advisories@github.com", "published": "2022-07-13T21:15:08.017", "lastModified": "2022-07-20T15:01:04.037", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "FlyteAdmin is the control plane for Flyte responsible for managing entities and administering workflow executions. In versions 1.1.30 and prior, authenticated users using an external identity provider can continue to use Access Tokens and ID Tokens even after they expire. Users who use FlyteAdmin as the OAuth2 Authorization Server are unaffected by this issue. A patch is available on the `master` branch of the repository. As a workaround, rotating signing keys immediately will invalidate all open sessions and force all users to attempt to obtain new tokens. Those who use this workaround should continue to rotate keys until FlyteAdmin has been upgraded and hide FlyteAdmin deployment ingress URL from the internet."}, {"lang": "es", "value": "FlyteAdmin es el plano de control de Flyte responsable de la administraci\u00f3n de entidades y de la administraci\u00f3n de las ejecuciones del flujo de trabajo. En versiones 1.1.30 y anteriores, los usuarios autenticados usando un proveedor de identidad externo pueden seguir usando los tokens de acceso y los tokens de identificaci\u00f3n incluso despu\u00e9s de que expiren. Los usuarios que usan FlyteAdmin como servidor de autorizaci\u00f3n OAuth2 no est\u00e1n afectados por este problema. Se presenta un parche disponible en la rama \"master\" del repositorio. Como mitigaci\u00f3n, rotar las claves de firma inmediatamente invalidar\u00e1 todas las sesiones abiertas y obligar\u00e1 a todos los usuarios a intentar obtener nuevos tokens. Aquellos que usen esta mitigaci\u00f3n deber\u00edan continuar rotando las claves hasta que FlyteAdmin haya sido actualizado y ocultar la URL de entrada del despliegue de FlyteAdmin de Internet"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-613"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:flyte:flyteadmin:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.31", "matchCriteriaId": "13F09ADA-0635-4ACC-9FBC-09A45856E601"}]}]}], "references": [{"url": "https://github.com/flyteorg/flyteadmin/commit/a1ec282d02706e074bc4986fd0412e5da3b9d00a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flyteorg/flyteadmin/pull/455", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flyteorg/flyteadmin/security/advisories/GHSA-qwrj-9hmp-gpxh", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/flyteorg/flyteadmin/commit/a1ec282d02706e074bc4986fd0412e5da3b9d00a"}}