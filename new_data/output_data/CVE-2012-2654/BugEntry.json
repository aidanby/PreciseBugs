{"buggy_code": ["# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2010 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nCloud Controller: Implementation of EC2 REST API calls, which are\ndispatched to other nodes via AMQP RPC. State is via distributed\ndatastore.\n\"\"\"\n\nimport base64\nimport re\nimport time\nimport urllib\n\nfrom nova.api.ec2 import ec2utils\nfrom nova.api.ec2 import inst_state\nfrom nova.api import validator\nfrom nova import block_device\nfrom nova import compute\nfrom nova.compute import instance_types\nfrom nova.compute import vm_states\nfrom nova import crypto\nfrom nova import db\nfrom nova import exception\nfrom nova import flags\nfrom nova.image import s3\nfrom nova import log as logging\nfrom nova import network\nfrom nova.rpc import common as rpc_common\nfrom nova import quota\nfrom nova import utils\nfrom nova import volume\n\n\nFLAGS = flags.FLAGS\nflags.DECLARE('dhcp_domain', 'nova.network.manager')\n\nLOG = logging.getLogger(__name__)\n\n\ndef validate_ec2_id(val):\n    if not validator.validate_str()(val):\n        raise exception.InvalidInstanceIDMalformed(val)\n    try:\n        ec2utils.ec2_id_to_id(val)\n    except exception.InvalidEc2Id:\n        raise exception.InvalidInstanceIDMalformed(val)\n\n\ndef _gen_key(context, user_id, key_name):\n    \"\"\"Generate a key\n\n    This is a module level method because it is slow and we need to defer\n    it into a process pool.\"\"\"\n    # NOTE(vish): generating key pair is slow so check for legal\n    #             creation before creating key_pair\n    try:\n        db.key_pair_get(context, user_id, key_name)\n        raise exception.KeyPairExists(key_name=key_name)\n    except exception.NotFound:\n        pass\n    private_key, public_key, fingerprint = crypto.generate_key_pair()\n    key = {}\n    key['user_id'] = user_id\n    key['name'] = key_name\n    key['public_key'] = public_key\n    key['fingerprint'] = fingerprint\n    db.key_pair_create(context, key)\n    return {'private_key': private_key, 'fingerprint': fingerprint}\n\n\n# EC2 API can return the following values as documented in the EC2 API\n# http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/\n#    ApiReference-ItemType-InstanceStateType.html\n# pending 0 | running 16 | shutting-down 32 | terminated 48 | stopping 64 |\n# stopped 80\n_STATE_DESCRIPTION_MAP = {\n    None: inst_state.PENDING,\n    vm_states.ACTIVE: inst_state.RUNNING,\n    vm_states.BUILDING: inst_state.PENDING,\n    vm_states.REBUILDING: inst_state.PENDING,\n    vm_states.DELETED: inst_state.TERMINATED,\n    vm_states.SOFT_DELETE: inst_state.TERMINATED,\n    vm_states.STOPPED: inst_state.STOPPED,\n    vm_states.SHUTOFF: inst_state.SHUTOFF,\n    vm_states.MIGRATING: inst_state.MIGRATE,\n    vm_states.RESIZING: inst_state.RESIZE,\n    vm_states.PAUSED: inst_state.PAUSE,\n    vm_states.SUSPENDED: inst_state.SUSPEND,\n    vm_states.RESCUED: inst_state.RESCUE,\n}\n\n\ndef _state_description(vm_state, shutdown_terminate):\n    \"\"\"Map the vm state to the server status string\"\"\"\n    if (vm_state == vm_states.SHUTOFF and\n        not shutdown_terminate):\n            name = inst_state.STOPPED\n    else:\n        name = _STATE_DESCRIPTION_MAP.get(vm_state, vm_state)\n\n    return {'code': inst_state.name_to_code(name),\n            'name': name}\n\n\ndef _parse_block_device_mapping(bdm):\n    \"\"\"Parse BlockDeviceMappingItemType into flat hash\n    BlockDevicedMapping.<N>.DeviceName\n    BlockDevicedMapping.<N>.Ebs.SnapshotId\n    BlockDevicedMapping.<N>.Ebs.VolumeSize\n    BlockDevicedMapping.<N>.Ebs.DeleteOnTermination\n    BlockDevicedMapping.<N>.Ebs.NoDevice\n    BlockDevicedMapping.<N>.VirtualName\n    => remove .Ebs and allow volume id in SnapshotId\n    \"\"\"\n    ebs = bdm.pop('ebs', None)\n    if ebs:\n        ec2_id = ebs.pop('snapshot_id', None)\n        if ec2_id:\n            id = ec2utils.ec2_id_to_id(ec2_id)\n            if ec2_id.startswith('snap-'):\n                bdm['snapshot_id'] = id\n            elif ec2_id.startswith('vol-'):\n                bdm['volume_id'] = id\n            ebs.setdefault('delete_on_termination', True)\n        bdm.update(ebs)\n    return bdm\n\n\ndef _properties_get_mappings(properties):\n    return block_device.mappings_prepend_dev(properties.get('mappings', []))\n\n\ndef _format_block_device_mapping(bdm):\n    \"\"\"Contruct BlockDeviceMappingItemType\n    {'device_name': '...', 'snapshot_id': , ...}\n    => BlockDeviceMappingItemType\n    \"\"\"\n    keys = (('deviceName', 'device_name'),\n             ('virtualName', 'virtual_name'))\n    item = {}\n    for name, k in keys:\n        if k in bdm:\n            item[name] = bdm[k]\n    if bdm.get('no_device'):\n        item['noDevice'] = True\n    if ('snapshot_id' in bdm) or ('volume_id' in bdm):\n        ebs_keys = (('snapshotId', 'snapshot_id'),\n                    ('snapshotId', 'volume_id'),        # snapshotId is abused\n                    ('volumeSize', 'volume_size'),\n                    ('deleteOnTermination', 'delete_on_termination'))\n        ebs = {}\n        for name, k in ebs_keys:\n            if k in bdm:\n                if k == 'snapshot_id':\n                    ebs[name] = ec2utils.id_to_ec2_snap_id(bdm[k])\n                elif k == 'volume_id':\n                    ebs[name] = ec2utils.id_to_ec2_vol_id(bdm[k])\n                else:\n                    ebs[name] = bdm[k]\n        assert 'snapshotId' in ebs\n        item['ebs'] = ebs\n    return item\n\n\ndef _format_mappings(properties, result):\n    \"\"\"Format multiple BlockDeviceMappingItemType\"\"\"\n    mappings = [{'virtualName': m['virtual'], 'deviceName': m['device']}\n                for m in _properties_get_mappings(properties)\n                if block_device.is_swap_or_ephemeral(m['virtual'])]\n\n    block_device_mapping = [_format_block_device_mapping(bdm) for bdm in\n                            properties.get('block_device_mapping', [])]\n\n    # NOTE(yamahata): overwrite mappings with block_device_mapping\n    for bdm in block_device_mapping:\n        for i in range(len(mappings)):\n            if bdm['deviceName'] == mappings[i]['deviceName']:\n                del mappings[i]\n                break\n        mappings.append(bdm)\n\n    # NOTE(yamahata): trim ebs.no_device == true. Is this necessary?\n    mappings = [bdm for bdm in mappings if not (bdm.get('noDevice', False))]\n\n    if mappings:\n        result['blockDeviceMapping'] = mappings\n\n\nclass CloudController(object):\n    \"\"\" CloudController provides the critical dispatch between\n inbound API calls through the endpoint and messages\n sent to the other nodes.\n\"\"\"\n    def __init__(self):\n        self.image_service = s3.S3ImageService()\n        self.network_api = network.API()\n        self.volume_api = volume.API()\n        self.compute_api = compute.API(network_api=self.network_api,\n                                       volume_api=self.volume_api)\n        self.sgh = utils.import_object(FLAGS.security_group_handler)\n\n    def __str__(self):\n        return 'CloudController'\n\n    def _get_image_state(self, image):\n        # NOTE(vish): fallback status if image_state isn't set\n        state = image.get('status')\n        if state == 'active':\n            state = 'available'\n        return image['properties'].get('image_state', state)\n\n    def describe_availability_zones(self, context, **kwargs):\n        if ('zone_name' in kwargs and\n            'verbose' in kwargs['zone_name'] and\n            context.is_admin):\n            return self._describe_availability_zones_verbose(context,\n                                                             **kwargs)\n        else:\n            return self._describe_availability_zones(context, **kwargs)\n\n    def _describe_availability_zones(self, context, **kwargs):\n        ctxt = context.elevated()\n        enabled_services = db.service_get_all(ctxt, False)\n        disabled_services = db.service_get_all(ctxt, True)\n        available_zones = []\n        for zone in [service.availability_zone for service\n                     in enabled_services]:\n            if not zone in available_zones:\n                available_zones.append(zone)\n        not_available_zones = []\n        for zone in [service.availability_zone for service in disabled_services\n                     if not service['availability_zone'] in available_zones]:\n            if not zone in not_available_zones:\n                not_available_zones.append(zone)\n        result = []\n        for zone in available_zones:\n            result.append({'zoneName': zone,\n                           'zoneState': \"available\"})\n        for zone in not_available_zones:\n            result.append({'zoneName': zone,\n                           'zoneState': \"not available\"})\n        return {'availabilityZoneInfo': result}\n\n    def _describe_availability_zones_verbose(self, context, **kwargs):\n        rv = {'availabilityZoneInfo': [{'zoneName': 'nova',\n                                        'zoneState': 'available'}]}\n\n        services = db.service_get_all(context, False)\n        hosts = []\n        for host in [service['host'] for service in services]:\n            if not host in hosts:\n                hosts.append(host)\n        for host in hosts:\n            rv['availabilityZoneInfo'].append({'zoneName': '|- %s' % host,\n                                               'zoneState': ''})\n            hsvcs = [service for service in services\n                     if service['host'] == host]\n            for svc in hsvcs:\n                alive = utils.service_is_up(svc)\n                art = (alive and \":-)\") or \"XXX\"\n                active = 'enabled'\n                if svc['disabled']:\n                    active = 'disabled'\n                rv['availabilityZoneInfo'].append({\n                        'zoneName': '| |- %s' % svc['binary'],\n                        'zoneState': '%s %s %s' % (active, art,\n                                                   svc['updated_at'])})\n        return rv\n\n    def describe_regions(self, context, region_name=None, **kwargs):\n        if FLAGS.region_list:\n            regions = []\n            for region in FLAGS.region_list:\n                name, _sep, host = region.partition('=')\n                endpoint = '%s://%s:%s%s' % (FLAGS.ec2_scheme,\n                                             host,\n                                             FLAGS.ec2_port,\n                                             FLAGS.ec2_path)\n                regions.append({'regionName': name,\n                                'regionEndpoint': endpoint})\n        else:\n            regions = [{'regionName': 'nova',\n                        'regionEndpoint': '%s://%s:%s%s' % (FLAGS.ec2_scheme,\n                                                            FLAGS.ec2_host,\n                                                            FLAGS.ec2_port,\n                                                            FLAGS.ec2_path)}]\n        return {'regionInfo': regions}\n\n    def describe_snapshots(self,\n                           context,\n                           snapshot_id=None,\n                           owner=None,\n                           restorable_by=None,\n                           **kwargs):\n        if snapshot_id:\n            snapshots = []\n            for ec2_id in snapshot_id:\n                internal_id = ec2utils.ec2_id_to_id(ec2_id)\n                snapshot = self.volume_api.get_snapshot(\n                    context,\n                    snapshot_id=internal_id)\n                snapshots.append(snapshot)\n        else:\n            snapshots = self.volume_api.get_all_snapshots(context)\n        snapshots = [self._format_snapshot(context, s) for s in snapshots]\n        return {'snapshotSet': snapshots}\n\n    def _format_snapshot(self, context, snapshot):\n        s = {}\n        s['snapshotId'] = ec2utils.id_to_ec2_snap_id(snapshot['id'])\n        s['volumeId'] = ec2utils.id_to_ec2_vol_id(snapshot['volume_id'])\n        s['status'] = snapshot['status']\n        s['startTime'] = snapshot['created_at']\n        s['progress'] = snapshot['progress']\n        s['ownerId'] = snapshot['project_id']\n        s['volumeSize'] = snapshot['volume_size']\n        s['description'] = snapshot['display_description']\n        return s\n\n    def create_snapshot(self, context, volume_id, **kwargs):\n        validate_ec2_id(volume_id)\n        LOG.audit(_(\"Create snapshot of volume %s\"), volume_id,\n                  context=context)\n        volume_id = ec2utils.ec2_id_to_id(volume_id)\n        volume = self.volume_api.get(context, volume_id)\n        snapshot = self.volume_api.create_snapshot(\n                context,\n                volume,\n                None,\n                kwargs.get('description'))\n        return self._format_snapshot(context, snapshot)\n\n    def delete_snapshot(self, context, snapshot_id, **kwargs):\n        snapshot_id = ec2utils.ec2_id_to_id(snapshot_id)\n        snapshot = self.volume_api.get_snapshot(context, snapshot_id)\n        self.volume_api.delete_snapshot(context, snapshot)\n        return True\n\n    def describe_key_pairs(self, context, key_name=None, **kwargs):\n        key_pairs = db.key_pair_get_all_by_user(context, context.user_id)\n        if not key_name is None:\n            key_pairs = [x for x in key_pairs if x['name'] in key_name]\n\n        result = []\n        for key_pair in key_pairs:\n            # filter out the vpn keys\n            suffix = FLAGS.vpn_key_suffix\n            if context.is_admin or not key_pair['name'].endswith(suffix):\n                result.append({\n                    'keyName': key_pair['name'],\n                    'keyFingerprint': key_pair['fingerprint'],\n                })\n\n        return {'keySet': result}\n\n    def create_key_pair(self, context, key_name, **kwargs):\n        if not re.match('^[a-zA-Z0-9_\\- ]+$', str(key_name)):\n            err = _(\"Value (%s) for KeyName is invalid.\"\n                    \" Content limited to Alphanumeric character, \"\n                    \"spaces, dashes, and underscore.\") % key_name\n            raise exception.EC2APIError(err)\n\n        if len(str(key_name)) > 255:\n            err = _(\"Value (%s) for Keyname is invalid.\"\n                    \" Length exceeds maximum of 255.\") % key_name\n            raise exception.EC2APIError(err)\n\n        LOG.audit(_(\"Create key pair %s\"), key_name, context=context)\n        data = _gen_key(context, context.user_id, key_name)\n        return {'keyName': key_name,\n                'keyFingerprint': data['fingerprint'],\n                'keyMaterial': data['private_key']}\n        # TODO(vish): when context is no longer an object, pass it here\n\n    def import_key_pair(self, context, key_name, public_key_material,\n                        **kwargs):\n        LOG.audit(_(\"Import key %s\"), key_name, context=context)\n        try:\n            db.key_pair_get(context, context.user_id, key_name)\n            raise exception.KeyPairExists(key_name=key_name)\n        except exception.NotFound:\n            pass\n        public_key = base64.b64decode(public_key_material)\n        fingerprint = crypto.generate_fingerprint(public_key)\n        key = {}\n        key['user_id'] = context.user_id\n        key['name'] = key_name\n        key['public_key'] = public_key\n        key['fingerprint'] = fingerprint\n        db.key_pair_create(context, key)\n        return {'keyName': key_name,\n                'keyFingerprint': fingerprint}\n\n    def delete_key_pair(self, context, key_name, **kwargs):\n        LOG.audit(_(\"Delete key pair %s\"), key_name, context=context)\n        try:\n            db.key_pair_destroy(context, context.user_id, key_name)\n        except exception.NotFound:\n            # aws returns true even if the key doesn't exist\n            pass\n        return True\n\n    def describe_security_groups(self, context, group_name=None, group_id=None,\n                                 **kwargs):\n        self.compute_api.ensure_default_security_group(context)\n        if group_name or group_id:\n            groups = []\n            if group_name:\n                for name in group_name:\n                    group = db.security_group_get_by_name(context,\n                                                          context.project_id,\n                                                          name)\n                    groups.append(group)\n            if group_id:\n                for gid in group_id:\n                    group = db.security_group_get(context, gid)\n                    groups.append(group)\n        elif context.is_admin:\n            groups = db.security_group_get_all(context)\n        else:\n            groups = db.security_group_get_by_project(context,\n                                                      context.project_id)\n        groups = [self._format_security_group(context, g) for g in groups]\n\n        return {'securityGroupInfo':\n                list(sorted(groups,\n                            key=lambda k: (k['ownerId'], k['groupName'])))}\n\n    def _format_security_group(self, context, group):\n        g = {}\n        g['groupDescription'] = group.description\n        g['groupName'] = group.name\n        g['ownerId'] = group.project_id\n        g['ipPermissions'] = []\n        for rule in group.rules:\n            r = {}\n            r['groups'] = []\n            r['ipRanges'] = []\n            if rule.group_id:\n                source_group = db.security_group_get(context, rule.group_id)\n                r['groups'] += [{'groupName': source_group.name,\n                                 'userId': source_group.project_id}]\n                if rule.protocol:\n                    r['ipProtocol'] = rule.protocol\n                    r['fromPort'] = rule.from_port\n                    r['toPort'] = rule.to_port\n                    g['ipPermissions'] += [dict(r)]\n                else:\n                    for protocol, min_port, max_port in (('icmp', -1, -1),\n                                                         ('tcp', 1, 65535),\n                                                         ('udp', 1, 65535)):\n                        r['ipProtocol'] = protocol\n                        r['fromPort'] = min_port\n                        r['toPort'] = max_port\n                        g['ipPermissions'] += [dict(r)]\n            else:\n                r['ipProtocol'] = rule.protocol\n                r['fromPort'] = rule.from_port\n                r['toPort'] = rule.to_port\n                r['ipRanges'] += [{'cidrIp': rule.cidr}]\n                g['ipPermissions'] += [r]\n        return g\n\n    def _rule_args_to_dict(self, context, kwargs):\n        rules = []\n        if not 'groups' in kwargs and not 'ip_ranges' in kwargs:\n            rule = self._rule_dict_last_step(context, **kwargs)\n            if rule:\n                rules.append(rule)\n            return rules\n        if 'ip_ranges' in kwargs:\n            rules = self._cidr_args_split(kwargs)\n        else:\n            rules = [kwargs]\n        finalset = []\n        for rule in rules:\n            if 'groups' in rule:\n                groups_values = self._groups_args_split(rule)\n                for groups_value in groups_values:\n                    final = self._rule_dict_last_step(context, **groups_value)\n                    finalset.append(final)\n            else:\n                final = self._rule_dict_last_step(context, **rule)\n                finalset.append(final)\n        return finalset\n\n    def _cidr_args_split(self, kwargs):\n        cidr_args_split = []\n        cidrs = kwargs['ip_ranges']\n        for key, cidr in cidrs.iteritems():\n            mykwargs = kwargs.copy()\n            del mykwargs['ip_ranges']\n            mykwargs['cidr_ip'] = cidr['cidr_ip']\n            cidr_args_split.append(mykwargs)\n        return cidr_args_split\n\n    def _groups_args_split(self, kwargs):\n        groups_args_split = []\n        groups = kwargs['groups']\n        for key, group in groups.iteritems():\n            mykwargs = kwargs.copy()\n            del mykwargs['groups']\n            if 'group_name' in group:\n                mykwargs['source_security_group_name'] = group['group_name']\n            if 'user_id' in group:\n                mykwargs['source_security_group_owner_id'] = group['user_id']\n            if 'group_id' in group:\n                mykwargs['source_security_group_id'] = group['group_id']\n            groups_args_split.append(mykwargs)\n        return groups_args_split\n\n    def _rule_dict_last_step(self, context, to_port=None, from_port=None,\n                                  ip_protocol=None, cidr_ip=None, user_id=None,\n                                  source_security_group_name=None,\n                                  source_security_group_owner_id=None):\n\n        values = {}\n\n        if source_security_group_name:\n            source_project_id = self._get_source_project_id(context,\n                source_security_group_owner_id)\n\n            source_security_group = db.security_group_get_by_name(\n                    context.elevated(),\n                    source_project_id,\n                    source_security_group_name)\n            notfound = exception.SecurityGroupNotFound\n            if not source_security_group:\n                raise notfound(security_group_id=source_security_group_name)\n            values['group_id'] = source_security_group['id']\n        elif cidr_ip:\n            # If this fails, it throws an exception. This is what we want.\n            cidr_ip = urllib.unquote(cidr_ip).decode()\n\n            if not utils.is_valid_cidr(cidr_ip):\n                # Raise exception for non-valid address\n                raise exception.EC2APIError(_(\"Invalid CIDR\"))\n\n            values['cidr'] = cidr_ip\n        else:\n            values['cidr'] = '0.0.0.0/0'\n\n        if source_security_group_name:\n            # Open everything if an explicit port range or type/code are not\n            # specified, but only if a source group was specified.\n            ip_proto_upper = ip_protocol.upper() if ip_protocol else ''\n            if (ip_proto_upper == 'ICMP' and\n                from_port is None and to_port is None):\n                from_port = -1\n                to_port = -1\n            elif (ip_proto_upper in ['TCP', 'UDP'] and from_port is None\n                  and to_port is None):\n                from_port = 1\n                to_port = 65535\n\n        if ip_protocol and from_port is not None and to_port is not None:\n\n            ip_protocol = str(ip_protocol)\n            try:\n                # Verify integer conversions\n                from_port = int(from_port)\n                to_port = int(to_port)\n            except ValueError:\n                if ip_protocol.upper() == 'ICMP':\n                    raise exception.InvalidInput(reason=\"Type and\"\n                         \" Code must be integers for ICMP protocol type\")\n                else:\n                    raise exception.InvalidInput(reason=\"To and From ports \"\n                          \"must be integers\")\n\n            if ip_protocol.upper() not in ['TCP', 'UDP', 'ICMP']:\n                raise exception.InvalidIpProtocol(protocol=ip_protocol)\n\n            # Verify that from_port must always be less than\n            # or equal to to_port\n            if (ip_protocol.upper() in ['TCP', 'UDP'] and\n                (from_port > to_port)):\n                raise exception.InvalidPortRange(from_port=from_port,\n                      to_port=to_port, msg=\"Former value cannot\"\n                                            \" be greater than the later\")\n\n            # Verify valid TCP, UDP port ranges\n            if (ip_protocol.upper() in ['TCP', 'UDP'] and\n                (from_port < 1 or to_port > 65535)):\n                raise exception.InvalidPortRange(from_port=from_port,\n                      to_port=to_port, msg=\"Valid TCP ports should\"\n                                           \" be between 1-65535\")\n\n            # Verify ICMP type and code\n            if (ip_protocol.upper() == \"ICMP\" and\n                (from_port < -1 or from_port > 255 or\n                to_port < -1 or to_port > 255)):\n                raise exception.InvalidPortRange(from_port=from_port,\n                      to_port=to_port, msg=\"For ICMP, the\"\n                                           \" type:code must be valid\")\n\n            values['protocol'] = ip_protocol\n            values['from_port'] = from_port\n            values['to_port'] = to_port\n        else:\n            # If cidr based filtering, protocol and ports are mandatory\n            if 'cidr' in values:\n                return None\n\n        return values\n\n    def _security_group_rule_exists(self, security_group, values):\n        \"\"\"Indicates whether the specified rule values are already\n           defined in the given security group.\n        \"\"\"\n        for rule in security_group.rules:\n            is_duplicate = True\n            keys = ('group_id', 'cidr', 'from_port', 'to_port', 'protocol')\n            for key in keys:\n                if rule.get(key) != values.get(key):\n                    is_duplicate = False\n                    break\n            if is_duplicate:\n                return rule['id']\n        return False\n\n    def revoke_security_group_ingress(self, context, group_name=None,\n                                      group_id=None, **kwargs):\n        if not group_name and not group_id:\n            err = _(\"Not enough parameters, need group_name or group_id\")\n            raise exception.EC2APIError(err)\n        self.compute_api.ensure_default_security_group(context)\n        notfound = exception.SecurityGroupNotFound\n        if group_name:\n            security_group = db.security_group_get_by_name(context,\n                                                           context.project_id,\n                                                           group_name)\n            if not security_group:\n                raise notfound(security_group_id=group_name)\n        if group_id:\n            security_group = db.security_group_get(context, group_id)\n            if not security_group:\n                raise notfound(security_group_id=group_id)\n\n        msg = _(\"Revoke security group ingress %s\")\n        LOG.audit(msg, security_group['name'], context=context)\n        prevalues = []\n        try:\n            prevalues = kwargs['ip_permissions']\n        except KeyError:\n            prevalues.append(kwargs)\n        rule_id = None\n        rule_ids = []\n        for values in prevalues:\n            rulesvalues = self._rule_args_to_dict(context, values)\n            if not rulesvalues:\n                err = _(\"%s Not enough parameters to build a valid rule\")\n                raise exception.EC2APIError(err % rulesvalues)\n\n            for values_for_rule in rulesvalues:\n                values_for_rule['parent_group_id'] = security_group.id\n                rule_id = self._security_group_rule_exists(security_group,\n                                                           values_for_rule)\n                if rule_id:\n                    db.security_group_rule_destroy(context, rule_id)\n                    rule_ids.append(rule_id)\n        if rule_id:\n            # NOTE(vish): we removed a rule, so refresh\n            self.compute_api.trigger_security_group_rules_refresh(\n                    context,\n                    security_group_id=security_group['id'])\n            self.sgh.trigger_security_group_rule_destroy_refresh(\n                    context, rule_ids)\n            return True\n        raise exception.EC2APIError(_(\"No rule for the specified parameters.\"))\n\n    # TODO(soren): This has only been tested with Boto as the client.\n    #              Unfortunately, it seems Boto is using an old API\n    #              for these operations, so support for newer API versions\n    #              is sketchy.\n    def authorize_security_group_ingress(self, context, group_name=None,\n                                         group_id=None, **kwargs):\n        if not group_name and not group_id:\n            err = _(\"Not enough parameters, need group_name or group_id\")\n            raise exception.EC2APIError(err)\n        self.compute_api.ensure_default_security_group(context)\n        notfound = exception.SecurityGroupNotFound\n        if group_name:\n            security_group = db.security_group_get_by_name(context,\n                                                           context.project_id,\n                                                           group_name)\n            if not security_group:\n                raise notfound(security_group_id=group_name)\n        if group_id:\n            security_group = db.security_group_get(context, group_id)\n            if not security_group:\n                raise notfound(security_group_id=group_id)\n\n        msg = _(\"Authorize security group ingress %s\")\n        LOG.audit(msg, security_group['name'], context=context)\n        prevalues = []\n        try:\n            prevalues = kwargs['ip_permissions']\n        except KeyError:\n            prevalues.append(kwargs)\n        postvalues = []\n        for values in prevalues:\n            rulesvalues = self._rule_args_to_dict(context, values)\n            if not rulesvalues:\n                err = _(\"%s Not enough parameters to build a valid rule\")\n                raise exception.EC2APIError(err % rulesvalues)\n            for values_for_rule in rulesvalues:\n                values_for_rule['parent_group_id'] = security_group.id\n                if self._security_group_rule_exists(security_group,\n                                                    values_for_rule):\n                    err = _('%s - This rule already exists in group')\n                    raise exception.EC2APIError(err % values_for_rule)\n                postvalues.append(values_for_rule)\n\n        allowed = quota.allowed_security_group_rules(context,\n                                                   security_group['id'],\n                                                   1)\n        if allowed < 1:\n            msg = _(\"Quota exceeded, too many security group rules.\")\n            raise exception.EC2APIError(msg)\n\n        rule_ids = []\n        for values_for_rule in postvalues:\n            security_group_rule = db.security_group_rule_create(\n                    context,\n                    values_for_rule)\n            rule_ids.append(security_group_rule['id'])\n\n        if postvalues:\n            self.compute_api.trigger_security_group_rules_refresh(\n                    context,\n                    security_group_id=security_group['id'])\n            self.sgh.trigger_security_group_rule_create_refresh(\n                    context, rule_ids)\n            return True\n\n        raise exception.EC2APIError(_(\"No rule for the specified parameters.\"))\n\n    def _get_source_project_id(self, context, source_security_group_owner_id):\n        if source_security_group_owner_id:\n        # Parse user:project for source group.\n            source_parts = source_security_group_owner_id.split(':')\n\n            # If no project name specified, assume it's same as user name.\n            # Since we're looking up by project name, the user name is not\n            # used here.  It's only read for EC2 API compatibility.\n            if len(source_parts) == 2:\n                source_project_id = source_parts[1]\n            else:\n                source_project_id = source_parts[0]\n        else:\n            source_project_id = context.project_id\n\n        return source_project_id\n\n    def create_security_group(self, context, group_name, group_description):\n        if not re.match('^[a-zA-Z0-9_\\- ]+$', str(group_name)):\n            # Some validation to ensure that values match API spec.\n            # - Alphanumeric characters, spaces, dashes, and underscores.\n            # TODO(Daviey): LP: #813685 extend beyond group_name checking, and\n            #  probably create a param validator that can be used elsewhere.\n            err = _(\"Value (%s) for parameter GroupName is invalid.\"\n                    \" Content limited to Alphanumeric characters, \"\n                    \"spaces, dashes, and underscores.\") % group_name\n            # err not that of master ec2 implementation, as they fail to raise.\n            raise exception.InvalidParameterValue(err=err)\n\n        if len(str(group_name)) > 255:\n            err = _(\"Value (%s) for parameter GroupName is invalid.\"\n                    \" Length exceeds maximum of 255.\") % group_name\n            raise exception.InvalidParameterValue(err=err)\n\n        LOG.audit(_(\"Create Security Group %s\"), group_name, context=context)\n        self.compute_api.ensure_default_security_group(context)\n        if db.security_group_exists(context, context.project_id, group_name):\n            msg = _('group %s already exists')\n            raise exception.EC2APIError(msg % group_name)\n\n        if quota.allowed_security_groups(context, 1) < 1:\n            msg = _(\"Quota exceeded, too many security groups.\")\n            raise exception.EC2APIError(msg)\n\n        group = {'user_id': context.user_id,\n                 'project_id': context.project_id,\n                 'name': group_name,\n                 'description': group_description}\n        group_ref = db.security_group_create(context, group)\n\n        self.sgh.trigger_security_group_create_refresh(context, group)\n\n        return {'securityGroupSet': [self._format_security_group(context,\n                                                                 group_ref)]}\n\n    def delete_security_group(self, context, group_name=None, group_id=None,\n                              **kwargs):\n        if not group_name and not group_id:\n            err = _(\"Not enough parameters, need group_name or group_id\")\n            raise exception.EC2APIError(err)\n        notfound = exception.SecurityGroupNotFound\n        if group_name:\n            security_group = db.security_group_get_by_name(context,\n                                                           context.project_id,\n                                                           group_name)\n            if not security_group:\n                raise notfound(security_group_id=group_name)\n        elif group_id:\n            security_group = db.security_group_get(context, group_id)\n            if not security_group:\n                raise notfound(security_group_id=group_id)\n        if db.security_group_in_use(context, security_group.id):\n            raise exception.InvalidGroup(reason=\"In Use\")\n        LOG.audit(_(\"Delete security group %s\"), group_name, context=context)\n        db.security_group_destroy(context, security_group.id)\n\n        self.sgh.trigger_security_group_destroy_refresh(context,\n                                                        security_group.id)\n        return True\n\n    def get_console_output(self, context, instance_id, **kwargs):\n        LOG.audit(_(\"Get console output for instance %s\"), instance_id,\n                  context=context)\n        # instance_id may be passed in as a list of instances\n        if isinstance(instance_id, list):\n            ec2_id = instance_id[0]\n        else:\n            ec2_id = instance_id\n        validate_ec2_id(ec2_id)\n        instance_id = ec2utils.ec2_id_to_id(ec2_id)\n        instance = self.compute_api.get(context, instance_id)\n        output = self.compute_api.get_console_output(context, instance)\n        now = utils.utcnow()\n        return {\"InstanceId\": ec2_id,\n                \"Timestamp\": now,\n                \"output\": base64.b64encode(output)}\n\n    def describe_volumes(self, context, volume_id=None, **kwargs):\n        if volume_id:\n            volumes = []\n            for ec2_id in volume_id:\n                validate_ec2_id(ec2_id)\n                internal_id = ec2utils.ec2_id_to_id(ec2_id)\n                volume = self.volume_api.get(context, internal_id)\n                volumes.append(volume)\n        else:\n            volumes = self.volume_api.get_all(context)\n        volumes = [self._format_volume(context, v) for v in volumes]\n        return {'volumeSet': volumes}\n\n    def _format_volume(self, context, volume):\n        instance_ec2_id = None\n        instance_data = None\n        if volume.get('instance', None):\n            instance_id = volume['instance']['id']\n            instance_ec2_id = ec2utils.id_to_ec2_id(instance_id)\n            instance_data = '%s[%s]' % (instance_ec2_id,\n                                        volume['instance']['host'])\n        v = {}\n        v['volumeId'] = ec2utils.id_to_ec2_vol_id(volume['id'])\n        v['status'] = volume['status']\n        v['size'] = volume['size']\n        v['availabilityZone'] = volume['availability_zone']\n        v['createTime'] = volume['created_at']\n        if context.is_admin:\n            v['status'] = '%s (%s, %s, %s, %s)' % (\n                volume['status'],\n                volume['project_id'],\n                volume['host'],\n                instance_data,\n                volume['mountpoint'])\n        if volume['attach_status'] == 'attached':\n            v['attachmentSet'] = [{'attachTime': volume['attach_time'],\n                                   'deleteOnTermination': False,\n                                   'device': volume['mountpoint'],\n                                   'instanceId': instance_ec2_id,\n                                   'status': 'attached',\n                                   'volumeId': v['volumeId']}]\n        else:\n            v['attachmentSet'] = [{}]\n        if volume.get('snapshot_id') is not None:\n            v['snapshotId'] = ec2utils.id_to_ec2_snap_id(volume['snapshot_id'])\n        else:\n            v['snapshotId'] = None\n\n        return v\n\n    def create_volume(self, context, **kwargs):\n        size = kwargs.get('size')\n        if kwargs.get('snapshot_id') is not None:\n            snapshot_id = ec2utils.ec2_id_to_id(kwargs['snapshot_id'])\n            snapshot = self.volume_api.get_snapshot(context, snapshot_id)\n            LOG.audit(_(\"Create volume from snapshot %s\"), snapshot_id,\n                      context=context)\n        else:\n            snapshot = None\n            LOG.audit(_(\"Create volume of %s GB\"), size, context=context)\n\n        availability_zone = kwargs.get('availability_zone', None)\n\n        volume = self.volume_api.create(context,\n                                        size,\n                                        None,\n                                        None,\n                                        snapshot,\n                                        availability_zone=availability_zone)\n        # TODO(vish): Instance should be None at db layer instead of\n        #             trying to lazy load, but for now we turn it into\n        #             a dict to avoid an error.\n        return self._format_volume(context, dict(volume))\n\n    def delete_volume(self, context, volume_id, **kwargs):\n        validate_ec2_id(volume_id)\n        volume_id = ec2utils.ec2_id_to_id(volume_id)\n\n        try:\n            volume = self.volume_api.get(context, volume_id)\n            self.volume_api.delete(context, volume)\n        except exception.InvalidVolume:\n            raise exception.EC2APIError(_('Delete Failed'))\n\n        return True\n\n    def attach_volume(self, context, volume_id, instance_id, device, **kwargs):\n        validate_ec2_id(instance_id)\n        validate_ec2_id(volume_id)\n        volume_id = ec2utils.ec2_id_to_id(volume_id)\n        instance_id = ec2utils.ec2_id_to_id(instance_id)\n        instance = self.compute_api.get(context, instance_id)\n        msg = _(\"Attach volume %(volume_id)s to instance %(instance_id)s\"\n                \" at %(device)s\") % locals()\n        LOG.audit(msg, context=context)\n\n        try:\n            self.compute_api.attach_volume(context, instance,\n                                           volume_id, device)\n        except exception.InvalidVolume:\n            raise exception.EC2APIError(_('Attach Failed.'))\n\n        volume = self.volume_api.get(context, volume_id)\n        return {'attachTime': volume['attach_time'],\n                'device': volume['mountpoint'],\n                'instanceId': ec2utils.id_to_ec2_id(instance_id),\n                'requestId': context.request_id,\n                'status': volume['attach_status'],\n                'volumeId': ec2utils.id_to_ec2_vol_id(volume_id)}\n\n    def detach_volume(self, context, volume_id, **kwargs):\n        validate_ec2_id(volume_id)\n        volume_id = ec2utils.ec2_id_to_id(volume_id)\n        LOG.audit(_(\"Detach volume %s\"), volume_id, context=context)\n        volume = self.volume_api.get(context, volume_id)\n\n        try:\n            instance = self.compute_api.detach_volume(context,\n                                                      volume_id=volume_id)\n        except exception.InvalidVolume:\n            raise exception.EC2APIError(_('Detach Volume Failed.'))\n\n        return {'attachTime': volume['attach_time'],\n                'device': volume['mountpoint'],\n                'instanceId': ec2utils.id_to_ec2_id(instance['id']),\n                'requestId': context.request_id,\n                'status': volume['attach_status'],\n                'volumeId': ec2utils.id_to_ec2_vol_id(volume_id)}\n\n    def _format_kernel_id(self, context, instance_ref, result, key):\n        kernel_uuid = instance_ref['kernel_id']\n        if kernel_uuid is None or kernel_uuid == '':\n            return\n        result[key] = ec2utils.glance_id_to_ec2_id(context, kernel_uuid, 'aki')\n\n    def _format_ramdisk_id(self, context, instance_ref, result, key):\n        ramdisk_uuid = instance_ref['ramdisk_id']\n        if ramdisk_uuid is None or ramdisk_uuid == '':\n            return\n        result[key] = ec2utils.glance_id_to_ec2_id(context, ramdisk_uuid,\n                                                   'ari')\n\n    def describe_instance_attribute(self, context, instance_id, attribute,\n                                    **kwargs):\n        def _unsupported_attribute(instance, result):\n            raise exception.EC2APIError(_('attribute not supported: %s') %\n                                     attribute)\n\n        def _format_attr_block_device_mapping(instance, result):\n            tmp = {}\n            self._format_instance_root_device_name(instance, tmp)\n            self._format_instance_bdm(context, instance_id,\n                                      tmp['rootDeviceName'], result)\n\n        def _format_attr_disable_api_termination(instance, result):\n            result['disableApiTermination'] = instance['disable_terminate']\n\n        def _format_attr_group_set(instance, result):\n            CloudController._format_group_set(instance, result)\n\n        def _format_attr_instance_initiated_shutdown_behavior(instance,\n                                                               result):\n            if instance['shutdown_terminate']:\n                result['instanceInitiatedShutdownBehavior'] = 'terminate'\n            else:\n                result['instanceInitiatedShutdownBehavior'] = 'stop'\n\n        def _format_attr_instance_type(instance, result):\n            self._format_instance_type(instance, result)\n\n        def _format_attr_kernel(instance, result):\n            self._format_kernel_id(context, instance, result, 'kernel')\n\n        def _format_attr_ramdisk(instance, result):\n            self._format_ramdisk_id(context, instance, result, 'ramdisk')\n\n        def _format_attr_root_device_name(instance, result):\n            self._format_instance_root_device_name(instance, result)\n\n        def _format_attr_source_dest_check(instance, result):\n            _unsupported_attribute(instance, result)\n\n        def _format_attr_user_data(instance, result):\n            result['userData'] = base64.b64decode(instance['user_data'])\n\n        attribute_formatter = {\n            'blockDeviceMapping': _format_attr_block_device_mapping,\n            'disableApiTermination': _format_attr_disable_api_termination,\n            'groupSet': _format_attr_group_set,\n            'instanceInitiatedShutdownBehavior':\n            _format_attr_instance_initiated_shutdown_behavior,\n            'instanceType': _format_attr_instance_type,\n            'kernel': _format_attr_kernel,\n            'ramdisk': _format_attr_ramdisk,\n            'rootDeviceName': _format_attr_root_device_name,\n            'sourceDestCheck': _format_attr_source_dest_check,\n            'userData': _format_attr_user_data,\n            }\n\n        fn = attribute_formatter.get(attribute)\n        if fn is None:\n            raise exception.EC2APIError(\n                _('attribute not supported: %s') % attribute)\n\n        ec2_instance_id = instance_id\n        validate_ec2_id(instance_id)\n        instance_id = ec2utils.ec2_id_to_id(ec2_instance_id)\n        instance = self.compute_api.get(context, instance_id)\n        result = {'instance_id': ec2_instance_id}\n        fn(instance, result)\n        return result\n\n    def describe_instances(self, context, **kwargs):\n        # Optional DescribeInstances argument\n        instance_id = kwargs.get('instance_id', None)\n        return self._format_describe_instances(context,\n                instance_id=instance_id)\n\n    def describe_instances_v6(self, context, **kwargs):\n        # Optional DescribeInstancesV6 argument\n        instance_id = kwargs.get('instance_id', None)\n        return self._format_describe_instances(context,\n                instance_id=instance_id, use_v6=True)\n\n    def _format_describe_instances(self, context, **kwargs):\n        return {'reservationSet': self._format_instances(context, **kwargs)}\n\n    def _format_run_instances(self, context, reservation_id):\n        i = self._format_instances(context, reservation_id=reservation_id)\n        assert len(i) == 1\n        return i[0]\n\n    def _format_terminate_instances(self, context, instance_id,\n                                    previous_states):\n        instances_set = []\n        for (ec2_id, previous_state) in zip(instance_id, previous_states):\n            i = {}\n            i['instanceId'] = ec2_id\n            i['previousState'] = _state_description(previous_state['vm_state'],\n                                        previous_state['shutdown_terminate'])\n            try:\n                internal_id = ec2utils.ec2_id_to_id(ec2_id)\n                instance = self.compute_api.get(context, internal_id)\n                i['shutdownState'] = _state_description(instance['vm_state'],\n                                            instance['shutdown_terminate'])\n            except exception.NotFound:\n                i['shutdownState'] = _state_description(vm_states.DELETED,\n                                                        True)\n            instances_set.append(i)\n        return {'instancesSet': instances_set}\n\n    def _format_instance_bdm(self, context, instance_id, root_device_name,\n                             result):\n        \"\"\"Format InstanceBlockDeviceMappingResponseItemType\"\"\"\n        root_device_type = 'instance-store'\n        mapping = []\n        for bdm in db.block_device_mapping_get_all_by_instance(context,\n                                                               instance_id):\n            volume_id = bdm['volume_id']\n            if (volume_id is None or bdm['no_device']):\n                continue\n\n            if (bdm['device_name'] == root_device_name and\n                (bdm['snapshot_id'] or bdm['volume_id'])):\n                assert not bdm['virtual_name']\n                root_device_type = 'ebs'\n\n            vol = self.volume_api.get(context, volume_id)\n            LOG.debug(_(\"vol = %s\\n\"), vol)\n            # TODO(yamahata): volume attach time\n            ebs = {'volumeId': volume_id,\n                   'deleteOnTermination': bdm['delete_on_termination'],\n                   'attachTime': vol['attach_time'] or '-',\n                   'status': vol['status'], }\n            res = {'deviceName': bdm['device_name'],\n                   'ebs': ebs, }\n            mapping.append(res)\n\n        if mapping:\n            result['blockDeviceMapping'] = mapping\n        result['rootDeviceType'] = root_device_type\n\n    @staticmethod\n    def _format_instance_root_device_name(instance, result):\n        result['rootDeviceName'] = (instance.get('root_device_name') or\n                                    block_device.DEFAULT_ROOT_DEV_NAME)\n\n    @staticmethod\n    def _format_instance_type(instance, result):\n        if instance['instance_type']:\n            result['instanceType'] = instance['instance_type'].get('name')\n        else:\n            result['instanceType'] = None\n\n    @staticmethod\n    def _format_group_set(instance, result):\n        security_group_names = []\n        if instance.get('security_groups'):\n            for security_group in instance['security_groups']:\n                security_group_names.append(security_group['name'])\n        result['groupSet'] = utils.convert_to_list_dict(\n            security_group_names, 'groupId')\n\n    def _format_instances(self, context, instance_id=None, use_v6=False,\n            **search_opts):\n        # TODO(termie): this method is poorly named as its name does not imply\n        #               that it will be making a variety of database calls\n        #               rather than simply formatting a bunch of instances that\n        #               were handed to it\n        reservations = {}\n        # NOTE(vish): instance_id is an optional list of ids to filter by\n        if instance_id:\n            instances = []\n            for ec2_id in instance_id:\n                internal_id = ec2utils.ec2_id_to_id(ec2_id)\n                try:\n                    instance = self.compute_api.get(context, internal_id)\n                except exception.NotFound:\n                    continue\n                instances.append(instance)\n        else:\n            try:\n                # always filter out deleted instances\n                search_opts['deleted'] = False\n                instances = self.compute_api.get_all(context,\n                                                     search_opts=search_opts,\n                                                     sort_dir='asc')\n            except exception.NotFound:\n                instances = []\n        for instance in instances:\n            if not context.is_admin:\n                if instance['image_ref'] == str(FLAGS.vpn_image_id):\n                    continue\n            i = {}\n            instance_id = instance['id']\n            ec2_id = ec2utils.id_to_ec2_id(instance_id)\n            i['instanceId'] = ec2_id\n            image_uuid = instance['image_ref']\n            i['imageId'] = ec2utils.glance_id_to_ec2_id(context, image_uuid)\n            self._format_kernel_id(context, instance, i, 'kernelId')\n            self._format_ramdisk_id(context, instance, i, 'ramdiskId')\n            i['instanceState'] = _state_description(\n                instance['vm_state'], instance['shutdown_terminate'])\n\n            fixed_ip = None\n            floating_ip = None\n            ip_info = ec2utils.get_ip_info_for_instance(context, instance)\n            if ip_info['fixed_ips']:\n                fixed_ip = ip_info['fixed_ips'][0]\n            if ip_info['floating_ips']:\n                floating_ip = ip_info['floating_ips'][0]\n            if ip_info['fixed_ip6s']:\n                i['dnsNameV6'] = ip_info['fixed_ip6s'][0]\n            if FLAGS.ec2_private_dns_show_ip:\n                i['privateDnsName'] = fixed_ip\n            else:\n                i['privateDnsName'] = instance['hostname']\n            i['privateIpAddress'] = fixed_ip\n            i['publicDnsName'] = floating_ip\n            i['ipAddress'] = floating_ip or fixed_ip\n            i['dnsName'] = i['publicDnsName'] or i['privateDnsName']\n            i['keyName'] = instance['key_name']\n\n            if context.is_admin:\n                i['keyName'] = '%s (%s, %s)' % (i['keyName'],\n                    instance['project_id'],\n                    instance['host'])\n            i['productCodesSet'] = utils.convert_to_list_dict([],\n                                                              'product_codes')\n            self._format_instance_type(instance, i)\n            i['launchTime'] = instance['created_at']\n            i['amiLaunchIndex'] = instance['launch_index']\n            self._format_instance_root_device_name(instance, i)\n            self._format_instance_bdm(context, instance_id,\n                                      i['rootDeviceName'], i)\n            host = instance['host']\n            services = db.service_get_all_by_host(context.elevated(), host)\n            zone = ec2utils.get_availability_zone_by_host(services, host)\n            i['placement'] = {'availabilityZone': zone}\n            if instance['reservation_id'] not in reservations:\n                r = {}\n                r['reservationId'] = instance['reservation_id']\n                r['ownerId'] = instance['project_id']\n                self._format_group_set(instance, r)\n                r['instancesSet'] = []\n                reservations[instance['reservation_id']] = r\n            reservations[instance['reservation_id']]['instancesSet'].append(i)\n\n        return list(reservations.values())\n\n    def describe_addresses(self, context, **kwargs):\n        return self.format_addresses(context)\n\n    def format_addresses(self, context):\n        addresses = []\n        floaters = self.network_api.get_floating_ips_by_project(context)\n        for floating_ip_ref in floaters:\n            if floating_ip_ref['project_id'] is None:\n                continue\n            address = floating_ip_ref['address']\n            ec2_id = None\n            if floating_ip_ref['fixed_ip_id']:\n                fixed_id = floating_ip_ref['fixed_ip_id']\n                fixed = self.network_api.get_fixed_ip(context, fixed_id)\n                if fixed['instance_id'] is not None:\n                    ec2_id = ec2utils.id_to_ec2_id(fixed['instance_id'])\n            address_rv = {'public_ip': address,\n                          'instance_id': ec2_id}\n            if context.is_admin:\n                details = \"%s (%s)\" % (address_rv['instance_id'],\n                                       floating_ip_ref['project_id'])\n                address_rv['instance_id'] = details\n            addresses.append(address_rv)\n        return {'addressesSet': addresses}\n\n    def allocate_address(self, context, **kwargs):\n        LOG.audit(_(\"Allocate address\"), context=context)\n        try:\n            public_ip = self.network_api.allocate_floating_ip(context)\n            return {'publicIp': public_ip}\n        except rpc_common.RemoteError as ex:\n            # NOTE(tr3buchet) - why does this block exist?\n            if ex.exc_type == 'NoMoreFloatingIps':\n                raise exception.NoMoreFloatingIps()\n            else:\n                raise\n\n    def release_address(self, context, public_ip, **kwargs):\n        LOG.audit(_(\"Release address %s\"), public_ip, context=context)\n        self.network_api.release_floating_ip(context, address=public_ip)\n        return {'return': \"true\"}\n\n    def associate_address(self, context, instance_id, public_ip, **kwargs):\n        LOG.audit(_(\"Associate address %(public_ip)s to\"\n                \" instance %(instance_id)s\") % locals(), context=context)\n        instance_id = ec2utils.ec2_id_to_id(instance_id)\n        instance = self.compute_api.get(context, instance_id)\n        self.compute_api.associate_floating_ip(context,\n                                               instance,\n                                               address=public_ip)\n        return {'return': \"true\"}\n\n    def disassociate_address(self, context, public_ip, **kwargs):\n        LOG.audit(_(\"Disassociate address %s\"), public_ip, context=context)\n        self.network_api.disassociate_floating_ip(context, address=public_ip)\n        return {'return': \"true\"}\n\n    def run_instances(self, context, **kwargs):\n        max_count = int(kwargs.get('max_count', 1))\n        if kwargs.get('kernel_id'):\n            kernel = self._get_image(context, kwargs['kernel_id'])\n            kwargs['kernel_id'] = ec2utils.id_to_glance_id(context,\n                                                           kernel['id'])\n        if kwargs.get('ramdisk_id'):\n            ramdisk = self._get_image(context, kwargs['ramdisk_id'])\n            kwargs['ramdisk_id'] = ec2utils.id_to_glance_id(context,\n                                                            ramdisk['id'])\n        for bdm in kwargs.get('block_device_mapping', []):\n            _parse_block_device_mapping(bdm)\n\n        image = self._get_image(context, kwargs['image_id'])\n        image_uuid = ec2utils.id_to_glance_id(context, image['id'])\n\n        if image:\n            image_state = self._get_image_state(image)\n        else:\n            raise exception.ImageNotFound(image_id=kwargs['image_id'])\n\n        if image_state != 'available':\n            raise exception.EC2APIError(_('Image must be available'))\n\n        (instances, resv_id) = self.compute_api.create(context,\n            instance_type=instance_types.get_instance_type_by_name(\n                kwargs.get('instance_type', None)),\n            image_href=image_uuid,\n            min_count=int(kwargs.get('min_count', max_count)),\n            max_count=max_count,\n            kernel_id=kwargs.get('kernel_id'),\n            ramdisk_id=kwargs.get('ramdisk_id'),\n            key_name=kwargs.get('key_name'),\n            user_data=kwargs.get('user_data'),\n            security_group=kwargs.get('security_group'),\n            availability_zone=kwargs.get('placement', {}).get(\n                                  'availability_zone'),\n            block_device_mapping=kwargs.get('block_device_mapping', {}))\n        return self._format_run_instances(context, resv_id)\n\n    def terminate_instances(self, context, instance_id, **kwargs):\n        \"\"\"Terminate each instance in instance_id, which is a list of ec2 ids.\n        instance_id is a kwarg so its name cannot be modified.\"\"\"\n        LOG.debug(_(\"Going to start terminating instances\"))\n        previous_states = []\n        for ec2_id in instance_id:\n            validate_ec2_id(ec2_id)\n            _instance_id = ec2utils.ec2_id_to_id(ec2_id)\n            instance = self.compute_api.get(context, _instance_id)\n            previous_states.append(instance)\n            self.compute_api.delete(context, instance)\n        return self._format_terminate_instances(context,\n                                                instance_id,\n                                                previous_states)\n\n    def reboot_instances(self, context, instance_id, **kwargs):\n        \"\"\"instance_id is a list of instance ids\"\"\"\n        LOG.audit(_(\"Reboot instance %r\"), instance_id, context=context)\n        for ec2_id in instance_id:\n            validate_ec2_id(ec2_id)\n            _instance_id = ec2utils.ec2_id_to_id(ec2_id)\n            instance = self.compute_api.get(context, _instance_id)\n            self.compute_api.reboot(context, instance, 'HARD')\n        return True\n\n    def stop_instances(self, context, instance_id, **kwargs):\n        \"\"\"Stop each instances in instance_id.\n        Here instance_id is a list of instance ids\"\"\"\n        LOG.debug(_(\"Going to stop instances\"))\n        for ec2_id in instance_id:\n            validate_ec2_id(ec2_id)\n            _instance_id = ec2utils.ec2_id_to_id(ec2_id)\n            instance = self.compute_api.get(context, _instance_id)\n            self.compute_api.stop(context, instance)\n        return True\n\n    def start_instances(self, context, instance_id, **kwargs):\n        \"\"\"Start each instances in instance_id.\n        Here instance_id is a list of instance ids\"\"\"\n        LOG.debug(_(\"Going to start instances\"))\n        for ec2_id in instance_id:\n            validate_ec2_id(ec2_id)\n            _instance_id = ec2utils.ec2_id_to_id(ec2_id)\n            instance = self.compute_api.get(context, _instance_id)\n            self.compute_api.start(context, instance)\n        return True\n\n    def _get_image(self, context, ec2_id):\n        try:\n            internal_id = ec2utils.ec2_id_to_id(ec2_id)\n            image = self.image_service.show(context, internal_id)\n        except (exception.InvalidEc2Id, exception.ImageNotFound):\n            try:\n                return self.image_service.show_by_name(context, ec2_id)\n            except exception.NotFound:\n                raise exception.ImageNotFound(image_id=ec2_id)\n        image_type = ec2_id.split('-')[0]\n        if ec2utils.image_type(image.get('container_format')) != image_type:\n            raise exception.ImageNotFound(image_id=ec2_id)\n        return image\n\n    def _format_image(self, image):\n        \"\"\"Convert from format defined by GlanceImageService to S3 format.\"\"\"\n        i = {}\n        image_type = ec2utils.image_type(image.get('container_format'))\n        ec2_id = ec2utils.image_ec2_id(image.get('id'), image_type)\n        name = image.get('name')\n        i['imageId'] = ec2_id\n        kernel_id = image['properties'].get('kernel_id')\n        if kernel_id:\n            i['kernelId'] = ec2utils.image_ec2_id(kernel_id, 'aki')\n        ramdisk_id = image['properties'].get('ramdisk_id')\n        if ramdisk_id:\n            i['ramdiskId'] = ec2utils.image_ec2_id(ramdisk_id, 'ari')\n\n        if FLAGS.auth_strategy == 'deprecated':\n            i['imageOwnerId'] = image['properties'].get('project_id')\n        else:\n            i['imageOwnerId'] = image.get('owner')\n\n        img_loc = image['properties'].get('image_location')\n        if img_loc:\n            i['imageLocation'] = img_loc\n        else:\n            i['imageLocation'] = \"%s (%s)\" % (img_loc, name)\n\n        i['name'] = name\n        if not name and img_loc:\n            # This should only occur for images registered with ec2 api\n            # prior to that api populating the glance name\n            i['name'] = img_loc\n\n        i['imageState'] = self._get_image_state(image)\n        i['description'] = image.get('description')\n        display_mapping = {'aki': 'kernel',\n                           'ari': 'ramdisk',\n                           'ami': 'machine'}\n        i['imageType'] = display_mapping.get(image_type)\n        i['isPublic'] = not not image.get('is_public')\n        i['architecture'] = image['properties'].get('architecture')\n\n        properties = image['properties']\n        root_device_name = block_device.properties_root_device_name(properties)\n        root_device_type = 'instance-store'\n        for bdm in properties.get('block_device_mapping', []):\n            if (bdm.get('device_name') == root_device_name and\n                ('snapshot_id' in bdm or 'volume_id' in bdm) and\n                not bdm.get('no_device')):\n                root_device_type = 'ebs'\n        i['rootDeviceName'] = (root_device_name or\n                               block_device.DEFAULT_ROOT_DEV_NAME)\n        i['rootDeviceType'] = root_device_type\n\n        _format_mappings(properties, i)\n\n        return i\n\n    def describe_images(self, context, image_id=None, **kwargs):\n        # NOTE: image_id is a list!\n        if image_id:\n            images = []\n            for ec2_id in image_id:\n                try:\n                    image = self._get_image(context, ec2_id)\n                except exception.NotFound:\n                    raise exception.ImageNotFound(image_id=ec2_id)\n                images.append(image)\n        else:\n            images = self.image_service.detail(context)\n        images = [self._format_image(i) for i in images]\n        return {'imagesSet': images}\n\n    def deregister_image(self, context, image_id, **kwargs):\n        LOG.audit(_(\"De-registering image %s\"), image_id, context=context)\n        image = self._get_image(context, image_id)\n        internal_id = image['id']\n        self.image_service.delete(context, internal_id)\n        return {'imageId': image_id}\n\n    def _register_image(self, context, metadata):\n        image = self.image_service.create(context, metadata)\n        image_type = ec2utils.image_type(image.get('container_format'))\n        image_id = ec2utils.image_ec2_id(image['id'], image_type)\n        return image_id\n\n    def register_image(self, context, image_location=None, **kwargs):\n        if image_location is None and kwargs.get('name'):\n            image_location = kwargs['name']\n        if image_location is None:\n            raise exception.EC2APIError(_('imageLocation is required'))\n\n        metadata = {'properties': {'image_location': image_location}}\n\n        if kwargs.get('name'):\n            metadata['name'] = kwargs['name']\n        else:\n            metadata['name'] = image_location\n\n        if 'root_device_name' in kwargs:\n            metadata['properties']['root_device_name'] = kwargs.get(\n                                                         'root_device_name')\n\n        mappings = [_parse_block_device_mapping(bdm) for bdm in\n                    kwargs.get('block_device_mapping', [])]\n        if mappings:\n            metadata['properties']['block_device_mapping'] = mappings\n\n        image_id = self._register_image(context, metadata)\n        msg = _(\"Registered image %(image_location)s with\"\n                \" id %(image_id)s\") % locals()\n        LOG.audit(msg, context=context)\n        return {'imageId': image_id}\n\n    def describe_image_attribute(self, context, image_id, attribute, **kwargs):\n        def _block_device_mapping_attribute(image, result):\n            _format_mappings(image['properties'], result)\n\n        def _launch_permission_attribute(image, result):\n            result['launchPermission'] = []\n            if image['is_public']:\n                result['launchPermission'].append({'group': 'all'})\n\n        def _root_device_name_attribute(image, result):\n            _prop_root_dev_name = block_device.properties_root_device_name\n            result['rootDeviceName'] = _prop_root_dev_name(image['properties'])\n            if result['rootDeviceName'] is None:\n                result['rootDeviceName'] = block_device.DEFAULT_ROOT_DEV_NAME\n\n        supported_attributes = {\n            'blockDeviceMapping': _block_device_mapping_attribute,\n            'launchPermission': _launch_permission_attribute,\n            'rootDeviceName': _root_device_name_attribute,\n            }\n\n        fn = supported_attributes.get(attribute)\n        if fn is None:\n            raise exception.EC2APIError(_('attribute not supported: %s')\n                                     % attribute)\n        try:\n            image = self._get_image(context, image_id)\n        except exception.NotFound:\n            raise exception.ImageNotFound(image_id=image_id)\n\n        result = {'imageId': image_id}\n        fn(image, result)\n        return result\n\n    def modify_image_attribute(self, context, image_id, attribute,\n                               operation_type, **kwargs):\n        # TODO(devcamcar): Support users and groups other than 'all'.\n        if attribute != 'launchPermission':\n            raise exception.EC2APIError(_('attribute not supported: %s')\n                                     % attribute)\n        if not 'user_group' in kwargs:\n            raise exception.EC2APIError(_('user or group not specified'))\n        if len(kwargs['user_group']) != 1 and kwargs['user_group'][0] != 'all':\n            raise exception.EC2APIError(_('only group \"all\" is supported'))\n        if not operation_type in ['add', 'remove']:\n            msg = _('operation_type must be add or remove')\n            raise exception.EC2APIError(msg)\n        LOG.audit(_(\"Updating image %s publicity\"), image_id, context=context)\n\n        try:\n            image = self._get_image(context, image_id)\n        except exception.NotFound:\n            raise exception.ImageNotFound(image_id=image_id)\n        internal_id = image['id']\n        del(image['id'])\n\n        image['is_public'] = (operation_type == 'add')\n        try:\n            return self.image_service.update(context, internal_id, image)\n        except exception.ImageNotAuthorized:\n            msg = _('Not allowed to modify attributes for image %s')\n            raise exception.EC2APIError(msg % image_id)\n\n    def update_image(self, context, image_id, **kwargs):\n        internal_id = ec2utils.ec2_id_to_id(image_id)\n        result = self.image_service.update(context, internal_id, dict(kwargs))\n        return result\n\n    # TODO(yamahata): race condition\n    # At the moment there is no way to prevent others from\n    # manipulating instances/volumes/snapshots.\n    # As other code doesn't take it into consideration, here we don't\n    # care of it for now. Ostrich algorithm\n    def create_image(self, context, instance_id, **kwargs):\n        # NOTE(yamahata): name/description are ignored by register_image(),\n        #                 do so here\n        no_reboot = kwargs.get('no_reboot', False)\n        validate_ec2_id(instance_id)\n        ec2_instance_id = instance_id\n        instance_id = ec2utils.ec2_id_to_id(ec2_instance_id)\n        instance = self.compute_api.get(context, instance_id)\n\n        # stop the instance if necessary\n        restart_instance = False\n        if not no_reboot:\n            vm_state = instance['vm_state']\n\n            # if the instance is in subtle state, refuse to proceed.\n            if vm_state not in (vm_states.ACTIVE, vm_states.SHUTOFF,\n                                vm_states.STOPPED):\n                raise exception.InstanceNotRunning(instance_id=ec2_instance_id)\n\n            if vm_state in (vm_states.ACTIVE, vm_states.SHUTOFF):\n                restart_instance = True\n                self.compute_api.stop(context, instance)\n\n            # wait instance for really stopped\n            start_time = time.time()\n            while vm_state != vm_states.STOPPED:\n                time.sleep(1)\n                instance = self.compute_api.get(context, instance_id)\n                vm_state = instance['vm_state']\n                # NOTE(yamahata): timeout and error. 1 hour for now for safety.\n                #                 Is it too short/long?\n                #                 Or is there any better way?\n                timeout = 1 * 60 * 60\n                if time.time() > start_time + timeout:\n                    raise exception.EC2APIError(\n                        _('Couldn\\'t stop instance with in %d sec') % timeout)\n\n        src_image = self._get_image(context, instance['image_ref'])\n        properties = src_image['properties']\n        if instance['root_device_name']:\n            properties['root_device_name'] = instance['root_device_name']\n\n        mapping = []\n        bdms = db.block_device_mapping_get_all_by_instance(context,\n                                                           instance_id)\n        for bdm in bdms:\n            if bdm.no_device:\n                continue\n            m = {}\n            for attr in ('device_name', 'snapshot_id', 'volume_id',\n                         'volume_size', 'delete_on_termination', 'no_device',\n                         'virtual_name'):\n                val = getattr(bdm, attr)\n                if val is not None:\n                    m[attr] = val\n\n            volume_id = m.get('volume_id')\n            if m.get('snapshot_id') and volume_id:\n                # create snapshot based on volume_id\n                volume = self.volume_api.get(context, volume_id)\n                # NOTE(yamahata): Should we wait for snapshot creation?\n                #                 Linux LVM snapshot creation completes in\n                #                 short time, it doesn't matter for now.\n                snapshot = self.volume_api.create_snapshot_force(\n                        context, volume, volume['display_name'],\n                        volume['display_description'])\n                m['snapshot_id'] = snapshot['id']\n                del m['volume_id']\n\n            if m:\n                mapping.append(m)\n\n        for m in _properties_get_mappings(properties):\n            virtual_name = m['virtual']\n            if virtual_name in ('ami', 'root'):\n                continue\n\n            assert block_device.is_swap_or_ephemeral(virtual_name)\n            device_name = m['device']\n            if device_name in [b['device_name'] for b in mapping\n                               if not b.get('no_device', False)]:\n                continue\n\n            # NOTE(yamahata): swap and ephemeral devices are specified in\n            #                 AMI, but disabled for this instance by user.\n            #                 So disable those device by no_device.\n            mapping.append({'device_name': device_name, 'no_device': True})\n\n        if mapping:\n            properties['block_device_mapping'] = mapping\n\n        for attr in ('status', 'location', 'id'):\n            src_image.pop(attr, None)\n\n        image_id = self._register_image(context, src_image)\n\n        if restart_instance:\n            self.compute_api.start(context, instance_id=instance_id)\n\n        return {'imageId': image_id}\n", "# Copyright 2011 OpenStack LLC.\n# Copyright 2012 Justin Santa Barbara\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"The security groups extension.\"\"\"\n\nimport urllib\nfrom xml.dom import minidom\n\nfrom webob import exc\nimport webob\n\nfrom nova.api.openstack import common\nfrom nova.api.openstack import extensions\nfrom nova.api.openstack import wsgi\nfrom nova.api.openstack import xmlutil\nfrom nova import compute\nfrom nova import db\nfrom nova import exception\nfrom nova import flags\nfrom nova import log as logging\nfrom nova import quota\nfrom nova import utils\n\n\nLOG = logging.getLogger(__name__)\nFLAGS = flags.FLAGS\nauthorize = extensions.extension_authorizer('compute', 'security_groups')\n\n\ndef make_rule(elem):\n    elem.set('id')\n    elem.set('parent_group_id')\n\n    proto = xmlutil.SubTemplateElement(elem, 'ip_protocol')\n    proto.text = 'ip_protocol'\n\n    from_port = xmlutil.SubTemplateElement(elem, 'from_port')\n    from_port.text = 'from_port'\n\n    to_port = xmlutil.SubTemplateElement(elem, 'to_port')\n    to_port.text = 'to_port'\n\n    group = xmlutil.SubTemplateElement(elem, 'group', selector='group')\n    name = xmlutil.SubTemplateElement(group, 'name')\n    name.text = 'name'\n    tenant_id = xmlutil.SubTemplateElement(group, 'tenant_id')\n    tenant_id.text = 'tenant_id'\n\n    ip_range = xmlutil.SubTemplateElement(elem, 'ip_range',\n                                          selector='ip_range')\n    cidr = xmlutil.SubTemplateElement(ip_range, 'cidr')\n    cidr.text = 'cidr'\n\n\ndef make_sg(elem):\n    elem.set('id')\n    elem.set('tenant_id')\n    elem.set('name')\n\n    desc = xmlutil.SubTemplateElement(elem, 'description')\n    desc.text = 'description'\n\n    rules = xmlutil.SubTemplateElement(elem, 'rules')\n    rule = xmlutil.SubTemplateElement(rules, 'rule', selector='rules')\n    make_rule(rule)\n\n\nsg_nsmap = {None: wsgi.XMLNS_V11}\n\n\nclass SecurityGroupRuleTemplate(xmlutil.TemplateBuilder):\n    def construct(self):\n        root = xmlutil.TemplateElement('security_group_rule',\n                                       selector='security_group_rule')\n        make_rule(root)\n        return xmlutil.MasterTemplate(root, 1, nsmap=sg_nsmap)\n\n\nclass SecurityGroupTemplate(xmlutil.TemplateBuilder):\n    def construct(self):\n        root = xmlutil.TemplateElement('security_group',\n                                       selector='security_group')\n        make_sg(root)\n        return xmlutil.MasterTemplate(root, 1, nsmap=sg_nsmap)\n\n\nclass SecurityGroupsTemplate(xmlutil.TemplateBuilder):\n    def construct(self):\n        root = xmlutil.TemplateElement('security_groups')\n        elem = xmlutil.SubTemplateElement(root, 'security_group',\n                                          selector='security_groups')\n        make_sg(elem)\n        return xmlutil.MasterTemplate(root, 1, nsmap=sg_nsmap)\n\n\nclass SecurityGroupXMLDeserializer(wsgi.MetadataXMLDeserializer):\n    \"\"\"\n    Deserializer to handle xml-formatted security group requests.\n    \"\"\"\n    def default(self, string):\n        \"\"\"Deserialize an xml-formatted security group create request\"\"\"\n        dom = minidom.parseString(string)\n        security_group = {}\n        sg_node = self.find_first_child_named(dom,\n                                               'security_group')\n        if sg_node is not None:\n            if sg_node.hasAttribute('name'):\n                security_group['name'] = sg_node.getAttribute('name')\n            desc_node = self.find_first_child_named(sg_node,\n                                                     \"description\")\n            if desc_node:\n                security_group['description'] = self.extract_text(desc_node)\n        return {'body': {'security_group': security_group}}\n\n\nclass SecurityGroupRulesXMLDeserializer(wsgi.MetadataXMLDeserializer):\n    \"\"\"\n    Deserializer to handle xml-formatted security group requests.\n    \"\"\"\n\n    def default(self, string):\n        \"\"\"Deserialize an xml-formatted security group create request\"\"\"\n        dom = minidom.parseString(string)\n        security_group_rule = self._extract_security_group_rule(dom)\n        return {'body': {'security_group_rule': security_group_rule}}\n\n    def _extract_security_group_rule(self, node):\n        \"\"\"Marshal the security group rule attribute of a parsed request\"\"\"\n        sg_rule = {}\n        sg_rule_node = self.find_first_child_named(node,\n                                                   'security_group_rule')\n        if sg_rule_node is not None:\n            ip_protocol_node = self.find_first_child_named(sg_rule_node,\n                                                           \"ip_protocol\")\n            if ip_protocol_node is not None:\n                sg_rule['ip_protocol'] = self.extract_text(ip_protocol_node)\n\n            from_port_node = self.find_first_child_named(sg_rule_node,\n                                                         \"from_port\")\n            if from_port_node is not None:\n                sg_rule['from_port'] = self.extract_text(from_port_node)\n\n            to_port_node = self.find_first_child_named(sg_rule_node, \"to_port\")\n            if to_port_node is not None:\n                sg_rule['to_port'] = self.extract_text(to_port_node)\n\n            parent_group_id_node = self.find_first_child_named(sg_rule_node,\n                                                            \"parent_group_id\")\n            if parent_group_id_node is not None:\n                sg_rule['parent_group_id'] = self.extract_text(\n                                                         parent_group_id_node)\n\n            group_id_node = self.find_first_child_named(sg_rule_node,\n                                                        \"group_id\")\n            if group_id_node is not None:\n                sg_rule['group_id'] = self.extract_text(group_id_node)\n\n            cidr_node = self.find_first_child_named(sg_rule_node, \"cidr\")\n            if cidr_node is not None:\n                sg_rule['cidr'] = self.extract_text(cidr_node)\n\n        return sg_rule\n\n\nclass SecurityGroupControllerBase(object):\n    \"\"\"Base class for Security Group controllers.\"\"\"\n\n    def __init__(self):\n        self.compute_api = compute.API()\n        self.sgh = utils.import_object(FLAGS.security_group_handler)\n\n    def _format_security_group_rule(self, context, rule):\n        sg_rule = {}\n        sg_rule['id'] = rule.id\n        sg_rule['parent_group_id'] = rule.parent_group_id\n        sg_rule['ip_protocol'] = rule.protocol\n        sg_rule['from_port'] = rule.from_port\n        sg_rule['to_port'] = rule.to_port\n        sg_rule['group'] = {}\n        sg_rule['ip_range'] = {}\n        if rule.group_id:\n            source_group = db.security_group_get(context, rule.group_id)\n            sg_rule['group'] = {'name': source_group.name,\n                             'tenant_id': source_group.project_id}\n        else:\n            sg_rule['ip_range'] = {'cidr': rule.cidr}\n        return sg_rule\n\n    def _format_security_group(self, context, group):\n        security_group = {}\n        security_group['id'] = group.id\n        security_group['description'] = group.description\n        security_group['name'] = group.name\n        security_group['tenant_id'] = group.project_id\n        security_group['rules'] = []\n        for rule in group.rules:\n            security_group['rules'] += [self._format_security_group_rule(\n                    context, rule)]\n        return security_group\n\n\nclass SecurityGroupController(SecurityGroupControllerBase):\n    \"\"\"The Security group API controller for the OpenStack API.\"\"\"\n\n    def _get_security_group(self, context, id):\n        try:\n            id = int(id)\n            security_group = db.security_group_get(context, id)\n        except ValueError:\n            msg = _(\"Security group id should be integer\")\n            raise exc.HTTPBadRequest(explanation=msg)\n        except exception.NotFound as exp:\n            raise exc.HTTPNotFound(explanation=unicode(exp))\n        return security_group\n\n    @wsgi.serializers(xml=SecurityGroupTemplate)\n    def show(self, req, id):\n        \"\"\"Return data about the given security group.\"\"\"\n        context = req.environ['nova.context']\n        authorize(context)\n        security_group = self._get_security_group(context, id)\n        return {'security_group': self._format_security_group(context,\n                                                              security_group)}\n\n    def delete(self, req, id):\n        \"\"\"Delete a security group.\"\"\"\n        context = req.environ['nova.context']\n        authorize(context)\n        security_group = self._get_security_group(context, id)\n        if db.security_group_in_use(context, security_group.id):\n            msg = _(\"Security group is still in use\")\n            raise exc.HTTPBadRequest(explanation=msg)\n        LOG.audit(_(\"Delete security group %s\"), id, context=context)\n        db.security_group_destroy(context, security_group.id)\n        self.sgh.trigger_security_group_destroy_refresh(\n            context, security_group.id)\n\n        return webob.Response(status_int=202)\n\n    @wsgi.serializers(xml=SecurityGroupsTemplate)\n    def index(self, req):\n        \"\"\"Returns a list of security groups\"\"\"\n        context = req.environ['nova.context']\n        authorize(context)\n\n        self.compute_api.ensure_default_security_group(context)\n        groups = db.security_group_get_by_project(context,\n                                                  context.project_id)\n        limited_list = common.limited(groups, req)\n        result = [self._format_security_group(context, group)\n                     for group in limited_list]\n\n        return {'security_groups':\n                list(sorted(result,\n                            key=lambda k: (k['tenant_id'], k['name'])))}\n\n    @wsgi.serializers(xml=SecurityGroupTemplate)\n    @wsgi.deserializers(xml=SecurityGroupXMLDeserializer)\n    def create(self, req, body):\n        \"\"\"Creates a new security group.\"\"\"\n        context = req.environ['nova.context']\n        authorize(context)\n        if not body:\n            raise exc.HTTPUnprocessableEntity()\n\n        security_group = body.get('security_group', None)\n\n        if security_group is None:\n            raise exc.HTTPUnprocessableEntity()\n\n        group_name = security_group.get('name', None)\n        group_description = security_group.get('description', None)\n\n        self._validate_security_group_property(group_name, \"name\")\n        self._validate_security_group_property(group_description,\n                                               \"description\")\n        group_name = group_name.strip()\n        group_description = group_description.strip()\n\n        if quota.allowed_security_groups(context, 1) < 1:\n            msg = _(\"Quota exceeded, too many security groups.\")\n            raise exc.HTTPBadRequest(explanation=msg)\n\n        LOG.audit(_(\"Create Security Group %s\"), group_name, context=context)\n        self.compute_api.ensure_default_security_group(context)\n        if db.security_group_exists(context, context.project_id, group_name):\n            msg = _('Security group %s already exists') % group_name\n            raise exc.HTTPBadRequest(explanation=msg)\n\n        group = {'user_id': context.user_id,\n                 'project_id': context.project_id,\n                 'name': group_name,\n                 'description': group_description}\n        group_ref = db.security_group_create(context, group)\n        self.sgh.trigger_security_group_create_refresh(context, group)\n\n        return {'security_group': self._format_security_group(context,\n                                                                 group_ref)}\n\n    def _validate_security_group_property(self, value, typ):\n        \"\"\" typ will be either 'name' or 'description',\n            depending on the caller\n        \"\"\"\n        try:\n            val = value.strip()\n        except AttributeError:\n            msg = _(\"Security group %s is not a string or unicode\") % typ\n            raise exc.HTTPBadRequest(explanation=msg)\n        if not val:\n            msg = _(\"Security group %s cannot be empty.\") % typ\n            raise exc.HTTPBadRequest(explanation=msg)\n        if len(val) > 255:\n            msg = _(\"Security group %s should not be greater \"\n                            \"than 255 characters.\") % typ\n            raise exc.HTTPBadRequest(explanation=msg)\n\n\nclass SecurityGroupRulesController(SecurityGroupControllerBase):\n\n    @wsgi.serializers(xml=SecurityGroupRuleTemplate)\n    @wsgi.deserializers(xml=SecurityGroupRulesXMLDeserializer)\n    def create(self, req, body):\n        context = req.environ['nova.context']\n        authorize(context)\n\n        if not body:\n            raise exc.HTTPUnprocessableEntity()\n\n        if not 'security_group_rule' in body:\n            raise exc.HTTPUnprocessableEntity()\n\n        self.compute_api.ensure_default_security_group(context)\n\n        sg_rule = body['security_group_rule']\n        parent_group_id = sg_rule.get('parent_group_id', None)\n        try:\n            parent_group_id = int(parent_group_id)\n            security_group = db.security_group_get(context, parent_group_id)\n        except ValueError:\n            msg = _(\"Parent group id is not integer\")\n            raise exc.HTTPBadRequest(explanation=msg)\n        except exception.NotFound as exp:\n            msg = _(\"Security group (%s) not found\") % parent_group_id\n            raise exc.HTTPNotFound(explanation=msg)\n\n        msg = _(\"Authorize security group ingress %s\")\n        LOG.audit(msg, security_group['name'], context=context)\n\n        try:\n            values = self._rule_args_to_dict(context,\n                              to_port=sg_rule.get('to_port'),\n                              from_port=sg_rule.get('from_port'),\n                              parent_group_id=sg_rule.get('parent_group_id'),\n                              ip_protocol=sg_rule.get('ip_protocol'),\n                              cidr=sg_rule.get('cidr'),\n                              group_id=sg_rule.get('group_id'))\n        except Exception as exp:\n            raise exc.HTTPBadRequest(explanation=unicode(exp))\n\n        if values is None:\n            msg = _(\"Not enough parameters to build a \"\n                                       \"valid rule.\")\n            raise exc.HTTPBadRequest(explanation=msg)\n\n        values['parent_group_id'] = security_group.id\n\n        if self._security_group_rule_exists(security_group, values):\n            msg = _('This rule already exists in group %s') % parent_group_id\n            raise exc.HTTPBadRequest(explanation=msg)\n\n        allowed = quota.allowed_security_group_rules(context,\n                                                   parent_group_id,\n                                                   1)\n        if allowed < 1:\n            msg = _(\"Quota exceeded, too many security group rules.\")\n            raise exc.HTTPBadRequest(explanation=msg)\n\n        security_group_rule = db.security_group_rule_create(context, values)\n        self.sgh.trigger_security_group_rule_create_refresh(\n            context, [security_group_rule['id']])\n        self.compute_api.trigger_security_group_rules_refresh(context,\n                                    security_group_id=security_group['id'])\n\n        return {\"security_group_rule\": self._format_security_group_rule(\n                                                        context,\n                                                        security_group_rule)}\n\n    def _security_group_rule_exists(self, security_group, values):\n        \"\"\"Indicates whether the specified rule values are already\n           defined in the given security group.\n        \"\"\"\n        for rule in security_group.rules:\n            is_duplicate = True\n            keys = ('group_id', 'cidr', 'from_port', 'to_port', 'protocol')\n            for key in keys:\n                if rule.get(key) != values.get(key):\n                    is_duplicate = False\n                    break\n            if is_duplicate:\n                return True\n        return False\n\n    def _rule_args_to_dict(self, context, to_port=None, from_port=None,\n                                  parent_group_id=None, ip_protocol=None,\n                                  cidr=None, group_id=None):\n        values = {}\n\n        if group_id is not None:\n            try:\n                parent_group_id = int(parent_group_id)\n                group_id = int(group_id)\n            except ValueError:\n                msg = _(\"Parent or group id is not integer\")\n                raise exception.InvalidInput(reason=msg)\n\n            values['group_id'] = group_id\n            #check if groupId exists\n            db.security_group_get(context, group_id)\n        elif cidr:\n            # If this fails, it throws an exception. This is what we want.\n            try:\n                cidr = urllib.unquote(cidr).decode()\n            except Exception:\n                raise exception.InvalidCidr(cidr=cidr)\n\n            if not utils.is_valid_cidr(cidr):\n                # Raise exception for non-valid address\n                raise exception.InvalidCidr(cidr=cidr)\n\n            values['cidr'] = cidr\n        else:\n            values['cidr'] = '0.0.0.0/0'\n\n        if group_id:\n            # Open everything if an explicit port range or type/code are not\n            # specified, but only if a source group was specified.\n            ip_proto_upper = ip_protocol.upper() if ip_protocol else ''\n            if (ip_proto_upper == 'ICMP' and\n                from_port is None and to_port is None):\n                from_port = -1\n                to_port = -1\n            elif (ip_proto_upper in ['TCP', 'UDP'] and from_port is None\n                  and to_port is None):\n                from_port = 1\n                to_port = 65535\n\n        if ip_protocol and from_port is not None and to_port is not None:\n\n            ip_protocol = str(ip_protocol)\n            try:\n                from_port = int(from_port)\n                to_port = int(to_port)\n            except ValueError:\n                if ip_protocol.upper() == 'ICMP':\n                    raise exception.InvalidInput(reason=\"Type and\"\n                         \" Code must be integers for ICMP protocol type\")\n                else:\n                    raise exception.InvalidInput(reason=\"To and From ports \"\n                          \"must be integers\")\n\n            if ip_protocol.upper() not in ['TCP', 'UDP', 'ICMP']:\n                raise exception.InvalidIpProtocol(protocol=ip_protocol)\n\n            # Verify that from_port must always be less than\n            # or equal to to_port\n            if (ip_protocol.upper() in ['TCP', 'UDP'] and\n                from_port > to_port):\n                raise exception.InvalidPortRange(from_port=from_port,\n                      to_port=to_port, msg=\"Former value cannot\"\n                                            \" be greater than the later\")\n\n            # Verify valid TCP, UDP port ranges\n            if (ip_protocol.upper() in ['TCP', 'UDP'] and\n                (from_port < 1 or to_port > 65535)):\n                raise exception.InvalidPortRange(from_port=from_port,\n                      to_port=to_port, msg=\"Valid TCP ports should\"\n                                           \" be between 1-65535\")\n\n            # Verify ICMP type and code\n            if (ip_protocol.upper() == \"ICMP\" and\n                (from_port < -1 or from_port > 255 or\n                to_port < -1 or to_port > 255)):\n                raise exception.InvalidPortRange(from_port=from_port,\n                      to_port=to_port, msg=\"For ICMP, the\"\n                                           \" type:code must be valid\")\n\n            values['protocol'] = ip_protocol\n            values['from_port'] = from_port\n            values['to_port'] = to_port\n        else:\n            # If cidr based filtering, protocol and ports are mandatory\n            if 'cidr' in values:\n                return None\n\n        return values\n\n    def delete(self, req, id):\n        context = req.environ['nova.context']\n        authorize(context)\n\n        self.compute_api.ensure_default_security_group(context)\n        try:\n            id = int(id)\n            rule = db.security_group_rule_get(context, id)\n        except ValueError:\n            msg = _(\"Rule id is not integer\")\n            raise exc.HTTPBadRequest(explanation=msg)\n        except exception.NotFound:\n            msg = _(\"Rule (%s) not found\") % id\n            raise exc.HTTPNotFound(explanation=msg)\n\n        group_id = rule.parent_group_id\n        self.compute_api.ensure_default_security_group(context)\n        security_group = db.security_group_get(context, group_id)\n\n        msg = _(\"Revoke security group ingress %s\")\n        LOG.audit(msg, security_group['name'], context=context)\n\n        db.security_group_rule_destroy(context, rule['id'])\n        self.sgh.trigger_security_group_rule_destroy_refresh(\n            context, [rule['id']])\n        self.compute_api.trigger_security_group_rules_refresh(context,\n                                    security_group_id=security_group['id'])\n\n        return webob.Response(status_int=202)\n\n\nclass ServerSecurityGroupController(SecurityGroupControllerBase):\n\n    @wsgi.serializers(xml=SecurityGroupsTemplate)\n    def index(self, req, server_id):\n        \"\"\"Returns a list of security groups for the given instance.\"\"\"\n        context = req.environ['nova.context']\n        authorize(context)\n\n        self.compute_api.ensure_default_security_group(context)\n\n        try:\n            instance = self.compute_api.get(context, server_id)\n            groups = db.security_group_get_by_instance(context,\n                                                       instance['id'])\n        except exception.ApiError, e:\n            raise webob.exc.HTTPBadRequest(explanation=e.message)\n        except exception.NotAuthorized, e:\n            raise webob.exc.HTTPUnauthorized()\n\n        result = [self._format_security_group(context, group)\n                    for group in groups]\n\n        return {'security_groups':\n                list(sorted(result,\n                            key=lambda k: (k['tenant_id'], k['name'])))}\n\n\nclass SecurityGroupActionController(wsgi.Controller):\n    def __init__(self, *args, **kwargs):\n        super(SecurityGroupActionController, self).__init__(*args, **kwargs)\n        self.compute_api = compute.API()\n        self.sgh = utils.import_object(FLAGS.security_group_handler)\n\n    @wsgi.action('addSecurityGroup')\n    def _addSecurityGroup(self, req, id, body):\n        context = req.environ['nova.context']\n        authorize(context)\n\n        try:\n            body = body['addSecurityGroup']\n            group_name = body['name']\n        except TypeError:\n            msg = _(\"Missing parameter dict\")\n            raise webob.exc.HTTPBadRequest(explanation=msg)\n        except KeyError:\n            msg = _(\"Security group not specified\")\n            raise webob.exc.HTTPBadRequest(explanation=msg)\n\n        if not group_name or group_name.strip() == '':\n            msg = _(\"Security group name cannot be empty\")\n            raise webob.exc.HTTPBadRequest(explanation=msg)\n\n        try:\n            instance = self.compute_api.get(context, id)\n            self.compute_api.add_security_group(context, instance, group_name)\n            self.sgh.trigger_instance_add_security_group_refresh(\n                context, instance, group_name)\n        except exception.SecurityGroupNotFound as exp:\n            raise exc.HTTPNotFound(explanation=unicode(exp))\n        except exception.InstanceNotFound as exp:\n            raise exc.HTTPNotFound(explanation=unicode(exp))\n        except exception.Invalid as exp:\n            raise exc.HTTPBadRequest(explanation=unicode(exp))\n\n        return webob.Response(status_int=202)\n\n    @wsgi.action('removeSecurityGroup')\n    def _removeSecurityGroup(self, req, id, body):\n        context = req.environ['nova.context']\n        authorize(context)\n\n        try:\n            body = body['removeSecurityGroup']\n            group_name = body['name']\n        except TypeError:\n            msg = _(\"Missing parameter dict\")\n            raise webob.exc.HTTPBadRequest(explanation=msg)\n        except KeyError:\n            msg = _(\"Security group not specified\")\n            raise webob.exc.HTTPBadRequest(explanation=msg)\n\n        if not group_name or group_name.strip() == '':\n            msg = _(\"Security group name cannot be empty\")\n            raise webob.exc.HTTPBadRequest(explanation=msg)\n\n        try:\n            instance = self.compute_api.get(context, id)\n            self.compute_api.remove_security_group(context, instance,\n                                                   group_name)\n            self.sgh.trigger_instance_remove_security_group_refresh(\n                context, instance, group_name)\n        except exception.SecurityGroupNotFound as exp:\n            raise exc.HTTPNotFound(explanation=unicode(exp))\n        except exception.InstanceNotFound as exp:\n            raise exc.HTTPNotFound(explanation=unicode(exp))\n        except exception.Invalid as exp:\n            raise exc.HTTPBadRequest(explanation=unicode(exp))\n\n        return webob.Response(status_int=202)\n\n\nclass Security_groups(extensions.ExtensionDescriptor):\n    \"\"\"Security group support\"\"\"\n\n    name = \"SecurityGroups\"\n    alias = \"security_groups\"\n    namespace = \"http://docs.openstack.org/compute/ext/securitygroups/api/v1.1\"\n    updated = \"2011-07-21T00:00:00+00:00\"\n\n    def get_controller_extensions(self):\n        controller = SecurityGroupActionController()\n        extension = extensions.ControllerExtension(self, 'servers', controller)\n        return [extension]\n\n    def get_resources(self):\n        resources = []\n\n        res = extensions.ResourceExtension('os-security-groups',\n                                controller=SecurityGroupController())\n\n        resources.append(res)\n\n        res = extensions.ResourceExtension('os-security-group-rules',\n                                controller=SecurityGroupRulesController())\n        resources.append(res)\n\n        res = extensions.ResourceExtension(\n            'os-security-groups',\n            controller=ServerSecurityGroupController(),\n            parent=dict(member_name='server', collection_name='servers'))\n        resources.append(res)\n\n        return resources\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2011 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n# Copyright (c) 2011 Citrix Systems, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nfrom nova import context\nfrom nova import db\nfrom nova import flags\nfrom nova import log as logging\nfrom nova.openstack.common import cfg\nfrom nova import utils\nfrom nova.virt import netutils\n\n\nLOG = logging.getLogger(__name__)\n\nallow_same_net_traffic_opt = cfg.BoolOpt('allow_same_net_traffic',\n        default=True,\n        help='Whether to allow network traffic from same network')\n\nFLAGS = flags.FLAGS\nFLAGS.register_opt(allow_same_net_traffic_opt)\n\n\nclass FirewallDriver(object):\n    \"\"\" Firewall Driver base class.\n\n        Defines methods that any driver providing security groups\n        and provider fireall functionality should implement.\n    \"\"\"\n    def prepare_instance_filter(self, instance, network_info):\n        \"\"\"Prepare filters for the instance.\n        At this point, the instance isn't running yet.\"\"\"\n        raise NotImplementedError()\n\n    def unfilter_instance(self, instance, network_info):\n        \"\"\"Stop filtering instance\"\"\"\n        raise NotImplementedError()\n\n    def apply_instance_filter(self, instance, network_info):\n        \"\"\"Apply instance filter.\n\n        Once this method returns, the instance should be firewalled\n        appropriately. This method should as far as possible be a\n        no-op. It's vastly preferred to get everything set up in\n        prepare_instance_filter.\n        \"\"\"\n        raise NotImplementedError()\n\n    def refresh_security_group_rules(self, security_group_id):\n        \"\"\"Refresh security group rules from data store\n\n        Gets called when a rule has been added to or removed from\n        the security group.\"\"\"\n        raise NotImplementedError()\n\n    def refresh_security_group_members(self, security_group_id):\n        \"\"\"Refresh security group members from data store\n\n        Gets called when an instance gets added to or removed from\n        the security group.\"\"\"\n        raise NotImplementedError()\n\n    def refresh_provider_fw_rules(self):\n        \"\"\"Refresh common rules for all hosts/instances from data store.\n\n        Gets called when a rule has been added to or removed from\n        the list of rules (via admin api).\n\n        \"\"\"\n        raise NotImplementedError()\n\n    def setup_basic_filtering(self, instance, network_info):\n        \"\"\"Create rules to block spoofing and allow dhcp.\n\n        This gets called when spawning an instance, before\n        :py:meth:`prepare_instance_filter`.\n\n        \"\"\"\n        raise NotImplementedError()\n\n    def instance_filter_exists(self, instance, network_info):\n        \"\"\"Check nova-instance-instance-xxx exists\"\"\"\n        raise NotImplementedError()\n\n\nclass IptablesFirewallDriver(FirewallDriver):\n    \"\"\"Driver which enforces security groups through iptables rules.\"\"\"\n\n    def __init__(self, **kwargs):\n        from nova.network import linux_net\n        self.iptables = linux_net.iptables_manager\n        self.instances = {}\n        self.network_infos = {}\n        self.basicly_filtered = False\n\n        self.iptables.ipv4['filter'].add_chain('sg-fallback')\n        self.iptables.ipv4['filter'].add_rule('sg-fallback', '-j DROP')\n        self.iptables.ipv6['filter'].add_chain('sg-fallback')\n        self.iptables.ipv6['filter'].add_rule('sg-fallback', '-j DROP')\n\n    def setup_basic_filtering(self, instance, network_info):\n        pass\n\n    def apply_instance_filter(self, instance, network_info):\n        \"\"\"No-op. Everything is done in prepare_instance_filter.\"\"\"\n        pass\n\n    def unfilter_instance(self, instance, network_info):\n        if self.instances.pop(instance['id'], None):\n            # NOTE(vish): use the passed info instead of the stored info\n            self.network_infos.pop(instance['id'])\n            self.remove_filters_for_instance(instance)\n            self.iptables.apply()\n        else:\n            LOG.info(_('Attempted to unfilter instance %s which is not '\n                     'filtered'), instance['id'])\n\n    def prepare_instance_filter(self, instance, network_info):\n        self.instances[instance['id']] = instance\n        self.network_infos[instance['id']] = network_info\n        self.add_filters_for_instance(instance)\n        LOG.debug(_('Filters added to instance %s'), instance['uuid'])\n        self.refresh_provider_fw_rules()\n        LOG.debug(_('Provider Firewall Rules refreshed'))\n        self.iptables.apply()\n\n    def _create_filter(self, ips, chain_name):\n        return ['-d %s -j $%s' % (ip, chain_name) for ip in ips]\n\n    def _filters_for_instance(self, chain_name, network_info):\n        \"\"\"Creates a rule corresponding to each ip that defines a\n             jump to the corresponding instance - chain for all the traffic\n             destined to that ip.\"\"\"\n        ips_v4 = [ip['ip'] for (_n, mapping) in network_info\n                 for ip in mapping['ips']]\n        ipv4_rules = self._create_filter(ips_v4, chain_name)\n\n        ipv6_rules = []\n        if FLAGS.use_ipv6:\n            ips_v6 = [ip['ip'] for (_n, mapping) in network_info\n                     for ip in mapping['ip6s']]\n            ipv6_rules = self._create_filter(ips_v6, chain_name)\n\n        return ipv4_rules, ipv6_rules\n\n    def _add_filters(self, chain_name, ipv4_rules, ipv6_rules):\n        for rule in ipv4_rules:\n            self.iptables.ipv4['filter'].add_rule(chain_name, rule)\n\n        if FLAGS.use_ipv6:\n            for rule in ipv6_rules:\n                self.iptables.ipv6['filter'].add_rule(chain_name, rule)\n\n    def add_filters_for_instance(self, instance):\n        network_info = self.network_infos[instance['id']]\n        chain_name = self._instance_chain_name(instance)\n        if FLAGS.use_ipv6:\n            self.iptables.ipv6['filter'].add_chain(chain_name)\n        self.iptables.ipv4['filter'].add_chain(chain_name)\n        ipv4_rules, ipv6_rules = self._filters_for_instance(chain_name,\n                                                            network_info)\n        self._add_filters('local', ipv4_rules, ipv6_rules)\n        ipv4_rules, ipv6_rules = self.instance_rules(instance, network_info)\n        self._add_filters(chain_name, ipv4_rules, ipv6_rules)\n\n    def remove_filters_for_instance(self, instance):\n        chain_name = self._instance_chain_name(instance)\n\n        self.iptables.ipv4['filter'].remove_chain(chain_name)\n        if FLAGS.use_ipv6:\n            self.iptables.ipv6['filter'].remove_chain(chain_name)\n\n    @staticmethod\n    def _security_group_chain_name(security_group_id):\n        return 'nova-sg-%s' % (security_group_id,)\n\n    def _instance_chain_name(self, instance):\n        return 'inst-%s' % (instance['id'],)\n\n    def _do_basic_rules(self, ipv4_rules, ipv6_rules, network_info):\n        # Always drop invalid packets\n        ipv4_rules += ['-m state --state ' 'INVALID -j DROP']\n        ipv6_rules += ['-m state --state ' 'INVALID -j DROP']\n\n        # Allow established connections\n        ipv4_rules += ['-m state --state ESTABLISHED,RELATED -j ACCEPT']\n        ipv6_rules += ['-m state --state ESTABLISHED,RELATED -j ACCEPT']\n\n        # Pass through provider-wide drops\n        ipv4_rules += ['-j $provider']\n        ipv6_rules += ['-j $provider']\n\n    def _do_dhcp_rules(self, ipv4_rules, network_info):\n        dhcp_servers = [info['dhcp_server'] for (_n, info) in network_info]\n\n        for dhcp_server in dhcp_servers:\n            ipv4_rules.append('-s %s -p udp --sport 67 --dport 68 '\n                              '-j ACCEPT' % (dhcp_server,))\n\n    def _do_project_network_rules(self, ipv4_rules, ipv6_rules, network_info):\n        cidrs = [network['cidr'] for (network, _i) in network_info]\n        for cidr in cidrs:\n            ipv4_rules.append('-s %s -j ACCEPT' % (cidr,))\n        if FLAGS.use_ipv6:\n            cidrv6s = [network['cidr_v6'] for (network, _i) in\n                       network_info]\n\n            for cidrv6 in cidrv6s:\n                ipv6_rules.append('-s %s -j ACCEPT' % (cidrv6,))\n\n    def _do_ra_rules(self, ipv6_rules, network_info):\n        gateways_v6 = [mapping['gateway_v6'] for (_n, mapping) in\n                       network_info]\n        for gateway_v6 in gateways_v6:\n            ipv6_rules.append(\n                    '-s %s/128 -p icmpv6 -j ACCEPT' % (gateway_v6,))\n\n    def _build_icmp_rule(self, rule, version):\n        icmp_type = rule.from_port\n        icmp_code = rule.to_port\n\n        if icmp_type == -1:\n            icmp_type_arg = None\n        else:\n            icmp_type_arg = '%s' % icmp_type\n            if not icmp_code == -1:\n                icmp_type_arg += '/%s' % icmp_code\n\n        if icmp_type_arg:\n            if version == 4:\n                return ['-m', 'icmp', '--icmp-type', icmp_type_arg]\n            elif version == 6:\n                return ['-m', 'icmp6', '--icmpv6-type', icmp_type_arg]\n        # return empty list if icmp_type == -1\n        return []\n\n    def _build_tcp_udp_rule(self, rule, version):\n        if rule.from_port == rule.to_port:\n            return ['--dport', '%s' % (rule.from_port,)]\n        else:\n            return ['-m', 'multiport',\n                    '--dports', '%s:%s' % (rule.from_port,\n                                           rule.to_port)]\n\n    def instance_rules(self, instance, network_info):\n        ctxt = context.get_admin_context()\n\n        ipv4_rules = []\n        ipv6_rules = []\n\n        # Initialize with basic rules\n        self._do_basic_rules(ipv4_rules, ipv6_rules, network_info)\n        # Set up rules to allow traffic to/from DHCP server\n        self._do_dhcp_rules(ipv4_rules, network_info)\n\n        #Allow project network traffic\n        if FLAGS.allow_same_net_traffic:\n            self._do_project_network_rules(ipv4_rules, ipv6_rules,\n                                           network_info)\n        # We wrap these in FLAGS.use_ipv6 because they might cause\n        # a DB lookup. The other ones are just list operations, so\n        # they're not worth the clutter.\n        if FLAGS.use_ipv6:\n            # Allow RA responses\n            self._do_ra_rules(ipv6_rules, network_info)\n\n        security_groups = db.security_group_get_by_instance(ctxt,\n                                                            instance['id'])\n\n        # then, security group chains and rules\n        for security_group in security_groups:\n            rules = db.security_group_rule_get_by_security_group(ctxt,\n                                                          security_group['id'])\n\n            for rule in rules:\n                LOG.debug(_('Adding security group rule: %r'), rule)\n\n                if not rule.cidr:\n                    version = 4\n                else:\n                    version = netutils.get_ip_version(rule.cidr)\n\n                if version == 4:\n                    fw_rules = ipv4_rules\n                else:\n                    fw_rules = ipv6_rules\n\n                protocol = rule.protocol\n                if version == 6 and rule.protocol == 'icmp':\n                    protocol = 'icmpv6'\n\n                args = ['-j ACCEPT']\n                if protocol:\n                    args += ['-p', protocol]\n\n                if protocol in ['udp', 'tcp']:\n                    args += self._build_tcp_udp_rule(rule, version)\n                elif protocol == 'icmp':\n                    args += self._build_icmp_rule(rule, version)\n                if rule.cidr:\n                    LOG.info('Using cidr %r', rule.cidr)\n                    args += ['-s', rule.cidr]\n                    fw_rules += [' '.join(args)]\n                else:\n                    if rule['grantee_group']:\n                        # FIXME(jkoelker) This needs to be ported up into\n                        #                 the compute manager which already\n                        #                 has access to a nw_api handle,\n                        #                 and should be the only one making\n                        #                 making rpc calls.\n                        import nova.network\n                        nw_api = nova.network.API()\n                        for instance in rule['grantee_group']['instances']:\n                            LOG.info('instance: %r', instance)\n                            nw_info = nw_api.get_instance_nw_info(ctxt,\n                                                                  instance)\n\n                            ips = [ip['address']\n                                for ip in nw_info.fixed_ips()\n                                    if ip['version'] == version]\n\n                            LOG.info('ips: %r', ips)\n                            for ip in ips:\n                                subrule = args + ['-s %s' % ip]\n                                fw_rules += [' '.join(subrule)]\n\n                LOG.info('Using fw_rules: %r', fw_rules)\n        ipv4_rules += ['-j $sg-fallback']\n        ipv6_rules += ['-j $sg-fallback']\n\n        return ipv4_rules, ipv6_rules\n\n    def instance_filter_exists(self, instance, network_info):\n        pass\n\n    def refresh_security_group_members(self, security_group):\n        self.do_refresh_security_group_rules(security_group)\n        self.iptables.apply()\n\n    def refresh_security_group_rules(self, security_group):\n        self.do_refresh_security_group_rules(security_group)\n        self.iptables.apply()\n\n    @utils.synchronized('iptables', external=True)\n    def do_refresh_security_group_rules(self, security_group):\n        for instance in self.instances.values():\n            self.remove_filters_for_instance(instance)\n            self.add_filters_for_instance(instance)\n\n    def refresh_provider_fw_rules(self):\n        \"\"\"See :class:`FirewallDriver` docs.\"\"\"\n        self._do_refresh_provider_fw_rules()\n        self.iptables.apply()\n\n    @utils.synchronized('iptables', external=True)\n    def _do_refresh_provider_fw_rules(self):\n        \"\"\"Internal, synchronized version of refresh_provider_fw_rules.\"\"\"\n        self._purge_provider_fw_rules()\n        self._build_provider_fw_rules()\n\n    def _purge_provider_fw_rules(self):\n        \"\"\"Remove all rules from the provider chains.\"\"\"\n        self.iptables.ipv4['filter'].empty_chain('provider')\n        if FLAGS.use_ipv6:\n            self.iptables.ipv6['filter'].empty_chain('provider')\n\n    def _build_provider_fw_rules(self):\n        \"\"\"Create all rules for the provider IP DROPs.\"\"\"\n        self.iptables.ipv4['filter'].add_chain('provider')\n        if FLAGS.use_ipv6:\n            self.iptables.ipv6['filter'].add_chain('provider')\n        ipv4_rules, ipv6_rules = self._provider_rules()\n        for rule in ipv4_rules:\n            self.iptables.ipv4['filter'].add_rule('provider', rule)\n\n        if FLAGS.use_ipv6:\n            for rule in ipv6_rules:\n                self.iptables.ipv6['filter'].add_rule('provider', rule)\n\n    @staticmethod\n    def _provider_rules():\n        \"\"\"Generate a list of rules from provider for IP4 & IP6.\"\"\"\n        ctxt = context.get_admin_context()\n        ipv4_rules = []\n        ipv6_rules = []\n        rules = db.provider_fw_rule_get_all(ctxt)\n        for rule in rules:\n            LOG.debug(_('Adding provider rule: %s'), rule['cidr'])\n            version = netutils.get_ip_version(rule['cidr'])\n            if version == 4:\n                fw_rules = ipv4_rules\n            else:\n                fw_rules = ipv6_rules\n\n            protocol = rule['protocol']\n            if version == 6 and protocol == 'icmp':\n                protocol = 'icmpv6'\n\n            args = ['-p', protocol, '-s', rule['cidr']]\n\n            if protocol in ['udp', 'tcp']:\n                if rule['from_port'] == rule['to_port']:\n                    args += ['--dport', '%s' % (rule['from_port'],)]\n                else:\n                    args += ['-m', 'multiport',\n                             '--dports', '%s:%s' % (rule['from_port'],\n                                                    rule['to_port'])]\n            elif protocol == 'icmp':\n                icmp_type = rule['from_port']\n                icmp_code = rule['to_port']\n\n                if icmp_type == -1:\n                    icmp_type_arg = None\n                else:\n                    icmp_type_arg = '%s' % icmp_type\n                    if not icmp_code == -1:\n                        icmp_type_arg += '/%s' % icmp_code\n\n                if icmp_type_arg:\n                    if version == 4:\n                        args += ['-m', 'icmp', '--icmp-type',\n                                 icmp_type_arg]\n                    elif version == 6:\n                        args += ['-m', 'icmp6', '--icmpv6-type',\n                                 icmp_type_arg]\n            args += ['-j DROP']\n            fw_rules += [' '.join(args)]\n        return ipv4_rules, ipv6_rules\n\n\nclass NoopFirewallDriver(object):\n    \"\"\"Firewall driver which just provides No-op methods.\"\"\"\n    def __init__(*args, **kwargs):\n        pass\n\n    def _noop(*args, **kwargs):\n        pass\n\n    def __getattr__(self, key):\n        return self._noop\n\n    def instance_filter_exists(self, instance, network_info):\n        return True\n"], "fixing_code": ["# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2010 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nCloud Controller: Implementation of EC2 REST API calls, which are\ndispatched to other nodes via AMQP RPC. State is via distributed\ndatastore.\n\"\"\"\n\nimport base64\nimport re\nimport time\nimport urllib\n\nfrom nova.api.ec2 import ec2utils\nfrom nova.api.ec2 import inst_state\nfrom nova.api import validator\nfrom nova import block_device\nfrom nova import compute\nfrom nova.compute import instance_types\nfrom nova.compute import vm_states\nfrom nova import crypto\nfrom nova import db\nfrom nova import exception\nfrom nova import flags\nfrom nova.image import s3\nfrom nova import log as logging\nfrom nova import network\nfrom nova.rpc import common as rpc_common\nfrom nova import quota\nfrom nova import utils\nfrom nova import volume\n\n\nFLAGS = flags.FLAGS\nflags.DECLARE('dhcp_domain', 'nova.network.manager')\n\nLOG = logging.getLogger(__name__)\n\n\ndef validate_ec2_id(val):\n    if not validator.validate_str()(val):\n        raise exception.InvalidInstanceIDMalformed(val)\n    try:\n        ec2utils.ec2_id_to_id(val)\n    except exception.InvalidEc2Id:\n        raise exception.InvalidInstanceIDMalformed(val)\n\n\ndef _gen_key(context, user_id, key_name):\n    \"\"\"Generate a key\n\n    This is a module level method because it is slow and we need to defer\n    it into a process pool.\"\"\"\n    # NOTE(vish): generating key pair is slow so check for legal\n    #             creation before creating key_pair\n    try:\n        db.key_pair_get(context, user_id, key_name)\n        raise exception.KeyPairExists(key_name=key_name)\n    except exception.NotFound:\n        pass\n    private_key, public_key, fingerprint = crypto.generate_key_pair()\n    key = {}\n    key['user_id'] = user_id\n    key['name'] = key_name\n    key['public_key'] = public_key\n    key['fingerprint'] = fingerprint\n    db.key_pair_create(context, key)\n    return {'private_key': private_key, 'fingerprint': fingerprint}\n\n\n# EC2 API can return the following values as documented in the EC2 API\n# http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/\n#    ApiReference-ItemType-InstanceStateType.html\n# pending 0 | running 16 | shutting-down 32 | terminated 48 | stopping 64 |\n# stopped 80\n_STATE_DESCRIPTION_MAP = {\n    None: inst_state.PENDING,\n    vm_states.ACTIVE: inst_state.RUNNING,\n    vm_states.BUILDING: inst_state.PENDING,\n    vm_states.REBUILDING: inst_state.PENDING,\n    vm_states.DELETED: inst_state.TERMINATED,\n    vm_states.SOFT_DELETE: inst_state.TERMINATED,\n    vm_states.STOPPED: inst_state.STOPPED,\n    vm_states.SHUTOFF: inst_state.SHUTOFF,\n    vm_states.MIGRATING: inst_state.MIGRATE,\n    vm_states.RESIZING: inst_state.RESIZE,\n    vm_states.PAUSED: inst_state.PAUSE,\n    vm_states.SUSPENDED: inst_state.SUSPEND,\n    vm_states.RESCUED: inst_state.RESCUE,\n}\n\n\ndef _state_description(vm_state, shutdown_terminate):\n    \"\"\"Map the vm state to the server status string\"\"\"\n    if (vm_state == vm_states.SHUTOFF and\n        not shutdown_terminate):\n            name = inst_state.STOPPED\n    else:\n        name = _STATE_DESCRIPTION_MAP.get(vm_state, vm_state)\n\n    return {'code': inst_state.name_to_code(name),\n            'name': name}\n\n\ndef _parse_block_device_mapping(bdm):\n    \"\"\"Parse BlockDeviceMappingItemType into flat hash\n    BlockDevicedMapping.<N>.DeviceName\n    BlockDevicedMapping.<N>.Ebs.SnapshotId\n    BlockDevicedMapping.<N>.Ebs.VolumeSize\n    BlockDevicedMapping.<N>.Ebs.DeleteOnTermination\n    BlockDevicedMapping.<N>.Ebs.NoDevice\n    BlockDevicedMapping.<N>.VirtualName\n    => remove .Ebs and allow volume id in SnapshotId\n    \"\"\"\n    ebs = bdm.pop('ebs', None)\n    if ebs:\n        ec2_id = ebs.pop('snapshot_id', None)\n        if ec2_id:\n            id = ec2utils.ec2_id_to_id(ec2_id)\n            if ec2_id.startswith('snap-'):\n                bdm['snapshot_id'] = id\n            elif ec2_id.startswith('vol-'):\n                bdm['volume_id'] = id\n            ebs.setdefault('delete_on_termination', True)\n        bdm.update(ebs)\n    return bdm\n\n\ndef _properties_get_mappings(properties):\n    return block_device.mappings_prepend_dev(properties.get('mappings', []))\n\n\ndef _format_block_device_mapping(bdm):\n    \"\"\"Contruct BlockDeviceMappingItemType\n    {'device_name': '...', 'snapshot_id': , ...}\n    => BlockDeviceMappingItemType\n    \"\"\"\n    keys = (('deviceName', 'device_name'),\n             ('virtualName', 'virtual_name'))\n    item = {}\n    for name, k in keys:\n        if k in bdm:\n            item[name] = bdm[k]\n    if bdm.get('no_device'):\n        item['noDevice'] = True\n    if ('snapshot_id' in bdm) or ('volume_id' in bdm):\n        ebs_keys = (('snapshotId', 'snapshot_id'),\n                    ('snapshotId', 'volume_id'),        # snapshotId is abused\n                    ('volumeSize', 'volume_size'),\n                    ('deleteOnTermination', 'delete_on_termination'))\n        ebs = {}\n        for name, k in ebs_keys:\n            if k in bdm:\n                if k == 'snapshot_id':\n                    ebs[name] = ec2utils.id_to_ec2_snap_id(bdm[k])\n                elif k == 'volume_id':\n                    ebs[name] = ec2utils.id_to_ec2_vol_id(bdm[k])\n                else:\n                    ebs[name] = bdm[k]\n        assert 'snapshotId' in ebs\n        item['ebs'] = ebs\n    return item\n\n\ndef _format_mappings(properties, result):\n    \"\"\"Format multiple BlockDeviceMappingItemType\"\"\"\n    mappings = [{'virtualName': m['virtual'], 'deviceName': m['device']}\n                for m in _properties_get_mappings(properties)\n                if block_device.is_swap_or_ephemeral(m['virtual'])]\n\n    block_device_mapping = [_format_block_device_mapping(bdm) for bdm in\n                            properties.get('block_device_mapping', [])]\n\n    # NOTE(yamahata): overwrite mappings with block_device_mapping\n    for bdm in block_device_mapping:\n        for i in range(len(mappings)):\n            if bdm['deviceName'] == mappings[i]['deviceName']:\n                del mappings[i]\n                break\n        mappings.append(bdm)\n\n    # NOTE(yamahata): trim ebs.no_device == true. Is this necessary?\n    mappings = [bdm for bdm in mappings if not (bdm.get('noDevice', False))]\n\n    if mappings:\n        result['blockDeviceMapping'] = mappings\n\n\nclass CloudController(object):\n    \"\"\" CloudController provides the critical dispatch between\n inbound API calls through the endpoint and messages\n sent to the other nodes.\n\"\"\"\n    def __init__(self):\n        self.image_service = s3.S3ImageService()\n        self.network_api = network.API()\n        self.volume_api = volume.API()\n        self.compute_api = compute.API(network_api=self.network_api,\n                                       volume_api=self.volume_api)\n        self.sgh = utils.import_object(FLAGS.security_group_handler)\n\n    def __str__(self):\n        return 'CloudController'\n\n    def _get_image_state(self, image):\n        # NOTE(vish): fallback status if image_state isn't set\n        state = image.get('status')\n        if state == 'active':\n            state = 'available'\n        return image['properties'].get('image_state', state)\n\n    def describe_availability_zones(self, context, **kwargs):\n        if ('zone_name' in kwargs and\n            'verbose' in kwargs['zone_name'] and\n            context.is_admin):\n            return self._describe_availability_zones_verbose(context,\n                                                             **kwargs)\n        else:\n            return self._describe_availability_zones(context, **kwargs)\n\n    def _describe_availability_zones(self, context, **kwargs):\n        ctxt = context.elevated()\n        enabled_services = db.service_get_all(ctxt, False)\n        disabled_services = db.service_get_all(ctxt, True)\n        available_zones = []\n        for zone in [service.availability_zone for service\n                     in enabled_services]:\n            if not zone in available_zones:\n                available_zones.append(zone)\n        not_available_zones = []\n        for zone in [service.availability_zone for service in disabled_services\n                     if not service['availability_zone'] in available_zones]:\n            if not zone in not_available_zones:\n                not_available_zones.append(zone)\n        result = []\n        for zone in available_zones:\n            result.append({'zoneName': zone,\n                           'zoneState': \"available\"})\n        for zone in not_available_zones:\n            result.append({'zoneName': zone,\n                           'zoneState': \"not available\"})\n        return {'availabilityZoneInfo': result}\n\n    def _describe_availability_zones_verbose(self, context, **kwargs):\n        rv = {'availabilityZoneInfo': [{'zoneName': 'nova',\n                                        'zoneState': 'available'}]}\n\n        services = db.service_get_all(context, False)\n        hosts = []\n        for host in [service['host'] for service in services]:\n            if not host in hosts:\n                hosts.append(host)\n        for host in hosts:\n            rv['availabilityZoneInfo'].append({'zoneName': '|- %s' % host,\n                                               'zoneState': ''})\n            hsvcs = [service for service in services\n                     if service['host'] == host]\n            for svc in hsvcs:\n                alive = utils.service_is_up(svc)\n                art = (alive and \":-)\") or \"XXX\"\n                active = 'enabled'\n                if svc['disabled']:\n                    active = 'disabled'\n                rv['availabilityZoneInfo'].append({\n                        'zoneName': '| |- %s' % svc['binary'],\n                        'zoneState': '%s %s %s' % (active, art,\n                                                   svc['updated_at'])})\n        return rv\n\n    def describe_regions(self, context, region_name=None, **kwargs):\n        if FLAGS.region_list:\n            regions = []\n            for region in FLAGS.region_list:\n                name, _sep, host = region.partition('=')\n                endpoint = '%s://%s:%s%s' % (FLAGS.ec2_scheme,\n                                             host,\n                                             FLAGS.ec2_port,\n                                             FLAGS.ec2_path)\n                regions.append({'regionName': name,\n                                'regionEndpoint': endpoint})\n        else:\n            regions = [{'regionName': 'nova',\n                        'regionEndpoint': '%s://%s:%s%s' % (FLAGS.ec2_scheme,\n                                                            FLAGS.ec2_host,\n                                                            FLAGS.ec2_port,\n                                                            FLAGS.ec2_path)}]\n        return {'regionInfo': regions}\n\n    def describe_snapshots(self,\n                           context,\n                           snapshot_id=None,\n                           owner=None,\n                           restorable_by=None,\n                           **kwargs):\n        if snapshot_id:\n            snapshots = []\n            for ec2_id in snapshot_id:\n                internal_id = ec2utils.ec2_id_to_id(ec2_id)\n                snapshot = self.volume_api.get_snapshot(\n                    context,\n                    snapshot_id=internal_id)\n                snapshots.append(snapshot)\n        else:\n            snapshots = self.volume_api.get_all_snapshots(context)\n        snapshots = [self._format_snapshot(context, s) for s in snapshots]\n        return {'snapshotSet': snapshots}\n\n    def _format_snapshot(self, context, snapshot):\n        s = {}\n        s['snapshotId'] = ec2utils.id_to_ec2_snap_id(snapshot['id'])\n        s['volumeId'] = ec2utils.id_to_ec2_vol_id(snapshot['volume_id'])\n        s['status'] = snapshot['status']\n        s['startTime'] = snapshot['created_at']\n        s['progress'] = snapshot['progress']\n        s['ownerId'] = snapshot['project_id']\n        s['volumeSize'] = snapshot['volume_size']\n        s['description'] = snapshot['display_description']\n        return s\n\n    def create_snapshot(self, context, volume_id, **kwargs):\n        validate_ec2_id(volume_id)\n        LOG.audit(_(\"Create snapshot of volume %s\"), volume_id,\n                  context=context)\n        volume_id = ec2utils.ec2_id_to_id(volume_id)\n        volume = self.volume_api.get(context, volume_id)\n        snapshot = self.volume_api.create_snapshot(\n                context,\n                volume,\n                None,\n                kwargs.get('description'))\n        return self._format_snapshot(context, snapshot)\n\n    def delete_snapshot(self, context, snapshot_id, **kwargs):\n        snapshot_id = ec2utils.ec2_id_to_id(snapshot_id)\n        snapshot = self.volume_api.get_snapshot(context, snapshot_id)\n        self.volume_api.delete_snapshot(context, snapshot)\n        return True\n\n    def describe_key_pairs(self, context, key_name=None, **kwargs):\n        key_pairs = db.key_pair_get_all_by_user(context, context.user_id)\n        if not key_name is None:\n            key_pairs = [x for x in key_pairs if x['name'] in key_name]\n\n        result = []\n        for key_pair in key_pairs:\n            # filter out the vpn keys\n            suffix = FLAGS.vpn_key_suffix\n            if context.is_admin or not key_pair['name'].endswith(suffix):\n                result.append({\n                    'keyName': key_pair['name'],\n                    'keyFingerprint': key_pair['fingerprint'],\n                })\n\n        return {'keySet': result}\n\n    def create_key_pair(self, context, key_name, **kwargs):\n        if not re.match('^[a-zA-Z0-9_\\- ]+$', str(key_name)):\n            err = _(\"Value (%s) for KeyName is invalid.\"\n                    \" Content limited to Alphanumeric character, \"\n                    \"spaces, dashes, and underscore.\") % key_name\n            raise exception.EC2APIError(err)\n\n        if len(str(key_name)) > 255:\n            err = _(\"Value (%s) for Keyname is invalid.\"\n                    \" Length exceeds maximum of 255.\") % key_name\n            raise exception.EC2APIError(err)\n\n        LOG.audit(_(\"Create key pair %s\"), key_name, context=context)\n        data = _gen_key(context, context.user_id, key_name)\n        return {'keyName': key_name,\n                'keyFingerprint': data['fingerprint'],\n                'keyMaterial': data['private_key']}\n        # TODO(vish): when context is no longer an object, pass it here\n\n    def import_key_pair(self, context, key_name, public_key_material,\n                        **kwargs):\n        LOG.audit(_(\"Import key %s\"), key_name, context=context)\n        try:\n            db.key_pair_get(context, context.user_id, key_name)\n            raise exception.KeyPairExists(key_name=key_name)\n        except exception.NotFound:\n            pass\n        public_key = base64.b64decode(public_key_material)\n        fingerprint = crypto.generate_fingerprint(public_key)\n        key = {}\n        key['user_id'] = context.user_id\n        key['name'] = key_name\n        key['public_key'] = public_key\n        key['fingerprint'] = fingerprint\n        db.key_pair_create(context, key)\n        return {'keyName': key_name,\n                'keyFingerprint': fingerprint}\n\n    def delete_key_pair(self, context, key_name, **kwargs):\n        LOG.audit(_(\"Delete key pair %s\"), key_name, context=context)\n        try:\n            db.key_pair_destroy(context, context.user_id, key_name)\n        except exception.NotFound:\n            # aws returns true even if the key doesn't exist\n            pass\n        return True\n\n    def describe_security_groups(self, context, group_name=None, group_id=None,\n                                 **kwargs):\n        self.compute_api.ensure_default_security_group(context)\n        if group_name or group_id:\n            groups = []\n            if group_name:\n                for name in group_name:\n                    group = db.security_group_get_by_name(context,\n                                                          context.project_id,\n                                                          name)\n                    groups.append(group)\n            if group_id:\n                for gid in group_id:\n                    group = db.security_group_get(context, gid)\n                    groups.append(group)\n        elif context.is_admin:\n            groups = db.security_group_get_all(context)\n        else:\n            groups = db.security_group_get_by_project(context,\n                                                      context.project_id)\n        groups = [self._format_security_group(context, g) for g in groups]\n\n        return {'securityGroupInfo':\n                list(sorted(groups,\n                            key=lambda k: (k['ownerId'], k['groupName'])))}\n\n    def _format_security_group(self, context, group):\n        g = {}\n        g['groupDescription'] = group.description\n        g['groupName'] = group.name\n        g['ownerId'] = group.project_id\n        g['ipPermissions'] = []\n        for rule in group.rules:\n            r = {}\n            r['groups'] = []\n            r['ipRanges'] = []\n            if rule.group_id:\n                source_group = db.security_group_get(context, rule.group_id)\n                r['groups'] += [{'groupName': source_group.name,\n                                 'userId': source_group.project_id}]\n                if rule.protocol:\n                    r['ipProtocol'] = rule.protocol\n                    r['fromPort'] = rule.from_port\n                    r['toPort'] = rule.to_port\n                    g['ipPermissions'] += [dict(r)]\n                else:\n                    for protocol, min_port, max_port in (('icmp', -1, -1),\n                                                         ('tcp', 1, 65535),\n                                                         ('udp', 1, 65535)):\n                        r['ipProtocol'] = protocol\n                        r['fromPort'] = min_port\n                        r['toPort'] = max_port\n                        g['ipPermissions'] += [dict(r)]\n            else:\n                r['ipProtocol'] = rule.protocol\n                r['fromPort'] = rule.from_port\n                r['toPort'] = rule.to_port\n                r['ipRanges'] += [{'cidrIp': rule.cidr}]\n                g['ipPermissions'] += [r]\n        return g\n\n    def _rule_args_to_dict(self, context, kwargs):\n        rules = []\n        if not 'groups' in kwargs and not 'ip_ranges' in kwargs:\n            rule = self._rule_dict_last_step(context, **kwargs)\n            if rule:\n                rules.append(rule)\n            return rules\n        if 'ip_ranges' in kwargs:\n            rules = self._cidr_args_split(kwargs)\n        else:\n            rules = [kwargs]\n        finalset = []\n        for rule in rules:\n            if 'groups' in rule:\n                groups_values = self._groups_args_split(rule)\n                for groups_value in groups_values:\n                    final = self._rule_dict_last_step(context, **groups_value)\n                    finalset.append(final)\n            else:\n                final = self._rule_dict_last_step(context, **rule)\n                finalset.append(final)\n        return finalset\n\n    def _cidr_args_split(self, kwargs):\n        cidr_args_split = []\n        cidrs = kwargs['ip_ranges']\n        for key, cidr in cidrs.iteritems():\n            mykwargs = kwargs.copy()\n            del mykwargs['ip_ranges']\n            mykwargs['cidr_ip'] = cidr['cidr_ip']\n            cidr_args_split.append(mykwargs)\n        return cidr_args_split\n\n    def _groups_args_split(self, kwargs):\n        groups_args_split = []\n        groups = kwargs['groups']\n        for key, group in groups.iteritems():\n            mykwargs = kwargs.copy()\n            del mykwargs['groups']\n            if 'group_name' in group:\n                mykwargs['source_security_group_name'] = group['group_name']\n            if 'user_id' in group:\n                mykwargs['source_security_group_owner_id'] = group['user_id']\n            if 'group_id' in group:\n                mykwargs['source_security_group_id'] = group['group_id']\n            groups_args_split.append(mykwargs)\n        return groups_args_split\n\n    def _rule_dict_last_step(self, context, to_port=None, from_port=None,\n                                  ip_protocol=None, cidr_ip=None, user_id=None,\n                                  source_security_group_name=None,\n                                  source_security_group_owner_id=None):\n\n        values = {}\n\n        if source_security_group_name:\n            source_project_id = self._get_source_project_id(context,\n                source_security_group_owner_id)\n\n            source_security_group = db.security_group_get_by_name(\n                    context.elevated(),\n                    source_project_id,\n                    source_security_group_name)\n            notfound = exception.SecurityGroupNotFound\n            if not source_security_group:\n                raise notfound(security_group_id=source_security_group_name)\n            values['group_id'] = source_security_group['id']\n        elif cidr_ip:\n            # If this fails, it throws an exception. This is what we want.\n            cidr_ip = urllib.unquote(cidr_ip).decode()\n\n            if not utils.is_valid_cidr(cidr_ip):\n                # Raise exception for non-valid address\n                raise exception.EC2APIError(_(\"Invalid CIDR\"))\n\n            values['cidr'] = cidr_ip\n        else:\n            values['cidr'] = '0.0.0.0/0'\n\n        if source_security_group_name:\n            # Open everything if an explicit port range or type/code are not\n            # specified, but only if a source group was specified.\n            ip_proto_upper = ip_protocol.upper() if ip_protocol else ''\n            if (ip_proto_upper == 'ICMP' and\n                from_port is None and to_port is None):\n                from_port = -1\n                to_port = -1\n            elif (ip_proto_upper in ['TCP', 'UDP'] and from_port is None\n                  and to_port is None):\n                from_port = 1\n                to_port = 65535\n\n        if ip_protocol and from_port is not None and to_port is not None:\n\n            ip_protocol = str(ip_protocol)\n            try:\n                # Verify integer conversions\n                from_port = int(from_port)\n                to_port = int(to_port)\n            except ValueError:\n                if ip_protocol.upper() == 'ICMP':\n                    raise exception.InvalidInput(reason=\"Type and\"\n                         \" Code must be integers for ICMP protocol type\")\n                else:\n                    raise exception.InvalidInput(reason=\"To and From ports \"\n                          \"must be integers\")\n\n            if ip_protocol.upper() not in ['TCP', 'UDP', 'ICMP']:\n                raise exception.InvalidIpProtocol(protocol=ip_protocol)\n\n            # Verify that from_port must always be less than\n            # or equal to to_port\n            if (ip_protocol.upper() in ['TCP', 'UDP'] and\n                (from_port > to_port)):\n                raise exception.InvalidPortRange(from_port=from_port,\n                      to_port=to_port, msg=\"Former value cannot\"\n                                            \" be greater than the later\")\n\n            # Verify valid TCP, UDP port ranges\n            if (ip_protocol.upper() in ['TCP', 'UDP'] and\n                (from_port < 1 or to_port > 65535)):\n                raise exception.InvalidPortRange(from_port=from_port,\n                      to_port=to_port, msg=\"Valid TCP ports should\"\n                                           \" be between 1-65535\")\n\n            # Verify ICMP type and code\n            if (ip_protocol.upper() == \"ICMP\" and\n                (from_port < -1 or from_port > 255 or\n                to_port < -1 or to_port > 255)):\n                raise exception.InvalidPortRange(from_port=from_port,\n                      to_port=to_port, msg=\"For ICMP, the\"\n                                           \" type:code must be valid\")\n\n            values['protocol'] = ip_protocol.lower()\n            values['from_port'] = from_port\n            values['to_port'] = to_port\n        else:\n            # If cidr based filtering, protocol and ports are mandatory\n            if 'cidr' in values:\n                return None\n\n        return values\n\n    def _security_group_rule_exists(self, security_group, values):\n        \"\"\"Indicates whether the specified rule values are already\n           defined in the given security group.\n        \"\"\"\n        for rule in security_group.rules:\n            is_duplicate = True\n            keys = ('group_id', 'cidr', 'from_port', 'to_port', 'protocol')\n            for key in keys:\n                if rule.get(key) != values.get(key):\n                    is_duplicate = False\n                    break\n            if is_duplicate:\n                return rule['id']\n        return False\n\n    def revoke_security_group_ingress(self, context, group_name=None,\n                                      group_id=None, **kwargs):\n        if not group_name and not group_id:\n            err = _(\"Not enough parameters, need group_name or group_id\")\n            raise exception.EC2APIError(err)\n        self.compute_api.ensure_default_security_group(context)\n        notfound = exception.SecurityGroupNotFound\n        if group_name:\n            security_group = db.security_group_get_by_name(context,\n                                                           context.project_id,\n                                                           group_name)\n            if not security_group:\n                raise notfound(security_group_id=group_name)\n        if group_id:\n            security_group = db.security_group_get(context, group_id)\n            if not security_group:\n                raise notfound(security_group_id=group_id)\n\n        msg = _(\"Revoke security group ingress %s\")\n        LOG.audit(msg, security_group['name'], context=context)\n        prevalues = []\n        try:\n            prevalues = kwargs['ip_permissions']\n        except KeyError:\n            prevalues.append(kwargs)\n        rule_id = None\n        rule_ids = []\n        for values in prevalues:\n            rulesvalues = self._rule_args_to_dict(context, values)\n            if not rulesvalues:\n                err = _(\"%s Not enough parameters to build a valid rule\")\n                raise exception.EC2APIError(err % rulesvalues)\n\n            for values_for_rule in rulesvalues:\n                values_for_rule['parent_group_id'] = security_group.id\n                rule_id = self._security_group_rule_exists(security_group,\n                                                           values_for_rule)\n                if rule_id:\n                    db.security_group_rule_destroy(context, rule_id)\n                    rule_ids.append(rule_id)\n        if rule_id:\n            # NOTE(vish): we removed a rule, so refresh\n            self.compute_api.trigger_security_group_rules_refresh(\n                    context,\n                    security_group_id=security_group['id'])\n            self.sgh.trigger_security_group_rule_destroy_refresh(\n                    context, rule_ids)\n            return True\n        raise exception.EC2APIError(_(\"No rule for the specified parameters.\"))\n\n    # TODO(soren): This has only been tested with Boto as the client.\n    #              Unfortunately, it seems Boto is using an old API\n    #              for these operations, so support for newer API versions\n    #              is sketchy.\n    def authorize_security_group_ingress(self, context, group_name=None,\n                                         group_id=None, **kwargs):\n        if not group_name and not group_id:\n            err = _(\"Not enough parameters, need group_name or group_id\")\n            raise exception.EC2APIError(err)\n        self.compute_api.ensure_default_security_group(context)\n        notfound = exception.SecurityGroupNotFound\n        if group_name:\n            security_group = db.security_group_get_by_name(context,\n                                                           context.project_id,\n                                                           group_name)\n            if not security_group:\n                raise notfound(security_group_id=group_name)\n        if group_id:\n            security_group = db.security_group_get(context, group_id)\n            if not security_group:\n                raise notfound(security_group_id=group_id)\n\n        msg = _(\"Authorize security group ingress %s\")\n        LOG.audit(msg, security_group['name'], context=context)\n        prevalues = []\n        try:\n            prevalues = kwargs['ip_permissions']\n        except KeyError:\n            prevalues.append(kwargs)\n        postvalues = []\n        for values in prevalues:\n            rulesvalues = self._rule_args_to_dict(context, values)\n            if not rulesvalues:\n                err = _(\"%s Not enough parameters to build a valid rule\")\n                raise exception.EC2APIError(err % rulesvalues)\n            for values_for_rule in rulesvalues:\n                values_for_rule['parent_group_id'] = security_group.id\n                if self._security_group_rule_exists(security_group,\n                                                    values_for_rule):\n                    err = _('%s - This rule already exists in group')\n                    raise exception.EC2APIError(err % values_for_rule)\n                postvalues.append(values_for_rule)\n\n        allowed = quota.allowed_security_group_rules(context,\n                                                   security_group['id'],\n                                                   1)\n        if allowed < 1:\n            msg = _(\"Quota exceeded, too many security group rules.\")\n            raise exception.EC2APIError(msg)\n\n        rule_ids = []\n        for values_for_rule in postvalues:\n            security_group_rule = db.security_group_rule_create(\n                    context,\n                    values_for_rule)\n            rule_ids.append(security_group_rule['id'])\n\n        if postvalues:\n            self.compute_api.trigger_security_group_rules_refresh(\n                    context,\n                    security_group_id=security_group['id'])\n            self.sgh.trigger_security_group_rule_create_refresh(\n                    context, rule_ids)\n            return True\n\n        raise exception.EC2APIError(_(\"No rule for the specified parameters.\"))\n\n    def _get_source_project_id(self, context, source_security_group_owner_id):\n        if source_security_group_owner_id:\n        # Parse user:project for source group.\n            source_parts = source_security_group_owner_id.split(':')\n\n            # If no project name specified, assume it's same as user name.\n            # Since we're looking up by project name, the user name is not\n            # used here.  It's only read for EC2 API compatibility.\n            if len(source_parts) == 2:\n                source_project_id = source_parts[1]\n            else:\n                source_project_id = source_parts[0]\n        else:\n            source_project_id = context.project_id\n\n        return source_project_id\n\n    def create_security_group(self, context, group_name, group_description):\n        if not re.match('^[a-zA-Z0-9_\\- ]+$', str(group_name)):\n            # Some validation to ensure that values match API spec.\n            # - Alphanumeric characters, spaces, dashes, and underscores.\n            # TODO(Daviey): LP: #813685 extend beyond group_name checking, and\n            #  probably create a param validator that can be used elsewhere.\n            err = _(\"Value (%s) for parameter GroupName is invalid.\"\n                    \" Content limited to Alphanumeric characters, \"\n                    \"spaces, dashes, and underscores.\") % group_name\n            # err not that of master ec2 implementation, as they fail to raise.\n            raise exception.InvalidParameterValue(err=err)\n\n        if len(str(group_name)) > 255:\n            err = _(\"Value (%s) for parameter GroupName is invalid.\"\n                    \" Length exceeds maximum of 255.\") % group_name\n            raise exception.InvalidParameterValue(err=err)\n\n        LOG.audit(_(\"Create Security Group %s\"), group_name, context=context)\n        self.compute_api.ensure_default_security_group(context)\n        if db.security_group_exists(context, context.project_id, group_name):\n            msg = _('group %s already exists')\n            raise exception.EC2APIError(msg % group_name)\n\n        if quota.allowed_security_groups(context, 1) < 1:\n            msg = _(\"Quota exceeded, too many security groups.\")\n            raise exception.EC2APIError(msg)\n\n        group = {'user_id': context.user_id,\n                 'project_id': context.project_id,\n                 'name': group_name,\n                 'description': group_description}\n        group_ref = db.security_group_create(context, group)\n\n        self.sgh.trigger_security_group_create_refresh(context, group)\n\n        return {'securityGroupSet': [self._format_security_group(context,\n                                                                 group_ref)]}\n\n    def delete_security_group(self, context, group_name=None, group_id=None,\n                              **kwargs):\n        if not group_name and not group_id:\n            err = _(\"Not enough parameters, need group_name or group_id\")\n            raise exception.EC2APIError(err)\n        notfound = exception.SecurityGroupNotFound\n        if group_name:\n            security_group = db.security_group_get_by_name(context,\n                                                           context.project_id,\n                                                           group_name)\n            if not security_group:\n                raise notfound(security_group_id=group_name)\n        elif group_id:\n            security_group = db.security_group_get(context, group_id)\n            if not security_group:\n                raise notfound(security_group_id=group_id)\n        if db.security_group_in_use(context, security_group.id):\n            raise exception.InvalidGroup(reason=\"In Use\")\n        LOG.audit(_(\"Delete security group %s\"), group_name, context=context)\n        db.security_group_destroy(context, security_group.id)\n\n        self.sgh.trigger_security_group_destroy_refresh(context,\n                                                        security_group.id)\n        return True\n\n    def get_console_output(self, context, instance_id, **kwargs):\n        LOG.audit(_(\"Get console output for instance %s\"), instance_id,\n                  context=context)\n        # instance_id may be passed in as a list of instances\n        if isinstance(instance_id, list):\n            ec2_id = instance_id[0]\n        else:\n            ec2_id = instance_id\n        validate_ec2_id(ec2_id)\n        instance_id = ec2utils.ec2_id_to_id(ec2_id)\n        instance = self.compute_api.get(context, instance_id)\n        output = self.compute_api.get_console_output(context, instance)\n        now = utils.utcnow()\n        return {\"InstanceId\": ec2_id,\n                \"Timestamp\": now,\n                \"output\": base64.b64encode(output)}\n\n    def describe_volumes(self, context, volume_id=None, **kwargs):\n        if volume_id:\n            volumes = []\n            for ec2_id in volume_id:\n                validate_ec2_id(ec2_id)\n                internal_id = ec2utils.ec2_id_to_id(ec2_id)\n                volume = self.volume_api.get(context, internal_id)\n                volumes.append(volume)\n        else:\n            volumes = self.volume_api.get_all(context)\n        volumes = [self._format_volume(context, v) for v in volumes]\n        return {'volumeSet': volumes}\n\n    def _format_volume(self, context, volume):\n        instance_ec2_id = None\n        instance_data = None\n        if volume.get('instance', None):\n            instance_id = volume['instance']['id']\n            instance_ec2_id = ec2utils.id_to_ec2_id(instance_id)\n            instance_data = '%s[%s]' % (instance_ec2_id,\n                                        volume['instance']['host'])\n        v = {}\n        v['volumeId'] = ec2utils.id_to_ec2_vol_id(volume['id'])\n        v['status'] = volume['status']\n        v['size'] = volume['size']\n        v['availabilityZone'] = volume['availability_zone']\n        v['createTime'] = volume['created_at']\n        if context.is_admin:\n            v['status'] = '%s (%s, %s, %s, %s)' % (\n                volume['status'],\n                volume['project_id'],\n                volume['host'],\n                instance_data,\n                volume['mountpoint'])\n        if volume['attach_status'] == 'attached':\n            v['attachmentSet'] = [{'attachTime': volume['attach_time'],\n                                   'deleteOnTermination': False,\n                                   'device': volume['mountpoint'],\n                                   'instanceId': instance_ec2_id,\n                                   'status': 'attached',\n                                   'volumeId': v['volumeId']}]\n        else:\n            v['attachmentSet'] = [{}]\n        if volume.get('snapshot_id') is not None:\n            v['snapshotId'] = ec2utils.id_to_ec2_snap_id(volume['snapshot_id'])\n        else:\n            v['snapshotId'] = None\n\n        return v\n\n    def create_volume(self, context, **kwargs):\n        size = kwargs.get('size')\n        if kwargs.get('snapshot_id') is not None:\n            snapshot_id = ec2utils.ec2_id_to_id(kwargs['snapshot_id'])\n            snapshot = self.volume_api.get_snapshot(context, snapshot_id)\n            LOG.audit(_(\"Create volume from snapshot %s\"), snapshot_id,\n                      context=context)\n        else:\n            snapshot = None\n            LOG.audit(_(\"Create volume of %s GB\"), size, context=context)\n\n        availability_zone = kwargs.get('availability_zone', None)\n\n        volume = self.volume_api.create(context,\n                                        size,\n                                        None,\n                                        None,\n                                        snapshot,\n                                        availability_zone=availability_zone)\n        # TODO(vish): Instance should be None at db layer instead of\n        #             trying to lazy load, but for now we turn it into\n        #             a dict to avoid an error.\n        return self._format_volume(context, dict(volume))\n\n    def delete_volume(self, context, volume_id, **kwargs):\n        validate_ec2_id(volume_id)\n        volume_id = ec2utils.ec2_id_to_id(volume_id)\n\n        try:\n            volume = self.volume_api.get(context, volume_id)\n            self.volume_api.delete(context, volume)\n        except exception.InvalidVolume:\n            raise exception.EC2APIError(_('Delete Failed'))\n\n        return True\n\n    def attach_volume(self, context, volume_id, instance_id, device, **kwargs):\n        validate_ec2_id(instance_id)\n        validate_ec2_id(volume_id)\n        volume_id = ec2utils.ec2_id_to_id(volume_id)\n        instance_id = ec2utils.ec2_id_to_id(instance_id)\n        instance = self.compute_api.get(context, instance_id)\n        msg = _(\"Attach volume %(volume_id)s to instance %(instance_id)s\"\n                \" at %(device)s\") % locals()\n        LOG.audit(msg, context=context)\n\n        try:\n            self.compute_api.attach_volume(context, instance,\n                                           volume_id, device)\n        except exception.InvalidVolume:\n            raise exception.EC2APIError(_('Attach Failed.'))\n\n        volume = self.volume_api.get(context, volume_id)\n        return {'attachTime': volume['attach_time'],\n                'device': volume['mountpoint'],\n                'instanceId': ec2utils.id_to_ec2_id(instance_id),\n                'requestId': context.request_id,\n                'status': volume['attach_status'],\n                'volumeId': ec2utils.id_to_ec2_vol_id(volume_id)}\n\n    def detach_volume(self, context, volume_id, **kwargs):\n        validate_ec2_id(volume_id)\n        volume_id = ec2utils.ec2_id_to_id(volume_id)\n        LOG.audit(_(\"Detach volume %s\"), volume_id, context=context)\n        volume = self.volume_api.get(context, volume_id)\n\n        try:\n            instance = self.compute_api.detach_volume(context,\n                                                      volume_id=volume_id)\n        except exception.InvalidVolume:\n            raise exception.EC2APIError(_('Detach Volume Failed.'))\n\n        return {'attachTime': volume['attach_time'],\n                'device': volume['mountpoint'],\n                'instanceId': ec2utils.id_to_ec2_id(instance['id']),\n                'requestId': context.request_id,\n                'status': volume['attach_status'],\n                'volumeId': ec2utils.id_to_ec2_vol_id(volume_id)}\n\n    def _format_kernel_id(self, context, instance_ref, result, key):\n        kernel_uuid = instance_ref['kernel_id']\n        if kernel_uuid is None or kernel_uuid == '':\n            return\n        result[key] = ec2utils.glance_id_to_ec2_id(context, kernel_uuid, 'aki')\n\n    def _format_ramdisk_id(self, context, instance_ref, result, key):\n        ramdisk_uuid = instance_ref['ramdisk_id']\n        if ramdisk_uuid is None or ramdisk_uuid == '':\n            return\n        result[key] = ec2utils.glance_id_to_ec2_id(context, ramdisk_uuid,\n                                                   'ari')\n\n    def describe_instance_attribute(self, context, instance_id, attribute,\n                                    **kwargs):\n        def _unsupported_attribute(instance, result):\n            raise exception.EC2APIError(_('attribute not supported: %s') %\n                                     attribute)\n\n        def _format_attr_block_device_mapping(instance, result):\n            tmp = {}\n            self._format_instance_root_device_name(instance, tmp)\n            self._format_instance_bdm(context, instance_id,\n                                      tmp['rootDeviceName'], result)\n\n        def _format_attr_disable_api_termination(instance, result):\n            result['disableApiTermination'] = instance['disable_terminate']\n\n        def _format_attr_group_set(instance, result):\n            CloudController._format_group_set(instance, result)\n\n        def _format_attr_instance_initiated_shutdown_behavior(instance,\n                                                               result):\n            if instance['shutdown_terminate']:\n                result['instanceInitiatedShutdownBehavior'] = 'terminate'\n            else:\n                result['instanceInitiatedShutdownBehavior'] = 'stop'\n\n        def _format_attr_instance_type(instance, result):\n            self._format_instance_type(instance, result)\n\n        def _format_attr_kernel(instance, result):\n            self._format_kernel_id(context, instance, result, 'kernel')\n\n        def _format_attr_ramdisk(instance, result):\n            self._format_ramdisk_id(context, instance, result, 'ramdisk')\n\n        def _format_attr_root_device_name(instance, result):\n            self._format_instance_root_device_name(instance, result)\n\n        def _format_attr_source_dest_check(instance, result):\n            _unsupported_attribute(instance, result)\n\n        def _format_attr_user_data(instance, result):\n            result['userData'] = base64.b64decode(instance['user_data'])\n\n        attribute_formatter = {\n            'blockDeviceMapping': _format_attr_block_device_mapping,\n            'disableApiTermination': _format_attr_disable_api_termination,\n            'groupSet': _format_attr_group_set,\n            'instanceInitiatedShutdownBehavior':\n            _format_attr_instance_initiated_shutdown_behavior,\n            'instanceType': _format_attr_instance_type,\n            'kernel': _format_attr_kernel,\n            'ramdisk': _format_attr_ramdisk,\n            'rootDeviceName': _format_attr_root_device_name,\n            'sourceDestCheck': _format_attr_source_dest_check,\n            'userData': _format_attr_user_data,\n            }\n\n        fn = attribute_formatter.get(attribute)\n        if fn is None:\n            raise exception.EC2APIError(\n                _('attribute not supported: %s') % attribute)\n\n        ec2_instance_id = instance_id\n        validate_ec2_id(instance_id)\n        instance_id = ec2utils.ec2_id_to_id(ec2_instance_id)\n        instance = self.compute_api.get(context, instance_id)\n        result = {'instance_id': ec2_instance_id}\n        fn(instance, result)\n        return result\n\n    def describe_instances(self, context, **kwargs):\n        # Optional DescribeInstances argument\n        instance_id = kwargs.get('instance_id', None)\n        return self._format_describe_instances(context,\n                instance_id=instance_id)\n\n    def describe_instances_v6(self, context, **kwargs):\n        # Optional DescribeInstancesV6 argument\n        instance_id = kwargs.get('instance_id', None)\n        return self._format_describe_instances(context,\n                instance_id=instance_id, use_v6=True)\n\n    def _format_describe_instances(self, context, **kwargs):\n        return {'reservationSet': self._format_instances(context, **kwargs)}\n\n    def _format_run_instances(self, context, reservation_id):\n        i = self._format_instances(context, reservation_id=reservation_id)\n        assert len(i) == 1\n        return i[0]\n\n    def _format_terminate_instances(self, context, instance_id,\n                                    previous_states):\n        instances_set = []\n        for (ec2_id, previous_state) in zip(instance_id, previous_states):\n            i = {}\n            i['instanceId'] = ec2_id\n            i['previousState'] = _state_description(previous_state['vm_state'],\n                                        previous_state['shutdown_terminate'])\n            try:\n                internal_id = ec2utils.ec2_id_to_id(ec2_id)\n                instance = self.compute_api.get(context, internal_id)\n                i['shutdownState'] = _state_description(instance['vm_state'],\n                                            instance['shutdown_terminate'])\n            except exception.NotFound:\n                i['shutdownState'] = _state_description(vm_states.DELETED,\n                                                        True)\n            instances_set.append(i)\n        return {'instancesSet': instances_set}\n\n    def _format_instance_bdm(self, context, instance_id, root_device_name,\n                             result):\n        \"\"\"Format InstanceBlockDeviceMappingResponseItemType\"\"\"\n        root_device_type = 'instance-store'\n        mapping = []\n        for bdm in db.block_device_mapping_get_all_by_instance(context,\n                                                               instance_id):\n            volume_id = bdm['volume_id']\n            if (volume_id is None or bdm['no_device']):\n                continue\n\n            if (bdm['device_name'] == root_device_name and\n                (bdm['snapshot_id'] or bdm['volume_id'])):\n                assert not bdm['virtual_name']\n                root_device_type = 'ebs'\n\n            vol = self.volume_api.get(context, volume_id)\n            LOG.debug(_(\"vol = %s\\n\"), vol)\n            # TODO(yamahata): volume attach time\n            ebs = {'volumeId': volume_id,\n                   'deleteOnTermination': bdm['delete_on_termination'],\n                   'attachTime': vol['attach_time'] or '-',\n                   'status': vol['status'], }\n            res = {'deviceName': bdm['device_name'],\n                   'ebs': ebs, }\n            mapping.append(res)\n\n        if mapping:\n            result['blockDeviceMapping'] = mapping\n        result['rootDeviceType'] = root_device_type\n\n    @staticmethod\n    def _format_instance_root_device_name(instance, result):\n        result['rootDeviceName'] = (instance.get('root_device_name') or\n                                    block_device.DEFAULT_ROOT_DEV_NAME)\n\n    @staticmethod\n    def _format_instance_type(instance, result):\n        if instance['instance_type']:\n            result['instanceType'] = instance['instance_type'].get('name')\n        else:\n            result['instanceType'] = None\n\n    @staticmethod\n    def _format_group_set(instance, result):\n        security_group_names = []\n        if instance.get('security_groups'):\n            for security_group in instance['security_groups']:\n                security_group_names.append(security_group['name'])\n        result['groupSet'] = utils.convert_to_list_dict(\n            security_group_names, 'groupId')\n\n    def _format_instances(self, context, instance_id=None, use_v6=False,\n            **search_opts):\n        # TODO(termie): this method is poorly named as its name does not imply\n        #               that it will be making a variety of database calls\n        #               rather than simply formatting a bunch of instances that\n        #               were handed to it\n        reservations = {}\n        # NOTE(vish): instance_id is an optional list of ids to filter by\n        if instance_id:\n            instances = []\n            for ec2_id in instance_id:\n                internal_id = ec2utils.ec2_id_to_id(ec2_id)\n                try:\n                    instance = self.compute_api.get(context, internal_id)\n                except exception.NotFound:\n                    continue\n                instances.append(instance)\n        else:\n            try:\n                # always filter out deleted instances\n                search_opts['deleted'] = False\n                instances = self.compute_api.get_all(context,\n                                                     search_opts=search_opts,\n                                                     sort_dir='asc')\n            except exception.NotFound:\n                instances = []\n        for instance in instances:\n            if not context.is_admin:\n                if instance['image_ref'] == str(FLAGS.vpn_image_id):\n                    continue\n            i = {}\n            instance_id = instance['id']\n            ec2_id = ec2utils.id_to_ec2_id(instance_id)\n            i['instanceId'] = ec2_id\n            image_uuid = instance['image_ref']\n            i['imageId'] = ec2utils.glance_id_to_ec2_id(context, image_uuid)\n            self._format_kernel_id(context, instance, i, 'kernelId')\n            self._format_ramdisk_id(context, instance, i, 'ramdiskId')\n            i['instanceState'] = _state_description(\n                instance['vm_state'], instance['shutdown_terminate'])\n\n            fixed_ip = None\n            floating_ip = None\n            ip_info = ec2utils.get_ip_info_for_instance(context, instance)\n            if ip_info['fixed_ips']:\n                fixed_ip = ip_info['fixed_ips'][0]\n            if ip_info['floating_ips']:\n                floating_ip = ip_info['floating_ips'][0]\n            if ip_info['fixed_ip6s']:\n                i['dnsNameV6'] = ip_info['fixed_ip6s'][0]\n            if FLAGS.ec2_private_dns_show_ip:\n                i['privateDnsName'] = fixed_ip\n            else:\n                i['privateDnsName'] = instance['hostname']\n            i['privateIpAddress'] = fixed_ip\n            i['publicDnsName'] = floating_ip\n            i['ipAddress'] = floating_ip or fixed_ip\n            i['dnsName'] = i['publicDnsName'] or i['privateDnsName']\n            i['keyName'] = instance['key_name']\n\n            if context.is_admin:\n                i['keyName'] = '%s (%s, %s)' % (i['keyName'],\n                    instance['project_id'],\n                    instance['host'])\n            i['productCodesSet'] = utils.convert_to_list_dict([],\n                                                              'product_codes')\n            self._format_instance_type(instance, i)\n            i['launchTime'] = instance['created_at']\n            i['amiLaunchIndex'] = instance['launch_index']\n            self._format_instance_root_device_name(instance, i)\n            self._format_instance_bdm(context, instance_id,\n                                      i['rootDeviceName'], i)\n            host = instance['host']\n            services = db.service_get_all_by_host(context.elevated(), host)\n            zone = ec2utils.get_availability_zone_by_host(services, host)\n            i['placement'] = {'availabilityZone': zone}\n            if instance['reservation_id'] not in reservations:\n                r = {}\n                r['reservationId'] = instance['reservation_id']\n                r['ownerId'] = instance['project_id']\n                self._format_group_set(instance, r)\n                r['instancesSet'] = []\n                reservations[instance['reservation_id']] = r\n            reservations[instance['reservation_id']]['instancesSet'].append(i)\n\n        return list(reservations.values())\n\n    def describe_addresses(self, context, **kwargs):\n        return self.format_addresses(context)\n\n    def format_addresses(self, context):\n        addresses = []\n        floaters = self.network_api.get_floating_ips_by_project(context)\n        for floating_ip_ref in floaters:\n            if floating_ip_ref['project_id'] is None:\n                continue\n            address = floating_ip_ref['address']\n            ec2_id = None\n            if floating_ip_ref['fixed_ip_id']:\n                fixed_id = floating_ip_ref['fixed_ip_id']\n                fixed = self.network_api.get_fixed_ip(context, fixed_id)\n                if fixed['instance_id'] is not None:\n                    ec2_id = ec2utils.id_to_ec2_id(fixed['instance_id'])\n            address_rv = {'public_ip': address,\n                          'instance_id': ec2_id}\n            if context.is_admin:\n                details = \"%s (%s)\" % (address_rv['instance_id'],\n                                       floating_ip_ref['project_id'])\n                address_rv['instance_id'] = details\n            addresses.append(address_rv)\n        return {'addressesSet': addresses}\n\n    def allocate_address(self, context, **kwargs):\n        LOG.audit(_(\"Allocate address\"), context=context)\n        try:\n            public_ip = self.network_api.allocate_floating_ip(context)\n            return {'publicIp': public_ip}\n        except rpc_common.RemoteError as ex:\n            # NOTE(tr3buchet) - why does this block exist?\n            if ex.exc_type == 'NoMoreFloatingIps':\n                raise exception.NoMoreFloatingIps()\n            else:\n                raise\n\n    def release_address(self, context, public_ip, **kwargs):\n        LOG.audit(_(\"Release address %s\"), public_ip, context=context)\n        self.network_api.release_floating_ip(context, address=public_ip)\n        return {'return': \"true\"}\n\n    def associate_address(self, context, instance_id, public_ip, **kwargs):\n        LOG.audit(_(\"Associate address %(public_ip)s to\"\n                \" instance %(instance_id)s\") % locals(), context=context)\n        instance_id = ec2utils.ec2_id_to_id(instance_id)\n        instance = self.compute_api.get(context, instance_id)\n        self.compute_api.associate_floating_ip(context,\n                                               instance,\n                                               address=public_ip)\n        return {'return': \"true\"}\n\n    def disassociate_address(self, context, public_ip, **kwargs):\n        LOG.audit(_(\"Disassociate address %s\"), public_ip, context=context)\n        self.network_api.disassociate_floating_ip(context, address=public_ip)\n        return {'return': \"true\"}\n\n    def run_instances(self, context, **kwargs):\n        max_count = int(kwargs.get('max_count', 1))\n        if kwargs.get('kernel_id'):\n            kernel = self._get_image(context, kwargs['kernel_id'])\n            kwargs['kernel_id'] = ec2utils.id_to_glance_id(context,\n                                                           kernel['id'])\n        if kwargs.get('ramdisk_id'):\n            ramdisk = self._get_image(context, kwargs['ramdisk_id'])\n            kwargs['ramdisk_id'] = ec2utils.id_to_glance_id(context,\n                                                            ramdisk['id'])\n        for bdm in kwargs.get('block_device_mapping', []):\n            _parse_block_device_mapping(bdm)\n\n        image = self._get_image(context, kwargs['image_id'])\n        image_uuid = ec2utils.id_to_glance_id(context, image['id'])\n\n        if image:\n            image_state = self._get_image_state(image)\n        else:\n            raise exception.ImageNotFound(image_id=kwargs['image_id'])\n\n        if image_state != 'available':\n            raise exception.EC2APIError(_('Image must be available'))\n\n        (instances, resv_id) = self.compute_api.create(context,\n            instance_type=instance_types.get_instance_type_by_name(\n                kwargs.get('instance_type', None)),\n            image_href=image_uuid,\n            min_count=int(kwargs.get('min_count', max_count)),\n            max_count=max_count,\n            kernel_id=kwargs.get('kernel_id'),\n            ramdisk_id=kwargs.get('ramdisk_id'),\n            key_name=kwargs.get('key_name'),\n            user_data=kwargs.get('user_data'),\n            security_group=kwargs.get('security_group'),\n            availability_zone=kwargs.get('placement', {}).get(\n                                  'availability_zone'),\n            block_device_mapping=kwargs.get('block_device_mapping', {}))\n        return self._format_run_instances(context, resv_id)\n\n    def terminate_instances(self, context, instance_id, **kwargs):\n        \"\"\"Terminate each instance in instance_id, which is a list of ec2 ids.\n        instance_id is a kwarg so its name cannot be modified.\"\"\"\n        LOG.debug(_(\"Going to start terminating instances\"))\n        previous_states = []\n        for ec2_id in instance_id:\n            validate_ec2_id(ec2_id)\n            _instance_id = ec2utils.ec2_id_to_id(ec2_id)\n            instance = self.compute_api.get(context, _instance_id)\n            previous_states.append(instance)\n            self.compute_api.delete(context, instance)\n        return self._format_terminate_instances(context,\n                                                instance_id,\n                                                previous_states)\n\n    def reboot_instances(self, context, instance_id, **kwargs):\n        \"\"\"instance_id is a list of instance ids\"\"\"\n        LOG.audit(_(\"Reboot instance %r\"), instance_id, context=context)\n        for ec2_id in instance_id:\n            validate_ec2_id(ec2_id)\n            _instance_id = ec2utils.ec2_id_to_id(ec2_id)\n            instance = self.compute_api.get(context, _instance_id)\n            self.compute_api.reboot(context, instance, 'HARD')\n        return True\n\n    def stop_instances(self, context, instance_id, **kwargs):\n        \"\"\"Stop each instances in instance_id.\n        Here instance_id is a list of instance ids\"\"\"\n        LOG.debug(_(\"Going to stop instances\"))\n        for ec2_id in instance_id:\n            validate_ec2_id(ec2_id)\n            _instance_id = ec2utils.ec2_id_to_id(ec2_id)\n            instance = self.compute_api.get(context, _instance_id)\n            self.compute_api.stop(context, instance)\n        return True\n\n    def start_instances(self, context, instance_id, **kwargs):\n        \"\"\"Start each instances in instance_id.\n        Here instance_id is a list of instance ids\"\"\"\n        LOG.debug(_(\"Going to start instances\"))\n        for ec2_id in instance_id:\n            validate_ec2_id(ec2_id)\n            _instance_id = ec2utils.ec2_id_to_id(ec2_id)\n            instance = self.compute_api.get(context, _instance_id)\n            self.compute_api.start(context, instance)\n        return True\n\n    def _get_image(self, context, ec2_id):\n        try:\n            internal_id = ec2utils.ec2_id_to_id(ec2_id)\n            image = self.image_service.show(context, internal_id)\n        except (exception.InvalidEc2Id, exception.ImageNotFound):\n            try:\n                return self.image_service.show_by_name(context, ec2_id)\n            except exception.NotFound:\n                raise exception.ImageNotFound(image_id=ec2_id)\n        image_type = ec2_id.split('-')[0]\n        if ec2utils.image_type(image.get('container_format')) != image_type:\n            raise exception.ImageNotFound(image_id=ec2_id)\n        return image\n\n    def _format_image(self, image):\n        \"\"\"Convert from format defined by GlanceImageService to S3 format.\"\"\"\n        i = {}\n        image_type = ec2utils.image_type(image.get('container_format'))\n        ec2_id = ec2utils.image_ec2_id(image.get('id'), image_type)\n        name = image.get('name')\n        i['imageId'] = ec2_id\n        kernel_id = image['properties'].get('kernel_id')\n        if kernel_id:\n            i['kernelId'] = ec2utils.image_ec2_id(kernel_id, 'aki')\n        ramdisk_id = image['properties'].get('ramdisk_id')\n        if ramdisk_id:\n            i['ramdiskId'] = ec2utils.image_ec2_id(ramdisk_id, 'ari')\n\n        if FLAGS.auth_strategy == 'deprecated':\n            i['imageOwnerId'] = image['properties'].get('project_id')\n        else:\n            i['imageOwnerId'] = image.get('owner')\n\n        img_loc = image['properties'].get('image_location')\n        if img_loc:\n            i['imageLocation'] = img_loc\n        else:\n            i['imageLocation'] = \"%s (%s)\" % (img_loc, name)\n\n        i['name'] = name\n        if not name and img_loc:\n            # This should only occur for images registered with ec2 api\n            # prior to that api populating the glance name\n            i['name'] = img_loc\n\n        i['imageState'] = self._get_image_state(image)\n        i['description'] = image.get('description')\n        display_mapping = {'aki': 'kernel',\n                           'ari': 'ramdisk',\n                           'ami': 'machine'}\n        i['imageType'] = display_mapping.get(image_type)\n        i['isPublic'] = not not image.get('is_public')\n        i['architecture'] = image['properties'].get('architecture')\n\n        properties = image['properties']\n        root_device_name = block_device.properties_root_device_name(properties)\n        root_device_type = 'instance-store'\n        for bdm in properties.get('block_device_mapping', []):\n            if (bdm.get('device_name') == root_device_name and\n                ('snapshot_id' in bdm or 'volume_id' in bdm) and\n                not bdm.get('no_device')):\n                root_device_type = 'ebs'\n        i['rootDeviceName'] = (root_device_name or\n                               block_device.DEFAULT_ROOT_DEV_NAME)\n        i['rootDeviceType'] = root_device_type\n\n        _format_mappings(properties, i)\n\n        return i\n\n    def describe_images(self, context, image_id=None, **kwargs):\n        # NOTE: image_id is a list!\n        if image_id:\n            images = []\n            for ec2_id in image_id:\n                try:\n                    image = self._get_image(context, ec2_id)\n                except exception.NotFound:\n                    raise exception.ImageNotFound(image_id=ec2_id)\n                images.append(image)\n        else:\n            images = self.image_service.detail(context)\n        images = [self._format_image(i) for i in images]\n        return {'imagesSet': images}\n\n    def deregister_image(self, context, image_id, **kwargs):\n        LOG.audit(_(\"De-registering image %s\"), image_id, context=context)\n        image = self._get_image(context, image_id)\n        internal_id = image['id']\n        self.image_service.delete(context, internal_id)\n        return {'imageId': image_id}\n\n    def _register_image(self, context, metadata):\n        image = self.image_service.create(context, metadata)\n        image_type = ec2utils.image_type(image.get('container_format'))\n        image_id = ec2utils.image_ec2_id(image['id'], image_type)\n        return image_id\n\n    def register_image(self, context, image_location=None, **kwargs):\n        if image_location is None and kwargs.get('name'):\n            image_location = kwargs['name']\n        if image_location is None:\n            raise exception.EC2APIError(_('imageLocation is required'))\n\n        metadata = {'properties': {'image_location': image_location}}\n\n        if kwargs.get('name'):\n            metadata['name'] = kwargs['name']\n        else:\n            metadata['name'] = image_location\n\n        if 'root_device_name' in kwargs:\n            metadata['properties']['root_device_name'] = kwargs.get(\n                                                         'root_device_name')\n\n        mappings = [_parse_block_device_mapping(bdm) for bdm in\n                    kwargs.get('block_device_mapping', [])]\n        if mappings:\n            metadata['properties']['block_device_mapping'] = mappings\n\n        image_id = self._register_image(context, metadata)\n        msg = _(\"Registered image %(image_location)s with\"\n                \" id %(image_id)s\") % locals()\n        LOG.audit(msg, context=context)\n        return {'imageId': image_id}\n\n    def describe_image_attribute(self, context, image_id, attribute, **kwargs):\n        def _block_device_mapping_attribute(image, result):\n            _format_mappings(image['properties'], result)\n\n        def _launch_permission_attribute(image, result):\n            result['launchPermission'] = []\n            if image['is_public']:\n                result['launchPermission'].append({'group': 'all'})\n\n        def _root_device_name_attribute(image, result):\n            _prop_root_dev_name = block_device.properties_root_device_name\n            result['rootDeviceName'] = _prop_root_dev_name(image['properties'])\n            if result['rootDeviceName'] is None:\n                result['rootDeviceName'] = block_device.DEFAULT_ROOT_DEV_NAME\n\n        supported_attributes = {\n            'blockDeviceMapping': _block_device_mapping_attribute,\n            'launchPermission': _launch_permission_attribute,\n            'rootDeviceName': _root_device_name_attribute,\n            }\n\n        fn = supported_attributes.get(attribute)\n        if fn is None:\n            raise exception.EC2APIError(_('attribute not supported: %s')\n                                     % attribute)\n        try:\n            image = self._get_image(context, image_id)\n        except exception.NotFound:\n            raise exception.ImageNotFound(image_id=image_id)\n\n        result = {'imageId': image_id}\n        fn(image, result)\n        return result\n\n    def modify_image_attribute(self, context, image_id, attribute,\n                               operation_type, **kwargs):\n        # TODO(devcamcar): Support users and groups other than 'all'.\n        if attribute != 'launchPermission':\n            raise exception.EC2APIError(_('attribute not supported: %s')\n                                     % attribute)\n        if not 'user_group' in kwargs:\n            raise exception.EC2APIError(_('user or group not specified'))\n        if len(kwargs['user_group']) != 1 and kwargs['user_group'][0] != 'all':\n            raise exception.EC2APIError(_('only group \"all\" is supported'))\n        if not operation_type in ['add', 'remove']:\n            msg = _('operation_type must be add or remove')\n            raise exception.EC2APIError(msg)\n        LOG.audit(_(\"Updating image %s publicity\"), image_id, context=context)\n\n        try:\n            image = self._get_image(context, image_id)\n        except exception.NotFound:\n            raise exception.ImageNotFound(image_id=image_id)\n        internal_id = image['id']\n        del(image['id'])\n\n        image['is_public'] = (operation_type == 'add')\n        try:\n            return self.image_service.update(context, internal_id, image)\n        except exception.ImageNotAuthorized:\n            msg = _('Not allowed to modify attributes for image %s')\n            raise exception.EC2APIError(msg % image_id)\n\n    def update_image(self, context, image_id, **kwargs):\n        internal_id = ec2utils.ec2_id_to_id(image_id)\n        result = self.image_service.update(context, internal_id, dict(kwargs))\n        return result\n\n    # TODO(yamahata): race condition\n    # At the moment there is no way to prevent others from\n    # manipulating instances/volumes/snapshots.\n    # As other code doesn't take it into consideration, here we don't\n    # care of it for now. Ostrich algorithm\n    def create_image(self, context, instance_id, **kwargs):\n        # NOTE(yamahata): name/description are ignored by register_image(),\n        #                 do so here\n        no_reboot = kwargs.get('no_reboot', False)\n        validate_ec2_id(instance_id)\n        ec2_instance_id = instance_id\n        instance_id = ec2utils.ec2_id_to_id(ec2_instance_id)\n        instance = self.compute_api.get(context, instance_id)\n\n        # stop the instance if necessary\n        restart_instance = False\n        if not no_reboot:\n            vm_state = instance['vm_state']\n\n            # if the instance is in subtle state, refuse to proceed.\n            if vm_state not in (vm_states.ACTIVE, vm_states.SHUTOFF,\n                                vm_states.STOPPED):\n                raise exception.InstanceNotRunning(instance_id=ec2_instance_id)\n\n            if vm_state in (vm_states.ACTIVE, vm_states.SHUTOFF):\n                restart_instance = True\n                self.compute_api.stop(context, instance)\n\n            # wait instance for really stopped\n            start_time = time.time()\n            while vm_state != vm_states.STOPPED:\n                time.sleep(1)\n                instance = self.compute_api.get(context, instance_id)\n                vm_state = instance['vm_state']\n                # NOTE(yamahata): timeout and error. 1 hour for now for safety.\n                #                 Is it too short/long?\n                #                 Or is there any better way?\n                timeout = 1 * 60 * 60\n                if time.time() > start_time + timeout:\n                    raise exception.EC2APIError(\n                        _('Couldn\\'t stop instance with in %d sec') % timeout)\n\n        src_image = self._get_image(context, instance['image_ref'])\n        properties = src_image['properties']\n        if instance['root_device_name']:\n            properties['root_device_name'] = instance['root_device_name']\n\n        mapping = []\n        bdms = db.block_device_mapping_get_all_by_instance(context,\n                                                           instance_id)\n        for bdm in bdms:\n            if bdm.no_device:\n                continue\n            m = {}\n            for attr in ('device_name', 'snapshot_id', 'volume_id',\n                         'volume_size', 'delete_on_termination', 'no_device',\n                         'virtual_name'):\n                val = getattr(bdm, attr)\n                if val is not None:\n                    m[attr] = val\n\n            volume_id = m.get('volume_id')\n            if m.get('snapshot_id') and volume_id:\n                # create snapshot based on volume_id\n                volume = self.volume_api.get(context, volume_id)\n                # NOTE(yamahata): Should we wait for snapshot creation?\n                #                 Linux LVM snapshot creation completes in\n                #                 short time, it doesn't matter for now.\n                snapshot = self.volume_api.create_snapshot_force(\n                        context, volume, volume['display_name'],\n                        volume['display_description'])\n                m['snapshot_id'] = snapshot['id']\n                del m['volume_id']\n\n            if m:\n                mapping.append(m)\n\n        for m in _properties_get_mappings(properties):\n            virtual_name = m['virtual']\n            if virtual_name in ('ami', 'root'):\n                continue\n\n            assert block_device.is_swap_or_ephemeral(virtual_name)\n            device_name = m['device']\n            if device_name in [b['device_name'] for b in mapping\n                               if not b.get('no_device', False)]:\n                continue\n\n            # NOTE(yamahata): swap and ephemeral devices are specified in\n            #                 AMI, but disabled for this instance by user.\n            #                 So disable those device by no_device.\n            mapping.append({'device_name': device_name, 'no_device': True})\n\n        if mapping:\n            properties['block_device_mapping'] = mapping\n\n        for attr in ('status', 'location', 'id'):\n            src_image.pop(attr, None)\n\n        image_id = self._register_image(context, src_image)\n\n        if restart_instance:\n            self.compute_api.start(context, instance_id=instance_id)\n\n        return {'imageId': image_id}\n", "# Copyright 2011 OpenStack LLC.\n# Copyright 2012 Justin Santa Barbara\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"The security groups extension.\"\"\"\n\nimport urllib\nfrom xml.dom import minidom\n\nfrom webob import exc\nimport webob\n\nfrom nova.api.openstack import common\nfrom nova.api.openstack import extensions\nfrom nova.api.openstack import wsgi\nfrom nova.api.openstack import xmlutil\nfrom nova import compute\nfrom nova import db\nfrom nova import exception\nfrom nova import flags\nfrom nova import log as logging\nfrom nova import quota\nfrom nova import utils\n\n\nLOG = logging.getLogger(__name__)\nFLAGS = flags.FLAGS\nauthorize = extensions.extension_authorizer('compute', 'security_groups')\n\n\ndef make_rule(elem):\n    elem.set('id')\n    elem.set('parent_group_id')\n\n    proto = xmlutil.SubTemplateElement(elem, 'ip_protocol')\n    proto.text = 'ip_protocol'\n\n    from_port = xmlutil.SubTemplateElement(elem, 'from_port')\n    from_port.text = 'from_port'\n\n    to_port = xmlutil.SubTemplateElement(elem, 'to_port')\n    to_port.text = 'to_port'\n\n    group = xmlutil.SubTemplateElement(elem, 'group', selector='group')\n    name = xmlutil.SubTemplateElement(group, 'name')\n    name.text = 'name'\n    tenant_id = xmlutil.SubTemplateElement(group, 'tenant_id')\n    tenant_id.text = 'tenant_id'\n\n    ip_range = xmlutil.SubTemplateElement(elem, 'ip_range',\n                                          selector='ip_range')\n    cidr = xmlutil.SubTemplateElement(ip_range, 'cidr')\n    cidr.text = 'cidr'\n\n\ndef make_sg(elem):\n    elem.set('id')\n    elem.set('tenant_id')\n    elem.set('name')\n\n    desc = xmlutil.SubTemplateElement(elem, 'description')\n    desc.text = 'description'\n\n    rules = xmlutil.SubTemplateElement(elem, 'rules')\n    rule = xmlutil.SubTemplateElement(rules, 'rule', selector='rules')\n    make_rule(rule)\n\n\nsg_nsmap = {None: wsgi.XMLNS_V11}\n\n\nclass SecurityGroupRuleTemplate(xmlutil.TemplateBuilder):\n    def construct(self):\n        root = xmlutil.TemplateElement('security_group_rule',\n                                       selector='security_group_rule')\n        make_rule(root)\n        return xmlutil.MasterTemplate(root, 1, nsmap=sg_nsmap)\n\n\nclass SecurityGroupTemplate(xmlutil.TemplateBuilder):\n    def construct(self):\n        root = xmlutil.TemplateElement('security_group',\n                                       selector='security_group')\n        make_sg(root)\n        return xmlutil.MasterTemplate(root, 1, nsmap=sg_nsmap)\n\n\nclass SecurityGroupsTemplate(xmlutil.TemplateBuilder):\n    def construct(self):\n        root = xmlutil.TemplateElement('security_groups')\n        elem = xmlutil.SubTemplateElement(root, 'security_group',\n                                          selector='security_groups')\n        make_sg(elem)\n        return xmlutil.MasterTemplate(root, 1, nsmap=sg_nsmap)\n\n\nclass SecurityGroupXMLDeserializer(wsgi.MetadataXMLDeserializer):\n    \"\"\"\n    Deserializer to handle xml-formatted security group requests.\n    \"\"\"\n    def default(self, string):\n        \"\"\"Deserialize an xml-formatted security group create request\"\"\"\n        dom = minidom.parseString(string)\n        security_group = {}\n        sg_node = self.find_first_child_named(dom,\n                                               'security_group')\n        if sg_node is not None:\n            if sg_node.hasAttribute('name'):\n                security_group['name'] = sg_node.getAttribute('name')\n            desc_node = self.find_first_child_named(sg_node,\n                                                     \"description\")\n            if desc_node:\n                security_group['description'] = self.extract_text(desc_node)\n        return {'body': {'security_group': security_group}}\n\n\nclass SecurityGroupRulesXMLDeserializer(wsgi.MetadataXMLDeserializer):\n    \"\"\"\n    Deserializer to handle xml-formatted security group requests.\n    \"\"\"\n\n    def default(self, string):\n        \"\"\"Deserialize an xml-formatted security group create request\"\"\"\n        dom = minidom.parseString(string)\n        security_group_rule = self._extract_security_group_rule(dom)\n        return {'body': {'security_group_rule': security_group_rule}}\n\n    def _extract_security_group_rule(self, node):\n        \"\"\"Marshal the security group rule attribute of a parsed request\"\"\"\n        sg_rule = {}\n        sg_rule_node = self.find_first_child_named(node,\n                                                   'security_group_rule')\n        if sg_rule_node is not None:\n            ip_protocol_node = self.find_first_child_named(sg_rule_node,\n                                                           \"ip_protocol\")\n            if ip_protocol_node is not None:\n                sg_rule['ip_protocol'] = self.extract_text(ip_protocol_node)\n\n            from_port_node = self.find_first_child_named(sg_rule_node,\n                                                         \"from_port\")\n            if from_port_node is not None:\n                sg_rule['from_port'] = self.extract_text(from_port_node)\n\n            to_port_node = self.find_first_child_named(sg_rule_node, \"to_port\")\n            if to_port_node is not None:\n                sg_rule['to_port'] = self.extract_text(to_port_node)\n\n            parent_group_id_node = self.find_first_child_named(sg_rule_node,\n                                                            \"parent_group_id\")\n            if parent_group_id_node is not None:\n                sg_rule['parent_group_id'] = self.extract_text(\n                                                         parent_group_id_node)\n\n            group_id_node = self.find_first_child_named(sg_rule_node,\n                                                        \"group_id\")\n            if group_id_node is not None:\n                sg_rule['group_id'] = self.extract_text(group_id_node)\n\n            cidr_node = self.find_first_child_named(sg_rule_node, \"cidr\")\n            if cidr_node is not None:\n                sg_rule['cidr'] = self.extract_text(cidr_node)\n\n        return sg_rule\n\n\nclass SecurityGroupControllerBase(object):\n    \"\"\"Base class for Security Group controllers.\"\"\"\n\n    def __init__(self):\n        self.compute_api = compute.API()\n        self.sgh = utils.import_object(FLAGS.security_group_handler)\n\n    def _format_security_group_rule(self, context, rule):\n        sg_rule = {}\n        sg_rule['id'] = rule.id\n        sg_rule['parent_group_id'] = rule.parent_group_id\n        sg_rule['ip_protocol'] = rule.protocol\n        sg_rule['from_port'] = rule.from_port\n        sg_rule['to_port'] = rule.to_port\n        sg_rule['group'] = {}\n        sg_rule['ip_range'] = {}\n        if rule.group_id:\n            source_group = db.security_group_get(context, rule.group_id)\n            sg_rule['group'] = {'name': source_group.name,\n                             'tenant_id': source_group.project_id}\n        else:\n            sg_rule['ip_range'] = {'cidr': rule.cidr}\n        return sg_rule\n\n    def _format_security_group(self, context, group):\n        security_group = {}\n        security_group['id'] = group.id\n        security_group['description'] = group.description\n        security_group['name'] = group.name\n        security_group['tenant_id'] = group.project_id\n        security_group['rules'] = []\n        for rule in group.rules:\n            security_group['rules'] += [self._format_security_group_rule(\n                    context, rule)]\n        return security_group\n\n\nclass SecurityGroupController(SecurityGroupControllerBase):\n    \"\"\"The Security group API controller for the OpenStack API.\"\"\"\n\n    def _get_security_group(self, context, id):\n        try:\n            id = int(id)\n            security_group = db.security_group_get(context, id)\n        except ValueError:\n            msg = _(\"Security group id should be integer\")\n            raise exc.HTTPBadRequest(explanation=msg)\n        except exception.NotFound as exp:\n            raise exc.HTTPNotFound(explanation=unicode(exp))\n        return security_group\n\n    @wsgi.serializers(xml=SecurityGroupTemplate)\n    def show(self, req, id):\n        \"\"\"Return data about the given security group.\"\"\"\n        context = req.environ['nova.context']\n        authorize(context)\n        security_group = self._get_security_group(context, id)\n        return {'security_group': self._format_security_group(context,\n                                                              security_group)}\n\n    def delete(self, req, id):\n        \"\"\"Delete a security group.\"\"\"\n        context = req.environ['nova.context']\n        authorize(context)\n        security_group = self._get_security_group(context, id)\n        if db.security_group_in_use(context, security_group.id):\n            msg = _(\"Security group is still in use\")\n            raise exc.HTTPBadRequest(explanation=msg)\n        LOG.audit(_(\"Delete security group %s\"), id, context=context)\n        db.security_group_destroy(context, security_group.id)\n        self.sgh.trigger_security_group_destroy_refresh(\n            context, security_group.id)\n\n        return webob.Response(status_int=202)\n\n    @wsgi.serializers(xml=SecurityGroupsTemplate)\n    def index(self, req):\n        \"\"\"Returns a list of security groups\"\"\"\n        context = req.environ['nova.context']\n        authorize(context)\n\n        self.compute_api.ensure_default_security_group(context)\n        groups = db.security_group_get_by_project(context,\n                                                  context.project_id)\n        limited_list = common.limited(groups, req)\n        result = [self._format_security_group(context, group)\n                     for group in limited_list]\n\n        return {'security_groups':\n                list(sorted(result,\n                            key=lambda k: (k['tenant_id'], k['name'])))}\n\n    @wsgi.serializers(xml=SecurityGroupTemplate)\n    @wsgi.deserializers(xml=SecurityGroupXMLDeserializer)\n    def create(self, req, body):\n        \"\"\"Creates a new security group.\"\"\"\n        context = req.environ['nova.context']\n        authorize(context)\n        if not body:\n            raise exc.HTTPUnprocessableEntity()\n\n        security_group = body.get('security_group', None)\n\n        if security_group is None:\n            raise exc.HTTPUnprocessableEntity()\n\n        group_name = security_group.get('name', None)\n        group_description = security_group.get('description', None)\n\n        self._validate_security_group_property(group_name, \"name\")\n        self._validate_security_group_property(group_description,\n                                               \"description\")\n        group_name = group_name.strip()\n        group_description = group_description.strip()\n\n        if quota.allowed_security_groups(context, 1) < 1:\n            msg = _(\"Quota exceeded, too many security groups.\")\n            raise exc.HTTPBadRequest(explanation=msg)\n\n        LOG.audit(_(\"Create Security Group %s\"), group_name, context=context)\n        self.compute_api.ensure_default_security_group(context)\n        if db.security_group_exists(context, context.project_id, group_name):\n            msg = _('Security group %s already exists') % group_name\n            raise exc.HTTPBadRequest(explanation=msg)\n\n        group = {'user_id': context.user_id,\n                 'project_id': context.project_id,\n                 'name': group_name,\n                 'description': group_description}\n        group_ref = db.security_group_create(context, group)\n        self.sgh.trigger_security_group_create_refresh(context, group)\n\n        return {'security_group': self._format_security_group(context,\n                                                                 group_ref)}\n\n    def _validate_security_group_property(self, value, typ):\n        \"\"\" typ will be either 'name' or 'description',\n            depending on the caller\n        \"\"\"\n        try:\n            val = value.strip()\n        except AttributeError:\n            msg = _(\"Security group %s is not a string or unicode\") % typ\n            raise exc.HTTPBadRequest(explanation=msg)\n        if not val:\n            msg = _(\"Security group %s cannot be empty.\") % typ\n            raise exc.HTTPBadRequest(explanation=msg)\n        if len(val) > 255:\n            msg = _(\"Security group %s should not be greater \"\n                            \"than 255 characters.\") % typ\n            raise exc.HTTPBadRequest(explanation=msg)\n\n\nclass SecurityGroupRulesController(SecurityGroupControllerBase):\n\n    @wsgi.serializers(xml=SecurityGroupRuleTemplate)\n    @wsgi.deserializers(xml=SecurityGroupRulesXMLDeserializer)\n    def create(self, req, body):\n        context = req.environ['nova.context']\n        authorize(context)\n\n        if not body:\n            raise exc.HTTPUnprocessableEntity()\n\n        if not 'security_group_rule' in body:\n            raise exc.HTTPUnprocessableEntity()\n\n        self.compute_api.ensure_default_security_group(context)\n\n        sg_rule = body['security_group_rule']\n        parent_group_id = sg_rule.get('parent_group_id', None)\n        try:\n            parent_group_id = int(parent_group_id)\n            security_group = db.security_group_get(context, parent_group_id)\n        except ValueError:\n            msg = _(\"Parent group id is not integer\")\n            raise exc.HTTPBadRequest(explanation=msg)\n        except exception.NotFound as exp:\n            msg = _(\"Security group (%s) not found\") % parent_group_id\n            raise exc.HTTPNotFound(explanation=msg)\n\n        msg = _(\"Authorize security group ingress %s\")\n        LOG.audit(msg, security_group['name'], context=context)\n\n        try:\n            values = self._rule_args_to_dict(context,\n                              to_port=sg_rule.get('to_port'),\n                              from_port=sg_rule.get('from_port'),\n                              parent_group_id=sg_rule.get('parent_group_id'),\n                              ip_protocol=sg_rule.get('ip_protocol'),\n                              cidr=sg_rule.get('cidr'),\n                              group_id=sg_rule.get('group_id'))\n        except Exception as exp:\n            raise exc.HTTPBadRequest(explanation=unicode(exp))\n\n        if values is None:\n            msg = _(\"Not enough parameters to build a \"\n                                       \"valid rule.\")\n            raise exc.HTTPBadRequest(explanation=msg)\n\n        values['parent_group_id'] = security_group.id\n\n        if self._security_group_rule_exists(security_group, values):\n            msg = _('This rule already exists in group %s') % parent_group_id\n            raise exc.HTTPBadRequest(explanation=msg)\n\n        allowed = quota.allowed_security_group_rules(context,\n                                                   parent_group_id,\n                                                   1)\n        if allowed < 1:\n            msg = _(\"Quota exceeded, too many security group rules.\")\n            raise exc.HTTPBadRequest(explanation=msg)\n\n        security_group_rule = db.security_group_rule_create(context, values)\n        self.sgh.trigger_security_group_rule_create_refresh(\n            context, [security_group_rule['id']])\n        self.compute_api.trigger_security_group_rules_refresh(context,\n                                    security_group_id=security_group['id'])\n\n        return {\"security_group_rule\": self._format_security_group_rule(\n                                                        context,\n                                                        security_group_rule)}\n\n    def _security_group_rule_exists(self, security_group, values):\n        \"\"\"Indicates whether the specified rule values are already\n           defined in the given security group.\n        \"\"\"\n        for rule in security_group.rules:\n            is_duplicate = True\n            keys = ('group_id', 'cidr', 'from_port', 'to_port', 'protocol')\n            for key in keys:\n                if rule.get(key) != values.get(key):\n                    is_duplicate = False\n                    break\n            if is_duplicate:\n                return True\n        return False\n\n    def _rule_args_to_dict(self, context, to_port=None, from_port=None,\n                                  parent_group_id=None, ip_protocol=None,\n                                  cidr=None, group_id=None):\n        values = {}\n\n        if group_id is not None:\n            try:\n                parent_group_id = int(parent_group_id)\n                group_id = int(group_id)\n            except ValueError:\n                msg = _(\"Parent or group id is not integer\")\n                raise exception.InvalidInput(reason=msg)\n\n            values['group_id'] = group_id\n            #check if groupId exists\n            db.security_group_get(context, group_id)\n        elif cidr:\n            # If this fails, it throws an exception. This is what we want.\n            try:\n                cidr = urllib.unquote(cidr).decode()\n            except Exception:\n                raise exception.InvalidCidr(cidr=cidr)\n\n            if not utils.is_valid_cidr(cidr):\n                # Raise exception for non-valid address\n                raise exception.InvalidCidr(cidr=cidr)\n\n            values['cidr'] = cidr\n        else:\n            values['cidr'] = '0.0.0.0/0'\n\n        if group_id:\n            # Open everything if an explicit port range or type/code are not\n            # specified, but only if a source group was specified.\n            ip_proto_upper = ip_protocol.upper() if ip_protocol else ''\n            if (ip_proto_upper == 'ICMP' and\n                from_port is None and to_port is None):\n                from_port = -1\n                to_port = -1\n            elif (ip_proto_upper in ['TCP', 'UDP'] and from_port is None\n                  and to_port is None):\n                from_port = 1\n                to_port = 65535\n\n        if ip_protocol and from_port is not None and to_port is not None:\n\n            ip_protocol = str(ip_protocol)\n            try:\n                from_port = int(from_port)\n                to_port = int(to_port)\n            except ValueError:\n                if ip_protocol.upper() == 'ICMP':\n                    raise exception.InvalidInput(reason=\"Type and\"\n                         \" Code must be integers for ICMP protocol type\")\n                else:\n                    raise exception.InvalidInput(reason=\"To and From ports \"\n                          \"must be integers\")\n\n            if ip_protocol.upper() not in ['TCP', 'UDP', 'ICMP']:\n                raise exception.InvalidIpProtocol(protocol=ip_protocol)\n\n            # Verify that from_port must always be less than\n            # or equal to to_port\n            if (ip_protocol.upper() in ['TCP', 'UDP'] and\n                from_port > to_port):\n                raise exception.InvalidPortRange(from_port=from_port,\n                      to_port=to_port, msg=\"Former value cannot\"\n                                            \" be greater than the later\")\n\n            # Verify valid TCP, UDP port ranges\n            if (ip_protocol.upper() in ['TCP', 'UDP'] and\n                (from_port < 1 or to_port > 65535)):\n                raise exception.InvalidPortRange(from_port=from_port,\n                      to_port=to_port, msg=\"Valid TCP ports should\"\n                                           \" be between 1-65535\")\n\n            # Verify ICMP type and code\n            if (ip_protocol.upper() == \"ICMP\" and\n                (from_port < -1 or from_port > 255 or\n                to_port < -1 or to_port > 255)):\n                raise exception.InvalidPortRange(from_port=from_port,\n                      to_port=to_port, msg=\"For ICMP, the\"\n                                           \" type:code must be valid\")\n\n            values['protocol'] = ip_protocol.lower()\n            values['from_port'] = from_port\n            values['to_port'] = to_port\n        else:\n            # If cidr based filtering, protocol and ports are mandatory\n            if 'cidr' in values:\n                return None\n\n        return values\n\n    def delete(self, req, id):\n        context = req.environ['nova.context']\n        authorize(context)\n\n        self.compute_api.ensure_default_security_group(context)\n        try:\n            id = int(id)\n            rule = db.security_group_rule_get(context, id)\n        except ValueError:\n            msg = _(\"Rule id is not integer\")\n            raise exc.HTTPBadRequest(explanation=msg)\n        except exception.NotFound:\n            msg = _(\"Rule (%s) not found\") % id\n            raise exc.HTTPNotFound(explanation=msg)\n\n        group_id = rule.parent_group_id\n        self.compute_api.ensure_default_security_group(context)\n        security_group = db.security_group_get(context, group_id)\n\n        msg = _(\"Revoke security group ingress %s\")\n        LOG.audit(msg, security_group['name'], context=context)\n\n        db.security_group_rule_destroy(context, rule['id'])\n        self.sgh.trigger_security_group_rule_destroy_refresh(\n            context, [rule['id']])\n        self.compute_api.trigger_security_group_rules_refresh(context,\n                                    security_group_id=security_group['id'])\n\n        return webob.Response(status_int=202)\n\n\nclass ServerSecurityGroupController(SecurityGroupControllerBase):\n\n    @wsgi.serializers(xml=SecurityGroupsTemplate)\n    def index(self, req, server_id):\n        \"\"\"Returns a list of security groups for the given instance.\"\"\"\n        context = req.environ['nova.context']\n        authorize(context)\n\n        self.compute_api.ensure_default_security_group(context)\n\n        try:\n            instance = self.compute_api.get(context, server_id)\n            groups = db.security_group_get_by_instance(context,\n                                                       instance['id'])\n        except exception.ApiError, e:\n            raise webob.exc.HTTPBadRequest(explanation=e.message)\n        except exception.NotAuthorized, e:\n            raise webob.exc.HTTPUnauthorized()\n\n        result = [self._format_security_group(context, group)\n                    for group in groups]\n\n        return {'security_groups':\n                list(sorted(result,\n                            key=lambda k: (k['tenant_id'], k['name'])))}\n\n\nclass SecurityGroupActionController(wsgi.Controller):\n    def __init__(self, *args, **kwargs):\n        super(SecurityGroupActionController, self).__init__(*args, **kwargs)\n        self.compute_api = compute.API()\n        self.sgh = utils.import_object(FLAGS.security_group_handler)\n\n    @wsgi.action('addSecurityGroup')\n    def _addSecurityGroup(self, req, id, body):\n        context = req.environ['nova.context']\n        authorize(context)\n\n        try:\n            body = body['addSecurityGroup']\n            group_name = body['name']\n        except TypeError:\n            msg = _(\"Missing parameter dict\")\n            raise webob.exc.HTTPBadRequest(explanation=msg)\n        except KeyError:\n            msg = _(\"Security group not specified\")\n            raise webob.exc.HTTPBadRequest(explanation=msg)\n\n        if not group_name or group_name.strip() == '':\n            msg = _(\"Security group name cannot be empty\")\n            raise webob.exc.HTTPBadRequest(explanation=msg)\n\n        try:\n            instance = self.compute_api.get(context, id)\n            self.compute_api.add_security_group(context, instance, group_name)\n            self.sgh.trigger_instance_add_security_group_refresh(\n                context, instance, group_name)\n        except exception.SecurityGroupNotFound as exp:\n            raise exc.HTTPNotFound(explanation=unicode(exp))\n        except exception.InstanceNotFound as exp:\n            raise exc.HTTPNotFound(explanation=unicode(exp))\n        except exception.Invalid as exp:\n            raise exc.HTTPBadRequest(explanation=unicode(exp))\n\n        return webob.Response(status_int=202)\n\n    @wsgi.action('removeSecurityGroup')\n    def _removeSecurityGroup(self, req, id, body):\n        context = req.environ['nova.context']\n        authorize(context)\n\n        try:\n            body = body['removeSecurityGroup']\n            group_name = body['name']\n        except TypeError:\n            msg = _(\"Missing parameter dict\")\n            raise webob.exc.HTTPBadRequest(explanation=msg)\n        except KeyError:\n            msg = _(\"Security group not specified\")\n            raise webob.exc.HTTPBadRequest(explanation=msg)\n\n        if not group_name or group_name.strip() == '':\n            msg = _(\"Security group name cannot be empty\")\n            raise webob.exc.HTTPBadRequest(explanation=msg)\n\n        try:\n            instance = self.compute_api.get(context, id)\n            self.compute_api.remove_security_group(context, instance,\n                                                   group_name)\n            self.sgh.trigger_instance_remove_security_group_refresh(\n                context, instance, group_name)\n        except exception.SecurityGroupNotFound as exp:\n            raise exc.HTTPNotFound(explanation=unicode(exp))\n        except exception.InstanceNotFound as exp:\n            raise exc.HTTPNotFound(explanation=unicode(exp))\n        except exception.Invalid as exp:\n            raise exc.HTTPBadRequest(explanation=unicode(exp))\n\n        return webob.Response(status_int=202)\n\n\nclass Security_groups(extensions.ExtensionDescriptor):\n    \"\"\"Security group support\"\"\"\n\n    name = \"SecurityGroups\"\n    alias = \"security_groups\"\n    namespace = \"http://docs.openstack.org/compute/ext/securitygroups/api/v1.1\"\n    updated = \"2011-07-21T00:00:00+00:00\"\n\n    def get_controller_extensions(self):\n        controller = SecurityGroupActionController()\n        extension = extensions.ControllerExtension(self, 'servers', controller)\n        return [extension]\n\n    def get_resources(self):\n        resources = []\n\n        res = extensions.ResourceExtension('os-security-groups',\n                                controller=SecurityGroupController())\n\n        resources.append(res)\n\n        res = extensions.ResourceExtension('os-security-group-rules',\n                                controller=SecurityGroupRulesController())\n        resources.append(res)\n\n        res = extensions.ResourceExtension(\n            'os-security-groups',\n            controller=ServerSecurityGroupController(),\n            parent=dict(member_name='server', collection_name='servers'))\n        resources.append(res)\n\n        return resources\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2011 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n# Copyright (c) 2011 Citrix Systems, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nfrom nova import context\nfrom nova import db\nfrom nova import flags\nfrom nova import log as logging\nfrom nova.openstack.common import cfg\nfrom nova import utils\nfrom nova.virt import netutils\n\n\nLOG = logging.getLogger(__name__)\n\nallow_same_net_traffic_opt = cfg.BoolOpt('allow_same_net_traffic',\n        default=True,\n        help='Whether to allow network traffic from same network')\n\nFLAGS = flags.FLAGS\nFLAGS.register_opt(allow_same_net_traffic_opt)\n\n\nclass FirewallDriver(object):\n    \"\"\" Firewall Driver base class.\n\n        Defines methods that any driver providing security groups\n        and provider fireall functionality should implement.\n    \"\"\"\n    def prepare_instance_filter(self, instance, network_info):\n        \"\"\"Prepare filters for the instance.\n        At this point, the instance isn't running yet.\"\"\"\n        raise NotImplementedError()\n\n    def unfilter_instance(self, instance, network_info):\n        \"\"\"Stop filtering instance\"\"\"\n        raise NotImplementedError()\n\n    def apply_instance_filter(self, instance, network_info):\n        \"\"\"Apply instance filter.\n\n        Once this method returns, the instance should be firewalled\n        appropriately. This method should as far as possible be a\n        no-op. It's vastly preferred to get everything set up in\n        prepare_instance_filter.\n        \"\"\"\n        raise NotImplementedError()\n\n    def refresh_security_group_rules(self, security_group_id):\n        \"\"\"Refresh security group rules from data store\n\n        Gets called when a rule has been added to or removed from\n        the security group.\"\"\"\n        raise NotImplementedError()\n\n    def refresh_security_group_members(self, security_group_id):\n        \"\"\"Refresh security group members from data store\n\n        Gets called when an instance gets added to or removed from\n        the security group.\"\"\"\n        raise NotImplementedError()\n\n    def refresh_provider_fw_rules(self):\n        \"\"\"Refresh common rules for all hosts/instances from data store.\n\n        Gets called when a rule has been added to or removed from\n        the list of rules (via admin api).\n\n        \"\"\"\n        raise NotImplementedError()\n\n    def setup_basic_filtering(self, instance, network_info):\n        \"\"\"Create rules to block spoofing and allow dhcp.\n\n        This gets called when spawning an instance, before\n        :py:meth:`prepare_instance_filter`.\n\n        \"\"\"\n        raise NotImplementedError()\n\n    def instance_filter_exists(self, instance, network_info):\n        \"\"\"Check nova-instance-instance-xxx exists\"\"\"\n        raise NotImplementedError()\n\n\nclass IptablesFirewallDriver(FirewallDriver):\n    \"\"\"Driver which enforces security groups through iptables rules.\"\"\"\n\n    def __init__(self, **kwargs):\n        from nova.network import linux_net\n        self.iptables = linux_net.iptables_manager\n        self.instances = {}\n        self.network_infos = {}\n        self.basicly_filtered = False\n\n        self.iptables.ipv4['filter'].add_chain('sg-fallback')\n        self.iptables.ipv4['filter'].add_rule('sg-fallback', '-j DROP')\n        self.iptables.ipv6['filter'].add_chain('sg-fallback')\n        self.iptables.ipv6['filter'].add_rule('sg-fallback', '-j DROP')\n\n    def setup_basic_filtering(self, instance, network_info):\n        pass\n\n    def apply_instance_filter(self, instance, network_info):\n        \"\"\"No-op. Everything is done in prepare_instance_filter.\"\"\"\n        pass\n\n    def unfilter_instance(self, instance, network_info):\n        if self.instances.pop(instance['id'], None):\n            # NOTE(vish): use the passed info instead of the stored info\n            self.network_infos.pop(instance['id'])\n            self.remove_filters_for_instance(instance)\n            self.iptables.apply()\n        else:\n            LOG.info(_('Attempted to unfilter instance %s which is not '\n                     'filtered'), instance['id'])\n\n    def prepare_instance_filter(self, instance, network_info):\n        self.instances[instance['id']] = instance\n        self.network_infos[instance['id']] = network_info\n        self.add_filters_for_instance(instance)\n        LOG.debug(_('Filters added to instance %s'), instance['uuid'])\n        self.refresh_provider_fw_rules()\n        LOG.debug(_('Provider Firewall Rules refreshed'))\n        self.iptables.apply()\n\n    def _create_filter(self, ips, chain_name):\n        return ['-d %s -j $%s' % (ip, chain_name) for ip in ips]\n\n    def _filters_for_instance(self, chain_name, network_info):\n        \"\"\"Creates a rule corresponding to each ip that defines a\n             jump to the corresponding instance - chain for all the traffic\n             destined to that ip.\"\"\"\n        ips_v4 = [ip['ip'] for (_n, mapping) in network_info\n                 for ip in mapping['ips']]\n        ipv4_rules = self._create_filter(ips_v4, chain_name)\n\n        ipv6_rules = []\n        if FLAGS.use_ipv6:\n            ips_v6 = [ip['ip'] for (_n, mapping) in network_info\n                     for ip in mapping['ip6s']]\n            ipv6_rules = self._create_filter(ips_v6, chain_name)\n\n        return ipv4_rules, ipv6_rules\n\n    def _add_filters(self, chain_name, ipv4_rules, ipv6_rules):\n        for rule in ipv4_rules:\n            self.iptables.ipv4['filter'].add_rule(chain_name, rule)\n\n        if FLAGS.use_ipv6:\n            for rule in ipv6_rules:\n                self.iptables.ipv6['filter'].add_rule(chain_name, rule)\n\n    def add_filters_for_instance(self, instance):\n        network_info = self.network_infos[instance['id']]\n        chain_name = self._instance_chain_name(instance)\n        if FLAGS.use_ipv6:\n            self.iptables.ipv6['filter'].add_chain(chain_name)\n        self.iptables.ipv4['filter'].add_chain(chain_name)\n        ipv4_rules, ipv6_rules = self._filters_for_instance(chain_name,\n                                                            network_info)\n        self._add_filters('local', ipv4_rules, ipv6_rules)\n        ipv4_rules, ipv6_rules = self.instance_rules(instance, network_info)\n        self._add_filters(chain_name, ipv4_rules, ipv6_rules)\n\n    def remove_filters_for_instance(self, instance):\n        chain_name = self._instance_chain_name(instance)\n\n        self.iptables.ipv4['filter'].remove_chain(chain_name)\n        if FLAGS.use_ipv6:\n            self.iptables.ipv6['filter'].remove_chain(chain_name)\n\n    @staticmethod\n    def _security_group_chain_name(security_group_id):\n        return 'nova-sg-%s' % (security_group_id,)\n\n    def _instance_chain_name(self, instance):\n        return 'inst-%s' % (instance['id'],)\n\n    def _do_basic_rules(self, ipv4_rules, ipv6_rules, network_info):\n        # Always drop invalid packets\n        ipv4_rules += ['-m state --state ' 'INVALID -j DROP']\n        ipv6_rules += ['-m state --state ' 'INVALID -j DROP']\n\n        # Allow established connections\n        ipv4_rules += ['-m state --state ESTABLISHED,RELATED -j ACCEPT']\n        ipv6_rules += ['-m state --state ESTABLISHED,RELATED -j ACCEPT']\n\n        # Pass through provider-wide drops\n        ipv4_rules += ['-j $provider']\n        ipv6_rules += ['-j $provider']\n\n    def _do_dhcp_rules(self, ipv4_rules, network_info):\n        dhcp_servers = [info['dhcp_server'] for (_n, info) in network_info]\n\n        for dhcp_server in dhcp_servers:\n            ipv4_rules.append('-s %s -p udp --sport 67 --dport 68 '\n                              '-j ACCEPT' % (dhcp_server,))\n\n    def _do_project_network_rules(self, ipv4_rules, ipv6_rules, network_info):\n        cidrs = [network['cidr'] for (network, _i) in network_info]\n        for cidr in cidrs:\n            ipv4_rules.append('-s %s -j ACCEPT' % (cidr,))\n        if FLAGS.use_ipv6:\n            cidrv6s = [network['cidr_v6'] for (network, _i) in\n                       network_info]\n\n            for cidrv6 in cidrv6s:\n                ipv6_rules.append('-s %s -j ACCEPT' % (cidrv6,))\n\n    def _do_ra_rules(self, ipv6_rules, network_info):\n        gateways_v6 = [mapping['gateway_v6'] for (_n, mapping) in\n                       network_info]\n        for gateway_v6 in gateways_v6:\n            ipv6_rules.append(\n                    '-s %s/128 -p icmpv6 -j ACCEPT' % (gateway_v6,))\n\n    def _build_icmp_rule(self, rule, version):\n        icmp_type = rule.from_port\n        icmp_code = rule.to_port\n\n        if icmp_type == -1:\n            icmp_type_arg = None\n        else:\n            icmp_type_arg = '%s' % icmp_type\n            if not icmp_code == -1:\n                icmp_type_arg += '/%s' % icmp_code\n\n        if icmp_type_arg:\n            if version == 4:\n                return ['-m', 'icmp', '--icmp-type', icmp_type_arg]\n            elif version == 6:\n                return ['-m', 'icmp6', '--icmpv6-type', icmp_type_arg]\n        # return empty list if icmp_type == -1\n        return []\n\n    def _build_tcp_udp_rule(self, rule, version):\n        if rule.from_port == rule.to_port:\n            return ['--dport', '%s' % (rule.from_port,)]\n        else:\n            return ['-m', 'multiport',\n                    '--dports', '%s:%s' % (rule.from_port,\n                                           rule.to_port)]\n\n    def instance_rules(self, instance, network_info):\n        ctxt = context.get_admin_context()\n\n        ipv4_rules = []\n        ipv6_rules = []\n\n        # Initialize with basic rules\n        self._do_basic_rules(ipv4_rules, ipv6_rules, network_info)\n        # Set up rules to allow traffic to/from DHCP server\n        self._do_dhcp_rules(ipv4_rules, network_info)\n\n        #Allow project network traffic\n        if FLAGS.allow_same_net_traffic:\n            self._do_project_network_rules(ipv4_rules, ipv6_rules,\n                                           network_info)\n        # We wrap these in FLAGS.use_ipv6 because they might cause\n        # a DB lookup. The other ones are just list operations, so\n        # they're not worth the clutter.\n        if FLAGS.use_ipv6:\n            # Allow RA responses\n            self._do_ra_rules(ipv6_rules, network_info)\n\n        security_groups = db.security_group_get_by_instance(ctxt,\n                                                            instance['id'])\n\n        # then, security group chains and rules\n        for security_group in security_groups:\n            rules = db.security_group_rule_get_by_security_group(ctxt,\n                                                          security_group['id'])\n\n            for rule in rules:\n                LOG.debug(_('Adding security group rule: %r'), rule)\n\n                if not rule.cidr:\n                    version = 4\n                else:\n                    version = netutils.get_ip_version(rule.cidr)\n\n                if version == 4:\n                    fw_rules = ipv4_rules\n                else:\n                    fw_rules = ipv6_rules\n\n                protocol = rule.protocol.lower()\n                if version == 6 and protocol == 'icmp':\n                    protocol = 'icmpv6'\n\n                args = ['-j ACCEPT']\n                if protocol:\n                    args += ['-p', protocol]\n\n                if protocol in ['udp', 'tcp']:\n                    args += self._build_tcp_udp_rule(rule, version)\n                elif protocol == 'icmp':\n                    args += self._build_icmp_rule(rule, version)\n                if rule.cidr:\n                    LOG.info('Using cidr %r', rule.cidr)\n                    args += ['-s', rule.cidr]\n                    fw_rules += [' '.join(args)]\n                else:\n                    if rule['grantee_group']:\n                        # FIXME(jkoelker) This needs to be ported up into\n                        #                 the compute manager which already\n                        #                 has access to a nw_api handle,\n                        #                 and should be the only one making\n                        #                 making rpc calls.\n                        import nova.network\n                        nw_api = nova.network.API()\n                        for instance in rule['grantee_group']['instances']:\n                            LOG.info('instance: %r', instance)\n                            nw_info = nw_api.get_instance_nw_info(ctxt,\n                                                                  instance)\n\n                            ips = [ip['address']\n                                for ip in nw_info.fixed_ips()\n                                    if ip['version'] == version]\n\n                            LOG.info('ips: %r', ips)\n                            for ip in ips:\n                                subrule = args + ['-s %s' % ip]\n                                fw_rules += [' '.join(subrule)]\n\n                LOG.info('Using fw_rules: %r', fw_rules)\n        ipv4_rules += ['-j $sg-fallback']\n        ipv6_rules += ['-j $sg-fallback']\n\n        return ipv4_rules, ipv6_rules\n\n    def instance_filter_exists(self, instance, network_info):\n        pass\n\n    def refresh_security_group_members(self, security_group):\n        self.do_refresh_security_group_rules(security_group)\n        self.iptables.apply()\n\n    def refresh_security_group_rules(self, security_group):\n        self.do_refresh_security_group_rules(security_group)\n        self.iptables.apply()\n\n    @utils.synchronized('iptables', external=True)\n    def do_refresh_security_group_rules(self, security_group):\n        for instance in self.instances.values():\n            self.remove_filters_for_instance(instance)\n            self.add_filters_for_instance(instance)\n\n    def refresh_provider_fw_rules(self):\n        \"\"\"See :class:`FirewallDriver` docs.\"\"\"\n        self._do_refresh_provider_fw_rules()\n        self.iptables.apply()\n\n    @utils.synchronized('iptables', external=True)\n    def _do_refresh_provider_fw_rules(self):\n        \"\"\"Internal, synchronized version of refresh_provider_fw_rules.\"\"\"\n        self._purge_provider_fw_rules()\n        self._build_provider_fw_rules()\n\n    def _purge_provider_fw_rules(self):\n        \"\"\"Remove all rules from the provider chains.\"\"\"\n        self.iptables.ipv4['filter'].empty_chain('provider')\n        if FLAGS.use_ipv6:\n            self.iptables.ipv6['filter'].empty_chain('provider')\n\n    def _build_provider_fw_rules(self):\n        \"\"\"Create all rules for the provider IP DROPs.\"\"\"\n        self.iptables.ipv4['filter'].add_chain('provider')\n        if FLAGS.use_ipv6:\n            self.iptables.ipv6['filter'].add_chain('provider')\n        ipv4_rules, ipv6_rules = self._provider_rules()\n        for rule in ipv4_rules:\n            self.iptables.ipv4['filter'].add_rule('provider', rule)\n\n        if FLAGS.use_ipv6:\n            for rule in ipv6_rules:\n                self.iptables.ipv6['filter'].add_rule('provider', rule)\n\n    @staticmethod\n    def _provider_rules():\n        \"\"\"Generate a list of rules from provider for IP4 & IP6.\"\"\"\n        ctxt = context.get_admin_context()\n        ipv4_rules = []\n        ipv6_rules = []\n        rules = db.provider_fw_rule_get_all(ctxt)\n        for rule in rules:\n            LOG.debug(_('Adding provider rule: %s'), rule['cidr'])\n            version = netutils.get_ip_version(rule['cidr'])\n            if version == 4:\n                fw_rules = ipv4_rules\n            else:\n                fw_rules = ipv6_rules\n\n            protocol = rule['protocol']\n            if version == 6 and protocol == 'icmp':\n                protocol = 'icmpv6'\n\n            args = ['-p', protocol, '-s', rule['cidr']]\n\n            if protocol in ['udp', 'tcp']:\n                if rule['from_port'] == rule['to_port']:\n                    args += ['--dport', '%s' % (rule['from_port'],)]\n                else:\n                    args += ['-m', 'multiport',\n                             '--dports', '%s:%s' % (rule['from_port'],\n                                                    rule['to_port'])]\n            elif protocol == 'icmp':\n                icmp_type = rule['from_port']\n                icmp_code = rule['to_port']\n\n                if icmp_type == -1:\n                    icmp_type_arg = None\n                else:\n                    icmp_type_arg = '%s' % icmp_type\n                    if not icmp_code == -1:\n                        icmp_type_arg += '/%s' % icmp_code\n\n                if icmp_type_arg:\n                    if version == 4:\n                        args += ['-m', 'icmp', '--icmp-type',\n                                 icmp_type_arg]\n                    elif version == 6:\n                        args += ['-m', 'icmp6', '--icmpv6-type',\n                                 icmp_type_arg]\n            args += ['-j DROP']\n            fw_rules += [' '.join(args)]\n        return ipv4_rules, ipv6_rules\n\n\nclass NoopFirewallDriver(object):\n    \"\"\"Firewall driver which just provides No-op methods.\"\"\"\n    def __init__(*args, **kwargs):\n        pass\n\n    def _noop(*args, **kwargs):\n        pass\n\n    def __getattr__(self, key):\n        return self._noop\n\n    def instance_filter_exists(self, instance, network_info):\n        return True\n"], "filenames": ["nova/api/ec2/cloud.py", "nova/api/openstack/compute/contrib/security_groups.py", "nova/virt/firewall.py"], "buggy_code_start_loc": [613, 500, 303], "buggy_code_end_loc": [614, 501, 305], "fixing_code_start_loc": [613, 500, 303], "fixing_code_end_loc": [614, 501, 305], "type": "CWE-20", "message": "The (1) EC2 and (2) OS APIs in OpenStack Compute (Nova) Folsom (2012.2), Essex (2012.1), and Diablo (2011.3) do not properly check the protocol when security groups are created and the network protocol is not specified entirely in lowercase, which allows remote attackers to bypass intended access restrictions.", "other": {"cve": {"id": "CVE-2012-2654", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-21T15:55:12.847", "lastModified": "2017-08-29T01:31:38.460", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The (1) EC2 and (2) OS APIs in OpenStack Compute (Nova) Folsom (2012.2), Essex (2012.1), and Diablo (2011.3) do not properly check the protocol when security groups are created and the network protocol is not specified entirely in lowercase, which allows remote attackers to bypass intended access restrictions."}, {"lang": "es", "value": "Las APIs (1) EC2 y (2) OS en OpenStack Compute (Nova) Folsom (2012.2), Essex (2012.1) y Diablo (2011.3) no comprueban correctamente el protocolo cuando se crean grupos de seguridad y el protocolo de red no se ha especificado por completo en min\u00fasculas, lo que permite a atacantes remotos eludir restricciones de acceso."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openstack:compute:2012.2:*:*:*:*:*:*:*", "matchCriteriaId": "0E9D8029-F7DD-435D-B4F4-D3DABDB7333B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openstack:diablo:2011.3:*:*:*:*:*:*:*", "matchCriteriaId": "65FA489C-5FDC-4887-9F1F-66177F87DB5E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openstack:essex:2012.1:*:*:*:*:*:*:*", "matchCriteriaId": "E5FDB43F-B315-4F68-9D86-B644F2D4DF9A"}]}]}], "references": [{"url": "http://www.ubuntu.com/usn/USN-1466-1", "source": "secalert@redhat.com"}, {"url": "https://bugs.launchpad.net/nova/+bug/985184", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/76110", "source": "secalert@redhat.com"}, {"url": "https://github.com/openstack/nova/commit/9f9e9da777161426a6f8cb4314b78e09beac2978", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://github.com/openstack/nova/commit/ff06c7c885dc94ed7c828e8cdbb8b5d850a7e654", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://lists.launchpad.net/openstack/msg12883.html", "source": "secalert@redhat.com"}, {"url": "https://review.openstack.org/#/c/8239/", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/openstack/nova/commit/9f9e9da777161426a6f8cb4314b78e09beac2978"}}