{"buggy_code": ["import {\n    ApiCompiledQueryResults,\n    ApiExploreResults,\n    ApiExploresResults,\n    ApiQueryResults,\n    ApiSqlQueryResults,\n    getRequestMethod,\n    LightdashRequestMethodHeader,\n    MetricQuery,\n    NotFoundError,\n    ProjectCatalog,\n    TablesConfiguration,\n} from '@lightdash/common';\nimport express from 'express';\nimport fs from 'fs';\n\nimport path from 'path';\nimport {\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n} from '../controllers/authentication';\nimport { SchedulerClient } from '../scheduler/SchedulerClient';\nimport { CsvService } from '../services/CsvService/CsvService';\nimport {\n    csvService,\n    dashboardService,\n    projectService,\n    savedChartsService,\n    searchService,\n    spaceService,\n} from '../services/services';\n\nconst { Readable } = require('stream');\n\nexport const projectRouter = express.Router({ mergeParams: true });\n\nprojectRouter.get(\n    '/',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            res.json({\n                status: 'ok',\n                results: await projectService.getProject(\n                    req.params.projectUuid,\n                    req.user!,\n                ),\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.patch(\n    '/',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        projectService\n            .update(\n                req.params.projectUuid,\n                req.user!,\n                req.body,\n                getRequestMethod(req.header(LightdashRequestMethodHeader)),\n            )\n            .then((results) => {\n                res.json({\n                    status: 'ok',\n                    results,\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.get(\n    '/search/:query',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            const results = await searchService.getSearchResults(\n                req.user!,\n                req.params.projectUuid,\n                req.params.query,\n            );\n            res.json({ status: 'ok', results });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.put(\n    '/explores',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        projectService\n            .setExplores(req.params.projectUuid, req.body)\n            .then(() => {\n                res.json({\n                    status: 'ok',\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.get(\n    '/explores',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            const results: ApiExploresResults =\n                await projectService.getAllExploresSummary(\n                    req.user!,\n                    req.params.projectUuid,\n                    req.query.filtered === 'true',\n                );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.get(\n    '/explores/:exploreId',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            const results: ApiExploreResults = await projectService.getExplore(\n                req.user!,\n                req.params.projectUuid,\n                req.params.exploreId,\n            );\n            res.json({ status: 'ok', results });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.post(\n    '/explores/:exploreId/compileQuery',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            const { body } = req;\n            const metricQuery: MetricQuery = {\n                dimensions: body.dimensions,\n                metrics: body.metrics,\n                filters: body.filters,\n                sorts: body.sorts,\n                limit: body.limit,\n                tableCalculations: body.tableCalculations,\n                additionalMetrics: body.additionalMetrics,\n            };\n            const results: ApiCompiledQueryResults = (\n                await projectService.compileQuery(\n                    req.user!,\n                    metricQuery,\n                    req.params.projectUuid,\n                    req.params.exploreId,\n                )\n            ).query;\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.post(\n    '/explores/:exploreId/downloadCsv',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        const { body } = req;\n\n        try {\n            const {\n                onlyRaw,\n                csvLimit,\n                showTableNames,\n                customLabels,\n                columnOrder,\n            } = body;\n            const { projectUuid, exploreId } = req.params;\n\n            const metricQuery: MetricQuery = {\n                dimensions: body.dimensions,\n                metrics: body.metrics,\n                filters: body.filters,\n                sorts: body.sorts,\n                limit: body.limit,\n                tableCalculations: body.tableCalculations,\n                additionalMetrics: body.additionalMetrics,\n            };\n\n            const { jobId } = await CsvService.scheduleDownloadCsv(req.user!, {\n                userUuid: req.user?.userUuid!,\n                projectUuid,\n                exploreId,\n                metricQuery,\n                onlyRaw,\n                csvLimit,\n                showTableNames,\n                customLabels,\n                columnOrder,\n            });\n\n            res.json({\n                status: 'ok',\n                results: {\n                    jobId,\n                },\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.get(\n    '/csv/:fileId',\n\n    async (req, res, next) => {\n        try {\n            if (!req.params.fileId.startsWith('csv-')) {\n                throw new NotFoundError(\n                    `CSV file not found ${req.params.fileId}`,\n                );\n            }\n            const filePath = path.join('/tmp', req.params.fileId);\n            if (!fs.existsSync(filePath)) {\n                const error = `This file ${req.params.fileId} doesn't exist on this server, this may be happening if you are running multiple containers or because files are not persisted. You can check out our docs to learn more on how to enable cloud storage: https://docs.lightdash.com/self-host/customize-deployment/configure-lightdash-to-use-external-object-storage`;\n                throw new NotFoundError(error);\n            }\n            res.set('Content-Type', 'text/csv');\n            res.set(\n                'Content-Disposition',\n                `attachment; filename=${req.params.fileId}`,\n            );\n            res.sendFile(filePath);\n        } catch (error) {\n            next(error);\n        }\n    },\n);\n\nprojectRouter.get(\n    '/field/:fieldId/search',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            const value: string =\n                typeof req.query.value === 'string'\n                    ? req.query.value.toString()\n                    : '';\n            const limit: number =\n                typeof req.query.limit === 'string'\n                    ? parseInt(req.query.limit.toString(), 10)\n                    : 100;\n\n            const table =\n                typeof req.query.table === 'string' ? req.query.table : '';\n\n            const results = {\n                search: value,\n                results: await projectService.searchFieldUniqueValues(\n                    req.user!,\n                    req.params.projectUuid,\n                    table,\n                    req.params.fieldId,\n                    value,\n                    limit,\n                ),\n            };\n\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.post(\n    '/refresh',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        try {\n            const results = await projectService.compileProject(\n                req.user!,\n                req.params.projectUuid,\n                getRequestMethod(req.header(LightdashRequestMethodHeader)),\n            );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.post(\n    '/saved',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        if (req.query.duplicateFrom) {\n            savedChartsService\n                .duplicate(\n                    req.user!,\n                    req.params.projectUuid,\n                    req.query.duplicateFrom.toString(),\n                )\n                .then((results) => {\n                    res.json({\n                        status: 'ok',\n                        results,\n                    });\n                })\n                .catch(next);\n        } else {\n            savedChartsService\n                .create(req.user!, req.params.projectUuid, req.body)\n                .then((results) => {\n                    res.json({\n                        status: 'ok',\n                        results,\n                    });\n                })\n                .catch(next);\n        }\n    },\n);\n\nprojectRouter.patch(\n    '/saved',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        savedChartsService\n            .updateMultiple(req.user!, req.params.projectUuid, req.body)\n            .then((results) => {\n                res.json({\n                    status: 'ok',\n                    results,\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.get(\n    '/spaces',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        spaceService\n            .getAllSpaces(req.params.projectUuid, req.user!)\n            .then((results) => {\n                res.json({\n                    status: 'ok',\n                    results,\n                });\n            })\n            .catch(next);\n    },\n);\nprojectRouter.get(\n    '/spaces/:spaceUuid',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        spaceService\n            .getSpace(req.params.projectUuid, req.user!, req.params.spaceUuid)\n            .then((results) => {\n                res.json({\n                    status: 'ok',\n                    results,\n                });\n            })\n            .catch(next);\n    },\n);\nprojectRouter.post(\n    '/spaces',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        spaceService\n            .createSpace(req.params.projectUuid, req.user!, req.body)\n            .then((results) => {\n                res.json({\n                    status: 'ok',\n                    results,\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.delete(\n    '/spaces/:spaceUUid',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        spaceService\n            .deleteSpace(req.user!, req.params.spaceUUid)\n            .then((results) => {\n                res.json({\n                    status: 'ok',\n                    results,\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.patch(\n    '/spaces/:spaceUUid',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        spaceService\n            .updateSpace(req.user!, req.params.spaceUUid, req.body)\n            .then((results) => {\n                res.json({\n                    status: 'ok',\n                    results,\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.patch(\n    '/spaces/:spaceUuid/pinning',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        spaceService\n            .togglePinning(req.user!, req.params.spaceUuid)\n            .then((results) => {\n                res.json({\n                    status: 'ok',\n                    results,\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.post(\n    '/spaces/:spaceUUid/share',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        spaceService\n            .addSpaceShare(req.user!, req.params.spaceUUid, req.body.userUuid)\n            .then(() => {\n                res.json({\n                    status: 'ok',\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.delete(\n    '/spaces/:spaceUUid/share/:userUuid',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        spaceService\n            .removeSpaceShare(\n                req.user!,\n                req.params.spaceUUid,\n                req.params.userUuid,\n            )\n            .then(() => {\n                res.json({\n                    status: 'ok',\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.get(\n    '/dashboards',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        const chartUuid: string | undefined =\n            typeof req.query.chartUuid === 'string'\n                ? req.query.chartUuid.toString()\n                : undefined;\n        dashboardService\n            .getAllByProject(req.user!, req.params.projectUuid, chartUuid)\n            .then((results) => {\n                res.json({\n                    status: 'ok',\n                    results,\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.post(\n    '/dashboards',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        if (req.query.duplicateFrom) {\n            dashboardService\n                .duplicate(\n                    req.user!,\n                    req.params.projectUuid,\n                    req.query.duplicateFrom.toString(),\n                )\n                .then((results) => {\n                    res.status(201).json({\n                        status: 'ok',\n                        results,\n                    });\n                })\n                .catch(next);\n        } else {\n            dashboardService\n                .create(req.user!, req.params.projectUuid, req.body)\n                .then((results) => {\n                    res.status(201).json({\n                        status: 'ok',\n                        results,\n                    });\n                })\n                .catch(next);\n        }\n    },\n);\n\nprojectRouter.patch(\n    '/dashboards',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        dashboardService\n            .updateMultiple(req.user!, req.params.projectUuid, req.body)\n            .then((results) => {\n                res.json({\n                    status: 'ok',\n                    results,\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.post(\n    '/sqlQuery',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        try {\n            const results: ApiSqlQueryResults =\n                await projectService.runSqlQuery(\n                    req.user!,\n                    req.params.projectUuid,\n                    req.body.sql,\n                );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.post(\n    '/sqlRunner/downloadCsv',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            const { customLabels, sql } = req.body;\n            const { projectUuid } = req.params;\n\n            const fileUrl = await csvService.downloadSqlCsv({\n                user: req.user!,\n                projectUuid,\n                sql,\n                customLabels,\n            });\n            res.json({\n                status: 'ok',\n                results: {\n                    url: fileUrl,\n                },\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.get(\n    '/catalog',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            const results: ProjectCatalog = await projectService.getCatalog(\n                req.user!,\n                req.params.projectUuid,\n            );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.get(\n    '/tablesConfiguration',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            const results: TablesConfiguration =\n                await projectService.getTablesConfiguration(\n                    req.user!,\n                    req.params.projectUuid,\n                );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.patch(\n    '/tablesConfiguration',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        try {\n            const results: TablesConfiguration =\n                await projectService.updateTablesConfiguration(\n                    req.user!,\n                    req.params.projectUuid,\n                    req.body,\n                );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.get(\n    '/hasSavedCharts',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            const results = await projectService.hasSavedCharts(\n                req.user!,\n                req.params.projectUuid,\n            );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.get(\n    '/access',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            const results = await projectService.getProjectAccess(\n                req.user!,\n                req.params.projectUuid,\n            );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.post(\n    '/access',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        try {\n            const results = await projectService.createProjectAccess(\n                req.user!,\n                req.params.projectUuid,\n                req.body,\n            );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\nprojectRouter.patch(\n    '/access/:userUuid',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        try {\n            const results = await projectService.updateProjectAccess(\n                req.user!,\n                req.params.projectUuid,\n                req.params.userUuid,\n                req.body,\n            );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\nprojectRouter.delete(\n    '/access/:userUuid',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        try {\n            const results = await projectService.deleteProjectAccess(\n                req.user!,\n                req.params.projectUuid,\n                req.params.userUuid,\n            );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n", "import {\n    ForbiddenError,\n    NotFoundError,\n    SlackSettings,\n} from '@lightdash/common';\nimport { ExpressReceiver } from '@slack/bolt';\nimport express from 'express';\nimport fs from 'fs';\nimport path from 'path';\nimport { analytics } from '../analytics/client';\nimport { LightdashAnalytics } from '../analytics/LightdashAnalytics';\nimport { slackOptions } from '../clients/Slack/SlackOptions';\nimport {\n    isAuthenticated,\n    unauthorisedInDemo,\n} from '../controllers/authentication';\nimport { slackAuthenticationModel } from '../models/models';\n\nexport const slackRouter = express.Router({ mergeParams: true });\n\nslackRouter.get(\n    '/',\n    isAuthenticated,\n    unauthorisedInDemo,\n\n    async (req, res, next) => {\n        try {\n            const organizationUuid = req.user?.organizationUuid;\n            if (!organizationUuid) throw new ForbiddenError();\n            const slackAuth =\n                await slackAuthenticationModel.getInstallationFromOrganizationUuid(\n                    organizationUuid,\n                );\n            if (slackAuth === undefined) {\n                res.status(404).send(\n                    `Could not find an installation for organizationUuid ${organizationUuid}`,\n                );\n                return;\n            }\n            const response: SlackSettings = {\n                organizationUuid,\n                slackTeamName: slackAuth.slackTeamName,\n                createdAt: slackAuth.createdAt,\n                scopes: slackAuth.scopes,\n            };\n            res.json({\n                status: 'ok',\n                results: response,\n            });\n        } catch (error) {\n            next(error);\n        }\n    },\n);\n\nslackRouter.get(\n    '/image/:imageId',\n\n    async (req, res, next) => {\n        try {\n            if (!req.params.imageId.startsWith('slack-image')) {\n                throw new NotFoundError(\n                    `Slack image not found ${req.params.imageId}`,\n                );\n            }\n            const filePath = path.join('/tmp', req.params.imageId);\n            if (!fs.existsSync(filePath)) {\n                const error = `This file ${req.params.imageId} doesn't exist on this server, this may be happening if you are running multiple containers or because files are not persisted. You can check out our docs to learn more on how to enable cloud storage: https://docs.lightdash.com/self-host/customize-deployment/configure-lightdash-to-use-external-object-storage`;\n                throw new NotFoundError(error);\n            }\n            res.sendFile(filePath);\n        } catch (error) {\n            next(error);\n        }\n    },\n);\n\nslackRouter.delete(\n    '/',\n    isAuthenticated,\n    unauthorisedInDemo,\n\n    async (req, res, next) => {\n        try {\n            analytics.track({\n                event: 'share_slack.delete',\n                userId: req.user?.userUuid,\n                properties: {\n                    organizationUuid: req.params.organizationUuid,\n                },\n            });\n\n            const organizationUuid = req.user?.organizationUuid;\n            if (!organizationUuid) throw new ForbiddenError();\n            await slackAuthenticationModel.deleteInstallationFromOrganizationUuid(\n                organizationUuid,\n            );\n\n            res.json({\n                status: 'ok',\n            });\n        } catch (error) {\n            next(error);\n        }\n    },\n);\n\nslackRouter.get(\n    '/install/',\n    isAuthenticated,\n    unauthorisedInDemo,\n\n    async (req, res, next) => {\n        try {\n            const metadata = {\n                organizationUuid: req.user?.organizationUuid,\n                userId: req.user?.userId,\n            };\n            const options = {\n                redirectUri: slackOptions.redirectUri,\n                scopes: slackOptions.scopes,\n                userScopes: slackOptions.installerOptions.userScopes,\n                metadata: JSON.stringify(metadata),\n            };\n            analytics.track({\n                event: 'share_slack.install',\n                userId: req.user?.userUuid,\n                properties: {\n                    organizationUuid: req.params.organizationUuid,\n                },\n            });\n\n            const slackReceiver = new ExpressReceiver(slackOptions);\n\n            await slackReceiver.installer?.handleInstallPath(\n                req,\n                res,\n                {},\n                options,\n            );\n        } catch (error) {\n            analytics.track({\n                event: 'share_slack.install_error',\n                userId: req.user?.userUuid,\n                anonymousId: !req.user?.userUuid\n                    ? LightdashAnalytics.anonymousId\n                    : undefined,\n                properties: {\n                    error: `${error}`,\n                },\n            });\n            next(error);\n        }\n    },\n);\n"], "fixing_code": ["import {\n    ApiCompiledQueryResults,\n    ApiExploreResults,\n    ApiExploresResults,\n    ApiQueryResults,\n    ApiSqlQueryResults,\n    getRequestMethod,\n    LightdashRequestMethodHeader,\n    MetricQuery,\n    NotFoundError,\n    ProjectCatalog,\n    TablesConfiguration,\n} from '@lightdash/common';\nimport express from 'express';\nimport fs from 'fs';\n\nimport path from 'path';\nimport {\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n} from '../controllers/authentication';\nimport { SchedulerClient } from '../scheduler/SchedulerClient';\nimport { CsvService } from '../services/CsvService/CsvService';\nimport {\n    csvService,\n    dashboardService,\n    projectService,\n    savedChartsService,\n    searchService,\n    spaceService,\n} from '../services/services';\n\nconst { Readable } = require('stream');\n\nexport const projectRouter = express.Router({ mergeParams: true });\n\nprojectRouter.get(\n    '/',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            res.json({\n                status: 'ok',\n                results: await projectService.getProject(\n                    req.params.projectUuid,\n                    req.user!,\n                ),\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.patch(\n    '/',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        projectService\n            .update(\n                req.params.projectUuid,\n                req.user!,\n                req.body,\n                getRequestMethod(req.header(LightdashRequestMethodHeader)),\n            )\n            .then((results) => {\n                res.json({\n                    status: 'ok',\n                    results,\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.get(\n    '/search/:query',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            const results = await searchService.getSearchResults(\n                req.user!,\n                req.params.projectUuid,\n                req.params.query,\n            );\n            res.json({ status: 'ok', results });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.put(\n    '/explores',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        projectService\n            .setExplores(req.params.projectUuid, req.body)\n            .then(() => {\n                res.json({\n                    status: 'ok',\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.get(\n    '/explores',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            const results: ApiExploresResults =\n                await projectService.getAllExploresSummary(\n                    req.user!,\n                    req.params.projectUuid,\n                    req.query.filtered === 'true',\n                );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.get(\n    '/explores/:exploreId',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            const results: ApiExploreResults = await projectService.getExplore(\n                req.user!,\n                req.params.projectUuid,\n                req.params.exploreId,\n            );\n            res.json({ status: 'ok', results });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.post(\n    '/explores/:exploreId/compileQuery',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            const { body } = req;\n            const metricQuery: MetricQuery = {\n                dimensions: body.dimensions,\n                metrics: body.metrics,\n                filters: body.filters,\n                sorts: body.sorts,\n                limit: body.limit,\n                tableCalculations: body.tableCalculations,\n                additionalMetrics: body.additionalMetrics,\n            };\n            const results: ApiCompiledQueryResults = (\n                await projectService.compileQuery(\n                    req.user!,\n                    metricQuery,\n                    req.params.projectUuid,\n                    req.params.exploreId,\n                )\n            ).query;\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.post(\n    '/explores/:exploreId/downloadCsv',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        const { body } = req;\n\n        try {\n            const {\n                onlyRaw,\n                csvLimit,\n                showTableNames,\n                customLabels,\n                columnOrder,\n            } = body;\n            const { projectUuid, exploreId } = req.params;\n\n            const metricQuery: MetricQuery = {\n                dimensions: body.dimensions,\n                metrics: body.metrics,\n                filters: body.filters,\n                sorts: body.sorts,\n                limit: body.limit,\n                tableCalculations: body.tableCalculations,\n                additionalMetrics: body.additionalMetrics,\n            };\n\n            const { jobId } = await CsvService.scheduleDownloadCsv(req.user!, {\n                userUuid: req.user?.userUuid!,\n                projectUuid,\n                exploreId,\n                metricQuery,\n                onlyRaw,\n                csvLimit,\n                showTableNames,\n                customLabels,\n                columnOrder,\n            });\n\n            res.json({\n                status: 'ok',\n                results: {\n                    jobId,\n                },\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.get(\n    '/csv/:fileId',\n\n    async (req, res, next) => {\n        try {\n            const { fileId } = req.params;\n\n            if (!fileId.startsWith('csv-') || !fileId.endsWith('.csv')) {\n                throw new NotFoundError(`CSV file not found ${fileId}`);\n            }\n            const sanitizedFileId = fileId.replace('..', '');\n\n            const filePath = path.join('/tmp', sanitizedFileId);\n            if (!fs.existsSync(filePath)) {\n                const error = `This file ${fileId} doesn't exist on this server, this may be happening if you are running multiple containers or because files are not persisted. You can check out our docs to learn more on how to enable cloud storage: https://docs.lightdash.com/self-host/customize-deployment/configure-lightdash-to-use-external-object-storage`;\n                throw new NotFoundError(error);\n            }\n            res.set('Content-Type', 'text/csv');\n            res.set('Content-Disposition', `attachment; filename=${fileId}`);\n            res.sendFile(filePath);\n        } catch (error) {\n            next(error);\n        }\n    },\n);\n\nprojectRouter.get(\n    '/field/:fieldId/search',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            const value: string =\n                typeof req.query.value === 'string'\n                    ? req.query.value.toString()\n                    : '';\n            const limit: number =\n                typeof req.query.limit === 'string'\n                    ? parseInt(req.query.limit.toString(), 10)\n                    : 100;\n\n            const table =\n                typeof req.query.table === 'string' ? req.query.table : '';\n\n            const results = {\n                search: value,\n                results: await projectService.searchFieldUniqueValues(\n                    req.user!,\n                    req.params.projectUuid,\n                    table,\n                    req.params.fieldId,\n                    value,\n                    limit,\n                ),\n            };\n\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.post(\n    '/refresh',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        try {\n            const results = await projectService.compileProject(\n                req.user!,\n                req.params.projectUuid,\n                getRequestMethod(req.header(LightdashRequestMethodHeader)),\n            );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.post(\n    '/saved',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        if (req.query.duplicateFrom) {\n            savedChartsService\n                .duplicate(\n                    req.user!,\n                    req.params.projectUuid,\n                    req.query.duplicateFrom.toString(),\n                )\n                .then((results) => {\n                    res.json({\n                        status: 'ok',\n                        results,\n                    });\n                })\n                .catch(next);\n        } else {\n            savedChartsService\n                .create(req.user!, req.params.projectUuid, req.body)\n                .then((results) => {\n                    res.json({\n                        status: 'ok',\n                        results,\n                    });\n                })\n                .catch(next);\n        }\n    },\n);\n\nprojectRouter.patch(\n    '/saved',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        savedChartsService\n            .updateMultiple(req.user!, req.params.projectUuid, req.body)\n            .then((results) => {\n                res.json({\n                    status: 'ok',\n                    results,\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.get(\n    '/spaces',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        spaceService\n            .getAllSpaces(req.params.projectUuid, req.user!)\n            .then((results) => {\n                res.json({\n                    status: 'ok',\n                    results,\n                });\n            })\n            .catch(next);\n    },\n);\nprojectRouter.get(\n    '/spaces/:spaceUuid',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        spaceService\n            .getSpace(req.params.projectUuid, req.user!, req.params.spaceUuid)\n            .then((results) => {\n                res.json({\n                    status: 'ok',\n                    results,\n                });\n            })\n            .catch(next);\n    },\n);\nprojectRouter.post(\n    '/spaces',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        spaceService\n            .createSpace(req.params.projectUuid, req.user!, req.body)\n            .then((results) => {\n                res.json({\n                    status: 'ok',\n                    results,\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.delete(\n    '/spaces/:spaceUUid',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        spaceService\n            .deleteSpace(req.user!, req.params.spaceUUid)\n            .then((results) => {\n                res.json({\n                    status: 'ok',\n                    results,\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.patch(\n    '/spaces/:spaceUUid',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        spaceService\n            .updateSpace(req.user!, req.params.spaceUUid, req.body)\n            .then((results) => {\n                res.json({\n                    status: 'ok',\n                    results,\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.patch(\n    '/spaces/:spaceUuid/pinning',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        spaceService\n            .togglePinning(req.user!, req.params.spaceUuid)\n            .then((results) => {\n                res.json({\n                    status: 'ok',\n                    results,\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.post(\n    '/spaces/:spaceUUid/share',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        spaceService\n            .addSpaceShare(req.user!, req.params.spaceUUid, req.body.userUuid)\n            .then(() => {\n                res.json({\n                    status: 'ok',\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.delete(\n    '/spaces/:spaceUUid/share/:userUuid',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        spaceService\n            .removeSpaceShare(\n                req.user!,\n                req.params.spaceUUid,\n                req.params.userUuid,\n            )\n            .then(() => {\n                res.json({\n                    status: 'ok',\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.get(\n    '/dashboards',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        const chartUuid: string | undefined =\n            typeof req.query.chartUuid === 'string'\n                ? req.query.chartUuid.toString()\n                : undefined;\n        dashboardService\n            .getAllByProject(req.user!, req.params.projectUuid, chartUuid)\n            .then((results) => {\n                res.json({\n                    status: 'ok',\n                    results,\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.post(\n    '/dashboards',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        if (req.query.duplicateFrom) {\n            dashboardService\n                .duplicate(\n                    req.user!,\n                    req.params.projectUuid,\n                    req.query.duplicateFrom.toString(),\n                )\n                .then((results) => {\n                    res.status(201).json({\n                        status: 'ok',\n                        results,\n                    });\n                })\n                .catch(next);\n        } else {\n            dashboardService\n                .create(req.user!, req.params.projectUuid, req.body)\n                .then((results) => {\n                    res.status(201).json({\n                        status: 'ok',\n                        results,\n                    });\n                })\n                .catch(next);\n        }\n    },\n);\n\nprojectRouter.patch(\n    '/dashboards',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        dashboardService\n            .updateMultiple(req.user!, req.params.projectUuid, req.body)\n            .then((results) => {\n                res.json({\n                    status: 'ok',\n                    results,\n                });\n            })\n            .catch(next);\n    },\n);\n\nprojectRouter.post(\n    '/sqlQuery',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        try {\n            const results: ApiSqlQueryResults =\n                await projectService.runSqlQuery(\n                    req.user!,\n                    req.params.projectUuid,\n                    req.body.sql,\n                );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.post(\n    '/sqlRunner/downloadCsv',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            const { customLabels, sql } = req.body;\n            const { projectUuid } = req.params;\n\n            const fileUrl = await csvService.downloadSqlCsv({\n                user: req.user!,\n                projectUuid,\n                sql,\n                customLabels,\n            });\n            res.json({\n                status: 'ok',\n                results: {\n                    url: fileUrl,\n                },\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.get(\n    '/catalog',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            const results: ProjectCatalog = await projectService.getCatalog(\n                req.user!,\n                req.params.projectUuid,\n            );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.get(\n    '/tablesConfiguration',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            const results: TablesConfiguration =\n                await projectService.getTablesConfiguration(\n                    req.user!,\n                    req.params.projectUuid,\n                );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.patch(\n    '/tablesConfiguration',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        try {\n            const results: TablesConfiguration =\n                await projectService.updateTablesConfiguration(\n                    req.user!,\n                    req.params.projectUuid,\n                    req.body,\n                );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.get(\n    '/hasSavedCharts',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            const results = await projectService.hasSavedCharts(\n                req.user!,\n                req.params.projectUuid,\n            );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.get(\n    '/access',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    async (req, res, next) => {\n        try {\n            const results = await projectService.getProjectAccess(\n                req.user!,\n                req.params.projectUuid,\n            );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n\nprojectRouter.post(\n    '/access',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        try {\n            const results = await projectService.createProjectAccess(\n                req.user!,\n                req.params.projectUuid,\n                req.body,\n            );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\nprojectRouter.patch(\n    '/access/:userUuid',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        try {\n            const results = await projectService.updateProjectAccess(\n                req.user!,\n                req.params.projectUuid,\n                req.params.userUuid,\n                req.body,\n            );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\nprojectRouter.delete(\n    '/access/:userUuid',\n    allowApiKeyAuthentication,\n    isAuthenticated,\n    unauthorisedInDemo,\n    async (req, res, next) => {\n        try {\n            const results = await projectService.deleteProjectAccess(\n                req.user!,\n                req.params.projectUuid,\n                req.params.userUuid,\n            );\n            res.json({\n                status: 'ok',\n                results,\n            });\n        } catch (e) {\n            next(e);\n        }\n    },\n);\n", "import {\n    ForbiddenError,\n    NotFoundError,\n    SlackSettings,\n} from '@lightdash/common';\nimport { ExpressReceiver } from '@slack/bolt';\nimport express from 'express';\nimport fs from 'fs';\nimport path from 'path';\nimport { analytics } from '../analytics/client';\nimport { LightdashAnalytics } from '../analytics/LightdashAnalytics';\nimport { slackOptions } from '../clients/Slack/SlackOptions';\nimport {\n    isAuthenticated,\n    unauthorisedInDemo,\n} from '../controllers/authentication';\nimport { slackAuthenticationModel } from '../models/models';\n\nexport const slackRouter = express.Router({ mergeParams: true });\n\nslackRouter.get(\n    '/',\n    isAuthenticated,\n    unauthorisedInDemo,\n\n    async (req, res, next) => {\n        try {\n            const organizationUuid = req.user?.organizationUuid;\n            if (!organizationUuid) throw new ForbiddenError();\n            const slackAuth =\n                await slackAuthenticationModel.getInstallationFromOrganizationUuid(\n                    organizationUuid,\n                );\n            if (slackAuth === undefined) {\n                res.status(404).send(\n                    `Could not find an installation for organizationUuid ${organizationUuid}`,\n                );\n                return;\n            }\n            const response: SlackSettings = {\n                organizationUuid,\n                slackTeamName: slackAuth.slackTeamName,\n                createdAt: slackAuth.createdAt,\n                scopes: slackAuth.scopes,\n            };\n            res.json({\n                status: 'ok',\n                results: response,\n            });\n        } catch (error) {\n            next(error);\n        }\n    },\n);\n\nslackRouter.get(\n    '/image/:imageId',\n\n    async (req, res, next) => {\n        try {\n            const { imageId } = req.params;\n            if (\n                !imageId.startsWith('slack-image') ||\n                !imageId.endsWith('.png')\n            ) {\n                throw new NotFoundError(\n                    `Slack image not found ${req.params.imageId}`,\n                );\n            }\n            const sanitizedImageId = imageId.replace('..', '');\n\n            const filePath = path.join('/tmp', sanitizedImageId);\n            if (!fs.existsSync(filePath)) {\n                const error = `This file ${imageId} doesn't exist on this server, this may be happening if you are running multiple containers or because files are not persisted. You can check out our docs to learn more on how to enable cloud storage: https://docs.lightdash.com/self-host/customize-deployment/configure-lightdash-to-use-external-object-storage`;\n                throw new NotFoundError(error);\n            }\n            res.sendFile(filePath);\n        } catch (error) {\n            next(error);\n        }\n    },\n);\n\nslackRouter.delete(\n    '/',\n    isAuthenticated,\n    unauthorisedInDemo,\n\n    async (req, res, next) => {\n        try {\n            analytics.track({\n                event: 'share_slack.delete',\n                userId: req.user?.userUuid,\n                properties: {\n                    organizationUuid: req.params.organizationUuid,\n                },\n            });\n\n            const organizationUuid = req.user?.organizationUuid;\n            if (!organizationUuid) throw new ForbiddenError();\n            await slackAuthenticationModel.deleteInstallationFromOrganizationUuid(\n                organizationUuid,\n            );\n\n            res.json({\n                status: 'ok',\n            });\n        } catch (error) {\n            next(error);\n        }\n    },\n);\n\nslackRouter.get(\n    '/install/',\n    isAuthenticated,\n    unauthorisedInDemo,\n\n    async (req, res, next) => {\n        try {\n            const metadata = {\n                organizationUuid: req.user?.organizationUuid,\n                userId: req.user?.userId,\n            };\n            const options = {\n                redirectUri: slackOptions.redirectUri,\n                scopes: slackOptions.scopes,\n                userScopes: slackOptions.installerOptions.userScopes,\n                metadata: JSON.stringify(metadata),\n            };\n            analytics.track({\n                event: 'share_slack.install',\n                userId: req.user?.userUuid,\n                properties: {\n                    organizationUuid: req.params.organizationUuid,\n                },\n            });\n\n            const slackReceiver = new ExpressReceiver(slackOptions);\n\n            await slackReceiver.installer?.handleInstallPath(\n                req,\n                res,\n                {},\n                options,\n            );\n        } catch (error) {\n            analytics.track({\n                event: 'share_slack.install_error',\n                userId: req.user?.userUuid,\n                anonymousId: !req.user?.userUuid\n                    ? LightdashAnalytics.anonymousId\n                    : undefined,\n                properties: {\n                    error: `${error}`,\n                },\n            });\n            next(error);\n        }\n    },\n);\n"], "filenames": ["packages/backend/src/routers/projectRouter.ts", "packages/backend/src/routers/slackRouter.ts"], "buggy_code_start_loc": [245, 61], "buggy_code_end_loc": [260, 69], "fixing_code_start_loc": [245, 61], "fixing_code_end_loc": [259, 75], "type": "CWE-22", "message": "packages/backend/src/routers in Lightdash before 0.510.3 has insecure file endpoints, e.g., they allow .. directory traversal and do not ensure that an intended file extension (.csv or .png) is used.", "other": {"cve": {"id": "CVE-2023-35844", "sourceIdentifier": "cve@mitre.org", "published": "2023-06-19T02:15:08.903", "lastModified": "2023-06-27T15:48:14.627", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "packages/backend/src/routers in Lightdash before 0.510.3 has insecure file endpoints, e.g., they allow .. directory traversal and do not ensure that an intended file extension (.csv or .png) is used."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lightdash:lightdash:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.510.3", "matchCriteriaId": "8D62C6A5-FC94-45F8-86CE-AAFE64A2D1FF"}]}]}], "references": [{"url": "https://advisory.dw1.io/59", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/lightdash/lightdash/commit/fcc808c84c2cc3afb343063e32a49440d32a553c", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/lightdash/lightdash/compare/0.510.2...0.510.3", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/lightdash/lightdash/pull/5090", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/lightdash/lightdash/commit/fcc808c84c2cc3afb343063e32a49440d32a553c"}}