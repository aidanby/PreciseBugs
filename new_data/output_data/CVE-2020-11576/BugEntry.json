{"buggy_code": ["package session\n\nimport (\n\t\"context\"\n\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\n\t\"github.com/argoproj/argo-cd/pkg/apiclient/session\"\n\tsessionmgr \"github.com/argoproj/argo-cd/util/session\"\n)\n\n// Server provides a Session service\ntype Server struct {\n\tmgr           *sessionmgr.SessionManager\n\tauthenticator Authenticator\n}\n\ntype Authenticator interface {\n\tAuthenticate(ctx context.Context) (context.Context, error)\n}\n\n// NewServer returns a new instance of the Session service\nfunc NewServer(mgr *sessionmgr.SessionManager, authenticator Authenticator) *Server {\n\treturn &Server{mgr, authenticator}\n}\n\n// Create generates a JWT token signed by Argo CD intended for web/CLI logins of the admin user\n// using username/password\nfunc (s *Server) Create(ctx context.Context, q *session.SessionCreateRequest) (*session.SessionResponse, error) {\n\tif q.Token != \"\" {\n\t\treturn nil, status.Errorf(codes.Unauthenticated, \"token-based session creation no longer supported. please upgrade argocd cli to v0.7+\")\n\t}\n\tif q.Username == \"\" || q.Password == \"\" {\n\t\treturn nil, status.Errorf(codes.Unauthenticated, \"no credentials supplied\")\n\t}\n\terr := s.mgr.VerifyUsernamePassword(q.Username, q.Password)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tjwtToken, err := s.mgr.Create(q.Username, 0, \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &session.SessionResponse{Token: jwtToken}, nil\n}\n\n// Delete an authentication cookie from the client.  This makes sense only for the Web client.\nfunc (s *Server) Delete(ctx context.Context, q *session.SessionDeleteRequest) (*session.SessionResponse, error) {\n\treturn &session.SessionResponse{Token: \"\"}, nil\n}\n\n// AuthFuncOverride overrides the authentication function and let us not require auth to receive auth.\n// Without this function here, ArgoCDServer.authenticate would be invoked and credentials checked.\n// Since this service is generally invoked when the user has _no_ credentials, that would create a\n// chicken-and-egg situation if we didn't place this here to allow traffic to pass through.\nfunc (s *Server) AuthFuncOverride(ctx context.Context, fullMethodName string) (context.Context, error) {\n\t// this authenticates the user, but ignores any error, so that we have claims populated\n\tctx, _ = s.authenticator.Authenticate(ctx)\n\treturn ctx, nil\n}\n\nfunc (s *Server) GetUserInfo(ctx context.Context, q *session.GetUserInfoRequest) (*session.GetUserInfoResponse, error) {\n\treturn &session.GetUserInfoResponse{\n\t\tLoggedIn: sessionmgr.LoggedIn(ctx),\n\t\tUsername: sessionmgr.Username(ctx),\n\t\tIss:      sessionmgr.Iss(ctx),\n\t\tGroups:   sessionmgr.Groups(ctx),\n\t}, nil\n}\n", "package e2e\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/argoproj/argo-cd/pkg/apiclient/session\"\n\t\"github.com/argoproj/argo-cd/util\"\n\n\targocdclient \"github.com/argoproj/argo-cd/pkg/apiclient\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"github.com/argoproj/argo-cd/errors\"\n\t. \"github.com/argoproj/argo-cd/test/e2e/fixture\"\n)\n\nfunc TestCreateAndUseAccount(t *testing.T) {\n\tEnsureCleanState(t)\n\n\toutput, err := RunCli(\"account\", \"list\")\n\terrors.CheckError(err)\n\n\tassert.Equal(t, `NAME   ENABLED  CAPABILITIES\nadmin  true     login`, output)\n\n\tSetAccounts(map[string][]string{\n\t\t\"test\": {\"login\", \"apiKey\"},\n\t})\n\n\toutput, err = RunCli(\"account\", \"list\")\n\terrors.CheckError(err)\n\n\tassert.Equal(t, `NAME   ENABLED  CAPABILITIES\nadmin  true     login\ntest   true     login, apiKey`, output)\n\n\ttoken, err := RunCli(\"account\", \"generate-token\", \"--account\", \"test\")\n\terrors.CheckError(err)\n\n\tclientOpts := ArgoCDClientset.ClientOptions()\n\tclientOpts.AuthToken = token\n\ttestAccountClientset := argocdclient.NewClientOrDie(&clientOpts)\n\n\tcloser, client := testAccountClientset.NewSessionClientOrDie()\n\tdefer util.Close(closer)\n\n\tinfo, err := client.GetUserInfo(context.Background(), &session.GetUserInfoRequest{})\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, info.Username, \"test\")\n}\n", "package session\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/argoproj/argo-cd/server/rbacpolicy\"\n\n\t\"github.com/dgrijalva/jwt-go\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\n\t\"github.com/argoproj/argo-cd/common\"\n\t\"github.com/argoproj/argo-cd/util/dex\"\n\thttputil \"github.com/argoproj/argo-cd/util/http\"\n\tjwtutil \"github.com/argoproj/argo-cd/util/jwt\"\n\toidcutil \"github.com/argoproj/argo-cd/util/oidc\"\n\tpasswordutil \"github.com/argoproj/argo-cd/util/password\"\n\t\"github.com/argoproj/argo-cd/util/settings\"\n)\n\n// SessionManager generates and validates JWT tokens for login sessions.\ntype SessionManager struct {\n\tsettingsMgr *settings.SettingsManager\n\tclient      *http.Client\n\tprov        oidcutil.Provider\n}\n\nconst (\n\t// SessionManagerClaimsIssuer fills the \"iss\" field of the token.\n\tSessionManagerClaimsIssuer = \"argocd\"\n\n\t// invalidLoginError, for security purposes, doesn't say whether the username or password was invalid.  This does not mitigate the potential for timing attacks to determine which is which.\n\tinvalidLoginError  = \"Invalid username or password\"\n\tblankPasswordError = \"Blank passwords are not allowed\"\n\taccountDisabled    = \"Account %s is disabled\"\n)\n\n// NewSessionManager creates a new session manager from Argo CD settings\nfunc NewSessionManager(settingsMgr *settings.SettingsManager, dexServerAddr string) *SessionManager {\n\ts := SessionManager{\n\t\tsettingsMgr: settingsMgr,\n\t}\n\tsettings, err := settingsMgr.GetSettings()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\ttlsConfig := settings.TLSConfig()\n\tif tlsConfig != nil {\n\t\ttlsConfig.InsecureSkipVerify = true\n\t}\n\ts.client = &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: tlsConfig,\n\t\t\tProxy:           http.ProxyFromEnvironment,\n\t\t\tDial: (&net.Dialer{\n\t\t\t\tTimeout:   30 * time.Second,\n\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t}).Dial,\n\t\t\tTLSHandshakeTimeout:   10 * time.Second,\n\t\t\tExpectContinueTimeout: 1 * time.Second,\n\t\t},\n\t}\n\tif settings.DexConfig != \"\" {\n\t\ts.client.Transport = dex.NewDexRewriteURLRoundTripper(dexServerAddr, s.client.Transport)\n\t}\n\tif os.Getenv(common.EnvVarSSODebug) == \"1\" {\n\t\ts.client.Transport = httputil.DebugTransport{T: s.client.Transport}\n\t}\n\n\treturn &s\n}\n\n// Create creates a new token for a given subject (user) and returns it as a string.\n// Passing a value of `0` for secondsBeforeExpiry creates a token that never expires.\n// The id parameter holds an optional unique JWT token identifier and stored as a standard claim \"jti\" in the JWT token.\nfunc (mgr *SessionManager) Create(subject string, secondsBeforeExpiry int64, id string) (string, error) {\n\t// Create a new token object, specifying signing method and the claims\n\t// you would like it to contain.\n\tnow := time.Now().UTC()\n\tclaims := jwt.StandardClaims{\n\t\tIssuedAt:  now.Unix(),\n\t\tIssuer:    SessionManagerClaimsIssuer,\n\t\tNotBefore: now.Unix(),\n\t\tSubject:   subject,\n\t\tId:        id,\n\t}\n\tif secondsBeforeExpiry > 0 {\n\t\texpires := now.Add(time.Duration(secondsBeforeExpiry) * time.Second)\n\t\tclaims.ExpiresAt = expires.Unix()\n\t}\n\n\treturn mgr.signClaims(claims)\n}\n\nfunc (mgr *SessionManager) signClaims(claims jwt.Claims) (string, error) {\n\tlog.Infof(\"Issuing claims: %v\", claims)\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\tsettings, err := mgr.settingsMgr.GetSettings()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn token.SignedString(settings.ServerSignature)\n}\n\n// Parse tries to parse the provided string and returns the token claims for local login.\nfunc (mgr *SessionManager) Parse(tokenString string) (jwt.Claims, error) {\n\t// Parse takes the token string and a function for looking up the key. The latter is especially\n\t// useful if you use multiple keys for your application.  The standard is to use 'kid' in the\n\t// head of the token to identify which key to use, but the parsed token (head and claims) is provided\n\t// to the callback, providing flexibility.\n\tvar claims jwt.MapClaims\n\tsettings, err := mgr.settingsMgr.GetSettings()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttoken, err := jwt.ParseWithClaims(tokenString, &claims, func(token *jwt.Token) (interface{}, error) {\n\t\t// Don't forget to validate the alg is what you expect:\n\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\treturn nil, fmt.Errorf(\"Unexpected signing method: %v\", token.Header[\"alg\"])\n\t\t}\n\t\treturn settings.ServerSignature, nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsubject := jwtutil.GetField(claims, \"sub\")\n\tif rbacpolicy.IsProjectSubject(subject) {\n\t\treturn token.Claims, nil\n\t}\n\n\taccount, err := mgr.settingsMgr.GetAccount(subject)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif id := jwtutil.GetField(claims, \"jti\"); id != \"\" && account.TokenIndex(id) == -1 {\n\t\treturn nil, fmt.Errorf(\"account %s does not have token with id %s\", subject, id)\n\t}\n\n\tissuedAt := time.Unix(int64(claims[\"iat\"].(float64)), 0)\n\tif account.PasswordMtime != nil && issuedAt.Before(*account.PasswordMtime) {\n\t\treturn nil, fmt.Errorf(\"Account password has changed since token issued\")\n\t}\n\treturn token.Claims, nil\n}\n\n// VerifyUsernamePassword verifies if a username/password combo is correct\nfunc (mgr *SessionManager) VerifyUsernamePassword(username string, password string) error {\n\taccount, err := mgr.settingsMgr.GetAccount(username)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !account.Enabled {\n\t\treturn status.Errorf(codes.Unauthenticated, accountDisabled, username)\n\t}\n\tif password == \"\" {\n\t\treturn status.Errorf(codes.Unauthenticated, blankPasswordError)\n\t}\n\n\tvalid, _ := passwordutil.VerifyPassword(password, account.PasswordHash)\n\tif !valid {\n\t\treturn status.Errorf(codes.Unauthenticated, invalidLoginError)\n\t}\n\treturn nil\n}\n\n// VerifyToken verifies if a token is correct. Tokens can be issued either from us or by an IDP.\n// We choose how to verify based on the issuer.\nfunc (mgr *SessionManager) VerifyToken(tokenString string) (jwt.Claims, error) {\n\tparser := &jwt.Parser{\n\t\tSkipClaimsValidation: true,\n\t}\n\tvar claims jwt.StandardClaims\n\t_, _, err := parser.ParseUnverified(tokenString, &claims)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tswitch claims.Issuer {\n\tcase SessionManagerClaimsIssuer:\n\t\t// Argo CD signed token\n\t\treturn mgr.Parse(tokenString)\n\tdefault:\n\t\t// IDP signed token\n\t\tprov, err := mgr.provider()\n\t\tif err != nil {\n\t\t\treturn claims, err\n\t\t}\n\t\tidToken, err := prov.Verify(claims.Audience, tokenString)\n\t\tif err != nil {\n\t\t\treturn claims, err\n\t\t}\n\t\tvar claims jwt.MapClaims\n\t\terr = idToken.Claims(&claims)\n\t\treturn claims, err\n\t}\n}\n\nfunc (mgr *SessionManager) provider() (oidcutil.Provider, error) {\n\tif mgr.prov != nil {\n\t\treturn mgr.prov, nil\n\t}\n\tsettings, err := mgr.settingsMgr.GetSettings()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !settings.IsSSOConfigured() {\n\t\treturn nil, fmt.Errorf(\"SSO is not configured\")\n\t}\n\tmgr.prov = oidcutil.NewOIDCProvider(settings.IssuerURL(), mgr.client)\n\treturn mgr.prov, nil\n}\n\nfunc LoggedIn(ctx context.Context) bool {\n\treturn Sub(ctx) != \"\"\n}\n\n// Username is a helper to extract a human readable username from a context\nfunc Username(ctx context.Context) string {\n\tmapClaims, ok := mapClaims(ctx)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\tswitch jwtutil.GetField(mapClaims, \"iss\") {\n\tcase SessionManagerClaimsIssuer:\n\t\treturn jwtutil.GetField(mapClaims, \"sub\")\n\tdefault:\n\t\treturn jwtutil.GetField(mapClaims, \"email\")\n\t}\n}\n\nfunc Iss(ctx context.Context) string {\n\tmapClaims, ok := mapClaims(ctx)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn jwtutil.GetField(mapClaims, \"iss\")\n}\n\nfunc Iat(ctx context.Context) (time.Time, error) {\n\tmapClaims, ok := mapClaims(ctx)\n\tif !ok {\n\t\treturn time.Time{}, errors.New(\"unable to extract token claims\")\n\t}\n\tiatField, ok := mapClaims[\"iat\"]\n\tif !ok {\n\t\treturn time.Time{}, errors.New(\"token does not have iat claim\")\n\t}\n\n\tif iat, ok := iatField.(float64); !ok {\n\t\treturn time.Time{}, errors.New(\"iat token field has unexpected type\")\n\t} else {\n\t\treturn time.Unix(int64(iat), 0), nil\n\t}\n}\n\nfunc Sub(ctx context.Context) string {\n\tmapClaims, ok := mapClaims(ctx)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn jwtutil.GetField(mapClaims, \"sub\")\n}\n\nfunc Groups(ctx context.Context) []string {\n\tmapClaims, ok := mapClaims(ctx)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn jwtutil.GetGroups(mapClaims)\n}\n\nfunc mapClaims(ctx context.Context) (jwt.MapClaims, bool) {\n\tclaims, ok := ctx.Value(\"claims\").(jwt.Claims)\n\tif !ok {\n\t\treturn nil, false\n\t}\n\tmapClaims, err := jwtutil.MapClaims(claims)\n\tif err != nil {\n\t\treturn nil, false\n\t}\n\treturn mapClaims, true\n}\n"], "fixing_code": ["package session\n\nimport (\n\t\"context\"\n\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\n\t\"github.com/argoproj/argo-cd/pkg/apiclient/session\"\n\tsessionmgr \"github.com/argoproj/argo-cd/util/session\"\n)\n\n// Server provides a Session service\ntype Server struct {\n\tmgr           *sessionmgr.SessionManager\n\tauthenticator Authenticator\n}\n\ntype Authenticator interface {\n\tAuthenticate(ctx context.Context) (context.Context, error)\n}\n\n// NewServer returns a new instance of the Session service\nfunc NewServer(mgr *sessionmgr.SessionManager, authenticator Authenticator) *Server {\n\treturn &Server{mgr, authenticator}\n}\n\n// Create generates a JWT token signed by Argo CD intended for web/CLI logins of the admin user\n// using username/password\nfunc (s *Server) Create(_ context.Context, q *session.SessionCreateRequest) (*session.SessionResponse, error) {\n\tif q.Token != \"\" {\n\t\treturn nil, status.Errorf(codes.Unauthenticated, \"token-based session creation no longer supported. please upgrade argocd cli to v0.7+\")\n\t}\n\tif q.Username == \"\" || q.Password == \"\" {\n\t\treturn nil, status.Errorf(codes.Unauthenticated, \"no credentials supplied\")\n\t}\n\terr := s.mgr.VerifyUsernamePassword(q.Username, q.Password)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tjwtToken, err := s.mgr.Create(q.Username, 0, \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &session.SessionResponse{Token: jwtToken}, nil\n}\n\n// Delete an authentication cookie from the client.  This makes sense only for the Web client.\nfunc (s *Server) Delete(ctx context.Context, q *session.SessionDeleteRequest) (*session.SessionResponse, error) {\n\treturn &session.SessionResponse{Token: \"\"}, nil\n}\n\n// AuthFuncOverride overrides the authentication function and let us not require auth to receive auth.\n// Without this function here, ArgoCDServer.authenticate would be invoked and credentials checked.\n// Since this service is generally invoked when the user has _no_ credentials, that would create a\n// chicken-and-egg situation if we didn't place this here to allow traffic to pass through.\nfunc (s *Server) AuthFuncOverride(ctx context.Context, fullMethodName string) (context.Context, error) {\n\t// this authenticates the user, but ignores any error, so that we have claims populated\n\tctx, _ = s.authenticator.Authenticate(ctx)\n\treturn ctx, nil\n}\n\nfunc (s *Server) GetUserInfo(ctx context.Context, q *session.GetUserInfoRequest) (*session.GetUserInfoResponse, error) {\n\treturn &session.GetUserInfoResponse{\n\t\tLoggedIn: sessionmgr.LoggedIn(ctx),\n\t\tUsername: sessionmgr.Username(ctx),\n\t\tIss:      sessionmgr.Iss(ctx),\n\t\tGroups:   sessionmgr.Groups(ctx),\n\t}, nil\n}\n", "package e2e\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\n\t\"github.com/argoproj/argo-cd/errors\"\n\targocdclient \"github.com/argoproj/argo-cd/pkg/apiclient\"\n\t\"github.com/argoproj/argo-cd/pkg/apiclient/session\"\n\t. \"github.com/argoproj/argo-cd/test/e2e/fixture\"\n\t\"github.com/argoproj/argo-cd/util\"\n)\n\nfunc TestCreateAndUseAccount(t *testing.T) {\n\tEnsureCleanState(t)\n\n\toutput, err := RunCli(\"account\", \"list\")\n\terrors.CheckError(err)\n\n\tassert.Equal(t, `NAME   ENABLED  CAPABILITIES\nadmin  true     login`, output)\n\n\tSetAccounts(map[string][]string{\n\t\t\"test\": {\"login\", \"apiKey\"},\n\t})\n\n\toutput, err = RunCli(\"account\", \"list\")\n\terrors.CheckError(err)\n\n\tassert.Equal(t, `NAME   ENABLED  CAPABILITIES\nadmin  true     login\ntest   true     login, apiKey`, output)\n\n\ttoken, err := RunCli(\"account\", \"generate-token\", \"--account\", \"test\")\n\terrors.CheckError(err)\n\n\tclientOpts := ArgoCDClientset.ClientOptions()\n\tclientOpts.AuthToken = token\n\ttestAccountClientset := argocdclient.NewClientOrDie(&clientOpts)\n\n\tcloser, client := testAccountClientset.NewSessionClientOrDie()\n\tdefer util.Close(closer)\n\n\tinfo, err := client.GetUserInfo(context.Background(), &session.GetUserInfoRequest{})\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, info.Username, \"test\")\n}\n\nfunc TestLoginBadCredentials(t *testing.T) {\n\tEnsureCleanState(t)\n\n\tcloser, sessionClient := ArgoCDClientset.NewSessionClientOrDie()\n\tdefer util.Close(closer)\n\n\trequests := []session.SessionCreateRequest{{\n\t\tUsername: \"user-does-not-exist\", Password: \"some-password\",\n\t}, {\n\t\tUsername: \"admin\", Password: \"bad-password\",\n\t}}\n\n\tfor _, r := range requests {\n\t\t_, err := sessionClient.Create(context.Background(), &r)\n\t\tif !assert.Error(t, err) {\n\t\t\treturn\n\t\t}\n\t\terrStatus, ok := status.FromError(err)\n\t\tif !assert.True(t, ok) {\n\t\t\treturn\n\t\t}\n\t\tassert.Equal(t, codes.Unauthenticated, errStatus.Code())\n\t\tassert.Equal(t, \"Invalid username or password\", errStatus.Message())\n\t}\n}\n", "package session\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/argoproj/argo-cd/server/rbacpolicy\"\n\n\t\"github.com/dgrijalva/jwt-go\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\n\t\"github.com/argoproj/argo-cd/common\"\n\t\"github.com/argoproj/argo-cd/util/dex\"\n\thttputil \"github.com/argoproj/argo-cd/util/http\"\n\tjwtutil \"github.com/argoproj/argo-cd/util/jwt\"\n\toidcutil \"github.com/argoproj/argo-cd/util/oidc\"\n\tpasswordutil \"github.com/argoproj/argo-cd/util/password\"\n\t\"github.com/argoproj/argo-cd/util/settings\"\n)\n\n// SessionManager generates and validates JWT tokens for login sessions.\ntype SessionManager struct {\n\tsettingsMgr *settings.SettingsManager\n\tclient      *http.Client\n\tprov        oidcutil.Provider\n}\n\nconst (\n\t// SessionManagerClaimsIssuer fills the \"iss\" field of the token.\n\tSessionManagerClaimsIssuer = \"argocd\"\n\n\t// invalidLoginError, for security purposes, doesn't say whether the username or password was invalid.  This does not mitigate the potential for timing attacks to determine which is which.\n\tinvalidLoginError  = \"Invalid username or password\"\n\tblankPasswordError = \"Blank passwords are not allowed\"\n\taccountDisabled    = \"Account %s is disabled\"\n)\n\n// NewSessionManager creates a new session manager from Argo CD settings\nfunc NewSessionManager(settingsMgr *settings.SettingsManager, dexServerAddr string) *SessionManager {\n\ts := SessionManager{\n\t\tsettingsMgr: settingsMgr,\n\t}\n\tsettings, err := settingsMgr.GetSettings()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\ttlsConfig := settings.TLSConfig()\n\tif tlsConfig != nil {\n\t\ttlsConfig.InsecureSkipVerify = true\n\t}\n\ts.client = &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: tlsConfig,\n\t\t\tProxy:           http.ProxyFromEnvironment,\n\t\t\tDial: (&net.Dialer{\n\t\t\t\tTimeout:   30 * time.Second,\n\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t}).Dial,\n\t\t\tTLSHandshakeTimeout:   10 * time.Second,\n\t\t\tExpectContinueTimeout: 1 * time.Second,\n\t\t},\n\t}\n\tif settings.DexConfig != \"\" {\n\t\ts.client.Transport = dex.NewDexRewriteURLRoundTripper(dexServerAddr, s.client.Transport)\n\t}\n\tif os.Getenv(common.EnvVarSSODebug) == \"1\" {\n\t\ts.client.Transport = httputil.DebugTransport{T: s.client.Transport}\n\t}\n\n\treturn &s\n}\n\n// Create creates a new token for a given subject (user) and returns it as a string.\n// Passing a value of `0` for secondsBeforeExpiry creates a token that never expires.\n// The id parameter holds an optional unique JWT token identifier and stored as a standard claim \"jti\" in the JWT token.\nfunc (mgr *SessionManager) Create(subject string, secondsBeforeExpiry int64, id string) (string, error) {\n\t// Create a new token object, specifying signing method and the claims\n\t// you would like it to contain.\n\tnow := time.Now().UTC()\n\tclaims := jwt.StandardClaims{\n\t\tIssuedAt:  now.Unix(),\n\t\tIssuer:    SessionManagerClaimsIssuer,\n\t\tNotBefore: now.Unix(),\n\t\tSubject:   subject,\n\t\tId:        id,\n\t}\n\tif secondsBeforeExpiry > 0 {\n\t\texpires := now.Add(time.Duration(secondsBeforeExpiry) * time.Second)\n\t\tclaims.ExpiresAt = expires.Unix()\n\t}\n\n\treturn mgr.signClaims(claims)\n}\n\nfunc (mgr *SessionManager) signClaims(claims jwt.Claims) (string, error) {\n\tlog.Infof(\"Issuing claims: %v\", claims)\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\tsettings, err := mgr.settingsMgr.GetSettings()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn token.SignedString(settings.ServerSignature)\n}\n\n// Parse tries to parse the provided string and returns the token claims for local login.\nfunc (mgr *SessionManager) Parse(tokenString string) (jwt.Claims, error) {\n\t// Parse takes the token string and a function for looking up the key. The latter is especially\n\t// useful if you use multiple keys for your application.  The standard is to use 'kid' in the\n\t// head of the token to identify which key to use, but the parsed token (head and claims) is provided\n\t// to the callback, providing flexibility.\n\tvar claims jwt.MapClaims\n\tsettings, err := mgr.settingsMgr.GetSettings()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttoken, err := jwt.ParseWithClaims(tokenString, &claims, func(token *jwt.Token) (interface{}, error) {\n\t\t// Don't forget to validate the alg is what you expect:\n\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\treturn nil, fmt.Errorf(\"Unexpected signing method: %v\", token.Header[\"alg\"])\n\t\t}\n\t\treturn settings.ServerSignature, nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsubject := jwtutil.GetField(claims, \"sub\")\n\tif rbacpolicy.IsProjectSubject(subject) {\n\t\treturn token.Claims, nil\n\t}\n\n\taccount, err := mgr.settingsMgr.GetAccount(subject)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif id := jwtutil.GetField(claims, \"jti\"); id != \"\" && account.TokenIndex(id) == -1 {\n\t\treturn nil, fmt.Errorf(\"account %s does not have token with id %s\", subject, id)\n\t}\n\n\tissuedAt := time.Unix(int64(claims[\"iat\"].(float64)), 0)\n\tif account.PasswordMtime != nil && issuedAt.Before(*account.PasswordMtime) {\n\t\treturn nil, fmt.Errorf(\"Account password has changed since token issued\")\n\t}\n\treturn token.Claims, nil\n}\n\n// VerifyUsernamePassword verifies if a username/password combo is correct\nfunc (mgr *SessionManager) VerifyUsernamePassword(username string, password string) error {\n\taccount, err := mgr.settingsMgr.GetAccount(username)\n\tif err != nil {\n\t\tif errStatus, ok := status.FromError(err); ok && errStatus.Code() == codes.NotFound {\n\t\t\terr = status.Errorf(codes.Unauthenticated, invalidLoginError)\n\t\t}\n\t\treturn err\n\t}\n\tif !account.Enabled {\n\t\treturn status.Errorf(codes.Unauthenticated, accountDisabled, username)\n\t}\n\tif password == \"\" {\n\t\treturn status.Errorf(codes.Unauthenticated, blankPasswordError)\n\t}\n\n\tvalid, _ := passwordutil.VerifyPassword(password, account.PasswordHash)\n\tif !valid {\n\t\treturn status.Errorf(codes.Unauthenticated, invalidLoginError)\n\t}\n\treturn nil\n}\n\n// VerifyToken verifies if a token is correct. Tokens can be issued either from us or by an IDP.\n// We choose how to verify based on the issuer.\nfunc (mgr *SessionManager) VerifyToken(tokenString string) (jwt.Claims, error) {\n\tparser := &jwt.Parser{\n\t\tSkipClaimsValidation: true,\n\t}\n\tvar claims jwt.StandardClaims\n\t_, _, err := parser.ParseUnverified(tokenString, &claims)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tswitch claims.Issuer {\n\tcase SessionManagerClaimsIssuer:\n\t\t// Argo CD signed token\n\t\treturn mgr.Parse(tokenString)\n\tdefault:\n\t\t// IDP signed token\n\t\tprov, err := mgr.provider()\n\t\tif err != nil {\n\t\t\treturn claims, err\n\t\t}\n\t\tidToken, err := prov.Verify(claims.Audience, tokenString)\n\t\tif err != nil {\n\t\t\treturn claims, err\n\t\t}\n\t\tvar claims jwt.MapClaims\n\t\terr = idToken.Claims(&claims)\n\t\treturn claims, err\n\t}\n}\n\nfunc (mgr *SessionManager) provider() (oidcutil.Provider, error) {\n\tif mgr.prov != nil {\n\t\treturn mgr.prov, nil\n\t}\n\tsettings, err := mgr.settingsMgr.GetSettings()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !settings.IsSSOConfigured() {\n\t\treturn nil, fmt.Errorf(\"SSO is not configured\")\n\t}\n\tmgr.prov = oidcutil.NewOIDCProvider(settings.IssuerURL(), mgr.client)\n\treturn mgr.prov, nil\n}\n\nfunc LoggedIn(ctx context.Context) bool {\n\treturn Sub(ctx) != \"\"\n}\n\n// Username is a helper to extract a human readable username from a context\nfunc Username(ctx context.Context) string {\n\tmapClaims, ok := mapClaims(ctx)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\tswitch jwtutil.GetField(mapClaims, \"iss\") {\n\tcase SessionManagerClaimsIssuer:\n\t\treturn jwtutil.GetField(mapClaims, \"sub\")\n\tdefault:\n\t\treturn jwtutil.GetField(mapClaims, \"email\")\n\t}\n}\n\nfunc Iss(ctx context.Context) string {\n\tmapClaims, ok := mapClaims(ctx)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn jwtutil.GetField(mapClaims, \"iss\")\n}\n\nfunc Iat(ctx context.Context) (time.Time, error) {\n\tmapClaims, ok := mapClaims(ctx)\n\tif !ok {\n\t\treturn time.Time{}, errors.New(\"unable to extract token claims\")\n\t}\n\tiatField, ok := mapClaims[\"iat\"]\n\tif !ok {\n\t\treturn time.Time{}, errors.New(\"token does not have iat claim\")\n\t}\n\n\tif iat, ok := iatField.(float64); !ok {\n\t\treturn time.Time{}, errors.New(\"iat token field has unexpected type\")\n\t} else {\n\t\treturn time.Unix(int64(iat), 0), nil\n\t}\n}\n\nfunc Sub(ctx context.Context) string {\n\tmapClaims, ok := mapClaims(ctx)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn jwtutil.GetField(mapClaims, \"sub\")\n}\n\nfunc Groups(ctx context.Context) []string {\n\tmapClaims, ok := mapClaims(ctx)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn jwtutil.GetGroups(mapClaims)\n}\n\nfunc mapClaims(ctx context.Context) (jwt.MapClaims, bool) {\n\tclaims, ok := ctx.Value(\"claims\").(jwt.Claims)\n\tif !ok {\n\t\treturn nil, false\n\t}\n\tmapClaims, err := jwtutil.MapClaims(claims)\n\tif err != nil {\n\t\treturn nil, false\n\t}\n\treturn mapClaims, true\n}\n"], "filenames": ["server/session/session.go", "test/e2e/accounts_test.go", "util/session/sessionmanager.go"], "buggy_code_start_loc": [30, 7, 158], "buggy_code_end_loc": [31, 52, 158], "fixing_code_start_loc": [30, 6, 159], "fixing_code_end_loc": [31, 79, 162], "type": "CWE-203", "message": "Fixed in v1.5.1, Argo version v1.5.0 was vulnerable to a user-enumeration vulnerability which allowed attackers to determine the usernames of valid (non-SSO) accounts because /api/v1/session returned 401 for an existing username and 404 otherwise.", "other": {"cve": {"id": "CVE-2020-11576", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-08T18:15:15.323", "lastModified": "2022-04-06T16:32:38.143", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Fixed in v1.5.1, Argo version v1.5.0 was vulnerable to a user-enumeration vulnerability which allowed attackers to determine the usernames of valid (non-SSO) accounts because /api/v1/session returned 401 for an existing username and 404 otherwise."}, {"lang": "es", "value": "Arreglado en v1.5.1, Argo versi\u00f3n v1.5.0 era vulnerable a una vulnerabilidad de enumeraci\u00f3n de usuarios que permit\u00eda a los atacantes determinar los nombres de usuario de cuentas v\u00e1lidas (no SSO) porque / api / v1 / session devolvi\u00f3 401 para un nombre de usuario existente y 404 de lo contrario ."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:argo_continuous_delivery:1.5.0:-:*:*:*:kubernetes:*:*", "matchCriteriaId": "83D0A513-AA9B-48C5-8AA9-D118CF7A790A"}]}]}], "references": [{"url": "https://github.com/argoproj/argo-cd/commit/35a7350b7444bcaf53ee0bb11b9d8e3ae4b717a1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/argoproj/argo-cd/pull/3215", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.soluble.ai/blog/argo-cves-2020", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/argoproj/argo-cd/commit/35a7350b7444bcaf53ee0bb11b9d8e3ae4b717a1"}}