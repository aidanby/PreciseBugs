{"buggy_code": ["// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n//\n// WSO2 Inc. licenses this file to you under the Apache License,\n// Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\npackage org.ballerinalang.cli.module;\n\nimport me.tongfei.progressbar.ProgressBar;\nimport me.tongfei.progressbar.ProgressBarStyle;\nimport org.ballerinalang.cli.module.util.ErrorUtil;\nimport org.ballerinalang.cli.module.util.Utils;\nimport org.ballerinalang.jvm.JSONParser;\nimport org.ballerinalang.jvm.values.MapValue;\n\nimport java.io.BufferedReader;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.Authenticator;\nimport java.net.HttpURLConnection;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\nimport javax.ws.rs.core.HttpHeaders;\n\nimport static org.ballerinalang.cli.module.util.CliModuleConstants.BALLERINA_PLATFORM;\nimport static org.ballerinalang.cli.module.util.CliModuleConstants.BAL_LANG_SPEC_VERSION;\nimport static org.ballerinalang.cli.module.util.CliModuleConstants.IDENTITY;\nimport static org.ballerinalang.cli.module.util.CliModuleConstants.RESOLVED_REQUESTED_URI;\nimport static org.ballerinalang.cli.module.util.Utils.convertToUrl;\nimport static org.ballerinalang.cli.module.util.Utils.createHttpUrlConnection;\nimport static org.ballerinalang.cli.module.util.Utils.getStatusCode;\nimport static org.ballerinalang.cli.module.util.Utils.initializeSsl;\nimport static org.ballerinalang.cli.module.util.Utils.setRequestMethod;\n\n/**\n * This class is pulling the modules from ballerina central.\n *\n * @since 1.2.0\n */\npublic class Pull {\n    private static final String VERSION_REGEX = \"(\\\\d+\\\\.)(\\\\d+\\\\.)(\\\\d+)\";\n    private static PrintStream outStream = System.out;\n    private static DefaultLogFormatter logFormatter = new DefaultLogFormatter();\n\n    private Pull() {\n    }\n\n    /**\n     * Execute pull command.\n     *\n     * @param url                   remote uri of the central\n     * @param modulePathInBaloCache module path in balo cache, user.home/.ballerina/balo_cache/org_name/module_name\n     * @param moduleNameWithOrg     module name with org, org_name/module_name\n     * @param proxyHost             proxy host\n     * @param proxyPort             proxy port\n     * @param proxyUsername         proxy username\n     * @param proxyPassword         proxy password\n     * @param supportedVersionRange supported version range\n     * @param isBuild               pulling happens when building\n     * @param isNightlyBuild        is nightly build\n     * @param langSpecVersion       lang spec version\n     * @param platform              supported version\n     */\n    public static void execute(String url, String modulePathInBaloCache, String moduleNameWithOrg, String proxyHost,\n            int proxyPort, String proxyUsername, String proxyPassword, String supportedVersionRange, boolean isBuild,\n            boolean isNightlyBuild, String langSpecVersion, String platform) {\n        if (isBuild) {\n            logFormatter = new BuildLogFormatter();\n        }\n\n        HttpURLConnection conn = null;\n        try {\n            initializeSsl();\n            conn = createHttpUrlConnection(convertToUrl(url + supportedVersionRange), proxyHost, proxyPort,\n                    proxyUsername, proxyPassword);\n\n            conn.setInstanceFollowRedirects(false);\n            setRequestMethod(conn, Utils.RequestMethod.GET);\n\n            // Set headers\n            conn.setRequestProperty(BALLERINA_PLATFORM, platform);\n            conn.setRequestProperty(BAL_LANG_SPEC_VERSION, langSpecVersion);\n            conn.setRequestProperty(HttpHeaders.ACCEPT_ENCODING, IDENTITY);\n\n            boolean redirect = false;\n            // 302 - Module is found\n            // Other - Error occurred, json returned with the error message\n            if (getStatusCode(conn) == HttpURLConnection.HTTP_MOVED_TEMP) {\n                redirect = true;\n            } else {\n                handleErrorResponse(conn, url, moduleNameWithOrg);\n            }\n\n            if (redirect) {\n                // get redirect url from \"location\" header field\n                String newUrl = conn.getHeaderField(HttpHeaders.LOCATION);\n                String contentDisposition = conn.getHeaderField(HttpHeaders.CONTENT_DISPOSITION);\n\n                conn = createHttpUrlConnection(convertToUrl(newUrl), proxyHost, proxyPort, proxyUsername,\n                        proxyPassword);\n                conn.setRequestProperty(HttpHeaders.CONTENT_DISPOSITION, contentDisposition);\n\n                createBaloInHomeRepo(conn, modulePathInBaloCache, moduleNameWithOrg, isNightlyBuild, newUrl,\n                        contentDisposition);\n            }\n        } catch (Exception e) {\n            throw ErrorUtil.createCommandException(e.getMessage());\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n            Authenticator.setDefault(null);\n        }\n    }\n\n    /**\n     * Create the balo in home repo.\n     *\n     * @param conn                  http connection\n     * @param modulePathInBaloCache module path in balo cache, <user.home>.ballerina/balo_cache/<org-name>/<module-name>\n     * @param moduleNameWithOrg     module name with org, <org-name>/<module-name>\n     * @param isNightlyBuild        is nightly build\n     * @param newUrl                new redirect url\n     * @param contentDisposition    content disposition header\n     */\n    private static void createBaloInHomeRepo(HttpURLConnection conn, String modulePathInBaloCache,\n            String moduleNameWithOrg, boolean isNightlyBuild, String newUrl, String contentDisposition) {\n        long responseContentLength = conn.getContentLengthLong();\n        if (responseContentLength <= 0) {\n            createError(\"invalid response from the server, please try again\");\n        }\n        String resolvedURI = conn.getHeaderField(RESOLVED_REQUESTED_URI);\n        if (resolvedURI == null || resolvedURI.equals(\"\")) {\n            resolvedURI = newUrl;\n        }\n        String[] uriParts = resolvedURI.split(\"/\");\n        String moduleVersion = uriParts[uriParts.length - 3];\n\n        validateModuleVersion(moduleVersion);\n        String baloFile = getBaloFileName(contentDisposition, uriParts[uriParts.length - 1]);\n        Path baloCacheWithModulePath = Paths.get(modulePathInBaloCache, moduleVersion);\n        //<user.home>.ballerina/balo_cache/<org-name>/<module-name>/<module-version>\n\n        Path baloPath = Paths.get(baloCacheWithModulePath.toString(), baloFile);\n        if (baloPath.toFile().exists()) {\n            createError(\"module already exists in the home repository: \" + baloPath.toString());\n        }\n\n        createBaloFileDirectory(baloCacheWithModulePath);\n        writeBaloFile(conn, baloPath, moduleNameWithOrg + \":\" + moduleVersion, responseContentLength);\n        handleNightlyBuild(isNightlyBuild, baloCacheWithModulePath);\n    }\n\n    /**\n     * Write balo file to the home repo.\n     *\n     * @param conn             http connection\n     * @param baloPath         path of the balo file\n     * @param fullModuleName   full module name, <org-name>/<module-name>:<module-version>\n     * @param resContentLength response content length\n     */\n    private static void writeBaloFile(HttpURLConnection conn, Path baloPath, String fullModuleName,\n            long resContentLength) {\n        try (InputStream inputStream = conn.getInputStream();\n                FileOutputStream outputStream = new FileOutputStream(baloPath.toString())) {\n            writeAndHandleProgress(inputStream, outputStream, resContentLength / 1024, fullModuleName);\n        } catch (IOException e) {\n            createError(\"error occurred copying the balo file: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Show progress of the writing the balo file.\n     *\n     * @param inputStream    response input stream\n     * @param outputStream   home repo balo file output stream\n     * @param totalSizeInKB  response input stream size in kb\n     * @param fullModuleName full module name, <org-name>/<module-name>:<module-version>\n     */\n    private static void writeAndHandleProgress(InputStream inputStream, FileOutputStream outputStream,\n            long totalSizeInKB, String fullModuleName) {\n        int count;\n        byte[] buffer = new byte[1024];\n\n        try (ProgressBar progressBar = new ProgressBar(fullModuleName + \" [central.ballerina.io -> home repo] \",\n                totalSizeInKB, 1000, outStream, ProgressBarStyle.ASCII, \" KB\", 1)) {\n            while ((count = inputStream.read(buffer)) > 0) {\n                outputStream.write(buffer, 0, count);\n                progressBar.step();\n            }\n        } catch (IOException e) {\n            outStream.println(logFormatter.formatLog(fullModuleName + \"pulling the module from central failed\"));\n        } finally {\n            outStream.println(logFormatter.formatLog(fullModuleName + \" pulled from central successfully\"));\n        }\n    }\n\n    /**\n     * Handle nightly build.\n     *\n     * @param isNightlyBuild          is nightly build\n     * @param baloCacheWithModulePath balo cache with module path\n     */\n    private static void handleNightlyBuild(boolean isNightlyBuild, Path baloCacheWithModulePath) {\n        if (isNightlyBuild) {\n            // If its a nightly build tag the file as a module from nightly\n            Path nightlyBuildMetaFile = Paths.get(baloCacheWithModulePath.toString(), \"nightly.build\");\n            if (!nightlyBuildMetaFile.toFile().exists()) {\n                createNightlyBuildMetaFile(nightlyBuildMetaFile);\n            }\n        }\n    }\n\n    /**\n     * Validate module version with the regex.\n     *\n     * @param moduleVersion module version\n     */\n    private static void validateModuleVersion(String moduleVersion) {\n        if (!moduleVersion.matches(VERSION_REGEX)) {\n            createError(\"module version could not be detected\");\n        }\n    }\n\n    /**\n     * Create nightly build meta file.\n     *\n     * @param nightlyBuildMetaFilePath nightly build meta file path\n     */\n    private static void createNightlyBuildMetaFile(Path nightlyBuildMetaFilePath) {\n        try {\n            Files.createFile(nightlyBuildMetaFilePath);\n        } catch (Exception e) {\n            createError(\"error occurred while creating nightly.build file.\");\n        }\n    }\n\n    /**\n     * Create balo file directory.\n     *\n     * @param fullPathToStoreBalo full path to store the balo file\n     *                            <user.home>.ballerina/balo_cache/<org-name>/<module-name>/<module-version>\n     */\n    private static void createBaloFileDirectory(Path fullPathToStoreBalo) {\n        try {\n            Files.createDirectory(fullPathToStoreBalo);\n        } catch (IOException e) {\n            createError(\"error creating directory for balo file\");\n        }\n    }\n\n    /**\n     * Handle error response.\n     *\n     * @param conn           http connection\n     * @param url            remote repository url\n     * @param moduleFullName module name with org and version\n     */\n    private static void handleErrorResponse(HttpURLConnection conn, String url, String moduleFullName) {\n        try (BufferedReader reader = new BufferedReader(\n                new InputStreamReader(conn.getErrorStream(), Charset.defaultCharset()))) {\n            StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                result.append(line);\n            }\n\n            MapValue payload = (MapValue) JSONParser.parse(result.toString());\n            createError(\"error: \" + payload.getStringValue(\"message\"));\n        } catch (IOException e) {\n            createError(\"failed to pull the module '\" + moduleFullName + \"' from the remote repository '\" + url + \"'\");\n        }\n    }\n\n    /**\n     * Create error using log formatter.\n     *\n     * @param errMessage error message\n     */\n    private static void createError(String errMessage) {\n        throw ErrorUtil.createCommandException(logFormatter.formatLog(errMessage));\n    }\n\n    /**\n     * Get balo file name from content disposition header.\n     *\n     * @param contentDisposition content disposition header value\n     * @param baloFile           balo file name taken from RESOLVED_REQUESTED_URI\n     * @return balo file name\n     */\n    private static String getBaloFileName(String contentDisposition, String baloFile) {\n        if (contentDisposition != null && !contentDisposition.equals(\"\")) {\n            return contentDisposition.substring(\"attachment; filename=\".length());\n        } else {\n            return baloFile;\n        }\n    }\n}\n\n/**\n * Default log formatter class.\n */\nclass DefaultLogFormatter {\n    String formatLog(String msg) {\n        return msg;\n    }\n}\n\n/**\n * Build log formatter class which used to log the message for build command.\n */\nclass BuildLogFormatter extends DefaultLogFormatter {\n    @Override String formatLog(String msg) {\n        return \"\\t\" + msg;\n    }\n}\n", "// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n//\n// WSO2 Inc. licenses this file to you under the Apache License,\n// Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\npackage org.ballerinalang.cli.module;\n\nimport me.tongfei.progressbar.ProgressBar;\nimport me.tongfei.progressbar.ProgressBarStyle;\nimport org.ballerinalang.cli.module.util.ErrorUtil;\nimport org.ballerinalang.cli.module.util.Utils;\nimport org.ballerinalang.jvm.JSONParser;\nimport org.ballerinalang.jvm.values.MapValue;\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.Authenticator;\nimport java.net.HttpURLConnection;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport javax.ws.rs.core.HttpHeaders;\nimport javax.ws.rs.core.MediaType;\n\nimport static org.ballerinalang.cli.module.util.CliModuleConstants.PUSH_ORGANIZATION;\nimport static org.ballerinalang.cli.module.util.Utils.convertToUrl;\nimport static org.ballerinalang.cli.module.util.Utils.createHttpUrlConnection;\nimport static org.ballerinalang.cli.module.util.Utils.getStatusCode;\nimport static org.ballerinalang.cli.module.util.Utils.initializeSsl;\nimport static org.ballerinalang.cli.module.util.Utils.setRequestMethod;\n\n/**\n * This class is pushing the modules to ballerina central.\n *\n * @since 1.2.0\n */\npublic class Push {\n\n    private static PrintStream errStream = System.err;\n    private static PrintStream outStream = System.out;\n    private static final int NO_OF_BYTES = 64;\n    private static final int BUFFER_SIZE = 1024 * NO_OF_BYTES;\n\n    private Push() {\n    }\n\n    /**\n     * Execute push command.\n     *\n     * @param url           remote uri of the central\n     * @param proxyHost     proxy host\n     * @param proxyPort     proxy port\n     * @param proxyUsername proxy username\n     * @param proxyPassword proxy password\n     * @param accessToken   access token of the org\n     * @param orgName       org name\n     * @param moduleName    module name\n     * @param version       module version\n     * @param baloPath      path to the balo\n     */\n    public static void execute(String url, String proxyHost, int proxyPort, String proxyUsername, String proxyPassword,\n            String accessToken, String orgName, String moduleName, String version, Path baloPath) {\n        initializeSsl();\n        HttpURLConnection conn = createHttpUrlConnection(convertToUrl(url), proxyHost, proxyPort, proxyUsername,\n                proxyPassword);\n        conn.setInstanceFollowRedirects(false);\n        setRequestMethod(conn, Utils.RequestMethod.POST);\n\n        // Set headers\n        conn.setRequestProperty(HttpHeaders.AUTHORIZATION, \"Bearer \" + accessToken);\n        conn.setRequestProperty(PUSH_ORGANIZATION, orgName);\n        conn.setRequestProperty(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_OCTET_STREAM);\n\n        conn.setDoOutput(true);\n        conn.setChunkedStreamingMode(BUFFER_SIZE);\n\n        try (DataOutputStream outputStream = new DataOutputStream(conn.getOutputStream())) {\n            // Send balo content by 1 kb chunks\n            byte[] buffer = new byte[BUFFER_SIZE];\n            int count;\n            try (ProgressBar progressBar = new ProgressBar(\n                    orgName + \"/\" + moduleName + \":\" + version + \" [project repo -> central]\",\n                    getTotalFileSizeInKB(baloPath), 1000, outStream, ProgressBarStyle.ASCII, \" KB\", 1);\n                    FileInputStream fis = new FileInputStream(baloPath.toFile())) {\n                while ((count = fis.read(buffer)) > 0) {\n                    outputStream.write(buffer, 0, count);\n                    outputStream.flush();\n                    progressBar.stepBy((long) NO_OF_BYTES);\n                }\n            }\n        } catch (IOException e) {\n            throw ErrorUtil.createCommandException(\"error occurred while uploading balo to central: \" + e.getMessage());\n        }\n\n        handleResponse(conn, orgName, moduleName, version);\n        Authenticator.setDefault(null);\n    }\n\n    /**\n     * Handle the http response.\n     *\n     * @param conn       http connection\n     * @param orgName    org name\n     * @param moduleName module name\n     * @param version    module version\n     */\n    private static void handleResponse(HttpURLConnection conn, String orgName, String moduleName, String version) {\n        try {\n            int statusCode = getStatusCode(conn);\n            // 200 - Module pushed successfully\n            // Other - Error occurred, json returned with the error message\n            if (statusCode == HttpURLConnection.HTTP_OK) {\n                outStream.println(orgName + \"/\" + moduleName + \":\" + version + \" pushed to central successfully\");\n            } else if (statusCode == HttpURLConnection.HTTP_UNAUTHORIZED) {\n                errStream.println(\"unauthorized access token for organization: \" + orgName);\n            } else if (statusCode == HttpURLConnection.HTTP_BAD_REQUEST) {\n                try (BufferedReader reader = new BufferedReader(\n                        new InputStreamReader(conn.getErrorStream(), Charset.defaultCharset()))) {\n                    StringBuilder result = new StringBuilder();\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        result.append(line);\n                    }\n\n                    MapValue payload = (MapValue) JSONParser.parse(result.toString());\n                    String message = payload.getStringValue(\"message\");\n                    if (message.contains(\"module md file cannot be empty\")) {\n                        errStream.println(message);\n                    } else {\n                        throw ErrorUtil.createCommandException(message);\n                    }\n                } catch (IOException e) {\n                    throw ErrorUtil.createCommandException(\n                            \"failed to push the module '\" + orgName + \"/\" + moduleName + \":\" + version\n                                    + \"' to the remote repository '\" + conn.getURL() + \"'\");\n                }\n            } else {\n                throw ErrorUtil.createCommandException(\n                        \"failed to push the module '\" + orgName + \"/\" + moduleName + \":\" + version\n                                + \"' to the remote repository '\" + conn.getURL() + \"'\");\n            }\n        } finally {\n            conn.disconnect();\n        }\n    }\n\n    /**\n     * Get total file size in kb.\n     *\n     * @param filePath path to the file\n     * @return size of the file in kb\n     */\n    private static long getTotalFileSizeInKB(Path filePath) {\n        byte[] baloContent;\n        try {\n            baloContent = Files.readAllBytes(filePath);\n            return baloContent.length / 1024;\n        } catch (IOException e) {\n            throw ErrorUtil.createCommandException(\"cannot read the balo content\");\n        }\n    }\n}\n", "// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n//\n// WSO2 Inc. licenses this file to you under the Apache License,\n// Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\npackage org.ballerinalang.cli.module;\n\nimport org.ballerinalang.cli.module.util.ErrorUtil;\nimport org.ballerinalang.cli.module.util.Utils;\nimport org.ballerinalang.jvm.JSONParser;\nimport org.ballerinalang.jvm.values.ArrayValue;\nimport org.ballerinalang.jvm.values.MapValue;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.Authenticator;\nimport java.net.HttpURLConnection;\nimport java.nio.charset.Charset;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nimport static org.ballerinalang.cli.module.util.Utils.convertToUrl;\nimport static org.ballerinalang.cli.module.util.Utils.createHttpUrlConnection;\nimport static org.ballerinalang.cli.module.util.Utils.getStatusCode;\nimport static org.ballerinalang.cli.module.util.Utils.initializeSsl;\nimport static org.ballerinalang.cli.module.util.Utils.setRequestMethod;\n\n/**\n * This class is searching modules from ballerina central.\n *\n * @since 1.2.0\n */\npublic class Search {\n\n    private static PrintStream outStream = System.out;\n\n    private Search() {\n    }\n\n    /**\n     * Execute search command.\n     *\n     * @param url           remote uri of the central\n     * @param proxyHost     proxy host\n     * @param proxyPort     proxy port\n     * @param proxyUsername proxy username\n     * @param proxyPassword proxy password\n     * @param terminalWidth terminal width of the CLI\n     */\n    public static void execute(String url, String proxyHost, int proxyPort, String proxyUsername, String proxyPassword,\n            String terminalWidth) {\n        initializeSsl();\n        HttpURLConnection conn = createHttpUrlConnection(convertToUrl(url), proxyHost, proxyPort, proxyUsername,\n                proxyPassword);\n        conn.setInstanceFollowRedirects(false);\n        setRequestMethod(conn, Utils.RequestMethod.GET);\n        handleResponse(conn, getStatusCode(conn), terminalWidth);\n        Authenticator.setDefault(null);\n    }\n\n    /**\n     * Handle http response.\n     *\n     * @param conn          http connection\n     * @param statusCode    status code of the response\n     * @param terminalWidth terminal width of the CLI\n     */\n    private static void handleResponse(HttpURLConnection conn, int statusCode, String terminalWidth) {\n        try {\n            // 200 - modules found\n            // Other - Error occurred, json returned with the error message\n            MapValue payload;\n            if (statusCode == HttpURLConnection.HTTP_OK) {\n                try (BufferedReader reader = new BufferedReader(\n                        new InputStreamReader(conn.getInputStream(), Charset.defaultCharset()))) {\n                    StringBuilder result = new StringBuilder();\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        result.append(line);\n                    }\n                    payload = (MapValue) JSONParser.parse(result.toString());\n                } catch (IOException e) {\n                    throw ErrorUtil.createCommandException(e.getMessage());\n                }\n\n                if (payload.getIntValue(\"count\") > 0) {\n                    ArrayValue modules = payload.getArrayValue(\"modules\");\n                    printModules(modules, terminalWidth);\n                } else {\n                    outStream.println(\"no modules found\");\n                }\n            } else {\n                StringBuilder result = new StringBuilder();\n                try (BufferedReader reader = new BufferedReader(\n                        new InputStreamReader(conn.getErrorStream(), Charset.defaultCharset()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        result.append(line);\n                    }\n                } catch (IOException e) {\n                    throw ErrorUtil.createCommandException(e.getMessage());\n                }\n\n                payload = (MapValue) JSONParser.parse(result.toString());\n                throw ErrorUtil.createCommandException(payload.getStringValue(\"message\"));\n            }\n        } finally {\n            conn.disconnect();\n        }\n    }\n\n    /**\n     * Print module information as a table in the CLI.\n     *\n     * @param modules       modules array\n     * @param terminalWidth terminal width of the CLI\n     */\n    public static void printModules(ArrayValue modules, String terminalWidth) {\n        int rightMargin = 3;\n        int width = Integer.parseInt(terminalWidth) - rightMargin;\n        int dateColWidth = 15;\n        int versionColWidth = 8;\n        int authorsColWidth = 15;\n        double nameColFactor = 9.0;\n        double descColFactor = 16.0;\n        int additionalSpace = 7;\n        double remainingWidth = (double) width - (dateColWidth + versionColWidth + additionalSpace);\n        int nameColWidth = (int) Math.round(remainingWidth * (nameColFactor / (nameColFactor + descColFactor)));\n        int descColWidth = (int) Math.round(remainingWidth * (descColFactor / (nameColFactor + descColFactor)));\n        int minDescColWidth = 60;\n\n        printTitle();\n        printTableHeader(dateColWidth, versionColWidth, nameColWidth, descColWidth, minDescColWidth, authorsColWidth);\n\n        int i = 0;\n        while (i < modules.size()) {\n            printModule((MapValue) modules.get(i), dateColWidth, versionColWidth, authorsColWidth, nameColWidth,\n                    descColWidth, minDescColWidth);\n            i = i + 1;\n            outStream.println();\n        }\n        outStream.println();\n        outStream.println(modules.size() + \" modules found\");\n    }\n\n    /**\n     * Print module row.\n     *\n     * @param module          module information\n     * @param dateColWidth    date column width\n     * @param versionColWidth version column width\n     * @param nameColWidth    name column width\n     * @param descColWidth    description column width\n     * @param minDescColWidth minimum description column width\n     * @param authorsColWidth authors column width\n     */\n    private static void printModule(MapValue module, int dateColWidth, int versionColWidth, int authorsColWidth,\n            int nameColWidth, int descColWidth, int minDescColWidth) {\n        String orgName = module.getStringValue(\"orgName\");\n        String packageName = module.getStringValue(\"name\");\n        printInCLI(\"|\" + orgName + \"/\" + packageName, nameColWidth);\n\n        String summary = module.getStringValue(\"summary\");\n\n        if (descColWidth >= minDescColWidth) {\n            printInCLI(summary, descColWidth - authorsColWidth);\n            String authors = \"\";\n            ArrayValue authorsArr = module.getArrayValue(\"authors\");\n\n            if (authorsArr.size() > 0) {\n                for (int j = 0; j < authorsArr.size(); j++) {\n                    if (j == 0) {\n                        authors = (String) authorsArr.get(j);\n                    } else if (j == authorsArr.size() - 1) {\n                        authors = (String) authorsArr.get(j);\n                    } else {\n                        authors = \", \" + authorsArr.get(j);\n                    }\n                }\n            }\n            printInCLI(authors, authorsColWidth);\n        } else {\n            printInCLI(summary, descColWidth);\n        }\n\n        long createTimeJson = module.getIntValue(\"createdDate\");\n        printInCLI(getDateCreated(createTimeJson), dateColWidth);\n\n        String packageVersion = module.getStringValue(\"version\");\n        printInCLI(packageVersion, versionColWidth);\n    }\n\n    /**\n     * Print the tile.\n     */\n    private static void printTitle() {\n        outStream.println();\n        outStream.println(\"Ballerina Central\");\n        outStream.println(\"=================\");\n        outStream.println();\n    }\n\n    /**\n     * Print in CLI.\n     *\n     * @param element           printing element\n     * @param charactersAllowed number of characters allowed\n     */\n    private static void printInCLI(String element, int charactersAllowed) {\n        int lengthOfElement = element.length();\n        if (lengthOfElement > charactersAllowed || lengthOfElement == charactersAllowed) {\n            int margin = 3;\n            String trimmedElement = element.substring(0, charactersAllowed - margin) + \"...\";\n            outStream.print(trimmedElement + \" |\");\n        } else {\n            printCharacter(element, charactersAllowed, \" \", false);\n        }\n    }\n\n    /**\n     * Print characters.\n     *\n     * @param element           printing element\n     * @param charactersAllowed number of characters allowed\n     * @param separator         separating element\n     * @param isDashElement     is a dash element\n     */\n    private static void printCharacter(String element, int charactersAllowed, String separator, boolean isDashElement) {\n        int lengthOfElement = element.length();\n        StringBuilder print = new StringBuilder(element);\n        int i = 0;\n        while (i < charactersAllowed - lengthOfElement) {\n            print.append(separator);\n            i = i + 1;\n        }\n        if (isDashElement) {\n            outStream.print(print + \"-|\");\n        } else {\n            outStream.print(print + \" |\");\n        }\n    }\n\n    /**\n     * Get date in simple date format.\n     *\n     * @param timeInMillis date in millis\n     * @return date in simple date format\n     */\n    private static String getDateCreated(long timeInMillis) {\n        Date date = new Date(timeInMillis);\n        DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd-E\");\n        return df.format(date);\n    }\n\n    /**\n     * Print table header.\n     *\n     * @param dateColWidth    date column width\n     * @param versionColWidth version column width\n     * @param nameColWidth    name column width\n     * @param descColWidth    description column width\n     * @param minDescColWidth minimum description column width\n     * @param authorsColWidth authors column width\n     */\n    private static void printTableHeader(int dateColWidth, int versionColWidth, int nameColWidth, int descColWidth,\n            int minDescColWidth, int authorsColWidth) {\n        printHeadingRow(dateColWidth, versionColWidth, nameColWidth, descColWidth, minDescColWidth, authorsColWidth);\n        printDashRow(dateColWidth, versionColWidth, nameColWidth, descColWidth, minDescColWidth, authorsColWidth);\n    }\n\n    /**\n     * Print heading row of the table header.\n     *\n     * @param dateColWidth    date column width\n     * @param versionColWidth version column width\n     * @param nameColWidth    name column width\n     * @param descColWidth    description column width\n     * @param minDescColWidth minimum description column width\n     * @param authorsColWidth authors column width\n     */\n    private static void printHeadingRow(int dateColWidth, int versionColWidth, int nameColWidth, int descColWidth,\n            int minDescColWidth, int authorsColWidth) {\n        printInCLI(\"|NAME\", nameColWidth);\n        if (descColWidth >= minDescColWidth) {\n            printInCLI(\"DESCRIPTION\", descColWidth - authorsColWidth);\n            printInCLI(\"AUTHOR\", authorsColWidth);\n        } else {\n            printInCLI(\"DESCRIPTION\", descColWidth);\n        }\n        printInCLI(\"DATE\", dateColWidth);\n        printInCLI(\"VERSION\", versionColWidth);\n        outStream.println();\n    }\n\n    /**\n     * Print dash row of the table header.\n     *\n     * @param dateColWidth    date column width\n     * @param versionColWidth version column width\n     * @param nameColWidth    name column width\n     * @param descColWidth    description column width\n     * @param minDescColWidth minimum description column width\n     * @param authorsColWidth authors column width\n     */\n    private static void printDashRow(int dateColWidth, int versionColWidth, int nameColWidth, int descColWidth,\n            int minDescColWidth, int authorsColWidth) {\n        printCharacter(\"|-\", nameColWidth, \"-\", true);\n\n        if (descColWidth >= minDescColWidth) {\n            printCharacter(\"-\", descColWidth - authorsColWidth, \"-\", true);\n            printCharacter(\"-\", authorsColWidth, \"-\", true);\n        } else {\n            printCharacter(\"-\", descColWidth, \"-\", true);\n        }\n\n        printCharacter(\"-\", dateColWidth, \"-\", true);\n        printCharacter(\"-\", versionColWidth, \"-\", true);\n\n        outStream.println();\n    }\n}\n", "// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n//\n// WSO2 Inc. licenses this file to you under the Apache License,\n// Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\npackage org.ballerinalang.cli.module;\n\nimport com.sun.net.httpserver.HttpExchange;\nimport com.sun.net.httpserver.HttpHandler;\nimport com.sun.net.httpserver.HttpServer;\nimport org.ballerinalang.cli.module.util.ErrorUtil;\n\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Paths;\nimport java.util.Collections;\n\nimport javax.ws.rs.core.HttpHeaders;\n\nimport static org.ballerinalang.cli.module.util.CliModuleConstants.SETTINGS_TOML_FILE;\n\n/**\n * This class has a service which updates the access token in the `Settings.toml` file.\n *\n * @since 1.2.0\n */\npublic class TokenUpdater {\n\n    private static PrintStream errStream = System.err;\n    private static PrintStream outStream = System.out;\n\n    private TokenUpdater() {\n    }\n\n    /**\n     * Creating the server which updates the access token in the `Settings.toml` file.\n     *\n     * @param settingsTomlFilePath `Settings.toml` file path\n     */\n    public static void execute(String settingsTomlFilePath) {\n        HttpServer server;\n        try {\n            server = HttpServer.create(new InetSocketAddress(9295), 0);\n        } catch (IOException e) {\n            throw ErrorUtil.createCommandException(\"error occurred while creating the server: \" + e.getMessage() +\n                    \"Access token is missing in \" + settingsTomlFilePath +\n                    \"\\nAuto update failed. Please visit https://central.ballerina.io, get token and add it to the\" +\n                    settingsTomlFilePath + \" file.\");\n        }\n        server.createContext(\"/update-settings\", new TokenUpdateHandler());\n        server.setExecutor(null); // creates a default executor\n        server.start();\n    }\n\n    /**\n     * Http handler of the server.\n     */\n    static class TokenUpdateHandler implements HttpHandler {\n\n        @Override public void handle(HttpExchange httpExchange) {\n            String token = getToken(httpExchange.getRequestURI().getPath());\n            String currentUsersHomeDir = System.getProperty(\"user.home\");\n            String settingsTomlPath = String.valueOf(Paths.get(currentUsersHomeDir, \".ballerina\", SETTINGS_TOML_FILE));\n            FileOutputStream outputStream = null;\n            try {\n                outputStream = new FileOutputStream(settingsTomlPath);\n                String str = \"[central]\\naccesstoken=\\\"\" + token + \"\\\"\";\n                outputStream.write(str.getBytes(StandardCharsets.UTF_8));\n            } catch (FileNotFoundException e) {\n                throw ErrorUtil.createCommandException(\"Settings.toml file could not be found: \" + settingsTomlPath);\n            } catch (IOException e) {\n                throw ErrorUtil.createCommandException(\n                        \"error occurred while writing to the Settings.toml file: \" + e.getMessage());\n            } finally {\n                try {\n                    if (outputStream != null) {\n                        outputStream.close();\n                    }\n                } catch (IOException e) {\n                    errStream.println(\"error occurred while closing the output stream: \" + e.getMessage());\n                }\n            }\n            outStream.println(\"token updated\");\n\n            OutputStream os = null;\n            try {\n                String response = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"/>\";\n                httpExchange.getResponseHeaders()\n                        .put(HttpHeaders.CONTENT_TYPE, Collections.singletonList(\"image/svg+xml\"));\n                httpExchange.sendResponseHeaders(HttpURLConnection.HTTP_OK,\n                        response.getBytes(StandardCharsets.UTF_8).length);\n                os = httpExchange.getResponseBody();\n                os.write(response.getBytes(StandardCharsets.UTF_8));\n            } catch (IOException e) {\n                throw ErrorUtil\n                        .createCommandException(\"error occurred while generating the response: \" + e.getMessage());\n            } finally {\n                try {\n                    if (os != null) {\n                        os.close();\n                    }\n                } catch (IOException e) {\n                    errStream.println(\"error occurred while closing the output stream: \" + e.getMessage());\n                }\n            }\n        }\n\n        /**\n         * Get access token from url.\n         *\n         * @param uri url with access token\n         * @return access token\n         */\n        private static String getToken(String uri) {\n            String[] uriParts = uri.split(\"/\");\n            return uriParts[uriParts.length - 1];\n        }\n    }\n}\n", "// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n//\n// WSO2 Inc. licenses this file to you under the Apache License,\n// Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\npackage org.ballerinalang.cli.module.util;\n\nimport java.io.IOException;\nimport java.net.Authenticator;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.PasswordAuthentication;\nimport java.net.ProtocolException;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\nimport static org.ballerinalang.cli.module.util.CliModuleConstants.SSL;\n\n/**\n * Class contains miscellaneous utility methods.\n *\n * @since 1.2.0\n */\npublic class Utils {\n\n    /**\n     * Request method types.\n     */\n    public enum RequestMethod {\n        GET, POST\n    }\n\n    private static TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n        public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n            return new java.security.cert.X509Certificate[] {};\n        }\n\n        public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n            //No need to implement.\n        }\n\n        public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n            //No need to implement.\n        }\n    } };\n\n    /**\n     * Get proxy for http connection.\n     *\n     * @param proxyHost     proxy host\n     * @param proxyPort     proxy port\n     * @param proxyUsername proxy username\n     * @param proxyPassword proxy password\n     * @return The proxy object.\n     */\n    public static Proxy getProxy(String proxyHost, int proxyPort, String proxyUsername, String proxyPassword) {\n        if (!\"\".equals(proxyHost)) {\n            InetSocketAddress proxyInet = new InetSocketAddress(proxyHost, proxyPort);\n            if (!\"\".equals(proxyUsername) && \"\".equals(proxyPassword)) {\n                Authenticator authenticator = new Authenticator() {\n                    @Override public PasswordAuthentication getPasswordAuthentication() {\n                        return (new PasswordAuthentication(proxyUsername, proxyPassword.toCharArray()));\n                    }\n                };\n                Authenticator.setDefault(authenticator);\n            }\n            return new Proxy(Proxy.Type.HTTP, proxyInet);\n        }\n        return null;\n    }\n\n    /**\n     * Convert string to URL.\n     *\n     * @param url string URL\n     * @return URL\n     */\n    public static URL convertToUrl(String url) {\n        try {\n            return new URL(url);\n        } catch (MalformedURLException e) {\n            throw ErrorUtil.createCommandException(e.getMessage());\n        }\n    }\n\n    /**\n     * Initialize SSL.\n     */\n    public static void initializeSsl() {\n        try {\n            SSLContext sc = SSLContext.getInstance(SSL);\n            sc.init(null, trustAllCerts, new java.security.SecureRandom());\n            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n        } catch (NoSuchAlgorithmException | KeyManagementException e) {\n            throw ErrorUtil.createCommandException(\"initializing SSL failed: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Create http URL connection.\n     *\n     * @param url           connection URL\n     * @param proxyHost     proxy host\n     * @param proxyPort     proxy port\n     * @param proxyUsername proxy username\n     * @param proxyPassword proxy password\n     * @return http URL connection\n     */\n    public static HttpURLConnection createHttpUrlConnection(URL url, String proxyHost, int proxyPort,\n            String proxyUsername, String proxyPassword) {\n        try {\n            Proxy proxy = getProxy(proxyHost, proxyPort, proxyUsername, proxyPassword);\n            // set proxy if exists.\n            if (proxy == null) {\n                return (HttpURLConnection) url.openConnection();\n            } else {\n                return (HttpURLConnection) url.openConnection(proxy);\n            }\n        } catch (IOException e) {\n            throw ErrorUtil.createCommandException(e.getMessage());\n        }\n    }\n\n    /**\n     * Set request method of the http connection.\n     *\n     * @param conn   http connection\n     * @param method request method\n     */\n    public static void setRequestMethod(HttpURLConnection conn, RequestMethod method) {\n        try {\n            conn.setRequestMethod(getRequestMethodAsString(method));\n        } catch (ProtocolException e) {\n            throw ErrorUtil.createCommandException(e.getMessage());\n        }\n    }\n\n    private static String getRequestMethodAsString(RequestMethod method) {\n        switch (method) {\n        case GET:\n            return \"GET\";\n        case POST:\n            return \"POST\";\n        default:\n            throw ErrorUtil.createCommandException(\"invalid request method:\" + method);\n        }\n    }\n\n    /**\n     * Get status code of http response.\n     *\n     * @param conn http connection\n     * @return status code\n     */\n    public static int getStatusCode(HttpURLConnection conn) {\n        try {\n            return conn.getResponseCode();\n        } catch (IOException e) {\n            throw ErrorUtil\n                    .createCommandException(\"connection to the remote repository host failed: \" + e.getMessage());\n        }\n    }\n}\n", "/*\n * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n *\n * WSO2 Inc. licenses this file to you under the Apache License,\n * Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.ballerinalang.cli.module;\n\nimport org.ballerinalang.cli.module.util.Utils;\nimport org.testng.Assert;\nimport org.testng.annotations.Test;\n\nimport java.net.HttpURLConnection;\nimport java.net.Proxy;\n\nimport static org.ballerinalang.cli.module.util.Utils.convertToUrl;\nimport static org.ballerinalang.cli.module.util.Utils.createHttpUrlConnection;\n\n/**\n * Unit tests for Utils class.\n *\n * @since 1.2.0\n */\npublic class UtilsTest {\n\n    private static final String TEST_URL = \"https://api.central.ballerina.io/1.0/modules\";\n\n    @Test(description = \"Test creating proxy\")\n    public void testGetProxy() {\n        Proxy proxy;\n        // Test without proxy\n        proxy = Utils.getProxy(\"\", 0, \"\", \"\");\n        Assert.assertNull(proxy);\n        // Test with proxy\n        proxy = Utils.getProxy(\"http://localhost\", 9090, \"testUser\", \"testPassword\");\n        Assert.assertNotNull(proxy);\n        Assert.assertEquals(proxy.toString(), \"HTTP @ http://localhost:9090\");\n\n    }\n\n    @Test(description = \"Test create http URL connection without proxy\")\n    public void testCreateHttpUrlConnection() {\n        HttpURLConnection conn;\n        // Test without proxy\n        conn = createHttpUrlConnection(convertToUrl(TEST_URL), \"\", 0, \"\", \"\");\n        Assert.assertNotNull(conn);\n        // Test with the proxy\n        conn = createHttpUrlConnection(convertToUrl(TEST_URL), \"http://localhost\", 9090, \"testUser\", \"testPassword\");\n        Assert.assertNotNull(conn);\n    }\n\n    @Test(description = \"Test set request\")\n    public void testSetRequestMethod() {\n        HttpURLConnection conn = createHttpUrlConnection(convertToUrl(TEST_URL), \"\", 0, \"\", \"\");\n        Utils.setRequestMethod(conn, Utils.RequestMethod.POST);\n        Assert.assertEquals(conn.getRequestMethod(), \"POST\");\n    }\n\n\n}\n", "/*\n * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n *\n * WSO2 Inc. licenses this file to you under the Apache License,\n * Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.wso2.ballerinalang.compiler.packaging.converters;\n\nimport org.ballerinalang.jvm.JSONParser;\nimport org.ballerinalang.jvm.values.MapValue;\nimport org.ballerinalang.model.elements.PackageID;\nimport org.ballerinalang.repository.CompilerInput;\nimport org.ballerinalang.toml.model.Manifest;\nimport org.wso2.ballerinalang.compiler.util.Name;\nimport org.wso2.ballerinalang.util.TomlParserUtils;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.Authenticator;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.PasswordAuthentication;\nimport java.net.Proxy;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\n/**\n *  Checks if there is a latest version in central if version is not mentioned. If there is then the version of the\n *  module is updated with that version.\n */\npublic class URIDryConverter extends URIConverter {\n\n    /**\n     * This is to keep track that an error has already been logged so that it doesn't repeatedly log the same error.\n     */\n    private static boolean loggedError = false;\n    private static final Pattern semVerPatchPattern = Pattern.compile(\"(\\\\d+)\\\\.(\\\\d+)\");\n    private PrintStream errStream = System.err;\n    private Proxy proxy;\n\n    private static TrustManager[] trustAllCerts = new TrustManager[]{\n            new X509TrustManager() {\n                public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                    return new java.security.cert.X509Certificate[]{};\n                }\n                public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n                    //No need to implement.\n                }\n                public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n                    //No need to implement.\n                }\n            }\n    };\n\n    public URIDryConverter(URI base, Map<PackageID, Manifest> dependencyManifests) {\n        this(base, dependencyManifests, false);\n    }\n\n    public URIDryConverter(URI base, Map<PackageID, Manifest> dependencyManifests, boolean isBuild) {\n        super(base, dependencyManifests, isBuild);\n        this.base = URI.create(base.toString() + \"/modules/info/\");\n        try {\n            SSLContext sc = SSLContext.getInstance(\"SSL\");\n            sc.init(null, trustAllCerts, new java.security.SecureRandom());\n            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n            proxy = getProxy();\n        } catch (NoSuchAlgorithmException | KeyManagementException e) {\n            // ignore errors\n        }\n    }\n\n    public Stream<CompilerInput> finalize(URI remoteURI, PackageID moduleID) {\n        try {\n            // only continue if a fixed module version is not set. a module version may be set through Ballerina.toml or\n            // Ballerina.lock already.\n            Matcher matcher = semVerPatchPattern.matcher(moduleID.version.value);\n            if (\"\".equals(moduleID.version.value) || \"*\".equals(moduleID.version.value) || matcher.matches()) {\n                HttpURLConnection conn;\n                // set proxy if exists.\n                if (null == this.proxy) {\n                    conn = (HttpURLConnection) remoteURI.toURL().openConnection();\n                } else {\n                    conn = (HttpURLConnection) remoteURI.toURL().openConnection(this.proxy);\n                }\n                conn.setInstanceFollowRedirects(false);\n                conn.setRequestMethod(\"GET\");\n\n                // status code and meaning\n                //// 200 - module info found\n                //// 400 - bad request sent\n                //// 500 - backend is broken\n                int statusCode = conn.getResponseCode();\n                if (statusCode == 200) {\n                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(),\n                            Charset.defaultCharset()))) {\n                        StringBuilder result = new StringBuilder();\n                        String line;\n                        while ((line = reader.readLine()) != null) {\n                            result.append(line);\n                        }\n                        Object payload = JSONParser.parse(result.toString());\n                        if (payload instanceof MapValue) {\n                            MapValue moduleInfo = ((MapValue) payload).getMapValue(\"module\");\n                            String version = moduleInfo.getStringValue(\"version\");\n                            moduleID.version = new Name(version);\n                        }\n                    }\n                } else if (statusCode == 400 && !loggedError) {\n                    try (BufferedReader errorStream = new BufferedReader(\n                            new InputStreamReader(conn.getInputStream(), Charset.defaultCharset()))) {\n                        String errorContent = errorStream.lines().collect(Collectors.joining(\"\\n\"));\n                        this.errStream.println(\"error: could not connect to remote repository to find the latest \" +\n                                \"version of module: \" + moduleID.toString() + \". use '--offline' \" +\n                                \"flag to build in offline mode. reason: \" + errorContent);\n                        setErrorLoggedStatusAsTrue();\n                    }\n                } else if (statusCode == 500 && !loggedError) {\n                    this.errStream.println(\"error: could not connect to remote repository to find the latest \" +\n                            \"version of module: \" + moduleID.toString() + \". use '--offline' \" +\n                            \"flag to build in offline mode.\");\n                    setErrorLoggedStatusAsTrue();\n                }\n                conn.disconnect();\n                Authenticator.setDefault(null);\n            }\n        } catch (IOException e) {\n            // ignore error and don't set the version.\n        }\n\n        return Stream.empty();\n    }\n\n    /**\n     * Set the status that an error has been logged.\n     */\n    private static void setErrorLoggedStatusAsTrue() {\n        loggedError = true;\n    }\n\n    /**\n     * Get proxy for http connection.\n     *\n     * @return The proxy object.\n     */\n    private Proxy getProxy() {\n        org.ballerinalang.toml.model.Proxy proxy = TomlParserUtils.readSettings().getProxy();\n        if (!\"\".equals(proxy.getHost())) {\n            InetSocketAddress proxyInet = new InetSocketAddress(proxy.getHost(), proxy.getPort());\n            if (!\"\".equals(proxy.getUserName()) && \"\".equals(proxy.getPassword())) {\n                Authenticator authenticator = new RemoteAuthenticator();\n                Authenticator.setDefault(authenticator);\n            }\n            return new Proxy(Proxy.Type.HTTP, proxyInet);\n        }\n\n        return null;\n    }\n\n    /**\n     * Authenticator for the proxy server if provided.\n     */\n    static class RemoteAuthenticator extends Authenticator {\n        org.ballerinalang.toml.model.Proxy proxy;\n        public RemoteAuthenticator() {\n            proxy = TomlParserUtils.readSettings().getProxy();\n        }\n\n        @Override\n        protected PasswordAuthentication getPasswordAuthentication() {\n            return (new PasswordAuthentication(this.proxy.getUserName(), this.proxy.getPassword().toCharArray()));\n        }\n    }\n}\n", "/*\n * Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.ballerinalang.openapi;\n\nimport com.github.jknack.handlebars.Context;\nimport com.github.jknack.handlebars.Handlebars;\nimport com.github.jknack.handlebars.Template;\nimport com.github.jknack.handlebars.context.FieldValueResolver;\nimport com.github.jknack.handlebars.context.JavaBeanValueResolver;\nimport com.github.jknack.handlebars.context.MapValueResolver;\nimport com.github.jknack.handlebars.helper.StringHelpers;\nimport com.github.jknack.handlebars.io.ClassPathTemplateLoader;\nimport com.github.jknack.handlebars.io.FileTemplateLoader;\nimport io.swagger.v3.oas.models.OpenAPI;\nimport io.swagger.v3.parser.OpenAPIV3Parser;\nimport org.apache.commons.lang3.StringUtils;\nimport org.ballerinalang.openapi.exception.BallerinaOpenApiException;\nimport org.ballerinalang.openapi.model.BallerinaOpenApi;\nimport org.ballerinalang.openapi.model.GenSrcFile;\nimport org.ballerinalang.openapi.typemodel.BallerinaOpenApiType;\nimport org.ballerinalang.openapi.utils.CodegenUtils;\nimport org.ballerinalang.openapi.utils.GeneratorConstants;\nimport org.ballerinalang.openapi.utils.GeneratorConstants.GenType;\nimport org.ballerinalang.openapi.utils.TypeExtractorUtil;\nimport org.ballerinalang.tool.LauncherUtils;\nimport org.wso2.ballerinalang.compiler.util.ProjectDirs;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static org.ballerinalang.openapi.model.GenSrcFile.GenFileType;\nimport static org.ballerinalang.openapi.utils.GeneratorConstants.GenType.GEN_CLIENT;\nimport static org.ballerinalang.openapi.utils.GeneratorConstants.MODULE_MD;\n\n/**\n * This class generates Ballerina Services/Clients for a provided OAS definition.\n */\npublic class CodeGenerator {\n    private String srcPackage;\n    private String modelPackage;\n\n    private static final PrintStream outStream = System.err;\n\n    /**\n     * Generates ballerina source for provided Open API Definition in {@code definitionPath}.\n     * Generated source will be written to a ballerina module at {@code outPath}\n     * <p>Method can be user for generating Ballerina mock services and clients</p>\n     *\n     * @param type           Output type. Following types are supported\n     *                       <ul>\n     *                       <li>mock</li>\n     *                       <li>client</li>\n     *                       </ul>\n     * @param executionPath  Command execution path\n     * @param definitionPath Input Open Api Definition file path\n     * @param serviceName    Output Service Name\n     * @param outPath        Destination file path to save generated source files. If not provided\n     *                       {@code definitionPath} will be used as the default destination path\n     * @throws IOException               when file operations fail\n     * @throws BallerinaOpenApiException when code generator fails\n     */\n    private void generate(GenType type, String executionPath, String definitionPath,\n                          String reldefinitionPath , String serviceName, String outPath)\n            throws IOException, BallerinaOpenApiException {\n\n        if (!CodegenUtils.isBallerinaProject(Paths.get(outPath))) {\n            throw new BallerinaOpenApiException(OpenApiMesseges.GEN_CLIENT_PROJECT_ROOT);\n        }\n\n        //Check if the selected path is a ballerina root for service generation\n        //TODO check with team for root check\n        Path projectRoot = ProjectDirs.findProjectRoot(Paths.get(executionPath));\n        if (type.equals(GenType.GEN_SERVICE) && projectRoot == null) {\n            throw LauncherUtils.createUsageExceptionWithHelp(OpenApiMesseges.GEN_SERVICE_PROJECT_ROOT);\n        }\n\n        Path srcPath = CodegenUtils.getSourcePath(srcPackage, outPath);\n        Path implPath = CodegenUtils.getImplPath(srcPackage, srcPath);\n\n        if (type.equals(GEN_CLIENT)) {\n            if (srcPackage.equals(\"\")) {\n                srcPath = srcPath.resolve(\"client\");\n                implPath = implPath.resolve(\"client\");\n            }\n\n            if (Files.notExists(srcPath)) {\n                Files.createDirectory(srcPath);\n            }\n\n            if (Files.notExists(implPath)) {\n                Files.createDirectory(implPath);\n            }\n\n        }\n\n        List<GenSrcFile> genFiles = generateBalSource(type, definitionPath, reldefinitionPath, serviceName);\n        writeGeneratedSources(genFiles, srcPath, implPath, type);\n    }\n\n\n    /**\n     * Generates ballerina source for provided Open API Definition in {@code definitionPath}.\n     * Generated source will be written to a ballerina module at {@code outPath}\n     * Method can be user for generating Ballerina clients.\n     *\n     * @param executionPath  Command execution path\n     * @param definitionPath Input Open Api Definition file path\n     * @param outPath        Destination file path to save generated source files. If not provided\n     *                       {@code definitionPath} will be used as the default destination path\n     * @throws IOException               when file operations fail\n     * @throws BallerinaOpenApiException when code generator fails\n     */\n    public void generateClient(String executionPath, String definitionPath, String serviceName, String outPath)\n            throws IOException, BallerinaOpenApiException {\n        generate(GenType.GEN_CLIENT, executionPath, definitionPath, null, serviceName, outPath);\n    }\n\n    /**\n     * Generates ballerina source for provided Open API Definition in {@code definitionPath}.\n     * Generated source will be written to a ballerina module at {@code outPath}\n     * Method can be user for generating Ballerina clients.\n     *\n     * @param executionPath  Command execution path\n     * @param definitionPath Input Open Api Definition file path\n     * @param reldefinitionPath Relative definition path to be used in the generated ballerina code\n     * @param serviceName    service name for the generated service\n     * @param outPath        Destination file path to save generated source files. If not provided\n     *                       {@code definitionPath} will be used as the default destination path\n     * @throws IOException               when file operations fail\n     * @throws BallerinaOpenApiException when code generator fails\n     */\n    public void generateService(String executionPath, String definitionPath,\n                                String reldefinitionPath, String serviceName, String outPath)\n            throws IOException, BallerinaOpenApiException {\n        generate(GenType.GEN_SERVICE, executionPath, definitionPath, reldefinitionPath, serviceName, outPath);\n    }\n\n    /**\n     * Generates ballerina source for provided Open API Definition in {@code definitionPath}.\n     * Generated code will be returned as a list of source files\n     * <p>Method can be user for generating Ballerina mock services and clients</p>\n     *\n     * @param type           Output type. Following types are supported\n     *                       <ul>\n     *                       <li>mock</li>\n     *                       <li>client</li>\n     *                       </ul>\n     * @param serviceName    Out put service name\n     * @param definitionPath Input Open Api Definition file path\n     * @param reldefinitionPath Relative OpenApi File\n     * @return a list of generated source files wrapped as {@link GenSrcFile}\n     * @throws IOException               when file operations fail\n     * @throws BallerinaOpenApiException when open api context building fail\n     */\n    public List<GenSrcFile> generateBalSource(GenType type, String definitionPath,\n                                              String reldefinitionPath, String serviceName)\n            throws IOException, BallerinaOpenApiException {\n        OpenAPI api = new OpenAPIV3Parser().read(definitionPath);\n\n        if (api == null) {\n            throw new BallerinaOpenApiException(\"Couldn't read the definition from file: \" + definitionPath);\n        }\n\n        if (serviceName != null) {\n            api.getInfo().setTitle(serviceName);\n        } else if (api.getInfo() == null || StringUtils.isEmpty(api.getInfo().getTitle())) {\n            api.getInfo().setTitle(GeneratorConstants.UNTITLED_SERVICE);\n        }\n\n        List<GenSrcFile> sourceFiles;\n\n        switch (type) {\n            case GEN_CLIENT:\n                // modelPackage is not in use at the moment. All models will be written into same package\n                // as other src files.\n                // Therefore value set to modelPackage is ignored here\n                BallerinaOpenApi definitionContext = new BallerinaOpenApi().buildContext(api).srcPackage(srcPackage)\n                        .modelPackage(srcPackage);\n                definitionContext.setDefinitionPath(reldefinitionPath);\n\n                sourceFiles = generateClient(definitionContext);\n                break;\n            case GEN_SERVICE:\n\n                final BallerinaOpenApiType openApi = TypeExtractorUtil.extractOpenApiObject(api);\n                openApi.setBalServiceName(serviceName);\n                openApi.setBalModule(srcPackage);\n                openApi.setServers(api);\n                openApi.setTags(api.getTags());\n\n                if (reldefinitionPath == null) {\n                    openApi.setDefPath(definitionPath.replaceAll(Pattern.quote(\"\\\\\"),\n                            Matcher.quoteReplacement(\"\\\\\\\\\")));\n                } else {\n                    openApi.setDefPath(reldefinitionPath.replaceAll(Pattern.quote(\"\\\\\"),\n                            Matcher.quoteReplacement(\"\\\\\\\\\")));\n                }\n\n                sourceFiles = generateBallerinaService(openApi);\n                break;\n            default:\n                return null;\n        }\n\n        return sourceFiles;\n    }\n\n    /**\n     * Write ballerina definition of a <code>object</code> to a file as described by <code>template.</code>\n     *\n     * @param object       Context object to be used by the template parser\n     * @param templateDir  Directory with all the templates required for generating the source file\n     * @param templateName Name of the parent template to be used\n     * @param outPath      Destination path for writing the resulting source file\n     * @throws IOException when file operations fail\n     * @deprecated This method is now deprecated.\n     * Use {@link #generateBalSource(GeneratorConstants.GenType, String, String, String) generate}\n     * and implement a file write functionality your self, if you need to customize file writing steps.\n     * Otherwise use {@link #generate(GeneratorConstants.GenType, String, String, String, String, String) generate}\n     * to directly write generated source to a ballerina module.\n     */\n    @Deprecated\n    public void writeBallerina(Object object, String templateDir, String templateName, String outPath)\n            throws IOException {\n        PrintWriter writer = null;\n\n        try {\n            Template template = compileTemplate(templateDir, templateName);\n            Context context = Context.newBuilder(object).resolver(\n                    MapValueResolver.INSTANCE,\n                    JavaBeanValueResolver.INSTANCE,\n                    FieldValueResolver.INSTANCE).build();\n            writer = new PrintWriter(outPath, \"UTF-8\");\n            writer.println(template.apply(context));\n        } finally {\n            if (writer != null) {\n                writer.close();\n            }\n        }\n    }\n\n    private Template compileTemplate(String defaultTemplateDir, String templateName) throws IOException {\n        defaultTemplateDir = defaultTemplateDir.replaceAll(\"\\\\\\\\\", \"/\");\n        String templatesDirPath = System.getProperty(GeneratorConstants.TEMPLATES_DIR_PATH_KEY, defaultTemplateDir);\n        ClassPathTemplateLoader cpTemplateLoader = new ClassPathTemplateLoader((templatesDirPath));\n        FileTemplateLoader fileTemplateLoader = new FileTemplateLoader(templatesDirPath);\n        cpTemplateLoader.setSuffix(GeneratorConstants.TEMPLATES_SUFFIX);\n        fileTemplateLoader.setSuffix(GeneratorConstants.TEMPLATES_SUFFIX);\n\n        Handlebars handlebars = new Handlebars().with(cpTemplateLoader, fileTemplateLoader);\n        handlebars.setInfiniteLoops(true); //This will allow templates to call themselves with recursion.\n        handlebars.registerHelpers(StringHelpers.class);\n        handlebars.registerHelper(\"equals\", (object, options) -> {\n            CharSequence result;\n            Object param0 = options.param(0);\n\n            if (param0 == null) {\n                throw new IllegalArgumentException(\"found 'null', expected 'string'\");\n            }\n            if (object != null) {\n                if (object.toString().equals(param0.toString())) {\n                    result = options.fn(options.context);\n                } else {\n                    result = options.inverse();\n                }\n            } else {\n                result = null;\n            }\n\n            return result;\n        });\n\n        return handlebars.compile(templateName);\n    }\n\n    private void writeGeneratedSources(List<GenSrcFile> sources, Path srcPath, Path implPath, GenType type)\n            throws IOException {\n        // Remove old generated files - if any - before regenerate\n        // if srcPackage was not provided and source was written to main package nothing will be deleted.\n        if (srcPackage != null && !srcPackage.isEmpty() && Files.exists(srcPath)) {\n            final File[] listFiles = new File(String.valueOf(srcPath)).listFiles();\n            if (listFiles != null) {\n                Arrays.stream(listFiles).forEach(file -> {\n                    boolean deleteStatus = true;\n                    if (!file.isDirectory() && !file.getName().equals(MODULE_MD)) {\n                        deleteStatus = file.delete();\n                    }\n\n                    //Capture return value of file.delete() since if\n                    //unable to delete returns false from file.delete() without an exception.\n                    if (!deleteStatus) {\n                        outStream.println(\"Unable to clean module directory.\");\n                    }\n                });\n            }\n\n        }\n\n        for (GenSrcFile file : sources) {\n            Path filePath;\n\n            // We only overwrite files of overwritable type.\n            // So non overwritable files will be written to disk only once.\n            if (!file.getType().isOverwritable()) {\n                filePath = implPath.resolve(file.getFileName());\n                if (Files.notExists(filePath)) {\n                    CodegenUtils.writeFile(filePath, file.getContent());\n                }\n            } else {\n                filePath = srcPath.resolve(file.getFileName());\n                CodegenUtils.writeFile(filePath, file.getContent());\n            }\n        }\n\n        //This will print the generated files to the console\n        if (type.equals(GenType.GEN_SERVICE)) {\n            outStream.println(\"Service generated successfully and the OpenApi contract is copied to \" + srcPackage\n                    + \"/resources. this location will be referenced throughout the ballerina project.\");\n        } else if (type.equals(GEN_CLIENT)) {\n            outStream.println(\"Client generated successfully.\");\n        }\n        outStream.println(\"Following files were created. \\n\" +\n                \"src/ \\n- \" + srcPackage);\n        Iterator<GenSrcFile> iterator = sources.iterator();\n        while (iterator.hasNext()) {\n            outStream.println(\"-- \" + iterator.next().getFileName());\n        }\n    }\n\n    /**\n     * Generate code for ballerina client.\n     *\n     * @param context model context to be used by the templates\n     * @return generated source files as a list of {@link GenSrcFile}\n     * @throws IOException when code generation with specified templates fails\n     */\n    private List<GenSrcFile> generateClient(BallerinaOpenApi context) throws IOException {\n        if (srcPackage == null || srcPackage.isEmpty()) {\n            srcPackage = GeneratorConstants.DEFAULT_CLIENT_PKG;\n        }\n\n        List<GenSrcFile> sourceFiles = new ArrayList<>();\n        String srcFile = context.getInfo().getTitle().toLowerCase(Locale.ENGLISH)\n                .replaceAll(\" \", \"_\") + \".bal\";\n\n        // Generate ballerina service and resources.\n        String mainContent = getContent(context, GeneratorConstants.DEFAULT_CLIENT_DIR,\n                GeneratorConstants.CLIENT_TEMPLATE_NAME);\n        sourceFiles.add(new GenSrcFile(GenFileType.GEN_SRC, srcPackage, srcFile, mainContent));\n\n        // Generate ballerina records to represent schemas.\n        String schemaContent = getContent(context, GeneratorConstants.DEFAULT_MODEL_DIR,\n                GeneratorConstants.SCHEMA_TEMPLATE_NAME);\n        sourceFiles.add(new GenSrcFile(GenFileType.MODEL_SRC, srcPackage, GeneratorConstants.SCHEMA_FILE_NAME,\n                schemaContent));\n\n        return sourceFiles;\n    }\n\n    private List<GenSrcFile> generateBallerinaService(BallerinaOpenApiType api) throws IOException {\n        if (srcPackage == null || srcPackage.isEmpty()) {\n            srcPackage = GeneratorConstants.DEFAULT_MOCK_PKG;\n        }\n\n        List<GenSrcFile> sourceFiles = new ArrayList<>();\n        String concatTitle = api.getBalServiceName().toLowerCase(Locale.ENGLISH).replaceAll(\" \", \"_\");\n        String srcFile = concatTitle + \".bal\";\n\n        String mainContent = getContent(api, GeneratorConstants.DEFAULT_TEMPLATE_DIR + \"/service\",\n                \"balService\");\n        sourceFiles.add(new GenSrcFile(GenFileType.GEN_SRC, srcPackage, srcFile, mainContent));\n\n        String schemaContent = getContent(api, GeneratorConstants.DEFAULT_TEMPLATE_DIR + \"/service\",\n                \"schemaList\");\n        sourceFiles.add(new GenSrcFile(GenFileType.GEN_SRC, srcPackage, GeneratorConstants.SCHEMA_FILE_NAME,\n                schemaContent));\n\n        return sourceFiles;\n    }\n\n    /**\n     * Retrieve generated source content as a String value.\n     *\n     * @param object       context to be used by template engine\n     * @param templateDir  templates directory\n     * @param templateName name of the template to be used for this code generation\n     * @return String with populated template\n     * @throws IOException when template population fails\n     */\n    private String getContent(BallerinaOpenApiType object, String templateDir, String templateName) throws IOException {\n        Template template = compileTemplate(templateDir, templateName);\n        Context context = Context.newBuilder(object)\n                .resolver(MapValueResolver.INSTANCE, JavaBeanValueResolver.INSTANCE, FieldValueResolver.INSTANCE)\n                .build();\n        return template.apply(context);\n    }\n\n    /**\n     * Retrieve generated source content as a String value.\n     *\n     * @param object       context to be used by template engine\n     * @param templateDir  templates directory\n     * @param templateName name of the template to be used for this code generation\n     * @return String with populated template\n     * @throws IOException when template population fails\n     */\n    private String getContent(BallerinaOpenApi object, String templateDir, String templateName) throws IOException {\n        Template template = compileTemplate(templateDir, templateName);\n        Context context = Context.newBuilder(object)\n                .resolver(MapValueResolver.INSTANCE, JavaBeanValueResolver.INSTANCE, FieldValueResolver.INSTANCE)\n                .build();\n        return template.apply(context);\n    }\n\n    public String getSrcPackage() {\n        return srcPackage;\n    }\n\n    public void setSrcPackage(String srcPackage) {\n        this.srcPackage = srcPackage;\n    }\n\n    public String getModelPackage() {\n        return modelPackage;\n    }\n\n    public void setModelPackage(String modelPackage) {\n        this.modelPackage = modelPackage;\n    }\n}\n", "/*\n * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n *\n * WSO2 Inc. licenses this file to you under the Apache License,\n * Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.ballerinalang.test.packaging;\n\nimport org.awaitility.Duration;\nimport org.ballerinalang.cli.module.util.Utils;\nimport org.ballerinalang.jvm.JSONParser;\nimport org.ballerinalang.jvm.values.MapValue;\nimport org.ballerinalang.test.BaseTest;\nimport org.ballerinalang.test.context.BMainInstance;\nimport org.ballerinalang.test.context.BallerinaTestException;\nimport org.ballerinalang.test.context.LogLeecher;\nimport org.ballerinalang.test.context.LogLeecher.LeecherType;\nimport org.testng.Assert;\nimport org.testng.annotations.AfterClass;\nimport org.testng.annotations.BeforeClass;\nimport org.testng.annotations.Test;\nimport org.wso2.ballerinalang.compiler.util.ProjectDirConstants;\nimport org.wso2.ballerinalang.programfile.ProgramFileConstants;\nimport org.wso2.ballerinalang.util.RepoUtils;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Map;\n\nimport static java.util.concurrent.TimeUnit.SECONDS;\nimport static org.awaitility.Awaitility.given;\nimport static org.ballerinalang.cli.module.util.Utils.convertToUrl;\nimport static org.ballerinalang.cli.module.util.Utils.createHttpUrlConnection;\nimport static org.ballerinalang.cli.module.util.Utils.initializeSsl;\nimport static org.ballerinalang.cli.module.util.Utils.setRequestMethod;\nimport static org.ballerinalang.test.packaging.ModulePushTestCase.REPO_TO_CENTRAL_SUCCESS_MSG;\nimport static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.BLANG_COMPILED_PKG_BINARY_EXT;\nimport static org.wso2.ballerinalang.util.RepoUtils.BALLERINA_STAGE_CENTRAL;\n\n/**\n * Testing pushing, pulling, searching a package from central and installing package to home repository.\n *\n * @since 0.981.0\n */\npublic class PackagingTestCase extends BaseTest {\n    private Path tempHomeDirectory;\n    private Path tempProjectDirectory;\n    private String moduleName = \"test\";\n    private String datePushed;\n    private String orgName = \"bcintegrationtest\";\n    private Map<String, String> envVariables;\n    private BMainInstance balClient;\n    private int totalPullCount = 0;\n    \n    @BeforeClass()\n    public void setUp() throws IOException, BallerinaTestException {\n        tempHomeDirectory = Files.createTempDirectory(\"bal-test-integration-packaging-home-\");\n        tempProjectDirectory = Files.createTempDirectory(\"bal-test-integration-packaging-project-\");\n        moduleName = moduleName + PackerinaTestUtils.randomModuleName(10);\n        PackerinaTestUtils.createSettingToml(tempHomeDirectory);\n        envVariables = addEnvVariables(PackerinaTestUtils.getEnvVariables());\n        balClient = new BMainInstance(balServer);\n    }\n\n    @Test(description = \"Test create a ballerina project and module to be pushed to central\")\n    public void testCreateProject() throws Exception {\n        Path projectPath = tempProjectDirectory.resolve(\"initProject\");\n\n        // Create project\n        balClient.runMain(\"new\", new String[]{\"initProject\"}, envVariables, new String[]{}, new LogLeecher[]{},\n                projectPath.getParent().toString());\n    \n        // Update org name\n        PackerinaTestUtils.updateManifestOrgName(projectPath, orgName);\n        \n        Assert.assertTrue(Files.exists(projectPath));\n        Assert.assertTrue(Files.isDirectory(projectPath));\n    \n        // Create module\n        balClient.runMain(\"add\", new String[]{moduleName}, envVariables, new String[]{}, new LogLeecher[]{},\n                projectPath.toString());\n    \n        Assert.assertTrue(Files.exists(projectPath.resolve(\"src\").resolve(moduleName)));\n        Assert.assertTrue(Files.isDirectory(projectPath.resolve(\"src\").resolve(moduleName)));\n    }\n\n    @Test(description = \"Test pushing a package to central\", dependsOnMethods = \"testCreateProject\")\n    public void testPush() throws Exception {\n        Path projectPath = tempProjectDirectory.resolve(\"initProject\");\n\n        // Get date and time of the module pushed.\n        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyy-MM-dd-EE\");\n        datePushed = dtf.format(LocalDateTime.now());\n\n        // First try to push without building\n        String firstMsg = \"error: cannot find balo file for the module: \" + moduleName + \". Run \" +\n                          \"'ballerina build -c <module_name>' to compile and generate the balo.\";\n        LogLeecher clientLeecher = new LogLeecher(firstMsg, LeecherType.ERROR);\n        balClient.runMain(\"push\", new String[]{moduleName}, envVariables, new String[]{},\n                          new LogLeecher[]{clientLeecher}, projectPath.toString());\n        clientLeecher.waitForText(2000);\n        \n        String baloFileName = moduleName + \"-\"\n                              + ProgramFileConstants.IMPLEMENTATION_VERSION + \"-\"\n                              + ProgramFileConstants.ANY_PLATFORM + \"-\"\n                              + \"0.1.0\"\n                              + BLANG_COMPILED_PKG_BINARY_EXT;\n        Path baloPath = projectPath.resolve(\"target\").resolve(\"balo\").resolve(baloFileName);\n        Assert.assertTrue(Files.notExists(baloPath));\n\n        // Build module\n        String buildMessage = \"Created target\" + File.separator + \"balo\" + File.separator + baloFileName;\n        clientLeecher = new LogLeecher(buildMessage);\n        balClient.runMain(\"build\", new String[]{\"-c\", moduleName}, envVariables, new String[]{},\n                new LogLeecher[]{clientLeecher}, projectPath.toString());\n        \n        // Then try to push without the flag so it builds the artifact\n        String secondMsg = orgName + \"/\" + moduleName + \":0.1.0\" + REPO_TO_CENTRAL_SUCCESS_MSG;\n        clientLeecher = new LogLeecher(secondMsg, LeecherType.INFO);\n        balClient.runMain(\"push\", new String[]{moduleName}, envVariables, new String[]{},\n                          new LogLeecher[]{clientLeecher}, projectPath.toString());\n        clientLeecher.waitForText(60000);\n    }\n\n    @Test(description = \"Test pulling a package from central\", dependsOnMethods = \"testPush\")\n    public void testPull() {\n        String baloFileName = moduleName + \"-\"\n                              + ProgramFileConstants.IMPLEMENTATION_VERSION + \"-\"\n                              + ProgramFileConstants.ANY_PLATFORM + \"-\"\n                              + \"0.1.0\"\n                              + BLANG_COMPILED_PKG_BINARY_EXT;\n        Path baloPath = Paths.get(ProjectDirConstants.BALO_CACHE_DIR_NAME,\n                                 orgName, moduleName, \"0.1.0\");\n\n        given().with().pollInterval(Duration.TEN_SECONDS).and()\n               .with().pollDelay(Duration.FIVE_SECONDS)\n               .await().atMost(90, SECONDS).until(() -> {\n            String[] clientArgs = {orgName + \"/\" + moduleName + \":0.1.0\"};\n            balClient.runMain(\"pull\", clientArgs, envVariables, new String[]{},\n                    new LogLeecher[]{}, balServer.getServerHome());\n            totalPullCount += 1;\n            return Files.exists(tempHomeDirectory.resolve(baloPath).resolve(baloFileName));\n        });\n\n        Assert.assertTrue(Files.exists(tempHomeDirectory.resolve(baloPath).resolve(baloFileName)));\n    }\n\n    @Test(description = \"Test searching a package from central\", dependsOnMethods = \"testPush\")\n    public void testSearch() throws BallerinaTestException {\n        String actualMsg = balClient.runMainAndReadStdOut(\"search\", new String[]{moduleName}, envVariables,\n                balServer.getServerHome(), false);\n\n        // Check if the search results contains the following.\n        Assert.assertTrue(actualMsg.contains(\"Ballerina Central\"));\n        Assert.assertTrue(actualMsg.contains(\"NAME\"));\n        Assert.assertTrue(actualMsg.contains(\"DESCRIPTION\"));\n        Assert.assertTrue(actualMsg.contains(\"DATE\"));\n        Assert.assertTrue(actualMsg.contains(\"VERSION\"));\n        Assert.assertTrue(actualMsg.contains(datePushed));\n        Assert.assertTrue(actualMsg.contains(\"0.1.0\"));\n    }\n\n    @Test(description = \"Test pullCount of a package from central\", dependsOnMethods = \"testPull\", enabled = false)\n    public void testPullCount() throws IOException {\n        initializeSsl();\n        String url = RepoUtils.getRemoteRepoURL() + \"/modules/info/\" + orgName + \"/\" + moduleName + \"/*/\";\n        HttpURLConnection conn = createHttpUrlConnection(convertToUrl(url), \"\", 0, \"\", \"\");\n        conn.setInstanceFollowRedirects(false);\n        setRequestMethod(conn, Utils.RequestMethod.GET);\n\n        int statusCode = conn.getResponseCode();\n        if (statusCode == 200) {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(),\n                    Charset.defaultCharset()))) {\n                StringBuilder result = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    result.append(line);\n                }\n                Object payload = JSONParser.parse(result.toString());\n                if (payload instanceof MapValue) {\n                    long pullCount = ((MapValue) payload).getIntValue(\"totalPullCount\");\n                    Assert.assertEquals(pullCount, totalPullCount);\n                } else {\n                    Assert.fail(\"error: invalid response received\");\n                }\n            }\n        } else {\n            Assert.fail(\"error: could not connect to remote repository to find the latest version of module\");\n        }\n    }\n\n    @Test(description = \"Test push all packages in project to central\", enabled = false)\n    public void testPushAllPackages() throws Exception {\n        // Test ballerina init\n        Path projectPath = tempProjectDirectory.resolve(\"pushAllPackageTest\");\n        \n        // Create project\n        balClient.runMain(\"new\", new String[]{\"pushAllPackageTest\"}, envVariables, new String[]{}, new LogLeecher[]{},\n                projectPath.getParent().toString());\n    \n        Assert.assertTrue(Files.exists(projectPath));\n        Assert.assertTrue(Files.isDirectory(projectPath));\n        \n        String firstPackage = \"firstTestPkg\" + PackerinaTestUtils.randomModuleName(10);\n        String secondPackage = \"secondTestPkg\" + PackerinaTestUtils.randomModuleName(10);\n        \n        // update org name\n        PackerinaTestUtils.updateManifestOrgName(projectPath, orgName);\n        \n        // Create first module\n        balClient.runMain(\"add\", new String[]{firstPackage}, envVariables, new String[]{}, new LogLeecher[]{},\n                projectPath.toString());\n    \n        Assert.assertTrue(Files.exists(projectPath.resolve(\"src\").resolve(firstPackage)));\n        Assert.assertTrue(Files.isDirectory(projectPath.resolve(\"src\").resolve(firstPackage)));\n    \n        // Create second module\n        balClient.runMain(\"add\", new String[]{secondPackage}, envVariables, new String[]{}, new LogLeecher[]{},\n                projectPath.toString());\n    \n        Assert.assertTrue(Files.exists(projectPath.resolve(\"src\").resolve(secondPackage)));\n        Assert.assertTrue(Files.isDirectory(projectPath.resolve(\"src\").resolve(secondPackage)));\n    \n        // Build module\n        balClient.runMain(\"build\", new String[]{\"-c\", \"-a\"}, envVariables, new String[]{},\n                new LogLeecher[]{}, projectPath.toString());\n        \n        LogLeecher clientLeecherOne = new LogLeecher(orgName + \"/\" + firstPackage + \":0.1.0\"\n                + REPO_TO_CENTRAL_SUCCESS_MSG);\n        LogLeecher clientLeecherTwo = new LogLeecher(orgName + \"/\" + secondPackage + \":0.1.0\"\n                + REPO_TO_CENTRAL_SUCCESS_MSG);\n        balClient.runMain(\"push\", new String[]{\"-a\"}, envVariables, new String[]{},\n                new LogLeecher[]{clientLeecherOne, clientLeecherTwo}, projectPath.toString());\n        clientLeecherOne.waitForText(60000);\n        clientLeecherTwo.waitForText(60000);\n    }\n\n    @Test(description = \"Test ballerina version\")\n    public void testBallerinaVersion() throws Exception {\n        LogLeecher clientLeecher = new LogLeecher(RepoUtils.getBallerinaVersion());\n        balClient.runMain(\"version\", new String[0], envVariables, new String[]{},\n                new LogLeecher[]{clientLeecher}, tempProjectDirectory.toString());\n    }\n\n    @Test(description = \"Test and run a module which has a module name contains period. eg: foo.bar\")\n    public void testBuildAndRunModuleWithPeriod() throws BallerinaTestException {\n        // Test ballerina init\n        Path projectPath = tempProjectDirectory.resolve(\"buildAndRunModuleWithPeriodProject\");\n\n        // Create project\n        balClient.runMain(\"new\", new String[] { \"buildAndRunModuleWithPeriodProject\" }, envVariables, new String[] {},\n                new LogLeecher[] {}, projectPath.getParent().toString());\n\n        Assert.assertTrue(Files.exists(projectPath));\n        Assert.assertTrue(Files.isDirectory(projectPath));\n\n        // Create module named `foo.bar`\n        String moduleName = \"foo.bar\";\n        balClient.runMain(\"add\", new String[] { moduleName }, envVariables, new String[] {}, new LogLeecher[] {},\n                projectPath.toString());\n\n        Assert.assertTrue(Files.exists(projectPath.resolve(\"src\").resolve(moduleName)));\n        Assert.assertTrue(Files.isDirectory(projectPath.resolve(\"src\").resolve(moduleName)));\n\n        // Build module\n        LogLeecher buildLeecher = new LogLeecher(\"[pass] testFunction\");\n        balClient.runMain(\"build\", new String[] { \"-c\", \"-a\" }, envVariables, new String[] {},\n                new LogLeecher[] { buildLeecher }, projectPath.toString());\n        buildLeecher.waitForText(60000);\n\n        // Run module\n        LogLeecher runLeecher = new LogLeecher(\"Hello World!\");\n        balClient.runMain(\"run\", new String[] { moduleName }, envVariables, new String[] {},\n                new LogLeecher[] { runLeecher }, projectPath.toString());\n        buildLeecher.waitForText(5000);\n    }\n\n    /**\n     * Get environment variables and add ballerina_home as a env variable the tmp directory.\n     *\n     * @return env directory variable array\n     */\n    private Map<String, String> addEnvVariables(Map<String, String> envVariables) {\n        envVariables.put(ProjectDirConstants.HOME_REPO_ENV_KEY, tempHomeDirectory.toString());\n        envVariables.put(BALLERINA_STAGE_CENTRAL, \"true\");\n        return envVariables;\n    }\n\n    @AfterClass\n    private void cleanup() throws Exception {\n        PackerinaTestUtils.deleteFiles(tempHomeDirectory);\n        PackerinaTestUtils.deleteFiles(tempProjectDirectory);\n    }\n}\n"], "fixing_code": ["// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n//\n// WSO2 Inc. licenses this file to you under the Apache License,\n// Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\npackage org.ballerinalang.cli.module;\n\nimport me.tongfei.progressbar.ProgressBar;\nimport me.tongfei.progressbar.ProgressBarStyle;\nimport org.ballerinalang.cli.module.util.ErrorUtil;\nimport org.ballerinalang.cli.module.util.Utils;\nimport org.ballerinalang.jvm.JSONParser;\nimport org.ballerinalang.jvm.values.MapValue;\n\nimport java.io.BufferedReader;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.Authenticator;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.ws.rs.core.HttpHeaders;\n\nimport static org.ballerinalang.cli.module.util.CliModuleConstants.BALLERINA_PLATFORM;\nimport static org.ballerinalang.cli.module.util.CliModuleConstants.BAL_LANG_SPEC_VERSION;\nimport static org.ballerinalang.cli.module.util.CliModuleConstants.IDENTITY;\nimport static org.ballerinalang.cli.module.util.CliModuleConstants.RESOLVED_REQUESTED_URI;\nimport static org.ballerinalang.cli.module.util.Utils.convertToUrl;\nimport static org.ballerinalang.cli.module.util.Utils.createHttpsUrlConnection;\nimport static org.ballerinalang.cli.module.util.Utils.getStatusCode;\nimport static org.ballerinalang.cli.module.util.Utils.setRequestMethod;\n\n/**\n * This class is pulling the modules from ballerina central.\n *\n * @since 1.2.0\n */\npublic class Pull {\n    private static final String VERSION_REGEX = \"(\\\\d+\\\\.)(\\\\d+\\\\.)(\\\\d+)\";\n    private static PrintStream outStream = System.out;\n    private static DefaultLogFormatter logFormatter = new DefaultLogFormatter();\n\n    private Pull() {\n    }\n\n    /**\n     * Execute pull command.\n     *\n     * @param url                   remote uri of the central\n     * @param modulePathInBaloCache module path in balo cache, user.home/.ballerina/balo_cache/org_name/module_name\n     * @param moduleNameWithOrg     module name with org, org_name/module_name\n     * @param proxyHost             proxy host\n     * @param proxyPort             proxy port\n     * @param proxyUsername         proxy username\n     * @param proxyPassword         proxy password\n     * @param supportedVersionRange supported version range\n     * @param isBuild               pulling happens when building\n     * @param isNightlyBuild        is nightly build\n     * @param langSpecVersion       lang spec version\n     * @param platform              supported version\n     */\n    public static void execute(String url, String modulePathInBaloCache, String moduleNameWithOrg, String proxyHost,\n            int proxyPort, String proxyUsername, String proxyPassword, String supportedVersionRange, boolean isBuild,\n            boolean isNightlyBuild, String langSpecVersion, String platform) {\n        if (isBuild) {\n            logFormatter = new BuildLogFormatter();\n        }\n\n        HttpsURLConnection conn = null;\n        try {\n            conn = createHttpsUrlConnection(convertToUrl(url + supportedVersionRange), proxyHost, proxyPort,\n                                            proxyUsername, proxyPassword);\n\n            conn.setInstanceFollowRedirects(false);\n            setRequestMethod(conn, Utils.RequestMethod.GET);\n\n            // Set headers\n            conn.setRequestProperty(BALLERINA_PLATFORM, platform);\n            conn.setRequestProperty(BAL_LANG_SPEC_VERSION, langSpecVersion);\n            conn.setRequestProperty(HttpHeaders.ACCEPT_ENCODING, IDENTITY);\n\n            boolean redirect = false;\n            // 302 - Module is found\n            // Other - Error occurred, json returned with the error message\n            if (getStatusCode(conn) == HttpsURLConnection.HTTP_MOVED_TEMP) {\n                redirect = true;\n            } else {\n                handleErrorResponse(conn, url, moduleNameWithOrg);\n            }\n\n            if (redirect) {\n                // get redirect url from \"location\" header field\n                String newUrl = conn.getHeaderField(HttpHeaders.LOCATION);\n                String contentDisposition = conn.getHeaderField(HttpHeaders.CONTENT_DISPOSITION);\n\n                conn = createHttpsUrlConnection(convertToUrl(newUrl), proxyHost, proxyPort, proxyUsername,\n                                                proxyPassword);\n                conn.setRequestProperty(HttpHeaders.CONTENT_DISPOSITION, contentDisposition);\n\n                createBaloInHomeRepo(conn, modulePathInBaloCache, moduleNameWithOrg, isNightlyBuild, newUrl,\n                        contentDisposition);\n            }\n        } catch (Exception e) {\n            throw ErrorUtil.createCommandException(e.getMessage());\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n            Authenticator.setDefault(null);\n        }\n    }\n\n    /**\n     * Create the balo in home repo.\n     *\n     * @param conn                  https connection\n     * @param modulePathInBaloCache module path in balo cache, <user.home>.ballerina/balo_cache/<org-name>/<module-name>\n     * @param moduleNameWithOrg     module name with org, <org-name>/<module-name>\n     * @param isNightlyBuild        is nightly build\n     * @param newUrl                new redirect url\n     * @param contentDisposition    content disposition header\n     */\n    private static void createBaloInHomeRepo(HttpsURLConnection conn, String modulePathInBaloCache,\n            String moduleNameWithOrg, boolean isNightlyBuild, String newUrl, String contentDisposition) {\n        long responseContentLength = conn.getContentLengthLong();\n        if (responseContentLength <= 0) {\n            createError(\"invalid response from the server, please try again\");\n        }\n        String resolvedURI = conn.getHeaderField(RESOLVED_REQUESTED_URI);\n        if (resolvedURI == null || resolvedURI.equals(\"\")) {\n            resolvedURI = newUrl;\n        }\n        String[] uriParts = resolvedURI.split(\"/\");\n        String moduleVersion = uriParts[uriParts.length - 3];\n\n        validateModuleVersion(moduleVersion);\n        String baloFile = getBaloFileName(contentDisposition, uriParts[uriParts.length - 1]);\n        Path baloCacheWithModulePath = Paths.get(modulePathInBaloCache, moduleVersion);\n        //<user.home>.ballerina/balo_cache/<org-name>/<module-name>/<module-version>\n\n        Path baloPath = Paths.get(baloCacheWithModulePath.toString(), baloFile);\n        if (baloPath.toFile().exists()) {\n            createError(\"module already exists in the home repository: \" + baloPath.toString());\n        }\n\n        createBaloFileDirectory(baloCacheWithModulePath);\n        writeBaloFile(conn, baloPath, moduleNameWithOrg + \":\" + moduleVersion, responseContentLength);\n        handleNightlyBuild(isNightlyBuild, baloCacheWithModulePath);\n    }\n\n    /**\n     * Write balo file to the home repo.\n     *\n     * @param conn             https connection\n     * @param baloPath         path of the balo file\n     * @param fullModuleName   full module name, <org-name>/<module-name>:<module-version>\n     * @param resContentLength response content length\n     */\n    private static void writeBaloFile(HttpsURLConnection conn, Path baloPath, String fullModuleName,\n            long resContentLength) {\n        try (InputStream inputStream = conn.getInputStream();\n                FileOutputStream outputStream = new FileOutputStream(baloPath.toString())) {\n            writeAndHandleProgress(inputStream, outputStream, resContentLength / 1024, fullModuleName);\n        } catch (IOException e) {\n            createError(\"error occurred copying the balo file: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Show progress of the writing the balo file.\n     *\n     * @param inputStream    response input stream\n     * @param outputStream   home repo balo file output stream\n     * @param totalSizeInKB  response input stream size in kb\n     * @param fullModuleName full module name, <org-name>/<module-name>:<module-version>\n     */\n    private static void writeAndHandleProgress(InputStream inputStream, FileOutputStream outputStream,\n            long totalSizeInKB, String fullModuleName) {\n        int count;\n        byte[] buffer = new byte[1024];\n\n        try (ProgressBar progressBar = new ProgressBar(fullModuleName + \" [central.ballerina.io -> home repo] \",\n                totalSizeInKB, 1000, outStream, ProgressBarStyle.ASCII, \" KB\", 1)) {\n            while ((count = inputStream.read(buffer)) > 0) {\n                outputStream.write(buffer, 0, count);\n                progressBar.step();\n            }\n        } catch (IOException e) {\n            outStream.println(logFormatter.formatLog(fullModuleName + \"pulling the module from central failed\"));\n        } finally {\n            outStream.println(logFormatter.formatLog(fullModuleName + \" pulled from central successfully\"));\n        }\n    }\n\n    /**\n     * Handle nightly build.\n     *\n     * @param isNightlyBuild          is nightly build\n     * @param baloCacheWithModulePath balo cache with module path\n     */\n    private static void handleNightlyBuild(boolean isNightlyBuild, Path baloCacheWithModulePath) {\n        if (isNightlyBuild) {\n            // If its a nightly build tag the file as a module from nightly\n            Path nightlyBuildMetaFile = Paths.get(baloCacheWithModulePath.toString(), \"nightly.build\");\n            if (!nightlyBuildMetaFile.toFile().exists()) {\n                createNightlyBuildMetaFile(nightlyBuildMetaFile);\n            }\n        }\n    }\n\n    /**\n     * Validate module version with the regex.\n     *\n     * @param moduleVersion module version\n     */\n    private static void validateModuleVersion(String moduleVersion) {\n        if (!moduleVersion.matches(VERSION_REGEX)) {\n            createError(\"module version could not be detected\");\n        }\n    }\n\n    /**\n     * Create nightly build meta file.\n     *\n     * @param nightlyBuildMetaFilePath nightly build meta file path\n     */\n    private static void createNightlyBuildMetaFile(Path nightlyBuildMetaFilePath) {\n        try {\n            Files.createFile(nightlyBuildMetaFilePath);\n        } catch (Exception e) {\n            createError(\"error occurred while creating nightly.build file.\");\n        }\n    }\n\n    /**\n     * Create balo file directory.\n     *\n     * @param fullPathToStoreBalo full path to store the balo file\n     *                            <user.home>.ballerina/balo_cache/<org-name>/<module-name>/<module-version>\n     */\n    private static void createBaloFileDirectory(Path fullPathToStoreBalo) {\n        try {\n            Files.createDirectory(fullPathToStoreBalo);\n        } catch (IOException e) {\n            createError(\"error creating directory for balo file\");\n        }\n    }\n\n    /**\n     * Handle error response.\n     *\n     * @param conn           https connection\n     * @param url            remote repository url\n     * @param moduleFullName module name with org and version\n     */\n    private static void handleErrorResponse(HttpsURLConnection conn, String url, String moduleFullName) {\n        try (BufferedReader reader = new BufferedReader(\n                new InputStreamReader(conn.getErrorStream(), Charset.defaultCharset()))) {\n            StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                result.append(line);\n            }\n\n            MapValue payload = (MapValue) JSONParser.parse(result.toString());\n            createError(\"error: \" + payload.getStringValue(\"message\"));\n        } catch (IOException e) {\n            createError(\"failed to pull the module '\" + moduleFullName + \"' from the remote repository '\" + url + \"'\");\n        }\n    }\n\n    /**\n     * Create error using log formatter.\n     *\n     * @param errMessage error message\n     */\n    private static void createError(String errMessage) {\n        throw ErrorUtil.createCommandException(logFormatter.formatLog(errMessage));\n    }\n\n    /**\n     * Get balo file name from content disposition header.\n     *\n     * @param contentDisposition content disposition header value\n     * @param baloFile           balo file name taken from RESOLVED_REQUESTED_URI\n     * @return balo file name\n     */\n    private static String getBaloFileName(String contentDisposition, String baloFile) {\n        if (contentDisposition != null && !contentDisposition.equals(\"\")) {\n            return contentDisposition.substring(\"attachment; filename=\".length());\n        } else {\n            return baloFile;\n        }\n    }\n}\n\n/**\n * Default log formatter class.\n */\nclass DefaultLogFormatter {\n    String formatLog(String msg) {\n        return msg;\n    }\n}\n\n/**\n * Build log formatter class which used to log the message for build command.\n */\nclass BuildLogFormatter extends DefaultLogFormatter {\n    @Override String formatLog(String msg) {\n        return \"\\t\" + msg;\n    }\n}\n", "// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n//\n// WSO2 Inc. licenses this file to you under the Apache License,\n// Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\npackage org.ballerinalang.cli.module;\n\nimport me.tongfei.progressbar.ProgressBar;\nimport me.tongfei.progressbar.ProgressBarStyle;\nimport org.ballerinalang.cli.module.util.ErrorUtil;\nimport org.ballerinalang.cli.module.util.Utils;\nimport org.ballerinalang.jvm.JSONParser;\nimport org.ballerinalang.jvm.values.MapValue;\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.Authenticator;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.ws.rs.core.HttpHeaders;\nimport javax.ws.rs.core.MediaType;\n\nimport static org.ballerinalang.cli.module.util.CliModuleConstants.PUSH_ORGANIZATION;\nimport static org.ballerinalang.cli.module.util.Utils.convertToUrl;\nimport static org.ballerinalang.cli.module.util.Utils.createHttpsUrlConnection;\nimport static org.ballerinalang.cli.module.util.Utils.getStatusCode;\nimport static org.ballerinalang.cli.module.util.Utils.setRequestMethod;\n\n/**\n * This class is pushing the modules to ballerina central.\n *\n * @since 1.2.0\n */\npublic class Push {\n\n    private static PrintStream errStream = System.err;\n    private static PrintStream outStream = System.out;\n    private static final int NO_OF_BYTES = 64;\n    private static final int BUFFER_SIZE = 1024 * NO_OF_BYTES;\n\n    private Push() {\n    }\n\n    /**\n     * Execute push command.\n     *\n     * @param url           remote uri of the central\n     * @param proxyHost     proxy host\n     * @param proxyPort     proxy port\n     * @param proxyUsername proxy username\n     * @param proxyPassword proxy password\n     * @param accessToken   access token of the org\n     * @param orgName       org name\n     * @param moduleName    module name\n     * @param version       module version\n     * @param baloPath      path to the balo\n     */\n    public static void execute(String url, String proxyHost, int proxyPort, String proxyUsername, String proxyPassword,\n            String accessToken, String orgName, String moduleName, String version, Path baloPath) {\n        HttpsURLConnection conn = createHttpsUrlConnection(convertToUrl(url), proxyHost, proxyPort, proxyUsername,\n                                                           proxyPassword);\n        conn.setInstanceFollowRedirects(false);\n        setRequestMethod(conn, Utils.RequestMethod.POST);\n\n        // Set headers\n        conn.setRequestProperty(HttpHeaders.AUTHORIZATION, \"Bearer \" + accessToken);\n        conn.setRequestProperty(PUSH_ORGANIZATION, orgName);\n        conn.setRequestProperty(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_OCTET_STREAM);\n\n        conn.setDoOutput(true);\n        conn.setChunkedStreamingMode(BUFFER_SIZE);\n\n        try (DataOutputStream outputStream = new DataOutputStream(conn.getOutputStream())) {\n            // Send balo content by 1 kb chunks\n            byte[] buffer = new byte[BUFFER_SIZE];\n            int count;\n            try (ProgressBar progressBar = new ProgressBar(\n                    orgName + \"/\" + moduleName + \":\" + version + \" [project repo -> central]\",\n                    getTotalFileSizeInKB(baloPath), 1000, outStream, ProgressBarStyle.ASCII, \" KB\", 1);\n                    FileInputStream fis = new FileInputStream(baloPath.toFile())) {\n                while ((count = fis.read(buffer)) > 0) {\n                    outputStream.write(buffer, 0, count);\n                    outputStream.flush();\n                    progressBar.stepBy((long) NO_OF_BYTES);\n                }\n            }\n        } catch (IOException e) {\n            throw ErrorUtil.createCommandException(\"error occurred while uploading balo to central: \" + e.getMessage());\n        }\n\n        handleResponse(conn, orgName, moduleName, version);\n        Authenticator.setDefault(null);\n    }\n\n    /**\n     * Handle the http response.\n     *\n     * @param conn       https connection\n     * @param orgName    org name\n     * @param moduleName module name\n     * @param version    module version\n     */\n    private static void handleResponse(HttpsURLConnection conn, String orgName, String moduleName, String version) {\n        try {\n            int statusCode = getStatusCode(conn);\n            // 200 - Module pushed successfully\n            // Other - Error occurred, json returned with the error message\n            if (statusCode == HttpsURLConnection.HTTP_OK) {\n                outStream.println(orgName + \"/\" + moduleName + \":\" + version + \" pushed to central successfully\");\n            } else if (statusCode == HttpsURLConnection.HTTP_UNAUTHORIZED) {\n                errStream.println(\"unauthorized access token for organization: \" + orgName);\n            } else if (statusCode == HttpsURLConnection.HTTP_BAD_REQUEST) {\n                try (BufferedReader reader = new BufferedReader(\n                        new InputStreamReader(conn.getErrorStream(), Charset.defaultCharset()))) {\n                    StringBuilder result = new StringBuilder();\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        result.append(line);\n                    }\n\n                    MapValue payload = (MapValue) JSONParser.parse(result.toString());\n                    String message = payload.getStringValue(\"message\");\n                    if (message.contains(\"module md file cannot be empty\")) {\n                        errStream.println(message);\n                    } else {\n                        throw ErrorUtil.createCommandException(message);\n                    }\n                } catch (IOException e) {\n                    throw ErrorUtil.createCommandException(\n                            \"failed to push the module '\" + orgName + \"/\" + moduleName + \":\" + version\n                                    + \"' to the remote repository '\" + conn.getURL() + \"'\");\n                }\n            } else {\n                throw ErrorUtil.createCommandException(\n                        \"failed to push the module '\" + orgName + \"/\" + moduleName + \":\" + version\n                                + \"' to the remote repository '\" + conn.getURL() + \"'\");\n            }\n        } finally {\n            conn.disconnect();\n        }\n    }\n\n    /**\n     * Get total file size in kb.\n     *\n     * @param filePath path to the file\n     * @return size of the file in kb\n     */\n    private static long getTotalFileSizeInKB(Path filePath) {\n        byte[] baloContent;\n        try {\n            baloContent = Files.readAllBytes(filePath);\n            return baloContent.length / 1024;\n        } catch (IOException e) {\n            throw ErrorUtil.createCommandException(\"cannot read the balo content\");\n        }\n    }\n}\n", "// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n//\n// WSO2 Inc. licenses this file to you under the Apache License,\n// Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\npackage org.ballerinalang.cli.module;\n\nimport org.ballerinalang.cli.module.util.ErrorUtil;\nimport org.ballerinalang.cli.module.util.Utils;\nimport org.ballerinalang.jvm.JSONParser;\nimport org.ballerinalang.jvm.values.ArrayValue;\nimport org.ballerinalang.jvm.values.MapValue;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.Authenticator;\nimport java.nio.charset.Charset;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nimport javax.net.ssl.HttpsURLConnection;\n\nimport static org.ballerinalang.cli.module.util.Utils.convertToUrl;\nimport static org.ballerinalang.cli.module.util.Utils.createHttpsUrlConnection;\nimport static org.ballerinalang.cli.module.util.Utils.getStatusCode;\nimport static org.ballerinalang.cli.module.util.Utils.setRequestMethod;\n\n/**\n * This class is searching modules from ballerina central.\n *\n * @since 1.2.0\n */\npublic class Search {\n\n    private static PrintStream outStream = System.out;\n\n    private Search() {\n    }\n\n    /**\n     * Execute search command.\n     *\n     * @param url           remote uri of the central\n     * @param proxyHost     proxy host\n     * @param proxyPort     proxy port\n     * @param proxyUsername proxy username\n     * @param proxyPassword proxy password\n     * @param terminalWidth terminal width of the CLI\n     */\n    public static void execute(String url, String proxyHost, int proxyPort, String proxyUsername, String proxyPassword,\n            String terminalWidth) {\n        HttpsURLConnection conn = createHttpsUrlConnection(convertToUrl(url), proxyHost, proxyPort, proxyUsername,\n                                                           proxyPassword);\n        conn.setInstanceFollowRedirects(false);\n        setRequestMethod(conn, Utils.RequestMethod.GET);\n        handleResponse(conn, getStatusCode(conn), terminalWidth);\n        Authenticator.setDefault(null);\n    }\n\n    /**\n     * Handle http response.\n     *\n     * @param conn          https connection\n     * @param statusCode    status code of the response\n     * @param terminalWidth terminal width of the CLI\n     */\n    private static void handleResponse(HttpsURLConnection conn, int statusCode, String terminalWidth) {\n        try {\n            // 200 - modules found\n            // Other - Error occurred, json returned with the error message\n            MapValue payload;\n            if (statusCode == HttpsURLConnection.HTTP_OK) {\n                try (BufferedReader reader = new BufferedReader(\n                        new InputStreamReader(conn.getInputStream(), Charset.defaultCharset()))) {\n                    StringBuilder result = new StringBuilder();\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        result.append(line);\n                    }\n                    payload = (MapValue) JSONParser.parse(result.toString());\n                } catch (IOException e) {\n                    throw ErrorUtil.createCommandException(e.getMessage());\n                }\n\n                if (payload.getIntValue(\"count\") > 0) {\n                    ArrayValue modules = payload.getArrayValue(\"modules\");\n                    printModules(modules, terminalWidth);\n                } else {\n                    outStream.println(\"no modules found\");\n                }\n            } else {\n                StringBuilder result = new StringBuilder();\n                try (BufferedReader reader = new BufferedReader(\n                        new InputStreamReader(conn.getErrorStream(), Charset.defaultCharset()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        result.append(line);\n                    }\n                } catch (IOException e) {\n                    throw ErrorUtil.createCommandException(e.getMessage());\n                }\n\n                payload = (MapValue) JSONParser.parse(result.toString());\n                throw ErrorUtil.createCommandException(payload.getStringValue(\"message\"));\n            }\n        } finally {\n            conn.disconnect();\n        }\n    }\n\n    /**\n     * Print module information as a table in the CLI.\n     *\n     * @param modules       modules array\n     * @param terminalWidth terminal width of the CLI\n     */\n    public static void printModules(ArrayValue modules, String terminalWidth) {\n        int rightMargin = 3;\n        int width = Integer.parseInt(terminalWidth) - rightMargin;\n        int dateColWidth = 15;\n        int versionColWidth = 8;\n        int authorsColWidth = 15;\n        double nameColFactor = 9.0;\n        double descColFactor = 16.0;\n        int additionalSpace = 7;\n        double remainingWidth = (double) width - (dateColWidth + versionColWidth + additionalSpace);\n        int nameColWidth = (int) Math.round(remainingWidth * (nameColFactor / (nameColFactor + descColFactor)));\n        int descColWidth = (int) Math.round(remainingWidth * (descColFactor / (nameColFactor + descColFactor)));\n        int minDescColWidth = 60;\n\n        printTitle();\n        printTableHeader(dateColWidth, versionColWidth, nameColWidth, descColWidth, minDescColWidth, authorsColWidth);\n\n        int i = 0;\n        while (i < modules.size()) {\n            printModule((MapValue) modules.get(i), dateColWidth, versionColWidth, authorsColWidth, nameColWidth,\n                    descColWidth, minDescColWidth);\n            i = i + 1;\n            outStream.println();\n        }\n        outStream.println();\n        outStream.println(modules.size() + \" modules found\");\n    }\n\n    /**\n     * Print module row.\n     *\n     * @param module          module information\n     * @param dateColWidth    date column width\n     * @param versionColWidth version column width\n     * @param nameColWidth    name column width\n     * @param descColWidth    description column width\n     * @param minDescColWidth minimum description column width\n     * @param authorsColWidth authors column width\n     */\n    private static void printModule(MapValue module, int dateColWidth, int versionColWidth, int authorsColWidth,\n            int nameColWidth, int descColWidth, int minDescColWidth) {\n        String orgName = module.getStringValue(\"orgName\");\n        String packageName = module.getStringValue(\"name\");\n        printInCLI(\"|\" + orgName + \"/\" + packageName, nameColWidth);\n\n        String summary = module.getStringValue(\"summary\");\n\n        if (descColWidth >= minDescColWidth) {\n            printInCLI(summary, descColWidth - authorsColWidth);\n            String authors = \"\";\n            ArrayValue authorsArr = module.getArrayValue(\"authors\");\n\n            if (authorsArr.size() > 0) {\n                for (int j = 0; j < authorsArr.size(); j++) {\n                    if (j == 0) {\n                        authors = (String) authorsArr.get(j);\n                    } else if (j == authorsArr.size() - 1) {\n                        authors = (String) authorsArr.get(j);\n                    } else {\n                        authors = \", \" + authorsArr.get(j);\n                    }\n                }\n            }\n            printInCLI(authors, authorsColWidth);\n        } else {\n            printInCLI(summary, descColWidth);\n        }\n\n        long createTimeJson = module.getIntValue(\"createdDate\");\n        printInCLI(getDateCreated(createTimeJson), dateColWidth);\n\n        String packageVersion = module.getStringValue(\"version\");\n        printInCLI(packageVersion, versionColWidth);\n    }\n\n    /**\n     * Print the tile.\n     */\n    private static void printTitle() {\n        outStream.println();\n        outStream.println(\"Ballerina Central\");\n        outStream.println(\"=================\");\n        outStream.println();\n    }\n\n    /**\n     * Print in CLI.\n     *\n     * @param element           printing element\n     * @param charactersAllowed number of characters allowed\n     */\n    private static void printInCLI(String element, int charactersAllowed) {\n        int lengthOfElement = element.length();\n        if (lengthOfElement > charactersAllowed || lengthOfElement == charactersAllowed) {\n            int margin = 3;\n            String trimmedElement = element.substring(0, charactersAllowed - margin) + \"...\";\n            outStream.print(trimmedElement + \" |\");\n        } else {\n            printCharacter(element, charactersAllowed, \" \", false);\n        }\n    }\n\n    /**\n     * Print characters.\n     *\n     * @param element           printing element\n     * @param charactersAllowed number of characters allowed\n     * @param separator         separating element\n     * @param isDashElement     is a dash element\n     */\n    private static void printCharacter(String element, int charactersAllowed, String separator, boolean isDashElement) {\n        int lengthOfElement = element.length();\n        StringBuilder print = new StringBuilder(element);\n        int i = 0;\n        while (i < charactersAllowed - lengthOfElement) {\n            print.append(separator);\n            i = i + 1;\n        }\n        if (isDashElement) {\n            outStream.print(print + \"-|\");\n        } else {\n            outStream.print(print + \" |\");\n        }\n    }\n\n    /**\n     * Get date in simple date format.\n     *\n     * @param timeInMillis date in millis\n     * @return date in simple date format\n     */\n    private static String getDateCreated(long timeInMillis) {\n        Date date = new Date(timeInMillis);\n        DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd-E\");\n        return df.format(date);\n    }\n\n    /**\n     * Print table header.\n     *\n     * @param dateColWidth    date column width\n     * @param versionColWidth version column width\n     * @param nameColWidth    name column width\n     * @param descColWidth    description column width\n     * @param minDescColWidth minimum description column width\n     * @param authorsColWidth authors column width\n     */\n    private static void printTableHeader(int dateColWidth, int versionColWidth, int nameColWidth, int descColWidth,\n            int minDescColWidth, int authorsColWidth) {\n        printHeadingRow(dateColWidth, versionColWidth, nameColWidth, descColWidth, minDescColWidth, authorsColWidth);\n        printDashRow(dateColWidth, versionColWidth, nameColWidth, descColWidth, minDescColWidth, authorsColWidth);\n    }\n\n    /**\n     * Print heading row of the table header.\n     *\n     * @param dateColWidth    date column width\n     * @param versionColWidth version column width\n     * @param nameColWidth    name column width\n     * @param descColWidth    description column width\n     * @param minDescColWidth minimum description column width\n     * @param authorsColWidth authors column width\n     */\n    private static void printHeadingRow(int dateColWidth, int versionColWidth, int nameColWidth, int descColWidth,\n            int minDescColWidth, int authorsColWidth) {\n        printInCLI(\"|NAME\", nameColWidth);\n        if (descColWidth >= minDescColWidth) {\n            printInCLI(\"DESCRIPTION\", descColWidth - authorsColWidth);\n            printInCLI(\"AUTHOR\", authorsColWidth);\n        } else {\n            printInCLI(\"DESCRIPTION\", descColWidth);\n        }\n        printInCLI(\"DATE\", dateColWidth);\n        printInCLI(\"VERSION\", versionColWidth);\n        outStream.println();\n    }\n\n    /**\n     * Print dash row of the table header.\n     *\n     * @param dateColWidth    date column width\n     * @param versionColWidth version column width\n     * @param nameColWidth    name column width\n     * @param descColWidth    description column width\n     * @param minDescColWidth minimum description column width\n     * @param authorsColWidth authors column width\n     */\n    private static void printDashRow(int dateColWidth, int versionColWidth, int nameColWidth, int descColWidth,\n            int minDescColWidth, int authorsColWidth) {\n        printCharacter(\"|-\", nameColWidth, \"-\", true);\n\n        if (descColWidth >= minDescColWidth) {\n            printCharacter(\"-\", descColWidth - authorsColWidth, \"-\", true);\n            printCharacter(\"-\", authorsColWidth, \"-\", true);\n        } else {\n            printCharacter(\"-\", descColWidth, \"-\", true);\n        }\n\n        printCharacter(\"-\", dateColWidth, \"-\", true);\n        printCharacter(\"-\", versionColWidth, \"-\", true);\n\n        outStream.println();\n    }\n}\n", "// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n//\n// WSO2 Inc. licenses this file to you under the Apache License,\n// Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\npackage org.ballerinalang.cli.module;\n\nimport com.sun.net.httpserver.HttpExchange;\nimport com.sun.net.httpserver.HttpHandler;\nimport com.sun.net.httpserver.HttpServer;\nimport org.ballerinalang.cli.module.util.ErrorUtil;\n\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.InetSocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Paths;\nimport java.util.Collections;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.ws.rs.core.HttpHeaders;\n\nimport static org.ballerinalang.cli.module.util.CliModuleConstants.SETTINGS_TOML_FILE;\n\n/**\n * This class has a service which updates the access token in the `Settings.toml` file.\n *\n * @since 1.2.0\n */\npublic class TokenUpdater {\n\n    private static PrintStream errStream = System.err;\n    private static PrintStream outStream = System.out;\n\n    private TokenUpdater() {\n    }\n\n    /**\n     * Creating the server which updates the access token in the `Settings.toml` file.\n     *\n     * @param settingsTomlFilePath `Settings.toml` file path\n     */\n    public static void execute(String settingsTomlFilePath) {\n        HttpServer server;\n        try {\n            server = HttpServer.create(new InetSocketAddress(9295), 0);\n        } catch (IOException e) {\n            throw ErrorUtil.createCommandException(\"error occurred while creating the server: \" + e.getMessage() +\n                    \"Access token is missing in \" + settingsTomlFilePath +\n                    \"\\nAuto update failed. Please visit https://central.ballerina.io, get token and add it to the\" +\n                    settingsTomlFilePath + \" file.\");\n        }\n        server.createContext(\"/update-settings\", new TokenUpdateHandler());\n        server.setExecutor(null); // creates a default executor\n        server.start();\n    }\n\n    /**\n     * Http handler of the server.\n     */\n    static class TokenUpdateHandler implements HttpHandler {\n\n        @Override public void handle(HttpExchange httpExchange) {\n            String token = getToken(httpExchange.getRequestURI().getPath());\n            String currentUsersHomeDir = System.getProperty(\"user.home\");\n            String settingsTomlPath = String.valueOf(Paths.get(currentUsersHomeDir, \".ballerina\", SETTINGS_TOML_FILE));\n            FileOutputStream outputStream = null;\n            try {\n                outputStream = new FileOutputStream(settingsTomlPath);\n                String str = \"[central]\\naccesstoken=\\\"\" + token + \"\\\"\";\n                outputStream.write(str.getBytes(StandardCharsets.UTF_8));\n            } catch (FileNotFoundException e) {\n                throw ErrorUtil.createCommandException(\"Settings.toml file could not be found: \" + settingsTomlPath);\n            } catch (IOException e) {\n                throw ErrorUtil.createCommandException(\n                        \"error occurred while writing to the Settings.toml file: \" + e.getMessage());\n            } finally {\n                try {\n                    if (outputStream != null) {\n                        outputStream.close();\n                    }\n                } catch (IOException e) {\n                    errStream.println(\"error occurred while closing the output stream: \" + e.getMessage());\n                }\n            }\n            outStream.println(\"token updated\");\n\n            OutputStream os = null;\n            try {\n                String response = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"/>\";\n                httpExchange.getResponseHeaders()\n                        .put(HttpHeaders.CONTENT_TYPE, Collections.singletonList(\"image/svg+xml\"));\n                httpExchange.sendResponseHeaders(HttpsURLConnection.HTTP_OK,\n                                                 response.getBytes(StandardCharsets.UTF_8).length);\n                os = httpExchange.getResponseBody();\n                os.write(response.getBytes(StandardCharsets.UTF_8));\n            } catch (IOException e) {\n                throw ErrorUtil\n                        .createCommandException(\"error occurred while generating the response: \" + e.getMessage());\n            } finally {\n                try {\n                    if (os != null) {\n                        os.close();\n                    }\n                } catch (IOException e) {\n                    errStream.println(\"error occurred while closing the output stream: \" + e.getMessage());\n                }\n            }\n        }\n\n        /**\n         * Get access token from url.\n         *\n         * @param uri url with access token\n         * @return access token\n         */\n        private static String getToken(String uri) {\n            String[] uriParts = uri.split(\"/\");\n            return uriParts[uriParts.length - 1];\n        }\n    }\n}\n", "// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n//\n// WSO2 Inc. licenses this file to you under the Apache License,\n// Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\npackage org.ballerinalang.cli.module.util;\n\nimport java.io.IOException;\nimport java.net.Authenticator;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.PasswordAuthentication;\nimport java.net.ProtocolException;\nimport java.net.Proxy;\nimport java.net.URL;\n\nimport javax.net.ssl.HttpsURLConnection;\n\n/**\n * Class contains miscellaneous utility methods.\n *\n * @since 1.2.0\n */\npublic class Utils {\n\n    /**\n     * Request method types.\n     */\n    public enum RequestMethod {\n        GET, POST\n    }\n\n    /**\n     * Get proxy for http connection.\n     *\n     * @param proxyHost     proxy host\n     * @param proxyPort     proxy port\n     * @param proxyUsername proxy username\n     * @param proxyPassword proxy password\n     * @return The proxy object.\n     */\n    public static Proxy getProxy(String proxyHost, int proxyPort, String proxyUsername, String proxyPassword) {\n        if (!\"\".equals(proxyHost)) {\n            InetSocketAddress proxyInet = new InetSocketAddress(proxyHost, proxyPort);\n            if (!\"\".equals(proxyUsername) && \"\".equals(proxyPassword)) {\n                Authenticator authenticator = new Authenticator() {\n                    @Override public PasswordAuthentication getPasswordAuthentication() {\n                        return (new PasswordAuthentication(proxyUsername, proxyPassword.toCharArray()));\n                    }\n                };\n                Authenticator.setDefault(authenticator);\n            }\n            return new Proxy(Proxy.Type.HTTP, proxyInet);\n        }\n        return null;\n    }\n\n    /**\n     * Convert string to URL.\n     *\n     * @param url string URL\n     * @return URL\n     */\n    public static URL convertToUrl(String url) {\n        try {\n            return new URL(url);\n        } catch (MalformedURLException e) {\n            throw ErrorUtil.createCommandException(e.getMessage());\n        }\n    }\n\n    /**\n     * Create https URL connection.\n     *\n     * @param url           connection URL\n     * @param proxyHost     proxy host\n     * @param proxyPort     proxy port\n     * @param proxyUsername proxy username\n     * @param proxyPassword proxy password\n     * @return http URL connection\n     */\n    public static HttpsURLConnection createHttpsUrlConnection(URL url, String proxyHost, int proxyPort,\n            String proxyUsername, String proxyPassword) {\n        try {\n            Proxy proxy = getProxy(proxyHost, proxyPort, proxyUsername, proxyPassword);\n            // set proxy if exists.\n            if (proxy == null) {\n                return (HttpsURLConnection) url.openConnection();\n            } else {\n                return (HttpsURLConnection) url.openConnection(proxy);\n            }\n        } catch (IOException e) {\n            throw ErrorUtil.createCommandException(e.getMessage());\n        }\n    }\n\n    /**\n     * Set request method of the http connection.\n     *\n     * @param conn   https connection\n     * @param method request method\n     */\n    public static void setRequestMethod(HttpsURLConnection conn, RequestMethod method) {\n        try {\n            conn.setRequestMethod(getRequestMethodAsString(method));\n        } catch (ProtocolException e) {\n            throw ErrorUtil.createCommandException(e.getMessage());\n        }\n    }\n\n    private static String getRequestMethodAsString(RequestMethod method) {\n        switch (method) {\n        case GET:\n            return \"GET\";\n        case POST:\n            return \"POST\";\n        default:\n            throw ErrorUtil.createCommandException(\"invalid request method:\" + method);\n        }\n    }\n\n    /**\n     * Get status code of http response.\n     *\n     * @param conn https connection\n     * @return status code\n     */\n    public static int getStatusCode(HttpsURLConnection conn) {\n        try {\n            return conn.getResponseCode();\n        } catch (IOException e) {\n            throw ErrorUtil\n                    .createCommandException(\"connection to the remote repository host failed: \" + e.getMessage());\n        }\n    }\n}\n", "/*\n * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n *\n * WSO2 Inc. licenses this file to you under the Apache License,\n * Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.ballerinalang.cli.module;\n\nimport org.ballerinalang.cli.module.util.Utils;\nimport org.testng.Assert;\nimport org.testng.annotations.Test;\n\nimport java.net.Proxy;\n\nimport javax.net.ssl.HttpsURLConnection;\n\nimport static org.ballerinalang.cli.module.util.Utils.convertToUrl;\nimport static org.ballerinalang.cli.module.util.Utils.createHttpsUrlConnection;\n\n/**\n * Unit tests for Utils class.\n *\n * @since 1.2.0\n */\npublic class UtilsTest {\n\n    private static final String TEST_URL = \"https://api.central.ballerina.io/1.0/modules\";\n\n    @Test(description = \"Test creating proxy\")\n    public void testGetProxy() {\n        Proxy proxy;\n        // Test without proxy\n        proxy = Utils.getProxy(\"\", 0, \"\", \"\");\n        Assert.assertNull(proxy);\n        // Test with proxy\n        proxy = Utils.getProxy(\"http://localhost\", 9090, \"testUser\", \"testPassword\");\n        Assert.assertNotNull(proxy);\n        Assert.assertEquals(proxy.toString(), \"HTTP @ http://localhost:9090\");\n\n    }\n\n    @Test(description = \"Test create https URL connection without proxy\")\n    public void testCreateHttpUrlConnection() {\n        HttpsURLConnection conn;\n        // Test without proxy\n        conn = createHttpsUrlConnection(convertToUrl(TEST_URL), \"\", 0, \"\", \"\");\n        Assert.assertNotNull(conn);\n        // Test with the proxy\n        conn = createHttpsUrlConnection(convertToUrl(TEST_URL), \"http://localhost\", 9090, \"testUser\", \"testPassword\");\n        Assert.assertNotNull(conn);\n    }\n\n    @Test(description = \"Test set request\")\n    public void testSetRequestMethod() {\n        HttpsURLConnection conn = createHttpsUrlConnection(convertToUrl(TEST_URL), \"\", 0, \"\", \"\");\n        Utils.setRequestMethod(conn, Utils.RequestMethod.POST);\n        Assert.assertEquals(conn.getRequestMethod(), \"POST\");\n    }\n\n\n}\n", "/*\n * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n *\n * WSO2 Inc. licenses this file to you under the Apache License,\n * Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.wso2.ballerinalang.compiler.packaging.converters;\n\nimport org.ballerinalang.jvm.JSONParser;\nimport org.ballerinalang.jvm.values.MapValue;\nimport org.ballerinalang.model.elements.PackageID;\nimport org.ballerinalang.repository.CompilerInput;\nimport org.ballerinalang.toml.model.Manifest;\nimport org.wso2.ballerinalang.compiler.util.Name;\nimport org.wso2.ballerinalang.util.TomlParserUtils;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.Authenticator;\nimport java.net.InetSocketAddress;\nimport java.net.PasswordAuthentication;\nimport java.net.Proxy;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport javax.net.ssl.HttpsURLConnection;\n\n/**\n *  Checks if there is a latest version in central if version is not mentioned. If there is then the version of the\n *  module is updated with that version.\n */\npublic class URIDryConverter extends URIConverter {\n\n    /**\n     * This is to keep track that an error has already been logged so that it doesn't repeatedly log the same error.\n     */\n    private static boolean loggedError = false;\n    private static final Pattern semVerPatchPattern = Pattern.compile(\"(\\\\d+)\\\\.(\\\\d+)\");\n    private PrintStream errStream = System.err;\n    private Proxy proxy;\n\n    public URIDryConverter(URI base, Map<PackageID, Manifest> dependencyManifests) {\n        this(base, dependencyManifests, false);\n    }\n\n    public URIDryConverter(URI base, Map<PackageID, Manifest> dependencyManifests, boolean isBuild) {\n        super(base, dependencyManifests, isBuild);\n        this.base = URI.create(base.toString() + \"/modules/info/\");\n        proxy = getProxy();\n    }\n\n    public Stream<CompilerInput> finalize(URI remoteURI, PackageID moduleID) {\n        try {\n            // only continue if a fixed module version is not set. a module version may be set through Ballerina.toml or\n            // Ballerina.lock already.\n            Matcher matcher = semVerPatchPattern.matcher(moduleID.version.value);\n            if (\"\".equals(moduleID.version.value) || \"*\".equals(moduleID.version.value) || matcher.matches()) {\n                HttpsURLConnection conn;\n                // set proxy if exists.\n                if (null == this.proxy) {\n                    conn = (HttpsURLConnection) remoteURI.toURL().openConnection();\n                } else {\n                    conn = (HttpsURLConnection) remoteURI.toURL().openConnection(this.proxy);\n                }\n                conn.setInstanceFollowRedirects(false);\n                conn.setRequestMethod(\"GET\");\n\n                // status code and meaning\n                //// 200 - module info found\n                //// 400 - bad request sent\n                //// 500 - backend is broken\n                int statusCode = conn.getResponseCode();\n                if (statusCode == 200) {\n                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(),\n                            Charset.defaultCharset()))) {\n                        StringBuilder result = new StringBuilder();\n                        String line;\n                        while ((line = reader.readLine()) != null) {\n                            result.append(line);\n                        }\n                        Object payload = JSONParser.parse(result.toString());\n                        if (payload instanceof MapValue) {\n                            MapValue moduleInfo = ((MapValue) payload).getMapValue(\"module\");\n                            String version = moduleInfo.getStringValue(\"version\");\n                            moduleID.version = new Name(version);\n                        }\n                    }\n                } else if (statusCode == 400 && !loggedError) {\n                    try (BufferedReader errorStream = new BufferedReader(\n                            new InputStreamReader(conn.getInputStream(), Charset.defaultCharset()))) {\n                        String errorContent = errorStream.lines().collect(Collectors.joining(\"\\n\"));\n                        this.errStream.println(\"error: could not connect to remote repository to find the latest \" +\n                                \"version of module: \" + moduleID.toString() + \". use '--offline' \" +\n                                \"flag to build in offline mode. reason: \" + errorContent);\n                        setErrorLoggedStatusAsTrue();\n                    }\n                } else if (statusCode == 500 && !loggedError) {\n                    this.errStream.println(\"error: could not connect to remote repository to find the latest \" +\n                            \"version of module: \" + moduleID.toString() + \". use '--offline' \" +\n                            \"flag to build in offline mode.\");\n                    setErrorLoggedStatusAsTrue();\n                }\n                conn.disconnect();\n                Authenticator.setDefault(null);\n            }\n        } catch (IOException e) {\n            // ignore error and don't set the version.\n        }\n\n        return Stream.empty();\n    }\n\n    /**\n     * Set the status that an error has been logged.\n     */\n    private static void setErrorLoggedStatusAsTrue() {\n        loggedError = true;\n    }\n\n    /**\n     * Get proxy for http connection.\n     *\n     * @return The proxy object.\n     */\n    private Proxy getProxy() {\n        org.ballerinalang.toml.model.Proxy proxy = TomlParserUtils.readSettings().getProxy();\n        if (!\"\".equals(proxy.getHost())) {\n            InetSocketAddress proxyInet = new InetSocketAddress(proxy.getHost(), proxy.getPort());\n            if (!\"\".equals(proxy.getUserName()) && \"\".equals(proxy.getPassword())) {\n                Authenticator authenticator = new RemoteAuthenticator();\n                Authenticator.setDefault(authenticator);\n            }\n            return new Proxy(Proxy.Type.HTTP, proxyInet);\n        }\n\n        return null;\n    }\n\n    /**\n     * Authenticator for the proxy server if provided.\n     */\n    static class RemoteAuthenticator extends Authenticator {\n        org.ballerinalang.toml.model.Proxy proxy;\n        public RemoteAuthenticator() {\n            proxy = TomlParserUtils.readSettings().getProxy();\n        }\n\n        @Override\n        protected PasswordAuthentication getPasswordAuthentication() {\n            return (new PasswordAuthentication(this.proxy.getUserName(), this.proxy.getPassword().toCharArray()));\n        }\n    }\n}\n", "/*\n * Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.ballerinalang.openapi;\n\nimport com.github.jknack.handlebars.Context;\nimport com.github.jknack.handlebars.Handlebars;\nimport com.github.jknack.handlebars.Template;\nimport com.github.jknack.handlebars.context.FieldValueResolver;\nimport com.github.jknack.handlebars.context.JavaBeanValueResolver;\nimport com.github.jknack.handlebars.context.MapValueResolver;\nimport com.github.jknack.handlebars.helper.StringHelpers;\nimport com.github.jknack.handlebars.io.ClassPathTemplateLoader;\nimport com.github.jknack.handlebars.io.FileTemplateLoader;\nimport io.swagger.v3.oas.models.OpenAPI;\nimport io.swagger.v3.parser.OpenAPIV3Parser;\nimport org.apache.commons.lang3.StringUtils;\nimport org.ballerinalang.openapi.exception.BallerinaOpenApiException;\nimport org.ballerinalang.openapi.model.BallerinaOpenApi;\nimport org.ballerinalang.openapi.model.GenSrcFile;\nimport org.ballerinalang.openapi.typemodel.BallerinaOpenApiType;\nimport org.ballerinalang.openapi.utils.CodegenUtils;\nimport org.ballerinalang.openapi.utils.GeneratorConstants;\nimport org.ballerinalang.openapi.utils.GeneratorConstants.GenType;\nimport org.ballerinalang.openapi.utils.TypeExtractorUtil;\nimport org.ballerinalang.tool.LauncherUtils;\nimport org.wso2.ballerinalang.compiler.util.ProjectDirs;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static org.ballerinalang.openapi.model.GenSrcFile.GenFileType;\nimport static org.ballerinalang.openapi.utils.GeneratorConstants.GenType.GEN_CLIENT;\nimport static org.ballerinalang.openapi.utils.GeneratorConstants.MODULE_MD;\n\n/**\n * This class generates Ballerina Services/Clients for a provided OAS definition.\n */\npublic class CodeGenerator {\n    private String srcPackage;\n    private String modelPackage;\n\n    private static final PrintStream outStream = System.err;\n\n    /**\n     * Generates ballerina source for provided Open API Definition in {@code definitionPath}.\n     * Generated source will be written to a ballerina module at {@code outPath}\n     * <p>Method can be user for generating Ballerina mock services and clients</p>\n     *\n     * @param type           Output type. Following types are supported\n     *                       <ul>\n     *                       <li>mock</li>\n     *                       <li>client</li>\n     *                       </ul>\n     * @param executionPath  Command execution path\n     * @param definitionPath Input Open Api Definition file path\n     * @param serviceName    Output Service Name\n     * @param outPath        Destination file path to save generated source files. If not provided\n     *                       {@code definitionPath} will be used as the default destination path\n     * @throws IOException               when file operations fail\n     * @throws BallerinaOpenApiException when code generator fails\n     */\n    private void generate(GenType type, String executionPath, String definitionPath,\n                          String reldefinitionPath , String serviceName, String outPath)\n            throws IOException, BallerinaOpenApiException {\n\n        if (!CodegenUtils.isBallerinaProject(Paths.get(outPath))) {\n            throw new BallerinaOpenApiException(OpenApiMesseges.GEN_CLIENT_PROJECT_ROOT);\n        }\n\n        //Check if the selected path is a ballerina root for service generation\n        //TODO check with team for root check\n        Path projectRoot = ProjectDirs.findProjectRoot(Paths.get(executionPath));\n        if (type.equals(GenType.GEN_SERVICE) && projectRoot == null) {\n            throw LauncherUtils.createUsageExceptionWithHelp(OpenApiMesseges.GEN_SERVICE_PROJECT_ROOT);\n        }\n\n        Path srcPath = CodegenUtils.getSourcePath(srcPackage, outPath);\n        Path implPath = CodegenUtils.getImplPath(srcPackage, srcPath);\n\n        if (type.equals(GEN_CLIENT)) {\n            if (srcPackage.equals(\"\")) {\n                srcPath = srcPath.resolve(\"client\");\n                implPath = implPath.resolve(\"client\");\n            }\n\n            if (Files.notExists(srcPath)) {\n                Files.createDirectory(srcPath);\n            }\n\n            if (Files.notExists(implPath)) {\n                Files.createDirectory(implPath);\n            }\n\n        }\n\n        List<GenSrcFile> genFiles = generateBalSource(type, definitionPath, reldefinitionPath, serviceName);\n        writeGeneratedSources(genFiles, srcPath, implPath, type);\n    }\n\n    /**\n     * Generates ballerina source for provided Open API Definition in {@code definitionPath}.\n     * Generated source will be written to a ballerina module at {@code outPath}\n     * Method can be user for generating Ballerina clients.\n     *\n     * @param executionPath  Command execution path\n     * @param definitionPath Input Open Api Definition file path\n     * @param serviceName    service name\n     * @param outPath        Destination file path to save generated source files. If not provided\n     *                       {@code definitionPath} will be used as the default destination path\n     * @throws IOException               when file operations fail\n     * @throws BallerinaOpenApiException when code generator fails\n     */\n    public void generateClient(String executionPath, String definitionPath, String serviceName, String outPath)\n            throws IOException, BallerinaOpenApiException {\n        generate(GenType.GEN_CLIENT, executionPath, definitionPath, null, serviceName, outPath);\n    }\n\n    /**\n     * Generates ballerina source for provided Open API Definition in {@code definitionPath}.\n     * Generated source will be written to a ballerina module at {@code outPath}\n     * Method can be user for generating Ballerina clients.\n     *\n     * @param executionPath  Command execution path\n     * @param definitionPath Input Open Api Definition file path\n     * @param reldefinitionPath Relative definition path to be used in the generated ballerina code\n     * @param serviceName    service name for the generated service\n     * @param outPath        Destination file path to save generated source files. If not provided\n     *                       {@code definitionPath} will be used as the default destination path\n     * @throws IOException               when file operations fail\n     * @throws BallerinaOpenApiException when code generator fails\n     */\n    public void generateService(String executionPath, String definitionPath,\n                                String reldefinitionPath, String serviceName, String outPath)\n            throws IOException, BallerinaOpenApiException {\n        generate(GenType.GEN_SERVICE, executionPath, definitionPath, reldefinitionPath, serviceName, outPath);\n    }\n\n    /**\n     * Generates ballerina source for provided Open API Definition in {@code definitionPath}.\n     * Generated code will be returned as a list of source files\n     * <p>Method can be user for generating Ballerina mock services and clients</p>\n     *\n     * @param type           Output type. Following types are supported\n     *                       <ul>\n     *                       <li>mock</li>\n     *                       <li>client</li>\n     *                       </ul>\n     * @param serviceName    Out put service name\n     * @param definitionPath Input Open Api Definition file path\n     * @param reldefinitionPath Relative OpenApi File\n     * @return a list of generated source files wrapped as {@link GenSrcFile}\n     * @throws IOException               when file operations fail\n     * @throws BallerinaOpenApiException when open api context building fail\n     */\n    public List<GenSrcFile> generateBalSource(GenType type, String definitionPath,\n                                              String reldefinitionPath, String serviceName)\n            throws IOException, BallerinaOpenApiException {\n        OpenAPI api = new OpenAPIV3Parser().read(definitionPath);\n\n        if (api == null) {\n            throw new BallerinaOpenApiException(\"Couldn't read the definition from file: \" + definitionPath);\n        }\n\n        if (serviceName != null) {\n            api.getInfo().setTitle(serviceName);\n        } else if (api.getInfo() == null || StringUtils.isEmpty(api.getInfo().getTitle())) {\n            api.getInfo().setTitle(GeneratorConstants.UNTITLED_SERVICE);\n        }\n\n        List<GenSrcFile> sourceFiles;\n\n        switch (type) {\n            case GEN_CLIENT:\n                // modelPackage is not in use at the moment. All models will be written into same package\n                // as other src files.\n                // Therefore value set to modelPackage is ignored here\n                BallerinaOpenApi definitionContext = new BallerinaOpenApi().buildContext(api).srcPackage(srcPackage)\n                        .modelPackage(srcPackage);\n                definitionContext.setDefinitionPath(reldefinitionPath);\n\n                sourceFiles = generateClient(definitionContext);\n                break;\n            case GEN_SERVICE:\n\n                final BallerinaOpenApiType openApi = TypeExtractorUtil.extractOpenApiObject(api);\n                openApi.setBalServiceName(serviceName);\n                openApi.setBalModule(srcPackage);\n                openApi.setServers(api);\n                openApi.setTags(api.getTags());\n\n                if (reldefinitionPath == null) {\n                    openApi.setDefPath(definitionPath.replaceAll(Pattern.quote(\"\\\\\"),\n                            Matcher.quoteReplacement(\"\\\\\\\\\")));\n                } else {\n                    openApi.setDefPath(reldefinitionPath.replaceAll(Pattern.quote(\"\\\\\"),\n                            Matcher.quoteReplacement(\"\\\\\\\\\")));\n                }\n\n                sourceFiles = generateBallerinaService(openApi);\n                break;\n            default:\n                return null;\n        }\n\n        return sourceFiles;\n    }\n\n    /**\n     * Write ballerina definition of a <code>object</code> to a file as described by <code>template.</code>\n     *\n     * @param object       Context object to be used by the template parser\n     * @param templateDir  Directory with all the templates required for generating the source file\n     * @param templateName Name of the parent template to be used\n     * @param outPath      Destination path for writing the resulting source file\n     * @throws IOException when file operations fail\n     * @deprecated This method is now deprecated.\n     * Use {@link #generateBalSource(GeneratorConstants.GenType, String, String, String) generate}\n     * and implement a file write functionality your self, if you need to customize file writing steps.\n     * Otherwise use {@link #generate(GeneratorConstants.GenType, String, String, String, String, String) generate}\n     * to directly write generated source to a ballerina module.\n     */\n    @Deprecated\n    public void writeBallerina(Object object, String templateDir, String templateName, String outPath)\n            throws IOException {\n        PrintWriter writer = null;\n\n        try {\n            Template template = compileTemplate(templateDir, templateName);\n            Context context = Context.newBuilder(object).resolver(\n                    MapValueResolver.INSTANCE,\n                    JavaBeanValueResolver.INSTANCE,\n                    FieldValueResolver.INSTANCE).build();\n            writer = new PrintWriter(outPath, \"UTF-8\");\n            writer.println(template.apply(context));\n        } finally {\n            if (writer != null) {\n                writer.close();\n            }\n        }\n    }\n\n    private Template compileTemplate(String defaultTemplateDir, String templateName) throws IOException {\n        defaultTemplateDir = defaultTemplateDir.replaceAll(\"\\\\\\\\\", \"/\");\n        String templatesDirPath = System.getProperty(GeneratorConstants.TEMPLATES_DIR_PATH_KEY, defaultTemplateDir);\n        ClassPathTemplateLoader cpTemplateLoader = new ClassPathTemplateLoader((templatesDirPath));\n        FileTemplateLoader fileTemplateLoader = new FileTemplateLoader(templatesDirPath);\n        cpTemplateLoader.setSuffix(GeneratorConstants.TEMPLATES_SUFFIX);\n        fileTemplateLoader.setSuffix(GeneratorConstants.TEMPLATES_SUFFIX);\n\n        Handlebars handlebars = new Handlebars().with(cpTemplateLoader, fileTemplateLoader);\n        handlebars.setInfiniteLoops(true); //This will allow templates to call themselves with recursion.\n        handlebars.registerHelpers(StringHelpers.class);\n        handlebars.registerHelper(\"equals\", (object, options) -> {\n            CharSequence result;\n            Object param0 = options.param(0);\n\n            if (param0 == null) {\n                throw new IllegalArgumentException(\"found 'null', expected 'string'\");\n            }\n            if (object != null) {\n                if (object.toString().equals(param0.toString())) {\n                    result = options.fn(options.context);\n                } else {\n                    result = options.inverse();\n                }\n            } else {\n                result = null;\n            }\n\n            return result;\n        });\n\n        return handlebars.compile(templateName);\n    }\n\n    private void writeGeneratedSources(List<GenSrcFile> sources, Path srcPath, Path implPath, GenType type)\n            throws IOException {\n        // Remove old generated files - if any - before regenerate\n        // if srcPackage was not provided and source was written to main package nothing will be deleted.\n        if (srcPackage != null && !srcPackage.isEmpty() && Files.exists(srcPath)) {\n            final File[] listFiles = new File(String.valueOf(srcPath)).listFiles();\n            if (listFiles != null) {\n                Arrays.stream(listFiles).forEach(file -> {\n                    boolean deleteStatus = true;\n                    if (!file.isDirectory() && !file.getName().equals(MODULE_MD)) {\n                        deleteStatus = file.delete();\n                    }\n\n                    //Capture return value of file.delete() since if\n                    //unable to delete returns false from file.delete() without an exception.\n                    if (!deleteStatus) {\n                        outStream.println(\"Unable to clean module directory.\");\n                    }\n                });\n            }\n\n        }\n\n        for (GenSrcFile file : sources) {\n            Path filePath;\n\n            // We only overwrite files of overwritable type.\n            // So non overwritable files will be written to disk only once.\n            if (!file.getType().isOverwritable()) {\n                filePath = implPath.resolve(file.getFileName());\n                if (Files.notExists(filePath)) {\n                    CodegenUtils.writeFile(filePath, file.getContent());\n                }\n            } else {\n                filePath = srcPath.resolve(file.getFileName());\n                CodegenUtils.writeFile(filePath, file.getContent());\n            }\n        }\n\n        //This will print the generated files to the console\n        if (type.equals(GenType.GEN_SERVICE)) {\n            outStream.println(\"Service generated successfully and the OpenApi contract is copied to \" + srcPackage\n                    + \"/resources. this location will be referenced throughout the ballerina project.\");\n        } else if (type.equals(GEN_CLIENT)) {\n            outStream.println(\"Client generated successfully.\");\n        }\n        outStream.println(\"Following files were created. \\n\" +\n                \"src/ \\n- \" + srcPackage);\n        Iterator<GenSrcFile> iterator = sources.iterator();\n        while (iterator.hasNext()) {\n            outStream.println(\"-- \" + iterator.next().getFileName());\n        }\n    }\n\n    /**\n     * Generate code for ballerina client.\n     *\n     * @param context model context to be used by the templates\n     * @return generated source files as a list of {@link GenSrcFile}\n     * @throws IOException when code generation with specified templates fails\n     */\n    private List<GenSrcFile> generateClient(BallerinaOpenApi context) throws IOException {\n        if (srcPackage == null || srcPackage.isEmpty()) {\n            srcPackage = GeneratorConstants.DEFAULT_CLIENT_PKG;\n        }\n\n        List<GenSrcFile> sourceFiles = new ArrayList<>();\n        String srcFile = context.getInfo().getTitle().toLowerCase(Locale.ENGLISH)\n                .replaceAll(\" \", \"_\") + \".bal\";\n\n        // Generate ballerina service and resources.\n        String mainContent = getContent(context, GeneratorConstants.DEFAULT_CLIENT_DIR,\n                GeneratorConstants.CLIENT_TEMPLATE_NAME);\n        sourceFiles.add(new GenSrcFile(GenFileType.GEN_SRC, srcPackage, srcFile, mainContent));\n\n        // Generate ballerina records to represent schemas.\n        String schemaContent = getContent(context, GeneratorConstants.DEFAULT_MODEL_DIR,\n                GeneratorConstants.SCHEMA_TEMPLATE_NAME);\n        sourceFiles.add(new GenSrcFile(GenFileType.MODEL_SRC, srcPackage, GeneratorConstants.SCHEMA_FILE_NAME,\n                schemaContent));\n\n        return sourceFiles;\n    }\n\n    private List<GenSrcFile> generateBallerinaService(BallerinaOpenApiType api) throws IOException {\n        if (srcPackage == null || srcPackage.isEmpty()) {\n            srcPackage = GeneratorConstants.DEFAULT_MOCK_PKG;\n        }\n\n        List<GenSrcFile> sourceFiles = new ArrayList<>();\n        String concatTitle = api.getBalServiceName().toLowerCase(Locale.ENGLISH).replaceAll(\" \", \"_\");\n        String srcFile = concatTitle + \".bal\";\n\n        String mainContent = getContent(api, GeneratorConstants.DEFAULT_TEMPLATE_DIR + \"/service\",\n                \"balService\");\n        sourceFiles.add(new GenSrcFile(GenFileType.GEN_SRC, srcPackage, srcFile, mainContent));\n\n        String schemaContent = getContent(api, GeneratorConstants.DEFAULT_TEMPLATE_DIR + \"/service\",\n                \"schemaList\");\n        sourceFiles.add(new GenSrcFile(GenFileType.GEN_SRC, srcPackage, GeneratorConstants.SCHEMA_FILE_NAME,\n                schemaContent));\n\n        return sourceFiles;\n    }\n\n    /**\n     * Retrieve generated source content as a String value.\n     *\n     * @param object       context to be used by template engine\n     * @param templateDir  templates directory\n     * @param templateName name of the template to be used for this code generation\n     * @return String with populated template\n     * @throws IOException when template population fails\n     */\n    private String getContent(BallerinaOpenApiType object, String templateDir, String templateName) throws IOException {\n        Template template = compileTemplate(templateDir, templateName);\n        Context context = Context.newBuilder(object)\n                .resolver(MapValueResolver.INSTANCE, JavaBeanValueResolver.INSTANCE, FieldValueResolver.INSTANCE)\n                .build();\n        return template.apply(context);\n    }\n\n    /**\n     * Retrieve generated source content as a String value.\n     *\n     * @param object       context to be used by template engine\n     * @param templateDir  templates directory\n     * @param templateName name of the template to be used for this code generation\n     * @return String with populated template\n     * @throws IOException when template population fails\n     */\n    private String getContent(BallerinaOpenApi object, String templateDir, String templateName) throws IOException {\n        Template template = compileTemplate(templateDir, templateName);\n        Context context = Context.newBuilder(object)\n                .resolver(MapValueResolver.INSTANCE, JavaBeanValueResolver.INSTANCE, FieldValueResolver.INSTANCE)\n                .build();\n        return template.apply(context);\n    }\n\n    public String getSrcPackage() {\n        return srcPackage;\n    }\n\n    public void setSrcPackage(String srcPackage) {\n        this.srcPackage = srcPackage;\n    }\n\n    public String getModelPackage() {\n        return modelPackage;\n    }\n\n    public void setModelPackage(String modelPackage) {\n        this.modelPackage = modelPackage;\n    }\n}\n", "/*\n * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n *\n * WSO2 Inc. licenses this file to you under the Apache License,\n * Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.ballerinalang.test.packaging;\n\nimport org.awaitility.Duration;\nimport org.ballerinalang.cli.module.util.Utils;\nimport org.ballerinalang.jvm.JSONParser;\nimport org.ballerinalang.jvm.values.MapValue;\nimport org.ballerinalang.test.BaseTest;\nimport org.ballerinalang.test.context.BMainInstance;\nimport org.ballerinalang.test.context.BallerinaTestException;\nimport org.ballerinalang.test.context.LogLeecher;\nimport org.ballerinalang.test.context.LogLeecher.LeecherType;\nimport org.testng.Assert;\nimport org.testng.annotations.AfterClass;\nimport org.testng.annotations.BeforeClass;\nimport org.testng.annotations.Test;\nimport org.wso2.ballerinalang.compiler.util.ProjectDirConstants;\nimport org.wso2.ballerinalang.programfile.ProgramFileConstants;\nimport org.wso2.ballerinalang.util.RepoUtils;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Map;\n\nimport javax.net.ssl.HttpsURLConnection;\n\nimport static java.util.concurrent.TimeUnit.SECONDS;\nimport static org.awaitility.Awaitility.given;\nimport static org.ballerinalang.cli.module.util.Utils.convertToUrl;\nimport static org.ballerinalang.cli.module.util.Utils.createHttpsUrlConnection;\nimport static org.ballerinalang.cli.module.util.Utils.setRequestMethod;\nimport static org.ballerinalang.test.packaging.ModulePushTestCase.REPO_TO_CENTRAL_SUCCESS_MSG;\nimport static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.BLANG_COMPILED_PKG_BINARY_EXT;\nimport static org.wso2.ballerinalang.util.RepoUtils.BALLERINA_STAGE_CENTRAL;\n\n/**\n * Testing pushing, pulling, searching a package from central and installing package to home repository.\n *\n * @since 0.981.0\n */\npublic class PackagingTestCase extends BaseTest {\n    private Path tempHomeDirectory;\n    private Path tempProjectDirectory;\n    private String moduleName = \"test\";\n    private String datePushed;\n    private String orgName = \"bcintegrationtest\";\n    private Map<String, String> envVariables;\n    private BMainInstance balClient;\n    private int totalPullCount = 0;\n    \n    @BeforeClass()\n    public void setUp() throws IOException, BallerinaTestException {\n        tempHomeDirectory = Files.createTempDirectory(\"bal-test-integration-packaging-home-\");\n        tempProjectDirectory = Files.createTempDirectory(\"bal-test-integration-packaging-project-\");\n        moduleName = moduleName + PackerinaTestUtils.randomModuleName(10);\n        PackerinaTestUtils.createSettingToml(tempHomeDirectory);\n        envVariables = addEnvVariables(PackerinaTestUtils.getEnvVariables());\n        balClient = new BMainInstance(balServer);\n    }\n\n    @Test(description = \"Test create a ballerina project and module to be pushed to central\")\n    public void testCreateProject() throws Exception {\n        Path projectPath = tempProjectDirectory.resolve(\"initProject\");\n\n        // Create project\n        balClient.runMain(\"new\", new String[]{\"initProject\"}, envVariables, new String[]{}, new LogLeecher[]{},\n                projectPath.getParent().toString());\n    \n        // Update org name\n        PackerinaTestUtils.updateManifestOrgName(projectPath, orgName);\n        \n        Assert.assertTrue(Files.exists(projectPath));\n        Assert.assertTrue(Files.isDirectory(projectPath));\n    \n        // Create module\n        balClient.runMain(\"add\", new String[]{moduleName}, envVariables, new String[]{}, new LogLeecher[]{},\n                projectPath.toString());\n    \n        Assert.assertTrue(Files.exists(projectPath.resolve(\"src\").resolve(moduleName)));\n        Assert.assertTrue(Files.isDirectory(projectPath.resolve(\"src\").resolve(moduleName)));\n    }\n\n    @Test(description = \"Test pushing a package to central\", dependsOnMethods = \"testCreateProject\")\n    public void testPush() throws Exception {\n        Path projectPath = tempProjectDirectory.resolve(\"initProject\");\n\n        // Get date and time of the module pushed.\n        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyy-MM-dd-EE\");\n        datePushed = dtf.format(LocalDateTime.now());\n\n        // First try to push without building\n        String firstMsg = \"error: cannot find balo file for the module: \" + moduleName + \". Run \" +\n                          \"'ballerina build -c <module_name>' to compile and generate the balo.\";\n        LogLeecher clientLeecher = new LogLeecher(firstMsg, LeecherType.ERROR);\n        balClient.runMain(\"push\", new String[]{moduleName}, envVariables, new String[]{},\n                          new LogLeecher[]{clientLeecher}, projectPath.toString());\n        clientLeecher.waitForText(2000);\n        \n        String baloFileName = moduleName + \"-\"\n                              + ProgramFileConstants.IMPLEMENTATION_VERSION + \"-\"\n                              + ProgramFileConstants.ANY_PLATFORM + \"-\"\n                              + \"0.1.0\"\n                              + BLANG_COMPILED_PKG_BINARY_EXT;\n        Path baloPath = projectPath.resolve(\"target\").resolve(\"balo\").resolve(baloFileName);\n        Assert.assertTrue(Files.notExists(baloPath));\n\n        // Build module\n        String buildMessage = \"Created target\" + File.separator + \"balo\" + File.separator + baloFileName;\n        clientLeecher = new LogLeecher(buildMessage);\n        balClient.runMain(\"build\", new String[]{\"-c\", moduleName}, envVariables, new String[]{},\n                new LogLeecher[]{clientLeecher}, projectPath.toString());\n        \n        // Then try to push without the flag so it builds the artifact\n        String secondMsg = orgName + \"/\" + moduleName + \":0.1.0\" + REPO_TO_CENTRAL_SUCCESS_MSG;\n        clientLeecher = new LogLeecher(secondMsg, LeecherType.INFO);\n        balClient.runMain(\"push\", new String[]{moduleName}, envVariables, new String[]{},\n                          new LogLeecher[]{clientLeecher}, projectPath.toString());\n        clientLeecher.waitForText(60000);\n    }\n\n    @Test(description = \"Test pulling a package from central\", dependsOnMethods = \"testPush\")\n    public void testPull() {\n        String baloFileName = moduleName + \"-\"\n                              + ProgramFileConstants.IMPLEMENTATION_VERSION + \"-\"\n                              + ProgramFileConstants.ANY_PLATFORM + \"-\"\n                              + \"0.1.0\"\n                              + BLANG_COMPILED_PKG_BINARY_EXT;\n        Path baloPath = Paths.get(ProjectDirConstants.BALO_CACHE_DIR_NAME,\n                                 orgName, moduleName, \"0.1.0\");\n\n        given().with().pollInterval(Duration.TEN_SECONDS).and()\n               .with().pollDelay(Duration.FIVE_SECONDS)\n               .await().atMost(90, SECONDS).until(() -> {\n            String[] clientArgs = {orgName + \"/\" + moduleName + \":0.1.0\"};\n            balClient.runMain(\"pull\", clientArgs, envVariables, new String[]{},\n                    new LogLeecher[]{}, balServer.getServerHome());\n            totalPullCount += 1;\n            return Files.exists(tempHomeDirectory.resolve(baloPath).resolve(baloFileName));\n        });\n\n        Assert.assertTrue(Files.exists(tempHomeDirectory.resolve(baloPath).resolve(baloFileName)));\n    }\n\n    @Test(description = \"Test searching a package from central\", dependsOnMethods = \"testPush\")\n    public void testSearch() throws BallerinaTestException {\n        String actualMsg = balClient.runMainAndReadStdOut(\"search\", new String[]{moduleName}, envVariables,\n                balServer.getServerHome(), false);\n\n        // Check if the search results contains the following.\n        Assert.assertTrue(actualMsg.contains(\"Ballerina Central\"));\n        Assert.assertTrue(actualMsg.contains(\"NAME\"));\n        Assert.assertTrue(actualMsg.contains(\"DESCRIPTION\"));\n        Assert.assertTrue(actualMsg.contains(\"DATE\"));\n        Assert.assertTrue(actualMsg.contains(\"VERSION\"));\n        Assert.assertTrue(actualMsg.contains(datePushed));\n        Assert.assertTrue(actualMsg.contains(\"0.1.0\"));\n    }\n\n    @Test(description = \"Test pullCount of a package from central\", dependsOnMethods = \"testPull\", enabled = false)\n    public void testPullCount() throws IOException {\n        String url = RepoUtils.getRemoteRepoURL() + \"/modules/info/\" + orgName + \"/\" + moduleName + \"/*/\";\n        HttpsURLConnection conn = createHttpsUrlConnection(convertToUrl(url), \"\", 0, \"\", \"\");\n        conn.setInstanceFollowRedirects(false);\n        setRequestMethod(conn, Utils.RequestMethod.GET);\n\n        int statusCode = conn.getResponseCode();\n        if (statusCode == 200) {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(),\n                    Charset.defaultCharset()))) {\n                StringBuilder result = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    result.append(line);\n                }\n                Object payload = JSONParser.parse(result.toString());\n                if (payload instanceof MapValue) {\n                    long pullCount = ((MapValue) payload).getIntValue(\"totalPullCount\");\n                    Assert.assertEquals(pullCount, totalPullCount);\n                } else {\n                    Assert.fail(\"error: invalid response received\");\n                }\n            }\n        } else {\n            Assert.fail(\"error: could not connect to remote repository to find the latest version of module\");\n        }\n    }\n\n    @Test(description = \"Test push all packages in project to central\", enabled = false)\n    public void testPushAllPackages() throws Exception {\n        // Test ballerina init\n        Path projectPath = tempProjectDirectory.resolve(\"pushAllPackageTest\");\n        \n        // Create project\n        balClient.runMain(\"new\", new String[]{\"pushAllPackageTest\"}, envVariables, new String[]{}, new LogLeecher[]{},\n                projectPath.getParent().toString());\n    \n        Assert.assertTrue(Files.exists(projectPath));\n        Assert.assertTrue(Files.isDirectory(projectPath));\n        \n        String firstPackage = \"firstTestPkg\" + PackerinaTestUtils.randomModuleName(10);\n        String secondPackage = \"secondTestPkg\" + PackerinaTestUtils.randomModuleName(10);\n        \n        // update org name\n        PackerinaTestUtils.updateManifestOrgName(projectPath, orgName);\n        \n        // Create first module\n        balClient.runMain(\"add\", new String[]{firstPackage}, envVariables, new String[]{}, new LogLeecher[]{},\n                projectPath.toString());\n    \n        Assert.assertTrue(Files.exists(projectPath.resolve(\"src\").resolve(firstPackage)));\n        Assert.assertTrue(Files.isDirectory(projectPath.resolve(\"src\").resolve(firstPackage)));\n    \n        // Create second module\n        balClient.runMain(\"add\", new String[]{secondPackage}, envVariables, new String[]{}, new LogLeecher[]{},\n                projectPath.toString());\n    \n        Assert.assertTrue(Files.exists(projectPath.resolve(\"src\").resolve(secondPackage)));\n        Assert.assertTrue(Files.isDirectory(projectPath.resolve(\"src\").resolve(secondPackage)));\n    \n        // Build module\n        balClient.runMain(\"build\", new String[]{\"-c\", \"-a\"}, envVariables, new String[]{},\n                new LogLeecher[]{}, projectPath.toString());\n        \n        LogLeecher clientLeecherOne = new LogLeecher(orgName + \"/\" + firstPackage + \":0.1.0\"\n                + REPO_TO_CENTRAL_SUCCESS_MSG);\n        LogLeecher clientLeecherTwo = new LogLeecher(orgName + \"/\" + secondPackage + \":0.1.0\"\n                + REPO_TO_CENTRAL_SUCCESS_MSG);\n        balClient.runMain(\"push\", new String[]{\"-a\"}, envVariables, new String[]{},\n                new LogLeecher[]{clientLeecherOne, clientLeecherTwo}, projectPath.toString());\n        clientLeecherOne.waitForText(60000);\n        clientLeecherTwo.waitForText(60000);\n    }\n\n    @Test(description = \"Test ballerina version\")\n    public void testBallerinaVersion() throws Exception {\n        LogLeecher clientLeecher = new LogLeecher(RepoUtils.getBallerinaVersion());\n        balClient.runMain(\"version\", new String[0], envVariables, new String[]{},\n                new LogLeecher[]{clientLeecher}, tempProjectDirectory.toString());\n    }\n\n    @Test(description = \"Test and run a module which has a module name contains period. eg: foo.bar\")\n    public void testBuildAndRunModuleWithPeriod() throws BallerinaTestException {\n        // Test ballerina init\n        Path projectPath = tempProjectDirectory.resolve(\"buildAndRunModuleWithPeriodProject\");\n\n        // Create project\n        balClient.runMain(\"new\", new String[] { \"buildAndRunModuleWithPeriodProject\" }, envVariables, new String[] {},\n                new LogLeecher[] {}, projectPath.getParent().toString());\n\n        Assert.assertTrue(Files.exists(projectPath));\n        Assert.assertTrue(Files.isDirectory(projectPath));\n\n        // Create module named `foo.bar`\n        String moduleName = \"foo.bar\";\n        balClient.runMain(\"add\", new String[] { moduleName }, envVariables, new String[] {}, new LogLeecher[] {},\n                projectPath.toString());\n\n        Assert.assertTrue(Files.exists(projectPath.resolve(\"src\").resolve(moduleName)));\n        Assert.assertTrue(Files.isDirectory(projectPath.resolve(\"src\").resolve(moduleName)));\n\n        // Build module\n        LogLeecher buildLeecher = new LogLeecher(\"[pass] testFunction\");\n        balClient.runMain(\"build\", new String[] { \"-c\", \"-a\" }, envVariables, new String[] {},\n                new LogLeecher[] { buildLeecher }, projectPath.toString());\n        buildLeecher.waitForText(60000);\n\n        // Run module\n        LogLeecher runLeecher = new LogLeecher(\"Hello World!\");\n        balClient.runMain(\"run\", new String[] { moduleName }, envVariables, new String[] {},\n                new LogLeecher[] { runLeecher }, projectPath.toString());\n        buildLeecher.waitForText(5000);\n    }\n\n    /**\n     * Get environment variables and add ballerina_home as a env variable the tmp directory.\n     *\n     * @return env directory variable array\n     */\n    private Map<String, String> addEnvVariables(Map<String, String> envVariables) {\n        envVariables.put(ProjectDirConstants.HOME_REPO_ENV_KEY, tempHomeDirectory.toString());\n        envVariables.put(BALLERINA_STAGE_CENTRAL, \"true\");\n        return envVariables;\n    }\n\n    @AfterClass\n    private void cleanup() throws Exception {\n        PackerinaTestUtils.deleteFiles(tempHomeDirectory);\n        PackerinaTestUtils.deleteFiles(tempProjectDirectory);\n    }\n}\n"], "filenames": ["cli/ballerina-cli-module/src/main/java/org/ballerinalang/cli/module/Pull.java", "cli/ballerina-cli-module/src/main/java/org/ballerinalang/cli/module/Push.java", "cli/ballerina-cli-module/src/main/java/org/ballerinalang/cli/module/Search.java", "cli/ballerina-cli-module/src/main/java/org/ballerinalang/cli/module/TokenUpdater.java", "cli/ballerina-cli-module/src/main/java/org/ballerinalang/cli/module/util/Utils.java", "cli/ballerina-cli-module/src/test/java/org/ballerinalang/cli/module/UtilsTest.java", "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/packaging/converters/URIDryConverter.java", "misc/openapi-ballerina/modules/openapi-to-ballerina-generator/src/main/java/org/ballerinalang/openapi/CodeGenerator.java", "tests/jballerina-integration-test/src/test/java/org/ballerinalang/test/packaging/PackagingTestCase.java"], "buggy_code_start_loc": [33, 33, 30, 29, 21, 25, 34, 125, 41], "buggy_code_end_loc": [276, 133, 88, 109, 175, 67, 110, 132, 188], "fixing_code_start_loc": [32, 32, 29, 28, 20, 24, 33, 124, 40], "fixing_code_end_loc": [274, 131, 87, 109, 140, 68, 83, 133, 187], "type": "CWE-306", "message": "Ballerina is an open source programming language and platform for cloud application programmers. Ballerina versions 1.2.x and SL releases up to alpha 3 have a potential for a supply chain attack via MiTM against users. Http connections did not make use of TLS and certificate checking was ignored. The vulnerability allows an attacker to substitute or modify packages retrieved from BC thus allowing to inject malicious code into ballerina executables. This has been patched in Ballerina 1.2.14 and Ballerina SwanLake alpha4.", "other": {"cve": {"id": "CVE-2021-32700", "sourceIdentifier": "security-advisories@github.com", "published": "2021-06-22T20:15:08.637", "lastModified": "2021-06-29T18:56:14.373", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Ballerina is an open source programming language and platform for cloud application programmers. Ballerina versions 1.2.x and SL releases up to alpha 3 have a potential for a supply chain attack via MiTM against users. Http connections did not make use of TLS and certificate checking was ignored. The vulnerability allows an attacker to substitute or modify packages retrieved from BC thus allowing to inject malicious code into ballerina executables. This has been patched in Ballerina 1.2.14 and Ballerina SwanLake alpha4."}, {"lang": "es", "value": "Ballerina es un lenguaje de programaci\u00f3n de c\u00f3digo abierto y una plataforma para programadores de aplicaciones en la nube. Ballerina versiones 1.2.x y SL hasta la alfa 3 tienen un potencial para un ataque a la cadena de suministro  por medio de MiTM contra los usuarios. Las conexiones Http no hac\u00edan uso de TLS y se ignoraba la comprobaci\u00f3n de certificados. La vulnerabilidad permite a un atacante sustituir o modificar los paquetes recuperados de BC permitiendo as\u00ed inyectar c\u00f3digo malicioso en los ejecutables de Ballerina. Esto ha sido parcheado en Ballerina versi\u00f3n 1.2.14 y Ballerina versi\u00f3n SwanLake alpha4"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-306"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ballerina:ballerina:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.14", "matchCriteriaId": "11BA594E-F609-41A8-95DE-BD85C64974B6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ballerina:swan_lake:alpha1:*:*:*:*:*:*:*", "matchCriteriaId": "10FD03E6-19DB-4FCA-A83B-C7302A2715C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ballerina:swan_lake:alpha2:*:*:*:*:*:*:*", "matchCriteriaId": "86E59979-D90D-4451-9420-344C71492504"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ballerina:swan_lake:alpha3:*:*:*:*:*:*:*", "matchCriteriaId": "FE0D267F-0506-44A6-A44E-7E4841293459"}]}]}], "references": [{"url": "https://github.com/ballerina-platform/ballerina-lang/commit/4609ffee1744ecd16aac09303b1783bf0a525816", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ballerina-platform/ballerina-lang/security/advisories/GHSA-f5qg-fqrw-v5ww", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ballerina-platform/ballerina-lang/commit/4609ffee1744ecd16aac09303b1783bf0a525816"}}