{"buggy_code": ["# frozen_string_literal: true\n\n# TODO: This code here doesn't make a lot of sense as a Concern since no other model would\n#       ever use the functionality. It would be better to make it a Service.\n\n# rubocop:disable Metrics/ModuleLength\nmodule ExportablePlan\n\n  include ConditionsHelper\n\n  def as_pdf(user, coversheet = false)\n    prepare(user, coversheet)\n  end\n\n  # rubocop:disable Metrics/AbcSize, Metrics/ParameterLists\n  def as_csv(user,\n             headings = true,\n             unanswered = true,\n             selected_phase = nil,\n             show_custom_sections = true,\n             show_coversheet = false)\n    hash = prepare(user, show_coversheet)\n    CSV.generate do |csv|\n      prepare_coversheet_for_csv(csv, headings, hash) if show_coversheet\n\n      hdrs = (hash[:phases].many? ? [_(\"Phase\")] : [])\n      hdrs << if headings\n                [_(\"Section\"), _(\"Question\"), _(\"Answer\")]\n              else\n                [_(\"Answer\")]\n              end\n\n      customization = hash[:customization]\n\n      csv << hdrs.flatten\n      hash[:phases].each do |phase|\n        next unless selected_phase.nil? || phase[:title] == selected_phase.title\n\n        phase[:sections].each do |section|\n          show_section = !customization\n          show_section ||= customization && !section[:modifiable]\n          show_section ||= customization && section[:modifiable] && show_custom_sections\n\n          if show_section && num_section_questions(self, section, phase).positive?\n            show_section_for_csv(csv, phase, section, headings, unanswered, hash)\n          end\n        end\n      end\n    end\n  end\n  # rubocop:enable Metrics/AbcSize, Metrics/ParameterLists\n\n  private\n\n  # rubocop:disable Metrics/MethodLength, Metrics/AbcSize\n  def prepare(user, coversheet = false)\n    hash = coversheet ? prepare_coversheet : {}\n    template = Template.includes(phases: { sections: { questions: :question_format } })\n                       .joins(phases: { sections: { questions: :question_format } })\n                       .where(id: template_id)\n                       .order(\"sections.number\", \"questions.number\").first\n    hash[:customization] = template.customization_of.present?\n    hash[:title] = title\n    hash[:answers] = answers\n\n    # add the relevant questions/answers\n    phases = []\n    template.phases.each do |phase|\n      phs = { title: phase.title, number: phase.number, sections: [] }\n      phase.sections.each do |section|\n        sctn = { title: section.title,\n                 number: section.number,\n                 questions: [],\n                 modifiable: section.modifiable }\n        section.questions.each do |question|\n          txt = question.text\n          sctn[:questions] << {\n            id: question.id,\n            text: txt,\n            format: question.question_format\n          }\n        end\n        phs[:sections] << sctn\n      end\n      phases << phs\n    end\n    hash[:phases] = phases\n\n    record_plan_export(user, :pdf)\n\n    hash\n  end\n  # rubocop:enable Metrics/MethodLength, Metrics/AbcSize\n\n  # rubocop:disable Metrics/AbcSize\n  def prepare_coversheet\n    hash = {}\n    # name of owner and any co-owners\n    attribution = owner.present? ? [owner.name(false)] : []\n    roles.administrator.not_creator.each do |role|\n      attribution << role.user.name(false)\n    end\n    hash[:attribution] = attribution\n\n    # Org name of plan owner's org\n    hash[:affiliation] = owner.present? ? owner.org.name : \"\"\n\n    # set the funder name\n    hash[:funder] = funder.name if funder.present?\n    template_org = template.org\n    hash[:funder] = template_org.name if !hash[:funder].present? && template_org.funder?\n\n    # set the template name and customizer name if applicable\n    hash[:template] = template.title\n    customizer = \"\"\n    cust_questions = questions.where(modifiable: true).pluck(:id)\n    # if the template is customized, and has custom answered questions\n    if template.customization_of.present? &&\n       Answer.where(plan_id: id, question_id: cust_questions).present?\n      customizer = _(\" Customised By: \") + template.org.name\n    end\n    hash[:customizer] = customizer\n    hash\n  end\n  # rubocop:enable Metrics/AbcSize\n  # rubocop:enable\n\n  # rubocop:disable Metrics/MethodLength, Metrics/AbcSize\n  def prepare_coversheet_for_csv(csv, _headings, hash)\n    csv << [if hash[:attribution].many?\n              _(\"Creators: \")\n            else\n              _(\"Creator:\")\n            end, _(\"%{authors}\") % { authors: hash[:attribution].join(\", \") }]\n    csv << [\"Affiliation: \", _(\"%{affiliation}\") % { affiliation: hash[:affiliation] }]\n    csv << if hash[:funder].present?\n             [_(\"Template: \"), _(\"%{funder}\") % { funder: hash[:funder] }]\n           else\n             [_(\"Template: \"), _(\"%{template}\") % { template: hash[:template] + hash[:customizer] }]\n           end\n    if grant_number.present?\n      csv << [_(\"Grant number: \"), _(\"%{grant_number}\") % { grant_number: grant_number }]\n    end\n    if description.present?\n      csv << [_(\"Project abstract: \"), _(\"%{description}\") %\n                                       { description: Nokogiri::HTML(description).text }]\n    end\n    csv << [_(\"Last modified: \"), _(\"%{date}\") % { date: updated_at.to_date.strftime(\"%d-%m-%Y\") }]\n    csv << [_(\"Copyright information:\"),\n            _(\"The above plan creator(s) have agreed that others may use as\n             much of the text of this plan as they would like in their own plans,\n             and customise it as necessary. You do not need to credit the creator(s)\n             as the source of the language used, but using any of the plan's text\n             does not imply that the creator(s) endorse, or have any relationship to,\n             your project or proposal\")]\n    csv << []\n    csv << []\n  end\n  # rubocop:enable Metrics/MethodLength, Metrics/AbcSize\n\n  # rubocop:disable Metrics/AbcSize, Metrics/BlockLength, Metrics/MethodLength\n  # rubocop:disable Metrics/ParameterLists\n  def show_section_for_csv(csv, phase, section, headings, unanswered, hash)\n    section[:questions].each do |question|\n      next if remove_list(hash).include?(question[:id])\n\n      answer = self.answer(question[:id], false)\n      answer_text = \"\"\n      if answer.present?\n        if answer.question_options.any?\n          answer_text += answer.question_options.pluck(:text).join(\", \")\n        end\n        answer_text += answer.text if answer.answered?\n      elsif unanswered\n        answer_text += _(\"Not Answered\")\n      end\n      single_line_answer_for_csv = sanitize_text(answer_text).gsub(/\\r|\\n/, \" \")\n      flds = (hash[:phases].many? ? [phase[:title]] : [])\n      if headings\n        question_text = if question[:text].is_a? String\n                          question[:text]\n                        else\n                          (if question[:text].many?\n                             question[:text].join(\", \")\n                           else\n                             question[:text][0]\n                           end)\n                        end\n        flds << [section[:title], sanitize_text(question_text),\n                 single_line_answer_for_csv]\n      else\n        flds << [single_line_answer_for_csv]\n      end\n      csv << flds.flatten\n    end\n  end\n  # rubocop:enable Metrics/AbcSize, Metrics/BlockLength, Metrics/MethodLength\n  # rubocop:enable\n  # rubocop:enable Metrics/ParameterLists\n\n  def record_plan_export(user, format)\n    # TODO: Re-evaluate how/why we are doing this. The only place it is used is in statistics\n    #       generation as 'downloads' without any regard for the format (although we only call this\n    #       here when a PDF is generated). It would be more efficient to probably just have a\n    #       counter on the plans table itself. (e.g. plans.nbr_downloads)\n    #       This would require a fair bit of work though, as the column would need to be added,\n    #       the ExportedPlan model/table removed, statistics generation Rake task updated\n    exported_plan = ExportedPlan.new.tap do |ep|\n      ep.user_id = user&.id\n      ep.plan = self\n      ep.phase_id = phases.first.id\n      ep.format = format\n      plan_settings = settings(:export)\n\n      Settings::Template::DEFAULT_SETTINGS.each do |key, _value|\n        ep.settings(:export).send(\"#{key}=\", plan_settings.send(key))\n      end\n    end\n    exported_plan.save\n  end\n\n  def sanitize_text(text)\n    ActionView::Base.full_sanitizer.sanitize(text.to_s.gsub(/&nbsp;/i, \"\"))\n  end\n\nend\n# rubocop:enable Metrics/ModuleLength\n", "# frozen_string_literal: true\n\n# == Schema Information\n#\n# Table name: exported_plans\n#\n#  id         :integer          not null, primary key\n#  format     :string\n#  created_at :datetime         not null\n#  updated_at :datetime         not null\n#  phase_id   :integer\n#  plan_id    :integer\n#  user_id    :integer\n#\nclass ExportedPlan < ApplicationRecord\n\n  include SettingsTemplateHelper\n\n  # associations between tables\n  belongs_to :plan\n  belongs_to :user, optional: true\n\n  validates :plan, presence: { message: PRESENCE_MESSAGE }\n\n  validates :format, presence: { message: PRESENCE_MESSAGE }\n\n  # Store settings with the exported plan so it can be recreated later\n  # if necessary (otherwise the settings associated with the plan at a\n  # given time can be lost)\n  has_settings :export, class_name: \"Settings::Template\" do |s|\n    s.key :export, defaults: Settings::Template::DEFAULT_SETTINGS\n  end\n\n  # TODO: Consider removing the accessor methods, they add no value. The view/controller could\n  #       just access the value directly from the project/plan: exported_plan.plan.project.title\n\n  # Getters to match Settings::Template::VALID_ADMIN_FIELDS\n  def project_name\n    name = plan.template.title\n    name += \" - #{plan.title}\" if plan.template.phases.count > 1\n    name\n  end\n\n  def project_identifier\n    plan.identifier\n  end\n\n  def grant_title\n    plan.grant_number\n  end\n\n  def principal_investigator\n    plan.contributors.investigation\n  end\n\n  def project_data_contact\n    plan.contributors.data_curation\n  end\n\n  def project_admins\n    plan.contributors.project_administration\n  end\n\n  def project_description\n    plan.description\n  end\n\n  def owner\n    plan.roles.to_a.select(&:creator?).first.user\n  end\n\n  def funder\n    org = plan.funder\n    org = plan.template.try(:org) unless org.present?\n    org.name if org.present? && org.funder?\n  end\n\n  def institution\n    plan.owner.org.try(:name)\n  end\n\n  def orcid\n    return \"\" unless owner.present?\n\n    ids = owner.identifiers.by_scheme_name(\"orcid\", \"User\")\n    ids.first.present? ? ids.first.value : \"\"\n  end\n\n  def sections\n    self.phase_id ||= plan.template.phases.first.id\n    Section.where({ phase_id: phase_id }).order(:number)\n  end\n\n  def questions_for_section(section_id)\n    Question.where(id: questions).where(section_id: section_id).order(:number)\n  end\n\n  def admin_details\n    @admin_details ||= settings(:export).fields[:admin]\n  end\n\n  # Retrieves the title field\n  def title\n    settings(:export).title\n  end\n\n  # Export formats\n\n  # rubocop:disable Metrics/AbcSize, Metrics/MethodLength, Metrics/BlockLength\n  def as_csv(sections, unanswered_questions, question_headings)\n    CSV.generate do |csv|\n      # rubocop:disable Style/ConditionalAssignment\n      if question_headings\n        csv << [_(\"Section\"), _(\"Question\"), _(\"Answer\"), _(\"Selected option(s)\"),\n                _(\"Answered by\"), _(\"Answered at\")]\n      else\n        csv << [_(\"Section\"), _(\"Answer\"), _(\"Selected option(s)\"), _(\"Answered by\"),\n                _(\"Answered at\")]\n      end\n      # rubocop:enable Style/ConditionalAssignment\n      sections.each do |section|\n        section.questions.each do |question|\n          answer = Answer.where(plan_id: plan_id, question_id: question.id).first\n          # skip unansewered questions\n          next if answer.blank? && !unanswered_questions\n\n          answer_text = answer.present? ? answer.text : \"\"\n          q_format = question.question_format\n          options_string = if q_format.option_based?\n                             answer.question_options.collect(&:text).join(\"; \")\n                           else\n                             \"\"\n                           end\n          csv << if question_headings\n                   [\n                     section.title,\n                     sanitize_text(question.text),\n                     question.option_comment_display ? sanitize_text(answer_text) : \"\",\n                     options_string,\n                     user.name,\n                     answer.updated_at\n                   ]\n                 else\n                   [\n                     section.title,\n                     question.option_comment_display ? sanitize_text(answer_text) : \"\",\n                     options_string,\n                     user.name,\n                     answer.updated_at\n                   ]\n                 end\n        end\n      end\n    end\n  end\n  # rubocop:enable Metrics/AbcSize, Metrics/MethodLength, Metrics/BlockLength\n  # rubocop:enable\n\n  # rubocop:disable Metrics/AbcSize, Metrics/MethodLength\n  def as_txt(sections, unanswered_questions, question_headings, details)\n    output = \"#{plan.title}\\n\\n#{plan.template.title}\\n\"\n    output += \"\\n\" + _(\"Details\") + \"\\n\\n\"\n    if details\n      admin_details.each do |at|\n        value = send(at)\n        output += if value.present?\n                    admin_field_t(at.to_s) + \": \" + value + \"\\n\"\n                  else\n                    admin_field_t(at.to_s) + \": \" + _(\"-\") + \"\\n\"\n                  end\n      end\n    end\n\n    sections.each do |section|\n      output += \"\\n#{section.title}\\n\" if question_headings\n      section.questions.each do |question|\n        answer = plan.answer(question.id, false)\n        # skip if question un-answered\n        next if answer.nil? && !unanswered_questions\n\n        if question_headings\n          qtext = sanitize_text(question.text.gsub(/<li>/, \"  * \"))\n          output += \"\\n* #{qtext}\"\n        end\n        if answer.nil?\n          output += _(\"Question not answered.\") + \"\\n\"\n        else\n          q_format = question.question_format\n          if q_format.option_based?\n            output += answer.question_options.collect(&:text).join(\"\\n\")\n            output += \"\\n#{sanitize_text(answer.text)}\\n\" if question.option_comment_display\n          else\n            output += \"\\n#{sanitize_text(answer.text)}\\n\"\n          end\n        end\n      end\n    end\n    output\n  end\n  # rubocop:enable Metrics/AbcSize, Metrics/MethodLength\n  # rubocop:enable\n\n  private\n\n  # Returns an Array of question_ids for the exported settings stored for a plan\n  def questions\n    question_settings = settings(:export).fields[:questions]\n    @questions ||= if question_settings.present?\n                     if question_settings == :all\n                       Question.where(section_id: plan.sections.collect(&:id)).pluck(:id)\n                     elsif question_settings.is_a?(Array)\n                       question_settings\n                     else\n                       []\n                     end\n                   else\n                     []\n                   end\n  end\n\n  def sanitize_text(text)\n    ActionView::Base.full_sanitizer.sanitize(text.gsub(/&nbsp;/i, \"\")) unless text.nil?\n  end\n\nend\n", "# frozen_string_literal: true\n\n# builds a json response to a successful project createtion\n\njson.prettify!\n\n# rubocop:disable Metrics/BlockLength\njson.array! @plans.each do |plan|\n  json.id             plan.id\n  json.title          plan.title\n  json.grant_number   plan.grant_number\n  json.last_updated   plan.updated_at\n  json.creation_date  plan.created_at\n  json.test_plan      plan.is_test?\n  json.template do\n    json.title        plan.template.title\n    json.id           plan.template.family_id\n  end\n  json.funder do\n    json.name(plan.template.org.funder? ? plan.template.org.name : plan.funder&.name)\n  end\n\n  investigator = plan.contributors.investigation.first\n  if investigator.present?\n    json.principal_investigator do\n      json.name         investigator.name\n      json.email        investigator.email\n      json.phone        investigator.phone\n    end\n  end\n\n  data_contact = plan.contributors.data_curation.first || plan.owner\n  if data_contact.present?\n    json.data_contact do\n      json.name   data_contact.is_a?(Contributor) ? data_contact.name : data_contact.name(false)\n      json.email  data_contact.email\n      json.phone  data_contact.phone if data_contact.is_a?(Contributor)\n    end\n  end\n\n  json.users plan.roles.each do |role|\n    json.email role.user.email\n  end\n  json.description plan.description\n  json.plan_content plan.template.phases.each do |phase|\n    json.title phase.title\n    json.description phase.description\n    json.sections phase.sections.each do |section|\n      json.title        section.title\n      json.description  section.description\n      json.number       section.number\n      json.questions section.questions.each do |question|\n        json.text       question.text\n        json.number     question.number\n        json.format     question.question_format.title\n        json.option_based question.question_format.option_based\n        json.themes question.themes.each do |theme|\n          json.theme theme.title\n        end\n        answer = plan.answers.select { |a| a.question_id == question.id }.first\n        if answer.present?\n          json.answered true\n          json.answer do\n            json.text answer.text\n            if answer.question_options.present?\n              json.options answer.question_options.each do |option|\n                json.text option.text\n              end\n            end\n          end\n        else\n          json.answered false\n        end\n      end\n    end\n  end\nend\n# rubocop:enable Metrics/BlockLength\n", "# frozen_string_literal: true\n\njson.prettify!\n\njson.plans @org_plans.each do |plan|\n  json.id             plan.id\n  json.grant_number   plan.grant_number\n  json.title          plan.title\n  json.test_plan      plan.is_test?\n\n  json.template do\n    json.title        plan.template.title\n    json.id           plan.template.family_id\n  end\n\n  json.funder do\n    json.name         plan.template.org.funder? ? plan.template.org.name : \"\"\n  end\n\n  json.principal_investigator do\n    json.name         plan.contributors.investigation.first&.name\n  end\n\n  json.data_contact do\n    json.info         plan.contributors.data_curation.first&.name\n  end\n\n  json.description    plan.description\n\n  json.date_created   plan.created_at\n  json.date_last_updated plan.updated_at\n\n  json.completion do\n    json.total_questions     plan.questions.count\n    json.answered_questions  plan.answers.count\n  end\nend\n", "<%= \"#{@plan.title}\" %>\n<%= \"----------------------------------------------------------\\n\" %>\n<% if @show_coversheet %>\n<%= @hash[:attribution].many? ? _(\"Creators: \") : _('Creator:') %> <%= @hash[:attribution].join(', ') %>\n<%= _(\"Affiliation: \") + @hash[:affiliation] %>\n  <% if @hash[:funder].present? %>\n<%= _(\"Template: \") + @hash[:funder] %>\n  <% else %>\n<%= _(\"Template: \") + @hash[:template] + @hash[:customizer] %>\n  <% end %>\n  <% if @plan.grant_number.present? %>\n<%= _(\"Grant number: \") + @plan.grant_number %>\n  <% end %>\n  <% if @plan.description.present? %>\n<%= _(\"Project abstract: \") %>\n<%= \"\\t\" + strip_tags(@plan.description) + \"\\n\" %>\n  <% end %>\n<%= _(\"Last modified: \") + l(@plan.updated_at.to_date, formats: :short) %>\n<%= _(\"Copyright information:\") %>\n<%= \"\\t\" + _(\" The above plan creator(s) have agreed that others may use as much of the text of this plan as they would like in their own plans, and customise it as necessary. You do not need to credit the creator(s) as the source of the language used, but using any of the plan's text does not imply that the creator(s) endorse, or have any relationship to, your project or proposal\") %>\n<%= \"----------------------------------------------------------\\n\" %>\n<% end %>\n\n<% @hash[:phases].each do |phase| %>\n<%# Only render selected phase %>\n<% if phase[:title] == @selected_phase.title %>\n<%= (@hash[:phases].many? ? \"#{phase[:title]}\" : \"\") %>\n  <% phase[:sections].each do |section| %>\n    <% if display_section?(@hash[:customization], section, @show_custom_sections) && num_section_questions(@plan, section, phase) > 0 %>\n      <% if @show_sections_questions %>\n        <%= \"#{section[:title]}\\n\" %>\n      <% end %>\n      <% section[:questions].each do |question| %>\n        <% if remove_list(@plan).include?(question[:id]) %> \n          <% next %>\n        <% end %>\n        <%# text in this case is an array to accomodate for option_based %>\n        <% if @show_sections_questions %>\n          <% if question[:text].respond_to?(:each) %>\n            <% question[:text].each do |txt| %>\n              <%= \"#{strip_tags(txt.gsub(/<br\\/?>/, '\\n'))}\\n\" %>\n            <% end %>\n          <% else %>\n            <%= \"#{strip_tags(question[:text].gsub(/<tr>(\\s|<td>|<\\/td>|&nbsp;)*(<\\/tr>|<tr>)/,\"\"))}\\n\" if question[:text].present? && question[:text][0].present? %>\n          <% end %>\n        <% end %>\n        <% answer = @plan.answer(question[:id], false) %>\n        <% blank = not(answer.present? && answer.answered?) %>\n        <% if blank && @show_unanswered %>\n          <%= \"    #{_(\"Question not answered.\")}\\n\\n\" %>\n        <% elsif !blank %>\n          <% if answer.question_options.length > 0 %>\n            <% answer.question_options.each do |opt| %>\n              <%= \"    #{opt.text}\\n\" %>\n            <% end %>\n          <% end %>\n          <%= \"    #{strip_tags(answer.text.gsub(/<\\/?p>/, '').gsub(/<br\\s?\\/?>/, '\\n').chomp)}\\n\\n\" if answer.text.present? %>\n          <% end %>\n        <% end %>\n      <% end %>\n    <% end %>\n  <% end %>\n<% end %>\n<%= \"----------------------------------------------------------\" %>\n<%= _(\"A Data Management Plan created using %{application_name}\") % { application_name: ApplicationService.application_name } %>\n"], "fixing_code": ["# frozen_string_literal: true\n\n# TODO: This code here doesn't make a lot of sense as a Concern since no other model would\n#       ever use the functionality. It would be better to make it a Service.\n\n# rubocop:disable Metrics/ModuleLength\nmodule ExportablePlan\n\n  include ConditionsHelper\n\n  def as_pdf(user, coversheet = false)\n    prepare(user, coversheet)\n  end\n\n  # rubocop:disable Metrics/AbcSize, Metrics/ParameterLists\n  def as_csv(user,\n             headings = true,\n             unanswered = true,\n             selected_phase = nil,\n             show_custom_sections = true,\n             show_coversheet = false)\n    hash = prepare(user, show_coversheet)\n    CSV.generate do |csv|\n      prepare_coversheet_for_csv(csv, headings, hash) if show_coversheet\n\n      hdrs = (hash[:phases].many? ? [_(\"Phase\")] : [])\n      hdrs << if headings\n                [_(\"Section\"), _(\"Question\"), _(\"Answer\")]\n              else\n                [_(\"Answer\")]\n              end\n\n      customization = hash[:customization]\n\n      csv << hdrs.flatten\n      hash[:phases].each do |phase|\n        next unless selected_phase.nil? || phase[:title] == selected_phase.title\n\n        phase[:sections].each do |section|\n          show_section = !customization\n          show_section ||= customization && !section[:modifiable]\n          show_section ||= customization && section[:modifiable] && show_custom_sections\n\n          if show_section && num_section_questions(self, section, phase).positive?\n            show_section_for_csv(csv, phase, section, headings, unanswered, hash)\n          end\n        end\n      end\n    end\n  end\n  # rubocop:enable Metrics/AbcSize, Metrics/ParameterLists\n\n  private\n\n  # rubocop:disable Metrics/MethodLength, Metrics/AbcSize\n  def prepare(user, coversheet = false)\n    hash = coversheet ? prepare_coversheet : {}\n    template = Template.includes(phases: { sections: { questions: :question_format } })\n                       .joins(phases: { sections: { questions: :question_format } })\n                       .where(id: template_id)\n                       .order(\"sections.number\", \"questions.number\").first\n    hash[:customization] = template.customization_of.present?\n    hash[:title] = title\n    hash[:answers] = answers\n\n    # add the relevant questions/answers\n    phases = []\n    template.phases.each do |phase|\n      phs = { title: phase.title, number: phase.number, sections: [] }\n      phase.sections.each do |section|\n        sctn = { title: section.title,\n                 number: section.number,\n                 questions: [],\n                 modifiable: section.modifiable }\n        section.questions.each do |question|\n          txt = question.text\n          sctn[:questions] << {\n            id: question.id,\n            text: txt,\n            format: question.question_format\n          }\n        end\n        phs[:sections] << sctn\n      end\n      phases << phs\n    end\n    hash[:phases] = phases\n\n    record_plan_export(user, :pdf)\n\n    hash\n  end\n  # rubocop:enable Metrics/MethodLength, Metrics/AbcSize\n\n  # rubocop:disable Metrics/AbcSize\n  def prepare_coversheet\n    hash = {}\n    # name of owner and any co-owners\n    attribution = owner.present? ? [owner.name(false)] : []\n    roles.administrator.not_creator.each do |role|\n      attribution << role.user.name(false)\n    end\n    hash[:attribution] = attribution\n\n    # Org name of plan owner's org\n    hash[:affiliation] = owner.present? ? owner.org.name : \"\"\n\n    # set the funder name\n    hash[:funder] = funder.name if funder.present?\n    template_org = template.org\n    hash[:funder] = template_org.name if !hash[:funder].present? && template_org.funder?\n\n    # set the template name and customizer name if applicable\n    hash[:template] = template.title\n    customizer = \"\"\n    cust_questions = questions.where(modifiable: true).pluck(:id)\n    # if the template is customized, and has custom answered questions\n    if template.customization_of.present? &&\n       Answer.where(plan_id: id, question_id: cust_questions).present?\n      customizer = _(\" Customised By: \") + template.org.name\n    end\n    hash[:customizer] = customizer\n    hash\n  end\n  # rubocop:enable Metrics/AbcSize\n  # rubocop:enable\n\n  # rubocop:disable Metrics/MethodLength, Metrics/AbcSize\n  def prepare_coversheet_for_csv(csv, _headings, hash)\n    csv << [if hash[:attribution].many?\n              _(\"Creators: \")\n            else\n              _(\"Creator:\")\n            end, _(\"%{authors}\") % { authors: hash[:attribution].join(\", \") }]\n    csv << [\"Affiliation: \", _(\"%{affiliation}\") % { affiliation: hash[:affiliation] }]\n    csv << if hash[:funder].present?\n             [_(\"Template: \"), _(\"%{funder}\") % { funder: hash[:funder] }]\n           else\n             [_(\"Template: \"), _(\"%{template}\") % { template: hash[:template] + hash[:customizer] }]\n           end\n    if grant&.value.present?\n      csv << [_(\"Grant number: \"), _(\"%{grant_number}\") % { grant_number: grant&.value }]\n    end\n    if description.present?\n      csv << [_(\"Project abstract: \"), _(\"%{description}\") %\n                                       { description: Nokogiri::HTML(description).text }]\n    end\n    csv << [_(\"Last modified: \"), _(\"%{date}\") % { date: updated_at.to_date.strftime(\"%d-%m-%Y\") }]\n    csv << [_(\"Copyright information:\"),\n            _(\"The above plan creator(s) have agreed that others may use as\n             much of the text of this plan as they would like in their own plans,\n             and customise it as necessary. You do not need to credit the creator(s)\n             as the source of the language used, but using any of the plan's text\n             does not imply that the creator(s) endorse, or have any relationship to,\n             your project or proposal\")]\n    csv << []\n    csv << []\n  end\n  # rubocop:enable Metrics/MethodLength, Metrics/AbcSize\n\n  # rubocop:disable Metrics/AbcSize, Metrics/BlockLength, Metrics/MethodLength\n  # rubocop:disable Metrics/ParameterLists\n  def show_section_for_csv(csv, phase, section, headings, unanswered, hash)\n    section[:questions].each do |question|\n      next if remove_list(hash).include?(question[:id])\n\n      answer = self.answer(question[:id], false)\n      answer_text = \"\"\n      if answer.present?\n        if answer.question_options.any?\n          answer_text += answer.question_options.pluck(:text).join(\", \")\n        end\n        answer_text += answer.text if answer.answered?\n      elsif unanswered\n        answer_text += _(\"Not Answered\")\n      end\n      single_line_answer_for_csv = sanitize_text(answer_text).gsub(/\\r|\\n/, \" \")\n      flds = (hash[:phases].many? ? [phase[:title]] : [])\n      if headings\n        question_text = if question[:text].is_a? String\n                          question[:text]\n                        else\n                          (if question[:text].many?\n                             question[:text].join(\", \")\n                           else\n                             question[:text][0]\n                           end)\n                        end\n        flds << [section[:title], sanitize_text(question_text),\n                 single_line_answer_for_csv]\n      else\n        flds << [single_line_answer_for_csv]\n      end\n      csv << flds.flatten\n    end\n  end\n  # rubocop:enable Metrics/AbcSize, Metrics/BlockLength, Metrics/MethodLength\n  # rubocop:enable\n  # rubocop:enable Metrics/ParameterLists\n\n  def record_plan_export(user, format)\n    # TODO: Re-evaluate how/why we are doing this. The only place it is used is in statistics\n    #       generation as 'downloads' without any regard for the format (although we only call this\n    #       here when a PDF is generated). It would be more efficient to probably just have a\n    #       counter on the plans table itself. (e.g. plans.nbr_downloads)\n    #       This would require a fair bit of work though, as the column would need to be added,\n    #       the ExportedPlan model/table removed, statistics generation Rake task updated\n    exported_plan = ExportedPlan.new.tap do |ep|\n      ep.user_id = user&.id\n      ep.plan = self\n      ep.phase_id = phases.first.id\n      ep.format = format\n      plan_settings = settings(:export)\n\n      Settings::Template::DEFAULT_SETTINGS.each do |key, _value|\n        ep.settings(:export).send(\"#{key}=\", plan_settings.send(key))\n      end\n    end\n    exported_plan.save\n  end\n\n  def sanitize_text(text)\n    ActionView::Base.full_sanitizer.sanitize(text.to_s.gsub(/&nbsp;/i, \"\"))\n  end\n\nend\n# rubocop:enable Metrics/ModuleLength\n", "# frozen_string_literal: true\n\n# == Schema Information\n#\n# Table name: exported_plans\n#\n#  id         :integer          not null, primary key\n#  format     :string\n#  created_at :datetime         not null\n#  updated_at :datetime         not null\n#  phase_id   :integer\n#  plan_id    :integer\n#  user_id    :integer\n#\nclass ExportedPlan < ApplicationRecord\n\n  include SettingsTemplateHelper\n\n  # associations between tables\n  belongs_to :plan\n  belongs_to :user, optional: true\n\n  validates :plan, presence: { message: PRESENCE_MESSAGE }\n\n  validates :format, presence: { message: PRESENCE_MESSAGE }\n\n  # Store settings with the exported plan so it can be recreated later\n  # if necessary (otherwise the settings associated with the plan at a\n  # given time can be lost)\n  has_settings :export, class_name: \"Settings::Template\" do |s|\n    s.key :export, defaults: Settings::Template::DEFAULT_SETTINGS\n  end\n\n  # TODO: Consider removing the accessor methods, they add no value. The view/controller could\n  #       just access the value directly from the project/plan: exported_plan.plan.project.title\n\n  # Getters to match Settings::Template::VALID_ADMIN_FIELDS\n  def project_name\n    name = plan.template.title\n    name += \" - #{plan.title}\" if plan.template.phases.count > 1\n    name\n  end\n\n  def project_identifier\n    plan.identifier\n  end\n\n  def grant_title\n    plan.grant&.value\n  end\n\n  def principal_investigator\n    plan.contributors.investigation\n  end\n\n  def project_data_contact\n    plan.contributors.data_curation\n  end\n\n  def project_admins\n    plan.contributors.project_administration\n  end\n\n  def project_description\n    plan.description\n  end\n\n  def owner\n    plan.roles.to_a.select(&:creator?).first.user\n  end\n\n  def funder\n    org = plan.funder\n    org = plan.template.try(:org) unless org.present?\n    org.name if org.present? && org.funder?\n  end\n\n  def institution\n    plan.owner.org.try(:name)\n  end\n\n  def orcid\n    return \"\" unless owner.present?\n\n    ids = owner.identifiers.by_scheme_name(\"orcid\", \"User\")\n    ids.first.present? ? ids.first.value : \"\"\n  end\n\n  def sections\n    self.phase_id ||= plan.template.phases.first.id\n    Section.where({ phase_id: phase_id }).order(:number)\n  end\n\n  def questions_for_section(section_id)\n    Question.where(id: questions).where(section_id: section_id).order(:number)\n  end\n\n  def admin_details\n    @admin_details ||= settings(:export).fields[:admin]\n  end\n\n  # Retrieves the title field\n  def title\n    settings(:export).title\n  end\n\n  # Export formats\n\n  # rubocop:disable Metrics/AbcSize, Metrics/MethodLength, Metrics/BlockLength\n  def as_csv(sections, unanswered_questions, question_headings)\n    CSV.generate do |csv|\n      # rubocop:disable Style/ConditionalAssignment\n      if question_headings\n        csv << [_(\"Section\"), _(\"Question\"), _(\"Answer\"), _(\"Selected option(s)\"),\n                _(\"Answered by\"), _(\"Answered at\")]\n      else\n        csv << [_(\"Section\"), _(\"Answer\"), _(\"Selected option(s)\"), _(\"Answered by\"),\n                _(\"Answered at\")]\n      end\n      # rubocop:enable Style/ConditionalAssignment\n      sections.each do |section|\n        section.questions.each do |question|\n          answer = Answer.where(plan_id: plan_id, question_id: question.id).first\n          # skip unansewered questions\n          next if answer.blank? && !unanswered_questions\n\n          answer_text = answer.present? ? answer.text : \"\"\n          q_format = question.question_format\n          options_string = if q_format.option_based?\n                             answer.question_options.collect(&:text).join(\"; \")\n                           else\n                             \"\"\n                           end\n          csv << if question_headings\n                   [\n                     section.title,\n                     sanitize_text(question.text),\n                     question.option_comment_display ? sanitize_text(answer_text) : \"\",\n                     options_string,\n                     user.name,\n                     answer.updated_at\n                   ]\n                 else\n                   [\n                     section.title,\n                     question.option_comment_display ? sanitize_text(answer_text) : \"\",\n                     options_string,\n                     user.name,\n                     answer.updated_at\n                   ]\n                 end\n        end\n      end\n    end\n  end\n  # rubocop:enable Metrics/AbcSize, Metrics/MethodLength, Metrics/BlockLength\n  # rubocop:enable\n\n  # rubocop:disable Metrics/AbcSize, Metrics/MethodLength\n  def as_txt(sections, unanswered_questions, question_headings, details)\n    output = \"#{plan.title}\\n\\n#{plan.template.title}\\n\"\n    output += \"\\n\" + _(\"Details\") + \"\\n\\n\"\n    if details\n      admin_details.each do |at|\n        value = send(at)\n        output += if value.present?\n                    admin_field_t(at.to_s) + \": \" + value + \"\\n\"\n                  else\n                    admin_field_t(at.to_s) + \": \" + _(\"-\") + \"\\n\"\n                  end\n      end\n    end\n\n    sections.each do |section|\n      output += \"\\n#{section.title}\\n\" if question_headings\n      section.questions.each do |question|\n        answer = plan.answer(question.id, false)\n        # skip if question un-answered\n        next if answer.nil? && !unanswered_questions\n\n        if question_headings\n          qtext = sanitize_text(question.text.gsub(/<li>/, \"  * \"))\n          output += \"\\n* #{qtext}\"\n        end\n        if answer.nil?\n          output += _(\"Question not answered.\") + \"\\n\"\n        else\n          q_format = question.question_format\n          if q_format.option_based?\n            output += answer.question_options.collect(&:text).join(\"\\n\")\n            output += \"\\n#{sanitize_text(answer.text)}\\n\" if question.option_comment_display\n          else\n            output += \"\\n#{sanitize_text(answer.text)}\\n\"\n          end\n        end\n      end\n    end\n    output\n  end\n  # rubocop:enable Metrics/AbcSize, Metrics/MethodLength\n  # rubocop:enable\n\n  private\n\n  # Returns an Array of question_ids for the exported settings stored for a plan\n  def questions\n    question_settings = settings(:export).fields[:questions]\n    @questions ||= if question_settings.present?\n                     if question_settings == :all\n                       Question.where(section_id: plan.sections.collect(&:id)).pluck(:id)\n                     elsif question_settings.is_a?(Array)\n                       question_settings\n                     else\n                       []\n                     end\n                   else\n                     []\n                   end\n  end\n\n  def sanitize_text(text)\n    ActionView::Base.full_sanitizer.sanitize(text.gsub(/&nbsp;/i, \"\")) unless text.nil?\n  end\n\nend\n", "# frozen_string_literal: true\n\n# builds a json response to a successful project createtion\n\njson.prettify!\n\n# rubocop:disable Metrics/BlockLength\njson.array! @plans.each do |plan|\n  json.id             plan.id\n  json.title          plan.title\n  json.grant_number   plan.grant&.value\n  json.last_updated   plan.updated_at\n  json.creation_date  plan.created_at\n  json.test_plan      plan.is_test?\n  json.template do\n    json.title        plan.template.title\n    json.id           plan.template.family_id\n  end\n  json.funder do\n    json.name(plan.template.org.funder? ? plan.template.org.name : plan.funder&.name)\n  end\n\n  investigator = plan.contributors.investigation.first\n  if investigator.present?\n    json.principal_investigator do\n      json.name         investigator.name\n      json.email        investigator.email\n      json.phone        investigator.phone\n    end\n  end\n\n  data_contact = plan.contributors.data_curation.first || plan.owner\n  if data_contact.present?\n    json.data_contact do\n      json.name   data_contact.is_a?(Contributor) ? data_contact.name : data_contact.name(false)\n      json.email  data_contact.email\n      json.phone  data_contact.phone if data_contact.is_a?(Contributor)\n    end\n  end\n\n  json.users plan.roles.each do |role|\n    json.email role.user.email\n  end\n  json.description plan.description\n  json.plan_content plan.template.phases.each do |phase|\n    json.title phase.title\n    json.description phase.description\n    json.sections phase.sections.each do |section|\n      json.title        section.title\n      json.description  section.description\n      json.number       section.number\n      json.questions section.questions.each do |question|\n        json.text       question.text\n        json.number     question.number\n        json.format     question.question_format.title\n        json.option_based question.question_format.option_based\n        json.themes question.themes.each do |theme|\n          json.theme theme.title\n        end\n        answer = plan.answers.select { |a| a.question_id == question.id }.first\n        if answer.present?\n          json.answered true\n          json.answer do\n            json.text answer.text\n            if answer.question_options.present?\n              json.options answer.question_options.each do |option|\n                json.text option.text\n              end\n            end\n          end\n        else\n          json.answered false\n        end\n      end\n    end\n  end\nend\n# rubocop:enable Metrics/BlockLength\n", "# frozen_string_literal: true\n\njson.prettify!\n\njson.plans @org_plans.each do |plan|\n  json.id             plan.id\n  json.grant_number   plan.grant&.value\n  json.title          plan.title\n  json.test_plan      plan.is_test?\n\n  json.template do\n    json.title        plan.template.title\n    json.id           plan.template.family_id\n  end\n\n  json.funder do\n    json.name         plan.template.org.funder? ? plan.template.org.name : \"\"\n  end\n\n  json.principal_investigator do\n    json.name         plan.contributors.investigation.first&.name\n  end\n\n  json.data_contact do\n    json.info         plan.contributors.data_curation.first&.name\n  end\n\n  json.description    plan.description\n\n  json.date_created   plan.created_at\n  json.date_last_updated plan.updated_at\n\n  json.completion do\n    json.total_questions     plan.questions.count\n    json.answered_questions  plan.answers.count\n  end\nend\n", "<%= \"#{@plan.title}\" %>\n<%= \"----------------------------------------------------------\\n\" %>\n<% if @show_coversheet %>\n<%= @hash[:attribution].many? ? _(\"Creators: \") : _('Creator:') %> <%= @hash[:attribution].join(', ') %>\n<%= _(\"Affiliation: \") + @hash[:affiliation] %>\n  <% if @hash[:funder].present? %>\n<%= _(\"Template: \") + @hash[:funder] %>\n  <% else %>\n<%= _(\"Template: \") + @hash[:template] + @hash[:customizer] %>\n  <% end %>\n  <% if @plan.grant&.value.present? %>\n<%= _(\"Grant number: \") + @plan.grant&.value %>\n  <% end %>\n  <% if @plan.description.present? %>\n<%= _(\"Project abstract: \") %>\n<%= \"\\t\" + strip_tags(@plan.description) + \"\\n\" %>\n  <% end %>\n<%= _(\"Last modified: \") + l(@plan.updated_at.to_date, formats: :short) %>\n<%= _(\"Copyright information:\") %>\n<%= \"\\t\" + _(\" The above plan creator(s) have agreed that others may use as much of the text of this plan as they would like in their own plans, and customise it as necessary. You do not need to credit the creator(s) as the source of the language used, but using any of the plan's text does not imply that the creator(s) endorse, or have any relationship to, your project or proposal\") %>\n<%= \"----------------------------------------------------------\\n\" %>\n<% end %>\n\n<% @hash[:phases].each do |phase| %>\n<%# Only render selected phase %>\n<% if phase[:title] == @selected_phase.title %>\n<%= (@hash[:phases].many? ? \"#{phase[:title]}\" : \"\") %>\n  <% phase[:sections].each do |section| %>\n    <% if display_section?(@hash[:customization], section, @show_custom_sections) && num_section_questions(@plan, section, phase) > 0 %>\n      <% if @show_sections_questions %>\n        <%= \"#{section[:title]}\\n\" %>\n      <% end %>\n      <% section[:questions].each do |question| %>\n        <% if remove_list(@plan).include?(question[:id]) %>\n          <% next %>\n        <% end %>\n        <%# text in this case is an array to accomodate for option_based %>\n        <% if @show_sections_questions %>\n          <% if question[:text].respond_to?(:each) %>\n            <% question[:text].each do |txt| %>\n              <%= \"#{strip_tags(txt.gsub(/<br\\/?>/, '\\n'))}\\n\" %>\n            <% end %>\n          <% else %>\n            <%= \"#{strip_tags(question[:text].gsub(/<tr>(\\s|<td>|<\\/td>|&nbsp;)*(<\\/tr>|<tr>)/,\"\"))}\\n\" if question[:text].present? && question[:text][0].present? %>\n          <% end %>\n        <% end %>\n        <% answer = @plan.answer(question[:id], false) %>\n        <% blank = not(answer.present? && answer.answered?) %>\n        <% if blank && @show_unanswered %>\n          <%= \"    #{_(\"Question not answered.\")}\\n\\n\" %>\n        <% elsif !blank %>\n          <% if answer.question_options.length > 0 %>\n            <% answer.question_options.each do |opt| %>\n              <%= \"    #{opt.text}\\n\" %>\n            <% end %>\n          <% end %>\n          <%= \"    #{strip_tags(answer.text.gsub(/<\\/?p>/, '').gsub(/<br\\s?\\/?>/, '\\n').chomp)}\\n\\n\" if answer.text.present? %>\n          <% end %>\n        <% end %>\n      <% end %>\n    <% end %>\n  <% end %>\n<% end %>\n<%= \"----------------------------------------------------------\" %>\n<%= _(\"A Data Management Plan created using %{application_name}\") % { application_name: ApplicationService.application_name } %>\n"], "filenames": ["app/models/concerns/exportable_plan.rb", "app/models/exported_plan.rb", "app/views/api/v0/plans/index.json.jbuilder", "app/views/api/v0/statistics/plans.json.jbuilder", "app/views/shared/export/_plan_txt.erb"], "buggy_code_start_loc": [141, 49, 11, 7, 11], "buggy_code_end_loc": [143, 50, 12, 8, 35], "fixing_code_start_loc": [141, 49, 11, 7, 11], "fixing_code_end_loc": [143, 50, 12, 8, 35], "type": "CWE-79", "message": "DMP Roadmap before 3.0.4 allows XSS.", "other": {"cve": {"id": "CVE-2021-44896", "sourceIdentifier": "cve@mitre.org", "published": "2022-01-01T23:15:08.647", "lastModified": "2022-01-07T19:39:18.350", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "DMP Roadmap before 3.0.4 allows XSS."}, {"lang": "es", "value": "DMP Roadmap versiones anteriores a 3.0.4, permite un ataque de tipo XSS.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dmproadmap_project:dmproadmap:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.0.4", "matchCriteriaId": "14A208F0-766D-4C43-BF14-A48D5F565350"}]}]}], "references": [{"url": "https://github.com/DMPRoadmap/roadmap/commit/0b83ad31ac01a709633080b134cfb6debc310c5e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/DMPRoadmap/roadmap/compare/v3.0.3...v3.0.4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/DMPRoadmap/roadmap/pull/3030", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/DMPRoadmap/roadmap/commit/0b83ad31ac01a709633080b134cfb6debc310c5e"}}