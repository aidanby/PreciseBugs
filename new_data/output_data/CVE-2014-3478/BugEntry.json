{"buggy_code": ["/*\n * Copyright (c) Ian F. Darwin 1986-1995.\n * Software written by Ian F. Darwin and others;\n * maintained 1995-present by Christos Zoulas and others.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice immediately at the beginning of the file, without modification,\n *    this list of conditions, and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n/*\n * softmagic - interpret variable magic from MAGIC\n */\n\n#include \"file.h\"\n\n#ifndef\tlint\nFILE_RCSID(\"@(#)$File: softmagic.c,v 1.189 2014/05/30 16:47:44 christos Exp $\")\n#endif\t/* lint */\n\n#include \"magic.h\"\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <time.h>\n#if defined(HAVE_LOCALE_H)\n#include <locale.h>\n#endif\n\n\nprivate int match(struct magic_set *, struct magic *, uint32_t,\n    const unsigned char *, size_t, size_t, int, int, int, int, int *, int *,\n    int *);\nprivate int mget(struct magic_set *, const unsigned char *,\n    struct magic *, size_t, size_t, unsigned int, int, int, int, int, int *,\n    int *, int *);\nprivate int magiccheck(struct magic_set *, struct magic *);\nprivate int32_t mprint(struct magic_set *, struct magic *);\nprivate int32_t moffset(struct magic_set *, struct magic *);\nprivate void mdebug(uint32_t, const char *, size_t);\nprivate int mcopy(struct magic_set *, union VALUETYPE *, int, int,\n    const unsigned char *, uint32_t, size_t, struct magic *);\nprivate int mconvert(struct magic_set *, struct magic *, int);\nprivate int print_sep(struct magic_set *, int);\nprivate int handle_annotation(struct magic_set *, struct magic *);\nprivate void cvt_8(union VALUETYPE *, const struct magic *);\nprivate void cvt_16(union VALUETYPE *, const struct magic *);\nprivate void cvt_32(union VALUETYPE *, const struct magic *);\nprivate void cvt_64(union VALUETYPE *, const struct magic *);\n\n#define OFFSET_OOB(n, o, i)\t((n) < (o) || (i) > ((n) - (o)))\n/*\n * softmagic - lookup one file in parsed, in-memory copy of database\n * Passed the name and FILE * of one file to be typed.\n */\n/*ARGSUSED1*/\t\t/* nbytes passed for regularity, maybe need later */\nprotected int\nfile_softmagic(struct magic_set *ms, const unsigned char *buf, size_t nbytes,\n    size_t level, int mode, int text)\n{\n\tstruct mlist *ml;\n\tint rv, printed_something = 0, need_separator = 0;\n\tfor (ml = ms->mlist[0]->next; ml != ms->mlist[0]; ml = ml->next)\n\t\tif ((rv = match(ms, ml->magic, ml->nmagic, buf, nbytes, 0, mode,\n\t\t    text, 0, level, &printed_something, &need_separator,\n\t\t    NULL)) != 0)\n\t\t\treturn rv;\n\n\treturn 0;\n}\n\n#define FILE_FMTDEBUG\n#ifdef FILE_FMTDEBUG\n#define F(a, b, c) file_fmtcheck((a), (b), (c), __FILE__, __LINE__)\n\nprivate const char * __attribute__((__format_arg__(3)))\nfile_fmtcheck(struct magic_set *ms, const struct magic *m, const char *def,\n\tconst char *file, size_t line)\n{\n\tconst char *ptr = fmtcheck(m->desc, def);\n\tif (ptr == def)\n\t\tfile_magerror(ms,\n\t\t    \"%s, %zu: format `%s' does not match with `%s'\",\n\t\t    file, line, m->desc, def);\n\treturn ptr;\n}\n#else\n#define F(a, b, c) fmtcheck((b)->desc, (c))\n#endif\n\n/*\n * Go through the whole list, stopping if you find a match.  Process all\n * the continuations of that match before returning.\n *\n * We support multi-level continuations:\n *\n *\tAt any time when processing a successful top-level match, there is a\n *\tcurrent continuation level; it represents the level of the last\n *\tsuccessfully matched continuation.\n *\n *\tContinuations above that level are skipped as, if we see one, it\n *\tmeans that the continuation that controls them - i.e, the\n *\tlower-level continuation preceding them - failed to match.\n *\n *\tContinuations below that level are processed as, if we see one,\n *\tit means we've finished processing or skipping higher-level\n *\tcontinuations under the control of a successful or unsuccessful\n *\tlower-level continuation, and are now seeing the next lower-level\n *\tcontinuation and should process it.  The current continuation\n *\tlevel reverts to the level of the one we're seeing.\n *\n *\tContinuations at the current level are processed as, if we see\n *\tone, there's no lower-level continuation that may have failed.\n *\n *\tIf a continuation matches, we bump the current continuation level\n *\tso that higher-level continuations are processed.\n */\nprivate int\nmatch(struct magic_set *ms, struct magic *magic, uint32_t nmagic,\n    const unsigned char *s, size_t nbytes, size_t offset, int mode, int text,\n    int flip, int recursion_level, int *printed_something, int *need_separator,\n    int *returnval)\n{\n\tuint32_t magindex = 0;\n\tunsigned int cont_level = 0;\n\tint returnvalv = 0, e; /* if a match is found it is set to 1*/\n\tint firstline = 1; /* a flag to print X\\n  X\\n- X */\n\tint print = (ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0;\n\n\tif (returnval == NULL)\n\t\treturnval = &returnvalv;\n\n\tif (file_check_mem(ms, cont_level) == -1)\n\t\treturn -1;\n\n\tfor (magindex = 0; magindex < nmagic; magindex++) {\n\t\tint flush = 0;\n\t\tstruct magic *m = &magic[magindex];\n\n\t\tif (m->type != FILE_NAME)\n\t\tif ((IS_STRING(m->type) &&\n#define FLT (STRING_BINTEST | STRING_TEXTTEST)\n\t\t     ((text && (m->str_flags & FLT) == STRING_BINTEST) ||\n\t\t      (!text && (m->str_flags & FLT) == STRING_TEXTTEST))) ||\n\t\t    (m->flag & mode) != mode) {\n\t\t\t/* Skip sub-tests */\n\t\t\twhile (magindex + 1 < nmagic &&\n                               magic[magindex + 1].cont_level != 0 &&\n\t\t\t       ++magindex)\n\t\t\t\tcontinue;\n\t\t\tcontinue; /* Skip to next top-level test*/\n\t\t}\n\n\t\tms->offset = m->offset;\n\t\tms->line = m->lineno;\n\n\t\t/* if main entry matches, print it... */\n\t\tswitch (mget(ms, s, m, nbytes, offset, cont_level, mode, text,\n\t\t    flip, recursion_level + 1, printed_something,\n\t\t    need_separator, returnval)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\tflush = m->reln != '!';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (m->type == FILE_INDIRECT)\n\t\t\t\t*returnval = 1;\n\n\t\t\tswitch (magiccheck(ms, m)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n\t\t\t\tflush++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tflush = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (flush) {\n\t\t\t/*\n\t\t\t * main entry didn't match,\n\t\t\t * flush its continuations\n\t\t\t */\n\t\t\twhile (magindex < nmagic - 1 &&\n\t\t\t    magic[magindex + 1].cont_level != 0)\n\t\t\t\tmagindex++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((e = handle_annotation(ms, m)) != 0) {\n\t\t\t*need_separator = 1;\n\t\t\t*printed_something = 1;\n\t\t\t*returnval = 1;\n\t\t\treturn e;\n\t\t}\n\t\t/*\n\t\t * If we are going to print something, we'll need to print\n\t\t * a blank before we print something else.\n\t\t */\n\t\tif (*m->desc) {\n\t\t\t*need_separator = 1;\n\t\t\t*printed_something = 1;\n\t\t\tif (print_sep(ms, firstline) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\n\n\t\tif (print && mprint(ms, m) == -1)\n\t\t\treturn -1;\n\n\t\tms->c.li[cont_level].off = moffset(ms, m);\n\n\t\t/* and any continuations that match */\n\t\tif (file_check_mem(ms, ++cont_level) == -1)\n\t\t\treturn -1;\n\n\t\twhile (++magindex < nmagic &&\n\t\t    magic[magindex].cont_level != 0) {\n\t\t\tm = &magic[magindex];\n\t\t\tms->line = m->lineno; /* for messages */\n\n\t\t\tif (cont_level < m->cont_level)\n\t\t\t\tcontinue;\n\t\t\tif (cont_level > m->cont_level) {\n\t\t\t\t/*\n\t\t\t\t * We're at the end of the level\n\t\t\t\t * \"cont_level\" continuations.\n\t\t\t\t */\n\t\t\t\tcont_level = m->cont_level;\n\t\t\t}\n\t\t\tms->offset = m->offset;\n\t\t\tif (m->flag & OFFADD) {\n\t\t\t\tms->offset +=\n\t\t\t\t    ms->c.li[cont_level - 1].off;\n\t\t\t}\n\n#ifdef ENABLE_CONDITIONALS\n\t\t\tif (m->cond == COND_ELSE ||\n\t\t\t    m->cond == COND_ELIF) {\n\t\t\t\tif (ms->c.li[cont_level].last_match == 1)\n\t\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tswitch (mget(ms, s, m, nbytes, offset, cont_level, mode,\n\t\t\t    text, flip, recursion_level + 1, printed_something,\n\t\t\t    need_separator, returnval)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n\t\t\t\tif (m->reln != '!')\n\t\t\t\t\tcontinue;\n\t\t\t\tflush = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (m->type == FILE_INDIRECT)\n\t\t\t\t\t*returnval = 1;\n\t\t\t\tflush = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (flush ? 1 : magiccheck(ms, m)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n#ifdef ENABLE_CONDITIONALS\n\t\t\t\tms->c.li[cont_level].last_match = 0;\n#endif\n\t\t\t\tbreak;\n\t\t\tdefault:\n#ifdef ENABLE_CONDITIONALS\n\t\t\t\tms->c.li[cont_level].last_match = 1;\n#endif\n\t\t\t\tif (m->type == FILE_CLEAR)\n\t\t\t\t\tms->c.li[cont_level].got_match = 0;\n\t\t\t\telse if (ms->c.li[cont_level].got_match) {\n\t\t\t\t\tif (m->type == FILE_DEFAULT)\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tms->c.li[cont_level].got_match = 1;\n\t\t\t\tif ((e = handle_annotation(ms, m)) != 0) {\n\t\t\t\t\t*need_separator = 1;\n\t\t\t\t\t*printed_something = 1;\n\t\t\t\t\t*returnval = 1;\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If we are going to print something,\n\t\t\t\t * make sure that we have a separator first.\n\t\t\t\t */\n\t\t\t\tif (*m->desc) {\n\t\t\t\t\tif (!*printed_something) {\n\t\t\t\t\t\t*printed_something = 1;\n\t\t\t\t\t\tif (print_sep(ms, firstline)\n\t\t\t\t\t\t    == -1)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * This continuation matched.  Print\n\t\t\t\t * its message, with a blank before it\n\t\t\t\t * if the previous item printed and\n\t\t\t\t * this item isn't empty.\n\t\t\t\t */\n\t\t\t\t/* space if previous printed */\n\t\t\t\tif (*need_separator\n\t\t\t\t    && ((m->flag & NOSPACE) == 0)\n\t\t\t\t    && *m->desc) {\n\t\t\t\t\tif (print &&\n\t\t\t\t\t    file_printf(ms, \" \") == -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t*need_separator = 0;\n\t\t\t\t}\n\t\t\t\tif (print && mprint(ms, m) == -1)\n\t\t\t\t\treturn -1;\n\n\t\t\t\tms->c.li[cont_level].off = moffset(ms, m);\n\n\t\t\t\tif (*m->desc)\n\t\t\t\t\t*need_separator = 1;\n\n\t\t\t\t/*\n\t\t\t\t * If we see any continuations\n\t\t\t\t * at a higher level,\n\t\t\t\t * process them.\n\t\t\t\t */\n\t\t\t\tif (file_check_mem(ms, ++cont_level) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (*printed_something) {\n\t\t\tfirstline = 0;\n\t\t\tif (print)\n\t\t\t\t*returnval = 1;\n\t\t}\n\t\tif ((ms->flags & MAGIC_CONTINUE) == 0 && *printed_something) {\n\t\t\treturn *returnval; /* don't keep searching */\n\t\t}\n\t}\n\treturn *returnval;  /* This is hit if -k is set or there is no match */\n}\n\nprivate int\ncheck_fmt(struct magic_set *ms, struct magic *m)\n{\n\tfile_regex_t rx;\n\tint rc, rv = -1;\n\n\tif (strchr(m->desc, '%') == NULL)\n\t\treturn 0;\n\n\trc = file_regcomp(&rx, \"%[-0-9\\\\.]*s\", REG_EXTENDED|REG_NOSUB);\n\tif (rc) {\n\t\tfile_regerror(&rx, rc, ms);\n\t} else {\n\t\trc = file_regexec(&rx, m->desc, 0, 0, 0);\n\t\trv = !rc;\n\t}\n\tfile_regfree(&rx);\n\treturn rv;\n}\n\n#ifndef HAVE_STRNDUP\nchar * strndup(const char *, size_t);\n\nchar *\nstrndup(const char *str, size_t n)\n{\n\tsize_t len;\n\tchar *copy;\n\n\tfor (len = 0; len < n && str[len]; len++)\n\t\tcontinue;\n\tif ((copy = malloc(len + 1)) == NULL)\n\t\treturn NULL;\n\t(void)memcpy(copy, str, len);\n\tcopy[len] = '\\0';\n\treturn copy;\n}\n#endif /* HAVE_STRNDUP */\n\nprivate int32_t\nmprint(struct magic_set *ms, struct magic *m)\n{\n\tuint64_t v;\n\tfloat vf;\n\tdouble vd;\n\tint64_t t = 0;\n \tchar buf[128], tbuf[26];\n\tunion VALUETYPE *p = &ms->ms_value;\n\n  \tswitch (m->type) {\n  \tcase FILE_BYTE:\n\t\tv = file_signextend(ms, m, (uint64_t)p->b);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%d\",\n\t\t\t    (unsigned char)v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%d\"),\n\t\t\t    (unsigned char) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(char);\n\t\tbreak;\n\n  \tcase FILE_SHORT:\n  \tcase FILE_BESHORT:\n  \tcase FILE_LESHORT:\n\t\tv = file_signextend(ms, m, (uint64_t)p->h);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%u\",\n\t\t\t    (unsigned short)v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%u\"),\n\t\t\t    (unsigned short) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(short);\n\t\tbreak;\n\n  \tcase FILE_LONG:\n  \tcase FILE_BELONG:\n  \tcase FILE_LELONG:\n  \tcase FILE_MELONG:\n\t\tv = file_signextend(ms, m, (uint64_t)p->l);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%u\", (uint32_t) v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%u\"), (uint32_t) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(int32_t);\n  \t\tbreak;\n\n  \tcase FILE_QUAD:\n  \tcase FILE_BEQUAD:\n  \tcase FILE_LEQUAD:\n\t\tv = file_signextend(ms, m, p->q);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%\" INT64_T_FORMAT \"u\",\n\t\t\t    (unsigned long long)v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%\" INT64_T_FORMAT \"u\"),\n\t\t\t    (unsigned long long) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(int64_t);\n  \t\tbreak;\n\n  \tcase FILE_STRING:\n  \tcase FILE_PSTRING:\n  \tcase FILE_BESTRING16:\n  \tcase FILE_LESTRING16:\n\t\tif (m->reln == '=' || m->reln == '!') {\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), m->value.s) == -1)\n\t\t\t\treturn -1;\n\t\t\tt = ms->offset + m->vallen;\n\t\t}\n\t\telse {\n\t\t\tchar *str = p->s;\n\n\t\t\t/* compute t before we mangle the string? */\n\t\t\tt = ms->offset + strlen(str);\n\n\t\t\tif (*m->value.s == '\\0')\n\t\t\t\tstr[strcspn(str, \"\\n\")] = '\\0';\n\n\t\t\tif (m->str_flags & STRING_TRIM) {\n\t\t\t\tchar *last;\n\t\t\t\twhile (isspace((unsigned char)*str))\n\t\t\t\t\tstr++;\n\t\t\t\tlast = str;\n\t\t\t\twhile (*last)\n\t\t\t\t\tlast++;\n\t\t\t\t--last;\n\t\t\t\twhile (isspace((unsigned char)*last))\n\t\t\t\t\tlast--;\n\t\t\t\t*++last = '\\0';\n\t\t\t}\n\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), str) == -1)\n\t\t\t\treturn -1;\n\n\t\t\tif (m->type == FILE_PSTRING)\n\t\t\t\tt += file_pstring_length_size(m);\n\t\t}\n\t\tbreak;\n\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->l + m->num_mask, FILE_T_LOCAL, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint32_t);\n\t\tbreak;\n\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->l + m->num_mask, 0, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint32_t);\n\t\tbreak;\n\n\tcase FILE_QDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_LEQDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->q + m->num_mask, FILE_T_LOCAL, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint64_t);\n\t\tbreak;\n\n\tcase FILE_QLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_LEQLDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->q + m->num_mask, 0, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint64_t);\n\t\tbreak;\n\n\tcase FILE_QWDATE:\n\tcase FILE_BEQWDATE:\n\tcase FILE_LEQWDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->q + m->num_mask, FILE_T_WINDOWS, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint64_t);\n\t\tbreak;\n\n  \tcase FILE_FLOAT:\n  \tcase FILE_BEFLOAT:\n  \tcase FILE_LEFLOAT:\n\t\tvf = p->f;\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%g\", vf);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%g\"), vf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(float);\n  \t\tbreak;\n\n  \tcase FILE_DOUBLE:\n  \tcase FILE_BEDOUBLE:\n  \tcase FILE_LEDOUBLE:\n\t\tvd = p->d;\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%g\", vd);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%g\"), vd) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(double);\n  \t\tbreak;\n\n\tcase FILE_REGEX: {\n\t\tchar *cp;\n\t\tint rval;\n\n\t\tcp = strndup((const char *)ms->search.s, ms->search.rm_len);\n\t\tif (cp == NULL) {\n\t\t\tfile_oomem(ms, ms->search.rm_len);\n\t\t\treturn -1;\n\t\t}\n\t\trval = file_printf(ms, F(ms, m, \"%s\"), cp);\n\t\tfree(cp);\n\n\t\tif (rval == -1)\n\t\t\treturn -1;\n\n\t\tif ((m->str_flags & REGEX_OFFSET_START))\n\t\t\tt = ms->search.offset;\n\t\telse\n\t\t\tt = ms->search.offset + ms->search.rm_len;\n\t\tbreak;\n\t}\n\n\tcase FILE_SEARCH:\n\t  \tif (file_printf(ms, F(ms, m, \"%s\"), m->value.s) == -1)\n\t\t\treturn -1;\n\t\tif ((m->str_flags & REGEX_OFFSET_START))\n\t\t\tt = ms->search.offset;\n\t\telse\n\t\t\tt = ms->search.offset + m->vallen;\n\t\tbreak;\n\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\t  \tif (file_printf(ms, \"%s\", m->desc) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\tcase FILE_USE:\n\tcase FILE_NAME:\n\t\tt = ms->offset;\n\t\tbreak;\n\n\tdefault:\n\t\tfile_magerror(ms, \"invalid m->type (%d) in mprint()\", m->type);\n\t\treturn -1;\n\t}\n\treturn (int32_t)t;\n}\n\nprivate int32_t\nmoffset(struct magic_set *ms, struct magic *m)\n{\n  \tswitch (m->type) {\n  \tcase FILE_BYTE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(char)));\n\n  \tcase FILE_SHORT:\n  \tcase FILE_BESHORT:\n  \tcase FILE_LESHORT:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(short)));\n\n  \tcase FILE_LONG:\n  \tcase FILE_BELONG:\n  \tcase FILE_LELONG:\n  \tcase FILE_MELONG:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(int32_t)));\n\n  \tcase FILE_QUAD:\n  \tcase FILE_BEQUAD:\n  \tcase FILE_LEQUAD:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(int64_t)));\n\n  \tcase FILE_STRING:\n  \tcase FILE_PSTRING:\n  \tcase FILE_BESTRING16:\n  \tcase FILE_LESTRING16:\n\t\tif (m->reln == '=' || m->reln == '!')\n\t\t\treturn ms->offset + m->vallen;\n\t\telse {\n\t\t\tunion VALUETYPE *p = &ms->ms_value;\n\t\t\tuint32_t t;\n\n\t\t\tif (*m->value.s == '\\0')\n\t\t\t\tp->s[strcspn(p->s, \"\\n\")] = '\\0';\n\t\t\tt = CAST(uint32_t, (ms->offset + strlen(p->s)));\n\t\t\tif (m->type == FILE_PSTRING)\n\t\t\t\tt += (uint32_t)file_pstring_length_size(m);\n\t\t\treturn t;\n\t\t}\n\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint32_t)));\n\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint32_t)));\n\n\tcase FILE_QDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_LEQDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint64_t)));\n\n\tcase FILE_QLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_LEQLDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint64_t)));\n\n  \tcase FILE_FLOAT:\n  \tcase FILE_BEFLOAT:\n  \tcase FILE_LEFLOAT:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(float)));\n\n  \tcase FILE_DOUBLE:\n  \tcase FILE_BEDOUBLE:\n  \tcase FILE_LEDOUBLE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(double)));\n\n\tcase FILE_REGEX:\n\t\tif ((m->str_flags & REGEX_OFFSET_START) != 0)\n\t\t\treturn CAST(int32_t, ms->search.offset);\n\t\telse\n\t\t\treturn CAST(int32_t, (ms->search.offset +\n\t\t\t    ms->search.rm_len));\n\n\tcase FILE_SEARCH:\n\t\tif ((m->str_flags & REGEX_OFFSET_START) != 0)\n\t\t\treturn CAST(int32_t, ms->search.offset);\n\t\telse\n\t\t\treturn CAST(int32_t, (ms->search.offset + m->vallen));\n\n\tcase FILE_CLEAR:\n\tcase FILE_DEFAULT:\n\tcase FILE_INDIRECT:\n\t\treturn ms->offset;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nprivate int\ncvt_flip(int type, int flip)\n{\n\tif (flip == 0)\n\t\treturn type;\n\tswitch (type) {\n\tcase FILE_BESHORT:\n\t\treturn FILE_LESHORT;\n\tcase FILE_BELONG:\n\t\treturn FILE_LELONG;\n\tcase FILE_BEDATE:\n\t\treturn FILE_LEDATE;\n\tcase FILE_BELDATE:\n\t\treturn FILE_LELDATE;\n\tcase FILE_BEQUAD:\n\t\treturn FILE_LEQUAD;\n\tcase FILE_BEQDATE:\n\t\treturn FILE_LEQDATE;\n\tcase FILE_BEQLDATE:\n\t\treturn FILE_LEQLDATE;\n\tcase FILE_BEQWDATE:\n\t\treturn FILE_LEQWDATE;\n\tcase FILE_LESHORT:\n\t\treturn FILE_BESHORT;\n\tcase FILE_LELONG:\n\t\treturn FILE_BELONG;\n\tcase FILE_LEDATE:\n\t\treturn FILE_BEDATE;\n\tcase FILE_LELDATE:\n\t\treturn FILE_BELDATE;\n\tcase FILE_LEQUAD:\n\t\treturn FILE_BEQUAD;\n\tcase FILE_LEQDATE:\n\t\treturn FILE_BEQDATE;\n\tcase FILE_LEQLDATE:\n\t\treturn FILE_BEQLDATE;\n\tcase FILE_LEQWDATE:\n\t\treturn FILE_BEQWDATE;\n\tcase FILE_BEFLOAT:\n\t\treturn FILE_LEFLOAT;\n\tcase FILE_LEFLOAT:\n\t\treturn FILE_BEFLOAT;\n\tcase FILE_BEDOUBLE:\n\t\treturn FILE_LEDOUBLE;\n\tcase FILE_LEDOUBLE:\n\t\treturn FILE_BEDOUBLE;\n\tdefault:\n\t\treturn type;\n\t}\n}\n#define DO_CVT(fld, cast) \\\n\tif (m->num_mask) \\\n\t\tswitch (m->mask_op & FILE_OPS_MASK) { \\\n\t\tcase FILE_OPAND: \\\n\t\t\tp->fld &= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPOR: \\\n\t\t\tp->fld |= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPXOR: \\\n\t\t\tp->fld ^= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPADD: \\\n\t\t\tp->fld += cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMINUS: \\\n\t\t\tp->fld -= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMULTIPLY: \\\n\t\t\tp->fld *= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPDIVIDE: \\\n\t\t\tp->fld /= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMODULO: \\\n\t\t\tp->fld %= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\t} \\\n\tif (m->mask_op & FILE_OPINVERSE) \\\n\t\tp->fld = ~p->fld \\\n\nprivate void\ncvt_8(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(b, (uint8_t));\n}\n\nprivate void\ncvt_16(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(h, (uint16_t));\n}\n\nprivate void\ncvt_32(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(l, (uint32_t));\n}\n\nprivate void\ncvt_64(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(q, (uint64_t));\n}\n\n#define DO_CVT2(fld, cast) \\\n\tif (m->num_mask) \\\n\t\tswitch (m->mask_op & FILE_OPS_MASK) { \\\n\t\tcase FILE_OPADD: \\\n\t\t\tp->fld += cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMINUS: \\\n\t\t\tp->fld -= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMULTIPLY: \\\n\t\t\tp->fld *= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPDIVIDE: \\\n\t\t\tp->fld /= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\t} \\\n\nprivate void\ncvt_float(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT2(f, (float));\n}\n\nprivate void\ncvt_double(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT2(d, (double));\n}\n\n/*\n * Convert the byte order of the data we are looking at\n * While we're here, let's apply the mask operation\n * (unless you have a better idea)\n */\nprivate int\nmconvert(struct magic_set *ms, struct magic *m, int flip)\n{\n\tunion VALUETYPE *p = &ms->ms_value;\n\tuint8_t type;\n\n\tswitch (type = cvt_flip(m->type, flip)) {\n\tcase FILE_BYTE:\n\t\tcvt_8(p, m);\n\t\treturn 1;\n\tcase FILE_SHORT:\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LONG:\n\tcase FILE_DATE:\n\tcase FILE_LDATE:\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_QUAD:\n\tcase FILE_QDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_QWDATE:\n\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_STRING:\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16: {\n\t\t/* Null terminate and eat *trailing* return */\n\t\tp->s[sizeof(p->s) - 1] = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_PSTRING: {\n\t\tchar *ptr1 = p->s, *ptr2 = ptr1 + file_pstring_length_size(m);\n\t\tsize_t len = file_pstring_get_length(m, ptr1);\n\t\tif (len >= sizeof(p->s))\n\t\t\tlen = sizeof(p->s) - 1;\n\t\twhile (len--)\n\t\t\t*ptr1++ = *ptr2++;\n\t\t*ptr1 = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_BESHORT:\n\t\tp->h = (short)((p->hs[0]<<8)|(p->hs[1]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_BELONG:\n\tcase FILE_BEDATE:\n\tcase FILE_BELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));\n\t\tif (type == FILE_BELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_BEQUAD:\n\tcase FILE_BEQDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_BEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));\n\t\tif (type == FILE_BEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_LESHORT:\n\t\tp->h = (short)((p->hs[1]<<8)|(p->hs[0]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LELONG:\n\tcase FILE_LEDATE:\n\tcase FILE_LELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));\n\t\tif (type == FILE_LELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_LEQUAD:\n\tcase FILE_LEQDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_LEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));\n\t\tif (type == FILE_LEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_MELONG:\n\tcase FILE_MEDATE:\n\tcase FILE_MELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));\n\t\tif (type == FILE_MELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_FLOAT:\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_BEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)|\n\t\t\t((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_LEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[3]<<24)|((uint32_t)p->hl[2]<<16)|\n\t\t\t((uint32_t)p->hl[1]<<8) |((uint32_t)p->hl[0]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_DOUBLE:\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_BEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t\t((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t\t((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t\t((uint64_t)p->hq[6]<<8) |((uint64_t)p->hq[7]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_LEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t\t((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t\t((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t\t((uint64_t)p->hq[1]<<8) |((uint64_t)p->hq[0]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_REGEX:\n\tcase FILE_SEARCH:\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\tcase FILE_NAME:\n\tcase FILE_USE:\n\t\treturn 1;\n\tdefault:\n\t\tfile_magerror(ms, \"invalid type %d in mconvert()\", m->type);\n\t\treturn 0;\n\t}\n}\n\n\nprivate void\nmdebug(uint32_t offset, const char *str, size_t len)\n{\n\t(void) fprintf(stderr, \"mget/%zu @%d: \", len, offset);\n\tfile_showstr(stderr, str, len);\n\t(void) fputc('\\n', stderr);\n\t(void) fputc('\\n', stderr);\n}\n\nprivate int\nmcopy(struct magic_set *ms, union VALUETYPE *p, int type, int indir,\n    const unsigned char *s, uint32_t offset, size_t nbytes, struct magic *m)\n{\n\t/*\n\t * Note: FILE_SEARCH and FILE_REGEX do not actually copy\n\t * anything, but setup pointers into the source\n\t */\n\tif (indir == 0) {\n\t\tswitch (type) {\n\t\tcase FILE_SEARCH:\n\t\t\tms->search.s = RCAST(const char *, s) + offset;\n\t\t\tms->search.s_len = nbytes - offset;\n\t\t\tms->search.offset = offset;\n\t\t\treturn 0;\n\n\t\tcase FILE_REGEX: {\n\t\t\tconst char *b;\n\t\t\tconst char *c;\n\t\t\tconst char *last;\t/* end of search region */\n\t\t\tconst char *buf;\t/* start of search region */\n\t\t\tconst char *end;\n\t\t\tsize_t lines, linecnt, bytecnt;\n\n\t\t\tif (s == NULL) {\n\t\t\t\tms->search.s_len = 0;\n\t\t\t\tms->search.s = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (m->str_flags & REGEX_LINE_COUNT) {\n\t\t\t\tlinecnt = m->str_range;\n\t\t\t\tbytecnt = linecnt * 80;\n\t\t\t} else {\n\t\t\t\tlinecnt = 0;\n\t\t\t\tbytecnt = m->str_range;\n\t\t\t}\n\n\t\t\tif (bytecnt == 0)\n\t\t\t\tbytecnt = 8192;\n\t\t\tif (bytecnt > nbytes)\n\t\t\t\tbytecnt = nbytes;\n\n\t\t\tbuf = RCAST(const char *, s) + offset;\n\t\t\tend = last = RCAST(const char *, s) + bytecnt;\n\t\t\t/* mget() guarantees buf <= last */\n\t\t\tfor (lines = linecnt, b = buf; lines && b < end &&\n\t\t\t     ((b = CAST(const char *,\n\t\t\t\t memchr(c = b, '\\n', CAST(size_t, (end - b)))))\n\t\t\t     || (b = CAST(const char *,\n\t\t\t\t memchr(c, '\\r', CAST(size_t, (end - c))))));\n\t\t\t     lines--, b++) {\n\t\t\t\tlast = b;\n\t\t\t\tif (b[0] == '\\r' && b[1] == '\\n')\n\t\t\t\t\tb++;\n\t\t\t}\n\t\t\tif (lines)\n\t\t\t\tlast = RCAST(const char *, s) + bytecnt;\n\n\t\t\tms->search.s = buf;\n\t\t\tms->search.s_len = last - buf;\n\t\t\tms->search.offset = offset;\n\t\t\tms->search.rm_len = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16: {\n\t\t\tconst unsigned char *src = s + offset;\n\t\t\tconst unsigned char *esrc = s + nbytes;\n\t\t\tchar *dst = p->s;\n\t\t\tchar *edst = &p->s[sizeof(p->s) - 1];\n\n\t\t\tif (type == FILE_BESTRING16)\n\t\t\t\tsrc++;\n\n\t\t\t/* check that offset is within range */\n\t\t\tif (offset >= nbytes)\n\t\t\t\tbreak;\n\t\t\tfor (/*EMPTY*/; src < esrc; src += 2, dst++) {\n\t\t\t\tif (dst < edst)\n\t\t\t\t\t*dst = *src;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t\tif (*dst == '\\0') {\n\t\t\t\t\tif (type == FILE_BESTRING16 ?\n\t\t\t\t\t    *(src - 1) != '\\0' :\n\t\t\t\t\t    *(src + 1) != '\\0')\n\t\t\t\t\t\t*dst = ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t\t*edst = '\\0';\n\t\t\treturn 0;\n\t\t}\n\t\tcase FILE_STRING:\t/* XXX - these two should not need */\n\t\tcase FILE_PSTRING:\t/* to copy anything, but do anyway. */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (offset >= nbytes) {\n\t\t(void)memset(p, '\\0', sizeof(*p));\n\t\treturn 0;\n\t}\n\tif (nbytes - offset < sizeof(*p))\n\t\tnbytes = nbytes - offset;\n\telse\n\t\tnbytes = sizeof(*p);\n\n\t(void)memcpy(p, s + offset, nbytes);\n\n\t/*\n\t * the usefulness of padding with zeroes eludes me, it\n\t * might even cause problems\n\t */\n\tif (nbytes < sizeof(*p))\n\t\t(void)memset(((char *)(void *)p) + nbytes, '\\0',\n\t\t    sizeof(*p) - nbytes);\n\treturn 0;\n}\n\nprivate int\nmget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n    int flip, int recursion_level, int *printed_something,\n    int *need_separator, int *returnval)\n{\n\tuint32_t soffset, offset = ms->offset;\n\tuint32_t lhs;\n\tint rv, oneed_separator, in_type;\n\tchar *sbuf, *rbuf;\n\tunion VALUETYPE *p = &ms->ms_value;\n\tstruct mlist ml;\n\n\tif (recursion_level >= 20) {\n\t\tfile_error(ms, 0, \"recursion nesting exceeded\");\n\t\treturn -1;\n\t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t    (uint32_t)nbytes, m) == -1)\n\t\treturn -1;\n\n\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\tfprintf(stderr, \"mget(type=%d, flag=%x, offset=%u, o=%zu, \"\n\t\t    \"nbytes=%zu)\\n\", m->type, m->flag, offset, o, nbytes);\n\t\tmdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\tfile_mdump(m);\n#endif\n\t}\n\n\tif (m->flag & INDIR) {\n\t\tint off = m->in_offset;\n\t\tif (m->in_op & FILE_OPINDIRECT) {\n\t\t\tconst union VALUETYPE *q = CAST(const union VALUETYPE *,\n\t\t\t    ((const void *)(s + offset + off)));\n\t\t\tswitch (cvt_flip(m->in_type, flip)) {\n\t\t\tcase FILE_BYTE:\n\t\t\t\toff = q->b;\n\t\t\t\tbreak;\n\t\t\tcase FILE_SHORT:\n\t\t\t\toff = q->h;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BESHORT:\n\t\t\t\toff = (short)((q->hs[0]<<8)|(q->hs[1]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LESHORT:\n\t\t\t\toff = (short)((q->hs[1]<<8)|(q->hs[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LONG:\n\t\t\t\toff = q->l;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BELONG:\n\t\t\tcase FILE_BEID3:\n\t\t\t\toff = (int32_t)((q->hl[0]<<24)|(q->hl[1]<<16)|\n\t\t\t\t\t\t (q->hl[2]<<8)|(q->hl[3]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LEID3:\n\t\t\tcase FILE_LELONG:\n\t\t\t\toff = (int32_t)((q->hl[3]<<24)|(q->hl[2]<<16)|\n\t\t\t\t\t\t (q->hl[1]<<8)|(q->hl[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_MELONG:\n\t\t\t\toff = (int32_t)((q->hl[1]<<24)|(q->hl[0]<<16)|\n\t\t\t\t\t\t (q->hl[3]<<8)|(q->hl[2]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect offs=%u\\n\", off);\n\t\t}\n\t\tswitch (in_type = cvt_flip(m->in_type, flip)) {\n\t\tcase FILE_BYTE:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 1))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->b & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->b | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->b ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->b + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->b - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->b * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->b / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->b % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->b;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BESHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hs[0] << 8) | p->hs[1];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LESHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hs[1] << 8) | p->hs[0];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->h & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->h | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->h ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->h + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->h - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->h * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->h / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->h % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p->h;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BELONG:\n\t\tcase FILE_BEID3:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hl[0] << 24) | (p->hl[1] << 16) |\n\t\t\t    (p->hl[2] << 8) | p->hl[3];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LELONG:\n\t\tcase FILE_LEID3:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hl[3] << 24) | (p->hl[2] << 16) |\n\t\t\t    (p->hl[1] << 8) | p->hl[0];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_MELONG:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hl[1] << 24) | (p->hl[0] << 16) |\n\t\t\t    (p->hl[3] << 8) | p->hl[2];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LONG:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->l & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->l | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->l ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->l + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->l - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->l * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->l / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->l % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->l;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (in_type) {\n\t\tcase FILE_LEID3:\n\t\tcase FILE_BEID3:\n\t\t\toffset = ((((offset >>  0) & 0x7f) <<  0) |\n\t\t\t\t (((offset >>  8) & 0x7f) <<  7) |\n\t\t\t\t (((offset >> 16) & 0x7f) << 14) |\n\t\t\t\t (((offset >> 24) & 0x7f) << 21)) + 10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (m->flag & INDIROFFADD) {\n\t\t\toffset += ms->c.li[cont_level-1].off;\n\t\t\tif (offset == 0) {\n\t\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t    \"indirect *zero* offset\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect +offs=%u\\n\", offset);\n\t\t}\n\t\tif (mcopy(ms, p, m->type, 0, s, offset, nbytes, m) == -1)\n\t\t\treturn -1;\n\t\tms->offset = offset;\n\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\t\tmdebug(offset, (char *)(void *)p,\n\t\t\t    sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\t\tfile_mdump(m);\n#endif\n\t\t}\n\t}\n\n\t/* Verify we have enough data to match magic type */\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\t\tif (OFFSET_OOB(nbytes, offset, 1))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_BESHORT:\n\tcase FILE_LESHORT:\n\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_BELONG:\n\tcase FILE_LELONG:\n\tcase FILE_MELONG:\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tif (OFFSET_OOB(nbytes, offset, 8))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\tcase FILE_SEARCH:\n\t\tif (OFFSET_OOB(nbytes, offset, m->vallen))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_REGEX:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\t\tif (offset == 0)\n\t\t\treturn 0;\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = ms->o.buf;\n\t\tsoffset = ms->offset;\n\t\tms->o.buf = NULL;\n\t\tms->offset = 0;\n\t\trv = file_softmagic(ms, s + offset, nbytes - offset,\n\t\t    recursion_level, BINTEST, text);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\tfprintf(stderr, \"indirect @offs=%u[%d]\\n\", offset, rv);\n\t\trbuf = ms->o.buf;\n\t\tms->o.buf = sbuf;\n\t\tms->offset = soffset;\n\t\tif (rv == 1) {\n\t\t\tif ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&\n\t\t\t    file_printf(ms, F(ms, m, \"%u\"), offset) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(rbuf);\n\t\treturn rv;\n\n\tcase FILE_USE:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = m->value.s;\n\t\tif (*sbuf == '^') {\n\t\t\tsbuf++;\n\t\t\tflip = !flip;\n\t\t}\n\t\tif (file_magicfind(ms, sbuf, &ml) == -1) {\n\t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", sbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\toneed_separator = *need_separator;\n\t\tif (m->flag & NOSPACE)\n\t\t\t*need_separator = 0;\n\t\trv = match(ms, ml.magic, ml.nmagic, s, nbytes, offset + o,\n\t\t    mode, text, flip, recursion_level, printed_something,\n\t\t    need_separator, returnval);\n\t\tif (rv != 1)\n\t\t    *need_separator = oneed_separator;\n\t\treturn rv;\n\n\tcase FILE_NAME:\n\t\tif (file_printf(ms, \"%s\", m->desc) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\tcase FILE_DEFAULT:\t/* nothing to check */\n\tcase FILE_CLEAR:\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!mconvert(ms, m, flip))\n\t\treturn 0;\n\treturn 1;\n}\n\nprivate uint64_t\nfile_strncmp(const char *s1, const char *s2, size_t len, uint32_t flags)\n{\n\t/*\n\t * Convert the source args to unsigned here so that (1) the\n\t * compare will be unsigned as it is in strncmp() and (2) so\n\t * the ctype functions will work correctly without extra\n\t * casting.\n\t */\n\tconst unsigned char *a = (const unsigned char *)s1;\n\tconst unsigned char *b = (const unsigned char *)s2;\n\tuint64_t v;\n\n\t/*\n\t * What we want here is v = strncmp(s1, s2, len),\n\t * but ignoring any nulls.\n\t */\n\tv = 0;\n\tif (0L == flags) { /* normal string: do it fast */\n\t\twhile (len-- > 0)\n\t\t\tif ((v = *b++ - *a++) != '\\0')\n\t\t\t\tbreak;\n\t}\n\telse { /* combine the others */\n\t\twhile (len-- > 0) {\n\t\t\tif ((flags & STRING_IGNORE_LOWERCASE) &&\n\t\t\t    islower(*a)) {\n\t\t\t\tif ((v = tolower(*b++) - *a++) != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ((flags & STRING_IGNORE_UPPERCASE) &&\n\t\t\t    isupper(*a)) {\n\t\t\t\tif ((v = toupper(*b++) - *a++) != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ((flags & STRING_COMPACT_WHITESPACE) &&\n\t\t\t    isspace(*a)) {\n\t\t\t\ta++;\n\t\t\t\tif (isspace(*b++)) {\n\t\t\t\t\tif (!isspace(*a))\n\t\t\t\t\t\twhile (isspace(*b))\n\t\t\t\t\t\t\tb++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ((flags & STRING_COMPACT_OPTIONAL_WHITESPACE) &&\n\t\t\t    isspace(*a)) {\n\t\t\t\ta++;\n\t\t\t\twhile (isspace(*b))\n\t\t\t\t\tb++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((v = *b++ - *a++) != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn v;\n}\n\nprivate uint64_t\nfile_strncmp16(const char *a, const char *b, size_t len, uint32_t flags)\n{\n\t/*\n\t * XXX - The 16-bit string compare probably needs to be done\n\t * differently, especially if the flags are to be supported.\n\t * At the moment, I am unsure.\n\t */\n\tflags = 0;\n\treturn file_strncmp(a, b, len, flags);\n}\n\nprivate int\nmagiccheck(struct magic_set *ms, struct magic *m)\n{\n\tuint64_t l = m->value.q;\n\tuint64_t v;\n\tfloat fl, fv;\n\tdouble dl, dv;\n\tint matched;\n\tunion VALUETYPE *p = &ms->ms_value;\n\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\t\tv = p->b;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_BESHORT:\n\tcase FILE_LESHORT:\n\t\tv = p->h;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_BELONG:\n\tcase FILE_LELONG:\n\tcase FILE_MELONG:\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\t\tv = p->l;\n\t\tbreak;\n\n\tcase FILE_QUAD:\n\tcase FILE_LEQUAD:\n\tcase FILE_BEQUAD:\n\tcase FILE_QDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_LEQDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_QWDATE:\n\tcase FILE_BEQWDATE:\n\tcase FILE_LEQWDATE:\n\t\tv = p->q;\n\t\tbreak;\n\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tfl = m->value.f;\n\t\tfv = p->f;\n\t\tswitch (m->reln) {\n\t\tcase 'x':\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\n\t\tcase '!':\n\t\t\tmatched = fv != fl;\n\t\t\tbreak;\n\n\t\tcase '=':\n\t\t\tmatched = fv == fl;\n\t\t\tbreak;\n\n\t\tcase '>':\n\t\t\tmatched = fv > fl;\n\t\t\tbreak;\n\n\t\tcase '<':\n\t\t\tmatched = fv < fl;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfile_magerror(ms, \"cannot happen with float: invalid relation `%c'\",\n\t\t\t    m->reln);\n\t\t\treturn -1;\n\t\t}\n\t\treturn matched;\n\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tdl = m->value.d;\n\t\tdv = p->d;\n\t\tswitch (m->reln) {\n\t\tcase 'x':\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\n\t\tcase '!':\n\t\t\tmatched = dv != dl;\n\t\t\tbreak;\n\n\t\tcase '=':\n\t\t\tmatched = dv == dl;\n\t\t\tbreak;\n\n\t\tcase '>':\n\t\t\tmatched = dv > dl;\n\t\t\tbreak;\n\n\t\tcase '<':\n\t\t\tmatched = dv < dl;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfile_magerror(ms, \"cannot happen with double: invalid relation `%c'\", m->reln);\n\t\t\treturn -1;\n\t\t}\n\t\treturn matched;\n\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\t\tl = 0;\n\t\tv = 0;\n\t\tbreak;\n\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\t\tl = 0;\n\t\tv = file_strncmp(m->value.s, p->s, (size_t)m->vallen, m->str_flags);\n\t\tbreak;\n\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16:\n\t\tl = 0;\n\t\tv = file_strncmp16(m->value.s, p->s, (size_t)m->vallen, m->str_flags);\n\t\tbreak;\n\n\tcase FILE_SEARCH: { /* search ms->search.s for the string m->value.s */\n\t\tsize_t slen;\n\t\tsize_t idx;\n\n\t\tif (ms->search.s == NULL)\n\t\t\treturn 0;\n\n\t\tslen = MIN(m->vallen, sizeof(m->value.s));\n\t\tl = 0;\n\t\tv = 0;\n\n\t\tfor (idx = 0; m->str_range == 0 || idx < m->str_range; idx++) {\n\t\t\tif (slen + idx > ms->search.s_len)\n\t\t\t\tbreak;\n\n\t\t\tv = file_strncmp(m->value.s, ms->search.s + idx, slen,\n\t\t\t    m->str_flags);\n\t\t\tif (v == 0) {\t/* found match */\n\t\t\t\tms->search.offset += idx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase FILE_REGEX: {\n\t\tint rc;\n\t\tfile_regex_t rx;\n\n\t\tif (ms->search.s == NULL)\n\t\t\treturn 0;\n\n\t\tl = 0;\n\t\trc = file_regcomp(&rx, m->value.s,\n\t\t    REG_EXTENDED|REG_NEWLINE|\n\t\t    ((m->str_flags & STRING_IGNORE_CASE) ? REG_ICASE : 0));\n\t\tif (rc) {\n\t\t\tfile_regerror(&rx, rc, ms);\n\t\t\tv = (uint64_t)-1;\n\t\t} else {\n\t\t\tregmatch_t pmatch[1];\n\t\t\tsize_t slen = ms->search.s_len;\n#ifndef REG_STARTEND\n#define\tREG_STARTEND\t0\n\t\t\tchar c;\n\t\t\tif (slen != 0)\n\t\t\t\tslen--;\n\t\t\tc = ms->search.s[slen];\n\t\t\t((char *)(intptr_t)ms->search.s)[slen] = '\\0';\n#else\n\t\t\tpmatch[0].rm_so = 0;\n\t\t\tpmatch[0].rm_eo = slen;\n#endif\n\t\t\trc = file_regexec(&rx, (const char *)ms->search.s,\n\t\t\t    1, pmatch, REG_STARTEND);\n#if REG_STARTEND == 0\n\t\t\t((char *)(intptr_t)ms->search.s)[l] = c;\n#endif\n\t\t\tswitch (rc) {\n\t\t\tcase 0:\n\t\t\t\tms->search.s += (int)pmatch[0].rm_so;\n\t\t\t\tms->search.offset += (size_t)pmatch[0].rm_so;\n\t\t\t\tms->search.rm_len =\n\t\t\t\t    (size_t)(pmatch[0].rm_eo - pmatch[0].rm_so);\n\t\t\t\tv = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase REG_NOMATCH:\n\t\t\t\tv = 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tfile_regerror(&rx, rc, ms);\n\t\t\t\tv = (uint64_t)-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfile_regfree(&rx);\n\t\tif (v == (uint64_t)-1)\n\t\t\treturn -1;\n\t\tbreak;\n\t}\n\tcase FILE_INDIRECT:\n\tcase FILE_USE:\n\tcase FILE_NAME:\n\t\treturn 1;\n\tdefault:\n\t\tfile_magerror(ms, \"invalid type %d in magiccheck()\", m->type);\n\t\treturn -1;\n\t}\n\n\tv = file_signextend(ms, m, v);\n\n\tswitch (m->reln) {\n\tcase 'x':\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t    \"u == *any* = 1\\n\", (unsigned long long)v);\n\t\tmatched = 1;\n\t\tbreak;\n\n\tcase '!':\n\t\tmatched = v != l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT \"u != %\"\n\t\t\t    INT64_T_FORMAT \"u = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, matched);\n\t\tbreak;\n\n\tcase '=':\n\t\tmatched = v == l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT \"u == %\"\n\t\t\t    INT64_T_FORMAT \"u = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, matched);\n\t\tbreak;\n\n\tcase '>':\n\t\tif (m->flag & UNSIGNED) {\n\t\t\tmatched = v > l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"u > %\" INT64_T_FORMAT \"u = %d\\n\",\n\t\t\t\t    (unsigned long long)v,\n\t\t\t\t    (unsigned long long)l, matched);\n\t\t}\n\t\telse {\n\t\t\tmatched = (int64_t) v > (int64_t) l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"d > %\" INT64_T_FORMAT \"d = %d\\n\",\n\t\t\t\t    (long long)v, (long long)l, matched);\n\t\t}\n\t\tbreak;\n\n\tcase '<':\n\t\tif (m->flag & UNSIGNED) {\n\t\t\tmatched = v < l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"u < %\" INT64_T_FORMAT \"u = %d\\n\",\n\t\t\t\t    (unsigned long long)v,\n\t\t\t\t    (unsigned long long)l, matched);\n\t\t}\n\t\telse {\n\t\t\tmatched = (int64_t) v < (int64_t) l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"d < %\" INT64_T_FORMAT \"d = %d\\n\",\n\t\t\t\t     (long long)v, (long long)l, matched);\n\t\t}\n\t\tbreak;\n\n\tcase '&':\n\t\tmatched = (v & l) == l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"((%\" INT64_T_FORMAT \"x & %\"\n\t\t\t    INT64_T_FORMAT \"x) == %\" INT64_T_FORMAT\n\t\t\t    \"x) = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, (unsigned long long)l,\n\t\t\t    matched);\n\t\tbreak;\n\n\tcase '^':\n\t\tmatched = (v & l) != l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"((%\" INT64_T_FORMAT \"x & %\"\n\t\t\t    INT64_T_FORMAT \"x) != %\" INT64_T_FORMAT\n\t\t\t    \"x) = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, (unsigned long long)l,\n\t\t\t    matched);\n\t\tbreak;\n\n\tdefault:\n\t\tfile_magerror(ms, \"cannot happen: invalid relation `%c'\",\n\t\t    m->reln);\n\t\treturn -1;\n\t}\n\n\treturn matched;\n}\n\nprivate int\nhandle_annotation(struct magic_set *ms, struct magic *m)\n{\n\tif (ms->flags & MAGIC_APPLE) {\n\t\tif (file_printf(ms, \"%.8s\", m->apple) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\t}\n\tif ((ms->flags & MAGIC_MIME_TYPE) && m->mimetype[0]) {\n\t\tif (file_printf(ms, \"%s\", m->mimetype) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nprivate int\nprint_sep(struct magic_set *ms, int firstline)\n{\n\tif (ms->flags & MAGIC_MIME)\n\t\treturn 0;\n\tif (firstline)\n\t\treturn 0;\n\t/*\n\t * we found another match\n\t * put a newline and '-' to do some simple formatting\n\t */\n\treturn file_printf(ms, \"\\n- \");\n}\n"], "fixing_code": ["/*\n * Copyright (c) Ian F. Darwin 1986-1995.\n * Software written by Ian F. Darwin and others;\n * maintained 1995-present by Christos Zoulas and others.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice immediately at the beginning of the file, without modification,\n *    this list of conditions, and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n/*\n * softmagic - interpret variable magic from MAGIC\n */\n\n#include \"file.h\"\n\n#ifndef\tlint\nFILE_RCSID(\"@(#)$File: softmagic.c,v 1.190 2014/06/03 19:01:34 christos Exp $\")\n#endif\t/* lint */\n\n#include \"magic.h\"\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <time.h>\n#if defined(HAVE_LOCALE_H)\n#include <locale.h>\n#endif\n\n\nprivate int match(struct magic_set *, struct magic *, uint32_t,\n    const unsigned char *, size_t, size_t, int, int, int, int, int *, int *,\n    int *);\nprivate int mget(struct magic_set *, const unsigned char *,\n    struct magic *, size_t, size_t, unsigned int, int, int, int, int, int *,\n    int *, int *);\nprivate int magiccheck(struct magic_set *, struct magic *);\nprivate int32_t mprint(struct magic_set *, struct magic *);\nprivate int32_t moffset(struct magic_set *, struct magic *);\nprivate void mdebug(uint32_t, const char *, size_t);\nprivate int mcopy(struct magic_set *, union VALUETYPE *, int, int,\n    const unsigned char *, uint32_t, size_t, struct magic *);\nprivate int mconvert(struct magic_set *, struct magic *, int);\nprivate int print_sep(struct magic_set *, int);\nprivate int handle_annotation(struct magic_set *, struct magic *);\nprivate void cvt_8(union VALUETYPE *, const struct magic *);\nprivate void cvt_16(union VALUETYPE *, const struct magic *);\nprivate void cvt_32(union VALUETYPE *, const struct magic *);\nprivate void cvt_64(union VALUETYPE *, const struct magic *);\n\n#define OFFSET_OOB(n, o, i)\t((n) < (o) || (i) > ((n) - (o)))\n/*\n * softmagic - lookup one file in parsed, in-memory copy of database\n * Passed the name and FILE * of one file to be typed.\n */\n/*ARGSUSED1*/\t\t/* nbytes passed for regularity, maybe need later */\nprotected int\nfile_softmagic(struct magic_set *ms, const unsigned char *buf, size_t nbytes,\n    size_t level, int mode, int text)\n{\n\tstruct mlist *ml;\n\tint rv, printed_something = 0, need_separator = 0;\n\tfor (ml = ms->mlist[0]->next; ml != ms->mlist[0]; ml = ml->next)\n\t\tif ((rv = match(ms, ml->magic, ml->nmagic, buf, nbytes, 0, mode,\n\t\t    text, 0, level, &printed_something, &need_separator,\n\t\t    NULL)) != 0)\n\t\t\treturn rv;\n\n\treturn 0;\n}\n\n#define FILE_FMTDEBUG\n#ifdef FILE_FMTDEBUG\n#define F(a, b, c) file_fmtcheck((a), (b), (c), __FILE__, __LINE__)\n\nprivate const char * __attribute__((__format_arg__(3)))\nfile_fmtcheck(struct magic_set *ms, const struct magic *m, const char *def,\n\tconst char *file, size_t line)\n{\n\tconst char *ptr = fmtcheck(m->desc, def);\n\tif (ptr == def)\n\t\tfile_magerror(ms,\n\t\t    \"%s, %zu: format `%s' does not match with `%s'\",\n\t\t    file, line, m->desc, def);\n\treturn ptr;\n}\n#else\n#define F(a, b, c) fmtcheck((b)->desc, (c))\n#endif\n\n/*\n * Go through the whole list, stopping if you find a match.  Process all\n * the continuations of that match before returning.\n *\n * We support multi-level continuations:\n *\n *\tAt any time when processing a successful top-level match, there is a\n *\tcurrent continuation level; it represents the level of the last\n *\tsuccessfully matched continuation.\n *\n *\tContinuations above that level are skipped as, if we see one, it\n *\tmeans that the continuation that controls them - i.e, the\n *\tlower-level continuation preceding them - failed to match.\n *\n *\tContinuations below that level are processed as, if we see one,\n *\tit means we've finished processing or skipping higher-level\n *\tcontinuations under the control of a successful or unsuccessful\n *\tlower-level continuation, and are now seeing the next lower-level\n *\tcontinuation and should process it.  The current continuation\n *\tlevel reverts to the level of the one we're seeing.\n *\n *\tContinuations at the current level are processed as, if we see\n *\tone, there's no lower-level continuation that may have failed.\n *\n *\tIf a continuation matches, we bump the current continuation level\n *\tso that higher-level continuations are processed.\n */\nprivate int\nmatch(struct magic_set *ms, struct magic *magic, uint32_t nmagic,\n    const unsigned char *s, size_t nbytes, size_t offset, int mode, int text,\n    int flip, int recursion_level, int *printed_something, int *need_separator,\n    int *returnval)\n{\n\tuint32_t magindex = 0;\n\tunsigned int cont_level = 0;\n\tint returnvalv = 0, e; /* if a match is found it is set to 1*/\n\tint firstline = 1; /* a flag to print X\\n  X\\n- X */\n\tint print = (ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0;\n\n\tif (returnval == NULL)\n\t\treturnval = &returnvalv;\n\n\tif (file_check_mem(ms, cont_level) == -1)\n\t\treturn -1;\n\n\tfor (magindex = 0; magindex < nmagic; magindex++) {\n\t\tint flush = 0;\n\t\tstruct magic *m = &magic[magindex];\n\n\t\tif (m->type != FILE_NAME)\n\t\tif ((IS_STRING(m->type) &&\n#define FLT (STRING_BINTEST | STRING_TEXTTEST)\n\t\t     ((text && (m->str_flags & FLT) == STRING_BINTEST) ||\n\t\t      (!text && (m->str_flags & FLT) == STRING_TEXTTEST))) ||\n\t\t    (m->flag & mode) != mode) {\n\t\t\t/* Skip sub-tests */\n\t\t\twhile (magindex + 1 < nmagic &&\n                               magic[magindex + 1].cont_level != 0 &&\n\t\t\t       ++magindex)\n\t\t\t\tcontinue;\n\t\t\tcontinue; /* Skip to next top-level test*/\n\t\t}\n\n\t\tms->offset = m->offset;\n\t\tms->line = m->lineno;\n\n\t\t/* if main entry matches, print it... */\n\t\tswitch (mget(ms, s, m, nbytes, offset, cont_level, mode, text,\n\t\t    flip, recursion_level + 1, printed_something,\n\t\t    need_separator, returnval)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\tflush = m->reln != '!';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (m->type == FILE_INDIRECT)\n\t\t\t\t*returnval = 1;\n\n\t\t\tswitch (magiccheck(ms, m)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n\t\t\t\tflush++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tflush = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (flush) {\n\t\t\t/*\n\t\t\t * main entry didn't match,\n\t\t\t * flush its continuations\n\t\t\t */\n\t\t\twhile (magindex < nmagic - 1 &&\n\t\t\t    magic[magindex + 1].cont_level != 0)\n\t\t\t\tmagindex++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((e = handle_annotation(ms, m)) != 0) {\n\t\t\t*need_separator = 1;\n\t\t\t*printed_something = 1;\n\t\t\t*returnval = 1;\n\t\t\treturn e;\n\t\t}\n\t\t/*\n\t\t * If we are going to print something, we'll need to print\n\t\t * a blank before we print something else.\n\t\t */\n\t\tif (*m->desc) {\n\t\t\t*need_separator = 1;\n\t\t\t*printed_something = 1;\n\t\t\tif (print_sep(ms, firstline) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\n\n\t\tif (print && mprint(ms, m) == -1)\n\t\t\treturn -1;\n\n\t\tms->c.li[cont_level].off = moffset(ms, m);\n\n\t\t/* and any continuations that match */\n\t\tif (file_check_mem(ms, ++cont_level) == -1)\n\t\t\treturn -1;\n\n\t\twhile (++magindex < nmagic &&\n\t\t    magic[magindex].cont_level != 0) {\n\t\t\tm = &magic[magindex];\n\t\t\tms->line = m->lineno; /* for messages */\n\n\t\t\tif (cont_level < m->cont_level)\n\t\t\t\tcontinue;\n\t\t\tif (cont_level > m->cont_level) {\n\t\t\t\t/*\n\t\t\t\t * We're at the end of the level\n\t\t\t\t * \"cont_level\" continuations.\n\t\t\t\t */\n\t\t\t\tcont_level = m->cont_level;\n\t\t\t}\n\t\t\tms->offset = m->offset;\n\t\t\tif (m->flag & OFFADD) {\n\t\t\t\tms->offset +=\n\t\t\t\t    ms->c.li[cont_level - 1].off;\n\t\t\t}\n\n#ifdef ENABLE_CONDITIONALS\n\t\t\tif (m->cond == COND_ELSE ||\n\t\t\t    m->cond == COND_ELIF) {\n\t\t\t\tif (ms->c.li[cont_level].last_match == 1)\n\t\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tswitch (mget(ms, s, m, nbytes, offset, cont_level, mode,\n\t\t\t    text, flip, recursion_level + 1, printed_something,\n\t\t\t    need_separator, returnval)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n\t\t\t\tif (m->reln != '!')\n\t\t\t\t\tcontinue;\n\t\t\t\tflush = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (m->type == FILE_INDIRECT)\n\t\t\t\t\t*returnval = 1;\n\t\t\t\tflush = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (flush ? 1 : magiccheck(ms, m)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n#ifdef ENABLE_CONDITIONALS\n\t\t\t\tms->c.li[cont_level].last_match = 0;\n#endif\n\t\t\t\tbreak;\n\t\t\tdefault:\n#ifdef ENABLE_CONDITIONALS\n\t\t\t\tms->c.li[cont_level].last_match = 1;\n#endif\n\t\t\t\tif (m->type == FILE_CLEAR)\n\t\t\t\t\tms->c.li[cont_level].got_match = 0;\n\t\t\t\telse if (ms->c.li[cont_level].got_match) {\n\t\t\t\t\tif (m->type == FILE_DEFAULT)\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tms->c.li[cont_level].got_match = 1;\n\t\t\t\tif ((e = handle_annotation(ms, m)) != 0) {\n\t\t\t\t\t*need_separator = 1;\n\t\t\t\t\t*printed_something = 1;\n\t\t\t\t\t*returnval = 1;\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If we are going to print something,\n\t\t\t\t * make sure that we have a separator first.\n\t\t\t\t */\n\t\t\t\tif (*m->desc) {\n\t\t\t\t\tif (!*printed_something) {\n\t\t\t\t\t\t*printed_something = 1;\n\t\t\t\t\t\tif (print_sep(ms, firstline)\n\t\t\t\t\t\t    == -1)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * This continuation matched.  Print\n\t\t\t\t * its message, with a blank before it\n\t\t\t\t * if the previous item printed and\n\t\t\t\t * this item isn't empty.\n\t\t\t\t */\n\t\t\t\t/* space if previous printed */\n\t\t\t\tif (*need_separator\n\t\t\t\t    && ((m->flag & NOSPACE) == 0)\n\t\t\t\t    && *m->desc) {\n\t\t\t\t\tif (print &&\n\t\t\t\t\t    file_printf(ms, \" \") == -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t*need_separator = 0;\n\t\t\t\t}\n\t\t\t\tif (print && mprint(ms, m) == -1)\n\t\t\t\t\treturn -1;\n\n\t\t\t\tms->c.li[cont_level].off = moffset(ms, m);\n\n\t\t\t\tif (*m->desc)\n\t\t\t\t\t*need_separator = 1;\n\n\t\t\t\t/*\n\t\t\t\t * If we see any continuations\n\t\t\t\t * at a higher level,\n\t\t\t\t * process them.\n\t\t\t\t */\n\t\t\t\tif (file_check_mem(ms, ++cont_level) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (*printed_something) {\n\t\t\tfirstline = 0;\n\t\t\tif (print)\n\t\t\t\t*returnval = 1;\n\t\t}\n\t\tif ((ms->flags & MAGIC_CONTINUE) == 0 && *printed_something) {\n\t\t\treturn *returnval; /* don't keep searching */\n\t\t}\n\t}\n\treturn *returnval;  /* This is hit if -k is set or there is no match */\n}\n\nprivate int\ncheck_fmt(struct magic_set *ms, struct magic *m)\n{\n\tfile_regex_t rx;\n\tint rc, rv = -1;\n\n\tif (strchr(m->desc, '%') == NULL)\n\t\treturn 0;\n\n\trc = file_regcomp(&rx, \"%[-0-9\\\\.]*s\", REG_EXTENDED|REG_NOSUB);\n\tif (rc) {\n\t\tfile_regerror(&rx, rc, ms);\n\t} else {\n\t\trc = file_regexec(&rx, m->desc, 0, 0, 0);\n\t\trv = !rc;\n\t}\n\tfile_regfree(&rx);\n\treturn rv;\n}\n\n#ifndef HAVE_STRNDUP\nchar * strndup(const char *, size_t);\n\nchar *\nstrndup(const char *str, size_t n)\n{\n\tsize_t len;\n\tchar *copy;\n\n\tfor (len = 0; len < n && str[len]; len++)\n\t\tcontinue;\n\tif ((copy = malloc(len + 1)) == NULL)\n\t\treturn NULL;\n\t(void)memcpy(copy, str, len);\n\tcopy[len] = '\\0';\n\treturn copy;\n}\n#endif /* HAVE_STRNDUP */\n\nprivate int32_t\nmprint(struct magic_set *ms, struct magic *m)\n{\n\tuint64_t v;\n\tfloat vf;\n\tdouble vd;\n\tint64_t t = 0;\n \tchar buf[128], tbuf[26];\n\tunion VALUETYPE *p = &ms->ms_value;\n\n  \tswitch (m->type) {\n  \tcase FILE_BYTE:\n\t\tv = file_signextend(ms, m, (uint64_t)p->b);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%d\",\n\t\t\t    (unsigned char)v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%d\"),\n\t\t\t    (unsigned char) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(char);\n\t\tbreak;\n\n  \tcase FILE_SHORT:\n  \tcase FILE_BESHORT:\n  \tcase FILE_LESHORT:\n\t\tv = file_signextend(ms, m, (uint64_t)p->h);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%u\",\n\t\t\t    (unsigned short)v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%u\"),\n\t\t\t    (unsigned short) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(short);\n\t\tbreak;\n\n  \tcase FILE_LONG:\n  \tcase FILE_BELONG:\n  \tcase FILE_LELONG:\n  \tcase FILE_MELONG:\n\t\tv = file_signextend(ms, m, (uint64_t)p->l);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%u\", (uint32_t) v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%u\"), (uint32_t) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(int32_t);\n  \t\tbreak;\n\n  \tcase FILE_QUAD:\n  \tcase FILE_BEQUAD:\n  \tcase FILE_LEQUAD:\n\t\tv = file_signextend(ms, m, p->q);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%\" INT64_T_FORMAT \"u\",\n\t\t\t    (unsigned long long)v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%\" INT64_T_FORMAT \"u\"),\n\t\t\t    (unsigned long long) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(int64_t);\n  \t\tbreak;\n\n  \tcase FILE_STRING:\n  \tcase FILE_PSTRING:\n  \tcase FILE_BESTRING16:\n  \tcase FILE_LESTRING16:\n\t\tif (m->reln == '=' || m->reln == '!') {\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), m->value.s) == -1)\n\t\t\t\treturn -1;\n\t\t\tt = ms->offset + m->vallen;\n\t\t}\n\t\telse {\n\t\t\tchar *str = p->s;\n\n\t\t\t/* compute t before we mangle the string? */\n\t\t\tt = ms->offset + strlen(str);\n\n\t\t\tif (*m->value.s == '\\0')\n\t\t\t\tstr[strcspn(str, \"\\n\")] = '\\0';\n\n\t\t\tif (m->str_flags & STRING_TRIM) {\n\t\t\t\tchar *last;\n\t\t\t\twhile (isspace((unsigned char)*str))\n\t\t\t\t\tstr++;\n\t\t\t\tlast = str;\n\t\t\t\twhile (*last)\n\t\t\t\t\tlast++;\n\t\t\t\t--last;\n\t\t\t\twhile (isspace((unsigned char)*last))\n\t\t\t\t\tlast--;\n\t\t\t\t*++last = '\\0';\n\t\t\t}\n\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), str) == -1)\n\t\t\t\treturn -1;\n\n\t\t\tif (m->type == FILE_PSTRING)\n\t\t\t\tt += file_pstring_length_size(m);\n\t\t}\n\t\tbreak;\n\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->l + m->num_mask, FILE_T_LOCAL, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint32_t);\n\t\tbreak;\n\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->l + m->num_mask, 0, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint32_t);\n\t\tbreak;\n\n\tcase FILE_QDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_LEQDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->q + m->num_mask, FILE_T_LOCAL, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint64_t);\n\t\tbreak;\n\n\tcase FILE_QLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_LEQLDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->q + m->num_mask, 0, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint64_t);\n\t\tbreak;\n\n\tcase FILE_QWDATE:\n\tcase FILE_BEQWDATE:\n\tcase FILE_LEQWDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->q + m->num_mask, FILE_T_WINDOWS, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint64_t);\n\t\tbreak;\n\n  \tcase FILE_FLOAT:\n  \tcase FILE_BEFLOAT:\n  \tcase FILE_LEFLOAT:\n\t\tvf = p->f;\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%g\", vf);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%g\"), vf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(float);\n  \t\tbreak;\n\n  \tcase FILE_DOUBLE:\n  \tcase FILE_BEDOUBLE:\n  \tcase FILE_LEDOUBLE:\n\t\tvd = p->d;\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%g\", vd);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%g\"), vd) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(double);\n  \t\tbreak;\n\n\tcase FILE_REGEX: {\n\t\tchar *cp;\n\t\tint rval;\n\n\t\tcp = strndup((const char *)ms->search.s, ms->search.rm_len);\n\t\tif (cp == NULL) {\n\t\t\tfile_oomem(ms, ms->search.rm_len);\n\t\t\treturn -1;\n\t\t}\n\t\trval = file_printf(ms, F(ms, m, \"%s\"), cp);\n\t\tfree(cp);\n\n\t\tif (rval == -1)\n\t\t\treturn -1;\n\n\t\tif ((m->str_flags & REGEX_OFFSET_START))\n\t\t\tt = ms->search.offset;\n\t\telse\n\t\t\tt = ms->search.offset + ms->search.rm_len;\n\t\tbreak;\n\t}\n\n\tcase FILE_SEARCH:\n\t  \tif (file_printf(ms, F(ms, m, \"%s\"), m->value.s) == -1)\n\t\t\treturn -1;\n\t\tif ((m->str_flags & REGEX_OFFSET_START))\n\t\t\tt = ms->search.offset;\n\t\telse\n\t\t\tt = ms->search.offset + m->vallen;\n\t\tbreak;\n\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\t  \tif (file_printf(ms, \"%s\", m->desc) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\tcase FILE_USE:\n\tcase FILE_NAME:\n\t\tt = ms->offset;\n\t\tbreak;\n\n\tdefault:\n\t\tfile_magerror(ms, \"invalid m->type (%d) in mprint()\", m->type);\n\t\treturn -1;\n\t}\n\treturn (int32_t)t;\n}\n\nprivate int32_t\nmoffset(struct magic_set *ms, struct magic *m)\n{\n  \tswitch (m->type) {\n  \tcase FILE_BYTE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(char)));\n\n  \tcase FILE_SHORT:\n  \tcase FILE_BESHORT:\n  \tcase FILE_LESHORT:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(short)));\n\n  \tcase FILE_LONG:\n  \tcase FILE_BELONG:\n  \tcase FILE_LELONG:\n  \tcase FILE_MELONG:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(int32_t)));\n\n  \tcase FILE_QUAD:\n  \tcase FILE_BEQUAD:\n  \tcase FILE_LEQUAD:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(int64_t)));\n\n  \tcase FILE_STRING:\n  \tcase FILE_PSTRING:\n  \tcase FILE_BESTRING16:\n  \tcase FILE_LESTRING16:\n\t\tif (m->reln == '=' || m->reln == '!')\n\t\t\treturn ms->offset + m->vallen;\n\t\telse {\n\t\t\tunion VALUETYPE *p = &ms->ms_value;\n\t\t\tuint32_t t;\n\n\t\t\tif (*m->value.s == '\\0')\n\t\t\t\tp->s[strcspn(p->s, \"\\n\")] = '\\0';\n\t\t\tt = CAST(uint32_t, (ms->offset + strlen(p->s)));\n\t\t\tif (m->type == FILE_PSTRING)\n\t\t\t\tt += (uint32_t)file_pstring_length_size(m);\n\t\t\treturn t;\n\t\t}\n\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint32_t)));\n\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint32_t)));\n\n\tcase FILE_QDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_LEQDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint64_t)));\n\n\tcase FILE_QLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_LEQLDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint64_t)));\n\n  \tcase FILE_FLOAT:\n  \tcase FILE_BEFLOAT:\n  \tcase FILE_LEFLOAT:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(float)));\n\n  \tcase FILE_DOUBLE:\n  \tcase FILE_BEDOUBLE:\n  \tcase FILE_LEDOUBLE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(double)));\n\n\tcase FILE_REGEX:\n\t\tif ((m->str_flags & REGEX_OFFSET_START) != 0)\n\t\t\treturn CAST(int32_t, ms->search.offset);\n\t\telse\n\t\t\treturn CAST(int32_t, (ms->search.offset +\n\t\t\t    ms->search.rm_len));\n\n\tcase FILE_SEARCH:\n\t\tif ((m->str_flags & REGEX_OFFSET_START) != 0)\n\t\t\treturn CAST(int32_t, ms->search.offset);\n\t\telse\n\t\t\treturn CAST(int32_t, (ms->search.offset + m->vallen));\n\n\tcase FILE_CLEAR:\n\tcase FILE_DEFAULT:\n\tcase FILE_INDIRECT:\n\t\treturn ms->offset;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nprivate int\ncvt_flip(int type, int flip)\n{\n\tif (flip == 0)\n\t\treturn type;\n\tswitch (type) {\n\tcase FILE_BESHORT:\n\t\treturn FILE_LESHORT;\n\tcase FILE_BELONG:\n\t\treturn FILE_LELONG;\n\tcase FILE_BEDATE:\n\t\treturn FILE_LEDATE;\n\tcase FILE_BELDATE:\n\t\treturn FILE_LELDATE;\n\tcase FILE_BEQUAD:\n\t\treturn FILE_LEQUAD;\n\tcase FILE_BEQDATE:\n\t\treturn FILE_LEQDATE;\n\tcase FILE_BEQLDATE:\n\t\treturn FILE_LEQLDATE;\n\tcase FILE_BEQWDATE:\n\t\treturn FILE_LEQWDATE;\n\tcase FILE_LESHORT:\n\t\treturn FILE_BESHORT;\n\tcase FILE_LELONG:\n\t\treturn FILE_BELONG;\n\tcase FILE_LEDATE:\n\t\treturn FILE_BEDATE;\n\tcase FILE_LELDATE:\n\t\treturn FILE_BELDATE;\n\tcase FILE_LEQUAD:\n\t\treturn FILE_BEQUAD;\n\tcase FILE_LEQDATE:\n\t\treturn FILE_BEQDATE;\n\tcase FILE_LEQLDATE:\n\t\treturn FILE_BEQLDATE;\n\tcase FILE_LEQWDATE:\n\t\treturn FILE_BEQWDATE;\n\tcase FILE_BEFLOAT:\n\t\treturn FILE_LEFLOAT;\n\tcase FILE_LEFLOAT:\n\t\treturn FILE_BEFLOAT;\n\tcase FILE_BEDOUBLE:\n\t\treturn FILE_LEDOUBLE;\n\tcase FILE_LEDOUBLE:\n\t\treturn FILE_BEDOUBLE;\n\tdefault:\n\t\treturn type;\n\t}\n}\n#define DO_CVT(fld, cast) \\\n\tif (m->num_mask) \\\n\t\tswitch (m->mask_op & FILE_OPS_MASK) { \\\n\t\tcase FILE_OPAND: \\\n\t\t\tp->fld &= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPOR: \\\n\t\t\tp->fld |= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPXOR: \\\n\t\t\tp->fld ^= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPADD: \\\n\t\t\tp->fld += cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMINUS: \\\n\t\t\tp->fld -= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMULTIPLY: \\\n\t\t\tp->fld *= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPDIVIDE: \\\n\t\t\tp->fld /= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMODULO: \\\n\t\t\tp->fld %= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\t} \\\n\tif (m->mask_op & FILE_OPINVERSE) \\\n\t\tp->fld = ~p->fld \\\n\nprivate void\ncvt_8(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(b, (uint8_t));\n}\n\nprivate void\ncvt_16(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(h, (uint16_t));\n}\n\nprivate void\ncvt_32(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(l, (uint32_t));\n}\n\nprivate void\ncvt_64(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(q, (uint64_t));\n}\n\n#define DO_CVT2(fld, cast) \\\n\tif (m->num_mask) \\\n\t\tswitch (m->mask_op & FILE_OPS_MASK) { \\\n\t\tcase FILE_OPADD: \\\n\t\t\tp->fld += cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMINUS: \\\n\t\t\tp->fld -= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMULTIPLY: \\\n\t\t\tp->fld *= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPDIVIDE: \\\n\t\t\tp->fld /= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\t} \\\n\nprivate void\ncvt_float(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT2(f, (float));\n}\n\nprivate void\ncvt_double(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT2(d, (double));\n}\n\n/*\n * Convert the byte order of the data we are looking at\n * While we're here, let's apply the mask operation\n * (unless you have a better idea)\n */\nprivate int\nmconvert(struct magic_set *ms, struct magic *m, int flip)\n{\n\tunion VALUETYPE *p = &ms->ms_value;\n\tuint8_t type;\n\n\tswitch (type = cvt_flip(m->type, flip)) {\n\tcase FILE_BYTE:\n\t\tcvt_8(p, m);\n\t\treturn 1;\n\tcase FILE_SHORT:\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LONG:\n\tcase FILE_DATE:\n\tcase FILE_LDATE:\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_QUAD:\n\tcase FILE_QDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_QWDATE:\n\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_STRING:\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16: {\n\t\t/* Null terminate and eat *trailing* return */\n\t\tp->s[sizeof(p->s) - 1] = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_PSTRING: {\n\t\tsize_t sz = file_pstring_length_size(m);\n\t\tchar *ptr1 = p->s, *ptr2 = ptr1 + sz;\n\t\tsize_t len = file_pstring_get_length(m, ptr1);\n\t\tif (len >= sizeof(p->s)) {\n\t\t\t/*\n\t\t\t * The size of the pascal string length (sz)\n\t\t\t * is 1, 2, or 4. We need at least 1 byte for NUL\n\t\t\t * termination, but we've already truncated the\n\t\t\t * string by p->s, so we need to deduct sz.\n\t\t\t */ \n\t\t\tlen = sizeof(p->s) - sz;\n\t\t}\n\t\twhile (len--)\n\t\t\t*ptr1++ = *ptr2++;\n\t\t*ptr1 = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_BESHORT:\n\t\tp->h = (short)((p->hs[0]<<8)|(p->hs[1]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_BELONG:\n\tcase FILE_BEDATE:\n\tcase FILE_BELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));\n\t\tif (type == FILE_BELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_BEQUAD:\n\tcase FILE_BEQDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_BEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));\n\t\tif (type == FILE_BEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_LESHORT:\n\t\tp->h = (short)((p->hs[1]<<8)|(p->hs[0]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LELONG:\n\tcase FILE_LEDATE:\n\tcase FILE_LELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));\n\t\tif (type == FILE_LELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_LEQUAD:\n\tcase FILE_LEQDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_LEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));\n\t\tif (type == FILE_LEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_MELONG:\n\tcase FILE_MEDATE:\n\tcase FILE_MELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));\n\t\tif (type == FILE_MELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_FLOAT:\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_BEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)|\n\t\t\t((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_LEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[3]<<24)|((uint32_t)p->hl[2]<<16)|\n\t\t\t((uint32_t)p->hl[1]<<8) |((uint32_t)p->hl[0]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_DOUBLE:\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_BEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t\t((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t\t((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t\t((uint64_t)p->hq[6]<<8) |((uint64_t)p->hq[7]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_LEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t\t((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t\t((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t\t((uint64_t)p->hq[1]<<8) |((uint64_t)p->hq[0]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_REGEX:\n\tcase FILE_SEARCH:\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\tcase FILE_NAME:\n\tcase FILE_USE:\n\t\treturn 1;\n\tdefault:\n\t\tfile_magerror(ms, \"invalid type %d in mconvert()\", m->type);\n\t\treturn 0;\n\t}\n}\n\n\nprivate void\nmdebug(uint32_t offset, const char *str, size_t len)\n{\n\t(void) fprintf(stderr, \"mget/%zu @%d: \", len, offset);\n\tfile_showstr(stderr, str, len);\n\t(void) fputc('\\n', stderr);\n\t(void) fputc('\\n', stderr);\n}\n\nprivate int\nmcopy(struct magic_set *ms, union VALUETYPE *p, int type, int indir,\n    const unsigned char *s, uint32_t offset, size_t nbytes, struct magic *m)\n{\n\t/*\n\t * Note: FILE_SEARCH and FILE_REGEX do not actually copy\n\t * anything, but setup pointers into the source\n\t */\n\tif (indir == 0) {\n\t\tswitch (type) {\n\t\tcase FILE_SEARCH:\n\t\t\tms->search.s = RCAST(const char *, s) + offset;\n\t\t\tms->search.s_len = nbytes - offset;\n\t\t\tms->search.offset = offset;\n\t\t\treturn 0;\n\n\t\tcase FILE_REGEX: {\n\t\t\tconst char *b;\n\t\t\tconst char *c;\n\t\t\tconst char *last;\t/* end of search region */\n\t\t\tconst char *buf;\t/* start of search region */\n\t\t\tconst char *end;\n\t\t\tsize_t lines, linecnt, bytecnt;\n\n\t\t\tif (s == NULL) {\n\t\t\t\tms->search.s_len = 0;\n\t\t\t\tms->search.s = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (m->str_flags & REGEX_LINE_COUNT) {\n\t\t\t\tlinecnt = m->str_range;\n\t\t\t\tbytecnt = linecnt * 80;\n\t\t\t} else {\n\t\t\t\tlinecnt = 0;\n\t\t\t\tbytecnt = m->str_range;\n\t\t\t}\n\n\t\t\tif (bytecnt == 0)\n\t\t\t\tbytecnt = 8192;\n\t\t\tif (bytecnt > nbytes)\n\t\t\t\tbytecnt = nbytes;\n\n\t\t\tbuf = RCAST(const char *, s) + offset;\n\t\t\tend = last = RCAST(const char *, s) + bytecnt;\n\t\t\t/* mget() guarantees buf <= last */\n\t\t\tfor (lines = linecnt, b = buf; lines && b < end &&\n\t\t\t     ((b = CAST(const char *,\n\t\t\t\t memchr(c = b, '\\n', CAST(size_t, (end - b)))))\n\t\t\t     || (b = CAST(const char *,\n\t\t\t\t memchr(c, '\\r', CAST(size_t, (end - c))))));\n\t\t\t     lines--, b++) {\n\t\t\t\tlast = b;\n\t\t\t\tif (b[0] == '\\r' && b[1] == '\\n')\n\t\t\t\t\tb++;\n\t\t\t}\n\t\t\tif (lines)\n\t\t\t\tlast = RCAST(const char *, s) + bytecnt;\n\n\t\t\tms->search.s = buf;\n\t\t\tms->search.s_len = last - buf;\n\t\t\tms->search.offset = offset;\n\t\t\tms->search.rm_len = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16: {\n\t\t\tconst unsigned char *src = s + offset;\n\t\t\tconst unsigned char *esrc = s + nbytes;\n\t\t\tchar *dst = p->s;\n\t\t\tchar *edst = &p->s[sizeof(p->s) - 1];\n\n\t\t\tif (type == FILE_BESTRING16)\n\t\t\t\tsrc++;\n\n\t\t\t/* check that offset is within range */\n\t\t\tif (offset >= nbytes)\n\t\t\t\tbreak;\n\t\t\tfor (/*EMPTY*/; src < esrc; src += 2, dst++) {\n\t\t\t\tif (dst < edst)\n\t\t\t\t\t*dst = *src;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t\tif (*dst == '\\0') {\n\t\t\t\t\tif (type == FILE_BESTRING16 ?\n\t\t\t\t\t    *(src - 1) != '\\0' :\n\t\t\t\t\t    *(src + 1) != '\\0')\n\t\t\t\t\t\t*dst = ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t\t*edst = '\\0';\n\t\t\treturn 0;\n\t\t}\n\t\tcase FILE_STRING:\t/* XXX - these two should not need */\n\t\tcase FILE_PSTRING:\t/* to copy anything, but do anyway. */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (offset >= nbytes) {\n\t\t(void)memset(p, '\\0', sizeof(*p));\n\t\treturn 0;\n\t}\n\tif (nbytes - offset < sizeof(*p))\n\t\tnbytes = nbytes - offset;\n\telse\n\t\tnbytes = sizeof(*p);\n\n\t(void)memcpy(p, s + offset, nbytes);\n\n\t/*\n\t * the usefulness of padding with zeroes eludes me, it\n\t * might even cause problems\n\t */\n\tif (nbytes < sizeof(*p))\n\t\t(void)memset(((char *)(void *)p) + nbytes, '\\0',\n\t\t    sizeof(*p) - nbytes);\n\treturn 0;\n}\n\nprivate int\nmget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n    int flip, int recursion_level, int *printed_something,\n    int *need_separator, int *returnval)\n{\n\tuint32_t soffset, offset = ms->offset;\n\tuint32_t lhs;\n\tint rv, oneed_separator, in_type;\n\tchar *sbuf, *rbuf;\n\tunion VALUETYPE *p = &ms->ms_value;\n\tstruct mlist ml;\n\n\tif (recursion_level >= 20) {\n\t\tfile_error(ms, 0, \"recursion nesting exceeded\");\n\t\treturn -1;\n\t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t    (uint32_t)nbytes, m) == -1)\n\t\treturn -1;\n\n\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\tfprintf(stderr, \"mget(type=%d, flag=%x, offset=%u, o=%zu, \"\n\t\t    \"nbytes=%zu)\\n\", m->type, m->flag, offset, o, nbytes);\n\t\tmdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\tfile_mdump(m);\n#endif\n\t}\n\n\tif (m->flag & INDIR) {\n\t\tint off = m->in_offset;\n\t\tif (m->in_op & FILE_OPINDIRECT) {\n\t\t\tconst union VALUETYPE *q = CAST(const union VALUETYPE *,\n\t\t\t    ((const void *)(s + offset + off)));\n\t\t\tswitch (cvt_flip(m->in_type, flip)) {\n\t\t\tcase FILE_BYTE:\n\t\t\t\toff = q->b;\n\t\t\t\tbreak;\n\t\t\tcase FILE_SHORT:\n\t\t\t\toff = q->h;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BESHORT:\n\t\t\t\toff = (short)((q->hs[0]<<8)|(q->hs[1]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LESHORT:\n\t\t\t\toff = (short)((q->hs[1]<<8)|(q->hs[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LONG:\n\t\t\t\toff = q->l;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BELONG:\n\t\t\tcase FILE_BEID3:\n\t\t\t\toff = (int32_t)((q->hl[0]<<24)|(q->hl[1]<<16)|\n\t\t\t\t\t\t (q->hl[2]<<8)|(q->hl[3]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LEID3:\n\t\t\tcase FILE_LELONG:\n\t\t\t\toff = (int32_t)((q->hl[3]<<24)|(q->hl[2]<<16)|\n\t\t\t\t\t\t (q->hl[1]<<8)|(q->hl[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_MELONG:\n\t\t\t\toff = (int32_t)((q->hl[1]<<24)|(q->hl[0]<<16)|\n\t\t\t\t\t\t (q->hl[3]<<8)|(q->hl[2]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect offs=%u\\n\", off);\n\t\t}\n\t\tswitch (in_type = cvt_flip(m->in_type, flip)) {\n\t\tcase FILE_BYTE:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 1))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->b & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->b | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->b ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->b + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->b - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->b * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->b / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->b % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->b;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BESHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hs[0] << 8) | p->hs[1];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LESHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hs[1] << 8) | p->hs[0];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->h & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->h | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->h ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->h + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->h - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->h * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->h / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->h % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p->h;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BELONG:\n\t\tcase FILE_BEID3:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hl[0] << 24) | (p->hl[1] << 16) |\n\t\t\t    (p->hl[2] << 8) | p->hl[3];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LELONG:\n\t\tcase FILE_LEID3:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hl[3] << 24) | (p->hl[2] << 16) |\n\t\t\t    (p->hl[1] << 8) | p->hl[0];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_MELONG:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hl[1] << 24) | (p->hl[0] << 16) |\n\t\t\t    (p->hl[3] << 8) | p->hl[2];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LONG:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->l & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->l | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->l ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->l + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->l - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->l * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->l / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->l % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->l;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (in_type) {\n\t\tcase FILE_LEID3:\n\t\tcase FILE_BEID3:\n\t\t\toffset = ((((offset >>  0) & 0x7f) <<  0) |\n\t\t\t\t (((offset >>  8) & 0x7f) <<  7) |\n\t\t\t\t (((offset >> 16) & 0x7f) << 14) |\n\t\t\t\t (((offset >> 24) & 0x7f) << 21)) + 10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (m->flag & INDIROFFADD) {\n\t\t\toffset += ms->c.li[cont_level-1].off;\n\t\t\tif (offset == 0) {\n\t\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t    \"indirect *zero* offset\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect +offs=%u\\n\", offset);\n\t\t}\n\t\tif (mcopy(ms, p, m->type, 0, s, offset, nbytes, m) == -1)\n\t\t\treturn -1;\n\t\tms->offset = offset;\n\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\t\tmdebug(offset, (char *)(void *)p,\n\t\t\t    sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\t\tfile_mdump(m);\n#endif\n\t\t}\n\t}\n\n\t/* Verify we have enough data to match magic type */\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\t\tif (OFFSET_OOB(nbytes, offset, 1))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_BESHORT:\n\tcase FILE_LESHORT:\n\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_BELONG:\n\tcase FILE_LELONG:\n\tcase FILE_MELONG:\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tif (OFFSET_OOB(nbytes, offset, 8))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\tcase FILE_SEARCH:\n\t\tif (OFFSET_OOB(nbytes, offset, m->vallen))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_REGEX:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\t\tif (offset == 0)\n\t\t\treturn 0;\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = ms->o.buf;\n\t\tsoffset = ms->offset;\n\t\tms->o.buf = NULL;\n\t\tms->offset = 0;\n\t\trv = file_softmagic(ms, s + offset, nbytes - offset,\n\t\t    recursion_level, BINTEST, text);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\tfprintf(stderr, \"indirect @offs=%u[%d]\\n\", offset, rv);\n\t\trbuf = ms->o.buf;\n\t\tms->o.buf = sbuf;\n\t\tms->offset = soffset;\n\t\tif (rv == 1) {\n\t\t\tif ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&\n\t\t\t    file_printf(ms, F(ms, m, \"%u\"), offset) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(rbuf);\n\t\treturn rv;\n\n\tcase FILE_USE:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = m->value.s;\n\t\tif (*sbuf == '^') {\n\t\t\tsbuf++;\n\t\t\tflip = !flip;\n\t\t}\n\t\tif (file_magicfind(ms, sbuf, &ml) == -1) {\n\t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", sbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\toneed_separator = *need_separator;\n\t\tif (m->flag & NOSPACE)\n\t\t\t*need_separator = 0;\n\t\trv = match(ms, ml.magic, ml.nmagic, s, nbytes, offset + o,\n\t\t    mode, text, flip, recursion_level, printed_something,\n\t\t    need_separator, returnval);\n\t\tif (rv != 1)\n\t\t    *need_separator = oneed_separator;\n\t\treturn rv;\n\n\tcase FILE_NAME:\n\t\tif (file_printf(ms, \"%s\", m->desc) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\tcase FILE_DEFAULT:\t/* nothing to check */\n\tcase FILE_CLEAR:\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!mconvert(ms, m, flip))\n\t\treturn 0;\n\treturn 1;\n}\n\nprivate uint64_t\nfile_strncmp(const char *s1, const char *s2, size_t len, uint32_t flags)\n{\n\t/*\n\t * Convert the source args to unsigned here so that (1) the\n\t * compare will be unsigned as it is in strncmp() and (2) so\n\t * the ctype functions will work correctly without extra\n\t * casting.\n\t */\n\tconst unsigned char *a = (const unsigned char *)s1;\n\tconst unsigned char *b = (const unsigned char *)s2;\n\tuint64_t v;\n\n\t/*\n\t * What we want here is v = strncmp(s1, s2, len),\n\t * but ignoring any nulls.\n\t */\n\tv = 0;\n\tif (0L == flags) { /* normal string: do it fast */\n\t\twhile (len-- > 0)\n\t\t\tif ((v = *b++ - *a++) != '\\0')\n\t\t\t\tbreak;\n\t}\n\telse { /* combine the others */\n\t\twhile (len-- > 0) {\n\t\t\tif ((flags & STRING_IGNORE_LOWERCASE) &&\n\t\t\t    islower(*a)) {\n\t\t\t\tif ((v = tolower(*b++) - *a++) != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ((flags & STRING_IGNORE_UPPERCASE) &&\n\t\t\t    isupper(*a)) {\n\t\t\t\tif ((v = toupper(*b++) - *a++) != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ((flags & STRING_COMPACT_WHITESPACE) &&\n\t\t\t    isspace(*a)) {\n\t\t\t\ta++;\n\t\t\t\tif (isspace(*b++)) {\n\t\t\t\t\tif (!isspace(*a))\n\t\t\t\t\t\twhile (isspace(*b))\n\t\t\t\t\t\t\tb++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ((flags & STRING_COMPACT_OPTIONAL_WHITESPACE) &&\n\t\t\t    isspace(*a)) {\n\t\t\t\ta++;\n\t\t\t\twhile (isspace(*b))\n\t\t\t\t\tb++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((v = *b++ - *a++) != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn v;\n}\n\nprivate uint64_t\nfile_strncmp16(const char *a, const char *b, size_t len, uint32_t flags)\n{\n\t/*\n\t * XXX - The 16-bit string compare probably needs to be done\n\t * differently, especially if the flags are to be supported.\n\t * At the moment, I am unsure.\n\t */\n\tflags = 0;\n\treturn file_strncmp(a, b, len, flags);\n}\n\nprivate int\nmagiccheck(struct magic_set *ms, struct magic *m)\n{\n\tuint64_t l = m->value.q;\n\tuint64_t v;\n\tfloat fl, fv;\n\tdouble dl, dv;\n\tint matched;\n\tunion VALUETYPE *p = &ms->ms_value;\n\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\t\tv = p->b;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_BESHORT:\n\tcase FILE_LESHORT:\n\t\tv = p->h;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_BELONG:\n\tcase FILE_LELONG:\n\tcase FILE_MELONG:\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\t\tv = p->l;\n\t\tbreak;\n\n\tcase FILE_QUAD:\n\tcase FILE_LEQUAD:\n\tcase FILE_BEQUAD:\n\tcase FILE_QDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_LEQDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_QWDATE:\n\tcase FILE_BEQWDATE:\n\tcase FILE_LEQWDATE:\n\t\tv = p->q;\n\t\tbreak;\n\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tfl = m->value.f;\n\t\tfv = p->f;\n\t\tswitch (m->reln) {\n\t\tcase 'x':\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\n\t\tcase '!':\n\t\t\tmatched = fv != fl;\n\t\t\tbreak;\n\n\t\tcase '=':\n\t\t\tmatched = fv == fl;\n\t\t\tbreak;\n\n\t\tcase '>':\n\t\t\tmatched = fv > fl;\n\t\t\tbreak;\n\n\t\tcase '<':\n\t\t\tmatched = fv < fl;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfile_magerror(ms, \"cannot happen with float: invalid relation `%c'\",\n\t\t\t    m->reln);\n\t\t\treturn -1;\n\t\t}\n\t\treturn matched;\n\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tdl = m->value.d;\n\t\tdv = p->d;\n\t\tswitch (m->reln) {\n\t\tcase 'x':\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\n\t\tcase '!':\n\t\t\tmatched = dv != dl;\n\t\t\tbreak;\n\n\t\tcase '=':\n\t\t\tmatched = dv == dl;\n\t\t\tbreak;\n\n\t\tcase '>':\n\t\t\tmatched = dv > dl;\n\t\t\tbreak;\n\n\t\tcase '<':\n\t\t\tmatched = dv < dl;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfile_magerror(ms, \"cannot happen with double: invalid relation `%c'\", m->reln);\n\t\t\treturn -1;\n\t\t}\n\t\treturn matched;\n\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\t\tl = 0;\n\t\tv = 0;\n\t\tbreak;\n\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\t\tl = 0;\n\t\tv = file_strncmp(m->value.s, p->s, (size_t)m->vallen, m->str_flags);\n\t\tbreak;\n\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16:\n\t\tl = 0;\n\t\tv = file_strncmp16(m->value.s, p->s, (size_t)m->vallen, m->str_flags);\n\t\tbreak;\n\n\tcase FILE_SEARCH: { /* search ms->search.s for the string m->value.s */\n\t\tsize_t slen;\n\t\tsize_t idx;\n\n\t\tif (ms->search.s == NULL)\n\t\t\treturn 0;\n\n\t\tslen = MIN(m->vallen, sizeof(m->value.s));\n\t\tl = 0;\n\t\tv = 0;\n\n\t\tfor (idx = 0; m->str_range == 0 || idx < m->str_range; idx++) {\n\t\t\tif (slen + idx > ms->search.s_len)\n\t\t\t\tbreak;\n\n\t\t\tv = file_strncmp(m->value.s, ms->search.s + idx, slen,\n\t\t\t    m->str_flags);\n\t\t\tif (v == 0) {\t/* found match */\n\t\t\t\tms->search.offset += idx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase FILE_REGEX: {\n\t\tint rc;\n\t\tfile_regex_t rx;\n\n\t\tif (ms->search.s == NULL)\n\t\t\treturn 0;\n\n\t\tl = 0;\n\t\trc = file_regcomp(&rx, m->value.s,\n\t\t    REG_EXTENDED|REG_NEWLINE|\n\t\t    ((m->str_flags & STRING_IGNORE_CASE) ? REG_ICASE : 0));\n\t\tif (rc) {\n\t\t\tfile_regerror(&rx, rc, ms);\n\t\t\tv = (uint64_t)-1;\n\t\t} else {\n\t\t\tregmatch_t pmatch[1];\n\t\t\tsize_t slen = ms->search.s_len;\n#ifndef REG_STARTEND\n#define\tREG_STARTEND\t0\n\t\t\tchar c;\n\t\t\tif (slen != 0)\n\t\t\t\tslen--;\n\t\t\tc = ms->search.s[slen];\n\t\t\t((char *)(intptr_t)ms->search.s)[slen] = '\\0';\n#else\n\t\t\tpmatch[0].rm_so = 0;\n\t\t\tpmatch[0].rm_eo = slen;\n#endif\n\t\t\trc = file_regexec(&rx, (const char *)ms->search.s,\n\t\t\t    1, pmatch, REG_STARTEND);\n#if REG_STARTEND == 0\n\t\t\t((char *)(intptr_t)ms->search.s)[l] = c;\n#endif\n\t\t\tswitch (rc) {\n\t\t\tcase 0:\n\t\t\t\tms->search.s += (int)pmatch[0].rm_so;\n\t\t\t\tms->search.offset += (size_t)pmatch[0].rm_so;\n\t\t\t\tms->search.rm_len =\n\t\t\t\t    (size_t)(pmatch[0].rm_eo - pmatch[0].rm_so);\n\t\t\t\tv = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase REG_NOMATCH:\n\t\t\t\tv = 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tfile_regerror(&rx, rc, ms);\n\t\t\t\tv = (uint64_t)-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfile_regfree(&rx);\n\t\tif (v == (uint64_t)-1)\n\t\t\treturn -1;\n\t\tbreak;\n\t}\n\tcase FILE_INDIRECT:\n\tcase FILE_USE:\n\tcase FILE_NAME:\n\t\treturn 1;\n\tdefault:\n\t\tfile_magerror(ms, \"invalid type %d in magiccheck()\", m->type);\n\t\treturn -1;\n\t}\n\n\tv = file_signextend(ms, m, v);\n\n\tswitch (m->reln) {\n\tcase 'x':\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t    \"u == *any* = 1\\n\", (unsigned long long)v);\n\t\tmatched = 1;\n\t\tbreak;\n\n\tcase '!':\n\t\tmatched = v != l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT \"u != %\"\n\t\t\t    INT64_T_FORMAT \"u = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, matched);\n\t\tbreak;\n\n\tcase '=':\n\t\tmatched = v == l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT \"u == %\"\n\t\t\t    INT64_T_FORMAT \"u = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, matched);\n\t\tbreak;\n\n\tcase '>':\n\t\tif (m->flag & UNSIGNED) {\n\t\t\tmatched = v > l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"u > %\" INT64_T_FORMAT \"u = %d\\n\",\n\t\t\t\t    (unsigned long long)v,\n\t\t\t\t    (unsigned long long)l, matched);\n\t\t}\n\t\telse {\n\t\t\tmatched = (int64_t) v > (int64_t) l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"d > %\" INT64_T_FORMAT \"d = %d\\n\",\n\t\t\t\t    (long long)v, (long long)l, matched);\n\t\t}\n\t\tbreak;\n\n\tcase '<':\n\t\tif (m->flag & UNSIGNED) {\n\t\t\tmatched = v < l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"u < %\" INT64_T_FORMAT \"u = %d\\n\",\n\t\t\t\t    (unsigned long long)v,\n\t\t\t\t    (unsigned long long)l, matched);\n\t\t}\n\t\telse {\n\t\t\tmatched = (int64_t) v < (int64_t) l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"d < %\" INT64_T_FORMAT \"d = %d\\n\",\n\t\t\t\t     (long long)v, (long long)l, matched);\n\t\t}\n\t\tbreak;\n\n\tcase '&':\n\t\tmatched = (v & l) == l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"((%\" INT64_T_FORMAT \"x & %\"\n\t\t\t    INT64_T_FORMAT \"x) == %\" INT64_T_FORMAT\n\t\t\t    \"x) = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, (unsigned long long)l,\n\t\t\t    matched);\n\t\tbreak;\n\n\tcase '^':\n\t\tmatched = (v & l) != l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"((%\" INT64_T_FORMAT \"x & %\"\n\t\t\t    INT64_T_FORMAT \"x) != %\" INT64_T_FORMAT\n\t\t\t    \"x) = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, (unsigned long long)l,\n\t\t\t    matched);\n\t\tbreak;\n\n\tdefault:\n\t\tfile_magerror(ms, \"cannot happen: invalid relation `%c'\",\n\t\t    m->reln);\n\t\treturn -1;\n\t}\n\n\treturn matched;\n}\n\nprivate int\nhandle_annotation(struct magic_set *ms, struct magic *m)\n{\n\tif (ms->flags & MAGIC_APPLE) {\n\t\tif (file_printf(ms, \"%.8s\", m->apple) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\t}\n\tif ((ms->flags & MAGIC_MIME_TYPE) && m->mimetype[0]) {\n\t\tif (file_printf(ms, \"%s\", m->mimetype) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nprivate int\nprint_sep(struct magic_set *ms, int firstline)\n{\n\tif (ms->flags & MAGIC_MIME)\n\t\treturn 0;\n\tif (firstline)\n\t\treturn 0;\n\t/*\n\t * we found another match\n\t * put a newline and '-' to do some simple formatting\n\t */\n\treturn file_printf(ms, \"\\n- \");\n}\n"], "filenames": ["src/softmagic.c"], "buggy_code_start_loc": [35], "buggy_code_end_loc": [947], "fixing_code_start_loc": [35], "fixing_code_end_loc": [955], "type": "CWE-119", "message": "Buffer overflow in the mconvert function in softmagic.c in file before 5.19, as used in the Fileinfo component in PHP before 5.4.30 and 5.5.x before 5.5.14, allows remote attackers to cause a denial of service (application crash) via a crafted Pascal string in a FILE_PSTRING conversion.", "other": {"cve": {"id": "CVE-2014-3478", "sourceIdentifier": "secalert@redhat.com", "published": "2014-07-09T11:07:01.587", "lastModified": "2016-11-28T19:11:29.920", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Buffer overflow in the mconvert function in softmagic.c in file before 5.19, as used in the Fileinfo component in PHP before 5.4.30 and 5.5.x before 5.5.14, allows remote attackers to cause a denial of service (application crash) via a crafted Pascal string in a FILE_PSTRING conversion."}, {"lang": "es", "value": "Desbordamiento de buffer en la funci\u00f3n mconvert en softmagic.c en file anterior a 5.19, utilizado en el componente Fileinfo en PHP anterior a 5.4.30 y 5.5.x anterior a 5.5.14, permite a atacantes remotos causar una denegaci\u00f3n de servicio (ca\u00edda de aplicaci\u00f3n) a trav\u00e9s de una cadena Pascal manipulada en una conversi\u00f3n FILE_PSTRING."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.18", "matchCriteriaId": "FCDEA321-FC13-42AE-9250-0C6055D9B280"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.00:*:*:*:*:*:*:*", "matchCriteriaId": "F6FF256D-3DD4-41A8-B119-D20A493A6EA5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.01:*:*:*:*:*:*:*", "matchCriteriaId": "F1981126-D773-49B6-BD3D-F17BC37352CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.02:*:*:*:*:*:*:*", "matchCriteriaId": "00EF31A2-E788-4111-8C46-DB6C8F8724C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.03:*:*:*:*:*:*:*", "matchCriteriaId": "1587EAB1-5322-4264-A7E5-D70DA68F6B80"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.04:*:*:*:*:*:*:*", "matchCriteriaId": "DC514A20-168F-4653-8BBA-D068ACA3D2E8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.05:*:*:*:*:*:*:*", "matchCriteriaId": "DE0F4E1A-EA88-4858-9431-E82B2D415FB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.06:*:*:*:*:*:*:*", "matchCriteriaId": "F7D0625D-452F-4CE1-9A5F-6439AB6DE981"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.07:*:*:*:*:*:*:*", "matchCriteriaId": "ECBFF148-DEAA-4D7C-9CFC-556FEADAB619"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.08:*:*:*:*:*:*:*", "matchCriteriaId": "C99F7C59-F1C5-4202-A86F-90173D0FCF62"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.09:*:*:*:*:*:*:*", "matchCriteriaId": "D0AA7E7E-60C1-40BD-AD21-5FDD92485FD2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.10:*:*:*:*:*:*:*", "matchCriteriaId": "CA4DBB2C-5C87-42C8-BA3D-FF852C467013"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.11:*:*:*:*:*:*:*", "matchCriteriaId": "B513E684-36C2-45D7-A166-3B42018AB79C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.12:*:*:*:*:*:*:*", "matchCriteriaId": "5BBA4D40-EE73-4F38-ABA6-3840A67F097F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.13:*:*:*:*:*:*:*", "matchCriteriaId": "8A647100-18D6-4741-B147-BBA95215BF2E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.14:*:*:*:*:*:*:*", "matchCriteriaId": "A6A554A0-AA80-419E-AEBD-6E659300316C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.15:*:*:*:*:*:*:*", "matchCriteriaId": "91B2F536-84E5-44A6-B515-2BD68E9906B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.16:*:*:*:*:*:*:*", "matchCriteriaId": "3814C047-D9FF-44E6-94FE-29B3B0F9F53A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.17:*:*:*:*:*:*:*", "matchCriteriaId": "B56BEB99-306B-438A-81E4-212AF53D0719"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.4.29", "matchCriteriaId": "1055C4A6-94BE-40CB-BAB4-39C08F5A7F8C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "E7B9B8D2-78B7-4B17-955B-741C7A6F6634"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "5CA2A940-BD69-4D35-AF12-432CB929248B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "29BD13F9-86C8-44C4-A860-9A87870A518E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "1B361FDE-9F6A-4E9A-96F1-619DC56EECB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "3DBD9E7B-1237-47A8-8A07-5CC5246A9C5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "6F2BB41E-2096-4291-B0ED-06825FDFE8BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "52BA94F7-1AF9-415C-AC21-30BC25C74C5D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "D0A739A0-698A-422B-886B-430A79F6E945"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "086E0D24-A43E-4CEA-9FB0-FE193B88CC31"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "EC8D0963-8CA5-4814-9B6D-4E1C3907737B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "77A4B7E0-C872-4E53-AD72-1BB2755E4FDA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "EECCD553-53D5-485E-8C21-E2A5070833B2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "95357C79-A754-4E0C-B65B-0FA241962B12"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.12:rc1:*:*:*:*:*:*", "matchCriteriaId": "25EAF9A9-F7A1-4AC7-BCFD-769BE0FDB537"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.12:rc2:*:*:*:*:*:*", "matchCriteriaId": "74EA8037-7C22-48B3-9FA2-4BFFFFD513D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "C8D1254E-0C72-4958-BA7F-5B818C3ACB15"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.13:rc1:*:*:*:*:*:*", "matchCriteriaId": "92994FFC-F362-48AC-9CA8-8EBCAC880C91"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.14:*:*:*:*:*:*:*", "matchCriteriaId": "21131DF1-1EE5-4C84-B1E0-FA75BC39B344"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.14:rc1:*:*:*:*:*:*", "matchCriteriaId": "0B23F85D-465B-4176-9798-E78AADE421EC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.15:rc1:*:*:*:*:*:*", "matchCriteriaId": "ADEE52B4-8392-4321-8C00-FABA6270E728"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.16:rc1:*:*:*:*:*:*", "matchCriteriaId": "57D74F58-DB3A-4A70-93CF-B350DB65EF49"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.17:*:*:*:*:*:*:*", "matchCriteriaId": "AAEE86A0-C3FC-446E-8DF0-4FA32F741E1B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.18:*:*:*:*:*:*:*", "matchCriteriaId": "90B670B6-A211-40C6-A8A0-1B0188EF891F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.19:*:*:*:*:*:*:*", "matchCriteriaId": "AAAC4776-F3FF-42D8-AC6E-4746987D30BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.20:*:*:*:*:*:*:*", "matchCriteriaId": "41DC16B7-7A45-4BDE-B340-F17D97CA3BDD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.21:*:*:*:*:*:*:*", "matchCriteriaId": "0FD7C2E6-9B34-4890-A0D1-39BB8ECA47E4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.22:*:*:*:*:*:*:*", "matchCriteriaId": "4F8F72EC-7431-4B36-89EF-E7593ACFBFEA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.23:*:*:*:*:*:*:*", "matchCriteriaId": "86E9AC84-430D-4FDA-8FFE-B77E17803A11"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.24:*:*:*:*:*:*:*", "matchCriteriaId": "5238A7AE-D3FD-4465-95D7-F9C8787F9463"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.25:*:*:*:*:*:*:*", "matchCriteriaId": "6B877725-43E7-479E-9FA3-6D2FFE89B620"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.26:*:*:*:*:*:*:*", "matchCriteriaId": "AB33BBC0-9D17-4369-A52D-B4B65150380A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.27:*:*:*:*:*:*:*", "matchCriteriaId": "95E112B5-12CC-40D5-AA1E-B5FB1ABC831E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.4.28:*:*:*:*:*:*:*", "matchCriteriaId": "B078B1E5-14BD-4004-8384-4656E1063EC0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "9F6D9B19-E64D-4BED-9194-17460CE19E6F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:alpha1:*:*:*:*:*:*", "matchCriteriaId": "3D25E591-448C-4E3B-8557-6E48F7571796"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:alpha2:*:*:*:*:*:*", "matchCriteriaId": "6DA18F3F-B4B5-40C3-BF19-67C1F0C1787D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:alpha3:*:*:*:*:*:*", "matchCriteriaId": "3AF783C9-26E7-4E02-BD41-77B9783667E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:alpha4:*:*:*:*:*:*", "matchCriteriaId": "EF49701D-ECE4-4CEB-BDAB-24C09C8AD4B4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:alpha5:*:*:*:*:*:*", "matchCriteriaId": "7AEDF6F7-001D-4A35-A26F-417991AD377F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:alpha6:*:*:*:*:*:*", "matchCriteriaId": "4031DB99-B4B4-41EC-B3C1-543D92C575A9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "D5450EA7-A398-49D2-AA8E-7C95B074BAB1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "04FE0E4E-BC94-4DC9-BE9B-DC57B952B2FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "BB8E09D8-9CBE-4279-88B7-24A214A5A537"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "2D41ECCE-887D-49A2-9BB3-B559495AC55B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "79B418BC-27F4-4443-A0F7-FF4ADA568C1B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "8EEBDF62-BA1B-4438-9AEA-8B56AA5713E8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "F644EA6C-50C6-4A1C-A4AC-287AA9477B46"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "4DD47F30-74F5-48E8-8657-C2373FE2BD22"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "0C09527B-6B47-41F8-BDE6-01C47E452286"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "2E454D87-23CB-4D7F-90FE-942EE54D661F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "1031E646-F2CF-4A3E-8E6A-5D4BC950BEDA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "130E50C1-D209-4CFF-9399-69D561340FBB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "C1F29948-9417-460B-8B04-D91AE4E8B423"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.8:*:*:*:*:*:*:*", "matchCriteriaId": "A37D00C1-4F41-4400-9CE4-8E8BAA3E4142"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.9:*:*:*:*:*:*:*", "matchCriteriaId": "093D08B7-CC3C-4616-8697-F15B253A7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.10:*:*:*:*:*:*:*", "matchCriteriaId": "E9CD8FEE-DE7B-47CB-9985-4092BFA071D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.11:*:*:*:*:*:*:*", "matchCriteriaId": "A30B2D9E-F289-43C9-BFBC-1CEF284A417E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.12:*:*:*:*:*:*:*", "matchCriteriaId": "FE41CFDF-8ECD-41C1-94A7-5AFD42C5DDEA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.5.13:*:*:*:*:*:*:*", "matchCriteriaId": "6AEAC9BA-AF82-4345-839C-D339DCB962A7"}]}]}], "references": [{"url": "http://lists.apple.com/archives/security-announce/2015/Apr/msg00001.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-updates/2014-09/msg00046.html", "source": "secalert@redhat.com"}, {"url": "http://marc.info/?l=bugtraq&m=141017844705317&w=2", "source": "secalert@redhat.com"}, {"url": "http://mx.gw.com/pipermail/file/2014/001553.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-1327.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-1765.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-1766.html", "source": "secalert@redhat.com"}, {"url": "http://support.apple.com/kb/HT6443", "source": "secalert@redhat.com"}, {"url": "http://www.debian.org/security/2014/dsa-2974", "source": "secalert@redhat.com"}, {"url": "http://www.debian.org/security/2014/dsa-3021", "source": "secalert@redhat.com"}, {"url": "http://www.oracle.com/technetwork/topics/security/bulletinjan2015-2370101.html", "source": "secalert@redhat.com"}, {"url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinoct2015-2719645.html", "source": "secalert@redhat.com"}, {"url": "http://www.php.net/ChangeLog-5.php", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/68239", "source": "secalert@redhat.com"}, {"url": "https://bugs.php.net/bug.php?id=67410", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://github.com/file/file/commit/27a14bc7ba285a0a5ebfdb55e54001aa11932b08", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://support.apple.com/HT204659", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/file/file/commit/27a14bc7ba285a0a5ebfdb55e54001aa11932b08"}}