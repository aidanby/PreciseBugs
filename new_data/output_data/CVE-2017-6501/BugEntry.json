{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            X   X   CCCC  FFFFF                              %\n%                             X X   C      F                                  %\n%                              X    C      FFF                                %\n%                             X X   C      F                                  %\n%                            X   X   CCCC  F                                  %\n%                                                                             %\n%                                                                             %\n%                        Read GIMP XCF Image Format                           %\n%                                                                             %\n%                              Software Design                                %\n%                              Leonard Rosenthol                              %\n%                               November 2001                                 %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/color.h\"\n#include \"magick/composite.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/pixel.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/property.h\"\n#include \"magick/quantize.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/static.h\"\n#include \"magick/string_.h\"\n#include \"magick/module.h\"\n\f\n/*\n  Typedef declarations.\n*/\ntypedef enum\n{\n  GIMP_RGB,\n  GIMP_GRAY,\n  GIMP_INDEXED\n} GimpImageBaseType;\n\ntypedef enum\n{\n  PROP_END                   =  0,\n  PROP_COLORMAP              =  1,\n  PROP_ACTIVE_LAYER          =  2,\n  PROP_ACTIVE_CHANNEL        =  3,\n  PROP_SELECTION             =  4,\n  PROP_FLOATING_SELECTION    =  5,\n  PROP_OPACITY               =  6,\n  PROP_MODE                  =  7,\n  PROP_VISIBLE               =  8,\n  PROP_LINKED                =  9,\n  PROP_PRESERVE_TRANSPARENCY = 10,\n  PROP_APPLY_MASK            = 11,\n  PROP_EDIT_MASK             = 12,\n  PROP_SHOW_MASK             = 13,\n  PROP_SHOW_MASKED           = 14,\n  PROP_OFFSETS               = 15,\n  PROP_COLOR                 = 16,\n  PROP_COMPRESSION           = 17,\n  PROP_GUIDES                = 18,\n  PROP_RESOLUTION            = 19,\n  PROP_TATTOO                = 20,\n  PROP_PARASITES             = 21,\n  PROP_UNIT                  = 22,\n  PROP_PATHS                 = 23,\n  PROP_USER_UNIT             = 24\n} PropType;\n\ntypedef enum\n{\n  COMPRESS_NONE              =  0,\n  COMPRESS_RLE               =  1,\n  COMPRESS_ZLIB              =  2,  /* unused */\n  COMPRESS_FRACTAL           =  3   /* unused */\n} XcfCompressionType;\n\ntypedef struct\n{\n  size_t\n    width,\n    height,\n    image_type,\n    bytes_per_pixel;\n\n  int\n    compression;\n\n  size_t\n    file_size;\n\n  size_t\n    number_layers;\n\n  ExceptionInfo\n    *exception;\n} XCFDocInfo;\n\ntypedef struct\n{\n  char\n    name[1024];\n\n  unsigned int\n    active;\n\n  size_t\n    width,\n    height,\n    type,\n    alpha,\n    visible,\n    linked,\n    preserve_trans,\n    apply_mask,\n    show_mask,\n    edit_mask,\n    floating_offset;\n\n  ssize_t\n    offset_x,\n    offset_y;\n\n  size_t\n    mode,\n    tattoo;\n\n  Image\n    *image;\n} XCFLayerInfo;\n\n#define TILE_WIDTH   64\n#define TILE_HEIGHT  64\n\ntypedef struct\n{\n  unsigned char\n    red,\n    green,\n    blue,\n    alpha;\n} XCFPixelPacket;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s X C F                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsXCF() returns MagickTrue if the image format type, identified by the\n%  magick string, is XCF (GIMP native format).\n%\n%  The format of the IsXCF method is:\n%\n%      MagickBooleanType IsXCF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n%\n*/\nstatic MagickBooleanType IsXCF(const unsigned char *magick,const size_t length)\n{\n  if (length < 8)\n    return(MagickFalse);\n  if (LocaleNCompare((char *) magick,\"gimp xcf\",8) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\ntypedef enum\n{\n  GIMP_NORMAL_MODE,\n  GIMP_DISSOLVE_MODE,\n  GIMP_BEHIND_MODE,\n  GIMP_MULTIPLY_MODE,\n  GIMP_SCREEN_MODE,\n  GIMP_OVERLAY_MODE,\n  GIMP_DIFFERENCE_MODE,\n  GIMP_ADDITION_MODE,\n  GIMP_SUBTRACT_MODE,\n  GIMP_DARKEN_ONLY_MODE,\n  GIMP_LIGHTEN_ONLY_MODE,\n  GIMP_HUE_MODE,\n  GIMP_SATURATION_MODE,\n  GIMP_COLOR_MODE,\n  GIMP_VALUE_MODE,\n  GIMP_DIVIDE_MODE,\n  GIMP_DODGE_MODE,\n  GIMP_BURN_MODE,\n  GIMP_HARDLIGHT_MODE\n} GimpLayerModeEffects;\n\n/*\n  Simple utility routine to convert between PSD blending modes and\n  ImageMagick compositing operators\n*/\nstatic CompositeOperator GIMPBlendModeToCompositeOperator(\n  size_t blendMode)\n{\n  switch ( blendMode )\n  {\n    case GIMP_NORMAL_MODE:       return(OverCompositeOp);\n    case GIMP_DISSOLVE_MODE:     return(DissolveCompositeOp);\n    case GIMP_MULTIPLY_MODE:     return(MultiplyCompositeOp);\n    case GIMP_SCREEN_MODE:       return(ScreenCompositeOp);\n    case GIMP_OVERLAY_MODE:      return(OverlayCompositeOp);\n    case GIMP_DIFFERENCE_MODE:   return(DifferenceCompositeOp);\n    case GIMP_ADDITION_MODE:     return(AddCompositeOp);\n    case GIMP_SUBTRACT_MODE:     return(SubtractCompositeOp);\n    case GIMP_DARKEN_ONLY_MODE:  return(DarkenCompositeOp);\n    case GIMP_LIGHTEN_ONLY_MODE: return(LightenCompositeOp);\n    case GIMP_HUE_MODE:          return(HueCompositeOp);\n    case GIMP_SATURATION_MODE:   return(SaturateCompositeOp);\n    case GIMP_COLOR_MODE:        return(ColorizeCompositeOp);\n    case GIMP_DODGE_MODE:        return(ColorDodgeCompositeOp);\n    case GIMP_BURN_MODE:         return(ColorBurnCompositeOp);\n    case GIMP_HARDLIGHT_MODE:    return(HardLightCompositeOp);\n    case GIMP_DIVIDE_MODE:       return(DivideCompositeOp);\n    /* these are the ones we don't support...yet */\n    case GIMP_BEHIND_MODE:       return(OverCompositeOp);\n    case GIMP_VALUE_MODE:        return(OverCompositeOp);\n    default:                     return(OverCompositeOp);\n  }\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e a d B l o b S t r i n g W i t h L o n g S i z e                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobStringWithLongSize reads characters from a blob or file\n%  starting with a ssize_t length byte and then characters to that length\n%\n%  The format of the ReadBlobStringWithLongSize method is:\n%\n%      char *ReadBlobStringWithLongSize(Image *image,char *string)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o string: the address of a character buffer.\n%\n*/\n\nstatic char *ReadBlobStringWithLongSize(Image *image,char *string,size_t max)\n{\n  int\n    c;\n\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(max != 0);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  length=ReadBlobMSBLong(image);\n  for (i=0; i < (ssize_t) MagickMin(length,max-1); i++)\n  {\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      return((char *) NULL);\n    string[i]=(char) c;\n  }\n  string[i]='\\0';\n  offset=SeekBlob(image,(MagickOffsetType) (length-i),SEEK_CUR);\n  if (offset < 0)\n    (void) ThrowMagickException(&image->exception,GetMagickModule(),\n      CorruptImageError,\"ImproperImageHeader\",\"`%s'\",image->filename);\n  return(string);\n}\n\nstatic MagickBooleanType load_tile(Image *image,Image *tile_image,\n  XCFDocInfo *inDocInfo,XCFLayerInfo *inLayerInfo,size_t data_length)\n{\n  ExceptionInfo\n    *exception;\n\n  ssize_t\n    y;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  size_t\n    extent;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *graydata;\n\n  XCFPixelPacket\n    *xcfdata,\n    *xcfodata;\n\n  extent=0;\n  if (inDocInfo->image_type == GIMP_GRAY)\n    extent=tile_image->columns*tile_image->rows*sizeof(*graydata);\n  else\n    if (inDocInfo->image_type == GIMP_RGB)\n      extent=tile_image->columns*tile_image->rows*sizeof(*xcfdata);\n  if (extent > data_length)\n    ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n      image->filename);\n  xcfdata=(XCFPixelPacket *) AcquireQuantumMemory(MagickMax(data_length,\n    tile_image->columns*tile_image->rows),sizeof(*xcfdata));\n  if (xcfdata == (XCFPixelPacket *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  xcfodata=xcfdata;\n  graydata=(unsigned char *) xcfdata;  /* used by gray and indexed */\n  count=ReadBlob(image,data_length,(unsigned char *) xcfdata);\n  if (count != (ssize_t) data_length)\n    ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n      image->filename);\n  exception=(&image->exception);\n  for (y=0; y < (ssize_t) tile_image->rows; y++)\n  {\n    q=GetAuthenticPixels(tile_image,0,y,tile_image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    if (inDocInfo->image_type == GIMP_GRAY)\n      {\n        for (x=0; x < (ssize_t) tile_image->columns; x++)\n        {\n          SetPixelRed(q,ScaleCharToQuantum(*graydata));\n          SetPixelGreen(q,GetPixelRed(q));\n          SetPixelBlue(q,GetPixelRed(q));\n          SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n            inLayerInfo->alpha));\n          graydata++;\n          q++;\n        }\n      }\n    else\n      if (inDocInfo->image_type == GIMP_RGB)\n        {\n          for (x=0; x < (ssize_t) tile_image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum(xcfdata->red));\n            SetPixelGreen(q,ScaleCharToQuantum(xcfdata->green));\n            SetPixelBlue(q,ScaleCharToQuantum(xcfdata->blue));\n            SetPixelAlpha(q,xcfdata->alpha == 255U ? TransparentOpacity :\n              ScaleCharToQuantum((unsigned char) inLayerInfo->alpha));\n            xcfdata++;\n            q++;\n          }\n        }\n     if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n       break;\n  }\n  xcfodata=(XCFPixelPacket *) RelinquishMagickMemory(xcfodata);\n  return MagickTrue;\n}\n\nstatic MagickBooleanType load_tile_rle(Image *image,Image *tile_image,\n  XCFDocInfo *inDocInfo,XCFLayerInfo *inLayerInfo,size_t data_length)\n{\n  ExceptionInfo\n    *exception;\n\n  MagickOffsetType\n    size;\n\n  Quantum\n    alpha;\n\n  register PixelPacket\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    bytes_per_pixel,\n    count,\n    i,\n    j;\n\n  unsigned char\n    data,\n    pixel,\n    *xcfdata,\n    *xcfodata,\n    *xcfdatalimit;\n\n  bytes_per_pixel=(ssize_t) inDocInfo->bytes_per_pixel;\n  xcfdata=(unsigned char *) AcquireQuantumMemory(data_length,sizeof(*xcfdata));\n  if (xcfdata == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  xcfodata=xcfdata;\n  count=ReadBlob(image, (size_t) data_length, xcfdata);\n  xcfdatalimit = xcfodata+count-1;\n  exception=(&image->exception);\n  alpha=ScaleCharToQuantum((unsigned char) inLayerInfo->alpha);\n  for (i=0; i < (ssize_t) bytes_per_pixel; i++)\n  {\n    q=GetAuthenticPixels(tile_image,0,0,tile_image->columns,tile_image->rows,\n      exception);\n    if (q == (PixelPacket *) NULL)\n      continue;\n    size=(MagickOffsetType) tile_image->rows*tile_image->columns;\n    while (size > 0)\n    {\n      if (xcfdata > xcfdatalimit)\n        goto bogus_rle;\n      pixel=(*xcfdata++);\n      length=(size_t) pixel;\n      if (length >= 128)\n        {\n          length=255-(length-1);\n          if (length == 128)\n            {\n              if (xcfdata >= xcfdatalimit)\n                goto bogus_rle;\n              length=(size_t) ((*xcfdata << 8) + xcfdata[1]);\n              xcfdata+=2;\n            }\n          size-=length;\n          if (size < 0)\n            goto bogus_rle;\n          if (&xcfdata[length-1] > xcfdatalimit)\n            goto bogus_rle;\n          while (length-- > 0)\n          {\n            data=(*xcfdata++);\n            switch (i)\n            {\n              case 0:\n              {\n                SetPixelRed(q,ScaleCharToQuantum(data));\n                if (inDocInfo->image_type == GIMP_GRAY)\n                  {\n                    SetPixelGreen(q,ScaleCharToQuantum(data));\n                    SetPixelBlue(q,ScaleCharToQuantum(data));\n                  }\n                else\n                  {\n                    SetPixelGreen(q,GetPixelRed(q));\n                    SetPixelBlue(q,GetPixelRed(q));\n                  }\n                SetPixelAlpha(q,alpha);\n                break;\n              }\n              case 1:\n              {\n                if (inDocInfo->image_type == GIMP_GRAY)\n                  SetPixelAlpha(q,ScaleCharToQuantum(data));\n                else\n                  SetPixelGreen(q,ScaleCharToQuantum(data));\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(q,ScaleCharToQuantum(data));\n                break;\n              }\n              case 3:\n              {\n                SetPixelAlpha(q,ScaleCharToQuantum(data));\n                break;\n              }\n            }\n            q++;\n          }\n        }\n      else\n        {\n          length+=1;\n          if (length == 128)\n            {\n              if (xcfdata >= xcfdatalimit)\n                goto bogus_rle;\n              length=(size_t) ((*xcfdata << 8) + xcfdata[1]);\n              xcfdata+=2;\n            }\n          size-=length;\n          if (size < 0)\n            goto bogus_rle;\n          if (xcfdata > xcfdatalimit)\n            goto bogus_rle;\n          pixel=(*xcfdata++);\n          for (j=0; j < (ssize_t) length; j++)\n          {\n            data=pixel;\n            switch (i)\n            {\n              case 0:\n              {\n                SetPixelRed(q,ScaleCharToQuantum(data));\n                if (inDocInfo->image_type == GIMP_GRAY)\n                  {\n                    SetPixelGreen(q,ScaleCharToQuantum(data));\n                    SetPixelBlue(q,ScaleCharToQuantum(data));\n                  }\n                else\n                  {\n                    SetPixelGreen(q,GetPixelRed(q));\n                    SetPixelBlue(q,GetPixelRed(q));\n                  }\n                SetPixelAlpha(q,alpha);\n                break;\n              }\n              case 1:\n              {\n                if (inDocInfo->image_type == GIMP_GRAY)\n                  SetPixelAlpha(q,ScaleCharToQuantum(data));\n                else\n                  SetPixelGreen(q,ScaleCharToQuantum(data));\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(q,ScaleCharToQuantum(data));\n                break;\n              }\n              case 3:\n              {\n                SetPixelAlpha(q,ScaleCharToQuantum(data));\n                break;\n              }\n            }\n            q++;\n          }\n        }\n    }\n    if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n      break;\n  }\n  xcfodata=(unsigned char *) RelinquishMagickMemory(xcfodata);\n  return(MagickTrue);\n\n  bogus_rle:\n    if (xcfodata != (unsigned char *) NULL)\n      xcfodata=(unsigned char *) RelinquishMagickMemory(xcfodata);\n  return(MagickFalse);\n}\n\nstatic MagickBooleanType load_level(Image *image,XCFDocInfo *inDocInfo,\n  XCFLayerInfo *inLayerInfo)\n{\n  ExceptionInfo\n    *exception;\n\n  int\n    destLeft = 0,\n    destTop = 0;\n\n  Image*\n    tile_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    saved_pos,\n    offset,\n    offset2;\n\n  register ssize_t\n    i;\n\n  size_t\n    width,\n    height,\n    ntiles,\n    ntile_rows,\n    ntile_cols,\n    tile_image_width,\n    tile_image_height;\n\n  /* start reading the data */\n  exception=inDocInfo->exception;\n  width=ReadBlobMSBLong(image);\n  height=ReadBlobMSBLong(image);\n\n  /*\n    Read in the first tile offset.  If it is '0', then this tile level is empty\n    and we can simply return.\n  */\n  offset=(MagickOffsetType) ReadBlobMSBLong(image);\n  if (offset == 0)\n    return(MagickTrue);\n  /*\n    Initialize the reference for the in-memory tile-compression.\n  */\n  ntile_rows=(height+TILE_HEIGHT-1)/TILE_HEIGHT;\n  ntile_cols=(width+TILE_WIDTH-1)/TILE_WIDTH;\n  ntiles=ntile_rows*ntile_cols;\n  for (i = 0; i < (ssize_t) ntiles; i++)\n  {\n    status=MagickFalse;\n    if (offset == 0)\n      ThrowBinaryException(CorruptImageError,\"NotEnoughTiles\",image->filename);\n    /* save the current position as it is where the\n     *  next tile offset is stored.\n     */\n    saved_pos=TellBlob(image);\n    /* read in the offset of the next tile so we can calculate the amount\n       of data needed for this tile*/\n    offset2=(MagickOffsetType)ReadBlobMSBLong(image);\n    /* if the offset is 0 then we need to read in the maximum possible\n       allowing for negative compression */\n    if (offset2 == 0)\n      offset2=(MagickOffsetType) (offset + TILE_WIDTH * TILE_WIDTH * 4* 1.5);\n    /* seek to the tile offset */\n    if (SeekBlob(image, offset, SEEK_SET) != offset)\n      ThrowBinaryException(CorruptImageError,\"InsufficientImageDataInFile\",\n        image->filename);\n\n      /* allocate the image for the tile\n        NOTE: the last tile in a row or column may not be a full tile!\n      */\n      tile_image_width=(size_t) (destLeft == (int) ntile_cols-1 ?\n        (int) width % TILE_WIDTH : TILE_WIDTH);\n      if (tile_image_width == 0)\n        tile_image_width=TILE_WIDTH;\n      tile_image_height = (size_t) (destTop == (int) ntile_rows-1 ?\n        (int) height % TILE_HEIGHT : TILE_HEIGHT);\n      if (tile_image_height == 0)\n        tile_image_height=TILE_HEIGHT;\n      tile_image=CloneImage(inLayerInfo->image,tile_image_width,\n        tile_image_height,MagickTrue,exception);\n\n      /* read in the tile */\n      switch (inDocInfo->compression)\n      {\n        case COMPRESS_NONE:\n          if (load_tile(image,tile_image,inDocInfo,inLayerInfo,(size_t) (offset2-offset)) == 0)\n            status=MagickTrue;\n          break;\n        case COMPRESS_RLE:\n          if (load_tile_rle (image,tile_image,inDocInfo,inLayerInfo,\n              (int) (offset2-offset)) == 0)\n            status=MagickTrue;\n          break;\n        case COMPRESS_ZLIB:\n          ThrowBinaryException(CoderError,\"ZipCompressNotSupported\",\n            image->filename)\n        case COMPRESS_FRACTAL:\n          ThrowBinaryException(CoderError,\"FractalCompressNotSupported\",\n            image->filename)\n      }\n\n      /* composite the tile onto the layer's image, and then destroy it */\n      (void) CompositeImage(inLayerInfo->image,CopyCompositeOp,tile_image,\n        destLeft * TILE_WIDTH,destTop*TILE_HEIGHT);\n      tile_image=DestroyImage(tile_image);\n\n      /* adjust tile position */\n      destLeft++;\n      if (destLeft >= (int) ntile_cols)\n        {\n          destLeft = 0;\n          destTop++;\n        }\n      if (status != MagickFalse)\n        return(MagickFalse);\n      /* restore the saved position so we'll be ready to\n       *  read the next offset.\n       */\n      offset=SeekBlob(image, saved_pos, SEEK_SET);\n      /* read in the offset of the next tile */\n      offset=(MagickOffsetType) ReadBlobMSBLong(image);\n    }\n  if (offset != 0)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename)\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType load_hierarchy(Image *image,XCFDocInfo *inDocInfo,\n   XCFLayerInfo *inLayer)\n{\n  MagickOffsetType\n    saved_pos,\n    offset,\n    junk;\n\n  size_t\n    width,\n    height,\n    bytes_per_pixel;\n\n  width=ReadBlobMSBLong(image);\n  (void) width;\n  height=ReadBlobMSBLong(image);\n  (void) height;\n  bytes_per_pixel=inDocInfo->bytes_per_pixel=ReadBlobMSBLong(image);\n  (void) bytes_per_pixel;\n\n  /* load in the levels...we make sure that the number of levels\n   *  calculated when the TileManager was created is the same\n   *  as the number of levels found in the file.\n   */\n  offset=(MagickOffsetType) ReadBlobMSBLong(image);  /* top level */\n\n  /* discard offsets for layers below first, if any.\n   */\n  do\n  {\n    junk=(MagickOffsetType) ReadBlobMSBLong(image);\n  }\n  while (junk != 0);\n\n  /* save the current position as it is where the\n   *  next level offset is stored.\n   */\n  saved_pos=TellBlob(image);\n\n  /* seek to the level offset */\n  if (SeekBlob(image, offset, SEEK_SET) != offset)\n    ThrowBinaryException(CorruptImageError,\"InsufficientImageDataInFile\",\n      image->filename);\n\n  /* read in the level */\n  if (load_level (image, inDocInfo, inLayer) == 0)\n    return(MagickFalse);\n  /* restore the saved position so we'll be ready to\n   *  read the next offset.\n   */\n  offset=SeekBlob(image, saved_pos, SEEK_SET);\n  return(MagickTrue);\n}\n\nstatic void InitXCFImage(XCFLayerInfo *outLayer)\n{\n  outLayer->image->page.x=outLayer->offset_x;\n  outLayer->image->page.y=outLayer->offset_y;\n  outLayer->image->page.width=outLayer->width;\n  outLayer->image->page.height=outLayer->height;\n  (void) SetImageProperty(outLayer->image,\"label\",(char *)outLayer->name);\n}\n\nstatic MagickBooleanType ReadOneLayer(const ImageInfo *image_info,Image* image,\n  XCFDocInfo* inDocInfo,XCFLayerInfo *outLayer,const ssize_t layer)\n{\n  MagickOffsetType\n    offset;\n\n  unsigned int\n    foundPropEnd = 0;\n\n  size_t\n    hierarchy_offset,\n    layer_mask_offset;\n\n  /* clear the block! */\n  (void) ResetMagickMemory( outLayer, 0, sizeof( XCFLayerInfo ) );\n  /* read in the layer width, height, type and name */\n  outLayer->width = ReadBlobMSBLong(image);\n  outLayer->height = ReadBlobMSBLong(image);\n  outLayer->type = ReadBlobMSBLong(image);\n  (void) ReadBlobStringWithLongSize(image, outLayer->name,\n    sizeof(outLayer->name));\n  if (EOFBlob(image) != MagickFalse)\n    ThrowBinaryException(CorruptImageError,\"InsufficientImageDataInFile\",\n      image->filename);\n  /* read the layer properties! */\n  foundPropEnd = 0;\n  while ( (foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse) ) {\n  PropType    prop_type = (PropType) ReadBlobMSBLong(image);\n  size_t  prop_size = ReadBlobMSBLong(image);\n    switch (prop_type)\n    {\n    case PROP_END:\n      foundPropEnd = 1;\n      break;\n    case PROP_ACTIVE_LAYER:\n      outLayer->active = 1;\n      break;\n    case PROP_FLOATING_SELECTION:\n      outLayer->floating_offset = ReadBlobMSBLong(image);\n      break;\n    case PROP_OPACITY:\n      outLayer->alpha = ReadBlobMSBLong(image);\n      break;\n    case PROP_VISIBLE:\n      outLayer->visible = ReadBlobMSBLong(image);\n      break;\n    case PROP_LINKED:\n      outLayer->linked = ReadBlobMSBLong(image);\n      break;\n    case PROP_PRESERVE_TRANSPARENCY:\n      outLayer->preserve_trans = ReadBlobMSBLong(image);\n      break;\n    case PROP_APPLY_MASK:\n      outLayer->apply_mask = ReadBlobMSBLong(image);\n      break;\n    case PROP_EDIT_MASK:\n      outLayer->edit_mask = ReadBlobMSBLong(image);\n      break;\n    case PROP_SHOW_MASK:\n      outLayer->show_mask = ReadBlobMSBLong(image);\n      break;\n    case PROP_OFFSETS:\n      outLayer->offset_x = ReadBlobMSBSignedLong(image);\n      outLayer->offset_y = ReadBlobMSBSignedLong(image);\n      break;\n    case PROP_MODE:\n      outLayer->mode = ReadBlobMSBLong(image);\n      break;\n    case PROP_TATTOO:\n      outLayer->preserve_trans = ReadBlobMSBLong(image);\n      break;\n     case PROP_PARASITES:\n     {\n       if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n         ThrowFileException(&image->exception,CorruptImageError,\n           \"UnexpectedEndOfFile\",image->filename);\n\n        /*\n       ssize_t base = info->cp;\n       GimpParasite *p;\n       while (info->cp - base < prop_size)\n       {\n       p = xcf_load_parasite(info);\n       gimp_drawable_parasite_attach(GIMP_DRAWABLE(layer), p);\n       gimp_parasite_free(p);\n       }\n       if (info->cp - base != prop_size)\n       g_message (\"Error detected while loading a layer's parasites\");\n       */\n     }\n     break;\n    default:\n      /* g_message (\"unexpected/unknown layer property: %d (skipping)\",\n         prop_type); */\n\n      {\n      int buf[16];\n      ssize_t amount;\n\n      /* read over it... */\n      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))\n        {\n        amount = (ssize_t) MagickMin(16, prop_size);\n        amount = ReadBlob(image, (size_t) amount, (unsigned char *) &buf);\n        if (!amount)\n          ThrowBinaryException(CorruptImageError,\"CorruptImage\",\n            image->filename);\n        prop_size -= (size_t) MagickMin(16, (size_t) amount);\n        }\n      }\n      break;\n    }\n  }\n\n  if (foundPropEnd == MagickFalse)\n    return(MagickFalse);\n  /* allocate the image for this layer */\n  if (image_info->number_scenes != 0)\n    {\n      ssize_t\n        scene;\n\n      scene=inDocInfo->number_layers-layer-1;\n      if (scene > (ssize_t) (image_info->scene+image_info->number_scenes-1))\n        {\n          outLayer->image=CloneImage(image,0,0,MagickTrue,&image->exception);\n          if (outLayer->image == (Image *) NULL)\n            return(MagickFalse);\n          InitXCFImage(outLayer);\n          return(MagickTrue);\n        }\n    }\n  /* allocate the image for this layer */\n  outLayer->image=CloneImage(image,outLayer->width, outLayer->height,MagickTrue,\n     &image->exception);\n  if (outLayer->image == (Image *) NULL)\n    return(MagickFalse);\n  /* clear the image based on the layer opacity */\n  outLayer->image->background_color.opacity=\n    ScaleCharToQuantum((unsigned char) (255-outLayer->alpha));\n  (void) SetImageBackgroundColor(outLayer->image);\n\n  InitXCFImage(outLayer);\n\n  /* set the compositing mode */\n  outLayer->image->compose = GIMPBlendModeToCompositeOperator( outLayer->mode );\n  if ( outLayer->visible == MagickFalse )\n    {\n      /* BOGUS: should really be separate member var! */\n      outLayer->image->compose = NoCompositeOp;\n    }\n\n  /* read the hierarchy and layer mask offsets */\n  hierarchy_offset = ReadBlobMSBLong(image);\n  layer_mask_offset = ReadBlobMSBLong(image);\n\n  /* read in the hierarchy */\n  offset=SeekBlob(image, (MagickOffsetType) hierarchy_offset, SEEK_SET);\n  if (offset != (MagickOffsetType) hierarchy_offset)\n    (void) ThrowMagickException(&image->exception,GetMagickModule(),\n      CorruptImageError,\"InvalidImageHeader\",\"`%s'\",image->filename);\n  if (load_hierarchy (image, inDocInfo, outLayer) == 0)\n    return(MagickFalse);\n\n  /* read in the layer mask */\n  if (layer_mask_offset != 0)\n    {\n      offset=SeekBlob(image, (MagickOffsetType) layer_mask_offset, SEEK_SET);\n\n#if 0  /* BOGUS: support layer masks! */\n      layer_mask = xcf_load_layer_mask (info, gimage);\n      if (layer_mask == 0)\n  goto error;\n\n      /* set the offsets of the layer_mask */\n      GIMP_DRAWABLE (layer_mask)->offset_x = GIMP_DRAWABLE (layer)->offset_x;\n      GIMP_DRAWABLE (layer_mask)->offset_y = GIMP_DRAWABLE (layer)->offset_y;\n\n      gimp_layer_add_mask (layer, layer_mask, MagickFalse);\n\n      layer->mask->apply_mask = apply_mask;\n      layer->mask->edit_mask  = edit_mask;\n      layer->mask->show_mask  = show_mask;\n#endif\n  }\n\n  /* attach the floating selection... */\n#if 0  /* BOGUS: we may need to read this, even if we don't support it! */\n  if (add_floating_sel)\n    {\n      GimpLayer *floating_sel;\n\n      floating_sel = info->floating_sel;\n      floating_sel_attach (floating_sel, GIMP_DRAWABLE (layer));\n    }\n#endif\n\n  return MagickTrue;\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d X C F I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadXCFImage() reads a GIMP (GNU Image Manipulation Program) image\n%  file and returns it.  It allocates the memory necessary for the new Image\n%  structure and returns a pointer to the new image.\n%\n%  The format of the ReadXCFImage method is:\n%\n%      image=ReadXCFImage(image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    magick[14];\n\n  Image\n    *image;\n\n  int\n    foundPropEnd = 0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    image_type,\n    length;\n\n  ssize_t\n    count;\n\n  XCFDocInfo\n    doc_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  count=ReadBlob(image,14,(unsigned char *) magick);\n  if ((count != 14) ||\n      (LocaleNCompare((char *) magick,\"gimp xcf\",8) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ResetMagickMemory(&doc_info,0,sizeof(XCFDocInfo));\n  doc_info.exception=exception;\n  doc_info.width=ReadBlobMSBLong(image);\n  doc_info.height=ReadBlobMSBLong(image);\n  if ((doc_info.width > 262144) || (doc_info.height > 262144))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  doc_info.image_type=ReadBlobMSBLong(image);\n  /*\n    Initialize image attributes.\n  */\n  image->columns=doc_info.width;\n  image->rows=doc_info.height;\n  image_type=doc_info.image_type;\n  doc_info.file_size=GetBlobSize(image);\n  image->compression=NoCompression;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (image_type == GIMP_RGB)\n    ;\n  else\n    if (image_type == GIMP_GRAY)\n      image->colorspace=GRAYColorspace;\n    else\n      if (image_type == GIMP_INDEXED)\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n  (void) SetImageOpacity(image,OpaqueOpacity); \n  (void) SetImageBackgroundColor(image);\n  /*\n    Read properties.\n  */\n  while ((foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse))\n  {\n    PropType prop_type = (PropType) ReadBlobMSBLong(image);\n    size_t prop_size = ReadBlobMSBLong(image);\n\n    switch (prop_type)\n    {\n      case PROP_END:\n        foundPropEnd=1;\n        break;\n      case PROP_COLORMAP:\n      {\n        /* Cannot rely on prop_size here--the value is set incorrectly\n           by some Gimp versions.\n        */\n        size_t num_colours = ReadBlobMSBLong(image);\n        if (DiscardBlobBytes(image,3*num_colours) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n    /*\n      if (info->file_version == 0)\n      {\n        gint i;\n\n        g_message (_(\"XCF warning: version 0 of XCF file format\\n\"\n           \"did not save indexed colormaps correctly.\\n\"\n           \"Substituting grayscale map.\"));\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        xcf_seek_pos (info, info->cp + gimage->num_cols);\n        for (i = 0; i<gimage->num_cols; i++)\n          {\n            gimage->cmap[i*3+0] = i;\n            gimage->cmap[i*3+1] = i;\n            gimage->cmap[i*3+2] = i;\n          }\n      }\n      else\n      {\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        info->cp +=\n          xcf_read_int8 (info->fp,\n                   (guint8*) gimage->cmap, gimage->num_cols*3);\n      }\n     */\n        break;\n      }\n      case PROP_COMPRESSION:\n      {\n        doc_info.compression = ReadBlobByte(image);\n        if ((doc_info.compression != COMPRESS_NONE) &&\n            (doc_info.compression != COMPRESS_RLE) &&\n            (doc_info.compression != COMPRESS_ZLIB) &&\n            (doc_info.compression != COMPRESS_FRACTAL))\n          ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n      }\n      break;\n\n      case PROP_GUIDES:\n      {\n         /* just skip it - we don't care about guides */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n      }\n      break;\n\n    case PROP_RESOLUTION:\n      {\n        /* float xres = (float) */ (void) ReadBlobMSBLong(image);\n        /* float yres = (float) */ (void) ReadBlobMSBLong(image);\n\n        /*\n        if (xres < GIMP_MIN_RESOLUTION || xres > GIMP_MAX_RESOLUTION ||\n            yres < GIMP_MIN_RESOLUTION || yres > GIMP_MAX_RESOLUTION)\n        {\n        g_message (\"Warning, resolution out of range in XCF file\");\n        xres = gimage->gimp->config->default_xresolution;\n        yres = gimage->gimp->config->default_yresolution;\n        }\n        */\n\n\n        /* BOGUS: we don't write these yet because we aren't\n              reading them properly yet :(\n              image->x_resolution = xres;\n              image->y_resolution = yres;\n        */\n      }\n      break;\n\n    case PROP_TATTOO:\n      {\n        /* we need to read it, even if we ignore it */\n        /*size_t  tattoo_state = */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PARASITES:\n      {\n        /* BOGUS: we may need these for IPTC stuff */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n        /*\n      gssize_t         base = info->cp;\n      GimpParasite *p;\n\n      while (info->cp - base < prop_size)\n        {\n          p = xcf_load_parasite (info);\n          gimp_image_parasite_attach (gimage, p);\n          gimp_parasite_free (p);\n        }\n      if (info->cp - base != prop_size)\n        g_message (\"Error detected while loading an image's parasites\");\n      */\n          }\n      break;\n\n    case PROP_UNIT:\n      {\n        /* BOGUS: ignore for now... */\n      /*size_t unit =  */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PATHS:\n      {\n      /* BOGUS: just skip it for now */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n\n        /*\n      PathList *paths = xcf_load_bzpaths (gimage, info);\n      gimp_image_set_paths (gimage, paths);\n      */\n      }\n      break;\n\n    case PROP_USER_UNIT:\n      {\n        char  unit_string[1000];\n        /*BOGUS: ignored for now */\n        /*float  factor = (float) */ (void) ReadBlobMSBLong(image);\n        /* size_t digits =  */ (void) ReadBlobMSBLong(image);\n        for (i=0; i<5; i++)\n         (void) ReadBlobStringWithLongSize(image, unit_string,\n           sizeof(unit_string));\n      }\n     break;\n\n      default:\n      {\n        int buf[16];\n        ssize_t amount;\n\n      /* read over it... */\n      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))\n      {\n        amount=(ssize_t) MagickMin(16, prop_size);\n        amount=(ssize_t) ReadBlob(image,(size_t) amount,(unsigned char *) &buf);\n        if (!amount)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n        prop_size -= (size_t) MagickMin(16,(size_t) amount);\n      }\n    }\n    break;\n  }\n  }\n  if (foundPropEnd == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    {\n      ; /* do nothing, were just pinging! */\n    }\n  else\n    {\n      int\n        current_layer = 0,\n        foundAllLayers = MagickFalse,\n        number_layers = 0;\n\n      MagickOffsetType\n        oldPos=TellBlob(image);\n\n      XCFLayerInfo\n        *layer_info;\n\n      /*\n        The read pointer.\n      */\n      do\n      {\n        ssize_t offset = ReadBlobMSBSignedLong(image);\n        if (offset == 0)\n          foundAllLayers=MagickTrue;\n        else\n          number_layers++;\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n    } while (foundAllLayers == MagickFalse);\n    doc_info.number_layers=number_layers;\n    offset=SeekBlob(image,oldPos,SEEK_SET); /* restore the position! */\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /* allocate our array of layer info blocks */\n    length=(size_t) number_layers;\n    layer_info=(XCFLayerInfo *) AcquireQuantumMemory(length,\n      sizeof(*layer_info));\n    if (layer_info == (XCFLayerInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(layer_info,0,number_layers*sizeof(XCFLayerInfo));\n    for ( ; ; )\n    {\n      MagickBooleanType\n        layer_ok;\n\n      MagickOffsetType\n        offset,\n        saved_pos;\n\n      /* read in the offset of the next layer */\n      offset=(MagickOffsetType) ReadBlobMSBLong(image);\n      /* if the offset is 0 then we are at the end\n      *  of the layer list.\n      */\n      if (offset == 0)\n        break;\n      /* save the current position as it is where the\n      *  next layer offset is stored.\n      */\n      saved_pos=TellBlob(image);\n      /* seek to the layer offset */\n      if (SeekBlob(image,offset,SEEK_SET) != offset)\n        ThrowReaderException(ResourceLimitError,\"NotEnoughPixelData\");\n      /* read in the layer */\n      layer_ok=ReadOneLayer(image_info,image,&doc_info,\n        &layer_info[current_layer],current_layer);\n      if (layer_ok == MagickFalse)\n        {\n          int j;\n\n          for (j=0; j < current_layer; j++)\n            layer_info[j].image=DestroyImage(layer_info[j].image);\n          layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      offset=SeekBlob(image, saved_pos, SEEK_SET);\n      current_layer++;\n    }\n#if 0\n        {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        signed int  j;\n        for (j=number_layers-1; j>=0; j--) {\n          /* BOGUS: need to consider layer blending modes!! */\n\n          if ( layer_info[j].visible ) { /* only visible ones, please! */\n            CompositeImage(image, OverCompositeOp, layer_info[j].image,\n                     layer_info[j].offset_x, layer_info[j].offset_y );\n             layer_info[j].image =DestroyImage( layer_info[j].image );\n\n            /* If we do this, we'll get REAL gray images! */\n            if ( image_type == GIMP_GRAY ) {\n              QuantizeInfo  qi;\n              GetQuantizeInfo(&qi);\n              qi.colorspace = GRAYColorspace;\n              QuantizeImage( &qi, layer_info[j].image );\n            }\n          }\n        }\n      }\n#else\n      {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        ssize_t  j;\n\n        /* now reverse the order of the layers as they are put\n           into subimages\n        */\n        for (j=(long) number_layers-1; j >= 0; j--)\n          AppendImageToList(&image,layer_info[j].image);\n      }\n#endif\n\n    layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n\n#if 0  /* BOGUS: do we need the channels?? */\n    while (MagickTrue)\n    {\n      /* read in the offset of the next channel */\n      info->cp += xcf_read_int32 (info->fp, &offset, 1);\n\n      /* if the offset is 0 then we are at the end\n      *  of the channel list.\n      */\n      if (offset == 0)\n        break;\n\n      /* save the current position as it is where the\n      *  next channel offset is stored.\n      */\n      saved_pos = info->cp;\n\n      /* seek to the channel offset */\n      xcf_seek_pos (info, offset);\n\n      /* read in the layer */\n      channel = xcf_load_channel (info, gimage);\n      if (channel == 0)\n        goto error;\n\n      num_successful_elements++;\n\n      /* add the channel to the image if its not the selection */\n      if (channel != gimage->selection_mask)\n        gimp_image_add_channel (gimage, channel, -1);\n\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      xcf_seek_pos (info, saved_pos);\n    }\n#endif\n  }\n\n  (void) CloseBlob(image);\n  DestroyImage(RemoveFirstImageFromList(&image));\n  if (image_type == GIMP_GRAY)\n    image->type=GrayscaleType;\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r X C F I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterXCFImage() adds attributes for the XCF image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterXCFImage method is:\n%\n%      size_t RegisterXCFImage(void)\n%\n*/\nModuleExport size_t RegisterXCFImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"XCF\");\n  entry->decoder=(DecodeImageHandler *) ReadXCFImage;\n  entry->magick=(IsImageFormatHandler *) IsXCF;\n  entry->description=ConstantString(\"GIMP image\");\n  entry->module=ConstantString(\"XCF\");\n  entry->seekable_stream=MagickTrue;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r X C F I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterXCFImage() removes format registrations made by the\n%  XCF module from the list of supported formats.\n%\n%  The format of the UnregisterXCFImage method is:\n%\n%      UnregisterXCFImage(void)\n%\n*/\nModuleExport void UnregisterXCFImage(void)\n{\n  (void) UnregisterMagickInfo(\"XCF\");\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            X   X   CCCC  FFFFF                              %\n%                             X X   C      F                                  %\n%                              X    C      FFF                                %\n%                             X X   C      F                                  %\n%                            X   X   CCCC  F                                  %\n%                                                                             %\n%                                                                             %\n%                        Read GIMP XCF Image Format                           %\n%                                                                             %\n%                              Software Design                                %\n%                              Leonard Rosenthol                              %\n%                               November 2001                                 %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/color.h\"\n#include \"magick/composite.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/pixel.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/property.h\"\n#include \"magick/quantize.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/static.h\"\n#include \"magick/string_.h\"\n#include \"magick/module.h\"\n\f\n/*\n  Typedef declarations.\n*/\ntypedef enum\n{\n  GIMP_RGB,\n  GIMP_GRAY,\n  GIMP_INDEXED\n} GimpImageBaseType;\n\ntypedef enum\n{\n  PROP_END                   =  0,\n  PROP_COLORMAP              =  1,\n  PROP_ACTIVE_LAYER          =  2,\n  PROP_ACTIVE_CHANNEL        =  3,\n  PROP_SELECTION             =  4,\n  PROP_FLOATING_SELECTION    =  5,\n  PROP_OPACITY               =  6,\n  PROP_MODE                  =  7,\n  PROP_VISIBLE               =  8,\n  PROP_LINKED                =  9,\n  PROP_PRESERVE_TRANSPARENCY = 10,\n  PROP_APPLY_MASK            = 11,\n  PROP_EDIT_MASK             = 12,\n  PROP_SHOW_MASK             = 13,\n  PROP_SHOW_MASKED           = 14,\n  PROP_OFFSETS               = 15,\n  PROP_COLOR                 = 16,\n  PROP_COMPRESSION           = 17,\n  PROP_GUIDES                = 18,\n  PROP_RESOLUTION            = 19,\n  PROP_TATTOO                = 20,\n  PROP_PARASITES             = 21,\n  PROP_UNIT                  = 22,\n  PROP_PATHS                 = 23,\n  PROP_USER_UNIT             = 24\n} PropType;\n\ntypedef enum\n{\n  COMPRESS_NONE              =  0,\n  COMPRESS_RLE               =  1,\n  COMPRESS_ZLIB              =  2,  /* unused */\n  COMPRESS_FRACTAL           =  3   /* unused */\n} XcfCompressionType;\n\ntypedef struct\n{\n  size_t\n    width,\n    height,\n    image_type,\n    bytes_per_pixel;\n\n  int\n    compression;\n\n  size_t\n    file_size;\n\n  size_t\n    number_layers;\n\n  ExceptionInfo\n    *exception;\n} XCFDocInfo;\n\ntypedef struct\n{\n  char\n    name[1024];\n\n  unsigned int\n    active;\n\n  size_t\n    width,\n    height,\n    type,\n    alpha,\n    visible,\n    linked,\n    preserve_trans,\n    apply_mask,\n    show_mask,\n    edit_mask,\n    floating_offset;\n\n  ssize_t\n    offset_x,\n    offset_y;\n\n  size_t\n    mode,\n    tattoo;\n\n  Image\n    *image;\n} XCFLayerInfo;\n\n#define TILE_WIDTH   64\n#define TILE_HEIGHT  64\n\ntypedef struct\n{\n  unsigned char\n    red,\n    green,\n    blue,\n    alpha;\n} XCFPixelPacket;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s X C F                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsXCF() returns MagickTrue if the image format type, identified by the\n%  magick string, is XCF (GIMP native format).\n%\n%  The format of the IsXCF method is:\n%\n%      MagickBooleanType IsXCF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n%\n*/\nstatic MagickBooleanType IsXCF(const unsigned char *magick,const size_t length)\n{\n  if (length < 8)\n    return(MagickFalse);\n  if (LocaleNCompare((char *) magick,\"gimp xcf\",8) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\ntypedef enum\n{\n  GIMP_NORMAL_MODE,\n  GIMP_DISSOLVE_MODE,\n  GIMP_BEHIND_MODE,\n  GIMP_MULTIPLY_MODE,\n  GIMP_SCREEN_MODE,\n  GIMP_OVERLAY_MODE,\n  GIMP_DIFFERENCE_MODE,\n  GIMP_ADDITION_MODE,\n  GIMP_SUBTRACT_MODE,\n  GIMP_DARKEN_ONLY_MODE,\n  GIMP_LIGHTEN_ONLY_MODE,\n  GIMP_HUE_MODE,\n  GIMP_SATURATION_MODE,\n  GIMP_COLOR_MODE,\n  GIMP_VALUE_MODE,\n  GIMP_DIVIDE_MODE,\n  GIMP_DODGE_MODE,\n  GIMP_BURN_MODE,\n  GIMP_HARDLIGHT_MODE\n} GimpLayerModeEffects;\n\n/*\n  Simple utility routine to convert between PSD blending modes and\n  ImageMagick compositing operators\n*/\nstatic CompositeOperator GIMPBlendModeToCompositeOperator(\n  size_t blendMode)\n{\n  switch ( blendMode )\n  {\n    case GIMP_NORMAL_MODE:       return(OverCompositeOp);\n    case GIMP_DISSOLVE_MODE:     return(DissolveCompositeOp);\n    case GIMP_MULTIPLY_MODE:     return(MultiplyCompositeOp);\n    case GIMP_SCREEN_MODE:       return(ScreenCompositeOp);\n    case GIMP_OVERLAY_MODE:      return(OverlayCompositeOp);\n    case GIMP_DIFFERENCE_MODE:   return(DifferenceCompositeOp);\n    case GIMP_ADDITION_MODE:     return(AddCompositeOp);\n    case GIMP_SUBTRACT_MODE:     return(SubtractCompositeOp);\n    case GIMP_DARKEN_ONLY_MODE:  return(DarkenCompositeOp);\n    case GIMP_LIGHTEN_ONLY_MODE: return(LightenCompositeOp);\n    case GIMP_HUE_MODE:          return(HueCompositeOp);\n    case GIMP_SATURATION_MODE:   return(SaturateCompositeOp);\n    case GIMP_COLOR_MODE:        return(ColorizeCompositeOp);\n    case GIMP_DODGE_MODE:        return(ColorDodgeCompositeOp);\n    case GIMP_BURN_MODE:         return(ColorBurnCompositeOp);\n    case GIMP_HARDLIGHT_MODE:    return(HardLightCompositeOp);\n    case GIMP_DIVIDE_MODE:       return(DivideCompositeOp);\n    /* these are the ones we don't support...yet */\n    case GIMP_BEHIND_MODE:       return(OverCompositeOp);\n    case GIMP_VALUE_MODE:        return(OverCompositeOp);\n    default:                     return(OverCompositeOp);\n  }\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e a d B l o b S t r i n g W i t h L o n g S i z e                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobStringWithLongSize reads characters from a blob or file\n%  starting with a ssize_t length byte and then characters to that length\n%\n%  The format of the ReadBlobStringWithLongSize method is:\n%\n%      char *ReadBlobStringWithLongSize(Image *image,char *string)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o string: the address of a character buffer.\n%\n*/\n\nstatic char *ReadBlobStringWithLongSize(Image *image,char *string,size_t max)\n{\n  int\n    c;\n\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(max != 0);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  length=ReadBlobMSBLong(image);\n  for (i=0; i < (ssize_t) MagickMin(length,max-1); i++)\n  {\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      return((char *) NULL);\n    string[i]=(char) c;\n  }\n  string[i]='\\0';\n  offset=SeekBlob(image,(MagickOffsetType) (length-i),SEEK_CUR);\n  if (offset < 0)\n    (void) ThrowMagickException(&image->exception,GetMagickModule(),\n      CorruptImageError,\"ImproperImageHeader\",\"`%s'\",image->filename);\n  return(string);\n}\n\nstatic MagickBooleanType load_tile(Image *image,Image *tile_image,\n  XCFDocInfo *inDocInfo,XCFLayerInfo *inLayerInfo,size_t data_length)\n{\n  ExceptionInfo\n    *exception;\n\n  ssize_t\n    y;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  size_t\n    extent;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *graydata;\n\n  XCFPixelPacket\n    *xcfdata,\n    *xcfodata;\n\n  extent=0;\n  if (inDocInfo->image_type == GIMP_GRAY)\n    extent=tile_image->columns*tile_image->rows*sizeof(*graydata);\n  else\n    if (inDocInfo->image_type == GIMP_RGB)\n      extent=tile_image->columns*tile_image->rows*sizeof(*xcfdata);\n  if (extent > data_length)\n    ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n      image->filename);\n  xcfdata=(XCFPixelPacket *) AcquireQuantumMemory(MagickMax(data_length,\n    tile_image->columns*tile_image->rows),sizeof(*xcfdata));\n  if (xcfdata == (XCFPixelPacket *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  xcfodata=xcfdata;\n  graydata=(unsigned char *) xcfdata;  /* used by gray and indexed */\n  count=ReadBlob(image,data_length,(unsigned char *) xcfdata);\n  if (count != (ssize_t) data_length)\n    ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n      image->filename);\n  exception=(&image->exception);\n  for (y=0; y < (ssize_t) tile_image->rows; y++)\n  {\n    q=GetAuthenticPixels(tile_image,0,y,tile_image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    if (inDocInfo->image_type == GIMP_GRAY)\n      {\n        for (x=0; x < (ssize_t) tile_image->columns; x++)\n        {\n          SetPixelRed(q,ScaleCharToQuantum(*graydata));\n          SetPixelGreen(q,GetPixelRed(q));\n          SetPixelBlue(q,GetPixelRed(q));\n          SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n            inLayerInfo->alpha));\n          graydata++;\n          q++;\n        }\n      }\n    else\n      if (inDocInfo->image_type == GIMP_RGB)\n        {\n          for (x=0; x < (ssize_t) tile_image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum(xcfdata->red));\n            SetPixelGreen(q,ScaleCharToQuantum(xcfdata->green));\n            SetPixelBlue(q,ScaleCharToQuantum(xcfdata->blue));\n            SetPixelAlpha(q,xcfdata->alpha == 255U ? TransparentOpacity :\n              ScaleCharToQuantum((unsigned char) inLayerInfo->alpha));\n            xcfdata++;\n            q++;\n          }\n        }\n     if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n       break;\n  }\n  xcfodata=(XCFPixelPacket *) RelinquishMagickMemory(xcfodata);\n  return MagickTrue;\n}\n\nstatic MagickBooleanType load_tile_rle(Image *image,Image *tile_image,\n  XCFDocInfo *inDocInfo,XCFLayerInfo *inLayerInfo,size_t data_length)\n{\n  ExceptionInfo\n    *exception;\n\n  MagickOffsetType\n    size;\n\n  Quantum\n    alpha;\n\n  register PixelPacket\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    bytes_per_pixel,\n    count,\n    i,\n    j;\n\n  unsigned char\n    data,\n    pixel,\n    *xcfdata,\n    *xcfodata,\n    *xcfdatalimit;\n\n  bytes_per_pixel=(ssize_t) inDocInfo->bytes_per_pixel;\n  xcfdata=(unsigned char *) AcquireQuantumMemory(data_length,sizeof(*xcfdata));\n  if (xcfdata == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  xcfodata=xcfdata;\n  count=ReadBlob(image, (size_t) data_length, xcfdata);\n  xcfdatalimit = xcfodata+count-1;\n  exception=(&image->exception);\n  alpha=ScaleCharToQuantum((unsigned char) inLayerInfo->alpha);\n  for (i=0; i < (ssize_t) bytes_per_pixel; i++)\n  {\n    q=GetAuthenticPixels(tile_image,0,0,tile_image->columns,tile_image->rows,\n      exception);\n    if (q == (PixelPacket *) NULL)\n      continue;\n    size=(MagickOffsetType) tile_image->rows*tile_image->columns;\n    while (size > 0)\n    {\n      if (xcfdata > xcfdatalimit)\n        goto bogus_rle;\n      pixel=(*xcfdata++);\n      length=(size_t) pixel;\n      if (length >= 128)\n        {\n          length=255-(length-1);\n          if (length == 128)\n            {\n              if (xcfdata >= xcfdatalimit)\n                goto bogus_rle;\n              length=(size_t) ((*xcfdata << 8) + xcfdata[1]);\n              xcfdata+=2;\n            }\n          size-=length;\n          if (size < 0)\n            goto bogus_rle;\n          if (&xcfdata[length-1] > xcfdatalimit)\n            goto bogus_rle;\n          while (length-- > 0)\n          {\n            data=(*xcfdata++);\n            switch (i)\n            {\n              case 0:\n              {\n                SetPixelRed(q,ScaleCharToQuantum(data));\n                if (inDocInfo->image_type == GIMP_GRAY)\n                  {\n                    SetPixelGreen(q,ScaleCharToQuantum(data));\n                    SetPixelBlue(q,ScaleCharToQuantum(data));\n                  }\n                else\n                  {\n                    SetPixelGreen(q,GetPixelRed(q));\n                    SetPixelBlue(q,GetPixelRed(q));\n                  }\n                SetPixelAlpha(q,alpha);\n                break;\n              }\n              case 1:\n              {\n                if (inDocInfo->image_type == GIMP_GRAY)\n                  SetPixelAlpha(q,ScaleCharToQuantum(data));\n                else\n                  SetPixelGreen(q,ScaleCharToQuantum(data));\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(q,ScaleCharToQuantum(data));\n                break;\n              }\n              case 3:\n              {\n                SetPixelAlpha(q,ScaleCharToQuantum(data));\n                break;\n              }\n            }\n            q++;\n          }\n        }\n      else\n        {\n          length+=1;\n          if (length == 128)\n            {\n              if (xcfdata >= xcfdatalimit)\n                goto bogus_rle;\n              length=(size_t) ((*xcfdata << 8) + xcfdata[1]);\n              xcfdata+=2;\n            }\n          size-=length;\n          if (size < 0)\n            goto bogus_rle;\n          if (xcfdata > xcfdatalimit)\n            goto bogus_rle;\n          pixel=(*xcfdata++);\n          for (j=0; j < (ssize_t) length; j++)\n          {\n            data=pixel;\n            switch (i)\n            {\n              case 0:\n              {\n                SetPixelRed(q,ScaleCharToQuantum(data));\n                if (inDocInfo->image_type == GIMP_GRAY)\n                  {\n                    SetPixelGreen(q,ScaleCharToQuantum(data));\n                    SetPixelBlue(q,ScaleCharToQuantum(data));\n                  }\n                else\n                  {\n                    SetPixelGreen(q,GetPixelRed(q));\n                    SetPixelBlue(q,GetPixelRed(q));\n                  }\n                SetPixelAlpha(q,alpha);\n                break;\n              }\n              case 1:\n              {\n                if (inDocInfo->image_type == GIMP_GRAY)\n                  SetPixelAlpha(q,ScaleCharToQuantum(data));\n                else\n                  SetPixelGreen(q,ScaleCharToQuantum(data));\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(q,ScaleCharToQuantum(data));\n                break;\n              }\n              case 3:\n              {\n                SetPixelAlpha(q,ScaleCharToQuantum(data));\n                break;\n              }\n            }\n            q++;\n          }\n        }\n    }\n    if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n      break;\n  }\n  xcfodata=(unsigned char *) RelinquishMagickMemory(xcfodata);\n  return(MagickTrue);\n\n  bogus_rle:\n    if (xcfodata != (unsigned char *) NULL)\n      xcfodata=(unsigned char *) RelinquishMagickMemory(xcfodata);\n  return(MagickFalse);\n}\n\nstatic MagickBooleanType load_level(Image *image,XCFDocInfo *inDocInfo,\n  XCFLayerInfo *inLayerInfo)\n{\n  ExceptionInfo\n    *exception;\n\n  int\n    destLeft = 0,\n    destTop = 0;\n\n  Image*\n    tile_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    saved_pos,\n    offset,\n    offset2;\n\n  register ssize_t\n    i;\n\n  size_t\n    width,\n    height,\n    ntiles,\n    ntile_rows,\n    ntile_cols,\n    tile_image_width,\n    tile_image_height;\n\n  /* start reading the data */\n  exception=inDocInfo->exception;\n  width=ReadBlobMSBLong(image);\n  height=ReadBlobMSBLong(image);\n\n  /*\n    Read in the first tile offset.  If it is '0', then this tile level is empty\n    and we can simply return.\n  */\n  offset=(MagickOffsetType) ReadBlobMSBLong(image);\n  if (offset == 0)\n    return(MagickTrue);\n  /*\n    Initialize the reference for the in-memory tile-compression.\n  */\n  ntile_rows=(height+TILE_HEIGHT-1)/TILE_HEIGHT;\n  ntile_cols=(width+TILE_WIDTH-1)/TILE_WIDTH;\n  ntiles=ntile_rows*ntile_cols;\n  for (i = 0; i < (ssize_t) ntiles; i++)\n  {\n    status=MagickFalse;\n    if (offset == 0)\n      ThrowBinaryException(CorruptImageError,\"NotEnoughTiles\",image->filename);\n    /* save the current position as it is where the\n     *  next tile offset is stored.\n     */\n    saved_pos=TellBlob(image);\n    /* read in the offset of the next tile so we can calculate the amount\n       of data needed for this tile*/\n    offset2=(MagickOffsetType)ReadBlobMSBLong(image);\n    /* if the offset is 0 then we need to read in the maximum possible\n       allowing for negative compression */\n    if (offset2 == 0)\n      offset2=(MagickOffsetType) (offset + TILE_WIDTH * TILE_WIDTH * 4* 1.5);\n    /* seek to the tile offset */\n    if (SeekBlob(image, offset, SEEK_SET) != offset)\n      ThrowBinaryException(CorruptImageError,\"InsufficientImageDataInFile\",\n        image->filename);\n\n      /* allocate the image for the tile\n        NOTE: the last tile in a row or column may not be a full tile!\n      */\n      tile_image_width=(size_t) (destLeft == (int) ntile_cols-1 ?\n        (int) width % TILE_WIDTH : TILE_WIDTH);\n      if (tile_image_width == 0)\n        tile_image_width=TILE_WIDTH;\n      tile_image_height = (size_t) (destTop == (int) ntile_rows-1 ?\n        (int) height % TILE_HEIGHT : TILE_HEIGHT);\n      if (tile_image_height == 0)\n        tile_image_height=TILE_HEIGHT;\n      tile_image=CloneImage(inLayerInfo->image,tile_image_width,\n        tile_image_height,MagickTrue,exception);\n\n      /* read in the tile */\n      switch (inDocInfo->compression)\n      {\n        case COMPRESS_NONE:\n          if (load_tile(image,tile_image,inDocInfo,inLayerInfo,(size_t) (offset2-offset)) == 0)\n            status=MagickTrue;\n          break;\n        case COMPRESS_RLE:\n          if (load_tile_rle (image,tile_image,inDocInfo,inLayerInfo,\n              (int) (offset2-offset)) == 0)\n            status=MagickTrue;\n          break;\n        case COMPRESS_ZLIB:\n          ThrowBinaryException(CoderError,\"ZipCompressNotSupported\",\n            image->filename)\n        case COMPRESS_FRACTAL:\n          ThrowBinaryException(CoderError,\"FractalCompressNotSupported\",\n            image->filename)\n      }\n\n      /* composite the tile onto the layer's image, and then destroy it */\n      (void) CompositeImage(inLayerInfo->image,CopyCompositeOp,tile_image,\n        destLeft * TILE_WIDTH,destTop*TILE_HEIGHT);\n      tile_image=DestroyImage(tile_image);\n\n      /* adjust tile position */\n      destLeft++;\n      if (destLeft >= (int) ntile_cols)\n        {\n          destLeft = 0;\n          destTop++;\n        }\n      if (status != MagickFalse)\n        return(MagickFalse);\n      /* restore the saved position so we'll be ready to\n       *  read the next offset.\n       */\n      offset=SeekBlob(image, saved_pos, SEEK_SET);\n      /* read in the offset of the next tile */\n      offset=(MagickOffsetType) ReadBlobMSBLong(image);\n    }\n  if (offset != 0)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename)\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType load_hierarchy(Image *image,XCFDocInfo *inDocInfo,\n   XCFLayerInfo *inLayer)\n{\n  MagickOffsetType\n    saved_pos,\n    offset,\n    junk;\n\n  size_t\n    width,\n    height,\n    bytes_per_pixel;\n\n  width=ReadBlobMSBLong(image);\n  (void) width;\n  height=ReadBlobMSBLong(image);\n  (void) height;\n  bytes_per_pixel=inDocInfo->bytes_per_pixel=ReadBlobMSBLong(image);\n  (void) bytes_per_pixel;\n\n  /* load in the levels...we make sure that the number of levels\n   *  calculated when the TileManager was created is the same\n   *  as the number of levels found in the file.\n   */\n  offset=(MagickOffsetType) ReadBlobMSBLong(image);  /* top level */\n\n  /* discard offsets for layers below first, if any.\n   */\n  do\n  {\n    junk=(MagickOffsetType) ReadBlobMSBLong(image);\n  }\n  while (junk != 0);\n\n  /* save the current position as it is where the\n   *  next level offset is stored.\n   */\n  saved_pos=TellBlob(image);\n\n  /* seek to the level offset */\n  if (SeekBlob(image, offset, SEEK_SET) != offset)\n    ThrowBinaryException(CorruptImageError,\"InsufficientImageDataInFile\",\n      image->filename);\n\n  /* read in the level */\n  if (load_level (image, inDocInfo, inLayer) == 0)\n    return(MagickFalse);\n  /* restore the saved position so we'll be ready to\n   *  read the next offset.\n   */\n  offset=SeekBlob(image, saved_pos, SEEK_SET);\n  return(MagickTrue);\n}\n\nstatic void InitXCFImage(XCFLayerInfo *outLayer)\n{\n  outLayer->image->page.x=outLayer->offset_x;\n  outLayer->image->page.y=outLayer->offset_y;\n  outLayer->image->page.width=outLayer->width;\n  outLayer->image->page.height=outLayer->height;\n  (void) SetImageProperty(outLayer->image,\"label\",(char *)outLayer->name);\n}\n\nstatic MagickBooleanType ReadOneLayer(const ImageInfo *image_info,Image* image,\n  XCFDocInfo* inDocInfo,XCFLayerInfo *outLayer,const ssize_t layer)\n{\n  MagickOffsetType\n    offset;\n\n  unsigned int\n    foundPropEnd = 0;\n\n  size_t\n    hierarchy_offset,\n    layer_mask_offset;\n\n  /* clear the block! */\n  (void) ResetMagickMemory( outLayer, 0, sizeof( XCFLayerInfo ) );\n  /* read in the layer width, height, type and name */\n  outLayer->width = ReadBlobMSBLong(image);\n  outLayer->height = ReadBlobMSBLong(image);\n  outLayer->type = ReadBlobMSBLong(image);\n  (void) ReadBlobStringWithLongSize(image, outLayer->name,\n    sizeof(outLayer->name));\n  if (EOFBlob(image) != MagickFalse)\n    ThrowBinaryException(CorruptImageError,\"InsufficientImageDataInFile\",\n      image->filename);\n  /* read the layer properties! */\n  foundPropEnd = 0;\n  while ( (foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse) ) {\n  PropType    prop_type = (PropType) ReadBlobMSBLong(image);\n  size_t  prop_size = ReadBlobMSBLong(image);\n    switch (prop_type)\n    {\n    case PROP_END:\n      foundPropEnd = 1;\n      break;\n    case PROP_ACTIVE_LAYER:\n      outLayer->active = 1;\n      break;\n    case PROP_FLOATING_SELECTION:\n      outLayer->floating_offset = ReadBlobMSBLong(image);\n      break;\n    case PROP_OPACITY:\n      outLayer->alpha = ReadBlobMSBLong(image);\n      break;\n    case PROP_VISIBLE:\n      outLayer->visible = ReadBlobMSBLong(image);\n      break;\n    case PROP_LINKED:\n      outLayer->linked = ReadBlobMSBLong(image);\n      break;\n    case PROP_PRESERVE_TRANSPARENCY:\n      outLayer->preserve_trans = ReadBlobMSBLong(image);\n      break;\n    case PROP_APPLY_MASK:\n      outLayer->apply_mask = ReadBlobMSBLong(image);\n      break;\n    case PROP_EDIT_MASK:\n      outLayer->edit_mask = ReadBlobMSBLong(image);\n      break;\n    case PROP_SHOW_MASK:\n      outLayer->show_mask = ReadBlobMSBLong(image);\n      break;\n    case PROP_OFFSETS:\n      outLayer->offset_x = ReadBlobMSBSignedLong(image);\n      outLayer->offset_y = ReadBlobMSBSignedLong(image);\n      break;\n    case PROP_MODE:\n      outLayer->mode = ReadBlobMSBLong(image);\n      break;\n    case PROP_TATTOO:\n      outLayer->preserve_trans = ReadBlobMSBLong(image);\n      break;\n     case PROP_PARASITES:\n     {\n       if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n         ThrowFileException(&image->exception,CorruptImageError,\n           \"UnexpectedEndOfFile\",image->filename);\n\n        /*\n       ssize_t base = info->cp;\n       GimpParasite *p;\n       while (info->cp - base < prop_size)\n       {\n       p = xcf_load_parasite(info);\n       gimp_drawable_parasite_attach(GIMP_DRAWABLE(layer), p);\n       gimp_parasite_free(p);\n       }\n       if (info->cp - base != prop_size)\n       g_message (\"Error detected while loading a layer's parasites\");\n       */\n     }\n     break;\n    default:\n      /* g_message (\"unexpected/unknown layer property: %d (skipping)\",\n         prop_type); */\n\n      {\n      int buf[16];\n      ssize_t amount;\n\n      /* read over it... */\n      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))\n        {\n        amount = (ssize_t) MagickMin(16, prop_size);\n        amount = ReadBlob(image, (size_t) amount, (unsigned char *) &buf);\n        if (!amount)\n          ThrowBinaryException(CorruptImageError,\"CorruptImage\",\n            image->filename);\n        prop_size -= (size_t) MagickMin(16, (size_t) amount);\n        }\n      }\n      break;\n    }\n  }\n\n  if (foundPropEnd == MagickFalse)\n    return(MagickFalse);\n  /* allocate the image for this layer */\n  if (image_info->number_scenes != 0)\n    {\n      ssize_t\n        scene;\n\n      scene=inDocInfo->number_layers-layer-1;\n      if (scene > (ssize_t) (image_info->scene+image_info->number_scenes-1))\n        {\n          outLayer->image=CloneImage(image,0,0,MagickTrue,&image->exception);\n          if (outLayer->image == (Image *) NULL)\n            return(MagickFalse);\n          InitXCFImage(outLayer);\n          return(MagickTrue);\n        }\n    }\n  /* allocate the image for this layer */\n  outLayer->image=CloneImage(image,outLayer->width, outLayer->height,MagickTrue,\n     &image->exception);\n  if (outLayer->image == (Image *) NULL)\n    return(MagickFalse);\n  /* clear the image based on the layer opacity */\n  outLayer->image->background_color.opacity=\n    ScaleCharToQuantum((unsigned char) (255-outLayer->alpha));\n  (void) SetImageBackgroundColor(outLayer->image);\n\n  InitXCFImage(outLayer);\n\n  /* set the compositing mode */\n  outLayer->image->compose = GIMPBlendModeToCompositeOperator( outLayer->mode );\n  if ( outLayer->visible == MagickFalse )\n    {\n      /* BOGUS: should really be separate member var! */\n      outLayer->image->compose = NoCompositeOp;\n    }\n\n  /* read the hierarchy and layer mask offsets */\n  hierarchy_offset = ReadBlobMSBLong(image);\n  layer_mask_offset = ReadBlobMSBLong(image);\n\n  /* read in the hierarchy */\n  offset=SeekBlob(image, (MagickOffsetType) hierarchy_offset, SEEK_SET);\n  if (offset != (MagickOffsetType) hierarchy_offset)\n    (void) ThrowMagickException(&image->exception,GetMagickModule(),\n      CorruptImageError,\"InvalidImageHeader\",\"`%s'\",image->filename);\n  if (load_hierarchy (image, inDocInfo, outLayer) == 0)\n    return(MagickFalse);\n\n  /* read in the layer mask */\n  if (layer_mask_offset != 0)\n    {\n      offset=SeekBlob(image, (MagickOffsetType) layer_mask_offset, SEEK_SET);\n\n#if 0  /* BOGUS: support layer masks! */\n      layer_mask = xcf_load_layer_mask (info, gimage);\n      if (layer_mask == 0)\n  goto error;\n\n      /* set the offsets of the layer_mask */\n      GIMP_DRAWABLE (layer_mask)->offset_x = GIMP_DRAWABLE (layer)->offset_x;\n      GIMP_DRAWABLE (layer_mask)->offset_y = GIMP_DRAWABLE (layer)->offset_y;\n\n      gimp_layer_add_mask (layer, layer_mask, MagickFalse);\n\n      layer->mask->apply_mask = apply_mask;\n      layer->mask->edit_mask  = edit_mask;\n      layer->mask->show_mask  = show_mask;\n#endif\n  }\n\n  /* attach the floating selection... */\n#if 0  /* BOGUS: we may need to read this, even if we don't support it! */\n  if (add_floating_sel)\n    {\n      GimpLayer *floating_sel;\n\n      floating_sel = info->floating_sel;\n      floating_sel_attach (floating_sel, GIMP_DRAWABLE (layer));\n    }\n#endif\n\n  return MagickTrue;\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d X C F I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadXCFImage() reads a GIMP (GNU Image Manipulation Program) image\n%  file and returns it.  It allocates the memory necessary for the new Image\n%  structure and returns a pointer to the new image.\n%\n%  The format of the ReadXCFImage method is:\n%\n%      image=ReadXCFImage(image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    magick[14];\n\n  Image\n    *image;\n\n  int\n    foundPropEnd = 0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    image_type,\n    length;\n\n  ssize_t\n    count;\n\n  XCFDocInfo\n    doc_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  count=ReadBlob(image,14,(unsigned char *) magick);\n  if ((count != 14) ||\n      (LocaleNCompare((char *) magick,\"gimp xcf\",8) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ResetMagickMemory(&doc_info,0,sizeof(XCFDocInfo));\n  doc_info.exception=exception;\n  doc_info.width=ReadBlobMSBLong(image);\n  doc_info.height=ReadBlobMSBLong(image);\n  if ((doc_info.width > 262144) || (doc_info.height > 262144))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  doc_info.image_type=ReadBlobMSBLong(image);\n  /*\n    Initialize image attributes.\n  */\n  image->columns=doc_info.width;\n  image->rows=doc_info.height;\n  image_type=doc_info.image_type;\n  doc_info.file_size=GetBlobSize(image);\n  image->compression=NoCompression;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (image_type == GIMP_RGB)\n    ;\n  else\n    if (image_type == GIMP_GRAY)\n      image->colorspace=GRAYColorspace;\n    else\n      if (image_type == GIMP_INDEXED)\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n  (void) SetImageOpacity(image,OpaqueOpacity); \n  (void) SetImageBackgroundColor(image);\n  /*\n    Read properties.\n  */\n  while ((foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse))\n  {\n    PropType prop_type = (PropType) ReadBlobMSBLong(image);\n    size_t prop_size = ReadBlobMSBLong(image);\n\n    switch (prop_type)\n    {\n      case PROP_END:\n        foundPropEnd=1;\n        break;\n      case PROP_COLORMAP:\n      {\n        /* Cannot rely on prop_size here--the value is set incorrectly\n           by some Gimp versions.\n        */\n        size_t num_colours = ReadBlobMSBLong(image);\n        if (DiscardBlobBytes(image,3*num_colours) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n    /*\n      if (info->file_version == 0)\n      {\n        gint i;\n\n        g_message (_(\"XCF warning: version 0 of XCF file format\\n\"\n           \"did not save indexed colormaps correctly.\\n\"\n           \"Substituting grayscale map.\"));\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        xcf_seek_pos (info, info->cp + gimage->num_cols);\n        for (i = 0; i<gimage->num_cols; i++)\n          {\n            gimage->cmap[i*3+0] = i;\n            gimage->cmap[i*3+1] = i;\n            gimage->cmap[i*3+2] = i;\n          }\n      }\n      else\n      {\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        info->cp +=\n          xcf_read_int8 (info->fp,\n                   (guint8*) gimage->cmap, gimage->num_cols*3);\n      }\n     */\n        break;\n      }\n      case PROP_COMPRESSION:\n      {\n        doc_info.compression = ReadBlobByte(image);\n        if ((doc_info.compression != COMPRESS_NONE) &&\n            (doc_info.compression != COMPRESS_RLE) &&\n            (doc_info.compression != COMPRESS_ZLIB) &&\n            (doc_info.compression != COMPRESS_FRACTAL))\n          ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n      }\n      break;\n\n      case PROP_GUIDES:\n      {\n         /* just skip it - we don't care about guides */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n      }\n      break;\n\n    case PROP_RESOLUTION:\n      {\n        /* float xres = (float) */ (void) ReadBlobMSBLong(image);\n        /* float yres = (float) */ (void) ReadBlobMSBLong(image);\n\n        /*\n        if (xres < GIMP_MIN_RESOLUTION || xres > GIMP_MAX_RESOLUTION ||\n            yres < GIMP_MIN_RESOLUTION || yres > GIMP_MAX_RESOLUTION)\n        {\n        g_message (\"Warning, resolution out of range in XCF file\");\n        xres = gimage->gimp->config->default_xresolution;\n        yres = gimage->gimp->config->default_yresolution;\n        }\n        */\n\n\n        /* BOGUS: we don't write these yet because we aren't\n              reading them properly yet :(\n              image->x_resolution = xres;\n              image->y_resolution = yres;\n        */\n      }\n      break;\n\n    case PROP_TATTOO:\n      {\n        /* we need to read it, even if we ignore it */\n        /*size_t  tattoo_state = */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PARASITES:\n      {\n        /* BOGUS: we may need these for IPTC stuff */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n        /*\n      gssize_t         base = info->cp;\n      GimpParasite *p;\n\n      while (info->cp - base < prop_size)\n        {\n          p = xcf_load_parasite (info);\n          gimp_image_parasite_attach (gimage, p);\n          gimp_parasite_free (p);\n        }\n      if (info->cp - base != prop_size)\n        g_message (\"Error detected while loading an image's parasites\");\n      */\n          }\n      break;\n\n    case PROP_UNIT:\n      {\n        /* BOGUS: ignore for now... */\n      /*size_t unit =  */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PATHS:\n      {\n      /* BOGUS: just skip it for now */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n\n        /*\n      PathList *paths = xcf_load_bzpaths (gimage, info);\n      gimp_image_set_paths (gimage, paths);\n      */\n      }\n      break;\n\n    case PROP_USER_UNIT:\n      {\n        char  unit_string[1000];\n        /*BOGUS: ignored for now */\n        /*float  factor = (float) */ (void) ReadBlobMSBLong(image);\n        /* size_t digits =  */ (void) ReadBlobMSBLong(image);\n        for (i=0; i<5; i++)\n         (void) ReadBlobStringWithLongSize(image, unit_string,\n           sizeof(unit_string));\n      }\n     break;\n\n      default:\n      {\n        int buf[16];\n        ssize_t amount;\n\n      /* read over it... */\n      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))\n      {\n        amount=(ssize_t) MagickMin(16, prop_size);\n        amount=(ssize_t) ReadBlob(image,(size_t) amount,(unsigned char *) &buf);\n        if (!amount)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n        prop_size -= (size_t) MagickMin(16,(size_t) amount);\n      }\n    }\n    break;\n  }\n  }\n  if (foundPropEnd == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    {\n      ; /* do nothing, were just pinging! */\n    }\n  else\n    {\n      int\n        current_layer = 0,\n        foundAllLayers = MagickFalse,\n        number_layers = 0;\n\n      MagickOffsetType\n        oldPos=TellBlob(image);\n\n      XCFLayerInfo\n        *layer_info;\n\n      /*\n        The read pointer.\n      */\n      do\n      {\n        ssize_t offset = ReadBlobMSBSignedLong(image);\n        if (offset == 0)\n          foundAllLayers=MagickTrue;\n        else\n          number_layers++;\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n    } while (foundAllLayers == MagickFalse);\n    doc_info.number_layers=number_layers;\n    offset=SeekBlob(image,oldPos,SEEK_SET); /* restore the position! */\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /* allocate our array of layer info blocks */\n    length=(size_t) number_layers;\n    layer_info=(XCFLayerInfo *) AcquireQuantumMemory(length,\n      sizeof(*layer_info));\n    if (layer_info == (XCFLayerInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(layer_info,0,number_layers*sizeof(XCFLayerInfo));\n    for ( ; ; )\n    {\n      MagickBooleanType\n        layer_ok;\n\n      MagickOffsetType\n        offset,\n        saved_pos;\n\n      /* read in the offset of the next layer */\n      offset=(MagickOffsetType) ReadBlobMSBLong(image);\n      /* if the offset is 0 then we are at the end\n      *  of the layer list.\n      */\n      if (offset == 0)\n        break;\n      /* save the current position as it is where the\n      *  next layer offset is stored.\n      */\n      saved_pos=TellBlob(image);\n      /* seek to the layer offset */\n      if (SeekBlob(image,offset,SEEK_SET) != offset)\n        ThrowReaderException(ResourceLimitError,\"NotEnoughPixelData\");\n      /* read in the layer */\n      layer_ok=ReadOneLayer(image_info,image,&doc_info,\n        &layer_info[current_layer],current_layer);\n      if (layer_ok == MagickFalse)\n        {\n          int j;\n\n          for (j=0; j < current_layer; j++)\n            layer_info[j].image=DestroyImage(layer_info[j].image);\n          layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      offset=SeekBlob(image, saved_pos, SEEK_SET);\n      current_layer++;\n    }\n#if 0\n        {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        signed int  j;\n        for (j=number_layers-1; j>=0; j--) {\n          /* BOGUS: need to consider layer blending modes!! */\n\n          if ( layer_info[j].visible ) { /* only visible ones, please! */\n            CompositeImage(image, OverCompositeOp, layer_info[j].image,\n                     layer_info[j].offset_x, layer_info[j].offset_y );\n             layer_info[j].image =DestroyImage( layer_info[j].image );\n\n            /* If we do this, we'll get REAL gray images! */\n            if ( image_type == GIMP_GRAY ) {\n              QuantizeInfo  qi;\n              GetQuantizeInfo(&qi);\n              qi.colorspace = GRAYColorspace;\n              QuantizeImage( &qi, layer_info[j].image );\n            }\n          }\n        }\n      }\n#else\n      {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        ssize_t  j;\n\n        /* now reverse the order of the layers as they are put\n           into subimages\n        */\n        for (j=(long) number_layers-1; j >= 0; j--)\n          AppendImageToList(&image,layer_info[j].image);\n      }\n#endif\n\n    layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n\n#if 0  /* BOGUS: do we need the channels?? */\n    while (MagickTrue)\n    {\n      /* read in the offset of the next channel */\n      info->cp += xcf_read_int32 (info->fp, &offset, 1);\n\n      /* if the offset is 0 then we are at the end\n      *  of the channel list.\n      */\n      if (offset == 0)\n        break;\n\n      /* save the current position as it is where the\n      *  next channel offset is stored.\n      */\n      saved_pos = info->cp;\n\n      /* seek to the channel offset */\n      xcf_seek_pos (info, offset);\n\n      /* read in the layer */\n      channel = xcf_load_channel (info, gimage);\n      if (channel == 0)\n        goto error;\n\n      num_successful_elements++;\n\n      /* add the channel to the image if its not the selection */\n      if (channel != gimage->selection_mask)\n        gimp_image_add_channel (gimage, channel, -1);\n\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      xcf_seek_pos (info, saved_pos);\n    }\n#endif\n  }\n\n  (void) CloseBlob(image);\n  if (GetNextImageInList(image) != (Image *) NULL)\n    DestroyImage(RemoveFirstImageFromList(&image));\n  if (image_type == GIMP_GRAY)\n    image->type=GrayscaleType;\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r X C F I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterXCFImage() adds attributes for the XCF image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterXCFImage method is:\n%\n%      size_t RegisterXCFImage(void)\n%\n*/\nModuleExport size_t RegisterXCFImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"XCF\");\n  entry->decoder=(DecodeImageHandler *) ReadXCFImage;\n  entry->magick=(IsImageFormatHandler *) IsXCF;\n  entry->description=ConstantString(\"GIMP image\");\n  entry->module=ConstantString(\"XCF\");\n  entry->seekable_stream=MagickTrue;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r X C F I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterXCFImage() removes format registrations made by the\n%  XCF module from the list of supported formats.\n%\n%  The format of the UnregisterXCFImage method is:\n%\n%      UnregisterXCFImage(void)\n%\n*/\nModuleExport void UnregisterXCFImage(void)\n{\n  (void) UnregisterMagickInfo(\"XCF\");\n}\n"], "filenames": ["coders/xcf.c"], "buggy_code_start_loc": [1453], "buggy_code_end_loc": [1454], "fixing_code_start_loc": [1453], "fixing_code_end_loc": [1455], "type": "CWE-476", "message": "An issue was discovered in ImageMagick 6.9.7. A specially crafted xcf file could lead to a NULL pointer dereference.", "other": {"cve": {"id": "CVE-2017-6501", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-06T02:59:00.650", "lastModified": "2019-03-13T13:48:09.127", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in ImageMagick 6.9.7. A specially crafted xcf file could lead to a NULL pointer dereference."}, {"lang": "es", "value": "Ha sido descubierto un problema en ImageMagick 6.9.7. Un archivo cxf especialmente manipulado podr\u00eda conducir a una referencia de puntero NULL."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:6.9.7:*:*:*:*:*:*:*", "matchCriteriaId": "E5CFF56F-ED8D-4546-AD6C-47F9CC215B28"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/96589", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.debian.org/856881", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/d31fec57e9dfb0516deead2053a856e3c71e9751", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/d31fec57e9dfb0516deead2053a856e3c71e9751"}}