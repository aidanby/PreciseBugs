{"buggy_code": ["/*\n * Copyright (c) 2010  Aurelien Jacobs <aurel@gnuage.org>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/avstring.h\"\n#include \"libavutil/common.h\"\n#include \"libavutil/parseutils.h\"\n#include \"htmlsubtitles.h\"\n\nstatic int html_color_parse(void *log_ctx, const char *str)\n{\n    uint8_t rgba[4];\n    if (av_parse_color(rgba, str, strcspn(str, \"\\\" >\"), log_ctx) < 0)\n        return -1;\n    return rgba[0] | rgba[1] << 8 | rgba[2] << 16;\n}\n\nenum {\n    PARAM_UNKNOWN = -1,\n    PARAM_SIZE,\n    PARAM_COLOR,\n    PARAM_FACE,\n    PARAM_NUMBER\n};\n\ntypedef struct SrtStack {\n    char tag[128];\n    char param[PARAM_NUMBER][128];\n} SrtStack;\n\nstatic void rstrip_spaces_buf(AVBPrint *buf)\n{\n    if (av_bprint_is_complete(buf))\n        while (buf->len > 0 && buf->str[buf->len - 1] == ' ')\n            buf->str[--buf->len] = 0;\n}\n\n/*\n * Fast code for scanning the rest of a tag. Functionally equivalent to\n * this sscanf call:\n *\n * sscanf(in, \"%127[^<>]>%n\", buffer, lenp) == 2\n */\nstatic int scantag(const char* in, char* buffer, int* lenp) {\n    int len;\n\n    for (len = 0; len < 128; len++) {\n        const char c = *in++;\n        switch (c) {\n        case '\\0':\n            return 0;\n        case '<':\n            return 0;\n        case '>':\n            buffer[len] = '\\0';\n            *lenp = len+1;\n            return 1;\n        default:\n            break;\n        }\n        buffer[len] = c;\n    }\n    return 0;\n}\n\nint ff_htmlmarkup_to_ass(void *log_ctx, AVBPrint *dst, const char *in)\n{\n    char *param, buffer[128], tmp[128];\n    int len, tag_close, sptr = 1, line_start = 1, an = 0, end = 0;\n    SrtStack stack[16];\n    int closing_brace_missing = 0;\n\n    stack[0].tag[0] = 0;\n    strcpy(stack[0].param[PARAM_SIZE],  \"{\\\\fs}\");\n    strcpy(stack[0].param[PARAM_COLOR], \"{\\\\c}\");\n    strcpy(stack[0].param[PARAM_FACE],  \"{\\\\fn}\");\n\n    for (; !end && *in; in++) {\n        switch (*in) {\n        case '\\r':\n            break;\n        case '\\n':\n            if (line_start) {\n                end = 1;\n                break;\n            }\n            rstrip_spaces_buf(dst);\n            av_bprintf(dst, \"\\\\N\");\n            line_start = 1;\n            break;\n        case ' ':\n            if (!line_start)\n                av_bprint_chars(dst, *in, 1);\n            break;\n        case '{':    /* skip all {\\xxx} substrings except for {\\an%d}\n                        and all microdvd like styles such as {Y:xxx} */\n            len = 0;\n            an += sscanf(in, \"{\\\\an%*1u}%n\", &len) >= 0 && len > 0;\n\n            if (!closing_brace_missing) {\n                if (   (an != 1 && in[1] == '\\\\')\n                    || (in[1] && strchr(\"CcFfoPSsYy\", in[1]) && in[2] == ':')) {\n                    char *bracep = strchr(in+2, '}');\n                    if (bracep) {\n                        in = bracep;\n                        break;\n                    } else\n                        closing_brace_missing = 1;\n                }\n            }\n\n            av_bprint_chars(dst, *in, 1);\n            break;\n        case '<':\n            tag_close = in[1] == '/';\n            len = 0;\n            if (scantag(in+tag_close+1, buffer, &len) && len > 0) {\n                const char *tagname = buffer;\n                while (*tagname == ' ')\n                    tagname++;\n                if ((param = strchr(tagname, ' ')))\n                    *param++ = 0;\n                if ((!tag_close && sptr < FF_ARRAY_ELEMS(stack) && *tagname) ||\n                    ( tag_close && sptr > 0 && !strcmp(stack[sptr-1].tag, tagname))) {\n                    int i, j, unknown = 0;\n                    in += len + tag_close;\n                    if (!tag_close)\n                        memset(stack+sptr, 0, sizeof(*stack));\n                    if (!strcmp(tagname, \"font\")) {\n                        if (tag_close) {\n                            for (i=PARAM_NUMBER-1; i>=0; i--)\n                                if (stack[sptr-1].param[i][0])\n                                    for (j=sptr-2; j>=0; j--)\n                                        if (stack[j].param[i][0]) {\n                                            av_bprintf(dst, \"%s\", stack[j].param[i]);\n                                            break;\n                                        }\n                        } else {\n                            while (param) {\n                                if (!strncmp(param, \"size=\", 5)) {\n                                    unsigned font_size;\n                                    param += 5 + (param[5] == '\"');\n                                    if (sscanf(param, \"%u\", &font_size) == 1) {\n                                        snprintf(stack[sptr].param[PARAM_SIZE],\n                                             sizeof(stack[0].param[PARAM_SIZE]),\n                                             \"{\\\\fs%u}\", font_size);\n                                    }\n                                } else if (!strncmp(param, \"color=\", 6)) {\n                                    param += 6 + (param[6] == '\"');\n                                    snprintf(stack[sptr].param[PARAM_COLOR],\n                                         sizeof(stack[0].param[PARAM_COLOR]),\n                                         \"{\\\\c&H%X&}\",\n                                         html_color_parse(log_ctx, param));\n                                } else if (!strncmp(param, \"face=\", 5)) {\n                                    param += 5 + (param[5] == '\"');\n                                    len = strcspn(param,\n                                                  param[-1] == '\"' ? \"\\\"\" :\" \");\n                                    av_strlcpy(tmp, param,\n                                               FFMIN(sizeof(tmp), len+1));\n                                    param += len;\n                                    snprintf(stack[sptr].param[PARAM_FACE],\n                                             sizeof(stack[0].param[PARAM_FACE]),\n                                             \"{\\\\fn%s}\", tmp);\n                                }\n                                if ((param = strchr(param, ' ')))\n                                    param++;\n                            }\n                            for (i=0; i<PARAM_NUMBER; i++)\n                                if (stack[sptr].param[i][0])\n                                    av_bprintf(dst, \"%s\", stack[sptr].param[i]);\n                        }\n                    } else if (tagname[0] && !tagname[1] && strspn(tagname, \"bisu\") == 1) {\n                        av_bprintf(dst, \"{\\\\%c%d}\", tagname[0], !tag_close);\n                    } else {\n                        unknown = 1;\n                        snprintf(tmp, sizeof(tmp), \"</%s>\", tagname);\n                    }\n                    if (tag_close) {\n                        sptr--;\n                    } else if (unknown && !strstr(in, tmp)) {\n                        in -= len + tag_close;\n                        av_bprint_chars(dst, *in, 1);\n                    } else\n                        av_strlcpy(stack[sptr++].tag, tagname,\n                                   sizeof(stack[0].tag));\n                    break;\n                }\n            }\n        default:\n            av_bprint_chars(dst, *in, 1);\n            break;\n        }\n        if (*in != ' ' && *in != '\\r' && *in != '\\n')\n            line_start = 0;\n    }\n\n    if (!av_bprint_is_complete(dst))\n        return AVERROR(ENOMEM);\n\n    while (dst->len >= 2 && !strncmp(&dst->str[dst->len - 2], \"\\\\N\", 2))\n        dst->len -= 2;\n    dst->str[dst->len] = 0;\n    rstrip_spaces_buf(dst);\n\n    return 0;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2010  Aurelien Jacobs <aurel@gnuage.org>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/avstring.h\"\n#include \"libavutil/common.h\"\n#include \"libavutil/parseutils.h\"\n#include \"htmlsubtitles.h\"\n#include <ctype.h>\n\nstatic int html_color_parse(void *log_ctx, const char *str)\n{\n    uint8_t rgba[4];\n    if (av_parse_color(rgba, str, strcspn(str, \"\\\" >\"), log_ctx) < 0)\n        return -1;\n    return rgba[0] | rgba[1] << 8 | rgba[2] << 16;\n}\n\nenum {\n    PARAM_UNKNOWN = -1,\n    PARAM_SIZE,\n    PARAM_COLOR,\n    PARAM_FACE,\n    PARAM_NUMBER\n};\n\ntypedef struct SrtStack {\n    char tag[128];\n    char param[PARAM_NUMBER][128];\n} SrtStack;\n\nstatic void rstrip_spaces_buf(AVBPrint *buf)\n{\n    if (av_bprint_is_complete(buf))\n        while (buf->len > 0 && buf->str[buf->len - 1] == ' ')\n            buf->str[--buf->len] = 0;\n}\n\n/*\n * Fast code for scanning text enclosed in braces. Functionally\n * equivalent to this sscanf call:\n *\n * sscanf(in, \"{\\\\an%*1u}%n\", &len) >= 0 && len > 0\n */\nstatic int scanbraces(const char* in) {\n    if (strncmp(in, \"{\\\\an\", 4) != 0) {\n        return 0;\n    }\n    if (!isdigit(in[4])) {\n        return 0;\n    }\n    if (in[5] != '}') {\n        return 0;\n    }\n    return 1;\n}\n\n/*\n * Fast code for scanning the rest of a tag. Functionally equivalent to\n * this sscanf call:\n *\n * sscanf(in, \"%127[^<>]>%n\", buffer, lenp) == 2\n */\nstatic int scantag(const char* in, char* buffer, int* lenp) {\n    int len;\n\n    for (len = 0; len < 128; len++) {\n        const char c = *in++;\n        switch (c) {\n        case '\\0':\n            return 0;\n        case '<':\n            return 0;\n        case '>':\n            buffer[len] = '\\0';\n            *lenp = len+1;\n            return 1;\n        default:\n            break;\n        }\n        buffer[len] = c;\n    }\n    return 0;\n}\n\nint ff_htmlmarkup_to_ass(void *log_ctx, AVBPrint *dst, const char *in)\n{\n    char *param, buffer[128], tmp[128];\n    int len, tag_close, sptr = 1, line_start = 1, an = 0, end = 0;\n    SrtStack stack[16];\n    int closing_brace_missing = 0;\n\n    stack[0].tag[0] = 0;\n    strcpy(stack[0].param[PARAM_SIZE],  \"{\\\\fs}\");\n    strcpy(stack[0].param[PARAM_COLOR], \"{\\\\c}\");\n    strcpy(stack[0].param[PARAM_FACE],  \"{\\\\fn}\");\n\n    for (; !end && *in; in++) {\n        switch (*in) {\n        case '\\r':\n            break;\n        case '\\n':\n            if (line_start) {\n                end = 1;\n                break;\n            }\n            rstrip_spaces_buf(dst);\n            av_bprintf(dst, \"\\\\N\");\n            line_start = 1;\n            break;\n        case ' ':\n            if (!line_start)\n                av_bprint_chars(dst, *in, 1);\n            break;\n        case '{':    /* skip all {\\xxx} substrings except for {\\an%d}\n                        and all microdvd like styles such as {Y:xxx} */\n            an += scanbraces(in);\n            if (!closing_brace_missing) {\n                if (   (an != 1 && in[1] == '\\\\')\n                    || (in[1] && strchr(\"CcFfoPSsYy\", in[1]) && in[2] == ':')) {\n                    char *bracep = strchr(in+2, '}');\n                    if (bracep) {\n                        in = bracep;\n                        break;\n                    } else\n                        closing_brace_missing = 1;\n                }\n            }\n\n            av_bprint_chars(dst, *in, 1);\n            break;\n        case '<':\n            tag_close = in[1] == '/';\n            len = 0;\n            if (scantag(in+tag_close+1, buffer, &len) && len > 0) {\n                const char *tagname = buffer;\n                while (*tagname == ' ')\n                    tagname++;\n                if ((param = strchr(tagname, ' ')))\n                    *param++ = 0;\n                if ((!tag_close && sptr < FF_ARRAY_ELEMS(stack) && *tagname) ||\n                    ( tag_close && sptr > 0 && !strcmp(stack[sptr-1].tag, tagname))) {\n                    int i, j, unknown = 0;\n                    in += len + tag_close;\n                    if (!tag_close)\n                        memset(stack+sptr, 0, sizeof(*stack));\n                    if (!strcmp(tagname, \"font\")) {\n                        if (tag_close) {\n                            for (i=PARAM_NUMBER-1; i>=0; i--)\n                                if (stack[sptr-1].param[i][0])\n                                    for (j=sptr-2; j>=0; j--)\n                                        if (stack[j].param[i][0]) {\n                                            av_bprintf(dst, \"%s\", stack[j].param[i]);\n                                            break;\n                                        }\n                        } else {\n                            while (param) {\n                                if (!strncmp(param, \"size=\", 5)) {\n                                    unsigned font_size;\n                                    param += 5 + (param[5] == '\"');\n                                    if (sscanf(param, \"%u\", &font_size) == 1) {\n                                        snprintf(stack[sptr].param[PARAM_SIZE],\n                                             sizeof(stack[0].param[PARAM_SIZE]),\n                                             \"{\\\\fs%u}\", font_size);\n                                    }\n                                } else if (!strncmp(param, \"color=\", 6)) {\n                                    param += 6 + (param[6] == '\"');\n                                    snprintf(stack[sptr].param[PARAM_COLOR],\n                                         sizeof(stack[0].param[PARAM_COLOR]),\n                                         \"{\\\\c&H%X&}\",\n                                         html_color_parse(log_ctx, param));\n                                } else if (!strncmp(param, \"face=\", 5)) {\n                                    param += 5 + (param[5] == '\"');\n                                    len = strcspn(param,\n                                                  param[-1] == '\"' ? \"\\\"\" :\" \");\n                                    av_strlcpy(tmp, param,\n                                               FFMIN(sizeof(tmp), len+1));\n                                    param += len;\n                                    snprintf(stack[sptr].param[PARAM_FACE],\n                                             sizeof(stack[0].param[PARAM_FACE]),\n                                             \"{\\\\fn%s}\", tmp);\n                                }\n                                if ((param = strchr(param, ' ')))\n                                    param++;\n                            }\n                            for (i=0; i<PARAM_NUMBER; i++)\n                                if (stack[sptr].param[i][0])\n                                    av_bprintf(dst, \"%s\", stack[sptr].param[i]);\n                        }\n                    } else if (tagname[0] && !tagname[1] && strspn(tagname, \"bisu\") == 1) {\n                        av_bprintf(dst, \"{\\\\%c%d}\", tagname[0], !tag_close);\n                    } else {\n                        unknown = 1;\n                        snprintf(tmp, sizeof(tmp), \"</%s>\", tagname);\n                    }\n                    if (tag_close) {\n                        sptr--;\n                    } else if (unknown && !strstr(in, tmp)) {\n                        in -= len + tag_close;\n                        av_bprint_chars(dst, *in, 1);\n                    } else\n                        av_strlcpy(stack[sptr++].tag, tagname,\n                                   sizeof(stack[0].tag));\n                    break;\n                }\n            }\n        default:\n            av_bprint_chars(dst, *in, 1);\n            break;\n        }\n        if (*in != ' ' && *in != '\\r' && *in != '\\n')\n            line_start = 0;\n    }\n\n    if (!av_bprint_is_complete(dst))\n        return AVERROR(ENOMEM);\n\n    while (dst->len >= 2 && !strncmp(&dst->str[dst->len - 2], \"\\\\N\", 2))\n        dst->len -= 2;\n    dst->str[dst->len] = 0;\n    rstrip_spaces_buf(dst);\n\n    return 0;\n}\n"], "filenames": ["libavcodec/htmlsubtitles.c"], "buggy_code_start_loc": [24], "buggy_code_end_loc": [116], "fixing_code_start_loc": [25], "fixing_code_end_loc": [134], "type": "CWE-125", "message": "A denial of service in the subtitle decoder in FFmpeg 3.2 and 4.1 allows attackers to hog the CPU via a crafted video file in Matroska format, because handle_open_brace in libavcodec/htmlsubtitles.c has a complex format argument to sscanf.", "other": {"cve": {"id": "CVE-2019-9721", "sourceIdentifier": "cve@mitre.org", "published": "2019-03-12T09:29:00.577", "lastModified": "2022-10-07T01:57:59.993", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A denial of service in the subtitle decoder in FFmpeg 3.2 and 4.1 allows attackers to hog the CPU via a crafted video file in Matroska format, because handle_open_brace in libavcodec/htmlsubtitles.c has a complex format argument to sscanf."}, {"lang": "es", "value": "Una denegaci\u00f3n de servicio en el decodificador de subt\u00edtulos en FFmpeg versi\u00f3n 3.2 y 4.1 permite a los atacantes acaparar la CPU a trav\u00e9s de un archivo de v\u00eddeo elaborado en formato Matroska, porque handle_open_brace en libavcodec/htmlsubtitles.c tiene un argumento de formato complejo para sscanf"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "21F765CB-B78E-42A3-BB22-D9FC515694B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:4.1:*:*:*:*:*:*:*", "matchCriteriaId": "DC791808-C7E8-4298-9FB1-C1D72C573255"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/107384", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "https://git.ffmpeg.org/gitweb/ffmpeg.git/commit/894995c41e0795c7a44f81adc4838dedc3932e65", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/273f2755ce8635d42da3cde0eeba15b2e7842774", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3967-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/273f2755ce8635d42da3cde0eeba15b2e7842774"}}