{"buggy_code": ["/*\n * Copyright 1999-2021 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the Apache License 2.0 (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#include <stdio.h>\n#include \"internal/cryptlib.h\"\n#include <openssl/core.h>\n#include <openssl/core_names.h>\n#include <openssl/pkcs12.h>\n#include \"p12_local.h\"\n#include \"crypto/pkcs7/pk7_local.h\"\n\n/* Pack an object into an OCTET STRING and turn into a safebag */\n\nPKCS12_SAFEBAG *PKCS12_item_pack_safebag(void *obj, const ASN1_ITEM *it,\n                                         int nid1, int nid2)\n{\n    PKCS12_BAGS *bag;\n    PKCS12_SAFEBAG *safebag;\n\n    if ((bag = PKCS12_BAGS_new()) == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    bag->type = OBJ_nid2obj(nid1);\n    if (!ASN1_item_pack(obj, it, &bag->value.octet)) {\n        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    if ((safebag = PKCS12_SAFEBAG_new()) == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    safebag->value.bag = bag;\n    safebag->type = OBJ_nid2obj(nid2);\n    return safebag;\n\n err:\n    PKCS12_BAGS_free(bag);\n    return NULL;\n}\n\n/* Turn a stack of SAFEBAGS into a PKCS#7 data Contentinfo */\nPKCS7 *PKCS12_pack_p7data(STACK_OF(PKCS12_SAFEBAG) *sk)\n{\n    PKCS7 *p7;\n\n    if ((p7 = PKCS7_new()) == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    p7->type = OBJ_nid2obj(NID_pkcs7_data);\n    if ((p7->d.data = ASN1_OCTET_STRING_new()) == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (!ASN1_item_pack(sk, ASN1_ITEM_rptr(PKCS12_SAFEBAGS), &p7->d.data)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CANT_PACK_STRUCTURE);\n        goto err;\n    }\n    return p7;\n\n err:\n    PKCS7_free(p7);\n    return NULL;\n}\n\n/* Unpack SAFEBAGS from PKCS#7 data ContentInfo */\nSTACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7data(PKCS7 *p7)\n{\n    if (!PKCS7_type_is_data(p7)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);\n        return NULL;\n    }\n    return ASN1_item_unpack(p7->d.data, ASN1_ITEM_rptr(PKCS12_SAFEBAGS));\n}\n\n/* Turn a stack of SAFEBAGS into a PKCS#7 encrypted data ContentInfo */\n\nPKCS7 *PKCS12_pack_p7encdata_ex(int pbe_nid, const char *pass, int passlen,\n                                unsigned char *salt, int saltlen, int iter,\n                                STACK_OF(PKCS12_SAFEBAG) *bags,\n                                OSSL_LIB_CTX *ctx, const char *propq)\n{\n    PKCS7 *p7;\n    X509_ALGOR *pbe;\n    const EVP_CIPHER *pbe_ciph = NULL;\n    EVP_CIPHER *pbe_ciph_fetch = NULL;\n\n    if ((p7 = PKCS7_new_ex(ctx, propq)) == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    if (!PKCS7_set_type(p7, NID_pkcs7_encrypted)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_ERROR_SETTING_ENCRYPTED_DATA_TYPE);\n        goto err;\n    }\n\n    ERR_set_mark();\n    pbe_ciph = pbe_ciph_fetch = EVP_CIPHER_fetch(ctx, OBJ_nid2sn(pbe_nid), propq);\n    if (pbe_ciph == NULL)\n        pbe_ciph = EVP_get_cipherbynid(pbe_nid);\n    ERR_pop_to_mark();\n\n    if (pbe_ciph != NULL) {\n        pbe = PKCS5_pbe2_set_iv_ex(pbe_ciph, iter, salt, saltlen, NULL, -1, ctx);\n    } else {\n        pbe = PKCS5_pbe_set_ex(pbe_nid, iter, salt, saltlen, ctx);\n    }\n\n    if (pbe == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    X509_ALGOR_free(p7->d.encrypted->enc_data->algorithm);\n    p7->d.encrypted->enc_data->algorithm = pbe;\n    ASN1_OCTET_STRING_free(p7->d.encrypted->enc_data->enc_data);\n    if (!(p7->d.encrypted->enc_data->enc_data =\n          PKCS12_item_i2d_encrypt_ex(pbe, ASN1_ITEM_rptr(PKCS12_SAFEBAGS), pass,\n                                     passlen, bags, 1, ctx, propq))) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_ENCRYPT_ERROR);\n        goto err;\n    }\n\n    EVP_CIPHER_free(pbe_ciph_fetch);\n    return p7;\n\n err:\n    PKCS7_free(p7);\n    EVP_CIPHER_free(pbe_ciph_fetch);\n    return NULL;\n}\n\nPKCS7 *PKCS12_pack_p7encdata(int pbe_nid, const char *pass, int passlen,\n                             unsigned char *salt, int saltlen, int iter,\n                             STACK_OF(PKCS12_SAFEBAG) *bags)\n{\n    return PKCS12_pack_p7encdata_ex(pbe_nid, pass, passlen, salt, saltlen,\n                                    iter, bags, NULL, NULL);\n}\n\nSTACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7encdata(PKCS7 *p7, const char *pass,\n                                                  int passlen)\n{\n    if (!PKCS7_type_is_encrypted(p7))\n        return NULL;\n    return PKCS12_item_decrypt_d2i_ex(p7->d.encrypted->enc_data->algorithm,\n                                   ASN1_ITEM_rptr(PKCS12_SAFEBAGS),\n                                   pass, passlen,\n                                   p7->d.encrypted->enc_data->enc_data, 1,\n                                   p7->ctx.libctx, p7->ctx.propq);\n}\n\nPKCS8_PRIV_KEY_INFO *PKCS12_decrypt_skey_ex(const PKCS12_SAFEBAG *bag,\n                                            const char *pass, int passlen,\n                                            OSSL_LIB_CTX *ctx, const char *propq)\n{\n    return PKCS8_decrypt_ex(bag->value.shkeybag, pass, passlen, ctx, propq);\n}\n\nPKCS8_PRIV_KEY_INFO *PKCS12_decrypt_skey(const PKCS12_SAFEBAG *bag,\n                                         const char *pass, int passlen)\n{\n    return PKCS12_decrypt_skey_ex(bag, pass, passlen, NULL, NULL);\n}\n\nint PKCS12_pack_authsafes(PKCS12 *p12, STACK_OF(PKCS7) *safes)\n{\n    if (ASN1_item_pack(safes, ASN1_ITEM_rptr(PKCS12_AUTHSAFES),\n                       &p12->authsafes->d.data))\n        return 1;\n    return 0;\n}\n\nSTACK_OF(PKCS7) *PKCS12_unpack_authsafes(const PKCS12 *p12)\n{\n    STACK_OF(PKCS7) *p7s;\n    PKCS7 *p7;\n    int i;\n\n    if (!PKCS7_type_is_data(p12->authsafes)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);\n        return NULL;\n    }\n    p7s = ASN1_item_unpack(p12->authsafes->d.data,\n                           ASN1_ITEM_rptr(PKCS12_AUTHSAFES));\n    if (p7s != NULL) {\n        for (i = 0; i < sk_PKCS7_num(p7s); i++) {\n            p7 = sk_PKCS7_value(p7s, i);\n            if (!ossl_pkcs7_ctx_propagate(p12->authsafes, p7))\n                goto err;\n        }\n    }\n    return p7s;\nerr:\n    sk_PKCS7_free(p7s);\n    return NULL;\n}\n", "/*\n * Copyright 1999-2023 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the Apache License 2.0 (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n/*\n * HMAC low level APIs are deprecated for public use, but still ok for internal\n * use.\n */\n#include \"internal/deprecated.h\"\n\n#include <stdio.h>\n#include \"internal/cryptlib.h\"\n#include <openssl/crypto.h>\n#include <openssl/hmac.h>\n#include <openssl/rand.h>\n#include <openssl/pkcs12.h>\n#include \"p12_local.h\"\n\nint PKCS12_mac_present(const PKCS12 *p12)\n{\n    return p12->mac ? 1 : 0;\n}\n\nvoid PKCS12_get0_mac(const ASN1_OCTET_STRING **pmac,\n                     const X509_ALGOR **pmacalg,\n                     const ASN1_OCTET_STRING **psalt,\n                     const ASN1_INTEGER **piter,\n                     const PKCS12 *p12)\n{\n    if (p12->mac) {\n        X509_SIG_get0(p12->mac->dinfo, pmacalg, pmac);\n        if (psalt)\n            *psalt = p12->mac->salt;\n        if (piter)\n            *piter = p12->mac->iter;\n    } else {\n        if (pmac)\n            *pmac = NULL;\n        if (pmacalg)\n            *pmacalg = NULL;\n        if (psalt)\n            *psalt = NULL;\n        if (piter)\n            *piter = NULL;\n    }\n}\n\n#define TK26_MAC_KEY_LEN 32\n\nstatic int pkcs12_gen_gost_mac_key(const char *pass, int passlen,\n                                   const unsigned char *salt, int saltlen,\n                                   int iter, int keylen, unsigned char *key,\n                                   const EVP_MD *digest)\n{\n    unsigned char out[96];\n\n    if (keylen != TK26_MAC_KEY_LEN) {\n        return 0;\n    }\n\n    if (!PKCS5_PBKDF2_HMAC(pass, passlen, salt, saltlen, iter,\n                           digest, sizeof(out), out)) {\n        return 0;\n    }\n    memcpy(key, out + sizeof(out) - TK26_MAC_KEY_LEN, TK26_MAC_KEY_LEN);\n    OPENSSL_cleanse(out, sizeof(out));\n    return 1;\n}\n\n/* Generate a MAC */\nstatic int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n                          unsigned char *mac, unsigned int *maclen,\n                          int (*pkcs12_key_gen)(const char *pass, int passlen,\n                                                unsigned char *salt, int slen,\n                                                int id, int iter, int n,\n                                                unsigned char *out,\n                                                const EVP_MD *md_type))\n{\n    int ret = 0;\n    const EVP_MD *md;\n    EVP_MD *md_fetch;\n    HMAC_CTX *hmac = NULL;\n    unsigned char key[EVP_MAX_MD_SIZE], *salt;\n    int saltlen, iter;\n    char md_name[80];\n    int md_size = 0;\n    int md_nid;\n    const X509_ALGOR *macalg;\n    const ASN1_OBJECT *macoid;\n\n    if (!PKCS7_type_is_data(p12->authsafes)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);\n        return 0;\n    }\n\n    salt = p12->mac->salt->data;\n    saltlen = p12->mac->salt->length;\n    if (p12->mac->iter == NULL)\n        iter = 1;\n    else\n        iter = ASN1_INTEGER_get(p12->mac->iter);\n    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n    if (OBJ_obj2txt(md_name, sizeof(md_name), macoid, 0) < 0)\n        return 0;\n\n    (void)ERR_set_mark();\n    md = md_fetch = EVP_MD_fetch(p12->authsafes->ctx.libctx, md_name,\n                                 p12->authsafes->ctx.propq);\n    if (md == NULL)\n        md = EVP_get_digestbynid(OBJ_obj2nid(macoid));\n\n    if (md == NULL) {\n        (void)ERR_clear_last_mark();\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_UNKNOWN_DIGEST_ALGORITHM);\n        return 0;\n    }\n    (void)ERR_pop_to_mark();\n\n    md_size = EVP_MD_get_size(md);\n    md_nid = EVP_MD_get_type(md);\n    if (md_size < 0)\n        goto err;\n    if ((md_nid == NID_id_GostR3411_94\n         || md_nid == NID_id_GostR3411_2012_256\n         || md_nid == NID_id_GostR3411_2012_512)\n        && ossl_safe_getenv(\"LEGACY_GOST_PKCS12\") == NULL) {\n        md_size = TK26_MAC_KEY_LEN;\n        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n                                     md_size, key, md)) {\n            ERR_raise(ERR_LIB_PKCS12, PKCS12_R_KEY_GEN_ERROR);\n            goto err;\n        }\n    } else {\n        if (pkcs12_key_gen != NULL) {\n            if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n                                   iter, md_size, key, md)) {\n                ERR_raise(ERR_LIB_PKCS12, PKCS12_R_KEY_GEN_ERROR);\n                goto err;\n            }\n        } else {\n            /* Default to UTF-8 password */\n            if (!PKCS12_key_gen_utf8_ex(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n                                       iter, md_size, key, md,\n                                       p12->authsafes->ctx.libctx,\n                                       p12->authsafes->ctx.propq)) {\n                ERR_raise(ERR_LIB_PKCS12, PKCS12_R_KEY_GEN_ERROR);\n                goto err;\n            }\n        }\n    }\n    if ((hmac = HMAC_CTX_new()) == NULL\n        || !HMAC_Init_ex(hmac, key, md_size, md, NULL)\n        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n                        p12->authsafes->d.data->length)\n        || !HMAC_Final(hmac, mac, maclen)) {\n        goto err;\n    }\n    ret = 1;\n\nerr:\n    OPENSSL_cleanse(key, sizeof(key));\n    HMAC_CTX_free(hmac);\n    EVP_MD_free(md_fetch);\n    return ret;\n}\n\nint PKCS12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n                   unsigned char *mac, unsigned int *maclen)\n{\n    return pkcs12_gen_mac(p12, pass, passlen, mac, maclen, NULL);\n}\n\n/* Verify the mac */\nint PKCS12_verify_mac(PKCS12 *p12, const char *pass, int passlen)\n{\n    unsigned char mac[EVP_MAX_MD_SIZE];\n    unsigned int maclen;\n    const ASN1_OCTET_STRING *macoct;\n\n    if (p12->mac == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_MAC_ABSENT);\n        return 0;\n    }\n    if (!pkcs12_gen_mac(p12, pass, passlen, mac, &maclen, NULL)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_MAC_GENERATION_ERROR);\n        return 0;\n    }\n    X509_SIG_get0(p12->mac->dinfo, NULL, &macoct);\n    if ((maclen != (unsigned int)ASN1_STRING_length(macoct))\n        || CRYPTO_memcmp(mac, ASN1_STRING_get0_data(macoct), maclen) != 0)\n        return 0;\n\n    return 1;\n}\n\n/* Set a mac */\n\nint PKCS12_set_mac(PKCS12 *p12, const char *pass, int passlen,\n                   unsigned char *salt, int saltlen, int iter,\n                   const EVP_MD *md_type)\n{\n    unsigned char mac[EVP_MAX_MD_SIZE];\n    unsigned int maclen;\n    ASN1_OCTET_STRING *macoct;\n\n    if (md_type == NULL)\n        /* No need to do a fetch as the md_type is used only to get a NID */\n        md_type = EVP_sha256();\n    if (!iter)\n        iter = PKCS12_DEFAULT_ITER;\n    if (PKCS12_setup_mac(p12, iter, salt, saltlen, md_type) == PKCS12_ERROR) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_MAC_SETUP_ERROR);\n        return 0;\n    }\n    /*\n     * Note that output mac is forced to UTF-8...\n     */\n    if (!pkcs12_gen_mac(p12, pass, passlen, mac, &maclen, NULL)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_MAC_GENERATION_ERROR);\n        return 0;\n    }\n    X509_SIG_getm(p12->mac->dinfo, NULL, &macoct);\n    if (!ASN1_OCTET_STRING_set(macoct, mac, maclen)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_MAC_STRING_SET_ERROR);\n        return 0;\n    }\n    return 1;\n}\n\n/* Set up a mac structure */\nint PKCS12_setup_mac(PKCS12 *p12, int iter, unsigned char *salt, int saltlen,\n                     const EVP_MD *md_type)\n{\n    X509_ALGOR *macalg;\n\n    PKCS12_MAC_DATA_free(p12->mac);\n    p12->mac = NULL;\n\n    if ((p12->mac = PKCS12_MAC_DATA_new()) == NULL)\n        return PKCS12_ERROR;\n    if (iter > 1) {\n        if ((p12->mac->iter = ASN1_INTEGER_new()) == NULL) {\n            ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n            return 0;\n        }\n        if (!ASN1_INTEGER_set(p12->mac->iter, iter)) {\n            ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n            return 0;\n        }\n    }\n    if (saltlen == 0)\n        saltlen = PKCS12_SALT_LEN;\n    else if (saltlen < 0)\n        return 0;\n    if ((p12->mac->salt->data = OPENSSL_malloc(saltlen)) == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    p12->mac->salt->length = saltlen;\n    if (salt == NULL) {\n        if (RAND_bytes_ex(p12->authsafes->ctx.libctx, p12->mac->salt->data,\n                          (size_t)saltlen, 0) <= 0)\n            return 0;\n    } else {\n        memcpy(p12->mac->salt->data, salt, saltlen);\n    }\n    X509_SIG_getm(p12->mac->dinfo, &macalg, NULL);\n    if (!X509_ALGOR_set0(macalg, OBJ_nid2obj(EVP_MD_get_type(md_type)),\n                         V_ASN1_NULL, NULL)) {\n        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    return 1;\n}\n", "/*\n * Copyright 1999-2020 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the Apache License 2.0 (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/pkcs12.h>\n#include \"p12_local.h\"\n\n/* PKCS#12 password change routine */\n\nstatic int newpass_p12(PKCS12 *p12, const char *oldpass, const char *newpass);\nstatic int newpass_bags(STACK_OF(PKCS12_SAFEBAG) *bags, const char *oldpass,\n                        const char *newpass);\nstatic int newpass_bag(PKCS12_SAFEBAG *bag, const char *oldpass,\n                        const char *newpass);\nstatic int alg_get(const X509_ALGOR *alg, int *pnid, int *piter,\n                   int *psaltlen);\n\n/*\n * Change the password on a PKCS#12 structure.\n */\n\nint PKCS12_newpass(PKCS12 *p12, const char *oldpass, const char *newpass)\n{\n    /* Check for NULL PKCS12 structure */\n\n    if (p12 == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_INVALID_NULL_PKCS12_POINTER);\n        return 0;\n    }\n\n    /* Check the mac */\n\n    if (!PKCS12_verify_mac(p12, oldpass, -1)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_MAC_VERIFY_FAILURE);\n        return 0;\n    }\n\n    if (!newpass_p12(p12, oldpass, newpass)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_PARSE_ERROR);\n        return 0;\n    }\n\n    return 1;\n}\n\n/* Parse the outer PKCS#12 structure */\n\nstatic int newpass_p12(PKCS12 *p12, const char *oldpass, const char *newpass)\n{\n    STACK_OF(PKCS7) *asafes = NULL, *newsafes = NULL;\n    STACK_OF(PKCS12_SAFEBAG) *bags = NULL;\n    int i, bagnid, pbe_nid = 0, pbe_iter = 0, pbe_saltlen = 0;\n    PKCS7 *p7, *p7new;\n    ASN1_OCTET_STRING *p12_data_tmp = NULL, *macoct = NULL;\n    unsigned char mac[EVP_MAX_MD_SIZE];\n    unsigned int maclen;\n    int rv = 0;\n\n    if ((asafes = PKCS12_unpack_authsafes(p12)) == NULL)\n        goto err;\n    if ((newsafes = sk_PKCS7_new_null()) == NULL)\n        goto err;\n    for (i = 0; i < sk_PKCS7_num(asafes); i++) {\n        p7 = sk_PKCS7_value(asafes, i);\n        bagnid = OBJ_obj2nid(p7->type);\n        if (bagnid == NID_pkcs7_data) {\n            bags = PKCS12_unpack_p7data(p7);\n        } else if (bagnid == NID_pkcs7_encrypted) {\n            bags = PKCS12_unpack_p7encdata(p7, oldpass, -1);\n            if (!alg_get(p7->d.encrypted->enc_data->algorithm,\n                         &pbe_nid, &pbe_iter, &pbe_saltlen))\n                goto err;\n        } else {\n            continue;\n        }\n        if (bags == NULL)\n            goto err;\n        if (!newpass_bags(bags, oldpass, newpass))\n            goto err;\n        /* Repack bag in same form with new password */\n        if (bagnid == NID_pkcs7_data)\n            p7new = PKCS12_pack_p7data(bags);\n        else\n            p7new = PKCS12_pack_p7encdata(pbe_nid, newpass, -1, NULL,\n                                          pbe_saltlen, pbe_iter, bags);\n        if (p7new == NULL || !sk_PKCS7_push(newsafes, p7new))\n            goto err;\n        sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);\n        bags = NULL;\n    }\n\n    /* Repack safe: save old safe in case of error */\n\n    p12_data_tmp = p12->authsafes->d.data;\n    if ((p12->authsafes->d.data = ASN1_OCTET_STRING_new()) == NULL)\n        goto err;\n    if (!PKCS12_pack_authsafes(p12, newsafes))\n        goto err;\n\n    if (!PKCS12_gen_mac(p12, newpass, -1, mac, &maclen))\n        goto err;\n    X509_SIG_getm(p12->mac->dinfo, NULL, &macoct);\n    if (!ASN1_OCTET_STRING_set(macoct, mac, maclen))\n        goto err;\n\n    rv = 1;\n\nerr:\n    /* Restore old safe if necessary */\n    if (rv == 1) {\n        ASN1_OCTET_STRING_free(p12_data_tmp);\n    } else if (p12_data_tmp != NULL) {\n        ASN1_OCTET_STRING_free(p12->authsafes->d.data);\n        p12->authsafes->d.data = p12_data_tmp;\n    }\n    sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);\n    sk_PKCS7_pop_free(asafes, PKCS7_free);\n    sk_PKCS7_pop_free(newsafes, PKCS7_free);\n    return rv;\n}\n\nstatic int newpass_bags(STACK_OF(PKCS12_SAFEBAG) *bags, const char *oldpass,\n                        const char *newpass)\n{\n    int i;\n    for (i = 0; i < sk_PKCS12_SAFEBAG_num(bags); i++) {\n        if (!newpass_bag(sk_PKCS12_SAFEBAG_value(bags, i), oldpass, newpass))\n            return 0;\n    }\n    return 1;\n}\n\n/* Change password of safebag: only needs handle shrouded keybags */\n\nstatic int newpass_bag(PKCS12_SAFEBAG *bag, const char *oldpass,\n                       const char *newpass)\n{\n    PKCS8_PRIV_KEY_INFO *p8;\n    X509_SIG *p8new;\n    int p8_nid, p8_saltlen, p8_iter;\n    const X509_ALGOR *shalg;\n\n    if (PKCS12_SAFEBAG_get_nid(bag) != NID_pkcs8ShroudedKeyBag)\n        return 1;\n\n    if ((p8 = PKCS8_decrypt(bag->value.shkeybag, oldpass, -1)) == NULL)\n        return 0;\n    X509_SIG_get0(bag->value.shkeybag, &shalg, NULL);\n    if (!alg_get(shalg, &p8_nid, &p8_iter, &p8_saltlen)) {\n        PKCS8_PRIV_KEY_INFO_free(p8);\n        return 0;\n    }\n    p8new = PKCS8_encrypt(p8_nid, NULL, newpass, -1, NULL, p8_saltlen,\n                          p8_iter, p8);\n    PKCS8_PRIV_KEY_INFO_free(p8);\n    if (p8new == NULL)\n        return 0;\n    X509_SIG_free(bag->value.shkeybag);\n    bag->value.shkeybag = p8new;\n    return 1;\n}\n\nstatic int alg_get(const X509_ALGOR *alg, int *pnid, int *piter,\n                   int *psaltlen)\n{\n    PBEPARAM *pbe;\n\n    pbe = ASN1_TYPE_unpack_sequence(ASN1_ITEM_rptr(PBEPARAM), alg->parameter);\n    if (pbe == NULL)\n        return 0;\n    *pnid = OBJ_obj2nid(alg->algorithm);\n    *piter = ASN1_INTEGER_get(pbe->iter);\n    *psaltlen = pbe->salt->length;\n    PBEPARAM_free(pbe);\n    return 1;\n}\n", "/*\n * Copyright 1999-2021 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the Apache License 2.0 (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#include <stdio.h>\n#include \"internal/cryptlib.h\"\n#include <openssl/x509.h>\n#include <openssl/asn1.h>\n#include \"pk7_local.h\"\n\n/* PKCS#7 wrappers round generalised stream and MIME routines */\n\nint i2d_PKCS7_bio_stream(BIO *out, PKCS7 *p7, BIO *in, int flags)\n{\n    return i2d_ASN1_bio_stream(out, (ASN1_VALUE *)p7, in, flags,\n                               ASN1_ITEM_rptr(PKCS7));\n}\n\nint PEM_write_bio_PKCS7_stream(BIO *out, PKCS7 *p7, BIO *in, int flags)\n{\n    return PEM_write_bio_ASN1_stream(out, (ASN1_VALUE *)p7, in, flags,\n                                     \"PKCS7\", ASN1_ITEM_rptr(PKCS7));\n}\n\nint SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags)\n{\n    STACK_OF(X509_ALGOR) *mdalgs;\n    int ctype_nid = OBJ_obj2nid(p7->type);\n    const PKCS7_CTX *ctx = ossl_pkcs7_get0_ctx(p7);\n\n    if (ctype_nid == NID_pkcs7_signed)\n        mdalgs = p7->d.sign->md_algs;\n    else\n        mdalgs = NULL;\n\n    flags ^= SMIME_OLDMIME;\n\n    return SMIME_write_ASN1_ex(bio, (ASN1_VALUE *)p7, data, flags, ctype_nid,\n                               NID_undef, mdalgs, ASN1_ITEM_rptr(PKCS7),\n                               ossl_pkcs7_ctx_get0_libctx(ctx),\n                               ossl_pkcs7_ctx_get0_propq(ctx));\n}\n\nPKCS7 *SMIME_read_PKCS7_ex(BIO *bio, BIO **bcont, PKCS7 **p7)\n{\n    PKCS7 *ret;\n    OSSL_LIB_CTX *libctx = NULL;\n    const char *propq = NULL;\n\n    if (p7 != NULL && *p7 != NULL) {\n        libctx = (*p7)->ctx.libctx;\n        propq = (*p7)->ctx.propq;\n    }\n\n    ret = (PKCS7 *)SMIME_read_ASN1_ex(bio, 0, bcont, ASN1_ITEM_rptr(PKCS7),\n                                      (ASN1_VALUE **)p7, libctx, propq);\n    if (ret != NULL)\n        ossl_pkcs7_resolve_libctx(ret);\n    return ret;\n}\n\nPKCS7 *SMIME_read_PKCS7(BIO *bio, BIO **bcont)\n{\n    return SMIME_read_PKCS7_ex(bio, bcont, NULL);\n}\n"], "fixing_code": ["/*\n * Copyright 1999-2021 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the Apache License 2.0 (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#include <stdio.h>\n#include \"internal/cryptlib.h\"\n#include <openssl/core.h>\n#include <openssl/core_names.h>\n#include <openssl/pkcs12.h>\n#include \"p12_local.h\"\n#include \"crypto/pkcs7/pk7_local.h\"\n\n/* Pack an object into an OCTET STRING and turn into a safebag */\n\nPKCS12_SAFEBAG *PKCS12_item_pack_safebag(void *obj, const ASN1_ITEM *it,\n                                         int nid1, int nid2)\n{\n    PKCS12_BAGS *bag;\n    PKCS12_SAFEBAG *safebag;\n\n    if ((bag = PKCS12_BAGS_new()) == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    bag->type = OBJ_nid2obj(nid1);\n    if (!ASN1_item_pack(obj, it, &bag->value.octet)) {\n        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    if ((safebag = PKCS12_SAFEBAG_new()) == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    safebag->value.bag = bag;\n    safebag->type = OBJ_nid2obj(nid2);\n    return safebag;\n\n err:\n    PKCS12_BAGS_free(bag);\n    return NULL;\n}\n\n/* Turn a stack of SAFEBAGS into a PKCS#7 data Contentinfo */\nPKCS7 *PKCS12_pack_p7data(STACK_OF(PKCS12_SAFEBAG) *sk)\n{\n    PKCS7 *p7;\n\n    if ((p7 = PKCS7_new()) == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    p7->type = OBJ_nid2obj(NID_pkcs7_data);\n    if ((p7->d.data = ASN1_OCTET_STRING_new()) == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (!ASN1_item_pack(sk, ASN1_ITEM_rptr(PKCS12_SAFEBAGS), &p7->d.data)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CANT_PACK_STRUCTURE);\n        goto err;\n    }\n    return p7;\n\n err:\n    PKCS7_free(p7);\n    return NULL;\n}\n\n/* Unpack SAFEBAGS from PKCS#7 data ContentInfo */\nSTACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7data(PKCS7 *p7)\n{\n    if (!PKCS7_type_is_data(p7)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);\n        return NULL;\n    }\n\n    if (p7->d.data == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n        return NULL;\n    }\n\n    return ASN1_item_unpack(p7->d.data, ASN1_ITEM_rptr(PKCS12_SAFEBAGS));\n}\n\n/* Turn a stack of SAFEBAGS into a PKCS#7 encrypted data ContentInfo */\n\nPKCS7 *PKCS12_pack_p7encdata_ex(int pbe_nid, const char *pass, int passlen,\n                                unsigned char *salt, int saltlen, int iter,\n                                STACK_OF(PKCS12_SAFEBAG) *bags,\n                                OSSL_LIB_CTX *ctx, const char *propq)\n{\n    PKCS7 *p7;\n    X509_ALGOR *pbe;\n    const EVP_CIPHER *pbe_ciph = NULL;\n    EVP_CIPHER *pbe_ciph_fetch = NULL;\n\n    if ((p7 = PKCS7_new_ex(ctx, propq)) == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    if (!PKCS7_set_type(p7, NID_pkcs7_encrypted)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_ERROR_SETTING_ENCRYPTED_DATA_TYPE);\n        goto err;\n    }\n\n    ERR_set_mark();\n    pbe_ciph = pbe_ciph_fetch = EVP_CIPHER_fetch(ctx, OBJ_nid2sn(pbe_nid), propq);\n    if (pbe_ciph == NULL)\n        pbe_ciph = EVP_get_cipherbynid(pbe_nid);\n    ERR_pop_to_mark();\n\n    if (pbe_ciph != NULL) {\n        pbe = PKCS5_pbe2_set_iv_ex(pbe_ciph, iter, salt, saltlen, NULL, -1, ctx);\n    } else {\n        pbe = PKCS5_pbe_set_ex(pbe_nid, iter, salt, saltlen, ctx);\n    }\n\n    if (pbe == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    X509_ALGOR_free(p7->d.encrypted->enc_data->algorithm);\n    p7->d.encrypted->enc_data->algorithm = pbe;\n    ASN1_OCTET_STRING_free(p7->d.encrypted->enc_data->enc_data);\n    if (!(p7->d.encrypted->enc_data->enc_data =\n          PKCS12_item_i2d_encrypt_ex(pbe, ASN1_ITEM_rptr(PKCS12_SAFEBAGS), pass,\n                                     passlen, bags, 1, ctx, propq))) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_ENCRYPT_ERROR);\n        goto err;\n    }\n\n    EVP_CIPHER_free(pbe_ciph_fetch);\n    return p7;\n\n err:\n    PKCS7_free(p7);\n    EVP_CIPHER_free(pbe_ciph_fetch);\n    return NULL;\n}\n\nPKCS7 *PKCS12_pack_p7encdata(int pbe_nid, const char *pass, int passlen,\n                             unsigned char *salt, int saltlen, int iter,\n                             STACK_OF(PKCS12_SAFEBAG) *bags)\n{\n    return PKCS12_pack_p7encdata_ex(pbe_nid, pass, passlen, salt, saltlen,\n                                    iter, bags, NULL, NULL);\n}\n\nSTACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7encdata(PKCS7 *p7, const char *pass,\n                                                  int passlen)\n{\n    if (!PKCS7_type_is_encrypted(p7))\n        return NULL;\n\n    if (p7->d.encrypted == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n        return NULL;\n    }\n\n    return PKCS12_item_decrypt_d2i_ex(p7->d.encrypted->enc_data->algorithm,\n                                   ASN1_ITEM_rptr(PKCS12_SAFEBAGS),\n                                   pass, passlen,\n                                   p7->d.encrypted->enc_data->enc_data, 1,\n                                   p7->ctx.libctx, p7->ctx.propq);\n}\n\nPKCS8_PRIV_KEY_INFO *PKCS12_decrypt_skey_ex(const PKCS12_SAFEBAG *bag,\n                                            const char *pass, int passlen,\n                                            OSSL_LIB_CTX *ctx, const char *propq)\n{\n    return PKCS8_decrypt_ex(bag->value.shkeybag, pass, passlen, ctx, propq);\n}\n\nPKCS8_PRIV_KEY_INFO *PKCS12_decrypt_skey(const PKCS12_SAFEBAG *bag,\n                                         const char *pass, int passlen)\n{\n    return PKCS12_decrypt_skey_ex(bag, pass, passlen, NULL, NULL);\n}\n\nint PKCS12_pack_authsafes(PKCS12 *p12, STACK_OF(PKCS7) *safes)\n{\n    if (ASN1_item_pack(safes, ASN1_ITEM_rptr(PKCS12_AUTHSAFES),\n                       &p12->authsafes->d.data))\n        return 1;\n    return 0;\n}\n\nSTACK_OF(PKCS7) *PKCS12_unpack_authsafes(const PKCS12 *p12)\n{\n    STACK_OF(PKCS7) *p7s;\n    PKCS7 *p7;\n    int i;\n\n    if (!PKCS7_type_is_data(p12->authsafes)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);\n        return NULL;\n    }\n\n    if (p12->authsafes->d.data == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n        return NULL;\n    }\n\n    p7s = ASN1_item_unpack(p12->authsafes->d.data,\n                           ASN1_ITEM_rptr(PKCS12_AUTHSAFES));\n    if (p7s != NULL) {\n        for (i = 0; i < sk_PKCS7_num(p7s); i++) {\n            p7 = sk_PKCS7_value(p7s, i);\n            if (!ossl_pkcs7_ctx_propagate(p12->authsafes, p7))\n                goto err;\n        }\n    }\n    return p7s;\nerr:\n    sk_PKCS7_free(p7s);\n    return NULL;\n}\n", "/*\n * Copyright 1999-2023 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the Apache License 2.0 (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n/*\n * HMAC low level APIs are deprecated for public use, but still ok for internal\n * use.\n */\n#include \"internal/deprecated.h\"\n\n#include <stdio.h>\n#include \"internal/cryptlib.h\"\n#include <openssl/crypto.h>\n#include <openssl/hmac.h>\n#include <openssl/rand.h>\n#include <openssl/pkcs12.h>\n#include \"p12_local.h\"\n\nint PKCS12_mac_present(const PKCS12 *p12)\n{\n    return p12->mac ? 1 : 0;\n}\n\nvoid PKCS12_get0_mac(const ASN1_OCTET_STRING **pmac,\n                     const X509_ALGOR **pmacalg,\n                     const ASN1_OCTET_STRING **psalt,\n                     const ASN1_INTEGER **piter,\n                     const PKCS12 *p12)\n{\n    if (p12->mac) {\n        X509_SIG_get0(p12->mac->dinfo, pmacalg, pmac);\n        if (psalt)\n            *psalt = p12->mac->salt;\n        if (piter)\n            *piter = p12->mac->iter;\n    } else {\n        if (pmac)\n            *pmac = NULL;\n        if (pmacalg)\n            *pmacalg = NULL;\n        if (psalt)\n            *psalt = NULL;\n        if (piter)\n            *piter = NULL;\n    }\n}\n\n#define TK26_MAC_KEY_LEN 32\n\nstatic int pkcs12_gen_gost_mac_key(const char *pass, int passlen,\n                                   const unsigned char *salt, int saltlen,\n                                   int iter, int keylen, unsigned char *key,\n                                   const EVP_MD *digest)\n{\n    unsigned char out[96];\n\n    if (keylen != TK26_MAC_KEY_LEN) {\n        return 0;\n    }\n\n    if (!PKCS5_PBKDF2_HMAC(pass, passlen, salt, saltlen, iter,\n                           digest, sizeof(out), out)) {\n        return 0;\n    }\n    memcpy(key, out + sizeof(out) - TK26_MAC_KEY_LEN, TK26_MAC_KEY_LEN);\n    OPENSSL_cleanse(out, sizeof(out));\n    return 1;\n}\n\n/* Generate a MAC */\nstatic int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n                          unsigned char *mac, unsigned int *maclen,\n                          int (*pkcs12_key_gen)(const char *pass, int passlen,\n                                                unsigned char *salt, int slen,\n                                                int id, int iter, int n,\n                                                unsigned char *out,\n                                                const EVP_MD *md_type))\n{\n    int ret = 0;\n    const EVP_MD *md;\n    EVP_MD *md_fetch;\n    HMAC_CTX *hmac = NULL;\n    unsigned char key[EVP_MAX_MD_SIZE], *salt;\n    int saltlen, iter;\n    char md_name[80];\n    int md_size = 0;\n    int md_nid;\n    const X509_ALGOR *macalg;\n    const ASN1_OBJECT *macoid;\n\n    if (!PKCS7_type_is_data(p12->authsafes)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);\n        return 0;\n    }\n\n    if (p12->authsafes->d.data == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n        return 0;\n    }\n\n    salt = p12->mac->salt->data;\n    saltlen = p12->mac->salt->length;\n    if (p12->mac->iter == NULL)\n        iter = 1;\n    else\n        iter = ASN1_INTEGER_get(p12->mac->iter);\n    X509_SIG_get0(p12->mac->dinfo, &macalg, NULL);\n    X509_ALGOR_get0(&macoid, NULL, NULL, macalg);\n    if (OBJ_obj2txt(md_name, sizeof(md_name), macoid, 0) < 0)\n        return 0;\n\n    (void)ERR_set_mark();\n    md = md_fetch = EVP_MD_fetch(p12->authsafes->ctx.libctx, md_name,\n                                 p12->authsafes->ctx.propq);\n    if (md == NULL)\n        md = EVP_get_digestbynid(OBJ_obj2nid(macoid));\n\n    if (md == NULL) {\n        (void)ERR_clear_last_mark();\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_UNKNOWN_DIGEST_ALGORITHM);\n        return 0;\n    }\n    (void)ERR_pop_to_mark();\n\n    md_size = EVP_MD_get_size(md);\n    md_nid = EVP_MD_get_type(md);\n    if (md_size < 0)\n        goto err;\n    if ((md_nid == NID_id_GostR3411_94\n         || md_nid == NID_id_GostR3411_2012_256\n         || md_nid == NID_id_GostR3411_2012_512)\n        && ossl_safe_getenv(\"LEGACY_GOST_PKCS12\") == NULL) {\n        md_size = TK26_MAC_KEY_LEN;\n        if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,\n                                     md_size, key, md)) {\n            ERR_raise(ERR_LIB_PKCS12, PKCS12_R_KEY_GEN_ERROR);\n            goto err;\n        }\n    } else {\n        if (pkcs12_key_gen != NULL) {\n            if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n                                   iter, md_size, key, md)) {\n                ERR_raise(ERR_LIB_PKCS12, PKCS12_R_KEY_GEN_ERROR);\n                goto err;\n            }\n        } else {\n            /* Default to UTF-8 password */\n            if (!PKCS12_key_gen_utf8_ex(pass, passlen, salt, saltlen, PKCS12_MAC_ID,\n                                       iter, md_size, key, md,\n                                       p12->authsafes->ctx.libctx,\n                                       p12->authsafes->ctx.propq)) {\n                ERR_raise(ERR_LIB_PKCS12, PKCS12_R_KEY_GEN_ERROR);\n                goto err;\n            }\n        }\n    }\n    if ((hmac = HMAC_CTX_new()) == NULL\n        || !HMAC_Init_ex(hmac, key, md_size, md, NULL)\n        || !HMAC_Update(hmac, p12->authsafes->d.data->data,\n                        p12->authsafes->d.data->length)\n        || !HMAC_Final(hmac, mac, maclen)) {\n        goto err;\n    }\n    ret = 1;\n\nerr:\n    OPENSSL_cleanse(key, sizeof(key));\n    HMAC_CTX_free(hmac);\n    EVP_MD_free(md_fetch);\n    return ret;\n}\n\nint PKCS12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n                   unsigned char *mac, unsigned int *maclen)\n{\n    return pkcs12_gen_mac(p12, pass, passlen, mac, maclen, NULL);\n}\n\n/* Verify the mac */\nint PKCS12_verify_mac(PKCS12 *p12, const char *pass, int passlen)\n{\n    unsigned char mac[EVP_MAX_MD_SIZE];\n    unsigned int maclen;\n    const ASN1_OCTET_STRING *macoct;\n\n    if (p12->mac == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_MAC_ABSENT);\n        return 0;\n    }\n    if (!pkcs12_gen_mac(p12, pass, passlen, mac, &maclen, NULL)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_MAC_GENERATION_ERROR);\n        return 0;\n    }\n    X509_SIG_get0(p12->mac->dinfo, NULL, &macoct);\n    if ((maclen != (unsigned int)ASN1_STRING_length(macoct))\n        || CRYPTO_memcmp(mac, ASN1_STRING_get0_data(macoct), maclen) != 0)\n        return 0;\n\n    return 1;\n}\n\n/* Set a mac */\n\nint PKCS12_set_mac(PKCS12 *p12, const char *pass, int passlen,\n                   unsigned char *salt, int saltlen, int iter,\n                   const EVP_MD *md_type)\n{\n    unsigned char mac[EVP_MAX_MD_SIZE];\n    unsigned int maclen;\n    ASN1_OCTET_STRING *macoct;\n\n    if (md_type == NULL)\n        /* No need to do a fetch as the md_type is used only to get a NID */\n        md_type = EVP_sha256();\n    if (!iter)\n        iter = PKCS12_DEFAULT_ITER;\n    if (PKCS12_setup_mac(p12, iter, salt, saltlen, md_type) == PKCS12_ERROR) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_MAC_SETUP_ERROR);\n        return 0;\n    }\n    /*\n     * Note that output mac is forced to UTF-8...\n     */\n    if (!pkcs12_gen_mac(p12, pass, passlen, mac, &maclen, NULL)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_MAC_GENERATION_ERROR);\n        return 0;\n    }\n    X509_SIG_getm(p12->mac->dinfo, NULL, &macoct);\n    if (!ASN1_OCTET_STRING_set(macoct, mac, maclen)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_MAC_STRING_SET_ERROR);\n        return 0;\n    }\n    return 1;\n}\n\n/* Set up a mac structure */\nint PKCS12_setup_mac(PKCS12 *p12, int iter, unsigned char *salt, int saltlen,\n                     const EVP_MD *md_type)\n{\n    X509_ALGOR *macalg;\n\n    PKCS12_MAC_DATA_free(p12->mac);\n    p12->mac = NULL;\n\n    if ((p12->mac = PKCS12_MAC_DATA_new()) == NULL)\n        return PKCS12_ERROR;\n    if (iter > 1) {\n        if ((p12->mac->iter = ASN1_INTEGER_new()) == NULL) {\n            ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n            return 0;\n        }\n        if (!ASN1_INTEGER_set(p12->mac->iter, iter)) {\n            ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n            return 0;\n        }\n    }\n    if (saltlen == 0)\n        saltlen = PKCS12_SALT_LEN;\n    else if (saltlen < 0)\n        return 0;\n    if ((p12->mac->salt->data = OPENSSL_malloc(saltlen)) == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    p12->mac->salt->length = saltlen;\n    if (salt == NULL) {\n        if (RAND_bytes_ex(p12->authsafes->ctx.libctx, p12->mac->salt->data,\n                          (size_t)saltlen, 0) <= 0)\n            return 0;\n    } else {\n        memcpy(p12->mac->salt->data, salt, saltlen);\n    }\n    X509_SIG_getm(p12->mac->dinfo, &macalg, NULL);\n    if (!X509_ALGOR_set0(macalg, OBJ_nid2obj(EVP_MD_get_type(md_type)),\n                         V_ASN1_NULL, NULL)) {\n        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    return 1;\n}\n", "/*\n * Copyright 1999-2020 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the Apache License 2.0 (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/pkcs12.h>\n#include \"p12_local.h\"\n\n/* PKCS#12 password change routine */\n\nstatic int newpass_p12(PKCS12 *p12, const char *oldpass, const char *newpass);\nstatic int newpass_bags(STACK_OF(PKCS12_SAFEBAG) *bags, const char *oldpass,\n                        const char *newpass);\nstatic int newpass_bag(PKCS12_SAFEBAG *bag, const char *oldpass,\n                        const char *newpass);\nstatic int alg_get(const X509_ALGOR *alg, int *pnid, int *piter,\n                   int *psaltlen);\n\n/*\n * Change the password on a PKCS#12 structure.\n */\n\nint PKCS12_newpass(PKCS12 *p12, const char *oldpass, const char *newpass)\n{\n    /* Check for NULL PKCS12 structure */\n\n    if (p12 == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_INVALID_NULL_PKCS12_POINTER);\n        return 0;\n    }\n\n    /* Check the mac */\n\n    if (!PKCS12_verify_mac(p12, oldpass, -1)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_MAC_VERIFY_FAILURE);\n        return 0;\n    }\n\n    if (!newpass_p12(p12, oldpass, newpass)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_PARSE_ERROR);\n        return 0;\n    }\n\n    return 1;\n}\n\n/* Parse the outer PKCS#12 structure */\n\nstatic int newpass_p12(PKCS12 *p12, const char *oldpass, const char *newpass)\n{\n    STACK_OF(PKCS7) *asafes = NULL, *newsafes = NULL;\n    STACK_OF(PKCS12_SAFEBAG) *bags = NULL;\n    int i, bagnid, pbe_nid = 0, pbe_iter = 0, pbe_saltlen = 0;\n    PKCS7 *p7, *p7new;\n    ASN1_OCTET_STRING *p12_data_tmp = NULL, *macoct = NULL;\n    unsigned char mac[EVP_MAX_MD_SIZE];\n    unsigned int maclen;\n    int rv = 0;\n\n    if ((asafes = PKCS12_unpack_authsafes(p12)) == NULL)\n        goto err;\n    if ((newsafes = sk_PKCS7_new_null()) == NULL)\n        goto err;\n    for (i = 0; i < sk_PKCS7_num(asafes); i++) {\n        p7 = sk_PKCS7_value(asafes, i);\n        bagnid = OBJ_obj2nid(p7->type);\n        if (bagnid == NID_pkcs7_data) {\n            bags = PKCS12_unpack_p7data(p7);\n        } else if (bagnid == NID_pkcs7_encrypted) {\n            bags = PKCS12_unpack_p7encdata(p7, oldpass, -1);\n            if (p7->d.encrypted == NULL\n                    || !alg_get(p7->d.encrypted->enc_data->algorithm,\n                                &pbe_nid, &pbe_iter, &pbe_saltlen))\n                goto err;\n        } else {\n            continue;\n        }\n        if (bags == NULL)\n            goto err;\n        if (!newpass_bags(bags, oldpass, newpass))\n            goto err;\n        /* Repack bag in same form with new password */\n        if (bagnid == NID_pkcs7_data)\n            p7new = PKCS12_pack_p7data(bags);\n        else\n            p7new = PKCS12_pack_p7encdata(pbe_nid, newpass, -1, NULL,\n                                          pbe_saltlen, pbe_iter, bags);\n        if (p7new == NULL || !sk_PKCS7_push(newsafes, p7new))\n            goto err;\n        sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);\n        bags = NULL;\n    }\n\n    /* Repack safe: save old safe in case of error */\n\n    p12_data_tmp = p12->authsafes->d.data;\n    if ((p12->authsafes->d.data = ASN1_OCTET_STRING_new()) == NULL)\n        goto err;\n    if (!PKCS12_pack_authsafes(p12, newsafes))\n        goto err;\n\n    if (!PKCS12_gen_mac(p12, newpass, -1, mac, &maclen))\n        goto err;\n    X509_SIG_getm(p12->mac->dinfo, NULL, &macoct);\n    if (!ASN1_OCTET_STRING_set(macoct, mac, maclen))\n        goto err;\n\n    rv = 1;\n\nerr:\n    /* Restore old safe if necessary */\n    if (rv == 1) {\n        ASN1_OCTET_STRING_free(p12_data_tmp);\n    } else if (p12_data_tmp != NULL) {\n        ASN1_OCTET_STRING_free(p12->authsafes->d.data);\n        p12->authsafes->d.data = p12_data_tmp;\n    }\n    sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);\n    sk_PKCS7_pop_free(asafes, PKCS7_free);\n    sk_PKCS7_pop_free(newsafes, PKCS7_free);\n    return rv;\n}\n\nstatic int newpass_bags(STACK_OF(PKCS12_SAFEBAG) *bags, const char *oldpass,\n                        const char *newpass)\n{\n    int i;\n    for (i = 0; i < sk_PKCS12_SAFEBAG_num(bags); i++) {\n        if (!newpass_bag(sk_PKCS12_SAFEBAG_value(bags, i), oldpass, newpass))\n            return 0;\n    }\n    return 1;\n}\n\n/* Change password of safebag: only needs handle shrouded keybags */\n\nstatic int newpass_bag(PKCS12_SAFEBAG *bag, const char *oldpass,\n                       const char *newpass)\n{\n    PKCS8_PRIV_KEY_INFO *p8;\n    X509_SIG *p8new;\n    int p8_nid, p8_saltlen, p8_iter;\n    const X509_ALGOR *shalg;\n\n    if (PKCS12_SAFEBAG_get_nid(bag) != NID_pkcs8ShroudedKeyBag)\n        return 1;\n\n    if ((p8 = PKCS8_decrypt(bag->value.shkeybag, oldpass, -1)) == NULL)\n        return 0;\n    X509_SIG_get0(bag->value.shkeybag, &shalg, NULL);\n    if (!alg_get(shalg, &p8_nid, &p8_iter, &p8_saltlen)) {\n        PKCS8_PRIV_KEY_INFO_free(p8);\n        return 0;\n    }\n    p8new = PKCS8_encrypt(p8_nid, NULL, newpass, -1, NULL, p8_saltlen,\n                          p8_iter, p8);\n    PKCS8_PRIV_KEY_INFO_free(p8);\n    if (p8new == NULL)\n        return 0;\n    X509_SIG_free(bag->value.shkeybag);\n    bag->value.shkeybag = p8new;\n    return 1;\n}\n\nstatic int alg_get(const X509_ALGOR *alg, int *pnid, int *piter,\n                   int *psaltlen)\n{\n    PBEPARAM *pbe;\n\n    pbe = ASN1_TYPE_unpack_sequence(ASN1_ITEM_rptr(PBEPARAM), alg->parameter);\n    if (pbe == NULL)\n        return 0;\n    *pnid = OBJ_obj2nid(alg->algorithm);\n    *piter = ASN1_INTEGER_get(pbe->iter);\n    *psaltlen = pbe->salt->length;\n    PBEPARAM_free(pbe);\n    return 1;\n}\n", "/*\n * Copyright 1999-2021 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the Apache License 2.0 (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#include <stdio.h>\n#include \"internal/cryptlib.h\"\n#include <openssl/x509.h>\n#include <openssl/asn1.h>\n#include \"pk7_local.h\"\n\n/* PKCS#7 wrappers round generalised stream and MIME routines */\n\nint i2d_PKCS7_bio_stream(BIO *out, PKCS7 *p7, BIO *in, int flags)\n{\n    return i2d_ASN1_bio_stream(out, (ASN1_VALUE *)p7, in, flags,\n                               ASN1_ITEM_rptr(PKCS7));\n}\n\nint PEM_write_bio_PKCS7_stream(BIO *out, PKCS7 *p7, BIO *in, int flags)\n{\n    return PEM_write_bio_ASN1_stream(out, (ASN1_VALUE *)p7, in, flags,\n                                     \"PKCS7\", ASN1_ITEM_rptr(PKCS7));\n}\n\nint SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags)\n{\n    STACK_OF(X509_ALGOR) *mdalgs;\n    int ctype_nid = OBJ_obj2nid(p7->type);\n    const PKCS7_CTX *ctx = ossl_pkcs7_get0_ctx(p7);\n\n    if (ctype_nid == NID_pkcs7_signed) {\n        if (p7->d.sign == NULL)\n            return 0;\n        mdalgs = p7->d.sign->md_algs;\n    } else {\n        mdalgs = NULL;\n    }\n\n    flags ^= SMIME_OLDMIME;\n\n    return SMIME_write_ASN1_ex(bio, (ASN1_VALUE *)p7, data, flags, ctype_nid,\n                               NID_undef, mdalgs, ASN1_ITEM_rptr(PKCS7),\n                               ossl_pkcs7_ctx_get0_libctx(ctx),\n                               ossl_pkcs7_ctx_get0_propq(ctx));\n}\n\nPKCS7 *SMIME_read_PKCS7_ex(BIO *bio, BIO **bcont, PKCS7 **p7)\n{\n    PKCS7 *ret;\n    OSSL_LIB_CTX *libctx = NULL;\n    const char *propq = NULL;\n\n    if (p7 != NULL && *p7 != NULL) {\n        libctx = (*p7)->ctx.libctx;\n        propq = (*p7)->ctx.propq;\n    }\n\n    ret = (PKCS7 *)SMIME_read_ASN1_ex(bio, 0, bcont, ASN1_ITEM_rptr(PKCS7),\n                                      (ASN1_VALUE **)p7, libctx, propq);\n    if (ret != NULL)\n        ossl_pkcs7_resolve_libctx(ret);\n    return ret;\n}\n\nPKCS7 *SMIME_read_PKCS7(BIO *bio, BIO **bcont)\n{\n    return SMIME_read_PKCS7_ex(bio, bcont, NULL);\n}\n"], "filenames": ["crypto/pkcs12/p12_add.c", "crypto/pkcs12/p12_mutl.c", "crypto/pkcs12/p12_npas.c", "crypto/pkcs7/pk7_mime.c"], "buggy_code_start_loc": [80, 97, 80, 36], "buggy_code_end_loc": [190, 97, 82, 39], "fixing_code_start_loc": [81, 98, 80, 36], "fixing_code_end_loc": [209, 103, 83, 43], "type": "NVD-CWE-noinfo", "message": "Issue summary: Processing a maliciously formatted PKCS12 file may lead OpenSSL\nto crash leading to a potential Denial of Service attack\n\nImpact summary: Applications loading files in the PKCS12 format from untrusted\nsources might terminate abruptly.\n\nA file in PKCS12 format can contain certificates and keys and may come from an\nuntrusted source. The PKCS12 specification allows certain fields to be NULL, but\nOpenSSL does not correctly check for this case. This can lead to a NULL pointer\ndereference that results in OpenSSL crashing. If an application processes PKCS12\nfiles from an untrusted source using the OpenSSL APIs then that application will\nbe vulnerable to this issue.\n\nOpenSSL APIs that are vulnerable to this are: PKCS12_parse(),\nPKCS12_unpack_p7data(), PKCS12_unpack_p7encdata(), PKCS12_unpack_authsafes()\nand PKCS12_newpass().\n\nWe have also fixed a similar issue in SMIME_write_PKCS7(). However since this\nfunction is related to writing data we do not consider it security significant.\n\nThe FIPS modules in 3.2, 3.1 and 3.0 are not affected by this issue.", "other": {"cve": {"id": "CVE-2024-0727", "sourceIdentifier": "openssl-security@openssl.org", "published": "2024-01-26T09:15:07.637", "lastModified": "2024-02-08T10:15:13.910", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Issue summary: Processing a maliciously formatted PKCS12 file may lead OpenSSL\nto crash leading to a potential Denial of Service attack\n\nImpact summary: Applications loading files in the PKCS12 format from untrusted\nsources might terminate abruptly.\n\nA file in PKCS12 format can contain certificates and keys and may come from an\nuntrusted source. The PKCS12 specification allows certain fields to be NULL, but\nOpenSSL does not correctly check for this case. This can lead to a NULL pointer\ndereference that results in OpenSSL crashing. If an application processes PKCS12\nfiles from an untrusted source using the OpenSSL APIs then that application will\nbe vulnerable to this issue.\n\nOpenSSL APIs that are vulnerable to this are: PKCS12_parse(),\nPKCS12_unpack_p7data(), PKCS12_unpack_p7encdata(), PKCS12_unpack_authsafes()\nand PKCS12_newpass().\n\nWe have also fixed a similar issue in SMIME_write_PKCS7(). However since this\nfunction is related to writing data we do not consider it security significant.\n\nThe FIPS modules in 3.2, 3.1 and 3.0 are not affected by this issue."}, {"lang": "es", "value": "Resumen del problema: el procesamiento de un archivo PKCS12 con formato malintencionado puede hacer que OpenSSL falle y provoque un posible ataque de denegaci\u00f3n de servicio. Resumen de impacto: las aplicaciones que cargan archivos en formato PKCS12 desde fuentes que no son de confianza pueden finalizar abruptamente. Un archivo en formato PKCS12 puede contener certificados y claves y puede provenir de una fuente que no es de confianza. La especificaci\u00f3n PKCS12 permite que ciertos campos sean NULL, pero OpenSSL no verifica correctamente este caso. Esto puede provocar una desreferencia del puntero NULL que provoque el bloqueo de OpenSSL. Si una aplicaci\u00f3n procesa archivos PKCS12 de una fuente que no es de confianza utilizando las API de OpenSSL, esa aplicaci\u00f3n ser\u00e1 vulnerable a este problema. Las API de OpenSSL que son vulnerables a esto son: PKCS12_parse(), PKCS12_unpack_p7data(), PKCS12_unpack_p7encdata(), PKCS12_unpack_authsafes() y PKCS12_newpass(). Tambi\u00e9n solucionamos un problema similar en SMIME_write_PKCS7(). Sin embargo, dado que esta funci\u00f3n est\u00e1 relacionada con la escritura de datos, no la consideramos importante para la seguridad. Los m\u00f3dulos FIPS en 3.2, 3.1 y 3.0 no se ven afectados por este problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openssl:openssl:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.0.2", "versionEndExcluding": "1.0.2zj", "matchCriteriaId": "E30B9424-68AA-4ED4-A1CB-3DA32A2350EC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openssl:openssl:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.1.1", "versionEndExcluding": "1.1.1x", "matchCriteriaId": "93CF937D-2520-44AF-B40B-B41720BEAB36"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openssl:openssl:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.0.13", "matchCriteriaId": "21346C7C-ED3A-43D4-BBCB-41D62F7ACBF2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openssl:openssl:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.1.0", "versionEndExcluding": "3.1.5", "matchCriteriaId": "AAD34F57-90D2-415F-9544-70B594D04E53"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openssl:openssl:3.2.0:-:*:*:*:*:*:*", "matchCriteriaId": "AA5220D8-3CAD-4524-BA73-1656FB437446"}]}]}], "references": [{"url": "https://github.com/openssl/openssl/commit/09df4395b5071217b76dc7d3d2e630eb8c5a79c2", "source": "openssl-security@openssl.org", "tags": ["Patch"]}, {"url": "https://github.com/openssl/openssl/commit/775acfdbd0c6af9ac855f34969cdab0c0c90844a", "source": "openssl-security@openssl.org", "tags": ["Patch"]}, {"url": "https://github.com/openssl/openssl/commit/d135eeab8a5dbf72b3da5240bab9ddb7678dbd2c", "source": "openssl-security@openssl.org", "tags": ["Patch"]}, {"url": "https://github.openssl.org/openssl/extended-releases/commit/03b3941d60c4bce58fab69a0c22377ab439bc0e8", "source": "openssl-security@openssl.org", "tags": ["Patch"]}, {"url": "https://github.openssl.org/openssl/extended-releases/commit/aebaa5883e31122b404e450732dc833dc9dee539", "source": "openssl-security@openssl.org", "tags": ["Patch"]}, {"url": "https://security.netapp.com/advisory/ntap-20240208-0006/", "source": "openssl-security@openssl.org"}, {"url": "https://www.openssl.org/news/secadv/20240125.txt", "source": "openssl-security@openssl.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/openssl/openssl/commit/09df4395b5071217b76dc7d3d2e630eb8c5a79c2"}}