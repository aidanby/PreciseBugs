{"buggy_code": ["\nc     libmeshb example : transform a quadrilateral mesh into a triangular one\nc     using fast block transfer and pipelined post processing\n\n      include 'libmeshb7.ins'\n\n      external qad2tri, movver\n\n      integer n\n      parameter (n=4000)\n      integer i, ver, dim, res\n     +, RefTab(n), TriTab(4,2*n), QadTab(5,n)\n      integer*8 NmbVer, NmbQad, InpMsh, OutMsh\n      real*8 VerTab(3,n)\n\n\nc     --------------------------------------------\nc     Open the quadrilateral mesh file for reading\nc     --------------------------------------------\n\n      InpMsh = gmfopenmesh('../sample_meshes/quad.meshb'\n     +,GmfRead,ver,dim)\n      print*, 'input mesh  :', InpMsh,'version :',ver,'dim :',dim\n\n      if(InpMsh.eq.0) STOP ' InpMsh = 0'\n      if(dim.ne.3) STOP ' dimension <> 3'\n\nc     Check memory bounds\n      NmbVer = gmfstatkwd(InpMsh, GmfVertices)\n      if(NmbVer.gt.n) STOP 'Too many vertices'\n\n      i = gmfstatkwd(InpMsh, GmfSolAtQuadrilaterals)\n      print*, i,'GmfSolAtQuadrilaterals'\n\n      NmbQad = gmfstatkwd(InpMsh, GmfQuadrilaterals)\n      if(NmbQad.gt.n) STOP 'Too many quads'\n\n      print*, 'input mesh  : ',NmbVer,' vertices,',NmbQad,'quads'\n\nc     Read the vertices\n      res = gmfgetblock(InpMsh, GmfVertices, 1_8, NmbVer,\n     +                  movver, 1, VerTab,\n     +                  GmfDouble, VerTab(1,1), VerTab(1,2),\n     +                  GmfDouble, VerTab(2,1), VerTab(2,2),\n     +                  GmfDouble, VerTab(3,1), VerTab(3,2),\n     +                  GmfInt,    RefTab(1),   RefTab(2))\n\nc     Read the quads\n      res = gmfgetblock(InpMsh, GmfQuadrilaterals, 1_8, NmbQad,0,\n     +                  GmfInt, QadTab(1,1), QadTab(1,2),\n     +                  GmfInt, QadTab(2,1), QadTab(2,2),\n     +                  GmfInt, QadTab(3,1), QadTab(3,2),\n     +                  GmfInt, QadTab(4,1), QadTab(4,2),\n     +                  GmfInt, QadTab(5,1), QadTab(5,2))\n\nc     Close the quadrilateral mesh\n      res = gmfclosemesh(InpMsh)\n      print*, QadTab(1,1),QadTab(2,1),QadTab(3,1),QadTab(4,1)\n\n\nc     ------------------------\nc     Create a triangular mesh\nc     ------------------------\n\n      OutMsh = gmfopenmesh('tri.meshb', GmfWrite, ver, dim)\n      if(OutMsh.eq.0) STOP ' OutMsh = 0'\n\nc     Set the number of vertices\n      res = gmfsetkwd(OutMsh, GmfVertices, NmbVer, 0 , 0)\n\nc     Then write them down\n      res = gmfsetblock(OutMsh, GmfVertices, 1_8, NmbVer,\n     +                  0, %val(0) ,%val(0),\n     +                  GmfDouble, VerTab(1,1), VerTab(1,2),\n     +                  GmfDouble, VerTab(2,1), VerTab(2,2),\n     +                  GmfDouble, VerTab(3,1), VerTab(3,2),\n     +                  GmfInt,    RefTab(1),   RefTab(2))\n\nc     Write the triangles\n      res = gmfsetkwd(OutMsh, GmfTriangles, 2*NmbQad, 0, 0)\n      res = gmfsetblock(OutMsh, GmfTriangles, 1_8, 2*NmbQad,\n     +                  0,%val(0),%val(0),\n     +                  qad2tri, 2, QadTab, TriTab,\n     +                  GmfInt, TriTab(1,1), TriTab(1,2),\n     +                  GmfInt, TriTab(2,1), TriTab(2,2),\n     +                  GmfInt, TriTab(3,1), TriTab(3,2),\n     +                  GmfInt, TriTab(4,1), TriTab(4,2))\n\nc     Don't forget to close the file\n      res = gmfclosemesh(OutMsh)\n\n      print*, 'output mesh : ',NmbVer,' vertices,',\n     +         2*NmbQad,'triangles'\n\n      end      \n\n\n\n      subroutine qad2tri(BegIdx,EndIdx,QadTab,TriTab)\n\n      integer*8 i,BegIdx,EndIdx\n      integer TriTab(4,*),QadTab(5,*)\n      print*, 'beg : ',BegIdx, 'end : ', EndIdx\n\n      do i = BegIdx,EndIdx\n          if(mod(i,2) .EQ. 1) then\n              TriTab(1,i) = QadTab(1,i/2)\n              TriTab(2,i) = QadTab(2,i/2)\n              TriTab(3,i) = QadTab(3,i/2)\n              TriTab(4,i) = QadTab(5,i/2)\n          else\n              TriTab(1,i) = QadTab(1,i/2)\n              TriTab(2,i) = QadTab(3,i/2)\n              TriTab(3,i) = QadTab(4,i/2)\n              TriTab(4,i) = QadTab(5,i/2)\n          endif\n      end do\n\n      return\n      end\n\n\n      subroutine movver(BegIdx,EndIdx,VerTab)\n\n      integer*8 i,BegIdx,EndIdx\n      real*8 VerTab(3,*)\n      print*, 'beg : ',BegIdx, 'end : ', EndIdx\n\n      do i = BegIdx,EndIdx\n          VerTab(1,i) = VerTab(1,i)*2\n      end do\n\n      return\n      end\n", "\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*                               LIBMESHB V7.61                               */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*   Description:        handles .meshb file format I/O                       */\n/*   Author:             Loic MARECHAL                                        */\n/*   Creation date:      dec 09 1999                                          */\n/*   Last modification:  sep 27 2021                                          */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\n\n/*----------------------------------------------------------------------------*/\n/* Headers' macros                                                            */\n/*----------------------------------------------------------------------------*/\n\n// Silent Visual Studio warnings on string functions\n#define _CRT_SECURE_NO_WARNINGS\n\n#ifdef F77API\n\n// Add a final underscore to Fortran procedure names\n#ifdef F77_NO_UNDER_SCORE\n#define NAMF77(c,f)  f\n#define APIF77(x)    x\n#else\n#define NAMF77(c,f)  f ## _\n#define APIF77(x)    x ## _\n#endif\n\n// Pass parameters as pointers in Fortran\n#define VALF77(v)    *v\n#define TYPF77(t)    t*\n\n#else\n\n// Pass parameters as values in C\n#define NAMF77(c,f)  c\n#define VALF77(v)    v\n#define TYPF77(t)    t\n\n#endif\n\n\n/*----------------------------------------------------------------------------*/\n/* Includes                                                                   */\n/*----------------------------------------------------------------------------*/\n\n#define _XOPEN_SOURCE 500\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include <setjmp.h>\n#include <fcntl.h>\n\n \n/*\n * [Bruno] include the headers with the prototypes for \n *  open()/close()/write()/lseek() \n *  and define the constants to be used to open() a file. \n *   Under Windows, \n *  1)   _O_BINARY should be set in the flags.\n *  2) 'mode' has a completely different meaning\n */\n\n#if defined(__unix__) || defined(__linux__) || defined(__APPLE__) || defined(__EMSCRIPTEN__)\n\n#include <unistd.h>\n\n#define OPEN_READ_FLAGS   O_RDONLY\n#define OPEN_WRITE_FLAGS  O_CREAT | O_WRONLY | O_TRUNC\n#define OPEN_READ_MODE    0666\n#define OPEN_WRITE_MODE   0666   \n   \n#elif defined(_WIN32) || defined(_WIN64)\n\n#define GMF_WINDOWS\n\n#include <windows.h>\n#include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <wchar.h>\n\n#define OPEN_READ_FLAGS    O_RDONLY | _O_BINARY\n#define OPEN_WRITE_FLAGS   O_CREAT | O_WRONLY | O_TRUNC | _O_BINARY\n#define OPEN_READ_MODE     _S_IREAD\n#define OPEN_WRITE_MODE    _S_IREAD | S_IWRITE \n\n#endif\n\n\n#if defined(_WIN64)\n#define MYFTELL(s) (int64_t)_ftelli64(s)\n#define MYFSEEK(s,o,w) _fseeki64(s,(__int64)o,w)\n#else\n#define MYFTELL(s) ftell(s)\n#define MYFSEEK(s,o,w) fseek(s,o,w)\n#endif\n\n\n#include <errno.h>\n#include <libmeshb7.h>\n\n// [Bruno] Using portable printf modifier from pstdint.h\n// (alternative: use \"%zd\" under Linux and \"%Id\" under Windows)\n\n#ifdef PRINTF_INT64_MODIFIER\n#define INT64_T_FMT \"%\" PRINTF_INT64_MODIFIER \"d\"\n#else\n#   ifdef GMF_WINDOWS\n#    define INT64_T_FMT \"%Id\"\n#   else\n#    include <inttypes.h>\n#    define INT64_T_FMT \"%\" PRId64\n#   endif\n#endif\n\n\n// AIO: hardware or software mockup are both encapsulated into my_aio functions\n\n#ifdef WITH_GMF_AIO\n\n#include <aio.h>\n\nint    my_aio_error (const struct aiocb *aiocbp){return(aio_error (aiocbp));}\nint    my_aio_read  (      struct aiocb *aiocbp){return(aio_read  (aiocbp));}\nsize_t my_aio_return(      struct aiocb *aiocbp){return(aio_return(aiocbp));}\nint    my_aio_write (      struct aiocb *aiocbp){return(aio_write (aiocbp));}\n\n#else\n\n// Mockup aio library\n\nstruct aiocb\n{\n   FILE   *aio_fildes;         // File descriptor\n   off_t  aio_offset;          // File offset\n   void   *aio_buf;            // Location of buffer\n   size_t aio_nbytes;          // Length of transfer\n   int    aio_lio_opcode;      // Operation to be performed\n};\n\nint my_aio_error(const struct aiocb *aiocbp)\n{\n   return(aiocbp->aio_lio_opcode);\n}\n\n// Set the file position and read a block of data\nint my_aio_read(struct aiocb *aiocbp)\n{\n   if( (MYFSEEK(aiocbp->aio_fildes, (off_t)aiocbp->aio_offset, SEEK_SET) == 0)\n   &&  (fread(aiocbp->aio_buf, 1, aiocbp->aio_nbytes, aiocbp->aio_fildes)\n       == aiocbp->aio_nbytes) )\n   {\n      aiocbp->aio_lio_opcode = 0;\n   }\n   else\n   {\n      aiocbp->aio_lio_opcode = -1;\n   }\n\n   return(aiocbp->aio_lio_opcode);\n}\n\nsize_t my_aio_return(struct aiocb *aiocbp)\n{\n   return(aiocbp->aio_nbytes);\n}\n\n// Set the file position and write a block of data\nint my_aio_write(struct aiocb *aiocbp)\n{\n   if( (MYFSEEK(aiocbp->aio_fildes, (off_t)aiocbp->aio_offset, SEEK_SET) == 0)\n   &&  (fwrite(aiocbp->aio_buf, 1, aiocbp->aio_nbytes, aiocbp->aio_fildes)\n       == aiocbp->aio_nbytes) )\n   {\n      aiocbp->aio_lio_opcode = 0;\n   }\n   else\n   {\n      aiocbp->aio_lio_opcode = -1;\n   }\n\n   return(aiocbp->aio_lio_opcode);\n}\n\n#endif\n\n\n/*----------------------------------------------------------------------------*/\n/* Defines                                                                    */\n/*----------------------------------------------------------------------------*/\n\n#define Asc       1\n#define Bin       2\n#define MshFil    4\n#define SolFil    8\n#define InfKwd    1\n#define RegKwd    2\n#define SolKwd    3\n#define CmtKwd    4\n#define WrdSiz    4\n#define FilStrSiz 64\n#define BufSiz    10000L\n#define MaxArg    20\n\n\n\n/*----------------------------------------------------------------------------*/\n/* Structures                                                                 */\n/*----------------------------------------------------------------------------*/\n\ntypedef struct\n{\n   int      typ, deg, NmbNod, SolSiz, NmbWrd, NmbTyp, TypTab[ GmfMaxTyp ];\n   int      *OrdTab;\n   int64_t  NmbLin;\n   size_t   pos;\n   char     fmt[ GmfMaxTyp*9 ];\n}KwdSct;\n\ntypedef struct\n{\n   int      dim, ver, mod, typ, cod, FilDes, FltSiz;\n   int64_t  NexKwdPos, siz;\n   size_t   pos;\n   jmp_buf  err;\n   KwdSct   KwdTab[ GmfMaxKwd + 1 ];\n   FILE     *hdl;\n   int      *IntBuf;\n   float    *FltBuf;\n   char     *buf;\n   char     FilNam[ GmfStrSiz ];\n   double   DblBuf[1000/8];\n   unsigned char blk[ BufSiz + 1000L ];\n}GmfMshSct;\n\n\n/*----------------------------------------------------------------------------*/\n/* Global variables                                                           */\n/*----------------------------------------------------------------------------*/\n\nconst char *GmfKwdFmt[ GmfMaxKwd + 1 ][3] = \n{\n   {\"Reserved\",                                 \"\", \"\"},\n   {\"MeshVersionFormatted\",                     \"\", \"i\"},\n   {\"Reserved\",                                 \"\", \"\"},\n   {\"Dimension\",                                \"\", \"i\"},\n   {\"Vertices\",                                 \"i\", \"dri\"},\n   {\"Edges\",                                    \"i\", \"iii\"},\n   {\"Triangles\",                                \"i\", \"iiii\"},\n   {\"Quadrilaterals\",                           \"i\", \"iiiii\"},\n   {\"Tetrahedra\",                               \"i\", \"iiiii\"},\n   {\"Prisms\",                                   \"i\", \"iiiiiii\"},\n   {\"Hexahedra\",                                \"i\", \"iiiiiiiii\"},\n   {\"Reserved\",                                 \"\",  \"\"},\n   {\"Reserved\",                                 \"\",  \"\"},\n   {\"Corners\",                                  \"i\", \"i\"},\n   {\"Ridges\",                                   \"i\", \"i\"},\n   {\"RequiredVertices\",                         \"i\", \"i\"},\n   {\"RequiredEdges\",                            \"i\", \"i\"},\n   {\"RequiredTriangles\",                        \"i\", \"i\"},\n   {\"RequiredQuadrilaterals\",                   \"i\", \"i\"},\n   {\"TangentAtEdgeVertices\",                    \"i\", \"iii\"},\n   {\"NormalAtVertices\",                         \"i\", \"ii\"},\n   {\"NormalAtTriangleVertices\",                 \"i\", \"iii\"},\n   {\"NormalAtQuadrilateralVertices\",            \"i\", \"iiii\"},\n   {\"AngleOfCornerBound\",                       \"\",  \"r\"},\n   {\"TrianglesP2\",                              \"i\", \"iiiiiii\"},\n   {\"EdgesP2\",                                  \"i\", \"iiii\"},\n   {\"SolAtPyramids\",                            \"i\", \"sr\"},\n   {\"QuadrilateralsQ2\",                         \"i\", \"iiiiiiiiii\"},\n   {\"ISolAtPyramids\",                           \"i\", \"iiiii\"},\n   {\"SubDomainFromGeom\",                        \"i\", \"iii\"},\n   {\"TetrahedraP2\",                             \"i\", \"iiiiiiiiiii\"},\n   {\"Fault_NearTri\",                            \"i\", \"i\"},\n   {\"Fault_Inter\",                              \"i\", \"i\"},\n   {\"HexahedraQ2\",                              \"i\", \"iiiiiiiiiiiiiiiiiiiiiiiiiiii\"},\n   {\"ExtraVerticesAtEdges\",                     \"i\", \"in\"},\n   {\"ExtraVerticesAtTriangles\",                 \"i\", \"in\"},\n   {\"ExtraVerticesAtQuadrilaterals\",            \"i\", \"in\"},\n   {\"ExtraVerticesAtTetrahedra\",                \"i\", \"in\"},\n   {\"ExtraVerticesAtPrisms\",                    \"i\", \"in\"},\n   {\"ExtraVerticesAtHexahedra\",                 \"i\", \"in\"},\n   {\"VerticesOnGeometricVertices\",              \"i\", \"ii\"},\n   {\"VerticesOnGeometricEdges\",                 \"i\", \"iirr\"},\n   {\"VerticesOnGeometricTriangles\",             \"i\", \"iirrr\"},\n   {\"VerticesOnGeometricQuadrilaterals\",        \"i\", \"iirrr\"},\n   {\"EdgesOnGeometricEdges\",                    \"i\", \"ii\"},\n   {\"Fault_FreeEdge\",                           \"i\", \"i\"},\n   {\"Polyhedra\",                                \"i\", \"iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\"},\n   {\"Polygons\",                                 \"\",  \"iiiiiiiii\"},\n   {\"Fault_Overlap\",                            \"i\", \"i\"},\n   {\"Pyramids\",                                 \"i\", \"iiiiii\"},\n   {\"BoundingBox\",                              \"\",  \"drdr\"},\n   {\"Reserved\",                                 \"\",  \"\"},\n   {\"PrivateTable\",                             \"i\", \"i\"},\n   {\"Fault_BadShape\",                           \"i\", \"i\"},\n   {\"End\",                                      \"\",  \"\"},\n   {\"TrianglesOnGeometricTriangles\",            \"i\", \"ii\"},\n   {\"TrianglesOnGeometricQuadrilaterals\",       \"i\", \"ii\"},\n   {\"QuadrilateralsOnGeometricTriangles\",       \"i\", \"ii\"},\n   {\"QuadrilateralsOnGeometricQuadrilaterals\",  \"i\", \"ii\"},\n   {\"Tangents\",                                 \"i\", \"dr\"},\n   {\"Normals\",                                  \"i\", \"dr\"},\n   {\"TangentAtVertices\",                        \"i\", \"ii\"},\n   {\"SolAtVertices\",                            \"i\", \"sr\"},\n   {\"SolAtEdges\",                               \"i\", \"sr\"},\n   {\"SolAtTriangles\",                           \"i\", \"sr\"},\n   {\"SolAtQuadrilaterals\",                      \"i\", \"sr\"},\n   {\"SolAtTetrahedra\",                          \"i\", \"sr\"},\n   {\"SolAtPrisms\",                              \"i\", \"sr\"},\n   {\"SolAtHexahedra\",                           \"i\", \"sr\"},\n   {\"DSolAtVertices\",                           \"i\", \"sr\"},\n   {\"ISolAtVertices\",                           \"i\", \"i\"},\n   {\"ISolAtEdges\",                              \"i\", \"ii\"},\n   {\"ISolAtTriangles\",                          \"i\", \"iii\"},\n   {\"ISolAtQuadrilaterals\",                     \"i\", \"iiii\"},\n   {\"ISolAtTetrahedra\",                         \"i\", \"iiii\"},\n   {\"ISolAtPrisms\",                             \"i\", \"iiiiii\"},\n   {\"ISolAtHexahedra\",                          \"i\", \"iiiiiiii\"},\n   {\"Iterations\",                               \"\",  \"i\"},\n   {\"Time\",                                     \"\",  \"r\"},\n   {\"Fault_SmallTri\",                           \"i\", \"i\"},\n   {\"CoarseHexahedra\",                          \"i\", \"i\"},\n   {\"Comments\",                                 \"i\", \"c\"},\n   {\"PeriodicVertices\",                         \"i\", \"ii\"},\n   {\"PeriodicEdges\",                            \"i\", \"ii\"},\n   {\"PeriodicTriangles\",                        \"i\", \"ii\"},\n   {\"PeriodicQuadrilaterals\",                   \"i\", \"ii\"},\n   {\"PrismsP2\",                                 \"i\", \"iiiiiiiiiiiiiiiiiii\"},\n   {\"PyramidsP2\",                               \"i\", \"iiiiiiiiiiiiiii\"},\n   {\"QuadrilateralsQ3\",                         \"i\", \"iiiiiiiiiiiiiiiii\"},\n   {\"QuadrilateralsQ4\",                         \"i\", \"iiiiiiiiiiiiiiiiiiiiiiiiii\"},\n   {\"TrianglesP3\",                              \"i\", \"iiiiiiiiiii\"},\n   {\"TrianglesP4\",                              \"i\", \"iiiiiiiiiiiiiiii\"},\n   {\"EdgesP3\",                                  \"i\", \"iiiii\"},\n   {\"EdgesP4\",                                  \"i\", \"iiiiii\"},\n   {\"IRefGroups\",                               \"i\", \"ciii\"},\n   {\"DRefGroups\",                               \"i\", \"iii\"},\n   {\"TetrahedraP3\",                             \"i\", \"iiiiiiiiiiiiiiiiiiiii\"},\n   {\"TetrahedraP4\",                             \"i\", \"iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\"},\n   {\"HexahedraQ3\",                              \"i\", \"iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\"},\n   {\"HexahedraQ4\",                              \"i\", \"iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\"},\n   {\"PyramidsP3\",                               \"i\", \"iiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\"},\n   {\"PyramidsP4\",                               \"i\", \"iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\"},\n   {\"PrismsP3\",                                 \"i\", \"iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\"},\n   {\"PrismsP4\",                                 \"i\", \"iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\"},\n   {\"HOSolAtEdgesP1\",                           \"i\", \"hr\"},\n   {\"HOSolAtEdgesP2\",                           \"i\", \"hr\"},\n   {\"HOSolAtEdgesP3\",                           \"i\", \"hr\"},\n   {\"HOSolAtTrianglesP1\",                       \"i\", \"hr\"},\n   {\"HOSolAtTrianglesP2\",                       \"i\", \"hr\"},\n   {\"HOSolAtTrianglesP3\",                       \"i\", \"hr\"},\n   {\"HOSolAtQuadrilateralsQ1\",                  \"i\", \"hr\"},\n   {\"HOSolAtQuadrilateralsQ2\",                  \"i\", \"hr\"},\n   {\"HOSolAtQuadrilateralsQ3\",                  \"i\", \"hr\"},\n   {\"HOSolAtTetrahedraP1\",                      \"i\", \"hr\"},\n   {\"HOSolAtTetrahedraP2\",                      \"i\", \"hr\"},\n   {\"HOSolAtTetrahedraP3\",                      \"i\", \"hr\"},\n   {\"HOSolAtPyramidsP1\",                        \"i\", \"hr\"},\n   {\"HOSolAtPyramidsP2\",                        \"i\", \"hr\"},\n   {\"HOSolAtPyramidsP3\",                        \"i\", \"hr\"},\n   {\"HOSolAtPrismsP1\",                          \"i\", \"hr\"},\n   {\"HOSolAtPrismsP2\",                          \"i\", \"hr\"},\n   {\"HOSolAtPrismsP3\",                          \"i\", \"hr\"},\n   {\"HOSolAtHexahedraQ1\",                       \"i\", \"hr\"},\n   {\"HOSolAtHexahedraQ2\",                       \"i\", \"hr\"},\n   {\"HOSolAtHexahedraQ3\",                       \"i\", \"hr\"},\n   {\"BezierBasis\",                              \"\",  \"i\"},\n   {\"ByteFlow\",                                 \"i\", \"i\"},\n   {\"EdgesP2Ordering\",                          \"i\", \"i\"},\n   {\"EdgesP3Ordering\",                          \"i\", \"i\"},\n   {\"TrianglesP2Ordering\",                      \"i\", \"iii\"},\n   {\"TrianglesP3Ordering\",                      \"i\", \"iii\"},\n   {\"QuadrilateralsQ2Ordering\",                 \"i\", \"ii\"},\n   {\"QuadrilateralsQ3Ordering\",                 \"i\", \"ii\"},\n   {\"TetrahedraP2Ordering\",                     \"i\", \"iiii\"},\n   {\"TetrahedraP3Ordering\",                     \"i\", \"iiii\"},\n   {\"PyramidsP2Ordering\",                       \"i\", \"iii\"},\n   {\"PyramidsP3Ordering\",                       \"i\", \"iii\"},\n   {\"PrismsP2Ordering\",                         \"i\", \"iiii\"},\n   {\"PrismsP3Ordering\",                         \"i\", \"iiii\"},\n   {\"HexahedraQ2Ordering\",                      \"i\", \"iii\"},\n   {\"HexahedraQ3Ordering\",                      \"i\", \"iii\"},\n   {\"EdgesP1Ordering\",                          \"i\", \"i\"},\n   {\"EdgesP4Ordering\",                          \"i\", \"i\"},\n   {\"TrianglesP1Ordering\",                      \"i\", \"iii\"},\n   {\"TrianglesP4Ordering\",                      \"i\", \"iii\"},\n   {\"QuadrilateralsQ1Ordering\",                 \"i\", \"ii\"},\n   {\"QuadrilateralsQ4Ordering\",                 \"i\", \"ii\"},\n   {\"TetrahedraP1Ordering\",                     \"i\", \"iiii\"},\n   {\"TetrahedraP4Ordering\",                     \"i\", \"iiii\"},\n   {\"PyramidsP1Ordering\",                       \"i\", \"iii\"},\n   {\"PyramidsP4Ordering\",                       \"i\", \"iii\"},\n   {\"PrismsP1Ordering\",                         \"i\", \"iiii\"},\n   {\"PrismsP4Ordering\",                         \"i\", \"iiii\"},\n   {\"HexahedraQ1Ordering\",                      \"i\", \"iii\"},\n   {\"HexahedraQ4Ordering\",                      \"i\", \"iii\"},\n   {\"FloatingPointPrecision\",                   \"\",  \"i\"},\n   {\"HOSolAtEdgesP4\",                           \"i\", \"hr\"},\n   {\"HOSolAtTrianglesP4\",                       \"i\", \"hr\"},\n   {\"HOSolAtQuadrilateralsQ4\",                  \"i\", \"hr\"},\n   {\"HOSolAtTetrahedraP4\",                      \"i\", \"hr\"},\n   {\"HOSolAtPyramidsP4\",                        \"i\", \"hr\"},\n   {\"HOSolAtPrismsP4\",                          \"i\", \"hr\"},\n   {\"HOSolAtHexahedraQ4\",                       \"i\", \"hr\"},\n   {\"HOSolAtEdgesP1NodesPositions\",             \"i\", \"rr\"},\n   {\"HOSolAtEdgesP2NodesPositions\",             \"i\", \"rr\"},\n   {\"HOSolAtEdgesP3NodesPositions\",             \"i\", \"rr\"},\n   {\"HOSolAtEdgesP4NodesPositions\",             \"i\", \"rr\"},\n   {\"HOSolAtTrianglesP1NodesPositions\",         \"i\", \"rrr\"},\n   {\"HOSolAtTrianglesP2NodesPositions\",         \"i\", \"rrr\"},\n   {\"HOSolAtTrianglesP3NodesPositions\",         \"i\", \"rrr\"},\n   {\"HOSolAtTrianglesP4NodesPositions\",         \"i\", \"rrr\"},\n   {\"HOSolAtQuadrilateralsQ1NodesPositions\",    \"i\", \"rr\"},\n   {\"HOSolAtQuadrilateralsQ2NodesPositions\",    \"i\", \"rr\"},\n   {\"HOSolAtQuadrilateralsQ3NodesPositions\",    \"i\", \"rr\"},\n   {\"HOSolAtQuadrilateralsQ4NodesPositions\",    \"i\", \"rr\"},\n   {\"HOSolAtTetrahedraP1NodesPositions\",        \"i\", \"rrrr\"},\n   {\"HOSolAtTetrahedraP2NodesPositions\",        \"i\", \"rrrr\"},\n   {\"HOSolAtTetrahedraP3NodesPositions\",        \"i\", \"rrrr\"},\n   {\"HOSolAtTetrahedraP4NodesPositions\",        \"i\", \"rrrr\"},\n   {\"HOSolAtPyramidsP1NodesPositions\",          \"i\", \"rrr\"},\n   {\"HOSolAtPyramidsP2NodesPositions\",          \"i\", \"rrr\"},\n   {\"HOSolAtPyramidsP3NodesPositions\",          \"i\", \"rrr\"},\n   {\"HOSolAtPyramidsP4NodesPositions\",          \"i\", \"rrr\"},\n   {\"HOSolAtPrismsP1NodesPositions\",            \"i\", \"rrrr\"},\n   {\"HOSolAtPrismsP2NodesPositions\",            \"i\", \"rrrr\"},\n   {\"HOSolAtPrismsP3NodesPositions\",            \"i\", \"rrrr\"},\n   {\"HOSolAtPrismsP4NodesPositions\",            \"i\", \"rrrr\"},\n   {\"HOSolAtHexahedraQ1NodesPositions\",         \"i\", \"rrr\"},\n   {\"HOSolAtHexahedraQ2NodesPositions\",         \"i\", \"rrr\"},\n   {\"HOSolAtHexahedraQ3NodesPositions\",         \"i\", \"rrr\"},\n   {\"HOSolAtHexahedraQ4NodesPositions\",         \"i\", \"rrr\"},\n   {\"EdgesReferenceElement\",                    \"\",  \"rr\"},\n   {\"TriangleReferenceElement\",                 \"\",  \"rrrrrr\"},\n   {\"QuadrilateralReferenceElement\",            \"\",  \"rrrrrrrr\"},\n   {\"TetrahedronReferenceElement\",              \"\",  \"rrrrrrrrrrrr\"},\n   {\"PyramidReferenceElement\",                  \"\",  \"rrrrrrrrrrrrrrr\"},\n   {\"PrismReferenceElement\",                    \"\",  \"rrrrrrrrrrrrrrrrrr\"},\n   {\"HexahedronReferenceElement\",               \"\",  \"rrrrrrrrrrrrrrrrrrrrrrrr\"},\n   {\"BoundaryLayers\",                           \"i\", \"iii\"},\n   {\"ReferenceStrings\",                         \"i\", \"iic\"},\n   {\"Prisms9\",                                  \"i\", \"iiiiiiiiii\"},\n   {\"Hexahedra12\",                              \"i\", \"iiiiiiiiiiiii\"},\n   {\"Quadrilaterals6\",                          \"i\", \"iiiiiii\"},\n   {\"BoundaryPolygonHeaders\",                   \"i\", \"ii\"},\n   {\"BoundaryPolygonVertices\",                  \"i\", \"i\"},\n   {\"InnerPolygonHeaders\",                      \"i\", \"ii\"},\n   {\"InnerPolygonVertices\",                     \"i\", \"i\"},\n   {\"PolyhedraHeaders\",                         \"i\", \"ii\"},\n   {\"PolyhedraFaces\",                           \"i\", \"i\"},\n   {\"Domains\",                                  \"\",  \"ii\"},\n   {\"VerticesGID\",                              \"i\", \"iii\"},\n   {\"EdgesGID\",                                 \"i\", \"iii\"},\n   {\"TrianglesGID\",                             \"i\", \"iii\"},\n   {\"QuadrilateralsGID\",                        \"i\", \"iii\"},\n   {\"TetrahedraGID\",                            \"i\", \"iii\"},\n   {\"PyramidsGID\",                              \"i\", \"iii\"},\n   {\"PrismsGID\",                                \"i\", \"iii\"},\n   {\"HexahedraGID\",                             \"i\", \"iii\"},\n};\n\n#ifdef TRANSMESH\nint GmfMaxRefTab[ GmfMaxKwd + 1 ];\n#endif\n\n\n/*----------------------------------------------------------------------------*/\n/* Prototypes of local procedures                                             */\n/*----------------------------------------------------------------------------*/\n\nstatic void    ScaWrd   (GmfMshSct *, void *);\nstatic void    ScaDblWrd(GmfMshSct *, void *);\nstatic int64_t GetPos   (GmfMshSct *);\nstatic void    RecWrd   (GmfMshSct *, const void *);\nstatic void    RecDblWrd(GmfMshSct *, const void *);\nstatic void    RecBlk   (GmfMshSct *, const void *, int);\nstatic void    SetPos   (GmfMshSct *, int64_t);\nstatic int     ScaKwdTab(GmfMshSct *);\nstatic void    ExpFmt   (GmfMshSct *, int);\nstatic void    ScaKwdHdr(GmfMshSct *, int);\nstatic void    SwpWrd   (char *, int);\nstatic int     SetFilPos(GmfMshSct *, int64_t);\nstatic int64_t GetFilPos(GmfMshSct *msh);\nstatic int64_t GetFilSiz(GmfMshSct *);\n#ifdef F77API\nstatic void    CalF77Prc(int64_t, int64_t, void *, int, void **);\n#endif\n\n\n/*----------------------------------------------------------------------------*/\n/* Fscanf and fgets checking for errors                                       */\n/*----------------------------------------------------------------------------*/\n\n#define safe_fscanf(hdl, format, ptr, JmpErr) \\\n   do { \\\n      if( fscanf(hdl, format, ptr) != 1 ) \\\n         longjmp( JmpErr, -1); \\\n   } while(0)\n\n\n#define safe_fgets(ptr, siz, hdl, JmpErr) \\\n   do { \\\n      if( fgets(ptr, siz, hdl) == NULL ) \\\n         longjmp( JmpErr, -2); \\\n   } while(0)\n\n\n#define safe_fread(ptr, siz, nit, str, JmpErr) \\\n   do { \\\n      if( fread(ptr, siz, nit, str) != nit ) \\\n         longjmp( JmpErr, -3); \\\n   } while(0)\n\n\n/*----------------------------------------------------------------------------*/\n/* Open a mesh file in read or write mode                                     */\n/*----------------------------------------------------------------------------*/\n\nint64_t GmfOpenMesh(const char *FilNam, int mod, ...)\n{\n   int      KwdCod, res, *PtrVer, *PtrDim, err;\n   int64_t  MshIdx;\n   char     str[ GmfStrSiz ];\n   va_list  VarArg;\n   GmfMshSct *msh;\n\n   /*---------------------*/\n   /* MESH STRUCTURE INIT */\n   /*---------------------*/\n\n   if(!(msh = calloc(1, sizeof(GmfMshSct))))\n      return(0);\n\n   MshIdx = (int64_t)msh;\n\n   // Save the current stack environment for longjmp\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(msh->hdl != NULL)\n         fclose(msh->hdl);\n\n      if(msh->FilDes != 0)\n#ifdef GMF_WINDOWS\n         _close(msh->FilDes);\n#else\n         close(msh->FilDes);\n#endif\n\n      free(msh);\n      return(0);\n   }\n\n   // Copy the FilNam into the structure\n   if(strlen(FilNam) + 7 >= GmfStrSiz)\n      longjmp(msh->err, -4);\n\n   strcpy(msh->FilNam, FilNam);\n\n   // Store the opening mod (read or write) and guess\n   // the filetype (binary or ascii) depending on the extension\n   msh->mod = mod;\n   msh->buf = (void *)msh->DblBuf;\n   msh->FltBuf = (void *)msh->DblBuf;\n   msh->IntBuf = (void *)msh->DblBuf;\n\n   if(strstr(msh->FilNam, \".meshb\"))\n      msh->typ |= (Bin | MshFil);\n   else if(strstr(msh->FilNam, \".mesh\"))\n      msh->typ |= (Asc | MshFil);\n   else if(strstr(msh->FilNam, \".solb\"))\n      msh->typ |= (Bin | SolFil);\n   else if(strstr(msh->FilNam, \".sol\"))\n      msh->typ |= (Asc | SolFil);\n   else\n      longjmp(msh->err, -5);\n\n   // Open the file in the required mod and initialize the mesh structure\n   if(msh->mod == GmfRead)\n   {\n\n      /*-----------------------*/\n      /* OPEN FILE FOR READING */\n      /*-----------------------*/\n\n      va_start(VarArg, mod);\n      PtrVer = va_arg(VarArg, int *);\n      PtrDim = va_arg(VarArg, int *);\n      va_end(VarArg);\n\n      // Read the endian coding tag, the mesh version\n      // and the mesh dimension (mandatory kwd)\n      if(msh->typ & Bin)\n      {\n         // Create the name string and open the file\n#ifdef WITH_GMF_AIO\n         // [Bruno] added binary flag (necessary under Windows)\n         msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE);\n\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -6);\n\n         // Read the endian coding tag\n         if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz)\n            longjmp(msh->err, -7);\n#else\n         // [Bruno] added binary flag (necessary under Windows)\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -8);\n\n         // Read the endian coding tag\n         safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err);\n#endif\n\n         // Read the mesh version and the mesh dimension (mandatory kwd)\n         if( (msh->cod != 1) && (msh->cod != 16777216) )\n            longjmp(msh->err, -9);\n\n         ScaWrd(msh, (unsigned char *)&msh->ver);\n\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -10);\n\n         if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n            longjmp(msh->err, -11);\n\n         ScaWrd(msh, (unsigned char *)&KwdCod);\n\n         if(KwdCod != GmfDimension)\n            longjmp(msh->err, -12);\n\n         GetPos(msh);\n         ScaWrd(msh, (unsigned char *)&msh->dim);\n      }\n      else\n      {\n         // Create the name string and open the file\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -13);\n\n         do\n         {\n            res = fscanf(msh->hdl, \"%s\", str);\n         }while( (res != EOF) && strcmp(str, \"MeshVersionFormatted\") );\n\n         if(res == EOF)\n            longjmp(msh->err, -14);\n\n         safe_fscanf(msh->hdl, \"%d\", &msh->ver, msh->err);\n\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -15);\n\n         do\n         {\n            res = fscanf(msh->hdl, \"%s\", str);\n         }while( (res != EOF) && strcmp(str, \"Dimension\") );\n\n         if(res == EOF)\n            longjmp(msh->err, -16);\n\n         safe_fscanf(msh->hdl, \"%d\", &msh->dim, msh->err);\n      }\n\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -17);\n\n      (*PtrVer) = msh->ver;\n      (*PtrDim) = msh->dim;\n\n      // Set default real numbers size\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n\n      /*------------*/\n      /* KW READING */\n      /*------------*/\n\n      // Read the list of kw present in the file\n      if(!ScaKwdTab(msh))\n         return(0);\n\n      return(MshIdx);\n   }\n   else if(msh->mod == GmfWrite)\n   {\n\n      /*-----------------------*/\n      /* OPEN FILE FOR WRITING */\n      /*-----------------------*/\n\n      msh->cod = 1;\n\n      // Check if the user provided a valid version number and dimension\n      va_start(VarArg, mod);\n      msh->ver = va_arg(VarArg, int);\n      msh->dim = va_arg(VarArg, int);\n      va_end(VarArg);\n\n      if( (msh->ver < 1) || (msh->ver > 4) )\n         longjmp(msh->err, -18);\n\n      if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n         longjmp(msh->err, -19);\n\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -20);\n\n      // Set default real numbers size\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n\n      // Create the mesh file\n      if(msh->typ & Bin) \n      {\n         /* \n          * [Bruno] replaced previous call to creat():\n          * with a call to open(), because Windows needs the\n          * binary flag to be specified.\n          */\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE);\n\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -21);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n            longjmp(msh->err, -22);\n#endif\n      }\n      else if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n         longjmp(msh->err, -23);\n\n\n      /*------------*/\n      /* KW WRITING */\n      /*------------*/\n\n      // Write the mesh version and dimension\n      if(msh->typ & Asc)\n      {\n         fprintf(msh->hdl, \"%s %d\\n\\n\",\n               GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver);\n         fprintf(msh->hdl, \"%s %d\\n\",\n               GmfKwdFmt[ GmfDimension ][0], msh->dim);\n      }\n      else\n      {\n         RecWrd(msh, (unsigned char *)&msh->cod);\n         RecWrd(msh, (unsigned char *)&msh->ver);\n         GmfSetKwd(MshIdx, GmfDimension, 0);\n         RecWrd(msh, (unsigned char *)&msh->dim);\n      }\n\n      return(MshIdx);\n   }\n   else\n   {\n      free(msh);\n      return(0);\n   }\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Close a meshfile in the right way                                          */\n/*----------------------------------------------------------------------------*/\n\nint GmfCloseMesh(int64_t MshIdx)\n{\n   int i, res = 1;\n   GmfMshSct *msh = (GmfMshSct *)MshIdx;\n\n   RecBlk(msh, msh->buf, 0);\n\n   // In write down the \"End\" kw in write mode\n   if(msh->mod == GmfWrite)\n   {\n      if(msh->typ & Asc)\n         fprintf(msh->hdl, \"\\n%s\\n\", GmfKwdFmt[ GmfEnd ][0]);\n      else\n         GmfSetKwd(MshIdx, GmfEnd, 0);\n   }\n\n   // Close the file and free the mesh structure\n   if(msh->typ & Bin)\n#ifdef WITH_GMF_AIO\n      close(msh->FilDes);\n#else\n      fclose(msh->hdl);\n#endif\n   else if(fclose(msh->hdl))\n      res = 0;\n\n   // Free optional H.O. renumbering tables\n   for(i=0;i<GmfLastKeyword;i++)\n      if(msh->KwdTab[i].OrdTab)\n         free(msh->KwdTab[i].OrdTab);\n\n   free(msh);\n\n   return(res);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Read the number of lines and set the position to this kwd                  */\n/*----------------------------------------------------------------------------*/\n\nint64_t GmfStatKwd(int64_t MshIdx, int KwdCod, ...)\n{\n   int         i, *PtrNmbTyp, *PtrSolSiz, *TypTab, *PtrDeg, *PtrNmbNod;\n   GmfMshSct   *msh = (GmfMshSct *)MshIdx;\n   KwdSct      *kwd;\n   va_list     VarArg;\n\n   if( (KwdCod < 1) || (KwdCod > GmfMaxKwd) )\n      return(0);\n\n   kwd = &msh->KwdTab[ KwdCod ];\n\n   if(!kwd->NmbLin)\n      return(0);\n\n   // Read further arguments if this kw is a sol\n   if(kwd->typ == SolKwd)\n   {\n      va_start(VarArg, KwdCod);\n\n      PtrNmbTyp = va_arg(VarArg, int *);\n      *PtrNmbTyp = kwd->NmbTyp;\n\n      PtrSolSiz = va_arg(VarArg, int *);\n      *PtrSolSiz = kwd->SolSiz;\n\n      TypTab = va_arg(VarArg, int *);\n\n      for(i=0;i<kwd->NmbTyp;i++)\n         TypTab[i] = kwd->TypTab[i];\n\n      // Add two extra paramaters for HO elements: degree and nmb nodes\n      if(!strcmp(\"hr\", GmfKwdFmt[ KwdCod ][2]) )\n      {\n         PtrDeg = va_arg(VarArg, int *);\n         *PtrDeg = kwd->deg;\n         \n         PtrNmbNod = va_arg(VarArg, int *);\n         *PtrNmbNod = kwd->NmbNod;\n      }\n\n      va_end(VarArg);\n   }\n\n   return(kwd->NmbLin);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Set the current file position to a given kwd                               */\n/*----------------------------------------------------------------------------*/\n\nint GmfGotoKwd(int64_t MshIdx, int KwdCod)\n{\n   GmfMshSct   *msh = (GmfMshSct *)MshIdx;\n   KwdSct      *kwd = &msh->KwdTab[ KwdCod ];\n\n   if( (KwdCod < 1) || (KwdCod > GmfMaxKwd) || !kwd->NmbLin )\n      return(0);\n\n   return(SetFilPos(msh, kwd->pos));\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Write the kwd and set the number of lines                                  */\n/*----------------------------------------------------------------------------*/\n\nint GmfSetKwd(int64_t MshIdx, int KwdCod, int64_t NmbLin, ...)\n{\n   int         i, *TypTab;\n   int64_t     CurPos;\n   va_list     VarArg;\n   GmfMshSct   *msh = (GmfMshSct *)MshIdx;\n   KwdSct      *kwd;\n\n   RecBlk(msh, msh->buf, 0);\n\n   if( (KwdCod < 1) || (KwdCod > GmfMaxKwd) )\n      return(0);\n\n   kwd = &msh->KwdTab[ KwdCod ];\n\n   // Read further arguments if this kw is a solution\n   if(!strcmp(GmfKwdFmt[ KwdCod ][2], \"sr\")\n   || !strcmp(GmfKwdFmt[ KwdCod ][2], \"hr\"))\n   {\n      va_start(VarArg, NmbLin);\n\n      kwd->NmbTyp = va_arg(VarArg, int);\n      TypTab = va_arg(VarArg, int *);\n\n      for(i=0;i<kwd->NmbTyp;i++)\n         kwd->TypTab[i] = TypTab[i];\n\n      // Add two extra paramaters for HO elements: degree and nmb nodes\n      if(!strcmp(\"hr\", GmfKwdFmt[ KwdCod ][2]))\n      {\n         kwd->deg = va_arg(VarArg, int);\n         kwd->NmbNod = va_arg(VarArg, int);\n      }\n\n      va_end(VarArg);\n   }\n\n   // Setup the kwd info\n   ExpFmt(msh, KwdCod);\n\n   if(!kwd->typ)\n      return(0);\n   else if(kwd->typ == InfKwd)\n      kwd->NmbLin = 1;\n   else\n      kwd->NmbLin = NmbLin;\n\n   // Store the next kwd position in binary file\n   if( (msh->typ & Bin) && msh->NexKwdPos )\n   {\n      CurPos = GetFilPos(msh);\n\n      if(!SetFilPos(msh, msh->NexKwdPos))\n         return(0);\n\n      SetPos(msh, CurPos);\n\n      if(!SetFilPos(msh, CurPos))\n         return(0);\n   }\n\n   // Write the header\n   if(msh->typ & Asc)\n   {\n      fprintf(msh->hdl, \"\\n%s\\n\", GmfKwdFmt[ KwdCod ][0]);\n\n      if(kwd->typ != InfKwd)\n         fprintf(msh->hdl, INT64_T_FMT\"\\n\", kwd->NmbLin);\n\n      // In case of solution field, write the extended header\n      if(kwd->typ == SolKwd)\n      {\n         fprintf(msh->hdl, \"%d \", kwd->NmbTyp);\n\n         for(i=0;i<kwd->NmbTyp;i++)\n            fprintf(msh->hdl, \"%d \", kwd->TypTab[i]);\n\n         fprintf(msh->hdl, \"\\n\");\n      }\n\n      if(!strcmp(\"hr\", GmfKwdFmt[ KwdCod ][2]))\n         fprintf(msh->hdl, \"%d %d\\n\", kwd->deg, kwd->NmbNod);\n   }\n   else\n   {\n      RecWrd(msh, (unsigned char *)&KwdCod);\n      msh->NexKwdPos = GetFilPos(msh);\n      SetPos(msh, 0);\n\n      if(kwd->typ != InfKwd)\n      {\n         if(msh->ver < 4)\n         {\n            i = (int)kwd->NmbLin;\n            RecWrd(msh, (unsigned char *)&i);\n         }\n         else\n            RecDblWrd(msh, (unsigned char *)&kwd->NmbLin);\n      }\n\n      // In case of solution field, write the extended header at once\n      if(kwd->typ == SolKwd)\n      {\n         RecWrd(msh, (unsigned char *)&kwd->NmbTyp);\n\n         for(i=0;i<kwd->NmbTyp;i++)\n            RecWrd(msh, (unsigned char *)&kwd->TypTab[i]);\n\n         if(!strcmp(\"hr\", GmfKwdFmt[ KwdCod ][2]))\n         {\n            RecWrd(msh, (unsigned char *)&kwd->deg);\n            RecWrd(msh, (unsigned char *)&kwd->NmbNod);\n         }\n      }\n   }\n\n   // Reset write buffer position\n   msh->pos = 0;\n\n   // Compute the total file size and check if it crosses the 2GB threshold\n   msh->siz += kwd->NmbLin * kwd->NmbWrd * WrdSiz;\n\n   return(1);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Read a full line from the current kwd                                      */\n/*----------------------------------------------------------------------------*/\n\nint NAMF77(GmfGetLin, gmfgetlin)(TYPF77(int64_t)MshIdx, TYPF77(int)KwdCod, ...)\n{\n   int         i, err;\n   float       *FltSolTab, FltVal, *PtrFlt;\n   double      *DblSolTab, *PtrDbl;\n   va_list     VarArg;\n   GmfMshSct   *msh = (GmfMshSct *) VALF77(MshIdx);\n   KwdSct      *kwd = &msh->KwdTab[ VALF77(KwdCod) ];\n\n   if( (VALF77(KwdCod) < 1) || (VALF77(KwdCod) > GmfMaxKwd) )\n      return(0);\n\n   // Save the current stack environment for longjmp\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      return(0);\n   }\n\n   // Start decoding the arguments\n   va_start(VarArg, KwdCod);\n\n   switch(kwd->typ)\n   {\n      case InfKwd : case RegKwd : case CmtKwd :\n      {\n         if(msh->typ & Asc)\n         {\n            for(i=0;i<kwd->SolSiz;i++)\n            {\n               if(kwd->fmt[i] == 'r')\n               {\n                  if(msh->FltSiz == 32)\n                  {\n                     safe_fscanf(msh->hdl, \"%f\", &FltVal, msh->err);\n                     PtrDbl = va_arg(VarArg, double *);\n                     PtrFlt = (float *)PtrDbl;\n                     *PtrFlt = FltVal;\n                  }                     \n                  else\n                  {\n                     safe_fscanf(msh->hdl, \"%lf\",\n                              va_arg(VarArg, double *), msh->err);\n                  }\n               }\n               else if(kwd->fmt[i] == 'i')\n               {\n                  if(msh->ver <= 3)\n                  {\n                     safe_fscanf(msh->hdl, \"%d\",\n                        va_arg(VarArg, int *), msh->err);\n                  }\n                  else\n                  {\n                     // [Bruno] %ld -> INT64_T_FMT\n                     safe_fscanf(msh->hdl, INT64_T_FMT,\n                              va_arg(VarArg, int64_t *), msh->err);\n                  }\n               }\n               else if(kwd->fmt[i] == 'c')\n               {\n                  safe_fgets( va_arg(VarArg, char *),\n                              WrdSiz * FilStrSiz, msh->hdl, msh->err);\n               }\n            }\n         }\n         else\n         {\n            for(i=0;i<kwd->SolSiz;i++)\n               if(kwd->fmt[i] == 'r')\n                  if(msh->FltSiz == 32)\n                     ScaWrd(msh, (unsigned char *)va_arg(VarArg, float *));\n                  else\n                     ScaDblWrd(msh, (unsigned char *)va_arg(VarArg, double *));\n               else if(kwd->fmt[i] == 'i')\n                  if(msh->ver <= 3)\n                     ScaWrd(msh, (unsigned char *)va_arg(VarArg, int *));\n                  else\n                     ScaDblWrd(msh, (unsigned char *)va_arg(VarArg, int64_t *));\n               else if(kwd->fmt[i] == 'c')\n                  // [Bruno] added error control\n                  safe_fread(va_arg(VarArg, char *), WrdSiz, FilStrSiz, msh->hdl, msh->err);\n         }\n      }break;\n\n      case SolKwd :\n      {\n         if(msh->FltSiz == 32)\n         {\n            FltSolTab = va_arg(VarArg, float *);\n\n            if(msh->typ & Asc)\n               for(i=0; i<kwd->SolSiz; i++)\n                  safe_fscanf(msh->hdl, \"%f\", &FltSolTab[i], msh->err);\n            else\n               for(i=0; i<kwd->SolSiz; i++)\n                  ScaWrd(msh, (unsigned char *)&FltSolTab[i]);\n         }\n         else\n         {\n            DblSolTab = va_arg(VarArg, double *);\n\n            if(msh->typ & Asc)\n               for(i=0; i<kwd->SolSiz; i++)\n                  safe_fscanf(msh->hdl, \"%lf\", &DblSolTab[i], msh->err);\n            else\n               for(i=0; i<kwd->SolSiz; i++)\n                  ScaDblWrd(msh, (unsigned char *)&DblSolTab[i]);\n         }\n      }break;\n   }\n\n   va_end(VarArg);\n\n   return(1);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Write a full line from the current kwd                                     */\n/*----------------------------------------------------------------------------*/\n\nint NAMF77(GmfSetLin, gmfsetlin)(TYPF77(int64_t) MshIdx, TYPF77(int) KwdCod, ...)\n{\n   int         i, pos, *IntBuf, err;\n   int64_t     *LngBuf;\n   float       *FltSolTab, *FltBuf;\n   double      *DblSolTab, *DblBuf;\n   va_list     VarArg;\n   GmfMshSct   *msh = (GmfMshSct *) VALF77(MshIdx);\n   KwdSct      *kwd = &msh->KwdTab[ VALF77(KwdCod) ];\n\n   if( ( VALF77(KwdCod) < 1) || ( VALF77(KwdCod) > GmfMaxKwd) )\n      return(0);\n\n   // Save the current stack environment for longjmp\n   // This is needed in RecBlk()\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      return(0);\n   }\n\n   // Start decoding the arguments\n   va_start(VarArg, KwdCod);\n\n   if(kwd->typ != SolKwd)\n   {\n      if(msh->typ & Asc)\n      {\n         for(i=0;i<kwd->SolSiz;i++)\n         {\n            if(kwd->fmt[i] == 'r')\n            {\n               if(msh->FltSiz == 32)\n#ifdef F77API\n                  fprintf(msh->hdl, \"%.9g \", *(va_arg(VarArg, float *)));\n#else\n                  fprintf(msh->hdl, \"%.9g \", va_arg(VarArg, double));\n#endif\n               else\n                  fprintf(msh->hdl, \"%.17g \", VALF77(va_arg(VarArg, TYPF77(double))));\n            }\n            else if(kwd->fmt[i] == 'i')\n            {\n               if(msh->ver <= 3)\n                  fprintf(msh->hdl, \"%d \", VALF77(va_arg(VarArg, TYPF77(int))));\n               else\n               {\n                  // [Bruno] %ld -> INT64_T_FMT\n                  fprintf( msh->hdl, INT64_T_FMT \" \",\n                           VALF77(va_arg(VarArg, TYPF77(int64_t))));\n               }\n            }\n            else if(kwd->fmt[i] == 'c')\n               fprintf(msh->hdl, \"%s \", va_arg(VarArg, char *));\n         }\n      }\n      else\n      {\n         pos = 0;\n\n         for(i=0;i<kwd->SolSiz;i++)\n         {\n            if(kwd->fmt[i] == 'r')\n            {\n               if(msh->FltSiz == 32)\n               {\n                  FltBuf = (void *)&msh->buf[ pos ];\n#ifdef F77API\n                  *FltBuf = (float)*(va_arg(VarArg, float *));\n#else\n                  *FltBuf = (float)va_arg(VarArg, double);\n#endif\n                  pos += 4;\n               }\n               else\n               {\n                  DblBuf = (void *)&msh->buf[ pos ];\n                  *DblBuf = VALF77(va_arg(VarArg, TYPF77(double)));\n                  pos += 8;\n               }\n            }\n            else if(kwd->fmt[i] == 'i')\n            {\n               if(msh->ver <= 3)\n               {\n                  IntBuf = (void *)&msh->buf[ pos ];\n                  *IntBuf = VALF77(va_arg(VarArg, TYPF77(int)));\n                  pos += 4;\n               }\n               else\n               {\n                  LngBuf = (void *)&msh->buf[ pos ];\n                  *LngBuf = VALF77(va_arg(VarArg, TYPF77(int64_t)));\n                  pos += 8;\n               }\n            }\n            else if(kwd->fmt[i] == 'c')\n            {\n               memset(&msh->buf[ pos ], 0, FilStrSiz * WrdSiz);\n               strncpy(&msh->buf[ pos ], va_arg(VarArg, char *), FilStrSiz * WrdSiz);\n               pos += FilStrSiz;\n            }\n         }\n\n         RecBlk(msh, msh->buf, kwd->NmbWrd);\n      }\n   }\n   else\n   {\n      if(msh->FltSiz == 32)\n      {\n         FltSolTab = va_arg(VarArg, float *);\n\n         if(msh->typ & Asc)\n            for(i=0; i<kwd->SolSiz; i++)\n               fprintf(msh->hdl, \"%.9g \", (double)FltSolTab[i]);\n         else\n            RecBlk(msh, (unsigned char *)FltSolTab, kwd->NmbWrd);\n      }\n      else\n      {\n         DblSolTab = va_arg(VarArg, double *);\n\n         if(msh->typ & Asc)\n            for(i=0; i<kwd->SolSiz; i++)\n               fprintf(msh->hdl, \"%.17g \", DblSolTab[i]);\n         else\n            RecBlk(msh, (unsigned char *)DblSolTab, kwd->NmbWrd);\n      }\n   }\n\n   va_end(VarArg);\n\n   if(msh->typ & Asc)\n      fprintf(msh->hdl, \"\\n\");\n\n   return(1);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Private procedure for mesh : copy a whole line                             */\n/*----------------------------------------------------------------------------*/\n\n#ifdef TRANSMESH\n\nint GmfCpyLin(int64_t InpIdx, int64_t OutIdx, int KwdCod)\n{\n   char        s[ WrdSiz * FilStrSiz ];\n   double      d;\n   float       f;\n   int         i, a, err;\n   int64_t     l;\n   GmfMshSct   *InpMsh = (GmfMshSct *)InpIdx, *OutMsh = (GmfMshSct *)OutIdx;\n   KwdSct      *kwd = &InpMsh->KwdTab[ KwdCod ];\n\n   // Save the current stack environment for longjmp\n   if( (err = setjmp(InpMsh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", InpMsh, err);\n#endif\n      return(0);\n   }\n\n   for(i=0;i<kwd->SolSiz;i++)\n   {\n      if(kwd->fmt[i] == 'r')\n      {\n         if(InpMsh->FltSiz == 32)\n         {\n            if(InpMsh->typ & Asc)\n               safe_fscanf(InpMsh->hdl, \"%f\", &f, InpMsh->err);\n            else\n               ScaWrd(InpMsh, (unsigned char *)&f);\n\n            d = (double)f;\n         }\n         else\n         {\n            if(InpMsh->typ & Asc)\n               safe_fscanf(InpMsh->hdl, \"%lf\", &d, InpMsh->err);\n            else\n               ScaDblWrd(InpMsh, (unsigned char *)&d);\n\n            f = (float)d;\n         }\n\n         if(OutMsh->FltSiz == 32)\n            if(OutMsh->typ & Asc)\n               fprintf(OutMsh->hdl, \"%.9g \", (double)f);\n            else\n               RecWrd(OutMsh, (unsigned char *)&f);\n         else\n            if(OutMsh->typ & Asc)\n               fprintf(OutMsh->hdl, \"%.17g \", d);\n            else\n               RecDblWrd(OutMsh, (unsigned char *)&d);\n      }\n      else if(kwd->fmt[i] == 'i')\n      {\n         if(InpMsh->ver <= 3)\n         {\n            if(InpMsh->typ & Asc)\n               safe_fscanf(InpMsh->hdl, \"%d\", &a, InpMsh->err);\n            else\n               ScaWrd(InpMsh, (unsigned char *)&a);\n\n            l = (int64_t)a;\n         }\n         else\n         {\n            if(InpMsh->typ & Asc)\n               safe_fscanf(InpMsh->hdl, INT64_T_FMT, &l, InpMsh->err);\n            else\n               ScaDblWrd(InpMsh, (unsigned char *)&l);\n\n            a = (int)l;\n         }\n\n         if( (i == kwd->SolSiz-1) && (a > GmfMaxRefTab[ KwdCod ]) )\n            GmfMaxRefTab[ KwdCod ] = a;\n\n         if(OutMsh->ver <= 3)\n         {\n            if(OutMsh->typ & Asc)\n               fprintf(OutMsh->hdl, \"%d \", a);\n            else\n               RecWrd(OutMsh, (unsigned char *)&a);\n         }\n         else\n         {\n            if(OutMsh->typ & Asc)\n               fprintf(OutMsh->hdl, INT64_T_FMT\" \", l);\n            else\n               RecDblWrd(OutMsh, (unsigned char *)&l);\n         }\n      }\n      else if(kwd->fmt[i] == 'c')\n      {\n         memset(s, 0, FilStrSiz * WrdSiz);\n\n         if(InpMsh->typ & Asc)\n            safe_fgets(s, WrdSiz * FilStrSiz, InpMsh->hdl, InpMsh->err);\n         else\n#ifdef WITH_GMF_AIO\n            read(InpMsh->FilDes, s, WrdSiz * FilStrSiz);\n#else\n            safe_fread(s, WrdSiz, FilStrSiz, InpMsh->hdl, InpMsh->err);\n#endif\n         if(OutMsh->typ & Asc)\n            fprintf(OutMsh->hdl, \"%s \", s);\n         else\n#ifdef WITH_GMF_AIO\n            write(OutMsh->FilDes, s, WrdSiz * FilStrSiz);\n#else\n            fwrite(s, WrdSiz, FilStrSiz, OutMsh->hdl);\n#endif\n      }\n   }\n\n   if(OutMsh->typ & Asc)\n      fprintf(OutMsh->hdl, \"\\n\");\n\n   return(1);\n}\n\n#endif\n\n\n// [Bruno] Made asynchronous I/O optional\n#ifndef WITHOUT_AIO\n\n/*----------------------------------------------------------------------------*/\n/* Bufferized asynchronous reading of all keyword's lines                     */\n/*----------------------------------------------------------------------------*/\n\nint NAMF77(GmfGetBlock, gmfgetblock)(  TYPF77(int64_t) MshIdx,\n                                       TYPF77(int)     KwdCod,\n                                       TYPF77(int64_t) BegIdx,\n                                       TYPF77(int64_t) EndIdx,\n                                       TYPF77(int)     MapTyp,\n                                       void           *MapTab,\n                                       void           *prc, ... )\n{\n   char        *UsrDat[ GmfMaxTyp ], *UsrBas[ GmfMaxTyp ], *FilPos, *EndUsrDat;\n   char        *FilBuf = NULL, *FrtBuf = NULL, *BckBuf = NULL, *BegUsrDat;\n   char        *StrTab[5] = { \"\", \"%f\", \"%lf\", \"%d\", INT64_T_FMT };\n   char        **BegTab, **EndTab;\n   int         i, j, k, *FilPtrI32, *UsrPtrI32, FilTyp[ GmfMaxTyp ];\n   int         UsrTyp[ GmfMaxTyp ], TypSiz[5] = {0,4,8,4,8};\n   int         *IntMapTab = NULL, err, TotSiz = 0, IniFlg = 1, mod = GmfArgLst;\n   int         *TypTab, *SizTab, typ, VecCnt, ArgCnt = 0;\n   float       *FilPtrR32, *UsrPtrR32;\n   double      *FilPtrR64, *UsrPtrR64;\n   int64_t     BlkNmbLin, *FilPtrI64, *UsrPtrI64, BlkBegIdx, BlkEndIdx = 0;\n   int64_t     *LngMapTab = NULL, OldIdx = 0, UsrNmbLin, VecLen;\n   size_t      FilBegIdx = VALF77(BegIdx), FilEndIdx = VALF77(EndIdx);\n   void        (*UsrPrc)(int64_t, int64_t, void *) = NULL;\n   size_t      UsrLen[ GmfMaxTyp ], ret, LinSiz, b, NmbBlk;\n   va_list     VarArg;\n   GmfMshSct   *msh = (GmfMshSct *) VALF77(MshIdx);\n   KwdSct      *kwd = &msh->KwdTab[ VALF77(KwdCod) ];\n   struct      aiocb aio;\n#ifdef F77API\n   int         NmbArg = 0;\n   void        *ArgTab[ MaxArg ];\n#else\n   char        *UsrArg = NULL;\n#endif\n\n   // Save the current stack environment for longjmp\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(BckBuf)\n         free(BckBuf);\n\n      if(FrtBuf)\n         free(FrtBuf);\n\n      return(0);\n   }\n\n   // Check mesh and keyword\n   if( (VALF77(KwdCod) < 1) || (VALF77(KwdCod) > GmfMaxKwd) || !kwd->NmbLin )\n      return(0);\n\n   // Make sure it's not a simple information keyword\n   if( (kwd->typ != RegKwd) && (kwd->typ != SolKwd) )\n      return(0);\n\n   // Check user's bounds\n   if( (FilBegIdx < 1) || (FilBegIdx > FilEndIdx) || (FilEndIdx > (size_t)kwd->NmbLin) )\n      return(0);\n\n   // Compute the number of lines to be read\n   UsrNmbLin = FilEndIdx - FilBegIdx + 1;\n\n   // Get the renumbering map if any\n   if(VALF77(MapTyp) == GmfInt)\n      IntMapTab = (int *)MapTab;\n   else if(VALF77(MapTyp) == GmfLong)\n      LngMapTab = (int64_t *)MapTab;\n\n   // Start decoding the arguments\n   va_start(VarArg, prc);\n   LinSiz = 0;\n\n   // Get the user's preprocessing procedure and argument adresses, if any\n#ifdef F77API\n   if(prc)\n   {\n      UsrPrc = (void (*)(int64_t, int64_t, void *))prc;\n      NmbArg = *(va_arg(VarArg, int *));\n\n      for(i=0;i<NmbArg;i++)\n         ArgTab[i] = va_arg(VarArg, void *);\n   }\n#else\n   if(prc)\n   {\n      UsrPrc = (void (*)(int64_t, int64_t, void *))prc;\n      UsrArg = va_arg(VarArg, void *);\n   }\n#endif\n\n   if( (kwd->typ != RegKwd) && (kwd->typ != SolKwd) )\n      return(0);\n\n   // Read the first data type to select between list and table mode\n   typ = VALF77(va_arg(VarArg, TYPF77(int)));\n\n   // If the table mode is selected, read the four additional tables\n   // containing the arguments: type, vector size, begin and end pointers\n   if(typ == GmfArgTab)\n   {\n      mod = GmfArgTab;\n      TypTab = va_arg(VarArg, int *);\n      SizTab = va_arg(VarArg, int *);\n      BegTab = va_arg(VarArg, char **);\n      EndTab = va_arg(VarArg, char **);\n   }\n\n   // Read the arguments until to total size reaches the keyword's size\n   while(TotSiz < kwd->SolSiz)\n   {\n      // In list mode all arguments are read from the variable argument buffer\n      if(mod == GmfArgLst)\n      {\n         // Do not read the type argument for the first iteration because\n         // it was read befeore the loop begins to get the argument mode\n         if(IniFlg)\n            IniFlg = 0;\n         else\n            typ = VALF77(va_arg(VarArg, TYPF77(int)));\n\n         // In case the type is a vector. get its size and change the type\n         // for the corresponding scalar type\n         if(typ >= GmfFloatVec && typ <= GmfLongVec)\n         {\n            typ -= 4;\n            VecCnt = VALF77(va_arg(VarArg, TYPF77(int)));\n         }\n         else\n            VecCnt = 1;\n\n         BegUsrDat = va_arg(VarArg, char *);\n         EndUsrDat = va_arg(VarArg, char *);\n      }\n      else\n      {\n         // Do exactly the same as above but the arguments are read from\n         // the tables instead of VarArgs\n         typ = TypTab[ ArgCnt ];\n\n         if(typ >= GmfFloatVec && typ <= GmfLongVec)\n         {\n            typ -= 4;\n            VecCnt = SizTab[ ArgCnt ];\n         }\n         else\n            VecCnt = 1;\n\n         BegUsrDat = (char *)BegTab[ ArgCnt ];\n         EndUsrDat = (char *)EndTab[ ArgCnt ];\n         ArgCnt++;\n      }\n\n      if(UsrNmbLin > 1)\n         VecLen = (size_t)(EndUsrDat - BegUsrDat) / (UsrNmbLin - 1);\n      else\n         VecLen = 0;\n\n      // Compute the consecutive begin / end adresses for vector data types\n      for(i=0;i<VecCnt;i++)\n      {\n         UsrTyp[ TotSiz ]  = typ;\n         UsrBas[ TotSiz ]  = BegUsrDat + i * TypSiz[ typ ];\n         UsrDat[ TotSiz ]  = UsrBas[ TotSiz ];\n         UsrLen[ TotSiz ]  = VecLen;\n         TotSiz++;\n      }\n   }\n\n   // Get the file's data type\n   for(i=0;i<kwd->SolSiz;i++)\n   {\n      if(kwd->fmt[i] == 'r')\n         if(msh->FltSiz == 32)\n            FilTyp[i] = GmfFloat;\n         else\n            FilTyp[i] = GmfDouble;\n      else\n         if(msh->ver <= 3)\n            FilTyp[i] = GmfInt;\n         else\n            FilTyp[i] = GmfLong;\n\n      // Compute the file stride\n      LinSiz += TypSiz[ FilTyp[i] ];\n   }\n\n   va_end(VarArg);\n\n   // Move file pointer to the keyword data\n   SetFilPos(msh, kwd->pos);\n\n   // Read the whole kwd data\n   if(msh->typ & Asc)\n   {\n      OldIdx = 1;\n\n      for(i=1;i<=FilEndIdx;i++)\n      {\n         for(j=0;j<kwd->SolSiz;j++)\n         {\n            // Reorder HO nodes on the fly\n            if(kwd->OrdTab && (j != kwd->SolSiz-1))\n               k = kwd->OrdTab[j];\n            else\n               k = j;\n\n            // Move to the next user's data line only when the desired\n            // begining position in the ascii file has been reached since\n            // we cannot move directly to an arbitrary position\n            if(IntMapTab)\n               UsrDat[j] = UsrBas[k] + (IntMapTab[ OldIdx ] - 1) * UsrLen[k];\n            else if(LngMapTab)\n               UsrDat[j] = UsrBas[k] + (LngMapTab[ OldIdx ] - 1) * UsrLen[k];\n            else\n               UsrDat[j] = UsrBas[k] + (OldIdx - 1) * UsrLen[k];\n\n            safe_fscanf(msh->hdl, StrTab[ UsrTyp[j] ], UsrDat[j], msh->err);\n         }\n\n         if(i >= FilBegIdx)\n            OldIdx++;\n\n         // Call the user's preprocessing procedure\n         if(UsrPrc)\n#ifdef F77API\n            CalF77Prc(1, kwd->NmbLin, UsrPrc, NmbArg, ArgTab);\n#else\n            UsrPrc(1, kwd->NmbLin, UsrArg);\n#endif\n      }\n   }\n   else\n   {\n      // Allocate both front and back buffers\n      if(!(BckBuf = malloc(BufSiz * LinSiz)))\n         return(0);\n\n      if(!(FrtBuf = malloc(BufSiz * LinSiz)))\n         return(0);\n\n      // Setup the ansynchonous parameters\n      memset(&aio, 0, sizeof(struct aiocb));\n      FilBuf = BckBuf;\n      aio.aio_buf = BckBuf;\n#ifdef WITH_GMF_AIO\n      aio.aio_fildes = msh->FilDes;\n#else\n      aio.aio_fildes = msh->hdl;\n#endif\n      aio.aio_offset = (off_t)(GetFilPos(msh) + (FilBegIdx-1) * LinSiz);\n\n      NmbBlk = UsrNmbLin / BufSiz;\n\n      // Loop over N+1 blocks\n      for(b=0;b<=NmbBlk+1;b++)\n      {\n         // Wait for the previous block read to complete except\n         // for the first loop interation\n         if(b)\n         {\n            while(my_aio_error(&aio) == EINPROGRESS);\n\n            err = my_aio_error(&aio);\n            ret = my_aio_return(&aio);\n\n            if (err != 0) {\n              printf (\" Error at aio_error() : %s\\n\", strerror (err));\n              exit(1);\n            }\n\n            if (ret != aio.aio_nbytes) {\n              printf(\" Error at aio_return()\\n\");\n              exit(1);\n            }\n\n            // Increment the reading position\n            aio.aio_offset += (off_t)aio.aio_nbytes;\n\n            // and swap the buffers\n            if(aio.aio_buf == BckBuf)\n            {\n               aio.aio_buf = FrtBuf;\n               FilBuf = BckBuf;\n            }\n            else\n            {\n               aio.aio_buf = BckBuf;\n               FilBuf = FrtBuf;\n            }\n         }\n \n         // Read a chunk of data except for the last loop interarion\n         if(b <= NmbBlk)\n         {\n            // The last block is shorter than the others\n            if(b == NmbBlk)\n               BlkNmbLin = UsrNmbLin - b * BufSiz;\n            else\n               BlkNmbLin = BufSiz;\n\n            aio.aio_nbytes = BlkNmbLin * LinSiz;\n\n            if(my_aio_read(&aio) == -1)\n            {\n               printf(\"block      = %zd / %zd\\n\", b+1, NmbBlk+1);\n               printf(\"size       = \"INT64_T_FMT\" lines\\n\", BlkNmbLin);\n#ifdef WITH_GMF_AIO\n               printf(\"aio_fildes = %d\\n\",aio.aio_fildes);\n#else\n               printf(\"aio_fildes = %p\\n\",aio.aio_fildes);\n#endif\n               printf(\"aio_buf    = %p\\n\",aio.aio_buf);\n               printf(\"aio_offset = \" INT64_T_FMT \"\\n\",(int64_t)aio.aio_offset);\n               printf(\"aio_nbytes = \" INT64_T_FMT \"\\n\",(int64_t)aio.aio_nbytes);\n               printf(\"errno      = %d\\n\",errno);\n               exit(1);\n            }\n         }\n\n         // Then decode the block and store it in the user's data structure\n         // except for the first loop interation\n         if(b)\n         {\n            // The last block is shorter than the others\n            if(b-1 == NmbBlk)\n               BlkNmbLin = UsrNmbLin - (b-1) * BufSiz;\n            else\n               BlkNmbLin = BufSiz;\n\n            BlkBegIdx = BlkEndIdx+1;\n            BlkEndIdx += BlkNmbLin;\n            FilPos = FilBuf;\n\n            for(i=0;i<BlkNmbLin;i++)\n            {\n               OldIdx++;\n\n               for(j=0;j<kwd->SolSiz;j++)\n               {\n                  if(msh->cod != 1)\n                     SwpWrd(FilPos, TypSiz[ FilTyp[j] ]);\n\n                  // Reorder HO nodes on the fly\n                  if(kwd->OrdTab && (j != kwd->SolSiz-1))\n                     k = kwd->OrdTab[j];\n                  else\n                     k = j;\n\n                  if(IntMapTab)\n                     UsrDat[j] = UsrBas[k] + (IntMapTab[ OldIdx ] - 1) * UsrLen[k];\n                  else if(LngMapTab)\n                     UsrDat[j] = UsrBas[k] + (LngMapTab[ OldIdx ] - 1) * UsrLen[k];\n                  else\n                     UsrDat[j] = UsrBas[k] + (OldIdx - 1) * UsrLen[k];\n\n                  if(FilTyp[j] == GmfInt)\n                  {\n                     FilPtrI32 = (int *)FilPos;\n\n                     if(UsrTyp[j] == GmfInt)\n                     {\n                        UsrPtrI32 = (int *)UsrDat[j];\n                        *UsrPtrI32 = *FilPtrI32;\n                     }\n                     else\n                     {\n                        UsrPtrI64 = (int64_t *)UsrDat[j];\n                        *UsrPtrI64 = (int64_t)*FilPtrI32;\n                     }\n                  }\n                  else if(FilTyp[j] == GmfLong)\n                  {\n                     FilPtrI64 = (int64_t *)FilPos;\n\n                     if(UsrTyp[j] == GmfLong)\n                     {\n                        UsrPtrI64 = (int64_t *)UsrDat[j];\n                        *UsrPtrI64 = *FilPtrI64;\n                     }\n                     else\n                     {\n                        UsrPtrI32 = (int *)UsrDat[j];\n                        *UsrPtrI32 = (int)*FilPtrI64;\n                     }\n                  }\n                  else if(FilTyp[j] == GmfFloat)\n                  {\n                     FilPtrR32 = (float *)FilPos;\n\n                     if(UsrTyp[j] == GmfFloat)\n                     {\n                        UsrPtrR32 = (float *)UsrDat[j];\n                        *UsrPtrR32 = *FilPtrR32;\n                     }\n                     else\n                     {\n                        UsrPtrR64 = (double *)UsrDat[j];\n                        *UsrPtrR64 = (double)*FilPtrR32;\n                     }\n                  }\n                  else if(FilTyp[j] == GmfDouble)\n                  {\n                     FilPtrR64 = (double *)FilPos;\n\n                     if(UsrTyp[j] == GmfDouble)\n                     {\n                        UsrPtrR64 = (double *)UsrDat[j];\n                        *UsrPtrR64 = *FilPtrR64;\n                     }\n                     else\n                     {\n                        UsrPtrR32 = (float *)UsrDat[j];\n                        *UsrPtrR32 = (float)*FilPtrR64;\n                     }\n                  }\n\n                  FilPos += TypSiz[ FilTyp[j] ];\n               }\n            }\n\n            // Call the user's preprocessing procedure\n            if(UsrPrc)\n#ifdef F77API\n               CalF77Prc(BlkBegIdx, BlkEndIdx, UsrPrc, NmbArg, ArgTab);\n#else\n               UsrPrc(BlkBegIdx, BlkEndIdx, UsrArg);\n#endif\n         }\n      }\n\n      free(BckBuf);\n      free(FrtBuf);\n   }\n\n   return(1);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Bufferized writing of all keyword's lines                                  */\n/*----------------------------------------------------------------------------*/\n\nint NAMF77(GmfSetBlock, gmfsetblock)(  TYPF77(int64_t) MshIdx,\n                                       TYPF77(int)     KwdCod,\n                                       TYPF77(int64_t) BegIdx,\n                                       TYPF77(int64_t) EndIdx,\n                                       TYPF77(int)     MapTyp,\n                                       void           *MapTab,\n                                       void           *prc, ... )\n{\n   char        *UsrDat[ GmfMaxTyp ], *UsrBas[ GmfMaxTyp ];\n   char        *StrTab[5] = { \"\", \"%.9g\", \"%.17g\", \"%d\", \"%lld\" }, *FilPos;\n   char        *FilBuf = NULL, *FrtBuf = NULL, *BckBuf = NULL;\n   char        **BegTab, **EndTab, *BegUsrDat, *EndUsrDat;\n   int         i, j, *FilPtrI32, *UsrPtrI32, FilTyp[ GmfMaxTyp ];\n   int         UsrTyp[ GmfMaxTyp ], TypSiz[5] = {0,4,8,4,8};\n   int         err, *IntMapTab = NULL, typ, mod = GmfArgLst;\n   int         *TypTab, *SizTab, IniFlg = 1, TotSiz = 0, VecCnt, ArgCnt = 0;\n   float       *FilPtrR32, *UsrPtrR32;\n   double      *FilPtrR64, *UsrPtrR64;\n   int64_t     UsrNmbLin, BlkNmbLin = 0, BlkBegIdx, BlkEndIdx = 0;\n   int64_t     *FilPtrI64, *UsrPtrI64, *LngMapTab = NULL, OldIdx = 0;\n   size_t      FilBegIdx = VALF77(BegIdx), FilEndIdx = VALF77(EndIdx);\n   void        (*UsrPrc)(int64_t, int64_t, void *) = NULL;\n   size_t      UsrLen[ GmfMaxTyp ], ret, LinSiz, VecLen, s, b, NmbBlk;\n   va_list     VarArg;\n   GmfMshSct   *msh = (GmfMshSct *) VALF77(MshIdx);\n   KwdSct      *kwd = &msh->KwdTab[ VALF77(KwdCod) ];\n   struct      aiocb aio;\n#ifdef F77API\n   int         NmbArg = 0;\n   void        *ArgTab[ MaxArg ];\n#else\n   char        *UsrArg = NULL;\n#endif\n\n   // Save the current stack environment for longjmp\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(FilBuf)\n         free(FilBuf);\n\n      return(0);\n   }\n\n   // Check mesh and keyword\n   if( (VALF77(KwdCod) < 1) || (VALF77(KwdCod) > GmfMaxKwd) || !kwd->NmbLin )\n      return(0);\n\n   // Make sure it's not a simple information keyword\n   if( (kwd->typ != RegKwd) && (kwd->typ != SolKwd) )\n      return(0);\n\n   // Temporarily overwright the given begin and end values\n   // as arbitrary position block write is not yet implemented\n   FilBegIdx = 1;\n   FilEndIdx = kwd->NmbLin;\n\n   // Check user's bounds\n   if( (FilBegIdx < 1) || (FilBegIdx > FilEndIdx) || (FilEndIdx > (size_t)kwd->NmbLin) )\n      return(0);\n\n   // Compute the number of lines to be written\n   UsrNmbLin = FilEndIdx - FilBegIdx + 1;\n\n   // Get the renumbering map if any\n   if(VALF77(MapTyp) == GmfInt)\n      IntMapTab = (int *)MapTab;\n   else if(VALF77(MapTyp) == GmfLong)\n      LngMapTab = (int64_t *)MapTab;\n\n   // Start decoding the arguments\n   va_start(VarArg, prc);\n   LinSiz = 0;\n\n   // Get the user's postprocessing procedure and argument adresses, if any\n#ifdef F77API\n   if(prc)\n   {\n      UsrPrc = (void (*)(int64_t, int64_t, void *))prc;\n      NmbArg = *(va_arg(VarArg, int *));\n\n      for(i=0;i<NmbArg;i++)\n         ArgTab[i] = va_arg(VarArg, void *);\n   }\n#else\n   if(prc)\n   {\n      UsrPrc = (void (*)(int64_t, int64_t, void *))prc;\n      UsrArg = va_arg(VarArg, void *);\n   }\n#endif\n\n   if( (kwd->typ != RegKwd) && (kwd->typ != SolKwd) )\n      return(0);\n\n   // Read the first data type to select between list and table mode\n   typ = VALF77(va_arg(VarArg, TYPF77(int)));\n\n   // If the table mode is selected, read the four additional tables\n   // containing the arguments: type, vector size, begin and end pointers\n   if(typ == GmfArgTab)\n   {\n      mod = GmfArgTab;\n      TypTab = va_arg(VarArg, int *);\n      SizTab = va_arg(VarArg, int *);\n      BegTab = va_arg(VarArg, char **);\n      EndTab = va_arg(VarArg, char **);\n   }\n\n   // Read the arguments until to total size reaches the keyword's size\n   while(TotSiz < kwd->SolSiz)\n   {\n      // In list mode all arguments are read from the variable argument buffer\n      if(mod == GmfArgLst)\n      {\n         // Do not read the type argument for the first iteration because\n         // it was read befeore the loop begins to get the argument mode\n         if(IniFlg)\n            IniFlg = 0;\n         else\n            typ = VALF77(va_arg(VarArg, TYPF77(int)));\n\n         // In case the type is a vector. get its size and change the type\n         // for the corresponding scalar type\n         if(typ >= GmfFloatVec && typ <= GmfLongVec)\n         {\n            typ -= 4;\n            VecCnt = VALF77(va_arg(VarArg, TYPF77(int)));\n         }\n         else\n            VecCnt = 1;\n\n         BegUsrDat = va_arg(VarArg, char *);\n         EndUsrDat = va_arg(VarArg, char *);\n      }\n      else\n      {\n         // Do exactly the same as above but the arguments are read from\n         // the tables instead of VarArgs\n         typ = TypTab[ ArgCnt ];\n\n         if(typ >= GmfFloatVec && typ <= GmfLongVec)\n         {\n            typ -= 4;\n            VecCnt = SizTab[ ArgCnt ];\n         }\n         else\n            VecCnt = 1;\n\n         BegUsrDat = (char *)BegTab[ ArgCnt ];\n         EndUsrDat = (char *)EndTab[ ArgCnt ];\n         ArgCnt++;\n      }\n\n      if(UsrNmbLin > 1)\n         VecLen = (size_t)(EndUsrDat - BegUsrDat) / (UsrNmbLin - 1);\n      else\n         VecLen = 0;\n\n      // Compute the consecutive begin / end adresses for vector data types\n      for(i=0;i<VecCnt;i++)\n      {\n         UsrTyp[ TotSiz ]  = typ;\n         UsrBas[ TotSiz ]  = BegUsrDat + i * TypSiz[ typ ];\n         UsrDat[ TotSiz ]  = UsrBas[ TotSiz ];\n         UsrLen[ TotSiz ]  = VecLen;\n         TotSiz++;\n      }\n   }\n\n   // Get the file's data type\n   for(i=0;i<kwd->SolSiz;i++)\n   {\n      if(kwd->fmt[i] == 'r')\n         if(msh->FltSiz == 32)\n            FilTyp[i] = GmfFloat;\n         else\n            FilTyp[i] = GmfDouble;\n      else\n         if(msh->ver <= 3)\n            FilTyp[i] = GmfInt;\n         else\n            FilTyp[i] = GmfLong;\n\n      // Compute the file stride\n      LinSiz += TypSiz[ FilTyp[i] ];\n   }\n\n   va_end(VarArg);\n\n   // Write the whole kwd data\n   if(msh->typ & Asc)\n   {\n      if(UsrPrc)\n#ifdef F77API\n         CalF77Prc(1, kwd->NmbLin, UsrPrc, NmbArg, ArgTab);\n#else\n         UsrPrc(1, kwd->NmbLin, UsrArg);\n#endif\n\n      for(s=FilBegIdx; s<=FilEndIdx; s++)\n         for(j=0;j<kwd->SolSiz;j++)\n         {\n            if(UsrTyp[j] == GmfFloat)\n            {\n               UsrPtrR32 = (float *)UsrDat[j];\n               fprintf(msh->hdl, StrTab[ UsrTyp[j] ], (double)*UsrPtrR32);\n            }\n            else if(UsrTyp[j] == GmfDouble)\n            {\n               UsrPtrR64 = (double *)UsrDat[j];\n               fprintf(msh->hdl, StrTab[ UsrTyp[j] ], *UsrPtrR64);\n            }\n            else if(UsrTyp[j] == GmfInt)\n            {\n               UsrPtrI32 = (int *)UsrDat[j];\n               fprintf(msh->hdl, StrTab[ UsrTyp[j] ], *UsrPtrI32);\n            }\n            else if(UsrTyp[j] == GmfLong)\n            {\n               UsrPtrI64 = (int64_t *)UsrDat[j];\n               fprintf(msh->hdl, StrTab[ UsrTyp[j] ], *UsrPtrI64);\n            }\n\n            if(j < kwd->SolSiz -1)\n               fprintf(msh->hdl, \" \");\n            else\n               fprintf(msh->hdl, \"\\n\");\n\n            //UsrDat[j] += UsrLen[j];\n            if(IntMapTab)\n               UsrDat[j] = UsrBas[j] + IntMapTab[s] * UsrLen[j];\n            else if(LngMapTab)\n               UsrDat[j] = UsrBas[j] + LngMapTab[s] * UsrLen[j];\n            else\n               UsrDat[j] = UsrBas[j] + s * UsrLen[j];\n         }\n   }\n   else\n   {\n      // Allocate the front and back buffers\n      if(!(BckBuf = malloc(BufSiz * LinSiz)))\n         return(0);\n\n      if(!(FrtBuf = malloc(BufSiz * LinSiz)))\n         return(0);\n\n      // Setup the asynchronous parameters\n      memset(&aio, 0, sizeof(struct aiocb));\n      FilBuf = BckBuf;\n#ifdef WITH_GMF_AIO\n      aio.aio_fildes = msh->FilDes;\n#else\n      aio.aio_fildes = msh->hdl;\n#endif\n      aio.aio_offset = (off_t)GetFilPos(msh);\n\n      NmbBlk = UsrNmbLin / BufSiz;\n\n      // Loop over N+1 blocks\n      for(b=0;b<=NmbBlk+1;b++)\n      {\n         // Launch an asynchronous block write\n         // except for the first loop iteration\n         if(b)\n         {\n            aio.aio_nbytes = BlkNmbLin * LinSiz;\n            \n            if(my_aio_write(&aio) == -1)\n            {\n#ifdef WITH_GMF_AIO\n               printf(\"aio_fildes = %d\\n\",aio.aio_fildes);\n#else\n               printf(\"aio_fildes = %p\\n\",aio.aio_fildes);\n#endif\n               printf(\"aio_buf    = %p\\n\",aio.aio_buf);\n               printf(\"aio_offset = \" INT64_T_FMT \"\\n\",(int64_t)aio.aio_offset);\n               printf(\"aio_nbytes = \" INT64_T_FMT \"\\n\",(int64_t)aio.aio_nbytes);\n               printf(\"errno      = %d\\n\",errno);\n               exit(1);\n            }\n         }\n\n         // Parse the block data except at the last loop iteration\n         if(b<=NmbBlk)\n         {\n            // The last block is shorter\n            if(b == NmbBlk)\n               BlkNmbLin = UsrNmbLin - b * BufSiz;\n            else\n               BlkNmbLin = BufSiz;\n\n            FilPos = FilBuf;\n            BlkBegIdx = BlkEndIdx+1;\n            BlkEndIdx += BlkNmbLin;\n\n            // Call user's preprocessing first\n            if(UsrPrc)\n#ifdef F77API\n               CalF77Prc(BlkBegIdx, BlkEndIdx, UsrPrc, NmbArg, ArgTab);\n#else\n               UsrPrc(BlkBegIdx, BlkEndIdx, UsrArg);\n#endif\n\n            // Then copy it's data to the file buffer\n            for(i=0;i<BlkNmbLin;i++)\n            {\n               OldIdx++;\n\n               for(j=0;j<kwd->SolSiz;j++)\n               {\n                  if(IntMapTab)\n                     UsrDat[j] = UsrBas[j] + (IntMapTab[ OldIdx ] - 1) * UsrLen[j];\n                  else if(LngMapTab)\n                     UsrDat[j] = UsrBas[j] + (LngMapTab[ OldIdx ] - 1) * UsrLen[j];\n                  else\n                     UsrDat[j] = UsrBas[j] + (OldIdx - 1) * UsrLen[j];\n\n                  if(FilTyp[j] == GmfInt)\n                  {\n                     FilPtrI32 = (int *)FilPos;\n\n                     if(UsrTyp[j] == GmfInt)\n                     {\n                        UsrPtrI32 = (int *)UsrDat[j];\n                        *FilPtrI32 = *UsrPtrI32;\n                     }\n                     else\n                     {\n                        UsrPtrI64 = (int64_t *)UsrDat[j];\n                        *FilPtrI32 = (int)*UsrPtrI64;\n                     }\n                  }\n                  else if(FilTyp[j] == GmfLong)\n                  {\n                     FilPtrI64 = (int64_t *)FilPos;\n\n                     if(UsrTyp[j] == GmfLong)\n                     {\n                        UsrPtrI64 = (int64_t *)UsrDat[j];\n                        *FilPtrI64 = *UsrPtrI64;\n                     }\n                     else\n                     {\n                        UsrPtrI32 = (int *)UsrDat[j];\n                        *FilPtrI64 = (int64_t)*UsrPtrI32;\n                     }\n                  }\n                  else if(FilTyp[j] == GmfFloat)\n                  {\n                     FilPtrR32 = (float *)FilPos;\n\n                     if(UsrTyp[j] == GmfFloat)\n                     {\n                        UsrPtrR32 = (float *)UsrDat[j];\n                        *FilPtrR32 = *UsrPtrR32;\n                     }\n                     else\n                     {\n                        UsrPtrR64 = (double *)UsrDat[j];\n                        *FilPtrR32 = (float)*UsrPtrR64;\n                     }\n                  }\n                  else if(FilTyp[j] == GmfDouble)\n                  {\n                     FilPtrR64 = (double *)FilPos;\n\n                     if(UsrTyp[j] == GmfDouble)\n                     {\n                        UsrPtrR64 = (double *)UsrDat[j];\n                        *FilPtrR64 = *UsrPtrR64;\n                     }\n                     else\n                     {\n                        UsrPtrR32 = (float *)UsrDat[j];\n                        *FilPtrR64 = (double)*UsrPtrR32;\n                     }\n                  }\n\n                  FilPos += TypSiz[ FilTyp[j] ];\n               }\n            }\n         }\n\n         // Wait for write completion execpt at the first loop iteration\n         if(b)\n         {\n            while(my_aio_error(&aio) == EINPROGRESS);\n\n            err = my_aio_error(&aio);\n            ret = my_aio_return(&aio);\n\n            if (err != 0) {\n              printf (\" Error at aio_error() : %s\\n\", strerror (err));\n              exit(1);\n            }\n\n            if (ret != aio.aio_nbytes) {\n              printf(\" Error at aio_return()\\n\");\n              exit(1);\n            }\n\n            // Move the write position\n            aio.aio_offset += (off_t)aio.aio_nbytes;\n         }\n\n         // Swap the buffers\n         if(FilBuf == BckBuf)\n         {\n            aio.aio_buf = BckBuf;\n            FilBuf = FrtBuf;\n         }\n         else\n         {\n            aio.aio_buf = FrtBuf;\n            FilBuf = BckBuf;\n         }\n      }\n\n      SetFilPos(msh, aio.aio_offset);\n      free(BckBuf);\n      free(FrtBuf);\n   }\n\n   return(1);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Map two HO element's nodes numbering orders                                */\n/*----------------------------------------------------------------------------*/\n\nint GmfSetHONodesOrdering(int64_t MshIdx, int KwdCod, int *BasTab, int *OrdTab)\n{\n   int i, j, k, flg, NmbNod, NmbCrd;\n   GmfMshSct   *msh = (GmfMshSct *)MshIdx;\n   KwdSct      *kwd;\n   \n   // printf(\"\\n\\tGmfSetHONodesOrdering 0\\n\");\n\n   if( (KwdCod < 1) || (KwdCod > GmfMaxKwd) )\n      return(0);\n\n   kwd = &msh->KwdTab[ KwdCod ];\n\n   // Find the Bezier indices dimension according to the element's kind\n   switch(KwdCod)\n   {\n      case GmfEdges   :          NmbNod =  2; NmbCrd = 1; break;\n      case GmfEdgesP2 :          NmbNod =  3; NmbCrd = 1; break;\n      case GmfEdgesP3 :          NmbNod =  4; NmbCrd = 1; break;\n      case GmfEdgesP4 :          NmbNod =  5; NmbCrd = 1; break;\n      case GmfTriangles   :      NmbNod =  3; NmbCrd = 3; break;\n      case GmfTrianglesP2 :      NmbNod =  6; NmbCrd = 3; break;\n      case GmfTrianglesP3 :      NmbNod = 10; NmbCrd = 3; break;\n      case GmfTrianglesP4 :      NmbNod = 15; NmbCrd = 3; break;\n      case GmfQuadrilaterals   : NmbNod =  4; NmbCrd = 2; break;\n      case GmfQuadrilateralsQ2 : NmbNod =  9; NmbCrd = 2; break;\n      case GmfQuadrilateralsQ3 : NmbNod = 16; NmbCrd = 2; break;\n      case GmfQuadrilateralsQ4 : NmbNod = 25; NmbCrd = 2; break;\n      case GmfTetrahedra   :     NmbNod =  4; NmbCrd = 4; break;\n      case GmfTetrahedraP2 :     NmbNod = 10; NmbCrd = 4; break;\n      case GmfTetrahedraP3 :     NmbNod = 20; NmbCrd = 4; break;\n      case GmfTetrahedraP4 :     NmbNod = 35; NmbCrd = 4; break;\n      case GmfPyramids   :       NmbNod =  5; NmbCrd = 3; break;\n      case GmfPyramidsP2 :       NmbNod = 14; NmbCrd = 3; break;\n      case GmfPyramidsP3 :       NmbNod = 30; NmbCrd = 3; break;\n      case GmfPyramidsP4 :       NmbNod = 55; NmbCrd = 3; break;\n      case GmfPrisms   :         NmbNod =  6; NmbCrd = 4; break;\n      case GmfPrismsP2 :         NmbNod = 18; NmbCrd = 4; break;\n      case GmfPrismsP3 :         NmbNod = 40; NmbCrd = 4; break;\n      case GmfPrismsP4 :         NmbNod = 75; NmbCrd = 4; break;\n      case GmfHexahedra   :      NmbNod =  8; NmbCrd = 3; break;\n      case GmfHexahedraQ2 :      NmbNod = 27; NmbCrd = 3; break;\n      case GmfHexahedraQ3 :      NmbNod = 64; NmbCrd = 3; break;\n      case GmfHexahedraQ4 :      NmbNod =125; NmbCrd = 3; break;\n      default : return(0);\n   }\n\n   // Free and rebuild the mapping table if there were already one\n   if(kwd->OrdTab)\n      free(kwd->OrdTab);\n\n   if(!(kwd->OrdTab = malloc(NmbNod * sizeof(int))))\n      return(0);\n\n   // Find the corresponding Bezier coordinates from the source table\n   for(i=0;i<NmbNod;i++)\n   {\n      for(j=0;j<NmbNod;j++)\n      {\n         flg = 1;\n\n         for(k=0;k<NmbCrd;k++)\n            if(BasTab[ i * NmbCrd + k ] != OrdTab[ j * NmbCrd + k ])\n            {\n               flg = 0;\n               break;\n            }\n\n         if(flg)\n            kwd->OrdTab[j] = i;\n      }\n   }\n\n   // Check the ordering consistency\n   for(i=0;i<NmbNod;i++)\n   {\n      flg = 0;\n\n      for(j=0;j<NmbNod;j++)\n         if(kwd->OrdTab[j] == i)\n         {\n            flg = 1;\n            break;\n         }\n\n      if(!flg)\n      {\n         for(j=0;j<NmbNod;j++)\n            kwd->OrdTab[j] = j;\n\n         return(0);\n      }\n   }\n\n   return(1);\n}\n\n#endif\n\n\n#ifndef F77API\n\n\n/*----------------------------------------------------------------------------*/\n/* Read an EGADS binary CAD and return the byte flow and its exact byte size  */\n/*----------------------------------------------------------------------------*/\n\nchar *GmfReadByteFlow(int64_t MshIdx, int *NmbByt)\n{\n   int         cod, *WrdTab;\n   size_t      i, NmbWrd;\n   GmfMshSct   *msh = (GmfMshSct *)MshIdx;\n\n   // Read and allocate the number of 4-byte words in the byteflow\n   if(!(NmbWrd = GmfStatKwd(MshIdx, GmfByteFlow)))\n      return(NULL);\n\n   if(!(WrdTab = malloc(NmbWrd * WrdSiz)))\n      return(NULL);\n\n   // Disable the endianess conversion\n   cod = msh->cod;\n   msh->cod = 1;\n\n   // Read the exact number of bytes in the byteflow\n   GmfGotoKwd(MshIdx, GmfByteFlow);\n   GmfGetLin(MshIdx, GmfByteFlow, NmbByt);\n\n   // Read the byteflow as 4-byte blocks\n   for(i=0;i<NmbWrd;i++)\n      GmfGetLin(MshIdx, GmfByteFlow, &WrdTab[i]);\n\n   // Enable endianess convertion\n   msh->cod = cod;\n\n   return((char *)WrdTab);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Write an EGADS binary CAD as an integer table whose first entry is the size*/\n/*----------------------------------------------------------------------------*/\n\nint GmfWriteByteFlow(int64_t MshIdx, char *BytTab, int NmbByt)\n{\n   int i, PadWrd = 0, *WrdTab = (int *)BytTab, NmbWrd = NmbByt / WrdSiz;\n\n   // Add an extra padding word at the end if needed\n   if(NmbByt > NmbWrd * 4)\n      PadWrd = 1;\n\n   // Create the keyword with the number of words, not bytes\n   if(!GmfSetKwd(MshIdx, GmfByteFlow, NmbWrd + PadWrd))\n      return(0);\n\n   // Reacord the exact number of bytes\n   GmfSetLin(MshIdx, GmfByteFlow, NmbByt);\n\n   // Write the byteflow as 4-byte words, missing up to 3 endding bytes\n   for(i=0;i<NmbWrd;i++)\n      GmfSetLin(MshIdx, GmfByteFlow, WrdTab[i]);\n\n   // Write the extra 1,2 or 3 ending bytes\n   if(PadWrd)\n   {\n      PadWrd = 0;\n\n      // Copy the last bytes in an integer\n      for(i=0; i<NmbByt - NmbWrd * 4; i++)\n         PadWrd |= BytTab[ NmbWrd * 4 + i ] << (i*8);\n\n      // And write it as the last line\n      GmfSetLin(MshIdx, GmfByteFlow, PadWrd);\n   }\n\n   return(1);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Override the floating point precision deduced form the file version        */\n/* with the one read from the GmfFloatingPointPrecision field                 */\n/*----------------------------------------------------------------------------*/\n\nint GmfGetFloatPrecision(int64_t MshIdx)\n{\n   int FltSiz;\n   GmfMshSct *msh = (GmfMshSct *)MshIdx;\n\n   if(GmfStatKwd(MshIdx, GmfFloatingPointPrecision))\n   {\n      GmfGotoKwd(MshIdx, GmfFloatingPointPrecision);\n      GmfGetLin(MshIdx, GmfFloatingPointPrecision, &FltSiz);\n\n      if(FltSiz == 32 || FltSiz == 64)\n         msh->FltSiz = FltSiz;\n   }\n\n   return(msh->FltSiz);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Set the floating point precision arbitrarily, regardless the file version  */\n/*----------------------------------------------------------------------------*/\n\nvoid GmfSetFloatPrecision(int64_t MshIdx , int FltSiz)\n{\n   GmfMshSct *msh = (GmfMshSct *)MshIdx;\n\n   if(FltSiz != 32 && FltSiz != 64)\n      return;\n\n   msh->FltSiz = FltSiz;\n   GmfSetKwd(MshIdx, GmfFloatingPointPrecision, 1);\n   GmfSetLin(MshIdx, GmfFloatingPointPrecision, FltSiz);\n}\n\n#endif\n\n\n/*----------------------------------------------------------------------------*/\n/* Find every kw present in a meshfile                                        */\n/*----------------------------------------------------------------------------*/\n\nstatic int ScaKwdTab(GmfMshSct *msh)\n{\n   int      KwdCod, c;\n   int64_t  NexPos, EndPos, LstPos;\n   char     str[ GmfStrSiz ];\n\n   if(msh->typ & Asc)\n   {\n      // Scan each string in the file until the end\n      while(fscanf(msh->hdl, \"%s\", str) != EOF)\n      {\n         // Fast test in order to reject quickly the numeric values\n         if(isalpha(str[0]))\n         {\n            // Search which kwd code this string is associated with, then get its\n            // header and save the curent position in file (just before the data)\n            for(KwdCod=1; KwdCod<= GmfMaxKwd; KwdCod++)\n               if(!strcmp(str, GmfKwdFmt[ KwdCod ][0]))\n               {\n                  ScaKwdHdr(msh, KwdCod);\n                  break;\n               }\n         }\n         else if(str[0] == '#')\n            while((c = fgetc(msh->hdl)) != '\\n' && c != EOF);\n      }\n   }\n   else\n   {\n      // Get file size\n      EndPos = GetFilSiz(msh);\n      LstPos = -1;\n\n      // Jump through kwd positions in the file\n      do\n      {\n         // Get the kwd code and the next kwd position\n         ScaWrd(msh, ( char *)&KwdCod);\n         NexPos = GetPos(msh);\n\n         // Make sure the flow does not move beyond the file size\n         if(NexPos > EndPos)\n            longjmp(msh->err, -24);\n\n         // And check that it does not move back\n         if(NexPos && (NexPos <= LstPos))\n            longjmp(msh->err, -30);\n\n         LstPos = NexPos;\n\n         // Check if this kwd belongs to this mesh version\n         if( (KwdCod >= 1) && (KwdCod <= GmfMaxKwd) )\n            ScaKwdHdr(msh, KwdCod);\n\n         // Go to the next kwd\n         if(NexPos && !(SetFilPos(msh, NexPos)))\n            longjmp(msh->err, -25);\n\n      }while(NexPos && (KwdCod != GmfEnd));\n   }\n\n   return(1);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Read and setup the keyword's header                                        */\n/*----------------------------------------------------------------------------*/\n\nstatic void ScaKwdHdr(GmfMshSct *msh, int KwdCod)\n{\n   int      i;\n   KwdSct   *kwd = &msh->KwdTab[ KwdCod ];\n\n   if(!strcmp(\"i\", GmfKwdFmt[ KwdCod ][1]))\n      if(msh->typ & Asc)\n         safe_fscanf(msh->hdl, INT64_T_FMT, &kwd->NmbLin, msh->err);\n      else\n         if(msh->ver <= 3)\n         {\n            ScaWrd(msh, (unsigned char *)&i);\n            kwd->NmbLin = i;\n         }\n         else\n            ScaDblWrd(msh, (unsigned char *)&kwd->NmbLin);\n   else\n      kwd->NmbLin = 1;\n\n   if(!strcmp(\"sr\", GmfKwdFmt[ KwdCod ][2])\n   || !strcmp(\"hr\", GmfKwdFmt[ KwdCod ][2]) )\n   {\n      if(msh->typ & Asc)\n      {\n         safe_fscanf(msh->hdl, \"%d\", &kwd->NmbTyp, msh->err);\n\n         for(i=0;i<kwd->NmbTyp;i++)\n            safe_fscanf(msh->hdl, \"%d\", &kwd->TypTab[i], msh->err);\n\n         // Scan two extra fields for HO solutions: deg and nmb Nodes\n         if(!strcmp(\"hr\", GmfKwdFmt[ KwdCod ][2]))\n         {\n            safe_fscanf(msh->hdl, \"%d\", &kwd->deg, msh->err);\n            safe_fscanf(msh->hdl, \"%d\", &kwd->NmbNod, msh->err);\n         }\n         else\n         {\n            kwd->deg = 0;\n            kwd->NmbNod = 1;\n         }\n\n      }\n      else\n      {\n         ScaWrd(msh, (unsigned char *)&kwd->NmbTyp);\n\n         for(i=0;i<kwd->NmbTyp;i++)\n            ScaWrd(msh, (unsigned char *)&kwd->TypTab[i]);\n\n         // Scan two extra fields for HO solutions: deg and nmb Nodes\n         if(!strcmp(\"hr\", GmfKwdFmt[ KwdCod ][2]))\n         {\n            ScaWrd(msh, (unsigned char *)&kwd->deg);\n            ScaWrd(msh, (unsigned char *)&kwd->NmbNod);\n         }\n         else\n         {\n            kwd->deg = 0;\n            kwd->NmbNod = 1;\n         }\n      }\n   }\n\n   ExpFmt(msh, KwdCod);\n   kwd->pos = GetFilPos(msh);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Expand the compacted format and compute the line size                      */\n/*----------------------------------------------------------------------------*/\n\nstatic void ExpFmt(GmfMshSct *msh, int KwdCod)\n{\n   int         i, j, TmpSiz=0, IntWrd, FltWrd;\n   char        chr;\n   const char  *InpFmt = GmfKwdFmt[ KwdCod ][2];\n   KwdSct      *kwd = &msh->KwdTab[ KwdCod ];\n\n   // Set the kwd's type\n   if(!strlen(GmfKwdFmt[ KwdCod ][1]))\n      kwd->typ = InfKwd;\n   else if( !strcmp(InpFmt, \"sr\") || !strcmp(InpFmt, \"hr\") )\n      kwd->typ = SolKwd;\n   else\n      kwd->typ = RegKwd;\n\n   // Get the solution-field's size\n   if(kwd->typ == SolKwd)\n      for(i=0;i<kwd->NmbTyp;i++)\n         switch(kwd->TypTab[i])\n         {\n            case GmfSca    : TmpSiz += 1; break;\n            case GmfVec    : TmpSiz += msh->dim; break;\n            case GmfSymMat : TmpSiz += (msh->dim * (msh->dim+1)) / 2; break;\n            case GmfMat    : TmpSiz += msh->dim * msh->dim; break;\n         }\n\n   // Scan each character from the format string\n   i = kwd->SolSiz = kwd->NmbWrd = 0;\n\n   while(i < (int)strlen(InpFmt))\n   {\n      chr = InpFmt[ i++ ];\n\n      if(chr == 'd')\n      {\n         chr = InpFmt[i++];\n\n         for(j=0;j<msh->dim;j++)\n            kwd->fmt[ kwd->SolSiz++ ] = chr;\n      }\n      else if((chr == 's')||(chr == 'h'))\n      {\n         chr = InpFmt[i++];\n\n         for(j=0;j<TmpSiz;j++)\n            kwd->fmt[ kwd->SolSiz++ ] = chr;\n      }\n      else\n         kwd->fmt[ kwd->SolSiz++ ] = chr;\n   }\n\n   if(msh->FltSiz == 32)\n      FltWrd = 1;\n   else\n      FltWrd = 2;\n\n   if(msh->ver <= 3)\n      IntWrd = 1;\n   else\n      IntWrd = 2;\n\n   for(i=0;i<kwd->SolSiz;i++)\n      switch(kwd->fmt[i])\n      {\n         case 'i' : kwd->NmbWrd += IntWrd; break;\n         case 'c' : kwd->NmbWrd += FilStrSiz; break;\n         case 'r' : kwd->NmbWrd += FltWrd;break;\n      }\n\n   // HO solution: duplicate the format as many times as the number of nodes\n   if( !strcmp(InpFmt, \"hr\") && (kwd->NmbNod > 1) )\n   {\n      for(i=1;i<=kwd->NmbNod;i++)\n         for(j=0;j<kwd->SolSiz;j++)\n            kwd->fmt[ i * kwd->SolSiz + j ] = kwd->fmt[j];\n\n      kwd->SolSiz *= kwd->NmbNod;\n      kwd->NmbWrd *= kwd->NmbNod;\n   }\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Read a four bytes word from a mesh file                                    */\n/*----------------------------------------------------------------------------*/\n\nstatic void ScaWrd(GmfMshSct *msh, void *ptr)\n{\n#ifdef WITH_GMF_AIO\n   if(read(msh->FilDes, ptr, WrdSiz) != WrdSiz)\n#else\n   if(fread(ptr, WrdSiz, 1, msh->hdl) != 1)\n#endif\n      longjmp(msh->err, -26);\n\n   if(msh->cod != 1)\n      SwpWrd((char *)ptr, WrdSiz);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Read an eight bytes word from a mesh file                                  */\n/*----------------------------------------------------------------------------*/\n\nstatic void ScaDblWrd(GmfMshSct *msh, void *ptr)\n{\n#ifdef WITH_GMF_AIO\n   if(read(msh->FilDes, ptr, WrdSiz * 2) != WrdSiz * 2)\n#else\n   if( fread(ptr, WrdSiz, 2, msh->hdl) != 2 )\n#endif\n      longjmp(msh->err, -27);\n\n   if(msh->cod != 1)\n      SwpWrd((char *)ptr, 2 * WrdSiz);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Read a 4 or 8 bytes position in mesh file                                  */\n/*----------------------------------------------------------------------------*/\n\nstatic int64_t GetPos(GmfMshSct *msh)\n{\n   int      IntVal;\n   int64_t  pos;\n\n   if(msh->ver >= 3)\n      ScaDblWrd(msh, (unsigned char*)&pos);\n   else\n   {\n      ScaWrd(msh, (unsigned char*)&IntVal);\n      pos = (int64_t)IntVal;\n   }\n\n   return(pos);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Write a four bytes word to a mesh file                                     */\n/*----------------------------------------------------------------------------*/\n\nstatic void RecWrd(GmfMshSct *msh, const void *wrd)\n{\n   // [Bruno] added error control\n#ifdef WITH_GMF_AIO\n   if(write(msh->FilDes, wrd, WrdSiz) != WrdSiz)\n#else\n   if(fwrite(wrd, WrdSiz, 1, msh->hdl) != 1)\n#endif\n      longjmp(msh->err,-28);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Write an eight bytes word to a mesh file                                   */\n/*----------------------------------------------------------------------------*/\n\nstatic void RecDblWrd(GmfMshSct *msh, const void *wrd)\n{\n   // [Bruno] added error control\n#ifdef WITH_GMF_AIO\n   if(write(msh->FilDes, wrd, WrdSiz * 2) != WrdSiz*2)\n#else\n   if(fwrite(wrd, WrdSiz, 2, msh->hdl) != 2)\n#endif\n      longjmp(msh->err,-29);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Write a block of four bytes word to a mesh file                            */\n/*----------------------------------------------------------------------------*/\n\nstatic void RecBlk(GmfMshSct *msh, const void *blk, int siz)\n{\n   // Copy this line-block into the main mesh buffer\n   if(siz)\n   {\n      memcpy(&msh->blk[ msh->pos ], blk, (size_t)(siz * WrdSiz));\n      msh->pos += siz * WrdSiz;\n   }\n\n   // When the buffer is full or this procedure is APIF77ed with a 0 size,\n   // flush the cache on disk\n\n   if( (msh->pos > BufSiz) || (!siz && msh->pos) )\n   {\n#ifdef GMF_WINDOWS\n      /*\n       *   [Bruno] TODO: check that msh->pos is smaller\n       * than 4G (fits in 32 bits).\n       *   Note: for now, when trying to write more than 4Gb, it will\n       * trigger an error (longjmp).\n       *   As far as I understand:\n       *   Given that this function just flushes the cache, and given that\n       * the cache size is 10000 words, this is much much smaller than 4Gb\n       * so there is probably no problem.\n       */\n#ifdef WITH_GMF_AIO\n      if(write(msh->FilDes, msh->blk, (int)msh->pos) != (ssize_t)msh->pos)\n#else      \n      if(fwrite(msh->blk, 1, (size_t)msh->pos, msh->hdl) != msh->pos)\n#endif      \n         longjmp(msh->err, -30);\n#else      \n#ifdef WITH_GMF_AIO\n      if(write(msh->FilDes, msh->blk, msh->pos) != (ssize_t)msh->pos)\n#else      \n      if(fwrite(msh->blk, 1, msh->pos, msh->hdl) != msh->pos)\n#endif      \n         longjmp(msh->err, -31);\n#endif      \n      msh->pos = 0;\n   }\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Write a 4 or 8 bytes position in a mesh file                               */\n/*----------------------------------------------------------------------------*/\n\nstatic void SetPos(GmfMshSct *msh, int64_t pos)\n{\n   int IntVal;\n\n   if(msh->ver >= 3)\n      RecDblWrd(msh, (unsigned char*)&pos);\n   else\n   {\n      IntVal = (int)pos;\n      RecWrd(msh, (unsigned char*)&IntVal);\n   }\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Endianness conversion                                                      */\n/*----------------------------------------------------------------------------*/\n\nstatic void SwpWrd(char *wrd, int siz)\n{\n   char  swp;\n   int   i;\n\n   for(i=0;i<siz/2;i++)\n   {\n      swp = wrd[ siz-i-1 ];\n      wrd[ siz-i-1 ] = wrd[i];\n      wrd[i] = swp;\n   }\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Set current position in a file                                             */\n/*----------------------------------------------------------------------------*/\n\nstatic int SetFilPos(GmfMshSct *msh, int64_t pos)\n{\n#ifdef WITH_GMF_AIO\n   if(msh->typ & Bin)\n      return((lseek(msh->FilDes, (off_t)pos, 0) != -1));\n   else\n      return((MYFSEEK(msh->hdl, (off_t)pos, SEEK_SET) == 0));\n#else\n   return((MYFSEEK(msh->hdl, (off_t)pos, SEEK_SET) == 0));\n#endif\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Get current position in a file                                             */\n/*----------------------------------------------------------------------------*/\n\nstatic int64_t GetFilPos(GmfMshSct *msh)\n{\n#ifdef WITH_GMF_AIO\n   if(msh->typ & Bin)\n      return(lseek(msh->FilDes, 0, 1));\n   else\n      return(MYFTELL(msh->hdl));\n#else\n   return(MYFTELL(msh->hdl));\n#endif\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Move the position to the end of file and return the size                   */\n/*----------------------------------------------------------------------------*/\n\nstatic int64_t GetFilSiz(GmfMshSct *msh)\n{\n   int64_t CurPos, EndPos = 0;\n\n   if(msh->typ & Bin)\n   {\n#ifdef WITH_GMF_AIO\n      CurPos = lseek(msh->FilDes, 0, 1);\n      EndPos = lseek(msh->FilDes, 0, 2);\n      lseek(msh->FilDes, (off_t)CurPos, 0);\n#else\n      CurPos = MYFTELL(msh->hdl);\n\n      if(MYFSEEK(msh->hdl, 0, SEEK_END) != 0)\n         longjmp(msh->err, -32);\n\n      EndPos = MYFTELL(msh->hdl);\n\n      if(MYFSEEK(msh->hdl, (off_t)CurPos, SEEK_SET) != 0)\n         longjmp(msh->err, -33);\n#endif\n   }\n   else\n   {\n      CurPos = MYFTELL(msh->hdl);\n\n      if(MYFSEEK(msh->hdl, 0, SEEK_END) != 0)\n         longjmp(msh->err, -34);\n\n      EndPos = MYFTELL(msh->hdl);\n\n      if(MYFSEEK(msh->hdl, (off_t)CurPos, SEEK_SET) != 0)\n         longjmp(msh->err, -35);\n   }\n\n   return(EndPos);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Fortran 77 API                                                             */\n/*----------------------------------------------------------------------------*/\n\n#ifdef F77API\n\nint64_t APIF77(gmfopenmesh)(  char *FilNam, int *mod,\n                              int *ver, int *dim, int StrSiz )\n{\n   int   i = 0;\n   char  TmpNam[ GmfStrSiz ];\n\n   if(StrSiz <= 0)\n      return(0);\n\n   // Trim trailing spaces from the fortran string\n   while(isspace(FilNam[ StrSiz-1 ]))\n      StrSiz--;\n\n   for(i=0;i<StrSiz;i++)\n      TmpNam[i] = FilNam[i];\n\n   TmpNam[ StrSiz ] = 0;\n\n   if(*mod == GmfRead)\n      return(GmfOpenMesh(TmpNam, *mod, ver, dim));\n   else\n      return(GmfOpenMesh(TmpNam, *mod, *ver, *dim));\n}\n\nint APIF77(gmfclosemesh)(int64_t *idx)\n{\n   return(GmfCloseMesh(*idx));\n}\n\nint APIF77(gmfgotokwd)(int64_t *MshIdx, int *KwdIdx)\n{\n   return(GmfGotoKwd(*MshIdx, *KwdIdx));\n}\n\nint APIF77(gmfstatkwd)( int64_t *MshIdx, int *KwdIdx, int *NmbTyp,\n                        int *SolSiz, int *TypTab,  int *deg, int *NmbNod)\n{\n   if(!strcmp(GmfKwdFmt[ *KwdIdx ][2], \"hr\"))\n      return(GmfStatKwd(*MshIdx, *KwdIdx, NmbTyp, SolSiz, TypTab, deg, NmbNod));\n   else if(!strcmp(GmfKwdFmt[ *KwdIdx ][2], \"sr\"))\n      return(GmfStatKwd(*MshIdx, *KwdIdx, NmbTyp, SolSiz, TypTab));\n   else\n      return(GmfStatKwd(*MshIdx, *KwdIdx));\n}\n\nint APIF77(gmfsetkwd)(  int64_t *MshIdx, int *KwdIdx, int *NmbLin,\n                        int *NmbTyp, int *TypTab, int *deg, int *NmbNod)\n{\n   if(!strcmp(GmfKwdFmt[ *KwdIdx ][2], \"hr\"))\n      return(GmfSetKwd(*MshIdx, *KwdIdx, *NmbLin, *NmbTyp, TypTab, *deg, *NmbNod));\n   else if(!strcmp(GmfKwdFmt[ *KwdIdx ][2], \"sr\"))\n      return(GmfSetKwd(*MshIdx, *KwdIdx, *NmbLin, *NmbTyp, TypTab));\n   else\n      return(GmfSetKwd(*MshIdx, *KwdIdx, *NmbLin));\n}\n\n\nint APIF77(gmfsethonodesordering)(int64_t *MshIdx, int *KwdCod, int *BasTab, int *OrdTab)\n{\n   return(GmfSetHONodesOrdering(*MshIdx, *KwdCod, BasTab, OrdTab));\n}\n/*\nint APIF77(gmfreadbyteflow)(int64_t *MshIdx, char *BytFlo, int *NmbByt)\n{\n   int TmpNmb;\n   char *TmpFlo;\n\n   TmpFlo = GmfReadByteFlow(*MshIdx, &TmpNmb);\n\n   if(!TmpFlo || NmbByt <= 0 || !BytFlo || TmpNmb > *NmbByt)\n      return(0);\n\n   *NmbByt = TmpNmb;\n   memcpy(BytFlo, TmpFlo, *NmbByt);\n   free(TmpFlo);\n\n   return(TmpNmb);\n}\n\nint APIF77(gmfwritebyteflow)(int64_t *MshIdx, char *BytFlo, int *NmbByt)\n{\n   return(GmfWriteByteFlow(*MshIdx, BytFlo, *NmbByt));\n}\n\nint APIF77(gmfgetfloatprecision)(int64_t *MshIdx)\n{\n   return(GmfGetFloatPrecision(*MshIdx));\n}\n\nint APIF77(gmfsetfloatprecision)(int64_t *MshIdx, int *FltSiz)\n{\n   GmfSetFloatPrecision(*MshIdx, *FltSiz);\n   return(0);\n}\n*/\n\n/*----------------------------------------------------------------------------*/\n/* Duplication macros                                                         */\n/*----------------------------------------------------------------------------*/\n\n#define DUP(s,n) DUP ## n (s)\n#define DUP1(s) s\n#define DUP2(s) DUP1(s),s\n#define DUP3(s) DUP2(s),s\n#define DUP4(s) DUP3(s),s\n#define DUP5(s) DUP4(s),s\n#define DUP6(s) DUP5(s),s\n#define DUP7(s) DUP6(s),s\n#define DUP8(s) DUP7(s),s\n#define DUP9(s) DUP8(s),s\n#define DUP10(s) DUP9(s),s\n#define DUP11(s) DUP10(s),s\n#define DUP12(s) DUP11(s),s\n#define DUP13(s) DUP12(s),s\n#define DUP14(s) DUP13(s),s\n#define DUP15(s) DUP14(s),s\n#define DUP16(s) DUP15(s),s\n#define DUP17(s) DUP16(s),s\n#define DUP18(s) DUP17(s),s\n#define DUP19(s) DUP18(s),s\n#define DUP20(s) DUP19(s),s\n\n\n#define ARG(a,n) ARG ## n (a)\n#define ARG1(a) a[0]\n#define ARG2(a) ARG1(a),a[1]\n#define ARG3(a) ARG2(a),a[2]\n#define ARG4(a) ARG3(a),a[3]\n#define ARG5(a) ARG4(a),a[4]\n#define ARG6(a) ARG5(a),a[5]\n#define ARG7(a) ARG6(a),a[6]\n#define ARG8(a) ARG7(a),a[7]\n#define ARG9(a) ARG8(a),a[8]\n#define ARG10(a) ARG9(a),a[9]\n#define ARG11(a) ARG10(a),a[10]\n#define ARG12(a) ARG11(a),a[11]\n#define ARG13(a) ARG12(a),a[12]\n#define ARG14(a) ARG13(a),a[13]\n#define ARG15(a) ARG14(a),a[14]\n#define ARG16(a) ARG15(a),a[15]\n#define ARG17(a) ARG16(a),a[16]\n#define ARG18(a) ARG17(a),a[17]\n#define ARG19(a) ARG18(a),a[18]\n#define ARG20(a) ARG19(a),a[19]\n\n\n/*----------------------------------------------------------------------------*/\n/* Call a fortran thread with 1 to 20 arguments                               */\n/*----------------------------------------------------------------------------*/\n\nstatic void CalF77Prc(  int64_t BegIdx, int64_t EndIdx,\n                        void *prc, int NmbArg, void **ArgTab )\n{\n   switch(NmbArg)\n   {\n      case 1 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 1)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 1)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 1));\n      }break;\n\n      case 2 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 2)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 2)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 2));\n      }break;\n\n      case 3 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 3)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 3)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 3));\n      }break;\n\n      case 4 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 4)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 4)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 4));\n      }break;\n\n      case 5 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 5)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 5)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 5));\n      }break;\n\n      case 6 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 6)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 6)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 6));\n      }break;\n\n      case 7 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 7)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 7)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 7));\n      }break;\n\n      case 8 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 8)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 8)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 8));\n      }break;\n\n      case 9 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 9)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 9)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 9));\n      }break;\n\n      case 10 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 10)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 10)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 10));\n      }break;\n\n      case 11 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 11)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 11)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 11));\n      }break;\n\n      case 12 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 12)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 12)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 12));\n      }break;\n\n      case 13 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 13)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 13)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 13));\n      }break;\n\n      case 14 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 14)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 14)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 14));\n      }break;\n\n      case 15 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 15)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 15)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 15));\n      }break;\n\n      case 16 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 16)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 16)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 16));\n      }break;\n\n      case 17 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 17)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 17)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 17));\n      }break;\n\n      case 18 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 18)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 18)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 18));\n      }break;\n\n      case 19 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 19)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 19)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 19));\n      }break;\n\n      case 20 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 20)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 20)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 20));\n      }break;\n   }\n}\n\n#endif\n"], "fixing_code": ["\nc     libmeshb example: transform a quadrilateral mesh into a triangular one\nc     using fast block transfer and pipelined post processing\n\n      include 'libmeshb7.ins'\n\n      external qad2tri, movver\n\n      integer n\n      parameter (n=4000)\n      integer i, ver, dim, res\n     +, RefTab(n), TriTab(4,2*n), QadTab(5,n)\n      integer*8 NmbVer, NmbQad, InpMsh, OutMsh\n      real*8 VerTab(3,n)\n\n\nc     --------------------------------------------\nc     Open the quadrilateral mesh file for reading\nc     --------------------------------------------\n\n      InpMsh = gmfopenmesh('../sample_meshes/quad.meshb'\n     +,GmfRead,ver,dim)\n      print*, 'input mesh  :', InpMsh,'version :',ver,'dim :',dim\n\n      if(InpMsh.eq.0) STOP ' InpMsh = 0'\n      if(dim.ne.3) STOP ' dimension <> 3'\n\nc     Check memory bounds\n      NmbVer = gmfstatkwd(InpMsh, GmfVertices)\n      if(NmbVer.gt.n) STOP 'Too many vertices'\n\n      i = gmfstatkwd(InpMsh, GmfSolAtQuadrilaterals)\n      print*, i,'GmfSolAtQuadrilaterals'\n\n      NmbQad = gmfstatkwd(InpMsh, GmfQuadrilaterals)\n      if(NmbQad.gt.n) STOP 'Too many quads'\n\n      print*, 'input mesh  : ',NmbVer,' vertices,',NmbQad,'quads'\n\nc     Read the vertices\n      res = gmfgetblock(InpMsh, GmfVertices, 1_8, NmbVer,\n     +                  0, %val(0), movver, 1, VerTab,\n     +                  GmfDouble, VerTab(1,1), VerTab(1,2),\n     +                  GmfDouble, VerTab(2,1), VerTab(2,2),\n     +                  GmfDouble, VerTab(3,1), VerTab(3,2),\n     +                  GmfInt,    RefTab(1),   RefTab(2))\n\nc     Read the quads\n      res = gmfgetblock(InpMsh, GmfQuadrilaterals, 1_8, NmbQad,\n     +                  0, %val(0), %val(0),\n     +                  GmfInt, QadTab(1,1), QadTab(1,2),\n     +                  GmfInt, QadTab(2,1), QadTab(2,2),\n     +                  GmfInt, QadTab(3,1), QadTab(3,2),\n     +                  GmfInt, QadTab(4,1), QadTab(4,2),\n     +                  GmfInt, QadTab(5,1), QadTab(5,2))\n\nc     Close the quadrilateral mesh\n      res = gmfclosemesh(InpMsh)\n      print*, QadTab(1,1),QadTab(2,1),QadTab(3,1),QadTab(4,1)\n\n\nc     ------------------------\nc     Create a triangular mesh\nc     ------------------------\n\n      OutMsh = gmfopenmesh('tri.meshb', GmfWrite, ver, dim)\n      if(OutMsh.eq.0) STOP ' OutMsh = 0'\n\nc     Set the number of vertices\n      res = gmfsetkwd(OutMsh, GmfVertices, NmbVer, 0 , 0)\n\nc     Then write them down\n      res = gmfsetblock(OutMsh, GmfVertices, 1_8, NmbVer,\n     +                  0, %val(0) ,%val(0),\n     +                  GmfDouble, VerTab(1,1), VerTab(1,2),\n     +                  GmfDouble, VerTab(2,1), VerTab(2,2),\n     +                  GmfDouble, VerTab(3,1), VerTab(3,2),\n     +                  GmfInt,    RefTab(1),   RefTab(2))\n\nc     Write the triangles\n      res = gmfsetkwd(OutMsh, GmfTriangles, 2*NmbQad, 0, 0)\n      res = gmfsetblock(OutMsh, GmfTriangles, 1_8, 2*NmbQad,\n     +                  0,%val(0),\n     +                  qad2tri, 2, QadTab, TriTab,\n     +                  GmfInt, TriTab(1,1), TriTab(1,2),\n     +                  GmfInt, TriTab(2,1), TriTab(2,2),\n     +                  GmfInt, TriTab(3,1), TriTab(3,2),\n     +                  GmfInt, TriTab(4,1), TriTab(4,2))\n\nc     Don't forget to close the file\n      res = gmfclosemesh(OutMsh)\n\n      print*, 'output mesh : ',NmbVer,' vertices,',\n     +         2*NmbQad,'triangles'\n\n      end      \n\n\n\n      subroutine qad2tri(BegIdx,EndIdx,QadTab,TriTab)\n\n      integer*8 i,BegIdx,EndIdx\n      integer TriTab(4,*),QadTab(5,*)\n      print*, 'beg : ',BegIdx, 'end : ', EndIdx\n\n      do i = BegIdx,EndIdx\n          if(mod(i,2) .EQ. 1) then\n              TriTab(1,i) = QadTab(1,i/2)\n              TriTab(2,i) = QadTab(2,i/2)\n              TriTab(3,i) = QadTab(3,i/2)\n              TriTab(4,i) = QadTab(5,i/2)\n          else\n              TriTab(1,i) = QadTab(1,i/2)\n              TriTab(2,i) = QadTab(3,i/2)\n              TriTab(3,i) = QadTab(4,i/2)\n              TriTab(4,i) = QadTab(5,i/2)\n          endif\n      end do\n\n      return\n      end\n\n\n      subroutine movver(BegIdx,EndIdx,VerTab)\n\n      integer*8 i,BegIdx,EndIdx\n      real*8 VerTab(3,*)\n      print*, 'beg : ',BegIdx, 'end : ', EndIdx\n\n      do i = BegIdx,EndIdx\n          VerTab(1,i) = VerTab(1,i)*2\n      end do\n\n      return\n      end\n", "\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*                               LIBMESHB V7.62                               */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*   Description:        handles .meshb file format I/O                       */\n/*   Author:             Loic MARECHAL                                        */\n/*   Creation date:      dec 09 1999                                          */\n/*   Last modification:  jan 07 2022                                          */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\n\n/*----------------------------------------------------------------------------*/\n/* Headers' macros                                                            */\n/*----------------------------------------------------------------------------*/\n\n// Silent Visual Studio warnings on string functions\n#define _CRT_SECURE_NO_WARNINGS\n\n#ifdef F77API\n\n// Add a final underscore to Fortran procedure names\n#ifdef F77_NO_UNDER_SCORE\n#define NAMF77(c,f)  f\n#define APIF77(x)    x\n#else\n#define NAMF77(c,f)  f ## _\n#define APIF77(x)    x ## _\n#endif\n\n// Pass parameters as pointers in Fortran\n#define VALF77(v)    *v\n#define TYPF77(t)    t*\n\n#else\n\n// Pass parameters as values in C\n#define NAMF77(c,f)  c\n#define VALF77(v)    v\n#define TYPF77(t)    t\n\n#endif\n\n\n/*----------------------------------------------------------------------------*/\n/* Includes                                                                   */\n/*----------------------------------------------------------------------------*/\n\n#define _XOPEN_SOURCE 500\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include <setjmp.h>\n#include <fcntl.h>\n\n \n/*\n * [Bruno] include the headers with the prototypes for \n *  open()/close()/write()/lseek() \n *  and define the constants to be used to open() a file. \n *   Under Windows, \n *  1)   _O_BINARY should be set in the flags.\n *  2) 'mode' has a completely different meaning\n */\n\n#if defined(__unix__) || defined(__linux__) || defined(__APPLE__) || defined(__EMSCRIPTEN__)\n\n#include <unistd.h>\n\n#define OPEN_READ_FLAGS   O_RDONLY\n#define OPEN_WRITE_FLAGS  O_CREAT | O_WRONLY | O_TRUNC\n#define OPEN_READ_MODE    0666\n#define OPEN_WRITE_MODE   0666   \n   \n#elif defined(_WIN32) || defined(_WIN64)\n\n#define GMF_WINDOWS\n\n#include <windows.h>\n#include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <wchar.h>\n\n#define OPEN_READ_FLAGS    O_RDONLY | _O_BINARY\n#define OPEN_WRITE_FLAGS   O_CREAT | O_WRONLY | O_TRUNC | _O_BINARY\n#define OPEN_READ_MODE     _S_IREAD\n#define OPEN_WRITE_MODE    _S_IREAD | S_IWRITE \n\n#endif\n\n\n#if defined(_WIN64)\n#define MYFTELL(s) (int64_t)_ftelli64(s)\n#define MYFSEEK(s,o,w) _fseeki64(s,(__int64)o,w)\n#else\n#define MYFTELL(s) ftell(s)\n#define MYFSEEK(s,o,w) fseek(s,o,w)\n#endif\n\n\n#include <errno.h>\n#include <libmeshb7.h>\n\n// [Bruno] Using portable printf modifier from pstdint.h\n// (alternative: use \"%zd\" under Linux and \"%Id\" under Windows)\n\n#ifdef PRINTF_INT64_MODIFIER\n#define INT64_T_FMT \"%\" PRINTF_INT64_MODIFIER \"d\"\n#else\n#   ifdef GMF_WINDOWS\n#    define INT64_T_FMT \"%Id\"\n#   else\n#    include <inttypes.h>\n#    define INT64_T_FMT \"%\" PRId64\n#   endif\n#endif\n\n\n// AIO: hardware or software mockup are both encapsulated into my_aio functions\n\n#ifdef WITH_GMF_AIO\n\n#include <aio.h>\n\nint    my_aio_error (const struct aiocb *aiocbp){return(aio_error (aiocbp));}\nint    my_aio_read  (      struct aiocb *aiocbp){return(aio_read  (aiocbp));}\nsize_t my_aio_return(      struct aiocb *aiocbp){return(aio_return(aiocbp));}\nint    my_aio_write (      struct aiocb *aiocbp){return(aio_write (aiocbp));}\n\n#else\n\n// Mockup aio library\n\nstruct aiocb\n{\n   FILE   *aio_fildes;         // File descriptor\n   off_t  aio_offset;          // File offset\n   void   *aio_buf;            // Location of buffer\n   size_t aio_nbytes;          // Length of transfer\n   int    aio_lio_opcode;      // Operation to be performed\n};\n\nint my_aio_error(const struct aiocb *aiocbp)\n{\n   return(aiocbp->aio_lio_opcode);\n}\n\n// Set the file position and read a block of data\nint my_aio_read(struct aiocb *aiocbp)\n{\n   if( (MYFSEEK(aiocbp->aio_fildes, (off_t)aiocbp->aio_offset, SEEK_SET) == 0)\n   &&  (fread(aiocbp->aio_buf, 1, aiocbp->aio_nbytes, aiocbp->aio_fildes)\n       == aiocbp->aio_nbytes) )\n   {\n      aiocbp->aio_lio_opcode = 0;\n   }\n   else\n   {\n      aiocbp->aio_lio_opcode = -1;\n   }\n\n   return(aiocbp->aio_lio_opcode);\n}\n\nsize_t my_aio_return(struct aiocb *aiocbp)\n{\n   return(aiocbp->aio_nbytes);\n}\n\n// Set the file position and write a block of data\nint my_aio_write(struct aiocb *aiocbp)\n{\n   if( (MYFSEEK(aiocbp->aio_fildes, (off_t)aiocbp->aio_offset, SEEK_SET) == 0)\n   &&  (fwrite(aiocbp->aio_buf, 1, aiocbp->aio_nbytes, aiocbp->aio_fildes)\n       == aiocbp->aio_nbytes) )\n   {\n      aiocbp->aio_lio_opcode = 0;\n   }\n   else\n   {\n      aiocbp->aio_lio_opcode = -1;\n   }\n\n   return(aiocbp->aio_lio_opcode);\n}\n\n#endif\n\n\n/*----------------------------------------------------------------------------*/\n/* Defines                                                                    */\n/*----------------------------------------------------------------------------*/\n\n#define Asc       1\n#define Bin       2\n#define MshFil    4\n#define SolFil    8\n#define InfKwd    1\n#define RegKwd    2\n#define SolKwd    3\n#define CmtKwd    4\n#define WrdSiz    4\n#define FilStrSiz 64\n#define BufSiz    10000L\n#define MaxArg    20\n\n\n\n/*----------------------------------------------------------------------------*/\n/* Structures                                                                 */\n/*----------------------------------------------------------------------------*/\n\ntypedef struct\n{\n   int      typ, deg, NmbNod, SolSiz, NmbWrd, NmbTyp, TypTab[ GmfMaxTyp ];\n   int      *OrdTab;\n   int64_t  NmbLin;\n   size_t   pos;\n   char     fmt[ GmfMaxTyp*9 ];\n}KwdSct;\n\ntypedef struct\n{\n   int      dim, ver, mod, typ, cod, FilDes, FltSiz;\n   int64_t  NexKwdPos, siz;\n   size_t   pos;\n   jmp_buf  err;\n   KwdSct   KwdTab[ GmfMaxKwd + 1 ];\n   FILE     *hdl;\n   int      *IntBuf;\n   float    *FltBuf;\n   char     *buf;\n   char     FilNam[ GmfStrSiz ];\n   double   DblBuf[1000/8];\n   unsigned char blk[ BufSiz + 1000L ];\n}GmfMshSct;\n\n\n/*----------------------------------------------------------------------------*/\n/* Global variables                                                           */\n/*----------------------------------------------------------------------------*/\n\nconst char *GmfKwdFmt[ GmfMaxKwd + 1 ][3] = \n{\n   {\"Reserved\",                                 \"\", \"\"},\n   {\"MeshVersionFormatted\",                     \"\", \"i\"},\n   {\"Reserved\",                                 \"\", \"\"},\n   {\"Dimension\",                                \"\", \"i\"},\n   {\"Vertices\",                                 \"i\", \"dri\"},\n   {\"Edges\",                                    \"i\", \"iii\"},\n   {\"Triangles\",                                \"i\", \"iiii\"},\n   {\"Quadrilaterals\",                           \"i\", \"iiiii\"},\n   {\"Tetrahedra\",                               \"i\", \"iiiii\"},\n   {\"Prisms\",                                   \"i\", \"iiiiiii\"},\n   {\"Hexahedra\",                                \"i\", \"iiiiiiiii\"},\n   {\"Reserved\",                                 \"\",  \"\"},\n   {\"Reserved\",                                 \"\",  \"\"},\n   {\"Corners\",                                  \"i\", \"i\"},\n   {\"Ridges\",                                   \"i\", \"i\"},\n   {\"RequiredVertices\",                         \"i\", \"i\"},\n   {\"RequiredEdges\",                            \"i\", \"i\"},\n   {\"RequiredTriangles\",                        \"i\", \"i\"},\n   {\"RequiredQuadrilaterals\",                   \"i\", \"i\"},\n   {\"TangentAtEdgeVertices\",                    \"i\", \"iii\"},\n   {\"NormalAtVertices\",                         \"i\", \"ii\"},\n   {\"NormalAtTriangleVertices\",                 \"i\", \"iii\"},\n   {\"NormalAtQuadrilateralVertices\",            \"i\", \"iiii\"},\n   {\"AngleOfCornerBound\",                       \"\",  \"r\"},\n   {\"TrianglesP2\",                              \"i\", \"iiiiiii\"},\n   {\"EdgesP2\",                                  \"i\", \"iiii\"},\n   {\"SolAtPyramids\",                            \"i\", \"sr\"},\n   {\"QuadrilateralsQ2\",                         \"i\", \"iiiiiiiiii\"},\n   {\"ISolAtPyramids\",                           \"i\", \"iiiii\"},\n   {\"SubDomainFromGeom\",                        \"i\", \"iii\"},\n   {\"TetrahedraP2\",                             \"i\", \"iiiiiiiiiii\"},\n   {\"Fault_NearTri\",                            \"i\", \"i\"},\n   {\"Fault_Inter\",                              \"i\", \"i\"},\n   {\"HexahedraQ2\",                              \"i\", \"iiiiiiiiiiiiiiiiiiiiiiiiiiii\"},\n   {\"ExtraVerticesAtEdges\",                     \"i\", \"in\"},\n   {\"ExtraVerticesAtTriangles\",                 \"i\", \"in\"},\n   {\"ExtraVerticesAtQuadrilaterals\",            \"i\", \"in\"},\n   {\"ExtraVerticesAtTetrahedra\",                \"i\", \"in\"},\n   {\"ExtraVerticesAtPrisms\",                    \"i\", \"in\"},\n   {\"ExtraVerticesAtHexahedra\",                 \"i\", \"in\"},\n   {\"VerticesOnGeometricVertices\",              \"i\", \"ii\"},\n   {\"VerticesOnGeometricEdges\",                 \"i\", \"iirr\"},\n   {\"VerticesOnGeometricTriangles\",             \"i\", \"iirrr\"},\n   {\"VerticesOnGeometricQuadrilaterals\",        \"i\", \"iirrr\"},\n   {\"EdgesOnGeometricEdges\",                    \"i\", \"ii\"},\n   {\"Fault_FreeEdge\",                           \"i\", \"i\"},\n   {\"Polyhedra\",                                \"i\", \"iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\"},\n   {\"Polygons\",                                 \"\",  \"iiiiiiiii\"},\n   {\"Fault_Overlap\",                            \"i\", \"i\"},\n   {\"Pyramids\",                                 \"i\", \"iiiiii\"},\n   {\"BoundingBox\",                              \"\",  \"drdr\"},\n   {\"Reserved\",                                 \"\",  \"\"},\n   {\"PrivateTable\",                             \"i\", \"i\"},\n   {\"Fault_BadShape\",                           \"i\", \"i\"},\n   {\"End\",                                      \"\",  \"\"},\n   {\"TrianglesOnGeometricTriangles\",            \"i\", \"ii\"},\n   {\"TrianglesOnGeometricQuadrilaterals\",       \"i\", \"ii\"},\n   {\"QuadrilateralsOnGeometricTriangles\",       \"i\", \"ii\"},\n   {\"QuadrilateralsOnGeometricQuadrilaterals\",  \"i\", \"ii\"},\n   {\"Tangents\",                                 \"i\", \"dr\"},\n   {\"Normals\",                                  \"i\", \"dr\"},\n   {\"TangentAtVertices\",                        \"i\", \"ii\"},\n   {\"SolAtVertices\",                            \"i\", \"sr\"},\n   {\"SolAtEdges\",                               \"i\", \"sr\"},\n   {\"SolAtTriangles\",                           \"i\", \"sr\"},\n   {\"SolAtQuadrilaterals\",                      \"i\", \"sr\"},\n   {\"SolAtTetrahedra\",                          \"i\", \"sr\"},\n   {\"SolAtPrisms\",                              \"i\", \"sr\"},\n   {\"SolAtHexahedra\",                           \"i\", \"sr\"},\n   {\"DSolAtVertices\",                           \"i\", \"sr\"},\n   {\"ISolAtVertices\",                           \"i\", \"i\"},\n   {\"ISolAtEdges\",                              \"i\", \"ii\"},\n   {\"ISolAtTriangles\",                          \"i\", \"iii\"},\n   {\"ISolAtQuadrilaterals\",                     \"i\", \"iiii\"},\n   {\"ISolAtTetrahedra\",                         \"i\", \"iiii\"},\n   {\"ISolAtPrisms\",                             \"i\", \"iiiiii\"},\n   {\"ISolAtHexahedra\",                          \"i\", \"iiiiiiii\"},\n   {\"Iterations\",                               \"\",  \"i\"},\n   {\"Time\",                                     \"\",  \"r\"},\n   {\"Fault_SmallTri\",                           \"i\", \"i\"},\n   {\"CoarseHexahedra\",                          \"i\", \"i\"},\n   {\"Comments\",                                 \"i\", \"c\"},\n   {\"PeriodicVertices\",                         \"i\", \"ii\"},\n   {\"PeriodicEdges\",                            \"i\", \"ii\"},\n   {\"PeriodicTriangles\",                        \"i\", \"ii\"},\n   {\"PeriodicQuadrilaterals\",                   \"i\", \"ii\"},\n   {\"PrismsP2\",                                 \"i\", \"iiiiiiiiiiiiiiiiiii\"},\n   {\"PyramidsP2\",                               \"i\", \"iiiiiiiiiiiiiii\"},\n   {\"QuadrilateralsQ3\",                         \"i\", \"iiiiiiiiiiiiiiiii\"},\n   {\"QuadrilateralsQ4\",                         \"i\", \"iiiiiiiiiiiiiiiiiiiiiiiiii\"},\n   {\"TrianglesP3\",                              \"i\", \"iiiiiiiiiii\"},\n   {\"TrianglesP4\",                              \"i\", \"iiiiiiiiiiiiiiii\"},\n   {\"EdgesP3\",                                  \"i\", \"iiiii\"},\n   {\"EdgesP4\",                                  \"i\", \"iiiiii\"},\n   {\"IRefGroups\",                               \"i\", \"ciii\"},\n   {\"DRefGroups\",                               \"i\", \"iii\"},\n   {\"TetrahedraP3\",                             \"i\", \"iiiiiiiiiiiiiiiiiiiii\"},\n   {\"TetrahedraP4\",                             \"i\", \"iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\"},\n   {\"HexahedraQ3\",                              \"i\", \"iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\"},\n   {\"HexahedraQ4\",                              \"i\", \"iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\"},\n   {\"PyramidsP3\",                               \"i\", \"iiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\"},\n   {\"PyramidsP4\",                               \"i\", \"iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\"},\n   {\"PrismsP3\",                                 \"i\", \"iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\"},\n   {\"PrismsP4\",                                 \"i\", \"iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\"},\n   {\"HOSolAtEdgesP1\",                           \"i\", \"hr\"},\n   {\"HOSolAtEdgesP2\",                           \"i\", \"hr\"},\n   {\"HOSolAtEdgesP3\",                           \"i\", \"hr\"},\n   {\"HOSolAtTrianglesP1\",                       \"i\", \"hr\"},\n   {\"HOSolAtTrianglesP2\",                       \"i\", \"hr\"},\n   {\"HOSolAtTrianglesP3\",                       \"i\", \"hr\"},\n   {\"HOSolAtQuadrilateralsQ1\",                  \"i\", \"hr\"},\n   {\"HOSolAtQuadrilateralsQ2\",                  \"i\", \"hr\"},\n   {\"HOSolAtQuadrilateralsQ3\",                  \"i\", \"hr\"},\n   {\"HOSolAtTetrahedraP1\",                      \"i\", \"hr\"},\n   {\"HOSolAtTetrahedraP2\",                      \"i\", \"hr\"},\n   {\"HOSolAtTetrahedraP3\",                      \"i\", \"hr\"},\n   {\"HOSolAtPyramidsP1\",                        \"i\", \"hr\"},\n   {\"HOSolAtPyramidsP2\",                        \"i\", \"hr\"},\n   {\"HOSolAtPyramidsP3\",                        \"i\", \"hr\"},\n   {\"HOSolAtPrismsP1\",                          \"i\", \"hr\"},\n   {\"HOSolAtPrismsP2\",                          \"i\", \"hr\"},\n   {\"HOSolAtPrismsP3\",                          \"i\", \"hr\"},\n   {\"HOSolAtHexahedraQ1\",                       \"i\", \"hr\"},\n   {\"HOSolAtHexahedraQ2\",                       \"i\", \"hr\"},\n   {\"HOSolAtHexahedraQ3\",                       \"i\", \"hr\"},\n   {\"BezierBasis\",                              \"\",  \"i\"},\n   {\"ByteFlow\",                                 \"i\", \"i\"},\n   {\"EdgesP2Ordering\",                          \"i\", \"i\"},\n   {\"EdgesP3Ordering\",                          \"i\", \"i\"},\n   {\"TrianglesP2Ordering\",                      \"i\", \"iii\"},\n   {\"TrianglesP3Ordering\",                      \"i\", \"iii\"},\n   {\"QuadrilateralsQ2Ordering\",                 \"i\", \"ii\"},\n   {\"QuadrilateralsQ3Ordering\",                 \"i\", \"ii\"},\n   {\"TetrahedraP2Ordering\",                     \"i\", \"iiii\"},\n   {\"TetrahedraP3Ordering\",                     \"i\", \"iiii\"},\n   {\"PyramidsP2Ordering\",                       \"i\", \"iii\"},\n   {\"PyramidsP3Ordering\",                       \"i\", \"iii\"},\n   {\"PrismsP2Ordering\",                         \"i\", \"iiii\"},\n   {\"PrismsP3Ordering\",                         \"i\", \"iiii\"},\n   {\"HexahedraQ2Ordering\",                      \"i\", \"iii\"},\n   {\"HexahedraQ3Ordering\",                      \"i\", \"iii\"},\n   {\"EdgesP1Ordering\",                          \"i\", \"i\"},\n   {\"EdgesP4Ordering\",                          \"i\", \"i\"},\n   {\"TrianglesP1Ordering\",                      \"i\", \"iii\"},\n   {\"TrianglesP4Ordering\",                      \"i\", \"iii\"},\n   {\"QuadrilateralsQ1Ordering\",                 \"i\", \"ii\"},\n   {\"QuadrilateralsQ4Ordering\",                 \"i\", \"ii\"},\n   {\"TetrahedraP1Ordering\",                     \"i\", \"iiii\"},\n   {\"TetrahedraP4Ordering\",                     \"i\", \"iiii\"},\n   {\"PyramidsP1Ordering\",                       \"i\", \"iii\"},\n   {\"PyramidsP4Ordering\",                       \"i\", \"iii\"},\n   {\"PrismsP1Ordering\",                         \"i\", \"iiii\"},\n   {\"PrismsP4Ordering\",                         \"i\", \"iiii\"},\n   {\"HexahedraQ1Ordering\",                      \"i\", \"iii\"},\n   {\"HexahedraQ4Ordering\",                      \"i\", \"iii\"},\n   {\"FloatingPointPrecision\",                   \"\",  \"i\"},\n   {\"HOSolAtEdgesP4\",                           \"i\", \"hr\"},\n   {\"HOSolAtTrianglesP4\",                       \"i\", \"hr\"},\n   {\"HOSolAtQuadrilateralsQ4\",                  \"i\", \"hr\"},\n   {\"HOSolAtTetrahedraP4\",                      \"i\", \"hr\"},\n   {\"HOSolAtPyramidsP4\",                        \"i\", \"hr\"},\n   {\"HOSolAtPrismsP4\",                          \"i\", \"hr\"},\n   {\"HOSolAtHexahedraQ4\",                       \"i\", \"hr\"},\n   {\"HOSolAtEdgesP1NodesPositions\",             \"i\", \"rr\"},\n   {\"HOSolAtEdgesP2NodesPositions\",             \"i\", \"rr\"},\n   {\"HOSolAtEdgesP3NodesPositions\",             \"i\", \"rr\"},\n   {\"HOSolAtEdgesP4NodesPositions\",             \"i\", \"rr\"},\n   {\"HOSolAtTrianglesP1NodesPositions\",         \"i\", \"rrr\"},\n   {\"HOSolAtTrianglesP2NodesPositions\",         \"i\", \"rrr\"},\n   {\"HOSolAtTrianglesP3NodesPositions\",         \"i\", \"rrr\"},\n   {\"HOSolAtTrianglesP4NodesPositions\",         \"i\", \"rrr\"},\n   {\"HOSolAtQuadrilateralsQ1NodesPositions\",    \"i\", \"rr\"},\n   {\"HOSolAtQuadrilateralsQ2NodesPositions\",    \"i\", \"rr\"},\n   {\"HOSolAtQuadrilateralsQ3NodesPositions\",    \"i\", \"rr\"},\n   {\"HOSolAtQuadrilateralsQ4NodesPositions\",    \"i\", \"rr\"},\n   {\"HOSolAtTetrahedraP1NodesPositions\",        \"i\", \"rrrr\"},\n   {\"HOSolAtTetrahedraP2NodesPositions\",        \"i\", \"rrrr\"},\n   {\"HOSolAtTetrahedraP3NodesPositions\",        \"i\", \"rrrr\"},\n   {\"HOSolAtTetrahedraP4NodesPositions\",        \"i\", \"rrrr\"},\n   {\"HOSolAtPyramidsP1NodesPositions\",          \"i\", \"rrr\"},\n   {\"HOSolAtPyramidsP2NodesPositions\",          \"i\", \"rrr\"},\n   {\"HOSolAtPyramidsP3NodesPositions\",          \"i\", \"rrr\"},\n   {\"HOSolAtPyramidsP4NodesPositions\",          \"i\", \"rrr\"},\n   {\"HOSolAtPrismsP1NodesPositions\",            \"i\", \"rrrr\"},\n   {\"HOSolAtPrismsP2NodesPositions\",            \"i\", \"rrrr\"},\n   {\"HOSolAtPrismsP3NodesPositions\",            \"i\", \"rrrr\"},\n   {\"HOSolAtPrismsP4NodesPositions\",            \"i\", \"rrrr\"},\n   {\"HOSolAtHexahedraQ1NodesPositions\",         \"i\", \"rrr\"},\n   {\"HOSolAtHexahedraQ2NodesPositions\",         \"i\", \"rrr\"},\n   {\"HOSolAtHexahedraQ3NodesPositions\",         \"i\", \"rrr\"},\n   {\"HOSolAtHexahedraQ4NodesPositions\",         \"i\", \"rrr\"},\n   {\"EdgesReferenceElement\",                    \"\",  \"rr\"},\n   {\"TriangleReferenceElement\",                 \"\",  \"rrrrrr\"},\n   {\"QuadrilateralReferenceElement\",            \"\",  \"rrrrrrrr\"},\n   {\"TetrahedronReferenceElement\",              \"\",  \"rrrrrrrrrrrr\"},\n   {\"PyramidReferenceElement\",                  \"\",  \"rrrrrrrrrrrrrrr\"},\n   {\"PrismReferenceElement\",                    \"\",  \"rrrrrrrrrrrrrrrrrr\"},\n   {\"HexahedronReferenceElement\",               \"\",  \"rrrrrrrrrrrrrrrrrrrrrrrr\"},\n   {\"BoundaryLayers\",                           \"i\", \"iii\"},\n   {\"ReferenceStrings\",                         \"i\", \"iic\"},\n   {\"Prisms9\",                                  \"i\", \"iiiiiiiiii\"},\n   {\"Hexahedra12\",                              \"i\", \"iiiiiiiiiiiii\"},\n   {\"Quadrilaterals6\",                          \"i\", \"iiiiiii\"},\n   {\"BoundaryPolygonHeaders\",                   \"i\", \"ii\"},\n   {\"BoundaryPolygonVertices\",                  \"i\", \"i\"},\n   {\"InnerPolygonHeaders\",                      \"i\", \"ii\"},\n   {\"InnerPolygonVertices\",                     \"i\", \"i\"},\n   {\"PolyhedraHeaders\",                         \"i\", \"ii\"},\n   {\"PolyhedraFaces\",                           \"i\", \"i\"},\n   {\"Domains\",                                  \"\",  \"ii\"},\n   {\"VerticesGID\",                              \"i\", \"iii\"},\n   {\"EdgesGID\",                                 \"i\", \"iii\"},\n   {\"TrianglesGID\",                             \"i\", \"iii\"},\n   {\"QuadrilateralsGID\",                        \"i\", \"iii\"},\n   {\"TetrahedraGID\",                            \"i\", \"iii\"},\n   {\"PyramidsGID\",                              \"i\", \"iii\"},\n   {\"PrismsGID\",                                \"i\", \"iii\"},\n   {\"HexahedraGID\",                             \"i\", \"iii\"},\n};\n\n#ifdef TRANSMESH\nint GmfMaxRefTab[ GmfMaxKwd + 1 ];\n#endif\n\n\n/*----------------------------------------------------------------------------*/\n/* Prototypes of local procedures                                             */\n/*----------------------------------------------------------------------------*/\n\nstatic void    ScaWrd   (GmfMshSct *, void *);\nstatic void    ScaDblWrd(GmfMshSct *, void *);\nstatic int64_t GetPos   (GmfMshSct *);\nstatic void    RecWrd   (GmfMshSct *, const void *);\nstatic void    RecDblWrd(GmfMshSct *, const void *);\nstatic void    RecBlk   (GmfMshSct *, const void *, int);\nstatic void    SetPos   (GmfMshSct *, int64_t);\nstatic int     ScaKwdTab(GmfMshSct *);\nstatic void    ExpFmt   (GmfMshSct *, int);\nstatic void    ScaKwdHdr(GmfMshSct *, int);\nstatic void    SwpWrd   (char *, int);\nstatic int     SetFilPos(GmfMshSct *, int64_t);\nstatic int64_t GetFilPos(GmfMshSct *msh);\nstatic int64_t GetFilSiz(GmfMshSct *);\n#ifdef F77API\nstatic void    CalF77Prc(int64_t, int64_t, void *, int, void **);\n#endif\n\n\n/*----------------------------------------------------------------------------*/\n/* Fscanf and fgets checking for errors                                       */\n/*----------------------------------------------------------------------------*/\n\n#define safe_fscanf(hdl, format, ptr, JmpErr) \\\n   do { \\\n      if( fscanf(hdl, format, ptr) != 1 ) \\\n         longjmp( JmpErr, -1); \\\n   } while(0)\n\n\n#define safe_fgets(ptr, siz, hdl, JmpErr) \\\n   do { \\\n      if( fgets(ptr, siz, hdl) == NULL ) \\\n         longjmp( JmpErr, -2); \\\n   } while(0)\n\n\n#define safe_fread(ptr, siz, nit, str, JmpErr) \\\n   do { \\\n      if( fread(ptr, siz, nit, str) != nit ) \\\n         longjmp( JmpErr, -3); \\\n   } while(0)\n\n\n/*----------------------------------------------------------------------------*/\n/* Open a mesh file in read or write mode                                     */\n/*----------------------------------------------------------------------------*/\n\nint64_t GmfOpenMesh(const char *FilNam, int mod, ...)\n{\n   int      KwdCod, res, *PtrVer, *PtrDim, err;\n   int64_t  MshIdx;\n   char     str[ GmfStrSiz ];\n   va_list  VarArg;\n   GmfMshSct *msh;\n\n   /*---------------------*/\n   /* MESH STRUCTURE INIT */\n   /*---------------------*/\n\n   if(!(msh = calloc(1, sizeof(GmfMshSct))))\n      return(0);\n\n   MshIdx = (int64_t)msh;\n\n   // Save the current stack environment for longjmp\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(msh->hdl != NULL)\n         fclose(msh->hdl);\n\n      if(msh->FilDes != 0)\n#ifdef GMF_WINDOWS\n         _close(msh->FilDes);\n#else\n         close(msh->FilDes);\n#endif\n\n      free(msh);\n      return(0);\n   }\n\n   // Copy the FilNam into the structure\n   if(strlen(FilNam) + 7 >= GmfStrSiz)\n      longjmp(msh->err, -4);\n\n   strcpy(msh->FilNam, FilNam);\n\n   // Store the opening mod (read or write) and guess\n   // the filetype (binary or ascii) depending on the extension\n   msh->mod = mod;\n   msh->buf = (void *)msh->DblBuf;\n   msh->FltBuf = (void *)msh->DblBuf;\n   msh->IntBuf = (void *)msh->DblBuf;\n\n   if(strstr(msh->FilNam, \".meshb\"))\n      msh->typ |= (Bin | MshFil);\n   else if(strstr(msh->FilNam, \".mesh\"))\n      msh->typ |= (Asc | MshFil);\n   else if(strstr(msh->FilNam, \".solb\"))\n      msh->typ |= (Bin | SolFil);\n   else if(strstr(msh->FilNam, \".sol\"))\n      msh->typ |= (Asc | SolFil);\n   else\n      longjmp(msh->err, -5);\n\n   // Open the file in the required mod and initialize the mesh structure\n   if(msh->mod == GmfRead)\n   {\n\n      /*-----------------------*/\n      /* OPEN FILE FOR READING */\n      /*-----------------------*/\n\n      va_start(VarArg, mod);\n      PtrVer = va_arg(VarArg, int *);\n      PtrDim = va_arg(VarArg, int *);\n      va_end(VarArg);\n\n      // Read the endian coding tag, the mesh version\n      // and the mesh dimension (mandatory kwd)\n      if(msh->typ & Bin)\n      {\n         // Create the name string and open the file\n#ifdef WITH_GMF_AIO\n         // [Bruno] added binary flag (necessary under Windows)\n         msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE);\n\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -6);\n\n         // Read the endian coding tag\n         if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz)\n            longjmp(msh->err, -7);\n#else\n         // [Bruno] added binary flag (necessary under Windows)\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -8);\n\n         // Read the endian coding tag\n         safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err);\n#endif\n\n         // Read the mesh version and the mesh dimension (mandatory kwd)\n         if( (msh->cod != 1) && (msh->cod != 16777216) )\n            longjmp(msh->err, -9);\n\n         ScaWrd(msh, (unsigned char *)&msh->ver);\n\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -10);\n\n         if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n            longjmp(msh->err, -11);\n\n         ScaWrd(msh, (unsigned char *)&KwdCod);\n\n         if(KwdCod != GmfDimension)\n            longjmp(msh->err, -12);\n\n         GetPos(msh);\n         ScaWrd(msh, (unsigned char *)&msh->dim);\n      }\n      else\n      {\n         // Create the name string and open the file\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -13);\n\n         do\n         {\n            res = fscanf(msh->hdl, \"%100s\", str);\n         }while( (res != EOF) && strcmp(str, \"MeshVersionFormatted\") );\n\n         if(res == EOF)\n            longjmp(msh->err, -14);\n\n         safe_fscanf(msh->hdl, \"%d\", &msh->ver, msh->err);\n\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -15);\n\n         do\n         {\n            res = fscanf(msh->hdl, \"%100s\", str);\n         }while( (res != EOF) && strcmp(str, \"Dimension\") );\n\n         if(res == EOF)\n            longjmp(msh->err, -16);\n\n         safe_fscanf(msh->hdl, \"%d\", &msh->dim, msh->err);\n      }\n\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -17);\n\n      (*PtrVer) = msh->ver;\n      (*PtrDim) = msh->dim;\n\n      // Set default real numbers size\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n\n      /*------------*/\n      /* KW READING */\n      /*------------*/\n\n      // Read the list of kw present in the file\n      if(!ScaKwdTab(msh))\n         return(0);\n\n      return(MshIdx);\n   }\n   else if(msh->mod == GmfWrite)\n   {\n\n      /*-----------------------*/\n      /* OPEN FILE FOR WRITING */\n      /*-----------------------*/\n\n      msh->cod = 1;\n\n      // Check if the user provided a valid version number and dimension\n      va_start(VarArg, mod);\n      msh->ver = va_arg(VarArg, int);\n      msh->dim = va_arg(VarArg, int);\n      va_end(VarArg);\n\n      if( (msh->ver < 1) || (msh->ver > 4) )\n         longjmp(msh->err, -18);\n\n      if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n         longjmp(msh->err, -19);\n\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -20);\n\n      // Set default real numbers size\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n\n      // Create the mesh file\n      if(msh->typ & Bin) \n      {\n         /* \n          * [Bruno] replaced previous call to creat():\n          * with a call to open(), because Windows needs the\n          * binary flag to be specified.\n          */\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE);\n\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -21);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n            longjmp(msh->err, -22);\n#endif\n      }\n      else if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n         longjmp(msh->err, -23);\n\n\n      /*------------*/\n      /* KW WRITING */\n      /*------------*/\n\n      // Write the mesh version and dimension\n      if(msh->typ & Asc)\n      {\n         fprintf(msh->hdl, \"%s %d\\n\\n\",\n               GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver);\n         fprintf(msh->hdl, \"%s %d\\n\",\n               GmfKwdFmt[ GmfDimension ][0], msh->dim);\n      }\n      else\n      {\n         RecWrd(msh, (unsigned char *)&msh->cod);\n         RecWrd(msh, (unsigned char *)&msh->ver);\n         GmfSetKwd(MshIdx, GmfDimension, 0);\n         RecWrd(msh, (unsigned char *)&msh->dim);\n      }\n\n      return(MshIdx);\n   }\n   else\n   {\n      free(msh);\n      return(0);\n   }\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Close a meshfile in the right way                                          */\n/*----------------------------------------------------------------------------*/\n\nint GmfCloseMesh(int64_t MshIdx)\n{\n   int i, res = 1;\n   GmfMshSct *msh = (GmfMshSct *)MshIdx;\n\n   RecBlk(msh, msh->buf, 0);\n\n   // In write down the \"End\" kw in write mode\n   if(msh->mod == GmfWrite)\n   {\n      if(msh->typ & Asc)\n         fprintf(msh->hdl, \"\\n%s\\n\", GmfKwdFmt[ GmfEnd ][0]);\n      else\n         GmfSetKwd(MshIdx, GmfEnd, 0);\n   }\n\n   // Close the file and free the mesh structure\n   if(msh->typ & Bin)\n#ifdef WITH_GMF_AIO\n      close(msh->FilDes);\n#else\n      fclose(msh->hdl);\n#endif\n   else if(fclose(msh->hdl))\n      res = 0;\n\n   // Free optional H.O. renumbering tables\n   for(i=0;i<GmfLastKeyword;i++)\n      if(msh->KwdTab[i].OrdTab)\n         free(msh->KwdTab[i].OrdTab);\n\n   free(msh);\n\n   return(res);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Read the number of lines and set the position to this kwd                  */\n/*----------------------------------------------------------------------------*/\n\nint64_t GmfStatKwd(int64_t MshIdx, int KwdCod, ...)\n{\n   int         i, *PtrNmbTyp, *PtrSolSiz, *TypTab, *PtrDeg, *PtrNmbNod;\n   GmfMshSct   *msh = (GmfMshSct *)MshIdx;\n   KwdSct      *kwd;\n   va_list     VarArg;\n\n   if( (KwdCod < 1) || (KwdCod > GmfMaxKwd) )\n      return(0);\n\n   kwd = &msh->KwdTab[ KwdCod ];\n\n   if(!kwd->NmbLin)\n      return(0);\n\n   // Read further arguments if this kw is a sol\n   if(kwd->typ == SolKwd)\n   {\n      va_start(VarArg, KwdCod);\n\n      PtrNmbTyp = va_arg(VarArg, int *);\n      *PtrNmbTyp = kwd->NmbTyp;\n\n      PtrSolSiz = va_arg(VarArg, int *);\n      *PtrSolSiz = kwd->SolSiz;\n\n      TypTab = va_arg(VarArg, int *);\n\n      for(i=0;i<kwd->NmbTyp;i++)\n         TypTab[i] = kwd->TypTab[i];\n\n      // Add two extra paramaters for HO elements: degree and nmb nodes\n      if(!strcmp(\"hr\", GmfKwdFmt[ KwdCod ][2]) )\n      {\n         PtrDeg = va_arg(VarArg, int *);\n         *PtrDeg = kwd->deg;\n         \n         PtrNmbNod = va_arg(VarArg, int *);\n         *PtrNmbNod = kwd->NmbNod;\n      }\n\n      va_end(VarArg);\n   }\n\n   return(kwd->NmbLin);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Set the current file position to a given kwd                               */\n/*----------------------------------------------------------------------------*/\n\nint GmfGotoKwd(int64_t MshIdx, int KwdCod)\n{\n   GmfMshSct   *msh = (GmfMshSct *)MshIdx;\n   KwdSct      *kwd = &msh->KwdTab[ KwdCod ];\n\n   if( (KwdCod < 1) || (KwdCod > GmfMaxKwd) || !kwd->NmbLin )\n      return(0);\n\n   return(SetFilPos(msh, kwd->pos));\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Write the kwd and set the number of lines                                  */\n/*----------------------------------------------------------------------------*/\n\nint GmfSetKwd(int64_t MshIdx, int KwdCod, int64_t NmbLin, ...)\n{\n   int         i, *TypTab;\n   int64_t     CurPos;\n   va_list     VarArg;\n   GmfMshSct   *msh = (GmfMshSct *)MshIdx;\n   KwdSct      *kwd;\n\n   RecBlk(msh, msh->buf, 0);\n\n   if( (KwdCod < 1) || (KwdCod > GmfMaxKwd) )\n      return(0);\n\n   kwd = &msh->KwdTab[ KwdCod ];\n\n   // Read further arguments if this kw is a solution\n   if(!strcmp(GmfKwdFmt[ KwdCod ][2], \"sr\")\n   || !strcmp(GmfKwdFmt[ KwdCod ][2], \"hr\"))\n   {\n      va_start(VarArg, NmbLin);\n\n      kwd->NmbTyp = va_arg(VarArg, int);\n      TypTab = va_arg(VarArg, int *);\n\n      for(i=0;i<kwd->NmbTyp;i++)\n         kwd->TypTab[i] = TypTab[i];\n\n      // Add two extra paramaters for HO elements: degree and nmb nodes\n      if(!strcmp(\"hr\", GmfKwdFmt[ KwdCod ][2]))\n      {\n         kwd->deg = va_arg(VarArg, int);\n         kwd->NmbNod = va_arg(VarArg, int);\n      }\n\n      va_end(VarArg);\n   }\n\n   // Setup the kwd info\n   ExpFmt(msh, KwdCod);\n\n   if(!kwd->typ)\n      return(0);\n   else if(kwd->typ == InfKwd)\n      kwd->NmbLin = 1;\n   else\n      kwd->NmbLin = NmbLin;\n\n   // Store the next kwd position in binary file\n   if( (msh->typ & Bin) && msh->NexKwdPos )\n   {\n      CurPos = GetFilPos(msh);\n\n      if(!SetFilPos(msh, msh->NexKwdPos))\n         return(0);\n\n      SetPos(msh, CurPos);\n\n      if(!SetFilPos(msh, CurPos))\n         return(0);\n   }\n\n   // Write the header\n   if(msh->typ & Asc)\n   {\n      fprintf(msh->hdl, \"\\n%s\\n\", GmfKwdFmt[ KwdCod ][0]);\n\n      if(kwd->typ != InfKwd)\n         fprintf(msh->hdl, INT64_T_FMT\"\\n\", kwd->NmbLin);\n\n      // In case of solution field, write the extended header\n      if(kwd->typ == SolKwd)\n      {\n         fprintf(msh->hdl, \"%d \", kwd->NmbTyp);\n\n         for(i=0;i<kwd->NmbTyp;i++)\n            fprintf(msh->hdl, \"%d \", kwd->TypTab[i]);\n\n         fprintf(msh->hdl, \"\\n\");\n      }\n\n      if(!strcmp(\"hr\", GmfKwdFmt[ KwdCod ][2]))\n         fprintf(msh->hdl, \"%d %d\\n\", kwd->deg, kwd->NmbNod);\n   }\n   else\n   {\n      RecWrd(msh, (unsigned char *)&KwdCod);\n      msh->NexKwdPos = GetFilPos(msh);\n      SetPos(msh, 0);\n\n      if(kwd->typ != InfKwd)\n      {\n         if(msh->ver < 4)\n         {\n            i = (int)kwd->NmbLin;\n            RecWrd(msh, (unsigned char *)&i);\n         }\n         else\n            RecDblWrd(msh, (unsigned char *)&kwd->NmbLin);\n      }\n\n      // In case of solution field, write the extended header at once\n      if(kwd->typ == SolKwd)\n      {\n         RecWrd(msh, (unsigned char *)&kwd->NmbTyp);\n\n         for(i=0;i<kwd->NmbTyp;i++)\n            RecWrd(msh, (unsigned char *)&kwd->TypTab[i]);\n\n         if(!strcmp(\"hr\", GmfKwdFmt[ KwdCod ][2]))\n         {\n            RecWrd(msh, (unsigned char *)&kwd->deg);\n            RecWrd(msh, (unsigned char *)&kwd->NmbNod);\n         }\n      }\n   }\n\n   // Reset write buffer position\n   msh->pos = 0;\n\n   // Compute the total file size and check if it crosses the 2GB threshold\n   msh->siz += kwd->NmbLin * kwd->NmbWrd * WrdSiz;\n\n   return(1);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Read a full line from the current kwd                                      */\n/*----------------------------------------------------------------------------*/\n\nint NAMF77(GmfGetLin, gmfgetlin)(TYPF77(int64_t)MshIdx, TYPF77(int)KwdCod, ...)\n{\n   int         i, err;\n   float       *FltSolTab, FltVal, *PtrFlt;\n   double      *DblSolTab, *PtrDbl;\n   va_list     VarArg;\n   GmfMshSct   *msh = (GmfMshSct *) VALF77(MshIdx);\n   KwdSct      *kwd = &msh->KwdTab[ VALF77(KwdCod) ];\n\n   if( (VALF77(KwdCod) < 1) || (VALF77(KwdCod) > GmfMaxKwd) )\n      return(0);\n\n   // Save the current stack environment for longjmp\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      return(0);\n   }\n\n   // Start decoding the arguments\n   va_start(VarArg, KwdCod);\n\n   switch(kwd->typ)\n   {\n      case InfKwd : case RegKwd : case CmtKwd :\n      {\n         if(msh->typ & Asc)\n         {\n            for(i=0;i<kwd->SolSiz;i++)\n            {\n               if(kwd->fmt[i] == 'r')\n               {\n                  if(msh->FltSiz == 32)\n                  {\n                     safe_fscanf(msh->hdl, \"%f\", &FltVal, msh->err);\n                     PtrDbl = va_arg(VarArg, double *);\n                     PtrFlt = (float *)PtrDbl;\n                     *PtrFlt = FltVal;\n                  }                     \n                  else\n                  {\n                     safe_fscanf(msh->hdl, \"%lf\",\n                              va_arg(VarArg, double *), msh->err);\n                  }\n               }\n               else if(kwd->fmt[i] == 'i')\n               {\n                  if(msh->ver <= 3)\n                  {\n                     safe_fscanf(msh->hdl, \"%d\",\n                        va_arg(VarArg, int *), msh->err);\n                  }\n                  else\n                  {\n                     // [Bruno] %ld -> INT64_T_FMT\n                     safe_fscanf(msh->hdl, INT64_T_FMT,\n                              va_arg(VarArg, int64_t *), msh->err);\n                  }\n               }\n               else if(kwd->fmt[i] == 'c')\n               {\n                  safe_fgets( va_arg(VarArg, char *),\n                              WrdSiz * FilStrSiz, msh->hdl, msh->err);\n               }\n            }\n         }\n         else\n         {\n            for(i=0;i<kwd->SolSiz;i++)\n               if(kwd->fmt[i] == 'r')\n                  if(msh->FltSiz == 32)\n                     ScaWrd(msh, (unsigned char *)va_arg(VarArg, float *));\n                  else\n                     ScaDblWrd(msh, (unsigned char *)va_arg(VarArg, double *));\n               else if(kwd->fmt[i] == 'i')\n                  if(msh->ver <= 3)\n                     ScaWrd(msh, (unsigned char *)va_arg(VarArg, int *));\n                  else\n                     ScaDblWrd(msh, (unsigned char *)va_arg(VarArg, int64_t *));\n               else if(kwd->fmt[i] == 'c')\n                  // [Bruno] added error control\n                  safe_fread(va_arg(VarArg, char *), WrdSiz, FilStrSiz, msh->hdl, msh->err);\n         }\n      }break;\n\n      case SolKwd :\n      {\n         if(msh->FltSiz == 32)\n         {\n            FltSolTab = va_arg(VarArg, float *);\n\n            if(msh->typ & Asc)\n               for(i=0; i<kwd->SolSiz; i++)\n                  safe_fscanf(msh->hdl, \"%f\", &FltSolTab[i], msh->err);\n            else\n               for(i=0; i<kwd->SolSiz; i++)\n                  ScaWrd(msh, (unsigned char *)&FltSolTab[i]);\n         }\n         else\n         {\n            DblSolTab = va_arg(VarArg, double *);\n\n            if(msh->typ & Asc)\n               for(i=0; i<kwd->SolSiz; i++)\n                  safe_fscanf(msh->hdl, \"%lf\", &DblSolTab[i], msh->err);\n            else\n               for(i=0; i<kwd->SolSiz; i++)\n                  ScaDblWrd(msh, (unsigned char *)&DblSolTab[i]);\n         }\n      }break;\n   }\n\n   va_end(VarArg);\n\n   return(1);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Write a full line from the current kwd                                     */\n/*----------------------------------------------------------------------------*/\n\nint NAMF77(GmfSetLin, gmfsetlin)(TYPF77(int64_t) MshIdx, TYPF77(int) KwdCod, ...)\n{\n   int         i, pos, *IntBuf, err;\n   int64_t     *LngBuf;\n   float       *FltSolTab, *FltBuf;\n   double      *DblSolTab, *DblBuf;\n   va_list     VarArg;\n   GmfMshSct   *msh = (GmfMshSct *) VALF77(MshIdx);\n   KwdSct      *kwd = &msh->KwdTab[ VALF77(KwdCod) ];\n\n   if( ( VALF77(KwdCod) < 1) || ( VALF77(KwdCod) > GmfMaxKwd) )\n      return(0);\n\n   // Save the current stack environment for longjmp\n   // This is needed in RecBlk()\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      return(0);\n   }\n\n   // Start decoding the arguments\n   va_start(VarArg, KwdCod);\n\n   if(kwd->typ != SolKwd)\n   {\n      if(msh->typ & Asc)\n      {\n         for(i=0;i<kwd->SolSiz;i++)\n         {\n            if(kwd->fmt[i] == 'r')\n            {\n               if(msh->FltSiz == 32)\n#ifdef F77API\n                  fprintf(msh->hdl, \"%.9g \", *(va_arg(VarArg, float *)));\n#else\n                  fprintf(msh->hdl, \"%.9g \", va_arg(VarArg, double));\n#endif\n               else\n                  fprintf(msh->hdl, \"%.17g \", VALF77(va_arg(VarArg, TYPF77(double))));\n            }\n            else if(kwd->fmt[i] == 'i')\n            {\n               if(msh->ver <= 3)\n                  fprintf(msh->hdl, \"%d \", VALF77(va_arg(VarArg, TYPF77(int))));\n               else\n               {\n                  // [Bruno] %ld -> INT64_T_FMT\n                  fprintf( msh->hdl, INT64_T_FMT \" \",\n                           VALF77(va_arg(VarArg, TYPF77(int64_t))));\n               }\n            }\n            else if(kwd->fmt[i] == 'c')\n               fprintf(msh->hdl, \"%s \", va_arg(VarArg, char *));\n         }\n      }\n      else\n      {\n         pos = 0;\n\n         for(i=0;i<kwd->SolSiz;i++)\n         {\n            if(kwd->fmt[i] == 'r')\n            {\n               if(msh->FltSiz == 32)\n               {\n                  FltBuf = (void *)&msh->buf[ pos ];\n#ifdef F77API\n                  *FltBuf = (float)*(va_arg(VarArg, float *));\n#else\n                  *FltBuf = (float)va_arg(VarArg, double);\n#endif\n                  pos += 4;\n               }\n               else\n               {\n                  DblBuf = (void *)&msh->buf[ pos ];\n                  *DblBuf = VALF77(va_arg(VarArg, TYPF77(double)));\n                  pos += 8;\n               }\n            }\n            else if(kwd->fmt[i] == 'i')\n            {\n               if(msh->ver <= 3)\n               {\n                  IntBuf = (void *)&msh->buf[ pos ];\n                  *IntBuf = VALF77(va_arg(VarArg, TYPF77(int)));\n                  pos += 4;\n               }\n               else\n               {\n                  LngBuf = (void *)&msh->buf[ pos ];\n                  *LngBuf = VALF77(va_arg(VarArg, TYPF77(int64_t)));\n                  pos += 8;\n               }\n            }\n            else if(kwd->fmt[i] == 'c')\n            {\n               memset(&msh->buf[ pos ], 0, FilStrSiz * WrdSiz);\n               strncpy(&msh->buf[ pos ], va_arg(VarArg, char *), FilStrSiz * WrdSiz);\n               pos += FilStrSiz;\n            }\n         }\n\n         RecBlk(msh, msh->buf, kwd->NmbWrd);\n      }\n   }\n   else\n   {\n      if(msh->FltSiz == 32)\n      {\n         FltSolTab = va_arg(VarArg, float *);\n\n         if(msh->typ & Asc)\n            for(i=0; i<kwd->SolSiz; i++)\n               fprintf(msh->hdl, \"%.9g \", (double)FltSolTab[i]);\n         else\n            RecBlk(msh, (unsigned char *)FltSolTab, kwd->NmbWrd);\n      }\n      else\n      {\n         DblSolTab = va_arg(VarArg, double *);\n\n         if(msh->typ & Asc)\n            for(i=0; i<kwd->SolSiz; i++)\n               fprintf(msh->hdl, \"%.17g \", DblSolTab[i]);\n         else\n            RecBlk(msh, (unsigned char *)DblSolTab, kwd->NmbWrd);\n      }\n   }\n\n   va_end(VarArg);\n\n   if(msh->typ & Asc)\n      fprintf(msh->hdl, \"\\n\");\n\n   return(1);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Private procedure for mesh : copy a whole line                             */\n/*----------------------------------------------------------------------------*/\n\n#ifdef TRANSMESH\n\nint GmfCpyLin(int64_t InpIdx, int64_t OutIdx, int KwdCod)\n{\n   char        s[ WrdSiz * FilStrSiz ];\n   double      d;\n   float       f;\n   int         i, a, err;\n   int64_t     l;\n   GmfMshSct   *InpMsh = (GmfMshSct *)InpIdx, *OutMsh = (GmfMshSct *)OutIdx;\n   KwdSct      *kwd = &InpMsh->KwdTab[ KwdCod ];\n\n   // Save the current stack environment for longjmp\n   if( (err = setjmp(InpMsh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", InpMsh, err);\n#endif\n      return(0);\n   }\n\n   for(i=0;i<kwd->SolSiz;i++)\n   {\n      if(kwd->fmt[i] == 'r')\n      {\n         if(InpMsh->FltSiz == 32)\n         {\n            if(InpMsh->typ & Asc)\n               safe_fscanf(InpMsh->hdl, \"%f\", &f, InpMsh->err);\n            else\n               ScaWrd(InpMsh, (unsigned char *)&f);\n\n            d = (double)f;\n         }\n         else\n         {\n            if(InpMsh->typ & Asc)\n               safe_fscanf(InpMsh->hdl, \"%lf\", &d, InpMsh->err);\n            else\n               ScaDblWrd(InpMsh, (unsigned char *)&d);\n\n            f = (float)d;\n         }\n\n         if(OutMsh->FltSiz == 32)\n            if(OutMsh->typ & Asc)\n               fprintf(OutMsh->hdl, \"%.9g \", (double)f);\n            else\n               RecWrd(OutMsh, (unsigned char *)&f);\n         else\n            if(OutMsh->typ & Asc)\n               fprintf(OutMsh->hdl, \"%.17g \", d);\n            else\n               RecDblWrd(OutMsh, (unsigned char *)&d);\n      }\n      else if(kwd->fmt[i] == 'i')\n      {\n         if(InpMsh->ver <= 3)\n         {\n            if(InpMsh->typ & Asc)\n               safe_fscanf(InpMsh->hdl, \"%d\", &a, InpMsh->err);\n            else\n               ScaWrd(InpMsh, (unsigned char *)&a);\n\n            l = (int64_t)a;\n         }\n         else\n         {\n            if(InpMsh->typ & Asc)\n               safe_fscanf(InpMsh->hdl, INT64_T_FMT, &l, InpMsh->err);\n            else\n               ScaDblWrd(InpMsh, (unsigned char *)&l);\n\n            a = (int)l;\n         }\n\n         if( (i == kwd->SolSiz-1) && (a > GmfMaxRefTab[ KwdCod ]) )\n            GmfMaxRefTab[ KwdCod ] = a;\n\n         if(OutMsh->ver <= 3)\n         {\n            if(OutMsh->typ & Asc)\n               fprintf(OutMsh->hdl, \"%d \", a);\n            else\n               RecWrd(OutMsh, (unsigned char *)&a);\n         }\n         else\n         {\n            if(OutMsh->typ & Asc)\n               fprintf(OutMsh->hdl, INT64_T_FMT\" \", l);\n            else\n               RecDblWrd(OutMsh, (unsigned char *)&l);\n         }\n      }\n      else if(kwd->fmt[i] == 'c')\n      {\n         memset(s, 0, FilStrSiz * WrdSiz);\n\n         if(InpMsh->typ & Asc)\n            safe_fgets(s, WrdSiz * FilStrSiz, InpMsh->hdl, InpMsh->err);\n         else\n#ifdef WITH_GMF_AIO\n            read(InpMsh->FilDes, s, WrdSiz * FilStrSiz);\n#else\n            safe_fread(s, WrdSiz, FilStrSiz, InpMsh->hdl, InpMsh->err);\n#endif\n         if(OutMsh->typ & Asc)\n            fprintf(OutMsh->hdl, \"%s \", s);\n         else\n#ifdef WITH_GMF_AIO\n            write(OutMsh->FilDes, s, WrdSiz * FilStrSiz);\n#else\n            fwrite(s, WrdSiz, FilStrSiz, OutMsh->hdl);\n#endif\n      }\n   }\n\n   if(OutMsh->typ & Asc)\n      fprintf(OutMsh->hdl, \"\\n\");\n\n   return(1);\n}\n\n#endif\n\n\n// [Bruno] Made asynchronous I/O optional\n#ifndef WITHOUT_AIO\n\n/*----------------------------------------------------------------------------*/\n/* Bufferized asynchronous reading of all keyword's lines                     */\n/*----------------------------------------------------------------------------*/\n\nint NAMF77(GmfGetBlock, gmfgetblock)(  TYPF77(int64_t) MshIdx,\n                                       TYPF77(int)     KwdCod,\n                                       TYPF77(int64_t) BegIdx,\n                                       TYPF77(int64_t) EndIdx,\n                                       TYPF77(int)     MapTyp,\n                                       void           *MapTab,\n                                       void           *prc, ... )\n{\n   char        *UsrDat[ GmfMaxTyp ], *UsrBas[ GmfMaxTyp ], *FilPos, *EndUsrDat;\n   char        *FilBuf = NULL, *FrtBuf = NULL, *BckBuf = NULL, *BegUsrDat;\n   char        *StrTab[5] = { \"\", \"%f\", \"%lf\", \"%d\", INT64_T_FMT };\n   char        **BegTab, **EndTab;\n   int         i, j, k, *FilPtrI32, *UsrPtrI32, FilTyp[ GmfMaxTyp ];\n   int         UsrTyp[ GmfMaxTyp ], TypSiz[5] = {0,4,8,4,8};\n   int         *IntMapTab = NULL, err, TotSiz = 0, IniFlg = 1, mod = GmfArgLst;\n   int         *TypTab, *SizTab, typ, VecCnt, ArgCnt = 0;\n   float       *FilPtrR32, *UsrPtrR32;\n   double      *FilPtrR64, *UsrPtrR64;\n   int64_t     BlkNmbLin, *FilPtrI64, *UsrPtrI64, BlkBegIdx, BlkEndIdx = 0;\n   int64_t     *LngMapTab = NULL, OldIdx = 0, UsrNmbLin, VecLen;\n   size_t      FilBegIdx = VALF77(BegIdx), FilEndIdx = VALF77(EndIdx);\n   void        (*UsrPrc)(int64_t, int64_t, void *) = NULL;\n   size_t      UsrLen[ GmfMaxTyp ], ret, LinSiz, b, NmbBlk;\n   va_list     VarArg;\n   GmfMshSct   *msh = (GmfMshSct *) VALF77(MshIdx);\n   KwdSct      *kwd = &msh->KwdTab[ VALF77(KwdCod) ];\n   struct      aiocb aio;\n#ifdef F77API\n   int         NmbArg = 0;\n   void        *ArgTab[ MaxArg ];\n#else\n   char        *UsrArg = NULL;\n#endif\n\n   // Save the current stack environment for longjmp\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(BckBuf)\n         free(BckBuf);\n\n      if(FrtBuf)\n         free(FrtBuf);\n\n      return(0);\n   }\n\n   // Check mesh and keyword\n   if( (VALF77(KwdCod) < 1) || (VALF77(KwdCod) > GmfMaxKwd) || !kwd->NmbLin )\n      return(0);\n\n   // Make sure it's not a simple information keyword\n   if( (kwd->typ != RegKwd) && (kwd->typ != SolKwd) )\n      return(0);\n\n   // Check user's bounds\n   if( (FilBegIdx < 1) || (FilBegIdx > FilEndIdx) || (FilEndIdx > (size_t)kwd->NmbLin) )\n      return(0);\n\n   // Compute the number of lines to be read\n   UsrNmbLin = FilEndIdx - FilBegIdx + 1;\n\n   // Get the renumbering map if any\n   if(VALF77(MapTyp) == GmfInt)\n      IntMapTab = (int *)MapTab;\n   else if(VALF77(MapTyp) == GmfLong)\n      LngMapTab = (int64_t *)MapTab;\n\n   // Start decoding the arguments\n   va_start(VarArg, prc);\n   LinSiz = 0;\n\n   // Get the user's preprocessing procedure and argument adresses, if any\n#ifdef F77API\n   if(prc)\n   {\n      UsrPrc = (void (*)(int64_t, int64_t, void *))prc;\n      NmbArg = *(va_arg(VarArg, int *));\n\n      for(i=0;i<NmbArg;i++)\n         ArgTab[i] = va_arg(VarArg, void *);\n   }\n#else\n   if(prc)\n   {\n      UsrPrc = (void (*)(int64_t, int64_t, void *))prc;\n      UsrArg = va_arg(VarArg, void *);\n   }\n#endif\n\n   if( (kwd->typ != RegKwd) && (kwd->typ != SolKwd) )\n      return(0);\n\n   // Read the first data type to select between list and table mode\n   typ = VALF77(va_arg(VarArg, TYPF77(int)));\n\n   // If the table mode is selected, read the four additional tables\n   // containing the arguments: type, vector size, begin and end pointers\n   if(typ == GmfArgTab)\n   {\n      mod = GmfArgTab;\n      TypTab = va_arg(VarArg, int *);\n      SizTab = va_arg(VarArg, int *);\n      BegTab = va_arg(VarArg, char **);\n      EndTab = va_arg(VarArg, char **);\n   }\n\n   // Read the arguments until to total size reaches the keyword's size\n   while(TotSiz < kwd->SolSiz)\n   {\n      // In list mode all arguments are read from the variable argument buffer\n      if(mod == GmfArgLst)\n      {\n         // Do not read the type argument for the first iteration because\n         // it was read befeore the loop begins to get the argument mode\n         if(IniFlg)\n            IniFlg = 0;\n         else\n            typ = VALF77(va_arg(VarArg, TYPF77(int)));\n\n         // In case the type is a vector. get its size and change the type\n         // for the corresponding scalar type\n         if(typ >= GmfFloatVec && typ <= GmfLongVec)\n         {\n            typ -= 4;\n            VecCnt = VALF77(va_arg(VarArg, TYPF77(int)));\n         }\n         else\n            VecCnt = 1;\n\n         BegUsrDat = va_arg(VarArg, char *);\n         EndUsrDat = va_arg(VarArg, char *);\n      }\n      else\n      {\n         // Do exactly the same as above but the arguments are read from\n         // the tables instead of VarArgs\n         typ = TypTab[ ArgCnt ];\n\n         if(typ >= GmfFloatVec && typ <= GmfLongVec)\n         {\n            typ -= 4;\n            VecCnt = SizTab[ ArgCnt ];\n         }\n         else\n            VecCnt = 1;\n\n         BegUsrDat = (char *)BegTab[ ArgCnt ];\n         EndUsrDat = (char *)EndTab[ ArgCnt ];\n         ArgCnt++;\n      }\n\n      if(UsrNmbLin > 1)\n         VecLen = (size_t)(EndUsrDat - BegUsrDat) / (UsrNmbLin - 1);\n      else\n         VecLen = 0;\n\n      // Compute the consecutive begin / end adresses for vector data types\n      for(i=0;i<VecCnt;i++)\n      {\n         UsrTyp[ TotSiz ]  = typ;\n         UsrBas[ TotSiz ]  = BegUsrDat + i * TypSiz[ typ ];\n         UsrDat[ TotSiz ]  = UsrBas[ TotSiz ];\n         UsrLen[ TotSiz ]  = VecLen;\n         TotSiz++;\n      }\n   }\n\n   // Get the file's data type\n   for(i=0;i<kwd->SolSiz;i++)\n   {\n      if(kwd->fmt[i] == 'r')\n         if(msh->FltSiz == 32)\n            FilTyp[i] = GmfFloat;\n         else\n            FilTyp[i] = GmfDouble;\n      else\n         if(msh->ver <= 3)\n            FilTyp[i] = GmfInt;\n         else\n            FilTyp[i] = GmfLong;\n\n      // Compute the file stride\n      LinSiz += TypSiz[ FilTyp[i] ];\n   }\n\n   va_end(VarArg);\n\n   // Move file pointer to the keyword data\n   SetFilPos(msh, kwd->pos);\n\n   // Read the whole kwd data\n   if(msh->typ & Asc)\n   {\n      OldIdx = 1;\n\n      for(i=1;i<=FilEndIdx;i++)\n      {\n         for(j=0;j<kwd->SolSiz;j++)\n         {\n            // Reorder HO nodes on the fly\n            if(kwd->OrdTab && (j != kwd->SolSiz-1))\n               k = kwd->OrdTab[j];\n            else\n               k = j;\n\n            // Move to the next user's data line only when the desired\n            // begining position in the ascii file has been reached since\n            // we cannot move directly to an arbitrary position\n            if(IntMapTab)\n               UsrDat[j] = UsrBas[k] + (IntMapTab[ OldIdx ] - 1) * UsrLen[k];\n            else if(LngMapTab)\n               UsrDat[j] = UsrBas[k] + (LngMapTab[ OldIdx ] - 1) * UsrLen[k];\n            else\n               UsrDat[j] = UsrBas[k] + (OldIdx - 1) * UsrLen[k];\n\n            safe_fscanf(msh->hdl, StrTab[ UsrTyp[j] ], UsrDat[j], msh->err);\n         }\n\n         if(i >= FilBegIdx)\n            OldIdx++;\n\n         // Call the user's preprocessing procedure\n         if(UsrPrc)\n#ifdef F77API\n            CalF77Prc(1, kwd->NmbLin, UsrPrc, NmbArg, ArgTab);\n#else\n            UsrPrc(1, kwd->NmbLin, UsrArg);\n#endif\n      }\n   }\n   else\n   {\n      // Allocate both front and back buffers\n      if(!(BckBuf = malloc(BufSiz * LinSiz)))\n         return(0);\n\n      if(!(FrtBuf = malloc(BufSiz * LinSiz)))\n         return(0);\n\n      // Setup the ansynchonous parameters\n      memset(&aio, 0, sizeof(struct aiocb));\n      FilBuf = BckBuf;\n      aio.aio_buf = BckBuf;\n#ifdef WITH_GMF_AIO\n      aio.aio_fildes = msh->FilDes;\n#else\n      aio.aio_fildes = msh->hdl;\n#endif\n      aio.aio_offset = (off_t)(GetFilPos(msh) + (FilBegIdx-1) * LinSiz);\n\n      NmbBlk = UsrNmbLin / BufSiz;\n\n      // Loop over N+1 blocks\n      for(b=0;b<=NmbBlk+1;b++)\n      {\n         // Wait for the previous block read to complete except\n         // for the first loop interation\n         if(b)\n         {\n            while(my_aio_error(&aio) == EINPROGRESS);\n\n            err = my_aio_error(&aio);\n            ret = my_aio_return(&aio);\n\n            if (err != 0) {\n              printf (\" Error at aio_error() : %s\\n\", strerror (err));\n              exit(1);\n            }\n\n            if (ret != aio.aio_nbytes) {\n              printf(\" Error at aio_return()\\n\");\n              exit(1);\n            }\n\n            // Increment the reading position\n            aio.aio_offset += (off_t)aio.aio_nbytes;\n\n            // and swap the buffers\n            if(aio.aio_buf == BckBuf)\n            {\n               aio.aio_buf = FrtBuf;\n               FilBuf = BckBuf;\n            }\n            else\n            {\n               aio.aio_buf = BckBuf;\n               FilBuf = FrtBuf;\n            }\n         }\n \n         // Read a chunk of data except for the last loop interarion\n         if(b <= NmbBlk)\n         {\n            // The last block is shorter than the others\n            if(b == NmbBlk)\n               BlkNmbLin = UsrNmbLin - b * BufSiz;\n            else\n               BlkNmbLin = BufSiz;\n\n            aio.aio_nbytes = BlkNmbLin * LinSiz;\n\n            if(my_aio_read(&aio) == -1)\n            {\n               printf(\"block      = %zd / %zd\\n\", b+1, NmbBlk+1);\n               printf(\"size       = \"INT64_T_FMT\" lines\\n\", BlkNmbLin);\n#ifdef WITH_GMF_AIO\n               printf(\"aio_fildes = %d\\n\",aio.aio_fildes);\n#else\n               printf(\"aio_fildes = %p\\n\",aio.aio_fildes);\n#endif\n               printf(\"aio_buf    = %p\\n\",aio.aio_buf);\n               printf(\"aio_offset = \" INT64_T_FMT \"\\n\",(int64_t)aio.aio_offset);\n               printf(\"aio_nbytes = \" INT64_T_FMT \"\\n\",(int64_t)aio.aio_nbytes);\n               printf(\"errno      = %d\\n\",errno);\n               exit(1);\n            }\n         }\n\n         // Then decode the block and store it in the user's data structure\n         // except for the first loop interation\n         if(b)\n         {\n            // The last block is shorter than the others\n            if(b-1 == NmbBlk)\n               BlkNmbLin = UsrNmbLin - (b-1) * BufSiz;\n            else\n               BlkNmbLin = BufSiz;\n\n            BlkBegIdx = BlkEndIdx+1;\n            BlkEndIdx += BlkNmbLin;\n            FilPos = FilBuf;\n\n            for(i=0;i<BlkNmbLin;i++)\n            {\n               OldIdx++;\n\n               for(j=0;j<kwd->SolSiz;j++)\n               {\n                  if(msh->cod != 1)\n                     SwpWrd(FilPos, TypSiz[ FilTyp[j] ]);\n\n                  // Reorder HO nodes on the fly\n                  if(kwd->OrdTab && (j != kwd->SolSiz-1))\n                     k = kwd->OrdTab[j];\n                  else\n                     k = j;\n\n                  if(IntMapTab)\n                     UsrDat[j] = UsrBas[k] + (IntMapTab[ OldIdx ] - 1) * UsrLen[k];\n                  else if(LngMapTab)\n                     UsrDat[j] = UsrBas[k] + (LngMapTab[ OldIdx ] - 1) * UsrLen[k];\n                  else\n                     UsrDat[j] = UsrBas[k] + (OldIdx - 1) * UsrLen[k];\n\n                  if(FilTyp[j] == GmfInt)\n                  {\n                     FilPtrI32 = (int *)FilPos;\n\n                     if(UsrTyp[j] == GmfInt)\n                     {\n                        UsrPtrI32 = (int *)UsrDat[j];\n                        *UsrPtrI32 = *FilPtrI32;\n                     }\n                     else\n                     {\n                        UsrPtrI64 = (int64_t *)UsrDat[j];\n                        *UsrPtrI64 = (int64_t)*FilPtrI32;\n                     }\n                  }\n                  else if(FilTyp[j] == GmfLong)\n                  {\n                     FilPtrI64 = (int64_t *)FilPos;\n\n                     if(UsrTyp[j] == GmfLong)\n                     {\n                        UsrPtrI64 = (int64_t *)UsrDat[j];\n                        *UsrPtrI64 = *FilPtrI64;\n                     }\n                     else\n                     {\n                        UsrPtrI32 = (int *)UsrDat[j];\n                        *UsrPtrI32 = (int)*FilPtrI64;\n                     }\n                  }\n                  else if(FilTyp[j] == GmfFloat)\n                  {\n                     FilPtrR32 = (float *)FilPos;\n\n                     if(UsrTyp[j] == GmfFloat)\n                     {\n                        UsrPtrR32 = (float *)UsrDat[j];\n                        *UsrPtrR32 = *FilPtrR32;\n                     }\n                     else\n                     {\n                        UsrPtrR64 = (double *)UsrDat[j];\n                        *UsrPtrR64 = (double)*FilPtrR32;\n                     }\n                  }\n                  else if(FilTyp[j] == GmfDouble)\n                  {\n                     FilPtrR64 = (double *)FilPos;\n\n                     if(UsrTyp[j] == GmfDouble)\n                     {\n                        UsrPtrR64 = (double *)UsrDat[j];\n                        *UsrPtrR64 = *FilPtrR64;\n                     }\n                     else\n                     {\n                        UsrPtrR32 = (float *)UsrDat[j];\n                        *UsrPtrR32 = (float)*FilPtrR64;\n                     }\n                  }\n\n                  FilPos += TypSiz[ FilTyp[j] ];\n               }\n            }\n\n            // Call the user's preprocessing procedure\n            if(UsrPrc)\n#ifdef F77API\n               CalF77Prc(BlkBegIdx, BlkEndIdx, UsrPrc, NmbArg, ArgTab);\n#else\n               UsrPrc(BlkBegIdx, BlkEndIdx, UsrArg);\n#endif\n         }\n      }\n\n      free(BckBuf);\n      free(FrtBuf);\n   }\n\n   return(1);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Bufferized writing of all keyword's lines                                  */\n/*----------------------------------------------------------------------------*/\n\nint NAMF77(GmfSetBlock, gmfsetblock)(  TYPF77(int64_t) MshIdx,\n                                       TYPF77(int)     KwdCod,\n                                       TYPF77(int64_t) BegIdx,\n                                       TYPF77(int64_t) EndIdx,\n                                       TYPF77(int)     MapTyp,\n                                       void           *MapTab,\n                                       void           *prc, ... )\n{\n   char        *UsrDat[ GmfMaxTyp ], *UsrBas[ GmfMaxTyp ];\n   char        *StrTab[5] = { \"\", \"%.9g\", \"%.17g\", \"%d\", \"%lld\" }, *FilPos;\n   char        *FilBuf = NULL, *FrtBuf = NULL, *BckBuf = NULL;\n   char        **BegTab, **EndTab, *BegUsrDat, *EndUsrDat;\n   int         i, j, *FilPtrI32, *UsrPtrI32, FilTyp[ GmfMaxTyp ];\n   int         UsrTyp[ GmfMaxTyp ], TypSiz[5] = {0,4,8,4,8};\n   int         err, *IntMapTab = NULL, typ, mod = GmfArgLst;\n   int         *TypTab, *SizTab, IniFlg = 1, TotSiz = 0, VecCnt, ArgCnt = 0;\n   float       *FilPtrR32, *UsrPtrR32;\n   double      *FilPtrR64, *UsrPtrR64;\n   int64_t     UsrNmbLin, BlkNmbLin = 0, BlkBegIdx, BlkEndIdx = 0;\n   int64_t     *FilPtrI64, *UsrPtrI64, *LngMapTab = NULL, OldIdx = 0;\n   size_t      FilBegIdx = VALF77(BegIdx), FilEndIdx = VALF77(EndIdx);\n   void        (*UsrPrc)(int64_t, int64_t, void *) = NULL;\n   size_t      UsrLen[ GmfMaxTyp ], ret, LinSiz, VecLen, s, b, NmbBlk;\n   va_list     VarArg;\n   GmfMshSct   *msh = (GmfMshSct *) VALF77(MshIdx);\n   KwdSct      *kwd = &msh->KwdTab[ VALF77(KwdCod) ];\n   struct      aiocb aio;\n#ifdef F77API\n   int         NmbArg = 0;\n   void        *ArgTab[ MaxArg ];\n#else\n   char        *UsrArg = NULL;\n#endif\n\n   // Save the current stack environment for longjmp\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(FilBuf)\n         free(FilBuf);\n\n      return(0);\n   }\n\n   // Check mesh and keyword\n   if( (VALF77(KwdCod) < 1) || (VALF77(KwdCod) > GmfMaxKwd) || !kwd->NmbLin )\n      return(0);\n\n   // Make sure it's not a simple information keyword\n   if( (kwd->typ != RegKwd) && (kwd->typ != SolKwd) )\n      return(0);\n\n   // Temporarily overwright the given begin and end values\n   // as arbitrary position block write is not yet implemented\n   FilBegIdx = 1;\n   FilEndIdx = kwd->NmbLin;\n\n   // Check user's bounds\n   if( (FilBegIdx < 1) || (FilBegIdx > FilEndIdx) || (FilEndIdx > (size_t)kwd->NmbLin) )\n      return(0);\n\n   // Compute the number of lines to be written\n   UsrNmbLin = FilEndIdx - FilBegIdx + 1;\n\n   // Get the renumbering map if any\n   if(VALF77(MapTyp) == GmfInt)\n      IntMapTab = (int *)MapTab;\n   else if(VALF77(MapTyp) == GmfLong)\n      LngMapTab = (int64_t *)MapTab;\n\n   // Start decoding the arguments\n   va_start(VarArg, prc);\n   LinSiz = 0;\n\n   // Get the user's postprocessing procedure and argument adresses, if any\n#ifdef F77API\n   if(prc)\n   {\n      UsrPrc = (void (*)(int64_t, int64_t, void *))prc;\n      NmbArg = *(va_arg(VarArg, int *));\n\n      for(i=0;i<NmbArg;i++)\n         ArgTab[i] = va_arg(VarArg, void *);\n   }\n#else\n   if(prc)\n   {\n      UsrPrc = (void (*)(int64_t, int64_t, void *))prc;\n      UsrArg = va_arg(VarArg, void *);\n   }\n#endif\n\n   if( (kwd->typ != RegKwd) && (kwd->typ != SolKwd) )\n      return(0);\n\n   // Read the first data type to select between list and table mode\n   typ = VALF77(va_arg(VarArg, TYPF77(int)));\n\n   // If the table mode is selected, read the four additional tables\n   // containing the arguments: type, vector size, begin and end pointers\n   if(typ == GmfArgTab)\n   {\n      mod = GmfArgTab;\n      TypTab = va_arg(VarArg, int *);\n      SizTab = va_arg(VarArg, int *);\n      BegTab = va_arg(VarArg, char **);\n      EndTab = va_arg(VarArg, char **);\n   }\n\n   // Read the arguments until to total size reaches the keyword's size\n   while(TotSiz < kwd->SolSiz)\n   {\n      // In list mode all arguments are read from the variable argument buffer\n      if(mod == GmfArgLst)\n      {\n         // Do not read the type argument for the first iteration because\n         // it was read befeore the loop begins to get the argument mode\n         if(IniFlg)\n            IniFlg = 0;\n         else\n            typ = VALF77(va_arg(VarArg, TYPF77(int)));\n\n         // In case the type is a vector. get its size and change the type\n         // for the corresponding scalar type\n         if(typ >= GmfFloatVec && typ <= GmfLongVec)\n         {\n            typ -= 4;\n            VecCnt = VALF77(va_arg(VarArg, TYPF77(int)));\n         }\n         else\n            VecCnt = 1;\n\n         BegUsrDat = va_arg(VarArg, char *);\n         EndUsrDat = va_arg(VarArg, char *);\n      }\n      else\n      {\n         // Do exactly the same as above but the arguments are read from\n         // the tables instead of VarArgs\n         typ = TypTab[ ArgCnt ];\n\n         if(typ >= GmfFloatVec && typ <= GmfLongVec)\n         {\n            typ -= 4;\n            VecCnt = SizTab[ ArgCnt ];\n         }\n         else\n            VecCnt = 1;\n\n         BegUsrDat = (char *)BegTab[ ArgCnt ];\n         EndUsrDat = (char *)EndTab[ ArgCnt ];\n         ArgCnt++;\n      }\n\n      if(UsrNmbLin > 1)\n         VecLen = (size_t)(EndUsrDat - BegUsrDat) / (UsrNmbLin - 1);\n      else\n         VecLen = 0;\n\n      // Compute the consecutive begin / end adresses for vector data types\n      for(i=0;i<VecCnt;i++)\n      {\n         UsrTyp[ TotSiz ]  = typ;\n         UsrBas[ TotSiz ]  = BegUsrDat + i * TypSiz[ typ ];\n         UsrDat[ TotSiz ]  = UsrBas[ TotSiz ];\n         UsrLen[ TotSiz ]  = VecLen;\n         TotSiz++;\n      }\n   }\n\n   // Get the file's data type\n   for(i=0;i<kwd->SolSiz;i++)\n   {\n      if(kwd->fmt[i] == 'r')\n         if(msh->FltSiz == 32)\n            FilTyp[i] = GmfFloat;\n         else\n            FilTyp[i] = GmfDouble;\n      else\n         if(msh->ver <= 3)\n            FilTyp[i] = GmfInt;\n         else\n            FilTyp[i] = GmfLong;\n\n      // Compute the file stride\n      LinSiz += TypSiz[ FilTyp[i] ];\n   }\n\n   va_end(VarArg);\n\n   // Write the whole kwd data\n   if(msh->typ & Asc)\n   {\n      if(UsrPrc)\n#ifdef F77API\n         CalF77Prc(1, kwd->NmbLin, UsrPrc, NmbArg, ArgTab);\n#else\n         UsrPrc(1, kwd->NmbLin, UsrArg);\n#endif\n\n      for(s=FilBegIdx; s<=FilEndIdx; s++)\n         for(j=0;j<kwd->SolSiz;j++)\n         {\n            if(UsrTyp[j] == GmfFloat)\n            {\n               UsrPtrR32 = (float *)UsrDat[j];\n               fprintf(msh->hdl, StrTab[ UsrTyp[j] ], (double)*UsrPtrR32);\n            }\n            else if(UsrTyp[j] == GmfDouble)\n            {\n               UsrPtrR64 = (double *)UsrDat[j];\n               fprintf(msh->hdl, StrTab[ UsrTyp[j] ], *UsrPtrR64);\n            }\n            else if(UsrTyp[j] == GmfInt)\n            {\n               UsrPtrI32 = (int *)UsrDat[j];\n               fprintf(msh->hdl, StrTab[ UsrTyp[j] ], *UsrPtrI32);\n            }\n            else if(UsrTyp[j] == GmfLong)\n            {\n               UsrPtrI64 = (int64_t *)UsrDat[j];\n               fprintf(msh->hdl, StrTab[ UsrTyp[j] ], *UsrPtrI64);\n            }\n\n            if(j < kwd->SolSiz -1)\n               fprintf(msh->hdl, \" \");\n            else\n               fprintf(msh->hdl, \"\\n\");\n\n            //UsrDat[j] += UsrLen[j];\n            if(IntMapTab)\n               UsrDat[j] = UsrBas[j] + IntMapTab[s] * UsrLen[j];\n            else if(LngMapTab)\n               UsrDat[j] = UsrBas[j] + LngMapTab[s] * UsrLen[j];\n            else\n               UsrDat[j] = UsrBas[j] + s * UsrLen[j];\n         }\n   }\n   else\n   {\n      // Allocate the front and back buffers\n      if(!(BckBuf = malloc(BufSiz * LinSiz)))\n         return(0);\n\n      if(!(FrtBuf = malloc(BufSiz * LinSiz)))\n         return(0);\n\n      // Setup the asynchronous parameters\n      memset(&aio, 0, sizeof(struct aiocb));\n      FilBuf = BckBuf;\n#ifdef WITH_GMF_AIO\n      aio.aio_fildes = msh->FilDes;\n#else\n      aio.aio_fildes = msh->hdl;\n#endif\n      aio.aio_offset = (off_t)GetFilPos(msh);\n\n      NmbBlk = UsrNmbLin / BufSiz;\n\n      // Loop over N+1 blocks\n      for(b=0;b<=NmbBlk+1;b++)\n      {\n         // Launch an asynchronous block write\n         // except for the first loop iteration\n         if(b)\n         {\n            aio.aio_nbytes = BlkNmbLin * LinSiz;\n            \n            if(my_aio_write(&aio) == -1)\n            {\n#ifdef WITH_GMF_AIO\n               printf(\"aio_fildes = %d\\n\",aio.aio_fildes);\n#else\n               printf(\"aio_fildes = %p\\n\",aio.aio_fildes);\n#endif\n               printf(\"aio_buf    = %p\\n\",aio.aio_buf);\n               printf(\"aio_offset = \" INT64_T_FMT \"\\n\",(int64_t)aio.aio_offset);\n               printf(\"aio_nbytes = \" INT64_T_FMT \"\\n\",(int64_t)aio.aio_nbytes);\n               printf(\"errno      = %d\\n\",errno);\n               exit(1);\n            }\n         }\n\n         // Parse the block data except at the last loop iteration\n         if(b<=NmbBlk)\n         {\n            // The last block is shorter\n            if(b == NmbBlk)\n               BlkNmbLin = UsrNmbLin - b * BufSiz;\n            else\n               BlkNmbLin = BufSiz;\n\n            FilPos = FilBuf;\n            BlkBegIdx = BlkEndIdx+1;\n            BlkEndIdx += BlkNmbLin;\n\n            // Call user's preprocessing first\n            if(UsrPrc)\n#ifdef F77API\n               CalF77Prc(BlkBegIdx, BlkEndIdx, UsrPrc, NmbArg, ArgTab);\n#else\n               UsrPrc(BlkBegIdx, BlkEndIdx, UsrArg);\n#endif\n\n            // Then copy it's data to the file buffer\n            for(i=0;i<BlkNmbLin;i++)\n            {\n               OldIdx++;\n\n               for(j=0;j<kwd->SolSiz;j++)\n               {\n                  if(IntMapTab)\n                     UsrDat[j] = UsrBas[j] + (IntMapTab[ OldIdx ] - 1) * UsrLen[j];\n                  else if(LngMapTab)\n                     UsrDat[j] = UsrBas[j] + (LngMapTab[ OldIdx ] - 1) * UsrLen[j];\n                  else\n                     UsrDat[j] = UsrBas[j] + (OldIdx - 1) * UsrLen[j];\n\n                  if(FilTyp[j] == GmfInt)\n                  {\n                     FilPtrI32 = (int *)FilPos;\n\n                     if(UsrTyp[j] == GmfInt)\n                     {\n                        UsrPtrI32 = (int *)UsrDat[j];\n                        *FilPtrI32 = *UsrPtrI32;\n                     }\n                     else\n                     {\n                        UsrPtrI64 = (int64_t *)UsrDat[j];\n                        *FilPtrI32 = (int)*UsrPtrI64;\n                     }\n                  }\n                  else if(FilTyp[j] == GmfLong)\n                  {\n                     FilPtrI64 = (int64_t *)FilPos;\n\n                     if(UsrTyp[j] == GmfLong)\n                     {\n                        UsrPtrI64 = (int64_t *)UsrDat[j];\n                        *FilPtrI64 = *UsrPtrI64;\n                     }\n                     else\n                     {\n                        UsrPtrI32 = (int *)UsrDat[j];\n                        *FilPtrI64 = (int64_t)*UsrPtrI32;\n                     }\n                  }\n                  else if(FilTyp[j] == GmfFloat)\n                  {\n                     FilPtrR32 = (float *)FilPos;\n\n                     if(UsrTyp[j] == GmfFloat)\n                     {\n                        UsrPtrR32 = (float *)UsrDat[j];\n                        *FilPtrR32 = *UsrPtrR32;\n                     }\n                     else\n                     {\n                        UsrPtrR64 = (double *)UsrDat[j];\n                        *FilPtrR32 = (float)*UsrPtrR64;\n                     }\n                  }\n                  else if(FilTyp[j] == GmfDouble)\n                  {\n                     FilPtrR64 = (double *)FilPos;\n\n                     if(UsrTyp[j] == GmfDouble)\n                     {\n                        UsrPtrR64 = (double *)UsrDat[j];\n                        *FilPtrR64 = *UsrPtrR64;\n                     }\n                     else\n                     {\n                        UsrPtrR32 = (float *)UsrDat[j];\n                        *FilPtrR64 = (double)*UsrPtrR32;\n                     }\n                  }\n\n                  FilPos += TypSiz[ FilTyp[j] ];\n               }\n            }\n         }\n\n         // Wait for write completion execpt at the first loop iteration\n         if(b)\n         {\n            while(my_aio_error(&aio) == EINPROGRESS);\n\n            err = my_aio_error(&aio);\n            ret = my_aio_return(&aio);\n\n            if (err != 0) {\n              printf (\" Error at aio_error() : %s\\n\", strerror (err));\n              exit(1);\n            }\n\n            if (ret != aio.aio_nbytes) {\n              printf(\" Error at aio_return()\\n\");\n              exit(1);\n            }\n\n            // Move the write position\n            aio.aio_offset += (off_t)aio.aio_nbytes;\n         }\n\n         // Swap the buffers\n         if(FilBuf == BckBuf)\n         {\n            aio.aio_buf = BckBuf;\n            FilBuf = FrtBuf;\n         }\n         else\n         {\n            aio.aio_buf = FrtBuf;\n            FilBuf = BckBuf;\n         }\n      }\n\n      SetFilPos(msh, aio.aio_offset);\n      free(BckBuf);\n      free(FrtBuf);\n   }\n\n   return(1);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Map two HO element's nodes numbering orders                                */\n/*----------------------------------------------------------------------------*/\n\nint GmfSetHONodesOrdering(int64_t MshIdx, int KwdCod, int *BasTab, int *OrdTab)\n{\n   int i, j, k, flg, NmbNod, NmbCrd;\n   GmfMshSct   *msh = (GmfMshSct *)MshIdx;\n   KwdSct      *kwd;\n   \n   // printf(\"\\n\\tGmfSetHONodesOrdering 0\\n\");\n\n   if( (KwdCod < 1) || (KwdCod > GmfMaxKwd) )\n      return(0);\n\n   kwd = &msh->KwdTab[ KwdCod ];\n\n   // Find the Bezier indices dimension according to the element's kind\n   switch(KwdCod)\n   {\n      case GmfEdges   :          NmbNod =  2; NmbCrd = 1; break;\n      case GmfEdgesP2 :          NmbNod =  3; NmbCrd = 1; break;\n      case GmfEdgesP3 :          NmbNod =  4; NmbCrd = 1; break;\n      case GmfEdgesP4 :          NmbNod =  5; NmbCrd = 1; break;\n      case GmfTriangles   :      NmbNod =  3; NmbCrd = 3; break;\n      case GmfTrianglesP2 :      NmbNod =  6; NmbCrd = 3; break;\n      case GmfTrianglesP3 :      NmbNod = 10; NmbCrd = 3; break;\n      case GmfTrianglesP4 :      NmbNod = 15; NmbCrd = 3; break;\n      case GmfQuadrilaterals   : NmbNod =  4; NmbCrd = 2; break;\n      case GmfQuadrilateralsQ2 : NmbNod =  9; NmbCrd = 2; break;\n      case GmfQuadrilateralsQ3 : NmbNod = 16; NmbCrd = 2; break;\n      case GmfQuadrilateralsQ4 : NmbNod = 25; NmbCrd = 2; break;\n      case GmfTetrahedra   :     NmbNod =  4; NmbCrd = 4; break;\n      case GmfTetrahedraP2 :     NmbNod = 10; NmbCrd = 4; break;\n      case GmfTetrahedraP3 :     NmbNod = 20; NmbCrd = 4; break;\n      case GmfTetrahedraP4 :     NmbNod = 35; NmbCrd = 4; break;\n      case GmfPyramids   :       NmbNod =  5; NmbCrd = 3; break;\n      case GmfPyramidsP2 :       NmbNod = 14; NmbCrd = 3; break;\n      case GmfPyramidsP3 :       NmbNod = 30; NmbCrd = 3; break;\n      case GmfPyramidsP4 :       NmbNod = 55; NmbCrd = 3; break;\n      case GmfPrisms   :         NmbNod =  6; NmbCrd = 4; break;\n      case GmfPrismsP2 :         NmbNod = 18; NmbCrd = 4; break;\n      case GmfPrismsP3 :         NmbNod = 40; NmbCrd = 4; break;\n      case GmfPrismsP4 :         NmbNod = 75; NmbCrd = 4; break;\n      case GmfHexahedra   :      NmbNod =  8; NmbCrd = 3; break;\n      case GmfHexahedraQ2 :      NmbNod = 27; NmbCrd = 3; break;\n      case GmfHexahedraQ3 :      NmbNod = 64; NmbCrd = 3; break;\n      case GmfHexahedraQ4 :      NmbNod =125; NmbCrd = 3; break;\n      default : return(0);\n   }\n\n   // Free and rebuild the mapping table if there were already one\n   if(kwd->OrdTab)\n      free(kwd->OrdTab);\n\n   if(!(kwd->OrdTab = malloc(NmbNod * sizeof(int))))\n      return(0);\n\n   // Find the corresponding Bezier coordinates from the source table\n   for(i=0;i<NmbNod;i++)\n   {\n      for(j=0;j<NmbNod;j++)\n      {\n         flg = 1;\n\n         for(k=0;k<NmbCrd;k++)\n            if(BasTab[ i * NmbCrd + k ] != OrdTab[ j * NmbCrd + k ])\n            {\n               flg = 0;\n               break;\n            }\n\n         if(flg)\n            kwd->OrdTab[j] = i;\n      }\n   }\n\n   // Check the ordering consistency\n   for(i=0;i<NmbNod;i++)\n   {\n      flg = 0;\n\n      for(j=0;j<NmbNod;j++)\n         if(kwd->OrdTab[j] == i)\n         {\n            flg = 1;\n            break;\n         }\n\n      if(!flg)\n      {\n         for(j=0;j<NmbNod;j++)\n            kwd->OrdTab[j] = j;\n\n         return(0);\n      }\n   }\n\n   return(1);\n}\n\n#endif\n\n\n#ifndef F77API\n\n\n/*----------------------------------------------------------------------------*/\n/* Read an EGADS binary CAD and return the byte flow and its exact byte size  */\n/*----------------------------------------------------------------------------*/\n\nchar *GmfReadByteFlow(int64_t MshIdx, int *NmbByt)\n{\n   int         cod, *WrdTab;\n   size_t      i, NmbWrd;\n   GmfMshSct   *msh = (GmfMshSct *)MshIdx;\n\n   // Read and allocate the number of 4-byte words in the byteflow\n   if(!(NmbWrd = GmfStatKwd(MshIdx, GmfByteFlow)))\n      return(NULL);\n\n   if(!(WrdTab = malloc(NmbWrd * WrdSiz)))\n      return(NULL);\n\n   // Disable the endianess conversion\n   cod = msh->cod;\n   msh->cod = 1;\n\n   // Read the exact number of bytes in the byteflow\n   GmfGotoKwd(MshIdx, GmfByteFlow);\n   GmfGetLin(MshIdx, GmfByteFlow, NmbByt);\n\n   // Read the byteflow as 4-byte blocks\n   for(i=0;i<NmbWrd;i++)\n      GmfGetLin(MshIdx, GmfByteFlow, &WrdTab[i]);\n\n   // Enable endianess convertion\n   msh->cod = cod;\n\n   return((char *)WrdTab);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Write an EGADS binary CAD as an integer table whose first entry is the size*/\n/*----------------------------------------------------------------------------*/\n\nint GmfWriteByteFlow(int64_t MshIdx, char *BytTab, int NmbByt)\n{\n   int i, PadWrd = 0, *WrdTab = (int *)BytTab, NmbWrd = NmbByt / WrdSiz;\n\n   // Add an extra padding word at the end if needed\n   if(NmbByt > NmbWrd * 4)\n      PadWrd = 1;\n\n   // Create the keyword with the number of words, not bytes\n   if(!GmfSetKwd(MshIdx, GmfByteFlow, NmbWrd + PadWrd))\n      return(0);\n\n   // Reacord the exact number of bytes\n   GmfSetLin(MshIdx, GmfByteFlow, NmbByt);\n\n   // Write the byteflow as 4-byte words, missing up to 3 endding bytes\n   for(i=0;i<NmbWrd;i++)\n      GmfSetLin(MshIdx, GmfByteFlow, WrdTab[i]);\n\n   // Write the extra 1,2 or 3 ending bytes\n   if(PadWrd)\n   {\n      PadWrd = 0;\n\n      // Copy the last bytes in an integer\n      for(i=0; i<NmbByt - NmbWrd * 4; i++)\n         PadWrd |= BytTab[ NmbWrd * 4 + i ] << (i*8);\n\n      // And write it as the last line\n      GmfSetLin(MshIdx, GmfByteFlow, PadWrd);\n   }\n\n   return(1);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Override the floating point precision deduced form the file version        */\n/* with the one read from the GmfFloatingPointPrecision field                 */\n/*----------------------------------------------------------------------------*/\n\nint GmfGetFloatPrecision(int64_t MshIdx)\n{\n   int FltSiz;\n   GmfMshSct *msh = (GmfMshSct *)MshIdx;\n\n   if(GmfStatKwd(MshIdx, GmfFloatingPointPrecision))\n   {\n      GmfGotoKwd(MshIdx, GmfFloatingPointPrecision);\n      GmfGetLin(MshIdx, GmfFloatingPointPrecision, &FltSiz);\n\n      if(FltSiz == 32 || FltSiz == 64)\n         msh->FltSiz = FltSiz;\n   }\n\n   return(msh->FltSiz);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Set the floating point precision arbitrarily, regardless the file version  */\n/*----------------------------------------------------------------------------*/\n\nvoid GmfSetFloatPrecision(int64_t MshIdx , int FltSiz)\n{\n   GmfMshSct *msh = (GmfMshSct *)MshIdx;\n\n   if(FltSiz != 32 && FltSiz != 64)\n      return;\n\n   msh->FltSiz = FltSiz;\n   GmfSetKwd(MshIdx, GmfFloatingPointPrecision, 1);\n   GmfSetLin(MshIdx, GmfFloatingPointPrecision, FltSiz);\n}\n\n#endif\n\n\n/*----------------------------------------------------------------------------*/\n/* Find every kw present in a meshfile                                        */\n/*----------------------------------------------------------------------------*/\n\nstatic int ScaKwdTab(GmfMshSct *msh)\n{\n   int      KwdCod, c;\n   int64_t  NexPos, EndPos, LstPos;\n   char     str[ GmfStrSiz ];\n\n   if(msh->typ & Asc)\n   {\n      // Scan each string in the file until the end\n      while(fscanf(msh->hdl, \"%100s\", str) != EOF)\n      {\n         // Fast test in order to reject quickly the numeric values\n         if(isalpha(str[0]))\n         {\n            // Search which kwd code this string is associated with, then get its\n            // header and save the curent position in file (just before the data)\n            for(KwdCod=1; KwdCod<= GmfMaxKwd; KwdCod++)\n               if(!strcmp(str, GmfKwdFmt[ KwdCod ][0]))\n               {\n                  ScaKwdHdr(msh, KwdCod);\n                  break;\n               }\n         }\n         else if(str[0] == '#')\n            while((c = fgetc(msh->hdl)) != '\\n' && c != EOF);\n      }\n   }\n   else\n   {\n      // Get file size\n      EndPos = GetFilSiz(msh);\n      LstPos = -1;\n\n      // Jump through kwd positions in the file\n      do\n      {\n         // Get the kwd code and the next kwd position\n         ScaWrd(msh, ( char *)&KwdCod);\n         NexPos = GetPos(msh);\n\n         // Make sure the flow does not move beyond the file size\n         if(NexPos > EndPos)\n            longjmp(msh->err, -24);\n\n         // And check that it does not move back\n         if(NexPos && (NexPos <= LstPos))\n            longjmp(msh->err, -30);\n\n         LstPos = NexPos;\n\n         // Check if this kwd belongs to this mesh version\n         if( (KwdCod >= 1) && (KwdCod <= GmfMaxKwd) )\n            ScaKwdHdr(msh, KwdCod);\n\n         // Go to the next kwd\n         if(NexPos && !(SetFilPos(msh, NexPos)))\n            longjmp(msh->err, -25);\n\n      }while(NexPos && (KwdCod != GmfEnd));\n   }\n\n   return(1);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Read and setup the keyword's header                                        */\n/*----------------------------------------------------------------------------*/\n\nstatic void ScaKwdHdr(GmfMshSct *msh, int KwdCod)\n{\n   int      i;\n   KwdSct   *kwd = &msh->KwdTab[ KwdCod ];\n\n   if(!strcmp(\"i\", GmfKwdFmt[ KwdCod ][1]))\n      if(msh->typ & Asc)\n         safe_fscanf(msh->hdl, INT64_T_FMT, &kwd->NmbLin, msh->err);\n      else\n         if(msh->ver <= 3)\n         {\n            ScaWrd(msh, (unsigned char *)&i);\n            kwd->NmbLin = i;\n         }\n         else\n            ScaDblWrd(msh, (unsigned char *)&kwd->NmbLin);\n   else\n      kwd->NmbLin = 1;\n\n   if(!strcmp(\"sr\", GmfKwdFmt[ KwdCod ][2])\n   || !strcmp(\"hr\", GmfKwdFmt[ KwdCod ][2]) )\n   {\n      if(msh->typ & Asc)\n      {\n         safe_fscanf(msh->hdl, \"%d\", &kwd->NmbTyp, msh->err);\n\n         for(i=0;i<kwd->NmbTyp;i++)\n            safe_fscanf(msh->hdl, \"%d\", &kwd->TypTab[i], msh->err);\n\n         // Scan two extra fields for HO solutions: deg and nmb Nodes\n         if(!strcmp(\"hr\", GmfKwdFmt[ KwdCod ][2]))\n         {\n            safe_fscanf(msh->hdl, \"%d\", &kwd->deg, msh->err);\n            safe_fscanf(msh->hdl, \"%d\", &kwd->NmbNod, msh->err);\n         }\n         else\n         {\n            kwd->deg = 0;\n            kwd->NmbNod = 1;\n         }\n\n      }\n      else\n      {\n         ScaWrd(msh, (unsigned char *)&kwd->NmbTyp);\n\n         for(i=0;i<kwd->NmbTyp;i++)\n            ScaWrd(msh, (unsigned char *)&kwd->TypTab[i]);\n\n         // Scan two extra fields for HO solutions: deg and nmb Nodes\n         if(!strcmp(\"hr\", GmfKwdFmt[ KwdCod ][2]))\n         {\n            ScaWrd(msh, (unsigned char *)&kwd->deg);\n            ScaWrd(msh, (unsigned char *)&kwd->NmbNod);\n         }\n         else\n         {\n            kwd->deg = 0;\n            kwd->NmbNod = 1;\n         }\n      }\n   }\n\n   ExpFmt(msh, KwdCod);\n   kwd->pos = GetFilPos(msh);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Expand the compacted format and compute the line size                      */\n/*----------------------------------------------------------------------------*/\n\nstatic void ExpFmt(GmfMshSct *msh, int KwdCod)\n{\n   int         i, j, TmpSiz=0, IntWrd, FltWrd;\n   char        chr;\n   const char  *InpFmt = GmfKwdFmt[ KwdCod ][2];\n   KwdSct      *kwd = &msh->KwdTab[ KwdCod ];\n\n   // Set the kwd's type\n   if(!strlen(GmfKwdFmt[ KwdCod ][1]))\n      kwd->typ = InfKwd;\n   else if( !strcmp(InpFmt, \"sr\") || !strcmp(InpFmt, \"hr\") )\n      kwd->typ = SolKwd;\n   else\n      kwd->typ = RegKwd;\n\n   // Get the solution-field's size\n   if(kwd->typ == SolKwd)\n      for(i=0;i<kwd->NmbTyp;i++)\n         switch(kwd->TypTab[i])\n         {\n            case GmfSca    : TmpSiz += 1; break;\n            case GmfVec    : TmpSiz += msh->dim; break;\n            case GmfSymMat : TmpSiz += (msh->dim * (msh->dim+1)) / 2; break;\n            case GmfMat    : TmpSiz += msh->dim * msh->dim; break;\n         }\n\n   // Scan each character from the format string\n   i = kwd->SolSiz = kwd->NmbWrd = 0;\n\n   while(i < (int)strlen(InpFmt))\n   {\n      chr = InpFmt[ i++ ];\n\n      if(chr == 'd')\n      {\n         chr = InpFmt[i++];\n\n         for(j=0;j<msh->dim;j++)\n            kwd->fmt[ kwd->SolSiz++ ] = chr;\n      }\n      else if((chr == 's')||(chr == 'h'))\n      {\n         chr = InpFmt[i++];\n\n         for(j=0;j<TmpSiz;j++)\n            kwd->fmt[ kwd->SolSiz++ ] = chr;\n      }\n      else\n         kwd->fmt[ kwd->SolSiz++ ] = chr;\n   }\n\n   if(msh->FltSiz == 32)\n      FltWrd = 1;\n   else\n      FltWrd = 2;\n\n   if(msh->ver <= 3)\n      IntWrd = 1;\n   else\n      IntWrd = 2;\n\n   for(i=0;i<kwd->SolSiz;i++)\n      switch(kwd->fmt[i])\n      {\n         case 'i' : kwd->NmbWrd += IntWrd; break;\n         case 'c' : kwd->NmbWrd += FilStrSiz; break;\n         case 'r' : kwd->NmbWrd += FltWrd;break;\n      }\n\n   // HO solution: duplicate the format as many times as the number of nodes\n   if( !strcmp(InpFmt, \"hr\") && (kwd->NmbNod > 1) )\n   {\n      for(i=1;i<=kwd->NmbNod;i++)\n         for(j=0;j<kwd->SolSiz;j++)\n            kwd->fmt[ i * kwd->SolSiz + j ] = kwd->fmt[j];\n\n      kwd->SolSiz *= kwd->NmbNod;\n      kwd->NmbWrd *= kwd->NmbNod;\n   }\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Read a four bytes word from a mesh file                                    */\n/*----------------------------------------------------------------------------*/\n\nstatic void ScaWrd(GmfMshSct *msh, void *ptr)\n{\n#ifdef WITH_GMF_AIO\n   if(read(msh->FilDes, ptr, WrdSiz) != WrdSiz)\n#else\n   if(fread(ptr, WrdSiz, 1, msh->hdl) != 1)\n#endif\n      longjmp(msh->err, -26);\n\n   if(msh->cod != 1)\n      SwpWrd((char *)ptr, WrdSiz);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Read an eight bytes word from a mesh file                                  */\n/*----------------------------------------------------------------------------*/\n\nstatic void ScaDblWrd(GmfMshSct *msh, void *ptr)\n{\n#ifdef WITH_GMF_AIO\n   if(read(msh->FilDes, ptr, WrdSiz * 2) != WrdSiz * 2)\n#else\n   if( fread(ptr, WrdSiz, 2, msh->hdl) != 2 )\n#endif\n      longjmp(msh->err, -27);\n\n   if(msh->cod != 1)\n      SwpWrd((char *)ptr, 2 * WrdSiz);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Read a 4 or 8 bytes position in mesh file                                  */\n/*----------------------------------------------------------------------------*/\n\nstatic int64_t GetPos(GmfMshSct *msh)\n{\n   int      IntVal;\n   int64_t  pos;\n\n   if(msh->ver >= 3)\n      ScaDblWrd(msh, (unsigned char*)&pos);\n   else\n   {\n      ScaWrd(msh, (unsigned char*)&IntVal);\n      pos = (int64_t)IntVal;\n   }\n\n   return(pos);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Write a four bytes word to a mesh file                                     */\n/*----------------------------------------------------------------------------*/\n\nstatic void RecWrd(GmfMshSct *msh, const void *wrd)\n{\n   // [Bruno] added error control\n#ifdef WITH_GMF_AIO\n   if(write(msh->FilDes, wrd, WrdSiz) != WrdSiz)\n#else\n   if(fwrite(wrd, WrdSiz, 1, msh->hdl) != 1)\n#endif\n      longjmp(msh->err,-28);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Write an eight bytes word to a mesh file                                   */\n/*----------------------------------------------------------------------------*/\n\nstatic void RecDblWrd(GmfMshSct *msh, const void *wrd)\n{\n   // [Bruno] added error control\n#ifdef WITH_GMF_AIO\n   if(write(msh->FilDes, wrd, WrdSiz * 2) != WrdSiz*2)\n#else\n   if(fwrite(wrd, WrdSiz, 2, msh->hdl) != 2)\n#endif\n      longjmp(msh->err,-29);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Write a block of four bytes word to a mesh file                            */\n/*----------------------------------------------------------------------------*/\n\nstatic void RecBlk(GmfMshSct *msh, const void *blk, int siz)\n{\n   // Copy this line-block into the main mesh buffer\n   if(siz)\n   {\n      memcpy(&msh->blk[ msh->pos ], blk, (size_t)(siz * WrdSiz));\n      msh->pos += siz * WrdSiz;\n   }\n\n   // When the buffer is full or this procedure is APIF77ed with a 0 size,\n   // flush the cache on disk\n\n   if( (msh->pos > BufSiz) || (!siz && msh->pos) )\n   {\n#ifdef GMF_WINDOWS\n      /*\n       *   [Bruno] TODO: check that msh->pos is smaller\n       * than 4G (fits in 32 bits).\n       *   Note: for now, when trying to write more than 4Gb, it will\n       * trigger an error (longjmp).\n       *   As far as I understand:\n       *   Given that this function just flushes the cache, and given that\n       * the cache size is 10000 words, this is much much smaller than 4Gb\n       * so there is probably no problem.\n       */\n#ifdef WITH_GMF_AIO\n      if(write(msh->FilDes, msh->blk, (int)msh->pos) != (ssize_t)msh->pos)\n#else      \n      if(fwrite(msh->blk, 1, (size_t)msh->pos, msh->hdl) != msh->pos)\n#endif      \n         longjmp(msh->err, -30);\n#else      \n#ifdef WITH_GMF_AIO\n      if(write(msh->FilDes, msh->blk, msh->pos) != (ssize_t)msh->pos)\n#else      \n      if(fwrite(msh->blk, 1, msh->pos, msh->hdl) != msh->pos)\n#endif      \n         longjmp(msh->err, -31);\n#endif      \n      msh->pos = 0;\n   }\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Write a 4 or 8 bytes position in a mesh file                               */\n/*----------------------------------------------------------------------------*/\n\nstatic void SetPos(GmfMshSct *msh, int64_t pos)\n{\n   int IntVal;\n\n   if(msh->ver >= 3)\n      RecDblWrd(msh, (unsigned char*)&pos);\n   else\n   {\n      IntVal = (int)pos;\n      RecWrd(msh, (unsigned char*)&IntVal);\n   }\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Endianness conversion                                                      */\n/*----------------------------------------------------------------------------*/\n\nstatic void SwpWrd(char *wrd, int siz)\n{\n   char  swp;\n   int   i;\n\n   for(i=0;i<siz/2;i++)\n   {\n      swp = wrd[ siz-i-1 ];\n      wrd[ siz-i-1 ] = wrd[i];\n      wrd[i] = swp;\n   }\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Set current position in a file                                             */\n/*----------------------------------------------------------------------------*/\n\nstatic int SetFilPos(GmfMshSct *msh, int64_t pos)\n{\n#ifdef WITH_GMF_AIO\n   if(msh->typ & Bin)\n      return((lseek(msh->FilDes, (off_t)pos, 0) != -1));\n   else\n      return((MYFSEEK(msh->hdl, (off_t)pos, SEEK_SET) == 0));\n#else\n   return((MYFSEEK(msh->hdl, (off_t)pos, SEEK_SET) == 0));\n#endif\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Get current position in a file                                             */\n/*----------------------------------------------------------------------------*/\n\nstatic int64_t GetFilPos(GmfMshSct *msh)\n{\n#ifdef WITH_GMF_AIO\n   if(msh->typ & Bin)\n      return(lseek(msh->FilDes, 0, 1));\n   else\n      return(MYFTELL(msh->hdl));\n#else\n   return(MYFTELL(msh->hdl));\n#endif\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Move the position to the end of file and return the size                   */\n/*----------------------------------------------------------------------------*/\n\nstatic int64_t GetFilSiz(GmfMshSct *msh)\n{\n   int64_t CurPos, EndPos = 0;\n\n   if(msh->typ & Bin)\n   {\n#ifdef WITH_GMF_AIO\n      CurPos = lseek(msh->FilDes, 0, 1);\n      EndPos = lseek(msh->FilDes, 0, 2);\n      lseek(msh->FilDes, (off_t)CurPos, 0);\n#else\n      CurPos = MYFTELL(msh->hdl);\n\n      if(MYFSEEK(msh->hdl, 0, SEEK_END) != 0)\n         longjmp(msh->err, -32);\n\n      EndPos = MYFTELL(msh->hdl);\n\n      if(MYFSEEK(msh->hdl, (off_t)CurPos, SEEK_SET) != 0)\n         longjmp(msh->err, -33);\n#endif\n   }\n   else\n   {\n      CurPos = MYFTELL(msh->hdl);\n\n      if(MYFSEEK(msh->hdl, 0, SEEK_END) != 0)\n         longjmp(msh->err, -34);\n\n      EndPos = MYFTELL(msh->hdl);\n\n      if(MYFSEEK(msh->hdl, (off_t)CurPos, SEEK_SET) != 0)\n         longjmp(msh->err, -35);\n   }\n\n   return(EndPos);\n}\n\n\n/*----------------------------------------------------------------------------*/\n/* Fortran 77 API                                                             */\n/*----------------------------------------------------------------------------*/\n\n#ifdef F77API\n\nint64_t APIF77(gmfopenmesh)(  char *FilNam, int *mod,\n                              int *ver, int *dim, int StrSiz )\n{\n   int   i = 0;\n   char  TmpNam[ GmfStrSiz ];\n\n   if(StrSiz <= 0)\n      return(0);\n\n   // Trim trailing spaces from the fortran string\n   while(isspace(FilNam[ StrSiz-1 ]))\n      StrSiz--;\n\n   for(i=0;i<StrSiz;i++)\n      TmpNam[i] = FilNam[i];\n\n   TmpNam[ StrSiz ] = 0;\n\n   if(*mod == GmfRead)\n      return(GmfOpenMesh(TmpNam, *mod, ver, dim));\n   else\n      return(GmfOpenMesh(TmpNam, *mod, *ver, *dim));\n}\n\nint APIF77(gmfclosemesh)(int64_t *idx)\n{\n   return(GmfCloseMesh(*idx));\n}\n\nint APIF77(gmfgotokwd)(int64_t *MshIdx, int *KwdIdx)\n{\n   return(GmfGotoKwd(*MshIdx, *KwdIdx));\n}\n\nint APIF77(gmfstatkwd)( int64_t *MshIdx, int *KwdIdx, int *NmbTyp,\n                        int *SolSiz, int *TypTab,  int *deg, int *NmbNod)\n{\n   if(!strcmp(GmfKwdFmt[ *KwdIdx ][2], \"hr\"))\n      return(GmfStatKwd(*MshIdx, *KwdIdx, NmbTyp, SolSiz, TypTab, deg, NmbNod));\n   else if(!strcmp(GmfKwdFmt[ *KwdIdx ][2], \"sr\"))\n      return(GmfStatKwd(*MshIdx, *KwdIdx, NmbTyp, SolSiz, TypTab));\n   else\n      return(GmfStatKwd(*MshIdx, *KwdIdx));\n}\n\nint APIF77(gmfsetkwd)(  int64_t *MshIdx, int *KwdIdx, int *NmbLin,\n                        int *NmbTyp, int *TypTab, int *deg, int *NmbNod)\n{\n   if(!strcmp(GmfKwdFmt[ *KwdIdx ][2], \"hr\"))\n      return(GmfSetKwd(*MshIdx, *KwdIdx, *NmbLin, *NmbTyp, TypTab, *deg, *NmbNod));\n   else if(!strcmp(GmfKwdFmt[ *KwdIdx ][2], \"sr\"))\n      return(GmfSetKwd(*MshIdx, *KwdIdx, *NmbLin, *NmbTyp, TypTab));\n   else\n      return(GmfSetKwd(*MshIdx, *KwdIdx, *NmbLin));\n}\n\n\nint APIF77(gmfsethonodesordering)(int64_t *MshIdx, int *KwdCod, int *BasTab, int *OrdTab)\n{\n   return(GmfSetHONodesOrdering(*MshIdx, *KwdCod, BasTab, OrdTab));\n}\n/*\nint APIF77(gmfreadbyteflow)(int64_t *MshIdx, char *BytFlo, int *NmbByt)\n{\n   int TmpNmb;\n   char *TmpFlo;\n\n   TmpFlo = GmfReadByteFlow(*MshIdx, &TmpNmb);\n\n   if(!TmpFlo || NmbByt <= 0 || !BytFlo || TmpNmb > *NmbByt)\n      return(0);\n\n   *NmbByt = TmpNmb;\n   memcpy(BytFlo, TmpFlo, *NmbByt);\n   free(TmpFlo);\n\n   return(TmpNmb);\n}\n\nint APIF77(gmfwritebyteflow)(int64_t *MshIdx, char *BytFlo, int *NmbByt)\n{\n   return(GmfWriteByteFlow(*MshIdx, BytFlo, *NmbByt));\n}\n\nint APIF77(gmfgetfloatprecision)(int64_t *MshIdx)\n{\n   return(GmfGetFloatPrecision(*MshIdx));\n}\n\nint APIF77(gmfsetfloatprecision)(int64_t *MshIdx, int *FltSiz)\n{\n   GmfSetFloatPrecision(*MshIdx, *FltSiz);\n   return(0);\n}\n*/\n\n/*----------------------------------------------------------------------------*/\n/* Duplication macros                                                         */\n/*----------------------------------------------------------------------------*/\n\n#define DUP(s,n) DUP ## n (s)\n#define DUP1(s) s\n#define DUP2(s) DUP1(s),s\n#define DUP3(s) DUP2(s),s\n#define DUP4(s) DUP3(s),s\n#define DUP5(s) DUP4(s),s\n#define DUP6(s) DUP5(s),s\n#define DUP7(s) DUP6(s),s\n#define DUP8(s) DUP7(s),s\n#define DUP9(s) DUP8(s),s\n#define DUP10(s) DUP9(s),s\n#define DUP11(s) DUP10(s),s\n#define DUP12(s) DUP11(s),s\n#define DUP13(s) DUP12(s),s\n#define DUP14(s) DUP13(s),s\n#define DUP15(s) DUP14(s),s\n#define DUP16(s) DUP15(s),s\n#define DUP17(s) DUP16(s),s\n#define DUP18(s) DUP17(s),s\n#define DUP19(s) DUP18(s),s\n#define DUP20(s) DUP19(s),s\n\n\n#define ARG(a,n) ARG ## n (a)\n#define ARG1(a) a[0]\n#define ARG2(a) ARG1(a),a[1]\n#define ARG3(a) ARG2(a),a[2]\n#define ARG4(a) ARG3(a),a[3]\n#define ARG5(a) ARG4(a),a[4]\n#define ARG6(a) ARG5(a),a[5]\n#define ARG7(a) ARG6(a),a[6]\n#define ARG8(a) ARG7(a),a[7]\n#define ARG9(a) ARG8(a),a[8]\n#define ARG10(a) ARG9(a),a[9]\n#define ARG11(a) ARG10(a),a[10]\n#define ARG12(a) ARG11(a),a[11]\n#define ARG13(a) ARG12(a),a[12]\n#define ARG14(a) ARG13(a),a[13]\n#define ARG15(a) ARG14(a),a[14]\n#define ARG16(a) ARG15(a),a[15]\n#define ARG17(a) ARG16(a),a[16]\n#define ARG18(a) ARG17(a),a[17]\n#define ARG19(a) ARG18(a),a[18]\n#define ARG20(a) ARG19(a),a[19]\n\n\n/*----------------------------------------------------------------------------*/\n/* Call a fortran thread with 1 to 20 arguments                               */\n/*----------------------------------------------------------------------------*/\n\nstatic void CalF77Prc(  int64_t BegIdx, int64_t EndIdx,\n                        void *prc, int NmbArg, void **ArgTab )\n{\n   switch(NmbArg)\n   {\n      case 1 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 1)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 1)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 1));\n      }break;\n\n      case 2 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 2)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 2)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 2));\n      }break;\n\n      case 3 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 3)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 3)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 3));\n      }break;\n\n      case 4 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 4)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 4)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 4));\n      }break;\n\n      case 5 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 5)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 5)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 5));\n      }break;\n\n      case 6 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 6)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 6)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 6));\n      }break;\n\n      case 7 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 7)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 7)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 7));\n      }break;\n\n      case 8 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 8)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 8)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 8));\n      }break;\n\n      case 9 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 9)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 9)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 9));\n      }break;\n\n      case 10 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 10)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 10)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 10));\n      }break;\n\n      case 11 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 11)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 11)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 11));\n      }break;\n\n      case 12 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 12)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 12)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 12));\n      }break;\n\n      case 13 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 13)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 13)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 13));\n      }break;\n\n      case 14 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 14)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 14)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 14));\n      }break;\n\n      case 15 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 15)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 15)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 15));\n      }break;\n\n      case 16 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 16)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 16)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 16));\n      }break;\n\n      case 17 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 17)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 17)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 17));\n      }break;\n\n      case 18 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 18)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 18)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 18));\n      }break;\n\n      case 19 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 19)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 19)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 19));\n      }break;\n\n      case 20 :\n      {\n         void (*prc1)(int64_t *, int64_t *, DUP(void *, 20)) =\n            (void (*)(int64_t *, int64_t *, DUP(void *, 20)))prc;\n         prc1(&BegIdx, &EndIdx, ARG(ArgTab, 20));\n      }break;\n   }\n}\n\n#endif\n"], "filenames": ["examples/test_libmeshb_block_pipeline.f", "sources/libmeshb7.c"], "buggy_code_start_loc": [2, 5], "buggy_code_end_loc": [83, 2543], "fixing_code_start_loc": [2, 5], "fixing_code_end_loc": [84, 2543], "type": "CWE-120", "message": "A buffer overflow in the GmfOpenMesh() function of libMeshb v7.61 allows attackers to cause a Denial of Service (DoS) via a crafted MESH file.", "other": {"cve": {"id": "CVE-2021-46225", "sourceIdentifier": "cve@mitre.org", "published": "2022-01-12T20:15:08.610", "lastModified": "2022-01-15T02:18:15.600", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A buffer overflow in the GmfOpenMesh() function of libMeshb v7.61 allows attackers to cause a Denial of Service (DoS) via a crafted MESH file."}, {"lang": "es", "value": "Un desbordamiento de b\u00fafer en la funci\u00f3n GmfOpenMesh() de libMeshb versi\u00f3n v7.61 permite a atacantes causar una denegaci\u00f3n de servicio (DoS) por medio de un archivo MESH dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libmeshb_project:libmeshb:7.61:*:*:*:*:*:*:*", "matchCriteriaId": "E4B4BDFC-B828-4503-860B-65E2AE948767"}]}]}], "references": [{"url": "https://github.com/LoicMarechal/libMeshb/commit/8cd68c54e0647c0030ae4506a225ad4a2655c316", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LoicMarechal/libMeshb/issues/21", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LoicMarechal/libMeshb/commit/8cd68c54e0647c0030ae4506a225ad4a2655c316"}}